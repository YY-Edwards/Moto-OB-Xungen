
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ad14  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000e2b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000ecf8  0000f244  2**0
                  ALLOC
  7 .bss          00004988  00000a48  8000ecf8  0000f248  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f244  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001720  00000000  00000000  0000f278  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000371f  00000000  00000000  00010998  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002dbf5  00000000  00000000  000140b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000076d3  00000000  00000000  00041cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d8bc  00000000  00000000  0004937f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003e54  00000000  00000000  00056c3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000080b5  00000000  00000000  0005aa90  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f727  00000000  00000000  00062b45  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017d8  00000000  00000000  00072270  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 54 	sub	pc,pc,-15532

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e f0       	mov	r0,-17
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 8c       	sub	r12,-72
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6c 44       	ld.w	r4,r6[0x10]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	70 08       	ld.w	r8,r8[0x0]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 54       	eor	r4,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	70 08       	ld.w	r8,r8[0x0]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 4b       	or	r11,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	70 08       	ld.w	r8,r8[0x0]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	70 08       	ld.w	r8,r8[0x0]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	70 08       	ld.w	r8,r8[0x0]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	70 08       	ld.w	r8,r8[0x0]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	70 08       	ld.w	r8,r8[0x0]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d1 00       	acall	0x10
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	70 08       	ld.w	r8,r8[0x0]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d1 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d1 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d1 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	70 08       	ld.w	r8,r8[0x0]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d1 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d1 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d1 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d1 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d1 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d2 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 40       	acall	0x24

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d2 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	70 08       	ld.w	r8,r8[0x0]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d1 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d2 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	70 08       	ld.w	r8,r8[0x0]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c0       	acall	0x2c
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d2 d0       	acall	0x2d
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 e0       	acall	0x2e
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	d2 f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	70 08       	ld.w	r8,r8[0x0]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 4d       	or	sp,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d3 10       	acall	0x31
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	70 08       	ld.w	r8,r8[0x0]
80002404:	00 00       	add	r0,r0
80002406:	0a 4c       	or	r12,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d3 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	70 08       	ld.w	r8,r8[0x0]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 b0       	acall	0x3b
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	70 08       	ld.w	r8,r8[0x0]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c0       	acall	0x3c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d3 d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	70 08       	ld.w	r8,r8[0x0]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d4 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	70 08       	ld.w	r8,r8[0x0]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 50       	acall	0x45
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	70 08       	ld.w	r8,r8[0x0]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 60       	acall	0x46

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d4 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	70 08       	ld.w	r8,r8[0x0]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 5c       	eor	r12,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d4 80       	acall	0x48
800025cc:	00 00       	add	r0,r0
800025ce:	0a 4d       	or	sp,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	70 08       	ld.w	r8,r8[0x0]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d4 b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 00       	acall	0x50
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 30       	acall	0x53

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 40       	acall	0x54
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	70 08       	ld.w	r8,r8[0x0]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	d5 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 80       	acall	0x58

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	70 08       	ld.w	r8,r8[0x0]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b0       	acall	0x5b
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d5 c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d5 f0       	acall	0x5f
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	70 08       	ld.w	r8,r8[0x0]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d5 fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	69 34       	ld.w	r4,r4[0x4c]
80002828:	00 00       	add	r0,r0
8000282a:	0a 58       	eor	r8,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 50       	eor	r0,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0b 6c       	ld.uh	r12,--r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 98       	ld.ub	r8,r6[0x1]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 56       	eor	r6,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	40 7c       	lddsp	r12,sp[0x1c]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d6 08       	*unknown*
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	70 08       	ld.w	r8,r8[0x0]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d6 1c       	*unknown*
80002850:	00 00       	add	r0,r0
80002852:	0d 9c       	ld.ub	r12,r6[0x1]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	d6 2c       	*unknown*
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	d6 58       	*unknown*
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	3f 44       	mov	r4,-12
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	61 c4       	ld.w	r4,r0[0x70]
80002864:	00 00       	add	r0,r0
80002866:	0b 74       	ld.ub	r4,--r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	2c 0c       	sub	r12,-64
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d6 68       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d6 78       	*unknown*
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	6a e4       	ld.w	r4,r5[0x38]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	d6 88       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	70 08       	ld.w	r8,r8[0x0]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 56       	eor	r6,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	40 7c       	lddsp	r12,sp[0x1c]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	6a 9c       	ld.w	r12,r5[0x24]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	50 50       	stdsp	sp[0x14],r0

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d6 a8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	70 08       	ld.w	r8,r8[0x0]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	d6 bc       	*unknown*
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	d6 d4       	*unknown*
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d6 f0       	acall	0x6f
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	d7 08       	*unknown*
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	d7 14       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	78 8c       	ld.w	r12,r12[0x20]
800029b4:	00 00       	add	r0,r0
800029b6:	0b 74       	ld.ub	r4,--r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	2d b8       	sub	r8,-37
800029bc:	00 00       	add	r0,r0
800029be:	0b 6c       	ld.uh	r12,--r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	63 d0       	ld.w	r0,r1[0x74]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	d7 2c       	*unknown*

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0d 98       	ld.ub	r8,r6[0x1]
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	3f d0       	mov	r0,-3

80002a00 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002a00:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80002a02:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002a04:	30 0a       	mov	r10,0
80002a06:	32 8b       	mov	r11,40
80002a08:	49 5c       	lddpc	r12,80002a5c <xg_rtc_init+0x5c>
80002a0a:	f0 1f 00 16 	mcall	80002a60 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80002a0e:	30 ea       	mov	r10,14
80002a10:	30 1b       	mov	r11,1
80002a12:	fe 7c 0d 00 	mov	r12,-62208
80002a16:	f0 1f 00 14 	mcall	80002a64 <xg_rtc_init+0x64>
80002a1a:	c0 41       	brne	80002a22 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80002a1c:	49 3c       	lddpc	r12,80002a68 <xg_rtc_init+0x68>
80002a1e:	f0 1f 00 14 	mcall	80002a6c <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80002a22:	30 0b       	mov	r11,0
80002a24:	fe 7c 0d 00 	mov	r12,-62208
80002a28:	f0 1f 00 12 	mcall	80002a70 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80002a2c:	fe 7c 0d 00 	mov	r12,-62208
80002a30:	f0 1f 00 11 	mcall	80002a74 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002a34:	fe 7c 0d 00 	mov	r12,-62208
80002a38:	f0 1f 00 10 	mcall	80002a78 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002a3c:	49 08       	lddpc	r8,80002a7c <xg_rtc_init+0x7c>
80002a3e:	31 09       	mov	r9,16
80002a40:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002a42:	30 29       	mov	r9,2
80002a44:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002a46:	31 d9       	mov	r9,29
80002a48:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a4a:	31 79       	mov	r9,23
80002a4c:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a4e:	33 b9       	mov	r9,59
80002a50:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a52:	32 89       	mov	r9,40
80002a54:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002a56:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a58:	d8 02       	popm	pc
80002a5a:	00 00       	add	r0,r0
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	2a 80       	sub	r0,-88
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	54 70       	stdsp	sp[0x11c],r0
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	57 bc       	stdsp	sp[0x1ec],r12
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	d7 3c       	*unknown*
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	70 08       	ld.w	r8,r8[0x0]
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	57 78       	stdsp	sp[0x1dc],r8
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	57 70       	stdsp	sp[0x1dc],r0
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	57 4c       	stdsp	sp[0x1d0],r12
80002a7c:	00 00       	add	r0,r0
80002a7e:	0d 9c       	ld.ub	r12,r6[0x1]

80002a80 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a80:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a82:	4b 98       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a84:	11 d9       	ld.ub	r9,r8[0x5]
80002a86:	2f f9       	sub	r9,-1
80002a88:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a8a:	11 d9       	ld.ub	r9,r8[0x5]
80002a8c:	33 b8       	mov	r8,59
80002a8e:	f0 09 18 00 	cp.b	r9,r8
80002a92:	e0 88 00 5f 	brls	80002b50 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a96:	4b 48       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a98:	30 09       	mov	r9,0
80002a9a:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a9c:	11 c9       	ld.ub	r9,r8[0x4]
80002a9e:	2f f9       	sub	r9,-1
80002aa0:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002aa2:	11 c9       	ld.ub	r9,r8[0x4]
80002aa4:	33 b8       	mov	r8,59
80002aa6:	f0 09 18 00 	cp.b	r9,r8
80002aaa:	e0 88 00 53 	brls	80002b50 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002aae:	4a e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ab0:	30 09       	mov	r9,0
80002ab2:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002ab4:	11 b9       	ld.ub	r9,r8[0x3]
80002ab6:	2f f9       	sub	r9,-1
80002ab8:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002aba:	11 b9       	ld.ub	r9,r8[0x3]
80002abc:	31 78       	mov	r8,23
80002abe:	f0 09 18 00 	cp.b	r9,r8
80002ac2:	e0 88 00 47 	brls	80002b50 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002ac6:	4a 88       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ac8:	30 09       	mov	r9,0
80002aca:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002acc:	11 88       	ld.ub	r8,r8[0x0]
80002ace:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002ad2:	e0 69 01 6e 	mov	r9,366
80002ad6:	e0 6a 01 6d 	mov	r10,365
80002ada:	f4 08 17 10 	movne	r8,r10
80002ade:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002ae2:	4a 19       	lddpc	r9,80002b64 <rtc_irq+0xe4>
80002ae4:	13 9a       	ld.ub	r10,r9[0x1]
80002ae6:	30 29       	mov	r9,2
80002ae8:	f2 0a 18 00 	cp.b	r10,r9
80002aec:	c0 b0       	breq	80002b02 <rtc_irq+0x82>
80002aee:	49 e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002af0:	11 99       	ld.ub	r9,r8[0x1]
80002af2:	11 9a       	ld.ub	r10,r8[0x1]
80002af4:	a3 9a       	lsr	r10,0x3
80002af6:	12 0a       	add	r10,r9
80002af8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002afc:	2e 2a       	sub	r10,-30
80002afe:	5c 5a       	castu.b	r10
80002b00:	c0 58       	rjmp	80002b0a <rtc_irq+0x8a>
80002b02:	f0 c8 01 51 	sub	r8,r8,337
80002b06:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002b0a:	49 78       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b0c:	11 a9       	ld.ub	r9,r8[0x2]
80002b0e:	2f f9       	sub	r9,-1
80002b10:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002b12:	11 a8       	ld.ub	r8,r8[0x2]
80002b14:	f0 0a 18 00 	cp.b	r10,r8
80002b18:	c1 c2       	brcc	80002b50 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002b1a:	49 38       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b1c:	30 19       	mov	r9,1
80002b1e:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002b20:	11 99       	ld.ub	r9,r8[0x1]
80002b22:	2f f9       	sub	r9,-1
80002b24:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002b26:	11 99       	ld.ub	r9,r8[0x1]
80002b28:	30 c8       	mov	r8,12
80002b2a:	f0 09 18 00 	cp.b	r9,r8
80002b2e:	e0 88 00 11 	brls	80002b50 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002b32:	48 d8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b34:	30 19       	mov	r9,1
80002b36:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002b38:	11 89       	ld.ub	r9,r8[0x0]
80002b3a:	2f f9       	sub	r9,-1
80002b3c:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002b3e:	11 89       	ld.ub	r9,r8[0x0]
80002b40:	39 68       	mov	r8,-106
80002b42:	f0 09 18 00 	cp.b	r9,r8
80002b46:	e0 88 00 05 	brls	80002b50 <rtc_irq+0xd0>
80002b4a:	30 09       	mov	r9,0
80002b4c:	48 68       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b4e:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b50:	fe 7c 0d 00 	mov	r12,-62208
80002b54:	f0 1f 00 05 	mcall	80002b68 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b58:	30 19       	mov	r9,1
80002b5a:	48 58       	lddpc	r8,80002b6c <rtc_irq+0xec>
80002b5c:	91 09       	st.w	r8[0x0],r9
}
80002b5e:	d4 02       	popm	lr
80002b60:	d6 03       	rete
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0d 9c       	ld.ub	r12,r6[0x1]
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	57 9c       	stdsp	sp[0x1e4],r12
80002b6c:	00 00       	add	r0,r0
80002b6e:	04 f4       	st.b	--r2,r4

80002b70 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b70:	20 1c       	sub	r12,1
80002b72:	5c 5c       	castu.b	r12
80002b74:	31 18       	mov	r8,17
80002b76:	f0 0c 18 00 	cp.b	r12,r8
80002b7a:	e0 88 00 03 	brls	80002b80 <CalculateBurst+0x10>
80002b7e:	5e fd       	retal	0
80002b80:	48 28       	lddpc	r8,80002b88 <CalculateBurst+0x18>
80002b82:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b86:	5e fc       	retal	r12
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	d7 5c       	*unknown*

80002b8c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b8c:	48 38       	lddpc	r8,80002b98 <payload_init+0xc>
80002b8e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b90:	48 38       	lddpc	r8,80002b9c <payload_init+0x10>
80002b92:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b94:	5e fc       	retal	r12
80002b96:	00 00       	add	r0,r0
80002b98:	00 00       	add	r0,r0
80002b9a:	0a 6c       	and	r12,r5
80002b9c:	00 00       	add	r0,r0
80002b9e:	0a 70       	tst	r0,r5

80002ba0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
80002ba4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba6:	30 09       	mov	r9,0
80002ba8:	fa ca ff f8 	sub	r10,sp,-8
80002bac:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bae:	1a 9b       	mov	r11,sp
80002bb0:	f0 1f 00 02 	mcall	80002bb8 <set_idle_store_isr+0x18>
}
80002bb4:	2f ed       	sub	sp,-8
80002bb6:	d8 02       	popm	pc
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	63 80       	ld.w	r0,r1[0x60]

80002bbc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bbc:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002bbe:	48 48       	lddpc	r8,80002bcc <payload_rx+0x10>
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	18 9b       	mov	r11,r12
80002bc4:	10 9c       	mov	r12,r8
80002bc6:	f0 1f 00 03 	mcall	80002bd0 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002bca:	d8 02       	popm	pc
80002bcc:	00 00       	add	r0,r0
80002bce:	0a a8       	st.w	r5++,r8
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	2b a0       	sub	r0,-70

80002bd4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002bd4:	d4 01       	pushm	lr
80002bd6:	20 2d       	sub	sp,8
80002bd8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bda:	58 0c       	cp.w	r12,0
80002bdc:	c1 10       	breq	80002bfe <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bde:	30 08       	mov	r8,0
80002be0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002be2:	98 88       	ld.uh	r8,r12[0x0]
80002be4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002be8:	e0 48 40 00 	cp.w	r8,16384
80002bec:	c0 91       	brne	80002bfe <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bee:	48 68       	lddpc	r8,80002c04 <phy_rx+0x30>
80002bf0:	70 0c       	ld.w	r12,r8[0x0]
80002bf2:	30 09       	mov	r9,0
80002bf4:	fa ca ff fc 	sub	r10,sp,-4
80002bf8:	1a 9b       	mov	r11,sp
80002bfa:	f0 1f 00 04 	mcall	80002c08 <phy_rx+0x34>
		}	

    }
		
 
}
80002bfe:	2f ed       	sub	sp,-8
80002c00:	d8 02       	popm	pc
80002c02:	00 00       	add	r0,r0
80002c04:	00 00       	add	r0,r0
80002c06:	0a b4       	st.h	r5++,r4
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	63 80       	ld.w	r0,r1[0x60]

80002c0c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c0c:	eb cd 40 80 	pushm	r7,lr
80002c10:	20 1d       	sub	sp,4
80002c12:	fa c7 ff fc 	sub	r7,sp,-4
80002c16:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c18:	30 09       	mov	r9,0
80002c1a:	12 9a       	mov	r10,r9
80002c1c:	1a 9b       	mov	r11,sp
80002c1e:	f0 1f 00 03 	mcall	80002c28 <set_idle_store+0x1c>
}
80002c22:	2f fd       	sub	sp,-4
80002c24:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	63 d0       	ld.w	r0,r1[0x74]

80002c2c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c2c:	d4 01       	pushm	lr
80002c2e:	20 1d       	sub	sp,4
80002c30:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c32:	98 88       	ld.uh	r8,r12[0x0]
80002c34:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c38:	e0 48 40 00 	cp.w	r8,16384
80002c3c:	c0 d1       	brne	80002c56 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c3e:	49 08       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c40:	70 08       	ld.w	r8,r8[0x0]
80002c42:	58 08       	cp.w	r8,0
80002c44:	c1 a0       	breq	80002c78 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c46:	48 e8       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c48:	70 0c       	ld.w	r12,r8[0x0]
80002c4a:	30 09       	mov	r9,0
80002c4c:	12 9a       	mov	r10,r9
80002c4e:	1a 9b       	mov	r11,sp
80002c50:	f0 1f 00 0c 	mcall	80002c80 <phy_tx+0x54>
80002c54:	c1 28       	rjmp	80002c78 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c56:	e0 48 10 00 	cp.w	r8,4096
80002c5a:	5f 0a       	sreq	r10
80002c5c:	e0 48 20 00 	cp.w	r8,8192
80002c60:	5f 09       	sreq	r9
80002c62:	f5 e9 10 09 	or	r9,r10,r9
80002c66:	c0 71       	brne	80002c74 <phy_tx+0x48>
80002c68:	e0 48 50 00 	cp.w	r8,20480
80002c6c:	c0 40       	breq	80002c74 <phy_tx+0x48>
80002c6e:	e0 48 60 00 	cp.w	r8,24576
80002c72:	c0 31       	brne	80002c78 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c74:	48 48       	lddpc	r8,80002c84 <phy_tx+0x58>
80002c76:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c78:	2f fd       	sub	sp,-4
80002c7a:	d8 02       	popm	pc
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a d4       	st.w	--r5,r4
80002c80:	80 00       	ld.sh	r0,r0[0x0]
80002c82:	63 d0       	ld.w	r0,r1[0x74]
80002c84:	00 00       	add	r0,r0
80002c86:	0a c8       	st.b	r5++,r8

80002c88 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c88:	d4 01       	pushm	lr
80002c8a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c8c:	30 08       	mov	r8,0
80002c8e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c90:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c92:	1a 9a       	mov	r10,sp
80002c94:	fa cb ff fc 	sub	r11,sp,-4
80002c98:	f0 1f 00 05 	mcall	80002cac <get_idle_store_isr+0x24>
80002c9c:	58 1c       	cp.w	r12,1
80002c9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ca2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ca6:	2f ed       	sub	sp,-8
80002ca8:	d8 02       	popm	pc
80002caa:	00 00       	add	r0,r0
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	60 d4       	ld.w	r4,r0[0x34]

80002cb0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80002cb4:	20 1d       	sub	sp,4
80002cb6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002cb8:	4b a8       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cba:	70 08       	ld.w	r8,r8[0x0]
80002cbc:	58 08       	cp.w	r8,0
80002cbe:	c6 60       	breq	80002d8a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002cc0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cc2:	30 08       	mov	r8,0
80002cc4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cc6:	4b 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002cc8:	70 08       	ld.w	r8,r8[0x0]
80002cca:	58 18       	cp.w	r8,1
80002ccc:	c2 60       	breq	80002d18 <phy_tx_func+0x68>
80002cce:	c0 43       	brcs	80002cd6 <phy_tx_func+0x26>
80002cd0:	58 28       	cp.w	r8,2
80002cd2:	c5 c1       	brne	80002d8a <phy_tx_func+0xda>
80002cd4:	c5 58       	rjmp	80002d7e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002cd6:	4b 38       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cd8:	70 0c       	ld.w	r12,r8[0x0]
80002cda:	1a 9a       	mov	r10,sp
80002cdc:	4b 3b       	lddpc	r11,80002da8 <phy_tx_func+0xf8>
80002cde:	f0 1f 00 34 	mcall	80002dac <phy_tx_func+0xfc>
80002ce2:	58 1c       	cp.w	r12,1
80002ce4:	c1 41       	brne	80002d0c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ce6:	4b 18       	lddpc	r8,80002da8 <phy_tx_func+0xf8>
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	90 08       	ld.sh	r8,r8[0x0]
80002cec:	10 9a       	mov	r10,r8
80002cee:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cf2:	4b 09       	lddpc	r9,80002db0 <phy_tx_func+0x100>
80002cf4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cf6:	5c 78       	castu.h	r8
80002cf8:	ea 18 ab cd 	orh	r8,0xabcd
80002cfc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cfe:	30 19       	mov	r9,1
80002d00:	4a d8       	lddpc	r8,80002db4 <phy_tx_func+0x104>
80002d02:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d04:	30 19       	mov	r9,1
80002d06:	4a 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d08:	91 09       	st.w	r8[0x0],r9
80002d0a:	c4 08       	rjmp	80002d8a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d0c:	e0 68 5a 5a 	mov	r8,23130
80002d10:	ea 18 ab cd 	orh	r8,0xabcd
80002d14:	8f 18       	st.w	r7[0x4],r8
80002d16:	c3 a8       	rjmp	80002d8a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d18:	4a 7a       	lddpc	r10,80002db4 <phy_tx_func+0x104>
80002d1a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d1c:	4a 39       	lddpc	r9,80002da8 <phy_tx_func+0xf8>
80002d1e:	72 09       	ld.w	r9,r9[0x0]
80002d20:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d24:	b1 69       	lsl	r9,0x10
80002d26:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d28:	2f f8       	sub	r8,-1
80002d2a:	5c 58       	castu.b	r8
80002d2c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d2e:	4a 1b       	lddpc	r11,80002db0 <phy_tx_func+0x100>
80002d30:	96 0c       	ld.sh	r12,r11[0x0]
80002d32:	20 2c       	sub	r12,2
80002d34:	5c 8c       	casts.h	r12
80002d36:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d3a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d3c:	30 0b       	mov	r11,0
80002d3e:	f6 0a 19 00 	cp.h	r10,r11
80002d42:	e0 89 00 09 	brgt	80002d54 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d46:	e8 19 00 ba 	orl	r9,0xba
80002d4a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d4c:	30 09       	mov	r9,0
80002d4e:	49 68       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d50:	91 09       	st.w	r8[0x0],r9
80002d52:	c1 c8       	rjmp	80002d8a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d54:	49 5a       	lddpc	r10,80002da8 <phy_tx_func+0xf8>
80002d56:	74 0a       	ld.w	r10,r10[0x0]
80002d58:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d5c:	14 49       	or	r9,r10
80002d5e:	8f 19       	st.w	r7[0x4],r9
80002d60:	2f f8       	sub	r8,-1
80002d62:	49 59       	lddpc	r9,80002db4 <phy_tx_func+0x104>
80002d64:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d66:	20 2c       	sub	r12,2
80002d68:	49 28       	lddpc	r8,80002db0 <phy_tx_func+0x100>
80002d6a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d6c:	30 08       	mov	r8,0
80002d6e:	f0 0c 19 00 	cp.h	r12,r8
80002d72:	e0 89 00 0c 	brgt	80002d8a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d76:	30 29       	mov	r9,2
80002d78:	48 b8       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d7a:	91 09       	st.w	r8[0x0],r9
80002d7c:	c0 78       	rjmp	80002d8a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d7e:	fc 18 00 ba 	movh	r8,0xba
80002d82:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d84:	30 09       	mov	r9,0
80002d86:	48 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d88:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d8a:	e0 68 5a 5a 	mov	r8,23130
80002d8e:	ea 18 ab cd 	orh	r8,0xabcd
80002d92:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d94:	30 08       	mov	r8,0
80002d96:	8f 38       	st.w	r7[0xc],r8
}
80002d98:	2f fd       	sub	sp,-4
80002d9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d9e:	00 00       	add	r0,r0
80002da0:	00 00       	add	r0,r0
80002da2:	0a d4       	st.w	--r5,r4
80002da4:	00 00       	add	r0,r0
80002da6:	0a 94       	mov	r4,r5
80002da8:	00 00       	add	r0,r0
80002daa:	0a a0       	st.w	r5++,r0
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	60 d4       	ld.w	r4,r0[0x34]
80002db0:	00 00       	add	r0,r0
80002db2:	0a bc       	st.h	r5++,r12
80002db4:	00 00       	add	r0,r0
80002db6:	0a 74       	tst	r4,r5

80002db8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002db8:	d4 01       	pushm	lr
80002dba:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002dbc:	30 0a       	mov	r10,0
80002dbe:	fa cb ff fc 	sub	r11,sp,-4
80002dc2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002dc4:	14 99       	mov	r9,r10
80002dc6:	1a 9b       	mov	r11,sp
80002dc8:	f0 1f 00 05 	mcall	80002ddc <get_idle_store+0x24>
80002dcc:	58 1c       	cp.w	r12,1
80002dce:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002dd2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002dd6:	2f fd       	sub	sp,-4
80002dd8:	d8 02       	popm	pc
80002dda:	00 00       	add	r0,r0
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	61 c4       	ld.w	r4,r0[0x70]

80002de0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002de0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002de2:	48 5b       	lddpc	r11,80002df4 <phy_init+0x14>
80002de4:	48 5c       	lddpc	r12,80002df8 <phy_init+0x18>
80002de6:	f0 1f 00 06 	mcall	80002dfc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dea:	f0 1f 00 06 	mcall	80002e00 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dee:	f0 1f 00 06 	mcall	80002e04 <phy_init+0x24>
	
}
80002df2:	d8 02       	popm	pc
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	2c b0       	sub	r0,-53
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2e 08       	sub	r8,-32
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	3e 68       	mov	r8,-26
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	3e 7c       	mov	r12,-25
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	48 28       	lddpc	r8,80002e0c <phy_rx_func+0x4>

80002e08 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e08:	eb cd 40 e0 	pushm	r5-r7,lr
80002e0c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e0e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e12:	70 08       	ld.w	r8,r8[0x0]
80002e14:	58 08       	cp.w	r8,0
80002e16:	e0 80 01 08 	breq	80003026 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e1a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e1c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e20:	70 09       	ld.w	r9,r8[0x0]
80002e22:	2f f9       	sub	r9,-1
80002e24:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e26:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e2a:	70 08       	ld.w	r8,r8[0x0]
80002e2c:	58 18       	cp.w	r8,1
80002e2e:	e0 80 00 85 	breq	80002f38 <phy_rx_func+0x130>
80002e32:	c0 73       	brcs	80002e40 <phy_rx_func+0x38>
80002e34:	58 28       	cp.w	r8,2
80002e36:	c5 c0       	breq	80002eee <phy_rx_func+0xe6>
80002e38:	58 38       	cp.w	r8,3
80002e3a:	e0 81 00 f6 	brne	80003026 <phy_rx_func+0x21e>
80002e3e:	cd 58       	rjmp	80002fe8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e40:	e0 6a 5a 5a 	mov	r10,23130
80002e44:	ea 1a ab cd 	orh	r10,0xabcd
80002e48:	14 36       	cp.w	r6,r10
80002e4a:	e0 80 00 ee 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e4e:	ec 08 16 10 	lsr	r8,r6,0x10
80002e52:	e0 48 ab cd 	cp.w	r8,43981
80002e56:	e0 81 00 e8 	brne	80003026 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e5a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e5e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e62:	20 28       	sub	r8,2
80002e64:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e68:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e6a:	30 09       	mov	r9,0
80002e6c:	f2 08 19 00 	cp.h	r8,r9
80002e70:	e0 8a 00 db 	brle	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e74:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e78:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e7a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e7e:	70 0c       	ld.w	r12,r8[0x0]
80002e80:	f0 1f 03 88 	mcall	80003ca0 <phy_rx_func+0xe98>
80002e84:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e88:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e8a:	58 0c       	cp.w	r12,0
80002e8c:	e0 80 00 cd 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e90:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e94:	90 09       	ld.sh	r9,r8[0x0]
80002e96:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e9a:	2f f9       	sub	r9,-1
80002e9c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e9e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002ea2:	74 0a       	ld.w	r10,r10[0x0]
80002ea4:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ea8:	76 0b       	ld.w	r11,r11[0x0]
80002eaa:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002eae:	2f f9       	sub	r9,-1
80002eb0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002eb2:	e2 16 0f 00 	andl	r6,0xf00,COH
80002eb6:	e0 46 01 00 	cp.w	r6,256
80002eba:	c0 c0       	breq	80002ed2 <phy_rx_func+0xca>
80002ebc:	e0 8b 00 05 	brhi	80002ec6 <phy_rx_func+0xbe>
80002ec0:	58 06       	cp.w	r6,0
80002ec2:	c0 80       	breq	80002ed2 <phy_rx_func+0xca>
80002ec4:	c0 c8       	rjmp	80002edc <phy_rx_func+0xd4>
80002ec6:	e0 46 02 00 	cp.w	r6,512
80002eca:	c0 40       	breq	80002ed2 <phy_rx_func+0xca>
80002ecc:	e0 46 03 00 	cp.w	r6,768
80002ed0:	c0 61       	brne	80002edc <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ed2:	30 29       	mov	r9,2
80002ed4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002ed8:	91 09       	st.w	r8[0x0],r9
80002eda:	ca 68       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002edc:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002ee0:	70 0c       	ld.w	r12,r8[0x0]
80002ee2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002ee6:	70 0b       	ld.w	r11,r8[0x0]
80002ee8:	f0 1f 03 70 	mcall	80003ca8 <phy_rx_func+0xea0>
80002eec:	c9 d8       	rjmp	80003026 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eee:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002ef2:	b1 86       	lsr	r6,0x10
80002ef4:	14 06       	add	r6,r10
80002ef6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002efa:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002efc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f00:	90 09       	ld.sh	r9,r8[0x0]
80002f02:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f06:	76 0b       	ld.w	r11,r11[0x0]
80002f08:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f0c:	2f f9       	sub	r9,-1
80002f0e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f10:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f14:	92 08       	ld.sh	r8,r9[0x0]
80002f16:	20 28       	sub	r8,2
80002f18:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f1a:	30 09       	mov	r9,0
80002f1c:	f2 08 19 00 	cp.h	r8,r9
80002f20:	e0 8a 00 07 	brle	80002f2e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f24:	30 19       	mov	r9,1
80002f26:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f2a:	91 09       	st.w	r8[0x0],r9
80002f2c:	c7 d8       	rjmp	80003026 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f2e:	30 39       	mov	r9,3
80002f30:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f34:	91 09       	st.w	r8[0x0],r9
80002f36:	c7 88       	rjmp	80003026 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f38:	ec 0a 14 10 	asr	r10,r6,0x10
80002f3c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f40:	90 09       	ld.sh	r9,r8[0x0]
80002f42:	14 09       	add	r9,r10
80002f44:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f46:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f4a:	92 08       	ld.sh	r8,r9[0x0]
80002f4c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f50:	76 0b       	ld.w	r11,r11[0x0]
80002f52:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f56:	2f f8       	sub	r8,-1
80002f58:	5c 88       	casts.h	r8
80002f5a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f5c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f60:	94 09       	ld.sh	r9,r10[0x0]
80002f62:	20 29       	sub	r9,2
80002f64:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f66:	30 0a       	mov	r10,0
80002f68:	f4 09 19 00 	cp.h	r9,r10
80002f6c:	e0 89 00 20 	brgt	80002fac <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f70:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f74:	e0 46 00 ba 	cp.w	r6,186
80002f78:	c0 d1       	brne	80002f92 <phy_rx_func+0x18a>
80002f7a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f7e:	90 09       	ld.sh	r9,r8[0x0]
80002f80:	f4 09 19 00 	cp.h	r9,r10
80002f84:	c0 71       	brne	80002f92 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f86:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f8a:	70 0c       	ld.w	r12,r8[0x0]
80002f8c:	f0 1f 03 49 	mcall	80003cb0 <phy_rx_func+0xea8>
80002f90:	c0 98       	rjmp	80002fa2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f92:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f96:	70 0c       	ld.w	r12,r8[0x0]
80002f98:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f9c:	70 0b       	ld.w	r11,r8[0x0]
80002f9e:	f0 1f 03 43 	mcall	80003ca8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002fa2:	30 09       	mov	r9,0
80002fa4:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002fa8:	91 09       	st.w	r8[0x0],r9
80002faa:	c3 e8       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002fac:	5c 86       	casts.h	r6
80002fae:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002fb2:	92 0a       	ld.sh	r10,r9[0x0]
80002fb4:	0c 0a       	add	r10,r6
80002fb6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fb8:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002fbc:	72 09       	ld.w	r9,r9[0x0]
80002fbe:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002fc2:	2f f8       	sub	r8,-1
80002fc4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002fc8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002fca:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002fce:	92 08       	ld.sh	r8,r9[0x0]
80002fd0:	20 28       	sub	r8,2
80002fd2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fd4:	30 09       	mov	r9,0
80002fd6:	f2 08 19 00 	cp.h	r8,r9
80002fda:	e0 89 00 26 	brgt	80003026 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fde:	30 39       	mov	r9,3
80002fe0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fe4:	91 09       	st.w	r8[0x0],r9
80002fe6:	c2 08       	rjmp	80003026 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fe8:	e6 16 00 ff 	andh	r6,0xff,COH
80002fec:	fc 19 00 ba 	movh	r9,0xba
80002ff0:	12 36       	cp.w	r6,r9
80002ff2:	c0 e1       	brne	8000300e <phy_rx_func+0x206>
80002ff4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ff8:	90 09       	ld.sh	r9,r8[0x0]
80002ffa:	30 08       	mov	r8,0
80002ffc:	f0 09 19 00 	cp.h	r9,r8
80003000:	c0 71       	brne	8000300e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003002:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003006:	70 0c       	ld.w	r12,r8[0x0]
80003008:	f0 1f 03 2a 	mcall	80003cb0 <phy_rx_func+0xea8>
8000300c:	c0 98       	rjmp	8000301e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000300e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003012:	70 0c       	ld.w	r12,r8[0x0]
80003014:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003018:	70 0b       	ld.w	r11,r8[0x0]
8000301a:	f0 1f 03 24 	mcall	80003ca8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000301e:	30 09       	mov	r9,0
80003020:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003024:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003026:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000302a:	11 89       	ld.ub	r9,r8[0x0]
8000302c:	30 08       	mov	r8,0
8000302e:	f0 09 18 00 	cp.b	r9,r8
80003032:	c1 31       	brne	80003058 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003034:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003038:	6c 0c       	ld.w	r12,r6[0x0]
8000303a:	f0 1f 03 1a 	mcall	80003ca0 <phy_rx_func+0xe98>
8000303e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003042:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003044:	6c 0c       	ld.w	r12,r6[0x0]
80003046:	f0 1f 03 17 	mcall	80003ca0 <phy_rx_func+0xe98>
8000304a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000304e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003050:	30 19       	mov	r9,1
80003052:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003056:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003058:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	58 28       	cp.w	r8,2
80003060:	e0 80 01 98 	breq	80003390 <phy_rx_func+0x588>
80003064:	e0 8b 00 06 	brhi	80003070 <phy_rx_func+0x268>
80003068:	58 08       	cp.w	r8,0
8000306a:	c0 b0       	breq	80003080 <phy_rx_func+0x278>
8000306c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003070:	58 38       	cp.w	r8,3
80003072:	e0 80 05 c5 	breq	80003bfc <phy_rx_func+0xdf4>
80003076:	58 48       	cp.w	r8,4
80003078:	e0 81 06 05 	brne	80003c82 <phy_rx_func+0xe7a>
8000307c:	e0 8f 02 4b 	bral	80003512 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003080:	6e 28       	ld.w	r8,r7[0x8]
80003082:	e0 6a 5a 5a 	mov	r10,23130
80003086:	ea 1a ab cd 	orh	r10,0xabcd
8000308a:	14 38       	cp.w	r8,r10
8000308c:	c0 71       	brne	8000309a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000308e:	30 09       	mov	r9,0
80003090:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003094:	91 09       	st.w	r8[0x0],r9
80003096:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000309a:	10 99       	mov	r9,r8
8000309c:	e0 19 00 00 	andl	r9,0x0
800030a0:	fc 1a ab cd 	movh	r10,0xabcd
800030a4:	14 39       	cp.w	r9,r10
800030a6:	e0 81 05 ee 	brne	80003c82 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800030aa:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800030ae:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800030b2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800030b4:	6e 29       	ld.w	r9,r7[0x8]
800030b6:	e2 19 f0 00 	andl	r9,0xf000,COH
800030ba:	e0 49 c0 00 	cp.w	r9,49152
800030be:	e0 81 00 ce 	brne	8000325a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800030c2:	30 1a       	mov	r10,1
800030c4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030c8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030ca:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030ce:	72 09       	ld.w	r9,r9[0x0]
800030d0:	58 09       	cp.w	r9,0
800030d2:	c0 71       	brne	800030e0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030d4:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030d8:	f0 1f 03 00 	mcall	80003cd8 <phy_rx_func+0xed0>
800030dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030e0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030e4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030e8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030ea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030ee:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030f2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030f6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030f8:	13 89       	ld.ub	r9,r9[0x0]
800030fa:	37 fa       	mov	r10,127
800030fc:	f4 09 18 00 	cp.b	r9,r10
80003100:	c6 d0       	breq	800031da <phy_rx_func+0x3d2>
80003102:	e0 8b 00 0c 	brhi	8000311a <phy_rx_func+0x312>
80003106:	31 2a       	mov	r10,18
80003108:	f4 09 18 00 	cp.b	r9,r10
8000310c:	c4 20       	breq	80003190 <phy_rx_func+0x388>
8000310e:	31 3a       	mov	r10,19
80003110:	f4 09 18 00 	cp.b	r9,r10
80003114:	e0 81 00 83 	brne	8000321a <phy_rx_func+0x412>
80003118:	c5 b8       	rjmp	800031ce <phy_rx_func+0x3c6>
8000311a:	2f 09       	sub	r9,-16
8000311c:	30 1a       	mov	r10,1
8000311e:	f4 09 18 00 	cp.b	r9,r10
80003122:	e0 8b 00 7c 	brhi	8000321a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003126:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000312a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000312e:	59 08       	cp.w	r8,16
80003130:	c0 71       	brne	8000313e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003132:	30 19       	mov	r9,1
80003134:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003138:	91 09       	st.w	r8[0x0],r9
8000313a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000313e:	e0 48 00 20 	cp.w	r8,32
80003142:	c2 11       	brne	80003184 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003144:	30 a9       	mov	r9,10
80003146:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000314a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000314c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003150:	6c 08       	ld.w	r8,r6[0x0]
80003152:	f0 0a 11 ff 	rsub	r10,r8,-1
80003156:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000315a:	2f f8       	sub	r8,-1
8000315c:	6e 0c       	ld.w	r12,r7[0x0]
8000315e:	f4 ca fe 00 	sub	r10,r10,-512
80003162:	30 0b       	mov	r11,0
80003164:	10 0c       	add	r12,r8
80003166:	f0 1f 02 e1 	mcall	80003ce8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000316a:	30 08       	mov	r8,0
8000316c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000316e:	6e 0c       	ld.w	r12,r7[0x0]
80003170:	f0 1f 02 df 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003174:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003178:	70 0c       	ld.w	r12,r8[0x0]
8000317a:	f0 1f 02 ca 	mcall	80003ca0 <phy_rx_func+0xe98>
8000317e:	8f 0c       	st.w	r7[0x0],r12
80003180:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003184:	30 09       	mov	r9,0
80003186:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003190:	20 48       	sub	r8,4
80003192:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003196:	93 08       	st.w	r9[0x0],r8
80003198:	58 08       	cp.w	r8,0
8000319a:	e0 80 05 74 	breq	80003c82 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000319e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800031a2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800031a6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800031aa:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800031ac:	8e 69       	ld.sh	r9,r7[0xc]
800031ae:	fe f8 0b 46 	ld.w	r8,pc[2886]
800031b2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800031b4:	8e 79       	ld.sh	r9,r7[0xe]
800031b6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800031b8:	f0 1f 02 d0 	mcall	80003cf8 <phy_rx_func+0xef0>
800031bc:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800031c0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800031c2:	30 49       	mov	r9,4
800031c4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031c8:	91 09       	st.w	r8[0x0],r9
800031ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031ce:	30 09       	mov	r9,0
800031d0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031d4:	91 09       	st.w	r8[0x0],r9
800031d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031da:	20 48       	sub	r8,4
800031dc:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031e0:	93 08       	st.w	r9[0x0],r8
800031e2:	58 08       	cp.w	r8,0
800031e4:	e0 80 05 4f 	breq	80003c82 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031e8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031ec:	70 09       	ld.w	r9,r8[0x0]
800031ee:	8e 7b       	ld.sh	r11,r7[0xe]
800031f0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031f4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031f8:	2f f9       	sub	r9,-1
800031fa:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031fc:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003200:	70 09       	ld.w	r9,r8[0x0]
80003202:	20 29       	sub	r9,2
80003204:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003206:	30 29       	mov	r9,2
80003208:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000320c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000320e:	30 39       	mov	r9,3
80003210:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000321a:	30 3a       	mov	r10,3
8000321c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003220:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003222:	6e 2a       	ld.w	r10,r7[0x8]
80003224:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003228:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000322a:	6e 3a       	ld.w	r10,r7[0xc]
8000322c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000322e:	59 48       	cp.w	r8,20
80003230:	c0 61       	brne	8000323c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003232:	31 89       	mov	r9,24
80003234:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	c0 a8       	rjmp	8000324e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000323c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003240:	70 08       	ld.w	r8,r8[0x0]
80003242:	59 08       	cp.w	r8,16
80003244:	c0 51       	brne	8000324e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003246:	31 09       	mov	r9,16
80003248:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000324c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000324e:	30 49       	mov	r9,4
80003250:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003254:	91 09       	st.w	r8[0x0],r9
80003256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000325a:	e0 49 10 00 	cp.w	r9,4096
8000325e:	5f 1a       	srne	r10
80003260:	e0 49 20 00 	cp.w	r9,8192
80003264:	5f 19       	srne	r9
80003266:	f5 e9 00 09 	and	r9,r10,r9
8000326a:	e0 81 05 0c 	brne	80003c82 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000326e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003272:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003274:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003278:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000327a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000327e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003280:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003284:	72 09       	ld.w	r9,r9[0x0]
80003286:	58 09       	cp.w	r9,0
80003288:	c0 71       	brne	80003296 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000328a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000328e:	f0 1f 02 93 	mcall	80003cd8 <phy_rx_func+0xed0>
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003296:	6e 2a       	ld.w	r10,r7[0x8]
80003298:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000329c:	58 1a       	cp.w	r10,1
8000329e:	e0 8b 00 4d 	brhi	80003338 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800032a2:	20 48       	sub	r8,4
800032a4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800032a8:	93 08       	st.w	r9[0x0],r8
800032aa:	58 08       	cp.w	r8,0
800032ac:	e0 80 04 eb 	breq	80003c82 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800032b0:	8e 68       	ld.sh	r8,r7[0xc]
800032b2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800032b6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800032ba:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800032bc:	30 09       	mov	r9,0
800032be:	f2 08 19 00 	cp.h	r8,r9
800032c2:	c0 70       	breq	800032d0 <phy_rx_func+0x4c8>
800032c4:	30 19       	mov	r9,1
800032c6:	f2 08 19 00 	cp.h	r8,r9
800032ca:	e0 81 04 dc 	brne	80003c82 <phy_rx_func+0xe7a>
800032ce:	c2 68       	rjmp	8000331a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032d0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032d4:	70 0a       	ld.w	r10,r8[0x0]
800032d6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032da:	72 09       	ld.w	r9,r9[0x0]
800032dc:	8e 7b       	ld.sh	r11,r7[0xe]
800032de:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032e2:	70 09       	ld.w	r9,r8[0x0]
800032e4:	2f f9       	sub	r9,-1
800032e6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e8:	e0 49 00 ff 	cp.w	r9,255
800032ec:	e0 88 00 11 	brls	8000330e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032f0:	30 09       	mov	r9,0
800032f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032f4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032f8:	6e 0c       	ld.w	r12,r7[0x0]
800032fa:	f0 1f 02 7d 	mcall	80003cec <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032fe:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003302:	70 0c       	ld.w	r12,r8[0x0]
80003304:	f0 1f 02 67 	mcall	80003ca0 <phy_rx_func+0xe98>
80003308:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000330a:	e0 80 04 bc 	breq	80003c82 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000330e:	30 29       	mov	r9,2
80003310:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003314:	91 09       	st.w	r8[0x0],r9
80003316:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000331a:	8e 79       	ld.sh	r9,r7[0xe]
8000331c:	30 38       	mov	r8,3
8000331e:	f0 09 19 00 	cp.h	r9,r8
80003322:	c0 51       	brne	8000332c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003324:	30 19       	mov	r9,1
80003326:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000332a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000332c:	30 29       	mov	r9,2
8000332e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003332:	91 09       	st.w	r8[0x0],r9
80003334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003338:	58 18       	cp.w	r8,1
8000333a:	e0 88 04 a4 	brls	80003c82 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000333e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003342:	70 0a       	ld.w	r10,r8[0x0]
80003344:	6e 3b       	ld.w	r11,r7[0xc]
80003346:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000334a:	70 09       	ld.w	r9,r8[0x0]
8000334c:	2f f9       	sub	r9,-1
8000334e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003350:	e0 49 00 ff 	cp.w	r9,255
80003354:	e0 88 00 11 	brls	80003376 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003358:	30 09       	mov	r9,0
8000335a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000335c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003360:	6e 0c       	ld.w	r12,r7[0x0]
80003362:	f0 1f 02 63 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003366:	fe f8 09 52 	ld.w	r8,pc[2386]
8000336a:	70 0c       	ld.w	r12,r8[0x0]
8000336c:	f0 1f 02 4d 	mcall	80003ca0 <phy_rx_func+0xe98>
80003370:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003372:	e0 80 04 88 	breq	80003c82 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003376:	fe f9 09 56 	ld.w	r9,pc[2390]
8000337a:	72 08       	ld.w	r8,r9[0x0]
8000337c:	20 28       	sub	r8,2
8000337e:	93 08       	st.w	r9[0x0],r8
80003380:	e0 80 04 81 	breq	80003c82 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003384:	30 29       	mov	r9,2
80003386:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000338a:	91 09       	st.w	r8[0x0],r9
8000338c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003390:	fe f8 09 84 	ld.w	r8,pc[2436]
80003394:	70 0a       	ld.w	r10,r8[0x0]
80003396:	fe f9 09 26 	ld.w	r9,pc[2342]
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	8e 4b       	ld.sh	r11,r7[0x8]
8000339e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800033a2:	70 09       	ld.w	r9,r8[0x0]
800033a4:	2f f9       	sub	r9,-1
800033a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a8:	e0 49 00 ff 	cp.w	r9,255
800033ac:	e0 88 00 16 	brls	800033d8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800033b0:	30 09       	mov	r9,0
800033b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033b4:	fe f6 09 08 	ld.w	r6,pc[2312]
800033b8:	6c 0c       	ld.w	r12,r6[0x0]
800033ba:	f0 1f 02 4d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033be:	fe f8 08 fa 	ld.w	r8,pc[2298]
800033c2:	70 0c       	ld.w	r12,r8[0x0]
800033c4:	f0 1f 02 37 	mcall	80003ca0 <phy_rx_func+0xe98>
800033c8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033ca:	c0 71       	brne	800033d8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033cc:	30 09       	mov	r9,0
800033ce:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033d2:	91 09       	st.w	r8[0x0],r9
800033d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033d8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033dc:	72 08       	ld.w	r8,r9[0x0]
800033de:	20 28       	sub	r8,2
800033e0:	93 08       	st.w	r9[0x0],r8
800033e2:	c0 71       	brne	800033f0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033e4:	30 09       	mov	r9,0
800033e6:	fe f8 08 de 	ld.w	r8,pc[2270]
800033ea:	91 09       	st.w	r8[0x0],r9
800033ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033f0:	fe f8 09 24 	ld.w	r8,pc[2340]
800033f4:	70 0a       	ld.w	r10,r8[0x0]
800033f6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033fa:	72 09       	ld.w	r9,r9[0x0]
800033fc:	8e 5b       	ld.sh	r11,r7[0xa]
800033fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003402:	70 09       	ld.w	r9,r8[0x0]
80003404:	2f f9       	sub	r9,-1
80003406:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003408:	e0 49 00 ff 	cp.w	r9,255
8000340c:	e0 88 00 16 	brls	80003438 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003410:	30 09       	mov	r9,0
80003412:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003414:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003418:	6c 0c       	ld.w	r12,r6[0x0]
8000341a:	f0 1f 02 35 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000341e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003422:	70 0c       	ld.w	r12,r8[0x0]
80003424:	f0 1f 02 1f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003428:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000342a:	c0 71       	brne	80003438 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000342c:	30 09       	mov	r9,0
8000342e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003438:	fe f9 08 94 	ld.w	r9,pc[2196]
8000343c:	72 08       	ld.w	r8,r9[0x0]
8000343e:	20 28       	sub	r8,2
80003440:	93 08       	st.w	r9[0x0],r8
80003442:	c0 71       	brne	80003450 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003444:	30 09       	mov	r9,0
80003446:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000344a:	91 09       	st.w	r8[0x0],r9
8000344c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003450:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003454:	70 0a       	ld.w	r10,r8[0x0]
80003456:	fe f9 08 66 	ld.w	r9,pc[2150]
8000345a:	72 09       	ld.w	r9,r9[0x0]
8000345c:	8e 6b       	ld.sh	r11,r7[0xc]
8000345e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003462:	70 09       	ld.w	r9,r8[0x0]
80003464:	2f f9       	sub	r9,-1
80003466:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003468:	e0 49 00 ff 	cp.w	r9,255
8000346c:	e0 88 00 16 	brls	80003498 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003470:	30 09       	mov	r9,0
80003472:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003474:	fe f6 08 48 	ld.w	r6,pc[2120]
80003478:	6c 0c       	ld.w	r12,r6[0x0]
8000347a:	f0 1f 02 1d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000347e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003482:	70 0c       	ld.w	r12,r8[0x0]
80003484:	f0 1f 02 07 	mcall	80003ca0 <phy_rx_func+0xe98>
80003488:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000348a:	c0 71       	brne	80003498 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000348c:	30 09       	mov	r9,0
8000348e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003492:	91 09       	st.w	r8[0x0],r9
80003494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003498:	fe f9 08 34 	ld.w	r9,pc[2100]
8000349c:	72 08       	ld.w	r8,r9[0x0]
8000349e:	20 28       	sub	r8,2
800034a0:	93 08       	st.w	r9[0x0],r8
800034a2:	c0 71       	brne	800034b0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800034a4:	30 09       	mov	r9,0
800034a6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800034aa:	91 09       	st.w	r8[0x0],r9
800034ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034b0:	fe f8 08 64 	ld.w	r8,pc[2148]
800034b4:	70 0a       	ld.w	r10,r8[0x0]
800034b6:	fe f9 08 06 	ld.w	r9,pc[2054]
800034ba:	72 09       	ld.w	r9,r9[0x0]
800034bc:	8e 7b       	ld.sh	r11,r7[0xe]
800034be:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034c2:	70 09       	ld.w	r9,r8[0x0]
800034c4:	2f f9       	sub	r9,-1
800034c6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034c8:	e0 49 00 ff 	cp.w	r9,255
800034cc:	e0 88 00 16 	brls	800034f8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034d0:	30 09       	mov	r9,0
800034d2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034d4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034d8:	6e 0c       	ld.w	r12,r7[0x0]
800034da:	f0 1f 02 05 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034de:	fe f8 07 da 	ld.w	r8,pc[2010]
800034e2:	70 0c       	ld.w	r12,r8[0x0]
800034e4:	f0 1f 01 ef 	mcall	80003ca0 <phy_rx_func+0xe98>
800034e8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034ea:	c0 71       	brne	800034f8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034ec:	30 09       	mov	r9,0
800034ee:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034f2:	91 09       	st.w	r8[0x0],r9
800034f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034f8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034fc:	72 08       	ld.w	r8,r9[0x0]
800034fe:	20 28       	sub	r8,2
80003500:	93 08       	st.w	r9[0x0],r8
80003502:	e0 81 03 c0 	brne	80003c82 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003506:	30 09       	mov	r9,0
80003508:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000350c:	91 09       	st.w	r8[0x0],r9
8000350e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003512:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003516:	11 89       	ld.ub	r9,r8[0x0]
80003518:	31 28       	mov	r8,18
8000351a:	f0 09 18 00 	cp.b	r9,r8
8000351e:	e0 81 01 4c 	brne	800037b6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003522:	ef 39 00 09 	ld.ub	r9,r7[9]
80003526:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000352a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000352c:	11 89       	ld.ub	r9,r8[0x0]
8000352e:	3f 28       	mov	r8,-14
80003530:	f0 09 18 00 	cp.b	r9,r8
80003534:	e0 81 01 3b 	brne	800037aa <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003538:	30 19       	mov	r9,1
8000353a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000353e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003540:	6e 29       	ld.w	r9,r7[0x8]
80003542:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003546:	fe f8 07 86 	ld.w	r8,pc[1926]
8000354a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000354c:	8e 59       	ld.sh	r9,r7[0xa]
8000354e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003552:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003554:	8e 69       	ld.sh	r9,r7[0xc]
80003556:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003558:	8e 79       	ld.sh	r9,r7[0xe]
8000355a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000355c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003560:	fe f9 07 60 	ld.w	r9,pc[1888]
80003564:	72 0a       	ld.w	r10,r9[0x0]
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000356c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003570:	70 09       	ld.w	r9,r8[0x0]
80003572:	2f f9       	sub	r9,-1
80003574:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003576:	e0 49 01 ff 	cp.w	r9,511
8000357a:	e0 88 00 16 	brls	800035a6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000357e:	30 09       	mov	r9,0
80003580:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003582:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003586:	6c 0c       	ld.w	r12,r6[0x0]
80003588:	f0 1f 01 d9 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000358c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003590:	70 0c       	ld.w	r12,r8[0x0]
80003592:	f0 1f 01 c4 	mcall	80003ca0 <phy_rx_func+0xe98>
80003596:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003598:	c0 71       	brne	800035a6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000359a:	30 09       	mov	r9,0
8000359c:	fe f8 07 28 	ld.w	r8,pc[1832]
800035a0:	91 09       	st.w	r8[0x0],r9
800035a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a6:	fe f9 07 26 	ld.w	r9,pc[1830]
800035aa:	72 08       	ld.w	r8,r9[0x0]
800035ac:	20 18       	sub	r8,1
800035ae:	93 08       	st.w	r9[0x0],r8
800035b0:	c0 71       	brne	800035be <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800035b2:	30 09       	mov	r9,0
800035b4:	fe f8 07 10 	ld.w	r8,pc[1808]
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035be:	fe f8 07 26 	ld.w	r8,pc[1830]
800035c2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800035c6:	72 0a       	ld.w	r10,r9[0x0]
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035ce:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035d2:	70 09       	ld.w	r9,r8[0x0]
800035d4:	2f f9       	sub	r9,-1
800035d6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035d8:	e0 49 01 ff 	cp.w	r9,511
800035dc:	e0 88 00 16 	brls	80003608 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035e0:	30 09       	mov	r9,0
800035e2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035e8:	6c 0c       	ld.w	r12,r6[0x0]
800035ea:	f0 1f 01 c1 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ee:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035f2:	70 0c       	ld.w	r12,r8[0x0]
800035f4:	f0 1f 01 ab 	mcall	80003ca0 <phy_rx_func+0xe98>
800035f8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035fa:	c0 71       	brne	80003608 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035fc:	30 09       	mov	r9,0
800035fe:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003602:	91 09       	st.w	r8[0x0],r9
80003604:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003608:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000360c:	72 08       	ld.w	r8,r9[0x0]
8000360e:	20 18       	sub	r8,1
80003610:	93 08       	st.w	r9[0x0],r8
80003612:	c0 71       	brne	80003620 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003614:	30 09       	mov	r9,0
80003616:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000361a:	91 09       	st.w	r8[0x0],r9
8000361c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003620:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003624:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003628:	72 0a       	ld.w	r10,r9[0x0]
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003630:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003634:	70 09       	ld.w	r9,r8[0x0]
80003636:	2f f9       	sub	r9,-1
80003638:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363a:	e0 49 01 ff 	cp.w	r9,511
8000363e:	e0 88 00 16 	brls	8000366a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003642:	30 09       	mov	r9,0
80003644:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003646:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000364a:	6c 0c       	ld.w	r12,r6[0x0]
8000364c:	f0 1f 01 a8 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003650:	fe f8 06 68 	ld.w	r8,pc[1640]
80003654:	70 0c       	ld.w	r12,r8[0x0]
80003656:	f0 1f 01 93 	mcall	80003ca0 <phy_rx_func+0xe98>
8000365a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000365c:	c0 71       	brne	8000366a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000365e:	30 09       	mov	r9,0
80003660:	fe f8 06 64 	ld.w	r8,pc[1636]
80003664:	91 09       	st.w	r8[0x0],r9
80003666:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000366a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000366e:	72 08       	ld.w	r8,r9[0x0]
80003670:	20 18       	sub	r8,1
80003672:	93 08       	st.w	r9[0x0],r8
80003674:	c0 71       	brne	80003682 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003676:	30 09       	mov	r9,0
80003678:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000367c:	91 09       	st.w	r8[0x0],r9
8000367e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003682:	fe f8 06 62 	ld.w	r8,pc[1634]
80003686:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000368a:	72 0a       	ld.w	r10,r9[0x0]
8000368c:	70 09       	ld.w	r9,r8[0x0]
8000368e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003692:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	2f f9       	sub	r9,-1
8000369a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000369c:	e0 49 01 ff 	cp.w	r9,511
800036a0:	e0 88 00 16 	brls	800036cc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800036a4:	30 09       	mov	r9,0
800036a6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036a8:	fe f6 06 18 	ld.w	r6,pc[1560]
800036ac:	6c 0c       	ld.w	r12,r6[0x0]
800036ae:	f0 1f 01 90 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036b2:	fe f8 06 06 	ld.w	r8,pc[1542]
800036b6:	70 0c       	ld.w	r12,r8[0x0]
800036b8:	f0 1f 01 7a 	mcall	80003ca0 <phy_rx_func+0xe98>
800036bc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036be:	c0 71       	brne	800036cc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800036c0:	30 09       	mov	r9,0
800036c2:	fe f8 06 02 	ld.w	r8,pc[1538]
800036c6:	91 09       	st.w	r8[0x0],r9
800036c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036cc:	fe f9 06 00 	ld.w	r9,pc[1536]
800036d0:	72 08       	ld.w	r8,r9[0x0]
800036d2:	20 18       	sub	r8,1
800036d4:	93 08       	st.w	r9[0x0],r8
800036d6:	c0 71       	brne	800036e4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036de:	91 09       	st.w	r8[0x0],r9
800036e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036e4:	fe f8 06 00 	ld.w	r8,pc[1536]
800036e8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036ec:	72 0a       	ld.w	r10,r9[0x0]
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036f4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	2f f9       	sub	r9,-1
800036fc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036fe:	e0 49 01 ff 	cp.w	r9,511
80003702:	e0 88 00 16 	brls	8000372e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003706:	30 09       	mov	r9,0
80003708:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000370a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000370e:	6c 0c       	ld.w	r12,r6[0x0]
80003710:	f0 1f 01 77 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003714:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003718:	70 0c       	ld.w	r12,r8[0x0]
8000371a:	f0 1f 01 62 	mcall	80003ca0 <phy_rx_func+0xe98>
8000371e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003720:	c0 71       	brne	8000372e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003722:	30 09       	mov	r9,0
80003724:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003728:	91 09       	st.w	r8[0x0],r9
8000372a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000372e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003732:	72 08       	ld.w	r8,r9[0x0]
80003734:	20 18       	sub	r8,1
80003736:	93 08       	st.w	r9[0x0],r8
80003738:	c0 71       	brne	80003746 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003746:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000374a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000374e:	72 0a       	ld.w	r10,r9[0x0]
80003750:	70 09       	ld.w	r9,r8[0x0]
80003752:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003756:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	2f f9       	sub	r9,-1
8000375e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003760:	e0 49 01 ff 	cp.w	r9,511
80003764:	e0 88 00 16 	brls	80003790 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003768:	30 09       	mov	r9,0
8000376a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000376c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003770:	6e 0c       	ld.w	r12,r7[0x0]
80003772:	f0 1f 01 5f 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003776:	fe f8 05 42 	ld.w	r8,pc[1346]
8000377a:	70 0c       	ld.w	r12,r8[0x0]
8000377c:	f0 1f 01 49 	mcall	80003ca0 <phy_rx_func+0xe98>
80003780:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003782:	c0 71       	brne	80003790 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003784:	30 09       	mov	r9,0
80003786:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000378a:	91 09       	st.w	r8[0x0],r9
8000378c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003790:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003794:	72 08       	ld.w	r8,r9[0x0]
80003796:	20 18       	sub	r8,1
80003798:	93 08       	st.w	r9[0x0],r8
8000379a:	e0 81 02 74 	brne	80003c82 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000379e:	30 09       	mov	r9,0
800037a0:	fe f8 05 24 	ld.w	r8,pc[1316]
800037a4:	91 09       	st.w	r8[0x0],r9
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037aa:	30 09       	mov	r9,0
800037ac:	fe f8 05 18 	ld.w	r8,pc[1304]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037b6:	fe f8 05 26 	ld.w	r8,pc[1318]
800037ba:	11 89       	ld.ub	r9,r8[0x0]
800037bc:	3f 28       	mov	r8,-14
800037be:	f0 09 18 00 	cp.b	r9,r8
800037c2:	c4 31       	brne	80003848 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037c4:	8e 49       	ld.sh	r9,r7[0x8]
800037c6:	fe f8 05 56 	ld.w	r8,pc[1366]
800037ca:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037cc:	fe f8 05 18 	ld.w	r8,pc[1304]
800037d0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037d4:	72 0a       	ld.w	r10,r9[0x0]
800037d6:	70 09       	ld.w	r9,r8[0x0]
800037d8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037e0:	70 09       	ld.w	r9,r8[0x0]
800037e2:	2f f9       	sub	r9,-1
800037e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037e6:	e0 49 01 ff 	cp.w	r9,511
800037ea:	e0 88 00 16 	brls	80003816 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ee:	30 09       	mov	r9,0
800037f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037f2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037f6:	6e 0c       	ld.w	r12,r7[0x0]
800037f8:	f0 1f 01 3d 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037fc:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003800:	70 0c       	ld.w	r12,r8[0x0]
80003802:	f0 1f 01 28 	mcall	80003ca0 <phy_rx_func+0xe98>
80003806:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003808:	c0 71       	brne	80003816 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000380a:	30 09       	mov	r9,0
8000380c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003816:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000381a:	72 08       	ld.w	r8,r9[0x0]
8000381c:	20 18       	sub	r8,1
8000381e:	93 08       	st.w	r9[0x0],r8
80003820:	c0 71       	brne	8000382e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003822:	30 09       	mov	r9,0
80003824:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003828:	91 09       	st.w	r8[0x0],r9
8000382a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000382e:	20 18       	sub	r8,1
80003830:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003834:	93 08       	st.w	r9[0x0],r8
80003836:	58 08       	cp.w	r8,0
80003838:	e0 81 02 25 	brne	80003c82 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000383c:	30 09       	mov	r9,0
8000383e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003842:	91 09       	st.w	r8[0x0],r9
80003844:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003848:	fe f8 04 94 	ld.w	r8,pc[1172]
8000384c:	11 89       	ld.ub	r9,r8[0x0]
8000384e:	3f 38       	mov	r8,-13
80003850:	f0 09 18 00 	cp.b	r9,r8
80003854:	e0 81 01 0c 	brne	80003a6c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003858:	8e 49       	ld.sh	r9,r7[0x8]
8000385a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000385e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003860:	8e 59       	ld.sh	r9,r7[0xa]
80003862:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003864:	8e 69       	ld.sh	r9,r7[0xc]
80003866:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003868:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000386c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003870:	72 0a       	ld.w	r10,r9[0x0]
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003878:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000387c:	70 09       	ld.w	r9,r8[0x0]
8000387e:	2f f9       	sub	r9,-1
80003880:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003882:	e0 49 01 ff 	cp.w	r9,511
80003886:	e0 88 00 16 	brls	800038b2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388a:	30 09       	mov	r9,0
8000388c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000388e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003892:	6c 0c       	ld.w	r12,r6[0x0]
80003894:	f0 1f 01 16 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003898:	fe f8 04 20 	ld.w	r8,pc[1056]
8000389c:	70 0c       	ld.w	r12,r8[0x0]
8000389e:	f0 1f 01 01 	mcall	80003ca0 <phy_rx_func+0xe98>
800038a2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800038a6:	30 09       	mov	r9,0
800038a8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800038ac:	91 09       	st.w	r8[0x0],r9
800038ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800038b6:	72 08       	ld.w	r8,r9[0x0]
800038b8:	20 18       	sub	r8,1
800038ba:	93 08       	st.w	r9[0x0],r8
800038bc:	c0 71       	brne	800038ca <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800038be:	30 09       	mov	r9,0
800038c0:	fe f8 04 04 	ld.w	r8,pc[1028]
800038c4:	91 09       	st.w	r8[0x0],r9
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038ca:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038ce:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038d2:	72 0a       	ld.w	r10,r9[0x0]
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038da:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038de:	70 09       	ld.w	r9,r8[0x0]
800038e0:	2f f9       	sub	r9,-1
800038e2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e4:	e0 49 01 ff 	cp.w	r9,511
800038e8:	e0 88 00 16 	brls	80003914 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ec:	30 09       	mov	r9,0
800038ee:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038f0:	fe f6 03 d0 	ld.w	r6,pc[976]
800038f4:	6c 0c       	ld.w	r12,r6[0x0]
800038f6:	f0 1f 00 fe 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038fa:	fe f8 03 be 	ld.w	r8,pc[958]
800038fe:	70 0c       	ld.w	r12,r8[0x0]
80003900:	f0 1f 00 e8 	mcall	80003ca0 <phy_rx_func+0xe98>
80003904:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003906:	c0 71       	brne	80003914 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003908:	30 09       	mov	r9,0
8000390a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000390e:	91 09       	st.w	r8[0x0],r9
80003910:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003914:	fe f9 03 b8 	ld.w	r9,pc[952]
80003918:	72 08       	ld.w	r8,r9[0x0]
8000391a:	20 18       	sub	r8,1
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	c0 71       	brne	8000392c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003920:	30 09       	mov	r9,0
80003922:	fe f8 03 a2 	ld.w	r8,pc[930]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000392c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003930:	fe f9 03 90 	ld.w	r9,pc[912]
80003934:	72 0a       	ld.w	r10,r9[0x0]
80003936:	70 09       	ld.w	r9,r8[0x0]
80003938:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000393c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003940:	70 09       	ld.w	r9,r8[0x0]
80003942:	2f f9       	sub	r9,-1
80003944:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003946:	e0 49 01 ff 	cp.w	r9,511
8000394a:	e0 88 00 16 	brls	80003976 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000394e:	30 09       	mov	r9,0
80003950:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003952:	fe f6 03 6e 	ld.w	r6,pc[878]
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 00 e5 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003960:	70 0c       	ld.w	r12,r8[0x0]
80003962:	f0 1f 00 d0 	mcall	80003ca0 <phy_rx_func+0xe98>
80003966:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003968:	c0 71       	brne	80003976 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000396a:	30 09       	mov	r9,0
8000396c:	fe f8 03 58 	ld.w	r8,pc[856]
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003976:	fe f9 03 56 	ld.w	r9,pc[854]
8000397a:	72 08       	ld.w	r8,r9[0x0]
8000397c:	20 18       	sub	r8,1
8000397e:	93 08       	st.w	r9[0x0],r8
80003980:	c0 71       	brne	8000398e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003982:	30 09       	mov	r9,0
80003984:	fe f8 03 40 	ld.w	r8,pc[832]
80003988:	91 09       	st.w	r8[0x0],r9
8000398a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000398e:	fe f8 03 56 	ld.w	r8,pc[854]
80003992:	fe f9 03 2e 	ld.w	r9,pc[814]
80003996:	72 0a       	ld.w	r10,r9[0x0]
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000399e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039a2:	70 09       	ld.w	r9,r8[0x0]
800039a4:	2f f9       	sub	r9,-1
800039a6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039a8:	e0 49 01 ff 	cp.w	r9,511
800039ac:	e0 88 00 16 	brls	800039d8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800039b0:	30 09       	mov	r9,0
800039b2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039b4:	fe f6 03 0c 	ld.w	r6,pc[780]
800039b8:	6c 0c       	ld.w	r12,r6[0x0]
800039ba:	f0 1f 00 cd 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039be:	fe f8 02 fa 	ld.w	r8,pc[762]
800039c2:	70 0c       	ld.w	r12,r8[0x0]
800039c4:	f0 1f 00 b7 	mcall	80003ca0 <phy_rx_func+0xe98>
800039c8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039cc:	30 09       	mov	r9,0
800039ce:	fe f8 02 f6 	ld.w	r8,pc[758]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039d8:	fe f9 02 f4 	ld.w	r9,pc[756]
800039dc:	72 08       	ld.w	r8,r9[0x0]
800039de:	20 18       	sub	r8,1
800039e0:	93 08       	st.w	r9[0x0],r8
800039e2:	c0 71       	brne	800039f0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039e4:	30 09       	mov	r9,0
800039e6:	fe f8 02 de 	ld.w	r8,pc[734]
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039f0:	fe f8 02 f4 	ld.w	r8,pc[756]
800039f4:	fe f9 02 cc 	ld.w	r9,pc[716]
800039f8:	72 0a       	ld.w	r10,r9[0x0]
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a00:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a04:	70 09       	ld.w	r9,r8[0x0]
80003a06:	2f f9       	sub	r9,-1
80003a08:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a0a:	e0 49 01 ff 	cp.w	r9,511
80003a0e:	e0 88 00 16 	brls	80003a3a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a12:	30 09       	mov	r9,0
80003a14:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a16:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a1a:	6e 0c       	ld.w	r12,r7[0x0]
80003a1c:	f0 1f 00 b4 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a20:	fe f8 02 98 	ld.w	r8,pc[664]
80003a24:	70 0c       	ld.w	r12,r8[0x0]
80003a26:	f0 1f 00 9f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003a2a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a2c:	c0 71       	brne	80003a3a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a2e:	30 09       	mov	r9,0
80003a30:	fe f8 02 94 	ld.w	r8,pc[660]
80003a34:	91 09       	st.w	r8[0x0],r9
80003a36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a3a:	fe f9 02 92 	ld.w	r9,pc[658]
80003a3e:	72 08       	ld.w	r8,r9[0x0]
80003a40:	20 18       	sub	r8,1
80003a42:	93 08       	st.w	r9[0x0],r8
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a4c:	91 09       	st.w	r8[0x0],r9
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a52:	20 18       	sub	r8,1
80003a54:	fe f9 02 78 	ld.w	r9,pc[632]
80003a58:	93 08       	st.w	r9[0x0],r8
80003a5a:	58 08       	cp.w	r8,0
80003a5c:	e0 81 01 13 	brne	80003c82 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a60:	30 09       	mov	r9,0
80003a62:	fe f8 02 62 	ld.w	r8,pc[610]
80003a66:	91 09       	st.w	r8[0x0],r9
80003a68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a6c:	fe f8 02 70 	ld.w	r8,pc[624]
80003a70:	11 89       	ld.ub	r9,r8[0x0]
80003a72:	30 48       	mov	r8,4
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	c0 80       	breq	80003a88 <phy_rx_func+0xc80>
80003a7a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a7e:	11 89       	ld.ub	r9,r8[0x0]
80003a80:	30 38       	mov	r8,3
80003a82:	f0 09 18 00 	cp.b	r9,r8
80003a86:	c1 41       	brne	80003aae <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a88:	6e 29       	ld.w	r9,r7[0x8]
80003a8a:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a8e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a90:	6e 39       	ld.w	r9,r7[0xc]
80003a92:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a94:	fe f9 02 38 	ld.w	r9,pc[568]
80003a98:	72 08       	ld.w	r8,r9[0x0]
80003a9a:	20 88       	sub	r8,8
80003a9c:	93 08       	st.w	r9[0x0],r8
80003a9e:	e0 81 00 f2 	brne	80003c82 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003aa2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003aa4:	fe f9 02 20 	ld.w	r9,pc[544]
80003aa8:	93 08       	st.w	r9[0x0],r8
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003aae:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ab2:	11 89       	ld.ub	r9,r8[0x0]
80003ab4:	31 38       	mov	r8,19
80003ab6:	f0 09 18 00 	cp.b	r9,r8
80003aba:	e0 81 00 9c 	brne	80003bf2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003abe:	fe f8 02 62 	ld.w	r8,pc[610]
80003ac2:	11 88       	ld.ub	r8,r8[0x0]
80003ac4:	30 c9       	mov	r9,12
80003ac6:	f2 08 18 00 	cp.b	r8,r9
80003aca:	e0 81 00 7b 	brne	80003bc0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003ace:	8e 49       	ld.sh	r9,r7[0x8]
80003ad0:	fe f8 02 54 	ld.w	r8,pc[596]
80003ad4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ad8:	30 09       	mov	r9,0
80003ada:	fe f8 02 46 	ld.w	r8,pc[582]
80003ade:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ae0:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ae4:	3f 38       	mov	r8,-13
80003ae6:	f0 09 18 00 	cp.b	r9,r8
80003aea:	c6 61       	brne	80003bb6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003aec:	10 99       	mov	r9,r8
80003aee:	4f c8       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003af0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003af2:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003af6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003afa:	4f 58       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003afc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003afe:	30 19       	mov	r9,1
80003b00:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b04:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b06:	8e 79       	ld.sh	r9,r7[0xe]
80003b08:	fe f8 02 14 	ld.w	r8,pc[532]
80003b0c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b0e:	4f 68       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b10:	4e c9       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b12:	72 0a       	ld.w	r10,r9[0x0]
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b1a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b1e:	70 09       	ld.w	r9,r8[0x0]
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b24:	e0 49 01 ff 	cp.w	r9,511
80003b28:	e0 88 00 13 	brls	80003b4e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2c:	30 09       	mov	r9,0
80003b2e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b30:	4e 46       	lddpc	r6,80003cc0 <phy_rx_func+0xeb8>
80003b32:	6c 0c       	ld.w	r12,r6[0x0]
80003b34:	f0 1f 00 6e 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b38:	4e 08       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b3a:	70 0c       	ld.w	r12,r8[0x0]
80003b3c:	f0 1f 00 59 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b40:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b42:	c0 61       	brne	80003b4e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b44:	30 09       	mov	r9,0
80003b46:	4e 08       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b48:	91 09       	st.w	r8[0x0],r9
80003b4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b4e:	4e 09       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003b50:	72 08       	ld.w	r8,r9[0x0]
80003b52:	20 18       	sub	r8,1
80003b54:	93 08       	st.w	r9[0x0],r8
80003b56:	c0 61       	brne	80003b62 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b58:	30 09       	mov	r9,0
80003b5a:	4d b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b62:	4e 18       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b64:	4d 79       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b66:	72 0a       	ld.w	r10,r9[0x0]
80003b68:	70 09       	ld.w	r9,r8[0x0]
80003b6a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b6e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b72:	70 09       	ld.w	r9,r8[0x0]
80003b74:	2f f9       	sub	r9,-1
80003b76:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b78:	e0 49 01 ff 	cp.w	r9,511
80003b7c:	e0 88 00 13 	brls	80003ba2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b80:	30 09       	mov	r9,0
80003b82:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b84:	4c f7       	lddpc	r7,80003cc0 <phy_rx_func+0xeb8>
80003b86:	6e 0c       	ld.w	r12,r7[0x0]
80003b88:	f0 1f 00 59 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b8c:	4c b8       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b8e:	70 0c       	ld.w	r12,r8[0x0]
80003b90:	f0 1f 00 44 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b94:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b96:	c0 61       	brne	80003ba2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b98:	30 09       	mov	r9,0
80003b9a:	4c b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b9c:	91 09       	st.w	r8[0x0],r9
80003b9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003ba2:	4c b9       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003ba4:	72 08       	ld.w	r8,r9[0x0]
80003ba6:	20 18       	sub	r8,1
80003ba8:	93 08       	st.w	r9[0x0],r8
80003baa:	c6 c1       	brne	80003c82 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003bac:	30 09       	mov	r9,0
80003bae:	4c 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bb0:	91 09       	st.w	r8[0x0],r9
80003bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003bb6:	30 09       	mov	r9,0
80003bb8:	4c 38       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bba:	91 09       	st.w	r8[0x0],r9
80003bbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003bc0:	8e 4a       	ld.sh	r10,r7[0x8]
80003bc2:	4d 99       	lddpc	r9,80003d24 <phy_rx_func+0xf1c>
80003bc4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bc8:	4d 6a       	lddpc	r10,80003d20 <phy_rx_func+0xf18>
80003bca:	15 88       	ld.ub	r8,r10[0x0]
80003bcc:	f0 cb ff ff 	sub	r11,r8,-1
80003bd0:	8e 5c       	ld.sh	r12,r7[0xa]
80003bd2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bd6:	f0 cb ff fe 	sub	r11,r8,-2
80003bda:	8e 6c       	ld.sh	r12,r7[0xc]
80003bdc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003be0:	f0 cb ff fd 	sub	r11,r8,-3
80003be4:	8e 7c       	ld.sh	r12,r7[0xe]
80003be6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bea:	2f c8       	sub	r8,-4
80003bec:	b4 88       	st.b	r10[0x0],r8
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bf2:	30 09       	mov	r9,0
80003bf4:	4b 48       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bf6:	91 09       	st.w	r8[0x0],r9
80003bf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bfc:	4c 08       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003bfe:	70 09       	ld.w	r9,r8[0x0]
80003c00:	8e 4b       	ld.sh	r11,r7[0x8]
80003c02:	4c 0a       	lddpc	r10,80003d00 <phy_rx_func+0xef8>
80003c04:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c08:	2f f9       	sub	r9,-1
80003c0a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c0c:	4b 58       	lddpc	r8,80003ce0 <phy_rx_func+0xed8>
80003c0e:	70 09       	ld.w	r9,r8[0x0]
80003c10:	20 29       	sub	r9,2
80003c12:	91 09       	st.w	r8[0x0],r9
80003c14:	70 08       	ld.w	r8,r8[0x0]
80003c16:	58 08       	cp.w	r8,0
80003c18:	c2 f1       	brne	80003c76 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c1a:	30 09       	mov	r9,0
80003c1c:	4b 88       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003c1e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c20:	8e 59       	ld.sh	r9,r7[0xa]
80003c22:	fe 78 82 12 	mov	r8,-32238
80003c26:	f0 09 19 00 	cp.h	r9,r8
80003c2a:	c2 11       	brne	80003c6c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c2c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c30:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c34:	4a f8       	lddpc	r8,80003cf0 <phy_rx_func+0xee8>
80003c36:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c38:	8e 59       	ld.sh	r9,r7[0xa]
80003c3a:	4a f8       	lddpc	r8,80003cf4 <phy_rx_func+0xeec>
80003c3c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c3e:	8e 69       	ld.sh	r9,r7[0xc]
80003c40:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c42:	f0 1f 00 2e 	mcall	80003cf8 <phy_rx_func+0xef0>
80003c46:	4a 18       	lddpc	r8,80003cc8 <phy_rx_func+0xec0>
80003c48:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c4a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c4e:	31 38       	mov	r8,19
80003c50:	f0 09 18 00 	cp.b	r9,r8
80003c54:	c0 71       	brne	80003c62 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c56:	10 99       	mov	r9,r8
80003c58:	4a 18       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003c5a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c5c:	30 09       	mov	r9,0
80003c5e:	49 c8       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003c60:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c62:	30 49       	mov	r9,4
80003c64:	49 88       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c6c:	30 09       	mov	r9,0
80003c6e:	49 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c70:	91 09       	st.w	r8[0x0],r9
80003c72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c76:	4a dc       	lddpc	r12,80003d28 <phy_rx_func+0xf20>
80003c78:	f0 1f 00 18 	mcall	80003cd8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c7c:	30 09       	mov	r9,0
80003c7e:	49 28       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c80:	91 09       	st.w	r8[0x0],r9
80003c82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c86:	00 00       	add	r0,r0
80003c88:	00 00       	add	r0,r0
80003c8a:	0a b4       	st.h	r5++,r4
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a cc       	st.b	r5++,r12
80003c90:	00 00       	add	r0,r0
80003c92:	0a ac       	st.w	r5++,r12
80003c94:	00 00       	add	r0,r0
80003c96:	0a 8e       	andn	lr,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 7c       	tst	r12,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a a4       	st.w	r5++,r4
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	2c 88       	sub	r8,-56
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 9c       	mov	r12,r5
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	2b a0       	sub	r0,-70
80003cac:	00 00       	add	r0,r0
80003cae:	0a b0       	st.h	r5++,r0
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	2b d4       	sub	r4,-67
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 8d       	andn	sp,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0a a8       	st.w	r5++,r8
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a b8       	st.h	r5++,r8
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 90       	mov	r0,r5
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a d8       	st.w	--r5,r8
80003cc8:	00 00       	add	r0,r0
80003cca:	0a c0       	st.b	r5++,r0
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 78       	tst	r8,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 55       	eor	r5,r5
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	d7 a4       	*unknown*
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	71 94       	ld.w	r4,r8[0x64]
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 8c       	andn	r12,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a e4       	st.h	--r5,r4
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a c4       	st.b	r5++,r4
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	79 d4       	ld.w	r4,r12[0x74]
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	2b bc       	sub	r12,-69
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 4a       	or	r10,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	21 2c       	sub	r12,18
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	2b 70       	sub	r0,-73
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a 80       	andn	r0,r5
80003d00:	00 00       	add	r0,r0
80003d02:	20 30       	sub	r0,3
80003d04:	00 00       	add	r0,r0
80003d06:	0a 84       	andn	r4,r5
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 4b       	or	r11,r5
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a 49       	or	r9,r5
80003d10:	00 00       	add	r0,r0
80003d12:	0a dc       	st.w	--r5,r12
80003d14:	00 00       	add	r0,r0
80003d16:	0a 98       	mov	r8,r5
80003d18:	00 00       	add	r0,r0
80003d1a:	0a 64       	and	r4,r5
80003d1c:	00 00       	add	r0,r0
80003d1e:	20 28       	sub	r8,2
80003d20:	00 00       	add	r0,r0
80003d22:	0a d0       	st.w	--r5,r0
80003d24:	00 00       	add	r0,r0
80003d26:	21 30       	sub	r0,19
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	d7 bc       	*unknown*

80003d2c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d2c:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003d2e:	30 09       	mov	r9,0
80003d30:	49 b8       	lddpc	r8,80003d9c <pdca_int_handler+0x70>
80003d32:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d34:	49 b8       	lddpc	r8,80003da0 <pdca_int_handler+0x74>
80003d36:	70 09       	ld.w	r9,r8[0x0]
80003d38:	2f f9       	sub	r9,-1
80003d3a:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d3c:	49 a8       	lddpc	r8,80003da4 <pdca_int_handler+0x78>
80003d3e:	11 89       	ld.ub	r9,r8[0x0]
80003d40:	ec 19 00 01 	eorl	r9,0x1
80003d44:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d46:	11 89       	ld.ub	r9,r8[0x0]
80003d48:	a5 69       	lsl	r9,0x4
80003d4a:	2f c9       	sub	r9,-4
80003d4c:	49 7a       	lddpc	r10,80003da8 <pdca_int_handler+0x7c>
80003d4e:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d50:	fe 7a 00 40 	mov	r10,-65472
80003d54:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d56:	30 39       	mov	r9,3
80003d58:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d5a:	11 8a       	ld.ub	r10,r8[0x0]
80003d5c:	a5 6a       	lsl	r10,0x4
80003d5e:	2f ca       	sub	r10,-4
80003d60:	49 38       	lddpc	r8,80003dac <pdca_int_handler+0x80>
80003d62:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d64:	fe 78 00 00 	mov	r8,-65536
80003d68:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d6a:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d6c:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d6e:	49 18       	lddpc	r8,80003db0 <pdca_int_handler+0x84>
80003d70:	70 08       	ld.w	r8,r8[0x0]
80003d72:	58 08       	cp.w	r8,0
80003d74:	c0 70       	breq	80003d82 <pdca_int_handler+0x56>
80003d76:	48 c9       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d78:	13 89       	ld.ub	r9,r9[0x0]
80003d7a:	a5 69       	lsl	r9,0x4
80003d7c:	48 cc       	lddpc	r12,80003dac <pdca_int_handler+0x80>
80003d7e:	12 0c       	add	r12,r9
80003d80:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d82:	48 d8       	lddpc	r8,80003db4 <pdca_int_handler+0x88>
80003d84:	70 08       	ld.w	r8,r8[0x0]
80003d86:	58 08       	cp.w	r8,0
80003d88:	c0 70       	breq	80003d96 <pdca_int_handler+0x6a>
80003d8a:	48 79       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d8c:	13 89       	ld.ub	r9,r9[0x0]
80003d8e:	a5 69       	lsl	r9,0x4
80003d90:	48 6c       	lddpc	r12,80003da8 <pdca_int_handler+0x7c>
80003d92:	12 0c       	add	r12,r9
80003d94:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d96:	d4 02       	popm	lr
80003d98:	d6 03       	rete
80003d9a:	00 00       	add	r0,r0
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a ec       	st.h	--r5,r12
80003da0:	00 00       	add	r0,r0
80003da2:	0a f0       	st.b	--r5,r0
80003da4:	00 00       	add	r0,r0
80003da6:	53 50       	stdsp	sp[0xd4],r0
80003da8:	00 00       	add	r0,r0
80003daa:	53 78       	stdsp	sp[0xdc],r8
80003dac:	00 00       	add	r0,r0
80003dae:	53 58       	stdsp	sp[0xd4],r8
80003db0:	00 00       	add	r0,r0
80003db2:	0a e8       	st.h	--r5,r8
80003db4:	00 00       	add	r0,r0
80003db6:	0a f4       	st.b	--r5,r4

80003db8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003db8:	fe 78 10 00 	mov	r8,-61440
80003dbc:	e0 69 0d c0 	mov	r9,3520
80003dc0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003dc4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003dc8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003dcc:	fe 78 34 00 	mov	r8,-52224
80003dd0:	e0 69 80 00 	mov	r9,32768
80003dd4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dd6:	30 09       	mov	r9,0
80003dd8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003dda:	e0 69 04 21 	mov	r9,1057
80003dde:	ea 19 3f 20 	orh	r9,0x3f20
80003de2:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003de4:	e0 69 02 9f 	mov	r9,671
80003de8:	ea 19 01 00 	orh	r9,0x100
80003dec:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003dee:	e0 6a 04 02 	mov	r10,1026
80003df2:	ea 1a 3f 20 	orh	r10,0x3f20
80003df6:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003df8:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dfa:	5e fc       	retal	r12

80003dfc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dfc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dfe:	30 19       	mov	r9,1
80003e00:	49 78       	lddpc	r8,80003e5c <local_start_PDC+0x60>
80003e02:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e04:	fe 78 00 00 	mov	r8,-65536
80003e08:	30 7b       	mov	r11,7
80003e0a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e0c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e0e:	49 59       	lddpc	r9,80003e60 <local_start_PDC+0x64>
80003e10:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e14:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e16:	30 3a       	mov	r10,3
80003e18:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e1a:	30 1c       	mov	r12,1
80003e1c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e1e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e20:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e22:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e24:	30 2c       	mov	r12,2
80003e26:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e28:	48 f9       	lddpc	r9,80003e64 <local_start_PDC+0x68>
80003e2a:	e0 68 5a 5a 	mov	r8,23130
80003e2e:	ea 18 ab cd 	orh	r8,0xabcd
80003e32:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e34:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e36:	30 0e       	mov	lr,0
80003e38:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e3a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e3c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e3e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e40:	fe 78 00 40 	mov	r8,-65472
80003e44:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e46:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e48:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e4c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e4e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e50:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e52:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e54:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e56:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e58:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e5a:	d8 02       	popm	pc
80003e5c:	00 00       	add	r0,r0
80003e5e:	53 50       	stdsp	sp[0xd4],r0
80003e60:	00 00       	add	r0,r0
80003e62:	53 58       	stdsp	sp[0xd4],r8
80003e64:	00 00       	add	r0,r0
80003e66:	53 78       	stdsp	sp[0xdc],r8

80003e68 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e68:	48 38       	lddpc	r8,80003e74 <register_rx_tx_func+0xc>
80003e6a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e6c:	48 38       	lddpc	r8,80003e78 <register_rx_tx_func+0x10>
80003e6e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e70:	5e fc       	retal	r12
80003e72:	00 00       	add	r0,r0
80003e74:	00 00       	add	r0,r0
80003e76:	0a e8       	st.h	--r5,r8
80003e78:	00 00       	add	r0,r0
80003e7a:	0a f4       	st.b	--r5,r4

80003e7c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e7c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e7e:	fe 78 10 00 	mov	r8,-61440
80003e82:	30 29       	mov	r9,2
80003e84:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e88:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e8c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e8e:	30 3a       	mov	r10,3
80003e90:	36 0b       	mov	r11,96
80003e92:	49 4c       	lddpc	r12,80003ee0 <ssc_init+0x64>
80003e94:	f0 1f 00 14 	mcall	80003ee4 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e98:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e9a:	fe 79 10 00 	mov	r9,-61440
80003e9e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ea2:	e2 18 00 02 	andl	r8,0x2,COH
80003ea6:	cf c0       	breq	80003e9e <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ea8:	fe 79 10 00 	mov	r9,-61440
80003eac:	f2 f8 01 60 	ld.w	r8,r9[352]
80003eb0:	e2 18 00 02 	andl	r8,0x2,COH
80003eb4:	cf c1       	brne	80003eac <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003eb6:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003eb8:	f0 1f 00 0c 	mcall	80003ee8 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ebc:	f0 1f 00 0c 	mcall	80003eec <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec0:	fe 79 00 00 	mov	r9,-65536
80003ec4:	30 18       	mov	r8,1
80003ec6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec8:	fe 7a 00 40 	mov	r10,-65472
80003ecc:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ece:	e0 6b 01 01 	mov	r11,257
80003ed2:	fe 7a 34 00 	mov	r10,-52224
80003ed6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ed8:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003eda:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3d 2c       	mov	r12,-46
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	54 70       	stdsp	sp[0x11c],r0
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	3d b8       	mov	r8,-37
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	3d fc       	mov	r12,-33

80003ef0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ef0:	48 28       	lddpc	r8,80003ef8 <xcmp_register_app_list+0x8>
80003ef2:	91 0c       	st.w	r8[0x0],r12
}
80003ef4:	5e fc       	retal	r12
80003ef6:	00 00       	add	r0,r0
80003ef8:	00 00       	add	r0,r0
80003efa:	53 98       	stdsp	sp[0xe4],r8

80003efc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003efc:	eb cd 40 80 	pushm	r7,lr
80003f00:	fa cd 01 00 	sub	sp,sp,256
80003f04:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f06:	16 98       	mov	r8,r11
80003f08:	2f 08       	sub	r8,-16
80003f0a:	af a8       	sbr	r8,0xe
80003f0c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f0e:	3f f8       	mov	r8,-1
80003f10:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f12:	30 b9       	mov	r9,11
80003f14:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f16:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f18:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f1a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f1c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f1e:	f6 ca ff fe 	sub	r10,r11,-2
80003f22:	18 9b       	mov	r11,r12
80003f24:	fa cc ff f0 	sub	r12,sp,-16
80003f28:	f0 1f 00 05 	mcall	80003f3c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f2c:	2f e7       	sub	r7,-2
80003f2e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f30:	1a 9c       	mov	r12,sp
80003f32:	f0 1f 00 04 	mcall	80003f40 <xcmp_tx+0x44>
}
80003f36:	2c 0d       	sub	sp,-256
80003f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	78 8c       	ld.w	r12,r12[0x20]
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	45 08       	lddsp	r8,sp[0x140]

80003f44 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f44:	d4 21       	pushm	r4-r7,lr
80003f46:	fa cd 00 d0 	sub	sp,sp,208
80003f4a:	18 94       	mov	r4,r12
80003f4c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f4e:	e0 68 01 00 	mov	r8,256
80003f52:	f0 0b 19 00 	cp.h	r11,r8
80003f56:	e0 8b 00 36 	brhi	80003fc2 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f5a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f5e:	e0 68 04 1d 	mov	r8,1053
80003f62:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f64:	30 18       	mov	r8,1
80003f66:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f68:	32 08       	mov	r8,32
80003f6a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f6c:	30 28       	mov	r8,2
80003f6e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f70:	30 48       	mov	r8,4
80003f72:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f74:	ea 1a 0c 00 	orh	r10,0xc00
80003f78:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f7a:	30 4a       	mov	r10,4
80003f7c:	1a 9b       	mov	r11,sp
80003f7e:	fa cc ff f4 	sub	r12,sp,-12
80003f82:	f0 1f 00 12 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f86:	30 f8       	mov	r8,15
80003f88:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f8c:	3a 78       	mov	r8,-89
80003f8e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f92:	30 08       	mov	r8,0
80003f94:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f98:	0e 9a       	mov	r10,r7
80003f9a:	5c 7a       	castu.h	r10
80003f9c:	f4 08 16 08 	lsr	r8,r10,0x8
80003fa0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003fa4:	0e 96       	mov	r6,r7
80003fa6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003faa:	08 9b       	mov	r11,r4
80003fac:	fa cc ff eb 	sub	r12,sp,-21
80003fb0:	f0 1f 00 06 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003fb4:	ee cb ff f3 	sub	r11,r7,-13
80003fb8:	5c 5b       	castu.b	r11
80003fba:	fa cc ff fa 	sub	r12,sp,-6
80003fbe:	f0 1f 00 04 	mcall	80003fcc <xcmp_data_session_req+0x88>
}
80003fc2:	2c cd       	sub	sp,-208
80003fc4:	d8 22       	popm	r4-r7,pc
80003fc6:	00 00       	add	r0,r0
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	78 8c       	ld.w	r12,r12[0x20]
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e fc       	mov	r12,-17

80003fd0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fd0:	d4 01       	pushm	lr
80003fd2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fd6:	fe 78 b4 00 	mov	r8,-19456
80003fda:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fdc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fe0:	30 89       	mov	r9,8
80003fe2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fe4:	30 19       	mov	r9,1
80003fe6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fe8:	30 09       	mov	r9,0
80003fea:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fec:	30 5a       	mov	r10,5
80003fee:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003ff0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003ff2:	30 7a       	mov	r10,7
80003ff4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ff6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ff8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ffa:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ffe:	30 9b       	mov	r11,9
80004000:	fa cc ff fe 	sub	r12,sp,-2
80004004:	f0 1f 00 02 	mcall	8000400c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004008:	2c dd       	sub	sp,-204
8000400a:	d8 02       	popm	pc
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3e fc       	mov	r12,-17

80004010 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004010:	d4 01       	pushm	lr
80004012:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004016:	fe 78 80 00 	mov	r8,-32768
8000401a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000401c:	30 38       	mov	r8,3
8000401e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004020:	30 1b       	mov	r11,1
80004022:	fa cc ff fe 	sub	r12,sp,-2
80004026:	f0 1f 00 03 	mcall	80004030 <xcmp_opcode_not_supported+0x20>
}
8000402a:	2c dd       	sub	sp,-204
8000402c:	d8 02       	popm	pc
8000402e:	00 00       	add	r0,r0
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	3e fc       	mov	r12,-17

80004034 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004034:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004036:	96 88       	ld.uh	r8,r11[0x0]
80004038:	e2 18 f0 00 	andl	r8,0xf000,COH
8000403c:	e0 48 80 00 	cp.w	r8,32768
80004040:	c0 f0       	breq	8000405e <xcmp_exec_func+0x2a>
80004042:	e0 48 b0 00 	cp.w	r8,45056
80004046:	c1 20       	breq	8000406a <xcmp_exec_func+0x36>
80004048:	58 08       	cp.w	r8,0
8000404a:	c1 51       	brne	80004074 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000404c:	78 08       	ld.w	r8,r12[0x0]
8000404e:	58 08       	cp.w	r8,0
80004050:	c0 40       	breq	80004058 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004052:	16 9c       	mov	r12,r11
80004054:	5d 18       	icall	r8
80004056:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004058:	f0 1f 00 08 	mcall	80004078 <xcmp_exec_func+0x44>
8000405c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000405e:	78 18       	ld.w	r8,r12[0x4]
80004060:	58 08       	cp.w	r8,0
80004062:	c0 90       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004064:	16 9c       	mov	r12,r11
80004066:	5d 18       	icall	r8
80004068:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000406a:	78 28       	ld.w	r8,r12[0x8]
8000406c:	58 08       	cp.w	r8,0
8000406e:	c0 30       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004070:	16 9c       	mov	r12,r11
80004072:	5d 18       	icall	r8
80004074:	d8 02       	popm	pc
80004076:	00 00       	add	r0,r0
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	40 10       	lddsp	r0,sp[0x4]

8000407c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000407c:	d4 01       	pushm	lr
8000407e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004082:	e0 68 04 09 	mov	r8,1033
80004086:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004088:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000408c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000408e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004092:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004094:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004096:	30 09       	mov	r9,0
80004098:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000409a:	fb 69 00 08 	st.b	sp[8],r9
8000409e:	fa c8 ff f7 	sub	r8,sp,-9
800040a2:	b0 89       	st.b	r8[0x0],r9
800040a4:	fa c8 ff f6 	sub	r8,sp,-10
800040a8:	b0 89       	st.b	r8[0x0],r9
800040aa:	fa c8 ff f5 	sub	r8,sp,-11
800040ae:	b0 89       	st.b	r8[0x0],r9
800040b0:	fa c8 ff f4 	sub	r8,sp,-12
800040b4:	b0 89       	st.b	r8[0x0],r9
800040b6:	fa c8 ff f3 	sub	r8,sp,-13
800040ba:	b0 89       	st.b	r8[0x0],r9
800040bc:	fa c8 ff f2 	sub	r8,sp,-14
800040c0:	b0 89       	st.b	r8[0x0],r9
800040c2:	fa c8 ff f1 	sub	r8,sp,-15
800040c6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040c8:	30 cb       	mov	r11,12
800040ca:	fa cc ff fe 	sub	r12,sp,-2
800040ce:	f0 1f 00 03 	mcall	800040d8 <xcmp_IdleTestTone+0x5c>
}
800040d2:	2c dd       	sub	sp,-204
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e fc       	mov	r12,-17

800040dc <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040dc:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040de:	48 dc       	lddpc	r12,80004110 <xcmp_init+0x34>
800040e0:	f0 1f 00 0d 	mcall	80004114 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040e4:	30 4b       	mov	r11,4
800040e6:	31 4c       	mov	r12,20
800040e8:	f0 1f 00 0c 	mcall	80004118 <xcmp_init+0x3c>
800040ec:	48 c8       	lddpc	r8,8000411c <xcmp_init+0x40>
800040ee:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040f0:	30 09       	mov	r9,0
800040f2:	1a d9       	st.w	--sp,r9
800040f4:	1a d9       	st.w	--sp,r9
800040f6:	1a d9       	st.w	--sp,r9
800040f8:	30 38       	mov	r8,3
800040fa:	e0 6a 04 00 	mov	r10,1024
800040fe:	48 9b       	lddpc	r11,80004120 <xcmp_init+0x44>
80004100:	48 9c       	lddpc	r12,80004124 <xcmp_init+0x48>
80004102:	f0 1f 00 0a 	mcall	80004128 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004106:	f0 1f 00 0a 	mcall	8000412c <xcmp_init+0x50>
8000410a:	2f dd       	sub	sp,-12
	
}
8000410c:	d8 02       	popm	pc
8000410e:	00 00       	add	r0,r0
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	42 2c       	lddsp	r12,sp[0x88]
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	42 78       	lddsp	r8,sp[0x9c]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	65 28       	ld.w	r8,r2[0x48]
8000411c:	00 00       	add	r0,r0
8000411e:	0b 10       	ld.sh	r0,r5++
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	d7 e8       	*unknown*
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	41 30       	lddsp	r0,sp[0x4c]
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	6c 44       	ld.w	r4,r6[0x10]
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	42 b0       	lddsp	r0,sp[0xac]

80004130 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004130:	d4 31       	pushm	r0-r7,lr
80004132:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004134:	4b 16       	lddpc	r6,800041f8 <xcmp_rx_process+0xc8>
80004136:	30 05       	mov	r5,0
80004138:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000413a:	4b 13       	lddpc	r3,800041fc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000413c:	4b 12       	lddpc	r2,80004200 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000413e:	4b 21       	lddpc	r1,80004204 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004140:	4b 20       	lddpc	r0,80004208 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004142:	6c 0c       	ld.w	r12,r6[0x0]
80004144:	0a 99       	mov	r9,r5
80004146:	08 9a       	mov	r10,r4
80004148:	1a 9b       	mov	r11,sp
8000414a:	f0 1f 00 31 	mcall	8000420c <xcmp_rx_process+0xdc>
8000414e:	58 1c       	cp.w	r12,1
80004150:	cf 91       	brne	80004142 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004152:	40 0b       	lddsp	r11,sp[0x0]
80004154:	58 0b       	cp.w	r11,0
80004156:	cf 60       	breq	80004142 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004158:	96 0a       	ld.sh	r10,r11[0x0]
8000415a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000415e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004162:	59 c8       	cp.w	r8,28
80004164:	c1 e0       	breq	800041a0 <xcmp_rx_process+0x70>
80004166:	e0 89 00 07 	brgt	80004174 <xcmp_rx_process+0x44>
8000416a:	58 e8       	cp.w	r8,14
8000416c:	c0 e0       	breq	80004188 <xcmp_rx_process+0x58>
8000416e:	58 f8       	cp.w	r8,15
80004170:	c2 41       	brne	800041b8 <xcmp_rx_process+0x88>
80004172:	c0 f8       	rjmp	80004190 <xcmp_rx_process+0x60>
80004174:	e0 48 01 09 	cp.w	r8,265
80004178:	c1 80       	breq	800041a8 <xcmp_rx_process+0x78>
8000417a:	e0 48 01 0a 	cp.w	r8,266
8000417e:	c1 90       	breq	800041b0 <xcmp_rx_process+0x80>
80004180:	e0 48 00 2c 	cp.w	r8,44
80004184:	c1 a1       	brne	800041b8 <xcmp_rx_process+0x88>
80004186:	c0 98       	rjmp	80004198 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004188:	4a 2c       	lddpc	r12,80004210 <xcmp_rx_process+0xe0>
8000418a:	f0 1f 00 23 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000418e:	c2 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004190:	4a 2c       	lddpc	r12,80004218 <xcmp_rx_process+0xe8>
80004192:	f0 1f 00 21 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
80004196:	c2 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004198:	4a 1c       	lddpc	r12,8000421c <xcmp_rx_process+0xec>
8000419a:	f0 1f 00 1f 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000419e:	c2 78       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041a0:	04 9c       	mov	r12,r2
800041a2:	f0 1f 00 1d 	mcall	80004214 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041a6:	c2 38       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041a8:	02 9c       	mov	r12,r1
800041aa:	f0 1f 00 1b 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041ae:	c1 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041b0:	00 9c       	mov	r12,r0
800041b2:	f0 1f 00 19 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041b6:	c1 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041b8:	12 98       	mov	r8,r9
800041ba:	e2 18 04 00 	andl	r8,0x400,COH
800041be:	c0 70       	breq	800041cc <xcmp_rx_process+0x9c>
800041c0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041c4:	e0 48 00 68 	cp.w	r8,104
800041c8:	e0 8a 00 08 	brle	800041d8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041cc:	e2 19 f0 00 	andl	r9,0xf000,COH
800041d0:	c0 e1       	brne	800041ec <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041d2:	f0 1f 00 14 	mcall	80004220 <xcmp_rx_process+0xf0>
800041d6:	c0 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041d8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041dc:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041e0:	49 19       	lddpc	r9,80004224 <xcmp_rx_process+0xf4>
800041e2:	72 08       	ld.w	r8,r9[0x0]
800041e4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041e8:	f0 1f 00 0b 	mcall	80004214 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041ec:	66 0c       	ld.w	r12,r3[0x0]
800041ee:	40 0b       	lddsp	r11,sp[0x0]
800041f0:	f0 1f 00 0e 	mcall	80004228 <xcmp_rx_process+0xf8>
800041f4:	ca 7b       	rjmp	80004142 <xcmp_rx_process+0x12>
800041f6:	00 00       	add	r0,r0
800041f8:	00 00       	add	r0,r0
800041fa:	0b 10       	ld.sh	r0,r5++
800041fc:	00 00       	add	r0,r0
800041fe:	0a a4       	st.w	r5++,r4
80004200:	00 00       	add	r0,r0
80004202:	0b 20       	ld.uh	r0,r5++
80004204:	00 00       	add	r0,r0
80004206:	0b 14       	ld.sh	r4,r5++
80004208:	00 00       	add	r0,r0
8000420a:	0b 04       	ld.w	r4,r5++
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	61 c4       	ld.w	r4,r0[0x70]
80004210:	00 00       	add	r0,r0
80004212:	0b 38       	ld.ub	r8,r5++
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	40 34       	lddsp	r4,sp[0xc]
80004218:	00 00       	add	r0,r0
8000421a:	0a f8       	st.b	--r5,r8
8000421c:	00 00       	add	r0,r0
8000421e:	0b 2c       	ld.uh	r12,r5++
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	40 10       	lddsp	r0,sp[0x4]
80004224:	00 00       	add	r0,r0
80004226:	53 98       	stdsp	sp[0xe4],r8
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	2c 0c       	sub	r12,-64

8000422c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000422c:	eb cd 40 90 	pushm	r4,r7,lr
80004230:	20 1d       	sub	sp,4
80004232:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004236:	48 c8       	lddpc	r8,80004264 <xcmp_rx+0x38>
80004238:	70 0c       	ld.w	r12,r8[0x0]
8000423a:	f0 1f 00 0c 	mcall	80004268 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000423e:	c1 00       	breq	8000425e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004240:	fa c7 ff fc 	sub	r7,sp,-4
80004244:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004246:	e0 6a 00 ca 	mov	r10,202
8000424a:	08 9b       	mov	r11,r4
8000424c:	f0 1f 00 08 	mcall	8000426c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004250:	48 88       	lddpc	r8,80004270 <xcmp_rx+0x44>
80004252:	70 0c       	ld.w	r12,r8[0x0]
80004254:	30 09       	mov	r9,0
80004256:	12 9a       	mov	r10,r9
80004258:	1a 9b       	mov	r11,sp
8000425a:	f0 1f 00 07 	mcall	80004274 <xcmp_rx+0x48>
	}	
}
8000425e:	2f fd       	sub	sp,-4
80004260:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004264:	00 00       	add	r0,r0
80004266:	0a a4       	st.w	r5++,r4
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	2d b8       	sub	r8,-37
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	78 8c       	ld.w	r12,r12[0x20]
80004270:	00 00       	add	r0,r0
80004272:	0b 10       	ld.sh	r0,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	63 d0       	ld.w	r0,r1[0x74]

80004278 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004278:	48 28       	lddpc	r8,80004280 <xnl_register_xcmp_func+0x8>
8000427a:	91 0c       	st.w	r8[0x0],r12
}
8000427c:	5e fc       	retal	r12
8000427e:	00 00       	add	r0,r0
80004280:	00 00       	add	r0,r0
80004282:	0b 64       	ld.uh	r4,--r5

80004284 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004284:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004286:	48 88       	lddpc	r8,800042a4 <xnl_get_msg_ack_func+0x20>
80004288:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000428a:	98 49       	ld.sh	r9,r12[0x8]
8000428c:	f0 09 19 00 	cp.h	r9,r8
80004290:	c0 81       	brne	800042a0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004292:	48 68       	lddpc	r8,800042a8 <xnl_get_msg_ack_func+0x24>
80004294:	70 0c       	ld.w	r12,r8[0x0]
80004296:	30 09       	mov	r9,0
80004298:	12 9a       	mov	r10,r9
8000429a:	12 9b       	mov	r11,r9
8000429c:	f0 1f 00 04 	mcall	800042ac <xnl_get_msg_ack_func+0x28>
800042a0:	d8 02       	popm	pc
800042a2:	00 00       	add	r0,r0
800042a4:	00 00       	add	r0,r0
800042a6:	0b 4a       	ld.w	r10,--r5
800042a8:	00 00       	add	r0,r0
800042aa:	0b 44       	ld.w	r4,--r5
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	63 d0       	ld.w	r0,r1[0x74]

800042b0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042b0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800042b4:	30 09       	mov	r9,0
800042b6:	4b 78       	lddpc	r8,80004390 <xnl_init+0xe0>
800042b8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042ba:	30 0b       	mov	r11,0
800042bc:	30 1c       	mov	r12,1
800042be:	f0 1f 00 36 	mcall	80004394 <xnl_init+0xe4>
800042c2:	4b 68       	lddpc	r8,80004398 <xnl_init+0xe8>
800042c4:	91 0c       	st.w	r8[0x0],r12
800042c6:	70 08       	ld.w	r8,r8[0x0]
800042c8:	58 08       	cp.w	r8,0
800042ca:	c0 80       	breq	800042da <xnl_init+0x2a>
800042cc:	4b 38       	lddpc	r8,80004398 <xnl_init+0xe8>
800042ce:	70 0c       	ld.w	r12,r8[0x0]
800042d0:	30 09       	mov	r9,0
800042d2:	12 9a       	mov	r10,r9
800042d4:	12 9b       	mov	r11,r9
800042d6:	f0 1f 00 32 	mcall	8000439c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042da:	30 4b       	mov	r11,4
800042dc:	31 4c       	mov	r12,20
800042de:	f0 1f 00 2e 	mcall	80004394 <xnl_init+0xe4>
800042e2:	4b 08       	lddpc	r8,800043a0 <xnl_init+0xf0>
800042e4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042e6:	30 4b       	mov	r11,4
800042e8:	31 ec       	mov	r12,30
800042ea:	f0 1f 00 2b 	mcall	80004394 <xnl_init+0xe4>
800042ee:	4a e8       	lddpc	r8,800043a4 <xnl_init+0xf4>
800042f0:	91 0c       	st.w	r8[0x0],r12
800042f2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042f4:	10 96       	mov	r6,r8
800042f6:	4a d5       	lddpc	r5,800043a8 <xnl_init+0xf8>
800042f8:	6c 0c       	ld.w	r12,r6[0x0]
800042fa:	ea 07 00 0b 	add	r11,r5,r7
800042fe:	f0 1f 00 2c 	mcall	800043ac <xnl_init+0xfc>
80004302:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004306:	e0 47 1e 00 	cp.w	r7,7680
8000430a:	cf 71       	brne	800042f8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000430c:	30 4b       	mov	r11,4
8000430e:	31 4c       	mov	r12,20
80004310:	f0 1f 00 21 	mcall	80004394 <xnl_init+0xe4>
80004314:	4a 78       	lddpc	r8,800043b0 <xnl_init+0x100>
80004316:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004318:	30 4b       	mov	r11,4
8000431a:	30 ac       	mov	r12,10
8000431c:	f0 1f 00 1e 	mcall	80004394 <xnl_init+0xe4>
80004320:	4a 58       	lddpc	r8,800043b4 <xnl_init+0x104>
80004322:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004324:	30 4b       	mov	r11,4
80004326:	30 ac       	mov	r12,10
80004328:	f0 1f 00 1b 	mcall	80004394 <xnl_init+0xe4>
8000432c:	4a 38       	lddpc	r8,800043b8 <xnl_init+0x108>
8000432e:	91 0c       	st.w	r8[0x0],r12
80004330:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004332:	10 96       	mov	r6,r8
80004334:	4a 25       	lddpc	r5,800043bc <xnl_init+0x10c>
80004336:	6c 0c       	ld.w	r12,r6[0x0]
80004338:	ea 07 00 0b 	add	r11,r5,r7
8000433c:	f0 1f 00 1c 	mcall	800043ac <xnl_init+0xfc>
80004340:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004344:	e0 47 14 00 	cp.w	r7,5120
80004348:	cf 71       	brne	80004336 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000434a:	30 4b       	mov	r11,4
8000434c:	30 5c       	mov	r12,5
8000434e:	f0 1f 00 12 	mcall	80004394 <xnl_init+0xe4>
80004352:	49 c8       	lddpc	r8,800043c0 <xnl_init+0x110>
80004354:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004356:	30 07       	mov	r7,0
80004358:	1a d7       	st.w	--sp,r7
8000435a:	1a d7       	st.w	--sp,r7
8000435c:	1a d7       	st.w	--sp,r7
8000435e:	30 38       	mov	r8,3
80004360:	0e 99       	mov	r9,r7
80004362:	e0 6a 00 dc 	mov	r10,220
80004366:	49 8b       	lddpc	r11,800043c4 <xnl_init+0x114>
80004368:	49 8c       	lddpc	r12,800043c8 <xnl_init+0x118>
8000436a:	f0 1f 00 19 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000436e:	1a d7       	st.w	--sp,r7
80004370:	1a d7       	st.w	--sp,r7
80004372:	1a d7       	st.w	--sp,r7
80004374:	30 38       	mov	r8,3
80004376:	0e 99       	mov	r9,r7
80004378:	e0 6a 00 82 	mov	r10,130
8000437c:	49 5b       	lddpc	r11,800043d0 <xnl_init+0x120>
8000437e:	49 6c       	lddpc	r12,800043d4 <xnl_init+0x124>
80004380:	f0 1f 00 13 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004384:	f0 1f 00 15 	mcall	800043d8 <xnl_init+0x128>
80004388:	2f ad       	sub	sp,-24
}
8000438a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000438e:	00 00       	add	r0,r0
80004390:	00 00       	add	r0,r0
80004392:	0b 4a       	ld.w	r10,--r5
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	65 28       	ld.w	r8,r2[0x48]
80004398:	00 00       	add	r0,r0
8000439a:	0b 44       	ld.w	r4,--r5
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	63 d0       	ld.w	r0,r1[0x74]
800043a0:	00 00       	add	r0,r0
800043a2:	0b 58       	ld.sh	r8,--r5
800043a4:	00 00       	add	r0,r0
800043a6:	0a a4       	st.w	r5++,r4
800043a8:	00 00       	add	r0,r0
800043aa:	35 4a       	mov	r10,84
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	2c 0c       	sub	r12,-64
800043b0:	00 00       	add	r0,r0
800043b2:	0a d4       	st.w	--r5,r4
800043b4:	00 00       	add	r0,r0
800043b6:	0a b4       	st.h	r5++,r4
800043b8:	00 00       	add	r0,r0
800043ba:	0a a8       	st.w	r5++,r8
800043bc:	00 00       	add	r0,r0
800043be:	21 4a       	sub	r10,20
800043c0:	00 00       	add	r0,r0
800043c2:	0a e0       	st.h	--r5,r0
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	d7 f0       	acall	0x7f
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	43 dc       	lddsp	r12,sp[0xf4]
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	6c 44       	ld.w	r4,r6[0x10]
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	d7 f8       	*unknown*
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	44 3c       	lddsp	r12,sp[0x10c]
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	2d e0       	sub	r0,-34

800043dc <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043dc:	eb cd 40 fe 	pushm	r1-r7,lr
800043e0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043e2:	49 26       	lddpc	r6,80004428 <xnl_rx_process+0x4c>
800043e4:	30 05       	mov	r5,0
800043e6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043e8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ea:	49 11       	lddpc	r1,8000442c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043ec:	49 12       	lddpc	r2,80004430 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043ee:	6c 0c       	ld.w	r12,r6[0x0]
800043f0:	0a 99       	mov	r9,r5
800043f2:	08 9a       	mov	r10,r4
800043f4:	1a 9b       	mov	r11,sp
800043f6:	f0 1f 00 10 	mcall	80004434 <xnl_rx_process+0x58>
800043fa:	58 1c       	cp.w	r12,1
800043fc:	cf 91       	brne	800043ee <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043fe:	40 0c       	lddsp	r12,sp[0x0]
80004400:	58 0c       	cp.w	r12,0
80004402:	cf 60       	breq	800043ee <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004404:	98 28       	ld.sh	r8,r12[0x4]
80004406:	e6 08 19 00 	cp.h	r8,r3
8000440a:	e0 8b 00 0a 	brhi	8000441e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000440e:	5c 78       	castu.h	r8
80004410:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004414:	58 09       	cp.w	r9,0
80004416:	c0 40       	breq	8000441e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004418:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000441c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000441e:	62 0c       	ld.w	r12,r1[0x0]
80004420:	40 0b       	lddsp	r11,sp[0x0]
80004422:	f0 1f 00 06 	mcall	80004438 <xnl_rx_process+0x5c>
80004426:	ce 4b       	rjmp	800043ee <xnl_rx_process+0x12>
80004428:	00 00       	add	r0,r0
8000442a:	0a b4       	st.h	r5++,r4
8000442c:	00 00       	add	r0,r0
8000442e:	0a a4       	st.w	r5++,r4
80004430:	00 00       	add	r0,r0
80004432:	04 f8       	st.b	--r2,r8
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	61 c4       	ld.w	r4,r0[0x70]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	2c 0c       	sub	r12,-64

8000443c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000443c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000443e:	4a a6       	lddpc	r6,800044e4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004440:	4a a2       	lddpc	r2,800044e8 <xnl_tx_process+0xac>
80004442:	4a b4       	lddpc	r4,800044ec <xnl_tx_process+0xb0>
80004444:	30 07       	mov	r7,0
80004446:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004448:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000444a:	4a a5       	lddpc	r5,800044f0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000444c:	4a a3       	lddpc	r3,800044f4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000444e:	6c 08       	ld.w	r8,r6[0x0]
80004450:	58 08       	cp.w	r8,0
80004452:	c0 40       	breq	8000445a <xnl_tx_process+0x1e>
80004454:	58 18       	cp.w	r8,1
80004456:	cf d1       	brne	80004450 <xnl_tx_process+0x14>
80004458:	c2 48       	rjmp	800044a0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000445a:	64 0c       	ld.w	r12,r2[0x0]
8000445c:	0e 99       	mov	r9,r7
8000445e:	02 9a       	mov	r10,r1
80004460:	08 9b       	mov	r11,r4
80004462:	f0 1f 00 26 	mcall	800044f8 <xnl_tx_process+0xbc>
80004466:	58 1c       	cp.w	r12,1
80004468:	cf 31       	brne	8000444e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000446a:	68 0b       	ld.w	r11,r4[0x0]
8000446c:	58 0b       	cp.w	r11,0
8000446e:	cf 00       	breq	8000444e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004470:	96 28       	ld.sh	r8,r11[0x4]
80004472:	e0 08 19 00 	cp.h	r8,r0
80004476:	c0 71       	brne	80004484 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004478:	4a 18       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
8000447a:	70 08       	ld.w	r8,r8[0x0]
8000447c:	10 9c       	mov	r12,r8
8000447e:	f0 1f 00 21 	mcall	80004500 <xnl_tx_process+0xc4>
						break;
80004482:	ce 6b       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004484:	16 9c       	mov	r12,r11
80004486:	f0 1f 00 20 	mcall	80004504 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000448a:	30 18       	mov	r8,1
8000448c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000448e:	66 0c       	ld.w	r12,r3[0x0]
80004490:	0e 99       	mov	r9,r7
80004492:	0e 9a       	mov	r10,r7
80004494:	0e 9b       	mov	r11,r7
80004496:	f0 1f 00 19 	mcall	800044f8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000449a:	30 18       	mov	r8,1
8000449c:	8d 08       	st.w	r6[0x0],r8
8000449e:	cd 8b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044a0:	66 0c       	ld.w	r12,r3[0x0]
800044a2:	0e 99       	mov	r9,r7
800044a4:	36 4a       	mov	r10,100
800044a6:	0e 9b       	mov	r11,r7
800044a8:	f0 1f 00 14 	mcall	800044f8 <xnl_tx_process+0xbc>
800044ac:	58 1c       	cp.w	r12,1
800044ae:	c0 81       	brne	800044be <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800044b0:	49 38       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044b2:	70 0c       	ld.w	r12,r8[0x0]
800044b4:	68 0b       	ld.w	r11,r4[0x0]
800044b6:	f0 1f 00 13 	mcall	80004500 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800044ba:	8d 07       	st.w	r6[0x0],r7
800044bc:	cc 9b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800044be:	6a 08       	ld.w	r8,r5[0x0]
800044c0:	58 38       	cp.w	r8,3
800044c2:	e0 89 00 09 	brgt	800044d4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800044c6:	68 0c       	ld.w	r12,r4[0x0]
800044c8:	f0 1f 00 0f 	mcall	80004504 <xnl_tx_process+0xc8>
						xnl_send_times++;
800044cc:	6a 08       	ld.w	r8,r5[0x0]
800044ce:	2f f8       	sub	r8,-1
800044d0:	8b 08       	st.w	r5[0x0],r8
800044d2:	cb eb       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044d4:	48 a8       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044d6:	70 0c       	ld.w	r12,r8[0x0]
800044d8:	68 0b       	ld.w	r11,r4[0x0]
800044da:	f0 1f 00 0a 	mcall	80004500 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044de:	8d 07       	st.w	r6[0x0],r7
800044e0:	cb 7b       	rjmp	8000444e <xnl_tx_process+0x12>
800044e2:	00 00       	add	r0,r0
800044e4:	00 00       	add	r0,r0
800044e6:	0b 54       	ld.sh	r4,--r5
800044e8:	00 00       	add	r0,r0
800044ea:	0b 58       	ld.sh	r8,--r5
800044ec:	00 00       	add	r0,r0
800044ee:	0b 60       	ld.uh	r0,--r5
800044f0:	00 00       	add	r0,r0
800044f2:	0b 5c       	ld.sh	r12,--r5
800044f4:	00 00       	add	r0,r0
800044f6:	0b 44       	ld.w	r4,--r5
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	61 c4       	ld.w	r4,r0[0x70]
800044fc:	00 00       	add	r0,r0
800044fe:	0a a4       	st.w	r5++,r4
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	2c 0c       	sub	r12,-64
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	2c 2c       	sub	r12,-62

80004508 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004508:	eb cd 40 c0 	pushm	r6-r7,lr
8000450c:	20 1d       	sub	sp,4
8000450e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004510:	98 39       	ld.sh	r9,r12[0x6]
80004512:	3f f8       	mov	r8,-1
80004514:	f0 09 19 00 	cp.h	r9,r8
80004518:	c0 a1       	brne	8000452c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000451a:	4a e9       	lddpc	r9,800045d0 <xnl_tx+0xc8>
8000451c:	13 88       	ld.ub	r8,r9[0x0]
8000451e:	2f f8       	sub	r8,-1
80004520:	5c 58       	castu.b	r8
80004522:	b2 88       	st.b	r9[0x0],r8
80004524:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004528:	a9 a8       	sbr	r8,0x8
8000452a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000452c:	8c 49       	ld.sh	r9,r6[0x8]
8000452e:	3f f8       	mov	r8,-1
80004530:	f0 09 19 00 	cp.h	r9,r8
80004534:	c0 41       	brne	8000453c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004536:	4a 88       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004538:	90 18       	ld.sh	r8,r8[0x2]
8000453a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000453c:	8c 59       	ld.sh	r9,r6[0xa]
8000453e:	3f f8       	mov	r8,-1
80004540:	f0 09 19 00 	cp.h	r9,r8
80004544:	c0 41       	brne	8000454c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004546:	4a 48       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004548:	90 28       	ld.sh	r8,r8[0x4]
8000454a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000454c:	8c 69       	ld.sh	r9,r6[0xc]
8000454e:	3f f8       	mov	r8,-1
80004550:	f0 09 19 00 	cp.h	r9,r8
80004554:	c0 e1       	brne	80004570 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004556:	4a 08       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004558:	90 49       	ld.sh	r9,r8[0x8]
8000455a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000455c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000455e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004560:	90 49       	ld.sh	r9,r8[0x8]
80004562:	e0 19 ff 00 	andl	r9,0xff00
80004566:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000456a:	f3 e8 10 08 	or	r8,r9,r8
8000456e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004570:	0d 98       	ld.ub	r8,r6[0x1]
80004572:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004574:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004578:	10 0c       	add	r12,r8
8000457a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000457c:	58 0c       	cp.w	r12,0
8000457e:	e0 89 00 04 	brgt	80004586 <xnl_tx+0x7e>
80004582:	30 09       	mov	r9,0
80004584:	c0 d8       	rjmp	8000459e <xnl_tx+0x96>
80004586:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000458a:	2f ec       	sub	r12,-2
8000458c:	30 09       	mov	r9,0
8000458e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004590:	15 1b       	ld.sh	r11,r10++
80004592:	f6 09 00 09 	add	r9,r11,r9
80004596:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004598:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000459a:	18 38       	cp.w	r8,r12
8000459c:	cf a1       	brne	80004590 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000459e:	5c 39       	neg	r9
800045a0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045a2:	48 e8       	lddpc	r8,800045d8 <xnl_tx+0xd0>
800045a4:	70 0c       	ld.w	r12,r8[0x0]
800045a6:	f0 1f 00 0e 	mcall	800045dc <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045aa:	c1 00       	breq	800045ca <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045ac:	fa c7 ff fc 	sub	r7,sp,-4
800045b0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045b2:	e0 6a 01 00 	mov	r10,256
800045b6:	0c 9b       	mov	r11,r6
800045b8:	f0 1f 00 0a 	mcall	800045e0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045bc:	48 a8       	lddpc	r8,800045e4 <xnl_tx+0xdc>
800045be:	70 0c       	ld.w	r12,r8[0x0]
800045c0:	30 09       	mov	r9,0
800045c2:	12 9a       	mov	r10,r9
800045c4:	1a 9b       	mov	r11,sp
800045c6:	f0 1f 00 09 	mcall	800045e8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800045ca:	2f fd       	sub	sp,-4
800045cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045d0:	00 00       	add	r0,r0
800045d2:	0b 48       	ld.w	r8,--r5
800045d4:	00 00       	add	r0,r0
800045d6:	0b 4a       	ld.w	r10,--r5
800045d8:	00 00       	add	r0,r0
800045da:	0a a4       	st.w	r5++,r4
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	2d b8       	sub	r8,-37
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	78 8c       	ld.w	r12,r12[0x20]
800045e4:	00 00       	add	r0,r0
800045e6:	0b 58       	ld.sh	r8,--r5
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	63 d0       	ld.w	r0,r1[0x74]

800045ec <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045ec:	eb cd 40 80 	pushm	r7,lr
800045f0:	fa cd 01 00 	sub	sp,sp,256
800045f4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045f6:	e0 68 40 0e 	mov	r8,16398
800045fa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045fc:	3f f8       	mov	r8,-1
800045fe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004600:	30 c8       	mov	r8,12
80004602:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004604:	98 38       	ld.sh	r8,r12[0x6]
80004606:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004608:	98 58       	ld.sh	r8,r12[0xa]
8000460a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000460c:	98 48       	ld.sh	r8,r12[0x8]
8000460e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004610:	98 68       	ld.sh	r8,r12[0xc]
80004612:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004614:	30 08       	mov	r8,0
80004616:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004618:	1a 9c       	mov	r12,sp
8000461a:	f0 1f 00 0a 	mcall	80004640 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000461e:	fa cd 00 cc 	sub	sp,sp,204
80004622:	e0 6a 00 ca 	mov	r10,202
80004626:	ee cb ff f0 	sub	r11,r7,-16
8000462a:	1a 9c       	mov	r12,sp
8000462c:	f0 1f 00 06 	mcall	80004644 <xnl_data_msg_func+0x58>
80004630:	48 68       	lddpc	r8,80004648 <xnl_data_msg_func+0x5c>
80004632:	70 08       	ld.w	r8,r8[0x0]
80004634:	5d 18       	icall	r8
80004636:	fa cd ff 34 	sub	sp,sp,-204
}
8000463a:	2c 0d       	sub	sp,-256
8000463c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	45 08       	lddsp	r8,sp[0x140]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	78 8c       	ld.w	r12,r12[0x20]
80004648:	00 00       	add	r0,r0
8000464a:	0b 64       	ld.uh	r4,--r5

8000464c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000464c:	d4 21       	pushm	r4-r7,lr
8000464e:	fa cd 01 00 	sub	sp,sp,256
80004652:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004654:	4c 28       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004656:	11 88       	ld.ub	r8,r8[0x0]
80004658:	58 08       	cp.w	r8,0
8000465a:	e0 81 00 7f 	brne	80004758 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000465e:	4c 18       	lddpc	r8,80004760 <xnl_device_auth_reply_func+0x114>
80004660:	70 0c       	ld.w	r12,r8[0x0]
80004662:	30 09       	mov	r9,0
80004664:	12 9a       	mov	r10,r9
80004666:	12 9b       	mov	r11,r9
80004668:	f0 1f 00 3f 	mcall	80004764 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000466c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004670:	4b b8       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004672:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004674:	ef 39 00 12 	ld.ub	r9,r7[18]
80004678:	ef 38 00 13 	ld.ub	r8,r7[19]
8000467c:	b1 68       	lsl	r8,0x10
8000467e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004682:	ef 38 00 15 	ld.ub	r8,r7[21]
80004686:	f3 e8 10 08 	or	r8,r9,r8
8000468a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000468e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004692:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004696:	ef 38 00 17 	ld.ub	r8,r7[23]
8000469a:	b1 68       	lsl	r8,0x10
8000469c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046a0:	ef 38 00 19 	ld.ub	r8,r7[25]
800046a4:	f5 e8 10 08 	or	r8,r10,r8
800046a8:	ef 3a 00 18 	ld.ub	r10,r7[24]
800046ac:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800046b0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046b2:	e0 64 79 b9 	mov	r4,31161
800046b6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046ba:	e0 65 45 07 	mov	r5,17671
800046be:	ea 15 8a bd 	orh	r5,0x8abd
800046c2:	e0 66 f9 3d 	mov	r6,63805
800046c6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046ca:	e0 6e b8 cf 	mov	lr,47311
800046ce:	ea 1e 36 83 	orh	lr,0x3683
800046d2:	e0 67 aa 1c 	mov	r7,43548
800046d6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046da:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046dc:	f4 08 00 0c 	add	r12,r10,r8
800046e0:	f0 0b 15 04 	lsl	r11,r8,0x4
800046e4:	0a 0b       	add	r11,r5
800046e6:	f9 eb 20 0b 	eor	r11,r12,r11
800046ea:	f0 0c 16 05 	lsr	r12,r8,0x5
800046ee:	0c 0c       	add	r12,r6
800046f0:	18 5b       	eor	r11,r12
800046f2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046f4:	f2 0c 15 04 	lsl	r12,r9,0x4
800046f8:	1c 0c       	add	r12,lr
800046fa:	f2 0b 16 05 	lsr	r11,r9,0x5
800046fe:	0e 0b       	add	r11,r7
80004700:	f9 eb 20 0b 	eor	r11,r12,r11
80004704:	f2 0a 00 0c 	add	r12,r9,r10
80004708:	18 5b       	eor	r11,r12
8000470a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000470c:	e0 6b 37 20 	mov	r11,14112
80004710:	ea 1b c6 ef 	orh	r11,0xc6ef
80004714:	16 3a       	cp.w	r10,r11
80004716:	ce 21       	brne	800046da <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004718:	e0 6a 40 1a 	mov	r10,16410
8000471c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000471e:	3f fa       	mov	r10,-1
80004720:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004722:	30 6b       	mov	r11,6
80004724:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004726:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004728:	48 db       	lddpc	r11,8000475c <xnl_device_auth_reply_func+0x110>
8000472a:	96 1c       	ld.sh	r12,r11[0x2]
8000472c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000472e:	96 2b       	ld.sh	r11,r11[0x4]
80004730:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004732:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004734:	30 ca       	mov	r10,12
80004736:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004738:	30 0a       	mov	r10,0
8000473a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000473e:	30 7a       	mov	r10,7
80004740:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004744:	30 2a       	mov	r10,2
80004746:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000474a:	fa ca ff ec 	sub	r10,sp,-20
8000474e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004750:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004752:	1a 9c       	mov	r12,sp
80004754:	f0 1f 00 05 	mcall	80004768 <xnl_device_auth_reply_func+0x11c>
}
80004758:	2c 0d       	sub	sp,-256
8000475a:	d8 22       	popm	r4-r7,pc
8000475c:	00 00       	add	r0,r0
8000475e:	0b 4a       	ld.w	r10,--r5
80004760:	00 00       	add	r0,r0
80004762:	0b 44       	ld.w	r4,--r5
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	63 d0       	ld.w	r0,r1[0x74]
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	45 08       	lddsp	r8,sp[0x140]

8000476c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000476c:	eb cd 40 80 	pushm	r7,lr
80004770:	fa cd 01 00 	sub	sp,sp,256
80004774:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004776:	49 28       	lddpc	r8,800047bc <xnl_master_status_brdcst_func+0x50>
80004778:	11 88       	ld.ub	r8,r8[0x0]
8000477a:	58 08       	cp.w	r8,0
8000477c:	c1 c1       	brne	800047b4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000477e:	49 18       	lddpc	r8,800047c0 <xnl_master_status_brdcst_func+0x54>
80004780:	70 0c       	ld.w	r12,r8[0x0]
80004782:	30 09       	mov	r9,0
80004784:	12 9a       	mov	r10,r9
80004786:	12 9b       	mov	r11,r9
80004788:	f0 1f 00 0f 	mcall	800047c4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000478c:	8e 58       	ld.sh	r8,r7[0xa]
8000478e:	48 c9       	lddpc	r9,800047bc <xnl_master_status_brdcst_func+0x50>
80004790:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004792:	e0 68 40 0e 	mov	r8,16398
80004796:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004798:	3f f8       	mov	r8,-1
8000479a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000479c:	30 4a       	mov	r10,4
8000479e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047a0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047a2:	92 19       	ld.sh	r9,r9[0x2]
800047a4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047a6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047a8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047aa:	30 08       	mov	r8,0
800047ac:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800047ae:	1a 9c       	mov	r12,sp
800047b0:	f0 1f 00 06 	mcall	800047c8 <xnl_master_status_brdcst_func+0x5c>
}
800047b4:	2c 0d       	sub	sp,-256
800047b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ba:	00 00       	add	r0,r0
800047bc:	00 00       	add	r0,r0
800047be:	0b 4a       	ld.w	r10,--r5
800047c0:	00 00       	add	r0,r0
800047c2:	0b 44       	ld.w	r4,--r5
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	63 d0       	ld.w	r0,r1[0x74]
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	45 08       	lddsp	r8,sp[0x140]

800047cc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800047cc:	eb cd 40 80 	pushm	r7,lr
800047d0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047d2:	49 28       	lddpc	r8,80004818 <xnl_device_conn_reply_func+0x4c>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	30 09       	mov	r9,0
800047d8:	12 9a       	mov	r10,r9
800047da:	12 9b       	mov	r11,r9
800047dc:	f0 1f 00 10 	mcall	8000481c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047e0:	ef 18 00 10 	ld.uh	r8,r7[16]
800047e4:	10 99       	mov	r9,r8
800047e6:	e2 19 ff 00 	andl	r9,0xff00,COH
800047ea:	e0 49 01 00 	cp.w	r9,256
800047ee:	c0 60       	breq	800047fa <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047f0:	0e 9c       	mov	r12,r7
800047f2:	f0 1f 00 0c 	mcall	80004820 <xnl_device_conn_reply_func+0x54>
800047f6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047fa:	a9 68       	lsl	r8,0x8
800047fc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004800:	48 98       	lddpc	r8,80004824 <xnl_device_conn_reply_func+0x58>
80004802:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004804:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004808:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000480a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000480e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004810:	30 19       	mov	r9,1
80004812:	b0 89       	st.b	r8[0x0],r9
80004814:	e3 cd 80 80 	ldm	sp++,r7,pc
80004818:	00 00       	add	r0,r0
8000481a:	0b 44       	ld.w	r4,--r5
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	63 d0       	ld.w	r0,r1[0x74]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	47 6c       	lddsp	r12,sp[0x1d8]
80004824:	00 00       	add	r0,r0
80004826:	0b 4a       	ld.w	r10,--r5

80004828 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004828:	d4 01       	pushm	lr
8000482a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000482e:	e0 68 40 0e 	mov	r8,16398
80004832:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004834:	3f f8       	mov	r8,-1
80004836:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004838:	30 38       	mov	r8,3
8000483a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000483c:	30 08       	mov	r8,0
8000483e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004840:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004842:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004844:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004846:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004848:	1a 9c       	mov	r12,sp
8000484a:	f0 1f 00 03 	mcall	80004854 <xnl_send_device_master_query+0x2c>
}
8000484e:	2c 0d       	sub	sp,-256
80004850:	d8 02       	popm	pc
80004852:	00 00       	add	r0,r0
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	45 08       	lddsp	r8,sp[0x140]

80004858 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004858:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000485a:	48 78       	lddpc	r8,80004874 <RC522_SPI_SetSpeed+0x1c>
8000485c:	70 09       	ld.w	r9,r8[0x0]
8000485e:	72 ca       	ld.w	r10,r9[0x30]
80004860:	5c 7c       	castu.h	r12
80004862:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004866:	f9 ea 10 0a 	or	r10,r12,r10
8000486a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000486c:	70 0c       	ld.w	r12,r8[0x0]
8000486e:	f0 1f 00 03 	mcall	80004878 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004872:	d8 02       	popm	pc
80004874:	00 00       	add	r0,r0
80004876:	20 24       	sub	r4,2
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	58 c0       	cp.w	r0,12

8000487c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000487c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000487e:	e0 6c 04 00 	mov	r12,1024
80004882:	f0 1f 00 02 	mcall	80004888 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004886:	d8 02       	popm	pc
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	48 58       	lddpc	r8,8000489c <RC522_ReadByte+0x10>

8000488c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000488c:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004890:	48 b7       	lddpc	r7,800048bc <RC522_ReadByte+0x30>
80004892:	30 0b       	mov	r11,0
80004894:	6e 0c       	ld.w	r12,r7[0x0]
80004896:	f0 1f 00 0b 	mcall	800048c0 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000489a:	e0 6b 00 ff 	mov	r11,255
8000489e:	6e 0c       	ld.w	r12,r7[0x0]
800048a0:	f0 1f 00 09 	mcall	800048c4 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800048a4:	30 06       	mov	r6,0
800048a6:	0c 9b       	mov	r11,r6
800048a8:	6e 0c       	ld.w	r12,r7[0x0]
800048aa:	f0 1f 00 08 	mcall	800048c8 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048ae:	0c 9b       	mov	r11,r6
800048b0:	6e 0c       	ld.w	r12,r7[0x0]
800048b2:	f0 1f 00 07 	mcall	800048cc <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
800048b6:	0d 9c       	ld.ub	r12,r6[0x1]
800048b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048bc:	00 00       	add	r0,r0
800048be:	20 24       	sub	r4,2
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	5a 2c       	cp.w	r12,-30
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	58 c6       	cp.w	r6,12
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	58 e2       	cp.w	r2,14
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	59 ec       	cp.w	r12,30

800048d0 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800048d0:	eb cd 40 c0 	pushm	r6-r7,lr
800048d4:	20 1d       	sub	sp,4
800048d6:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048d8:	48 c7       	lddpc	r7,80004908 <RC522_WriteByte+0x38>
800048da:	30 0b       	mov	r11,0
800048dc:	6e 0c       	ld.w	r12,r7[0x0]
800048de:	f0 1f 00 0c 	mcall	8000490c <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048e2:	1b 8b       	ld.ub	r11,sp[0x0]
800048e4:	6e 0c       	ld.w	r12,r7[0x0]
800048e6:	f0 1f 00 0b 	mcall	80004910 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048ea:	1a 9b       	mov	r11,sp
800048ec:	6e 0c       	ld.w	r12,r7[0x0]
800048ee:	f0 1f 00 0a 	mcall	80004914 <RC522_WriteByte+0x44>
800048f2:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048f4:	30 0b       	mov	r11,0
800048f6:	6e 0c       	ld.w	r12,r7[0x0]
800048f8:	f0 1f 00 08 	mcall	80004918 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048fc:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004900:	2f fd       	sub	sp,-4
80004902:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004906:	00 00       	add	r0,r0
80004908:	00 00       	add	r0,r0
8000490a:	20 24       	sub	r4,2
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	5a 2c       	cp.w	r12,-30
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	58 c6       	cp.w	r6,12
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	58 e2       	cp.w	r2,14
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	59 ec       	cp.w	r12,30

8000491c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000491c:	eb cd 40 c0 	pushm	r6-r7,lr
80004920:	18 96       	mov	r6,r12
80004922:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004924:	31 8c       	mov	r12,24
80004926:	f0 1f 00 09 	mcall	80004948 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000492a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000492e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004932:	f0 1f 00 07 	mcall	8000494c <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004936:	0e 9c       	mov	r12,r7
80004938:	f0 1f 00 05 	mcall	8000494c <WriteRawRC+0x30>
	
	SET_SPI_CS;
8000493c:	31 8c       	mov	r12,24
8000493e:	f0 1f 00 05 	mcall	80004950 <WriteRawRC+0x34>

}
80004942:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004946:	00 00       	add	r0,r0
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	54 50       	stdsp	sp[0x114],r0
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 d0       	lddpc	r0,80004980 <PcdReset+0x2c>
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	54 34       	stdsp	sp[0x10c],r4

80004954 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004954:	d4 01       	pushm	lr

	SET_RC522RST;
80004956:	31 9c       	mov	r12,25
80004958:	f0 1f 00 1b 	mcall	800049c4 <PcdReset+0x70>
	delay_ns(10);
8000495c:	30 ac       	mov	r12,10
8000495e:	f0 1f 00 1b 	mcall	800049c8 <PcdReset+0x74>

	CLR_RC522RST;
80004962:	31 9c       	mov	r12,25
80004964:	f0 1f 00 1a 	mcall	800049cc <PcdReset+0x78>
	delay_ns(10);
80004968:	30 ac       	mov	r12,10
8000496a:	f0 1f 00 18 	mcall	800049c8 <PcdReset+0x74>

	SET_RC522RST;
8000496e:	31 9c       	mov	r12,25
80004970:	f0 1f 00 15 	mcall	800049c4 <PcdReset+0x70>
	delay_ns(10);
80004974:	30 ac       	mov	r12,10
80004976:	f0 1f 00 15 	mcall	800049c8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000497a:	30 fb       	mov	r11,15
8000497c:	30 1c       	mov	r12,1
8000497e:	f0 1f 00 15 	mcall	800049d0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004982:	30 fb       	mov	r11,15
80004984:	30 1c       	mov	r12,1
80004986:	f0 1f 00 13 	mcall	800049d0 <PcdReset+0x7c>
	delay_ns(10);
8000498a:	30 ac       	mov	r12,10
8000498c:	f0 1f 00 0f 	mcall	800049c8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004990:	33 db       	mov	r11,61
80004992:	31 1c       	mov	r12,17
80004994:	f0 1f 00 0f 	mcall	800049d0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004998:	31 eb       	mov	r11,30
8000499a:	32 dc       	mov	r12,45
8000499c:	f0 1f 00 0d 	mcall	800049d0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800049a0:	30 0b       	mov	r11,0
800049a2:	32 cc       	mov	r12,44
800049a4:	f0 1f 00 0b 	mcall	800049d0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800049a8:	e0 6b 00 8d 	mov	r11,141
800049ac:	32 ac       	mov	r12,42
800049ae:	f0 1f 00 09 	mcall	800049d0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800049b2:	33 eb       	mov	r11,62
800049b4:	32 bc       	mov	r12,43
800049b6:	f0 1f 00 07 	mcall	800049d0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800049ba:	34 0b       	mov	r11,64
800049bc:	31 5c       	mov	r12,21
800049be:	f0 1f 00 05 	mcall	800049d0 <PcdReset+0x7c>
	
	return MI_OK;
}
800049c2:	d8 0a       	popm	pc,r12=0
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	54 34       	stdsp	sp[0x10c],r4
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	51 cc       	stdsp	sp[0x70],r12
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	54 50       	stdsp	sp[0x114],r0
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	49 1c       	lddpc	r12,80004a14 <SetBitMask>

800049d4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049d4:	eb cd 40 80 	pushm	r7,lr
800049d8:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800049da:	31 8c       	mov	r12,24
800049dc:	f0 1f 00 0a 	mcall	80004a04 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049e0:	ee 08 15 01 	lsl	r8,r7,0x1
800049e4:	10 9c       	mov	r12,r8
800049e6:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049ea:	a7 bc       	sbr	r12,0x7
800049ec:	f0 1f 00 07 	mcall	80004a08 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800049f0:	f0 1f 00 07 	mcall	80004a0c <ReadRawRC+0x38>
800049f4:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800049f6:	31 8c       	mov	r12,24
800049f8:	f0 1f 00 06 	mcall	80004a10 <ReadRawRC+0x3c>
	return ucResult;
}
800049fc:	0e 9c       	mov	r12,r7
800049fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a02:	00 00       	add	r0,r0
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	54 50       	stdsp	sp[0x114],r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 d0       	lddpc	r0,80004a3c <PcdAntennaOn+0x4>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	48 8c       	lddpc	r12,80004a2c <SetBitMask+0x18>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	54 34       	stdsp	sp[0x10c],r4

80004a14 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a14:	eb cd 40 c0 	pushm	r6-r7,lr
80004a18:	18 97       	mov	r7,r12
80004a1a:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a1c:	f0 1f 00 05 	mcall	80004a30 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a20:	f9 e6 10 0b 	or	r11,r12,r6
80004a24:	5c 5b       	castu.b	r11
80004a26:	0e 9c       	mov	r12,r7
80004a28:	f0 1f 00 03 	mcall	80004a34 <SetBitMask+0x20>
}
80004a2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	49 d4       	lddpc	r4,80004aa4 <M500PcdConfigISOType+0x14>
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	49 1c       	lddpc	r12,80004a78 <ClearBitMask+0x20>

80004a38 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a38:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a3a:	31 4c       	mov	r12,20
80004a3c:	f0 1f 00 05 	mcall	80004a50 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a40:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a44:	c0 51       	brne	80004a4e <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a46:	30 3b       	mov	r11,3
80004a48:	31 4c       	mov	r12,20
80004a4a:	f0 1f 00 03 	mcall	80004a54 <PcdAntennaOn+0x1c>
80004a4e:	d8 02       	popm	pc
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	49 d4       	lddpc	r4,80004ac4 <M500PcdConfigISOType+0x34>
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	4a 14       	lddpc	r4,80004ad8 <M500PcdConfigISOType+0x48>

80004a58 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a58:	eb cd 40 c0 	pushm	r6-r7,lr
80004a5c:	18 97       	mov	r7,r12
80004a5e:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a60:	f0 1f 00 06 	mcall	80004a78 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a64:	5c d6       	com	r6
80004a66:	f9 e6 00 06 	and	r6,r12,r6
80004a6a:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a6e:	0e 9c       	mov	r12,r7
80004a70:	f0 1f 00 03 	mcall	80004a7c <ClearBitMask+0x24>
	
}
80004a74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	49 d4       	lddpc	r4,80004aec <M500PcdConfigISOType+0x5c>
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	49 1c       	lddpc	r12,80004ac0 <M500PcdConfigISOType+0x30>

80004a80 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a80:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a82:	30 3b       	mov	r11,3
80004a84:	31 4c       	mov	r12,20
80004a86:	f0 1f 00 02 	mcall	80004a8c <PcdAntennaOff+0xc>
}
80004a8a:	d8 02       	popm	pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	4a 58       	lddpc	r8,80004b20 <rc522_init+0x20>

80004a90 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a90:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a92:	34 18       	mov	r8,65
80004a94:	f0 0c 18 00 	cp.b	r12,r8
80004a98:	c0 20       	breq	80004a9c <M500PcdConfigISOType+0xc>
80004a9a:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a9c:	30 8b       	mov	r11,8
80004a9e:	16 9c       	mov	r12,r11
80004aa0:	f0 1f 00 14 	mcall	80004af0 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004aa4:	33 db       	mov	r11,61
80004aa6:	31 1c       	mov	r12,17
80004aa8:	f0 1f 00 13 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004aac:	e0 6b 00 86 	mov	r11,134
80004ab0:	31 7c       	mov	r12,23
80004ab2:	f0 1f 00 11 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004ab6:	37 fb       	mov	r11,127
80004ab8:	32 6c       	mov	r12,38
80004aba:	f0 1f 00 0f 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004abe:	31 eb       	mov	r11,30
80004ac0:	32 dc       	mov	r12,45
80004ac2:	f0 1f 00 0d 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004ac6:	30 0b       	mov	r11,0
80004ac8:	32 cc       	mov	r12,44
80004aca:	f0 1f 00 0b 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004ace:	e0 6b 00 8d 	mov	r11,141
80004ad2:	32 ac       	mov	r12,42
80004ad4:	f0 1f 00 08 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004ad8:	33 eb       	mov	r11,62
80004ada:	32 bc       	mov	r12,43
80004adc:	f0 1f 00 06 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004ae0:	e0 6c 03 e8 	mov	r12,1000
80004ae4:	f0 1f 00 05 	mcall	80004af8 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ae8:	f0 1f 00 05 	mcall	80004afc <M500PcdConfigISOType+0x6c>
80004aec:	d8 0a       	popm	pc,r12=0
80004aee:	00 00       	add	r0,r0
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	4a 58       	lddpc	r8,80004b84 <rc522_init+0x84>
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	49 1c       	lddpc	r12,80004b38 <rc522_init+0x38>
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	51 cc       	stdsp	sp[0x70],r12
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	4a 38       	lddpc	r8,80004b88 <rc522_init+0x88>

80004b00 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b00:	eb cd 40 c0 	pushm	r6-r7,lr
80004b04:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b06:	4a 28       	lddpc	r8,80004b8c <rc522_init+0x8c>
80004b08:	1a 96       	mov	r6,sp
80004b0a:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b0e:	fa eb 00 00 	st.d	sp[0],r10
80004b12:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b16:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b1a:	30 4b       	mov	r11,4
80004b1c:	49 dc       	lddpc	r12,80004b90 <rc522_init+0x90>
80004b1e:	f0 1f 00 1e 	mcall	80004b94 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b22:	31 9c       	mov	r12,25
80004b24:	f0 1f 00 1d 	mcall	80004b98 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b28:	31 9c       	mov	r12,25
80004b2a:	f0 1f 00 1d 	mcall	80004b9c <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004b2e:	49 d7       	lddpc	r7,80004ba0 <rc522_init+0xa0>
80004b30:	fe 7c 24 00 	mov	r12,-56320
80004b34:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b36:	1a 9b       	mov	r11,sp
80004b38:	f0 1f 00 1b 	mcall	80004ba4 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b3c:	30 09       	mov	r9,0
80004b3e:	12 9a       	mov	r10,r9
80004b40:	12 9b       	mov	r11,r9
80004b42:	6e 0c       	ld.w	r12,r7[0x0]
80004b44:	f0 1f 00 19 	mcall	80004ba8 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004b48:	6e 0c       	ld.w	r12,r7[0x0]
80004b4a:	f0 1f 00 19 	mcall	80004bac <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b4e:	e0 6a 36 00 	mov	r10,13824
80004b52:	ea 1a 01 6e 	orh	r10,0x16e
80004b56:	1a 9b       	mov	r11,sp
80004b58:	6e 0c       	ld.w	r12,r7[0x0]
80004b5a:	f0 1f 00 16 	mcall	80004bb0 <rc522_init+0xb0>
80004b5e:	c0 50       	breq	80004b68 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b60:	30 29       	mov	r9,2
80004b62:	49 58       	lddpc	r8,80004bb4 <rc522_init+0xb4>
80004b64:	b0 89       	st.b	r8[0x0],r9
80004b66:	c0 38       	rjmp	80004b6c <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b68:	f0 1f 00 14 	mcall	80004bb8 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b6c:	f0 1f 00 14 	mcall	80004bbc <rc522_init+0xbc>
	
	PcdAntennaOff();
80004b70:	f0 1f 00 14 	mcall	80004bc0 <rc522_init+0xc0>
	
	delay_ms(2); 
80004b74:	30 2c       	mov	r12,2
80004b76:	f0 1f 00 14 	mcall	80004bc4 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004b7a:	f0 1f 00 14 	mcall	80004bc8 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004b7e:	34 1c       	mov	r12,65
80004b80:	f0 1f 00 13 	mcall	80004bcc <rc522_init+0xcc>
	

80004b84:	2f cd       	sub	sp,-16
80004b86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b8a:	00 00       	add	r0,r0
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	d8 00       	acall	0x80
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	d8 10       	acall	0x81
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	53 ec       	stdsp	sp[0xf8],r12
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	54 1c       	stdsp	sp[0x104],r12
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	54 34       	stdsp	sp[0x10c],r4
80004ba0:	00 00       	add	r0,r0
80004ba2:	20 24       	sub	r4,2
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	58 5c       	cp.w	r12,5
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	58 94       	cp.w	r4,9
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	58 c0       	cp.w	r0,12
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	59 04       	cp.w	r4,16
80004bb4:	00 00       	add	r0,r0
80004bb6:	0b 68       	ld.uh	r8,--r5
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	48 7c       	lddpc	r12,80004bd4 <PcdComMF522+0x4>
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	49 54       	lddpc	r4,80004c10 <PcdComMF522+0x40>
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	4a 80       	lddpc	r0,80004c60 <PcdComMF522+0x90>
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	52 0c       	stdsp	sp[0x80],r12
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	4a 38       	lddpc	r8,80004c54 <PcdComMF522+0x84>
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	4a 90       	lddpc	r0,80004c70 <PcdComMF522+0xa0>

80004bd0 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004bd0:	d4 31       	pushm	r0-r7,lr
80004bd2:	20 1d       	sub	sp,4
80004bd4:	18 92       	mov	r2,r12
80004bd6:	16 95       	mov	r5,r11
80004bd8:	14 96       	mov	r6,r10
80004bda:	50 09       	stdsp	sp[0x0],r9
80004bdc:	10 90       	mov	r0,r8
80004bde:	f8 c8 00 0c 	sub	r8,r12,12
80004be2:	5c 58       	castu.b	r8
80004be4:	30 29       	mov	r9,2
80004be6:	f2 08 18 00 	cp.b	r8,r9
80004bea:	e0 88 00 05 	brls	80004bf4 <PcdComMF522+0x24>
80004bee:	30 03       	mov	r3,0
80004bf0:	06 91       	mov	r1,r3
80004bf2:	c0 78       	rjmp	80004c00 <PcdComMF522+0x30>
80004bf4:	4c f9       	lddpc	r9,80004d30 <PcdComMF522+0x160>
80004bf6:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004bfa:	4c f9       	lddpc	r9,80004d34 <PcdComMF522+0x164>
80004bfc:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c00:	02 9b       	mov	r11,r1
80004c02:	a7 bb       	sbr	r11,0x7
80004c04:	30 2c       	mov	r12,2
80004c06:	f0 1f 00 4d 	mcall	80004d38 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c0a:	e0 6b 00 80 	mov	r11,128
80004c0e:	30 4c       	mov	r12,4
80004c10:	f0 1f 00 4b 	mcall	80004d3c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c14:	30 0b       	mov	r11,0
80004c16:	30 1c       	mov	r12,1
80004c18:	f0 1f 00 48 	mcall	80004d38 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c1c:	e0 6b 00 80 	mov	r11,128
80004c20:	30 ac       	mov	r12,10
80004c22:	f0 1f 00 48 	mcall	80004d40 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c26:	58 06       	cp.w	r6,0
80004c28:	c0 c0       	breq	80004c40 <PcdComMF522+0x70>
80004c2a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c2c:	30 94       	mov	r4,9
80004c2e:	0f 3b       	ld.ub	r11,r7++
80004c30:	08 9c       	mov	r12,r4
80004c32:	f0 1f 00 42 	mcall	80004d38 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c36:	0e 98       	mov	r8,r7
80004c38:	0a 18       	sub	r8,r5
80004c3a:	ec 08 19 00 	cp.h	r8,r6
80004c3e:	cf 83       	brcs	80004c2e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c40:	04 9b       	mov	r11,r2
80004c42:	30 1c       	mov	r12,1
80004c44:	f0 1f 00 3d 	mcall	80004d38 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c48:	30 c8       	mov	r8,12
80004c4a:	f0 02 18 00 	cp.b	r2,r8
80004c4e:	c0 61       	brne	80004c5a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c50:	e0 6b 00 80 	mov	r11,128
80004c54:	30 dc       	mov	r12,13
80004c56:	f0 1f 00 3b 	mcall	80004d40 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c5a:	30 4c       	mov	r12,4
80004c5c:	f0 1f 00 3a 	mcall	80004d44 <PcdComMF522+0x174>
80004c60:	18 97       	mov	r7,r12
80004c62:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c66:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c68:	30 44       	mov	r4,4
80004c6a:	c0 88       	rjmp	80004c7a <PcdComMF522+0xaa>
80004c6c:	08 9c       	mov	r12,r4
80004c6e:	f0 1f 00 36 	mcall	80004d44 <PcdComMF522+0x174>
80004c72:	18 97       	mov	r7,r12
		i--;
80004c74:	20 16       	sub	r6,1
80004c76:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c78:	c0 a0       	breq	80004c8c <PcdComMF522+0xbc>
80004c7a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c7e:	c4 c1       	brne	80004d16 <PcdComMF522+0x146>
80004c80:	ef e3 00 08 	and	r8,r7,r3
80004c84:	ea 08 18 00 	cp.b	r8,r5
80004c88:	cf 20       	breq	80004c6c <PcdComMF522+0x9c>
80004c8a:	c4 68       	rjmp	80004d16 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c8c:	e0 6b 00 80 	mov	r11,128
80004c90:	30 dc       	mov	r12,13
80004c92:	f0 1f 00 2b 	mcall	80004d3c <PcdComMF522+0x16c>
80004c96:	30 27       	mov	r7,2
80004c98:	c3 38       	rjmp	80004cfe <PcdComMF522+0x12e>
80004c9a:	02 67       	and	r7,r1
80004c9c:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ca0:	30 c8       	mov	r8,12
80004ca2:	f0 02 18 00 	cp.b	r2,r8
80004ca6:	c2 c1       	brne	80004cfe <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ca8:	30 ac       	mov	r12,10
80004caa:	f0 1f 00 27 	mcall	80004d44 <PcdComMF522+0x174>
80004cae:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004cb0:	30 cc       	mov	r12,12
80004cb2:	f0 1f 00 25 	mcall	80004d44 <PcdComMF522+0x174>
80004cb6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004cba:	c0 70       	breq	80004cc8 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004cbc:	08 98       	mov	r8,r4
80004cbe:	20 18       	sub	r8,1
80004cc0:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004cc4:	a0 8c       	st.b	r0[0x0],r12
80004cc6:	c0 48       	rjmp	80004cce <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004cc8:	e8 08 15 03 	lsl	r8,r4,0x3
80004ccc:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004cce:	58 04       	cp.w	r4,0
80004cd0:	c0 61       	brne	80004cdc <PcdComMF522+0x10c>
80004cd2:	30 14       	mov	r4,1
80004cd4:	40 05       	lddsp	r5,sp[0x0]
80004cd6:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cd8:	30 93       	mov	r3,9
80004cda:	c0 98       	rjmp	80004cec <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cdc:	31 28       	mov	r8,18
80004cde:	f0 04 18 00 	cp.b	r4,r8
80004ce2:	f9 b4 0b 12 	movhi	r4,18
80004ce6:	58 04       	cp.w	r4,0
80004ce8:	cf 61       	brne	80004cd4 <PcdComMF522+0x104>
80004cea:	c0 a8       	rjmp	80004cfe <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cec:	06 9c       	mov	r12,r3
80004cee:	f0 1f 00 16 	mcall	80004d44 <PcdComMF522+0x174>
80004cf2:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cf4:	ec 05 01 08 	sub	r8,r6,r5
80004cf8:	e8 08 19 00 	cp.h	r8,r4
80004cfc:	cf 83       	brcs	80004cec <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004cfe:	e0 6b 00 80 	mov	r11,128
80004d02:	30 cc       	mov	r12,12
80004d04:	f0 1f 00 0f 	mcall	80004d40 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d08:	30 0b       	mov	r11,0
80004d0a:	30 1c       	mov	r12,1
80004d0c:	f0 1f 00 0b 	mcall	80004d38 <PcdComMF522+0x168>
	return status;
}
80004d10:	0e 9c       	mov	r12,r7
80004d12:	2f fd       	sub	sp,-4
80004d14:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d16:	e0 6b 00 80 	mov	r11,128
80004d1a:	30 dc       	mov	r12,13
80004d1c:	f0 1f 00 08 	mcall	80004d3c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d20:	30 6c       	mov	r12,6
80004d22:	f0 1f 00 09 	mcall	80004d44 <PcdComMF522+0x174>
80004d26:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d2a:	cb 80       	breq	80004c9a <PcdComMF522+0xca>
80004d2c:	30 27       	mov	r7,2
80004d2e:	ce 8b       	rjmp	80004cfe <PcdComMF522+0x12e>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	d8 30       	acall	0x83
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	d8 34       	*unknown*
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	49 1c       	lddpc	r12,80004d7c <PcdAnticoll+0x34>
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4a 58       	lddpc	r8,80004dd0 <PcdRequest+0x4>
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	4a 14       	lddpc	r4,80004dc4 <PcdAnticoll+0x7c>
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	49 d4       	lddpc	r4,80004db8 <PcdAnticoll+0x70>

80004d48 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d48:	eb cd 40 c0 	pushm	r6-r7,lr
80004d4c:	20 5d       	sub	sp,20
80004d4e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d50:	30 8b       	mov	r11,8
80004d52:	16 9c       	mov	r12,r11
80004d54:	f0 1f 00 1a 	mcall	80004dbc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d58:	30 0b       	mov	r11,0
80004d5a:	30 dc       	mov	r12,13
80004d5c:	f0 1f 00 19 	mcall	80004dc0 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d60:	e0 6b 00 80 	mov	r11,128
80004d64:	30 ec       	mov	r12,14
80004d66:	f0 1f 00 16 	mcall	80004dbc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d6a:	39 38       	mov	r8,-109
80004d6c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d6e:	32 08       	mov	r8,32
80004d70:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d72:	1a 9b       	mov	r11,sp
80004d74:	fa c8 ff ed 	sub	r8,sp,-19
80004d78:	1a 99       	mov	r9,sp
80004d7a:	30 2a       	mov	r10,2
80004d7c:	30 cc       	mov	r12,12
80004d7e:	f0 1f 00 12 	mcall	80004dc4 <PcdAnticoll+0x7c>
80004d82:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d84:	c1 21       	brne	80004da8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d86:	1b 89       	ld.ub	r9,sp[0x0]
80004d88:	ac 89       	st.b	r6[0x0],r9
80004d8a:	1b 98       	ld.ub	r8,sp[0x1]
80004d8c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d8e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d90:	1b a8       	ld.ub	r8,sp[0x2]
80004d92:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d94:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d98:	1b b9       	ld.ub	r9,sp[0x3]
80004d9a:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004d9c:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004d9e:	1b c9       	ld.ub	r9,sp[0x4]
80004da0:	f0 09 18 00 	cp.b	r9,r8
80004da4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004da8:	e0 6b 00 80 	mov	r11,128
80004dac:	30 ec       	mov	r12,14
80004dae:	f0 1f 00 07 	mcall	80004dc8 <PcdAnticoll+0x80>
	return status;
}
80004db2:	0e 9c       	mov	r12,r7
80004db4:	2f bd       	sub	sp,-20
80004db6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dba:	00 00       	add	r0,r0
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	4a 58       	lddpc	r8,80004e50 <CalulateCRC+0x20>
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	49 1c       	lddpc	r12,80004e04 <PcdRequest+0x38>
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	4b d0       	lddpc	r0,80004eb8 <CalulateCRC+0x88>
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	4a 14       	lddpc	r4,80004e4c <CalulateCRC+0x1c>

80004dcc <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004dcc:	eb cd 40 c0 	pushm	r6-r7,lr
80004dd0:	20 5d       	sub	sp,20
80004dd2:	18 97       	mov	r7,r12
80004dd4:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004dd6:	30 8b       	mov	r11,8
80004dd8:	16 9c       	mov	r12,r11
80004dda:	f0 1f 00 12 	mcall	80004e20 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004dde:	30 7b       	mov	r11,7
80004de0:	30 dc       	mov	r12,13
80004de2:	f0 1f 00 11 	mcall	80004e24 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004de6:	30 3b       	mov	r11,3
80004de8:	31 4c       	mov	r12,20
80004dea:	f0 1f 00 10 	mcall	80004e28 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004dee:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004df0:	1a 9b       	mov	r11,sp
80004df2:	fa c8 ff ed 	sub	r8,sp,-19
80004df6:	1a 99       	mov	r9,sp
80004df8:	30 1a       	mov	r10,1
80004dfa:	30 cc       	mov	r12,12
80004dfc:	f0 1f 00 0c 	mcall	80004e2c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e00:	c0 c1       	brne	80004e18 <PcdRequest+0x4c>
80004e02:	31 08       	mov	r8,16
80004e04:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e08:	f0 09 18 00 	cp.b	r9,r8
80004e0c:	c0 61       	brne	80004e18 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e0e:	1b 88       	ld.ub	r8,sp[0x0]
80004e10:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e12:	1b 98       	ld.ub	r8,sp[0x1]
80004e14:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e16:	c0 28       	rjmp	80004e1a <PcdRequest+0x4e>
80004e18:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e1a:	2f bd       	sub	sp,-20
80004e1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4a 58       	lddpc	r8,80004eb4 <CalulateCRC+0x84>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	49 1c       	lddpc	r12,80004e68 <CalulateCRC+0x38>
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4a 14       	lddpc	r4,80004eac <CalulateCRC+0x7c>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4b d0       	lddpc	r0,80004f20 <PcdSelect+0x64>

80004e30 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e30:	eb cd 40 f8 	pushm	r3-r7,lr
80004e34:	18 95       	mov	r5,r12
80004e36:	16 96       	mov	r6,r11
80004e38:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e3a:	30 4b       	mov	r11,4
80004e3c:	30 5c       	mov	r12,5
80004e3e:	f0 1f 00 1c 	mcall	80004eac <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e42:	30 0b       	mov	r11,0
80004e44:	30 1c       	mov	r12,1
80004e46:	f0 1f 00 1b 	mcall	80004eb0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e4a:	e0 6b 00 80 	mov	r11,128
80004e4e:	30 ac       	mov	r12,10
80004e50:	f0 1f 00 19 	mcall	80004eb4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e54:	58 06       	cp.w	r6,0
80004e56:	c0 c0       	breq	80004e6e <CalulateCRC+0x3e>
80004e58:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e5a:	30 94       	mov	r4,9
80004e5c:	0f 3b       	ld.ub	r11,r7++
80004e5e:	08 9c       	mov	r12,r4
80004e60:	f0 1f 00 14 	mcall	80004eb0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e64:	0e 98       	mov	r8,r7
80004e66:	0a 18       	sub	r8,r5
80004e68:	ec 08 18 00 	cp.b	r8,r6
80004e6c:	cf 83       	brcs	80004e5c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e6e:	30 3b       	mov	r11,3
80004e70:	30 1c       	mov	r12,1
80004e72:	f0 1f 00 10 	mcall	80004eb0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e76:	30 5c       	mov	r12,5
80004e78:	f0 1f 00 10 	mcall	80004eb8 <CalulateCRC+0x88>
80004e7c:	e0 67 00 fe 	mov	r7,254
80004e80:	30 56       	mov	r6,5
80004e82:	c0 78       	rjmp	80004e90 <CalulateCRC+0x60>
80004e84:	0c 9c       	mov	r12,r6
80004e86:	f0 1f 00 0d 	mcall	80004eb8 <CalulateCRC+0x88>
		i--;
80004e8a:	20 17       	sub	r7,1
80004e8c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e8e:	c0 40       	breq	80004e96 <CalulateCRC+0x66>
80004e90:	e2 1c 00 04 	andl	r12,0x4,COH
80004e94:	cf 80       	breq	80004e84 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e96:	32 2c       	mov	r12,34
80004e98:	f0 1f 00 08 	mcall	80004eb8 <CalulateCRC+0x88>
80004e9c:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004e9e:	32 1c       	mov	r12,33
80004ea0:	f0 1f 00 06 	mcall	80004eb8 <CalulateCRC+0x88>
80004ea4:	a6 9c       	st.b	r3[0x1],r12
}
80004ea6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004eaa:	00 00       	add	r0,r0
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	4a 58       	lddpc	r8,80004f40 <rfid_auto_reader+0x10>
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	49 1c       	lddpc	r12,80004ef4 <PcdSelect+0x38>
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	4a 14       	lddpc	r4,80004f38 <rfid_auto_reader+0x8>
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	49 d4       	lddpc	r4,80004f2c <PcdSelect+0x70>

80004ebc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004ebc:	eb cd 40 80 	pushm	r7,lr
80004ec0:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004ec2:	39 38       	mov	r8,-109
80004ec4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004ec6:	37 08       	mov	r8,112
80004ec8:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004eca:	30 08       	mov	r8,0
80004ecc:	ba e8       	st.b	sp[0x6],r8
80004ece:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004ed2:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004ed6:	19 89       	ld.ub	r9,r12[0x0]
80004ed8:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004eda:	19 3a       	ld.ub	r10,r12++
80004edc:	1b e9       	ld.ub	r9,sp[0x6]
80004ede:	f5 e9 20 09 	eor	r9,r10,r9
80004ee2:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004ee4:	16 38       	cp.w	r8,r11
80004ee6:	cf 81       	brne	80004ed6 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004ee8:	1a 97       	mov	r7,sp
80004eea:	fa ca ff f9 	sub	r10,sp,-7
80004eee:	30 7b       	mov	r11,7
80004ef0:	1a 9c       	mov	r12,sp
80004ef2:	f0 1f 00 0d 	mcall	80004f24 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004ef6:	30 8b       	mov	r11,8
80004ef8:	16 9c       	mov	r12,r11
80004efa:	f0 1f 00 0c 	mcall	80004f28 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004efe:	fa c8 ff ed 	sub	r8,sp,-19
80004f02:	1a 99       	mov	r9,sp
80004f04:	30 9a       	mov	r10,9
80004f06:	1a 9b       	mov	r11,sp
80004f08:	30 cc       	mov	r12,12
80004f0a:	f0 1f 00 09 	mcall	80004f2c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f0e:	c0 71       	brne	80004f1c <PcdSelect+0x60>
80004f10:	31 88       	mov	r8,24
80004f12:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f16:	f0 09 18 00 	cp.b	r9,r8
80004f1a:	c0 20       	breq	80004f1e <PcdSelect+0x62>
80004f1c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f1e:	2f bd       	sub	sp,-20
80004f20:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	4e 30       	lddpc	r0,800050b0 <rfid_sendID_message+0x60>
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4a 58       	lddpc	r8,80004fbc <rfid_auto_reader+0x8c>
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4b d0       	lddpc	r0,80005020 <rfid_auto_reader+0xf0>

80004f30 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f30:	eb cd 40 c0 	pushm	r6-r7,lr
80004f34:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f36:	f0 1f 00 37 	mcall	80005010 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f3a:	4b 7b       	lddpc	r11,80005014 <rfid_auto_reader+0xe4>
80004f3c:	35 2c       	mov	r12,82
80004f3e:	f0 1f 00 37 	mcall	80005018 <rfid_auto_reader+0xe8>
80004f42:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f44:	c6 31       	brne	8000500a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f46:	4b 48       	lddpc	r8,80005014 <rfid_auto_reader+0xe4>
80004f48:	11 88       	ld.ub	r8,r8[0x0]
80004f4a:	30 49       	mov	r9,4
80004f4c:	f2 08 18 00 	cp.b	r8,r9
80004f50:	c0 b1       	brne	80004f66 <rfid_auto_reader+0x36>
80004f52:	4b 19       	lddpc	r9,80005014 <rfid_auto_reader+0xe4>
80004f54:	13 9a       	ld.ub	r10,r9[0x1]
80004f56:	30 09       	mov	r9,0
80004f58:	f2 0a 18 00 	cp.b	r10,r9
80004f5c:	c0 51       	brne	80004f66 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f5e:	4b 0c       	lddpc	r12,8000501c <rfid_auto_reader+0xec>
80004f60:	f0 1f 00 30 	mcall	80005020 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f64:	c3 c8       	rjmp	80004fdc <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f66:	30 29       	mov	r9,2
80004f68:	f2 08 18 00 	cp.b	r8,r9
80004f6c:	c0 b1       	brne	80004f82 <rfid_auto_reader+0x52>
80004f6e:	4a a9       	lddpc	r9,80005014 <rfid_auto_reader+0xe4>
80004f70:	13 9a       	ld.ub	r10,r9[0x1]
80004f72:	30 09       	mov	r9,0
80004f74:	f2 0a 18 00 	cp.b	r10,r9
80004f78:	c0 51       	brne	80004f82 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f7a:	4a bc       	lddpc	r12,80005024 <rfid_auto_reader+0xf4>
80004f7c:	f0 1f 00 29 	mcall	80005020 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f80:	c2 e8       	rjmp	80004fdc <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f82:	34 49       	mov	r9,68
80004f84:	f2 08 18 00 	cp.b	r8,r9
80004f88:	c0 b1       	brne	80004f9e <rfid_auto_reader+0x6e>
80004f8a:	4a 39       	lddpc	r9,80005014 <rfid_auto_reader+0xe4>
80004f8c:	13 9a       	ld.ub	r10,r9[0x1]
80004f8e:	30 09       	mov	r9,0
80004f90:	f2 0a 18 00 	cp.b	r10,r9
80004f94:	c0 51       	brne	80004f9e <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f96:	4a 5c       	lddpc	r12,80005028 <rfid_auto_reader+0xf8>
80004f98:	f0 1f 00 22 	mcall	80005020 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f9c:	c2 08       	rjmp	80004fdc <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f9e:	30 89       	mov	r9,8
80004fa0:	f2 08 18 00 	cp.b	r8,r9
80004fa4:	c0 b1       	brne	80004fba <rfid_auto_reader+0x8a>
80004fa6:	49 c9       	lddpc	r9,80005014 <rfid_auto_reader+0xe4>
80004fa8:	13 9a       	ld.ub	r10,r9[0x1]
80004faa:	30 09       	mov	r9,0
80004fac:	f2 0a 18 00 	cp.b	r10,r9
80004fb0:	c0 51       	brne	80004fba <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004fb2:	49 fc       	lddpc	r12,8000502c <rfid_auto_reader+0xfc>
80004fb4:	f0 1f 00 1b 	mcall	80005020 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fb8:	c1 28       	rjmp	80004fdc <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fba:	34 49       	mov	r9,68
80004fbc:	f2 08 18 00 	cp.b	r8,r9
80004fc0:	c0 b1       	brne	80004fd6 <rfid_auto_reader+0xa6>
80004fc2:	49 58       	lddpc	r8,80005014 <rfid_auto_reader+0xe4>
80004fc4:	11 99       	ld.ub	r9,r8[0x1]
80004fc6:	30 38       	mov	r8,3
80004fc8:	f0 09 18 00 	cp.b	r9,r8
80004fcc:	c0 51       	brne	80004fd6 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004fce:	49 9c       	lddpc	r12,80005030 <rfid_auto_reader+0x100>
80004fd0:	f0 1f 00 14 	mcall	80005020 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fd4:	c0 48       	rjmp	80004fdc <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004fd6:	49 8c       	lddpc	r12,80005034 <rfid_auto_reader+0x104>
80004fd8:	f0 1f 00 12 	mcall	80005020 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fdc:	49 7c       	lddpc	r12,80005038 <rfid_auto_reader+0x108>
80004fde:	f0 1f 00 18 	mcall	8000503c <rfid_auto_reader+0x10c>
80004fe2:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004fe4:	c0 60       	breq	80004ff0 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004fe6:	37 8b       	mov	r11,120
80004fe8:	30 1c       	mov	r12,1
80004fea:	f0 1f 00 16 	mcall	80005040 <rfid_auto_reader+0x110>
		return status;
80004fee:	c0 e8       	rjmp	8000500a <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004ff0:	49 2c       	lddpc	r12,80005038 <rfid_auto_reader+0x108>
80004ff2:	f0 1f 00 15 	mcall	80005044 <rfid_auto_reader+0x114>
80004ff6:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004ff8:	c0 91       	brne	8000500a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004ffa:	30 4a       	mov	r10,4
80004ffc:	48 fb       	lddpc	r11,80005038 <rfid_auto_reader+0x108>
80004ffe:	0c 9c       	mov	r12,r6
80005000:	f0 1f 00 12 	mcall	80005048 <rfid_auto_reader+0x118>
		log("select okay\n");
80005004:	49 2c       	lddpc	r12,8000504c <rfid_auto_reader+0x11c>
80005006:	f0 1f 00 07 	mcall	80005020 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000500a:	0e 9c       	mov	r12,r7
8000500c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	49 54       	lddpc	r4,80005064 <rfid_sendID_message+0x14>
80005014:	00 00       	add	r0,r0
80005016:	53 ac       	stdsp	sp[0xe8],r12
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	4d cc       	lddpc	r12,80005188 <rfid_sendID_message+0x138>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	d8 38       	*unknown*
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	70 08       	ld.w	r8,r8[0x0]
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	d8 44       	*unknown*
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	d8 50       	acall	0x85
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	d8 60       	acall	0x86
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	d8 68       	*unknown*
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	d8 74       	*unknown*
80005038:	00 00       	add	r0,r0
8000503a:	53 b0       	stdsp	sp[0xec],r0
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	4d 48       	lddpc	r8,8000518c <rfid_sendID_message+0x13c>
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	40 7c       	lddsp	r12,sp[0x1c]
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	4e bc       	lddpc	r12,800051f0 <delay_us+0xc>
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	78 8c       	ld.w	r12,r12[0x20]
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	d8 80       	acall	0x88

80005050 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80005050:	eb cd 40 e0 	pushm	r5-r7,lr
80005054:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005056:	fa cc ff 90 	sub	r12,sp,-112
8000505a:	30 08       	mov	r8,0
8000505c:	30 09       	mov	r9,0
8000505e:	f8 e9 00 00 	st.d	r12[0],r8
80005062:	30 0a       	mov	r10,0
80005064:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005066:	fa e9 00 20 	st.d	sp[32],r8
8000506a:	fa e9 00 28 	st.d	sp[40],r8
8000506e:	fa e9 00 30 	st.d	sp[48],r8
80005072:	fa e9 00 38 	st.d	sp[56],r8
80005076:	fa e9 00 40 	st.d	sp[64],r8
8000507a:	fa e9 00 48 	st.d	sp[72],r8
8000507e:	fa e9 00 50 	st.d	sp[80],r8
80005082:	fa e9 00 58 	st.d	sp[88],r8
80005086:	fa e9 00 60 	st.d	sp[96],r8
8000508a:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
8000508e:	f0 1f 00 43 	mcall	80005198 <rfid_sendID_message+0x148>
80005092:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005094:	c7 61       	brne	80005180 <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005096:	fb 38 00 73 	ld.ub	r8,sp[115]
8000509a:	1a d8       	st.w	--sp,r8
8000509c:	fb 38 00 76 	ld.ub	r8,sp[118]
800050a0:	1a d8       	st.w	--sp,r8
800050a2:	fb 38 00 79 	ld.ub	r8,sp[121]
800050a6:	1a d8       	st.w	--sp,r8
800050a8:	fb 38 00 7c 	ld.ub	r8,sp[124]
800050ac:	1a d8       	st.w	--sp,r8
800050ae:	4b cc       	lddpc	r12,8000519c <rfid_sendID_message+0x14c>
800050b0:	f0 1f 00 3c 	mcall	800051a0 <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
800050b4:	37 7b       	mov	r11,119
800050b6:	30 1c       	mov	r12,1
800050b8:	f0 1f 00 3b 	mcall	800051a4 <rfid_sendID_message+0x154>
800050bc:	fa c9 ff 80 	sub	r9,sp,-128
800050c0:	fa c8 ff f0 	sub	r8,sp,-16
800050c4:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
800050c8:	fa c5 ff 7c 	sub	r5,sp,-132
800050cc:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050ce:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050d0:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800050d2:	13 8b       	ld.ub	r11,r9[0x0]
800050d4:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050d8:	fc 0c 18 00 	cp.b	r12,lr
800050dc:	f7 bc 08 d0 	subls	r12,-48
800050e0:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800050e4:	f7 bc 0b a9 	subhi	r12,-87
800050e8:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050ec:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800050ee:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800050f2:	fc 0b 18 00 	cp.b	r11,lr
800050f6:	f7 bb 08 d0 	subls	r11,-48
800050fa:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800050fe:	f7 bb 0b a9 	subhi	r11,-87
80005102:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80005106:	b0 b6       	st.b	r8[0x3],r6
80005108:	2f f9       	sub	r9,-1
8000510a:	2f c8       	sub	r8,-4
8000510c:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
8000510e:	0a 39       	cp.w	r9,r5
80005110:	ce 11       	brne	800050d2 <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005112:	30 6a       	mov	r10,6
80005114:	4a 5b       	lddpc	r11,800051a8 <rfid_sendID_message+0x158>
80005116:	fa cc ff f0 	sub	r12,sp,-16
8000511a:	f0 1f 00 25 	mcall	800051ac <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
8000511e:	4a 58       	lddpc	r8,800051b0 <rfid_sendID_message+0x160>
80005120:	11 89       	ld.ub	r9,r8[0x0]
80005122:	39 f8       	mov	r8,-97
80005124:	f0 09 18 00 	cp.b	r9,r8
80005128:	e0 88 00 05 	brls	80005132 <rfid_sendID_message+0xe2>
8000512c:	38 09       	mov	r9,-128
8000512e:	4a 18       	lddpc	r8,800051b0 <rfid_sendID_message+0x160>
80005130:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005132:	4a 08       	lddpc	r8,800051b0 <rfid_sendID_message+0x160>
80005134:	11 86       	ld.ub	r6,r8[0x0]
80005136:	2f f6       	sub	r6,-1
80005138:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000513a:	30 5a       	mov	r10,5
8000513c:	49 eb       	lddpc	r11,800051b4 <rfid_sendID_message+0x164>
8000513e:	fa cc ff e5 	sub	r12,sp,-27
80005142:	f0 1f 00 1b 	mcall	800051ac <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005146:	31 e8       	mov	r8,30
80005148:	fb 58 00 16 	st.h	sp[22],r8
8000514c:	fb 66 00 1a 	st.b	sp[26],r6
80005150:	fe 78 e0 00 	mov	r8,-8192
80005154:	fb 58 00 18 	st.h	sp[24],r8
80005158:	fa c6 ff e0 	sub	r6,sp,-32
8000515c:	30 aa       	mov	r10,10
8000515e:	fa cb ff ea 	sub	r11,sp,-22
80005162:	0c 9c       	mov	r12,r6
80005164:	f0 1f 00 12 	mcall	800051ac <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005168:	31 6a       	mov	r10,22
8000516a:	1a 9b       	mov	r11,sp
8000516c:	fa cc ff d6 	sub	r12,sp,-42
80005170:	f0 1f 00 0f 	mcall	800051ac <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80005174:	30 9a       	mov	r10,9
80005176:	32 0b       	mov	r11,32
80005178:	0c 9c       	mov	r12,r6
8000517a:	f0 1f 00 10 	mcall	800051b8 <rfid_sendID_message+0x168>
8000517e:	c0 88       	rjmp	8000518e <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80005180:	37 8b       	mov	r11,120
80005182:	30 1c       	mov	r12,1
80005184:	f0 1f 00 08 	mcall	800051a4 <rfid_sendID_message+0x154>
		log("no card find...\n");
80005188:	48 dc       	lddpc	r12,800051bc <rfid_sendID_message+0x16c>
8000518a:	f0 1f 00 06 	mcall	800051a0 <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
8000518e:	0e 9c       	mov	r12,r7
80005190:	2e 1d       	sub	sp,-124
80005192:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005196:	00 00       	add	r0,r0
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	4f 30       	lddpc	r0,80005364 <xg_flashc_init+0x70>
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	d8 90       	acall	0x89
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	70 08       	ld.w	r8,r8[0x0]
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	40 7c       	lddsp	r12,sp[0x1c]
800051a8:	00 00       	add	r0,r0
800051aa:	0d 9c       	ld.ub	r12,r6[0x1]
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	78 8c       	ld.w	r12,r12[0x20]
800051b0:	00 00       	add	r0,r0
800051b2:	05 34       	ld.ub	r4,r2++
800051b4:	00 00       	add	r0,r0
800051b6:	05 2c       	ld.uh	r12,r2++
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	3f 44       	mov	r4,-12
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	d8 ac       	*unknown*

800051c0 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
800051c0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800051c2:	f0 1f 00 02 	mcall	800051c8 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
800051c6:	d8 02       	popm	pc
800051c8:	80 00       	ld.sh	r0,r0[0x0]
800051ca:	4b 00       	lddpc	r0,80005288 <local_start_pll0+0x28>

800051cc <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051cc:	58 0c       	cp.w	r12,0
800051ce:	5e 0c       	reteq	r12
800051d0:	30 08       	mov	r8,0
	{
		nop();
800051d2:	d7 03       	nop
		nop();
800051d4:	d7 03       	nop
		nop();
800051d6:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051d8:	2f f8       	sub	r8,-1
800051da:	10 3c       	cp.w	r12,r8
800051dc:	fe 9b ff fb 	brhi	800051d2 <delay_ns+0x6>
800051e0:	5e fc       	retal	r12
800051e2:	d7 03       	nop

800051e4 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051e4:	eb cd 40 e0 	pushm	r5-r7,lr
800051e8:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051ea:	58 0c       	cp.w	r12,0
800051ec:	c0 b0       	breq	80005202 <delay_us+0x1e>
800051ee:	30 07       	mov	r7,0
		delay_ns(1000);
800051f0:	e0 65 03 e8 	mov	r5,1000
800051f4:	0a 9c       	mov	r12,r5
800051f6:	f0 1f 00 05 	mcall	80005208 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051fa:	2f f7       	sub	r7,-1
800051fc:	0e 36       	cp.w	r6,r7
800051fe:	fe 9b ff fb 	brhi	800051f4 <delay_us+0x10>
80005202:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005206:	00 00       	add	r0,r0
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	51 cc       	stdsp	sp[0x70],r12

8000520c <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
8000520c:	eb cd 40 e0 	pushm	r5-r7,lr
80005210:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005212:	58 0c       	cp.w	r12,0
80005214:	c0 b0       	breq	8000522a <delay_ms+0x1e>
80005216:	30 07       	mov	r7,0
		delay_us(1000);
80005218:	e0 65 03 e8 	mov	r5,1000
8000521c:	0a 9c       	mov	r12,r5
8000521e:	f0 1f 00 05 	mcall	80005230 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005222:	2f f7       	sub	r7,-1
80005224:	0e 36       	cp.w	r6,r7
80005226:	fe 9b ff fb 	brhi	8000521c <delay_ms+0x10>
8000522a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000522e:	00 00       	add	r0,r0
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	51 e4       	stdsp	sp[0x78],r4

80005234 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005234:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005236:	30 3b       	mov	r11,3
80005238:	48 8c       	lddpc	r12,80005258 <local_start_timer+0x24>
8000523a:	f0 1f 00 09 	mcall	8000525c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000523e:	fe 78 38 00 	mov	r8,-51200
80005242:	e0 69 91 0d 	mov	r9,37133
80005246:	ea 19 00 52 	orh	r9,0x52
8000524a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000524c:	32 09       	mov	r9,32
8000524e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005250:	30 59       	mov	r9,5
80005252:	91 09       	st.w	r8[0x0],r9
}
80005254:	d8 02       	popm	pc
80005256:	00 00       	add	r0,r0
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	d8 c0       	acall	0x8c
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	53 ec       	stdsp	sp[0xf8],r12

80005260 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005260:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005262:	30 3a       	mov	r10,3
80005264:	e0 6b 1b 00 	mov	r11,6912
80005268:	ea 1b 00 b7 	orh	r11,0xb7
8000526c:	fe 7c 0c 00 	mov	r12,-62464
80005270:	f0 1f 00 19 	mcall	800052d4 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005274:	31 08       	mov	r8,16
80005276:	1a d8       	st.w	--sp,r8
80005278:	30 08       	mov	r8,0
8000527a:	30 19       	mov	r9,1
8000527c:	30 7a       	mov	r10,7
8000527e:	10 9b       	mov	r11,r8
80005280:	fe 7c 0c 00 	mov	r12,-62464
80005284:	f0 1f 00 15 	mcall	800052d8 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005288:	30 08       	mov	r8,0
8000528a:	30 19       	mov	r9,1
8000528c:	12 9a       	mov	r10,r9
8000528e:	10 9b       	mov	r11,r8
80005290:	fe 7c 0c 00 	mov	r12,-62464
80005294:	f0 1f 00 12 	mcall	800052dc <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005298:	30 0b       	mov	r11,0
8000529a:	fe 7c 0c 00 	mov	r12,-62464
8000529e:	f0 1f 00 11 	mcall	800052e0 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800052a2:	fe 7c 0c 00 	mov	r12,-62464
800052a6:	f0 1f 00 10 	mcall	800052e4 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800052aa:	30 0a       	mov	r10,0
800052ac:	1a da       	st.w	--sp,r10
800052ae:	1a da       	st.w	--sp,r10
800052b0:	14 98       	mov	r8,r10
800052b2:	14 99       	mov	r9,r10
800052b4:	30 1b       	mov	r11,1
800052b6:	fe 7c 0c 00 	mov	r12,-62464
800052ba:	f0 1f 00 0c 	mcall	800052e8 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800052be:	30 1c       	mov	r12,1
800052c0:	f0 1f 00 0b 	mcall	800052ec <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800052c4:	30 2b       	mov	r11,2
800052c6:	fe 7c 0c 00 	mov	r12,-62464
800052ca:	f0 1f 00 0a 	mcall	800052f0 <local_start_pll0+0x90>
800052ce:	2f dd       	sub	sp,-12
/****/
}
800052d0:	d8 02       	popm	pc
800052d2:	00 00       	add	r0,r0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	56 f4       	stdsp	sp[0x1bc],r4
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	56 96       	stdsp	sp[0x1a4],r6
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	56 b8       	stdsp	sp[0x1ac],r8
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	56 d2       	stdsp	sp[0x1b4],r2
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	56 e0       	stdsp	sp[0x1b8],r0
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	56 50       	stdsp	sp[0x194],r0
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	53 8c       	stdsp	sp[0xe0],r12
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	56 ea       	stdsp	sp[0x1b8],r10

800052f4 <xg_flashc_init>:
	//
}

//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052f4:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800052f8:	f0 1f 00 1a 	mcall	80005360 <xg_flashc_init+0x6c>
800052fc:	49 a8       	lddpc	r8,80005364 <xg_flashc_init+0x70>
800052fe:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005300:	70 08       	ld.w	r8,r8[0x0]
80005302:	58 08       	cp.w	r8,0
80005304:	c0 41       	brne	8000530c <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005306:	49 9c       	lddpc	r12,80005368 <xg_flashc_init+0x74>
80005308:	f0 1f 00 19 	mcall	8000536c <xg_flashc_init+0x78>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
8000530c:	30 0b       	mov	r11,0
8000530e:	30 1c       	mov	r12,1
80005310:	f0 1f 00 18 	mcall	80005370 <xg_flashc_init+0x7c>
80005314:	49 88       	lddpc	r8,80005374 <xg_flashc_init+0x80>
80005316:	91 0c       	st.w	r8[0x0],r12
80005318:	70 08       	ld.w	r8,r8[0x0]
8000531a:	58 08       	cp.w	r8,0
8000531c:	c0 80       	breq	8000532c <xg_flashc_init+0x38>
8000531e:	49 68       	lddpc	r8,80005374 <xg_flashc_init+0x80>
80005320:	70 0c       	ld.w	r12,r8[0x0]
80005322:	30 09       	mov	r9,0
80005324:	12 9a       	mov	r10,r9
80005326:	12 9b       	mov	r11,r9
80005328:	f0 1f 00 14 	mcall	80005378 <xg_flashc_init+0x84>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
8000532c:	30 4b       	mov	r11,4
8000532e:	31 4c       	mov	r12,20
80005330:	f0 1f 00 10 	mcall	80005370 <xg_flashc_init+0x7c>
80005334:	49 28       	lddpc	r8,8000537c <xg_flashc_init+0x88>
80005336:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005338:	30 4b       	mov	r11,4
8000533a:	31 4c       	mov	r12,20
8000533c:	f0 1f 00 0d 	mcall	80005370 <xg_flashc_init+0x7c>
80005340:	49 08       	lddpc	r8,80005380 <xg_flashc_init+0x8c>
80005342:	91 0c       	st.w	r8[0x0],r12
80005344:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005346:	10 96       	mov	r6,r8
80005348:	48 f5       	lddpc	r5,80005384 <xg_flashc_init+0x90>
8000534a:	6c 0c       	ld.w	r12,r6[0x0]
8000534c:	ea 07 00 0b 	add	r11,r5,r7
80005350:	f0 1f 00 0e 	mcall	80005388 <xg_flashc_init+0x94>
80005354:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005356:	e0 47 02 80 	cp.w	r7,640
8000535a:	cf 81       	brne	8000534a <xg_flashc_init+0x56>
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
8000535c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	64 d0       	ld.w	r0,r2[0x34]
80005364:	00 00       	add	r0,r0
80005366:	0b 70       	ld.ub	r0,--r5
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	d8 d8       	*unknown*
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	70 08       	ld.w	r8,r8[0x0]
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	65 28       	ld.w	r8,r2[0x48]
80005374:	00 00       	add	r0,r0
80005376:	53 b4       	stdsp	sp[0xec],r4
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	63 d0       	ld.w	r0,r1[0x74]
8000537c:	00 00       	add	r0,r0
8000537e:	0b 6c       	ld.uh	r12,--r5
80005380:	00 00       	add	r0,r0
80005382:	0b 74       	ld.ub	r4,--r5
80005384:	00 00       	add	r0,r0
80005386:	0d a2       	ld.ub	r2,r6[0x2]
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	2c 0c       	sub	r12,-64

8000538c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000538c:	fe 68 14 00 	mov	r8,-125952
80005390:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005392:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005396:	91 09       	st.w	r8[0x0],r9
}
80005398:	5e fc       	retal	r12

8000539a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000539a:	f8 08 16 05 	lsr	r8,r12,0x5
8000539e:	a9 68       	lsl	r8,0x8
800053a0:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800053a4:	58 1b       	cp.w	r11,1
800053a6:	c0 d0       	breq	800053c0 <gpio_enable_module_pin+0x26>
800053a8:	c0 63       	brcs	800053b4 <gpio_enable_module_pin+0x1a>
800053aa:	58 2b       	cp.w	r11,2
800053ac:	c1 00       	breq	800053cc <gpio_enable_module_pin+0x32>
800053ae:	58 3b       	cp.w	r11,3
800053b0:	c1 40       	breq	800053d8 <gpio_enable_module_pin+0x3e>
800053b2:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053b4:	30 19       	mov	r9,1
800053b6:	f2 0c 09 49 	lsl	r9,r9,r12
800053ba:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053bc:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053be:	c1 28       	rjmp	800053e2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053c0:	30 19       	mov	r9,1
800053c2:	f2 0c 09 49 	lsl	r9,r9,r12
800053c6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053c8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053ca:	c0 c8       	rjmp	800053e2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053cc:	30 19       	mov	r9,1
800053ce:	f2 0c 09 49 	lsl	r9,r9,r12
800053d2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053d4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053d6:	c0 68       	rjmp	800053e2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053d8:	30 19       	mov	r9,1
800053da:	f2 0c 09 49 	lsl	r9,r9,r12
800053de:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053e0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053e2:	30 19       	mov	r9,1
800053e4:	f2 0c 09 4c 	lsl	r12,r9,r12
800053e8:	91 2c       	st.w	r8[0x8],r12
800053ea:	5e fd       	retal	0

800053ec <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053ec:	d4 21       	pushm	r4-r7,lr
800053ee:	18 97       	mov	r7,r12
800053f0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053f2:	58 0b       	cp.w	r11,0
800053f4:	c0 31       	brne	800053fa <gpio_enable_module+0xe>
800053f6:	30 05       	mov	r5,0
800053f8:	c0 d8       	rjmp	80005412 <gpio_enable_module+0x26>
800053fa:	30 06       	mov	r6,0
800053fc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053fe:	6e 1b       	ld.w	r11,r7[0x4]
80005400:	6e 0c       	ld.w	r12,r7[0x0]
80005402:	f0 1f 00 06 	mcall	80005418 <gpio_enable_module+0x2c>
80005406:	18 45       	or	r5,r12
		gpiomap++;
80005408:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000540a:	2f f6       	sub	r6,-1
8000540c:	0c 34       	cp.w	r4,r6
8000540e:	fe 9b ff f8 	brhi	800053fe <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005412:	0a 9c       	mov	r12,r5
80005414:	d8 22       	popm	r4-r7,pc
80005416:	00 00       	add	r0,r0
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	53 9a       	stdsp	sp[0xe4],r10

8000541c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000541c:	f8 08 16 05 	lsr	r8,r12,0x5
80005420:	a9 68       	lsl	r8,0x8
80005422:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005426:	30 19       	mov	r9,1
80005428:	f2 0c 09 4c 	lsl	r12,r9,r12
8000542c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005430:	91 1c       	st.w	r8[0x4],r12
}
80005432:	5e fc       	retal	r12

80005434 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005434:	f8 08 16 05 	lsr	r8,r12,0x5
80005438:	a9 68       	lsl	r8,0x8
8000543a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000543e:	30 19       	mov	r9,1
80005440:	f2 0c 09 4c 	lsl	r12,r9,r12
80005444:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005448:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000544c:	91 1c       	st.w	r8[0x4],r12
}
8000544e:	5e fc       	retal	r12

80005450 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005450:	f8 08 16 05 	lsr	r8,r12,0x5
80005454:	a9 68       	lsl	r8,0x8
80005456:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000545a:	30 19       	mov	r9,1
8000545c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005460:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005464:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005468:	91 1c       	st.w	r8[0x4],r12
}
8000546a:	5e fc       	retal	r12

8000546c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000546c:	c0 08       	rjmp	8000546c <_unhandled_interrupt>
8000546e:	d7 03       	nop

80005470 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005470:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005474:	49 99       	lddpc	r9,800054d8 <INTC_register_interrupt+0x68>
80005476:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000547a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000547e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005480:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005484:	58 0a       	cp.w	r10,0
80005486:	c0 91       	brne	80005498 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005488:	49 59       	lddpc	r9,800054dc <INTC_register_interrupt+0x6c>
8000548a:	49 6a       	lddpc	r10,800054e0 <INTC_register_interrupt+0x70>
8000548c:	12 1a       	sub	r10,r9
8000548e:	fe 79 08 00 	mov	r9,-63488
80005492:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005496:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005498:	58 1a       	cp.w	r10,1
8000549a:	c0 a1       	brne	800054ae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000549c:	49 09       	lddpc	r9,800054dc <INTC_register_interrupt+0x6c>
8000549e:	49 2a       	lddpc	r10,800054e4 <INTC_register_interrupt+0x74>
800054a0:	12 1a       	sub	r10,r9
800054a2:	bf aa       	sbr	r10,0x1e
800054a4:	fe 79 08 00 	mov	r9,-63488
800054a8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054ac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800054ae:	58 2a       	cp.w	r10,2
800054b0:	c0 a1       	brne	800054c4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800054b2:	48 b9       	lddpc	r9,800054dc <INTC_register_interrupt+0x6c>
800054b4:	48 da       	lddpc	r10,800054e8 <INTC_register_interrupt+0x78>
800054b6:	12 1a       	sub	r10,r9
800054b8:	bf ba       	sbr	r10,0x1f
800054ba:	fe 79 08 00 	mov	r9,-63488
800054be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054c2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800054c4:	48 69       	lddpc	r9,800054dc <INTC_register_interrupt+0x6c>
800054c6:	48 aa       	lddpc	r10,800054ec <INTC_register_interrupt+0x7c>
800054c8:	12 1a       	sub	r10,r9
800054ca:	ea 1a c0 00 	orh	r10,0xc000
800054ce:	fe 79 08 00 	mov	r9,-63488
800054d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054d6:	5e fc       	retal	r12
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	d9 88       	*unknown*
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	ce 00       	breq	8000549e <INTC_register_interrupt+0x2e>
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	cf 04       	brge	800054c2 <INTC_register_interrupt+0x52>
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	cf 12       	brcc	800054c8 <INTC_register_interrupt+0x58>
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	cf 20       	breq	800054ce <INTC_register_interrupt+0x5e>
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	cf 2e       	rcall	800052d2 <local_start_pll0+0x72>

800054f0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054f0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054f2:	49 18       	lddpc	r8,80005534 <INTC_init_interrupts+0x44>
800054f4:	e3 b8 00 01 	mtsr	0x4,r8
800054f8:	49 0e       	lddpc	lr,80005538 <INTC_init_interrupts+0x48>
800054fa:	30 07       	mov	r7,0
800054fc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054fe:	49 0c       	lddpc	r12,8000553c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005500:	49 05       	lddpc	r5,80005540 <INTC_init_interrupts+0x50>
80005502:	10 15       	sub	r5,r8
80005504:	fe 76 08 00 	mov	r6,-63488
80005508:	c1 08       	rjmp	80005528 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000550a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000550c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000550e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005510:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005514:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005516:	10 3a       	cp.w	r10,r8
80005518:	fe 9b ff fc 	brhi	80005510 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000551c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005520:	2f f7       	sub	r7,-1
80005522:	2f 8e       	sub	lr,-8
80005524:	59 37       	cp.w	r7,19
80005526:	c0 50       	breq	80005530 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005528:	7c 08       	ld.w	r8,lr[0x0]
8000552a:	58 08       	cp.w	r8,0
8000552c:	ce f1       	brne	8000550a <INTC_init_interrupts+0x1a>
8000552e:	cf 7b       	rjmp	8000551c <INTC_init_interrupts+0x2c>
80005530:	d8 22       	popm	r4-r7,pc
80005532:	00 00       	add	r0,r0
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	ce 00       	breq	800054f6 <INTC_init_interrupts+0x6>
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	d9 88       	*unknown*
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	54 6c       	stdsp	sp[0x118],r12
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	cf 04       	brge	80005522 <INTC_init_interrupts+0x32>

80005544 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005544:	fe 78 08 00 	mov	r8,-63488
80005548:	e0 69 00 83 	mov	r9,131
8000554c:	f2 0c 01 0c 	sub	r12,r9,r12
80005550:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005554:	f2 ca ff c0 	sub	r10,r9,-64
80005558:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000555c:	58 08       	cp.w	r8,0
8000555e:	c0 21       	brne	80005562 <_get_interrupt_handler+0x1e>
80005560:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005562:	f0 08 12 00 	clz	r8,r8
80005566:	48 5a       	lddpc	r10,80005578 <_get_interrupt_handler+0x34>
80005568:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000556c:	f0 08 11 1f 	rsub	r8,r8,31
80005570:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005572:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005576:	5e fc       	retal	r12
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	d9 88       	*unknown*

8000557c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000557c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000557e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005582:	99 a8       	st.w	r12[0x28],r8
}
80005584:	5e fc       	retal	r12
80005586:	d7 03       	nop

80005588 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005588:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000558a:	ec 5b bb 9f 	cp.w	r11,899999
8000558e:	e0 8b 00 04 	brhi	80005596 <pm_enable_osc0_crystal+0xe>
80005592:	30 4b       	mov	r11,4
80005594:	c1 38       	rjmp	800055ba <pm_enable_osc0_crystal+0x32>
80005596:	e0 68 c6 bf 	mov	r8,50879
8000559a:	ea 18 00 2d 	orh	r8,0x2d
8000559e:	10 3b       	cp.w	r11,r8
800055a0:	e0 8b 00 04 	brhi	800055a8 <pm_enable_osc0_crystal+0x20>
800055a4:	30 5b       	mov	r11,5
800055a6:	c0 a8       	rjmp	800055ba <pm_enable_osc0_crystal+0x32>
800055a8:	e0 68 12 00 	mov	r8,4608
800055ac:	ea 18 00 7a 	orh	r8,0x7a
800055b0:	10 3b       	cp.w	r11,r8
800055b2:	f9 bb 03 06 	movlo	r11,6
800055b6:	f9 bb 02 07 	movhs	r11,7
800055ba:	f0 1f 00 02 	mcall	800055c0 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800055be:	d8 02       	popm	pc
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	55 7c       	stdsp	sp[0x15c],r12

800055c4 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800055c4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800055c6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800055ca:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800055cc:	78 08       	ld.w	r8,r12[0x0]
800055ce:	a3 a8       	sbr	r8,0x2
800055d0:	99 08       	st.w	r12[0x0],r8
}
800055d2:	5e fc       	retal	r12

800055d4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800055d4:	79 58       	ld.w	r8,r12[0x54]
800055d6:	e2 18 00 80 	andl	r8,0x80,COH
800055da:	cf d0       	breq	800055d4 <pm_wait_for_clk0_ready>
}
800055dc:	5e fc       	retal	r12
800055de:	d7 03       	nop

800055e0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800055e0:	eb cd 40 80 	pushm	r7,lr
800055e4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055e6:	f0 1f 00 04 	mcall	800055f4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055ea:	0e 9c       	mov	r12,r7
800055ec:	f0 1f 00 03 	mcall	800055f8 <pm_enable_clk0+0x18>
}
800055f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	55 c4       	stdsp	sp[0x170],r4
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	55 d4       	stdsp	sp[0x174],r4

800055fc <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055fc:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800055fe:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005602:	99 c8       	st.w	r12[0x30],r8
}
80005604:	5e fc       	retal	r12
80005606:	d7 03       	nop

80005608 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005608:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000560a:	30 1b       	mov	r11,1
8000560c:	f0 1f 00 02 	mcall	80005614 <pm_enable_osc32_crystal+0xc>
}
80005610:	d8 02       	popm	pc
80005612:	00 00       	add	r0,r0
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	55 fc       	stdsp	sp[0x17c],r12

80005618 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005618:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000561a:	30 19       	mov	r9,1
8000561c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005620:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005624:	99 c8       	st.w	r12[0x30],r8
}
80005626:	5e fc       	retal	r12

80005628 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005628:	79 58       	ld.w	r8,r12[0x54]
8000562a:	e2 18 02 00 	andl	r8,0x200,COH
8000562e:	cf d0       	breq	80005628 <pm_wait_for_clk32_ready>
}
80005630:	5e fc       	retal	r12
80005632:	d7 03       	nop

80005634 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005634:	eb cd 40 80 	pushm	r7,lr
80005638:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000563a:	f0 1f 00 04 	mcall	80005648 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000563e:	0e 9c       	mov	r12,r7
80005640:	f0 1f 00 03 	mcall	8000564c <pm_enable_clk32+0x18>
}
80005644:	e3 cd 80 80 	ldm	sp++,r7,pc
80005648:	80 00       	ld.sh	r0,r0[0x0]
8000564a:	56 18       	stdsp	sp[0x184],r8
8000564c:	80 00       	ld.sh	r0,r0[0x0]
8000564e:	56 28       	stdsp	sp[0x188],r8

80005650 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005650:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005654:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005658:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000565a:	09 f7       	ld.ub	r7,r4[0x7]
8000565c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005660:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005664:	09 b4       	ld.ub	r4,r4[0x3]
80005666:	08 96       	mov	r6,r4
80005668:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000566c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005670:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005674:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005678:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000567c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005680:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005684:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005688:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000568a:	79 58       	ld.w	r8,r12[0x54]
8000568c:	e2 18 00 20 	andl	r8,0x20,COH
80005690:	cf d0       	breq	8000568a <pm_cksel+0x3a>
}
80005692:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005696 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005696:	eb cd 40 80 	pushm	r7,lr
8000569a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000569c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000569e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800056a2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800056a6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800056aa:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800056ae:	2f 8b       	sub	r11,-8
800056b0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800056b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800056b8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800056b8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800056ba:	2f 8b       	sub	r11,-8
800056bc:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800056c0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800056c4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800056c8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800056cc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800056d0:	d8 02       	popm	pc

800056d2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800056d2:	2f 8b       	sub	r11,-8
800056d4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800056d8:	a1 a8       	sbr	r8,0x0
800056da:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800056de:	5e fc       	retal	r12

800056e0 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056e0:	79 58       	ld.w	r8,r12[0x54]
800056e2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800056e6:	cf d0       	breq	800056e0 <pm_wait_for_pll0_locked>
}
800056e8:	5e fc       	retal	r12

800056ea <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800056ea:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800056ec:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800056f0:	99 08       	st.w	r12[0x0],r8
}
800056f2:	5e fc       	retal	r12

800056f4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800056f4:	eb cd 40 c0 	pushm	r6-r7,lr
800056f8:	18 97       	mov	r7,r12
800056fa:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800056fc:	f0 1f 00 06 	mcall	80005714 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005700:	0c 9b       	mov	r11,r6
80005702:	0e 9c       	mov	r12,r7
80005704:	f0 1f 00 05 	mcall	80005718 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005708:	30 1b       	mov	r11,1
8000570a:	0e 9c       	mov	r12,r7
8000570c:	f0 1f 00 04 	mcall	8000571c <pm_switch_to_osc0+0x28>
}
80005710:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	55 88       	stdsp	sp[0x160],r8
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	55 e0       	stdsp	sp[0x178],r0
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	56 ea       	stdsp	sp[0x1b8],r10

80005720 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005720:	78 0c       	ld.w	r12,r12[0x0]
}
80005722:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005726:	5e fc       	retal	r12

80005728 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005728:	eb cd 40 c0 	pushm	r6-r7,lr
8000572c:	18 97       	mov	r7,r12
8000572e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005730:	0e 9c       	mov	r12,r7
80005732:	f0 1f 00 06 	mcall	80005748 <rtc_set_value+0x20>
80005736:	cf d1       	brne	80005730 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005738:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000573a:	0e 9c       	mov	r12,r7
8000573c:	f0 1f 00 03 	mcall	80005748 <rtc_set_value+0x20>
80005740:	cf d1       	brne	8000573a <rtc_set_value+0x12>
}
80005742:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005746:	00 00       	add	r0,r0
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	57 20       	stdsp	sp[0x1c8],r0

8000574c <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
8000574c:	eb cd 40 80 	pushm	r7,lr
80005750:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80005752:	0e 9c       	mov	r12,r7
80005754:	f0 1f 00 06 	mcall	8000576c <rtc_enable+0x20>
80005758:	cf d1       	brne	80005752 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
8000575a:	6e 08       	ld.w	r8,r7[0x0]
8000575c:	a1 a8       	sbr	r8,0x0
8000575e:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005760:	0e 9c       	mov	r12,r7
80005762:	f0 1f 00 03 	mcall	8000576c <rtc_enable+0x20>
80005766:	cf d1       	brne	80005760 <rtc_enable+0x14>
}
80005768:	e3 cd 80 80 	ldm	sp++,r7,pc
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	57 20       	stdsp	sp[0x1c8],r0

80005770 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005770:	30 18       	mov	r8,1
80005772:	99 48       	st.w	r12[0x10],r8
}
80005774:	5e fc       	retal	r12
80005776:	d7 03       	nop

80005778 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005778:	eb cd 40 c0 	pushm	r6-r7,lr
8000577c:	18 97       	mov	r7,r12
8000577e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005780:	0e 9c       	mov	r12,r7
80005782:	f0 1f 00 06 	mcall	80005798 <rtc_set_top_value+0x20>
80005786:	cf d1       	brne	80005780 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005788:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000578a:	0e 9c       	mov	r12,r7
8000578c:	f0 1f 00 03 	mcall	80005798 <rtc_set_top_value+0x20>
80005790:	cf d1       	brne	8000578a <rtc_set_top_value+0x12>
}
80005792:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005796:	00 00       	add	r0,r0
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	57 20       	stdsp	sp[0x1c8],r0

8000579c <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000579c:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800057a0:	e6 18 00 01 	andh	r8,0x1,COH
800057a4:	c0 71       	brne	800057b2 <rtc_clear_interrupt+0x16>
800057a6:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800057a8:	30 18       	mov	r8,1
800057aa:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800057ac:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
800057ae:	d5 03       	csrf	0x10
800057b0:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800057b2:	30 18       	mov	r8,1
800057b4:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800057b6:	78 78       	ld.w	r8,r12[0x1c]
800057b8:	5e fc       	retal	r12
800057ba:	d7 03       	nop

800057bc <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
800057bc:	eb cd 40 e0 	pushm	r5-r7,lr
800057c0:	18 97       	mov	r7,r12
800057c2:	16 96       	mov	r6,r11
800057c4:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800057c6:	30 18       	mov	r8,1
800057c8:	f0 0b 18 00 	cp.b	r11,r8
800057cc:	5f b9       	srhi	r9
800057ce:	30 f8       	mov	r8,15
800057d0:	f0 0a 18 00 	cp.b	r10,r8
800057d4:	5f b8       	srhi	r8
800057d6:	f3 e8 10 08 	or	r8,r9,r8
800057da:	c0 30       	breq	800057e0 <rtc_init+0x24>
800057dc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800057e0:	30 18       	mov	r8,1
800057e2:	f0 0b 18 00 	cp.b	r11,r8
800057e6:	c0 a1       	brne	800057fa <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800057e8:	fe 7c 0c 00 	mov	r12,-62464
800057ec:	f0 1f 00 0f 	mcall	80005828 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800057f0:	30 0b       	mov	r11,0
800057f2:	fe 7c 0c 00 	mov	r12,-62464
800057f6:	f0 1f 00 0e 	mcall	8000582c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800057fa:	0e 9c       	mov	r12,r7
800057fc:	f0 1f 00 0d 	mcall	80005830 <rtc_init+0x74>
80005800:	cf d1       	brne	800057fa <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80005802:	a3 76       	lsl	r6,0x3
80005804:	b1 a6       	sbr	r6,0x10
80005806:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000580a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
8000580c:	0e 9c       	mov	r12,r7
8000580e:	f0 1f 00 09 	mcall	80005830 <rtc_init+0x74>
80005812:	cf d1       	brne	8000580c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80005814:	30 0b       	mov	r11,0
80005816:	0e 9c       	mov	r12,r7
80005818:	f0 1f 00 07 	mcall	80005834 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
8000581c:	3f fb       	mov	r11,-1
8000581e:	0e 9c       	mov	r12,r7
80005820:	f0 1f 00 06 	mcall	80005838 <rtc_init+0x7c>
80005824:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	56 08       	stdsp	sp[0x180],r8
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	56 34       	stdsp	sp[0x18c],r4
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	57 20       	stdsp	sp[0x1c8],r0
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	57 28       	stdsp	sp[0x1c8],r8
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	57 78       	stdsp	sp[0x1dc],r8

8000583c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000583c:	f8 c8 00 01 	sub	r8,r12,1
80005840:	f0 0b 00 0b 	add	r11,r8,r11
80005844:	f6 0c 0d 0a 	divu	r10,r11,r12
80005848:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000584a:	f4 c8 00 01 	sub	r8,r10,1
8000584e:	e0 48 00 fe 	cp.w	r8,254
80005852:	e0 88 00 03 	brls	80005858 <getBaudDiv+0x1c>
80005856:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005858:	5c 8c       	casts.h	r12
}
8000585a:	5e fc       	retal	r12

8000585c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000585c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005860:	30 18       	mov	r8,1
80005862:	f0 09 18 00 	cp.b	r9,r8
80005866:	e0 88 00 04 	brls	8000586e <spi_initMaster+0x12>
8000586a:	30 2c       	mov	r12,2
8000586c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000586e:	e0 68 00 80 	mov	r8,128
80005872:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005874:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005876:	30 19       	mov	r9,1
80005878:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000587c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005880:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005884:	30 09       	mov	r9,0
80005886:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000588a:	30 fa       	mov	r10,15
8000588c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005890:	99 18       	st.w	r12[0x4],r8
80005892:	5e f9       	retal	r9

80005894 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005894:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005896:	30 18       	mov	r8,1
80005898:	f0 0b 18 00 	cp.b	r11,r8
8000589c:	5f be       	srhi	lr
8000589e:	f0 0a 18 00 	cp.b	r10,r8
800058a2:	5f b8       	srhi	r8
800058a4:	fd e8 10 08 	or	r8,lr,r8
800058a8:	c0 30       	breq	800058ae <spi_selectionMode+0x1a>
800058aa:	30 2c       	mov	r12,2
800058ac:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800058ae:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800058b0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800058b4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800058b8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800058bc:	99 18       	st.w	r12[0x4],r8
800058be:	d8 0a       	popm	pc,r12=0

800058c0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800058c0:	30 18       	mov	r8,1
800058c2:	99 08       	st.w	r12[0x0],r8
}
800058c4:	5e fc       	retal	r12

800058c6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800058c6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058ca:	c0 58       	rjmp	800058d4 <spi_write+0xe>
		if (!timeout--) {
800058cc:	58 08       	cp.w	r8,0
800058ce:	c0 21       	brne	800058d2 <spi_write+0xc>
800058d0:	5e ff       	retal	1
800058d2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058d4:	78 49       	ld.w	r9,r12[0x10]
800058d6:	e2 19 00 02 	andl	r9,0x2,COH
800058da:	cf 90       	breq	800058cc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800058dc:	5c 7b       	castu.h	r11
800058de:	99 3b       	st.w	r12[0xc],r11
800058e0:	5e fd       	retal	0

800058e2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800058e2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058e6:	c0 58       	rjmp	800058f0 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058e8:	58 08       	cp.w	r8,0
800058ea:	c0 21       	brne	800058ee <spi_read+0xc>
800058ec:	5e ff       	retal	1
800058ee:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058f0:	78 49       	ld.w	r9,r12[0x10]
800058f2:	e2 19 02 01 	andl	r9,0x201,COH
800058f6:	e0 49 02 01 	cp.w	r9,513
800058fa:	cf 71       	brne	800058e8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800058fc:	78 28       	ld.w	r8,r12[0x8]
800058fe:	b6 08       	st.h	r11[0x0],r8
80005900:	5e fd       	retal	0
80005902:	d7 03       	nop

80005904 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005904:	eb cd 40 f8 	pushm	r3-r7,lr
80005908:	18 95       	mov	r5,r12
8000590a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000590c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005910:	30 38       	mov	r8,3
80005912:	f0 06 18 00 	cp.b	r6,r8
80005916:	e0 8b 00 5e 	brhi	800059d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000591a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000591e:	30 18       	mov	r8,1
80005920:	f0 04 18 00 	cp.b	r4,r8
80005924:	e0 8b 00 57 	brhi	800059d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005928:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000592c:	30 78       	mov	r8,7
8000592e:	f0 03 18 00 	cp.b	r3,r8
80005932:	e0 88 00 50 	brls	800059d2 <spi_setupChipReg+0xce>
80005936:	31 08       	mov	r8,16
80005938:	f0 03 18 00 	cp.b	r3,r8
8000593c:	e0 8b 00 4b 	brhi	800059d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005940:	14 9b       	mov	r11,r10
80005942:	6e 1c       	ld.w	r12,r7[0x4]
80005944:	f0 1f 00 26 	mcall	800059dc <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005948:	c4 55       	brlt	800059d2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000594a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000594c:	ec 09 16 01 	lsr	r9,r6,0x1
80005950:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005954:	ec 16 00 01 	eorl	r6,0x1
80005958:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000595c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005960:	20 83       	sub	r3,8
80005962:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005966:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000596a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000596e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005972:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005976:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000597a:	0f 89       	ld.ub	r9,r7[0x0]
8000597c:	30 1a       	mov	r10,1
8000597e:	f4 09 18 00 	cp.b	r9,r10
80005982:	c0 d0       	breq	8000599c <spi_setupChipReg+0x98>
80005984:	c0 a3       	brcs	80005998 <spi_setupChipReg+0x94>
80005986:	30 2a       	mov	r10,2
80005988:	f4 09 18 00 	cp.b	r9,r10
8000598c:	c0 a0       	breq	800059a0 <spi_setupChipReg+0x9c>
8000598e:	30 3a       	mov	r10,3
80005990:	f4 09 18 00 	cp.b	r9,r10
80005994:	c1 f1       	brne	800059d2 <spi_setupChipReg+0xce>
80005996:	c0 78       	rjmp	800059a4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005998:	8b c8       	st.w	r5[0x30],r8
		break;
8000599a:	c0 68       	rjmp	800059a6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000599c:	8b d8       	st.w	r5[0x34],r8
		break;
8000599e:	c0 48       	rjmp	800059a6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800059a0:	8b e8       	st.w	r5[0x38],r8
		break;
800059a2:	c0 28       	rjmp	800059a6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800059a4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800059a6:	48 f8       	lddpc	r8,800059e0 <spi_setupChipReg+0xdc>
800059a8:	70 08       	ld.w	r8,r8[0x0]
800059aa:	58 08       	cp.w	r8,0
800059ac:	c1 61       	brne	800059d8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800059ae:	30 0b       	mov	r11,0
800059b0:	30 1c       	mov	r12,1
800059b2:	f0 1f 00 0d 	mcall	800059e4 <spi_setupChipReg+0xe0>
800059b6:	48 b8       	lddpc	r8,800059e0 <spi_setupChipReg+0xdc>
800059b8:	91 0c       	st.w	r8[0x0],r12
800059ba:	58 0c       	cp.w	r12,0
800059bc:	c0 a0       	breq	800059d0 <spi_setupChipReg+0xcc>
800059be:	30 09       	mov	r9,0
800059c0:	12 9a       	mov	r10,r9
800059c2:	12 9b       	mov	r11,r9
800059c4:	f0 1f 00 09 	mcall	800059e8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800059c8:	48 68       	lddpc	r8,800059e0 <spi_setupChipReg+0xdc>
800059ca:	70 08       	ld.w	r8,r8[0x0]
800059cc:	58 08       	cp.w	r8,0
800059ce:	c0 51       	brne	800059d8 <spi_setupChipReg+0xd4>
800059d0:	c0 08       	rjmp	800059d0 <spi_setupChipReg+0xcc>
800059d2:	30 2c       	mov	r12,2
800059d4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059d8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	58 3c       	cp.w	r12,3
800059e0:	00 00       	add	r0,r0
800059e2:	53 bc       	stdsp	sp[0xec],r12
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	65 28       	ld.w	r8,r2[0x48]
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	63 d0       	ld.w	r0,r1[0x74]

800059ec <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059ec:	d4 01       	pushm	lr
800059ee:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059f2:	c0 58       	rjmp	800059fc <spi_unselectChip+0x10>
		if (!timeout--) {
800059f4:	58 08       	cp.w	r8,0
800059f6:	c0 21       	brne	800059fa <spi_unselectChip+0xe>
800059f8:	da 0a       	popm	pc,r12=1
800059fa:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059fc:	78 49       	ld.w	r9,r12[0x10]
800059fe:	e2 19 02 00 	andl	r9,0x200,COH
80005a02:	cf 90       	breq	800059f4 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a04:	78 18       	ld.w	r8,r12[0x4]
80005a06:	ea 18 00 0f 	orh	r8,0xf
80005a0a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a0c:	fc 18 01 00 	movh	r8,0x100
80005a10:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005a12:	30 09       	mov	r9,0
80005a14:	12 9a       	mov	r10,r9
80005a16:	12 9b       	mov	r11,r9
80005a18:	48 38       	lddpc	r8,80005a24 <spi_unselectChip+0x38>
80005a1a:	70 0c       	ld.w	r12,r8[0x0]
80005a1c:	f0 1f 00 03 	mcall	80005a28 <spi_unselectChip+0x3c>
80005a20:	d8 0a       	popm	pc,r12=0
80005a22:	00 00       	add	r0,r0
80005a24:	00 00       	add	r0,r0
80005a26:	53 bc       	stdsp	sp[0xec],r12
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	63 d0       	ld.w	r0,r1[0x74]

80005a2c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a2c:	eb cd 40 f8 	pushm	r3-r7,lr
80005a30:	18 94       	mov	r4,r12
80005a32:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a34:	49 a6       	lddpc	r6,80005a9c <spi_selectChip+0x70>
80005a36:	30 07       	mov	r7,0
80005a38:	31 45       	mov	r5,20
80005a3a:	0e 99       	mov	r9,r7
80005a3c:	0a 9a       	mov	r10,r5
80005a3e:	0e 9b       	mov	r11,r7
80005a40:	6c 0c       	ld.w	r12,r6[0x0]
80005a42:	f0 1f 00 18 	mcall	80005aa0 <spi_selectChip+0x74>
80005a46:	cf a0       	breq	80005a3a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a48:	68 18       	ld.w	r8,r4[0x4]
80005a4a:	ea 18 00 0f 	orh	r8,0xf
80005a4e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a50:	68 18       	ld.w	r8,r4[0x4]
80005a52:	e2 18 00 04 	andl	r8,0x4,COH
80005a56:	c1 10       	breq	80005a78 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a58:	30 e8       	mov	r8,14
80005a5a:	f0 03 18 00 	cp.b	r3,r8
80005a5e:	e0 8b 00 1c 	brhi	80005a96 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a62:	68 19       	ld.w	r9,r4[0x4]
80005a64:	e6 08 15 10 	lsl	r8,r3,0x10
80005a68:	ea 18 ff f0 	orh	r8,0xfff0
80005a6c:	e8 18 ff ff 	orl	r8,0xffff
80005a70:	12 68       	and	r8,r9
80005a72:	89 18       	st.w	r4[0x4],r8
80005a74:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a78:	30 38       	mov	r8,3
80005a7a:	f0 03 18 00 	cp.b	r3,r8
80005a7e:	e0 8b 00 0c 	brhi	80005a96 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a82:	68 19       	ld.w	r9,r4[0x4]
80005a84:	2f 03       	sub	r3,-16
80005a86:	30 18       	mov	r8,1
80005a88:	f0 03 09 48 	lsl	r8,r8,r3
80005a8c:	5c d8       	com	r8
80005a8e:	12 68       	and	r8,r9
80005a90:	89 18       	st.w	r4[0x4],r8
80005a92:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a96:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a98:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a9c:	00 00       	add	r0,r0
80005a9e:	53 bc       	stdsp	sp[0xec],r12
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	61 c4       	ld.w	r4,r0[0x70]

80005aa4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005aa4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005aa6:	f6 08 15 04 	lsl	r8,r11,0x4
80005aaa:	14 38       	cp.w	r8,r10
80005aac:	f9 b8 08 10 	movls	r8,16
80005ab0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005ab4:	f0 0b 02 4b 	mul	r11,r8,r11
80005ab8:	f6 09 16 01 	lsr	r9,r11,0x1
80005abc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005ac0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005ac4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005ac8:	f2 cb 00 01 	sub	r11,r9,1
80005acc:	e0 4b ff fe 	cp.w	r11,65534
80005ad0:	e0 88 00 03 	brls	80005ad6 <usart_set_async_baudrate+0x32>
80005ad4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005ad6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005ad8:	e8 6e 00 00 	mov	lr,524288
80005adc:	59 08       	cp.w	r8,16
80005ade:	fc 08 17 10 	movne	r8,lr
80005ae2:	f9 b8 00 00 	moveq	r8,0
80005ae6:	e4 1b ff f7 	andh	r11,0xfff7
80005aea:	e0 1b fe cf 	andl	r11,0xfecf
80005aee:	16 48       	or	r8,r11
80005af0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005af2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005af6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005afa:	99 89       	st.w	r12[0x20],r9
80005afc:	d8 0a       	popm	pc,r12=0

80005afe <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005afe:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005b00:	e2 18 00 02 	andl	r8,0x2,COH
80005b04:	c0 31       	brne	80005b0a <usart_write_char+0xc>
80005b06:	30 2c       	mov	r12,2
80005b08:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005b0a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005b0e:	99 7b       	st.w	r12[0x1c],r11
80005b10:	5e fd       	retal	0
80005b12:	d7 03       	nop

80005b14 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005b14:	eb cd 40 e0 	pushm	r5-r7,lr
80005b18:	18 96       	mov	r6,r12
80005b1a:	16 95       	mov	r5,r11
80005b1c:	e0 67 27 0f 	mov	r7,9999
80005b20:	c0 68       	rjmp	80005b2c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005b22:	58 07       	cp.w	r7,0
80005b24:	c0 31       	brne	80005b2a <usart_putchar+0x16>
80005b26:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b2a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b2c:	0a 9b       	mov	r11,r5
80005b2e:	0c 9c       	mov	r12,r6
80005b30:	f0 1f 00 03 	mcall	80005b3c <usart_putchar+0x28>
80005b34:	cf 71       	brne	80005b22 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b3a:	00 00       	add	r0,r0
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	5a fe       	cp.w	lr,-17

80005b40 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b40:	78 58       	ld.w	r8,r12[0x14]
80005b42:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b46:	c0 30       	breq	80005b4c <usart_read_char+0xc>
80005b48:	30 4c       	mov	r12,4
80005b4a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b4c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b4e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b52:	c0 31       	brne	80005b58 <usart_read_char+0x18>
80005b54:	30 3c       	mov	r12,3
80005b56:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b58:	78 68       	ld.w	r8,r12[0x18]
80005b5a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b5e:	97 08       	st.w	r11[0x0],r8
80005b60:	5e fd       	retal	0
80005b62:	d7 03       	nop

80005b64 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b64:	eb cd 40 c0 	pushm	r6-r7,lr
80005b68:	20 1d       	sub	sp,4
80005b6a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b6c:	1a 97       	mov	r7,sp
80005b6e:	1a 9b       	mov	r11,sp
80005b70:	0c 9c       	mov	r12,r6
80005b72:	f0 1f 00 07 	mcall	80005b8c <usart_getchar+0x28>
80005b76:	58 3c       	cp.w	r12,3
80005b78:	cf b0       	breq	80005b6e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b7a:	58 4c       	cp.w	r12,4
80005b7c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b80:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b84:	2f fd       	sub	sp,-4
80005b86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b8a:	00 00       	add	r0,r0
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	5b 40       	cp.w	r0,-12

80005b90 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b90:	eb cd 40 c0 	pushm	r6-r7,lr
80005b94:	18 96       	mov	r6,r12
80005b96:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b98:	17 8b       	ld.ub	r11,r11[0x0]
80005b9a:	58 0b       	cp.w	r11,0
80005b9c:	c0 80       	breq	80005bac <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b9e:	2f f7       	sub	r7,-1
80005ba0:	0c 9c       	mov	r12,r6
80005ba2:	f0 1f 00 04 	mcall	80005bb0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005ba6:	0f 8b       	ld.ub	r11,r7[0x0]
80005ba8:	58 0b       	cp.w	r11,0
80005baa:	cf a1       	brne	80005b9e <usart_write_line+0xe>
80005bac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	5b 14       	cp.w	r4,-15

80005bb4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005bb4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005bb8:	e6 18 00 01 	andh	r8,0x1,COH
80005bbc:	c0 71       	brne	80005bca <usart_reset+0x16>
80005bbe:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005bc0:	3f f8       	mov	r8,-1
80005bc2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005bc4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005bc6:	d5 03       	csrf	0x10
80005bc8:	c0 48       	rjmp	80005bd0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005bca:	3f f8       	mov	r8,-1
80005bcc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005bce:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005bd0:	30 08       	mov	r8,0
80005bd2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005bd4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005bd6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005bd8:	ea 68 61 0c 	mov	r8,680204
80005bdc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005bde:	5e fc       	retal	r12

80005be0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005be0:	eb cd 40 e0 	pushm	r5-r7,lr
80005be4:	18 96       	mov	r6,r12
80005be6:	16 97       	mov	r7,r11
80005be8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005bea:	f0 1f 00 2f 	mcall	80005ca4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005bee:	58 07       	cp.w	r7,0
80005bf0:	c5 80       	breq	80005ca0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005bf2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bf4:	30 49       	mov	r9,4
80005bf6:	f2 08 18 00 	cp.b	r8,r9
80005bfa:	e0 88 00 53 	brls	80005ca0 <usart_init_rs232+0xc0>
80005bfe:	30 99       	mov	r9,9
80005c00:	f2 08 18 00 	cp.b	r8,r9
80005c04:	e0 8b 00 4e 	brhi	80005ca0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005c08:	0f d9       	ld.ub	r9,r7[0x5]
80005c0a:	30 78       	mov	r8,7
80005c0c:	f0 09 18 00 	cp.b	r9,r8
80005c10:	e0 8b 00 48 	brhi	80005ca0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005c14:	8e 39       	ld.sh	r9,r7[0x6]
80005c16:	e0 68 01 01 	mov	r8,257
80005c1a:	f0 09 19 00 	cp.h	r9,r8
80005c1e:	e0 8b 00 41 	brhi	80005ca0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005c22:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c26:	30 38       	mov	r8,3
80005c28:	f0 09 18 00 	cp.b	r9,r8
80005c2c:	e0 8b 00 3a 	brhi	80005ca0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c30:	0a 9a       	mov	r10,r5
80005c32:	6e 0b       	ld.w	r11,r7[0x0]
80005c34:	0c 9c       	mov	r12,r6
80005c36:	f0 1f 00 1d 	mcall	80005ca8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c3a:	58 1c       	cp.w	r12,1
80005c3c:	c3 20       	breq	80005ca0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c3e:	0f c8       	ld.ub	r8,r7[0x4]
80005c40:	30 99       	mov	r9,9
80005c42:	f2 08 18 00 	cp.b	r8,r9
80005c46:	c0 51       	brne	80005c50 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c48:	6c 18       	ld.w	r8,r6[0x4]
80005c4a:	b1 b8       	sbr	r8,0x11
80005c4c:	8d 18       	st.w	r6[0x4],r8
80005c4e:	c0 68       	rjmp	80005c5a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c50:	6c 19       	ld.w	r9,r6[0x4]
80005c52:	20 58       	sub	r8,5
80005c54:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c58:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c5a:	6c 19       	ld.w	r9,r6[0x4]
80005c5c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c60:	0f d8       	ld.ub	r8,r7[0x5]
80005c62:	a9 78       	lsl	r8,0x9
80005c64:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c68:	12 48       	or	r8,r9
80005c6a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c6c:	8e 38       	ld.sh	r8,r7[0x6]
80005c6e:	30 29       	mov	r9,2
80005c70:	f2 08 19 00 	cp.h	r8,r9
80005c74:	e0 88 00 09 	brls	80005c86 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c78:	6c 18       	ld.w	r8,r6[0x4]
80005c7a:	ad b8       	sbr	r8,0xd
80005c7c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c7e:	8e b8       	ld.uh	r8,r7[0x6]
80005c80:	20 28       	sub	r8,2
80005c82:	8d a8       	st.w	r6[0x28],r8
80005c84:	c0 68       	rjmp	80005c90 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c86:	6c 19       	ld.w	r9,r6[0x4]
80005c88:	5c 78       	castu.h	r8
80005c8a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c8e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c90:	6c 18       	ld.w	r8,r6[0x4]
80005c92:	e0 18 ff f0 	andl	r8,0xfff0
80005c96:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c98:	35 08       	mov	r8,80
80005c9a:	8d 08       	st.w	r6[0x0],r8
80005c9c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005ca0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005ca4:	80 00       	ld.sh	r0,r0[0x0]
80005ca6:	5b b4       	cp.w	r4,-5
80005ca8:	80 00       	ld.sh	r0,r0[0x0]
80005caa:	5a a4       	cp.w	r4,-22

80005cac <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005cac:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005cb0:	fe c0 8e b0 	sub	r0,pc,-29008

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005cb4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005cb8:	d5 53       	csrf	0x15
  cp      r0, r1
80005cba:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005cbc:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005cc0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005cc2:	c0 62       	brcc	80005cce <idata_load_loop_end>
  cp      r0, r1
80005cc4:	48 92       	lddpc	r2,80005ce8 <udata_clear_loop_end+0x4>

80005cc6 <idata_load_loop>:
  brlo    idata_load_loop
80005cc6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005cc8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005cca:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005ccc:	cf d3       	brcs	80005cc6 <idata_load_loop>

80005cce <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005cce:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80005cd2:	e0 61 53 d0 	mov	r1,21456
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005cd6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005cd8:	c0 62       	brcc	80005ce4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005cda:	30 02       	mov	r2,0
80005cdc:	30 03       	mov	r3,0

80005cde <udata_clear_loop>:
80005cde:	a1 22       	st.d	r0++,r2
80005ce0:	02 30       	cp.w	r0,r1
80005ce2:	cf e3       	brcs	80005cde <udata_clear_loop>

80005ce4 <udata_clear_loop_end>:
80005ce4:	fe cf e9 28 	sub	pc,pc,-5848
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	e2 b8       	*unknown*

80005cec <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005cec:	f8 c8 ff f8 	sub	r8,r12,-8
80005cf0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005cf2:	3f f9       	mov	r9,-1
80005cf4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005cf6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005cf8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005cfa:	30 08       	mov	r8,0
80005cfc:	99 08       	st.w	r12[0x0],r8
}
80005cfe:	5e fc       	retal	r12

80005d00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005d00:	30 08       	mov	r8,0
80005d02:	99 48       	st.w	r12[0x10],r8
}
80005d04:	5e fc       	retal	r12

80005d06 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005d06:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005d08:	70 19       	ld.w	r9,r8[0x4]
80005d0a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005d0c:	78 19       	ld.w	r9,r12[0x4]
80005d0e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d10:	70 19       	ld.w	r9,r8[0x4]
80005d12:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d14:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005d16:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d18:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d1a:	78 08       	ld.w	r8,r12[0x0]
80005d1c:	2f f8       	sub	r8,-1
80005d1e:	99 08       	st.w	r12[0x0],r8
}
80005d20:	5e fc       	retal	r12

80005d22 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005d22:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d24:	5b fa       	cp.w	r10,-1
80005d26:	c0 31       	brne	80005d2c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d28:	78 48       	ld.w	r8,r12[0x10]
80005d2a:	c0 c8       	rjmp	80005d42 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d2c:	f8 c8 ff f8 	sub	r8,r12,-8
80005d30:	70 19       	ld.w	r9,r8[0x4]
80005d32:	72 09       	ld.w	r9,r9[0x0]
80005d34:	12 3a       	cp.w	r10,r9
80005d36:	c0 63       	brcs	80005d42 <vListInsert+0x20>
80005d38:	70 18       	ld.w	r8,r8[0x4]
80005d3a:	70 19       	ld.w	r9,r8[0x4]
80005d3c:	72 09       	ld.w	r9,r9[0x0]
80005d3e:	12 3a       	cp.w	r10,r9
80005d40:	cf c2       	brcc	80005d38 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d42:	70 19       	ld.w	r9,r8[0x4]
80005d44:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d46:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d48:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d4a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d4c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d4e:	78 08       	ld.w	r8,r12[0x0]
80005d50:	2f f8       	sub	r8,-1
80005d52:	99 08       	st.w	r12[0x0],r8
}
80005d54:	5e fc       	retal	r12

80005d56 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d56:	78 18       	ld.w	r8,r12[0x4]
80005d58:	78 29       	ld.w	r9,r12[0x8]
80005d5a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d5c:	78 28       	ld.w	r8,r12[0x8]
80005d5e:	78 19       	ld.w	r9,r12[0x4]
80005d60:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d62:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d64:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d66:	18 39       	cp.w	r9,r12
80005d68:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d6c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d70:	30 09       	mov	r9,0
80005d72:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d74:	70 09       	ld.w	r9,r8[0x0]
80005d76:	20 19       	sub	r9,1
80005d78:	91 09       	st.w	r8[0x0],r9
}
80005d7a:	5e fc       	retal	r12

80005d7c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d7c:	e0 68 08 08 	mov	r8,2056
80005d80:	ea 18 08 08 	orh	r8,0x808
80005d84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d86:	e0 68 09 09 	mov	r8,2313
80005d8a:	ea 18 09 09 	orh	r8,0x909
80005d8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d90:	e0 68 0a 0a 	mov	r8,2570
80005d94:	ea 18 0a 0a 	orh	r8,0xa0a
80005d98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d9a:	e0 68 0b 0b 	mov	r8,2827
80005d9e:	ea 18 0b 0b 	orh	r8,0xb0b
80005da2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005da4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005da6:	e0 68 be ef 	mov	r8,48879
80005daa:	ea 18 de ad 	orh	r8,0xdead
80005dae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005db0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005db2:	fc 18 00 40 	movh	r8,0x40
80005db6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005db8:	e0 68 00 ff 	mov	r8,255
80005dbc:	ea 18 ff 00 	orh	r8,0xff00
80005dc0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005dc2:	e0 68 01 01 	mov	r8,257
80005dc6:	ea 18 01 01 	orh	r8,0x101
80005dca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005dcc:	e0 68 02 02 	mov	r8,514
80005dd0:	ea 18 02 02 	orh	r8,0x202
80005dd4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005dd6:	e0 68 03 03 	mov	r8,771
80005dda:	ea 18 03 03 	orh	r8,0x303
80005dde:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005de0:	e0 68 04 04 	mov	r8,1028
80005de4:	ea 18 04 04 	orh	r8,0x404
80005de8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005dea:	e0 68 05 05 	mov	r8,1285
80005dee:	ea 18 05 05 	orh	r8,0x505
80005df2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005df4:	e0 68 06 06 	mov	r8,1542
80005df8:	ea 18 06 06 	orh	r8,0x606
80005dfc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005dfe:	e0 68 07 07 	mov	r8,1799
80005e02:	ea 18 07 07 	orh	r8,0x707
80005e06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005e08:	30 08       	mov	r8,0
80005e0a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005e0c:	5e fc       	retal	r12
80005e0e:	d7 03       	nop

80005e10 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005e10:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005e12:	48 38       	lddpc	r8,80005e1c <vPortEnterCritical+0xc>
80005e14:	70 09       	ld.w	r9,r8[0x0]
80005e16:	2f f9       	sub	r9,-1
80005e18:	91 09       	st.w	r8[0x0],r9
}
80005e1a:	5e fc       	retal	r12
80005e1c:	00 00       	add	r0,r0
80005e1e:	05 38       	ld.ub	r8,r2++

80005e20 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005e20:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005e22:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e24:	30 0a       	mov	r10,0
80005e26:	14 9b       	mov	r11,r10
80005e28:	49 2c       	lddpc	r12,80005e70 <xPortStartScheduler+0x50>
80005e2a:	f0 1f 00 13 	mcall	80005e74 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e2e:	e0 68 5d c0 	mov	r8,24000
80005e32:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e36:	30 08       	mov	r8,0
80005e38:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e3c:	e0 68 0c f0 	mov	r8,3312
80005e40:	ea 18 00 00 	orh	r8,0x0
80005e44:	70 00       	ld.w	r0,r8[0x0]
80005e46:	60 0d       	ld.w	sp,r0[0x0]
80005e48:	1b 00       	ld.w	r0,sp++
80005e4a:	e0 68 05 38 	mov	r8,1336
80005e4e:	ea 18 00 00 	orh	r8,0x0
80005e52:	91 00       	st.w	r8[0x0],r0
80005e54:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e58:	2f ed       	sub	sp,-8
80005e5a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e5e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e62:	e3 b0 00 00 	mtsr	0x0,r0
80005e66:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e6a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e6e:	d8 0a       	popm	pc,r12=0
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	5f 3c       	srlo	r12
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	54 70       	stdsp	sp[0x11c],r0

80005e78 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e78:	20 6d       	sub	sp,24
80005e7a:	eb cd 00 ff 	pushm	r0-r7
80005e7e:	fa c7 ff c0 	sub	r7,sp,-64
80005e82:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e86:	ef 40 ff e0 	st.w	r7[-32],r0
80005e8a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e8e:	ef 40 ff e4 	st.w	r7[-28],r0
80005e92:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e96:	e0 68 05 38 	mov	r8,1336
80005e9a:	ea 18 00 00 	orh	r8,0x0
80005e9e:	70 00       	ld.w	r0,r8[0x0]
80005ea0:	1a d0       	st.w	--sp,r0
80005ea2:	f0 1f 00 1a 	mcall	80005f08 <LABEL_RET_SCALL_263+0x14>
80005ea6:	e0 68 0c f0 	mov	r8,3312
80005eaa:	ea 18 00 00 	orh	r8,0x0
80005eae:	70 00       	ld.w	r0,r8[0x0]
80005eb0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005eb2:	f0 1f 00 17 	mcall	80005f0c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005eb6:	e0 68 0c f0 	mov	r8,3312
80005eba:	ea 18 00 00 	orh	r8,0x0
80005ebe:	70 00       	ld.w	r0,r8[0x0]
80005ec0:	60 0d       	ld.w	sp,r0[0x0]
80005ec2:	1b 00       	ld.w	r0,sp++
80005ec4:	e0 68 05 38 	mov	r8,1336
80005ec8:	ea 18 00 00 	orh	r8,0x0
80005ecc:	91 00       	st.w	r8[0x0],r0
80005ece:	fa c7 ff d8 	sub	r7,sp,-40
80005ed2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005ed6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005eda:	e0 61 05 38 	mov	r1,1336
80005ede:	ea 11 00 00 	orh	r1,0x0
80005ee2:	62 02       	ld.w	r2,r1[0x0]
80005ee4:	58 02       	cp.w	r2,0
80005ee6:	c0 70       	breq	80005ef4 <LABEL_RET_SCALL_263>
80005ee8:	e4 c2 00 01 	sub	r2,r2,1
80005eec:	83 02       	st.w	r1[0x0],r2
80005eee:	58 02       	cp.w	r2,0
80005ef0:	c0 21       	brne	80005ef4 <LABEL_RET_SCALL_263>
80005ef2:	b1 c0       	cbr	r0,0x10

80005ef4 <LABEL_RET_SCALL_263>:
80005ef4:	ef 40 ff f8 	st.w	r7[-8],r0
80005ef8:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005efc:	ef 40 ff fc 	st.w	r7[-4],r0
80005f00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f04:	2f ad       	sub	sp,-24
80005f06:	d6 13       	rets
80005f08:	80 00       	ld.sh	r0,r0[0x0]
80005f0a:	5e 10       	retne	r0
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	65 ac       	ld.w	r12,r2[0x68]

80005f10 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005f10:	e1 b8 00 43 	mfsr	r8,0x10c
80005f14:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005f18:	5e fc       	retal	r12
80005f1a:	d7 03       	nop

80005f1c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005f1c:	48 78       	lddpc	r8,80005f38 <vPortExitCritical+0x1c>
80005f1e:	70 08       	ld.w	r8,r8[0x0]
80005f20:	58 08       	cp.w	r8,0
80005f22:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f24:	48 58       	lddpc	r8,80005f38 <vPortExitCritical+0x1c>
80005f26:	70 09       	ld.w	r9,r8[0x0]
80005f28:	20 19       	sub	r9,1
80005f2a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f2c:	70 08       	ld.w	r8,r8[0x0]
80005f2e:	58 08       	cp.w	r8,0
80005f30:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f32:	d5 03       	csrf	0x10
80005f34:	5e fc       	retal	r12
80005f36:	00 00       	add	r0,r0
80005f38:	00 00       	add	r0,r0
80005f3a:	05 38       	ld.ub	r8,r2++

80005f3c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f3c:	eb cd 00 ff 	pushm	r0-r7
80005f40:	e0 68 05 38 	mov	r8,1336
80005f44:	ea 18 00 00 	orh	r8,0x0
80005f48:	70 00       	ld.w	r0,r8[0x0]
80005f4a:	1a d0       	st.w	--sp,r0
80005f4c:	7a 90       	ld.w	r0,sp[0x24]
80005f4e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f52:	58 10       	cp.w	r0,1
80005f54:	e0 8b 00 08 	brhi	80005f64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f58:	e0 68 0c f0 	mov	r8,3312
80005f5c:	ea 18 00 00 	orh	r8,0x0
80005f60:	70 00       	ld.w	r0,r8[0x0]
80005f62:	81 0d       	st.w	r0[0x0],sp

80005f64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f64:	f0 1f 00 12 	mcall	80005fac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f68:	f0 1f 00 12 	mcall	80005fb0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f6c:	f0 1f 00 12 	mcall	80005fb4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f70:	f0 1f 00 12 	mcall	80005fb8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f74:	7a 90       	ld.w	r0,sp[0x24]
80005f76:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f7a:	58 10       	cp.w	r0,1
80005f7c:	e0 8b 00 0e 	brhi	80005f98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f80:	f0 1f 00 0c 	mcall	80005fb0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f84:	f0 1f 00 0e 	mcall	80005fbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f88:	f0 1f 00 0c 	mcall	80005fb8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f8c:	e0 68 0c f0 	mov	r8,3312
80005f90:	ea 18 00 00 	orh	r8,0x0
80005f94:	70 00       	ld.w	r0,r8[0x0]
80005f96:	60 0d       	ld.w	sp,r0[0x0]

80005f98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f98:	1b 00       	ld.w	r0,sp++
80005f9a:	e0 68 05 38 	mov	r8,1336
80005f9e:	ea 18 00 00 	orh	r8,0x0
80005fa2:	91 00       	st.w	r8[0x0],r0
80005fa4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005fa8:	d6 03       	rete
80005faa:	00 00       	add	r0,r0
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	5f 10       	srne	r0
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	5e 10       	retne	r0
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	67 b0       	ld.w	r0,r3[0x6c]
80005fb8:	80 00       	ld.sh	r0,r0[0x0]
80005fba:	5f 1c       	srne	r12
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	65 ac       	ld.w	r12,r2[0x68]

80005fc0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005fc0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005fc2:	f0 1f 00 02 	mcall	80005fc8 <__malloc_lock+0x8>
}
80005fc6:	d8 02       	popm	pc
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	65 9c       	ld.w	r12,r2[0x64]

80005fcc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005fcc:	d4 01       	pushm	lr
	xTaskResumeAll();
80005fce:	f0 1f 00 02 	mcall	80005fd4 <__malloc_unlock+0x8>
}
80005fd2:	d8 02       	popm	pc
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	69 58       	ld.w	r8,r4[0x54]

80005fd8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005fd8:	d4 21       	pushm	r4-r7,lr
80005fda:	16 95       	mov	r5,r11
80005fdc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005fde:	58 0c       	cp.w	r12,0
80005fe0:	c0 30       	breq	80005fe6 <_read+0xe>
80005fe2:	3f f7       	mov	r7,-1
80005fe4:	c1 48       	rjmp	8000600c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005fe6:	58 0a       	cp.w	r10,0
80005fe8:	e0 89 00 04 	brgt	80005ff0 <_read+0x18>
80005fec:	30 07       	mov	r7,0
80005fee:	c0 f8       	rjmp	8000600c <_read+0x34>
80005ff0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005ff2:	48 84       	lddpc	r4,80006010 <_read+0x38>
80005ff4:	68 0c       	ld.w	r12,r4[0x0]
80005ff6:	f0 1f 00 08 	mcall	80006014 <_read+0x3c>
    if (c < 0)
80005ffa:	c0 95       	brlt	8000600c <_read+0x34>
      break;

    *ptr++ = c;
80005ffc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006000:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006002:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006006:	58 08       	cp.w	r8,0
80006008:	fe 99 ff f6 	brgt	80005ff4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000600c:	0e 9c       	mov	r12,r7
8000600e:	d8 22       	popm	r4-r7,pc
80006010:	00 00       	add	r0,r0
80006012:	53 c0       	stdsp	sp[0xf0],r0
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	5b 64       	cp.w	r4,-10

80006018 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006018:	d4 21       	pushm	r4-r7,lr
8000601a:	16 95       	mov	r5,r11
8000601c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000601e:	20 1c       	sub	r12,1
80006020:	58 2c       	cp.w	r12,2
80006022:	e0 8b 00 12 	brhi	80006046 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006026:	58 0a       	cp.w	r10,0
80006028:	c0 31       	brne	8000602e <_write+0x16>
8000602a:	30 07       	mov	r7,0
8000602c:	c0 e8       	rjmp	80006048 <_write+0x30>
8000602e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006030:	48 74       	lddpc	r4,8000604c <_write+0x34>
80006032:	68 0c       	ld.w	r12,r4[0x0]
80006034:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006038:	f0 1f 00 06 	mcall	80006050 <_write+0x38>
8000603c:	c0 55       	brlt	80006046 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000603e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006040:	0e 36       	cp.w	r6,r7
80006042:	cf 81       	brne	80006032 <_write+0x1a>
80006044:	c0 28       	rjmp	80006048 <_write+0x30>
80006046:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006048:	0e 9c       	mov	r12,r7
8000604a:	d8 22       	popm	r4-r7,pc
8000604c:	00 00       	add	r0,r0
8000604e:	53 c0       	stdsp	sp[0xf0],r0
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	5b 14       	cp.w	r4,-15

80006054 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006054:	eb cd 40 80 	pushm	r7,lr
80006058:	18 97       	mov	r7,r12
	if( pv )
8000605a:	58 0c       	cp.w	r12,0
8000605c:	c0 80       	breq	8000606c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000605e:	f0 1f 00 05 	mcall	80006070 <vPortFree+0x1c>
		{
			free( pv );
80006062:	0e 9c       	mov	r12,r7
80006064:	f0 1f 00 04 	mcall	80006074 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006068:	f0 1f 00 04 	mcall	80006078 <vPortFree+0x24>
8000606c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	65 9c       	ld.w	r12,r2[0x64]
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	74 34       	ld.w	r4,r10[0xc]
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	69 58       	ld.w	r8,r4[0x54]

8000607c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000607c:	eb cd 40 80 	pushm	r7,lr
80006080:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006082:	f0 1f 00 06 	mcall	80006098 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006086:	0e 9c       	mov	r12,r7
80006088:	f0 1f 00 05 	mcall	8000609c <pvPortMalloc+0x20>
8000608c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000608e:	f0 1f 00 05 	mcall	800060a0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006092:	0e 9c       	mov	r12,r7
80006094:	e3 cd 80 80 	ldm	sp++,r7,pc
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	65 9c       	ld.w	r12,r2[0x64]
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	74 44       	ld.w	r4,r10[0x10]
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	69 58       	ld.w	r8,r4[0x54]

800060a4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800060a4:	d4 01       	pushm	lr
800060a6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800060a8:	78 09       	ld.w	r9,r12[0x0]
800060aa:	58 09       	cp.w	r9,0
800060ac:	c1 10       	breq	800060ce <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800060ae:	78 3a       	ld.w	r10,r12[0xc]
800060b0:	79 09       	ld.w	r9,r12[0x40]
800060b2:	f4 09 00 09 	add	r9,r10,r9
800060b6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800060b8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800060ba:	14 39       	cp.w	r9,r10
800060bc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800060c0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800060c4:	79 0a       	ld.w	r10,r12[0x40]
800060c6:	78 3b       	ld.w	r11,r12[0xc]
800060c8:	10 9c       	mov	r12,r8
800060ca:	f0 1f 00 02 	mcall	800060d0 <prvCopyDataFromQueue+0x2c>
800060ce:	d8 02       	popm	pc
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	78 8c       	ld.w	r12,r12[0x20]

800060d4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800060d4:	eb cd 40 c0 	pushm	r6-r7,lr
800060d8:	18 97       	mov	r7,r12
800060da:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060dc:	78 e8       	ld.w	r8,r12[0x38]
800060de:	58 08       	cp.w	r8,0
800060e0:	c0 31       	brne	800060e6 <xQueueReceiveFromISR+0x12>
800060e2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060e6:	f0 1f 00 0e 	mcall	8000611c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060ea:	6e e8       	ld.w	r8,r7[0x38]
800060ec:	20 18       	sub	r8,1
800060ee:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800060f0:	6f 18       	ld.w	r8,r7[0x44]
800060f2:	5b f8       	cp.w	r8,-1
800060f4:	c0 d1       	brne	8000610e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060f6:	6e 48       	ld.w	r8,r7[0x10]
800060f8:	58 08       	cp.w	r8,0
800060fa:	c0 f0       	breq	80006118 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060fc:	ee cc ff f0 	sub	r12,r7,-16
80006100:	f0 1f 00 08 	mcall	80006120 <xQueueReceiveFromISR+0x4c>
80006104:	c0 a0       	breq	80006118 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006106:	30 1c       	mov	r12,1
80006108:	8d 0c       	st.w	r6[0x0],r12
8000610a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000610e:	2f f8       	sub	r8,-1
80006110:	ef 48 00 44 	st.w	r7[68],r8
80006114:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006118:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	60 a4       	ld.w	r4,r0[0x28]
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	67 34       	ld.w	r4,r3[0x4c]

80006124 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006124:	eb cd 40 c0 	pushm	r6-r7,lr
80006128:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000612a:	f0 1f 00 23 	mcall	800061b4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000612e:	6f 28       	ld.w	r8,r7[0x48]
80006130:	58 08       	cp.w	r8,0
80006132:	e0 8a 00 18 	brle	80006162 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006136:	6e 98       	ld.w	r8,r7[0x24]
80006138:	58 08       	cp.w	r8,0
8000613a:	c1 40       	breq	80006162 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000613c:	ee c6 ff dc 	sub	r6,r7,-36
80006140:	c0 48       	rjmp	80006148 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006142:	6e 98       	ld.w	r8,r7[0x24]
80006144:	58 08       	cp.w	r8,0
80006146:	c0 e0       	breq	80006162 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006148:	0c 9c       	mov	r12,r6
8000614a:	f0 1f 00 1c 	mcall	800061b8 <prvUnlockQueue+0x94>
8000614e:	c0 30       	breq	80006154 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006150:	f0 1f 00 1b 	mcall	800061bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006154:	6f 28       	ld.w	r8,r7[0x48]
80006156:	20 18       	sub	r8,1
80006158:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000615c:	58 08       	cp.w	r8,0
8000615e:	fe 99 ff f2 	brgt	80006142 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006162:	3f f8       	mov	r8,-1
80006164:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006168:	f0 1f 00 16 	mcall	800061c0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000616c:	f0 1f 00 12 	mcall	800061b4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006170:	6f 18       	ld.w	r8,r7[0x44]
80006172:	58 08       	cp.w	r8,0
80006174:	e0 8a 00 18 	brle	800061a4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006178:	6e 48       	ld.w	r8,r7[0x10]
8000617a:	58 08       	cp.w	r8,0
8000617c:	c1 40       	breq	800061a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000617e:	ee c6 ff f0 	sub	r6,r7,-16
80006182:	c0 48       	rjmp	8000618a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006184:	6e 48       	ld.w	r8,r7[0x10]
80006186:	58 08       	cp.w	r8,0
80006188:	c0 e0       	breq	800061a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000618a:	0c 9c       	mov	r12,r6
8000618c:	f0 1f 00 0b 	mcall	800061b8 <prvUnlockQueue+0x94>
80006190:	c0 30       	breq	80006196 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006192:	f0 1f 00 0b 	mcall	800061bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006196:	6f 18       	ld.w	r8,r7[0x44]
80006198:	20 18       	sub	r8,1
8000619a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000619e:	58 08       	cp.w	r8,0
800061a0:	fe 99 ff f2 	brgt	80006184 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800061a4:	3f f8       	mov	r8,-1
800061a6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800061aa:	f0 1f 00 06 	mcall	800061c0 <prvUnlockQueue+0x9c>
}
800061ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061b2:	00 00       	add	r0,r0
800061b4:	80 00       	ld.sh	r0,r0[0x0]
800061b6:	5e 10       	retne	r0
800061b8:	80 00       	ld.sh	r0,r0[0x0]
800061ba:	67 34       	ld.w	r4,r3[0x4c]
800061bc:	80 00       	ld.sh	r0,r0[0x0]
800061be:	66 40       	ld.w	r0,r3[0x10]
800061c0:	80 00       	ld.sh	r0,r0[0x0]
800061c2:	5f 1c       	srne	r12

800061c4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800061c4:	d4 31       	pushm	r0-r7,lr
800061c6:	20 5d       	sub	sp,20
800061c8:	18 97       	mov	r7,r12
800061ca:	50 0b       	stdsp	sp[0x0],r11
800061cc:	50 2a       	stdsp	sp[0x8],r10
800061ce:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800061d0:	f8 c2 ff dc 	sub	r2,r12,-36
800061d4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061d6:	fa c4 ff f4 	sub	r4,sp,-12
800061da:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061dc:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061de:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800061e2:	f0 1f 00 3e 	mcall	800062d8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061e6:	6e e8       	ld.w	r8,r7[0x38]
800061e8:	58 08       	cp.w	r8,0
800061ea:	c2 a0       	breq	8000623e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061ec:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061ee:	40 0b       	lddsp	r11,sp[0x0]
800061f0:	0e 9c       	mov	r12,r7
800061f2:	f0 1f 00 3b 	mcall	800062dc <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800061f6:	40 18       	lddsp	r8,sp[0x4]
800061f8:	58 08       	cp.w	r8,0
800061fa:	c1 51       	brne	80006224 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800061fc:	6e e8       	ld.w	r8,r7[0x38]
800061fe:	20 18       	sub	r8,1
80006200:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006202:	6e 08       	ld.w	r8,r7[0x0]
80006204:	58 08       	cp.w	r8,0
80006206:	c0 41       	brne	8000620e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006208:	f0 1f 00 36 	mcall	800062e0 <xQueueGenericReceive+0x11c>
8000620c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000620e:	6e 48       	ld.w	r8,r7[0x10]
80006210:	58 08       	cp.w	r8,0
80006212:	c1 20       	breq	80006236 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006214:	ee cc ff f0 	sub	r12,r7,-16
80006218:	f0 1f 00 33 	mcall	800062e4 <xQueueGenericReceive+0x120>
8000621c:	58 1c       	cp.w	r12,1
8000621e:	c0 c1       	brne	80006236 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006220:	d7 33       	scall
80006222:	c0 a8       	rjmp	80006236 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006224:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006226:	6e 98       	ld.w	r8,r7[0x24]
80006228:	58 08       	cp.w	r8,0
8000622a:	c0 60       	breq	80006236 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000622c:	04 9c       	mov	r12,r2
8000622e:	f0 1f 00 2e 	mcall	800062e4 <xQueueGenericReceive+0x120>
80006232:	c0 20       	breq	80006236 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006234:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006236:	f0 1f 00 2d 	mcall	800062e8 <xQueueGenericReceive+0x124>
8000623a:	30 1c       	mov	r12,1
				return pdPASS;
8000623c:	c4 c8       	rjmp	800062d4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000623e:	40 28       	lddsp	r8,sp[0x8]
80006240:	58 08       	cp.w	r8,0
80006242:	c0 51       	brne	8000624c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006244:	f0 1f 00 29 	mcall	800062e8 <xQueueGenericReceive+0x124>
80006248:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000624a:	c4 58       	rjmp	800062d4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000624c:	58 05       	cp.w	r5,0
8000624e:	c0 51       	brne	80006258 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006250:	08 9c       	mov	r12,r4
80006252:	f0 1f 00 27 	mcall	800062ec <xQueueGenericReceive+0x128>
80006256:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006258:	f0 1f 00 24 	mcall	800062e8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000625c:	f0 1f 00 25 	mcall	800062f0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006260:	f0 1f 00 1e 	mcall	800062d8 <xQueueGenericReceive+0x114>
80006264:	6f 18       	ld.w	r8,r7[0x44]
80006266:	5b f8       	cp.w	r8,-1
80006268:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000626c:	6f 28       	ld.w	r8,r7[0x48]
8000626e:	5b f8       	cp.w	r8,-1
80006270:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006274:	f0 1f 00 1d 	mcall	800062e8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006278:	06 9b       	mov	r11,r3
8000627a:	08 9c       	mov	r12,r4
8000627c:	f0 1f 00 1e 	mcall	800062f4 <xQueueGenericReceive+0x130>
80006280:	c2 41       	brne	800062c8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006282:	f0 1f 00 16 	mcall	800062d8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006286:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006288:	f0 1f 00 18 	mcall	800062e8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000628c:	58 06       	cp.w	r6,0
8000628e:	c1 71       	brne	800062bc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006290:	6e 08       	ld.w	r8,r7[0x0]
80006292:	58 08       	cp.w	r8,0
80006294:	c0 81       	brne	800062a4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006296:	f0 1f 00 11 	mcall	800062d8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000629a:	6e 1c       	ld.w	r12,r7[0x4]
8000629c:	f0 1f 00 17 	mcall	800062f8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800062a0:	f0 1f 00 12 	mcall	800062e8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800062a4:	40 2b       	lddsp	r11,sp[0x8]
800062a6:	04 9c       	mov	r12,r2
800062a8:	f0 1f 00 15 	mcall	800062fc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800062ac:	0e 9c       	mov	r12,r7
800062ae:	f0 1f 00 15 	mcall	80006300 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800062b2:	f0 1f 00 15 	mcall	80006304 <xQueueGenericReceive+0x140>
800062b6:	c9 61       	brne	800061e2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800062b8:	d7 33       	scall
800062ba:	c9 4b       	rjmp	800061e2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800062bc:	0e 9c       	mov	r12,r7
800062be:	f0 1f 00 11 	mcall	80006300 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800062c2:	f0 1f 00 11 	mcall	80006304 <xQueueGenericReceive+0x140>
800062c6:	c8 eb       	rjmp	800061e2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800062c8:	0e 9c       	mov	r12,r7
800062ca:	f0 1f 00 0e 	mcall	80006300 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800062ce:	f0 1f 00 0e 	mcall	80006304 <xQueueGenericReceive+0x140>
800062d2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800062d4:	2f bd       	sub	sp,-20
800062d6:	d8 32       	popm	r0-r7,pc
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	5e 10       	retne	r0
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	60 a4       	ld.w	r4,r0[0x28]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	66 4c       	ld.w	r12,r3[0x10]
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	67 34       	ld.w	r4,r3[0x4c]
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	5f 1c       	srne	r12
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	66 28       	ld.w	r8,r3[0x8]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	65 9c       	ld.w	r12,r2[0x64]
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	68 c4       	ld.w	r4,r4[0x30]
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	66 b0       	ld.w	r0,r3[0x2c]
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	6b 64       	ld.w	r4,r5[0x58]
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	61 24       	ld.w	r4,r0[0x48]
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	69 58       	ld.w	r8,r4[0x54]

80006308 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006308:	eb cd 40 80 	pushm	r7,lr
8000630c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000630e:	79 08       	ld.w	r8,r12[0x40]
80006310:	58 08       	cp.w	r8,0
80006312:	c0 a1       	brne	80006326 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006314:	78 08       	ld.w	r8,r12[0x0]
80006316:	58 08       	cp.w	r8,0
80006318:	c2 b1       	brne	8000636e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000631a:	78 1c       	ld.w	r12,r12[0x4]
8000631c:	f0 1f 00 17 	mcall	80006378 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006320:	30 08       	mov	r8,0
80006322:	8f 18       	st.w	r7[0x4],r8
80006324:	c2 58       	rjmp	8000636e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006326:	58 0a       	cp.w	r10,0
80006328:	c1 01       	brne	80006348 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000632a:	10 9a       	mov	r10,r8
8000632c:	78 2c       	ld.w	r12,r12[0x8]
8000632e:	f0 1f 00 14 	mcall	8000637c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006332:	6e 29       	ld.w	r9,r7[0x8]
80006334:	6f 08       	ld.w	r8,r7[0x40]
80006336:	f2 08 00 08 	add	r8,r9,r8
8000633a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000633c:	6e 19       	ld.w	r9,r7[0x4]
8000633e:	12 38       	cp.w	r8,r9
80006340:	c1 73       	brcs	8000636e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006342:	6e 08       	ld.w	r8,r7[0x0]
80006344:	8f 28       	st.w	r7[0x8],r8
80006346:	c1 48       	rjmp	8000636e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006348:	10 9a       	mov	r10,r8
8000634a:	78 3c       	ld.w	r12,r12[0xc]
8000634c:	f0 1f 00 0c 	mcall	8000637c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006350:	6f 08       	ld.w	r8,r7[0x40]
80006352:	6e 39       	ld.w	r9,r7[0xc]
80006354:	f2 08 01 08 	sub	r8,r9,r8
80006358:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000635a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000635c:	12 38       	cp.w	r8,r9
8000635e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006362:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006366:	f3 d8 e3 19 	subcs	r9,r9,r8
8000636a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000636e:	6e e8       	ld.w	r8,r7[0x38]
80006370:	2f f8       	sub	r8,-1
80006372:	8f e8       	st.w	r7[0x38],r8
}
80006374:	e3 cd 80 80 	ldm	sp++,r7,pc
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	66 58       	ld.w	r8,r3[0x14]
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	78 8c       	ld.w	r12,r12[0x20]

80006380 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006380:	eb cd 40 c0 	pushm	r6-r7,lr
80006384:	18 97       	mov	r7,r12
80006386:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006388:	78 ec       	ld.w	r12,r12[0x38]
8000638a:	6e f8       	ld.w	r8,r7[0x3c]
8000638c:	10 3c       	cp.w	r12,r8
8000638e:	c0 33       	brcs	80006394 <xQueueGenericSendFromISR+0x14>
80006390:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006394:	12 9a       	mov	r10,r9
80006396:	0e 9c       	mov	r12,r7
80006398:	f0 1f 00 0c 	mcall	800063c8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000639c:	6f 28       	ld.w	r8,r7[0x48]
8000639e:	5b f8       	cp.w	r8,-1
800063a0:	c0 d1       	brne	800063ba <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063a2:	6e 98       	ld.w	r8,r7[0x24]
800063a4:	58 08       	cp.w	r8,0
800063a6:	c0 f0       	breq	800063c4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800063a8:	ee cc ff dc 	sub	r12,r7,-36
800063ac:	f0 1f 00 08 	mcall	800063cc <xQueueGenericSendFromISR+0x4c>
800063b0:	c0 a0       	breq	800063c4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800063b2:	30 1c       	mov	r12,1
800063b4:	8d 0c       	st.w	r6[0x0],r12
800063b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800063ba:	2f f8       	sub	r8,-1
800063bc:	ef 48 00 48 	st.w	r7[72],r8
800063c0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063c4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	63 08       	ld.w	r8,r1[0x40]
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	67 34       	ld.w	r4,r3[0x4c]

800063d0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800063d0:	d4 31       	pushm	r0-r7,lr
800063d2:	20 5d       	sub	sp,20
800063d4:	18 97       	mov	r7,r12
800063d6:	50 0b       	stdsp	sp[0x0],r11
800063d8:	50 2a       	stdsp	sp[0x8],r10
800063da:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063dc:	f8 c0 ff f0 	sub	r0,r12,-16
800063e0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063e2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063e6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063e8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063ec:	f0 1f 00 2f 	mcall	800064a8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063f0:	6e e9       	ld.w	r9,r7[0x38]
800063f2:	6e f8       	ld.w	r8,r7[0x3c]
800063f4:	10 39       	cp.w	r9,r8
800063f6:	c1 42       	brcc	8000641e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063f8:	40 1a       	lddsp	r10,sp[0x4]
800063fa:	40 0b       	lddsp	r11,sp[0x0]
800063fc:	0e 9c       	mov	r12,r7
800063fe:	f0 1f 00 2c 	mcall	800064ac <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006402:	6e 98       	ld.w	r8,r7[0x24]
80006404:	58 08       	cp.w	r8,0
80006406:	c0 80       	breq	80006416 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006408:	ee cc ff dc 	sub	r12,r7,-36
8000640c:	f0 1f 00 29 	mcall	800064b0 <xQueueGenericSend+0xe0>
80006410:	58 1c       	cp.w	r12,1
80006412:	c0 21       	brne	80006416 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006414:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006416:	f0 1f 00 28 	mcall	800064b4 <xQueueGenericSend+0xe4>
8000641a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000641c:	c4 38       	rjmp	800064a2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000641e:	40 28       	lddsp	r8,sp[0x8]
80006420:	58 08       	cp.w	r8,0
80006422:	c0 51       	brne	8000642c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006424:	f0 1f 00 24 	mcall	800064b4 <xQueueGenericSend+0xe4>
80006428:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000642a:	c3 c8       	rjmp	800064a2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000642c:	58 04       	cp.w	r4,0
8000642e:	c0 51       	brne	80006438 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006430:	06 9c       	mov	r12,r3
80006432:	f0 1f 00 22 	mcall	800064b8 <xQueueGenericSend+0xe8>
80006436:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006438:	f0 1f 00 1f 	mcall	800064b4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000643c:	f0 1f 00 20 	mcall	800064bc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006440:	f0 1f 00 1a 	mcall	800064a8 <xQueueGenericSend+0xd8>
80006444:	6f 18       	ld.w	r8,r7[0x44]
80006446:	5b f8       	cp.w	r8,-1
80006448:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000644c:	6f 28       	ld.w	r8,r7[0x48]
8000644e:	5b f8       	cp.w	r8,-1
80006450:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006454:	f0 1f 00 18 	mcall	800064b4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006458:	04 9b       	mov	r11,r2
8000645a:	06 9c       	mov	r12,r3
8000645c:	f0 1f 00 19 	mcall	800064c0 <xQueueGenericSend+0xf0>
80006460:	c1 b1       	brne	80006496 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006462:	f0 1f 00 12 	mcall	800064a8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006466:	6e e5       	ld.w	r5,r7[0x38]
80006468:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000646a:	f0 1f 00 13 	mcall	800064b4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000646e:	0c 35       	cp.w	r5,r6
80006470:	c0 d1       	brne	8000648a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006472:	40 2b       	lddsp	r11,sp[0x8]
80006474:	00 9c       	mov	r12,r0
80006476:	f0 1f 00 14 	mcall	800064c4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000647a:	0e 9c       	mov	r12,r7
8000647c:	f0 1f 00 13 	mcall	800064c8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006480:	f0 1f 00 13 	mcall	800064cc <xQueueGenericSend+0xfc>
80006484:	cb 41       	brne	800063ec <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006486:	d7 33       	scall
80006488:	cb 2b       	rjmp	800063ec <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000648a:	0e 9c       	mov	r12,r7
8000648c:	f0 1f 00 0f 	mcall	800064c8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006490:	f0 1f 00 0f 	mcall	800064cc <xQueueGenericSend+0xfc>
80006494:	ca cb       	rjmp	800063ec <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006496:	0e 9c       	mov	r12,r7
80006498:	f0 1f 00 0c 	mcall	800064c8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000649c:	f0 1f 00 0c 	mcall	800064cc <xQueueGenericSend+0xfc>
800064a0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800064a2:	2f bd       	sub	sp,-20
800064a4:	d8 32       	popm	r0-r7,pc
800064a6:	00 00       	add	r0,r0
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	5e 10       	retne	r0
800064ac:	80 00       	ld.sh	r0,r0[0x0]
800064ae:	63 08       	ld.w	r8,r1[0x40]
800064b0:	80 00       	ld.sh	r0,r0[0x0]
800064b2:	67 34       	ld.w	r4,r3[0x4c]
800064b4:	80 00       	ld.sh	r0,r0[0x0]
800064b6:	5f 1c       	srne	r12
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	66 28       	ld.w	r8,r3[0x8]
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	65 9c       	ld.w	r12,r2[0x64]
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	68 c4       	ld.w	r4,r4[0x30]
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	6b 64       	ld.w	r4,r5[0x58]
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	61 24       	ld.w	r4,r0[0x48]
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	69 58       	ld.w	r8,r4[0x54]

800064d0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800064d0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064d4:	34 cc       	mov	r12,76
800064d6:	f0 1f 00 12 	mcall	8000651c <xQueueCreateMutex+0x4c>
800064da:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800064dc:	c1 d0       	breq	80006516 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800064de:	30 06       	mov	r6,0
800064e0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800064e2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064e4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064e6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064e8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064ea:	30 18       	mov	r8,1
800064ec:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064ee:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800064f2:	3f f8       	mov	r8,-1
800064f4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800064f8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064fc:	2f 0c       	sub	r12,-16
800064fe:	f0 1f 00 09 	mcall	80006520 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006502:	ee cc ff dc 	sub	r12,r7,-36
80006506:	f0 1f 00 07 	mcall	80006520 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000650a:	0c 99       	mov	r9,r6
8000650c:	0c 9a       	mov	r10,r6
8000650e:	0c 9b       	mov	r11,r6
80006510:	0e 9c       	mov	r12,r7
80006512:	f0 1f 00 05 	mcall	80006524 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006516:	0e 9c       	mov	r12,r7
80006518:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	60 7c       	ld.w	r12,r0[0x1c]
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	5c ec       	tnbz	r12
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	63 d0       	ld.w	r0,r1[0x74]

80006528 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006528:	d4 21       	pushm	r4-r7,lr
8000652a:	18 97       	mov	r7,r12
8000652c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000652e:	58 0c       	cp.w	r12,0
80006530:	c2 f0       	breq	8000658e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006532:	34 cc       	mov	r12,76
80006534:	f0 1f 00 17 	mcall	80006590 <xQueueCreate+0x68>
80006538:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000653a:	c2 a0       	breq	8000658e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000653c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006540:	e8 cc ff ff 	sub	r12,r4,-1
80006544:	f0 1f 00 13 	mcall	80006590 <xQueueCreate+0x68>
80006548:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000654a:	c1 e0       	breq	80006586 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000654c:	f8 04 00 04 	add	r4,r12,r4
80006550:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006552:	30 08       	mov	r8,0
80006554:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006556:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006558:	ee c8 00 01 	sub	r8,r7,1
8000655c:	ad 38       	mul	r8,r6
8000655e:	10 0c       	add	r12,r8
80006560:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006562:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006564:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006568:	3f f8       	mov	r8,-1
8000656a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000656e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006572:	ea cc ff f0 	sub	r12,r5,-16
80006576:	f0 1f 00 08 	mcall	80006594 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000657a:	ea cc ff dc 	sub	r12,r5,-36
8000657e:	f0 1f 00 06 	mcall	80006594 <xQueueCreate+0x6c>
80006582:	0a 9c       	mov	r12,r5
80006584:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006586:	0a 9c       	mov	r12,r5
80006588:	f0 1f 00 04 	mcall	80006598 <xQueueCreate+0x70>
8000658c:	d8 2a       	popm	r4-r7,pc,r12=0
8000658e:	d8 2a       	popm	r4-r7,pc,r12=0
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	60 7c       	ld.w	r12,r0[0x1c]
80006594:	80 00       	ld.sh	r0,r0[0x0]
80006596:	5c ec       	tnbz	r12
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	60 54       	ld.w	r4,r0[0x14]

8000659c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000659c:	48 38       	lddpc	r8,800065a8 <vTaskSuspendAll+0xc>
8000659e:	70 09       	ld.w	r9,r8[0x0]
800065a0:	2f f9       	sub	r9,-1
800065a2:	91 09       	st.w	r8[0x0],r9
}
800065a4:	5e fc       	retal	r12
800065a6:	00 00       	add	r0,r0
800065a8:	00 00       	add	r0,r0
800065aa:	0d 20       	ld.uh	r0,r6++

800065ac <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800065ac:	49 a8       	lddpc	r8,80006614 <vTaskSwitchContext+0x68>
800065ae:	70 08       	ld.w	r8,r8[0x0]
800065b0:	58 08       	cp.w	r8,0
800065b2:	c0 b1       	brne	800065c8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065b4:	49 98       	lddpc	r8,80006618 <vTaskSwitchContext+0x6c>
800065b6:	70 08       	ld.w	r8,r8[0x0]
800065b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065bc:	49 89       	lddpc	r9,8000661c <vTaskSwitchContext+0x70>
800065be:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800065c2:	58 08       	cp.w	r8,0
800065c4:	c0 60       	breq	800065d0 <vTaskSwitchContext+0x24>
800065c6:	c1 18       	rjmp	800065e8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800065c8:	30 19       	mov	r9,1
800065ca:	49 68       	lddpc	r8,80006620 <vTaskSwitchContext+0x74>
800065cc:	91 09       	st.w	r8[0x0],r9
800065ce:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065d0:	49 28       	lddpc	r8,80006618 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065d2:	49 3a       	lddpc	r10,8000661c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065d4:	70 09       	ld.w	r9,r8[0x0]
800065d6:	20 19       	sub	r9,1
800065d8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065da:	70 09       	ld.w	r9,r8[0x0]
800065dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065e0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065e4:	58 09       	cp.w	r9,0
800065e6:	cf 70       	breq	800065d4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065e8:	48 c8       	lddpc	r8,80006618 <vTaskSwitchContext+0x6c>
800065ea:	70 08       	ld.w	r8,r8[0x0]
800065ec:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065f0:	48 b9       	lddpc	r9,8000661c <vTaskSwitchContext+0x70>
800065f2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065f6:	70 19       	ld.w	r9,r8[0x4]
800065f8:	72 19       	ld.w	r9,r9[0x4]
800065fa:	91 19       	st.w	r8[0x4],r9
800065fc:	f0 ca ff f8 	sub	r10,r8,-8
80006600:	14 39       	cp.w	r9,r10
80006602:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006606:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000660a:	70 18       	ld.w	r8,r8[0x4]
8000660c:	70 39       	ld.w	r9,r8[0xc]
8000660e:	48 68       	lddpc	r8,80006624 <vTaskSwitchContext+0x78>
80006610:	91 09       	st.w	r8[0x0],r9
80006612:	5e fc       	retal	r12
80006614:	00 00       	add	r0,r0
80006616:	0d 20       	ld.uh	r0,r6++
80006618:	00 00       	add	r0,r0
8000661a:	0d 58       	ld.sh	r8,--r6
8000661c:	00 00       	add	r0,r0
8000661e:	0c 3c       	cp.w	r12,r6
80006620:	00 00       	add	r0,r0
80006622:	0d 40       	ld.w	r0,--r6
80006624:	00 00       	add	r0,r0
80006626:	0c f0       	st.b	--r6,r0

80006628 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006628:	48 48       	lddpc	r8,80006638 <vTaskSetTimeOutState+0x10>
8000662a:	70 08       	ld.w	r8,r8[0x0]
8000662c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000662e:	48 48       	lddpc	r8,8000663c <vTaskSetTimeOutState+0x14>
80006630:	70 08       	ld.w	r8,r8[0x0]
80006632:	99 18       	st.w	r12[0x4],r8
}
80006634:	5e fc       	retal	r12
80006636:	00 00       	add	r0,r0
80006638:	00 00       	add	r0,r0
8000663a:	0c 34       	cp.w	r4,r6
8000663c:	00 00       	add	r0,r0
8000663e:	0d 1c       	ld.sh	r12,r6++

80006640 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006640:	30 19       	mov	r9,1
80006642:	48 28       	lddpc	r8,80006648 <vTaskMissedYield+0x8>
80006644:	91 09       	st.w	r8[0x0],r9
}
80006646:	5e fc       	retal	r12
80006648:	00 00       	add	r0,r0
8000664a:	0d 40       	ld.w	r0,--r6

8000664c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000664c:	48 28       	lddpc	r8,80006654 <xTaskGetCurrentTaskHandle+0x8>
8000664e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006650:	5e fc       	retal	r12
80006652:	00 00       	add	r0,r0
80006654:	00 00       	add	r0,r0
80006656:	0c f0       	st.b	--r6,r0

80006658 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006658:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000665c:	58 0c       	cp.w	r12,0
8000665e:	c1 f0       	breq	8000669c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006660:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006662:	78 b9       	ld.w	r9,r12[0x2c]
80006664:	79 18       	ld.w	r8,r12[0x44]
80006666:	10 39       	cp.w	r9,r8
80006668:	c1 a0       	breq	8000669c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000666a:	f8 c6 ff fc 	sub	r6,r12,-4
8000666e:	0c 9c       	mov	r12,r6
80006670:	f0 1f 00 0c 	mcall	800066a0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006674:	6f 1c       	ld.w	r12,r7[0x44]
80006676:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006678:	f8 08 11 08 	rsub	r8,r12,8
8000667c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000667e:	48 a8       	lddpc	r8,800066a4 <vTaskPriorityDisinherit+0x4c>
80006680:	70 08       	ld.w	r8,r8[0x0]
80006682:	10 3c       	cp.w	r12,r8
80006684:	e0 88 00 04 	brls	8000668c <vTaskPriorityDisinherit+0x34>
80006688:	48 78       	lddpc	r8,800066a4 <vTaskPriorityDisinherit+0x4c>
8000668a:	91 0c       	st.w	r8[0x0],r12
8000668c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006690:	0c 9b       	mov	r11,r6
80006692:	48 68       	lddpc	r8,800066a8 <vTaskPriorityDisinherit+0x50>
80006694:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006698:	f0 1f 00 05 	mcall	800066ac <vTaskPriorityDisinherit+0x54>
8000669c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	5d 56       	*unknown*
800066a4:	00 00       	add	r0,r0
800066a6:	0d 58       	ld.sh	r8,--r6
800066a8:	00 00       	add	r0,r0
800066aa:	0c 3c       	cp.w	r12,r6
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	5d 06       	ror	r6

800066b0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800066b0:	eb cd 40 c0 	pushm	r6-r7,lr
800066b4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800066b6:	49 b8       	lddpc	r8,80006720 <vTaskPriorityInherit+0x70>
800066b8:	70 08       	ld.w	r8,r8[0x0]
800066ba:	78 b9       	ld.w	r9,r12[0x2c]
800066bc:	70 b8       	ld.w	r8,r8[0x2c]
800066be:	10 39       	cp.w	r9,r8
800066c0:	c2 d2       	brcc	8000671a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800066c2:	49 88       	lddpc	r8,80006720 <vTaskPriorityInherit+0x70>
800066c4:	70 08       	ld.w	r8,r8[0x0]
800066c6:	70 b8       	ld.w	r8,r8[0x2c]
800066c8:	f0 08 11 08 	rsub	r8,r8,8
800066cc:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800066ce:	f2 09 00 28 	add	r8,r9,r9<<0x2
800066d2:	49 59       	lddpc	r9,80006724 <vTaskPriorityInherit+0x74>
800066d4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066d8:	78 59       	ld.w	r9,r12[0x14]
800066da:	10 39       	cp.w	r9,r8
800066dc:	c1 b1       	brne	80006712 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800066de:	f8 c6 ff fc 	sub	r6,r12,-4
800066e2:	0c 9c       	mov	r12,r6
800066e4:	f0 1f 00 11 	mcall	80006728 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066e8:	48 e8       	lddpc	r8,80006720 <vTaskPriorityInherit+0x70>
800066ea:	70 08       	ld.w	r8,r8[0x0]
800066ec:	70 bc       	ld.w	r12,r8[0x2c]
800066ee:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800066f0:	48 f8       	lddpc	r8,8000672c <vTaskPriorityInherit+0x7c>
800066f2:	70 08       	ld.w	r8,r8[0x0]
800066f4:	10 3c       	cp.w	r12,r8
800066f6:	e0 88 00 04 	brls	800066fe <vTaskPriorityInherit+0x4e>
800066fa:	48 d8       	lddpc	r8,8000672c <vTaskPriorityInherit+0x7c>
800066fc:	91 0c       	st.w	r8[0x0],r12
800066fe:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006702:	0c 9b       	mov	r11,r6
80006704:	48 88       	lddpc	r8,80006724 <vTaskPriorityInherit+0x74>
80006706:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000670a:	f0 1f 00 0a 	mcall	80006730 <vTaskPriorityInherit+0x80>
8000670e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006712:	48 48       	lddpc	r8,80006720 <vTaskPriorityInherit+0x70>
80006714:	70 08       	ld.w	r8,r8[0x0]
80006716:	70 b8       	ld.w	r8,r8[0x2c]
80006718:	99 b8       	st.w	r12[0x2c],r8
8000671a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000671e:	00 00       	add	r0,r0
80006720:	00 00       	add	r0,r0
80006722:	0c f0       	st.b	--r6,r0
80006724:	00 00       	add	r0,r0
80006726:	0c 3c       	cp.w	r12,r6
80006728:	80 00       	ld.sh	r0,r0[0x0]
8000672a:	5d 56       	*unknown*
8000672c:	00 00       	add	r0,r0
8000672e:	0d 58       	ld.sh	r8,--r6
80006730:	80 00       	ld.sh	r0,r0[0x0]
80006732:	5d 06       	ror	r6

80006734 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006734:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006738:	78 38       	ld.w	r8,r12[0xc]
8000673a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000673c:	ee c6 ff e8 	sub	r6,r7,-24
80006740:	0c 9c       	mov	r12,r6
80006742:	f0 1f 00 15 	mcall	80006794 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006746:	49 58       	lddpc	r8,80006798 <xTaskRemoveFromEventList+0x64>
80006748:	70 08       	ld.w	r8,r8[0x0]
8000674a:	58 08       	cp.w	r8,0
8000674c:	c1 71       	brne	8000677a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000674e:	ee c6 ff fc 	sub	r6,r7,-4
80006752:	0c 9c       	mov	r12,r6
80006754:	f0 1f 00 10 	mcall	80006794 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006758:	6e bc       	ld.w	r12,r7[0x2c]
8000675a:	49 18       	lddpc	r8,8000679c <xTaskRemoveFromEventList+0x68>
8000675c:	70 08       	ld.w	r8,r8[0x0]
8000675e:	10 3c       	cp.w	r12,r8
80006760:	e0 88 00 04 	brls	80006768 <xTaskRemoveFromEventList+0x34>
80006764:	48 e8       	lddpc	r8,8000679c <xTaskRemoveFromEventList+0x68>
80006766:	91 0c       	st.w	r8[0x0],r12
80006768:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000676c:	0c 9b       	mov	r11,r6
8000676e:	48 d8       	lddpc	r8,800067a0 <xTaskRemoveFromEventList+0x6c>
80006770:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006774:	f0 1f 00 0c 	mcall	800067a4 <xTaskRemoveFromEventList+0x70>
80006778:	c0 58       	rjmp	80006782 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000677a:	0c 9b       	mov	r11,r6
8000677c:	48 bc       	lddpc	r12,800067a8 <xTaskRemoveFromEventList+0x74>
8000677e:	f0 1f 00 0a 	mcall	800067a4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006782:	48 b8       	lddpc	r8,800067ac <xTaskRemoveFromEventList+0x78>
80006784:	70 08       	ld.w	r8,r8[0x0]
80006786:	6e b9       	ld.w	r9,r7[0x2c]
80006788:	70 b8       	ld.w	r8,r8[0x2c]
8000678a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000678c:	5f 2c       	srhs	r12
8000678e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006792:	00 00       	add	r0,r0
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	5d 56       	*unknown*
80006798:	00 00       	add	r0,r0
8000679a:	0d 20       	ld.uh	r0,r6++
8000679c:	00 00       	add	r0,r0
8000679e:	0d 58       	ld.sh	r8,--r6
800067a0:	00 00       	add	r0,r0
800067a2:	0c 3c       	cp.w	r12,r6
800067a4:	80 00       	ld.sh	r0,r0[0x0]
800067a6:	5d 06       	ror	r6
800067a8:	00 00       	add	r0,r0
800067aa:	0c f4       	st.b	--r6,r4
800067ac:	00 00       	add	r0,r0
800067ae:	0c f0       	st.b	--r6,r0

800067b0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800067b0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800067b4:	4b 98       	lddpc	r8,80006898 <vTaskIncrementTick+0xe8>
800067b6:	70 08       	ld.w	r8,r8[0x0]
800067b8:	58 08       	cp.w	r8,0
800067ba:	c6 91       	brne	8000688c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800067bc:	4b 88       	lddpc	r8,8000689c <vTaskIncrementTick+0xec>
800067be:	70 09       	ld.w	r9,r8[0x0]
800067c0:	2f f9       	sub	r9,-1
800067c2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800067c4:	70 08       	ld.w	r8,r8[0x0]
800067c6:	58 08       	cp.w	r8,0
800067c8:	c1 a1       	brne	800067fc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800067ca:	4b 68       	lddpc	r8,800068a0 <vTaskIncrementTick+0xf0>
800067cc:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800067ce:	4b 69       	lddpc	r9,800068a4 <vTaskIncrementTick+0xf4>
800067d0:	72 0b       	ld.w	r11,r9[0x0]
800067d2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800067d4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800067d6:	4b 59       	lddpc	r9,800068a8 <vTaskIncrementTick+0xf8>
800067d8:	72 0a       	ld.w	r10,r9[0x0]
800067da:	2f fa       	sub	r10,-1
800067dc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800067de:	70 08       	ld.w	r8,r8[0x0]
800067e0:	70 08       	ld.w	r8,r8[0x0]
800067e2:	58 08       	cp.w	r8,0
800067e4:	c0 51       	brne	800067ee <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067e6:	3f f9       	mov	r9,-1
800067e8:	4b 18       	lddpc	r8,800068ac <vTaskIncrementTick+0xfc>
800067ea:	91 09       	st.w	r8[0x0],r9
800067ec:	c0 88       	rjmp	800067fc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067ee:	4a d8       	lddpc	r8,800068a0 <vTaskIncrementTick+0xf0>
800067f0:	70 08       	ld.w	r8,r8[0x0]
800067f2:	70 38       	ld.w	r8,r8[0xc]
800067f4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800067f6:	70 19       	ld.w	r9,r8[0x4]
800067f8:	4a d8       	lddpc	r8,800068ac <vTaskIncrementTick+0xfc>
800067fa:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800067fc:	4a 88       	lddpc	r8,8000689c <vTaskIncrementTick+0xec>
800067fe:	70 09       	ld.w	r9,r8[0x0]
80006800:	4a b8       	lddpc	r8,800068ac <vTaskIncrementTick+0xfc>
80006802:	70 08       	ld.w	r8,r8[0x0]
80006804:	10 39       	cp.w	r9,r8
80006806:	c4 73       	brcs	80006894 <vTaskIncrementTick+0xe4>
80006808:	4a 68       	lddpc	r8,800068a0 <vTaskIncrementTick+0xf0>
8000680a:	70 08       	ld.w	r8,r8[0x0]
8000680c:	70 08       	ld.w	r8,r8[0x0]
8000680e:	58 08       	cp.w	r8,0
80006810:	c0 c0       	breq	80006828 <vTaskIncrementTick+0x78>
80006812:	4a 48       	lddpc	r8,800068a0 <vTaskIncrementTick+0xf0>
80006814:	70 08       	ld.w	r8,r8[0x0]
80006816:	70 38       	ld.w	r8,r8[0xc]
80006818:	70 37       	ld.w	r7,r8[0xc]
8000681a:	6e 18       	ld.w	r8,r7[0x4]
8000681c:	4a 09       	lddpc	r9,8000689c <vTaskIncrementTick+0xec>
8000681e:	72 09       	ld.w	r9,r9[0x0]
80006820:	12 38       	cp.w	r8,r9
80006822:	e0 88 00 14 	brls	8000684a <vTaskIncrementTick+0x9a>
80006826:	c0 e8       	rjmp	80006842 <vTaskIncrementTick+0x92>
80006828:	3f f9       	mov	r9,-1
8000682a:	4a 18       	lddpc	r8,800068ac <vTaskIncrementTick+0xfc>
8000682c:	91 09       	st.w	r8[0x0],r9
8000682e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006832:	6a 08       	ld.w	r8,r5[0x0]
80006834:	70 38       	ld.w	r8,r8[0xc]
80006836:	70 37       	ld.w	r7,r8[0xc]
80006838:	6e 18       	ld.w	r8,r7[0x4]
8000683a:	64 09       	ld.w	r9,r2[0x0]
8000683c:	12 38       	cp.w	r8,r9
8000683e:	e0 88 00 0a 	brls	80006852 <vTaskIncrementTick+0xa2>
80006842:	49 b9       	lddpc	r9,800068ac <vTaskIncrementTick+0xfc>
80006844:	93 08       	st.w	r9[0x0],r8
80006846:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000684a:	49 a4       	lddpc	r4,800068b0 <vTaskIncrementTick+0x100>
8000684c:	49 a3       	lddpc	r3,800068b4 <vTaskIncrementTick+0x104>
8000684e:	49 55       	lddpc	r5,800068a0 <vTaskIncrementTick+0xf0>
80006850:	49 32       	lddpc	r2,8000689c <vTaskIncrementTick+0xec>
80006852:	ee c6 ff fc 	sub	r6,r7,-4
80006856:	0c 9c       	mov	r12,r6
80006858:	f0 1f 00 18 	mcall	800068b8 <vTaskIncrementTick+0x108>
8000685c:	6e a8       	ld.w	r8,r7[0x28]
8000685e:	58 08       	cp.w	r8,0
80006860:	c0 50       	breq	8000686a <vTaskIncrementTick+0xba>
80006862:	ee cc ff e8 	sub	r12,r7,-24
80006866:	f0 1f 00 15 	mcall	800068b8 <vTaskIncrementTick+0x108>
8000686a:	6e bc       	ld.w	r12,r7[0x2c]
8000686c:	68 08       	ld.w	r8,r4[0x0]
8000686e:	10 3c       	cp.w	r12,r8
80006870:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006874:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006878:	0c 9b       	mov	r11,r6
8000687a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000687e:	f0 1f 00 10 	mcall	800068bc <vTaskIncrementTick+0x10c>
80006882:	6a 08       	ld.w	r8,r5[0x0]
80006884:	70 08       	ld.w	r8,r8[0x0]
80006886:	58 08       	cp.w	r8,0
80006888:	cd 51       	brne	80006832 <vTaskIncrementTick+0x82>
8000688a:	cc fb       	rjmp	80006828 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000688c:	48 d8       	lddpc	r8,800068c0 <vTaskIncrementTick+0x110>
8000688e:	70 09       	ld.w	r9,r8[0x0]
80006890:	2f f9       	sub	r9,-1
80006892:	91 09       	st.w	r8[0x0],r9
80006894:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006898:	00 00       	add	r0,r0
8000689a:	0d 20       	ld.uh	r0,r6++
8000689c:	00 00       	add	r0,r0
8000689e:	0d 1c       	ld.sh	r12,r6++
800068a0:	00 00       	add	r0,r0
800068a2:	0c 28       	rsub	r8,r6
800068a4:	00 00       	add	r0,r0
800068a6:	0c 38       	cp.w	r8,r6
800068a8:	00 00       	add	r0,r0
800068aa:	0c 34       	cp.w	r4,r6
800068ac:	00 00       	add	r0,r0
800068ae:	05 3c       	ld.ub	r12,r2++
800068b0:	00 00       	add	r0,r0
800068b2:	0d 58       	ld.sh	r8,--r6
800068b4:	00 00       	add	r0,r0
800068b6:	0c 3c       	cp.w	r12,r6
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	5d 56       	*unknown*
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	5d 06       	ror	r6
800068c0:	00 00       	add	r0,r0
800068c2:	0c 20       	rsub	r0,r6

800068c4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800068c4:	eb cd 40 c0 	pushm	r6-r7,lr
800068c8:	18 97       	mov	r7,r12
800068ca:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800068cc:	f0 1f 00 15 	mcall	80006920 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800068d0:	6c 08       	ld.w	r8,r6[0x0]
800068d2:	5b f8       	cp.w	r8,-1
800068d4:	c0 31       	brne	800068da <xTaskCheckForTimeOut+0x16>
800068d6:	30 07       	mov	r7,0
800068d8:	c1 f8       	rjmp	80006916 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800068da:	49 39       	lddpc	r9,80006924 <xTaskCheckForTimeOut+0x60>
800068dc:	72 09       	ld.w	r9,r9[0x0]
800068de:	6e 0a       	ld.w	r10,r7[0x0]
800068e0:	12 3a       	cp.w	r10,r9
800068e2:	c0 70       	breq	800068f0 <xTaskCheckForTimeOut+0x2c>
800068e4:	49 19       	lddpc	r9,80006928 <xTaskCheckForTimeOut+0x64>
800068e6:	72 09       	ld.w	r9,r9[0x0]
800068e8:	6e 1a       	ld.w	r10,r7[0x4]
800068ea:	12 3a       	cp.w	r10,r9
800068ec:	e0 88 00 14 	brls	80006914 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800068f0:	48 e9       	lddpc	r9,80006928 <xTaskCheckForTimeOut+0x64>
800068f2:	72 0a       	ld.w	r10,r9[0x0]
800068f4:	6e 19       	ld.w	r9,r7[0x4]
800068f6:	12 1a       	sub	r10,r9
800068f8:	14 38       	cp.w	r8,r10
800068fa:	e0 88 00 0d 	brls	80006914 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800068fe:	48 ba       	lddpc	r10,80006928 <xTaskCheckForTimeOut+0x64>
80006900:	74 0a       	ld.w	r10,r10[0x0]
80006902:	14 19       	sub	r9,r10
80006904:	f2 08 00 08 	add	r8,r9,r8
80006908:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000690a:	0e 9c       	mov	r12,r7
8000690c:	f0 1f 00 08 	mcall	8000692c <xTaskCheckForTimeOut+0x68>
80006910:	30 07       	mov	r7,0
80006912:	c0 28       	rjmp	80006916 <xTaskCheckForTimeOut+0x52>
80006914:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006916:	f0 1f 00 07 	mcall	80006930 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000691a:	0e 9c       	mov	r12,r7
8000691c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	5e 10       	retne	r0
80006924:	00 00       	add	r0,r0
80006926:	0c 34       	cp.w	r4,r6
80006928:	00 00       	add	r0,r0
8000692a:	0d 1c       	ld.sh	r12,r6++
8000692c:	80 00       	ld.sh	r0,r0[0x0]
8000692e:	66 28       	ld.w	r8,r3[0x8]
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	5f 1c       	srne	r12

80006934 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006934:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006938:	f0 1f 00 05 	mcall	8000694c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000693c:	48 58       	lddpc	r8,80006950 <xTaskGetTickCount+0x1c>
8000693e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006940:	f0 1f 00 05 	mcall	80006954 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006944:	0e 9c       	mov	r12,r7
80006946:	e3 cd 80 80 	ldm	sp++,r7,pc
8000694a:	00 00       	add	r0,r0
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	5e 10       	retne	r0
80006950:	00 00       	add	r0,r0
80006952:	0d 1c       	ld.sh	r12,r6++
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	5f 1c       	srne	r12

80006958 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006958:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000695c:	f0 1f 00 2c 	mcall	80006a0c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006960:	4a c8       	lddpc	r8,80006a10 <xTaskResumeAll+0xb8>
80006962:	70 09       	ld.w	r9,r8[0x0]
80006964:	20 19       	sub	r9,1
80006966:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006968:	70 08       	ld.w	r8,r8[0x0]
8000696a:	58 08       	cp.w	r8,0
8000696c:	c4 91       	brne	800069fe <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000696e:	4a a8       	lddpc	r8,80006a14 <xTaskResumeAll+0xbc>
80006970:	70 08       	ld.w	r8,r8[0x0]
80006972:	58 08       	cp.w	r8,0
80006974:	c4 50       	breq	800069fe <xTaskResumeAll+0xa6>
80006976:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006978:	4a 85       	lddpc	r5,80006a18 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000697a:	4a 93       	lddpc	r3,80006a1c <xTaskResumeAll+0xc4>
8000697c:	4a 92       	lddpc	r2,80006a20 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000697e:	4a a1       	lddpc	r1,80006a24 <xTaskResumeAll+0xcc>
80006980:	c1 e8       	rjmp	800069bc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006982:	6a 38       	ld.w	r8,r5[0xc]
80006984:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006986:	ee cc ff e8 	sub	r12,r7,-24
8000698a:	f0 1f 00 28 	mcall	80006a28 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000698e:	ee c6 ff fc 	sub	r6,r7,-4
80006992:	0c 9c       	mov	r12,r6
80006994:	f0 1f 00 25 	mcall	80006a28 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006998:	6e bc       	ld.w	r12,r7[0x2c]
8000699a:	66 08       	ld.w	r8,r3[0x0]
8000699c:	10 3c       	cp.w	r12,r8
8000699e:	e7 fc ba 00 	st.whi	r3[0x0],r12
800069a2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069a6:	0c 9b       	mov	r11,r6
800069a8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800069ac:	f0 1f 00 20 	mcall	80006a2c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069b0:	62 08       	ld.w	r8,r1[0x0]
800069b2:	6e b9       	ld.w	r9,r7[0x2c]
800069b4:	70 b8       	ld.w	r8,r8[0x2c]
800069b6:	10 39       	cp.w	r9,r8
800069b8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069bc:	6a 08       	ld.w	r8,r5[0x0]
800069be:	58 08       	cp.w	r8,0
800069c0:	ce 11       	brne	80006982 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069c2:	49 c8       	lddpc	r8,80006a30 <xTaskResumeAll+0xd8>
800069c4:	70 08       	ld.w	r8,r8[0x0]
800069c6:	58 08       	cp.w	r8,0
800069c8:	c0 f0       	breq	800069e6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069ca:	49 a8       	lddpc	r8,80006a30 <xTaskResumeAll+0xd8>
800069cc:	70 08       	ld.w	r8,r8[0x0]
800069ce:	58 08       	cp.w	r8,0
800069d0:	c1 10       	breq	800069f2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800069d2:	49 87       	lddpc	r7,80006a30 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800069d4:	f0 1f 00 18 	mcall	80006a34 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800069d8:	6e 08       	ld.w	r8,r7[0x0]
800069da:	20 18       	sub	r8,1
800069dc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069de:	6e 08       	ld.w	r8,r7[0x0]
800069e0:	58 08       	cp.w	r8,0
800069e2:	cf 91       	brne	800069d4 <xTaskResumeAll+0x7c>
800069e4:	c0 78       	rjmp	800069f2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069e6:	58 14       	cp.w	r4,1
800069e8:	c0 50       	breq	800069f2 <xTaskResumeAll+0x9a>
800069ea:	49 48       	lddpc	r8,80006a38 <xTaskResumeAll+0xe0>
800069ec:	70 08       	ld.w	r8,r8[0x0]
800069ee:	58 18       	cp.w	r8,1
800069f0:	c0 71       	brne	800069fe <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800069f2:	30 09       	mov	r9,0
800069f4:	49 18       	lddpc	r8,80006a38 <xTaskResumeAll+0xe0>
800069f6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800069f8:	d7 33       	scall
800069fa:	30 17       	mov	r7,1
800069fc:	c0 28       	rjmp	80006a00 <xTaskResumeAll+0xa8>
800069fe:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006a00:	f0 1f 00 0f 	mcall	80006a3c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006a04:	0e 9c       	mov	r12,r7
80006a06:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006a0a:	00 00       	add	r0,r0
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	5e 10       	retne	r0
80006a10:	00 00       	add	r0,r0
80006a12:	0d 20       	ld.uh	r0,r6++
80006a14:	00 00       	add	r0,r0
80006a16:	0d 3c       	ld.ub	r12,r6++
80006a18:	00 00       	add	r0,r0
80006a1a:	0c f4       	st.b	--r6,r4
80006a1c:	00 00       	add	r0,r0
80006a1e:	0d 58       	ld.sh	r8,--r6
80006a20:	00 00       	add	r0,r0
80006a22:	0c 3c       	cp.w	r12,r6
80006a24:	00 00       	add	r0,r0
80006a26:	0c f0       	st.b	--r6,r0
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	5d 56       	*unknown*
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	5d 06       	ror	r6
80006a30:	00 00       	add	r0,r0
80006a32:	0c 20       	rsub	r0,r6
80006a34:	80 00       	ld.sh	r0,r0[0x0]
80006a36:	67 b0       	ld.w	r0,r3[0x6c]
80006a38:	00 00       	add	r0,r0
80006a3a:	0d 40       	ld.w	r0,--r6
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	5f 1c       	srne	r12

80006a40 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a40:	eb cd 40 80 	pushm	r7,lr
80006a44:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a46:	49 08       	lddpc	r8,80006a84 <prvAddCurrentTaskToDelayedList+0x44>
80006a48:	70 08       	ld.w	r8,r8[0x0]
80006a4a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a4c:	48 f8       	lddpc	r8,80006a88 <prvAddCurrentTaskToDelayedList+0x48>
80006a4e:	70 08       	ld.w	r8,r8[0x0]
80006a50:	10 3c       	cp.w	r12,r8
80006a52:	c0 a2       	brcc	80006a66 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a54:	48 c8       	lddpc	r8,80006a84 <prvAddCurrentTaskToDelayedList+0x44>
80006a56:	70 0b       	ld.w	r11,r8[0x0]
80006a58:	48 d8       	lddpc	r8,80006a8c <prvAddCurrentTaskToDelayedList+0x4c>
80006a5a:	70 0c       	ld.w	r12,r8[0x0]
80006a5c:	2f cb       	sub	r11,-4
80006a5e:	f0 1f 00 0d 	mcall	80006a90 <prvAddCurrentTaskToDelayedList+0x50>
80006a62:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a66:	48 88       	lddpc	r8,80006a84 <prvAddCurrentTaskToDelayedList+0x44>
80006a68:	70 0b       	ld.w	r11,r8[0x0]
80006a6a:	48 b8       	lddpc	r8,80006a94 <prvAddCurrentTaskToDelayedList+0x54>
80006a6c:	70 0c       	ld.w	r12,r8[0x0]
80006a6e:	2f cb       	sub	r11,-4
80006a70:	f0 1f 00 08 	mcall	80006a90 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a74:	48 98       	lddpc	r8,80006a98 <prvAddCurrentTaskToDelayedList+0x58>
80006a76:	70 08       	ld.w	r8,r8[0x0]
80006a78:	10 37       	cp.w	r7,r8
80006a7a:	c0 32       	brcc	80006a80 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a7c:	48 78       	lddpc	r8,80006a98 <prvAddCurrentTaskToDelayedList+0x58>
80006a7e:	91 07       	st.w	r8[0x0],r7
80006a80:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a84:	00 00       	add	r0,r0
80006a86:	0c f0       	st.b	--r6,r0
80006a88:	00 00       	add	r0,r0
80006a8a:	0d 1c       	ld.sh	r12,r6++
80006a8c:	00 00       	add	r0,r0
80006a8e:	0c 38       	cp.w	r8,r6
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	5d 22       	mustr	r2
80006a94:	00 00       	add	r0,r0
80006a96:	0c 28       	rsub	r8,r6
80006a98:	00 00       	add	r0,r0
80006a9a:	05 3c       	ld.ub	r12,r2++

80006a9c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a9c:	eb cd 40 c0 	pushm	r6-r7,lr
80006aa0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006aa2:	58 0c       	cp.w	r12,0
80006aa4:	c1 10       	breq	80006ac6 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006aa6:	f0 1f 00 0a 	mcall	80006acc <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006aaa:	48 a8       	lddpc	r8,80006ad0 <vTaskDelay+0x34>
80006aac:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aae:	48 a8       	lddpc	r8,80006ad4 <vTaskDelay+0x38>
80006ab0:	70 0c       	ld.w	r12,r8[0x0]
80006ab2:	2f cc       	sub	r12,-4
80006ab4:	f0 1f 00 09 	mcall	80006ad8 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006ab8:	ee 06 00 0c 	add	r12,r7,r6
80006abc:	f0 1f 00 08 	mcall	80006adc <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006ac0:	f0 1f 00 08 	mcall	80006ae0 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006ac4:	c0 21       	brne	80006ac8 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006ac6:	d7 33       	scall
80006ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	65 9c       	ld.w	r12,r2[0x64]
80006ad0:	00 00       	add	r0,r0
80006ad2:	0d 1c       	ld.sh	r12,r6++
80006ad4:	00 00       	add	r0,r0
80006ad6:	0c f0       	st.b	--r6,r0
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	5d 56       	*unknown*
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	6a 40       	ld.w	r0,r5[0x10]
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	69 58       	ld.w	r8,r4[0x54]

80006ae4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006ae4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ae8:	18 96       	mov	r6,r12
80006aea:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006aec:	f0 1f 00 18 	mcall	80006b4c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006af0:	6c 08       	ld.w	r8,r6[0x0]
80006af2:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006af4:	49 79       	lddpc	r9,80006b50 <vTaskDelayUntil+0x6c>
80006af6:	72 09       	ld.w	r9,r9[0x0]
80006af8:	12 38       	cp.w	r8,r9
80006afa:	e0 88 00 0c 	brls	80006b12 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006afe:	0e 38       	cp.w	r8,r7
80006b00:	e0 88 00 22 	brls	80006b44 <vTaskDelayUntil+0x60>
80006b04:	49 38       	lddpc	r8,80006b50 <vTaskDelayUntil+0x6c>
80006b06:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b08:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006b0a:	10 37       	cp.w	r7,r8
80006b0c:	e0 88 00 14 	brls	80006b34 <vTaskDelayUntil+0x50>
80006b10:	c0 a8       	rjmp	80006b24 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006b12:	0e 38       	cp.w	r8,r7
80006b14:	e0 8b 00 16 	brhi	80006b40 <vTaskDelayUntil+0x5c>
80006b18:	48 e8       	lddpc	r8,80006b50 <vTaskDelayUntil+0x6c>
80006b1a:	70 08       	ld.w	r8,r8[0x0]
80006b1c:	10 37       	cp.w	r7,r8
80006b1e:	e0 8b 00 11 	brhi	80006b40 <vTaskDelayUntil+0x5c>
80006b22:	c1 18       	rjmp	80006b44 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b24:	48 c8       	lddpc	r8,80006b54 <vTaskDelayUntil+0x70>
80006b26:	70 0c       	ld.w	r12,r8[0x0]
80006b28:	2f cc       	sub	r12,-4
80006b2a:	f0 1f 00 0c 	mcall	80006b58 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b2e:	0e 9c       	mov	r12,r7
80006b30:	f0 1f 00 0b 	mcall	80006b5c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b34:	f0 1f 00 0b 	mcall	80006b60 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b38:	c0 81       	brne	80006b48 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b3a:	d7 33       	scall
80006b3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b40:	8d 07       	st.w	r6[0x0],r7
80006b42:	cf 1b       	rjmp	80006b24 <vTaskDelayUntil+0x40>
80006b44:	8d 07       	st.w	r6[0x0],r7
80006b46:	cf 7b       	rjmp	80006b34 <vTaskDelayUntil+0x50>
80006b48:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	65 9c       	ld.w	r12,r2[0x64]
80006b50:	00 00       	add	r0,r0
80006b52:	0d 1c       	ld.sh	r12,r6++
80006b54:	00 00       	add	r0,r0
80006b56:	0c f0       	st.b	--r6,r0
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	5d 56       	*unknown*
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	6a 40       	ld.w	r0,r5[0x10]
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	69 58       	ld.w	r8,r4[0x54]

80006b64 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b64:	eb cd 40 c0 	pushm	r6-r7,lr
80006b68:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b6a:	48 e7       	lddpc	r7,80006ba0 <vTaskPlaceOnEventList+0x3c>
80006b6c:	6e 0b       	ld.w	r11,r7[0x0]
80006b6e:	2e 8b       	sub	r11,-24
80006b70:	f0 1f 00 0d 	mcall	80006ba4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b74:	6e 0c       	ld.w	r12,r7[0x0]
80006b76:	2f cc       	sub	r12,-4
80006b78:	f0 1f 00 0c 	mcall	80006ba8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b7c:	5b f6       	cp.w	r6,-1
80006b7e:	c0 81       	brne	80006b8e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b80:	6e 0b       	ld.w	r11,r7[0x0]
80006b82:	2f cb       	sub	r11,-4
80006b84:	48 ac       	lddpc	r12,80006bac <vTaskPlaceOnEventList+0x48>
80006b86:	f0 1f 00 0b 	mcall	80006bb0 <vTaskPlaceOnEventList+0x4c>
80006b8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b8e:	48 a8       	lddpc	r8,80006bb4 <vTaskPlaceOnEventList+0x50>
80006b90:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b92:	ec 0c 00 0c 	add	r12,r6,r12
80006b96:	f0 1f 00 09 	mcall	80006bb8 <vTaskPlaceOnEventList+0x54>
80006b9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b9e:	00 00       	add	r0,r0
80006ba0:	00 00       	add	r0,r0
80006ba2:	0c f0       	st.b	--r6,r0
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	5d 22       	mustr	r2
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	5d 56       	*unknown*
80006bac:	00 00       	add	r0,r0
80006bae:	0d 44       	ld.w	r4,--r6
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	5d 06       	ror	r6
80006bb4:	00 00       	add	r0,r0
80006bb6:	0d 1c       	ld.sh	r12,r6++
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	6a 40       	ld.w	r0,r5[0x10]

80006bbc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006bbc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006bc0:	49 67       	lddpc	r7,80006c18 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006bc2:	49 74       	lddpc	r4,80006c1c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006bc4:	49 73       	lddpc	r3,80006c20 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006bc6:	49 85       	lddpc	r5,80006c24 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006bc8:	6e 08       	ld.w	r8,r7[0x0]
80006bca:	58 08       	cp.w	r8,0
80006bcc:	c1 e0       	breq	80006c08 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006bce:	f0 1f 00 17 	mcall	80006c28 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006bd2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006bd4:	f0 1f 00 16 	mcall	80006c2c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006bd8:	58 06       	cp.w	r6,0
80006bda:	c1 70       	breq	80006c08 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006bdc:	f0 1f 00 15 	mcall	80006c30 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006be0:	68 38       	ld.w	r8,r4[0xc]
80006be2:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006be4:	ec cc ff fc 	sub	r12,r6,-4
80006be8:	f0 1f 00 13 	mcall	80006c34 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006bec:	66 08       	ld.w	r8,r3[0x0]
80006bee:	20 18       	sub	r8,1
80006bf0:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006bf2:	6e 08       	ld.w	r8,r7[0x0]
80006bf4:	20 18       	sub	r8,1
80006bf6:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006bf8:	f0 1f 00 10 	mcall	80006c38 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006bfc:	6c cc       	ld.w	r12,r6[0x30]
80006bfe:	f0 1f 00 10 	mcall	80006c3c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006c02:	0c 9c       	mov	r12,r6
80006c04:	f0 1f 00 0e 	mcall	80006c3c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c08:	6a 08       	ld.w	r8,r5[0x0]
80006c0a:	58 18       	cp.w	r8,1
80006c0c:	e0 88 00 03 	brls	80006c12 <prvIdleTask+0x56>
			{
				taskYIELD();
80006c10:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006c12:	f0 1f 00 0c 	mcall	80006c40 <prvIdleTask+0x84>
		}
		#endif
	}
80006c16:	cd 9b       	rjmp	80006bc8 <prvIdleTask+0xc>
80006c18:	00 00       	add	r0,r0
80006c1a:	0c 30       	cp.w	r0,r6
80006c1c:	00 00       	add	r0,r0
80006c1e:	0c dc       	st.w	--r6,r12
80006c20:	00 00       	add	r0,r0
80006c22:	0d 3c       	ld.ub	r12,r6++
80006c24:	00 00       	add	r0,r0
80006c26:	0c 3c       	cp.w	r12,r6
80006c28:	80 00       	ld.sh	r0,r0[0x0]
80006c2a:	65 9c       	ld.w	r12,r2[0x64]
80006c2c:	80 00       	ld.sh	r0,r0[0x0]
80006c2e:	69 58       	ld.w	r8,r4[0x54]
80006c30:	80 00       	ld.sh	r0,r0[0x0]
80006c32:	5e 10       	retne	r0
80006c34:	80 00       	ld.sh	r0,r0[0x0]
80006c36:	5d 56       	*unknown*
80006c38:	80 00       	ld.sh	r0,r0[0x0]
80006c3a:	5f 1c       	srne	r12
80006c3c:	80 00       	ld.sh	r0,r0[0x0]
80006c3e:	60 54       	ld.w	r4,r0[0x14]
80006c40:	80 00       	ld.sh	r0,r0[0x0]
80006c42:	20 2c       	sub	r12,2

80006c44 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c44:	d4 31       	pushm	r0-r7,lr
80006c46:	20 1d       	sub	sp,4
80006c48:	fa c4 ff d8 	sub	r4,sp,-40
80006c4c:	50 0c       	stdsp	sp[0x0],r12
80006c4e:	16 91       	mov	r1,r11
80006c50:	14 97       	mov	r7,r10
80006c52:	12 90       	mov	r0,r9
80006c54:	10 93       	mov	r3,r8
80006c56:	68 02       	ld.w	r2,r4[0x0]
80006c58:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c5a:	34 8c       	mov	r12,72
80006c5c:	f0 1f 00 5c 	mcall	80006dcc <xTaskGenericCreate+0x188>
80006c60:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c62:	c0 31       	brne	80006c68 <xTaskGenericCreate+0x24>
80006c64:	3f fc       	mov	r12,-1
80006c66:	ca f8       	rjmp	80006dc4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c68:	58 06       	cp.w	r6,0
80006c6a:	e0 81 00 af 	brne	80006dc8 <xTaskGenericCreate+0x184>
80006c6e:	0e 9c       	mov	r12,r7
80006c70:	5c 7c       	castu.h	r12
80006c72:	a3 6c       	lsl	r12,0x2
80006c74:	f0 1f 00 56 	mcall	80006dcc <xTaskGenericCreate+0x188>
80006c78:	18 96       	mov	r6,r12
80006c7a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c7c:	c0 61       	brne	80006c88 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c7e:	0a 9c       	mov	r12,r5
80006c80:	f0 1f 00 54 	mcall	80006dd0 <xTaskGenericCreate+0x18c>
80006c84:	3f fc       	mov	r12,-1
80006c86:	c9 f8       	rjmp	80006dc4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c88:	5c 77       	castu.h	r7
80006c8a:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c8e:	e0 6b 00 a5 	mov	r11,165
80006c92:	0c 9c       	mov	r12,r6
80006c94:	f0 1f 00 50 	mcall	80006dd4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c98:	ee c6 00 01 	sub	r6,r7,1
80006c9c:	6a c8       	ld.w	r8,r5[0x30]
80006c9e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006ca2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006ca6:	31 0a       	mov	r10,16
80006ca8:	02 9b       	mov	r11,r1
80006caa:	ea cc ff cc 	sub	r12,r5,-52
80006cae:	f0 1f 00 4b 	mcall	80006dd8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006cb2:	30 08       	mov	r8,0
80006cb4:	eb 68 00 43 	st.b	r5[67],r8
80006cb8:	58 73       	cp.w	r3,7
80006cba:	e6 07 17 80 	movls	r7,r3
80006cbe:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006cc2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006cc4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006cc8:	ea c4 ff fc 	sub	r4,r5,-4
80006ccc:	08 9c       	mov	r12,r4
80006cce:	f0 1f 00 44 	mcall	80006ddc <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006cd2:	ea cc ff e8 	sub	r12,r5,-24
80006cd6:	f0 1f 00 42 	mcall	80006ddc <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006cda:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006cdc:	ee 07 11 08 	rsub	r7,r7,8
80006ce0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006ce2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006ce4:	00 9a       	mov	r10,r0
80006ce6:	40 0b       	lddsp	r11,sp[0x0]
80006ce8:	0c 9c       	mov	r12,r6
80006cea:	f0 1f 00 3e 	mcall	80006de0 <xTaskGenericCreate+0x19c>
80006cee:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006cf0:	58 02       	cp.w	r2,0
80006cf2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006cf6:	f0 1f 00 3c 	mcall	80006de4 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006cfa:	4b c8       	lddpc	r8,80006de8 <xTaskGenericCreate+0x1a4>
80006cfc:	70 09       	ld.w	r9,r8[0x0]
80006cfe:	2f f9       	sub	r9,-1
80006d00:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006d02:	4b b8       	lddpc	r8,80006dec <xTaskGenericCreate+0x1a8>
80006d04:	70 08       	ld.w	r8,r8[0x0]
80006d06:	58 08       	cp.w	r8,0
80006d08:	c2 61       	brne	80006d54 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006d0a:	4b 98       	lddpc	r8,80006dec <xTaskGenericCreate+0x1a8>
80006d0c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006d0e:	4b 78       	lddpc	r8,80006de8 <xTaskGenericCreate+0x1a4>
80006d10:	70 08       	ld.w	r8,r8[0x0]
80006d12:	58 18       	cp.w	r8,1
80006d14:	c2 b1       	brne	80006d6a <xTaskGenericCreate+0x126>
80006d16:	4b 77       	lddpc	r7,80006df0 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006d18:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006d1c:	0e 9c       	mov	r12,r7
80006d1e:	f0 1f 00 36 	mcall	80006df4 <xTaskGenericCreate+0x1b0>
80006d22:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d24:	0c 37       	cp.w	r7,r6
80006d26:	cf b1       	brne	80006d1c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d28:	4b 47       	lddpc	r7,80006df8 <xTaskGenericCreate+0x1b4>
80006d2a:	0e 9c       	mov	r12,r7
80006d2c:	f0 1f 00 32 	mcall	80006df4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d30:	4b 36       	lddpc	r6,80006dfc <xTaskGenericCreate+0x1b8>
80006d32:	0c 9c       	mov	r12,r6
80006d34:	f0 1f 00 30 	mcall	80006df4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d38:	4b 2c       	lddpc	r12,80006e00 <xTaskGenericCreate+0x1bc>
80006d3a:	f0 1f 00 2f 	mcall	80006df4 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d3e:	4b 2c       	lddpc	r12,80006e04 <xTaskGenericCreate+0x1c0>
80006d40:	f0 1f 00 2d 	mcall	80006df4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d44:	4b 1c       	lddpc	r12,80006e08 <xTaskGenericCreate+0x1c4>
80006d46:	f0 1f 00 2c 	mcall	80006df4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d4a:	4b 18       	lddpc	r8,80006e0c <xTaskGenericCreate+0x1c8>
80006d4c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d4e:	4b 18       	lddpc	r8,80006e10 <xTaskGenericCreate+0x1cc>
80006d50:	91 06       	st.w	r8[0x0],r6
80006d52:	c0 c8       	rjmp	80006d6a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d54:	4b 08       	lddpc	r8,80006e14 <xTaskGenericCreate+0x1d0>
80006d56:	70 08       	ld.w	r8,r8[0x0]
80006d58:	58 08       	cp.w	r8,0
80006d5a:	c0 81       	brne	80006d6a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d5c:	4a 48       	lddpc	r8,80006dec <xTaskGenericCreate+0x1a8>
80006d5e:	70 08       	ld.w	r8,r8[0x0]
80006d60:	70 b8       	ld.w	r8,r8[0x2c]
80006d62:	10 33       	cp.w	r3,r8
80006d64:	c0 33       	brcs	80006d6a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d66:	4a 28       	lddpc	r8,80006dec <xTaskGenericCreate+0x1a8>
80006d68:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d6a:	6a b8       	ld.w	r8,r5[0x2c]
80006d6c:	4a b9       	lddpc	r9,80006e18 <xTaskGenericCreate+0x1d4>
80006d6e:	72 09       	ld.w	r9,r9[0x0]
80006d70:	12 38       	cp.w	r8,r9
80006d72:	e0 88 00 04 	brls	80006d7a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d76:	4a 99       	lddpc	r9,80006e18 <xTaskGenericCreate+0x1d4>
80006d78:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d7a:	4a 98       	lddpc	r8,80006e1c <xTaskGenericCreate+0x1d8>
80006d7c:	70 09       	ld.w	r9,r8[0x0]
80006d7e:	2f f9       	sub	r9,-1
80006d80:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d82:	6a b8       	ld.w	r8,r5[0x2c]
80006d84:	4a 79       	lddpc	r9,80006e20 <xTaskGenericCreate+0x1dc>
80006d86:	72 09       	ld.w	r9,r9[0x0]
80006d88:	12 38       	cp.w	r8,r9
80006d8a:	e0 88 00 04 	brls	80006d92 <xTaskGenericCreate+0x14e>
80006d8e:	4a 59       	lddpc	r9,80006e20 <xTaskGenericCreate+0x1dc>
80006d90:	93 08       	st.w	r9[0x0],r8
80006d92:	6a bc       	ld.w	r12,r5[0x2c]
80006d94:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d98:	08 9b       	mov	r11,r4
80006d9a:	49 68       	lddpc	r8,80006df0 <xTaskGenericCreate+0x1ac>
80006d9c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006da0:	f0 1f 00 21 	mcall	80006e24 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006da4:	f0 1f 00 21 	mcall	80006e28 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006da8:	49 b8       	lddpc	r8,80006e14 <xTaskGenericCreate+0x1d0>
80006daa:	70 08       	ld.w	r8,r8[0x0]
80006dac:	58 08       	cp.w	r8,0
80006dae:	c0 a0       	breq	80006dc2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006db0:	48 f8       	lddpc	r8,80006dec <xTaskGenericCreate+0x1a8>
80006db2:	70 08       	ld.w	r8,r8[0x0]
80006db4:	70 b8       	ld.w	r8,r8[0x2c]
80006db6:	10 33       	cp.w	r3,r8
80006db8:	e0 88 00 05 	brls	80006dc2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006dbc:	d7 33       	scall
80006dbe:	30 1c       	mov	r12,1
80006dc0:	c0 28       	rjmp	80006dc4 <xTaskGenericCreate+0x180>
80006dc2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006dc4:	2f fd       	sub	sp,-4
80006dc6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006dc8:	99 c6       	st.w	r12[0x30],r6
80006dca:	c5 fb       	rjmp	80006c88 <xTaskGenericCreate+0x44>
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	60 7c       	ld.w	r12,r0[0x1c]
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	60 54       	ld.w	r4,r0[0x14]
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	79 d4       	ld.w	r4,r12[0x74]
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	7d 00       	ld.w	r0,lr[0x40]
80006ddc:	80 00       	ld.sh	r0,r0[0x0]
80006dde:	5d 00       	ror	r0
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	5d 7c       	*unknown*
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	5e 10       	retne	r0
80006de8:	00 00       	add	r0,r0
80006dea:	0d 3c       	ld.ub	r12,r6++
80006dec:	00 00       	add	r0,r0
80006dee:	0c f0       	st.b	--r6,r0
80006df0:	00 00       	add	r0,r0
80006df2:	0c 3c       	cp.w	r12,r6
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	5c ec       	tnbz	r12
80006df8:	00 00       	add	r0,r0
80006dfa:	0d 08       	ld.w	r8,r6++
80006dfc:	00 00       	add	r0,r0
80006dfe:	0d 24       	ld.uh	r4,r6++
80006e00:	00 00       	add	r0,r0
80006e02:	0c f4       	st.b	--r6,r4
80006e04:	00 00       	add	r0,r0
80006e06:	0c dc       	st.w	--r6,r12
80006e08:	00 00       	add	r0,r0
80006e0a:	0d 44       	ld.w	r4,--r6
80006e0c:	00 00       	add	r0,r0
80006e0e:	0c 28       	rsub	r8,r6
80006e10:	00 00       	add	r0,r0
80006e12:	0c 38       	cp.w	r8,r6
80006e14:	00 00       	add	r0,r0
80006e16:	0c 2c       	rsub	r12,r6
80006e18:	00 00       	add	r0,r0
80006e1a:	0c 24       	rsub	r4,r6
80006e1c:	00 00       	add	r0,r0
80006e1e:	0d 38       	ld.ub	r8,r6++
80006e20:	00 00       	add	r0,r0
80006e22:	0d 58       	ld.sh	r8,--r6
80006e24:	80 00       	ld.sh	r0,r0[0x0]
80006e26:	5d 06       	ror	r6
80006e28:	80 00       	ld.sh	r0,r0[0x0]
80006e2a:	5f 1c       	srne	r12

80006e2c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e2c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e2e:	30 09       	mov	r9,0
80006e30:	1a d9       	st.w	--sp,r9
80006e32:	1a d9       	st.w	--sp,r9
80006e34:	1a d9       	st.w	--sp,r9
80006e36:	12 98       	mov	r8,r9
80006e38:	e0 6a 01 00 	mov	r10,256
80006e3c:	48 9b       	lddpc	r11,80006e60 <vTaskStartScheduler+0x34>
80006e3e:	48 ac       	lddpc	r12,80006e64 <vTaskStartScheduler+0x38>
80006e40:	f0 1f 00 0a 	mcall	80006e68 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e44:	2f dd       	sub	sp,-12
80006e46:	58 1c       	cp.w	r12,1
80006e48:	c0 a1       	brne	80006e5c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e4a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e4c:	30 19       	mov	r9,1
80006e4e:	48 88       	lddpc	r8,80006e6c <vTaskStartScheduler+0x40>
80006e50:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e52:	30 09       	mov	r9,0
80006e54:	48 78       	lddpc	r8,80006e70 <vTaskStartScheduler+0x44>
80006e56:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e58:	f0 1f 00 07 	mcall	80006e74 <vTaskStartScheduler+0x48>
80006e5c:	d8 02       	popm	pc
80006e5e:	00 00       	add	r0,r0
80006e60:	80 00       	ld.sh	r0,r0[0x0]
80006e62:	da 20       	acall	0xa2
80006e64:	80 00       	ld.sh	r0,r0[0x0]
80006e66:	6b bc       	ld.w	r12,r5[0x6c]
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	6c 44       	ld.w	r4,r6[0x10]
80006e6c:	00 00       	add	r0,r0
80006e6e:	0c 2c       	rsub	r12,r6
80006e70:	00 00       	add	r0,r0
80006e72:	0d 1c       	ld.sh	r12,r6++
80006e74:	80 00       	ld.sh	r0,r0[0x0]
80006e76:	5e 20       	reths	r0

80006e78 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e78:	16 cc       	st.b	r11++,r12
	return str;
}
80006e7a:	5e fb       	retal	r11

80006e7c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80006e80:	20 3d       	sub	sp,12
80006e82:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e84:	30 06       	mov	r6,0
80006e86:	30 07       	mov	r7,0
80006e88:	fa e7 00 00 	st.d	sp[0],r6
80006e8c:	30 0c       	mov	r12,0
80006e8e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e90:	58 08       	cp.w	r8,0
80006e92:	c1 30       	breq	80006eb8 <PrintHex+0x3c>
80006e94:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e96:	1a 9c       	mov	r12,sp
80006e98:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e9c:	58 9e       	cp.w	lr,9
80006e9e:	e0 8a 00 04 	brle	80006ea6 <PrintHex+0x2a>
80006ea2:	2c 9e       	sub	lr,-55
80006ea4:	c0 48       	rjmp	80006eac <PrintHex+0x30>
80006ea6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006eaa:	2d 0e       	sub	lr,-48
80006eac:	f8 09 0b 0e 	st.b	r12[r9],lr
80006eb0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006eb2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006eb4:	cf 21       	brne	80006e98 <PrintHex+0x1c>
80006eb6:	c0 48       	rjmp	80006ebe <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006eb8:	33 08       	mov	r8,48
80006eba:	ba 88       	st.b	sp[0x0],r8
80006ebc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006ebe:	f6 09 01 08 	sub	r8,r11,r9
80006ec2:	58 08       	cp.w	r8,0
80006ec4:	e0 8a 00 13 	brle	80006eea <PrintHex+0x6e>
	{
		char num = len - cnt;
80006ec8:	12 1b       	sub	r11,r9
80006eca:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006ece:	18 9e       	mov	lr,r12
80006ed0:	58 0c       	cp.w	r12,0
80006ed2:	e0 8a 00 0c 	brle	80006eea <PrintHex+0x6e>
80006ed6:	1a 9b       	mov	r11,sp
80006ed8:	12 0b       	add	r11,r9
80006eda:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006edc:	33 07       	mov	r7,48
80006ede:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ee0:	2f f8       	sub	r8,-1
80006ee2:	1c 38       	cp.w	r8,lr
80006ee4:	cf d5       	brlt	80006ede <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ee6:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006eea:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006eee:	f0 cb ff ff 	sub	r11,r8,-1
80006ef2:	58 0b       	cp.w	r11,0
80006ef4:	e0 8a 00 19 	brle	80006f26 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ef8:	fa cb ff f4 	sub	r11,sp,-12
80006efc:	f6 09 00 09 	add	r9,r11,r9
80006f00:	37 8b       	mov	r11,120
80006f02:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006f06:	fa c9 ff f4 	sub	r9,sp,-12
80006f0a:	10 09       	add	r9,r8
80006f0c:	33 0b       	mov	r11,48
80006f0e:	f3 6b ff f4 	st.b	r9[-12],r11
80006f12:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f16:	fa ce 00 01 	sub	lr,sp,1
80006f1a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f1c:	11 8b       	ld.ub	r11,r8[0x0]
80006f1e:	12 cb       	st.b	r9++,r11
80006f20:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006f22:	1c 38       	cp.w	r8,lr
80006f24:	cf c1       	brne	80006f1c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f26:	14 9c       	mov	r12,r10
80006f28:	2f dd       	sub	sp,-12
80006f2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f2e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f2e:	d4 21       	pushm	r4-r7,lr
80006f30:	20 3d       	sub	sp,12
80006f32:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f34:	30 06       	mov	r6,0
80006f36:	30 07       	mov	r7,0
80006f38:	fa e7 00 00 	st.d	sp[0],r6
80006f3c:	30 0c       	mov	r12,0
80006f3e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f40:	58 08       	cp.w	r8,0
80006f42:	c0 35       	brlt	80006f48 <PrintDec+0x1a>
80006f44:	14 97       	mov	r7,r10
80006f46:	c0 58       	rjmp	80006f50 <PrintDec+0x22>
	{
		*p++ = '-';
80006f48:	14 97       	mov	r7,r10
80006f4a:	32 d9       	mov	r9,45
80006f4c:	0e c9       	st.b	r7++,r9
		i = -i;
80006f4e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f50:	58 08       	cp.w	r8,0
80006f52:	c0 51       	brne	80006f5c <PrintDec+0x2e>
80006f54:	33 08       	mov	r8,48
80006f56:	ba 88       	st.b	sp[0x0],r8
80006f58:	30 1e       	mov	lr,1
80006f5a:	c2 f8       	rjmp	80006fb8 <PrintDec+0x8a>
	
	int ten = i%10;
80006f5c:	e0 65 66 67 	mov	r5,26215
80006f60:	ea 15 66 66 	orh	r5,0x6666
80006f64:	f0 05 04 44 	muls.d	r4,r8,r5
80006f68:	ea 0c 14 02 	asr	r12,r5,0x2
80006f6c:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f70:	f8 09 01 09 	sub	r9,r12,r9
80006f74:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f78:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f7c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f7e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f80:	e0 66 66 67 	mov	r6,26215
80006f84:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f88:	2d 09       	sub	r9,-48
80006f8a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f8e:	2f fe       	sub	lr,-1
		i /= 10;
80006f90:	f0 06 04 44 	muls.d	r4,r8,r6
80006f94:	ea 09 14 02 	asr	r9,r5,0x2
80006f98:	bf 58       	asr	r8,0x1f
80006f9a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f9e:	f0 06 04 44 	muls.d	r4,r8,r6
80006fa2:	ea 09 14 02 	asr	r9,r5,0x2
80006fa6:	f0 05 14 1f 	asr	r5,r8,0x1f
80006faa:	0a 19       	sub	r9,r5
80006fac:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fb0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006fb4:	58 08       	cp.w	r8,0
80006fb6:	ce 91       	brne	80006f88 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006fb8:	f6 0e 01 08 	sub	r8,r11,lr
80006fbc:	58 08       	cp.w	r8,0
80006fbe:	e0 89 00 06 	brgt	80006fca <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fc2:	58 0e       	cp.w	lr,0
80006fc4:	e0 89 00 14 	brgt	80006fec <PrintDec+0xbe>
80006fc8:	c1 d8       	rjmp	80007002 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006fca:	1c 1b       	sub	r11,lr
80006fcc:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006fce:	16 9c       	mov	r12,r11
80006fd0:	58 0b       	cp.w	r11,0
80006fd2:	fe 9a ff f8 	brle	80006fc2 <PrintDec+0x94>
80006fd6:	1a 99       	mov	r9,sp
80006fd8:	1c 09       	add	r9,lr
80006fda:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fdc:	33 06       	mov	r6,48
80006fde:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006fe0:	2f f8       	sub	r8,-1
80006fe2:	18 38       	cp.w	r8,r12
80006fe4:	cf d5       	brlt	80006fde <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006fe6:	f6 0e 00 0e 	add	lr,r11,lr
80006fea:	ce cb       	rjmp	80006fc2 <PrintDec+0x94>
80006fec:	fa c8 ff f4 	sub	r8,sp,-12
80006ff0:	1c 08       	add	r8,lr
80006ff2:	20 d8       	sub	r8,13
80006ff4:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ff8:	11 89       	ld.ub	r9,r8[0x0]
80006ffa:	0e c9       	st.b	r7++,r9
80006ffc:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006ffe:	16 38       	cp.w	r8,r11
80007000:	cf c1       	brne	80006ff8 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007002:	14 9c       	mov	r12,r10
80007004:	2f dd       	sub	sp,-12
80007006:	d8 22       	popm	r4-r7,pc

80007008 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007008:	d4 31       	pushm	r0-r7,lr
8000700a:	fa cd 02 08 	sub	sp,sp,520
8000700e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007010:	e0 6a 01 00 	mov	r10,256
80007014:	30 0b       	mov	r11,0
80007016:	fa cc fe f8 	sub	r12,sp,-264
8000701a:	f0 1f 00 4e 	mcall	80007150 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000701e:	fa c4 fd d4 	sub	r4,sp,-556
80007022:	30 0a       	mov	r10,0
80007024:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007026:	fa c3 ff fc 	sub	r3,sp,-4
8000702a:	e0 61 01 00 	mov	r1,256
8000702e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007030:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007032:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007036:	02 9a       	mov	r10,r1
80007038:	00 9b       	mov	r11,r0
8000703a:	06 9c       	mov	r12,r3
8000703c:	f0 1f 00 45 	mcall	80007150 <log+0x148>
			
					if(*str == '%')
80007040:	0f 88       	ld.ub	r8,r7[0x0]
80007042:	e4 08 18 00 	cp.b	r8,r2
80007046:	c5 71       	brne	800070f4 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007048:	ee c8 ff ff 	sub	r8,r7,-1
8000704c:	11 89       	ld.ub	r9,r8[0x0]
8000704e:	4c 2a       	lddpc	r10,80007154 <log+0x14c>
80007050:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007052:	23 09       	sub	r9,48
80007054:	30 9a       	mov	r10,9
80007056:	f4 09 18 00 	cp.b	r9,r10
8000705a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000705e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007062:	f7 b9 08 30 	subls	r9,48
80007066:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000706a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000706e:	0f 88       	ld.ub	r8,r7[0x0]
80007070:	22 58       	sub	r8,37
80007072:	e0 48 00 53 	cp.w	r8,83
80007076:	e0 8b 00 31 	brhi	800070d8 <log+0xd0>
8000707a:	4b 89       	lddpc	r9,80007158 <log+0x150>
8000707c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007080:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007084:	06 9a       	mov	r10,r3
80007086:	40 0b       	lddsp	r11,sp[0x0]
80007088:	5c 5b       	castu.b	r11
8000708a:	68 0c       	ld.w	r12,r4[0x0]
8000708c:	f0 1f 00 34 	mcall	8000715c <log+0x154>
							break;
80007090:	c2 98       	rjmp	800070e2 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007092:	4b 4c       	lddpc	r12,80007160 <log+0x158>
80007094:	f0 1f 00 34 	mcall	80007164 <log+0x15c>
80007098:	08 95       	mov	r5,r4
8000709a:	06 9c       	mov	r12,r3
							break;
8000709c:	c2 38       	rjmp	800070e2 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000709e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800070a2:	06 9a       	mov	r10,r3
800070a4:	40 0b       	lddsp	r11,sp[0x0]
800070a6:	5c 5b       	castu.b	r11
800070a8:	68 0c       	ld.w	r12,r4[0x0]
800070aa:	f0 1f 00 30 	mcall	80007168 <log+0x160>
800070ae:	06 9c       	mov	r12,r3
							break;
800070b0:	c1 98       	rjmp	800070e2 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800070b2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800070b6:	06 9b       	mov	r11,r3
800070b8:	09 bc       	ld.ub	r12,r4[0x3]
800070ba:	f0 1f 00 2d 	mcall	8000716c <log+0x164>
800070be:	06 9c       	mov	r12,r3
							break;
800070c0:	c1 18       	rjmp	800070e2 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800070c2:	e8 c5 ff fc 	sub	r5,r4,-4
800070c6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800070c8:	c0 d8       	rjmp	800070e2 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800070ca:	06 9b       	mov	r11,r3
800070cc:	32 5c       	mov	r12,37
800070ce:	f0 1f 00 28 	mcall	8000716c <log+0x164>
800070d2:	08 95       	mov	r5,r4
800070d4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800070d6:	c0 68       	rjmp	800070e2 <log+0xda>
							
							default:
							log("I need relax.");
800070d8:	4a 6c       	lddpc	r12,80007170 <log+0x168>
800070da:	f0 1f 00 23 	mcall	80007164 <log+0x15c>
800070de:	08 95       	mov	r5,r4
800070e0:	06 9c       	mov	r12,r3
						}
						str++;
800070e2:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070e4:	1a dc       	st.w	--sp,r12
800070e6:	1a d6       	st.w	--sp,r6
800070e8:	4a 3b       	lddpc	r11,80007174 <log+0x16c>
800070ea:	0c 9c       	mov	r12,r6
800070ec:	f0 1f 00 23 	mcall	80007178 <log+0x170>
800070f0:	2f ed       	sub	sp,-8
800070f2:	c0 a8       	rjmp	80007106 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070f4:	2f f7       	sub	r7,-1
800070f6:	1a d8       	st.w	--sp,r8
800070f8:	1a d6       	st.w	--sp,r6
800070fa:	4a 1b       	lddpc	r11,8000717c <log+0x174>
800070fc:	0c 9c       	mov	r12,r6
800070fe:	f0 1f 00 1f 	mcall	80007178 <log+0x170>
80007102:	08 95       	mov	r5,r4
80007104:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007106:	0f 89       	ld.ub	r9,r7[0x0]
80007108:	30 08       	mov	r8,0
8000710a:	f0 09 18 00 	cp.b	r9,r8
8000710e:	c0 30       	breq	80007114 <log+0x10c>
80007110:	0a 94       	mov	r4,r5
80007112:	c9 2b       	rjmp	80007036 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007114:	fa c7 fe f8 	sub	r7,sp,-264
80007118:	1a d7       	st.w	--sp,r7
8000711a:	49 ab       	lddpc	r11,80007180 <log+0x178>
8000711c:	0e 9c       	mov	r12,r7
8000711e:	f0 1f 00 17 	mcall	80007178 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007122:	5c 5c       	castu.b	r12
80007124:	f8 c6 ff ff 	sub	r6,r12,-1
80007128:	0c 9c       	mov	r12,r6
8000712a:	f0 1f 00 17 	mcall	80007184 <log+0x17c>
8000712e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007130:	0c 9a       	mov	r10,r6
80007132:	0e 9b       	mov	r11,r7
80007134:	f0 1f 00 15 	mcall	80007188 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007138:	30 09       	mov	r9,0
8000713a:	30 5a       	mov	r10,5
8000713c:	fa cb fe f8 	sub	r11,sp,-264
80007140:	49 38       	lddpc	r8,8000718c <log+0x184>
80007142:	70 0c       	ld.w	r12,r8[0x0]
80007144:	f0 1f 00 13 	mcall	80007190 <log+0x188>
80007148:	2f fd       	sub	sp,-4
	
	
}
8000714a:	fe 3d fd f8 	sub	sp,-520
8000714e:	d8 32       	popm	r0-r7,pc
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	79 d4       	ld.w	r4,r12[0x74]
80007154:	00 00       	add	r0,r0
80007156:	0d 5c       	ld.sh	r12,--r6
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	da 28       	*unknown*
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	6f 2e       	ld.w	lr,r7[0x48]
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	dc d4       	*unknown*
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	70 08       	ld.w	r8,r8[0x0]
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	6e 7c       	ld.w	r12,r7[0x1c]
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	6e 78       	ld.w	r8,r7[0x1c]
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	dc e4       	*unknown*
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	dc f4       	*unknown*
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	7c c4       	ld.w	r4,lr[0x30]
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	dc fc       	*unknown*
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	dd 04       	*unknown*
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	60 7c       	ld.w	r12,r0[0x1c]
80007188:	80 00       	ld.sh	r0,r0[0x0]
8000718a:	78 8c       	ld.w	r12,r12[0x20]
8000718c:	00 00       	add	r0,r0
8000718e:	53 c4       	stdsp	sp[0xf0],r4
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	63 d0       	ld.w	r0,r1[0x74]

80007194 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007194:	d4 31       	pushm	r0-r7,lr
80007196:	fa cd 02 0c 	sub	sp,sp,524
8000719a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000719c:	e0 6a 01 00 	mov	r10,256
800071a0:	30 0b       	mov	r11,0
800071a2:	fa cc fe f4 	sub	r12,sp,-268
800071a6:	f0 1f 00 4c 	mcall	800072d4 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800071aa:	fa c4 fd d0 	sub	r4,sp,-560
800071ae:	30 0a       	mov	r10,0
800071b0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800071b2:	fa c3 ff fc 	sub	r3,sp,-4
800071b6:	e0 61 01 00 	mov	r1,256
800071ba:	14 90       	mov	r0,r10
			
			if(*str == '%')
800071bc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071be:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800071c2:	02 9a       	mov	r10,r1
800071c4:	00 9b       	mov	r11,r0
800071c6:	06 9c       	mov	r12,r3
800071c8:	f0 1f 00 43 	mcall	800072d4 <logFromISR+0x140>
			
			if(*str == '%')
800071cc:	0f 88       	ld.ub	r8,r7[0x0]
800071ce:	e4 08 18 00 	cp.b	r8,r2
800071d2:	c5 11       	brne	80007274 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800071d4:	ee c8 ff ff 	sub	r8,r7,-1
800071d8:	11 89       	ld.ub	r9,r8[0x0]
800071da:	4c 0a       	lddpc	r10,800072d8 <logFromISR+0x144>
800071dc:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800071de:	23 09       	sub	r9,48
800071e0:	30 9a       	mov	r10,9
800071e2:	f4 09 18 00 	cp.b	r9,r10
800071e6:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071ea:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071ee:	f7 b9 08 30 	subls	r9,48
800071f2:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800071f6:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800071fa:	0f 88       	ld.ub	r8,r7[0x0]
800071fc:	22 58       	sub	r8,37
800071fe:	e0 48 00 53 	cp.w	r8,83
80007202:	e0 8b 00 2b 	brhi	80007258 <logFromISR+0xc4>
80007206:	4b 69       	lddpc	r9,800072dc <logFromISR+0x148>
80007208:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000720c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007210:	06 9a       	mov	r10,r3
80007212:	40 0b       	lddsp	r11,sp[0x0]
80007214:	5c 5b       	castu.b	r11
80007216:	68 0c       	ld.w	r12,r4[0x0]
80007218:	f0 1f 00 32 	mcall	800072e0 <logFromISR+0x14c>
					break;
8000721c:	c2 38       	rjmp	80007262 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000721e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007222:	06 9a       	mov	r10,r3
80007224:	40 0b       	lddsp	r11,sp[0x0]
80007226:	5c 5b       	castu.b	r11
80007228:	68 0c       	ld.w	r12,r4[0x0]
8000722a:	f0 1f 00 2f 	mcall	800072e4 <logFromISR+0x150>
8000722e:	06 9c       	mov	r12,r3
					break;
80007230:	c1 98       	rjmp	80007262 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007232:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007236:	06 9b       	mov	r11,r3
80007238:	09 bc       	ld.ub	r12,r4[0x3]
8000723a:	f0 1f 00 2c 	mcall	800072e8 <logFromISR+0x154>
8000723e:	06 9c       	mov	r12,r3
					break;
80007240:	c1 18       	rjmp	80007262 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007242:	e8 c5 ff fc 	sub	r5,r4,-4
80007246:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007248:	c0 d8       	rjmp	80007262 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000724a:	06 9b       	mov	r11,r3
8000724c:	32 5c       	mov	r12,37
8000724e:	f0 1f 00 27 	mcall	800072e8 <logFromISR+0x154>
80007252:	08 95       	mov	r5,r4
80007254:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007256:	c0 68       	rjmp	80007262 <logFromISR+0xce>
					default:
					log("I need relax.");
80007258:	4a 5c       	lddpc	r12,800072ec <logFromISR+0x158>
8000725a:	f0 1f 00 26 	mcall	800072f0 <logFromISR+0x15c>
8000725e:	08 95       	mov	r5,r4
80007260:	06 9c       	mov	r12,r3
				}
				str++;
80007262:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007264:	1a dc       	st.w	--sp,r12
80007266:	1a d6       	st.w	--sp,r6
80007268:	4a 3b       	lddpc	r11,800072f4 <logFromISR+0x160>
8000726a:	0c 9c       	mov	r12,r6
8000726c:	f0 1f 00 23 	mcall	800072f8 <logFromISR+0x164>
80007270:	2f ed       	sub	sp,-8
80007272:	c0 a8       	rjmp	80007286 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007274:	2f f7       	sub	r7,-1
80007276:	1a d8       	st.w	--sp,r8
80007278:	1a d6       	st.w	--sp,r6
8000727a:	4a 1b       	lddpc	r11,800072fc <logFromISR+0x168>
8000727c:	0c 9c       	mov	r12,r6
8000727e:	f0 1f 00 1f 	mcall	800072f8 <logFromISR+0x164>
80007282:	08 95       	mov	r5,r4
80007284:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007286:	0f 89       	ld.ub	r9,r7[0x0]
80007288:	30 08       	mov	r8,0
8000728a:	f0 09 18 00 	cp.b	r9,r8
8000728e:	c0 30       	breq	80007294 <logFromISR+0x100>
80007290:	0a 94       	mov	r4,r5
80007292:	c9 8b       	rjmp	800071c2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007294:	fa c7 fe f4 	sub	r7,sp,-268
80007298:	1a d7       	st.w	--sp,r7
8000729a:	49 ab       	lddpc	r11,80007300 <logFromISR+0x16c>
8000729c:	0e 9c       	mov	r12,r7
8000729e:	f0 1f 00 17 	mcall	800072f8 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800072a2:	5c 5c       	castu.b	r12
800072a4:	f8 c6 ff ff 	sub	r6,r12,-1
800072a8:	0c 9c       	mov	r12,r6
800072aa:	f0 1f 00 17 	mcall	80007304 <logFromISR+0x170>
800072ae:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800072b0:	0c 9a       	mov	r10,r6
800072b2:	0e 9b       	mov	r11,r7
800072b4:	f0 1f 00 15 	mcall	80007308 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800072b8:	30 09       	mov	r9,0
800072ba:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800072bc:	fa ca fe f8 	sub	r10,sp,-264
800072c0:	fa cb fe f4 	sub	r11,sp,-268
800072c4:	49 28       	lddpc	r8,8000730c <logFromISR+0x178>
800072c6:	70 0c       	ld.w	r12,r8[0x0]
800072c8:	f0 1f 00 12 	mcall	80007310 <logFromISR+0x17c>
800072cc:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800072ce:	fe 3d fd f4 	sub	sp,-524
800072d2:	d8 32       	popm	r0-r7,pc
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	79 d4       	ld.w	r4,r12[0x74]
800072d8:	00 00       	add	r0,r0
800072da:	0d 5d       	ld.sh	sp,--r6
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	db 78       	*unknown*
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	6f 2e       	ld.w	lr,r7[0x48]
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	6e 7c       	ld.w	r12,r7[0x1c]
800072e8:	80 00       	ld.sh	r0,r0[0x0]
800072ea:	6e 78       	ld.w	r8,r7[0x1c]
800072ec:	80 00       	ld.sh	r0,r0[0x0]
800072ee:	dc e4       	*unknown*
800072f0:	80 00       	ld.sh	r0,r0[0x0]
800072f2:	70 08       	ld.w	r8,r8[0x0]
800072f4:	80 00       	ld.sh	r0,r0[0x0]
800072f6:	dc f4       	*unknown*
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	7c c4       	ld.w	r4,lr[0x30]
800072fc:	80 00       	ld.sh	r0,r0[0x0]
800072fe:	dc fc       	*unknown*
80007300:	80 00       	ld.sh	r0,r0[0x0]
80007302:	dd 04       	*unknown*
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	60 7c       	ld.w	r12,r0[0x1c]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	78 8c       	ld.w	r12,r12[0x20]
8000730c:	00 00       	add	r0,r0
8000730e:	53 c4       	stdsp	sp[0xf0],r4
80007310:	80 00       	ld.sh	r0,r0[0x0]
80007312:	63 80       	ld.w	r0,r1[0x60]

80007314 <log_init>:
		
	return str;
}

void log_init(void)
{
80007314:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007316:	30 2b       	mov	r11,2
80007318:	48 fc       	lddpc	r12,80007354 <log_init+0x40>
8000731a:	f0 1f 00 10 	mcall	80007358 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000731e:	e0 6a 36 00 	mov	r10,13824
80007322:	ea 1a 01 6e 	orh	r10,0x16e
80007326:	48 eb       	lddpc	r11,8000735c <log_init+0x48>
80007328:	fe 7c 18 00 	mov	r12,-59392
8000732c:	f0 1f 00 0d 	mcall	80007360 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007330:	30 4b       	mov	r11,4
80007332:	33 2c       	mov	r12,50
80007334:	f0 1f 00 0c 	mcall	80007364 <log_init+0x50>
80007338:	48 c8       	lddpc	r8,80007368 <log_init+0x54>
8000733a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000733c:	30 09       	mov	r9,0
8000733e:	1a d9       	st.w	--sp,r9
80007340:	1a d9       	st.w	--sp,r9
80007342:	1a d9       	st.w	--sp,r9
80007344:	30 28       	mov	r8,2
80007346:	36 4a       	mov	r10,100
80007348:	48 9b       	lddpc	r11,8000736c <log_init+0x58>
8000734a:	48 ac       	lddpc	r12,80007370 <log_init+0x5c>
8000734c:	f0 1f 00 0a 	mcall	80007374 <log_init+0x60>
80007350:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007352:	d8 02       	popm	pc
80007354:	80 00       	ld.sh	r0,r0[0x0]
80007356:	dd 10       	acall	0xd1
80007358:	80 00       	ld.sh	r0,r0[0x0]
8000735a:	53 ec       	stdsp	sp[0xf8],r12
8000735c:	80 00       	ld.sh	r0,r0[0x0]
8000735e:	dc c8       	*unknown*
80007360:	80 00       	ld.sh	r0,r0[0x0]
80007362:	5b e0       	cp.w	r0,-2
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	65 28       	ld.w	r8,r2[0x48]
80007368:	00 00       	add	r0,r0
8000736a:	53 c4       	stdsp	sp[0xf0],r4
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	dd 0c       	*unknown*
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	73 78       	ld.w	r8,r9[0x5c]
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6c 44       	ld.w	r4,r6[0x10]

80007378 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007378:	eb cd 40 f8 	pushm	r3-r7,lr
8000737c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000737e:	48 c7       	lddpc	r7,800073ac <task_log+0x34>
80007380:	30 05       	mov	r5,0
80007382:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007384:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007388:	0a 99       	mov	r9,r5
8000738a:	08 9a       	mov	r10,r4
8000738c:	1a 9b       	mov	r11,sp
8000738e:	6e 0c       	ld.w	r12,r7[0x0]
80007390:	f0 1f 00 08 	mcall	800073b0 <task_log+0x38>
80007394:	58 1c       	cp.w	r12,1
80007396:	cf 91       	brne	80007388 <task_log+0x10>
		{
			if( NULL != str)
80007398:	40 0b       	lddsp	r11,sp[0x0]
8000739a:	58 0b       	cp.w	r11,0
8000739c:	cf 60       	breq	80007388 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000739e:	06 9c       	mov	r12,r3
800073a0:	f0 1f 00 05 	mcall	800073b4 <task_log+0x3c>
				vPortFree(str);
800073a4:	40 0c       	lddsp	r12,sp[0x0]
800073a6:	f0 1f 00 05 	mcall	800073b8 <task_log+0x40>
800073aa:	ce fb       	rjmp	80007388 <task_log+0x10>
800073ac:	00 00       	add	r0,r0
800073ae:	53 c4       	stdsp	sp[0xf0],r4
800073b0:	80 00       	ld.sh	r0,r0[0x0]
800073b2:	61 c4       	ld.w	r4,r0[0x70]
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	5b 90       	cp.w	r0,-7
800073b8:	80 00       	ld.sh	r0,r0[0x0]
800073ba:	60 54       	ld.w	r4,r0[0x14]

800073bc <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800073bc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800073be:	fe 78 10 00 	mov	r8,-61440
800073c2:	30 19       	mov	r9,1
800073c4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800073c8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800073cc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800073d0:	d3 03       	ssrf	0x10
	local_start_pll0();
800073d2:	f0 1f 00 0d 	mcall	80007404 <main+0x48>
		
	INTC_init_interrupts();
800073d6:	f0 1f 00 0d 	mcall	80007408 <main+0x4c>
		
	log_init();
800073da:	f0 1f 00 0d 	mcall	8000740c <main+0x50>
	log("----start debug----");
800073de:	48 dc       	lddpc	r12,80007410 <main+0x54>
800073e0:	f0 1f 00 0d 	mcall	80007414 <main+0x58>
	
	xg_flashc_init();
800073e4:	f0 1f 00 0d 	mcall	80007418 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073e8:	f0 1f 00 0d 	mcall	8000741c <main+0x60>
		
	app_init();
800073ec:	f0 1f 00 0d 	mcall	80007420 <main+0x64>
	
	xg_rtc_init();
800073f0:	f0 1f 00 0d 	mcall	80007424 <main+0x68>
		
	xcmp_init();
800073f4:	f0 1f 00 0d 	mcall	80007428 <main+0x6c>

	local_start_timer();
800073f8:	f0 1f 00 0d 	mcall	8000742c <main+0x70>
		
	vTaskStartScheduler();
800073fc:	f0 1f 00 0d 	mcall	80007430 <main+0x74>
	return 0;
	
}
80007400:	d8 0a       	popm	pc,r12=0
80007402:	00 00       	add	r0,r0
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	52 60       	stdsp	sp[0x98],r0
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	54 f0       	stdsp	sp[0x13c],r0
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	73 14       	ld.w	r4,r9[0x44]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	dd 20       	acall	0xd2
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	70 08       	ld.w	r8,r8[0x0]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	52 f4       	stdsp	sp[0xbc],r4
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	51 c0       	stdsp	sp[0x70],r0
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	20 3c       	sub	r12,3
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	2a 00       	sub	r0,-96
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	40 dc       	lddsp	r12,sp[0x34]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	52 34       	stdsp	sp[0x8c],r4
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	6e 2c       	ld.w	r12,r7[0x8]

80007434 <free>:
80007434:	d4 01       	pushm	lr
80007436:	e0 68 0a 40 	mov	r8,2624
8000743a:	18 9b       	mov	r11,r12
8000743c:	70 0c       	ld.w	r12,r8[0x0]
8000743e:	e0 a0 1e 61 	rcall	8000b100 <_free_r>
80007442:	d8 02       	popm	pc

80007444 <malloc>:
80007444:	d4 01       	pushm	lr
80007446:	e0 68 0a 40 	mov	r8,2624
8000744a:	18 9b       	mov	r11,r12
8000744c:	70 0c       	ld.w	r12,r8[0x0]
8000744e:	c0 3c       	rcall	80007454 <_malloc_r>
80007450:	d8 02       	popm	pc
80007452:	d7 03       	nop

80007454 <_malloc_r>:
80007454:	d4 31       	pushm	r0-r7,lr
80007456:	f6 c8 ff f5 	sub	r8,r11,-11
8000745a:	18 95       	mov	r5,r12
8000745c:	10 97       	mov	r7,r8
8000745e:	e0 17 ff f8 	andl	r7,0xfff8
80007462:	59 68       	cp.w	r8,22
80007464:	f9 b7 08 10 	movls	r7,16
80007468:	16 37       	cp.w	r7,r11
8000746a:	5f 38       	srlo	r8
8000746c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007470:	c0 50       	breq	8000747a <_malloc_r+0x26>
80007472:	30 c8       	mov	r8,12
80007474:	99 38       	st.w	r12[0xc],r8
80007476:	e0 8f 01 fa 	bral	8000786a <_malloc_r+0x416>
8000747a:	fe b0 f5 a3 	rcall	80005fc0 <__malloc_lock>
8000747e:	e0 47 01 f7 	cp.w	r7,503
80007482:	e0 8b 00 1d 	brhi	800074bc <_malloc_r+0x68>
80007486:	ee 03 16 03 	lsr	r3,r7,0x3
8000748a:	e0 68 05 40 	mov	r8,1344
8000748e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007492:	70 36       	ld.w	r6,r8[0xc]
80007494:	10 36       	cp.w	r6,r8
80007496:	c0 61       	brne	800074a2 <_malloc_r+0x4e>
80007498:	ec c8 ff f8 	sub	r8,r6,-8
8000749c:	70 36       	ld.w	r6,r8[0xc]
8000749e:	10 36       	cp.w	r6,r8
800074a0:	c0 c0       	breq	800074b8 <_malloc_r+0x64>
800074a2:	6c 18       	ld.w	r8,r6[0x4]
800074a4:	e0 18 ff fc 	andl	r8,0xfffc
800074a8:	6c 3a       	ld.w	r10,r6[0xc]
800074aa:	ec 08 00 09 	add	r9,r6,r8
800074ae:	0a 9c       	mov	r12,r5
800074b0:	6c 28       	ld.w	r8,r6[0x8]
800074b2:	95 28       	st.w	r10[0x8],r8
800074b4:	91 3a       	st.w	r8[0xc],r10
800074b6:	c4 78       	rjmp	80007544 <_malloc_r+0xf0>
800074b8:	2f e3       	sub	r3,-2
800074ba:	c4 d8       	rjmp	80007554 <_malloc_r+0x100>
800074bc:	ee 03 16 09 	lsr	r3,r7,0x9
800074c0:	c0 41       	brne	800074c8 <_malloc_r+0x74>
800074c2:	ee 03 16 03 	lsr	r3,r7,0x3
800074c6:	c2 68       	rjmp	80007512 <_malloc_r+0xbe>
800074c8:	58 43       	cp.w	r3,4
800074ca:	e0 8b 00 06 	brhi	800074d6 <_malloc_r+0x82>
800074ce:	ee 03 16 06 	lsr	r3,r7,0x6
800074d2:	2c 83       	sub	r3,-56
800074d4:	c1 f8       	rjmp	80007512 <_malloc_r+0xbe>
800074d6:	59 43       	cp.w	r3,20
800074d8:	e0 8b 00 04 	brhi	800074e0 <_malloc_r+0x8c>
800074dc:	2a 53       	sub	r3,-91
800074de:	c1 a8       	rjmp	80007512 <_malloc_r+0xbe>
800074e0:	e0 43 00 54 	cp.w	r3,84
800074e4:	e0 8b 00 06 	brhi	800074f0 <_malloc_r+0x9c>
800074e8:	ee 03 16 0c 	lsr	r3,r7,0xc
800074ec:	29 23       	sub	r3,-110
800074ee:	c1 28       	rjmp	80007512 <_malloc_r+0xbe>
800074f0:	e0 43 01 54 	cp.w	r3,340
800074f4:	e0 8b 00 06 	brhi	80007500 <_malloc_r+0xac>
800074f8:	ee 03 16 0f 	lsr	r3,r7,0xf
800074fc:	28 93       	sub	r3,-119
800074fe:	c0 a8       	rjmp	80007512 <_malloc_r+0xbe>
80007500:	e0 43 05 54 	cp.w	r3,1364
80007504:	e0 88 00 04 	brls	8000750c <_malloc_r+0xb8>
80007508:	37 e3       	mov	r3,126
8000750a:	c0 48       	rjmp	80007512 <_malloc_r+0xbe>
8000750c:	ee 03 16 12 	lsr	r3,r7,0x12
80007510:	28 43       	sub	r3,-124
80007512:	e0 6a 05 40 	mov	r10,1344
80007516:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000751a:	74 36       	ld.w	r6,r10[0xc]
8000751c:	c1 98       	rjmp	8000754e <_malloc_r+0xfa>
8000751e:	6c 19       	ld.w	r9,r6[0x4]
80007520:	e0 19 ff fc 	andl	r9,0xfffc
80007524:	f2 07 01 0b 	sub	r11,r9,r7
80007528:	58 fb       	cp.w	r11,15
8000752a:	e0 8a 00 04 	brle	80007532 <_malloc_r+0xde>
8000752e:	20 13       	sub	r3,1
80007530:	c1 18       	rjmp	80007552 <_malloc_r+0xfe>
80007532:	6c 38       	ld.w	r8,r6[0xc]
80007534:	58 0b       	cp.w	r11,0
80007536:	c0 b5       	brlt	8000754c <_malloc_r+0xf8>
80007538:	6c 2a       	ld.w	r10,r6[0x8]
8000753a:	ec 09 00 09 	add	r9,r6,r9
8000753e:	0a 9c       	mov	r12,r5
80007540:	91 2a       	st.w	r8[0x8],r10
80007542:	95 38       	st.w	r10[0xc],r8
80007544:	72 18       	ld.w	r8,r9[0x4]
80007546:	a1 a8       	sbr	r8,0x0
80007548:	93 18       	st.w	r9[0x4],r8
8000754a:	cb c8       	rjmp	800076c2 <_malloc_r+0x26e>
8000754c:	10 96       	mov	r6,r8
8000754e:	14 36       	cp.w	r6,r10
80007550:	ce 71       	brne	8000751e <_malloc_r+0xca>
80007552:	2f f3       	sub	r3,-1
80007554:	e0 6a 05 40 	mov	r10,1344
80007558:	f4 cc ff f8 	sub	r12,r10,-8
8000755c:	78 26       	ld.w	r6,r12[0x8]
8000755e:	18 36       	cp.w	r6,r12
80007560:	c6 c0       	breq	80007638 <_malloc_r+0x1e4>
80007562:	6c 19       	ld.w	r9,r6[0x4]
80007564:	e0 19 ff fc 	andl	r9,0xfffc
80007568:	f2 07 01 08 	sub	r8,r9,r7
8000756c:	58 f8       	cp.w	r8,15
8000756e:	e0 89 00 8f 	brgt	8000768c <_malloc_r+0x238>
80007572:	99 3c       	st.w	r12[0xc],r12
80007574:	99 2c       	st.w	r12[0x8],r12
80007576:	58 08       	cp.w	r8,0
80007578:	c0 55       	brlt	80007582 <_malloc_r+0x12e>
8000757a:	ec 09 00 09 	add	r9,r6,r9
8000757e:	0a 9c       	mov	r12,r5
80007580:	ce 2b       	rjmp	80007544 <_malloc_r+0xf0>
80007582:	e0 49 01 ff 	cp.w	r9,511
80007586:	e0 8b 00 13 	brhi	800075ac <_malloc_r+0x158>
8000758a:	a3 99       	lsr	r9,0x3
8000758c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007590:	70 2b       	ld.w	r11,r8[0x8]
80007592:	8d 38       	st.w	r6[0xc],r8
80007594:	8d 2b       	st.w	r6[0x8],r11
80007596:	97 36       	st.w	r11[0xc],r6
80007598:	91 26       	st.w	r8[0x8],r6
8000759a:	a3 49       	asr	r9,0x2
8000759c:	74 18       	ld.w	r8,r10[0x4]
8000759e:	30 1b       	mov	r11,1
800075a0:	f6 09 09 49 	lsl	r9,r11,r9
800075a4:	f1 e9 10 09 	or	r9,r8,r9
800075a8:	95 19       	st.w	r10[0x4],r9
800075aa:	c4 78       	rjmp	80007638 <_malloc_r+0x1e4>
800075ac:	f2 0a 16 09 	lsr	r10,r9,0x9
800075b0:	58 4a       	cp.w	r10,4
800075b2:	e0 8b 00 07 	brhi	800075c0 <_malloc_r+0x16c>
800075b6:	f2 0a 16 06 	lsr	r10,r9,0x6
800075ba:	2c 8a       	sub	r10,-56
800075bc:	c2 08       	rjmp	800075fc <_malloc_r+0x1a8>
800075be:	d7 03       	nop
800075c0:	59 4a       	cp.w	r10,20
800075c2:	e0 8b 00 04 	brhi	800075ca <_malloc_r+0x176>
800075c6:	2a 5a       	sub	r10,-91
800075c8:	c1 a8       	rjmp	800075fc <_malloc_r+0x1a8>
800075ca:	e0 4a 00 54 	cp.w	r10,84
800075ce:	e0 8b 00 06 	brhi	800075da <_malloc_r+0x186>
800075d2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800075d6:	29 2a       	sub	r10,-110
800075d8:	c1 28       	rjmp	800075fc <_malloc_r+0x1a8>
800075da:	e0 4a 01 54 	cp.w	r10,340
800075de:	e0 8b 00 06 	brhi	800075ea <_malloc_r+0x196>
800075e2:	f2 0a 16 0f 	lsr	r10,r9,0xf
800075e6:	28 9a       	sub	r10,-119
800075e8:	c0 a8       	rjmp	800075fc <_malloc_r+0x1a8>
800075ea:	e0 4a 05 54 	cp.w	r10,1364
800075ee:	e0 88 00 04 	brls	800075f6 <_malloc_r+0x1a2>
800075f2:	37 ea       	mov	r10,126
800075f4:	c0 48       	rjmp	800075fc <_malloc_r+0x1a8>
800075f6:	f2 0a 16 12 	lsr	r10,r9,0x12
800075fa:	28 4a       	sub	r10,-124
800075fc:	e0 6b 05 40 	mov	r11,1344
80007600:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007604:	68 28       	ld.w	r8,r4[0x8]
80007606:	08 38       	cp.w	r8,r4
80007608:	c0 e1       	brne	80007624 <_malloc_r+0x1d0>
8000760a:	76 19       	ld.w	r9,r11[0x4]
8000760c:	a3 4a       	asr	r10,0x2
8000760e:	30 1e       	mov	lr,1
80007610:	fc 0a 09 4a 	lsl	r10,lr,r10
80007614:	f3 ea 10 0a 	or	r10,r9,r10
80007618:	10 99       	mov	r9,r8
8000761a:	97 1a       	st.w	r11[0x4],r10
8000761c:	c0 a8       	rjmp	80007630 <_malloc_r+0x1dc>
8000761e:	70 28       	ld.w	r8,r8[0x8]
80007620:	08 38       	cp.w	r8,r4
80007622:	c0 60       	breq	8000762e <_malloc_r+0x1da>
80007624:	70 1a       	ld.w	r10,r8[0x4]
80007626:	e0 1a ff fc 	andl	r10,0xfffc
8000762a:	14 39       	cp.w	r9,r10
8000762c:	cf 93       	brcs	8000761e <_malloc_r+0x1ca>
8000762e:	70 39       	ld.w	r9,r8[0xc]
80007630:	8d 39       	st.w	r6[0xc],r9
80007632:	8d 28       	st.w	r6[0x8],r8
80007634:	91 36       	st.w	r8[0xc],r6
80007636:	93 26       	st.w	r9[0x8],r6
80007638:	e6 08 14 02 	asr	r8,r3,0x2
8000763c:	30 1b       	mov	r11,1
8000763e:	e0 64 05 40 	mov	r4,1344
80007642:	f6 08 09 4b 	lsl	r11,r11,r8
80007646:	68 18       	ld.w	r8,r4[0x4]
80007648:	10 3b       	cp.w	r11,r8
8000764a:	e0 8b 00 6b 	brhi	80007720 <_malloc_r+0x2cc>
8000764e:	f7 e8 00 09 	and	r9,r11,r8
80007652:	c0 b1       	brne	80007668 <_malloc_r+0x214>
80007654:	e0 13 ff fc 	andl	r3,0xfffc
80007658:	a1 7b       	lsl	r11,0x1
8000765a:	2f c3       	sub	r3,-4
8000765c:	c0 38       	rjmp	80007662 <_malloc_r+0x20e>
8000765e:	2f c3       	sub	r3,-4
80007660:	a1 7b       	lsl	r11,0x1
80007662:	f7 e8 00 09 	and	r9,r11,r8
80007666:	cf c0       	breq	8000765e <_malloc_r+0x20a>
80007668:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000766c:	06 92       	mov	r2,r3
8000766e:	1c 91       	mov	r1,lr
80007670:	62 36       	ld.w	r6,r1[0xc]
80007672:	c2 e8       	rjmp	800076ce <_malloc_r+0x27a>
80007674:	6c 1a       	ld.w	r10,r6[0x4]
80007676:	e0 1a ff fc 	andl	r10,0xfffc
8000767a:	f4 07 01 08 	sub	r8,r10,r7
8000767e:	58 f8       	cp.w	r8,15
80007680:	e0 8a 00 15 	brle	800076aa <_malloc_r+0x256>
80007684:	6c 3a       	ld.w	r10,r6[0xc]
80007686:	6c 29       	ld.w	r9,r6[0x8]
80007688:	95 29       	st.w	r10[0x8],r9
8000768a:	93 3a       	st.w	r9[0xc],r10
8000768c:	0e 99       	mov	r9,r7
8000768e:	ec 07 00 07 	add	r7,r6,r7
80007692:	a1 a9       	sbr	r9,0x0
80007694:	99 37       	st.w	r12[0xc],r7
80007696:	99 27       	st.w	r12[0x8],r7
80007698:	8d 19       	st.w	r6[0x4],r9
8000769a:	ee 08 09 08 	st.w	r7[r8],r8
8000769e:	8f 2c       	st.w	r7[0x8],r12
800076a0:	8f 3c       	st.w	r7[0xc],r12
800076a2:	a1 a8       	sbr	r8,0x0
800076a4:	0a 9c       	mov	r12,r5
800076a6:	8f 18       	st.w	r7[0x4],r8
800076a8:	c0 d8       	rjmp	800076c2 <_malloc_r+0x26e>
800076aa:	6c 39       	ld.w	r9,r6[0xc]
800076ac:	58 08       	cp.w	r8,0
800076ae:	c0 f5       	brlt	800076cc <_malloc_r+0x278>
800076b0:	ec 0a 00 0a 	add	r10,r6,r10
800076b4:	74 18       	ld.w	r8,r10[0x4]
800076b6:	a1 a8       	sbr	r8,0x0
800076b8:	0a 9c       	mov	r12,r5
800076ba:	95 18       	st.w	r10[0x4],r8
800076bc:	6c 28       	ld.w	r8,r6[0x8]
800076be:	93 28       	st.w	r9[0x8],r8
800076c0:	91 39       	st.w	r8[0xc],r9
800076c2:	fe b0 f4 85 	rcall	80005fcc <__malloc_unlock>
800076c6:	ec cc ff f8 	sub	r12,r6,-8
800076ca:	d8 32       	popm	r0-r7,pc
800076cc:	12 96       	mov	r6,r9
800076ce:	02 36       	cp.w	r6,r1
800076d0:	cd 21       	brne	80007674 <_malloc_r+0x220>
800076d2:	2f f2       	sub	r2,-1
800076d4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800076d8:	c0 30       	breq	800076de <_malloc_r+0x28a>
800076da:	2f 81       	sub	r1,-8
800076dc:	cc ab       	rjmp	80007670 <_malloc_r+0x21c>
800076de:	1c 98       	mov	r8,lr
800076e0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800076e4:	c0 81       	brne	800076f4 <_malloc_r+0x2a0>
800076e6:	68 19       	ld.w	r9,r4[0x4]
800076e8:	f6 08 11 ff 	rsub	r8,r11,-1
800076ec:	f3 e8 00 08 	and	r8,r9,r8
800076f0:	89 18       	st.w	r4[0x4],r8
800076f2:	c0 78       	rjmp	80007700 <_malloc_r+0x2ac>
800076f4:	f0 c9 00 08 	sub	r9,r8,8
800076f8:	20 13       	sub	r3,1
800076fa:	70 08       	ld.w	r8,r8[0x0]
800076fc:	12 38       	cp.w	r8,r9
800076fe:	cf 10       	breq	800076e0 <_malloc_r+0x28c>
80007700:	a1 7b       	lsl	r11,0x1
80007702:	68 18       	ld.w	r8,r4[0x4]
80007704:	10 3b       	cp.w	r11,r8
80007706:	e0 8b 00 0d 	brhi	80007720 <_malloc_r+0x2cc>
8000770a:	58 0b       	cp.w	r11,0
8000770c:	c0 a0       	breq	80007720 <_malloc_r+0x2cc>
8000770e:	04 93       	mov	r3,r2
80007710:	c0 38       	rjmp	80007716 <_malloc_r+0x2c2>
80007712:	2f c3       	sub	r3,-4
80007714:	a1 7b       	lsl	r11,0x1
80007716:	f7 e8 00 09 	and	r9,r11,r8
8000771a:	ca 71       	brne	80007668 <_malloc_r+0x214>
8000771c:	cf bb       	rjmp	80007712 <_malloc_r+0x2be>
8000771e:	d7 03       	nop
80007720:	68 23       	ld.w	r3,r4[0x8]
80007722:	66 12       	ld.w	r2,r3[0x4]
80007724:	e0 12 ff fc 	andl	r2,0xfffc
80007728:	0e 32       	cp.w	r2,r7
8000772a:	5f 39       	srlo	r9
8000772c:	e4 07 01 08 	sub	r8,r2,r7
80007730:	58 f8       	cp.w	r8,15
80007732:	5f aa       	srle	r10
80007734:	f5 e9 10 09 	or	r9,r10,r9
80007738:	e0 80 00 9a 	breq	8000786c <_malloc_r+0x418>
8000773c:	e0 68 0d 68 	mov	r8,3432
80007740:	70 01       	ld.w	r1,r8[0x0]
80007742:	e0 68 09 4c 	mov	r8,2380
80007746:	2f 01       	sub	r1,-16
80007748:	70 08       	ld.w	r8,r8[0x0]
8000774a:	0e 01       	add	r1,r7
8000774c:	5b f8       	cp.w	r8,-1
8000774e:	c0 40       	breq	80007756 <_malloc_r+0x302>
80007750:	28 11       	sub	r1,-127
80007752:	e0 11 ff 80 	andl	r1,0xff80
80007756:	02 9b       	mov	r11,r1
80007758:	0a 9c       	mov	r12,r5
8000775a:	e0 a0 02 a5 	rcall	80007ca4 <_sbrk_r>
8000775e:	18 96       	mov	r6,r12
80007760:	5b fc       	cp.w	r12,-1
80007762:	c7 50       	breq	8000784c <_malloc_r+0x3f8>
80007764:	e6 02 00 08 	add	r8,r3,r2
80007768:	10 3c       	cp.w	r12,r8
8000776a:	c0 32       	brcc	80007770 <_malloc_r+0x31c>
8000776c:	08 33       	cp.w	r3,r4
8000776e:	c6 f1       	brne	8000784c <_malloc_r+0x3f8>
80007770:	e0 6a 0d 6c 	mov	r10,3436
80007774:	74 09       	ld.w	r9,r10[0x0]
80007776:	e2 09 00 09 	add	r9,r1,r9
8000777a:	95 09       	st.w	r10[0x0],r9
8000777c:	10 36       	cp.w	r6,r8
8000777e:	c0 a1       	brne	80007792 <_malloc_r+0x33e>
80007780:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007784:	c0 71       	brne	80007792 <_malloc_r+0x33e>
80007786:	e2 02 00 02 	add	r2,r1,r2
8000778a:	68 28       	ld.w	r8,r4[0x8]
8000778c:	a1 a2       	sbr	r2,0x0
8000778e:	91 12       	st.w	r8[0x4],r2
80007790:	c4 f8       	rjmp	8000782e <_malloc_r+0x3da>
80007792:	e0 6a 09 4c 	mov	r10,2380
80007796:	74 0b       	ld.w	r11,r10[0x0]
80007798:	5b fb       	cp.w	r11,-1
8000779a:	c0 31       	brne	800077a0 <_malloc_r+0x34c>
8000779c:	95 06       	st.w	r10[0x0],r6
8000779e:	c0 78       	rjmp	800077ac <_malloc_r+0x358>
800077a0:	ec 09 00 09 	add	r9,r6,r9
800077a4:	e0 6a 0d 6c 	mov	r10,3436
800077a8:	10 19       	sub	r9,r8
800077aa:	95 09       	st.w	r10[0x0],r9
800077ac:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800077b0:	f0 09 11 08 	rsub	r9,r8,8
800077b4:	58 08       	cp.w	r8,0
800077b6:	f2 08 17 10 	movne	r8,r9
800077ba:	ed d8 e1 06 	addne	r6,r6,r8
800077be:	28 08       	sub	r8,-128
800077c0:	ec 01 00 01 	add	r1,r6,r1
800077c4:	0a 9c       	mov	r12,r5
800077c6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800077ca:	f0 01 01 01 	sub	r1,r8,r1
800077ce:	02 9b       	mov	r11,r1
800077d0:	e0 a0 02 6a 	rcall	80007ca4 <_sbrk_r>
800077d4:	e0 68 0d 6c 	mov	r8,3436
800077d8:	5b fc       	cp.w	r12,-1
800077da:	ec 0c 17 00 	moveq	r12,r6
800077de:	f9 b1 00 00 	moveq	r1,0
800077e2:	70 09       	ld.w	r9,r8[0x0]
800077e4:	0c 1c       	sub	r12,r6
800077e6:	89 26       	st.w	r4[0x8],r6
800077e8:	02 0c       	add	r12,r1
800077ea:	12 01       	add	r1,r9
800077ec:	a1 ac       	sbr	r12,0x0
800077ee:	91 01       	st.w	r8[0x0],r1
800077f0:	8d 1c       	st.w	r6[0x4],r12
800077f2:	08 33       	cp.w	r3,r4
800077f4:	c1 d0       	breq	8000782e <_malloc_r+0x3da>
800077f6:	58 f2       	cp.w	r2,15
800077f8:	e0 8b 00 05 	brhi	80007802 <_malloc_r+0x3ae>
800077fc:	30 18       	mov	r8,1
800077fe:	8d 18       	st.w	r6[0x4],r8
80007800:	c2 68       	rjmp	8000784c <_malloc_r+0x3f8>
80007802:	30 59       	mov	r9,5
80007804:	20 c2       	sub	r2,12
80007806:	e0 12 ff f8 	andl	r2,0xfff8
8000780a:	e6 02 00 08 	add	r8,r3,r2
8000780e:	91 29       	st.w	r8[0x8],r9
80007810:	91 19       	st.w	r8[0x4],r9
80007812:	66 18       	ld.w	r8,r3[0x4]
80007814:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007818:	e5 e8 10 08 	or	r8,r2,r8
8000781c:	87 18       	st.w	r3[0x4],r8
8000781e:	58 f2       	cp.w	r2,15
80007820:	e0 88 00 07 	brls	8000782e <_malloc_r+0x3da>
80007824:	e6 cb ff f8 	sub	r11,r3,-8
80007828:	0a 9c       	mov	r12,r5
8000782a:	e0 a0 1c 6b 	rcall	8000b100 <_free_r>
8000782e:	e0 69 0d 64 	mov	r9,3428
80007832:	72 0a       	ld.w	r10,r9[0x0]
80007834:	e0 68 0d 6c 	mov	r8,3436
80007838:	70 08       	ld.w	r8,r8[0x0]
8000783a:	14 38       	cp.w	r8,r10
8000783c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007840:	e0 69 0d 60 	mov	r9,3424
80007844:	72 0a       	ld.w	r10,r9[0x0]
80007846:	14 38       	cp.w	r8,r10
80007848:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000784c:	68 28       	ld.w	r8,r4[0x8]
8000784e:	70 18       	ld.w	r8,r8[0x4]
80007850:	e0 18 ff fc 	andl	r8,0xfffc
80007854:	0e 38       	cp.w	r8,r7
80007856:	5f 39       	srlo	r9
80007858:	0e 18       	sub	r8,r7
8000785a:	58 f8       	cp.w	r8,15
8000785c:	5f aa       	srle	r10
8000785e:	f5 e9 10 09 	or	r9,r10,r9
80007862:	c0 50       	breq	8000786c <_malloc_r+0x418>
80007864:	0a 9c       	mov	r12,r5
80007866:	fe b0 f3 b3 	rcall	80005fcc <__malloc_unlock>
8000786a:	d8 3a       	popm	r0-r7,pc,r12=0
8000786c:	68 26       	ld.w	r6,r4[0x8]
8000786e:	a1 a8       	sbr	r8,0x0
80007870:	0e 99       	mov	r9,r7
80007872:	a1 a9       	sbr	r9,0x0
80007874:	8d 19       	st.w	r6[0x4],r9
80007876:	ec 07 00 07 	add	r7,r6,r7
8000787a:	0a 9c       	mov	r12,r5
8000787c:	89 27       	st.w	r4[0x8],r7
8000787e:	8f 18       	st.w	r7[0x4],r8
80007880:	fe b0 f3 a6 	rcall	80005fcc <__malloc_unlock>
80007884:	ec cc ff f8 	sub	r12,r6,-8
80007888:	d8 32       	popm	r0-r7,pc
8000788a:	d7 03       	nop

8000788c <memcpy>:
8000788c:	58 8a       	cp.w	r10,8
8000788e:	c2 f5       	brlt	800078ec <memcpy+0x60>
80007890:	f9 eb 10 09 	or	r9,r12,r11
80007894:	e2 19 00 03 	andl	r9,0x3,COH
80007898:	e0 81 00 97 	brne	800079c6 <memcpy+0x13a>
8000789c:	e0 4a 00 20 	cp.w	r10,32
800078a0:	c3 b4       	brge	80007916 <memcpy+0x8a>
800078a2:	f4 08 14 02 	asr	r8,r10,0x2
800078a6:	f0 09 11 08 	rsub	r9,r8,8
800078aa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800078ae:	76 69       	ld.w	r9,r11[0x18]
800078b0:	99 69       	st.w	r12[0x18],r9
800078b2:	76 59       	ld.w	r9,r11[0x14]
800078b4:	99 59       	st.w	r12[0x14],r9
800078b6:	76 49       	ld.w	r9,r11[0x10]
800078b8:	99 49       	st.w	r12[0x10],r9
800078ba:	76 39       	ld.w	r9,r11[0xc]
800078bc:	99 39       	st.w	r12[0xc],r9
800078be:	76 29       	ld.w	r9,r11[0x8]
800078c0:	99 29       	st.w	r12[0x8],r9
800078c2:	76 19       	ld.w	r9,r11[0x4]
800078c4:	99 19       	st.w	r12[0x4],r9
800078c6:	76 09       	ld.w	r9,r11[0x0]
800078c8:	99 09       	st.w	r12[0x0],r9
800078ca:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800078ce:	f8 08 00 28 	add	r8,r12,r8<<0x2
800078d2:	e0 1a 00 03 	andl	r10,0x3
800078d6:	f4 0a 11 04 	rsub	r10,r10,4
800078da:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078de:	17 a9       	ld.ub	r9,r11[0x2]
800078e0:	b0 a9       	st.b	r8[0x2],r9
800078e2:	17 99       	ld.ub	r9,r11[0x1]
800078e4:	b0 99       	st.b	r8[0x1],r9
800078e6:	17 89       	ld.ub	r9,r11[0x0]
800078e8:	b0 89       	st.b	r8[0x0],r9
800078ea:	5e fc       	retal	r12
800078ec:	f4 0a 11 09 	rsub	r10,r10,9
800078f0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078f4:	17 f9       	ld.ub	r9,r11[0x7]
800078f6:	b8 f9       	st.b	r12[0x7],r9
800078f8:	17 e9       	ld.ub	r9,r11[0x6]
800078fa:	b8 e9       	st.b	r12[0x6],r9
800078fc:	17 d9       	ld.ub	r9,r11[0x5]
800078fe:	b8 d9       	st.b	r12[0x5],r9
80007900:	17 c9       	ld.ub	r9,r11[0x4]
80007902:	b8 c9       	st.b	r12[0x4],r9
80007904:	17 b9       	ld.ub	r9,r11[0x3]
80007906:	b8 b9       	st.b	r12[0x3],r9
80007908:	17 a9       	ld.ub	r9,r11[0x2]
8000790a:	b8 a9       	st.b	r12[0x2],r9
8000790c:	17 99       	ld.ub	r9,r11[0x1]
8000790e:	b8 99       	st.b	r12[0x1],r9
80007910:	17 89       	ld.ub	r9,r11[0x0]
80007912:	b8 89       	st.b	r12[0x0],r9
80007914:	5e fc       	retal	r12
80007916:	eb cd 40 c0 	pushm	r6-r7,lr
8000791a:	18 99       	mov	r9,r12
8000791c:	22 0a       	sub	r10,32
8000791e:	b7 07       	ld.d	r6,r11++
80007920:	b3 26       	st.d	r9++,r6
80007922:	b7 07       	ld.d	r6,r11++
80007924:	b3 26       	st.d	r9++,r6
80007926:	b7 07       	ld.d	r6,r11++
80007928:	b3 26       	st.d	r9++,r6
8000792a:	b7 07       	ld.d	r6,r11++
8000792c:	b3 26       	st.d	r9++,r6
8000792e:	22 0a       	sub	r10,32
80007930:	cf 74       	brge	8000791e <memcpy+0x92>
80007932:	2f 0a       	sub	r10,-16
80007934:	c0 65       	brlt	80007940 <memcpy+0xb4>
80007936:	b7 07       	ld.d	r6,r11++
80007938:	b3 26       	st.d	r9++,r6
8000793a:	b7 07       	ld.d	r6,r11++
8000793c:	b3 26       	st.d	r9++,r6
8000793e:	21 0a       	sub	r10,16
80007940:	5c 3a       	neg	r10
80007942:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007946:	d7 03       	nop
80007948:	d7 03       	nop
8000794a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000794e:	f3 66 00 0e 	st.b	r9[14],r6
80007952:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007956:	f3 66 00 0d 	st.b	r9[13],r6
8000795a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000795e:	f3 66 00 0c 	st.b	r9[12],r6
80007962:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007966:	f3 66 00 0b 	st.b	r9[11],r6
8000796a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000796e:	f3 66 00 0a 	st.b	r9[10],r6
80007972:	f7 36 00 09 	ld.ub	r6,r11[9]
80007976:	f3 66 00 09 	st.b	r9[9],r6
8000797a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000797e:	f3 66 00 08 	st.b	r9[8],r6
80007982:	f7 36 00 07 	ld.ub	r6,r11[7]
80007986:	f3 66 00 07 	st.b	r9[7],r6
8000798a:	f7 36 00 06 	ld.ub	r6,r11[6]
8000798e:	f3 66 00 06 	st.b	r9[6],r6
80007992:	f7 36 00 05 	ld.ub	r6,r11[5]
80007996:	f3 66 00 05 	st.b	r9[5],r6
8000799a:	f7 36 00 04 	ld.ub	r6,r11[4]
8000799e:	f3 66 00 04 	st.b	r9[4],r6
800079a2:	f7 36 00 03 	ld.ub	r6,r11[3]
800079a6:	f3 66 00 03 	st.b	r9[3],r6
800079aa:	f7 36 00 02 	ld.ub	r6,r11[2]
800079ae:	f3 66 00 02 	st.b	r9[2],r6
800079b2:	f7 36 00 01 	ld.ub	r6,r11[1]
800079b6:	f3 66 00 01 	st.b	r9[1],r6
800079ba:	f7 36 00 00 	ld.ub	r6,r11[0]
800079be:	f3 66 00 00 	st.b	r9[0],r6
800079c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800079c6:	20 1a       	sub	r10,1
800079c8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800079cc:	f8 0a 0b 09 	st.b	r12[r10],r9
800079d0:	cf b1       	brne	800079c6 <memcpy+0x13a>
800079d2:	5e fc       	retal	r12

800079d4 <memset>:
800079d4:	18 98       	mov	r8,r12
800079d6:	c0 38       	rjmp	800079dc <memset+0x8>
800079d8:	10 cb       	st.b	r8++,r11
800079da:	20 1a       	sub	r10,1
800079dc:	58 0a       	cp.w	r10,0
800079de:	cf d1       	brne	800079d8 <memset+0x4>
800079e0:	5e fc       	retal	r12
800079e2:	d7 03       	nop

800079e4 <_realloc_r>:
800079e4:	d4 31       	pushm	r0-r7,lr
800079e6:	20 1d       	sub	sp,4
800079e8:	16 94       	mov	r4,r11
800079ea:	18 92       	mov	r2,r12
800079ec:	14 9b       	mov	r11,r10
800079ee:	58 04       	cp.w	r4,0
800079f0:	c0 51       	brne	800079fa <_realloc_r+0x16>
800079f2:	fe b0 fd 31 	rcall	80007454 <_malloc_r>
800079f6:	18 95       	mov	r5,r12
800079f8:	c5 39       	rjmp	80007c9e <_realloc_r+0x2ba>
800079fa:	50 0a       	stdsp	sp[0x0],r10
800079fc:	fe b0 f2 e2 	rcall	80005fc0 <__malloc_lock>
80007a00:	40 0b       	lddsp	r11,sp[0x0]
80007a02:	f6 c8 ff f5 	sub	r8,r11,-11
80007a06:	e8 c1 00 08 	sub	r1,r4,8
80007a0a:	10 96       	mov	r6,r8
80007a0c:	62 1c       	ld.w	r12,r1[0x4]
80007a0e:	e0 16 ff f8 	andl	r6,0xfff8
80007a12:	59 68       	cp.w	r8,22
80007a14:	f9 b6 08 10 	movls	r6,16
80007a18:	16 36       	cp.w	r6,r11
80007a1a:	5f 38       	srlo	r8
80007a1c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007a20:	c0 50       	breq	80007a2a <_realloc_r+0x46>
80007a22:	30 c8       	mov	r8,12
80007a24:	30 05       	mov	r5,0
80007a26:	85 38       	st.w	r2[0xc],r8
80007a28:	c3 b9       	rjmp	80007c9e <_realloc_r+0x2ba>
80007a2a:	18 90       	mov	r0,r12
80007a2c:	e0 10 ff fc 	andl	r0,0xfffc
80007a30:	0c 30       	cp.w	r0,r6
80007a32:	e0 84 01 0b 	brge	80007c48 <_realloc_r+0x264>
80007a36:	e0 68 05 40 	mov	r8,1344
80007a3a:	e2 00 00 09 	add	r9,r1,r0
80007a3e:	70 25       	ld.w	r5,r8[0x8]
80007a40:	0a 39       	cp.w	r9,r5
80007a42:	c0 90       	breq	80007a54 <_realloc_r+0x70>
80007a44:	72 1a       	ld.w	r10,r9[0x4]
80007a46:	a1 ca       	cbr	r10,0x0
80007a48:	f2 0a 00 0a 	add	r10,r9,r10
80007a4c:	74 1a       	ld.w	r10,r10[0x4]
80007a4e:	ed ba 00 00 	bld	r10,0x0
80007a52:	c2 20       	breq	80007a96 <_realloc_r+0xb2>
80007a54:	72 1a       	ld.w	r10,r9[0x4]
80007a56:	e0 1a ff fc 	andl	r10,0xfffc
80007a5a:	f4 00 00 03 	add	r3,r10,r0
80007a5e:	0a 39       	cp.w	r9,r5
80007a60:	c1 31       	brne	80007a86 <_realloc_r+0xa2>
80007a62:	ec c7 ff f0 	sub	r7,r6,-16
80007a66:	0e 33       	cp.w	r3,r7
80007a68:	c1 95       	brlt	80007a9a <_realloc_r+0xb6>
80007a6a:	e2 06 00 09 	add	r9,r1,r6
80007a6e:	0c 13       	sub	r3,r6
80007a70:	a1 a3       	sbr	r3,0x0
80007a72:	93 13       	st.w	r9[0x4],r3
80007a74:	91 29       	st.w	r8[0x8],r9
80007a76:	04 9c       	mov	r12,r2
80007a78:	62 18       	ld.w	r8,r1[0x4]
80007a7a:	08 95       	mov	r5,r4
80007a7c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a80:	10 46       	or	r6,r8
80007a82:	83 16       	st.w	r1[0x4],r6
80007a84:	c0 b9       	rjmp	80007c9a <_realloc_r+0x2b6>
80007a86:	0c 33       	cp.w	r3,r6
80007a88:	c0 95       	brlt	80007a9a <_realloc_r+0xb6>
80007a8a:	72 28       	ld.w	r8,r9[0x8]
80007a8c:	02 97       	mov	r7,r1
80007a8e:	72 39       	ld.w	r9,r9[0xc]
80007a90:	93 28       	st.w	r9[0x8],r8
80007a92:	91 39       	st.w	r8[0xc],r9
80007a94:	cd c8       	rjmp	80007c4c <_realloc_r+0x268>
80007a96:	30 0a       	mov	r10,0
80007a98:	14 99       	mov	r9,r10
80007a9a:	ed bc 00 00 	bld	r12,0x0
80007a9e:	e0 80 00 95 	breq	80007bc8 <_realloc_r+0x1e4>
80007aa2:	62 07       	ld.w	r7,r1[0x0]
80007aa4:	e2 07 01 07 	sub	r7,r1,r7
80007aa8:	6e 1c       	ld.w	r12,r7[0x4]
80007aaa:	e0 1c ff fc 	andl	r12,0xfffc
80007aae:	58 09       	cp.w	r9,0
80007ab0:	c5 60       	breq	80007b5c <_realloc_r+0x178>
80007ab2:	f8 00 00 03 	add	r3,r12,r0
80007ab6:	0a 39       	cp.w	r9,r5
80007ab8:	c4 81       	brne	80007b48 <_realloc_r+0x164>
80007aba:	14 03       	add	r3,r10
80007abc:	ec c9 ff f0 	sub	r9,r6,-16
80007ac0:	12 33       	cp.w	r3,r9
80007ac2:	c4 d5       	brlt	80007b5c <_realloc_r+0x178>
80007ac4:	6e 3a       	ld.w	r10,r7[0xc]
80007ac6:	6e 29       	ld.w	r9,r7[0x8]
80007ac8:	95 29       	st.w	r10[0x8],r9
80007aca:	93 3a       	st.w	r9[0xc],r10
80007acc:	ee c5 ff f8 	sub	r5,r7,-8
80007ad0:	e0 ca 00 04 	sub	r10,r0,4
80007ad4:	e0 4a 00 24 	cp.w	r10,36
80007ad8:	e0 8b 00 25 	brhi	80007b22 <_realloc_r+0x13e>
80007adc:	0a 99       	mov	r9,r5
80007ade:	59 3a       	cp.w	r10,19
80007ae0:	e0 88 00 1a 	brls	80007b14 <_realloc_r+0x130>
80007ae4:	09 09       	ld.w	r9,r4++
80007ae6:	8b 09       	st.w	r5[0x0],r9
80007ae8:	09 09       	ld.w	r9,r4++
80007aea:	8f 39       	st.w	r7[0xc],r9
80007aec:	ee c9 ff f0 	sub	r9,r7,-16
80007af0:	59 ba       	cp.w	r10,27
80007af2:	e0 88 00 11 	brls	80007b14 <_realloc_r+0x130>
80007af6:	09 0b       	ld.w	r11,r4++
80007af8:	93 0b       	st.w	r9[0x0],r11
80007afa:	09 09       	ld.w	r9,r4++
80007afc:	8f 59       	st.w	r7[0x14],r9
80007afe:	ee c9 ff e8 	sub	r9,r7,-24
80007b02:	e0 4a 00 24 	cp.w	r10,36
80007b06:	c0 71       	brne	80007b14 <_realloc_r+0x130>
80007b08:	09 0a       	ld.w	r10,r4++
80007b0a:	93 0a       	st.w	r9[0x0],r10
80007b0c:	ee c9 ff e0 	sub	r9,r7,-32
80007b10:	09 0a       	ld.w	r10,r4++
80007b12:	8f 7a       	st.w	r7[0x1c],r10
80007b14:	09 0a       	ld.w	r10,r4++
80007b16:	12 aa       	st.w	r9++,r10
80007b18:	68 0a       	ld.w	r10,r4[0x0]
80007b1a:	93 0a       	st.w	r9[0x0],r10
80007b1c:	68 1a       	ld.w	r10,r4[0x4]
80007b1e:	93 1a       	st.w	r9[0x4],r10
80007b20:	c0 78       	rjmp	80007b2e <_realloc_r+0x14a>
80007b22:	50 08       	stdsp	sp[0x0],r8
80007b24:	08 9b       	mov	r11,r4
80007b26:	0a 9c       	mov	r12,r5
80007b28:	e0 a0 1d 8f 	rcall	8000b646 <memmove>
80007b2c:	40 08       	lddsp	r8,sp[0x0]
80007b2e:	ee 06 00 09 	add	r9,r7,r6
80007b32:	0c 13       	sub	r3,r6
80007b34:	a1 a3       	sbr	r3,0x0
80007b36:	93 13       	st.w	r9[0x4],r3
80007b38:	91 29       	st.w	r8[0x8],r9
80007b3a:	04 9c       	mov	r12,r2
80007b3c:	6e 18       	ld.w	r8,r7[0x4]
80007b3e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b42:	10 46       	or	r6,r8
80007b44:	8f 16       	st.w	r7[0x4],r6
80007b46:	ca a8       	rjmp	80007c9a <_realloc_r+0x2b6>
80007b48:	14 03       	add	r3,r10
80007b4a:	0c 33       	cp.w	r3,r6
80007b4c:	c0 85       	brlt	80007b5c <_realloc_r+0x178>
80007b4e:	72 28       	ld.w	r8,r9[0x8]
80007b50:	72 39       	ld.w	r9,r9[0xc]
80007b52:	93 28       	st.w	r9[0x8],r8
80007b54:	91 39       	st.w	r8[0xc],r9
80007b56:	6e 28       	ld.w	r8,r7[0x8]
80007b58:	6e 39       	ld.w	r9,r7[0xc]
80007b5a:	c0 78       	rjmp	80007b68 <_realloc_r+0x184>
80007b5c:	f8 00 00 03 	add	r3,r12,r0
80007b60:	0c 33       	cp.w	r3,r6
80007b62:	c3 35       	brlt	80007bc8 <_realloc_r+0x1e4>
80007b64:	6e 39       	ld.w	r9,r7[0xc]
80007b66:	6e 28       	ld.w	r8,r7[0x8]
80007b68:	93 28       	st.w	r9[0x8],r8
80007b6a:	91 39       	st.w	r8[0xc],r9
80007b6c:	e0 ca 00 04 	sub	r10,r0,4
80007b70:	ee cc ff f8 	sub	r12,r7,-8
80007b74:	e0 4a 00 24 	cp.w	r10,36
80007b78:	e0 8b 00 24 	brhi	80007bc0 <_realloc_r+0x1dc>
80007b7c:	59 3a       	cp.w	r10,19
80007b7e:	e0 88 00 1a 	brls	80007bb2 <_realloc_r+0x1ce>
80007b82:	09 08       	ld.w	r8,r4++
80007b84:	99 08       	st.w	r12[0x0],r8
80007b86:	09 08       	ld.w	r8,r4++
80007b88:	8f 38       	st.w	r7[0xc],r8
80007b8a:	ee cc ff f0 	sub	r12,r7,-16
80007b8e:	59 ba       	cp.w	r10,27
80007b90:	e0 88 00 11 	brls	80007bb2 <_realloc_r+0x1ce>
80007b94:	09 08       	ld.w	r8,r4++
80007b96:	99 08       	st.w	r12[0x0],r8
80007b98:	09 08       	ld.w	r8,r4++
80007b9a:	8f 58       	st.w	r7[0x14],r8
80007b9c:	ee cc ff e8 	sub	r12,r7,-24
80007ba0:	e0 4a 00 24 	cp.w	r10,36
80007ba4:	c0 71       	brne	80007bb2 <_realloc_r+0x1ce>
80007ba6:	09 08       	ld.w	r8,r4++
80007ba8:	99 08       	st.w	r12[0x0],r8
80007baa:	ee cc ff e0 	sub	r12,r7,-32
80007bae:	09 08       	ld.w	r8,r4++
80007bb0:	8f 78       	st.w	r7[0x1c],r8
80007bb2:	09 08       	ld.w	r8,r4++
80007bb4:	18 a8       	st.w	r12++,r8
80007bb6:	68 08       	ld.w	r8,r4[0x0]
80007bb8:	99 08       	st.w	r12[0x0],r8
80007bba:	68 18       	ld.w	r8,r4[0x4]
80007bbc:	99 18       	st.w	r12[0x4],r8
80007bbe:	c4 78       	rjmp	80007c4c <_realloc_r+0x268>
80007bc0:	08 9b       	mov	r11,r4
80007bc2:	e0 a0 1d 42 	rcall	8000b646 <memmove>
80007bc6:	c4 38       	rjmp	80007c4c <_realloc_r+0x268>
80007bc8:	04 9c       	mov	r12,r2
80007bca:	fe b0 fc 45 	rcall	80007454 <_malloc_r>
80007bce:	18 95       	mov	r5,r12
80007bd0:	c3 a0       	breq	80007c44 <_realloc_r+0x260>
80007bd2:	62 18       	ld.w	r8,r1[0x4]
80007bd4:	f8 c9 00 08 	sub	r9,r12,8
80007bd8:	a1 c8       	cbr	r8,0x0
80007bda:	e2 08 00 08 	add	r8,r1,r8
80007bde:	10 39       	cp.w	r9,r8
80007be0:	c0 71       	brne	80007bee <_realloc_r+0x20a>
80007be2:	72 13       	ld.w	r3,r9[0x4]
80007be4:	02 97       	mov	r7,r1
80007be6:	e0 13 ff fc 	andl	r3,0xfffc
80007bea:	00 03       	add	r3,r0
80007bec:	c3 08       	rjmp	80007c4c <_realloc_r+0x268>
80007bee:	e0 ca 00 04 	sub	r10,r0,4
80007bf2:	e0 4a 00 24 	cp.w	r10,36
80007bf6:	e0 8b 00 20 	brhi	80007c36 <_realloc_r+0x252>
80007bfa:	08 99       	mov	r9,r4
80007bfc:	18 98       	mov	r8,r12
80007bfe:	59 3a       	cp.w	r10,19
80007c00:	e0 88 00 14 	brls	80007c28 <_realloc_r+0x244>
80007c04:	13 0b       	ld.w	r11,r9++
80007c06:	10 ab       	st.w	r8++,r11
80007c08:	13 0b       	ld.w	r11,r9++
80007c0a:	10 ab       	st.w	r8++,r11
80007c0c:	59 ba       	cp.w	r10,27
80007c0e:	e0 88 00 0d 	brls	80007c28 <_realloc_r+0x244>
80007c12:	13 0b       	ld.w	r11,r9++
80007c14:	10 ab       	st.w	r8++,r11
80007c16:	13 0b       	ld.w	r11,r9++
80007c18:	10 ab       	st.w	r8++,r11
80007c1a:	e0 4a 00 24 	cp.w	r10,36
80007c1e:	c0 51       	brne	80007c28 <_realloc_r+0x244>
80007c20:	13 0a       	ld.w	r10,r9++
80007c22:	10 aa       	st.w	r8++,r10
80007c24:	13 0a       	ld.w	r10,r9++
80007c26:	10 aa       	st.w	r8++,r10
80007c28:	13 0a       	ld.w	r10,r9++
80007c2a:	10 aa       	st.w	r8++,r10
80007c2c:	72 0a       	ld.w	r10,r9[0x0]
80007c2e:	91 0a       	st.w	r8[0x0],r10
80007c30:	72 19       	ld.w	r9,r9[0x4]
80007c32:	91 19       	st.w	r8[0x4],r9
80007c34:	c0 48       	rjmp	80007c3c <_realloc_r+0x258>
80007c36:	08 9b       	mov	r11,r4
80007c38:	e0 a0 1d 07 	rcall	8000b646 <memmove>
80007c3c:	08 9b       	mov	r11,r4
80007c3e:	04 9c       	mov	r12,r2
80007c40:	e0 a0 1a 60 	rcall	8000b100 <_free_r>
80007c44:	04 9c       	mov	r12,r2
80007c46:	c2 a8       	rjmp	80007c9a <_realloc_r+0x2b6>
80007c48:	00 93       	mov	r3,r0
80007c4a:	02 97       	mov	r7,r1
80007c4c:	e6 06 01 09 	sub	r9,r3,r6
80007c50:	6e 18       	ld.w	r8,r7[0x4]
80007c52:	58 f9       	cp.w	r9,15
80007c54:	e0 88 00 16 	brls	80007c80 <_realloc_r+0x29c>
80007c58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c5c:	ed e8 10 08 	or	r8,r6,r8
80007c60:	8f 18       	st.w	r7[0x4],r8
80007c62:	12 98       	mov	r8,r9
80007c64:	a1 a8       	sbr	r8,0x0
80007c66:	ee 06 00 0b 	add	r11,r7,r6
80007c6a:	f6 09 00 09 	add	r9,r11,r9
80007c6e:	97 18       	st.w	r11[0x4],r8
80007c70:	72 18       	ld.w	r8,r9[0x4]
80007c72:	a1 a8       	sbr	r8,0x0
80007c74:	2f 8b       	sub	r11,-8
80007c76:	93 18       	st.w	r9[0x4],r8
80007c78:	04 9c       	mov	r12,r2
80007c7a:	e0 a0 1a 43 	rcall	8000b100 <_free_r>
80007c7e:	c0 b8       	rjmp	80007c94 <_realloc_r+0x2b0>
80007c80:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c84:	e7 e8 10 08 	or	r8,r3,r8
80007c88:	8f 18       	st.w	r7[0x4],r8
80007c8a:	ee 03 00 03 	add	r3,r7,r3
80007c8e:	66 18       	ld.w	r8,r3[0x4]
80007c90:	a1 a8       	sbr	r8,0x0
80007c92:	87 18       	st.w	r3[0x4],r8
80007c94:	04 9c       	mov	r12,r2
80007c96:	ee c5 ff f8 	sub	r5,r7,-8
80007c9a:	fe b0 f1 99 	rcall	80005fcc <__malloc_unlock>
80007c9e:	0a 9c       	mov	r12,r5
80007ca0:	2f fd       	sub	sp,-4
80007ca2:	d8 32       	popm	r0-r7,pc

80007ca4 <_sbrk_r>:
80007ca4:	d4 21       	pushm	r4-r7,lr
80007ca6:	30 08       	mov	r8,0
80007ca8:	18 97       	mov	r7,r12
80007caa:	e0 66 53 c8 	mov	r6,21448
80007cae:	16 9c       	mov	r12,r11
80007cb0:	8d 08       	st.w	r6[0x0],r8
80007cb2:	c8 5c       	rcall	80007dbc <_sbrk>
80007cb4:	5b fc       	cp.w	r12,-1
80007cb6:	c0 51       	brne	80007cc0 <_sbrk_r+0x1c>
80007cb8:	6c 08       	ld.w	r8,r6[0x0]
80007cba:	58 08       	cp.w	r8,0
80007cbc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007cc0:	d8 22       	popm	r4-r7,pc
80007cc2:	d7 03       	nop

80007cc4 <sprintf>:
80007cc4:	d4 01       	pushm	lr
80007cc6:	21 7d       	sub	sp,92
80007cc8:	e0 68 ff ff 	mov	r8,65535
80007ccc:	ea 18 7f ff 	orh	r8,0x7fff
80007cd0:	50 58       	stdsp	sp[0x14],r8
80007cd2:	50 28       	stdsp	sp[0x8],r8
80007cd4:	e0 68 02 08 	mov	r8,520
80007cd8:	ba 68       	st.h	sp[0xc],r8
80007cda:	3f f8       	mov	r8,-1
80007cdc:	ba 78       	st.h	sp[0xe],r8
80007cde:	e0 68 0a 40 	mov	r8,2624
80007ce2:	50 4c       	stdsp	sp[0x10],r12
80007ce4:	16 9a       	mov	r10,r11
80007ce6:	50 0c       	stdsp	sp[0x0],r12
80007ce8:	fa c9 ff a0 	sub	r9,sp,-96
80007cec:	70 0c       	ld.w	r12,r8[0x0]
80007cee:	1a 9b       	mov	r11,sp
80007cf0:	e0 a0 02 1a 	rcall	80008124 <_vfprintf_r>
80007cf4:	30 09       	mov	r9,0
80007cf6:	40 08       	lddsp	r8,sp[0x0]
80007cf8:	b0 89       	st.b	r8[0x0],r9
80007cfa:	2e 9d       	sub	sp,-92
80007cfc:	d8 02       	popm	pc
80007cfe:	d7 03       	nop

80007d00 <strncpy>:
80007d00:	30 08       	mov	r8,0
80007d02:	10 3a       	cp.w	r10,r8
80007d04:	5e 0c       	reteq	r12
80007d06:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007d0a:	f8 08 0b 09 	st.b	r12[r8],r9
80007d0e:	2f f8       	sub	r8,-1
80007d10:	58 09       	cp.w	r9,0
80007d12:	cf 81       	brne	80007d02 <strncpy+0x2>
80007d14:	10 3a       	cp.w	r10,r8
80007d16:	5e 0c       	reteq	r12
80007d18:	f8 08 0b 09 	st.b	r12[r8],r9
80007d1c:	2f f8       	sub	r8,-1
80007d1e:	cf bb       	rjmp	80007d14 <strncpy+0x14>

80007d20 <_close>:
80007d20:	30 28       	mov	r8,2
80007d22:	d6 73       	breakpoint
80007d24:	3f fc       	mov	r12,-1
80007d26:	35 8b       	mov	r11,88
80007d28:	58 0c       	cp.w	r12,0
80007d2a:	5e 4c       	retge	r12
80007d2c:	e0 6a 53 c8 	mov	r10,21448
80007d30:	95 0b       	st.w	r10[0x0],r11
80007d32:	5e fc       	retal	r12

80007d34 <_lseek>:
80007d34:	30 58       	mov	r8,5
80007d36:	d6 73       	breakpoint
80007d38:	3f fc       	mov	r12,-1
80007d3a:	35 8b       	mov	r11,88
80007d3c:	58 0c       	cp.w	r12,0
80007d3e:	5e 4c       	retge	r12
80007d40:	e0 6a 53 c8 	mov	r10,21448
80007d44:	95 0b       	st.w	r10[0x0],r11
80007d46:	5e fc       	retal	r12

80007d48 <isatty>:
80007d48:	30 b8       	mov	r8,11
80007d4a:	d6 73       	breakpoint
80007d4c:	3f fc       	mov	r12,-1
80007d4e:	35 8b       	mov	r11,88
80007d50:	58 0c       	cp.w	r12,0
80007d52:	5e 4c       	retge	r12
80007d54:	e0 6a 53 c8 	mov	r10,21448
80007d58:	95 0b       	st.w	r10[0x0],r11
80007d5a:	5e fc       	retal	r12

80007d5c <_fstat_host>:
80007d5c:	30 98       	mov	r8,9
80007d5e:	d6 73       	breakpoint
80007d60:	3f fc       	mov	r12,-1
80007d62:	35 8b       	mov	r11,88
80007d64:	58 0c       	cp.w	r12,0
80007d66:	5e 4c       	retge	r12
80007d68:	e0 6a 53 c8 	mov	r10,21448
80007d6c:	95 0b       	st.w	r10[0x0],r11
80007d6e:	5e fc       	retal	r12

80007d70 <_fstat>:
80007d70:	d4 21       	pushm	r4-r7,lr
80007d72:	21 0d       	sub	sp,64
80007d74:	16 97       	mov	r7,r11
80007d76:	1a 9b       	mov	r11,sp
80007d78:	cf 2f       	rcall	80007d5c <_fstat_host>
80007d7a:	c0 34       	brge	80007d80 <_fstat+0x10>
80007d7c:	3f fc       	mov	r12,-1
80007d7e:	c1 c8       	rjmp	80007db6 <_fstat+0x46>
80007d80:	40 08       	lddsp	r8,sp[0x0]
80007d82:	ae 08       	st.h	r7[0x0],r8
80007d84:	40 18       	lddsp	r8,sp[0x4]
80007d86:	ae 18       	st.h	r7[0x2],r8
80007d88:	40 28       	lddsp	r8,sp[0x8]
80007d8a:	8f 18       	st.w	r7[0x4],r8
80007d8c:	40 38       	lddsp	r8,sp[0xc]
80007d8e:	ae 48       	st.h	r7[0x8],r8
80007d90:	40 48       	lddsp	r8,sp[0x10]
80007d92:	ae 58       	st.h	r7[0xa],r8
80007d94:	40 58       	lddsp	r8,sp[0x14]
80007d96:	ae 68       	st.h	r7[0xc],r8
80007d98:	40 68       	lddsp	r8,sp[0x18]
80007d9a:	ae 78       	st.h	r7[0xe],r8
80007d9c:	40 88       	lddsp	r8,sp[0x20]
80007d9e:	8f 48       	st.w	r7[0x10],r8
80007da0:	40 a8       	lddsp	r8,sp[0x28]
80007da2:	8f b8       	st.w	r7[0x2c],r8
80007da4:	40 c8       	lddsp	r8,sp[0x30]
80007da6:	8f c8       	st.w	r7[0x30],r8
80007da8:	40 d8       	lddsp	r8,sp[0x34]
80007daa:	8f 58       	st.w	r7[0x14],r8
80007dac:	40 e8       	lddsp	r8,sp[0x38]
80007dae:	30 0c       	mov	r12,0
80007db0:	8f 78       	st.w	r7[0x1c],r8
80007db2:	40 f8       	lddsp	r8,sp[0x3c]
80007db4:	8f 98       	st.w	r7[0x24],r8
80007db6:	2f 0d       	sub	sp,-64
80007db8:	d8 22       	popm	r4-r7,pc
80007dba:	d7 03       	nop

80007dbc <_sbrk>:
80007dbc:	d4 01       	pushm	lr
80007dbe:	e0 68 0d 94 	mov	r8,3476
80007dc2:	70 09       	ld.w	r9,r8[0x0]
80007dc4:	58 09       	cp.w	r9,0
80007dc6:	c0 41       	brne	80007dce <_sbrk+0x12>
80007dc8:	e0 69 53 d0 	mov	r9,21456
80007dcc:	91 09       	st.w	r8[0x0],r9
80007dce:	e0 69 0d 94 	mov	r9,3476
80007dd2:	e0 7a 70 00 	mov	r10,94208
80007dd6:	72 08       	ld.w	r8,r9[0x0]
80007dd8:	f0 0c 00 0c 	add	r12,r8,r12
80007ddc:	14 3c       	cp.w	r12,r10
80007dde:	e0 8b 00 04 	brhi	80007de6 <_sbrk+0x2a>
80007de2:	93 0c       	st.w	r9[0x0],r12
80007de4:	c0 68       	rjmp	80007df0 <_sbrk+0x34>
80007de6:	e0 a0 18 15 	rcall	8000ae10 <__errno>
80007dea:	30 c8       	mov	r8,12
80007dec:	99 08       	st.w	r12[0x0],r8
80007dee:	3f f8       	mov	r8,-1
80007df0:	10 9c       	mov	r12,r8
80007df2:	d8 02       	popm	pc

80007df4 <get_arg>:
80007df4:	d4 31       	pushm	r0-r7,lr
80007df6:	20 8d       	sub	sp,32
80007df8:	fa c4 ff bc 	sub	r4,sp,-68
80007dfc:	50 4b       	stdsp	sp[0x10],r11
80007dfe:	68 2e       	ld.w	lr,r4[0x8]
80007e00:	50 58       	stdsp	sp[0x14],r8
80007e02:	12 96       	mov	r6,r9
80007e04:	7c 0b       	ld.w	r11,lr[0x0]
80007e06:	70 05       	ld.w	r5,r8[0x0]
80007e08:	50 6e       	stdsp	sp[0x18],lr
80007e0a:	58 0b       	cp.w	r11,0
80007e0c:	f4 0b 17 00 	moveq	r11,r10
80007e10:	68 03       	ld.w	r3,r4[0x0]
80007e12:	68 11       	ld.w	r1,r4[0x4]
80007e14:	40 49       	lddsp	r9,sp[0x10]
80007e16:	30 08       	mov	r8,0
80007e18:	c2 89       	rjmp	80008068 <get_arg+0x274>
80007e1a:	2f fb       	sub	r11,-1
80007e1c:	32 5c       	mov	r12,37
80007e1e:	17 8a       	ld.ub	r10,r11[0x0]
80007e20:	f8 0a 18 00 	cp.b	r10,r12
80007e24:	5f 1e       	srne	lr
80007e26:	f0 0a 18 00 	cp.b	r10,r8
80007e2a:	5f 1c       	srne	r12
80007e2c:	fd ec 00 0c 	and	r12,lr,r12
80007e30:	f0 0c 18 00 	cp.b	r12,r8
80007e34:	cf 31       	brne	80007e1a <get_arg+0x26>
80007e36:	58 0a       	cp.w	r10,0
80007e38:	e0 80 01 25 	breq	80008082 <get_arg+0x28e>
80007e3c:	30 0c       	mov	r12,0
80007e3e:	3f fa       	mov	r10,-1
80007e40:	18 90       	mov	r0,r12
80007e42:	50 3a       	stdsp	sp[0xc],r10
80007e44:	18 94       	mov	r4,r12
80007e46:	18 92       	mov	r2,r12
80007e48:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e4c:	16 97       	mov	r7,r11
80007e4e:	50 7c       	stdsp	sp[0x1c],r12
80007e50:	fe cc 9e 48 	sub	r12,pc,-25016
80007e54:	0f 3a       	ld.ub	r10,r7++
80007e56:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e5a:	40 7c       	lddsp	r12,sp[0x1c]
80007e5c:	1c 0c       	add	r12,lr
80007e5e:	fe ce 9f 1e 	sub	lr,pc,-24802
80007e62:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e66:	20 1e       	sub	lr,1
80007e68:	50 0e       	stdsp	sp[0x0],lr
80007e6a:	fe ce 9f 96 	sub	lr,pc,-24682
80007e6e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e72:	50 7c       	stdsp	sp[0x1c],r12
80007e74:	40 0c       	lddsp	r12,sp[0x0]
80007e76:	58 7c       	cp.w	r12,7
80007e78:	e0 8b 00 f1 	brhi	8000805a <get_arg+0x266>
80007e7c:	fe ce a1 48 	sub	lr,pc,-24248
80007e80:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e84:	36 8b       	mov	r11,104
80007e86:	f6 0a 18 00 	cp.b	r10,r11
80007e8a:	e0 80 00 e8 	breq	8000805a <get_arg+0x266>
80007e8e:	37 1b       	mov	r11,113
80007e90:	f6 0a 18 00 	cp.b	r10,r11
80007e94:	c0 70       	breq	80007ea2 <get_arg+0xae>
80007e96:	34 cb       	mov	r11,76
80007e98:	f6 0a 18 00 	cp.b	r10,r11
80007e9c:	c0 51       	brne	80007ea6 <get_arg+0xb2>
80007e9e:	a3 b4       	sbr	r4,0x3
80007ea0:	cd d8       	rjmp	8000805a <get_arg+0x266>
80007ea2:	a5 b4       	sbr	r4,0x5
80007ea4:	cd b8       	rjmp	8000805a <get_arg+0x266>
80007ea6:	08 9a       	mov	r10,r4
80007ea8:	0e 9b       	mov	r11,r7
80007eaa:	a5 aa       	sbr	r10,0x4
80007eac:	17 3c       	ld.ub	r12,r11++
80007eae:	a5 b4       	sbr	r4,0x5
80007eb0:	36 ce       	mov	lr,108
80007eb2:	fc 0c 18 00 	cp.b	r12,lr
80007eb6:	e0 80 00 d3 	breq	8000805c <get_arg+0x268>
80007eba:	14 94       	mov	r4,r10
80007ebc:	cc f8       	rjmp	8000805a <get_arg+0x266>
80007ebe:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007ec2:	36 7c       	mov	r12,103
80007ec4:	f8 0a 18 00 	cp.b	r10,r12
80007ec8:	e0 8b 00 27 	brhi	80007f16 <get_arg+0x122>
80007ecc:	36 5b       	mov	r11,101
80007ece:	f6 0a 18 00 	cp.b	r10,r11
80007ed2:	c4 82       	brcc	80007f62 <get_arg+0x16e>
80007ed4:	34 fb       	mov	r11,79
80007ed6:	f6 0a 18 00 	cp.b	r10,r11
80007eda:	c4 80       	breq	80007f6a <get_arg+0x176>
80007edc:	e0 8b 00 0c 	brhi	80007ef4 <get_arg+0x100>
80007ee0:	34 5b       	mov	r11,69
80007ee2:	f6 0a 18 00 	cp.b	r10,r11
80007ee6:	c3 e0       	breq	80007f62 <get_arg+0x16e>
80007ee8:	34 7b       	mov	r11,71
80007eea:	f6 0a 18 00 	cp.b	r10,r11
80007eee:	c3 a0       	breq	80007f62 <get_arg+0x16e>
80007ef0:	34 4b       	mov	r11,68
80007ef2:	c0 88       	rjmp	80007f02 <get_arg+0x10e>
80007ef4:	35 8b       	mov	r11,88
80007ef6:	f6 0a 18 00 	cp.b	r10,r11
80007efa:	c2 c0       	breq	80007f52 <get_arg+0x15e>
80007efc:	e0 8b 00 07 	brhi	80007f0a <get_arg+0x116>
80007f00:	35 5b       	mov	r11,85
80007f02:	f6 0a 18 00 	cp.b	r10,r11
80007f06:	c3 51       	brne	80007f70 <get_arg+0x17c>
80007f08:	c3 18       	rjmp	80007f6a <get_arg+0x176>
80007f0a:	36 3b       	mov	r11,99
80007f0c:	f6 0a 18 00 	cp.b	r10,r11
80007f10:	c2 f0       	breq	80007f6e <get_arg+0x17a>
80007f12:	36 4b       	mov	r11,100
80007f14:	c0 e8       	rjmp	80007f30 <get_arg+0x13c>
80007f16:	37 0b       	mov	r11,112
80007f18:	f6 0a 18 00 	cp.b	r10,r11
80007f1c:	c2 50       	breq	80007f66 <get_arg+0x172>
80007f1e:	e0 8b 00 0d 	brhi	80007f38 <get_arg+0x144>
80007f22:	36 eb       	mov	r11,110
80007f24:	f6 0a 18 00 	cp.b	r10,r11
80007f28:	c1 f0       	breq	80007f66 <get_arg+0x172>
80007f2a:	e0 8b 00 14 	brhi	80007f52 <get_arg+0x15e>
80007f2e:	36 9b       	mov	r11,105
80007f30:	f6 0a 18 00 	cp.b	r10,r11
80007f34:	c1 e1       	brne	80007f70 <get_arg+0x17c>
80007f36:	c0 e8       	rjmp	80007f52 <get_arg+0x15e>
80007f38:	37 5b       	mov	r11,117
80007f3a:	f6 0a 18 00 	cp.b	r10,r11
80007f3e:	c0 a0       	breq	80007f52 <get_arg+0x15e>
80007f40:	37 8b       	mov	r11,120
80007f42:	f6 0a 18 00 	cp.b	r10,r11
80007f46:	c0 60       	breq	80007f52 <get_arg+0x15e>
80007f48:	37 3b       	mov	r11,115
80007f4a:	f6 0a 18 00 	cp.b	r10,r11
80007f4e:	c1 11       	brne	80007f70 <get_arg+0x17c>
80007f50:	c0 b8       	rjmp	80007f66 <get_arg+0x172>
80007f52:	ed b4 00 04 	bld	r4,0x4
80007f56:	c0 a0       	breq	80007f6a <get_arg+0x176>
80007f58:	ed b4 00 05 	bld	r4,0x5
80007f5c:	c0 91       	brne	80007f6e <get_arg+0x17a>
80007f5e:	30 20       	mov	r0,2
80007f60:	c0 88       	rjmp	80007f70 <get_arg+0x17c>
80007f62:	30 40       	mov	r0,4
80007f64:	c0 68       	rjmp	80007f70 <get_arg+0x17c>
80007f66:	30 30       	mov	r0,3
80007f68:	c0 48       	rjmp	80007f70 <get_arg+0x17c>
80007f6a:	30 10       	mov	r0,1
80007f6c:	c0 28       	rjmp	80007f70 <get_arg+0x17c>
80007f6e:	30 00       	mov	r0,0
80007f70:	40 3b       	lddsp	r11,sp[0xc]
80007f72:	5b fb       	cp.w	r11,-1
80007f74:	c0 40       	breq	80007f7c <get_arg+0x188>
80007f76:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f7a:	c7 08       	rjmp	8000805a <get_arg+0x266>
80007f7c:	58 60       	cp.w	r0,6
80007f7e:	e0 8b 00 6e 	brhi	8000805a <get_arg+0x266>
80007f82:	6c 0a       	ld.w	r10,r6[0x0]
80007f84:	ea cc ff ff 	sub	r12,r5,-1
80007f88:	fe ce a2 34 	sub	lr,pc,-24012
80007f8c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f90:	f4 cb ff f8 	sub	r11,r10,-8
80007f94:	8d 0b       	st.w	r6[0x0],r11
80007f96:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f9a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f9e:	c0 f8       	rjmp	80007fbc <get_arg+0x1c8>
80007fa0:	f4 cb ff fc 	sub	r11,r10,-4
80007fa4:	8d 0b       	st.w	r6[0x0],r11
80007fa6:	74 0a       	ld.w	r10,r10[0x0]
80007fa8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007fac:	c0 88       	rjmp	80007fbc <get_arg+0x1c8>
80007fae:	f4 cb ff f8 	sub	r11,r10,-8
80007fb2:	8d 0b       	st.w	r6[0x0],r11
80007fb4:	f4 ea 00 00 	ld.d	r10,r10[0]
80007fb8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007fbc:	0e 9b       	mov	r11,r7
80007fbe:	18 95       	mov	r5,r12
80007fc0:	c4 e8       	rjmp	8000805c <get_arg+0x268>
80007fc2:	62 0a       	ld.w	r10,r1[0x0]
80007fc4:	5b fa       	cp.w	r10,-1
80007fc6:	c0 b1       	brne	80007fdc <get_arg+0x1e8>
80007fc8:	50 19       	stdsp	sp[0x4],r9
80007fca:	50 28       	stdsp	sp[0x8],r8
80007fcc:	e0 6a 00 80 	mov	r10,128
80007fd0:	30 0b       	mov	r11,0
80007fd2:	02 9c       	mov	r12,r1
80007fd4:	fe b0 fd 00 	rcall	800079d4 <memset>
80007fd8:	40 28       	lddsp	r8,sp[0x8]
80007fda:	40 19       	lddsp	r9,sp[0x4]
80007fdc:	e4 cc 00 01 	sub	r12,r2,1
80007fe0:	0e 9b       	mov	r11,r7
80007fe2:	50 3c       	stdsp	sp[0xc],r12
80007fe4:	f2 0c 0c 49 	max	r9,r9,r12
80007fe8:	c3 a8       	rjmp	8000805c <get_arg+0x268>
80007fea:	62 0a       	ld.w	r10,r1[0x0]
80007fec:	5b fa       	cp.w	r10,-1
80007fee:	c0 b1       	brne	80008004 <get_arg+0x210>
80007ff0:	50 19       	stdsp	sp[0x4],r9
80007ff2:	50 28       	stdsp	sp[0x8],r8
80007ff4:	e0 6a 00 80 	mov	r10,128
80007ff8:	30 0b       	mov	r11,0
80007ffa:	02 9c       	mov	r12,r1
80007ffc:	fe b0 fc ec 	rcall	800079d4 <memset>
80008000:	40 28       	lddsp	r8,sp[0x8]
80008002:	40 19       	lddsp	r9,sp[0x4]
80008004:	20 12       	sub	r2,1
80008006:	30 0a       	mov	r10,0
80008008:	0e 9b       	mov	r11,r7
8000800a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000800e:	f2 02 0c 49 	max	r9,r9,r2
80008012:	c2 58       	rjmp	8000805c <get_arg+0x268>
80008014:	16 97       	mov	r7,r11
80008016:	6c 0a       	ld.w	r10,r6[0x0]
80008018:	f4 cb ff fc 	sub	r11,r10,-4
8000801c:	8d 0b       	st.w	r6[0x0],r11
8000801e:	74 0a       	ld.w	r10,r10[0x0]
80008020:	0e 9b       	mov	r11,r7
80008022:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008026:	2f f5       	sub	r5,-1
80008028:	c1 a8       	rjmp	8000805c <get_arg+0x268>
8000802a:	f4 c2 00 30 	sub	r2,r10,48
8000802e:	c0 68       	rjmp	8000803a <get_arg+0x246>
80008030:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008034:	2f f7       	sub	r7,-1
80008036:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000803a:	0f 8a       	ld.ub	r10,r7[0x0]
8000803c:	58 0a       	cp.w	r10,0
8000803e:	c0 e0       	breq	8000805a <get_arg+0x266>
80008040:	23 0a       	sub	r10,48
80008042:	58 9a       	cp.w	r10,9
80008044:	fe 98 ff f6 	brls	80008030 <get_arg+0x23c>
80008048:	c0 98       	rjmp	8000805a <get_arg+0x266>
8000804a:	2f f7       	sub	r7,-1
8000804c:	0f 8a       	ld.ub	r10,r7[0x0]
8000804e:	58 0a       	cp.w	r10,0
80008050:	c0 50       	breq	8000805a <get_arg+0x266>
80008052:	23 0a       	sub	r10,48
80008054:	58 9a       	cp.w	r10,9
80008056:	fe 98 ff fa 	brls	8000804a <get_arg+0x256>
8000805a:	0e 9b       	mov	r11,r7
8000805c:	40 7c       	lddsp	r12,sp[0x1c]
8000805e:	30 ba       	mov	r10,11
80008060:	f4 0c 18 00 	cp.b	r12,r10
80008064:	fe 91 fe f2 	brne	80007e48 <get_arg+0x54>
80008068:	40 42       	lddsp	r2,sp[0x10]
8000806a:	17 8c       	ld.ub	r12,r11[0x0]
8000806c:	0a 32       	cp.w	r2,r5
8000806e:	5f 4a       	srge	r10
80008070:	f0 0c 18 00 	cp.b	r12,r8
80008074:	5f 1c       	srne	r12
80008076:	f9 ea 00 0a 	and	r10,r12,r10
8000807a:	f0 0a 18 00 	cp.b	r10,r8
8000807e:	fe 91 fe cf 	brne	80007e1c <get_arg+0x28>
80008082:	30 08       	mov	r8,0
80008084:	40 4e       	lddsp	lr,sp[0x10]
80008086:	17 8a       	ld.ub	r10,r11[0x0]
80008088:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000808c:	f0 0a 18 00 	cp.b	r10,r8
80008090:	fc 09 17 10 	movne	r9,lr
80008094:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008098:	06 9e       	mov	lr,r3
8000809a:	c2 a8       	rjmp	800080ee <get_arg+0x2fa>
8000809c:	62 0a       	ld.w	r10,r1[0x0]
8000809e:	58 3a       	cp.w	r10,3
800080a0:	c1 e0       	breq	800080dc <get_arg+0x2e8>
800080a2:	e0 89 00 07 	brgt	800080b0 <get_arg+0x2bc>
800080a6:	58 1a       	cp.w	r10,1
800080a8:	c1 a0       	breq	800080dc <get_arg+0x2e8>
800080aa:	58 2a       	cp.w	r10,2
800080ac:	c1 81       	brne	800080dc <get_arg+0x2e8>
800080ae:	c0 58       	rjmp	800080b8 <get_arg+0x2c4>
800080b0:	58 5a       	cp.w	r10,5
800080b2:	c0 c0       	breq	800080ca <get_arg+0x2d6>
800080b4:	c0 b5       	brlt	800080ca <get_arg+0x2d6>
800080b6:	c1 38       	rjmp	800080dc <get_arg+0x2e8>
800080b8:	6c 0a       	ld.w	r10,r6[0x0]
800080ba:	f4 cc ff f8 	sub	r12,r10,-8
800080be:	8d 0c       	st.w	r6[0x0],r12
800080c0:	f4 e2 00 00 	ld.d	r2,r10[0]
800080c4:	f0 e3 00 00 	st.d	r8[0],r2
800080c8:	c1 08       	rjmp	800080e8 <get_arg+0x2f4>
800080ca:	6c 0a       	ld.w	r10,r6[0x0]
800080cc:	f4 cc ff f8 	sub	r12,r10,-8
800080d0:	8d 0c       	st.w	r6[0x0],r12
800080d2:	f4 e2 00 00 	ld.d	r2,r10[0]
800080d6:	f0 e3 00 00 	st.d	r8[0],r2
800080da:	c0 78       	rjmp	800080e8 <get_arg+0x2f4>
800080dc:	6c 0a       	ld.w	r10,r6[0x0]
800080de:	f4 cc ff fc 	sub	r12,r10,-4
800080e2:	8d 0c       	st.w	r6[0x0],r12
800080e4:	74 0a       	ld.w	r10,r10[0x0]
800080e6:	91 0a       	st.w	r8[0x0],r10
800080e8:	2f f5       	sub	r5,-1
800080ea:	2f 88       	sub	r8,-8
800080ec:	2f c1       	sub	r1,-4
800080ee:	12 35       	cp.w	r5,r9
800080f0:	fe 9a ff d6 	brle	8000809c <get_arg+0x2a8>
800080f4:	1c 93       	mov	r3,lr
800080f6:	40 52       	lddsp	r2,sp[0x14]
800080f8:	40 6e       	lddsp	lr,sp[0x18]
800080fa:	85 05       	st.w	r2[0x0],r5
800080fc:	9d 0b       	st.w	lr[0x0],r11
800080fe:	40 4b       	lddsp	r11,sp[0x10]
80008100:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008104:	2f 8d       	sub	sp,-32
80008106:	d8 32       	popm	r0-r7,pc

80008108 <__sprint_r>:
80008108:	d4 21       	pushm	r4-r7,lr
8000810a:	14 97       	mov	r7,r10
8000810c:	74 28       	ld.w	r8,r10[0x8]
8000810e:	58 08       	cp.w	r8,0
80008110:	c0 41       	brne	80008118 <__sprint_r+0x10>
80008112:	95 18       	st.w	r10[0x4],r8
80008114:	10 9c       	mov	r12,r8
80008116:	d8 22       	popm	r4-r7,pc
80008118:	e0 a0 18 ba 	rcall	8000b28c <__sfvwrite_r>
8000811c:	30 08       	mov	r8,0
8000811e:	8f 18       	st.w	r7[0x4],r8
80008120:	8f 28       	st.w	r7[0x8],r8
80008122:	d8 22       	popm	r4-r7,pc

80008124 <_vfprintf_r>:
80008124:	d4 31       	pushm	r0-r7,lr
80008126:	fa cd 06 bc 	sub	sp,sp,1724
8000812a:	51 09       	stdsp	sp[0x40],r9
8000812c:	16 91       	mov	r1,r11
8000812e:	14 97       	mov	r7,r10
80008130:	18 95       	mov	r5,r12
80008132:	e0 a0 1a 1d 	rcall	8000b56c <_localeconv_r>
80008136:	78 0c       	ld.w	r12,r12[0x0]
80008138:	50 cc       	stdsp	sp[0x30],r12
8000813a:	58 05       	cp.w	r5,0
8000813c:	c0 70       	breq	8000814a <_vfprintf_r+0x26>
8000813e:	6a 68       	ld.w	r8,r5[0x18]
80008140:	58 08       	cp.w	r8,0
80008142:	c0 41       	brne	8000814a <_vfprintf_r+0x26>
80008144:	0a 9c       	mov	r12,r5
80008146:	e0 a0 17 43 	rcall	8000afcc <__sinit>
8000814a:	fe c8 a0 32 	sub	r8,pc,-24526
8000814e:	10 31       	cp.w	r1,r8
80008150:	c0 31       	brne	80008156 <_vfprintf_r+0x32>
80008152:	6a 01       	ld.w	r1,r5[0x0]
80008154:	c0 c8       	rjmp	8000816c <_vfprintf_r+0x48>
80008156:	fe c8 a0 1e 	sub	r8,pc,-24546
8000815a:	10 31       	cp.w	r1,r8
8000815c:	c0 31       	brne	80008162 <_vfprintf_r+0x3e>
8000815e:	6a 11       	ld.w	r1,r5[0x4]
80008160:	c0 68       	rjmp	8000816c <_vfprintf_r+0x48>
80008162:	fe c8 a0 0a 	sub	r8,pc,-24566
80008166:	10 31       	cp.w	r1,r8
80008168:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000816c:	82 68       	ld.sh	r8,r1[0xc]
8000816e:	ed b8 00 03 	bld	r8,0x3
80008172:	c0 41       	brne	8000817a <_vfprintf_r+0x56>
80008174:	62 48       	ld.w	r8,r1[0x10]
80008176:	58 08       	cp.w	r8,0
80008178:	c0 71       	brne	80008186 <_vfprintf_r+0x62>
8000817a:	02 9b       	mov	r11,r1
8000817c:	0a 9c       	mov	r12,r5
8000817e:	e0 a0 0f 5d 	rcall	8000a038 <__swsetup_r>
80008182:	e0 81 0f 54 	brne	8000a02a <_vfprintf_r+0x1f06>
80008186:	82 68       	ld.sh	r8,r1[0xc]
80008188:	10 99       	mov	r9,r8
8000818a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000818e:	58 a9       	cp.w	r9,10
80008190:	c3 c1       	brne	80008208 <_vfprintf_r+0xe4>
80008192:	82 79       	ld.sh	r9,r1[0xe]
80008194:	30 0a       	mov	r10,0
80008196:	f4 09 19 00 	cp.h	r9,r10
8000819a:	c3 75       	brlt	80008208 <_vfprintf_r+0xe4>
8000819c:	a1 d8       	cbr	r8,0x1
8000819e:	fb 58 05 d0 	st.h	sp[1488],r8
800081a2:	62 88       	ld.w	r8,r1[0x20]
800081a4:	fb 48 05 e4 	st.w	sp[1508],r8
800081a8:	62 a8       	ld.w	r8,r1[0x28]
800081aa:	fb 48 05 ec 	st.w	sp[1516],r8
800081ae:	fa c8 ff bc 	sub	r8,sp,-68
800081b2:	fb 48 05 d4 	st.w	sp[1492],r8
800081b6:	fb 48 05 c4 	st.w	sp[1476],r8
800081ba:	e0 68 04 00 	mov	r8,1024
800081be:	fb 48 05 d8 	st.w	sp[1496],r8
800081c2:	fb 48 05 cc 	st.w	sp[1484],r8
800081c6:	30 08       	mov	r8,0
800081c8:	fb 59 05 d2 	st.h	sp[1490],r9
800081cc:	0e 9a       	mov	r10,r7
800081ce:	41 09       	lddsp	r9,sp[0x40]
800081d0:	fa c7 fa 3c 	sub	r7,sp,-1476
800081d4:	fb 48 05 dc 	st.w	sp[1500],r8
800081d8:	0a 9c       	mov	r12,r5
800081da:	0e 9b       	mov	r11,r7
800081dc:	ca 4f       	rcall	80008124 <_vfprintf_r>
800081de:	50 bc       	stdsp	sp[0x2c],r12
800081e0:	c0 95       	brlt	800081f2 <_vfprintf_r+0xce>
800081e2:	0e 9b       	mov	r11,r7
800081e4:	0a 9c       	mov	r12,r5
800081e6:	e0 a0 16 1b 	rcall	8000ae1c <_fflush_r>
800081ea:	40 be       	lddsp	lr,sp[0x2c]
800081ec:	f9 be 01 ff 	movne	lr,-1
800081f0:	50 be       	stdsp	sp[0x2c],lr
800081f2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081f6:	ed b8 00 06 	bld	r8,0x6
800081fa:	e0 81 0f 1a 	brne	8000a02e <_vfprintf_r+0x1f0a>
800081fe:	82 68       	ld.sh	r8,r1[0xc]
80008200:	a7 a8       	sbr	r8,0x6
80008202:	a2 68       	st.h	r1[0xc],r8
80008204:	e0 8f 0f 15 	bral	8000a02e <_vfprintf_r+0x1f0a>
80008208:	30 08       	mov	r8,0
8000820a:	fb 48 06 b4 	st.w	sp[1716],r8
8000820e:	fb 48 06 90 	st.w	sp[1680],r8
80008212:	fb 48 06 8c 	st.w	sp[1676],r8
80008216:	fb 48 06 b0 	st.w	sp[1712],r8
8000821a:	30 08       	mov	r8,0
8000821c:	30 09       	mov	r9,0
8000821e:	50 a7       	stdsp	sp[0x28],r7
80008220:	50 78       	stdsp	sp[0x1c],r8
80008222:	fa c3 f9 e0 	sub	r3,sp,-1568
80008226:	3f f8       	mov	r8,-1
80008228:	50 59       	stdsp	sp[0x14],r9
8000822a:	fb 43 06 88 	st.w	sp[1672],r3
8000822e:	fb 48 05 44 	st.w	sp[1348],r8
80008232:	12 9c       	mov	r12,r9
80008234:	50 69       	stdsp	sp[0x18],r9
80008236:	50 d9       	stdsp	sp[0x34],r9
80008238:	50 e9       	stdsp	sp[0x38],r9
8000823a:	50 b9       	stdsp	sp[0x2c],r9
8000823c:	12 97       	mov	r7,r9
8000823e:	0a 94       	mov	r4,r5
80008240:	40 a2       	lddsp	r2,sp[0x28]
80008242:	32 5a       	mov	r10,37
80008244:	30 08       	mov	r8,0
80008246:	c0 28       	rjmp	8000824a <_vfprintf_r+0x126>
80008248:	2f f2       	sub	r2,-1
8000824a:	05 89       	ld.ub	r9,r2[0x0]
8000824c:	f0 09 18 00 	cp.b	r9,r8
80008250:	5f 1b       	srne	r11
80008252:	f4 09 18 00 	cp.b	r9,r10
80008256:	5f 19       	srne	r9
80008258:	f3 eb 00 0b 	and	r11,r9,r11
8000825c:	f0 0b 18 00 	cp.b	r11,r8
80008260:	cf 41       	brne	80008248 <_vfprintf_r+0x124>
80008262:	40 ab       	lddsp	r11,sp[0x28]
80008264:	e4 0b 01 06 	sub	r6,r2,r11
80008268:	c1 e0       	breq	800082a4 <_vfprintf_r+0x180>
8000826a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000826e:	0c 08       	add	r8,r6
80008270:	87 0b       	st.w	r3[0x0],r11
80008272:	fb 48 06 90 	st.w	sp[1680],r8
80008276:	87 16       	st.w	r3[0x4],r6
80008278:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000827c:	2f f8       	sub	r8,-1
8000827e:	fb 48 06 8c 	st.w	sp[1676],r8
80008282:	58 78       	cp.w	r8,7
80008284:	e0 89 00 04 	brgt	8000828c <_vfprintf_r+0x168>
80008288:	2f 83       	sub	r3,-8
8000828a:	c0 a8       	rjmp	8000829e <_vfprintf_r+0x17a>
8000828c:	fa ca f9 78 	sub	r10,sp,-1672
80008290:	02 9b       	mov	r11,r1
80008292:	08 9c       	mov	r12,r4
80008294:	c3 af       	rcall	80008108 <__sprint_r>
80008296:	e0 81 0e c6 	brne	8000a022 <_vfprintf_r+0x1efe>
8000829a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000829e:	40 ba       	lddsp	r10,sp[0x2c]
800082a0:	0c 0a       	add	r10,r6
800082a2:	50 ba       	stdsp	sp[0x2c],r10
800082a4:	05 89       	ld.ub	r9,r2[0x0]
800082a6:	30 08       	mov	r8,0
800082a8:	f0 09 18 00 	cp.b	r9,r8
800082ac:	e0 80 0e aa 	breq	8000a000 <_vfprintf_r+0x1edc>
800082b0:	30 09       	mov	r9,0
800082b2:	fb 68 06 bb 	st.b	sp[1723],r8
800082b6:	0e 96       	mov	r6,r7
800082b8:	e4 c8 ff ff 	sub	r8,r2,-1
800082bc:	3f fe       	mov	lr,-1
800082be:	50 93       	stdsp	sp[0x24],r3
800082c0:	50 41       	stdsp	sp[0x10],r1
800082c2:	0e 93       	mov	r3,r7
800082c4:	04 91       	mov	r1,r2
800082c6:	50 89       	stdsp	sp[0x20],r9
800082c8:	50 a8       	stdsp	sp[0x28],r8
800082ca:	50 2e       	stdsp	sp[0x8],lr
800082cc:	50 39       	stdsp	sp[0xc],r9
800082ce:	12 95       	mov	r5,r9
800082d0:	12 90       	mov	r0,r9
800082d2:	10 97       	mov	r7,r8
800082d4:	08 92       	mov	r2,r4
800082d6:	c0 78       	rjmp	800082e4 <_vfprintf_r+0x1c0>
800082d8:	3f fc       	mov	r12,-1
800082da:	08 97       	mov	r7,r4
800082dc:	50 2c       	stdsp	sp[0x8],r12
800082de:	c0 38       	rjmp	800082e4 <_vfprintf_r+0x1c0>
800082e0:	30 0b       	mov	r11,0
800082e2:	50 3b       	stdsp	sp[0xc],r11
800082e4:	0f 38       	ld.ub	r8,r7++
800082e6:	c0 28       	rjmp	800082ea <_vfprintf_r+0x1c6>
800082e8:	12 90       	mov	r0,r9
800082ea:	f0 c9 00 20 	sub	r9,r8,32
800082ee:	e0 49 00 58 	cp.w	r9,88
800082f2:	e0 8b 0a 30 	brhi	80009752 <_vfprintf_r+0x162e>
800082f6:	fe ca a5 86 	sub	r10,pc,-23162
800082fa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800082fe:	50 a7       	stdsp	sp[0x28],r7
80008300:	50 80       	stdsp	sp[0x20],r0
80008302:	0c 97       	mov	r7,r6
80008304:	04 94       	mov	r4,r2
80008306:	06 96       	mov	r6,r3
80008308:	02 92       	mov	r2,r1
8000830a:	fe c9 a3 5e 	sub	r9,pc,-23714
8000830e:	40 93       	lddsp	r3,sp[0x24]
80008310:	10 90       	mov	r0,r8
80008312:	40 41       	lddsp	r1,sp[0x10]
80008314:	50 d9       	stdsp	sp[0x34],r9
80008316:	e0 8f 08 8e 	bral	80009432 <_vfprintf_r+0x130e>
8000831a:	30 08       	mov	r8,0
8000831c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008320:	f0 09 18 00 	cp.b	r9,r8
80008324:	ce 01       	brne	800082e4 <_vfprintf_r+0x1c0>
80008326:	32 08       	mov	r8,32
80008328:	c6 e8       	rjmp	80008404 <_vfprintf_r+0x2e0>
8000832a:	a1 a5       	sbr	r5,0x0
8000832c:	cd cb       	rjmp	800082e4 <_vfprintf_r+0x1c0>
8000832e:	0f 89       	ld.ub	r9,r7[0x0]
80008330:	f2 c8 00 30 	sub	r8,r9,48
80008334:	58 98       	cp.w	r8,9
80008336:	e0 8b 00 1d 	brhi	80008370 <_vfprintf_r+0x24c>
8000833a:	ee c8 ff ff 	sub	r8,r7,-1
8000833e:	30 0b       	mov	r11,0
80008340:	23 09       	sub	r9,48
80008342:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008346:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000834a:	11 39       	ld.ub	r9,r8++
8000834c:	f2 ca 00 30 	sub	r10,r9,48
80008350:	58 9a       	cp.w	r10,9
80008352:	fe 98 ff f7 	brls	80008340 <_vfprintf_r+0x21c>
80008356:	e0 49 00 24 	cp.w	r9,36
8000835a:	cc 31       	brne	800082e0 <_vfprintf_r+0x1bc>
8000835c:	e0 4b 00 20 	cp.w	r11,32
80008360:	e0 89 0e 60 	brgt	8000a020 <_vfprintf_r+0x1efc>
80008364:	20 1b       	sub	r11,1
80008366:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000836a:	12 3b       	cp.w	r11,r9
8000836c:	c0 95       	brlt	8000837e <_vfprintf_r+0x25a>
8000836e:	c1 08       	rjmp	8000838e <_vfprintf_r+0x26a>
80008370:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008374:	ec ca ff ff 	sub	r10,r6,-1
80008378:	12 36       	cp.w	r6,r9
8000837a:	c1 f5       	brlt	800083b8 <_vfprintf_r+0x294>
8000837c:	c2 68       	rjmp	800083c8 <_vfprintf_r+0x2a4>
8000837e:	fa ce f9 44 	sub	lr,sp,-1724
80008382:	10 97       	mov	r7,r8
80008384:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008388:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000838c:	c3 58       	rjmp	800083f6 <_vfprintf_r+0x2d2>
8000838e:	10 97       	mov	r7,r8
80008390:	fa c8 f9 50 	sub	r8,sp,-1712
80008394:	1a d8       	st.w	--sp,r8
80008396:	fa c8 fa b8 	sub	r8,sp,-1352
8000839a:	1a d8       	st.w	--sp,r8
8000839c:	fa c8 fb b4 	sub	r8,sp,-1100
800083a0:	02 9a       	mov	r10,r1
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	04 9c       	mov	r12,r2
800083a6:	fa c8 f9 40 	sub	r8,sp,-1728
800083aa:	fa c9 ff b4 	sub	r9,sp,-76
800083ae:	fe b0 fd 23 	rcall	80007df4 <get_arg>
800083b2:	2f dd       	sub	sp,-12
800083b4:	78 00       	ld.w	r0,r12[0x0]
800083b6:	c2 08       	rjmp	800083f6 <_vfprintf_r+0x2d2>
800083b8:	fa cc f9 44 	sub	r12,sp,-1724
800083bc:	14 96       	mov	r6,r10
800083be:	f8 03 00 38 	add	r8,r12,r3<<0x3
800083c2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800083c6:	c1 88       	rjmp	800083f6 <_vfprintf_r+0x2d2>
800083c8:	41 08       	lddsp	r8,sp[0x40]
800083ca:	59 f9       	cp.w	r9,31
800083cc:	e0 89 00 11 	brgt	800083ee <_vfprintf_r+0x2ca>
800083d0:	f0 cb ff fc 	sub	r11,r8,-4
800083d4:	51 0b       	stdsp	sp[0x40],r11
800083d6:	70 00       	ld.w	r0,r8[0x0]
800083d8:	fa cb f9 44 	sub	r11,sp,-1724
800083dc:	f6 09 00 38 	add	r8,r11,r9<<0x3
800083e0:	f1 40 fd 88 	st.w	r8[-632],r0
800083e4:	2f f9       	sub	r9,-1
800083e6:	14 96       	mov	r6,r10
800083e8:	fb 49 06 b4 	st.w	sp[1716],r9
800083ec:	c0 58       	rjmp	800083f6 <_vfprintf_r+0x2d2>
800083ee:	70 00       	ld.w	r0,r8[0x0]
800083f0:	14 96       	mov	r6,r10
800083f2:	2f c8       	sub	r8,-4
800083f4:	51 08       	stdsp	sp[0x40],r8
800083f6:	58 00       	cp.w	r0,0
800083f8:	fe 94 ff 76 	brge	800082e4 <_vfprintf_r+0x1c0>
800083fc:	5c 30       	neg	r0
800083fe:	a3 a5       	sbr	r5,0x2
80008400:	c7 2b       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008402:	32 b8       	mov	r8,43
80008404:	fb 68 06 bb 	st.b	sp[1723],r8
80008408:	c6 eb       	rjmp	800082e4 <_vfprintf_r+0x1c0>
8000840a:	0f 38       	ld.ub	r8,r7++
8000840c:	e0 48 00 2a 	cp.w	r8,42
80008410:	c0 30       	breq	80008416 <_vfprintf_r+0x2f2>
80008412:	30 09       	mov	r9,0
80008414:	c7 98       	rjmp	80008506 <_vfprintf_r+0x3e2>
80008416:	0f 88       	ld.ub	r8,r7[0x0]
80008418:	f0 c9 00 30 	sub	r9,r8,48
8000841c:	58 99       	cp.w	r9,9
8000841e:	e0 8b 00 1f 	brhi	8000845c <_vfprintf_r+0x338>
80008422:	ee c4 ff ff 	sub	r4,r7,-1
80008426:	30 0b       	mov	r11,0
80008428:	23 08       	sub	r8,48
8000842a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000842e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008432:	09 38       	ld.ub	r8,r4++
80008434:	f0 c9 00 30 	sub	r9,r8,48
80008438:	58 99       	cp.w	r9,9
8000843a:	fe 98 ff f7 	brls	80008428 <_vfprintf_r+0x304>
8000843e:	e0 48 00 24 	cp.w	r8,36
80008442:	fe 91 ff 4f 	brne	800082e0 <_vfprintf_r+0x1bc>
80008446:	e0 4b 00 20 	cp.w	r11,32
8000844a:	e0 89 0d eb 	brgt	8000a020 <_vfprintf_r+0x1efc>
8000844e:	20 1b       	sub	r11,1
80008450:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008454:	10 3b       	cp.w	r11,r8
80008456:	c0 a5       	brlt	8000846a <_vfprintf_r+0x346>
80008458:	c1 18       	rjmp	8000847a <_vfprintf_r+0x356>
8000845a:	d7 03       	nop
8000845c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008460:	ec c9 ff ff 	sub	r9,r6,-1
80008464:	14 36       	cp.w	r6,r10
80008466:	c1 f5       	brlt	800084a4 <_vfprintf_r+0x380>
80008468:	c2 88       	rjmp	800084b8 <_vfprintf_r+0x394>
8000846a:	fa ca f9 44 	sub	r10,sp,-1724
8000846e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008472:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008476:	50 2b       	stdsp	sp[0x8],r11
80008478:	c3 c8       	rjmp	800084f0 <_vfprintf_r+0x3cc>
8000847a:	fa c8 f9 50 	sub	r8,sp,-1712
8000847e:	1a d8       	st.w	--sp,r8
80008480:	fa c8 fa b8 	sub	r8,sp,-1352
80008484:	1a d8       	st.w	--sp,r8
80008486:	fa c8 fb b4 	sub	r8,sp,-1100
8000848a:	02 9a       	mov	r10,r1
8000848c:	1a d8       	st.w	--sp,r8
8000848e:	04 9c       	mov	r12,r2
80008490:	fa c8 f9 40 	sub	r8,sp,-1728
80008494:	fa c9 ff b4 	sub	r9,sp,-76
80008498:	fe b0 fc ae 	rcall	80007df4 <get_arg>
8000849c:	2f dd       	sub	sp,-12
8000849e:	78 0c       	ld.w	r12,r12[0x0]
800084a0:	50 2c       	stdsp	sp[0x8],r12
800084a2:	c2 78       	rjmp	800084f0 <_vfprintf_r+0x3cc>
800084a4:	12 96       	mov	r6,r9
800084a6:	0e 94       	mov	r4,r7
800084a8:	fa c9 f9 44 	sub	r9,sp,-1724
800084ac:	f2 03 00 38 	add	r8,r9,r3<<0x3
800084b0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800084b4:	50 28       	stdsp	sp[0x8],r8
800084b6:	c1 d8       	rjmp	800084f0 <_vfprintf_r+0x3cc>
800084b8:	41 08       	lddsp	r8,sp[0x40]
800084ba:	59 fa       	cp.w	r10,31
800084bc:	e0 89 00 14 	brgt	800084e4 <_vfprintf_r+0x3c0>
800084c0:	f0 cb ff fc 	sub	r11,r8,-4
800084c4:	70 08       	ld.w	r8,r8[0x0]
800084c6:	51 0b       	stdsp	sp[0x40],r11
800084c8:	50 28       	stdsp	sp[0x8],r8
800084ca:	fa c6 f9 44 	sub	r6,sp,-1724
800084ce:	40 2e       	lddsp	lr,sp[0x8]
800084d0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800084d4:	f1 4e fd 88 	st.w	r8[-632],lr
800084d8:	2f fa       	sub	r10,-1
800084da:	0e 94       	mov	r4,r7
800084dc:	fb 4a 06 b4 	st.w	sp[1716],r10
800084e0:	12 96       	mov	r6,r9
800084e2:	c0 78       	rjmp	800084f0 <_vfprintf_r+0x3cc>
800084e4:	70 0c       	ld.w	r12,r8[0x0]
800084e6:	0e 94       	mov	r4,r7
800084e8:	2f c8       	sub	r8,-4
800084ea:	50 2c       	stdsp	sp[0x8],r12
800084ec:	12 96       	mov	r6,r9
800084ee:	51 08       	stdsp	sp[0x40],r8
800084f0:	40 2b       	lddsp	r11,sp[0x8]
800084f2:	58 0b       	cp.w	r11,0
800084f4:	fe 95 fe f2 	brlt	800082d8 <_vfprintf_r+0x1b4>
800084f8:	08 97       	mov	r7,r4
800084fa:	cf 5a       	rjmp	800082e4 <_vfprintf_r+0x1c0>
800084fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008500:	0f 38       	ld.ub	r8,r7++
80008502:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008506:	f0 ca 00 30 	sub	r10,r8,48
8000850a:	58 9a       	cp.w	r10,9
8000850c:	fe 98 ff f8 	brls	800084fc <_vfprintf_r+0x3d8>
80008510:	3f fa       	mov	r10,-1
80008512:	f2 0a 0c 49 	max	r9,r9,r10
80008516:	50 29       	stdsp	sp[0x8],r9
80008518:	ce 9a       	rjmp	800082ea <_vfprintf_r+0x1c6>
8000851a:	a7 b5       	sbr	r5,0x7
8000851c:	ce 4a       	rjmp	800082e4 <_vfprintf_r+0x1c0>
8000851e:	30 09       	mov	r9,0
80008520:	23 08       	sub	r8,48
80008522:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008526:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000852a:	0f 38       	ld.ub	r8,r7++
8000852c:	f0 ca 00 30 	sub	r10,r8,48
80008530:	58 9a       	cp.w	r10,9
80008532:	fe 98 ff f7 	brls	80008520 <_vfprintf_r+0x3fc>
80008536:	e0 48 00 24 	cp.w	r8,36
8000853a:	fe 91 fe d7 	brne	800082e8 <_vfprintf_r+0x1c4>
8000853e:	e0 49 00 20 	cp.w	r9,32
80008542:	e0 89 0d 6f 	brgt	8000a020 <_vfprintf_r+0x1efc>
80008546:	f2 c3 00 01 	sub	r3,r9,1
8000854a:	30 19       	mov	r9,1
8000854c:	50 39       	stdsp	sp[0xc],r9
8000854e:	cc ba       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008550:	a3 b5       	sbr	r5,0x3
80008552:	cc 9a       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008554:	a7 a5       	sbr	r5,0x6
80008556:	cc 7a       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008558:	0a 98       	mov	r8,r5
8000855a:	a5 b5       	sbr	r5,0x5
8000855c:	a5 a8       	sbr	r8,0x4
8000855e:	0f 89       	ld.ub	r9,r7[0x0]
80008560:	36 ce       	mov	lr,108
80008562:	fc 09 18 00 	cp.b	r9,lr
80008566:	f7 b7 00 ff 	subeq	r7,-1
8000856a:	f0 05 17 10 	movne	r5,r8
8000856e:	cb ba       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008570:	a5 b5       	sbr	r5,0x5
80008572:	cb 9a       	rjmp	800082e4 <_vfprintf_r+0x1c0>
80008574:	50 a7       	stdsp	sp[0x28],r7
80008576:	50 80       	stdsp	sp[0x20],r0
80008578:	0c 97       	mov	r7,r6
8000857a:	10 90       	mov	r0,r8
8000857c:	06 96       	mov	r6,r3
8000857e:	04 94       	mov	r4,r2
80008580:	40 93       	lddsp	r3,sp[0x24]
80008582:	02 92       	mov	r2,r1
80008584:	0e 99       	mov	r9,r7
80008586:	40 41       	lddsp	r1,sp[0x10]
80008588:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000858c:	40 3c       	lddsp	r12,sp[0xc]
8000858e:	58 0c       	cp.w	r12,0
80008590:	c1 d0       	breq	800085ca <_vfprintf_r+0x4a6>
80008592:	10 36       	cp.w	r6,r8
80008594:	c0 64       	brge	800085a0 <_vfprintf_r+0x47c>
80008596:	fa cb f9 44 	sub	r11,sp,-1724
8000859a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000859e:	c1 d8       	rjmp	800085d8 <_vfprintf_r+0x4b4>
800085a0:	fa c8 f9 50 	sub	r8,sp,-1712
800085a4:	1a d8       	st.w	--sp,r8
800085a6:	fa c8 fa b8 	sub	r8,sp,-1352
800085aa:	1a d8       	st.w	--sp,r8
800085ac:	fa c8 fb b4 	sub	r8,sp,-1100
800085b0:	1a d8       	st.w	--sp,r8
800085b2:	fa c8 f9 40 	sub	r8,sp,-1728
800085b6:	fa c9 ff b4 	sub	r9,sp,-76
800085ba:	04 9a       	mov	r10,r2
800085bc:	0c 9b       	mov	r11,r6
800085be:	08 9c       	mov	r12,r4
800085c0:	fe b0 fc 1a 	rcall	80007df4 <get_arg>
800085c4:	2f dd       	sub	sp,-12
800085c6:	19 b8       	ld.ub	r8,r12[0x3]
800085c8:	c2 28       	rjmp	8000860c <_vfprintf_r+0x4e8>
800085ca:	2f f7       	sub	r7,-1
800085cc:	10 39       	cp.w	r9,r8
800085ce:	c0 84       	brge	800085de <_vfprintf_r+0x4ba>
800085d0:	fa ca f9 44 	sub	r10,sp,-1724
800085d4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085d8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800085dc:	c1 88       	rjmp	8000860c <_vfprintf_r+0x4e8>
800085de:	41 09       	lddsp	r9,sp[0x40]
800085e0:	59 f8       	cp.w	r8,31
800085e2:	e0 89 00 12 	brgt	80008606 <_vfprintf_r+0x4e2>
800085e6:	f2 ca ff fc 	sub	r10,r9,-4
800085ea:	51 0a       	stdsp	sp[0x40],r10
800085ec:	72 09       	ld.w	r9,r9[0x0]
800085ee:	fa c6 f9 44 	sub	r6,sp,-1724
800085f2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085f6:	2f f8       	sub	r8,-1
800085f8:	f5 49 fd 88 	st.w	r10[-632],r9
800085fc:	fb 48 06 b4 	st.w	sp[1716],r8
80008600:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008604:	c0 48       	rjmp	8000860c <_vfprintf_r+0x4e8>
80008606:	13 b8       	ld.ub	r8,r9[0x3]
80008608:	2f c9       	sub	r9,-4
8000860a:	51 09       	stdsp	sp[0x40],r9
8000860c:	fb 68 06 60 	st.b	sp[1632],r8
80008610:	30 0e       	mov	lr,0
80008612:	30 08       	mov	r8,0
80008614:	30 12       	mov	r2,1
80008616:	fb 68 06 bb 	st.b	sp[1723],r8
8000861a:	50 2e       	stdsp	sp[0x8],lr
8000861c:	e0 8f 08 ad 	bral	80009776 <_vfprintf_r+0x1652>
80008620:	50 a7       	stdsp	sp[0x28],r7
80008622:	50 80       	stdsp	sp[0x20],r0
80008624:	0c 97       	mov	r7,r6
80008626:	04 94       	mov	r4,r2
80008628:	06 96       	mov	r6,r3
8000862a:	02 92       	mov	r2,r1
8000862c:	40 93       	lddsp	r3,sp[0x24]
8000862e:	10 90       	mov	r0,r8
80008630:	40 41       	lddsp	r1,sp[0x10]
80008632:	a5 a5       	sbr	r5,0x4
80008634:	c0 a8       	rjmp	80008648 <_vfprintf_r+0x524>
80008636:	50 a7       	stdsp	sp[0x28],r7
80008638:	50 80       	stdsp	sp[0x20],r0
8000863a:	0c 97       	mov	r7,r6
8000863c:	04 94       	mov	r4,r2
8000863e:	06 96       	mov	r6,r3
80008640:	02 92       	mov	r2,r1
80008642:	40 93       	lddsp	r3,sp[0x24]
80008644:	10 90       	mov	r0,r8
80008646:	40 41       	lddsp	r1,sp[0x10]
80008648:	ed b5 00 05 	bld	r5,0x5
8000864c:	c5 11       	brne	800086ee <_vfprintf_r+0x5ca>
8000864e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008652:	40 3c       	lddsp	r12,sp[0xc]
80008654:	58 0c       	cp.w	r12,0
80008656:	c1 e0       	breq	80008692 <_vfprintf_r+0x56e>
80008658:	10 36       	cp.w	r6,r8
8000865a:	c0 64       	brge	80008666 <_vfprintf_r+0x542>
8000865c:	fa cb f9 44 	sub	r11,sp,-1724
80008660:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008664:	c2 08       	rjmp	800086a4 <_vfprintf_r+0x580>
80008666:	fa c8 f9 50 	sub	r8,sp,-1712
8000866a:	1a d8       	st.w	--sp,r8
8000866c:	fa c8 fa b8 	sub	r8,sp,-1352
80008670:	0c 9b       	mov	r11,r6
80008672:	1a d8       	st.w	--sp,r8
80008674:	fa c8 fb b4 	sub	r8,sp,-1100
80008678:	1a d8       	st.w	--sp,r8
8000867a:	fa c9 ff b4 	sub	r9,sp,-76
8000867e:	fa c8 f9 40 	sub	r8,sp,-1728
80008682:	04 9a       	mov	r10,r2
80008684:	08 9c       	mov	r12,r4
80008686:	fe b0 fb b7 	rcall	80007df4 <get_arg>
8000868a:	2f dd       	sub	sp,-12
8000868c:	78 1b       	ld.w	r11,r12[0x4]
8000868e:	78 09       	ld.w	r9,r12[0x0]
80008690:	c2 b8       	rjmp	800086e6 <_vfprintf_r+0x5c2>
80008692:	ee ca ff ff 	sub	r10,r7,-1
80008696:	10 37       	cp.w	r7,r8
80008698:	c0 b4       	brge	800086ae <_vfprintf_r+0x58a>
8000869a:	fa c9 f9 44 	sub	r9,sp,-1724
8000869e:	14 97       	mov	r7,r10
800086a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086a4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086a8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800086ac:	c1 d8       	rjmp	800086e6 <_vfprintf_r+0x5c2>
800086ae:	41 09       	lddsp	r9,sp[0x40]
800086b0:	59 f8       	cp.w	r8,31
800086b2:	e0 89 00 14 	brgt	800086da <_vfprintf_r+0x5b6>
800086b6:	f2 cb ff f8 	sub	r11,r9,-8
800086ba:	51 0b       	stdsp	sp[0x40],r11
800086bc:	fa c6 f9 44 	sub	r6,sp,-1724
800086c0:	72 1b       	ld.w	r11,r9[0x4]
800086c2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800086c6:	72 09       	ld.w	r9,r9[0x0]
800086c8:	f9 4b fd 8c 	st.w	r12[-628],r11
800086cc:	f9 49 fd 88 	st.w	r12[-632],r9
800086d0:	2f f8       	sub	r8,-1
800086d2:	14 97       	mov	r7,r10
800086d4:	fb 48 06 b4 	st.w	sp[1716],r8
800086d8:	c0 78       	rjmp	800086e6 <_vfprintf_r+0x5c2>
800086da:	f2 c8 ff f8 	sub	r8,r9,-8
800086de:	72 1b       	ld.w	r11,r9[0x4]
800086e0:	14 97       	mov	r7,r10
800086e2:	51 08       	stdsp	sp[0x40],r8
800086e4:	72 09       	ld.w	r9,r9[0x0]
800086e6:	16 98       	mov	r8,r11
800086e8:	fa e9 00 00 	st.d	sp[0],r8
800086ec:	ca e8       	rjmp	80008848 <_vfprintf_r+0x724>
800086ee:	ed b5 00 04 	bld	r5,0x4
800086f2:	c1 71       	brne	80008720 <_vfprintf_r+0x5fc>
800086f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f8:	40 3e       	lddsp	lr,sp[0xc]
800086fa:	58 0e       	cp.w	lr,0
800086fc:	c0 80       	breq	8000870c <_vfprintf_r+0x5e8>
800086fe:	10 36       	cp.w	r6,r8
80008700:	c6 94       	brge	800087d2 <_vfprintf_r+0x6ae>
80008702:	fa cc f9 44 	sub	r12,sp,-1724
80008706:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000870a:	c8 28       	rjmp	8000880e <_vfprintf_r+0x6ea>
8000870c:	ee ca ff ff 	sub	r10,r7,-1
80008710:	10 37       	cp.w	r7,r8
80008712:	e0 84 00 81 	brge	80008814 <_vfprintf_r+0x6f0>
80008716:	fa cb f9 44 	sub	r11,sp,-1724
8000871a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000871e:	c7 78       	rjmp	8000880c <_vfprintf_r+0x6e8>
80008720:	ed b5 00 06 	bld	r5,0x6
80008724:	c4 b1       	brne	800087ba <_vfprintf_r+0x696>
80008726:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000872a:	40 3c       	lddsp	r12,sp[0xc]
8000872c:	58 0c       	cp.w	r12,0
8000872e:	c1 d0       	breq	80008768 <_vfprintf_r+0x644>
80008730:	10 36       	cp.w	r6,r8
80008732:	c0 64       	brge	8000873e <_vfprintf_r+0x61a>
80008734:	fa cb f9 44 	sub	r11,sp,-1724
80008738:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000873c:	c1 f8       	rjmp	8000877a <_vfprintf_r+0x656>
8000873e:	fa c8 f9 50 	sub	r8,sp,-1712
80008742:	1a d8       	st.w	--sp,r8
80008744:	fa c8 fa b8 	sub	r8,sp,-1352
80008748:	1a d8       	st.w	--sp,r8
8000874a:	fa c8 fb b4 	sub	r8,sp,-1100
8000874e:	1a d8       	st.w	--sp,r8
80008750:	fa c8 f9 40 	sub	r8,sp,-1728
80008754:	fa c9 ff b4 	sub	r9,sp,-76
80008758:	04 9a       	mov	r10,r2
8000875a:	0c 9b       	mov	r11,r6
8000875c:	08 9c       	mov	r12,r4
8000875e:	fe b0 fb 4b 	rcall	80007df4 <get_arg>
80008762:	2f dd       	sub	sp,-12
80008764:	98 18       	ld.sh	r8,r12[0x2]
80008766:	c2 68       	rjmp	800087b2 <_vfprintf_r+0x68e>
80008768:	ee ca ff ff 	sub	r10,r7,-1
8000876c:	10 37       	cp.w	r7,r8
8000876e:	c0 94       	brge	80008780 <_vfprintf_r+0x65c>
80008770:	fa c9 f9 44 	sub	r9,sp,-1724
80008774:	14 97       	mov	r7,r10
80008776:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000877a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000877e:	c1 a8       	rjmp	800087b2 <_vfprintf_r+0x68e>
80008780:	41 09       	lddsp	r9,sp[0x40]
80008782:	59 f8       	cp.w	r8,31
80008784:	e0 89 00 13 	brgt	800087aa <_vfprintf_r+0x686>
80008788:	f2 cb ff fc 	sub	r11,r9,-4
8000878c:	51 0b       	stdsp	sp[0x40],r11
8000878e:	72 09       	ld.w	r9,r9[0x0]
80008790:	fa c6 f9 44 	sub	r6,sp,-1724
80008794:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008798:	2f f8       	sub	r8,-1
8000879a:	f7 49 fd 88 	st.w	r11[-632],r9
8000879e:	fb 48 06 b4 	st.w	sp[1716],r8
800087a2:	14 97       	mov	r7,r10
800087a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800087a8:	c0 58       	rjmp	800087b2 <_vfprintf_r+0x68e>
800087aa:	92 18       	ld.sh	r8,r9[0x2]
800087ac:	14 97       	mov	r7,r10
800087ae:	2f c9       	sub	r9,-4
800087b0:	51 09       	stdsp	sp[0x40],r9
800087b2:	50 18       	stdsp	sp[0x4],r8
800087b4:	bf 58       	asr	r8,0x1f
800087b6:	50 08       	stdsp	sp[0x0],r8
800087b8:	c4 88       	rjmp	80008848 <_vfprintf_r+0x724>
800087ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087be:	40 3c       	lddsp	r12,sp[0xc]
800087c0:	58 0c       	cp.w	r12,0
800087c2:	c1 d0       	breq	800087fc <_vfprintf_r+0x6d8>
800087c4:	10 36       	cp.w	r6,r8
800087c6:	c0 64       	brge	800087d2 <_vfprintf_r+0x6ae>
800087c8:	fa cb f9 44 	sub	r11,sp,-1724
800087cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087d0:	c1 f8       	rjmp	8000880e <_vfprintf_r+0x6ea>
800087d2:	fa c8 f9 50 	sub	r8,sp,-1712
800087d6:	1a d8       	st.w	--sp,r8
800087d8:	fa c8 fa b8 	sub	r8,sp,-1352
800087dc:	0c 9b       	mov	r11,r6
800087de:	1a d8       	st.w	--sp,r8
800087e0:	fa c8 fb b4 	sub	r8,sp,-1100
800087e4:	04 9a       	mov	r10,r2
800087e6:	1a d8       	st.w	--sp,r8
800087e8:	08 9c       	mov	r12,r4
800087ea:	fa c8 f9 40 	sub	r8,sp,-1728
800087ee:	fa c9 ff b4 	sub	r9,sp,-76
800087f2:	fe b0 fb 01 	rcall	80007df4 <get_arg>
800087f6:	2f dd       	sub	sp,-12
800087f8:	78 0b       	ld.w	r11,r12[0x0]
800087fa:	c2 48       	rjmp	80008842 <_vfprintf_r+0x71e>
800087fc:	ee ca ff ff 	sub	r10,r7,-1
80008800:	10 37       	cp.w	r7,r8
80008802:	c0 94       	brge	80008814 <_vfprintf_r+0x6f0>
80008804:	fa c9 f9 44 	sub	r9,sp,-1724
80008808:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000880c:	14 97       	mov	r7,r10
8000880e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008812:	c1 88       	rjmp	80008842 <_vfprintf_r+0x71e>
80008814:	41 09       	lddsp	r9,sp[0x40]
80008816:	59 f8       	cp.w	r8,31
80008818:	e0 89 00 11 	brgt	8000883a <_vfprintf_r+0x716>
8000881c:	f2 cb ff fc 	sub	r11,r9,-4
80008820:	51 0b       	stdsp	sp[0x40],r11
80008822:	fa c6 f9 44 	sub	r6,sp,-1724
80008826:	72 0b       	ld.w	r11,r9[0x0]
80008828:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000882c:	f3 4b fd 88 	st.w	r9[-632],r11
80008830:	2f f8       	sub	r8,-1
80008832:	14 97       	mov	r7,r10
80008834:	fb 48 06 b4 	st.w	sp[1716],r8
80008838:	c0 58       	rjmp	80008842 <_vfprintf_r+0x71e>
8000883a:	72 0b       	ld.w	r11,r9[0x0]
8000883c:	14 97       	mov	r7,r10
8000883e:	2f c9       	sub	r9,-4
80008840:	51 09       	stdsp	sp[0x40],r9
80008842:	50 1b       	stdsp	sp[0x4],r11
80008844:	bf 5b       	asr	r11,0x1f
80008846:	50 0b       	stdsp	sp[0x0],r11
80008848:	fa ea 00 00 	ld.d	r10,sp[0]
8000884c:	58 0a       	cp.w	r10,0
8000884e:	5c 2b       	cpc	r11
80008850:	c0 e4       	brge	8000886c <_vfprintf_r+0x748>
80008852:	30 08       	mov	r8,0
80008854:	fa ea 00 00 	ld.d	r10,sp[0]
80008858:	30 09       	mov	r9,0
8000885a:	f0 0a 01 0a 	sub	r10,r8,r10
8000885e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008862:	32 d8       	mov	r8,45
80008864:	fa eb 00 00 	st.d	sp[0],r10
80008868:	fb 68 06 bb 	st.b	sp[1723],r8
8000886c:	30 18       	mov	r8,1
8000886e:	e0 8f 06 fa 	bral	80009662 <_vfprintf_r+0x153e>
80008872:	50 a7       	stdsp	sp[0x28],r7
80008874:	50 80       	stdsp	sp[0x20],r0
80008876:	0c 97       	mov	r7,r6
80008878:	04 94       	mov	r4,r2
8000887a:	06 96       	mov	r6,r3
8000887c:	02 92       	mov	r2,r1
8000887e:	40 93       	lddsp	r3,sp[0x24]
80008880:	10 90       	mov	r0,r8
80008882:	40 41       	lddsp	r1,sp[0x10]
80008884:	0e 99       	mov	r9,r7
80008886:	ed b5 00 03 	bld	r5,0x3
8000888a:	c4 11       	brne	8000890c <_vfprintf_r+0x7e8>
8000888c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008890:	40 3a       	lddsp	r10,sp[0xc]
80008892:	58 0a       	cp.w	r10,0
80008894:	c1 90       	breq	800088c6 <_vfprintf_r+0x7a2>
80008896:	10 36       	cp.w	r6,r8
80008898:	c6 45       	brlt	80008960 <_vfprintf_r+0x83c>
8000889a:	fa c8 f9 50 	sub	r8,sp,-1712
8000889e:	1a d8       	st.w	--sp,r8
800088a0:	fa c8 fa b8 	sub	r8,sp,-1352
800088a4:	1a d8       	st.w	--sp,r8
800088a6:	fa c8 fb b4 	sub	r8,sp,-1100
800088aa:	0c 9b       	mov	r11,r6
800088ac:	1a d8       	st.w	--sp,r8
800088ae:	04 9a       	mov	r10,r2
800088b0:	fa c8 f9 40 	sub	r8,sp,-1728
800088b4:	fa c9 ff b4 	sub	r9,sp,-76
800088b8:	08 9c       	mov	r12,r4
800088ba:	fe b0 fa 9d 	rcall	80007df4 <get_arg>
800088be:	2f dd       	sub	sp,-12
800088c0:	78 16       	ld.w	r6,r12[0x4]
800088c2:	50 76       	stdsp	sp[0x1c],r6
800088c4:	c4 88       	rjmp	80008954 <_vfprintf_r+0x830>
800088c6:	2f f7       	sub	r7,-1
800088c8:	10 39       	cp.w	r9,r8
800088ca:	c0 c4       	brge	800088e2 <_vfprintf_r+0x7be>
800088cc:	fa ce f9 44 	sub	lr,sp,-1724
800088d0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800088d4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800088d8:	50 7c       	stdsp	sp[0x1c],r12
800088da:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088de:	50 56       	stdsp	sp[0x14],r6
800088e0:	c6 68       	rjmp	800089ac <_vfprintf_r+0x888>
800088e2:	41 09       	lddsp	r9,sp[0x40]
800088e4:	59 f8       	cp.w	r8,31
800088e6:	e0 89 00 10 	brgt	80008906 <_vfprintf_r+0x7e2>
800088ea:	f2 ca ff f8 	sub	r10,r9,-8
800088ee:	72 1b       	ld.w	r11,r9[0x4]
800088f0:	51 0a       	stdsp	sp[0x40],r10
800088f2:	72 09       	ld.w	r9,r9[0x0]
800088f4:	fa ca f9 44 	sub	r10,sp,-1724
800088f8:	50 7b       	stdsp	sp[0x1c],r11
800088fa:	50 59       	stdsp	sp[0x14],r9
800088fc:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008900:	40 5b       	lddsp	r11,sp[0x14]
80008902:	40 7a       	lddsp	r10,sp[0x1c]
80008904:	c4 78       	rjmp	80008992 <_vfprintf_r+0x86e>
80008906:	72 18       	ld.w	r8,r9[0x4]
80008908:	50 78       	stdsp	sp[0x1c],r8
8000890a:	c4 c8       	rjmp	800089a2 <_vfprintf_r+0x87e>
8000890c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008910:	40 3e       	lddsp	lr,sp[0xc]
80008912:	58 0e       	cp.w	lr,0
80008914:	c2 30       	breq	8000895a <_vfprintf_r+0x836>
80008916:	10 36       	cp.w	r6,r8
80008918:	c0 94       	brge	8000892a <_vfprintf_r+0x806>
8000891a:	fa cc f9 44 	sub	r12,sp,-1724
8000891e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008922:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008926:	50 7b       	stdsp	sp[0x1c],r11
80008928:	cd 9b       	rjmp	800088da <_vfprintf_r+0x7b6>
8000892a:	fa c8 f9 50 	sub	r8,sp,-1712
8000892e:	1a d8       	st.w	--sp,r8
80008930:	fa c8 fa b8 	sub	r8,sp,-1352
80008934:	04 9a       	mov	r10,r2
80008936:	1a d8       	st.w	--sp,r8
80008938:	fa c8 fb b4 	sub	r8,sp,-1100
8000893c:	0c 9b       	mov	r11,r6
8000893e:	1a d8       	st.w	--sp,r8
80008940:	08 9c       	mov	r12,r4
80008942:	fa c8 f9 40 	sub	r8,sp,-1728
80008946:	fa c9 ff b4 	sub	r9,sp,-76
8000894a:	fe b0 fa 55 	rcall	80007df4 <get_arg>
8000894e:	2f dd       	sub	sp,-12
80008950:	78 1a       	ld.w	r10,r12[0x4]
80008952:	50 7a       	stdsp	sp[0x1c],r10
80008954:	78 0c       	ld.w	r12,r12[0x0]
80008956:	50 5c       	stdsp	sp[0x14],r12
80008958:	c2 a8       	rjmp	800089ac <_vfprintf_r+0x888>
8000895a:	2f f7       	sub	r7,-1
8000895c:	10 39       	cp.w	r9,r8
8000895e:	c0 94       	brge	80008970 <_vfprintf_r+0x84c>
80008960:	fa c9 f9 44 	sub	r9,sp,-1724
80008964:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008968:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000896c:	50 78       	stdsp	sp[0x1c],r8
8000896e:	cb 6b       	rjmp	800088da <_vfprintf_r+0x7b6>
80008970:	41 09       	lddsp	r9,sp[0x40]
80008972:	59 f8       	cp.w	r8,31
80008974:	e0 89 00 15 	brgt	8000899e <_vfprintf_r+0x87a>
80008978:	f2 ca ff f8 	sub	r10,r9,-8
8000897c:	72 16       	ld.w	r6,r9[0x4]
8000897e:	72 09       	ld.w	r9,r9[0x0]
80008980:	51 0a       	stdsp	sp[0x40],r10
80008982:	50 59       	stdsp	sp[0x14],r9
80008984:	fa ce f9 44 	sub	lr,sp,-1724
80008988:	50 76       	stdsp	sp[0x1c],r6
8000898a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000898e:	40 5b       	lddsp	r11,sp[0x14]
80008990:	0c 9a       	mov	r10,r6
80008992:	f2 eb fd 88 	st.d	r9[-632],r10
80008996:	2f f8       	sub	r8,-1
80008998:	fb 48 06 b4 	st.w	sp[1716],r8
8000899c:	c0 88       	rjmp	800089ac <_vfprintf_r+0x888>
8000899e:	72 1c       	ld.w	r12,r9[0x4]
800089a0:	50 7c       	stdsp	sp[0x1c],r12
800089a2:	f2 c8 ff f8 	sub	r8,r9,-8
800089a6:	51 08       	stdsp	sp[0x40],r8
800089a8:	72 09       	ld.w	r9,r9[0x0]
800089aa:	50 59       	stdsp	sp[0x14],r9
800089ac:	40 5b       	lddsp	r11,sp[0x14]
800089ae:	40 7a       	lddsp	r10,sp[0x1c]
800089b0:	e0 a0 19 54 	rcall	8000bc58 <__isinfd>
800089b4:	18 96       	mov	r6,r12
800089b6:	c1 70       	breq	800089e4 <_vfprintf_r+0x8c0>
800089b8:	30 08       	mov	r8,0
800089ba:	30 09       	mov	r9,0
800089bc:	40 5b       	lddsp	r11,sp[0x14]
800089be:	40 7a       	lddsp	r10,sp[0x1c]
800089c0:	e0 a0 1d b4 	rcall	8000c528 <__avr32_f64_cmp_lt>
800089c4:	c0 40       	breq	800089cc <_vfprintf_r+0x8a8>
800089c6:	32 d8       	mov	r8,45
800089c8:	fb 68 06 bb 	st.b	sp[1723],r8
800089cc:	fe c8 aa 0c 	sub	r8,pc,-22004
800089d0:	fe c6 aa 0c 	sub	r6,pc,-22004
800089d4:	a7 d5       	cbr	r5,0x7
800089d6:	e0 40 00 47 	cp.w	r0,71
800089da:	f0 06 17 a0 	movle	r6,r8
800089de:	30 32       	mov	r2,3
800089e0:	e0 8f 06 ce 	bral	8000977c <_vfprintf_r+0x1658>
800089e4:	40 5b       	lddsp	r11,sp[0x14]
800089e6:	40 7a       	lddsp	r10,sp[0x1c]
800089e8:	e0 a0 19 4d 	rcall	8000bc82 <__isnand>
800089ec:	c0 e0       	breq	80008a08 <_vfprintf_r+0x8e4>
800089ee:	50 26       	stdsp	sp[0x8],r6
800089f0:	fe c8 aa 28 	sub	r8,pc,-21976
800089f4:	fe c6 aa 28 	sub	r6,pc,-21976
800089f8:	a7 d5       	cbr	r5,0x7
800089fa:	e0 40 00 47 	cp.w	r0,71
800089fe:	f0 06 17 a0 	movle	r6,r8
80008a02:	30 32       	mov	r2,3
80008a04:	e0 8f 06 c2 	bral	80009788 <_vfprintf_r+0x1664>
80008a08:	40 2a       	lddsp	r10,sp[0x8]
80008a0a:	5b fa       	cp.w	r10,-1
80008a0c:	c0 41       	brne	80008a14 <_vfprintf_r+0x8f0>
80008a0e:	30 69       	mov	r9,6
80008a10:	50 29       	stdsp	sp[0x8],r9
80008a12:	c1 18       	rjmp	80008a34 <_vfprintf_r+0x910>
80008a14:	e0 40 00 47 	cp.w	r0,71
80008a18:	5f 09       	sreq	r9
80008a1a:	e0 40 00 67 	cp.w	r0,103
80008a1e:	5f 08       	sreq	r8
80008a20:	f3 e8 10 08 	or	r8,r9,r8
80008a24:	f8 08 18 00 	cp.b	r8,r12
80008a28:	c0 60       	breq	80008a34 <_vfprintf_r+0x910>
80008a2a:	40 28       	lddsp	r8,sp[0x8]
80008a2c:	58 08       	cp.w	r8,0
80008a2e:	f9 b8 00 01 	moveq	r8,1
80008a32:	50 28       	stdsp	sp[0x8],r8
80008a34:	40 78       	lddsp	r8,sp[0x1c]
80008a36:	40 59       	lddsp	r9,sp[0x14]
80008a38:	fa e9 06 94 	st.d	sp[1684],r8
80008a3c:	a9 a5       	sbr	r5,0x8
80008a3e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a42:	58 08       	cp.w	r8,0
80008a44:	c0 65       	brlt	80008a50 <_vfprintf_r+0x92c>
80008a46:	40 5e       	lddsp	lr,sp[0x14]
80008a48:	30 0c       	mov	r12,0
80008a4a:	50 6e       	stdsp	sp[0x18],lr
80008a4c:	50 9c       	stdsp	sp[0x24],r12
80008a4e:	c0 78       	rjmp	80008a5c <_vfprintf_r+0x938>
80008a50:	40 5b       	lddsp	r11,sp[0x14]
80008a52:	32 da       	mov	r10,45
80008a54:	ee 1b 80 00 	eorh	r11,0x8000
80008a58:	50 9a       	stdsp	sp[0x24],r10
80008a5a:	50 6b       	stdsp	sp[0x18],r11
80008a5c:	e0 40 00 46 	cp.w	r0,70
80008a60:	5f 09       	sreq	r9
80008a62:	e0 40 00 66 	cp.w	r0,102
80008a66:	5f 08       	sreq	r8
80008a68:	f3 e8 10 08 	or	r8,r9,r8
80008a6c:	50 48       	stdsp	sp[0x10],r8
80008a6e:	c0 40       	breq	80008a76 <_vfprintf_r+0x952>
80008a70:	40 22       	lddsp	r2,sp[0x8]
80008a72:	30 39       	mov	r9,3
80008a74:	c1 08       	rjmp	80008a94 <_vfprintf_r+0x970>
80008a76:	e0 40 00 45 	cp.w	r0,69
80008a7a:	5f 09       	sreq	r9
80008a7c:	e0 40 00 65 	cp.w	r0,101
80008a80:	5f 08       	sreq	r8
80008a82:	40 22       	lddsp	r2,sp[0x8]
80008a84:	10 49       	or	r9,r8
80008a86:	2f f2       	sub	r2,-1
80008a88:	40 46       	lddsp	r6,sp[0x10]
80008a8a:	ec 09 18 00 	cp.b	r9,r6
80008a8e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a92:	30 29       	mov	r9,2
80008a94:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a98:	1a d8       	st.w	--sp,r8
80008a9a:	fa c8 f9 54 	sub	r8,sp,-1708
80008a9e:	1a d8       	st.w	--sp,r8
80008aa0:	fa c8 f9 4c 	sub	r8,sp,-1716
80008aa4:	08 9c       	mov	r12,r4
80008aa6:	1a d8       	st.w	--sp,r8
80008aa8:	04 98       	mov	r8,r2
80008aaa:	40 9b       	lddsp	r11,sp[0x24]
80008aac:	40 aa       	lddsp	r10,sp[0x28]
80008aae:	e0 a0 0b c3 	rcall	8000a234 <_dtoa_r>
80008ab2:	e0 40 00 47 	cp.w	r0,71
80008ab6:	5f 19       	srne	r9
80008ab8:	e0 40 00 67 	cp.w	r0,103
80008abc:	5f 18       	srne	r8
80008abe:	18 96       	mov	r6,r12
80008ac0:	2f dd       	sub	sp,-12
80008ac2:	f3 e8 00 08 	and	r8,r9,r8
80008ac6:	c0 41       	brne	80008ace <_vfprintf_r+0x9aa>
80008ac8:	ed b5 00 00 	bld	r5,0x0
80008acc:	c3 01       	brne	80008b2c <_vfprintf_r+0xa08>
80008ace:	ec 02 00 0e 	add	lr,r6,r2
80008ad2:	50 3e       	stdsp	sp[0xc],lr
80008ad4:	40 4c       	lddsp	r12,sp[0x10]
80008ad6:	58 0c       	cp.w	r12,0
80008ad8:	c1 50       	breq	80008b02 <_vfprintf_r+0x9de>
80008ada:	0d 89       	ld.ub	r9,r6[0x0]
80008adc:	33 08       	mov	r8,48
80008ade:	f0 09 18 00 	cp.b	r9,r8
80008ae2:	c0 b1       	brne	80008af8 <_vfprintf_r+0x9d4>
80008ae4:	30 08       	mov	r8,0
80008ae6:	30 09       	mov	r9,0
80008ae8:	40 6b       	lddsp	r11,sp[0x18]
80008aea:	40 7a       	lddsp	r10,sp[0x1c]
80008aec:	e0 a0 1c d7 	rcall	8000c49a <__avr32_f64_cmp_eq>
80008af0:	fb b2 00 01 	rsubeq	r2,1
80008af4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008af8:	40 3b       	lddsp	r11,sp[0xc]
80008afa:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008afe:	10 0b       	add	r11,r8
80008b00:	50 3b       	stdsp	sp[0xc],r11
80008b02:	40 6b       	lddsp	r11,sp[0x18]
80008b04:	30 08       	mov	r8,0
80008b06:	30 09       	mov	r9,0
80008b08:	40 7a       	lddsp	r10,sp[0x1c]
80008b0a:	e0 a0 1c c8 	rcall	8000c49a <__avr32_f64_cmp_eq>
80008b0e:	c0 90       	breq	80008b20 <_vfprintf_r+0x9fc>
80008b10:	40 3a       	lddsp	r10,sp[0xc]
80008b12:	fb 4a 06 a4 	st.w	sp[1700],r10
80008b16:	c0 58       	rjmp	80008b20 <_vfprintf_r+0x9fc>
80008b18:	10 c9       	st.b	r8++,r9
80008b1a:	fb 48 06 a4 	st.w	sp[1700],r8
80008b1e:	c0 28       	rjmp	80008b22 <_vfprintf_r+0x9fe>
80008b20:	33 09       	mov	r9,48
80008b22:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b26:	40 3e       	lddsp	lr,sp[0xc]
80008b28:	1c 38       	cp.w	r8,lr
80008b2a:	cf 73       	brcs	80008b18 <_vfprintf_r+0x9f4>
80008b2c:	e0 40 00 47 	cp.w	r0,71
80008b30:	5f 09       	sreq	r9
80008b32:	e0 40 00 67 	cp.w	r0,103
80008b36:	5f 08       	sreq	r8
80008b38:	f3 e8 10 08 	or	r8,r9,r8
80008b3c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b40:	0c 19       	sub	r9,r6
80008b42:	50 69       	stdsp	sp[0x18],r9
80008b44:	58 08       	cp.w	r8,0
80008b46:	c0 b0       	breq	80008b5c <_vfprintf_r+0xa38>
80008b48:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b4c:	5b d8       	cp.w	r8,-3
80008b4e:	c0 55       	brlt	80008b58 <_vfprintf_r+0xa34>
80008b50:	40 2c       	lddsp	r12,sp[0x8]
80008b52:	18 38       	cp.w	r8,r12
80008b54:	e0 8a 00 6a 	brle	80008c28 <_vfprintf_r+0xb04>
80008b58:	20 20       	sub	r0,2
80008b5a:	c0 58       	rjmp	80008b64 <_vfprintf_r+0xa40>
80008b5c:	e0 40 00 65 	cp.w	r0,101
80008b60:	e0 89 00 46 	brgt	80008bec <_vfprintf_r+0xac8>
80008b64:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b68:	fb 60 06 9c 	st.b	sp[1692],r0
80008b6c:	20 1b       	sub	r11,1
80008b6e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b72:	c0 47       	brpl	80008b7a <_vfprintf_r+0xa56>
80008b74:	5c 3b       	neg	r11
80008b76:	32 d8       	mov	r8,45
80008b78:	c0 28       	rjmp	80008b7c <_vfprintf_r+0xa58>
80008b7a:	32 b8       	mov	r8,43
80008b7c:	fb 68 06 9d 	st.b	sp[1693],r8
80008b80:	58 9b       	cp.w	r11,9
80008b82:	e0 8a 00 1d 	brle	80008bbc <_vfprintf_r+0xa98>
80008b86:	fa c9 fa 35 	sub	r9,sp,-1483
80008b8a:	30 aa       	mov	r10,10
80008b8c:	12 98       	mov	r8,r9
80008b8e:	0e 9c       	mov	r12,r7
80008b90:	0c 92       	mov	r2,r6
80008b92:	f6 0a 0c 06 	divs	r6,r11,r10
80008b96:	0e 9b       	mov	r11,r7
80008b98:	2d 0b       	sub	r11,-48
80008b9a:	10 fb       	st.b	--r8,r11
80008b9c:	0c 9b       	mov	r11,r6
80008b9e:	58 96       	cp.w	r6,9
80008ba0:	fe 99 ff f9 	brgt	80008b92 <_vfprintf_r+0xa6e>
80008ba4:	2d 0b       	sub	r11,-48
80008ba6:	18 97       	mov	r7,r12
80008ba8:	04 96       	mov	r6,r2
80008baa:	10 fb       	st.b	--r8,r11
80008bac:	fa ca f9 62 	sub	r10,sp,-1694
80008bb0:	c0 38       	rjmp	80008bb6 <_vfprintf_r+0xa92>
80008bb2:	11 3b       	ld.ub	r11,r8++
80008bb4:	14 cb       	st.b	r10++,r11
80008bb6:	12 38       	cp.w	r8,r9
80008bb8:	cf d3       	brcs	80008bb2 <_vfprintf_r+0xa8e>
80008bba:	c0 98       	rjmp	80008bcc <_vfprintf_r+0xaa8>
80008bbc:	2d 0b       	sub	r11,-48
80008bbe:	33 08       	mov	r8,48
80008bc0:	fb 6b 06 9f 	st.b	sp[1695],r11
80008bc4:	fb 68 06 9e 	st.b	sp[1694],r8
80008bc8:	fa ca f9 60 	sub	r10,sp,-1696
80008bcc:	fa c8 f9 64 	sub	r8,sp,-1692
80008bd0:	f4 08 01 08 	sub	r8,r10,r8
80008bd4:	50 e8       	stdsp	sp[0x38],r8
80008bd6:	10 92       	mov	r2,r8
80008bd8:	40 6b       	lddsp	r11,sp[0x18]
80008bda:	16 02       	add	r2,r11
80008bdc:	58 1b       	cp.w	r11,1
80008bde:	e0 89 00 05 	brgt	80008be8 <_vfprintf_r+0xac4>
80008be2:	ed b5 00 00 	bld	r5,0x0
80008be6:	c3 51       	brne	80008c50 <_vfprintf_r+0xb2c>
80008be8:	2f f2       	sub	r2,-1
80008bea:	c3 38       	rjmp	80008c50 <_vfprintf_r+0xb2c>
80008bec:	e0 40 00 66 	cp.w	r0,102
80008bf0:	c1 c1       	brne	80008c28 <_vfprintf_r+0xb04>
80008bf2:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bf6:	58 02       	cp.w	r2,0
80008bf8:	e0 8a 00 0c 	brle	80008c10 <_vfprintf_r+0xaec>
80008bfc:	40 2a       	lddsp	r10,sp[0x8]
80008bfe:	58 0a       	cp.w	r10,0
80008c00:	c0 41       	brne	80008c08 <_vfprintf_r+0xae4>
80008c02:	ed b5 00 00 	bld	r5,0x0
80008c06:	c2 51       	brne	80008c50 <_vfprintf_r+0xb2c>
80008c08:	2f f2       	sub	r2,-1
80008c0a:	40 29       	lddsp	r9,sp[0x8]
80008c0c:	12 02       	add	r2,r9
80008c0e:	c0 b8       	rjmp	80008c24 <_vfprintf_r+0xb00>
80008c10:	40 28       	lddsp	r8,sp[0x8]
80008c12:	58 08       	cp.w	r8,0
80008c14:	c0 61       	brne	80008c20 <_vfprintf_r+0xafc>
80008c16:	ed b5 00 00 	bld	r5,0x0
80008c1a:	c0 30       	breq	80008c20 <_vfprintf_r+0xafc>
80008c1c:	30 12       	mov	r2,1
80008c1e:	c1 98       	rjmp	80008c50 <_vfprintf_r+0xb2c>
80008c20:	40 22       	lddsp	r2,sp[0x8]
80008c22:	2f e2       	sub	r2,-2
80008c24:	36 60       	mov	r0,102
80008c26:	c1 58       	rjmp	80008c50 <_vfprintf_r+0xb2c>
80008c28:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c2c:	40 6e       	lddsp	lr,sp[0x18]
80008c2e:	1c 32       	cp.w	r2,lr
80008c30:	c0 65       	brlt	80008c3c <_vfprintf_r+0xb18>
80008c32:	ed b5 00 00 	bld	r5,0x0
80008c36:	f7 b2 00 ff 	subeq	r2,-1
80008c3a:	c0 a8       	rjmp	80008c4e <_vfprintf_r+0xb2a>
80008c3c:	e4 08 11 02 	rsub	r8,r2,2
80008c40:	40 6c       	lddsp	r12,sp[0x18]
80008c42:	58 02       	cp.w	r2,0
80008c44:	f0 02 17 a0 	movle	r2,r8
80008c48:	f9 b2 09 01 	movgt	r2,1
80008c4c:	18 02       	add	r2,r12
80008c4e:	36 70       	mov	r0,103
80008c50:	40 9b       	lddsp	r11,sp[0x24]
80008c52:	58 0b       	cp.w	r11,0
80008c54:	e0 80 05 94 	breq	8000977c <_vfprintf_r+0x1658>
80008c58:	32 d8       	mov	r8,45
80008c5a:	fb 68 06 bb 	st.b	sp[1723],r8
80008c5e:	e0 8f 05 93 	bral	80009784 <_vfprintf_r+0x1660>
80008c62:	50 a7       	stdsp	sp[0x28],r7
80008c64:	04 94       	mov	r4,r2
80008c66:	0c 97       	mov	r7,r6
80008c68:	02 92       	mov	r2,r1
80008c6a:	06 96       	mov	r6,r3
80008c6c:	40 41       	lddsp	r1,sp[0x10]
80008c6e:	40 93       	lddsp	r3,sp[0x24]
80008c70:	0e 99       	mov	r9,r7
80008c72:	ed b5 00 05 	bld	r5,0x5
80008c76:	c4 81       	brne	80008d06 <_vfprintf_r+0xbe2>
80008c78:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c7c:	40 3e       	lddsp	lr,sp[0xc]
80008c7e:	58 0e       	cp.w	lr,0
80008c80:	c1 d0       	breq	80008cba <_vfprintf_r+0xb96>
80008c82:	10 36       	cp.w	r6,r8
80008c84:	c0 64       	brge	80008c90 <_vfprintf_r+0xb6c>
80008c86:	fa cc f9 44 	sub	r12,sp,-1724
80008c8a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c8e:	c1 d8       	rjmp	80008cc8 <_vfprintf_r+0xba4>
80008c90:	fa c8 f9 50 	sub	r8,sp,-1712
80008c94:	1a d8       	st.w	--sp,r8
80008c96:	fa c8 fa b8 	sub	r8,sp,-1352
80008c9a:	04 9a       	mov	r10,r2
80008c9c:	1a d8       	st.w	--sp,r8
80008c9e:	fa c8 fb b4 	sub	r8,sp,-1100
80008ca2:	0c 9b       	mov	r11,r6
80008ca4:	1a d8       	st.w	--sp,r8
80008ca6:	08 9c       	mov	r12,r4
80008ca8:	fa c8 f9 40 	sub	r8,sp,-1728
80008cac:	fa c9 ff b4 	sub	r9,sp,-76
80008cb0:	fe b0 f8 a2 	rcall	80007df4 <get_arg>
80008cb4:	2f dd       	sub	sp,-12
80008cb6:	78 0a       	ld.w	r10,r12[0x0]
80008cb8:	c2 08       	rjmp	80008cf8 <_vfprintf_r+0xbd4>
80008cba:	2f f7       	sub	r7,-1
80008cbc:	10 39       	cp.w	r9,r8
80008cbe:	c0 84       	brge	80008cce <_vfprintf_r+0xbaa>
80008cc0:	fa cb f9 44 	sub	r11,sp,-1724
80008cc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cc8:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ccc:	c1 68       	rjmp	80008cf8 <_vfprintf_r+0xbd4>
80008cce:	41 09       	lddsp	r9,sp[0x40]
80008cd0:	59 f8       	cp.w	r8,31
80008cd2:	e0 89 00 10 	brgt	80008cf2 <_vfprintf_r+0xbce>
80008cd6:	f2 ca ff fc 	sub	r10,r9,-4
80008cda:	51 0a       	stdsp	sp[0x40],r10
80008cdc:	fa c6 f9 44 	sub	r6,sp,-1724
80008ce0:	72 0a       	ld.w	r10,r9[0x0]
80008ce2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ce6:	f3 4a fd 88 	st.w	r9[-632],r10
80008cea:	2f f8       	sub	r8,-1
80008cec:	fb 48 06 b4 	st.w	sp[1716],r8
80008cf0:	c0 48       	rjmp	80008cf8 <_vfprintf_r+0xbd4>
80008cf2:	72 0a       	ld.w	r10,r9[0x0]
80008cf4:	2f c9       	sub	r9,-4
80008cf6:	51 09       	stdsp	sp[0x40],r9
80008cf8:	40 be       	lddsp	lr,sp[0x2c]
80008cfa:	1c 98       	mov	r8,lr
80008cfc:	95 1e       	st.w	r10[0x4],lr
80008cfe:	bf 58       	asr	r8,0x1f
80008d00:	95 08       	st.w	r10[0x0],r8
80008d02:	fe 9f fa 9f 	bral	80008240 <_vfprintf_r+0x11c>
80008d06:	ed b5 00 04 	bld	r5,0x4
80008d0a:	c4 80       	breq	80008d9a <_vfprintf_r+0xc76>
80008d0c:	e2 15 00 40 	andl	r5,0x40,COH
80008d10:	c4 50       	breq	80008d9a <_vfprintf_r+0xc76>
80008d12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d16:	40 3c       	lddsp	r12,sp[0xc]
80008d18:	58 0c       	cp.w	r12,0
80008d1a:	c1 d0       	breq	80008d54 <_vfprintf_r+0xc30>
80008d1c:	10 36       	cp.w	r6,r8
80008d1e:	c0 64       	brge	80008d2a <_vfprintf_r+0xc06>
80008d20:	fa cb f9 44 	sub	r11,sp,-1724
80008d24:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d28:	c1 d8       	rjmp	80008d62 <_vfprintf_r+0xc3e>
80008d2a:	fa c8 f9 50 	sub	r8,sp,-1712
80008d2e:	1a d8       	st.w	--sp,r8
80008d30:	fa c8 fa b8 	sub	r8,sp,-1352
80008d34:	04 9a       	mov	r10,r2
80008d36:	1a d8       	st.w	--sp,r8
80008d38:	fa c8 fb b4 	sub	r8,sp,-1100
80008d3c:	0c 9b       	mov	r11,r6
80008d3e:	1a d8       	st.w	--sp,r8
80008d40:	08 9c       	mov	r12,r4
80008d42:	fa c8 f9 40 	sub	r8,sp,-1728
80008d46:	fa c9 ff b4 	sub	r9,sp,-76
80008d4a:	fe b0 f8 55 	rcall	80007df4 <get_arg>
80008d4e:	2f dd       	sub	sp,-12
80008d50:	78 0a       	ld.w	r10,r12[0x0]
80008d52:	c2 08       	rjmp	80008d92 <_vfprintf_r+0xc6e>
80008d54:	2f f7       	sub	r7,-1
80008d56:	10 39       	cp.w	r9,r8
80008d58:	c0 84       	brge	80008d68 <_vfprintf_r+0xc44>
80008d5a:	fa ca f9 44 	sub	r10,sp,-1724
80008d5e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d62:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d66:	c1 68       	rjmp	80008d92 <_vfprintf_r+0xc6e>
80008d68:	41 09       	lddsp	r9,sp[0x40]
80008d6a:	59 f8       	cp.w	r8,31
80008d6c:	e0 89 00 10 	brgt	80008d8c <_vfprintf_r+0xc68>
80008d70:	f2 ca ff fc 	sub	r10,r9,-4
80008d74:	51 0a       	stdsp	sp[0x40],r10
80008d76:	fa c6 f9 44 	sub	r6,sp,-1724
80008d7a:	72 0a       	ld.w	r10,r9[0x0]
80008d7c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d80:	f3 4a fd 88 	st.w	r9[-632],r10
80008d84:	2f f8       	sub	r8,-1
80008d86:	fb 48 06 b4 	st.w	sp[1716],r8
80008d8a:	c0 48       	rjmp	80008d92 <_vfprintf_r+0xc6e>
80008d8c:	72 0a       	ld.w	r10,r9[0x0]
80008d8e:	2f c9       	sub	r9,-4
80008d90:	51 09       	stdsp	sp[0x40],r9
80008d92:	40 be       	lddsp	lr,sp[0x2c]
80008d94:	b4 0e       	st.h	r10[0x0],lr
80008d96:	fe 9f fa 55 	bral	80008240 <_vfprintf_r+0x11c>
80008d9a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d9e:	40 3c       	lddsp	r12,sp[0xc]
80008da0:	58 0c       	cp.w	r12,0
80008da2:	c1 d0       	breq	80008ddc <_vfprintf_r+0xcb8>
80008da4:	10 36       	cp.w	r6,r8
80008da6:	c0 64       	brge	80008db2 <_vfprintf_r+0xc8e>
80008da8:	fa cb f9 44 	sub	r11,sp,-1724
80008dac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008db0:	c1 d8       	rjmp	80008dea <_vfprintf_r+0xcc6>
80008db2:	fa c8 f9 50 	sub	r8,sp,-1712
80008db6:	1a d8       	st.w	--sp,r8
80008db8:	fa c8 fa b8 	sub	r8,sp,-1352
80008dbc:	04 9a       	mov	r10,r2
80008dbe:	1a d8       	st.w	--sp,r8
80008dc0:	fa c8 fb b4 	sub	r8,sp,-1100
80008dc4:	0c 9b       	mov	r11,r6
80008dc6:	1a d8       	st.w	--sp,r8
80008dc8:	08 9c       	mov	r12,r4
80008dca:	fa c8 f9 40 	sub	r8,sp,-1728
80008dce:	fa c9 ff b4 	sub	r9,sp,-76
80008dd2:	fe b0 f8 11 	rcall	80007df4 <get_arg>
80008dd6:	2f dd       	sub	sp,-12
80008dd8:	78 0a       	ld.w	r10,r12[0x0]
80008dda:	c2 08       	rjmp	80008e1a <_vfprintf_r+0xcf6>
80008ddc:	2f f7       	sub	r7,-1
80008dde:	10 39       	cp.w	r9,r8
80008de0:	c0 84       	brge	80008df0 <_vfprintf_r+0xccc>
80008de2:	fa ca f9 44 	sub	r10,sp,-1724
80008de6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dea:	ec fa fd 88 	ld.w	r10,r6[-632]
80008dee:	c1 68       	rjmp	80008e1a <_vfprintf_r+0xcf6>
80008df0:	41 09       	lddsp	r9,sp[0x40]
80008df2:	59 f8       	cp.w	r8,31
80008df4:	e0 89 00 10 	brgt	80008e14 <_vfprintf_r+0xcf0>
80008df8:	f2 ca ff fc 	sub	r10,r9,-4
80008dfc:	51 0a       	stdsp	sp[0x40],r10
80008dfe:	fa c6 f9 44 	sub	r6,sp,-1724
80008e02:	72 0a       	ld.w	r10,r9[0x0]
80008e04:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e08:	f3 4a fd 88 	st.w	r9[-632],r10
80008e0c:	2f f8       	sub	r8,-1
80008e0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008e12:	c0 48       	rjmp	80008e1a <_vfprintf_r+0xcf6>
80008e14:	72 0a       	ld.w	r10,r9[0x0]
80008e16:	2f c9       	sub	r9,-4
80008e18:	51 09       	stdsp	sp[0x40],r9
80008e1a:	40 be       	lddsp	lr,sp[0x2c]
80008e1c:	95 0e       	st.w	r10[0x0],lr
80008e1e:	fe 9f fa 11 	bral	80008240 <_vfprintf_r+0x11c>
80008e22:	50 a7       	stdsp	sp[0x28],r7
80008e24:	50 80       	stdsp	sp[0x20],r0
80008e26:	0c 97       	mov	r7,r6
80008e28:	04 94       	mov	r4,r2
80008e2a:	06 96       	mov	r6,r3
80008e2c:	02 92       	mov	r2,r1
80008e2e:	40 93       	lddsp	r3,sp[0x24]
80008e30:	10 90       	mov	r0,r8
80008e32:	40 41       	lddsp	r1,sp[0x10]
80008e34:	a5 a5       	sbr	r5,0x4
80008e36:	c0 a8       	rjmp	80008e4a <_vfprintf_r+0xd26>
80008e38:	50 a7       	stdsp	sp[0x28],r7
80008e3a:	50 80       	stdsp	sp[0x20],r0
80008e3c:	0c 97       	mov	r7,r6
80008e3e:	04 94       	mov	r4,r2
80008e40:	06 96       	mov	r6,r3
80008e42:	02 92       	mov	r2,r1
80008e44:	40 93       	lddsp	r3,sp[0x24]
80008e46:	10 90       	mov	r0,r8
80008e48:	40 41       	lddsp	r1,sp[0x10]
80008e4a:	ed b5 00 05 	bld	r5,0x5
80008e4e:	c5 d1       	brne	80008f08 <_vfprintf_r+0xde4>
80008e50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e54:	40 3c       	lddsp	r12,sp[0xc]
80008e56:	58 0c       	cp.w	r12,0
80008e58:	c2 60       	breq	80008ea4 <_vfprintf_r+0xd80>
80008e5a:	10 36       	cp.w	r6,r8
80008e5c:	c0 a4       	brge	80008e70 <_vfprintf_r+0xd4c>
80008e5e:	fa cb f9 44 	sub	r11,sp,-1724
80008e62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e66:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e6a:	fa e9 00 00 	st.d	sp[0],r8
80008e6e:	c1 88       	rjmp	80008e9e <_vfprintf_r+0xd7a>
80008e70:	fa c8 f9 50 	sub	r8,sp,-1712
80008e74:	1a d8       	st.w	--sp,r8
80008e76:	fa c8 fa b8 	sub	r8,sp,-1352
80008e7a:	04 9a       	mov	r10,r2
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	0c 9b       	mov	r11,r6
80008e80:	fa c8 fb b4 	sub	r8,sp,-1100
80008e84:	08 9c       	mov	r12,r4
80008e86:	1a d8       	st.w	--sp,r8
80008e88:	fa c8 f9 40 	sub	r8,sp,-1728
80008e8c:	fa c9 ff b4 	sub	r9,sp,-76
80008e90:	fe b0 f7 b2 	rcall	80007df4 <get_arg>
80008e94:	2f dd       	sub	sp,-12
80008e96:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e9a:	fa eb 00 00 	st.d	sp[0],r10
80008e9e:	30 08       	mov	r8,0
80008ea0:	e0 8f 03 de 	bral	8000965c <_vfprintf_r+0x1538>
80008ea4:	ee ca ff ff 	sub	r10,r7,-1
80008ea8:	10 37       	cp.w	r7,r8
80008eaa:	c0 b4       	brge	80008ec0 <_vfprintf_r+0xd9c>
80008eac:	fa c9 f9 44 	sub	r9,sp,-1724
80008eb0:	14 97       	mov	r7,r10
80008eb2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eb6:	ec ea fd 88 	ld.d	r10,r6[-632]
80008eba:	fa eb 00 00 	st.d	sp[0],r10
80008ebe:	c1 88       	rjmp	80008eee <_vfprintf_r+0xdca>
80008ec0:	41 09       	lddsp	r9,sp[0x40]
80008ec2:	59 f8       	cp.w	r8,31
80008ec4:	e0 89 00 18 	brgt	80008ef4 <_vfprintf_r+0xdd0>
80008ec8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ecc:	f2 cb ff f8 	sub	r11,r9,-8
80008ed0:	fa e7 00 00 	st.d	sp[0],r6
80008ed4:	51 0b       	stdsp	sp[0x40],r11
80008ed6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eda:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ede:	fa e6 00 00 	ld.d	r6,sp[0]
80008ee2:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ee6:	2f f8       	sub	r8,-1
80008ee8:	14 97       	mov	r7,r10
80008eea:	fb 48 06 b4 	st.w	sp[1716],r8
80008eee:	40 38       	lddsp	r8,sp[0xc]
80008ef0:	e0 8f 03 b6 	bral	8000965c <_vfprintf_r+0x1538>
80008ef4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ef8:	40 38       	lddsp	r8,sp[0xc]
80008efa:	fa e7 00 00 	st.d	sp[0],r6
80008efe:	2f 89       	sub	r9,-8
80008f00:	14 97       	mov	r7,r10
80008f02:	51 09       	stdsp	sp[0x40],r9
80008f04:	e0 8f 03 ac 	bral	8000965c <_vfprintf_r+0x1538>
80008f08:	ed b5 00 04 	bld	r5,0x4
80008f0c:	c1 61       	brne	80008f38 <_vfprintf_r+0xe14>
80008f0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f12:	40 3e       	lddsp	lr,sp[0xc]
80008f14:	58 0e       	cp.w	lr,0
80008f16:	c0 80       	breq	80008f26 <_vfprintf_r+0xe02>
80008f18:	10 36       	cp.w	r6,r8
80008f1a:	c6 74       	brge	80008fe8 <_vfprintf_r+0xec4>
80008f1c:	fa cc f9 44 	sub	r12,sp,-1724
80008f20:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f24:	c8 08       	rjmp	80009024 <_vfprintf_r+0xf00>
80008f26:	ee ca ff ff 	sub	r10,r7,-1
80008f2a:	10 37       	cp.w	r7,r8
80008f2c:	c7 f4       	brge	8000902a <_vfprintf_r+0xf06>
80008f2e:	fa cb f9 44 	sub	r11,sp,-1724
80008f32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f36:	c7 68       	rjmp	80009022 <_vfprintf_r+0xefe>
80008f38:	ed b5 00 06 	bld	r5,0x6
80008f3c:	c4 a1       	brne	80008fd0 <_vfprintf_r+0xeac>
80008f3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f42:	40 3c       	lddsp	r12,sp[0xc]
80008f44:	58 0c       	cp.w	r12,0
80008f46:	c1 d0       	breq	80008f80 <_vfprintf_r+0xe5c>
80008f48:	10 36       	cp.w	r6,r8
80008f4a:	c0 64       	brge	80008f56 <_vfprintf_r+0xe32>
80008f4c:	fa cb f9 44 	sub	r11,sp,-1724
80008f50:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f54:	c1 f8       	rjmp	80008f92 <_vfprintf_r+0xe6e>
80008f56:	fa c8 f9 50 	sub	r8,sp,-1712
80008f5a:	1a d8       	st.w	--sp,r8
80008f5c:	fa c8 fa b8 	sub	r8,sp,-1352
80008f60:	1a d8       	st.w	--sp,r8
80008f62:	fa c8 fb b4 	sub	r8,sp,-1100
80008f66:	1a d8       	st.w	--sp,r8
80008f68:	fa c8 f9 40 	sub	r8,sp,-1728
80008f6c:	fa c9 ff b4 	sub	r9,sp,-76
80008f70:	04 9a       	mov	r10,r2
80008f72:	0c 9b       	mov	r11,r6
80008f74:	08 9c       	mov	r12,r4
80008f76:	fe b0 f7 3f 	rcall	80007df4 <get_arg>
80008f7a:	2f dd       	sub	sp,-12
80008f7c:	98 18       	ld.sh	r8,r12[0x2]
80008f7e:	c2 68       	rjmp	80008fca <_vfprintf_r+0xea6>
80008f80:	ee ca ff ff 	sub	r10,r7,-1
80008f84:	10 37       	cp.w	r7,r8
80008f86:	c0 94       	brge	80008f98 <_vfprintf_r+0xe74>
80008f88:	fa c9 f9 44 	sub	r9,sp,-1724
80008f8c:	14 97       	mov	r7,r10
80008f8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f92:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f96:	c1 a8       	rjmp	80008fca <_vfprintf_r+0xea6>
80008f98:	41 09       	lddsp	r9,sp[0x40]
80008f9a:	59 f8       	cp.w	r8,31
80008f9c:	e0 89 00 13 	brgt	80008fc2 <_vfprintf_r+0xe9e>
80008fa0:	f2 cb ff fc 	sub	r11,r9,-4
80008fa4:	51 0b       	stdsp	sp[0x40],r11
80008fa6:	72 09       	ld.w	r9,r9[0x0]
80008fa8:	fa c6 f9 44 	sub	r6,sp,-1724
80008fac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fb0:	2f f8       	sub	r8,-1
80008fb2:	f7 49 fd 88 	st.w	r11[-632],r9
80008fb6:	fb 48 06 b4 	st.w	sp[1716],r8
80008fba:	14 97       	mov	r7,r10
80008fbc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fc0:	c0 58       	rjmp	80008fca <_vfprintf_r+0xea6>
80008fc2:	92 18       	ld.sh	r8,r9[0x2]
80008fc4:	14 97       	mov	r7,r10
80008fc6:	2f c9       	sub	r9,-4
80008fc8:	51 09       	stdsp	sp[0x40],r9
80008fca:	5c 78       	castu.h	r8
80008fcc:	50 18       	stdsp	sp[0x4],r8
80008fce:	c4 68       	rjmp	8000905a <_vfprintf_r+0xf36>
80008fd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fd4:	40 3c       	lddsp	r12,sp[0xc]
80008fd6:	58 0c       	cp.w	r12,0
80008fd8:	c1 d0       	breq	80009012 <_vfprintf_r+0xeee>
80008fda:	10 36       	cp.w	r6,r8
80008fdc:	c0 64       	brge	80008fe8 <_vfprintf_r+0xec4>
80008fde:	fa cb f9 44 	sub	r11,sp,-1724
80008fe2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fe6:	c1 f8       	rjmp	80009024 <_vfprintf_r+0xf00>
80008fe8:	fa c8 f9 50 	sub	r8,sp,-1712
80008fec:	1a d8       	st.w	--sp,r8
80008fee:	fa c8 fa b8 	sub	r8,sp,-1352
80008ff2:	0c 9b       	mov	r11,r6
80008ff4:	1a d8       	st.w	--sp,r8
80008ff6:	fa c8 fb b4 	sub	r8,sp,-1100
80008ffa:	04 9a       	mov	r10,r2
80008ffc:	1a d8       	st.w	--sp,r8
80008ffe:	08 9c       	mov	r12,r4
80009000:	fa c8 f9 40 	sub	r8,sp,-1728
80009004:	fa c9 ff b4 	sub	r9,sp,-76
80009008:	fe b0 f6 f6 	rcall	80007df4 <get_arg>
8000900c:	2f dd       	sub	sp,-12
8000900e:	78 0b       	ld.w	r11,r12[0x0]
80009010:	c2 48       	rjmp	80009058 <_vfprintf_r+0xf34>
80009012:	ee ca ff ff 	sub	r10,r7,-1
80009016:	10 37       	cp.w	r7,r8
80009018:	c0 94       	brge	8000902a <_vfprintf_r+0xf06>
8000901a:	fa c9 f9 44 	sub	r9,sp,-1724
8000901e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009022:	14 97       	mov	r7,r10
80009024:	ec fb fd 88 	ld.w	r11,r6[-632]
80009028:	c1 88       	rjmp	80009058 <_vfprintf_r+0xf34>
8000902a:	41 09       	lddsp	r9,sp[0x40]
8000902c:	59 f8       	cp.w	r8,31
8000902e:	e0 89 00 11 	brgt	80009050 <_vfprintf_r+0xf2c>
80009032:	f2 cb ff fc 	sub	r11,r9,-4
80009036:	51 0b       	stdsp	sp[0x40],r11
80009038:	fa c6 f9 44 	sub	r6,sp,-1724
8000903c:	72 0b       	ld.w	r11,r9[0x0]
8000903e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009042:	f3 4b fd 88 	st.w	r9[-632],r11
80009046:	2f f8       	sub	r8,-1
80009048:	14 97       	mov	r7,r10
8000904a:	fb 48 06 b4 	st.w	sp[1716],r8
8000904e:	c0 58       	rjmp	80009058 <_vfprintf_r+0xf34>
80009050:	72 0b       	ld.w	r11,r9[0x0]
80009052:	14 97       	mov	r7,r10
80009054:	2f c9       	sub	r9,-4
80009056:	51 09       	stdsp	sp[0x40],r9
80009058:	50 1b       	stdsp	sp[0x4],r11
8000905a:	30 0e       	mov	lr,0
8000905c:	50 0e       	stdsp	sp[0x0],lr
8000905e:	1c 98       	mov	r8,lr
80009060:	e0 8f 02 fe 	bral	8000965c <_vfprintf_r+0x1538>
80009064:	50 a7       	stdsp	sp[0x28],r7
80009066:	50 80       	stdsp	sp[0x20],r0
80009068:	0c 97       	mov	r7,r6
8000906a:	04 94       	mov	r4,r2
8000906c:	06 96       	mov	r6,r3
8000906e:	02 92       	mov	r2,r1
80009070:	40 93       	lddsp	r3,sp[0x24]
80009072:	40 41       	lddsp	r1,sp[0x10]
80009074:	0e 99       	mov	r9,r7
80009076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000907a:	40 3c       	lddsp	r12,sp[0xc]
8000907c:	58 0c       	cp.w	r12,0
8000907e:	c1 d0       	breq	800090b8 <_vfprintf_r+0xf94>
80009080:	10 36       	cp.w	r6,r8
80009082:	c0 64       	brge	8000908e <_vfprintf_r+0xf6a>
80009084:	fa cb f9 44 	sub	r11,sp,-1724
80009088:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000908c:	c1 d8       	rjmp	800090c6 <_vfprintf_r+0xfa2>
8000908e:	fa c8 f9 50 	sub	r8,sp,-1712
80009092:	1a d8       	st.w	--sp,r8
80009094:	fa c8 fa b8 	sub	r8,sp,-1352
80009098:	1a d8       	st.w	--sp,r8
8000909a:	fa c8 fb b4 	sub	r8,sp,-1100
8000909e:	1a d8       	st.w	--sp,r8
800090a0:	fa c9 ff b4 	sub	r9,sp,-76
800090a4:	fa c8 f9 40 	sub	r8,sp,-1728
800090a8:	04 9a       	mov	r10,r2
800090aa:	0c 9b       	mov	r11,r6
800090ac:	08 9c       	mov	r12,r4
800090ae:	fe b0 f6 a3 	rcall	80007df4 <get_arg>
800090b2:	2f dd       	sub	sp,-12
800090b4:	78 09       	ld.w	r9,r12[0x0]
800090b6:	c2 18       	rjmp	800090f8 <_vfprintf_r+0xfd4>
800090b8:	2f f7       	sub	r7,-1
800090ba:	10 39       	cp.w	r9,r8
800090bc:	c0 84       	brge	800090cc <_vfprintf_r+0xfa8>
800090be:	fa ca f9 44 	sub	r10,sp,-1724
800090c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090c6:	ec f9 fd 88 	ld.w	r9,r6[-632]
800090ca:	c1 78       	rjmp	800090f8 <_vfprintf_r+0xfd4>
800090cc:	41 09       	lddsp	r9,sp[0x40]
800090ce:	59 f8       	cp.w	r8,31
800090d0:	e0 89 00 10 	brgt	800090f0 <_vfprintf_r+0xfcc>
800090d4:	f2 ca ff fc 	sub	r10,r9,-4
800090d8:	51 0a       	stdsp	sp[0x40],r10
800090da:	fa c6 f9 44 	sub	r6,sp,-1724
800090de:	72 09       	ld.w	r9,r9[0x0]
800090e0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800090e4:	f5 49 fd 88 	st.w	r10[-632],r9
800090e8:	2f f8       	sub	r8,-1
800090ea:	fb 48 06 b4 	st.w	sp[1716],r8
800090ee:	c0 58       	rjmp	800090f8 <_vfprintf_r+0xfd4>
800090f0:	f2 c8 ff fc 	sub	r8,r9,-4
800090f4:	51 08       	stdsp	sp[0x40],r8
800090f6:	72 09       	ld.w	r9,r9[0x0]
800090f8:	33 08       	mov	r8,48
800090fa:	fb 68 06 b8 	st.b	sp[1720],r8
800090fe:	37 88       	mov	r8,120
80009100:	30 0e       	mov	lr,0
80009102:	fb 68 06 b9 	st.b	sp[1721],r8
80009106:	fe cc b1 36 	sub	r12,pc,-20170
8000910a:	50 19       	stdsp	sp[0x4],r9
8000910c:	a1 b5       	sbr	r5,0x1
8000910e:	50 0e       	stdsp	sp[0x0],lr
80009110:	50 dc       	stdsp	sp[0x34],r12
80009112:	30 28       	mov	r8,2
80009114:	37 80       	mov	r0,120
80009116:	e0 8f 02 a3 	bral	8000965c <_vfprintf_r+0x1538>
8000911a:	50 a7       	stdsp	sp[0x28],r7
8000911c:	50 80       	stdsp	sp[0x20],r0
8000911e:	10 90       	mov	r0,r8
80009120:	30 08       	mov	r8,0
80009122:	fb 68 06 bb 	st.b	sp[1723],r8
80009126:	0c 97       	mov	r7,r6
80009128:	04 94       	mov	r4,r2
8000912a:	06 96       	mov	r6,r3
8000912c:	02 92       	mov	r2,r1
8000912e:	40 93       	lddsp	r3,sp[0x24]
80009130:	40 41       	lddsp	r1,sp[0x10]
80009132:	0e 99       	mov	r9,r7
80009134:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009138:	40 3b       	lddsp	r11,sp[0xc]
8000913a:	58 0b       	cp.w	r11,0
8000913c:	c1 d0       	breq	80009176 <_vfprintf_r+0x1052>
8000913e:	10 36       	cp.w	r6,r8
80009140:	c0 64       	brge	8000914c <_vfprintf_r+0x1028>
80009142:	fa ca f9 44 	sub	r10,sp,-1724
80009146:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000914a:	c1 d8       	rjmp	80009184 <_vfprintf_r+0x1060>
8000914c:	fa c8 f9 50 	sub	r8,sp,-1712
80009150:	1a d8       	st.w	--sp,r8
80009152:	fa c8 fa b8 	sub	r8,sp,-1352
80009156:	1a d8       	st.w	--sp,r8
80009158:	fa c8 fb b4 	sub	r8,sp,-1100
8000915c:	0c 9b       	mov	r11,r6
8000915e:	1a d8       	st.w	--sp,r8
80009160:	04 9a       	mov	r10,r2
80009162:	fa c8 f9 40 	sub	r8,sp,-1728
80009166:	fa c9 ff b4 	sub	r9,sp,-76
8000916a:	08 9c       	mov	r12,r4
8000916c:	fe b0 f6 44 	rcall	80007df4 <get_arg>
80009170:	2f dd       	sub	sp,-12
80009172:	78 06       	ld.w	r6,r12[0x0]
80009174:	c2 08       	rjmp	800091b4 <_vfprintf_r+0x1090>
80009176:	2f f7       	sub	r7,-1
80009178:	10 39       	cp.w	r9,r8
8000917a:	c0 84       	brge	8000918a <_vfprintf_r+0x1066>
8000917c:	fa c9 f9 44 	sub	r9,sp,-1724
80009180:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009184:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009188:	c1 68       	rjmp	800091b4 <_vfprintf_r+0x1090>
8000918a:	41 09       	lddsp	r9,sp[0x40]
8000918c:	59 f8       	cp.w	r8,31
8000918e:	e0 89 00 10 	brgt	800091ae <_vfprintf_r+0x108a>
80009192:	f2 ca ff fc 	sub	r10,r9,-4
80009196:	51 0a       	stdsp	sp[0x40],r10
80009198:	72 06       	ld.w	r6,r9[0x0]
8000919a:	fa ce f9 44 	sub	lr,sp,-1724
8000919e:	fc 08 00 39 	add	r9,lr,r8<<0x3
800091a2:	f3 46 fd 88 	st.w	r9[-632],r6
800091a6:	2f f8       	sub	r8,-1
800091a8:	fb 48 06 b4 	st.w	sp[1716],r8
800091ac:	c0 48       	rjmp	800091b4 <_vfprintf_r+0x1090>
800091ae:	72 06       	ld.w	r6,r9[0x0]
800091b0:	2f c9       	sub	r9,-4
800091b2:	51 09       	stdsp	sp[0x40],r9
800091b4:	40 2c       	lddsp	r12,sp[0x8]
800091b6:	58 0c       	cp.w	r12,0
800091b8:	c1 05       	brlt	800091d8 <_vfprintf_r+0x10b4>
800091ba:	18 9a       	mov	r10,r12
800091bc:	30 0b       	mov	r11,0
800091be:	0c 9c       	mov	r12,r6
800091c0:	e0 a0 12 38 	rcall	8000b630 <memchr>
800091c4:	e0 80 02 df 	breq	80009782 <_vfprintf_r+0x165e>
800091c8:	f8 06 01 02 	sub	r2,r12,r6
800091cc:	40 2b       	lddsp	r11,sp[0x8]
800091ce:	16 32       	cp.w	r2,r11
800091d0:	e0 89 02 d9 	brgt	80009782 <_vfprintf_r+0x165e>
800091d4:	e0 8f 02 d4 	bral	8000977c <_vfprintf_r+0x1658>
800091d8:	30 0a       	mov	r10,0
800091da:	0c 9c       	mov	r12,r6
800091dc:	50 2a       	stdsp	sp[0x8],r10
800091de:	e0 a0 15 99 	rcall	8000bd10 <strlen>
800091e2:	18 92       	mov	r2,r12
800091e4:	e0 8f 02 d2 	bral	80009788 <_vfprintf_r+0x1664>
800091e8:	50 a7       	stdsp	sp[0x28],r7
800091ea:	50 80       	stdsp	sp[0x20],r0
800091ec:	0c 97       	mov	r7,r6
800091ee:	04 94       	mov	r4,r2
800091f0:	06 96       	mov	r6,r3
800091f2:	02 92       	mov	r2,r1
800091f4:	40 93       	lddsp	r3,sp[0x24]
800091f6:	10 90       	mov	r0,r8
800091f8:	40 41       	lddsp	r1,sp[0x10]
800091fa:	a5 a5       	sbr	r5,0x4
800091fc:	c0 a8       	rjmp	80009210 <_vfprintf_r+0x10ec>
800091fe:	50 a7       	stdsp	sp[0x28],r7
80009200:	50 80       	stdsp	sp[0x20],r0
80009202:	0c 97       	mov	r7,r6
80009204:	04 94       	mov	r4,r2
80009206:	06 96       	mov	r6,r3
80009208:	02 92       	mov	r2,r1
8000920a:	40 93       	lddsp	r3,sp[0x24]
8000920c:	10 90       	mov	r0,r8
8000920e:	40 41       	lddsp	r1,sp[0x10]
80009210:	ed b5 00 05 	bld	r5,0x5
80009214:	c5 61       	brne	800092c0 <_vfprintf_r+0x119c>
80009216:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000921a:	40 39       	lddsp	r9,sp[0xc]
8000921c:	58 09       	cp.w	r9,0
8000921e:	c2 10       	breq	80009260 <_vfprintf_r+0x113c>
80009220:	10 36       	cp.w	r6,r8
80009222:	c0 74       	brge	80009230 <_vfprintf_r+0x110c>
80009224:	fa c8 f9 44 	sub	r8,sp,-1724
80009228:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000922c:	c2 38       	rjmp	80009272 <_vfprintf_r+0x114e>
8000922e:	d7 03       	nop
80009230:	fa c8 f9 50 	sub	r8,sp,-1712
80009234:	1a d8       	st.w	--sp,r8
80009236:	fa c8 fa b8 	sub	r8,sp,-1352
8000923a:	1a d8       	st.w	--sp,r8
8000923c:	fa c8 fb b4 	sub	r8,sp,-1100
80009240:	1a d8       	st.w	--sp,r8
80009242:	fa c8 f9 40 	sub	r8,sp,-1728
80009246:	fa c9 ff b4 	sub	r9,sp,-76
8000924a:	04 9a       	mov	r10,r2
8000924c:	0c 9b       	mov	r11,r6
8000924e:	08 9c       	mov	r12,r4
80009250:	fe b0 f5 d2 	rcall	80007df4 <get_arg>
80009254:	2f dd       	sub	sp,-12
80009256:	f8 e8 00 00 	ld.d	r8,r12[0]
8000925a:	fa e9 00 00 	st.d	sp[0],r8
8000925e:	c2 e8       	rjmp	800092ba <_vfprintf_r+0x1196>
80009260:	ee ca ff ff 	sub	r10,r7,-1
80009264:	10 37       	cp.w	r7,r8
80009266:	c0 b4       	brge	8000927c <_vfprintf_r+0x1158>
80009268:	fa c8 f9 44 	sub	r8,sp,-1724
8000926c:	14 97       	mov	r7,r10
8000926e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009272:	ec ea fd 88 	ld.d	r10,r6[-632]
80009276:	fa eb 00 00 	st.d	sp[0],r10
8000927a:	c2 08       	rjmp	800092ba <_vfprintf_r+0x1196>
8000927c:	41 09       	lddsp	r9,sp[0x40]
8000927e:	59 f8       	cp.w	r8,31
80009280:	e0 89 00 16 	brgt	800092ac <_vfprintf_r+0x1188>
80009284:	f2 e6 00 00 	ld.d	r6,r9[0]
80009288:	f2 cb ff f8 	sub	r11,r9,-8
8000928c:	fa e7 00 00 	st.d	sp[0],r6
80009290:	51 0b       	stdsp	sp[0x40],r11
80009292:	fa c6 f9 44 	sub	r6,sp,-1724
80009296:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000929a:	fa e6 00 00 	ld.d	r6,sp[0]
8000929e:	f2 e7 fd 88 	st.d	r9[-632],r6
800092a2:	2f f8       	sub	r8,-1
800092a4:	14 97       	mov	r7,r10
800092a6:	fb 48 06 b4 	st.w	sp[1716],r8
800092aa:	c0 88       	rjmp	800092ba <_vfprintf_r+0x1196>
800092ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800092b0:	2f 89       	sub	r9,-8
800092b2:	fa e7 00 00 	st.d	sp[0],r6
800092b6:	51 09       	stdsp	sp[0x40],r9
800092b8:	14 97       	mov	r7,r10
800092ba:	30 18       	mov	r8,1
800092bc:	e0 8f 01 d0 	bral	8000965c <_vfprintf_r+0x1538>
800092c0:	ed b5 00 04 	bld	r5,0x4
800092c4:	c1 61       	brne	800092f0 <_vfprintf_r+0x11cc>
800092c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092ca:	40 3e       	lddsp	lr,sp[0xc]
800092cc:	58 0e       	cp.w	lr,0
800092ce:	c0 80       	breq	800092de <_vfprintf_r+0x11ba>
800092d0:	10 36       	cp.w	r6,r8
800092d2:	c6 74       	brge	800093a0 <_vfprintf_r+0x127c>
800092d4:	fa cc f9 44 	sub	r12,sp,-1724
800092d8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092dc:	c8 08       	rjmp	800093dc <_vfprintf_r+0x12b8>
800092de:	ee ca ff ff 	sub	r10,r7,-1
800092e2:	10 37       	cp.w	r7,r8
800092e4:	c7 f4       	brge	800093e2 <_vfprintf_r+0x12be>
800092e6:	fa cb f9 44 	sub	r11,sp,-1724
800092ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ee:	c7 68       	rjmp	800093da <_vfprintf_r+0x12b6>
800092f0:	ed b5 00 06 	bld	r5,0x6
800092f4:	c4 a1       	brne	80009388 <_vfprintf_r+0x1264>
800092f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092fa:	40 3c       	lddsp	r12,sp[0xc]
800092fc:	58 0c       	cp.w	r12,0
800092fe:	c1 d0       	breq	80009338 <_vfprintf_r+0x1214>
80009300:	10 36       	cp.w	r6,r8
80009302:	c0 64       	brge	8000930e <_vfprintf_r+0x11ea>
80009304:	fa cb f9 44 	sub	r11,sp,-1724
80009308:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000930c:	c1 f8       	rjmp	8000934a <_vfprintf_r+0x1226>
8000930e:	fa c8 f9 50 	sub	r8,sp,-1712
80009312:	1a d8       	st.w	--sp,r8
80009314:	fa c8 fa b8 	sub	r8,sp,-1352
80009318:	1a d8       	st.w	--sp,r8
8000931a:	fa c8 fb b4 	sub	r8,sp,-1100
8000931e:	1a d8       	st.w	--sp,r8
80009320:	fa c8 f9 40 	sub	r8,sp,-1728
80009324:	fa c9 ff b4 	sub	r9,sp,-76
80009328:	04 9a       	mov	r10,r2
8000932a:	0c 9b       	mov	r11,r6
8000932c:	08 9c       	mov	r12,r4
8000932e:	fe b0 f5 63 	rcall	80007df4 <get_arg>
80009332:	2f dd       	sub	sp,-12
80009334:	98 18       	ld.sh	r8,r12[0x2]
80009336:	c2 68       	rjmp	80009382 <_vfprintf_r+0x125e>
80009338:	ee ca ff ff 	sub	r10,r7,-1
8000933c:	10 37       	cp.w	r7,r8
8000933e:	c0 94       	brge	80009350 <_vfprintf_r+0x122c>
80009340:	fa c9 f9 44 	sub	r9,sp,-1724
80009344:	14 97       	mov	r7,r10
80009346:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000934a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000934e:	c1 a8       	rjmp	80009382 <_vfprintf_r+0x125e>
80009350:	41 09       	lddsp	r9,sp[0x40]
80009352:	59 f8       	cp.w	r8,31
80009354:	e0 89 00 13 	brgt	8000937a <_vfprintf_r+0x1256>
80009358:	f2 cb ff fc 	sub	r11,r9,-4
8000935c:	51 0b       	stdsp	sp[0x40],r11
8000935e:	72 09       	ld.w	r9,r9[0x0]
80009360:	fa c6 f9 44 	sub	r6,sp,-1724
80009364:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009368:	2f f8       	sub	r8,-1
8000936a:	f7 49 fd 88 	st.w	r11[-632],r9
8000936e:	fb 48 06 b4 	st.w	sp[1716],r8
80009372:	14 97       	mov	r7,r10
80009374:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009378:	c0 58       	rjmp	80009382 <_vfprintf_r+0x125e>
8000937a:	92 18       	ld.sh	r8,r9[0x2]
8000937c:	14 97       	mov	r7,r10
8000937e:	2f c9       	sub	r9,-4
80009380:	51 09       	stdsp	sp[0x40],r9
80009382:	5c 78       	castu.h	r8
80009384:	50 18       	stdsp	sp[0x4],r8
80009386:	c4 68       	rjmp	80009412 <_vfprintf_r+0x12ee>
80009388:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000938c:	40 3c       	lddsp	r12,sp[0xc]
8000938e:	58 0c       	cp.w	r12,0
80009390:	c1 d0       	breq	800093ca <_vfprintf_r+0x12a6>
80009392:	10 36       	cp.w	r6,r8
80009394:	c0 64       	brge	800093a0 <_vfprintf_r+0x127c>
80009396:	fa cb f9 44 	sub	r11,sp,-1724
8000939a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000939e:	c1 f8       	rjmp	800093dc <_vfprintf_r+0x12b8>
800093a0:	fa c8 f9 50 	sub	r8,sp,-1712
800093a4:	1a d8       	st.w	--sp,r8
800093a6:	fa c8 fa b8 	sub	r8,sp,-1352
800093aa:	0c 9b       	mov	r11,r6
800093ac:	1a d8       	st.w	--sp,r8
800093ae:	fa c8 fb b4 	sub	r8,sp,-1100
800093b2:	04 9a       	mov	r10,r2
800093b4:	1a d8       	st.w	--sp,r8
800093b6:	08 9c       	mov	r12,r4
800093b8:	fa c8 f9 40 	sub	r8,sp,-1728
800093bc:	fa c9 ff b4 	sub	r9,sp,-76
800093c0:	fe b0 f5 1a 	rcall	80007df4 <get_arg>
800093c4:	2f dd       	sub	sp,-12
800093c6:	78 0b       	ld.w	r11,r12[0x0]
800093c8:	c2 48       	rjmp	80009410 <_vfprintf_r+0x12ec>
800093ca:	ee ca ff ff 	sub	r10,r7,-1
800093ce:	10 37       	cp.w	r7,r8
800093d0:	c0 94       	brge	800093e2 <_vfprintf_r+0x12be>
800093d2:	fa c9 f9 44 	sub	r9,sp,-1724
800093d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093da:	14 97       	mov	r7,r10
800093dc:	ec fb fd 88 	ld.w	r11,r6[-632]
800093e0:	c1 88       	rjmp	80009410 <_vfprintf_r+0x12ec>
800093e2:	41 09       	lddsp	r9,sp[0x40]
800093e4:	59 f8       	cp.w	r8,31
800093e6:	e0 89 00 11 	brgt	80009408 <_vfprintf_r+0x12e4>
800093ea:	f2 cb ff fc 	sub	r11,r9,-4
800093ee:	51 0b       	stdsp	sp[0x40],r11
800093f0:	fa c6 f9 44 	sub	r6,sp,-1724
800093f4:	72 0b       	ld.w	r11,r9[0x0]
800093f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093fa:	f3 4b fd 88 	st.w	r9[-632],r11
800093fe:	2f f8       	sub	r8,-1
80009400:	14 97       	mov	r7,r10
80009402:	fb 48 06 b4 	st.w	sp[1716],r8
80009406:	c0 58       	rjmp	80009410 <_vfprintf_r+0x12ec>
80009408:	72 0b       	ld.w	r11,r9[0x0]
8000940a:	14 97       	mov	r7,r10
8000940c:	2f c9       	sub	r9,-4
8000940e:	51 09       	stdsp	sp[0x40],r9
80009410:	50 1b       	stdsp	sp[0x4],r11
80009412:	30 0e       	mov	lr,0
80009414:	30 18       	mov	r8,1
80009416:	50 0e       	stdsp	sp[0x0],lr
80009418:	c2 29       	rjmp	8000965c <_vfprintf_r+0x1538>
8000941a:	50 a7       	stdsp	sp[0x28],r7
8000941c:	50 80       	stdsp	sp[0x20],r0
8000941e:	0c 97       	mov	r7,r6
80009420:	04 94       	mov	r4,r2
80009422:	06 96       	mov	r6,r3
80009424:	02 92       	mov	r2,r1
80009426:	fe cc b4 56 	sub	r12,pc,-19370
8000942a:	40 93       	lddsp	r3,sp[0x24]
8000942c:	10 90       	mov	r0,r8
8000942e:	40 41       	lddsp	r1,sp[0x10]
80009430:	50 dc       	stdsp	sp[0x34],r12
80009432:	ed b5 00 05 	bld	r5,0x5
80009436:	c5 51       	brne	800094e0 <_vfprintf_r+0x13bc>
80009438:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000943c:	40 3b       	lddsp	r11,sp[0xc]
8000943e:	58 0b       	cp.w	r11,0
80009440:	c2 20       	breq	80009484 <_vfprintf_r+0x1360>
80009442:	10 36       	cp.w	r6,r8
80009444:	c0 a4       	brge	80009458 <_vfprintf_r+0x1334>
80009446:	fa ca f9 44 	sub	r10,sp,-1724
8000944a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000944e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009452:	fa e9 00 00 	st.d	sp[0],r8
80009456:	cf 28       	rjmp	8000963a <_vfprintf_r+0x1516>
80009458:	fa c8 f9 50 	sub	r8,sp,-1712
8000945c:	1a d8       	st.w	--sp,r8
8000945e:	fa c8 fa b8 	sub	r8,sp,-1352
80009462:	04 9a       	mov	r10,r2
80009464:	1a d8       	st.w	--sp,r8
80009466:	0c 9b       	mov	r11,r6
80009468:	fa c8 fb b4 	sub	r8,sp,-1100
8000946c:	08 9c       	mov	r12,r4
8000946e:	1a d8       	st.w	--sp,r8
80009470:	fa c8 f9 40 	sub	r8,sp,-1728
80009474:	fa c9 ff b4 	sub	r9,sp,-76
80009478:	fe b0 f4 be 	rcall	80007df4 <get_arg>
8000947c:	2f dd       	sub	sp,-12
8000947e:	f8 ea 00 00 	ld.d	r10,r12[0]
80009482:	c0 c8       	rjmp	8000949a <_vfprintf_r+0x1376>
80009484:	ee ca ff ff 	sub	r10,r7,-1
80009488:	10 37       	cp.w	r7,r8
8000948a:	c0 b4       	brge	800094a0 <_vfprintf_r+0x137c>
8000948c:	fa c9 f9 44 	sub	r9,sp,-1724
80009490:	14 97       	mov	r7,r10
80009492:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009496:	ec ea fd 88 	ld.d	r10,r6[-632]
8000949a:	fa eb 00 00 	st.d	sp[0],r10
8000949e:	cc e8       	rjmp	8000963a <_vfprintf_r+0x1516>
800094a0:	41 09       	lddsp	r9,sp[0x40]
800094a2:	59 f8       	cp.w	r8,31
800094a4:	e0 89 00 16 	brgt	800094d0 <_vfprintf_r+0x13ac>
800094a8:	f2 e6 00 00 	ld.d	r6,r9[0]
800094ac:	f2 cb ff f8 	sub	r11,r9,-8
800094b0:	fa e7 00 00 	st.d	sp[0],r6
800094b4:	51 0b       	stdsp	sp[0x40],r11
800094b6:	fa c6 f9 44 	sub	r6,sp,-1724
800094ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094be:	fa e6 00 00 	ld.d	r6,sp[0]
800094c2:	f2 e7 fd 88 	st.d	r9[-632],r6
800094c6:	2f f8       	sub	r8,-1
800094c8:	14 97       	mov	r7,r10
800094ca:	fb 48 06 b4 	st.w	sp[1716],r8
800094ce:	cb 68       	rjmp	8000963a <_vfprintf_r+0x1516>
800094d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800094d4:	2f 89       	sub	r9,-8
800094d6:	fa e7 00 00 	st.d	sp[0],r6
800094da:	51 09       	stdsp	sp[0x40],r9
800094dc:	14 97       	mov	r7,r10
800094de:	ca e8       	rjmp	8000963a <_vfprintf_r+0x1516>
800094e0:	ed b5 00 04 	bld	r5,0x4
800094e4:	c1 71       	brne	80009512 <_vfprintf_r+0x13ee>
800094e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094ea:	40 3e       	lddsp	lr,sp[0xc]
800094ec:	58 0e       	cp.w	lr,0
800094ee:	c0 80       	breq	800094fe <_vfprintf_r+0x13da>
800094f0:	10 36       	cp.w	r6,r8
800094f2:	c6 94       	brge	800095c4 <_vfprintf_r+0x14a0>
800094f4:	fa cc f9 44 	sub	r12,sp,-1724
800094f8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094fc:	c8 28       	rjmp	80009600 <_vfprintf_r+0x14dc>
800094fe:	ee ca ff ff 	sub	r10,r7,-1
80009502:	10 37       	cp.w	r7,r8
80009504:	e0 84 00 81 	brge	80009606 <_vfprintf_r+0x14e2>
80009508:	fa cb f9 44 	sub	r11,sp,-1724
8000950c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009510:	c7 78       	rjmp	800095fe <_vfprintf_r+0x14da>
80009512:	ed b5 00 06 	bld	r5,0x6
80009516:	c4 b1       	brne	800095ac <_vfprintf_r+0x1488>
80009518:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000951c:	40 3c       	lddsp	r12,sp[0xc]
8000951e:	58 0c       	cp.w	r12,0
80009520:	c1 d0       	breq	8000955a <_vfprintf_r+0x1436>
80009522:	10 36       	cp.w	r6,r8
80009524:	c0 64       	brge	80009530 <_vfprintf_r+0x140c>
80009526:	fa cb f9 44 	sub	r11,sp,-1724
8000952a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000952e:	c1 f8       	rjmp	8000956c <_vfprintf_r+0x1448>
80009530:	fa c8 f9 50 	sub	r8,sp,-1712
80009534:	1a d8       	st.w	--sp,r8
80009536:	fa c8 fa b8 	sub	r8,sp,-1352
8000953a:	1a d8       	st.w	--sp,r8
8000953c:	fa c8 fb b4 	sub	r8,sp,-1100
80009540:	1a d8       	st.w	--sp,r8
80009542:	fa c8 f9 40 	sub	r8,sp,-1728
80009546:	fa c9 ff b4 	sub	r9,sp,-76
8000954a:	04 9a       	mov	r10,r2
8000954c:	0c 9b       	mov	r11,r6
8000954e:	08 9c       	mov	r12,r4
80009550:	fe b0 f4 52 	rcall	80007df4 <get_arg>
80009554:	2f dd       	sub	sp,-12
80009556:	98 18       	ld.sh	r8,r12[0x2]
80009558:	c2 78       	rjmp	800095a6 <_vfprintf_r+0x1482>
8000955a:	ee ca ff ff 	sub	r10,r7,-1
8000955e:	10 37       	cp.w	r7,r8
80009560:	c0 a4       	brge	80009574 <_vfprintf_r+0x1450>
80009562:	fa c9 f9 44 	sub	r9,sp,-1724
80009566:	14 97       	mov	r7,r10
80009568:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000956c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009570:	c1 b8       	rjmp	800095a6 <_vfprintf_r+0x1482>
80009572:	d7 03       	nop
80009574:	41 09       	lddsp	r9,sp[0x40]
80009576:	59 f8       	cp.w	r8,31
80009578:	e0 89 00 13 	brgt	8000959e <_vfprintf_r+0x147a>
8000957c:	f2 cb ff fc 	sub	r11,r9,-4
80009580:	51 0b       	stdsp	sp[0x40],r11
80009582:	72 09       	ld.w	r9,r9[0x0]
80009584:	fa c6 f9 44 	sub	r6,sp,-1724
80009588:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000958c:	2f f8       	sub	r8,-1
8000958e:	f7 49 fd 88 	st.w	r11[-632],r9
80009592:	fb 48 06 b4 	st.w	sp[1716],r8
80009596:	14 97       	mov	r7,r10
80009598:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000959c:	c0 58       	rjmp	800095a6 <_vfprintf_r+0x1482>
8000959e:	92 18       	ld.sh	r8,r9[0x2]
800095a0:	14 97       	mov	r7,r10
800095a2:	2f c9       	sub	r9,-4
800095a4:	51 09       	stdsp	sp[0x40],r9
800095a6:	5c 78       	castu.h	r8
800095a8:	50 18       	stdsp	sp[0x4],r8
800095aa:	c4 68       	rjmp	80009636 <_vfprintf_r+0x1512>
800095ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095b0:	40 3c       	lddsp	r12,sp[0xc]
800095b2:	58 0c       	cp.w	r12,0
800095b4:	c1 d0       	breq	800095ee <_vfprintf_r+0x14ca>
800095b6:	10 36       	cp.w	r6,r8
800095b8:	c0 64       	brge	800095c4 <_vfprintf_r+0x14a0>
800095ba:	fa cb f9 44 	sub	r11,sp,-1724
800095be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095c2:	c1 f8       	rjmp	80009600 <_vfprintf_r+0x14dc>
800095c4:	fa c8 f9 50 	sub	r8,sp,-1712
800095c8:	1a d8       	st.w	--sp,r8
800095ca:	fa c8 fa b8 	sub	r8,sp,-1352
800095ce:	0c 9b       	mov	r11,r6
800095d0:	1a d8       	st.w	--sp,r8
800095d2:	fa c8 fb b4 	sub	r8,sp,-1100
800095d6:	04 9a       	mov	r10,r2
800095d8:	1a d8       	st.w	--sp,r8
800095da:	08 9c       	mov	r12,r4
800095dc:	fa c8 f9 40 	sub	r8,sp,-1728
800095e0:	fa c9 ff b4 	sub	r9,sp,-76
800095e4:	fe b0 f4 08 	rcall	80007df4 <get_arg>
800095e8:	2f dd       	sub	sp,-12
800095ea:	78 0b       	ld.w	r11,r12[0x0]
800095ec:	c2 48       	rjmp	80009634 <_vfprintf_r+0x1510>
800095ee:	ee ca ff ff 	sub	r10,r7,-1
800095f2:	10 37       	cp.w	r7,r8
800095f4:	c0 94       	brge	80009606 <_vfprintf_r+0x14e2>
800095f6:	fa c9 f9 44 	sub	r9,sp,-1724
800095fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095fe:	14 97       	mov	r7,r10
80009600:	ec fb fd 88 	ld.w	r11,r6[-632]
80009604:	c1 88       	rjmp	80009634 <_vfprintf_r+0x1510>
80009606:	41 09       	lddsp	r9,sp[0x40]
80009608:	59 f8       	cp.w	r8,31
8000960a:	e0 89 00 11 	brgt	8000962c <_vfprintf_r+0x1508>
8000960e:	f2 cb ff fc 	sub	r11,r9,-4
80009612:	51 0b       	stdsp	sp[0x40],r11
80009614:	fa c6 f9 44 	sub	r6,sp,-1724
80009618:	72 0b       	ld.w	r11,r9[0x0]
8000961a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000961e:	f3 4b fd 88 	st.w	r9[-632],r11
80009622:	2f f8       	sub	r8,-1
80009624:	14 97       	mov	r7,r10
80009626:	fb 48 06 b4 	st.w	sp[1716],r8
8000962a:	c0 58       	rjmp	80009634 <_vfprintf_r+0x1510>
8000962c:	72 0b       	ld.w	r11,r9[0x0]
8000962e:	14 97       	mov	r7,r10
80009630:	2f c9       	sub	r9,-4
80009632:	51 09       	stdsp	sp[0x40],r9
80009634:	50 1b       	stdsp	sp[0x4],r11
80009636:	30 0e       	mov	lr,0
80009638:	50 0e       	stdsp	sp[0x0],lr
8000963a:	40 08       	lddsp	r8,sp[0x0]
8000963c:	40 1c       	lddsp	r12,sp[0x4]
8000963e:	18 48       	or	r8,r12
80009640:	5f 19       	srne	r9
80009642:	0a 98       	mov	r8,r5
80009644:	eb e9 00 09 	and	r9,r5,r9
80009648:	a1 b8       	sbr	r8,0x1
8000964a:	58 09       	cp.w	r9,0
8000964c:	c0 70       	breq	8000965a <_vfprintf_r+0x1536>
8000964e:	10 95       	mov	r5,r8
80009650:	fb 60 06 b9 	st.b	sp[1721],r0
80009654:	33 08       	mov	r8,48
80009656:	fb 68 06 b8 	st.b	sp[1720],r8
8000965a:	30 28       	mov	r8,2
8000965c:	30 09       	mov	r9,0
8000965e:	fb 69 06 bb 	st.b	sp[1723],r9
80009662:	0a 99       	mov	r9,r5
80009664:	a7 d9       	cbr	r9,0x7
80009666:	40 2b       	lddsp	r11,sp[0x8]
80009668:	40 16       	lddsp	r6,sp[0x4]
8000966a:	58 0b       	cp.w	r11,0
8000966c:	5f 1a       	srne	r10
8000966e:	f2 05 17 40 	movge	r5,r9
80009672:	fa c2 f9 78 	sub	r2,sp,-1672
80009676:	40 09       	lddsp	r9,sp[0x0]
80009678:	0c 49       	or	r9,r6
8000967a:	5f 19       	srne	r9
8000967c:	f5 e9 10 09 	or	r9,r10,r9
80009680:	c5 c0       	breq	80009738 <_vfprintf_r+0x1614>
80009682:	30 19       	mov	r9,1
80009684:	f2 08 18 00 	cp.b	r8,r9
80009688:	c0 60       	breq	80009694 <_vfprintf_r+0x1570>
8000968a:	30 29       	mov	r9,2
8000968c:	f2 08 18 00 	cp.b	r8,r9
80009690:	c0 41       	brne	80009698 <_vfprintf_r+0x1574>
80009692:	c3 c8       	rjmp	8000970a <_vfprintf_r+0x15e6>
80009694:	04 96       	mov	r6,r2
80009696:	c3 08       	rjmp	800096f6 <_vfprintf_r+0x15d2>
80009698:	04 96       	mov	r6,r2
8000969a:	fa e8 00 00 	ld.d	r8,sp[0]
8000969e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800096a2:	2d 0a       	sub	r10,-48
800096a4:	0c fa       	st.b	--r6,r10
800096a6:	f0 0b 16 03 	lsr	r11,r8,0x3
800096aa:	f2 0c 16 03 	lsr	r12,r9,0x3
800096ae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800096b2:	18 99       	mov	r9,r12
800096b4:	16 98       	mov	r8,r11
800096b6:	58 08       	cp.w	r8,0
800096b8:	5c 29       	cpc	r9
800096ba:	cf 21       	brne	8000969e <_vfprintf_r+0x157a>
800096bc:	fa e9 00 00 	st.d	sp[0],r8
800096c0:	ed b5 00 00 	bld	r5,0x0
800096c4:	c4 51       	brne	8000974e <_vfprintf_r+0x162a>
800096c6:	33 09       	mov	r9,48
800096c8:	f2 0a 18 00 	cp.b	r10,r9
800096cc:	c4 10       	breq	8000974e <_vfprintf_r+0x162a>
800096ce:	0c f9       	st.b	--r6,r9
800096d0:	c3 f8       	rjmp	8000974e <_vfprintf_r+0x162a>
800096d2:	fa ea 00 00 	ld.d	r10,sp[0]
800096d6:	30 a8       	mov	r8,10
800096d8:	30 09       	mov	r9,0
800096da:	e0 a0 1a 19 	rcall	8000cb0c <__avr32_umod64>
800096de:	30 a8       	mov	r8,10
800096e0:	2d 0a       	sub	r10,-48
800096e2:	30 09       	mov	r9,0
800096e4:	ac 8a       	st.b	r6[0x0],r10
800096e6:	fa ea 00 00 	ld.d	r10,sp[0]
800096ea:	e0 a0 18 df 	rcall	8000c8a8 <__avr32_udiv64>
800096ee:	16 99       	mov	r9,r11
800096f0:	14 98       	mov	r8,r10
800096f2:	fa e9 00 00 	st.d	sp[0],r8
800096f6:	20 16       	sub	r6,1
800096f8:	fa ea 00 00 	ld.d	r10,sp[0]
800096fc:	58 9a       	cp.w	r10,9
800096fe:	5c 2b       	cpc	r11
80009700:	fe 9b ff e9 	brhi	800096d2 <_vfprintf_r+0x15ae>
80009704:	1b f8       	ld.ub	r8,sp[0x7]
80009706:	2d 08       	sub	r8,-48
80009708:	c2 08       	rjmp	80009748 <_vfprintf_r+0x1624>
8000970a:	04 96       	mov	r6,r2
8000970c:	fa e8 00 00 	ld.d	r8,sp[0]
80009710:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009714:	40 de       	lddsp	lr,sp[0x34]
80009716:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000971a:	0c fa       	st.b	--r6,r10
8000971c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009720:	f0 0a 16 04 	lsr	r10,r8,0x4
80009724:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009728:	16 99       	mov	r9,r11
8000972a:	14 98       	mov	r8,r10
8000972c:	58 08       	cp.w	r8,0
8000972e:	5c 29       	cpc	r9
80009730:	cf 01       	brne	80009710 <_vfprintf_r+0x15ec>
80009732:	fa e9 00 00 	st.d	sp[0],r8
80009736:	c0 c8       	rjmp	8000974e <_vfprintf_r+0x162a>
80009738:	58 08       	cp.w	r8,0
8000973a:	c0 91       	brne	8000974c <_vfprintf_r+0x1628>
8000973c:	ed b5 00 00 	bld	r5,0x0
80009740:	c0 61       	brne	8000974c <_vfprintf_r+0x1628>
80009742:	fa c6 f9 79 	sub	r6,sp,-1671
80009746:	33 08       	mov	r8,48
80009748:	ac 88       	st.b	r6[0x0],r8
8000974a:	c0 28       	rjmp	8000974e <_vfprintf_r+0x162a>
8000974c:	04 96       	mov	r6,r2
8000974e:	0c 12       	sub	r2,r6
80009750:	c1 c8       	rjmp	80009788 <_vfprintf_r+0x1664>
80009752:	50 a7       	stdsp	sp[0x28],r7
80009754:	50 80       	stdsp	sp[0x20],r0
80009756:	40 93       	lddsp	r3,sp[0x24]
80009758:	0c 97       	mov	r7,r6
8000975a:	10 90       	mov	r0,r8
8000975c:	04 94       	mov	r4,r2
8000975e:	40 41       	lddsp	r1,sp[0x10]
80009760:	58 08       	cp.w	r8,0
80009762:	e0 80 04 4f 	breq	8000a000 <_vfprintf_r+0x1edc>
80009766:	fb 68 06 60 	st.b	sp[1632],r8
8000976a:	30 0c       	mov	r12,0
8000976c:	30 08       	mov	r8,0
8000976e:	30 12       	mov	r2,1
80009770:	fb 68 06 bb 	st.b	sp[1723],r8
80009774:	50 2c       	stdsp	sp[0x8],r12
80009776:	fa c6 f9 a0 	sub	r6,sp,-1632
8000977a:	c0 78       	rjmp	80009788 <_vfprintf_r+0x1664>
8000977c:	30 0b       	mov	r11,0
8000977e:	50 2b       	stdsp	sp[0x8],r11
80009780:	c0 48       	rjmp	80009788 <_vfprintf_r+0x1664>
80009782:	40 22       	lddsp	r2,sp[0x8]
80009784:	30 0a       	mov	r10,0
80009786:	50 2a       	stdsp	sp[0x8],r10
80009788:	40 29       	lddsp	r9,sp[0x8]
8000978a:	e4 09 0c 49 	max	r9,r2,r9
8000978e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009792:	50 39       	stdsp	sp[0xc],r9
80009794:	0a 9e       	mov	lr,r5
80009796:	30 09       	mov	r9,0
80009798:	e2 1e 00 02 	andl	lr,0x2,COH
8000979c:	f2 08 18 00 	cp.b	r8,r9
800097a0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800097a4:	f7 b8 01 ff 	subne	r8,-1
800097a8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800097ac:	0a 9b       	mov	r11,r5
800097ae:	58 0e       	cp.w	lr,0
800097b0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800097b4:	f7 bc 01 fe 	subne	r12,-2
800097b8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800097bc:	e2 1b 00 84 	andl	r11,0x84,COH
800097c0:	50 fe       	stdsp	sp[0x3c],lr
800097c2:	50 9b       	stdsp	sp[0x24],r11
800097c4:	c4 71       	brne	80009852 <_vfprintf_r+0x172e>
800097c6:	40 8a       	lddsp	r10,sp[0x20]
800097c8:	40 39       	lddsp	r9,sp[0xc]
800097ca:	12 1a       	sub	r10,r9
800097cc:	50 4a       	stdsp	sp[0x10],r10
800097ce:	58 0a       	cp.w	r10,0
800097d0:	e0 89 00 20 	brgt	80009810 <_vfprintf_r+0x16ec>
800097d4:	c3 f8       	rjmp	80009852 <_vfprintf_r+0x172e>
800097d6:	2f 09       	sub	r9,-16
800097d8:	2f f8       	sub	r8,-1
800097da:	fe ce b7 f2 	sub	lr,pc,-18446
800097de:	31 0c       	mov	r12,16
800097e0:	fb 49 06 90 	st.w	sp[1680],r9
800097e4:	87 0e       	st.w	r3[0x0],lr
800097e6:	87 1c       	st.w	r3[0x4],r12
800097e8:	fb 48 06 8c 	st.w	sp[1676],r8
800097ec:	58 78       	cp.w	r8,7
800097ee:	e0 89 00 04 	brgt	800097f6 <_vfprintf_r+0x16d2>
800097f2:	2f 83       	sub	r3,-8
800097f4:	c0 b8       	rjmp	8000980a <_vfprintf_r+0x16e6>
800097f6:	fa ca f9 78 	sub	r10,sp,-1672
800097fa:	02 9b       	mov	r11,r1
800097fc:	08 9c       	mov	r12,r4
800097fe:	fe b0 f4 85 	rcall	80008108 <__sprint_r>
80009802:	e0 81 04 10 	brne	8000a022 <_vfprintf_r+0x1efe>
80009806:	fa c3 f9 e0 	sub	r3,sp,-1568
8000980a:	40 4b       	lddsp	r11,sp[0x10]
8000980c:	21 0b       	sub	r11,16
8000980e:	50 4b       	stdsp	sp[0x10],r11
80009810:	fa f9 06 90 	ld.w	r9,sp[1680]
80009814:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009818:	fe ca b8 30 	sub	r10,pc,-18384
8000981c:	40 4e       	lddsp	lr,sp[0x10]
8000981e:	59 0e       	cp.w	lr,16
80009820:	fe 99 ff db 	brgt	800097d6 <_vfprintf_r+0x16b2>
80009824:	1c 09       	add	r9,lr
80009826:	2f f8       	sub	r8,-1
80009828:	87 0a       	st.w	r3[0x0],r10
8000982a:	fb 49 06 90 	st.w	sp[1680],r9
8000982e:	87 1e       	st.w	r3[0x4],lr
80009830:	fb 48 06 8c 	st.w	sp[1676],r8
80009834:	58 78       	cp.w	r8,7
80009836:	e0 89 00 04 	brgt	8000983e <_vfprintf_r+0x171a>
8000983a:	2f 83       	sub	r3,-8
8000983c:	c0 b8       	rjmp	80009852 <_vfprintf_r+0x172e>
8000983e:	fa ca f9 78 	sub	r10,sp,-1672
80009842:	02 9b       	mov	r11,r1
80009844:	08 9c       	mov	r12,r4
80009846:	fe b0 f4 61 	rcall	80008108 <__sprint_r>
8000984a:	e0 81 03 ec 	brne	8000a022 <_vfprintf_r+0x1efe>
8000984e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009852:	30 09       	mov	r9,0
80009854:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009858:	f2 08 18 00 	cp.b	r8,r9
8000985c:	c1 f0       	breq	8000989a <_vfprintf_r+0x1776>
8000985e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009862:	fa c9 f9 45 	sub	r9,sp,-1723
80009866:	2f f8       	sub	r8,-1
80009868:	87 09       	st.w	r3[0x0],r9
8000986a:	fb 48 06 90 	st.w	sp[1680],r8
8000986e:	30 19       	mov	r9,1
80009870:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009874:	87 19       	st.w	r3[0x4],r9
80009876:	2f f8       	sub	r8,-1
80009878:	fb 48 06 8c 	st.w	sp[1676],r8
8000987c:	58 78       	cp.w	r8,7
8000987e:	e0 89 00 04 	brgt	80009886 <_vfprintf_r+0x1762>
80009882:	2f 83       	sub	r3,-8
80009884:	c0 b8       	rjmp	8000989a <_vfprintf_r+0x1776>
80009886:	fa ca f9 78 	sub	r10,sp,-1672
8000988a:	02 9b       	mov	r11,r1
8000988c:	08 9c       	mov	r12,r4
8000988e:	fe b0 f4 3d 	rcall	80008108 <__sprint_r>
80009892:	e0 81 03 c8 	brne	8000a022 <_vfprintf_r+0x1efe>
80009896:	fa c3 f9 e0 	sub	r3,sp,-1568
8000989a:	40 fc       	lddsp	r12,sp[0x3c]
8000989c:	58 0c       	cp.w	r12,0
8000989e:	c1 f0       	breq	800098dc <_vfprintf_r+0x17b8>
800098a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800098a4:	fa c9 f9 48 	sub	r9,sp,-1720
800098a8:	2f e8       	sub	r8,-2
800098aa:	87 09       	st.w	r3[0x0],r9
800098ac:	fb 48 06 90 	st.w	sp[1680],r8
800098b0:	30 29       	mov	r9,2
800098b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098b6:	87 19       	st.w	r3[0x4],r9
800098b8:	2f f8       	sub	r8,-1
800098ba:	fb 48 06 8c 	st.w	sp[1676],r8
800098be:	58 78       	cp.w	r8,7
800098c0:	e0 89 00 04 	brgt	800098c8 <_vfprintf_r+0x17a4>
800098c4:	2f 83       	sub	r3,-8
800098c6:	c0 b8       	rjmp	800098dc <_vfprintf_r+0x17b8>
800098c8:	fa ca f9 78 	sub	r10,sp,-1672
800098cc:	02 9b       	mov	r11,r1
800098ce:	08 9c       	mov	r12,r4
800098d0:	fe b0 f4 1c 	rcall	80008108 <__sprint_r>
800098d4:	e0 81 03 a7 	brne	8000a022 <_vfprintf_r+0x1efe>
800098d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098dc:	40 9b       	lddsp	r11,sp[0x24]
800098de:	e0 4b 00 80 	cp.w	r11,128
800098e2:	c4 71       	brne	80009970 <_vfprintf_r+0x184c>
800098e4:	40 8a       	lddsp	r10,sp[0x20]
800098e6:	40 39       	lddsp	r9,sp[0xc]
800098e8:	12 1a       	sub	r10,r9
800098ea:	50 4a       	stdsp	sp[0x10],r10
800098ec:	58 0a       	cp.w	r10,0
800098ee:	e0 89 00 20 	brgt	8000992e <_vfprintf_r+0x180a>
800098f2:	c3 f8       	rjmp	80009970 <_vfprintf_r+0x184c>
800098f4:	2f 09       	sub	r9,-16
800098f6:	2f f8       	sub	r8,-1
800098f8:	fe ce b9 00 	sub	lr,pc,-18176
800098fc:	31 0c       	mov	r12,16
800098fe:	fb 49 06 90 	st.w	sp[1680],r9
80009902:	87 0e       	st.w	r3[0x0],lr
80009904:	87 1c       	st.w	r3[0x4],r12
80009906:	fb 48 06 8c 	st.w	sp[1676],r8
8000990a:	58 78       	cp.w	r8,7
8000990c:	e0 89 00 04 	brgt	80009914 <_vfprintf_r+0x17f0>
80009910:	2f 83       	sub	r3,-8
80009912:	c0 b8       	rjmp	80009928 <_vfprintf_r+0x1804>
80009914:	fa ca f9 78 	sub	r10,sp,-1672
80009918:	02 9b       	mov	r11,r1
8000991a:	08 9c       	mov	r12,r4
8000991c:	fe b0 f3 f6 	rcall	80008108 <__sprint_r>
80009920:	e0 81 03 81 	brne	8000a022 <_vfprintf_r+0x1efe>
80009924:	fa c3 f9 e0 	sub	r3,sp,-1568
80009928:	40 4b       	lddsp	r11,sp[0x10]
8000992a:	21 0b       	sub	r11,16
8000992c:	50 4b       	stdsp	sp[0x10],r11
8000992e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009932:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009936:	fe ca b9 3e 	sub	r10,pc,-18114
8000993a:	40 4e       	lddsp	lr,sp[0x10]
8000993c:	59 0e       	cp.w	lr,16
8000993e:	fe 99 ff db 	brgt	800098f4 <_vfprintf_r+0x17d0>
80009942:	1c 09       	add	r9,lr
80009944:	2f f8       	sub	r8,-1
80009946:	87 0a       	st.w	r3[0x0],r10
80009948:	fb 49 06 90 	st.w	sp[1680],r9
8000994c:	87 1e       	st.w	r3[0x4],lr
8000994e:	fb 48 06 8c 	st.w	sp[1676],r8
80009952:	58 78       	cp.w	r8,7
80009954:	e0 89 00 04 	brgt	8000995c <_vfprintf_r+0x1838>
80009958:	2f 83       	sub	r3,-8
8000995a:	c0 b8       	rjmp	80009970 <_vfprintf_r+0x184c>
8000995c:	fa ca f9 78 	sub	r10,sp,-1672
80009960:	02 9b       	mov	r11,r1
80009962:	08 9c       	mov	r12,r4
80009964:	fe b0 f3 d2 	rcall	80008108 <__sprint_r>
80009968:	e0 81 03 5d 	brne	8000a022 <_vfprintf_r+0x1efe>
8000996c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009970:	40 2c       	lddsp	r12,sp[0x8]
80009972:	04 1c       	sub	r12,r2
80009974:	50 2c       	stdsp	sp[0x8],r12
80009976:	58 0c       	cp.w	r12,0
80009978:	e0 89 00 20 	brgt	800099b8 <_vfprintf_r+0x1894>
8000997c:	c3 f8       	rjmp	800099fa <_vfprintf_r+0x18d6>
8000997e:	2f 09       	sub	r9,-16
80009980:	2f f8       	sub	r8,-1
80009982:	fe cb b9 8a 	sub	r11,pc,-18038
80009986:	31 0a       	mov	r10,16
80009988:	fb 49 06 90 	st.w	sp[1680],r9
8000998c:	87 0b       	st.w	r3[0x0],r11
8000998e:	87 1a       	st.w	r3[0x4],r10
80009990:	fb 48 06 8c 	st.w	sp[1676],r8
80009994:	58 78       	cp.w	r8,7
80009996:	e0 89 00 04 	brgt	8000999e <_vfprintf_r+0x187a>
8000999a:	2f 83       	sub	r3,-8
8000999c:	c0 b8       	rjmp	800099b2 <_vfprintf_r+0x188e>
8000999e:	fa ca f9 78 	sub	r10,sp,-1672
800099a2:	02 9b       	mov	r11,r1
800099a4:	08 9c       	mov	r12,r4
800099a6:	fe b0 f3 b1 	rcall	80008108 <__sprint_r>
800099aa:	e0 81 03 3c 	brne	8000a022 <_vfprintf_r+0x1efe>
800099ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800099b2:	40 29       	lddsp	r9,sp[0x8]
800099b4:	21 09       	sub	r9,16
800099b6:	50 29       	stdsp	sp[0x8],r9
800099b8:	fa f9 06 90 	ld.w	r9,sp[1680]
800099bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099c0:	fe ca b9 c8 	sub	r10,pc,-17976
800099c4:	40 2e       	lddsp	lr,sp[0x8]
800099c6:	59 0e       	cp.w	lr,16
800099c8:	fe 99 ff db 	brgt	8000997e <_vfprintf_r+0x185a>
800099cc:	1c 09       	add	r9,lr
800099ce:	2f f8       	sub	r8,-1
800099d0:	87 0a       	st.w	r3[0x0],r10
800099d2:	fb 49 06 90 	st.w	sp[1680],r9
800099d6:	87 1e       	st.w	r3[0x4],lr
800099d8:	fb 48 06 8c 	st.w	sp[1676],r8
800099dc:	58 78       	cp.w	r8,7
800099de:	e0 89 00 04 	brgt	800099e6 <_vfprintf_r+0x18c2>
800099e2:	2f 83       	sub	r3,-8
800099e4:	c0 b8       	rjmp	800099fa <_vfprintf_r+0x18d6>
800099e6:	fa ca f9 78 	sub	r10,sp,-1672
800099ea:	02 9b       	mov	r11,r1
800099ec:	08 9c       	mov	r12,r4
800099ee:	fe b0 f3 8d 	rcall	80008108 <__sprint_r>
800099f2:	e0 81 03 18 	brne	8000a022 <_vfprintf_r+0x1efe>
800099f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099fa:	ed b5 00 08 	bld	r5,0x8
800099fe:	c0 b0       	breq	80009a14 <_vfprintf_r+0x18f0>
80009a00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a04:	87 12       	st.w	r3[0x4],r2
80009a06:	87 06       	st.w	r3[0x0],r6
80009a08:	f0 02 00 02 	add	r2,r8,r2
80009a0c:	fb 42 06 90 	st.w	sp[1680],r2
80009a10:	e0 8f 01 d4 	bral	80009db8 <_vfprintf_r+0x1c94>
80009a14:	e0 40 00 65 	cp.w	r0,101
80009a18:	e0 8a 01 d6 	brle	80009dc4 <_vfprintf_r+0x1ca0>
80009a1c:	30 08       	mov	r8,0
80009a1e:	30 09       	mov	r9,0
80009a20:	40 5b       	lddsp	r11,sp[0x14]
80009a22:	40 7a       	lddsp	r10,sp[0x1c]
80009a24:	e0 a0 15 3b 	rcall	8000c49a <__avr32_f64_cmp_eq>
80009a28:	c7 90       	breq	80009b1a <_vfprintf_r+0x19f6>
80009a2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a2e:	fe c9 ba 4a 	sub	r9,pc,-17846
80009a32:	2f f8       	sub	r8,-1
80009a34:	87 09       	st.w	r3[0x0],r9
80009a36:	fb 48 06 90 	st.w	sp[1680],r8
80009a3a:	30 19       	mov	r9,1
80009a3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a40:	87 19       	st.w	r3[0x4],r9
80009a42:	2f f8       	sub	r8,-1
80009a44:	fb 48 06 8c 	st.w	sp[1676],r8
80009a48:	58 78       	cp.w	r8,7
80009a4a:	e0 89 00 05 	brgt	80009a54 <_vfprintf_r+0x1930>
80009a4e:	2f 83       	sub	r3,-8
80009a50:	c0 c8       	rjmp	80009a68 <_vfprintf_r+0x1944>
80009a52:	d7 03       	nop
80009a54:	fa ca f9 78 	sub	r10,sp,-1672
80009a58:	02 9b       	mov	r11,r1
80009a5a:	08 9c       	mov	r12,r4
80009a5c:	fe b0 f3 56 	rcall	80008108 <__sprint_r>
80009a60:	e0 81 02 e1 	brne	8000a022 <_vfprintf_r+0x1efe>
80009a64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a68:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a6c:	40 6c       	lddsp	r12,sp[0x18]
80009a6e:	18 38       	cp.w	r8,r12
80009a70:	c0 55       	brlt	80009a7a <_vfprintf_r+0x1956>
80009a72:	ed b5 00 00 	bld	r5,0x0
80009a76:	e0 81 02 6b 	brne	80009f4c <_vfprintf_r+0x1e28>
80009a7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a7e:	2f f8       	sub	r8,-1
80009a80:	40 cb       	lddsp	r11,sp[0x30]
80009a82:	fb 48 06 90 	st.w	sp[1680],r8
80009a86:	30 19       	mov	r9,1
80009a88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a8c:	87 0b       	st.w	r3[0x0],r11
80009a8e:	2f f8       	sub	r8,-1
80009a90:	87 19       	st.w	r3[0x4],r9
80009a92:	fb 48 06 8c 	st.w	sp[1676],r8
80009a96:	58 78       	cp.w	r8,7
80009a98:	e0 89 00 04 	brgt	80009aa0 <_vfprintf_r+0x197c>
80009a9c:	2f 83       	sub	r3,-8
80009a9e:	c0 b8       	rjmp	80009ab4 <_vfprintf_r+0x1990>
80009aa0:	fa ca f9 78 	sub	r10,sp,-1672
80009aa4:	02 9b       	mov	r11,r1
80009aa6:	08 9c       	mov	r12,r4
80009aa8:	fe b0 f3 30 	rcall	80008108 <__sprint_r>
80009aac:	e0 81 02 bb 	brne	8000a022 <_vfprintf_r+0x1efe>
80009ab0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab4:	40 66       	lddsp	r6,sp[0x18]
80009ab6:	20 16       	sub	r6,1
80009ab8:	58 06       	cp.w	r6,0
80009aba:	e0 89 00 1d 	brgt	80009af4 <_vfprintf_r+0x19d0>
80009abe:	e0 8f 02 47 	bral	80009f4c <_vfprintf_r+0x1e28>
80009ac2:	2f 09       	sub	r9,-16
80009ac4:	2f f8       	sub	r8,-1
80009ac6:	fb 49 06 90 	st.w	sp[1680],r9
80009aca:	87 02       	st.w	r3[0x0],r2
80009acc:	87 10       	st.w	r3[0x4],r0
80009ace:	fb 48 06 8c 	st.w	sp[1676],r8
80009ad2:	58 78       	cp.w	r8,7
80009ad4:	e0 89 00 04 	brgt	80009adc <_vfprintf_r+0x19b8>
80009ad8:	2f 83       	sub	r3,-8
80009ada:	c0 b8       	rjmp	80009af0 <_vfprintf_r+0x19cc>
80009adc:	fa ca f9 78 	sub	r10,sp,-1672
80009ae0:	02 9b       	mov	r11,r1
80009ae2:	08 9c       	mov	r12,r4
80009ae4:	fe b0 f3 12 	rcall	80008108 <__sprint_r>
80009ae8:	e0 81 02 9d 	brne	8000a022 <_vfprintf_r+0x1efe>
80009aec:	fa c3 f9 e0 	sub	r3,sp,-1568
80009af0:	21 06       	sub	r6,16
80009af2:	c0 48       	rjmp	80009afa <_vfprintf_r+0x19d6>
80009af4:	fe c2 ba fc 	sub	r2,pc,-17668
80009af8:	31 00       	mov	r0,16
80009afa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009afe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b02:	fe ca bb 0a 	sub	r10,pc,-17654
80009b06:	59 06       	cp.w	r6,16
80009b08:	fe 99 ff dd 	brgt	80009ac2 <_vfprintf_r+0x199e>
80009b0c:	0c 09       	add	r9,r6
80009b0e:	87 0a       	st.w	r3[0x0],r10
80009b10:	fb 49 06 90 	st.w	sp[1680],r9
80009b14:	2f f8       	sub	r8,-1
80009b16:	87 16       	st.w	r3[0x4],r6
80009b18:	c5 39       	rjmp	80009dbe <_vfprintf_r+0x1c9a>
80009b1a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009b1e:	58 0a       	cp.w	r10,0
80009b20:	e0 89 00 92 	brgt	80009c44 <_vfprintf_r+0x1b20>
80009b24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b28:	fe c9 bb 44 	sub	r9,pc,-17596
80009b2c:	2f f8       	sub	r8,-1
80009b2e:	87 09       	st.w	r3[0x0],r9
80009b30:	fb 48 06 90 	st.w	sp[1680],r8
80009b34:	30 19       	mov	r9,1
80009b36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3a:	87 19       	st.w	r3[0x4],r9
80009b3c:	2f f8       	sub	r8,-1
80009b3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b42:	58 78       	cp.w	r8,7
80009b44:	e0 89 00 04 	brgt	80009b4c <_vfprintf_r+0x1a28>
80009b48:	2f 83       	sub	r3,-8
80009b4a:	c0 b8       	rjmp	80009b60 <_vfprintf_r+0x1a3c>
80009b4c:	fa ca f9 78 	sub	r10,sp,-1672
80009b50:	02 9b       	mov	r11,r1
80009b52:	08 9c       	mov	r12,r4
80009b54:	fe b0 f2 da 	rcall	80008108 <__sprint_r>
80009b58:	e0 81 02 65 	brne	8000a022 <_vfprintf_r+0x1efe>
80009b5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b60:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b64:	58 08       	cp.w	r8,0
80009b66:	c0 81       	brne	80009b76 <_vfprintf_r+0x1a52>
80009b68:	40 6a       	lddsp	r10,sp[0x18]
80009b6a:	58 0a       	cp.w	r10,0
80009b6c:	c0 51       	brne	80009b76 <_vfprintf_r+0x1a52>
80009b6e:	ed b5 00 00 	bld	r5,0x0
80009b72:	e0 81 01 ed 	brne	80009f4c <_vfprintf_r+0x1e28>
80009b76:	40 c9       	lddsp	r9,sp[0x30]
80009b78:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b7c:	2f f8       	sub	r8,-1
80009b7e:	87 09       	st.w	r3[0x0],r9
80009b80:	fb 48 06 90 	st.w	sp[1680],r8
80009b84:	30 19       	mov	r9,1
80009b86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b8a:	87 19       	st.w	r3[0x4],r9
80009b8c:	2f f8       	sub	r8,-1
80009b8e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b92:	58 78       	cp.w	r8,7
80009b94:	e0 89 00 04 	brgt	80009b9c <_vfprintf_r+0x1a78>
80009b98:	2f 83       	sub	r3,-8
80009b9a:	c0 b8       	rjmp	80009bb0 <_vfprintf_r+0x1a8c>
80009b9c:	fa ca f9 78 	sub	r10,sp,-1672
80009ba0:	02 9b       	mov	r11,r1
80009ba2:	08 9c       	mov	r12,r4
80009ba4:	fe b0 f2 b2 	rcall	80008108 <__sprint_r>
80009ba8:	e0 81 02 3d 	brne	8000a022 <_vfprintf_r+0x1efe>
80009bac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bb4:	5c 32       	neg	r2
80009bb6:	58 02       	cp.w	r2,0
80009bb8:	e0 89 00 1d 	brgt	80009bf2 <_vfprintf_r+0x1ace>
80009bbc:	c3 d8       	rjmp	80009c36 <_vfprintf_r+0x1b12>
80009bbe:	2f 09       	sub	r9,-16
80009bc0:	2f f8       	sub	r8,-1
80009bc2:	31 0e       	mov	lr,16
80009bc4:	fb 49 06 90 	st.w	sp[1680],r9
80009bc8:	87 00       	st.w	r3[0x0],r0
80009bca:	87 1e       	st.w	r3[0x4],lr
80009bcc:	fb 48 06 8c 	st.w	sp[1676],r8
80009bd0:	58 78       	cp.w	r8,7
80009bd2:	e0 89 00 04 	brgt	80009bda <_vfprintf_r+0x1ab6>
80009bd6:	2f 83       	sub	r3,-8
80009bd8:	c0 b8       	rjmp	80009bee <_vfprintf_r+0x1aca>
80009bda:	fa ca f9 78 	sub	r10,sp,-1672
80009bde:	02 9b       	mov	r11,r1
80009be0:	08 9c       	mov	r12,r4
80009be2:	fe b0 f2 93 	rcall	80008108 <__sprint_r>
80009be6:	e0 81 02 1e 	brne	8000a022 <_vfprintf_r+0x1efe>
80009bea:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bee:	21 02       	sub	r2,16
80009bf0:	c0 38       	rjmp	80009bf6 <_vfprintf_r+0x1ad2>
80009bf2:	fe c0 bb fa 	sub	r0,pc,-17414
80009bf6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bfa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bfe:	fe ca bc 06 	sub	r10,pc,-17402
80009c02:	59 02       	cp.w	r2,16
80009c04:	fe 99 ff dd 	brgt	80009bbe <_vfprintf_r+0x1a9a>
80009c08:	04 09       	add	r9,r2
80009c0a:	2f f8       	sub	r8,-1
80009c0c:	87 0a       	st.w	r3[0x0],r10
80009c0e:	fb 49 06 90 	st.w	sp[1680],r9
80009c12:	87 12       	st.w	r3[0x4],r2
80009c14:	fb 48 06 8c 	st.w	sp[1676],r8
80009c18:	58 78       	cp.w	r8,7
80009c1a:	e0 89 00 04 	brgt	80009c22 <_vfprintf_r+0x1afe>
80009c1e:	2f 83       	sub	r3,-8
80009c20:	c0 b8       	rjmp	80009c36 <_vfprintf_r+0x1b12>
80009c22:	fa ca f9 78 	sub	r10,sp,-1672
80009c26:	02 9b       	mov	r11,r1
80009c28:	08 9c       	mov	r12,r4
80009c2a:	fe b0 f2 6f 	rcall	80008108 <__sprint_r>
80009c2e:	e0 81 01 fa 	brne	8000a022 <_vfprintf_r+0x1efe>
80009c32:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c36:	40 6c       	lddsp	r12,sp[0x18]
80009c38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c3c:	87 06       	st.w	r3[0x0],r6
80009c3e:	87 1c       	st.w	r3[0x4],r12
80009c40:	18 08       	add	r8,r12
80009c42:	cb 98       	rjmp	80009db4 <_vfprintf_r+0x1c90>
80009c44:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c48:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c4c:	40 6b       	lddsp	r11,sp[0x18]
80009c4e:	16 3a       	cp.w	r10,r11
80009c50:	c6 f5       	brlt	80009d2e <_vfprintf_r+0x1c0a>
80009c52:	16 09       	add	r9,r11
80009c54:	2f f8       	sub	r8,-1
80009c56:	87 06       	st.w	r3[0x0],r6
80009c58:	fb 49 06 90 	st.w	sp[1680],r9
80009c5c:	87 1b       	st.w	r3[0x4],r11
80009c5e:	fb 48 06 8c 	st.w	sp[1676],r8
80009c62:	58 78       	cp.w	r8,7
80009c64:	e0 89 00 04 	brgt	80009c6c <_vfprintf_r+0x1b48>
80009c68:	2f 83       	sub	r3,-8
80009c6a:	c0 b8       	rjmp	80009c80 <_vfprintf_r+0x1b5c>
80009c6c:	fa ca f9 78 	sub	r10,sp,-1672
80009c70:	02 9b       	mov	r11,r1
80009c72:	08 9c       	mov	r12,r4
80009c74:	fe b0 f2 4a 	rcall	80008108 <__sprint_r>
80009c78:	e0 81 01 d5 	brne	8000a022 <_vfprintf_r+0x1efe>
80009c7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c80:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c84:	40 6a       	lddsp	r10,sp[0x18]
80009c86:	14 16       	sub	r6,r10
80009c88:	58 06       	cp.w	r6,0
80009c8a:	e0 89 00 1c 	brgt	80009cc2 <_vfprintf_r+0x1b9e>
80009c8e:	c3 d8       	rjmp	80009d08 <_vfprintf_r+0x1be4>
80009c90:	2f 09       	sub	r9,-16
80009c92:	2f f8       	sub	r8,-1
80009c94:	fb 49 06 90 	st.w	sp[1680],r9
80009c98:	87 02       	st.w	r3[0x0],r2
80009c9a:	87 10       	st.w	r3[0x4],r0
80009c9c:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca0:	58 78       	cp.w	r8,7
80009ca2:	e0 89 00 04 	brgt	80009caa <_vfprintf_r+0x1b86>
80009ca6:	2f 83       	sub	r3,-8
80009ca8:	c0 b8       	rjmp	80009cbe <_vfprintf_r+0x1b9a>
80009caa:	fa ca f9 78 	sub	r10,sp,-1672
80009cae:	02 9b       	mov	r11,r1
80009cb0:	08 9c       	mov	r12,r4
80009cb2:	fe b0 f2 2b 	rcall	80008108 <__sprint_r>
80009cb6:	e0 81 01 b6 	brne	8000a022 <_vfprintf_r+0x1efe>
80009cba:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cbe:	21 06       	sub	r6,16
80009cc0:	c0 48       	rjmp	80009cc8 <_vfprintf_r+0x1ba4>
80009cc2:	fe c2 bc ca 	sub	r2,pc,-17206
80009cc6:	31 00       	mov	r0,16
80009cc8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ccc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd0:	fe ca bc d8 	sub	r10,pc,-17192
80009cd4:	59 06       	cp.w	r6,16
80009cd6:	fe 99 ff dd 	brgt	80009c90 <_vfprintf_r+0x1b6c>
80009cda:	0c 09       	add	r9,r6
80009cdc:	2f f8       	sub	r8,-1
80009cde:	87 0a       	st.w	r3[0x0],r10
80009ce0:	fb 49 06 90 	st.w	sp[1680],r9
80009ce4:	87 16       	st.w	r3[0x4],r6
80009ce6:	fb 48 06 8c 	st.w	sp[1676],r8
80009cea:	58 78       	cp.w	r8,7
80009cec:	e0 89 00 04 	brgt	80009cf4 <_vfprintf_r+0x1bd0>
80009cf0:	2f 83       	sub	r3,-8
80009cf2:	c0 b8       	rjmp	80009d08 <_vfprintf_r+0x1be4>
80009cf4:	fa ca f9 78 	sub	r10,sp,-1672
80009cf8:	02 9b       	mov	r11,r1
80009cfa:	08 9c       	mov	r12,r4
80009cfc:	fe b0 f2 06 	rcall	80008108 <__sprint_r>
80009d00:	e0 81 01 91 	brne	8000a022 <_vfprintf_r+0x1efe>
80009d04:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d08:	ed b5 00 00 	bld	r5,0x0
80009d0c:	e0 81 01 20 	brne	80009f4c <_vfprintf_r+0x1e28>
80009d10:	40 c9       	lddsp	r9,sp[0x30]
80009d12:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d16:	2f f8       	sub	r8,-1
80009d18:	87 09       	st.w	r3[0x0],r9
80009d1a:	fb 48 06 90 	st.w	sp[1680],r8
80009d1e:	30 19       	mov	r9,1
80009d20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d24:	87 19       	st.w	r3[0x4],r9
80009d26:	2f f8       	sub	r8,-1
80009d28:	fb 48 06 8c 	st.w	sp[1676],r8
80009d2c:	c0 29       	rjmp	80009f30 <_vfprintf_r+0x1e0c>
80009d2e:	14 09       	add	r9,r10
80009d30:	2f f8       	sub	r8,-1
80009d32:	fb 49 06 90 	st.w	sp[1680],r9
80009d36:	87 06       	st.w	r3[0x0],r6
80009d38:	87 1a       	st.w	r3[0x4],r10
80009d3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d3e:	58 78       	cp.w	r8,7
80009d40:	e0 89 00 04 	brgt	80009d48 <_vfprintf_r+0x1c24>
80009d44:	2f 83       	sub	r3,-8
80009d46:	c0 b8       	rjmp	80009d5c <_vfprintf_r+0x1c38>
80009d48:	fa ca f9 78 	sub	r10,sp,-1672
80009d4c:	02 9b       	mov	r11,r1
80009d4e:	08 9c       	mov	r12,r4
80009d50:	fe b0 f1 dc 	rcall	80008108 <__sprint_r>
80009d54:	e0 81 01 67 	brne	8000a022 <_vfprintf_r+0x1efe>
80009d58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d5c:	40 c8       	lddsp	r8,sp[0x30]
80009d5e:	87 08       	st.w	r3[0x0],r8
80009d60:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d64:	2f f8       	sub	r8,-1
80009d66:	30 19       	mov	r9,1
80009d68:	fb 48 06 90 	st.w	sp[1680],r8
80009d6c:	87 19       	st.w	r3[0x4],r9
80009d6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d72:	2f f8       	sub	r8,-1
80009d74:	fb 48 06 8c 	st.w	sp[1676],r8
80009d78:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d7c:	58 78       	cp.w	r8,7
80009d7e:	e0 89 00 04 	brgt	80009d86 <_vfprintf_r+0x1c62>
80009d82:	2f 83       	sub	r3,-8
80009d84:	c0 b8       	rjmp	80009d9a <_vfprintf_r+0x1c76>
80009d86:	fa ca f9 78 	sub	r10,sp,-1672
80009d8a:	02 9b       	mov	r11,r1
80009d8c:	08 9c       	mov	r12,r4
80009d8e:	fe b0 f1 bd 	rcall	80008108 <__sprint_r>
80009d92:	e0 81 01 48 	brne	8000a022 <_vfprintf_r+0x1efe>
80009d96:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d9a:	04 06       	add	r6,r2
80009d9c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009da0:	87 06       	st.w	r3[0x0],r6
80009da2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009da6:	40 66       	lddsp	r6,sp[0x18]
80009da8:	40 6e       	lddsp	lr,sp[0x18]
80009daa:	10 16       	sub	r6,r8
80009dac:	f2 08 01 08 	sub	r8,r9,r8
80009db0:	87 16       	st.w	r3[0x4],r6
80009db2:	1c 08       	add	r8,lr
80009db4:	fb 48 06 90 	st.w	sp[1680],r8
80009db8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dbc:	2f f8       	sub	r8,-1
80009dbe:	fb 48 06 8c 	st.w	sp[1676],r8
80009dc2:	cb 78       	rjmp	80009f30 <_vfprintf_r+0x1e0c>
80009dc4:	40 6c       	lddsp	r12,sp[0x18]
80009dc6:	58 1c       	cp.w	r12,1
80009dc8:	e0 89 00 06 	brgt	80009dd4 <_vfprintf_r+0x1cb0>
80009dcc:	ed b5 00 00 	bld	r5,0x0
80009dd0:	e0 81 00 85 	brne	80009eda <_vfprintf_r+0x1db6>
80009dd4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dd8:	2f f8       	sub	r8,-1
80009dda:	30 19       	mov	r9,1
80009ddc:	fb 48 06 90 	st.w	sp[1680],r8
80009de0:	87 06       	st.w	r3[0x0],r6
80009de2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009de6:	87 19       	st.w	r3[0x4],r9
80009de8:	2f f8       	sub	r8,-1
80009dea:	fb 48 06 8c 	st.w	sp[1676],r8
80009dee:	58 78       	cp.w	r8,7
80009df0:	e0 89 00 04 	brgt	80009df8 <_vfprintf_r+0x1cd4>
80009df4:	2f 83       	sub	r3,-8
80009df6:	c0 b8       	rjmp	80009e0c <_vfprintf_r+0x1ce8>
80009df8:	fa ca f9 78 	sub	r10,sp,-1672
80009dfc:	02 9b       	mov	r11,r1
80009dfe:	08 9c       	mov	r12,r4
80009e00:	fe b0 f1 84 	rcall	80008108 <__sprint_r>
80009e04:	e0 81 01 0f 	brne	8000a022 <_vfprintf_r+0x1efe>
80009e08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e10:	2f f8       	sub	r8,-1
80009e12:	40 cb       	lddsp	r11,sp[0x30]
80009e14:	fb 48 06 90 	st.w	sp[1680],r8
80009e18:	30 19       	mov	r9,1
80009e1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e1e:	87 0b       	st.w	r3[0x0],r11
80009e20:	2f f8       	sub	r8,-1
80009e22:	87 19       	st.w	r3[0x4],r9
80009e24:	fb 48 06 8c 	st.w	sp[1676],r8
80009e28:	58 78       	cp.w	r8,7
80009e2a:	e0 89 00 05 	brgt	80009e34 <_vfprintf_r+0x1d10>
80009e2e:	2f 83       	sub	r3,-8
80009e30:	c0 c8       	rjmp	80009e48 <_vfprintf_r+0x1d24>
80009e32:	d7 03       	nop
80009e34:	fa ca f9 78 	sub	r10,sp,-1672
80009e38:	02 9b       	mov	r11,r1
80009e3a:	08 9c       	mov	r12,r4
80009e3c:	fe b0 f1 66 	rcall	80008108 <__sprint_r>
80009e40:	e0 81 00 f1 	brne	8000a022 <_vfprintf_r+0x1efe>
80009e44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e48:	30 08       	mov	r8,0
80009e4a:	30 09       	mov	r9,0
80009e4c:	40 5b       	lddsp	r11,sp[0x14]
80009e4e:	40 7a       	lddsp	r10,sp[0x1c]
80009e50:	e0 a0 13 25 	rcall	8000c49a <__avr32_f64_cmp_eq>
80009e54:	40 68       	lddsp	r8,sp[0x18]
80009e56:	20 18       	sub	r8,1
80009e58:	58 0c       	cp.w	r12,0
80009e5a:	c0 d1       	brne	80009e74 <_vfprintf_r+0x1d50>
80009e5c:	2f f6       	sub	r6,-1
80009e5e:	87 18       	st.w	r3[0x4],r8
80009e60:	87 06       	st.w	r3[0x0],r6
80009e62:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e66:	10 06       	add	r6,r8
80009e68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e6c:	fb 46 06 90 	st.w	sp[1680],r6
80009e70:	2f f8       	sub	r8,-1
80009e72:	c3 18       	rjmp	80009ed4 <_vfprintf_r+0x1db0>
80009e74:	10 96       	mov	r6,r8
80009e76:	58 08       	cp.w	r8,0
80009e78:	e0 89 00 1c 	brgt	80009eb0 <_vfprintf_r+0x1d8c>
80009e7c:	c4 b8       	rjmp	80009f12 <_vfprintf_r+0x1dee>
80009e7e:	2f 09       	sub	r9,-16
80009e80:	2f f8       	sub	r8,-1
80009e82:	fb 49 06 90 	st.w	sp[1680],r9
80009e86:	87 02       	st.w	r3[0x0],r2
80009e88:	87 10       	st.w	r3[0x4],r0
80009e8a:	fb 48 06 8c 	st.w	sp[1676],r8
80009e8e:	58 78       	cp.w	r8,7
80009e90:	e0 89 00 04 	brgt	80009e98 <_vfprintf_r+0x1d74>
80009e94:	2f 83       	sub	r3,-8
80009e96:	c0 b8       	rjmp	80009eac <_vfprintf_r+0x1d88>
80009e98:	fa ca f9 78 	sub	r10,sp,-1672
80009e9c:	02 9b       	mov	r11,r1
80009e9e:	08 9c       	mov	r12,r4
80009ea0:	fe b0 f1 34 	rcall	80008108 <__sprint_r>
80009ea4:	e0 81 00 bf 	brne	8000a022 <_vfprintf_r+0x1efe>
80009ea8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eac:	21 06       	sub	r6,16
80009eae:	c0 48       	rjmp	80009eb6 <_vfprintf_r+0x1d92>
80009eb0:	fe c2 be b8 	sub	r2,pc,-16712
80009eb4:	31 00       	mov	r0,16
80009eb6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009eba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ebe:	fe ca be c6 	sub	r10,pc,-16698
80009ec2:	59 06       	cp.w	r6,16
80009ec4:	fe 99 ff dd 	brgt	80009e7e <_vfprintf_r+0x1d5a>
80009ec8:	0c 09       	add	r9,r6
80009eca:	87 0a       	st.w	r3[0x0],r10
80009ecc:	fb 49 06 90 	st.w	sp[1680],r9
80009ed0:	2f f8       	sub	r8,-1
80009ed2:	87 16       	st.w	r3[0x4],r6
80009ed4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ed8:	c0 e8       	rjmp	80009ef4 <_vfprintf_r+0x1dd0>
80009eda:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ede:	2f f8       	sub	r8,-1
80009ee0:	30 19       	mov	r9,1
80009ee2:	fb 48 06 90 	st.w	sp[1680],r8
80009ee6:	87 06       	st.w	r3[0x0],r6
80009ee8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eec:	87 19       	st.w	r3[0x4],r9
80009eee:	2f f8       	sub	r8,-1
80009ef0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ef4:	58 78       	cp.w	r8,7
80009ef6:	e0 89 00 04 	brgt	80009efe <_vfprintf_r+0x1dda>
80009efa:	2f 83       	sub	r3,-8
80009efc:	c0 b8       	rjmp	80009f12 <_vfprintf_r+0x1dee>
80009efe:	fa ca f9 78 	sub	r10,sp,-1672
80009f02:	02 9b       	mov	r11,r1
80009f04:	08 9c       	mov	r12,r4
80009f06:	fe b0 f1 01 	rcall	80008108 <__sprint_r>
80009f0a:	e0 81 00 8c 	brne	8000a022 <_vfprintf_r+0x1efe>
80009f0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f12:	40 ea       	lddsp	r10,sp[0x38]
80009f14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f18:	14 08       	add	r8,r10
80009f1a:	fa c9 f9 64 	sub	r9,sp,-1692
80009f1e:	fb 48 06 90 	st.w	sp[1680],r8
80009f22:	87 1a       	st.w	r3[0x4],r10
80009f24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f28:	87 09       	st.w	r3[0x0],r9
80009f2a:	2f f8       	sub	r8,-1
80009f2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f30:	58 78       	cp.w	r8,7
80009f32:	e0 89 00 04 	brgt	80009f3a <_vfprintf_r+0x1e16>
80009f36:	2f 83       	sub	r3,-8
80009f38:	c0 a8       	rjmp	80009f4c <_vfprintf_r+0x1e28>
80009f3a:	fa ca f9 78 	sub	r10,sp,-1672
80009f3e:	02 9b       	mov	r11,r1
80009f40:	08 9c       	mov	r12,r4
80009f42:	fe b0 f0 e3 	rcall	80008108 <__sprint_r>
80009f46:	c6 e1       	brne	8000a022 <_vfprintf_r+0x1efe>
80009f48:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f4c:	e2 15 00 04 	andl	r5,0x4,COH
80009f50:	c3 f0       	breq	80009fce <_vfprintf_r+0x1eaa>
80009f52:	40 86       	lddsp	r6,sp[0x20]
80009f54:	40 39       	lddsp	r9,sp[0xc]
80009f56:	12 16       	sub	r6,r9
80009f58:	58 06       	cp.w	r6,0
80009f5a:	e0 89 00 1a 	brgt	80009f8e <_vfprintf_r+0x1e6a>
80009f5e:	c3 88       	rjmp	80009fce <_vfprintf_r+0x1eaa>
80009f60:	2f 09       	sub	r9,-16
80009f62:	2f f8       	sub	r8,-1
80009f64:	fb 49 06 90 	st.w	sp[1680],r9
80009f68:	87 05       	st.w	r3[0x0],r5
80009f6a:	87 12       	st.w	r3[0x4],r2
80009f6c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f70:	58 78       	cp.w	r8,7
80009f72:	e0 89 00 04 	brgt	80009f7a <_vfprintf_r+0x1e56>
80009f76:	2f 83       	sub	r3,-8
80009f78:	c0 98       	rjmp	80009f8a <_vfprintf_r+0x1e66>
80009f7a:	00 9a       	mov	r10,r0
80009f7c:	02 9b       	mov	r11,r1
80009f7e:	08 9c       	mov	r12,r4
80009f80:	fe b0 f0 c4 	rcall	80008108 <__sprint_r>
80009f84:	c4 f1       	brne	8000a022 <_vfprintf_r+0x1efe>
80009f86:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f8a:	21 06       	sub	r6,16
80009f8c:	c0 68       	rjmp	80009f98 <_vfprintf_r+0x1e74>
80009f8e:	fe c5 bf a6 	sub	r5,pc,-16474
80009f92:	31 02       	mov	r2,16
80009f94:	fa c0 f9 78 	sub	r0,sp,-1672
80009f98:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fa0:	fe ca bf b8 	sub	r10,pc,-16456
80009fa4:	59 06       	cp.w	r6,16
80009fa6:	fe 99 ff dd 	brgt	80009f60 <_vfprintf_r+0x1e3c>
80009faa:	0c 09       	add	r9,r6
80009fac:	2f f8       	sub	r8,-1
80009fae:	87 0a       	st.w	r3[0x0],r10
80009fb0:	87 16       	st.w	r3[0x4],r6
80009fb2:	fb 49 06 90 	st.w	sp[1680],r9
80009fb6:	fb 48 06 8c 	st.w	sp[1676],r8
80009fba:	58 78       	cp.w	r8,7
80009fbc:	e0 8a 00 09 	brle	80009fce <_vfprintf_r+0x1eaa>
80009fc0:	fa ca f9 78 	sub	r10,sp,-1672
80009fc4:	02 9b       	mov	r11,r1
80009fc6:	08 9c       	mov	r12,r4
80009fc8:	fe b0 f0 a0 	rcall	80008108 <__sprint_r>
80009fcc:	c2 b1       	brne	8000a022 <_vfprintf_r+0x1efe>
80009fce:	40 bc       	lddsp	r12,sp[0x2c]
80009fd0:	40 36       	lddsp	r6,sp[0xc]
80009fd2:	40 8e       	lddsp	lr,sp[0x20]
80009fd4:	ec 0e 0c 48 	max	r8,r6,lr
80009fd8:	10 0c       	add	r12,r8
80009fda:	50 bc       	stdsp	sp[0x2c],r12
80009fdc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fe0:	58 08       	cp.w	r8,0
80009fe2:	c0 80       	breq	80009ff2 <_vfprintf_r+0x1ece>
80009fe4:	fa ca f9 78 	sub	r10,sp,-1672
80009fe8:	02 9b       	mov	r11,r1
80009fea:	08 9c       	mov	r12,r4
80009fec:	fe b0 f0 8e 	rcall	80008108 <__sprint_r>
80009ff0:	c1 91       	brne	8000a022 <_vfprintf_r+0x1efe>
80009ff2:	30 0b       	mov	r11,0
80009ff4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ff8:	fb 4b 06 8c 	st.w	sp[1676],r11
80009ffc:	fe 9f f1 22 	bral	80008240 <_vfprintf_r+0x11c>
8000a000:	08 95       	mov	r5,r4
8000a002:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a006:	58 08       	cp.w	r8,0
8000a008:	c0 80       	breq	8000a018 <_vfprintf_r+0x1ef4>
8000a00a:	08 9c       	mov	r12,r4
8000a00c:	fa ca f9 78 	sub	r10,sp,-1672
8000a010:	02 9b       	mov	r11,r1
8000a012:	fe b0 f0 7b 	rcall	80008108 <__sprint_r>
8000a016:	c0 61       	brne	8000a022 <_vfprintf_r+0x1efe>
8000a018:	30 08       	mov	r8,0
8000a01a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a01e:	c0 28       	rjmp	8000a022 <_vfprintf_r+0x1efe>
8000a020:	40 41       	lddsp	r1,sp[0x10]
8000a022:	82 68       	ld.sh	r8,r1[0xc]
8000a024:	ed b8 00 06 	bld	r8,0x6
8000a028:	c0 31       	brne	8000a02e <_vfprintf_r+0x1f0a>
8000a02a:	3f fa       	mov	r10,-1
8000a02c:	50 ba       	stdsp	sp[0x2c],r10
8000a02e:	40 bc       	lddsp	r12,sp[0x2c]
8000a030:	fe 3d f9 44 	sub	sp,-1724
8000a034:	d8 32       	popm	r0-r7,pc
8000a036:	d7 03       	nop

8000a038 <__swsetup_r>:
8000a038:	d4 21       	pushm	r4-r7,lr
8000a03a:	e0 68 0a 40 	mov	r8,2624
8000a03e:	18 96       	mov	r6,r12
8000a040:	16 97       	mov	r7,r11
8000a042:	70 0c       	ld.w	r12,r8[0x0]
8000a044:	58 0c       	cp.w	r12,0
8000a046:	c0 60       	breq	8000a052 <__swsetup_r+0x1a>
8000a048:	78 68       	ld.w	r8,r12[0x18]
8000a04a:	58 08       	cp.w	r8,0
8000a04c:	c0 31       	brne	8000a052 <__swsetup_r+0x1a>
8000a04e:	e0 a0 07 bf 	rcall	8000afcc <__sinit>
8000a052:	fe c8 bf 3a 	sub	r8,pc,-16582
8000a056:	10 37       	cp.w	r7,r8
8000a058:	c0 61       	brne	8000a064 <__swsetup_r+0x2c>
8000a05a:	e0 68 0a 40 	mov	r8,2624
8000a05e:	70 08       	ld.w	r8,r8[0x0]
8000a060:	70 07       	ld.w	r7,r8[0x0]
8000a062:	c1 28       	rjmp	8000a086 <__swsetup_r+0x4e>
8000a064:	fe c8 bf 2c 	sub	r8,pc,-16596
8000a068:	10 37       	cp.w	r7,r8
8000a06a:	c0 61       	brne	8000a076 <__swsetup_r+0x3e>
8000a06c:	e0 68 0a 40 	mov	r8,2624
8000a070:	70 08       	ld.w	r8,r8[0x0]
8000a072:	70 17       	ld.w	r7,r8[0x4]
8000a074:	c0 98       	rjmp	8000a086 <__swsetup_r+0x4e>
8000a076:	fe c8 bf 1e 	sub	r8,pc,-16610
8000a07a:	10 37       	cp.w	r7,r8
8000a07c:	c0 51       	brne	8000a086 <__swsetup_r+0x4e>
8000a07e:	e0 68 0a 40 	mov	r8,2624
8000a082:	70 08       	ld.w	r8,r8[0x0]
8000a084:	70 27       	ld.w	r7,r8[0x8]
8000a086:	8e 68       	ld.sh	r8,r7[0xc]
8000a088:	ed b8 00 03 	bld	r8,0x3
8000a08c:	c1 e0       	breq	8000a0c8 <__swsetup_r+0x90>
8000a08e:	ed b8 00 04 	bld	r8,0x4
8000a092:	c3 e1       	brne	8000a10e <__swsetup_r+0xd6>
8000a094:	ed b8 00 02 	bld	r8,0x2
8000a098:	c1 51       	brne	8000a0c2 <__swsetup_r+0x8a>
8000a09a:	6e db       	ld.w	r11,r7[0x34]
8000a09c:	58 0b       	cp.w	r11,0
8000a09e:	c0 a0       	breq	8000a0b2 <__swsetup_r+0x7a>
8000a0a0:	ee c8 ff bc 	sub	r8,r7,-68
8000a0a4:	10 3b       	cp.w	r11,r8
8000a0a6:	c0 40       	breq	8000a0ae <__swsetup_r+0x76>
8000a0a8:	0c 9c       	mov	r12,r6
8000a0aa:	e0 a0 08 2b 	rcall	8000b100 <_free_r>
8000a0ae:	30 08       	mov	r8,0
8000a0b0:	8f d8       	st.w	r7[0x34],r8
8000a0b2:	8e 68       	ld.sh	r8,r7[0xc]
8000a0b4:	e0 18 ff db 	andl	r8,0xffdb
8000a0b8:	ae 68       	st.h	r7[0xc],r8
8000a0ba:	30 08       	mov	r8,0
8000a0bc:	8f 18       	st.w	r7[0x4],r8
8000a0be:	6e 48       	ld.w	r8,r7[0x10]
8000a0c0:	8f 08       	st.w	r7[0x0],r8
8000a0c2:	8e 68       	ld.sh	r8,r7[0xc]
8000a0c4:	a3 b8       	sbr	r8,0x3
8000a0c6:	ae 68       	st.h	r7[0xc],r8
8000a0c8:	6e 48       	ld.w	r8,r7[0x10]
8000a0ca:	58 08       	cp.w	r8,0
8000a0cc:	c0 b1       	brne	8000a0e2 <__swsetup_r+0xaa>
8000a0ce:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d0:	e2 18 02 80 	andl	r8,0x280,COH
8000a0d4:	e0 48 02 00 	cp.w	r8,512
8000a0d8:	c0 50       	breq	8000a0e2 <__swsetup_r+0xaa>
8000a0da:	0c 9c       	mov	r12,r6
8000a0dc:	0e 9b       	mov	r11,r7
8000a0de:	e0 a0 0a 4b 	rcall	8000b574 <__smakebuf_r>
8000a0e2:	8e 69       	ld.sh	r9,r7[0xc]
8000a0e4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a0e8:	c0 70       	breq	8000a0f6 <__swsetup_r+0xbe>
8000a0ea:	30 08       	mov	r8,0
8000a0ec:	8f 28       	st.w	r7[0x8],r8
8000a0ee:	6e 58       	ld.w	r8,r7[0x14]
8000a0f0:	5c 38       	neg	r8
8000a0f2:	8f 68       	st.w	r7[0x18],r8
8000a0f4:	c0 68       	rjmp	8000a100 <__swsetup_r+0xc8>
8000a0f6:	ed b9 00 01 	bld	r9,0x1
8000a0fa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a0fe:	8f 28       	st.w	r7[0x8],r8
8000a100:	6e 48       	ld.w	r8,r7[0x10]
8000a102:	58 08       	cp.w	r8,0
8000a104:	c0 61       	brne	8000a110 <__swsetup_r+0xd8>
8000a106:	8e 68       	ld.sh	r8,r7[0xc]
8000a108:	ed b8 00 07 	bld	r8,0x7
8000a10c:	c0 21       	brne	8000a110 <__swsetup_r+0xd8>
8000a10e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a110:	d8 2a       	popm	r4-r7,pc,r12=0
8000a112:	d7 03       	nop

8000a114 <quorem>:
8000a114:	d4 31       	pushm	r0-r7,lr
8000a116:	20 2d       	sub	sp,8
8000a118:	18 97       	mov	r7,r12
8000a11a:	78 48       	ld.w	r8,r12[0x10]
8000a11c:	76 46       	ld.w	r6,r11[0x10]
8000a11e:	0c 38       	cp.w	r8,r6
8000a120:	c0 34       	brge	8000a126 <quorem+0x12>
8000a122:	30 0c       	mov	r12,0
8000a124:	c8 58       	rjmp	8000a22e <quorem+0x11a>
8000a126:	ec c2 ff fc 	sub	r2,r6,-4
8000a12a:	f6 c3 ff ec 	sub	r3,r11,-20
8000a12e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a132:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a136:	2f f9       	sub	r9,-1
8000a138:	20 16       	sub	r6,1
8000a13a:	f8 09 0d 08 	divu	r8,r12,r9
8000a13e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a142:	ee c4 ff ec 	sub	r4,r7,-20
8000a146:	10 95       	mov	r5,r8
8000a148:	58 08       	cp.w	r8,0
8000a14a:	c4 10       	breq	8000a1cc <quorem+0xb8>
8000a14c:	30 09       	mov	r9,0
8000a14e:	06 9a       	mov	r10,r3
8000a150:	08 98       	mov	r8,r4
8000a152:	12 91       	mov	r1,r9
8000a154:	50 0b       	stdsp	sp[0x0],r11
8000a156:	70 0e       	ld.w	lr,r8[0x0]
8000a158:	b1 8e       	lsr	lr,0x10
8000a15a:	50 1e       	stdsp	sp[0x4],lr
8000a15c:	15 0e       	ld.w	lr,r10++
8000a15e:	fc 00 16 10 	lsr	r0,lr,0x10
8000a162:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a166:	ea 0e 03 41 	mac	r1,r5,lr
8000a16a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a16e:	b1 81       	lsr	r1,0x10
8000a170:	40 1b       	lddsp	r11,sp[0x4]
8000a172:	ea 00 02 40 	mul	r0,r5,r0
8000a176:	e2 00 00 00 	add	r0,r1,r0
8000a17a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a17e:	02 1b       	sub	r11,r1
8000a180:	50 1b       	stdsp	sp[0x4],r11
8000a182:	70 0b       	ld.w	r11,r8[0x0]
8000a184:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a188:	02 09       	add	r9,r1
8000a18a:	f2 0e 01 0e 	sub	lr,r9,lr
8000a18e:	b0 1e       	st.h	r8[0x2],lr
8000a190:	fc 09 14 10 	asr	r9,lr,0x10
8000a194:	40 1e       	lddsp	lr,sp[0x4]
8000a196:	fc 09 00 09 	add	r9,lr,r9
8000a19a:	b0 09       	st.h	r8[0x0],r9
8000a19c:	e0 01 16 10 	lsr	r1,r0,0x10
8000a1a0:	2f c8       	sub	r8,-4
8000a1a2:	b1 49       	asr	r9,0x10
8000a1a4:	04 3a       	cp.w	r10,r2
8000a1a6:	fe 98 ff d8 	brls	8000a156 <quorem+0x42>
8000a1aa:	40 0b       	lddsp	r11,sp[0x0]
8000a1ac:	58 0c       	cp.w	r12,0
8000a1ae:	c0 f1       	brne	8000a1cc <quorem+0xb8>
8000a1b0:	ec c8 ff fb 	sub	r8,r6,-5
8000a1b4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1b8:	c0 28       	rjmp	8000a1bc <quorem+0xa8>
8000a1ba:	20 16       	sub	r6,1
8000a1bc:	20 48       	sub	r8,4
8000a1be:	08 38       	cp.w	r8,r4
8000a1c0:	e0 88 00 05 	brls	8000a1ca <quorem+0xb6>
8000a1c4:	70 09       	ld.w	r9,r8[0x0]
8000a1c6:	58 09       	cp.w	r9,0
8000a1c8:	cf 90       	breq	8000a1ba <quorem+0xa6>
8000a1ca:	8f 46       	st.w	r7[0x10],r6
8000a1cc:	0e 9c       	mov	r12,r7
8000a1ce:	e0 a0 0a d2 	rcall	8000b772 <__mcmp>
8000a1d2:	c2 d5       	brlt	8000a22c <quorem+0x118>
8000a1d4:	2f f5       	sub	r5,-1
8000a1d6:	08 98       	mov	r8,r4
8000a1d8:	30 09       	mov	r9,0
8000a1da:	07 0b       	ld.w	r11,r3++
8000a1dc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a1e0:	70 0c       	ld.w	r12,r8[0x0]
8000a1e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a1e6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a1ea:	14 1e       	sub	lr,r10
8000a1ec:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1f0:	16 1a       	sub	r10,r11
8000a1f2:	12 0a       	add	r10,r9
8000a1f4:	b0 1a       	st.h	r8[0x2],r10
8000a1f6:	b1 4a       	asr	r10,0x10
8000a1f8:	fc 0a 00 09 	add	r9,lr,r10
8000a1fc:	b0 09       	st.h	r8[0x0],r9
8000a1fe:	2f c8       	sub	r8,-4
8000a200:	b1 49       	asr	r9,0x10
8000a202:	04 33       	cp.w	r3,r2
8000a204:	fe 98 ff eb 	brls	8000a1da <quorem+0xc6>
8000a208:	ec c8 ff fb 	sub	r8,r6,-5
8000a20c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a210:	58 09       	cp.w	r9,0
8000a212:	c0 d1       	brne	8000a22c <quorem+0x118>
8000a214:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a218:	c0 28       	rjmp	8000a21c <quorem+0x108>
8000a21a:	20 16       	sub	r6,1
8000a21c:	20 48       	sub	r8,4
8000a21e:	08 38       	cp.w	r8,r4
8000a220:	e0 88 00 05 	brls	8000a22a <quorem+0x116>
8000a224:	70 09       	ld.w	r9,r8[0x0]
8000a226:	58 09       	cp.w	r9,0
8000a228:	cf 90       	breq	8000a21a <quorem+0x106>
8000a22a:	8f 46       	st.w	r7[0x10],r6
8000a22c:	0a 9c       	mov	r12,r5
8000a22e:	2f ed       	sub	sp,-8
8000a230:	d8 32       	popm	r0-r7,pc
8000a232:	d7 03       	nop

8000a234 <_dtoa_r>:
8000a234:	d4 31       	pushm	r0-r7,lr
8000a236:	21 ad       	sub	sp,104
8000a238:	fa c4 ff 74 	sub	r4,sp,-140
8000a23c:	18 97       	mov	r7,r12
8000a23e:	16 95       	mov	r5,r11
8000a240:	68 2c       	ld.w	r12,r4[0x8]
8000a242:	50 c9       	stdsp	sp[0x30],r9
8000a244:	68 16       	ld.w	r6,r4[0x4]
8000a246:	68 09       	ld.w	r9,r4[0x0]
8000a248:	50 e8       	stdsp	sp[0x38],r8
8000a24a:	14 94       	mov	r4,r10
8000a24c:	51 2c       	stdsp	sp[0x48],r12
8000a24e:	fa e5 00 08 	st.d	sp[8],r4
8000a252:	51 59       	stdsp	sp[0x54],r9
8000a254:	6e 95       	ld.w	r5,r7[0x24]
8000a256:	58 05       	cp.w	r5,0
8000a258:	c0 91       	brne	8000a26a <_dtoa_r+0x36>
8000a25a:	31 0c       	mov	r12,16
8000a25c:	fe b0 e8 f4 	rcall	80007444 <malloc>
8000a260:	99 35       	st.w	r12[0xc],r5
8000a262:	8f 9c       	st.w	r7[0x24],r12
8000a264:	99 15       	st.w	r12[0x4],r5
8000a266:	99 25       	st.w	r12[0x8],r5
8000a268:	99 05       	st.w	r12[0x0],r5
8000a26a:	6e 99       	ld.w	r9,r7[0x24]
8000a26c:	72 08       	ld.w	r8,r9[0x0]
8000a26e:	58 08       	cp.w	r8,0
8000a270:	c0 f0       	breq	8000a28e <_dtoa_r+0x5a>
8000a272:	72 1a       	ld.w	r10,r9[0x4]
8000a274:	91 1a       	st.w	r8[0x4],r10
8000a276:	30 1a       	mov	r10,1
8000a278:	72 19       	ld.w	r9,r9[0x4]
8000a27a:	f4 09 09 49 	lsl	r9,r10,r9
8000a27e:	10 9b       	mov	r11,r8
8000a280:	91 29       	st.w	r8[0x8],r9
8000a282:	0e 9c       	mov	r12,r7
8000a284:	e0 a0 0a 90 	rcall	8000b7a4 <_Bfree>
8000a288:	6e 98       	ld.w	r8,r7[0x24]
8000a28a:	30 09       	mov	r9,0
8000a28c:	91 09       	st.w	r8[0x0],r9
8000a28e:	40 28       	lddsp	r8,sp[0x8]
8000a290:	10 94       	mov	r4,r8
8000a292:	58 08       	cp.w	r8,0
8000a294:	c0 64       	brge	8000a2a0 <_dtoa_r+0x6c>
8000a296:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a29a:	50 28       	stdsp	sp[0x8],r8
8000a29c:	30 18       	mov	r8,1
8000a29e:	c0 28       	rjmp	8000a2a2 <_dtoa_r+0x6e>
8000a2a0:	30 08       	mov	r8,0
8000a2a2:	8d 08       	st.w	r6[0x0],r8
8000a2a4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a2a8:	40 26       	lddsp	r6,sp[0x8]
8000a2aa:	0c 98       	mov	r8,r6
8000a2ac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a2b0:	18 38       	cp.w	r8,r12
8000a2b2:	c2 01       	brne	8000a2f2 <_dtoa_r+0xbe>
8000a2b4:	e0 68 27 0f 	mov	r8,9999
8000a2b8:	41 5b       	lddsp	r11,sp[0x54]
8000a2ba:	97 08       	st.w	r11[0x0],r8
8000a2bc:	40 3a       	lddsp	r10,sp[0xc]
8000a2be:	58 0a       	cp.w	r10,0
8000a2c0:	c0 71       	brne	8000a2ce <_dtoa_r+0x9a>
8000a2c2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a2c6:	c0 41       	brne	8000a2ce <_dtoa_r+0x9a>
8000a2c8:	fe cc c1 c0 	sub	r12,pc,-15936
8000a2cc:	c0 38       	rjmp	8000a2d2 <_dtoa_r+0x9e>
8000a2ce:	fe cc c1 ba 	sub	r12,pc,-15942
8000a2d2:	41 29       	lddsp	r9,sp[0x48]
8000a2d4:	58 09       	cp.w	r9,0
8000a2d6:	e0 80 05 9a 	breq	8000ae0a <_dtoa_r+0xbd6>
8000a2da:	f8 c8 ff fd 	sub	r8,r12,-3
8000a2de:	f8 c9 ff f8 	sub	r9,r12,-8
8000a2e2:	11 8b       	ld.ub	r11,r8[0x0]
8000a2e4:	30 0a       	mov	r10,0
8000a2e6:	41 25       	lddsp	r5,sp[0x48]
8000a2e8:	f4 0b 18 00 	cp.b	r11,r10
8000a2ec:	f2 08 17 10 	movne	r8,r9
8000a2f0:	c1 68       	rjmp	8000a31c <_dtoa_r+0xe8>
8000a2f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2f6:	30 08       	mov	r8,0
8000a2f8:	fa eb 00 3c 	st.d	sp[60],r10
8000a2fc:	30 09       	mov	r9,0
8000a2fe:	e0 a0 10 ce 	rcall	8000c49a <__avr32_f64_cmp_eq>
8000a302:	c1 00       	breq	8000a322 <_dtoa_r+0xee>
8000a304:	30 18       	mov	r8,1
8000a306:	41 5a       	lddsp	r10,sp[0x54]
8000a308:	95 08       	st.w	r10[0x0],r8
8000a30a:	fe cc c3 26 	sub	r12,pc,-15578
8000a30e:	41 29       	lddsp	r9,sp[0x48]
8000a310:	f8 08 00 08 	add	r8,r12,r8
8000a314:	58 09       	cp.w	r9,0
8000a316:	e0 80 05 7a 	breq	8000ae0a <_dtoa_r+0xbd6>
8000a31a:	12 95       	mov	r5,r9
8000a31c:	8b 08       	st.w	r5[0x0],r8
8000a31e:	e0 8f 05 76 	bral	8000ae0a <_dtoa_r+0xbd6>
8000a322:	fa c8 ff 9c 	sub	r8,sp,-100
8000a326:	fa c9 ff a0 	sub	r9,sp,-96
8000a32a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a32e:	0e 9c       	mov	r12,r7
8000a330:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a334:	e0 a0 0a 8a 	rcall	8000b848 <__d2b>
8000a338:	18 93       	mov	r3,r12
8000a33a:	58 05       	cp.w	r5,0
8000a33c:	c0 d0       	breq	8000a356 <_dtoa_r+0x122>
8000a33e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a342:	30 04       	mov	r4,0
8000a344:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a348:	ea c5 03 ff 	sub	r5,r5,1023
8000a34c:	10 9b       	mov	r11,r8
8000a34e:	51 74       	stdsp	sp[0x5c],r4
8000a350:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a354:	c2 58       	rjmp	8000a39e <_dtoa_r+0x16a>
8000a356:	41 88       	lddsp	r8,sp[0x60]
8000a358:	41 9c       	lddsp	r12,sp[0x64]
8000a35a:	10 0c       	add	r12,r8
8000a35c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a360:	e0 45 00 20 	cp.w	r5,32
8000a364:	e0 8a 00 0e 	brle	8000a380 <_dtoa_r+0x14c>
8000a368:	f8 cc fb ee 	sub	r12,r12,-1042
8000a36c:	40 3b       	lddsp	r11,sp[0xc]
8000a36e:	ea 08 11 40 	rsub	r8,r5,64
8000a372:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a376:	ec 08 09 46 	lsl	r6,r6,r8
8000a37a:	0c 4c       	or	r12,r6
8000a37c:	c0 78       	rjmp	8000a38a <_dtoa_r+0x156>
8000a37e:	d7 03       	nop
8000a380:	ea 0c 11 20 	rsub	r12,r5,32
8000a384:	40 3a       	lddsp	r10,sp[0xc]
8000a386:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a38a:	e0 a0 10 14 	rcall	8000c3b2 <__avr32_u32_to_f64>
8000a38e:	fc 18 fe 10 	movh	r8,0xfe10
8000a392:	30 19       	mov	r9,1
8000a394:	ea c5 04 33 	sub	r5,r5,1075
8000a398:	f0 0b 00 0b 	add	r11,r8,r11
8000a39c:	51 79       	stdsp	sp[0x5c],r9
8000a39e:	30 08       	mov	r8,0
8000a3a0:	fc 19 3f f8 	movh	r9,0x3ff8
8000a3a4:	e0 a0 0e 9c 	rcall	8000c0dc <__avr32_f64_sub>
8000a3a8:	e0 68 43 61 	mov	r8,17249
8000a3ac:	ea 18 63 6f 	orh	r8,0x636f
8000a3b0:	e0 69 87 a7 	mov	r9,34727
8000a3b4:	ea 19 3f d2 	orh	r9,0x3fd2
8000a3b8:	e0 a0 0d a6 	rcall	8000bf04 <__avr32_f64_mul>
8000a3bc:	e0 68 c8 b3 	mov	r8,51379
8000a3c0:	ea 18 8b 60 	orh	r8,0x8b60
8000a3c4:	e0 69 8a 28 	mov	r9,35368
8000a3c8:	ea 19 3f c6 	orh	r9,0x3fc6
8000a3cc:	e0 a0 0f 56 	rcall	8000c278 <__avr32_f64_add>
8000a3d0:	0a 9c       	mov	r12,r5
8000a3d2:	14 90       	mov	r0,r10
8000a3d4:	16 91       	mov	r1,r11
8000a3d6:	e0 a0 0f f2 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a3da:	e0 68 79 fb 	mov	r8,31227
8000a3de:	ea 18 50 9f 	orh	r8,0x509f
8000a3e2:	e0 69 44 13 	mov	r9,17427
8000a3e6:	ea 19 3f d3 	orh	r9,0x3fd3
8000a3ea:	e0 a0 0d 8d 	rcall	8000bf04 <__avr32_f64_mul>
8000a3ee:	14 98       	mov	r8,r10
8000a3f0:	16 99       	mov	r9,r11
8000a3f2:	00 9a       	mov	r10,r0
8000a3f4:	02 9b       	mov	r11,r1
8000a3f6:	e0 a0 0f 41 	rcall	8000c278 <__avr32_f64_add>
8000a3fa:	14 90       	mov	r0,r10
8000a3fc:	16 91       	mov	r1,r11
8000a3fe:	e0 a0 0f c7 	rcall	8000c38c <__avr32_f64_to_s32>
8000a402:	30 08       	mov	r8,0
8000a404:	18 96       	mov	r6,r12
8000a406:	30 09       	mov	r9,0
8000a408:	00 9a       	mov	r10,r0
8000a40a:	02 9b       	mov	r11,r1
8000a40c:	e0 a0 10 8e 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a410:	c0 c0       	breq	8000a428 <_dtoa_r+0x1f4>
8000a412:	0c 9c       	mov	r12,r6
8000a414:	e0 a0 0f d3 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a418:	14 98       	mov	r8,r10
8000a41a:	16 99       	mov	r9,r11
8000a41c:	00 9a       	mov	r10,r0
8000a41e:	02 9b       	mov	r11,r1
8000a420:	e0 a0 10 3d 	rcall	8000c49a <__avr32_f64_cmp_eq>
8000a424:	f7 b6 00 01 	subeq	r6,1
8000a428:	59 66       	cp.w	r6,22
8000a42a:	e0 88 00 05 	brls	8000a434 <_dtoa_r+0x200>
8000a42e:	30 18       	mov	r8,1
8000a430:	51 48       	stdsp	sp[0x50],r8
8000a432:	c1 38       	rjmp	8000a458 <_dtoa_r+0x224>
8000a434:	fe c8 c2 6c 	sub	r8,pc,-15764
8000a438:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a43c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a440:	e0 a0 10 74 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a444:	f9 b4 00 00 	moveq	r4,0
8000a448:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a44c:	f7 b6 01 01 	subne	r6,1
8000a450:	f9 bc 01 00 	movne	r12,0
8000a454:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a458:	41 90       	lddsp	r0,sp[0x64]
8000a45a:	20 10       	sub	r0,1
8000a45c:	0a 10       	sub	r0,r5
8000a45e:	c0 46       	brmi	8000a466 <_dtoa_r+0x232>
8000a460:	50 40       	stdsp	sp[0x10],r0
8000a462:	30 00       	mov	r0,0
8000a464:	c0 48       	rjmp	8000a46c <_dtoa_r+0x238>
8000a466:	30 0b       	mov	r11,0
8000a468:	5c 30       	neg	r0
8000a46a:	50 4b       	stdsp	sp[0x10],r11
8000a46c:	ec 02 11 00 	rsub	r2,r6,0
8000a470:	58 06       	cp.w	r6,0
8000a472:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a476:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a47a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a47e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a482:	f9 b2 04 00 	movge	r2,0
8000a486:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a48a:	f9 b9 05 00 	movlt	r9,0
8000a48e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a492:	40 c8       	lddsp	r8,sp[0x30]
8000a494:	58 98       	cp.w	r8,9
8000a496:	e0 8b 00 20 	brhi	8000a4d6 <_dtoa_r+0x2a2>
8000a49a:	58 58       	cp.w	r8,5
8000a49c:	f9 b4 0a 01 	movle	r4,1
8000a4a0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a4a4:	f7 b5 09 04 	subgt	r5,4
8000a4a8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a4ac:	f9 b4 09 00 	movgt	r4,0
8000a4b0:	40 cc       	lddsp	r12,sp[0x30]
8000a4b2:	58 3c       	cp.w	r12,3
8000a4b4:	c2 d0       	breq	8000a50e <_dtoa_r+0x2da>
8000a4b6:	e0 89 00 05 	brgt	8000a4c0 <_dtoa_r+0x28c>
8000a4ba:	58 2c       	cp.w	r12,2
8000a4bc:	c1 01       	brne	8000a4dc <_dtoa_r+0x2a8>
8000a4be:	c1 88       	rjmp	8000a4ee <_dtoa_r+0x2ba>
8000a4c0:	40 cb       	lddsp	r11,sp[0x30]
8000a4c2:	58 4b       	cp.w	r11,4
8000a4c4:	c0 60       	breq	8000a4d0 <_dtoa_r+0x29c>
8000a4c6:	58 5b       	cp.w	r11,5
8000a4c8:	c0 a1       	brne	8000a4dc <_dtoa_r+0x2a8>
8000a4ca:	30 1a       	mov	r10,1
8000a4cc:	50 da       	stdsp	sp[0x34],r10
8000a4ce:	c2 28       	rjmp	8000a512 <_dtoa_r+0x2de>
8000a4d0:	30 19       	mov	r9,1
8000a4d2:	50 d9       	stdsp	sp[0x34],r9
8000a4d4:	c0 f8       	rjmp	8000a4f2 <_dtoa_r+0x2be>
8000a4d6:	30 08       	mov	r8,0
8000a4d8:	30 14       	mov	r4,1
8000a4da:	50 c8       	stdsp	sp[0x30],r8
8000a4dc:	3f f5       	mov	r5,-1
8000a4de:	30 1c       	mov	r12,1
8000a4e0:	30 0b       	mov	r11,0
8000a4e2:	50 95       	stdsp	sp[0x24],r5
8000a4e4:	50 dc       	stdsp	sp[0x34],r12
8000a4e6:	0a 91       	mov	r1,r5
8000a4e8:	31 28       	mov	r8,18
8000a4ea:	50 eb       	stdsp	sp[0x38],r11
8000a4ec:	c2 08       	rjmp	8000a52c <_dtoa_r+0x2f8>
8000a4ee:	30 0a       	mov	r10,0
8000a4f0:	50 da       	stdsp	sp[0x34],r10
8000a4f2:	40 e9       	lddsp	r9,sp[0x38]
8000a4f4:	58 09       	cp.w	r9,0
8000a4f6:	e0 89 00 07 	brgt	8000a504 <_dtoa_r+0x2d0>
8000a4fa:	30 18       	mov	r8,1
8000a4fc:	50 98       	stdsp	sp[0x24],r8
8000a4fe:	10 91       	mov	r1,r8
8000a500:	50 e8       	stdsp	sp[0x38],r8
8000a502:	c1 58       	rjmp	8000a52c <_dtoa_r+0x2f8>
8000a504:	40 e5       	lddsp	r5,sp[0x38]
8000a506:	50 95       	stdsp	sp[0x24],r5
8000a508:	0a 91       	mov	r1,r5
8000a50a:	0a 98       	mov	r8,r5
8000a50c:	c1 08       	rjmp	8000a52c <_dtoa_r+0x2f8>
8000a50e:	30 0c       	mov	r12,0
8000a510:	50 dc       	stdsp	sp[0x34],r12
8000a512:	40 eb       	lddsp	r11,sp[0x38]
8000a514:	ec 0b 00 0b 	add	r11,r6,r11
8000a518:	50 9b       	stdsp	sp[0x24],r11
8000a51a:	16 98       	mov	r8,r11
8000a51c:	2f f8       	sub	r8,-1
8000a51e:	58 08       	cp.w	r8,0
8000a520:	e0 89 00 05 	brgt	8000a52a <_dtoa_r+0x2f6>
8000a524:	10 91       	mov	r1,r8
8000a526:	30 18       	mov	r8,1
8000a528:	c0 28       	rjmp	8000a52c <_dtoa_r+0x2f8>
8000a52a:	10 91       	mov	r1,r8
8000a52c:	30 09       	mov	r9,0
8000a52e:	6e 9a       	ld.w	r10,r7[0x24]
8000a530:	95 19       	st.w	r10[0x4],r9
8000a532:	30 49       	mov	r9,4
8000a534:	c0 68       	rjmp	8000a540 <_dtoa_r+0x30c>
8000a536:	d7 03       	nop
8000a538:	6a 1a       	ld.w	r10,r5[0x4]
8000a53a:	a1 79       	lsl	r9,0x1
8000a53c:	2f fa       	sub	r10,-1
8000a53e:	8b 1a       	st.w	r5[0x4],r10
8000a540:	6e 95       	ld.w	r5,r7[0x24]
8000a542:	f2 ca ff ec 	sub	r10,r9,-20
8000a546:	10 3a       	cp.w	r10,r8
8000a548:	fe 98 ff f8 	brls	8000a538 <_dtoa_r+0x304>
8000a54c:	6a 1b       	ld.w	r11,r5[0x4]
8000a54e:	0e 9c       	mov	r12,r7
8000a550:	e0 a0 09 44 	rcall	8000b7d8 <_Balloc>
8000a554:	58 e1       	cp.w	r1,14
8000a556:	5f 88       	srls	r8
8000a558:	8b 0c       	st.w	r5[0x0],r12
8000a55a:	f1 e4 00 04 	and	r4,r8,r4
8000a55e:	6e 98       	ld.w	r8,r7[0x24]
8000a560:	70 08       	ld.w	r8,r8[0x0]
8000a562:	50 88       	stdsp	sp[0x20],r8
8000a564:	e0 80 01 82 	breq	8000a868 <_dtoa_r+0x634>
8000a568:	58 06       	cp.w	r6,0
8000a56a:	e0 8a 00 43 	brle	8000a5f0 <_dtoa_r+0x3bc>
8000a56e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a572:	fe c8 c3 aa 	sub	r8,pc,-15446
8000a576:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a57a:	fa e5 00 18 	st.d	sp[24],r4
8000a57e:	ec 04 14 04 	asr	r4,r6,0x4
8000a582:	ed b4 00 04 	bld	r4,0x4
8000a586:	c0 30       	breq	8000a58c <_dtoa_r+0x358>
8000a588:	30 25       	mov	r5,2
8000a58a:	c1 08       	rjmp	8000a5aa <_dtoa_r+0x376>
8000a58c:	fe c8 c2 fc 	sub	r8,pc,-15620
8000a590:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a594:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a598:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a59c:	e0 a0 0f fa 	rcall	8000c590 <__avr32_f64_div>
8000a5a0:	30 35       	mov	r5,3
8000a5a2:	14 98       	mov	r8,r10
8000a5a4:	16 99       	mov	r9,r11
8000a5a6:	fa e9 00 08 	st.d	sp[8],r8
8000a5aa:	fe cc c3 1a 	sub	r12,pc,-15590
8000a5ae:	50 a3       	stdsp	sp[0x28],r3
8000a5b0:	0c 93       	mov	r3,r6
8000a5b2:	18 96       	mov	r6,r12
8000a5b4:	c0 f8       	rjmp	8000a5d2 <_dtoa_r+0x39e>
8000a5b6:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5ba:	ed b4 00 00 	bld	r4,0x0
8000a5be:	c0 81       	brne	8000a5ce <_dtoa_r+0x39a>
8000a5c0:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5c4:	2f f5       	sub	r5,-1
8000a5c6:	e0 a0 0c 9f 	rcall	8000bf04 <__avr32_f64_mul>
8000a5ca:	fa eb 00 18 	st.d	sp[24],r10
8000a5ce:	a1 54       	asr	r4,0x1
8000a5d0:	2f 86       	sub	r6,-8
8000a5d2:	58 04       	cp.w	r4,0
8000a5d4:	cf 11       	brne	8000a5b6 <_dtoa_r+0x382>
8000a5d6:	fa e8 00 18 	ld.d	r8,sp[24]
8000a5da:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5de:	06 96       	mov	r6,r3
8000a5e0:	e0 a0 0f d8 	rcall	8000c590 <__avr32_f64_div>
8000a5e4:	40 a3       	lddsp	r3,sp[0x28]
8000a5e6:	14 98       	mov	r8,r10
8000a5e8:	16 99       	mov	r9,r11
8000a5ea:	fa e9 00 08 	st.d	sp[8],r8
8000a5ee:	c2 f8       	rjmp	8000a64c <_dtoa_r+0x418>
8000a5f0:	ec 08 11 00 	rsub	r8,r6,0
8000a5f4:	c0 31       	brne	8000a5fa <_dtoa_r+0x3c6>
8000a5f6:	30 25       	mov	r5,2
8000a5f8:	c2 a8       	rjmp	8000a64c <_dtoa_r+0x418>
8000a5fa:	fe cc c3 6a 	sub	r12,pc,-15510
8000a5fe:	f0 04 14 04 	asr	r4,r8,0x4
8000a602:	50 1c       	stdsp	sp[0x4],r12
8000a604:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a608:	fe c9 c4 40 	sub	r9,pc,-15296
8000a60c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a610:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a614:	e0 a0 0c 78 	rcall	8000bf04 <__avr32_f64_mul>
8000a618:	40 1c       	lddsp	r12,sp[0x4]
8000a61a:	50 63       	stdsp	sp[0x18],r3
8000a61c:	30 25       	mov	r5,2
8000a61e:	0c 93       	mov	r3,r6
8000a620:	fa eb 00 08 	st.d	sp[8],r10
8000a624:	18 96       	mov	r6,r12
8000a626:	c0 f8       	rjmp	8000a644 <_dtoa_r+0x410>
8000a628:	fa ea 00 08 	ld.d	r10,sp[8]
8000a62c:	ed b4 00 00 	bld	r4,0x0
8000a630:	c0 81       	brne	8000a640 <_dtoa_r+0x40c>
8000a632:	ec e8 00 00 	ld.d	r8,r6[0]
8000a636:	2f f5       	sub	r5,-1
8000a638:	e0 a0 0c 66 	rcall	8000bf04 <__avr32_f64_mul>
8000a63c:	fa eb 00 08 	st.d	sp[8],r10
8000a640:	a1 54       	asr	r4,0x1
8000a642:	2f 86       	sub	r6,-8
8000a644:	58 04       	cp.w	r4,0
8000a646:	cf 11       	brne	8000a628 <_dtoa_r+0x3f4>
8000a648:	06 96       	mov	r6,r3
8000a64a:	40 63       	lddsp	r3,sp[0x18]
8000a64c:	41 4a       	lddsp	r10,sp[0x50]
8000a64e:	58 0a       	cp.w	r10,0
8000a650:	c2 a0       	breq	8000a6a4 <_dtoa_r+0x470>
8000a652:	fa e8 00 08 	ld.d	r8,sp[8]
8000a656:	58 01       	cp.w	r1,0
8000a658:	5f 94       	srgt	r4
8000a65a:	fa e9 00 18 	st.d	sp[24],r8
8000a65e:	30 08       	mov	r8,0
8000a660:	fc 19 3f f0 	movh	r9,0x3ff0
8000a664:	fa ea 00 18 	ld.d	r10,sp[24]
8000a668:	e0 a0 0f 60 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a66c:	f9 bc 00 00 	moveq	r12,0
8000a670:	f9 bc 01 01 	movne	r12,1
8000a674:	e9 ec 00 0c 	and	r12,r4,r12
8000a678:	c1 60       	breq	8000a6a4 <_dtoa_r+0x470>
8000a67a:	40 98       	lddsp	r8,sp[0x24]
8000a67c:	58 08       	cp.w	r8,0
8000a67e:	e0 8a 00 f1 	brle	8000a860 <_dtoa_r+0x62c>
8000a682:	30 08       	mov	r8,0
8000a684:	fc 19 40 24 	movh	r9,0x4024
8000a688:	ec c4 00 01 	sub	r4,r6,1
8000a68c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a690:	2f f5       	sub	r5,-1
8000a692:	50 64       	stdsp	sp[0x18],r4
8000a694:	e0 a0 0c 38 	rcall	8000bf04 <__avr32_f64_mul>
8000a698:	40 94       	lddsp	r4,sp[0x24]
8000a69a:	14 98       	mov	r8,r10
8000a69c:	16 99       	mov	r9,r11
8000a69e:	fa e9 00 08 	st.d	sp[8],r8
8000a6a2:	c0 38       	rjmp	8000a6a8 <_dtoa_r+0x474>
8000a6a4:	50 66       	stdsp	sp[0x18],r6
8000a6a6:	02 94       	mov	r4,r1
8000a6a8:	0a 9c       	mov	r12,r5
8000a6aa:	e0 a0 0e 88 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a6ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6b2:	e0 a0 0c 29 	rcall	8000bf04 <__avr32_f64_mul>
8000a6b6:	30 08       	mov	r8,0
8000a6b8:	fc 19 40 1c 	movh	r9,0x401c
8000a6bc:	e0 a0 0d de 	rcall	8000c278 <__avr32_f64_add>
8000a6c0:	14 98       	mov	r8,r10
8000a6c2:	16 99       	mov	r9,r11
8000a6c4:	fa e9 00 28 	st.d	sp[40],r8
8000a6c8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a6cc:	40 a5       	lddsp	r5,sp[0x28]
8000a6ce:	10 05       	add	r5,r8
8000a6d0:	50 a5       	stdsp	sp[0x28],r5
8000a6d2:	58 04       	cp.w	r4,0
8000a6d4:	c2 11       	brne	8000a716 <_dtoa_r+0x4e2>
8000a6d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6da:	30 08       	mov	r8,0
8000a6dc:	fc 19 40 14 	movh	r9,0x4014
8000a6e0:	e0 a0 0c fe 	rcall	8000c0dc <__avr32_f64_sub>
8000a6e4:	40 bc       	lddsp	r12,sp[0x2c]
8000a6e6:	fa eb 00 08 	st.d	sp[8],r10
8000a6ea:	14 98       	mov	r8,r10
8000a6ec:	16 99       	mov	r9,r11
8000a6ee:	18 9a       	mov	r10,r12
8000a6f0:	0a 9b       	mov	r11,r5
8000a6f2:	e0 a0 0f 1b 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a6f6:	e0 81 02 54 	brne	8000ab9e <_dtoa_r+0x96a>
8000a6fa:	0a 98       	mov	r8,r5
8000a6fc:	40 b9       	lddsp	r9,sp[0x2c]
8000a6fe:	ee 18 80 00 	eorh	r8,0x8000
8000a702:	fa ea 00 08 	ld.d	r10,sp[8]
8000a706:	10 95       	mov	r5,r8
8000a708:	12 98       	mov	r8,r9
8000a70a:	0a 99       	mov	r9,r5
8000a70c:	e0 a0 0f 0e 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a710:	e0 81 02 3e 	brne	8000ab8c <_dtoa_r+0x958>
8000a714:	ca 68       	rjmp	8000a860 <_dtoa_r+0x62c>
8000a716:	fe c9 c5 4e 	sub	r9,pc,-15026
8000a71a:	e8 c8 00 01 	sub	r8,r4,1
8000a71e:	40 d5       	lddsp	r5,sp[0x34]
8000a720:	58 05       	cp.w	r5,0
8000a722:	c4 f0       	breq	8000a7c0 <_dtoa_r+0x58c>
8000a724:	30 0c       	mov	r12,0
8000a726:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a72a:	51 3c       	stdsp	sp[0x4c],r12
8000a72c:	30 0a       	mov	r10,0
8000a72e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a732:	e0 a0 0f 2f 	rcall	8000c590 <__avr32_f64_div>
8000a736:	fa e8 00 28 	ld.d	r8,sp[40]
8000a73a:	40 85       	lddsp	r5,sp[0x20]
8000a73c:	e0 a0 0c d0 	rcall	8000c0dc <__avr32_f64_sub>
8000a740:	fa eb 00 28 	st.d	sp[40],r10
8000a744:	fa ea 00 08 	ld.d	r10,sp[8]
8000a748:	e0 a0 0e 22 	rcall	8000c38c <__avr32_f64_to_s32>
8000a74c:	51 6c       	stdsp	sp[0x58],r12
8000a74e:	e0 a0 0e 36 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a752:	14 98       	mov	r8,r10
8000a754:	16 99       	mov	r9,r11
8000a756:	fa ea 00 08 	ld.d	r10,sp[8]
8000a75a:	e0 a0 0c c1 	rcall	8000c0dc <__avr32_f64_sub>
8000a75e:	fa eb 00 08 	st.d	sp[8],r10
8000a762:	41 68       	lddsp	r8,sp[0x58]
8000a764:	2d 08       	sub	r8,-48
8000a766:	0a c8       	st.b	r5++,r8
8000a768:	41 39       	lddsp	r9,sp[0x4c]
8000a76a:	2f f9       	sub	r9,-1
8000a76c:	51 39       	stdsp	sp[0x4c],r9
8000a76e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a772:	e0 a0 0e db 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a776:	e0 81 03 39 	brne	8000ade8 <_dtoa_r+0xbb4>
8000a77a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a77e:	30 0a       	mov	r10,0
8000a780:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a784:	e0 a0 0c ac 	rcall	8000c0dc <__avr32_f64_sub>
8000a788:	fa e8 00 28 	ld.d	r8,sp[40]
8000a78c:	e0 a0 0e ce 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a790:	fa ea 00 28 	ld.d	r10,sp[40]
8000a794:	30 08       	mov	r8,0
8000a796:	fc 19 40 24 	movh	r9,0x4024
8000a79a:	e0 81 00 da 	brne	8000a94e <_dtoa_r+0x71a>
8000a79e:	41 3c       	lddsp	r12,sp[0x4c]
8000a7a0:	08 3c       	cp.w	r12,r4
8000a7a2:	c5 f4       	brge	8000a860 <_dtoa_r+0x62c>
8000a7a4:	e0 a0 0b b0 	rcall	8000bf04 <__avr32_f64_mul>
8000a7a8:	30 08       	mov	r8,0
8000a7aa:	fa eb 00 28 	st.d	sp[40],r10
8000a7ae:	fc 19 40 24 	movh	r9,0x4024
8000a7b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7b6:	e0 a0 0b a7 	rcall	8000bf04 <__avr32_f64_mul>
8000a7ba:	fa eb 00 08 	st.d	sp[8],r10
8000a7be:	cc 3b       	rjmp	8000a744 <_dtoa_r+0x510>
8000a7c0:	40 85       	lddsp	r5,sp[0x20]
8000a7c2:	08 05       	add	r5,r4
8000a7c4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a7c8:	51 35       	stdsp	sp[0x4c],r5
8000a7ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7ce:	40 85       	lddsp	r5,sp[0x20]
8000a7d0:	e0 a0 0b 9a 	rcall	8000bf04 <__avr32_f64_mul>
8000a7d4:	fa eb 00 28 	st.d	sp[40],r10
8000a7d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7dc:	e0 a0 0d d8 	rcall	8000c38c <__avr32_f64_to_s32>
8000a7e0:	51 6c       	stdsp	sp[0x58],r12
8000a7e2:	e0 a0 0d ec 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a7e6:	14 98       	mov	r8,r10
8000a7e8:	16 99       	mov	r9,r11
8000a7ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ee:	e0 a0 0c 77 	rcall	8000c0dc <__avr32_f64_sub>
8000a7f2:	fa eb 00 08 	st.d	sp[8],r10
8000a7f6:	41 68       	lddsp	r8,sp[0x58]
8000a7f8:	2d 08       	sub	r8,-48
8000a7fa:	0a c8       	st.b	r5++,r8
8000a7fc:	41 3c       	lddsp	r12,sp[0x4c]
8000a7fe:	18 35       	cp.w	r5,r12
8000a800:	c2 81       	brne	8000a850 <_dtoa_r+0x61c>
8000a802:	30 08       	mov	r8,0
8000a804:	fc 19 3f e0 	movh	r9,0x3fe0
8000a808:	fa ea 00 28 	ld.d	r10,sp[40]
8000a80c:	e0 a0 0d 36 	rcall	8000c278 <__avr32_f64_add>
8000a810:	40 85       	lddsp	r5,sp[0x20]
8000a812:	fa e8 00 08 	ld.d	r8,sp[8]
8000a816:	08 05       	add	r5,r4
8000a818:	e0 a0 0e 88 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a81c:	e0 81 00 99 	brne	8000a94e <_dtoa_r+0x71a>
8000a820:	fa e8 00 28 	ld.d	r8,sp[40]
8000a824:	30 0a       	mov	r10,0
8000a826:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a82a:	e0 a0 0c 59 	rcall	8000c0dc <__avr32_f64_sub>
8000a82e:	14 98       	mov	r8,r10
8000a830:	16 99       	mov	r9,r11
8000a832:	fa ea 00 08 	ld.d	r10,sp[8]
8000a836:	e0 a0 0e 79 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a83a:	c1 30       	breq	8000a860 <_dtoa_r+0x62c>
8000a83c:	33 09       	mov	r9,48
8000a83e:	0a 98       	mov	r8,r5
8000a840:	11 7a       	ld.ub	r10,--r8
8000a842:	f2 0a 18 00 	cp.b	r10,r9
8000a846:	e0 81 02 d1 	brne	8000ade8 <_dtoa_r+0xbb4>
8000a84a:	10 95       	mov	r5,r8
8000a84c:	cf 9b       	rjmp	8000a83e <_dtoa_r+0x60a>
8000a84e:	d7 03       	nop
8000a850:	30 08       	mov	r8,0
8000a852:	fc 19 40 24 	movh	r9,0x4024
8000a856:	e0 a0 0b 57 	rcall	8000bf04 <__avr32_f64_mul>
8000a85a:	fa eb 00 08 	st.d	sp[8],r10
8000a85e:	cb db       	rjmp	8000a7d8 <_dtoa_r+0x5a4>
8000a860:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a864:	fa eb 00 08 	st.d	sp[8],r10
8000a868:	58 e6       	cp.w	r6,14
8000a86a:	5f ab       	srle	r11
8000a86c:	41 8a       	lddsp	r10,sp[0x60]
8000a86e:	30 08       	mov	r8,0
8000a870:	f4 09 11 ff 	rsub	r9,r10,-1
8000a874:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a878:	f0 09 18 00 	cp.b	r9,r8
8000a87c:	e0 80 00 82 	breq	8000a980 <_dtoa_r+0x74c>
8000a880:	40 ea       	lddsp	r10,sp[0x38]
8000a882:	58 01       	cp.w	r1,0
8000a884:	5f a9       	srle	r9
8000a886:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a88a:	fe ca c6 c2 	sub	r10,pc,-14654
8000a88e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a892:	fa e5 00 10 	st.d	sp[16],r4
8000a896:	f0 09 18 00 	cp.b	r9,r8
8000a89a:	c1 40       	breq	8000a8c2 <_dtoa_r+0x68e>
8000a89c:	58 01       	cp.w	r1,0
8000a89e:	e0 81 01 77 	brne	8000ab8c <_dtoa_r+0x958>
8000a8a2:	30 08       	mov	r8,0
8000a8a4:	fc 19 40 14 	movh	r9,0x4014
8000a8a8:	08 9a       	mov	r10,r4
8000a8aa:	0a 9b       	mov	r11,r5
8000a8ac:	e0 a0 0b 2c 	rcall	8000bf04 <__avr32_f64_mul>
8000a8b0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8b4:	e0 a0 0e 06 	rcall	8000c4c0 <__avr32_f64_cmp_ge>
8000a8b8:	e0 81 01 6a 	brne	8000ab8c <_dtoa_r+0x958>
8000a8bc:	02 92       	mov	r2,r1
8000a8be:	e0 8f 01 72 	bral	8000aba2 <_dtoa_r+0x96e>
8000a8c2:	40 85       	lddsp	r5,sp[0x20]
8000a8c4:	30 14       	mov	r4,1
8000a8c6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8ce:	e0 a0 0e 61 	rcall	8000c590 <__avr32_f64_div>
8000a8d2:	e0 a0 0d 5d 	rcall	8000c38c <__avr32_f64_to_s32>
8000a8d6:	18 92       	mov	r2,r12
8000a8d8:	e0 a0 0d 71 	rcall	8000c3ba <__avr32_s32_to_f64>
8000a8dc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8e0:	e0 a0 0b 12 	rcall	8000bf04 <__avr32_f64_mul>
8000a8e4:	14 98       	mov	r8,r10
8000a8e6:	16 99       	mov	r9,r11
8000a8e8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8ec:	e0 a0 0b f8 	rcall	8000c0dc <__avr32_f64_sub>
8000a8f0:	fa eb 00 08 	st.d	sp[8],r10
8000a8f4:	e4 c8 ff d0 	sub	r8,r2,-48
8000a8f8:	0a c8       	st.b	r5++,r8
8000a8fa:	fc 19 40 24 	movh	r9,0x4024
8000a8fe:	30 08       	mov	r8,0
8000a900:	02 34       	cp.w	r4,r1
8000a902:	c3 31       	brne	8000a968 <_dtoa_r+0x734>
8000a904:	fa e8 00 08 	ld.d	r8,sp[8]
8000a908:	e0 a0 0c b8 	rcall	8000c278 <__avr32_f64_add>
8000a90c:	16 91       	mov	r1,r11
8000a90e:	14 90       	mov	r0,r10
8000a910:	14 98       	mov	r8,r10
8000a912:	02 99       	mov	r9,r1
8000a914:	fa ea 00 10 	ld.d	r10,sp[16]
8000a918:	e0 a0 0e 08 	rcall	8000c528 <__avr32_f64_cmp_lt>
8000a91c:	c1 a1       	brne	8000a950 <_dtoa_r+0x71c>
8000a91e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a922:	00 9a       	mov	r10,r0
8000a924:	02 9b       	mov	r11,r1
8000a926:	e0 a0 0d ba 	rcall	8000c49a <__avr32_f64_cmp_eq>
8000a92a:	e0 80 02 5e 	breq	8000ade6 <_dtoa_r+0xbb2>
8000a92e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a932:	c0 f1       	brne	8000a950 <_dtoa_r+0x71c>
8000a934:	e0 8f 02 59 	bral	8000ade6 <_dtoa_r+0xbb2>
8000a938:	40 8a       	lddsp	r10,sp[0x20]
8000a93a:	14 38       	cp.w	r8,r10
8000a93c:	c0 30       	breq	8000a942 <_dtoa_r+0x70e>
8000a93e:	10 95       	mov	r5,r8
8000a940:	c0 98       	rjmp	8000a952 <_dtoa_r+0x71e>
8000a942:	33 08       	mov	r8,48
8000a944:	40 89       	lddsp	r9,sp[0x20]
8000a946:	2f f6       	sub	r6,-1
8000a948:	b2 88       	st.b	r9[0x0],r8
8000a94a:	40 88       	lddsp	r8,sp[0x20]
8000a94c:	c0 88       	rjmp	8000a95c <_dtoa_r+0x728>
8000a94e:	40 66       	lddsp	r6,sp[0x18]
8000a950:	33 99       	mov	r9,57
8000a952:	0a 98       	mov	r8,r5
8000a954:	11 7a       	ld.ub	r10,--r8
8000a956:	f2 0a 18 00 	cp.b	r10,r9
8000a95a:	ce f0       	breq	8000a938 <_dtoa_r+0x704>
8000a95c:	50 66       	stdsp	sp[0x18],r6
8000a95e:	11 89       	ld.ub	r9,r8[0x0]
8000a960:	2f f9       	sub	r9,-1
8000a962:	b0 89       	st.b	r8[0x0],r9
8000a964:	e0 8f 02 42 	bral	8000ade8 <_dtoa_r+0xbb4>
8000a968:	e0 a0 0a ce 	rcall	8000bf04 <__avr32_f64_mul>
8000a96c:	2f f4       	sub	r4,-1
8000a96e:	fa eb 00 08 	st.d	sp[8],r10
8000a972:	30 08       	mov	r8,0
8000a974:	30 09       	mov	r9,0
8000a976:	e0 a0 0d 92 	rcall	8000c49a <__avr32_f64_cmp_eq>
8000a97a:	ca 60       	breq	8000a8c6 <_dtoa_r+0x692>
8000a97c:	e0 8f 02 35 	bral	8000ade6 <_dtoa_r+0xbb2>
8000a980:	40 d8       	lddsp	r8,sp[0x34]
8000a982:	58 08       	cp.w	r8,0
8000a984:	c0 51       	brne	8000a98e <_dtoa_r+0x75a>
8000a986:	04 98       	mov	r8,r2
8000a988:	00 95       	mov	r5,r0
8000a98a:	40 d4       	lddsp	r4,sp[0x34]
8000a98c:	c3 78       	rjmp	8000a9fa <_dtoa_r+0x7c6>
8000a98e:	40 c5       	lddsp	r5,sp[0x30]
8000a990:	58 15       	cp.w	r5,1
8000a992:	e0 89 00 0f 	brgt	8000a9b0 <_dtoa_r+0x77c>
8000a996:	41 74       	lddsp	r4,sp[0x5c]
8000a998:	58 04       	cp.w	r4,0
8000a99a:	c0 40       	breq	8000a9a2 <_dtoa_r+0x76e>
8000a99c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a9a0:	c0 48       	rjmp	8000a9a8 <_dtoa_r+0x774>
8000a9a2:	41 99       	lddsp	r9,sp[0x64]
8000a9a4:	f2 09 11 36 	rsub	r9,r9,54
8000a9a8:	04 98       	mov	r8,r2
8000a9aa:	00 95       	mov	r5,r0
8000a9ac:	c1 c8       	rjmp	8000a9e4 <_dtoa_r+0x7b0>
8000a9ae:	d7 03       	nop
8000a9b0:	e2 c8 00 01 	sub	r8,r1,1
8000a9b4:	58 01       	cp.w	r1,0
8000a9b6:	e0 05 17 40 	movge	r5,r0
8000a9ba:	e2 09 17 40 	movge	r9,r1
8000a9be:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a9c2:	f9 b9 05 00 	movlt	r9,0
8000a9c6:	10 32       	cp.w	r2,r8
8000a9c8:	e5 d8 e4 18 	subge	r8,r2,r8
8000a9cc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a9d0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a9d4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a9d8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a9dc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a9e0:	f9 b8 05 00 	movlt	r8,0
8000a9e4:	40 4b       	lddsp	r11,sp[0x10]
8000a9e6:	12 0b       	add	r11,r9
8000a9e8:	50 08       	stdsp	sp[0x0],r8
8000a9ea:	50 4b       	stdsp	sp[0x10],r11
8000a9ec:	12 00       	add	r0,r9
8000a9ee:	30 1b       	mov	r11,1
8000a9f0:	0e 9c       	mov	r12,r7
8000a9f2:	e0 a0 08 a7 	rcall	8000bb40 <__i2b>
8000a9f6:	40 08       	lddsp	r8,sp[0x0]
8000a9f8:	18 94       	mov	r4,r12
8000a9fa:	40 4a       	lddsp	r10,sp[0x10]
8000a9fc:	58 05       	cp.w	r5,0
8000a9fe:	5f 99       	srgt	r9
8000aa00:	58 0a       	cp.w	r10,0
8000aa02:	5f 9a       	srgt	r10
8000aa04:	f5 e9 00 09 	and	r9,r10,r9
8000aa08:	c0 80       	breq	8000aa18 <_dtoa_r+0x7e4>
8000aa0a:	40 4c       	lddsp	r12,sp[0x10]
8000aa0c:	f8 05 0d 49 	min	r9,r12,r5
8000aa10:	12 1c       	sub	r12,r9
8000aa12:	12 10       	sub	r0,r9
8000aa14:	50 4c       	stdsp	sp[0x10],r12
8000aa16:	12 15       	sub	r5,r9
8000aa18:	58 02       	cp.w	r2,0
8000aa1a:	e0 8a 00 27 	brle	8000aa68 <_dtoa_r+0x834>
8000aa1e:	40 db       	lddsp	r11,sp[0x34]
8000aa20:	58 0b       	cp.w	r11,0
8000aa22:	c1 d0       	breq	8000aa5c <_dtoa_r+0x828>
8000aa24:	58 08       	cp.w	r8,0
8000aa26:	e0 8a 00 17 	brle	8000aa54 <_dtoa_r+0x820>
8000aa2a:	10 9a       	mov	r10,r8
8000aa2c:	50 08       	stdsp	sp[0x0],r8
8000aa2e:	08 9b       	mov	r11,r4
8000aa30:	0e 9c       	mov	r12,r7
8000aa32:	e0 a0 08 cd 	rcall	8000bbcc <__pow5mult>
8000aa36:	06 9a       	mov	r10,r3
8000aa38:	18 9b       	mov	r11,r12
8000aa3a:	18 94       	mov	r4,r12
8000aa3c:	0e 9c       	mov	r12,r7
8000aa3e:	e0 a0 08 01 	rcall	8000ba40 <__multiply>
8000aa42:	18 99       	mov	r9,r12
8000aa44:	06 9b       	mov	r11,r3
8000aa46:	50 19       	stdsp	sp[0x4],r9
8000aa48:	0e 9c       	mov	r12,r7
8000aa4a:	e0 a0 06 ad 	rcall	8000b7a4 <_Bfree>
8000aa4e:	40 19       	lddsp	r9,sp[0x4]
8000aa50:	40 08       	lddsp	r8,sp[0x0]
8000aa52:	12 93       	mov	r3,r9
8000aa54:	e4 08 01 0a 	sub	r10,r2,r8
8000aa58:	c0 80       	breq	8000aa68 <_dtoa_r+0x834>
8000aa5a:	c0 28       	rjmp	8000aa5e <_dtoa_r+0x82a>
8000aa5c:	04 9a       	mov	r10,r2
8000aa5e:	06 9b       	mov	r11,r3
8000aa60:	0e 9c       	mov	r12,r7
8000aa62:	e0 a0 08 b5 	rcall	8000bbcc <__pow5mult>
8000aa66:	18 93       	mov	r3,r12
8000aa68:	30 1b       	mov	r11,1
8000aa6a:	0e 9c       	mov	r12,r7
8000aa6c:	e0 a0 08 6a 	rcall	8000bb40 <__i2b>
8000aa70:	41 1a       	lddsp	r10,sp[0x44]
8000aa72:	18 92       	mov	r2,r12
8000aa74:	58 0a       	cp.w	r10,0
8000aa76:	e0 8a 00 07 	brle	8000aa84 <_dtoa_r+0x850>
8000aa7a:	18 9b       	mov	r11,r12
8000aa7c:	0e 9c       	mov	r12,r7
8000aa7e:	e0 a0 08 a7 	rcall	8000bbcc <__pow5mult>
8000aa82:	18 92       	mov	r2,r12
8000aa84:	40 c9       	lddsp	r9,sp[0x30]
8000aa86:	58 19       	cp.w	r9,1
8000aa88:	e0 89 00 14 	brgt	8000aab0 <_dtoa_r+0x87c>
8000aa8c:	40 38       	lddsp	r8,sp[0xc]
8000aa8e:	58 08       	cp.w	r8,0
8000aa90:	c1 01       	brne	8000aab0 <_dtoa_r+0x87c>
8000aa92:	40 29       	lddsp	r9,sp[0x8]
8000aa94:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa98:	c0 c1       	brne	8000aab0 <_dtoa_r+0x87c>
8000aa9a:	12 98       	mov	r8,r9
8000aa9c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aaa0:	c0 80       	breq	8000aab0 <_dtoa_r+0x87c>
8000aaa2:	40 4c       	lddsp	r12,sp[0x10]
8000aaa4:	30 1b       	mov	r11,1
8000aaa6:	2f fc       	sub	r12,-1
8000aaa8:	2f f0       	sub	r0,-1
8000aaaa:	50 4c       	stdsp	sp[0x10],r12
8000aaac:	50 6b       	stdsp	sp[0x18],r11
8000aaae:	c0 38       	rjmp	8000aab4 <_dtoa_r+0x880>
8000aab0:	30 0a       	mov	r10,0
8000aab2:	50 6a       	stdsp	sp[0x18],r10
8000aab4:	41 19       	lddsp	r9,sp[0x44]
8000aab6:	58 09       	cp.w	r9,0
8000aab8:	c0 31       	brne	8000aabe <_dtoa_r+0x88a>
8000aaba:	30 1c       	mov	r12,1
8000aabc:	c0 98       	rjmp	8000aace <_dtoa_r+0x89a>
8000aabe:	64 48       	ld.w	r8,r2[0x10]
8000aac0:	2f c8       	sub	r8,-4
8000aac2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aac6:	e0 a0 05 df 	rcall	8000b684 <__hi0bits>
8000aaca:	f8 0c 11 20 	rsub	r12,r12,32
8000aace:	40 4b       	lddsp	r11,sp[0x10]
8000aad0:	f8 0b 00 08 	add	r8,r12,r11
8000aad4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aad8:	c0 c0       	breq	8000aaf0 <_dtoa_r+0x8bc>
8000aada:	f0 08 11 20 	rsub	r8,r8,32
8000aade:	58 48       	cp.w	r8,4
8000aae0:	e0 8a 00 06 	brle	8000aaec <_dtoa_r+0x8b8>
8000aae4:	20 48       	sub	r8,4
8000aae6:	10 0b       	add	r11,r8
8000aae8:	50 4b       	stdsp	sp[0x10],r11
8000aaea:	c0 78       	rjmp	8000aaf8 <_dtoa_r+0x8c4>
8000aaec:	58 48       	cp.w	r8,4
8000aaee:	c0 70       	breq	8000aafc <_dtoa_r+0x8c8>
8000aaf0:	40 4a       	lddsp	r10,sp[0x10]
8000aaf2:	2e 48       	sub	r8,-28
8000aaf4:	10 0a       	add	r10,r8
8000aaf6:	50 4a       	stdsp	sp[0x10],r10
8000aaf8:	10 00       	add	r0,r8
8000aafa:	10 05       	add	r5,r8
8000aafc:	58 00       	cp.w	r0,0
8000aafe:	e0 8a 00 08 	brle	8000ab0e <_dtoa_r+0x8da>
8000ab02:	06 9b       	mov	r11,r3
8000ab04:	00 9a       	mov	r10,r0
8000ab06:	0e 9c       	mov	r12,r7
8000ab08:	e0 a0 07 58 	rcall	8000b9b8 <__lshift>
8000ab0c:	18 93       	mov	r3,r12
8000ab0e:	40 49       	lddsp	r9,sp[0x10]
8000ab10:	58 09       	cp.w	r9,0
8000ab12:	e0 8a 00 08 	brle	8000ab22 <_dtoa_r+0x8ee>
8000ab16:	04 9b       	mov	r11,r2
8000ab18:	12 9a       	mov	r10,r9
8000ab1a:	0e 9c       	mov	r12,r7
8000ab1c:	e0 a0 07 4e 	rcall	8000b9b8 <__lshift>
8000ab20:	18 92       	mov	r2,r12
8000ab22:	41 48       	lddsp	r8,sp[0x50]
8000ab24:	58 08       	cp.w	r8,0
8000ab26:	c1 b0       	breq	8000ab5c <_dtoa_r+0x928>
8000ab28:	04 9b       	mov	r11,r2
8000ab2a:	06 9c       	mov	r12,r3
8000ab2c:	e0 a0 06 23 	rcall	8000b772 <__mcmp>
8000ab30:	c1 64       	brge	8000ab5c <_dtoa_r+0x928>
8000ab32:	06 9b       	mov	r11,r3
8000ab34:	30 09       	mov	r9,0
8000ab36:	30 aa       	mov	r10,10
8000ab38:	0e 9c       	mov	r12,r7
8000ab3a:	e0 a0 08 0b 	rcall	8000bb50 <__multadd>
8000ab3e:	20 16       	sub	r6,1
8000ab40:	18 93       	mov	r3,r12
8000ab42:	40 dc       	lddsp	r12,sp[0x34]
8000ab44:	58 0c       	cp.w	r12,0
8000ab46:	c0 31       	brne	8000ab4c <_dtoa_r+0x918>
8000ab48:	40 91       	lddsp	r1,sp[0x24]
8000ab4a:	c0 98       	rjmp	8000ab5c <_dtoa_r+0x928>
8000ab4c:	08 9b       	mov	r11,r4
8000ab4e:	40 91       	lddsp	r1,sp[0x24]
8000ab50:	30 09       	mov	r9,0
8000ab52:	30 aa       	mov	r10,10
8000ab54:	0e 9c       	mov	r12,r7
8000ab56:	e0 a0 07 fd 	rcall	8000bb50 <__multadd>
8000ab5a:	18 94       	mov	r4,r12
8000ab5c:	58 01       	cp.w	r1,0
8000ab5e:	5f a9       	srle	r9
8000ab60:	40 cb       	lddsp	r11,sp[0x30]
8000ab62:	58 2b       	cp.w	r11,2
8000ab64:	5f 98       	srgt	r8
8000ab66:	f3 e8 00 08 	and	r8,r9,r8
8000ab6a:	c2 50       	breq	8000abb4 <_dtoa_r+0x980>
8000ab6c:	58 01       	cp.w	r1,0
8000ab6e:	c1 11       	brne	8000ab90 <_dtoa_r+0x95c>
8000ab70:	04 9b       	mov	r11,r2
8000ab72:	02 99       	mov	r9,r1
8000ab74:	30 5a       	mov	r10,5
8000ab76:	0e 9c       	mov	r12,r7
8000ab78:	e0 a0 07 ec 	rcall	8000bb50 <__multadd>
8000ab7c:	18 92       	mov	r2,r12
8000ab7e:	18 9b       	mov	r11,r12
8000ab80:	06 9c       	mov	r12,r3
8000ab82:	e0 a0 05 f8 	rcall	8000b772 <__mcmp>
8000ab86:	e0 89 00 0f 	brgt	8000aba4 <_dtoa_r+0x970>
8000ab8a:	c0 38       	rjmp	8000ab90 <_dtoa_r+0x95c>
8000ab8c:	30 02       	mov	r2,0
8000ab8e:	04 94       	mov	r4,r2
8000ab90:	40 ea       	lddsp	r10,sp[0x38]
8000ab92:	30 09       	mov	r9,0
8000ab94:	5c da       	com	r10
8000ab96:	40 85       	lddsp	r5,sp[0x20]
8000ab98:	50 6a       	stdsp	sp[0x18],r10
8000ab9a:	50 49       	stdsp	sp[0x10],r9
8000ab9c:	c0 f9       	rjmp	8000adba <_dtoa_r+0xb86>
8000ab9e:	08 92       	mov	r2,r4
8000aba0:	40 66       	lddsp	r6,sp[0x18]
8000aba2:	04 94       	mov	r4,r2
8000aba4:	2f f6       	sub	r6,-1
8000aba6:	50 66       	stdsp	sp[0x18],r6
8000aba8:	33 18       	mov	r8,49
8000abaa:	40 85       	lddsp	r5,sp[0x20]
8000abac:	0a c8       	st.b	r5++,r8
8000abae:	30 08       	mov	r8,0
8000abb0:	50 48       	stdsp	sp[0x10],r8
8000abb2:	c0 49       	rjmp	8000adba <_dtoa_r+0xb86>
8000abb4:	40 dc       	lddsp	r12,sp[0x34]
8000abb6:	58 0c       	cp.w	r12,0
8000abb8:	e0 80 00 b5 	breq	8000ad22 <_dtoa_r+0xaee>
8000abbc:	58 05       	cp.w	r5,0
8000abbe:	e0 8a 00 08 	brle	8000abce <_dtoa_r+0x99a>
8000abc2:	08 9b       	mov	r11,r4
8000abc4:	0a 9a       	mov	r10,r5
8000abc6:	0e 9c       	mov	r12,r7
8000abc8:	e0 a0 06 f8 	rcall	8000b9b8 <__lshift>
8000abcc:	18 94       	mov	r4,r12
8000abce:	40 6b       	lddsp	r11,sp[0x18]
8000abd0:	58 0b       	cp.w	r11,0
8000abd2:	c0 31       	brne	8000abd8 <_dtoa_r+0x9a4>
8000abd4:	08 9c       	mov	r12,r4
8000abd6:	c1 38       	rjmp	8000abfc <_dtoa_r+0x9c8>
8000abd8:	68 1b       	ld.w	r11,r4[0x4]
8000abda:	0e 9c       	mov	r12,r7
8000abdc:	e0 a0 05 fe 	rcall	8000b7d8 <_Balloc>
8000abe0:	68 4a       	ld.w	r10,r4[0x10]
8000abe2:	18 95       	mov	r5,r12
8000abe4:	e8 cb ff f4 	sub	r11,r4,-12
8000abe8:	2f ea       	sub	r10,-2
8000abea:	2f 4c       	sub	r12,-12
8000abec:	a3 6a       	lsl	r10,0x2
8000abee:	fe b0 e6 4f 	rcall	8000788c <memcpy>
8000abf2:	0a 9b       	mov	r11,r5
8000abf4:	30 1a       	mov	r10,1
8000abf6:	0e 9c       	mov	r12,r7
8000abf8:	e0 a0 06 e0 	rcall	8000b9b8 <__lshift>
8000abfc:	50 44       	stdsp	sp[0x10],r4
8000abfe:	40 3a       	lddsp	r10,sp[0xc]
8000ac00:	30 19       	mov	r9,1
8000ac02:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ac06:	18 94       	mov	r4,r12
8000ac08:	50 da       	stdsp	sp[0x34],r10
8000ac0a:	40 85       	lddsp	r5,sp[0x20]
8000ac0c:	50 99       	stdsp	sp[0x24],r9
8000ac0e:	50 26       	stdsp	sp[0x8],r6
8000ac10:	50 e1       	stdsp	sp[0x38],r1
8000ac12:	04 9b       	mov	r11,r2
8000ac14:	06 9c       	mov	r12,r3
8000ac16:	fe b0 fa 7f 	rcall	8000a114 <quorem>
8000ac1a:	40 4b       	lddsp	r11,sp[0x10]
8000ac1c:	f8 c0 ff d0 	sub	r0,r12,-48
8000ac20:	06 9c       	mov	r12,r3
8000ac22:	e0 a0 05 a8 	rcall	8000b772 <__mcmp>
8000ac26:	08 9a       	mov	r10,r4
8000ac28:	50 6c       	stdsp	sp[0x18],r12
8000ac2a:	04 9b       	mov	r11,r2
8000ac2c:	0e 9c       	mov	r12,r7
8000ac2e:	e0 a0 06 5d 	rcall	8000b8e8 <__mdiff>
8000ac32:	18 91       	mov	r1,r12
8000ac34:	78 38       	ld.w	r8,r12[0xc]
8000ac36:	58 08       	cp.w	r8,0
8000ac38:	c0 30       	breq	8000ac3e <_dtoa_r+0xa0a>
8000ac3a:	30 16       	mov	r6,1
8000ac3c:	c0 68       	rjmp	8000ac48 <_dtoa_r+0xa14>
8000ac3e:	18 9b       	mov	r11,r12
8000ac40:	06 9c       	mov	r12,r3
8000ac42:	e0 a0 05 98 	rcall	8000b772 <__mcmp>
8000ac46:	18 96       	mov	r6,r12
8000ac48:	0e 9c       	mov	r12,r7
8000ac4a:	02 9b       	mov	r11,r1
8000ac4c:	e0 a0 05 ac 	rcall	8000b7a4 <_Bfree>
8000ac50:	40 cc       	lddsp	r12,sp[0x30]
8000ac52:	ed ec 10 08 	or	r8,r6,r12
8000ac56:	c0 d1       	brne	8000ac70 <_dtoa_r+0xa3c>
8000ac58:	40 db       	lddsp	r11,sp[0x34]
8000ac5a:	58 0b       	cp.w	r11,0
8000ac5c:	c0 a1       	brne	8000ac70 <_dtoa_r+0xa3c>
8000ac5e:	40 26       	lddsp	r6,sp[0x8]
8000ac60:	e0 40 00 39 	cp.w	r0,57
8000ac64:	c3 00       	breq	8000acc4 <_dtoa_r+0xa90>
8000ac66:	40 6a       	lddsp	r10,sp[0x18]
8000ac68:	58 0a       	cp.w	r10,0
8000ac6a:	e0 89 00 24 	brgt	8000acb2 <_dtoa_r+0xa7e>
8000ac6e:	c2 f8       	rjmp	8000accc <_dtoa_r+0xa98>
8000ac70:	40 69       	lddsp	r9,sp[0x18]
8000ac72:	58 09       	cp.w	r9,0
8000ac74:	c0 85       	brlt	8000ac84 <_dtoa_r+0xa50>
8000ac76:	12 98       	mov	r8,r9
8000ac78:	40 cc       	lddsp	r12,sp[0x30]
8000ac7a:	18 48       	or	r8,r12
8000ac7c:	c1 d1       	brne	8000acb6 <_dtoa_r+0xa82>
8000ac7e:	40 db       	lddsp	r11,sp[0x34]
8000ac80:	58 0b       	cp.w	r11,0
8000ac82:	c1 a1       	brne	8000acb6 <_dtoa_r+0xa82>
8000ac84:	0c 99       	mov	r9,r6
8000ac86:	40 26       	lddsp	r6,sp[0x8]
8000ac88:	58 09       	cp.w	r9,0
8000ac8a:	e0 8a 00 21 	brle	8000accc <_dtoa_r+0xa98>
8000ac8e:	06 9b       	mov	r11,r3
8000ac90:	30 1a       	mov	r10,1
8000ac92:	0e 9c       	mov	r12,r7
8000ac94:	e0 a0 06 92 	rcall	8000b9b8 <__lshift>
8000ac98:	04 9b       	mov	r11,r2
8000ac9a:	18 93       	mov	r3,r12
8000ac9c:	e0 a0 05 6b 	rcall	8000b772 <__mcmp>
8000aca0:	e0 89 00 06 	brgt	8000acac <_dtoa_r+0xa78>
8000aca4:	c1 41       	brne	8000accc <_dtoa_r+0xa98>
8000aca6:	ed b0 00 00 	bld	r0,0x0
8000acaa:	c1 11       	brne	8000accc <_dtoa_r+0xa98>
8000acac:	e0 40 00 39 	cp.w	r0,57
8000acb0:	c0 a0       	breq	8000acc4 <_dtoa_r+0xa90>
8000acb2:	2f f0       	sub	r0,-1
8000acb4:	c0 c8       	rjmp	8000accc <_dtoa_r+0xa98>
8000acb6:	58 06       	cp.w	r6,0
8000acb8:	e0 8a 00 0c 	brle	8000acd0 <_dtoa_r+0xa9c>
8000acbc:	40 26       	lddsp	r6,sp[0x8]
8000acbe:	e0 40 00 39 	cp.w	r0,57
8000acc2:	c0 41       	brne	8000acca <_dtoa_r+0xa96>
8000acc4:	33 98       	mov	r8,57
8000acc6:	0a c8       	st.b	r5++,r8
8000acc8:	c6 78       	rjmp	8000ad96 <_dtoa_r+0xb62>
8000acca:	2f f0       	sub	r0,-1
8000accc:	0a c0       	st.b	r5++,r0
8000acce:	c7 58       	rjmp	8000adb8 <_dtoa_r+0xb84>
8000acd0:	0a c0       	st.b	r5++,r0
8000acd2:	40 9a       	lddsp	r10,sp[0x24]
8000acd4:	40 e9       	lddsp	r9,sp[0x38]
8000acd6:	12 3a       	cp.w	r10,r9
8000acd8:	c4 30       	breq	8000ad5e <_dtoa_r+0xb2a>
8000acda:	06 9b       	mov	r11,r3
8000acdc:	30 09       	mov	r9,0
8000acde:	30 aa       	mov	r10,10
8000ace0:	0e 9c       	mov	r12,r7
8000ace2:	e0 a0 07 37 	rcall	8000bb50 <__multadd>
8000ace6:	40 48       	lddsp	r8,sp[0x10]
8000ace8:	18 93       	mov	r3,r12
8000acea:	08 38       	cp.w	r8,r4
8000acec:	c0 91       	brne	8000acfe <_dtoa_r+0xaca>
8000acee:	10 9b       	mov	r11,r8
8000acf0:	30 09       	mov	r9,0
8000acf2:	30 aa       	mov	r10,10
8000acf4:	0e 9c       	mov	r12,r7
8000acf6:	e0 a0 07 2d 	rcall	8000bb50 <__multadd>
8000acfa:	50 4c       	stdsp	sp[0x10],r12
8000acfc:	c0 e8       	rjmp	8000ad18 <_dtoa_r+0xae4>
8000acfe:	40 4b       	lddsp	r11,sp[0x10]
8000ad00:	30 09       	mov	r9,0
8000ad02:	30 aa       	mov	r10,10
8000ad04:	0e 9c       	mov	r12,r7
8000ad06:	e0 a0 07 25 	rcall	8000bb50 <__multadd>
8000ad0a:	08 9b       	mov	r11,r4
8000ad0c:	50 4c       	stdsp	sp[0x10],r12
8000ad0e:	30 09       	mov	r9,0
8000ad10:	30 aa       	mov	r10,10
8000ad12:	0e 9c       	mov	r12,r7
8000ad14:	e0 a0 07 1e 	rcall	8000bb50 <__multadd>
8000ad18:	18 94       	mov	r4,r12
8000ad1a:	40 9c       	lddsp	r12,sp[0x24]
8000ad1c:	2f fc       	sub	r12,-1
8000ad1e:	50 9c       	stdsp	sp[0x24],r12
8000ad20:	c7 9b       	rjmp	8000ac12 <_dtoa_r+0x9de>
8000ad22:	30 18       	mov	r8,1
8000ad24:	06 90       	mov	r0,r3
8000ad26:	40 85       	lddsp	r5,sp[0x20]
8000ad28:	08 93       	mov	r3,r4
8000ad2a:	0c 94       	mov	r4,r6
8000ad2c:	10 96       	mov	r6,r8
8000ad2e:	04 9b       	mov	r11,r2
8000ad30:	00 9c       	mov	r12,r0
8000ad32:	fe b0 f9 f1 	rcall	8000a114 <quorem>
8000ad36:	2d 0c       	sub	r12,-48
8000ad38:	0a cc       	st.b	r5++,r12
8000ad3a:	02 36       	cp.w	r6,r1
8000ad3c:	c0 a4       	brge	8000ad50 <_dtoa_r+0xb1c>
8000ad3e:	00 9b       	mov	r11,r0
8000ad40:	30 09       	mov	r9,0
8000ad42:	30 aa       	mov	r10,10
8000ad44:	0e 9c       	mov	r12,r7
8000ad46:	2f f6       	sub	r6,-1
8000ad48:	e0 a0 07 04 	rcall	8000bb50 <__multadd>
8000ad4c:	18 90       	mov	r0,r12
8000ad4e:	cf 0b       	rjmp	8000ad2e <_dtoa_r+0xafa>
8000ad50:	08 96       	mov	r6,r4
8000ad52:	30 0b       	mov	r11,0
8000ad54:	06 94       	mov	r4,r3
8000ad56:	50 4b       	stdsp	sp[0x10],r11
8000ad58:	00 93       	mov	r3,r0
8000ad5a:	18 90       	mov	r0,r12
8000ad5c:	c0 28       	rjmp	8000ad60 <_dtoa_r+0xb2c>
8000ad5e:	40 26       	lddsp	r6,sp[0x8]
8000ad60:	06 9b       	mov	r11,r3
8000ad62:	30 1a       	mov	r10,1
8000ad64:	0e 9c       	mov	r12,r7
8000ad66:	e0 a0 06 29 	rcall	8000b9b8 <__lshift>
8000ad6a:	04 9b       	mov	r11,r2
8000ad6c:	18 93       	mov	r3,r12
8000ad6e:	e0 a0 05 02 	rcall	8000b772 <__mcmp>
8000ad72:	e0 89 00 12 	brgt	8000ad96 <_dtoa_r+0xb62>
8000ad76:	c1 b1       	brne	8000adac <_dtoa_r+0xb78>
8000ad78:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad7c:	c0 d1       	brne	8000ad96 <_dtoa_r+0xb62>
8000ad7e:	c1 78       	rjmp	8000adac <_dtoa_r+0xb78>
8000ad80:	40 89       	lddsp	r9,sp[0x20]
8000ad82:	12 38       	cp.w	r8,r9
8000ad84:	c0 30       	breq	8000ad8a <_dtoa_r+0xb56>
8000ad86:	10 95       	mov	r5,r8
8000ad88:	c0 88       	rjmp	8000ad98 <_dtoa_r+0xb64>
8000ad8a:	2f f6       	sub	r6,-1
8000ad8c:	50 66       	stdsp	sp[0x18],r6
8000ad8e:	33 18       	mov	r8,49
8000ad90:	40 8c       	lddsp	r12,sp[0x20]
8000ad92:	b8 88       	st.b	r12[0x0],r8
8000ad94:	c1 38       	rjmp	8000adba <_dtoa_r+0xb86>
8000ad96:	33 9a       	mov	r10,57
8000ad98:	0a 98       	mov	r8,r5
8000ad9a:	11 79       	ld.ub	r9,--r8
8000ad9c:	f4 09 18 00 	cp.b	r9,r10
8000ada0:	cf 00       	breq	8000ad80 <_dtoa_r+0xb4c>
8000ada2:	2f f9       	sub	r9,-1
8000ada4:	b0 89       	st.b	r8[0x0],r9
8000ada6:	c0 98       	rjmp	8000adb8 <_dtoa_r+0xb84>
8000ada8:	10 95       	mov	r5,r8
8000adaa:	c0 28       	rjmp	8000adae <_dtoa_r+0xb7a>
8000adac:	33 09       	mov	r9,48
8000adae:	0a 98       	mov	r8,r5
8000adb0:	11 7a       	ld.ub	r10,--r8
8000adb2:	f2 0a 18 00 	cp.b	r10,r9
8000adb6:	cf 90       	breq	8000ada8 <_dtoa_r+0xb74>
8000adb8:	50 66       	stdsp	sp[0x18],r6
8000adba:	04 9b       	mov	r11,r2
8000adbc:	0e 9c       	mov	r12,r7
8000adbe:	e0 a0 04 f3 	rcall	8000b7a4 <_Bfree>
8000adc2:	58 04       	cp.w	r4,0
8000adc4:	c1 20       	breq	8000ade8 <_dtoa_r+0xbb4>
8000adc6:	40 4b       	lddsp	r11,sp[0x10]
8000adc8:	08 3b       	cp.w	r11,r4
8000adca:	5f 19       	srne	r9
8000adcc:	58 0b       	cp.w	r11,0
8000adce:	5f 18       	srne	r8
8000add0:	f3 e8 00 08 	and	r8,r9,r8
8000add4:	c0 40       	breq	8000addc <_dtoa_r+0xba8>
8000add6:	0e 9c       	mov	r12,r7
8000add8:	e0 a0 04 e6 	rcall	8000b7a4 <_Bfree>
8000addc:	08 9b       	mov	r11,r4
8000adde:	0e 9c       	mov	r12,r7
8000ade0:	e0 a0 04 e2 	rcall	8000b7a4 <_Bfree>
8000ade4:	c0 28       	rjmp	8000ade8 <_dtoa_r+0xbb4>
8000ade6:	50 66       	stdsp	sp[0x18],r6
8000ade8:	0e 9c       	mov	r12,r7
8000adea:	06 9b       	mov	r11,r3
8000adec:	e0 a0 04 dc 	rcall	8000b7a4 <_Bfree>
8000adf0:	30 08       	mov	r8,0
8000adf2:	aa 88       	st.b	r5[0x0],r8
8000adf4:	40 68       	lddsp	r8,sp[0x18]
8000adf6:	41 5a       	lddsp	r10,sp[0x54]
8000adf8:	2f f8       	sub	r8,-1
8000adfa:	41 29       	lddsp	r9,sp[0x48]
8000adfc:	95 08       	st.w	r10[0x0],r8
8000adfe:	40 8c       	lddsp	r12,sp[0x20]
8000ae00:	58 09       	cp.w	r9,0
8000ae02:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ae06:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ae0a:	2e 6d       	sub	sp,-104
8000ae0c:	d8 32       	popm	r0-r7,pc
8000ae0e:	d7 03       	nop

8000ae10 <__errno>:
8000ae10:	e0 68 0a 40 	mov	r8,2624
8000ae14:	70 0c       	ld.w	r12,r8[0x0]
8000ae16:	2f 4c       	sub	r12,-12
8000ae18:	5e fc       	retal	r12
8000ae1a:	d7 03       	nop

8000ae1c <_fflush_r>:
8000ae1c:	d4 21       	pushm	r4-r7,lr
8000ae1e:	16 97       	mov	r7,r11
8000ae20:	18 96       	mov	r6,r12
8000ae22:	76 48       	ld.w	r8,r11[0x10]
8000ae24:	58 08       	cp.w	r8,0
8000ae26:	c7 f0       	breq	8000af24 <_fflush_r+0x108>
8000ae28:	58 0c       	cp.w	r12,0
8000ae2a:	c0 50       	breq	8000ae34 <_fflush_r+0x18>
8000ae2c:	78 68       	ld.w	r8,r12[0x18]
8000ae2e:	58 08       	cp.w	r8,0
8000ae30:	c0 21       	brne	8000ae34 <_fflush_r+0x18>
8000ae32:	cc dc       	rcall	8000afcc <__sinit>
8000ae34:	fe c8 cd 1c 	sub	r8,pc,-13028
8000ae38:	10 37       	cp.w	r7,r8
8000ae3a:	c0 31       	brne	8000ae40 <_fflush_r+0x24>
8000ae3c:	6c 07       	ld.w	r7,r6[0x0]
8000ae3e:	c0 c8       	rjmp	8000ae56 <_fflush_r+0x3a>
8000ae40:	fe c8 cd 08 	sub	r8,pc,-13048
8000ae44:	10 37       	cp.w	r7,r8
8000ae46:	c0 31       	brne	8000ae4c <_fflush_r+0x30>
8000ae48:	6c 17       	ld.w	r7,r6[0x4]
8000ae4a:	c0 68       	rjmp	8000ae56 <_fflush_r+0x3a>
8000ae4c:	fe c8 cc f4 	sub	r8,pc,-13068
8000ae50:	10 37       	cp.w	r7,r8
8000ae52:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae56:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae58:	14 98       	mov	r8,r10
8000ae5a:	ed ba 00 03 	bld	r10,0x3
8000ae5e:	c4 20       	breq	8000aee2 <_fflush_r+0xc6>
8000ae60:	ab ba       	sbr	r10,0xb
8000ae62:	ae 6a       	st.h	r7[0xc],r10
8000ae64:	6e 18       	ld.w	r8,r7[0x4]
8000ae66:	58 08       	cp.w	r8,0
8000ae68:	e0 89 00 06 	brgt	8000ae74 <_fflush_r+0x58>
8000ae6c:	6f 08       	ld.w	r8,r7[0x40]
8000ae6e:	58 08       	cp.w	r8,0
8000ae70:	e0 8a 00 5a 	brle	8000af24 <_fflush_r+0x108>
8000ae74:	6e b8       	ld.w	r8,r7[0x2c]
8000ae76:	58 08       	cp.w	r8,0
8000ae78:	c5 60       	breq	8000af24 <_fflush_r+0x108>
8000ae7a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae7e:	c0 30       	breq	8000ae84 <_fflush_r+0x68>
8000ae80:	6f 55       	ld.w	r5,r7[0x54]
8000ae82:	c0 f8       	rjmp	8000aea0 <_fflush_r+0x84>
8000ae84:	30 19       	mov	r9,1
8000ae86:	6e 8b       	ld.w	r11,r7[0x20]
8000ae88:	0c 9c       	mov	r12,r6
8000ae8a:	5d 18       	icall	r8
8000ae8c:	18 95       	mov	r5,r12
8000ae8e:	5b fc       	cp.w	r12,-1
8000ae90:	c0 81       	brne	8000aea0 <_fflush_r+0x84>
8000ae92:	6c 38       	ld.w	r8,r6[0xc]
8000ae94:	59 d8       	cp.w	r8,29
8000ae96:	c4 70       	breq	8000af24 <_fflush_r+0x108>
8000ae98:	8e 68       	ld.sh	r8,r7[0xc]
8000ae9a:	a7 a8       	sbr	r8,0x6
8000ae9c:	ae 68       	st.h	r7[0xc],r8
8000ae9e:	d8 22       	popm	r4-r7,pc
8000aea0:	8e 68       	ld.sh	r8,r7[0xc]
8000aea2:	ed b8 00 02 	bld	r8,0x2
8000aea6:	c0 91       	brne	8000aeb8 <_fflush_r+0x9c>
8000aea8:	6e 18       	ld.w	r8,r7[0x4]
8000aeaa:	10 15       	sub	r5,r8
8000aeac:	6e d8       	ld.w	r8,r7[0x34]
8000aeae:	58 08       	cp.w	r8,0
8000aeb0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aeb4:	eb d8 e1 15 	subne	r5,r5,r8
8000aeb8:	6e b8       	ld.w	r8,r7[0x2c]
8000aeba:	0c 9c       	mov	r12,r6
8000aebc:	30 09       	mov	r9,0
8000aebe:	0a 9a       	mov	r10,r5
8000aec0:	6e 8b       	ld.w	r11,r7[0x20]
8000aec2:	5d 18       	icall	r8
8000aec4:	8e 68       	ld.sh	r8,r7[0xc]
8000aec6:	0a 3c       	cp.w	r12,r5
8000aec8:	c2 61       	brne	8000af14 <_fflush_r+0xf8>
8000aeca:	ab d8       	cbr	r8,0xb
8000aecc:	30 0c       	mov	r12,0
8000aece:	6e 49       	ld.w	r9,r7[0x10]
8000aed0:	ae 68       	st.h	r7[0xc],r8
8000aed2:	8f 1c       	st.w	r7[0x4],r12
8000aed4:	8f 09       	st.w	r7[0x0],r9
8000aed6:	ed b8 00 0c 	bld	r8,0xc
8000aeda:	c2 51       	brne	8000af24 <_fflush_r+0x108>
8000aedc:	ef 45 00 54 	st.w	r7[84],r5
8000aee0:	d8 22       	popm	r4-r7,pc
8000aee2:	6e 45       	ld.w	r5,r7[0x10]
8000aee4:	58 05       	cp.w	r5,0
8000aee6:	c1 f0       	breq	8000af24 <_fflush_r+0x108>
8000aee8:	6e 04       	ld.w	r4,r7[0x0]
8000aeea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aeee:	8f 05       	st.w	r7[0x0],r5
8000aef0:	f9 b8 01 00 	movne	r8,0
8000aef4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aef8:	0a 14       	sub	r4,r5
8000aefa:	8f 28       	st.w	r7[0x8],r8
8000aefc:	c1 18       	rjmp	8000af1e <_fflush_r+0x102>
8000aefe:	08 99       	mov	r9,r4
8000af00:	0a 9a       	mov	r10,r5
8000af02:	6e a8       	ld.w	r8,r7[0x28]
8000af04:	6e 8b       	ld.w	r11,r7[0x20]
8000af06:	0c 9c       	mov	r12,r6
8000af08:	5d 18       	icall	r8
8000af0a:	18 14       	sub	r4,r12
8000af0c:	58 0c       	cp.w	r12,0
8000af0e:	e0 89 00 07 	brgt	8000af1c <_fflush_r+0x100>
8000af12:	8e 68       	ld.sh	r8,r7[0xc]
8000af14:	a7 a8       	sbr	r8,0x6
8000af16:	3f fc       	mov	r12,-1
8000af18:	ae 68       	st.h	r7[0xc],r8
8000af1a:	d8 22       	popm	r4-r7,pc
8000af1c:	18 05       	add	r5,r12
8000af1e:	58 04       	cp.w	r4,0
8000af20:	fe 99 ff ef 	brgt	8000aefe <_fflush_r+0xe2>
8000af24:	d8 2a       	popm	r4-r7,pc,r12=0
8000af26:	d7 03       	nop

8000af28 <__sfp_lock_acquire>:
8000af28:	5e fc       	retal	r12

8000af2a <__sfp_lock_release>:
8000af2a:	5e fc       	retal	r12

8000af2c <_cleanup_r>:
8000af2c:	d4 01       	pushm	lr
8000af2e:	fe cb f0 ae 	sub	r11,pc,-3922
8000af32:	e0 a0 02 f7 	rcall	8000b520 <_fwalk>
8000af36:	d8 02       	popm	pc

8000af38 <__sfmoreglue>:
8000af38:	d4 21       	pushm	r4-r7,lr
8000af3a:	16 95       	mov	r5,r11
8000af3c:	f6 06 10 5c 	mul	r6,r11,92
8000af40:	ec cb ff f4 	sub	r11,r6,-12
8000af44:	fe b0 e2 88 	rcall	80007454 <_malloc_r>
8000af48:	18 97       	mov	r7,r12
8000af4a:	c0 90       	breq	8000af5c <__sfmoreglue+0x24>
8000af4c:	99 15       	st.w	r12[0x4],r5
8000af4e:	30 0b       	mov	r11,0
8000af50:	2f 4c       	sub	r12,-12
8000af52:	0c 9a       	mov	r10,r6
8000af54:	8f 2c       	st.w	r7[0x8],r12
8000af56:	8f 0b       	st.w	r7[0x0],r11
8000af58:	fe b0 e5 3e 	rcall	800079d4 <memset>
8000af5c:	0e 9c       	mov	r12,r7
8000af5e:	d8 22       	popm	r4-r7,pc

8000af60 <__sfp>:
8000af60:	d4 21       	pushm	r4-r7,lr
8000af62:	fe c8 cd e6 	sub	r8,pc,-12826
8000af66:	18 96       	mov	r6,r12
8000af68:	70 07       	ld.w	r7,r8[0x0]
8000af6a:	6e 68       	ld.w	r8,r7[0x18]
8000af6c:	58 08       	cp.w	r8,0
8000af6e:	c0 31       	brne	8000af74 <__sfp+0x14>
8000af70:	0e 9c       	mov	r12,r7
8000af72:	c2 dc       	rcall	8000afcc <__sinit>
8000af74:	ee c7 ff 28 	sub	r7,r7,-216
8000af78:	30 05       	mov	r5,0
8000af7a:	6e 2c       	ld.w	r12,r7[0x8]
8000af7c:	6e 18       	ld.w	r8,r7[0x4]
8000af7e:	c0 68       	rjmp	8000af8a <__sfp+0x2a>
8000af80:	98 69       	ld.sh	r9,r12[0xc]
8000af82:	ea 09 19 00 	cp.h	r9,r5
8000af86:	c1 10       	breq	8000afa8 <__sfp+0x48>
8000af88:	2a 4c       	sub	r12,-92
8000af8a:	20 18       	sub	r8,1
8000af8c:	cf a7       	brpl	8000af80 <__sfp+0x20>
8000af8e:	6e 08       	ld.w	r8,r7[0x0]
8000af90:	58 08       	cp.w	r8,0
8000af92:	c0 61       	brne	8000af9e <__sfp+0x3e>
8000af94:	30 4b       	mov	r11,4
8000af96:	0c 9c       	mov	r12,r6
8000af98:	cd 0f       	rcall	8000af38 <__sfmoreglue>
8000af9a:	8f 0c       	st.w	r7[0x0],r12
8000af9c:	c0 30       	breq	8000afa2 <__sfp+0x42>
8000af9e:	6e 07       	ld.w	r7,r7[0x0]
8000afa0:	ce db       	rjmp	8000af7a <__sfp+0x1a>
8000afa2:	30 c8       	mov	r8,12
8000afa4:	8d 38       	st.w	r6[0xc],r8
8000afa6:	d8 22       	popm	r4-r7,pc
8000afa8:	30 08       	mov	r8,0
8000afaa:	f9 48 00 4c 	st.w	r12[76],r8
8000afae:	99 08       	st.w	r12[0x0],r8
8000afb0:	99 28       	st.w	r12[0x8],r8
8000afb2:	99 18       	st.w	r12[0x4],r8
8000afb4:	99 48       	st.w	r12[0x10],r8
8000afb6:	99 58       	st.w	r12[0x14],r8
8000afb8:	99 68       	st.w	r12[0x18],r8
8000afba:	99 d8       	st.w	r12[0x34],r8
8000afbc:	99 e8       	st.w	r12[0x38],r8
8000afbe:	f9 48 00 48 	st.w	r12[72],r8
8000afc2:	3f f8       	mov	r8,-1
8000afc4:	b8 78       	st.h	r12[0xe],r8
8000afc6:	30 18       	mov	r8,1
8000afc8:	b8 68       	st.h	r12[0xc],r8
8000afca:	d8 22       	popm	r4-r7,pc

8000afcc <__sinit>:
8000afcc:	d4 21       	pushm	r4-r7,lr
8000afce:	18 96       	mov	r6,r12
8000afd0:	78 67       	ld.w	r7,r12[0x18]
8000afd2:	58 07       	cp.w	r7,0
8000afd4:	c4 91       	brne	8000b066 <__sinit+0x9a>
8000afd6:	fe c8 00 aa 	sub	r8,pc,170
8000afda:	30 15       	mov	r5,1
8000afdc:	99 a8       	st.w	r12[0x28],r8
8000afde:	f9 47 00 d8 	st.w	r12[216],r7
8000afe2:	f9 47 00 dc 	st.w	r12[220],r7
8000afe6:	f9 47 00 e0 	st.w	r12[224],r7
8000afea:	99 65       	st.w	r12[0x18],r5
8000afec:	cb af       	rcall	8000af60 <__sfp>
8000afee:	8d 0c       	st.w	r6[0x0],r12
8000aff0:	0c 9c       	mov	r12,r6
8000aff2:	cb 7f       	rcall	8000af60 <__sfp>
8000aff4:	8d 1c       	st.w	r6[0x4],r12
8000aff6:	0c 9c       	mov	r12,r6
8000aff8:	cb 4f       	rcall	8000af60 <__sfp>
8000affa:	6c 09       	ld.w	r9,r6[0x0]
8000affc:	30 48       	mov	r8,4
8000affe:	93 07       	st.w	r9[0x0],r7
8000b000:	b2 68       	st.h	r9[0xc],r8
8000b002:	93 17       	st.w	r9[0x4],r7
8000b004:	93 27       	st.w	r9[0x8],r7
8000b006:	6c 18       	ld.w	r8,r6[0x4]
8000b008:	b2 77       	st.h	r9[0xe],r7
8000b00a:	93 47       	st.w	r9[0x10],r7
8000b00c:	93 57       	st.w	r9[0x14],r7
8000b00e:	93 67       	st.w	r9[0x18],r7
8000b010:	93 89       	st.w	r9[0x20],r9
8000b012:	91 07       	st.w	r8[0x0],r7
8000b014:	91 17       	st.w	r8[0x4],r7
8000b016:	91 27       	st.w	r8[0x8],r7
8000b018:	fe ce f3 24 	sub	lr,pc,-3292
8000b01c:	fe cb f3 54 	sub	r11,pc,-3244
8000b020:	93 9e       	st.w	r9[0x24],lr
8000b022:	93 ab       	st.w	r9[0x28],r11
8000b024:	fe ca f3 7c 	sub	r10,pc,-3204
8000b028:	fe c4 f3 88 	sub	r4,pc,-3192
8000b02c:	93 ba       	st.w	r9[0x2c],r10
8000b02e:	93 c4       	st.w	r9[0x30],r4
8000b030:	30 99       	mov	r9,9
8000b032:	b0 69       	st.h	r8[0xc],r9
8000b034:	b0 75       	st.h	r8[0xe],r5
8000b036:	91 c4       	st.w	r8[0x30],r4
8000b038:	91 47       	st.w	r8[0x10],r7
8000b03a:	91 57       	st.w	r8[0x14],r7
8000b03c:	91 67       	st.w	r8[0x18],r7
8000b03e:	91 88       	st.w	r8[0x20],r8
8000b040:	91 9e       	st.w	r8[0x24],lr
8000b042:	91 ab       	st.w	r8[0x28],r11
8000b044:	91 ba       	st.w	r8[0x2c],r10
8000b046:	8d 2c       	st.w	r6[0x8],r12
8000b048:	31 28       	mov	r8,18
8000b04a:	99 07       	st.w	r12[0x0],r7
8000b04c:	b8 68       	st.h	r12[0xc],r8
8000b04e:	99 17       	st.w	r12[0x4],r7
8000b050:	99 27       	st.w	r12[0x8],r7
8000b052:	30 28       	mov	r8,2
8000b054:	b8 78       	st.h	r12[0xe],r8
8000b056:	99 c4       	st.w	r12[0x30],r4
8000b058:	99 67       	st.w	r12[0x18],r7
8000b05a:	99 9e       	st.w	r12[0x24],lr
8000b05c:	99 ab       	st.w	r12[0x28],r11
8000b05e:	99 ba       	st.w	r12[0x2c],r10
8000b060:	99 47       	st.w	r12[0x10],r7
8000b062:	99 57       	st.w	r12[0x14],r7
8000b064:	99 8c       	st.w	r12[0x20],r12
8000b066:	d8 22       	popm	r4-r7,pc

8000b068 <_malloc_trim_r>:
8000b068:	d4 21       	pushm	r4-r7,lr
8000b06a:	16 95       	mov	r5,r11
8000b06c:	18 97       	mov	r7,r12
8000b06e:	fe b0 d7 a9 	rcall	80005fc0 <__malloc_lock>
8000b072:	e0 64 05 40 	mov	r4,1344
8000b076:	68 28       	ld.w	r8,r4[0x8]
8000b078:	70 16       	ld.w	r6,r8[0x4]
8000b07a:	e0 16 ff fc 	andl	r6,0xfffc
8000b07e:	ec c8 ff 91 	sub	r8,r6,-111
8000b082:	f0 05 01 05 	sub	r5,r8,r5
8000b086:	e0 15 ff 80 	andl	r5,0xff80
8000b08a:	ea c5 00 80 	sub	r5,r5,128
8000b08e:	e0 45 00 7f 	cp.w	r5,127
8000b092:	e0 8a 00 25 	brle	8000b0dc <_malloc_trim_r+0x74>
8000b096:	30 0b       	mov	r11,0
8000b098:	0e 9c       	mov	r12,r7
8000b09a:	fe b0 e6 05 	rcall	80007ca4 <_sbrk_r>
8000b09e:	68 28       	ld.w	r8,r4[0x8]
8000b0a0:	0c 08       	add	r8,r6
8000b0a2:	10 3c       	cp.w	r12,r8
8000b0a4:	c1 c1       	brne	8000b0dc <_malloc_trim_r+0x74>
8000b0a6:	ea 0b 11 00 	rsub	r11,r5,0
8000b0aa:	0e 9c       	mov	r12,r7
8000b0ac:	fe b0 e5 fc 	rcall	80007ca4 <_sbrk_r>
8000b0b0:	5b fc       	cp.w	r12,-1
8000b0b2:	c1 91       	brne	8000b0e4 <_malloc_trim_r+0x7c>
8000b0b4:	30 0b       	mov	r11,0
8000b0b6:	0e 9c       	mov	r12,r7
8000b0b8:	fe b0 e5 f6 	rcall	80007ca4 <_sbrk_r>
8000b0bc:	68 28       	ld.w	r8,r4[0x8]
8000b0be:	f8 08 01 09 	sub	r9,r12,r8
8000b0c2:	58 f9       	cp.w	r9,15
8000b0c4:	e0 8a 00 0c 	brle	8000b0dc <_malloc_trim_r+0x74>
8000b0c8:	a1 a9       	sbr	r9,0x0
8000b0ca:	91 19       	st.w	r8[0x4],r9
8000b0cc:	e0 68 09 4c 	mov	r8,2380
8000b0d0:	70 09       	ld.w	r9,r8[0x0]
8000b0d2:	e0 68 0d 6c 	mov	r8,3436
8000b0d6:	f8 09 01 09 	sub	r9,r12,r9
8000b0da:	91 09       	st.w	r8[0x0],r9
8000b0dc:	0e 9c       	mov	r12,r7
8000b0de:	fe b0 d7 77 	rcall	80005fcc <__malloc_unlock>
8000b0e2:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0e4:	68 28       	ld.w	r8,r4[0x8]
8000b0e6:	0a 16       	sub	r6,r5
8000b0e8:	a1 a6       	sbr	r6,0x0
8000b0ea:	91 16       	st.w	r8[0x4],r6
8000b0ec:	e0 68 0d 6c 	mov	r8,3436
8000b0f0:	70 09       	ld.w	r9,r8[0x0]
8000b0f2:	0a 19       	sub	r9,r5
8000b0f4:	0e 9c       	mov	r12,r7
8000b0f6:	91 09       	st.w	r8[0x0],r9
8000b0f8:	fe b0 d7 6a 	rcall	80005fcc <__malloc_unlock>
8000b0fc:	da 2a       	popm	r4-r7,pc,r12=1
8000b0fe:	d7 03       	nop

8000b100 <_free_r>:
8000b100:	d4 21       	pushm	r4-r7,lr
8000b102:	16 96       	mov	r6,r11
8000b104:	18 97       	mov	r7,r12
8000b106:	58 0b       	cp.w	r11,0
8000b108:	e0 80 00 c0 	breq	8000b288 <_free_r+0x188>
8000b10c:	fe b0 d7 5a 	rcall	80005fc0 <__malloc_lock>
8000b110:	20 86       	sub	r6,8
8000b112:	e0 6a 05 40 	mov	r10,1344
8000b116:	6c 18       	ld.w	r8,r6[0x4]
8000b118:	74 2e       	ld.w	lr,r10[0x8]
8000b11a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b11e:	a1 c8       	cbr	r8,0x0
8000b120:	ec 08 00 09 	add	r9,r6,r8
8000b124:	72 1b       	ld.w	r11,r9[0x4]
8000b126:	e0 1b ff fc 	andl	r11,0xfffc
8000b12a:	1c 39       	cp.w	r9,lr
8000b12c:	c1 e1       	brne	8000b168 <_free_r+0x68>
8000b12e:	f6 08 00 08 	add	r8,r11,r8
8000b132:	58 0c       	cp.w	r12,0
8000b134:	c0 81       	brne	8000b144 <_free_r+0x44>
8000b136:	6c 09       	ld.w	r9,r6[0x0]
8000b138:	12 16       	sub	r6,r9
8000b13a:	12 08       	add	r8,r9
8000b13c:	6c 3b       	ld.w	r11,r6[0xc]
8000b13e:	6c 29       	ld.w	r9,r6[0x8]
8000b140:	97 29       	st.w	r11[0x8],r9
8000b142:	93 3b       	st.w	r9[0xc],r11
8000b144:	10 99       	mov	r9,r8
8000b146:	95 26       	st.w	r10[0x8],r6
8000b148:	a1 a9       	sbr	r9,0x0
8000b14a:	8d 19       	st.w	r6[0x4],r9
8000b14c:	e0 69 09 48 	mov	r9,2376
8000b150:	72 09       	ld.w	r9,r9[0x0]
8000b152:	12 38       	cp.w	r8,r9
8000b154:	c0 63       	brcs	8000b160 <_free_r+0x60>
8000b156:	e0 68 0d 68 	mov	r8,3432
8000b15a:	0e 9c       	mov	r12,r7
8000b15c:	70 0b       	ld.w	r11,r8[0x0]
8000b15e:	c8 5f       	rcall	8000b068 <_malloc_trim_r>
8000b160:	0e 9c       	mov	r12,r7
8000b162:	fe b0 d7 35 	rcall	80005fcc <__malloc_unlock>
8000b166:	d8 22       	popm	r4-r7,pc
8000b168:	93 1b       	st.w	r9[0x4],r11
8000b16a:	58 0c       	cp.w	r12,0
8000b16c:	c0 30       	breq	8000b172 <_free_r+0x72>
8000b16e:	30 0c       	mov	r12,0
8000b170:	c1 08       	rjmp	8000b190 <_free_r+0x90>
8000b172:	6c 0e       	ld.w	lr,r6[0x0]
8000b174:	f4 c5 ff f8 	sub	r5,r10,-8
8000b178:	1c 16       	sub	r6,lr
8000b17a:	1c 08       	add	r8,lr
8000b17c:	6c 2e       	ld.w	lr,r6[0x8]
8000b17e:	0a 3e       	cp.w	lr,r5
8000b180:	f9 bc 00 01 	moveq	r12,1
8000b184:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b188:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b18c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b190:	f2 0b 00 0e 	add	lr,r9,r11
8000b194:	7c 1e       	ld.w	lr,lr[0x4]
8000b196:	ed be 00 00 	bld	lr,0x0
8000b19a:	c1 40       	breq	8000b1c2 <_free_r+0xc2>
8000b19c:	16 08       	add	r8,r11
8000b19e:	58 0c       	cp.w	r12,0
8000b1a0:	c0 d1       	brne	8000b1ba <_free_r+0xba>
8000b1a2:	e0 6e 05 40 	mov	lr,1344
8000b1a6:	72 2b       	ld.w	r11,r9[0x8]
8000b1a8:	2f 8e       	sub	lr,-8
8000b1aa:	1c 3b       	cp.w	r11,lr
8000b1ac:	c0 71       	brne	8000b1ba <_free_r+0xba>
8000b1ae:	97 36       	st.w	r11[0xc],r6
8000b1b0:	97 26       	st.w	r11[0x8],r6
8000b1b2:	8d 2b       	st.w	r6[0x8],r11
8000b1b4:	8d 3b       	st.w	r6[0xc],r11
8000b1b6:	30 1c       	mov	r12,1
8000b1b8:	c0 58       	rjmp	8000b1c2 <_free_r+0xc2>
8000b1ba:	72 2b       	ld.w	r11,r9[0x8]
8000b1bc:	72 39       	ld.w	r9,r9[0xc]
8000b1be:	93 2b       	st.w	r9[0x8],r11
8000b1c0:	97 39       	st.w	r11[0xc],r9
8000b1c2:	10 99       	mov	r9,r8
8000b1c4:	ec 08 09 08 	st.w	r6[r8],r8
8000b1c8:	a1 a9       	sbr	r9,0x0
8000b1ca:	8d 19       	st.w	r6[0x4],r9
8000b1cc:	58 0c       	cp.w	r12,0
8000b1ce:	c5 a1       	brne	8000b282 <_free_r+0x182>
8000b1d0:	e0 48 01 ff 	cp.w	r8,511
8000b1d4:	e0 8b 00 13 	brhi	8000b1fa <_free_r+0xfa>
8000b1d8:	a3 98       	lsr	r8,0x3
8000b1da:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b1de:	72 2b       	ld.w	r11,r9[0x8]
8000b1e0:	8d 39       	st.w	r6[0xc],r9
8000b1e2:	8d 2b       	st.w	r6[0x8],r11
8000b1e4:	97 36       	st.w	r11[0xc],r6
8000b1e6:	93 26       	st.w	r9[0x8],r6
8000b1e8:	a3 48       	asr	r8,0x2
8000b1ea:	74 19       	ld.w	r9,r10[0x4]
8000b1ec:	30 1b       	mov	r11,1
8000b1ee:	f6 08 09 48 	lsl	r8,r11,r8
8000b1f2:	f3 e8 10 08 	or	r8,r9,r8
8000b1f6:	95 18       	st.w	r10[0x4],r8
8000b1f8:	c4 58       	rjmp	8000b282 <_free_r+0x182>
8000b1fa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b1fe:	58 4b       	cp.w	r11,4
8000b200:	e0 8b 00 06 	brhi	8000b20c <_free_r+0x10c>
8000b204:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b208:	2c 8b       	sub	r11,-56
8000b20a:	c2 08       	rjmp	8000b24a <_free_r+0x14a>
8000b20c:	59 4b       	cp.w	r11,20
8000b20e:	e0 8b 00 04 	brhi	8000b216 <_free_r+0x116>
8000b212:	2a 5b       	sub	r11,-91
8000b214:	c1 b8       	rjmp	8000b24a <_free_r+0x14a>
8000b216:	e0 4b 00 54 	cp.w	r11,84
8000b21a:	e0 8b 00 06 	brhi	8000b226 <_free_r+0x126>
8000b21e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b222:	29 2b       	sub	r11,-110
8000b224:	c1 38       	rjmp	8000b24a <_free_r+0x14a>
8000b226:	e0 4b 01 54 	cp.w	r11,340
8000b22a:	e0 8b 00 06 	brhi	8000b236 <_free_r+0x136>
8000b22e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b232:	28 9b       	sub	r11,-119
8000b234:	c0 b8       	rjmp	8000b24a <_free_r+0x14a>
8000b236:	e0 4b 05 54 	cp.w	r11,1364
8000b23a:	e0 88 00 05 	brls	8000b244 <_free_r+0x144>
8000b23e:	37 eb       	mov	r11,126
8000b240:	c0 58       	rjmp	8000b24a <_free_r+0x14a>
8000b242:	d7 03       	nop
8000b244:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b248:	28 4b       	sub	r11,-124
8000b24a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b24e:	78 29       	ld.w	r9,r12[0x8]
8000b250:	18 39       	cp.w	r9,r12
8000b252:	c0 e1       	brne	8000b26e <_free_r+0x16e>
8000b254:	74 18       	ld.w	r8,r10[0x4]
8000b256:	a3 4b       	asr	r11,0x2
8000b258:	30 1c       	mov	r12,1
8000b25a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b25e:	f1 eb 10 0b 	or	r11,r8,r11
8000b262:	12 98       	mov	r8,r9
8000b264:	95 1b       	st.w	r10[0x4],r11
8000b266:	c0 a8       	rjmp	8000b27a <_free_r+0x17a>
8000b268:	72 29       	ld.w	r9,r9[0x8]
8000b26a:	18 39       	cp.w	r9,r12
8000b26c:	c0 60       	breq	8000b278 <_free_r+0x178>
8000b26e:	72 1a       	ld.w	r10,r9[0x4]
8000b270:	e0 1a ff fc 	andl	r10,0xfffc
8000b274:	14 38       	cp.w	r8,r10
8000b276:	cf 93       	brcs	8000b268 <_free_r+0x168>
8000b278:	72 38       	ld.w	r8,r9[0xc]
8000b27a:	8d 38       	st.w	r6[0xc],r8
8000b27c:	8d 29       	st.w	r6[0x8],r9
8000b27e:	93 36       	st.w	r9[0xc],r6
8000b280:	91 26       	st.w	r8[0x8],r6
8000b282:	0e 9c       	mov	r12,r7
8000b284:	fe b0 d6 a4 	rcall	80005fcc <__malloc_unlock>
8000b288:	d8 22       	popm	r4-r7,pc
8000b28a:	d7 03       	nop

8000b28c <__sfvwrite_r>:
8000b28c:	d4 31       	pushm	r0-r7,lr
8000b28e:	20 3d       	sub	sp,12
8000b290:	14 94       	mov	r4,r10
8000b292:	18 95       	mov	r5,r12
8000b294:	16 97       	mov	r7,r11
8000b296:	74 28       	ld.w	r8,r10[0x8]
8000b298:	58 08       	cp.w	r8,0
8000b29a:	e0 80 01 40 	breq	8000b51a <__sfvwrite_r+0x28e>
8000b29e:	96 68       	ld.sh	r8,r11[0xc]
8000b2a0:	ed b8 00 03 	bld	r8,0x3
8000b2a4:	c0 41       	brne	8000b2ac <__sfvwrite_r+0x20>
8000b2a6:	76 48       	ld.w	r8,r11[0x10]
8000b2a8:	58 08       	cp.w	r8,0
8000b2aa:	c0 c1       	brne	8000b2c2 <__sfvwrite_r+0x36>
8000b2ac:	0e 9b       	mov	r11,r7
8000b2ae:	0a 9c       	mov	r12,r5
8000b2b0:	fe b0 f6 c4 	rcall	8000a038 <__swsetup_r>
8000b2b4:	c0 70       	breq	8000b2c2 <__sfvwrite_r+0x36>
8000b2b6:	8e 68       	ld.sh	r8,r7[0xc]
8000b2b8:	a7 a8       	sbr	r8,0x6
8000b2ba:	ae 68       	st.h	r7[0xc],r8
8000b2bc:	30 98       	mov	r8,9
8000b2be:	8b 38       	st.w	r5[0xc],r8
8000b2c0:	c2 b9       	rjmp	8000b516 <__sfvwrite_r+0x28a>
8000b2c2:	8e 63       	ld.sh	r3,r7[0xc]
8000b2c4:	68 00       	ld.w	r0,r4[0x0]
8000b2c6:	06 96       	mov	r6,r3
8000b2c8:	e2 16 00 02 	andl	r6,0x2,COH
8000b2cc:	c2 10       	breq	8000b30e <__sfvwrite_r+0x82>
8000b2ce:	30 03       	mov	r3,0
8000b2d0:	e0 62 04 00 	mov	r2,1024
8000b2d4:	06 96       	mov	r6,r3
8000b2d6:	c0 48       	rjmp	8000b2de <__sfvwrite_r+0x52>
8000b2d8:	60 03       	ld.w	r3,r0[0x0]
8000b2da:	60 16       	ld.w	r6,r0[0x4]
8000b2dc:	2f 80       	sub	r0,-8
8000b2de:	58 06       	cp.w	r6,0
8000b2e0:	cf c0       	breq	8000b2d8 <__sfvwrite_r+0x4c>
8000b2e2:	e0 46 04 00 	cp.w	r6,1024
8000b2e6:	ec 09 17 80 	movls	r9,r6
8000b2ea:	e4 09 17 b0 	movhi	r9,r2
8000b2ee:	06 9a       	mov	r10,r3
8000b2f0:	6e a8       	ld.w	r8,r7[0x28]
8000b2f2:	6e 8b       	ld.w	r11,r7[0x20]
8000b2f4:	0a 9c       	mov	r12,r5
8000b2f6:	5d 18       	icall	r8
8000b2f8:	18 16       	sub	r6,r12
8000b2fa:	58 0c       	cp.w	r12,0
8000b2fc:	e0 8a 01 0a 	brle	8000b510 <__sfvwrite_r+0x284>
8000b300:	68 28       	ld.w	r8,r4[0x8]
8000b302:	18 18       	sub	r8,r12
8000b304:	89 28       	st.w	r4[0x8],r8
8000b306:	e0 80 01 0a 	breq	8000b51a <__sfvwrite_r+0x28e>
8000b30a:	18 03       	add	r3,r12
8000b30c:	ce 9b       	rjmp	8000b2de <__sfvwrite_r+0x52>
8000b30e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b312:	c0 70       	breq	8000b320 <__sfvwrite_r+0x94>
8000b314:	50 06       	stdsp	sp[0x0],r6
8000b316:	0c 93       	mov	r3,r6
8000b318:	0c 91       	mov	r1,r6
8000b31a:	50 15       	stdsp	sp[0x4],r5
8000b31c:	08 92       	mov	r2,r4
8000b31e:	c9 c8       	rjmp	8000b456 <__sfvwrite_r+0x1ca>
8000b320:	06 96       	mov	r6,r3
8000b322:	08 91       	mov	r1,r4
8000b324:	c0 48       	rjmp	8000b32c <__sfvwrite_r+0xa0>
8000b326:	60 03       	ld.w	r3,r0[0x0]
8000b328:	60 16       	ld.w	r6,r0[0x4]
8000b32a:	2f 80       	sub	r0,-8
8000b32c:	58 06       	cp.w	r6,0
8000b32e:	cf c0       	breq	8000b326 <__sfvwrite_r+0x9a>
8000b330:	8e 68       	ld.sh	r8,r7[0xc]
8000b332:	6e 24       	ld.w	r4,r7[0x8]
8000b334:	10 99       	mov	r9,r8
8000b336:	e2 19 02 00 	andl	r9,0x200,COH
8000b33a:	c5 50       	breq	8000b3e4 <__sfvwrite_r+0x158>
8000b33c:	08 36       	cp.w	r6,r4
8000b33e:	c4 43       	brcs	8000b3c6 <__sfvwrite_r+0x13a>
8000b340:	10 99       	mov	r9,r8
8000b342:	e2 19 04 80 	andl	r9,0x480,COH
8000b346:	c4 00       	breq	8000b3c6 <__sfvwrite_r+0x13a>
8000b348:	6e 4b       	ld.w	r11,r7[0x10]
8000b34a:	6e 09       	ld.w	r9,r7[0x0]
8000b34c:	16 19       	sub	r9,r11
8000b34e:	50 09       	stdsp	sp[0x0],r9
8000b350:	6e 59       	ld.w	r9,r7[0x14]
8000b352:	10 9c       	mov	r12,r8
8000b354:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b358:	30 28       	mov	r8,2
8000b35a:	f4 08 0c 08 	divs	r8,r10,r8
8000b35e:	fa e9 00 04 	st.d	sp[4],r8
8000b362:	10 94       	mov	r4,r8
8000b364:	40 09       	lddsp	r9,sp[0x0]
8000b366:	e2 1c 04 00 	andl	r12,0x400,COH
8000b36a:	2f f9       	sub	r9,-1
8000b36c:	0c 09       	add	r9,r6
8000b36e:	12 38       	cp.w	r8,r9
8000b370:	f2 04 17 30 	movlo	r4,r9
8000b374:	58 0c       	cp.w	r12,0
8000b376:	c1 10       	breq	8000b398 <__sfvwrite_r+0x10c>
8000b378:	08 9b       	mov	r11,r4
8000b37a:	0a 9c       	mov	r12,r5
8000b37c:	fe b0 e0 6c 	rcall	80007454 <_malloc_r>
8000b380:	18 92       	mov	r2,r12
8000b382:	c1 40       	breq	8000b3aa <__sfvwrite_r+0x11e>
8000b384:	40 0a       	lddsp	r10,sp[0x0]
8000b386:	6e 4b       	ld.w	r11,r7[0x10]
8000b388:	fe b0 e2 82 	rcall	8000788c <memcpy>
8000b38c:	8e 68       	ld.sh	r8,r7[0xc]
8000b38e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b392:	a7 b8       	sbr	r8,0x7
8000b394:	ae 68       	st.h	r7[0xc],r8
8000b396:	c0 d8       	rjmp	8000b3b0 <__sfvwrite_r+0x124>
8000b398:	08 9a       	mov	r10,r4
8000b39a:	0a 9c       	mov	r12,r5
8000b39c:	fe b0 e3 24 	rcall	800079e4 <_realloc_r>
8000b3a0:	18 92       	mov	r2,r12
8000b3a2:	c0 71       	brne	8000b3b0 <__sfvwrite_r+0x124>
8000b3a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b3a6:	0a 9c       	mov	r12,r5
8000b3a8:	ca ce       	rcall	8000b100 <_free_r>
8000b3aa:	30 c8       	mov	r8,12
8000b3ac:	8b 38       	st.w	r5[0xc],r8
8000b3ae:	cb 18       	rjmp	8000b510 <__sfvwrite_r+0x284>
8000b3b0:	40 0a       	lddsp	r10,sp[0x0]
8000b3b2:	40 09       	lddsp	r9,sp[0x0]
8000b3b4:	e8 0a 01 0a 	sub	r10,r4,r10
8000b3b8:	e4 09 00 08 	add	r8,r2,r9
8000b3bc:	8f 54       	st.w	r7[0x14],r4
8000b3be:	8f 2a       	st.w	r7[0x8],r10
8000b3c0:	8f 08       	st.w	r7[0x0],r8
8000b3c2:	8f 42       	st.w	r7[0x10],r2
8000b3c4:	0c 94       	mov	r4,r6
8000b3c6:	08 36       	cp.w	r6,r4
8000b3c8:	ec 04 17 30 	movlo	r4,r6
8000b3cc:	06 9b       	mov	r11,r3
8000b3ce:	08 9a       	mov	r10,r4
8000b3d0:	6e 0c       	ld.w	r12,r7[0x0]
8000b3d2:	c3 ad       	rcall	8000b646 <memmove>
8000b3d4:	6e 08       	ld.w	r8,r7[0x0]
8000b3d6:	08 08       	add	r8,r4
8000b3d8:	8f 08       	st.w	r7[0x0],r8
8000b3da:	6e 28       	ld.w	r8,r7[0x8]
8000b3dc:	08 18       	sub	r8,r4
8000b3de:	0c 94       	mov	r4,r6
8000b3e0:	8f 28       	st.w	r7[0x8],r8
8000b3e2:	c2 e8       	rjmp	8000b43e <__sfvwrite_r+0x1b2>
8000b3e4:	08 36       	cp.w	r6,r4
8000b3e6:	5f ba       	srhi	r10
8000b3e8:	6e 0c       	ld.w	r12,r7[0x0]
8000b3ea:	6e 48       	ld.w	r8,r7[0x10]
8000b3ec:	10 3c       	cp.w	r12,r8
8000b3ee:	5f b8       	srhi	r8
8000b3f0:	f5 e8 00 08 	and	r8,r10,r8
8000b3f4:	f2 08 18 00 	cp.b	r8,r9
8000b3f8:	c0 d0       	breq	8000b412 <__sfvwrite_r+0x186>
8000b3fa:	06 9b       	mov	r11,r3
8000b3fc:	08 9a       	mov	r10,r4
8000b3fe:	c2 4d       	rcall	8000b646 <memmove>
8000b400:	6e 08       	ld.w	r8,r7[0x0]
8000b402:	08 08       	add	r8,r4
8000b404:	0e 9b       	mov	r11,r7
8000b406:	8f 08       	st.w	r7[0x0],r8
8000b408:	0a 9c       	mov	r12,r5
8000b40a:	fe b0 fd 09 	rcall	8000ae1c <_fflush_r>
8000b40e:	c1 80       	breq	8000b43e <__sfvwrite_r+0x1b2>
8000b410:	c8 08       	rjmp	8000b510 <__sfvwrite_r+0x284>
8000b412:	6e 59       	ld.w	r9,r7[0x14]
8000b414:	12 36       	cp.w	r6,r9
8000b416:	c0 a3       	brcs	8000b42a <__sfvwrite_r+0x19e>
8000b418:	6e a8       	ld.w	r8,r7[0x28]
8000b41a:	06 9a       	mov	r10,r3
8000b41c:	6e 8b       	ld.w	r11,r7[0x20]
8000b41e:	0a 9c       	mov	r12,r5
8000b420:	5d 18       	icall	r8
8000b422:	18 94       	mov	r4,r12
8000b424:	e0 89 00 0d 	brgt	8000b43e <__sfvwrite_r+0x1b2>
8000b428:	c7 48       	rjmp	8000b510 <__sfvwrite_r+0x284>
8000b42a:	0c 9a       	mov	r10,r6
8000b42c:	06 9b       	mov	r11,r3
8000b42e:	c0 cd       	rcall	8000b646 <memmove>
8000b430:	6e 08       	ld.w	r8,r7[0x0]
8000b432:	0c 08       	add	r8,r6
8000b434:	0c 94       	mov	r4,r6
8000b436:	8f 08       	st.w	r7[0x0],r8
8000b438:	6e 28       	ld.w	r8,r7[0x8]
8000b43a:	0c 18       	sub	r8,r6
8000b43c:	8f 28       	st.w	r7[0x8],r8
8000b43e:	62 28       	ld.w	r8,r1[0x8]
8000b440:	08 18       	sub	r8,r4
8000b442:	83 28       	st.w	r1[0x8],r8
8000b444:	c6 b0       	breq	8000b51a <__sfvwrite_r+0x28e>
8000b446:	08 16       	sub	r6,r4
8000b448:	08 03       	add	r3,r4
8000b44a:	c7 1b       	rjmp	8000b32c <__sfvwrite_r+0xa0>
8000b44c:	60 03       	ld.w	r3,r0[0x0]
8000b44e:	60 11       	ld.w	r1,r0[0x4]
8000b450:	30 08       	mov	r8,0
8000b452:	2f 80       	sub	r0,-8
8000b454:	50 08       	stdsp	sp[0x0],r8
8000b456:	58 01       	cp.w	r1,0
8000b458:	cf a0       	breq	8000b44c <__sfvwrite_r+0x1c0>
8000b45a:	40 0a       	lddsp	r10,sp[0x0]
8000b45c:	58 0a       	cp.w	r10,0
8000b45e:	c1 41       	brne	8000b486 <__sfvwrite_r+0x1fa>
8000b460:	e2 c6 ff ff 	sub	r6,r1,-1
8000b464:	02 9a       	mov	r10,r1
8000b466:	30 ab       	mov	r11,10
8000b468:	06 9c       	mov	r12,r3
8000b46a:	ce 3c       	rcall	8000b630 <memchr>
8000b46c:	f8 c8 ff ff 	sub	r8,r12,-1
8000b470:	58 0c       	cp.w	r12,0
8000b472:	f1 d3 e1 16 	subne	r6,r8,r3
8000b476:	f9 b9 01 01 	movne	r9,1
8000b47a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b47e:	f9 b8 00 01 	moveq	r8,1
8000b482:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b486:	02 36       	cp.w	r6,r1
8000b488:	ec 04 17 80 	movls	r4,r6
8000b48c:	e2 04 17 b0 	movhi	r4,r1
8000b490:	6e 59       	ld.w	r9,r7[0x14]
8000b492:	6e 25       	ld.w	r5,r7[0x8]
8000b494:	f2 05 00 05 	add	r5,r9,r5
8000b498:	0a 34       	cp.w	r4,r5
8000b49a:	5f 9a       	srgt	r10
8000b49c:	6e 0c       	ld.w	r12,r7[0x0]
8000b49e:	6e 48       	ld.w	r8,r7[0x10]
8000b4a0:	10 3c       	cp.w	r12,r8
8000b4a2:	5f b8       	srhi	r8
8000b4a4:	f5 e8 00 08 	and	r8,r10,r8
8000b4a8:	30 0a       	mov	r10,0
8000b4aa:	f4 08 18 00 	cp.b	r8,r10
8000b4ae:	c0 d0       	breq	8000b4c8 <__sfvwrite_r+0x23c>
8000b4b0:	06 9b       	mov	r11,r3
8000b4b2:	0a 9a       	mov	r10,r5
8000b4b4:	cc 9c       	rcall	8000b646 <memmove>
8000b4b6:	6e 08       	ld.w	r8,r7[0x0]
8000b4b8:	0a 08       	add	r8,r5
8000b4ba:	0e 9b       	mov	r11,r7
8000b4bc:	8f 08       	st.w	r7[0x0],r8
8000b4be:	40 1c       	lddsp	r12,sp[0x4]
8000b4c0:	fe b0 fc ae 	rcall	8000ae1c <_fflush_r>
8000b4c4:	c1 70       	breq	8000b4f2 <__sfvwrite_r+0x266>
8000b4c6:	c2 58       	rjmp	8000b510 <__sfvwrite_r+0x284>
8000b4c8:	12 34       	cp.w	r4,r9
8000b4ca:	c0 a5       	brlt	8000b4de <__sfvwrite_r+0x252>
8000b4cc:	6e a8       	ld.w	r8,r7[0x28]
8000b4ce:	06 9a       	mov	r10,r3
8000b4d0:	6e 8b       	ld.w	r11,r7[0x20]
8000b4d2:	40 1c       	lddsp	r12,sp[0x4]
8000b4d4:	5d 18       	icall	r8
8000b4d6:	18 95       	mov	r5,r12
8000b4d8:	e0 89 00 0d 	brgt	8000b4f2 <__sfvwrite_r+0x266>
8000b4dc:	c1 a8       	rjmp	8000b510 <__sfvwrite_r+0x284>
8000b4de:	08 9a       	mov	r10,r4
8000b4e0:	06 9b       	mov	r11,r3
8000b4e2:	cb 2c       	rcall	8000b646 <memmove>
8000b4e4:	6e 08       	ld.w	r8,r7[0x0]
8000b4e6:	08 08       	add	r8,r4
8000b4e8:	08 95       	mov	r5,r4
8000b4ea:	8f 08       	st.w	r7[0x0],r8
8000b4ec:	6e 28       	ld.w	r8,r7[0x8]
8000b4ee:	08 18       	sub	r8,r4
8000b4f0:	8f 28       	st.w	r7[0x8],r8
8000b4f2:	0a 16       	sub	r6,r5
8000b4f4:	c0 71       	brne	8000b502 <__sfvwrite_r+0x276>
8000b4f6:	0e 9b       	mov	r11,r7
8000b4f8:	40 1c       	lddsp	r12,sp[0x4]
8000b4fa:	fe b0 fc 91 	rcall	8000ae1c <_fflush_r>
8000b4fe:	c0 91       	brne	8000b510 <__sfvwrite_r+0x284>
8000b500:	50 06       	stdsp	sp[0x0],r6
8000b502:	64 28       	ld.w	r8,r2[0x8]
8000b504:	0a 18       	sub	r8,r5
8000b506:	85 28       	st.w	r2[0x8],r8
8000b508:	c0 90       	breq	8000b51a <__sfvwrite_r+0x28e>
8000b50a:	0a 11       	sub	r1,r5
8000b50c:	0a 03       	add	r3,r5
8000b50e:	ca 4b       	rjmp	8000b456 <__sfvwrite_r+0x1ca>
8000b510:	8e 68       	ld.sh	r8,r7[0xc]
8000b512:	a7 a8       	sbr	r8,0x6
8000b514:	ae 68       	st.h	r7[0xc],r8
8000b516:	3f fc       	mov	r12,-1
8000b518:	c0 28       	rjmp	8000b51c <__sfvwrite_r+0x290>
8000b51a:	30 0c       	mov	r12,0
8000b51c:	2f dd       	sub	sp,-12
8000b51e:	d8 32       	popm	r0-r7,pc

8000b520 <_fwalk>:
8000b520:	d4 31       	pushm	r0-r7,lr
8000b522:	30 05       	mov	r5,0
8000b524:	16 91       	mov	r1,r11
8000b526:	f8 c7 ff 28 	sub	r7,r12,-216
8000b52a:	0a 92       	mov	r2,r5
8000b52c:	fe b0 fc fe 	rcall	8000af28 <__sfp_lock_acquire>
8000b530:	3f f3       	mov	r3,-1
8000b532:	c1 68       	rjmp	8000b55e <_fwalk+0x3e>
8000b534:	6e 26       	ld.w	r6,r7[0x8]
8000b536:	6e 14       	ld.w	r4,r7[0x4]
8000b538:	2f 46       	sub	r6,-12
8000b53a:	c0 c8       	rjmp	8000b552 <_fwalk+0x32>
8000b53c:	8c 08       	ld.sh	r8,r6[0x0]
8000b53e:	e4 08 19 00 	cp.h	r8,r2
8000b542:	c0 70       	breq	8000b550 <_fwalk+0x30>
8000b544:	8c 18       	ld.sh	r8,r6[0x2]
8000b546:	e6 08 19 00 	cp.h	r8,r3
8000b54a:	c0 30       	breq	8000b550 <_fwalk+0x30>
8000b54c:	5d 11       	icall	r1
8000b54e:	18 45       	or	r5,r12
8000b550:	2a 46       	sub	r6,-92
8000b552:	20 14       	sub	r4,1
8000b554:	ec cc 00 0c 	sub	r12,r6,12
8000b558:	58 04       	cp.w	r4,0
8000b55a:	cf 14       	brge	8000b53c <_fwalk+0x1c>
8000b55c:	6e 07       	ld.w	r7,r7[0x0]
8000b55e:	58 07       	cp.w	r7,0
8000b560:	ce a1       	brne	8000b534 <_fwalk+0x14>
8000b562:	fe b0 fc e4 	rcall	8000af2a <__sfp_lock_release>
8000b566:	0a 9c       	mov	r12,r5
8000b568:	d8 32       	popm	r0-r7,pc
8000b56a:	d7 03       	nop

8000b56c <_localeconv_r>:
8000b56c:	fe cc d3 ec 	sub	r12,pc,-11284
8000b570:	5e fc       	retal	r12
8000b572:	d7 03       	nop

8000b574 <__smakebuf_r>:
8000b574:	d4 21       	pushm	r4-r7,lr
8000b576:	20 fd       	sub	sp,60
8000b578:	96 68       	ld.sh	r8,r11[0xc]
8000b57a:	16 97       	mov	r7,r11
8000b57c:	18 96       	mov	r6,r12
8000b57e:	e2 18 00 02 	andl	r8,0x2,COH
8000b582:	c3 d1       	brne	8000b5fc <__smakebuf_r+0x88>
8000b584:	96 7b       	ld.sh	r11,r11[0xe]
8000b586:	f0 0b 19 00 	cp.h	r11,r8
8000b58a:	c0 55       	brlt	8000b594 <__smakebuf_r+0x20>
8000b58c:	1a 9a       	mov	r10,sp
8000b58e:	e0 a0 04 81 	rcall	8000be90 <_fstat_r>
8000b592:	c0 f4       	brge	8000b5b0 <__smakebuf_r+0x3c>
8000b594:	8e 65       	ld.sh	r5,r7[0xc]
8000b596:	0a 98       	mov	r8,r5
8000b598:	ab b8       	sbr	r8,0xb
8000b59a:	e2 15 00 80 	andl	r5,0x80,COH
8000b59e:	ae 68       	st.h	r7[0xc],r8
8000b5a0:	30 04       	mov	r4,0
8000b5a2:	e0 68 04 00 	mov	r8,1024
8000b5a6:	f9 b5 01 40 	movne	r5,64
8000b5aa:	f0 05 17 00 	moveq	r5,r8
8000b5ae:	c1 c8       	rjmp	8000b5e6 <__smakebuf_r+0x72>
8000b5b0:	40 18       	lddsp	r8,sp[0x4]
8000b5b2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b5b6:	e0 48 20 00 	cp.w	r8,8192
8000b5ba:	5f 04       	sreq	r4
8000b5bc:	e0 48 80 00 	cp.w	r8,32768
8000b5c0:	c0 e1       	brne	8000b5dc <__smakebuf_r+0x68>
8000b5c2:	6e b9       	ld.w	r9,r7[0x2c]
8000b5c4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b5c8:	10 39       	cp.w	r9,r8
8000b5ca:	c0 91       	brne	8000b5dc <__smakebuf_r+0x68>
8000b5cc:	8e 68       	ld.sh	r8,r7[0xc]
8000b5ce:	e0 65 04 00 	mov	r5,1024
8000b5d2:	ab a8       	sbr	r8,0xa
8000b5d4:	ef 45 00 50 	st.w	r7[80],r5
8000b5d8:	ae 68       	st.h	r7[0xc],r8
8000b5da:	c0 68       	rjmp	8000b5e6 <__smakebuf_r+0x72>
8000b5dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b5de:	e0 65 04 00 	mov	r5,1024
8000b5e2:	ab b8       	sbr	r8,0xb
8000b5e4:	ae 68       	st.h	r7[0xc],r8
8000b5e6:	0a 9b       	mov	r11,r5
8000b5e8:	0c 9c       	mov	r12,r6
8000b5ea:	fe b0 df 35 	rcall	80007454 <_malloc_r>
8000b5ee:	8e 68       	ld.sh	r8,r7[0xc]
8000b5f0:	c0 d1       	brne	8000b60a <__smakebuf_r+0x96>
8000b5f2:	ed b8 00 09 	bld	r8,0x9
8000b5f6:	c1 b0       	breq	8000b62c <__smakebuf_r+0xb8>
8000b5f8:	a1 b8       	sbr	r8,0x1
8000b5fa:	ae 68       	st.h	r7[0xc],r8
8000b5fc:	ee c8 ff b9 	sub	r8,r7,-71
8000b600:	8f 48       	st.w	r7[0x10],r8
8000b602:	8f 08       	st.w	r7[0x0],r8
8000b604:	30 18       	mov	r8,1
8000b606:	8f 58       	st.w	r7[0x14],r8
8000b608:	c1 28       	rjmp	8000b62c <__smakebuf_r+0xb8>
8000b60a:	a7 b8       	sbr	r8,0x7
8000b60c:	8f 4c       	st.w	r7[0x10],r12
8000b60e:	ae 68       	st.h	r7[0xc],r8
8000b610:	8f 55       	st.w	r7[0x14],r5
8000b612:	fe c8 06 e6 	sub	r8,pc,1766
8000b616:	8f 0c       	st.w	r7[0x0],r12
8000b618:	8d a8       	st.w	r6[0x28],r8
8000b61a:	58 04       	cp.w	r4,0
8000b61c:	c0 80       	breq	8000b62c <__smakebuf_r+0xb8>
8000b61e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b620:	fe b0 e3 94 	rcall	80007d48 <isatty>
8000b624:	c0 40       	breq	8000b62c <__smakebuf_r+0xb8>
8000b626:	8e 68       	ld.sh	r8,r7[0xc]
8000b628:	a1 a8       	sbr	r8,0x0
8000b62a:	ae 68       	st.h	r7[0xc],r8
8000b62c:	2f 1d       	sub	sp,-60
8000b62e:	d8 22       	popm	r4-r7,pc

8000b630 <memchr>:
8000b630:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b634:	c0 68       	rjmp	8000b640 <memchr+0x10>
8000b636:	20 1a       	sub	r10,1
8000b638:	19 88       	ld.ub	r8,r12[0x0]
8000b63a:	16 38       	cp.w	r8,r11
8000b63c:	5e 0c       	reteq	r12
8000b63e:	2f fc       	sub	r12,-1
8000b640:	58 0a       	cp.w	r10,0
8000b642:	cf a1       	brne	8000b636 <memchr+0x6>
8000b644:	5e fa       	retal	r10

8000b646 <memmove>:
8000b646:	d4 01       	pushm	lr
8000b648:	18 3b       	cp.w	r11,r12
8000b64a:	c1 92       	brcc	8000b67c <memmove+0x36>
8000b64c:	f6 0a 00 09 	add	r9,r11,r10
8000b650:	12 3c       	cp.w	r12,r9
8000b652:	c1 52       	brcc	8000b67c <memmove+0x36>
8000b654:	f8 0a 00 0b 	add	r11,r12,r10
8000b658:	30 08       	mov	r8,0
8000b65a:	c0 68       	rjmp	8000b666 <memmove+0x20>
8000b65c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b660:	20 1a       	sub	r10,1
8000b662:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b666:	20 18       	sub	r8,1
8000b668:	58 0a       	cp.w	r10,0
8000b66a:	cf 91       	brne	8000b65c <memmove+0x16>
8000b66c:	d8 02       	popm	pc
8000b66e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b672:	20 1a       	sub	r10,1
8000b674:	f8 08 0b 09 	st.b	r12[r8],r9
8000b678:	2f f8       	sub	r8,-1
8000b67a:	c0 28       	rjmp	8000b67e <memmove+0x38>
8000b67c:	30 08       	mov	r8,0
8000b67e:	58 0a       	cp.w	r10,0
8000b680:	cf 71       	brne	8000b66e <memmove+0x28>
8000b682:	d8 02       	popm	pc

8000b684 <__hi0bits>:
8000b684:	18 98       	mov	r8,r12
8000b686:	e0 1c 00 00 	andl	r12,0x0
8000b68a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b68e:	58 0c       	cp.w	r12,0
8000b690:	f2 08 17 00 	moveq	r8,r9
8000b694:	f9 bc 00 10 	moveq	r12,16
8000b698:	f9 bc 01 00 	movne	r12,0
8000b69c:	10 9a       	mov	r10,r8
8000b69e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b6a2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b6a6:	f7 bc 00 f8 	subeq	r12,-8
8000b6aa:	f2 08 17 00 	moveq	r8,r9
8000b6ae:	10 9a       	mov	r10,r8
8000b6b0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b6b4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b6b8:	f7 bc 00 fc 	subeq	r12,-4
8000b6bc:	f2 08 17 00 	moveq	r8,r9
8000b6c0:	10 9a       	mov	r10,r8
8000b6c2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b6c6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b6ca:	f7 bc 00 fe 	subeq	r12,-2
8000b6ce:	f2 08 17 00 	moveq	r8,r9
8000b6d2:	58 08       	cp.w	r8,0
8000b6d4:	5e 5c       	retlt	r12
8000b6d6:	ed b8 00 1e 	bld	r8,0x1e
8000b6da:	f9 bc 01 20 	movne	r12,32
8000b6de:	f7 bc 00 ff 	subeq	r12,-1
8000b6e2:	5e fc       	retal	r12

8000b6e4 <__lo0bits>:
8000b6e4:	18 99       	mov	r9,r12
8000b6e6:	78 08       	ld.w	r8,r12[0x0]
8000b6e8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6ec:	c1 50       	breq	8000b716 <__lo0bits+0x32>
8000b6ee:	ed b8 00 00 	bld	r8,0x0
8000b6f2:	c0 21       	brne	8000b6f6 <__lo0bits+0x12>
8000b6f4:	5e fd       	retal	0
8000b6f6:	10 9b       	mov	r11,r8
8000b6f8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b6fc:	e2 1b 00 02 	andl	r11,0x2,COH
8000b700:	a3 88       	lsr	r8,0x2
8000b702:	58 0b       	cp.w	r11,0
8000b704:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b708:	f9 bc 01 01 	movne	r12,1
8000b70c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b710:	f9 bc 00 02 	moveq	r12,2
8000b714:	5e fc       	retal	r12
8000b716:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b71a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b71e:	58 0a       	cp.w	r10,0
8000b720:	f6 08 17 00 	moveq	r8,r11
8000b724:	f9 bc 00 10 	moveq	r12,16
8000b728:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b72c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b730:	58 0b       	cp.w	r11,0
8000b732:	f7 bc 00 f8 	subeq	r12,-8
8000b736:	f4 08 17 00 	moveq	r8,r10
8000b73a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b73e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b742:	58 0b       	cp.w	r11,0
8000b744:	f7 bc 00 fc 	subeq	r12,-4
8000b748:	f4 08 17 00 	moveq	r8,r10
8000b74c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b750:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b754:	58 0b       	cp.w	r11,0
8000b756:	f7 bc 00 fe 	subeq	r12,-2
8000b75a:	f4 08 17 00 	moveq	r8,r10
8000b75e:	ed b8 00 00 	bld	r8,0x0
8000b762:	c0 60       	breq	8000b76e <__lo0bits+0x8a>
8000b764:	a1 98       	lsr	r8,0x1
8000b766:	c0 31       	brne	8000b76c <__lo0bits+0x88>
8000b768:	32 0c       	mov	r12,32
8000b76a:	5e fc       	retal	r12
8000b76c:	2f fc       	sub	r12,-1
8000b76e:	93 08       	st.w	r9[0x0],r8
8000b770:	5e fc       	retal	r12

8000b772 <__mcmp>:
8000b772:	d4 01       	pushm	lr
8000b774:	18 98       	mov	r8,r12
8000b776:	76 49       	ld.w	r9,r11[0x10]
8000b778:	78 4c       	ld.w	r12,r12[0x10]
8000b77a:	12 1c       	sub	r12,r9
8000b77c:	c1 31       	brne	8000b7a2 <__mcmp+0x30>
8000b77e:	2f b9       	sub	r9,-5
8000b780:	a3 69       	lsl	r9,0x2
8000b782:	12 0b       	add	r11,r9
8000b784:	f0 09 00 09 	add	r9,r8,r9
8000b788:	2e c8       	sub	r8,-20
8000b78a:	13 4e       	ld.w	lr,--r9
8000b78c:	17 4a       	ld.w	r10,--r11
8000b78e:	14 3e       	cp.w	lr,r10
8000b790:	c0 60       	breq	8000b79c <__mcmp+0x2a>
8000b792:	f9 bc 03 ff 	movlo	r12,-1
8000b796:	f9 bc 02 01 	movhs	r12,1
8000b79a:	d8 02       	popm	pc
8000b79c:	10 39       	cp.w	r9,r8
8000b79e:	fe 9b ff f6 	brhi	8000b78a <__mcmp+0x18>
8000b7a2:	d8 02       	popm	pc

8000b7a4 <_Bfree>:
8000b7a4:	d4 21       	pushm	r4-r7,lr
8000b7a6:	18 97       	mov	r7,r12
8000b7a8:	16 95       	mov	r5,r11
8000b7aa:	78 96       	ld.w	r6,r12[0x24]
8000b7ac:	58 06       	cp.w	r6,0
8000b7ae:	c0 91       	brne	8000b7c0 <_Bfree+0x1c>
8000b7b0:	31 0c       	mov	r12,16
8000b7b2:	fe b0 de 49 	rcall	80007444 <malloc>
8000b7b6:	99 36       	st.w	r12[0xc],r6
8000b7b8:	8f 9c       	st.w	r7[0x24],r12
8000b7ba:	99 16       	st.w	r12[0x4],r6
8000b7bc:	99 26       	st.w	r12[0x8],r6
8000b7be:	99 06       	st.w	r12[0x0],r6
8000b7c0:	58 05       	cp.w	r5,0
8000b7c2:	c0 90       	breq	8000b7d4 <_Bfree+0x30>
8000b7c4:	6a 19       	ld.w	r9,r5[0x4]
8000b7c6:	6e 98       	ld.w	r8,r7[0x24]
8000b7c8:	70 38       	ld.w	r8,r8[0xc]
8000b7ca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b7ce:	8b 0a       	st.w	r5[0x0],r10
8000b7d0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b7d4:	d8 22       	popm	r4-r7,pc
8000b7d6:	d7 03       	nop

8000b7d8 <_Balloc>:
8000b7d8:	d4 21       	pushm	r4-r7,lr
8000b7da:	18 97       	mov	r7,r12
8000b7dc:	16 96       	mov	r6,r11
8000b7de:	78 95       	ld.w	r5,r12[0x24]
8000b7e0:	58 05       	cp.w	r5,0
8000b7e2:	c0 91       	brne	8000b7f4 <_Balloc+0x1c>
8000b7e4:	31 0c       	mov	r12,16
8000b7e6:	fe b0 de 2f 	rcall	80007444 <malloc>
8000b7ea:	99 35       	st.w	r12[0xc],r5
8000b7ec:	8f 9c       	st.w	r7[0x24],r12
8000b7ee:	99 15       	st.w	r12[0x4],r5
8000b7f0:	99 25       	st.w	r12[0x8],r5
8000b7f2:	99 05       	st.w	r12[0x0],r5
8000b7f4:	6e 95       	ld.w	r5,r7[0x24]
8000b7f6:	6a 38       	ld.w	r8,r5[0xc]
8000b7f8:	58 08       	cp.w	r8,0
8000b7fa:	c0 b1       	brne	8000b810 <_Balloc+0x38>
8000b7fc:	31 0a       	mov	r10,16
8000b7fe:	30 4b       	mov	r11,4
8000b800:	0e 9c       	mov	r12,r7
8000b802:	e0 a0 02 a7 	rcall	8000bd50 <_calloc_r>
8000b806:	8b 3c       	st.w	r5[0xc],r12
8000b808:	6e 98       	ld.w	r8,r7[0x24]
8000b80a:	70 3c       	ld.w	r12,r8[0xc]
8000b80c:	58 0c       	cp.w	r12,0
8000b80e:	c1 b0       	breq	8000b844 <_Balloc+0x6c>
8000b810:	6e 98       	ld.w	r8,r7[0x24]
8000b812:	70 38       	ld.w	r8,r8[0xc]
8000b814:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b818:	70 0c       	ld.w	r12,r8[0x0]
8000b81a:	58 0c       	cp.w	r12,0
8000b81c:	c0 40       	breq	8000b824 <_Balloc+0x4c>
8000b81e:	78 09       	ld.w	r9,r12[0x0]
8000b820:	91 09       	st.w	r8[0x0],r9
8000b822:	c0 e8       	rjmp	8000b83e <_Balloc+0x66>
8000b824:	0e 9c       	mov	r12,r7
8000b826:	30 17       	mov	r7,1
8000b828:	0e 9b       	mov	r11,r7
8000b82a:	ee 06 09 47 	lsl	r7,r7,r6
8000b82e:	ee ca ff fb 	sub	r10,r7,-5
8000b832:	a3 6a       	lsl	r10,0x2
8000b834:	e0 a0 02 8e 	rcall	8000bd50 <_calloc_r>
8000b838:	c0 60       	breq	8000b844 <_Balloc+0x6c>
8000b83a:	99 16       	st.w	r12[0x4],r6
8000b83c:	99 27       	st.w	r12[0x8],r7
8000b83e:	30 08       	mov	r8,0
8000b840:	99 38       	st.w	r12[0xc],r8
8000b842:	99 48       	st.w	r12[0x10],r8
8000b844:	d8 22       	popm	r4-r7,pc
8000b846:	d7 03       	nop

8000b848 <__d2b>:
8000b848:	d4 31       	pushm	r0-r7,lr
8000b84a:	20 2d       	sub	sp,8
8000b84c:	16 93       	mov	r3,r11
8000b84e:	12 96       	mov	r6,r9
8000b850:	10 95       	mov	r5,r8
8000b852:	14 92       	mov	r2,r10
8000b854:	30 1b       	mov	r11,1
8000b856:	cc 1f       	rcall	8000b7d8 <_Balloc>
8000b858:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b85c:	50 09       	stdsp	sp[0x0],r9
8000b85e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b862:	b5 a9       	sbr	r9,0x14
8000b864:	f0 01 16 14 	lsr	r1,r8,0x14
8000b868:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b86c:	18 94       	mov	r4,r12
8000b86e:	58 02       	cp.w	r2,0
8000b870:	c1 d0       	breq	8000b8aa <__d2b+0x62>
8000b872:	fa cc ff f8 	sub	r12,sp,-8
8000b876:	18 d2       	st.w	--r12,r2
8000b878:	c3 6f       	rcall	8000b6e4 <__lo0bits>
8000b87a:	40 18       	lddsp	r8,sp[0x4]
8000b87c:	c0 d0       	breq	8000b896 <__d2b+0x4e>
8000b87e:	40 09       	lddsp	r9,sp[0x0]
8000b880:	f8 0a 11 20 	rsub	r10,r12,32
8000b884:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b888:	f5 e8 10 08 	or	r8,r10,r8
8000b88c:	89 58       	st.w	r4[0x14],r8
8000b88e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b892:	50 09       	stdsp	sp[0x0],r9
8000b894:	c0 28       	rjmp	8000b898 <__d2b+0x50>
8000b896:	89 58       	st.w	r4[0x14],r8
8000b898:	40 08       	lddsp	r8,sp[0x0]
8000b89a:	58 08       	cp.w	r8,0
8000b89c:	f9 b3 01 02 	movne	r3,2
8000b8a0:	f9 b3 00 01 	moveq	r3,1
8000b8a4:	89 68       	st.w	r4[0x18],r8
8000b8a6:	89 43       	st.w	r4[0x10],r3
8000b8a8:	c0 88       	rjmp	8000b8b8 <__d2b+0x70>
8000b8aa:	1a 9c       	mov	r12,sp
8000b8ac:	c1 cf       	rcall	8000b6e4 <__lo0bits>
8000b8ae:	30 13       	mov	r3,1
8000b8b0:	40 08       	lddsp	r8,sp[0x0]
8000b8b2:	2e 0c       	sub	r12,-32
8000b8b4:	89 43       	st.w	r4[0x10],r3
8000b8b6:	89 58       	st.w	r4[0x14],r8
8000b8b8:	58 01       	cp.w	r1,0
8000b8ba:	c0 90       	breq	8000b8cc <__d2b+0x84>
8000b8bc:	e2 c1 04 33 	sub	r1,r1,1075
8000b8c0:	18 01       	add	r1,r12
8000b8c2:	8d 01       	st.w	r6[0x0],r1
8000b8c4:	f8 0c 11 35 	rsub	r12,r12,53
8000b8c8:	8b 0c       	st.w	r5[0x0],r12
8000b8ca:	c0 c8       	rjmp	8000b8e2 <__d2b+0x9a>
8000b8cc:	e6 c8 ff fc 	sub	r8,r3,-4
8000b8d0:	f8 cc 04 32 	sub	r12,r12,1074
8000b8d4:	a5 73       	lsl	r3,0x5
8000b8d6:	8d 0c       	st.w	r6[0x0],r12
8000b8d8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b8dc:	cd 4e       	rcall	8000b684 <__hi0bits>
8000b8de:	18 13       	sub	r3,r12
8000b8e0:	8b 03       	st.w	r5[0x0],r3
8000b8e2:	08 9c       	mov	r12,r4
8000b8e4:	2f ed       	sub	sp,-8
8000b8e6:	d8 32       	popm	r0-r7,pc

8000b8e8 <__mdiff>:
8000b8e8:	d4 31       	pushm	r0-r7,lr
8000b8ea:	74 48       	ld.w	r8,r10[0x10]
8000b8ec:	76 45       	ld.w	r5,r11[0x10]
8000b8ee:	16 97       	mov	r7,r11
8000b8f0:	14 96       	mov	r6,r10
8000b8f2:	10 15       	sub	r5,r8
8000b8f4:	c1 31       	brne	8000b91a <__mdiff+0x32>
8000b8f6:	2f b8       	sub	r8,-5
8000b8f8:	ee ce ff ec 	sub	lr,r7,-20
8000b8fc:	a3 68       	lsl	r8,0x2
8000b8fe:	f4 08 00 0b 	add	r11,r10,r8
8000b902:	ee 08 00 08 	add	r8,r7,r8
8000b906:	11 4a       	ld.w	r10,--r8
8000b908:	17 49       	ld.w	r9,--r11
8000b90a:	12 3a       	cp.w	r10,r9
8000b90c:	c0 30       	breq	8000b912 <__mdiff+0x2a>
8000b90e:	c0 e2       	brcc	8000b92a <__mdiff+0x42>
8000b910:	c0 78       	rjmp	8000b91e <__mdiff+0x36>
8000b912:	1c 38       	cp.w	r8,lr
8000b914:	fe 9b ff f9 	brhi	8000b906 <__mdiff+0x1e>
8000b918:	c4 98       	rjmp	8000b9aa <__mdiff+0xc2>
8000b91a:	58 05       	cp.w	r5,0
8000b91c:	c0 64       	brge	8000b928 <__mdiff+0x40>
8000b91e:	0e 98       	mov	r8,r7
8000b920:	30 15       	mov	r5,1
8000b922:	0c 97       	mov	r7,r6
8000b924:	10 96       	mov	r6,r8
8000b926:	c0 28       	rjmp	8000b92a <__mdiff+0x42>
8000b928:	30 05       	mov	r5,0
8000b92a:	6e 1b       	ld.w	r11,r7[0x4]
8000b92c:	c5 6f       	rcall	8000b7d8 <_Balloc>
8000b92e:	6e 49       	ld.w	r9,r7[0x10]
8000b930:	6c 44       	ld.w	r4,r6[0x10]
8000b932:	99 35       	st.w	r12[0xc],r5
8000b934:	2f b4       	sub	r4,-5
8000b936:	f2 c5 ff fb 	sub	r5,r9,-5
8000b93a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b93e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b942:	2e c6       	sub	r6,-20
8000b944:	2e c7       	sub	r7,-20
8000b946:	f8 c8 ff ec 	sub	r8,r12,-20
8000b94a:	30 0a       	mov	r10,0
8000b94c:	0f 0e       	ld.w	lr,r7++
8000b94e:	0d 0b       	ld.w	r11,r6++
8000b950:	fc 02 16 10 	lsr	r2,lr,0x10
8000b954:	f6 03 16 10 	lsr	r3,r11,0x10
8000b958:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b95c:	e4 03 01 03 	sub	r3,r2,r3
8000b960:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b964:	fc 0b 01 0b 	sub	r11,lr,r11
8000b968:	f6 0a 00 0a 	add	r10,r11,r10
8000b96c:	b0 1a       	st.h	r8[0x2],r10
8000b96e:	b1 4a       	asr	r10,0x10
8000b970:	e6 0a 00 0a 	add	r10,r3,r10
8000b974:	b0 0a       	st.h	r8[0x0],r10
8000b976:	2f c8       	sub	r8,-4
8000b978:	b1 4a       	asr	r10,0x10
8000b97a:	08 36       	cp.w	r6,r4
8000b97c:	ce 83       	brcs	8000b94c <__mdiff+0x64>
8000b97e:	c0 d8       	rjmp	8000b998 <__mdiff+0xb0>
8000b980:	0f 0b       	ld.w	r11,r7++
8000b982:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b986:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b98a:	16 0a       	add	r10,r11
8000b98c:	b0 1a       	st.h	r8[0x2],r10
8000b98e:	b1 4a       	asr	r10,0x10
8000b990:	1c 0a       	add	r10,lr
8000b992:	b0 0a       	st.h	r8[0x0],r10
8000b994:	2f c8       	sub	r8,-4
8000b996:	b1 4a       	asr	r10,0x10
8000b998:	0a 37       	cp.w	r7,r5
8000b99a:	cf 33       	brcs	8000b980 <__mdiff+0x98>
8000b99c:	c0 28       	rjmp	8000b9a0 <__mdiff+0xb8>
8000b99e:	20 19       	sub	r9,1
8000b9a0:	11 4a       	ld.w	r10,--r8
8000b9a2:	58 0a       	cp.w	r10,0
8000b9a4:	cf d0       	breq	8000b99e <__mdiff+0xb6>
8000b9a6:	99 49       	st.w	r12[0x10],r9
8000b9a8:	d8 32       	popm	r0-r7,pc
8000b9aa:	30 0b       	mov	r11,0
8000b9ac:	c1 6f       	rcall	8000b7d8 <_Balloc>
8000b9ae:	30 18       	mov	r8,1
8000b9b0:	99 48       	st.w	r12[0x10],r8
8000b9b2:	30 08       	mov	r8,0
8000b9b4:	99 58       	st.w	r12[0x14],r8
8000b9b6:	d8 32       	popm	r0-r7,pc

8000b9b8 <__lshift>:
8000b9b8:	d4 31       	pushm	r0-r7,lr
8000b9ba:	16 97       	mov	r7,r11
8000b9bc:	76 46       	ld.w	r6,r11[0x10]
8000b9be:	f4 02 14 05 	asr	r2,r10,0x5
8000b9c2:	2f f6       	sub	r6,-1
8000b9c4:	14 93       	mov	r3,r10
8000b9c6:	18 94       	mov	r4,r12
8000b9c8:	04 06       	add	r6,r2
8000b9ca:	76 1b       	ld.w	r11,r11[0x4]
8000b9cc:	6e 28       	ld.w	r8,r7[0x8]
8000b9ce:	c0 38       	rjmp	8000b9d4 <__lshift+0x1c>
8000b9d0:	2f fb       	sub	r11,-1
8000b9d2:	a1 78       	lsl	r8,0x1
8000b9d4:	10 36       	cp.w	r6,r8
8000b9d6:	fe 99 ff fd 	brgt	8000b9d0 <__lshift+0x18>
8000b9da:	08 9c       	mov	r12,r4
8000b9dc:	cf ee       	rcall	8000b7d8 <_Balloc>
8000b9de:	30 09       	mov	r9,0
8000b9e0:	18 95       	mov	r5,r12
8000b9e2:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9e6:	12 9a       	mov	r10,r9
8000b9e8:	c0 38       	rjmp	8000b9ee <__lshift+0x36>
8000b9ea:	10 aa       	st.w	r8++,r10
8000b9ec:	2f f9       	sub	r9,-1
8000b9ee:	04 39       	cp.w	r9,r2
8000b9f0:	cf d5       	brlt	8000b9ea <__lshift+0x32>
8000b9f2:	6e 4b       	ld.w	r11,r7[0x10]
8000b9f4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b9f8:	2f bb       	sub	r11,-5
8000b9fa:	ee c9 ff ec 	sub	r9,r7,-20
8000b9fe:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ba02:	58 03       	cp.w	r3,0
8000ba04:	c1 30       	breq	8000ba2a <__lshift+0x72>
8000ba06:	e6 0c 11 20 	rsub	r12,r3,32
8000ba0a:	30 0a       	mov	r10,0
8000ba0c:	72 02       	ld.w	r2,r9[0x0]
8000ba0e:	e4 03 09 42 	lsl	r2,r2,r3
8000ba12:	04 4a       	or	r10,r2
8000ba14:	10 aa       	st.w	r8++,r10
8000ba16:	13 0a       	ld.w	r10,r9++
8000ba18:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba1c:	16 39       	cp.w	r9,r11
8000ba1e:	cf 73       	brcs	8000ba0c <__lshift+0x54>
8000ba20:	91 0a       	st.w	r8[0x0],r10
8000ba22:	58 0a       	cp.w	r10,0
8000ba24:	c0 70       	breq	8000ba32 <__lshift+0x7a>
8000ba26:	2f f6       	sub	r6,-1
8000ba28:	c0 58       	rjmp	8000ba32 <__lshift+0x7a>
8000ba2a:	13 0a       	ld.w	r10,r9++
8000ba2c:	10 aa       	st.w	r8++,r10
8000ba2e:	16 39       	cp.w	r9,r11
8000ba30:	cf d3       	brcs	8000ba2a <__lshift+0x72>
8000ba32:	08 9c       	mov	r12,r4
8000ba34:	20 16       	sub	r6,1
8000ba36:	0e 9b       	mov	r11,r7
8000ba38:	8b 46       	st.w	r5[0x10],r6
8000ba3a:	cb 5e       	rcall	8000b7a4 <_Bfree>
8000ba3c:	0a 9c       	mov	r12,r5
8000ba3e:	d8 32       	popm	r0-r7,pc

8000ba40 <__multiply>:
8000ba40:	d4 31       	pushm	r0-r7,lr
8000ba42:	20 2d       	sub	sp,8
8000ba44:	76 49       	ld.w	r9,r11[0x10]
8000ba46:	74 48       	ld.w	r8,r10[0x10]
8000ba48:	16 96       	mov	r6,r11
8000ba4a:	14 95       	mov	r5,r10
8000ba4c:	10 39       	cp.w	r9,r8
8000ba4e:	ec 08 17 50 	movlt	r8,r6
8000ba52:	ea 06 17 50 	movlt	r6,r5
8000ba56:	f0 05 17 50 	movlt	r5,r8
8000ba5a:	6c 28       	ld.w	r8,r6[0x8]
8000ba5c:	76 43       	ld.w	r3,r11[0x10]
8000ba5e:	74 42       	ld.w	r2,r10[0x10]
8000ba60:	76 1b       	ld.w	r11,r11[0x4]
8000ba62:	e4 03 00 07 	add	r7,r2,r3
8000ba66:	10 37       	cp.w	r7,r8
8000ba68:	f7 bb 09 ff 	subgt	r11,-1
8000ba6c:	cb 6e       	rcall	8000b7d8 <_Balloc>
8000ba6e:	ee c4 ff fb 	sub	r4,r7,-5
8000ba72:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba76:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba7a:	30 0a       	mov	r10,0
8000ba7c:	12 98       	mov	r8,r9
8000ba7e:	c0 28       	rjmp	8000ba82 <__multiply+0x42>
8000ba80:	10 aa       	st.w	r8++,r10
8000ba82:	08 38       	cp.w	r8,r4
8000ba84:	cf e3       	brcs	8000ba80 <__multiply+0x40>
8000ba86:	2f b3       	sub	r3,-5
8000ba88:	2f b2       	sub	r2,-5
8000ba8a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba8e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba92:	ec cb ff ec 	sub	r11,r6,-20
8000ba96:	50 12       	stdsp	sp[0x4],r2
8000ba98:	ea ca ff ec 	sub	r10,r5,-20
8000ba9c:	c4 48       	rjmp	8000bb24 <__multiply+0xe4>
8000ba9e:	94 95       	ld.uh	r5,r10[0x2]
8000baa0:	58 05       	cp.w	r5,0
8000baa2:	c2 00       	breq	8000bae2 <__multiply+0xa2>
8000baa4:	12 98       	mov	r8,r9
8000baa6:	16 96       	mov	r6,r11
8000baa8:	30 0e       	mov	lr,0
8000baaa:	50 09       	stdsp	sp[0x0],r9
8000baac:	0d 02       	ld.w	r2,r6++
8000baae:	e4 00 16 10 	lsr	r0,r2,0x10
8000bab2:	70 01       	ld.w	r1,r8[0x0]
8000bab4:	70 09       	ld.w	r9,r8[0x0]
8000bab6:	b1 81       	lsr	r1,0x10
8000bab8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000babc:	e0 05 03 41 	mac	r1,r0,r5
8000bac0:	ab 32       	mul	r2,r5
8000bac2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bac6:	00 02       	add	r2,r0
8000bac8:	e4 0e 00 0e 	add	lr,r2,lr
8000bacc:	b0 1e       	st.h	r8[0x2],lr
8000bace:	b1 8e       	lsr	lr,0x10
8000bad0:	1c 01       	add	r1,lr
8000bad2:	b0 01       	st.h	r8[0x0],r1
8000bad4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bad8:	2f c8       	sub	r8,-4
8000bada:	06 36       	cp.w	r6,r3
8000badc:	ce 83       	brcs	8000baac <__multiply+0x6c>
8000bade:	40 09       	lddsp	r9,sp[0x0]
8000bae0:	91 0e       	st.w	r8[0x0],lr
8000bae2:	94 86       	ld.uh	r6,r10[0x0]
8000bae4:	58 06       	cp.w	r6,0
8000bae6:	c1 d0       	breq	8000bb20 <__multiply+0xe0>
8000bae8:	72 02       	ld.w	r2,r9[0x0]
8000baea:	12 98       	mov	r8,r9
8000baec:	16 9e       	mov	lr,r11
8000baee:	30 05       	mov	r5,0
8000baf0:	b0 12       	st.h	r8[0x2],r2
8000baf2:	1d 01       	ld.w	r1,lr++
8000baf4:	90 82       	ld.uh	r2,r8[0x0]
8000baf6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bafa:	ad 30       	mul	r0,r6
8000bafc:	e0 02 00 02 	add	r2,r0,r2
8000bb00:	e4 05 00 05 	add	r5,r2,r5
8000bb04:	b0 05       	st.h	r8[0x0],r5
8000bb06:	b1 85       	lsr	r5,0x10
8000bb08:	b1 81       	lsr	r1,0x10
8000bb0a:	2f c8       	sub	r8,-4
8000bb0c:	ad 31       	mul	r1,r6
8000bb0e:	90 92       	ld.uh	r2,r8[0x2]
8000bb10:	e2 02 00 02 	add	r2,r1,r2
8000bb14:	0a 02       	add	r2,r5
8000bb16:	e4 05 16 10 	lsr	r5,r2,0x10
8000bb1a:	06 3e       	cp.w	lr,r3
8000bb1c:	ce a3       	brcs	8000baf0 <__multiply+0xb0>
8000bb1e:	91 02       	st.w	r8[0x0],r2
8000bb20:	2f ca       	sub	r10,-4
8000bb22:	2f c9       	sub	r9,-4
8000bb24:	40 18       	lddsp	r8,sp[0x4]
8000bb26:	10 3a       	cp.w	r10,r8
8000bb28:	cb b3       	brcs	8000ba9e <__multiply+0x5e>
8000bb2a:	c0 28       	rjmp	8000bb2e <__multiply+0xee>
8000bb2c:	20 17       	sub	r7,1
8000bb2e:	58 07       	cp.w	r7,0
8000bb30:	e0 8a 00 05 	brle	8000bb3a <__multiply+0xfa>
8000bb34:	09 48       	ld.w	r8,--r4
8000bb36:	58 08       	cp.w	r8,0
8000bb38:	cf a0       	breq	8000bb2c <__multiply+0xec>
8000bb3a:	99 47       	st.w	r12[0x10],r7
8000bb3c:	2f ed       	sub	sp,-8
8000bb3e:	d8 32       	popm	r0-r7,pc

8000bb40 <__i2b>:
8000bb40:	d4 21       	pushm	r4-r7,lr
8000bb42:	16 97       	mov	r7,r11
8000bb44:	30 1b       	mov	r11,1
8000bb46:	c4 9e       	rcall	8000b7d8 <_Balloc>
8000bb48:	30 19       	mov	r9,1
8000bb4a:	99 57       	st.w	r12[0x14],r7
8000bb4c:	99 49       	st.w	r12[0x10],r9
8000bb4e:	d8 22       	popm	r4-r7,pc

8000bb50 <__multadd>:
8000bb50:	d4 31       	pushm	r0-r7,lr
8000bb52:	30 08       	mov	r8,0
8000bb54:	12 95       	mov	r5,r9
8000bb56:	16 97       	mov	r7,r11
8000bb58:	18 96       	mov	r6,r12
8000bb5a:	76 44       	ld.w	r4,r11[0x10]
8000bb5c:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb60:	72 0b       	ld.w	r11,r9[0x0]
8000bb62:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb66:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb6a:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb6e:	f4 0b 03 45 	mac	r5,r10,r11
8000bb72:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb76:	b1 85       	lsr	r5,0x10
8000bb78:	18 05       	add	r5,r12
8000bb7a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb7e:	f8 0b 00 0b 	add	r11,r12,r11
8000bb82:	12 ab       	st.w	r9++,r11
8000bb84:	2f f8       	sub	r8,-1
8000bb86:	b1 85       	lsr	r5,0x10
8000bb88:	08 38       	cp.w	r8,r4
8000bb8a:	ce b5       	brlt	8000bb60 <__multadd+0x10>
8000bb8c:	58 05       	cp.w	r5,0
8000bb8e:	c1 c0       	breq	8000bbc6 <__multadd+0x76>
8000bb90:	6e 28       	ld.w	r8,r7[0x8]
8000bb92:	10 34       	cp.w	r4,r8
8000bb94:	c1 35       	brlt	8000bbba <__multadd+0x6a>
8000bb96:	6e 1b       	ld.w	r11,r7[0x4]
8000bb98:	0c 9c       	mov	r12,r6
8000bb9a:	2f fb       	sub	r11,-1
8000bb9c:	c1 ee       	rcall	8000b7d8 <_Balloc>
8000bb9e:	6e 4a       	ld.w	r10,r7[0x10]
8000bba0:	ee cb ff f4 	sub	r11,r7,-12
8000bba4:	18 93       	mov	r3,r12
8000bba6:	2f ea       	sub	r10,-2
8000bba8:	2f 4c       	sub	r12,-12
8000bbaa:	a3 6a       	lsl	r10,0x2
8000bbac:	fe b0 de 70 	rcall	8000788c <memcpy>
8000bbb0:	0e 9b       	mov	r11,r7
8000bbb2:	0c 9c       	mov	r12,r6
8000bbb4:	fe b0 fd f8 	rcall	8000b7a4 <_Bfree>
8000bbb8:	06 97       	mov	r7,r3
8000bbba:	e8 c8 ff ff 	sub	r8,r4,-1
8000bbbe:	2f b4       	sub	r4,-5
8000bbc0:	8f 48       	st.w	r7[0x10],r8
8000bbc2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bbc6:	0e 9c       	mov	r12,r7
8000bbc8:	d8 32       	popm	r0-r7,pc
8000bbca:	d7 03       	nop

8000bbcc <__pow5mult>:
8000bbcc:	d4 31       	pushm	r0-r7,lr
8000bbce:	14 96       	mov	r6,r10
8000bbd0:	18 97       	mov	r7,r12
8000bbd2:	16 94       	mov	r4,r11
8000bbd4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bbd8:	c0 90       	breq	8000bbea <__pow5mult+0x1e>
8000bbda:	20 18       	sub	r8,1
8000bbdc:	fe c9 da 20 	sub	r9,pc,-9696
8000bbe0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bbe4:	30 09       	mov	r9,0
8000bbe6:	cb 5f       	rcall	8000bb50 <__multadd>
8000bbe8:	18 94       	mov	r4,r12
8000bbea:	a3 46       	asr	r6,0x2
8000bbec:	c3 40       	breq	8000bc54 <__pow5mult+0x88>
8000bbee:	6e 95       	ld.w	r5,r7[0x24]
8000bbf0:	58 05       	cp.w	r5,0
8000bbf2:	c0 91       	brne	8000bc04 <__pow5mult+0x38>
8000bbf4:	31 0c       	mov	r12,16
8000bbf6:	fe b0 dc 27 	rcall	80007444 <malloc>
8000bbfa:	99 35       	st.w	r12[0xc],r5
8000bbfc:	8f 9c       	st.w	r7[0x24],r12
8000bbfe:	99 15       	st.w	r12[0x4],r5
8000bc00:	99 25       	st.w	r12[0x8],r5
8000bc02:	99 05       	st.w	r12[0x0],r5
8000bc04:	6e 93       	ld.w	r3,r7[0x24]
8000bc06:	66 25       	ld.w	r5,r3[0x8]
8000bc08:	58 05       	cp.w	r5,0
8000bc0a:	c0 c1       	brne	8000bc22 <__pow5mult+0x56>
8000bc0c:	e0 6b 02 71 	mov	r11,625
8000bc10:	0e 9c       	mov	r12,r7
8000bc12:	c9 7f       	rcall	8000bb40 <__i2b>
8000bc14:	87 2c       	st.w	r3[0x8],r12
8000bc16:	30 08       	mov	r8,0
8000bc18:	18 95       	mov	r5,r12
8000bc1a:	99 08       	st.w	r12[0x0],r8
8000bc1c:	c0 38       	rjmp	8000bc22 <__pow5mult+0x56>
8000bc1e:	06 9c       	mov	r12,r3
8000bc20:	18 95       	mov	r5,r12
8000bc22:	ed b6 00 00 	bld	r6,0x0
8000bc26:	c0 b1       	brne	8000bc3c <__pow5mult+0x70>
8000bc28:	08 9b       	mov	r11,r4
8000bc2a:	0a 9a       	mov	r10,r5
8000bc2c:	0e 9c       	mov	r12,r7
8000bc2e:	c0 9f       	rcall	8000ba40 <__multiply>
8000bc30:	08 9b       	mov	r11,r4
8000bc32:	18 93       	mov	r3,r12
8000bc34:	0e 9c       	mov	r12,r7
8000bc36:	06 94       	mov	r4,r3
8000bc38:	fe b0 fd b6 	rcall	8000b7a4 <_Bfree>
8000bc3c:	a1 56       	asr	r6,0x1
8000bc3e:	c0 b0       	breq	8000bc54 <__pow5mult+0x88>
8000bc40:	6a 03       	ld.w	r3,r5[0x0]
8000bc42:	58 03       	cp.w	r3,0
8000bc44:	ce d1       	brne	8000bc1e <__pow5mult+0x52>
8000bc46:	0a 9a       	mov	r10,r5
8000bc48:	0a 9b       	mov	r11,r5
8000bc4a:	0e 9c       	mov	r12,r7
8000bc4c:	cf ae       	rcall	8000ba40 <__multiply>
8000bc4e:	8b 0c       	st.w	r5[0x0],r12
8000bc50:	99 03       	st.w	r12[0x0],r3
8000bc52:	ce 7b       	rjmp	8000bc20 <__pow5mult+0x54>
8000bc54:	08 9c       	mov	r12,r4
8000bc56:	d8 32       	popm	r0-r7,pc

8000bc58 <__isinfd>:
8000bc58:	14 98       	mov	r8,r10
8000bc5a:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc5e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc62:	f0 0b 11 00 	rsub	r11,r8,0
8000bc66:	f7 e8 10 08 	or	r8,r11,r8
8000bc6a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc6e:	f2 08 01 08 	sub	r8,r9,r8
8000bc72:	f0 0c 11 00 	rsub	r12,r8,0
8000bc76:	f9 e8 10 08 	or	r8,r12,r8
8000bc7a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc7e:	2f fc       	sub	r12,-1
8000bc80:	5e fc       	retal	r12

8000bc82 <__isnand>:
8000bc82:	14 98       	mov	r8,r10
8000bc84:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc88:	f0 0c 11 00 	rsub	r12,r8,0
8000bc8c:	10 4c       	or	r12,r8
8000bc8e:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc92:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc96:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc9a:	bf 9c       	lsr	r12,0x1f
8000bc9c:	5e fc       	retal	r12
8000bc9e:	d7 03       	nop

8000bca0 <__sclose>:
8000bca0:	d4 01       	pushm	lr
8000bca2:	96 7b       	ld.sh	r11,r11[0xe]
8000bca4:	c8 2c       	rcall	8000bda8 <_close_r>
8000bca6:	d8 02       	popm	pc

8000bca8 <__sseek>:
8000bca8:	d4 21       	pushm	r4-r7,lr
8000bcaa:	16 97       	mov	r7,r11
8000bcac:	96 7b       	ld.sh	r11,r11[0xe]
8000bcae:	c0 3d       	rcall	8000beb4 <_lseek_r>
8000bcb0:	8e 68       	ld.sh	r8,r7[0xc]
8000bcb2:	10 99       	mov	r9,r8
8000bcb4:	ad c8       	cbr	r8,0xc
8000bcb6:	ad a9       	sbr	r9,0xc
8000bcb8:	5b fc       	cp.w	r12,-1
8000bcba:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bcbe:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bcc2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bcc6:	d8 22       	popm	r4-r7,pc

8000bcc8 <__swrite>:
8000bcc8:	d4 21       	pushm	r4-r7,lr
8000bcca:	96 68       	ld.sh	r8,r11[0xc]
8000bccc:	16 97       	mov	r7,r11
8000bcce:	14 95       	mov	r5,r10
8000bcd0:	12 94       	mov	r4,r9
8000bcd2:	e2 18 01 00 	andl	r8,0x100,COH
8000bcd6:	18 96       	mov	r6,r12
8000bcd8:	c0 50       	breq	8000bce2 <__swrite+0x1a>
8000bcda:	30 29       	mov	r9,2
8000bcdc:	30 0a       	mov	r10,0
8000bcde:	96 7b       	ld.sh	r11,r11[0xe]
8000bce0:	ce ac       	rcall	8000beb4 <_lseek_r>
8000bce2:	8e 68       	ld.sh	r8,r7[0xc]
8000bce4:	ad c8       	cbr	r8,0xc
8000bce6:	08 99       	mov	r9,r4
8000bce8:	0a 9a       	mov	r10,r5
8000bcea:	8e 7b       	ld.sh	r11,r7[0xe]
8000bcec:	0c 9c       	mov	r12,r6
8000bcee:	ae 68       	st.h	r7[0xc],r8
8000bcf0:	c1 cc       	rcall	8000bd28 <_write_r>
8000bcf2:	d8 22       	popm	r4-r7,pc

8000bcf4 <__sread>:
8000bcf4:	d4 21       	pushm	r4-r7,lr
8000bcf6:	16 97       	mov	r7,r11
8000bcf8:	96 7b       	ld.sh	r11,r11[0xe]
8000bcfa:	cf 1c       	rcall	8000bedc <_read_r>
8000bcfc:	c0 65       	brlt	8000bd08 <__sread+0x14>
8000bcfe:	6f 58       	ld.w	r8,r7[0x54]
8000bd00:	18 08       	add	r8,r12
8000bd02:	ef 48 00 54 	st.w	r7[84],r8
8000bd06:	d8 22       	popm	r4-r7,pc
8000bd08:	8e 68       	ld.sh	r8,r7[0xc]
8000bd0a:	ad c8       	cbr	r8,0xc
8000bd0c:	ae 68       	st.h	r7[0xc],r8
8000bd0e:	d8 22       	popm	r4-r7,pc

8000bd10 <strlen>:
8000bd10:	30 09       	mov	r9,0
8000bd12:	18 98       	mov	r8,r12
8000bd14:	c0 28       	rjmp	8000bd18 <strlen+0x8>
8000bd16:	2f f8       	sub	r8,-1
8000bd18:	11 8a       	ld.ub	r10,r8[0x0]
8000bd1a:	f2 0a 18 00 	cp.b	r10,r9
8000bd1e:	cf c1       	brne	8000bd16 <strlen+0x6>
8000bd20:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd24:	5e fc       	retal	r12
8000bd26:	d7 03       	nop

8000bd28 <_write_r>:
8000bd28:	d4 21       	pushm	r4-r7,lr
8000bd2a:	16 98       	mov	r8,r11
8000bd2c:	18 97       	mov	r7,r12
8000bd2e:	10 9c       	mov	r12,r8
8000bd30:	30 08       	mov	r8,0
8000bd32:	14 9b       	mov	r11,r10
8000bd34:	e0 66 53 c8 	mov	r6,21448
8000bd38:	12 9a       	mov	r10,r9
8000bd3a:	8d 08       	st.w	r6[0x0],r8
8000bd3c:	fe b0 d1 6e 	rcall	80006018 <_write>
8000bd40:	5b fc       	cp.w	r12,-1
8000bd42:	c0 51       	brne	8000bd4c <_write_r+0x24>
8000bd44:	6c 08       	ld.w	r8,r6[0x0]
8000bd46:	58 08       	cp.w	r8,0
8000bd48:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd4c:	d8 22       	popm	r4-r7,pc
8000bd4e:	d7 03       	nop

8000bd50 <_calloc_r>:
8000bd50:	d4 21       	pushm	r4-r7,lr
8000bd52:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd56:	fe b0 db 7f 	rcall	80007454 <_malloc_r>
8000bd5a:	18 97       	mov	r7,r12
8000bd5c:	c2 30       	breq	8000bda2 <_calloc_r+0x52>
8000bd5e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd62:	e0 1a ff fc 	andl	r10,0xfffc
8000bd66:	20 4a       	sub	r10,4
8000bd68:	e0 4a 00 24 	cp.w	r10,36
8000bd6c:	e0 8b 00 18 	brhi	8000bd9c <_calloc_r+0x4c>
8000bd70:	18 98       	mov	r8,r12
8000bd72:	59 3a       	cp.w	r10,19
8000bd74:	e0 88 00 0f 	brls	8000bd92 <_calloc_r+0x42>
8000bd78:	30 09       	mov	r9,0
8000bd7a:	10 a9       	st.w	r8++,r9
8000bd7c:	10 a9       	st.w	r8++,r9
8000bd7e:	59 ba       	cp.w	r10,27
8000bd80:	e0 88 00 09 	brls	8000bd92 <_calloc_r+0x42>
8000bd84:	10 a9       	st.w	r8++,r9
8000bd86:	10 a9       	st.w	r8++,r9
8000bd88:	e0 4a 00 24 	cp.w	r10,36
8000bd8c:	c0 31       	brne	8000bd92 <_calloc_r+0x42>
8000bd8e:	10 a9       	st.w	r8++,r9
8000bd90:	10 a9       	st.w	r8++,r9
8000bd92:	30 09       	mov	r9,0
8000bd94:	10 a9       	st.w	r8++,r9
8000bd96:	91 19       	st.w	r8[0x4],r9
8000bd98:	91 09       	st.w	r8[0x0],r9
8000bd9a:	c0 48       	rjmp	8000bda2 <_calloc_r+0x52>
8000bd9c:	30 0b       	mov	r11,0
8000bd9e:	fe b0 de 1b 	rcall	800079d4 <memset>
8000bda2:	0e 9c       	mov	r12,r7
8000bda4:	d8 22       	popm	r4-r7,pc
8000bda6:	d7 03       	nop

8000bda8 <_close_r>:
8000bda8:	d4 21       	pushm	r4-r7,lr
8000bdaa:	30 08       	mov	r8,0
8000bdac:	18 97       	mov	r7,r12
8000bdae:	e0 66 53 c8 	mov	r6,21448
8000bdb2:	16 9c       	mov	r12,r11
8000bdb4:	8d 08       	st.w	r6[0x0],r8
8000bdb6:	fe b0 df b5 	rcall	80007d20 <_close>
8000bdba:	5b fc       	cp.w	r12,-1
8000bdbc:	c0 51       	brne	8000bdc6 <_close_r+0x1e>
8000bdbe:	6c 08       	ld.w	r8,r6[0x0]
8000bdc0:	58 08       	cp.w	r8,0
8000bdc2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdc6:	d8 22       	popm	r4-r7,pc

8000bdc8 <_fclose_r>:
8000bdc8:	d4 21       	pushm	r4-r7,lr
8000bdca:	18 96       	mov	r6,r12
8000bdcc:	16 97       	mov	r7,r11
8000bdce:	58 0b       	cp.w	r11,0
8000bdd0:	c0 31       	brne	8000bdd6 <_fclose_r+0xe>
8000bdd2:	16 95       	mov	r5,r11
8000bdd4:	c5 38       	rjmp	8000be7a <_fclose_r+0xb2>
8000bdd6:	fe b0 f8 a9 	rcall	8000af28 <__sfp_lock_acquire>
8000bdda:	58 06       	cp.w	r6,0
8000bddc:	c0 70       	breq	8000bdea <_fclose_r+0x22>
8000bdde:	6c 68       	ld.w	r8,r6[0x18]
8000bde0:	58 08       	cp.w	r8,0
8000bde2:	c0 41       	brne	8000bdea <_fclose_r+0x22>
8000bde4:	0c 9c       	mov	r12,r6
8000bde6:	fe b0 f8 f3 	rcall	8000afcc <__sinit>
8000bdea:	fe c8 dc d2 	sub	r8,pc,-9006
8000bdee:	10 37       	cp.w	r7,r8
8000bdf0:	c0 31       	brne	8000bdf6 <_fclose_r+0x2e>
8000bdf2:	6c 07       	ld.w	r7,r6[0x0]
8000bdf4:	c0 c8       	rjmp	8000be0c <_fclose_r+0x44>
8000bdf6:	fe c8 dc be 	sub	r8,pc,-9026
8000bdfa:	10 37       	cp.w	r7,r8
8000bdfc:	c0 31       	brne	8000be02 <_fclose_r+0x3a>
8000bdfe:	6c 17       	ld.w	r7,r6[0x4]
8000be00:	c0 68       	rjmp	8000be0c <_fclose_r+0x44>
8000be02:	fe c8 dc aa 	sub	r8,pc,-9046
8000be06:	10 37       	cp.w	r7,r8
8000be08:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be0c:	8e 69       	ld.sh	r9,r7[0xc]
8000be0e:	30 08       	mov	r8,0
8000be10:	f0 09 19 00 	cp.h	r9,r8
8000be14:	c0 51       	brne	8000be1e <_fclose_r+0x56>
8000be16:	fe b0 f8 8a 	rcall	8000af2a <__sfp_lock_release>
8000be1a:	30 05       	mov	r5,0
8000be1c:	c2 f8       	rjmp	8000be7a <_fclose_r+0xb2>
8000be1e:	0e 9b       	mov	r11,r7
8000be20:	0c 9c       	mov	r12,r6
8000be22:	fe b0 f7 fd 	rcall	8000ae1c <_fflush_r>
8000be26:	6e c8       	ld.w	r8,r7[0x30]
8000be28:	18 95       	mov	r5,r12
8000be2a:	58 08       	cp.w	r8,0
8000be2c:	c0 60       	breq	8000be38 <_fclose_r+0x70>
8000be2e:	6e 8b       	ld.w	r11,r7[0x20]
8000be30:	0c 9c       	mov	r12,r6
8000be32:	5d 18       	icall	r8
8000be34:	f9 b5 05 ff 	movlt	r5,-1
8000be38:	8e 68       	ld.sh	r8,r7[0xc]
8000be3a:	ed b8 00 07 	bld	r8,0x7
8000be3e:	c0 51       	brne	8000be48 <_fclose_r+0x80>
8000be40:	6e 4b       	ld.w	r11,r7[0x10]
8000be42:	0c 9c       	mov	r12,r6
8000be44:	fe b0 f9 5e 	rcall	8000b100 <_free_r>
8000be48:	6e db       	ld.w	r11,r7[0x34]
8000be4a:	58 0b       	cp.w	r11,0
8000be4c:	c0 a0       	breq	8000be60 <_fclose_r+0x98>
8000be4e:	ee c8 ff bc 	sub	r8,r7,-68
8000be52:	10 3b       	cp.w	r11,r8
8000be54:	c0 40       	breq	8000be5c <_fclose_r+0x94>
8000be56:	0c 9c       	mov	r12,r6
8000be58:	fe b0 f9 54 	rcall	8000b100 <_free_r>
8000be5c:	30 08       	mov	r8,0
8000be5e:	8f d8       	st.w	r7[0x34],r8
8000be60:	6f 2b       	ld.w	r11,r7[0x48]
8000be62:	58 0b       	cp.w	r11,0
8000be64:	c0 70       	breq	8000be72 <_fclose_r+0xaa>
8000be66:	0c 9c       	mov	r12,r6
8000be68:	fe b0 f9 4c 	rcall	8000b100 <_free_r>
8000be6c:	30 08       	mov	r8,0
8000be6e:	ef 48 00 48 	st.w	r7[72],r8
8000be72:	30 08       	mov	r8,0
8000be74:	ae 68       	st.h	r7[0xc],r8
8000be76:	fe b0 f8 5a 	rcall	8000af2a <__sfp_lock_release>
8000be7a:	0a 9c       	mov	r12,r5
8000be7c:	d8 22       	popm	r4-r7,pc
8000be7e:	d7 03       	nop

8000be80 <fclose>:
8000be80:	d4 01       	pushm	lr
8000be82:	e0 68 0a 40 	mov	r8,2624
8000be86:	18 9b       	mov	r11,r12
8000be88:	70 0c       	ld.w	r12,r8[0x0]
8000be8a:	c9 ff       	rcall	8000bdc8 <_fclose_r>
8000be8c:	d8 02       	popm	pc
8000be8e:	d7 03       	nop

8000be90 <_fstat_r>:
8000be90:	d4 21       	pushm	r4-r7,lr
8000be92:	16 98       	mov	r8,r11
8000be94:	18 97       	mov	r7,r12
8000be96:	10 9c       	mov	r12,r8
8000be98:	30 08       	mov	r8,0
8000be9a:	e0 66 53 c8 	mov	r6,21448
8000be9e:	14 9b       	mov	r11,r10
8000bea0:	8d 08       	st.w	r6[0x0],r8
8000bea2:	fe b0 df 67 	rcall	80007d70 <_fstat>
8000bea6:	5b fc       	cp.w	r12,-1
8000bea8:	c0 51       	brne	8000beb2 <_fstat_r+0x22>
8000beaa:	6c 08       	ld.w	r8,r6[0x0]
8000beac:	58 08       	cp.w	r8,0
8000beae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beb2:	d8 22       	popm	r4-r7,pc

8000beb4 <_lseek_r>:
8000beb4:	d4 21       	pushm	r4-r7,lr
8000beb6:	16 98       	mov	r8,r11
8000beb8:	18 97       	mov	r7,r12
8000beba:	10 9c       	mov	r12,r8
8000bebc:	30 08       	mov	r8,0
8000bebe:	14 9b       	mov	r11,r10
8000bec0:	e0 66 53 c8 	mov	r6,21448
8000bec4:	12 9a       	mov	r10,r9
8000bec6:	8d 08       	st.w	r6[0x0],r8
8000bec8:	fe b0 df 36 	rcall	80007d34 <_lseek>
8000becc:	5b fc       	cp.w	r12,-1
8000bece:	c0 51       	brne	8000bed8 <_lseek_r+0x24>
8000bed0:	6c 08       	ld.w	r8,r6[0x0]
8000bed2:	58 08       	cp.w	r8,0
8000bed4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bed8:	d8 22       	popm	r4-r7,pc
8000beda:	d7 03       	nop

8000bedc <_read_r>:
8000bedc:	d4 21       	pushm	r4-r7,lr
8000bede:	16 98       	mov	r8,r11
8000bee0:	18 97       	mov	r7,r12
8000bee2:	10 9c       	mov	r12,r8
8000bee4:	30 08       	mov	r8,0
8000bee6:	14 9b       	mov	r11,r10
8000bee8:	e0 66 53 c8 	mov	r6,21448
8000beec:	12 9a       	mov	r10,r9
8000beee:	8d 08       	st.w	r6[0x0],r8
8000bef0:	fe b0 d0 74 	rcall	80005fd8 <_read>
8000bef4:	5b fc       	cp.w	r12,-1
8000bef6:	c0 51       	brne	8000bf00 <_read_r+0x24>
8000bef8:	6c 08       	ld.w	r8,r6[0x0]
8000befa:	58 08       	cp.w	r8,0
8000befc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf00:	d8 22       	popm	r4-r7,pc
8000bf02:	d7 03       	nop

8000bf04 <__avr32_f64_mul>:
8000bf04:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bf08:	e0 80 00 dc 	breq	8000c0c0 <__avr32_f64_mul_op1_zero>
8000bf0c:	d4 21       	pushm	r4-r7,lr
8000bf0e:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf12:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bf16:	30 15       	mov	r5,1
8000bf18:	c4 30       	breq	8000bf9e <__avr32_f64_mul_op1_subnormal>
8000bf1a:	ab 6b       	lsl	r11,0xa
8000bf1c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bf20:	ab 6a       	lsl	r10,0xa
8000bf22:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf26:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf2a:	c5 c0       	breq	8000bfe2 <__avr32_f64_mul_op2_subnormal>
8000bf2c:	a1 78       	lsl	r8,0x1
8000bf2e:	5c f9       	rol	r9
8000bf30:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf34:	e0 47 07 ff 	cp.w	r7,2047
8000bf38:	c7 70       	breq	8000c026 <__avr32_f64_mul_op_nan_or_inf>
8000bf3a:	e0 46 07 ff 	cp.w	r6,2047
8000bf3e:	c7 40       	breq	8000c026 <__avr32_f64_mul_op_nan_or_inf>
8000bf40:	ee 06 00 0c 	add	r12,r7,r6
8000bf44:	e0 2c 03 fe 	sub	r12,1022
8000bf48:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf4c:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf50:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf54:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf58:	08 07       	add	r7,r4
8000bf5a:	f4 05 00 4a 	adc	r10,r10,r5
8000bf5e:	5c 0b       	acr	r11
8000bf60:	ed bb 00 14 	bld	r11,0x14
8000bf64:	c0 50       	breq	8000bf6e <__avr32_f64_mul+0x6a>
8000bf66:	a1 77       	lsl	r7,0x1
8000bf68:	5c fa       	rol	r10
8000bf6a:	5c fb       	rol	r11
8000bf6c:	20 1c       	sub	r12,1
8000bf6e:	58 0c       	cp.w	r12,0
8000bf70:	e0 8a 00 6f 	brle	8000c04e <__avr32_f64_mul_res_subnormal>
8000bf74:	e0 4c 07 ff 	cp.w	r12,2047
8000bf78:	e0 84 00 9c 	brge	8000c0b0 <__avr32_f64_mul_res_inf>
8000bf7c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf80:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf84:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf88:	ee 17 80 00 	eorh	r7,0x8000
8000bf8c:	f1 b7 04 20 	satu	r7,0x1
8000bf90:	0e 0a       	add	r10,r7
8000bf92:	5c 0b       	acr	r11
8000bf94:	ed be 00 1f 	bld	lr,0x1f
8000bf98:	ef bb 00 1f 	bst	r11,0x1f
8000bf9c:	d8 22       	popm	r4-r7,pc

8000bf9e <__avr32_f64_mul_op1_subnormal>:
8000bf9e:	e4 1b 00 0f 	andh	r11,0xf
8000bfa2:	f4 0c 12 00 	clz	r12,r10
8000bfa6:	f6 06 12 00 	clz	r6,r11
8000bfaa:	f7 bc 03 e1 	sublo	r12,-31
8000bfae:	f8 06 17 30 	movlo	r6,r12
8000bfb2:	f7 b6 02 01 	subhs	r6,1
8000bfb6:	e0 46 00 20 	cp.w	r6,32
8000bfba:	c0 d4       	brge	8000bfd4 <__avr32_f64_mul_op1_subnormal+0x36>
8000bfbc:	ec 0c 11 20 	rsub	r12,r6,32
8000bfc0:	f6 06 09 4b 	lsl	r11,r11,r6
8000bfc4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bfc8:	18 4b       	or	r11,r12
8000bfca:	f4 06 09 4a 	lsl	r10,r10,r6
8000bfce:	20 b6       	sub	r6,11
8000bfd0:	0c 17       	sub	r7,r6
8000bfd2:	ca ab       	rjmp	8000bf26 <__avr32_f64_mul+0x22>
8000bfd4:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfd8:	c6 40       	breq	8000c0a0 <__avr32_f64_mul_res_zero>
8000bfda:	30 0a       	mov	r10,0
8000bfdc:	20 b6       	sub	r6,11
8000bfde:	0c 17       	sub	r7,r6
8000bfe0:	ca 3b       	rjmp	8000bf26 <__avr32_f64_mul+0x22>

8000bfe2 <__avr32_f64_mul_op2_subnormal>:
8000bfe2:	e4 19 00 0f 	andh	r9,0xf
8000bfe6:	f0 0c 12 00 	clz	r12,r8
8000bfea:	f2 05 12 00 	clz	r5,r9
8000bfee:	f7 bc 03 ea 	sublo	r12,-22
8000bff2:	f8 05 17 30 	movlo	r5,r12
8000bff6:	f7 b5 02 0a 	subhs	r5,10
8000bffa:	e0 45 00 20 	cp.w	r5,32
8000bffe:	c0 d4       	brge	8000c018 <__avr32_f64_mul_op2_subnormal+0x36>
8000c000:	ea 0c 11 20 	rsub	r12,r5,32
8000c004:	f2 05 09 49 	lsl	r9,r9,r5
8000c008:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c00c:	18 49       	or	r9,r12
8000c00e:	f0 05 09 48 	lsl	r8,r8,r5
8000c012:	20 25       	sub	r5,2
8000c014:	0a 16       	sub	r6,r5
8000c016:	c8 fb       	rjmp	8000bf34 <__avr32_f64_mul+0x30>
8000c018:	f0 05 09 49 	lsl	r9,r8,r5
8000c01c:	c4 20       	breq	8000c0a0 <__avr32_f64_mul_res_zero>
8000c01e:	30 08       	mov	r8,0
8000c020:	20 25       	sub	r5,2
8000c022:	0a 16       	sub	r6,r5
8000c024:	c8 8b       	rjmp	8000bf34 <__avr32_f64_mul+0x30>

8000c026 <__avr32_f64_mul_op_nan_or_inf>:
8000c026:	e4 19 00 0f 	andh	r9,0xf
8000c02a:	e4 1b 00 0f 	andh	r11,0xf
8000c02e:	14 4b       	or	r11,r10
8000c030:	10 49       	or	r9,r8
8000c032:	e0 47 07 ff 	cp.w	r7,2047
8000c036:	c0 91       	brne	8000c048 <__avr32_f64_mul_op1_not_naninf>
8000c038:	58 0b       	cp.w	r11,0
8000c03a:	c3 81       	brne	8000c0aa <__avr32_f64_mul_res_nan>
8000c03c:	e0 46 07 ff 	cp.w	r6,2047
8000c040:	c3 81       	brne	8000c0b0 <__avr32_f64_mul_res_inf>
8000c042:	58 09       	cp.w	r9,0
8000c044:	c3 60       	breq	8000c0b0 <__avr32_f64_mul_res_inf>
8000c046:	c3 28       	rjmp	8000c0aa <__avr32_f64_mul_res_nan>

8000c048 <__avr32_f64_mul_op1_not_naninf>:
8000c048:	58 09       	cp.w	r9,0
8000c04a:	c3 30       	breq	8000c0b0 <__avr32_f64_mul_res_inf>
8000c04c:	c2 f8       	rjmp	8000c0aa <__avr32_f64_mul_res_nan>

8000c04e <__avr32_f64_mul_res_subnormal>:
8000c04e:	5c 3c       	neg	r12
8000c050:	2f fc       	sub	r12,-1
8000c052:	f1 bc 04 c0 	satu	r12,0x6
8000c056:	e0 4c 00 20 	cp.w	r12,32
8000c05a:	c1 14       	brge	8000c07c <__avr32_f64_mul_res_subnormal+0x2e>
8000c05c:	f8 08 11 20 	rsub	r8,r12,32
8000c060:	0e 46       	or	r6,r7
8000c062:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c066:	f4 08 09 49 	lsl	r9,r10,r8
8000c06a:	12 47       	or	r7,r9
8000c06c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c070:	f6 08 09 49 	lsl	r9,r11,r8
8000c074:	12 4a       	or	r10,r9
8000c076:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c07a:	c8 3b       	rjmp	8000bf80 <__avr32_f64_mul+0x7c>
8000c07c:	f8 08 11 20 	rsub	r8,r12,32
8000c080:	f9 b9 00 00 	moveq	r9,0
8000c084:	c0 30       	breq	8000c08a <__avr32_f64_mul_res_subnormal+0x3c>
8000c086:	f6 08 09 49 	lsl	r9,r11,r8
8000c08a:	0e 46       	or	r6,r7
8000c08c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c090:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c094:	f3 ea 10 07 	or	r7,r9,r10
8000c098:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c09c:	30 0b       	mov	r11,0
8000c09e:	c7 1b       	rjmp	8000bf80 <__avr32_f64_mul+0x7c>

8000c0a0 <__avr32_f64_mul_res_zero>:
8000c0a0:	1c 9b       	mov	r11,lr
8000c0a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0a6:	30 0a       	mov	r10,0
8000c0a8:	d8 22       	popm	r4-r7,pc

8000c0aa <__avr32_f64_mul_res_nan>:
8000c0aa:	3f fb       	mov	r11,-1
8000c0ac:	3f fa       	mov	r10,-1
8000c0ae:	d8 22       	popm	r4-r7,pc

8000c0b0 <__avr32_f64_mul_res_inf>:
8000c0b0:	f0 6b 00 00 	mov	r11,-1048576
8000c0b4:	ed be 00 1f 	bld	lr,0x1f
8000c0b8:	ef bb 00 1f 	bst	r11,0x1f
8000c0bc:	30 0a       	mov	r10,0
8000c0be:	d8 22       	popm	r4-r7,pc

8000c0c0 <__avr32_f64_mul_op1_zero>:
8000c0c0:	f7 e9 20 0b 	eor	r11,r11,r9
8000c0c4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0c8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c0cc:	e0 4c 07 ff 	cp.w	r12,2047
8000c0d0:	5e 1c       	retne	r12
8000c0d2:	3f fa       	mov	r10,-1
8000c0d4:	3f fb       	mov	r11,-1
8000c0d6:	5e fc       	retal	r12

8000c0d8 <__avr32_f64_sub_from_add>:
8000c0d8:	ee 19 80 00 	eorh	r9,0x8000

8000c0dc <__avr32_f64_sub>:
8000c0dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0e0:	e0 86 00 ca 	brmi	8000c274 <__avr32_f64_add_from_sub>
8000c0e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0e8:	16 9c       	mov	r12,r11
8000c0ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0ee:	bf db       	cbr	r11,0x1f
8000c0f0:	bf d9       	cbr	r9,0x1f
8000c0f2:	10 3a       	cp.w	r10,r8
8000c0f4:	f2 0b 13 00 	cpc	r11,r9
8000c0f8:	c0 92       	brcc	8000c10a <__avr32_f64_sub+0x2e>
8000c0fa:	16 97       	mov	r7,r11
8000c0fc:	12 9b       	mov	r11,r9
8000c0fe:	0e 99       	mov	r9,r7
8000c100:	14 97       	mov	r7,r10
8000c102:	10 9a       	mov	r10,r8
8000c104:	0e 98       	mov	r8,r7
8000c106:	ee 1c 80 00 	eorh	r12,0x8000
8000c10a:	f6 07 16 14 	lsr	r7,r11,0x14
8000c10e:	ab 7b       	lsl	r11,0xb
8000c110:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c114:	ab 7a       	lsl	r10,0xb
8000c116:	bf bb       	sbr	r11,0x1f
8000c118:	f2 06 16 14 	lsr	r6,r9,0x14
8000c11c:	c4 40       	breq	8000c1a4 <__avr32_f64_sub_opL_subnormal>
8000c11e:	ab 79       	lsl	r9,0xb
8000c120:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c124:	ab 78       	lsl	r8,0xb
8000c126:	bf b9       	sbr	r9,0x1f

8000c128 <__avr32_f64_sub_opL_subnormal_done>:
8000c128:	e0 47 07 ff 	cp.w	r7,2047
8000c12c:	c4 f0       	breq	8000c1ca <__avr32_f64_sub_opH_nan_or_inf>
8000c12e:	0e 26       	rsub	r6,r7
8000c130:	c1 20       	breq	8000c154 <__avr32_f64_sub_shift_done>
8000c132:	ec 05 11 20 	rsub	r5,r6,32
8000c136:	e0 46 00 20 	cp.w	r6,32
8000c13a:	c7 c2       	brcc	8000c232 <__avr32_f64_sub_longshift>
8000c13c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c140:	f2 05 09 45 	lsl	r5,r9,r5
8000c144:	f0 06 0a 48 	lsr	r8,r8,r6
8000c148:	f2 06 0a 49 	lsr	r9,r9,r6
8000c14c:	0a 48       	or	r8,r5
8000c14e:	58 0e       	cp.w	lr,0
8000c150:	5f 1e       	srne	lr
8000c152:	1c 48       	or	r8,lr

8000c154 <__avr32_f64_sub_shift_done>:
8000c154:	10 1a       	sub	r10,r8
8000c156:	f6 09 01 4b 	sbc	r11,r11,r9
8000c15a:	f6 06 12 00 	clz	r6,r11
8000c15e:	c0 e0       	breq	8000c17a <__avr32_f64_sub_longnormalize_done>
8000c160:	c7 83       	brcs	8000c250 <__avr32_f64_sub_longnormalize>
8000c162:	ec 0e 11 20 	rsub	lr,r6,32
8000c166:	f6 06 09 4b 	lsl	r11,r11,r6
8000c16a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c16e:	1c 4b       	or	r11,lr
8000c170:	f4 06 09 4a 	lsl	r10,r10,r6
8000c174:	0c 17       	sub	r7,r6
8000c176:	e0 8a 00 39 	brle	8000c1e8 <__avr32_f64_sub_subnormal_result>

8000c17a <__avr32_f64_sub_longnormalize_done>:
8000c17a:	f4 09 15 15 	lsl	r9,r10,0x15
8000c17e:	ab 9a       	lsr	r10,0xb
8000c180:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c184:	ab 9b       	lsr	r11,0xb
8000c186:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c18a:	18 4b       	or	r11,r12

8000c18c <__avr32_f64_sub_round>:
8000c18c:	fc 17 80 00 	movh	r7,0x8000
8000c190:	ed ba 00 00 	bld	r10,0x0
8000c194:	f7 b7 01 ff 	subne	r7,-1
8000c198:	0e 39       	cp.w	r9,r7
8000c19a:	5f 29       	srhs	r9
8000c19c:	12 0a       	add	r10,r9
8000c19e:	5c 0b       	acr	r11
8000c1a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1a4 <__avr32_f64_sub_opL_subnormal>:
8000c1a4:	ab 79       	lsl	r9,0xb
8000c1a6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c1aa:	ab 78       	lsl	r8,0xb
8000c1ac:	f3 e8 10 0e 	or	lr,r9,r8
8000c1b0:	f9 b6 01 01 	movne	r6,1
8000c1b4:	ee 0e 11 00 	rsub	lr,r7,0
8000c1b8:	f9 b7 00 01 	moveq	r7,1
8000c1bc:	ef bb 00 1f 	bst	r11,0x1f
8000c1c0:	f7 ea 10 0e 	or	lr,r11,r10
8000c1c4:	f9 b7 00 00 	moveq	r7,0
8000c1c8:	cb 0b       	rjmp	8000c128 <__avr32_f64_sub_opL_subnormal_done>

8000c1ca <__avr32_f64_sub_opH_nan_or_inf>:
8000c1ca:	bf db       	cbr	r11,0x1f
8000c1cc:	f7 ea 10 0e 	or	lr,r11,r10
8000c1d0:	c0 81       	brne	8000c1e0 <__avr32_f64_sub_return_nan>
8000c1d2:	e0 46 07 ff 	cp.w	r6,2047
8000c1d6:	c0 50       	breq	8000c1e0 <__avr32_f64_sub_return_nan>
8000c1d8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c1dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1e0 <__avr32_f64_sub_return_nan>:
8000c1e0:	3f fa       	mov	r10,-1
8000c1e2:	3f fb       	mov	r11,-1
8000c1e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1e8 <__avr32_f64_sub_subnormal_result>:
8000c1e8:	5c 37       	neg	r7
8000c1ea:	2f f7       	sub	r7,-1
8000c1ec:	f1 b7 04 c0 	satu	r7,0x6
8000c1f0:	e0 47 00 20 	cp.w	r7,32
8000c1f4:	c1 14       	brge	8000c216 <__avr32_f64_sub_subnormal_result+0x2e>
8000c1f6:	ee 08 11 20 	rsub	r8,r7,32
8000c1fa:	f4 08 09 49 	lsl	r9,r10,r8
8000c1fe:	5f 16       	srne	r6
8000c200:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c204:	0c 4a       	or	r10,r6
8000c206:	f6 08 09 49 	lsl	r9,r11,r8
8000c20a:	f5 e9 10 0a 	or	r10,r10,r9
8000c20e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c212:	30 07       	mov	r7,0
8000c214:	cb 3b       	rjmp	8000c17a <__avr32_f64_sub_longnormalize_done>
8000c216:	ee 08 11 40 	rsub	r8,r7,64
8000c21a:	f6 08 09 49 	lsl	r9,r11,r8
8000c21e:	14 49       	or	r9,r10
8000c220:	5f 16       	srne	r6
8000c222:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c226:	0c 4a       	or	r10,r6
8000c228:	30 0b       	mov	r11,0
8000c22a:	30 07       	mov	r7,0
8000c22c:	ca 7b       	rjmp	8000c17a <__avr32_f64_sub_longnormalize_done>
8000c22e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c232 <__avr32_f64_sub_longshift>:
8000c232:	f1 b6 04 c0 	satu	r6,0x6
8000c236:	f0 0e 17 00 	moveq	lr,r8
8000c23a:	c0 40       	breq	8000c242 <__avr32_f64_sub_longshift+0x10>
8000c23c:	f2 05 09 4e 	lsl	lr,r9,r5
8000c240:	10 4e       	or	lr,r8
8000c242:	f2 06 0a 48 	lsr	r8,r9,r6
8000c246:	30 09       	mov	r9,0
8000c248:	58 0e       	cp.w	lr,0
8000c24a:	5f 1e       	srne	lr
8000c24c:	1c 48       	or	r8,lr
8000c24e:	c8 3b       	rjmp	8000c154 <__avr32_f64_sub_shift_done>

8000c250 <__avr32_f64_sub_longnormalize>:
8000c250:	f4 06 12 00 	clz	r6,r10
8000c254:	f9 b7 03 00 	movlo	r7,0
8000c258:	f9 b6 03 00 	movlo	r6,0
8000c25c:	f9 bc 03 00 	movlo	r12,0
8000c260:	f7 b6 02 e0 	subhs	r6,-32
8000c264:	f4 06 09 4b 	lsl	r11,r10,r6
8000c268:	30 0a       	mov	r10,0
8000c26a:	0c 17       	sub	r7,r6
8000c26c:	fe 9a ff be 	brle	8000c1e8 <__avr32_f64_sub_subnormal_result>
8000c270:	c8 5b       	rjmp	8000c17a <__avr32_f64_sub_longnormalize_done>
8000c272:	d7 03       	nop

8000c274 <__avr32_f64_add_from_sub>:
8000c274:	ee 19 80 00 	eorh	r9,0x8000

8000c278 <__avr32_f64_add>:
8000c278:	f7 e9 20 0c 	eor	r12,r11,r9
8000c27c:	fe 96 ff 2e 	brmi	8000c0d8 <__avr32_f64_sub_from_add>
8000c280:	eb cd 40 e0 	pushm	r5-r7,lr
8000c284:	16 9c       	mov	r12,r11
8000c286:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c28a:	bf db       	cbr	r11,0x1f
8000c28c:	bf d9       	cbr	r9,0x1f
8000c28e:	12 3b       	cp.w	r11,r9
8000c290:	c0 72       	brcc	8000c29e <__avr32_f64_add+0x26>
8000c292:	16 97       	mov	r7,r11
8000c294:	12 9b       	mov	r11,r9
8000c296:	0e 99       	mov	r9,r7
8000c298:	14 97       	mov	r7,r10
8000c29a:	10 9a       	mov	r10,r8
8000c29c:	0e 98       	mov	r8,r7
8000c29e:	30 0e       	mov	lr,0
8000c2a0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c2a4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c2a8:	b5 ab       	sbr	r11,0x14
8000c2aa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c2ae:	c6 20       	breq	8000c372 <__avr32_f64_add_op2_subnormal>
8000c2b0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c2b4:	b5 a9       	sbr	r9,0x14
8000c2b6:	e0 47 07 ff 	cp.w	r7,2047
8000c2ba:	c2 80       	breq	8000c30a <__avr32_f64_add_opH_nan_or_inf>
8000c2bc:	0e 26       	rsub	r6,r7
8000c2be:	c1 20       	breq	8000c2e2 <__avr32_f64_add_shift_done>
8000c2c0:	e0 46 00 36 	cp.w	r6,54
8000c2c4:	c1 52       	brcc	8000c2ee <__avr32_f64_add_res_of_done>
8000c2c6:	ec 05 11 20 	rsub	r5,r6,32
8000c2ca:	e0 46 00 20 	cp.w	r6,32
8000c2ce:	c3 52       	brcc	8000c338 <__avr32_f64_add_longshift>
8000c2d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c2d4:	f2 05 09 45 	lsl	r5,r9,r5
8000c2d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2e0:	0a 48       	or	r8,r5

8000c2e2 <__avr32_f64_add_shift_done>:
8000c2e2:	10 0a       	add	r10,r8
8000c2e4:	f6 09 00 4b 	adc	r11,r11,r9
8000c2e8:	ed bb 00 15 	bld	r11,0x15
8000c2ec:	c3 40       	breq	8000c354 <__avr32_f64_add_res_of>

8000c2ee <__avr32_f64_add_res_of_done>:
8000c2ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2f2:	18 4b       	or	r11,r12

8000c2f4 <__avr32_f64_add_round>:
8000c2f4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c2f8:	18 4e       	or	lr,r12
8000c2fa:	ee 1e 80 00 	eorh	lr,0x8000
8000c2fe:	f1 be 04 20 	satu	lr,0x1
8000c302:	1c 0a       	add	r10,lr
8000c304:	5c 0b       	acr	r11
8000c306:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c30a <__avr32_f64_add_opH_nan_or_inf>:
8000c30a:	b5 cb       	cbr	r11,0x14
8000c30c:	f7 ea 10 0e 	or	lr,r11,r10
8000c310:	c1 01       	brne	8000c330 <__avr32_f64_add_return_nan>
8000c312:	e0 46 07 ff 	cp.w	r6,2047
8000c316:	c0 30       	breq	8000c31c <__avr32_f64_add_opL_nan_or_inf>
8000c318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c31c <__avr32_f64_add_opL_nan_or_inf>:
8000c31c:	b5 c9       	cbr	r9,0x14
8000c31e:	f3 e8 10 0e 	or	lr,r9,r8
8000c322:	c0 71       	brne	8000c330 <__avr32_f64_add_return_nan>
8000c324:	30 0a       	mov	r10,0
8000c326:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c32a:	18 4b       	or	r11,r12
8000c32c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c330 <__avr32_f64_add_return_nan>:
8000c330:	3f fa       	mov	r10,-1
8000c332:	3f fb       	mov	r11,-1
8000c334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c338 <__avr32_f64_add_longshift>:
8000c338:	f1 b6 04 c0 	satu	r6,0x6
8000c33c:	f0 0e 17 00 	moveq	lr,r8
8000c340:	c0 60       	breq	8000c34c <__avr32_f64_add_longshift+0x14>
8000c342:	f2 05 09 4e 	lsl	lr,r9,r5
8000c346:	58 08       	cp.w	r8,0
8000c348:	5f 18       	srne	r8
8000c34a:	10 4e       	or	lr,r8
8000c34c:	f2 06 0a 48 	lsr	r8,r9,r6
8000c350:	30 09       	mov	r9,0
8000c352:	cc 8b       	rjmp	8000c2e2 <__avr32_f64_add_shift_done>

8000c354 <__avr32_f64_add_res_of>:
8000c354:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c358:	a1 9b       	lsr	r11,0x1
8000c35a:	5d 0a       	ror	r10
8000c35c:	5d 0e       	ror	lr
8000c35e:	2f f7       	sub	r7,-1
8000c360:	e0 47 07 ff 	cp.w	r7,2047
8000c364:	f9 ba 00 00 	moveq	r10,0
8000c368:	f9 bb 00 00 	moveq	r11,0
8000c36c:	f9 be 00 00 	moveq	lr,0
8000c370:	cb fb       	rjmp	8000c2ee <__avr32_f64_add_res_of_done>

8000c372 <__avr32_f64_add_op2_subnormal>:
8000c372:	30 16       	mov	r6,1
8000c374:	58 07       	cp.w	r7,0
8000c376:	ca 01       	brne	8000c2b6 <__avr32_f64_add+0x3e>
8000c378:	b5 cb       	cbr	r11,0x14
8000c37a:	10 0a       	add	r10,r8
8000c37c:	f6 09 00 4b 	adc	r11,r11,r9
8000c380:	18 4b       	or	r11,r12
8000c382:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c386:	d7 03       	nop

8000c388 <__avr32_f64_to_u32>:
8000c388:	58 0b       	cp.w	r11,0
8000c38a:	5e 6d       	retmi	0

8000c38c <__avr32_f64_to_s32>:
8000c38c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c390:	b5 9c       	lsr	r12,0x15
8000c392:	e0 2c 03 ff 	sub	r12,1023
8000c396:	5e 3d       	retlo	0
8000c398:	f8 0c 11 1f 	rsub	r12,r12,31
8000c39c:	16 99       	mov	r9,r11
8000c39e:	ab 7b       	lsl	r11,0xb
8000c3a0:	bf bb       	sbr	r11,0x1f
8000c3a2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c3a6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c3aa:	a1 79       	lsl	r9,0x1
8000c3ac:	5e 2b       	reths	r11
8000c3ae:	5c 3b       	neg	r11
8000c3b0:	5e fb       	retal	r11

8000c3b2 <__avr32_u32_to_f64>:
8000c3b2:	f8 cb 00 00 	sub	r11,r12,0
8000c3b6:	30 0c       	mov	r12,0
8000c3b8:	c0 38       	rjmp	8000c3be <__avr32_s32_to_f64+0x4>

8000c3ba <__avr32_s32_to_f64>:
8000c3ba:	18 9b       	mov	r11,r12
8000c3bc:	5c 4b       	abs	r11
8000c3be:	30 0a       	mov	r10,0
8000c3c0:	5e 0b       	reteq	r11
8000c3c2:	d4 01       	pushm	lr
8000c3c4:	e0 69 04 1e 	mov	r9,1054
8000c3c8:	f6 08 12 00 	clz	r8,r11
8000c3cc:	c1 70       	breq	8000c3fa <__avr32_s32_to_f64+0x40>
8000c3ce:	c0 c3       	brcs	8000c3e6 <__avr32_s32_to_f64+0x2c>
8000c3d0:	f0 0e 11 20 	rsub	lr,r8,32
8000c3d4:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3d8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c3dc:	1c 4b       	or	r11,lr
8000c3de:	f4 08 09 4a 	lsl	r10,r10,r8
8000c3e2:	10 19       	sub	r9,r8
8000c3e4:	c0 b8       	rjmp	8000c3fa <__avr32_s32_to_f64+0x40>
8000c3e6:	f4 08 12 00 	clz	r8,r10
8000c3ea:	f9 b8 03 00 	movlo	r8,0
8000c3ee:	f7 b8 02 e0 	subhs	r8,-32
8000c3f2:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3f6:	30 0a       	mov	r10,0
8000c3f8:	10 19       	sub	r9,r8
8000c3fa:	58 09       	cp.w	r9,0
8000c3fc:	e0 89 00 30 	brgt	8000c45c <__avr32_s32_to_f64+0xa2>
8000c400:	5c 39       	neg	r9
8000c402:	2f f9       	sub	r9,-1
8000c404:	e0 49 00 36 	cp.w	r9,54
8000c408:	c0 43       	brcs	8000c410 <__avr32_s32_to_f64+0x56>
8000c40a:	30 0b       	mov	r11,0
8000c40c:	30 0a       	mov	r10,0
8000c40e:	c2 68       	rjmp	8000c45a <__avr32_s32_to_f64+0xa0>
8000c410:	2f 69       	sub	r9,-10
8000c412:	f2 08 11 20 	rsub	r8,r9,32
8000c416:	e0 49 00 20 	cp.w	r9,32
8000c41a:	c0 b2       	brcc	8000c430 <__avr32_s32_to_f64+0x76>
8000c41c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c420:	f6 08 09 48 	lsl	r8,r11,r8
8000c424:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c428:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c42c:	10 4b       	or	r11,r8
8000c42e:	c0 88       	rjmp	8000c43e <__avr32_s32_to_f64+0x84>
8000c430:	f6 08 09 4e 	lsl	lr,r11,r8
8000c434:	14 4e       	or	lr,r10
8000c436:	16 9a       	mov	r10,r11
8000c438:	30 0b       	mov	r11,0
8000c43a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c43e:	ed ba 00 00 	bld	r10,0x0
8000c442:	c0 92       	brcc	8000c454 <__avr32_s32_to_f64+0x9a>
8000c444:	1c 7e       	tst	lr,lr
8000c446:	c0 41       	brne	8000c44e <__avr32_s32_to_f64+0x94>
8000c448:	ed ba 00 01 	bld	r10,0x1
8000c44c:	c0 42       	brcc	8000c454 <__avr32_s32_to_f64+0x9a>
8000c44e:	2f fa       	sub	r10,-1
8000c450:	f7 bb 02 ff 	subhs	r11,-1
8000c454:	5c fc       	rol	r12
8000c456:	5d 0b       	ror	r11
8000c458:	5d 0a       	ror	r10
8000c45a:	d8 02       	popm	pc
8000c45c:	e0 68 03 ff 	mov	r8,1023
8000c460:	ed ba 00 0b 	bld	r10,0xb
8000c464:	f7 b8 00 ff 	subeq	r8,-1
8000c468:	10 0a       	add	r10,r8
8000c46a:	5c 0b       	acr	r11
8000c46c:	f7 b9 03 fe 	sublo	r9,-2
8000c470:	e0 49 07 ff 	cp.w	r9,2047
8000c474:	c0 55       	brlt	8000c47e <__avr32_s32_to_f64+0xc4>
8000c476:	30 0a       	mov	r10,0
8000c478:	fc 1b ff e0 	movh	r11,0xffe0
8000c47c:	c0 c8       	rjmp	8000c494 <__floatsidf_return_op1>
8000c47e:	ed bb 00 1f 	bld	r11,0x1f
8000c482:	f7 b9 01 01 	subne	r9,1
8000c486:	ab 9a       	lsr	r10,0xb
8000c488:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c48c:	a1 7b       	lsl	r11,0x1
8000c48e:	ab 9b       	lsr	r11,0xb
8000c490:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c494 <__floatsidf_return_op1>:
8000c494:	a1 7c       	lsl	r12,0x1
8000c496:	5d 0b       	ror	r11
8000c498:	d8 02       	popm	pc

8000c49a <__avr32_f64_cmp_eq>:
8000c49a:	10 3a       	cp.w	r10,r8
8000c49c:	f2 0b 13 00 	cpc	r11,r9
8000c4a0:	c0 80       	breq	8000c4b0 <__avr32_f64_cmp_eq+0x16>
8000c4a2:	a1 7b       	lsl	r11,0x1
8000c4a4:	a1 79       	lsl	r9,0x1
8000c4a6:	14 4b       	or	r11,r10
8000c4a8:	12 4b       	or	r11,r9
8000c4aa:	10 4b       	or	r11,r8
8000c4ac:	5e 0f       	reteq	1
8000c4ae:	5e fd       	retal	0
8000c4b0:	a1 7b       	lsl	r11,0x1
8000c4b2:	fc 1c ff e0 	movh	r12,0xffe0
8000c4b6:	58 0a       	cp.w	r10,0
8000c4b8:	f8 0b 13 00 	cpc	r11,r12
8000c4bc:	5e 8f       	retls	1
8000c4be:	5e fd       	retal	0

8000c4c0 <__avr32_f64_cmp_ge>:
8000c4c0:	1a de       	st.w	--sp,lr
8000c4c2:	1a d7       	st.w	--sp,r7
8000c4c4:	a1 7b       	lsl	r11,0x1
8000c4c6:	5f 3c       	srlo	r12
8000c4c8:	a1 79       	lsl	r9,0x1
8000c4ca:	5f 37       	srlo	r7
8000c4cc:	5c fc       	rol	r12
8000c4ce:	fc 1e ff e0 	movh	lr,0xffe0
8000c4d2:	58 0a       	cp.w	r10,0
8000c4d4:	fc 0b 13 00 	cpc	r11,lr
8000c4d8:	e0 8b 00 1d 	brhi	8000c512 <__avr32_f64_cmp_ge+0x52>
8000c4dc:	58 08       	cp.w	r8,0
8000c4de:	fc 09 13 00 	cpc	r9,lr
8000c4e2:	e0 8b 00 18 	brhi	8000c512 <__avr32_f64_cmp_ge+0x52>
8000c4e6:	58 0b       	cp.w	r11,0
8000c4e8:	f5 ba 00 00 	subfeq	r10,0
8000c4ec:	c1 50       	breq	8000c516 <__avr32_f64_cmp_ge+0x56>
8000c4ee:	1b 07       	ld.w	r7,sp++
8000c4f0:	1b 0e       	ld.w	lr,sp++
8000c4f2:	58 3c       	cp.w	r12,3
8000c4f4:	c0 a0       	breq	8000c508 <__avr32_f64_cmp_ge+0x48>
8000c4f6:	58 1c       	cp.w	r12,1
8000c4f8:	c0 33       	brcs	8000c4fe <__avr32_f64_cmp_ge+0x3e>
8000c4fa:	5e 0f       	reteq	1
8000c4fc:	5e 1d       	retne	0
8000c4fe:	10 3a       	cp.w	r10,r8
8000c500:	f2 0b 13 00 	cpc	r11,r9
8000c504:	5e 2f       	reths	1
8000c506:	5e 3d       	retlo	0
8000c508:	14 38       	cp.w	r8,r10
8000c50a:	f6 09 13 00 	cpc	r9,r11
8000c50e:	5e 2f       	reths	1
8000c510:	5e 3d       	retlo	0
8000c512:	1b 07       	ld.w	r7,sp++
8000c514:	d8 0a       	popm	pc,r12=0
8000c516:	58 17       	cp.w	r7,1
8000c518:	5f 0c       	sreq	r12
8000c51a:	58 09       	cp.w	r9,0
8000c51c:	f5 b8 00 00 	subfeq	r8,0
8000c520:	1b 07       	ld.w	r7,sp++
8000c522:	1b 0e       	ld.w	lr,sp++
8000c524:	5e 0f       	reteq	1
8000c526:	5e fc       	retal	r12

8000c528 <__avr32_f64_cmp_lt>:
8000c528:	1a de       	st.w	--sp,lr
8000c52a:	1a d7       	st.w	--sp,r7
8000c52c:	a1 7b       	lsl	r11,0x1
8000c52e:	5f 3c       	srlo	r12
8000c530:	a1 79       	lsl	r9,0x1
8000c532:	5f 37       	srlo	r7
8000c534:	5c fc       	rol	r12
8000c536:	fc 1e ff e0 	movh	lr,0xffe0
8000c53a:	58 0a       	cp.w	r10,0
8000c53c:	fc 0b 13 00 	cpc	r11,lr
8000c540:	e0 8b 00 1d 	brhi	8000c57a <__avr32_f64_cmp_lt+0x52>
8000c544:	58 08       	cp.w	r8,0
8000c546:	fc 09 13 00 	cpc	r9,lr
8000c54a:	e0 8b 00 18 	brhi	8000c57a <__avr32_f64_cmp_lt+0x52>
8000c54e:	58 0b       	cp.w	r11,0
8000c550:	f5 ba 00 00 	subfeq	r10,0
8000c554:	c1 50       	breq	8000c57e <__avr32_f64_cmp_lt+0x56>
8000c556:	1b 07       	ld.w	r7,sp++
8000c558:	1b 0e       	ld.w	lr,sp++
8000c55a:	58 3c       	cp.w	r12,3
8000c55c:	c0 a0       	breq	8000c570 <__avr32_f64_cmp_lt+0x48>
8000c55e:	58 1c       	cp.w	r12,1
8000c560:	c0 33       	brcs	8000c566 <__avr32_f64_cmp_lt+0x3e>
8000c562:	5e 0d       	reteq	0
8000c564:	5e 1f       	retne	1
8000c566:	10 3a       	cp.w	r10,r8
8000c568:	f2 0b 13 00 	cpc	r11,r9
8000c56c:	5e 2d       	reths	0
8000c56e:	5e 3f       	retlo	1
8000c570:	14 38       	cp.w	r8,r10
8000c572:	f6 09 13 00 	cpc	r9,r11
8000c576:	5e 2d       	reths	0
8000c578:	5e 3f       	retlo	1
8000c57a:	1b 07       	ld.w	r7,sp++
8000c57c:	d8 0a       	popm	pc,r12=0
8000c57e:	58 17       	cp.w	r7,1
8000c580:	5f 1c       	srne	r12
8000c582:	58 09       	cp.w	r9,0
8000c584:	f5 b8 00 00 	subfeq	r8,0
8000c588:	1b 07       	ld.w	r7,sp++
8000c58a:	1b 0e       	ld.w	lr,sp++
8000c58c:	5e 0d       	reteq	0
8000c58e:	5e fc       	retal	r12

8000c590 <__avr32_f64_div>:
8000c590:	eb cd 40 ff 	pushm	r0-r7,lr
8000c594:	f7 e9 20 0e 	eor	lr,r11,r9
8000c598:	f6 07 16 14 	lsr	r7,r11,0x14
8000c59c:	a9 7b       	lsl	r11,0x9
8000c59e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c5a2:	a9 7a       	lsl	r10,0x9
8000c5a4:	bd bb       	sbr	r11,0x1d
8000c5a6:	e4 1b 3f ff 	andh	r11,0x3fff
8000c5aa:	ab d7       	cbr	r7,0xb
8000c5ac:	e0 80 00 cc 	breq	8000c744 <__avr32_f64_div_round_subnormal+0x54>
8000c5b0:	e0 47 07 ff 	cp.w	r7,2047
8000c5b4:	e0 84 00 b5 	brge	8000c71e <__avr32_f64_div_round_subnormal+0x2e>
8000c5b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c5bc:	a9 79       	lsl	r9,0x9
8000c5be:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c5c2:	a9 78       	lsl	r8,0x9
8000c5c4:	bd b9       	sbr	r9,0x1d
8000c5c6:	e4 19 3f ff 	andh	r9,0x3fff
8000c5ca:	ab d6       	cbr	r6,0xb
8000c5cc:	e0 80 00 e2 	breq	8000c790 <__avr32_f64_div_round_subnormal+0xa0>
8000c5d0:	e0 46 07 ff 	cp.w	r6,2047
8000c5d4:	e0 84 00 b2 	brge	8000c738 <__avr32_f64_div_round_subnormal+0x48>
8000c5d8:	0c 17       	sub	r7,r6
8000c5da:	fe 37 fc 01 	sub	r7,-1023
8000c5de:	fc 1c 80 00 	movh	r12,0x8000
8000c5e2:	f8 03 16 01 	lsr	r3,r12,0x1
8000c5e6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c5ea:	5c d4       	com	r4
8000c5ec:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c600:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c604:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c608:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c60c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c610:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c614:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c618:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c61c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c620:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c624:	e4 09 07 40 	macu.d	r0,r2,r9
8000c628:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c62c:	02 04       	add	r4,r1
8000c62e:	5c 05       	acr	r5
8000c630:	a3 65       	lsl	r5,0x2
8000c632:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c636:	a3 64       	lsl	r4,0x2
8000c638:	5c 34       	neg	r4
8000c63a:	f8 05 01 45 	sbc	r5,r12,r5
8000c63e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c642:	e4 05 07 40 	macu.d	r0,r2,r5
8000c646:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c64a:	02 04       	add	r4,r1
8000c64c:	5c 05       	acr	r5
8000c64e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c652:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c656:	e8 02 15 02 	lsl	r2,r4,0x2
8000c65a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c65e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c662:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c666:	02 04       	add	r4,r1
8000c668:	5c 05       	acr	r5
8000c66a:	a3 65       	lsl	r5,0x2
8000c66c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c670:	a3 64       	lsl	r4,0x2
8000c672:	5c 34       	neg	r4
8000c674:	f8 05 01 45 	sbc	r5,r12,r5
8000c678:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c67c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c680:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c684:	02 04       	add	r4,r1
8000c686:	5c 05       	acr	r5
8000c688:	ea 03 15 02 	lsl	r3,r5,0x2
8000c68c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c690:	e8 02 15 02 	lsl	r2,r4,0x2
8000c694:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c698:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c69c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c6a0:	02 02       	add	r2,r1
8000c6a2:	5c 03       	acr	r3
8000c6a4:	ed b3 00 1c 	bld	r3,0x1c
8000c6a8:	c0 90       	breq	8000c6ba <__avr32_f64_div+0x12a>
8000c6aa:	a1 72       	lsl	r2,0x1
8000c6ac:	5c f3       	rol	r3
8000c6ae:	20 17       	sub	r7,1
8000c6b0:	a3 9a       	lsr	r10,0x3
8000c6b2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c6b6:	a3 9b       	lsr	r11,0x3
8000c6b8:	c0 58       	rjmp	8000c6c2 <__avr32_f64_div+0x132>
8000c6ba:	a5 8a       	lsr	r10,0x4
8000c6bc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c6c0:	a5 8b       	lsr	r11,0x4
8000c6c2:	58 07       	cp.w	r7,0
8000c6c4:	e0 8a 00 8b 	brle	8000c7da <__avr32_f64_div_res_subnormal>
8000c6c8:	e0 12 ff 00 	andl	r2,0xff00
8000c6cc:	e8 12 00 80 	orl	r2,0x80
8000c6d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6e0:	00 05       	add	r5,r0
8000c6e2:	f0 01 00 48 	adc	r8,r8,r1
8000c6e6:	5c 09       	acr	r9
8000c6e8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6ec:	58 04       	cp.w	r4,0
8000c6ee:	5c 25       	cpc	r5

8000c6f0 <__avr32_f64_div_round_subnormal>:
8000c6f0:	f4 08 13 00 	cpc	r8,r10
8000c6f4:	f6 09 13 00 	cpc	r9,r11
8000c6f8:	5f 36       	srlo	r6
8000c6fa:	f8 06 17 00 	moveq	r6,r12
8000c6fe:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c702:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c706:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c70a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c70e:	ed be 00 1f 	bld	lr,0x1f
8000c712:	ef bb 00 1f 	bst	r11,0x1f
8000c716:	0c 0a       	add	r10,r6
8000c718:	5c 0b       	acr	r11
8000c71a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c71e:	e4 1b 00 0f 	andh	r11,0xf
8000c722:	14 4b       	or	r11,r10
8000c724:	e0 81 00 a7 	brne	8000c872 <__avr32_f64_div_res_subnormal+0x98>
8000c728:	f2 06 16 14 	lsr	r6,r9,0x14
8000c72c:	ab d6       	cbr	r6,0xb
8000c72e:	e0 46 07 ff 	cp.w	r6,2047
8000c732:	e0 81 00 a4 	brne	8000c87a <__avr32_f64_div_res_subnormal+0xa0>
8000c736:	c9 e8       	rjmp	8000c872 <__avr32_f64_div_res_subnormal+0x98>
8000c738:	e4 19 00 0f 	andh	r9,0xf
8000c73c:	10 49       	or	r9,r8
8000c73e:	e0 81 00 9a 	brne	8000c872 <__avr32_f64_div_res_subnormal+0x98>
8000c742:	c9 28       	rjmp	8000c866 <__avr32_f64_div_res_subnormal+0x8c>
8000c744:	a3 7b       	lsl	r11,0x3
8000c746:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c74a:	a3 7a       	lsl	r10,0x3
8000c74c:	f5 eb 10 04 	or	r4,r10,r11
8000c750:	e0 80 00 a0 	breq	8000c890 <__avr32_f64_div_op1_zero>
8000c754:	f6 04 12 00 	clz	r4,r11
8000c758:	c1 70       	breq	8000c786 <__avr32_f64_div_round_subnormal+0x96>
8000c75a:	c0 c3       	brcs	8000c772 <__avr32_f64_div_round_subnormal+0x82>
8000c75c:	e8 05 11 20 	rsub	r5,r4,32
8000c760:	f6 04 09 4b 	lsl	r11,r11,r4
8000c764:	f4 05 0a 45 	lsr	r5,r10,r5
8000c768:	0a 4b       	or	r11,r5
8000c76a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c76e:	08 17       	sub	r7,r4
8000c770:	c0 b8       	rjmp	8000c786 <__avr32_f64_div_round_subnormal+0x96>
8000c772:	f4 04 12 00 	clz	r4,r10
8000c776:	f9 b4 03 00 	movlo	r4,0
8000c77a:	f7 b4 02 e0 	subhs	r4,-32
8000c77e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c782:	30 0a       	mov	r10,0
8000c784:	08 17       	sub	r7,r4
8000c786:	a3 8a       	lsr	r10,0x2
8000c788:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c78c:	a3 8b       	lsr	r11,0x2
8000c78e:	c1 1b       	rjmp	8000c5b0 <__avr32_f64_div+0x20>
8000c790:	a3 79       	lsl	r9,0x3
8000c792:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c796:	a3 78       	lsl	r8,0x3
8000c798:	f3 e8 10 04 	or	r4,r9,r8
8000c79c:	c6 f0       	breq	8000c87a <__avr32_f64_div_res_subnormal+0xa0>
8000c79e:	f2 04 12 00 	clz	r4,r9
8000c7a2:	c1 70       	breq	8000c7d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c7a4:	c0 c3       	brcs	8000c7bc <__avr32_f64_div_round_subnormal+0xcc>
8000c7a6:	e8 05 11 20 	rsub	r5,r4,32
8000c7aa:	f2 04 09 49 	lsl	r9,r9,r4
8000c7ae:	f0 05 0a 45 	lsr	r5,r8,r5
8000c7b2:	0a 49       	or	r9,r5
8000c7b4:	f0 04 09 48 	lsl	r8,r8,r4
8000c7b8:	08 16       	sub	r6,r4
8000c7ba:	c0 b8       	rjmp	8000c7d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c7bc:	f0 04 12 00 	clz	r4,r8
8000c7c0:	f9 b4 03 00 	movlo	r4,0
8000c7c4:	f7 b4 02 e0 	subhs	r4,-32
8000c7c8:	f0 04 09 49 	lsl	r9,r8,r4
8000c7cc:	30 08       	mov	r8,0
8000c7ce:	08 16       	sub	r6,r4
8000c7d0:	a3 88       	lsr	r8,0x2
8000c7d2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c7d6:	a3 89       	lsr	r9,0x2
8000c7d8:	cf ca       	rjmp	8000c5d0 <__avr32_f64_div+0x40>

8000c7da <__avr32_f64_div_res_subnormal>:
8000c7da:	5c 37       	neg	r7
8000c7dc:	2f f7       	sub	r7,-1
8000c7de:	f1 b7 04 c0 	satu	r7,0x6
8000c7e2:	e0 47 00 20 	cp.w	r7,32
8000c7e6:	c1 54       	brge	8000c810 <__avr32_f64_div_res_subnormal+0x36>
8000c7e8:	ee 06 11 20 	rsub	r6,r7,32
8000c7ec:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7f0:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7f4:	18 42       	or	r2,r12
8000c7f6:	e6 07 0a 43 	lsr	r3,r3,r7
8000c7fa:	f4 06 09 41 	lsl	r1,r10,r6
8000c7fe:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c802:	f6 06 09 4c 	lsl	r12,r11,r6
8000c806:	18 4a       	or	r10,r12
8000c808:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c80c:	30 00       	mov	r0,0
8000c80e:	c1 58       	rjmp	8000c838 <__avr32_f64_div_res_subnormal+0x5e>
8000c810:	ee 06 11 20 	rsub	r6,r7,32
8000c814:	f9 b0 00 00 	moveq	r0,0
8000c818:	f9 bc 00 00 	moveq	r12,0
8000c81c:	c0 50       	breq	8000c826 <__avr32_f64_div_res_subnormal+0x4c>
8000c81e:	f4 06 09 40 	lsl	r0,r10,r6
8000c822:	f6 06 09 4c 	lsl	r12,r11,r6
8000c826:	e6 07 0a 42 	lsr	r2,r3,r7
8000c82a:	30 03       	mov	r3,0
8000c82c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c830:	18 41       	or	r1,r12
8000c832:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c836:	30 0b       	mov	r11,0
8000c838:	e0 12 ff 00 	andl	r2,0xff00
8000c83c:	e8 12 00 80 	orl	r2,0x80
8000c840:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c844:	e4 09 07 46 	macu.d	r6,r2,r9
8000c848:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c84c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c850:	0c 05       	add	r5,r6
8000c852:	f0 07 00 48 	adc	r8,r8,r7
8000c856:	5c 09       	acr	r9
8000c858:	30 07       	mov	r7,0
8000c85a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c85e:	00 34       	cp.w	r4,r0
8000c860:	e2 05 13 00 	cpc	r5,r1
8000c864:	c4 6b       	rjmp	8000c6f0 <__avr32_f64_div_round_subnormal>
8000c866:	1c 9b       	mov	r11,lr
8000c868:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c86c:	30 0a       	mov	r10,0
8000c86e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c872:	3f fb       	mov	r11,-1
8000c874:	30 0a       	mov	r10,0
8000c876:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c87a:	f5 eb 10 04 	or	r4,r10,r11
8000c87e:	c0 90       	breq	8000c890 <__avr32_f64_div_op1_zero>
8000c880:	1c 9b       	mov	r11,lr
8000c882:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c886:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c88a:	30 0a       	mov	r10,0
8000c88c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c890 <__avr32_f64_div_op1_zero>:
8000c890:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c894:	ce f0       	breq	8000c872 <__avr32_f64_div_res_subnormal+0x98>
8000c896:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c89a:	e0 44 07 ff 	cp.w	r4,2047
8000c89e:	ce 41       	brne	8000c866 <__avr32_f64_div_res_subnormal+0x8c>
8000c8a0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c8a4:	ce 10       	breq	8000c866 <__avr32_f64_div_res_subnormal+0x8c>
8000c8a6:	ce 6b       	rjmp	8000c872 <__avr32_f64_div_res_subnormal+0x98>

8000c8a8 <__avr32_udiv64>:
8000c8a8:	d4 31       	pushm	r0-r7,lr
8000c8aa:	1a 97       	mov	r7,sp
8000c8ac:	20 3d       	sub	sp,12
8000c8ae:	10 9c       	mov	r12,r8
8000c8b0:	12 9e       	mov	lr,r9
8000c8b2:	14 93       	mov	r3,r10
8000c8b4:	58 09       	cp.w	r9,0
8000c8b6:	e0 81 00 bd 	brne	8000ca30 <__avr32_udiv64+0x188>
8000c8ba:	16 38       	cp.w	r8,r11
8000c8bc:	e0 88 00 40 	brls	8000c93c <__avr32_udiv64+0x94>
8000c8c0:	f0 08 12 00 	clz	r8,r8
8000c8c4:	c0 d0       	breq	8000c8de <__avr32_udiv64+0x36>
8000c8c6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c8ca:	f0 09 11 20 	rsub	r9,r8,32
8000c8ce:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8d2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c8d6:	f4 08 09 43 	lsl	r3,r10,r8
8000c8da:	f3 eb 10 0b 	or	r11,r9,r11
8000c8de:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c8e2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c8e6:	f6 0e 0d 00 	divu	r0,r11,lr
8000c8ea:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8ee:	00 99       	mov	r9,r0
8000c8f0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8f4:	e0 0a 02 48 	mul	r8,r0,r10
8000c8f8:	10 3b       	cp.w	r11,r8
8000c8fa:	c0 a2       	brcc	8000c90e <__avr32_udiv64+0x66>
8000c8fc:	20 19       	sub	r9,1
8000c8fe:	18 0b       	add	r11,r12
8000c900:	18 3b       	cp.w	r11,r12
8000c902:	c0 63       	brcs	8000c90e <__avr32_udiv64+0x66>
8000c904:	10 3b       	cp.w	r11,r8
8000c906:	f7 b9 03 01 	sublo	r9,1
8000c90a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c90e:	f6 08 01 01 	sub	r1,r11,r8
8000c912:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c916:	e2 0e 0d 00 	divu	r0,r1,lr
8000c91a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c91e:	00 98       	mov	r8,r0
8000c920:	e0 0a 02 4a 	mul	r10,r0,r10
8000c924:	14 33       	cp.w	r3,r10
8000c926:	c0 82       	brcc	8000c936 <__avr32_udiv64+0x8e>
8000c928:	20 18       	sub	r8,1
8000c92a:	18 03       	add	r3,r12
8000c92c:	18 33       	cp.w	r3,r12
8000c92e:	c0 43       	brcs	8000c936 <__avr32_udiv64+0x8e>
8000c930:	14 33       	cp.w	r3,r10
8000c932:	f7 b8 03 01 	sublo	r8,1
8000c936:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c93a:	cd f8       	rjmp	8000caf8 <__avr32_udiv64+0x250>
8000c93c:	58 08       	cp.w	r8,0
8000c93e:	c0 51       	brne	8000c948 <__avr32_udiv64+0xa0>
8000c940:	30 19       	mov	r9,1
8000c942:	f2 08 0d 08 	divu	r8,r9,r8
8000c946:	10 9c       	mov	r12,r8
8000c948:	f8 06 12 00 	clz	r6,r12
8000c94c:	c0 41       	brne	8000c954 <__avr32_udiv64+0xac>
8000c94e:	18 1b       	sub	r11,r12
8000c950:	30 19       	mov	r9,1
8000c952:	c4 08       	rjmp	8000c9d2 <__avr32_udiv64+0x12a>
8000c954:	ec 01 11 20 	rsub	r1,r6,32
8000c958:	f4 01 0a 49 	lsr	r9,r10,r1
8000c95c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c960:	f6 06 09 48 	lsl	r8,r11,r6
8000c964:	f6 01 0a 41 	lsr	r1,r11,r1
8000c968:	f3 e8 10 08 	or	r8,r9,r8
8000c96c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c970:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c974:	e2 03 0d 00 	divu	r0,r1,r3
8000c978:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c97c:	00 9e       	mov	lr,r0
8000c97e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c982:	e0 05 02 49 	mul	r9,r0,r5
8000c986:	12 3b       	cp.w	r11,r9
8000c988:	c0 a2       	brcc	8000c99c <__avr32_udiv64+0xf4>
8000c98a:	20 1e       	sub	lr,1
8000c98c:	18 0b       	add	r11,r12
8000c98e:	18 3b       	cp.w	r11,r12
8000c990:	c0 63       	brcs	8000c99c <__avr32_udiv64+0xf4>
8000c992:	12 3b       	cp.w	r11,r9
8000c994:	f7 be 03 01 	sublo	lr,1
8000c998:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c99c:	12 1b       	sub	r11,r9
8000c99e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c9a2:	f6 03 0d 02 	divu	r2,r11,r3
8000c9a6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c9aa:	04 99       	mov	r9,r2
8000c9ac:	e4 05 02 4b 	mul	r11,r2,r5
8000c9b0:	16 38       	cp.w	r8,r11
8000c9b2:	c0 a2       	brcc	8000c9c6 <__avr32_udiv64+0x11e>
8000c9b4:	20 19       	sub	r9,1
8000c9b6:	18 08       	add	r8,r12
8000c9b8:	18 38       	cp.w	r8,r12
8000c9ba:	c0 63       	brcs	8000c9c6 <__avr32_udiv64+0x11e>
8000c9bc:	16 38       	cp.w	r8,r11
8000c9be:	f7 b9 03 01 	sublo	r9,1
8000c9c2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c9c6:	f4 06 09 43 	lsl	r3,r10,r6
8000c9ca:	f0 0b 01 0b 	sub	r11,r8,r11
8000c9ce:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c9d2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c9d6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c9da:	f6 06 0d 00 	divu	r0,r11,r6
8000c9de:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9e2:	00 9a       	mov	r10,r0
8000c9e4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9e8:	e0 0e 02 48 	mul	r8,r0,lr
8000c9ec:	10 3b       	cp.w	r11,r8
8000c9ee:	c0 a2       	brcc	8000ca02 <__avr32_udiv64+0x15a>
8000c9f0:	20 1a       	sub	r10,1
8000c9f2:	18 0b       	add	r11,r12
8000c9f4:	18 3b       	cp.w	r11,r12
8000c9f6:	c0 63       	brcs	8000ca02 <__avr32_udiv64+0x15a>
8000c9f8:	10 3b       	cp.w	r11,r8
8000c9fa:	f7 ba 03 01 	sublo	r10,1
8000c9fe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca02:	f6 08 01 01 	sub	r1,r11,r8
8000ca06:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca0a:	e2 06 0d 00 	divu	r0,r1,r6
8000ca0e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca12:	00 98       	mov	r8,r0
8000ca14:	e0 0e 02 4b 	mul	r11,r0,lr
8000ca18:	16 33       	cp.w	r3,r11
8000ca1a:	c0 82       	brcc	8000ca2a <__avr32_udiv64+0x182>
8000ca1c:	20 18       	sub	r8,1
8000ca1e:	18 03       	add	r3,r12
8000ca20:	18 33       	cp.w	r3,r12
8000ca22:	c0 43       	brcs	8000ca2a <__avr32_udiv64+0x182>
8000ca24:	16 33       	cp.w	r3,r11
8000ca26:	f7 b8 03 01 	sublo	r8,1
8000ca2a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca2e:	c6 98       	rjmp	8000cb00 <__avr32_udiv64+0x258>
8000ca30:	16 39       	cp.w	r9,r11
8000ca32:	e0 8b 00 65 	brhi	8000cafc <__avr32_udiv64+0x254>
8000ca36:	f2 09 12 00 	clz	r9,r9
8000ca3a:	c0 b1       	brne	8000ca50 <__avr32_udiv64+0x1a8>
8000ca3c:	10 3a       	cp.w	r10,r8
8000ca3e:	5f 2a       	srhs	r10
8000ca40:	1c 3b       	cp.w	r11,lr
8000ca42:	5f b8       	srhi	r8
8000ca44:	10 4a       	or	r10,r8
8000ca46:	f2 0a 18 00 	cp.b	r10,r9
8000ca4a:	c5 90       	breq	8000cafc <__avr32_udiv64+0x254>
8000ca4c:	30 18       	mov	r8,1
8000ca4e:	c5 98       	rjmp	8000cb00 <__avr32_udiv64+0x258>
8000ca50:	f0 09 09 46 	lsl	r6,r8,r9
8000ca54:	f2 03 11 20 	rsub	r3,r9,32
8000ca58:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca5c:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca60:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca64:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca68:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca6c:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca70:	18 42       	or	r2,r12
8000ca72:	f1 ee 10 0c 	or	r12,r8,lr
8000ca76:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca7e:	e6 01 0d 04 	divu	r4,r3,r1
8000ca82:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca86:	08 9e       	mov	lr,r4
8000ca88:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca8c:	e8 06 02 48 	mul	r8,r4,r6
8000ca90:	10 33       	cp.w	r3,r8
8000ca92:	c0 a2       	brcc	8000caa6 <__avr32_udiv64+0x1fe>
8000ca94:	20 1e       	sub	lr,1
8000ca96:	18 03       	add	r3,r12
8000ca98:	18 33       	cp.w	r3,r12
8000ca9a:	c0 63       	brcs	8000caa6 <__avr32_udiv64+0x1fe>
8000ca9c:	10 33       	cp.w	r3,r8
8000ca9e:	f7 be 03 01 	sublo	lr,1
8000caa2:	e7 dc e3 03 	addcs	r3,r3,r12
8000caa6:	10 13       	sub	r3,r8
8000caa8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000caac:	e6 01 0d 00 	divu	r0,r3,r1
8000cab0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cab4:	00 98       	mov	r8,r0
8000cab6:	e0 06 02 46 	mul	r6,r0,r6
8000caba:	0c 3b       	cp.w	r11,r6
8000cabc:	c0 a2       	brcc	8000cad0 <__avr32_udiv64+0x228>
8000cabe:	20 18       	sub	r8,1
8000cac0:	18 0b       	add	r11,r12
8000cac2:	18 3b       	cp.w	r11,r12
8000cac4:	c0 63       	brcs	8000cad0 <__avr32_udiv64+0x228>
8000cac6:	0c 3b       	cp.w	r11,r6
8000cac8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cacc:	f7 b8 03 01 	sublo	r8,1
8000cad0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cad4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cad8:	0c 1b       	sub	r11,r6
8000cada:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cade:	06 95       	mov	r5,r3
8000cae0:	16 35       	cp.w	r5,r11
8000cae2:	e0 8b 00 0a 	brhi	8000caf6 <__avr32_udiv64+0x24e>
8000cae6:	5f 0b       	sreq	r11
8000cae8:	f4 09 09 49 	lsl	r9,r10,r9
8000caec:	12 32       	cp.w	r2,r9
8000caee:	5f b9       	srhi	r9
8000caf0:	f7 e9 00 09 	and	r9,r11,r9
8000caf4:	c0 60       	breq	8000cb00 <__avr32_udiv64+0x258>
8000caf6:	20 18       	sub	r8,1
8000caf8:	30 09       	mov	r9,0
8000cafa:	c0 38       	rjmp	8000cb00 <__avr32_udiv64+0x258>
8000cafc:	30 09       	mov	r9,0
8000cafe:	12 98       	mov	r8,r9
8000cb00:	10 9a       	mov	r10,r8
8000cb02:	12 93       	mov	r3,r9
8000cb04:	10 92       	mov	r2,r8
8000cb06:	12 9b       	mov	r11,r9
8000cb08:	2f dd       	sub	sp,-12
8000cb0a:	d8 32       	popm	r0-r7,pc

8000cb0c <__avr32_umod64>:
8000cb0c:	d4 31       	pushm	r0-r7,lr
8000cb0e:	1a 97       	mov	r7,sp
8000cb10:	20 3d       	sub	sp,12
8000cb12:	10 9c       	mov	r12,r8
8000cb14:	12 95       	mov	r5,r9
8000cb16:	14 9e       	mov	lr,r10
8000cb18:	16 91       	mov	r1,r11
8000cb1a:	16 96       	mov	r6,r11
8000cb1c:	58 09       	cp.w	r9,0
8000cb1e:	e0 81 00 81 	brne	8000cc20 <__avr32_umod64+0x114>
8000cb22:	16 38       	cp.w	r8,r11
8000cb24:	e0 88 00 12 	brls	8000cb48 <__avr32_umod64+0x3c>
8000cb28:	f0 08 12 00 	clz	r8,r8
8000cb2c:	c4 e0       	breq	8000cbc8 <__avr32_umod64+0xbc>
8000cb2e:	f6 08 09 46 	lsl	r6,r11,r8
8000cb32:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb36:	f0 0b 11 20 	rsub	r11,r8,32
8000cb3a:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb3e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb42:	f7 e6 10 06 	or	r6,r11,r6
8000cb46:	c4 18       	rjmp	8000cbc8 <__avr32_umod64+0xbc>
8000cb48:	58 08       	cp.w	r8,0
8000cb4a:	c0 51       	brne	8000cb54 <__avr32_umod64+0x48>
8000cb4c:	30 19       	mov	r9,1
8000cb4e:	f2 08 0d 08 	divu	r8,r9,r8
8000cb52:	10 9c       	mov	r12,r8
8000cb54:	f8 08 12 00 	clz	r8,r12
8000cb58:	c0 31       	brne	8000cb5e <__avr32_umod64+0x52>
8000cb5a:	18 16       	sub	r6,r12
8000cb5c:	c3 68       	rjmp	8000cbc8 <__avr32_umod64+0xbc>
8000cb5e:	f0 03 11 20 	rsub	r3,r8,32
8000cb62:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb66:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb6a:	ec 08 09 49 	lsl	r9,r6,r8
8000cb6e:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb72:	f7 e9 10 09 	or	r9,r11,r9
8000cb76:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb7e:	e6 05 0d 02 	divu	r2,r3,r5
8000cb82:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb86:	ec 02 02 4b 	mul	r11,r6,r2
8000cb8a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb8e:	16 3e       	cp.w	lr,r11
8000cb90:	c0 72       	brcc	8000cb9e <__avr32_umod64+0x92>
8000cb92:	18 0e       	add	lr,r12
8000cb94:	18 3e       	cp.w	lr,r12
8000cb96:	c0 43       	brcs	8000cb9e <__avr32_umod64+0x92>
8000cb98:	16 3e       	cp.w	lr,r11
8000cb9a:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb9e:	fc 0b 01 03 	sub	r3,lr,r11
8000cba2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cba6:	e6 05 0d 02 	divu	r2,r3,r5
8000cbaa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbae:	a5 36       	mul	r6,r2
8000cbb0:	0c 39       	cp.w	r9,r6
8000cbb2:	c0 72       	brcc	8000cbc0 <__avr32_umod64+0xb4>
8000cbb4:	18 09       	add	r9,r12
8000cbb6:	18 39       	cp.w	r9,r12
8000cbb8:	c0 43       	brcs	8000cbc0 <__avr32_umod64+0xb4>
8000cbba:	0c 39       	cp.w	r9,r6
8000cbbc:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbc0:	f2 06 01 06 	sub	r6,r9,r6
8000cbc4:	f4 08 09 4e 	lsl	lr,r10,r8
8000cbc8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cbcc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cbd0:	ec 0a 0d 02 	divu	r2,r6,r10
8000cbd4:	fc 09 16 10 	lsr	r9,lr,0x10
8000cbd8:	ea 02 02 4b 	mul	r11,r5,r2
8000cbdc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbe0:	16 39       	cp.w	r9,r11
8000cbe2:	c0 72       	brcc	8000cbf0 <__avr32_umod64+0xe4>
8000cbe4:	18 09       	add	r9,r12
8000cbe6:	18 39       	cp.w	r9,r12
8000cbe8:	c0 43       	brcs	8000cbf0 <__avr32_umod64+0xe4>
8000cbea:	16 39       	cp.w	r9,r11
8000cbec:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbf0:	f2 0b 01 0b 	sub	r11,r9,r11
8000cbf4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cbf8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cbfc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cc00:	ea 0a 02 4a 	mul	r10,r5,r10
8000cc04:	14 3e       	cp.w	lr,r10
8000cc06:	c0 72       	brcc	8000cc14 <__avr32_umod64+0x108>
8000cc08:	18 0e       	add	lr,r12
8000cc0a:	18 3e       	cp.w	lr,r12
8000cc0c:	c0 43       	brcs	8000cc14 <__avr32_umod64+0x108>
8000cc0e:	14 3e       	cp.w	lr,r10
8000cc10:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc14:	fc 0a 01 0a 	sub	r10,lr,r10
8000cc18:	30 0b       	mov	r11,0
8000cc1a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cc1e:	c7 b8       	rjmp	8000cd14 <__avr32_umod64+0x208>
8000cc20:	16 39       	cp.w	r9,r11
8000cc22:	e0 8b 00 79 	brhi	8000cd14 <__avr32_umod64+0x208>
8000cc26:	f2 09 12 00 	clz	r9,r9
8000cc2a:	c1 21       	brne	8000cc4e <__avr32_umod64+0x142>
8000cc2c:	10 3a       	cp.w	r10,r8
8000cc2e:	5f 2b       	srhs	r11
8000cc30:	0a 31       	cp.w	r1,r5
8000cc32:	5f ba       	srhi	r10
8000cc34:	f7 ea 10 0a 	or	r10,r11,r10
8000cc38:	f2 0a 18 00 	cp.b	r10,r9
8000cc3c:	c0 60       	breq	8000cc48 <__avr32_umod64+0x13c>
8000cc3e:	fc 08 01 0c 	sub	r12,lr,r8
8000cc42:	e2 05 01 46 	sbc	r6,r1,r5
8000cc46:	18 9e       	mov	lr,r12
8000cc48:	0c 9b       	mov	r11,r6
8000cc4a:	1c 9a       	mov	r10,lr
8000cc4c:	c6 48       	rjmp	8000cd14 <__avr32_umod64+0x208>
8000cc4e:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc52:	f2 06 11 20 	rsub	r6,r9,32
8000cc56:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc5a:	f0 09 09 42 	lsl	r2,r8,r9
8000cc5e:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc62:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc66:	18 48       	or	r8,r12
8000cc68:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc6c:	f4 09 09 43 	lsl	r3,r10,r9
8000cc70:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc74:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc78:	16 4a       	or	r10,r11
8000cc7a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc7e:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc82:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc86:	08 91       	mov	r1,r4
8000cc88:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc8c:	e8 0e 02 46 	mul	r6,r4,lr
8000cc90:	0c 3c       	cp.w	r12,r6
8000cc92:	c0 a2       	brcc	8000cca6 <__avr32_umod64+0x19a>
8000cc94:	20 11       	sub	r1,1
8000cc96:	10 0c       	add	r12,r8
8000cc98:	10 3c       	cp.w	r12,r8
8000cc9a:	c0 63       	brcs	8000cca6 <__avr32_umod64+0x19a>
8000cc9c:	0c 3c       	cp.w	r12,r6
8000cc9e:	f7 b1 03 01 	sublo	r1,1
8000cca2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cca6:	0c 1c       	sub	r12,r6
8000cca8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ccac:	f8 0b 0d 04 	divu	r4,r12,r11
8000ccb0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ccb4:	08 96       	mov	r6,r4
8000ccb6:	e8 0e 02 4e 	mul	lr,r4,lr
8000ccba:	1c 3b       	cp.w	r11,lr
8000ccbc:	c0 a2       	brcc	8000ccd0 <__avr32_umod64+0x1c4>
8000ccbe:	20 16       	sub	r6,1
8000ccc0:	10 0b       	add	r11,r8
8000ccc2:	10 3b       	cp.w	r11,r8
8000ccc4:	c0 63       	brcs	8000ccd0 <__avr32_umod64+0x1c4>
8000ccc6:	1c 3b       	cp.w	r11,lr
8000ccc8:	f7 b6 03 01 	sublo	r6,1
8000cccc:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ccd0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ccd4:	1c 1b       	sub	r11,lr
8000ccd6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ccda:	00 9e       	mov	lr,r0
8000ccdc:	02 9c       	mov	r12,r1
8000ccde:	16 3c       	cp.w	r12,r11
8000cce0:	e0 8b 00 08 	brhi	8000ccf0 <__avr32_umod64+0x1e4>
8000cce4:	5f 06       	sreq	r6
8000cce6:	06 30       	cp.w	r0,r3
8000cce8:	5f ba       	srhi	r10
8000ccea:	ed ea 00 0a 	and	r10,r6,r10
8000ccee:	c0 60       	breq	8000ccfa <__avr32_umod64+0x1ee>
8000ccf0:	fc 02 01 04 	sub	r4,lr,r2
8000ccf4:	f8 08 01 4c 	sbc	r12,r12,r8
8000ccf8:	08 9e       	mov	lr,r4
8000ccfa:	e6 0e 01 0a 	sub	r10,r3,lr
8000ccfe:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cd02:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cd06:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cd0a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cd0e:	f8 01 09 4c 	lsl	r12,r12,r1
8000cd12:	18 4a       	or	r10,r12
8000cd14:	2f dd       	sub	sp,-12
8000cd16:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 88 	sub	pc,pc,28808

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 1f 	rcall	80005544 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 18 	rcall	80005544 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 11 	rcall	80005544 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 0a 	rcall	80005544 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
