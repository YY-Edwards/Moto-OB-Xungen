
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ae58  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d000  8000d000  0000d400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001230  8000d200  8000d200  0000d600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a48  00000004  8000e430  0000ec04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a4c  8000ee78  0000f64c  2**0
                  ALLOC
  7 .bss          00004748  00000a50  8000ee78  0000f650  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f64c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000014a8  00000000  00000000  0000f680  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000304a  00000000  00000000  00010b28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002af3c  00000000  00000000  00013b72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006ffa  00000000  00000000  0003eaae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000cef3  00000000  00000000  00045aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000385c  00000000  00000000  0005299c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007a6b  00000000  00000000  000561f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000eb34  00000000  00000000  0005dc63  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001570  00000000  00000000  0006c798  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c1 d8 	sub	pc,pc,-15912

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d ec       	ld.ub	r12,r6[0x6]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3c f8       	mov	r8,-49
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 18       	sub	r8,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f8       	sub	r8,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d2 00       	acall	0x20
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6d 68       	ld.w	r8,r6[0x58]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 5c       	eor	r12,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;
extern volatile DateTime_t Current_time;
static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000209c:	49 77       	lddpc	r7,800020f8 <app_cfg+0x68>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000209e:	30 62       	mov	r2,6
800020a0:	30 13       	mov	r3,1
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a2:	30 11       	mov	r1,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020a4:	30 c0       	mov	r0,12
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 95       	mov	r5,r8
800020a8:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c0 a1       	brne	800020c8 <app_cfg+0x38>
800020b6:	0f 88       	ld.ub	r8,r7[0x0]
800020b8:	58 08       	cp.w	r8,0
800020ba:	c0 71       	brne	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
800020bc:	ae 81       	st.b	r7[0x0],r1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020be:	00 9b       	mov	r11,r0
800020c0:	06 9c       	mov	r12,r3
800020c2:	f0 1f 00 0f 	mcall	800020fc <app_cfg+0x6c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c6:	c0 d8       	rjmp	800020e0 <app_cfg+0x50>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800020c8:	0f 88       	ld.ub	r8,r7[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 30       	breq	800020d2 <app_cfg+0x42>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
800020ce:	d7 03       	nop
800020d0:	c0 88       	rjmp	800020e0 <app_cfg+0x50>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			nop();
800020d6:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800020d8:	04 9b       	mov	r11,r2
800020da:	06 9c       	mov	r12,r3
800020dc:	f0 1f 00 08 	mcall	800020fc <app_cfg+0x6c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e0:	08 9b       	mov	r11,r4
800020e2:	0a 9c       	mov	r12,r5
800020e4:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020e8:	ce 2b       	rjmp	800020ac <app_cfg+0x1c>
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	6a 58       	ld.w	r8,r5[0x14]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 54       	eor	r4,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d ec       	ld.ub	r12,r6[0x6]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 64       	and	r4,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	3e 84       	mov	r4,-24
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	6c 08       	ld.w	r8,r6[0x0]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	d2 08       	*unknown*
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	71 2c       	ld.w	r12,r8[0x48]

80002118 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002118:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000211a:	48 99       	lddpc	r9,8000213c <app_payload_rx_proc+0x24>
8000211c:	13 88       	ld.ub	r8,r9[0x0]
8000211e:	2f f8       	sub	r8,-1
80002120:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002122:	30 39       	mov	r9,3
80002124:	f2 08 18 00 	cp.b	r8,r9
80002128:	c0 71       	brne	80002136 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000212a:	30 09       	mov	r9,0
8000212c:	48 48       	lddpc	r8,8000213c <app_payload_rx_proc+0x24>
8000212e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002130:	48 4c       	lddpc	r12,80002140 <app_payload_rx_proc+0x28>
80002132:	f0 1f 00 05 	mcall	80002144 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002136:	48 58       	lddpc	r8,80002148 <app_payload_rx_proc+0x30>
80002138:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000213a:	d8 02       	popm	pc
8000213c:	00 00       	add	r0,r0
8000213e:	0a 61       	and	r1,r5
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	d2 0c       	*unknown*
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	71 2c       	ld.w	r12,r8[0x48]
80002148:	00 00       	add	r0,r0
8000214a:	0a 60       	and	r0,r5

8000214c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_brdcst_func+0x10>
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	d2 18       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	71 2c       	ld.w	r12,r8[0x48]

80002160 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_reply_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_reply_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	d2 38       	*unknown*
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	71 2c       	ld.w	r12,r8[0x48]

80002174 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <FD_request_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <FD_request_func+0x10>
	
	
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d2 54       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	71 2c       	ld.w	r12,r8[0x48]

80002188 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002188:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000218a:	48 3c       	lddpc	r12,80002194 <EnOB_brdcst_func+0xc>
8000218c:	f0 1f 00 03 	mcall	80002198 <EnOB_brdcst_func+0x10>
}
80002190:	d8 02       	popm	pc
80002192:	00 00       	add	r0,r0
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d2 70       	acall	0x27
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	71 2c       	ld.w	r12,r8[0x48]

8000219c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000219c:	eb cd 40 80 	pushm	r7,lr
800021a0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800021a2:	19 a9       	ld.ub	r9,r12[0x2]
800021a4:	30 08       	mov	r8,0
800021a6:	f0 09 18 00 	cp.b	r9,r8
800021aa:	c1 91       	brne	800021dc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021ac:	19 b8       	ld.ub	r8,r12[0x3]
800021ae:	30 19       	mov	r9,1
800021b0:	f2 08 18 00 	cp.b	r8,r9
800021b4:	c0 61       	brne	800021c0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021b6:	49 0c       	lddpc	r12,800021f4 <EnOB_reply_func+0x58>
800021b8:	f0 1f 00 10 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021c0:	58 08       	cp.w	r8,0
800021c2:	c0 61       	brne	800021ce <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021c4:	48 ec       	lddpc	r12,800021fc <EnOB_reply_func+0x60>
800021c6:	f0 1f 00 0d 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	48 cc       	lddpc	r12,80002200 <EnOB_reply_func+0x64>
800021d2:	f0 1f 00 0a 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021d6:	2f fd       	sub	sp,-4
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021dc:	48 ac       	lddpc	r12,80002204 <EnOB_reply_func+0x68>
800021de:	f0 1f 00 07 	mcall	800021f8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 9c       	lddpc	r12,80002208 <EnOB_reply_func+0x6c>
800021e8:	f0 1f 00 04 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	d2 88       	*unknown*
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	71 2c       	ld.w	r12,r8[0x48]
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	d2 a0       	acall	0x2a
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	d2 b4       	*unknown*
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	d2 cc       	*unknown*
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	d2 e8       	*unknown*

8000220c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000220e:	19 a9       	ld.ub	r9,r12[0x2]
80002210:	31 18       	mov	r8,17
80002212:	f0 09 18 00 	cp.b	r9,r8
80002216:	c0 41       	brne	8000221e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002218:	48 2c       	lddpc	r12,80002220 <SingleDetection_brdcst_func+0x14>
8000221a:	f0 1f 00 03 	mcall	80002224 <SingleDetection_brdcst_func+0x18>
8000221e:	d8 02       	popm	pc
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	d3 00       	acall	0x30
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	71 2c       	ld.w	r12,r8[0x48]

80002228 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002228:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000222a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000222e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002230:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xb4>
80002232:	f0 1f 00 2c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002236:	0f 88       	ld.ub	r8,r7[0x0]
80002238:	1a d8       	st.w	--sp,r8
8000223a:	4a bc       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xbc>
8000223c:	f0 1f 00 29 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002240:	1a d5       	st.w	--sp,r5
80002242:	4a ac       	lddpc	r12,800022e8 <ButtonConfig_brdcst_func+0xc0>
80002244:	f0 1f 00 27 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002248:	0f a8       	ld.ub	r8,r7[0x2]
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	4a 8c       	lddpc	r12,800022ec <ButtonConfig_brdcst_func+0xc4>
8000224e:	f0 1f 00 25 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002252:	2f dd       	sub	sp,-12
80002254:	58 05       	cp.w	r5,0
80002256:	c4 10       	breq	800022d8 <ButtonConfig_brdcst_func+0xb0>
80002258:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225a:	4a 64       	lddpc	r4,800022f0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225c:	4a 63       	lddpc	r3,800022f4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000225e:	4a 72       	lddpc	r2,800022f8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	4a 71       	lddpc	r1,800022fc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002262:	4a 80       	lddpc	r0,80002300 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002264:	0f b9       	ld.ub	r9,r7[0x3]
80002266:	0f c8       	ld.ub	r8,r7[0x4]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	08 9c       	mov	r12,r4
80002272:	f0 1f 00 1c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002276:	0f d9       	ld.ub	r9,r7[0x5]
80002278:	0f e8       	ld.ub	r8,r7[0x6]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	06 9c       	mov	r12,r3
80002284:	f0 1f 00 17 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002288:	0f f9       	ld.ub	r9,r7[0x7]
8000228a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000228e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002292:	1a d8       	st.w	--sp,r8
80002294:	1a d6       	st.w	--sp,r6
80002296:	04 9c       	mov	r12,r2
80002298:	f0 1f 00 12 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000229c:	ef 39 00 09 	ld.ub	r9,r7[9]
800022a0:	ef 38 00 0a 	ld.ub	r8,r7[10]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	02 9c       	mov	r12,r1
800022ae:	f0 1f 00 0d 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022b2:	2f 8d       	sub	sp,-32
800022b4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022bc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022c0:	1a d8       	st.w	--sp,r8
800022c2:	1a d6       	st.w	--sp,r6
800022c4:	00 9c       	mov	r12,r0
800022c6:	f0 1f 00 07 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
800022ca:	2f f6       	sub	r6,-1
800022cc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ce:	2f ed       	sub	sp,-8
800022d0:	ec 05 18 00 	cp.b	r5,r6
800022d4:	fe 9b ff c8 	brhi	80002264 <ButtonConfig_brdcst_func+0x3c>
800022d8:	d8 32       	popm	r0-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	d3 14       	*unknown*
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	71 2c       	ld.w	r12,r8[0x48]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	d3 34       	*unknown*
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	d3 48       	*unknown*
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	d3 60       	acall	0x36
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d3 80       	acall	0x38
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d3 a8       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	d3 d0       	acall	0x3d
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d3 f4       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d4 1c       	*unknown*

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d4 40       	acall	0x44
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	71 2c       	ld.w	r12,r8[0x48]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d3 34       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d4 58       	*unknown*

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	4a 7c       	lddpc	r12,800023f4 <DataSession_brdcst_func+0xac>
8000235a:	f0 1f 00 28 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	4a 4c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
8000236e:	f0 1f 00 23 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	4a 2c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
8000237a:	f0 1f 00 20 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c3 70       	breq	800023f0 <DataSession_brdcst_func+0xa8>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	4a 04       	lddpc	r4,80002404 <DataSession_brdcst_func+0xbc>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 19 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	49 8c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
800023ac:	f0 1f 00 13 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800023b0:	0d 88       	ld.ub	r8,r6[0x0]
800023b2:	2f fd       	sub	sp,-4
800023b4:	30 39       	mov	r9,3
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c0 51       	brne	800023c4 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
800023bc:	49 4c       	lddpc	r12,8000240c <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 0f 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023c2:	c0 88       	rjmp	800023d2 <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800023c4:	30 49       	mov	r9,4
800023c6:	f2 08 18 00 	cp.b	r8,r9
800023ca:	c0 41       	brne	800023d2 <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
800023cc:	49 1c       	lddpc	r12,80002410 <DataSession_brdcst_func+0xc8>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023d2:	0d a7       	ld.ub	r7,r6[0x2]
800023d4:	0d b8       	ld.ub	r8,r6[0x3]
800023d6:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
800023da:	0d 98       	ld.ub	r8,r6[0x1]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	48 8c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
800023e0:	f0 1f 00 06 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023e4:	5c 77       	castu.h	r7
800023e6:	1a d7       	st.w	--sp,r7
800023e8:	48 6c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
800023ea:	f0 1f 00 04 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023ee:	2f ed       	sub	sp,-8
800023f0:	d8 22       	popm	r4-r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d4 74       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	71 2c       	ld.w	r12,r8[0x48]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d4 88       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d4 a0       	acall	0x4a
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d4 bc       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d4 d4       	*unknown*
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	d4 e0       	acall	0x4e
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d4 f8       	*unknown*

80002414 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
80002418:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000241a:	19 a9       	ld.ub	r9,r12[0x2]
8000241c:	30 08       	mov	r8,0
8000241e:	f0 09 18 00 	cp.b	r9,r8
80002422:	c1 11       	brne	80002444 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002424:	49 3c       	lddpc	r12,80002470 <DataSession_reply_func+0x5c>
80002426:	f0 1f 00 14 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000242a:	0f b8       	ld.ub	r8,r7[0x3]
8000242c:	1a d8       	st.w	--sp,r8
8000242e:	49 3c       	lddpc	r12,80002478 <DataSession_reply_func+0x64>
80002430:	f0 1f 00 11 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002434:	0f c8       	ld.ub	r8,r7[0x4]
80002436:	1a d8       	st.w	--sp,r8
80002438:	49 1c       	lddpc	r12,8000247c <DataSession_reply_func+0x68>
8000243a:	f0 1f 00 0f 	mcall	80002474 <DataSession_reply_func+0x60>
8000243e:	2f ed       	sub	sp,-8
80002440:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002444:	48 fc       	lddpc	r12,80002480 <DataSession_reply_func+0x6c>
80002446:	f0 1f 00 0c 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000244a:	0f a8       	ld.ub	r8,r7[0x2]
8000244c:	1a d8       	st.w	--sp,r8
8000244e:	48 ec       	lddpc	r12,80002484 <DataSession_reply_func+0x70>
80002450:	f0 1f 00 09 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002454:	0f b8       	ld.ub	r8,r7[0x3]
80002456:	1a d8       	st.w	--sp,r8
80002458:	48 cc       	lddpc	r12,80002488 <DataSession_reply_func+0x74>
8000245a:	f0 1f 00 07 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000245e:	0f c8       	ld.ub	r8,r7[0x4]
80002460:	1a d8       	st.w	--sp,r8
80002462:	48 bc       	lddpc	r12,8000248c <DataSession_reply_func+0x78>
80002464:	f0 1f 00 04 	mcall	80002474 <DataSession_reply_func+0x60>
80002468:	2f dd       	sub	sp,-12
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d5 10       	acall	0x51
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	71 2c       	ld.w	r12,r8[0x48]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	d5 20       	acall	0x52
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	d5 2c       	*unknown*
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d5 38       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d5 48       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d5 58       	*unknown*
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	d5 64       	*unknown*

80002490 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002498:	0f 98       	ld.ub	r8,r7[0x1]
8000249a:	1a d8       	st.w	--sp,r8
8000249c:	48 bc       	lddpc	r12,800024c8 <CallControl_brdcst_func+0x38>
8000249e:	f0 1f 00 0c 	mcall	800024cc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024a2:	2f fd       	sub	sp,-4
800024a4:	0f 99       	ld.ub	r9,r7[0x1]
800024a6:	30 38       	mov	r8,3
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c0 41       	brne	800024b4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 88       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024b2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 48       	mov	r8,4
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 41       	brne	800024c4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d5 70       	acall	0x57
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	71 2c       	ld.w	r12,r8[0x48]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 62       	and	r2,r5

800024d4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024d4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024d8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024dc:	0f 99       	ld.ub	r9,r7[0x1]
800024de:	30 08       	mov	r8,0
800024e0:	f0 09 18 00 	cp.b	r9,r8
800024e4:	c0 71       	brne	800024f2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024e6:	48 ac       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x38>
800024e8:	f0 1f 00 0a 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024ec:	30 09       	mov	r9,0
800024ee:	48 a8       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
800024f0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024f2:	0f 99       	ld.ub	r9,r7[0x1]
800024f4:	30 18       	mov	r8,1
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 71       	brne	80002508 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024fc:	48 7c       	lddpc	r12,80002518 <TransmitControl_brdcst_func+0x44>
800024fe:	f0 1f 00 05 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002502:	30 19       	mov	r9,1
80002504:	48 48       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
80002506:	b0 89       	st.b	r8[0x0],r9
80002508:	e3 cd 80 80 	ldm	sp++,r7,pc
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	d5 88       	*unknown*
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	71 2c       	ld.w	r12,r8[0x48]
80002514:	00 00       	add	r0,r0
80002516:	0a 58       	eor	r8,r5
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d5 a0       	acall	0x5a

8000251c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 61       	brne	80002558 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000252e:	48 ec       	lddpc	r12,80002564 <TransmitControl_reply_func+0x48>
80002530:	f0 1f 00 0e 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002534:	0f 98       	ld.ub	r8,r7[0x1]
80002536:	1a d8       	st.w	--sp,r8
80002538:	48 dc       	lddpc	r12,8000256c <TransmitControl_reply_func+0x50>
8000253a:	f0 1f 00 0c 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000253e:	0f a8       	ld.ub	r8,r7[0x2]
80002540:	1a d8       	st.w	--sp,r8
80002542:	48 cc       	lddpc	r12,80002570 <TransmitControl_reply_func+0x54>
80002544:	f0 1f 00 09 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002548:	0f b8       	ld.ub	r8,r7[0x3]
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	48 ac       	lddpc	r12,80002574 <TransmitControl_reply_func+0x58>
8000254e:	f0 1f 00 07 	mcall	80002568 <TransmitControl_reply_func+0x4c>
80002552:	2f dd       	sub	sp,-12
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002558:	48 8c       	lddpc	r12,80002578 <TransmitControl_reply_func+0x5c>
8000255a:	f0 1f 00 04 	mcall	80002568 <TransmitControl_reply_func+0x4c>
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d5 b4       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	71 2c       	ld.w	r12,r8[0x48]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d5 d0       	acall	0x5d
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d5 e4       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d6 00       	acall	0x60
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d6 10       	acall	0x61

8000257c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 51       	brne	80002590 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002588:	48 4c       	lddpc	r12,80002598 <AudioRoutingControl_reply_func+0x1c>
8000258a:	f0 1f 00 05 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
8000258e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002590:	48 4c       	lddpc	r12,800025a0 <AudioRoutingControl_reply_func+0x24>
80002592:	f0 1f 00 03 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
80002596:	d8 02       	popm	pc
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d6 28       	*unknown*
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	71 2c       	ld.w	r12,r8[0x48]
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	d6 38       	*unknown*

800025a4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025ac:	0f 89       	ld.ub	r9,r7[0x0]
800025ae:	30 08       	mov	r8,0
800025b0:	f0 09 18 00 	cp.b	r9,r8
800025b4:	c1 b1       	brne	800025ea <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b6:	0f b8       	ld.ub	r8,r7[0x3]
800025b8:	31 09       	mov	r9,16
800025ba:	f2 08 18 00 	cp.b	r8,r9
800025be:	c0 f1       	brne	800025dc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025c0:	48 dc       	lddpc	r12,800025f4 <Volume_reply_func+0x50>
800025c2:	f0 1f 00 0e 	mcall	800025f8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c6:	0f 99       	ld.ub	r9,r7[0x1]
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ce:	1a d8       	st.w	--sp,r8
800025d0:	48 bc       	lddpc	r12,800025fc <Volume_reply_func+0x58>
800025d2:	f0 1f 00 0a 	mcall	800025f8 <Volume_reply_func+0x54>
800025d6:	2f fd       	sub	sp,-4
800025d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025dc:	1a d8       	st.w	--sp,r8
800025de:	48 9c       	lddpc	r12,80002600 <Volume_reply_func+0x5c>
800025e0:	f0 1f 00 06 	mcall	800025f8 <Volume_reply_func+0x54>
800025e4:	2f fd       	sub	sp,-4
800025e6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ea:	48 7c       	lddpc	r12,80002604 <Volume_reply_func+0x60>
800025ec:	f0 1f 00 03 	mcall	800025f8 <Volume_reply_func+0x54>
800025f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d6 4c       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	71 2c       	ld.w	r12,r8[0x48]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d6 60       	acall	0x66
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	d6 7c       	*unknown*
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	d6 94       	*unknown*

80002608 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002608:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000260a:	19 d9       	ld.ub	r9,r12[0x5]
8000260c:	30 08       	mov	r8,0
8000260e:	f0 09 18 00 	cp.b	r9,r8
80002612:	c0 81       	brne	80002622 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002614:	10 99       	mov	r9,r8
80002616:	48 78       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002618:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000261a:	48 7c       	lddpc	r12,80002634 <spk_brdcst_func+0x2c>
8000261c:	f0 1f 00 07 	mcall	80002638 <spk_brdcst_func+0x30>
80002620:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002622:	30 19       	mov	r9,1
80002624:	48 38       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002626:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002628:	48 5c       	lddpc	r12,8000263c <spk_brdcst_func+0x34>
8000262a:	f0 1f 00 04 	mcall	80002638 <spk_brdcst_func+0x30>
8000262e:	d8 02       	popm	pc
80002630:	00 00       	add	r0,r0
80002632:	0a 50       	eor	r0,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d6 ac       	*unknown*
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	71 2c       	ld.w	r12,r8[0x48]
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	d6 bc       	*unknown*

80002640 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002640:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002642:	19 a9       	ld.ub	r9,r12[0x2]
80002644:	30 08       	mov	r8,0
80002646:	f0 09 18 00 	cp.b	r9,r8
8000264a:	c0 f1       	brne	80002668 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000264c:	19 e9       	ld.ub	r9,r12[0x6]
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c0 40       	breq	8000265a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002654:	30 19       	mov	r9,1
80002656:	48 98       	lddpc	r8,80002678 <spk_reply_func+0x38>
80002658:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000265a:	19 e8       	ld.ub	r8,r12[0x6]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 8c       	lddpc	r12,8000267c <spk_reply_func+0x3c>
80002660:	f0 1f 00 08 	mcall	80002680 <spk_reply_func+0x40>
80002664:	2f fd       	sub	sp,-4
80002666:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002668:	30 09       	mov	r9,0
8000266a:	48 48       	lddpc	r8,80002678 <spk_reply_func+0x38>
8000266c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266e:	48 6c       	lddpc	r12,80002684 <spk_reply_func+0x44>
80002670:	f0 1f 00 04 	mcall	80002680 <spk_reply_func+0x40>
80002674:	d8 02       	popm	pc
80002676:	00 00       	add	r0,r0
80002678:	00 00       	add	r0,r0
8000267a:	0a 50       	eor	r0,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	d6 c8       	*unknown*
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	71 2c       	ld.w	r12,r8[0x48]
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	d6 d8       	*unknown*

80002688 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000268c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002690:	0f a9       	ld.ub	r9,r7[0x2]
80002692:	30 08       	mov	r8,0
80002694:	f0 09 18 00 	cp.b	r9,r8
80002698:	c0 71       	brne	800026a6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000269a:	48 dc       	lddpc	r12,800026cc <mic_brdcst_func+0x44>
8000269c:	f0 1f 00 0d 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026a0:	30 09       	mov	r9,0
800026a2:	48 d8       	lddpc	r8,800026d4 <mic_brdcst_func+0x4c>
800026a4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a6:	0f a9       	ld.ub	r9,r7[0x2]
800026a8:	31 18       	mov	r8,17
800026aa:	f0 09 18 00 	cp.b	r9,r8
800026ae:	c0 d1       	brne	800026c8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026b0:	48 ac       	lddpc	r12,800026d8 <mic_brdcst_func+0x50>
800026b2:	f0 1f 00 08 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b6:	48 89       	lddpc	r9,800026d4 <mic_brdcst_func+0x4c>
800026b8:	30 18       	mov	r8,1
800026ba:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026bc:	13 89       	ld.ub	r9,r9[0x0]
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c0 31       	brne	800026c8 <mic_brdcst_func+0x40>
800026c4:	48 68       	lddpc	r8,800026dc <mic_brdcst_func+0x54>
800026c6:	11 88       	ld.ub	r8,r8[0x0]
800026c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d6 e4       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	71 2c       	ld.w	r12,r8[0x48]
800026d4:	00 00       	add	r0,r0
800026d6:	0a 65       	and	r5,r5
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d6 f8       	*unknown*
800026dc:	00 00       	add	r0,r0
800026de:	0a 62       	and	r2,r5

800026e0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e8:	49 ac       	lddpc	r12,80002750 <mic_reply_func+0x70>
800026ea:	f0 1f 00 1b 	mcall	80002754 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ee:	0f 89       	ld.ub	r9,r7[0x0]
800026f0:	30 08       	mov	r8,0
800026f2:	f0 09 18 00 	cp.b	r9,r8
800026f6:	c2 71       	brne	80002744 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f8:	0f 98       	ld.ub	r8,r7[0x1]
800026fa:	30 29       	mov	r9,2
800026fc:	f2 08 18 00 	cp.b	r8,r9
80002700:	c1 b1       	brne	80002736 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002702:	49 6c       	lddpc	r12,80002758 <mic_reply_func+0x78>
80002704:	f0 1f 00 14 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002708:	0f a8       	ld.ub	r8,r7[0x2]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	49 4c       	lddpc	r12,8000275c <mic_reply_func+0x7c>
8000270e:	f0 1f 00 12 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002712:	0f b8       	ld.ub	r8,r7[0x3]
80002714:	1a d8       	st.w	--sp,r8
80002716:	49 3c       	lddpc	r12,80002760 <mic_reply_func+0x80>
80002718:	f0 1f 00 0f 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000271c:	0f c8       	ld.ub	r8,r7[0x4]
8000271e:	1a d8       	st.w	--sp,r8
80002720:	49 1c       	lddpc	r12,80002764 <mic_reply_func+0x84>
80002722:	f0 1f 00 0d 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002726:	0f d8       	ld.ub	r8,r7[0x5]
80002728:	1a d8       	st.w	--sp,r8
8000272a:	49 0c       	lddpc	r12,80002768 <mic_reply_func+0x88>
8000272c:	f0 1f 00 0a 	mcall	80002754 <mic_reply_func+0x74>
80002730:	2f cd       	sub	sp,-16
80002732:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002736:	1a d8       	st.w	--sp,r8
80002738:	48 dc       	lddpc	r12,8000276c <mic_reply_func+0x8c>
8000273a:	f0 1f 00 07 	mcall	80002754 <mic_reply_func+0x74>
8000273e:	2f fd       	sub	sp,-4
80002740:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002744:	48 bc       	lddpc	r12,80002770 <mic_reply_func+0x90>
80002746:	f0 1f 00 04 	mcall	80002754 <mic_reply_func+0x74>
8000274a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274e:	00 00       	add	r0,r0
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	d7 0c       	*unknown*
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	71 2c       	ld.w	r12,r8[0x48]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	d7 1c       	*unknown*
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	d7 30       	acall	0x73
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	d7 44       	*unknown*
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	d7 60       	acall	0x76
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d7 78       	*unknown*
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	d7 90       	acall	0x79
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	d7 a8       	*unknown*

80002774 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002774:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002778:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000277c:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x34>
8000277e:	f0 1f 00 0c 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002782:	0f 88       	ld.ub	r8,r7[0x0]
80002784:	1a d8       	st.w	--sp,r8
80002786:	48 bc       	lddpc	r12,800027b0 <dcm_brdcst_func+0x3c>
80002788:	f0 1f 00 09 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000278c:	0f a8       	ld.ub	r8,r7[0x2]
8000278e:	1a d8       	st.w	--sp,r8
80002790:	48 9c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x40>
80002792:	f0 1f 00 07 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002796:	0f 98       	ld.ub	r8,r7[0x1]
80002798:	1a d8       	st.w	--sp,r8
8000279a:	48 8c       	lddpc	r12,800027b8 <dcm_brdcst_func+0x44>
8000279c:	f0 1f 00 04 	mcall	800027ac <dcm_brdcst_func+0x38>
800027a0:	2f dd       	sub	sp,-12
	
	
}
800027a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a6:	00 00       	add	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	d7 b8       	*unknown*
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	71 2c       	ld.w	r12,r8[0x48]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d7 cc       	*unknown*
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d7 e0       	acall	0x7e
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d7 f8       	*unknown*

800027bc <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027bc:	eb cd 40 80 	pushm	r7,lr
800027c0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027c2:	19 a9       	ld.ub	r9,r12[0x2]
800027c4:	30 08       	mov	r8,0
800027c6:	f0 09 18 00 	cp.b	r9,r8
800027ca:	c1 b1       	brne	80002800 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027cc:	19 b8       	ld.ub	r8,r12[0x3]
800027ce:	30 19       	mov	r9,1
800027d0:	f2 08 18 00 	cp.b	r8,r9
800027d4:	c0 51       	brne	800027de <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d6:	48 ec       	lddpc	r12,8000280c <dcm_reply_func+0x50>
800027d8:	f0 1f 00 0e 	mcall	80002810 <dcm_reply_func+0x54>
800027dc:	c0 a8       	rjmp	800027f0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027de:	58 08       	cp.w	r8,0
800027e0:	c0 51       	brne	800027ea <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027e2:	48 dc       	lddpc	r12,80002814 <dcm_reply_func+0x58>
800027e4:	f0 1f 00 0b 	mcall	80002810 <dcm_reply_func+0x54>
800027e8:	c0 48       	rjmp	800027f0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ea:	48 cc       	lddpc	r12,80002818 <dcm_reply_func+0x5c>
800027ec:	f0 1f 00 09 	mcall	80002810 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027f0:	0f d8       	ld.ub	r8,r7[0x5]
800027f2:	1a d8       	st.w	--sp,r8
800027f4:	48 ac       	lddpc	r12,8000281c <dcm_reply_func+0x60>
800027f6:	f0 1f 00 07 	mcall	80002810 <dcm_reply_func+0x54>
800027fa:	2f fd       	sub	sp,-4
800027fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002800:	48 8c       	lddpc	r12,80002820 <dcm_reply_func+0x64>
80002802:	f0 1f 00 04 	mcall	80002810 <dcm_reply_func+0x54>
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	d8 14       	*unknown*
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	71 2c       	ld.w	r12,r8[0x48]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	d8 28       	*unknown*
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d8 3c       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	d8 50       	acall	0x85
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	d8 5c       	*unknown*

80002824 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002824:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002826:	19 a9       	ld.ub	r9,r12[0x2]
80002828:	30 08       	mov	r8,0
8000282a:	f0 09 18 00 	cp.b	r9,r8
8000282e:	c0 51       	brne	80002838 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x1c>
80002832:	f0 1f 00 05 	mcall	80002844 <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002838:	48 4c       	lddpc	r12,80002848 <ToneControl_reply_func+0x24>
8000283a:	f0 1f 00 03 	mcall	80002844 <ToneControl_reply_func+0x20>
8000283e:	d8 02       	popm	pc
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	d8 68       	*unknown*
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	71 2c       	ld.w	r12,r8[0x48]
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	d8 74       	*unknown*

8000284c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000284c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002850:	19 c7       	ld.ub	r7,r12[0x4]
80002852:	19 d8       	ld.ub	r8,r12[0x5]
80002854:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002858:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000285a:	48 dc       	lddpc	r12,8000288c <Phyuserinput_brdcst_func+0x40>
8000285c:	f0 1f 00 0d 	mcall	80002890 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002860:	36 08       	mov	r8,96
80002862:	f0 07 19 00 	cp.h	r7,r8
80002866:	c1 11       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
80002868:	48 b8       	lddpc	r8,80002894 <Phyuserinput_brdcst_func+0x48>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 18       	mov	r8,1
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 b1       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002874:	31 4b       	mov	r11,20
80002876:	30 1c       	mov	r12,1
80002878:	f0 1f 00 08 	mcall	80002898 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
8000287c:	e0 6c 03 20 	mov	r12,800
80002880:	f0 1f 00 07 	mcall	8000289c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002884:	f0 1f 00 07 	mcall	800028a0 <Phyuserinput_brdcst_func+0x54>
80002888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d8 80       	acall	0x88
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	71 2c       	ld.w	r12,r8[0x48]
80002894:	00 00       	add	r0,r0
80002896:	0a 64       	and	r4,r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	3e 84       	mov	r4,-24
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	6b c0       	ld.w	r0,r5[0x70]
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	4e 58       	lddpc	r8,80002a34 <phy_tx+0x44>

800028a4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028a6:	19 e8       	ld.ub	r8,r12[0x6]
800028a8:	30 19       	mov	r9,1
800028aa:	f2 08 18 00 	cp.b	r8,r9
800028ae:	c0 61       	brne	800028ba <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b0:	48 98       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b2:	70 09       	ld.w	r9,r8[0x0]
800028b4:	a1 a9       	sbr	r9,0x0
800028b6:	91 09       	st.w	r8[0x0],r9
800028b8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ba:	30 29       	mov	r9,2
800028bc:	f2 08 18 00 	cp.b	r8,r9
800028c0:	c0 80       	breq	800028d0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028c2:	48 58       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c4:	70 09       	ld.w	r9,r8[0x0]
800028c6:	e0 19 ff fc 	andl	r9,0xfffc
800028ca:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028cc:	f0 1f 00 03 	mcall	800028d8 <DeviceInitializationStatus_brdcst_func+0x34>
800028d0:	d8 02       	popm	pc
800028d2:	00 00       	add	r0,r0
800028d4:	00 00       	add	r0,r0
800028d6:	0d ec       	ld.ub	r12,r6[0x6]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	3d d8       	mov	r8,-35

800028dc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028dc:	20 1c       	sub	r12,1
800028de:	5c 5c       	castu.b	r12
800028e0:	31 18       	mov	r8,17
800028e2:	f0 0c 18 00 	cp.b	r12,r8
800028e6:	e0 88 00 03 	brls	800028ec <CalculateBurst+0x10>
800028ea:	5e fd       	retal	0
800028ec:	48 28       	lddpc	r8,800028f4 <CalculateBurst+0x18>
800028ee:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028f2:	5e fc       	retal	r12
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d8 a0       	acall	0x8a

800028f8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028f8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028fa:	48 98       	lddpc	r8,8000291c <payload_init+0x24>
800028fc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028fe:	48 98       	lddpc	r8,80002920 <payload_init+0x28>
80002900:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002902:	30 09       	mov	r9,0
80002904:	1a d9       	st.w	--sp,r9
80002906:	1a d9       	st.w	--sp,r9
80002908:	1a d9       	st.w	--sp,r9
8000290a:	30 28       	mov	r8,2
8000290c:	e0 6a 04 00 	mov	r10,1024
80002910:	48 5b       	lddpc	r11,80002924 <payload_init+0x2c>
80002912:	48 6c       	lddpc	r12,80002928 <payload_init+0x30>
80002914:	f0 1f 00 06 	mcall	8000292c <payload_init+0x34>
80002918:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000291a:	d8 02       	popm	pc
8000291c:	00 00       	add	r0,r0
8000291e:	0a 6c       	and	r12,r5
80002920:	00 00       	add	r0,r0
80002922:	0a 70       	tst	r0,r5
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	d8 e8       	*unknown*
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	29 30       	sub	r0,-109
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	6d 68       	ld.w	r8,r6[0x58]

80002930 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002930:	eb cd 40 f8 	pushm	r3-r7,lr
80002934:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002936:	48 e8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002938:	70 08       	ld.w	r8,r8[0x0]
8000293a:	58 08       	cp.w	r8,0
8000293c:	c0 71       	brne	8000294a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000293e:	30 4b       	mov	r11,4
80002940:	30 5c       	mov	r12,5
80002942:	f0 1f 00 0c 	mcall	80002970 <payload_rx_process+0x40>
80002946:	48 a8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002948:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000294a:	48 96       	lddpc	r6,8000296c <payload_rx_process+0x3c>
8000294c:	30 05       	mov	r5,0
8000294e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002950:	48 93       	lddpc	r3,80002974 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002952:	6c 0c       	ld.w	r12,r6[0x0]
80002954:	0a 99       	mov	r9,r5
80002956:	08 9a       	mov	r10,r4
80002958:	1a 9b       	mov	r11,sp
8000295a:	f0 1f 00 08 	mcall	80002978 <payload_rx_process+0x48>
8000295e:	58 1c       	cp.w	r12,1
80002960:	cf 91       	brne	80002952 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002962:	66 08       	ld.w	r8,r3[0x0]
80002964:	40 0c       	lddsp	r12,sp[0x0]
80002966:	5d 18       	icall	r8
80002968:	cf 5b       	rjmp	80002952 <payload_rx_process+0x22>
8000296a:	00 00       	add	r0,r0
8000296c:	00 00       	add	r0,r0
8000296e:	0a a0       	st.w	r5++,r0
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	66 4c       	ld.w	r12,r3[0x10]
80002974:	00 00       	add	r0,r0
80002976:	0a 6c       	and	r12,r5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	63 40       	ld.w	r0,r1[0x50]

8000297c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000297c:	d4 01       	pushm	lr
8000297e:	20 2d       	sub	sp,8
80002980:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002982:	30 09       	mov	r9,0
80002984:	fa ca ff f8 	sub	r10,sp,-8
80002988:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000298a:	1a 9b       	mov	r11,sp
8000298c:	f0 1f 00 02 	mcall	80002994 <set_idle_store_isr+0x18>
}
80002990:	2f ed       	sub	sp,-8
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	64 fc       	ld.w	r12,r2[0x3c]

80002998 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002998:	d4 01       	pushm	lr
8000299a:	20 2d       	sub	sp,8
8000299c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000299e:	58 0c       	cp.w	r12,0
800029a0:	c1 10       	breq	800029c2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029a2:	30 08       	mov	r8,0
800029a4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029a6:	98 88       	ld.uh	r8,r12[0x0]
800029a8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ac:	e0 48 40 00 	cp.w	r8,16384
800029b0:	c0 91       	brne	800029c2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029b2:	48 68       	lddpc	r8,800029c8 <phy_rx+0x30>
800029b4:	70 0c       	ld.w	r12,r8[0x0]
800029b6:	30 09       	mov	r9,0
800029b8:	fa ca ff fc 	sub	r10,sp,-4
800029bc:	1a 9b       	mov	r11,sp
800029be:	f0 1f 00 04 	mcall	800029cc <phy_rx+0x34>
		}	

    }
		
 
}
800029c2:	2f ed       	sub	sp,-8
800029c4:	d8 02       	popm	pc
800029c6:	00 00       	add	r0,r0
800029c8:	00 00       	add	r0,r0
800029ca:	0a b8       	st.h	r5++,r8
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	64 fc       	ld.w	r12,r2[0x3c]

800029d0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029d0:	eb cd 40 80 	pushm	r7,lr
800029d4:	20 1d       	sub	sp,4
800029d6:	fa c7 ff fc 	sub	r7,sp,-4
800029da:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029dc:	30 09       	mov	r9,0
800029de:	12 9a       	mov	r10,r9
800029e0:	1a 9b       	mov	r11,sp
800029e2:	f0 1f 00 03 	mcall	800029ec <set_idle_store+0x1c>
}
800029e6:	2f fd       	sub	sp,-4
800029e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	65 4c       	ld.w	r12,r2[0x50]

800029f0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029f0:	d4 01       	pushm	lr
800029f2:	20 1d       	sub	sp,4
800029f4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029f6:	98 88       	ld.uh	r8,r12[0x0]
800029f8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029fc:	e0 48 40 00 	cp.w	r8,16384
80002a00:	c0 d1       	brne	80002a1a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a02:	49 08       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	58 08       	cp.w	r8,0
80002a08:	c1 a0       	breq	80002a3c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a0a:	48 e8       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a0c:	70 0c       	ld.w	r12,r8[0x0]
80002a0e:	30 09       	mov	r9,0
80002a10:	12 9a       	mov	r10,r9
80002a12:	1a 9b       	mov	r11,sp
80002a14:	f0 1f 00 0c 	mcall	80002a44 <phy_tx+0x54>
80002a18:	c1 28       	rjmp	80002a3c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a1a:	e0 48 10 00 	cp.w	r8,4096
80002a1e:	5f 0a       	sreq	r10
80002a20:	e0 48 20 00 	cp.w	r8,8192
80002a24:	5f 09       	sreq	r9
80002a26:	f5 e9 10 09 	or	r9,r10,r9
80002a2a:	c0 71       	brne	80002a38 <phy_tx+0x48>
80002a2c:	e0 48 50 00 	cp.w	r8,20480
80002a30:	c0 40       	breq	80002a38 <phy_tx+0x48>
80002a32:	e0 48 60 00 	cp.w	r8,24576
80002a36:	c0 31       	brne	80002a3c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a38:	48 48       	lddpc	r8,80002a48 <phy_tx+0x58>
80002a3a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a3c:	2f fd       	sub	sp,-4
80002a3e:	d8 02       	popm	pc
80002a40:	00 00       	add	r0,r0
80002a42:	0a dc       	st.w	--r5,r12
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	65 4c       	ld.w	r12,r2[0x50]
80002a48:	00 00       	add	r0,r0
80002a4a:	0a cc       	st.b	r5++,r12

80002a4c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a4c:	d4 01       	pushm	lr
80002a4e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a50:	30 08       	mov	r8,0
80002a52:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a54:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a56:	1a 9a       	mov	r10,sp
80002a58:	fa cb ff fc 	sub	r11,sp,-4
80002a5c:	f0 1f 00 05 	mcall	80002a70 <get_idle_store_isr+0x24>
80002a60:	58 1c       	cp.w	r12,1
80002a62:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a66:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a6a:	2f ed       	sub	sp,-8
80002a6c:	d8 02       	popm	pc
80002a6e:	00 00       	add	r0,r0
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	62 50       	ld.w	r0,r1[0x14]

80002a74 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a74:	eb cd 40 c0 	pushm	r6-r7,lr
80002a78:	20 1d       	sub	sp,4
80002a7a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a7c:	4b a8       	lddpc	r8,80002b64 <phy_tx_func+0xf0>
80002a7e:	70 08       	ld.w	r8,r8[0x0]
80002a80:	58 08       	cp.w	r8,0
80002a82:	c6 60       	breq	80002b4e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a84:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a86:	30 08       	mov	r8,0
80002a88:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a8a:	4b 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002a8c:	70 08       	ld.w	r8,r8[0x0]
80002a8e:	58 18       	cp.w	r8,1
80002a90:	c2 60       	breq	80002adc <phy_tx_func+0x68>
80002a92:	c0 43       	brcs	80002a9a <phy_tx_func+0x26>
80002a94:	58 28       	cp.w	r8,2
80002a96:	c5 c1       	brne	80002b4e <phy_tx_func+0xda>
80002a98:	c5 58       	rjmp	80002b42 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a9a:	4b 38       	lddpc	r8,80002b64 <phy_tx_func+0xf0>
80002a9c:	70 0c       	ld.w	r12,r8[0x0]
80002a9e:	1a 9a       	mov	r10,sp
80002aa0:	4b 3b       	lddpc	r11,80002b6c <phy_tx_func+0xf8>
80002aa2:	f0 1f 00 34 	mcall	80002b70 <phy_tx_func+0xfc>
80002aa6:	58 1c       	cp.w	r12,1
80002aa8:	c1 41       	brne	80002ad0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aaa:	4b 18       	lddpc	r8,80002b6c <phy_tx_func+0xf8>
80002aac:	70 08       	ld.w	r8,r8[0x0]
80002aae:	90 08       	ld.sh	r8,r8[0x0]
80002ab0:	10 9a       	mov	r10,r8
80002ab2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002ab6:	4b 09       	lddpc	r9,80002b74 <phy_tx_func+0x100>
80002ab8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002aba:	5c 78       	castu.h	r8
80002abc:	ea 18 ab cd 	orh	r8,0xabcd
80002ac0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ac2:	30 19       	mov	r9,1
80002ac4:	4a d8       	lddpc	r8,80002b78 <phy_tx_func+0x104>
80002ac6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac8:	30 19       	mov	r9,1
80002aca:	4a 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002acc:	91 09       	st.w	r8[0x0],r9
80002ace:	c4 08       	rjmp	80002b4e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ad0:	e0 68 5a 5a 	mov	r8,23130
80002ad4:	ea 18 ab cd 	orh	r8,0xabcd
80002ad8:	8f 18       	st.w	r7[0x4],r8
80002ada:	c3 a8       	rjmp	80002b4e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002adc:	4a 7a       	lddpc	r10,80002b78 <phy_tx_func+0x104>
80002ade:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ae0:	4a 39       	lddpc	r9,80002b6c <phy_tx_func+0xf8>
80002ae2:	72 09       	ld.w	r9,r9[0x0]
80002ae4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ae8:	b1 69       	lsl	r9,0x10
80002aea:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aec:	2f f8       	sub	r8,-1
80002aee:	5c 58       	castu.b	r8
80002af0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002af2:	4a 1b       	lddpc	r11,80002b74 <phy_tx_func+0x100>
80002af4:	96 0c       	ld.sh	r12,r11[0x0]
80002af6:	20 2c       	sub	r12,2
80002af8:	5c 8c       	casts.h	r12
80002afa:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002afe:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b00:	30 0b       	mov	r11,0
80002b02:	f6 0a 19 00 	cp.h	r10,r11
80002b06:	e0 89 00 09 	brgt	80002b18 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b0a:	e8 19 00 ba 	orl	r9,0xba
80002b0e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b10:	30 09       	mov	r9,0
80002b12:	49 68       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b14:	91 09       	st.w	r8[0x0],r9
80002b16:	c1 c8       	rjmp	80002b4e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b18:	49 5a       	lddpc	r10,80002b6c <phy_tx_func+0xf8>
80002b1a:	74 0a       	ld.w	r10,r10[0x0]
80002b1c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b20:	14 49       	or	r9,r10
80002b22:	8f 19       	st.w	r7[0x4],r9
80002b24:	2f f8       	sub	r8,-1
80002b26:	49 59       	lddpc	r9,80002b78 <phy_tx_func+0x104>
80002b28:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b2a:	20 2c       	sub	r12,2
80002b2c:	49 28       	lddpc	r8,80002b74 <phy_tx_func+0x100>
80002b2e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b30:	30 08       	mov	r8,0
80002b32:	f0 0c 19 00 	cp.h	r12,r8
80002b36:	e0 89 00 0c 	brgt	80002b4e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b3a:	30 29       	mov	r9,2
80002b3c:	48 b8       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b3e:	91 09       	st.w	r8[0x0],r9
80002b40:	c0 78       	rjmp	80002b4e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b42:	fc 18 00 ba 	movh	r8,0xba
80002b46:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b48:	30 09       	mov	r9,0
80002b4a:	48 88       	lddpc	r8,80002b68 <phy_tx_func+0xf4>
80002b4c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b4e:	e0 68 5a 5a 	mov	r8,23130
80002b52:	ea 18 ab cd 	orh	r8,0xabcd
80002b56:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b58:	30 08       	mov	r8,0
80002b5a:	8f 38       	st.w	r7[0xc],r8
}
80002b5c:	2f fd       	sub	sp,-4
80002b5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0a dc       	st.w	--r5,r12
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 94       	mov	r4,r5
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a e8       	st.h	--r5,r8
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	62 50       	ld.w	r0,r1[0x14]
80002b74:	00 00       	add	r0,r0
80002b76:	0a bc       	st.h	r5++,r12
80002b78:	00 00       	add	r0,r0
80002b7a:	0a 78       	tst	r8,r5

80002b7c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b7c:	d4 01       	pushm	lr
80002b7e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b80:	30 0a       	mov	r10,0
80002b82:	fa cb ff fc 	sub	r11,sp,-4
80002b86:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b88:	14 99       	mov	r9,r10
80002b8a:	1a 9b       	mov	r11,sp
80002b8c:	f0 1f 00 05 	mcall	80002ba0 <get_idle_store+0x24>
80002b90:	58 1c       	cp.w	r12,1
80002b92:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b96:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002b9a:	2f fd       	sub	sp,-4
80002b9c:	d8 02       	popm	pc
80002b9e:	00 00       	add	r0,r0
80002ba0:	80 00       	ld.sh	r0,r0[0x0]
80002ba2:	63 40       	ld.w	r0,r1[0x50]

80002ba4 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002ba4:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002ba6:	48 5b       	lddpc	r11,80002bb8 <phy_init+0x14>
80002ba8:	48 5c       	lddpc	r12,80002bbc <phy_init+0x18>
80002baa:	f0 1f 00 06 	mcall	80002bc0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002bae:	f0 1f 00 06 	mcall	80002bc4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002bb2:	f0 1f 00 06 	mcall	80002bc8 <phy_init+0x24>
	
}
80002bb6:	d8 02       	popm	pc
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	2a 74       	sub	r4,-89
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	2c 2c       	sub	r12,-62
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	3c 74       	mov	r4,-57
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	3c 88       	mov	r8,-56
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	46 30       	lddsp	r0,sp[0x18c]

80002bcc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bcc:	d4 01       	pushm	lr
80002bce:	20 2d       	sub	sp,8
80002bd0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bd2:	30 08       	mov	r8,0
80002bd4:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002bd6:	48 f8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002bd8:	70 08       	ld.w	r8,r8[0x0]
80002bda:	58 08       	cp.w	r8,0
80002bdc:	c0 71       	brne	80002bea <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bde:	30 4b       	mov	r11,4
80002be0:	30 5c       	mov	r12,5
80002be2:	f0 1f 00 0d 	mcall	80002c14 <payload_rx+0x48>
80002be6:	48 b8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002be8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002bea:	48 a8       	lddpc	r8,80002c10 <payload_rx+0x44>
80002bec:	70 0c       	ld.w	r12,r8[0x0]
80002bee:	30 09       	mov	r9,0
80002bf0:	fa ca ff fc 	sub	r10,sp,-4
80002bf4:	1a 9b       	mov	r11,sp
80002bf6:	f0 1f 00 09 	mcall	80002c18 <payload_rx+0x4c>
80002bfa:	c0 91       	brne	80002c0c <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002bfc:	48 88       	lddpc	r8,80002c1c <payload_rx+0x50>
80002bfe:	70 0c       	ld.w	r12,r8[0x0]
80002c00:	40 0b       	lddsp	r11,sp[0x0]
80002c02:	f0 1f 00 08 	mcall	80002c20 <payload_rx+0x54>
		logFromISR("mm");
80002c06:	48 8c       	lddpc	r12,80002c24 <payload_rx+0x58>
80002c08:	f0 1f 00 08 	mcall	80002c28 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002c0c:	2f ed       	sub	sp,-8
80002c0e:	d8 02       	popm	pc
80002c10:	00 00       	add	r0,r0
80002c12:	0a a0       	st.w	r5++,r0
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	66 4c       	ld.w	r12,r3[0x10]
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	64 fc       	ld.w	r12,r2[0x3c]
80002c1c:	00 00       	add	r0,r0
80002c1e:	0a ac       	st.w	r5++,r12
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	29 7c       	sub	r12,-105
80002c24:	80 00       	ld.sh	r0,r0[0x0]
80002c26:	d8 f4       	*unknown*
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	72 b8       	ld.w	r8,r9[0x2c]

80002c2c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c2c:	eb cd 40 e0 	pushm	r5-r7,lr
80002c30:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c32:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c36:	70 08       	ld.w	r8,r8[0x0]
80002c38:	58 08       	cp.w	r8,0
80002c3a:	e0 80 01 08 	breq	80002e4a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c3e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c40:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c44:	70 09       	ld.w	r9,r8[0x0]
80002c46:	2f f9       	sub	r9,-1
80002c48:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c4a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c4e:	70 08       	ld.w	r8,r8[0x0]
80002c50:	58 18       	cp.w	r8,1
80002c52:	e0 80 00 85 	breq	80002d5c <phy_rx_func+0x130>
80002c56:	c0 73       	brcs	80002c64 <phy_rx_func+0x38>
80002c58:	58 28       	cp.w	r8,2
80002c5a:	c5 c0       	breq	80002d12 <phy_rx_func+0xe6>
80002c5c:	58 38       	cp.w	r8,3
80002c5e:	e0 81 00 f6 	brne	80002e4a <phy_rx_func+0x21e>
80002c62:	cd 58       	rjmp	80002e0c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c64:	e0 6a 5a 5a 	mov	r10,23130
80002c68:	ea 1a ab cd 	orh	r10,0xabcd
80002c6c:	14 36       	cp.w	r6,r10
80002c6e:	e0 80 00 ee 	breq	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c72:	ec 08 16 10 	lsr	r8,r6,0x10
80002c76:	e0 48 ab cd 	cp.w	r8,43981
80002c7a:	e0 81 00 e8 	brne	80002e4a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c7e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c82:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c86:	20 28       	sub	r8,2
80002c88:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c8c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c8e:	30 09       	mov	r9,0
80002c90:	f2 08 19 00 	cp.h	r8,r9
80002c94:	e0 8a 00 db 	brle	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002c98:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002c9c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002c9e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002ca2:	70 0c       	ld.w	r12,r8[0x0]
80002ca4:	f0 1f 03 88 	mcall	80003ac4 <phy_rx_func+0xe98>
80002ca8:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002cac:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002cae:	58 0c       	cp.w	r12,0
80002cb0:	e0 80 00 cd 	breq	80002e4a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002cb4:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cb8:	90 09       	ld.sh	r9,r8[0x0]
80002cba:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cbe:	2f f9       	sub	r9,-1
80002cc0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cc2:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cc6:	74 0a       	ld.w	r10,r10[0x0]
80002cc8:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ccc:	76 0b       	ld.w	r11,r11[0x0]
80002cce:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cd2:	2f f9       	sub	r9,-1
80002cd4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002cd6:	e2 16 0f 00 	andl	r6,0xf00,COH
80002cda:	e0 46 01 00 	cp.w	r6,256
80002cde:	c0 c0       	breq	80002cf6 <phy_rx_func+0xca>
80002ce0:	e0 8b 00 05 	brhi	80002cea <phy_rx_func+0xbe>
80002ce4:	58 06       	cp.w	r6,0
80002ce6:	c0 80       	breq	80002cf6 <phy_rx_func+0xca>
80002ce8:	c0 c8       	rjmp	80002d00 <phy_rx_func+0xd4>
80002cea:	e0 46 02 00 	cp.w	r6,512
80002cee:	c0 40       	breq	80002cf6 <phy_rx_func+0xca>
80002cf0:	e0 46 03 00 	cp.w	r6,768
80002cf4:	c0 61       	brne	80002d00 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002cf6:	30 29       	mov	r9,2
80002cf8:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002cfc:	91 09       	st.w	r8[0x0],r9
80002cfe:	ca 68       	rjmp	80002e4a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002d00:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002d04:	70 0c       	ld.w	r12,r8[0x0]
80002d06:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d0a:	70 0b       	ld.w	r11,r8[0x0]
80002d0c:	f0 1f 03 70 	mcall	80003acc <phy_rx_func+0xea0>
80002d10:	c9 d8       	rjmp	80002e4a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d12:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d16:	b1 86       	lsr	r6,0x10
80002d18:	14 06       	add	r6,r10
80002d1a:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d1e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d20:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d24:	90 09       	ld.sh	r9,r8[0x0]
80002d26:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d2a:	76 0b       	ld.w	r11,r11[0x0]
80002d2c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d30:	2f f9       	sub	r9,-1
80002d32:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d34:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d38:	92 08       	ld.sh	r8,r9[0x0]
80002d3a:	20 28       	sub	r8,2
80002d3c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d3e:	30 09       	mov	r9,0
80002d40:	f2 08 19 00 	cp.h	r8,r9
80002d44:	e0 8a 00 07 	brle	80002d52 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d48:	30 19       	mov	r9,1
80002d4a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d4e:	91 09       	st.w	r8[0x0],r9
80002d50:	c7 d8       	rjmp	80002e4a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d52:	30 39       	mov	r9,3
80002d54:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d58:	91 09       	st.w	r8[0x0],r9
80002d5a:	c7 88       	rjmp	80002e4a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d5c:	ec 0a 14 10 	asr	r10,r6,0x10
80002d60:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d64:	90 09       	ld.sh	r9,r8[0x0]
80002d66:	14 09       	add	r9,r10
80002d68:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d6a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d6e:	92 08       	ld.sh	r8,r9[0x0]
80002d70:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d74:	76 0b       	ld.w	r11,r11[0x0]
80002d76:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d7a:	2f f8       	sub	r8,-1
80002d7c:	5c 88       	casts.h	r8
80002d7e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d80:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d84:	94 09       	ld.sh	r9,r10[0x0]
80002d86:	20 29       	sub	r9,2
80002d88:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d8a:	30 0a       	mov	r10,0
80002d8c:	f4 09 19 00 	cp.h	r9,r10
80002d90:	e0 89 00 20 	brgt	80002dd0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002d94:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002d98:	e0 46 00 ba 	cp.w	r6,186
80002d9c:	c0 d1       	brne	80002db6 <phy_rx_func+0x18a>
80002d9e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002da2:	90 09       	ld.sh	r9,r8[0x0]
80002da4:	f4 09 19 00 	cp.h	r9,r10
80002da8:	c0 71       	brne	80002db6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002daa:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002dae:	70 0c       	ld.w	r12,r8[0x0]
80002db0:	f0 1f 03 49 	mcall	80003ad4 <phy_rx_func+0xea8>
80002db4:	c0 98       	rjmp	80002dc6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002db6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002dba:	70 0c       	ld.w	r12,r8[0x0]
80002dbc:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002dc0:	70 0b       	ld.w	r11,r8[0x0]
80002dc2:	f0 1f 03 43 	mcall	80003acc <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dc6:	30 09       	mov	r9,0
80002dc8:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dcc:	91 09       	st.w	r8[0x0],r9
80002dce:	c3 e8       	rjmp	80002e4a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002dd0:	5c 86       	casts.h	r6
80002dd2:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002dd6:	92 0a       	ld.sh	r10,r9[0x0]
80002dd8:	0c 0a       	add	r10,r6
80002dda:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ddc:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002de0:	72 09       	ld.w	r9,r9[0x0]
80002de2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002de6:	2f f8       	sub	r8,-1
80002de8:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002dec:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002dee:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002df2:	92 08       	ld.sh	r8,r9[0x0]
80002df4:	20 28       	sub	r8,2
80002df6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002df8:	30 09       	mov	r9,0
80002dfa:	f2 08 19 00 	cp.h	r8,r9
80002dfe:	e0 89 00 26 	brgt	80002e4a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002e02:	30 39       	mov	r9,3
80002e04:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e08:	91 09       	st.w	r8[0x0],r9
80002e0a:	c2 08       	rjmp	80002e4a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e0c:	e6 16 00 ff 	andh	r6,0xff,COH
80002e10:	fc 19 00 ba 	movh	r9,0xba
80002e14:	12 36       	cp.w	r6,r9
80002e16:	c0 e1       	brne	80002e32 <phy_rx_func+0x206>
80002e18:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e1c:	90 09       	ld.sh	r9,r8[0x0]
80002e1e:	30 08       	mov	r8,0
80002e20:	f0 09 19 00 	cp.h	r9,r8
80002e24:	c0 71       	brne	80002e32 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e26:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e2a:	70 0c       	ld.w	r12,r8[0x0]
80002e2c:	f0 1f 03 2a 	mcall	80003ad4 <phy_rx_func+0xea8>
80002e30:	c0 98       	rjmp	80002e42 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e32:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e36:	70 0c       	ld.w	r12,r8[0x0]
80002e38:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e3c:	70 0b       	ld.w	r11,r8[0x0]
80002e3e:	f0 1f 03 24 	mcall	80003acc <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e42:	30 09       	mov	r9,0
80002e44:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e48:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e4a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e4e:	11 89       	ld.ub	r9,r8[0x0]
80002e50:	30 08       	mov	r8,0
80002e52:	f0 09 18 00 	cp.b	r9,r8
80002e56:	c1 31       	brne	80002e7c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e58:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e5c:	6c 0c       	ld.w	r12,r6[0x0]
80002e5e:	f0 1f 03 1a 	mcall	80003ac4 <phy_rx_func+0xe98>
80002e62:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e66:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e68:	6c 0c       	ld.w	r12,r6[0x0]
80002e6a:	f0 1f 03 17 	mcall	80003ac4 <phy_rx_func+0xe98>
80002e6e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e72:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e74:	30 19       	mov	r9,1
80002e76:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e7a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e7c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e80:	70 08       	ld.w	r8,r8[0x0]
80002e82:	58 28       	cp.w	r8,2
80002e84:	e0 80 01 98 	breq	800031b4 <phy_rx_func+0x588>
80002e88:	e0 8b 00 06 	brhi	80002e94 <phy_rx_func+0x268>
80002e8c:	58 08       	cp.w	r8,0
80002e8e:	c0 b0       	breq	80002ea4 <phy_rx_func+0x278>
80002e90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e94:	58 38       	cp.w	r8,3
80002e96:	e0 80 05 c5 	breq	80003a20 <phy_rx_func+0xdf4>
80002e9a:	58 48       	cp.w	r8,4
80002e9c:	e0 81 06 05 	brne	80003aa6 <phy_rx_func+0xe7a>
80002ea0:	e0 8f 02 4b 	bral	80003336 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002ea4:	6e 28       	ld.w	r8,r7[0x8]
80002ea6:	e0 6a 5a 5a 	mov	r10,23130
80002eaa:	ea 1a ab cd 	orh	r10,0xabcd
80002eae:	14 38       	cp.w	r8,r10
80002eb0:	c0 71       	brne	80002ebe <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002eb2:	30 09       	mov	r9,0
80002eb4:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002eb8:	91 09       	st.w	r8[0x0],r9
80002eba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002ebe:	10 99       	mov	r9,r8
80002ec0:	e0 19 00 00 	andl	r9,0x0
80002ec4:	fc 1a ab cd 	movh	r10,0xabcd
80002ec8:	14 39       	cp.w	r9,r10
80002eca:	e0 81 05 ee 	brne	80003aa6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002ece:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002ed2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ed6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ed8:	6e 29       	ld.w	r9,r7[0x8]
80002eda:	e2 19 f0 00 	andl	r9,0xf000,COH
80002ede:	e0 49 c0 00 	cp.w	r9,49152
80002ee2:	e0 81 00 ce 	brne	8000307e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ee6:	30 1a       	mov	r10,1
80002ee8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002eec:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002eee:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002ef2:	72 09       	ld.w	r9,r9[0x0]
80002ef4:	58 09       	cp.w	r9,0
80002ef6:	c0 71       	brne	80002f04 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002ef8:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002efc:	f0 1f 03 00 	mcall	80003afc <phy_rx_func+0xed0>
80002f00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002f04:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f08:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f0c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f0e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f12:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f16:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f1a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f1c:	13 89       	ld.ub	r9,r9[0x0]
80002f1e:	37 fa       	mov	r10,127
80002f20:	f4 09 18 00 	cp.b	r9,r10
80002f24:	c6 d0       	breq	80002ffe <phy_rx_func+0x3d2>
80002f26:	e0 8b 00 0c 	brhi	80002f3e <phy_rx_func+0x312>
80002f2a:	31 2a       	mov	r10,18
80002f2c:	f4 09 18 00 	cp.b	r9,r10
80002f30:	c4 20       	breq	80002fb4 <phy_rx_func+0x388>
80002f32:	31 3a       	mov	r10,19
80002f34:	f4 09 18 00 	cp.b	r9,r10
80002f38:	e0 81 00 83 	brne	8000303e <phy_rx_func+0x412>
80002f3c:	c5 b8       	rjmp	80002ff2 <phy_rx_func+0x3c6>
80002f3e:	2f 09       	sub	r9,-16
80002f40:	30 1a       	mov	r10,1
80002f42:	f4 09 18 00 	cp.b	r9,r10
80002f46:	e0 8b 00 7c 	brhi	8000303e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f4a:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f4e:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f52:	59 08       	cp.w	r8,16
80002f54:	c0 71       	brne	80002f62 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f56:	30 19       	mov	r9,1
80002f58:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f5c:	91 09       	st.w	r8[0x0],r9
80002f5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f62:	e0 48 00 20 	cp.w	r8,32
80002f66:	c2 11       	brne	80002fa8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f68:	30 a9       	mov	r9,10
80002f6a:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f6e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f70:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f74:	6c 08       	ld.w	r8,r6[0x0]
80002f76:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f7a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f7e:	2f f8       	sub	r8,-1
80002f80:	6e 0c       	ld.w	r12,r7[0x0]
80002f82:	f4 ca fe 00 	sub	r10,r10,-512
80002f86:	30 0b       	mov	r11,0
80002f88:	10 0c       	add	r12,r8
80002f8a:	f0 1f 02 e1 	mcall	80003b0c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f8e:	30 08       	mov	r8,0
80002f90:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f92:	6e 0c       	ld.w	r12,r7[0x0]
80002f94:	f0 1f 02 df 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002f98:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002f9c:	70 0c       	ld.w	r12,r8[0x0]
80002f9e:	f0 1f 02 ca 	mcall	80003ac4 <phy_rx_func+0xe98>
80002fa2:	8f 0c       	st.w	r7[0x0],r12
80002fa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fa8:	30 09       	mov	r9,0
80002faa:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fae:	91 09       	st.w	r8[0x0],r9
80002fb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fb4:	20 48       	sub	r8,4
80002fb6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fba:	93 08       	st.w	r9[0x0],r8
80002fbc:	58 08       	cp.w	r8,0
80002fbe:	e0 80 05 74 	breq	80003aa6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fc2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fc6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fca:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fce:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fd0:	8e 69       	ld.sh	r9,r7[0xc]
80002fd2:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fd6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fd8:	8e 79       	ld.sh	r9,r7[0xe]
80002fda:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fdc:	f0 1f 02 d0 	mcall	80003b1c <phy_rx_func+0xef0>
80002fe0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002fe4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002fe6:	30 49       	mov	r9,4
80002fe8:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002fec:	91 09       	st.w	r8[0x0],r9
80002fee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002ff2:	30 09       	mov	r9,0
80002ff4:	fe f8 0a f8 	ld.w	r8,pc[2808]
80002ff8:	91 09       	st.w	r8[0x0],r9
80002ffa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002ffe:	20 48       	sub	r8,4
80003000:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003004:	93 08       	st.w	r9[0x0],r8
80003006:	58 08       	cp.w	r8,0
80003008:	e0 80 05 4f 	breq	80003aa6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000300c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003010:	70 09       	ld.w	r9,r8[0x0]
80003012:	8e 7b       	ld.sh	r11,r7[0xe]
80003014:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003018:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000301c:	2f f9       	sub	r9,-1
8000301e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003020:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003024:	70 09       	ld.w	r9,r8[0x0]
80003026:	20 29       	sub	r9,2
80003028:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000302a:	30 29       	mov	r9,2
8000302c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003030:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003032:	30 39       	mov	r9,3
80003034:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003038:	91 09       	st.w	r8[0x0],r9
8000303a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000303e:	30 3a       	mov	r10,3
80003040:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003044:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003046:	6e 2a       	ld.w	r10,r7[0x8]
80003048:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000304c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000304e:	6e 3a       	ld.w	r10,r7[0xc]
80003050:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003052:	59 48       	cp.w	r8,20
80003054:	c0 61       	brne	80003060 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003056:	31 89       	mov	r9,24
80003058:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000305c:	91 09       	st.w	r8[0x0],r9
8000305e:	c0 a8       	rjmp	80003072 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003060:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003064:	70 08       	ld.w	r8,r8[0x0]
80003066:	59 08       	cp.w	r8,16
80003068:	c0 51       	brne	80003072 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000306a:	31 09       	mov	r9,16
8000306c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003070:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003072:	30 49       	mov	r9,4
80003074:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003078:	91 09       	st.w	r8[0x0],r9
8000307a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000307e:	e0 49 10 00 	cp.w	r9,4096
80003082:	5f 1a       	srne	r10
80003084:	e0 49 20 00 	cp.w	r9,8192
80003088:	5f 19       	srne	r9
8000308a:	f5 e9 00 09 	and	r9,r10,r9
8000308e:	e0 81 05 0c 	brne	80003aa6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003092:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003096:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003098:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000309c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000309e:	fe fa 0a 62 	ld.w	r10,pc[2658]
800030a2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800030a4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030a8:	72 09       	ld.w	r9,r9[0x0]
800030aa:	58 09       	cp.w	r9,0
800030ac:	c0 71       	brne	800030ba <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030ae:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030b2:	f0 1f 02 93 	mcall	80003afc <phy_rx_func+0xed0>
800030b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030ba:	6e 2a       	ld.w	r10,r7[0x8]
800030bc:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030c0:	58 1a       	cp.w	r10,1
800030c2:	e0 8b 00 4d 	brhi	8000315c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030c6:	20 48       	sub	r8,4
800030c8:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030cc:	93 08       	st.w	r9[0x0],r8
800030ce:	58 08       	cp.w	r8,0
800030d0:	e0 80 04 eb 	breq	80003aa6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030d4:	8e 68       	ld.sh	r8,r7[0xc]
800030d6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030da:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030de:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030e0:	30 09       	mov	r9,0
800030e2:	f2 08 19 00 	cp.h	r8,r9
800030e6:	c0 70       	breq	800030f4 <phy_rx_func+0x4c8>
800030e8:	30 19       	mov	r9,1
800030ea:	f2 08 19 00 	cp.h	r8,r9
800030ee:	e0 81 04 dc 	brne	80003aa6 <phy_rx_func+0xe7a>
800030f2:	c2 68       	rjmp	8000313e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800030f4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800030f8:	70 0a       	ld.w	r10,r8[0x0]
800030fa:	fe f9 09 e6 	ld.w	r9,pc[2534]
800030fe:	72 09       	ld.w	r9,r9[0x0]
80003100:	8e 7b       	ld.sh	r11,r7[0xe]
80003102:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003106:	70 09       	ld.w	r9,r8[0x0]
80003108:	2f f9       	sub	r9,-1
8000310a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000310c:	e0 49 00 ff 	cp.w	r9,255
80003110:	e0 88 00 11 	brls	80003132 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003114:	30 09       	mov	r9,0
80003116:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003118:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000311c:	6e 0c       	ld.w	r12,r7[0x0]
8000311e:	f0 1f 02 7d 	mcall	80003b10 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003122:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003126:	70 0c       	ld.w	r12,r8[0x0]
80003128:	f0 1f 02 67 	mcall	80003ac4 <phy_rx_func+0xe98>
8000312c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000312e:	e0 80 04 bc 	breq	80003aa6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003132:	30 29       	mov	r9,2
80003134:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003138:	91 09       	st.w	r8[0x0],r9
8000313a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000313e:	8e 79       	ld.sh	r9,r7[0xe]
80003140:	30 38       	mov	r8,3
80003142:	f0 09 19 00 	cp.h	r9,r8
80003146:	c0 51       	brne	80003150 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003148:	30 19       	mov	r9,1
8000314a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000314e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003150:	30 29       	mov	r9,2
80003152:	fe f8 09 96 	ld.w	r8,pc[2454]
80003156:	91 09       	st.w	r8[0x0],r9
80003158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000315c:	58 18       	cp.w	r8,1
8000315e:	e0 88 04 a4 	brls	80003aa6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003162:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003166:	70 0a       	ld.w	r10,r8[0x0]
80003168:	6e 3b       	ld.w	r11,r7[0xc]
8000316a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000316e:	70 09       	ld.w	r9,r8[0x0]
80003170:	2f f9       	sub	r9,-1
80003172:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003174:	e0 49 00 ff 	cp.w	r9,255
80003178:	e0 88 00 11 	brls	8000319a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000317c:	30 09       	mov	r9,0
8000317e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003180:	fe f7 09 60 	ld.w	r7,pc[2400]
80003184:	6e 0c       	ld.w	r12,r7[0x0]
80003186:	f0 1f 02 63 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000318a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000318e:	70 0c       	ld.w	r12,r8[0x0]
80003190:	f0 1f 02 4d 	mcall	80003ac4 <phy_rx_func+0xe98>
80003194:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003196:	e0 80 04 88 	breq	80003aa6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000319a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000319e:	72 08       	ld.w	r8,r9[0x0]
800031a0:	20 28       	sub	r8,2
800031a2:	93 08       	st.w	r9[0x0],r8
800031a4:	e0 80 04 81 	breq	80003aa6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031a8:	30 29       	mov	r9,2
800031aa:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031ae:	91 09       	st.w	r8[0x0],r9
800031b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031b4:	fe f8 09 84 	ld.w	r8,pc[2436]
800031b8:	70 0a       	ld.w	r10,r8[0x0]
800031ba:	fe f9 09 26 	ld.w	r9,pc[2342]
800031be:	72 09       	ld.w	r9,r9[0x0]
800031c0:	8e 4b       	ld.sh	r11,r7[0x8]
800031c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031c6:	70 09       	ld.w	r9,r8[0x0]
800031c8:	2f f9       	sub	r9,-1
800031ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031cc:	e0 49 00 ff 	cp.w	r9,255
800031d0:	e0 88 00 16 	brls	800031fc <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031d4:	30 09       	mov	r9,0
800031d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031d8:	fe f6 09 08 	ld.w	r6,pc[2312]
800031dc:	6c 0c       	ld.w	r12,r6[0x0]
800031de:	f0 1f 02 4d 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031e2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031e6:	70 0c       	ld.w	r12,r8[0x0]
800031e8:	f0 1f 02 37 	mcall	80003ac4 <phy_rx_func+0xe98>
800031ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031ee:	c0 71       	brne	800031fc <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031f0:	30 09       	mov	r9,0
800031f2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800031f6:	91 09       	st.w	r8[0x0],r9
800031f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800031fc:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003200:	72 08       	ld.w	r8,r9[0x0]
80003202:	20 28       	sub	r8,2
80003204:	93 08       	st.w	r9[0x0],r8
80003206:	c0 71       	brne	80003214 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003208:	30 09       	mov	r9,0
8000320a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000320e:	91 09       	st.w	r8[0x0],r9
80003210:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003214:	fe f8 09 24 	ld.w	r8,pc[2340]
80003218:	70 0a       	ld.w	r10,r8[0x0]
8000321a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000321e:	72 09       	ld.w	r9,r9[0x0]
80003220:	8e 5b       	ld.sh	r11,r7[0xa]
80003222:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003226:	70 09       	ld.w	r9,r8[0x0]
80003228:	2f f9       	sub	r9,-1
8000322a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000322c:	e0 49 00 ff 	cp.w	r9,255
80003230:	e0 88 00 16 	brls	8000325c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003234:	30 09       	mov	r9,0
80003236:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003238:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000323c:	6c 0c       	ld.w	r12,r6[0x0]
8000323e:	f0 1f 02 35 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003242:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003246:	70 0c       	ld.w	r12,r8[0x0]
80003248:	f0 1f 02 1f 	mcall	80003ac4 <phy_rx_func+0xe98>
8000324c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000324e:	c0 71       	brne	8000325c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003250:	30 09       	mov	r9,0
80003252:	fe f8 08 96 	ld.w	r8,pc[2198]
80003256:	91 09       	st.w	r8[0x0],r9
80003258:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000325c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003260:	72 08       	ld.w	r8,r9[0x0]
80003262:	20 28       	sub	r8,2
80003264:	93 08       	st.w	r9[0x0],r8
80003266:	c0 71       	brne	80003274 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003268:	30 09       	mov	r9,0
8000326a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000326e:	91 09       	st.w	r8[0x0],r9
80003270:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003274:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003278:	70 0a       	ld.w	r10,r8[0x0]
8000327a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000327e:	72 09       	ld.w	r9,r9[0x0]
80003280:	8e 6b       	ld.sh	r11,r7[0xc]
80003282:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003286:	70 09       	ld.w	r9,r8[0x0]
80003288:	2f f9       	sub	r9,-1
8000328a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000328c:	e0 49 00 ff 	cp.w	r9,255
80003290:	e0 88 00 16 	brls	800032bc <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003294:	30 09       	mov	r9,0
80003296:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003298:	fe f6 08 48 	ld.w	r6,pc[2120]
8000329c:	6c 0c       	ld.w	r12,r6[0x0]
8000329e:	f0 1f 02 1d 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032a2:	fe f8 08 3a 	ld.w	r8,pc[2106]
800032a6:	70 0c       	ld.w	r12,r8[0x0]
800032a8:	f0 1f 02 07 	mcall	80003ac4 <phy_rx_func+0xe98>
800032ac:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032ae:	c0 71       	brne	800032bc <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032b0:	30 09       	mov	r9,0
800032b2:	fe f8 08 36 	ld.w	r8,pc[2102]
800032b6:	91 09       	st.w	r8[0x0],r9
800032b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032bc:	fe f9 08 34 	ld.w	r9,pc[2100]
800032c0:	72 08       	ld.w	r8,r9[0x0]
800032c2:	20 28       	sub	r8,2
800032c4:	93 08       	st.w	r9[0x0],r8
800032c6:	c0 71       	brne	800032d4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032c8:	30 09       	mov	r9,0
800032ca:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032ce:	91 09       	st.w	r8[0x0],r9
800032d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032d4:	fe f8 08 64 	ld.w	r8,pc[2148]
800032d8:	70 0a       	ld.w	r10,r8[0x0]
800032da:	fe f9 08 06 	ld.w	r9,pc[2054]
800032de:	72 09       	ld.w	r9,r9[0x0]
800032e0:	8e 7b       	ld.sh	r11,r7[0xe]
800032e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032e6:	70 09       	ld.w	r9,r8[0x0]
800032e8:	2f f9       	sub	r9,-1
800032ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032ec:	e0 49 00 ff 	cp.w	r9,255
800032f0:	e0 88 00 16 	brls	8000331c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800032f4:	30 09       	mov	r9,0
800032f6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032f8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800032fc:	6e 0c       	ld.w	r12,r7[0x0]
800032fe:	f0 1f 02 05 	mcall	80003b10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003302:	fe f8 07 da 	ld.w	r8,pc[2010]
80003306:	70 0c       	ld.w	r12,r8[0x0]
80003308:	f0 1f 01 ef 	mcall	80003ac4 <phy_rx_func+0xe98>
8000330c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000330e:	c0 71       	brne	8000331c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003310:	30 09       	mov	r9,0
80003312:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003316:	91 09       	st.w	r8[0x0],r9
80003318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000331c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003320:	72 08       	ld.w	r8,r9[0x0]
80003322:	20 28       	sub	r8,2
80003324:	93 08       	st.w	r9[0x0],r8
80003326:	e0 81 03 c0 	brne	80003aa6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000332a:	30 09       	mov	r9,0
8000332c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003330:	91 09       	st.w	r8[0x0],r9
80003332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003336:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000333a:	11 89       	ld.ub	r9,r8[0x0]
8000333c:	31 28       	mov	r8,18
8000333e:	f0 09 18 00 	cp.b	r9,r8
80003342:	e0 81 01 4c 	brne	800035da <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003346:	ef 39 00 09 	ld.ub	r9,r7[9]
8000334a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000334e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003350:	11 89       	ld.ub	r9,r8[0x0]
80003352:	3f 28       	mov	r8,-14
80003354:	f0 09 18 00 	cp.b	r9,r8
80003358:	e0 81 01 3b 	brne	800035ce <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000335c:	30 19       	mov	r9,1
8000335e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003362:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003364:	6e 29       	ld.w	r9,r7[0x8]
80003366:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000336a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000336e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003370:	8e 59       	ld.sh	r9,r7[0xa]
80003372:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003376:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003378:	8e 69       	ld.sh	r9,r7[0xc]
8000337a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000337c:	8e 79       	ld.sh	r9,r7[0xe]
8000337e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003380:	fe f8 07 88 	ld.w	r8,pc[1928]
80003384:	fe f9 07 60 	ld.w	r9,pc[1888]
80003388:	72 0a       	ld.w	r10,r9[0x0]
8000338a:	70 09       	ld.w	r9,r8[0x0]
8000338c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003390:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003394:	70 09       	ld.w	r9,r8[0x0]
80003396:	2f f9       	sub	r9,-1
80003398:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000339a:	e0 49 01 ff 	cp.w	r9,511
8000339e:	e0 88 00 16 	brls	800033ca <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800033a2:	30 09       	mov	r9,0
800033a4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033a6:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033aa:	6c 0c       	ld.w	r12,r6[0x0]
800033ac:	f0 1f 01 d9 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033b0:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033b4:	70 0c       	ld.w	r12,r8[0x0]
800033b6:	f0 1f 01 c4 	mcall	80003ac4 <phy_rx_func+0xe98>
800033ba:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033bc:	c0 71       	brne	800033ca <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033be:	30 09       	mov	r9,0
800033c0:	fe f8 07 28 	ld.w	r8,pc[1832]
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033ca:	fe f9 07 26 	ld.w	r9,pc[1830]
800033ce:	72 08       	ld.w	r8,r9[0x0]
800033d0:	20 18       	sub	r8,1
800033d2:	93 08       	st.w	r9[0x0],r8
800033d4:	c0 71       	brne	800033e2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033d6:	30 09       	mov	r9,0
800033d8:	fe f8 07 10 	ld.w	r8,pc[1808]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033e2:	fe f8 07 26 	ld.w	r8,pc[1830]
800033e6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033ea:	72 0a       	ld.w	r10,r9[0x0]
800033ec:	70 09       	ld.w	r9,r8[0x0]
800033ee:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033f2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033f6:	70 09       	ld.w	r9,r8[0x0]
800033f8:	2f f9       	sub	r9,-1
800033fa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033fc:	e0 49 01 ff 	cp.w	r9,511
80003400:	e0 88 00 16 	brls	8000342c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003404:	30 09       	mov	r9,0
80003406:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003408:	fe f6 06 dc 	ld.w	r6,pc[1756]
8000340c:	6c 0c       	ld.w	r12,r6[0x0]
8000340e:	f0 1f 01 c1 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003412:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003416:	70 0c       	ld.w	r12,r8[0x0]
80003418:	f0 1f 01 ab 	mcall	80003ac4 <phy_rx_func+0xe98>
8000341c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000341e:	c0 71       	brne	8000342c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003420:	30 09       	mov	r9,0
80003422:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003426:	91 09       	st.w	r8[0x0],r9
80003428:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000342c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003430:	72 08       	ld.w	r8,r9[0x0]
80003432:	20 18       	sub	r8,1
80003434:	93 08       	st.w	r9[0x0],r8
80003436:	c0 71       	brne	80003444 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003438:	30 09       	mov	r9,0
8000343a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003444:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003448:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000344c:	72 0a       	ld.w	r10,r9[0x0]
8000344e:	70 09       	ld.w	r9,r8[0x0]
80003450:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003454:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003458:	70 09       	ld.w	r9,r8[0x0]
8000345a:	2f f9       	sub	r9,-1
8000345c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000345e:	e0 49 01 ff 	cp.w	r9,511
80003462:	e0 88 00 16 	brls	8000348e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003466:	30 09       	mov	r9,0
80003468:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000346a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000346e:	6c 0c       	ld.w	r12,r6[0x0]
80003470:	f0 1f 01 a8 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003474:	fe f8 06 68 	ld.w	r8,pc[1640]
80003478:	70 0c       	ld.w	r12,r8[0x0]
8000347a:	f0 1f 01 93 	mcall	80003ac4 <phy_rx_func+0xe98>
8000347e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003480:	c0 71       	brne	8000348e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003482:	30 09       	mov	r9,0
80003484:	fe f8 06 64 	ld.w	r8,pc[1636]
80003488:	91 09       	st.w	r8[0x0],r9
8000348a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000348e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003492:	72 08       	ld.w	r8,r9[0x0]
80003494:	20 18       	sub	r8,1
80003496:	93 08       	st.w	r9[0x0],r8
80003498:	c0 71       	brne	800034a6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000349a:	30 09       	mov	r9,0
8000349c:	fe f8 06 4c 	ld.w	r8,pc[1612]
800034a0:	91 09       	st.w	r8[0x0],r9
800034a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800034a6:	fe f8 06 62 	ld.w	r8,pc[1634]
800034aa:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034ae:	72 0a       	ld.w	r10,r9[0x0]
800034b0:	70 09       	ld.w	r9,r8[0x0]
800034b2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034b6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ba:	70 09       	ld.w	r9,r8[0x0]
800034bc:	2f f9       	sub	r9,-1
800034be:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034c0:	e0 49 01 ff 	cp.w	r9,511
800034c4:	e0 88 00 16 	brls	800034f0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034c8:	30 09       	mov	r9,0
800034ca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034cc:	fe f6 06 18 	ld.w	r6,pc[1560]
800034d0:	6c 0c       	ld.w	r12,r6[0x0]
800034d2:	f0 1f 01 90 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034d6:	fe f8 06 06 	ld.w	r8,pc[1542]
800034da:	70 0c       	ld.w	r12,r8[0x0]
800034dc:	f0 1f 01 7a 	mcall	80003ac4 <phy_rx_func+0xe98>
800034e0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 06 02 	ld.w	r8,pc[1538]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034f0:	fe f9 06 00 	ld.w	r9,pc[1536]
800034f4:	72 08       	ld.w	r8,r9[0x0]
800034f6:	20 18       	sub	r8,1
800034f8:	93 08       	st.w	r9[0x0],r8
800034fa:	c0 71       	brne	80003508 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003502:	91 09       	st.w	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003508:	fe f8 06 00 	ld.w	r8,pc[1536]
8000350c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003510:	72 0a       	ld.w	r10,r9[0x0]
80003512:	70 09       	ld.w	r9,r8[0x0]
80003514:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003518:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000351c:	70 09       	ld.w	r9,r8[0x0]
8000351e:	2f f9       	sub	r9,-1
80003520:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003522:	e0 49 01 ff 	cp.w	r9,511
80003526:	e0 88 00 16 	brls	80003552 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000352a:	30 09       	mov	r9,0
8000352c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000352e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003532:	6c 0c       	ld.w	r12,r6[0x0]
80003534:	f0 1f 01 77 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003538:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000353c:	70 0c       	ld.w	r12,r8[0x0]
8000353e:	f0 1f 01 62 	mcall	80003ac4 <phy_rx_func+0xe98>
80003542:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003544:	c0 71       	brne	80003552 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003546:	30 09       	mov	r9,0
80003548:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000354c:	91 09       	st.w	r8[0x0],r9
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003552:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003556:	72 08       	ld.w	r8,r9[0x0]
80003558:	20 18       	sub	r8,1
8000355a:	93 08       	st.w	r9[0x0],r8
8000355c:	c0 71       	brne	8000356a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000355e:	30 09       	mov	r9,0
80003560:	fe f8 05 88 	ld.w	r8,pc[1416]
80003564:	91 09       	st.w	r8[0x0],r9
80003566:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000356a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000356e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003572:	72 0a       	ld.w	r10,r9[0x0]
80003574:	70 09       	ld.w	r9,r8[0x0]
80003576:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000357a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000357e:	70 09       	ld.w	r9,r8[0x0]
80003580:	2f f9       	sub	r9,-1
80003582:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003584:	e0 49 01 ff 	cp.w	r9,511
80003588:	e0 88 00 16 	brls	800035b4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000358c:	30 09       	mov	r9,0
8000358e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003590:	fe f7 05 54 	ld.w	r7,pc[1364]
80003594:	6e 0c       	ld.w	r12,r7[0x0]
80003596:	f0 1f 01 5f 	mcall	80003b10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000359a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000359e:	70 0c       	ld.w	r12,r8[0x0]
800035a0:	f0 1f 01 49 	mcall	80003ac4 <phy_rx_func+0xe98>
800035a4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035a6:	c0 71       	brne	800035b4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035b4:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035b8:	72 08       	ld.w	r8,r9[0x0]
800035ba:	20 18       	sub	r8,1
800035bc:	93 08       	st.w	r9[0x0],r8
800035be:	e0 81 02 74 	brne	80003aa6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035c2:	30 09       	mov	r9,0
800035c4:	fe f8 05 24 	ld.w	r8,pc[1316]
800035c8:	91 09       	st.w	r8[0x0],r9
800035ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035ce:	30 09       	mov	r9,0
800035d0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035d4:	91 09       	st.w	r8[0x0],r9
800035d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035da:	fe f8 05 26 	ld.w	r8,pc[1318]
800035de:	11 89       	ld.ub	r9,r8[0x0]
800035e0:	3f 28       	mov	r8,-14
800035e2:	f0 09 18 00 	cp.b	r9,r8
800035e6:	c4 31       	brne	8000366c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035e8:	8e 49       	ld.sh	r9,r7[0x8]
800035ea:	fe f8 05 56 	ld.w	r8,pc[1366]
800035ee:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035f0:	fe f8 05 18 	ld.w	r8,pc[1304]
800035f4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800035f8:	72 0a       	ld.w	r10,r9[0x0]
800035fa:	70 09       	ld.w	r9,r8[0x0]
800035fc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003600:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003604:	70 09       	ld.w	r9,r8[0x0]
80003606:	2f f9       	sub	r9,-1
80003608:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000360a:	e0 49 01 ff 	cp.w	r9,511
8000360e:	e0 88 00 16 	brls	8000363a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003612:	30 09       	mov	r9,0
80003614:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003616:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000361a:	6e 0c       	ld.w	r12,r7[0x0]
8000361c:	f0 1f 01 3d 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003620:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003624:	70 0c       	ld.w	r12,r8[0x0]
80003626:	f0 1f 01 28 	mcall	80003ac4 <phy_rx_func+0xe98>
8000362a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000362c:	c0 71       	brne	8000363a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000362e:	30 09       	mov	r9,0
80003630:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003634:	91 09       	st.w	r8[0x0],r9
80003636:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000363a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000363e:	72 08       	ld.w	r8,r9[0x0]
80003640:	20 18       	sub	r8,1
80003642:	93 08       	st.w	r9[0x0],r8
80003644:	c0 71       	brne	80003652 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003646:	30 09       	mov	r9,0
80003648:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000364c:	91 09       	st.w	r8[0x0],r9
8000364e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003652:	20 18       	sub	r8,1
80003654:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003658:	93 08       	st.w	r9[0x0],r8
8000365a:	58 08       	cp.w	r8,0
8000365c:	e0 81 02 25 	brne	80003aa6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003660:	30 09       	mov	r9,0
80003662:	fe f8 04 86 	ld.w	r8,pc[1158]
80003666:	91 09       	st.w	r8[0x0],r9
80003668:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000366c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003670:	11 89       	ld.ub	r9,r8[0x0]
80003672:	3f 38       	mov	r8,-13
80003674:	f0 09 18 00 	cp.b	r9,r8
80003678:	e0 81 01 0c 	brne	80003890 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000367c:	8e 49       	ld.sh	r9,r7[0x8]
8000367e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003682:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003684:	8e 59       	ld.sh	r9,r7[0xa]
80003686:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003688:	8e 69       	ld.sh	r9,r7[0xc]
8000368a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000368c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003690:	fe f9 04 54 	ld.w	r9,pc[1108]
80003694:	72 0a       	ld.w	r10,r9[0x0]
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000369c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036a0:	70 09       	ld.w	r9,r8[0x0]
800036a2:	2f f9       	sub	r9,-1
800036a4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036a6:	e0 49 01 ff 	cp.w	r9,511
800036aa:	e0 88 00 16 	brls	800036d6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036ae:	30 09       	mov	r9,0
800036b0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036b2:	fe f6 04 32 	ld.w	r6,pc[1074]
800036b6:	6c 0c       	ld.w	r12,r6[0x0]
800036b8:	f0 1f 01 16 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036bc:	fe f8 04 20 	ld.w	r8,pc[1056]
800036c0:	70 0c       	ld.w	r12,r8[0x0]
800036c2:	f0 1f 01 01 	mcall	80003ac4 <phy_rx_func+0xe98>
800036c6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036c8:	c0 71       	brne	800036d6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036ca:	30 09       	mov	r9,0
800036cc:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036d0:	91 09       	st.w	r8[0x0],r9
800036d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036d6:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036da:	72 08       	ld.w	r8,r9[0x0]
800036dc:	20 18       	sub	r8,1
800036de:	93 08       	st.w	r9[0x0],r8
800036e0:	c0 71       	brne	800036ee <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036e2:	30 09       	mov	r9,0
800036e4:	fe f8 04 04 	ld.w	r8,pc[1028]
800036e8:	91 09       	st.w	r8[0x0],r9
800036ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036ee:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036f2:	fe f9 03 f2 	ld.w	r9,pc[1010]
800036f6:	72 0a       	ld.w	r10,r9[0x0]
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	ef 3b 00 09 	ld.ub	r11,r7[9]
800036fe:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003702:	70 09       	ld.w	r9,r8[0x0]
80003704:	2f f9       	sub	r9,-1
80003706:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003708:	e0 49 01 ff 	cp.w	r9,511
8000370c:	e0 88 00 16 	brls	80003738 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003710:	30 09       	mov	r9,0
80003712:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003714:	fe f6 03 d0 	ld.w	r6,pc[976]
80003718:	6c 0c       	ld.w	r12,r6[0x0]
8000371a:	f0 1f 00 fe 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000371e:	fe f8 03 be 	ld.w	r8,pc[958]
80003722:	70 0c       	ld.w	r12,r8[0x0]
80003724:	f0 1f 00 e8 	mcall	80003ac4 <phy_rx_func+0xe98>
80003728:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000372a:	c0 71       	brne	80003738 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000372c:	30 09       	mov	r9,0
8000372e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003732:	91 09       	st.w	r8[0x0],r9
80003734:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003738:	fe f9 03 b8 	ld.w	r9,pc[952]
8000373c:	72 08       	ld.w	r8,r9[0x0]
8000373e:	20 18       	sub	r8,1
80003740:	93 08       	st.w	r9[0x0],r8
80003742:	c0 71       	brne	80003750 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003744:	30 09       	mov	r9,0
80003746:	fe f8 03 a2 	ld.w	r8,pc[930]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003750:	fe f8 03 b8 	ld.w	r8,pc[952]
80003754:	fe f9 03 90 	ld.w	r9,pc[912]
80003758:	72 0a       	ld.w	r10,r9[0x0]
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003760:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003764:	70 09       	ld.w	r9,r8[0x0]
80003766:	2f f9       	sub	r9,-1
80003768:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000376a:	e0 49 01 ff 	cp.w	r9,511
8000376e:	e0 88 00 16 	brls	8000379a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003772:	30 09       	mov	r9,0
80003774:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003776:	fe f6 03 6e 	ld.w	r6,pc[878]
8000377a:	6c 0c       	ld.w	r12,r6[0x0]
8000377c:	f0 1f 00 e5 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003780:	fe f8 03 5c 	ld.w	r8,pc[860]
80003784:	70 0c       	ld.w	r12,r8[0x0]
80003786:	f0 1f 00 d0 	mcall	80003ac4 <phy_rx_func+0xe98>
8000378a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000378c:	c0 71       	brne	8000379a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000378e:	30 09       	mov	r9,0
80003790:	fe f8 03 58 	ld.w	r8,pc[856]
80003794:	91 09       	st.w	r8[0x0],r9
80003796:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000379a:	fe f9 03 56 	ld.w	r9,pc[854]
8000379e:	72 08       	ld.w	r8,r9[0x0]
800037a0:	20 18       	sub	r8,1
800037a2:	93 08       	st.w	r9[0x0],r8
800037a4:	c0 71       	brne	800037b2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800037a6:	30 09       	mov	r9,0
800037a8:	fe f8 03 40 	ld.w	r8,pc[832]
800037ac:	91 09       	st.w	r8[0x0],r9
800037ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037b2:	fe f8 03 56 	ld.w	r8,pc[854]
800037b6:	fe f9 03 2e 	ld.w	r9,pc[814]
800037ba:	72 0a       	ld.w	r10,r9[0x0]
800037bc:	70 09       	ld.w	r9,r8[0x0]
800037be:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037c2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037c6:	70 09       	ld.w	r9,r8[0x0]
800037c8:	2f f9       	sub	r9,-1
800037ca:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037cc:	e0 49 01 ff 	cp.w	r9,511
800037d0:	e0 88 00 16 	brls	800037fc <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037d4:	30 09       	mov	r9,0
800037d6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037d8:	fe f6 03 0c 	ld.w	r6,pc[780]
800037dc:	6c 0c       	ld.w	r12,r6[0x0]
800037de:	f0 1f 00 cd 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037e2:	fe f8 02 fa 	ld.w	r8,pc[762]
800037e6:	70 0c       	ld.w	r12,r8[0x0]
800037e8:	f0 1f 00 b7 	mcall	80003ac4 <phy_rx_func+0xe98>
800037ec:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 02 f6 	ld.w	r8,pc[758]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037fc:	fe f9 02 f4 	ld.w	r9,pc[756]
80003800:	72 08       	ld.w	r8,r9[0x0]
80003802:	20 18       	sub	r8,1
80003804:	93 08       	st.w	r9[0x0],r8
80003806:	c0 71       	brne	80003814 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003808:	30 09       	mov	r9,0
8000380a:	fe f8 02 de 	ld.w	r8,pc[734]
8000380e:	91 09       	st.w	r8[0x0],r9
80003810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003814:	fe f8 02 f4 	ld.w	r8,pc[756]
80003818:	fe f9 02 cc 	ld.w	r9,pc[716]
8000381c:	72 0a       	ld.w	r10,r9[0x0]
8000381e:	70 09       	ld.w	r9,r8[0x0]
80003820:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003824:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003828:	70 09       	ld.w	r9,r8[0x0]
8000382a:	2f f9       	sub	r9,-1
8000382c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000382e:	e0 49 01 ff 	cp.w	r9,511
80003832:	e0 88 00 16 	brls	8000385e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003836:	30 09       	mov	r9,0
80003838:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000383a:	fe f7 02 aa 	ld.w	r7,pc[682]
8000383e:	6e 0c       	ld.w	r12,r7[0x0]
80003840:	f0 1f 00 b4 	mcall	80003b10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003844:	fe f8 02 98 	ld.w	r8,pc[664]
80003848:	70 0c       	ld.w	r12,r8[0x0]
8000384a:	f0 1f 00 9f 	mcall	80003ac4 <phy_rx_func+0xe98>
8000384e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003850:	c0 71       	brne	8000385e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 02 94 	ld.w	r8,pc[660]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000385e:	fe f9 02 92 	ld.w	r9,pc[658]
80003862:	72 08       	ld.w	r8,r9[0x0]
80003864:	20 18       	sub	r8,1
80003866:	93 08       	st.w	r9[0x0],r8
80003868:	c0 71       	brne	80003876 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000386a:	30 09       	mov	r9,0
8000386c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003870:	91 09       	st.w	r8[0x0],r9
80003872:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003876:	20 18       	sub	r8,1
80003878:	fe f9 02 78 	ld.w	r9,pc[632]
8000387c:	93 08       	st.w	r9[0x0],r8
8000387e:	58 08       	cp.w	r8,0
80003880:	e0 81 01 13 	brne	80003aa6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003884:	30 09       	mov	r9,0
80003886:	fe f8 02 62 	ld.w	r8,pc[610]
8000388a:	91 09       	st.w	r8[0x0],r9
8000388c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003890:	fe f8 02 70 	ld.w	r8,pc[624]
80003894:	11 89       	ld.ub	r9,r8[0x0]
80003896:	30 48       	mov	r8,4
80003898:	f0 09 18 00 	cp.b	r9,r8
8000389c:	c0 80       	breq	800038ac <phy_rx_func+0xc80>
8000389e:	fe f8 02 62 	ld.w	r8,pc[610]
800038a2:	11 89       	ld.ub	r9,r8[0x0]
800038a4:	30 38       	mov	r8,3
800038a6:	f0 09 18 00 	cp.b	r9,r8
800038aa:	c1 41       	brne	800038d2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038ac:	6e 29       	ld.w	r9,r7[0x8]
800038ae:	fe f8 02 7a 	ld.w	r8,pc[634]
800038b2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038b4:	6e 39       	ld.w	r9,r7[0xc]
800038b6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038b8:	fe f9 02 38 	ld.w	r9,pc[568]
800038bc:	72 08       	ld.w	r8,r9[0x0]
800038be:	20 88       	sub	r8,8
800038c0:	93 08       	st.w	r9[0x0],r8
800038c2:	e0 81 00 f2 	brne	80003aa6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038c6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038c8:	fe f9 02 20 	ld.w	r9,pc[544]
800038cc:	93 08       	st.w	r9[0x0],r8
800038ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038d2:	fe f8 02 2e 	ld.w	r8,pc[558]
800038d6:	11 89       	ld.ub	r9,r8[0x0]
800038d8:	31 38       	mov	r8,19
800038da:	f0 09 18 00 	cp.b	r9,r8
800038de:	e0 81 00 9c 	brne	80003a16 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038e2:	fe f8 02 62 	ld.w	r8,pc[610]
800038e6:	11 88       	ld.ub	r8,r8[0x0]
800038e8:	30 c9       	mov	r9,12
800038ea:	f2 08 18 00 	cp.b	r8,r9
800038ee:	e0 81 00 7b 	brne	800039e4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038f2:	8e 49       	ld.sh	r9,r7[0x8]
800038f4:	fe f8 02 54 	ld.w	r8,pc[596]
800038f8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	fe f8 02 46 	ld.w	r8,pc[582]
80003902:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003904:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003908:	3f 38       	mov	r8,-13
8000390a:	f0 09 18 00 	cp.b	r9,r8
8000390e:	c6 61       	brne	800039da <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003910:	10 99       	mov	r9,r8
80003912:	4f c8       	lddpc	r8,80003b00 <phy_rx_func+0xed4>
80003914:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003916:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000391a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000391e:	4f 58       	lddpc	r8,80003af0 <phy_rx_func+0xec4>
80003920:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003922:	30 19       	mov	r9,1
80003924:	fe f8 02 0c 	ld.w	r8,pc[524]
80003928:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000392a:	8e 79       	ld.sh	r9,r7[0xe]
8000392c:	fe f8 02 14 	ld.w	r8,pc[532]
80003930:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003932:	4f 68       	lddpc	r8,80003b08 <phy_rx_func+0xedc>
80003934:	4e c9       	lddpc	r9,80003ae4 <phy_rx_func+0xeb8>
80003936:	72 0a       	ld.w	r10,r9[0x0]
80003938:	70 09       	ld.w	r9,r8[0x0]
8000393a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000393e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003942:	70 09       	ld.w	r9,r8[0x0]
80003944:	2f f9       	sub	r9,-1
80003946:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003948:	e0 49 01 ff 	cp.w	r9,511
8000394c:	e0 88 00 13 	brls	80003972 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003950:	30 09       	mov	r9,0
80003952:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003954:	4e 46       	lddpc	r6,80003ae4 <phy_rx_func+0xeb8>
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 00 6e 	mcall	80003b10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	4e 08       	lddpc	r8,80003adc <phy_rx_func+0xeb0>
8000395e:	70 0c       	ld.w	r12,r8[0x0]
80003960:	f0 1f 00 59 	mcall	80003ac4 <phy_rx_func+0xe98>
80003964:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003966:	c0 61       	brne	80003972 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003968:	30 09       	mov	r9,0
8000396a:	4e 08       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
8000396c:	91 09       	st.w	r8[0x0],r9
8000396e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003972:	4e 09       	lddpc	r9,80003af0 <phy_rx_func+0xec4>
80003974:	72 08       	ld.w	r8,r9[0x0]
80003976:	20 18       	sub	r8,1
80003978:	93 08       	st.w	r9[0x0],r8
8000397a:	c0 61       	brne	80003986 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
8000397c:	30 09       	mov	r9,0
8000397e:	4d b8       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003986:	4e 18       	lddpc	r8,80003b08 <phy_rx_func+0xedc>
80003988:	4d 79       	lddpc	r9,80003ae4 <phy_rx_func+0xeb8>
8000398a:	72 0a       	ld.w	r10,r9[0x0]
8000398c:	70 09       	ld.w	r9,r8[0x0]
8000398e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003992:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003996:	70 09       	ld.w	r9,r8[0x0]
80003998:	2f f9       	sub	r9,-1
8000399a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399c:	e0 49 01 ff 	cp.w	r9,511
800039a0:	e0 88 00 13 	brls	800039c6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800039a4:	30 09       	mov	r9,0
800039a6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039a8:	4c f7       	lddpc	r7,80003ae4 <phy_rx_func+0xeb8>
800039aa:	6e 0c       	ld.w	r12,r7[0x0]
800039ac:	f0 1f 00 59 	mcall	80003b10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039b0:	4c b8       	lddpc	r8,80003adc <phy_rx_func+0xeb0>
800039b2:	70 0c       	ld.w	r12,r8[0x0]
800039b4:	f0 1f 00 44 	mcall	80003ac4 <phy_rx_func+0xe98>
800039b8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039ba:	c0 61       	brne	800039c6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039bc:	30 09       	mov	r9,0
800039be:	4c b8       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039c0:	91 09       	st.w	r8[0x0],r9
800039c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039c6:	4c b9       	lddpc	r9,80003af0 <phy_rx_func+0xec4>
800039c8:	72 08       	ld.w	r8,r9[0x0]
800039ca:	20 18       	sub	r8,1
800039cc:	93 08       	st.w	r9[0x0],r8
800039ce:	c6 c1       	brne	80003aa6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039d0:	30 09       	mov	r9,0
800039d2:	4c 68       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039d4:	91 09       	st.w	r8[0x0],r9
800039d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	4c 38       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
800039de:	91 09       	st.w	r8[0x0],r9
800039e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039e4:	8e 4a       	ld.sh	r10,r7[0x8]
800039e6:	4d 99       	lddpc	r9,80003b48 <phy_rx_func+0xf1c>
800039e8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039ec:	4d 6a       	lddpc	r10,80003b44 <phy_rx_func+0xf18>
800039ee:	15 88       	ld.ub	r8,r10[0x0]
800039f0:	f0 cb ff ff 	sub	r11,r8,-1
800039f4:	8e 5c       	ld.sh	r12,r7[0xa]
800039f6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800039fa:	f0 cb ff fe 	sub	r11,r8,-2
800039fe:	8e 6c       	ld.sh	r12,r7[0xc]
80003a00:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003a04:	f0 cb ff fd 	sub	r11,r8,-3
80003a08:	8e 7c       	ld.sh	r12,r7[0xe]
80003a0a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a0e:	2f c8       	sub	r8,-4
80003a10:	b4 88       	st.b	r10[0x0],r8
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a16:	30 09       	mov	r9,0
80003a18:	4b 48       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a1a:	91 09       	st.w	r8[0x0],r9
80003a1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a20:	4c 08       	lddpc	r8,80003b20 <phy_rx_func+0xef4>
80003a22:	70 09       	ld.w	r9,r8[0x0]
80003a24:	8e 4b       	ld.sh	r11,r7[0x8]
80003a26:	4c 0a       	lddpc	r10,80003b24 <phy_rx_func+0xef8>
80003a28:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a2c:	2f f9       	sub	r9,-1
80003a2e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a30:	4b 58       	lddpc	r8,80003b04 <phy_rx_func+0xed8>
80003a32:	70 09       	ld.w	r9,r8[0x0]
80003a34:	20 29       	sub	r9,2
80003a36:	91 09       	st.w	r8[0x0],r9
80003a38:	70 08       	ld.w	r8,r8[0x0]
80003a3a:	58 08       	cp.w	r8,0
80003a3c:	c2 f1       	brne	80003a9a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a3e:	30 09       	mov	r9,0
80003a40:	4b 88       	lddpc	r8,80003b20 <phy_rx_func+0xef4>
80003a42:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a44:	8e 59       	ld.sh	r9,r7[0xa]
80003a46:	fe 78 82 12 	mov	r8,-32238
80003a4a:	f0 09 19 00 	cp.h	r9,r8
80003a4e:	c2 11       	brne	80003a90 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a50:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a54:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a58:	4a f8       	lddpc	r8,80003b14 <phy_rx_func+0xee8>
80003a5a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a5c:	8e 59       	ld.sh	r9,r7[0xa]
80003a5e:	4a f8       	lddpc	r8,80003b18 <phy_rx_func+0xeec>
80003a60:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a62:	8e 69       	ld.sh	r9,r7[0xc]
80003a64:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a66:	f0 1f 00 2e 	mcall	80003b1c <phy_rx_func+0xef0>
80003a6a:	4a 18       	lddpc	r8,80003aec <phy_rx_func+0xec0>
80003a6c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a6e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a72:	31 38       	mov	r8,19
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	c0 71       	brne	80003a86 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a7a:	10 99       	mov	r9,r8
80003a7c:	4a 18       	lddpc	r8,80003b00 <phy_rx_func+0xed4>
80003a7e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a80:	30 09       	mov	r9,0
80003a82:	49 c8       	lddpc	r8,80003af0 <phy_rx_func+0xec4>
80003a84:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a86:	30 49       	mov	r9,4
80003a88:	49 88       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a90:	30 09       	mov	r9,0
80003a92:	49 68       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003a94:	91 09       	st.w	r8[0x0],r9
80003a96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003a9a:	4a dc       	lddpc	r12,80003b4c <phy_rx_func+0xf20>
80003a9c:	f0 1f 00 18 	mcall	80003afc <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003aa0:	30 09       	mov	r9,0
80003aa2:	49 28       	lddpc	r8,80003ae8 <phy_rx_func+0xebc>
80003aa4:	91 09       	st.w	r8[0x0],r9
80003aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003aaa:	00 00       	add	r0,r0
80003aac:	00 00       	add	r0,r0
80003aae:	0a b8       	st.h	r5++,r8
80003ab0:	00 00       	add	r0,r0
80003ab2:	0a d4       	st.w	--r5,r4
80003ab4:	00 00       	add	r0,r0
80003ab6:	0a b0       	st.h	r5++,r0
80003ab8:	00 00       	add	r0,r0
80003aba:	0a 90       	mov	r0,r5
80003abc:	00 00       	add	r0,r0
80003abe:	0a 80       	andn	r0,r5
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a a4       	st.w	r5++,r4
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	2a 4c       	sub	r12,-92
80003ac8:	00 00       	add	r0,r0
80003aca:	0a d8       	st.w	--r5,r8
80003acc:	80 00       	ld.sh	r0,r0[0x0]
80003ace:	29 7c       	sub	r12,-105
80003ad0:	00 00       	add	r0,r0
80003ad2:	0a b4       	st.h	r5++,r4
80003ad4:	80 00       	ld.sh	r0,r0[0x0]
80003ad6:	29 98       	sub	r8,-103
80003ad8:	00 00       	add	r0,r0
80003ada:	0a e4       	st.h	--r5,r4
80003adc:	00 00       	add	r0,r0
80003ade:	0a ac       	st.w	r5++,r12
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a c8       	st.b	r5++,r8
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 9c       	mov	r12,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	0a ec       	st.h	--r5,r12
80003aec:	00 00       	add	r0,r0
80003aee:	0a c4       	st.b	r5++,r4
80003af0:	00 00       	add	r0,r0
80003af2:	0a 8c       	andn	r12,r5
80003af4:	00 00       	add	r0,r0
80003af6:	0a 63       	and	r3,r5
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	d8 f8       	*unknown*
80003afc:	80 00       	ld.sh	r0,r0[0x0]
80003afe:	72 b8       	ld.w	r8,r9[0x2c]
80003b00:	00 00       	add	r0,r0
80003b02:	0a 98       	mov	r8,r5
80003b04:	00 00       	add	r0,r0
80003b06:	0a 7c       	tst	r12,r5
80003b08:	00 00       	add	r0,r0
80003b0a:	0a e0       	st.h	--r5,r0
80003b0c:	80 00       	ld.sh	r0,r0[0x0]
80003b0e:	7b 1a       	ld.w	r10,sp[0x44]
80003b10:	80 00       	ld.sh	r0,r0[0x0]
80003b12:	2b cc       	sub	r12,-68
80003b14:	00 00       	add	r0,r0
80003b16:	0a 66       	and	r6,r5
80003b18:	00 00       	add	r0,r0
80003b1a:	1f 00       	ld.w	r0,pc++
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	28 dc       	sub	r12,-115
80003b20:	00 00       	add	r0,r0
80003b22:	0a c0       	st.b	r5++,r0
80003b24:	00 00       	add	r0,r0
80003b26:	1e 04       	add	r4,pc
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 84       	andn	r4,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a 60       	and	r0,r5
80003b30:	00 00       	add	r0,r0
80003b32:	0a 51       	eor	r1,r5
80003b34:	00 00       	add	r0,r0
80003b36:	0a 74       	tst	r4,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	0a a8       	st.w	r5++,r8
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a 67       	and	r7,r5
80003b40:	00 00       	add	r0,r0
80003b42:	1d fc       	ld.ub	r12,lr[0x7]
80003b44:	00 00       	add	r0,r0
80003b46:	0a d0       	st.w	--r5,r0
80003b48:	00 00       	add	r0,r0
80003b4a:	1f 04       	ld.w	r4,pc++
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	d9 10       	acall	0x91

80003b50 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b50:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b52:	49 88       	lddpc	r8,80003bb0 <pdca_int_handler+0x60>
80003b54:	11 89       	ld.ub	r9,r8[0x0]
80003b56:	ec 19 00 01 	eorl	r9,0x1
80003b5a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b5c:	11 89       	ld.ub	r9,r8[0x0]
80003b5e:	a5 69       	lsl	r9,0x4
80003b60:	2f c9       	sub	r9,-4
80003b62:	49 5a       	lddpc	r10,80003bb4 <pdca_int_handler+0x64>
80003b64:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b66:	fe 7a 00 40 	mov	r10,-65472
80003b6a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b6c:	30 39       	mov	r9,3
80003b6e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b70:	11 8a       	ld.ub	r10,r8[0x0]
80003b72:	a5 6a       	lsl	r10,0x4
80003b74:	2f ca       	sub	r10,-4
80003b76:	49 18       	lddpc	r8,80003bb8 <pdca_int_handler+0x68>
80003b78:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b7a:	fe 78 00 00 	mov	r8,-65536
80003b7e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b80:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b82:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b84:	48 e8       	lddpc	r8,80003bbc <pdca_int_handler+0x6c>
80003b86:	70 08       	ld.w	r8,r8[0x0]
80003b88:	58 08       	cp.w	r8,0
80003b8a:	c0 70       	breq	80003b98 <pdca_int_handler+0x48>
80003b8c:	48 99       	lddpc	r9,80003bb0 <pdca_int_handler+0x60>
80003b8e:	13 89       	ld.ub	r9,r9[0x0]
80003b90:	a5 69       	lsl	r9,0x4
80003b92:	48 ac       	lddpc	r12,80003bb8 <pdca_int_handler+0x68>
80003b94:	12 0c       	add	r12,r9
80003b96:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003b98:	48 a8       	lddpc	r8,80003bc0 <pdca_int_handler+0x70>
80003b9a:	70 08       	ld.w	r8,r8[0x0]
80003b9c:	58 08       	cp.w	r8,0
80003b9e:	c0 70       	breq	80003bac <pdca_int_handler+0x5c>
80003ba0:	48 49       	lddpc	r9,80003bb0 <pdca_int_handler+0x60>
80003ba2:	13 89       	ld.ub	r9,r9[0x0]
80003ba4:	a5 69       	lsl	r9,0x4
80003ba6:	48 4c       	lddpc	r12,80003bb4 <pdca_int_handler+0x64>
80003ba8:	12 0c       	add	r12,r9
80003baa:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003bac:	d4 02       	popm	lr
80003bae:	d6 03       	rete
80003bb0:	00 00       	add	r0,r0
80003bb2:	51 24       	stdsp	sp[0x48],r4
80003bb4:	00 00       	add	r0,r0
80003bb6:	51 4c       	stdsp	sp[0x50],r12
80003bb8:	00 00       	add	r0,r0
80003bba:	51 2c       	stdsp	sp[0x48],r12
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a f0       	st.b	--r5,r0
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a f4       	st.b	--r5,r4

80003bc4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bc4:	fe 78 10 00 	mov	r8,-61440
80003bc8:	e0 69 0d c0 	mov	r9,3520
80003bcc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bd0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bd4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bd8:	fe 78 34 00 	mov	r8,-52224
80003bdc:	e0 69 80 00 	mov	r9,32768
80003be0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003be2:	30 09       	mov	r9,0
80003be4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003be6:	e0 69 04 21 	mov	r9,1057
80003bea:	ea 19 3f 20 	orh	r9,0x3f20
80003bee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003bf0:	e0 69 02 9f 	mov	r9,671
80003bf4:	ea 19 01 00 	orh	r9,0x100
80003bf8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003bfa:	e0 6a 04 02 	mov	r10,1026
80003bfe:	ea 1a 3f 20 	orh	r10,0x3f20
80003c02:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003c04:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003c06:	5e fc       	retal	r12

80003c08 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c08:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c0a:	30 19       	mov	r9,1
80003c0c:	49 78       	lddpc	r8,80003c68 <local_start_PDC+0x60>
80003c0e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c10:	fe 78 00 00 	mov	r8,-65536
80003c14:	30 7b       	mov	r11,7
80003c16:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c18:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c1a:	49 59       	lddpc	r9,80003c6c <local_start_PDC+0x64>
80003c1c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c20:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c22:	30 3a       	mov	r10,3
80003c24:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c26:	30 1c       	mov	r12,1
80003c28:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c2a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c2c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c2e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c30:	30 2c       	mov	r12,2
80003c32:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c34:	48 f9       	lddpc	r9,80003c70 <local_start_PDC+0x68>
80003c36:	e0 68 5a 5a 	mov	r8,23130
80003c3a:	ea 18 ab cd 	orh	r8,0xabcd
80003c3e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c40:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c42:	30 0e       	mov	lr,0
80003c44:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c46:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c48:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c4a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c4c:	fe 78 00 40 	mov	r8,-65472
80003c50:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c52:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c54:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c58:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c5a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c5c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c5e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c60:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c62:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c64:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c66:	d8 02       	popm	pc
80003c68:	00 00       	add	r0,r0
80003c6a:	51 24       	stdsp	sp[0x48],r4
80003c6c:	00 00       	add	r0,r0
80003c6e:	51 2c       	stdsp	sp[0x48],r12
80003c70:	00 00       	add	r0,r0
80003c72:	51 4c       	stdsp	sp[0x50],r12

80003c74 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c74:	48 38       	lddpc	r8,80003c80 <register_rx_tx_func+0xc>
80003c76:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c78:	48 38       	lddpc	r8,80003c84 <register_rx_tx_func+0x10>
80003c7a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c7c:	5e fc       	retal	r12
80003c7e:	00 00       	add	r0,r0
80003c80:	00 00       	add	r0,r0
80003c82:	0a f0       	st.b	--r5,r0
80003c84:	00 00       	add	r0,r0
80003c86:	0a f4       	st.b	--r5,r4

80003c88 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c88:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c8a:	fe 78 10 00 	mov	r8,-61440
80003c8e:	30 29       	mov	r9,2
80003c90:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c94:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003c98:	30 3a       	mov	r10,3
80003c9a:	36 0b       	mov	r11,96
80003c9c:	49 3c       	lddpc	r12,80003ce8 <ssc_init+0x60>
80003c9e:	f0 1f 00 14 	mcall	80003cec <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003ca2:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003ca4:	fe 79 10 00 	mov	r9,-61440
80003ca8:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cac:	e2 18 00 02 	andl	r8,0x2,COH
80003cb0:	cf c0       	breq	80003ca8 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003cb2:	fe 79 10 00 	mov	r9,-61440
80003cb6:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cba:	e2 18 00 02 	andl	r8,0x2,COH
80003cbe:	cf c1       	brne	80003cb6 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003cc0:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003cc2:	f0 1f 00 0c 	mcall	80003cf0 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003cc6:	f0 1f 00 0c 	mcall	80003cf4 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cca:	fe 79 00 00 	mov	r9,-65536
80003cce:	30 18       	mov	r8,1
80003cd0:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cd2:	fe 7a 00 40 	mov	r10,-65472
80003cd6:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cd8:	e0 6b 01 01 	mov	r11,257
80003cdc:	fe 7a 34 00 	mov	r10,-52224
80003ce0:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ce2:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ce4:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ce6:	d8 02       	popm	pc
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	3b 50       	mov	r0,-75
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	58 ac       	cp.w	r12,10
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	3b c4       	mov	r4,-68
80003cf4:	80 00       	ld.sh	r0,r0[0x0]
80003cf6:	3c 08       	mov	r8,-64

80003cf8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003cf8:	48 28       	lddpc	r8,80003d00 <xcmp_register_app_list+0x8>
80003cfa:	91 0c       	st.w	r8[0x0],r12
}
80003cfc:	5e fc       	retal	r12
80003cfe:	00 00       	add	r0,r0
80003d00:	00 00       	add	r0,r0
80003d02:	51 6c       	stdsp	sp[0x58],r12

80003d04 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d04:	eb cd 40 80 	pushm	r7,lr
80003d08:	fa cd 01 00 	sub	sp,sp,256
80003d0c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d0e:	16 98       	mov	r8,r11
80003d10:	2f 08       	sub	r8,-16
80003d12:	af a8       	sbr	r8,0xe
80003d14:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d16:	3f f8       	mov	r8,-1
80003d18:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d1a:	30 b9       	mov	r9,11
80003d1c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d1e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d20:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d22:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d24:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d26:	f6 ca ff fe 	sub	r10,r11,-2
80003d2a:	18 9b       	mov	r11,r12
80003d2c:	fa cc ff f0 	sub	r12,sp,-16
80003d30:	f0 1f 00 05 	mcall	80003d44 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d34:	2f e7       	sub	r7,-2
80003d36:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d38:	1a 9c       	mov	r12,sp
80003d3a:	f0 1f 00 04 	mcall	80003d48 <xcmp_tx+0x44>
}
80003d3e:	2c 0d       	sub	sp,-256
80003d40:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	79 d2       	ld.w	r2,r12[0x74]
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	43 10       	lddsp	r0,sp[0xc4]

80003d4c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d4c:	d4 21       	pushm	r4-r7,lr
80003d4e:	fa cd 00 d0 	sub	sp,sp,208
80003d52:	18 94       	mov	r4,r12
80003d54:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d56:	e0 68 01 00 	mov	r8,256
80003d5a:	f0 0b 19 00 	cp.h	r11,r8
80003d5e:	e0 8b 00 36 	brhi	80003dca <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d62:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d66:	e0 68 04 1d 	mov	r8,1053
80003d6a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003d6c:	30 18       	mov	r8,1
80003d6e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003d70:	32 08       	mov	r8,32
80003d72:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003d74:	30 28       	mov	r8,2
80003d76:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003d78:	30 48       	mov	r8,4
80003d7a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003d7c:	ea 1a 0c 00 	orh	r10,0xc00
80003d80:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003d82:	30 4a       	mov	r10,4
80003d84:	1a 9b       	mov	r11,sp
80003d86:	fa cc ff f4 	sub	r12,sp,-12
80003d8a:	f0 1f 00 12 	mcall	80003dd0 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003d8e:	30 f8       	mov	r8,15
80003d90:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003d94:	3a 78       	mov	r8,-89
80003d96:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003d9a:	30 08       	mov	r8,0
80003d9c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003da0:	0e 9a       	mov	r10,r7
80003da2:	5c 7a       	castu.h	r10
80003da4:	f4 08 16 08 	lsr	r8,r10,0x8
80003da8:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003dac:	0e 96       	mov	r6,r7
80003dae:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003db2:	08 9b       	mov	r11,r4
80003db4:	fa cc ff eb 	sub	r12,sp,-21
80003db8:	f0 1f 00 06 	mcall	80003dd0 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003dbc:	ee cb ff f3 	sub	r11,r7,-13
80003dc0:	5c 5b       	castu.b	r11
80003dc2:	fa cc ff fa 	sub	r12,sp,-6
80003dc6:	f0 1f 00 04 	mcall	80003dd4 <xcmp_data_session_req+0x88>
}
80003dca:	2c cd       	sub	sp,-208
80003dcc:	d8 22       	popm	r4-r7,pc
80003dce:	00 00       	add	r0,r0
80003dd0:	80 00       	ld.sh	r0,r0[0x0]
80003dd2:	79 d2       	ld.w	r2,r12[0x74]
80003dd4:	80 00       	ld.sh	r0,r0[0x0]
80003dd6:	3d 04       	mov	r4,-48

80003dd8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003dd8:	d4 01       	pushm	lr
80003dda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dde:	fe 78 b4 00 	mov	r8,-19456
80003de2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003de4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003de8:	30 89       	mov	r9,8
80003dea:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003dec:	30 19       	mov	r9,1
80003dee:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003df0:	30 09       	mov	r9,0
80003df2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003df4:	30 5a       	mov	r10,5
80003df6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003df8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003dfa:	30 7a       	mov	r10,7
80003dfc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003dfe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e00:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e02:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e06:	30 9b       	mov	r11,9
80003e08:	fa cc ff fe 	sub	r12,sp,-2
80003e0c:	f0 1f 00 02 	mcall	80003e14 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e10:	2c dd       	sub	sp,-204
80003e12:	d8 02       	popm	pc
80003e14:	80 00       	ld.sh	r0,r0[0x0]
80003e16:	3d 04       	mov	r4,-48

80003e18 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e18:	d4 01       	pushm	lr
80003e1a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e1e:	fe 78 80 00 	mov	r8,-32768
80003e22:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e24:	30 38       	mov	r8,3
80003e26:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e28:	30 1b       	mov	r11,1
80003e2a:	fa cc ff fe 	sub	r12,sp,-2
80003e2e:	f0 1f 00 03 	mcall	80003e38 <xcmp_opcode_not_supported+0x20>
}
80003e32:	2c dd       	sub	sp,-204
80003e34:	d8 02       	popm	pc
80003e36:	00 00       	add	r0,r0
80003e38:	80 00       	ld.sh	r0,r0[0x0]
80003e3a:	3d 04       	mov	r4,-48

80003e3c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e3c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e3e:	96 88       	ld.uh	r8,r11[0x0]
80003e40:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e44:	e0 48 80 00 	cp.w	r8,32768
80003e48:	c0 f0       	breq	80003e66 <xcmp_exec_func+0x2a>
80003e4a:	e0 48 b0 00 	cp.w	r8,45056
80003e4e:	c1 20       	breq	80003e72 <xcmp_exec_func+0x36>
80003e50:	58 08       	cp.w	r8,0
80003e52:	c1 51       	brne	80003e7c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e54:	78 08       	ld.w	r8,r12[0x0]
80003e56:	58 08       	cp.w	r8,0
80003e58:	c0 40       	breq	80003e60 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e5a:	16 9c       	mov	r12,r11
80003e5c:	5d 18       	icall	r8
80003e5e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e60:	f0 1f 00 08 	mcall	80003e80 <xcmp_exec_func+0x44>
80003e64:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e66:	78 18       	ld.w	r8,r12[0x4]
80003e68:	58 08       	cp.w	r8,0
80003e6a:	c0 90       	breq	80003e7c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e6c:	16 9c       	mov	r12,r11
80003e6e:	5d 18       	icall	r8
80003e70:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e72:	78 28       	ld.w	r8,r12[0x8]
80003e74:	58 08       	cp.w	r8,0
80003e76:	c0 30       	breq	80003e7c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e78:	16 9c       	mov	r12,r11
80003e7a:	5d 18       	icall	r8
80003e7c:	d8 02       	popm	pc
80003e7e:	00 00       	add	r0,r0
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	3e 18       	mov	r8,-31

80003e84 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003e84:	d4 01       	pushm	lr
80003e86:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003e8a:	e0 68 04 09 	mov	r8,1033
80003e8e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003e90:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003e94:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003e96:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003e9a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003e9c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003e9e:	30 09       	mov	r9,0
80003ea0:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003ea2:	fb 69 00 08 	st.b	sp[8],r9
80003ea6:	fa c8 ff f7 	sub	r8,sp,-9
80003eaa:	b0 89       	st.b	r8[0x0],r9
80003eac:	fa c8 ff f6 	sub	r8,sp,-10
80003eb0:	b0 89       	st.b	r8[0x0],r9
80003eb2:	fa c8 ff f5 	sub	r8,sp,-11
80003eb6:	b0 89       	st.b	r8[0x0],r9
80003eb8:	fa c8 ff f4 	sub	r8,sp,-12
80003ebc:	b0 89       	st.b	r8[0x0],r9
80003ebe:	fa c8 ff f3 	sub	r8,sp,-13
80003ec2:	b0 89       	st.b	r8[0x0],r9
80003ec4:	fa c8 ff f2 	sub	r8,sp,-14
80003ec8:	b0 89       	st.b	r8[0x0],r9
80003eca:	fa c8 ff f1 	sub	r8,sp,-15
80003ece:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003ed0:	30 cb       	mov	r11,12
80003ed2:	fa cc ff fe 	sub	r12,sp,-2
80003ed6:	f0 1f 00 03 	mcall	80003ee0 <xcmp_IdleTestTone+0x5c>
}
80003eda:	2c dd       	sub	sp,-204
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3d 04       	mov	r4,-48

80003ee4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ee4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ee6:	48 dc       	lddpc	r12,80003f18 <xcmp_init+0x34>
80003ee8:	f0 1f 00 0d 	mcall	80003f1c <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003eec:	30 4b       	mov	r11,4
80003eee:	31 4c       	mov	r12,20
80003ef0:	f0 1f 00 0c 	mcall	80003f20 <xcmp_init+0x3c>
80003ef4:	48 c8       	lddpc	r8,80003f24 <xcmp_init+0x40>
80003ef6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ef8:	30 09       	mov	r9,0
80003efa:	1a d9       	st.w	--sp,r9
80003efc:	1a d9       	st.w	--sp,r9
80003efe:	1a d9       	st.w	--sp,r9
80003f00:	30 38       	mov	r8,3
80003f02:	e0 6a 01 80 	mov	r10,384
80003f06:	48 9b       	lddpc	r11,80003f28 <xcmp_init+0x44>
80003f08:	48 9c       	lddpc	r12,80003f2c <xcmp_init+0x48>
80003f0a:	f0 1f 00 0a 	mcall	80003f30 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003f0e:	f0 1f 00 0a 	mcall	80003f34 <xcmp_init+0x50>
80003f12:	2f dd       	sub	sp,-12
	
}
80003f14:	d8 02       	popm	pc
80003f16:	00 00       	add	r0,r0
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	40 34       	lddsp	r4,sp[0xc]
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	40 80       	lddsp	r0,sp[0x20]
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	66 4c       	ld.w	r12,r3[0x10]
80003f24:	00 00       	add	r0,r0
80003f26:	0b 10       	ld.sh	r0,r5++
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	d9 3c       	*unknown*
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	3f 38       	mov	r8,-13
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	6d 68       	ld.w	r8,r6[0x58]
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	40 b8       	lddsp	r8,sp[0x2c]

80003f38 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f38:	d4 31       	pushm	r0-r7,lr
80003f3a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f3c:	4b 16       	lddpc	r6,80004000 <xcmp_rx_process+0xc8>
80003f3e:	30 05       	mov	r5,0
80003f40:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f42:	4b 13       	lddpc	r3,80004004 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f44:	4b 12       	lddpc	r2,80004008 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f46:	4b 21       	lddpc	r1,8000400c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f48:	4b 20       	lddpc	r0,80004010 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f4a:	6c 0c       	ld.w	r12,r6[0x0]
80003f4c:	0a 99       	mov	r9,r5
80003f4e:	08 9a       	mov	r10,r4
80003f50:	1a 9b       	mov	r11,sp
80003f52:	f0 1f 00 31 	mcall	80004014 <xcmp_rx_process+0xdc>
80003f56:	58 1c       	cp.w	r12,1
80003f58:	cf 91       	brne	80003f4a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f5a:	40 0b       	lddsp	r11,sp[0x0]
80003f5c:	58 0b       	cp.w	r11,0
80003f5e:	cf 60       	breq	80003f4a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f60:	96 0a       	ld.sh	r10,r11[0x0]
80003f62:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f66:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f6a:	59 c8       	cp.w	r8,28
80003f6c:	c1 e0       	breq	80003fa8 <xcmp_rx_process+0x70>
80003f6e:	e0 89 00 07 	brgt	80003f7c <xcmp_rx_process+0x44>
80003f72:	58 e8       	cp.w	r8,14
80003f74:	c0 e0       	breq	80003f90 <xcmp_rx_process+0x58>
80003f76:	58 f8       	cp.w	r8,15
80003f78:	c2 41       	brne	80003fc0 <xcmp_rx_process+0x88>
80003f7a:	c0 f8       	rjmp	80003f98 <xcmp_rx_process+0x60>
80003f7c:	e0 48 01 09 	cp.w	r8,265
80003f80:	c1 80       	breq	80003fb0 <xcmp_rx_process+0x78>
80003f82:	e0 48 01 0a 	cp.w	r8,266
80003f86:	c1 90       	breq	80003fb8 <xcmp_rx_process+0x80>
80003f88:	e0 48 00 2c 	cp.w	r8,44
80003f8c:	c1 a1       	brne	80003fc0 <xcmp_rx_process+0x88>
80003f8e:	c0 98       	rjmp	80003fa0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003f90:	4a 2c       	lddpc	r12,80004018 <xcmp_rx_process+0xe0>
80003f92:	f0 1f 00 23 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003f96:	c2 f8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003f98:	4a 2c       	lddpc	r12,80004020 <xcmp_rx_process+0xe8>
80003f9a:	f0 1f 00 21 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003f9e:	c2 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003fa0:	4a 1c       	lddpc	r12,80004024 <xcmp_rx_process+0xec>
80003fa2:	f0 1f 00 1f 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fa6:	c2 78       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fa8:	04 9c       	mov	r12,r2
80003faa:	f0 1f 00 1d 	mcall	8000401c <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003fae:	c2 38       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fb0:	02 9c       	mov	r12,r1
80003fb2:	f0 1f 00 1b 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fb6:	c1 f8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fb8:	00 9c       	mov	r12,r0
80003fba:	f0 1f 00 19 	mcall	8000401c <xcmp_rx_process+0xe4>
					break;
80003fbe:	c1 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fc0:	12 98       	mov	r8,r9
80003fc2:	e2 18 04 00 	andl	r8,0x400,COH
80003fc6:	c0 70       	breq	80003fd4 <xcmp_rx_process+0x9c>
80003fc8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fcc:	e0 48 00 68 	cp.w	r8,104
80003fd0:	e0 8a 00 08 	brle	80003fe0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003fd4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003fd8:	c0 e1       	brne	80003ff4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003fda:	f0 1f 00 14 	mcall	80004028 <xcmp_rx_process+0xf0>
80003fde:	c0 b8       	rjmp	80003ff4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003fe0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003fe4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003fe8:	49 19       	lddpc	r9,8000402c <xcmp_rx_process+0xf4>
80003fea:	72 08       	ld.w	r8,r9[0x0]
80003fec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003ff0:	f0 1f 00 0b 	mcall	8000401c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ff4:	66 0c       	ld.w	r12,r3[0x0]
80003ff6:	40 0b       	lddsp	r11,sp[0x0]
80003ff8:	f0 1f 00 0e 	mcall	80004030 <xcmp_rx_process+0xf8>
80003ffc:	ca 7b       	rjmp	80003f4a <xcmp_rx_process+0x12>
80003ffe:	00 00       	add	r0,r0
80004000:	00 00       	add	r0,r0
80004002:	0b 10       	ld.sh	r0,r5++
80004004:	00 00       	add	r0,r0
80004006:	0a a4       	st.w	r5++,r4
80004008:	00 00       	add	r0,r0
8000400a:	0b 20       	ld.uh	r0,r5++
8000400c:	00 00       	add	r0,r0
8000400e:	0b 14       	ld.sh	r4,r5++
80004010:	00 00       	add	r0,r0
80004012:	0b 04       	ld.w	r4,r5++
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	63 40       	ld.w	r0,r1[0x50]
80004018:	00 00       	add	r0,r0
8000401a:	0b 38       	ld.ub	r8,r5++
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	3e 3c       	mov	r12,-29
80004020:	00 00       	add	r0,r0
80004022:	0a f8       	st.b	--r5,r8
80004024:	00 00       	add	r0,r0
80004026:	0b 2c       	ld.uh	r12,r5++
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3e 18       	mov	r8,-31
8000402c:	00 00       	add	r0,r0
8000402e:	51 6c       	stdsp	sp[0x58],r12
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	29 d0       	sub	r0,-99

80004034 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004034:	eb cd 40 90 	pushm	r4,r7,lr
80004038:	20 1d       	sub	sp,4
8000403a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000403e:	48 c8       	lddpc	r8,8000406c <xcmp_rx+0x38>
80004040:	70 0c       	ld.w	r12,r8[0x0]
80004042:	f0 1f 00 0c 	mcall	80004070 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004046:	c1 00       	breq	80004066 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004048:	fa c7 ff fc 	sub	r7,sp,-4
8000404c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000404e:	e0 6a 00 ca 	mov	r10,202
80004052:	08 9b       	mov	r11,r4
80004054:	f0 1f 00 08 	mcall	80004074 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004058:	48 88       	lddpc	r8,80004078 <xcmp_rx+0x44>
8000405a:	70 0c       	ld.w	r12,r8[0x0]
8000405c:	30 09       	mov	r9,0
8000405e:	12 9a       	mov	r10,r9
80004060:	1a 9b       	mov	r11,sp
80004062:	f0 1f 00 07 	mcall	8000407c <xcmp_rx+0x48>
	}	
}
80004066:	2f fd       	sub	sp,-4
80004068:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000406c:	00 00       	add	r0,r0
8000406e:	0a a4       	st.w	r5++,r4
80004070:	80 00       	ld.sh	r0,r0[0x0]
80004072:	2b 7c       	sub	r12,-73
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	79 d2       	ld.w	r2,r12[0x74]
80004078:	00 00       	add	r0,r0
8000407a:	0b 10       	ld.sh	r0,r5++
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	65 4c       	ld.w	r12,r2[0x50]

80004080 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004080:	48 28       	lddpc	r8,80004088 <xnl_register_xcmp_func+0x8>
80004082:	91 0c       	st.w	r8[0x0],r12
}
80004084:	5e fc       	retal	r12
80004086:	00 00       	add	r0,r0
80004088:	00 00       	add	r0,r0
8000408a:	0b 64       	ld.uh	r4,--r5

8000408c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000408c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000408e:	48 88       	lddpc	r8,800040ac <xnl_get_msg_ack_func+0x20>
80004090:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004092:	98 49       	ld.sh	r9,r12[0x8]
80004094:	f0 09 19 00 	cp.h	r9,r8
80004098:	c0 81       	brne	800040a8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000409a:	48 68       	lddpc	r8,800040b0 <xnl_get_msg_ack_func+0x24>
8000409c:	70 0c       	ld.w	r12,r8[0x0]
8000409e:	30 09       	mov	r9,0
800040a0:	12 9a       	mov	r10,r9
800040a2:	12 9b       	mov	r11,r9
800040a4:	f0 1f 00 04 	mcall	800040b4 <xnl_get_msg_ack_func+0x28>
800040a8:	d8 02       	popm	pc
800040aa:	00 00       	add	r0,r0
800040ac:	00 00       	add	r0,r0
800040ae:	0b 4a       	ld.w	r10,--r5
800040b0:	00 00       	add	r0,r0
800040b2:	0b 44       	ld.w	r4,--r5
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	65 4c       	ld.w	r12,r2[0x50]

800040b8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040b8:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040bc:	30 09       	mov	r9,0
800040be:	4b 78       	lddpc	r8,80004198 <xnl_init+0xe0>
800040c0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040c2:	30 0b       	mov	r11,0
800040c4:	30 1c       	mov	r12,1
800040c6:	f0 1f 00 36 	mcall	8000419c <xnl_init+0xe4>
800040ca:	4b 68       	lddpc	r8,800041a0 <xnl_init+0xe8>
800040cc:	91 0c       	st.w	r8[0x0],r12
800040ce:	70 08       	ld.w	r8,r8[0x0]
800040d0:	58 08       	cp.w	r8,0
800040d2:	c0 80       	breq	800040e2 <xnl_init+0x2a>
800040d4:	4b 38       	lddpc	r8,800041a0 <xnl_init+0xe8>
800040d6:	70 0c       	ld.w	r12,r8[0x0]
800040d8:	30 09       	mov	r9,0
800040da:	12 9a       	mov	r10,r9
800040dc:	12 9b       	mov	r11,r9
800040de:	f0 1f 00 32 	mcall	800041a4 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800040e2:	30 4b       	mov	r11,4
800040e4:	31 4c       	mov	r12,20
800040e6:	f0 1f 00 2e 	mcall	8000419c <xnl_init+0xe4>
800040ea:	4b 08       	lddpc	r8,800041a8 <xnl_init+0xf0>
800040ec:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040ee:	30 4b       	mov	r11,4
800040f0:	31 ec       	mov	r12,30
800040f2:	f0 1f 00 2b 	mcall	8000419c <xnl_init+0xe4>
800040f6:	4a e8       	lddpc	r8,800041ac <xnl_init+0xf4>
800040f8:	91 0c       	st.w	r8[0x0],r12
800040fa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040fc:	10 96       	mov	r6,r8
800040fe:	4a d5       	lddpc	r5,800041b0 <xnl_init+0xf8>
80004100:	6c 0c       	ld.w	r12,r6[0x0]
80004102:	ea 07 00 0b 	add	r11,r5,r7
80004106:	f0 1f 00 2c 	mcall	800041b4 <xnl_init+0xfc>
8000410a:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000410e:	e0 47 1e 00 	cp.w	r7,7680
80004112:	cf 71       	brne	80004100 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004114:	30 4b       	mov	r11,4
80004116:	31 4c       	mov	r12,20
80004118:	f0 1f 00 21 	mcall	8000419c <xnl_init+0xe4>
8000411c:	4a 78       	lddpc	r8,800041b8 <xnl_init+0x100>
8000411e:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004120:	30 4b       	mov	r11,4
80004122:	30 ac       	mov	r12,10
80004124:	f0 1f 00 1e 	mcall	8000419c <xnl_init+0xe4>
80004128:	4a 58       	lddpc	r8,800041bc <xnl_init+0x104>
8000412a:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000412c:	30 4b       	mov	r11,4
8000412e:	30 ac       	mov	r12,10
80004130:	f0 1f 00 1b 	mcall	8000419c <xnl_init+0xe4>
80004134:	4a 38       	lddpc	r8,800041c0 <xnl_init+0x108>
80004136:	91 0c       	st.w	r8[0x0],r12
80004138:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000413a:	10 96       	mov	r6,r8
8000413c:	4a 25       	lddpc	r5,800041c4 <xnl_init+0x10c>
8000413e:	6c 0c       	ld.w	r12,r6[0x0]
80004140:	ea 07 00 0b 	add	r11,r5,r7
80004144:	f0 1f 00 1c 	mcall	800041b4 <xnl_init+0xfc>
80004148:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000414c:	e0 47 14 00 	cp.w	r7,5120
80004150:	cf 71       	brne	8000413e <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004152:	30 4b       	mov	r11,4
80004154:	30 5c       	mov	r12,5
80004156:	f0 1f 00 12 	mcall	8000419c <xnl_init+0xe4>
8000415a:	49 c8       	lddpc	r8,800041c8 <xnl_init+0x110>
8000415c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000415e:	30 07       	mov	r7,0
80004160:	1a d7       	st.w	--sp,r7
80004162:	1a d7       	st.w	--sp,r7
80004164:	1a d7       	st.w	--sp,r7
80004166:	30 38       	mov	r8,3
80004168:	0e 99       	mov	r9,r7
8000416a:	e0 6a 02 00 	mov	r10,512
8000416e:	49 8b       	lddpc	r11,800041cc <xnl_init+0x114>
80004170:	49 8c       	lddpc	r12,800041d0 <xnl_init+0x118>
80004172:	f0 1f 00 19 	mcall	800041d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004176:	1a d7       	st.w	--sp,r7
80004178:	1a d7       	st.w	--sp,r7
8000417a:	1a d7       	st.w	--sp,r7
8000417c:	30 38       	mov	r8,3
8000417e:	0e 99       	mov	r9,r7
80004180:	e0 6a 03 20 	mov	r10,800
80004184:	49 5b       	lddpc	r11,800041d8 <xnl_init+0x120>
80004186:	49 6c       	lddpc	r12,800041dc <xnl_init+0x124>
80004188:	f0 1f 00 13 	mcall	800041d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000418c:	f0 1f 00 15 	mcall	800041e0 <xnl_init+0x128>
80004190:	2f ad       	sub	sp,-24
}
80004192:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004196:	00 00       	add	r0,r0
80004198:	00 00       	add	r0,r0
8000419a:	0b 4a       	ld.w	r10,--r5
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	66 4c       	ld.w	r12,r3[0x10]
800041a0:	00 00       	add	r0,r0
800041a2:	0b 44       	ld.w	r4,--r5
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	65 4c       	ld.w	r12,r2[0x50]
800041a8:	00 00       	add	r0,r0
800041aa:	0b 58       	ld.sh	r8,--r5
800041ac:	00 00       	add	r0,r0
800041ae:	0a a4       	st.w	r5++,r4
800041b0:	00 00       	add	r0,r0
800041b2:	33 1e       	mov	lr,49
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	29 d0       	sub	r0,-99
800041b8:	00 00       	add	r0,r0
800041ba:	0a dc       	st.w	--r5,r12
800041bc:	00 00       	add	r0,r0
800041be:	0a b8       	st.h	r5++,r8
800041c0:	00 00       	add	r0,r0
800041c2:	0a ac       	st.w	r5++,r12
800041c4:	00 00       	add	r0,r0
800041c6:	1f 1e       	ld.sh	lr,pc++
800041c8:	00 00       	add	r0,r0
800041ca:	0a a0       	st.w	r5++,r0
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	d9 44       	*unknown*
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	41 e4       	lddsp	r4,sp[0x78]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	6d 68       	ld.w	r8,r6[0x58]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	d2 00       	acall	0x20
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	42 44       	lddsp	r4,sp[0x90]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	2b a4       	sub	r4,-70

800041e4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041e4:	eb cd 40 fe 	pushm	r1-r7,lr
800041e8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041ea:	49 26       	lddpc	r6,80004230 <xnl_rx_process+0x4c>
800041ec:	30 05       	mov	r5,0
800041ee:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041f0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041f2:	49 11       	lddpc	r1,80004234 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041f4:	49 12       	lddpc	r2,80004238 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041f6:	6c 0c       	ld.w	r12,r6[0x0]
800041f8:	0a 99       	mov	r9,r5
800041fa:	08 9a       	mov	r10,r4
800041fc:	1a 9b       	mov	r11,sp
800041fe:	f0 1f 00 10 	mcall	8000423c <xnl_rx_process+0x58>
80004202:	58 1c       	cp.w	r12,1
80004204:	cf 91       	brne	800041f6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004206:	40 0c       	lddsp	r12,sp[0x0]
80004208:	58 0c       	cp.w	r12,0
8000420a:	cf 60       	breq	800041f6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000420c:	98 28       	ld.sh	r8,r12[0x4]
8000420e:	e6 08 19 00 	cp.h	r8,r3
80004212:	e0 8b 00 0a 	brhi	80004226 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004216:	5c 78       	castu.h	r8
80004218:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000421c:	58 09       	cp.w	r9,0
8000421e:	c0 40       	breq	80004226 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004220:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004224:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004226:	62 0c       	ld.w	r12,r1[0x0]
80004228:	40 0b       	lddsp	r11,sp[0x0]
8000422a:	f0 1f 00 06 	mcall	80004240 <xnl_rx_process+0x5c>
8000422e:	ce 4b       	rjmp	800041f6 <xnl_rx_process+0x12>
80004230:	00 00       	add	r0,r0
80004232:	0a b8       	st.h	r5++,r8
80004234:	00 00       	add	r0,r0
80004236:	0a a4       	st.w	r5++,r4
80004238:	00 00       	add	r0,r0
8000423a:	04 f0       	st.b	--r2,r0
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	63 40       	ld.w	r0,r1[0x50]
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	29 d0       	sub	r0,-99

80004244 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004244:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004246:	4a a6       	lddpc	r6,800042ec <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004248:	4a a2       	lddpc	r2,800042f0 <xnl_tx_process+0xac>
8000424a:	4a b4       	lddpc	r4,800042f4 <xnl_tx_process+0xb0>
8000424c:	30 07       	mov	r7,0
8000424e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004250:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004252:	4a a5       	lddpc	r5,800042f8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004254:	4a a3       	lddpc	r3,800042fc <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004256:	6c 08       	ld.w	r8,r6[0x0]
80004258:	58 08       	cp.w	r8,0
8000425a:	c0 40       	breq	80004262 <xnl_tx_process+0x1e>
8000425c:	58 18       	cp.w	r8,1
8000425e:	cf d1       	brne	80004258 <xnl_tx_process+0x14>
80004260:	c2 48       	rjmp	800042a8 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004262:	64 0c       	ld.w	r12,r2[0x0]
80004264:	0e 99       	mov	r9,r7
80004266:	02 9a       	mov	r10,r1
80004268:	08 9b       	mov	r11,r4
8000426a:	f0 1f 00 26 	mcall	80004300 <xnl_tx_process+0xbc>
8000426e:	58 1c       	cp.w	r12,1
80004270:	cf 31       	brne	80004256 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004272:	68 0b       	ld.w	r11,r4[0x0]
80004274:	58 0b       	cp.w	r11,0
80004276:	cf 00       	breq	80004256 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004278:	96 28       	ld.sh	r8,r11[0x4]
8000427a:	e0 08 19 00 	cp.h	r8,r0
8000427e:	c0 71       	brne	8000428c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004280:	4a 18       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
80004282:	70 08       	ld.w	r8,r8[0x0]
80004284:	10 9c       	mov	r12,r8
80004286:	f0 1f 00 21 	mcall	80004308 <xnl_tx_process+0xc4>
						break;
8000428a:	ce 6b       	rjmp	80004256 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000428c:	16 9c       	mov	r12,r11
8000428e:	f0 1f 00 20 	mcall	8000430c <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004292:	30 18       	mov	r8,1
80004294:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004296:	66 0c       	ld.w	r12,r3[0x0]
80004298:	0e 99       	mov	r9,r7
8000429a:	0e 9a       	mov	r10,r7
8000429c:	0e 9b       	mov	r11,r7
8000429e:	f0 1f 00 19 	mcall	80004300 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800042a2:	30 18       	mov	r8,1
800042a4:	8d 08       	st.w	r6[0x0],r8
800042a6:	cd 8b       	rjmp	80004256 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042a8:	66 0c       	ld.w	r12,r3[0x0]
800042aa:	0e 99       	mov	r9,r7
800042ac:	36 4a       	mov	r10,100
800042ae:	0e 9b       	mov	r11,r7
800042b0:	f0 1f 00 14 	mcall	80004300 <xnl_tx_process+0xbc>
800042b4:	58 1c       	cp.w	r12,1
800042b6:	c0 81       	brne	800042c6 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042b8:	49 38       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
800042ba:	70 0c       	ld.w	r12,r8[0x0]
800042bc:	68 0b       	ld.w	r11,r4[0x0]
800042be:	f0 1f 00 13 	mcall	80004308 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042c2:	8d 07       	st.w	r6[0x0],r7
800042c4:	cc 9b       	rjmp	80004256 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042c6:	6a 08       	ld.w	r8,r5[0x0]
800042c8:	58 38       	cp.w	r8,3
800042ca:	e0 89 00 09 	brgt	800042dc <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042ce:	68 0c       	ld.w	r12,r4[0x0]
800042d0:	f0 1f 00 0f 	mcall	8000430c <xnl_tx_process+0xc8>
						xnl_send_times++;
800042d4:	6a 08       	ld.w	r8,r5[0x0]
800042d6:	2f f8       	sub	r8,-1
800042d8:	8b 08       	st.w	r5[0x0],r8
800042da:	cb eb       	rjmp	80004256 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042dc:	48 a8       	lddpc	r8,80004304 <xnl_tx_process+0xc0>
800042de:	70 0c       	ld.w	r12,r8[0x0]
800042e0:	68 0b       	ld.w	r11,r4[0x0]
800042e2:	f0 1f 00 0a 	mcall	80004308 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042e6:	8d 07       	st.w	r6[0x0],r7
800042e8:	cb 7b       	rjmp	80004256 <xnl_tx_process+0x12>
800042ea:	00 00       	add	r0,r0
800042ec:	00 00       	add	r0,r0
800042ee:	0b 54       	ld.sh	r4,--r5
800042f0:	00 00       	add	r0,r0
800042f2:	0b 58       	ld.sh	r8,--r5
800042f4:	00 00       	add	r0,r0
800042f6:	0b 60       	ld.uh	r0,--r5
800042f8:	00 00       	add	r0,r0
800042fa:	0b 5c       	ld.sh	r12,--r5
800042fc:	00 00       	add	r0,r0
800042fe:	0b 44       	ld.w	r4,--r5
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	63 40       	ld.w	r0,r1[0x50]
80004304:	00 00       	add	r0,r0
80004306:	0a a4       	st.w	r5++,r4
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	29 d0       	sub	r0,-99
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	29 f0       	sub	r0,-97

80004310 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004310:	eb cd 40 c0 	pushm	r6-r7,lr
80004314:	20 1d       	sub	sp,4
80004316:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004318:	98 39       	ld.sh	r9,r12[0x6]
8000431a:	3f f8       	mov	r8,-1
8000431c:	f0 09 19 00 	cp.h	r9,r8
80004320:	c0 a1       	brne	80004334 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004322:	4a e9       	lddpc	r9,800043d8 <xnl_tx+0xc8>
80004324:	13 88       	ld.ub	r8,r9[0x0]
80004326:	2f f8       	sub	r8,-1
80004328:	5c 58       	castu.b	r8
8000432a:	b2 88       	st.b	r9[0x0],r8
8000432c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004330:	a9 a8       	sbr	r8,0x8
80004332:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004334:	8c 49       	ld.sh	r9,r6[0x8]
80004336:	3f f8       	mov	r8,-1
80004338:	f0 09 19 00 	cp.h	r9,r8
8000433c:	c0 41       	brne	80004344 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000433e:	4a 88       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004340:	90 18       	ld.sh	r8,r8[0x2]
80004342:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004344:	8c 59       	ld.sh	r9,r6[0xa]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 41       	brne	80004354 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000434e:	4a 48       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004350:	90 28       	ld.sh	r8,r8[0x4]
80004352:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004354:	8c 69       	ld.sh	r9,r6[0xc]
80004356:	3f f8       	mov	r8,-1
80004358:	f0 09 19 00 	cp.h	r9,r8
8000435c:	c0 e1       	brne	80004378 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000435e:	4a 08       	lddpc	r8,800043dc <xnl_tx+0xcc>
80004360:	90 49       	ld.sh	r9,r8[0x8]
80004362:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004364:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004366:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004368:	90 49       	ld.sh	r9,r8[0x8]
8000436a:	e0 19 ff 00 	andl	r9,0xff00
8000436e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004372:	f3 e8 10 08 	or	r8,r9,r8
80004376:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004378:	0d 98       	ld.ub	r8,r6[0x1]
8000437a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000437c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004380:	10 0c       	add	r12,r8
80004382:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004384:	58 0c       	cp.w	r12,0
80004386:	e0 89 00 04 	brgt	8000438e <xnl_tx+0x7e>
8000438a:	30 09       	mov	r9,0
8000438c:	c0 d8       	rjmp	800043a6 <xnl_tx+0x96>
8000438e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004392:	2f ec       	sub	r12,-2
80004394:	30 09       	mov	r9,0
80004396:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004398:	15 1b       	ld.sh	r11,r10++
8000439a:	f6 09 00 09 	add	r9,r11,r9
8000439e:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043a0:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043a2:	18 38       	cp.w	r8,r12
800043a4:	cf a1       	brne	80004398 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043a6:	5c 39       	neg	r9
800043a8:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043aa:	48 e8       	lddpc	r8,800043e0 <xnl_tx+0xd0>
800043ac:	70 0c       	ld.w	r12,r8[0x0]
800043ae:	f0 1f 00 0e 	mcall	800043e4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043b2:	c1 00       	breq	800043d2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043b4:	fa c7 ff fc 	sub	r7,sp,-4
800043b8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043ba:	e0 6a 01 00 	mov	r10,256
800043be:	0c 9b       	mov	r11,r6
800043c0:	f0 1f 00 0a 	mcall	800043e8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043c4:	48 a8       	lddpc	r8,800043ec <xnl_tx+0xdc>
800043c6:	70 0c       	ld.w	r12,r8[0x0]
800043c8:	30 09       	mov	r9,0
800043ca:	12 9a       	mov	r10,r9
800043cc:	1a 9b       	mov	r11,sp
800043ce:	f0 1f 00 09 	mcall	800043f0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043d2:	2f fd       	sub	sp,-4
800043d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043d8:	00 00       	add	r0,r0
800043da:	0b 48       	ld.w	r8,--r5
800043dc:	00 00       	add	r0,r0
800043de:	0b 4a       	ld.w	r10,--r5
800043e0:	00 00       	add	r0,r0
800043e2:	0a a4       	st.w	r5++,r4
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	2b 7c       	sub	r12,-73
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	79 d2       	ld.w	r2,r12[0x74]
800043ec:	00 00       	add	r0,r0
800043ee:	0b 58       	ld.sh	r8,--r5
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	65 4c       	ld.w	r12,r2[0x50]

800043f4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800043f4:	eb cd 40 80 	pushm	r7,lr
800043f8:	fa cd 01 00 	sub	sp,sp,256
800043fc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800043fe:	e0 68 40 0e 	mov	r8,16398
80004402:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004404:	3f f8       	mov	r8,-1
80004406:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004408:	30 c8       	mov	r8,12
8000440a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000440c:	98 38       	ld.sh	r8,r12[0x6]
8000440e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004410:	98 58       	ld.sh	r8,r12[0xa]
80004412:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004414:	98 48       	ld.sh	r8,r12[0x8]
80004416:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004418:	98 68       	ld.sh	r8,r12[0xc]
8000441a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000441c:	30 08       	mov	r8,0
8000441e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004420:	1a 9c       	mov	r12,sp
80004422:	f0 1f 00 0a 	mcall	80004448 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004426:	fa cd 00 cc 	sub	sp,sp,204
8000442a:	e0 6a 00 ca 	mov	r10,202
8000442e:	ee cb ff f0 	sub	r11,r7,-16
80004432:	1a 9c       	mov	r12,sp
80004434:	f0 1f 00 06 	mcall	8000444c <xnl_data_msg_func+0x58>
80004438:	48 68       	lddpc	r8,80004450 <xnl_data_msg_func+0x5c>
8000443a:	70 08       	ld.w	r8,r8[0x0]
8000443c:	5d 18       	icall	r8
8000443e:	fa cd ff 34 	sub	sp,sp,-204
}
80004442:	2c 0d       	sub	sp,-256
80004444:	e3 cd 80 80 	ldm	sp++,r7,pc
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	43 10       	lddsp	r0,sp[0xc4]
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	79 d2       	ld.w	r2,r12[0x74]
80004450:	00 00       	add	r0,r0
80004452:	0b 64       	ld.uh	r4,--r5

80004454 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004454:	d4 21       	pushm	r4-r7,lr
80004456:	fa cd 01 00 	sub	sp,sp,256
8000445a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000445c:	4c 28       	lddpc	r8,80004564 <xnl_device_auth_reply_func+0x110>
8000445e:	11 88       	ld.ub	r8,r8[0x0]
80004460:	58 08       	cp.w	r8,0
80004462:	e0 81 00 7f 	brne	80004560 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004466:	4c 18       	lddpc	r8,80004568 <xnl_device_auth_reply_func+0x114>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	30 09       	mov	r9,0
8000446c:	12 9a       	mov	r10,r9
8000446e:	12 9b       	mov	r11,r9
80004470:	f0 1f 00 3f 	mcall	8000456c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004474:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004478:	4b b8       	lddpc	r8,80004564 <xnl_device_auth_reply_func+0x110>
8000447a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000447c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004480:	ef 38 00 13 	ld.ub	r8,r7[19]
80004484:	b1 68       	lsl	r8,0x10
80004486:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000448a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000448e:	f3 e8 10 08 	or	r8,r9,r8
80004492:	ef 39 00 14 	ld.ub	r9,r7[20]
80004496:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000449a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000449e:	ef 38 00 17 	ld.ub	r8,r7[23]
800044a2:	b1 68       	lsl	r8,0x10
800044a4:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800044a8:	ef 38 00 19 	ld.ub	r8,r7[25]
800044ac:	f5 e8 10 08 	or	r8,r10,r8
800044b0:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044b4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044b8:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044ba:	e0 64 79 b9 	mov	r4,31161
800044be:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044c2:	e0 65 45 07 	mov	r5,17671
800044c6:	ea 15 8a bd 	orh	r5,0x8abd
800044ca:	e0 66 f9 3d 	mov	r6,63805
800044ce:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044d2:	e0 6e b8 cf 	mov	lr,47311
800044d6:	ea 1e 36 83 	orh	lr,0x3683
800044da:	e0 67 aa 1c 	mov	r7,43548
800044de:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044e2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044e4:	f4 08 00 0c 	add	r12,r10,r8
800044e8:	f0 0b 15 04 	lsl	r11,r8,0x4
800044ec:	0a 0b       	add	r11,r5
800044ee:	f9 eb 20 0b 	eor	r11,r12,r11
800044f2:	f0 0c 16 05 	lsr	r12,r8,0x5
800044f6:	0c 0c       	add	r12,r6
800044f8:	18 5b       	eor	r11,r12
800044fa:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044fc:	f2 0c 15 04 	lsl	r12,r9,0x4
80004500:	1c 0c       	add	r12,lr
80004502:	f2 0b 16 05 	lsr	r11,r9,0x5
80004506:	0e 0b       	add	r11,r7
80004508:	f9 eb 20 0b 	eor	r11,r12,r11
8000450c:	f2 0a 00 0c 	add	r12,r9,r10
80004510:	18 5b       	eor	r11,r12
80004512:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004514:	e0 6b 37 20 	mov	r11,14112
80004518:	ea 1b c6 ef 	orh	r11,0xc6ef
8000451c:	16 3a       	cp.w	r10,r11
8000451e:	ce 21       	brne	800044e2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004520:	e0 6a 40 1a 	mov	r10,16410
80004524:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004526:	3f fa       	mov	r10,-1
80004528:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000452a:	30 6b       	mov	r11,6
8000452c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000452e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004530:	48 db       	lddpc	r11,80004564 <xnl_device_auth_reply_func+0x110>
80004532:	96 1c       	ld.sh	r12,r11[0x2]
80004534:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004536:	96 2b       	ld.sh	r11,r11[0x4]
80004538:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000453a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000453c:	30 ca       	mov	r10,12
8000453e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004540:	30 0a       	mov	r10,0
80004542:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004546:	30 7a       	mov	r10,7
80004548:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000454c:	30 2a       	mov	r10,2
8000454e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004552:	fa ca ff ec 	sub	r10,sp,-20
80004556:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004558:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000455a:	1a 9c       	mov	r12,sp
8000455c:	f0 1f 00 05 	mcall	80004570 <xnl_device_auth_reply_func+0x11c>
}
80004560:	2c 0d       	sub	sp,-256
80004562:	d8 22       	popm	r4-r7,pc
80004564:	00 00       	add	r0,r0
80004566:	0b 4a       	ld.w	r10,--r5
80004568:	00 00       	add	r0,r0
8000456a:	0b 44       	ld.w	r4,--r5
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	65 4c       	ld.w	r12,r2[0x50]
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	43 10       	lddsp	r0,sp[0xc4]

80004574 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004574:	eb cd 40 80 	pushm	r7,lr
80004578:	fa cd 01 00 	sub	sp,sp,256
8000457c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000457e:	49 28       	lddpc	r8,800045c4 <xnl_master_status_brdcst_func+0x50>
80004580:	11 88       	ld.ub	r8,r8[0x0]
80004582:	58 08       	cp.w	r8,0
80004584:	c1 c1       	brne	800045bc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004586:	49 18       	lddpc	r8,800045c8 <xnl_master_status_brdcst_func+0x54>
80004588:	70 0c       	ld.w	r12,r8[0x0]
8000458a:	30 09       	mov	r9,0
8000458c:	12 9a       	mov	r10,r9
8000458e:	12 9b       	mov	r11,r9
80004590:	f0 1f 00 0f 	mcall	800045cc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004594:	8e 58       	ld.sh	r8,r7[0xa]
80004596:	48 c9       	lddpc	r9,800045c4 <xnl_master_status_brdcst_func+0x50>
80004598:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000459a:	e0 68 40 0e 	mov	r8,16398
8000459e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045a0:	3f f8       	mov	r8,-1
800045a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800045a4:	30 4a       	mov	r10,4
800045a6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045a8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045aa:	92 19       	ld.sh	r9,r9[0x2]
800045ac:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800045ae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045b0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045b2:	30 08       	mov	r8,0
800045b4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045b6:	1a 9c       	mov	r12,sp
800045b8:	f0 1f 00 06 	mcall	800045d0 <xnl_master_status_brdcst_func+0x5c>
}
800045bc:	2c 0d       	sub	sp,-256
800045be:	e3 cd 80 80 	ldm	sp++,r7,pc
800045c2:	00 00       	add	r0,r0
800045c4:	00 00       	add	r0,r0
800045c6:	0b 4a       	ld.w	r10,--r5
800045c8:	00 00       	add	r0,r0
800045ca:	0b 44       	ld.w	r4,--r5
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	65 4c       	ld.w	r12,r2[0x50]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	43 10       	lddsp	r0,sp[0xc4]

800045d4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800045d4:	eb cd 40 80 	pushm	r7,lr
800045d8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800045da:	49 28       	lddpc	r8,80004620 <xnl_device_conn_reply_func+0x4c>
800045dc:	70 0c       	ld.w	r12,r8[0x0]
800045de:	30 09       	mov	r9,0
800045e0:	12 9a       	mov	r10,r9
800045e2:	12 9b       	mov	r11,r9
800045e4:	f0 1f 00 10 	mcall	80004624 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045e8:	ef 18 00 10 	ld.uh	r8,r7[16]
800045ec:	10 99       	mov	r9,r8
800045ee:	e2 19 ff 00 	andl	r9,0xff00,COH
800045f2:	e0 49 01 00 	cp.w	r9,256
800045f6:	c0 60       	breq	80004602 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800045f8:	0e 9c       	mov	r12,r7
800045fa:	f0 1f 00 0c 	mcall	80004628 <xnl_device_conn_reply_func+0x54>
800045fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004602:	a9 68       	lsl	r8,0x8
80004604:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004608:	48 98       	lddpc	r8,8000462c <xnl_device_conn_reply_func+0x58>
8000460a:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000460c:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004610:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004612:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004616:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004618:	30 19       	mov	r9,1
8000461a:	b0 89       	st.b	r8[0x0],r9
8000461c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004620:	00 00       	add	r0,r0
80004622:	0b 44       	ld.w	r4,--r5
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	65 4c       	ld.w	r12,r2[0x50]
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	45 74       	lddsp	r4,sp[0x15c]
8000462c:	00 00       	add	r0,r0
8000462e:	0b 4a       	ld.w	r10,--r5

80004630 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004630:	d4 01       	pushm	lr
80004632:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004636:	e0 68 40 0e 	mov	r8,16398
8000463a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000463c:	3f f8       	mov	r8,-1
8000463e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004640:	30 38       	mov	r8,3
80004642:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004644:	30 08       	mov	r8,0
80004646:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004648:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000464a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000464c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000464e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004650:	1a 9c       	mov	r12,sp
80004652:	f0 1f 00 03 	mcall	8000465c <xnl_send_device_master_query+0x2c>
}
80004656:	2c 0d       	sub	sp,-256
80004658:	d8 02       	popm	pc
8000465a:	00 00       	add	r0,r0
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	43 10       	lddsp	r0,sp[0xc4]

80004660 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004660:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004662:	48 78       	lddpc	r8,8000467c <RC522_SPI_SetSpeed+0x1c>
80004664:	70 09       	ld.w	r9,r8[0x0]
80004666:	72 ca       	ld.w	r10,r9[0x30]
80004668:	5c 7c       	castu.h	r12
8000466a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000466e:	f9 ea 10 0a 	or	r10,r12,r10
80004672:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004674:	70 0c       	ld.w	r12,r8[0x0]
80004676:	f0 1f 00 03 	mcall	80004680 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000467a:	d8 02       	popm	pc
8000467c:	00 00       	add	r0,r0
8000467e:	1d f8       	ld.ub	r8,lr[0x7]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	5a 3c       	cp.w	r12,-29

80004684 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004684:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004686:	e0 6c 04 00 	mov	r12,1024
8000468a:	f0 1f 00 02 	mcall	80004690 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000468e:	d8 02       	popm	pc
80004690:	80 00       	ld.sh	r0,r0[0x0]
80004692:	46 60       	lddsp	r0,sp[0x198]

80004694 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004694:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004698:	48 b7       	lddpc	r7,800046c4 <RC522_ReadByte+0x30>
8000469a:	30 0b       	mov	r11,0
8000469c:	6e 0c       	ld.w	r12,r7[0x0]
8000469e:	f0 1f 00 0b 	mcall	800046c8 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046a2:	e0 6b 00 ff 	mov	r11,255
800046a6:	6e 0c       	ld.w	r12,r7[0x0]
800046a8:	f0 1f 00 09 	mcall	800046cc <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800046ac:	30 06       	mov	r6,0
800046ae:	0c 9b       	mov	r11,r6
800046b0:	6e 0c       	ld.w	r12,r7[0x0]
800046b2:	f0 1f 00 08 	mcall	800046d0 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046b6:	0c 9b       	mov	r11,r6
800046b8:	6e 0c       	ld.w	r12,r7[0x0]
800046ba:	f0 1f 00 07 	mcall	800046d4 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
800046be:	0d 9c       	ld.ub	r12,r6[0x1]
800046c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046c4:	00 00       	add	r0,r0
800046c6:	1d f8       	ld.ub	r8,lr[0x7]
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	5b a8       	cp.w	r8,-6
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	5a 42       	cp.w	r2,-28
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	5a 5e       	cp.w	lr,-27
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	5b 68       	cp.w	r8,-10

800046d8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800046d8:	eb cd 40 c0 	pushm	r6-r7,lr
800046dc:	20 1d       	sub	sp,4
800046de:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800046e0:	48 c7       	lddpc	r7,80004710 <RC522_WriteByte+0x38>
800046e2:	30 0b       	mov	r11,0
800046e4:	6e 0c       	ld.w	r12,r7[0x0]
800046e6:	f0 1f 00 0c 	mcall	80004714 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800046ea:	1b 8b       	ld.ub	r11,sp[0x0]
800046ec:	6e 0c       	ld.w	r12,r7[0x0]
800046ee:	f0 1f 00 0b 	mcall	80004718 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800046f2:	1a 9b       	mov	r11,sp
800046f4:	6e 0c       	ld.w	r12,r7[0x0]
800046f6:	f0 1f 00 0a 	mcall	8000471c <RC522_WriteByte+0x44>
800046fa:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046fc:	30 0b       	mov	r11,0
800046fe:	6e 0c       	ld.w	r12,r7[0x0]
80004700:	f0 1f 00 08 	mcall	80004720 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004704:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004708:	2f fd       	sub	sp,-4
8000470a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000470e:	00 00       	add	r0,r0
80004710:	00 00       	add	r0,r0
80004712:	1d f8       	ld.ub	r8,lr[0x7]
80004714:	80 00       	ld.sh	r0,r0[0x0]
80004716:	5b a8       	cp.w	r8,-6
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	5a 42       	cp.w	r2,-28
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	5a 5e       	cp.w	lr,-27
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	5b 68       	cp.w	r8,-10

80004724 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004724:	eb cd 40 c0 	pushm	r6-r7,lr
80004728:	18 96       	mov	r6,r12
8000472a:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
8000472c:	31 8c       	mov	r12,24
8000472e:	f0 1f 00 09 	mcall	80004750 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004732:	ec 0c 15 01 	lsl	r12,r6,0x1
80004736:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000473a:	f0 1f 00 07 	mcall	80004754 <WriteRawRC+0x30>
	RC522_WriteByte(value);
8000473e:	0e 9c       	mov	r12,r7
80004740:	f0 1f 00 05 	mcall	80004754 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004744:	31 8c       	mov	r12,24
80004746:	f0 1f 00 05 	mcall	80004758 <WriteRawRC+0x34>

}
8000474a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000474e:	00 00       	add	r0,r0
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	58 8c       	cp.w	r12,8
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	46 d8       	lddsp	r8,sp[0x1b4]
80004758:	80 00       	ld.sh	r0,r0[0x0]
8000475a:	58 70       	cp.w	r0,7

8000475c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000475c:	d4 01       	pushm	lr

	SET_RC522RST;
8000475e:	31 9c       	mov	r12,25
80004760:	f0 1f 00 1b 	mcall	800047cc <PcdReset+0x70>
	delay_ns(10);
80004764:	30 ac       	mov	r12,10
80004766:	f0 1f 00 1b 	mcall	800047d0 <PcdReset+0x74>

	CLR_RC522RST;
8000476a:	31 9c       	mov	r12,25
8000476c:	f0 1f 00 1a 	mcall	800047d4 <PcdReset+0x78>
	delay_ns(10);
80004770:	30 ac       	mov	r12,10
80004772:	f0 1f 00 18 	mcall	800047d0 <PcdReset+0x74>

	SET_RC522RST;
80004776:	31 9c       	mov	r12,25
80004778:	f0 1f 00 15 	mcall	800047cc <PcdReset+0x70>
	delay_ns(10);
8000477c:	30 ac       	mov	r12,10
8000477e:	f0 1f 00 15 	mcall	800047d0 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004782:	30 fb       	mov	r11,15
80004784:	30 1c       	mov	r12,1
80004786:	f0 1f 00 15 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000478a:	30 fb       	mov	r11,15
8000478c:	30 1c       	mov	r12,1
8000478e:	f0 1f 00 13 	mcall	800047d8 <PcdReset+0x7c>
	delay_ns(10);
80004792:	30 ac       	mov	r12,10
80004794:	f0 1f 00 0f 	mcall	800047d0 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004798:	33 db       	mov	r11,61
8000479a:	31 1c       	mov	r12,17
8000479c:	f0 1f 00 0f 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047a0:	31 eb       	mov	r11,30
800047a2:	32 dc       	mov	r12,45
800047a4:	f0 1f 00 0d 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800047a8:	30 0b       	mov	r11,0
800047aa:	32 cc       	mov	r12,44
800047ac:	f0 1f 00 0b 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800047b0:	e0 6b 00 8d 	mov	r11,141
800047b4:	32 ac       	mov	r12,42
800047b6:	f0 1f 00 09 	mcall	800047d8 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800047ba:	33 eb       	mov	r11,62
800047bc:	32 bc       	mov	r12,43
800047be:	f0 1f 00 07 	mcall	800047d8 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800047c2:	34 0b       	mov	r11,64
800047c4:	31 5c       	mov	r12,21
800047c6:	f0 1f 00 05 	mcall	800047d8 <PcdReset+0x7c>
	
	return MI_OK;
}
800047ca:	d8 0a       	popm	pc,r12=0
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	58 70       	cp.w	r0,7
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	50 1c       	stdsp	sp[0x4],r12
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	58 8c       	cp.w	r12,8
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	47 24       	lddsp	r4,sp[0x1c8]

800047dc <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800047dc:	eb cd 40 80 	pushm	r7,lr
800047e0:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800047e2:	31 8c       	mov	r12,24
800047e4:	f0 1f 00 0a 	mcall	8000480c <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800047e8:	ee 08 15 01 	lsl	r8,r7,0x1
800047ec:	10 9c       	mov	r12,r8
800047ee:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047f2:	a7 bc       	sbr	r12,0x7
800047f4:	f0 1f 00 07 	mcall	80004810 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800047f8:	f0 1f 00 07 	mcall	80004814 <ReadRawRC+0x38>
800047fc:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800047fe:	31 8c       	mov	r12,24
80004800:	f0 1f 00 06 	mcall	80004818 <ReadRawRC+0x3c>
	return ucResult;
}
80004804:	0e 9c       	mov	r12,r7
80004806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000480a:	00 00       	add	r0,r0
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	58 8c       	cp.w	r12,8
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	46 d8       	lddsp	r8,sp[0x1b4]
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	46 94       	lddsp	r4,sp[0x1a4]
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	58 70       	cp.w	r0,7

8000481c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000481c:	eb cd 40 c0 	pushm	r6-r7,lr
80004820:	18 97       	mov	r7,r12
80004822:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004824:	f0 1f 00 05 	mcall	80004838 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004828:	f9 e6 10 0b 	or	r11,r12,r6
8000482c:	5c 5b       	castu.b	r11
8000482e:	0e 9c       	mov	r12,r7
80004830:	f0 1f 00 03 	mcall	8000483c <SetBitMask+0x20>
}
80004834:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	47 dc       	lddsp	r12,sp[0x1f4]
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	47 24       	lddsp	r4,sp[0x1c8]

80004840 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004840:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004842:	31 4c       	mov	r12,20
80004844:	f0 1f 00 05 	mcall	80004858 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004848:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000484c:	c0 51       	brne	80004856 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000484e:	30 3b       	mov	r11,3
80004850:	31 4c       	mov	r12,20
80004852:	f0 1f 00 03 	mcall	8000485c <PcdAntennaOn+0x1c>
80004856:	d8 02       	popm	pc
80004858:	80 00       	ld.sh	r0,r0[0x0]
8000485a:	47 dc       	lddsp	r12,sp[0x1f4]
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	48 1c       	lddpc	r12,80004860 <ClearBitMask>

80004860 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004860:	eb cd 40 c0 	pushm	r6-r7,lr
80004864:	18 97       	mov	r7,r12
80004866:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004868:	f0 1f 00 06 	mcall	80004880 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
8000486c:	5c d6       	com	r6
8000486e:	f9 e6 00 06 	and	r6,r12,r6
80004872:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004876:	0e 9c       	mov	r12,r7
80004878:	f0 1f 00 03 	mcall	80004884 <ClearBitMask+0x24>
	
}
8000487c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	47 dc       	lddsp	r12,sp[0x1f4]
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	47 24       	lddsp	r4,sp[0x1c8]

80004888 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004888:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000488a:	30 3b       	mov	r11,3
8000488c:	31 4c       	mov	r12,20
8000488e:	f0 1f 00 02 	mcall	80004894 <PcdAntennaOff+0xc>
}
80004892:	d8 02       	popm	pc
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	48 60       	lddpc	r0,800048ac <M500PcdConfigISOType+0x14>

80004898 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004898:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000489a:	34 18       	mov	r8,65
8000489c:	f0 0c 18 00 	cp.b	r12,r8
800048a0:	c0 20       	breq	800048a4 <M500PcdConfigISOType+0xc>
800048a2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048a4:	30 8b       	mov	r11,8
800048a6:	16 9c       	mov	r12,r11
800048a8:	f0 1f 00 14 	mcall	800048f8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800048ac:	33 db       	mov	r11,61
800048ae:	31 1c       	mov	r12,17
800048b0:	f0 1f 00 13 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800048b4:	e0 6b 00 86 	mov	r11,134
800048b8:	31 7c       	mov	r12,23
800048ba:	f0 1f 00 11 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800048be:	37 fb       	mov	r11,127
800048c0:	32 6c       	mov	r12,38
800048c2:	f0 1f 00 0f 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800048c6:	31 eb       	mov	r11,30
800048c8:	32 dc       	mov	r12,45
800048ca:	f0 1f 00 0d 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800048ce:	30 0b       	mov	r11,0
800048d0:	32 cc       	mov	r12,44
800048d2:	f0 1f 00 0b 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800048d6:	e0 6b 00 8d 	mov	r11,141
800048da:	32 ac       	mov	r12,42
800048dc:	f0 1f 00 08 	mcall	800048fc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800048e0:	33 eb       	mov	r11,62
800048e2:	32 bc       	mov	r12,43
800048e4:	f0 1f 00 06 	mcall	800048fc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800048e8:	e0 6c 03 e8 	mov	r12,1000
800048ec:	f0 1f 00 05 	mcall	80004900 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800048f0:	f0 1f 00 05 	mcall	80004904 <M500PcdConfigISOType+0x6c>
800048f4:	d8 0a       	popm	pc,r12=0
800048f6:	00 00       	add	r0,r0
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	48 60       	lddpc	r0,80004910 <rc522_init+0x8>
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	47 24       	lddsp	r4,sp[0x1c8]
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	50 1c       	stdsp	sp[0x4],r12
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	48 40       	lddpc	r0,80004914 <rc522_init+0xc>

80004908 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004908:	eb cd 40 c0 	pushm	r6-r7,lr
8000490c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000490e:	4a 28       	lddpc	r8,80004994 <rc522_init+0x8c>
80004910:	1a 96       	mov	r6,sp
80004912:	f0 ea 00 00 	ld.d	r10,r8[0]
80004916:	fa eb 00 00 	st.d	sp[0],r10
8000491a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000491e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004922:	30 4b       	mov	r11,4
80004924:	49 dc       	lddpc	r12,80004998 <rc522_init+0x90>
80004926:	f0 1f 00 1e 	mcall	8000499c <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000492a:	31 9c       	mov	r12,25
8000492c:	f0 1f 00 1d 	mcall	800049a0 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004930:	31 9c       	mov	r12,25
80004932:	f0 1f 00 1d 	mcall	800049a4 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004936:	49 d7       	lddpc	r7,800049a8 <rc522_init+0xa0>
80004938:	fe 7c 24 00 	mov	r12,-56320
8000493c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000493e:	1a 9b       	mov	r11,sp
80004940:	f0 1f 00 1b 	mcall	800049ac <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004944:	30 09       	mov	r9,0
80004946:	12 9a       	mov	r10,r9
80004948:	12 9b       	mov	r11,r9
8000494a:	6e 0c       	ld.w	r12,r7[0x0]
8000494c:	f0 1f 00 19 	mcall	800049b0 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004950:	6e 0c       	ld.w	r12,r7[0x0]
80004952:	f0 1f 00 19 	mcall	800049b4 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004956:	e0 6a 36 00 	mov	r10,13824
8000495a:	ea 1a 01 6e 	orh	r10,0x16e
8000495e:	1a 9b       	mov	r11,sp
80004960:	6e 0c       	ld.w	r12,r7[0x0]
80004962:	f0 1f 00 16 	mcall	800049b8 <rc522_init+0xb0>
80004966:	c0 50       	breq	80004970 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004968:	30 29       	mov	r9,2
8000496a:	49 58       	lddpc	r8,800049bc <rc522_init+0xb4>
8000496c:	b0 89       	st.b	r8[0x0],r9
8000496e:	c0 38       	rjmp	80004974 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004970:	f0 1f 00 14 	mcall	800049c0 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004974:	f0 1f 00 14 	mcall	800049c4 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004978:	f0 1f 00 14 	mcall	800049c8 <rc522_init+0xc0>
	
	delay_ms(2); 
8000497c:	30 2c       	mov	r12,2
8000497e:	f0 1f 00 14 	mcall	800049cc <rc522_init+0xc4>
	
	PcdAntennaOn();
80004982:	f0 1f 00 14 	mcall	800049d0 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004986:	34 1c       	mov	r12,65
80004988:	f0 1f 00 13 	mcall	800049d4 <rc522_init+0xcc>
	

8000498c:	2f cd       	sub	sp,-16
8000498e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004992:	00 00       	add	r0,r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	d9 74       	*unknown*
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	d9 4c       	*unknown*
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	58 28       	cp.w	r8,2
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	58 58       	cp.w	r8,5
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	58 70       	cp.w	r0,7
800049a8:	00 00       	add	r0,r0
800049aa:	1d f8       	ld.ub	r8,lr[0x7]
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	59 d8       	cp.w	r8,29
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	5a 10       	cp.w	r0,-31
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	5a 3c       	cp.w	r12,-29
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	5a 80       	cp.w	r0,-24
800049bc:	00 00       	add	r0,r0
800049be:	0b 68       	ld.uh	r8,--r5
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	46 84       	lddsp	r4,sp[0x1a0]
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	47 5c       	lddsp	r12,sp[0x1d4]
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	48 88       	lddpc	r8,800049e8 <PcdComMF522+0x10>
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	50 5c       	stdsp	sp[0x14],r12
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	48 40       	lddpc	r0,800049e0 <PcdComMF522+0x8>
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 98       	lddpc	r8,800049f8 <PcdComMF522+0x20>

800049d8 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
800049d8:	d4 31       	pushm	r0-r7,lr
800049da:	20 1d       	sub	sp,4
800049dc:	18 92       	mov	r2,r12
800049de:	16 95       	mov	r5,r11
800049e0:	14 96       	mov	r6,r10
800049e2:	50 09       	stdsp	sp[0x0],r9
800049e4:	10 90       	mov	r0,r8
800049e6:	f8 c8 00 0c 	sub	r8,r12,12
800049ea:	5c 58       	castu.b	r8
800049ec:	30 29       	mov	r9,2
800049ee:	f2 08 18 00 	cp.b	r8,r9
800049f2:	e0 88 00 05 	brls	800049fc <PcdComMF522+0x24>
800049f6:	30 03       	mov	r3,0
800049f8:	06 91       	mov	r1,r3
800049fa:	c0 78       	rjmp	80004a08 <PcdComMF522+0x30>
800049fc:	4c f9       	lddpc	r9,80004b38 <PcdComMF522+0x160>
800049fe:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a02:	4c f9       	lddpc	r9,80004b3c <PcdComMF522+0x164>
80004a04:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a08:	02 9b       	mov	r11,r1
80004a0a:	a7 bb       	sbr	r11,0x7
80004a0c:	30 2c       	mov	r12,2
80004a0e:	f0 1f 00 4d 	mcall	80004b40 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a12:	e0 6b 00 80 	mov	r11,128
80004a16:	30 4c       	mov	r12,4
80004a18:	f0 1f 00 4b 	mcall	80004b44 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a1c:	30 0b       	mov	r11,0
80004a1e:	30 1c       	mov	r12,1
80004a20:	f0 1f 00 48 	mcall	80004b40 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a24:	e0 6b 00 80 	mov	r11,128
80004a28:	30 ac       	mov	r12,10
80004a2a:	f0 1f 00 48 	mcall	80004b48 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a2e:	58 06       	cp.w	r6,0
80004a30:	c0 c0       	breq	80004a48 <PcdComMF522+0x70>
80004a32:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a34:	30 94       	mov	r4,9
80004a36:	0f 3b       	ld.ub	r11,r7++
80004a38:	08 9c       	mov	r12,r4
80004a3a:	f0 1f 00 42 	mcall	80004b40 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a3e:	0e 98       	mov	r8,r7
80004a40:	0a 18       	sub	r8,r5
80004a42:	ec 08 19 00 	cp.h	r8,r6
80004a46:	cf 83       	brcs	80004a36 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004a48:	04 9b       	mov	r11,r2
80004a4a:	30 1c       	mov	r12,1
80004a4c:	f0 1f 00 3d 	mcall	80004b40 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004a50:	30 c8       	mov	r8,12
80004a52:	f0 02 18 00 	cp.b	r2,r8
80004a56:	c0 61       	brne	80004a62 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004a58:	e0 6b 00 80 	mov	r11,128
80004a5c:	30 dc       	mov	r12,13
80004a5e:	f0 1f 00 3b 	mcall	80004b48 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a62:	30 4c       	mov	r12,4
80004a64:	f0 1f 00 3a 	mcall	80004b4c <PcdComMF522+0x174>
80004a68:	18 97       	mov	r7,r12
80004a6a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a6e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a70:	30 44       	mov	r4,4
80004a72:	c0 88       	rjmp	80004a82 <PcdComMF522+0xaa>
80004a74:	08 9c       	mov	r12,r4
80004a76:	f0 1f 00 36 	mcall	80004b4c <PcdComMF522+0x174>
80004a7a:	18 97       	mov	r7,r12
		i--;
80004a7c:	20 16       	sub	r6,1
80004a7e:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004a80:	c0 a0       	breq	80004a94 <PcdComMF522+0xbc>
80004a82:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004a86:	c4 c1       	brne	80004b1e <PcdComMF522+0x146>
80004a88:	ef e3 00 08 	and	r8,r7,r3
80004a8c:	ea 08 18 00 	cp.b	r8,r5
80004a90:	cf 20       	breq	80004a74 <PcdComMF522+0x9c>
80004a92:	c4 68       	rjmp	80004b1e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004a94:	e0 6b 00 80 	mov	r11,128
80004a98:	30 dc       	mov	r12,13
80004a9a:	f0 1f 00 2b 	mcall	80004b44 <PcdComMF522+0x16c>
80004a9e:	30 27       	mov	r7,2
80004aa0:	c3 38       	rjmp	80004b06 <PcdComMF522+0x12e>
80004aa2:	02 67       	and	r7,r1
80004aa4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004aa8:	30 c8       	mov	r8,12
80004aaa:	f0 02 18 00 	cp.b	r2,r8
80004aae:	c2 c1       	brne	80004b06 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ab0:	30 ac       	mov	r12,10
80004ab2:	f0 1f 00 27 	mcall	80004b4c <PcdComMF522+0x174>
80004ab6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004ab8:	30 cc       	mov	r12,12
80004aba:	f0 1f 00 25 	mcall	80004b4c <PcdComMF522+0x174>
80004abe:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004ac2:	c0 70       	breq	80004ad0 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004ac4:	08 98       	mov	r8,r4
80004ac6:	20 18       	sub	r8,1
80004ac8:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004acc:	a0 8c       	st.b	r0[0x0],r12
80004ace:	c0 48       	rjmp	80004ad6 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004ad0:	e8 08 15 03 	lsl	r8,r4,0x3
80004ad4:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004ad6:	58 04       	cp.w	r4,0
80004ad8:	c0 61       	brne	80004ae4 <PcdComMF522+0x10c>
80004ada:	30 14       	mov	r4,1
80004adc:	40 05       	lddsp	r5,sp[0x0]
80004ade:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ae0:	30 93       	mov	r3,9
80004ae2:	c0 98       	rjmp	80004af4 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ae4:	31 28       	mov	r8,18
80004ae6:	f0 04 18 00 	cp.b	r4,r8
80004aea:	f9 b4 0b 12 	movhi	r4,18
80004aee:	58 04       	cp.w	r4,0
80004af0:	cf 61       	brne	80004adc <PcdComMF522+0x104>
80004af2:	c0 a8       	rjmp	80004b06 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004af4:	06 9c       	mov	r12,r3
80004af6:	f0 1f 00 16 	mcall	80004b4c <PcdComMF522+0x174>
80004afa:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004afc:	ec 05 01 08 	sub	r8,r6,r5
80004b00:	e8 08 19 00 	cp.h	r8,r4
80004b04:	cf 83       	brcs	80004af4 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b06:	e0 6b 00 80 	mov	r11,128
80004b0a:	30 cc       	mov	r12,12
80004b0c:	f0 1f 00 0f 	mcall	80004b48 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b10:	30 0b       	mov	r11,0
80004b12:	30 1c       	mov	r12,1
80004b14:	f0 1f 00 0b 	mcall	80004b40 <PcdComMF522+0x168>
	return status;
}
80004b18:	0e 9c       	mov	r12,r7
80004b1a:	2f fd       	sub	sp,-4
80004b1c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b1e:	e0 6b 00 80 	mov	r11,128
80004b22:	30 dc       	mov	r12,13
80004b24:	f0 1f 00 08 	mcall	80004b44 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b28:	30 6c       	mov	r12,6
80004b2a:	f0 1f 00 09 	mcall	80004b4c <PcdComMF522+0x174>
80004b2e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b32:	cb 80       	breq	80004aa2 <PcdComMF522+0xca>
80004b34:	30 27       	mov	r7,2
80004b36:	ce 8b       	rjmp	80004b06 <PcdComMF522+0x12e>
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	d9 6c       	*unknown*
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	d9 70       	acall	0x97
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	47 24       	lddsp	r4,sp[0x1c8]
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	48 60       	lddpc	r0,80004b5c <PcdAnticoll+0xc>
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	48 1c       	lddpc	r12,80004b4c <PcdComMF522+0x174>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	47 dc       	lddsp	r12,sp[0x1f4]

80004b50 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004b50:	eb cd 40 c0 	pushm	r6-r7,lr
80004b54:	20 5d       	sub	sp,20
80004b56:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004b58:	30 8b       	mov	r11,8
80004b5a:	16 9c       	mov	r12,r11
80004b5c:	f0 1f 00 1a 	mcall	80004bc4 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004b60:	30 0b       	mov	r11,0
80004b62:	30 dc       	mov	r12,13
80004b64:	f0 1f 00 19 	mcall	80004bc8 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004b68:	e0 6b 00 80 	mov	r11,128
80004b6c:	30 ec       	mov	r12,14
80004b6e:	f0 1f 00 16 	mcall	80004bc4 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004b72:	39 38       	mov	r8,-109
80004b74:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004b76:	32 08       	mov	r8,32
80004b78:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004b7a:	1a 9b       	mov	r11,sp
80004b7c:	fa c8 ff ed 	sub	r8,sp,-19
80004b80:	1a 99       	mov	r9,sp
80004b82:	30 2a       	mov	r10,2
80004b84:	30 cc       	mov	r12,12
80004b86:	f0 1f 00 12 	mcall	80004bcc <PcdAnticoll+0x7c>
80004b8a:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004b8c:	c1 21       	brne	80004bb0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004b8e:	1b 89       	ld.ub	r9,sp[0x0]
80004b90:	ac 89       	st.b	r6[0x0],r9
80004b92:	1b 98       	ld.ub	r8,sp[0x1]
80004b94:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004b96:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004b98:	1b a8       	ld.ub	r8,sp[0x2]
80004b9a:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004b9c:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ba0:	1b b9       	ld.ub	r9,sp[0x3]
80004ba2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ba4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004ba6:	1b c9       	ld.ub	r9,sp[0x4]
80004ba8:	f0 09 18 00 	cp.b	r9,r8
80004bac:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004bb0:	e0 6b 00 80 	mov	r11,128
80004bb4:	30 ec       	mov	r12,14
80004bb6:	f0 1f 00 07 	mcall	80004bd0 <PcdAnticoll+0x80>
	return status;
}
80004bba:	0e 9c       	mov	r12,r7
80004bbc:	2f bd       	sub	sp,-20
80004bbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bc2:	00 00       	add	r0,r0
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	48 60       	lddpc	r0,80004bdc <PcdRequest+0x8>
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	47 24       	lddsp	r4,sp[0x1c8]
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	49 d8       	lddpc	r8,80004c40 <CalulateCRC+0x8>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	48 1c       	lddpc	r12,80004bd4 <PcdRequest>

80004bd4 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004bd4:	eb cd 40 c0 	pushm	r6-r7,lr
80004bd8:	20 5d       	sub	sp,20
80004bda:	18 97       	mov	r7,r12
80004bdc:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004bde:	30 8b       	mov	r11,8
80004be0:	16 9c       	mov	r12,r11
80004be2:	f0 1f 00 12 	mcall	80004c28 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004be6:	30 7b       	mov	r11,7
80004be8:	30 dc       	mov	r12,13
80004bea:	f0 1f 00 11 	mcall	80004c2c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004bee:	30 3b       	mov	r11,3
80004bf0:	31 4c       	mov	r12,20
80004bf2:	f0 1f 00 10 	mcall	80004c30 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004bf6:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004bf8:	1a 9b       	mov	r11,sp
80004bfa:	fa c8 ff ed 	sub	r8,sp,-19
80004bfe:	1a 99       	mov	r9,sp
80004c00:	30 1a       	mov	r10,1
80004c02:	30 cc       	mov	r12,12
80004c04:	f0 1f 00 0c 	mcall	80004c34 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c08:	c0 c1       	brne	80004c20 <PcdRequest+0x4c>
80004c0a:	31 08       	mov	r8,16
80004c0c:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c10:	f0 09 18 00 	cp.b	r9,r8
80004c14:	c0 61       	brne	80004c20 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c16:	1b 88       	ld.ub	r8,sp[0x0]
80004c18:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c1a:	1b 98       	ld.ub	r8,sp[0x1]
80004c1c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c1e:	c0 28       	rjmp	80004c22 <PcdRequest+0x4e>
80004c20:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c22:	2f bd       	sub	sp,-20
80004c24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	48 60       	lddpc	r0,80004c40 <CalulateCRC+0x8>
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	47 24       	lddsp	r4,sp[0x1c8]
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	48 1c       	lddpc	r12,80004c34 <PcdRequest+0x60>
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	49 d8       	lddpc	r8,80004ca8 <CalulateCRC+0x70>

80004c38 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c38:	eb cd 40 f8 	pushm	r3-r7,lr
80004c3c:	18 95       	mov	r5,r12
80004c3e:	16 96       	mov	r6,r11
80004c40:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c42:	30 4b       	mov	r11,4
80004c44:	30 5c       	mov	r12,5
80004c46:	f0 1f 00 1c 	mcall	80004cb4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c4a:	30 0b       	mov	r11,0
80004c4c:	30 1c       	mov	r12,1
80004c4e:	f0 1f 00 1b 	mcall	80004cb8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004c52:	e0 6b 00 80 	mov	r11,128
80004c56:	30 ac       	mov	r12,10
80004c58:	f0 1f 00 19 	mcall	80004cbc <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004c5c:	58 06       	cp.w	r6,0
80004c5e:	c0 c0       	breq	80004c76 <CalulateCRC+0x3e>
80004c60:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004c62:	30 94       	mov	r4,9
80004c64:	0f 3b       	ld.ub	r11,r7++
80004c66:	08 9c       	mov	r12,r4
80004c68:	f0 1f 00 14 	mcall	80004cb8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004c6c:	0e 98       	mov	r8,r7
80004c6e:	0a 18       	sub	r8,r5
80004c70:	ec 08 18 00 	cp.b	r8,r6
80004c74:	cf 83       	brcs	80004c64 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004c76:	30 3b       	mov	r11,3
80004c78:	30 1c       	mov	r12,1
80004c7a:	f0 1f 00 10 	mcall	80004cb8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004c7e:	30 5c       	mov	r12,5
80004c80:	f0 1f 00 10 	mcall	80004cc0 <CalulateCRC+0x88>
80004c84:	e0 67 00 fe 	mov	r7,254
80004c88:	30 56       	mov	r6,5
80004c8a:	c0 78       	rjmp	80004c98 <CalulateCRC+0x60>
80004c8c:	0c 9c       	mov	r12,r6
80004c8e:	f0 1f 00 0d 	mcall	80004cc0 <CalulateCRC+0x88>
		i--;
80004c92:	20 17       	sub	r7,1
80004c94:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004c96:	c0 40       	breq	80004c9e <CalulateCRC+0x66>
80004c98:	e2 1c 00 04 	andl	r12,0x4,COH
80004c9c:	cf 80       	breq	80004c8c <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004c9e:	32 2c       	mov	r12,34
80004ca0:	f0 1f 00 08 	mcall	80004cc0 <CalulateCRC+0x88>
80004ca4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ca6:	32 1c       	mov	r12,33
80004ca8:	f0 1f 00 06 	mcall	80004cc0 <CalulateCRC+0x88>
80004cac:	a6 9c       	st.b	r3[0x1],r12
}
80004cae:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004cb2:	00 00       	add	r0,r0
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	48 60       	lddpc	r0,80004ccc <PcdSelect+0x8>
80004cb8:	80 00       	ld.sh	r0,r0[0x0]
80004cba:	47 24       	lddsp	r4,sp[0x1c8]
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	48 1c       	lddpc	r12,80004cc0 <CalulateCRC+0x88>
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	47 dc       	lddsp	r12,sp[0x1f4]

80004cc4 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004cc4:	eb cd 40 80 	pushm	r7,lr
80004cc8:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cca:	39 38       	mov	r8,-109
80004ccc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004cce:	37 08       	mov	r8,112
80004cd0:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004cd2:	30 08       	mov	r8,0
80004cd4:	ba e8       	st.b	sp[0x6],r8
80004cd6:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004cda:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004cde:	19 89       	ld.ub	r9,r12[0x0]
80004ce0:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004ce2:	19 3a       	ld.ub	r10,r12++
80004ce4:	1b e9       	ld.ub	r9,sp[0x6]
80004ce6:	f5 e9 20 09 	eor	r9,r10,r9
80004cea:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004cec:	16 38       	cp.w	r8,r11
80004cee:	cf 81       	brne	80004cde <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004cf0:	1a 97       	mov	r7,sp
80004cf2:	fa ca ff f9 	sub	r10,sp,-7
80004cf6:	30 7b       	mov	r11,7
80004cf8:	1a 9c       	mov	r12,sp
80004cfa:	f0 1f 00 0d 	mcall	80004d2c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004cfe:	30 8b       	mov	r11,8
80004d00:	16 9c       	mov	r12,r11
80004d02:	f0 1f 00 0c 	mcall	80004d30 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d06:	fa c8 ff ed 	sub	r8,sp,-19
80004d0a:	1a 99       	mov	r9,sp
80004d0c:	30 9a       	mov	r10,9
80004d0e:	1a 9b       	mov	r11,sp
80004d10:	30 cc       	mov	r12,12
80004d12:	f0 1f 00 09 	mcall	80004d34 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d16:	c0 71       	brne	80004d24 <PcdSelect+0x60>
80004d18:	31 88       	mov	r8,24
80004d1a:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d1e:	f0 09 18 00 	cp.b	r9,r8
80004d22:	c0 20       	breq	80004d26 <PcdSelect+0x62>
80004d24:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d26:	2f bd       	sub	sp,-20
80004d28:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	4c 38       	lddpc	r8,80004e38 <rfid_auto_reader+0x100>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	48 60       	lddpc	r0,80004d48 <rfid_auto_reader+0x10>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	49 d8       	lddpc	r8,80004da8 <rfid_auto_reader+0x70>

80004d38 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d38:	eb cd 40 c0 	pushm	r6-r7,lr
80004d3c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d3e:	f0 1f 00 37 	mcall	80004e18 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d42:	4b 7b       	lddpc	r11,80004e1c <rfid_auto_reader+0xe4>
80004d44:	35 2c       	mov	r12,82
80004d46:	f0 1f 00 37 	mcall	80004e20 <rfid_auto_reader+0xe8>
80004d4a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004d4c:	c6 31       	brne	80004e12 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d4e:	4b 48       	lddpc	r8,80004e1c <rfid_auto_reader+0xe4>
80004d50:	11 88       	ld.ub	r8,r8[0x0]
80004d52:	30 49       	mov	r9,4
80004d54:	f2 08 18 00 	cp.b	r8,r9
80004d58:	c0 b1       	brne	80004d6e <rfid_auto_reader+0x36>
80004d5a:	4b 19       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d5c:	13 9a       	ld.ub	r10,r9[0x1]
80004d5e:	30 09       	mov	r9,0
80004d60:	f2 0a 18 00 	cp.b	r10,r9
80004d64:	c0 51       	brne	80004d6e <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004d66:	4b 0c       	lddpc	r12,80004e24 <rfid_auto_reader+0xec>
80004d68:	f0 1f 00 30 	mcall	80004e28 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d6c:	c3 c8       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d6e:	30 29       	mov	r9,2
80004d70:	f2 08 18 00 	cp.b	r8,r9
80004d74:	c0 b1       	brne	80004d8a <rfid_auto_reader+0x52>
80004d76:	4a a9       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d78:	13 9a       	ld.ub	r10,r9[0x1]
80004d7a:	30 09       	mov	r9,0
80004d7c:	f2 0a 18 00 	cp.b	r10,r9
80004d80:	c0 51       	brne	80004d8a <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004d82:	4a bc       	lddpc	r12,80004e2c <rfid_auto_reader+0xf4>
80004d84:	f0 1f 00 29 	mcall	80004e28 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004d88:	c2 e8       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004d8a:	34 49       	mov	r9,68
80004d8c:	f2 08 18 00 	cp.b	r8,r9
80004d90:	c0 b1       	brne	80004da6 <rfid_auto_reader+0x6e>
80004d92:	4a 39       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004d94:	13 9a       	ld.ub	r10,r9[0x1]
80004d96:	30 09       	mov	r9,0
80004d98:	f2 0a 18 00 	cp.b	r10,r9
80004d9c:	c0 51       	brne	80004da6 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004d9e:	4a 5c       	lddpc	r12,80004e30 <rfid_auto_reader+0xf8>
80004da0:	f0 1f 00 22 	mcall	80004e28 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004da4:	c2 08       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004da6:	30 89       	mov	r9,8
80004da8:	f2 08 18 00 	cp.b	r8,r9
80004dac:	c0 b1       	brne	80004dc2 <rfid_auto_reader+0x8a>
80004dae:	49 c9       	lddpc	r9,80004e1c <rfid_auto_reader+0xe4>
80004db0:	13 9a       	ld.ub	r10,r9[0x1]
80004db2:	30 09       	mov	r9,0
80004db4:	f2 0a 18 00 	cp.b	r10,r9
80004db8:	c0 51       	brne	80004dc2 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004dba:	49 fc       	lddpc	r12,80004e34 <rfid_auto_reader+0xfc>
80004dbc:	f0 1f 00 1b 	mcall	80004e28 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dc0:	c1 28       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004dc2:	34 49       	mov	r9,68
80004dc4:	f2 08 18 00 	cp.b	r8,r9
80004dc8:	c0 b1       	brne	80004dde <rfid_auto_reader+0xa6>
80004dca:	49 58       	lddpc	r8,80004e1c <rfid_auto_reader+0xe4>
80004dcc:	11 99       	ld.ub	r9,r8[0x1]
80004dce:	30 38       	mov	r8,3
80004dd0:	f0 09 18 00 	cp.b	r9,r8
80004dd4:	c0 51       	brne	80004dde <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004dd6:	49 9c       	lddpc	r12,80004e38 <rfid_auto_reader+0x100>
80004dd8:	f0 1f 00 14 	mcall	80004e28 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ddc:	c0 48       	rjmp	80004de4 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004dde:	49 8c       	lddpc	r12,80004e3c <rfid_auto_reader+0x104>
80004de0:	f0 1f 00 12 	mcall	80004e28 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004de4:	49 7c       	lddpc	r12,80004e40 <rfid_auto_reader+0x108>
80004de6:	f0 1f 00 18 	mcall	80004e44 <rfid_auto_reader+0x10c>
80004dea:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004dec:	c0 60       	breq	80004df8 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004dee:	37 8b       	mov	r11,120
80004df0:	30 1c       	mov	r12,1
80004df2:	f0 1f 00 16 	mcall	80004e48 <rfid_auto_reader+0x110>
		return status;
80004df6:	c0 e8       	rjmp	80004e12 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004df8:	49 2c       	lddpc	r12,80004e40 <rfid_auto_reader+0x108>
80004dfa:	f0 1f 00 15 	mcall	80004e4c <rfid_auto_reader+0x114>
80004dfe:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004e00:	c0 91       	brne	80004e12 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e02:	30 4a       	mov	r10,4
80004e04:	48 fb       	lddpc	r11,80004e40 <rfid_auto_reader+0x108>
80004e06:	0c 9c       	mov	r12,r6
80004e08:	f0 1f 00 12 	mcall	80004e50 <rfid_auto_reader+0x118>
		log("select okay\n");
80004e0c:	49 2c       	lddpc	r12,80004e54 <rfid_auto_reader+0x11c>
80004e0e:	f0 1f 00 07 	mcall	80004e28 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004e12:	0e 9c       	mov	r12,r7
80004e14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	47 5c       	lddsp	r12,sp[0x1d4]
80004e1c:	00 00       	add	r0,r0
80004e1e:	51 80       	stdsp	sp[0x60],r0
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4b d4       	lddpc	r4,80004f14 <rfid_sendID_message+0xbc>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	d9 84       	*unknown*
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	71 2c       	ld.w	r12,r8[0x48]
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	d9 90       	acall	0x99
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	d9 9c       	*unknown*
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	d9 ac       	*unknown*
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	d9 b4       	*unknown*
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	d9 c0       	acall	0x9c
80004e40:	00 00       	add	r0,r0
80004e42:	51 84       	stdsp	sp[0x60],r4
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	4b 50       	lddpc	r0,80004f18 <rfid_sendID_message+0xc0>
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	3e 84       	mov	r4,-24
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4c c4       	lddpc	r4,80004f7c <rfid_sendID_message+0x124>
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	79 d2       	ld.w	r2,r12[0x74]
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	d9 cc       	*unknown*

80004e58 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80004e58:	eb cd 40 e0 	pushm	r5-r7,lr
80004e5c:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004e5e:	fa ca ff a4 	sub	r10,sp,-92
80004e62:	30 08       	mov	r8,0
80004e64:	30 09       	mov	r9,0
80004e66:	f4 e9 00 00 	st.d	r10[0],r8
80004e6a:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80004e6e:	fa cc ff 94 	sub	r12,sp,-108
80004e72:	f8 e9 00 00 	st.d	r12[0],r8
80004e76:	30 0a       	mov	r10,0
80004e78:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004e7a:	fa e9 00 0c 	st.d	sp[12],r8
80004e7e:	fa e9 00 14 	st.d	sp[20],r8
80004e82:	fa e9 00 1c 	st.d	sp[28],r8
80004e86:	fa e9 00 24 	st.d	sp[36],r8
80004e8a:	fa e9 00 2c 	st.d	sp[44],r8
80004e8e:	fa e9 00 34 	st.d	sp[52],r8
80004e92:	fa e9 00 3c 	st.d	sp[60],r8
80004e96:	fa e9 00 44 	st.d	sp[68],r8
80004e9a:	fa e9 00 4c 	st.d	sp[76],r8
80004e9e:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
80004ea2:	f0 1f 00 3f 	mcall	80004f9c <rfid_sendID_message+0x144>
80004ea6:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ea8:	c6 e1       	brne	80004f84 <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004eaa:	fb 38 00 6f 	ld.ub	r8,sp[111]
80004eae:	1a d8       	st.w	--sp,r8
80004eb0:	fb 38 00 72 	ld.ub	r8,sp[114]
80004eb4:	1a d8       	st.w	--sp,r8
80004eb6:	fb 38 00 75 	ld.ub	r8,sp[117]
80004eba:	1a d8       	st.w	--sp,r8
80004ebc:	fb 38 00 78 	ld.ub	r8,sp[120]
80004ec0:	1a d8       	st.w	--sp,r8
80004ec2:	4b 8c       	lddpc	r12,80004fa0 <rfid_sendID_message+0x148>
80004ec4:	f0 1f 00 38 	mcall	80004fa4 <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80004ec8:	37 7b       	mov	r11,119
80004eca:	30 1c       	mov	r12,1
80004ecc:	f0 1f 00 37 	mcall	80004fa8 <rfid_sendID_message+0x150>
80004ed0:	fa c9 ff 84 	sub	r9,sp,-124
80004ed4:	fa c8 ff 94 	sub	r8,sp,-108
80004ed8:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80004edc:	fa c5 ff 80 	sub	r5,sp,-128
80004ee0:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004ee2:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80004ee4:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004ee6:	13 8b       	ld.ub	r11,r9[0x0]
80004ee8:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004eec:	fc 0c 18 00 	cp.b	r12,lr
80004ef0:	f7 bc 08 d0 	subls	r12,-48
80004ef4:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80004ef8:	f7 bc 0b a9 	subhi	r12,-87
80004efc:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
80004f00:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f02:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80004f06:	fc 0b 18 00 	cp.b	r11,lr
80004f0a:	f7 bb 08 d0 	subls	r11,-48
80004f0e:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80004f12:	f7 bb 0b a9 	subhi	r11,-87
80004f16:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80004f1a:	b0 b6       	st.b	r8[0x3],r6
80004f1c:	2f f9       	sub	r9,-1
80004f1e:	2f c8       	sub	r8,-4
80004f20:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f22:	0a 39       	cp.w	r9,r5
80004f24:	ce 11       	brne	80004ee6 <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f26:	4a 28       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f28:	11 89       	ld.ub	r9,r8[0x0]
80004f2a:	39 f8       	mov	r8,-97
80004f2c:	f0 09 18 00 	cp.b	r9,r8
80004f30:	e0 88 00 05 	brls	80004f3a <rfid_sendID_message+0xe2>
80004f34:	38 09       	mov	r9,-128
80004f36:	49 e8       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f38:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f3a:	49 d8       	lddpc	r8,80004fac <rfid_sendID_message+0x154>
80004f3c:	11 86       	ld.ub	r6,r8[0x0]
80004f3e:	2f f6       	sub	r6,-1
80004f40:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f42:	30 5a       	mov	r10,5
80004f44:	49 bb       	lddpc	r11,80004fb0 <rfid_sendID_message+0x158>
80004f46:	fa cc ff f9 	sub	r12,sp,-7
80004f4a:	f0 1f 00 1b 	mcall	80004fb4 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f4e:	31 88       	mov	r8,24
80004f50:	ba 18       	st.h	sp[0x2],r8
80004f52:	ba e6       	st.b	sp[0x6],r6
80004f54:	fe 78 e0 00 	mov	r8,-8192
80004f58:	ba 28       	st.h	sp[0x4],r8
80004f5a:	fa c6 ff f4 	sub	r6,sp,-12
80004f5e:	30 aa       	mov	r10,10
80004f60:	fa cb ff fe 	sub	r11,sp,-2
80004f64:	0c 9c       	mov	r12,r6
80004f66:	f0 1f 00 14 	mcall	80004fb4 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80004f6a:	31 0a       	mov	r10,16
80004f6c:	fa cb ff a4 	sub	r11,sp,-92
80004f70:	fa cc ff ea 	sub	r12,sp,-22
80004f74:	f0 1f 00 10 	mcall	80004fb4 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80004f78:	30 9a       	mov	r10,9
80004f7a:	31 ab       	mov	r11,26
80004f7c:	0c 9c       	mov	r12,r6
80004f7e:	f0 1f 00 0f 	mcall	80004fb8 <rfid_sendID_message+0x160>
80004f82:	c0 88       	rjmp	80004f92 <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80004f84:	37 8b       	mov	r11,120
80004f86:	30 1c       	mov	r12,1
80004f88:	f0 1f 00 08 	mcall	80004fa8 <rfid_sendID_message+0x150>
		log("no card find...\n");
80004f8c:	48 cc       	lddpc	r12,80004fbc <rfid_sendID_message+0x164>
80004f8e:	f0 1f 00 06 	mcall	80004fa4 <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
80004f92:	0e 9c       	mov	r12,r7
80004f94:	2e 2d       	sub	sp,-120
80004f96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004f9a:	00 00       	add	r0,r0
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	4d 38       	lddpc	r8,800050e8 <xg_flashc_init+0x38>
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	d9 dc       	*unknown*
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	71 2c       	ld.w	r12,r8[0x48]
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	3e 84       	mov	r4,-24
80004fac:	00 00       	add	r0,r0
80004fae:	05 2c       	ld.uh	r12,r2++
80004fb0:	00 00       	add	r0,r0
80004fb2:	05 24       	ld.uh	r4,r2++
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	79 d2       	ld.w	r2,r12[0x74]
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	3d 4c       	mov	r12,-44
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	d9 f8       	*unknown*

80004fc0 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004fc0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004fc2:	f0 1f 00 02 	mcall	80004fc8 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80004fc6:	d8 02       	popm	pc
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	49 08       	lddpc	r8,80005008 <local_start_pll0+0x3c>

80004fcc <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004fcc:	fe 78 0c 00 	mov	r8,-62464
80004fd0:	e0 69 03 07 	mov	r9,775
80004fd4:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004fd6:	30 49       	mov	r9,4
80004fd8:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004fda:	71 59       	ld.w	r9,r8[0x54]
80004fdc:	e2 19 00 80 	andl	r9,0x80,COH
80004fe0:	cf d0       	breq	80004fda <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004fe2:	fe 78 0c 00 	mov	r8,-62464
80004fe6:	30 59       	mov	r9,5
80004fe8:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004fea:	e0 69 01 0d 	mov	r9,269
80004fee:	ea 19 10 07 	orh	r9,0x1007
80004ff2:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004ff4:	71 59       	ld.w	r9,r8[0x54]
80004ff6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004ffa:	cf d0       	breq	80004ff4 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004ffc:	fe 78 0c 00 	mov	r8,-62464
80005000:	fc 19 00 80 	movh	r9,0x80
80005004:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005006:	34 0a       	mov	r10,64
80005008:	fe 69 14 00 	mov	r9,-125952
8000500c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000500e:	30 69       	mov	r9,6
80005010:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005012:	30 19       	mov	r9,1
80005014:	fe 68 10 00 	mov	r8,-126976
80005018:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
8000501a:	5e fc       	retal	r12

8000501c <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000501c:	58 0c       	cp.w	r12,0
8000501e:	5e 0c       	reteq	r12
80005020:	30 08       	mov	r8,0
	{
		nop();
80005022:	d7 03       	nop
		nop();
80005024:	d7 03       	nop
		nop();
80005026:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005028:	2f f8       	sub	r8,-1
8000502a:	10 3c       	cp.w	r12,r8
8000502c:	fe 9b ff fb 	brhi	80005022 <delay_ns+0x6>
80005030:	5e fc       	retal	r12
80005032:	d7 03       	nop

80005034 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005034:	eb cd 40 e0 	pushm	r5-r7,lr
80005038:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000503a:	58 0c       	cp.w	r12,0
8000503c:	c0 b0       	breq	80005052 <delay_us+0x1e>
8000503e:	30 07       	mov	r7,0
		delay_ns(1000);
80005040:	e0 65 03 e8 	mov	r5,1000
80005044:	0a 9c       	mov	r12,r5
80005046:	f0 1f 00 05 	mcall	80005058 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000504a:	2f f7       	sub	r7,-1
8000504c:	0e 36       	cp.w	r6,r7
8000504e:	fe 9b ff fb 	brhi	80005044 <delay_us+0x10>
80005052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005056:	00 00       	add	r0,r0
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	50 1c       	stdsp	sp[0x4],r12

8000505c <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
8000505c:	eb cd 40 e0 	pushm	r5-r7,lr
80005060:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005062:	58 0c       	cp.w	r12,0
80005064:	c0 b0       	breq	8000507a <delay_ms+0x1e>
80005066:	30 07       	mov	r7,0
		delay_us(1000);
80005068:	e0 65 03 e8 	mov	r5,1000
8000506c:	0a 9c       	mov	r12,r5
8000506e:	f0 1f 00 05 	mcall	80005080 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005072:	2f f7       	sub	r7,-1
80005074:	0e 36       	cp.w	r6,r7
80005076:	fe 9b ff fb 	brhi	8000506c <delay_ms+0x10>
8000507a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000507e:	00 00       	add	r0,r0
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	50 34       	stdsp	sp[0xc],r4

80005084 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005084:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005086:	30 3b       	mov	r11,3
80005088:	48 8c       	lddpc	r12,800050a8 <local_start_timer+0x24>
8000508a:	f0 1f 00 09 	mcall	800050ac <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000508e:	fe 78 38 00 	mov	r8,-51200
80005092:	e0 69 91 0d 	mov	r9,37133
80005096:	ea 19 00 52 	orh	r9,0x52
8000509a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000509c:	32 09       	mov	r9,32
8000509e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050a0:	30 59       	mov	r9,5
800050a2:	91 09       	st.w	r8[0x0],r9
}
800050a4:	d8 02       	popm	pc
800050a6:	00 00       	add	r0,r0
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	da 0c       	*unknown*
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	58 28       	cp.w	r8,2

800050b0 <xg_flashc_init>:



U8 Current_total_message_counter[2] = {0};
void xg_flashc_init(void)
{
800050b0:	d4 31       	pushm	r0-r7,lr
800050b2:	20 1d       	sub	sp,4
	
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
800050b4:	30 0a       	mov	r10,0
800050b6:	30 0b       	mov	r11,0
800050b8:	fe f8 02 08 	ld.w	r8,pc[520]
800050bc:	b1 2a       	st.d	r8++,r10
800050be:	b1 2a       	st.d	r8++,r10
800050c0:	b1 2a       	st.d	r8++,r10
800050c2:	b1 2a       	st.d	r8++,r10
800050c4:	b1 2a       	st.d	r8++,r10
800050c6:	b1 2a       	st.d	r8++,r10
800050c8:	b1 2a       	st.d	r8++,r10
800050ca:	b1 2a       	st.d	r8++,r10
800050cc:	b1 2a       	st.d	r8++,r10
800050ce:	f0 eb 00 00 	st.d	r8[0],r10
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
800050d2:	4f c7       	lddpc	r7,800052c0 <xg_flashc_init+0x210>
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					memset(str, 0x00, sizeof(str));	
800050d4:	ee c6 ff f8 	sub	r6,r7,-8
800050d8:	ec c5 ff f8 	sub	r5,r6,-8
800050dc:	ea c4 ff f8 	sub	r4,r5,-8
800050e0:	e8 c3 ff f8 	sub	r3,r4,-8
800050e4:	e6 c2 ff f8 	sub	r2,r3,-8
800050e8:	e4 c1 ff f8 	sub	r1,r2,-8
800050ec:	e2 c0 ff f8 	sub	r0,r1,-8
800050f0:	e0 c9 ff f8 	sub	r9,r0,-8
800050f4:	50 09       	stdsp	sp[0x0],r9
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
800050f6:	30 19       	mov	r9,1
800050f8:	30 7a       	mov	r10,7
800050fa:	e0 6b b0 00 	mov	r11,45056
800050fe:	ea 1b 80 04 	orh	r11,0x8004
80005102:	0e 9c       	mov	r12,r7
80005104:	f0 1f 00 70 	mcall	800052c4 <xg_flashc_init+0x214>
	flashc_memcpy((void *)LABEL_ADDRESS, (void *)LABEL_ADDRESS, LABEL_LENGTH,  false);//为了获取当前页号码
80005108:	30 09       	mov	r9,0
8000510a:	30 7a       	mov	r10,7
8000510c:	e0 6b b0 00 	mov	r11,45056
80005110:	ea 1b 80 04 	orh	r11,0x8004
80005114:	16 9c       	mov	r12,r11
80005116:	f0 1f 00 6c 	mcall	800052c4 <xg_flashc_init+0x214>
	current_page_number = flashc_get_page_number();
8000511a:	f0 1f 00 6c 	mcall	800052c8 <xg_flashc_init+0x218>
8000511e:	4e c8       	lddpc	r8,800052cc <xg_flashc_init+0x21c>
80005120:	91 0c       	st.w	r8[0x0],r12
	if (flashc_is_lock_error() || flashc_is_programming_error())
80005122:	f0 1f 00 6c 	mcall	800052d0 <xg_flashc_init+0x220>
80005126:	e0 81 00 c3 	brne	800052ac <xg_flashc_init+0x1fc>
8000512a:	f0 1f 00 6b 	mcall	800052d4 <xg_flashc_init+0x224>
8000512e:	e0 81 00 bf 	brne	800052ac <xg_flashc_init+0x1fc>
	{
		return false;
	}
	else
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005132:	30 7a       	mov	r10,7
80005134:	0e 9b       	mov	r11,r7
80005136:	4e 9c       	lddpc	r12,800052d8 <xg_flashc_init+0x228>
80005138:	f0 1f 00 69 	mcall	800052dc <xg_flashc_init+0x22c>
8000513c:	c3 00       	breq	8000519c <xg_flashc_init+0xec>
			//{
				//current_page_number+=i;
				////flashc_erase_page(current_page_number, true);
			//}
			//set label
			flashc_memcpy((void *)LABEL_ADDRESS, (void *)XGFlashLabel, LABEL_LENGTH,  true);
8000513e:	30 19       	mov	r9,1
80005140:	30 7a       	mov	r10,7
80005142:	4e 6b       	lddpc	r11,800052d8 <xg_flashc_init+0x228>
80005144:	e0 6c b0 00 	mov	r12,45056
80005148:	ea 1c 80 04 	orh	r12,0x8004
8000514c:	f0 1f 00 5e 	mcall	800052c4 <xg_flashc_init+0x214>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005150:	4d cb       	lddpc	r11,800052c0 <xg_flashc_init+0x210>
80005152:	30 06       	mov	r6,0
80005154:	30 07       	mov	r7,0
80005156:	16 98       	mov	r8,r11
80005158:	b1 26       	st.d	r8++,r6
8000515a:	b1 26       	st.d	r8++,r6
8000515c:	b1 26       	st.d	r8++,r6
8000515e:	b1 26       	st.d	r8++,r6
80005160:	b1 26       	st.d	r8++,r6
80005162:	b1 26       	st.d	r8++,r6
80005164:	b1 26       	st.d	r8++,r6
80005166:	b1 26       	st.d	r8++,r6
80005168:	b1 26       	st.d	r8++,r6
8000516a:	f0 e7 00 00 	st.d	r8[0],r6
			
			flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)str, MESSAGE_NUMBERS_LENGTH,  false);
8000516e:	30 09       	mov	r9,0
80005170:	30 2a       	mov	r10,2
80005172:	e0 6c b0 07 	mov	r12,45063
80005176:	ea 1c 80 04 	orh	r12,0x8004
8000517a:	f0 1f 00 53 	mcall	800052c4 <xg_flashc_init+0x214>
			if (flashc_is_lock_error() || flashc_is_programming_error())
8000517e:	f0 1f 00 55 	mcall	800052d0 <xg_flashc_init+0x220>
80005182:	e0 81 00 95 	brne	800052ac <xg_flashc_init+0x1fc>
80005186:	f0 1f 00 54 	mcall	800052d4 <xg_flashc_init+0x224>
8000518a:	e0 81 00 91 	brne	800052ac <xg_flashc_init+0x1fc>
			{
				return false;
			}
			current_message_index = 0;
8000518e:	30 09       	mov	r9,0
80005190:	4d 48       	lddpc	r8,800052e0 <xg_flashc_init+0x230>
80005192:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005194:	4d 4c       	lddpc	r12,800052e4 <xg_flashc_init+0x234>
80005196:	f0 1f 00 55 	mcall	800052e8 <xg_flashc_init+0x238>
8000519a:	c8 28       	rjmp	8000529e <xg_flashc_init+0x1ee>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
8000519c:	1a d7       	st.w	--sp,r7
8000519e:	4d 4c       	lddpc	r12,800052ec <xg_flashc_init+0x23c>
800051a0:	f0 1f 00 52 	mcall	800052e8 <xg_flashc_init+0x238>
			//Get the current voice index		
			flashc_memcpy((void *)&current_message_index, (void *)MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH,  false);
800051a4:	30 09       	mov	r9,0
800051a6:	30 2a       	mov	r10,2
800051a8:	e0 6b b0 07 	mov	r11,45063
800051ac:	ea 1b 80 04 	orh	r11,0x8004
800051b0:	4c cc       	lddpc	r12,800052e0 <xg_flashc_init+0x230>
800051b2:	f0 1f 00 45 	mcall	800052c4 <xg_flashc_init+0x214>
			if (flashc_is_lock_error() || flashc_is_programming_error())
800051b6:	f0 1f 00 47 	mcall	800052d0 <xg_flashc_init+0x220>
800051ba:	2f fd       	sub	sp,-4
800051bc:	58 0c       	cp.w	r12,0
800051be:	c7 71       	brne	800052ac <xg_flashc_init+0x1fc>
800051c0:	f0 1f 00 45 	mcall	800052d4 <xg_flashc_init+0x224>
800051c4:	c7 41       	brne	800052ac <xg_flashc_init+0x1fc>
				return false;
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
800051c6:	4c 78       	lddpc	r8,800052e0 <xg_flashc_init+0x230>
800051c8:	90 09       	ld.sh	r9,r8[0x0]
800051ca:	30 08       	mov	r8,0
800051cc:	f0 09 19 00 	cp.h	r9,r8
800051d0:	c6 40       	breq	80005298 <xg_flashc_init+0x1e8>
					memset(str, 0x00, sizeof(str));	
800051d2:	30 08       	mov	r8,0
800051d4:	30 09       	mov	r9,0
800051d6:	ee e9 00 00 	st.d	r7[0],r8
800051da:	ec e9 00 00 	st.d	r6[0],r8
800051de:	ea e9 00 00 	st.d	r5[0],r8
800051e2:	e8 e9 00 00 	st.d	r4[0],r8
800051e6:	e6 e9 00 00 	st.d	r3[0],r8
800051ea:	e4 e9 00 00 	st.d	r2[0],r8
800051ee:	e2 e9 00 00 	st.d	r1[0],r8
800051f2:	e0 e9 00 00 	st.d	r0[0],r8
800051f6:	40 0a       	lddsp	r10,sp[0x0]
800051f8:	b5 28       	st.d	r10++,r8
800051fa:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
					flashc_memcpy((void *)str, (void *)address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
800051fe:	4b 98       	lddpc	r8,800052e0 <xg_flashc_init+0x230>
80005200:	90 8b       	ld.uh	r11,r8[0x0]
80005202:	20 1b       	sub	r11,1
80005204:	30 09       	mov	r9,0
80005206:	30 8a       	mov	r10,8
80005208:	e0 68 b0 09 	mov	r8,45065
8000520c:	ea 18 80 04 	orh	r8,0x8004
80005210:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
80005214:	0e 9c       	mov	r12,r7
80005216:	f0 1f 00 2c 	mcall	800052c4 <xg_flashc_init+0x214>
					if (flashc_is_lock_error() || flashc_is_programming_error())
8000521a:	f0 1f 00 2e 	mcall	800052d0 <xg_flashc_init+0x220>
8000521e:	c0 41       	brne	80005226 <xg_flashc_init+0x176>
80005220:	f0 1f 00 2d 	mcall	800052d4 <xg_flashc_init+0x224>
80005224:	c0 50       	breq	8000522e <xg_flashc_init+0x17e>
					{
						log("\r\n----voice storage is err!!!----\r\n");
80005226:	4b 3c       	lddpc	r12,800052f0 <xg_flashc_init+0x240>
80005228:	f0 1f 00 30 	mcall	800052e8 <xg_flashc_init+0x238>
8000522c:	c8 9b       	rjmp	8000513e <xg_flashc_init+0x8e>
						goto ERASE;
					}
					else
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
8000522e:	0f 89       	ld.ub	r9,r7[0x0]
80005230:	0f 98       	ld.ub	r8,r7[0x1]
80005232:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005236:	4a b9       	lddpc	r9,800052e0 <xg_flashc_init+0x230>
80005238:	92 09       	ld.sh	r9,r9[0x0]
8000523a:	f0 09 19 00 	cp.h	r9,r8
8000523e:	c2 91       	brne	80005290 <xg_flashc_init+0x1e0>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005240:	0f e9       	ld.ub	r9,r7[0x6]
80005242:	0f f8       	ld.ub	r8,r7[0x7]
80005244:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005248:	0f aa       	ld.ub	r10,r7[0x2]
8000524a:	0f b8       	ld.ub	r8,r7[0x3]
8000524c:	b1 68       	lsl	r8,0x10
8000524e:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005252:	0f ca       	ld.ub	r10,r7[0x4]
80005254:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005258:	0f da       	ld.ub	r10,r7[0x5]
8000525a:	f5 e8 10 08 	or	r8,r10,r8
8000525e:	f2 08 00 08 	add	r8,r9,r8
80005262:	4a 59       	lddpc	r9,800052f4 <xg_flashc_init+0x244>
80005264:	93 08       	st.w	r9[0x0],r8
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005266:	e0 69 f0 00 	mov	r9,61440
8000526a:	ea 19 80 05 	orh	r9,0x8005
8000526e:	12 38       	cp.w	r8,r9
80005270:	e0 88 00 14 	brls	80005298 <xg_flashc_init+0x1e8>
										
								log("\r\n----voice storage is full!!!----\r\n");
80005274:	4a 1c       	lddpc	r12,800052f8 <xg_flashc_init+0x248>
80005276:	f0 1f 00 1d 	mcall	800052e8 <xg_flashc_init+0x238>
								//xgflash erase
								
								flashc_memset64((void *)LABEL_ADDRESS, (void *)0x00, LABEL_LENGTH,  true);
8000527a:	30 18       	mov	r8,1
8000527c:	30 79       	mov	r9,7
8000527e:	30 0a       	mov	r10,0
80005280:	30 0b       	mov	r11,0
80005282:	e0 6c b0 00 	mov	r12,45056
80005286:	ea 1c 80 04 	orh	r12,0x8004
8000528a:	f0 1f 00 1d 	mcall	800052fc <xg_flashc_init+0x24c>
8000528e:	c3 4b       	rjmp	800050f6 <xg_flashc_init+0x46>

							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80005290:	49 8c       	lddpc	r12,800052f0 <xg_flashc_init+0x240>
80005292:	f0 1f 00 16 	mcall	800052e8 <xg_flashc_init+0x238>
80005296:	c5 4b       	rjmp	8000513e <xg_flashc_init+0x8e>
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read voice info okay!----\r\n");
80005298:	49 ac       	lddpc	r12,80005300 <xg_flashc_init+0x250>
8000529a:	f0 1f 00 14 	mcall	800052e8 <xg_flashc_init+0x238>
			}
		}
				
		memcpy(xg_message_count_ptr, &current_message_index, sizeof(current_message_index));
8000529e:	49 18       	lddpc	r8,800052e0 <xg_flashc_init+0x230>
800052a0:	90 09       	ld.sh	r9,r8[0x0]
800052a2:	49 98       	lddpc	r8,80005304 <xg_flashc_init+0x254>
800052a4:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
800052a6:	30 19       	mov	r9,1
800052a8:	49 88       	lddpc	r8,80005308 <xg_flashc_init+0x258>
800052aa:	b0 89       	st.b	r8[0x0],r9
{
	
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init(Current_total_message_counter);
	log("xgflash message counter : %d\n", (Current_total_message_counter[0]&0xFF00) + Current_total_message_counter[1]);
800052ac:	49 68       	lddpc	r8,80005304 <xg_flashc_init+0x254>
800052ae:	11 98       	ld.ub	r8,r8[0x1]
800052b0:	1a d8       	st.w	--sp,r8
800052b2:	49 7c       	lddpc	r12,8000530c <xg_flashc_init+0x25c>
800052b4:	f0 1f 00 0d 	mcall	800052e8 <xg_flashc_init+0x238>
800052b8:	2f fd       	sub	sp,-4
	//flashc_memcpy((void *)0x80021007,  &write_data, 8,  true);
	//
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
}
800052ba:	2f fd       	sub	sp,-4
800052bc:	d8 32       	popm	r0-r7,pc
800052be:	00 00       	add	r0,r0
800052c0:	00 00       	add	r0,r0
800052c2:	0b 70       	ld.ub	r0,--r5
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	56 d8       	stdsp	sp[0x1b4],r8
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	53 80       	stdsp	sp[0xe0],r0
800052cc:	00 00       	add	r0,r0
800052ce:	0b 6c       	ld.uh	r12,--r5
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	53 60       	stdsp	sp[0xd8],r0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	53 70       	stdsp	sp[0xdc],r0
800052d8:	00 00       	add	r0,r0
800052da:	05 30       	ld.ub	r0,r2++
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	79 ac       	ld.w	r12,r12[0x68]
800052e0:	00 00       	add	r0,r0
800052e2:	0b c0       	ld.ub	r0,r5[0x4]
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	da 24       	*unknown*
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	71 2c       	ld.w	r12,r8[0x48]
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	da 50       	acall	0xa5
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	da 5c       	*unknown*
800052f4:	00 00       	add	r0,r0
800052f6:	05 38       	ld.ub	r8,r2++
800052f8:	80 00       	ld.sh	r0,r0[0x0]
800052fa:	da 80       	acall	0xa8
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	54 a0       	stdsp	sp[0x128],r0
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	da a8       	*unknown*
80005304:	00 00       	add	r0,r0
80005306:	0b c4       	ld.ub	r4,r5[0x4]
80005308:	00 00       	add	r0,r0
8000530a:	0b 69       	ld.uh	r9,--r5
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	da d0       	acall	0xad

80005310 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80005310:	d4 01       	pushm	lr
80005312:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80005314:	31 0a       	mov	r10,16
80005316:	48 ab       	lddpc	r11,8000533c <flashc_get_flash_size+0x2c>
80005318:	1a 9c       	mov	r12,sp
8000531a:	f0 1f 00 0a 	mcall	80005340 <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
8000531e:	fe 68 14 00 	mov	r8,-125952
80005322:	70 28       	ld.w	r8,r8[0x8]
80005324:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
80005328:	fa c9 ff f0 	sub	r9,sp,-16
8000532c:	f2 08 00 18 	add	r8,r9,r8<<0x1
80005330:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
80005334:	ab 6c       	lsl	r12,0xa
80005336:	2f cd       	sub	sp,-16
80005338:	d8 02       	popm	pc
8000533a:	00 00       	add	r0,r0
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	da ee       	*unknown*
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	79 d2       	ld.w	r2,r12[0x74]

80005344 <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80005344:	fe 68 14 00 	mov	r8,-125952
80005348:	70 2c       	ld.w	r12,r8[0x8]
}
8000534a:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000534e:	5e fc       	retal	r12

80005350 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80005350:	d4 01       	pushm	lr
	while (!flashc_is_ready());
80005352:	f0 1f 00 03 	mcall	8000535c <flashc_default_wait_until_ready+0xc>
80005356:	cf e0       	breq	80005352 <flashc_default_wait_until_ready+0x2>
}
80005358:	d8 02       	popm	pc
8000535a:	00 00       	add	r0,r0
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	53 44       	stdsp	sp[0xd0],r4

80005360 <flashc_is_lock_error>:
//! by a function.
static unsigned int flashc_error_status = 0;


bool flashc_is_lock_error(void)
{
80005360:	48 38       	lddpc	r8,8000536c <flashc_is_lock_error+0xc>
80005362:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
}
80005364:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
80005368:	5e fc       	retal	r12
8000536a:	00 00       	add	r0,r0
8000536c:	00 00       	add	r0,r0
8000536e:	0b c8       	ld.ub	r8,r5[0x4]

80005370 <flashc_is_programming_error>:


bool flashc_is_programming_error(void)
{
80005370:	48 38       	lddpc	r8,8000537c <flashc_is_programming_error+0xc>
80005372:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_PROGE_MASK) != 0);
}
80005374:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
80005378:	5e fc       	retal	r12
8000537a:	00 00       	add	r0,r0
8000537c:	00 00       	add	r0,r0
8000537e:	0b c8       	ld.ub	r8,r5[0x4]

80005380 <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
80005380:	fe 68 14 00 	mov	r8,-125952
80005384:	70 1c       	ld.w	r12,r8[0x4]
}
80005386:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
8000538a:	5e fc       	retal	r12

8000538c <flashc_issue_command>:


void flashc_issue_command(unsigned int command, int page_number)
{
8000538c:	eb cd 40 c0 	pushm	r6-r7,lr
80005390:	18 96       	mov	r6,r12
80005392:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80005394:	48 e8       	lddpc	r8,800053cc <flashc_issue_command+0x40>
80005396:	70 08       	ld.w	r8,r8[0x0]
80005398:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000539a:	fe 68 14 00 	mov	r8,-125952
8000539e:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800053a0:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
800053a4:	58 07       	cp.w	r7,0
800053a6:	c0 35       	brlt	800053ac <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800053a8:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800053ac:	3a 59       	mov	r9,-91
800053ae:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800053b2:	fe 69 14 00 	mov	r9,-125952
800053b6:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800053b8:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800053ba:	e2 19 00 0c 	andl	r9,0xc,COH
800053be:	48 58       	lddpc	r8,800053d0 <flashc_issue_command+0x44>
800053c0:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800053c2:	48 38       	lddpc	r8,800053cc <flashc_issue_command+0x40>
800053c4:	70 08       	ld.w	r8,r8[0x0]
800053c6:	5d 18       	icall	r8
}
800053c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053cc:	00 00       	add	r0,r0
800053ce:	05 3c       	ld.ub	r12,r2++
800053d0:	00 00       	add	r0,r0
800053d2:	0b c8       	ld.ub	r8,r5[0x4]

800053d4 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
800053d4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
800053d6:	3f fb       	mov	r11,-1
800053d8:	30 3c       	mov	r12,3
800053da:	f0 1f 00 02 	mcall	800053e0 <flashc_clear_page_buffer+0xc>
}
800053de:	d8 02       	popm	pc
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	53 8c       	stdsp	sp[0xe0],r12

800053e4 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
800053e4:	fe 68 14 00 	mov	r8,-125952
800053e8:	70 2c       	ld.w	r12,r8[0x8]
}
800053ea:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
800053ee:	5e fc       	retal	r12

800053f0 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
800053f0:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
800053f2:	18 9b       	mov	r11,r12
800053f4:	30 cc       	mov	r12,12
800053f6:	f0 1f 00 03 	mcall	80005400 <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
800053fa:	f0 1f 00 03 	mcall	80005404 <flashc_quick_page_read+0x14>
}
800053fe:	d8 02       	popm	pc
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	53 8c       	stdsp	sp[0xe0],r12
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	53 e4       	stdsp	sp[0xf8],r4

80005408 <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
80005408:	eb cd 40 c0 	pushm	r6-r7,lr
8000540c:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
8000540e:	18 9b       	mov	r11,r12
80005410:	30 2c       	mov	r12,2
80005412:	f0 1f 00 09 	mcall	80005434 <flashc_erase_page+0x2c>
	if (check) {
80005416:	58 07       	cp.w	r7,0
80005418:	c0 31       	brne	8000541e <flashc_erase_page+0x16>
8000541a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
8000541e:	48 77       	lddpc	r7,80005438 <flashc_erase_page+0x30>
80005420:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
80005422:	3f fc       	mov	r12,-1
80005424:	f0 1f 00 06 	mcall	8000543c <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
80005428:	6e 08       	ld.w	r8,r7[0x0]
8000542a:	f1 e6 10 06 	or	r6,r8,r6
8000542e:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
80005430:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	53 8c       	stdsp	sp[0xe0],r12
80005438:	00 00       	add	r0,r0
8000543a:	0b c8       	ld.ub	r8,r5[0x4]
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	53 f0       	stdsp	sp[0xfc],r0

80005440 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80005440:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
80005442:	18 9b       	mov	r11,r12
80005444:	30 1c       	mov	r12,1
80005446:	f0 1f 00 02 	mcall	8000544c <flashc_write_page+0xc>
}
8000544a:	d8 02       	popm	pc
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	53 8c       	stdsp	sp[0xe0],r12

80005450 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
80005450:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80005452:	3f fb       	mov	r11,-1
80005454:	30 fc       	mov	r12,15
80005456:	f0 1f 00 03 	mcall	80005460 <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
8000545a:	f0 1f 00 03 	mcall	80005464 <flashc_quick_user_page_read+0x14>
}
8000545e:	d8 02       	popm	pc
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	53 8c       	stdsp	sp[0xe0],r12
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	53 e4       	stdsp	sp[0xf8],r4

80005468 <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
80005468:	eb cd 40 80 	pushm	r7,lr
8000546c:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
8000546e:	3f fb       	mov	r11,-1
80005470:	30 ec       	mov	r12,14
80005472:	f0 1f 00 06 	mcall	80005488 <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
80005476:	58 07       	cp.w	r7,0
80005478:	c0 31       	brne	8000547e <flashc_erase_user_page+0x16>
8000547a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000547e:	f0 1f 00 04 	mcall	8000548c <flashc_erase_user_page+0x24>
}
80005482:	e3 cd 80 80 	ldm	sp++,r7,pc
80005486:	00 00       	add	r0,r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	53 8c       	stdsp	sp[0xe0],r12
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	54 50       	stdsp	sp[0x114],r0

80005490 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80005490:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
80005492:	3f fb       	mov	r11,-1
80005494:	30 dc       	mov	r12,13
80005496:	f0 1f 00 02 	mcall	8000549c <flashc_write_user_page+0xc>
}
8000549a:	d8 02       	popm	pc
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	53 8c       	stdsp	sp[0xe0],r12

800054a0 <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800054a0:	d4 31       	pushm	r0-r7,lr
800054a2:	20 cd       	sub	sp,48
800054a4:	50 6c       	stdsp	sp[0x18],r12
800054a6:	14 94       	mov	r4,r10
800054a8:	16 95       	mov	r5,r11
800054aa:	12 96       	mov	r6,r9
800054ac:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800054ae:	30 08       	mov	r8,0
800054b0:	30 09       	mov	r9,0
800054b2:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800054b6:	f0 1f 00 82 	mcall	800056bc <flashc_memset64+0x21c>
800054ba:	fc 18 80 00 	movh	r8,0x8000
800054be:	f8 08 00 08 	add	r8,r12,r8
800054c2:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
800054c4:	40 6b       	lddsp	r11,sp[0x18]
800054c6:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800054c8:	58 04       	cp.w	r4,0
800054ca:	5c 25       	cpc	r5
800054cc:	c1 80       	breq	800054fc <flashc_memset64+0x5c>
800054ce:	f6 c8 ff f9 	sub	r8,r11,-7
800054d2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800054d6:	fa c9 ff d0 	sub	r9,sp,-48
800054da:	10 09       	add	r9,r8
800054dc:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
800054e0:	e8 0c 16 08 	lsr	r12,r4,0x8
800054e4:	ea 0a 16 08 	lsr	r10,r5,0x8
800054e8:	f9 e5 11 89 	or	r9,r12,r5<<0x18
800054ec:	14 95       	mov	r5,r10
800054ee:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800054f0:	20 18       	sub	r8,1
800054f2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800054f6:	58 04       	cp.w	r4,0
800054f8:	5c 25       	cpc	r5
800054fa:	ce e1       	brne	800054d6 <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
800054fc:	f6 06 00 06 	add	r6,r11,r6
80005500:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80005502:	e0 6a ff ff 	mov	r10,65535
80005506:	ea 1a 7f ff 	orh	r10,0x7fff
8000550a:	14 3b       	cp.w	r11,r10
8000550c:	e0 8b 00 05 	brhi	80005516 <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
80005510:	fc 17 80 00 	movh	r7,0x8000
80005514:	c0 e8       	rjmp	80005530 <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80005516:	40 29       	lddsp	r9,sp[0x8]
80005518:	16 39       	cp.w	r9,r11
8000551a:	e0 8b 00 0b 	brhi	80005530 <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
8000551e:	fc 18 80 80 	movh	r8,0x8080
80005522:	e0 6a ff ff 	mov	r10,65535
80005526:	ea 1a 80 7f 	orh	r10,0x807f
8000552a:	14 3b       	cp.w	r11,r10
8000552c:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
80005530:	40 09       	lddsp	r9,sp[0x0]
80005532:	e0 68 02 00 	mov	r8,512
80005536:	ea 18 80 80 	orh	r8,0x8080
8000553a:	10 39       	cp.w	r9,r8
8000553c:	e0 88 00 04 	brls	80005544 <flashc_memset64+0xa4>
80005540:	50 08       	stdsp	sp[0x0],r8
80005542:	c0 c8       	rjmp	8000555a <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80005544:	40 0a       	lddsp	r10,sp[0x0]
80005546:	fc 19 80 80 	movh	r9,0x8080
8000554a:	12 3a       	cp.w	r10,r9
8000554c:	e0 8b 00 07 	brhi	8000555a <flashc_memset64+0xba>
80005550:	40 28       	lddsp	r8,sp[0x8]
80005552:	10 3a       	cp.w	r10,r8
80005554:	f0 0a 17 b0 	movhi	r10,r8
80005558:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
8000555a:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
8000555c:	10 9b       	mov	r11,r8
8000555e:	e0 1b ff f8 	andl	r11,0xfff8
80005562:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80005564:	fa e4 00 28 	ld.d	r4,sp[40]
80005568:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8000556a:	4d 66       	lddpc	r6,800056c0 <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
8000556c:	10 9a       	mov	r10,r8
8000556e:	e0 1a fe 00 	andl	r10,0xfe00
80005572:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005574:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80005578:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000557a:	40 08       	lddsp	r8,sp[0x0]
8000557c:	40 59       	lddsp	r9,sp[0x14]
8000557e:	12 18       	sub	r8,r9
80005580:	2f 88       	sub	r8,-8
80005582:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80005584:	c9 18       	rjmp	800056a6 <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
80005586:	f0 1f 00 50 	mcall	800056c4 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
8000558a:	6c 08       	ld.w	r8,r6[0x0]
8000558c:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
8000558e:	04 9c       	mov	r12,r2
80005590:	e0 1c fe 00 	andl	r12,0xfe00
80005594:	f8 ce fe 00 	sub	lr,r12,-512
80005598:	40 18       	lddsp	r8,sp[0x4]
8000559a:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
8000559e:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800055a2:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
800055a6:	c2 f0       	breq	80005604 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055a8:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800055aa:	18 90       	mov	r0,r12
800055ac:	04 91       	mov	r1,r2
800055ae:	e0 11 ff f8 	andl	r1,0xfff8
800055b2:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055b4:	18 31       	cp.w	r1,r12
800055b6:	e0 88 00 10 	brls	800055d6 <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800055ba:	f0 ea 00 00 	ld.d	r10,r8[0]
800055be:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800055c0:	10 39       	cp.w	r9,r8
800055c2:	fe 9b ff fc 	brhi	800055ba <flashc_memset64+0x11a>
800055c6:	e0 08 11 ff 	rsub	r8,r0,-1
800055ca:	02 08       	add	r8,r1
800055cc:	e0 18 ff f8 	andl	r8,0xfff8
800055d0:	2f 88       	sub	r8,-8
800055d2:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800055d6:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
800055da:	c1 50       	breq	80005604 <flashc_memset64+0x164>
800055dc:	30 0a       	mov	r10,0
800055de:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
800055e2:	17 8b       	ld.ub	r11,r11[0x0]
800055e4:	fa c7 ff e0 	sub	r7,sp,-32
800055e8:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
800055ec:	2f fa       	sub	r10,-1
800055ee:	04 3a       	cp.w	r10,r2
800055f0:	cf 71       	brne	800055de <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800055f2:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
800055f4:	40 1b       	lddsp	r11,sp[0x4]
800055f6:	16 39       	cp.w	r9,r11
800055f8:	c0 62       	brcc	80005604 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
800055fa:	fa e8 00 20 	ld.d	r8,sp[32]
800055fe:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
80005600:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005604:	0e 99       	mov	r9,r7
80005606:	0e 1e       	sub	lr,r7
80005608:	a3 5e       	asr	lr,0x3
8000560a:	c0 80       	breq	8000561a <flashc_memset64+0x17a>
8000560c:	0e 9a       	mov	r10,r7
8000560e:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
80005610:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005612:	20 18       	sub	r8,1
80005614:	cf e1       	brne	80005610 <flashc_memset64+0x170>
80005616:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
8000561a:	40 4a       	lddsp	r10,sp[0x10]
8000561c:	14 3c       	cp.w	r12,r10
8000561e:	c1 d3       	brcs	80005658 <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80005620:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005622:	40 59       	lddsp	r9,sp[0x14]
80005624:	58 09       	cp.w	r9,0
80005626:	c1 00       	breq	80005646 <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80005628:	10 99       	mov	r9,r8
8000562a:	fa c8 ff e0 	sub	r8,sp,-32
8000562e:	40 5b       	lddsp	r11,sp[0x14]
80005630:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
80005632:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
80005636:	13 3a       	ld.ub	r10,r9++
80005638:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000563a:	16 38       	cp.w	r8,r11
8000563c:	cf d1       	brne	80005636 <flashc_memset64+0x196>
8000563e:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80005640:	fa ea 00 20 	ld.d	r10,sp[32]
80005644:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005646:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000564a:	c0 70       	breq	80005658 <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
8000564c:	f0 ea 00 00 	ld.d	r10,r8[0]
80005650:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005652:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005656:	cf b1       	brne	8000564c <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
80005658:	0e 92       	mov	r2,r7
8000565a:	fc 1a 80 80 	movh	r10,0x8080
8000565e:	14 37       	cp.w	r7,r10
80005660:	e0 8b 00 17 	brhi	8000568e <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80005664:	40 39       	lddsp	r9,sp[0xc]
80005666:	58 09       	cp.w	r9,0
80005668:	c0 70       	breq	80005676 <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
8000566a:	30 0b       	mov	r11,0
8000566c:	3f fc       	mov	r12,-1
8000566e:	f0 1f 00 17 	mcall	800056c8 <flashc_memset64+0x228>
				error_status |= flashc_error_status;
80005672:	6c 08       	ld.w	r8,r6[0x0]
80005674:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
80005676:	3f fc       	mov	r12,-1
80005678:	f0 1f 00 15 	mcall	800056cc <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
8000567c:	6c 08       	ld.w	r8,r6[0x0]
8000567e:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80005680:	fc 18 80 80 	movh	r8,0x8080
80005684:	40 2b       	lddsp	r11,sp[0x8]
80005686:	04 3b       	cp.w	r11,r2
80005688:	f0 07 17 80 	movls	r7,r8
8000568c:	c0 d8       	rjmp	800056a6 <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
8000568e:	40 3a       	lddsp	r10,sp[0xc]
80005690:	58 0a       	cp.w	r10,0
80005692:	c0 60       	breq	8000569e <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
80005694:	30 0c       	mov	r12,0
80005696:	f0 1f 00 0f 	mcall	800056d0 <flashc_memset64+0x230>
				error_status |= flashc_error_status;
8000569a:	6c 08       	ld.w	r8,r6[0x0]
8000569c:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
8000569e:	f0 1f 00 0e 	mcall	800056d4 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
800056a2:	6c 08       	ld.w	r8,r6[0x0]
800056a4:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800056a6:	0e 92       	mov	r2,r7
800056a8:	40 09       	lddsp	r9,sp[0x0]
800056aa:	12 37       	cp.w	r7,r9
800056ac:	fe 93 ff 6d 	brlo	80005586 <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800056b0:	48 48       	lddpc	r8,800056c0 <flashc_memset64+0x220>
800056b2:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800056b4:	40 6c       	lddsp	r12,sp[0x18]
800056b6:	2f 4d       	sub	sp,-48
800056b8:	d8 32       	popm	r0-r7,pc
800056ba:	00 00       	add	r0,r0
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	53 10       	stdsp	sp[0xc4],r0
800056c0:	00 00       	add	r0,r0
800056c2:	0b c8       	ld.ub	r8,r5[0x4]
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	53 d4       	stdsp	sp[0xf4],r4
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	54 08       	stdsp	sp[0x100],r8
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	54 40       	stdsp	sp[0x110],r0
800056d0:	80 00       	ld.sh	r0,r0[0x0]
800056d2:	54 68       	stdsp	sp[0x118],r8
800056d4:	80 00       	ld.sh	r0,r0[0x0]
800056d6:	54 90       	stdsp	sp[0x124],r0

800056d8 <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
800056d8:	d4 31       	pushm	r0-r7,lr
800056da:	20 7d       	sub	sp,28
800056dc:	50 1c       	stdsp	sp[0x4],r12
800056de:	14 97       	mov	r7,r10
800056e0:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
800056e2:	e0 69 ff ff 	mov	r9,65535
800056e6:	ea 19 80 7f 	orh	r9,0x807f
800056ea:	12 3c       	cp.w	r12,r9
800056ec:	5f b8       	srhi	r8
800056ee:	50 28       	stdsp	sp[0x8],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
800056f0:	58 0a       	cp.w	r10,0
800056f2:	c0 41       	brne	800056fa <flashc_memcpy+0x22>
800056f4:	30 09       	mov	r9,0
800056f6:	50 09       	stdsp	sp[0x0],r9
800056f8:	c5 b8       	rjmp	800057ae <flashc_memcpy+0xd6>
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
800056fa:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
800056fc:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
800056fe:	0c 90       	mov	r0,r6
80005700:	e0 10 fe 00 	andl	r0,0xfe00
80005704:	30 08       	mov	r8,0
80005706:	50 08       	stdsp	sp[0x0],r8

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
80005708:	4a d1       	lddpc	r1,800057bc <flashc_memcpy+0xe4>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8000570a:	30 05       	mov	r5,0
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8000570c:	fa c3 ff ec 	sub	r3,sp,-20
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005710:	10 92       	mov	r2,r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
80005712:	f0 1f 00 2c 	mcall	800057c0 <flashc_memcpy+0xe8>
		error_status |= flashc_error_status;
80005716:	62 08       	ld.w	r8,r1[0x0]
80005718:	40 09       	lddsp	r9,sp[0x0]
8000571a:	10 49       	or	r9,r8
8000571c:	50 09       	stdsp	sp[0x0],r9
8000571e:	00 9b       	mov	r11,r0
80005720:	e0 ce fe 00 	sub	lr,r0,-512
80005724:	16 9c       	mov	r12,r11

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005726:	f6 e8 00 00 	ld.d	r8,r11[0]
8000572a:	fa e9 00 14 	st.d	sp[20],r8
8000572e:	04 98       	mov	r8,r2

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80005730:	58 07       	cp.w	r7,0
80005732:	5f 1a       	srne	r10
80005734:	f0 0b 00 09 	add	r9,r8,r11
80005738:	12 36       	cp.w	r6,r9
8000573a:	5f 09       	sreq	r9
8000573c:	f5 e9 00 09 	and	r9,r10,r9
80005740:	ea 09 18 00 	cp.b	r9,r5
80005744:	c0 60       	breq	80005750 <flashc_memcpy+0x78>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005746:	09 39       	ld.ub	r9,r4++
80005748:	e6 08 0b 09 	st.b	r3[r8],r9
					dest_add++;
8000574c:	2f f6       	sub	r6,-1
					nbytes--;
8000574e:	20 17       	sub	r7,1
80005750:	2f f8       	sub	r8,-1
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80005752:	58 88       	cp.w	r8,8
80005754:	ce e1       	brne	80005730 <flashc_memcpy+0x58>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
80005756:	fa e8 00 14 	ld.d	r8,sp[20]
8000575a:	f8 e9 00 00 	st.d	r12[0],r8
8000575e:	2f 8b       	sub	r11,-8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80005760:	1c 3b       	cp.w	r11,lr
80005762:	ce 11       	brne	80005724 <flashc_memcpy+0x4c>
80005764:	50 37       	stdsp	sp[0xc],r7
80005766:	e0 c0 fe 00 	sub	r0,r0,-512
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
8000576a:	40 48       	lddsp	r8,sp[0x10]
8000576c:	58 08       	cp.w	r8,0
8000576e:	c1 00       	breq	8000578e <flashc_memcpy+0xb6>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
80005770:	40 29       	lddsp	r9,sp[0x8]
80005772:	58 09       	cp.w	r9,0
80005774:	c0 50       	breq	8000577e <flashc_memcpy+0xa6>
80005776:	30 0c       	mov	r12,0
80005778:	f0 1f 00 13 	mcall	800057c4 <flashc_memcpy+0xec>
8000577c:	c0 58       	rjmp	80005786 <flashc_memcpy+0xae>
8000577e:	30 0b       	mov	r11,0
80005780:	3f fc       	mov	r12,-1
80005782:	f0 1f 00 12 	mcall	800057c8 <flashc_memcpy+0xf0>
			error_status |= flashc_error_status;
80005786:	62 08       	ld.w	r8,r1[0x0]
80005788:	40 09       	lddsp	r9,sp[0x0]
8000578a:	10 49       	or	r9,r8
8000578c:	50 09       	stdsp	sp[0x0],r9
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
8000578e:	40 28       	lddsp	r8,sp[0x8]
80005790:	58 08       	cp.w	r8,0
80005792:	c0 40       	breq	8000579a <flashc_memcpy+0xc2>
80005794:	f0 1f 00 0e 	mcall	800057cc <flashc_memcpy+0xf4>
80005798:	c0 48       	rjmp	800057a0 <flashc_memcpy+0xc8>
8000579a:	3f fc       	mov	r12,-1
8000579c:	f0 1f 00 0d 	mcall	800057d0 <flashc_memcpy+0xf8>
		error_status |= flashc_error_status;
800057a0:	62 08       	ld.w	r8,r1[0x0]
800057a2:	40 09       	lddsp	r9,sp[0x0]
800057a4:	10 49       	or	r9,r8
800057a6:	50 09       	stdsp	sp[0x0],r9

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
800057a8:	40 38       	lddsp	r8,sp[0xc]
800057aa:	58 08       	cp.w	r8,0
800057ac:	cb 31       	brne	80005712 <flashc_memcpy+0x3a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
800057ae:	48 48       	lddpc	r8,800057bc <flashc_memcpy+0xe4>
800057b0:	40 09       	lddsp	r9,sp[0x0]
800057b2:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
800057b4:	40 1c       	lddsp	r12,sp[0x4]
800057b6:	2f 9d       	sub	sp,-28
800057b8:	d8 32       	popm	r0-r7,pc
800057ba:	00 00       	add	r0,r0
800057bc:	00 00       	add	r0,r0
800057be:	0b c8       	ld.ub	r8,r5[0x4]
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	53 d4       	stdsp	sp[0xf4],r4
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	54 68       	stdsp	sp[0x118],r8
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	54 08       	stdsp	sp[0x100],r8
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	54 90       	stdsp	sp[0x124],r0
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	54 40       	stdsp	sp[0x110],r0

800057d4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800057d4:	f8 08 16 05 	lsr	r8,r12,0x5
800057d8:	a9 68       	lsl	r8,0x8
800057da:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800057de:	58 1b       	cp.w	r11,1
800057e0:	c0 d0       	breq	800057fa <gpio_enable_module_pin+0x26>
800057e2:	c0 63       	brcs	800057ee <gpio_enable_module_pin+0x1a>
800057e4:	58 2b       	cp.w	r11,2
800057e6:	c1 00       	breq	80005806 <gpio_enable_module_pin+0x32>
800057e8:	58 3b       	cp.w	r11,3
800057ea:	c1 40       	breq	80005812 <gpio_enable_module_pin+0x3e>
800057ec:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800057ee:	30 19       	mov	r9,1
800057f0:	f2 0c 09 49 	lsl	r9,r9,r12
800057f4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800057f6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800057f8:	c1 28       	rjmp	8000581c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800057fa:	30 19       	mov	r9,1
800057fc:	f2 0c 09 49 	lsl	r9,r9,r12
80005800:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005802:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005804:	c0 c8       	rjmp	8000581c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005806:	30 19       	mov	r9,1
80005808:	f2 0c 09 49 	lsl	r9,r9,r12
8000580c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000580e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005810:	c0 68       	rjmp	8000581c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005812:	30 19       	mov	r9,1
80005814:	f2 0c 09 49 	lsl	r9,r9,r12
80005818:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000581a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000581c:	30 19       	mov	r9,1
8000581e:	f2 0c 09 4c 	lsl	r12,r9,r12
80005822:	91 2c       	st.w	r8[0x8],r12
80005824:	5e fd       	retal	0
80005826:	d7 03       	nop

80005828 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005828:	d4 21       	pushm	r4-r7,lr
8000582a:	18 97       	mov	r7,r12
8000582c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000582e:	58 0b       	cp.w	r11,0
80005830:	c0 31       	brne	80005836 <gpio_enable_module+0xe>
80005832:	30 05       	mov	r5,0
80005834:	c0 d8       	rjmp	8000584e <gpio_enable_module+0x26>
80005836:	30 06       	mov	r6,0
80005838:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000583a:	6e 1b       	ld.w	r11,r7[0x4]
8000583c:	6e 0c       	ld.w	r12,r7[0x0]
8000583e:	f0 1f 00 06 	mcall	80005854 <gpio_enable_module+0x2c>
80005842:	18 45       	or	r5,r12
		gpiomap++;
80005844:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005846:	2f f6       	sub	r6,-1
80005848:	0c 34       	cp.w	r4,r6
8000584a:	fe 9b ff f8 	brhi	8000583a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000584e:	0a 9c       	mov	r12,r5
80005850:	d8 22       	popm	r4-r7,pc
80005852:	00 00       	add	r0,r0
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	57 d4       	stdsp	sp[0x1f4],r4

80005858 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005858:	f8 08 16 05 	lsr	r8,r12,0x5
8000585c:	a9 68       	lsl	r8,0x8
8000585e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005862:	30 19       	mov	r9,1
80005864:	f2 0c 09 4c 	lsl	r12,r9,r12
80005868:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000586c:	91 1c       	st.w	r8[0x4],r12
}
8000586e:	5e fc       	retal	r12

80005870 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005870:	f8 08 16 05 	lsr	r8,r12,0x5
80005874:	a9 68       	lsl	r8,0x8
80005876:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000587a:	30 19       	mov	r9,1
8000587c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005880:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005884:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005888:	91 1c       	st.w	r8[0x4],r12
}
8000588a:	5e fc       	retal	r12

8000588c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000588c:	f8 08 16 05 	lsr	r8,r12,0x5
80005890:	a9 68       	lsl	r8,0x8
80005892:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005896:	30 19       	mov	r9,1
80005898:	f2 0c 09 4c 	lsl	r12,r9,r12
8000589c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800058a0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800058a4:	91 1c       	st.w	r8[0x4],r12
}
800058a6:	5e fc       	retal	r12

800058a8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800058a8:	c0 08       	rjmp	800058a8 <_unhandled_interrupt>
800058aa:	d7 03       	nop

800058ac <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800058ac:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800058b0:	49 99       	lddpc	r9,80005914 <INTC_register_interrupt+0x68>
800058b2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800058b6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800058ba:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800058bc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800058c0:	58 0a       	cp.w	r10,0
800058c2:	c0 91       	brne	800058d4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800058c4:	49 59       	lddpc	r9,80005918 <INTC_register_interrupt+0x6c>
800058c6:	49 6a       	lddpc	r10,8000591c <INTC_register_interrupt+0x70>
800058c8:	12 1a       	sub	r10,r9
800058ca:	fe 79 08 00 	mov	r9,-63488
800058ce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058d2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800058d4:	58 1a       	cp.w	r10,1
800058d6:	c0 a1       	brne	800058ea <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800058d8:	49 09       	lddpc	r9,80005918 <INTC_register_interrupt+0x6c>
800058da:	49 2a       	lddpc	r10,80005920 <INTC_register_interrupt+0x74>
800058dc:	12 1a       	sub	r10,r9
800058de:	bf aa       	sbr	r10,0x1e
800058e0:	fe 79 08 00 	mov	r9,-63488
800058e4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058e8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800058ea:	58 2a       	cp.w	r10,2
800058ec:	c0 a1       	brne	80005900 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800058ee:	48 b9       	lddpc	r9,80005918 <INTC_register_interrupt+0x6c>
800058f0:	48 da       	lddpc	r10,80005924 <INTC_register_interrupt+0x78>
800058f2:	12 1a       	sub	r10,r9
800058f4:	bf ba       	sbr	r10,0x1f
800058f6:	fe 79 08 00 	mov	r9,-63488
800058fa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800058fe:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005900:	48 69       	lddpc	r9,80005918 <INTC_register_interrupt+0x6c>
80005902:	48 aa       	lddpc	r10,80005928 <INTC_register_interrupt+0x7c>
80005904:	12 1a       	sub	r10,r9
80005906:	ea 1a c0 00 	orh	r10,0xc000
8000590a:	fe 79 08 00 	mov	r9,-63488
8000590e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005912:	5e fc       	retal	r12
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	db 00       	acall	0xb0
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	d0 00       	acall	0x0
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	d1 04       	*unknown*
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	d1 12       	popm	r0-r3,r11
80005924:	80 00       	ld.sh	r0,r0[0x0]
80005926:	d1 20       	acall	0x12
80005928:	80 00       	ld.sh	r0,r0[0x0]
8000592a:	d1 2e       	*unknown*

8000592c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000592c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000592e:	49 18       	lddpc	r8,80005970 <INTC_init_interrupts+0x44>
80005930:	e3 b8 00 01 	mtsr	0x4,r8
80005934:	49 0e       	lddpc	lr,80005974 <INTC_init_interrupts+0x48>
80005936:	30 07       	mov	r7,0
80005938:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000593a:	49 0c       	lddpc	r12,80005978 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000593c:	49 05       	lddpc	r5,8000597c <INTC_init_interrupts+0x50>
8000593e:	10 15       	sub	r5,r8
80005940:	fe 76 08 00 	mov	r6,-63488
80005944:	c1 08       	rjmp	80005964 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005946:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005948:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000594a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000594c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005950:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005952:	10 3a       	cp.w	r10,r8
80005954:	fe 9b ff fc 	brhi	8000594c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005958:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000595c:	2f f7       	sub	r7,-1
8000595e:	2f 8e       	sub	lr,-8
80005960:	59 37       	cp.w	r7,19
80005962:	c0 50       	breq	8000596c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005964:	7c 08       	ld.w	r8,lr[0x0]
80005966:	58 08       	cp.w	r8,0
80005968:	ce f1       	brne	80005946 <INTC_init_interrupts+0x1a>
8000596a:	cf 7b       	rjmp	80005958 <INTC_init_interrupts+0x2c>
8000596c:	d8 22       	popm	r4-r7,pc
8000596e:	00 00       	add	r0,r0
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	d0 00       	acall	0x0
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	db 00       	acall	0xb0
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	58 a8       	cp.w	r8,10
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	d1 04       	*unknown*

80005980 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005980:	fe 78 08 00 	mov	r8,-63488
80005984:	e0 69 00 83 	mov	r9,131
80005988:	f2 0c 01 0c 	sub	r12,r9,r12
8000598c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005990:	f2 ca ff c0 	sub	r10,r9,-64
80005994:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005998:	58 08       	cp.w	r8,0
8000599a:	c0 21       	brne	8000599e <_get_interrupt_handler+0x1e>
8000599c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000599e:	f0 08 12 00 	clz	r8,r8
800059a2:	48 5a       	lddpc	r10,800059b4 <_get_interrupt_handler+0x34>
800059a4:	f4 09 00 39 	add	r9,r10,r9<<0x3
800059a8:	f0 08 11 1f 	rsub	r8,r8,31
800059ac:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800059ae:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800059b2:	5e fc       	retal	r12
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	db 00       	acall	0xb0

800059b8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800059b8:	f8 c8 00 01 	sub	r8,r12,1
800059bc:	f0 0b 00 0b 	add	r11,r8,r11
800059c0:	f6 0c 0d 0a 	divu	r10,r11,r12
800059c4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800059c6:	f4 c8 00 01 	sub	r8,r10,1
800059ca:	e0 48 00 fe 	cp.w	r8,254
800059ce:	e0 88 00 03 	brls	800059d4 <getBaudDiv+0x1c>
800059d2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800059d4:	5c 8c       	casts.h	r12
}
800059d6:	5e fc       	retal	r12

800059d8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800059d8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800059dc:	30 18       	mov	r8,1
800059de:	f0 09 18 00 	cp.b	r9,r8
800059e2:	e0 88 00 04 	brls	800059ea <spi_initMaster+0x12>
800059e6:	30 2c       	mov	r12,2
800059e8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800059ea:	e0 68 00 80 	mov	r8,128
800059ee:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800059f0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800059f2:	30 19       	mov	r9,1
800059f4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800059f8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800059fc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005a00:	30 09       	mov	r9,0
80005a02:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005a06:	30 fa       	mov	r10,15
80005a08:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005a0c:	99 18       	st.w	r12[0x4],r8
80005a0e:	5e f9       	retal	r9

80005a10 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005a10:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005a12:	30 18       	mov	r8,1
80005a14:	f0 0b 18 00 	cp.b	r11,r8
80005a18:	5f be       	srhi	lr
80005a1a:	f0 0a 18 00 	cp.b	r10,r8
80005a1e:	5f b8       	srhi	r8
80005a20:	fd e8 10 08 	or	r8,lr,r8
80005a24:	c0 30       	breq	80005a2a <spi_selectionMode+0x1a>
80005a26:	30 2c       	mov	r12,2
80005a28:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005a2a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005a2c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005a30:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005a34:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005a38:	99 18       	st.w	r12[0x4],r8
80005a3a:	d8 0a       	popm	pc,r12=0

80005a3c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005a3c:	30 18       	mov	r8,1
80005a3e:	99 08       	st.w	r12[0x0],r8
}
80005a40:	5e fc       	retal	r12

80005a42 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005a42:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005a46:	c0 58       	rjmp	80005a50 <spi_write+0xe>
		if (!timeout--) {
80005a48:	58 08       	cp.w	r8,0
80005a4a:	c0 21       	brne	80005a4e <spi_write+0xc>
80005a4c:	5e ff       	retal	1
80005a4e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005a50:	78 49       	ld.w	r9,r12[0x10]
80005a52:	e2 19 00 02 	andl	r9,0x2,COH
80005a56:	cf 90       	breq	80005a48 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005a58:	5c 7b       	castu.h	r11
80005a5a:	99 3b       	st.w	r12[0xc],r11
80005a5c:	5e fd       	retal	0

80005a5e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005a5e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005a62:	c0 58       	rjmp	80005a6c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005a64:	58 08       	cp.w	r8,0
80005a66:	c0 21       	brne	80005a6a <spi_read+0xc>
80005a68:	5e ff       	retal	1
80005a6a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005a6c:	78 49       	ld.w	r9,r12[0x10]
80005a6e:	e2 19 02 01 	andl	r9,0x201,COH
80005a72:	e0 49 02 01 	cp.w	r9,513
80005a76:	cf 71       	brne	80005a64 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005a78:	78 28       	ld.w	r8,r12[0x8]
80005a7a:	b6 08       	st.h	r11[0x0],r8
80005a7c:	5e fd       	retal	0
80005a7e:	d7 03       	nop

80005a80 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005a80:	eb cd 40 f8 	pushm	r3-r7,lr
80005a84:	18 95       	mov	r5,r12
80005a86:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005a88:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005a8c:	30 38       	mov	r8,3
80005a8e:	f0 06 18 00 	cp.b	r6,r8
80005a92:	e0 8b 00 5e 	brhi	80005b4e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005a96:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005a9a:	30 18       	mov	r8,1
80005a9c:	f0 04 18 00 	cp.b	r4,r8
80005aa0:	e0 8b 00 57 	brhi	80005b4e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005aa4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005aa8:	30 78       	mov	r8,7
80005aaa:	f0 03 18 00 	cp.b	r3,r8
80005aae:	e0 88 00 50 	brls	80005b4e <spi_setupChipReg+0xce>
80005ab2:	31 08       	mov	r8,16
80005ab4:	f0 03 18 00 	cp.b	r3,r8
80005ab8:	e0 8b 00 4b 	brhi	80005b4e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005abc:	14 9b       	mov	r11,r10
80005abe:	6e 1c       	ld.w	r12,r7[0x4]
80005ac0:	f0 1f 00 26 	mcall	80005b58 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005ac4:	c4 55       	brlt	80005b4e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005ac6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005ac8:	ec 09 16 01 	lsr	r9,r6,0x1
80005acc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005ad0:	ec 16 00 01 	eorl	r6,0x1
80005ad4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005ad8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005adc:	20 83       	sub	r3,8
80005ade:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005ae2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005ae6:	ef 39 00 09 	ld.ub	r9,r7[9]
80005aea:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005aee:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005af2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005af6:	0f 89       	ld.ub	r9,r7[0x0]
80005af8:	30 1a       	mov	r10,1
80005afa:	f4 09 18 00 	cp.b	r9,r10
80005afe:	c0 d0       	breq	80005b18 <spi_setupChipReg+0x98>
80005b00:	c0 a3       	brcs	80005b14 <spi_setupChipReg+0x94>
80005b02:	30 2a       	mov	r10,2
80005b04:	f4 09 18 00 	cp.b	r9,r10
80005b08:	c0 a0       	breq	80005b1c <spi_setupChipReg+0x9c>
80005b0a:	30 3a       	mov	r10,3
80005b0c:	f4 09 18 00 	cp.b	r9,r10
80005b10:	c1 f1       	brne	80005b4e <spi_setupChipReg+0xce>
80005b12:	c0 78       	rjmp	80005b20 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005b14:	8b c8       	st.w	r5[0x30],r8
		break;
80005b16:	c0 68       	rjmp	80005b22 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005b18:	8b d8       	st.w	r5[0x34],r8
		break;
80005b1a:	c0 48       	rjmp	80005b22 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005b1c:	8b e8       	st.w	r5[0x38],r8
		break;
80005b1e:	c0 28       	rjmp	80005b22 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005b20:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005b22:	48 f8       	lddpc	r8,80005b5c <spi_setupChipReg+0xdc>
80005b24:	70 08       	ld.w	r8,r8[0x0]
80005b26:	58 08       	cp.w	r8,0
80005b28:	c1 61       	brne	80005b54 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005b2a:	30 0b       	mov	r11,0
80005b2c:	30 1c       	mov	r12,1
80005b2e:	f0 1f 00 0d 	mcall	80005b60 <spi_setupChipReg+0xe0>
80005b32:	48 b8       	lddpc	r8,80005b5c <spi_setupChipReg+0xdc>
80005b34:	91 0c       	st.w	r8[0x0],r12
80005b36:	58 0c       	cp.w	r12,0
80005b38:	c0 a0       	breq	80005b4c <spi_setupChipReg+0xcc>
80005b3a:	30 09       	mov	r9,0
80005b3c:	12 9a       	mov	r10,r9
80005b3e:	12 9b       	mov	r11,r9
80005b40:	f0 1f 00 09 	mcall	80005b64 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005b44:	48 68       	lddpc	r8,80005b5c <spi_setupChipReg+0xdc>
80005b46:	70 08       	ld.w	r8,r8[0x0]
80005b48:	58 08       	cp.w	r8,0
80005b4a:	c0 51       	brne	80005b54 <spi_setupChipReg+0xd4>
80005b4c:	c0 08       	rjmp	80005b4c <spi_setupChipReg+0xcc>
80005b4e:	30 2c       	mov	r12,2
80005b50:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005b54:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	59 b8       	cp.w	r8,27
80005b5c:	00 00       	add	r0,r0
80005b5e:	51 88       	stdsp	sp[0x60],r8
80005b60:	80 00       	ld.sh	r0,r0[0x0]
80005b62:	66 4c       	ld.w	r12,r3[0x10]
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	65 4c       	ld.w	r12,r2[0x50]

80005b68 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005b68:	d4 01       	pushm	lr
80005b6a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b6e:	c0 58       	rjmp	80005b78 <spi_unselectChip+0x10>
		if (!timeout--) {
80005b70:	58 08       	cp.w	r8,0
80005b72:	c0 21       	brne	80005b76 <spi_unselectChip+0xe>
80005b74:	da 0a       	popm	pc,r12=1
80005b76:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b78:	78 49       	ld.w	r9,r12[0x10]
80005b7a:	e2 19 02 00 	andl	r9,0x200,COH
80005b7e:	cf 90       	breq	80005b70 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b80:	78 18       	ld.w	r8,r12[0x4]
80005b82:	ea 18 00 0f 	orh	r8,0xf
80005b86:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005b88:	fc 18 01 00 	movh	r8,0x100
80005b8c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005b8e:	30 09       	mov	r9,0
80005b90:	12 9a       	mov	r10,r9
80005b92:	12 9b       	mov	r11,r9
80005b94:	48 38       	lddpc	r8,80005ba0 <spi_unselectChip+0x38>
80005b96:	70 0c       	ld.w	r12,r8[0x0]
80005b98:	f0 1f 00 03 	mcall	80005ba4 <spi_unselectChip+0x3c>
80005b9c:	d8 0a       	popm	pc,r12=0
80005b9e:	00 00       	add	r0,r0
80005ba0:	00 00       	add	r0,r0
80005ba2:	51 88       	stdsp	sp[0x60],r8
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	65 4c       	ld.w	r12,r2[0x50]

80005ba8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005ba8:	eb cd 40 f8 	pushm	r3-r7,lr
80005bac:	18 94       	mov	r4,r12
80005bae:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005bb0:	49 a6       	lddpc	r6,80005c18 <spi_selectChip+0x70>
80005bb2:	30 07       	mov	r7,0
80005bb4:	31 45       	mov	r5,20
80005bb6:	0e 99       	mov	r9,r7
80005bb8:	0a 9a       	mov	r10,r5
80005bba:	0e 9b       	mov	r11,r7
80005bbc:	6c 0c       	ld.w	r12,r6[0x0]
80005bbe:	f0 1f 00 18 	mcall	80005c1c <spi_selectChip+0x74>
80005bc2:	cf a0       	breq	80005bb6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005bc4:	68 18       	ld.w	r8,r4[0x4]
80005bc6:	ea 18 00 0f 	orh	r8,0xf
80005bca:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005bcc:	68 18       	ld.w	r8,r4[0x4]
80005bce:	e2 18 00 04 	andl	r8,0x4,COH
80005bd2:	c1 10       	breq	80005bf4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005bd4:	30 e8       	mov	r8,14
80005bd6:	f0 03 18 00 	cp.b	r3,r8
80005bda:	e0 8b 00 1c 	brhi	80005c12 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005bde:	68 19       	ld.w	r9,r4[0x4]
80005be0:	e6 08 15 10 	lsl	r8,r3,0x10
80005be4:	ea 18 ff f0 	orh	r8,0xfff0
80005be8:	e8 18 ff ff 	orl	r8,0xffff
80005bec:	12 68       	and	r8,r9
80005bee:	89 18       	st.w	r4[0x4],r8
80005bf0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005bf4:	30 38       	mov	r8,3
80005bf6:	f0 03 18 00 	cp.b	r3,r8
80005bfa:	e0 8b 00 0c 	brhi	80005c12 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005bfe:	68 19       	ld.w	r9,r4[0x4]
80005c00:	2f 03       	sub	r3,-16
80005c02:	30 18       	mov	r8,1
80005c04:	f0 03 09 48 	lsl	r8,r8,r3
80005c08:	5c d8       	com	r8
80005c0a:	12 68       	and	r8,r9
80005c0c:	89 18       	st.w	r4[0x4],r8
80005c0e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005c12:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005c14:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005c18:	00 00       	add	r0,r0
80005c1a:	51 88       	stdsp	sp[0x60],r8
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	63 40       	ld.w	r0,r1[0x50]

80005c20 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005c20:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005c22:	f6 08 15 04 	lsl	r8,r11,0x4
80005c26:	14 38       	cp.w	r8,r10
80005c28:	f9 b8 08 10 	movls	r8,16
80005c2c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005c30:	f0 0b 02 4b 	mul	r11,r8,r11
80005c34:	f6 09 16 01 	lsr	r9,r11,0x1
80005c38:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005c3c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005c40:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005c44:	f2 cb 00 01 	sub	r11,r9,1
80005c48:	e0 4b ff fe 	cp.w	r11,65534
80005c4c:	e0 88 00 03 	brls	80005c52 <usart_set_async_baudrate+0x32>
80005c50:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005c52:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005c54:	e8 6e 00 00 	mov	lr,524288
80005c58:	59 08       	cp.w	r8,16
80005c5a:	fc 08 17 10 	movne	r8,lr
80005c5e:	f9 b8 00 00 	moveq	r8,0
80005c62:	e4 1b ff f7 	andh	r11,0xfff7
80005c66:	e0 1b fe cf 	andl	r11,0xfecf
80005c6a:	16 48       	or	r8,r11
80005c6c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005c6e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005c72:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005c76:	99 89       	st.w	r12[0x20],r9
80005c78:	d8 0a       	popm	pc,r12=0

80005c7a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005c7a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005c7c:	e2 18 00 02 	andl	r8,0x2,COH
80005c80:	c0 31       	brne	80005c86 <usart_write_char+0xc>
80005c82:	30 2c       	mov	r12,2
80005c84:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005c86:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005c8a:	99 7b       	st.w	r12[0x1c],r11
80005c8c:	5e fd       	retal	0
80005c8e:	d7 03       	nop

80005c90 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005c90:	eb cd 40 e0 	pushm	r5-r7,lr
80005c94:	18 96       	mov	r6,r12
80005c96:	16 95       	mov	r5,r11
80005c98:	e0 67 27 0f 	mov	r7,9999
80005c9c:	c0 68       	rjmp	80005ca8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005c9e:	58 07       	cp.w	r7,0
80005ca0:	c0 31       	brne	80005ca6 <usart_putchar+0x16>
80005ca2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005ca6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005ca8:	0a 9b       	mov	r11,r5
80005caa:	0c 9c       	mov	r12,r6
80005cac:	f0 1f 00 03 	mcall	80005cb8 <usart_putchar+0x28>
80005cb0:	cf 71       	brne	80005c9e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005cb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005cb6:	00 00       	add	r0,r0
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	5c 7a       	castu.h	r10

80005cbc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005cbc:	78 58       	ld.w	r8,r12[0x14]
80005cbe:	e2 18 00 e0 	andl	r8,0xe0,COH
80005cc2:	c0 30       	breq	80005cc8 <usart_read_char+0xc>
80005cc4:	30 4c       	mov	r12,4
80005cc6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005cc8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005cca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005cce:	c0 31       	brne	80005cd4 <usart_read_char+0x18>
80005cd0:	30 3c       	mov	r12,3
80005cd2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005cd4:	78 68       	ld.w	r8,r12[0x18]
80005cd6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005cda:	97 08       	st.w	r11[0x0],r8
80005cdc:	5e fd       	retal	0
80005cde:	d7 03       	nop

80005ce0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005ce0:	eb cd 40 c0 	pushm	r6-r7,lr
80005ce4:	20 1d       	sub	sp,4
80005ce6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005ce8:	1a 97       	mov	r7,sp
80005cea:	1a 9b       	mov	r11,sp
80005cec:	0c 9c       	mov	r12,r6
80005cee:	f0 1f 00 07 	mcall	80005d08 <usart_getchar+0x28>
80005cf2:	58 3c       	cp.w	r12,3
80005cf4:	cf b0       	breq	80005cea <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005cf6:	58 4c       	cp.w	r12,4
80005cf8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005cfc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005d00:	2f fd       	sub	sp,-4
80005d02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d06:	00 00       	add	r0,r0
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	5c bc       	swap.b	r12

80005d0c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005d0c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d10:	18 96       	mov	r6,r12
80005d12:	16 97       	mov	r7,r11
  while (*string != '\0')
80005d14:	17 8b       	ld.ub	r11,r11[0x0]
80005d16:	58 0b       	cp.w	r11,0
80005d18:	c0 80       	breq	80005d28 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005d1a:	2f f7       	sub	r7,-1
80005d1c:	0c 9c       	mov	r12,r6
80005d1e:	f0 1f 00 04 	mcall	80005d2c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005d22:	0f 8b       	ld.ub	r11,r7[0x0]
80005d24:	58 0b       	cp.w	r11,0
80005d26:	cf a1       	brne	80005d1a <usart_write_line+0xe>
80005d28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	5c 90       	brev	r0

80005d30 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005d30:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005d34:	e6 18 00 01 	andh	r8,0x1,COH
80005d38:	c0 71       	brne	80005d46 <usart_reset+0x16>
80005d3a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005d3c:	3f f8       	mov	r8,-1
80005d3e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005d40:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005d42:	d5 03       	csrf	0x10
80005d44:	c0 48       	rjmp	80005d4c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005d46:	3f f8       	mov	r8,-1
80005d48:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005d4a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005d4c:	30 08       	mov	r8,0
80005d4e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005d50:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005d52:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005d54:	ea 68 61 0c 	mov	r8,680204
80005d58:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005d5a:	5e fc       	retal	r12

80005d5c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005d5c:	eb cd 40 e0 	pushm	r5-r7,lr
80005d60:	18 96       	mov	r6,r12
80005d62:	16 97       	mov	r7,r11
80005d64:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005d66:	f0 1f 00 2f 	mcall	80005e20 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005d6a:	58 07       	cp.w	r7,0
80005d6c:	c5 80       	breq	80005e1c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005d6e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005d70:	30 49       	mov	r9,4
80005d72:	f2 08 18 00 	cp.b	r8,r9
80005d76:	e0 88 00 53 	brls	80005e1c <usart_init_rs232+0xc0>
80005d7a:	30 99       	mov	r9,9
80005d7c:	f2 08 18 00 	cp.b	r8,r9
80005d80:	e0 8b 00 4e 	brhi	80005e1c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005d84:	0f d9       	ld.ub	r9,r7[0x5]
80005d86:	30 78       	mov	r8,7
80005d88:	f0 09 18 00 	cp.b	r9,r8
80005d8c:	e0 8b 00 48 	brhi	80005e1c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005d90:	8e 39       	ld.sh	r9,r7[0x6]
80005d92:	e0 68 01 01 	mov	r8,257
80005d96:	f0 09 19 00 	cp.h	r9,r8
80005d9a:	e0 8b 00 41 	brhi	80005e1c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005d9e:	ef 39 00 08 	ld.ub	r9,r7[8]
80005da2:	30 38       	mov	r8,3
80005da4:	f0 09 18 00 	cp.b	r9,r8
80005da8:	e0 8b 00 3a 	brhi	80005e1c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005dac:	0a 9a       	mov	r10,r5
80005dae:	6e 0b       	ld.w	r11,r7[0x0]
80005db0:	0c 9c       	mov	r12,r6
80005db2:	f0 1f 00 1d 	mcall	80005e24 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005db6:	58 1c       	cp.w	r12,1
80005db8:	c3 20       	breq	80005e1c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005dba:	0f c8       	ld.ub	r8,r7[0x4]
80005dbc:	30 99       	mov	r9,9
80005dbe:	f2 08 18 00 	cp.b	r8,r9
80005dc2:	c0 51       	brne	80005dcc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005dc4:	6c 18       	ld.w	r8,r6[0x4]
80005dc6:	b1 b8       	sbr	r8,0x11
80005dc8:	8d 18       	st.w	r6[0x4],r8
80005dca:	c0 68       	rjmp	80005dd6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005dcc:	6c 19       	ld.w	r9,r6[0x4]
80005dce:	20 58       	sub	r8,5
80005dd0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005dd4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005dd6:	6c 19       	ld.w	r9,r6[0x4]
80005dd8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ddc:	0f d8       	ld.ub	r8,r7[0x5]
80005dde:	a9 78       	lsl	r8,0x9
80005de0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005de4:	12 48       	or	r8,r9
80005de6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005de8:	8e 38       	ld.sh	r8,r7[0x6]
80005dea:	30 29       	mov	r9,2
80005dec:	f2 08 19 00 	cp.h	r8,r9
80005df0:	e0 88 00 09 	brls	80005e02 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005df4:	6c 18       	ld.w	r8,r6[0x4]
80005df6:	ad b8       	sbr	r8,0xd
80005df8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005dfa:	8e b8       	ld.uh	r8,r7[0x6]
80005dfc:	20 28       	sub	r8,2
80005dfe:	8d a8       	st.w	r6[0x28],r8
80005e00:	c0 68       	rjmp	80005e0c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005e02:	6c 19       	ld.w	r9,r6[0x4]
80005e04:	5c 78       	castu.h	r8
80005e06:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005e0a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005e0c:	6c 18       	ld.w	r8,r6[0x4]
80005e0e:	e0 18 ff f0 	andl	r8,0xfff0
80005e12:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005e14:	35 08       	mov	r8,80
80005e16:	8d 08       	st.w	r6[0x0],r8
80005e18:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005e1c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	5d 30       	musfr	r0
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	5c 20       	cpc	r0

80005e28 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005e28:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005e2c:	fe c0 8e 2c 	sub	r0,pc,-29140

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005e30:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005e34:	d5 53       	csrf	0x15
  cp      r0, r1
80005e36:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005e38:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005e3c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005e3e:	c0 62       	brcc	80005e4a <idata_load_loop_end>
  cp      r0, r1
80005e40:	48 92       	lddpc	r2,80005e64 <udata_clear_loop_end+0x4>

80005e42 <idata_load_loop>:
  brlo    idata_load_loop
80005e42:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005e44:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005e46:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005e48:	cf d3       	brcs	80005e42 <idata_load_loop>

80005e4a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005e4a:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
80005e4e:	e0 61 51 98 	mov	r1,20888
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005e52:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005e54:	c0 62       	brcc	80005e60 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005e56:	30 02       	mov	r2,0
80005e58:	30 03       	mov	r3,0

80005e5a <udata_clear_loop>:
80005e5a:	a1 22       	st.d	r0++,r2
80005e5c:	02 30       	cp.w	r0,r1
80005e5e:	cf e3       	brcs	80005e5a <udata_clear_loop>

80005e60 <udata_clear_loop_end>:
80005e60:	fe cf e9 7c 	sub	pc,pc,-5764
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	e4 30 f8 c8 	sub	r0,391368

80005e68 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005e68:	f8 c8 ff f8 	sub	r8,r12,-8
80005e6c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005e6e:	3f f9       	mov	r9,-1
80005e70:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005e72:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005e74:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005e76:	30 08       	mov	r8,0
80005e78:	99 08       	st.w	r12[0x0],r8
}
80005e7a:	5e fc       	retal	r12

80005e7c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005e7c:	30 08       	mov	r8,0
80005e7e:	99 48       	st.w	r12[0x10],r8
}
80005e80:	5e fc       	retal	r12

80005e82 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005e82:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005e84:	70 19       	ld.w	r9,r8[0x4]
80005e86:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005e88:	78 19       	ld.w	r9,r12[0x4]
80005e8a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005e8c:	70 19       	ld.w	r9,r8[0x4]
80005e8e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005e90:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005e92:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005e94:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005e96:	78 08       	ld.w	r8,r12[0x0]
80005e98:	2f f8       	sub	r8,-1
80005e9a:	99 08       	st.w	r12[0x0],r8
}
80005e9c:	5e fc       	retal	r12

80005e9e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005e9e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005ea0:	5b fa       	cp.w	r10,-1
80005ea2:	c0 31       	brne	80005ea8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ea4:	78 48       	ld.w	r8,r12[0x10]
80005ea6:	c0 c8       	rjmp	80005ebe <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ea8:	f8 c8 ff f8 	sub	r8,r12,-8
80005eac:	70 19       	ld.w	r9,r8[0x4]
80005eae:	72 09       	ld.w	r9,r9[0x0]
80005eb0:	12 3a       	cp.w	r10,r9
80005eb2:	c0 63       	brcs	80005ebe <vListInsert+0x20>
80005eb4:	70 18       	ld.w	r8,r8[0x4]
80005eb6:	70 19       	ld.w	r9,r8[0x4]
80005eb8:	72 09       	ld.w	r9,r9[0x0]
80005eba:	12 3a       	cp.w	r10,r9
80005ebc:	cf c2       	brcc	80005eb4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005ebe:	70 19       	ld.w	r9,r8[0x4]
80005ec0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ec2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005ec4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005ec6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ec8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005eca:	78 08       	ld.w	r8,r12[0x0]
80005ecc:	2f f8       	sub	r8,-1
80005ece:	99 08       	st.w	r12[0x0],r8
}
80005ed0:	5e fc       	retal	r12

80005ed2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ed2:	78 18       	ld.w	r8,r12[0x4]
80005ed4:	78 29       	ld.w	r9,r12[0x8]
80005ed6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ed8:	78 28       	ld.w	r8,r12[0x8]
80005eda:	78 19       	ld.w	r9,r12[0x4]
80005edc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005ede:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005ee0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005ee2:	18 39       	cp.w	r9,r12
80005ee4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005ee8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005eec:	30 09       	mov	r9,0
80005eee:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005ef0:	70 09       	ld.w	r9,r8[0x0]
80005ef2:	20 19       	sub	r9,1
80005ef4:	91 09       	st.w	r8[0x0],r9
}
80005ef6:	5e fc       	retal	r12

80005ef8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005ef8:	e0 68 08 08 	mov	r8,2056
80005efc:	ea 18 08 08 	orh	r8,0x808
80005f00:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005f02:	e0 68 09 09 	mov	r8,2313
80005f06:	ea 18 09 09 	orh	r8,0x909
80005f0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005f0c:	e0 68 0a 0a 	mov	r8,2570
80005f10:	ea 18 0a 0a 	orh	r8,0xa0a
80005f14:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005f16:	e0 68 0b 0b 	mov	r8,2827
80005f1a:	ea 18 0b 0b 	orh	r8,0xb0b
80005f1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005f20:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005f22:	e0 68 be ef 	mov	r8,48879
80005f26:	ea 18 de ad 	orh	r8,0xdead
80005f2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005f2c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005f2e:	fc 18 00 40 	movh	r8,0x40
80005f32:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005f34:	e0 68 00 ff 	mov	r8,255
80005f38:	ea 18 ff 00 	orh	r8,0xff00
80005f3c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005f3e:	e0 68 01 01 	mov	r8,257
80005f42:	ea 18 01 01 	orh	r8,0x101
80005f46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005f48:	e0 68 02 02 	mov	r8,514
80005f4c:	ea 18 02 02 	orh	r8,0x202
80005f50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005f52:	e0 68 03 03 	mov	r8,771
80005f56:	ea 18 03 03 	orh	r8,0x303
80005f5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005f5c:	e0 68 04 04 	mov	r8,1028
80005f60:	ea 18 04 04 	orh	r8,0x404
80005f64:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005f66:	e0 68 05 05 	mov	r8,1285
80005f6a:	ea 18 05 05 	orh	r8,0x505
80005f6e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005f70:	e0 68 06 06 	mov	r8,1542
80005f74:	ea 18 06 06 	orh	r8,0x606
80005f78:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005f7a:	e0 68 07 07 	mov	r8,1799
80005f7e:	ea 18 07 07 	orh	r8,0x707
80005f82:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005f84:	30 08       	mov	r8,0
80005f86:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005f88:	5e fc       	retal	r12
80005f8a:	d7 03       	nop

80005f8c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005f8c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005f8e:	48 38       	lddpc	r8,80005f98 <vPortEnterCritical+0xc>
80005f90:	70 09       	ld.w	r9,r8[0x0]
80005f92:	2f f9       	sub	r9,-1
80005f94:	91 09       	st.w	r8[0x0],r9
}
80005f96:	5e fc       	retal	r12
80005f98:	00 00       	add	r0,r0
80005f9a:	05 40       	ld.w	r0,--r2

80005f9c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005f9c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005f9e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005fa0:	30 0a       	mov	r10,0
80005fa2:	14 9b       	mov	r11,r10
80005fa4:	49 2c       	lddpc	r12,80005fec <xPortStartScheduler+0x50>
80005fa6:	f0 1f 00 13 	mcall	80005ff0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005faa:	e0 68 5d c0 	mov	r8,24000
80005fae:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005fb2:	30 08       	mov	r8,0
80005fb4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005fb8:	e0 68 0d 44 	mov	r8,3396
80005fbc:	ea 18 00 00 	orh	r8,0x0
80005fc0:	70 00       	ld.w	r0,r8[0x0]
80005fc2:	60 0d       	ld.w	sp,r0[0x0]
80005fc4:	1b 00       	ld.w	r0,sp++
80005fc6:	e0 68 05 40 	mov	r8,1344
80005fca:	ea 18 00 00 	orh	r8,0x0
80005fce:	91 00       	st.w	r8[0x0],r0
80005fd0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005fd4:	2f ed       	sub	sp,-8
80005fd6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005fda:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005fde:	e3 b0 00 00 	mtsr	0x0,r0
80005fe2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005fe6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005fea:	d8 0a       	popm	pc,r12=0
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	60 b8       	ld.w	r8,r0[0x2c]
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	58 ac       	cp.w	r12,10

80005ff4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005ff4:	20 6d       	sub	sp,24
80005ff6:	eb cd 00 ff 	pushm	r0-r7
80005ffa:	fa c7 ff c0 	sub	r7,sp,-64
80005ffe:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006002:	ef 40 ff e0 	st.w	r7[-32],r0
80006006:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000600a:	ef 40 ff e4 	st.w	r7[-28],r0
8000600e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006012:	e0 68 05 40 	mov	r8,1344
80006016:	ea 18 00 00 	orh	r8,0x0
8000601a:	70 00       	ld.w	r0,r8[0x0]
8000601c:	1a d0       	st.w	--sp,r0
8000601e:	f0 1f 00 1a 	mcall	80006084 <LABEL_RET_SCALL_263+0x14>
80006022:	e0 68 0d 44 	mov	r8,3396
80006026:	ea 18 00 00 	orh	r8,0x0
8000602a:	70 00       	ld.w	r0,r8[0x0]
8000602c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000602e:	f0 1f 00 17 	mcall	80006088 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006032:	e0 68 0d 44 	mov	r8,3396
80006036:	ea 18 00 00 	orh	r8,0x0
8000603a:	70 00       	ld.w	r0,r8[0x0]
8000603c:	60 0d       	ld.w	sp,r0[0x0]
8000603e:	1b 00       	ld.w	r0,sp++
80006040:	e0 68 05 40 	mov	r8,1344
80006044:	ea 18 00 00 	orh	r8,0x0
80006048:	91 00       	st.w	r8[0x0],r0
8000604a:	fa c7 ff d8 	sub	r7,sp,-40
8000604e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006052:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006056:	e0 61 05 40 	mov	r1,1344
8000605a:	ea 11 00 00 	orh	r1,0x0
8000605e:	62 02       	ld.w	r2,r1[0x0]
80006060:	58 02       	cp.w	r2,0
80006062:	c0 70       	breq	80006070 <LABEL_RET_SCALL_263>
80006064:	e4 c2 00 01 	sub	r2,r2,1
80006068:	83 02       	st.w	r1[0x0],r2
8000606a:	58 02       	cp.w	r2,0
8000606c:	c0 21       	brne	80006070 <LABEL_RET_SCALL_263>
8000606e:	b1 c0       	cbr	r0,0x10

80006070 <LABEL_RET_SCALL_263>:
80006070:	ef 40 ff f8 	st.w	r7[-8],r0
80006074:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006078:	ef 40 ff fc 	st.w	r7[-4],r0
8000607c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006080:	2f ad       	sub	sp,-24
80006082:	d6 13       	rets
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	5f 8c       	srls	r12
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	66 d0       	ld.w	r0,r3[0x34]

8000608c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000608c:	e1 b8 00 43 	mfsr	r8,0x10c
80006090:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006094:	5e fc       	retal	r12
80006096:	d7 03       	nop

80006098 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006098:	48 78       	lddpc	r8,800060b4 <vPortExitCritical+0x1c>
8000609a:	70 08       	ld.w	r8,r8[0x0]
8000609c:	58 08       	cp.w	r8,0
8000609e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800060a0:	48 58       	lddpc	r8,800060b4 <vPortExitCritical+0x1c>
800060a2:	70 09       	ld.w	r9,r8[0x0]
800060a4:	20 19       	sub	r9,1
800060a6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800060a8:	70 08       	ld.w	r8,r8[0x0]
800060aa:	58 08       	cp.w	r8,0
800060ac:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800060ae:	d5 03       	csrf	0x10
800060b0:	5e fc       	retal	r12
800060b2:	00 00       	add	r0,r0
800060b4:	00 00       	add	r0,r0
800060b6:	05 40       	ld.w	r0,--r2

800060b8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800060b8:	eb cd 00 ff 	pushm	r0-r7
800060bc:	e0 68 05 40 	mov	r8,1344
800060c0:	ea 18 00 00 	orh	r8,0x0
800060c4:	70 00       	ld.w	r0,r8[0x0]
800060c6:	1a d0       	st.w	--sp,r0
800060c8:	7a 90       	ld.w	r0,sp[0x24]
800060ca:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800060ce:	58 10       	cp.w	r0,1
800060d0:	e0 8b 00 08 	brhi	800060e0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800060d4:	e0 68 0d 44 	mov	r8,3396
800060d8:	ea 18 00 00 	orh	r8,0x0
800060dc:	70 00       	ld.w	r0,r8[0x0]
800060de:	81 0d       	st.w	r0[0x0],sp

800060e0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800060e0:	f0 1f 00 12 	mcall	80006128 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800060e4:	f0 1f 00 12 	mcall	8000612c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800060e8:	f0 1f 00 12 	mcall	80006130 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800060ec:	f0 1f 00 12 	mcall	80006134 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800060f0:	7a 90       	ld.w	r0,sp[0x24]
800060f2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800060f6:	58 10       	cp.w	r0,1
800060f8:	e0 8b 00 0e 	brhi	80006114 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800060fc:	f0 1f 00 0c 	mcall	8000612c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006100:	f0 1f 00 0e 	mcall	80006138 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006104:	f0 1f 00 0c 	mcall	80006134 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006108:	e0 68 0d 44 	mov	r8,3396
8000610c:	ea 18 00 00 	orh	r8,0x0
80006110:	70 00       	ld.w	r0,r8[0x0]
80006112:	60 0d       	ld.w	sp,r0[0x0]

80006114 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006114:	1b 00       	ld.w	r0,sp++
80006116:	e0 68 05 40 	mov	r8,1344
8000611a:	ea 18 00 00 	orh	r8,0x0
8000611e:	91 00       	st.w	r8[0x0],r0
80006120:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006124:	d6 03       	rete
80006126:	00 00       	add	r0,r0
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	60 8c       	ld.w	r12,r0[0x20]
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	5f 8c       	srls	r12
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	68 d4       	ld.w	r4,r4[0x34]
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	60 98       	ld.w	r8,r0[0x24]
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	66 d0       	ld.w	r0,r3[0x34]

8000613c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000613c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000613e:	f0 1f 00 02 	mcall	80006144 <__malloc_lock+0x8>
}
80006142:	d8 02       	popm	pc
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	66 c0       	ld.w	r0,r3[0x30]

80006148 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006148:	d4 01       	pushm	lr
	xTaskResumeAll();
8000614a:	f0 1f 00 02 	mcall	80006150 <__malloc_unlock+0x8>
}
8000614e:	d8 02       	popm	pc
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	6a 7c       	ld.w	r12,r5[0x1c]

80006154 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006154:	d4 21       	pushm	r4-r7,lr
80006156:	16 95       	mov	r5,r11
80006158:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000615a:	58 0c       	cp.w	r12,0
8000615c:	c0 30       	breq	80006162 <_read+0xe>
8000615e:	3f f7       	mov	r7,-1
80006160:	c1 48       	rjmp	80006188 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006162:	58 0a       	cp.w	r10,0
80006164:	e0 89 00 04 	brgt	8000616c <_read+0x18>
80006168:	30 07       	mov	r7,0
8000616a:	c0 f8       	rjmp	80006188 <_read+0x34>
8000616c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000616e:	48 84       	lddpc	r4,8000618c <_read+0x38>
80006170:	68 0c       	ld.w	r12,r4[0x0]
80006172:	f0 1f 00 08 	mcall	80006190 <_read+0x3c>
    if (c < 0)
80006176:	c0 95       	brlt	80006188 <_read+0x34>
      break;

    *ptr++ = c;
80006178:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
8000617c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000617e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006182:	58 08       	cp.w	r8,0
80006184:	fe 99 ff f6 	brgt	80006170 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006188:	0e 9c       	mov	r12,r7
8000618a:	d8 22       	popm	r4-r7,pc
8000618c:	00 00       	add	r0,r0
8000618e:	51 8c       	stdsp	sp[0x60],r12
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	5c e0       	tnbz	r0

80006194 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006194:	d4 21       	pushm	r4-r7,lr
80006196:	16 95       	mov	r5,r11
80006198:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000619a:	20 1c       	sub	r12,1
8000619c:	58 2c       	cp.w	r12,2
8000619e:	e0 8b 00 12 	brhi	800061c2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800061a2:	58 0a       	cp.w	r10,0
800061a4:	c0 31       	brne	800061aa <_write+0x16>
800061a6:	30 07       	mov	r7,0
800061a8:	c0 e8       	rjmp	800061c4 <_write+0x30>
800061aa:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800061ac:	48 74       	lddpc	r4,800061c8 <_write+0x34>
800061ae:	68 0c       	ld.w	r12,r4[0x0]
800061b0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800061b4:	f0 1f 00 06 	mcall	800061cc <_write+0x38>
800061b8:	c0 55       	brlt	800061c2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800061ba:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800061bc:	0e 36       	cp.w	r6,r7
800061be:	cf 81       	brne	800061ae <_write+0x1a>
800061c0:	c0 28       	rjmp	800061c4 <_write+0x30>
800061c2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800061c4:	0e 9c       	mov	r12,r7
800061c6:	d8 22       	popm	r4-r7,pc
800061c8:	00 00       	add	r0,r0
800061ca:	51 8c       	stdsp	sp[0x60],r12
800061cc:	80 00       	ld.sh	r0,r0[0x0]
800061ce:	5c 90       	brev	r0

800061d0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800061d0:	eb cd 40 80 	pushm	r7,lr
800061d4:	18 97       	mov	r7,r12
	if( pv )
800061d6:	58 0c       	cp.w	r12,0
800061d8:	c0 80       	breq	800061e8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800061da:	f0 1f 00 05 	mcall	800061ec <vPortFree+0x1c>
		{
			free( pv );
800061de:	0e 9c       	mov	r12,r7
800061e0:	f0 1f 00 04 	mcall	800061f0 <vPortFree+0x20>
		}
		xTaskResumeAll();
800061e4:	f0 1f 00 04 	mcall	800061f4 <vPortFree+0x24>
800061e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	66 c0       	ld.w	r0,r3[0x30]
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	75 54       	ld.w	r4,r10[0x54]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	6a 7c       	ld.w	r12,r5[0x1c]

800061f8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800061f8:	eb cd 40 80 	pushm	r7,lr
800061fc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800061fe:	f0 1f 00 06 	mcall	80006214 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006202:	0e 9c       	mov	r12,r7
80006204:	f0 1f 00 05 	mcall	80006218 <pvPortMalloc+0x20>
80006208:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000620a:	f0 1f 00 05 	mcall	8000621c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000620e:	0e 9c       	mov	r12,r7
80006210:	e3 cd 80 80 	ldm	sp++,r7,pc
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	66 c0       	ld.w	r0,r3[0x30]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	75 64       	ld.w	r4,r10[0x58]
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	6a 7c       	ld.w	r12,r5[0x1c]

80006220 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006220:	d4 01       	pushm	lr
80006222:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006224:	78 09       	ld.w	r9,r12[0x0]
80006226:	58 09       	cp.w	r9,0
80006228:	c1 10       	breq	8000624a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000622a:	78 3a       	ld.w	r10,r12[0xc]
8000622c:	79 09       	ld.w	r9,r12[0x40]
8000622e:	f4 09 00 09 	add	r9,r10,r9
80006232:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006234:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006236:	14 39       	cp.w	r9,r10
80006238:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000623c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006240:	79 0a       	ld.w	r10,r12[0x40]
80006242:	78 3b       	ld.w	r11,r12[0xc]
80006244:	10 9c       	mov	r12,r8
80006246:	f0 1f 00 02 	mcall	8000624c <prvCopyDataFromQueue+0x2c>
8000624a:	d8 02       	popm	pc
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	79 d2       	ld.w	r2,r12[0x74]

80006250 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006250:	eb cd 40 c0 	pushm	r6-r7,lr
80006254:	18 97       	mov	r7,r12
80006256:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006258:	78 e8       	ld.w	r8,r12[0x38]
8000625a:	58 08       	cp.w	r8,0
8000625c:	c0 31       	brne	80006262 <xQueueReceiveFromISR+0x12>
8000625e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006262:	f0 1f 00 0e 	mcall	80006298 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006266:	6e e8       	ld.w	r8,r7[0x38]
80006268:	20 18       	sub	r8,1
8000626a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000626c:	6f 18       	ld.w	r8,r7[0x44]
8000626e:	5b f8       	cp.w	r8,-1
80006270:	c0 d1       	brne	8000628a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006272:	6e 48       	ld.w	r8,r7[0x10]
80006274:	58 08       	cp.w	r8,0
80006276:	c0 f0       	breq	80006294 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006278:	ee cc ff f0 	sub	r12,r7,-16
8000627c:	f0 1f 00 08 	mcall	8000629c <xQueueReceiveFromISR+0x4c>
80006280:	c0 a0       	breq	80006294 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006282:	30 1c       	mov	r12,1
80006284:	8d 0c       	st.w	r6[0x0],r12
80006286:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000628a:	2f f8       	sub	r8,-1
8000628c:	ef 48 00 44 	st.w	r7[68],r8
80006290:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006294:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	62 20       	ld.w	r0,r1[0x8]
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	68 58       	ld.w	r8,r4[0x14]

800062a0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800062a0:	eb cd 40 c0 	pushm	r6-r7,lr
800062a4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800062a6:	f0 1f 00 23 	mcall	80006330 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800062aa:	6f 28       	ld.w	r8,r7[0x48]
800062ac:	58 08       	cp.w	r8,0
800062ae:	e0 8a 00 18 	brle	800062de <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062b2:	6e 98       	ld.w	r8,r7[0x24]
800062b4:	58 08       	cp.w	r8,0
800062b6:	c1 40       	breq	800062de <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800062b8:	ee c6 ff dc 	sub	r6,r7,-36
800062bc:	c0 48       	rjmp	800062c4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062be:	6e 98       	ld.w	r8,r7[0x24]
800062c0:	58 08       	cp.w	r8,0
800062c2:	c0 e0       	breq	800062de <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800062c4:	0c 9c       	mov	r12,r6
800062c6:	f0 1f 00 1c 	mcall	80006334 <prvUnlockQueue+0x94>
800062ca:	c0 30       	breq	800062d0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800062cc:	f0 1f 00 1b 	mcall	80006338 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800062d0:	6f 28       	ld.w	r8,r7[0x48]
800062d2:	20 18       	sub	r8,1
800062d4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800062d8:	58 08       	cp.w	r8,0
800062da:	fe 99 ff f2 	brgt	800062be <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800062de:	3f f8       	mov	r8,-1
800062e0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800062e4:	f0 1f 00 16 	mcall	8000633c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800062e8:	f0 1f 00 12 	mcall	80006330 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800062ec:	6f 18       	ld.w	r8,r7[0x44]
800062ee:	58 08       	cp.w	r8,0
800062f0:	e0 8a 00 18 	brle	80006320 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800062f4:	6e 48       	ld.w	r8,r7[0x10]
800062f6:	58 08       	cp.w	r8,0
800062f8:	c1 40       	breq	80006320 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800062fa:	ee c6 ff f0 	sub	r6,r7,-16
800062fe:	c0 48       	rjmp	80006306 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006300:	6e 48       	ld.w	r8,r7[0x10]
80006302:	58 08       	cp.w	r8,0
80006304:	c0 e0       	breq	80006320 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006306:	0c 9c       	mov	r12,r6
80006308:	f0 1f 00 0b 	mcall	80006334 <prvUnlockQueue+0x94>
8000630c:	c0 30       	breq	80006312 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000630e:	f0 1f 00 0b 	mcall	80006338 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006312:	6f 18       	ld.w	r8,r7[0x44]
80006314:	20 18       	sub	r8,1
80006316:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000631a:	58 08       	cp.w	r8,0
8000631c:	fe 99 ff f2 	brgt	80006300 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006320:	3f f8       	mov	r8,-1
80006322:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006326:	f0 1f 00 06 	mcall	8000633c <prvUnlockQueue+0x9c>
}
8000632a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000632e:	00 00       	add	r0,r0
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	5f 8c       	srls	r12
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	68 58       	ld.w	r8,r4[0x14]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	67 64       	ld.w	r4,r3[0x58]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	60 98       	ld.w	r8,r0[0x24]

80006340 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006340:	d4 31       	pushm	r0-r7,lr
80006342:	20 5d       	sub	sp,20
80006344:	18 97       	mov	r7,r12
80006346:	50 0b       	stdsp	sp[0x0],r11
80006348:	50 2a       	stdsp	sp[0x8],r10
8000634a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000634c:	f8 c2 ff dc 	sub	r2,r12,-36
80006350:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006352:	fa c4 ff f4 	sub	r4,sp,-12
80006356:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006358:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000635a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000635e:	f0 1f 00 3e 	mcall	80006454 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006362:	6e e8       	ld.w	r8,r7[0x38]
80006364:	58 08       	cp.w	r8,0
80006366:	c2 a0       	breq	800063ba <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006368:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000636a:	40 0b       	lddsp	r11,sp[0x0]
8000636c:	0e 9c       	mov	r12,r7
8000636e:	f0 1f 00 3b 	mcall	80006458 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006372:	40 18       	lddsp	r8,sp[0x4]
80006374:	58 08       	cp.w	r8,0
80006376:	c1 51       	brne	800063a0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006378:	6e e8       	ld.w	r8,r7[0x38]
8000637a:	20 18       	sub	r8,1
8000637c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000637e:	6e 08       	ld.w	r8,r7[0x0]
80006380:	58 08       	cp.w	r8,0
80006382:	c0 41       	brne	8000638a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006384:	f0 1f 00 36 	mcall	8000645c <xQueueGenericReceive+0x11c>
80006388:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000638a:	6e 48       	ld.w	r8,r7[0x10]
8000638c:	58 08       	cp.w	r8,0
8000638e:	c1 20       	breq	800063b2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006390:	ee cc ff f0 	sub	r12,r7,-16
80006394:	f0 1f 00 33 	mcall	80006460 <xQueueGenericReceive+0x120>
80006398:	58 1c       	cp.w	r12,1
8000639a:	c0 c1       	brne	800063b2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000639c:	d7 33       	scall
8000639e:	c0 a8       	rjmp	800063b2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800063a0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063a2:	6e 98       	ld.w	r8,r7[0x24]
800063a4:	58 08       	cp.w	r8,0
800063a6:	c0 60       	breq	800063b2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800063a8:	04 9c       	mov	r12,r2
800063aa:	f0 1f 00 2e 	mcall	80006460 <xQueueGenericReceive+0x120>
800063ae:	c0 20       	breq	800063b2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800063b0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800063b2:	f0 1f 00 2d 	mcall	80006464 <xQueueGenericReceive+0x124>
800063b6:	30 1c       	mov	r12,1
				return pdPASS;
800063b8:	c4 c8       	rjmp	80006450 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063ba:	40 28       	lddsp	r8,sp[0x8]
800063bc:	58 08       	cp.w	r8,0
800063be:	c0 51       	brne	800063c8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800063c0:	f0 1f 00 29 	mcall	80006464 <xQueueGenericReceive+0x124>
800063c4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800063c6:	c4 58       	rjmp	80006450 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800063c8:	58 05       	cp.w	r5,0
800063ca:	c0 51       	brne	800063d4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063cc:	08 9c       	mov	r12,r4
800063ce:	f0 1f 00 27 	mcall	80006468 <xQueueGenericReceive+0x128>
800063d2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800063d4:	f0 1f 00 24 	mcall	80006464 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800063d8:	f0 1f 00 25 	mcall	8000646c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800063dc:	f0 1f 00 1e 	mcall	80006454 <xQueueGenericReceive+0x114>
800063e0:	6f 18       	ld.w	r8,r7[0x44]
800063e2:	5b f8       	cp.w	r8,-1
800063e4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800063e8:	6f 28       	ld.w	r8,r7[0x48]
800063ea:	5b f8       	cp.w	r8,-1
800063ec:	ef f1 0a 12 	st.weq	r7[0x48],r1
800063f0:	f0 1f 00 1d 	mcall	80006464 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063f4:	06 9b       	mov	r11,r3
800063f6:	08 9c       	mov	r12,r4
800063f8:	f0 1f 00 1e 	mcall	80006470 <xQueueGenericReceive+0x130>
800063fc:	c2 41       	brne	80006444 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800063fe:	f0 1f 00 16 	mcall	80006454 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006402:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006404:	f0 1f 00 18 	mcall	80006464 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006408:	58 06       	cp.w	r6,0
8000640a:	c1 71       	brne	80006438 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000640c:	6e 08       	ld.w	r8,r7[0x0]
8000640e:	58 08       	cp.w	r8,0
80006410:	c0 81       	brne	80006420 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006412:	f0 1f 00 11 	mcall	80006454 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006416:	6e 1c       	ld.w	r12,r7[0x4]
80006418:	f0 1f 00 17 	mcall	80006474 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000641c:	f0 1f 00 12 	mcall	80006464 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006420:	40 2b       	lddsp	r11,sp[0x8]
80006422:	04 9c       	mov	r12,r2
80006424:	f0 1f 00 15 	mcall	80006478 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006428:	0e 9c       	mov	r12,r7
8000642a:	f0 1f 00 15 	mcall	8000647c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000642e:	f0 1f 00 15 	mcall	80006480 <xQueueGenericReceive+0x140>
80006432:	c9 61       	brne	8000635e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006434:	d7 33       	scall
80006436:	c9 4b       	rjmp	8000635e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006438:	0e 9c       	mov	r12,r7
8000643a:	f0 1f 00 11 	mcall	8000647c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000643e:	f0 1f 00 11 	mcall	80006480 <xQueueGenericReceive+0x140>
80006442:	c8 eb       	rjmp	8000635e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006444:	0e 9c       	mov	r12,r7
80006446:	f0 1f 00 0e 	mcall	8000647c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000644a:	f0 1f 00 0e 	mcall	80006480 <xQueueGenericReceive+0x140>
8000644e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006450:	2f bd       	sub	sp,-20
80006452:	d8 32       	popm	r0-r7,pc
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	5f 8c       	srls	r12
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	62 20       	ld.w	r0,r1[0x8]
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	67 70       	ld.w	r0,r3[0x5c]
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	68 58       	ld.w	r8,r4[0x14]
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	60 98       	ld.w	r8,r0[0x24]
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	67 4c       	ld.w	r12,r3[0x50]
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	66 c0       	ld.w	r0,r3[0x30]
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	69 e8       	ld.w	r8,r4[0x78]
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	67 d4       	ld.w	r4,r3[0x74]
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	6c 88       	ld.w	r8,r6[0x20]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	62 a0       	ld.w	r0,r1[0x28]
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	6a 7c       	ld.w	r12,r5[0x1c]

80006484 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006484:	eb cd 40 80 	pushm	r7,lr
80006488:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000648a:	79 08       	ld.w	r8,r12[0x40]
8000648c:	58 08       	cp.w	r8,0
8000648e:	c0 a1       	brne	800064a2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006490:	78 08       	ld.w	r8,r12[0x0]
80006492:	58 08       	cp.w	r8,0
80006494:	c2 b1       	brne	800064ea <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006496:	78 1c       	ld.w	r12,r12[0x4]
80006498:	f0 1f 00 17 	mcall	800064f4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000649c:	30 08       	mov	r8,0
8000649e:	8f 18       	st.w	r7[0x4],r8
800064a0:	c2 58       	rjmp	800064ea <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800064a2:	58 0a       	cp.w	r10,0
800064a4:	c1 01       	brne	800064c4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800064a6:	10 9a       	mov	r10,r8
800064a8:	78 2c       	ld.w	r12,r12[0x8]
800064aa:	f0 1f 00 14 	mcall	800064f8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800064ae:	6e 29       	ld.w	r9,r7[0x8]
800064b0:	6f 08       	ld.w	r8,r7[0x40]
800064b2:	f2 08 00 08 	add	r8,r9,r8
800064b6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800064b8:	6e 19       	ld.w	r9,r7[0x4]
800064ba:	12 38       	cp.w	r8,r9
800064bc:	c1 73       	brcs	800064ea <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800064be:	6e 08       	ld.w	r8,r7[0x0]
800064c0:	8f 28       	st.w	r7[0x8],r8
800064c2:	c1 48       	rjmp	800064ea <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800064c4:	10 9a       	mov	r10,r8
800064c6:	78 3c       	ld.w	r12,r12[0xc]
800064c8:	f0 1f 00 0c 	mcall	800064f8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800064cc:	6f 08       	ld.w	r8,r7[0x40]
800064ce:	6e 39       	ld.w	r9,r7[0xc]
800064d0:	f2 08 01 08 	sub	r8,r9,r8
800064d4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800064d6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800064d8:	12 38       	cp.w	r8,r9
800064da:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800064de:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800064e2:	f3 d8 e3 19 	subcs	r9,r9,r8
800064e6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800064ea:	6e e8       	ld.w	r8,r7[0x38]
800064ec:	2f f8       	sub	r8,-1
800064ee:	8f e8       	st.w	r7[0x38],r8
}
800064f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	67 7c       	ld.w	r12,r3[0x5c]
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	79 d2       	ld.w	r2,r12[0x74]

800064fc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800064fc:	eb cd 40 c0 	pushm	r6-r7,lr
80006500:	18 97       	mov	r7,r12
80006502:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006504:	78 ec       	ld.w	r12,r12[0x38]
80006506:	6e f8       	ld.w	r8,r7[0x3c]
80006508:	10 3c       	cp.w	r12,r8
8000650a:	c0 33       	brcs	80006510 <xQueueGenericSendFromISR+0x14>
8000650c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006510:	12 9a       	mov	r10,r9
80006512:	0e 9c       	mov	r12,r7
80006514:	f0 1f 00 0c 	mcall	80006544 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006518:	6f 28       	ld.w	r8,r7[0x48]
8000651a:	5b f8       	cp.w	r8,-1
8000651c:	c0 d1       	brne	80006536 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000651e:	6e 98       	ld.w	r8,r7[0x24]
80006520:	58 08       	cp.w	r8,0
80006522:	c0 f0       	breq	80006540 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006524:	ee cc ff dc 	sub	r12,r7,-36
80006528:	f0 1f 00 08 	mcall	80006548 <xQueueGenericSendFromISR+0x4c>
8000652c:	c0 a0       	breq	80006540 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000652e:	30 1c       	mov	r12,1
80006530:	8d 0c       	st.w	r6[0x0],r12
80006532:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006536:	2f f8       	sub	r8,-1
80006538:	ef 48 00 48 	st.w	r7[72],r8
8000653c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006540:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	64 84       	ld.w	r4,r2[0x20]
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	68 58       	ld.w	r8,r4[0x14]

8000654c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000654c:	d4 31       	pushm	r0-r7,lr
8000654e:	20 5d       	sub	sp,20
80006550:	18 97       	mov	r7,r12
80006552:	50 0b       	stdsp	sp[0x0],r11
80006554:	50 2a       	stdsp	sp[0x8],r10
80006556:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006558:	f8 c0 ff f0 	sub	r0,r12,-16
8000655c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000655e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006562:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006564:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006568:	f0 1f 00 2f 	mcall	80006624 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000656c:	6e e9       	ld.w	r9,r7[0x38]
8000656e:	6e f8       	ld.w	r8,r7[0x3c]
80006570:	10 39       	cp.w	r9,r8
80006572:	c1 42       	brcc	8000659a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006574:	40 1a       	lddsp	r10,sp[0x4]
80006576:	40 0b       	lddsp	r11,sp[0x0]
80006578:	0e 9c       	mov	r12,r7
8000657a:	f0 1f 00 2c 	mcall	80006628 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000657e:	6e 98       	ld.w	r8,r7[0x24]
80006580:	58 08       	cp.w	r8,0
80006582:	c0 80       	breq	80006592 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006584:	ee cc ff dc 	sub	r12,r7,-36
80006588:	f0 1f 00 29 	mcall	8000662c <xQueueGenericSend+0xe0>
8000658c:	58 1c       	cp.w	r12,1
8000658e:	c0 21       	brne	80006592 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006590:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006592:	f0 1f 00 28 	mcall	80006630 <xQueueGenericSend+0xe4>
80006596:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006598:	c4 38       	rjmp	8000661e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000659a:	40 28       	lddsp	r8,sp[0x8]
8000659c:	58 08       	cp.w	r8,0
8000659e:	c0 51       	brne	800065a8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800065a0:	f0 1f 00 24 	mcall	80006630 <xQueueGenericSend+0xe4>
800065a4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800065a6:	c3 c8       	rjmp	8000661e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800065a8:	58 04       	cp.w	r4,0
800065aa:	c0 51       	brne	800065b4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800065ac:	06 9c       	mov	r12,r3
800065ae:	f0 1f 00 22 	mcall	80006634 <xQueueGenericSend+0xe8>
800065b2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800065b4:	f0 1f 00 1f 	mcall	80006630 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800065b8:	f0 1f 00 20 	mcall	80006638 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800065bc:	f0 1f 00 1a 	mcall	80006624 <xQueueGenericSend+0xd8>
800065c0:	6f 18       	ld.w	r8,r7[0x44]
800065c2:	5b f8       	cp.w	r8,-1
800065c4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800065c8:	6f 28       	ld.w	r8,r7[0x48]
800065ca:	5b f8       	cp.w	r8,-1
800065cc:	ef f1 0a 12 	st.weq	r7[0x48],r1
800065d0:	f0 1f 00 18 	mcall	80006630 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800065d4:	04 9b       	mov	r11,r2
800065d6:	06 9c       	mov	r12,r3
800065d8:	f0 1f 00 19 	mcall	8000663c <xQueueGenericSend+0xf0>
800065dc:	c1 b1       	brne	80006612 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800065de:	f0 1f 00 12 	mcall	80006624 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800065e2:	6e e5       	ld.w	r5,r7[0x38]
800065e4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800065e6:	f0 1f 00 13 	mcall	80006630 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800065ea:	0c 35       	cp.w	r5,r6
800065ec:	c0 d1       	brne	80006606 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800065ee:	40 2b       	lddsp	r11,sp[0x8]
800065f0:	00 9c       	mov	r12,r0
800065f2:	f0 1f 00 14 	mcall	80006640 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800065f6:	0e 9c       	mov	r12,r7
800065f8:	f0 1f 00 13 	mcall	80006644 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800065fc:	f0 1f 00 13 	mcall	80006648 <xQueueGenericSend+0xfc>
80006600:	cb 41       	brne	80006568 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006602:	d7 33       	scall
80006604:	cb 2b       	rjmp	80006568 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006606:	0e 9c       	mov	r12,r7
80006608:	f0 1f 00 0f 	mcall	80006644 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000660c:	f0 1f 00 0f 	mcall	80006648 <xQueueGenericSend+0xfc>
80006610:	ca cb       	rjmp	80006568 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006612:	0e 9c       	mov	r12,r7
80006614:	f0 1f 00 0c 	mcall	80006644 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006618:	f0 1f 00 0c 	mcall	80006648 <xQueueGenericSend+0xfc>
8000661c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000661e:	2f bd       	sub	sp,-20
80006620:	d8 32       	popm	r0-r7,pc
80006622:	00 00       	add	r0,r0
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	5f 8c       	srls	r12
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	64 84       	ld.w	r4,r2[0x20]
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	68 58       	ld.w	r8,r4[0x14]
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	60 98       	ld.w	r8,r0[0x24]
80006634:	80 00       	ld.sh	r0,r0[0x0]
80006636:	67 4c       	ld.w	r12,r3[0x50]
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	66 c0       	ld.w	r0,r3[0x30]
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	69 e8       	ld.w	r8,r4[0x78]
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	6c 88       	ld.w	r8,r6[0x20]
80006644:	80 00       	ld.sh	r0,r0[0x0]
80006646:	62 a0       	ld.w	r0,r1[0x28]
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	6a 7c       	ld.w	r12,r5[0x1c]

8000664c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000664c:	d4 21       	pushm	r4-r7,lr
8000664e:	18 97       	mov	r7,r12
80006650:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006652:	58 0c       	cp.w	r12,0
80006654:	c2 f0       	breq	800066b2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006656:	34 cc       	mov	r12,76
80006658:	f0 1f 00 17 	mcall	800066b4 <xQueueCreate+0x68>
8000665c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000665e:	c2 a0       	breq	800066b2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006660:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006664:	e8 cc ff ff 	sub	r12,r4,-1
80006668:	f0 1f 00 13 	mcall	800066b4 <xQueueCreate+0x68>
8000666c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000666e:	c1 e0       	breq	800066aa <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006670:	f8 04 00 04 	add	r4,r12,r4
80006674:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006676:	30 08       	mov	r8,0
80006678:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000667a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000667c:	ee c8 00 01 	sub	r8,r7,1
80006680:	ad 38       	mul	r8,r6
80006682:	10 0c       	add	r12,r8
80006684:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006686:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006688:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000668c:	3f f8       	mov	r8,-1
8000668e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006692:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006696:	ea cc ff f0 	sub	r12,r5,-16
8000669a:	f0 1f 00 08 	mcall	800066b8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000669e:	ea cc ff dc 	sub	r12,r5,-36
800066a2:	f0 1f 00 06 	mcall	800066b8 <xQueueCreate+0x6c>
800066a6:	0a 9c       	mov	r12,r5
800066a8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800066aa:	0a 9c       	mov	r12,r5
800066ac:	f0 1f 00 04 	mcall	800066bc <xQueueCreate+0x70>
800066b0:	d8 2a       	popm	r4-r7,pc,r12=0
800066b2:	d8 2a       	popm	r4-r7,pc,r12=0
800066b4:	80 00       	ld.sh	r0,r0[0x0]
800066b6:	61 f8       	ld.w	r8,r0[0x7c]
800066b8:	80 00       	ld.sh	r0,r0[0x0]
800066ba:	5e 68       	retmi	r8
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	61 d0       	ld.w	r0,r0[0x74]

800066c0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800066c0:	48 38       	lddpc	r8,800066cc <vTaskSuspendAll+0xc>
800066c2:	70 09       	ld.w	r9,r8[0x0]
800066c4:	2f f9       	sub	r9,-1
800066c6:	91 09       	st.w	r8[0x0],r9
}
800066c8:	5e fc       	retal	r12
800066ca:	00 00       	add	r0,r0
800066cc:	00 00       	add	r0,r0
800066ce:	0d 74       	ld.ub	r4,--r6

800066d0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800066d0:	49 a8       	lddpc	r8,80006738 <vTaskSwitchContext+0x68>
800066d2:	70 08       	ld.w	r8,r8[0x0]
800066d4:	58 08       	cp.w	r8,0
800066d6:	c0 b1       	brne	800066ec <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066d8:	49 98       	lddpc	r8,8000673c <vTaskSwitchContext+0x6c>
800066da:	70 08       	ld.w	r8,r8[0x0]
800066dc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800066e0:	49 89       	lddpc	r9,80006740 <vTaskSwitchContext+0x70>
800066e2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800066e6:	58 08       	cp.w	r8,0
800066e8:	c0 60       	breq	800066f4 <vTaskSwitchContext+0x24>
800066ea:	c1 18       	rjmp	8000670c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800066ec:	30 19       	mov	r9,1
800066ee:	49 68       	lddpc	r8,80006744 <vTaskSwitchContext+0x74>
800066f0:	91 09       	st.w	r8[0x0],r9
800066f2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800066f4:	49 28       	lddpc	r8,8000673c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066f6:	49 3a       	lddpc	r10,80006740 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800066f8:	70 09       	ld.w	r9,r8[0x0]
800066fa:	20 19       	sub	r9,1
800066fc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066fe:	70 09       	ld.w	r9,r8[0x0]
80006700:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006704:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006708:	58 09       	cp.w	r9,0
8000670a:	cf 70       	breq	800066f8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000670c:	48 c8       	lddpc	r8,8000673c <vTaskSwitchContext+0x6c>
8000670e:	70 08       	ld.w	r8,r8[0x0]
80006710:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006714:	48 b9       	lddpc	r9,80006740 <vTaskSwitchContext+0x70>
80006716:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000671a:	70 19       	ld.w	r9,r8[0x4]
8000671c:	72 19       	ld.w	r9,r9[0x4]
8000671e:	91 19       	st.w	r8[0x4],r9
80006720:	f0 ca ff f8 	sub	r10,r8,-8
80006724:	14 39       	cp.w	r9,r10
80006726:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000672a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000672e:	70 18       	ld.w	r8,r8[0x4]
80006730:	70 39       	ld.w	r9,r8[0xc]
80006732:	48 68       	lddpc	r8,80006748 <vTaskSwitchContext+0x78>
80006734:	91 09       	st.w	r8[0x0],r9
80006736:	5e fc       	retal	r12
80006738:	00 00       	add	r0,r0
8000673a:	0d 74       	ld.ub	r4,--r6
8000673c:	00 00       	add	r0,r0
8000673e:	0d ac       	ld.ub	r12,r6[0x2]
80006740:	00 00       	add	r0,r0
80006742:	0c 90       	mov	r0,r6
80006744:	00 00       	add	r0,r0
80006746:	0d 94       	ld.ub	r4,r6[0x1]
80006748:	00 00       	add	r0,r0
8000674a:	0d 44       	ld.w	r4,--r6

8000674c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000674c:	48 48       	lddpc	r8,8000675c <vTaskSetTimeOutState+0x10>
8000674e:	70 08       	ld.w	r8,r8[0x0]
80006750:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006752:	48 48       	lddpc	r8,80006760 <vTaskSetTimeOutState+0x14>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	99 18       	st.w	r12[0x4],r8
}
80006758:	5e fc       	retal	r12
8000675a:	00 00       	add	r0,r0
8000675c:	00 00       	add	r0,r0
8000675e:	0c 88       	andn	r8,r6
80006760:	00 00       	add	r0,r0
80006762:	0d 70       	ld.ub	r0,--r6

80006764 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006764:	30 19       	mov	r9,1
80006766:	48 28       	lddpc	r8,8000676c <vTaskMissedYield+0x8>
80006768:	91 09       	st.w	r8[0x0],r9
}
8000676a:	5e fc       	retal	r12
8000676c:	00 00       	add	r0,r0
8000676e:	0d 94       	ld.ub	r4,r6[0x1]

80006770 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006770:	48 28       	lddpc	r8,80006778 <xTaskGetCurrentTaskHandle+0x8>
80006772:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006774:	5e fc       	retal	r12
80006776:	00 00       	add	r0,r0
80006778:	00 00       	add	r0,r0
8000677a:	0d 44       	ld.w	r4,--r6

8000677c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000677c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006780:	58 0c       	cp.w	r12,0
80006782:	c1 f0       	breq	800067c0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006784:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006786:	78 b9       	ld.w	r9,r12[0x2c]
80006788:	79 18       	ld.w	r8,r12[0x44]
8000678a:	10 39       	cp.w	r9,r8
8000678c:	c1 a0       	breq	800067c0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000678e:	f8 c6 ff fc 	sub	r6,r12,-4
80006792:	0c 9c       	mov	r12,r6
80006794:	f0 1f 00 0c 	mcall	800067c4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006798:	6f 1c       	ld.w	r12,r7[0x44]
8000679a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000679c:	f8 08 11 08 	rsub	r8,r12,8
800067a0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800067a2:	48 a8       	lddpc	r8,800067c8 <vTaskPriorityDisinherit+0x4c>
800067a4:	70 08       	ld.w	r8,r8[0x0]
800067a6:	10 3c       	cp.w	r12,r8
800067a8:	e0 88 00 04 	brls	800067b0 <vTaskPriorityDisinherit+0x34>
800067ac:	48 78       	lddpc	r8,800067c8 <vTaskPriorityDisinherit+0x4c>
800067ae:	91 0c       	st.w	r8[0x0],r12
800067b0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067b4:	0c 9b       	mov	r11,r6
800067b6:	48 68       	lddpc	r8,800067cc <vTaskPriorityDisinherit+0x50>
800067b8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067bc:	f0 1f 00 05 	mcall	800067d0 <vTaskPriorityDisinherit+0x54>
800067c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067c4:	80 00       	ld.sh	r0,r0[0x0]
800067c6:	5e d2       	retvc	r2
800067c8:	00 00       	add	r0,r0
800067ca:	0d ac       	ld.ub	r12,r6[0x2]
800067cc:	00 00       	add	r0,r0
800067ce:	0c 90       	mov	r0,r6
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	5e 82       	retls	r2

800067d4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800067d4:	eb cd 40 c0 	pushm	r6-r7,lr
800067d8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800067da:	49 b8       	lddpc	r8,80006844 <vTaskPriorityInherit+0x70>
800067dc:	70 08       	ld.w	r8,r8[0x0]
800067de:	78 b9       	ld.w	r9,r12[0x2c]
800067e0:	70 b8       	ld.w	r8,r8[0x2c]
800067e2:	10 39       	cp.w	r9,r8
800067e4:	c2 d2       	brcc	8000683e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800067e6:	49 88       	lddpc	r8,80006844 <vTaskPriorityInherit+0x70>
800067e8:	70 08       	ld.w	r8,r8[0x0]
800067ea:	70 b8       	ld.w	r8,r8[0x2c]
800067ec:	f0 08 11 08 	rsub	r8,r8,8
800067f0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800067f2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800067f6:	49 59       	lddpc	r9,80006848 <vTaskPriorityInherit+0x74>
800067f8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800067fc:	78 59       	ld.w	r9,r12[0x14]
800067fe:	10 39       	cp.w	r9,r8
80006800:	c1 b1       	brne	80006836 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006802:	f8 c6 ff fc 	sub	r6,r12,-4
80006806:	0c 9c       	mov	r12,r6
80006808:	f0 1f 00 11 	mcall	8000684c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000680c:	48 e8       	lddpc	r8,80006844 <vTaskPriorityInherit+0x70>
8000680e:	70 08       	ld.w	r8,r8[0x0]
80006810:	70 bc       	ld.w	r12,r8[0x2c]
80006812:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006814:	48 f8       	lddpc	r8,80006850 <vTaskPriorityInherit+0x7c>
80006816:	70 08       	ld.w	r8,r8[0x0]
80006818:	10 3c       	cp.w	r12,r8
8000681a:	e0 88 00 04 	brls	80006822 <vTaskPriorityInherit+0x4e>
8000681e:	48 d8       	lddpc	r8,80006850 <vTaskPriorityInherit+0x7c>
80006820:	91 0c       	st.w	r8[0x0],r12
80006822:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006826:	0c 9b       	mov	r11,r6
80006828:	48 88       	lddpc	r8,80006848 <vTaskPriorityInherit+0x74>
8000682a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000682e:	f0 1f 00 0a 	mcall	80006854 <vTaskPriorityInherit+0x80>
80006832:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006836:	48 48       	lddpc	r8,80006844 <vTaskPriorityInherit+0x70>
80006838:	70 08       	ld.w	r8,r8[0x0]
8000683a:	70 b8       	ld.w	r8,r8[0x2c]
8000683c:	99 b8       	st.w	r12[0x2c],r8
8000683e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006842:	00 00       	add	r0,r0
80006844:	00 00       	add	r0,r0
80006846:	0d 44       	ld.w	r4,--r6
80006848:	00 00       	add	r0,r0
8000684a:	0c 90       	mov	r0,r6
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	5e d2       	retvc	r2
80006850:	00 00       	add	r0,r0
80006852:	0d ac       	ld.ub	r12,r6[0x2]
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	5e 82       	retls	r2

80006858 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006858:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000685c:	78 38       	ld.w	r8,r12[0xc]
8000685e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006860:	ee c6 ff e8 	sub	r6,r7,-24
80006864:	0c 9c       	mov	r12,r6
80006866:	f0 1f 00 15 	mcall	800068b8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000686a:	49 58       	lddpc	r8,800068bc <xTaskRemoveFromEventList+0x64>
8000686c:	70 08       	ld.w	r8,r8[0x0]
8000686e:	58 08       	cp.w	r8,0
80006870:	c1 71       	brne	8000689e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006872:	ee c6 ff fc 	sub	r6,r7,-4
80006876:	0c 9c       	mov	r12,r6
80006878:	f0 1f 00 10 	mcall	800068b8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000687c:	6e bc       	ld.w	r12,r7[0x2c]
8000687e:	49 18       	lddpc	r8,800068c0 <xTaskRemoveFromEventList+0x68>
80006880:	70 08       	ld.w	r8,r8[0x0]
80006882:	10 3c       	cp.w	r12,r8
80006884:	e0 88 00 04 	brls	8000688c <xTaskRemoveFromEventList+0x34>
80006888:	48 e8       	lddpc	r8,800068c0 <xTaskRemoveFromEventList+0x68>
8000688a:	91 0c       	st.w	r8[0x0],r12
8000688c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006890:	0c 9b       	mov	r11,r6
80006892:	48 d8       	lddpc	r8,800068c4 <xTaskRemoveFromEventList+0x6c>
80006894:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006898:	f0 1f 00 0c 	mcall	800068c8 <xTaskRemoveFromEventList+0x70>
8000689c:	c0 58       	rjmp	800068a6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000689e:	0c 9b       	mov	r11,r6
800068a0:	48 bc       	lddpc	r12,800068cc <xTaskRemoveFromEventList+0x74>
800068a2:	f0 1f 00 0a 	mcall	800068c8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068a6:	48 b8       	lddpc	r8,800068d0 <xTaskRemoveFromEventList+0x78>
800068a8:	70 08       	ld.w	r8,r8[0x0]
800068aa:	6e b9       	ld.w	r9,r7[0x2c]
800068ac:	70 b8       	ld.w	r8,r8[0x2c]
800068ae:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800068b0:	5f 2c       	srhs	r12
800068b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068b6:	00 00       	add	r0,r0
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	5e d2       	retvc	r2
800068bc:	00 00       	add	r0,r0
800068be:	0d 74       	ld.ub	r4,--r6
800068c0:	00 00       	add	r0,r0
800068c2:	0d ac       	ld.ub	r12,r6[0x2]
800068c4:	00 00       	add	r0,r0
800068c6:	0c 90       	mov	r0,r6
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	5e 82       	retls	r2
800068cc:	00 00       	add	r0,r0
800068ce:	0d 48       	ld.w	r8,--r6
800068d0:	00 00       	add	r0,r0
800068d2:	0d 44       	ld.w	r4,--r6

800068d4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800068d4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800068d8:	4b 98       	lddpc	r8,800069bc <vTaskIncrementTick+0xe8>
800068da:	70 08       	ld.w	r8,r8[0x0]
800068dc:	58 08       	cp.w	r8,0
800068de:	c6 91       	brne	800069b0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800068e0:	4b 88       	lddpc	r8,800069c0 <vTaskIncrementTick+0xec>
800068e2:	70 09       	ld.w	r9,r8[0x0]
800068e4:	2f f9       	sub	r9,-1
800068e6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800068e8:	70 08       	ld.w	r8,r8[0x0]
800068ea:	58 08       	cp.w	r8,0
800068ec:	c1 a1       	brne	80006920 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800068ee:	4b 68       	lddpc	r8,800069c4 <vTaskIncrementTick+0xf0>
800068f0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800068f2:	4b 69       	lddpc	r9,800069c8 <vTaskIncrementTick+0xf4>
800068f4:	72 0b       	ld.w	r11,r9[0x0]
800068f6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800068f8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800068fa:	4b 59       	lddpc	r9,800069cc <vTaskIncrementTick+0xf8>
800068fc:	72 0a       	ld.w	r10,r9[0x0]
800068fe:	2f fa       	sub	r10,-1
80006900:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006902:	70 08       	ld.w	r8,r8[0x0]
80006904:	70 08       	ld.w	r8,r8[0x0]
80006906:	58 08       	cp.w	r8,0
80006908:	c0 51       	brne	80006912 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000690a:	3f f9       	mov	r9,-1
8000690c:	4b 18       	lddpc	r8,800069d0 <vTaskIncrementTick+0xfc>
8000690e:	91 09       	st.w	r8[0x0],r9
80006910:	c0 88       	rjmp	80006920 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006912:	4a d8       	lddpc	r8,800069c4 <vTaskIncrementTick+0xf0>
80006914:	70 08       	ld.w	r8,r8[0x0]
80006916:	70 38       	ld.w	r8,r8[0xc]
80006918:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000691a:	70 19       	ld.w	r9,r8[0x4]
8000691c:	4a d8       	lddpc	r8,800069d0 <vTaskIncrementTick+0xfc>
8000691e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006920:	4a 88       	lddpc	r8,800069c0 <vTaskIncrementTick+0xec>
80006922:	70 09       	ld.w	r9,r8[0x0]
80006924:	4a b8       	lddpc	r8,800069d0 <vTaskIncrementTick+0xfc>
80006926:	70 08       	ld.w	r8,r8[0x0]
80006928:	10 39       	cp.w	r9,r8
8000692a:	c4 73       	brcs	800069b8 <vTaskIncrementTick+0xe4>
8000692c:	4a 68       	lddpc	r8,800069c4 <vTaskIncrementTick+0xf0>
8000692e:	70 08       	ld.w	r8,r8[0x0]
80006930:	70 08       	ld.w	r8,r8[0x0]
80006932:	58 08       	cp.w	r8,0
80006934:	c0 c0       	breq	8000694c <vTaskIncrementTick+0x78>
80006936:	4a 48       	lddpc	r8,800069c4 <vTaskIncrementTick+0xf0>
80006938:	70 08       	ld.w	r8,r8[0x0]
8000693a:	70 38       	ld.w	r8,r8[0xc]
8000693c:	70 37       	ld.w	r7,r8[0xc]
8000693e:	6e 18       	ld.w	r8,r7[0x4]
80006940:	4a 09       	lddpc	r9,800069c0 <vTaskIncrementTick+0xec>
80006942:	72 09       	ld.w	r9,r9[0x0]
80006944:	12 38       	cp.w	r8,r9
80006946:	e0 88 00 14 	brls	8000696e <vTaskIncrementTick+0x9a>
8000694a:	c0 e8       	rjmp	80006966 <vTaskIncrementTick+0x92>
8000694c:	3f f9       	mov	r9,-1
8000694e:	4a 18       	lddpc	r8,800069d0 <vTaskIncrementTick+0xfc>
80006950:	91 09       	st.w	r8[0x0],r9
80006952:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006956:	6a 08       	ld.w	r8,r5[0x0]
80006958:	70 38       	ld.w	r8,r8[0xc]
8000695a:	70 37       	ld.w	r7,r8[0xc]
8000695c:	6e 18       	ld.w	r8,r7[0x4]
8000695e:	64 09       	ld.w	r9,r2[0x0]
80006960:	12 38       	cp.w	r8,r9
80006962:	e0 88 00 0a 	brls	80006976 <vTaskIncrementTick+0xa2>
80006966:	49 b9       	lddpc	r9,800069d0 <vTaskIncrementTick+0xfc>
80006968:	93 08       	st.w	r9[0x0],r8
8000696a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000696e:	49 a4       	lddpc	r4,800069d4 <vTaskIncrementTick+0x100>
80006970:	49 a3       	lddpc	r3,800069d8 <vTaskIncrementTick+0x104>
80006972:	49 55       	lddpc	r5,800069c4 <vTaskIncrementTick+0xf0>
80006974:	49 32       	lddpc	r2,800069c0 <vTaskIncrementTick+0xec>
80006976:	ee c6 ff fc 	sub	r6,r7,-4
8000697a:	0c 9c       	mov	r12,r6
8000697c:	f0 1f 00 18 	mcall	800069dc <vTaskIncrementTick+0x108>
80006980:	6e a8       	ld.w	r8,r7[0x28]
80006982:	58 08       	cp.w	r8,0
80006984:	c0 50       	breq	8000698e <vTaskIncrementTick+0xba>
80006986:	ee cc ff e8 	sub	r12,r7,-24
8000698a:	f0 1f 00 15 	mcall	800069dc <vTaskIncrementTick+0x108>
8000698e:	6e bc       	ld.w	r12,r7[0x2c]
80006990:	68 08       	ld.w	r8,r4[0x0]
80006992:	10 3c       	cp.w	r12,r8
80006994:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006998:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000699c:	0c 9b       	mov	r11,r6
8000699e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800069a2:	f0 1f 00 10 	mcall	800069e0 <vTaskIncrementTick+0x10c>
800069a6:	6a 08       	ld.w	r8,r5[0x0]
800069a8:	70 08       	ld.w	r8,r8[0x0]
800069aa:	58 08       	cp.w	r8,0
800069ac:	cd 51       	brne	80006956 <vTaskIncrementTick+0x82>
800069ae:	cc fb       	rjmp	8000694c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800069b0:	48 d8       	lddpc	r8,800069e4 <vTaskIncrementTick+0x110>
800069b2:	70 09       	ld.w	r9,r8[0x0]
800069b4:	2f f9       	sub	r9,-1
800069b6:	91 09       	st.w	r8[0x0],r9
800069b8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800069bc:	00 00       	add	r0,r0
800069be:	0d 74       	ld.ub	r4,--r6
800069c0:	00 00       	add	r0,r0
800069c2:	0d 70       	ld.ub	r0,--r6
800069c4:	00 00       	add	r0,r0
800069c6:	0c 7c       	tst	r12,r6
800069c8:	00 00       	add	r0,r0
800069ca:	0c 8c       	andn	r12,r6
800069cc:	00 00       	add	r0,r0
800069ce:	0c 88       	andn	r8,r6
800069d0:	00 00       	add	r0,r0
800069d2:	05 44       	ld.w	r4,--r2
800069d4:	00 00       	add	r0,r0
800069d6:	0d ac       	ld.ub	r12,r6[0x2]
800069d8:	00 00       	add	r0,r0
800069da:	0c 90       	mov	r0,r6
800069dc:	80 00       	ld.sh	r0,r0[0x0]
800069de:	5e d2       	retvc	r2
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	5e 82       	retls	r2
800069e4:	00 00       	add	r0,r0
800069e6:	0c 74       	tst	r4,r6

800069e8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800069e8:	eb cd 40 c0 	pushm	r6-r7,lr
800069ec:	18 97       	mov	r7,r12
800069ee:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800069f0:	f0 1f 00 15 	mcall	80006a44 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800069f4:	6c 08       	ld.w	r8,r6[0x0]
800069f6:	5b f8       	cp.w	r8,-1
800069f8:	c0 31       	brne	800069fe <xTaskCheckForTimeOut+0x16>
800069fa:	30 07       	mov	r7,0
800069fc:	c1 f8       	rjmp	80006a3a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800069fe:	49 39       	lddpc	r9,80006a48 <xTaskCheckForTimeOut+0x60>
80006a00:	72 09       	ld.w	r9,r9[0x0]
80006a02:	6e 0a       	ld.w	r10,r7[0x0]
80006a04:	12 3a       	cp.w	r10,r9
80006a06:	c0 70       	breq	80006a14 <xTaskCheckForTimeOut+0x2c>
80006a08:	49 19       	lddpc	r9,80006a4c <xTaskCheckForTimeOut+0x64>
80006a0a:	72 09       	ld.w	r9,r9[0x0]
80006a0c:	6e 1a       	ld.w	r10,r7[0x4]
80006a0e:	12 3a       	cp.w	r10,r9
80006a10:	e0 88 00 14 	brls	80006a38 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006a14:	48 e9       	lddpc	r9,80006a4c <xTaskCheckForTimeOut+0x64>
80006a16:	72 0a       	ld.w	r10,r9[0x0]
80006a18:	6e 19       	ld.w	r9,r7[0x4]
80006a1a:	12 1a       	sub	r10,r9
80006a1c:	14 38       	cp.w	r8,r10
80006a1e:	e0 88 00 0d 	brls	80006a38 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006a22:	48 ba       	lddpc	r10,80006a4c <xTaskCheckForTimeOut+0x64>
80006a24:	74 0a       	ld.w	r10,r10[0x0]
80006a26:	14 19       	sub	r9,r10
80006a28:	f2 08 00 08 	add	r8,r9,r8
80006a2c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006a2e:	0e 9c       	mov	r12,r7
80006a30:	f0 1f 00 08 	mcall	80006a50 <xTaskCheckForTimeOut+0x68>
80006a34:	30 07       	mov	r7,0
80006a36:	c0 28       	rjmp	80006a3a <xTaskCheckForTimeOut+0x52>
80006a38:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006a3a:	f0 1f 00 07 	mcall	80006a54 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006a3e:	0e 9c       	mov	r12,r7
80006a40:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	5f 8c       	srls	r12
80006a48:	00 00       	add	r0,r0
80006a4a:	0c 88       	andn	r8,r6
80006a4c:	00 00       	add	r0,r0
80006a4e:	0d 70       	ld.ub	r0,--r6
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	67 4c       	ld.w	r12,r3[0x50]
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	60 98       	ld.w	r8,r0[0x24]

80006a58 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006a58:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006a5c:	f0 1f 00 05 	mcall	80006a70 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006a60:	48 58       	lddpc	r8,80006a74 <xTaskGetTickCount+0x1c>
80006a62:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006a64:	f0 1f 00 05 	mcall	80006a78 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006a68:	0e 9c       	mov	r12,r7
80006a6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a6e:	00 00       	add	r0,r0
80006a70:	80 00       	ld.sh	r0,r0[0x0]
80006a72:	5f 8c       	srls	r12
80006a74:	00 00       	add	r0,r0
80006a76:	0d 70       	ld.ub	r0,--r6
80006a78:	80 00       	ld.sh	r0,r0[0x0]
80006a7a:	60 98       	ld.w	r8,r0[0x24]

80006a7c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006a7c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006a80:	f0 1f 00 2c 	mcall	80006b30 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006a84:	4a c8       	lddpc	r8,80006b34 <xTaskResumeAll+0xb8>
80006a86:	70 09       	ld.w	r9,r8[0x0]
80006a88:	20 19       	sub	r9,1
80006a8a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006a8c:	70 08       	ld.w	r8,r8[0x0]
80006a8e:	58 08       	cp.w	r8,0
80006a90:	c4 91       	brne	80006b22 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006a92:	4a a8       	lddpc	r8,80006b38 <xTaskResumeAll+0xbc>
80006a94:	70 08       	ld.w	r8,r8[0x0]
80006a96:	58 08       	cp.w	r8,0
80006a98:	c4 50       	breq	80006b22 <xTaskResumeAll+0xa6>
80006a9a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006a9c:	4a 85       	lddpc	r5,80006b3c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006a9e:	4a 93       	lddpc	r3,80006b40 <xTaskResumeAll+0xc4>
80006aa0:	4a 92       	lddpc	r2,80006b44 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006aa2:	4a a1       	lddpc	r1,80006b48 <xTaskResumeAll+0xcc>
80006aa4:	c1 e8       	rjmp	80006ae0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006aa6:	6a 38       	ld.w	r8,r5[0xc]
80006aa8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006aaa:	ee cc ff e8 	sub	r12,r7,-24
80006aae:	f0 1f 00 28 	mcall	80006b4c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006ab2:	ee c6 ff fc 	sub	r6,r7,-4
80006ab6:	0c 9c       	mov	r12,r6
80006ab8:	f0 1f 00 25 	mcall	80006b4c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006abc:	6e bc       	ld.w	r12,r7[0x2c]
80006abe:	66 08       	ld.w	r8,r3[0x0]
80006ac0:	10 3c       	cp.w	r12,r8
80006ac2:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006ac6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006aca:	0c 9b       	mov	r11,r6
80006acc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006ad0:	f0 1f 00 20 	mcall	80006b50 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ad4:	62 08       	ld.w	r8,r1[0x0]
80006ad6:	6e b9       	ld.w	r9,r7[0x2c]
80006ad8:	70 b8       	ld.w	r8,r8[0x2c]
80006ada:	10 39       	cp.w	r9,r8
80006adc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006ae0:	6a 08       	ld.w	r8,r5[0x0]
80006ae2:	58 08       	cp.w	r8,0
80006ae4:	ce 11       	brne	80006aa6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006ae6:	49 c8       	lddpc	r8,80006b54 <xTaskResumeAll+0xd8>
80006ae8:	70 08       	ld.w	r8,r8[0x0]
80006aea:	58 08       	cp.w	r8,0
80006aec:	c0 f0       	breq	80006b0a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006aee:	49 a8       	lddpc	r8,80006b54 <xTaskResumeAll+0xd8>
80006af0:	70 08       	ld.w	r8,r8[0x0]
80006af2:	58 08       	cp.w	r8,0
80006af4:	c1 10       	breq	80006b16 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006af6:	49 87       	lddpc	r7,80006b54 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006af8:	f0 1f 00 18 	mcall	80006b58 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006afc:	6e 08       	ld.w	r8,r7[0x0]
80006afe:	20 18       	sub	r8,1
80006b00:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006b02:	6e 08       	ld.w	r8,r7[0x0]
80006b04:	58 08       	cp.w	r8,0
80006b06:	cf 91       	brne	80006af8 <xTaskResumeAll+0x7c>
80006b08:	c0 78       	rjmp	80006b16 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006b0a:	58 14       	cp.w	r4,1
80006b0c:	c0 50       	breq	80006b16 <xTaskResumeAll+0x9a>
80006b0e:	49 48       	lddpc	r8,80006b5c <xTaskResumeAll+0xe0>
80006b10:	70 08       	ld.w	r8,r8[0x0]
80006b12:	58 18       	cp.w	r8,1
80006b14:	c0 71       	brne	80006b22 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006b16:	30 09       	mov	r9,0
80006b18:	49 18       	lddpc	r8,80006b5c <xTaskResumeAll+0xe0>
80006b1a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006b1c:	d7 33       	scall
80006b1e:	30 17       	mov	r7,1
80006b20:	c0 28       	rjmp	80006b24 <xTaskResumeAll+0xa8>
80006b22:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006b24:	f0 1f 00 0f 	mcall	80006b60 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006b28:	0e 9c       	mov	r12,r7
80006b2a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006b2e:	00 00       	add	r0,r0
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5f 8c       	srls	r12
80006b34:	00 00       	add	r0,r0
80006b36:	0d 74       	ld.ub	r4,--r6
80006b38:	00 00       	add	r0,r0
80006b3a:	0d 90       	ld.ub	r0,r6[0x1]
80006b3c:	00 00       	add	r0,r0
80006b3e:	0d 48       	ld.w	r8,--r6
80006b40:	00 00       	add	r0,r0
80006b42:	0d ac       	ld.ub	r12,r6[0x2]
80006b44:	00 00       	add	r0,r0
80006b46:	0c 90       	mov	r0,r6
80006b48:	00 00       	add	r0,r0
80006b4a:	0d 44       	ld.w	r4,--r6
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	5e d2       	retvc	r2
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	5e 82       	retls	r2
80006b54:	00 00       	add	r0,r0
80006b56:	0c 74       	tst	r4,r6
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	68 d4       	ld.w	r4,r4[0x34]
80006b5c:	00 00       	add	r0,r0
80006b5e:	0d 94       	ld.ub	r4,r6[0x1]
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	60 98       	ld.w	r8,r0[0x24]

80006b64 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006b64:	eb cd 40 80 	pushm	r7,lr
80006b68:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006b6a:	49 08       	lddpc	r8,80006ba8 <prvAddCurrentTaskToDelayedList+0x44>
80006b6c:	70 08       	ld.w	r8,r8[0x0]
80006b6e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006b70:	48 f8       	lddpc	r8,80006bac <prvAddCurrentTaskToDelayedList+0x48>
80006b72:	70 08       	ld.w	r8,r8[0x0]
80006b74:	10 3c       	cp.w	r12,r8
80006b76:	c0 a2       	brcc	80006b8a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b78:	48 c8       	lddpc	r8,80006ba8 <prvAddCurrentTaskToDelayedList+0x44>
80006b7a:	70 0b       	ld.w	r11,r8[0x0]
80006b7c:	48 d8       	lddpc	r8,80006bb0 <prvAddCurrentTaskToDelayedList+0x4c>
80006b7e:	70 0c       	ld.w	r12,r8[0x0]
80006b80:	2f cb       	sub	r11,-4
80006b82:	f0 1f 00 0d 	mcall	80006bb4 <prvAddCurrentTaskToDelayedList+0x50>
80006b86:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b8a:	48 88       	lddpc	r8,80006ba8 <prvAddCurrentTaskToDelayedList+0x44>
80006b8c:	70 0b       	ld.w	r11,r8[0x0]
80006b8e:	48 b8       	lddpc	r8,80006bb8 <prvAddCurrentTaskToDelayedList+0x54>
80006b90:	70 0c       	ld.w	r12,r8[0x0]
80006b92:	2f cb       	sub	r11,-4
80006b94:	f0 1f 00 08 	mcall	80006bb4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006b98:	48 98       	lddpc	r8,80006bbc <prvAddCurrentTaskToDelayedList+0x58>
80006b9a:	70 08       	ld.w	r8,r8[0x0]
80006b9c:	10 37       	cp.w	r7,r8
80006b9e:	c0 32       	brcc	80006ba4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006ba0:	48 78       	lddpc	r8,80006bbc <prvAddCurrentTaskToDelayedList+0x58>
80006ba2:	91 07       	st.w	r8[0x0],r7
80006ba4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ba8:	00 00       	add	r0,r0
80006baa:	0d 44       	ld.w	r4,--r6
80006bac:	00 00       	add	r0,r0
80006bae:	0d 70       	ld.ub	r0,--r6
80006bb0:	00 00       	add	r0,r0
80006bb2:	0c 8c       	andn	r12,r6
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	5e 9e       	retgt	-1
80006bb8:	00 00       	add	r0,r0
80006bba:	0c 7c       	tst	r12,r6
80006bbc:	00 00       	add	r0,r0
80006bbe:	05 44       	ld.w	r4,--r2

80006bc0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006bc0:	eb cd 40 c0 	pushm	r6-r7,lr
80006bc4:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006bc6:	58 0c       	cp.w	r12,0
80006bc8:	c1 10       	breq	80006bea <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006bca:	f0 1f 00 0a 	mcall	80006bf0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006bce:	48 a8       	lddpc	r8,80006bf4 <vTaskDelay+0x34>
80006bd0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bd2:	48 a8       	lddpc	r8,80006bf8 <vTaskDelay+0x38>
80006bd4:	70 0c       	ld.w	r12,r8[0x0]
80006bd6:	2f cc       	sub	r12,-4
80006bd8:	f0 1f 00 09 	mcall	80006bfc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006bdc:	ee 06 00 0c 	add	r12,r7,r6
80006be0:	f0 1f 00 08 	mcall	80006c00 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006be4:	f0 1f 00 08 	mcall	80006c04 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006be8:	c0 21       	brne	80006bec <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006bea:	d7 33       	scall
80006bec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	66 c0       	ld.w	r0,r3[0x30]
80006bf4:	00 00       	add	r0,r0
80006bf6:	0d 70       	ld.ub	r0,--r6
80006bf8:	00 00       	add	r0,r0
80006bfa:	0d 44       	ld.w	r4,--r6
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	5e d2       	retvc	r2
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	6b 64       	ld.w	r4,r5[0x58]
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	6a 7c       	ld.w	r12,r5[0x1c]

80006c08 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006c08:	eb cd 40 c0 	pushm	r6-r7,lr
80006c0c:	18 96       	mov	r6,r12
80006c0e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006c10:	f0 1f 00 18 	mcall	80006c70 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006c14:	6c 08       	ld.w	r8,r6[0x0]
80006c16:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006c18:	49 79       	lddpc	r9,80006c74 <vTaskDelayUntil+0x6c>
80006c1a:	72 09       	ld.w	r9,r9[0x0]
80006c1c:	12 38       	cp.w	r8,r9
80006c1e:	e0 88 00 0c 	brls	80006c36 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006c22:	0e 38       	cp.w	r8,r7
80006c24:	e0 88 00 22 	brls	80006c68 <vTaskDelayUntil+0x60>
80006c28:	49 38       	lddpc	r8,80006c74 <vTaskDelayUntil+0x6c>
80006c2a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c2c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006c2e:	10 37       	cp.w	r7,r8
80006c30:	e0 88 00 14 	brls	80006c58 <vTaskDelayUntil+0x50>
80006c34:	c0 a8       	rjmp	80006c48 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006c36:	0e 38       	cp.w	r8,r7
80006c38:	e0 8b 00 16 	brhi	80006c64 <vTaskDelayUntil+0x5c>
80006c3c:	48 e8       	lddpc	r8,80006c74 <vTaskDelayUntil+0x6c>
80006c3e:	70 08       	ld.w	r8,r8[0x0]
80006c40:	10 37       	cp.w	r7,r8
80006c42:	e0 8b 00 11 	brhi	80006c64 <vTaskDelayUntil+0x5c>
80006c46:	c1 18       	rjmp	80006c68 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c48:	48 c8       	lddpc	r8,80006c78 <vTaskDelayUntil+0x70>
80006c4a:	70 0c       	ld.w	r12,r8[0x0]
80006c4c:	2f cc       	sub	r12,-4
80006c4e:	f0 1f 00 0c 	mcall	80006c7c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006c52:	0e 9c       	mov	r12,r7
80006c54:	f0 1f 00 0b 	mcall	80006c80 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006c58:	f0 1f 00 0b 	mcall	80006c84 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006c5c:	c0 81       	brne	80006c6c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006c5e:	d7 33       	scall
80006c60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c64:	8d 07       	st.w	r6[0x0],r7
80006c66:	cf 1b       	rjmp	80006c48 <vTaskDelayUntil+0x40>
80006c68:	8d 07       	st.w	r6[0x0],r7
80006c6a:	cf 7b       	rjmp	80006c58 <vTaskDelayUntil+0x50>
80006c6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c70:	80 00       	ld.sh	r0,r0[0x0]
80006c72:	66 c0       	ld.w	r0,r3[0x30]
80006c74:	00 00       	add	r0,r0
80006c76:	0d 70       	ld.ub	r0,--r6
80006c78:	00 00       	add	r0,r0
80006c7a:	0d 44       	ld.w	r4,--r6
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	5e d2       	retvc	r2
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	6b 64       	ld.w	r4,r5[0x58]
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	6a 7c       	ld.w	r12,r5[0x1c]

80006c88 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006c88:	eb cd 40 c0 	pushm	r6-r7,lr
80006c8c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006c8e:	48 e7       	lddpc	r7,80006cc4 <vTaskPlaceOnEventList+0x3c>
80006c90:	6e 0b       	ld.w	r11,r7[0x0]
80006c92:	2e 8b       	sub	r11,-24
80006c94:	f0 1f 00 0d 	mcall	80006cc8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c98:	6e 0c       	ld.w	r12,r7[0x0]
80006c9a:	2f cc       	sub	r12,-4
80006c9c:	f0 1f 00 0c 	mcall	80006ccc <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006ca0:	5b f6       	cp.w	r6,-1
80006ca2:	c0 81       	brne	80006cb2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ca4:	6e 0b       	ld.w	r11,r7[0x0]
80006ca6:	2f cb       	sub	r11,-4
80006ca8:	48 ac       	lddpc	r12,80006cd0 <vTaskPlaceOnEventList+0x48>
80006caa:	f0 1f 00 0b 	mcall	80006cd4 <vTaskPlaceOnEventList+0x4c>
80006cae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006cb2:	48 a8       	lddpc	r8,80006cd8 <vTaskPlaceOnEventList+0x50>
80006cb4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006cb6:	ec 0c 00 0c 	add	r12,r6,r12
80006cba:	f0 1f 00 09 	mcall	80006cdc <vTaskPlaceOnEventList+0x54>
80006cbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006cc2:	00 00       	add	r0,r0
80006cc4:	00 00       	add	r0,r0
80006cc6:	0d 44       	ld.w	r4,--r6
80006cc8:	80 00       	ld.sh	r0,r0[0x0]
80006cca:	5e 9e       	retgt	-1
80006ccc:	80 00       	ld.sh	r0,r0[0x0]
80006cce:	5e d2       	retvc	r2
80006cd0:	00 00       	add	r0,r0
80006cd2:	0d 98       	ld.ub	r8,r6[0x1]
80006cd4:	80 00       	ld.sh	r0,r0[0x0]
80006cd6:	5e 82       	retls	r2
80006cd8:	00 00       	add	r0,r0
80006cda:	0d 70       	ld.ub	r0,--r6
80006cdc:	80 00       	ld.sh	r0,r0[0x0]
80006cde:	6b 64       	ld.w	r4,r5[0x58]

80006ce0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006ce0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006ce4:	49 67       	lddpc	r7,80006d3c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006ce6:	49 74       	lddpc	r4,80006d40 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006ce8:	49 73       	lddpc	r3,80006d44 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006cea:	49 85       	lddpc	r5,80006d48 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006cec:	6e 08       	ld.w	r8,r7[0x0]
80006cee:	58 08       	cp.w	r8,0
80006cf0:	c1 e0       	breq	80006d2c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006cf2:	f0 1f 00 17 	mcall	80006d4c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006cf6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006cf8:	f0 1f 00 16 	mcall	80006d50 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006cfc:	58 06       	cp.w	r6,0
80006cfe:	c1 70       	breq	80006d2c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006d00:	f0 1f 00 15 	mcall	80006d54 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006d04:	68 38       	ld.w	r8,r4[0xc]
80006d06:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006d08:	ec cc ff fc 	sub	r12,r6,-4
80006d0c:	f0 1f 00 13 	mcall	80006d58 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006d10:	66 08       	ld.w	r8,r3[0x0]
80006d12:	20 18       	sub	r8,1
80006d14:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006d16:	6e 08       	ld.w	r8,r7[0x0]
80006d18:	20 18       	sub	r8,1
80006d1a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006d1c:	f0 1f 00 10 	mcall	80006d5c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006d20:	6c cc       	ld.w	r12,r6[0x30]
80006d22:	f0 1f 00 10 	mcall	80006d60 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006d26:	0c 9c       	mov	r12,r6
80006d28:	f0 1f 00 0e 	mcall	80006d60 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006d2c:	6a 08       	ld.w	r8,r5[0x0]
80006d2e:	58 18       	cp.w	r8,1
80006d30:	e0 88 00 03 	brls	80006d36 <prvIdleTask+0x56>
			{
				taskYIELD();
80006d34:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006d36:	f0 1f 00 0c 	mcall	80006d64 <prvIdleTask+0x84>
		}
		#endif
	}
80006d3a:	cd 9b       	rjmp	80006cec <prvIdleTask+0xc>
80006d3c:	00 00       	add	r0,r0
80006d3e:	0c 84       	andn	r4,r6
80006d40:	00 00       	add	r0,r0
80006d42:	0d 30       	ld.ub	r0,r6++
80006d44:	00 00       	add	r0,r0
80006d46:	0d 90       	ld.ub	r0,r6[0x1]
80006d48:	00 00       	add	r0,r0
80006d4a:	0c 90       	mov	r0,r6
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	66 c0       	ld.w	r0,r3[0x30]
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	6a 7c       	ld.w	r12,r5[0x1c]
80006d54:	80 00       	ld.sh	r0,r0[0x0]
80006d56:	5f 8c       	srls	r12
80006d58:	80 00       	ld.sh	r0,r0[0x0]
80006d5a:	5e d2       	retvc	r2
80006d5c:	80 00       	ld.sh	r0,r0[0x0]
80006d5e:	60 98       	ld.w	r8,r0[0x24]
80006d60:	80 00       	ld.sh	r0,r0[0x0]
80006d62:	61 d0       	ld.w	r0,r0[0x74]
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	20 2c       	sub	r12,2

80006d68 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006d68:	d4 31       	pushm	r0-r7,lr
80006d6a:	20 1d       	sub	sp,4
80006d6c:	fa c4 ff d8 	sub	r4,sp,-40
80006d70:	50 0c       	stdsp	sp[0x0],r12
80006d72:	16 91       	mov	r1,r11
80006d74:	14 97       	mov	r7,r10
80006d76:	12 90       	mov	r0,r9
80006d78:	10 93       	mov	r3,r8
80006d7a:	68 02       	ld.w	r2,r4[0x0]
80006d7c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006d7e:	34 8c       	mov	r12,72
80006d80:	f0 1f 00 5c 	mcall	80006ef0 <xTaskGenericCreate+0x188>
80006d84:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006d86:	c0 31       	brne	80006d8c <xTaskGenericCreate+0x24>
80006d88:	3f fc       	mov	r12,-1
80006d8a:	ca f8       	rjmp	80006ee8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d8c:	58 06       	cp.w	r6,0
80006d8e:	e0 81 00 af 	brne	80006eec <xTaskGenericCreate+0x184>
80006d92:	0e 9c       	mov	r12,r7
80006d94:	5c 7c       	castu.h	r12
80006d96:	a3 6c       	lsl	r12,0x2
80006d98:	f0 1f 00 56 	mcall	80006ef0 <xTaskGenericCreate+0x188>
80006d9c:	18 96       	mov	r6,r12
80006d9e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006da0:	c0 61       	brne	80006dac <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006da2:	0a 9c       	mov	r12,r5
80006da4:	f0 1f 00 54 	mcall	80006ef4 <xTaskGenericCreate+0x18c>
80006da8:	3f fc       	mov	r12,-1
80006daa:	c9 f8       	rjmp	80006ee8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006dac:	5c 77       	castu.h	r7
80006dae:	ee 0a 15 02 	lsl	r10,r7,0x2
80006db2:	e0 6b 00 a5 	mov	r11,165
80006db6:	0c 9c       	mov	r12,r6
80006db8:	f0 1f 00 50 	mcall	80006ef8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006dbc:	ee c6 00 01 	sub	r6,r7,1
80006dc0:	6a c8       	ld.w	r8,r5[0x30]
80006dc2:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006dc6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006dca:	31 0a       	mov	r10,16
80006dcc:	02 9b       	mov	r11,r1
80006dce:	ea cc ff cc 	sub	r12,r5,-52
80006dd2:	f0 1f 00 4b 	mcall	80006efc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006dd6:	30 08       	mov	r8,0
80006dd8:	eb 68 00 43 	st.b	r5[67],r8
80006ddc:	58 73       	cp.w	r3,7
80006dde:	e6 07 17 80 	movls	r7,r3
80006de2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006de6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006de8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006dec:	ea c4 ff fc 	sub	r4,r5,-4
80006df0:	08 9c       	mov	r12,r4
80006df2:	f0 1f 00 44 	mcall	80006f00 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006df6:	ea cc ff e8 	sub	r12,r5,-24
80006dfa:	f0 1f 00 42 	mcall	80006f00 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006dfe:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006e00:	ee 07 11 08 	rsub	r7,r7,8
80006e04:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006e06:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006e08:	00 9a       	mov	r10,r0
80006e0a:	40 0b       	lddsp	r11,sp[0x0]
80006e0c:	0c 9c       	mov	r12,r6
80006e0e:	f0 1f 00 3e 	mcall	80006f04 <xTaskGenericCreate+0x19c>
80006e12:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006e14:	58 02       	cp.w	r2,0
80006e16:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006e1a:	f0 1f 00 3c 	mcall	80006f08 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006e1e:	4b c8       	lddpc	r8,80006f0c <xTaskGenericCreate+0x1a4>
80006e20:	70 09       	ld.w	r9,r8[0x0]
80006e22:	2f f9       	sub	r9,-1
80006e24:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006e26:	4b b8       	lddpc	r8,80006f10 <xTaskGenericCreate+0x1a8>
80006e28:	70 08       	ld.w	r8,r8[0x0]
80006e2a:	58 08       	cp.w	r8,0
80006e2c:	c2 61       	brne	80006e78 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006e2e:	4b 98       	lddpc	r8,80006f10 <xTaskGenericCreate+0x1a8>
80006e30:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006e32:	4b 78       	lddpc	r8,80006f0c <xTaskGenericCreate+0x1a4>
80006e34:	70 08       	ld.w	r8,r8[0x0]
80006e36:	58 18       	cp.w	r8,1
80006e38:	c2 b1       	brne	80006e8e <xTaskGenericCreate+0x126>
80006e3a:	4b 77       	lddpc	r7,80006f14 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006e3c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006e40:	0e 9c       	mov	r12,r7
80006e42:	f0 1f 00 36 	mcall	80006f18 <xTaskGenericCreate+0x1b0>
80006e46:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006e48:	0c 37       	cp.w	r7,r6
80006e4a:	cf b1       	brne	80006e40 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006e4c:	4b 47       	lddpc	r7,80006f1c <xTaskGenericCreate+0x1b4>
80006e4e:	0e 9c       	mov	r12,r7
80006e50:	f0 1f 00 32 	mcall	80006f18 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006e54:	4b 36       	lddpc	r6,80006f20 <xTaskGenericCreate+0x1b8>
80006e56:	0c 9c       	mov	r12,r6
80006e58:	f0 1f 00 30 	mcall	80006f18 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006e5c:	4b 2c       	lddpc	r12,80006f24 <xTaskGenericCreate+0x1bc>
80006e5e:	f0 1f 00 2f 	mcall	80006f18 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006e62:	4b 2c       	lddpc	r12,80006f28 <xTaskGenericCreate+0x1c0>
80006e64:	f0 1f 00 2d 	mcall	80006f18 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006e68:	4b 1c       	lddpc	r12,80006f2c <xTaskGenericCreate+0x1c4>
80006e6a:	f0 1f 00 2c 	mcall	80006f18 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006e6e:	4b 18       	lddpc	r8,80006f30 <xTaskGenericCreate+0x1c8>
80006e70:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006e72:	4b 18       	lddpc	r8,80006f34 <xTaskGenericCreate+0x1cc>
80006e74:	91 06       	st.w	r8[0x0],r6
80006e76:	c0 c8       	rjmp	80006e8e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006e78:	4b 08       	lddpc	r8,80006f38 <xTaskGenericCreate+0x1d0>
80006e7a:	70 08       	ld.w	r8,r8[0x0]
80006e7c:	58 08       	cp.w	r8,0
80006e7e:	c0 81       	brne	80006e8e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006e80:	4a 48       	lddpc	r8,80006f10 <xTaskGenericCreate+0x1a8>
80006e82:	70 08       	ld.w	r8,r8[0x0]
80006e84:	70 b8       	ld.w	r8,r8[0x2c]
80006e86:	10 33       	cp.w	r3,r8
80006e88:	c0 33       	brcs	80006e8e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006e8a:	4a 28       	lddpc	r8,80006f10 <xTaskGenericCreate+0x1a8>
80006e8c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006e8e:	6a b8       	ld.w	r8,r5[0x2c]
80006e90:	4a b9       	lddpc	r9,80006f3c <xTaskGenericCreate+0x1d4>
80006e92:	72 09       	ld.w	r9,r9[0x0]
80006e94:	12 38       	cp.w	r8,r9
80006e96:	e0 88 00 04 	brls	80006e9e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006e9a:	4a 99       	lddpc	r9,80006f3c <xTaskGenericCreate+0x1d4>
80006e9c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006e9e:	4a 98       	lddpc	r8,80006f40 <xTaskGenericCreate+0x1d8>
80006ea0:	70 09       	ld.w	r9,r8[0x0]
80006ea2:	2f f9       	sub	r9,-1
80006ea4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ea6:	6a b8       	ld.w	r8,r5[0x2c]
80006ea8:	4a 79       	lddpc	r9,80006f44 <xTaskGenericCreate+0x1dc>
80006eaa:	72 09       	ld.w	r9,r9[0x0]
80006eac:	12 38       	cp.w	r8,r9
80006eae:	e0 88 00 04 	brls	80006eb6 <xTaskGenericCreate+0x14e>
80006eb2:	4a 59       	lddpc	r9,80006f44 <xTaskGenericCreate+0x1dc>
80006eb4:	93 08       	st.w	r9[0x0],r8
80006eb6:	6a bc       	ld.w	r12,r5[0x2c]
80006eb8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ebc:	08 9b       	mov	r11,r4
80006ebe:	49 68       	lddpc	r8,80006f14 <xTaskGenericCreate+0x1ac>
80006ec0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ec4:	f0 1f 00 21 	mcall	80006f48 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006ec8:	f0 1f 00 21 	mcall	80006f4c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006ecc:	49 b8       	lddpc	r8,80006f38 <xTaskGenericCreate+0x1d0>
80006ece:	70 08       	ld.w	r8,r8[0x0]
80006ed0:	58 08       	cp.w	r8,0
80006ed2:	c0 a0       	breq	80006ee6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ed4:	48 f8       	lddpc	r8,80006f10 <xTaskGenericCreate+0x1a8>
80006ed6:	70 08       	ld.w	r8,r8[0x0]
80006ed8:	70 b8       	ld.w	r8,r8[0x2c]
80006eda:	10 33       	cp.w	r3,r8
80006edc:	e0 88 00 05 	brls	80006ee6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ee0:	d7 33       	scall
80006ee2:	30 1c       	mov	r12,1
80006ee4:	c0 28       	rjmp	80006ee8 <xTaskGenericCreate+0x180>
80006ee6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006ee8:	2f fd       	sub	sp,-4
80006eea:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006eec:	99 c6       	st.w	r12[0x30],r6
80006eee:	c5 fb       	rjmp	80006dac <xTaskGenericCreate+0x44>
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	61 f8       	ld.w	r8,r0[0x7c]
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	61 d0       	ld.w	r0,r0[0x74]
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	7b 1a       	ld.w	r10,sp[0x44]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	7e 44       	ld.w	r4,pc[0x10]
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	5e 7c       	retpl	r12
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	5e f8       	retal	r8
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	5f 8c       	srls	r12
80006f0c:	00 00       	add	r0,r0
80006f0e:	0d 90       	ld.ub	r0,r6[0x1]
80006f10:	00 00       	add	r0,r0
80006f12:	0d 44       	ld.w	r4,--r6
80006f14:	00 00       	add	r0,r0
80006f16:	0c 90       	mov	r0,r6
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	5e 68       	retmi	r8
80006f1c:	00 00       	add	r0,r0
80006f1e:	0d 5c       	ld.sh	r12,--r6
80006f20:	00 00       	add	r0,r0
80006f22:	0d 78       	ld.ub	r8,--r6
80006f24:	00 00       	add	r0,r0
80006f26:	0d 48       	ld.w	r8,--r6
80006f28:	00 00       	add	r0,r0
80006f2a:	0d 30       	ld.ub	r0,r6++
80006f2c:	00 00       	add	r0,r0
80006f2e:	0d 98       	ld.ub	r8,r6[0x1]
80006f30:	00 00       	add	r0,r0
80006f32:	0c 7c       	tst	r12,r6
80006f34:	00 00       	add	r0,r0
80006f36:	0c 8c       	andn	r12,r6
80006f38:	00 00       	add	r0,r0
80006f3a:	0c 80       	andn	r0,r6
80006f3c:	00 00       	add	r0,r0
80006f3e:	0c 78       	tst	r8,r6
80006f40:	00 00       	add	r0,r0
80006f42:	0d 8c       	ld.ub	r12,r6[0x0]
80006f44:	00 00       	add	r0,r0
80006f46:	0d ac       	ld.ub	r12,r6[0x2]
80006f48:	80 00       	ld.sh	r0,r0[0x0]
80006f4a:	5e 82       	retls	r2
80006f4c:	80 00       	ld.sh	r0,r0[0x0]
80006f4e:	60 98       	ld.w	r8,r0[0x24]

80006f50 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006f50:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006f52:	30 09       	mov	r9,0
80006f54:	1a d9       	st.w	--sp,r9
80006f56:	1a d9       	st.w	--sp,r9
80006f58:	1a d9       	st.w	--sp,r9
80006f5a:	12 98       	mov	r8,r9
80006f5c:	e0 6a 01 00 	mov	r10,256
80006f60:	48 9b       	lddpc	r11,80006f84 <vTaskStartScheduler+0x34>
80006f62:	48 ac       	lddpc	r12,80006f88 <vTaskStartScheduler+0x38>
80006f64:	f0 1f 00 0a 	mcall	80006f8c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006f68:	2f dd       	sub	sp,-12
80006f6a:	58 1c       	cp.w	r12,1
80006f6c:	c0 a1       	brne	80006f80 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006f6e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006f70:	30 19       	mov	r9,1
80006f72:	48 88       	lddpc	r8,80006f90 <vTaskStartScheduler+0x40>
80006f74:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006f76:	30 09       	mov	r9,0
80006f78:	48 78       	lddpc	r8,80006f94 <vTaskStartScheduler+0x44>
80006f7a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006f7c:	f0 1f 00 07 	mcall	80006f98 <vTaskStartScheduler+0x48>
80006f80:	d8 02       	popm	pc
80006f82:	00 00       	add	r0,r0
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	db 98       	*unknown*
80006f88:	80 00       	ld.sh	r0,r0[0x0]
80006f8a:	6c e0       	ld.w	r0,r6[0x38]
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	6d 68       	ld.w	r8,r6[0x58]
80006f90:	00 00       	add	r0,r0
80006f92:	0c 80       	andn	r0,r6
80006f94:	00 00       	add	r0,r0
80006f96:	0d 70       	ld.ub	r0,--r6
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	5f 9c       	srgt	r12

80006f9c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006f9c:	16 cc       	st.b	r11++,r12
	return str;
}
80006f9e:	5e fb       	retal	r11

80006fa0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006fa0:	eb cd 40 c0 	pushm	r6-r7,lr
80006fa4:	20 3d       	sub	sp,12
80006fa6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006fa8:	30 06       	mov	r6,0
80006faa:	30 07       	mov	r7,0
80006fac:	fa e7 00 00 	st.d	sp[0],r6
80006fb0:	30 0c       	mov	r12,0
80006fb2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006fb4:	58 08       	cp.w	r8,0
80006fb6:	c1 30       	breq	80006fdc <PrintHex+0x3c>
80006fb8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006fba:	1a 9c       	mov	r12,sp
80006fbc:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006fc0:	58 9e       	cp.w	lr,9
80006fc2:	e0 8a 00 04 	brle	80006fca <PrintHex+0x2a>
80006fc6:	2c 9e       	sub	lr,-55
80006fc8:	c0 48       	rjmp	80006fd0 <PrintHex+0x30>
80006fca:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006fce:	2d 0e       	sub	lr,-48
80006fd0:	f8 09 0b 0e 	st.b	r12[r9],lr
80006fd4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006fd6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006fd8:	cf 21       	brne	80006fbc <PrintHex+0x1c>
80006fda:	c0 48       	rjmp	80006fe2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006fdc:	33 08       	mov	r8,48
80006fde:	ba 88       	st.b	sp[0x0],r8
80006fe0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006fe2:	f6 09 01 08 	sub	r8,r11,r9
80006fe6:	58 08       	cp.w	r8,0
80006fe8:	e0 8a 00 13 	brle	8000700e <PrintHex+0x6e>
	{
		char num = len - cnt;
80006fec:	12 1b       	sub	r11,r9
80006fee:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006ff2:	18 9e       	mov	lr,r12
80006ff4:	58 0c       	cp.w	r12,0
80006ff6:	e0 8a 00 0c 	brle	8000700e <PrintHex+0x6e>
80006ffa:	1a 9b       	mov	r11,sp
80006ffc:	12 0b       	add	r11,r9
80006ffe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007000:	33 07       	mov	r7,48
80007002:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007004:	2f f8       	sub	r8,-1
80007006:	1c 38       	cp.w	r8,lr
80007008:	cf d5       	brlt	80007002 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000700a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000700e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007012:	f0 cb ff ff 	sub	r11,r8,-1
80007016:	58 0b       	cp.w	r11,0
80007018:	e0 8a 00 19 	brle	8000704a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000701c:	fa cb ff f4 	sub	r11,sp,-12
80007020:	f6 09 00 09 	add	r9,r11,r9
80007024:	37 8b       	mov	r11,120
80007026:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000702a:	fa c9 ff f4 	sub	r9,sp,-12
8000702e:	10 09       	add	r9,r8
80007030:	33 0b       	mov	r11,48
80007032:	f3 6b ff f4 	st.b	r9[-12],r11
80007036:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000703a:	fa ce 00 01 	sub	lr,sp,1
8000703e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007040:	11 8b       	ld.ub	r11,r8[0x0]
80007042:	12 cb       	st.b	r9++,r11
80007044:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007046:	1c 38       	cp.w	r8,lr
80007048:	cf c1       	brne	80007040 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000704a:	14 9c       	mov	r12,r10
8000704c:	2f dd       	sub	sp,-12
8000704e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007052 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007052:	d4 21       	pushm	r4-r7,lr
80007054:	20 3d       	sub	sp,12
80007056:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007058:	30 06       	mov	r6,0
8000705a:	30 07       	mov	r7,0
8000705c:	fa e7 00 00 	st.d	sp[0],r6
80007060:	30 0c       	mov	r12,0
80007062:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007064:	58 08       	cp.w	r8,0
80007066:	c0 35       	brlt	8000706c <PrintDec+0x1a>
80007068:	14 97       	mov	r7,r10
8000706a:	c0 58       	rjmp	80007074 <PrintDec+0x22>
	{
		*p++ = '-';
8000706c:	14 97       	mov	r7,r10
8000706e:	32 d9       	mov	r9,45
80007070:	0e c9       	st.b	r7++,r9
		i = -i;
80007072:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007074:	58 08       	cp.w	r8,0
80007076:	c0 51       	brne	80007080 <PrintDec+0x2e>
80007078:	33 08       	mov	r8,48
8000707a:	ba 88       	st.b	sp[0x0],r8
8000707c:	30 1e       	mov	lr,1
8000707e:	c2 f8       	rjmp	800070dc <PrintDec+0x8a>
	
	int ten = i%10;
80007080:	e0 65 66 67 	mov	r5,26215
80007084:	ea 15 66 66 	orh	r5,0x6666
80007088:	f0 05 04 44 	muls.d	r4,r8,r5
8000708c:	ea 0c 14 02 	asr	r12,r5,0x2
80007090:	f0 09 14 1f 	asr	r9,r8,0x1f
80007094:	f8 09 01 09 	sub	r9,r12,r9
80007098:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000709c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800070a0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800070a2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800070a4:	e0 66 66 67 	mov	r6,26215
800070a8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800070ac:	2d 09       	sub	r9,-48
800070ae:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800070b2:	2f fe       	sub	lr,-1
		i /= 10;
800070b4:	f0 06 04 44 	muls.d	r4,r8,r6
800070b8:	ea 09 14 02 	asr	r9,r5,0x2
800070bc:	bf 58       	asr	r8,0x1f
800070be:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800070c2:	f0 06 04 44 	muls.d	r4,r8,r6
800070c6:	ea 09 14 02 	asr	r9,r5,0x2
800070ca:	f0 05 14 1f 	asr	r5,r8,0x1f
800070ce:	0a 19       	sub	r9,r5
800070d0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800070d4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800070d8:	58 08       	cp.w	r8,0
800070da:	ce 91       	brne	800070ac <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800070dc:	f6 0e 01 08 	sub	r8,r11,lr
800070e0:	58 08       	cp.w	r8,0
800070e2:	e0 89 00 06 	brgt	800070ee <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800070e6:	58 0e       	cp.w	lr,0
800070e8:	e0 89 00 14 	brgt	80007110 <PrintDec+0xbe>
800070ec:	c1 d8       	rjmp	80007126 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800070ee:	1c 1b       	sub	r11,lr
800070f0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800070f2:	16 9c       	mov	r12,r11
800070f4:	58 0b       	cp.w	r11,0
800070f6:	fe 9a ff f8 	brle	800070e6 <PrintDec+0x94>
800070fa:	1a 99       	mov	r9,sp
800070fc:	1c 09       	add	r9,lr
800070fe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007100:	33 06       	mov	r6,48
80007102:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007104:	2f f8       	sub	r8,-1
80007106:	18 38       	cp.w	r8,r12
80007108:	cf d5       	brlt	80007102 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000710a:	f6 0e 00 0e 	add	lr,r11,lr
8000710e:	ce cb       	rjmp	800070e6 <PrintDec+0x94>
80007110:	fa c8 ff f4 	sub	r8,sp,-12
80007114:	1c 08       	add	r8,lr
80007116:	20 d8       	sub	r8,13
80007118:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
8000711c:	11 89       	ld.ub	r9,r8[0x0]
8000711e:	0e c9       	st.b	r7++,r9
80007120:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007122:	16 38       	cp.w	r8,r11
80007124:	cf c1       	brne	8000711c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007126:	14 9c       	mov	r12,r10
80007128:	2f dd       	sub	sp,-12
8000712a:	d8 22       	popm	r4-r7,pc

8000712c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
8000712c:	d4 31       	pushm	r0-r7,lr
8000712e:	fa cd 02 08 	sub	sp,sp,520
80007132:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007134:	e0 6a 01 00 	mov	r10,256
80007138:	30 0b       	mov	r11,0
8000713a:	fa cc fe f8 	sub	r12,sp,-264
8000713e:	f0 1f 00 4e 	mcall	80007274 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007142:	fa c4 fd d4 	sub	r4,sp,-556
80007146:	30 0a       	mov	r10,0
80007148:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000714a:	fa c3 ff fc 	sub	r3,sp,-4
8000714e:	e0 61 01 00 	mov	r1,256
80007152:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007154:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007156:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000715a:	02 9a       	mov	r10,r1
8000715c:	00 9b       	mov	r11,r0
8000715e:	06 9c       	mov	r12,r3
80007160:	f0 1f 00 45 	mcall	80007274 <log+0x148>
			
					if(*str == '%')
80007164:	0f 88       	ld.ub	r8,r7[0x0]
80007166:	e4 08 18 00 	cp.b	r8,r2
8000716a:	c5 71       	brne	80007218 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
8000716c:	ee c8 ff ff 	sub	r8,r7,-1
80007170:	11 89       	ld.ub	r9,r8[0x0]
80007172:	4c 2a       	lddpc	r10,80007278 <log+0x14c>
80007174:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007176:	23 09       	sub	r9,48
80007178:	30 9a       	mov	r10,9
8000717a:	f4 09 18 00 	cp.b	r9,r10
8000717e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007182:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007186:	f7 b9 08 30 	subls	r9,48
8000718a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000718e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007192:	0f 88       	ld.ub	r8,r7[0x0]
80007194:	22 58       	sub	r8,37
80007196:	e0 48 00 53 	cp.w	r8,83
8000719a:	e0 8b 00 31 	brhi	800071fc <log+0xd0>
8000719e:	4b 89       	lddpc	r9,8000727c <log+0x150>
800071a0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800071a4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800071a8:	06 9a       	mov	r10,r3
800071aa:	40 0b       	lddsp	r11,sp[0x0]
800071ac:	5c 5b       	castu.b	r11
800071ae:	68 0c       	ld.w	r12,r4[0x0]
800071b0:	f0 1f 00 34 	mcall	80007280 <log+0x154>
							break;
800071b4:	c2 98       	rjmp	80007206 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800071b6:	4b 4c       	lddpc	r12,80007284 <log+0x158>
800071b8:	f0 1f 00 34 	mcall	80007288 <log+0x15c>
800071bc:	08 95       	mov	r5,r4
800071be:	06 9c       	mov	r12,r3
							break;
800071c0:	c2 38       	rjmp	80007206 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800071c2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800071c6:	06 9a       	mov	r10,r3
800071c8:	40 0b       	lddsp	r11,sp[0x0]
800071ca:	5c 5b       	castu.b	r11
800071cc:	68 0c       	ld.w	r12,r4[0x0]
800071ce:	f0 1f 00 30 	mcall	8000728c <log+0x160>
800071d2:	06 9c       	mov	r12,r3
							break;
800071d4:	c1 98       	rjmp	80007206 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800071d6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800071da:	06 9b       	mov	r11,r3
800071dc:	09 bc       	ld.ub	r12,r4[0x3]
800071de:	f0 1f 00 2d 	mcall	80007290 <log+0x164>
800071e2:	06 9c       	mov	r12,r3
							break;
800071e4:	c1 18       	rjmp	80007206 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800071e6:	e8 c5 ff fc 	sub	r5,r4,-4
800071ea:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800071ec:	c0 d8       	rjmp	80007206 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800071ee:	06 9b       	mov	r11,r3
800071f0:	32 5c       	mov	r12,37
800071f2:	f0 1f 00 28 	mcall	80007290 <log+0x164>
800071f6:	08 95       	mov	r5,r4
800071f8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800071fa:	c0 68       	rjmp	80007206 <log+0xda>
							
							default:
							log("I need relax.");
800071fc:	4a 6c       	lddpc	r12,80007294 <log+0x168>
800071fe:	f0 1f 00 23 	mcall	80007288 <log+0x15c>
80007202:	08 95       	mov	r5,r4
80007204:	06 9c       	mov	r12,r3
						}
						str++;
80007206:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007208:	1a dc       	st.w	--sp,r12
8000720a:	1a d6       	st.w	--sp,r6
8000720c:	4a 3b       	lddpc	r11,80007298 <log+0x16c>
8000720e:	0c 9c       	mov	r12,r6
80007210:	f0 1f 00 23 	mcall	8000729c <log+0x170>
80007214:	2f ed       	sub	sp,-8
80007216:	c0 a8       	rjmp	8000722a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007218:	2f f7       	sub	r7,-1
8000721a:	1a d8       	st.w	--sp,r8
8000721c:	1a d6       	st.w	--sp,r6
8000721e:	4a 1b       	lddpc	r11,800072a0 <log+0x174>
80007220:	0c 9c       	mov	r12,r6
80007222:	f0 1f 00 1f 	mcall	8000729c <log+0x170>
80007226:	08 95       	mov	r5,r4
80007228:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000722a:	0f 89       	ld.ub	r9,r7[0x0]
8000722c:	30 08       	mov	r8,0
8000722e:	f0 09 18 00 	cp.b	r9,r8
80007232:	c0 30       	breq	80007238 <log+0x10c>
80007234:	0a 94       	mov	r4,r5
80007236:	c9 2b       	rjmp	8000715a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007238:	fa c7 fe f8 	sub	r7,sp,-264
8000723c:	1a d7       	st.w	--sp,r7
8000723e:	49 ab       	lddpc	r11,800072a4 <log+0x178>
80007240:	0e 9c       	mov	r12,r7
80007242:	f0 1f 00 17 	mcall	8000729c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007246:	5c 5c       	castu.b	r12
80007248:	f8 c6 ff ff 	sub	r6,r12,-1
8000724c:	0c 9c       	mov	r12,r6
8000724e:	f0 1f 00 17 	mcall	800072a8 <log+0x17c>
80007252:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007254:	0c 9a       	mov	r10,r6
80007256:	0e 9b       	mov	r11,r7
80007258:	f0 1f 00 15 	mcall	800072ac <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000725c:	30 09       	mov	r9,0
8000725e:	30 5a       	mov	r10,5
80007260:	fa cb fe f8 	sub	r11,sp,-264
80007264:	49 38       	lddpc	r8,800072b0 <log+0x184>
80007266:	70 0c       	ld.w	r12,r8[0x0]
80007268:	f0 1f 00 13 	mcall	800072b4 <log+0x188>
8000726c:	2f fd       	sub	sp,-4
	
	
}
8000726e:	fe 3d fd f8 	sub	sp,-520
80007272:	d8 32       	popm	r0-r7,pc
80007274:	80 00       	ld.sh	r0,r0[0x0]
80007276:	7b 1a       	ld.w	r10,sp[0x44]
80007278:	00 00       	add	r0,r0
8000727a:	0d b0       	ld.ub	r0,r6[0x3]
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	db a0       	acall	0xba
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	70 52       	ld.w	r2,r8[0x14]
80007284:	80 00       	ld.sh	r0,r0[0x0]
80007286:	de 4c       	*unknown*
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	71 2c       	ld.w	r12,r8[0x48]
8000728c:	80 00       	ld.sh	r0,r0[0x0]
8000728e:	6f a0       	ld.w	r0,r7[0x68]
80007290:	80 00       	ld.sh	r0,r0[0x0]
80007292:	6f 9c       	ld.w	r12,r7[0x64]
80007294:	80 00       	ld.sh	r0,r0[0x0]
80007296:	de 5c       	*unknown*
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	de 6c       	*unknown*
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	7e 08       	ld.w	r8,pc[0x0]
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	de 74       	*unknown*
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	de 7c       	*unknown*
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	61 f8       	ld.w	r8,r0[0x7c]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	79 d2       	ld.w	r2,r12[0x74]
800072b0:	00 00       	add	r0,r0
800072b2:	51 90       	stdsp	sp[0x64],r0
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	65 4c       	ld.w	r12,r2[0x50]

800072b8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800072b8:	d4 31       	pushm	r0-r7,lr
800072ba:	fa cd 02 0c 	sub	sp,sp,524
800072be:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800072c0:	e0 6a 01 00 	mov	r10,256
800072c4:	30 0b       	mov	r11,0
800072c6:	fa cc fe f4 	sub	r12,sp,-268
800072ca:	f0 1f 00 4c 	mcall	800073f8 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800072ce:	fa c4 fd d0 	sub	r4,sp,-560
800072d2:	30 0a       	mov	r10,0
800072d4:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072d6:	fa c3 ff fc 	sub	r3,sp,-4
800072da:	e0 61 01 00 	mov	r1,256
800072de:	14 90       	mov	r0,r10
			
			if(*str == '%')
800072e0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072e2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072e6:	02 9a       	mov	r10,r1
800072e8:	00 9b       	mov	r11,r0
800072ea:	06 9c       	mov	r12,r3
800072ec:	f0 1f 00 43 	mcall	800073f8 <logFromISR+0x140>
			
			if(*str == '%')
800072f0:	0f 88       	ld.ub	r8,r7[0x0]
800072f2:	e4 08 18 00 	cp.b	r8,r2
800072f6:	c5 11       	brne	80007398 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800072f8:	ee c8 ff ff 	sub	r8,r7,-1
800072fc:	11 89       	ld.ub	r9,r8[0x0]
800072fe:	4c 0a       	lddpc	r10,800073fc <logFromISR+0x144>
80007300:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007302:	23 09       	sub	r9,48
80007304:	30 9a       	mov	r10,9
80007306:	f4 09 18 00 	cp.b	r9,r10
8000730a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000730e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007312:	f7 b9 08 30 	subls	r9,48
80007316:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000731a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000731e:	0f 88       	ld.ub	r8,r7[0x0]
80007320:	22 58       	sub	r8,37
80007322:	e0 48 00 53 	cp.w	r8,83
80007326:	e0 8b 00 2b 	brhi	8000737c <logFromISR+0xc4>
8000732a:	4b 69       	lddpc	r9,80007400 <logFromISR+0x148>
8000732c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007330:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007334:	06 9a       	mov	r10,r3
80007336:	40 0b       	lddsp	r11,sp[0x0]
80007338:	5c 5b       	castu.b	r11
8000733a:	68 0c       	ld.w	r12,r4[0x0]
8000733c:	f0 1f 00 32 	mcall	80007404 <logFromISR+0x14c>
					break;
80007340:	c2 38       	rjmp	80007386 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007342:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007346:	06 9a       	mov	r10,r3
80007348:	40 0b       	lddsp	r11,sp[0x0]
8000734a:	5c 5b       	castu.b	r11
8000734c:	68 0c       	ld.w	r12,r4[0x0]
8000734e:	f0 1f 00 2f 	mcall	80007408 <logFromISR+0x150>
80007352:	06 9c       	mov	r12,r3
					break;
80007354:	c1 98       	rjmp	80007386 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007356:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000735a:	06 9b       	mov	r11,r3
8000735c:	09 bc       	ld.ub	r12,r4[0x3]
8000735e:	f0 1f 00 2c 	mcall	8000740c <logFromISR+0x154>
80007362:	06 9c       	mov	r12,r3
					break;
80007364:	c1 18       	rjmp	80007386 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007366:	e8 c5 ff fc 	sub	r5,r4,-4
8000736a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000736c:	c0 d8       	rjmp	80007386 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000736e:	06 9b       	mov	r11,r3
80007370:	32 5c       	mov	r12,37
80007372:	f0 1f 00 27 	mcall	8000740c <logFromISR+0x154>
80007376:	08 95       	mov	r5,r4
80007378:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000737a:	c0 68       	rjmp	80007386 <logFromISR+0xce>
					default:
					log("I need relax.");
8000737c:	4a 5c       	lddpc	r12,80007410 <logFromISR+0x158>
8000737e:	f0 1f 00 26 	mcall	80007414 <logFromISR+0x15c>
80007382:	08 95       	mov	r5,r4
80007384:	06 9c       	mov	r12,r3
				}
				str++;
80007386:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007388:	1a dc       	st.w	--sp,r12
8000738a:	1a d6       	st.w	--sp,r6
8000738c:	4a 3b       	lddpc	r11,80007418 <logFromISR+0x160>
8000738e:	0c 9c       	mov	r12,r6
80007390:	f0 1f 00 23 	mcall	8000741c <logFromISR+0x164>
80007394:	2f ed       	sub	sp,-8
80007396:	c0 a8       	rjmp	800073aa <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007398:	2f f7       	sub	r7,-1
8000739a:	1a d8       	st.w	--sp,r8
8000739c:	1a d6       	st.w	--sp,r6
8000739e:	4a 1b       	lddpc	r11,80007420 <logFromISR+0x168>
800073a0:	0c 9c       	mov	r12,r6
800073a2:	f0 1f 00 1f 	mcall	8000741c <logFromISR+0x164>
800073a6:	08 95       	mov	r5,r4
800073a8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800073aa:	0f 89       	ld.ub	r9,r7[0x0]
800073ac:	30 08       	mov	r8,0
800073ae:	f0 09 18 00 	cp.b	r9,r8
800073b2:	c0 30       	breq	800073b8 <logFromISR+0x100>
800073b4:	0a 94       	mov	r4,r5
800073b6:	c9 8b       	rjmp	800072e6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800073b8:	fa c7 fe f4 	sub	r7,sp,-268
800073bc:	1a d7       	st.w	--sp,r7
800073be:	49 ab       	lddpc	r11,80007424 <logFromISR+0x16c>
800073c0:	0e 9c       	mov	r12,r7
800073c2:	f0 1f 00 17 	mcall	8000741c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800073c6:	5c 5c       	castu.b	r12
800073c8:	f8 c6 ff ff 	sub	r6,r12,-1
800073cc:	0c 9c       	mov	r12,r6
800073ce:	f0 1f 00 17 	mcall	80007428 <logFromISR+0x170>
800073d2:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800073d4:	0c 9a       	mov	r10,r6
800073d6:	0e 9b       	mov	r11,r7
800073d8:	f0 1f 00 15 	mcall	8000742c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800073dc:	30 09       	mov	r9,0
800073de:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800073e0:	fa ca fe f8 	sub	r10,sp,-264
800073e4:	fa cb fe f4 	sub	r11,sp,-268
800073e8:	49 28       	lddpc	r8,80007430 <logFromISR+0x178>
800073ea:	70 0c       	ld.w	r12,r8[0x0]
800073ec:	f0 1f 00 12 	mcall	80007434 <logFromISR+0x17c>
800073f0:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800073f2:	fe 3d fd f4 	sub	sp,-524
800073f6:	d8 32       	popm	r0-r7,pc
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	7b 1a       	ld.w	r10,sp[0x44]
800073fc:	00 00       	add	r0,r0
800073fe:	0d b1       	ld.ub	r1,r6[0x3]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	dc f0       	acall	0xcf
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	70 52       	ld.w	r2,r8[0x14]
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	6f a0       	ld.w	r0,r7[0x68]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	6f 9c       	ld.w	r12,r7[0x64]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	de 5c       	*unknown*
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	71 2c       	ld.w	r12,r8[0x48]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	de 6c       	*unknown*
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	7e 08       	ld.w	r8,pc[0x0]
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	de 74       	*unknown*
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	de 7c       	*unknown*
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	61 f8       	ld.w	r8,r0[0x7c]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	79 d2       	ld.w	r2,r12[0x74]
80007430:	00 00       	add	r0,r0
80007432:	51 90       	stdsp	sp[0x64],r0
80007434:	80 00       	ld.sh	r0,r0[0x0]
80007436:	64 fc       	ld.w	r12,r2[0x3c]

80007438 <log_init>:
		
	return str;
}

void log_init(void)
{
80007438:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000743a:	30 2b       	mov	r11,2
8000743c:	49 0c       	lddpc	r12,8000747c <log_init+0x44>
8000743e:	f0 1f 00 11 	mcall	80007480 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007442:	e0 6a 36 00 	mov	r10,13824
80007446:	ea 1a 01 6e 	orh	r10,0x16e
8000744a:	48 fb       	lddpc	r11,80007484 <log_init+0x4c>
8000744c:	fe 7c 18 00 	mov	r12,-59392
80007450:	f0 1f 00 0e 	mcall	80007488 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007454:	30 4b       	mov	r11,4
80007456:	33 2c       	mov	r12,50
80007458:	f0 1f 00 0d 	mcall	8000748c <log_init+0x54>
8000745c:	48 d8       	lddpc	r8,80007490 <log_init+0x58>
8000745e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007460:	30 09       	mov	r9,0
80007462:	1a d9       	st.w	--sp,r9
80007464:	1a d9       	st.w	--sp,r9
80007466:	1a d9       	st.w	--sp,r9
80007468:	30 28       	mov	r8,2
8000746a:	e0 6a 01 80 	mov	r10,384
8000746e:	48 ab       	lddpc	r11,80007494 <log_init+0x5c>
80007470:	48 ac       	lddpc	r12,80007498 <log_init+0x60>
80007472:	f0 1f 00 0b 	mcall	8000749c <log_init+0x64>
80007476:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007478:	d8 02       	popm	pc
8000747a:	00 00       	add	r0,r0
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	de 88       	*unknown*
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	58 28       	cp.w	r8,2
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	de 40       	acall	0xe4
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	5d 5c       	*unknown*
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	66 4c       	ld.w	r12,r3[0x10]
80007490:	00 00       	add	r0,r0
80007492:	51 90       	stdsp	sp[0x64],r0
80007494:	80 00       	ld.sh	r0,r0[0x0]
80007496:	de 84       	*unknown*
80007498:	80 00       	ld.sh	r0,r0[0x0]
8000749a:	74 a0       	ld.w	r0,r10[0x28]
8000749c:	80 00       	ld.sh	r0,r0[0x0]
8000749e:	6d 68       	ld.w	r8,r6[0x58]

800074a0 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800074a0:	eb cd 40 f8 	pushm	r3-r7,lr
800074a4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800074a6:	48 c7       	lddpc	r7,800074d4 <task_log+0x34>
800074a8:	30 05       	mov	r5,0
800074aa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800074ac:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800074b0:	0a 99       	mov	r9,r5
800074b2:	08 9a       	mov	r10,r4
800074b4:	1a 9b       	mov	r11,sp
800074b6:	6e 0c       	ld.w	r12,r7[0x0]
800074b8:	f0 1f 00 08 	mcall	800074d8 <task_log+0x38>
800074bc:	58 1c       	cp.w	r12,1
800074be:	cf 91       	brne	800074b0 <task_log+0x10>
		{
			if( NULL != str)
800074c0:	40 0b       	lddsp	r11,sp[0x0]
800074c2:	58 0b       	cp.w	r11,0
800074c4:	cf 60       	breq	800074b0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800074c6:	06 9c       	mov	r12,r3
800074c8:	f0 1f 00 05 	mcall	800074dc <task_log+0x3c>
				vPortFree(str);
800074cc:	40 0c       	lddsp	r12,sp[0x0]
800074ce:	f0 1f 00 05 	mcall	800074e0 <task_log+0x40>
800074d2:	ce fb       	rjmp	800074b0 <task_log+0x10>
800074d4:	00 00       	add	r0,r0
800074d6:	51 90       	stdsp	sp[0x64],r0
800074d8:	80 00       	ld.sh	r0,r0[0x0]
800074da:	63 40       	ld.w	r0,r1[0x50]
800074dc:	80 00       	ld.sh	r0,r0[0x0]
800074de:	5d 0c       	ror	r12
800074e0:	80 00       	ld.sh	r0,r0[0x0]
800074e2:	61 d0       	ld.w	r0,r0[0x74]

800074e4 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800074e4:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800074e6:	fe 78 10 00 	mov	r8,-61440
800074ea:	30 19       	mov	r9,1
800074ec:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800074f0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800074f4:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800074f8:	d3 03       	ssrf	0x10
	local_start_pll0();
800074fa:	f0 1f 00 0c 	mcall	80007528 <main+0x44>
		
	INTC_init_interrupts();
800074fe:	f0 1f 00 0c 	mcall	8000752c <main+0x48>
		
	log_init();
80007502:	f0 1f 00 0c 	mcall	80007530 <main+0x4c>
	log("----start debug----");
80007506:	48 cc       	lddpc	r12,80007534 <main+0x50>
80007508:	f0 1f 00 0c 	mcall	80007538 <main+0x54>
	
	xg_flashc_init();
8000750c:	f0 1f 00 0c 	mcall	8000753c <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007510:	f0 1f 00 0c 	mcall	80007540 <main+0x5c>
		
	app_init();
80007514:	f0 1f 00 0c 	mcall	80007544 <main+0x60>
		
	xcmp_init();
80007518:	f0 1f 00 0c 	mcall	80007548 <main+0x64>

	local_start_timer();
8000751c:	f0 1f 00 0c 	mcall	8000754c <main+0x68>
	
	//xg_rtc_init();
		
	vTaskStartScheduler();
80007520:	f0 1f 00 0c 	mcall	80007550 <main+0x6c>
	return 0;
	
}
80007524:	d8 0a       	popm	pc,r12=0
80007526:	00 00       	add	r0,r0
80007528:	80 00       	ld.sh	r0,r0[0x0]
8000752a:	4f cc       	lddpc	r12,80007718 <_malloc_r+0x1a4>
8000752c:	80 00       	ld.sh	r0,r0[0x0]
8000752e:	59 2c       	cp.w	r12,18
80007530:	80 00       	ld.sh	r0,r0[0x0]
80007532:	74 38       	ld.w	r8,r10[0xc]
80007534:	80 00       	ld.sh	r0,r0[0x0]
80007536:	de 98       	*unknown*
80007538:	80 00       	ld.sh	r0,r0[0x0]
8000753a:	71 2c       	ld.w	r12,r8[0x48]
8000753c:	80 00       	ld.sh	r0,r0[0x0]
8000753e:	50 b0       	stdsp	sp[0x2c],r0
80007540:	80 00       	ld.sh	r0,r0[0x0]
80007542:	4f c0       	lddpc	r0,80007730 <_malloc_r+0x1bc>
80007544:	80 00       	ld.sh	r0,r0[0x0]
80007546:	20 3c       	sub	r12,3
80007548:	80 00       	ld.sh	r0,r0[0x0]
8000754a:	3e e4       	mov	r4,-18
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	50 84       	stdsp	sp[0x20],r4
80007550:	80 00       	ld.sh	r0,r0[0x0]
80007552:	6f 50       	ld.w	r0,r7[0x54]

80007554 <free>:
80007554:	d4 01       	pushm	lr
80007556:	e0 68 0a 48 	mov	r8,2632
8000755a:	18 9b       	mov	r11,r12
8000755c:	70 0c       	ld.w	r12,r8[0x0]
8000755e:	e0 a0 1e 73 	rcall	8000b244 <_free_r>
80007562:	d8 02       	popm	pc

80007564 <malloc>:
80007564:	d4 01       	pushm	lr
80007566:	e0 68 0a 48 	mov	r8,2632
8000756a:	18 9b       	mov	r11,r12
8000756c:	70 0c       	ld.w	r12,r8[0x0]
8000756e:	c0 3c       	rcall	80007574 <_malloc_r>
80007570:	d8 02       	popm	pc
80007572:	d7 03       	nop

80007574 <_malloc_r>:
80007574:	d4 31       	pushm	r0-r7,lr
80007576:	f6 c8 ff f5 	sub	r8,r11,-11
8000757a:	18 95       	mov	r5,r12
8000757c:	10 97       	mov	r7,r8
8000757e:	e0 17 ff f8 	andl	r7,0xfff8
80007582:	59 68       	cp.w	r8,22
80007584:	f9 b7 08 10 	movls	r7,16
80007588:	16 37       	cp.w	r7,r11
8000758a:	5f 38       	srlo	r8
8000758c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007590:	c0 50       	breq	8000759a <_malloc_r+0x26>
80007592:	30 c8       	mov	r8,12
80007594:	99 38       	st.w	r12[0xc],r8
80007596:	e0 8f 01 fa 	bral	8000798a <_malloc_r+0x416>
8000759a:	fe b0 f5 d1 	rcall	8000613c <__malloc_lock>
8000759e:	e0 47 01 f7 	cp.w	r7,503
800075a2:	e0 8b 00 1d 	brhi	800075dc <_malloc_r+0x68>
800075a6:	ee 03 16 03 	lsr	r3,r7,0x3
800075aa:	e0 68 05 48 	mov	r8,1352
800075ae:	f0 03 00 38 	add	r8,r8,r3<<0x3
800075b2:	70 36       	ld.w	r6,r8[0xc]
800075b4:	10 36       	cp.w	r6,r8
800075b6:	c0 61       	brne	800075c2 <_malloc_r+0x4e>
800075b8:	ec c8 ff f8 	sub	r8,r6,-8
800075bc:	70 36       	ld.w	r6,r8[0xc]
800075be:	10 36       	cp.w	r6,r8
800075c0:	c0 c0       	breq	800075d8 <_malloc_r+0x64>
800075c2:	6c 18       	ld.w	r8,r6[0x4]
800075c4:	e0 18 ff fc 	andl	r8,0xfffc
800075c8:	6c 3a       	ld.w	r10,r6[0xc]
800075ca:	ec 08 00 09 	add	r9,r6,r8
800075ce:	0a 9c       	mov	r12,r5
800075d0:	6c 28       	ld.w	r8,r6[0x8]
800075d2:	95 28       	st.w	r10[0x8],r8
800075d4:	91 3a       	st.w	r8[0xc],r10
800075d6:	c4 78       	rjmp	80007664 <_malloc_r+0xf0>
800075d8:	2f e3       	sub	r3,-2
800075da:	c4 d8       	rjmp	80007674 <_malloc_r+0x100>
800075dc:	ee 03 16 09 	lsr	r3,r7,0x9
800075e0:	c0 41       	brne	800075e8 <_malloc_r+0x74>
800075e2:	ee 03 16 03 	lsr	r3,r7,0x3
800075e6:	c2 68       	rjmp	80007632 <_malloc_r+0xbe>
800075e8:	58 43       	cp.w	r3,4
800075ea:	e0 8b 00 06 	brhi	800075f6 <_malloc_r+0x82>
800075ee:	ee 03 16 06 	lsr	r3,r7,0x6
800075f2:	2c 83       	sub	r3,-56
800075f4:	c1 f8       	rjmp	80007632 <_malloc_r+0xbe>
800075f6:	59 43       	cp.w	r3,20
800075f8:	e0 8b 00 04 	brhi	80007600 <_malloc_r+0x8c>
800075fc:	2a 53       	sub	r3,-91
800075fe:	c1 a8       	rjmp	80007632 <_malloc_r+0xbe>
80007600:	e0 43 00 54 	cp.w	r3,84
80007604:	e0 8b 00 06 	brhi	80007610 <_malloc_r+0x9c>
80007608:	ee 03 16 0c 	lsr	r3,r7,0xc
8000760c:	29 23       	sub	r3,-110
8000760e:	c1 28       	rjmp	80007632 <_malloc_r+0xbe>
80007610:	e0 43 01 54 	cp.w	r3,340
80007614:	e0 8b 00 06 	brhi	80007620 <_malloc_r+0xac>
80007618:	ee 03 16 0f 	lsr	r3,r7,0xf
8000761c:	28 93       	sub	r3,-119
8000761e:	c0 a8       	rjmp	80007632 <_malloc_r+0xbe>
80007620:	e0 43 05 54 	cp.w	r3,1364
80007624:	e0 88 00 04 	brls	8000762c <_malloc_r+0xb8>
80007628:	37 e3       	mov	r3,126
8000762a:	c0 48       	rjmp	80007632 <_malloc_r+0xbe>
8000762c:	ee 03 16 12 	lsr	r3,r7,0x12
80007630:	28 43       	sub	r3,-124
80007632:	e0 6a 05 48 	mov	r10,1352
80007636:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000763a:	74 36       	ld.w	r6,r10[0xc]
8000763c:	c1 98       	rjmp	8000766e <_malloc_r+0xfa>
8000763e:	6c 19       	ld.w	r9,r6[0x4]
80007640:	e0 19 ff fc 	andl	r9,0xfffc
80007644:	f2 07 01 0b 	sub	r11,r9,r7
80007648:	58 fb       	cp.w	r11,15
8000764a:	e0 8a 00 04 	brle	80007652 <_malloc_r+0xde>
8000764e:	20 13       	sub	r3,1
80007650:	c1 18       	rjmp	80007672 <_malloc_r+0xfe>
80007652:	6c 38       	ld.w	r8,r6[0xc]
80007654:	58 0b       	cp.w	r11,0
80007656:	c0 b5       	brlt	8000766c <_malloc_r+0xf8>
80007658:	6c 2a       	ld.w	r10,r6[0x8]
8000765a:	ec 09 00 09 	add	r9,r6,r9
8000765e:	0a 9c       	mov	r12,r5
80007660:	91 2a       	st.w	r8[0x8],r10
80007662:	95 38       	st.w	r10[0xc],r8
80007664:	72 18       	ld.w	r8,r9[0x4]
80007666:	a1 a8       	sbr	r8,0x0
80007668:	93 18       	st.w	r9[0x4],r8
8000766a:	cb c8       	rjmp	800077e2 <_malloc_r+0x26e>
8000766c:	10 96       	mov	r6,r8
8000766e:	14 36       	cp.w	r6,r10
80007670:	ce 71       	brne	8000763e <_malloc_r+0xca>
80007672:	2f f3       	sub	r3,-1
80007674:	e0 6a 05 48 	mov	r10,1352
80007678:	f4 cc ff f8 	sub	r12,r10,-8
8000767c:	78 26       	ld.w	r6,r12[0x8]
8000767e:	18 36       	cp.w	r6,r12
80007680:	c6 c0       	breq	80007758 <_malloc_r+0x1e4>
80007682:	6c 19       	ld.w	r9,r6[0x4]
80007684:	e0 19 ff fc 	andl	r9,0xfffc
80007688:	f2 07 01 08 	sub	r8,r9,r7
8000768c:	58 f8       	cp.w	r8,15
8000768e:	e0 89 00 8f 	brgt	800077ac <_malloc_r+0x238>
80007692:	99 3c       	st.w	r12[0xc],r12
80007694:	99 2c       	st.w	r12[0x8],r12
80007696:	58 08       	cp.w	r8,0
80007698:	c0 55       	brlt	800076a2 <_malloc_r+0x12e>
8000769a:	ec 09 00 09 	add	r9,r6,r9
8000769e:	0a 9c       	mov	r12,r5
800076a0:	ce 2b       	rjmp	80007664 <_malloc_r+0xf0>
800076a2:	e0 49 01 ff 	cp.w	r9,511
800076a6:	e0 8b 00 13 	brhi	800076cc <_malloc_r+0x158>
800076aa:	a3 99       	lsr	r9,0x3
800076ac:	f4 09 00 38 	add	r8,r10,r9<<0x3
800076b0:	70 2b       	ld.w	r11,r8[0x8]
800076b2:	8d 38       	st.w	r6[0xc],r8
800076b4:	8d 2b       	st.w	r6[0x8],r11
800076b6:	97 36       	st.w	r11[0xc],r6
800076b8:	91 26       	st.w	r8[0x8],r6
800076ba:	a3 49       	asr	r9,0x2
800076bc:	74 18       	ld.w	r8,r10[0x4]
800076be:	30 1b       	mov	r11,1
800076c0:	f6 09 09 49 	lsl	r9,r11,r9
800076c4:	f1 e9 10 09 	or	r9,r8,r9
800076c8:	95 19       	st.w	r10[0x4],r9
800076ca:	c4 78       	rjmp	80007758 <_malloc_r+0x1e4>
800076cc:	f2 0a 16 09 	lsr	r10,r9,0x9
800076d0:	58 4a       	cp.w	r10,4
800076d2:	e0 8b 00 07 	brhi	800076e0 <_malloc_r+0x16c>
800076d6:	f2 0a 16 06 	lsr	r10,r9,0x6
800076da:	2c 8a       	sub	r10,-56
800076dc:	c2 08       	rjmp	8000771c <_malloc_r+0x1a8>
800076de:	d7 03       	nop
800076e0:	59 4a       	cp.w	r10,20
800076e2:	e0 8b 00 04 	brhi	800076ea <_malloc_r+0x176>
800076e6:	2a 5a       	sub	r10,-91
800076e8:	c1 a8       	rjmp	8000771c <_malloc_r+0x1a8>
800076ea:	e0 4a 00 54 	cp.w	r10,84
800076ee:	e0 8b 00 06 	brhi	800076fa <_malloc_r+0x186>
800076f2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800076f6:	29 2a       	sub	r10,-110
800076f8:	c1 28       	rjmp	8000771c <_malloc_r+0x1a8>
800076fa:	e0 4a 01 54 	cp.w	r10,340
800076fe:	e0 8b 00 06 	brhi	8000770a <_malloc_r+0x196>
80007702:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007706:	28 9a       	sub	r10,-119
80007708:	c0 a8       	rjmp	8000771c <_malloc_r+0x1a8>
8000770a:	e0 4a 05 54 	cp.w	r10,1364
8000770e:	e0 88 00 04 	brls	80007716 <_malloc_r+0x1a2>
80007712:	37 ea       	mov	r10,126
80007714:	c0 48       	rjmp	8000771c <_malloc_r+0x1a8>
80007716:	f2 0a 16 12 	lsr	r10,r9,0x12
8000771a:	28 4a       	sub	r10,-124
8000771c:	e0 6b 05 48 	mov	r11,1352
80007720:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007724:	68 28       	ld.w	r8,r4[0x8]
80007726:	08 38       	cp.w	r8,r4
80007728:	c0 e1       	brne	80007744 <_malloc_r+0x1d0>
8000772a:	76 19       	ld.w	r9,r11[0x4]
8000772c:	a3 4a       	asr	r10,0x2
8000772e:	30 1e       	mov	lr,1
80007730:	fc 0a 09 4a 	lsl	r10,lr,r10
80007734:	f3 ea 10 0a 	or	r10,r9,r10
80007738:	10 99       	mov	r9,r8
8000773a:	97 1a       	st.w	r11[0x4],r10
8000773c:	c0 a8       	rjmp	80007750 <_malloc_r+0x1dc>
8000773e:	70 28       	ld.w	r8,r8[0x8]
80007740:	08 38       	cp.w	r8,r4
80007742:	c0 60       	breq	8000774e <_malloc_r+0x1da>
80007744:	70 1a       	ld.w	r10,r8[0x4]
80007746:	e0 1a ff fc 	andl	r10,0xfffc
8000774a:	14 39       	cp.w	r9,r10
8000774c:	cf 93       	brcs	8000773e <_malloc_r+0x1ca>
8000774e:	70 39       	ld.w	r9,r8[0xc]
80007750:	8d 39       	st.w	r6[0xc],r9
80007752:	8d 28       	st.w	r6[0x8],r8
80007754:	91 36       	st.w	r8[0xc],r6
80007756:	93 26       	st.w	r9[0x8],r6
80007758:	e6 08 14 02 	asr	r8,r3,0x2
8000775c:	30 1b       	mov	r11,1
8000775e:	e0 64 05 48 	mov	r4,1352
80007762:	f6 08 09 4b 	lsl	r11,r11,r8
80007766:	68 18       	ld.w	r8,r4[0x4]
80007768:	10 3b       	cp.w	r11,r8
8000776a:	e0 8b 00 6b 	brhi	80007840 <_malloc_r+0x2cc>
8000776e:	f7 e8 00 09 	and	r9,r11,r8
80007772:	c0 b1       	brne	80007788 <_malloc_r+0x214>
80007774:	e0 13 ff fc 	andl	r3,0xfffc
80007778:	a1 7b       	lsl	r11,0x1
8000777a:	2f c3       	sub	r3,-4
8000777c:	c0 38       	rjmp	80007782 <_malloc_r+0x20e>
8000777e:	2f c3       	sub	r3,-4
80007780:	a1 7b       	lsl	r11,0x1
80007782:	f7 e8 00 09 	and	r9,r11,r8
80007786:	cf c0       	breq	8000777e <_malloc_r+0x20a>
80007788:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000778c:	06 92       	mov	r2,r3
8000778e:	1c 91       	mov	r1,lr
80007790:	62 36       	ld.w	r6,r1[0xc]
80007792:	c2 e8       	rjmp	800077ee <_malloc_r+0x27a>
80007794:	6c 1a       	ld.w	r10,r6[0x4]
80007796:	e0 1a ff fc 	andl	r10,0xfffc
8000779a:	f4 07 01 08 	sub	r8,r10,r7
8000779e:	58 f8       	cp.w	r8,15
800077a0:	e0 8a 00 15 	brle	800077ca <_malloc_r+0x256>
800077a4:	6c 3a       	ld.w	r10,r6[0xc]
800077a6:	6c 29       	ld.w	r9,r6[0x8]
800077a8:	95 29       	st.w	r10[0x8],r9
800077aa:	93 3a       	st.w	r9[0xc],r10
800077ac:	0e 99       	mov	r9,r7
800077ae:	ec 07 00 07 	add	r7,r6,r7
800077b2:	a1 a9       	sbr	r9,0x0
800077b4:	99 37       	st.w	r12[0xc],r7
800077b6:	99 27       	st.w	r12[0x8],r7
800077b8:	8d 19       	st.w	r6[0x4],r9
800077ba:	ee 08 09 08 	st.w	r7[r8],r8
800077be:	8f 2c       	st.w	r7[0x8],r12
800077c0:	8f 3c       	st.w	r7[0xc],r12
800077c2:	a1 a8       	sbr	r8,0x0
800077c4:	0a 9c       	mov	r12,r5
800077c6:	8f 18       	st.w	r7[0x4],r8
800077c8:	c0 d8       	rjmp	800077e2 <_malloc_r+0x26e>
800077ca:	6c 39       	ld.w	r9,r6[0xc]
800077cc:	58 08       	cp.w	r8,0
800077ce:	c0 f5       	brlt	800077ec <_malloc_r+0x278>
800077d0:	ec 0a 00 0a 	add	r10,r6,r10
800077d4:	74 18       	ld.w	r8,r10[0x4]
800077d6:	a1 a8       	sbr	r8,0x0
800077d8:	0a 9c       	mov	r12,r5
800077da:	95 18       	st.w	r10[0x4],r8
800077dc:	6c 28       	ld.w	r8,r6[0x8]
800077de:	93 28       	st.w	r9[0x8],r8
800077e0:	91 39       	st.w	r8[0xc],r9
800077e2:	fe b0 f4 b3 	rcall	80006148 <__malloc_unlock>
800077e6:	ec cc ff f8 	sub	r12,r6,-8
800077ea:	d8 32       	popm	r0-r7,pc
800077ec:	12 96       	mov	r6,r9
800077ee:	02 36       	cp.w	r6,r1
800077f0:	cd 21       	brne	80007794 <_malloc_r+0x220>
800077f2:	2f f2       	sub	r2,-1
800077f4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800077f8:	c0 30       	breq	800077fe <_malloc_r+0x28a>
800077fa:	2f 81       	sub	r1,-8
800077fc:	cc ab       	rjmp	80007790 <_malloc_r+0x21c>
800077fe:	1c 98       	mov	r8,lr
80007800:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007804:	c0 81       	brne	80007814 <_malloc_r+0x2a0>
80007806:	68 19       	ld.w	r9,r4[0x4]
80007808:	f6 08 11 ff 	rsub	r8,r11,-1
8000780c:	f3 e8 00 08 	and	r8,r9,r8
80007810:	89 18       	st.w	r4[0x4],r8
80007812:	c0 78       	rjmp	80007820 <_malloc_r+0x2ac>
80007814:	f0 c9 00 08 	sub	r9,r8,8
80007818:	20 13       	sub	r3,1
8000781a:	70 08       	ld.w	r8,r8[0x0]
8000781c:	12 38       	cp.w	r8,r9
8000781e:	cf 10       	breq	80007800 <_malloc_r+0x28c>
80007820:	a1 7b       	lsl	r11,0x1
80007822:	68 18       	ld.w	r8,r4[0x4]
80007824:	10 3b       	cp.w	r11,r8
80007826:	e0 8b 00 0d 	brhi	80007840 <_malloc_r+0x2cc>
8000782a:	58 0b       	cp.w	r11,0
8000782c:	c0 a0       	breq	80007840 <_malloc_r+0x2cc>
8000782e:	04 93       	mov	r3,r2
80007830:	c0 38       	rjmp	80007836 <_malloc_r+0x2c2>
80007832:	2f c3       	sub	r3,-4
80007834:	a1 7b       	lsl	r11,0x1
80007836:	f7 e8 00 09 	and	r9,r11,r8
8000783a:	ca 71       	brne	80007788 <_malloc_r+0x214>
8000783c:	cf bb       	rjmp	80007832 <_malloc_r+0x2be>
8000783e:	d7 03       	nop
80007840:	68 23       	ld.w	r3,r4[0x8]
80007842:	66 12       	ld.w	r2,r3[0x4]
80007844:	e0 12 ff fc 	andl	r2,0xfffc
80007848:	0e 32       	cp.w	r2,r7
8000784a:	5f 39       	srlo	r9
8000784c:	e4 07 01 08 	sub	r8,r2,r7
80007850:	58 f8       	cp.w	r8,15
80007852:	5f aa       	srle	r10
80007854:	f5 e9 10 09 	or	r9,r10,r9
80007858:	e0 80 00 9a 	breq	8000798c <_malloc_r+0x418>
8000785c:	e0 68 0d bc 	mov	r8,3516
80007860:	70 01       	ld.w	r1,r8[0x0]
80007862:	e0 68 09 54 	mov	r8,2388
80007866:	2f 01       	sub	r1,-16
80007868:	70 08       	ld.w	r8,r8[0x0]
8000786a:	0e 01       	add	r1,r7
8000786c:	5b f8       	cp.w	r8,-1
8000786e:	c0 40       	breq	80007876 <_malloc_r+0x302>
80007870:	28 11       	sub	r1,-127
80007872:	e0 11 ff 80 	andl	r1,0xff80
80007876:	02 9b       	mov	r11,r1
80007878:	0a 9c       	mov	r12,r5
8000787a:	e0 a0 02 b7 	rcall	80007de8 <_sbrk_r>
8000787e:	18 96       	mov	r6,r12
80007880:	5b fc       	cp.w	r12,-1
80007882:	c7 50       	breq	8000796c <_malloc_r+0x3f8>
80007884:	e6 02 00 08 	add	r8,r3,r2
80007888:	10 3c       	cp.w	r12,r8
8000788a:	c0 32       	brcc	80007890 <_malloc_r+0x31c>
8000788c:	08 33       	cp.w	r3,r4
8000788e:	c6 f1       	brne	8000796c <_malloc_r+0x3f8>
80007890:	e0 6a 0d c0 	mov	r10,3520
80007894:	74 09       	ld.w	r9,r10[0x0]
80007896:	e2 09 00 09 	add	r9,r1,r9
8000789a:	95 09       	st.w	r10[0x0],r9
8000789c:	10 36       	cp.w	r6,r8
8000789e:	c0 a1       	brne	800078b2 <_malloc_r+0x33e>
800078a0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800078a4:	c0 71       	brne	800078b2 <_malloc_r+0x33e>
800078a6:	e2 02 00 02 	add	r2,r1,r2
800078aa:	68 28       	ld.w	r8,r4[0x8]
800078ac:	a1 a2       	sbr	r2,0x0
800078ae:	91 12       	st.w	r8[0x4],r2
800078b0:	c4 f8       	rjmp	8000794e <_malloc_r+0x3da>
800078b2:	e0 6a 09 54 	mov	r10,2388
800078b6:	74 0b       	ld.w	r11,r10[0x0]
800078b8:	5b fb       	cp.w	r11,-1
800078ba:	c0 31       	brne	800078c0 <_malloc_r+0x34c>
800078bc:	95 06       	st.w	r10[0x0],r6
800078be:	c0 78       	rjmp	800078cc <_malloc_r+0x358>
800078c0:	ec 09 00 09 	add	r9,r6,r9
800078c4:	e0 6a 0d c0 	mov	r10,3520
800078c8:	10 19       	sub	r9,r8
800078ca:	95 09       	st.w	r10[0x0],r9
800078cc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800078d0:	f0 09 11 08 	rsub	r9,r8,8
800078d4:	58 08       	cp.w	r8,0
800078d6:	f2 08 17 10 	movne	r8,r9
800078da:	ed d8 e1 06 	addne	r6,r6,r8
800078de:	28 08       	sub	r8,-128
800078e0:	ec 01 00 01 	add	r1,r6,r1
800078e4:	0a 9c       	mov	r12,r5
800078e6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800078ea:	f0 01 01 01 	sub	r1,r8,r1
800078ee:	02 9b       	mov	r11,r1
800078f0:	e0 a0 02 7c 	rcall	80007de8 <_sbrk_r>
800078f4:	e0 68 0d c0 	mov	r8,3520
800078f8:	5b fc       	cp.w	r12,-1
800078fa:	ec 0c 17 00 	moveq	r12,r6
800078fe:	f9 b1 00 00 	moveq	r1,0
80007902:	70 09       	ld.w	r9,r8[0x0]
80007904:	0c 1c       	sub	r12,r6
80007906:	89 26       	st.w	r4[0x8],r6
80007908:	02 0c       	add	r12,r1
8000790a:	12 01       	add	r1,r9
8000790c:	a1 ac       	sbr	r12,0x0
8000790e:	91 01       	st.w	r8[0x0],r1
80007910:	8d 1c       	st.w	r6[0x4],r12
80007912:	08 33       	cp.w	r3,r4
80007914:	c1 d0       	breq	8000794e <_malloc_r+0x3da>
80007916:	58 f2       	cp.w	r2,15
80007918:	e0 8b 00 05 	brhi	80007922 <_malloc_r+0x3ae>
8000791c:	30 18       	mov	r8,1
8000791e:	8d 18       	st.w	r6[0x4],r8
80007920:	c2 68       	rjmp	8000796c <_malloc_r+0x3f8>
80007922:	30 59       	mov	r9,5
80007924:	20 c2       	sub	r2,12
80007926:	e0 12 ff f8 	andl	r2,0xfff8
8000792a:	e6 02 00 08 	add	r8,r3,r2
8000792e:	91 29       	st.w	r8[0x8],r9
80007930:	91 19       	st.w	r8[0x4],r9
80007932:	66 18       	ld.w	r8,r3[0x4]
80007934:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007938:	e5 e8 10 08 	or	r8,r2,r8
8000793c:	87 18       	st.w	r3[0x4],r8
8000793e:	58 f2       	cp.w	r2,15
80007940:	e0 88 00 07 	brls	8000794e <_malloc_r+0x3da>
80007944:	e6 cb ff f8 	sub	r11,r3,-8
80007948:	0a 9c       	mov	r12,r5
8000794a:	e0 a0 1c 7d 	rcall	8000b244 <_free_r>
8000794e:	e0 69 0d b8 	mov	r9,3512
80007952:	72 0a       	ld.w	r10,r9[0x0]
80007954:	e0 68 0d c0 	mov	r8,3520
80007958:	70 08       	ld.w	r8,r8[0x0]
8000795a:	14 38       	cp.w	r8,r10
8000795c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007960:	e0 69 0d b4 	mov	r9,3508
80007964:	72 0a       	ld.w	r10,r9[0x0]
80007966:	14 38       	cp.w	r8,r10
80007968:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000796c:	68 28       	ld.w	r8,r4[0x8]
8000796e:	70 18       	ld.w	r8,r8[0x4]
80007970:	e0 18 ff fc 	andl	r8,0xfffc
80007974:	0e 38       	cp.w	r8,r7
80007976:	5f 39       	srlo	r9
80007978:	0e 18       	sub	r8,r7
8000797a:	58 f8       	cp.w	r8,15
8000797c:	5f aa       	srle	r10
8000797e:	f5 e9 10 09 	or	r9,r10,r9
80007982:	c0 50       	breq	8000798c <_malloc_r+0x418>
80007984:	0a 9c       	mov	r12,r5
80007986:	fe b0 f3 e1 	rcall	80006148 <__malloc_unlock>
8000798a:	d8 3a       	popm	r0-r7,pc,r12=0
8000798c:	68 26       	ld.w	r6,r4[0x8]
8000798e:	a1 a8       	sbr	r8,0x0
80007990:	0e 99       	mov	r9,r7
80007992:	a1 a9       	sbr	r9,0x0
80007994:	8d 19       	st.w	r6[0x4],r9
80007996:	ec 07 00 07 	add	r7,r6,r7
8000799a:	0a 9c       	mov	r12,r5
8000799c:	89 27       	st.w	r4[0x8],r7
8000799e:	8f 18       	st.w	r7[0x4],r8
800079a0:	fe b0 f3 d4 	rcall	80006148 <__malloc_unlock>
800079a4:	ec cc ff f8 	sub	r12,r6,-8
800079a8:	d8 32       	popm	r0-r7,pc
800079aa:	d7 03       	nop

800079ac <memcmp>:
800079ac:	d4 01       	pushm	lr
800079ae:	30 08       	mov	r8,0
800079b0:	c0 d8       	rjmp	800079ca <memcmp+0x1e>
800079b2:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800079b6:	f6 08 07 09 	ld.ub	r9,r11[r8]
800079ba:	20 1a       	sub	r10,1
800079bc:	2f f8       	sub	r8,-1
800079be:	f2 0e 18 00 	cp.b	lr,r9
800079c2:	c0 40       	breq	800079ca <memcmp+0x1e>
800079c4:	fc 09 01 0c 	sub	r12,lr,r9
800079c8:	d8 02       	popm	pc
800079ca:	58 0a       	cp.w	r10,0
800079cc:	cf 31       	brne	800079b2 <memcmp+0x6>
800079ce:	14 9c       	mov	r12,r10
800079d0:	d8 02       	popm	pc

800079d2 <memcpy>:
800079d2:	58 8a       	cp.w	r10,8
800079d4:	c2 f5       	brlt	80007a32 <memcpy+0x60>
800079d6:	f9 eb 10 09 	or	r9,r12,r11
800079da:	e2 19 00 03 	andl	r9,0x3,COH
800079de:	e0 81 00 97 	brne	80007b0c <memcpy+0x13a>
800079e2:	e0 4a 00 20 	cp.w	r10,32
800079e6:	c3 b4       	brge	80007a5c <memcpy+0x8a>
800079e8:	f4 08 14 02 	asr	r8,r10,0x2
800079ec:	f0 09 11 08 	rsub	r9,r8,8
800079f0:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800079f4:	76 69       	ld.w	r9,r11[0x18]
800079f6:	99 69       	st.w	r12[0x18],r9
800079f8:	76 59       	ld.w	r9,r11[0x14]
800079fa:	99 59       	st.w	r12[0x14],r9
800079fc:	76 49       	ld.w	r9,r11[0x10]
800079fe:	99 49       	st.w	r12[0x10],r9
80007a00:	76 39       	ld.w	r9,r11[0xc]
80007a02:	99 39       	st.w	r12[0xc],r9
80007a04:	76 29       	ld.w	r9,r11[0x8]
80007a06:	99 29       	st.w	r12[0x8],r9
80007a08:	76 19       	ld.w	r9,r11[0x4]
80007a0a:	99 19       	st.w	r12[0x4],r9
80007a0c:	76 09       	ld.w	r9,r11[0x0]
80007a0e:	99 09       	st.w	r12[0x0],r9
80007a10:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007a14:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007a18:	e0 1a 00 03 	andl	r10,0x3
80007a1c:	f4 0a 11 04 	rsub	r10,r10,4
80007a20:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007a24:	17 a9       	ld.ub	r9,r11[0x2]
80007a26:	b0 a9       	st.b	r8[0x2],r9
80007a28:	17 99       	ld.ub	r9,r11[0x1]
80007a2a:	b0 99       	st.b	r8[0x1],r9
80007a2c:	17 89       	ld.ub	r9,r11[0x0]
80007a2e:	b0 89       	st.b	r8[0x0],r9
80007a30:	5e fc       	retal	r12
80007a32:	f4 0a 11 09 	rsub	r10,r10,9
80007a36:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007a3a:	17 f9       	ld.ub	r9,r11[0x7]
80007a3c:	b8 f9       	st.b	r12[0x7],r9
80007a3e:	17 e9       	ld.ub	r9,r11[0x6]
80007a40:	b8 e9       	st.b	r12[0x6],r9
80007a42:	17 d9       	ld.ub	r9,r11[0x5]
80007a44:	b8 d9       	st.b	r12[0x5],r9
80007a46:	17 c9       	ld.ub	r9,r11[0x4]
80007a48:	b8 c9       	st.b	r12[0x4],r9
80007a4a:	17 b9       	ld.ub	r9,r11[0x3]
80007a4c:	b8 b9       	st.b	r12[0x3],r9
80007a4e:	17 a9       	ld.ub	r9,r11[0x2]
80007a50:	b8 a9       	st.b	r12[0x2],r9
80007a52:	17 99       	ld.ub	r9,r11[0x1]
80007a54:	b8 99       	st.b	r12[0x1],r9
80007a56:	17 89       	ld.ub	r9,r11[0x0]
80007a58:	b8 89       	st.b	r12[0x0],r9
80007a5a:	5e fc       	retal	r12
80007a5c:	eb cd 40 c0 	pushm	r6-r7,lr
80007a60:	18 99       	mov	r9,r12
80007a62:	22 0a       	sub	r10,32
80007a64:	b7 07       	ld.d	r6,r11++
80007a66:	b3 26       	st.d	r9++,r6
80007a68:	b7 07       	ld.d	r6,r11++
80007a6a:	b3 26       	st.d	r9++,r6
80007a6c:	b7 07       	ld.d	r6,r11++
80007a6e:	b3 26       	st.d	r9++,r6
80007a70:	b7 07       	ld.d	r6,r11++
80007a72:	b3 26       	st.d	r9++,r6
80007a74:	22 0a       	sub	r10,32
80007a76:	cf 74       	brge	80007a64 <memcpy+0x92>
80007a78:	2f 0a       	sub	r10,-16
80007a7a:	c0 65       	brlt	80007a86 <memcpy+0xb4>
80007a7c:	b7 07       	ld.d	r6,r11++
80007a7e:	b3 26       	st.d	r9++,r6
80007a80:	b7 07       	ld.d	r6,r11++
80007a82:	b3 26       	st.d	r9++,r6
80007a84:	21 0a       	sub	r10,16
80007a86:	5c 3a       	neg	r10
80007a88:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007a8c:	d7 03       	nop
80007a8e:	d7 03       	nop
80007a90:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007a94:	f3 66 00 0e 	st.b	r9[14],r6
80007a98:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007a9c:	f3 66 00 0d 	st.b	r9[13],r6
80007aa0:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007aa4:	f3 66 00 0c 	st.b	r9[12],r6
80007aa8:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007aac:	f3 66 00 0b 	st.b	r9[11],r6
80007ab0:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007ab4:	f3 66 00 0a 	st.b	r9[10],r6
80007ab8:	f7 36 00 09 	ld.ub	r6,r11[9]
80007abc:	f3 66 00 09 	st.b	r9[9],r6
80007ac0:	f7 36 00 08 	ld.ub	r6,r11[8]
80007ac4:	f3 66 00 08 	st.b	r9[8],r6
80007ac8:	f7 36 00 07 	ld.ub	r6,r11[7]
80007acc:	f3 66 00 07 	st.b	r9[7],r6
80007ad0:	f7 36 00 06 	ld.ub	r6,r11[6]
80007ad4:	f3 66 00 06 	st.b	r9[6],r6
80007ad8:	f7 36 00 05 	ld.ub	r6,r11[5]
80007adc:	f3 66 00 05 	st.b	r9[5],r6
80007ae0:	f7 36 00 04 	ld.ub	r6,r11[4]
80007ae4:	f3 66 00 04 	st.b	r9[4],r6
80007ae8:	f7 36 00 03 	ld.ub	r6,r11[3]
80007aec:	f3 66 00 03 	st.b	r9[3],r6
80007af0:	f7 36 00 02 	ld.ub	r6,r11[2]
80007af4:	f3 66 00 02 	st.b	r9[2],r6
80007af8:	f7 36 00 01 	ld.ub	r6,r11[1]
80007afc:	f3 66 00 01 	st.b	r9[1],r6
80007b00:	f7 36 00 00 	ld.ub	r6,r11[0]
80007b04:	f3 66 00 00 	st.b	r9[0],r6
80007b08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b0c:	20 1a       	sub	r10,1
80007b0e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007b12:	f8 0a 0b 09 	st.b	r12[r10],r9
80007b16:	cf b1       	brne	80007b0c <memcpy+0x13a>
80007b18:	5e fc       	retal	r12

80007b1a <memset>:
80007b1a:	18 98       	mov	r8,r12
80007b1c:	c0 38       	rjmp	80007b22 <memset+0x8>
80007b1e:	10 cb       	st.b	r8++,r11
80007b20:	20 1a       	sub	r10,1
80007b22:	58 0a       	cp.w	r10,0
80007b24:	cf d1       	brne	80007b1e <memset+0x4>
80007b26:	5e fc       	retal	r12

80007b28 <_realloc_r>:
80007b28:	d4 31       	pushm	r0-r7,lr
80007b2a:	20 1d       	sub	sp,4
80007b2c:	16 94       	mov	r4,r11
80007b2e:	18 92       	mov	r2,r12
80007b30:	14 9b       	mov	r11,r10
80007b32:	58 04       	cp.w	r4,0
80007b34:	c0 51       	brne	80007b3e <_realloc_r+0x16>
80007b36:	fe b0 fd 1f 	rcall	80007574 <_malloc_r>
80007b3a:	18 95       	mov	r5,r12
80007b3c:	c5 39       	rjmp	80007de2 <_realloc_r+0x2ba>
80007b3e:	50 0a       	stdsp	sp[0x0],r10
80007b40:	fe b0 f2 fe 	rcall	8000613c <__malloc_lock>
80007b44:	40 0b       	lddsp	r11,sp[0x0]
80007b46:	f6 c8 ff f5 	sub	r8,r11,-11
80007b4a:	e8 c1 00 08 	sub	r1,r4,8
80007b4e:	10 96       	mov	r6,r8
80007b50:	62 1c       	ld.w	r12,r1[0x4]
80007b52:	e0 16 ff f8 	andl	r6,0xfff8
80007b56:	59 68       	cp.w	r8,22
80007b58:	f9 b6 08 10 	movls	r6,16
80007b5c:	16 36       	cp.w	r6,r11
80007b5e:	5f 38       	srlo	r8
80007b60:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007b64:	c0 50       	breq	80007b6e <_realloc_r+0x46>
80007b66:	30 c8       	mov	r8,12
80007b68:	30 05       	mov	r5,0
80007b6a:	85 38       	st.w	r2[0xc],r8
80007b6c:	c3 b9       	rjmp	80007de2 <_realloc_r+0x2ba>
80007b6e:	18 90       	mov	r0,r12
80007b70:	e0 10 ff fc 	andl	r0,0xfffc
80007b74:	0c 30       	cp.w	r0,r6
80007b76:	e0 84 01 0b 	brge	80007d8c <_realloc_r+0x264>
80007b7a:	e0 68 05 48 	mov	r8,1352
80007b7e:	e2 00 00 09 	add	r9,r1,r0
80007b82:	70 25       	ld.w	r5,r8[0x8]
80007b84:	0a 39       	cp.w	r9,r5
80007b86:	c0 90       	breq	80007b98 <_realloc_r+0x70>
80007b88:	72 1a       	ld.w	r10,r9[0x4]
80007b8a:	a1 ca       	cbr	r10,0x0
80007b8c:	f2 0a 00 0a 	add	r10,r9,r10
80007b90:	74 1a       	ld.w	r10,r10[0x4]
80007b92:	ed ba 00 00 	bld	r10,0x0
80007b96:	c2 20       	breq	80007bda <_realloc_r+0xb2>
80007b98:	72 1a       	ld.w	r10,r9[0x4]
80007b9a:	e0 1a ff fc 	andl	r10,0xfffc
80007b9e:	f4 00 00 03 	add	r3,r10,r0
80007ba2:	0a 39       	cp.w	r9,r5
80007ba4:	c1 31       	brne	80007bca <_realloc_r+0xa2>
80007ba6:	ec c7 ff f0 	sub	r7,r6,-16
80007baa:	0e 33       	cp.w	r3,r7
80007bac:	c1 95       	brlt	80007bde <_realloc_r+0xb6>
80007bae:	e2 06 00 09 	add	r9,r1,r6
80007bb2:	0c 13       	sub	r3,r6
80007bb4:	a1 a3       	sbr	r3,0x0
80007bb6:	93 13       	st.w	r9[0x4],r3
80007bb8:	91 29       	st.w	r8[0x8],r9
80007bba:	04 9c       	mov	r12,r2
80007bbc:	62 18       	ld.w	r8,r1[0x4]
80007bbe:	08 95       	mov	r5,r4
80007bc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007bc4:	10 46       	or	r6,r8
80007bc6:	83 16       	st.w	r1[0x4],r6
80007bc8:	c0 b9       	rjmp	80007dde <_realloc_r+0x2b6>
80007bca:	0c 33       	cp.w	r3,r6
80007bcc:	c0 95       	brlt	80007bde <_realloc_r+0xb6>
80007bce:	72 28       	ld.w	r8,r9[0x8]
80007bd0:	02 97       	mov	r7,r1
80007bd2:	72 39       	ld.w	r9,r9[0xc]
80007bd4:	93 28       	st.w	r9[0x8],r8
80007bd6:	91 39       	st.w	r8[0xc],r9
80007bd8:	cd c8       	rjmp	80007d90 <_realloc_r+0x268>
80007bda:	30 0a       	mov	r10,0
80007bdc:	14 99       	mov	r9,r10
80007bde:	ed bc 00 00 	bld	r12,0x0
80007be2:	e0 80 00 95 	breq	80007d0c <_realloc_r+0x1e4>
80007be6:	62 07       	ld.w	r7,r1[0x0]
80007be8:	e2 07 01 07 	sub	r7,r1,r7
80007bec:	6e 1c       	ld.w	r12,r7[0x4]
80007bee:	e0 1c ff fc 	andl	r12,0xfffc
80007bf2:	58 09       	cp.w	r9,0
80007bf4:	c5 60       	breq	80007ca0 <_realloc_r+0x178>
80007bf6:	f8 00 00 03 	add	r3,r12,r0
80007bfa:	0a 39       	cp.w	r9,r5
80007bfc:	c4 81       	brne	80007c8c <_realloc_r+0x164>
80007bfe:	14 03       	add	r3,r10
80007c00:	ec c9 ff f0 	sub	r9,r6,-16
80007c04:	12 33       	cp.w	r3,r9
80007c06:	c4 d5       	brlt	80007ca0 <_realloc_r+0x178>
80007c08:	6e 3a       	ld.w	r10,r7[0xc]
80007c0a:	6e 29       	ld.w	r9,r7[0x8]
80007c0c:	95 29       	st.w	r10[0x8],r9
80007c0e:	93 3a       	st.w	r9[0xc],r10
80007c10:	ee c5 ff f8 	sub	r5,r7,-8
80007c14:	e0 ca 00 04 	sub	r10,r0,4
80007c18:	e0 4a 00 24 	cp.w	r10,36
80007c1c:	e0 8b 00 25 	brhi	80007c66 <_realloc_r+0x13e>
80007c20:	0a 99       	mov	r9,r5
80007c22:	59 3a       	cp.w	r10,19
80007c24:	e0 88 00 1a 	brls	80007c58 <_realloc_r+0x130>
80007c28:	09 09       	ld.w	r9,r4++
80007c2a:	8b 09       	st.w	r5[0x0],r9
80007c2c:	09 09       	ld.w	r9,r4++
80007c2e:	8f 39       	st.w	r7[0xc],r9
80007c30:	ee c9 ff f0 	sub	r9,r7,-16
80007c34:	59 ba       	cp.w	r10,27
80007c36:	e0 88 00 11 	brls	80007c58 <_realloc_r+0x130>
80007c3a:	09 0b       	ld.w	r11,r4++
80007c3c:	93 0b       	st.w	r9[0x0],r11
80007c3e:	09 09       	ld.w	r9,r4++
80007c40:	8f 59       	st.w	r7[0x14],r9
80007c42:	ee c9 ff e8 	sub	r9,r7,-24
80007c46:	e0 4a 00 24 	cp.w	r10,36
80007c4a:	c0 71       	brne	80007c58 <_realloc_r+0x130>
80007c4c:	09 0a       	ld.w	r10,r4++
80007c4e:	93 0a       	st.w	r9[0x0],r10
80007c50:	ee c9 ff e0 	sub	r9,r7,-32
80007c54:	09 0a       	ld.w	r10,r4++
80007c56:	8f 7a       	st.w	r7[0x1c],r10
80007c58:	09 0a       	ld.w	r10,r4++
80007c5a:	12 aa       	st.w	r9++,r10
80007c5c:	68 0a       	ld.w	r10,r4[0x0]
80007c5e:	93 0a       	st.w	r9[0x0],r10
80007c60:	68 1a       	ld.w	r10,r4[0x4]
80007c62:	93 1a       	st.w	r9[0x4],r10
80007c64:	c0 78       	rjmp	80007c72 <_realloc_r+0x14a>
80007c66:	50 08       	stdsp	sp[0x0],r8
80007c68:	08 9b       	mov	r11,r4
80007c6a:	0a 9c       	mov	r12,r5
80007c6c:	e0 a0 1d 8f 	rcall	8000b78a <memmove>
80007c70:	40 08       	lddsp	r8,sp[0x0]
80007c72:	ee 06 00 09 	add	r9,r7,r6
80007c76:	0c 13       	sub	r3,r6
80007c78:	a1 a3       	sbr	r3,0x0
80007c7a:	93 13       	st.w	r9[0x4],r3
80007c7c:	91 29       	st.w	r8[0x8],r9
80007c7e:	04 9c       	mov	r12,r2
80007c80:	6e 18       	ld.w	r8,r7[0x4]
80007c82:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c86:	10 46       	or	r6,r8
80007c88:	8f 16       	st.w	r7[0x4],r6
80007c8a:	ca a8       	rjmp	80007dde <_realloc_r+0x2b6>
80007c8c:	14 03       	add	r3,r10
80007c8e:	0c 33       	cp.w	r3,r6
80007c90:	c0 85       	brlt	80007ca0 <_realloc_r+0x178>
80007c92:	72 28       	ld.w	r8,r9[0x8]
80007c94:	72 39       	ld.w	r9,r9[0xc]
80007c96:	93 28       	st.w	r9[0x8],r8
80007c98:	91 39       	st.w	r8[0xc],r9
80007c9a:	6e 28       	ld.w	r8,r7[0x8]
80007c9c:	6e 39       	ld.w	r9,r7[0xc]
80007c9e:	c0 78       	rjmp	80007cac <_realloc_r+0x184>
80007ca0:	f8 00 00 03 	add	r3,r12,r0
80007ca4:	0c 33       	cp.w	r3,r6
80007ca6:	c3 35       	brlt	80007d0c <_realloc_r+0x1e4>
80007ca8:	6e 39       	ld.w	r9,r7[0xc]
80007caa:	6e 28       	ld.w	r8,r7[0x8]
80007cac:	93 28       	st.w	r9[0x8],r8
80007cae:	91 39       	st.w	r8[0xc],r9
80007cb0:	e0 ca 00 04 	sub	r10,r0,4
80007cb4:	ee cc ff f8 	sub	r12,r7,-8
80007cb8:	e0 4a 00 24 	cp.w	r10,36
80007cbc:	e0 8b 00 24 	brhi	80007d04 <_realloc_r+0x1dc>
80007cc0:	59 3a       	cp.w	r10,19
80007cc2:	e0 88 00 1a 	brls	80007cf6 <_realloc_r+0x1ce>
80007cc6:	09 08       	ld.w	r8,r4++
80007cc8:	99 08       	st.w	r12[0x0],r8
80007cca:	09 08       	ld.w	r8,r4++
80007ccc:	8f 38       	st.w	r7[0xc],r8
80007cce:	ee cc ff f0 	sub	r12,r7,-16
80007cd2:	59 ba       	cp.w	r10,27
80007cd4:	e0 88 00 11 	brls	80007cf6 <_realloc_r+0x1ce>
80007cd8:	09 08       	ld.w	r8,r4++
80007cda:	99 08       	st.w	r12[0x0],r8
80007cdc:	09 08       	ld.w	r8,r4++
80007cde:	8f 58       	st.w	r7[0x14],r8
80007ce0:	ee cc ff e8 	sub	r12,r7,-24
80007ce4:	e0 4a 00 24 	cp.w	r10,36
80007ce8:	c0 71       	brne	80007cf6 <_realloc_r+0x1ce>
80007cea:	09 08       	ld.w	r8,r4++
80007cec:	99 08       	st.w	r12[0x0],r8
80007cee:	ee cc ff e0 	sub	r12,r7,-32
80007cf2:	09 08       	ld.w	r8,r4++
80007cf4:	8f 78       	st.w	r7[0x1c],r8
80007cf6:	09 08       	ld.w	r8,r4++
80007cf8:	18 a8       	st.w	r12++,r8
80007cfa:	68 08       	ld.w	r8,r4[0x0]
80007cfc:	99 08       	st.w	r12[0x0],r8
80007cfe:	68 18       	ld.w	r8,r4[0x4]
80007d00:	99 18       	st.w	r12[0x4],r8
80007d02:	c4 78       	rjmp	80007d90 <_realloc_r+0x268>
80007d04:	08 9b       	mov	r11,r4
80007d06:	e0 a0 1d 42 	rcall	8000b78a <memmove>
80007d0a:	c4 38       	rjmp	80007d90 <_realloc_r+0x268>
80007d0c:	04 9c       	mov	r12,r2
80007d0e:	fe b0 fc 33 	rcall	80007574 <_malloc_r>
80007d12:	18 95       	mov	r5,r12
80007d14:	c3 a0       	breq	80007d88 <_realloc_r+0x260>
80007d16:	62 18       	ld.w	r8,r1[0x4]
80007d18:	f8 c9 00 08 	sub	r9,r12,8
80007d1c:	a1 c8       	cbr	r8,0x0
80007d1e:	e2 08 00 08 	add	r8,r1,r8
80007d22:	10 39       	cp.w	r9,r8
80007d24:	c0 71       	brne	80007d32 <_realloc_r+0x20a>
80007d26:	72 13       	ld.w	r3,r9[0x4]
80007d28:	02 97       	mov	r7,r1
80007d2a:	e0 13 ff fc 	andl	r3,0xfffc
80007d2e:	00 03       	add	r3,r0
80007d30:	c3 08       	rjmp	80007d90 <_realloc_r+0x268>
80007d32:	e0 ca 00 04 	sub	r10,r0,4
80007d36:	e0 4a 00 24 	cp.w	r10,36
80007d3a:	e0 8b 00 20 	brhi	80007d7a <_realloc_r+0x252>
80007d3e:	08 99       	mov	r9,r4
80007d40:	18 98       	mov	r8,r12
80007d42:	59 3a       	cp.w	r10,19
80007d44:	e0 88 00 14 	brls	80007d6c <_realloc_r+0x244>
80007d48:	13 0b       	ld.w	r11,r9++
80007d4a:	10 ab       	st.w	r8++,r11
80007d4c:	13 0b       	ld.w	r11,r9++
80007d4e:	10 ab       	st.w	r8++,r11
80007d50:	59 ba       	cp.w	r10,27
80007d52:	e0 88 00 0d 	brls	80007d6c <_realloc_r+0x244>
80007d56:	13 0b       	ld.w	r11,r9++
80007d58:	10 ab       	st.w	r8++,r11
80007d5a:	13 0b       	ld.w	r11,r9++
80007d5c:	10 ab       	st.w	r8++,r11
80007d5e:	e0 4a 00 24 	cp.w	r10,36
80007d62:	c0 51       	brne	80007d6c <_realloc_r+0x244>
80007d64:	13 0a       	ld.w	r10,r9++
80007d66:	10 aa       	st.w	r8++,r10
80007d68:	13 0a       	ld.w	r10,r9++
80007d6a:	10 aa       	st.w	r8++,r10
80007d6c:	13 0a       	ld.w	r10,r9++
80007d6e:	10 aa       	st.w	r8++,r10
80007d70:	72 0a       	ld.w	r10,r9[0x0]
80007d72:	91 0a       	st.w	r8[0x0],r10
80007d74:	72 19       	ld.w	r9,r9[0x4]
80007d76:	91 19       	st.w	r8[0x4],r9
80007d78:	c0 48       	rjmp	80007d80 <_realloc_r+0x258>
80007d7a:	08 9b       	mov	r11,r4
80007d7c:	e0 a0 1d 07 	rcall	8000b78a <memmove>
80007d80:	08 9b       	mov	r11,r4
80007d82:	04 9c       	mov	r12,r2
80007d84:	e0 a0 1a 60 	rcall	8000b244 <_free_r>
80007d88:	04 9c       	mov	r12,r2
80007d8a:	c2 a8       	rjmp	80007dde <_realloc_r+0x2b6>
80007d8c:	00 93       	mov	r3,r0
80007d8e:	02 97       	mov	r7,r1
80007d90:	e6 06 01 09 	sub	r9,r3,r6
80007d94:	6e 18       	ld.w	r8,r7[0x4]
80007d96:	58 f9       	cp.w	r9,15
80007d98:	e0 88 00 16 	brls	80007dc4 <_realloc_r+0x29c>
80007d9c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007da0:	ed e8 10 08 	or	r8,r6,r8
80007da4:	8f 18       	st.w	r7[0x4],r8
80007da6:	12 98       	mov	r8,r9
80007da8:	a1 a8       	sbr	r8,0x0
80007daa:	ee 06 00 0b 	add	r11,r7,r6
80007dae:	f6 09 00 09 	add	r9,r11,r9
80007db2:	97 18       	st.w	r11[0x4],r8
80007db4:	72 18       	ld.w	r8,r9[0x4]
80007db6:	a1 a8       	sbr	r8,0x0
80007db8:	2f 8b       	sub	r11,-8
80007dba:	93 18       	st.w	r9[0x4],r8
80007dbc:	04 9c       	mov	r12,r2
80007dbe:	e0 a0 1a 43 	rcall	8000b244 <_free_r>
80007dc2:	c0 b8       	rjmp	80007dd8 <_realloc_r+0x2b0>
80007dc4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007dc8:	e7 e8 10 08 	or	r8,r3,r8
80007dcc:	8f 18       	st.w	r7[0x4],r8
80007dce:	ee 03 00 03 	add	r3,r7,r3
80007dd2:	66 18       	ld.w	r8,r3[0x4]
80007dd4:	a1 a8       	sbr	r8,0x0
80007dd6:	87 18       	st.w	r3[0x4],r8
80007dd8:	04 9c       	mov	r12,r2
80007dda:	ee c5 ff f8 	sub	r5,r7,-8
80007dde:	fe b0 f1 b5 	rcall	80006148 <__malloc_unlock>
80007de2:	0a 9c       	mov	r12,r5
80007de4:	2f fd       	sub	sp,-4
80007de6:	d8 32       	popm	r0-r7,pc

80007de8 <_sbrk_r>:
80007de8:	d4 21       	pushm	r4-r7,lr
80007dea:	30 08       	mov	r8,0
80007dec:	18 97       	mov	r7,r12
80007dee:	e0 66 51 94 	mov	r6,20884
80007df2:	16 9c       	mov	r12,r11
80007df4:	8d 08       	st.w	r6[0x0],r8
80007df6:	c8 5c       	rcall	80007f00 <_sbrk>
80007df8:	5b fc       	cp.w	r12,-1
80007dfa:	c0 51       	brne	80007e04 <_sbrk_r+0x1c>
80007dfc:	6c 08       	ld.w	r8,r6[0x0]
80007dfe:	58 08       	cp.w	r8,0
80007e00:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007e04:	d8 22       	popm	r4-r7,pc
80007e06:	d7 03       	nop

80007e08 <sprintf>:
80007e08:	d4 01       	pushm	lr
80007e0a:	21 7d       	sub	sp,92
80007e0c:	e0 68 ff ff 	mov	r8,65535
80007e10:	ea 18 7f ff 	orh	r8,0x7fff
80007e14:	50 58       	stdsp	sp[0x14],r8
80007e16:	50 28       	stdsp	sp[0x8],r8
80007e18:	e0 68 02 08 	mov	r8,520
80007e1c:	ba 68       	st.h	sp[0xc],r8
80007e1e:	3f f8       	mov	r8,-1
80007e20:	ba 78       	st.h	sp[0xe],r8
80007e22:	e0 68 0a 48 	mov	r8,2632
80007e26:	50 4c       	stdsp	sp[0x10],r12
80007e28:	16 9a       	mov	r10,r11
80007e2a:	50 0c       	stdsp	sp[0x0],r12
80007e2c:	fa c9 ff a0 	sub	r9,sp,-96
80007e30:	70 0c       	ld.w	r12,r8[0x0]
80007e32:	1a 9b       	mov	r11,sp
80007e34:	e0 a0 02 1a 	rcall	80008268 <_vfprintf_r>
80007e38:	30 09       	mov	r9,0
80007e3a:	40 08       	lddsp	r8,sp[0x0]
80007e3c:	b0 89       	st.b	r8[0x0],r9
80007e3e:	2e 9d       	sub	sp,-92
80007e40:	d8 02       	popm	pc
80007e42:	d7 03       	nop

80007e44 <strncpy>:
80007e44:	30 08       	mov	r8,0
80007e46:	10 3a       	cp.w	r10,r8
80007e48:	5e 0c       	reteq	r12
80007e4a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007e4e:	f8 08 0b 09 	st.b	r12[r8],r9
80007e52:	2f f8       	sub	r8,-1
80007e54:	58 09       	cp.w	r9,0
80007e56:	cf 81       	brne	80007e46 <strncpy+0x2>
80007e58:	10 3a       	cp.w	r10,r8
80007e5a:	5e 0c       	reteq	r12
80007e5c:	f8 08 0b 09 	st.b	r12[r8],r9
80007e60:	2f f8       	sub	r8,-1
80007e62:	cf bb       	rjmp	80007e58 <strncpy+0x14>

80007e64 <_close>:
80007e64:	30 28       	mov	r8,2
80007e66:	d6 73       	breakpoint
80007e68:	3f fc       	mov	r12,-1
80007e6a:	35 8b       	mov	r11,88
80007e6c:	58 0c       	cp.w	r12,0
80007e6e:	5e 4c       	retge	r12
80007e70:	e0 6a 51 94 	mov	r10,20884
80007e74:	95 0b       	st.w	r10[0x0],r11
80007e76:	5e fc       	retal	r12

80007e78 <_lseek>:
80007e78:	30 58       	mov	r8,5
80007e7a:	d6 73       	breakpoint
80007e7c:	3f fc       	mov	r12,-1
80007e7e:	35 8b       	mov	r11,88
80007e80:	58 0c       	cp.w	r12,0
80007e82:	5e 4c       	retge	r12
80007e84:	e0 6a 51 94 	mov	r10,20884
80007e88:	95 0b       	st.w	r10[0x0],r11
80007e8a:	5e fc       	retal	r12

80007e8c <isatty>:
80007e8c:	30 b8       	mov	r8,11
80007e8e:	d6 73       	breakpoint
80007e90:	3f fc       	mov	r12,-1
80007e92:	35 8b       	mov	r11,88
80007e94:	58 0c       	cp.w	r12,0
80007e96:	5e 4c       	retge	r12
80007e98:	e0 6a 51 94 	mov	r10,20884
80007e9c:	95 0b       	st.w	r10[0x0],r11
80007e9e:	5e fc       	retal	r12

80007ea0 <_fstat_host>:
80007ea0:	30 98       	mov	r8,9
80007ea2:	d6 73       	breakpoint
80007ea4:	3f fc       	mov	r12,-1
80007ea6:	35 8b       	mov	r11,88
80007ea8:	58 0c       	cp.w	r12,0
80007eaa:	5e 4c       	retge	r12
80007eac:	e0 6a 51 94 	mov	r10,20884
80007eb0:	95 0b       	st.w	r10[0x0],r11
80007eb2:	5e fc       	retal	r12

80007eb4 <_fstat>:
80007eb4:	d4 21       	pushm	r4-r7,lr
80007eb6:	21 0d       	sub	sp,64
80007eb8:	16 97       	mov	r7,r11
80007eba:	1a 9b       	mov	r11,sp
80007ebc:	cf 2f       	rcall	80007ea0 <_fstat_host>
80007ebe:	c0 34       	brge	80007ec4 <_fstat+0x10>
80007ec0:	3f fc       	mov	r12,-1
80007ec2:	c1 c8       	rjmp	80007efa <_fstat+0x46>
80007ec4:	40 08       	lddsp	r8,sp[0x0]
80007ec6:	ae 08       	st.h	r7[0x0],r8
80007ec8:	40 18       	lddsp	r8,sp[0x4]
80007eca:	ae 18       	st.h	r7[0x2],r8
80007ecc:	40 28       	lddsp	r8,sp[0x8]
80007ece:	8f 18       	st.w	r7[0x4],r8
80007ed0:	40 38       	lddsp	r8,sp[0xc]
80007ed2:	ae 48       	st.h	r7[0x8],r8
80007ed4:	40 48       	lddsp	r8,sp[0x10]
80007ed6:	ae 58       	st.h	r7[0xa],r8
80007ed8:	40 58       	lddsp	r8,sp[0x14]
80007eda:	ae 68       	st.h	r7[0xc],r8
80007edc:	40 68       	lddsp	r8,sp[0x18]
80007ede:	ae 78       	st.h	r7[0xe],r8
80007ee0:	40 88       	lddsp	r8,sp[0x20]
80007ee2:	8f 48       	st.w	r7[0x10],r8
80007ee4:	40 a8       	lddsp	r8,sp[0x28]
80007ee6:	8f b8       	st.w	r7[0x2c],r8
80007ee8:	40 c8       	lddsp	r8,sp[0x30]
80007eea:	8f c8       	st.w	r7[0x30],r8
80007eec:	40 d8       	lddsp	r8,sp[0x34]
80007eee:	8f 58       	st.w	r7[0x14],r8
80007ef0:	40 e8       	lddsp	r8,sp[0x38]
80007ef2:	30 0c       	mov	r12,0
80007ef4:	8f 78       	st.w	r7[0x1c],r8
80007ef6:	40 f8       	lddsp	r8,sp[0x3c]
80007ef8:	8f 98       	st.w	r7[0x24],r8
80007efa:	2f 0d       	sub	sp,-64
80007efc:	d8 22       	popm	r4-r7,pc
80007efe:	d7 03       	nop

80007f00 <_sbrk>:
80007f00:	d4 01       	pushm	lr
80007f02:	e0 68 0d e8 	mov	r8,3560
80007f06:	70 09       	ld.w	r9,r8[0x0]
80007f08:	58 09       	cp.w	r9,0
80007f0a:	c0 41       	brne	80007f12 <_sbrk+0x12>
80007f0c:	e0 69 51 98 	mov	r9,20888
80007f10:	91 09       	st.w	r8[0x0],r9
80007f12:	e0 69 0d e8 	mov	r9,3560
80007f16:	e0 7a 70 00 	mov	r10,94208
80007f1a:	72 08       	ld.w	r8,r9[0x0]
80007f1c:	f0 0c 00 0c 	add	r12,r8,r12
80007f20:	14 3c       	cp.w	r12,r10
80007f22:	e0 8b 00 04 	brhi	80007f2a <_sbrk+0x2a>
80007f26:	93 0c       	st.w	r9[0x0],r12
80007f28:	c0 68       	rjmp	80007f34 <_sbrk+0x34>
80007f2a:	e0 a0 18 15 	rcall	8000af54 <__errno>
80007f2e:	30 c8       	mov	r8,12
80007f30:	99 08       	st.w	r12[0x0],r8
80007f32:	3f f8       	mov	r8,-1
80007f34:	10 9c       	mov	r12,r8
80007f36:	d8 02       	popm	pc

80007f38 <get_arg>:
80007f38:	d4 31       	pushm	r0-r7,lr
80007f3a:	20 8d       	sub	sp,32
80007f3c:	fa c4 ff bc 	sub	r4,sp,-68
80007f40:	50 4b       	stdsp	sp[0x10],r11
80007f42:	68 2e       	ld.w	lr,r4[0x8]
80007f44:	50 58       	stdsp	sp[0x14],r8
80007f46:	12 96       	mov	r6,r9
80007f48:	7c 0b       	ld.w	r11,lr[0x0]
80007f4a:	70 05       	ld.w	r5,r8[0x0]
80007f4c:	50 6e       	stdsp	sp[0x18],lr
80007f4e:	58 0b       	cp.w	r11,0
80007f50:	f4 0b 17 00 	moveq	r11,r10
80007f54:	68 03       	ld.w	r3,r4[0x0]
80007f56:	68 11       	ld.w	r1,r4[0x4]
80007f58:	40 49       	lddsp	r9,sp[0x10]
80007f5a:	30 08       	mov	r8,0
80007f5c:	c2 89       	rjmp	800081ac <get_arg+0x274>
80007f5e:	2f fb       	sub	r11,-1
80007f60:	32 5c       	mov	r12,37
80007f62:	17 8a       	ld.ub	r10,r11[0x0]
80007f64:	f8 0a 18 00 	cp.b	r10,r12
80007f68:	5f 1e       	srne	lr
80007f6a:	f0 0a 18 00 	cp.b	r10,r8
80007f6e:	5f 1c       	srne	r12
80007f70:	fd ec 00 0c 	and	r12,lr,r12
80007f74:	f0 0c 18 00 	cp.b	r12,r8
80007f78:	cf 31       	brne	80007f5e <get_arg+0x26>
80007f7a:	58 0a       	cp.w	r10,0
80007f7c:	e0 80 01 25 	breq	800081c6 <get_arg+0x28e>
80007f80:	30 0c       	mov	r12,0
80007f82:	3f fa       	mov	r10,-1
80007f84:	18 90       	mov	r0,r12
80007f86:	50 3a       	stdsp	sp[0xc],r10
80007f88:	18 94       	mov	r4,r12
80007f8a:	18 92       	mov	r2,r12
80007f8c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007f90:	16 97       	mov	r7,r11
80007f92:	50 7c       	stdsp	sp[0x1c],r12
80007f94:	fe cc 9e 14 	sub	r12,pc,-25068
80007f98:	0f 3a       	ld.ub	r10,r7++
80007f9a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007f9e:	40 7c       	lddsp	r12,sp[0x1c]
80007fa0:	1c 0c       	add	r12,lr
80007fa2:	fe ce 9e ea 	sub	lr,pc,-24854
80007fa6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007faa:	20 1e       	sub	lr,1
80007fac:	50 0e       	stdsp	sp[0x0],lr
80007fae:	fe ce 9f 62 	sub	lr,pc,-24734
80007fb2:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007fb6:	50 7c       	stdsp	sp[0x1c],r12
80007fb8:	40 0c       	lddsp	r12,sp[0x0]
80007fba:	58 7c       	cp.w	r12,7
80007fbc:	e0 8b 00 f1 	brhi	8000819e <get_arg+0x266>
80007fc0:	fe ce a1 14 	sub	lr,pc,-24300
80007fc4:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007fc8:	36 8b       	mov	r11,104
80007fca:	f6 0a 18 00 	cp.b	r10,r11
80007fce:	e0 80 00 e8 	breq	8000819e <get_arg+0x266>
80007fd2:	37 1b       	mov	r11,113
80007fd4:	f6 0a 18 00 	cp.b	r10,r11
80007fd8:	c0 70       	breq	80007fe6 <get_arg+0xae>
80007fda:	34 cb       	mov	r11,76
80007fdc:	f6 0a 18 00 	cp.b	r10,r11
80007fe0:	c0 51       	brne	80007fea <get_arg+0xb2>
80007fe2:	a3 b4       	sbr	r4,0x3
80007fe4:	cd d8       	rjmp	8000819e <get_arg+0x266>
80007fe6:	a5 b4       	sbr	r4,0x5
80007fe8:	cd b8       	rjmp	8000819e <get_arg+0x266>
80007fea:	08 9a       	mov	r10,r4
80007fec:	0e 9b       	mov	r11,r7
80007fee:	a5 aa       	sbr	r10,0x4
80007ff0:	17 3c       	ld.ub	r12,r11++
80007ff2:	a5 b4       	sbr	r4,0x5
80007ff4:	36 ce       	mov	lr,108
80007ff6:	fc 0c 18 00 	cp.b	r12,lr
80007ffa:	e0 80 00 d3 	breq	800081a0 <get_arg+0x268>
80007ffe:	14 94       	mov	r4,r10
80008000:	cc f8       	rjmp	8000819e <get_arg+0x266>
80008002:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008006:	36 7c       	mov	r12,103
80008008:	f8 0a 18 00 	cp.b	r10,r12
8000800c:	e0 8b 00 27 	brhi	8000805a <get_arg+0x122>
80008010:	36 5b       	mov	r11,101
80008012:	f6 0a 18 00 	cp.b	r10,r11
80008016:	c4 82       	brcc	800080a6 <get_arg+0x16e>
80008018:	34 fb       	mov	r11,79
8000801a:	f6 0a 18 00 	cp.b	r10,r11
8000801e:	c4 80       	breq	800080ae <get_arg+0x176>
80008020:	e0 8b 00 0c 	brhi	80008038 <get_arg+0x100>
80008024:	34 5b       	mov	r11,69
80008026:	f6 0a 18 00 	cp.b	r10,r11
8000802a:	c3 e0       	breq	800080a6 <get_arg+0x16e>
8000802c:	34 7b       	mov	r11,71
8000802e:	f6 0a 18 00 	cp.b	r10,r11
80008032:	c3 a0       	breq	800080a6 <get_arg+0x16e>
80008034:	34 4b       	mov	r11,68
80008036:	c0 88       	rjmp	80008046 <get_arg+0x10e>
80008038:	35 8b       	mov	r11,88
8000803a:	f6 0a 18 00 	cp.b	r10,r11
8000803e:	c2 c0       	breq	80008096 <get_arg+0x15e>
80008040:	e0 8b 00 07 	brhi	8000804e <get_arg+0x116>
80008044:	35 5b       	mov	r11,85
80008046:	f6 0a 18 00 	cp.b	r10,r11
8000804a:	c3 51       	brne	800080b4 <get_arg+0x17c>
8000804c:	c3 18       	rjmp	800080ae <get_arg+0x176>
8000804e:	36 3b       	mov	r11,99
80008050:	f6 0a 18 00 	cp.b	r10,r11
80008054:	c2 f0       	breq	800080b2 <get_arg+0x17a>
80008056:	36 4b       	mov	r11,100
80008058:	c0 e8       	rjmp	80008074 <get_arg+0x13c>
8000805a:	37 0b       	mov	r11,112
8000805c:	f6 0a 18 00 	cp.b	r10,r11
80008060:	c2 50       	breq	800080aa <get_arg+0x172>
80008062:	e0 8b 00 0d 	brhi	8000807c <get_arg+0x144>
80008066:	36 eb       	mov	r11,110
80008068:	f6 0a 18 00 	cp.b	r10,r11
8000806c:	c1 f0       	breq	800080aa <get_arg+0x172>
8000806e:	e0 8b 00 14 	brhi	80008096 <get_arg+0x15e>
80008072:	36 9b       	mov	r11,105
80008074:	f6 0a 18 00 	cp.b	r10,r11
80008078:	c1 e1       	brne	800080b4 <get_arg+0x17c>
8000807a:	c0 e8       	rjmp	80008096 <get_arg+0x15e>
8000807c:	37 5b       	mov	r11,117
8000807e:	f6 0a 18 00 	cp.b	r10,r11
80008082:	c0 a0       	breq	80008096 <get_arg+0x15e>
80008084:	37 8b       	mov	r11,120
80008086:	f6 0a 18 00 	cp.b	r10,r11
8000808a:	c0 60       	breq	80008096 <get_arg+0x15e>
8000808c:	37 3b       	mov	r11,115
8000808e:	f6 0a 18 00 	cp.b	r10,r11
80008092:	c1 11       	brne	800080b4 <get_arg+0x17c>
80008094:	c0 b8       	rjmp	800080aa <get_arg+0x172>
80008096:	ed b4 00 04 	bld	r4,0x4
8000809a:	c0 a0       	breq	800080ae <get_arg+0x176>
8000809c:	ed b4 00 05 	bld	r4,0x5
800080a0:	c0 91       	brne	800080b2 <get_arg+0x17a>
800080a2:	30 20       	mov	r0,2
800080a4:	c0 88       	rjmp	800080b4 <get_arg+0x17c>
800080a6:	30 40       	mov	r0,4
800080a8:	c0 68       	rjmp	800080b4 <get_arg+0x17c>
800080aa:	30 30       	mov	r0,3
800080ac:	c0 48       	rjmp	800080b4 <get_arg+0x17c>
800080ae:	30 10       	mov	r0,1
800080b0:	c0 28       	rjmp	800080b4 <get_arg+0x17c>
800080b2:	30 00       	mov	r0,0
800080b4:	40 3b       	lddsp	r11,sp[0xc]
800080b6:	5b fb       	cp.w	r11,-1
800080b8:	c0 40       	breq	800080c0 <get_arg+0x188>
800080ba:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800080be:	c7 08       	rjmp	8000819e <get_arg+0x266>
800080c0:	58 60       	cp.w	r0,6
800080c2:	e0 8b 00 6e 	brhi	8000819e <get_arg+0x266>
800080c6:	6c 0a       	ld.w	r10,r6[0x0]
800080c8:	ea cc ff ff 	sub	r12,r5,-1
800080cc:	fe ce a2 00 	sub	lr,pc,-24064
800080d0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800080d4:	f4 cb ff f8 	sub	r11,r10,-8
800080d8:	8d 0b       	st.w	r6[0x0],r11
800080da:	f4 ea 00 00 	ld.d	r10,r10[0]
800080de:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800080e2:	c0 f8       	rjmp	80008100 <get_arg+0x1c8>
800080e4:	f4 cb ff fc 	sub	r11,r10,-4
800080e8:	8d 0b       	st.w	r6[0x0],r11
800080ea:	74 0a       	ld.w	r10,r10[0x0]
800080ec:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800080f0:	c0 88       	rjmp	80008100 <get_arg+0x1c8>
800080f2:	f4 cb ff f8 	sub	r11,r10,-8
800080f6:	8d 0b       	st.w	r6[0x0],r11
800080f8:	f4 ea 00 00 	ld.d	r10,r10[0]
800080fc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008100:	0e 9b       	mov	r11,r7
80008102:	18 95       	mov	r5,r12
80008104:	c4 e8       	rjmp	800081a0 <get_arg+0x268>
80008106:	62 0a       	ld.w	r10,r1[0x0]
80008108:	5b fa       	cp.w	r10,-1
8000810a:	c0 b1       	brne	80008120 <get_arg+0x1e8>
8000810c:	50 19       	stdsp	sp[0x4],r9
8000810e:	50 28       	stdsp	sp[0x8],r8
80008110:	e0 6a 00 80 	mov	r10,128
80008114:	30 0b       	mov	r11,0
80008116:	02 9c       	mov	r12,r1
80008118:	fe b0 fd 01 	rcall	80007b1a <memset>
8000811c:	40 28       	lddsp	r8,sp[0x8]
8000811e:	40 19       	lddsp	r9,sp[0x4]
80008120:	e4 cc 00 01 	sub	r12,r2,1
80008124:	0e 9b       	mov	r11,r7
80008126:	50 3c       	stdsp	sp[0xc],r12
80008128:	f2 0c 0c 49 	max	r9,r9,r12
8000812c:	c3 a8       	rjmp	800081a0 <get_arg+0x268>
8000812e:	62 0a       	ld.w	r10,r1[0x0]
80008130:	5b fa       	cp.w	r10,-1
80008132:	c0 b1       	brne	80008148 <get_arg+0x210>
80008134:	50 19       	stdsp	sp[0x4],r9
80008136:	50 28       	stdsp	sp[0x8],r8
80008138:	e0 6a 00 80 	mov	r10,128
8000813c:	30 0b       	mov	r11,0
8000813e:	02 9c       	mov	r12,r1
80008140:	fe b0 fc ed 	rcall	80007b1a <memset>
80008144:	40 28       	lddsp	r8,sp[0x8]
80008146:	40 19       	lddsp	r9,sp[0x4]
80008148:	20 12       	sub	r2,1
8000814a:	30 0a       	mov	r10,0
8000814c:	0e 9b       	mov	r11,r7
8000814e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008152:	f2 02 0c 49 	max	r9,r9,r2
80008156:	c2 58       	rjmp	800081a0 <get_arg+0x268>
80008158:	16 97       	mov	r7,r11
8000815a:	6c 0a       	ld.w	r10,r6[0x0]
8000815c:	f4 cb ff fc 	sub	r11,r10,-4
80008160:	8d 0b       	st.w	r6[0x0],r11
80008162:	74 0a       	ld.w	r10,r10[0x0]
80008164:	0e 9b       	mov	r11,r7
80008166:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000816a:	2f f5       	sub	r5,-1
8000816c:	c1 a8       	rjmp	800081a0 <get_arg+0x268>
8000816e:	f4 c2 00 30 	sub	r2,r10,48
80008172:	c0 68       	rjmp	8000817e <get_arg+0x246>
80008174:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008178:	2f f7       	sub	r7,-1
8000817a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000817e:	0f 8a       	ld.ub	r10,r7[0x0]
80008180:	58 0a       	cp.w	r10,0
80008182:	c0 e0       	breq	8000819e <get_arg+0x266>
80008184:	23 0a       	sub	r10,48
80008186:	58 9a       	cp.w	r10,9
80008188:	fe 98 ff f6 	brls	80008174 <get_arg+0x23c>
8000818c:	c0 98       	rjmp	8000819e <get_arg+0x266>
8000818e:	2f f7       	sub	r7,-1
80008190:	0f 8a       	ld.ub	r10,r7[0x0]
80008192:	58 0a       	cp.w	r10,0
80008194:	c0 50       	breq	8000819e <get_arg+0x266>
80008196:	23 0a       	sub	r10,48
80008198:	58 9a       	cp.w	r10,9
8000819a:	fe 98 ff fa 	brls	8000818e <get_arg+0x256>
8000819e:	0e 9b       	mov	r11,r7
800081a0:	40 7c       	lddsp	r12,sp[0x1c]
800081a2:	30 ba       	mov	r10,11
800081a4:	f4 0c 18 00 	cp.b	r12,r10
800081a8:	fe 91 fe f2 	brne	80007f8c <get_arg+0x54>
800081ac:	40 42       	lddsp	r2,sp[0x10]
800081ae:	17 8c       	ld.ub	r12,r11[0x0]
800081b0:	0a 32       	cp.w	r2,r5
800081b2:	5f 4a       	srge	r10
800081b4:	f0 0c 18 00 	cp.b	r12,r8
800081b8:	5f 1c       	srne	r12
800081ba:	f9 ea 00 0a 	and	r10,r12,r10
800081be:	f0 0a 18 00 	cp.b	r10,r8
800081c2:	fe 91 fe cf 	brne	80007f60 <get_arg+0x28>
800081c6:	30 08       	mov	r8,0
800081c8:	40 4e       	lddsp	lr,sp[0x10]
800081ca:	17 8a       	ld.ub	r10,r11[0x0]
800081cc:	e2 05 00 21 	add	r1,r1,r5<<0x2
800081d0:	f0 0a 18 00 	cp.b	r10,r8
800081d4:	fc 09 17 10 	movne	r9,lr
800081d8:	e6 05 00 38 	add	r8,r3,r5<<0x3
800081dc:	06 9e       	mov	lr,r3
800081de:	c2 a8       	rjmp	80008232 <get_arg+0x2fa>
800081e0:	62 0a       	ld.w	r10,r1[0x0]
800081e2:	58 3a       	cp.w	r10,3
800081e4:	c1 e0       	breq	80008220 <get_arg+0x2e8>
800081e6:	e0 89 00 07 	brgt	800081f4 <get_arg+0x2bc>
800081ea:	58 1a       	cp.w	r10,1
800081ec:	c1 a0       	breq	80008220 <get_arg+0x2e8>
800081ee:	58 2a       	cp.w	r10,2
800081f0:	c1 81       	brne	80008220 <get_arg+0x2e8>
800081f2:	c0 58       	rjmp	800081fc <get_arg+0x2c4>
800081f4:	58 5a       	cp.w	r10,5
800081f6:	c0 c0       	breq	8000820e <get_arg+0x2d6>
800081f8:	c0 b5       	brlt	8000820e <get_arg+0x2d6>
800081fa:	c1 38       	rjmp	80008220 <get_arg+0x2e8>
800081fc:	6c 0a       	ld.w	r10,r6[0x0]
800081fe:	f4 cc ff f8 	sub	r12,r10,-8
80008202:	8d 0c       	st.w	r6[0x0],r12
80008204:	f4 e2 00 00 	ld.d	r2,r10[0]
80008208:	f0 e3 00 00 	st.d	r8[0],r2
8000820c:	c1 08       	rjmp	8000822c <get_arg+0x2f4>
8000820e:	6c 0a       	ld.w	r10,r6[0x0]
80008210:	f4 cc ff f8 	sub	r12,r10,-8
80008214:	8d 0c       	st.w	r6[0x0],r12
80008216:	f4 e2 00 00 	ld.d	r2,r10[0]
8000821a:	f0 e3 00 00 	st.d	r8[0],r2
8000821e:	c0 78       	rjmp	8000822c <get_arg+0x2f4>
80008220:	6c 0a       	ld.w	r10,r6[0x0]
80008222:	f4 cc ff fc 	sub	r12,r10,-4
80008226:	8d 0c       	st.w	r6[0x0],r12
80008228:	74 0a       	ld.w	r10,r10[0x0]
8000822a:	91 0a       	st.w	r8[0x0],r10
8000822c:	2f f5       	sub	r5,-1
8000822e:	2f 88       	sub	r8,-8
80008230:	2f c1       	sub	r1,-4
80008232:	12 35       	cp.w	r5,r9
80008234:	fe 9a ff d6 	brle	800081e0 <get_arg+0x2a8>
80008238:	1c 93       	mov	r3,lr
8000823a:	40 52       	lddsp	r2,sp[0x14]
8000823c:	40 6e       	lddsp	lr,sp[0x18]
8000823e:	85 05       	st.w	r2[0x0],r5
80008240:	9d 0b       	st.w	lr[0x0],r11
80008242:	40 4b       	lddsp	r11,sp[0x10]
80008244:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008248:	2f 8d       	sub	sp,-32
8000824a:	d8 32       	popm	r0-r7,pc

8000824c <__sprint_r>:
8000824c:	d4 21       	pushm	r4-r7,lr
8000824e:	14 97       	mov	r7,r10
80008250:	74 28       	ld.w	r8,r10[0x8]
80008252:	58 08       	cp.w	r8,0
80008254:	c0 41       	brne	8000825c <__sprint_r+0x10>
80008256:	95 18       	st.w	r10[0x4],r8
80008258:	10 9c       	mov	r12,r8
8000825a:	d8 22       	popm	r4-r7,pc
8000825c:	e0 a0 18 ba 	rcall	8000b3d0 <__sfvwrite_r>
80008260:	30 08       	mov	r8,0
80008262:	8f 18       	st.w	r7[0x4],r8
80008264:	8f 28       	st.w	r7[0x8],r8
80008266:	d8 22       	popm	r4-r7,pc

80008268 <_vfprintf_r>:
80008268:	d4 31       	pushm	r0-r7,lr
8000826a:	fa cd 06 bc 	sub	sp,sp,1724
8000826e:	51 09       	stdsp	sp[0x40],r9
80008270:	16 91       	mov	r1,r11
80008272:	14 97       	mov	r7,r10
80008274:	18 95       	mov	r5,r12
80008276:	e0 a0 1a 1d 	rcall	8000b6b0 <_localeconv_r>
8000827a:	78 0c       	ld.w	r12,r12[0x0]
8000827c:	50 cc       	stdsp	sp[0x30],r12
8000827e:	58 05       	cp.w	r5,0
80008280:	c0 70       	breq	8000828e <_vfprintf_r+0x26>
80008282:	6a 68       	ld.w	r8,r5[0x18]
80008284:	58 08       	cp.w	r8,0
80008286:	c0 41       	brne	8000828e <_vfprintf_r+0x26>
80008288:	0a 9c       	mov	r12,r5
8000828a:	e0 a0 17 43 	rcall	8000b110 <__sinit>
8000828e:	fe c8 9f fe 	sub	r8,pc,-24578
80008292:	10 31       	cp.w	r1,r8
80008294:	c0 31       	brne	8000829a <_vfprintf_r+0x32>
80008296:	6a 01       	ld.w	r1,r5[0x0]
80008298:	c0 c8       	rjmp	800082b0 <_vfprintf_r+0x48>
8000829a:	fe c8 9f ea 	sub	r8,pc,-24598
8000829e:	10 31       	cp.w	r1,r8
800082a0:	c0 31       	brne	800082a6 <_vfprintf_r+0x3e>
800082a2:	6a 11       	ld.w	r1,r5[0x4]
800082a4:	c0 68       	rjmp	800082b0 <_vfprintf_r+0x48>
800082a6:	fe c8 9f d6 	sub	r8,pc,-24618
800082aa:	10 31       	cp.w	r1,r8
800082ac:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800082b0:	82 68       	ld.sh	r8,r1[0xc]
800082b2:	ed b8 00 03 	bld	r8,0x3
800082b6:	c0 41       	brne	800082be <_vfprintf_r+0x56>
800082b8:	62 48       	ld.w	r8,r1[0x10]
800082ba:	58 08       	cp.w	r8,0
800082bc:	c0 71       	brne	800082ca <_vfprintf_r+0x62>
800082be:	02 9b       	mov	r11,r1
800082c0:	0a 9c       	mov	r12,r5
800082c2:	e0 a0 0f 5d 	rcall	8000a17c <__swsetup_r>
800082c6:	e0 81 0f 54 	brne	8000a16e <_vfprintf_r+0x1f06>
800082ca:	82 68       	ld.sh	r8,r1[0xc]
800082cc:	10 99       	mov	r9,r8
800082ce:	e2 19 00 1a 	andl	r9,0x1a,COH
800082d2:	58 a9       	cp.w	r9,10
800082d4:	c3 c1       	brne	8000834c <_vfprintf_r+0xe4>
800082d6:	82 79       	ld.sh	r9,r1[0xe]
800082d8:	30 0a       	mov	r10,0
800082da:	f4 09 19 00 	cp.h	r9,r10
800082de:	c3 75       	brlt	8000834c <_vfprintf_r+0xe4>
800082e0:	a1 d8       	cbr	r8,0x1
800082e2:	fb 58 05 d0 	st.h	sp[1488],r8
800082e6:	62 88       	ld.w	r8,r1[0x20]
800082e8:	fb 48 05 e4 	st.w	sp[1508],r8
800082ec:	62 a8       	ld.w	r8,r1[0x28]
800082ee:	fb 48 05 ec 	st.w	sp[1516],r8
800082f2:	fa c8 ff bc 	sub	r8,sp,-68
800082f6:	fb 48 05 d4 	st.w	sp[1492],r8
800082fa:	fb 48 05 c4 	st.w	sp[1476],r8
800082fe:	e0 68 04 00 	mov	r8,1024
80008302:	fb 48 05 d8 	st.w	sp[1496],r8
80008306:	fb 48 05 cc 	st.w	sp[1484],r8
8000830a:	30 08       	mov	r8,0
8000830c:	fb 59 05 d2 	st.h	sp[1490],r9
80008310:	0e 9a       	mov	r10,r7
80008312:	41 09       	lddsp	r9,sp[0x40]
80008314:	fa c7 fa 3c 	sub	r7,sp,-1476
80008318:	fb 48 05 dc 	st.w	sp[1500],r8
8000831c:	0a 9c       	mov	r12,r5
8000831e:	0e 9b       	mov	r11,r7
80008320:	ca 4f       	rcall	80008268 <_vfprintf_r>
80008322:	50 bc       	stdsp	sp[0x2c],r12
80008324:	c0 95       	brlt	80008336 <_vfprintf_r+0xce>
80008326:	0e 9b       	mov	r11,r7
80008328:	0a 9c       	mov	r12,r5
8000832a:	e0 a0 16 1b 	rcall	8000af60 <_fflush_r>
8000832e:	40 be       	lddsp	lr,sp[0x2c]
80008330:	f9 be 01 ff 	movne	lr,-1
80008334:	50 be       	stdsp	sp[0x2c],lr
80008336:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000833a:	ed b8 00 06 	bld	r8,0x6
8000833e:	e0 81 0f 1a 	brne	8000a172 <_vfprintf_r+0x1f0a>
80008342:	82 68       	ld.sh	r8,r1[0xc]
80008344:	a7 a8       	sbr	r8,0x6
80008346:	a2 68       	st.h	r1[0xc],r8
80008348:	e0 8f 0f 15 	bral	8000a172 <_vfprintf_r+0x1f0a>
8000834c:	30 08       	mov	r8,0
8000834e:	fb 48 06 b4 	st.w	sp[1716],r8
80008352:	fb 48 06 90 	st.w	sp[1680],r8
80008356:	fb 48 06 8c 	st.w	sp[1676],r8
8000835a:	fb 48 06 b0 	st.w	sp[1712],r8
8000835e:	30 08       	mov	r8,0
80008360:	30 09       	mov	r9,0
80008362:	50 a7       	stdsp	sp[0x28],r7
80008364:	50 78       	stdsp	sp[0x1c],r8
80008366:	fa c3 f9 e0 	sub	r3,sp,-1568
8000836a:	3f f8       	mov	r8,-1
8000836c:	50 59       	stdsp	sp[0x14],r9
8000836e:	fb 43 06 88 	st.w	sp[1672],r3
80008372:	fb 48 05 44 	st.w	sp[1348],r8
80008376:	12 9c       	mov	r12,r9
80008378:	50 69       	stdsp	sp[0x18],r9
8000837a:	50 d9       	stdsp	sp[0x34],r9
8000837c:	50 e9       	stdsp	sp[0x38],r9
8000837e:	50 b9       	stdsp	sp[0x2c],r9
80008380:	12 97       	mov	r7,r9
80008382:	0a 94       	mov	r4,r5
80008384:	40 a2       	lddsp	r2,sp[0x28]
80008386:	32 5a       	mov	r10,37
80008388:	30 08       	mov	r8,0
8000838a:	c0 28       	rjmp	8000838e <_vfprintf_r+0x126>
8000838c:	2f f2       	sub	r2,-1
8000838e:	05 89       	ld.ub	r9,r2[0x0]
80008390:	f0 09 18 00 	cp.b	r9,r8
80008394:	5f 1b       	srne	r11
80008396:	f4 09 18 00 	cp.b	r9,r10
8000839a:	5f 19       	srne	r9
8000839c:	f3 eb 00 0b 	and	r11,r9,r11
800083a0:	f0 0b 18 00 	cp.b	r11,r8
800083a4:	cf 41       	brne	8000838c <_vfprintf_r+0x124>
800083a6:	40 ab       	lddsp	r11,sp[0x28]
800083a8:	e4 0b 01 06 	sub	r6,r2,r11
800083ac:	c1 e0       	breq	800083e8 <_vfprintf_r+0x180>
800083ae:	fa f8 06 90 	ld.w	r8,sp[1680]
800083b2:	0c 08       	add	r8,r6
800083b4:	87 0b       	st.w	r3[0x0],r11
800083b6:	fb 48 06 90 	st.w	sp[1680],r8
800083ba:	87 16       	st.w	r3[0x4],r6
800083bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800083c0:	2f f8       	sub	r8,-1
800083c2:	fb 48 06 8c 	st.w	sp[1676],r8
800083c6:	58 78       	cp.w	r8,7
800083c8:	e0 89 00 04 	brgt	800083d0 <_vfprintf_r+0x168>
800083cc:	2f 83       	sub	r3,-8
800083ce:	c0 a8       	rjmp	800083e2 <_vfprintf_r+0x17a>
800083d0:	fa ca f9 78 	sub	r10,sp,-1672
800083d4:	02 9b       	mov	r11,r1
800083d6:	08 9c       	mov	r12,r4
800083d8:	c3 af       	rcall	8000824c <__sprint_r>
800083da:	e0 81 0e c6 	brne	8000a166 <_vfprintf_r+0x1efe>
800083de:	fa c3 f9 e0 	sub	r3,sp,-1568
800083e2:	40 ba       	lddsp	r10,sp[0x2c]
800083e4:	0c 0a       	add	r10,r6
800083e6:	50 ba       	stdsp	sp[0x2c],r10
800083e8:	05 89       	ld.ub	r9,r2[0x0]
800083ea:	30 08       	mov	r8,0
800083ec:	f0 09 18 00 	cp.b	r9,r8
800083f0:	e0 80 0e aa 	breq	8000a144 <_vfprintf_r+0x1edc>
800083f4:	30 09       	mov	r9,0
800083f6:	fb 68 06 bb 	st.b	sp[1723],r8
800083fa:	0e 96       	mov	r6,r7
800083fc:	e4 c8 ff ff 	sub	r8,r2,-1
80008400:	3f fe       	mov	lr,-1
80008402:	50 93       	stdsp	sp[0x24],r3
80008404:	50 41       	stdsp	sp[0x10],r1
80008406:	0e 93       	mov	r3,r7
80008408:	04 91       	mov	r1,r2
8000840a:	50 89       	stdsp	sp[0x20],r9
8000840c:	50 a8       	stdsp	sp[0x28],r8
8000840e:	50 2e       	stdsp	sp[0x8],lr
80008410:	50 39       	stdsp	sp[0xc],r9
80008412:	12 95       	mov	r5,r9
80008414:	12 90       	mov	r0,r9
80008416:	10 97       	mov	r7,r8
80008418:	08 92       	mov	r2,r4
8000841a:	c0 78       	rjmp	80008428 <_vfprintf_r+0x1c0>
8000841c:	3f fc       	mov	r12,-1
8000841e:	08 97       	mov	r7,r4
80008420:	50 2c       	stdsp	sp[0x8],r12
80008422:	c0 38       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008424:	30 0b       	mov	r11,0
80008426:	50 3b       	stdsp	sp[0xc],r11
80008428:	0f 38       	ld.ub	r8,r7++
8000842a:	c0 28       	rjmp	8000842e <_vfprintf_r+0x1c6>
8000842c:	12 90       	mov	r0,r9
8000842e:	f0 c9 00 20 	sub	r9,r8,32
80008432:	e0 49 00 58 	cp.w	r9,88
80008436:	e0 8b 0a 30 	brhi	80009896 <_vfprintf_r+0x162e>
8000843a:	fe ca a5 52 	sub	r10,pc,-23214
8000843e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008442:	50 a7       	stdsp	sp[0x28],r7
80008444:	50 80       	stdsp	sp[0x20],r0
80008446:	0c 97       	mov	r7,r6
80008448:	04 94       	mov	r4,r2
8000844a:	06 96       	mov	r6,r3
8000844c:	02 92       	mov	r2,r1
8000844e:	fe c9 a3 2a 	sub	r9,pc,-23766
80008452:	40 93       	lddsp	r3,sp[0x24]
80008454:	10 90       	mov	r0,r8
80008456:	40 41       	lddsp	r1,sp[0x10]
80008458:	50 d9       	stdsp	sp[0x34],r9
8000845a:	e0 8f 08 8e 	bral	80009576 <_vfprintf_r+0x130e>
8000845e:	30 08       	mov	r8,0
80008460:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008464:	f0 09 18 00 	cp.b	r9,r8
80008468:	ce 01       	brne	80008428 <_vfprintf_r+0x1c0>
8000846a:	32 08       	mov	r8,32
8000846c:	c6 e8       	rjmp	80008548 <_vfprintf_r+0x2e0>
8000846e:	a1 a5       	sbr	r5,0x0
80008470:	cd cb       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008472:	0f 89       	ld.ub	r9,r7[0x0]
80008474:	f2 c8 00 30 	sub	r8,r9,48
80008478:	58 98       	cp.w	r8,9
8000847a:	e0 8b 00 1d 	brhi	800084b4 <_vfprintf_r+0x24c>
8000847e:	ee c8 ff ff 	sub	r8,r7,-1
80008482:	30 0b       	mov	r11,0
80008484:	23 09       	sub	r9,48
80008486:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000848a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000848e:	11 39       	ld.ub	r9,r8++
80008490:	f2 ca 00 30 	sub	r10,r9,48
80008494:	58 9a       	cp.w	r10,9
80008496:	fe 98 ff f7 	brls	80008484 <_vfprintf_r+0x21c>
8000849a:	e0 49 00 24 	cp.w	r9,36
8000849e:	cc 31       	brne	80008424 <_vfprintf_r+0x1bc>
800084a0:	e0 4b 00 20 	cp.w	r11,32
800084a4:	e0 89 0e 60 	brgt	8000a164 <_vfprintf_r+0x1efc>
800084a8:	20 1b       	sub	r11,1
800084aa:	fa f9 06 b4 	ld.w	r9,sp[1716]
800084ae:	12 3b       	cp.w	r11,r9
800084b0:	c0 95       	brlt	800084c2 <_vfprintf_r+0x25a>
800084b2:	c1 08       	rjmp	800084d2 <_vfprintf_r+0x26a>
800084b4:	fa f9 06 b4 	ld.w	r9,sp[1716]
800084b8:	ec ca ff ff 	sub	r10,r6,-1
800084bc:	12 36       	cp.w	r6,r9
800084be:	c1 f5       	brlt	800084fc <_vfprintf_r+0x294>
800084c0:	c2 68       	rjmp	8000850c <_vfprintf_r+0x2a4>
800084c2:	fa ce f9 44 	sub	lr,sp,-1724
800084c6:	10 97       	mov	r7,r8
800084c8:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800084cc:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800084d0:	c3 58       	rjmp	8000853a <_vfprintf_r+0x2d2>
800084d2:	10 97       	mov	r7,r8
800084d4:	fa c8 f9 50 	sub	r8,sp,-1712
800084d8:	1a d8       	st.w	--sp,r8
800084da:	fa c8 fa b8 	sub	r8,sp,-1352
800084de:	1a d8       	st.w	--sp,r8
800084e0:	fa c8 fb b4 	sub	r8,sp,-1100
800084e4:	02 9a       	mov	r10,r1
800084e6:	1a d8       	st.w	--sp,r8
800084e8:	04 9c       	mov	r12,r2
800084ea:	fa c8 f9 40 	sub	r8,sp,-1728
800084ee:	fa c9 ff b4 	sub	r9,sp,-76
800084f2:	fe b0 fd 23 	rcall	80007f38 <get_arg>
800084f6:	2f dd       	sub	sp,-12
800084f8:	78 00       	ld.w	r0,r12[0x0]
800084fa:	c2 08       	rjmp	8000853a <_vfprintf_r+0x2d2>
800084fc:	fa cc f9 44 	sub	r12,sp,-1724
80008500:	14 96       	mov	r6,r10
80008502:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008506:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000850a:	c1 88       	rjmp	8000853a <_vfprintf_r+0x2d2>
8000850c:	41 08       	lddsp	r8,sp[0x40]
8000850e:	59 f9       	cp.w	r9,31
80008510:	e0 89 00 11 	brgt	80008532 <_vfprintf_r+0x2ca>
80008514:	f0 cb ff fc 	sub	r11,r8,-4
80008518:	51 0b       	stdsp	sp[0x40],r11
8000851a:	70 00       	ld.w	r0,r8[0x0]
8000851c:	fa cb f9 44 	sub	r11,sp,-1724
80008520:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008524:	f1 40 fd 88 	st.w	r8[-632],r0
80008528:	2f f9       	sub	r9,-1
8000852a:	14 96       	mov	r6,r10
8000852c:	fb 49 06 b4 	st.w	sp[1716],r9
80008530:	c0 58       	rjmp	8000853a <_vfprintf_r+0x2d2>
80008532:	70 00       	ld.w	r0,r8[0x0]
80008534:	14 96       	mov	r6,r10
80008536:	2f c8       	sub	r8,-4
80008538:	51 08       	stdsp	sp[0x40],r8
8000853a:	58 00       	cp.w	r0,0
8000853c:	fe 94 ff 76 	brge	80008428 <_vfprintf_r+0x1c0>
80008540:	5c 30       	neg	r0
80008542:	a3 a5       	sbr	r5,0x2
80008544:	c7 2b       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008546:	32 b8       	mov	r8,43
80008548:	fb 68 06 bb 	st.b	sp[1723],r8
8000854c:	c6 eb       	rjmp	80008428 <_vfprintf_r+0x1c0>
8000854e:	0f 38       	ld.ub	r8,r7++
80008550:	e0 48 00 2a 	cp.w	r8,42
80008554:	c0 30       	breq	8000855a <_vfprintf_r+0x2f2>
80008556:	30 09       	mov	r9,0
80008558:	c7 98       	rjmp	8000864a <_vfprintf_r+0x3e2>
8000855a:	0f 88       	ld.ub	r8,r7[0x0]
8000855c:	f0 c9 00 30 	sub	r9,r8,48
80008560:	58 99       	cp.w	r9,9
80008562:	e0 8b 00 1f 	brhi	800085a0 <_vfprintf_r+0x338>
80008566:	ee c4 ff ff 	sub	r4,r7,-1
8000856a:	30 0b       	mov	r11,0
8000856c:	23 08       	sub	r8,48
8000856e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008572:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008576:	09 38       	ld.ub	r8,r4++
80008578:	f0 c9 00 30 	sub	r9,r8,48
8000857c:	58 99       	cp.w	r9,9
8000857e:	fe 98 ff f7 	brls	8000856c <_vfprintf_r+0x304>
80008582:	e0 48 00 24 	cp.w	r8,36
80008586:	fe 91 ff 4f 	brne	80008424 <_vfprintf_r+0x1bc>
8000858a:	e0 4b 00 20 	cp.w	r11,32
8000858e:	e0 89 0d eb 	brgt	8000a164 <_vfprintf_r+0x1efc>
80008592:	20 1b       	sub	r11,1
80008594:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008598:	10 3b       	cp.w	r11,r8
8000859a:	c0 a5       	brlt	800085ae <_vfprintf_r+0x346>
8000859c:	c1 18       	rjmp	800085be <_vfprintf_r+0x356>
8000859e:	d7 03       	nop
800085a0:	fa fa 06 b4 	ld.w	r10,sp[1716]
800085a4:	ec c9 ff ff 	sub	r9,r6,-1
800085a8:	14 36       	cp.w	r6,r10
800085aa:	c1 f5       	brlt	800085e8 <_vfprintf_r+0x380>
800085ac:	c2 88       	rjmp	800085fc <_vfprintf_r+0x394>
800085ae:	fa ca f9 44 	sub	r10,sp,-1724
800085b2:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800085b6:	f6 fb fd 88 	ld.w	r11,r11[-632]
800085ba:	50 2b       	stdsp	sp[0x8],r11
800085bc:	c3 c8       	rjmp	80008634 <_vfprintf_r+0x3cc>
800085be:	fa c8 f9 50 	sub	r8,sp,-1712
800085c2:	1a d8       	st.w	--sp,r8
800085c4:	fa c8 fa b8 	sub	r8,sp,-1352
800085c8:	1a d8       	st.w	--sp,r8
800085ca:	fa c8 fb b4 	sub	r8,sp,-1100
800085ce:	02 9a       	mov	r10,r1
800085d0:	1a d8       	st.w	--sp,r8
800085d2:	04 9c       	mov	r12,r2
800085d4:	fa c8 f9 40 	sub	r8,sp,-1728
800085d8:	fa c9 ff b4 	sub	r9,sp,-76
800085dc:	fe b0 fc ae 	rcall	80007f38 <get_arg>
800085e0:	2f dd       	sub	sp,-12
800085e2:	78 0c       	ld.w	r12,r12[0x0]
800085e4:	50 2c       	stdsp	sp[0x8],r12
800085e6:	c2 78       	rjmp	80008634 <_vfprintf_r+0x3cc>
800085e8:	12 96       	mov	r6,r9
800085ea:	0e 94       	mov	r4,r7
800085ec:	fa c9 f9 44 	sub	r9,sp,-1724
800085f0:	f2 03 00 38 	add	r8,r9,r3<<0x3
800085f4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800085f8:	50 28       	stdsp	sp[0x8],r8
800085fa:	c1 d8       	rjmp	80008634 <_vfprintf_r+0x3cc>
800085fc:	41 08       	lddsp	r8,sp[0x40]
800085fe:	59 fa       	cp.w	r10,31
80008600:	e0 89 00 14 	brgt	80008628 <_vfprintf_r+0x3c0>
80008604:	f0 cb ff fc 	sub	r11,r8,-4
80008608:	70 08       	ld.w	r8,r8[0x0]
8000860a:	51 0b       	stdsp	sp[0x40],r11
8000860c:	50 28       	stdsp	sp[0x8],r8
8000860e:	fa c6 f9 44 	sub	r6,sp,-1724
80008612:	40 2e       	lddsp	lr,sp[0x8]
80008614:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008618:	f1 4e fd 88 	st.w	r8[-632],lr
8000861c:	2f fa       	sub	r10,-1
8000861e:	0e 94       	mov	r4,r7
80008620:	fb 4a 06 b4 	st.w	sp[1716],r10
80008624:	12 96       	mov	r6,r9
80008626:	c0 78       	rjmp	80008634 <_vfprintf_r+0x3cc>
80008628:	70 0c       	ld.w	r12,r8[0x0]
8000862a:	0e 94       	mov	r4,r7
8000862c:	2f c8       	sub	r8,-4
8000862e:	50 2c       	stdsp	sp[0x8],r12
80008630:	12 96       	mov	r6,r9
80008632:	51 08       	stdsp	sp[0x40],r8
80008634:	40 2b       	lddsp	r11,sp[0x8]
80008636:	58 0b       	cp.w	r11,0
80008638:	fe 95 fe f2 	brlt	8000841c <_vfprintf_r+0x1b4>
8000863c:	08 97       	mov	r7,r4
8000863e:	cf 5a       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008640:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008644:	0f 38       	ld.ub	r8,r7++
80008646:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000864a:	f0 ca 00 30 	sub	r10,r8,48
8000864e:	58 9a       	cp.w	r10,9
80008650:	fe 98 ff f8 	brls	80008640 <_vfprintf_r+0x3d8>
80008654:	3f fa       	mov	r10,-1
80008656:	f2 0a 0c 49 	max	r9,r9,r10
8000865a:	50 29       	stdsp	sp[0x8],r9
8000865c:	ce 9a       	rjmp	8000842e <_vfprintf_r+0x1c6>
8000865e:	a7 b5       	sbr	r5,0x7
80008660:	ce 4a       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008662:	30 09       	mov	r9,0
80008664:	23 08       	sub	r8,48
80008666:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000866a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000866e:	0f 38       	ld.ub	r8,r7++
80008670:	f0 ca 00 30 	sub	r10,r8,48
80008674:	58 9a       	cp.w	r10,9
80008676:	fe 98 ff f7 	brls	80008664 <_vfprintf_r+0x3fc>
8000867a:	e0 48 00 24 	cp.w	r8,36
8000867e:	fe 91 fe d7 	brne	8000842c <_vfprintf_r+0x1c4>
80008682:	e0 49 00 20 	cp.w	r9,32
80008686:	e0 89 0d 6f 	brgt	8000a164 <_vfprintf_r+0x1efc>
8000868a:	f2 c3 00 01 	sub	r3,r9,1
8000868e:	30 19       	mov	r9,1
80008690:	50 39       	stdsp	sp[0xc],r9
80008692:	cc ba       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008694:	a3 b5       	sbr	r5,0x3
80008696:	cc 9a       	rjmp	80008428 <_vfprintf_r+0x1c0>
80008698:	a7 a5       	sbr	r5,0x6
8000869a:	cc 7a       	rjmp	80008428 <_vfprintf_r+0x1c0>
8000869c:	0a 98       	mov	r8,r5
8000869e:	a5 b5       	sbr	r5,0x5
800086a0:	a5 a8       	sbr	r8,0x4
800086a2:	0f 89       	ld.ub	r9,r7[0x0]
800086a4:	36 ce       	mov	lr,108
800086a6:	fc 09 18 00 	cp.b	r9,lr
800086aa:	f7 b7 00 ff 	subeq	r7,-1
800086ae:	f0 05 17 10 	movne	r5,r8
800086b2:	cb ba       	rjmp	80008428 <_vfprintf_r+0x1c0>
800086b4:	a5 b5       	sbr	r5,0x5
800086b6:	cb 9a       	rjmp	80008428 <_vfprintf_r+0x1c0>
800086b8:	50 a7       	stdsp	sp[0x28],r7
800086ba:	50 80       	stdsp	sp[0x20],r0
800086bc:	0c 97       	mov	r7,r6
800086be:	10 90       	mov	r0,r8
800086c0:	06 96       	mov	r6,r3
800086c2:	04 94       	mov	r4,r2
800086c4:	40 93       	lddsp	r3,sp[0x24]
800086c6:	02 92       	mov	r2,r1
800086c8:	0e 99       	mov	r9,r7
800086ca:	40 41       	lddsp	r1,sp[0x10]
800086cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086d0:	40 3c       	lddsp	r12,sp[0xc]
800086d2:	58 0c       	cp.w	r12,0
800086d4:	c1 d0       	breq	8000870e <_vfprintf_r+0x4a6>
800086d6:	10 36       	cp.w	r6,r8
800086d8:	c0 64       	brge	800086e4 <_vfprintf_r+0x47c>
800086da:	fa cb f9 44 	sub	r11,sp,-1724
800086de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086e2:	c1 d8       	rjmp	8000871c <_vfprintf_r+0x4b4>
800086e4:	fa c8 f9 50 	sub	r8,sp,-1712
800086e8:	1a d8       	st.w	--sp,r8
800086ea:	fa c8 fa b8 	sub	r8,sp,-1352
800086ee:	1a d8       	st.w	--sp,r8
800086f0:	fa c8 fb b4 	sub	r8,sp,-1100
800086f4:	1a d8       	st.w	--sp,r8
800086f6:	fa c8 f9 40 	sub	r8,sp,-1728
800086fa:	fa c9 ff b4 	sub	r9,sp,-76
800086fe:	04 9a       	mov	r10,r2
80008700:	0c 9b       	mov	r11,r6
80008702:	08 9c       	mov	r12,r4
80008704:	fe b0 fc 1a 	rcall	80007f38 <get_arg>
80008708:	2f dd       	sub	sp,-12
8000870a:	19 b8       	ld.ub	r8,r12[0x3]
8000870c:	c2 28       	rjmp	80008750 <_vfprintf_r+0x4e8>
8000870e:	2f f7       	sub	r7,-1
80008710:	10 39       	cp.w	r9,r8
80008712:	c0 84       	brge	80008722 <_vfprintf_r+0x4ba>
80008714:	fa ca f9 44 	sub	r10,sp,-1724
80008718:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000871c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008720:	c1 88       	rjmp	80008750 <_vfprintf_r+0x4e8>
80008722:	41 09       	lddsp	r9,sp[0x40]
80008724:	59 f8       	cp.w	r8,31
80008726:	e0 89 00 12 	brgt	8000874a <_vfprintf_r+0x4e2>
8000872a:	f2 ca ff fc 	sub	r10,r9,-4
8000872e:	51 0a       	stdsp	sp[0x40],r10
80008730:	72 09       	ld.w	r9,r9[0x0]
80008732:	fa c6 f9 44 	sub	r6,sp,-1724
80008736:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000873a:	2f f8       	sub	r8,-1
8000873c:	f5 49 fd 88 	st.w	r10[-632],r9
80008740:	fb 48 06 b4 	st.w	sp[1716],r8
80008744:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008748:	c0 48       	rjmp	80008750 <_vfprintf_r+0x4e8>
8000874a:	13 b8       	ld.ub	r8,r9[0x3]
8000874c:	2f c9       	sub	r9,-4
8000874e:	51 09       	stdsp	sp[0x40],r9
80008750:	fb 68 06 60 	st.b	sp[1632],r8
80008754:	30 0e       	mov	lr,0
80008756:	30 08       	mov	r8,0
80008758:	30 12       	mov	r2,1
8000875a:	fb 68 06 bb 	st.b	sp[1723],r8
8000875e:	50 2e       	stdsp	sp[0x8],lr
80008760:	e0 8f 08 ad 	bral	800098ba <_vfprintf_r+0x1652>
80008764:	50 a7       	stdsp	sp[0x28],r7
80008766:	50 80       	stdsp	sp[0x20],r0
80008768:	0c 97       	mov	r7,r6
8000876a:	04 94       	mov	r4,r2
8000876c:	06 96       	mov	r6,r3
8000876e:	02 92       	mov	r2,r1
80008770:	40 93       	lddsp	r3,sp[0x24]
80008772:	10 90       	mov	r0,r8
80008774:	40 41       	lddsp	r1,sp[0x10]
80008776:	a5 a5       	sbr	r5,0x4
80008778:	c0 a8       	rjmp	8000878c <_vfprintf_r+0x524>
8000877a:	50 a7       	stdsp	sp[0x28],r7
8000877c:	50 80       	stdsp	sp[0x20],r0
8000877e:	0c 97       	mov	r7,r6
80008780:	04 94       	mov	r4,r2
80008782:	06 96       	mov	r6,r3
80008784:	02 92       	mov	r2,r1
80008786:	40 93       	lddsp	r3,sp[0x24]
80008788:	10 90       	mov	r0,r8
8000878a:	40 41       	lddsp	r1,sp[0x10]
8000878c:	ed b5 00 05 	bld	r5,0x5
80008790:	c5 11       	brne	80008832 <_vfprintf_r+0x5ca>
80008792:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008796:	40 3c       	lddsp	r12,sp[0xc]
80008798:	58 0c       	cp.w	r12,0
8000879a:	c1 e0       	breq	800087d6 <_vfprintf_r+0x56e>
8000879c:	10 36       	cp.w	r6,r8
8000879e:	c0 64       	brge	800087aa <_vfprintf_r+0x542>
800087a0:	fa cb f9 44 	sub	r11,sp,-1724
800087a4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087a8:	c2 08       	rjmp	800087e8 <_vfprintf_r+0x580>
800087aa:	fa c8 f9 50 	sub	r8,sp,-1712
800087ae:	1a d8       	st.w	--sp,r8
800087b0:	fa c8 fa b8 	sub	r8,sp,-1352
800087b4:	0c 9b       	mov	r11,r6
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fb b4 	sub	r8,sp,-1100
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c9 ff b4 	sub	r9,sp,-76
800087c2:	fa c8 f9 40 	sub	r8,sp,-1728
800087c6:	04 9a       	mov	r10,r2
800087c8:	08 9c       	mov	r12,r4
800087ca:	fe b0 fb b7 	rcall	80007f38 <get_arg>
800087ce:	2f dd       	sub	sp,-12
800087d0:	78 1b       	ld.w	r11,r12[0x4]
800087d2:	78 09       	ld.w	r9,r12[0x0]
800087d4:	c2 b8       	rjmp	8000882a <_vfprintf_r+0x5c2>
800087d6:	ee ca ff ff 	sub	r10,r7,-1
800087da:	10 37       	cp.w	r7,r8
800087dc:	c0 b4       	brge	800087f2 <_vfprintf_r+0x58a>
800087de:	fa c9 f9 44 	sub	r9,sp,-1724
800087e2:	14 97       	mov	r7,r10
800087e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087e8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800087ec:	ec f9 fd 88 	ld.w	r9,r6[-632]
800087f0:	c1 d8       	rjmp	8000882a <_vfprintf_r+0x5c2>
800087f2:	41 09       	lddsp	r9,sp[0x40]
800087f4:	59 f8       	cp.w	r8,31
800087f6:	e0 89 00 14 	brgt	8000881e <_vfprintf_r+0x5b6>
800087fa:	f2 cb ff f8 	sub	r11,r9,-8
800087fe:	51 0b       	stdsp	sp[0x40],r11
80008800:	fa c6 f9 44 	sub	r6,sp,-1724
80008804:	72 1b       	ld.w	r11,r9[0x4]
80008806:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000880a:	72 09       	ld.w	r9,r9[0x0]
8000880c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008810:	f9 49 fd 88 	st.w	r12[-632],r9
80008814:	2f f8       	sub	r8,-1
80008816:	14 97       	mov	r7,r10
80008818:	fb 48 06 b4 	st.w	sp[1716],r8
8000881c:	c0 78       	rjmp	8000882a <_vfprintf_r+0x5c2>
8000881e:	f2 c8 ff f8 	sub	r8,r9,-8
80008822:	72 1b       	ld.w	r11,r9[0x4]
80008824:	14 97       	mov	r7,r10
80008826:	51 08       	stdsp	sp[0x40],r8
80008828:	72 09       	ld.w	r9,r9[0x0]
8000882a:	16 98       	mov	r8,r11
8000882c:	fa e9 00 00 	st.d	sp[0],r8
80008830:	ca e8       	rjmp	8000898c <_vfprintf_r+0x724>
80008832:	ed b5 00 04 	bld	r5,0x4
80008836:	c1 71       	brne	80008864 <_vfprintf_r+0x5fc>
80008838:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000883c:	40 3e       	lddsp	lr,sp[0xc]
8000883e:	58 0e       	cp.w	lr,0
80008840:	c0 80       	breq	80008850 <_vfprintf_r+0x5e8>
80008842:	10 36       	cp.w	r6,r8
80008844:	c6 94       	brge	80008916 <_vfprintf_r+0x6ae>
80008846:	fa cc f9 44 	sub	r12,sp,-1724
8000884a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000884e:	c8 28       	rjmp	80008952 <_vfprintf_r+0x6ea>
80008850:	ee ca ff ff 	sub	r10,r7,-1
80008854:	10 37       	cp.w	r7,r8
80008856:	e0 84 00 81 	brge	80008958 <_vfprintf_r+0x6f0>
8000885a:	fa cb f9 44 	sub	r11,sp,-1724
8000885e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008862:	c7 78       	rjmp	80008950 <_vfprintf_r+0x6e8>
80008864:	ed b5 00 06 	bld	r5,0x6
80008868:	c4 b1       	brne	800088fe <_vfprintf_r+0x696>
8000886a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000886e:	40 3c       	lddsp	r12,sp[0xc]
80008870:	58 0c       	cp.w	r12,0
80008872:	c1 d0       	breq	800088ac <_vfprintf_r+0x644>
80008874:	10 36       	cp.w	r6,r8
80008876:	c0 64       	brge	80008882 <_vfprintf_r+0x61a>
80008878:	fa cb f9 44 	sub	r11,sp,-1724
8000887c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008880:	c1 f8       	rjmp	800088be <_vfprintf_r+0x656>
80008882:	fa c8 f9 50 	sub	r8,sp,-1712
80008886:	1a d8       	st.w	--sp,r8
80008888:	fa c8 fa b8 	sub	r8,sp,-1352
8000888c:	1a d8       	st.w	--sp,r8
8000888e:	fa c8 fb b4 	sub	r8,sp,-1100
80008892:	1a d8       	st.w	--sp,r8
80008894:	fa c8 f9 40 	sub	r8,sp,-1728
80008898:	fa c9 ff b4 	sub	r9,sp,-76
8000889c:	04 9a       	mov	r10,r2
8000889e:	0c 9b       	mov	r11,r6
800088a0:	08 9c       	mov	r12,r4
800088a2:	fe b0 fb 4b 	rcall	80007f38 <get_arg>
800088a6:	2f dd       	sub	sp,-12
800088a8:	98 18       	ld.sh	r8,r12[0x2]
800088aa:	c2 68       	rjmp	800088f6 <_vfprintf_r+0x68e>
800088ac:	ee ca ff ff 	sub	r10,r7,-1
800088b0:	10 37       	cp.w	r7,r8
800088b2:	c0 94       	brge	800088c4 <_vfprintf_r+0x65c>
800088b4:	fa c9 f9 44 	sub	r9,sp,-1724
800088b8:	14 97       	mov	r7,r10
800088ba:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088be:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088c2:	c1 a8       	rjmp	800088f6 <_vfprintf_r+0x68e>
800088c4:	41 09       	lddsp	r9,sp[0x40]
800088c6:	59 f8       	cp.w	r8,31
800088c8:	e0 89 00 13 	brgt	800088ee <_vfprintf_r+0x686>
800088cc:	f2 cb ff fc 	sub	r11,r9,-4
800088d0:	51 0b       	stdsp	sp[0x40],r11
800088d2:	72 09       	ld.w	r9,r9[0x0]
800088d4:	fa c6 f9 44 	sub	r6,sp,-1724
800088d8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800088dc:	2f f8       	sub	r8,-1
800088de:	f7 49 fd 88 	st.w	r11[-632],r9
800088e2:	fb 48 06 b4 	st.w	sp[1716],r8
800088e6:	14 97       	mov	r7,r10
800088e8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088ec:	c0 58       	rjmp	800088f6 <_vfprintf_r+0x68e>
800088ee:	92 18       	ld.sh	r8,r9[0x2]
800088f0:	14 97       	mov	r7,r10
800088f2:	2f c9       	sub	r9,-4
800088f4:	51 09       	stdsp	sp[0x40],r9
800088f6:	50 18       	stdsp	sp[0x4],r8
800088f8:	bf 58       	asr	r8,0x1f
800088fa:	50 08       	stdsp	sp[0x0],r8
800088fc:	c4 88       	rjmp	8000898c <_vfprintf_r+0x724>
800088fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008902:	40 3c       	lddsp	r12,sp[0xc]
80008904:	58 0c       	cp.w	r12,0
80008906:	c1 d0       	breq	80008940 <_vfprintf_r+0x6d8>
80008908:	10 36       	cp.w	r6,r8
8000890a:	c0 64       	brge	80008916 <_vfprintf_r+0x6ae>
8000890c:	fa cb f9 44 	sub	r11,sp,-1724
80008910:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008914:	c1 f8       	rjmp	80008952 <_vfprintf_r+0x6ea>
80008916:	fa c8 f9 50 	sub	r8,sp,-1712
8000891a:	1a d8       	st.w	--sp,r8
8000891c:	fa c8 fa b8 	sub	r8,sp,-1352
80008920:	0c 9b       	mov	r11,r6
80008922:	1a d8       	st.w	--sp,r8
80008924:	fa c8 fb b4 	sub	r8,sp,-1100
80008928:	04 9a       	mov	r10,r2
8000892a:	1a d8       	st.w	--sp,r8
8000892c:	08 9c       	mov	r12,r4
8000892e:	fa c8 f9 40 	sub	r8,sp,-1728
80008932:	fa c9 ff b4 	sub	r9,sp,-76
80008936:	fe b0 fb 01 	rcall	80007f38 <get_arg>
8000893a:	2f dd       	sub	sp,-12
8000893c:	78 0b       	ld.w	r11,r12[0x0]
8000893e:	c2 48       	rjmp	80008986 <_vfprintf_r+0x71e>
80008940:	ee ca ff ff 	sub	r10,r7,-1
80008944:	10 37       	cp.w	r7,r8
80008946:	c0 94       	brge	80008958 <_vfprintf_r+0x6f0>
80008948:	fa c9 f9 44 	sub	r9,sp,-1724
8000894c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008950:	14 97       	mov	r7,r10
80008952:	ec fb fd 88 	ld.w	r11,r6[-632]
80008956:	c1 88       	rjmp	80008986 <_vfprintf_r+0x71e>
80008958:	41 09       	lddsp	r9,sp[0x40]
8000895a:	59 f8       	cp.w	r8,31
8000895c:	e0 89 00 11 	brgt	8000897e <_vfprintf_r+0x716>
80008960:	f2 cb ff fc 	sub	r11,r9,-4
80008964:	51 0b       	stdsp	sp[0x40],r11
80008966:	fa c6 f9 44 	sub	r6,sp,-1724
8000896a:	72 0b       	ld.w	r11,r9[0x0]
8000896c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008970:	f3 4b fd 88 	st.w	r9[-632],r11
80008974:	2f f8       	sub	r8,-1
80008976:	14 97       	mov	r7,r10
80008978:	fb 48 06 b4 	st.w	sp[1716],r8
8000897c:	c0 58       	rjmp	80008986 <_vfprintf_r+0x71e>
8000897e:	72 0b       	ld.w	r11,r9[0x0]
80008980:	14 97       	mov	r7,r10
80008982:	2f c9       	sub	r9,-4
80008984:	51 09       	stdsp	sp[0x40],r9
80008986:	50 1b       	stdsp	sp[0x4],r11
80008988:	bf 5b       	asr	r11,0x1f
8000898a:	50 0b       	stdsp	sp[0x0],r11
8000898c:	fa ea 00 00 	ld.d	r10,sp[0]
80008990:	58 0a       	cp.w	r10,0
80008992:	5c 2b       	cpc	r11
80008994:	c0 e4       	brge	800089b0 <_vfprintf_r+0x748>
80008996:	30 08       	mov	r8,0
80008998:	fa ea 00 00 	ld.d	r10,sp[0]
8000899c:	30 09       	mov	r9,0
8000899e:	f0 0a 01 0a 	sub	r10,r8,r10
800089a2:	f2 0b 01 4b 	sbc	r11,r9,r11
800089a6:	32 d8       	mov	r8,45
800089a8:	fa eb 00 00 	st.d	sp[0],r10
800089ac:	fb 68 06 bb 	st.b	sp[1723],r8
800089b0:	30 18       	mov	r8,1
800089b2:	e0 8f 06 fa 	bral	800097a6 <_vfprintf_r+0x153e>
800089b6:	50 a7       	stdsp	sp[0x28],r7
800089b8:	50 80       	stdsp	sp[0x20],r0
800089ba:	0c 97       	mov	r7,r6
800089bc:	04 94       	mov	r4,r2
800089be:	06 96       	mov	r6,r3
800089c0:	02 92       	mov	r2,r1
800089c2:	40 93       	lddsp	r3,sp[0x24]
800089c4:	10 90       	mov	r0,r8
800089c6:	40 41       	lddsp	r1,sp[0x10]
800089c8:	0e 99       	mov	r9,r7
800089ca:	ed b5 00 03 	bld	r5,0x3
800089ce:	c4 11       	brne	80008a50 <_vfprintf_r+0x7e8>
800089d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089d4:	40 3a       	lddsp	r10,sp[0xc]
800089d6:	58 0a       	cp.w	r10,0
800089d8:	c1 90       	breq	80008a0a <_vfprintf_r+0x7a2>
800089da:	10 36       	cp.w	r6,r8
800089dc:	c6 45       	brlt	80008aa4 <_vfprintf_r+0x83c>
800089de:	fa c8 f9 50 	sub	r8,sp,-1712
800089e2:	1a d8       	st.w	--sp,r8
800089e4:	fa c8 fa b8 	sub	r8,sp,-1352
800089e8:	1a d8       	st.w	--sp,r8
800089ea:	fa c8 fb b4 	sub	r8,sp,-1100
800089ee:	0c 9b       	mov	r11,r6
800089f0:	1a d8       	st.w	--sp,r8
800089f2:	04 9a       	mov	r10,r2
800089f4:	fa c8 f9 40 	sub	r8,sp,-1728
800089f8:	fa c9 ff b4 	sub	r9,sp,-76
800089fc:	08 9c       	mov	r12,r4
800089fe:	fe b0 fa 9d 	rcall	80007f38 <get_arg>
80008a02:	2f dd       	sub	sp,-12
80008a04:	78 16       	ld.w	r6,r12[0x4]
80008a06:	50 76       	stdsp	sp[0x1c],r6
80008a08:	c4 88       	rjmp	80008a98 <_vfprintf_r+0x830>
80008a0a:	2f f7       	sub	r7,-1
80008a0c:	10 39       	cp.w	r9,r8
80008a0e:	c0 c4       	brge	80008a26 <_vfprintf_r+0x7be>
80008a10:	fa ce f9 44 	sub	lr,sp,-1724
80008a14:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008a18:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008a1c:	50 7c       	stdsp	sp[0x1c],r12
80008a1e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008a22:	50 56       	stdsp	sp[0x14],r6
80008a24:	c6 68       	rjmp	80008af0 <_vfprintf_r+0x888>
80008a26:	41 09       	lddsp	r9,sp[0x40]
80008a28:	59 f8       	cp.w	r8,31
80008a2a:	e0 89 00 10 	brgt	80008a4a <_vfprintf_r+0x7e2>
80008a2e:	f2 ca ff f8 	sub	r10,r9,-8
80008a32:	72 1b       	ld.w	r11,r9[0x4]
80008a34:	51 0a       	stdsp	sp[0x40],r10
80008a36:	72 09       	ld.w	r9,r9[0x0]
80008a38:	fa ca f9 44 	sub	r10,sp,-1724
80008a3c:	50 7b       	stdsp	sp[0x1c],r11
80008a3e:	50 59       	stdsp	sp[0x14],r9
80008a40:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008a44:	40 5b       	lddsp	r11,sp[0x14]
80008a46:	40 7a       	lddsp	r10,sp[0x1c]
80008a48:	c4 78       	rjmp	80008ad6 <_vfprintf_r+0x86e>
80008a4a:	72 18       	ld.w	r8,r9[0x4]
80008a4c:	50 78       	stdsp	sp[0x1c],r8
80008a4e:	c4 c8       	rjmp	80008ae6 <_vfprintf_r+0x87e>
80008a50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a54:	40 3e       	lddsp	lr,sp[0xc]
80008a56:	58 0e       	cp.w	lr,0
80008a58:	c2 30       	breq	80008a9e <_vfprintf_r+0x836>
80008a5a:	10 36       	cp.w	r6,r8
80008a5c:	c0 94       	brge	80008a6e <_vfprintf_r+0x806>
80008a5e:	fa cc f9 44 	sub	r12,sp,-1724
80008a62:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a66:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008a6a:	50 7b       	stdsp	sp[0x1c],r11
80008a6c:	cd 9b       	rjmp	80008a1e <_vfprintf_r+0x7b6>
80008a6e:	fa c8 f9 50 	sub	r8,sp,-1712
80008a72:	1a d8       	st.w	--sp,r8
80008a74:	fa c8 fa b8 	sub	r8,sp,-1352
80008a78:	04 9a       	mov	r10,r2
80008a7a:	1a d8       	st.w	--sp,r8
80008a7c:	fa c8 fb b4 	sub	r8,sp,-1100
80008a80:	0c 9b       	mov	r11,r6
80008a82:	1a d8       	st.w	--sp,r8
80008a84:	08 9c       	mov	r12,r4
80008a86:	fa c8 f9 40 	sub	r8,sp,-1728
80008a8a:	fa c9 ff b4 	sub	r9,sp,-76
80008a8e:	fe b0 fa 55 	rcall	80007f38 <get_arg>
80008a92:	2f dd       	sub	sp,-12
80008a94:	78 1a       	ld.w	r10,r12[0x4]
80008a96:	50 7a       	stdsp	sp[0x1c],r10
80008a98:	78 0c       	ld.w	r12,r12[0x0]
80008a9a:	50 5c       	stdsp	sp[0x14],r12
80008a9c:	c2 a8       	rjmp	80008af0 <_vfprintf_r+0x888>
80008a9e:	2f f7       	sub	r7,-1
80008aa0:	10 39       	cp.w	r9,r8
80008aa2:	c0 94       	brge	80008ab4 <_vfprintf_r+0x84c>
80008aa4:	fa c9 f9 44 	sub	r9,sp,-1724
80008aa8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008aac:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008ab0:	50 78       	stdsp	sp[0x1c],r8
80008ab2:	cb 6b       	rjmp	80008a1e <_vfprintf_r+0x7b6>
80008ab4:	41 09       	lddsp	r9,sp[0x40]
80008ab6:	59 f8       	cp.w	r8,31
80008ab8:	e0 89 00 15 	brgt	80008ae2 <_vfprintf_r+0x87a>
80008abc:	f2 ca ff f8 	sub	r10,r9,-8
80008ac0:	72 16       	ld.w	r6,r9[0x4]
80008ac2:	72 09       	ld.w	r9,r9[0x0]
80008ac4:	51 0a       	stdsp	sp[0x40],r10
80008ac6:	50 59       	stdsp	sp[0x14],r9
80008ac8:	fa ce f9 44 	sub	lr,sp,-1724
80008acc:	50 76       	stdsp	sp[0x1c],r6
80008ace:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008ad2:	40 5b       	lddsp	r11,sp[0x14]
80008ad4:	0c 9a       	mov	r10,r6
80008ad6:	f2 eb fd 88 	st.d	r9[-632],r10
80008ada:	2f f8       	sub	r8,-1
80008adc:	fb 48 06 b4 	st.w	sp[1716],r8
80008ae0:	c0 88       	rjmp	80008af0 <_vfprintf_r+0x888>
80008ae2:	72 1c       	ld.w	r12,r9[0x4]
80008ae4:	50 7c       	stdsp	sp[0x1c],r12
80008ae6:	f2 c8 ff f8 	sub	r8,r9,-8
80008aea:	51 08       	stdsp	sp[0x40],r8
80008aec:	72 09       	ld.w	r9,r9[0x0]
80008aee:	50 59       	stdsp	sp[0x14],r9
80008af0:	40 5b       	lddsp	r11,sp[0x14]
80008af2:	40 7a       	lddsp	r10,sp[0x1c]
80008af4:	e0 a0 19 54 	rcall	8000bd9c <__isinfd>
80008af8:	18 96       	mov	r6,r12
80008afa:	c1 70       	breq	80008b28 <_vfprintf_r+0x8c0>
80008afc:	30 08       	mov	r8,0
80008afe:	30 09       	mov	r9,0
80008b00:	40 5b       	lddsp	r11,sp[0x14]
80008b02:	40 7a       	lddsp	r10,sp[0x1c]
80008b04:	e0 a0 1d b4 	rcall	8000c66c <__avr32_f64_cmp_lt>
80008b08:	c0 40       	breq	80008b10 <_vfprintf_r+0x8a8>
80008b0a:	32 d8       	mov	r8,45
80008b0c:	fb 68 06 bb 	st.b	sp[1723],r8
80008b10:	fe c8 a9 d8 	sub	r8,pc,-22056
80008b14:	fe c6 a9 d8 	sub	r6,pc,-22056
80008b18:	a7 d5       	cbr	r5,0x7
80008b1a:	e0 40 00 47 	cp.w	r0,71
80008b1e:	f0 06 17 a0 	movle	r6,r8
80008b22:	30 32       	mov	r2,3
80008b24:	e0 8f 06 ce 	bral	800098c0 <_vfprintf_r+0x1658>
80008b28:	40 5b       	lddsp	r11,sp[0x14]
80008b2a:	40 7a       	lddsp	r10,sp[0x1c]
80008b2c:	e0 a0 19 4d 	rcall	8000bdc6 <__isnand>
80008b30:	c0 e0       	breq	80008b4c <_vfprintf_r+0x8e4>
80008b32:	50 26       	stdsp	sp[0x8],r6
80008b34:	fe c8 a9 f4 	sub	r8,pc,-22028
80008b38:	fe c6 a9 f4 	sub	r6,pc,-22028
80008b3c:	a7 d5       	cbr	r5,0x7
80008b3e:	e0 40 00 47 	cp.w	r0,71
80008b42:	f0 06 17 a0 	movle	r6,r8
80008b46:	30 32       	mov	r2,3
80008b48:	e0 8f 06 c2 	bral	800098cc <_vfprintf_r+0x1664>
80008b4c:	40 2a       	lddsp	r10,sp[0x8]
80008b4e:	5b fa       	cp.w	r10,-1
80008b50:	c0 41       	brne	80008b58 <_vfprintf_r+0x8f0>
80008b52:	30 69       	mov	r9,6
80008b54:	50 29       	stdsp	sp[0x8],r9
80008b56:	c1 18       	rjmp	80008b78 <_vfprintf_r+0x910>
80008b58:	e0 40 00 47 	cp.w	r0,71
80008b5c:	5f 09       	sreq	r9
80008b5e:	e0 40 00 67 	cp.w	r0,103
80008b62:	5f 08       	sreq	r8
80008b64:	f3 e8 10 08 	or	r8,r9,r8
80008b68:	f8 08 18 00 	cp.b	r8,r12
80008b6c:	c0 60       	breq	80008b78 <_vfprintf_r+0x910>
80008b6e:	40 28       	lddsp	r8,sp[0x8]
80008b70:	58 08       	cp.w	r8,0
80008b72:	f9 b8 00 01 	moveq	r8,1
80008b76:	50 28       	stdsp	sp[0x8],r8
80008b78:	40 78       	lddsp	r8,sp[0x1c]
80008b7a:	40 59       	lddsp	r9,sp[0x14]
80008b7c:	fa e9 06 94 	st.d	sp[1684],r8
80008b80:	a9 a5       	sbr	r5,0x8
80008b82:	fa f8 06 94 	ld.w	r8,sp[1684]
80008b86:	58 08       	cp.w	r8,0
80008b88:	c0 65       	brlt	80008b94 <_vfprintf_r+0x92c>
80008b8a:	40 5e       	lddsp	lr,sp[0x14]
80008b8c:	30 0c       	mov	r12,0
80008b8e:	50 6e       	stdsp	sp[0x18],lr
80008b90:	50 9c       	stdsp	sp[0x24],r12
80008b92:	c0 78       	rjmp	80008ba0 <_vfprintf_r+0x938>
80008b94:	40 5b       	lddsp	r11,sp[0x14]
80008b96:	32 da       	mov	r10,45
80008b98:	ee 1b 80 00 	eorh	r11,0x8000
80008b9c:	50 9a       	stdsp	sp[0x24],r10
80008b9e:	50 6b       	stdsp	sp[0x18],r11
80008ba0:	e0 40 00 46 	cp.w	r0,70
80008ba4:	5f 09       	sreq	r9
80008ba6:	e0 40 00 66 	cp.w	r0,102
80008baa:	5f 08       	sreq	r8
80008bac:	f3 e8 10 08 	or	r8,r9,r8
80008bb0:	50 48       	stdsp	sp[0x10],r8
80008bb2:	c0 40       	breq	80008bba <_vfprintf_r+0x952>
80008bb4:	40 22       	lddsp	r2,sp[0x8]
80008bb6:	30 39       	mov	r9,3
80008bb8:	c1 08       	rjmp	80008bd8 <_vfprintf_r+0x970>
80008bba:	e0 40 00 45 	cp.w	r0,69
80008bbe:	5f 09       	sreq	r9
80008bc0:	e0 40 00 65 	cp.w	r0,101
80008bc4:	5f 08       	sreq	r8
80008bc6:	40 22       	lddsp	r2,sp[0x8]
80008bc8:	10 49       	or	r9,r8
80008bca:	2f f2       	sub	r2,-1
80008bcc:	40 46       	lddsp	r6,sp[0x10]
80008bce:	ec 09 18 00 	cp.b	r9,r6
80008bd2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008bd6:	30 29       	mov	r9,2
80008bd8:	fa c8 f9 5c 	sub	r8,sp,-1700
80008bdc:	1a d8       	st.w	--sp,r8
80008bde:	fa c8 f9 54 	sub	r8,sp,-1708
80008be2:	1a d8       	st.w	--sp,r8
80008be4:	fa c8 f9 4c 	sub	r8,sp,-1716
80008be8:	08 9c       	mov	r12,r4
80008bea:	1a d8       	st.w	--sp,r8
80008bec:	04 98       	mov	r8,r2
80008bee:	40 9b       	lddsp	r11,sp[0x24]
80008bf0:	40 aa       	lddsp	r10,sp[0x28]
80008bf2:	e0 a0 0b c3 	rcall	8000a378 <_dtoa_r>
80008bf6:	e0 40 00 47 	cp.w	r0,71
80008bfa:	5f 19       	srne	r9
80008bfc:	e0 40 00 67 	cp.w	r0,103
80008c00:	5f 18       	srne	r8
80008c02:	18 96       	mov	r6,r12
80008c04:	2f dd       	sub	sp,-12
80008c06:	f3 e8 00 08 	and	r8,r9,r8
80008c0a:	c0 41       	brne	80008c12 <_vfprintf_r+0x9aa>
80008c0c:	ed b5 00 00 	bld	r5,0x0
80008c10:	c3 01       	brne	80008c70 <_vfprintf_r+0xa08>
80008c12:	ec 02 00 0e 	add	lr,r6,r2
80008c16:	50 3e       	stdsp	sp[0xc],lr
80008c18:	40 4c       	lddsp	r12,sp[0x10]
80008c1a:	58 0c       	cp.w	r12,0
80008c1c:	c1 50       	breq	80008c46 <_vfprintf_r+0x9de>
80008c1e:	0d 89       	ld.ub	r9,r6[0x0]
80008c20:	33 08       	mov	r8,48
80008c22:	f0 09 18 00 	cp.b	r9,r8
80008c26:	c0 b1       	brne	80008c3c <_vfprintf_r+0x9d4>
80008c28:	30 08       	mov	r8,0
80008c2a:	30 09       	mov	r9,0
80008c2c:	40 6b       	lddsp	r11,sp[0x18]
80008c2e:	40 7a       	lddsp	r10,sp[0x1c]
80008c30:	e0 a0 1c d7 	rcall	8000c5de <__avr32_f64_cmp_eq>
80008c34:	fb b2 00 01 	rsubeq	r2,1
80008c38:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008c3c:	40 3b       	lddsp	r11,sp[0xc]
80008c3e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c42:	10 0b       	add	r11,r8
80008c44:	50 3b       	stdsp	sp[0xc],r11
80008c46:	40 6b       	lddsp	r11,sp[0x18]
80008c48:	30 08       	mov	r8,0
80008c4a:	30 09       	mov	r9,0
80008c4c:	40 7a       	lddsp	r10,sp[0x1c]
80008c4e:	e0 a0 1c c8 	rcall	8000c5de <__avr32_f64_cmp_eq>
80008c52:	c0 90       	breq	80008c64 <_vfprintf_r+0x9fc>
80008c54:	40 3a       	lddsp	r10,sp[0xc]
80008c56:	fb 4a 06 a4 	st.w	sp[1700],r10
80008c5a:	c0 58       	rjmp	80008c64 <_vfprintf_r+0x9fc>
80008c5c:	10 c9       	st.b	r8++,r9
80008c5e:	fb 48 06 a4 	st.w	sp[1700],r8
80008c62:	c0 28       	rjmp	80008c66 <_vfprintf_r+0x9fe>
80008c64:	33 09       	mov	r9,48
80008c66:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008c6a:	40 3e       	lddsp	lr,sp[0xc]
80008c6c:	1c 38       	cp.w	r8,lr
80008c6e:	cf 73       	brcs	80008c5c <_vfprintf_r+0x9f4>
80008c70:	e0 40 00 47 	cp.w	r0,71
80008c74:	5f 09       	sreq	r9
80008c76:	e0 40 00 67 	cp.w	r0,103
80008c7a:	5f 08       	sreq	r8
80008c7c:	f3 e8 10 08 	or	r8,r9,r8
80008c80:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008c84:	0c 19       	sub	r9,r6
80008c86:	50 69       	stdsp	sp[0x18],r9
80008c88:	58 08       	cp.w	r8,0
80008c8a:	c0 b0       	breq	80008ca0 <_vfprintf_r+0xa38>
80008c8c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c90:	5b d8       	cp.w	r8,-3
80008c92:	c0 55       	brlt	80008c9c <_vfprintf_r+0xa34>
80008c94:	40 2c       	lddsp	r12,sp[0x8]
80008c96:	18 38       	cp.w	r8,r12
80008c98:	e0 8a 00 6a 	brle	80008d6c <_vfprintf_r+0xb04>
80008c9c:	20 20       	sub	r0,2
80008c9e:	c0 58       	rjmp	80008ca8 <_vfprintf_r+0xa40>
80008ca0:	e0 40 00 65 	cp.w	r0,101
80008ca4:	e0 89 00 46 	brgt	80008d30 <_vfprintf_r+0xac8>
80008ca8:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008cac:	fb 60 06 9c 	st.b	sp[1692],r0
80008cb0:	20 1b       	sub	r11,1
80008cb2:	fb 4b 06 ac 	st.w	sp[1708],r11
80008cb6:	c0 47       	brpl	80008cbe <_vfprintf_r+0xa56>
80008cb8:	5c 3b       	neg	r11
80008cba:	32 d8       	mov	r8,45
80008cbc:	c0 28       	rjmp	80008cc0 <_vfprintf_r+0xa58>
80008cbe:	32 b8       	mov	r8,43
80008cc0:	fb 68 06 9d 	st.b	sp[1693],r8
80008cc4:	58 9b       	cp.w	r11,9
80008cc6:	e0 8a 00 1d 	brle	80008d00 <_vfprintf_r+0xa98>
80008cca:	fa c9 fa 35 	sub	r9,sp,-1483
80008cce:	30 aa       	mov	r10,10
80008cd0:	12 98       	mov	r8,r9
80008cd2:	0e 9c       	mov	r12,r7
80008cd4:	0c 92       	mov	r2,r6
80008cd6:	f6 0a 0c 06 	divs	r6,r11,r10
80008cda:	0e 9b       	mov	r11,r7
80008cdc:	2d 0b       	sub	r11,-48
80008cde:	10 fb       	st.b	--r8,r11
80008ce0:	0c 9b       	mov	r11,r6
80008ce2:	58 96       	cp.w	r6,9
80008ce4:	fe 99 ff f9 	brgt	80008cd6 <_vfprintf_r+0xa6e>
80008ce8:	2d 0b       	sub	r11,-48
80008cea:	18 97       	mov	r7,r12
80008cec:	04 96       	mov	r6,r2
80008cee:	10 fb       	st.b	--r8,r11
80008cf0:	fa ca f9 62 	sub	r10,sp,-1694
80008cf4:	c0 38       	rjmp	80008cfa <_vfprintf_r+0xa92>
80008cf6:	11 3b       	ld.ub	r11,r8++
80008cf8:	14 cb       	st.b	r10++,r11
80008cfa:	12 38       	cp.w	r8,r9
80008cfc:	cf d3       	brcs	80008cf6 <_vfprintf_r+0xa8e>
80008cfe:	c0 98       	rjmp	80008d10 <_vfprintf_r+0xaa8>
80008d00:	2d 0b       	sub	r11,-48
80008d02:	33 08       	mov	r8,48
80008d04:	fb 6b 06 9f 	st.b	sp[1695],r11
80008d08:	fb 68 06 9e 	st.b	sp[1694],r8
80008d0c:	fa ca f9 60 	sub	r10,sp,-1696
80008d10:	fa c8 f9 64 	sub	r8,sp,-1692
80008d14:	f4 08 01 08 	sub	r8,r10,r8
80008d18:	50 e8       	stdsp	sp[0x38],r8
80008d1a:	10 92       	mov	r2,r8
80008d1c:	40 6b       	lddsp	r11,sp[0x18]
80008d1e:	16 02       	add	r2,r11
80008d20:	58 1b       	cp.w	r11,1
80008d22:	e0 89 00 05 	brgt	80008d2c <_vfprintf_r+0xac4>
80008d26:	ed b5 00 00 	bld	r5,0x0
80008d2a:	c3 51       	brne	80008d94 <_vfprintf_r+0xb2c>
80008d2c:	2f f2       	sub	r2,-1
80008d2e:	c3 38       	rjmp	80008d94 <_vfprintf_r+0xb2c>
80008d30:	e0 40 00 66 	cp.w	r0,102
80008d34:	c1 c1       	brne	80008d6c <_vfprintf_r+0xb04>
80008d36:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d3a:	58 02       	cp.w	r2,0
80008d3c:	e0 8a 00 0c 	brle	80008d54 <_vfprintf_r+0xaec>
80008d40:	40 2a       	lddsp	r10,sp[0x8]
80008d42:	58 0a       	cp.w	r10,0
80008d44:	c0 41       	brne	80008d4c <_vfprintf_r+0xae4>
80008d46:	ed b5 00 00 	bld	r5,0x0
80008d4a:	c2 51       	brne	80008d94 <_vfprintf_r+0xb2c>
80008d4c:	2f f2       	sub	r2,-1
80008d4e:	40 29       	lddsp	r9,sp[0x8]
80008d50:	12 02       	add	r2,r9
80008d52:	c0 b8       	rjmp	80008d68 <_vfprintf_r+0xb00>
80008d54:	40 28       	lddsp	r8,sp[0x8]
80008d56:	58 08       	cp.w	r8,0
80008d58:	c0 61       	brne	80008d64 <_vfprintf_r+0xafc>
80008d5a:	ed b5 00 00 	bld	r5,0x0
80008d5e:	c0 30       	breq	80008d64 <_vfprintf_r+0xafc>
80008d60:	30 12       	mov	r2,1
80008d62:	c1 98       	rjmp	80008d94 <_vfprintf_r+0xb2c>
80008d64:	40 22       	lddsp	r2,sp[0x8]
80008d66:	2f e2       	sub	r2,-2
80008d68:	36 60       	mov	r0,102
80008d6a:	c1 58       	rjmp	80008d94 <_vfprintf_r+0xb2c>
80008d6c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d70:	40 6e       	lddsp	lr,sp[0x18]
80008d72:	1c 32       	cp.w	r2,lr
80008d74:	c0 65       	brlt	80008d80 <_vfprintf_r+0xb18>
80008d76:	ed b5 00 00 	bld	r5,0x0
80008d7a:	f7 b2 00 ff 	subeq	r2,-1
80008d7e:	c0 a8       	rjmp	80008d92 <_vfprintf_r+0xb2a>
80008d80:	e4 08 11 02 	rsub	r8,r2,2
80008d84:	40 6c       	lddsp	r12,sp[0x18]
80008d86:	58 02       	cp.w	r2,0
80008d88:	f0 02 17 a0 	movle	r2,r8
80008d8c:	f9 b2 09 01 	movgt	r2,1
80008d90:	18 02       	add	r2,r12
80008d92:	36 70       	mov	r0,103
80008d94:	40 9b       	lddsp	r11,sp[0x24]
80008d96:	58 0b       	cp.w	r11,0
80008d98:	e0 80 05 94 	breq	800098c0 <_vfprintf_r+0x1658>
80008d9c:	32 d8       	mov	r8,45
80008d9e:	fb 68 06 bb 	st.b	sp[1723],r8
80008da2:	e0 8f 05 93 	bral	800098c8 <_vfprintf_r+0x1660>
80008da6:	50 a7       	stdsp	sp[0x28],r7
80008da8:	04 94       	mov	r4,r2
80008daa:	0c 97       	mov	r7,r6
80008dac:	02 92       	mov	r2,r1
80008dae:	06 96       	mov	r6,r3
80008db0:	40 41       	lddsp	r1,sp[0x10]
80008db2:	40 93       	lddsp	r3,sp[0x24]
80008db4:	0e 99       	mov	r9,r7
80008db6:	ed b5 00 05 	bld	r5,0x5
80008dba:	c4 81       	brne	80008e4a <_vfprintf_r+0xbe2>
80008dbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dc0:	40 3e       	lddsp	lr,sp[0xc]
80008dc2:	58 0e       	cp.w	lr,0
80008dc4:	c1 d0       	breq	80008dfe <_vfprintf_r+0xb96>
80008dc6:	10 36       	cp.w	r6,r8
80008dc8:	c0 64       	brge	80008dd4 <_vfprintf_r+0xb6c>
80008dca:	fa cc f9 44 	sub	r12,sp,-1724
80008dce:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008dd2:	c1 d8       	rjmp	80008e0c <_vfprintf_r+0xba4>
80008dd4:	fa c8 f9 50 	sub	r8,sp,-1712
80008dd8:	1a d8       	st.w	--sp,r8
80008dda:	fa c8 fa b8 	sub	r8,sp,-1352
80008dde:	04 9a       	mov	r10,r2
80008de0:	1a d8       	st.w	--sp,r8
80008de2:	fa c8 fb b4 	sub	r8,sp,-1100
80008de6:	0c 9b       	mov	r11,r6
80008de8:	1a d8       	st.w	--sp,r8
80008dea:	08 9c       	mov	r12,r4
80008dec:	fa c8 f9 40 	sub	r8,sp,-1728
80008df0:	fa c9 ff b4 	sub	r9,sp,-76
80008df4:	fe b0 f8 a2 	rcall	80007f38 <get_arg>
80008df8:	2f dd       	sub	sp,-12
80008dfa:	78 0a       	ld.w	r10,r12[0x0]
80008dfc:	c2 08       	rjmp	80008e3c <_vfprintf_r+0xbd4>
80008dfe:	2f f7       	sub	r7,-1
80008e00:	10 39       	cp.w	r9,r8
80008e02:	c0 84       	brge	80008e12 <_vfprintf_r+0xbaa>
80008e04:	fa cb f9 44 	sub	r11,sp,-1724
80008e08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e0c:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e10:	c1 68       	rjmp	80008e3c <_vfprintf_r+0xbd4>
80008e12:	41 09       	lddsp	r9,sp[0x40]
80008e14:	59 f8       	cp.w	r8,31
80008e16:	e0 89 00 10 	brgt	80008e36 <_vfprintf_r+0xbce>
80008e1a:	f2 ca ff fc 	sub	r10,r9,-4
80008e1e:	51 0a       	stdsp	sp[0x40],r10
80008e20:	fa c6 f9 44 	sub	r6,sp,-1724
80008e24:	72 0a       	ld.w	r10,r9[0x0]
80008e26:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e2a:	f3 4a fd 88 	st.w	r9[-632],r10
80008e2e:	2f f8       	sub	r8,-1
80008e30:	fb 48 06 b4 	st.w	sp[1716],r8
80008e34:	c0 48       	rjmp	80008e3c <_vfprintf_r+0xbd4>
80008e36:	72 0a       	ld.w	r10,r9[0x0]
80008e38:	2f c9       	sub	r9,-4
80008e3a:	51 09       	stdsp	sp[0x40],r9
80008e3c:	40 be       	lddsp	lr,sp[0x2c]
80008e3e:	1c 98       	mov	r8,lr
80008e40:	95 1e       	st.w	r10[0x4],lr
80008e42:	bf 58       	asr	r8,0x1f
80008e44:	95 08       	st.w	r10[0x0],r8
80008e46:	fe 9f fa 9f 	bral	80008384 <_vfprintf_r+0x11c>
80008e4a:	ed b5 00 04 	bld	r5,0x4
80008e4e:	c4 80       	breq	80008ede <_vfprintf_r+0xc76>
80008e50:	e2 15 00 40 	andl	r5,0x40,COH
80008e54:	c4 50       	breq	80008ede <_vfprintf_r+0xc76>
80008e56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e5a:	40 3c       	lddsp	r12,sp[0xc]
80008e5c:	58 0c       	cp.w	r12,0
80008e5e:	c1 d0       	breq	80008e98 <_vfprintf_r+0xc30>
80008e60:	10 36       	cp.w	r6,r8
80008e62:	c0 64       	brge	80008e6e <_vfprintf_r+0xc06>
80008e64:	fa cb f9 44 	sub	r11,sp,-1724
80008e68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e6c:	c1 d8       	rjmp	80008ea6 <_vfprintf_r+0xc3e>
80008e6e:	fa c8 f9 50 	sub	r8,sp,-1712
80008e72:	1a d8       	st.w	--sp,r8
80008e74:	fa c8 fa b8 	sub	r8,sp,-1352
80008e78:	04 9a       	mov	r10,r2
80008e7a:	1a d8       	st.w	--sp,r8
80008e7c:	fa c8 fb b4 	sub	r8,sp,-1100
80008e80:	0c 9b       	mov	r11,r6
80008e82:	1a d8       	st.w	--sp,r8
80008e84:	08 9c       	mov	r12,r4
80008e86:	fa c8 f9 40 	sub	r8,sp,-1728
80008e8a:	fa c9 ff b4 	sub	r9,sp,-76
80008e8e:	fe b0 f8 55 	rcall	80007f38 <get_arg>
80008e92:	2f dd       	sub	sp,-12
80008e94:	78 0a       	ld.w	r10,r12[0x0]
80008e96:	c2 08       	rjmp	80008ed6 <_vfprintf_r+0xc6e>
80008e98:	2f f7       	sub	r7,-1
80008e9a:	10 39       	cp.w	r9,r8
80008e9c:	c0 84       	brge	80008eac <_vfprintf_r+0xc44>
80008e9e:	fa ca f9 44 	sub	r10,sp,-1724
80008ea2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ea6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008eaa:	c1 68       	rjmp	80008ed6 <_vfprintf_r+0xc6e>
80008eac:	41 09       	lddsp	r9,sp[0x40]
80008eae:	59 f8       	cp.w	r8,31
80008eb0:	e0 89 00 10 	brgt	80008ed0 <_vfprintf_r+0xc68>
80008eb4:	f2 ca ff fc 	sub	r10,r9,-4
80008eb8:	51 0a       	stdsp	sp[0x40],r10
80008eba:	fa c6 f9 44 	sub	r6,sp,-1724
80008ebe:	72 0a       	ld.w	r10,r9[0x0]
80008ec0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ec4:	f3 4a fd 88 	st.w	r9[-632],r10
80008ec8:	2f f8       	sub	r8,-1
80008eca:	fb 48 06 b4 	st.w	sp[1716],r8
80008ece:	c0 48       	rjmp	80008ed6 <_vfprintf_r+0xc6e>
80008ed0:	72 0a       	ld.w	r10,r9[0x0]
80008ed2:	2f c9       	sub	r9,-4
80008ed4:	51 09       	stdsp	sp[0x40],r9
80008ed6:	40 be       	lddsp	lr,sp[0x2c]
80008ed8:	b4 0e       	st.h	r10[0x0],lr
80008eda:	fe 9f fa 55 	bral	80008384 <_vfprintf_r+0x11c>
80008ede:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ee2:	40 3c       	lddsp	r12,sp[0xc]
80008ee4:	58 0c       	cp.w	r12,0
80008ee6:	c1 d0       	breq	80008f20 <_vfprintf_r+0xcb8>
80008ee8:	10 36       	cp.w	r6,r8
80008eea:	c0 64       	brge	80008ef6 <_vfprintf_r+0xc8e>
80008eec:	fa cb f9 44 	sub	r11,sp,-1724
80008ef0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ef4:	c1 d8       	rjmp	80008f2e <_vfprintf_r+0xcc6>
80008ef6:	fa c8 f9 50 	sub	r8,sp,-1712
80008efa:	1a d8       	st.w	--sp,r8
80008efc:	fa c8 fa b8 	sub	r8,sp,-1352
80008f00:	04 9a       	mov	r10,r2
80008f02:	1a d8       	st.w	--sp,r8
80008f04:	fa c8 fb b4 	sub	r8,sp,-1100
80008f08:	0c 9b       	mov	r11,r6
80008f0a:	1a d8       	st.w	--sp,r8
80008f0c:	08 9c       	mov	r12,r4
80008f0e:	fa c8 f9 40 	sub	r8,sp,-1728
80008f12:	fa c9 ff b4 	sub	r9,sp,-76
80008f16:	fe b0 f8 11 	rcall	80007f38 <get_arg>
80008f1a:	2f dd       	sub	sp,-12
80008f1c:	78 0a       	ld.w	r10,r12[0x0]
80008f1e:	c2 08       	rjmp	80008f5e <_vfprintf_r+0xcf6>
80008f20:	2f f7       	sub	r7,-1
80008f22:	10 39       	cp.w	r9,r8
80008f24:	c0 84       	brge	80008f34 <_vfprintf_r+0xccc>
80008f26:	fa ca f9 44 	sub	r10,sp,-1724
80008f2a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f2e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008f32:	c1 68       	rjmp	80008f5e <_vfprintf_r+0xcf6>
80008f34:	41 09       	lddsp	r9,sp[0x40]
80008f36:	59 f8       	cp.w	r8,31
80008f38:	e0 89 00 10 	brgt	80008f58 <_vfprintf_r+0xcf0>
80008f3c:	f2 ca ff fc 	sub	r10,r9,-4
80008f40:	51 0a       	stdsp	sp[0x40],r10
80008f42:	fa c6 f9 44 	sub	r6,sp,-1724
80008f46:	72 0a       	ld.w	r10,r9[0x0]
80008f48:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f4c:	f3 4a fd 88 	st.w	r9[-632],r10
80008f50:	2f f8       	sub	r8,-1
80008f52:	fb 48 06 b4 	st.w	sp[1716],r8
80008f56:	c0 48       	rjmp	80008f5e <_vfprintf_r+0xcf6>
80008f58:	72 0a       	ld.w	r10,r9[0x0]
80008f5a:	2f c9       	sub	r9,-4
80008f5c:	51 09       	stdsp	sp[0x40],r9
80008f5e:	40 be       	lddsp	lr,sp[0x2c]
80008f60:	95 0e       	st.w	r10[0x0],lr
80008f62:	fe 9f fa 11 	bral	80008384 <_vfprintf_r+0x11c>
80008f66:	50 a7       	stdsp	sp[0x28],r7
80008f68:	50 80       	stdsp	sp[0x20],r0
80008f6a:	0c 97       	mov	r7,r6
80008f6c:	04 94       	mov	r4,r2
80008f6e:	06 96       	mov	r6,r3
80008f70:	02 92       	mov	r2,r1
80008f72:	40 93       	lddsp	r3,sp[0x24]
80008f74:	10 90       	mov	r0,r8
80008f76:	40 41       	lddsp	r1,sp[0x10]
80008f78:	a5 a5       	sbr	r5,0x4
80008f7a:	c0 a8       	rjmp	80008f8e <_vfprintf_r+0xd26>
80008f7c:	50 a7       	stdsp	sp[0x28],r7
80008f7e:	50 80       	stdsp	sp[0x20],r0
80008f80:	0c 97       	mov	r7,r6
80008f82:	04 94       	mov	r4,r2
80008f84:	06 96       	mov	r6,r3
80008f86:	02 92       	mov	r2,r1
80008f88:	40 93       	lddsp	r3,sp[0x24]
80008f8a:	10 90       	mov	r0,r8
80008f8c:	40 41       	lddsp	r1,sp[0x10]
80008f8e:	ed b5 00 05 	bld	r5,0x5
80008f92:	c5 d1       	brne	8000904c <_vfprintf_r+0xde4>
80008f94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f98:	40 3c       	lddsp	r12,sp[0xc]
80008f9a:	58 0c       	cp.w	r12,0
80008f9c:	c2 60       	breq	80008fe8 <_vfprintf_r+0xd80>
80008f9e:	10 36       	cp.w	r6,r8
80008fa0:	c0 a4       	brge	80008fb4 <_vfprintf_r+0xd4c>
80008fa2:	fa cb f9 44 	sub	r11,sp,-1724
80008fa6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008faa:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008fae:	fa e9 00 00 	st.d	sp[0],r8
80008fb2:	c1 88       	rjmp	80008fe2 <_vfprintf_r+0xd7a>
80008fb4:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb8:	1a d8       	st.w	--sp,r8
80008fba:	fa c8 fa b8 	sub	r8,sp,-1352
80008fbe:	04 9a       	mov	r10,r2
80008fc0:	1a d8       	st.w	--sp,r8
80008fc2:	0c 9b       	mov	r11,r6
80008fc4:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc8:	08 9c       	mov	r12,r4
80008fca:	1a d8       	st.w	--sp,r8
80008fcc:	fa c8 f9 40 	sub	r8,sp,-1728
80008fd0:	fa c9 ff b4 	sub	r9,sp,-76
80008fd4:	fe b0 f7 b2 	rcall	80007f38 <get_arg>
80008fd8:	2f dd       	sub	sp,-12
80008fda:	f8 ea 00 00 	ld.d	r10,r12[0]
80008fde:	fa eb 00 00 	st.d	sp[0],r10
80008fe2:	30 08       	mov	r8,0
80008fe4:	e0 8f 03 de 	bral	800097a0 <_vfprintf_r+0x1538>
80008fe8:	ee ca ff ff 	sub	r10,r7,-1
80008fec:	10 37       	cp.w	r7,r8
80008fee:	c0 b4       	brge	80009004 <_vfprintf_r+0xd9c>
80008ff0:	fa c9 f9 44 	sub	r9,sp,-1724
80008ff4:	14 97       	mov	r7,r10
80008ff6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffa:	ec ea fd 88 	ld.d	r10,r6[-632]
80008ffe:	fa eb 00 00 	st.d	sp[0],r10
80009002:	c1 88       	rjmp	80009032 <_vfprintf_r+0xdca>
80009004:	41 09       	lddsp	r9,sp[0x40]
80009006:	59 f8       	cp.w	r8,31
80009008:	e0 89 00 18 	brgt	80009038 <_vfprintf_r+0xdd0>
8000900c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009010:	f2 cb ff f8 	sub	r11,r9,-8
80009014:	fa e7 00 00 	st.d	sp[0],r6
80009018:	51 0b       	stdsp	sp[0x40],r11
8000901a:	fa c6 f9 44 	sub	r6,sp,-1724
8000901e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009022:	fa e6 00 00 	ld.d	r6,sp[0]
80009026:	f2 e7 fd 88 	st.d	r9[-632],r6
8000902a:	2f f8       	sub	r8,-1
8000902c:	14 97       	mov	r7,r10
8000902e:	fb 48 06 b4 	st.w	sp[1716],r8
80009032:	40 38       	lddsp	r8,sp[0xc]
80009034:	e0 8f 03 b6 	bral	800097a0 <_vfprintf_r+0x1538>
80009038:	f2 e6 00 00 	ld.d	r6,r9[0]
8000903c:	40 38       	lddsp	r8,sp[0xc]
8000903e:	fa e7 00 00 	st.d	sp[0],r6
80009042:	2f 89       	sub	r9,-8
80009044:	14 97       	mov	r7,r10
80009046:	51 09       	stdsp	sp[0x40],r9
80009048:	e0 8f 03 ac 	bral	800097a0 <_vfprintf_r+0x1538>
8000904c:	ed b5 00 04 	bld	r5,0x4
80009050:	c1 61       	brne	8000907c <_vfprintf_r+0xe14>
80009052:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009056:	40 3e       	lddsp	lr,sp[0xc]
80009058:	58 0e       	cp.w	lr,0
8000905a:	c0 80       	breq	8000906a <_vfprintf_r+0xe02>
8000905c:	10 36       	cp.w	r6,r8
8000905e:	c6 74       	brge	8000912c <_vfprintf_r+0xec4>
80009060:	fa cc f9 44 	sub	r12,sp,-1724
80009064:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009068:	c8 08       	rjmp	80009168 <_vfprintf_r+0xf00>
8000906a:	ee ca ff ff 	sub	r10,r7,-1
8000906e:	10 37       	cp.w	r7,r8
80009070:	c7 f4       	brge	8000916e <_vfprintf_r+0xf06>
80009072:	fa cb f9 44 	sub	r11,sp,-1724
80009076:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000907a:	c7 68       	rjmp	80009166 <_vfprintf_r+0xefe>
8000907c:	ed b5 00 06 	bld	r5,0x6
80009080:	c4 a1       	brne	80009114 <_vfprintf_r+0xeac>
80009082:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009086:	40 3c       	lddsp	r12,sp[0xc]
80009088:	58 0c       	cp.w	r12,0
8000908a:	c1 d0       	breq	800090c4 <_vfprintf_r+0xe5c>
8000908c:	10 36       	cp.w	r6,r8
8000908e:	c0 64       	brge	8000909a <_vfprintf_r+0xe32>
80009090:	fa cb f9 44 	sub	r11,sp,-1724
80009094:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009098:	c1 f8       	rjmp	800090d6 <_vfprintf_r+0xe6e>
8000909a:	fa c8 f9 50 	sub	r8,sp,-1712
8000909e:	1a d8       	st.w	--sp,r8
800090a0:	fa c8 fa b8 	sub	r8,sp,-1352
800090a4:	1a d8       	st.w	--sp,r8
800090a6:	fa c8 fb b4 	sub	r8,sp,-1100
800090aa:	1a d8       	st.w	--sp,r8
800090ac:	fa c8 f9 40 	sub	r8,sp,-1728
800090b0:	fa c9 ff b4 	sub	r9,sp,-76
800090b4:	04 9a       	mov	r10,r2
800090b6:	0c 9b       	mov	r11,r6
800090b8:	08 9c       	mov	r12,r4
800090ba:	fe b0 f7 3f 	rcall	80007f38 <get_arg>
800090be:	2f dd       	sub	sp,-12
800090c0:	98 18       	ld.sh	r8,r12[0x2]
800090c2:	c2 68       	rjmp	8000910e <_vfprintf_r+0xea6>
800090c4:	ee ca ff ff 	sub	r10,r7,-1
800090c8:	10 37       	cp.w	r7,r8
800090ca:	c0 94       	brge	800090dc <_vfprintf_r+0xe74>
800090cc:	fa c9 f9 44 	sub	r9,sp,-1724
800090d0:	14 97       	mov	r7,r10
800090d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090d6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800090da:	c1 a8       	rjmp	8000910e <_vfprintf_r+0xea6>
800090dc:	41 09       	lddsp	r9,sp[0x40]
800090de:	59 f8       	cp.w	r8,31
800090e0:	e0 89 00 13 	brgt	80009106 <_vfprintf_r+0xe9e>
800090e4:	f2 cb ff fc 	sub	r11,r9,-4
800090e8:	51 0b       	stdsp	sp[0x40],r11
800090ea:	72 09       	ld.w	r9,r9[0x0]
800090ec:	fa c6 f9 44 	sub	r6,sp,-1724
800090f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800090f4:	2f f8       	sub	r8,-1
800090f6:	f7 49 fd 88 	st.w	r11[-632],r9
800090fa:	fb 48 06 b4 	st.w	sp[1716],r8
800090fe:	14 97       	mov	r7,r10
80009100:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009104:	c0 58       	rjmp	8000910e <_vfprintf_r+0xea6>
80009106:	92 18       	ld.sh	r8,r9[0x2]
80009108:	14 97       	mov	r7,r10
8000910a:	2f c9       	sub	r9,-4
8000910c:	51 09       	stdsp	sp[0x40],r9
8000910e:	5c 78       	castu.h	r8
80009110:	50 18       	stdsp	sp[0x4],r8
80009112:	c4 68       	rjmp	8000919e <_vfprintf_r+0xf36>
80009114:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009118:	40 3c       	lddsp	r12,sp[0xc]
8000911a:	58 0c       	cp.w	r12,0
8000911c:	c1 d0       	breq	80009156 <_vfprintf_r+0xeee>
8000911e:	10 36       	cp.w	r6,r8
80009120:	c0 64       	brge	8000912c <_vfprintf_r+0xec4>
80009122:	fa cb f9 44 	sub	r11,sp,-1724
80009126:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000912a:	c1 f8       	rjmp	80009168 <_vfprintf_r+0xf00>
8000912c:	fa c8 f9 50 	sub	r8,sp,-1712
80009130:	1a d8       	st.w	--sp,r8
80009132:	fa c8 fa b8 	sub	r8,sp,-1352
80009136:	0c 9b       	mov	r11,r6
80009138:	1a d8       	st.w	--sp,r8
8000913a:	fa c8 fb b4 	sub	r8,sp,-1100
8000913e:	04 9a       	mov	r10,r2
80009140:	1a d8       	st.w	--sp,r8
80009142:	08 9c       	mov	r12,r4
80009144:	fa c8 f9 40 	sub	r8,sp,-1728
80009148:	fa c9 ff b4 	sub	r9,sp,-76
8000914c:	fe b0 f6 f6 	rcall	80007f38 <get_arg>
80009150:	2f dd       	sub	sp,-12
80009152:	78 0b       	ld.w	r11,r12[0x0]
80009154:	c2 48       	rjmp	8000919c <_vfprintf_r+0xf34>
80009156:	ee ca ff ff 	sub	r10,r7,-1
8000915a:	10 37       	cp.w	r7,r8
8000915c:	c0 94       	brge	8000916e <_vfprintf_r+0xf06>
8000915e:	fa c9 f9 44 	sub	r9,sp,-1724
80009162:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009166:	14 97       	mov	r7,r10
80009168:	ec fb fd 88 	ld.w	r11,r6[-632]
8000916c:	c1 88       	rjmp	8000919c <_vfprintf_r+0xf34>
8000916e:	41 09       	lddsp	r9,sp[0x40]
80009170:	59 f8       	cp.w	r8,31
80009172:	e0 89 00 11 	brgt	80009194 <_vfprintf_r+0xf2c>
80009176:	f2 cb ff fc 	sub	r11,r9,-4
8000917a:	51 0b       	stdsp	sp[0x40],r11
8000917c:	fa c6 f9 44 	sub	r6,sp,-1724
80009180:	72 0b       	ld.w	r11,r9[0x0]
80009182:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009186:	f3 4b fd 88 	st.w	r9[-632],r11
8000918a:	2f f8       	sub	r8,-1
8000918c:	14 97       	mov	r7,r10
8000918e:	fb 48 06 b4 	st.w	sp[1716],r8
80009192:	c0 58       	rjmp	8000919c <_vfprintf_r+0xf34>
80009194:	72 0b       	ld.w	r11,r9[0x0]
80009196:	14 97       	mov	r7,r10
80009198:	2f c9       	sub	r9,-4
8000919a:	51 09       	stdsp	sp[0x40],r9
8000919c:	50 1b       	stdsp	sp[0x4],r11
8000919e:	30 0e       	mov	lr,0
800091a0:	50 0e       	stdsp	sp[0x0],lr
800091a2:	1c 98       	mov	r8,lr
800091a4:	e0 8f 02 fe 	bral	800097a0 <_vfprintf_r+0x1538>
800091a8:	50 a7       	stdsp	sp[0x28],r7
800091aa:	50 80       	stdsp	sp[0x20],r0
800091ac:	0c 97       	mov	r7,r6
800091ae:	04 94       	mov	r4,r2
800091b0:	06 96       	mov	r6,r3
800091b2:	02 92       	mov	r2,r1
800091b4:	40 93       	lddsp	r3,sp[0x24]
800091b6:	40 41       	lddsp	r1,sp[0x10]
800091b8:	0e 99       	mov	r9,r7
800091ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091be:	40 3c       	lddsp	r12,sp[0xc]
800091c0:	58 0c       	cp.w	r12,0
800091c2:	c1 d0       	breq	800091fc <_vfprintf_r+0xf94>
800091c4:	10 36       	cp.w	r6,r8
800091c6:	c0 64       	brge	800091d2 <_vfprintf_r+0xf6a>
800091c8:	fa cb f9 44 	sub	r11,sp,-1724
800091cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091d0:	c1 d8       	rjmp	8000920a <_vfprintf_r+0xfa2>
800091d2:	fa c8 f9 50 	sub	r8,sp,-1712
800091d6:	1a d8       	st.w	--sp,r8
800091d8:	fa c8 fa b8 	sub	r8,sp,-1352
800091dc:	1a d8       	st.w	--sp,r8
800091de:	fa c8 fb b4 	sub	r8,sp,-1100
800091e2:	1a d8       	st.w	--sp,r8
800091e4:	fa c9 ff b4 	sub	r9,sp,-76
800091e8:	fa c8 f9 40 	sub	r8,sp,-1728
800091ec:	04 9a       	mov	r10,r2
800091ee:	0c 9b       	mov	r11,r6
800091f0:	08 9c       	mov	r12,r4
800091f2:	fe b0 f6 a3 	rcall	80007f38 <get_arg>
800091f6:	2f dd       	sub	sp,-12
800091f8:	78 09       	ld.w	r9,r12[0x0]
800091fa:	c2 18       	rjmp	8000923c <_vfprintf_r+0xfd4>
800091fc:	2f f7       	sub	r7,-1
800091fe:	10 39       	cp.w	r9,r8
80009200:	c0 84       	brge	80009210 <_vfprintf_r+0xfa8>
80009202:	fa ca f9 44 	sub	r10,sp,-1724
80009206:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000920a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000920e:	c1 78       	rjmp	8000923c <_vfprintf_r+0xfd4>
80009210:	41 09       	lddsp	r9,sp[0x40]
80009212:	59 f8       	cp.w	r8,31
80009214:	e0 89 00 10 	brgt	80009234 <_vfprintf_r+0xfcc>
80009218:	f2 ca ff fc 	sub	r10,r9,-4
8000921c:	51 0a       	stdsp	sp[0x40],r10
8000921e:	fa c6 f9 44 	sub	r6,sp,-1724
80009222:	72 09       	ld.w	r9,r9[0x0]
80009224:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009228:	f5 49 fd 88 	st.w	r10[-632],r9
8000922c:	2f f8       	sub	r8,-1
8000922e:	fb 48 06 b4 	st.w	sp[1716],r8
80009232:	c0 58       	rjmp	8000923c <_vfprintf_r+0xfd4>
80009234:	f2 c8 ff fc 	sub	r8,r9,-4
80009238:	51 08       	stdsp	sp[0x40],r8
8000923a:	72 09       	ld.w	r9,r9[0x0]
8000923c:	33 08       	mov	r8,48
8000923e:	fb 68 06 b8 	st.b	sp[1720],r8
80009242:	37 88       	mov	r8,120
80009244:	30 0e       	mov	lr,0
80009246:	fb 68 06 b9 	st.b	sp[1721],r8
8000924a:	fe cc b1 02 	sub	r12,pc,-20222
8000924e:	50 19       	stdsp	sp[0x4],r9
80009250:	a1 b5       	sbr	r5,0x1
80009252:	50 0e       	stdsp	sp[0x0],lr
80009254:	50 dc       	stdsp	sp[0x34],r12
80009256:	30 28       	mov	r8,2
80009258:	37 80       	mov	r0,120
8000925a:	e0 8f 02 a3 	bral	800097a0 <_vfprintf_r+0x1538>
8000925e:	50 a7       	stdsp	sp[0x28],r7
80009260:	50 80       	stdsp	sp[0x20],r0
80009262:	10 90       	mov	r0,r8
80009264:	30 08       	mov	r8,0
80009266:	fb 68 06 bb 	st.b	sp[1723],r8
8000926a:	0c 97       	mov	r7,r6
8000926c:	04 94       	mov	r4,r2
8000926e:	06 96       	mov	r6,r3
80009270:	02 92       	mov	r2,r1
80009272:	40 93       	lddsp	r3,sp[0x24]
80009274:	40 41       	lddsp	r1,sp[0x10]
80009276:	0e 99       	mov	r9,r7
80009278:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000927c:	40 3b       	lddsp	r11,sp[0xc]
8000927e:	58 0b       	cp.w	r11,0
80009280:	c1 d0       	breq	800092ba <_vfprintf_r+0x1052>
80009282:	10 36       	cp.w	r6,r8
80009284:	c0 64       	brge	80009290 <_vfprintf_r+0x1028>
80009286:	fa ca f9 44 	sub	r10,sp,-1724
8000928a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000928e:	c1 d8       	rjmp	800092c8 <_vfprintf_r+0x1060>
80009290:	fa c8 f9 50 	sub	r8,sp,-1712
80009294:	1a d8       	st.w	--sp,r8
80009296:	fa c8 fa b8 	sub	r8,sp,-1352
8000929a:	1a d8       	st.w	--sp,r8
8000929c:	fa c8 fb b4 	sub	r8,sp,-1100
800092a0:	0c 9b       	mov	r11,r6
800092a2:	1a d8       	st.w	--sp,r8
800092a4:	04 9a       	mov	r10,r2
800092a6:	fa c8 f9 40 	sub	r8,sp,-1728
800092aa:	fa c9 ff b4 	sub	r9,sp,-76
800092ae:	08 9c       	mov	r12,r4
800092b0:	fe b0 f6 44 	rcall	80007f38 <get_arg>
800092b4:	2f dd       	sub	sp,-12
800092b6:	78 06       	ld.w	r6,r12[0x0]
800092b8:	c2 08       	rjmp	800092f8 <_vfprintf_r+0x1090>
800092ba:	2f f7       	sub	r7,-1
800092bc:	10 39       	cp.w	r9,r8
800092be:	c0 84       	brge	800092ce <_vfprintf_r+0x1066>
800092c0:	fa c9 f9 44 	sub	r9,sp,-1724
800092c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092c8:	ec f6 fd 88 	ld.w	r6,r6[-632]
800092cc:	c1 68       	rjmp	800092f8 <_vfprintf_r+0x1090>
800092ce:	41 09       	lddsp	r9,sp[0x40]
800092d0:	59 f8       	cp.w	r8,31
800092d2:	e0 89 00 10 	brgt	800092f2 <_vfprintf_r+0x108a>
800092d6:	f2 ca ff fc 	sub	r10,r9,-4
800092da:	51 0a       	stdsp	sp[0x40],r10
800092dc:	72 06       	ld.w	r6,r9[0x0]
800092de:	fa ce f9 44 	sub	lr,sp,-1724
800092e2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800092e6:	f3 46 fd 88 	st.w	r9[-632],r6
800092ea:	2f f8       	sub	r8,-1
800092ec:	fb 48 06 b4 	st.w	sp[1716],r8
800092f0:	c0 48       	rjmp	800092f8 <_vfprintf_r+0x1090>
800092f2:	72 06       	ld.w	r6,r9[0x0]
800092f4:	2f c9       	sub	r9,-4
800092f6:	51 09       	stdsp	sp[0x40],r9
800092f8:	40 2c       	lddsp	r12,sp[0x8]
800092fa:	58 0c       	cp.w	r12,0
800092fc:	c1 05       	brlt	8000931c <_vfprintf_r+0x10b4>
800092fe:	18 9a       	mov	r10,r12
80009300:	30 0b       	mov	r11,0
80009302:	0c 9c       	mov	r12,r6
80009304:	e0 a0 12 38 	rcall	8000b774 <memchr>
80009308:	e0 80 02 df 	breq	800098c6 <_vfprintf_r+0x165e>
8000930c:	f8 06 01 02 	sub	r2,r12,r6
80009310:	40 2b       	lddsp	r11,sp[0x8]
80009312:	16 32       	cp.w	r2,r11
80009314:	e0 89 02 d9 	brgt	800098c6 <_vfprintf_r+0x165e>
80009318:	e0 8f 02 d4 	bral	800098c0 <_vfprintf_r+0x1658>
8000931c:	30 0a       	mov	r10,0
8000931e:	0c 9c       	mov	r12,r6
80009320:	50 2a       	stdsp	sp[0x8],r10
80009322:	e0 a0 15 99 	rcall	8000be54 <strlen>
80009326:	18 92       	mov	r2,r12
80009328:	e0 8f 02 d2 	bral	800098cc <_vfprintf_r+0x1664>
8000932c:	50 a7       	stdsp	sp[0x28],r7
8000932e:	50 80       	stdsp	sp[0x20],r0
80009330:	0c 97       	mov	r7,r6
80009332:	04 94       	mov	r4,r2
80009334:	06 96       	mov	r6,r3
80009336:	02 92       	mov	r2,r1
80009338:	40 93       	lddsp	r3,sp[0x24]
8000933a:	10 90       	mov	r0,r8
8000933c:	40 41       	lddsp	r1,sp[0x10]
8000933e:	a5 a5       	sbr	r5,0x4
80009340:	c0 a8       	rjmp	80009354 <_vfprintf_r+0x10ec>
80009342:	50 a7       	stdsp	sp[0x28],r7
80009344:	50 80       	stdsp	sp[0x20],r0
80009346:	0c 97       	mov	r7,r6
80009348:	04 94       	mov	r4,r2
8000934a:	06 96       	mov	r6,r3
8000934c:	02 92       	mov	r2,r1
8000934e:	40 93       	lddsp	r3,sp[0x24]
80009350:	10 90       	mov	r0,r8
80009352:	40 41       	lddsp	r1,sp[0x10]
80009354:	ed b5 00 05 	bld	r5,0x5
80009358:	c5 61       	brne	80009404 <_vfprintf_r+0x119c>
8000935a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000935e:	40 39       	lddsp	r9,sp[0xc]
80009360:	58 09       	cp.w	r9,0
80009362:	c2 10       	breq	800093a4 <_vfprintf_r+0x113c>
80009364:	10 36       	cp.w	r6,r8
80009366:	c0 74       	brge	80009374 <_vfprintf_r+0x110c>
80009368:	fa c8 f9 44 	sub	r8,sp,-1724
8000936c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009370:	c2 38       	rjmp	800093b6 <_vfprintf_r+0x114e>
80009372:	d7 03       	nop
80009374:	fa c8 f9 50 	sub	r8,sp,-1712
80009378:	1a d8       	st.w	--sp,r8
8000937a:	fa c8 fa b8 	sub	r8,sp,-1352
8000937e:	1a d8       	st.w	--sp,r8
80009380:	fa c8 fb b4 	sub	r8,sp,-1100
80009384:	1a d8       	st.w	--sp,r8
80009386:	fa c8 f9 40 	sub	r8,sp,-1728
8000938a:	fa c9 ff b4 	sub	r9,sp,-76
8000938e:	04 9a       	mov	r10,r2
80009390:	0c 9b       	mov	r11,r6
80009392:	08 9c       	mov	r12,r4
80009394:	fe b0 f5 d2 	rcall	80007f38 <get_arg>
80009398:	2f dd       	sub	sp,-12
8000939a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000939e:	fa e9 00 00 	st.d	sp[0],r8
800093a2:	c2 e8       	rjmp	800093fe <_vfprintf_r+0x1196>
800093a4:	ee ca ff ff 	sub	r10,r7,-1
800093a8:	10 37       	cp.w	r7,r8
800093aa:	c0 b4       	brge	800093c0 <_vfprintf_r+0x1158>
800093ac:	fa c8 f9 44 	sub	r8,sp,-1724
800093b0:	14 97       	mov	r7,r10
800093b2:	f0 06 00 36 	add	r6,r8,r6<<0x3
800093b6:	ec ea fd 88 	ld.d	r10,r6[-632]
800093ba:	fa eb 00 00 	st.d	sp[0],r10
800093be:	c2 08       	rjmp	800093fe <_vfprintf_r+0x1196>
800093c0:	41 09       	lddsp	r9,sp[0x40]
800093c2:	59 f8       	cp.w	r8,31
800093c4:	e0 89 00 16 	brgt	800093f0 <_vfprintf_r+0x1188>
800093c8:	f2 e6 00 00 	ld.d	r6,r9[0]
800093cc:	f2 cb ff f8 	sub	r11,r9,-8
800093d0:	fa e7 00 00 	st.d	sp[0],r6
800093d4:	51 0b       	stdsp	sp[0x40],r11
800093d6:	fa c6 f9 44 	sub	r6,sp,-1724
800093da:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093de:	fa e6 00 00 	ld.d	r6,sp[0]
800093e2:	f2 e7 fd 88 	st.d	r9[-632],r6
800093e6:	2f f8       	sub	r8,-1
800093e8:	14 97       	mov	r7,r10
800093ea:	fb 48 06 b4 	st.w	sp[1716],r8
800093ee:	c0 88       	rjmp	800093fe <_vfprintf_r+0x1196>
800093f0:	f2 e6 00 00 	ld.d	r6,r9[0]
800093f4:	2f 89       	sub	r9,-8
800093f6:	fa e7 00 00 	st.d	sp[0],r6
800093fa:	51 09       	stdsp	sp[0x40],r9
800093fc:	14 97       	mov	r7,r10
800093fe:	30 18       	mov	r8,1
80009400:	e0 8f 01 d0 	bral	800097a0 <_vfprintf_r+0x1538>
80009404:	ed b5 00 04 	bld	r5,0x4
80009408:	c1 61       	brne	80009434 <_vfprintf_r+0x11cc>
8000940a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000940e:	40 3e       	lddsp	lr,sp[0xc]
80009410:	58 0e       	cp.w	lr,0
80009412:	c0 80       	breq	80009422 <_vfprintf_r+0x11ba>
80009414:	10 36       	cp.w	r6,r8
80009416:	c6 74       	brge	800094e4 <_vfprintf_r+0x127c>
80009418:	fa cc f9 44 	sub	r12,sp,-1724
8000941c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009420:	c8 08       	rjmp	80009520 <_vfprintf_r+0x12b8>
80009422:	ee ca ff ff 	sub	r10,r7,-1
80009426:	10 37       	cp.w	r7,r8
80009428:	c7 f4       	brge	80009526 <_vfprintf_r+0x12be>
8000942a:	fa cb f9 44 	sub	r11,sp,-1724
8000942e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009432:	c7 68       	rjmp	8000951e <_vfprintf_r+0x12b6>
80009434:	ed b5 00 06 	bld	r5,0x6
80009438:	c4 a1       	brne	800094cc <_vfprintf_r+0x1264>
8000943a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000943e:	40 3c       	lddsp	r12,sp[0xc]
80009440:	58 0c       	cp.w	r12,0
80009442:	c1 d0       	breq	8000947c <_vfprintf_r+0x1214>
80009444:	10 36       	cp.w	r6,r8
80009446:	c0 64       	brge	80009452 <_vfprintf_r+0x11ea>
80009448:	fa cb f9 44 	sub	r11,sp,-1724
8000944c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009450:	c1 f8       	rjmp	8000948e <_vfprintf_r+0x1226>
80009452:	fa c8 f9 50 	sub	r8,sp,-1712
80009456:	1a d8       	st.w	--sp,r8
80009458:	fa c8 fa b8 	sub	r8,sp,-1352
8000945c:	1a d8       	st.w	--sp,r8
8000945e:	fa c8 fb b4 	sub	r8,sp,-1100
80009462:	1a d8       	st.w	--sp,r8
80009464:	fa c8 f9 40 	sub	r8,sp,-1728
80009468:	fa c9 ff b4 	sub	r9,sp,-76
8000946c:	04 9a       	mov	r10,r2
8000946e:	0c 9b       	mov	r11,r6
80009470:	08 9c       	mov	r12,r4
80009472:	fe b0 f5 63 	rcall	80007f38 <get_arg>
80009476:	2f dd       	sub	sp,-12
80009478:	98 18       	ld.sh	r8,r12[0x2]
8000947a:	c2 68       	rjmp	800094c6 <_vfprintf_r+0x125e>
8000947c:	ee ca ff ff 	sub	r10,r7,-1
80009480:	10 37       	cp.w	r7,r8
80009482:	c0 94       	brge	80009494 <_vfprintf_r+0x122c>
80009484:	fa c9 f9 44 	sub	r9,sp,-1724
80009488:	14 97       	mov	r7,r10
8000948a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000948e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009492:	c1 a8       	rjmp	800094c6 <_vfprintf_r+0x125e>
80009494:	41 09       	lddsp	r9,sp[0x40]
80009496:	59 f8       	cp.w	r8,31
80009498:	e0 89 00 13 	brgt	800094be <_vfprintf_r+0x1256>
8000949c:	f2 cb ff fc 	sub	r11,r9,-4
800094a0:	51 0b       	stdsp	sp[0x40],r11
800094a2:	72 09       	ld.w	r9,r9[0x0]
800094a4:	fa c6 f9 44 	sub	r6,sp,-1724
800094a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800094ac:	2f f8       	sub	r8,-1
800094ae:	f7 49 fd 88 	st.w	r11[-632],r9
800094b2:	fb 48 06 b4 	st.w	sp[1716],r8
800094b6:	14 97       	mov	r7,r10
800094b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800094bc:	c0 58       	rjmp	800094c6 <_vfprintf_r+0x125e>
800094be:	92 18       	ld.sh	r8,r9[0x2]
800094c0:	14 97       	mov	r7,r10
800094c2:	2f c9       	sub	r9,-4
800094c4:	51 09       	stdsp	sp[0x40],r9
800094c6:	5c 78       	castu.h	r8
800094c8:	50 18       	stdsp	sp[0x4],r8
800094ca:	c4 68       	rjmp	80009556 <_vfprintf_r+0x12ee>
800094cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094d0:	40 3c       	lddsp	r12,sp[0xc]
800094d2:	58 0c       	cp.w	r12,0
800094d4:	c1 d0       	breq	8000950e <_vfprintf_r+0x12a6>
800094d6:	10 36       	cp.w	r6,r8
800094d8:	c0 64       	brge	800094e4 <_vfprintf_r+0x127c>
800094da:	fa cb f9 44 	sub	r11,sp,-1724
800094de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094e2:	c1 f8       	rjmp	80009520 <_vfprintf_r+0x12b8>
800094e4:	fa c8 f9 50 	sub	r8,sp,-1712
800094e8:	1a d8       	st.w	--sp,r8
800094ea:	fa c8 fa b8 	sub	r8,sp,-1352
800094ee:	0c 9b       	mov	r11,r6
800094f0:	1a d8       	st.w	--sp,r8
800094f2:	fa c8 fb b4 	sub	r8,sp,-1100
800094f6:	04 9a       	mov	r10,r2
800094f8:	1a d8       	st.w	--sp,r8
800094fa:	08 9c       	mov	r12,r4
800094fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009500:	fa c9 ff b4 	sub	r9,sp,-76
80009504:	fe b0 f5 1a 	rcall	80007f38 <get_arg>
80009508:	2f dd       	sub	sp,-12
8000950a:	78 0b       	ld.w	r11,r12[0x0]
8000950c:	c2 48       	rjmp	80009554 <_vfprintf_r+0x12ec>
8000950e:	ee ca ff ff 	sub	r10,r7,-1
80009512:	10 37       	cp.w	r7,r8
80009514:	c0 94       	brge	80009526 <_vfprintf_r+0x12be>
80009516:	fa c9 f9 44 	sub	r9,sp,-1724
8000951a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000951e:	14 97       	mov	r7,r10
80009520:	ec fb fd 88 	ld.w	r11,r6[-632]
80009524:	c1 88       	rjmp	80009554 <_vfprintf_r+0x12ec>
80009526:	41 09       	lddsp	r9,sp[0x40]
80009528:	59 f8       	cp.w	r8,31
8000952a:	e0 89 00 11 	brgt	8000954c <_vfprintf_r+0x12e4>
8000952e:	f2 cb ff fc 	sub	r11,r9,-4
80009532:	51 0b       	stdsp	sp[0x40],r11
80009534:	fa c6 f9 44 	sub	r6,sp,-1724
80009538:	72 0b       	ld.w	r11,r9[0x0]
8000953a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000953e:	f3 4b fd 88 	st.w	r9[-632],r11
80009542:	2f f8       	sub	r8,-1
80009544:	14 97       	mov	r7,r10
80009546:	fb 48 06 b4 	st.w	sp[1716],r8
8000954a:	c0 58       	rjmp	80009554 <_vfprintf_r+0x12ec>
8000954c:	72 0b       	ld.w	r11,r9[0x0]
8000954e:	14 97       	mov	r7,r10
80009550:	2f c9       	sub	r9,-4
80009552:	51 09       	stdsp	sp[0x40],r9
80009554:	50 1b       	stdsp	sp[0x4],r11
80009556:	30 0e       	mov	lr,0
80009558:	30 18       	mov	r8,1
8000955a:	50 0e       	stdsp	sp[0x0],lr
8000955c:	c2 29       	rjmp	800097a0 <_vfprintf_r+0x1538>
8000955e:	50 a7       	stdsp	sp[0x28],r7
80009560:	50 80       	stdsp	sp[0x20],r0
80009562:	0c 97       	mov	r7,r6
80009564:	04 94       	mov	r4,r2
80009566:	06 96       	mov	r6,r3
80009568:	02 92       	mov	r2,r1
8000956a:	fe cc b4 22 	sub	r12,pc,-19422
8000956e:	40 93       	lddsp	r3,sp[0x24]
80009570:	10 90       	mov	r0,r8
80009572:	40 41       	lddsp	r1,sp[0x10]
80009574:	50 dc       	stdsp	sp[0x34],r12
80009576:	ed b5 00 05 	bld	r5,0x5
8000957a:	c5 51       	brne	80009624 <_vfprintf_r+0x13bc>
8000957c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009580:	40 3b       	lddsp	r11,sp[0xc]
80009582:	58 0b       	cp.w	r11,0
80009584:	c2 20       	breq	800095c8 <_vfprintf_r+0x1360>
80009586:	10 36       	cp.w	r6,r8
80009588:	c0 a4       	brge	8000959c <_vfprintf_r+0x1334>
8000958a:	fa ca f9 44 	sub	r10,sp,-1724
8000958e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009592:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009596:	fa e9 00 00 	st.d	sp[0],r8
8000959a:	cf 28       	rjmp	8000977e <_vfprintf_r+0x1516>
8000959c:	fa c8 f9 50 	sub	r8,sp,-1712
800095a0:	1a d8       	st.w	--sp,r8
800095a2:	fa c8 fa b8 	sub	r8,sp,-1352
800095a6:	04 9a       	mov	r10,r2
800095a8:	1a d8       	st.w	--sp,r8
800095aa:	0c 9b       	mov	r11,r6
800095ac:	fa c8 fb b4 	sub	r8,sp,-1100
800095b0:	08 9c       	mov	r12,r4
800095b2:	1a d8       	st.w	--sp,r8
800095b4:	fa c8 f9 40 	sub	r8,sp,-1728
800095b8:	fa c9 ff b4 	sub	r9,sp,-76
800095bc:	fe b0 f4 be 	rcall	80007f38 <get_arg>
800095c0:	2f dd       	sub	sp,-12
800095c2:	f8 ea 00 00 	ld.d	r10,r12[0]
800095c6:	c0 c8       	rjmp	800095de <_vfprintf_r+0x1376>
800095c8:	ee ca ff ff 	sub	r10,r7,-1
800095cc:	10 37       	cp.w	r7,r8
800095ce:	c0 b4       	brge	800095e4 <_vfprintf_r+0x137c>
800095d0:	fa c9 f9 44 	sub	r9,sp,-1724
800095d4:	14 97       	mov	r7,r10
800095d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095da:	ec ea fd 88 	ld.d	r10,r6[-632]
800095de:	fa eb 00 00 	st.d	sp[0],r10
800095e2:	cc e8       	rjmp	8000977e <_vfprintf_r+0x1516>
800095e4:	41 09       	lddsp	r9,sp[0x40]
800095e6:	59 f8       	cp.w	r8,31
800095e8:	e0 89 00 16 	brgt	80009614 <_vfprintf_r+0x13ac>
800095ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800095f0:	f2 cb ff f8 	sub	r11,r9,-8
800095f4:	fa e7 00 00 	st.d	sp[0],r6
800095f8:	51 0b       	stdsp	sp[0x40],r11
800095fa:	fa c6 f9 44 	sub	r6,sp,-1724
800095fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009602:	fa e6 00 00 	ld.d	r6,sp[0]
80009606:	f2 e7 fd 88 	st.d	r9[-632],r6
8000960a:	2f f8       	sub	r8,-1
8000960c:	14 97       	mov	r7,r10
8000960e:	fb 48 06 b4 	st.w	sp[1716],r8
80009612:	cb 68       	rjmp	8000977e <_vfprintf_r+0x1516>
80009614:	f2 e6 00 00 	ld.d	r6,r9[0]
80009618:	2f 89       	sub	r9,-8
8000961a:	fa e7 00 00 	st.d	sp[0],r6
8000961e:	51 09       	stdsp	sp[0x40],r9
80009620:	14 97       	mov	r7,r10
80009622:	ca e8       	rjmp	8000977e <_vfprintf_r+0x1516>
80009624:	ed b5 00 04 	bld	r5,0x4
80009628:	c1 71       	brne	80009656 <_vfprintf_r+0x13ee>
8000962a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000962e:	40 3e       	lddsp	lr,sp[0xc]
80009630:	58 0e       	cp.w	lr,0
80009632:	c0 80       	breq	80009642 <_vfprintf_r+0x13da>
80009634:	10 36       	cp.w	r6,r8
80009636:	c6 94       	brge	80009708 <_vfprintf_r+0x14a0>
80009638:	fa cc f9 44 	sub	r12,sp,-1724
8000963c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009640:	c8 28       	rjmp	80009744 <_vfprintf_r+0x14dc>
80009642:	ee ca ff ff 	sub	r10,r7,-1
80009646:	10 37       	cp.w	r7,r8
80009648:	e0 84 00 81 	brge	8000974a <_vfprintf_r+0x14e2>
8000964c:	fa cb f9 44 	sub	r11,sp,-1724
80009650:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009654:	c7 78       	rjmp	80009742 <_vfprintf_r+0x14da>
80009656:	ed b5 00 06 	bld	r5,0x6
8000965a:	c4 b1       	brne	800096f0 <_vfprintf_r+0x1488>
8000965c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009660:	40 3c       	lddsp	r12,sp[0xc]
80009662:	58 0c       	cp.w	r12,0
80009664:	c1 d0       	breq	8000969e <_vfprintf_r+0x1436>
80009666:	10 36       	cp.w	r6,r8
80009668:	c0 64       	brge	80009674 <_vfprintf_r+0x140c>
8000966a:	fa cb f9 44 	sub	r11,sp,-1724
8000966e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009672:	c1 f8       	rjmp	800096b0 <_vfprintf_r+0x1448>
80009674:	fa c8 f9 50 	sub	r8,sp,-1712
80009678:	1a d8       	st.w	--sp,r8
8000967a:	fa c8 fa b8 	sub	r8,sp,-1352
8000967e:	1a d8       	st.w	--sp,r8
80009680:	fa c8 fb b4 	sub	r8,sp,-1100
80009684:	1a d8       	st.w	--sp,r8
80009686:	fa c8 f9 40 	sub	r8,sp,-1728
8000968a:	fa c9 ff b4 	sub	r9,sp,-76
8000968e:	04 9a       	mov	r10,r2
80009690:	0c 9b       	mov	r11,r6
80009692:	08 9c       	mov	r12,r4
80009694:	fe b0 f4 52 	rcall	80007f38 <get_arg>
80009698:	2f dd       	sub	sp,-12
8000969a:	98 18       	ld.sh	r8,r12[0x2]
8000969c:	c2 78       	rjmp	800096ea <_vfprintf_r+0x1482>
8000969e:	ee ca ff ff 	sub	r10,r7,-1
800096a2:	10 37       	cp.w	r7,r8
800096a4:	c0 a4       	brge	800096b8 <_vfprintf_r+0x1450>
800096a6:	fa c9 f9 44 	sub	r9,sp,-1724
800096aa:	14 97       	mov	r7,r10
800096ac:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096b0:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800096b4:	c1 b8       	rjmp	800096ea <_vfprintf_r+0x1482>
800096b6:	d7 03       	nop
800096b8:	41 09       	lddsp	r9,sp[0x40]
800096ba:	59 f8       	cp.w	r8,31
800096bc:	e0 89 00 13 	brgt	800096e2 <_vfprintf_r+0x147a>
800096c0:	f2 cb ff fc 	sub	r11,r9,-4
800096c4:	51 0b       	stdsp	sp[0x40],r11
800096c6:	72 09       	ld.w	r9,r9[0x0]
800096c8:	fa c6 f9 44 	sub	r6,sp,-1724
800096cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800096d0:	2f f8       	sub	r8,-1
800096d2:	f7 49 fd 88 	st.w	r11[-632],r9
800096d6:	fb 48 06 b4 	st.w	sp[1716],r8
800096da:	14 97       	mov	r7,r10
800096dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800096e0:	c0 58       	rjmp	800096ea <_vfprintf_r+0x1482>
800096e2:	92 18       	ld.sh	r8,r9[0x2]
800096e4:	14 97       	mov	r7,r10
800096e6:	2f c9       	sub	r9,-4
800096e8:	51 09       	stdsp	sp[0x40],r9
800096ea:	5c 78       	castu.h	r8
800096ec:	50 18       	stdsp	sp[0x4],r8
800096ee:	c4 68       	rjmp	8000977a <_vfprintf_r+0x1512>
800096f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096f4:	40 3c       	lddsp	r12,sp[0xc]
800096f6:	58 0c       	cp.w	r12,0
800096f8:	c1 d0       	breq	80009732 <_vfprintf_r+0x14ca>
800096fa:	10 36       	cp.w	r6,r8
800096fc:	c0 64       	brge	80009708 <_vfprintf_r+0x14a0>
800096fe:	fa cb f9 44 	sub	r11,sp,-1724
80009702:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009706:	c1 f8       	rjmp	80009744 <_vfprintf_r+0x14dc>
80009708:	fa c8 f9 50 	sub	r8,sp,-1712
8000970c:	1a d8       	st.w	--sp,r8
8000970e:	fa c8 fa b8 	sub	r8,sp,-1352
80009712:	0c 9b       	mov	r11,r6
80009714:	1a d8       	st.w	--sp,r8
80009716:	fa c8 fb b4 	sub	r8,sp,-1100
8000971a:	04 9a       	mov	r10,r2
8000971c:	1a d8       	st.w	--sp,r8
8000971e:	08 9c       	mov	r12,r4
80009720:	fa c8 f9 40 	sub	r8,sp,-1728
80009724:	fa c9 ff b4 	sub	r9,sp,-76
80009728:	fe b0 f4 08 	rcall	80007f38 <get_arg>
8000972c:	2f dd       	sub	sp,-12
8000972e:	78 0b       	ld.w	r11,r12[0x0]
80009730:	c2 48       	rjmp	80009778 <_vfprintf_r+0x1510>
80009732:	ee ca ff ff 	sub	r10,r7,-1
80009736:	10 37       	cp.w	r7,r8
80009738:	c0 94       	brge	8000974a <_vfprintf_r+0x14e2>
8000973a:	fa c9 f9 44 	sub	r9,sp,-1724
8000973e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009742:	14 97       	mov	r7,r10
80009744:	ec fb fd 88 	ld.w	r11,r6[-632]
80009748:	c1 88       	rjmp	80009778 <_vfprintf_r+0x1510>
8000974a:	41 09       	lddsp	r9,sp[0x40]
8000974c:	59 f8       	cp.w	r8,31
8000974e:	e0 89 00 11 	brgt	80009770 <_vfprintf_r+0x1508>
80009752:	f2 cb ff fc 	sub	r11,r9,-4
80009756:	51 0b       	stdsp	sp[0x40],r11
80009758:	fa c6 f9 44 	sub	r6,sp,-1724
8000975c:	72 0b       	ld.w	r11,r9[0x0]
8000975e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009762:	f3 4b fd 88 	st.w	r9[-632],r11
80009766:	2f f8       	sub	r8,-1
80009768:	14 97       	mov	r7,r10
8000976a:	fb 48 06 b4 	st.w	sp[1716],r8
8000976e:	c0 58       	rjmp	80009778 <_vfprintf_r+0x1510>
80009770:	72 0b       	ld.w	r11,r9[0x0]
80009772:	14 97       	mov	r7,r10
80009774:	2f c9       	sub	r9,-4
80009776:	51 09       	stdsp	sp[0x40],r9
80009778:	50 1b       	stdsp	sp[0x4],r11
8000977a:	30 0e       	mov	lr,0
8000977c:	50 0e       	stdsp	sp[0x0],lr
8000977e:	40 08       	lddsp	r8,sp[0x0]
80009780:	40 1c       	lddsp	r12,sp[0x4]
80009782:	18 48       	or	r8,r12
80009784:	5f 19       	srne	r9
80009786:	0a 98       	mov	r8,r5
80009788:	eb e9 00 09 	and	r9,r5,r9
8000978c:	a1 b8       	sbr	r8,0x1
8000978e:	58 09       	cp.w	r9,0
80009790:	c0 70       	breq	8000979e <_vfprintf_r+0x1536>
80009792:	10 95       	mov	r5,r8
80009794:	fb 60 06 b9 	st.b	sp[1721],r0
80009798:	33 08       	mov	r8,48
8000979a:	fb 68 06 b8 	st.b	sp[1720],r8
8000979e:	30 28       	mov	r8,2
800097a0:	30 09       	mov	r9,0
800097a2:	fb 69 06 bb 	st.b	sp[1723],r9
800097a6:	0a 99       	mov	r9,r5
800097a8:	a7 d9       	cbr	r9,0x7
800097aa:	40 2b       	lddsp	r11,sp[0x8]
800097ac:	40 16       	lddsp	r6,sp[0x4]
800097ae:	58 0b       	cp.w	r11,0
800097b0:	5f 1a       	srne	r10
800097b2:	f2 05 17 40 	movge	r5,r9
800097b6:	fa c2 f9 78 	sub	r2,sp,-1672
800097ba:	40 09       	lddsp	r9,sp[0x0]
800097bc:	0c 49       	or	r9,r6
800097be:	5f 19       	srne	r9
800097c0:	f5 e9 10 09 	or	r9,r10,r9
800097c4:	c5 c0       	breq	8000987c <_vfprintf_r+0x1614>
800097c6:	30 19       	mov	r9,1
800097c8:	f2 08 18 00 	cp.b	r8,r9
800097cc:	c0 60       	breq	800097d8 <_vfprintf_r+0x1570>
800097ce:	30 29       	mov	r9,2
800097d0:	f2 08 18 00 	cp.b	r8,r9
800097d4:	c0 41       	brne	800097dc <_vfprintf_r+0x1574>
800097d6:	c3 c8       	rjmp	8000984e <_vfprintf_r+0x15e6>
800097d8:	04 96       	mov	r6,r2
800097da:	c3 08       	rjmp	8000983a <_vfprintf_r+0x15d2>
800097dc:	04 96       	mov	r6,r2
800097de:	fa e8 00 00 	ld.d	r8,sp[0]
800097e2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800097e6:	2d 0a       	sub	r10,-48
800097e8:	0c fa       	st.b	--r6,r10
800097ea:	f0 0b 16 03 	lsr	r11,r8,0x3
800097ee:	f2 0c 16 03 	lsr	r12,r9,0x3
800097f2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800097f6:	18 99       	mov	r9,r12
800097f8:	16 98       	mov	r8,r11
800097fa:	58 08       	cp.w	r8,0
800097fc:	5c 29       	cpc	r9
800097fe:	cf 21       	brne	800097e2 <_vfprintf_r+0x157a>
80009800:	fa e9 00 00 	st.d	sp[0],r8
80009804:	ed b5 00 00 	bld	r5,0x0
80009808:	c4 51       	brne	80009892 <_vfprintf_r+0x162a>
8000980a:	33 09       	mov	r9,48
8000980c:	f2 0a 18 00 	cp.b	r10,r9
80009810:	c4 10       	breq	80009892 <_vfprintf_r+0x162a>
80009812:	0c f9       	st.b	--r6,r9
80009814:	c3 f8       	rjmp	80009892 <_vfprintf_r+0x162a>
80009816:	fa ea 00 00 	ld.d	r10,sp[0]
8000981a:	30 a8       	mov	r8,10
8000981c:	30 09       	mov	r9,0
8000981e:	e0 a0 1a 19 	rcall	8000cc50 <__avr32_umod64>
80009822:	30 a8       	mov	r8,10
80009824:	2d 0a       	sub	r10,-48
80009826:	30 09       	mov	r9,0
80009828:	ac 8a       	st.b	r6[0x0],r10
8000982a:	fa ea 00 00 	ld.d	r10,sp[0]
8000982e:	e0 a0 18 df 	rcall	8000c9ec <__avr32_udiv64>
80009832:	16 99       	mov	r9,r11
80009834:	14 98       	mov	r8,r10
80009836:	fa e9 00 00 	st.d	sp[0],r8
8000983a:	20 16       	sub	r6,1
8000983c:	fa ea 00 00 	ld.d	r10,sp[0]
80009840:	58 9a       	cp.w	r10,9
80009842:	5c 2b       	cpc	r11
80009844:	fe 9b ff e9 	brhi	80009816 <_vfprintf_r+0x15ae>
80009848:	1b f8       	ld.ub	r8,sp[0x7]
8000984a:	2d 08       	sub	r8,-48
8000984c:	c2 08       	rjmp	8000988c <_vfprintf_r+0x1624>
8000984e:	04 96       	mov	r6,r2
80009850:	fa e8 00 00 	ld.d	r8,sp[0]
80009854:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009858:	40 de       	lddsp	lr,sp[0x34]
8000985a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000985e:	0c fa       	st.b	--r6,r10
80009860:	f2 0b 16 04 	lsr	r11,r9,0x4
80009864:	f0 0a 16 04 	lsr	r10,r8,0x4
80009868:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000986c:	16 99       	mov	r9,r11
8000986e:	14 98       	mov	r8,r10
80009870:	58 08       	cp.w	r8,0
80009872:	5c 29       	cpc	r9
80009874:	cf 01       	brne	80009854 <_vfprintf_r+0x15ec>
80009876:	fa e9 00 00 	st.d	sp[0],r8
8000987a:	c0 c8       	rjmp	80009892 <_vfprintf_r+0x162a>
8000987c:	58 08       	cp.w	r8,0
8000987e:	c0 91       	brne	80009890 <_vfprintf_r+0x1628>
80009880:	ed b5 00 00 	bld	r5,0x0
80009884:	c0 61       	brne	80009890 <_vfprintf_r+0x1628>
80009886:	fa c6 f9 79 	sub	r6,sp,-1671
8000988a:	33 08       	mov	r8,48
8000988c:	ac 88       	st.b	r6[0x0],r8
8000988e:	c0 28       	rjmp	80009892 <_vfprintf_r+0x162a>
80009890:	04 96       	mov	r6,r2
80009892:	0c 12       	sub	r2,r6
80009894:	c1 c8       	rjmp	800098cc <_vfprintf_r+0x1664>
80009896:	50 a7       	stdsp	sp[0x28],r7
80009898:	50 80       	stdsp	sp[0x20],r0
8000989a:	40 93       	lddsp	r3,sp[0x24]
8000989c:	0c 97       	mov	r7,r6
8000989e:	10 90       	mov	r0,r8
800098a0:	04 94       	mov	r4,r2
800098a2:	40 41       	lddsp	r1,sp[0x10]
800098a4:	58 08       	cp.w	r8,0
800098a6:	e0 80 04 4f 	breq	8000a144 <_vfprintf_r+0x1edc>
800098aa:	fb 68 06 60 	st.b	sp[1632],r8
800098ae:	30 0c       	mov	r12,0
800098b0:	30 08       	mov	r8,0
800098b2:	30 12       	mov	r2,1
800098b4:	fb 68 06 bb 	st.b	sp[1723],r8
800098b8:	50 2c       	stdsp	sp[0x8],r12
800098ba:	fa c6 f9 a0 	sub	r6,sp,-1632
800098be:	c0 78       	rjmp	800098cc <_vfprintf_r+0x1664>
800098c0:	30 0b       	mov	r11,0
800098c2:	50 2b       	stdsp	sp[0x8],r11
800098c4:	c0 48       	rjmp	800098cc <_vfprintf_r+0x1664>
800098c6:	40 22       	lddsp	r2,sp[0x8]
800098c8:	30 0a       	mov	r10,0
800098ca:	50 2a       	stdsp	sp[0x8],r10
800098cc:	40 29       	lddsp	r9,sp[0x8]
800098ce:	e4 09 0c 49 	max	r9,r2,r9
800098d2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800098d6:	50 39       	stdsp	sp[0xc],r9
800098d8:	0a 9e       	mov	lr,r5
800098da:	30 09       	mov	r9,0
800098dc:	e2 1e 00 02 	andl	lr,0x2,COH
800098e0:	f2 08 18 00 	cp.b	r8,r9
800098e4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800098e8:	f7 b8 01 ff 	subne	r8,-1
800098ec:	fb f8 1a 03 	st.wne	sp[0xc],r8
800098f0:	0a 9b       	mov	r11,r5
800098f2:	58 0e       	cp.w	lr,0
800098f4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800098f8:	f7 bc 01 fe 	subne	r12,-2
800098fc:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009900:	e2 1b 00 84 	andl	r11,0x84,COH
80009904:	50 fe       	stdsp	sp[0x3c],lr
80009906:	50 9b       	stdsp	sp[0x24],r11
80009908:	c4 71       	brne	80009996 <_vfprintf_r+0x172e>
8000990a:	40 8a       	lddsp	r10,sp[0x20]
8000990c:	40 39       	lddsp	r9,sp[0xc]
8000990e:	12 1a       	sub	r10,r9
80009910:	50 4a       	stdsp	sp[0x10],r10
80009912:	58 0a       	cp.w	r10,0
80009914:	e0 89 00 20 	brgt	80009954 <_vfprintf_r+0x16ec>
80009918:	c3 f8       	rjmp	80009996 <_vfprintf_r+0x172e>
8000991a:	2f 09       	sub	r9,-16
8000991c:	2f f8       	sub	r8,-1
8000991e:	fe ce b7 be 	sub	lr,pc,-18498
80009922:	31 0c       	mov	r12,16
80009924:	fb 49 06 90 	st.w	sp[1680],r9
80009928:	87 0e       	st.w	r3[0x0],lr
8000992a:	87 1c       	st.w	r3[0x4],r12
8000992c:	fb 48 06 8c 	st.w	sp[1676],r8
80009930:	58 78       	cp.w	r8,7
80009932:	e0 89 00 04 	brgt	8000993a <_vfprintf_r+0x16d2>
80009936:	2f 83       	sub	r3,-8
80009938:	c0 b8       	rjmp	8000994e <_vfprintf_r+0x16e6>
8000993a:	fa ca f9 78 	sub	r10,sp,-1672
8000993e:	02 9b       	mov	r11,r1
80009940:	08 9c       	mov	r12,r4
80009942:	fe b0 f4 85 	rcall	8000824c <__sprint_r>
80009946:	e0 81 04 10 	brne	8000a166 <_vfprintf_r+0x1efe>
8000994a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000994e:	40 4b       	lddsp	r11,sp[0x10]
80009950:	21 0b       	sub	r11,16
80009952:	50 4b       	stdsp	sp[0x10],r11
80009954:	fa f9 06 90 	ld.w	r9,sp[1680]
80009958:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000995c:	fe ca b7 fc 	sub	r10,pc,-18436
80009960:	40 4e       	lddsp	lr,sp[0x10]
80009962:	59 0e       	cp.w	lr,16
80009964:	fe 99 ff db 	brgt	8000991a <_vfprintf_r+0x16b2>
80009968:	1c 09       	add	r9,lr
8000996a:	2f f8       	sub	r8,-1
8000996c:	87 0a       	st.w	r3[0x0],r10
8000996e:	fb 49 06 90 	st.w	sp[1680],r9
80009972:	87 1e       	st.w	r3[0x4],lr
80009974:	fb 48 06 8c 	st.w	sp[1676],r8
80009978:	58 78       	cp.w	r8,7
8000997a:	e0 89 00 04 	brgt	80009982 <_vfprintf_r+0x171a>
8000997e:	2f 83       	sub	r3,-8
80009980:	c0 b8       	rjmp	80009996 <_vfprintf_r+0x172e>
80009982:	fa ca f9 78 	sub	r10,sp,-1672
80009986:	02 9b       	mov	r11,r1
80009988:	08 9c       	mov	r12,r4
8000998a:	fe b0 f4 61 	rcall	8000824c <__sprint_r>
8000998e:	e0 81 03 ec 	brne	8000a166 <_vfprintf_r+0x1efe>
80009992:	fa c3 f9 e0 	sub	r3,sp,-1568
80009996:	30 09       	mov	r9,0
80009998:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000999c:	f2 08 18 00 	cp.b	r8,r9
800099a0:	c1 f0       	breq	800099de <_vfprintf_r+0x1776>
800099a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a6:	fa c9 f9 45 	sub	r9,sp,-1723
800099aa:	2f f8       	sub	r8,-1
800099ac:	87 09       	st.w	r3[0x0],r9
800099ae:	fb 48 06 90 	st.w	sp[1680],r8
800099b2:	30 19       	mov	r9,1
800099b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b8:	87 19       	st.w	r3[0x4],r9
800099ba:	2f f8       	sub	r8,-1
800099bc:	fb 48 06 8c 	st.w	sp[1676],r8
800099c0:	58 78       	cp.w	r8,7
800099c2:	e0 89 00 04 	brgt	800099ca <_vfprintf_r+0x1762>
800099c6:	2f 83       	sub	r3,-8
800099c8:	c0 b8       	rjmp	800099de <_vfprintf_r+0x1776>
800099ca:	fa ca f9 78 	sub	r10,sp,-1672
800099ce:	02 9b       	mov	r11,r1
800099d0:	08 9c       	mov	r12,r4
800099d2:	fe b0 f4 3d 	rcall	8000824c <__sprint_r>
800099d6:	e0 81 03 c8 	brne	8000a166 <_vfprintf_r+0x1efe>
800099da:	fa c3 f9 e0 	sub	r3,sp,-1568
800099de:	40 fc       	lddsp	r12,sp[0x3c]
800099e0:	58 0c       	cp.w	r12,0
800099e2:	c1 f0       	breq	80009a20 <_vfprintf_r+0x17b8>
800099e4:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e8:	fa c9 f9 48 	sub	r9,sp,-1720
800099ec:	2f e8       	sub	r8,-2
800099ee:	87 09       	st.w	r3[0x0],r9
800099f0:	fb 48 06 90 	st.w	sp[1680],r8
800099f4:	30 29       	mov	r9,2
800099f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099fa:	87 19       	st.w	r3[0x4],r9
800099fc:	2f f8       	sub	r8,-1
800099fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009a02:	58 78       	cp.w	r8,7
80009a04:	e0 89 00 04 	brgt	80009a0c <_vfprintf_r+0x17a4>
80009a08:	2f 83       	sub	r3,-8
80009a0a:	c0 b8       	rjmp	80009a20 <_vfprintf_r+0x17b8>
80009a0c:	fa ca f9 78 	sub	r10,sp,-1672
80009a10:	02 9b       	mov	r11,r1
80009a12:	08 9c       	mov	r12,r4
80009a14:	fe b0 f4 1c 	rcall	8000824c <__sprint_r>
80009a18:	e0 81 03 a7 	brne	8000a166 <_vfprintf_r+0x1efe>
80009a1c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a20:	40 9b       	lddsp	r11,sp[0x24]
80009a22:	e0 4b 00 80 	cp.w	r11,128
80009a26:	c4 71       	brne	80009ab4 <_vfprintf_r+0x184c>
80009a28:	40 8a       	lddsp	r10,sp[0x20]
80009a2a:	40 39       	lddsp	r9,sp[0xc]
80009a2c:	12 1a       	sub	r10,r9
80009a2e:	50 4a       	stdsp	sp[0x10],r10
80009a30:	58 0a       	cp.w	r10,0
80009a32:	e0 89 00 20 	brgt	80009a72 <_vfprintf_r+0x180a>
80009a36:	c3 f8       	rjmp	80009ab4 <_vfprintf_r+0x184c>
80009a38:	2f 09       	sub	r9,-16
80009a3a:	2f f8       	sub	r8,-1
80009a3c:	fe ce b8 cc 	sub	lr,pc,-18228
80009a40:	31 0c       	mov	r12,16
80009a42:	fb 49 06 90 	st.w	sp[1680],r9
80009a46:	87 0e       	st.w	r3[0x0],lr
80009a48:	87 1c       	st.w	r3[0x4],r12
80009a4a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4e:	58 78       	cp.w	r8,7
80009a50:	e0 89 00 04 	brgt	80009a58 <_vfprintf_r+0x17f0>
80009a54:	2f 83       	sub	r3,-8
80009a56:	c0 b8       	rjmp	80009a6c <_vfprintf_r+0x1804>
80009a58:	fa ca f9 78 	sub	r10,sp,-1672
80009a5c:	02 9b       	mov	r11,r1
80009a5e:	08 9c       	mov	r12,r4
80009a60:	fe b0 f3 f6 	rcall	8000824c <__sprint_r>
80009a64:	e0 81 03 81 	brne	8000a166 <_vfprintf_r+0x1efe>
80009a68:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a6c:	40 4b       	lddsp	r11,sp[0x10]
80009a6e:	21 0b       	sub	r11,16
80009a70:	50 4b       	stdsp	sp[0x10],r11
80009a72:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a7a:	fe ca b9 0a 	sub	r10,pc,-18166
80009a7e:	40 4e       	lddsp	lr,sp[0x10]
80009a80:	59 0e       	cp.w	lr,16
80009a82:	fe 99 ff db 	brgt	80009a38 <_vfprintf_r+0x17d0>
80009a86:	1c 09       	add	r9,lr
80009a88:	2f f8       	sub	r8,-1
80009a8a:	87 0a       	st.w	r3[0x0],r10
80009a8c:	fb 49 06 90 	st.w	sp[1680],r9
80009a90:	87 1e       	st.w	r3[0x4],lr
80009a92:	fb 48 06 8c 	st.w	sp[1676],r8
80009a96:	58 78       	cp.w	r8,7
80009a98:	e0 89 00 04 	brgt	80009aa0 <_vfprintf_r+0x1838>
80009a9c:	2f 83       	sub	r3,-8
80009a9e:	c0 b8       	rjmp	80009ab4 <_vfprintf_r+0x184c>
80009aa0:	fa ca f9 78 	sub	r10,sp,-1672
80009aa4:	02 9b       	mov	r11,r1
80009aa6:	08 9c       	mov	r12,r4
80009aa8:	fe b0 f3 d2 	rcall	8000824c <__sprint_r>
80009aac:	e0 81 03 5d 	brne	8000a166 <_vfprintf_r+0x1efe>
80009ab0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab4:	40 2c       	lddsp	r12,sp[0x8]
80009ab6:	04 1c       	sub	r12,r2
80009ab8:	50 2c       	stdsp	sp[0x8],r12
80009aba:	58 0c       	cp.w	r12,0
80009abc:	e0 89 00 20 	brgt	80009afc <_vfprintf_r+0x1894>
80009ac0:	c3 f8       	rjmp	80009b3e <_vfprintf_r+0x18d6>
80009ac2:	2f 09       	sub	r9,-16
80009ac4:	2f f8       	sub	r8,-1
80009ac6:	fe cb b9 56 	sub	r11,pc,-18090
80009aca:	31 0a       	mov	r10,16
80009acc:	fb 49 06 90 	st.w	sp[1680],r9
80009ad0:	87 0b       	st.w	r3[0x0],r11
80009ad2:	87 1a       	st.w	r3[0x4],r10
80009ad4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ad8:	58 78       	cp.w	r8,7
80009ada:	e0 89 00 04 	brgt	80009ae2 <_vfprintf_r+0x187a>
80009ade:	2f 83       	sub	r3,-8
80009ae0:	c0 b8       	rjmp	80009af6 <_vfprintf_r+0x188e>
80009ae2:	fa ca f9 78 	sub	r10,sp,-1672
80009ae6:	02 9b       	mov	r11,r1
80009ae8:	08 9c       	mov	r12,r4
80009aea:	fe b0 f3 b1 	rcall	8000824c <__sprint_r>
80009aee:	e0 81 03 3c 	brne	8000a166 <_vfprintf_r+0x1efe>
80009af2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009af6:	40 29       	lddsp	r9,sp[0x8]
80009af8:	21 09       	sub	r9,16
80009afa:	50 29       	stdsp	sp[0x8],r9
80009afc:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b04:	fe ca b9 94 	sub	r10,pc,-18028
80009b08:	40 2e       	lddsp	lr,sp[0x8]
80009b0a:	59 0e       	cp.w	lr,16
80009b0c:	fe 99 ff db 	brgt	80009ac2 <_vfprintf_r+0x185a>
80009b10:	1c 09       	add	r9,lr
80009b12:	2f f8       	sub	r8,-1
80009b14:	87 0a       	st.w	r3[0x0],r10
80009b16:	fb 49 06 90 	st.w	sp[1680],r9
80009b1a:	87 1e       	st.w	r3[0x4],lr
80009b1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b20:	58 78       	cp.w	r8,7
80009b22:	e0 89 00 04 	brgt	80009b2a <_vfprintf_r+0x18c2>
80009b26:	2f 83       	sub	r3,-8
80009b28:	c0 b8       	rjmp	80009b3e <_vfprintf_r+0x18d6>
80009b2a:	fa ca f9 78 	sub	r10,sp,-1672
80009b2e:	02 9b       	mov	r11,r1
80009b30:	08 9c       	mov	r12,r4
80009b32:	fe b0 f3 8d 	rcall	8000824c <__sprint_r>
80009b36:	e0 81 03 18 	brne	8000a166 <_vfprintf_r+0x1efe>
80009b3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b3e:	ed b5 00 08 	bld	r5,0x8
80009b42:	c0 b0       	breq	80009b58 <_vfprintf_r+0x18f0>
80009b44:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b48:	87 12       	st.w	r3[0x4],r2
80009b4a:	87 06       	st.w	r3[0x0],r6
80009b4c:	f0 02 00 02 	add	r2,r8,r2
80009b50:	fb 42 06 90 	st.w	sp[1680],r2
80009b54:	e0 8f 01 d4 	bral	80009efc <_vfprintf_r+0x1c94>
80009b58:	e0 40 00 65 	cp.w	r0,101
80009b5c:	e0 8a 01 d6 	brle	80009f08 <_vfprintf_r+0x1ca0>
80009b60:	30 08       	mov	r8,0
80009b62:	30 09       	mov	r9,0
80009b64:	40 5b       	lddsp	r11,sp[0x14]
80009b66:	40 7a       	lddsp	r10,sp[0x1c]
80009b68:	e0 a0 15 3b 	rcall	8000c5de <__avr32_f64_cmp_eq>
80009b6c:	c7 90       	breq	80009c5e <_vfprintf_r+0x19f6>
80009b6e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b72:	fe c9 ba 16 	sub	r9,pc,-17898
80009b76:	2f f8       	sub	r8,-1
80009b78:	87 09       	st.w	r3[0x0],r9
80009b7a:	fb 48 06 90 	st.w	sp[1680],r8
80009b7e:	30 19       	mov	r9,1
80009b80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b84:	87 19       	st.w	r3[0x4],r9
80009b86:	2f f8       	sub	r8,-1
80009b88:	fb 48 06 8c 	st.w	sp[1676],r8
80009b8c:	58 78       	cp.w	r8,7
80009b8e:	e0 89 00 05 	brgt	80009b98 <_vfprintf_r+0x1930>
80009b92:	2f 83       	sub	r3,-8
80009b94:	c0 c8       	rjmp	80009bac <_vfprintf_r+0x1944>
80009b96:	d7 03       	nop
80009b98:	fa ca f9 78 	sub	r10,sp,-1672
80009b9c:	02 9b       	mov	r11,r1
80009b9e:	08 9c       	mov	r12,r4
80009ba0:	fe b0 f3 56 	rcall	8000824c <__sprint_r>
80009ba4:	e0 81 02 e1 	brne	8000a166 <_vfprintf_r+0x1efe>
80009ba8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bac:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bb0:	40 6c       	lddsp	r12,sp[0x18]
80009bb2:	18 38       	cp.w	r8,r12
80009bb4:	c0 55       	brlt	80009bbe <_vfprintf_r+0x1956>
80009bb6:	ed b5 00 00 	bld	r5,0x0
80009bba:	e0 81 02 6b 	brne	8000a090 <_vfprintf_r+0x1e28>
80009bbe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bc2:	2f f8       	sub	r8,-1
80009bc4:	40 cb       	lddsp	r11,sp[0x30]
80009bc6:	fb 48 06 90 	st.w	sp[1680],r8
80009bca:	30 19       	mov	r9,1
80009bcc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bd0:	87 0b       	st.w	r3[0x0],r11
80009bd2:	2f f8       	sub	r8,-1
80009bd4:	87 19       	st.w	r3[0x4],r9
80009bd6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bda:	58 78       	cp.w	r8,7
80009bdc:	e0 89 00 04 	brgt	80009be4 <_vfprintf_r+0x197c>
80009be0:	2f 83       	sub	r3,-8
80009be2:	c0 b8       	rjmp	80009bf8 <_vfprintf_r+0x1990>
80009be4:	fa ca f9 78 	sub	r10,sp,-1672
80009be8:	02 9b       	mov	r11,r1
80009bea:	08 9c       	mov	r12,r4
80009bec:	fe b0 f3 30 	rcall	8000824c <__sprint_r>
80009bf0:	e0 81 02 bb 	brne	8000a166 <_vfprintf_r+0x1efe>
80009bf4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bf8:	40 66       	lddsp	r6,sp[0x18]
80009bfa:	20 16       	sub	r6,1
80009bfc:	58 06       	cp.w	r6,0
80009bfe:	e0 89 00 1d 	brgt	80009c38 <_vfprintf_r+0x19d0>
80009c02:	e0 8f 02 47 	bral	8000a090 <_vfprintf_r+0x1e28>
80009c06:	2f 09       	sub	r9,-16
80009c08:	2f f8       	sub	r8,-1
80009c0a:	fb 49 06 90 	st.w	sp[1680],r9
80009c0e:	87 02       	st.w	r3[0x0],r2
80009c10:	87 10       	st.w	r3[0x4],r0
80009c12:	fb 48 06 8c 	st.w	sp[1676],r8
80009c16:	58 78       	cp.w	r8,7
80009c18:	e0 89 00 04 	brgt	80009c20 <_vfprintf_r+0x19b8>
80009c1c:	2f 83       	sub	r3,-8
80009c1e:	c0 b8       	rjmp	80009c34 <_vfprintf_r+0x19cc>
80009c20:	fa ca f9 78 	sub	r10,sp,-1672
80009c24:	02 9b       	mov	r11,r1
80009c26:	08 9c       	mov	r12,r4
80009c28:	fe b0 f3 12 	rcall	8000824c <__sprint_r>
80009c2c:	e0 81 02 9d 	brne	8000a166 <_vfprintf_r+0x1efe>
80009c30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c34:	21 06       	sub	r6,16
80009c36:	c0 48       	rjmp	80009c3e <_vfprintf_r+0x19d6>
80009c38:	fe c2 ba c8 	sub	r2,pc,-17720
80009c3c:	31 00       	mov	r0,16
80009c3e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c42:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c46:	fe ca ba d6 	sub	r10,pc,-17706
80009c4a:	59 06       	cp.w	r6,16
80009c4c:	fe 99 ff dd 	brgt	80009c06 <_vfprintf_r+0x199e>
80009c50:	0c 09       	add	r9,r6
80009c52:	87 0a       	st.w	r3[0x0],r10
80009c54:	fb 49 06 90 	st.w	sp[1680],r9
80009c58:	2f f8       	sub	r8,-1
80009c5a:	87 16       	st.w	r3[0x4],r6
80009c5c:	c5 39       	rjmp	80009f02 <_vfprintf_r+0x1c9a>
80009c5e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009c62:	58 0a       	cp.w	r10,0
80009c64:	e0 89 00 92 	brgt	80009d88 <_vfprintf_r+0x1b20>
80009c68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c6c:	fe c9 bb 10 	sub	r9,pc,-17648
80009c70:	2f f8       	sub	r8,-1
80009c72:	87 09       	st.w	r3[0x0],r9
80009c74:	fb 48 06 90 	st.w	sp[1680],r8
80009c78:	30 19       	mov	r9,1
80009c7a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c7e:	87 19       	st.w	r3[0x4],r9
80009c80:	2f f8       	sub	r8,-1
80009c82:	fb 48 06 8c 	st.w	sp[1676],r8
80009c86:	58 78       	cp.w	r8,7
80009c88:	e0 89 00 04 	brgt	80009c90 <_vfprintf_r+0x1a28>
80009c8c:	2f 83       	sub	r3,-8
80009c8e:	c0 b8       	rjmp	80009ca4 <_vfprintf_r+0x1a3c>
80009c90:	fa ca f9 78 	sub	r10,sp,-1672
80009c94:	02 9b       	mov	r11,r1
80009c96:	08 9c       	mov	r12,r4
80009c98:	fe b0 f2 da 	rcall	8000824c <__sprint_r>
80009c9c:	e0 81 02 65 	brne	8000a166 <_vfprintf_r+0x1efe>
80009ca0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ca4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ca8:	58 08       	cp.w	r8,0
80009caa:	c0 81       	brne	80009cba <_vfprintf_r+0x1a52>
80009cac:	40 6a       	lddsp	r10,sp[0x18]
80009cae:	58 0a       	cp.w	r10,0
80009cb0:	c0 51       	brne	80009cba <_vfprintf_r+0x1a52>
80009cb2:	ed b5 00 00 	bld	r5,0x0
80009cb6:	e0 81 01 ed 	brne	8000a090 <_vfprintf_r+0x1e28>
80009cba:	40 c9       	lddsp	r9,sp[0x30]
80009cbc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cc0:	2f f8       	sub	r8,-1
80009cc2:	87 09       	st.w	r3[0x0],r9
80009cc4:	fb 48 06 90 	st.w	sp[1680],r8
80009cc8:	30 19       	mov	r9,1
80009cca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cce:	87 19       	st.w	r3[0x4],r9
80009cd0:	2f f8       	sub	r8,-1
80009cd2:	fb 48 06 8c 	st.w	sp[1676],r8
80009cd6:	58 78       	cp.w	r8,7
80009cd8:	e0 89 00 04 	brgt	80009ce0 <_vfprintf_r+0x1a78>
80009cdc:	2f 83       	sub	r3,-8
80009cde:	c0 b8       	rjmp	80009cf4 <_vfprintf_r+0x1a8c>
80009ce0:	fa ca f9 78 	sub	r10,sp,-1672
80009ce4:	02 9b       	mov	r11,r1
80009ce6:	08 9c       	mov	r12,r4
80009ce8:	fe b0 f2 b2 	rcall	8000824c <__sprint_r>
80009cec:	e0 81 02 3d 	brne	8000a166 <_vfprintf_r+0x1efe>
80009cf0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cf4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009cf8:	5c 32       	neg	r2
80009cfa:	58 02       	cp.w	r2,0
80009cfc:	e0 89 00 1d 	brgt	80009d36 <_vfprintf_r+0x1ace>
80009d00:	c3 d8       	rjmp	80009d7a <_vfprintf_r+0x1b12>
80009d02:	2f 09       	sub	r9,-16
80009d04:	2f f8       	sub	r8,-1
80009d06:	31 0e       	mov	lr,16
80009d08:	fb 49 06 90 	st.w	sp[1680],r9
80009d0c:	87 00       	st.w	r3[0x0],r0
80009d0e:	87 1e       	st.w	r3[0x4],lr
80009d10:	fb 48 06 8c 	st.w	sp[1676],r8
80009d14:	58 78       	cp.w	r8,7
80009d16:	e0 89 00 04 	brgt	80009d1e <_vfprintf_r+0x1ab6>
80009d1a:	2f 83       	sub	r3,-8
80009d1c:	c0 b8       	rjmp	80009d32 <_vfprintf_r+0x1aca>
80009d1e:	fa ca f9 78 	sub	r10,sp,-1672
80009d22:	02 9b       	mov	r11,r1
80009d24:	08 9c       	mov	r12,r4
80009d26:	fe b0 f2 93 	rcall	8000824c <__sprint_r>
80009d2a:	e0 81 02 1e 	brne	8000a166 <_vfprintf_r+0x1efe>
80009d2e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d32:	21 02       	sub	r2,16
80009d34:	c0 38       	rjmp	80009d3a <_vfprintf_r+0x1ad2>
80009d36:	fe c0 bb c6 	sub	r0,pc,-17466
80009d3a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d42:	fe ca bb d2 	sub	r10,pc,-17454
80009d46:	59 02       	cp.w	r2,16
80009d48:	fe 99 ff dd 	brgt	80009d02 <_vfprintf_r+0x1a9a>
80009d4c:	04 09       	add	r9,r2
80009d4e:	2f f8       	sub	r8,-1
80009d50:	87 0a       	st.w	r3[0x0],r10
80009d52:	fb 49 06 90 	st.w	sp[1680],r9
80009d56:	87 12       	st.w	r3[0x4],r2
80009d58:	fb 48 06 8c 	st.w	sp[1676],r8
80009d5c:	58 78       	cp.w	r8,7
80009d5e:	e0 89 00 04 	brgt	80009d66 <_vfprintf_r+0x1afe>
80009d62:	2f 83       	sub	r3,-8
80009d64:	c0 b8       	rjmp	80009d7a <_vfprintf_r+0x1b12>
80009d66:	fa ca f9 78 	sub	r10,sp,-1672
80009d6a:	02 9b       	mov	r11,r1
80009d6c:	08 9c       	mov	r12,r4
80009d6e:	fe b0 f2 6f 	rcall	8000824c <__sprint_r>
80009d72:	e0 81 01 fa 	brne	8000a166 <_vfprintf_r+0x1efe>
80009d76:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d7a:	40 6c       	lddsp	r12,sp[0x18]
80009d7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d80:	87 06       	st.w	r3[0x0],r6
80009d82:	87 1c       	st.w	r3[0x4],r12
80009d84:	18 08       	add	r8,r12
80009d86:	cb 98       	rjmp	80009ef8 <_vfprintf_r+0x1c90>
80009d88:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d90:	40 6b       	lddsp	r11,sp[0x18]
80009d92:	16 3a       	cp.w	r10,r11
80009d94:	c6 f5       	brlt	80009e72 <_vfprintf_r+0x1c0a>
80009d96:	16 09       	add	r9,r11
80009d98:	2f f8       	sub	r8,-1
80009d9a:	87 06       	st.w	r3[0x0],r6
80009d9c:	fb 49 06 90 	st.w	sp[1680],r9
80009da0:	87 1b       	st.w	r3[0x4],r11
80009da2:	fb 48 06 8c 	st.w	sp[1676],r8
80009da6:	58 78       	cp.w	r8,7
80009da8:	e0 89 00 04 	brgt	80009db0 <_vfprintf_r+0x1b48>
80009dac:	2f 83       	sub	r3,-8
80009dae:	c0 b8       	rjmp	80009dc4 <_vfprintf_r+0x1b5c>
80009db0:	fa ca f9 78 	sub	r10,sp,-1672
80009db4:	02 9b       	mov	r11,r1
80009db6:	08 9c       	mov	r12,r4
80009db8:	fe b0 f2 4a 	rcall	8000824c <__sprint_r>
80009dbc:	e0 81 01 d5 	brne	8000a166 <_vfprintf_r+0x1efe>
80009dc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dc4:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009dc8:	40 6a       	lddsp	r10,sp[0x18]
80009dca:	14 16       	sub	r6,r10
80009dcc:	58 06       	cp.w	r6,0
80009dce:	e0 89 00 1c 	brgt	80009e06 <_vfprintf_r+0x1b9e>
80009dd2:	c3 d8       	rjmp	80009e4c <_vfprintf_r+0x1be4>
80009dd4:	2f 09       	sub	r9,-16
80009dd6:	2f f8       	sub	r8,-1
80009dd8:	fb 49 06 90 	st.w	sp[1680],r9
80009ddc:	87 02       	st.w	r3[0x0],r2
80009dde:	87 10       	st.w	r3[0x4],r0
80009de0:	fb 48 06 8c 	st.w	sp[1676],r8
80009de4:	58 78       	cp.w	r8,7
80009de6:	e0 89 00 04 	brgt	80009dee <_vfprintf_r+0x1b86>
80009dea:	2f 83       	sub	r3,-8
80009dec:	c0 b8       	rjmp	80009e02 <_vfprintf_r+0x1b9a>
80009dee:	fa ca f9 78 	sub	r10,sp,-1672
80009df2:	02 9b       	mov	r11,r1
80009df4:	08 9c       	mov	r12,r4
80009df6:	fe b0 f2 2b 	rcall	8000824c <__sprint_r>
80009dfa:	e0 81 01 b6 	brne	8000a166 <_vfprintf_r+0x1efe>
80009dfe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e02:	21 06       	sub	r6,16
80009e04:	c0 48       	rjmp	80009e0c <_vfprintf_r+0x1ba4>
80009e06:	fe c2 bc 96 	sub	r2,pc,-17258
80009e0a:	31 00       	mov	r0,16
80009e0c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e14:	fe ca bc a4 	sub	r10,pc,-17244
80009e18:	59 06       	cp.w	r6,16
80009e1a:	fe 99 ff dd 	brgt	80009dd4 <_vfprintf_r+0x1b6c>
80009e1e:	0c 09       	add	r9,r6
80009e20:	2f f8       	sub	r8,-1
80009e22:	87 0a       	st.w	r3[0x0],r10
80009e24:	fb 49 06 90 	st.w	sp[1680],r9
80009e28:	87 16       	st.w	r3[0x4],r6
80009e2a:	fb 48 06 8c 	st.w	sp[1676],r8
80009e2e:	58 78       	cp.w	r8,7
80009e30:	e0 89 00 04 	brgt	80009e38 <_vfprintf_r+0x1bd0>
80009e34:	2f 83       	sub	r3,-8
80009e36:	c0 b8       	rjmp	80009e4c <_vfprintf_r+0x1be4>
80009e38:	fa ca f9 78 	sub	r10,sp,-1672
80009e3c:	02 9b       	mov	r11,r1
80009e3e:	08 9c       	mov	r12,r4
80009e40:	fe b0 f2 06 	rcall	8000824c <__sprint_r>
80009e44:	e0 81 01 91 	brne	8000a166 <_vfprintf_r+0x1efe>
80009e48:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e4c:	ed b5 00 00 	bld	r5,0x0
80009e50:	e0 81 01 20 	brne	8000a090 <_vfprintf_r+0x1e28>
80009e54:	40 c9       	lddsp	r9,sp[0x30]
80009e56:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e5a:	2f f8       	sub	r8,-1
80009e5c:	87 09       	st.w	r3[0x0],r9
80009e5e:	fb 48 06 90 	st.w	sp[1680],r8
80009e62:	30 19       	mov	r9,1
80009e64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e68:	87 19       	st.w	r3[0x4],r9
80009e6a:	2f f8       	sub	r8,-1
80009e6c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e70:	c0 29       	rjmp	8000a074 <_vfprintf_r+0x1e0c>
80009e72:	14 09       	add	r9,r10
80009e74:	2f f8       	sub	r8,-1
80009e76:	fb 49 06 90 	st.w	sp[1680],r9
80009e7a:	87 06       	st.w	r3[0x0],r6
80009e7c:	87 1a       	st.w	r3[0x4],r10
80009e7e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e82:	58 78       	cp.w	r8,7
80009e84:	e0 89 00 04 	brgt	80009e8c <_vfprintf_r+0x1c24>
80009e88:	2f 83       	sub	r3,-8
80009e8a:	c0 b8       	rjmp	80009ea0 <_vfprintf_r+0x1c38>
80009e8c:	fa ca f9 78 	sub	r10,sp,-1672
80009e90:	02 9b       	mov	r11,r1
80009e92:	08 9c       	mov	r12,r4
80009e94:	fe b0 f1 dc 	rcall	8000824c <__sprint_r>
80009e98:	e0 81 01 67 	brne	8000a166 <_vfprintf_r+0x1efe>
80009e9c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ea0:	40 c8       	lddsp	r8,sp[0x30]
80009ea2:	87 08       	st.w	r3[0x0],r8
80009ea4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ea8:	2f f8       	sub	r8,-1
80009eaa:	30 19       	mov	r9,1
80009eac:	fb 48 06 90 	st.w	sp[1680],r8
80009eb0:	87 19       	st.w	r3[0x4],r9
80009eb2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eb6:	2f f8       	sub	r8,-1
80009eb8:	fb 48 06 8c 	st.w	sp[1676],r8
80009ebc:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009ec0:	58 78       	cp.w	r8,7
80009ec2:	e0 89 00 04 	brgt	80009eca <_vfprintf_r+0x1c62>
80009ec6:	2f 83       	sub	r3,-8
80009ec8:	c0 b8       	rjmp	80009ede <_vfprintf_r+0x1c76>
80009eca:	fa ca f9 78 	sub	r10,sp,-1672
80009ece:	02 9b       	mov	r11,r1
80009ed0:	08 9c       	mov	r12,r4
80009ed2:	fe b0 f1 bd 	rcall	8000824c <__sprint_r>
80009ed6:	e0 81 01 48 	brne	8000a166 <_vfprintf_r+0x1efe>
80009eda:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ede:	04 06       	add	r6,r2
80009ee0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ee4:	87 06       	st.w	r3[0x0],r6
80009ee6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009eea:	40 66       	lddsp	r6,sp[0x18]
80009eec:	40 6e       	lddsp	lr,sp[0x18]
80009eee:	10 16       	sub	r6,r8
80009ef0:	f2 08 01 08 	sub	r8,r9,r8
80009ef4:	87 16       	st.w	r3[0x4],r6
80009ef6:	1c 08       	add	r8,lr
80009ef8:	fb 48 06 90 	st.w	sp[1680],r8
80009efc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f00:	2f f8       	sub	r8,-1
80009f02:	fb 48 06 8c 	st.w	sp[1676],r8
80009f06:	cb 78       	rjmp	8000a074 <_vfprintf_r+0x1e0c>
80009f08:	40 6c       	lddsp	r12,sp[0x18]
80009f0a:	58 1c       	cp.w	r12,1
80009f0c:	e0 89 00 06 	brgt	80009f18 <_vfprintf_r+0x1cb0>
80009f10:	ed b5 00 00 	bld	r5,0x0
80009f14:	e0 81 00 85 	brne	8000a01e <_vfprintf_r+0x1db6>
80009f18:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f1c:	2f f8       	sub	r8,-1
80009f1e:	30 19       	mov	r9,1
80009f20:	fb 48 06 90 	st.w	sp[1680],r8
80009f24:	87 06       	st.w	r3[0x0],r6
80009f26:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f2a:	87 19       	st.w	r3[0x4],r9
80009f2c:	2f f8       	sub	r8,-1
80009f2e:	fb 48 06 8c 	st.w	sp[1676],r8
80009f32:	58 78       	cp.w	r8,7
80009f34:	e0 89 00 04 	brgt	80009f3c <_vfprintf_r+0x1cd4>
80009f38:	2f 83       	sub	r3,-8
80009f3a:	c0 b8       	rjmp	80009f50 <_vfprintf_r+0x1ce8>
80009f3c:	fa ca f9 78 	sub	r10,sp,-1672
80009f40:	02 9b       	mov	r11,r1
80009f42:	08 9c       	mov	r12,r4
80009f44:	fe b0 f1 84 	rcall	8000824c <__sprint_r>
80009f48:	e0 81 01 0f 	brne	8000a166 <_vfprintf_r+0x1efe>
80009f4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f50:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f54:	2f f8       	sub	r8,-1
80009f56:	40 cb       	lddsp	r11,sp[0x30]
80009f58:	fb 48 06 90 	st.w	sp[1680],r8
80009f5c:	30 19       	mov	r9,1
80009f5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f62:	87 0b       	st.w	r3[0x0],r11
80009f64:	2f f8       	sub	r8,-1
80009f66:	87 19       	st.w	r3[0x4],r9
80009f68:	fb 48 06 8c 	st.w	sp[1676],r8
80009f6c:	58 78       	cp.w	r8,7
80009f6e:	e0 89 00 05 	brgt	80009f78 <_vfprintf_r+0x1d10>
80009f72:	2f 83       	sub	r3,-8
80009f74:	c0 c8       	rjmp	80009f8c <_vfprintf_r+0x1d24>
80009f76:	d7 03       	nop
80009f78:	fa ca f9 78 	sub	r10,sp,-1672
80009f7c:	02 9b       	mov	r11,r1
80009f7e:	08 9c       	mov	r12,r4
80009f80:	fe b0 f1 66 	rcall	8000824c <__sprint_r>
80009f84:	e0 81 00 f1 	brne	8000a166 <_vfprintf_r+0x1efe>
80009f88:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f8c:	30 08       	mov	r8,0
80009f8e:	30 09       	mov	r9,0
80009f90:	40 5b       	lddsp	r11,sp[0x14]
80009f92:	40 7a       	lddsp	r10,sp[0x1c]
80009f94:	e0 a0 13 25 	rcall	8000c5de <__avr32_f64_cmp_eq>
80009f98:	40 68       	lddsp	r8,sp[0x18]
80009f9a:	20 18       	sub	r8,1
80009f9c:	58 0c       	cp.w	r12,0
80009f9e:	c0 d1       	brne	80009fb8 <_vfprintf_r+0x1d50>
80009fa0:	2f f6       	sub	r6,-1
80009fa2:	87 18       	st.w	r3[0x4],r8
80009fa4:	87 06       	st.w	r3[0x0],r6
80009fa6:	fa f6 06 90 	ld.w	r6,sp[1680]
80009faa:	10 06       	add	r6,r8
80009fac:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fb0:	fb 46 06 90 	st.w	sp[1680],r6
80009fb4:	2f f8       	sub	r8,-1
80009fb6:	c3 18       	rjmp	8000a018 <_vfprintf_r+0x1db0>
80009fb8:	10 96       	mov	r6,r8
80009fba:	58 08       	cp.w	r8,0
80009fbc:	e0 89 00 1c 	brgt	80009ff4 <_vfprintf_r+0x1d8c>
80009fc0:	c4 b8       	rjmp	8000a056 <_vfprintf_r+0x1dee>
80009fc2:	2f 09       	sub	r9,-16
80009fc4:	2f f8       	sub	r8,-1
80009fc6:	fb 49 06 90 	st.w	sp[1680],r9
80009fca:	87 02       	st.w	r3[0x0],r2
80009fcc:	87 10       	st.w	r3[0x4],r0
80009fce:	fb 48 06 8c 	st.w	sp[1676],r8
80009fd2:	58 78       	cp.w	r8,7
80009fd4:	e0 89 00 04 	brgt	80009fdc <_vfprintf_r+0x1d74>
80009fd8:	2f 83       	sub	r3,-8
80009fda:	c0 b8       	rjmp	80009ff0 <_vfprintf_r+0x1d88>
80009fdc:	fa ca f9 78 	sub	r10,sp,-1672
80009fe0:	02 9b       	mov	r11,r1
80009fe2:	08 9c       	mov	r12,r4
80009fe4:	fe b0 f1 34 	rcall	8000824c <__sprint_r>
80009fe8:	e0 81 00 bf 	brne	8000a166 <_vfprintf_r+0x1efe>
80009fec:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ff0:	21 06       	sub	r6,16
80009ff2:	c0 48       	rjmp	80009ffa <_vfprintf_r+0x1d92>
80009ff4:	fe c2 be 84 	sub	r2,pc,-16764
80009ff8:	31 00       	mov	r0,16
80009ffa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ffe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a002:	fe ca be 92 	sub	r10,pc,-16750
8000a006:	59 06       	cp.w	r6,16
8000a008:	fe 99 ff dd 	brgt	80009fc2 <_vfprintf_r+0x1d5a>
8000a00c:	0c 09       	add	r9,r6
8000a00e:	87 0a       	st.w	r3[0x0],r10
8000a010:	fb 49 06 90 	st.w	sp[1680],r9
8000a014:	2f f8       	sub	r8,-1
8000a016:	87 16       	st.w	r3[0x4],r6
8000a018:	fb 48 06 8c 	st.w	sp[1676],r8
8000a01c:	c0 e8       	rjmp	8000a038 <_vfprintf_r+0x1dd0>
8000a01e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a022:	2f f8       	sub	r8,-1
8000a024:	30 19       	mov	r9,1
8000a026:	fb 48 06 90 	st.w	sp[1680],r8
8000a02a:	87 06       	st.w	r3[0x0],r6
8000a02c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a030:	87 19       	st.w	r3[0x4],r9
8000a032:	2f f8       	sub	r8,-1
8000a034:	fb 48 06 8c 	st.w	sp[1676],r8
8000a038:	58 78       	cp.w	r8,7
8000a03a:	e0 89 00 04 	brgt	8000a042 <_vfprintf_r+0x1dda>
8000a03e:	2f 83       	sub	r3,-8
8000a040:	c0 b8       	rjmp	8000a056 <_vfprintf_r+0x1dee>
8000a042:	fa ca f9 78 	sub	r10,sp,-1672
8000a046:	02 9b       	mov	r11,r1
8000a048:	08 9c       	mov	r12,r4
8000a04a:	fe b0 f1 01 	rcall	8000824c <__sprint_r>
8000a04e:	e0 81 00 8c 	brne	8000a166 <_vfprintf_r+0x1efe>
8000a052:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a056:	40 ea       	lddsp	r10,sp[0x38]
8000a058:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a05c:	14 08       	add	r8,r10
8000a05e:	fa c9 f9 64 	sub	r9,sp,-1692
8000a062:	fb 48 06 90 	st.w	sp[1680],r8
8000a066:	87 1a       	st.w	r3[0x4],r10
8000a068:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a06c:	87 09       	st.w	r3[0x0],r9
8000a06e:	2f f8       	sub	r8,-1
8000a070:	fb 48 06 8c 	st.w	sp[1676],r8
8000a074:	58 78       	cp.w	r8,7
8000a076:	e0 89 00 04 	brgt	8000a07e <_vfprintf_r+0x1e16>
8000a07a:	2f 83       	sub	r3,-8
8000a07c:	c0 a8       	rjmp	8000a090 <_vfprintf_r+0x1e28>
8000a07e:	fa ca f9 78 	sub	r10,sp,-1672
8000a082:	02 9b       	mov	r11,r1
8000a084:	08 9c       	mov	r12,r4
8000a086:	fe b0 f0 e3 	rcall	8000824c <__sprint_r>
8000a08a:	c6 e1       	brne	8000a166 <_vfprintf_r+0x1efe>
8000a08c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a090:	e2 15 00 04 	andl	r5,0x4,COH
8000a094:	c3 f0       	breq	8000a112 <_vfprintf_r+0x1eaa>
8000a096:	40 86       	lddsp	r6,sp[0x20]
8000a098:	40 39       	lddsp	r9,sp[0xc]
8000a09a:	12 16       	sub	r6,r9
8000a09c:	58 06       	cp.w	r6,0
8000a09e:	e0 89 00 1a 	brgt	8000a0d2 <_vfprintf_r+0x1e6a>
8000a0a2:	c3 88       	rjmp	8000a112 <_vfprintf_r+0x1eaa>
8000a0a4:	2f 09       	sub	r9,-16
8000a0a6:	2f f8       	sub	r8,-1
8000a0a8:	fb 49 06 90 	st.w	sp[1680],r9
8000a0ac:	87 05       	st.w	r3[0x0],r5
8000a0ae:	87 12       	st.w	r3[0x4],r2
8000a0b0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0b4:	58 78       	cp.w	r8,7
8000a0b6:	e0 89 00 04 	brgt	8000a0be <_vfprintf_r+0x1e56>
8000a0ba:	2f 83       	sub	r3,-8
8000a0bc:	c0 98       	rjmp	8000a0ce <_vfprintf_r+0x1e66>
8000a0be:	00 9a       	mov	r10,r0
8000a0c0:	02 9b       	mov	r11,r1
8000a0c2:	08 9c       	mov	r12,r4
8000a0c4:	fe b0 f0 c4 	rcall	8000824c <__sprint_r>
8000a0c8:	c4 f1       	brne	8000a166 <_vfprintf_r+0x1efe>
8000a0ca:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0ce:	21 06       	sub	r6,16
8000a0d0:	c0 68       	rjmp	8000a0dc <_vfprintf_r+0x1e74>
8000a0d2:	fe c5 bf 72 	sub	r5,pc,-16526
8000a0d6:	31 02       	mov	r2,16
8000a0d8:	fa c0 f9 78 	sub	r0,sp,-1672
8000a0dc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a0e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0e4:	fe ca bf 84 	sub	r10,pc,-16508
8000a0e8:	59 06       	cp.w	r6,16
8000a0ea:	fe 99 ff dd 	brgt	8000a0a4 <_vfprintf_r+0x1e3c>
8000a0ee:	0c 09       	add	r9,r6
8000a0f0:	2f f8       	sub	r8,-1
8000a0f2:	87 0a       	st.w	r3[0x0],r10
8000a0f4:	87 16       	st.w	r3[0x4],r6
8000a0f6:	fb 49 06 90 	st.w	sp[1680],r9
8000a0fa:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0fe:	58 78       	cp.w	r8,7
8000a100:	e0 8a 00 09 	brle	8000a112 <_vfprintf_r+0x1eaa>
8000a104:	fa ca f9 78 	sub	r10,sp,-1672
8000a108:	02 9b       	mov	r11,r1
8000a10a:	08 9c       	mov	r12,r4
8000a10c:	fe b0 f0 a0 	rcall	8000824c <__sprint_r>
8000a110:	c2 b1       	brne	8000a166 <_vfprintf_r+0x1efe>
8000a112:	40 bc       	lddsp	r12,sp[0x2c]
8000a114:	40 36       	lddsp	r6,sp[0xc]
8000a116:	40 8e       	lddsp	lr,sp[0x20]
8000a118:	ec 0e 0c 48 	max	r8,r6,lr
8000a11c:	10 0c       	add	r12,r8
8000a11e:	50 bc       	stdsp	sp[0x2c],r12
8000a120:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a124:	58 08       	cp.w	r8,0
8000a126:	c0 80       	breq	8000a136 <_vfprintf_r+0x1ece>
8000a128:	fa ca f9 78 	sub	r10,sp,-1672
8000a12c:	02 9b       	mov	r11,r1
8000a12e:	08 9c       	mov	r12,r4
8000a130:	fe b0 f0 8e 	rcall	8000824c <__sprint_r>
8000a134:	c1 91       	brne	8000a166 <_vfprintf_r+0x1efe>
8000a136:	30 0b       	mov	r11,0
8000a138:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a13c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a140:	fe 9f f1 22 	bral	80008384 <_vfprintf_r+0x11c>
8000a144:	08 95       	mov	r5,r4
8000a146:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a14a:	58 08       	cp.w	r8,0
8000a14c:	c0 80       	breq	8000a15c <_vfprintf_r+0x1ef4>
8000a14e:	08 9c       	mov	r12,r4
8000a150:	fa ca f9 78 	sub	r10,sp,-1672
8000a154:	02 9b       	mov	r11,r1
8000a156:	fe b0 f0 7b 	rcall	8000824c <__sprint_r>
8000a15a:	c0 61       	brne	8000a166 <_vfprintf_r+0x1efe>
8000a15c:	30 08       	mov	r8,0
8000a15e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a162:	c0 28       	rjmp	8000a166 <_vfprintf_r+0x1efe>
8000a164:	40 41       	lddsp	r1,sp[0x10]
8000a166:	82 68       	ld.sh	r8,r1[0xc]
8000a168:	ed b8 00 06 	bld	r8,0x6
8000a16c:	c0 31       	brne	8000a172 <_vfprintf_r+0x1f0a>
8000a16e:	3f fa       	mov	r10,-1
8000a170:	50 ba       	stdsp	sp[0x2c],r10
8000a172:	40 bc       	lddsp	r12,sp[0x2c]
8000a174:	fe 3d f9 44 	sub	sp,-1724
8000a178:	d8 32       	popm	r0-r7,pc
8000a17a:	d7 03       	nop

8000a17c <__swsetup_r>:
8000a17c:	d4 21       	pushm	r4-r7,lr
8000a17e:	e0 68 0a 48 	mov	r8,2632
8000a182:	18 96       	mov	r6,r12
8000a184:	16 97       	mov	r7,r11
8000a186:	70 0c       	ld.w	r12,r8[0x0]
8000a188:	58 0c       	cp.w	r12,0
8000a18a:	c0 60       	breq	8000a196 <__swsetup_r+0x1a>
8000a18c:	78 68       	ld.w	r8,r12[0x18]
8000a18e:	58 08       	cp.w	r8,0
8000a190:	c0 31       	brne	8000a196 <__swsetup_r+0x1a>
8000a192:	e0 a0 07 bf 	rcall	8000b110 <__sinit>
8000a196:	fe c8 bf 06 	sub	r8,pc,-16634
8000a19a:	10 37       	cp.w	r7,r8
8000a19c:	c0 61       	brne	8000a1a8 <__swsetup_r+0x2c>
8000a19e:	e0 68 0a 48 	mov	r8,2632
8000a1a2:	70 08       	ld.w	r8,r8[0x0]
8000a1a4:	70 07       	ld.w	r7,r8[0x0]
8000a1a6:	c1 28       	rjmp	8000a1ca <__swsetup_r+0x4e>
8000a1a8:	fe c8 be f8 	sub	r8,pc,-16648
8000a1ac:	10 37       	cp.w	r7,r8
8000a1ae:	c0 61       	brne	8000a1ba <__swsetup_r+0x3e>
8000a1b0:	e0 68 0a 48 	mov	r8,2632
8000a1b4:	70 08       	ld.w	r8,r8[0x0]
8000a1b6:	70 17       	ld.w	r7,r8[0x4]
8000a1b8:	c0 98       	rjmp	8000a1ca <__swsetup_r+0x4e>
8000a1ba:	fe c8 be ea 	sub	r8,pc,-16662
8000a1be:	10 37       	cp.w	r7,r8
8000a1c0:	c0 51       	brne	8000a1ca <__swsetup_r+0x4e>
8000a1c2:	e0 68 0a 48 	mov	r8,2632
8000a1c6:	70 08       	ld.w	r8,r8[0x0]
8000a1c8:	70 27       	ld.w	r7,r8[0x8]
8000a1ca:	8e 68       	ld.sh	r8,r7[0xc]
8000a1cc:	ed b8 00 03 	bld	r8,0x3
8000a1d0:	c1 e0       	breq	8000a20c <__swsetup_r+0x90>
8000a1d2:	ed b8 00 04 	bld	r8,0x4
8000a1d6:	c3 e1       	brne	8000a252 <__swsetup_r+0xd6>
8000a1d8:	ed b8 00 02 	bld	r8,0x2
8000a1dc:	c1 51       	brne	8000a206 <__swsetup_r+0x8a>
8000a1de:	6e db       	ld.w	r11,r7[0x34]
8000a1e0:	58 0b       	cp.w	r11,0
8000a1e2:	c0 a0       	breq	8000a1f6 <__swsetup_r+0x7a>
8000a1e4:	ee c8 ff bc 	sub	r8,r7,-68
8000a1e8:	10 3b       	cp.w	r11,r8
8000a1ea:	c0 40       	breq	8000a1f2 <__swsetup_r+0x76>
8000a1ec:	0c 9c       	mov	r12,r6
8000a1ee:	e0 a0 08 2b 	rcall	8000b244 <_free_r>
8000a1f2:	30 08       	mov	r8,0
8000a1f4:	8f d8       	st.w	r7[0x34],r8
8000a1f6:	8e 68       	ld.sh	r8,r7[0xc]
8000a1f8:	e0 18 ff db 	andl	r8,0xffdb
8000a1fc:	ae 68       	st.h	r7[0xc],r8
8000a1fe:	30 08       	mov	r8,0
8000a200:	8f 18       	st.w	r7[0x4],r8
8000a202:	6e 48       	ld.w	r8,r7[0x10]
8000a204:	8f 08       	st.w	r7[0x0],r8
8000a206:	8e 68       	ld.sh	r8,r7[0xc]
8000a208:	a3 b8       	sbr	r8,0x3
8000a20a:	ae 68       	st.h	r7[0xc],r8
8000a20c:	6e 48       	ld.w	r8,r7[0x10]
8000a20e:	58 08       	cp.w	r8,0
8000a210:	c0 b1       	brne	8000a226 <__swsetup_r+0xaa>
8000a212:	8e 68       	ld.sh	r8,r7[0xc]
8000a214:	e2 18 02 80 	andl	r8,0x280,COH
8000a218:	e0 48 02 00 	cp.w	r8,512
8000a21c:	c0 50       	breq	8000a226 <__swsetup_r+0xaa>
8000a21e:	0c 9c       	mov	r12,r6
8000a220:	0e 9b       	mov	r11,r7
8000a222:	e0 a0 0a 4b 	rcall	8000b6b8 <__smakebuf_r>
8000a226:	8e 69       	ld.sh	r9,r7[0xc]
8000a228:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a22c:	c0 70       	breq	8000a23a <__swsetup_r+0xbe>
8000a22e:	30 08       	mov	r8,0
8000a230:	8f 28       	st.w	r7[0x8],r8
8000a232:	6e 58       	ld.w	r8,r7[0x14]
8000a234:	5c 38       	neg	r8
8000a236:	8f 68       	st.w	r7[0x18],r8
8000a238:	c0 68       	rjmp	8000a244 <__swsetup_r+0xc8>
8000a23a:	ed b9 00 01 	bld	r9,0x1
8000a23e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a242:	8f 28       	st.w	r7[0x8],r8
8000a244:	6e 48       	ld.w	r8,r7[0x10]
8000a246:	58 08       	cp.w	r8,0
8000a248:	c0 61       	brne	8000a254 <__swsetup_r+0xd8>
8000a24a:	8e 68       	ld.sh	r8,r7[0xc]
8000a24c:	ed b8 00 07 	bld	r8,0x7
8000a250:	c0 21       	brne	8000a254 <__swsetup_r+0xd8>
8000a252:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a254:	d8 2a       	popm	r4-r7,pc,r12=0
8000a256:	d7 03       	nop

8000a258 <quorem>:
8000a258:	d4 31       	pushm	r0-r7,lr
8000a25a:	20 2d       	sub	sp,8
8000a25c:	18 97       	mov	r7,r12
8000a25e:	78 48       	ld.w	r8,r12[0x10]
8000a260:	76 46       	ld.w	r6,r11[0x10]
8000a262:	0c 38       	cp.w	r8,r6
8000a264:	c0 34       	brge	8000a26a <quorem+0x12>
8000a266:	30 0c       	mov	r12,0
8000a268:	c8 58       	rjmp	8000a372 <quorem+0x11a>
8000a26a:	ec c2 ff fc 	sub	r2,r6,-4
8000a26e:	f6 c3 ff ec 	sub	r3,r11,-20
8000a272:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a276:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a27a:	2f f9       	sub	r9,-1
8000a27c:	20 16       	sub	r6,1
8000a27e:	f8 09 0d 08 	divu	r8,r12,r9
8000a282:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a286:	ee c4 ff ec 	sub	r4,r7,-20
8000a28a:	10 95       	mov	r5,r8
8000a28c:	58 08       	cp.w	r8,0
8000a28e:	c4 10       	breq	8000a310 <quorem+0xb8>
8000a290:	30 09       	mov	r9,0
8000a292:	06 9a       	mov	r10,r3
8000a294:	08 98       	mov	r8,r4
8000a296:	12 91       	mov	r1,r9
8000a298:	50 0b       	stdsp	sp[0x0],r11
8000a29a:	70 0e       	ld.w	lr,r8[0x0]
8000a29c:	b1 8e       	lsr	lr,0x10
8000a29e:	50 1e       	stdsp	sp[0x4],lr
8000a2a0:	15 0e       	ld.w	lr,r10++
8000a2a2:	fc 00 16 10 	lsr	r0,lr,0x10
8000a2a6:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a2aa:	ea 0e 03 41 	mac	r1,r5,lr
8000a2ae:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a2b2:	b1 81       	lsr	r1,0x10
8000a2b4:	40 1b       	lddsp	r11,sp[0x4]
8000a2b6:	ea 00 02 40 	mul	r0,r5,r0
8000a2ba:	e2 00 00 00 	add	r0,r1,r0
8000a2be:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a2c2:	02 1b       	sub	r11,r1
8000a2c4:	50 1b       	stdsp	sp[0x4],r11
8000a2c6:	70 0b       	ld.w	r11,r8[0x0]
8000a2c8:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a2cc:	02 09       	add	r9,r1
8000a2ce:	f2 0e 01 0e 	sub	lr,r9,lr
8000a2d2:	b0 1e       	st.h	r8[0x2],lr
8000a2d4:	fc 09 14 10 	asr	r9,lr,0x10
8000a2d8:	40 1e       	lddsp	lr,sp[0x4]
8000a2da:	fc 09 00 09 	add	r9,lr,r9
8000a2de:	b0 09       	st.h	r8[0x0],r9
8000a2e0:	e0 01 16 10 	lsr	r1,r0,0x10
8000a2e4:	2f c8       	sub	r8,-4
8000a2e6:	b1 49       	asr	r9,0x10
8000a2e8:	04 3a       	cp.w	r10,r2
8000a2ea:	fe 98 ff d8 	brls	8000a29a <quorem+0x42>
8000a2ee:	40 0b       	lddsp	r11,sp[0x0]
8000a2f0:	58 0c       	cp.w	r12,0
8000a2f2:	c0 f1       	brne	8000a310 <quorem+0xb8>
8000a2f4:	ec c8 ff fb 	sub	r8,r6,-5
8000a2f8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a2fc:	c0 28       	rjmp	8000a300 <quorem+0xa8>
8000a2fe:	20 16       	sub	r6,1
8000a300:	20 48       	sub	r8,4
8000a302:	08 38       	cp.w	r8,r4
8000a304:	e0 88 00 05 	brls	8000a30e <quorem+0xb6>
8000a308:	70 09       	ld.w	r9,r8[0x0]
8000a30a:	58 09       	cp.w	r9,0
8000a30c:	cf 90       	breq	8000a2fe <quorem+0xa6>
8000a30e:	8f 46       	st.w	r7[0x10],r6
8000a310:	0e 9c       	mov	r12,r7
8000a312:	e0 a0 0a d2 	rcall	8000b8b6 <__mcmp>
8000a316:	c2 d5       	brlt	8000a370 <quorem+0x118>
8000a318:	2f f5       	sub	r5,-1
8000a31a:	08 98       	mov	r8,r4
8000a31c:	30 09       	mov	r9,0
8000a31e:	07 0b       	ld.w	r11,r3++
8000a320:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a324:	70 0c       	ld.w	r12,r8[0x0]
8000a326:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a32a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a32e:	14 1e       	sub	lr,r10
8000a330:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a334:	16 1a       	sub	r10,r11
8000a336:	12 0a       	add	r10,r9
8000a338:	b0 1a       	st.h	r8[0x2],r10
8000a33a:	b1 4a       	asr	r10,0x10
8000a33c:	fc 0a 00 09 	add	r9,lr,r10
8000a340:	b0 09       	st.h	r8[0x0],r9
8000a342:	2f c8       	sub	r8,-4
8000a344:	b1 49       	asr	r9,0x10
8000a346:	04 33       	cp.w	r3,r2
8000a348:	fe 98 ff eb 	brls	8000a31e <quorem+0xc6>
8000a34c:	ec c8 ff fb 	sub	r8,r6,-5
8000a350:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a354:	58 09       	cp.w	r9,0
8000a356:	c0 d1       	brne	8000a370 <quorem+0x118>
8000a358:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a35c:	c0 28       	rjmp	8000a360 <quorem+0x108>
8000a35e:	20 16       	sub	r6,1
8000a360:	20 48       	sub	r8,4
8000a362:	08 38       	cp.w	r8,r4
8000a364:	e0 88 00 05 	brls	8000a36e <quorem+0x116>
8000a368:	70 09       	ld.w	r9,r8[0x0]
8000a36a:	58 09       	cp.w	r9,0
8000a36c:	cf 90       	breq	8000a35e <quorem+0x106>
8000a36e:	8f 46       	st.w	r7[0x10],r6
8000a370:	0a 9c       	mov	r12,r5
8000a372:	2f ed       	sub	sp,-8
8000a374:	d8 32       	popm	r0-r7,pc
8000a376:	d7 03       	nop

8000a378 <_dtoa_r>:
8000a378:	d4 31       	pushm	r0-r7,lr
8000a37a:	21 ad       	sub	sp,104
8000a37c:	fa c4 ff 74 	sub	r4,sp,-140
8000a380:	18 97       	mov	r7,r12
8000a382:	16 95       	mov	r5,r11
8000a384:	68 2c       	ld.w	r12,r4[0x8]
8000a386:	50 c9       	stdsp	sp[0x30],r9
8000a388:	68 16       	ld.w	r6,r4[0x4]
8000a38a:	68 09       	ld.w	r9,r4[0x0]
8000a38c:	50 e8       	stdsp	sp[0x38],r8
8000a38e:	14 94       	mov	r4,r10
8000a390:	51 2c       	stdsp	sp[0x48],r12
8000a392:	fa e5 00 08 	st.d	sp[8],r4
8000a396:	51 59       	stdsp	sp[0x54],r9
8000a398:	6e 95       	ld.w	r5,r7[0x24]
8000a39a:	58 05       	cp.w	r5,0
8000a39c:	c0 91       	brne	8000a3ae <_dtoa_r+0x36>
8000a39e:	31 0c       	mov	r12,16
8000a3a0:	fe b0 e8 e2 	rcall	80007564 <malloc>
8000a3a4:	99 35       	st.w	r12[0xc],r5
8000a3a6:	8f 9c       	st.w	r7[0x24],r12
8000a3a8:	99 15       	st.w	r12[0x4],r5
8000a3aa:	99 25       	st.w	r12[0x8],r5
8000a3ac:	99 05       	st.w	r12[0x0],r5
8000a3ae:	6e 99       	ld.w	r9,r7[0x24]
8000a3b0:	72 08       	ld.w	r8,r9[0x0]
8000a3b2:	58 08       	cp.w	r8,0
8000a3b4:	c0 f0       	breq	8000a3d2 <_dtoa_r+0x5a>
8000a3b6:	72 1a       	ld.w	r10,r9[0x4]
8000a3b8:	91 1a       	st.w	r8[0x4],r10
8000a3ba:	30 1a       	mov	r10,1
8000a3bc:	72 19       	ld.w	r9,r9[0x4]
8000a3be:	f4 09 09 49 	lsl	r9,r10,r9
8000a3c2:	10 9b       	mov	r11,r8
8000a3c4:	91 29       	st.w	r8[0x8],r9
8000a3c6:	0e 9c       	mov	r12,r7
8000a3c8:	e0 a0 0a 90 	rcall	8000b8e8 <_Bfree>
8000a3cc:	6e 98       	ld.w	r8,r7[0x24]
8000a3ce:	30 09       	mov	r9,0
8000a3d0:	91 09       	st.w	r8[0x0],r9
8000a3d2:	40 28       	lddsp	r8,sp[0x8]
8000a3d4:	10 94       	mov	r4,r8
8000a3d6:	58 08       	cp.w	r8,0
8000a3d8:	c0 64       	brge	8000a3e4 <_dtoa_r+0x6c>
8000a3da:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a3de:	50 28       	stdsp	sp[0x8],r8
8000a3e0:	30 18       	mov	r8,1
8000a3e2:	c0 28       	rjmp	8000a3e6 <_dtoa_r+0x6e>
8000a3e4:	30 08       	mov	r8,0
8000a3e6:	8d 08       	st.w	r6[0x0],r8
8000a3e8:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a3ec:	40 26       	lddsp	r6,sp[0x8]
8000a3ee:	0c 98       	mov	r8,r6
8000a3f0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a3f4:	18 38       	cp.w	r8,r12
8000a3f6:	c2 01       	brne	8000a436 <_dtoa_r+0xbe>
8000a3f8:	e0 68 27 0f 	mov	r8,9999
8000a3fc:	41 5b       	lddsp	r11,sp[0x54]
8000a3fe:	97 08       	st.w	r11[0x0],r8
8000a400:	40 3a       	lddsp	r10,sp[0xc]
8000a402:	58 0a       	cp.w	r10,0
8000a404:	c0 71       	brne	8000a412 <_dtoa_r+0x9a>
8000a406:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a40a:	c0 41       	brne	8000a412 <_dtoa_r+0x9a>
8000a40c:	fe cc c1 8c 	sub	r12,pc,-15988
8000a410:	c0 38       	rjmp	8000a416 <_dtoa_r+0x9e>
8000a412:	fe cc c1 86 	sub	r12,pc,-15994
8000a416:	41 29       	lddsp	r9,sp[0x48]
8000a418:	58 09       	cp.w	r9,0
8000a41a:	e0 80 05 9a 	breq	8000af4e <_dtoa_r+0xbd6>
8000a41e:	f8 c8 ff fd 	sub	r8,r12,-3
8000a422:	f8 c9 ff f8 	sub	r9,r12,-8
8000a426:	11 8b       	ld.ub	r11,r8[0x0]
8000a428:	30 0a       	mov	r10,0
8000a42a:	41 25       	lddsp	r5,sp[0x48]
8000a42c:	f4 0b 18 00 	cp.b	r11,r10
8000a430:	f2 08 17 10 	movne	r8,r9
8000a434:	c1 68       	rjmp	8000a460 <_dtoa_r+0xe8>
8000a436:	fa ea 00 08 	ld.d	r10,sp[8]
8000a43a:	30 08       	mov	r8,0
8000a43c:	fa eb 00 3c 	st.d	sp[60],r10
8000a440:	30 09       	mov	r9,0
8000a442:	e0 a0 10 ce 	rcall	8000c5de <__avr32_f64_cmp_eq>
8000a446:	c1 00       	breq	8000a466 <_dtoa_r+0xee>
8000a448:	30 18       	mov	r8,1
8000a44a:	41 5a       	lddsp	r10,sp[0x54]
8000a44c:	95 08       	st.w	r10[0x0],r8
8000a44e:	fe cc c2 f2 	sub	r12,pc,-15630
8000a452:	41 29       	lddsp	r9,sp[0x48]
8000a454:	f8 08 00 08 	add	r8,r12,r8
8000a458:	58 09       	cp.w	r9,0
8000a45a:	e0 80 05 7a 	breq	8000af4e <_dtoa_r+0xbd6>
8000a45e:	12 95       	mov	r5,r9
8000a460:	8b 08       	st.w	r5[0x0],r8
8000a462:	e0 8f 05 76 	bral	8000af4e <_dtoa_r+0xbd6>
8000a466:	fa c8 ff 9c 	sub	r8,sp,-100
8000a46a:	fa c9 ff a0 	sub	r9,sp,-96
8000a46e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a472:	0e 9c       	mov	r12,r7
8000a474:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a478:	e0 a0 0a 8a 	rcall	8000b98c <__d2b>
8000a47c:	18 93       	mov	r3,r12
8000a47e:	58 05       	cp.w	r5,0
8000a480:	c0 d0       	breq	8000a49a <_dtoa_r+0x122>
8000a482:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a486:	30 04       	mov	r4,0
8000a488:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a48c:	ea c5 03 ff 	sub	r5,r5,1023
8000a490:	10 9b       	mov	r11,r8
8000a492:	51 74       	stdsp	sp[0x5c],r4
8000a494:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a498:	c2 58       	rjmp	8000a4e2 <_dtoa_r+0x16a>
8000a49a:	41 88       	lddsp	r8,sp[0x60]
8000a49c:	41 9c       	lddsp	r12,sp[0x64]
8000a49e:	10 0c       	add	r12,r8
8000a4a0:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a4a4:	e0 45 00 20 	cp.w	r5,32
8000a4a8:	e0 8a 00 0e 	brle	8000a4c4 <_dtoa_r+0x14c>
8000a4ac:	f8 cc fb ee 	sub	r12,r12,-1042
8000a4b0:	40 3b       	lddsp	r11,sp[0xc]
8000a4b2:	ea 08 11 40 	rsub	r8,r5,64
8000a4b6:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a4ba:	ec 08 09 46 	lsl	r6,r6,r8
8000a4be:	0c 4c       	or	r12,r6
8000a4c0:	c0 78       	rjmp	8000a4ce <_dtoa_r+0x156>
8000a4c2:	d7 03       	nop
8000a4c4:	ea 0c 11 20 	rsub	r12,r5,32
8000a4c8:	40 3a       	lddsp	r10,sp[0xc]
8000a4ca:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a4ce:	e0 a0 10 14 	rcall	8000c4f6 <__avr32_u32_to_f64>
8000a4d2:	fc 18 fe 10 	movh	r8,0xfe10
8000a4d6:	30 19       	mov	r9,1
8000a4d8:	ea c5 04 33 	sub	r5,r5,1075
8000a4dc:	f0 0b 00 0b 	add	r11,r8,r11
8000a4e0:	51 79       	stdsp	sp[0x5c],r9
8000a4e2:	30 08       	mov	r8,0
8000a4e4:	fc 19 3f f8 	movh	r9,0x3ff8
8000a4e8:	e0 a0 0e 9c 	rcall	8000c220 <__avr32_f64_sub>
8000a4ec:	e0 68 43 61 	mov	r8,17249
8000a4f0:	ea 18 63 6f 	orh	r8,0x636f
8000a4f4:	e0 69 87 a7 	mov	r9,34727
8000a4f8:	ea 19 3f d2 	orh	r9,0x3fd2
8000a4fc:	e0 a0 0d a6 	rcall	8000c048 <__avr32_f64_mul>
8000a500:	e0 68 c8 b3 	mov	r8,51379
8000a504:	ea 18 8b 60 	orh	r8,0x8b60
8000a508:	e0 69 8a 28 	mov	r9,35368
8000a50c:	ea 19 3f c6 	orh	r9,0x3fc6
8000a510:	e0 a0 0f 56 	rcall	8000c3bc <__avr32_f64_add>
8000a514:	0a 9c       	mov	r12,r5
8000a516:	14 90       	mov	r0,r10
8000a518:	16 91       	mov	r1,r11
8000a51a:	e0 a0 0f f2 	rcall	8000c4fe <__avr32_s32_to_f64>
8000a51e:	e0 68 79 fb 	mov	r8,31227
8000a522:	ea 18 50 9f 	orh	r8,0x509f
8000a526:	e0 69 44 13 	mov	r9,17427
8000a52a:	ea 19 3f d3 	orh	r9,0x3fd3
8000a52e:	e0 a0 0d 8d 	rcall	8000c048 <__avr32_f64_mul>
8000a532:	14 98       	mov	r8,r10
8000a534:	16 99       	mov	r9,r11
8000a536:	00 9a       	mov	r10,r0
8000a538:	02 9b       	mov	r11,r1
8000a53a:	e0 a0 0f 41 	rcall	8000c3bc <__avr32_f64_add>
8000a53e:	14 90       	mov	r0,r10
8000a540:	16 91       	mov	r1,r11
8000a542:	e0 a0 0f c7 	rcall	8000c4d0 <__avr32_f64_to_s32>
8000a546:	30 08       	mov	r8,0
8000a548:	18 96       	mov	r6,r12
8000a54a:	30 09       	mov	r9,0
8000a54c:	00 9a       	mov	r10,r0
8000a54e:	02 9b       	mov	r11,r1
8000a550:	e0 a0 10 8e 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a554:	c0 c0       	breq	8000a56c <_dtoa_r+0x1f4>
8000a556:	0c 9c       	mov	r12,r6
8000a558:	e0 a0 0f d3 	rcall	8000c4fe <__avr32_s32_to_f64>
8000a55c:	14 98       	mov	r8,r10
8000a55e:	16 99       	mov	r9,r11
8000a560:	00 9a       	mov	r10,r0
8000a562:	02 9b       	mov	r11,r1
8000a564:	e0 a0 10 3d 	rcall	8000c5de <__avr32_f64_cmp_eq>
8000a568:	f7 b6 00 01 	subeq	r6,1
8000a56c:	59 66       	cp.w	r6,22
8000a56e:	e0 88 00 05 	brls	8000a578 <_dtoa_r+0x200>
8000a572:	30 18       	mov	r8,1
8000a574:	51 48       	stdsp	sp[0x50],r8
8000a576:	c1 38       	rjmp	8000a59c <_dtoa_r+0x224>
8000a578:	fe c8 c2 38 	sub	r8,pc,-15816
8000a57c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a580:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a584:	e0 a0 10 74 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a588:	f9 b4 00 00 	moveq	r4,0
8000a58c:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a590:	f7 b6 01 01 	subne	r6,1
8000a594:	f9 bc 01 00 	movne	r12,0
8000a598:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a59c:	41 90       	lddsp	r0,sp[0x64]
8000a59e:	20 10       	sub	r0,1
8000a5a0:	0a 10       	sub	r0,r5
8000a5a2:	c0 46       	brmi	8000a5aa <_dtoa_r+0x232>
8000a5a4:	50 40       	stdsp	sp[0x10],r0
8000a5a6:	30 00       	mov	r0,0
8000a5a8:	c0 48       	rjmp	8000a5b0 <_dtoa_r+0x238>
8000a5aa:	30 0b       	mov	r11,0
8000a5ac:	5c 30       	neg	r0
8000a5ae:	50 4b       	stdsp	sp[0x10],r11
8000a5b0:	ec 02 11 00 	rsub	r2,r6,0
8000a5b4:	58 06       	cp.w	r6,0
8000a5b6:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a5ba:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a5be:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a5c2:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a5c6:	f9 b2 04 00 	movge	r2,0
8000a5ca:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a5ce:	f9 b9 05 00 	movlt	r9,0
8000a5d2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a5d6:	40 c8       	lddsp	r8,sp[0x30]
8000a5d8:	58 98       	cp.w	r8,9
8000a5da:	e0 8b 00 20 	brhi	8000a61a <_dtoa_r+0x2a2>
8000a5de:	58 58       	cp.w	r8,5
8000a5e0:	f9 b4 0a 01 	movle	r4,1
8000a5e4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a5e8:	f7 b5 09 04 	subgt	r5,4
8000a5ec:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a5f0:	f9 b4 09 00 	movgt	r4,0
8000a5f4:	40 cc       	lddsp	r12,sp[0x30]
8000a5f6:	58 3c       	cp.w	r12,3
8000a5f8:	c2 d0       	breq	8000a652 <_dtoa_r+0x2da>
8000a5fa:	e0 89 00 05 	brgt	8000a604 <_dtoa_r+0x28c>
8000a5fe:	58 2c       	cp.w	r12,2
8000a600:	c1 01       	brne	8000a620 <_dtoa_r+0x2a8>
8000a602:	c1 88       	rjmp	8000a632 <_dtoa_r+0x2ba>
8000a604:	40 cb       	lddsp	r11,sp[0x30]
8000a606:	58 4b       	cp.w	r11,4
8000a608:	c0 60       	breq	8000a614 <_dtoa_r+0x29c>
8000a60a:	58 5b       	cp.w	r11,5
8000a60c:	c0 a1       	brne	8000a620 <_dtoa_r+0x2a8>
8000a60e:	30 1a       	mov	r10,1
8000a610:	50 da       	stdsp	sp[0x34],r10
8000a612:	c2 28       	rjmp	8000a656 <_dtoa_r+0x2de>
8000a614:	30 19       	mov	r9,1
8000a616:	50 d9       	stdsp	sp[0x34],r9
8000a618:	c0 f8       	rjmp	8000a636 <_dtoa_r+0x2be>
8000a61a:	30 08       	mov	r8,0
8000a61c:	30 14       	mov	r4,1
8000a61e:	50 c8       	stdsp	sp[0x30],r8
8000a620:	3f f5       	mov	r5,-1
8000a622:	30 1c       	mov	r12,1
8000a624:	30 0b       	mov	r11,0
8000a626:	50 95       	stdsp	sp[0x24],r5
8000a628:	50 dc       	stdsp	sp[0x34],r12
8000a62a:	0a 91       	mov	r1,r5
8000a62c:	31 28       	mov	r8,18
8000a62e:	50 eb       	stdsp	sp[0x38],r11
8000a630:	c2 08       	rjmp	8000a670 <_dtoa_r+0x2f8>
8000a632:	30 0a       	mov	r10,0
8000a634:	50 da       	stdsp	sp[0x34],r10
8000a636:	40 e9       	lddsp	r9,sp[0x38]
8000a638:	58 09       	cp.w	r9,0
8000a63a:	e0 89 00 07 	brgt	8000a648 <_dtoa_r+0x2d0>
8000a63e:	30 18       	mov	r8,1
8000a640:	50 98       	stdsp	sp[0x24],r8
8000a642:	10 91       	mov	r1,r8
8000a644:	50 e8       	stdsp	sp[0x38],r8
8000a646:	c1 58       	rjmp	8000a670 <_dtoa_r+0x2f8>
8000a648:	40 e5       	lddsp	r5,sp[0x38]
8000a64a:	50 95       	stdsp	sp[0x24],r5
8000a64c:	0a 91       	mov	r1,r5
8000a64e:	0a 98       	mov	r8,r5
8000a650:	c1 08       	rjmp	8000a670 <_dtoa_r+0x2f8>
8000a652:	30 0c       	mov	r12,0
8000a654:	50 dc       	stdsp	sp[0x34],r12
8000a656:	40 eb       	lddsp	r11,sp[0x38]
8000a658:	ec 0b 00 0b 	add	r11,r6,r11
8000a65c:	50 9b       	stdsp	sp[0x24],r11
8000a65e:	16 98       	mov	r8,r11
8000a660:	2f f8       	sub	r8,-1
8000a662:	58 08       	cp.w	r8,0
8000a664:	e0 89 00 05 	brgt	8000a66e <_dtoa_r+0x2f6>
8000a668:	10 91       	mov	r1,r8
8000a66a:	30 18       	mov	r8,1
8000a66c:	c0 28       	rjmp	8000a670 <_dtoa_r+0x2f8>
8000a66e:	10 91       	mov	r1,r8
8000a670:	30 09       	mov	r9,0
8000a672:	6e 9a       	ld.w	r10,r7[0x24]
8000a674:	95 19       	st.w	r10[0x4],r9
8000a676:	30 49       	mov	r9,4
8000a678:	c0 68       	rjmp	8000a684 <_dtoa_r+0x30c>
8000a67a:	d7 03       	nop
8000a67c:	6a 1a       	ld.w	r10,r5[0x4]
8000a67e:	a1 79       	lsl	r9,0x1
8000a680:	2f fa       	sub	r10,-1
8000a682:	8b 1a       	st.w	r5[0x4],r10
8000a684:	6e 95       	ld.w	r5,r7[0x24]
8000a686:	f2 ca ff ec 	sub	r10,r9,-20
8000a68a:	10 3a       	cp.w	r10,r8
8000a68c:	fe 98 ff f8 	brls	8000a67c <_dtoa_r+0x304>
8000a690:	6a 1b       	ld.w	r11,r5[0x4]
8000a692:	0e 9c       	mov	r12,r7
8000a694:	e0 a0 09 44 	rcall	8000b91c <_Balloc>
8000a698:	58 e1       	cp.w	r1,14
8000a69a:	5f 88       	srls	r8
8000a69c:	8b 0c       	st.w	r5[0x0],r12
8000a69e:	f1 e4 00 04 	and	r4,r8,r4
8000a6a2:	6e 98       	ld.w	r8,r7[0x24]
8000a6a4:	70 08       	ld.w	r8,r8[0x0]
8000a6a6:	50 88       	stdsp	sp[0x20],r8
8000a6a8:	e0 80 01 82 	breq	8000a9ac <_dtoa_r+0x634>
8000a6ac:	58 06       	cp.w	r6,0
8000a6ae:	e0 8a 00 43 	brle	8000a734 <_dtoa_r+0x3bc>
8000a6b2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a6b6:	fe c8 c3 76 	sub	r8,pc,-15498
8000a6ba:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a6be:	fa e5 00 18 	st.d	sp[24],r4
8000a6c2:	ec 04 14 04 	asr	r4,r6,0x4
8000a6c6:	ed b4 00 04 	bld	r4,0x4
8000a6ca:	c0 30       	breq	8000a6d0 <_dtoa_r+0x358>
8000a6cc:	30 25       	mov	r5,2
8000a6ce:	c1 08       	rjmp	8000a6ee <_dtoa_r+0x376>
8000a6d0:	fe c8 c2 c8 	sub	r8,pc,-15672
8000a6d4:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a6d8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a6dc:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a6e0:	e0 a0 0f fa 	rcall	8000c6d4 <__avr32_f64_div>
8000a6e4:	30 35       	mov	r5,3
8000a6e6:	14 98       	mov	r8,r10
8000a6e8:	16 99       	mov	r9,r11
8000a6ea:	fa e9 00 08 	st.d	sp[8],r8
8000a6ee:	fe cc c2 e6 	sub	r12,pc,-15642
8000a6f2:	50 a3       	stdsp	sp[0x28],r3
8000a6f4:	0c 93       	mov	r3,r6
8000a6f6:	18 96       	mov	r6,r12
8000a6f8:	c0 f8       	rjmp	8000a716 <_dtoa_r+0x39e>
8000a6fa:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6fe:	ed b4 00 00 	bld	r4,0x0
8000a702:	c0 81       	brne	8000a712 <_dtoa_r+0x39a>
8000a704:	ec e8 00 00 	ld.d	r8,r6[0]
8000a708:	2f f5       	sub	r5,-1
8000a70a:	e0 a0 0c 9f 	rcall	8000c048 <__avr32_f64_mul>
8000a70e:	fa eb 00 18 	st.d	sp[24],r10
8000a712:	a1 54       	asr	r4,0x1
8000a714:	2f 86       	sub	r6,-8
8000a716:	58 04       	cp.w	r4,0
8000a718:	cf 11       	brne	8000a6fa <_dtoa_r+0x382>
8000a71a:	fa e8 00 18 	ld.d	r8,sp[24]
8000a71e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a722:	06 96       	mov	r6,r3
8000a724:	e0 a0 0f d8 	rcall	8000c6d4 <__avr32_f64_div>
8000a728:	40 a3       	lddsp	r3,sp[0x28]
8000a72a:	14 98       	mov	r8,r10
8000a72c:	16 99       	mov	r9,r11
8000a72e:	fa e9 00 08 	st.d	sp[8],r8
8000a732:	c2 f8       	rjmp	8000a790 <_dtoa_r+0x418>
8000a734:	ec 08 11 00 	rsub	r8,r6,0
8000a738:	c0 31       	brne	8000a73e <_dtoa_r+0x3c6>
8000a73a:	30 25       	mov	r5,2
8000a73c:	c2 a8       	rjmp	8000a790 <_dtoa_r+0x418>
8000a73e:	fe cc c3 36 	sub	r12,pc,-15562
8000a742:	f0 04 14 04 	asr	r4,r8,0x4
8000a746:	50 1c       	stdsp	sp[0x4],r12
8000a748:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a74c:	fe c9 c4 0c 	sub	r9,pc,-15348
8000a750:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a754:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a758:	e0 a0 0c 78 	rcall	8000c048 <__avr32_f64_mul>
8000a75c:	40 1c       	lddsp	r12,sp[0x4]
8000a75e:	50 63       	stdsp	sp[0x18],r3
8000a760:	30 25       	mov	r5,2
8000a762:	0c 93       	mov	r3,r6
8000a764:	fa eb 00 08 	st.d	sp[8],r10
8000a768:	18 96       	mov	r6,r12
8000a76a:	c0 f8       	rjmp	8000a788 <_dtoa_r+0x410>
8000a76c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a770:	ed b4 00 00 	bld	r4,0x0
8000a774:	c0 81       	brne	8000a784 <_dtoa_r+0x40c>
8000a776:	ec e8 00 00 	ld.d	r8,r6[0]
8000a77a:	2f f5       	sub	r5,-1
8000a77c:	e0 a0 0c 66 	rcall	8000c048 <__avr32_f64_mul>
8000a780:	fa eb 00 08 	st.d	sp[8],r10
8000a784:	a1 54       	asr	r4,0x1
8000a786:	2f 86       	sub	r6,-8
8000a788:	58 04       	cp.w	r4,0
8000a78a:	cf 11       	brne	8000a76c <_dtoa_r+0x3f4>
8000a78c:	06 96       	mov	r6,r3
8000a78e:	40 63       	lddsp	r3,sp[0x18]
8000a790:	41 4a       	lddsp	r10,sp[0x50]
8000a792:	58 0a       	cp.w	r10,0
8000a794:	c2 a0       	breq	8000a7e8 <_dtoa_r+0x470>
8000a796:	fa e8 00 08 	ld.d	r8,sp[8]
8000a79a:	58 01       	cp.w	r1,0
8000a79c:	5f 94       	srgt	r4
8000a79e:	fa e9 00 18 	st.d	sp[24],r8
8000a7a2:	30 08       	mov	r8,0
8000a7a4:	fc 19 3f f0 	movh	r9,0x3ff0
8000a7a8:	fa ea 00 18 	ld.d	r10,sp[24]
8000a7ac:	e0 a0 0f 60 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a7b0:	f9 bc 00 00 	moveq	r12,0
8000a7b4:	f9 bc 01 01 	movne	r12,1
8000a7b8:	e9 ec 00 0c 	and	r12,r4,r12
8000a7bc:	c1 60       	breq	8000a7e8 <_dtoa_r+0x470>
8000a7be:	40 98       	lddsp	r8,sp[0x24]
8000a7c0:	58 08       	cp.w	r8,0
8000a7c2:	e0 8a 00 f1 	brle	8000a9a4 <_dtoa_r+0x62c>
8000a7c6:	30 08       	mov	r8,0
8000a7c8:	fc 19 40 24 	movh	r9,0x4024
8000a7cc:	ec c4 00 01 	sub	r4,r6,1
8000a7d0:	fa ea 00 18 	ld.d	r10,sp[24]
8000a7d4:	2f f5       	sub	r5,-1
8000a7d6:	50 64       	stdsp	sp[0x18],r4
8000a7d8:	e0 a0 0c 38 	rcall	8000c048 <__avr32_f64_mul>
8000a7dc:	40 94       	lddsp	r4,sp[0x24]
8000a7de:	14 98       	mov	r8,r10
8000a7e0:	16 99       	mov	r9,r11
8000a7e2:	fa e9 00 08 	st.d	sp[8],r8
8000a7e6:	c0 38       	rjmp	8000a7ec <_dtoa_r+0x474>
8000a7e8:	50 66       	stdsp	sp[0x18],r6
8000a7ea:	02 94       	mov	r4,r1
8000a7ec:	0a 9c       	mov	r12,r5
8000a7ee:	e0 a0 0e 88 	rcall	8000c4fe <__avr32_s32_to_f64>
8000a7f2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7f6:	e0 a0 0c 29 	rcall	8000c048 <__avr32_f64_mul>
8000a7fa:	30 08       	mov	r8,0
8000a7fc:	fc 19 40 1c 	movh	r9,0x401c
8000a800:	e0 a0 0d de 	rcall	8000c3bc <__avr32_f64_add>
8000a804:	14 98       	mov	r8,r10
8000a806:	16 99       	mov	r9,r11
8000a808:	fa e9 00 28 	st.d	sp[40],r8
8000a80c:	fc 18 fc c0 	movh	r8,0xfcc0
8000a810:	40 a5       	lddsp	r5,sp[0x28]
8000a812:	10 05       	add	r5,r8
8000a814:	50 a5       	stdsp	sp[0x28],r5
8000a816:	58 04       	cp.w	r4,0
8000a818:	c2 11       	brne	8000a85a <_dtoa_r+0x4e2>
8000a81a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a81e:	30 08       	mov	r8,0
8000a820:	fc 19 40 14 	movh	r9,0x4014
8000a824:	e0 a0 0c fe 	rcall	8000c220 <__avr32_f64_sub>
8000a828:	40 bc       	lddsp	r12,sp[0x2c]
8000a82a:	fa eb 00 08 	st.d	sp[8],r10
8000a82e:	14 98       	mov	r8,r10
8000a830:	16 99       	mov	r9,r11
8000a832:	18 9a       	mov	r10,r12
8000a834:	0a 9b       	mov	r11,r5
8000a836:	e0 a0 0f 1b 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a83a:	e0 81 02 54 	brne	8000ace2 <_dtoa_r+0x96a>
8000a83e:	0a 98       	mov	r8,r5
8000a840:	40 b9       	lddsp	r9,sp[0x2c]
8000a842:	ee 18 80 00 	eorh	r8,0x8000
8000a846:	fa ea 00 08 	ld.d	r10,sp[8]
8000a84a:	10 95       	mov	r5,r8
8000a84c:	12 98       	mov	r8,r9
8000a84e:	0a 99       	mov	r9,r5
8000a850:	e0 a0 0f 0e 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a854:	e0 81 02 3e 	brne	8000acd0 <_dtoa_r+0x958>
8000a858:	ca 68       	rjmp	8000a9a4 <_dtoa_r+0x62c>
8000a85a:	fe c9 c5 1a 	sub	r9,pc,-15078
8000a85e:	e8 c8 00 01 	sub	r8,r4,1
8000a862:	40 d5       	lddsp	r5,sp[0x34]
8000a864:	58 05       	cp.w	r5,0
8000a866:	c4 f0       	breq	8000a904 <_dtoa_r+0x58c>
8000a868:	30 0c       	mov	r12,0
8000a86a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a86e:	51 3c       	stdsp	sp[0x4c],r12
8000a870:	30 0a       	mov	r10,0
8000a872:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a876:	e0 a0 0f 2f 	rcall	8000c6d4 <__avr32_f64_div>
8000a87a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a87e:	40 85       	lddsp	r5,sp[0x20]
8000a880:	e0 a0 0c d0 	rcall	8000c220 <__avr32_f64_sub>
8000a884:	fa eb 00 28 	st.d	sp[40],r10
8000a888:	fa ea 00 08 	ld.d	r10,sp[8]
8000a88c:	e0 a0 0e 22 	rcall	8000c4d0 <__avr32_f64_to_s32>
8000a890:	51 6c       	stdsp	sp[0x58],r12
8000a892:	e0 a0 0e 36 	rcall	8000c4fe <__avr32_s32_to_f64>
8000a896:	14 98       	mov	r8,r10
8000a898:	16 99       	mov	r9,r11
8000a89a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a89e:	e0 a0 0c c1 	rcall	8000c220 <__avr32_f64_sub>
8000a8a2:	fa eb 00 08 	st.d	sp[8],r10
8000a8a6:	41 68       	lddsp	r8,sp[0x58]
8000a8a8:	2d 08       	sub	r8,-48
8000a8aa:	0a c8       	st.b	r5++,r8
8000a8ac:	41 39       	lddsp	r9,sp[0x4c]
8000a8ae:	2f f9       	sub	r9,-1
8000a8b0:	51 39       	stdsp	sp[0x4c],r9
8000a8b2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8b6:	e0 a0 0e db 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a8ba:	e0 81 03 39 	brne	8000af2c <_dtoa_r+0xbb4>
8000a8be:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8c2:	30 0a       	mov	r10,0
8000a8c4:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a8c8:	e0 a0 0c ac 	rcall	8000c220 <__avr32_f64_sub>
8000a8cc:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8d0:	e0 a0 0e ce 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a8d4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a8d8:	30 08       	mov	r8,0
8000a8da:	fc 19 40 24 	movh	r9,0x4024
8000a8de:	e0 81 00 da 	brne	8000aa92 <_dtoa_r+0x71a>
8000a8e2:	41 3c       	lddsp	r12,sp[0x4c]
8000a8e4:	08 3c       	cp.w	r12,r4
8000a8e6:	c5 f4       	brge	8000a9a4 <_dtoa_r+0x62c>
8000a8e8:	e0 a0 0b b0 	rcall	8000c048 <__avr32_f64_mul>
8000a8ec:	30 08       	mov	r8,0
8000a8ee:	fa eb 00 28 	st.d	sp[40],r10
8000a8f2:	fc 19 40 24 	movh	r9,0x4024
8000a8f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8fa:	e0 a0 0b a7 	rcall	8000c048 <__avr32_f64_mul>
8000a8fe:	fa eb 00 08 	st.d	sp[8],r10
8000a902:	cc 3b       	rjmp	8000a888 <_dtoa_r+0x510>
8000a904:	40 85       	lddsp	r5,sp[0x20]
8000a906:	08 05       	add	r5,r4
8000a908:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a90c:	51 35       	stdsp	sp[0x4c],r5
8000a90e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a912:	40 85       	lddsp	r5,sp[0x20]
8000a914:	e0 a0 0b 9a 	rcall	8000c048 <__avr32_f64_mul>
8000a918:	fa eb 00 28 	st.d	sp[40],r10
8000a91c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a920:	e0 a0 0d d8 	rcall	8000c4d0 <__avr32_f64_to_s32>
8000a924:	51 6c       	stdsp	sp[0x58],r12
8000a926:	e0 a0 0d ec 	rcall	8000c4fe <__avr32_s32_to_f64>
8000a92a:	14 98       	mov	r8,r10
8000a92c:	16 99       	mov	r9,r11
8000a92e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a932:	e0 a0 0c 77 	rcall	8000c220 <__avr32_f64_sub>
8000a936:	fa eb 00 08 	st.d	sp[8],r10
8000a93a:	41 68       	lddsp	r8,sp[0x58]
8000a93c:	2d 08       	sub	r8,-48
8000a93e:	0a c8       	st.b	r5++,r8
8000a940:	41 3c       	lddsp	r12,sp[0x4c]
8000a942:	18 35       	cp.w	r5,r12
8000a944:	c2 81       	brne	8000a994 <_dtoa_r+0x61c>
8000a946:	30 08       	mov	r8,0
8000a948:	fc 19 3f e0 	movh	r9,0x3fe0
8000a94c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a950:	e0 a0 0d 36 	rcall	8000c3bc <__avr32_f64_add>
8000a954:	40 85       	lddsp	r5,sp[0x20]
8000a956:	fa e8 00 08 	ld.d	r8,sp[8]
8000a95a:	08 05       	add	r5,r4
8000a95c:	e0 a0 0e 88 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a960:	e0 81 00 99 	brne	8000aa92 <_dtoa_r+0x71a>
8000a964:	fa e8 00 28 	ld.d	r8,sp[40]
8000a968:	30 0a       	mov	r10,0
8000a96a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a96e:	e0 a0 0c 59 	rcall	8000c220 <__avr32_f64_sub>
8000a972:	14 98       	mov	r8,r10
8000a974:	16 99       	mov	r9,r11
8000a976:	fa ea 00 08 	ld.d	r10,sp[8]
8000a97a:	e0 a0 0e 79 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000a97e:	c1 30       	breq	8000a9a4 <_dtoa_r+0x62c>
8000a980:	33 09       	mov	r9,48
8000a982:	0a 98       	mov	r8,r5
8000a984:	11 7a       	ld.ub	r10,--r8
8000a986:	f2 0a 18 00 	cp.b	r10,r9
8000a98a:	e0 81 02 d1 	brne	8000af2c <_dtoa_r+0xbb4>
8000a98e:	10 95       	mov	r5,r8
8000a990:	cf 9b       	rjmp	8000a982 <_dtoa_r+0x60a>
8000a992:	d7 03       	nop
8000a994:	30 08       	mov	r8,0
8000a996:	fc 19 40 24 	movh	r9,0x4024
8000a99a:	e0 a0 0b 57 	rcall	8000c048 <__avr32_f64_mul>
8000a99e:	fa eb 00 08 	st.d	sp[8],r10
8000a9a2:	cb db       	rjmp	8000a91c <_dtoa_r+0x5a4>
8000a9a4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a9a8:	fa eb 00 08 	st.d	sp[8],r10
8000a9ac:	58 e6       	cp.w	r6,14
8000a9ae:	5f ab       	srle	r11
8000a9b0:	41 8a       	lddsp	r10,sp[0x60]
8000a9b2:	30 08       	mov	r8,0
8000a9b4:	f4 09 11 ff 	rsub	r9,r10,-1
8000a9b8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a9bc:	f0 09 18 00 	cp.b	r9,r8
8000a9c0:	e0 80 00 82 	breq	8000aac4 <_dtoa_r+0x74c>
8000a9c4:	40 ea       	lddsp	r10,sp[0x38]
8000a9c6:	58 01       	cp.w	r1,0
8000a9c8:	5f a9       	srle	r9
8000a9ca:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a9ce:	fe ca c6 8e 	sub	r10,pc,-14706
8000a9d2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a9d6:	fa e5 00 10 	st.d	sp[16],r4
8000a9da:	f0 09 18 00 	cp.b	r9,r8
8000a9de:	c1 40       	breq	8000aa06 <_dtoa_r+0x68e>
8000a9e0:	58 01       	cp.w	r1,0
8000a9e2:	e0 81 01 77 	brne	8000acd0 <_dtoa_r+0x958>
8000a9e6:	30 08       	mov	r8,0
8000a9e8:	fc 19 40 14 	movh	r9,0x4014
8000a9ec:	08 9a       	mov	r10,r4
8000a9ee:	0a 9b       	mov	r11,r5
8000a9f0:	e0 a0 0b 2c 	rcall	8000c048 <__avr32_f64_mul>
8000a9f4:	fa e8 00 08 	ld.d	r8,sp[8]
8000a9f8:	e0 a0 0e 06 	rcall	8000c604 <__avr32_f64_cmp_ge>
8000a9fc:	e0 81 01 6a 	brne	8000acd0 <_dtoa_r+0x958>
8000aa00:	02 92       	mov	r2,r1
8000aa02:	e0 8f 01 72 	bral	8000ace6 <_dtoa_r+0x96e>
8000aa06:	40 85       	lddsp	r5,sp[0x20]
8000aa08:	30 14       	mov	r4,1
8000aa0a:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa0e:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa12:	e0 a0 0e 61 	rcall	8000c6d4 <__avr32_f64_div>
8000aa16:	e0 a0 0d 5d 	rcall	8000c4d0 <__avr32_f64_to_s32>
8000aa1a:	18 92       	mov	r2,r12
8000aa1c:	e0 a0 0d 71 	rcall	8000c4fe <__avr32_s32_to_f64>
8000aa20:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa24:	e0 a0 0b 12 	rcall	8000c048 <__avr32_f64_mul>
8000aa28:	14 98       	mov	r8,r10
8000aa2a:	16 99       	mov	r9,r11
8000aa2c:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa30:	e0 a0 0b f8 	rcall	8000c220 <__avr32_f64_sub>
8000aa34:	fa eb 00 08 	st.d	sp[8],r10
8000aa38:	e4 c8 ff d0 	sub	r8,r2,-48
8000aa3c:	0a c8       	st.b	r5++,r8
8000aa3e:	fc 19 40 24 	movh	r9,0x4024
8000aa42:	30 08       	mov	r8,0
8000aa44:	02 34       	cp.w	r4,r1
8000aa46:	c3 31       	brne	8000aaac <_dtoa_r+0x734>
8000aa48:	fa e8 00 08 	ld.d	r8,sp[8]
8000aa4c:	e0 a0 0c b8 	rcall	8000c3bc <__avr32_f64_add>
8000aa50:	16 91       	mov	r1,r11
8000aa52:	14 90       	mov	r0,r10
8000aa54:	14 98       	mov	r8,r10
8000aa56:	02 99       	mov	r9,r1
8000aa58:	fa ea 00 10 	ld.d	r10,sp[16]
8000aa5c:	e0 a0 0e 08 	rcall	8000c66c <__avr32_f64_cmp_lt>
8000aa60:	c1 a1       	brne	8000aa94 <_dtoa_r+0x71c>
8000aa62:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa66:	00 9a       	mov	r10,r0
8000aa68:	02 9b       	mov	r11,r1
8000aa6a:	e0 a0 0d ba 	rcall	8000c5de <__avr32_f64_cmp_eq>
8000aa6e:	e0 80 02 5e 	breq	8000af2a <_dtoa_r+0xbb2>
8000aa72:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000aa76:	c0 f1       	brne	8000aa94 <_dtoa_r+0x71c>
8000aa78:	e0 8f 02 59 	bral	8000af2a <_dtoa_r+0xbb2>
8000aa7c:	40 8a       	lddsp	r10,sp[0x20]
8000aa7e:	14 38       	cp.w	r8,r10
8000aa80:	c0 30       	breq	8000aa86 <_dtoa_r+0x70e>
8000aa82:	10 95       	mov	r5,r8
8000aa84:	c0 98       	rjmp	8000aa96 <_dtoa_r+0x71e>
8000aa86:	33 08       	mov	r8,48
8000aa88:	40 89       	lddsp	r9,sp[0x20]
8000aa8a:	2f f6       	sub	r6,-1
8000aa8c:	b2 88       	st.b	r9[0x0],r8
8000aa8e:	40 88       	lddsp	r8,sp[0x20]
8000aa90:	c0 88       	rjmp	8000aaa0 <_dtoa_r+0x728>
8000aa92:	40 66       	lddsp	r6,sp[0x18]
8000aa94:	33 99       	mov	r9,57
8000aa96:	0a 98       	mov	r8,r5
8000aa98:	11 7a       	ld.ub	r10,--r8
8000aa9a:	f2 0a 18 00 	cp.b	r10,r9
8000aa9e:	ce f0       	breq	8000aa7c <_dtoa_r+0x704>
8000aaa0:	50 66       	stdsp	sp[0x18],r6
8000aaa2:	11 89       	ld.ub	r9,r8[0x0]
8000aaa4:	2f f9       	sub	r9,-1
8000aaa6:	b0 89       	st.b	r8[0x0],r9
8000aaa8:	e0 8f 02 42 	bral	8000af2c <_dtoa_r+0xbb4>
8000aaac:	e0 a0 0a ce 	rcall	8000c048 <__avr32_f64_mul>
8000aab0:	2f f4       	sub	r4,-1
8000aab2:	fa eb 00 08 	st.d	sp[8],r10
8000aab6:	30 08       	mov	r8,0
8000aab8:	30 09       	mov	r9,0
8000aaba:	e0 a0 0d 92 	rcall	8000c5de <__avr32_f64_cmp_eq>
8000aabe:	ca 60       	breq	8000aa0a <_dtoa_r+0x692>
8000aac0:	e0 8f 02 35 	bral	8000af2a <_dtoa_r+0xbb2>
8000aac4:	40 d8       	lddsp	r8,sp[0x34]
8000aac6:	58 08       	cp.w	r8,0
8000aac8:	c0 51       	brne	8000aad2 <_dtoa_r+0x75a>
8000aaca:	04 98       	mov	r8,r2
8000aacc:	00 95       	mov	r5,r0
8000aace:	40 d4       	lddsp	r4,sp[0x34]
8000aad0:	c3 78       	rjmp	8000ab3e <_dtoa_r+0x7c6>
8000aad2:	40 c5       	lddsp	r5,sp[0x30]
8000aad4:	58 15       	cp.w	r5,1
8000aad6:	e0 89 00 0f 	brgt	8000aaf4 <_dtoa_r+0x77c>
8000aada:	41 74       	lddsp	r4,sp[0x5c]
8000aadc:	58 04       	cp.w	r4,0
8000aade:	c0 40       	breq	8000aae6 <_dtoa_r+0x76e>
8000aae0:	f4 c9 fb cd 	sub	r9,r10,-1075
8000aae4:	c0 48       	rjmp	8000aaec <_dtoa_r+0x774>
8000aae6:	41 99       	lddsp	r9,sp[0x64]
8000aae8:	f2 09 11 36 	rsub	r9,r9,54
8000aaec:	04 98       	mov	r8,r2
8000aaee:	00 95       	mov	r5,r0
8000aaf0:	c1 c8       	rjmp	8000ab28 <_dtoa_r+0x7b0>
8000aaf2:	d7 03       	nop
8000aaf4:	e2 c8 00 01 	sub	r8,r1,1
8000aaf8:	58 01       	cp.w	r1,0
8000aafa:	e0 05 17 40 	movge	r5,r0
8000aafe:	e2 09 17 40 	movge	r9,r1
8000ab02:	e1 d1 e5 15 	sublt	r5,r0,r1
8000ab06:	f9 b9 05 00 	movlt	r9,0
8000ab0a:	10 32       	cp.w	r2,r8
8000ab0c:	e5 d8 e4 18 	subge	r8,r2,r8
8000ab10:	f1 d2 e5 18 	sublt	r8,r8,r2
8000ab14:	e5 d8 e5 02 	addlt	r2,r2,r8
8000ab18:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000ab1c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000ab20:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000ab24:	f9 b8 05 00 	movlt	r8,0
8000ab28:	40 4b       	lddsp	r11,sp[0x10]
8000ab2a:	12 0b       	add	r11,r9
8000ab2c:	50 08       	stdsp	sp[0x0],r8
8000ab2e:	50 4b       	stdsp	sp[0x10],r11
8000ab30:	12 00       	add	r0,r9
8000ab32:	30 1b       	mov	r11,1
8000ab34:	0e 9c       	mov	r12,r7
8000ab36:	e0 a0 08 a7 	rcall	8000bc84 <__i2b>
8000ab3a:	40 08       	lddsp	r8,sp[0x0]
8000ab3c:	18 94       	mov	r4,r12
8000ab3e:	40 4a       	lddsp	r10,sp[0x10]
8000ab40:	58 05       	cp.w	r5,0
8000ab42:	5f 99       	srgt	r9
8000ab44:	58 0a       	cp.w	r10,0
8000ab46:	5f 9a       	srgt	r10
8000ab48:	f5 e9 00 09 	and	r9,r10,r9
8000ab4c:	c0 80       	breq	8000ab5c <_dtoa_r+0x7e4>
8000ab4e:	40 4c       	lddsp	r12,sp[0x10]
8000ab50:	f8 05 0d 49 	min	r9,r12,r5
8000ab54:	12 1c       	sub	r12,r9
8000ab56:	12 10       	sub	r0,r9
8000ab58:	50 4c       	stdsp	sp[0x10],r12
8000ab5a:	12 15       	sub	r5,r9
8000ab5c:	58 02       	cp.w	r2,0
8000ab5e:	e0 8a 00 27 	brle	8000abac <_dtoa_r+0x834>
8000ab62:	40 db       	lddsp	r11,sp[0x34]
8000ab64:	58 0b       	cp.w	r11,0
8000ab66:	c1 d0       	breq	8000aba0 <_dtoa_r+0x828>
8000ab68:	58 08       	cp.w	r8,0
8000ab6a:	e0 8a 00 17 	brle	8000ab98 <_dtoa_r+0x820>
8000ab6e:	10 9a       	mov	r10,r8
8000ab70:	50 08       	stdsp	sp[0x0],r8
8000ab72:	08 9b       	mov	r11,r4
8000ab74:	0e 9c       	mov	r12,r7
8000ab76:	e0 a0 08 cd 	rcall	8000bd10 <__pow5mult>
8000ab7a:	06 9a       	mov	r10,r3
8000ab7c:	18 9b       	mov	r11,r12
8000ab7e:	18 94       	mov	r4,r12
8000ab80:	0e 9c       	mov	r12,r7
8000ab82:	e0 a0 08 01 	rcall	8000bb84 <__multiply>
8000ab86:	18 99       	mov	r9,r12
8000ab88:	06 9b       	mov	r11,r3
8000ab8a:	50 19       	stdsp	sp[0x4],r9
8000ab8c:	0e 9c       	mov	r12,r7
8000ab8e:	e0 a0 06 ad 	rcall	8000b8e8 <_Bfree>
8000ab92:	40 19       	lddsp	r9,sp[0x4]
8000ab94:	40 08       	lddsp	r8,sp[0x0]
8000ab96:	12 93       	mov	r3,r9
8000ab98:	e4 08 01 0a 	sub	r10,r2,r8
8000ab9c:	c0 80       	breq	8000abac <_dtoa_r+0x834>
8000ab9e:	c0 28       	rjmp	8000aba2 <_dtoa_r+0x82a>
8000aba0:	04 9a       	mov	r10,r2
8000aba2:	06 9b       	mov	r11,r3
8000aba4:	0e 9c       	mov	r12,r7
8000aba6:	e0 a0 08 b5 	rcall	8000bd10 <__pow5mult>
8000abaa:	18 93       	mov	r3,r12
8000abac:	30 1b       	mov	r11,1
8000abae:	0e 9c       	mov	r12,r7
8000abb0:	e0 a0 08 6a 	rcall	8000bc84 <__i2b>
8000abb4:	41 1a       	lddsp	r10,sp[0x44]
8000abb6:	18 92       	mov	r2,r12
8000abb8:	58 0a       	cp.w	r10,0
8000abba:	e0 8a 00 07 	brle	8000abc8 <_dtoa_r+0x850>
8000abbe:	18 9b       	mov	r11,r12
8000abc0:	0e 9c       	mov	r12,r7
8000abc2:	e0 a0 08 a7 	rcall	8000bd10 <__pow5mult>
8000abc6:	18 92       	mov	r2,r12
8000abc8:	40 c9       	lddsp	r9,sp[0x30]
8000abca:	58 19       	cp.w	r9,1
8000abcc:	e0 89 00 14 	brgt	8000abf4 <_dtoa_r+0x87c>
8000abd0:	40 38       	lddsp	r8,sp[0xc]
8000abd2:	58 08       	cp.w	r8,0
8000abd4:	c1 01       	brne	8000abf4 <_dtoa_r+0x87c>
8000abd6:	40 29       	lddsp	r9,sp[0x8]
8000abd8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000abdc:	c0 c1       	brne	8000abf4 <_dtoa_r+0x87c>
8000abde:	12 98       	mov	r8,r9
8000abe0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000abe4:	c0 80       	breq	8000abf4 <_dtoa_r+0x87c>
8000abe6:	40 4c       	lddsp	r12,sp[0x10]
8000abe8:	30 1b       	mov	r11,1
8000abea:	2f fc       	sub	r12,-1
8000abec:	2f f0       	sub	r0,-1
8000abee:	50 4c       	stdsp	sp[0x10],r12
8000abf0:	50 6b       	stdsp	sp[0x18],r11
8000abf2:	c0 38       	rjmp	8000abf8 <_dtoa_r+0x880>
8000abf4:	30 0a       	mov	r10,0
8000abf6:	50 6a       	stdsp	sp[0x18],r10
8000abf8:	41 19       	lddsp	r9,sp[0x44]
8000abfa:	58 09       	cp.w	r9,0
8000abfc:	c0 31       	brne	8000ac02 <_dtoa_r+0x88a>
8000abfe:	30 1c       	mov	r12,1
8000ac00:	c0 98       	rjmp	8000ac12 <_dtoa_r+0x89a>
8000ac02:	64 48       	ld.w	r8,r2[0x10]
8000ac04:	2f c8       	sub	r8,-4
8000ac06:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ac0a:	e0 a0 05 df 	rcall	8000b7c8 <__hi0bits>
8000ac0e:	f8 0c 11 20 	rsub	r12,r12,32
8000ac12:	40 4b       	lddsp	r11,sp[0x10]
8000ac14:	f8 0b 00 08 	add	r8,r12,r11
8000ac18:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ac1c:	c0 c0       	breq	8000ac34 <_dtoa_r+0x8bc>
8000ac1e:	f0 08 11 20 	rsub	r8,r8,32
8000ac22:	58 48       	cp.w	r8,4
8000ac24:	e0 8a 00 06 	brle	8000ac30 <_dtoa_r+0x8b8>
8000ac28:	20 48       	sub	r8,4
8000ac2a:	10 0b       	add	r11,r8
8000ac2c:	50 4b       	stdsp	sp[0x10],r11
8000ac2e:	c0 78       	rjmp	8000ac3c <_dtoa_r+0x8c4>
8000ac30:	58 48       	cp.w	r8,4
8000ac32:	c0 70       	breq	8000ac40 <_dtoa_r+0x8c8>
8000ac34:	40 4a       	lddsp	r10,sp[0x10]
8000ac36:	2e 48       	sub	r8,-28
8000ac38:	10 0a       	add	r10,r8
8000ac3a:	50 4a       	stdsp	sp[0x10],r10
8000ac3c:	10 00       	add	r0,r8
8000ac3e:	10 05       	add	r5,r8
8000ac40:	58 00       	cp.w	r0,0
8000ac42:	e0 8a 00 08 	brle	8000ac52 <_dtoa_r+0x8da>
8000ac46:	06 9b       	mov	r11,r3
8000ac48:	00 9a       	mov	r10,r0
8000ac4a:	0e 9c       	mov	r12,r7
8000ac4c:	e0 a0 07 58 	rcall	8000bafc <__lshift>
8000ac50:	18 93       	mov	r3,r12
8000ac52:	40 49       	lddsp	r9,sp[0x10]
8000ac54:	58 09       	cp.w	r9,0
8000ac56:	e0 8a 00 08 	brle	8000ac66 <_dtoa_r+0x8ee>
8000ac5a:	04 9b       	mov	r11,r2
8000ac5c:	12 9a       	mov	r10,r9
8000ac5e:	0e 9c       	mov	r12,r7
8000ac60:	e0 a0 07 4e 	rcall	8000bafc <__lshift>
8000ac64:	18 92       	mov	r2,r12
8000ac66:	41 48       	lddsp	r8,sp[0x50]
8000ac68:	58 08       	cp.w	r8,0
8000ac6a:	c1 b0       	breq	8000aca0 <_dtoa_r+0x928>
8000ac6c:	04 9b       	mov	r11,r2
8000ac6e:	06 9c       	mov	r12,r3
8000ac70:	e0 a0 06 23 	rcall	8000b8b6 <__mcmp>
8000ac74:	c1 64       	brge	8000aca0 <_dtoa_r+0x928>
8000ac76:	06 9b       	mov	r11,r3
8000ac78:	30 09       	mov	r9,0
8000ac7a:	30 aa       	mov	r10,10
8000ac7c:	0e 9c       	mov	r12,r7
8000ac7e:	e0 a0 08 0b 	rcall	8000bc94 <__multadd>
8000ac82:	20 16       	sub	r6,1
8000ac84:	18 93       	mov	r3,r12
8000ac86:	40 dc       	lddsp	r12,sp[0x34]
8000ac88:	58 0c       	cp.w	r12,0
8000ac8a:	c0 31       	brne	8000ac90 <_dtoa_r+0x918>
8000ac8c:	40 91       	lddsp	r1,sp[0x24]
8000ac8e:	c0 98       	rjmp	8000aca0 <_dtoa_r+0x928>
8000ac90:	08 9b       	mov	r11,r4
8000ac92:	40 91       	lddsp	r1,sp[0x24]
8000ac94:	30 09       	mov	r9,0
8000ac96:	30 aa       	mov	r10,10
8000ac98:	0e 9c       	mov	r12,r7
8000ac9a:	e0 a0 07 fd 	rcall	8000bc94 <__multadd>
8000ac9e:	18 94       	mov	r4,r12
8000aca0:	58 01       	cp.w	r1,0
8000aca2:	5f a9       	srle	r9
8000aca4:	40 cb       	lddsp	r11,sp[0x30]
8000aca6:	58 2b       	cp.w	r11,2
8000aca8:	5f 98       	srgt	r8
8000acaa:	f3 e8 00 08 	and	r8,r9,r8
8000acae:	c2 50       	breq	8000acf8 <_dtoa_r+0x980>
8000acb0:	58 01       	cp.w	r1,0
8000acb2:	c1 11       	brne	8000acd4 <_dtoa_r+0x95c>
8000acb4:	04 9b       	mov	r11,r2
8000acb6:	02 99       	mov	r9,r1
8000acb8:	30 5a       	mov	r10,5
8000acba:	0e 9c       	mov	r12,r7
8000acbc:	e0 a0 07 ec 	rcall	8000bc94 <__multadd>
8000acc0:	18 92       	mov	r2,r12
8000acc2:	18 9b       	mov	r11,r12
8000acc4:	06 9c       	mov	r12,r3
8000acc6:	e0 a0 05 f8 	rcall	8000b8b6 <__mcmp>
8000acca:	e0 89 00 0f 	brgt	8000ace8 <_dtoa_r+0x970>
8000acce:	c0 38       	rjmp	8000acd4 <_dtoa_r+0x95c>
8000acd0:	30 02       	mov	r2,0
8000acd2:	04 94       	mov	r4,r2
8000acd4:	40 ea       	lddsp	r10,sp[0x38]
8000acd6:	30 09       	mov	r9,0
8000acd8:	5c da       	com	r10
8000acda:	40 85       	lddsp	r5,sp[0x20]
8000acdc:	50 6a       	stdsp	sp[0x18],r10
8000acde:	50 49       	stdsp	sp[0x10],r9
8000ace0:	c0 f9       	rjmp	8000aefe <_dtoa_r+0xb86>
8000ace2:	08 92       	mov	r2,r4
8000ace4:	40 66       	lddsp	r6,sp[0x18]
8000ace6:	04 94       	mov	r4,r2
8000ace8:	2f f6       	sub	r6,-1
8000acea:	50 66       	stdsp	sp[0x18],r6
8000acec:	33 18       	mov	r8,49
8000acee:	40 85       	lddsp	r5,sp[0x20]
8000acf0:	0a c8       	st.b	r5++,r8
8000acf2:	30 08       	mov	r8,0
8000acf4:	50 48       	stdsp	sp[0x10],r8
8000acf6:	c0 49       	rjmp	8000aefe <_dtoa_r+0xb86>
8000acf8:	40 dc       	lddsp	r12,sp[0x34]
8000acfa:	58 0c       	cp.w	r12,0
8000acfc:	e0 80 00 b5 	breq	8000ae66 <_dtoa_r+0xaee>
8000ad00:	58 05       	cp.w	r5,0
8000ad02:	e0 8a 00 08 	brle	8000ad12 <_dtoa_r+0x99a>
8000ad06:	08 9b       	mov	r11,r4
8000ad08:	0a 9a       	mov	r10,r5
8000ad0a:	0e 9c       	mov	r12,r7
8000ad0c:	e0 a0 06 f8 	rcall	8000bafc <__lshift>
8000ad10:	18 94       	mov	r4,r12
8000ad12:	40 6b       	lddsp	r11,sp[0x18]
8000ad14:	58 0b       	cp.w	r11,0
8000ad16:	c0 31       	brne	8000ad1c <_dtoa_r+0x9a4>
8000ad18:	08 9c       	mov	r12,r4
8000ad1a:	c1 38       	rjmp	8000ad40 <_dtoa_r+0x9c8>
8000ad1c:	68 1b       	ld.w	r11,r4[0x4]
8000ad1e:	0e 9c       	mov	r12,r7
8000ad20:	e0 a0 05 fe 	rcall	8000b91c <_Balloc>
8000ad24:	68 4a       	ld.w	r10,r4[0x10]
8000ad26:	18 95       	mov	r5,r12
8000ad28:	e8 cb ff f4 	sub	r11,r4,-12
8000ad2c:	2f ea       	sub	r10,-2
8000ad2e:	2f 4c       	sub	r12,-12
8000ad30:	a3 6a       	lsl	r10,0x2
8000ad32:	fe b0 e6 50 	rcall	800079d2 <memcpy>
8000ad36:	0a 9b       	mov	r11,r5
8000ad38:	30 1a       	mov	r10,1
8000ad3a:	0e 9c       	mov	r12,r7
8000ad3c:	e0 a0 06 e0 	rcall	8000bafc <__lshift>
8000ad40:	50 44       	stdsp	sp[0x10],r4
8000ad42:	40 3a       	lddsp	r10,sp[0xc]
8000ad44:	30 19       	mov	r9,1
8000ad46:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ad4a:	18 94       	mov	r4,r12
8000ad4c:	50 da       	stdsp	sp[0x34],r10
8000ad4e:	40 85       	lddsp	r5,sp[0x20]
8000ad50:	50 99       	stdsp	sp[0x24],r9
8000ad52:	50 26       	stdsp	sp[0x8],r6
8000ad54:	50 e1       	stdsp	sp[0x38],r1
8000ad56:	04 9b       	mov	r11,r2
8000ad58:	06 9c       	mov	r12,r3
8000ad5a:	fe b0 fa 7f 	rcall	8000a258 <quorem>
8000ad5e:	40 4b       	lddsp	r11,sp[0x10]
8000ad60:	f8 c0 ff d0 	sub	r0,r12,-48
8000ad64:	06 9c       	mov	r12,r3
8000ad66:	e0 a0 05 a8 	rcall	8000b8b6 <__mcmp>
8000ad6a:	08 9a       	mov	r10,r4
8000ad6c:	50 6c       	stdsp	sp[0x18],r12
8000ad6e:	04 9b       	mov	r11,r2
8000ad70:	0e 9c       	mov	r12,r7
8000ad72:	e0 a0 06 5d 	rcall	8000ba2c <__mdiff>
8000ad76:	18 91       	mov	r1,r12
8000ad78:	78 38       	ld.w	r8,r12[0xc]
8000ad7a:	58 08       	cp.w	r8,0
8000ad7c:	c0 30       	breq	8000ad82 <_dtoa_r+0xa0a>
8000ad7e:	30 16       	mov	r6,1
8000ad80:	c0 68       	rjmp	8000ad8c <_dtoa_r+0xa14>
8000ad82:	18 9b       	mov	r11,r12
8000ad84:	06 9c       	mov	r12,r3
8000ad86:	e0 a0 05 98 	rcall	8000b8b6 <__mcmp>
8000ad8a:	18 96       	mov	r6,r12
8000ad8c:	0e 9c       	mov	r12,r7
8000ad8e:	02 9b       	mov	r11,r1
8000ad90:	e0 a0 05 ac 	rcall	8000b8e8 <_Bfree>
8000ad94:	40 cc       	lddsp	r12,sp[0x30]
8000ad96:	ed ec 10 08 	or	r8,r6,r12
8000ad9a:	c0 d1       	brne	8000adb4 <_dtoa_r+0xa3c>
8000ad9c:	40 db       	lddsp	r11,sp[0x34]
8000ad9e:	58 0b       	cp.w	r11,0
8000ada0:	c0 a1       	brne	8000adb4 <_dtoa_r+0xa3c>
8000ada2:	40 26       	lddsp	r6,sp[0x8]
8000ada4:	e0 40 00 39 	cp.w	r0,57
8000ada8:	c3 00       	breq	8000ae08 <_dtoa_r+0xa90>
8000adaa:	40 6a       	lddsp	r10,sp[0x18]
8000adac:	58 0a       	cp.w	r10,0
8000adae:	e0 89 00 24 	brgt	8000adf6 <_dtoa_r+0xa7e>
8000adb2:	c2 f8       	rjmp	8000ae10 <_dtoa_r+0xa98>
8000adb4:	40 69       	lddsp	r9,sp[0x18]
8000adb6:	58 09       	cp.w	r9,0
8000adb8:	c0 85       	brlt	8000adc8 <_dtoa_r+0xa50>
8000adba:	12 98       	mov	r8,r9
8000adbc:	40 cc       	lddsp	r12,sp[0x30]
8000adbe:	18 48       	or	r8,r12
8000adc0:	c1 d1       	brne	8000adfa <_dtoa_r+0xa82>
8000adc2:	40 db       	lddsp	r11,sp[0x34]
8000adc4:	58 0b       	cp.w	r11,0
8000adc6:	c1 a1       	brne	8000adfa <_dtoa_r+0xa82>
8000adc8:	0c 99       	mov	r9,r6
8000adca:	40 26       	lddsp	r6,sp[0x8]
8000adcc:	58 09       	cp.w	r9,0
8000adce:	e0 8a 00 21 	brle	8000ae10 <_dtoa_r+0xa98>
8000add2:	06 9b       	mov	r11,r3
8000add4:	30 1a       	mov	r10,1
8000add6:	0e 9c       	mov	r12,r7
8000add8:	e0 a0 06 92 	rcall	8000bafc <__lshift>
8000addc:	04 9b       	mov	r11,r2
8000adde:	18 93       	mov	r3,r12
8000ade0:	e0 a0 05 6b 	rcall	8000b8b6 <__mcmp>
8000ade4:	e0 89 00 06 	brgt	8000adf0 <_dtoa_r+0xa78>
8000ade8:	c1 41       	brne	8000ae10 <_dtoa_r+0xa98>
8000adea:	ed b0 00 00 	bld	r0,0x0
8000adee:	c1 11       	brne	8000ae10 <_dtoa_r+0xa98>
8000adf0:	e0 40 00 39 	cp.w	r0,57
8000adf4:	c0 a0       	breq	8000ae08 <_dtoa_r+0xa90>
8000adf6:	2f f0       	sub	r0,-1
8000adf8:	c0 c8       	rjmp	8000ae10 <_dtoa_r+0xa98>
8000adfa:	58 06       	cp.w	r6,0
8000adfc:	e0 8a 00 0c 	brle	8000ae14 <_dtoa_r+0xa9c>
8000ae00:	40 26       	lddsp	r6,sp[0x8]
8000ae02:	e0 40 00 39 	cp.w	r0,57
8000ae06:	c0 41       	brne	8000ae0e <_dtoa_r+0xa96>
8000ae08:	33 98       	mov	r8,57
8000ae0a:	0a c8       	st.b	r5++,r8
8000ae0c:	c6 78       	rjmp	8000aeda <_dtoa_r+0xb62>
8000ae0e:	2f f0       	sub	r0,-1
8000ae10:	0a c0       	st.b	r5++,r0
8000ae12:	c7 58       	rjmp	8000aefc <_dtoa_r+0xb84>
8000ae14:	0a c0       	st.b	r5++,r0
8000ae16:	40 9a       	lddsp	r10,sp[0x24]
8000ae18:	40 e9       	lddsp	r9,sp[0x38]
8000ae1a:	12 3a       	cp.w	r10,r9
8000ae1c:	c4 30       	breq	8000aea2 <_dtoa_r+0xb2a>
8000ae1e:	06 9b       	mov	r11,r3
8000ae20:	30 09       	mov	r9,0
8000ae22:	30 aa       	mov	r10,10
8000ae24:	0e 9c       	mov	r12,r7
8000ae26:	e0 a0 07 37 	rcall	8000bc94 <__multadd>
8000ae2a:	40 48       	lddsp	r8,sp[0x10]
8000ae2c:	18 93       	mov	r3,r12
8000ae2e:	08 38       	cp.w	r8,r4
8000ae30:	c0 91       	brne	8000ae42 <_dtoa_r+0xaca>
8000ae32:	10 9b       	mov	r11,r8
8000ae34:	30 09       	mov	r9,0
8000ae36:	30 aa       	mov	r10,10
8000ae38:	0e 9c       	mov	r12,r7
8000ae3a:	e0 a0 07 2d 	rcall	8000bc94 <__multadd>
8000ae3e:	50 4c       	stdsp	sp[0x10],r12
8000ae40:	c0 e8       	rjmp	8000ae5c <_dtoa_r+0xae4>
8000ae42:	40 4b       	lddsp	r11,sp[0x10]
8000ae44:	30 09       	mov	r9,0
8000ae46:	30 aa       	mov	r10,10
8000ae48:	0e 9c       	mov	r12,r7
8000ae4a:	e0 a0 07 25 	rcall	8000bc94 <__multadd>
8000ae4e:	08 9b       	mov	r11,r4
8000ae50:	50 4c       	stdsp	sp[0x10],r12
8000ae52:	30 09       	mov	r9,0
8000ae54:	30 aa       	mov	r10,10
8000ae56:	0e 9c       	mov	r12,r7
8000ae58:	e0 a0 07 1e 	rcall	8000bc94 <__multadd>
8000ae5c:	18 94       	mov	r4,r12
8000ae5e:	40 9c       	lddsp	r12,sp[0x24]
8000ae60:	2f fc       	sub	r12,-1
8000ae62:	50 9c       	stdsp	sp[0x24],r12
8000ae64:	c7 9b       	rjmp	8000ad56 <_dtoa_r+0x9de>
8000ae66:	30 18       	mov	r8,1
8000ae68:	06 90       	mov	r0,r3
8000ae6a:	40 85       	lddsp	r5,sp[0x20]
8000ae6c:	08 93       	mov	r3,r4
8000ae6e:	0c 94       	mov	r4,r6
8000ae70:	10 96       	mov	r6,r8
8000ae72:	04 9b       	mov	r11,r2
8000ae74:	00 9c       	mov	r12,r0
8000ae76:	fe b0 f9 f1 	rcall	8000a258 <quorem>
8000ae7a:	2d 0c       	sub	r12,-48
8000ae7c:	0a cc       	st.b	r5++,r12
8000ae7e:	02 36       	cp.w	r6,r1
8000ae80:	c0 a4       	brge	8000ae94 <_dtoa_r+0xb1c>
8000ae82:	00 9b       	mov	r11,r0
8000ae84:	30 09       	mov	r9,0
8000ae86:	30 aa       	mov	r10,10
8000ae88:	0e 9c       	mov	r12,r7
8000ae8a:	2f f6       	sub	r6,-1
8000ae8c:	e0 a0 07 04 	rcall	8000bc94 <__multadd>
8000ae90:	18 90       	mov	r0,r12
8000ae92:	cf 0b       	rjmp	8000ae72 <_dtoa_r+0xafa>
8000ae94:	08 96       	mov	r6,r4
8000ae96:	30 0b       	mov	r11,0
8000ae98:	06 94       	mov	r4,r3
8000ae9a:	50 4b       	stdsp	sp[0x10],r11
8000ae9c:	00 93       	mov	r3,r0
8000ae9e:	18 90       	mov	r0,r12
8000aea0:	c0 28       	rjmp	8000aea4 <_dtoa_r+0xb2c>
8000aea2:	40 26       	lddsp	r6,sp[0x8]
8000aea4:	06 9b       	mov	r11,r3
8000aea6:	30 1a       	mov	r10,1
8000aea8:	0e 9c       	mov	r12,r7
8000aeaa:	e0 a0 06 29 	rcall	8000bafc <__lshift>
8000aeae:	04 9b       	mov	r11,r2
8000aeb0:	18 93       	mov	r3,r12
8000aeb2:	e0 a0 05 02 	rcall	8000b8b6 <__mcmp>
8000aeb6:	e0 89 00 12 	brgt	8000aeda <_dtoa_r+0xb62>
8000aeba:	c1 b1       	brne	8000aef0 <_dtoa_r+0xb78>
8000aebc:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aec0:	c0 d1       	brne	8000aeda <_dtoa_r+0xb62>
8000aec2:	c1 78       	rjmp	8000aef0 <_dtoa_r+0xb78>
8000aec4:	40 89       	lddsp	r9,sp[0x20]
8000aec6:	12 38       	cp.w	r8,r9
8000aec8:	c0 30       	breq	8000aece <_dtoa_r+0xb56>
8000aeca:	10 95       	mov	r5,r8
8000aecc:	c0 88       	rjmp	8000aedc <_dtoa_r+0xb64>
8000aece:	2f f6       	sub	r6,-1
8000aed0:	50 66       	stdsp	sp[0x18],r6
8000aed2:	33 18       	mov	r8,49
8000aed4:	40 8c       	lddsp	r12,sp[0x20]
8000aed6:	b8 88       	st.b	r12[0x0],r8
8000aed8:	c1 38       	rjmp	8000aefe <_dtoa_r+0xb86>
8000aeda:	33 9a       	mov	r10,57
8000aedc:	0a 98       	mov	r8,r5
8000aede:	11 79       	ld.ub	r9,--r8
8000aee0:	f4 09 18 00 	cp.b	r9,r10
8000aee4:	cf 00       	breq	8000aec4 <_dtoa_r+0xb4c>
8000aee6:	2f f9       	sub	r9,-1
8000aee8:	b0 89       	st.b	r8[0x0],r9
8000aeea:	c0 98       	rjmp	8000aefc <_dtoa_r+0xb84>
8000aeec:	10 95       	mov	r5,r8
8000aeee:	c0 28       	rjmp	8000aef2 <_dtoa_r+0xb7a>
8000aef0:	33 09       	mov	r9,48
8000aef2:	0a 98       	mov	r8,r5
8000aef4:	11 7a       	ld.ub	r10,--r8
8000aef6:	f2 0a 18 00 	cp.b	r10,r9
8000aefa:	cf 90       	breq	8000aeec <_dtoa_r+0xb74>
8000aefc:	50 66       	stdsp	sp[0x18],r6
8000aefe:	04 9b       	mov	r11,r2
8000af00:	0e 9c       	mov	r12,r7
8000af02:	e0 a0 04 f3 	rcall	8000b8e8 <_Bfree>
8000af06:	58 04       	cp.w	r4,0
8000af08:	c1 20       	breq	8000af2c <_dtoa_r+0xbb4>
8000af0a:	40 4b       	lddsp	r11,sp[0x10]
8000af0c:	08 3b       	cp.w	r11,r4
8000af0e:	5f 19       	srne	r9
8000af10:	58 0b       	cp.w	r11,0
8000af12:	5f 18       	srne	r8
8000af14:	f3 e8 00 08 	and	r8,r9,r8
8000af18:	c0 40       	breq	8000af20 <_dtoa_r+0xba8>
8000af1a:	0e 9c       	mov	r12,r7
8000af1c:	e0 a0 04 e6 	rcall	8000b8e8 <_Bfree>
8000af20:	08 9b       	mov	r11,r4
8000af22:	0e 9c       	mov	r12,r7
8000af24:	e0 a0 04 e2 	rcall	8000b8e8 <_Bfree>
8000af28:	c0 28       	rjmp	8000af2c <_dtoa_r+0xbb4>
8000af2a:	50 66       	stdsp	sp[0x18],r6
8000af2c:	0e 9c       	mov	r12,r7
8000af2e:	06 9b       	mov	r11,r3
8000af30:	e0 a0 04 dc 	rcall	8000b8e8 <_Bfree>
8000af34:	30 08       	mov	r8,0
8000af36:	aa 88       	st.b	r5[0x0],r8
8000af38:	40 68       	lddsp	r8,sp[0x18]
8000af3a:	41 5a       	lddsp	r10,sp[0x54]
8000af3c:	2f f8       	sub	r8,-1
8000af3e:	41 29       	lddsp	r9,sp[0x48]
8000af40:	95 08       	st.w	r10[0x0],r8
8000af42:	40 8c       	lddsp	r12,sp[0x20]
8000af44:	58 09       	cp.w	r9,0
8000af46:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000af4a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000af4e:	2e 6d       	sub	sp,-104
8000af50:	d8 32       	popm	r0-r7,pc
8000af52:	d7 03       	nop

8000af54 <__errno>:
8000af54:	e0 68 0a 48 	mov	r8,2632
8000af58:	70 0c       	ld.w	r12,r8[0x0]
8000af5a:	2f 4c       	sub	r12,-12
8000af5c:	5e fc       	retal	r12
8000af5e:	d7 03       	nop

8000af60 <_fflush_r>:
8000af60:	d4 21       	pushm	r4-r7,lr
8000af62:	16 97       	mov	r7,r11
8000af64:	18 96       	mov	r6,r12
8000af66:	76 48       	ld.w	r8,r11[0x10]
8000af68:	58 08       	cp.w	r8,0
8000af6a:	c7 f0       	breq	8000b068 <_fflush_r+0x108>
8000af6c:	58 0c       	cp.w	r12,0
8000af6e:	c0 50       	breq	8000af78 <_fflush_r+0x18>
8000af70:	78 68       	ld.w	r8,r12[0x18]
8000af72:	58 08       	cp.w	r8,0
8000af74:	c0 21       	brne	8000af78 <_fflush_r+0x18>
8000af76:	cc dc       	rcall	8000b110 <__sinit>
8000af78:	fe c8 cc e8 	sub	r8,pc,-13080
8000af7c:	10 37       	cp.w	r7,r8
8000af7e:	c0 31       	brne	8000af84 <_fflush_r+0x24>
8000af80:	6c 07       	ld.w	r7,r6[0x0]
8000af82:	c0 c8       	rjmp	8000af9a <_fflush_r+0x3a>
8000af84:	fe c8 cc d4 	sub	r8,pc,-13100
8000af88:	10 37       	cp.w	r7,r8
8000af8a:	c0 31       	brne	8000af90 <_fflush_r+0x30>
8000af8c:	6c 17       	ld.w	r7,r6[0x4]
8000af8e:	c0 68       	rjmp	8000af9a <_fflush_r+0x3a>
8000af90:	fe c8 cc c0 	sub	r8,pc,-13120
8000af94:	10 37       	cp.w	r7,r8
8000af96:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000af9a:	8e 6a       	ld.sh	r10,r7[0xc]
8000af9c:	14 98       	mov	r8,r10
8000af9e:	ed ba 00 03 	bld	r10,0x3
8000afa2:	c4 20       	breq	8000b026 <_fflush_r+0xc6>
8000afa4:	ab ba       	sbr	r10,0xb
8000afa6:	ae 6a       	st.h	r7[0xc],r10
8000afa8:	6e 18       	ld.w	r8,r7[0x4]
8000afaa:	58 08       	cp.w	r8,0
8000afac:	e0 89 00 06 	brgt	8000afb8 <_fflush_r+0x58>
8000afb0:	6f 08       	ld.w	r8,r7[0x40]
8000afb2:	58 08       	cp.w	r8,0
8000afb4:	e0 8a 00 5a 	brle	8000b068 <_fflush_r+0x108>
8000afb8:	6e b8       	ld.w	r8,r7[0x2c]
8000afba:	58 08       	cp.w	r8,0
8000afbc:	c5 60       	breq	8000b068 <_fflush_r+0x108>
8000afbe:	e2 1a 10 00 	andl	r10,0x1000,COH
8000afc2:	c0 30       	breq	8000afc8 <_fflush_r+0x68>
8000afc4:	6f 55       	ld.w	r5,r7[0x54]
8000afc6:	c0 f8       	rjmp	8000afe4 <_fflush_r+0x84>
8000afc8:	30 19       	mov	r9,1
8000afca:	6e 8b       	ld.w	r11,r7[0x20]
8000afcc:	0c 9c       	mov	r12,r6
8000afce:	5d 18       	icall	r8
8000afd0:	18 95       	mov	r5,r12
8000afd2:	5b fc       	cp.w	r12,-1
8000afd4:	c0 81       	brne	8000afe4 <_fflush_r+0x84>
8000afd6:	6c 38       	ld.w	r8,r6[0xc]
8000afd8:	59 d8       	cp.w	r8,29
8000afda:	c4 70       	breq	8000b068 <_fflush_r+0x108>
8000afdc:	8e 68       	ld.sh	r8,r7[0xc]
8000afde:	a7 a8       	sbr	r8,0x6
8000afe0:	ae 68       	st.h	r7[0xc],r8
8000afe2:	d8 22       	popm	r4-r7,pc
8000afe4:	8e 68       	ld.sh	r8,r7[0xc]
8000afe6:	ed b8 00 02 	bld	r8,0x2
8000afea:	c0 91       	brne	8000affc <_fflush_r+0x9c>
8000afec:	6e 18       	ld.w	r8,r7[0x4]
8000afee:	10 15       	sub	r5,r8
8000aff0:	6e d8       	ld.w	r8,r7[0x34]
8000aff2:	58 08       	cp.w	r8,0
8000aff4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aff8:	eb d8 e1 15 	subne	r5,r5,r8
8000affc:	6e b8       	ld.w	r8,r7[0x2c]
8000affe:	0c 9c       	mov	r12,r6
8000b000:	30 09       	mov	r9,0
8000b002:	0a 9a       	mov	r10,r5
8000b004:	6e 8b       	ld.w	r11,r7[0x20]
8000b006:	5d 18       	icall	r8
8000b008:	8e 68       	ld.sh	r8,r7[0xc]
8000b00a:	0a 3c       	cp.w	r12,r5
8000b00c:	c2 61       	brne	8000b058 <_fflush_r+0xf8>
8000b00e:	ab d8       	cbr	r8,0xb
8000b010:	30 0c       	mov	r12,0
8000b012:	6e 49       	ld.w	r9,r7[0x10]
8000b014:	ae 68       	st.h	r7[0xc],r8
8000b016:	8f 1c       	st.w	r7[0x4],r12
8000b018:	8f 09       	st.w	r7[0x0],r9
8000b01a:	ed b8 00 0c 	bld	r8,0xc
8000b01e:	c2 51       	brne	8000b068 <_fflush_r+0x108>
8000b020:	ef 45 00 54 	st.w	r7[84],r5
8000b024:	d8 22       	popm	r4-r7,pc
8000b026:	6e 45       	ld.w	r5,r7[0x10]
8000b028:	58 05       	cp.w	r5,0
8000b02a:	c1 f0       	breq	8000b068 <_fflush_r+0x108>
8000b02c:	6e 04       	ld.w	r4,r7[0x0]
8000b02e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b032:	8f 05       	st.w	r7[0x0],r5
8000b034:	f9 b8 01 00 	movne	r8,0
8000b038:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b03c:	0a 14       	sub	r4,r5
8000b03e:	8f 28       	st.w	r7[0x8],r8
8000b040:	c1 18       	rjmp	8000b062 <_fflush_r+0x102>
8000b042:	08 99       	mov	r9,r4
8000b044:	0a 9a       	mov	r10,r5
8000b046:	6e a8       	ld.w	r8,r7[0x28]
8000b048:	6e 8b       	ld.w	r11,r7[0x20]
8000b04a:	0c 9c       	mov	r12,r6
8000b04c:	5d 18       	icall	r8
8000b04e:	18 14       	sub	r4,r12
8000b050:	58 0c       	cp.w	r12,0
8000b052:	e0 89 00 07 	brgt	8000b060 <_fflush_r+0x100>
8000b056:	8e 68       	ld.sh	r8,r7[0xc]
8000b058:	a7 a8       	sbr	r8,0x6
8000b05a:	3f fc       	mov	r12,-1
8000b05c:	ae 68       	st.h	r7[0xc],r8
8000b05e:	d8 22       	popm	r4-r7,pc
8000b060:	18 05       	add	r5,r12
8000b062:	58 04       	cp.w	r4,0
8000b064:	fe 99 ff ef 	brgt	8000b042 <_fflush_r+0xe2>
8000b068:	d8 2a       	popm	r4-r7,pc,r12=0
8000b06a:	d7 03       	nop

8000b06c <__sfp_lock_acquire>:
8000b06c:	5e fc       	retal	r12

8000b06e <__sfp_lock_release>:
8000b06e:	5e fc       	retal	r12

8000b070 <_cleanup_r>:
8000b070:	d4 01       	pushm	lr
8000b072:	fe cb f0 ae 	sub	r11,pc,-3922
8000b076:	e0 a0 02 f7 	rcall	8000b664 <_fwalk>
8000b07a:	d8 02       	popm	pc

8000b07c <__sfmoreglue>:
8000b07c:	d4 21       	pushm	r4-r7,lr
8000b07e:	16 95       	mov	r5,r11
8000b080:	f6 06 10 5c 	mul	r6,r11,92
8000b084:	ec cb ff f4 	sub	r11,r6,-12
8000b088:	fe b0 e2 76 	rcall	80007574 <_malloc_r>
8000b08c:	18 97       	mov	r7,r12
8000b08e:	c0 90       	breq	8000b0a0 <__sfmoreglue+0x24>
8000b090:	99 15       	st.w	r12[0x4],r5
8000b092:	30 0b       	mov	r11,0
8000b094:	2f 4c       	sub	r12,-12
8000b096:	0c 9a       	mov	r10,r6
8000b098:	8f 2c       	st.w	r7[0x8],r12
8000b09a:	8f 0b       	st.w	r7[0x0],r11
8000b09c:	fe b0 e5 3f 	rcall	80007b1a <memset>
8000b0a0:	0e 9c       	mov	r12,r7
8000b0a2:	d8 22       	popm	r4-r7,pc

8000b0a4 <__sfp>:
8000b0a4:	d4 21       	pushm	r4-r7,lr
8000b0a6:	fe c8 cd b2 	sub	r8,pc,-12878
8000b0aa:	18 96       	mov	r6,r12
8000b0ac:	70 07       	ld.w	r7,r8[0x0]
8000b0ae:	6e 68       	ld.w	r8,r7[0x18]
8000b0b0:	58 08       	cp.w	r8,0
8000b0b2:	c0 31       	brne	8000b0b8 <__sfp+0x14>
8000b0b4:	0e 9c       	mov	r12,r7
8000b0b6:	c2 dc       	rcall	8000b110 <__sinit>
8000b0b8:	ee c7 ff 28 	sub	r7,r7,-216
8000b0bc:	30 05       	mov	r5,0
8000b0be:	6e 2c       	ld.w	r12,r7[0x8]
8000b0c0:	6e 18       	ld.w	r8,r7[0x4]
8000b0c2:	c0 68       	rjmp	8000b0ce <__sfp+0x2a>
8000b0c4:	98 69       	ld.sh	r9,r12[0xc]
8000b0c6:	ea 09 19 00 	cp.h	r9,r5
8000b0ca:	c1 10       	breq	8000b0ec <__sfp+0x48>
8000b0cc:	2a 4c       	sub	r12,-92
8000b0ce:	20 18       	sub	r8,1
8000b0d0:	cf a7       	brpl	8000b0c4 <__sfp+0x20>
8000b0d2:	6e 08       	ld.w	r8,r7[0x0]
8000b0d4:	58 08       	cp.w	r8,0
8000b0d6:	c0 61       	brne	8000b0e2 <__sfp+0x3e>
8000b0d8:	30 4b       	mov	r11,4
8000b0da:	0c 9c       	mov	r12,r6
8000b0dc:	cd 0f       	rcall	8000b07c <__sfmoreglue>
8000b0de:	8f 0c       	st.w	r7[0x0],r12
8000b0e0:	c0 30       	breq	8000b0e6 <__sfp+0x42>
8000b0e2:	6e 07       	ld.w	r7,r7[0x0]
8000b0e4:	ce db       	rjmp	8000b0be <__sfp+0x1a>
8000b0e6:	30 c8       	mov	r8,12
8000b0e8:	8d 38       	st.w	r6[0xc],r8
8000b0ea:	d8 22       	popm	r4-r7,pc
8000b0ec:	30 08       	mov	r8,0
8000b0ee:	f9 48 00 4c 	st.w	r12[76],r8
8000b0f2:	99 08       	st.w	r12[0x0],r8
8000b0f4:	99 28       	st.w	r12[0x8],r8
8000b0f6:	99 18       	st.w	r12[0x4],r8
8000b0f8:	99 48       	st.w	r12[0x10],r8
8000b0fa:	99 58       	st.w	r12[0x14],r8
8000b0fc:	99 68       	st.w	r12[0x18],r8
8000b0fe:	99 d8       	st.w	r12[0x34],r8
8000b100:	99 e8       	st.w	r12[0x38],r8
8000b102:	f9 48 00 48 	st.w	r12[72],r8
8000b106:	3f f8       	mov	r8,-1
8000b108:	b8 78       	st.h	r12[0xe],r8
8000b10a:	30 18       	mov	r8,1
8000b10c:	b8 68       	st.h	r12[0xc],r8
8000b10e:	d8 22       	popm	r4-r7,pc

8000b110 <__sinit>:
8000b110:	d4 21       	pushm	r4-r7,lr
8000b112:	18 96       	mov	r6,r12
8000b114:	78 67       	ld.w	r7,r12[0x18]
8000b116:	58 07       	cp.w	r7,0
8000b118:	c4 91       	brne	8000b1aa <__sinit+0x9a>
8000b11a:	fe c8 00 aa 	sub	r8,pc,170
8000b11e:	30 15       	mov	r5,1
8000b120:	99 a8       	st.w	r12[0x28],r8
8000b122:	f9 47 00 d8 	st.w	r12[216],r7
8000b126:	f9 47 00 dc 	st.w	r12[220],r7
8000b12a:	f9 47 00 e0 	st.w	r12[224],r7
8000b12e:	99 65       	st.w	r12[0x18],r5
8000b130:	cb af       	rcall	8000b0a4 <__sfp>
8000b132:	8d 0c       	st.w	r6[0x0],r12
8000b134:	0c 9c       	mov	r12,r6
8000b136:	cb 7f       	rcall	8000b0a4 <__sfp>
8000b138:	8d 1c       	st.w	r6[0x4],r12
8000b13a:	0c 9c       	mov	r12,r6
8000b13c:	cb 4f       	rcall	8000b0a4 <__sfp>
8000b13e:	6c 09       	ld.w	r9,r6[0x0]
8000b140:	30 48       	mov	r8,4
8000b142:	93 07       	st.w	r9[0x0],r7
8000b144:	b2 68       	st.h	r9[0xc],r8
8000b146:	93 17       	st.w	r9[0x4],r7
8000b148:	93 27       	st.w	r9[0x8],r7
8000b14a:	6c 18       	ld.w	r8,r6[0x4]
8000b14c:	b2 77       	st.h	r9[0xe],r7
8000b14e:	93 47       	st.w	r9[0x10],r7
8000b150:	93 57       	st.w	r9[0x14],r7
8000b152:	93 67       	st.w	r9[0x18],r7
8000b154:	93 89       	st.w	r9[0x20],r9
8000b156:	91 07       	st.w	r8[0x0],r7
8000b158:	91 17       	st.w	r8[0x4],r7
8000b15a:	91 27       	st.w	r8[0x8],r7
8000b15c:	fe ce f3 24 	sub	lr,pc,-3292
8000b160:	fe cb f3 54 	sub	r11,pc,-3244
8000b164:	93 9e       	st.w	r9[0x24],lr
8000b166:	93 ab       	st.w	r9[0x28],r11
8000b168:	fe ca f3 7c 	sub	r10,pc,-3204
8000b16c:	fe c4 f3 88 	sub	r4,pc,-3192
8000b170:	93 ba       	st.w	r9[0x2c],r10
8000b172:	93 c4       	st.w	r9[0x30],r4
8000b174:	30 99       	mov	r9,9
8000b176:	b0 69       	st.h	r8[0xc],r9
8000b178:	b0 75       	st.h	r8[0xe],r5
8000b17a:	91 c4       	st.w	r8[0x30],r4
8000b17c:	91 47       	st.w	r8[0x10],r7
8000b17e:	91 57       	st.w	r8[0x14],r7
8000b180:	91 67       	st.w	r8[0x18],r7
8000b182:	91 88       	st.w	r8[0x20],r8
8000b184:	91 9e       	st.w	r8[0x24],lr
8000b186:	91 ab       	st.w	r8[0x28],r11
8000b188:	91 ba       	st.w	r8[0x2c],r10
8000b18a:	8d 2c       	st.w	r6[0x8],r12
8000b18c:	31 28       	mov	r8,18
8000b18e:	99 07       	st.w	r12[0x0],r7
8000b190:	b8 68       	st.h	r12[0xc],r8
8000b192:	99 17       	st.w	r12[0x4],r7
8000b194:	99 27       	st.w	r12[0x8],r7
8000b196:	30 28       	mov	r8,2
8000b198:	b8 78       	st.h	r12[0xe],r8
8000b19a:	99 c4       	st.w	r12[0x30],r4
8000b19c:	99 67       	st.w	r12[0x18],r7
8000b19e:	99 9e       	st.w	r12[0x24],lr
8000b1a0:	99 ab       	st.w	r12[0x28],r11
8000b1a2:	99 ba       	st.w	r12[0x2c],r10
8000b1a4:	99 47       	st.w	r12[0x10],r7
8000b1a6:	99 57       	st.w	r12[0x14],r7
8000b1a8:	99 8c       	st.w	r12[0x20],r12
8000b1aa:	d8 22       	popm	r4-r7,pc

8000b1ac <_malloc_trim_r>:
8000b1ac:	d4 21       	pushm	r4-r7,lr
8000b1ae:	16 95       	mov	r5,r11
8000b1b0:	18 97       	mov	r7,r12
8000b1b2:	fe b0 d7 c5 	rcall	8000613c <__malloc_lock>
8000b1b6:	e0 64 05 48 	mov	r4,1352
8000b1ba:	68 28       	ld.w	r8,r4[0x8]
8000b1bc:	70 16       	ld.w	r6,r8[0x4]
8000b1be:	e0 16 ff fc 	andl	r6,0xfffc
8000b1c2:	ec c8 ff 91 	sub	r8,r6,-111
8000b1c6:	f0 05 01 05 	sub	r5,r8,r5
8000b1ca:	e0 15 ff 80 	andl	r5,0xff80
8000b1ce:	ea c5 00 80 	sub	r5,r5,128
8000b1d2:	e0 45 00 7f 	cp.w	r5,127
8000b1d6:	e0 8a 00 25 	brle	8000b220 <_malloc_trim_r+0x74>
8000b1da:	30 0b       	mov	r11,0
8000b1dc:	0e 9c       	mov	r12,r7
8000b1de:	fe b0 e6 05 	rcall	80007de8 <_sbrk_r>
8000b1e2:	68 28       	ld.w	r8,r4[0x8]
8000b1e4:	0c 08       	add	r8,r6
8000b1e6:	10 3c       	cp.w	r12,r8
8000b1e8:	c1 c1       	brne	8000b220 <_malloc_trim_r+0x74>
8000b1ea:	ea 0b 11 00 	rsub	r11,r5,0
8000b1ee:	0e 9c       	mov	r12,r7
8000b1f0:	fe b0 e5 fc 	rcall	80007de8 <_sbrk_r>
8000b1f4:	5b fc       	cp.w	r12,-1
8000b1f6:	c1 91       	brne	8000b228 <_malloc_trim_r+0x7c>
8000b1f8:	30 0b       	mov	r11,0
8000b1fa:	0e 9c       	mov	r12,r7
8000b1fc:	fe b0 e5 f6 	rcall	80007de8 <_sbrk_r>
8000b200:	68 28       	ld.w	r8,r4[0x8]
8000b202:	f8 08 01 09 	sub	r9,r12,r8
8000b206:	58 f9       	cp.w	r9,15
8000b208:	e0 8a 00 0c 	brle	8000b220 <_malloc_trim_r+0x74>
8000b20c:	a1 a9       	sbr	r9,0x0
8000b20e:	91 19       	st.w	r8[0x4],r9
8000b210:	e0 68 09 54 	mov	r8,2388
8000b214:	70 09       	ld.w	r9,r8[0x0]
8000b216:	e0 68 0d c0 	mov	r8,3520
8000b21a:	f8 09 01 09 	sub	r9,r12,r9
8000b21e:	91 09       	st.w	r8[0x0],r9
8000b220:	0e 9c       	mov	r12,r7
8000b222:	fe b0 d7 93 	rcall	80006148 <__malloc_unlock>
8000b226:	d8 2a       	popm	r4-r7,pc,r12=0
8000b228:	68 28       	ld.w	r8,r4[0x8]
8000b22a:	0a 16       	sub	r6,r5
8000b22c:	a1 a6       	sbr	r6,0x0
8000b22e:	91 16       	st.w	r8[0x4],r6
8000b230:	e0 68 0d c0 	mov	r8,3520
8000b234:	70 09       	ld.w	r9,r8[0x0]
8000b236:	0a 19       	sub	r9,r5
8000b238:	0e 9c       	mov	r12,r7
8000b23a:	91 09       	st.w	r8[0x0],r9
8000b23c:	fe b0 d7 86 	rcall	80006148 <__malloc_unlock>
8000b240:	da 2a       	popm	r4-r7,pc,r12=1
8000b242:	d7 03       	nop

8000b244 <_free_r>:
8000b244:	d4 21       	pushm	r4-r7,lr
8000b246:	16 96       	mov	r6,r11
8000b248:	18 97       	mov	r7,r12
8000b24a:	58 0b       	cp.w	r11,0
8000b24c:	e0 80 00 c0 	breq	8000b3cc <_free_r+0x188>
8000b250:	fe b0 d7 76 	rcall	8000613c <__malloc_lock>
8000b254:	20 86       	sub	r6,8
8000b256:	e0 6a 05 48 	mov	r10,1352
8000b25a:	6c 18       	ld.w	r8,r6[0x4]
8000b25c:	74 2e       	ld.w	lr,r10[0x8]
8000b25e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b262:	a1 c8       	cbr	r8,0x0
8000b264:	ec 08 00 09 	add	r9,r6,r8
8000b268:	72 1b       	ld.w	r11,r9[0x4]
8000b26a:	e0 1b ff fc 	andl	r11,0xfffc
8000b26e:	1c 39       	cp.w	r9,lr
8000b270:	c1 e1       	brne	8000b2ac <_free_r+0x68>
8000b272:	f6 08 00 08 	add	r8,r11,r8
8000b276:	58 0c       	cp.w	r12,0
8000b278:	c0 81       	brne	8000b288 <_free_r+0x44>
8000b27a:	6c 09       	ld.w	r9,r6[0x0]
8000b27c:	12 16       	sub	r6,r9
8000b27e:	12 08       	add	r8,r9
8000b280:	6c 3b       	ld.w	r11,r6[0xc]
8000b282:	6c 29       	ld.w	r9,r6[0x8]
8000b284:	97 29       	st.w	r11[0x8],r9
8000b286:	93 3b       	st.w	r9[0xc],r11
8000b288:	10 99       	mov	r9,r8
8000b28a:	95 26       	st.w	r10[0x8],r6
8000b28c:	a1 a9       	sbr	r9,0x0
8000b28e:	8d 19       	st.w	r6[0x4],r9
8000b290:	e0 69 09 50 	mov	r9,2384
8000b294:	72 09       	ld.w	r9,r9[0x0]
8000b296:	12 38       	cp.w	r8,r9
8000b298:	c0 63       	brcs	8000b2a4 <_free_r+0x60>
8000b29a:	e0 68 0d bc 	mov	r8,3516
8000b29e:	0e 9c       	mov	r12,r7
8000b2a0:	70 0b       	ld.w	r11,r8[0x0]
8000b2a2:	c8 5f       	rcall	8000b1ac <_malloc_trim_r>
8000b2a4:	0e 9c       	mov	r12,r7
8000b2a6:	fe b0 d7 51 	rcall	80006148 <__malloc_unlock>
8000b2aa:	d8 22       	popm	r4-r7,pc
8000b2ac:	93 1b       	st.w	r9[0x4],r11
8000b2ae:	58 0c       	cp.w	r12,0
8000b2b0:	c0 30       	breq	8000b2b6 <_free_r+0x72>
8000b2b2:	30 0c       	mov	r12,0
8000b2b4:	c1 08       	rjmp	8000b2d4 <_free_r+0x90>
8000b2b6:	6c 0e       	ld.w	lr,r6[0x0]
8000b2b8:	f4 c5 ff f8 	sub	r5,r10,-8
8000b2bc:	1c 16       	sub	r6,lr
8000b2be:	1c 08       	add	r8,lr
8000b2c0:	6c 2e       	ld.w	lr,r6[0x8]
8000b2c2:	0a 3e       	cp.w	lr,r5
8000b2c4:	f9 bc 00 01 	moveq	r12,1
8000b2c8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b2cc:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b2d0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b2d4:	f2 0b 00 0e 	add	lr,r9,r11
8000b2d8:	7c 1e       	ld.w	lr,lr[0x4]
8000b2da:	ed be 00 00 	bld	lr,0x0
8000b2de:	c1 40       	breq	8000b306 <_free_r+0xc2>
8000b2e0:	16 08       	add	r8,r11
8000b2e2:	58 0c       	cp.w	r12,0
8000b2e4:	c0 d1       	brne	8000b2fe <_free_r+0xba>
8000b2e6:	e0 6e 05 48 	mov	lr,1352
8000b2ea:	72 2b       	ld.w	r11,r9[0x8]
8000b2ec:	2f 8e       	sub	lr,-8
8000b2ee:	1c 3b       	cp.w	r11,lr
8000b2f0:	c0 71       	brne	8000b2fe <_free_r+0xba>
8000b2f2:	97 36       	st.w	r11[0xc],r6
8000b2f4:	97 26       	st.w	r11[0x8],r6
8000b2f6:	8d 2b       	st.w	r6[0x8],r11
8000b2f8:	8d 3b       	st.w	r6[0xc],r11
8000b2fa:	30 1c       	mov	r12,1
8000b2fc:	c0 58       	rjmp	8000b306 <_free_r+0xc2>
8000b2fe:	72 2b       	ld.w	r11,r9[0x8]
8000b300:	72 39       	ld.w	r9,r9[0xc]
8000b302:	93 2b       	st.w	r9[0x8],r11
8000b304:	97 39       	st.w	r11[0xc],r9
8000b306:	10 99       	mov	r9,r8
8000b308:	ec 08 09 08 	st.w	r6[r8],r8
8000b30c:	a1 a9       	sbr	r9,0x0
8000b30e:	8d 19       	st.w	r6[0x4],r9
8000b310:	58 0c       	cp.w	r12,0
8000b312:	c5 a1       	brne	8000b3c6 <_free_r+0x182>
8000b314:	e0 48 01 ff 	cp.w	r8,511
8000b318:	e0 8b 00 13 	brhi	8000b33e <_free_r+0xfa>
8000b31c:	a3 98       	lsr	r8,0x3
8000b31e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b322:	72 2b       	ld.w	r11,r9[0x8]
8000b324:	8d 39       	st.w	r6[0xc],r9
8000b326:	8d 2b       	st.w	r6[0x8],r11
8000b328:	97 36       	st.w	r11[0xc],r6
8000b32a:	93 26       	st.w	r9[0x8],r6
8000b32c:	a3 48       	asr	r8,0x2
8000b32e:	74 19       	ld.w	r9,r10[0x4]
8000b330:	30 1b       	mov	r11,1
8000b332:	f6 08 09 48 	lsl	r8,r11,r8
8000b336:	f3 e8 10 08 	or	r8,r9,r8
8000b33a:	95 18       	st.w	r10[0x4],r8
8000b33c:	c4 58       	rjmp	8000b3c6 <_free_r+0x182>
8000b33e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b342:	58 4b       	cp.w	r11,4
8000b344:	e0 8b 00 06 	brhi	8000b350 <_free_r+0x10c>
8000b348:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b34c:	2c 8b       	sub	r11,-56
8000b34e:	c2 08       	rjmp	8000b38e <_free_r+0x14a>
8000b350:	59 4b       	cp.w	r11,20
8000b352:	e0 8b 00 04 	brhi	8000b35a <_free_r+0x116>
8000b356:	2a 5b       	sub	r11,-91
8000b358:	c1 b8       	rjmp	8000b38e <_free_r+0x14a>
8000b35a:	e0 4b 00 54 	cp.w	r11,84
8000b35e:	e0 8b 00 06 	brhi	8000b36a <_free_r+0x126>
8000b362:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b366:	29 2b       	sub	r11,-110
8000b368:	c1 38       	rjmp	8000b38e <_free_r+0x14a>
8000b36a:	e0 4b 01 54 	cp.w	r11,340
8000b36e:	e0 8b 00 06 	brhi	8000b37a <_free_r+0x136>
8000b372:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b376:	28 9b       	sub	r11,-119
8000b378:	c0 b8       	rjmp	8000b38e <_free_r+0x14a>
8000b37a:	e0 4b 05 54 	cp.w	r11,1364
8000b37e:	e0 88 00 05 	brls	8000b388 <_free_r+0x144>
8000b382:	37 eb       	mov	r11,126
8000b384:	c0 58       	rjmp	8000b38e <_free_r+0x14a>
8000b386:	d7 03       	nop
8000b388:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b38c:	28 4b       	sub	r11,-124
8000b38e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b392:	78 29       	ld.w	r9,r12[0x8]
8000b394:	18 39       	cp.w	r9,r12
8000b396:	c0 e1       	brne	8000b3b2 <_free_r+0x16e>
8000b398:	74 18       	ld.w	r8,r10[0x4]
8000b39a:	a3 4b       	asr	r11,0x2
8000b39c:	30 1c       	mov	r12,1
8000b39e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b3a2:	f1 eb 10 0b 	or	r11,r8,r11
8000b3a6:	12 98       	mov	r8,r9
8000b3a8:	95 1b       	st.w	r10[0x4],r11
8000b3aa:	c0 a8       	rjmp	8000b3be <_free_r+0x17a>
8000b3ac:	72 29       	ld.w	r9,r9[0x8]
8000b3ae:	18 39       	cp.w	r9,r12
8000b3b0:	c0 60       	breq	8000b3bc <_free_r+0x178>
8000b3b2:	72 1a       	ld.w	r10,r9[0x4]
8000b3b4:	e0 1a ff fc 	andl	r10,0xfffc
8000b3b8:	14 38       	cp.w	r8,r10
8000b3ba:	cf 93       	brcs	8000b3ac <_free_r+0x168>
8000b3bc:	72 38       	ld.w	r8,r9[0xc]
8000b3be:	8d 38       	st.w	r6[0xc],r8
8000b3c0:	8d 29       	st.w	r6[0x8],r9
8000b3c2:	93 36       	st.w	r9[0xc],r6
8000b3c4:	91 26       	st.w	r8[0x8],r6
8000b3c6:	0e 9c       	mov	r12,r7
8000b3c8:	fe b0 d6 c0 	rcall	80006148 <__malloc_unlock>
8000b3cc:	d8 22       	popm	r4-r7,pc
8000b3ce:	d7 03       	nop

8000b3d0 <__sfvwrite_r>:
8000b3d0:	d4 31       	pushm	r0-r7,lr
8000b3d2:	20 3d       	sub	sp,12
8000b3d4:	14 94       	mov	r4,r10
8000b3d6:	18 95       	mov	r5,r12
8000b3d8:	16 97       	mov	r7,r11
8000b3da:	74 28       	ld.w	r8,r10[0x8]
8000b3dc:	58 08       	cp.w	r8,0
8000b3de:	e0 80 01 40 	breq	8000b65e <__sfvwrite_r+0x28e>
8000b3e2:	96 68       	ld.sh	r8,r11[0xc]
8000b3e4:	ed b8 00 03 	bld	r8,0x3
8000b3e8:	c0 41       	brne	8000b3f0 <__sfvwrite_r+0x20>
8000b3ea:	76 48       	ld.w	r8,r11[0x10]
8000b3ec:	58 08       	cp.w	r8,0
8000b3ee:	c0 c1       	brne	8000b406 <__sfvwrite_r+0x36>
8000b3f0:	0e 9b       	mov	r11,r7
8000b3f2:	0a 9c       	mov	r12,r5
8000b3f4:	fe b0 f6 c4 	rcall	8000a17c <__swsetup_r>
8000b3f8:	c0 70       	breq	8000b406 <__sfvwrite_r+0x36>
8000b3fa:	8e 68       	ld.sh	r8,r7[0xc]
8000b3fc:	a7 a8       	sbr	r8,0x6
8000b3fe:	ae 68       	st.h	r7[0xc],r8
8000b400:	30 98       	mov	r8,9
8000b402:	8b 38       	st.w	r5[0xc],r8
8000b404:	c2 b9       	rjmp	8000b65a <__sfvwrite_r+0x28a>
8000b406:	8e 63       	ld.sh	r3,r7[0xc]
8000b408:	68 00       	ld.w	r0,r4[0x0]
8000b40a:	06 96       	mov	r6,r3
8000b40c:	e2 16 00 02 	andl	r6,0x2,COH
8000b410:	c2 10       	breq	8000b452 <__sfvwrite_r+0x82>
8000b412:	30 03       	mov	r3,0
8000b414:	e0 62 04 00 	mov	r2,1024
8000b418:	06 96       	mov	r6,r3
8000b41a:	c0 48       	rjmp	8000b422 <__sfvwrite_r+0x52>
8000b41c:	60 03       	ld.w	r3,r0[0x0]
8000b41e:	60 16       	ld.w	r6,r0[0x4]
8000b420:	2f 80       	sub	r0,-8
8000b422:	58 06       	cp.w	r6,0
8000b424:	cf c0       	breq	8000b41c <__sfvwrite_r+0x4c>
8000b426:	e0 46 04 00 	cp.w	r6,1024
8000b42a:	ec 09 17 80 	movls	r9,r6
8000b42e:	e4 09 17 b0 	movhi	r9,r2
8000b432:	06 9a       	mov	r10,r3
8000b434:	6e a8       	ld.w	r8,r7[0x28]
8000b436:	6e 8b       	ld.w	r11,r7[0x20]
8000b438:	0a 9c       	mov	r12,r5
8000b43a:	5d 18       	icall	r8
8000b43c:	18 16       	sub	r6,r12
8000b43e:	58 0c       	cp.w	r12,0
8000b440:	e0 8a 01 0a 	brle	8000b654 <__sfvwrite_r+0x284>
8000b444:	68 28       	ld.w	r8,r4[0x8]
8000b446:	18 18       	sub	r8,r12
8000b448:	89 28       	st.w	r4[0x8],r8
8000b44a:	e0 80 01 0a 	breq	8000b65e <__sfvwrite_r+0x28e>
8000b44e:	18 03       	add	r3,r12
8000b450:	ce 9b       	rjmp	8000b422 <__sfvwrite_r+0x52>
8000b452:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b456:	c0 70       	breq	8000b464 <__sfvwrite_r+0x94>
8000b458:	50 06       	stdsp	sp[0x0],r6
8000b45a:	0c 93       	mov	r3,r6
8000b45c:	0c 91       	mov	r1,r6
8000b45e:	50 15       	stdsp	sp[0x4],r5
8000b460:	08 92       	mov	r2,r4
8000b462:	c9 c8       	rjmp	8000b59a <__sfvwrite_r+0x1ca>
8000b464:	06 96       	mov	r6,r3
8000b466:	08 91       	mov	r1,r4
8000b468:	c0 48       	rjmp	8000b470 <__sfvwrite_r+0xa0>
8000b46a:	60 03       	ld.w	r3,r0[0x0]
8000b46c:	60 16       	ld.w	r6,r0[0x4]
8000b46e:	2f 80       	sub	r0,-8
8000b470:	58 06       	cp.w	r6,0
8000b472:	cf c0       	breq	8000b46a <__sfvwrite_r+0x9a>
8000b474:	8e 68       	ld.sh	r8,r7[0xc]
8000b476:	6e 24       	ld.w	r4,r7[0x8]
8000b478:	10 99       	mov	r9,r8
8000b47a:	e2 19 02 00 	andl	r9,0x200,COH
8000b47e:	c5 50       	breq	8000b528 <__sfvwrite_r+0x158>
8000b480:	08 36       	cp.w	r6,r4
8000b482:	c4 43       	brcs	8000b50a <__sfvwrite_r+0x13a>
8000b484:	10 99       	mov	r9,r8
8000b486:	e2 19 04 80 	andl	r9,0x480,COH
8000b48a:	c4 00       	breq	8000b50a <__sfvwrite_r+0x13a>
8000b48c:	6e 4b       	ld.w	r11,r7[0x10]
8000b48e:	6e 09       	ld.w	r9,r7[0x0]
8000b490:	16 19       	sub	r9,r11
8000b492:	50 09       	stdsp	sp[0x0],r9
8000b494:	6e 59       	ld.w	r9,r7[0x14]
8000b496:	10 9c       	mov	r12,r8
8000b498:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b49c:	30 28       	mov	r8,2
8000b49e:	f4 08 0c 08 	divs	r8,r10,r8
8000b4a2:	fa e9 00 04 	st.d	sp[4],r8
8000b4a6:	10 94       	mov	r4,r8
8000b4a8:	40 09       	lddsp	r9,sp[0x0]
8000b4aa:	e2 1c 04 00 	andl	r12,0x400,COH
8000b4ae:	2f f9       	sub	r9,-1
8000b4b0:	0c 09       	add	r9,r6
8000b4b2:	12 38       	cp.w	r8,r9
8000b4b4:	f2 04 17 30 	movlo	r4,r9
8000b4b8:	58 0c       	cp.w	r12,0
8000b4ba:	c1 10       	breq	8000b4dc <__sfvwrite_r+0x10c>
8000b4bc:	08 9b       	mov	r11,r4
8000b4be:	0a 9c       	mov	r12,r5
8000b4c0:	fe b0 e0 5a 	rcall	80007574 <_malloc_r>
8000b4c4:	18 92       	mov	r2,r12
8000b4c6:	c1 40       	breq	8000b4ee <__sfvwrite_r+0x11e>
8000b4c8:	40 0a       	lddsp	r10,sp[0x0]
8000b4ca:	6e 4b       	ld.w	r11,r7[0x10]
8000b4cc:	fe b0 e2 83 	rcall	800079d2 <memcpy>
8000b4d0:	8e 68       	ld.sh	r8,r7[0xc]
8000b4d2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b4d6:	a7 b8       	sbr	r8,0x7
8000b4d8:	ae 68       	st.h	r7[0xc],r8
8000b4da:	c0 d8       	rjmp	8000b4f4 <__sfvwrite_r+0x124>
8000b4dc:	08 9a       	mov	r10,r4
8000b4de:	0a 9c       	mov	r12,r5
8000b4e0:	fe b0 e3 24 	rcall	80007b28 <_realloc_r>
8000b4e4:	18 92       	mov	r2,r12
8000b4e6:	c0 71       	brne	8000b4f4 <__sfvwrite_r+0x124>
8000b4e8:	6e 4b       	ld.w	r11,r7[0x10]
8000b4ea:	0a 9c       	mov	r12,r5
8000b4ec:	ca ce       	rcall	8000b244 <_free_r>
8000b4ee:	30 c8       	mov	r8,12
8000b4f0:	8b 38       	st.w	r5[0xc],r8
8000b4f2:	cb 18       	rjmp	8000b654 <__sfvwrite_r+0x284>
8000b4f4:	40 0a       	lddsp	r10,sp[0x0]
8000b4f6:	40 09       	lddsp	r9,sp[0x0]
8000b4f8:	e8 0a 01 0a 	sub	r10,r4,r10
8000b4fc:	e4 09 00 08 	add	r8,r2,r9
8000b500:	8f 54       	st.w	r7[0x14],r4
8000b502:	8f 2a       	st.w	r7[0x8],r10
8000b504:	8f 08       	st.w	r7[0x0],r8
8000b506:	8f 42       	st.w	r7[0x10],r2
8000b508:	0c 94       	mov	r4,r6
8000b50a:	08 36       	cp.w	r6,r4
8000b50c:	ec 04 17 30 	movlo	r4,r6
8000b510:	06 9b       	mov	r11,r3
8000b512:	08 9a       	mov	r10,r4
8000b514:	6e 0c       	ld.w	r12,r7[0x0]
8000b516:	c3 ad       	rcall	8000b78a <memmove>
8000b518:	6e 08       	ld.w	r8,r7[0x0]
8000b51a:	08 08       	add	r8,r4
8000b51c:	8f 08       	st.w	r7[0x0],r8
8000b51e:	6e 28       	ld.w	r8,r7[0x8]
8000b520:	08 18       	sub	r8,r4
8000b522:	0c 94       	mov	r4,r6
8000b524:	8f 28       	st.w	r7[0x8],r8
8000b526:	c2 e8       	rjmp	8000b582 <__sfvwrite_r+0x1b2>
8000b528:	08 36       	cp.w	r6,r4
8000b52a:	5f ba       	srhi	r10
8000b52c:	6e 0c       	ld.w	r12,r7[0x0]
8000b52e:	6e 48       	ld.w	r8,r7[0x10]
8000b530:	10 3c       	cp.w	r12,r8
8000b532:	5f b8       	srhi	r8
8000b534:	f5 e8 00 08 	and	r8,r10,r8
8000b538:	f2 08 18 00 	cp.b	r8,r9
8000b53c:	c0 d0       	breq	8000b556 <__sfvwrite_r+0x186>
8000b53e:	06 9b       	mov	r11,r3
8000b540:	08 9a       	mov	r10,r4
8000b542:	c2 4d       	rcall	8000b78a <memmove>
8000b544:	6e 08       	ld.w	r8,r7[0x0]
8000b546:	08 08       	add	r8,r4
8000b548:	0e 9b       	mov	r11,r7
8000b54a:	8f 08       	st.w	r7[0x0],r8
8000b54c:	0a 9c       	mov	r12,r5
8000b54e:	fe b0 fd 09 	rcall	8000af60 <_fflush_r>
8000b552:	c1 80       	breq	8000b582 <__sfvwrite_r+0x1b2>
8000b554:	c8 08       	rjmp	8000b654 <__sfvwrite_r+0x284>
8000b556:	6e 59       	ld.w	r9,r7[0x14]
8000b558:	12 36       	cp.w	r6,r9
8000b55a:	c0 a3       	brcs	8000b56e <__sfvwrite_r+0x19e>
8000b55c:	6e a8       	ld.w	r8,r7[0x28]
8000b55e:	06 9a       	mov	r10,r3
8000b560:	6e 8b       	ld.w	r11,r7[0x20]
8000b562:	0a 9c       	mov	r12,r5
8000b564:	5d 18       	icall	r8
8000b566:	18 94       	mov	r4,r12
8000b568:	e0 89 00 0d 	brgt	8000b582 <__sfvwrite_r+0x1b2>
8000b56c:	c7 48       	rjmp	8000b654 <__sfvwrite_r+0x284>
8000b56e:	0c 9a       	mov	r10,r6
8000b570:	06 9b       	mov	r11,r3
8000b572:	c0 cd       	rcall	8000b78a <memmove>
8000b574:	6e 08       	ld.w	r8,r7[0x0]
8000b576:	0c 08       	add	r8,r6
8000b578:	0c 94       	mov	r4,r6
8000b57a:	8f 08       	st.w	r7[0x0],r8
8000b57c:	6e 28       	ld.w	r8,r7[0x8]
8000b57e:	0c 18       	sub	r8,r6
8000b580:	8f 28       	st.w	r7[0x8],r8
8000b582:	62 28       	ld.w	r8,r1[0x8]
8000b584:	08 18       	sub	r8,r4
8000b586:	83 28       	st.w	r1[0x8],r8
8000b588:	c6 b0       	breq	8000b65e <__sfvwrite_r+0x28e>
8000b58a:	08 16       	sub	r6,r4
8000b58c:	08 03       	add	r3,r4
8000b58e:	c7 1b       	rjmp	8000b470 <__sfvwrite_r+0xa0>
8000b590:	60 03       	ld.w	r3,r0[0x0]
8000b592:	60 11       	ld.w	r1,r0[0x4]
8000b594:	30 08       	mov	r8,0
8000b596:	2f 80       	sub	r0,-8
8000b598:	50 08       	stdsp	sp[0x0],r8
8000b59a:	58 01       	cp.w	r1,0
8000b59c:	cf a0       	breq	8000b590 <__sfvwrite_r+0x1c0>
8000b59e:	40 0a       	lddsp	r10,sp[0x0]
8000b5a0:	58 0a       	cp.w	r10,0
8000b5a2:	c1 41       	brne	8000b5ca <__sfvwrite_r+0x1fa>
8000b5a4:	e2 c6 ff ff 	sub	r6,r1,-1
8000b5a8:	02 9a       	mov	r10,r1
8000b5aa:	30 ab       	mov	r11,10
8000b5ac:	06 9c       	mov	r12,r3
8000b5ae:	ce 3c       	rcall	8000b774 <memchr>
8000b5b0:	f8 c8 ff ff 	sub	r8,r12,-1
8000b5b4:	58 0c       	cp.w	r12,0
8000b5b6:	f1 d3 e1 16 	subne	r6,r8,r3
8000b5ba:	f9 b9 01 01 	movne	r9,1
8000b5be:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b5c2:	f9 b8 00 01 	moveq	r8,1
8000b5c6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b5ca:	02 36       	cp.w	r6,r1
8000b5cc:	ec 04 17 80 	movls	r4,r6
8000b5d0:	e2 04 17 b0 	movhi	r4,r1
8000b5d4:	6e 59       	ld.w	r9,r7[0x14]
8000b5d6:	6e 25       	ld.w	r5,r7[0x8]
8000b5d8:	f2 05 00 05 	add	r5,r9,r5
8000b5dc:	0a 34       	cp.w	r4,r5
8000b5de:	5f 9a       	srgt	r10
8000b5e0:	6e 0c       	ld.w	r12,r7[0x0]
8000b5e2:	6e 48       	ld.w	r8,r7[0x10]
8000b5e4:	10 3c       	cp.w	r12,r8
8000b5e6:	5f b8       	srhi	r8
8000b5e8:	f5 e8 00 08 	and	r8,r10,r8
8000b5ec:	30 0a       	mov	r10,0
8000b5ee:	f4 08 18 00 	cp.b	r8,r10
8000b5f2:	c0 d0       	breq	8000b60c <__sfvwrite_r+0x23c>
8000b5f4:	06 9b       	mov	r11,r3
8000b5f6:	0a 9a       	mov	r10,r5
8000b5f8:	cc 9c       	rcall	8000b78a <memmove>
8000b5fa:	6e 08       	ld.w	r8,r7[0x0]
8000b5fc:	0a 08       	add	r8,r5
8000b5fe:	0e 9b       	mov	r11,r7
8000b600:	8f 08       	st.w	r7[0x0],r8
8000b602:	40 1c       	lddsp	r12,sp[0x4]
8000b604:	fe b0 fc ae 	rcall	8000af60 <_fflush_r>
8000b608:	c1 70       	breq	8000b636 <__sfvwrite_r+0x266>
8000b60a:	c2 58       	rjmp	8000b654 <__sfvwrite_r+0x284>
8000b60c:	12 34       	cp.w	r4,r9
8000b60e:	c0 a5       	brlt	8000b622 <__sfvwrite_r+0x252>
8000b610:	6e a8       	ld.w	r8,r7[0x28]
8000b612:	06 9a       	mov	r10,r3
8000b614:	6e 8b       	ld.w	r11,r7[0x20]
8000b616:	40 1c       	lddsp	r12,sp[0x4]
8000b618:	5d 18       	icall	r8
8000b61a:	18 95       	mov	r5,r12
8000b61c:	e0 89 00 0d 	brgt	8000b636 <__sfvwrite_r+0x266>
8000b620:	c1 a8       	rjmp	8000b654 <__sfvwrite_r+0x284>
8000b622:	08 9a       	mov	r10,r4
8000b624:	06 9b       	mov	r11,r3
8000b626:	cb 2c       	rcall	8000b78a <memmove>
8000b628:	6e 08       	ld.w	r8,r7[0x0]
8000b62a:	08 08       	add	r8,r4
8000b62c:	08 95       	mov	r5,r4
8000b62e:	8f 08       	st.w	r7[0x0],r8
8000b630:	6e 28       	ld.w	r8,r7[0x8]
8000b632:	08 18       	sub	r8,r4
8000b634:	8f 28       	st.w	r7[0x8],r8
8000b636:	0a 16       	sub	r6,r5
8000b638:	c0 71       	brne	8000b646 <__sfvwrite_r+0x276>
8000b63a:	0e 9b       	mov	r11,r7
8000b63c:	40 1c       	lddsp	r12,sp[0x4]
8000b63e:	fe b0 fc 91 	rcall	8000af60 <_fflush_r>
8000b642:	c0 91       	brne	8000b654 <__sfvwrite_r+0x284>
8000b644:	50 06       	stdsp	sp[0x0],r6
8000b646:	64 28       	ld.w	r8,r2[0x8]
8000b648:	0a 18       	sub	r8,r5
8000b64a:	85 28       	st.w	r2[0x8],r8
8000b64c:	c0 90       	breq	8000b65e <__sfvwrite_r+0x28e>
8000b64e:	0a 11       	sub	r1,r5
8000b650:	0a 03       	add	r3,r5
8000b652:	ca 4b       	rjmp	8000b59a <__sfvwrite_r+0x1ca>
8000b654:	8e 68       	ld.sh	r8,r7[0xc]
8000b656:	a7 a8       	sbr	r8,0x6
8000b658:	ae 68       	st.h	r7[0xc],r8
8000b65a:	3f fc       	mov	r12,-1
8000b65c:	c0 28       	rjmp	8000b660 <__sfvwrite_r+0x290>
8000b65e:	30 0c       	mov	r12,0
8000b660:	2f dd       	sub	sp,-12
8000b662:	d8 32       	popm	r0-r7,pc

8000b664 <_fwalk>:
8000b664:	d4 31       	pushm	r0-r7,lr
8000b666:	30 05       	mov	r5,0
8000b668:	16 91       	mov	r1,r11
8000b66a:	f8 c7 ff 28 	sub	r7,r12,-216
8000b66e:	0a 92       	mov	r2,r5
8000b670:	fe b0 fc fe 	rcall	8000b06c <__sfp_lock_acquire>
8000b674:	3f f3       	mov	r3,-1
8000b676:	c1 68       	rjmp	8000b6a2 <_fwalk+0x3e>
8000b678:	6e 26       	ld.w	r6,r7[0x8]
8000b67a:	6e 14       	ld.w	r4,r7[0x4]
8000b67c:	2f 46       	sub	r6,-12
8000b67e:	c0 c8       	rjmp	8000b696 <_fwalk+0x32>
8000b680:	8c 08       	ld.sh	r8,r6[0x0]
8000b682:	e4 08 19 00 	cp.h	r8,r2
8000b686:	c0 70       	breq	8000b694 <_fwalk+0x30>
8000b688:	8c 18       	ld.sh	r8,r6[0x2]
8000b68a:	e6 08 19 00 	cp.h	r8,r3
8000b68e:	c0 30       	breq	8000b694 <_fwalk+0x30>
8000b690:	5d 11       	icall	r1
8000b692:	18 45       	or	r5,r12
8000b694:	2a 46       	sub	r6,-92
8000b696:	20 14       	sub	r4,1
8000b698:	ec cc 00 0c 	sub	r12,r6,12
8000b69c:	58 04       	cp.w	r4,0
8000b69e:	cf 14       	brge	8000b680 <_fwalk+0x1c>
8000b6a0:	6e 07       	ld.w	r7,r7[0x0]
8000b6a2:	58 07       	cp.w	r7,0
8000b6a4:	ce a1       	brne	8000b678 <_fwalk+0x14>
8000b6a6:	fe b0 fc e4 	rcall	8000b06e <__sfp_lock_release>
8000b6aa:	0a 9c       	mov	r12,r5
8000b6ac:	d8 32       	popm	r0-r7,pc
8000b6ae:	d7 03       	nop

8000b6b0 <_localeconv_r>:
8000b6b0:	fe cc d3 b8 	sub	r12,pc,-11336
8000b6b4:	5e fc       	retal	r12
8000b6b6:	d7 03       	nop

8000b6b8 <__smakebuf_r>:
8000b6b8:	d4 21       	pushm	r4-r7,lr
8000b6ba:	20 fd       	sub	sp,60
8000b6bc:	96 68       	ld.sh	r8,r11[0xc]
8000b6be:	16 97       	mov	r7,r11
8000b6c0:	18 96       	mov	r6,r12
8000b6c2:	e2 18 00 02 	andl	r8,0x2,COH
8000b6c6:	c3 d1       	brne	8000b740 <__smakebuf_r+0x88>
8000b6c8:	96 7b       	ld.sh	r11,r11[0xe]
8000b6ca:	f0 0b 19 00 	cp.h	r11,r8
8000b6ce:	c0 55       	brlt	8000b6d8 <__smakebuf_r+0x20>
8000b6d0:	1a 9a       	mov	r10,sp
8000b6d2:	e0 a0 04 81 	rcall	8000bfd4 <_fstat_r>
8000b6d6:	c0 f4       	brge	8000b6f4 <__smakebuf_r+0x3c>
8000b6d8:	8e 65       	ld.sh	r5,r7[0xc]
8000b6da:	0a 98       	mov	r8,r5
8000b6dc:	ab b8       	sbr	r8,0xb
8000b6de:	e2 15 00 80 	andl	r5,0x80,COH
8000b6e2:	ae 68       	st.h	r7[0xc],r8
8000b6e4:	30 04       	mov	r4,0
8000b6e6:	e0 68 04 00 	mov	r8,1024
8000b6ea:	f9 b5 01 40 	movne	r5,64
8000b6ee:	f0 05 17 00 	moveq	r5,r8
8000b6f2:	c1 c8       	rjmp	8000b72a <__smakebuf_r+0x72>
8000b6f4:	40 18       	lddsp	r8,sp[0x4]
8000b6f6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b6fa:	e0 48 20 00 	cp.w	r8,8192
8000b6fe:	5f 04       	sreq	r4
8000b700:	e0 48 80 00 	cp.w	r8,32768
8000b704:	c0 e1       	brne	8000b720 <__smakebuf_r+0x68>
8000b706:	6e b9       	ld.w	r9,r7[0x2c]
8000b708:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b70c:	10 39       	cp.w	r9,r8
8000b70e:	c0 91       	brne	8000b720 <__smakebuf_r+0x68>
8000b710:	8e 68       	ld.sh	r8,r7[0xc]
8000b712:	e0 65 04 00 	mov	r5,1024
8000b716:	ab a8       	sbr	r8,0xa
8000b718:	ef 45 00 50 	st.w	r7[80],r5
8000b71c:	ae 68       	st.h	r7[0xc],r8
8000b71e:	c0 68       	rjmp	8000b72a <__smakebuf_r+0x72>
8000b720:	8e 68       	ld.sh	r8,r7[0xc]
8000b722:	e0 65 04 00 	mov	r5,1024
8000b726:	ab b8       	sbr	r8,0xb
8000b728:	ae 68       	st.h	r7[0xc],r8
8000b72a:	0a 9b       	mov	r11,r5
8000b72c:	0c 9c       	mov	r12,r6
8000b72e:	fe b0 df 23 	rcall	80007574 <_malloc_r>
8000b732:	8e 68       	ld.sh	r8,r7[0xc]
8000b734:	c0 d1       	brne	8000b74e <__smakebuf_r+0x96>
8000b736:	ed b8 00 09 	bld	r8,0x9
8000b73a:	c1 b0       	breq	8000b770 <__smakebuf_r+0xb8>
8000b73c:	a1 b8       	sbr	r8,0x1
8000b73e:	ae 68       	st.h	r7[0xc],r8
8000b740:	ee c8 ff b9 	sub	r8,r7,-71
8000b744:	8f 48       	st.w	r7[0x10],r8
8000b746:	8f 08       	st.w	r7[0x0],r8
8000b748:	30 18       	mov	r8,1
8000b74a:	8f 58       	st.w	r7[0x14],r8
8000b74c:	c1 28       	rjmp	8000b770 <__smakebuf_r+0xb8>
8000b74e:	a7 b8       	sbr	r8,0x7
8000b750:	8f 4c       	st.w	r7[0x10],r12
8000b752:	ae 68       	st.h	r7[0xc],r8
8000b754:	8f 55       	st.w	r7[0x14],r5
8000b756:	fe c8 06 e6 	sub	r8,pc,1766
8000b75a:	8f 0c       	st.w	r7[0x0],r12
8000b75c:	8d a8       	st.w	r6[0x28],r8
8000b75e:	58 04       	cp.w	r4,0
8000b760:	c0 80       	breq	8000b770 <__smakebuf_r+0xb8>
8000b762:	8e 7c       	ld.sh	r12,r7[0xe]
8000b764:	fe b0 e3 94 	rcall	80007e8c <isatty>
8000b768:	c0 40       	breq	8000b770 <__smakebuf_r+0xb8>
8000b76a:	8e 68       	ld.sh	r8,r7[0xc]
8000b76c:	a1 a8       	sbr	r8,0x0
8000b76e:	ae 68       	st.h	r7[0xc],r8
8000b770:	2f 1d       	sub	sp,-60
8000b772:	d8 22       	popm	r4-r7,pc

8000b774 <memchr>:
8000b774:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b778:	c0 68       	rjmp	8000b784 <memchr+0x10>
8000b77a:	20 1a       	sub	r10,1
8000b77c:	19 88       	ld.ub	r8,r12[0x0]
8000b77e:	16 38       	cp.w	r8,r11
8000b780:	5e 0c       	reteq	r12
8000b782:	2f fc       	sub	r12,-1
8000b784:	58 0a       	cp.w	r10,0
8000b786:	cf a1       	brne	8000b77a <memchr+0x6>
8000b788:	5e fa       	retal	r10

8000b78a <memmove>:
8000b78a:	d4 01       	pushm	lr
8000b78c:	18 3b       	cp.w	r11,r12
8000b78e:	c1 92       	brcc	8000b7c0 <memmove+0x36>
8000b790:	f6 0a 00 09 	add	r9,r11,r10
8000b794:	12 3c       	cp.w	r12,r9
8000b796:	c1 52       	brcc	8000b7c0 <memmove+0x36>
8000b798:	f8 0a 00 0b 	add	r11,r12,r10
8000b79c:	30 08       	mov	r8,0
8000b79e:	c0 68       	rjmp	8000b7aa <memmove+0x20>
8000b7a0:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b7a4:	20 1a       	sub	r10,1
8000b7a6:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b7aa:	20 18       	sub	r8,1
8000b7ac:	58 0a       	cp.w	r10,0
8000b7ae:	cf 91       	brne	8000b7a0 <memmove+0x16>
8000b7b0:	d8 02       	popm	pc
8000b7b2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b7b6:	20 1a       	sub	r10,1
8000b7b8:	f8 08 0b 09 	st.b	r12[r8],r9
8000b7bc:	2f f8       	sub	r8,-1
8000b7be:	c0 28       	rjmp	8000b7c2 <memmove+0x38>
8000b7c0:	30 08       	mov	r8,0
8000b7c2:	58 0a       	cp.w	r10,0
8000b7c4:	cf 71       	brne	8000b7b2 <memmove+0x28>
8000b7c6:	d8 02       	popm	pc

8000b7c8 <__hi0bits>:
8000b7c8:	18 98       	mov	r8,r12
8000b7ca:	e0 1c 00 00 	andl	r12,0x0
8000b7ce:	f0 09 15 10 	lsl	r9,r8,0x10
8000b7d2:	58 0c       	cp.w	r12,0
8000b7d4:	f2 08 17 00 	moveq	r8,r9
8000b7d8:	f9 bc 00 10 	moveq	r12,16
8000b7dc:	f9 bc 01 00 	movne	r12,0
8000b7e0:	10 9a       	mov	r10,r8
8000b7e2:	f0 09 15 08 	lsl	r9,r8,0x8
8000b7e6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b7ea:	f7 bc 00 f8 	subeq	r12,-8
8000b7ee:	f2 08 17 00 	moveq	r8,r9
8000b7f2:	10 9a       	mov	r10,r8
8000b7f4:	f0 09 15 04 	lsl	r9,r8,0x4
8000b7f8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b7fc:	f7 bc 00 fc 	subeq	r12,-4
8000b800:	f2 08 17 00 	moveq	r8,r9
8000b804:	10 9a       	mov	r10,r8
8000b806:	f0 09 15 02 	lsl	r9,r8,0x2
8000b80a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b80e:	f7 bc 00 fe 	subeq	r12,-2
8000b812:	f2 08 17 00 	moveq	r8,r9
8000b816:	58 08       	cp.w	r8,0
8000b818:	5e 5c       	retlt	r12
8000b81a:	ed b8 00 1e 	bld	r8,0x1e
8000b81e:	f9 bc 01 20 	movne	r12,32
8000b822:	f7 bc 00 ff 	subeq	r12,-1
8000b826:	5e fc       	retal	r12

8000b828 <__lo0bits>:
8000b828:	18 99       	mov	r9,r12
8000b82a:	78 08       	ld.w	r8,r12[0x0]
8000b82c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b830:	c1 50       	breq	8000b85a <__lo0bits+0x32>
8000b832:	ed b8 00 00 	bld	r8,0x0
8000b836:	c0 21       	brne	8000b83a <__lo0bits+0x12>
8000b838:	5e fd       	retal	0
8000b83a:	10 9b       	mov	r11,r8
8000b83c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b840:	e2 1b 00 02 	andl	r11,0x2,COH
8000b844:	a3 88       	lsr	r8,0x2
8000b846:	58 0b       	cp.w	r11,0
8000b848:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b84c:	f9 bc 01 01 	movne	r12,1
8000b850:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b854:	f9 bc 00 02 	moveq	r12,2
8000b858:	5e fc       	retal	r12
8000b85a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b85e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b862:	58 0a       	cp.w	r10,0
8000b864:	f6 08 17 00 	moveq	r8,r11
8000b868:	f9 bc 00 10 	moveq	r12,16
8000b86c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b870:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b874:	58 0b       	cp.w	r11,0
8000b876:	f7 bc 00 f8 	subeq	r12,-8
8000b87a:	f4 08 17 00 	moveq	r8,r10
8000b87e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b882:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b886:	58 0b       	cp.w	r11,0
8000b888:	f7 bc 00 fc 	subeq	r12,-4
8000b88c:	f4 08 17 00 	moveq	r8,r10
8000b890:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b894:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b898:	58 0b       	cp.w	r11,0
8000b89a:	f7 bc 00 fe 	subeq	r12,-2
8000b89e:	f4 08 17 00 	moveq	r8,r10
8000b8a2:	ed b8 00 00 	bld	r8,0x0
8000b8a6:	c0 60       	breq	8000b8b2 <__lo0bits+0x8a>
8000b8a8:	a1 98       	lsr	r8,0x1
8000b8aa:	c0 31       	brne	8000b8b0 <__lo0bits+0x88>
8000b8ac:	32 0c       	mov	r12,32
8000b8ae:	5e fc       	retal	r12
8000b8b0:	2f fc       	sub	r12,-1
8000b8b2:	93 08       	st.w	r9[0x0],r8
8000b8b4:	5e fc       	retal	r12

8000b8b6 <__mcmp>:
8000b8b6:	d4 01       	pushm	lr
8000b8b8:	18 98       	mov	r8,r12
8000b8ba:	76 49       	ld.w	r9,r11[0x10]
8000b8bc:	78 4c       	ld.w	r12,r12[0x10]
8000b8be:	12 1c       	sub	r12,r9
8000b8c0:	c1 31       	brne	8000b8e6 <__mcmp+0x30>
8000b8c2:	2f b9       	sub	r9,-5
8000b8c4:	a3 69       	lsl	r9,0x2
8000b8c6:	12 0b       	add	r11,r9
8000b8c8:	f0 09 00 09 	add	r9,r8,r9
8000b8cc:	2e c8       	sub	r8,-20
8000b8ce:	13 4e       	ld.w	lr,--r9
8000b8d0:	17 4a       	ld.w	r10,--r11
8000b8d2:	14 3e       	cp.w	lr,r10
8000b8d4:	c0 60       	breq	8000b8e0 <__mcmp+0x2a>
8000b8d6:	f9 bc 03 ff 	movlo	r12,-1
8000b8da:	f9 bc 02 01 	movhs	r12,1
8000b8de:	d8 02       	popm	pc
8000b8e0:	10 39       	cp.w	r9,r8
8000b8e2:	fe 9b ff f6 	brhi	8000b8ce <__mcmp+0x18>
8000b8e6:	d8 02       	popm	pc

8000b8e8 <_Bfree>:
8000b8e8:	d4 21       	pushm	r4-r7,lr
8000b8ea:	18 97       	mov	r7,r12
8000b8ec:	16 95       	mov	r5,r11
8000b8ee:	78 96       	ld.w	r6,r12[0x24]
8000b8f0:	58 06       	cp.w	r6,0
8000b8f2:	c0 91       	brne	8000b904 <_Bfree+0x1c>
8000b8f4:	31 0c       	mov	r12,16
8000b8f6:	fe b0 de 37 	rcall	80007564 <malloc>
8000b8fa:	99 36       	st.w	r12[0xc],r6
8000b8fc:	8f 9c       	st.w	r7[0x24],r12
8000b8fe:	99 16       	st.w	r12[0x4],r6
8000b900:	99 26       	st.w	r12[0x8],r6
8000b902:	99 06       	st.w	r12[0x0],r6
8000b904:	58 05       	cp.w	r5,0
8000b906:	c0 90       	breq	8000b918 <_Bfree+0x30>
8000b908:	6a 19       	ld.w	r9,r5[0x4]
8000b90a:	6e 98       	ld.w	r8,r7[0x24]
8000b90c:	70 38       	ld.w	r8,r8[0xc]
8000b90e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b912:	8b 0a       	st.w	r5[0x0],r10
8000b914:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b918:	d8 22       	popm	r4-r7,pc
8000b91a:	d7 03       	nop

8000b91c <_Balloc>:
8000b91c:	d4 21       	pushm	r4-r7,lr
8000b91e:	18 97       	mov	r7,r12
8000b920:	16 96       	mov	r6,r11
8000b922:	78 95       	ld.w	r5,r12[0x24]
8000b924:	58 05       	cp.w	r5,0
8000b926:	c0 91       	brne	8000b938 <_Balloc+0x1c>
8000b928:	31 0c       	mov	r12,16
8000b92a:	fe b0 de 1d 	rcall	80007564 <malloc>
8000b92e:	99 35       	st.w	r12[0xc],r5
8000b930:	8f 9c       	st.w	r7[0x24],r12
8000b932:	99 15       	st.w	r12[0x4],r5
8000b934:	99 25       	st.w	r12[0x8],r5
8000b936:	99 05       	st.w	r12[0x0],r5
8000b938:	6e 95       	ld.w	r5,r7[0x24]
8000b93a:	6a 38       	ld.w	r8,r5[0xc]
8000b93c:	58 08       	cp.w	r8,0
8000b93e:	c0 b1       	brne	8000b954 <_Balloc+0x38>
8000b940:	31 0a       	mov	r10,16
8000b942:	30 4b       	mov	r11,4
8000b944:	0e 9c       	mov	r12,r7
8000b946:	e0 a0 02 a7 	rcall	8000be94 <_calloc_r>
8000b94a:	8b 3c       	st.w	r5[0xc],r12
8000b94c:	6e 98       	ld.w	r8,r7[0x24]
8000b94e:	70 3c       	ld.w	r12,r8[0xc]
8000b950:	58 0c       	cp.w	r12,0
8000b952:	c1 b0       	breq	8000b988 <_Balloc+0x6c>
8000b954:	6e 98       	ld.w	r8,r7[0x24]
8000b956:	70 38       	ld.w	r8,r8[0xc]
8000b958:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b95c:	70 0c       	ld.w	r12,r8[0x0]
8000b95e:	58 0c       	cp.w	r12,0
8000b960:	c0 40       	breq	8000b968 <_Balloc+0x4c>
8000b962:	78 09       	ld.w	r9,r12[0x0]
8000b964:	91 09       	st.w	r8[0x0],r9
8000b966:	c0 e8       	rjmp	8000b982 <_Balloc+0x66>
8000b968:	0e 9c       	mov	r12,r7
8000b96a:	30 17       	mov	r7,1
8000b96c:	0e 9b       	mov	r11,r7
8000b96e:	ee 06 09 47 	lsl	r7,r7,r6
8000b972:	ee ca ff fb 	sub	r10,r7,-5
8000b976:	a3 6a       	lsl	r10,0x2
8000b978:	e0 a0 02 8e 	rcall	8000be94 <_calloc_r>
8000b97c:	c0 60       	breq	8000b988 <_Balloc+0x6c>
8000b97e:	99 16       	st.w	r12[0x4],r6
8000b980:	99 27       	st.w	r12[0x8],r7
8000b982:	30 08       	mov	r8,0
8000b984:	99 38       	st.w	r12[0xc],r8
8000b986:	99 48       	st.w	r12[0x10],r8
8000b988:	d8 22       	popm	r4-r7,pc
8000b98a:	d7 03       	nop

8000b98c <__d2b>:
8000b98c:	d4 31       	pushm	r0-r7,lr
8000b98e:	20 2d       	sub	sp,8
8000b990:	16 93       	mov	r3,r11
8000b992:	12 96       	mov	r6,r9
8000b994:	10 95       	mov	r5,r8
8000b996:	14 92       	mov	r2,r10
8000b998:	30 1b       	mov	r11,1
8000b99a:	cc 1f       	rcall	8000b91c <_Balloc>
8000b99c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b9a0:	50 09       	stdsp	sp[0x0],r9
8000b9a2:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b9a6:	b5 a9       	sbr	r9,0x14
8000b9a8:	f0 01 16 14 	lsr	r1,r8,0x14
8000b9ac:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b9b0:	18 94       	mov	r4,r12
8000b9b2:	58 02       	cp.w	r2,0
8000b9b4:	c1 d0       	breq	8000b9ee <__d2b+0x62>
8000b9b6:	fa cc ff f8 	sub	r12,sp,-8
8000b9ba:	18 d2       	st.w	--r12,r2
8000b9bc:	c3 6f       	rcall	8000b828 <__lo0bits>
8000b9be:	40 18       	lddsp	r8,sp[0x4]
8000b9c0:	c0 d0       	breq	8000b9da <__d2b+0x4e>
8000b9c2:	40 09       	lddsp	r9,sp[0x0]
8000b9c4:	f8 0a 11 20 	rsub	r10,r12,32
8000b9c8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b9cc:	f5 e8 10 08 	or	r8,r10,r8
8000b9d0:	89 58       	st.w	r4[0x14],r8
8000b9d2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b9d6:	50 09       	stdsp	sp[0x0],r9
8000b9d8:	c0 28       	rjmp	8000b9dc <__d2b+0x50>
8000b9da:	89 58       	st.w	r4[0x14],r8
8000b9dc:	40 08       	lddsp	r8,sp[0x0]
8000b9de:	58 08       	cp.w	r8,0
8000b9e0:	f9 b3 01 02 	movne	r3,2
8000b9e4:	f9 b3 00 01 	moveq	r3,1
8000b9e8:	89 68       	st.w	r4[0x18],r8
8000b9ea:	89 43       	st.w	r4[0x10],r3
8000b9ec:	c0 88       	rjmp	8000b9fc <__d2b+0x70>
8000b9ee:	1a 9c       	mov	r12,sp
8000b9f0:	c1 cf       	rcall	8000b828 <__lo0bits>
8000b9f2:	30 13       	mov	r3,1
8000b9f4:	40 08       	lddsp	r8,sp[0x0]
8000b9f6:	2e 0c       	sub	r12,-32
8000b9f8:	89 43       	st.w	r4[0x10],r3
8000b9fa:	89 58       	st.w	r4[0x14],r8
8000b9fc:	58 01       	cp.w	r1,0
8000b9fe:	c0 90       	breq	8000ba10 <__d2b+0x84>
8000ba00:	e2 c1 04 33 	sub	r1,r1,1075
8000ba04:	18 01       	add	r1,r12
8000ba06:	8d 01       	st.w	r6[0x0],r1
8000ba08:	f8 0c 11 35 	rsub	r12,r12,53
8000ba0c:	8b 0c       	st.w	r5[0x0],r12
8000ba0e:	c0 c8       	rjmp	8000ba26 <__d2b+0x9a>
8000ba10:	e6 c8 ff fc 	sub	r8,r3,-4
8000ba14:	f8 cc 04 32 	sub	r12,r12,1074
8000ba18:	a5 73       	lsl	r3,0x5
8000ba1a:	8d 0c       	st.w	r6[0x0],r12
8000ba1c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ba20:	cd 4e       	rcall	8000b7c8 <__hi0bits>
8000ba22:	18 13       	sub	r3,r12
8000ba24:	8b 03       	st.w	r5[0x0],r3
8000ba26:	08 9c       	mov	r12,r4
8000ba28:	2f ed       	sub	sp,-8
8000ba2a:	d8 32       	popm	r0-r7,pc

8000ba2c <__mdiff>:
8000ba2c:	d4 31       	pushm	r0-r7,lr
8000ba2e:	74 48       	ld.w	r8,r10[0x10]
8000ba30:	76 45       	ld.w	r5,r11[0x10]
8000ba32:	16 97       	mov	r7,r11
8000ba34:	14 96       	mov	r6,r10
8000ba36:	10 15       	sub	r5,r8
8000ba38:	c1 31       	brne	8000ba5e <__mdiff+0x32>
8000ba3a:	2f b8       	sub	r8,-5
8000ba3c:	ee ce ff ec 	sub	lr,r7,-20
8000ba40:	a3 68       	lsl	r8,0x2
8000ba42:	f4 08 00 0b 	add	r11,r10,r8
8000ba46:	ee 08 00 08 	add	r8,r7,r8
8000ba4a:	11 4a       	ld.w	r10,--r8
8000ba4c:	17 49       	ld.w	r9,--r11
8000ba4e:	12 3a       	cp.w	r10,r9
8000ba50:	c0 30       	breq	8000ba56 <__mdiff+0x2a>
8000ba52:	c0 e2       	brcc	8000ba6e <__mdiff+0x42>
8000ba54:	c0 78       	rjmp	8000ba62 <__mdiff+0x36>
8000ba56:	1c 38       	cp.w	r8,lr
8000ba58:	fe 9b ff f9 	brhi	8000ba4a <__mdiff+0x1e>
8000ba5c:	c4 98       	rjmp	8000baee <__mdiff+0xc2>
8000ba5e:	58 05       	cp.w	r5,0
8000ba60:	c0 64       	brge	8000ba6c <__mdiff+0x40>
8000ba62:	0e 98       	mov	r8,r7
8000ba64:	30 15       	mov	r5,1
8000ba66:	0c 97       	mov	r7,r6
8000ba68:	10 96       	mov	r6,r8
8000ba6a:	c0 28       	rjmp	8000ba6e <__mdiff+0x42>
8000ba6c:	30 05       	mov	r5,0
8000ba6e:	6e 1b       	ld.w	r11,r7[0x4]
8000ba70:	c5 6f       	rcall	8000b91c <_Balloc>
8000ba72:	6e 49       	ld.w	r9,r7[0x10]
8000ba74:	6c 44       	ld.w	r4,r6[0x10]
8000ba76:	99 35       	st.w	r12[0xc],r5
8000ba78:	2f b4       	sub	r4,-5
8000ba7a:	f2 c5 ff fb 	sub	r5,r9,-5
8000ba7e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ba82:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ba86:	2e c6       	sub	r6,-20
8000ba88:	2e c7       	sub	r7,-20
8000ba8a:	f8 c8 ff ec 	sub	r8,r12,-20
8000ba8e:	30 0a       	mov	r10,0
8000ba90:	0f 0e       	ld.w	lr,r7++
8000ba92:	0d 0b       	ld.w	r11,r6++
8000ba94:	fc 02 16 10 	lsr	r2,lr,0x10
8000ba98:	f6 03 16 10 	lsr	r3,r11,0x10
8000ba9c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000baa0:	e4 03 01 03 	sub	r3,r2,r3
8000baa4:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000baa8:	fc 0b 01 0b 	sub	r11,lr,r11
8000baac:	f6 0a 00 0a 	add	r10,r11,r10
8000bab0:	b0 1a       	st.h	r8[0x2],r10
8000bab2:	b1 4a       	asr	r10,0x10
8000bab4:	e6 0a 00 0a 	add	r10,r3,r10
8000bab8:	b0 0a       	st.h	r8[0x0],r10
8000baba:	2f c8       	sub	r8,-4
8000babc:	b1 4a       	asr	r10,0x10
8000babe:	08 36       	cp.w	r6,r4
8000bac0:	ce 83       	brcs	8000ba90 <__mdiff+0x64>
8000bac2:	c0 d8       	rjmp	8000badc <__mdiff+0xb0>
8000bac4:	0f 0b       	ld.w	r11,r7++
8000bac6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000baca:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bace:	16 0a       	add	r10,r11
8000bad0:	b0 1a       	st.h	r8[0x2],r10
8000bad2:	b1 4a       	asr	r10,0x10
8000bad4:	1c 0a       	add	r10,lr
8000bad6:	b0 0a       	st.h	r8[0x0],r10
8000bad8:	2f c8       	sub	r8,-4
8000bada:	b1 4a       	asr	r10,0x10
8000badc:	0a 37       	cp.w	r7,r5
8000bade:	cf 33       	brcs	8000bac4 <__mdiff+0x98>
8000bae0:	c0 28       	rjmp	8000bae4 <__mdiff+0xb8>
8000bae2:	20 19       	sub	r9,1
8000bae4:	11 4a       	ld.w	r10,--r8
8000bae6:	58 0a       	cp.w	r10,0
8000bae8:	cf d0       	breq	8000bae2 <__mdiff+0xb6>
8000baea:	99 49       	st.w	r12[0x10],r9
8000baec:	d8 32       	popm	r0-r7,pc
8000baee:	30 0b       	mov	r11,0
8000baf0:	c1 6f       	rcall	8000b91c <_Balloc>
8000baf2:	30 18       	mov	r8,1
8000baf4:	99 48       	st.w	r12[0x10],r8
8000baf6:	30 08       	mov	r8,0
8000baf8:	99 58       	st.w	r12[0x14],r8
8000bafa:	d8 32       	popm	r0-r7,pc

8000bafc <__lshift>:
8000bafc:	d4 31       	pushm	r0-r7,lr
8000bafe:	16 97       	mov	r7,r11
8000bb00:	76 46       	ld.w	r6,r11[0x10]
8000bb02:	f4 02 14 05 	asr	r2,r10,0x5
8000bb06:	2f f6       	sub	r6,-1
8000bb08:	14 93       	mov	r3,r10
8000bb0a:	18 94       	mov	r4,r12
8000bb0c:	04 06       	add	r6,r2
8000bb0e:	76 1b       	ld.w	r11,r11[0x4]
8000bb10:	6e 28       	ld.w	r8,r7[0x8]
8000bb12:	c0 38       	rjmp	8000bb18 <__lshift+0x1c>
8000bb14:	2f fb       	sub	r11,-1
8000bb16:	a1 78       	lsl	r8,0x1
8000bb18:	10 36       	cp.w	r6,r8
8000bb1a:	fe 99 ff fd 	brgt	8000bb14 <__lshift+0x18>
8000bb1e:	08 9c       	mov	r12,r4
8000bb20:	cf ee       	rcall	8000b91c <_Balloc>
8000bb22:	30 09       	mov	r9,0
8000bb24:	18 95       	mov	r5,r12
8000bb26:	f8 c8 ff ec 	sub	r8,r12,-20
8000bb2a:	12 9a       	mov	r10,r9
8000bb2c:	c0 38       	rjmp	8000bb32 <__lshift+0x36>
8000bb2e:	10 aa       	st.w	r8++,r10
8000bb30:	2f f9       	sub	r9,-1
8000bb32:	04 39       	cp.w	r9,r2
8000bb34:	cf d5       	brlt	8000bb2e <__lshift+0x32>
8000bb36:	6e 4b       	ld.w	r11,r7[0x10]
8000bb38:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000bb3c:	2f bb       	sub	r11,-5
8000bb3e:	ee c9 ff ec 	sub	r9,r7,-20
8000bb42:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000bb46:	58 03       	cp.w	r3,0
8000bb48:	c1 30       	breq	8000bb6e <__lshift+0x72>
8000bb4a:	e6 0c 11 20 	rsub	r12,r3,32
8000bb4e:	30 0a       	mov	r10,0
8000bb50:	72 02       	ld.w	r2,r9[0x0]
8000bb52:	e4 03 09 42 	lsl	r2,r2,r3
8000bb56:	04 4a       	or	r10,r2
8000bb58:	10 aa       	st.w	r8++,r10
8000bb5a:	13 0a       	ld.w	r10,r9++
8000bb5c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb60:	16 39       	cp.w	r9,r11
8000bb62:	cf 73       	brcs	8000bb50 <__lshift+0x54>
8000bb64:	91 0a       	st.w	r8[0x0],r10
8000bb66:	58 0a       	cp.w	r10,0
8000bb68:	c0 70       	breq	8000bb76 <__lshift+0x7a>
8000bb6a:	2f f6       	sub	r6,-1
8000bb6c:	c0 58       	rjmp	8000bb76 <__lshift+0x7a>
8000bb6e:	13 0a       	ld.w	r10,r9++
8000bb70:	10 aa       	st.w	r8++,r10
8000bb72:	16 39       	cp.w	r9,r11
8000bb74:	cf d3       	brcs	8000bb6e <__lshift+0x72>
8000bb76:	08 9c       	mov	r12,r4
8000bb78:	20 16       	sub	r6,1
8000bb7a:	0e 9b       	mov	r11,r7
8000bb7c:	8b 46       	st.w	r5[0x10],r6
8000bb7e:	cb 5e       	rcall	8000b8e8 <_Bfree>
8000bb80:	0a 9c       	mov	r12,r5
8000bb82:	d8 32       	popm	r0-r7,pc

8000bb84 <__multiply>:
8000bb84:	d4 31       	pushm	r0-r7,lr
8000bb86:	20 2d       	sub	sp,8
8000bb88:	76 49       	ld.w	r9,r11[0x10]
8000bb8a:	74 48       	ld.w	r8,r10[0x10]
8000bb8c:	16 96       	mov	r6,r11
8000bb8e:	14 95       	mov	r5,r10
8000bb90:	10 39       	cp.w	r9,r8
8000bb92:	ec 08 17 50 	movlt	r8,r6
8000bb96:	ea 06 17 50 	movlt	r6,r5
8000bb9a:	f0 05 17 50 	movlt	r5,r8
8000bb9e:	6c 28       	ld.w	r8,r6[0x8]
8000bba0:	76 43       	ld.w	r3,r11[0x10]
8000bba2:	74 42       	ld.w	r2,r10[0x10]
8000bba4:	76 1b       	ld.w	r11,r11[0x4]
8000bba6:	e4 03 00 07 	add	r7,r2,r3
8000bbaa:	10 37       	cp.w	r7,r8
8000bbac:	f7 bb 09 ff 	subgt	r11,-1
8000bbb0:	cb 6e       	rcall	8000b91c <_Balloc>
8000bbb2:	ee c4 ff fb 	sub	r4,r7,-5
8000bbb6:	f8 c9 ff ec 	sub	r9,r12,-20
8000bbba:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bbbe:	30 0a       	mov	r10,0
8000bbc0:	12 98       	mov	r8,r9
8000bbc2:	c0 28       	rjmp	8000bbc6 <__multiply+0x42>
8000bbc4:	10 aa       	st.w	r8++,r10
8000bbc6:	08 38       	cp.w	r8,r4
8000bbc8:	cf e3       	brcs	8000bbc4 <__multiply+0x40>
8000bbca:	2f b3       	sub	r3,-5
8000bbcc:	2f b2       	sub	r2,-5
8000bbce:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bbd2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bbd6:	ec cb ff ec 	sub	r11,r6,-20
8000bbda:	50 12       	stdsp	sp[0x4],r2
8000bbdc:	ea ca ff ec 	sub	r10,r5,-20
8000bbe0:	c4 48       	rjmp	8000bc68 <__multiply+0xe4>
8000bbe2:	94 95       	ld.uh	r5,r10[0x2]
8000bbe4:	58 05       	cp.w	r5,0
8000bbe6:	c2 00       	breq	8000bc26 <__multiply+0xa2>
8000bbe8:	12 98       	mov	r8,r9
8000bbea:	16 96       	mov	r6,r11
8000bbec:	30 0e       	mov	lr,0
8000bbee:	50 09       	stdsp	sp[0x0],r9
8000bbf0:	0d 02       	ld.w	r2,r6++
8000bbf2:	e4 00 16 10 	lsr	r0,r2,0x10
8000bbf6:	70 01       	ld.w	r1,r8[0x0]
8000bbf8:	70 09       	ld.w	r9,r8[0x0]
8000bbfa:	b1 81       	lsr	r1,0x10
8000bbfc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bc00:	e0 05 03 41 	mac	r1,r0,r5
8000bc04:	ab 32       	mul	r2,r5
8000bc06:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bc0a:	00 02       	add	r2,r0
8000bc0c:	e4 0e 00 0e 	add	lr,r2,lr
8000bc10:	b0 1e       	st.h	r8[0x2],lr
8000bc12:	b1 8e       	lsr	lr,0x10
8000bc14:	1c 01       	add	r1,lr
8000bc16:	b0 01       	st.h	r8[0x0],r1
8000bc18:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bc1c:	2f c8       	sub	r8,-4
8000bc1e:	06 36       	cp.w	r6,r3
8000bc20:	ce 83       	brcs	8000bbf0 <__multiply+0x6c>
8000bc22:	40 09       	lddsp	r9,sp[0x0]
8000bc24:	91 0e       	st.w	r8[0x0],lr
8000bc26:	94 86       	ld.uh	r6,r10[0x0]
8000bc28:	58 06       	cp.w	r6,0
8000bc2a:	c1 d0       	breq	8000bc64 <__multiply+0xe0>
8000bc2c:	72 02       	ld.w	r2,r9[0x0]
8000bc2e:	12 98       	mov	r8,r9
8000bc30:	16 9e       	mov	lr,r11
8000bc32:	30 05       	mov	r5,0
8000bc34:	b0 12       	st.h	r8[0x2],r2
8000bc36:	1d 01       	ld.w	r1,lr++
8000bc38:	90 82       	ld.uh	r2,r8[0x0]
8000bc3a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bc3e:	ad 30       	mul	r0,r6
8000bc40:	e0 02 00 02 	add	r2,r0,r2
8000bc44:	e4 05 00 05 	add	r5,r2,r5
8000bc48:	b0 05       	st.h	r8[0x0],r5
8000bc4a:	b1 85       	lsr	r5,0x10
8000bc4c:	b1 81       	lsr	r1,0x10
8000bc4e:	2f c8       	sub	r8,-4
8000bc50:	ad 31       	mul	r1,r6
8000bc52:	90 92       	ld.uh	r2,r8[0x2]
8000bc54:	e2 02 00 02 	add	r2,r1,r2
8000bc58:	0a 02       	add	r2,r5
8000bc5a:	e4 05 16 10 	lsr	r5,r2,0x10
8000bc5e:	06 3e       	cp.w	lr,r3
8000bc60:	ce a3       	brcs	8000bc34 <__multiply+0xb0>
8000bc62:	91 02       	st.w	r8[0x0],r2
8000bc64:	2f ca       	sub	r10,-4
8000bc66:	2f c9       	sub	r9,-4
8000bc68:	40 18       	lddsp	r8,sp[0x4]
8000bc6a:	10 3a       	cp.w	r10,r8
8000bc6c:	cb b3       	brcs	8000bbe2 <__multiply+0x5e>
8000bc6e:	c0 28       	rjmp	8000bc72 <__multiply+0xee>
8000bc70:	20 17       	sub	r7,1
8000bc72:	58 07       	cp.w	r7,0
8000bc74:	e0 8a 00 05 	brle	8000bc7e <__multiply+0xfa>
8000bc78:	09 48       	ld.w	r8,--r4
8000bc7a:	58 08       	cp.w	r8,0
8000bc7c:	cf a0       	breq	8000bc70 <__multiply+0xec>
8000bc7e:	99 47       	st.w	r12[0x10],r7
8000bc80:	2f ed       	sub	sp,-8
8000bc82:	d8 32       	popm	r0-r7,pc

8000bc84 <__i2b>:
8000bc84:	d4 21       	pushm	r4-r7,lr
8000bc86:	16 97       	mov	r7,r11
8000bc88:	30 1b       	mov	r11,1
8000bc8a:	c4 9e       	rcall	8000b91c <_Balloc>
8000bc8c:	30 19       	mov	r9,1
8000bc8e:	99 57       	st.w	r12[0x14],r7
8000bc90:	99 49       	st.w	r12[0x10],r9
8000bc92:	d8 22       	popm	r4-r7,pc

8000bc94 <__multadd>:
8000bc94:	d4 31       	pushm	r0-r7,lr
8000bc96:	30 08       	mov	r8,0
8000bc98:	12 95       	mov	r5,r9
8000bc9a:	16 97       	mov	r7,r11
8000bc9c:	18 96       	mov	r6,r12
8000bc9e:	76 44       	ld.w	r4,r11[0x10]
8000bca0:	f6 c9 ff ec 	sub	r9,r11,-20
8000bca4:	72 0b       	ld.w	r11,r9[0x0]
8000bca6:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bcaa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bcae:	f4 0c 02 4c 	mul	r12,r10,r12
8000bcb2:	f4 0b 03 45 	mac	r5,r10,r11
8000bcb6:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bcba:	b1 85       	lsr	r5,0x10
8000bcbc:	18 05       	add	r5,r12
8000bcbe:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bcc2:	f8 0b 00 0b 	add	r11,r12,r11
8000bcc6:	12 ab       	st.w	r9++,r11
8000bcc8:	2f f8       	sub	r8,-1
8000bcca:	b1 85       	lsr	r5,0x10
8000bccc:	08 38       	cp.w	r8,r4
8000bcce:	ce b5       	brlt	8000bca4 <__multadd+0x10>
8000bcd0:	58 05       	cp.w	r5,0
8000bcd2:	c1 c0       	breq	8000bd0a <__multadd+0x76>
8000bcd4:	6e 28       	ld.w	r8,r7[0x8]
8000bcd6:	10 34       	cp.w	r4,r8
8000bcd8:	c1 35       	brlt	8000bcfe <__multadd+0x6a>
8000bcda:	6e 1b       	ld.w	r11,r7[0x4]
8000bcdc:	0c 9c       	mov	r12,r6
8000bcde:	2f fb       	sub	r11,-1
8000bce0:	c1 ee       	rcall	8000b91c <_Balloc>
8000bce2:	6e 4a       	ld.w	r10,r7[0x10]
8000bce4:	ee cb ff f4 	sub	r11,r7,-12
8000bce8:	18 93       	mov	r3,r12
8000bcea:	2f ea       	sub	r10,-2
8000bcec:	2f 4c       	sub	r12,-12
8000bcee:	a3 6a       	lsl	r10,0x2
8000bcf0:	fe b0 de 71 	rcall	800079d2 <memcpy>
8000bcf4:	0e 9b       	mov	r11,r7
8000bcf6:	0c 9c       	mov	r12,r6
8000bcf8:	fe b0 fd f8 	rcall	8000b8e8 <_Bfree>
8000bcfc:	06 97       	mov	r7,r3
8000bcfe:	e8 c8 ff ff 	sub	r8,r4,-1
8000bd02:	2f b4       	sub	r4,-5
8000bd04:	8f 48       	st.w	r7[0x10],r8
8000bd06:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bd0a:	0e 9c       	mov	r12,r7
8000bd0c:	d8 32       	popm	r0-r7,pc
8000bd0e:	d7 03       	nop

8000bd10 <__pow5mult>:
8000bd10:	d4 31       	pushm	r0-r7,lr
8000bd12:	14 96       	mov	r6,r10
8000bd14:	18 97       	mov	r7,r12
8000bd16:	16 94       	mov	r4,r11
8000bd18:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bd1c:	c0 90       	breq	8000bd2e <__pow5mult+0x1e>
8000bd1e:	20 18       	sub	r8,1
8000bd20:	fe c9 d9 ec 	sub	r9,pc,-9748
8000bd24:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bd28:	30 09       	mov	r9,0
8000bd2a:	cb 5f       	rcall	8000bc94 <__multadd>
8000bd2c:	18 94       	mov	r4,r12
8000bd2e:	a3 46       	asr	r6,0x2
8000bd30:	c3 40       	breq	8000bd98 <__pow5mult+0x88>
8000bd32:	6e 95       	ld.w	r5,r7[0x24]
8000bd34:	58 05       	cp.w	r5,0
8000bd36:	c0 91       	brne	8000bd48 <__pow5mult+0x38>
8000bd38:	31 0c       	mov	r12,16
8000bd3a:	fe b0 dc 15 	rcall	80007564 <malloc>
8000bd3e:	99 35       	st.w	r12[0xc],r5
8000bd40:	8f 9c       	st.w	r7[0x24],r12
8000bd42:	99 15       	st.w	r12[0x4],r5
8000bd44:	99 25       	st.w	r12[0x8],r5
8000bd46:	99 05       	st.w	r12[0x0],r5
8000bd48:	6e 93       	ld.w	r3,r7[0x24]
8000bd4a:	66 25       	ld.w	r5,r3[0x8]
8000bd4c:	58 05       	cp.w	r5,0
8000bd4e:	c0 c1       	brne	8000bd66 <__pow5mult+0x56>
8000bd50:	e0 6b 02 71 	mov	r11,625
8000bd54:	0e 9c       	mov	r12,r7
8000bd56:	c9 7f       	rcall	8000bc84 <__i2b>
8000bd58:	87 2c       	st.w	r3[0x8],r12
8000bd5a:	30 08       	mov	r8,0
8000bd5c:	18 95       	mov	r5,r12
8000bd5e:	99 08       	st.w	r12[0x0],r8
8000bd60:	c0 38       	rjmp	8000bd66 <__pow5mult+0x56>
8000bd62:	06 9c       	mov	r12,r3
8000bd64:	18 95       	mov	r5,r12
8000bd66:	ed b6 00 00 	bld	r6,0x0
8000bd6a:	c0 b1       	brne	8000bd80 <__pow5mult+0x70>
8000bd6c:	08 9b       	mov	r11,r4
8000bd6e:	0a 9a       	mov	r10,r5
8000bd70:	0e 9c       	mov	r12,r7
8000bd72:	c0 9f       	rcall	8000bb84 <__multiply>
8000bd74:	08 9b       	mov	r11,r4
8000bd76:	18 93       	mov	r3,r12
8000bd78:	0e 9c       	mov	r12,r7
8000bd7a:	06 94       	mov	r4,r3
8000bd7c:	fe b0 fd b6 	rcall	8000b8e8 <_Bfree>
8000bd80:	a1 56       	asr	r6,0x1
8000bd82:	c0 b0       	breq	8000bd98 <__pow5mult+0x88>
8000bd84:	6a 03       	ld.w	r3,r5[0x0]
8000bd86:	58 03       	cp.w	r3,0
8000bd88:	ce d1       	brne	8000bd62 <__pow5mult+0x52>
8000bd8a:	0a 9a       	mov	r10,r5
8000bd8c:	0a 9b       	mov	r11,r5
8000bd8e:	0e 9c       	mov	r12,r7
8000bd90:	cf ae       	rcall	8000bb84 <__multiply>
8000bd92:	8b 0c       	st.w	r5[0x0],r12
8000bd94:	99 03       	st.w	r12[0x0],r3
8000bd96:	ce 7b       	rjmp	8000bd64 <__pow5mult+0x54>
8000bd98:	08 9c       	mov	r12,r4
8000bd9a:	d8 32       	popm	r0-r7,pc

8000bd9c <__isinfd>:
8000bd9c:	14 98       	mov	r8,r10
8000bd9e:	fc 19 7f f0 	movh	r9,0x7ff0
8000bda2:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bda6:	f0 0b 11 00 	rsub	r11,r8,0
8000bdaa:	f7 e8 10 08 	or	r8,r11,r8
8000bdae:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bdb2:	f2 08 01 08 	sub	r8,r9,r8
8000bdb6:	f0 0c 11 00 	rsub	r12,r8,0
8000bdba:	f9 e8 10 08 	or	r8,r12,r8
8000bdbe:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bdc2:	2f fc       	sub	r12,-1
8000bdc4:	5e fc       	retal	r12

8000bdc6 <__isnand>:
8000bdc6:	14 98       	mov	r8,r10
8000bdc8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bdcc:	f0 0c 11 00 	rsub	r12,r8,0
8000bdd0:	10 4c       	or	r12,r8
8000bdd2:	fc 18 7f f0 	movh	r8,0x7ff0
8000bdd6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bdda:	f0 0c 01 0c 	sub	r12,r8,r12
8000bdde:	bf 9c       	lsr	r12,0x1f
8000bde0:	5e fc       	retal	r12
8000bde2:	d7 03       	nop

8000bde4 <__sclose>:
8000bde4:	d4 01       	pushm	lr
8000bde6:	96 7b       	ld.sh	r11,r11[0xe]
8000bde8:	c8 2c       	rcall	8000beec <_close_r>
8000bdea:	d8 02       	popm	pc

8000bdec <__sseek>:
8000bdec:	d4 21       	pushm	r4-r7,lr
8000bdee:	16 97       	mov	r7,r11
8000bdf0:	96 7b       	ld.sh	r11,r11[0xe]
8000bdf2:	c0 3d       	rcall	8000bff8 <_lseek_r>
8000bdf4:	8e 68       	ld.sh	r8,r7[0xc]
8000bdf6:	10 99       	mov	r9,r8
8000bdf8:	ad c8       	cbr	r8,0xc
8000bdfa:	ad a9       	sbr	r9,0xc
8000bdfc:	5b fc       	cp.w	r12,-1
8000bdfe:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000be02:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000be06:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000be0a:	d8 22       	popm	r4-r7,pc

8000be0c <__swrite>:
8000be0c:	d4 21       	pushm	r4-r7,lr
8000be0e:	96 68       	ld.sh	r8,r11[0xc]
8000be10:	16 97       	mov	r7,r11
8000be12:	14 95       	mov	r5,r10
8000be14:	12 94       	mov	r4,r9
8000be16:	e2 18 01 00 	andl	r8,0x100,COH
8000be1a:	18 96       	mov	r6,r12
8000be1c:	c0 50       	breq	8000be26 <__swrite+0x1a>
8000be1e:	30 29       	mov	r9,2
8000be20:	30 0a       	mov	r10,0
8000be22:	96 7b       	ld.sh	r11,r11[0xe]
8000be24:	ce ac       	rcall	8000bff8 <_lseek_r>
8000be26:	8e 68       	ld.sh	r8,r7[0xc]
8000be28:	ad c8       	cbr	r8,0xc
8000be2a:	08 99       	mov	r9,r4
8000be2c:	0a 9a       	mov	r10,r5
8000be2e:	8e 7b       	ld.sh	r11,r7[0xe]
8000be30:	0c 9c       	mov	r12,r6
8000be32:	ae 68       	st.h	r7[0xc],r8
8000be34:	c1 cc       	rcall	8000be6c <_write_r>
8000be36:	d8 22       	popm	r4-r7,pc

8000be38 <__sread>:
8000be38:	d4 21       	pushm	r4-r7,lr
8000be3a:	16 97       	mov	r7,r11
8000be3c:	96 7b       	ld.sh	r11,r11[0xe]
8000be3e:	cf 1c       	rcall	8000c020 <_read_r>
8000be40:	c0 65       	brlt	8000be4c <__sread+0x14>
8000be42:	6f 58       	ld.w	r8,r7[0x54]
8000be44:	18 08       	add	r8,r12
8000be46:	ef 48 00 54 	st.w	r7[84],r8
8000be4a:	d8 22       	popm	r4-r7,pc
8000be4c:	8e 68       	ld.sh	r8,r7[0xc]
8000be4e:	ad c8       	cbr	r8,0xc
8000be50:	ae 68       	st.h	r7[0xc],r8
8000be52:	d8 22       	popm	r4-r7,pc

8000be54 <strlen>:
8000be54:	30 09       	mov	r9,0
8000be56:	18 98       	mov	r8,r12
8000be58:	c0 28       	rjmp	8000be5c <strlen+0x8>
8000be5a:	2f f8       	sub	r8,-1
8000be5c:	11 8a       	ld.ub	r10,r8[0x0]
8000be5e:	f2 0a 18 00 	cp.b	r10,r9
8000be62:	cf c1       	brne	8000be5a <strlen+0x6>
8000be64:	f0 0c 01 0c 	sub	r12,r8,r12
8000be68:	5e fc       	retal	r12
8000be6a:	d7 03       	nop

8000be6c <_write_r>:
8000be6c:	d4 21       	pushm	r4-r7,lr
8000be6e:	16 98       	mov	r8,r11
8000be70:	18 97       	mov	r7,r12
8000be72:	10 9c       	mov	r12,r8
8000be74:	30 08       	mov	r8,0
8000be76:	14 9b       	mov	r11,r10
8000be78:	e0 66 51 94 	mov	r6,20884
8000be7c:	12 9a       	mov	r10,r9
8000be7e:	8d 08       	st.w	r6[0x0],r8
8000be80:	fe b0 d1 8a 	rcall	80006194 <_write>
8000be84:	5b fc       	cp.w	r12,-1
8000be86:	c0 51       	brne	8000be90 <_write_r+0x24>
8000be88:	6c 08       	ld.w	r8,r6[0x0]
8000be8a:	58 08       	cp.w	r8,0
8000be8c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be90:	d8 22       	popm	r4-r7,pc
8000be92:	d7 03       	nop

8000be94 <_calloc_r>:
8000be94:	d4 21       	pushm	r4-r7,lr
8000be96:	f4 0b 02 4b 	mul	r11,r10,r11
8000be9a:	fe b0 db 6d 	rcall	80007574 <_malloc_r>
8000be9e:	18 97       	mov	r7,r12
8000bea0:	c2 30       	breq	8000bee6 <_calloc_r+0x52>
8000bea2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bea6:	e0 1a ff fc 	andl	r10,0xfffc
8000beaa:	20 4a       	sub	r10,4
8000beac:	e0 4a 00 24 	cp.w	r10,36
8000beb0:	e0 8b 00 18 	brhi	8000bee0 <_calloc_r+0x4c>
8000beb4:	18 98       	mov	r8,r12
8000beb6:	59 3a       	cp.w	r10,19
8000beb8:	e0 88 00 0f 	brls	8000bed6 <_calloc_r+0x42>
8000bebc:	30 09       	mov	r9,0
8000bebe:	10 a9       	st.w	r8++,r9
8000bec0:	10 a9       	st.w	r8++,r9
8000bec2:	59 ba       	cp.w	r10,27
8000bec4:	e0 88 00 09 	brls	8000bed6 <_calloc_r+0x42>
8000bec8:	10 a9       	st.w	r8++,r9
8000beca:	10 a9       	st.w	r8++,r9
8000becc:	e0 4a 00 24 	cp.w	r10,36
8000bed0:	c0 31       	brne	8000bed6 <_calloc_r+0x42>
8000bed2:	10 a9       	st.w	r8++,r9
8000bed4:	10 a9       	st.w	r8++,r9
8000bed6:	30 09       	mov	r9,0
8000bed8:	10 a9       	st.w	r8++,r9
8000beda:	91 19       	st.w	r8[0x4],r9
8000bedc:	91 09       	st.w	r8[0x0],r9
8000bede:	c0 48       	rjmp	8000bee6 <_calloc_r+0x52>
8000bee0:	30 0b       	mov	r11,0
8000bee2:	fe b0 de 1c 	rcall	80007b1a <memset>
8000bee6:	0e 9c       	mov	r12,r7
8000bee8:	d8 22       	popm	r4-r7,pc
8000beea:	d7 03       	nop

8000beec <_close_r>:
8000beec:	d4 21       	pushm	r4-r7,lr
8000beee:	30 08       	mov	r8,0
8000bef0:	18 97       	mov	r7,r12
8000bef2:	e0 66 51 94 	mov	r6,20884
8000bef6:	16 9c       	mov	r12,r11
8000bef8:	8d 08       	st.w	r6[0x0],r8
8000befa:	fe b0 df b5 	rcall	80007e64 <_close>
8000befe:	5b fc       	cp.w	r12,-1
8000bf00:	c0 51       	brne	8000bf0a <_close_r+0x1e>
8000bf02:	6c 08       	ld.w	r8,r6[0x0]
8000bf04:	58 08       	cp.w	r8,0
8000bf06:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf0a:	d8 22       	popm	r4-r7,pc

8000bf0c <_fclose_r>:
8000bf0c:	d4 21       	pushm	r4-r7,lr
8000bf0e:	18 96       	mov	r6,r12
8000bf10:	16 97       	mov	r7,r11
8000bf12:	58 0b       	cp.w	r11,0
8000bf14:	c0 31       	brne	8000bf1a <_fclose_r+0xe>
8000bf16:	16 95       	mov	r5,r11
8000bf18:	c5 38       	rjmp	8000bfbe <_fclose_r+0xb2>
8000bf1a:	fe b0 f8 a9 	rcall	8000b06c <__sfp_lock_acquire>
8000bf1e:	58 06       	cp.w	r6,0
8000bf20:	c0 70       	breq	8000bf2e <_fclose_r+0x22>
8000bf22:	6c 68       	ld.w	r8,r6[0x18]
8000bf24:	58 08       	cp.w	r8,0
8000bf26:	c0 41       	brne	8000bf2e <_fclose_r+0x22>
8000bf28:	0c 9c       	mov	r12,r6
8000bf2a:	fe b0 f8 f3 	rcall	8000b110 <__sinit>
8000bf2e:	fe c8 dc 9e 	sub	r8,pc,-9058
8000bf32:	10 37       	cp.w	r7,r8
8000bf34:	c0 31       	brne	8000bf3a <_fclose_r+0x2e>
8000bf36:	6c 07       	ld.w	r7,r6[0x0]
8000bf38:	c0 c8       	rjmp	8000bf50 <_fclose_r+0x44>
8000bf3a:	fe c8 dc 8a 	sub	r8,pc,-9078
8000bf3e:	10 37       	cp.w	r7,r8
8000bf40:	c0 31       	brne	8000bf46 <_fclose_r+0x3a>
8000bf42:	6c 17       	ld.w	r7,r6[0x4]
8000bf44:	c0 68       	rjmp	8000bf50 <_fclose_r+0x44>
8000bf46:	fe c8 dc 76 	sub	r8,pc,-9098
8000bf4a:	10 37       	cp.w	r7,r8
8000bf4c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bf50:	8e 69       	ld.sh	r9,r7[0xc]
8000bf52:	30 08       	mov	r8,0
8000bf54:	f0 09 19 00 	cp.h	r9,r8
8000bf58:	c0 51       	brne	8000bf62 <_fclose_r+0x56>
8000bf5a:	fe b0 f8 8a 	rcall	8000b06e <__sfp_lock_release>
8000bf5e:	30 05       	mov	r5,0
8000bf60:	c2 f8       	rjmp	8000bfbe <_fclose_r+0xb2>
8000bf62:	0e 9b       	mov	r11,r7
8000bf64:	0c 9c       	mov	r12,r6
8000bf66:	fe b0 f7 fd 	rcall	8000af60 <_fflush_r>
8000bf6a:	6e c8       	ld.w	r8,r7[0x30]
8000bf6c:	18 95       	mov	r5,r12
8000bf6e:	58 08       	cp.w	r8,0
8000bf70:	c0 60       	breq	8000bf7c <_fclose_r+0x70>
8000bf72:	6e 8b       	ld.w	r11,r7[0x20]
8000bf74:	0c 9c       	mov	r12,r6
8000bf76:	5d 18       	icall	r8
8000bf78:	f9 b5 05 ff 	movlt	r5,-1
8000bf7c:	8e 68       	ld.sh	r8,r7[0xc]
8000bf7e:	ed b8 00 07 	bld	r8,0x7
8000bf82:	c0 51       	brne	8000bf8c <_fclose_r+0x80>
8000bf84:	6e 4b       	ld.w	r11,r7[0x10]
8000bf86:	0c 9c       	mov	r12,r6
8000bf88:	fe b0 f9 5e 	rcall	8000b244 <_free_r>
8000bf8c:	6e db       	ld.w	r11,r7[0x34]
8000bf8e:	58 0b       	cp.w	r11,0
8000bf90:	c0 a0       	breq	8000bfa4 <_fclose_r+0x98>
8000bf92:	ee c8 ff bc 	sub	r8,r7,-68
8000bf96:	10 3b       	cp.w	r11,r8
8000bf98:	c0 40       	breq	8000bfa0 <_fclose_r+0x94>
8000bf9a:	0c 9c       	mov	r12,r6
8000bf9c:	fe b0 f9 54 	rcall	8000b244 <_free_r>
8000bfa0:	30 08       	mov	r8,0
8000bfa2:	8f d8       	st.w	r7[0x34],r8
8000bfa4:	6f 2b       	ld.w	r11,r7[0x48]
8000bfa6:	58 0b       	cp.w	r11,0
8000bfa8:	c0 70       	breq	8000bfb6 <_fclose_r+0xaa>
8000bfaa:	0c 9c       	mov	r12,r6
8000bfac:	fe b0 f9 4c 	rcall	8000b244 <_free_r>
8000bfb0:	30 08       	mov	r8,0
8000bfb2:	ef 48 00 48 	st.w	r7[72],r8
8000bfb6:	30 08       	mov	r8,0
8000bfb8:	ae 68       	st.h	r7[0xc],r8
8000bfba:	fe b0 f8 5a 	rcall	8000b06e <__sfp_lock_release>
8000bfbe:	0a 9c       	mov	r12,r5
8000bfc0:	d8 22       	popm	r4-r7,pc
8000bfc2:	d7 03       	nop

8000bfc4 <fclose>:
8000bfc4:	d4 01       	pushm	lr
8000bfc6:	e0 68 0a 48 	mov	r8,2632
8000bfca:	18 9b       	mov	r11,r12
8000bfcc:	70 0c       	ld.w	r12,r8[0x0]
8000bfce:	c9 ff       	rcall	8000bf0c <_fclose_r>
8000bfd0:	d8 02       	popm	pc
8000bfd2:	d7 03       	nop

8000bfd4 <_fstat_r>:
8000bfd4:	d4 21       	pushm	r4-r7,lr
8000bfd6:	16 98       	mov	r8,r11
8000bfd8:	18 97       	mov	r7,r12
8000bfda:	10 9c       	mov	r12,r8
8000bfdc:	30 08       	mov	r8,0
8000bfde:	e0 66 51 94 	mov	r6,20884
8000bfe2:	14 9b       	mov	r11,r10
8000bfe4:	8d 08       	st.w	r6[0x0],r8
8000bfe6:	fe b0 df 67 	rcall	80007eb4 <_fstat>
8000bfea:	5b fc       	cp.w	r12,-1
8000bfec:	c0 51       	brne	8000bff6 <_fstat_r+0x22>
8000bfee:	6c 08       	ld.w	r8,r6[0x0]
8000bff0:	58 08       	cp.w	r8,0
8000bff2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bff6:	d8 22       	popm	r4-r7,pc

8000bff8 <_lseek_r>:
8000bff8:	d4 21       	pushm	r4-r7,lr
8000bffa:	16 98       	mov	r8,r11
8000bffc:	18 97       	mov	r7,r12
8000bffe:	10 9c       	mov	r12,r8
8000c000:	30 08       	mov	r8,0
8000c002:	14 9b       	mov	r11,r10
8000c004:	e0 66 51 94 	mov	r6,20884
8000c008:	12 9a       	mov	r10,r9
8000c00a:	8d 08       	st.w	r6[0x0],r8
8000c00c:	fe b0 df 36 	rcall	80007e78 <_lseek>
8000c010:	5b fc       	cp.w	r12,-1
8000c012:	c0 51       	brne	8000c01c <_lseek_r+0x24>
8000c014:	6c 08       	ld.w	r8,r6[0x0]
8000c016:	58 08       	cp.w	r8,0
8000c018:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c01c:	d8 22       	popm	r4-r7,pc
8000c01e:	d7 03       	nop

8000c020 <_read_r>:
8000c020:	d4 21       	pushm	r4-r7,lr
8000c022:	16 98       	mov	r8,r11
8000c024:	18 97       	mov	r7,r12
8000c026:	10 9c       	mov	r12,r8
8000c028:	30 08       	mov	r8,0
8000c02a:	14 9b       	mov	r11,r10
8000c02c:	e0 66 51 94 	mov	r6,20884
8000c030:	12 9a       	mov	r10,r9
8000c032:	8d 08       	st.w	r6[0x0],r8
8000c034:	fe b0 d0 90 	rcall	80006154 <_read>
8000c038:	5b fc       	cp.w	r12,-1
8000c03a:	c0 51       	brne	8000c044 <_read_r+0x24>
8000c03c:	6c 08       	ld.w	r8,r6[0x0]
8000c03e:	58 08       	cp.w	r8,0
8000c040:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c044:	d8 22       	popm	r4-r7,pc
8000c046:	d7 03       	nop

8000c048 <__avr32_f64_mul>:
8000c048:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c04c:	e0 80 00 dc 	breq	8000c204 <__avr32_f64_mul_op1_zero>
8000c050:	d4 21       	pushm	r4-r7,lr
8000c052:	f7 e9 20 0e 	eor	lr,r11,r9
8000c056:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c05a:	30 15       	mov	r5,1
8000c05c:	c4 30       	breq	8000c0e2 <__avr32_f64_mul_op1_subnormal>
8000c05e:	ab 6b       	lsl	r11,0xa
8000c060:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c064:	ab 6a       	lsl	r10,0xa
8000c066:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c06a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c06e:	c5 c0       	breq	8000c126 <__avr32_f64_mul_op2_subnormal>
8000c070:	a1 78       	lsl	r8,0x1
8000c072:	5c f9       	rol	r9
8000c074:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c078:	e0 47 07 ff 	cp.w	r7,2047
8000c07c:	c7 70       	breq	8000c16a <__avr32_f64_mul_op_nan_or_inf>
8000c07e:	e0 46 07 ff 	cp.w	r6,2047
8000c082:	c7 40       	breq	8000c16a <__avr32_f64_mul_op_nan_or_inf>
8000c084:	ee 06 00 0c 	add	r12,r7,r6
8000c088:	e0 2c 03 fe 	sub	r12,1022
8000c08c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c090:	f4 09 07 44 	macu.d	r4,r10,r9
8000c094:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c098:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c09c:	08 07       	add	r7,r4
8000c09e:	f4 05 00 4a 	adc	r10,r10,r5
8000c0a2:	5c 0b       	acr	r11
8000c0a4:	ed bb 00 14 	bld	r11,0x14
8000c0a8:	c0 50       	breq	8000c0b2 <__avr32_f64_mul+0x6a>
8000c0aa:	a1 77       	lsl	r7,0x1
8000c0ac:	5c fa       	rol	r10
8000c0ae:	5c fb       	rol	r11
8000c0b0:	20 1c       	sub	r12,1
8000c0b2:	58 0c       	cp.w	r12,0
8000c0b4:	e0 8a 00 6f 	brle	8000c192 <__avr32_f64_mul_res_subnormal>
8000c0b8:	e0 4c 07 ff 	cp.w	r12,2047
8000c0bc:	e0 84 00 9c 	brge	8000c1f4 <__avr32_f64_mul_res_inf>
8000c0c0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c0c4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c0c8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c0cc:	ee 17 80 00 	eorh	r7,0x8000
8000c0d0:	f1 b7 04 20 	satu	r7,0x1
8000c0d4:	0e 0a       	add	r10,r7
8000c0d6:	5c 0b       	acr	r11
8000c0d8:	ed be 00 1f 	bld	lr,0x1f
8000c0dc:	ef bb 00 1f 	bst	r11,0x1f
8000c0e0:	d8 22       	popm	r4-r7,pc

8000c0e2 <__avr32_f64_mul_op1_subnormal>:
8000c0e2:	e4 1b 00 0f 	andh	r11,0xf
8000c0e6:	f4 0c 12 00 	clz	r12,r10
8000c0ea:	f6 06 12 00 	clz	r6,r11
8000c0ee:	f7 bc 03 e1 	sublo	r12,-31
8000c0f2:	f8 06 17 30 	movlo	r6,r12
8000c0f6:	f7 b6 02 01 	subhs	r6,1
8000c0fa:	e0 46 00 20 	cp.w	r6,32
8000c0fe:	c0 d4       	brge	8000c118 <__avr32_f64_mul_op1_subnormal+0x36>
8000c100:	ec 0c 11 20 	rsub	r12,r6,32
8000c104:	f6 06 09 4b 	lsl	r11,r11,r6
8000c108:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c10c:	18 4b       	or	r11,r12
8000c10e:	f4 06 09 4a 	lsl	r10,r10,r6
8000c112:	20 b6       	sub	r6,11
8000c114:	0c 17       	sub	r7,r6
8000c116:	ca ab       	rjmp	8000c06a <__avr32_f64_mul+0x22>
8000c118:	f4 06 09 4b 	lsl	r11,r10,r6
8000c11c:	c6 40       	breq	8000c1e4 <__avr32_f64_mul_res_zero>
8000c11e:	30 0a       	mov	r10,0
8000c120:	20 b6       	sub	r6,11
8000c122:	0c 17       	sub	r7,r6
8000c124:	ca 3b       	rjmp	8000c06a <__avr32_f64_mul+0x22>

8000c126 <__avr32_f64_mul_op2_subnormal>:
8000c126:	e4 19 00 0f 	andh	r9,0xf
8000c12a:	f0 0c 12 00 	clz	r12,r8
8000c12e:	f2 05 12 00 	clz	r5,r9
8000c132:	f7 bc 03 ea 	sublo	r12,-22
8000c136:	f8 05 17 30 	movlo	r5,r12
8000c13a:	f7 b5 02 0a 	subhs	r5,10
8000c13e:	e0 45 00 20 	cp.w	r5,32
8000c142:	c0 d4       	brge	8000c15c <__avr32_f64_mul_op2_subnormal+0x36>
8000c144:	ea 0c 11 20 	rsub	r12,r5,32
8000c148:	f2 05 09 49 	lsl	r9,r9,r5
8000c14c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c150:	18 49       	or	r9,r12
8000c152:	f0 05 09 48 	lsl	r8,r8,r5
8000c156:	20 25       	sub	r5,2
8000c158:	0a 16       	sub	r6,r5
8000c15a:	c8 fb       	rjmp	8000c078 <__avr32_f64_mul+0x30>
8000c15c:	f0 05 09 49 	lsl	r9,r8,r5
8000c160:	c4 20       	breq	8000c1e4 <__avr32_f64_mul_res_zero>
8000c162:	30 08       	mov	r8,0
8000c164:	20 25       	sub	r5,2
8000c166:	0a 16       	sub	r6,r5
8000c168:	c8 8b       	rjmp	8000c078 <__avr32_f64_mul+0x30>

8000c16a <__avr32_f64_mul_op_nan_or_inf>:
8000c16a:	e4 19 00 0f 	andh	r9,0xf
8000c16e:	e4 1b 00 0f 	andh	r11,0xf
8000c172:	14 4b       	or	r11,r10
8000c174:	10 49       	or	r9,r8
8000c176:	e0 47 07 ff 	cp.w	r7,2047
8000c17a:	c0 91       	brne	8000c18c <__avr32_f64_mul_op1_not_naninf>
8000c17c:	58 0b       	cp.w	r11,0
8000c17e:	c3 81       	brne	8000c1ee <__avr32_f64_mul_res_nan>
8000c180:	e0 46 07 ff 	cp.w	r6,2047
8000c184:	c3 81       	brne	8000c1f4 <__avr32_f64_mul_res_inf>
8000c186:	58 09       	cp.w	r9,0
8000c188:	c3 60       	breq	8000c1f4 <__avr32_f64_mul_res_inf>
8000c18a:	c3 28       	rjmp	8000c1ee <__avr32_f64_mul_res_nan>

8000c18c <__avr32_f64_mul_op1_not_naninf>:
8000c18c:	58 09       	cp.w	r9,0
8000c18e:	c3 30       	breq	8000c1f4 <__avr32_f64_mul_res_inf>
8000c190:	c2 f8       	rjmp	8000c1ee <__avr32_f64_mul_res_nan>

8000c192 <__avr32_f64_mul_res_subnormal>:
8000c192:	5c 3c       	neg	r12
8000c194:	2f fc       	sub	r12,-1
8000c196:	f1 bc 04 c0 	satu	r12,0x6
8000c19a:	e0 4c 00 20 	cp.w	r12,32
8000c19e:	c1 14       	brge	8000c1c0 <__avr32_f64_mul_res_subnormal+0x2e>
8000c1a0:	f8 08 11 20 	rsub	r8,r12,32
8000c1a4:	0e 46       	or	r6,r7
8000c1a6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c1aa:	f4 08 09 49 	lsl	r9,r10,r8
8000c1ae:	12 47       	or	r7,r9
8000c1b0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1b4:	f6 08 09 49 	lsl	r9,r11,r8
8000c1b8:	12 4a       	or	r10,r9
8000c1ba:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c1be:	c8 3b       	rjmp	8000c0c4 <__avr32_f64_mul+0x7c>
8000c1c0:	f8 08 11 20 	rsub	r8,r12,32
8000c1c4:	f9 b9 00 00 	moveq	r9,0
8000c1c8:	c0 30       	breq	8000c1ce <__avr32_f64_mul_res_subnormal+0x3c>
8000c1ca:	f6 08 09 49 	lsl	r9,r11,r8
8000c1ce:	0e 46       	or	r6,r7
8000c1d0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c1d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1d8:	f3 ea 10 07 	or	r7,r9,r10
8000c1dc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c1e0:	30 0b       	mov	r11,0
8000c1e2:	c7 1b       	rjmp	8000c0c4 <__avr32_f64_mul+0x7c>

8000c1e4 <__avr32_f64_mul_res_zero>:
8000c1e4:	1c 9b       	mov	r11,lr
8000c1e6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c1ea:	30 0a       	mov	r10,0
8000c1ec:	d8 22       	popm	r4-r7,pc

8000c1ee <__avr32_f64_mul_res_nan>:
8000c1ee:	3f fb       	mov	r11,-1
8000c1f0:	3f fa       	mov	r10,-1
8000c1f2:	d8 22       	popm	r4-r7,pc

8000c1f4 <__avr32_f64_mul_res_inf>:
8000c1f4:	f0 6b 00 00 	mov	r11,-1048576
8000c1f8:	ed be 00 1f 	bld	lr,0x1f
8000c1fc:	ef bb 00 1f 	bst	r11,0x1f
8000c200:	30 0a       	mov	r10,0
8000c202:	d8 22       	popm	r4-r7,pc

8000c204 <__avr32_f64_mul_op1_zero>:
8000c204:	f7 e9 20 0b 	eor	r11,r11,r9
8000c208:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c20c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c210:	e0 4c 07 ff 	cp.w	r12,2047
8000c214:	5e 1c       	retne	r12
8000c216:	3f fa       	mov	r10,-1
8000c218:	3f fb       	mov	r11,-1
8000c21a:	5e fc       	retal	r12

8000c21c <__avr32_f64_sub_from_add>:
8000c21c:	ee 19 80 00 	eorh	r9,0x8000

8000c220 <__avr32_f64_sub>:
8000c220:	f7 e9 20 0c 	eor	r12,r11,r9
8000c224:	e0 86 00 ca 	brmi	8000c3b8 <__avr32_f64_add_from_sub>
8000c228:	eb cd 40 e0 	pushm	r5-r7,lr
8000c22c:	16 9c       	mov	r12,r11
8000c22e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c232:	bf db       	cbr	r11,0x1f
8000c234:	bf d9       	cbr	r9,0x1f
8000c236:	10 3a       	cp.w	r10,r8
8000c238:	f2 0b 13 00 	cpc	r11,r9
8000c23c:	c0 92       	brcc	8000c24e <__avr32_f64_sub+0x2e>
8000c23e:	16 97       	mov	r7,r11
8000c240:	12 9b       	mov	r11,r9
8000c242:	0e 99       	mov	r9,r7
8000c244:	14 97       	mov	r7,r10
8000c246:	10 9a       	mov	r10,r8
8000c248:	0e 98       	mov	r8,r7
8000c24a:	ee 1c 80 00 	eorh	r12,0x8000
8000c24e:	f6 07 16 14 	lsr	r7,r11,0x14
8000c252:	ab 7b       	lsl	r11,0xb
8000c254:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c258:	ab 7a       	lsl	r10,0xb
8000c25a:	bf bb       	sbr	r11,0x1f
8000c25c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c260:	c4 40       	breq	8000c2e8 <__avr32_f64_sub_opL_subnormal>
8000c262:	ab 79       	lsl	r9,0xb
8000c264:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c268:	ab 78       	lsl	r8,0xb
8000c26a:	bf b9       	sbr	r9,0x1f

8000c26c <__avr32_f64_sub_opL_subnormal_done>:
8000c26c:	e0 47 07 ff 	cp.w	r7,2047
8000c270:	c4 f0       	breq	8000c30e <__avr32_f64_sub_opH_nan_or_inf>
8000c272:	0e 26       	rsub	r6,r7
8000c274:	c1 20       	breq	8000c298 <__avr32_f64_sub_shift_done>
8000c276:	ec 05 11 20 	rsub	r5,r6,32
8000c27a:	e0 46 00 20 	cp.w	r6,32
8000c27e:	c7 c2       	brcc	8000c376 <__avr32_f64_sub_longshift>
8000c280:	f0 05 09 4e 	lsl	lr,r8,r5
8000c284:	f2 05 09 45 	lsl	r5,r9,r5
8000c288:	f0 06 0a 48 	lsr	r8,r8,r6
8000c28c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c290:	0a 48       	or	r8,r5
8000c292:	58 0e       	cp.w	lr,0
8000c294:	5f 1e       	srne	lr
8000c296:	1c 48       	or	r8,lr

8000c298 <__avr32_f64_sub_shift_done>:
8000c298:	10 1a       	sub	r10,r8
8000c29a:	f6 09 01 4b 	sbc	r11,r11,r9
8000c29e:	f6 06 12 00 	clz	r6,r11
8000c2a2:	c0 e0       	breq	8000c2be <__avr32_f64_sub_longnormalize_done>
8000c2a4:	c7 83       	brcs	8000c394 <__avr32_f64_sub_longnormalize>
8000c2a6:	ec 0e 11 20 	rsub	lr,r6,32
8000c2aa:	f6 06 09 4b 	lsl	r11,r11,r6
8000c2ae:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c2b2:	1c 4b       	or	r11,lr
8000c2b4:	f4 06 09 4a 	lsl	r10,r10,r6
8000c2b8:	0c 17       	sub	r7,r6
8000c2ba:	e0 8a 00 39 	brle	8000c32c <__avr32_f64_sub_subnormal_result>

8000c2be <__avr32_f64_sub_longnormalize_done>:
8000c2be:	f4 09 15 15 	lsl	r9,r10,0x15
8000c2c2:	ab 9a       	lsr	r10,0xb
8000c2c4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c2c8:	ab 9b       	lsr	r11,0xb
8000c2ca:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2ce:	18 4b       	or	r11,r12

8000c2d0 <__avr32_f64_sub_round>:
8000c2d0:	fc 17 80 00 	movh	r7,0x8000
8000c2d4:	ed ba 00 00 	bld	r10,0x0
8000c2d8:	f7 b7 01 ff 	subne	r7,-1
8000c2dc:	0e 39       	cp.w	r9,r7
8000c2de:	5f 29       	srhs	r9
8000c2e0:	12 0a       	add	r10,r9
8000c2e2:	5c 0b       	acr	r11
8000c2e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e8 <__avr32_f64_sub_opL_subnormal>:
8000c2e8:	ab 79       	lsl	r9,0xb
8000c2ea:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c2ee:	ab 78       	lsl	r8,0xb
8000c2f0:	f3 e8 10 0e 	or	lr,r9,r8
8000c2f4:	f9 b6 01 01 	movne	r6,1
8000c2f8:	ee 0e 11 00 	rsub	lr,r7,0
8000c2fc:	f9 b7 00 01 	moveq	r7,1
8000c300:	ef bb 00 1f 	bst	r11,0x1f
8000c304:	f7 ea 10 0e 	or	lr,r11,r10
8000c308:	f9 b7 00 00 	moveq	r7,0
8000c30c:	cb 0b       	rjmp	8000c26c <__avr32_f64_sub_opL_subnormal_done>

8000c30e <__avr32_f64_sub_opH_nan_or_inf>:
8000c30e:	bf db       	cbr	r11,0x1f
8000c310:	f7 ea 10 0e 	or	lr,r11,r10
8000c314:	c0 81       	brne	8000c324 <__avr32_f64_sub_return_nan>
8000c316:	e0 46 07 ff 	cp.w	r6,2047
8000c31a:	c0 50       	breq	8000c324 <__avr32_f64_sub_return_nan>
8000c31c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c320:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c324 <__avr32_f64_sub_return_nan>:
8000c324:	3f fa       	mov	r10,-1
8000c326:	3f fb       	mov	r11,-1
8000c328:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c32c <__avr32_f64_sub_subnormal_result>:
8000c32c:	5c 37       	neg	r7
8000c32e:	2f f7       	sub	r7,-1
8000c330:	f1 b7 04 c0 	satu	r7,0x6
8000c334:	e0 47 00 20 	cp.w	r7,32
8000c338:	c1 14       	brge	8000c35a <__avr32_f64_sub_subnormal_result+0x2e>
8000c33a:	ee 08 11 20 	rsub	r8,r7,32
8000c33e:	f4 08 09 49 	lsl	r9,r10,r8
8000c342:	5f 16       	srne	r6
8000c344:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c348:	0c 4a       	or	r10,r6
8000c34a:	f6 08 09 49 	lsl	r9,r11,r8
8000c34e:	f5 e9 10 0a 	or	r10,r10,r9
8000c352:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c356:	30 07       	mov	r7,0
8000c358:	cb 3b       	rjmp	8000c2be <__avr32_f64_sub_longnormalize_done>
8000c35a:	ee 08 11 40 	rsub	r8,r7,64
8000c35e:	f6 08 09 49 	lsl	r9,r11,r8
8000c362:	14 49       	or	r9,r10
8000c364:	5f 16       	srne	r6
8000c366:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c36a:	0c 4a       	or	r10,r6
8000c36c:	30 0b       	mov	r11,0
8000c36e:	30 07       	mov	r7,0
8000c370:	ca 7b       	rjmp	8000c2be <__avr32_f64_sub_longnormalize_done>
8000c372:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c376 <__avr32_f64_sub_longshift>:
8000c376:	f1 b6 04 c0 	satu	r6,0x6
8000c37a:	f0 0e 17 00 	moveq	lr,r8
8000c37e:	c0 40       	breq	8000c386 <__avr32_f64_sub_longshift+0x10>
8000c380:	f2 05 09 4e 	lsl	lr,r9,r5
8000c384:	10 4e       	or	lr,r8
8000c386:	f2 06 0a 48 	lsr	r8,r9,r6
8000c38a:	30 09       	mov	r9,0
8000c38c:	58 0e       	cp.w	lr,0
8000c38e:	5f 1e       	srne	lr
8000c390:	1c 48       	or	r8,lr
8000c392:	c8 3b       	rjmp	8000c298 <__avr32_f64_sub_shift_done>

8000c394 <__avr32_f64_sub_longnormalize>:
8000c394:	f4 06 12 00 	clz	r6,r10
8000c398:	f9 b7 03 00 	movlo	r7,0
8000c39c:	f9 b6 03 00 	movlo	r6,0
8000c3a0:	f9 bc 03 00 	movlo	r12,0
8000c3a4:	f7 b6 02 e0 	subhs	r6,-32
8000c3a8:	f4 06 09 4b 	lsl	r11,r10,r6
8000c3ac:	30 0a       	mov	r10,0
8000c3ae:	0c 17       	sub	r7,r6
8000c3b0:	fe 9a ff be 	brle	8000c32c <__avr32_f64_sub_subnormal_result>
8000c3b4:	c8 5b       	rjmp	8000c2be <__avr32_f64_sub_longnormalize_done>
8000c3b6:	d7 03       	nop

8000c3b8 <__avr32_f64_add_from_sub>:
8000c3b8:	ee 19 80 00 	eorh	r9,0x8000

8000c3bc <__avr32_f64_add>:
8000c3bc:	f7 e9 20 0c 	eor	r12,r11,r9
8000c3c0:	fe 96 ff 2e 	brmi	8000c21c <__avr32_f64_sub_from_add>
8000c3c4:	eb cd 40 e0 	pushm	r5-r7,lr
8000c3c8:	16 9c       	mov	r12,r11
8000c3ca:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c3ce:	bf db       	cbr	r11,0x1f
8000c3d0:	bf d9       	cbr	r9,0x1f
8000c3d2:	12 3b       	cp.w	r11,r9
8000c3d4:	c0 72       	brcc	8000c3e2 <__avr32_f64_add+0x26>
8000c3d6:	16 97       	mov	r7,r11
8000c3d8:	12 9b       	mov	r11,r9
8000c3da:	0e 99       	mov	r9,r7
8000c3dc:	14 97       	mov	r7,r10
8000c3de:	10 9a       	mov	r10,r8
8000c3e0:	0e 98       	mov	r8,r7
8000c3e2:	30 0e       	mov	lr,0
8000c3e4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c3e8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c3ec:	b5 ab       	sbr	r11,0x14
8000c3ee:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c3f2:	c6 20       	breq	8000c4b6 <__avr32_f64_add_op2_subnormal>
8000c3f4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c3f8:	b5 a9       	sbr	r9,0x14
8000c3fa:	e0 47 07 ff 	cp.w	r7,2047
8000c3fe:	c2 80       	breq	8000c44e <__avr32_f64_add_opH_nan_or_inf>
8000c400:	0e 26       	rsub	r6,r7
8000c402:	c1 20       	breq	8000c426 <__avr32_f64_add_shift_done>
8000c404:	e0 46 00 36 	cp.w	r6,54
8000c408:	c1 52       	brcc	8000c432 <__avr32_f64_add_res_of_done>
8000c40a:	ec 05 11 20 	rsub	r5,r6,32
8000c40e:	e0 46 00 20 	cp.w	r6,32
8000c412:	c3 52       	brcc	8000c47c <__avr32_f64_add_longshift>
8000c414:	f0 05 09 4e 	lsl	lr,r8,r5
8000c418:	f2 05 09 45 	lsl	r5,r9,r5
8000c41c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c420:	f2 06 0a 49 	lsr	r9,r9,r6
8000c424:	0a 48       	or	r8,r5

8000c426 <__avr32_f64_add_shift_done>:
8000c426:	10 0a       	add	r10,r8
8000c428:	f6 09 00 4b 	adc	r11,r11,r9
8000c42c:	ed bb 00 15 	bld	r11,0x15
8000c430:	c3 40       	breq	8000c498 <__avr32_f64_add_res_of>

8000c432 <__avr32_f64_add_res_of_done>:
8000c432:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c436:	18 4b       	or	r11,r12

8000c438 <__avr32_f64_add_round>:
8000c438:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c43c:	18 4e       	or	lr,r12
8000c43e:	ee 1e 80 00 	eorh	lr,0x8000
8000c442:	f1 be 04 20 	satu	lr,0x1
8000c446:	1c 0a       	add	r10,lr
8000c448:	5c 0b       	acr	r11
8000c44a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c44e <__avr32_f64_add_opH_nan_or_inf>:
8000c44e:	b5 cb       	cbr	r11,0x14
8000c450:	f7 ea 10 0e 	or	lr,r11,r10
8000c454:	c1 01       	brne	8000c474 <__avr32_f64_add_return_nan>
8000c456:	e0 46 07 ff 	cp.w	r6,2047
8000c45a:	c0 30       	breq	8000c460 <__avr32_f64_add_opL_nan_or_inf>
8000c45c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c460 <__avr32_f64_add_opL_nan_or_inf>:
8000c460:	b5 c9       	cbr	r9,0x14
8000c462:	f3 e8 10 0e 	or	lr,r9,r8
8000c466:	c0 71       	brne	8000c474 <__avr32_f64_add_return_nan>
8000c468:	30 0a       	mov	r10,0
8000c46a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c46e:	18 4b       	or	r11,r12
8000c470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c474 <__avr32_f64_add_return_nan>:
8000c474:	3f fa       	mov	r10,-1
8000c476:	3f fb       	mov	r11,-1
8000c478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c47c <__avr32_f64_add_longshift>:
8000c47c:	f1 b6 04 c0 	satu	r6,0x6
8000c480:	f0 0e 17 00 	moveq	lr,r8
8000c484:	c0 60       	breq	8000c490 <__avr32_f64_add_longshift+0x14>
8000c486:	f2 05 09 4e 	lsl	lr,r9,r5
8000c48a:	58 08       	cp.w	r8,0
8000c48c:	5f 18       	srne	r8
8000c48e:	10 4e       	or	lr,r8
8000c490:	f2 06 0a 48 	lsr	r8,r9,r6
8000c494:	30 09       	mov	r9,0
8000c496:	cc 8b       	rjmp	8000c426 <__avr32_f64_add_shift_done>

8000c498 <__avr32_f64_add_res_of>:
8000c498:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c49c:	a1 9b       	lsr	r11,0x1
8000c49e:	5d 0a       	ror	r10
8000c4a0:	5d 0e       	ror	lr
8000c4a2:	2f f7       	sub	r7,-1
8000c4a4:	e0 47 07 ff 	cp.w	r7,2047
8000c4a8:	f9 ba 00 00 	moveq	r10,0
8000c4ac:	f9 bb 00 00 	moveq	r11,0
8000c4b0:	f9 be 00 00 	moveq	lr,0
8000c4b4:	cb fb       	rjmp	8000c432 <__avr32_f64_add_res_of_done>

8000c4b6 <__avr32_f64_add_op2_subnormal>:
8000c4b6:	30 16       	mov	r6,1
8000c4b8:	58 07       	cp.w	r7,0
8000c4ba:	ca 01       	brne	8000c3fa <__avr32_f64_add+0x3e>
8000c4bc:	b5 cb       	cbr	r11,0x14
8000c4be:	10 0a       	add	r10,r8
8000c4c0:	f6 09 00 4b 	adc	r11,r11,r9
8000c4c4:	18 4b       	or	r11,r12
8000c4c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c4ca:	d7 03       	nop

8000c4cc <__avr32_f64_to_u32>:
8000c4cc:	58 0b       	cp.w	r11,0
8000c4ce:	5e 6d       	retmi	0

8000c4d0 <__avr32_f64_to_s32>:
8000c4d0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c4d4:	b5 9c       	lsr	r12,0x15
8000c4d6:	e0 2c 03 ff 	sub	r12,1023
8000c4da:	5e 3d       	retlo	0
8000c4dc:	f8 0c 11 1f 	rsub	r12,r12,31
8000c4e0:	16 99       	mov	r9,r11
8000c4e2:	ab 7b       	lsl	r11,0xb
8000c4e4:	bf bb       	sbr	r11,0x1f
8000c4e6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c4ea:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c4ee:	a1 79       	lsl	r9,0x1
8000c4f0:	5e 2b       	reths	r11
8000c4f2:	5c 3b       	neg	r11
8000c4f4:	5e fb       	retal	r11

8000c4f6 <__avr32_u32_to_f64>:
8000c4f6:	f8 cb 00 00 	sub	r11,r12,0
8000c4fa:	30 0c       	mov	r12,0
8000c4fc:	c0 38       	rjmp	8000c502 <__avr32_s32_to_f64+0x4>

8000c4fe <__avr32_s32_to_f64>:
8000c4fe:	18 9b       	mov	r11,r12
8000c500:	5c 4b       	abs	r11
8000c502:	30 0a       	mov	r10,0
8000c504:	5e 0b       	reteq	r11
8000c506:	d4 01       	pushm	lr
8000c508:	e0 69 04 1e 	mov	r9,1054
8000c50c:	f6 08 12 00 	clz	r8,r11
8000c510:	c1 70       	breq	8000c53e <__avr32_s32_to_f64+0x40>
8000c512:	c0 c3       	brcs	8000c52a <__avr32_s32_to_f64+0x2c>
8000c514:	f0 0e 11 20 	rsub	lr,r8,32
8000c518:	f6 08 09 4b 	lsl	r11,r11,r8
8000c51c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c520:	1c 4b       	or	r11,lr
8000c522:	f4 08 09 4a 	lsl	r10,r10,r8
8000c526:	10 19       	sub	r9,r8
8000c528:	c0 b8       	rjmp	8000c53e <__avr32_s32_to_f64+0x40>
8000c52a:	f4 08 12 00 	clz	r8,r10
8000c52e:	f9 b8 03 00 	movlo	r8,0
8000c532:	f7 b8 02 e0 	subhs	r8,-32
8000c536:	f4 08 09 4b 	lsl	r11,r10,r8
8000c53a:	30 0a       	mov	r10,0
8000c53c:	10 19       	sub	r9,r8
8000c53e:	58 09       	cp.w	r9,0
8000c540:	e0 89 00 30 	brgt	8000c5a0 <__avr32_s32_to_f64+0xa2>
8000c544:	5c 39       	neg	r9
8000c546:	2f f9       	sub	r9,-1
8000c548:	e0 49 00 36 	cp.w	r9,54
8000c54c:	c0 43       	brcs	8000c554 <__avr32_s32_to_f64+0x56>
8000c54e:	30 0b       	mov	r11,0
8000c550:	30 0a       	mov	r10,0
8000c552:	c2 68       	rjmp	8000c59e <__avr32_s32_to_f64+0xa0>
8000c554:	2f 69       	sub	r9,-10
8000c556:	f2 08 11 20 	rsub	r8,r9,32
8000c55a:	e0 49 00 20 	cp.w	r9,32
8000c55e:	c0 b2       	brcc	8000c574 <__avr32_s32_to_f64+0x76>
8000c560:	f4 08 09 4e 	lsl	lr,r10,r8
8000c564:	f6 08 09 48 	lsl	r8,r11,r8
8000c568:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c56c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c570:	10 4b       	or	r11,r8
8000c572:	c0 88       	rjmp	8000c582 <__avr32_s32_to_f64+0x84>
8000c574:	f6 08 09 4e 	lsl	lr,r11,r8
8000c578:	14 4e       	or	lr,r10
8000c57a:	16 9a       	mov	r10,r11
8000c57c:	30 0b       	mov	r11,0
8000c57e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c582:	ed ba 00 00 	bld	r10,0x0
8000c586:	c0 92       	brcc	8000c598 <__avr32_s32_to_f64+0x9a>
8000c588:	1c 7e       	tst	lr,lr
8000c58a:	c0 41       	brne	8000c592 <__avr32_s32_to_f64+0x94>
8000c58c:	ed ba 00 01 	bld	r10,0x1
8000c590:	c0 42       	brcc	8000c598 <__avr32_s32_to_f64+0x9a>
8000c592:	2f fa       	sub	r10,-1
8000c594:	f7 bb 02 ff 	subhs	r11,-1
8000c598:	5c fc       	rol	r12
8000c59a:	5d 0b       	ror	r11
8000c59c:	5d 0a       	ror	r10
8000c59e:	d8 02       	popm	pc
8000c5a0:	e0 68 03 ff 	mov	r8,1023
8000c5a4:	ed ba 00 0b 	bld	r10,0xb
8000c5a8:	f7 b8 00 ff 	subeq	r8,-1
8000c5ac:	10 0a       	add	r10,r8
8000c5ae:	5c 0b       	acr	r11
8000c5b0:	f7 b9 03 fe 	sublo	r9,-2
8000c5b4:	e0 49 07 ff 	cp.w	r9,2047
8000c5b8:	c0 55       	brlt	8000c5c2 <__avr32_s32_to_f64+0xc4>
8000c5ba:	30 0a       	mov	r10,0
8000c5bc:	fc 1b ff e0 	movh	r11,0xffe0
8000c5c0:	c0 c8       	rjmp	8000c5d8 <__floatsidf_return_op1>
8000c5c2:	ed bb 00 1f 	bld	r11,0x1f
8000c5c6:	f7 b9 01 01 	subne	r9,1
8000c5ca:	ab 9a       	lsr	r10,0xb
8000c5cc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c5d0:	a1 7b       	lsl	r11,0x1
8000c5d2:	ab 9b       	lsr	r11,0xb
8000c5d4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c5d8 <__floatsidf_return_op1>:
8000c5d8:	a1 7c       	lsl	r12,0x1
8000c5da:	5d 0b       	ror	r11
8000c5dc:	d8 02       	popm	pc

8000c5de <__avr32_f64_cmp_eq>:
8000c5de:	10 3a       	cp.w	r10,r8
8000c5e0:	f2 0b 13 00 	cpc	r11,r9
8000c5e4:	c0 80       	breq	8000c5f4 <__avr32_f64_cmp_eq+0x16>
8000c5e6:	a1 7b       	lsl	r11,0x1
8000c5e8:	a1 79       	lsl	r9,0x1
8000c5ea:	14 4b       	or	r11,r10
8000c5ec:	12 4b       	or	r11,r9
8000c5ee:	10 4b       	or	r11,r8
8000c5f0:	5e 0f       	reteq	1
8000c5f2:	5e fd       	retal	0
8000c5f4:	a1 7b       	lsl	r11,0x1
8000c5f6:	fc 1c ff e0 	movh	r12,0xffe0
8000c5fa:	58 0a       	cp.w	r10,0
8000c5fc:	f8 0b 13 00 	cpc	r11,r12
8000c600:	5e 8f       	retls	1
8000c602:	5e fd       	retal	0

8000c604 <__avr32_f64_cmp_ge>:
8000c604:	1a de       	st.w	--sp,lr
8000c606:	1a d7       	st.w	--sp,r7
8000c608:	a1 7b       	lsl	r11,0x1
8000c60a:	5f 3c       	srlo	r12
8000c60c:	a1 79       	lsl	r9,0x1
8000c60e:	5f 37       	srlo	r7
8000c610:	5c fc       	rol	r12
8000c612:	fc 1e ff e0 	movh	lr,0xffe0
8000c616:	58 0a       	cp.w	r10,0
8000c618:	fc 0b 13 00 	cpc	r11,lr
8000c61c:	e0 8b 00 1d 	brhi	8000c656 <__avr32_f64_cmp_ge+0x52>
8000c620:	58 08       	cp.w	r8,0
8000c622:	fc 09 13 00 	cpc	r9,lr
8000c626:	e0 8b 00 18 	brhi	8000c656 <__avr32_f64_cmp_ge+0x52>
8000c62a:	58 0b       	cp.w	r11,0
8000c62c:	f5 ba 00 00 	subfeq	r10,0
8000c630:	c1 50       	breq	8000c65a <__avr32_f64_cmp_ge+0x56>
8000c632:	1b 07       	ld.w	r7,sp++
8000c634:	1b 0e       	ld.w	lr,sp++
8000c636:	58 3c       	cp.w	r12,3
8000c638:	c0 a0       	breq	8000c64c <__avr32_f64_cmp_ge+0x48>
8000c63a:	58 1c       	cp.w	r12,1
8000c63c:	c0 33       	brcs	8000c642 <__avr32_f64_cmp_ge+0x3e>
8000c63e:	5e 0f       	reteq	1
8000c640:	5e 1d       	retne	0
8000c642:	10 3a       	cp.w	r10,r8
8000c644:	f2 0b 13 00 	cpc	r11,r9
8000c648:	5e 2f       	reths	1
8000c64a:	5e 3d       	retlo	0
8000c64c:	14 38       	cp.w	r8,r10
8000c64e:	f6 09 13 00 	cpc	r9,r11
8000c652:	5e 2f       	reths	1
8000c654:	5e 3d       	retlo	0
8000c656:	1b 07       	ld.w	r7,sp++
8000c658:	d8 0a       	popm	pc,r12=0
8000c65a:	58 17       	cp.w	r7,1
8000c65c:	5f 0c       	sreq	r12
8000c65e:	58 09       	cp.w	r9,0
8000c660:	f5 b8 00 00 	subfeq	r8,0
8000c664:	1b 07       	ld.w	r7,sp++
8000c666:	1b 0e       	ld.w	lr,sp++
8000c668:	5e 0f       	reteq	1
8000c66a:	5e fc       	retal	r12

8000c66c <__avr32_f64_cmp_lt>:
8000c66c:	1a de       	st.w	--sp,lr
8000c66e:	1a d7       	st.w	--sp,r7
8000c670:	a1 7b       	lsl	r11,0x1
8000c672:	5f 3c       	srlo	r12
8000c674:	a1 79       	lsl	r9,0x1
8000c676:	5f 37       	srlo	r7
8000c678:	5c fc       	rol	r12
8000c67a:	fc 1e ff e0 	movh	lr,0xffe0
8000c67e:	58 0a       	cp.w	r10,0
8000c680:	fc 0b 13 00 	cpc	r11,lr
8000c684:	e0 8b 00 1d 	brhi	8000c6be <__avr32_f64_cmp_lt+0x52>
8000c688:	58 08       	cp.w	r8,0
8000c68a:	fc 09 13 00 	cpc	r9,lr
8000c68e:	e0 8b 00 18 	brhi	8000c6be <__avr32_f64_cmp_lt+0x52>
8000c692:	58 0b       	cp.w	r11,0
8000c694:	f5 ba 00 00 	subfeq	r10,0
8000c698:	c1 50       	breq	8000c6c2 <__avr32_f64_cmp_lt+0x56>
8000c69a:	1b 07       	ld.w	r7,sp++
8000c69c:	1b 0e       	ld.w	lr,sp++
8000c69e:	58 3c       	cp.w	r12,3
8000c6a0:	c0 a0       	breq	8000c6b4 <__avr32_f64_cmp_lt+0x48>
8000c6a2:	58 1c       	cp.w	r12,1
8000c6a4:	c0 33       	brcs	8000c6aa <__avr32_f64_cmp_lt+0x3e>
8000c6a6:	5e 0d       	reteq	0
8000c6a8:	5e 1f       	retne	1
8000c6aa:	10 3a       	cp.w	r10,r8
8000c6ac:	f2 0b 13 00 	cpc	r11,r9
8000c6b0:	5e 2d       	reths	0
8000c6b2:	5e 3f       	retlo	1
8000c6b4:	14 38       	cp.w	r8,r10
8000c6b6:	f6 09 13 00 	cpc	r9,r11
8000c6ba:	5e 2d       	reths	0
8000c6bc:	5e 3f       	retlo	1
8000c6be:	1b 07       	ld.w	r7,sp++
8000c6c0:	d8 0a       	popm	pc,r12=0
8000c6c2:	58 17       	cp.w	r7,1
8000c6c4:	5f 1c       	srne	r12
8000c6c6:	58 09       	cp.w	r9,0
8000c6c8:	f5 b8 00 00 	subfeq	r8,0
8000c6cc:	1b 07       	ld.w	r7,sp++
8000c6ce:	1b 0e       	ld.w	lr,sp++
8000c6d0:	5e 0d       	reteq	0
8000c6d2:	5e fc       	retal	r12

8000c6d4 <__avr32_f64_div>:
8000c6d4:	eb cd 40 ff 	pushm	r0-r7,lr
8000c6d8:	f7 e9 20 0e 	eor	lr,r11,r9
8000c6dc:	f6 07 16 14 	lsr	r7,r11,0x14
8000c6e0:	a9 7b       	lsl	r11,0x9
8000c6e2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c6e6:	a9 7a       	lsl	r10,0x9
8000c6e8:	bd bb       	sbr	r11,0x1d
8000c6ea:	e4 1b 3f ff 	andh	r11,0x3fff
8000c6ee:	ab d7       	cbr	r7,0xb
8000c6f0:	e0 80 00 cc 	breq	8000c888 <__avr32_f64_div_round_subnormal+0x54>
8000c6f4:	e0 47 07 ff 	cp.w	r7,2047
8000c6f8:	e0 84 00 b5 	brge	8000c862 <__avr32_f64_div_round_subnormal+0x2e>
8000c6fc:	f2 06 16 14 	lsr	r6,r9,0x14
8000c700:	a9 79       	lsl	r9,0x9
8000c702:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c706:	a9 78       	lsl	r8,0x9
8000c708:	bd b9       	sbr	r9,0x1d
8000c70a:	e4 19 3f ff 	andh	r9,0x3fff
8000c70e:	ab d6       	cbr	r6,0xb
8000c710:	e0 80 00 e2 	breq	8000c8d4 <__avr32_f64_div_round_subnormal+0xa0>
8000c714:	e0 46 07 ff 	cp.w	r6,2047
8000c718:	e0 84 00 b2 	brge	8000c87c <__avr32_f64_div_round_subnormal+0x48>
8000c71c:	0c 17       	sub	r7,r6
8000c71e:	fe 37 fc 01 	sub	r7,-1023
8000c722:	fc 1c 80 00 	movh	r12,0x8000
8000c726:	f8 03 16 01 	lsr	r3,r12,0x1
8000c72a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c72e:	5c d4       	com	r4
8000c730:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c734:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c738:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c73c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c740:	ea 03 15 02 	lsl	r3,r5,0x2
8000c744:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c748:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c74c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c750:	ea 03 15 02 	lsl	r3,r5,0x2
8000c754:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c758:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c75c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c760:	ea 03 15 02 	lsl	r3,r5,0x2
8000c764:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c768:	e4 09 07 40 	macu.d	r0,r2,r9
8000c76c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c770:	02 04       	add	r4,r1
8000c772:	5c 05       	acr	r5
8000c774:	a3 65       	lsl	r5,0x2
8000c776:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c77a:	a3 64       	lsl	r4,0x2
8000c77c:	5c 34       	neg	r4
8000c77e:	f8 05 01 45 	sbc	r5,r12,r5
8000c782:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c786:	e4 05 07 40 	macu.d	r0,r2,r5
8000c78a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c78e:	02 04       	add	r4,r1
8000c790:	5c 05       	acr	r5
8000c792:	ea 03 15 02 	lsl	r3,r5,0x2
8000c796:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c79a:	e8 02 15 02 	lsl	r2,r4,0x2
8000c79e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c7a2:	e4 09 07 40 	macu.d	r0,r2,r9
8000c7a6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c7aa:	02 04       	add	r4,r1
8000c7ac:	5c 05       	acr	r5
8000c7ae:	a3 65       	lsl	r5,0x2
8000c7b0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c7b4:	a3 64       	lsl	r4,0x2
8000c7b6:	5c 34       	neg	r4
8000c7b8:	f8 05 01 45 	sbc	r5,r12,r5
8000c7bc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c7c0:	e4 05 07 40 	macu.d	r0,r2,r5
8000c7c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c7c8:	02 04       	add	r4,r1
8000c7ca:	5c 05       	acr	r5
8000c7cc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c7d0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c7d4:	e8 02 15 02 	lsl	r2,r4,0x2
8000c7d8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c7dc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c7e0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c7e4:	02 02       	add	r2,r1
8000c7e6:	5c 03       	acr	r3
8000c7e8:	ed b3 00 1c 	bld	r3,0x1c
8000c7ec:	c0 90       	breq	8000c7fe <__avr32_f64_div+0x12a>
8000c7ee:	a1 72       	lsl	r2,0x1
8000c7f0:	5c f3       	rol	r3
8000c7f2:	20 17       	sub	r7,1
8000c7f4:	a3 9a       	lsr	r10,0x3
8000c7f6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c7fa:	a3 9b       	lsr	r11,0x3
8000c7fc:	c0 58       	rjmp	8000c806 <__avr32_f64_div+0x132>
8000c7fe:	a5 8a       	lsr	r10,0x4
8000c800:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c804:	a5 8b       	lsr	r11,0x4
8000c806:	58 07       	cp.w	r7,0
8000c808:	e0 8a 00 8b 	brle	8000c91e <__avr32_f64_div_res_subnormal>
8000c80c:	e0 12 ff 00 	andl	r2,0xff00
8000c810:	e8 12 00 80 	orl	r2,0x80
8000c814:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c818:	e4 09 07 40 	macu.d	r0,r2,r9
8000c81c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c820:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c824:	00 05       	add	r5,r0
8000c826:	f0 01 00 48 	adc	r8,r8,r1
8000c82a:	5c 09       	acr	r9
8000c82c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c830:	58 04       	cp.w	r4,0
8000c832:	5c 25       	cpc	r5

8000c834 <__avr32_f64_div_round_subnormal>:
8000c834:	f4 08 13 00 	cpc	r8,r10
8000c838:	f6 09 13 00 	cpc	r9,r11
8000c83c:	5f 36       	srlo	r6
8000c83e:	f8 06 17 00 	moveq	r6,r12
8000c842:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c846:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c84a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c84e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c852:	ed be 00 1f 	bld	lr,0x1f
8000c856:	ef bb 00 1f 	bst	r11,0x1f
8000c85a:	0c 0a       	add	r10,r6
8000c85c:	5c 0b       	acr	r11
8000c85e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c862:	e4 1b 00 0f 	andh	r11,0xf
8000c866:	14 4b       	or	r11,r10
8000c868:	e0 81 00 a7 	brne	8000c9b6 <__avr32_f64_div_res_subnormal+0x98>
8000c86c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c870:	ab d6       	cbr	r6,0xb
8000c872:	e0 46 07 ff 	cp.w	r6,2047
8000c876:	e0 81 00 a4 	brne	8000c9be <__avr32_f64_div_res_subnormal+0xa0>
8000c87a:	c9 e8       	rjmp	8000c9b6 <__avr32_f64_div_res_subnormal+0x98>
8000c87c:	e4 19 00 0f 	andh	r9,0xf
8000c880:	10 49       	or	r9,r8
8000c882:	e0 81 00 9a 	brne	8000c9b6 <__avr32_f64_div_res_subnormal+0x98>
8000c886:	c9 28       	rjmp	8000c9aa <__avr32_f64_div_res_subnormal+0x8c>
8000c888:	a3 7b       	lsl	r11,0x3
8000c88a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c88e:	a3 7a       	lsl	r10,0x3
8000c890:	f5 eb 10 04 	or	r4,r10,r11
8000c894:	e0 80 00 a0 	breq	8000c9d4 <__avr32_f64_div_op1_zero>
8000c898:	f6 04 12 00 	clz	r4,r11
8000c89c:	c1 70       	breq	8000c8ca <__avr32_f64_div_round_subnormal+0x96>
8000c89e:	c0 c3       	brcs	8000c8b6 <__avr32_f64_div_round_subnormal+0x82>
8000c8a0:	e8 05 11 20 	rsub	r5,r4,32
8000c8a4:	f6 04 09 4b 	lsl	r11,r11,r4
8000c8a8:	f4 05 0a 45 	lsr	r5,r10,r5
8000c8ac:	0a 4b       	or	r11,r5
8000c8ae:	f4 04 09 4a 	lsl	r10,r10,r4
8000c8b2:	08 17       	sub	r7,r4
8000c8b4:	c0 b8       	rjmp	8000c8ca <__avr32_f64_div_round_subnormal+0x96>
8000c8b6:	f4 04 12 00 	clz	r4,r10
8000c8ba:	f9 b4 03 00 	movlo	r4,0
8000c8be:	f7 b4 02 e0 	subhs	r4,-32
8000c8c2:	f4 04 09 4b 	lsl	r11,r10,r4
8000c8c6:	30 0a       	mov	r10,0
8000c8c8:	08 17       	sub	r7,r4
8000c8ca:	a3 8a       	lsr	r10,0x2
8000c8cc:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c8d0:	a3 8b       	lsr	r11,0x2
8000c8d2:	c1 1b       	rjmp	8000c6f4 <__avr32_f64_div+0x20>
8000c8d4:	a3 79       	lsl	r9,0x3
8000c8d6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c8da:	a3 78       	lsl	r8,0x3
8000c8dc:	f3 e8 10 04 	or	r4,r9,r8
8000c8e0:	c6 f0       	breq	8000c9be <__avr32_f64_div_res_subnormal+0xa0>
8000c8e2:	f2 04 12 00 	clz	r4,r9
8000c8e6:	c1 70       	breq	8000c914 <__avr32_f64_div_round_subnormal+0xe0>
8000c8e8:	c0 c3       	brcs	8000c900 <__avr32_f64_div_round_subnormal+0xcc>
8000c8ea:	e8 05 11 20 	rsub	r5,r4,32
8000c8ee:	f2 04 09 49 	lsl	r9,r9,r4
8000c8f2:	f0 05 0a 45 	lsr	r5,r8,r5
8000c8f6:	0a 49       	or	r9,r5
8000c8f8:	f0 04 09 48 	lsl	r8,r8,r4
8000c8fc:	08 16       	sub	r6,r4
8000c8fe:	c0 b8       	rjmp	8000c914 <__avr32_f64_div_round_subnormal+0xe0>
8000c900:	f0 04 12 00 	clz	r4,r8
8000c904:	f9 b4 03 00 	movlo	r4,0
8000c908:	f7 b4 02 e0 	subhs	r4,-32
8000c90c:	f0 04 09 49 	lsl	r9,r8,r4
8000c910:	30 08       	mov	r8,0
8000c912:	08 16       	sub	r6,r4
8000c914:	a3 88       	lsr	r8,0x2
8000c916:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c91a:	a3 89       	lsr	r9,0x2
8000c91c:	cf ca       	rjmp	8000c714 <__avr32_f64_div+0x40>

8000c91e <__avr32_f64_div_res_subnormal>:
8000c91e:	5c 37       	neg	r7
8000c920:	2f f7       	sub	r7,-1
8000c922:	f1 b7 04 c0 	satu	r7,0x6
8000c926:	e0 47 00 20 	cp.w	r7,32
8000c92a:	c1 54       	brge	8000c954 <__avr32_f64_div_res_subnormal+0x36>
8000c92c:	ee 06 11 20 	rsub	r6,r7,32
8000c930:	e4 07 0a 42 	lsr	r2,r2,r7
8000c934:	e6 06 09 4c 	lsl	r12,r3,r6
8000c938:	18 42       	or	r2,r12
8000c93a:	e6 07 0a 43 	lsr	r3,r3,r7
8000c93e:	f4 06 09 41 	lsl	r1,r10,r6
8000c942:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c946:	f6 06 09 4c 	lsl	r12,r11,r6
8000c94a:	18 4a       	or	r10,r12
8000c94c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c950:	30 00       	mov	r0,0
8000c952:	c1 58       	rjmp	8000c97c <__avr32_f64_div_res_subnormal+0x5e>
8000c954:	ee 06 11 20 	rsub	r6,r7,32
8000c958:	f9 b0 00 00 	moveq	r0,0
8000c95c:	f9 bc 00 00 	moveq	r12,0
8000c960:	c0 50       	breq	8000c96a <__avr32_f64_div_res_subnormal+0x4c>
8000c962:	f4 06 09 40 	lsl	r0,r10,r6
8000c966:	f6 06 09 4c 	lsl	r12,r11,r6
8000c96a:	e6 07 0a 42 	lsr	r2,r3,r7
8000c96e:	30 03       	mov	r3,0
8000c970:	f4 07 0a 41 	lsr	r1,r10,r7
8000c974:	18 41       	or	r1,r12
8000c976:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c97a:	30 0b       	mov	r11,0
8000c97c:	e0 12 ff 00 	andl	r2,0xff00
8000c980:	e8 12 00 80 	orl	r2,0x80
8000c984:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c988:	e4 09 07 46 	macu.d	r6,r2,r9
8000c98c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c990:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c994:	0c 05       	add	r5,r6
8000c996:	f0 07 00 48 	adc	r8,r8,r7
8000c99a:	5c 09       	acr	r9
8000c99c:	30 07       	mov	r7,0
8000c99e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c9a2:	00 34       	cp.w	r4,r0
8000c9a4:	e2 05 13 00 	cpc	r5,r1
8000c9a8:	c4 6b       	rjmp	8000c834 <__avr32_f64_div_round_subnormal>
8000c9aa:	1c 9b       	mov	r11,lr
8000c9ac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c9b0:	30 0a       	mov	r10,0
8000c9b2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c9b6:	3f fb       	mov	r11,-1
8000c9b8:	30 0a       	mov	r10,0
8000c9ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c9be:	f5 eb 10 04 	or	r4,r10,r11
8000c9c2:	c0 90       	breq	8000c9d4 <__avr32_f64_div_op1_zero>
8000c9c4:	1c 9b       	mov	r11,lr
8000c9c6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c9ca:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c9ce:	30 0a       	mov	r10,0
8000c9d0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c9d4 <__avr32_f64_div_op1_zero>:
8000c9d4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c9d8:	ce f0       	breq	8000c9b6 <__avr32_f64_div_res_subnormal+0x98>
8000c9da:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c9de:	e0 44 07 ff 	cp.w	r4,2047
8000c9e2:	ce 41       	brne	8000c9aa <__avr32_f64_div_res_subnormal+0x8c>
8000c9e4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c9e8:	ce 10       	breq	8000c9aa <__avr32_f64_div_res_subnormal+0x8c>
8000c9ea:	ce 6b       	rjmp	8000c9b6 <__avr32_f64_div_res_subnormal+0x98>

8000c9ec <__avr32_udiv64>:
8000c9ec:	d4 31       	pushm	r0-r7,lr
8000c9ee:	1a 97       	mov	r7,sp
8000c9f0:	20 3d       	sub	sp,12
8000c9f2:	10 9c       	mov	r12,r8
8000c9f4:	12 9e       	mov	lr,r9
8000c9f6:	14 93       	mov	r3,r10
8000c9f8:	58 09       	cp.w	r9,0
8000c9fa:	e0 81 00 bd 	brne	8000cb74 <__avr32_udiv64+0x188>
8000c9fe:	16 38       	cp.w	r8,r11
8000ca00:	e0 88 00 40 	brls	8000ca80 <__avr32_udiv64+0x94>
8000ca04:	f0 08 12 00 	clz	r8,r8
8000ca08:	c0 d0       	breq	8000ca22 <__avr32_udiv64+0x36>
8000ca0a:	f6 08 09 4b 	lsl	r11,r11,r8
8000ca0e:	f0 09 11 20 	rsub	r9,r8,32
8000ca12:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca16:	f4 09 0a 49 	lsr	r9,r10,r9
8000ca1a:	f4 08 09 43 	lsl	r3,r10,r8
8000ca1e:	f3 eb 10 0b 	or	r11,r9,r11
8000ca22:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ca26:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000ca2a:	f6 0e 0d 00 	divu	r0,r11,lr
8000ca2e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca32:	00 99       	mov	r9,r0
8000ca34:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca38:	e0 0a 02 48 	mul	r8,r0,r10
8000ca3c:	10 3b       	cp.w	r11,r8
8000ca3e:	c0 a2       	brcc	8000ca52 <__avr32_udiv64+0x66>
8000ca40:	20 19       	sub	r9,1
8000ca42:	18 0b       	add	r11,r12
8000ca44:	18 3b       	cp.w	r11,r12
8000ca46:	c0 63       	brcs	8000ca52 <__avr32_udiv64+0x66>
8000ca48:	10 3b       	cp.w	r11,r8
8000ca4a:	f7 b9 03 01 	sublo	r9,1
8000ca4e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca52:	f6 08 01 01 	sub	r1,r11,r8
8000ca56:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca5a:	e2 0e 0d 00 	divu	r0,r1,lr
8000ca5e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca62:	00 98       	mov	r8,r0
8000ca64:	e0 0a 02 4a 	mul	r10,r0,r10
8000ca68:	14 33       	cp.w	r3,r10
8000ca6a:	c0 82       	brcc	8000ca7a <__avr32_udiv64+0x8e>
8000ca6c:	20 18       	sub	r8,1
8000ca6e:	18 03       	add	r3,r12
8000ca70:	18 33       	cp.w	r3,r12
8000ca72:	c0 43       	brcs	8000ca7a <__avr32_udiv64+0x8e>
8000ca74:	14 33       	cp.w	r3,r10
8000ca76:	f7 b8 03 01 	sublo	r8,1
8000ca7a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ca7e:	cd f8       	rjmp	8000cc3c <__avr32_udiv64+0x250>
8000ca80:	58 08       	cp.w	r8,0
8000ca82:	c0 51       	brne	8000ca8c <__avr32_udiv64+0xa0>
8000ca84:	30 19       	mov	r9,1
8000ca86:	f2 08 0d 08 	divu	r8,r9,r8
8000ca8a:	10 9c       	mov	r12,r8
8000ca8c:	f8 06 12 00 	clz	r6,r12
8000ca90:	c0 41       	brne	8000ca98 <__avr32_udiv64+0xac>
8000ca92:	18 1b       	sub	r11,r12
8000ca94:	30 19       	mov	r9,1
8000ca96:	c4 08       	rjmp	8000cb16 <__avr32_udiv64+0x12a>
8000ca98:	ec 01 11 20 	rsub	r1,r6,32
8000ca9c:	f4 01 0a 49 	lsr	r9,r10,r1
8000caa0:	f8 06 09 4c 	lsl	r12,r12,r6
8000caa4:	f6 06 09 48 	lsl	r8,r11,r6
8000caa8:	f6 01 0a 41 	lsr	r1,r11,r1
8000caac:	f3 e8 10 08 	or	r8,r9,r8
8000cab0:	f8 03 16 10 	lsr	r3,r12,0x10
8000cab4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cab8:	e2 03 0d 00 	divu	r0,r1,r3
8000cabc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cac0:	00 9e       	mov	lr,r0
8000cac2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cac6:	e0 05 02 49 	mul	r9,r0,r5
8000caca:	12 3b       	cp.w	r11,r9
8000cacc:	c0 a2       	brcc	8000cae0 <__avr32_udiv64+0xf4>
8000cace:	20 1e       	sub	lr,1
8000cad0:	18 0b       	add	r11,r12
8000cad2:	18 3b       	cp.w	r11,r12
8000cad4:	c0 63       	brcs	8000cae0 <__avr32_udiv64+0xf4>
8000cad6:	12 3b       	cp.w	r11,r9
8000cad8:	f7 be 03 01 	sublo	lr,1
8000cadc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cae0:	12 1b       	sub	r11,r9
8000cae2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000cae6:	f6 03 0d 02 	divu	r2,r11,r3
8000caea:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000caee:	04 99       	mov	r9,r2
8000caf0:	e4 05 02 4b 	mul	r11,r2,r5
8000caf4:	16 38       	cp.w	r8,r11
8000caf6:	c0 a2       	brcc	8000cb0a <__avr32_udiv64+0x11e>
8000caf8:	20 19       	sub	r9,1
8000cafa:	18 08       	add	r8,r12
8000cafc:	18 38       	cp.w	r8,r12
8000cafe:	c0 63       	brcs	8000cb0a <__avr32_udiv64+0x11e>
8000cb00:	16 38       	cp.w	r8,r11
8000cb02:	f7 b9 03 01 	sublo	r9,1
8000cb06:	f1 dc e3 08 	addcs	r8,r8,r12
8000cb0a:	f4 06 09 43 	lsl	r3,r10,r6
8000cb0e:	f0 0b 01 0b 	sub	r11,r8,r11
8000cb12:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000cb16:	f8 06 16 10 	lsr	r6,r12,0x10
8000cb1a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000cb1e:	f6 06 0d 00 	divu	r0,r11,r6
8000cb22:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cb26:	00 9a       	mov	r10,r0
8000cb28:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb2c:	e0 0e 02 48 	mul	r8,r0,lr
8000cb30:	10 3b       	cp.w	r11,r8
8000cb32:	c0 a2       	brcc	8000cb46 <__avr32_udiv64+0x15a>
8000cb34:	20 1a       	sub	r10,1
8000cb36:	18 0b       	add	r11,r12
8000cb38:	18 3b       	cp.w	r11,r12
8000cb3a:	c0 63       	brcs	8000cb46 <__avr32_udiv64+0x15a>
8000cb3c:	10 3b       	cp.w	r11,r8
8000cb3e:	f7 ba 03 01 	sublo	r10,1
8000cb42:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb46:	f6 08 01 01 	sub	r1,r11,r8
8000cb4a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cb4e:	e2 06 0d 00 	divu	r0,r1,r6
8000cb52:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cb56:	00 98       	mov	r8,r0
8000cb58:	e0 0e 02 4b 	mul	r11,r0,lr
8000cb5c:	16 33       	cp.w	r3,r11
8000cb5e:	c0 82       	brcc	8000cb6e <__avr32_udiv64+0x182>
8000cb60:	20 18       	sub	r8,1
8000cb62:	18 03       	add	r3,r12
8000cb64:	18 33       	cp.w	r3,r12
8000cb66:	c0 43       	brcs	8000cb6e <__avr32_udiv64+0x182>
8000cb68:	16 33       	cp.w	r3,r11
8000cb6a:	f7 b8 03 01 	sublo	r8,1
8000cb6e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000cb72:	c6 98       	rjmp	8000cc44 <__avr32_udiv64+0x258>
8000cb74:	16 39       	cp.w	r9,r11
8000cb76:	e0 8b 00 65 	brhi	8000cc40 <__avr32_udiv64+0x254>
8000cb7a:	f2 09 12 00 	clz	r9,r9
8000cb7e:	c0 b1       	brne	8000cb94 <__avr32_udiv64+0x1a8>
8000cb80:	10 3a       	cp.w	r10,r8
8000cb82:	5f 2a       	srhs	r10
8000cb84:	1c 3b       	cp.w	r11,lr
8000cb86:	5f b8       	srhi	r8
8000cb88:	10 4a       	or	r10,r8
8000cb8a:	f2 0a 18 00 	cp.b	r10,r9
8000cb8e:	c5 90       	breq	8000cc40 <__avr32_udiv64+0x254>
8000cb90:	30 18       	mov	r8,1
8000cb92:	c5 98       	rjmp	8000cc44 <__avr32_udiv64+0x258>
8000cb94:	f0 09 09 46 	lsl	r6,r8,r9
8000cb98:	f2 03 11 20 	rsub	r3,r9,32
8000cb9c:	fc 09 09 4e 	lsl	lr,lr,r9
8000cba0:	f0 03 0a 48 	lsr	r8,r8,r3
8000cba4:	f6 09 09 4c 	lsl	r12,r11,r9
8000cba8:	f4 03 0a 42 	lsr	r2,r10,r3
8000cbac:	ef 46 ff f4 	st.w	r7[-12],r6
8000cbb0:	f6 03 0a 43 	lsr	r3,r11,r3
8000cbb4:	18 42       	or	r2,r12
8000cbb6:	f1 ee 10 0c 	or	r12,r8,lr
8000cbba:	f8 01 16 10 	lsr	r1,r12,0x10
8000cbbe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cbc2:	e6 01 0d 04 	divu	r4,r3,r1
8000cbc6:	e4 03 16 10 	lsr	r3,r2,0x10
8000cbca:	08 9e       	mov	lr,r4
8000cbcc:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cbd0:	e8 06 02 48 	mul	r8,r4,r6
8000cbd4:	10 33       	cp.w	r3,r8
8000cbd6:	c0 a2       	brcc	8000cbea <__avr32_udiv64+0x1fe>
8000cbd8:	20 1e       	sub	lr,1
8000cbda:	18 03       	add	r3,r12
8000cbdc:	18 33       	cp.w	r3,r12
8000cbde:	c0 63       	brcs	8000cbea <__avr32_udiv64+0x1fe>
8000cbe0:	10 33       	cp.w	r3,r8
8000cbe2:	f7 be 03 01 	sublo	lr,1
8000cbe6:	e7 dc e3 03 	addcs	r3,r3,r12
8000cbea:	10 13       	sub	r3,r8
8000cbec:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cbf0:	e6 01 0d 00 	divu	r0,r3,r1
8000cbf4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cbf8:	00 98       	mov	r8,r0
8000cbfa:	e0 06 02 46 	mul	r6,r0,r6
8000cbfe:	0c 3b       	cp.w	r11,r6
8000cc00:	c0 a2       	brcc	8000cc14 <__avr32_udiv64+0x228>
8000cc02:	20 18       	sub	r8,1
8000cc04:	18 0b       	add	r11,r12
8000cc06:	18 3b       	cp.w	r11,r12
8000cc08:	c0 63       	brcs	8000cc14 <__avr32_udiv64+0x228>
8000cc0a:	0c 3b       	cp.w	r11,r6
8000cc0c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cc10:	f7 b8 03 01 	sublo	r8,1
8000cc14:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cc18:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cc1c:	0c 1b       	sub	r11,r6
8000cc1e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cc22:	06 95       	mov	r5,r3
8000cc24:	16 35       	cp.w	r5,r11
8000cc26:	e0 8b 00 0a 	brhi	8000cc3a <__avr32_udiv64+0x24e>
8000cc2a:	5f 0b       	sreq	r11
8000cc2c:	f4 09 09 49 	lsl	r9,r10,r9
8000cc30:	12 32       	cp.w	r2,r9
8000cc32:	5f b9       	srhi	r9
8000cc34:	f7 e9 00 09 	and	r9,r11,r9
8000cc38:	c0 60       	breq	8000cc44 <__avr32_udiv64+0x258>
8000cc3a:	20 18       	sub	r8,1
8000cc3c:	30 09       	mov	r9,0
8000cc3e:	c0 38       	rjmp	8000cc44 <__avr32_udiv64+0x258>
8000cc40:	30 09       	mov	r9,0
8000cc42:	12 98       	mov	r8,r9
8000cc44:	10 9a       	mov	r10,r8
8000cc46:	12 93       	mov	r3,r9
8000cc48:	10 92       	mov	r2,r8
8000cc4a:	12 9b       	mov	r11,r9
8000cc4c:	2f dd       	sub	sp,-12
8000cc4e:	d8 32       	popm	r0-r7,pc

8000cc50 <__avr32_umod64>:
8000cc50:	d4 31       	pushm	r0-r7,lr
8000cc52:	1a 97       	mov	r7,sp
8000cc54:	20 3d       	sub	sp,12
8000cc56:	10 9c       	mov	r12,r8
8000cc58:	12 95       	mov	r5,r9
8000cc5a:	14 9e       	mov	lr,r10
8000cc5c:	16 91       	mov	r1,r11
8000cc5e:	16 96       	mov	r6,r11
8000cc60:	58 09       	cp.w	r9,0
8000cc62:	e0 81 00 81 	brne	8000cd64 <__avr32_umod64+0x114>
8000cc66:	16 38       	cp.w	r8,r11
8000cc68:	e0 88 00 12 	brls	8000cc8c <__avr32_umod64+0x3c>
8000cc6c:	f0 08 12 00 	clz	r8,r8
8000cc70:	c4 e0       	breq	8000cd0c <__avr32_umod64+0xbc>
8000cc72:	f6 08 09 46 	lsl	r6,r11,r8
8000cc76:	f8 08 09 4c 	lsl	r12,r12,r8
8000cc7a:	f0 0b 11 20 	rsub	r11,r8,32
8000cc7e:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc82:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cc86:	f7 e6 10 06 	or	r6,r11,r6
8000cc8a:	c4 18       	rjmp	8000cd0c <__avr32_umod64+0xbc>
8000cc8c:	58 08       	cp.w	r8,0
8000cc8e:	c0 51       	brne	8000cc98 <__avr32_umod64+0x48>
8000cc90:	30 19       	mov	r9,1
8000cc92:	f2 08 0d 08 	divu	r8,r9,r8
8000cc96:	10 9c       	mov	r12,r8
8000cc98:	f8 08 12 00 	clz	r8,r12
8000cc9c:	c0 31       	brne	8000cca2 <__avr32_umod64+0x52>
8000cc9e:	18 16       	sub	r6,r12
8000cca0:	c3 68       	rjmp	8000cd0c <__avr32_umod64+0xbc>
8000cca2:	f0 03 11 20 	rsub	r3,r8,32
8000cca6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ccaa:	f8 08 09 4c 	lsl	r12,r12,r8
8000ccae:	ec 08 09 49 	lsl	r9,r6,r8
8000ccb2:	ec 03 0a 43 	lsr	r3,r6,r3
8000ccb6:	f7 e9 10 09 	or	r9,r11,r9
8000ccba:	f8 05 16 10 	lsr	r5,r12,0x10
8000ccbe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ccc2:	e6 05 0d 02 	divu	r2,r3,r5
8000ccc6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ccca:	ec 02 02 4b 	mul	r11,r6,r2
8000ccce:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ccd2:	16 3e       	cp.w	lr,r11
8000ccd4:	c0 72       	brcc	8000cce2 <__avr32_umod64+0x92>
8000ccd6:	18 0e       	add	lr,r12
8000ccd8:	18 3e       	cp.w	lr,r12
8000ccda:	c0 43       	brcs	8000cce2 <__avr32_umod64+0x92>
8000ccdc:	16 3e       	cp.w	lr,r11
8000ccde:	fd dc e3 0e 	addcs	lr,lr,r12
8000cce2:	fc 0b 01 03 	sub	r3,lr,r11
8000cce6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000ccea:	e6 05 0d 02 	divu	r2,r3,r5
8000ccee:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ccf2:	a5 36       	mul	r6,r2
8000ccf4:	0c 39       	cp.w	r9,r6
8000ccf6:	c0 72       	brcc	8000cd04 <__avr32_umod64+0xb4>
8000ccf8:	18 09       	add	r9,r12
8000ccfa:	18 39       	cp.w	r9,r12
8000ccfc:	c0 43       	brcs	8000cd04 <__avr32_umod64+0xb4>
8000ccfe:	0c 39       	cp.w	r9,r6
8000cd00:	f3 dc e3 09 	addcs	r9,r9,r12
8000cd04:	f2 06 01 06 	sub	r6,r9,r6
8000cd08:	f4 08 09 4e 	lsl	lr,r10,r8
8000cd0c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cd10:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cd14:	ec 0a 0d 02 	divu	r2,r6,r10
8000cd18:	fc 09 16 10 	lsr	r9,lr,0x10
8000cd1c:	ea 02 02 4b 	mul	r11,r5,r2
8000cd20:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cd24:	16 39       	cp.w	r9,r11
8000cd26:	c0 72       	brcc	8000cd34 <__avr32_umod64+0xe4>
8000cd28:	18 09       	add	r9,r12
8000cd2a:	18 39       	cp.w	r9,r12
8000cd2c:	c0 43       	brcs	8000cd34 <__avr32_umod64+0xe4>
8000cd2e:	16 39       	cp.w	r9,r11
8000cd30:	f3 dc e3 09 	addcs	r9,r9,r12
8000cd34:	f2 0b 01 0b 	sub	r11,r9,r11
8000cd38:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cd3c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cd40:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cd44:	ea 0a 02 4a 	mul	r10,r5,r10
8000cd48:	14 3e       	cp.w	lr,r10
8000cd4a:	c0 72       	brcc	8000cd58 <__avr32_umod64+0x108>
8000cd4c:	18 0e       	add	lr,r12
8000cd4e:	18 3e       	cp.w	lr,r12
8000cd50:	c0 43       	brcs	8000cd58 <__avr32_umod64+0x108>
8000cd52:	14 3e       	cp.w	lr,r10
8000cd54:	fd dc e3 0e 	addcs	lr,lr,r12
8000cd58:	fc 0a 01 0a 	sub	r10,lr,r10
8000cd5c:	30 0b       	mov	r11,0
8000cd5e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cd62:	c7 b8       	rjmp	8000ce58 <__avr32_umod64+0x208>
8000cd64:	16 39       	cp.w	r9,r11
8000cd66:	e0 8b 00 79 	brhi	8000ce58 <__avr32_umod64+0x208>
8000cd6a:	f2 09 12 00 	clz	r9,r9
8000cd6e:	c1 21       	brne	8000cd92 <__avr32_umod64+0x142>
8000cd70:	10 3a       	cp.w	r10,r8
8000cd72:	5f 2b       	srhs	r11
8000cd74:	0a 31       	cp.w	r1,r5
8000cd76:	5f ba       	srhi	r10
8000cd78:	f7 ea 10 0a 	or	r10,r11,r10
8000cd7c:	f2 0a 18 00 	cp.b	r10,r9
8000cd80:	c0 60       	breq	8000cd8c <__avr32_umod64+0x13c>
8000cd82:	fc 08 01 0c 	sub	r12,lr,r8
8000cd86:	e2 05 01 46 	sbc	r6,r1,r5
8000cd8a:	18 9e       	mov	lr,r12
8000cd8c:	0c 9b       	mov	r11,r6
8000cd8e:	1c 9a       	mov	r10,lr
8000cd90:	c6 48       	rjmp	8000ce58 <__avr32_umod64+0x208>
8000cd92:	ea 09 09 4c 	lsl	r12,r5,r9
8000cd96:	f2 06 11 20 	rsub	r6,r9,32
8000cd9a:	f6 09 09 4b 	lsl	r11,r11,r9
8000cd9e:	f0 09 09 42 	lsl	r2,r8,r9
8000cda2:	ef 46 ff f4 	st.w	r7[-12],r6
8000cda6:	f0 06 0a 48 	lsr	r8,r8,r6
8000cdaa:	18 48       	or	r8,r12
8000cdac:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cdb0:	f4 09 09 43 	lsl	r3,r10,r9
8000cdb4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cdb8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cdbc:	16 4a       	or	r10,r11
8000cdbe:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cdc2:	f8 0b 0d 04 	divu	r4,r12,r11
8000cdc6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cdca:	08 91       	mov	r1,r4
8000cdcc:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cdd0:	e8 0e 02 46 	mul	r6,r4,lr
8000cdd4:	0c 3c       	cp.w	r12,r6
8000cdd6:	c0 a2       	brcc	8000cdea <__avr32_umod64+0x19a>
8000cdd8:	20 11       	sub	r1,1
8000cdda:	10 0c       	add	r12,r8
8000cddc:	10 3c       	cp.w	r12,r8
8000cdde:	c0 63       	brcs	8000cdea <__avr32_umod64+0x19a>
8000cde0:	0c 3c       	cp.w	r12,r6
8000cde2:	f7 b1 03 01 	sublo	r1,1
8000cde6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cdea:	0c 1c       	sub	r12,r6
8000cdec:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cdf0:	f8 0b 0d 04 	divu	r4,r12,r11
8000cdf4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cdf8:	08 96       	mov	r6,r4
8000cdfa:	e8 0e 02 4e 	mul	lr,r4,lr
8000cdfe:	1c 3b       	cp.w	r11,lr
8000ce00:	c0 a2       	brcc	8000ce14 <__avr32_umod64+0x1c4>
8000ce02:	20 16       	sub	r6,1
8000ce04:	10 0b       	add	r11,r8
8000ce06:	10 3b       	cp.w	r11,r8
8000ce08:	c0 63       	brcs	8000ce14 <__avr32_umod64+0x1c4>
8000ce0a:	1c 3b       	cp.w	r11,lr
8000ce0c:	f7 b6 03 01 	sublo	r6,1
8000ce10:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ce14:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ce18:	1c 1b       	sub	r11,lr
8000ce1a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ce1e:	00 9e       	mov	lr,r0
8000ce20:	02 9c       	mov	r12,r1
8000ce22:	16 3c       	cp.w	r12,r11
8000ce24:	e0 8b 00 08 	brhi	8000ce34 <__avr32_umod64+0x1e4>
8000ce28:	5f 06       	sreq	r6
8000ce2a:	06 30       	cp.w	r0,r3
8000ce2c:	5f ba       	srhi	r10
8000ce2e:	ed ea 00 0a 	and	r10,r6,r10
8000ce32:	c0 60       	breq	8000ce3e <__avr32_umod64+0x1ee>
8000ce34:	fc 02 01 04 	sub	r4,lr,r2
8000ce38:	f8 08 01 4c 	sbc	r12,r12,r8
8000ce3c:	08 9e       	mov	lr,r4
8000ce3e:	e6 0e 01 0a 	sub	r10,r3,lr
8000ce42:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ce46:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ce4a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ce4e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ce52:	f8 01 09 4c 	lsl	r12,r12,r1
8000ce56:	18 4a       	or	r10,r12
8000ce58:	2f dd       	sub	sp,-12
8000ce5a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d000:	c0 08       	rjmp	8000d000 <_evba>
	...

8000d004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d004:	c0 08       	rjmp	8000d004 <_handle_TLB_Multiple_Hit>
	...

8000d008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d008:	c0 08       	rjmp	8000d008 <_handle_Bus_Error_Data_Fetch>
	...

8000d00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d00c:	c0 08       	rjmp	8000d00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d010:	c0 08       	rjmp	8000d010 <_handle_NMI>
	...

8000d014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d014:	c0 08       	rjmp	8000d014 <_handle_Instruction_Address>
	...

8000d018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d018:	c0 08       	rjmp	8000d018 <_handle_ITLB_Protection>
	...

8000d01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d01c:	c0 08       	rjmp	8000d01c <_handle_Breakpoint>
	...

8000d020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d020:	c0 08       	rjmp	8000d020 <_handle_Illegal_Opcode>
	...

8000d024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d024:	c0 08       	rjmp	8000d024 <_handle_Unimplemented_Instruction>
	...

8000d028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d028:	c0 08       	rjmp	8000d028 <_handle_Privilege_Violation>
	...

8000d02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d02c:	c0 08       	rjmp	8000d02c <_handle_Floating_Point>
	...

8000d030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d030:	c0 08       	rjmp	8000d030 <_handle_Coprocessor_Absent>
	...

8000d034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d034:	c0 08       	rjmp	8000d034 <_handle_Data_Address_Read>
	...

8000d038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d038:	c0 08       	rjmp	8000d038 <_handle_Data_Address_Write>
	...

8000d03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d03c:	c0 08       	rjmp	8000d03c <_handle_DTLB_Protection_Read>
	...

8000d040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d040:	c0 08       	rjmp	8000d040 <_handle_DTLB_Protection_Write>
	...

8000d044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d044:	c0 08       	rjmp	8000d044 <_handle_DTLB_Modified>
	...

8000d050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d050:	c0 08       	rjmp	8000d050 <_handle_ITLB_Miss>
	...

8000d060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d060:	c0 08       	rjmp	8000d060 <_handle_DTLB_Miss_Read>
	...

8000d070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d070:	c0 08       	rjmp	8000d070 <_handle_DTLB_Miss_Write>
	...

8000d100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d100:	fe cf 71 0c 	sub	pc,pc,28940

8000d104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d104:	30 0c       	mov	r12,0
8000d106:	fe b0 c4 3d 	rcall	80005980 <_get_interrupt_handler>
8000d10a:	58 0c       	cp.w	r12,0
8000d10c:	f8 0f 17 10 	movne	pc,r12
8000d110:	d6 03       	rete

8000d112 <_int1>:
8000d112:	30 1c       	mov	r12,1
8000d114:	fe b0 c4 36 	rcall	80005980 <_get_interrupt_handler>
8000d118:	58 0c       	cp.w	r12,0
8000d11a:	f8 0f 17 10 	movne	pc,r12
8000d11e:	d6 03       	rete

8000d120 <_int2>:
8000d120:	30 2c       	mov	r12,2
8000d122:	fe b0 c4 2f 	rcall	80005980 <_get_interrupt_handler>
8000d126:	58 0c       	cp.w	r12,0
8000d128:	f8 0f 17 10 	movne	pc,r12
8000d12c:	d6 03       	rete

8000d12e <_int3>:
8000d12e:	30 3c       	mov	r12,3
8000d130:	fe b0 c4 28 	rcall	80005980 <_get_interrupt_handler>
8000d134:	58 0c       	cp.w	r12,0
8000d136:	f8 0f 17 10 	movne	pc,r12
8000d13a:	d6 03       	rete

8000d13c <ipr_val>:
8000d13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1fc:	d7 03 d7 03                                         ....
