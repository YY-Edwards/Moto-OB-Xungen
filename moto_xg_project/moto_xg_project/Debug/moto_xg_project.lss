
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bc2c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000de00  8000de00  0000e200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001610  8000e000  8000e000  0000e400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a54  00000004  8000f610  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000093b8  00000a58  80010064  00010658  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000382a  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002e1cd  00000000  00000000  0001564a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007812  00000000  00000000  00043817  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000dc88  00000000  00000000  0004b029  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00004104  00000000  00000000  00058cb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000082bb  00000000  00000000  0005cdb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000ff87  00000000  00000000  00065073  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001848  00000000  00000000  00075000  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b4 78 	sub	pc,pc,-19336

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 1c       	sub	r12,r7

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 74       	tst	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
80002040:	49 2c       	lddpc	r12,80002088 <app_init+0x4c>
80002042:	f0 1f 00 13 	mcall	8000208c <app_init+0x50>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002046:	49 3b       	lddpc	r11,80002090 <app_init+0x54>
80002048:	49 3c       	lddpc	r12,80002094 <app_init+0x58>
8000204a:	f0 1f 00 14 	mcall	80002098 <app_init+0x5c>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204e:	30 07       	mov	r7,0
80002050:	1a d7       	st.w	--sp,r7
80002052:	1a d7       	st.w	--sp,r7
80002054:	1a d7       	st.w	--sp,r7
80002056:	30 18       	mov	r8,1
80002058:	0e 99       	mov	r9,r7
8000205a:	e0 6a 02 ee 	mov	r10,750
8000205e:	49 0b       	lddpc	r11,8000209c <app_init+0x60>
80002060:	49 0c       	lddpc	r12,800020a0 <app_init+0x64>
80002062:	f0 1f 00 11 	mcall	800020a4 <app_init+0x68>
80002066:	49 16       	lddpc	r6,800020a8 <app_init+0x6c>
80002068:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
	 res = xTaskCreate(
8000206a:	1a d7       	st.w	--sp,r7
8000206c:	1a d7       	st.w	--sp,r7
8000206e:	1a d7       	st.w	--sp,r7
80002070:	30 18       	mov	r8,1
80002072:	0e 99       	mov	r9,r7
80002074:	e0 6a 02 ee 	mov	r10,750
80002078:	48 db       	lddpc	r11,800020ac <app_init+0x70>
8000207a:	48 ec       	lddpc	r12,800020b0 <app_init+0x74>
8000207c:	f0 1f 00 0a 	mcall	800020a4 <app_init+0x68>
80002080:	8d 0c       	st.w	r6[0x0],r12
80002082:	2f ad       	sub	sp,-24
	 ,  750
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
80002084:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002088:	00 00       	add	r0,r0
8000208a:	00 10       	sub	r0,r0
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	47 94       	lddsp	r4,sp[0x1e4]
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	20 b4       	sub	r4,11
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	20 c8       	sub	r8,12
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	34 3c       	mov	r12,67
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	e0 00       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	28 f8       	sub	r8,-113
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	7b 38       	ld.w	r8,sp[0x4c]
800020a8:	00 00       	add	r0,r0
800020aa:	0a 5c       	eor	r12,r5
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	e0 08       	*unknown*
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	27 c8       	sub	r8,124

800020b4 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020b4:	d4 01       	pushm	lr
  log("R");
800020b6:	48 3c       	lddpc	r12,800020c0 <app_payload_tx_proc+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	e0 10 80 00 	andl	r0,0x8000
800020c6:	7e fc       	ld.w	r12,pc[0x3c]

800020c8 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020c8:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020ca:	48 99       	lddpc	r9,800020ec <app_payload_rx_proc+0x24>
800020cc:	13 88       	ld.ub	r8,r9[0x0]
800020ce:	2f f8       	sub	r8,-1
800020d0:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020d2:	30 39       	mov	r9,3
800020d4:	f2 08 18 00 	cp.b	r8,r9
800020d8:	c0 71       	brne	800020e6 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020da:	30 09       	mov	r9,0
800020dc:	48 48       	lddpc	r8,800020ec <app_payload_rx_proc+0x24>
800020de:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020e0:	48 4c       	lddpc	r12,800020f0 <app_payload_rx_proc+0x28>
800020e2:	f0 1f 00 05 	mcall	800020f4 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020e6:	48 58       	lddpc	r8,800020f8 <app_payload_rx_proc+0x30>
800020e8:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020ea:	d8 02       	popm	pc
800020ec:	00 00       	add	r0,r0
800020ee:	0a 61       	and	r1,r5
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	e0 14 80 00 	andl	r4,0x8000
800020f6:	7e fc       	ld.w	r12,pc[0x3c]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 58       	eor	r8,r5

800020fc <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020fc:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020fe:	48 3c       	lddpc	r12,80002108 <FD_brdcst_func+0xc>
80002100:	f0 1f 00 03 	mcall	8000210c <FD_brdcst_func+0x10>
	
}
80002104:	d8 02       	popm	pc
80002106:	00 00       	add	r0,r0
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	e0 20 80 00 	sub	r0,32768
8000210e:	7e fc       	ld.w	r12,pc[0x3c]

80002110 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002110:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002112:	48 3c       	lddpc	r12,8000211c <FD_reply_func+0xc>
80002114:	f0 1f 00 03 	mcall	80002120 <FD_reply_func+0x10>
	
	
}
80002118:	d8 02       	popm	pc
8000211a:	00 00       	add	r0,r0
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	e0 40 80 00 	cp.w	r0,32768
80002122:	7e fc       	ld.w	r12,pc[0x3c]

80002124 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002124:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002126:	48 3c       	lddpc	r12,80002130 <FD_request_func+0xc>
80002128:	f0 1f 00 03 	mcall	80002134 <FD_request_func+0x10>
	
	
}
8000212c:	d8 02       	popm	pc
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	e0 5c 80 00 	cp.w	r12,98304
80002136:	7e fc       	ld.w	r12,pc[0x3c]

80002138 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002138:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000213a:	48 3c       	lddpc	r12,80002144 <EnOB_brdcst_func+0xc>
8000213c:	f0 1f 00 03 	mcall	80002148 <EnOB_brdcst_func+0x10>
}
80002140:	d8 02       	popm	pc
80002142:	00 00       	add	r0,r0
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	e0 78 80 00 	mov	r8,98304
8000214a:	7e fc       	ld.w	r12,pc[0x3c]

8000214c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000214c:	eb cd 40 80 	pushm	r7,lr
80002150:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002152:	19 a9       	ld.ub	r9,r12[0x2]
80002154:	30 08       	mov	r8,0
80002156:	f0 09 18 00 	cp.b	r9,r8
8000215a:	c1 91       	brne	8000218c <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000215c:	19 b8       	ld.ub	r8,r12[0x3]
8000215e:	30 19       	mov	r9,1
80002160:	f2 08 18 00 	cp.b	r8,r9
80002164:	c0 61       	brne	80002170 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002166:	49 0c       	lddpc	r12,800021a4 <EnOB_reply_func+0x58>
80002168:	f0 1f 00 10 	mcall	800021a8 <EnOB_reply_func+0x5c>
8000216c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002170:	58 08       	cp.w	r8,0
80002172:	c0 61       	brne	8000217e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002174:	48 ec       	lddpc	r12,800021ac <EnOB_reply_func+0x60>
80002176:	f0 1f 00 0d 	mcall	800021a8 <EnOB_reply_func+0x5c>
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000217e:	1a d8       	st.w	--sp,r8
80002180:	48 cc       	lddpc	r12,800021b0 <EnOB_reply_func+0x64>
80002182:	f0 1f 00 0a 	mcall	800021a8 <EnOB_reply_func+0x5c>
80002186:	2f fd       	sub	sp,-4
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
8000218c:	48 ac       	lddpc	r12,800021b4 <EnOB_reply_func+0x68>
8000218e:	f0 1f 00 07 	mcall	800021a8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002192:	0f a8       	ld.ub	r8,r7[0x2]
80002194:	1a d8       	st.w	--sp,r8
80002196:	48 9c       	lddpc	r12,800021b8 <EnOB_reply_func+0x6c>
80002198:	f0 1f 00 04 	mcall	800021a8 <EnOB_reply_func+0x5c>
8000219c:	2f fd       	sub	sp,-4
8000219e:	e3 cd 80 80 	ldm	sp++,r7,pc
800021a2:	00 00       	add	r0,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	e0 90 80 00 	breq	800321a6 <_data_lma+0x22b96>
800021aa:	7e fc       	ld.w	r12,pc[0x3c]
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	e0 a8       	*unknown*
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	e0 bc       	*unknown*
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	e0 d4 80 00 	satsub.w	r4,r0,-32768
800021ba:	e0 f0 eb cd 	ld.w	r0,r0[-5171]

800021bc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021bc:	eb cd 40 80 	pushm	r7,lr
800021c0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021c2:	19 a9       	ld.ub	r9,r12[0x2]
800021c4:	31 18       	mov	r8,17
800021c6:	f0 09 18 00 	cp.b	r9,r8
800021ca:	c0 91       	brne	800021dc <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021cc:	48 ac       	lddpc	r12,800021f4 <SingleDetection_brdcst_func+0x38>
800021ce:	f0 1f 00 0b 	mcall	800021f8 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021d2:	30 19       	mov	r9,1
800021d4:	48 a8       	lddpc	r8,800021fc <SingleDetection_brdcst_func+0x40>
800021d6:	b0 89       	st.b	r8[0x0],r9
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021dc:	48 9c       	lddpc	r12,80002200 <SingleDetection_brdcst_func+0x44>
800021de:	f0 1f 00 07 	mcall	800021f8 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 8c       	lddpc	r12,80002204 <SingleDetection_brdcst_func+0x48>
800021e8:	f0 1f 00 04 	mcall	800021f8 <SingleDetection_brdcst_func+0x3c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	e1 08 80 00 	ld.sh	r8,r0[-32768]
800021fa:	7e fc       	ld.w	r12,pc[0x3c]
800021fc:	00 00       	add	r0,r0
800021fe:	00 04       	add	r4,r0
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	e1 1c 80 00 	ld.uh	r12,r0[-32768]
80002206:	e1 2c d4 31 	ld.sb	r12,r0[-11215]

80002208 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002208:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000220a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000220e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002210:	4a bc       	lddpc	r12,800022bc <ButtonConfig_brdcst_func+0xb4>
80002212:	f0 1f 00 2c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002216:	0f 88       	ld.ub	r8,r7[0x0]
80002218:	1a d8       	st.w	--sp,r8
8000221a:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xbc>
8000221c:	f0 1f 00 29 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002220:	1a d5       	st.w	--sp,r5
80002222:	4a ac       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xc0>
80002224:	f0 1f 00 27 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002228:	0f a8       	ld.ub	r8,r7[0x2]
8000222a:	1a d8       	st.w	--sp,r8
8000222c:	4a 8c       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xc4>
8000222e:	f0 1f 00 25 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002232:	2f dd       	sub	sp,-12
80002234:	58 05       	cp.w	r5,0
80002236:	c4 10       	breq	800022b8 <ButtonConfig_brdcst_func+0xb0>
80002238:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000223a:	4a 64       	lddpc	r4,800022d0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000223c:	4a 63       	lddpc	r3,800022d4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000223e:	4a 72       	lddpc	r2,800022d8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002240:	4a 71       	lddpc	r1,800022dc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002242:	4a 80       	lddpc	r0,800022e0 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002244:	0f b9       	ld.ub	r9,r7[0x3]
80002246:	0f c8       	ld.ub	r8,r7[0x4]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	08 9c       	mov	r12,r4
80002252:	f0 1f 00 1c 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002256:	0f d9       	ld.ub	r9,r7[0x5]
80002258:	0f e8       	ld.ub	r8,r7[0x6]
8000225a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225e:	1a d8       	st.w	--sp,r8
80002260:	1a d6       	st.w	--sp,r6
80002262:	06 9c       	mov	r12,r3
80002264:	f0 1f 00 17 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002268:	0f f9       	ld.ub	r9,r7[0x7]
8000226a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	04 9c       	mov	r12,r2
80002278:	f0 1f 00 12 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000227c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002280:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002284:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002288:	1a d8       	st.w	--sp,r8
8000228a:	1a d6       	st.w	--sp,r6
8000228c:	02 9c       	mov	r12,r1
8000228e:	f0 1f 00 0d 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002292:	2f 8d       	sub	sp,-32
80002294:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002298:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000229c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a0:	1a d8       	st.w	--sp,r8
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	00 9c       	mov	r12,r0
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_brdcst_func+0xb8>
800022aa:	2f f6       	sub	r6,-1
800022ac:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ae:	2f ed       	sub	sp,-8
800022b0:	ec 05 18 00 	cp.b	r5,r6
800022b4:	fe 9b ff c8 	brhi	80002244 <ButtonConfig_brdcst_func+0x3c>
800022b8:	d8 32       	popm	r0-r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	e1 40 80 00 	st.w	r0[-32768],r0
800022c2:	7e fc       	ld.w	r12,pc[0x3c]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	e1 60 80 00 	st.b	r0[-32768],r0
800022ca:	e1 74 80 00 	stcond	r0[-32768],r4
800022ce:	e1 8c       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	e1 ac 80 00 	cop	cp4,cr0,cr0,cr0,0x18
800022d6:	e1 d4 80 00 	ldswp.w	r4,r0[0]
800022da:	e1 fc 80 00 	ld.wls	r12,r0[0x0]
800022de:	e2 20 80 00 	sub	r0,163840
800022e2:	e2 48 eb cd 	cp.w	r8,191437

800022e4 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022e4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022e8:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022ec:	0f 89       	ld.ub	r9,r7[0x0]
800022ee:	30 08       	mov	r8,0
800022f0:	f0 09 18 00 	cp.b	r9,r8
800022f4:	c0 c1       	brne	8000230c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022f6:	48 9c       	lddpc	r12,80002318 <ButtonConfig_reply_func+0x34>
800022f8:	f0 1f 00 09 	mcall	8000231c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022fc:	0f 98       	ld.ub	r8,r7[0x1]
800022fe:	1a d8       	st.w	--sp,r8
80002300:	48 8c       	lddpc	r12,80002320 <ButtonConfig_reply_func+0x3c>
80002302:	f0 1f 00 07 	mcall	8000231c <ButtonConfig_reply_func+0x38>
80002306:	2f fd       	sub	sp,-4
80002308:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000230c:	48 6c       	lddpc	r12,80002324 <ButtonConfig_reply_func+0x40>
8000230e:	f0 1f 00 04 	mcall	8000231c <ButtonConfig_reply_func+0x38>
80002312:	e3 cd 80 80 	ldm	sp++,r7,pc
80002316:	00 00       	add	r0,r0
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	e2 6c 80 00 	mov	r12,163840
8000231e:	7e fc       	ld.w	r12,pc[0x3c]
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	e1 60 80 00 	st.b	r0[-32768],r0
80002326:	e2 84 eb cd 	brge	8005fac0 <_data_lma+0x504b0>

80002328 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002328:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
8000232c:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
80002330:	0f 89       	ld.ub	r9,r7[0x0]
80002332:	30 08       	mov	r8,0
80002334:	f0 09 18 00 	cp.b	r9,r8
80002338:	c0 51       	brne	80002342 <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
8000233a:	48 cc       	lddpc	r12,80002368 <BatteryLevel_brdcst_func+0x40>
8000233c:	f0 1f 00 0c 	mcall	8000236c <BatteryLevel_brdcst_func+0x44>
80002340:	c0 48       	rjmp	80002348 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
80002342:	48 cc       	lddpc	r12,80002370 <BatteryLevel_brdcst_func+0x48>
80002344:	f0 1f 00 0a 	mcall	8000236c <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002348:	0f 98       	ld.ub	r8,r7[0x1]
8000234a:	1a d8       	st.w	--sp,r8
8000234c:	48 ac       	lddpc	r12,80002374 <BatteryLevel_brdcst_func+0x4c>
8000234e:	f0 1f 00 08 	mcall	8000236c <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
80002352:	8e 98       	ld.uh	r8,r7[0x2]
80002354:	1a d8       	st.w	--sp,r8
80002356:	48 9c       	lddpc	r12,80002378 <BatteryLevel_brdcst_func+0x50>
80002358:	f0 1f 00 05 	mcall	8000236c <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
8000235c:	0f 89       	ld.ub	r9,r7[0x0]
8000235e:	48 88       	lddpc	r8,8000237c <BatteryLevel_brdcst_func+0x54>
80002360:	b0 89       	st.b	r8[0x0],r9
80002362:	2f ed       	sub	sp,-8

}
80002364:	e3 cd 80 80 	ldm	sp++,r7,pc
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	e2 a0 80 00 	rcall	8005236a <_data_lma+0x42d5a>
8000236e:	7e fc       	ld.w	r12,pc[0x3c]
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	e2 b0 80 00 	rcall	80072372 <_data_lma+0x62d62>
80002376:	e2 c4 80 00 	sub	r4,r1,-32768
8000237a:	e2 dc 00 00 	satsub.w	r12,r1,0
8000237e:	0a 81       	andn	r1,r5

80002380 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
80002382:	19 a8       	ld.ub	r8,r12[0x2]
80002384:	30 19       	mov	r9,1
80002386:	f2 08 18 00 	cp.b	r8,r9
8000238a:	c0 51       	brne	80002394 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
8000238c:	48 6c       	lddpc	r12,800023a4 <ShutDown_brdcst_func+0x24>
8000238e:	f0 1f 00 07 	mcall	800023a8 <ShutDown_brdcst_func+0x28>
80002392:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002394:	30 29       	mov	r9,2
80002396:	f2 08 18 00 	cp.b	r8,r9
8000239a:	c0 41       	brne	800023a2 <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
8000239c:	48 4c       	lddpc	r12,800023ac <ShutDown_brdcst_func+0x2c>
8000239e:	f0 1f 00 03 	mcall	800023a8 <ShutDown_brdcst_func+0x28>
800023a2:	d8 02       	popm	pc
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	e2 f4 80 00 	ld.w	r4,r1[-32768]
800023aa:	7e fc       	ld.w	r12,pc[0x3c]
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	e3 08 eb cd 	ld.sh	r8,r1[-5171]

800023b0 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b0:	eb cd 40 80 	pushm	r7,lr
800023b4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023b6:	19 a9       	ld.ub	r9,r12[0x2]
800023b8:	30 08       	mov	r8,0
800023ba:	f0 09 18 00 	cp.b	r9,r8
800023be:	c0 61       	brne	800023ca <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
800023c0:	48 dc       	lddpc	r12,800023f4 <DataSession_reply_func+0x44>
800023c2:	f0 1f 00 0e 	mcall	800023f8 <DataSession_reply_func+0x48>
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
800023ca:	48 dc       	lddpc	r12,800023fc <DataSession_reply_func+0x4c>
800023cc:	f0 1f 00 0b 	mcall	800023f8 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
800023d0:	0f a8       	ld.ub	r8,r7[0x2]
800023d2:	1a d8       	st.w	--sp,r8
800023d4:	48 bc       	lddpc	r12,80002400 <DataSession_reply_func+0x50>
800023d6:	f0 1f 00 09 	mcall	800023f8 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
800023da:	0f b8       	ld.ub	r8,r7[0x3]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	48 ac       	lddpc	r12,80002404 <DataSession_reply_func+0x54>
800023e0:	f0 1f 00 06 	mcall	800023f8 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
800023e4:	0f c8       	ld.ub	r8,r7[0x4]
800023e6:	1a d8       	st.w	--sp,r8
800023e8:	48 8c       	lddpc	r12,80002408 <DataSession_reply_func+0x58>
800023ea:	f0 1f 00 04 	mcall	800023f8 <DataSession_reply_func+0x48>
800023ee:	2f dd       	sub	sp,-12
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	e3 18 80 00 	ld.uh	r8,r1[-32768]
800023fa:	7e fc       	ld.w	r12,pc[0x3c]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	e3 28 80 00 	ld.sb	r8,r1[-32768]
80002402:	e3 38 80 00 	ld.ub	r8,r1[-32768]
80002406:	e3 48 80 00 	st.w	r1[-32768],r8
8000240a:	e3 54 eb cd 	st.h	r1[-5171],r4

8000240c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002414:	0f 98       	ld.ub	r8,r7[0x1]
80002416:	1a d8       	st.w	--sp,r8
80002418:	48 bc       	lddpc	r12,80002444 <CallControl_brdcst_func+0x38>
8000241a:	f0 1f 00 0c 	mcall	80002448 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000241e:	2f fd       	sub	sp,-4
80002420:	0f 99       	ld.ub	r9,r7[0x1]
80002422:	30 38       	mov	r8,3
80002424:	f0 09 18 00 	cp.b	r9,r8
80002428:	c0 41       	brne	80002430 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000242a:	30 09       	mov	r9,0
8000242c:	48 88       	lddpc	r8,8000244c <CallControl_brdcst_func+0x40>
8000242e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002430:	0f 99       	ld.ub	r9,r7[0x1]
80002432:	30 48       	mov	r8,4
80002434:	f0 09 18 00 	cp.b	r9,r8
80002438:	c0 41       	brne	80002440 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000243a:	30 19       	mov	r9,1
8000243c:	48 48       	lddpc	r8,8000244c <CallControl_brdcst_func+0x40>
8000243e:	b0 89       	st.b	r8[0x0],r9
80002440:	e3 cd 80 80 	ldm	sp++,r7,pc
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	e3 60 80 00 	st.b	r1[-32768],r0
8000244a:	7e fc       	ld.w	r12,pc[0x3c]
8000244c:	00 00       	add	r0,r0
8000244e:	0a 83       	andn	r3,r5

80002450 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002450:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002454:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002458:	0f 99       	ld.ub	r9,r7[0x1]
8000245a:	30 08       	mov	r8,0
8000245c:	f0 09 18 00 	cp.b	r9,r8
80002460:	c0 71       	brne	8000246e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002462:	48 ac       	lddpc	r12,80002488 <TransmitControl_brdcst_func+0x38>
80002464:	f0 1f 00 0a 	mcall	8000248c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002468:	30 09       	mov	r9,0
8000246a:	48 a8       	lddpc	r8,80002490 <TransmitControl_brdcst_func+0x40>
8000246c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000246e:	0f 99       	ld.ub	r9,r7[0x1]
80002470:	30 18       	mov	r8,1
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 71       	brne	80002484 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002478:	48 7c       	lddpc	r12,80002494 <TransmitControl_brdcst_func+0x44>
8000247a:	f0 1f 00 05 	mcall	8000248c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000247e:	30 19       	mov	r9,1
80002480:	48 48       	lddpc	r8,80002490 <TransmitControl_brdcst_func+0x40>
80002482:	b0 89       	st.b	r8[0x0],r9
80002484:	e3 cd 80 80 	ldm	sp++,r7,pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	e3 78 80 00 	stcond	r1[-32768],r8
8000248e:	7e fc       	ld.w	r12,pc[0x3c]
80002490:	00 00       	add	r0,r0
80002492:	0a 60       	and	r0,r5
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	e3 90       	*unknown*

80002498 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002498:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000249c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024a0:	0f 89       	ld.ub	r9,r7[0x0]
800024a2:	30 08       	mov	r8,0
800024a4:	f0 09 18 00 	cp.b	r9,r8
800024a8:	c1 61       	brne	800024d4 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024aa:	48 ec       	lddpc	r12,800024e0 <TransmitControl_reply_func+0x48>
800024ac:	f0 1f 00 0e 	mcall	800024e4 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024b0:	0f 98       	ld.ub	r8,r7[0x1]
800024b2:	1a d8       	st.w	--sp,r8
800024b4:	48 dc       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x50>
800024b6:	f0 1f 00 0c 	mcall	800024e4 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024ba:	0f a8       	ld.ub	r8,r7[0x2]
800024bc:	1a d8       	st.w	--sp,r8
800024be:	48 cc       	lddpc	r12,800024ec <TransmitControl_reply_func+0x54>
800024c0:	f0 1f 00 09 	mcall	800024e4 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024c4:	0f b8       	ld.ub	r8,r7[0x3]
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 ac       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x58>
800024ca:	f0 1f 00 07 	mcall	800024e4 <TransmitControl_reply_func+0x4c>
800024ce:	2f dd       	sub	sp,-12
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d4:	48 8c       	lddpc	r12,800024f4 <TransmitControl_reply_func+0x5c>
800024d6:	f0 1f 00 04 	mcall	800024e4 <TransmitControl_reply_func+0x4c>
800024da:	e3 cd 80 80 	ldm	sp++,r7,pc
800024de:	00 00       	add	r0,r0
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	e3 a4 80 00 	cop	cp4,cr0,cr0,cr0,0x28
800024e6:	7e fc       	ld.w	r12,pc[0x3c]
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	e3 c0 80 00 	ldm	r0++,pc
800024ee:	e3 d4 80 00 	ldswp.w	r4,r1[0]
800024f2:	e3 f0 80 00 	ld.wls	r0,r1[0x0]
800024f6:	e4 00       	*unknown*

800024f8 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024fa:	19 a9       	ld.ub	r9,r12[0x2]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 51       	brne	8000250c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002504:	48 4c       	lddpc	r12,80002514 <AudioRoutingControl_reply_func+0x1c>
80002506:	f0 1f 00 05 	mcall	80002518 <AudioRoutingControl_reply_func+0x20>
8000250a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000250c:	48 4c       	lddpc	r12,8000251c <AudioRoutingControl_reply_func+0x24>
8000250e:	f0 1f 00 03 	mcall	80002518 <AudioRoutingControl_reply_func+0x20>
80002512:	d8 02       	popm	pc
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	e4 18 80 00 	andh	r8,0x8000
8000251a:	7e fc       	ld.w	r12,pc[0x3c]
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	e4 28 eb cd 	sub	r8,322509

80002520 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002520:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002524:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002528:	0f 89       	ld.ub	r9,r7[0x0]
8000252a:	30 08       	mov	r8,0
8000252c:	f0 09 18 00 	cp.b	r9,r8
80002530:	c1 b1       	brne	80002566 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002532:	0f b8       	ld.ub	r8,r7[0x3]
80002534:	31 09       	mov	r9,16
80002536:	f2 08 18 00 	cp.b	r8,r9
8000253a:	c0 f1       	brne	80002558 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000253c:	48 dc       	lddpc	r12,80002570 <Volume_reply_func+0x50>
8000253e:	f0 1f 00 0e 	mcall	80002574 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002542:	0f 99       	ld.ub	r9,r7[0x1]
80002544:	0f a8       	ld.ub	r8,r7[0x2]
80002546:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	48 bc       	lddpc	r12,80002578 <Volume_reply_func+0x58>
8000254e:	f0 1f 00 0a 	mcall	80002574 <Volume_reply_func+0x54>
80002552:	2f fd       	sub	sp,-4
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002558:	1a d8       	st.w	--sp,r8
8000255a:	48 9c       	lddpc	r12,8000257c <Volume_reply_func+0x5c>
8000255c:	f0 1f 00 06 	mcall	80002574 <Volume_reply_func+0x54>
80002560:	2f fd       	sub	sp,-4
80002562:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002566:	48 7c       	lddpc	r12,80002580 <Volume_reply_func+0x60>
80002568:	f0 1f 00 03 	mcall	80002574 <Volume_reply_func+0x54>
8000256c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	e4 3c 80 00 	sub	r12,360448
80002576:	7e fc       	ld.w	r12,pc[0x3c]
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	e4 50 80 00 	cp.w	r0,360448
8000257e:	e4 6c 80 00 	mov	r12,294912
80002582:	e4 84 d4 01 	brge	8009cd84 <_data_lma+0x8d774>

80002584 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002584:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002586:	19 d9       	ld.ub	r9,r12[0x5]
80002588:	30 08       	mov	r8,0
8000258a:	f0 09 18 00 	cp.b	r9,r8
8000258e:	c0 81       	brne	8000259e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002590:	10 99       	mov	r9,r8
80002592:	48 78       	lddpc	r8,800025ac <spk_brdcst_func+0x28>
80002594:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002596:	48 7c       	lddpc	r12,800025b0 <spk_brdcst_func+0x2c>
80002598:	f0 1f 00 07 	mcall	800025b4 <spk_brdcst_func+0x30>
8000259c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000259e:	30 19       	mov	r9,1
800025a0:	48 38       	lddpc	r8,800025ac <spk_brdcst_func+0x28>
800025a2:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025a4:	48 5c       	lddpc	r12,800025b8 <spk_brdcst_func+0x34>
800025a6:	f0 1f 00 04 	mcall	800025b4 <spk_brdcst_func+0x30>
800025aa:	d8 02       	popm	pc
800025ac:	00 00       	add	r0,r0
800025ae:	0a 79       	tst	r9,r5
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	e4 9c 80 00 	brvs	800b25b2 <_data_lma+0xa2fa2>
800025b6:	7e fc       	ld.w	r12,pc[0x3c]
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	e4 ac       	*unknown*

800025bc <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025bc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025be:	19 a9       	ld.ub	r9,r12[0x2]
800025c0:	30 08       	mov	r8,0
800025c2:	f0 09 18 00 	cp.b	r9,r8
800025c6:	c0 f1       	brne	800025e4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025c8:	19 e9       	ld.ub	r9,r12[0x6]
800025ca:	f0 09 18 00 	cp.b	r9,r8
800025ce:	c0 40       	breq	800025d6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025d0:	30 19       	mov	r9,1
800025d2:	48 98       	lddpc	r8,800025f4 <spk_reply_func+0x38>
800025d4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025d6:	19 e8       	ld.ub	r8,r12[0x6]
800025d8:	1a d8       	st.w	--sp,r8
800025da:	48 8c       	lddpc	r12,800025f8 <spk_reply_func+0x3c>
800025dc:	f0 1f 00 08 	mcall	800025fc <spk_reply_func+0x40>
800025e0:	2f fd       	sub	sp,-4
800025e2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025e4:	30 09       	mov	r9,0
800025e6:	48 48       	lddpc	r8,800025f4 <spk_reply_func+0x38>
800025e8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025ea:	48 6c       	lddpc	r12,80002600 <spk_reply_func+0x44>
800025ec:	f0 1f 00 04 	mcall	800025fc <spk_reply_func+0x40>
800025f0:	d8 02       	popm	pc
800025f2:	00 00       	add	r0,r0
800025f4:	00 00       	add	r0,r0
800025f6:	0a 79       	tst	r9,r5
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	e4 b8       	*unknown*
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	7e fc       	ld.w	r12,pc[0x3c]
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	e4 c8 eb cd 	sub	r8,r2,-5171

80002604 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002604:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002608:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000260c:	0f a9       	ld.ub	r9,r7[0x2]
8000260e:	30 08       	mov	r8,0
80002610:	f0 09 18 00 	cp.b	r9,r8
80002614:	c0 71       	brne	80002622 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002616:	48 dc       	lddpc	r12,80002648 <mic_brdcst_func+0x44>
80002618:	f0 1f 00 0d 	mcall	8000264c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000261c:	30 09       	mov	r9,0
8000261e:	48 d8       	lddpc	r8,80002650 <mic_brdcst_func+0x4c>
80002620:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002622:	0f a9       	ld.ub	r9,r7[0x2]
80002624:	31 18       	mov	r8,17
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 d1       	brne	80002644 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000262c:	48 ac       	lddpc	r12,80002654 <mic_brdcst_func+0x50>
8000262e:	f0 1f 00 08 	mcall	8000264c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002632:	48 89       	lddpc	r9,80002650 <mic_brdcst_func+0x4c>
80002634:	30 18       	mov	r8,1
80002636:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002638:	13 89       	ld.ub	r9,r9[0x0]
8000263a:	f0 09 18 00 	cp.b	r9,r8
8000263e:	c0 31       	brne	80002644 <mic_brdcst_func+0x40>
80002640:	48 68       	lddpc	r8,80002658 <mic_brdcst_func+0x54>
80002642:	11 88       	ld.ub	r8,r8[0x0]
80002644:	e3 cd 80 80 	ldm	sp++,r7,pc
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	e4 d4 80 00 	satsub.w	r4,r2,-32768
8000264e:	7e fc       	ld.w	r12,pc[0x3c]
80002650:	00 00       	add	r0,r0
80002652:	0a 78       	tst	r8,r5
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	e4 e8 00 00 	ld.d	r8,r2[0]
8000265a:	0a 83       	andn	r3,r5

8000265c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000265c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002660:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002664:	49 ac       	lddpc	r12,800026cc <mic_reply_func+0x70>
80002666:	f0 1f 00 1b 	mcall	800026d0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000266a:	0f 89       	ld.ub	r9,r7[0x0]
8000266c:	30 08       	mov	r8,0
8000266e:	f0 09 18 00 	cp.b	r9,r8
80002672:	c2 71       	brne	800026c0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002674:	0f 98       	ld.ub	r8,r7[0x1]
80002676:	30 29       	mov	r9,2
80002678:	f2 08 18 00 	cp.b	r8,r9
8000267c:	c1 b1       	brne	800026b2 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000267e:	49 6c       	lddpc	r12,800026d4 <mic_reply_func+0x78>
80002680:	f0 1f 00 14 	mcall	800026d0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	49 4c       	lddpc	r12,800026d8 <mic_reply_func+0x7c>
8000268a:	f0 1f 00 12 	mcall	800026d0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000268e:	0f b8       	ld.ub	r8,r7[0x3]
80002690:	1a d8       	st.w	--sp,r8
80002692:	49 3c       	lddpc	r12,800026dc <mic_reply_func+0x80>
80002694:	f0 1f 00 0f 	mcall	800026d0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002698:	0f c8       	ld.ub	r8,r7[0x4]
8000269a:	1a d8       	st.w	--sp,r8
8000269c:	49 1c       	lddpc	r12,800026e0 <mic_reply_func+0x84>
8000269e:	f0 1f 00 0d 	mcall	800026d0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026a2:	0f d8       	ld.ub	r8,r7[0x5]
800026a4:	1a d8       	st.w	--sp,r8
800026a6:	49 0c       	lddpc	r12,800026e4 <mic_reply_func+0x88>
800026a8:	f0 1f 00 0a 	mcall	800026d0 <mic_reply_func+0x74>
800026ac:	2f cd       	sub	sp,-16
800026ae:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	48 dc       	lddpc	r12,800026e8 <mic_reply_func+0x8c>
800026b6:	f0 1f 00 07 	mcall	800026d0 <mic_reply_func+0x74>
800026ba:	2f fd       	sub	sp,-4
800026bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c0:	48 bc       	lddpc	r12,800026ec <mic_reply_func+0x90>
800026c2:	f0 1f 00 04 	mcall	800026d0 <mic_reply_func+0x74>
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ca:	00 00       	add	r0,r0
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	e4 fc 80 00 	ld.w	r12,r2[-32768]
800026d2:	7e fc       	ld.w	r12,pc[0x3c]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	e5 0c 80 00 	ld.sh	r12,r2[-32768]
800026da:	e5 20 80 00 	ld.sb	r0,r2[-32768]
800026de:	e5 34 80 00 	ld.ub	r4,r2[-32768]
800026e2:	e5 50 80 00 	st.h	r2[-32768],r0
800026e6:	e5 68 80 00 	st.b	r2[-32768],r8
800026ea:	e5 80       	*unknown*
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	e5 98       	*unknown*

800026f0 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f8:	48 bc       	lddpc	r12,80002724 <dcm_brdcst_func+0x34>
800026fa:	f0 1f 00 0c 	mcall	80002728 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026fe:	0f 88       	ld.ub	r8,r7[0x0]
80002700:	1a d8       	st.w	--sp,r8
80002702:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x3c>
80002704:	f0 1f 00 09 	mcall	80002728 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002708:	0f a8       	ld.ub	r8,r7[0x2]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	48 9c       	lddpc	r12,80002730 <dcm_brdcst_func+0x40>
8000270e:	f0 1f 00 07 	mcall	80002728 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002712:	0f 98       	ld.ub	r8,r7[0x1]
80002714:	1a d8       	st.w	--sp,r8
80002716:	48 8c       	lddpc	r12,80002734 <dcm_brdcst_func+0x44>
80002718:	f0 1f 00 04 	mcall	80002728 <dcm_brdcst_func+0x38>
8000271c:	2f dd       	sub	sp,-12
	
	
}
8000271e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002722:	00 00       	add	r0,r0
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	e5 a8 80 00 	cop	cp4,cr0,cr0,cr0,0x50
8000272a:	7e fc       	ld.w	r12,pc[0x3c]
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	e5 bc       	*unknown*
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	e5 d0 80 00 	ldswp.w	r0,r2[0]
80002736:	e5 e8 eb cd 	sthh.w	sp[0x2f0],r2:t,r8:b

80002738 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002738:	eb cd 40 80 	pushm	r7,lr
8000273c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000273e:	19 a9       	ld.ub	r9,r12[0x2]
80002740:	30 08       	mov	r8,0
80002742:	f0 09 18 00 	cp.b	r9,r8
80002746:	c1 b1       	brne	8000277c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002748:	19 b8       	ld.ub	r8,r12[0x3]
8000274a:	30 19       	mov	r9,1
8000274c:	f2 08 18 00 	cp.b	r8,r9
80002750:	c0 51       	brne	8000275a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002752:	48 ec       	lddpc	r12,80002788 <dcm_reply_func+0x50>
80002754:	f0 1f 00 0e 	mcall	8000278c <dcm_reply_func+0x54>
80002758:	c0 a8       	rjmp	8000276c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000275a:	58 08       	cp.w	r8,0
8000275c:	c0 51       	brne	80002766 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000275e:	48 dc       	lddpc	r12,80002790 <dcm_reply_func+0x58>
80002760:	f0 1f 00 0b 	mcall	8000278c <dcm_reply_func+0x54>
80002764:	c0 48       	rjmp	8000276c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002766:	48 cc       	lddpc	r12,80002794 <dcm_reply_func+0x5c>
80002768:	f0 1f 00 09 	mcall	8000278c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000276c:	0f d8       	ld.ub	r8,r7[0x5]
8000276e:	1a d8       	st.w	--sp,r8
80002770:	48 ac       	lddpc	r12,80002798 <dcm_reply_func+0x60>
80002772:	f0 1f 00 07 	mcall	8000278c <dcm_reply_func+0x54>
80002776:	2f fd       	sub	sp,-4
80002778:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000277c:	48 8c       	lddpc	r12,8000279c <dcm_reply_func+0x64>
8000277e:	f0 1f 00 04 	mcall	8000278c <dcm_reply_func+0x54>
80002782:	e3 cd 80 80 	ldm	sp++,r7,pc
80002786:	00 00       	add	r0,r0
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	e6 04       	*unknown*
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	7e fc       	ld.w	r12,pc[0x3c]
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	e6 18 80 00 	andh	r8,0x8000,COH
80002796:	e6 2c 80 00 	sub	r12,425984
8000279a:	e6 40 80 00 	cp.w	r0,425984
8000279e:	e6 4c d4 01 	cp.w	r12,447489

800027a0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a2:	19 a9       	ld.ub	r9,r12[0x2]
800027a4:	30 08       	mov	r8,0
800027a6:	f0 09 18 00 	cp.b	r9,r8
800027aa:	c0 51       	brne	800027b4 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027ac:	48 4c       	lddpc	r12,800027bc <ToneControl_reply_func+0x1c>
800027ae:	f0 1f 00 05 	mcall	800027c0 <ToneControl_reply_func+0x20>
800027b2:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x24>
800027b6:	f0 1f 00 03 	mcall	800027c0 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	e6 58 80 00 	cp.w	r8,491520
800027c2:	7e fc       	ld.w	r12,pc[0x3c]
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	e6 64 d4 31 	mov	r4,447537

800027c8 <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027c8:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027ca:	32 0c       	mov	r12,32
800027cc:	f0 1f 00 34 	mcall	8000289c <send_message+0xd4>
800027d0:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 34 	mcall	800028a0 <send_message+0xd8>
800027d6:	4b 48       	lddpc	r8,800028a4 <send_message+0xdc>
800027d8:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027da:	4b 45       	lddpc	r5,800028a8 <send_message+0xe0>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800027dc:	4b 47       	lddpc	r7,800028ac <send_message+0xe4>
800027de:	30 16       	mov	r6,1
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027e0:	4b 43       	lddpc	r3,800028b0 <send_message+0xe8>
		{
			log("Current_total_message_count: %d\n", message_count);
800027e2:	4b 50       	lddpc	r0,800028b4 <send_message+0xec>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
800027e4:	30 12       	mov	r2,1
800027e6:	4b 51       	lddpc	r1,800028b8 <send_message+0xf0>
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027e8:	f0 1f 00 35 	mcall	800028bc <send_message+0xf4>
800027ec:	5c 8c       	casts.h	r12
800027ee:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027f0:	c4 80       	breq	80002880 <send_message+0xb8>
800027f2:	0f 88       	ld.ub	r8,r7[0x0]
800027f4:	58 08       	cp.w	r8,0
800027f6:	c4 51       	brne	80002880 <send_message+0xb8>
800027f8:	07 88       	ld.ub	r8,r3[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c4 20       	breq	80002880 <send_message+0xb8>
		{
			log("Current_total_message_count: %d\n", message_count);
800027fe:	5c 7c       	castu.h	r12
80002800:	1a dc       	st.w	--sp,r12
80002802:	00 9c       	mov	r12,r0
80002804:	f0 1f 00 2f 	mcall	800028c0 <send_message+0xf8>
			if(m_buff==NULL)break;
80002808:	2f fd       	sub	sp,-4
8000280a:	58 04       	cp.w	r4,0
8000280c:	c4 70       	breq	8000289a <send_message+0xd2>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
8000280e:	04 9a       	mov	r10,r2
80002810:	08 9b       	mov	r11,r4
80002812:	8a 8c       	ld.uh	r12,r5[0x0]
80002814:	f0 1f 00 2c 	mcall	800028c4 <send_message+0xfc>
80002818:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
8000281a:	c2 d1       	brne	80002874 <send_message+0xac>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
8000281c:	36 4a       	mov	r10,100
8000281e:	32 0b       	mov	r11,32
80002820:	08 9c       	mov	r12,r4
80002822:	f0 1f 00 2a 	mcall	800028c8 <send_message+0x100>
				if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
80002826:	4a a8       	lddpc	r8,800028cc <send_message+0x104>
80002828:	70 0c       	ld.w	r12,r8[0x0]
8000282a:	30 09       	mov	r9,0
8000282c:	e0 6a 9c 40 	mov	r10,40000
80002830:	12 9b       	mov	r11,r9
80002832:	f0 1f 00 28 	mcall	800028d0 <send_message+0x108>
80002836:	58 1c       	cp.w	r12,1
80002838:	c0 51       	brne	80002842 <send_message+0x7a>
				{
					log("xSemaphoreTake okay!\n");
8000283a:	4a 7c       	lddpc	r12,800028d4 <send_message+0x10c>
8000283c:	f0 1f 00 21 	mcall	800028c0 <send_message+0xf8>
80002840:	c2 78       	rjmp	8000288e <send_message+0xc6>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002842:	4a 6c       	lddpc	r12,800028d8 <send_message+0x110>
80002844:	f0 1f 00 1f 	mcall	800028c0 <send_message+0xf8>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002848:	e0 6b 00 b7 	mov	r11,183
8000284c:	04 9c       	mov	r12,r2
8000284e:	f0 1f 00 24 	mcall	800028dc <send_message+0x114>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002852:	04 9a       	mov	r10,r2
80002854:	32 0b       	mov	r11,32
80002856:	08 9c       	mov	r12,r4
80002858:	f0 1f 00 22 	mcall	800028e0 <send_message+0x118>
8000285c:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
8000285e:	c0 51       	brne	80002868 <send_message+0xa0>
					{
						log("save message okay\n");
80002860:	4a 1c       	lddpc	r12,800028e4 <send_message+0x11c>
80002862:	f0 1f 00 18 	mcall	800028c0 <send_message+0xf8>
80002866:	c1 48       	rjmp	8000288e <send_message+0xc6>
					}
					else
					{
						log("save message err : %d\n", status);
80002868:	1a dc       	st.w	--sp,r12
8000286a:	4a 0c       	lddpc	r12,800028e8 <send_message+0x120>
8000286c:	f0 1f 00 15 	mcall	800028c0 <send_message+0xf8>
80002870:	2f fd       	sub	sp,-4
80002872:	c0 e8       	rjmp	8000288e <send_message+0xc6>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
80002874:	1a dc       	st.w	--sp,r12
80002876:	49 ec       	lddpc	r12,800028ec <send_message+0x124>
80002878:	f0 1f 00 12 	mcall	800028c0 <send_message+0xf8>
8000287c:	2f fd       	sub	sp,-4
8000287e:	c0 88       	rjmp	8000288e <send_message+0xc6>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002880:	0f 88       	ld.ub	r8,r7[0x0]
80002882:	ec 08 18 00 	cp.b	r8,r6
80002886:	c0 41       	brne	8000288e <send_message+0xc6>
		{
			log("The device battery level is low !\n");
80002888:	49 ac       	lddpc	r12,800028f0 <send_message+0x128>
8000288a:	f0 1f 00 0e 	mcall	800028c0 <send_message+0xf8>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000288e:	e0 6b 07 d0 	mov	r11,2000
80002892:	48 5c       	lddpc	r12,800028a4 <send_message+0xdc>
80002894:	f0 1f 00 18 	mcall	800028f4 <send_message+0x12c>
	
	}
80002898:	ca 8b       	rjmp	800027e8 <send_message+0x20>
8000289a:	d8 32       	popm	r0-r7,pc
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	6f 58       	ld.w	r8,r7[0x54]
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	78 28       	ld.w	r8,r12[0x8]
800028a4:	00 00       	add	r0,r0
800028a6:	0a 6c       	and	r12,r5
800028a8:	00 00       	add	r0,r0
800028aa:	0a 6a       	and	r10,r5
800028ac:	00 00       	add	r0,r0
800028ae:	0a 81       	andn	r1,r5
800028b0:	00 00       	add	r0,r0
800028b2:	0a 70       	tst	r0,r5
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	e6 70 00 00 	mov	r0,458752
800028ba:	00 0c       	add	r12,r0
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	62 1c       	ld.w	r12,r1[0x4]
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	7e fc       	ld.w	r12,pc[0x3c]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	5e e0       	retqs	r0
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	47 e8       	lddsp	r8,sp[0x1f8]
800028cc:	00 00       	add	r0,r0
800028ce:	0b a8       	ld.ub	r8,r5[0x2]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	70 a0       	ld.w	r0,r8[0x28]
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	e6 94 80 00 	brge	800f28d6 <_data_lma+0xe32c6>
800028da:	e6 ac       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	49 24       	lddpc	r4,80002924 <app_cfg+0x2c>
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	60 8c       	ld.w	r12,r0[0x20]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	e6 c8 80 00 	sub	r8,r3,-32768
800028ea:	e6 dc 80 00 	satsub.w	r12,r3,-32768
800028ee:	e6 f4 80 00 	ld.w	r4,r3[-32768]
800028f2:	e7 0c 80 00 	ld.sh	r12,r3[-32768]
800028f6:	79 d8       	ld.w	r8,r12[0x74]

800028f8 <app_cfg>:
}

static __app_Thread_(app_cfg)
{
800028f8:	d4 31       	pushm	r0-r7,lr
800028fa:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800028fc:	f0 1f 00 42 	mcall	80002a04 <app_cfg+0x10c>
80002900:	4c 28       	lddpc	r8,80002a08 <app_cfg+0x110>
80002902:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002904:	4c 27       	lddpc	r7,80002a0c <app_cfg+0x114>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
80002906:	4c 35       	lddpc	r5,80002a10 <app_cfg+0x118>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002908:	36 41       	mov	r1,100
8000290a:	32 02       	mov	r2,32
8000290c:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
8000290e:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002910:	4c 14       	lddpc	r4,80002a14 <app_cfg+0x11c>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002912:	6e 08       	ld.w	r8,r7[0x0]
80002914:	58 28       	cp.w	r8,2
80002916:	c3 80       	breq	80002986 <app_cfg+0x8e>
80002918:	58 38       	cp.w	r8,3
8000291a:	c4 40       	breq	800029a2 <app_cfg+0xaa>
8000291c:	58 08       	cp.w	r8,0
8000291e:	c6 c1       	brne	800029f6 <app_cfg+0xfe>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002920:	4b e8       	lddpc	r8,80002a18 <app_cfg+0x120>
80002922:	70 08       	ld.w	r8,r8[0x0]
80002924:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002928:	58 38       	cp.w	r8,3
8000292a:	c1 61       	brne	80002956 <app_cfg+0x5e>
8000292c:	4b c8       	lddpc	r8,80002a1c <app_cfg+0x124>
8000292e:	11 88       	ld.ub	r8,r8[0x0]
80002930:	58 08       	cp.w	r8,0
80002932:	c1 21       	brne	80002956 <app_cfg+0x5e>
				{
					connect_flag=1;
80002934:	30 19       	mov	r9,1
80002936:	4b a8       	lddpc	r8,80002a1c <app_cfg+0x124>
80002938:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000293a:	30 cb       	mov	r11,12
8000293c:	30 1c       	mov	r12,1
8000293e:	f0 1f 00 39 	mcall	80002a20 <app_cfg+0x128>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002942:	30 cb       	mov	r11,12
80002944:	30 1c       	mov	r12,1
80002946:	f0 1f 00 37 	mcall	80002a20 <app_cfg+0x128>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
8000294a:	30 28       	mov	r8,2
8000294c:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
8000294e:	4b 6c       	lddpc	r12,80002a24 <app_cfg+0x12c>
80002950:	f0 1f 00 36 	mcall	80002a28 <app_cfg+0x130>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002954:	c5 18       	rjmp	800029f6 <app_cfg+0xfe>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002956:	d7 03       	nop
					nop();
80002958:	d7 03       	nop
					nop();
8000295a:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
8000295c:	4b 4c       	lddpc	r12,80002a2c <app_cfg+0x134>
8000295e:	f0 1f 00 33 	mcall	80002a28 <app_cfg+0x130>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002962:	4b 48       	lddpc	r8,80002a30 <app_cfg+0x138>
80002964:	11 de       	ld.ub	lr,r8[0x5]
80002966:	11 cc       	ld.ub	r12,r8[0x4]
80002968:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
8000296a:	11 aa       	ld.ub	r10,r8[0x2]
8000296c:	11 99       	ld.ub	r9,r8[0x1]
8000296e:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002970:	1a de       	st.w	--sp,lr
80002972:	1a dc       	st.w	--sp,r12
80002974:	1a db       	st.w	--sp,r11
80002976:	1a da       	st.w	--sp,r10
80002978:	1a d9       	st.w	--sp,r9
8000297a:	1a d8       	st.w	--sp,r8
8000297c:	4a ec       	lddpc	r12,80002a34 <app_cfg+0x13c>
8000297e:	f0 1f 00 2b 	mcall	80002a28 <app_cfg+0x130>
80002982:	2f ad       	sub	sp,-24
80002984:	c3 98       	rjmp	800029f6 <app_cfg+0xfe>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
80002986:	0b 88       	ld.ub	r8,r5[0x0]
80002988:	58 08       	cp.w	r8,0
8000298a:	c0 60       	breq	80002996 <app_cfg+0x9e>
							
							OB_State = OB_WAITINGAPPTASK;
8000298c:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
8000298e:	4a bc       	lddpc	r12,80002a38 <app_cfg+0x140>
80002990:	f0 1f 00 26 	mcall	80002a28 <app_cfg+0x130>
80002994:	c3 18       	rjmp	800029f6 <app_cfg+0xfe>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002996:	02 9a       	mov	r10,r1
80002998:	04 9b       	mov	r11,r2
8000299a:	0c 9c       	mov	r12,r6
8000299c:	f0 1f 00 28 	mcall	80002a3c <app_cfg+0x144>
800029a0:	c2 b8       	rjmp	800029f6 <app_cfg+0xfe>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800029a2:	68 0c       	ld.w	r12,r4[0x0]
800029a4:	0c 99       	mov	r9,r6
800029a6:	e0 6a 0f a0 	mov	r10,4000
800029aa:	1a 9b       	mov	r11,sp
800029ac:	f0 1f 00 25 	mcall	80002a40 <app_cfg+0x148>
800029b0:	58 1c       	cp.w	r12,1
800029b2:	c1 e1       	brne	800029ee <app_cfg+0xf6>
					{
						if(data_ptr!=NULL){//save message
800029b4:	40 08       	lddsp	r8,sp[0x0]
800029b6:	58 08       	cp.w	r8,0
800029b8:	c1 b0       	breq	800029ee <app_cfg+0xf6>
							
							log("receive okay!\n");
800029ba:	4a 3c       	lddpc	r12,80002a44 <app_cfg+0x14c>
800029bc:	f0 1f 00 1b 	mcall	80002a28 <app_cfg+0x130>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
800029c0:	30 1a       	mov	r10,1
800029c2:	04 9b       	mov	r11,r2
800029c4:	40 0c       	lddsp	r12,sp[0x0]
800029c6:	f0 1f 00 21 	mcall	80002a48 <app_cfg+0x150>
800029ca:	4a 18       	lddpc	r8,80002a4c <app_cfg+0x154>
800029cc:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
800029ce:	58 0c       	cp.w	r12,0
800029d0:	c0 51       	brne	800029da <app_cfg+0xe2>
							{
								log("save message okay\n");
800029d2:	4a 0c       	lddpc	r12,80002a50 <app_cfg+0x158>
800029d4:	f0 1f 00 15 	mcall	80002a28 <app_cfg+0x130>
800029d8:	c0 68       	rjmp	800029e4 <app_cfg+0xec>
							}
							else
							{
								log("save message err : %d\n", status);
800029da:	1a dc       	st.w	--sp,r12
800029dc:	49 ec       	lddpc	r12,80002a54 <app_cfg+0x15c>
800029de:	f0 1f 00 13 	mcall	80002a28 <app_cfg+0x130>
800029e2:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
800029e4:	49 d8       	lddpc	r8,80002a58 <app_cfg+0x160>
800029e6:	70 0c       	ld.w	r12,r8[0x0]
800029e8:	40 0b       	lddsp	r11,sp[0x0]
800029ea:	f0 1f 00 1d 	mcall	80002a5c <app_cfg+0x164>
							
						}
						
					}						
											
					nop();
800029ee:	d7 03       	nop
					//water_value = uxTaskGetStackHighWaterMark(NULL);
					//log("app-thread water_value: %d\n", water_value);
					log("app task run!\n");
800029f0:	49 cc       	lddpc	r12,80002a60 <app_cfg+0x168>
800029f2:	f0 1f 00 0e 	mcall	80002a28 <app_cfg+0x130>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (1500*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800029f6:	e0 6b 0b b8 	mov	r11,3000
800029fa:	48 4c       	lddpc	r12,80002a08 <app_cfg+0x110>
800029fc:	f0 1f 00 1a 	mcall	80002a64 <app_cfg+0x16c>
	}
80002a00:	c8 9b       	rjmp	80002912 <app_cfg+0x1a>
80002a02:	00 00       	add	r0,r0
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	78 28       	ld.w	r8,r12[0x8]
80002a08:	00 00       	add	r0,r0
80002a0a:	0a 7c       	tst	r12,r5
80002a0c:	00 00       	add	r0,r0
80002a0e:	0a 64       	and	r4,r5
80002a10:	00 00       	add	r0,r0
80002a12:	00 04       	add	r4,r0
80002a14:	00 00       	add	r0,r0
80002a16:	0b 90       	ld.ub	r0,r5[0x1]
80002a18:	00 00       	add	r0,r0
80002a1a:	0e 1c       	sub	r12,r7
80002a1c:	00 00       	add	r0,r0
80002a1e:	0a 70       	tst	r0,r5
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	49 24       	lddpc	r4,80002a68 <Phyuserinput_brdcst_func>
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	e7 30 80 00 	ld.ub	r0,r3[-32768]
80002a2a:	7e fc       	ld.w	r12,pc[0x3c]
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	e7 44 00 00 	st.w	r3[0],r4
80002a32:	0e 20       	rsub	r0,r7
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	e7 54 80 00 	st.h	r3[-32768],r4
80002a3a:	e7 80       	*unknown*
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	47 e8       	lddsp	r8,sp[0x1f8]
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	70 a0       	ld.w	r0,r8[0x28]
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	e7 90       	*unknown*
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	60 8c       	ld.w	r12,r0[0x20]
80002a4c:	00 00       	add	r0,r0
80002a4e:	00 08       	add	r8,r0
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	e6 c8 80 00 	sub	r8,r3,-32768
80002a56:	e6 dc 00 00 	satsub.w	r12,r3,0
80002a5a:	0b 9c       	ld.ub	r12,r5[0x1]
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	34 bc       	mov	r12,75
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	e7 a0 80 00 	cop	cp4,cr0,cr0,cr0,0x60
80002a66:	79 d8       	ld.w	r8,r12[0x74]

80002a68 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a68:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002a6c:	19 c7       	ld.ub	r7,r12[0x4]
80002a6e:	19 d8       	ld.ub	r8,r12[0x5]
80002a70:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002a74:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002a76:	48 dc       	lddpc	r12,80002aa8 <Phyuserinput_brdcst_func+0x40>
80002a78:	f0 1f 00 0d 	mcall	80002aac <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002a7c:	36 08       	mov	r8,96
80002a7e:	f0 07 19 00 	cp.h	r7,r8
80002a82:	c1 11       	brne	80002aa4 <Phyuserinput_brdcst_func+0x3c>
80002a84:	48 b8       	lddpc	r8,80002ab0 <Phyuserinput_brdcst_func+0x48>
80002a86:	11 89       	ld.ub	r9,r8[0x0]
80002a88:	30 18       	mov	r8,1
80002a8a:	f0 09 18 00 	cp.b	r9,r8
80002a8e:	c0 b1       	brne	80002aa4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002a90:	34 5b       	mov	r11,69
80002a92:	30 1c       	mov	r12,1
80002a94:	f0 1f 00 08 	mcall	80002ab4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a98:	e0 6c 07 d0 	mov	r12,2000
80002a9c:	f0 1f 00 07 	mcall	80002ab8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002aa0:	f0 1f 00 07 	mcall	80002abc <Phyuserinput_brdcst_func+0x54>
80002aa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	e7 b0       	*unknown*
80002aac:	80 00       	ld.sh	r0,r0[0x0]
80002aae:	7e fc       	ld.w	r12,pc[0x3c]
80002ab0:	00 00       	add	r0,r0
80002ab2:	0a 70       	tst	r0,r5
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	49 24       	lddpc	r4,80002afc <DataSession_brdcst_func+0x3c>
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	79 90       	ld.w	r0,r12[0x64]
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	59 64       	cp.w	r4,22

80002ac0 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ac0:	d4 21       	pushm	r4-r7,lr
80002ac2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002ac4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002ac8:	0d 88       	ld.ub	r8,r6[0x0]
80002aca:	32 49       	mov	r9,36
80002acc:	f2 08 18 00 	cp.b	r8,r9
80002ad0:	c2 91       	brne	80002b22 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002ad2:	4c 5c       	lddpc	r12,80002be4 <DataSession_brdcst_func+0x124>
80002ad4:	f0 1f 00 45 	mcall	80002be8 <DataSession_brdcst_func+0x128>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002ad8:	0d a5       	ld.ub	r5,r6[0x2]
80002ada:	0d b8       	ld.ub	r8,r6[0x3]
80002adc:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002ae0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002ae2:	0d 98       	ld.ub	r8,r6[0x1]
80002ae4:	1a d8       	st.w	--sp,r8
80002ae6:	4c 2c       	lddpc	r12,80002bec <DataSession_brdcst_func+0x12c>
80002ae8:	f0 1f 00 40 	mcall	80002be8 <DataSession_brdcst_func+0x128>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002aec:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002af0:	1a d8       	st.w	--sp,r8
80002af2:	4c 0c       	lddpc	r12,80002bf0 <DataSession_brdcst_func+0x130>
80002af4:	f0 1f 00 3d 	mcall	80002be8 <DataSession_brdcst_func+0x128>
		for(i=0; i<data_length; i++)
80002af8:	2f ed       	sub	sp,-8
80002afa:	58 05       	cp.w	r5,0
80002afc:	c7 20       	breq	80002be0 <DataSession_brdcst_func+0x120>
80002afe:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002b00:	4b d4       	lddpc	r4,80002bf4 <DataSession_brdcst_func+0x134>
80002b02:	ec 07 00 08 	add	r8,r6,r7
80002b06:	11 c8       	ld.ub	r8,r8[0x4]
80002b08:	1a d8       	st.w	--sp,r8
80002b0a:	1a d7       	st.w	--sp,r7
80002b0c:	08 9c       	mov	r12,r4
80002b0e:	f0 1f 00 37 	mcall	80002be8 <DataSession_brdcst_func+0x128>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002b12:	2f f7       	sub	r7,-1
80002b14:	5c 57       	castu.b	r7
80002b16:	2f ed       	sub	sp,-8
80002b18:	ee 05 19 00 	cp.h	r5,r7
80002b1c:	fe 9b ff f3 	brhi	80002b02 <DataSession_brdcst_func+0x42>
80002b20:	c6 08       	rjmp	80002be0 <DataSession_brdcst_func+0x120>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002b22:	1a d8       	st.w	--sp,r8
80002b24:	4b 5c       	lddpc	r12,80002bf8 <DataSession_brdcst_func+0x138>
80002b26:	f0 1f 00 31 	mcall	80002be8 <DataSession_brdcst_func+0x128>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002b2a:	0d 88       	ld.ub	r8,r6[0x0]
80002b2c:	2f fd       	sub	sp,-4
80002b2e:	30 39       	mov	r9,3
80002b30:	f2 08 18 00 	cp.b	r8,r9
80002b34:	c0 d1       	brne	80002b4e <DataSession_brdcst_func+0x8e>
		{
			log("data transmit success\n");
80002b36:	4b 2c       	lddpc	r12,80002bfc <DataSession_brdcst_func+0x13c>
80002b38:	f0 1f 00 2c 	mcall	80002be8 <DataSession_brdcst_func+0x128>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b3c:	e0 6c 07 d0 	mov	r12,2000
80002b40:	f0 1f 00 30 	mcall	80002c00 <DataSession_brdcst_func+0x140>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002b44:	37 7b       	mov	r11,119
80002b46:	30 1c       	mov	r12,1
80002b48:	f0 1f 00 2f 	mcall	80002c04 <DataSession_brdcst_func+0x144>
80002b4c:	c3 78       	rjmp	80002bba <DataSession_brdcst_func+0xfa>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002b4e:	30 49       	mov	r9,4
80002b50:	f2 08 18 00 	cp.b	r8,r9
80002b54:	c3 31       	brne	80002bba <DataSession_brdcst_func+0xfa>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002b56:	32 0a       	mov	r10,32
80002b58:	ec cb ff fc 	sub	r11,r6,-4
80002b5c:	1a 9c       	mov	r12,sp
80002b5e:	f0 1f 00 2b 	mcall	80002c08 <DataSession_brdcst_func+0x148>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002b62:	4a b8       	lddpc	r8,80002c0c <DataSession_brdcst_func+0x14c>
80002b64:	70 0c       	ld.w	r12,r8[0x0]
80002b66:	f0 1f 00 2b 	mcall	80002c10 <DataSession_brdcst_func+0x150>
80002b6a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002b6c:	c1 f0       	breq	80002baa <DataSession_brdcst_func+0xea>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002b6e:	32 0a       	mov	r10,32
80002b70:	1a 9b       	mov	r11,sp
80002b72:	f0 1f 00 26 	mcall	80002c08 <DataSession_brdcst_func+0x148>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002b76:	4a 88       	lddpc	r8,80002c14 <DataSession_brdcst_func+0x154>
80002b78:	70 0c       	ld.w	r12,r8[0x0]
80002b7a:	30 09       	mov	r9,0
80002b7c:	12 9a       	mov	r10,r9
80002b7e:	fa cb ff e0 	sub	r11,sp,-32
80002b82:	f0 1f 00 26 	mcall	80002c18 <DataSession_brdcst_func+0x158>
80002b86:	58 1c       	cp.w	r12,1
80002b88:	c1 40       	breq	80002bb0 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002b8a:	4a 5c       	lddpc	r12,80002c1c <DataSession_brdcst_func+0x15c>
80002b8c:	f0 1f 00 17 	mcall	80002be8 <DataSession_brdcst_func+0x128>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002b90:	32 3b       	mov	r11,35
80002b92:	30 1c       	mov	r12,1
80002b94:	f0 1f 00 1c 	mcall	80002c04 <DataSession_brdcst_func+0x144>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002b98:	e0 6c 17 70 	mov	r12,6000
80002b9c:	f0 1f 00 19 	mcall	80002c00 <DataSession_brdcst_func+0x140>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002ba0:	32 3b       	mov	r11,35
80002ba2:	30 0c       	mov	r12,0
80002ba4:	f0 1f 00 18 	mcall	80002c04 <DataSession_brdcst_func+0x144>
80002ba8:	c0 48       	rjmp	80002bb0 <DataSession_brdcst_func+0xf0>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002baa:	49 ec       	lddpc	r12,80002c20 <DataSession_brdcst_func+0x160>
80002bac:	f0 1f 00 0f 	mcall	80002be8 <DataSession_brdcst_func+0x128>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002bb0:	e0 6b 00 b7 	mov	r11,183
80002bb4:	30 1c       	mov	r12,1
80002bb6:	f0 1f 00 14 	mcall	80002c04 <DataSession_brdcst_func+0x144>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002bba:	0d 89       	ld.ub	r9,r6[0x0]
80002bbc:	20 39       	sub	r9,3
80002bbe:	30 18       	mov	r8,1
80002bc0:	f0 09 18 00 	cp.b	r9,r8
80002bc4:	e0 8b 00 0e 	brhi	80002be0 <DataSession_brdcst_func+0x120>
		{		
			if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
80002bc8:	49 78       	lddpc	r8,80002c24 <DataSession_brdcst_func+0x164>
80002bca:	70 0c       	ld.w	r12,r8[0x0]
80002bcc:	30 09       	mov	r9,0
80002bce:	12 9a       	mov	r10,r9
80002bd0:	12 9b       	mov	r11,r9
80002bd2:	f0 1f 00 12 	mcall	80002c18 <DataSession_brdcst_func+0x158>
80002bd6:	58 1c       	cp.w	r12,1
80002bd8:	c0 40       	breq	80002be0 <DataSession_brdcst_func+0x120>
			{
				log("xSemaphoreGive: err\n\r" );
80002bda:	49 4c       	lddpc	r12,80002c28 <DataSession_brdcst_func+0x168>
80002bdc:	f0 1f 00 03 	mcall	80002be8 <DataSession_brdcst_func+0x128>
				//
		//}
		
	}
	
}
80002be0:	2f 7d       	sub	sp,-36
80002be2:	d8 22       	popm	r4-r7,pc
80002be4:	80 00       	ld.sh	r0,r0[0x0]
80002be6:	e7 d0 80 00 	ldswp.w	r0,r3[0]
80002bea:	7e fc       	ld.w	r12,pc[0x3c]
80002bec:	80 00       	ld.sh	r0,r0[0x0]
80002bee:	e7 e4 80 00 	sthh.w	r0[r0],r3:b,r4:b
80002bf2:	e7 fc 80 00 	ld.wls	r12,r3[0x0]
80002bf6:	e8 18 80 00 	orl	r8,0x8000
80002bfa:	e8 30 80 00 	sub	r0,622592
80002bfe:	e8 3c 80 00 	sub	r12,622592
80002c02:	79 90       	ld.w	r0,r12[0x64]
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	49 24       	lddpc	r4,80002c4c <DeviceInitializationStatus_brdcst_func+0x20>
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	87 a6       	st.w	r3[0x28],r6
80002c0c:	00 00       	add	r0,r0
80002c0e:	0b 9c       	ld.ub	r12,r5[0x1]
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	36 68       	mov	r8,102
80002c14:	00 00       	add	r0,r0
80002c16:	0b 90       	ld.ub	r0,r5[0x1]
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	72 ac       	ld.w	r12,r9[0x28]
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	e8 54 80 00 	cp.w	r4,622592
80002c22:	e8 6c 00 00 	mov	r12,524288
80002c26:	0b a8       	ld.ub	r8,r5[0x2]
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	e8 7c d4 01 	mov	r12,644097

80002c2c <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002c2c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002c2e:	19 e8       	ld.ub	r8,r12[0x6]
80002c30:	30 19       	mov	r9,1
80002c32:	f2 08 18 00 	cp.b	r8,r9
80002c36:	c0 61       	brne	80002c42 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002c38:	48 98       	lddpc	r8,80002c5c <DeviceInitializationStatus_brdcst_func+0x30>
80002c3a:	70 09       	ld.w	r9,r8[0x0]
80002c3c:	a1 a9       	sbr	r9,0x0
80002c3e:	91 09       	st.w	r8[0x0],r9
80002c40:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002c42:	30 29       	mov	r9,2
80002c44:	f2 08 18 00 	cp.b	r8,r9
80002c48:	c0 80       	breq	80002c58 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002c4a:	48 58       	lddpc	r8,80002c5c <DeviceInitializationStatus_brdcst_func+0x30>
80002c4c:	70 09       	ld.w	r9,r8[0x0]
80002c4e:	e0 19 ff fc 	andl	r9,0xfffc
80002c52:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002c54:	f0 1f 00 03 	mcall	80002c60 <DeviceInitializationStatus_brdcst_func+0x34>
80002c58:	d8 02       	popm	pc
80002c5a:	00 00       	add	r0,r0
80002c5c:	00 00       	add	r0,r0
80002c5e:	0e 1c       	sub	r12,r7
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	48 78       	lddpc	r8,80002c7c <send_flash_command+0x18>

80002c64 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002c64:	eb cd 40 fc 	pushm	r2-r7,lr
80002c68:	20 1d       	sub	sp,4
80002c6a:	18 97       	mov	r7,r12
80002c6c:	14 95       	mov	r5,r10
80002c6e:	12 96       	mov	r6,r9
	U16 status = 1;
80002c70:	30 18       	mov	r8,1
80002c72:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002c74:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002c78:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002c7c:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002c80:	30 1b       	mov	r11,1
80002c82:	4e 58       	lddpc	r8,80002e14 <send_flash_command+0x1b0>
80002c84:	70 0c       	ld.w	r12,r8[0x0]
80002c86:	f0 1f 00 65 	mcall	80002e18 <send_flash_command+0x1b4>

    switch (command)
80002c8a:	30 58       	mov	r8,5
80002c8c:	f0 07 19 00 	cp.h	r7,r8
80002c90:	c3 40       	breq	80002cf8 <send_flash_command+0x94>
80002c92:	e0 8b 00 18 	brhi	80002cc2 <send_flash_command+0x5e>
80002c96:	30 28       	mov	r8,2
80002c98:	f0 07 19 00 	cp.h	r7,r8
80002c9c:	c5 e0       	breq	80002d58 <send_flash_command+0xf4>
80002c9e:	e0 8b 00 08 	brhi	80002cae <send_flash_command+0x4a>
80002ca2:	30 18       	mov	r8,1
80002ca4:	f0 07 19 00 	cp.h	r7,r8
80002ca8:	e0 81 00 ad 	brne	80002e02 <send_flash_command+0x19e>
80002cac:	c9 e8       	rjmp	80002de8 <send_flash_command+0x184>
80002cae:	30 38       	mov	r8,3
80002cb0:	f0 07 19 00 	cp.h	r7,r8
80002cb4:	c7 20       	breq	80002d98 <send_flash_command+0x134>
80002cb6:	30 48       	mov	r8,4
80002cb8:	f0 07 19 00 	cp.h	r7,r8
80002cbc:	e0 81 00 a3 	brne	80002e02 <send_flash_command+0x19e>
80002cc0:	c2 c8       	rjmp	80002d18 <send_flash_command+0xb4>
80002cc2:	35 28       	mov	r8,82
80002cc4:	f0 07 19 00 	cp.h	r7,r8
80002cc8:	c2 f0       	breq	80002d26 <send_flash_command+0xc2>
80002cca:	e0 8b 00 0c 	brhi	80002ce2 <send_flash_command+0x7e>
80002cce:	30 68       	mov	r8,6
80002cd0:	f0 07 19 00 	cp.h	r7,r8
80002cd4:	c2 20       	breq	80002d18 <send_flash_command+0xb4>
80002cd6:	32 08       	mov	r8,32
80002cd8:	f0 07 19 00 	cp.h	r7,r8
80002cdc:	e0 81 00 93 	brne	80002e02 <send_flash_command+0x19e>
80002ce0:	c2 38       	rjmp	80002d26 <send_flash_command+0xc2>
80002ce2:	36 08       	mov	r8,96
80002ce4:	f0 07 19 00 	cp.h	r7,r8
80002ce8:	c3 20       	breq	80002d4c <send_flash_command+0xe8>
80002cea:	e0 68 00 d8 	mov	r8,216
80002cee:	f0 07 19 00 	cp.h	r7,r8
80002cf2:	e0 81 00 88 	brne	80002e02 <send_flash_command+0x19e>
80002cf6:	c1 88       	rjmp	80002d26 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002cf8:	4c 77       	lddpc	r7,80002e14 <send_flash_command+0x1b0>
80002cfa:	30 5b       	mov	r11,5
80002cfc:	6e 0c       	ld.w	r12,r7[0x0]
80002cfe:	f0 1f 00 48 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_dummy();
80002d02:	e0 6b 00 ff 	mov	r11,255
80002d06:	6e 0c       	ld.w	r12,r7[0x0]
80002d08:	f0 1f 00 45 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002d0c:	fa cb ff fe 	sub	r11,sp,-2
80002d10:	6e 0c       	ld.w	r12,r7[0x0]
80002d12:	f0 1f 00 44 	mcall	80002e20 <send_flash_command+0x1bc>
			break;
80002d16:	c7 68       	rjmp	80002e02 <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002d18:	0e 9b       	mov	r11,r7
80002d1a:	5c 7b       	castu.h	r11
80002d1c:	4b e8       	lddpc	r8,80002e14 <send_flash_command+0x1b0>
80002d1e:	70 0c       	ld.w	r12,r8[0x0]
80002d20:	f0 1f 00 3f 	mcall	80002e1c <send_flash_command+0x1b8>
			break;
80002d24:	c6 f8       	rjmp	80002e02 <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002d26:	4b c6       	lddpc	r6,80002e14 <send_flash_command+0x1b0>
80002d28:	0e 9b       	mov	r11,r7
80002d2a:	5c 7b       	castu.h	r11
80002d2c:	6c 0c       	ld.w	r12,r6[0x0]
80002d2e:	f0 1f 00 3c 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002d32:	08 9b       	mov	r11,r4
80002d34:	6c 0c       	ld.w	r12,r6[0x0]
80002d36:	f0 1f 00 3a 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002d3a:	06 9b       	mov	r11,r3
80002d3c:	6c 0c       	ld.w	r12,r6[0x0]
80002d3e:	f0 1f 00 38 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002d42:	04 9b       	mov	r11,r2
80002d44:	6c 0c       	ld.w	r12,r6[0x0]
80002d46:	f0 1f 00 36 	mcall	80002e1c <send_flash_command+0x1b8>
			break;
80002d4a:	c5 c8       	rjmp	80002e02 <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002d4c:	36 0b       	mov	r11,96
80002d4e:	4b 28       	lddpc	r8,80002e14 <send_flash_command+0x1b0>
80002d50:	70 0c       	ld.w	r12,r8[0x0]
80002d52:	f0 1f 00 33 	mcall	80002e1c <send_flash_command+0x1b8>
			break;
80002d56:	c5 68       	rjmp	80002e02 <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002d58:	4a f7       	lddpc	r7,80002e14 <send_flash_command+0x1b0>
80002d5a:	30 2b       	mov	r11,2
80002d5c:	6e 0c       	ld.w	r12,r7[0x0]
80002d5e:	f0 1f 00 30 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002d62:	08 9b       	mov	r11,r4
80002d64:	6e 0c       	ld.w	r12,r7[0x0]
80002d66:	f0 1f 00 2e 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002d6a:	06 9b       	mov	r11,r3
80002d6c:	6e 0c       	ld.w	r12,r7[0x0]
80002d6e:	f0 1f 00 2c 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002d72:	04 9b       	mov	r11,r2
80002d74:	6e 0c       	ld.w	r12,r7[0x0]
80002d76:	f0 1f 00 2a 	mcall	80002e1c <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002d7a:	58 06       	cp.w	r6,0
80002d7c:	c4 30       	breq	80002e02 <send_flash_command+0x19e>
80002d7e:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002d80:	4a 54       	lddpc	r4,80002e14 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002d82:	0f 3b       	ld.ub	r11,r7++
80002d84:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002d86:	68 0c       	ld.w	r12,r4[0x0]
80002d88:	f0 1f 00 25 	mcall	80002e1c <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002d8c:	0e 98       	mov	r8,r7
80002d8e:	0a 18       	sub	r8,r5
80002d90:	ec 08 19 00 	cp.h	r8,r6
80002d94:	cf 73       	brcs	80002d82 <send_flash_command+0x11e>
80002d96:	c3 68       	rjmp	80002e02 <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002d98:	49 f7       	lddpc	r7,80002e14 <send_flash_command+0x1b0>
80002d9a:	30 3b       	mov	r11,3
80002d9c:	6e 0c       	ld.w	r12,r7[0x0]
80002d9e:	f0 1f 00 20 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002da2:	08 9b       	mov	r11,r4
80002da4:	6e 0c       	ld.w	r12,r7[0x0]
80002da6:	f0 1f 00 1e 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002daa:	06 9b       	mov	r11,r3
80002dac:	6e 0c       	ld.w	r12,r7[0x0]
80002dae:	f0 1f 00 1c 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002db2:	04 9b       	mov	r11,r2
80002db4:	6e 0c       	ld.w	r12,r7[0x0]
80002db6:	f0 1f 00 1a 	mcall	80002e1c <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002dba:	58 06       	cp.w	r6,0
80002dbc:	c2 30       	breq	80002e02 <send_flash_command+0x19e>
80002dbe:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002dc0:	49 54       	lddpc	r4,80002e14 <send_flash_command+0x1b0>
80002dc2:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002dc6:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002dc8:	06 9b       	mov	r11,r3
80002dca:	68 0c       	ld.w	r12,r4[0x0]
80002dcc:	f0 1f 00 14 	mcall	80002e1c <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002dd0:	1a 9b       	mov	r11,sp
80002dd2:	68 0c       	ld.w	r12,r4[0x0]
80002dd4:	f0 1f 00 13 	mcall	80002e20 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002dd8:	9a 08       	ld.sh	r8,sp[0x0]
80002dda:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002ddc:	0e 98       	mov	r8,r7
80002dde:	0a 18       	sub	r8,r5
80002de0:	ec 08 19 00 	cp.h	r8,r6
80002de4:	cf 23       	brcs	80002dc8 <send_flash_command+0x164>
80002de6:	c0 e8       	rjmp	80002e02 <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002de8:	48 b7       	lddpc	r7,80002e14 <send_flash_command+0x1b0>
80002dea:	30 1b       	mov	r11,1
80002dec:	6e 0c       	ld.w	r12,r7[0x0]
80002dee:	f0 1f 00 0c 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002df2:	30 0b       	mov	r11,0
80002df4:	6e 0c       	ld.w	r12,r7[0x0]
80002df6:	f0 1f 00 0a 	mcall	80002e1c <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002dfa:	30 0b       	mov	r11,0
80002dfc:	6e 0c       	ld.w	r12,r7[0x0]
80002dfe:	f0 1f 00 08 	mcall	80002e1c <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002e02:	30 1b       	mov	r11,1
80002e04:	48 48       	lddpc	r8,80002e14 <send_flash_command+0x1b0>
80002e06:	70 0c       	ld.w	r12,r8[0x0]
80002e08:	f0 1f 00 07 	mcall	80002e24 <send_flash_command+0x1c0>

	return status;
}
80002e0c:	9a 1c       	ld.sh	r12,sp[0x2]
80002e0e:	2f fd       	sub	sp,-4
80002e10:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002e14:	00 00       	add	r0,r0
80002e16:	1e 28       	rsub	r8,pc
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	69 08       	ld.w	r8,r4[0x40]
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	67 a2       	ld.w	r2,r3[0x68]
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	67 be       	ld.w	lr,r3[0x6c]
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	68 c8       	ld.w	r8,r4[0x30]

80002e28 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002e28:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002e2a:	58 0a       	cp.w	r10,0
80002e2c:	5f 09       	sreq	r9
80002e2e:	e0 68 ff fe 	mov	r8,65534
80002e32:	ea 18 00 7f 	orh	r8,0x7f
80002e36:	10 3c       	cp.w	r12,r8
80002e38:	5f b8       	srhi	r8
80002e3a:	f3 e8 10 08 	or	r8,r9,r8
80002e3e:	c0 e1       	brne	80002e5a <data_flash_read_block+0x32>
80002e40:	e0 68 10 00 	mov	r8,4096
80002e44:	f0 0b 19 00 	cp.h	r11,r8
80002e48:	e0 8b 00 09 	brhi	80002e5a <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002e4c:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002e50:	18 9b       	mov	r11,r12
80002e52:	30 3c       	mov	r12,3
80002e54:	f0 1f 00 02 	mcall	80002e5c <data_flash_read_block+0x34>
80002e58:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002e5a:	da 0a       	popm	pc,r12=1
80002e5c:	80 00       	ld.sh	r0,r0[0x0]
80002e5e:	2c 64       	sub	r4,-58

80002e60 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002e60:	eb cd 40 fc 	pushm	r2-r7,lr
80002e64:	18 94       	mov	r4,r12
80002e66:	16 93       	mov	r3,r11
80002e68:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002e6a:	58 0c       	cp.w	r12,0
80002e6c:	5f 09       	sreq	r9
80002e6e:	e0 68 ff fe 	mov	r8,65534
80002e72:	ea 18 00 7f 	orh	r8,0x7f
80002e76:	10 3b       	cp.w	r11,r8
80002e78:	5f b8       	srhi	r8
80002e7a:	f3 e8 10 08 	or	r8,r9,r8
80002e7e:	c3 a1       	brne	80002ef2 <data_flash_write_page+0x92>
80002e80:	e0 68 01 00 	mov	r8,256
80002e84:	f0 0a 19 00 	cp.h	r10,r8
80002e88:	e0 8b 00 35 	brhi	80002ef2 <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002e8c:	30 06       	mov	r6,0
80002e8e:	30 55       	mov	r5,5
80002e90:	30 17       	mov	r7,1
80002e92:	0c 99       	mov	r9,r6
80002e94:	0c 9a       	mov	r10,r6
80002e96:	0c 9b       	mov	r11,r6
80002e98:	0a 9c       	mov	r12,r5
80002e9a:	f0 1f 00 19 	mcall	80002efc <data_flash_write_page+0x9c>
80002e9e:	ee 0c 19 00 	cp.h	r12,r7
80002ea2:	cf 80       	breq	80002e92 <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002ea4:	30 09       	mov	r9,0
80002ea6:	12 9a       	mov	r10,r9
80002ea8:	12 9b       	mov	r11,r9
80002eaa:	30 6c       	mov	r12,6
80002eac:	f0 1f 00 14 	mcall	80002efc <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002eb0:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002eb4:	08 9a       	mov	r10,r4
80002eb6:	06 9b       	mov	r11,r3
80002eb8:	30 2c       	mov	r12,2
80002eba:	f0 1f 00 11 	mcall	80002efc <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002ebe:	30 06       	mov	r6,0
80002ec0:	30 57       	mov	r7,5
80002ec2:	0c 99       	mov	r9,r6
80002ec4:	0c 9a       	mov	r10,r6
80002ec6:	0c 9b       	mov	r11,r6
80002ec8:	0e 9c       	mov	r12,r7
80002eca:	f0 1f 00 0d 	mcall	80002efc <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002ece:	5c 7c       	castu.h	r12
80002ed0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002ed4:	cf 71       	brne	80002ec2 <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002ed6:	18 97       	mov	r7,r12
80002ed8:	e2 17 00 20 	andl	r7,0x20,COH
80002edc:	f9 b7 01 06 	movne	r7,6
80002ee0:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002ee4:	30 09       	mov	r9,0
80002ee6:	12 9a       	mov	r10,r9
80002ee8:	12 9b       	mov	r11,r9
80002eea:	30 4c       	mov	r12,4
80002eec:	f0 1f 00 04 	mcall	80002efc <data_flash_write_page+0x9c>

	return return_code;
80002ef0:	c0 28       	rjmp	80002ef4 <data_flash_write_page+0x94>
80002ef2:	30 17       	mov	r7,1
}
80002ef4:	0e 9c       	mov	r12,r7
80002ef6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002efa:	00 00       	add	r0,r0
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2c 64       	sub	r4,-58

80002f00 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002f00:	d4 31       	pushm	r0-r7,lr
80002f02:	18 94       	mov	r4,r12
80002f04:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002f08:	16 97       	mov	r7,r11
80002f0a:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f0c:	30 03       	mov	r3,0
80002f0e:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002f10:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f14:	c4 98       	rjmp	80002fa6 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002f16:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002f1a:	c1 b1       	brne	80002f50 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002f1c:	e0 06 19 00 	cp.h	r6,r0
80002f20:	e0 8b 00 0a 	brhi	80002f34 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002f24:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002f28:	0e 9b       	mov	r11,r7
80002f2a:	08 9c       	mov	r12,r4
80002f2c:	f0 1f 00 24 	mcall	80002fbc <data_flash_write_block+0xbc>
80002f30:	30 06       	mov	r6,0
80002f32:	c3 a8       	rjmp	80002fa6 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002f34:	e0 6a 01 00 	mov	r10,256
80002f38:	0e 9b       	mov	r11,r7
80002f3a:	08 9c       	mov	r12,r4
80002f3c:	f0 1f 00 20 	mcall	80002fbc <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002f40:	ec c6 01 00 	sub	r6,r6,256
80002f44:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002f46:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002f4a:	ee c7 ff 00 	sub	r7,r7,-256
80002f4e:	c2 c8       	rjmp	80002fa6 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002f50:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002f54:	0e 09       	add	r9,r7
80002f56:	0e 98       	mov	r8,r7
80002f58:	e4 18 00 7f 	andh	r8,0x7f
80002f5c:	e0 18 ff 00 	andl	r8,0xff00
80002f60:	f0 c8 ff 00 	sub	r8,r8,-256
80002f64:	10 39       	cp.w	r9,r8
80002f66:	e0 88 00 19 	brls	80002f98 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002f6a:	0e 91       	mov	r1,r7
80002f6c:	5c 51       	castu.b	r1
80002f6e:	e0 6a 01 00 	mov	r10,256
80002f72:	02 1a       	sub	r10,r1
80002f74:	5c 7a       	castu.h	r10
80002f76:	0e 9b       	mov	r11,r7
80002f78:	08 9c       	mov	r12,r4
80002f7a:	f0 1f 00 11 	mcall	80002fbc <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002f7e:	ec c6 01 00 	sub	r6,r6,256
80002f82:	02 06       	add	r6,r1
80002f84:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002f86:	e0 68 01 00 	mov	r8,256
80002f8a:	f0 05 01 05 	sub	r5,r8,r5
80002f8e:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002f90:	e0 17 ff 00 	andl	r7,0xff00
80002f94:	10 07       	add	r7,r8
80002f96:	c0 88       	rjmp	80002fa6 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002f98:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002f9c:	0e 9b       	mov	r11,r7
80002f9e:	08 9c       	mov	r12,r4
80002fa0:	f0 1f 00 07 	mcall	80002fbc <data_flash_write_block+0xbc>
80002fa4:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002fa6:	e6 06 19 00 	cp.h	r6,r3
80002faa:	5f 19       	srne	r9
80002fac:	58 7c       	cp.w	r12,7
80002fae:	5f 08       	sreq	r8
80002fb0:	f3 e8 00 08 	and	r8,r9,r8
80002fb4:	e4 08 18 00 	cp.b	r8,r2
80002fb8:	ca f1       	brne	80002f16 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002fba:	d8 32       	popm	r0-r7,pc
80002fbc:	80 00       	ld.sh	r0,r0[0x0]
80002fbe:	2e 60       	sub	r0,-26

80002fc0 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002fc0:	eb cd 40 f8 	pushm	r3-r7,lr
80002fc4:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002fc6:	e0 68 ff fe 	mov	r8,65534
80002fca:	ea 18 00 7f 	orh	r8,0x7f
80002fce:	10 3c       	cp.w	r12,r8
80002fd0:	e0 88 00 04 	brls	80002fd8 <data_flash_erase_block+0x18>
80002fd4:	30 17       	mov	r7,1
80002fd6:	c3 f8       	rjmp	80003054 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002fd8:	58 1b       	cp.w	r11,1
80002fda:	c0 31       	brne	80002fe0 <data_flash_erase_block+0x20>
80002fdc:	32 03       	mov	r3,32
80002fde:	c0 a8       	rjmp	80002ff2 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002fe0:	58 2b       	cp.w	r11,2
80002fe2:	c0 31       	brne	80002fe8 <data_flash_erase_block+0x28>
80002fe4:	35 23       	mov	r3,82
80002fe6:	c0 68       	rjmp	80002ff2 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002fe8:	e0 63 00 d8 	mov	r3,216
80002fec:	58 3b       	cp.w	r11,3
80002fee:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002ff2:	30 06       	mov	r6,0
80002ff4:	30 55       	mov	r5,5
80002ff6:	30 17       	mov	r7,1
80002ff8:	0c 99       	mov	r9,r6
80002ffa:	0c 9a       	mov	r10,r6
80002ffc:	0c 9b       	mov	r11,r6
80002ffe:	0a 9c       	mov	r12,r5
80003000:	f0 1f 00 17 	mcall	8000305c <data_flash_erase_block+0x9c>
80003004:	ee 0c 19 00 	cp.h	r12,r7
80003008:	cf 80       	breq	80002ff8 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
8000300a:	30 09       	mov	r9,0
8000300c:	12 9a       	mov	r10,r9
8000300e:	12 9b       	mov	r11,r9
80003010:	30 6c       	mov	r12,6
80003012:	f0 1f 00 13 	mcall	8000305c <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80003016:	30 09       	mov	r9,0
80003018:	12 9a       	mov	r10,r9
8000301a:	08 9b       	mov	r11,r4
8000301c:	06 9c       	mov	r12,r3
8000301e:	f0 1f 00 10 	mcall	8000305c <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003022:	30 06       	mov	r6,0
80003024:	30 57       	mov	r7,5
80003026:	0c 99       	mov	r9,r6
80003028:	0c 9a       	mov	r10,r6
8000302a:	0c 9b       	mov	r11,r6
8000302c:	0e 9c       	mov	r12,r7
8000302e:	f0 1f 00 0c 	mcall	8000305c <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80003032:	5c 7c       	castu.h	r12
80003034:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80003038:	cf 71       	brne	80003026 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
8000303a:	18 97       	mov	r7,r12
8000303c:	e2 17 00 20 	andl	r7,0x20,COH
80003040:	f9 b7 01 04 	movne	r7,4
80003044:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80003048:	30 09       	mov	r9,0
8000304a:	12 9a       	mov	r10,r9
8000304c:	12 9b       	mov	r11,r9
8000304e:	30 4c       	mov	r12,4
80003050:	f0 1f 00 03 	mcall	8000305c <data_flash_erase_block+0x9c>

	return return_code;
}
80003054:	0e 9c       	mov	r12,r7
80003056:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000305a:	00 00       	add	r0,r0
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	2c 64       	sub	r4,-58

80003060 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80003060:	d4 31       	pushm	r0-r7,lr
80003062:	20 3d       	sub	sp,12
80003064:	50 0c       	stdsp	sp[0x0],r12
80003066:	16 91       	mov	r1,r11
80003068:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
8000306a:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
8000306e:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80003070:	e0 69 10 00 	mov	r9,4096
80003074:	f2 0a 01 07 	sub	r7,r9,r10
80003078:	ea 07 19 00 	cp.h	r7,r5
8000307c:	ea 07 17 b0 	movhi	r7,r5
80003080:	5c 87       	casts.h	r7
80003082:	16 92       	mov	r2,r11
80003084:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003088:	4a e4       	lddpc	r4,80003140 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000308a:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
8000308c:	e8 c8 ff ff 	sub	r8,r4,-1
80003090:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80003092:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003094:	08 9a       	mov	r10,r4
80003096:	e0 6b 10 00 	mov	r11,4096
8000309a:	04 9c       	mov	r12,r2
8000309c:	f0 1f 00 2a 	mcall	80003144 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
800030a0:	58 07       	cp.w	r7,0
800030a2:	c3 00       	breq	80003102 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
800030a4:	40 13       	lddsp	r3,sp[0x4]
800030a6:	5c 73       	castu.h	r3
800030a8:	e8 03 07 08 	ld.ub	r8,r4[r3]
800030ac:	ec 08 18 00 	cp.b	r8,r6
800030b0:	c1 11       	brne	800030d2 <data_flash_write+0x72>
800030b2:	e6 c9 ff ff 	sub	r9,r3,-1
800030b6:	08 09       	add	r9,r4
800030b8:	30 08       	mov	r8,0
800030ba:	c0 58       	rjmp	800030c4 <data_flash_write+0x64>
800030bc:	13 3a       	ld.ub	r10,r9++
800030be:	ec 0a 18 00 	cp.b	r10,r6
800030c2:	c0 81       	brne	800030d2 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
800030c4:	2f f8       	sub	r8,-1
800030c6:	5c 88       	casts.h	r8
800030c8:	f0 07 19 00 	cp.h	r7,r8
800030cc:	fe 9b ff f8 	brhi	800030bc <data_flash_write+0x5c>
800030d0:	c1 98       	rjmp	80003102 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
800030d2:	30 1b       	mov	r11,1
800030d4:	04 9c       	mov	r12,r2
800030d6:	f0 1f 00 1d 	mcall	80003148 <data_flash_write+0xe8>
800030da:	40 08       	lddsp	r8,sp[0x0]
800030dc:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
800030de:	40 2a       	lddsp	r10,sp[0x8]
800030e0:	40 19       	lddsp	r9,sp[0x4]
800030e2:	12 0a       	add	r10,r9
800030e4:	0e 99       	mov	r9,r7
800030e6:	20 19       	sub	r9,1
800030e8:	5c 79       	castu.h	r9
800030ea:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
800030ec:	11 39       	ld.ub	r9,r8++
800030ee:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
800030f0:	14 33       	cp.w	r3,r10
800030f2:	cf d1       	brne	800030ec <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
800030f4:	e0 6a 10 00 	mov	r10,4096
800030f8:	04 9b       	mov	r11,r2
800030fa:	08 9c       	mov	r12,r4
800030fc:	f0 1f 00 14 	mcall	8000314c <data_flash_write+0xec>
80003100:	c0 78       	rjmp	8000310e <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80003102:	0e 9a       	mov	r10,r7
80003104:	5c 7a       	castu.h	r10
80003106:	02 9b       	mov	r11,r1
80003108:	40 0c       	lddsp	r12,sp[0x0]
8000310a:	f0 1f 00 11 	mcall	8000314c <data_flash_write+0xec>
8000310e:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80003112:	0e 98       	mov	r8,r7
80003114:	ee 05 19 00 	cp.h	r5,r7
80003118:	c1 20       	breq	8000313c <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
8000311a:	5c 78       	castu.h	r8
8000311c:	40 0a       	lddsp	r10,sp[0x0]
8000311e:	10 0a       	add	r10,r8
80003120:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80003122:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80003124:	0e 15       	sub	r5,r7
80003126:	5c 85       	casts.h	r5
80003128:	e0 05 19 00 	cp.h	r5,r0
8000312c:	ea 07 17 80 	movls	r7,r5
80003130:	e0 07 17 b0 	movhi	r7,r0
80003134:	5c 87       	casts.h	r7
80003136:	30 09       	mov	r9,0
80003138:	50 19       	stdsp	sp[0x4],r9
8000313a:	ca db       	rjmp	80003094 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
8000313c:	2f dd       	sub	sp,-12
8000313e:	d8 32       	popm	r0-r7,pc
80003140:	00 00       	add	r0,r0
80003142:	0e 28       	rsub	r8,r7
80003144:	80 00       	ld.sh	r0,r0[0x0]
80003146:	2e 28       	sub	r8,-30
80003148:	80 00       	ld.sh	r0,r0[0x0]
8000314a:	2f c0       	sub	r0,-4
8000314c:	80 00       	ld.sh	r0,r0[0x0]
8000314e:	2f 00       	sub	r0,-16

80003150 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80003150:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80003152:	48 78       	lddpc	r8,8000316c <W25Q64_SPI_SetSpeed+0x1c>
80003154:	70 09       	ld.w	r9,r8[0x0]
80003156:	72 da       	ld.w	r10,r9[0x34]
80003158:	5c 7c       	castu.h	r12
8000315a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000315e:	f9 ea 10 0a 	or	r10,r12,r10
80003162:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80003164:	70 0c       	ld.w	r12,r8[0x0]
80003166:	f0 1f 00 03 	mcall	80003170 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
8000316a:	d8 02       	popm	pc
8000316c:	00 00       	add	r0,r0
8000316e:	1e 28       	rsub	r8,pc
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	67 9c       	ld.w	r12,r3[0x64]

80003174 <W25Q64_SPI_SetSpeedHi>:
{
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
	
}
void W25Q64_SPI_SetSpeedHi(void)
{
80003174:	d4 01       	pushm	lr
	
	W25Q64_SPI_SetSpeed(0x0100);//baudDiv=1
80003176:	e0 6c 01 00 	mov	r12,256
8000317a:	f0 1f 00 02 	mcall	80003180 <W25Q64_SPI_SetSpeedHi+0xc>
	
}
8000317e:	d8 02       	popm	pc
80003180:	80 00       	ld.sh	r0,r0[0x0]
80003182:	31 50       	mov	r0,21

80003184 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003184:	eb cd 40 c0 	pushm	r6-r7,lr
80003188:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
8000318a:	4b a8       	lddpc	r8,80003270 <data_flash_init+0xec>
8000318c:	fa c6 ff fc 	sub	r6,sp,-4
80003190:	f0 ea 00 00 	ld.d	r10,r8[0]
80003194:	ec eb 00 00 	st.d	r6[0],r10
80003198:	f0 e8 00 08 	ld.d	r8,r8[8]
8000319c:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
800031a0:	30 4b       	mov	r11,4
800031a2:	4b 5c       	lddpc	r12,80003274 <data_flash_init+0xf0>
800031a4:	f0 1f 00 35 	mcall	80003278 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
800031a8:	4b 57       	lddpc	r7,8000327c <data_flash_init+0xf8>
800031aa:	fe 7c 24 00 	mov	r12,-56320
800031ae:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800031b0:	0c 9b       	mov	r11,r6
800031b2:	f0 1f 00 34 	mcall	80003280 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800031b6:	30 09       	mov	r9,0
800031b8:	12 9a       	mov	r10,r9
800031ba:	12 9b       	mov	r11,r9
800031bc:	6e 0c       	ld.w	r12,r7[0x0]
800031be:	f0 1f 00 32 	mcall	80003284 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
800031c2:	6e 0c       	ld.w	r12,r7[0x0]
800031c4:	f0 1f 00 31 	mcall	80003288 <data_flash_init+0x104>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800031c8:	e0 6a 36 00 	mov	r10,13824
800031cc:	ea 1a 01 6e 	orh	r10,0x16e
800031d0:	0c 9b       	mov	r11,r6
800031d2:	6e 0c       	ld.w	r12,r7[0x0]
800031d4:	f0 1f 00 2e 	mcall	8000328c <data_flash_init+0x108>
800031d8:	c0 50       	breq	800031e2 <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
800031da:	30 29       	mov	r9,2
800031dc:	4a d8       	lddpc	r8,80003290 <data_flash_init+0x10c>
800031de:	b0 89       	st.b	r8[0x0],r9
		return;
800031e0:	c4 58       	rjmp	8000326a <data_flash_init+0xe6>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800031e2:	1a 96       	mov	r6,sp
800031e4:	30 4a       	mov	r10,4
800031e6:	4a cb       	lddpc	r11,80003294 <data_flash_init+0x110>
800031e8:	1a 9c       	mov	r12,sp
800031ea:	f0 1f 00 2c 	mcall	80003298 <data_flash_init+0x114>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
800031ee:	4a 47       	lddpc	r7,8000327c <data_flash_init+0xf8>
800031f0:	30 1b       	mov	r11,1
800031f2:	6e 0c       	ld.w	r12,r7[0x0]
800031f4:	f0 1f 00 2a 	mcall	8000329c <data_flash_init+0x118>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
800031f8:	e0 6b 00 90 	mov	r11,144
800031fc:	6e 0c       	ld.w	r12,r7[0x0]
800031fe:	f0 1f 00 29 	mcall	800032a0 <data_flash_init+0x11c>
	spi_write_zero();
80003202:	30 0b       	mov	r11,0
80003204:	6e 0c       	ld.w	r12,r7[0x0]
80003206:	f0 1f 00 27 	mcall	800032a0 <data_flash_init+0x11c>
	spi_write_zero();
8000320a:	30 0b       	mov	r11,0
8000320c:	6e 0c       	ld.w	r12,r7[0x0]
8000320e:	f0 1f 00 25 	mcall	800032a0 <data_flash_init+0x11c>
	spi_write_zero();
80003212:	30 0b       	mov	r11,0
80003214:	6e 0c       	ld.w	r12,r7[0x0]
80003216:	f0 1f 00 23 	mcall	800032a0 <data_flash_init+0x11c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
8000321a:	e0 6b 00 ff 	mov	r11,255
8000321e:	6e 0c       	ld.w	r12,r7[0x0]
80003220:	f0 1f 00 20 	mcall	800032a0 <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[0]);
80003224:	1a 9b       	mov	r11,sp
80003226:	6e 0c       	ld.w	r12,r7[0x0]
80003228:	f0 1f 00 1f 	mcall	800032a4 <data_flash_init+0x120>
	
	spi_write_dummy();
8000322c:	e0 6b 00 ff 	mov	r11,255
80003230:	6e 0c       	ld.w	r12,r7[0x0]
80003232:	f0 1f 00 1c 	mcall	800032a0 <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[1]);
80003236:	fa cb ff fe 	sub	r11,sp,-2
8000323a:	6e 0c       	ld.w	r12,r7[0x0]
8000323c:	f0 1f 00 1a 	mcall	800032a4 <data_flash_init+0x120>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80003240:	30 1b       	mov	r11,1
80003242:	6e 0c       	ld.w	r12,r7[0x0]
80003244:	f0 1f 00 19 	mcall	800032a8 <data_flash_init+0x124>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80003248:	e0 68 00 ef 	mov	r8,239
8000324c:	9a 09       	ld.sh	r9,sp[0x0]
8000324e:	f0 09 19 00 	cp.h	r9,r8
80003252:	c0 61       	brne	8000325e <data_flash_init+0xda>
80003254:	31 68       	mov	r8,22
80003256:	9a 19       	ld.sh	r9,sp[0x2]
80003258:	f0 09 19 00 	cp.h	r9,r8
8000325c:	c0 50       	breq	80003266 <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
8000325e:	30 39       	mov	r9,3
80003260:	48 c8       	lddpc	r8,80003290 <data_flash_init+0x10c>
80003262:	b0 89       	st.b	r8[0x0],r9
		return;
80003264:	c0 38       	rjmp	8000326a <data_flash_init+0xe6>
	}

	W25Q64_SPI_SetSpeedHi();
80003266:	f0 1f 00 12 	mcall	800032ac <data_flash_init+0x128>
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
8000326a:	2f bd       	sub	sp,-20
8000326c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003270:	80 00       	ld.sh	r0,r0[0x0]
80003272:	e8 b8       	*unknown*
80003274:	80 00       	ld.sh	r0,r0[0x0]
80003276:	e8 94 80 00 	brge	80133276 <_data_lma+0x123c66>
8000327a:	62 c8       	ld.w	r8,r1[0x30]
8000327c:	00 00       	add	r0,r0
8000327e:	1e 28       	rsub	r8,pc
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	67 38       	ld.w	r8,r3[0x4c]
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	67 70       	ld.w	r0,r3[0x5c]
80003288:	80 00       	ld.sh	r0,r0[0x0]
8000328a:	67 9c       	ld.w	r12,r3[0x64]
8000328c:	80 00       	ld.sh	r0,r0[0x0]
8000328e:	67 e0       	ld.w	r0,r3[0x78]
80003290:	00 00       	add	r0,r0
80003292:	0a 84       	andn	r4,r5
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	e8 b4       	*unknown*
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	87 a6       	st.w	r3[0x28],r6
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	69 08       	ld.w	r8,r4[0x40]
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	67 a2       	ld.w	r2,r3[0x68]
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	67 be       	ld.w	lr,r3[0x6c]
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	68 c8       	ld.w	r8,r4[0x30]
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	31 74       	mov	r4,23

800032b0 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800032b0:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
800032b2:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800032b4:	30 0a       	mov	r10,0
800032b6:	32 8b       	mov	r11,40
800032b8:	49 5c       	lddpc	r12,8000330c <xg_rtc_init+0x5c>
800032ba:	f0 1f 00 16 	mcall	80003310 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
800032be:	30 ea       	mov	r10,14
800032c0:	30 1b       	mov	r11,1
800032c2:	fe 7c 0d 00 	mov	r12,-62208
800032c6:	f0 1f 00 14 	mcall	80003314 <xg_rtc_init+0x64>
800032ca:	c0 41       	brne	800032d2 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
800032cc:	49 3c       	lddpc	r12,80003318 <xg_rtc_init+0x68>
800032ce:	f0 1f 00 14 	mcall	8000331c <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800032d2:	30 0b       	mov	r11,0
800032d4:	fe 7c 0d 00 	mov	r12,-62208
800032d8:	f0 1f 00 12 	mcall	80003320 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800032dc:	fe 7c 0d 00 	mov	r12,-62208
800032e0:	f0 1f 00 11 	mcall	80003324 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
800032e4:	fe 7c 0d 00 	mov	r12,-62208
800032e8:	f0 1f 00 10 	mcall	80003328 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800032ec:	49 08       	lddpc	r8,8000332c <xg_rtc_init+0x7c>
800032ee:	31 09       	mov	r9,16
800032f0:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800032f2:	30 29       	mov	r9,2
800032f4:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
800032f6:	31 d9       	mov	r9,29
800032f8:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
800032fa:	31 79       	mov	r9,23
800032fc:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
800032fe:	33 b9       	mov	r9,59
80003300:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80003302:	32 89       	mov	r9,40
80003304:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80003306:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003308:	d8 02       	popm	pc
8000330a:	00 00       	add	r0,r0
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	33 30       	mov	r0,51
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	63 4c       	ld.w	r12,r1[0x50]
80003314:	80 00       	ld.sh	r0,r0[0x0]
80003316:	66 98       	ld.w	r8,r3[0x24]
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	e8 c8 80 00 	sub	r8,r4,-32768
8000331e:	7e fc       	ld.w	r12,pc[0x3c]
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	66 54       	ld.w	r4,r3[0x14]
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	66 4c       	ld.w	r12,r3[0x10]
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	66 28       	ld.w	r8,r3[0x8]
8000332c:	00 00       	add	r0,r0
8000332e:	0e 20       	rsub	r0,r7

80003330 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80003330:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80003332:	4b 98       	lddpc	r8,80003414 <rtc_irq+0xe4>
80003334:	11 d9       	ld.ub	r9,r8[0x5]
80003336:	2f f9       	sub	r9,-1
80003338:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
8000333a:	11 d9       	ld.ub	r9,r8[0x5]
8000333c:	33 b8       	mov	r8,59
8000333e:	f0 09 18 00 	cp.b	r9,r8
80003342:	e0 88 00 5f 	brls	80003400 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80003346:	4b 48       	lddpc	r8,80003414 <rtc_irq+0xe4>
80003348:	30 09       	mov	r9,0
8000334a:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
8000334c:	11 c9       	ld.ub	r9,r8[0x4]
8000334e:	2f f9       	sub	r9,-1
80003350:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80003352:	11 c9       	ld.ub	r9,r8[0x4]
80003354:	33 b8       	mov	r8,59
80003356:	f0 09 18 00 	cp.b	r9,r8
8000335a:	e0 88 00 53 	brls	80003400 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
8000335e:	4a e8       	lddpc	r8,80003414 <rtc_irq+0xe4>
80003360:	30 09       	mov	r9,0
80003362:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003364:	11 b9       	ld.ub	r9,r8[0x3]
80003366:	2f f9       	sub	r9,-1
80003368:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
8000336a:	11 b9       	ld.ub	r9,r8[0x3]
8000336c:	31 78       	mov	r8,23
8000336e:	f0 09 18 00 	cp.b	r9,r8
80003372:	e0 88 00 47 	brls	80003400 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003376:	4a 88       	lddpc	r8,80003414 <rtc_irq+0xe4>
80003378:	30 09       	mov	r9,0
8000337a:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
8000337c:	11 88       	ld.ub	r8,r8[0x0]
8000337e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003382:	e0 69 01 6e 	mov	r9,366
80003386:	e0 6a 01 6d 	mov	r10,365
8000338a:	f4 08 17 10 	movne	r8,r10
8000338e:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80003392:	4a 19       	lddpc	r9,80003414 <rtc_irq+0xe4>
80003394:	13 9a       	ld.ub	r10,r9[0x1]
80003396:	30 29       	mov	r9,2
80003398:	f2 0a 18 00 	cp.b	r10,r9
8000339c:	c0 b0       	breq	800033b2 <rtc_irq+0x82>
8000339e:	49 e8       	lddpc	r8,80003414 <rtc_irq+0xe4>
800033a0:	11 99       	ld.ub	r9,r8[0x1]
800033a2:	11 9a       	ld.ub	r10,r8[0x1]
800033a4:	a3 9a       	lsr	r10,0x3
800033a6:	12 0a       	add	r10,r9
800033a8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800033ac:	2e 2a       	sub	r10,-30
800033ae:	5c 5a       	castu.b	r10
800033b0:	c0 58       	rjmp	800033ba <rtc_irq+0x8a>
800033b2:	f0 c8 01 51 	sub	r8,r8,337
800033b6:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
800033ba:	49 78       	lddpc	r8,80003414 <rtc_irq+0xe4>
800033bc:	11 a9       	ld.ub	r9,r8[0x2]
800033be:	2f f9       	sub	r9,-1
800033c0:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
800033c2:	11 a8       	ld.ub	r8,r8[0x2]
800033c4:	f0 0a 18 00 	cp.b	r10,r8
800033c8:	c1 c2       	brcc	80003400 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800033ca:	49 38       	lddpc	r8,80003414 <rtc_irq+0xe4>
800033cc:	30 19       	mov	r9,1
800033ce:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800033d0:	11 99       	ld.ub	r9,r8[0x1]
800033d2:	2f f9       	sub	r9,-1
800033d4:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800033d6:	11 99       	ld.ub	r9,r8[0x1]
800033d8:	30 c8       	mov	r8,12
800033da:	f0 09 18 00 	cp.b	r9,r8
800033de:	e0 88 00 11 	brls	80003400 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800033e2:	48 d8       	lddpc	r8,80003414 <rtc_irq+0xe4>
800033e4:	30 19       	mov	r9,1
800033e6:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800033e8:	11 89       	ld.ub	r9,r8[0x0]
800033ea:	2f f9       	sub	r9,-1
800033ec:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800033ee:	11 89       	ld.ub	r9,r8[0x0]
800033f0:	39 68       	mov	r8,-106
800033f2:	f0 09 18 00 	cp.b	r9,r8
800033f6:	e0 88 00 05 	brls	80003400 <rtc_irq+0xd0>
800033fa:	30 09       	mov	r9,0
800033fc:	48 68       	lddpc	r8,80003414 <rtc_irq+0xe4>
800033fe:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003400:	fe 7c 0d 00 	mov	r12,-62208
80003404:	f0 1f 00 05 	mcall	80003418 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003408:	30 19       	mov	r9,1
8000340a:	48 58       	lddpc	r8,8000341c <rtc_irq+0xec>
8000340c:	91 09       	st.w	r8[0x0],r9
}
8000340e:	d4 02       	popm	lr
80003410:	d6 03       	rete
80003412:	00 00       	add	r0,r0
80003414:	00 00       	add	r0,r0
80003416:	0e 20       	rsub	r0,r7
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	66 78       	ld.w	r8,r3[0x1c]
8000341c:	00 00       	add	r0,r0
8000341e:	04 fc       	st.b	--r2,r12

80003420 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003420:	20 1c       	sub	r12,1
80003422:	5c 5c       	castu.b	r12
80003424:	31 18       	mov	r8,17
80003426:	f0 0c 18 00 	cp.b	r12,r8
8000342a:	e0 88 00 03 	brls	80003430 <CalculateBurst+0x10>
8000342e:	5e fd       	retal	0
80003430:	48 28       	lddpc	r8,80003438 <CalculateBurst+0x18>
80003432:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003436:	5e fc       	retal	r12
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	e8 e8 48 38 	ld.d	r8,r4[18488]

8000343c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
8000343c:	48 38       	lddpc	r8,80003448 <payload_init+0xc>
8000343e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003440:	48 38       	lddpc	r8,8000344c <payload_init+0x10>
80003442:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003444:	5e fc       	retal	r12
80003446:	00 00       	add	r0,r0
80003448:	00 00       	add	r0,r0
8000344a:	0a 88       	andn	r8,r5
8000344c:	00 00       	add	r0,r0
8000344e:	0a 8c       	andn	r12,r5

80003450 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003450:	d4 01       	pushm	lr
80003452:	20 2d       	sub	sp,8
80003454:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003456:	30 09       	mov	r9,0
80003458:	fa ca ff f8 	sub	r10,sp,-8
8000345c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000345e:	1a 9b       	mov	r11,sp
80003460:	f0 1f 00 02 	mcall	80003468 <set_idle_store_isr+0x18>
}
80003464:	2f ed       	sub	sp,-8
80003466:	d8 02       	popm	pc
80003468:	80 00       	ld.sh	r0,r0[0x0]
8000346a:	72 5c       	ld.w	r12,r9[0x14]

8000346c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
8000346c:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
8000346e:	48 48       	lddpc	r8,8000347c <payload_rx+0x10>
80003470:	70 08       	ld.w	r8,r8[0x0]
80003472:	18 9b       	mov	r11,r12
80003474:	10 9c       	mov	r12,r8
80003476:	f0 1f 00 03 	mcall	80003480 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
8000347a:	d8 02       	popm	pc
8000347c:	00 00       	add	r0,r0
8000347e:	0a c4       	st.b	r5++,r4
80003480:	80 00       	ld.sh	r0,r0[0x0]
80003482:	34 50       	mov	r0,69

80003484 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003484:	d4 01       	pushm	lr
80003486:	20 2d       	sub	sp,8
80003488:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000348a:	58 0c       	cp.w	r12,0
8000348c:	c1 10       	breq	800034ae <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000348e:	30 08       	mov	r8,0
80003490:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003492:	98 88       	ld.uh	r8,r12[0x0]
80003494:	e2 18 f0 00 	andl	r8,0xf000,COH
80003498:	e0 48 40 00 	cp.w	r8,16384
8000349c:	c0 91       	brne	800034ae <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
8000349e:	48 68       	lddpc	r8,800034b4 <phy_rx+0x30>
800034a0:	70 0c       	ld.w	r12,r8[0x0]
800034a2:	30 09       	mov	r9,0
800034a4:	fa ca ff fc 	sub	r10,sp,-4
800034a8:	1a 9b       	mov	r11,sp
800034aa:	f0 1f 00 04 	mcall	800034b8 <phy_rx+0x34>
		}	

    }
		
 
}
800034ae:	2f ed       	sub	sp,-8
800034b0:	d8 02       	popm	pc
800034b2:	00 00       	add	r0,r0
800034b4:	00 00       	add	r0,r0
800034b6:	0a d0       	st.w	--r5,r0
800034b8:	80 00       	ld.sh	r0,r0[0x0]
800034ba:	72 5c       	ld.w	r12,r9[0x14]

800034bc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800034bc:	eb cd 40 80 	pushm	r7,lr
800034c0:	20 1d       	sub	sp,4
800034c2:	fa c7 ff fc 	sub	r7,sp,-4
800034c6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800034c8:	30 09       	mov	r9,0
800034ca:	12 9a       	mov	r10,r9
800034cc:	1a 9b       	mov	r11,sp
800034ce:	f0 1f 00 03 	mcall	800034d8 <set_idle_store+0x1c>
}
800034d2:	2f fd       	sub	sp,-4
800034d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800034d8:	80 00       	ld.sh	r0,r0[0x0]
800034da:	72 ac       	ld.w	r12,r9[0x28]

800034dc <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800034dc:	d4 01       	pushm	lr
800034de:	20 1d       	sub	sp,4
800034e0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800034e2:	98 88       	ld.uh	r8,r12[0x0]
800034e4:	e2 18 f0 00 	andl	r8,0xf000,COH
800034e8:	e0 48 40 00 	cp.w	r8,16384
800034ec:	c0 d1       	brne	80003506 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800034ee:	49 08       	lddpc	r8,8000352c <phy_tx+0x50>
800034f0:	70 08       	ld.w	r8,r8[0x0]
800034f2:	58 08       	cp.w	r8,0
800034f4:	c1 a0       	breq	80003528 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800034f6:	48 e8       	lddpc	r8,8000352c <phy_tx+0x50>
800034f8:	70 0c       	ld.w	r12,r8[0x0]
800034fa:	30 09       	mov	r9,0
800034fc:	12 9a       	mov	r10,r9
800034fe:	1a 9b       	mov	r11,sp
80003500:	f0 1f 00 0c 	mcall	80003530 <phy_tx+0x54>
80003504:	c1 28       	rjmp	80003528 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003506:	e0 48 10 00 	cp.w	r8,4096
8000350a:	5f 0a       	sreq	r10
8000350c:	e0 48 20 00 	cp.w	r8,8192
80003510:	5f 09       	sreq	r9
80003512:	f5 e9 10 09 	or	r9,r10,r9
80003516:	c0 71       	brne	80003524 <phy_tx+0x48>
80003518:	e0 48 50 00 	cp.w	r8,20480
8000351c:	c0 40       	breq	80003524 <phy_tx+0x48>
8000351e:	e0 48 60 00 	cp.w	r8,24576
80003522:	c0 31       	brne	80003528 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003524:	48 48       	lddpc	r8,80003534 <phy_tx+0x58>
80003526:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003528:	2f fd       	sub	sp,-4
8000352a:	d8 02       	popm	pc
8000352c:	00 00       	add	r0,r0
8000352e:	0a f0       	st.b	--r5,r0
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	72 ac       	ld.w	r12,r9[0x28]
80003534:	00 00       	add	r0,r0
80003536:	0a e4       	st.h	--r5,r4

80003538 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003538:	d4 01       	pushm	lr
8000353a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000353c:	30 08       	mov	r8,0
8000353e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003540:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003542:	1a 9a       	mov	r10,sp
80003544:	fa cb ff fc 	sub	r11,sp,-4
80003548:	f0 1f 00 05 	mcall	8000355c <get_idle_store_isr+0x24>
8000354c:	58 1c       	cp.w	r12,1
8000354e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003552:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003556:	2f ed       	sub	sp,-8
80003558:	d8 02       	popm	pc
8000355a:	00 00       	add	r0,r0
8000355c:	80 00       	ld.sh	r0,r0[0x0]
8000355e:	6f b0       	ld.w	r0,r7[0x6c]

80003560 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003560:	eb cd 40 c0 	pushm	r6-r7,lr
80003564:	20 1d       	sub	sp,4
80003566:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003568:	4b a8       	lddpc	r8,80003650 <phy_tx_func+0xf0>
8000356a:	70 08       	ld.w	r8,r8[0x0]
8000356c:	58 08       	cp.w	r8,0
8000356e:	c6 60       	breq	8000363a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003570:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003572:	30 08       	mov	r8,0
80003574:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003576:	4b 88       	lddpc	r8,80003654 <phy_tx_func+0xf4>
80003578:	70 08       	ld.w	r8,r8[0x0]
8000357a:	58 18       	cp.w	r8,1
8000357c:	c2 60       	breq	800035c8 <phy_tx_func+0x68>
8000357e:	c0 43       	brcs	80003586 <phy_tx_func+0x26>
80003580:	58 28       	cp.w	r8,2
80003582:	c5 c1       	brne	8000363a <phy_tx_func+0xda>
80003584:	c5 58       	rjmp	8000362e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003586:	4b 38       	lddpc	r8,80003650 <phy_tx_func+0xf0>
80003588:	70 0c       	ld.w	r12,r8[0x0]
8000358a:	1a 9a       	mov	r10,sp
8000358c:	4b 3b       	lddpc	r11,80003658 <phy_tx_func+0xf8>
8000358e:	f0 1f 00 34 	mcall	8000365c <phy_tx_func+0xfc>
80003592:	58 1c       	cp.w	r12,1
80003594:	c1 41       	brne	800035bc <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003596:	4b 18       	lddpc	r8,80003658 <phy_tx_func+0xf8>
80003598:	70 08       	ld.w	r8,r8[0x0]
8000359a:	90 08       	ld.sh	r8,r8[0x0]
8000359c:	10 9a       	mov	r10,r8
8000359e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800035a2:	4b 09       	lddpc	r9,80003660 <phy_tx_func+0x100>
800035a4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800035a6:	5c 78       	castu.h	r8
800035a8:	ea 18 ab cd 	orh	r8,0xabcd
800035ac:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800035ae:	30 19       	mov	r9,1
800035b0:	4a d8       	lddpc	r8,80003664 <phy_tx_func+0x104>
800035b2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800035b4:	30 19       	mov	r9,1
800035b6:	4a 88       	lddpc	r8,80003654 <phy_tx_func+0xf4>
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	c4 08       	rjmp	8000363a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800035bc:	e0 68 5a 5a 	mov	r8,23130
800035c0:	ea 18 ab cd 	orh	r8,0xabcd
800035c4:	8f 18       	st.w	r7[0x4],r8
800035c6:	c3 a8       	rjmp	8000363a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800035c8:	4a 7a       	lddpc	r10,80003664 <phy_tx_func+0x104>
800035ca:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800035cc:	4a 39       	lddpc	r9,80003658 <phy_tx_func+0xf8>
800035ce:	72 09       	ld.w	r9,r9[0x0]
800035d0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800035d4:	b1 69       	lsl	r9,0x10
800035d6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800035d8:	2f f8       	sub	r8,-1
800035da:	5c 58       	castu.b	r8
800035dc:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800035de:	4a 1b       	lddpc	r11,80003660 <phy_tx_func+0x100>
800035e0:	96 0c       	ld.sh	r12,r11[0x0]
800035e2:	20 2c       	sub	r12,2
800035e4:	5c 8c       	casts.h	r12
800035e6:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800035ea:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800035ec:	30 0b       	mov	r11,0
800035ee:	f6 0a 19 00 	cp.h	r10,r11
800035f2:	e0 89 00 09 	brgt	80003604 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
800035f6:	e8 19 00 ba 	orl	r9,0xba
800035fa:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
800035fc:	30 09       	mov	r9,0
800035fe:	49 68       	lddpc	r8,80003654 <phy_tx_func+0xf4>
80003600:	91 09       	st.w	r8[0x0],r9
80003602:	c1 c8       	rjmp	8000363a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003604:	49 5a       	lddpc	r10,80003658 <phy_tx_func+0xf8>
80003606:	74 0a       	ld.w	r10,r10[0x0]
80003608:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
8000360c:	14 49       	or	r9,r10
8000360e:	8f 19       	st.w	r7[0x4],r9
80003610:	2f f8       	sub	r8,-1
80003612:	49 59       	lddpc	r9,80003664 <phy_tx_func+0x104>
80003614:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003616:	20 2c       	sub	r12,2
80003618:	49 28       	lddpc	r8,80003660 <phy_tx_func+0x100>
8000361a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000361c:	30 08       	mov	r8,0
8000361e:	f0 0c 19 00 	cp.h	r12,r8
80003622:	e0 89 00 0c 	brgt	8000363a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003626:	30 29       	mov	r9,2
80003628:	48 b8       	lddpc	r8,80003654 <phy_tx_func+0xf4>
8000362a:	91 09       	st.w	r8[0x0],r9
8000362c:	c0 78       	rjmp	8000363a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000362e:	fc 18 00 ba 	movh	r8,0xba
80003632:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003634:	30 09       	mov	r9,0
80003636:	48 88       	lddpc	r8,80003654 <phy_tx_func+0xf4>
80003638:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000363a:	e0 68 5a 5a 	mov	r8,23130
8000363e:	ea 18 ab cd 	orh	r8,0xabcd
80003642:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003644:	30 08       	mov	r8,0
80003646:	8f 38       	st.w	r7[0xc],r8
}
80003648:	2f fd       	sub	sp,-4
8000364a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000364e:	00 00       	add	r0,r0
80003650:	00 00       	add	r0,r0
80003652:	0a f0       	st.b	--r5,r0
80003654:	00 00       	add	r0,r0
80003656:	0a b0       	st.h	r5++,r0
80003658:	00 00       	add	r0,r0
8000365a:	0a bc       	st.h	r5++,r12
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	6f b0       	ld.w	r0,r7[0x6c]
80003660:	00 00       	add	r0,r0
80003662:	0a d8       	st.w	--r5,r8
80003664:	00 00       	add	r0,r0
80003666:	0a 90       	mov	r0,r5

80003668 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003668:	d4 01       	pushm	lr
8000366a:	20 1d       	sub	sp,4
	void * ptr = NULL;
8000366c:	30 0a       	mov	r10,0
8000366e:	fa cb ff fc 	sub	r11,sp,-4
80003672:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003674:	14 99       	mov	r9,r10
80003676:	1a 9b       	mov	r11,sp
80003678:	f0 1f 00 05 	mcall	8000368c <get_idle_store+0x24>
8000367c:	58 1c       	cp.w	r12,1
8000367e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003682:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003686:	2f fd       	sub	sp,-4
80003688:	d8 02       	popm	pc
8000368a:	00 00       	add	r0,r0
8000368c:	80 00       	ld.sh	r0,r0[0x0]
8000368e:	70 a0       	ld.w	r0,r8[0x28]

80003690 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003690:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003692:	48 5b       	lddpc	r11,800036a4 <phy_init+0x14>
80003694:	48 5c       	lddpc	r12,800036a8 <phy_init+0x18>
80003696:	f0 1f 00 06 	mcall	800036ac <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
8000369a:	f0 1f 00 06 	mcall	800036b0 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
8000369e:	f0 1f 00 06 	mcall	800036b4 <phy_init+0x24>
	
}
800036a2:	d8 02       	popm	pc
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	35 60       	mov	r0,86
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	36 b8       	mov	r8,107
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	47 0c       	lddsp	r12,sp[0x1c0]
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	47 20       	lddsp	r0,sp[0x1c8]
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	50 d0       	stdsp	sp[0x34],r0

800036b8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800036b8:	eb cd 40 e0 	pushm	r5-r7,lr
800036bc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800036be:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800036c2:	70 08       	ld.w	r8,r8[0x0]
800036c4:	58 08       	cp.w	r8,0
800036c6:	e0 80 01 08 	breq	800038d6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800036ca:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800036cc:	fe f8 0e 70 	ld.w	r8,pc[3696]
800036d0:	70 09       	ld.w	r9,r8[0x0]
800036d2:	2f f9       	sub	r9,-1
800036d4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800036d6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
800036da:	70 08       	ld.w	r8,r8[0x0]
800036dc:	58 18       	cp.w	r8,1
800036de:	e0 80 00 85 	breq	800037e8 <phy_rx_func+0x130>
800036e2:	c0 73       	brcs	800036f0 <phy_rx_func+0x38>
800036e4:	58 28       	cp.w	r8,2
800036e6:	c5 c0       	breq	8000379e <phy_rx_func+0xe6>
800036e8:	58 38       	cp.w	r8,3
800036ea:	e0 81 00 f6 	brne	800038d6 <phy_rx_func+0x21e>
800036ee:	cd 58       	rjmp	80003898 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800036f0:	e0 6a 5a 5a 	mov	r10,23130
800036f4:	ea 1a ab cd 	orh	r10,0xabcd
800036f8:	14 36       	cp.w	r6,r10
800036fa:	e0 80 00 ee 	breq	800038d6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800036fe:	ec 08 16 10 	lsr	r8,r6,0x10
80003702:	e0 48 ab cd 	cp.w	r8,43981
80003706:	e0 81 00 e8 	brne	800038d6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000370a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000370e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003712:	20 28       	sub	r8,2
80003714:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003718:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000371a:	30 09       	mov	r9,0
8000371c:	f2 08 19 00 	cp.h	r8,r9
80003720:	e0 8a 00 db 	brle	800038d6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003724:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003728:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000372a:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000372e:	70 0c       	ld.w	r12,r8[0x0]
80003730:	f0 1f 03 88 	mcall	80004550 <phy_rx_func+0xe98>
80003734:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003738:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000373a:	58 0c       	cp.w	r12,0
8000373c:	e0 80 00 cd 	breq	800038d6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003740:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003744:	90 09       	ld.sh	r9,r8[0x0]
80003746:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000374a:	2f f9       	sub	r9,-1
8000374c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000374e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80003752:	74 0a       	ld.w	r10,r10[0x0]
80003754:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003758:	76 0b       	ld.w	r11,r11[0x0]
8000375a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000375e:	2f f9       	sub	r9,-1
80003760:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003762:	e2 16 0f 00 	andl	r6,0xf00,COH
80003766:	e0 46 01 00 	cp.w	r6,256
8000376a:	c0 c0       	breq	80003782 <phy_rx_func+0xca>
8000376c:	e0 8b 00 05 	brhi	80003776 <phy_rx_func+0xbe>
80003770:	58 06       	cp.w	r6,0
80003772:	c0 80       	breq	80003782 <phy_rx_func+0xca>
80003774:	c0 c8       	rjmp	8000378c <phy_rx_func+0xd4>
80003776:	e0 46 02 00 	cp.w	r6,512
8000377a:	c0 40       	breq	80003782 <phy_rx_func+0xca>
8000377c:	e0 46 03 00 	cp.w	r6,768
80003780:	c0 61       	brne	8000378c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003782:	30 29       	mov	r9,2
80003784:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003788:	91 09       	st.w	r8[0x0],r9
8000378a:	ca 68       	rjmp	800038d6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
8000378c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003790:	70 0c       	ld.w	r12,r8[0x0]
80003792:	fe f8 0d c2 	ld.w	r8,pc[3522]
80003796:	70 0b       	ld.w	r11,r8[0x0]
80003798:	f0 1f 03 70 	mcall	80004558 <phy_rx_func+0xea0>
8000379c:	c9 d8       	rjmp	800038d6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000379e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800037a2:	b1 86       	lsr	r6,0x10
800037a4:	14 06       	add	r6,r10
800037a6:	fe f8 0d b6 	ld.w	r8,pc[3510]
800037aa:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800037ac:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800037b0:	90 09       	ld.sh	r9,r8[0x0]
800037b2:	fe fb 0d a2 	ld.w	r11,pc[3490]
800037b6:	76 0b       	ld.w	r11,r11[0x0]
800037b8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800037bc:	2f f9       	sub	r9,-1
800037be:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800037c0:	fe f9 0d 84 	ld.w	r9,pc[3460]
800037c4:	92 08       	ld.sh	r8,r9[0x0]
800037c6:	20 28       	sub	r8,2
800037c8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800037ca:	30 09       	mov	r9,0
800037cc:	f2 08 19 00 	cp.h	r8,r9
800037d0:	e0 8a 00 07 	brle	800037de <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800037d4:	30 19       	mov	r9,1
800037d6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800037da:	91 09       	st.w	r8[0x0],r9
800037dc:	c7 d8       	rjmp	800038d6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800037de:	30 39       	mov	r9,3
800037e0:	fe f8 0d 60 	ld.w	r8,pc[3424]
800037e4:	91 09       	st.w	r8[0x0],r9
800037e6:	c7 88       	rjmp	800038d6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800037e8:	ec 0a 14 10 	asr	r10,r6,0x10
800037ec:	fe f8 0d 70 	ld.w	r8,pc[3440]
800037f0:	90 09       	ld.sh	r9,r8[0x0]
800037f2:	14 09       	add	r9,r10
800037f4:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037f6:	fe f9 0d 52 	ld.w	r9,pc[3410]
800037fa:	92 08       	ld.sh	r8,r9[0x0]
800037fc:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003800:	76 0b       	ld.w	r11,r11[0x0]
80003802:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003806:	2f f8       	sub	r8,-1
80003808:	5c 88       	casts.h	r8
8000380a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000380c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003810:	94 09       	ld.sh	r9,r10[0x0]
80003812:	20 29       	sub	r9,2
80003814:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003816:	30 0a       	mov	r10,0
80003818:	f4 09 19 00 	cp.h	r9,r10
8000381c:	e0 89 00 20 	brgt	8000385c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003820:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003824:	e0 46 00 ba 	cp.w	r6,186
80003828:	c0 d1       	brne	80003842 <phy_rx_func+0x18a>
8000382a:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000382e:	90 09       	ld.sh	r9,r8[0x0]
80003830:	f4 09 19 00 	cp.h	r9,r10
80003834:	c0 71       	brne	80003842 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003836:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000383a:	70 0c       	ld.w	r12,r8[0x0]
8000383c:	f0 1f 03 49 	mcall	80004560 <phy_rx_func+0xea8>
80003840:	c0 98       	rjmp	80003852 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003842:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003846:	70 0c       	ld.w	r12,r8[0x0]
80003848:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000384c:	70 0b       	ld.w	r11,r8[0x0]
8000384e:	f0 1f 03 43 	mcall	80004558 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	c3 e8       	rjmp	800038d6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000385c:	5c 86       	casts.h	r6
8000385e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003862:	92 0a       	ld.sh	r10,r9[0x0]
80003864:	0c 0a       	add	r10,r6
80003866:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003868:	fe f9 0c ec 	ld.w	r9,pc[3308]
8000386c:	72 09       	ld.w	r9,r9[0x0]
8000386e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003872:	2f f8       	sub	r8,-1
80003874:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003878:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000387a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000387e:	92 08       	ld.sh	r8,r9[0x0]
80003880:	20 28       	sub	r8,2
80003882:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003884:	30 09       	mov	r9,0
80003886:	f2 08 19 00 	cp.h	r8,r9
8000388a:	e0 89 00 26 	brgt	800038d6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000388e:	30 39       	mov	r9,3
80003890:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003894:	91 09       	st.w	r8[0x0],r9
80003896:	c2 08       	rjmp	800038d6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003898:	e6 16 00 ff 	andh	r6,0xff,COH
8000389c:	fc 19 00 ba 	movh	r9,0xba
800038a0:	12 36       	cp.w	r6,r9
800038a2:	c0 e1       	brne	800038be <phy_rx_func+0x206>
800038a4:	fe f8 0c b8 	ld.w	r8,pc[3256]
800038a8:	90 09       	ld.sh	r9,r8[0x0]
800038aa:	30 08       	mov	r8,0
800038ac:	f0 09 19 00 	cp.h	r9,r8
800038b0:	c0 71       	brne	800038be <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800038b2:	fe f8 0c a2 	ld.w	r8,pc[3234]
800038b6:	70 0c       	ld.w	r12,r8[0x0]
800038b8:	f0 1f 03 2a 	mcall	80004560 <phy_rx_func+0xea8>
800038bc:	c0 98       	rjmp	800038ce <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800038be:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800038c2:	70 0c       	ld.w	r12,r8[0x0]
800038c4:	fe f8 0c 90 	ld.w	r8,pc[3216]
800038c8:	70 0b       	ld.w	r11,r8[0x0]
800038ca:	f0 1f 03 24 	mcall	80004558 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800038ce:	30 09       	mov	r9,0
800038d0:	fe f8 0c 70 	ld.w	r8,pc[3184]
800038d4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800038d6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800038da:	11 89       	ld.ub	r9,r8[0x0]
800038dc:	30 08       	mov	r8,0
800038de:	f0 09 18 00 	cp.b	r9,r8
800038e2:	c1 31       	brne	80003908 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800038e4:	fe f6 0c 84 	ld.w	r6,pc[3204]
800038e8:	6c 0c       	ld.w	r12,r6[0x0]
800038ea:	f0 1f 03 1a 	mcall	80004550 <phy_rx_func+0xe98>
800038ee:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800038f2:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800038f4:	6c 0c       	ld.w	r12,r6[0x0]
800038f6:	f0 1f 03 17 	mcall	80004550 <phy_rx_func+0xe98>
800038fa:	fe f8 0c 76 	ld.w	r8,pc[3190]
800038fe:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003900:	30 19       	mov	r9,1
80003902:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003906:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003908:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000390c:	70 08       	ld.w	r8,r8[0x0]
8000390e:	58 28       	cp.w	r8,2
80003910:	e0 80 01 98 	breq	80003c40 <phy_rx_func+0x588>
80003914:	e0 8b 00 06 	brhi	80003920 <phy_rx_func+0x268>
80003918:	58 08       	cp.w	r8,0
8000391a:	c0 b0       	breq	80003930 <phy_rx_func+0x278>
8000391c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003920:	58 38       	cp.w	r8,3
80003922:	e0 80 05 c5 	breq	800044ac <phy_rx_func+0xdf4>
80003926:	58 48       	cp.w	r8,4
80003928:	e0 81 06 05 	brne	80004532 <phy_rx_func+0xe7a>
8000392c:	e0 8f 02 4b 	bral	80003dc2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003930:	6e 28       	ld.w	r8,r7[0x8]
80003932:	e0 6a 5a 5a 	mov	r10,23130
80003936:	ea 1a ab cd 	orh	r10,0xabcd
8000393a:	14 38       	cp.w	r8,r10
8000393c:	c0 71       	brne	8000394a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000393e:	30 09       	mov	r9,0
80003940:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003944:	91 09       	st.w	r8[0x0],r9
80003946:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000394a:	10 99       	mov	r9,r8
8000394c:	e0 19 00 00 	andl	r9,0x0
80003950:	fc 1a ab cd 	movh	r10,0xabcd
80003954:	14 39       	cp.w	r9,r10
80003956:	e0 81 05 ee 	brne	80004532 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000395a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000395e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003962:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003964:	6e 29       	ld.w	r9,r7[0x8]
80003966:	e2 19 f0 00 	andl	r9,0xf000,COH
8000396a:	e0 49 c0 00 	cp.w	r9,49152
8000396e:	e0 81 00 ce 	brne	80003b0a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003972:	30 1a       	mov	r10,1
80003974:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003978:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000397a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000397e:	72 09       	ld.w	r9,r9[0x0]
80003980:	58 09       	cp.w	r9,0
80003982:	c0 71       	brne	80003990 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003984:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003988:	f0 1f 03 00 	mcall	80004588 <phy_rx_func+0xed0>
8000398c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003990:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003994:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003998:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000399a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000399e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800039a2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800039a6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800039a8:	13 89       	ld.ub	r9,r9[0x0]
800039aa:	37 fa       	mov	r10,127
800039ac:	f4 09 18 00 	cp.b	r9,r10
800039b0:	c6 d0       	breq	80003a8a <phy_rx_func+0x3d2>
800039b2:	e0 8b 00 0c 	brhi	800039ca <phy_rx_func+0x312>
800039b6:	31 2a       	mov	r10,18
800039b8:	f4 09 18 00 	cp.b	r9,r10
800039bc:	c4 20       	breq	80003a40 <phy_rx_func+0x388>
800039be:	31 3a       	mov	r10,19
800039c0:	f4 09 18 00 	cp.b	r9,r10
800039c4:	e0 81 00 83 	brne	80003aca <phy_rx_func+0x412>
800039c8:	c5 b8       	rjmp	80003a7e <phy_rx_func+0x3c6>
800039ca:	2f 09       	sub	r9,-16
800039cc:	30 1a       	mov	r10,1
800039ce:	f4 09 18 00 	cp.b	r9,r10
800039d2:	e0 8b 00 7c 	brhi	80003aca <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800039d6:	ef 38 00 0e 	ld.ub	r8,r7[14]
800039da:	e2 18 00 f0 	andl	r8,0xf0,COH
800039de:	59 08       	cp.w	r8,16
800039e0:	c0 71       	brne	800039ee <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800039e2:	30 19       	mov	r9,1
800039e4:	fe f8 0b 94 	ld.w	r8,pc[2964]
800039e8:	91 09       	st.w	r8[0x0],r9
800039ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800039ee:	e0 48 00 20 	cp.w	r8,32
800039f2:	c2 11       	brne	80003a34 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800039f4:	30 a9       	mov	r9,10
800039f6:	fe f8 0b 82 	ld.w	r8,pc[2946]
800039fa:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800039fc:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003a00:	6c 08       	ld.w	r8,r6[0x0]
80003a02:	f0 0a 11 ff 	rsub	r10,r8,-1
80003a06:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003a0a:	2f f8       	sub	r8,-1
80003a0c:	6e 0c       	ld.w	r12,r7[0x0]
80003a0e:	f4 ca fe 00 	sub	r10,r10,-512
80003a12:	30 0b       	mov	r11,0
80003a14:	10 0c       	add	r12,r8
80003a16:	f0 1f 02 e1 	mcall	80004598 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003a1a:	30 08       	mov	r8,0
80003a1c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003a1e:	6e 0c       	ld.w	r12,r7[0x0]
80003a20:	f0 1f 02 df 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a24:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003a28:	70 0c       	ld.w	r12,r8[0x0]
80003a2a:	f0 1f 02 ca 	mcall	80004550 <phy_rx_func+0xe98>
80003a2e:	8f 0c       	st.w	r7[0x0],r12
80003a30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003a34:	30 09       	mov	r9,0
80003a36:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003a3a:	91 09       	st.w	r8[0x0],r9
80003a3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a40:	20 48       	sub	r8,4
80003a42:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003a46:	93 08       	st.w	r9[0x0],r8
80003a48:	58 08       	cp.w	r8,0
80003a4a:	e0 80 05 74 	breq	80004532 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a4e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003a52:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a56:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003a5a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003a5c:	8e 69       	ld.sh	r9,r7[0xc]
80003a5e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003a62:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003a64:	8e 79       	ld.sh	r9,r7[0xe]
80003a66:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003a68:	f0 1f 02 d0 	mcall	800045a8 <phy_rx_func+0xef0>
80003a6c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003a70:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a72:	30 49       	mov	r9,4
80003a74:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003a78:	91 09       	st.w	r8[0x0],r9
80003a7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003a7e:	30 09       	mov	r9,0
80003a80:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003a84:	91 09       	st.w	r8[0x0],r9
80003a86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a8a:	20 48       	sub	r8,4
80003a8c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003a90:	93 08       	st.w	r9[0x0],r8
80003a92:	58 08       	cp.w	r8,0
80003a94:	e0 80 05 4f 	breq	80004532 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003a98:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003a9c:	70 09       	ld.w	r9,r8[0x0]
80003a9e:	8e 7b       	ld.sh	r11,r7[0xe]
80003aa0:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003aa4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003aa8:	2f f9       	sub	r9,-1
80003aaa:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003aac:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003ab0:	70 09       	ld.w	r9,r8[0x0]
80003ab2:	20 29       	sub	r9,2
80003ab4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003ab6:	30 29       	mov	r9,2
80003ab8:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003abc:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003abe:	30 39       	mov	r9,3
80003ac0:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003ac4:	91 09       	st.w	r8[0x0],r9
80003ac6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003aca:	30 3a       	mov	r10,3
80003acc:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003ad0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003ad2:	6e 2a       	ld.w	r10,r7[0x8]
80003ad4:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003ad8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003ada:	6e 3a       	ld.w	r10,r7[0xc]
80003adc:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003ade:	59 48       	cp.w	r8,20
80003ae0:	c0 61       	brne	80003aec <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003ae2:	31 89       	mov	r9,24
80003ae4:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003ae8:	91 09       	st.w	r8[0x0],r9
80003aea:	c0 a8       	rjmp	80003afe <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003aec:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003af0:	70 08       	ld.w	r8,r8[0x0]
80003af2:	59 08       	cp.w	r8,16
80003af4:	c0 51       	brne	80003afe <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003af6:	31 09       	mov	r9,16
80003af8:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003afc:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003afe:	30 49       	mov	r9,4
80003b00:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003b04:	91 09       	st.w	r8[0x0],r9
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003b0a:	e0 49 10 00 	cp.w	r9,4096
80003b0e:	5f 1a       	srne	r10
80003b10:	e0 49 20 00 	cp.w	r9,8192
80003b14:	5f 19       	srne	r9
80003b16:	f5 e9 00 09 	and	r9,r10,r9
80003b1a:	e0 81 05 0c 	brne	80004532 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003b1e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003b22:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003b24:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003b28:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003b2a:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003b2e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003b30:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003b34:	72 09       	ld.w	r9,r9[0x0]
80003b36:	58 09       	cp.w	r9,0
80003b38:	c0 71       	brne	80003b46 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003b3a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003b3e:	f0 1f 02 93 	mcall	80004588 <phy_rx_func+0xed0>
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b46:	6e 2a       	ld.w	r10,r7[0x8]
80003b48:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003b4c:	58 1a       	cp.w	r10,1
80003b4e:	e0 8b 00 4d 	brhi	80003be8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003b52:	20 48       	sub	r8,4
80003b54:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003b58:	93 08       	st.w	r9[0x0],r8
80003b5a:	58 08       	cp.w	r8,0
80003b5c:	e0 80 04 eb 	breq	80004532 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003b60:	8e 68       	ld.sh	r8,r7[0xc]
80003b62:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003b66:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003b6a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003b6c:	30 09       	mov	r9,0
80003b6e:	f2 08 19 00 	cp.h	r8,r9
80003b72:	c0 70       	breq	80003b80 <phy_rx_func+0x4c8>
80003b74:	30 19       	mov	r9,1
80003b76:	f2 08 19 00 	cp.h	r8,r9
80003b7a:	e0 81 04 dc 	brne	80004532 <phy_rx_func+0xe7a>
80003b7e:	c2 68       	rjmp	80003bca <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003b80:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003b84:	70 0a       	ld.w	r10,r8[0x0]
80003b86:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003b8a:	72 09       	ld.w	r9,r9[0x0]
80003b8c:	8e 7b       	ld.sh	r11,r7[0xe]
80003b8e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003b92:	70 09       	ld.w	r9,r8[0x0]
80003b94:	2f f9       	sub	r9,-1
80003b96:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003b98:	e0 49 00 ff 	cp.w	r9,255
80003b9c:	e0 88 00 11 	brls	80003bbe <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003ba0:	30 09       	mov	r9,0
80003ba2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003ba4:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003ba8:	6e 0c       	ld.w	r12,r7[0x0]
80003baa:	f0 1f 02 7d 	mcall	8000459c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003bae:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003bb2:	70 0c       	ld.w	r12,r8[0x0]
80003bb4:	f0 1f 02 67 	mcall	80004550 <phy_rx_func+0xe98>
80003bb8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003bba:	e0 80 04 bc 	breq	80004532 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003bbe:	30 29       	mov	r9,2
80003bc0:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003bc4:	91 09       	st.w	r8[0x0],r9
80003bc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bca:	8e 79       	ld.sh	r9,r7[0xe]
80003bcc:	30 38       	mov	r8,3
80003bce:	f0 09 19 00 	cp.h	r9,r8
80003bd2:	c0 51       	brne	80003bdc <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003bd4:	30 19       	mov	r9,1
80003bd6:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003bda:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003bdc:	30 29       	mov	r9,2
80003bde:	fe f8 09 96 	ld.w	r8,pc[2454]
80003be2:	91 09       	st.w	r8[0x0],r9
80003be4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003be8:	58 18       	cp.w	r8,1
80003bea:	e0 88 04 a4 	brls	80004532 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003bee:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003bf2:	70 0a       	ld.w	r10,r8[0x0]
80003bf4:	6e 3b       	ld.w	r11,r7[0xc]
80003bf6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003bfa:	70 09       	ld.w	r9,r8[0x0]
80003bfc:	2f f9       	sub	r9,-1
80003bfe:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c00:	e0 49 00 ff 	cp.w	r9,255
80003c04:	e0 88 00 11 	brls	80003c26 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003c08:	30 09       	mov	r9,0
80003c0a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c0c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003c10:	6e 0c       	ld.w	r12,r7[0x0]
80003c12:	f0 1f 02 63 	mcall	8000459c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c16:	fe f8 09 52 	ld.w	r8,pc[2386]
80003c1a:	70 0c       	ld.w	r12,r8[0x0]
80003c1c:	f0 1f 02 4d 	mcall	80004550 <phy_rx_func+0xe98>
80003c20:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003c22:	e0 80 04 88 	breq	80004532 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003c26:	fe f9 09 56 	ld.w	r9,pc[2390]
80003c2a:	72 08       	ld.w	r8,r9[0x0]
80003c2c:	20 28       	sub	r8,2
80003c2e:	93 08       	st.w	r9[0x0],r8
80003c30:	e0 80 04 81 	breq	80004532 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003c34:	30 29       	mov	r9,2
80003c36:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003c3a:	91 09       	st.w	r8[0x0],r9
80003c3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003c40:	fe f8 09 84 	ld.w	r8,pc[2436]
80003c44:	70 0a       	ld.w	r10,r8[0x0]
80003c46:	fe f9 09 26 	ld.w	r9,pc[2342]
80003c4a:	72 09       	ld.w	r9,r9[0x0]
80003c4c:	8e 4b       	ld.sh	r11,r7[0x8]
80003c4e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003c52:	70 09       	ld.w	r9,r8[0x0]
80003c54:	2f f9       	sub	r9,-1
80003c56:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c58:	e0 49 00 ff 	cp.w	r9,255
80003c5c:	e0 88 00 16 	brls	80003c88 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003c60:	30 09       	mov	r9,0
80003c62:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c64:	fe f6 09 08 	ld.w	r6,pc[2312]
80003c68:	6c 0c       	ld.w	r12,r6[0x0]
80003c6a:	f0 1f 02 4d 	mcall	8000459c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c6e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003c72:	70 0c       	ld.w	r12,r8[0x0]
80003c74:	f0 1f 02 37 	mcall	80004550 <phy_rx_func+0xe98>
80003c78:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003c7a:	c0 71       	brne	80003c88 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003c7c:	30 09       	mov	r9,0
80003c7e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003c82:	91 09       	st.w	r8[0x0],r9
80003c84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003c88:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003c8c:	72 08       	ld.w	r8,r9[0x0]
80003c8e:	20 28       	sub	r8,2
80003c90:	93 08       	st.w	r9[0x0],r8
80003c92:	c0 71       	brne	80003ca0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003c94:	30 09       	mov	r9,0
80003c96:	fe f8 08 de 	ld.w	r8,pc[2270]
80003c9a:	91 09       	st.w	r8[0x0],r9
80003c9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003ca0:	fe f8 09 24 	ld.w	r8,pc[2340]
80003ca4:	70 0a       	ld.w	r10,r8[0x0]
80003ca6:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003caa:	72 09       	ld.w	r9,r9[0x0]
80003cac:	8e 5b       	ld.sh	r11,r7[0xa]
80003cae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003cb2:	70 09       	ld.w	r9,r8[0x0]
80003cb4:	2f f9       	sub	r9,-1
80003cb6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003cb8:	e0 49 00 ff 	cp.w	r9,255
80003cbc:	e0 88 00 16 	brls	80003ce8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003cc0:	30 09       	mov	r9,0
80003cc2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cc4:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003cc8:	6c 0c       	ld.w	r12,r6[0x0]
80003cca:	f0 1f 02 35 	mcall	8000459c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003cce:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003cd2:	70 0c       	ld.w	r12,r8[0x0]
80003cd4:	f0 1f 02 1f 	mcall	80004550 <phy_rx_func+0xe98>
80003cd8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003cda:	c0 71       	brne	80003ce8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003cdc:	30 09       	mov	r9,0
80003cde:	fe f8 08 96 	ld.w	r8,pc[2198]
80003ce2:	91 09       	st.w	r8[0x0],r9
80003ce4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003ce8:	fe f9 08 94 	ld.w	r9,pc[2196]
80003cec:	72 08       	ld.w	r8,r9[0x0]
80003cee:	20 28       	sub	r8,2
80003cf0:	93 08       	st.w	r9[0x0],r8
80003cf2:	c0 71       	brne	80003d00 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003cf4:	30 09       	mov	r9,0
80003cf6:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003cfa:	91 09       	st.w	r8[0x0],r9
80003cfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003d00:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003d04:	70 0a       	ld.w	r10,r8[0x0]
80003d06:	fe f9 08 66 	ld.w	r9,pc[2150]
80003d0a:	72 09       	ld.w	r9,r9[0x0]
80003d0c:	8e 6b       	ld.sh	r11,r7[0xc]
80003d0e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d12:	70 09       	ld.w	r9,r8[0x0]
80003d14:	2f f9       	sub	r9,-1
80003d16:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d18:	e0 49 00 ff 	cp.w	r9,255
80003d1c:	e0 88 00 16 	brls	80003d48 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003d20:	30 09       	mov	r9,0
80003d22:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d24:	fe f6 08 48 	ld.w	r6,pc[2120]
80003d28:	6c 0c       	ld.w	r12,r6[0x0]
80003d2a:	f0 1f 02 1d 	mcall	8000459c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d2e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003d32:	70 0c       	ld.w	r12,r8[0x0]
80003d34:	f0 1f 02 07 	mcall	80004550 <phy_rx_func+0xe98>
80003d38:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d3a:	c0 71       	brne	80003d48 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003d3c:	30 09       	mov	r9,0
80003d3e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003d42:	91 09       	st.w	r8[0x0],r9
80003d44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003d48:	fe f9 08 34 	ld.w	r9,pc[2100]
80003d4c:	72 08       	ld.w	r8,r9[0x0]
80003d4e:	20 28       	sub	r8,2
80003d50:	93 08       	st.w	r9[0x0],r8
80003d52:	c0 71       	brne	80003d60 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003d54:	30 09       	mov	r9,0
80003d56:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003d5a:	91 09       	st.w	r8[0x0],r9
80003d5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003d60:	fe f8 08 64 	ld.w	r8,pc[2148]
80003d64:	70 0a       	ld.w	r10,r8[0x0]
80003d66:	fe f9 08 06 	ld.w	r9,pc[2054]
80003d6a:	72 09       	ld.w	r9,r9[0x0]
80003d6c:	8e 7b       	ld.sh	r11,r7[0xe]
80003d6e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d72:	70 09       	ld.w	r9,r8[0x0]
80003d74:	2f f9       	sub	r9,-1
80003d76:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d78:	e0 49 00 ff 	cp.w	r9,255
80003d7c:	e0 88 00 16 	brls	80003da8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003d80:	30 09       	mov	r9,0
80003d82:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d84:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003d88:	6e 0c       	ld.w	r12,r7[0x0]
80003d8a:	f0 1f 02 05 	mcall	8000459c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d8e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003d92:	70 0c       	ld.w	r12,r8[0x0]
80003d94:	f0 1f 01 ef 	mcall	80004550 <phy_rx_func+0xe98>
80003d98:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003d9a:	c0 71       	brne	80003da8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003d9c:	30 09       	mov	r9,0
80003d9e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003da2:	91 09       	st.w	r8[0x0],r9
80003da4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003da8:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003dac:	72 08       	ld.w	r8,r9[0x0]
80003dae:	20 28       	sub	r8,2
80003db0:	93 08       	st.w	r9[0x0],r8
80003db2:	e0 81 03 c0 	brne	80004532 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003db6:	30 09       	mov	r9,0
80003db8:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003dbc:	91 09       	st.w	r8[0x0],r9
80003dbe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003dc2:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003dc6:	11 89       	ld.ub	r9,r8[0x0]
80003dc8:	31 28       	mov	r8,18
80003dca:	f0 09 18 00 	cp.b	r9,r8
80003dce:	e0 81 01 4c 	brne	80004066 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003dd2:	ef 39 00 09 	ld.ub	r9,r7[9]
80003dd6:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003dda:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003ddc:	11 89       	ld.ub	r9,r8[0x0]
80003dde:	3f 28       	mov	r8,-14
80003de0:	f0 09 18 00 	cp.b	r9,r8
80003de4:	e0 81 01 3b 	brne	8000405a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003de8:	30 19       	mov	r9,1
80003dea:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003dee:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003df0:	6e 29       	ld.w	r9,r7[0x8]
80003df2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003df6:	fe f8 07 86 	ld.w	r8,pc[1926]
80003dfa:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003dfc:	8e 59       	ld.sh	r9,r7[0xa]
80003dfe:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e02:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003e04:	8e 69       	ld.sh	r9,r7[0xc]
80003e06:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003e08:	8e 79       	ld.sh	r9,r7[0xe]
80003e0a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003e0c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003e10:	fe f9 07 60 	ld.w	r9,pc[1888]
80003e14:	72 0a       	ld.w	r10,r9[0x0]
80003e16:	70 09       	ld.w	r9,r8[0x0]
80003e18:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003e1c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	2f f9       	sub	r9,-1
80003e24:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e26:	e0 49 01 ff 	cp.w	r9,511
80003e2a:	e0 88 00 16 	brls	80003e56 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003e2e:	30 09       	mov	r9,0
80003e30:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e32:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003e36:	6c 0c       	ld.w	r12,r6[0x0]
80003e38:	f0 1f 01 d9 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e3c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003e40:	70 0c       	ld.w	r12,r8[0x0]
80003e42:	f0 1f 01 c4 	mcall	80004550 <phy_rx_func+0xe98>
80003e46:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003e48:	c0 71       	brne	80003e56 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003e4a:	30 09       	mov	r9,0
80003e4c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003e50:	91 09       	st.w	r8[0x0],r9
80003e52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003e56:	fe f9 07 26 	ld.w	r9,pc[1830]
80003e5a:	72 08       	ld.w	r8,r9[0x0]
80003e5c:	20 18       	sub	r8,1
80003e5e:	93 08       	st.w	r9[0x0],r8
80003e60:	c0 71       	brne	80003e6e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003e62:	30 09       	mov	r9,0
80003e64:	fe f8 07 10 	ld.w	r8,pc[1808]
80003e68:	91 09       	st.w	r8[0x0],r9
80003e6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003e6e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003e72:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003e76:	72 0a       	ld.w	r10,r9[0x0]
80003e78:	70 09       	ld.w	r9,r8[0x0]
80003e7a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003e7e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e82:	70 09       	ld.w	r9,r8[0x0]
80003e84:	2f f9       	sub	r9,-1
80003e86:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e88:	e0 49 01 ff 	cp.w	r9,511
80003e8c:	e0 88 00 16 	brls	80003eb8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003e90:	30 09       	mov	r9,0
80003e92:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003e94:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003e98:	6c 0c       	ld.w	r12,r6[0x0]
80003e9a:	f0 1f 01 c1 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003e9e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003ea2:	70 0c       	ld.w	r12,r8[0x0]
80003ea4:	f0 1f 01 ab 	mcall	80004550 <phy_rx_func+0xe98>
80003ea8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003eaa:	c0 71       	brne	80003eb8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003eac:	30 09       	mov	r9,0
80003eae:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003eb2:	91 09       	st.w	r8[0x0],r9
80003eb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003eb8:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003ebc:	72 08       	ld.w	r8,r9[0x0]
80003ebe:	20 18       	sub	r8,1
80003ec0:	93 08       	st.w	r9[0x0],r8
80003ec2:	c0 71       	brne	80003ed0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003ec4:	30 09       	mov	r9,0
80003ec6:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003eca:	91 09       	st.w	r8[0x0],r9
80003ecc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003ed0:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003ed4:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003ed8:	72 0a       	ld.w	r10,r9[0x0]
80003eda:	70 09       	ld.w	r9,r8[0x0]
80003edc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003ee0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ee4:	70 09       	ld.w	r9,r8[0x0]
80003ee6:	2f f9       	sub	r9,-1
80003ee8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eea:	e0 49 01 ff 	cp.w	r9,511
80003eee:	e0 88 00 16 	brls	80003f1a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ef2:	30 09       	mov	r9,0
80003ef4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ef6:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003efa:	6c 0c       	ld.w	r12,r6[0x0]
80003efc:	f0 1f 01 a8 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f00:	fe f8 06 68 	ld.w	r8,pc[1640]
80003f04:	70 0c       	ld.w	r12,r8[0x0]
80003f06:	f0 1f 01 93 	mcall	80004550 <phy_rx_func+0xe98>
80003f0a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f0c:	c0 71       	brne	80003f1a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003f0e:	30 09       	mov	r9,0
80003f10:	fe f8 06 64 	ld.w	r8,pc[1636]
80003f14:	91 09       	st.w	r8[0x0],r9
80003f16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f1a:	fe f9 06 62 	ld.w	r9,pc[1634]
80003f1e:	72 08       	ld.w	r8,r9[0x0]
80003f20:	20 18       	sub	r8,1
80003f22:	93 08       	st.w	r9[0x0],r8
80003f24:	c0 71       	brne	80003f32 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003f26:	30 09       	mov	r9,0
80003f28:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003f2c:	91 09       	st.w	r8[0x0],r9
80003f2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003f32:	fe f8 06 62 	ld.w	r8,pc[1634]
80003f36:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003f3a:	72 0a       	ld.w	r10,r9[0x0]
80003f3c:	70 09       	ld.w	r9,r8[0x0]
80003f3e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003f42:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f46:	70 09       	ld.w	r9,r8[0x0]
80003f48:	2f f9       	sub	r9,-1
80003f4a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f4c:	e0 49 01 ff 	cp.w	r9,511
80003f50:	e0 88 00 16 	brls	80003f7c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f54:	30 09       	mov	r9,0
80003f56:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f58:	fe f6 06 18 	ld.w	r6,pc[1560]
80003f5c:	6c 0c       	ld.w	r12,r6[0x0]
80003f5e:	f0 1f 01 90 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f62:	fe f8 06 06 	ld.w	r8,pc[1542]
80003f66:	70 0c       	ld.w	r12,r8[0x0]
80003f68:	f0 1f 01 7a 	mcall	80004550 <phy_rx_func+0xe98>
80003f6c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f6e:	c0 71       	brne	80003f7c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003f70:	30 09       	mov	r9,0
80003f72:	fe f8 06 02 	ld.w	r8,pc[1538]
80003f76:	91 09       	st.w	r8[0x0],r9
80003f78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f7c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003f80:	72 08       	ld.w	r8,r9[0x0]
80003f82:	20 18       	sub	r8,1
80003f84:	93 08       	st.w	r9[0x0],r8
80003f86:	c0 71       	brne	80003f94 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003f88:	30 09       	mov	r9,0
80003f8a:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003f8e:	91 09       	st.w	r8[0x0],r9
80003f90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003f94:	fe f8 06 00 	ld.w	r8,pc[1536]
80003f98:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003f9c:	72 0a       	ld.w	r10,r9[0x0]
80003f9e:	70 09       	ld.w	r9,r8[0x0]
80003fa0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003fa4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fa8:	70 09       	ld.w	r9,r8[0x0]
80003faa:	2f f9       	sub	r9,-1
80003fac:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fae:	e0 49 01 ff 	cp.w	r9,511
80003fb2:	e0 88 00 16 	brls	80003fde <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003fb6:	30 09       	mov	r9,0
80003fb8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003fba:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003fbe:	6c 0c       	ld.w	r12,r6[0x0]
80003fc0:	f0 1f 01 77 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003fc4:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003fc8:	70 0c       	ld.w	r12,r8[0x0]
80003fca:	f0 1f 01 62 	mcall	80004550 <phy_rx_func+0xe98>
80003fce:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003fd0:	c0 71       	brne	80003fde <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003fd2:	30 09       	mov	r9,0
80003fd4:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003fd8:	91 09       	st.w	r8[0x0],r9
80003fda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003fde:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003fe2:	72 08       	ld.w	r8,r9[0x0]
80003fe4:	20 18       	sub	r8,1
80003fe6:	93 08       	st.w	r9[0x0],r8
80003fe8:	c0 71       	brne	80003ff6 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003fea:	30 09       	mov	r9,0
80003fec:	fe f8 05 88 	ld.w	r8,pc[1416]
80003ff0:	91 09       	st.w	r8[0x0],r9
80003ff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003ff6:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003ffa:	fe f9 05 76 	ld.w	r9,pc[1398]
80003ffe:	72 0a       	ld.w	r10,r9[0x0]
80004000:	70 09       	ld.w	r9,r8[0x0]
80004002:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004006:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000400a:	70 09       	ld.w	r9,r8[0x0]
8000400c:	2f f9       	sub	r9,-1
8000400e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004010:	e0 49 01 ff 	cp.w	r9,511
80004014:	e0 88 00 16 	brls	80004040 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80004018:	30 09       	mov	r9,0
8000401a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000401c:	fe f7 05 54 	ld.w	r7,pc[1364]
80004020:	6e 0c       	ld.w	r12,r7[0x0]
80004022:	f0 1f 01 5f 	mcall	8000459c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004026:	fe f8 05 42 	ld.w	r8,pc[1346]
8000402a:	70 0c       	ld.w	r12,r8[0x0]
8000402c:	f0 1f 01 49 	mcall	80004550 <phy_rx_func+0xe98>
80004030:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004032:	c0 71       	brne	80004040 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80004034:	30 09       	mov	r9,0
80004036:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000403a:	91 09       	st.w	r8[0x0],r9
8000403c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004040:	fe f9 05 3c 	ld.w	r9,pc[1340]
80004044:	72 08       	ld.w	r8,r9[0x0]
80004046:	20 18       	sub	r8,1
80004048:	93 08       	st.w	r9[0x0],r8
8000404a:	e0 81 02 74 	brne	80004532 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000404e:	30 09       	mov	r9,0
80004050:	fe f8 05 24 	ld.w	r8,pc[1316]
80004054:	91 09       	st.w	r8[0x0],r9
80004056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000405a:	30 09       	mov	r9,0
8000405c:	fe f8 05 18 	ld.w	r8,pc[1304]
80004060:	91 09       	st.w	r8[0x0],r9
80004062:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004066:	fe f8 05 26 	ld.w	r8,pc[1318]
8000406a:	11 89       	ld.ub	r9,r8[0x0]
8000406c:	3f 28       	mov	r8,-14
8000406e:	f0 09 18 00 	cp.b	r9,r8
80004072:	c4 31       	brne	800040f8 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004074:	8e 49       	ld.sh	r9,r7[0x8]
80004076:	fe f8 05 56 	ld.w	r8,pc[1366]
8000407a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000407c:	fe f8 05 18 	ld.w	r8,pc[1304]
80004080:	fe f9 04 f0 	ld.w	r9,pc[1264]
80004084:	72 0a       	ld.w	r10,r9[0x0]
80004086:	70 09       	ld.w	r9,r8[0x0]
80004088:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000408c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004090:	70 09       	ld.w	r9,r8[0x0]
80004092:	2f f9       	sub	r9,-1
80004094:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004096:	e0 49 01 ff 	cp.w	r9,511
8000409a:	e0 88 00 16 	brls	800040c6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000409e:	30 09       	mov	r9,0
800040a0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800040a2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800040a6:	6e 0c       	ld.w	r12,r7[0x0]
800040a8:	f0 1f 01 3d 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800040ac:	fe f8 04 bc 	ld.w	r8,pc[1212]
800040b0:	70 0c       	ld.w	r12,r8[0x0]
800040b2:	f0 1f 01 28 	mcall	80004550 <phy_rx_func+0xe98>
800040b6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800040b8:	c0 71       	brne	800040c6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800040ba:	30 09       	mov	r9,0
800040bc:	fe f8 04 b8 	ld.w	r8,pc[1208]
800040c0:	91 09       	st.w	r8[0x0],r9
800040c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800040c6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800040ca:	72 08       	ld.w	r8,r9[0x0]
800040cc:	20 18       	sub	r8,1
800040ce:	93 08       	st.w	r9[0x0],r8
800040d0:	c0 71       	brne	800040de <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800040d2:	30 09       	mov	r9,0
800040d4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800040d8:	91 09       	st.w	r8[0x0],r9
800040da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800040de:	20 18       	sub	r8,1
800040e0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800040e4:	93 08       	st.w	r9[0x0],r8
800040e6:	58 08       	cp.w	r8,0
800040e8:	e0 81 02 25 	brne	80004532 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800040ec:	30 09       	mov	r9,0
800040ee:	fe f8 04 86 	ld.w	r8,pc[1158]
800040f2:	91 09       	st.w	r8[0x0],r9
800040f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800040f8:	fe f8 04 94 	ld.w	r8,pc[1172]
800040fc:	11 89       	ld.ub	r9,r8[0x0]
800040fe:	3f 38       	mov	r8,-13
80004100:	f0 09 18 00 	cp.b	r9,r8
80004104:	e0 81 01 0c 	brne	8000431c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004108:	8e 49       	ld.sh	r9,r7[0x8]
8000410a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000410e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80004110:	8e 59       	ld.sh	r9,r7[0xa]
80004112:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80004114:	8e 69       	ld.sh	r9,r7[0xc]
80004116:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80004118:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000411c:	fe f9 04 54 	ld.w	r9,pc[1108]
80004120:	72 0a       	ld.w	r10,r9[0x0]
80004122:	70 09       	ld.w	r9,r8[0x0]
80004124:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004128:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000412c:	70 09       	ld.w	r9,r8[0x0]
8000412e:	2f f9       	sub	r9,-1
80004130:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004132:	e0 49 01 ff 	cp.w	r9,511
80004136:	e0 88 00 16 	brls	80004162 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000413a:	30 09       	mov	r9,0
8000413c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000413e:	fe f6 04 32 	ld.w	r6,pc[1074]
80004142:	6c 0c       	ld.w	r12,r6[0x0]
80004144:	f0 1f 01 16 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004148:	fe f8 04 20 	ld.w	r8,pc[1056]
8000414c:	70 0c       	ld.w	r12,r8[0x0]
8000414e:	f0 1f 01 01 	mcall	80004550 <phy_rx_func+0xe98>
80004152:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004154:	c0 71       	brne	80004162 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80004156:	30 09       	mov	r9,0
80004158:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000415c:	91 09       	st.w	r8[0x0],r9
8000415e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004162:	fe f9 04 1a 	ld.w	r9,pc[1050]
80004166:	72 08       	ld.w	r8,r9[0x0]
80004168:	20 18       	sub	r8,1
8000416a:	93 08       	st.w	r9[0x0],r8
8000416c:	c0 71       	brne	8000417a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000416e:	30 09       	mov	r9,0
80004170:	fe f8 04 04 	ld.w	r8,pc[1028]
80004174:	91 09       	st.w	r8[0x0],r9
80004176:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000417a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000417e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80004182:	72 0a       	ld.w	r10,r9[0x0]
80004184:	70 09       	ld.w	r9,r8[0x0]
80004186:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000418a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000418e:	70 09       	ld.w	r9,r8[0x0]
80004190:	2f f9       	sub	r9,-1
80004192:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004194:	e0 49 01 ff 	cp.w	r9,511
80004198:	e0 88 00 16 	brls	800041c4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000419c:	30 09       	mov	r9,0
8000419e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041a0:	fe f6 03 d0 	ld.w	r6,pc[976]
800041a4:	6c 0c       	ld.w	r12,r6[0x0]
800041a6:	f0 1f 00 fe 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041aa:	fe f8 03 be 	ld.w	r8,pc[958]
800041ae:	70 0c       	ld.w	r12,r8[0x0]
800041b0:	f0 1f 00 e8 	mcall	80004550 <phy_rx_func+0xe98>
800041b4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041b6:	c0 71       	brne	800041c4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800041b8:	30 09       	mov	r9,0
800041ba:	fe f8 03 ba 	ld.w	r8,pc[954]
800041be:	91 09       	st.w	r8[0x0],r9
800041c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041c4:	fe f9 03 b8 	ld.w	r9,pc[952]
800041c8:	72 08       	ld.w	r8,r9[0x0]
800041ca:	20 18       	sub	r8,1
800041cc:	93 08       	st.w	r9[0x0],r8
800041ce:	c0 71       	brne	800041dc <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800041d0:	30 09       	mov	r9,0
800041d2:	fe f8 03 a2 	ld.w	r8,pc[930]
800041d6:	91 09       	st.w	r8[0x0],r9
800041d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800041dc:	fe f8 03 b8 	ld.w	r8,pc[952]
800041e0:	fe f9 03 90 	ld.w	r9,pc[912]
800041e4:	72 0a       	ld.w	r10,r9[0x0]
800041e6:	70 09       	ld.w	r9,r8[0x0]
800041e8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800041ec:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041f0:	70 09       	ld.w	r9,r8[0x0]
800041f2:	2f f9       	sub	r9,-1
800041f4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041f6:	e0 49 01 ff 	cp.w	r9,511
800041fa:	e0 88 00 16 	brls	80004226 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800041fe:	30 09       	mov	r9,0
80004200:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004202:	fe f6 03 6e 	ld.w	r6,pc[878]
80004206:	6c 0c       	ld.w	r12,r6[0x0]
80004208:	f0 1f 00 e5 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000420c:	fe f8 03 5c 	ld.w	r8,pc[860]
80004210:	70 0c       	ld.w	r12,r8[0x0]
80004212:	f0 1f 00 d0 	mcall	80004550 <phy_rx_func+0xe98>
80004216:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004218:	c0 71       	brne	80004226 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000421a:	30 09       	mov	r9,0
8000421c:	fe f8 03 58 	ld.w	r8,pc[856]
80004220:	91 09       	st.w	r8[0x0],r9
80004222:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004226:	fe f9 03 56 	ld.w	r9,pc[854]
8000422a:	72 08       	ld.w	r8,r9[0x0]
8000422c:	20 18       	sub	r8,1
8000422e:	93 08       	st.w	r9[0x0],r8
80004230:	c0 71       	brne	8000423e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80004232:	30 09       	mov	r9,0
80004234:	fe f8 03 40 	ld.w	r8,pc[832]
80004238:	91 09       	st.w	r8[0x0],r9
8000423a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000423e:	fe f8 03 56 	ld.w	r8,pc[854]
80004242:	fe f9 03 2e 	ld.w	r9,pc[814]
80004246:	72 0a       	ld.w	r10,r9[0x0]
80004248:	70 09       	ld.w	r9,r8[0x0]
8000424a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000424e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004252:	70 09       	ld.w	r9,r8[0x0]
80004254:	2f f9       	sub	r9,-1
80004256:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004258:	e0 49 01 ff 	cp.w	r9,511
8000425c:	e0 88 00 16 	brls	80004288 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80004260:	30 09       	mov	r9,0
80004262:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004264:	fe f6 03 0c 	ld.w	r6,pc[780]
80004268:	6c 0c       	ld.w	r12,r6[0x0]
8000426a:	f0 1f 00 cd 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000426e:	fe f8 02 fa 	ld.w	r8,pc[762]
80004272:	70 0c       	ld.w	r12,r8[0x0]
80004274:	f0 1f 00 b7 	mcall	80004550 <phy_rx_func+0xe98>
80004278:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000427a:	c0 71       	brne	80004288 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
8000427c:	30 09       	mov	r9,0
8000427e:	fe f8 02 f6 	ld.w	r8,pc[758]
80004282:	91 09       	st.w	r8[0x0],r9
80004284:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004288:	fe f9 02 f4 	ld.w	r9,pc[756]
8000428c:	72 08       	ld.w	r8,r9[0x0]
8000428e:	20 18       	sub	r8,1
80004290:	93 08       	st.w	r9[0x0],r8
80004292:	c0 71       	brne	800042a0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80004294:	30 09       	mov	r9,0
80004296:	fe f8 02 de 	ld.w	r8,pc[734]
8000429a:	91 09       	st.w	r8[0x0],r9
8000429c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800042a0:	fe f8 02 f4 	ld.w	r8,pc[756]
800042a4:	fe f9 02 cc 	ld.w	r9,pc[716]
800042a8:	72 0a       	ld.w	r10,r9[0x0]
800042aa:	70 09       	ld.w	r9,r8[0x0]
800042ac:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800042b0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042b4:	70 09       	ld.w	r9,r8[0x0]
800042b6:	2f f9       	sub	r9,-1
800042b8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042ba:	e0 49 01 ff 	cp.w	r9,511
800042be:	e0 88 00 16 	brls	800042ea <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800042c2:	30 09       	mov	r9,0
800042c4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042c6:	fe f7 02 aa 	ld.w	r7,pc[682]
800042ca:	6e 0c       	ld.w	r12,r7[0x0]
800042cc:	f0 1f 00 b4 	mcall	8000459c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042d0:	fe f8 02 98 	ld.w	r8,pc[664]
800042d4:	70 0c       	ld.w	r12,r8[0x0]
800042d6:	f0 1f 00 9f 	mcall	80004550 <phy_rx_func+0xe98>
800042da:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042dc:	c0 71       	brne	800042ea <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800042de:	30 09       	mov	r9,0
800042e0:	fe f8 02 94 	ld.w	r8,pc[660]
800042e4:	91 09       	st.w	r8[0x0],r9
800042e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800042ea:	fe f9 02 92 	ld.w	r9,pc[658]
800042ee:	72 08       	ld.w	r8,r9[0x0]
800042f0:	20 18       	sub	r8,1
800042f2:	93 08       	st.w	r9[0x0],r8
800042f4:	c0 71       	brne	80004302 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
800042f6:	30 09       	mov	r9,0
800042f8:	fe f8 02 7c 	ld.w	r8,pc[636]
800042fc:	91 09       	st.w	r8[0x0],r9
800042fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004302:	20 18       	sub	r8,1
80004304:	fe f9 02 78 	ld.w	r9,pc[632]
80004308:	93 08       	st.w	r9[0x0],r8
8000430a:	58 08       	cp.w	r8,0
8000430c:	e0 81 01 13 	brne	80004532 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004310:	30 09       	mov	r9,0
80004312:	fe f8 02 62 	ld.w	r8,pc[610]
80004316:	91 09       	st.w	r8[0x0],r9
80004318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000431c:	fe f8 02 70 	ld.w	r8,pc[624]
80004320:	11 89       	ld.ub	r9,r8[0x0]
80004322:	30 48       	mov	r8,4
80004324:	f0 09 18 00 	cp.b	r9,r8
80004328:	c0 80       	breq	80004338 <phy_rx_func+0xc80>
8000432a:	fe f8 02 62 	ld.w	r8,pc[610]
8000432e:	11 89       	ld.ub	r9,r8[0x0]
80004330:	30 38       	mov	r8,3
80004332:	f0 09 18 00 	cp.b	r9,r8
80004336:	c1 41       	brne	8000435e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004338:	6e 29       	ld.w	r9,r7[0x8]
8000433a:	fe f8 02 7a 	ld.w	r8,pc[634]
8000433e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004340:	6e 39       	ld.w	r9,r7[0xc]
80004342:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004344:	fe f9 02 38 	ld.w	r9,pc[568]
80004348:	72 08       	ld.w	r8,r9[0x0]
8000434a:	20 88       	sub	r8,8
8000434c:	93 08       	st.w	r9[0x0],r8
8000434e:	e0 81 00 f2 	brne	80004532 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80004352:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004354:	fe f9 02 20 	ld.w	r9,pc[544]
80004358:	93 08       	st.w	r9[0x0],r8
8000435a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000435e:	fe f8 02 2e 	ld.w	r8,pc[558]
80004362:	11 89       	ld.ub	r9,r8[0x0]
80004364:	31 38       	mov	r8,19
80004366:	f0 09 18 00 	cp.b	r9,r8
8000436a:	e0 81 00 9c 	brne	800044a2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000436e:	fe f8 02 62 	ld.w	r8,pc[610]
80004372:	11 88       	ld.ub	r8,r8[0x0]
80004374:	30 c9       	mov	r9,12
80004376:	f2 08 18 00 	cp.b	r8,r9
8000437a:	e0 81 00 7b 	brne	80004470 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000437e:	8e 49       	ld.sh	r9,r7[0x8]
80004380:	fe f8 02 54 	ld.w	r8,pc[596]
80004384:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004388:	30 09       	mov	r9,0
8000438a:	fe f8 02 46 	ld.w	r8,pc[582]
8000438e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004390:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004394:	3f 38       	mov	r8,-13
80004396:	f0 09 18 00 	cp.b	r9,r8
8000439a:	c6 61       	brne	80004466 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
8000439c:	10 99       	mov	r9,r8
8000439e:	4f c8       	lddpc	r8,8000458c <phy_rx_func+0xed4>
800043a0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800043a2:	ef 39 00 0c 	ld.ub	r9,r7[12]
800043a6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800043aa:	4f 58       	lddpc	r8,8000457c <phy_rx_func+0xec4>
800043ac:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800043ae:	30 19       	mov	r9,1
800043b0:	fe f8 02 0c 	ld.w	r8,pc[524]
800043b4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800043b6:	8e 79       	ld.sh	r9,r7[0xe]
800043b8:	fe f8 02 14 	ld.w	r8,pc[532]
800043bc:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800043be:	4f 68       	lddpc	r8,80004594 <phy_rx_func+0xedc>
800043c0:	4e c9       	lddpc	r9,80004570 <phy_rx_func+0xeb8>
800043c2:	72 0a       	ld.w	r10,r9[0x0]
800043c4:	70 09       	ld.w	r9,r8[0x0]
800043c6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800043ca:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800043ce:	70 09       	ld.w	r9,r8[0x0]
800043d0:	2f f9       	sub	r9,-1
800043d2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800043d4:	e0 49 01 ff 	cp.w	r9,511
800043d8:	e0 88 00 13 	brls	800043fe <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800043dc:	30 09       	mov	r9,0
800043de:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800043e0:	4e 46       	lddpc	r6,80004570 <phy_rx_func+0xeb8>
800043e2:	6c 0c       	ld.w	r12,r6[0x0]
800043e4:	f0 1f 00 6e 	mcall	8000459c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800043e8:	4e 08       	lddpc	r8,80004568 <phy_rx_func+0xeb0>
800043ea:	70 0c       	ld.w	r12,r8[0x0]
800043ec:	f0 1f 00 59 	mcall	80004550 <phy_rx_func+0xe98>
800043f0:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800043f2:	c0 61       	brne	800043fe <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
800043f4:	30 09       	mov	r9,0
800043f6:	4e 08       	lddpc	r8,80004574 <phy_rx_func+0xebc>
800043f8:	91 09       	st.w	r8[0x0],r9
800043fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800043fe:	4e 09       	lddpc	r9,8000457c <phy_rx_func+0xec4>
80004400:	72 08       	ld.w	r8,r9[0x0]
80004402:	20 18       	sub	r8,1
80004404:	93 08       	st.w	r9[0x0],r8
80004406:	c0 61       	brne	80004412 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004408:	30 09       	mov	r9,0
8000440a:	4d b8       	lddpc	r8,80004574 <phy_rx_func+0xebc>
8000440c:	91 09       	st.w	r8[0x0],r9
8000440e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004412:	4e 18       	lddpc	r8,80004594 <phy_rx_func+0xedc>
80004414:	4d 79       	lddpc	r9,80004570 <phy_rx_func+0xeb8>
80004416:	72 0a       	ld.w	r10,r9[0x0]
80004418:	70 09       	ld.w	r9,r8[0x0]
8000441a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000441e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004422:	70 09       	ld.w	r9,r8[0x0]
80004424:	2f f9       	sub	r9,-1
80004426:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004428:	e0 49 01 ff 	cp.w	r9,511
8000442c:	e0 88 00 13 	brls	80004452 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80004430:	30 09       	mov	r9,0
80004432:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004434:	4c f7       	lddpc	r7,80004570 <phy_rx_func+0xeb8>
80004436:	6e 0c       	ld.w	r12,r7[0x0]
80004438:	f0 1f 00 59 	mcall	8000459c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000443c:	4c b8       	lddpc	r8,80004568 <phy_rx_func+0xeb0>
8000443e:	70 0c       	ld.w	r12,r8[0x0]
80004440:	f0 1f 00 44 	mcall	80004550 <phy_rx_func+0xe98>
80004444:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004446:	c0 61       	brne	80004452 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80004448:	30 09       	mov	r9,0
8000444a:	4c b8       	lddpc	r8,80004574 <phy_rx_func+0xebc>
8000444c:	91 09       	st.w	r8[0x0],r9
8000444e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004452:	4c b9       	lddpc	r9,8000457c <phy_rx_func+0xec4>
80004454:	72 08       	ld.w	r8,r9[0x0]
80004456:	20 18       	sub	r8,1
80004458:	93 08       	st.w	r9[0x0],r8
8000445a:	c6 c1       	brne	80004532 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
8000445c:	30 09       	mov	r9,0
8000445e:	4c 68       	lddpc	r8,80004574 <phy_rx_func+0xebc>
80004460:	91 09       	st.w	r8[0x0],r9
80004462:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004466:	30 09       	mov	r9,0
80004468:	4c 38       	lddpc	r8,80004574 <phy_rx_func+0xebc>
8000446a:	91 09       	st.w	r8[0x0],r9
8000446c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004470:	8e 4a       	ld.sh	r10,r7[0x8]
80004472:	4d 99       	lddpc	r9,800045d4 <phy_rx_func+0xf1c>
80004474:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004478:	4d 6a       	lddpc	r10,800045d0 <phy_rx_func+0xf18>
8000447a:	15 88       	ld.ub	r8,r10[0x0]
8000447c:	f0 cb ff ff 	sub	r11,r8,-1
80004480:	8e 5c       	ld.sh	r12,r7[0xa]
80004482:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80004486:	f0 cb ff fe 	sub	r11,r8,-2
8000448a:	8e 6c       	ld.sh	r12,r7[0xc]
8000448c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004490:	f0 cb ff fd 	sub	r11,r8,-3
80004494:	8e 7c       	ld.sh	r12,r7[0xe]
80004496:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000449a:	2f c8       	sub	r8,-4
8000449c:	b4 88       	st.b	r10[0x0],r8
8000449e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800044a2:	30 09       	mov	r9,0
800044a4:	4b 48       	lddpc	r8,80004574 <phy_rx_func+0xebc>
800044a6:	91 09       	st.w	r8[0x0],r9
800044a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800044ac:	4c 08       	lddpc	r8,800045ac <phy_rx_func+0xef4>
800044ae:	70 09       	ld.w	r9,r8[0x0]
800044b0:	8e 4b       	ld.sh	r11,r7[0x8]
800044b2:	4c 0a       	lddpc	r10,800045b0 <phy_rx_func+0xef8>
800044b4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800044b8:	2f f9       	sub	r9,-1
800044ba:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800044bc:	4b 58       	lddpc	r8,80004590 <phy_rx_func+0xed8>
800044be:	70 09       	ld.w	r9,r8[0x0]
800044c0:	20 29       	sub	r9,2
800044c2:	91 09       	st.w	r8[0x0],r9
800044c4:	70 08       	ld.w	r8,r8[0x0]
800044c6:	58 08       	cp.w	r8,0
800044c8:	c2 f1       	brne	80004526 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800044ca:	30 09       	mov	r9,0
800044cc:	4b 88       	lddpc	r8,800045ac <phy_rx_func+0xef4>
800044ce:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800044d0:	8e 59       	ld.sh	r9,r7[0xa]
800044d2:	fe 78 82 12 	mov	r8,-32238
800044d6:	f0 09 19 00 	cp.h	r9,r8
800044da:	c2 11       	brne	8000451c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800044dc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800044e0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800044e4:	4a f8       	lddpc	r8,800045a0 <phy_rx_func+0xee8>
800044e6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800044e8:	8e 59       	ld.sh	r9,r7[0xa]
800044ea:	4a f8       	lddpc	r8,800045a4 <phy_rx_func+0xeec>
800044ec:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800044ee:	8e 69       	ld.sh	r9,r7[0xc]
800044f0:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800044f2:	f0 1f 00 2e 	mcall	800045a8 <phy_rx_func+0xef0>
800044f6:	4a 18       	lddpc	r8,80004578 <phy_rx_func+0xec0>
800044f8:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800044fa:	ef 39 00 0f 	ld.ub	r9,r7[15]
800044fe:	31 38       	mov	r8,19
80004500:	f0 09 18 00 	cp.b	r9,r8
80004504:	c0 71       	brne	80004512 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004506:	10 99       	mov	r9,r8
80004508:	4a 18       	lddpc	r8,8000458c <phy_rx_func+0xed4>
8000450a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000450c:	30 09       	mov	r9,0
8000450e:	49 c8       	lddpc	r8,8000457c <phy_rx_func+0xec4>
80004510:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004512:	30 49       	mov	r9,4
80004514:	49 88       	lddpc	r8,80004574 <phy_rx_func+0xebc>
80004516:	91 09       	st.w	r8[0x0],r9
80004518:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000451c:	30 09       	mov	r9,0
8000451e:	49 68       	lddpc	r8,80004574 <phy_rx_func+0xebc>
80004520:	91 09       	st.w	r8[0x0],r9
80004522:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004526:	4a dc       	lddpc	r12,800045d8 <phy_rx_func+0xf20>
80004528:	f0 1f 00 18 	mcall	80004588 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
8000452c:	30 09       	mov	r9,0
8000452e:	49 28       	lddpc	r8,80004574 <phy_rx_func+0xebc>
80004530:	91 09       	st.w	r8[0x0],r9
80004532:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004536:	00 00       	add	r0,r0
80004538:	00 00       	add	r0,r0
8000453a:	0a d0       	st.w	--r5,r0
8000453c:	00 00       	add	r0,r0
8000453e:	0a e8       	st.h	--r5,r8
80004540:	00 00       	add	r0,r0
80004542:	0a c8       	st.b	r5++,r8
80004544:	00 00       	add	r0,r0
80004546:	0a aa       	st.w	r5++,r10
80004548:	00 00       	add	r0,r0
8000454a:	0a 98       	mov	r8,r5
8000454c:	00 00       	add	r0,r0
8000454e:	0a c0       	st.b	r5++,r0
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	35 38       	mov	r8,83
80004554:	00 00       	add	r0,r0
80004556:	0a b8       	st.h	r5++,r8
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	34 50       	mov	r0,69
8000455c:	00 00       	add	r0,r0
8000455e:	0a cc       	st.b	r5++,r12
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	34 84       	mov	r4,72
80004564:	00 00       	add	r0,r0
80004566:	0a a9       	st.w	r5++,r9
80004568:	00 00       	add	r0,r0
8000456a:	0a c4       	st.b	r5++,r4
8000456c:	00 00       	add	r0,r0
8000456e:	0a d4       	st.w	--r5,r4
80004570:	00 00       	add	r0,r0
80004572:	0a ac       	st.w	r5++,r12
80004574:	00 00       	add	r0,r0
80004576:	0a f4       	st.b	--r5,r4
80004578:	00 00       	add	r0,r0
8000457a:	0a dc       	st.w	--r5,r12
8000457c:	00 00       	add	r0,r0
8000457e:	0a 94       	mov	r4,r5
80004580:	00 00       	add	r0,r0
80004582:	0a 80       	andn	r0,r5
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	e9 30 80 00 	ld.ub	r0,r4[-32768]
8000458a:	80 88       	ld.uh	r8,r0[0x0]
8000458c:	00 00       	add	r0,r0
8000458e:	0a a8       	st.w	r5++,r8
80004590:	00 00       	add	r0,r0
80004592:	0b 00       	ld.w	r0,r5++
80004594:	00 00       	add	r0,r0
80004596:	0a e0       	st.h	--r5,r0
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	88 ee       	ld.uh	lr,r4[0xc]
8000459c:	80 00       	ld.sh	r0,r0[0x0]
8000459e:	34 6c       	mov	r12,70
800045a0:	00 00       	add	r0,r0
800045a2:	0a 62       	and	r2,r5
800045a4:	00 00       	add	r0,r0
800045a6:	1f 30       	ld.ub	r0,pc++
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	34 20       	mov	r0,66
800045ac:	00 00       	add	r0,r0
800045ae:	0a 9c       	mov	r12,r5
800045b0:	00 00       	add	r0,r0
800045b2:	1e 34       	cp.w	r4,pc
800045b4:	00 00       	add	r0,r0
800045b6:	0a a0       	st.w	r5++,r0
800045b8:	00 00       	add	r0,r0
800045ba:	0a 58       	eor	r8,r5
800045bc:	00 00       	add	r0,r0
800045be:	0a 68       	and	r8,r5
800045c0:	00 00       	add	r0,r0
800045c2:	0a f8       	st.b	--r5,r8
800045c4:	00 00       	add	r0,r0
800045c6:	0a b4       	st.h	r5++,r4
800045c8:	00 00       	add	r0,r0
800045ca:	0a 82       	andn	r2,r5
800045cc:	00 00       	add	r0,r0
800045ce:	1e 2c       	rsub	r12,pc
800045d0:	00 00       	add	r0,r0
800045d2:	0a ec       	st.h	--r5,r12
800045d4:	00 00       	add	r0,r0
800045d6:	1f 34       	ld.ub	r4,pc++
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	e9 48 d4 01 	st.w	r4[-11263],r8

800045dc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800045dc:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
800045de:	49 a8       	lddpc	r8,80004644 <pdca_int_handler+0x68>
800045e0:	70 09       	ld.w	r9,r8[0x0]
800045e2:	2f f9       	sub	r9,-1
800045e4:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800045e6:	49 98       	lddpc	r8,80004648 <pdca_int_handler+0x6c>
800045e8:	11 89       	ld.ub	r9,r8[0x0]
800045ea:	ec 19 00 01 	eorl	r9,0x1
800045ee:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800045f0:	11 89       	ld.ub	r9,r8[0x0]
800045f2:	a5 69       	lsl	r9,0x4
800045f4:	2f c9       	sub	r9,-4
800045f6:	49 6a       	lddpc	r10,8000464c <pdca_int_handler+0x70>
800045f8:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800045fa:	fe 7a 00 40 	mov	r10,-65472
800045fe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004600:	30 39       	mov	r9,3
80004602:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004604:	11 8a       	ld.ub	r10,r8[0x0]
80004606:	a5 6a       	lsl	r10,0x4
80004608:	2f ca       	sub	r10,-4
8000460a:	49 28       	lddpc	r8,80004650 <pdca_int_handler+0x74>
8000460c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000460e:	fe 78 00 00 	mov	r8,-65536
80004612:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004614:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004616:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004618:	48 f8       	lddpc	r8,80004654 <pdca_int_handler+0x78>
8000461a:	70 08       	ld.w	r8,r8[0x0]
8000461c:	58 08       	cp.w	r8,0
8000461e:	c0 70       	breq	8000462c <pdca_int_handler+0x50>
80004620:	48 a9       	lddpc	r9,80004648 <pdca_int_handler+0x6c>
80004622:	13 89       	ld.ub	r9,r9[0x0]
80004624:	a5 69       	lsl	r9,0x4
80004626:	48 bc       	lddpc	r12,80004650 <pdca_int_handler+0x74>
80004628:	12 0c       	add	r12,r9
8000462a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000462c:	48 b8       	lddpc	r8,80004658 <pdca_int_handler+0x7c>
8000462e:	70 08       	ld.w	r8,r8[0x0]
80004630:	58 08       	cp.w	r8,0
80004632:	c0 70       	breq	80004640 <pdca_int_handler+0x64>
80004634:	48 59       	lddpc	r9,80004648 <pdca_int_handler+0x6c>
80004636:	13 89       	ld.ub	r9,r9[0x0]
80004638:	a5 69       	lsl	r9,0x4
8000463a:	48 5c       	lddpc	r12,8000464c <pdca_int_handler+0x70>
8000463c:	12 0c       	add	r12,r9
8000463e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004640:	d4 02       	popm	lr
80004642:	d6 03       	rete
80004644:	00 00       	add	r0,r0
80004646:	0b 08       	ld.w	r8,r5++
80004648:	00 00       	add	r0,r0
8000464a:	97 54       	st.w	r11[0x14],r4
8000464c:	00 00       	add	r0,r0
8000464e:	97 7c       	st.w	r11[0x1c],r12
80004650:	00 00       	add	r0,r0
80004652:	97 5c       	st.w	r11[0x14],r12
80004654:	00 00       	add	r0,r0
80004656:	0b 04       	ld.w	r4,r5++
80004658:	00 00       	add	r0,r0
8000465a:	0b 0c       	ld.w	r12,r5++

8000465c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
8000465c:	fe 78 10 00 	mov	r8,-61440
80004660:	e0 69 0d c0 	mov	r9,3520
80004664:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004668:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000466c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004670:	fe 78 34 00 	mov	r8,-52224
80004674:	e0 69 80 00 	mov	r9,32768
80004678:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000467a:	30 09       	mov	r9,0
8000467c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000467e:	e0 69 04 21 	mov	r9,1057
80004682:	ea 19 3f 20 	orh	r9,0x3f20
80004686:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004688:	e0 69 02 9f 	mov	r9,671
8000468c:	ea 19 01 00 	orh	r9,0x100
80004690:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80004692:	e0 6a 04 02 	mov	r10,1026
80004696:	ea 1a 3f 20 	orh	r10,0x3f20
8000469a:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
8000469c:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000469e:	5e fc       	retal	r12

800046a0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800046a0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800046a2:	30 19       	mov	r9,1
800046a4:	49 78       	lddpc	r8,80004700 <local_start_PDC+0x60>
800046a6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800046a8:	fe 78 00 00 	mov	r8,-65536
800046ac:	30 7b       	mov	r11,7
800046ae:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800046b0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800046b2:	49 59       	lddpc	r9,80004704 <local_start_PDC+0x64>
800046b4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800046b8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800046ba:	30 3a       	mov	r10,3
800046bc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800046be:	30 1c       	mov	r12,1
800046c0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800046c2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800046c4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800046c6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800046c8:	30 2c       	mov	r12,2
800046ca:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800046cc:	48 f9       	lddpc	r9,80004708 <local_start_PDC+0x68>
800046ce:	e0 68 5a 5a 	mov	r8,23130
800046d2:	ea 18 ab cd 	orh	r8,0xabcd
800046d6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800046d8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800046da:	30 0e       	mov	lr,0
800046dc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800046de:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800046e0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800046e2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800046e4:	fe 78 00 40 	mov	r8,-65472
800046e8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800046ea:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800046ec:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800046f0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800046f2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800046f4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800046f6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800046f8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800046fa:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800046fc:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800046fe:	d8 02       	popm	pc
80004700:	00 00       	add	r0,r0
80004702:	97 54       	st.w	r11[0x14],r4
80004704:	00 00       	add	r0,r0
80004706:	97 5c       	st.w	r11[0x14],r12
80004708:	00 00       	add	r0,r0
8000470a:	97 7c       	st.w	r11[0x1c],r12

8000470c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
8000470c:	48 38       	lddpc	r8,80004718 <register_rx_tx_func+0xc>
8000470e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004710:	48 38       	lddpc	r8,8000471c <register_rx_tx_func+0x10>
80004712:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004714:	5e fc       	retal	r12
80004716:	00 00       	add	r0,r0
80004718:	00 00       	add	r0,r0
8000471a:	0b 04       	ld.w	r4,r5++
8000471c:	00 00       	add	r0,r0
8000471e:	0b 0c       	ld.w	r12,r5++

80004720 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004720:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004722:	fe 78 10 00 	mov	r8,-61440
80004726:	30 29       	mov	r9,2
80004728:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000472c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80004730:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80004732:	30 3a       	mov	r10,3
80004734:	36 0b       	mov	r11,96
80004736:	49 4c       	lddpc	r12,80004784 <ssc_init+0x64>
80004738:	f0 1f 00 14 	mcall	80004788 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
8000473c:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000473e:	fe 79 10 00 	mov	r9,-61440
80004742:	f2 f8 01 60 	ld.w	r8,r9[352]
80004746:	e2 18 00 02 	andl	r8,0x2,COH
8000474a:	cf c0       	breq	80004742 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000474c:	fe 79 10 00 	mov	r9,-61440
80004750:	f2 f8 01 60 	ld.w	r8,r9[352]
80004754:	e2 18 00 02 	andl	r8,0x2,COH
80004758:	cf c1       	brne	80004750 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
8000475a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
8000475c:	f0 1f 00 0c 	mcall	8000478c <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80004760:	f0 1f 00 0c 	mcall	80004790 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004764:	fe 79 00 00 	mov	r9,-65536
80004768:	30 18       	mov	r8,1
8000476a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000476c:	fe 7a 00 40 	mov	r10,-65472
80004770:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004772:	e0 6b 01 01 	mov	r11,257
80004776:	fe 7a 34 00 	mov	r10,-52224
8000477a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
8000477c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
8000477e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004780:	d8 02       	popm	pc
80004782:	00 00       	add	r0,r0
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	45 dc       	lddsp	r12,sp[0x174]
80004788:	80 00       	ld.sh	r0,r0[0x0]
8000478a:	63 4c       	ld.w	r12,r1[0x50]
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	46 5c       	lddsp	r12,sp[0x194]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	46 a0       	lddsp	r0,sp[0x1a8]

80004794 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004794:	48 28       	lddpc	r8,8000479c <xcmp_register_app_list+0x8>
80004796:	91 0c       	st.w	r8[0x0],r12
}
80004798:	5e fc       	retal	r12
8000479a:	00 00       	add	r0,r0
8000479c:	00 00       	add	r0,r0
8000479e:	97 9c       	st.w	r11[0x24],r12

800047a0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800047a0:	eb cd 40 80 	pushm	r7,lr
800047a4:	fa cd 01 00 	sub	sp,sp,256
800047a8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800047aa:	16 98       	mov	r8,r11
800047ac:	2f 08       	sub	r8,-16
800047ae:	af a8       	sbr	r8,0xe
800047b0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800047b2:	3f f8       	mov	r8,-1
800047b4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800047b6:	30 b9       	mov	r9,11
800047b8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800047ba:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800047bc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800047be:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047c0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800047c2:	f6 ca ff fe 	sub	r10,r11,-2
800047c6:	18 9b       	mov	r11,r12
800047c8:	fa cc ff f0 	sub	r12,sp,-16
800047cc:	f0 1f 00 05 	mcall	800047e0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800047d0:	2f e7       	sub	r7,-2
800047d2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800047d4:	1a 9c       	mov	r12,sp
800047d6:	f0 1f 00 04 	mcall	800047e4 <xcmp_tx+0x44>
}
800047da:	2c 0d       	sub	sp,-256
800047dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	87 a6       	st.w	r3[0x28],r6
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	4d b0       	lddpc	r0,80004950 <xcmp_IdleTestTone+0x2c>

800047e8 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
800047e8:	d4 21       	pushm	r4-r7,lr
800047ea:	fa cd 00 d0 	sub	sp,sp,208
800047ee:	18 94       	mov	r4,r12
800047f0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800047f2:	e0 68 01 00 	mov	r8,256
800047f6:	f0 0b 19 00 	cp.h	r11,r8
800047fa:	e0 8b 00 38 	brhi	8000486a <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
800047fe:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80004802:	e0 68 04 1d 	mov	r8,1053
80004806:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004808:	30 18       	mov	r8,1
8000480a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
8000480c:	32 08       	mov	r8,32
8000480e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004810:	30 28       	mov	r8,2
80004812:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004814:	30 48       	mov	r8,4
80004816:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004818:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
8000481c:	ea 1a 0c 00 	orh	r10,0xc00
80004820:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004822:	30 4a       	mov	r10,4
80004824:	1a 9b       	mov	r11,sp
80004826:	fa cc ff f4 	sub	r12,sp,-12
8000482a:	f0 1f 00 12 	mcall	80004870 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
8000482e:	30 f8       	mov	r8,15
80004830:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004834:	3a 78       	mov	r8,-89
80004836:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000483a:	30 08       	mov	r8,0
8000483c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004840:	0e 9a       	mov	r10,r7
80004842:	5c 7a       	castu.h	r10
80004844:	f4 08 16 08 	lsr	r8,r10,0x8
80004848:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
8000484c:	0e 96       	mov	r6,r7
8000484e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004852:	08 9b       	mov	r11,r4
80004854:	fa cc ff eb 	sub	r12,sp,-21
80004858:	f0 1f 00 06 	mcall	80004870 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
8000485c:	ee cb ff f3 	sub	r11,r7,-13
80004860:	5c 5b       	castu.b	r11
80004862:	fa cc ff fa 	sub	r12,sp,-6
80004866:	f0 1f 00 04 	mcall	80004874 <xcmp_data_session_req+0x8c>
}
8000486a:	2c cd       	sub	sp,-208
8000486c:	d8 22       	popm	r4-r7,pc
8000486e:	00 00       	add	r0,r0
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	87 a6       	st.w	r3[0x28],r6
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	47 a0       	lddsp	r0,sp[0x1e8]

80004878 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004878:	d4 01       	pushm	lr
8000487a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000487e:	fe 78 b4 00 	mov	r8,-19456
80004882:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004884:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004888:	30 89       	mov	r9,8
8000488a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000488c:	30 19       	mov	r9,1
8000488e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004890:	30 09       	mov	r9,0
80004892:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004894:	30 5a       	mov	r10,5
80004896:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004898:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000489a:	30 7a       	mov	r10,7
8000489c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000489e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800048a0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800048a2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800048a6:	30 9b       	mov	r11,9
800048a8:	fa cc ff fe 	sub	r12,sp,-2
800048ac:	f0 1f 00 02 	mcall	800048b4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800048b0:	2c dd       	sub	sp,-204
800048b2:	d8 02       	popm	pc
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	47 a0       	lddsp	r0,sp[0x1e8]

800048b8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800048b8:	d4 01       	pushm	lr
800048ba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800048be:	fe 78 80 00 	mov	r8,-32768
800048c2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800048c4:	30 38       	mov	r8,3
800048c6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800048c8:	30 1b       	mov	r11,1
800048ca:	fa cc ff fe 	sub	r12,sp,-2
800048ce:	f0 1f 00 03 	mcall	800048d8 <xcmp_opcode_not_supported+0x20>
}
800048d2:	2c dd       	sub	sp,-204
800048d4:	d8 02       	popm	pc
800048d6:	00 00       	add	r0,r0
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	47 a0       	lddsp	r0,sp[0x1e8]

800048dc <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800048dc:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800048de:	96 88       	ld.uh	r8,r11[0x0]
800048e0:	e2 18 f0 00 	andl	r8,0xf000,COH
800048e4:	e0 48 80 00 	cp.w	r8,32768
800048e8:	c0 f0       	breq	80004906 <xcmp_exec_func+0x2a>
800048ea:	e0 48 b0 00 	cp.w	r8,45056
800048ee:	c1 20       	breq	80004912 <xcmp_exec_func+0x36>
800048f0:	58 08       	cp.w	r8,0
800048f2:	c1 51       	brne	8000491c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800048f4:	78 08       	ld.w	r8,r12[0x0]
800048f6:	58 08       	cp.w	r8,0
800048f8:	c0 40       	breq	80004900 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800048fa:	16 9c       	mov	r12,r11
800048fc:	5d 18       	icall	r8
800048fe:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004900:	f0 1f 00 08 	mcall	80004920 <xcmp_exec_func+0x44>
80004904:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004906:	78 18       	ld.w	r8,r12[0x4]
80004908:	58 08       	cp.w	r8,0
8000490a:	c0 90       	breq	8000491c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000490c:	16 9c       	mov	r12,r11
8000490e:	5d 18       	icall	r8
80004910:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004912:	78 28       	ld.w	r8,r12[0x8]
80004914:	58 08       	cp.w	r8,0
80004916:	c0 30       	breq	8000491c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004918:	16 9c       	mov	r12,r11
8000491a:	5d 18       	icall	r8
8000491c:	d8 02       	popm	pc
8000491e:	00 00       	add	r0,r0
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	48 b8       	lddpc	r8,8000494c <xcmp_IdleTestTone+0x28>

80004924 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004924:	d4 01       	pushm	lr
80004926:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000492a:	e0 68 04 09 	mov	r8,1033
8000492e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004930:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004934:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004936:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000493a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000493c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000493e:	30 09       	mov	r9,0
80004940:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004942:	fb 69 00 08 	st.b	sp[8],r9
80004946:	fa c8 ff f7 	sub	r8,sp,-9
8000494a:	b0 89       	st.b	r8[0x0],r9
8000494c:	fa c8 ff f6 	sub	r8,sp,-10
80004950:	b0 89       	st.b	r8[0x0],r9
80004952:	fa c8 ff f5 	sub	r8,sp,-11
80004956:	b0 89       	st.b	r8[0x0],r9
80004958:	fa c8 ff f4 	sub	r8,sp,-12
8000495c:	b0 89       	st.b	r8[0x0],r9
8000495e:	fa c8 ff f3 	sub	r8,sp,-13
80004962:	b0 89       	st.b	r8[0x0],r9
80004964:	fa c8 ff f2 	sub	r8,sp,-14
80004968:	b0 89       	st.b	r8[0x0],r9
8000496a:	fa c8 ff f1 	sub	r8,sp,-15
8000496e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004970:	30 cb       	mov	r11,12
80004972:	fa cc ff fe 	sub	r12,sp,-2
80004976:	f0 1f 00 03 	mcall	80004980 <xcmp_IdleTestTone+0x5c>
}
8000497a:	2c dd       	sub	sp,-204
8000497c:	d8 02       	popm	pc
8000497e:	00 00       	add	r0,r0
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	47 a0       	lddsp	r0,sp[0x1e8]

80004984 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004984:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004986:	48 dc       	lddpc	r12,800049b8 <xcmp_init+0x34>
80004988:	f0 1f 00 0d 	mcall	800049bc <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000498c:	30 4b       	mov	r11,4
8000498e:	31 4c       	mov	r12,20
80004990:	f0 1f 00 0c 	mcall	800049c0 <xcmp_init+0x3c>
80004994:	48 c8       	lddpc	r8,800049c4 <xcmp_init+0x40>
80004996:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004998:	30 09       	mov	r9,0
8000499a:	1a d9       	st.w	--sp,r9
8000499c:	1a d9       	st.w	--sp,r9
8000499e:	1a d9       	st.w	--sp,r9
800049a0:	30 38       	mov	r8,3
800049a2:	e0 6a 04 00 	mov	r10,1024
800049a6:	48 9b       	lddpc	r11,800049c8 <xcmp_init+0x44>
800049a8:	48 9c       	lddpc	r12,800049cc <xcmp_init+0x48>
800049aa:	f0 1f 00 0a 	mcall	800049d0 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800049ae:	f0 1f 00 0a 	mcall	800049d4 <xcmp_init+0x50>
800049b2:	2f dd       	sub	sp,-12
	
}
800049b4:	d8 02       	popm	pc
800049b6:	00 00       	add	r0,r0
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	4a d4       	lddpc	r4,80004a6c <xcmp_rx_process+0x94>
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	4b 20       	lddpc	r0,80004a84 <xcmp_rx_process+0xac>
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	74 04       	ld.w	r4,r10[0x0]
800049c4:	00 00       	add	r0,r0
800049c6:	0b 28       	ld.uh	r8,r5++
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	e9 74 80 00 	stcond	r4[-32768],r4
800049ce:	49 d8       	lddpc	r8,80004a40 <xcmp_rx_process+0x68>
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	7b 38       	ld.w	r8,sp[0x4c]
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	4b 58       	lddpc	r8,80004aa8 <xcmp_rx_process+0xd0>

800049d8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800049d8:	d4 31       	pushm	r0-r7,lr
800049da:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800049dc:	4b 16       	lddpc	r6,80004aa0 <xcmp_rx_process+0xc8>
800049de:	30 05       	mov	r5,0
800049e0:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800049e2:	4b 13       	lddpc	r3,80004aa4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800049e4:	4b 12       	lddpc	r2,80004aa8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800049e6:	4b 21       	lddpc	r1,80004aac <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800049e8:	4b 20       	lddpc	r0,80004ab0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800049ea:	6c 0c       	ld.w	r12,r6[0x0]
800049ec:	0a 99       	mov	r9,r5
800049ee:	08 9a       	mov	r10,r4
800049f0:	1a 9b       	mov	r11,sp
800049f2:	f0 1f 00 31 	mcall	80004ab4 <xcmp_rx_process+0xdc>
800049f6:	58 1c       	cp.w	r12,1
800049f8:	cf 91       	brne	800049ea <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800049fa:	40 0b       	lddsp	r11,sp[0x0]
800049fc:	58 0b       	cp.w	r11,0
800049fe:	cf 60       	breq	800049ea <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004a00:	96 0a       	ld.sh	r10,r11[0x0]
80004a02:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a06:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004a0a:	59 c8       	cp.w	r8,28
80004a0c:	c1 e0       	breq	80004a48 <xcmp_rx_process+0x70>
80004a0e:	e0 89 00 07 	brgt	80004a1c <xcmp_rx_process+0x44>
80004a12:	58 e8       	cp.w	r8,14
80004a14:	c0 e0       	breq	80004a30 <xcmp_rx_process+0x58>
80004a16:	58 f8       	cp.w	r8,15
80004a18:	c2 41       	brne	80004a60 <xcmp_rx_process+0x88>
80004a1a:	c0 f8       	rjmp	80004a38 <xcmp_rx_process+0x60>
80004a1c:	e0 48 01 09 	cp.w	r8,265
80004a20:	c1 80       	breq	80004a50 <xcmp_rx_process+0x78>
80004a22:	e0 48 01 0a 	cp.w	r8,266
80004a26:	c1 90       	breq	80004a58 <xcmp_rx_process+0x80>
80004a28:	e0 48 00 2c 	cp.w	r8,44
80004a2c:	c1 a1       	brne	80004a60 <xcmp_rx_process+0x88>
80004a2e:	c0 98       	rjmp	80004a40 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004a30:	4a 2c       	lddpc	r12,80004ab8 <xcmp_rx_process+0xe0>
80004a32:	f0 1f 00 23 	mcall	80004abc <xcmp_rx_process+0xe4>
					break;
80004a36:	c2 f8       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004a38:	4a 2c       	lddpc	r12,80004ac0 <xcmp_rx_process+0xe8>
80004a3a:	f0 1f 00 21 	mcall	80004abc <xcmp_rx_process+0xe4>
					break;
80004a3e:	c2 b8       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004a40:	4a 1c       	lddpc	r12,80004ac4 <xcmp_rx_process+0xec>
80004a42:	f0 1f 00 1f 	mcall	80004abc <xcmp_rx_process+0xe4>
					break;
80004a46:	c2 78       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004a48:	04 9c       	mov	r12,r2
80004a4a:	f0 1f 00 1d 	mcall	80004abc <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004a4e:	c2 38       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004a50:	02 9c       	mov	r12,r1
80004a52:	f0 1f 00 1b 	mcall	80004abc <xcmp_rx_process+0xe4>
					break;
80004a56:	c1 f8       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004a58:	00 9c       	mov	r12,r0
80004a5a:	f0 1f 00 19 	mcall	80004abc <xcmp_rx_process+0xe4>
					break;
80004a5e:	c1 b8       	rjmp	80004a94 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004a60:	12 98       	mov	r8,r9
80004a62:	e2 18 04 00 	andl	r8,0x400,COH
80004a66:	c0 70       	breq	80004a74 <xcmp_rx_process+0x9c>
80004a68:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004a6c:	e0 48 00 68 	cp.w	r8,104
80004a70:	e0 8a 00 08 	brle	80004a80 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004a74:	e2 19 f0 00 	andl	r9,0xf000,COH
80004a78:	c0 e1       	brne	80004a94 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004a7a:	f0 1f 00 14 	mcall	80004ac8 <xcmp_rx_process+0xf0>
80004a7e:	c0 b8       	rjmp	80004a94 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004a80:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004a84:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004a88:	49 19       	lddpc	r9,80004acc <xcmp_rx_process+0xf4>
80004a8a:	72 08       	ld.w	r8,r9[0x0]
80004a8c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004a90:	f0 1f 00 0b 	mcall	80004abc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004a94:	66 0c       	ld.w	r12,r3[0x0]
80004a96:	40 0b       	lddsp	r11,sp[0x0]
80004a98:	f0 1f 00 0e 	mcall	80004ad0 <xcmp_rx_process+0xf8>
80004a9c:	ca 7b       	rjmp	800049ea <xcmp_rx_process+0x12>
80004a9e:	00 00       	add	r0,r0
80004aa0:	00 00       	add	r0,r0
80004aa2:	0b 28       	ld.uh	r8,r5++
80004aa4:	00 00       	add	r0,r0
80004aa6:	0a c0       	st.b	r5++,r0
80004aa8:	00 00       	add	r0,r0
80004aaa:	0b 38       	ld.ub	r8,r5++
80004aac:	00 00       	add	r0,r0
80004aae:	0b 2c       	ld.uh	r12,r5++
80004ab0:	00 00       	add	r0,r0
80004ab2:	0b 1c       	ld.sh	r12,r5++
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	70 a0       	ld.w	r0,r8[0x28]
80004ab8:	00 00       	add	r0,r0
80004aba:	0b 50       	ld.sh	r0,--r5
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	48 dc       	lddpc	r12,80004af0 <xcmp_rx+0x1c>
80004ac0:	00 00       	add	r0,r0
80004ac2:	0b 10       	ld.sh	r0,r5++
80004ac4:	00 00       	add	r0,r0
80004ac6:	0b 44       	ld.w	r4,--r5
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	48 b8       	lddpc	r8,80004af4 <xcmp_rx+0x20>
80004acc:	00 00       	add	r0,r0
80004ace:	97 9c       	st.w	r11[0x24],r12
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	34 bc       	mov	r12,75

80004ad4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004ad4:	eb cd 40 90 	pushm	r4,r7,lr
80004ad8:	20 1d       	sub	sp,4
80004ada:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004ade:	48 c8       	lddpc	r8,80004b0c <xcmp_rx+0x38>
80004ae0:	70 0c       	ld.w	r12,r8[0x0]
80004ae2:	f0 1f 00 0c 	mcall	80004b10 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004ae6:	c1 00       	breq	80004b06 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004ae8:	fa c7 ff fc 	sub	r7,sp,-4
80004aec:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004aee:	e0 6a 00 ca 	mov	r10,202
80004af2:	08 9b       	mov	r11,r4
80004af4:	f0 1f 00 08 	mcall	80004b14 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004af8:	48 88       	lddpc	r8,80004b18 <xcmp_rx+0x44>
80004afa:	70 0c       	ld.w	r12,r8[0x0]
80004afc:	30 09       	mov	r9,0
80004afe:	12 9a       	mov	r10,r9
80004b00:	1a 9b       	mov	r11,sp
80004b02:	f0 1f 00 07 	mcall	80004b1c <xcmp_rx+0x48>
	}	
}
80004b06:	2f fd       	sub	sp,-4
80004b08:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004b0c:	00 00       	add	r0,r0
80004b0e:	0a c0       	st.b	r5++,r0
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	36 68       	mov	r8,102
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	87 a6       	st.w	r3[0x28],r6
80004b18:	00 00       	add	r0,r0
80004b1a:	0b 28       	ld.uh	r8,r5++
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	72 ac       	ld.w	r12,r9[0x28]

80004b20 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004b20:	48 28       	lddpc	r8,80004b28 <xnl_register_xcmp_func+0x8>
80004b22:	91 0c       	st.w	r8[0x0],r12
}
80004b24:	5e fc       	retal	r12
80004b26:	00 00       	add	r0,r0
80004b28:	00 00       	add	r0,r0
80004b2a:	0b 7c       	ld.ub	r12,--r5

80004b2c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004b2c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004b2e:	48 88       	lddpc	r8,80004b4c <xnl_get_msg_ack_func+0x20>
80004b30:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004b32:	98 49       	ld.sh	r9,r12[0x8]
80004b34:	f0 09 19 00 	cp.h	r9,r8
80004b38:	c0 81       	brne	80004b48 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004b3a:	48 68       	lddpc	r8,80004b50 <xnl_get_msg_ack_func+0x24>
80004b3c:	70 0c       	ld.w	r12,r8[0x0]
80004b3e:	30 09       	mov	r9,0
80004b40:	12 9a       	mov	r10,r9
80004b42:	12 9b       	mov	r11,r9
80004b44:	f0 1f 00 04 	mcall	80004b54 <xnl_get_msg_ack_func+0x28>
80004b48:	d8 02       	popm	pc
80004b4a:	00 00       	add	r0,r0
80004b4c:	00 00       	add	r0,r0
80004b4e:	0b 62       	ld.uh	r2,--r5
80004b50:	00 00       	add	r0,r0
80004b52:	0b 5c       	ld.sh	r12,--r5
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	72 ac       	ld.w	r12,r9[0x28]

80004b58 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004b58:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004b5c:	30 09       	mov	r9,0
80004b5e:	4b 78       	lddpc	r8,80004c38 <xnl_init+0xe0>
80004b60:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004b62:	30 0b       	mov	r11,0
80004b64:	30 1c       	mov	r12,1
80004b66:	f0 1f 00 36 	mcall	80004c3c <xnl_init+0xe4>
80004b6a:	4b 68       	lddpc	r8,80004c40 <xnl_init+0xe8>
80004b6c:	91 0c       	st.w	r8[0x0],r12
80004b6e:	70 08       	ld.w	r8,r8[0x0]
80004b70:	58 08       	cp.w	r8,0
80004b72:	c0 80       	breq	80004b82 <xnl_init+0x2a>
80004b74:	4b 38       	lddpc	r8,80004c40 <xnl_init+0xe8>
80004b76:	70 0c       	ld.w	r12,r8[0x0]
80004b78:	30 09       	mov	r9,0
80004b7a:	12 9a       	mov	r10,r9
80004b7c:	12 9b       	mov	r11,r9
80004b7e:	f0 1f 00 32 	mcall	80004c44 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004b82:	30 4b       	mov	r11,4
80004b84:	33 cc       	mov	r12,60
80004b86:	f0 1f 00 2e 	mcall	80004c3c <xnl_init+0xe4>
80004b8a:	4b 08       	lddpc	r8,80004c48 <xnl_init+0xf0>
80004b8c:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004b8e:	30 4b       	mov	r11,4
80004b90:	36 4c       	mov	r12,100
80004b92:	f0 1f 00 2b 	mcall	80004c3c <xnl_init+0xe4>
80004b96:	4a e8       	lddpc	r8,80004c4c <xnl_init+0xf4>
80004b98:	91 0c       	st.w	r8[0x0],r12
80004b9a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004b9c:	10 96       	mov	r6,r8
80004b9e:	4a d5       	lddpc	r5,80004c50 <xnl_init+0xf8>
80004ba0:	6c 0c       	ld.w	r12,r6[0x0]
80004ba2:	ea 07 00 0b 	add	r11,r5,r7
80004ba6:	f0 1f 00 2c 	mcall	80004c54 <xnl_init+0xfc>
80004baa:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004bae:	e0 47 64 00 	cp.w	r7,25600
80004bb2:	cf 71       	brne	80004ba0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004bb4:	30 4b       	mov	r11,4
80004bb6:	33 2c       	mov	r12,50
80004bb8:	f0 1f 00 21 	mcall	80004c3c <xnl_init+0xe4>
80004bbc:	4a 78       	lddpc	r8,80004c58 <xnl_init+0x100>
80004bbe:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004bc0:	30 4b       	mov	r11,4
80004bc2:	32 8c       	mov	r12,40
80004bc4:	f0 1f 00 1e 	mcall	80004c3c <xnl_init+0xe4>
80004bc8:	4a 58       	lddpc	r8,80004c5c <xnl_init+0x104>
80004bca:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004bcc:	30 4b       	mov	r11,4
80004bce:	30 ac       	mov	r12,10
80004bd0:	f0 1f 00 1b 	mcall	80004c3c <xnl_init+0xe4>
80004bd4:	4a 38       	lddpc	r8,80004c60 <xnl_init+0x108>
80004bd6:	91 0c       	st.w	r8[0x0],r12
80004bd8:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004bda:	10 96       	mov	r6,r8
80004bdc:	4a 25       	lddpc	r5,80004c64 <xnl_init+0x10c>
80004bde:	6c 0c       	ld.w	r12,r6[0x0]
80004be0:	ea 07 00 0b 	add	r11,r5,r7
80004be4:	f0 1f 00 1c 	mcall	80004c54 <xnl_init+0xfc>
80004be8:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004bec:	e0 47 14 00 	cp.w	r7,5120
80004bf0:	cf 71       	brne	80004bde <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004bf2:	30 4b       	mov	r11,4
80004bf4:	30 5c       	mov	r12,5
80004bf6:	f0 1f 00 12 	mcall	80004c3c <xnl_init+0xe4>
80004bfa:	49 c8       	lddpc	r8,80004c68 <xnl_init+0x110>
80004bfc:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004bfe:	30 07       	mov	r7,0
80004c00:	1a d7       	st.w	--sp,r7
80004c02:	1a d7       	st.w	--sp,r7
80004c04:	1a d7       	st.w	--sp,r7
80004c06:	30 38       	mov	r8,3
80004c08:	0e 99       	mov	r9,r7
80004c0a:	e0 6a 00 dc 	mov	r10,220
80004c0e:	49 8b       	lddpc	r11,80004c6c <xnl_init+0x114>
80004c10:	49 8c       	lddpc	r12,80004c70 <xnl_init+0x118>
80004c12:	f0 1f 00 19 	mcall	80004c74 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004c16:	1a d7       	st.w	--sp,r7
80004c18:	1a d7       	st.w	--sp,r7
80004c1a:	1a d7       	st.w	--sp,r7
80004c1c:	30 38       	mov	r8,3
80004c1e:	0e 99       	mov	r9,r7
80004c20:	e0 6a 00 82 	mov	r10,130
80004c24:	49 5b       	lddpc	r11,80004c78 <xnl_init+0x120>
80004c26:	49 6c       	lddpc	r12,80004c7c <xnl_init+0x124>
80004c28:	f0 1f 00 13 	mcall	80004c74 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004c2c:	f0 1f 00 15 	mcall	80004c80 <xnl_init+0x128>
80004c30:	2f ad       	sub	sp,-24
}
80004c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c36:	00 00       	add	r0,r0
80004c38:	00 00       	add	r0,r0
80004c3a:	0b 62       	ld.uh	r2,--r5
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	74 04       	ld.w	r4,r10[0x0]
80004c40:	00 00       	add	r0,r0
80004c42:	0b 5c       	ld.sh	r12,--r5
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	72 ac       	ld.w	r12,r9[0x28]
80004c48:	00 00       	add	r0,r0
80004c4a:	0b 70       	ld.ub	r0,--r5
80004c4c:	00 00       	add	r0,r0
80004c4e:	0a c0       	st.b	r5++,r0
80004c50:	00 00       	add	r0,r0
80004c52:	33 4e       	mov	lr,52
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	34 bc       	mov	r12,75
80004c58:	00 00       	add	r0,r0
80004c5a:	0a f0       	st.b	--r5,r0
80004c5c:	00 00       	add	r0,r0
80004c5e:	0a d0       	st.w	--r5,r0
80004c60:	00 00       	add	r0,r0
80004c62:	0a c4       	st.b	r5++,r4
80004c64:	00 00       	add	r0,r0
80004c66:	1f 4e       	ld.w	lr,--pc
80004c68:	00 00       	add	r0,r0
80004c6a:	0a fc       	st.b	--r5,r12
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	e9 7c 80 00 	stcond	r4[-32768],r12
80004c72:	4c 84       	lddpc	r4,80004d90 <xnl_tx_process+0xac>
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	7b 38       	ld.w	r8,sp[0x4c]
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	e9 84       	*unknown*
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	4c e4       	lddpc	r4,80004db4 <xnl_tx+0x4>
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	36 90       	mov	r0,105

80004c84 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004c84:	eb cd 40 fe 	pushm	r1-r7,lr
80004c88:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004c8a:	49 26       	lddpc	r6,80004cd0 <xnl_rx_process+0x4c>
80004c8c:	30 05       	mov	r5,0
80004c8e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004c90:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004c92:	49 11       	lddpc	r1,80004cd4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004c94:	49 12       	lddpc	r2,80004cd8 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004c96:	6c 0c       	ld.w	r12,r6[0x0]
80004c98:	0a 99       	mov	r9,r5
80004c9a:	08 9a       	mov	r10,r4
80004c9c:	1a 9b       	mov	r11,sp
80004c9e:	f0 1f 00 10 	mcall	80004cdc <xnl_rx_process+0x58>
80004ca2:	58 1c       	cp.w	r12,1
80004ca4:	cf 91       	brne	80004c96 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004ca6:	40 0c       	lddsp	r12,sp[0x0]
80004ca8:	58 0c       	cp.w	r12,0
80004caa:	cf 60       	breq	80004c96 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004cac:	98 28       	ld.sh	r8,r12[0x4]
80004cae:	e6 08 19 00 	cp.h	r8,r3
80004cb2:	e0 8b 00 0a 	brhi	80004cc6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004cb6:	5c 78       	castu.h	r8
80004cb8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004cbc:	58 09       	cp.w	r9,0
80004cbe:	c0 40       	breq	80004cc6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004cc0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004cc4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004cc6:	62 0c       	ld.w	r12,r1[0x0]
80004cc8:	40 0b       	lddsp	r11,sp[0x0]
80004cca:	f0 1f 00 06 	mcall	80004ce0 <xnl_rx_process+0x5c>
80004cce:	ce 4b       	rjmp	80004c96 <xnl_rx_process+0x12>
80004cd0:	00 00       	add	r0,r0
80004cd2:	0a d0       	st.w	--r5,r0
80004cd4:	00 00       	add	r0,r0
80004cd6:	0a c0       	st.b	r5++,r0
80004cd8:	00 00       	add	r0,r0
80004cda:	05 00       	ld.w	r0,r2++
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	70 a0       	ld.w	r0,r8[0x28]
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	34 bc       	mov	r12,75

80004ce4 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004ce4:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004ce6:	4a a6       	lddpc	r6,80004d8c <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004ce8:	4a a2       	lddpc	r2,80004d90 <xnl_tx_process+0xac>
80004cea:	4a b4       	lddpc	r4,80004d94 <xnl_tx_process+0xb0>
80004cec:	30 07       	mov	r7,0
80004cee:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004cf0:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004cf2:	4a a5       	lddpc	r5,80004d98 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004cf4:	4a a3       	lddpc	r3,80004d9c <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004cf6:	6c 08       	ld.w	r8,r6[0x0]
80004cf8:	58 08       	cp.w	r8,0
80004cfa:	c0 40       	breq	80004d02 <xnl_tx_process+0x1e>
80004cfc:	58 18       	cp.w	r8,1
80004cfe:	cf d1       	brne	80004cf8 <xnl_tx_process+0x14>
80004d00:	c2 48       	rjmp	80004d48 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d02:	64 0c       	ld.w	r12,r2[0x0]
80004d04:	0e 99       	mov	r9,r7
80004d06:	02 9a       	mov	r10,r1
80004d08:	08 9b       	mov	r11,r4
80004d0a:	f0 1f 00 26 	mcall	80004da0 <xnl_tx_process+0xbc>
80004d0e:	58 1c       	cp.w	r12,1
80004d10:	cf 31       	brne	80004cf6 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004d12:	68 0b       	ld.w	r11,r4[0x0]
80004d14:	58 0b       	cp.w	r11,0
80004d16:	cf 00       	breq	80004cf6 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004d18:	96 28       	ld.sh	r8,r11[0x4]
80004d1a:	e0 08 19 00 	cp.h	r8,r0
80004d1e:	c0 71       	brne	80004d2c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004d20:	4a 18       	lddpc	r8,80004da4 <xnl_tx_process+0xc0>
80004d22:	70 08       	ld.w	r8,r8[0x0]
80004d24:	10 9c       	mov	r12,r8
80004d26:	f0 1f 00 21 	mcall	80004da8 <xnl_tx_process+0xc4>
						break;
80004d2a:	ce 6b       	rjmp	80004cf6 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004d2c:	16 9c       	mov	r12,r11
80004d2e:	f0 1f 00 20 	mcall	80004dac <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004d32:	30 18       	mov	r8,1
80004d34:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004d36:	66 0c       	ld.w	r12,r3[0x0]
80004d38:	0e 99       	mov	r9,r7
80004d3a:	0e 9a       	mov	r10,r7
80004d3c:	0e 9b       	mov	r11,r7
80004d3e:	f0 1f 00 19 	mcall	80004da0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004d42:	30 18       	mov	r8,1
80004d44:	8d 08       	st.w	r6[0x0],r8
80004d46:	cd 8b       	rjmp	80004cf6 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004d48:	66 0c       	ld.w	r12,r3[0x0]
80004d4a:	0e 99       	mov	r9,r7
80004d4c:	36 4a       	mov	r10,100
80004d4e:	0e 9b       	mov	r11,r7
80004d50:	f0 1f 00 14 	mcall	80004da0 <xnl_tx_process+0xbc>
80004d54:	58 1c       	cp.w	r12,1
80004d56:	c0 81       	brne	80004d66 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004d58:	49 38       	lddpc	r8,80004da4 <xnl_tx_process+0xc0>
80004d5a:	70 0c       	ld.w	r12,r8[0x0]
80004d5c:	68 0b       	ld.w	r11,r4[0x0]
80004d5e:	f0 1f 00 13 	mcall	80004da8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004d62:	8d 07       	st.w	r6[0x0],r7
80004d64:	cc 9b       	rjmp	80004cf6 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004d66:	6a 08       	ld.w	r8,r5[0x0]
80004d68:	58 38       	cp.w	r8,3
80004d6a:	e0 89 00 09 	brgt	80004d7c <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004d6e:	68 0c       	ld.w	r12,r4[0x0]
80004d70:	f0 1f 00 0f 	mcall	80004dac <xnl_tx_process+0xc8>
						xnl_send_times++;
80004d74:	6a 08       	ld.w	r8,r5[0x0]
80004d76:	2f f8       	sub	r8,-1
80004d78:	8b 08       	st.w	r5[0x0],r8
80004d7a:	cb eb       	rjmp	80004cf6 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004d7c:	48 a8       	lddpc	r8,80004da4 <xnl_tx_process+0xc0>
80004d7e:	70 0c       	ld.w	r12,r8[0x0]
80004d80:	68 0b       	ld.w	r11,r4[0x0]
80004d82:	f0 1f 00 0a 	mcall	80004da8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004d86:	8d 07       	st.w	r6[0x0],r7
80004d88:	cb 7b       	rjmp	80004cf6 <xnl_tx_process+0x12>
80004d8a:	00 00       	add	r0,r0
80004d8c:	00 00       	add	r0,r0
80004d8e:	0b 6c       	ld.uh	r12,--r5
80004d90:	00 00       	add	r0,r0
80004d92:	0b 70       	ld.ub	r0,--r5
80004d94:	00 00       	add	r0,r0
80004d96:	0b 78       	ld.ub	r8,--r5
80004d98:	00 00       	add	r0,r0
80004d9a:	0b 74       	ld.ub	r4,--r5
80004d9c:	00 00       	add	r0,r0
80004d9e:	0b 5c       	ld.sh	r12,--r5
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	70 a0       	ld.w	r0,r8[0x28]
80004da4:	00 00       	add	r0,r0
80004da6:	0a c0       	st.b	r5++,r0
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	34 bc       	mov	r12,75
80004dac:	80 00       	ld.sh	r0,r0[0x0]
80004dae:	34 dc       	mov	r12,77

80004db0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004db0:	eb cd 40 c0 	pushm	r6-r7,lr
80004db4:	20 1d       	sub	sp,4
80004db6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004db8:	98 39       	ld.sh	r9,r12[0x6]
80004dba:	3f f8       	mov	r8,-1
80004dbc:	f0 09 19 00 	cp.h	r9,r8
80004dc0:	c0 a1       	brne	80004dd4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004dc2:	4a e9       	lddpc	r9,80004e78 <xnl_tx+0xc8>
80004dc4:	13 88       	ld.ub	r8,r9[0x0]
80004dc6:	2f f8       	sub	r8,-1
80004dc8:	5c 58       	castu.b	r8
80004dca:	b2 88       	st.b	r9[0x0],r8
80004dcc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004dd0:	a9 a8       	sbr	r8,0x8
80004dd2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004dd4:	8c 49       	ld.sh	r9,r6[0x8]
80004dd6:	3f f8       	mov	r8,-1
80004dd8:	f0 09 19 00 	cp.h	r9,r8
80004ddc:	c0 41       	brne	80004de4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004dde:	4a 88       	lddpc	r8,80004e7c <xnl_tx+0xcc>
80004de0:	90 18       	ld.sh	r8,r8[0x2]
80004de2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004de4:	8c 59       	ld.sh	r9,r6[0xa]
80004de6:	3f f8       	mov	r8,-1
80004de8:	f0 09 19 00 	cp.h	r9,r8
80004dec:	c0 41       	brne	80004df4 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004dee:	4a 48       	lddpc	r8,80004e7c <xnl_tx+0xcc>
80004df0:	90 28       	ld.sh	r8,r8[0x4]
80004df2:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004df4:	8c 69       	ld.sh	r9,r6[0xc]
80004df6:	3f f8       	mov	r8,-1
80004df8:	f0 09 19 00 	cp.h	r9,r8
80004dfc:	c0 e1       	brne	80004e18 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004dfe:	4a 08       	lddpc	r8,80004e7c <xnl_tx+0xcc>
80004e00:	90 49       	ld.sh	r9,r8[0x8]
80004e02:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e04:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e06:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e08:	90 49       	ld.sh	r9,r8[0x8]
80004e0a:	e0 19 ff 00 	andl	r9,0xff00
80004e0e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004e12:	f3 e8 10 08 	or	r8,r9,r8
80004e16:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004e18:	0d 98       	ld.ub	r8,r6[0x1]
80004e1a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004e1c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004e20:	10 0c       	add	r12,r8
80004e22:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004e24:	58 0c       	cp.w	r12,0
80004e26:	e0 89 00 04 	brgt	80004e2e <xnl_tx+0x7e>
80004e2a:	30 09       	mov	r9,0
80004e2c:	c0 d8       	rjmp	80004e46 <xnl_tx+0x96>
80004e2e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004e32:	2f ec       	sub	r12,-2
80004e34:	30 09       	mov	r9,0
80004e36:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004e38:	15 1b       	ld.sh	r11,r10++
80004e3a:	f6 09 00 09 	add	r9,r11,r9
80004e3e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004e40:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004e42:	18 38       	cp.w	r8,r12
80004e44:	cf a1       	brne	80004e38 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004e46:	5c 39       	neg	r9
80004e48:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004e4a:	48 e8       	lddpc	r8,80004e80 <xnl_tx+0xd0>
80004e4c:	70 0c       	ld.w	r12,r8[0x0]
80004e4e:	f0 1f 00 0e 	mcall	80004e84 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004e52:	c1 00       	breq	80004e72 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004e54:	fa c7 ff fc 	sub	r7,sp,-4
80004e58:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004e5a:	e0 6a 01 00 	mov	r10,256
80004e5e:	0c 9b       	mov	r11,r6
80004e60:	f0 1f 00 0a 	mcall	80004e88 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004e64:	48 a8       	lddpc	r8,80004e8c <xnl_tx+0xdc>
80004e66:	70 0c       	ld.w	r12,r8[0x0]
80004e68:	30 09       	mov	r9,0
80004e6a:	12 9a       	mov	r10,r9
80004e6c:	1a 9b       	mov	r11,sp
80004e6e:	f0 1f 00 09 	mcall	80004e90 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004e72:	2f fd       	sub	sp,-4
80004e74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e78:	00 00       	add	r0,r0
80004e7a:	0b 60       	ld.uh	r0,--r5
80004e7c:	00 00       	add	r0,r0
80004e7e:	0b 62       	ld.uh	r2,--r5
80004e80:	00 00       	add	r0,r0
80004e82:	0a c0       	st.b	r5++,r0
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	36 68       	mov	r8,102
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	87 a6       	st.w	r3[0x28],r6
80004e8c:	00 00       	add	r0,r0
80004e8e:	0b 70       	ld.ub	r0,--r5
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	72 ac       	ld.w	r12,r9[0x28]

80004e94 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004e94:	eb cd 40 80 	pushm	r7,lr
80004e98:	fa cd 01 00 	sub	sp,sp,256
80004e9c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004e9e:	e0 68 40 0e 	mov	r8,16398
80004ea2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004ea4:	3f f8       	mov	r8,-1
80004ea6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004ea8:	30 c8       	mov	r8,12
80004eaa:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004eac:	98 38       	ld.sh	r8,r12[0x6]
80004eae:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004eb0:	98 58       	ld.sh	r8,r12[0xa]
80004eb2:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004eb4:	98 48       	ld.sh	r8,r12[0x8]
80004eb6:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004eb8:	98 68       	ld.sh	r8,r12[0xc]
80004eba:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004ebc:	30 08       	mov	r8,0
80004ebe:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ec0:	1a 9c       	mov	r12,sp
80004ec2:	f0 1f 00 0a 	mcall	80004ee8 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004ec6:	fa cd 00 cc 	sub	sp,sp,204
80004eca:	e0 6a 00 ca 	mov	r10,202
80004ece:	ee cb ff f0 	sub	r11,r7,-16
80004ed2:	1a 9c       	mov	r12,sp
80004ed4:	f0 1f 00 06 	mcall	80004eec <xnl_data_msg_func+0x58>
80004ed8:	48 68       	lddpc	r8,80004ef0 <xnl_data_msg_func+0x5c>
80004eda:	70 08       	ld.w	r8,r8[0x0]
80004edc:	5d 18       	icall	r8
80004ede:	fa cd ff 34 	sub	sp,sp,-204
}
80004ee2:	2c 0d       	sub	sp,-256
80004ee4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	4d b0       	lddpc	r0,80005054 <xnl_master_status_brdcst_func+0x40>
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	87 a6       	st.w	r3[0x28],r6
80004ef0:	00 00       	add	r0,r0
80004ef2:	0b 7c       	ld.ub	r12,--r5

80004ef4 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004ef4:	d4 21       	pushm	r4-r7,lr
80004ef6:	fa cd 01 00 	sub	sp,sp,256
80004efa:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004efc:	4c 28       	lddpc	r8,80005004 <xnl_device_auth_reply_func+0x110>
80004efe:	11 88       	ld.ub	r8,r8[0x0]
80004f00:	58 08       	cp.w	r8,0
80004f02:	e0 81 00 7f 	brne	80005000 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004f06:	4c 18       	lddpc	r8,80005008 <xnl_device_auth_reply_func+0x114>
80004f08:	70 0c       	ld.w	r12,r8[0x0]
80004f0a:	30 09       	mov	r9,0
80004f0c:	12 9a       	mov	r10,r9
80004f0e:	12 9b       	mov	r11,r9
80004f10:	f0 1f 00 3f 	mcall	8000500c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004f14:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004f18:	4b b8       	lddpc	r8,80005004 <xnl_device_auth_reply_func+0x110>
80004f1a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004f1c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004f20:	ef 38 00 13 	ld.ub	r8,r7[19]
80004f24:	b1 68       	lsl	r8,0x10
80004f26:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004f2a:	ef 38 00 15 	ld.ub	r8,r7[21]
80004f2e:	f3 e8 10 08 	or	r8,r9,r8
80004f32:	ef 39 00 14 	ld.ub	r9,r7[20]
80004f36:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004f3a:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004f3e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004f42:	b1 68       	lsl	r8,0x10
80004f44:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004f48:	ef 38 00 19 	ld.ub	r8,r7[25]
80004f4c:	f5 e8 10 08 	or	r8,r10,r8
80004f50:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004f54:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004f58:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004f5a:	e0 64 79 b9 	mov	r4,31161
80004f5e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004f62:	e0 65 45 07 	mov	r5,17671
80004f66:	ea 15 8a bd 	orh	r5,0x8abd
80004f6a:	e0 66 f9 3d 	mov	r6,63805
80004f6e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004f72:	e0 6e b8 cf 	mov	lr,47311
80004f76:	ea 1e 36 83 	orh	lr,0x3683
80004f7a:	e0 67 aa 1c 	mov	r7,43548
80004f7e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004f82:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004f84:	f4 08 00 0c 	add	r12,r10,r8
80004f88:	f0 0b 15 04 	lsl	r11,r8,0x4
80004f8c:	0a 0b       	add	r11,r5
80004f8e:	f9 eb 20 0b 	eor	r11,r12,r11
80004f92:	f0 0c 16 05 	lsr	r12,r8,0x5
80004f96:	0c 0c       	add	r12,r6
80004f98:	18 5b       	eor	r11,r12
80004f9a:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004f9c:	f2 0c 15 04 	lsl	r12,r9,0x4
80004fa0:	1c 0c       	add	r12,lr
80004fa2:	f2 0b 16 05 	lsr	r11,r9,0x5
80004fa6:	0e 0b       	add	r11,r7
80004fa8:	f9 eb 20 0b 	eor	r11,r12,r11
80004fac:	f2 0a 00 0c 	add	r12,r9,r10
80004fb0:	18 5b       	eor	r11,r12
80004fb2:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004fb4:	e0 6b 37 20 	mov	r11,14112
80004fb8:	ea 1b c6 ef 	orh	r11,0xc6ef
80004fbc:	16 3a       	cp.w	r10,r11
80004fbe:	ce 21       	brne	80004f82 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004fc0:	e0 6a 40 1a 	mov	r10,16410
80004fc4:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004fc6:	3f fa       	mov	r10,-1
80004fc8:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004fca:	30 6b       	mov	r11,6
80004fcc:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004fce:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004fd0:	48 db       	lddpc	r11,80005004 <xnl_device_auth_reply_func+0x110>
80004fd2:	96 1c       	ld.sh	r12,r11[0x2]
80004fd4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004fd6:	96 2b       	ld.sh	r11,r11[0x4]
80004fd8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004fda:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004fdc:	30 ca       	mov	r10,12
80004fde:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004fe0:	30 0a       	mov	r10,0
80004fe2:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004fe6:	30 7a       	mov	r10,7
80004fe8:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004fec:	30 2a       	mov	r10,2
80004fee:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ff2:	fa ca ff ec 	sub	r10,sp,-20
80004ff6:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ff8:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ffa:	1a 9c       	mov	r12,sp
80004ffc:	f0 1f 00 05 	mcall	80005010 <xnl_device_auth_reply_func+0x11c>
}
80005000:	2c 0d       	sub	sp,-256
80005002:	d8 22       	popm	r4-r7,pc
80005004:	00 00       	add	r0,r0
80005006:	0b 62       	ld.uh	r2,--r5
80005008:	00 00       	add	r0,r0
8000500a:	0b 5c       	ld.sh	r12,--r5
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	72 ac       	ld.w	r12,r9[0x28]
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	4d b0       	lddpc	r0,8000517c <RC522_WriteByte+0x1c>

80005014 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005014:	eb cd 40 80 	pushm	r7,lr
80005018:	fa cd 01 00 	sub	sp,sp,256
8000501c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000501e:	49 28       	lddpc	r8,80005064 <xnl_master_status_brdcst_func+0x50>
80005020:	11 88       	ld.ub	r8,r8[0x0]
80005022:	58 08       	cp.w	r8,0
80005024:	c1 c1       	brne	8000505c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80005026:	49 18       	lddpc	r8,80005068 <xnl_master_status_brdcst_func+0x54>
80005028:	70 0c       	ld.w	r12,r8[0x0]
8000502a:	30 09       	mov	r9,0
8000502c:	12 9a       	mov	r10,r9
8000502e:	12 9b       	mov	r11,r9
80005030:	f0 1f 00 0f 	mcall	8000506c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005034:	8e 58       	ld.sh	r8,r7[0xa]
80005036:	48 c9       	lddpc	r9,80005064 <xnl_master_status_brdcst_func+0x50>
80005038:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000503a:	e0 68 40 0e 	mov	r8,16398
8000503e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005040:	3f f8       	mov	r8,-1
80005042:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005044:	30 4a       	mov	r10,4
80005046:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005048:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000504a:	92 19       	ld.sh	r9,r9[0x2]
8000504c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000504e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005050:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80005052:	30 08       	mov	r8,0
80005054:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005056:	1a 9c       	mov	r12,sp
80005058:	f0 1f 00 06 	mcall	80005070 <xnl_master_status_brdcst_func+0x5c>
}
8000505c:	2c 0d       	sub	sp,-256
8000505e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005062:	00 00       	add	r0,r0
80005064:	00 00       	add	r0,r0
80005066:	0b 62       	ld.uh	r2,--r5
80005068:	00 00       	add	r0,r0
8000506a:	0b 5c       	ld.sh	r12,--r5
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	72 ac       	ld.w	r12,r9[0x28]
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	4d b0       	lddpc	r0,800051dc <PcdReset+0xc>

80005074 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005074:	eb cd 40 80 	pushm	r7,lr
80005078:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000507a:	49 28       	lddpc	r8,800050c0 <xnl_device_conn_reply_func+0x4c>
8000507c:	70 0c       	ld.w	r12,r8[0x0]
8000507e:	30 09       	mov	r9,0
80005080:	12 9a       	mov	r10,r9
80005082:	12 9b       	mov	r11,r9
80005084:	f0 1f 00 10 	mcall	800050c4 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005088:	ef 18 00 10 	ld.uh	r8,r7[16]
8000508c:	10 99       	mov	r9,r8
8000508e:	e2 19 ff 00 	andl	r9,0xff00,COH
80005092:	e0 49 01 00 	cp.w	r9,256
80005096:	c0 60       	breq	800050a2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005098:	0e 9c       	mov	r12,r7
8000509a:	f0 1f 00 0c 	mcall	800050c8 <xnl_device_conn_reply_func+0x54>
8000509e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800050a2:	a9 68       	lsl	r8,0x8
800050a4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800050a8:	48 98       	lddpc	r8,800050cc <xnl_device_conn_reply_func+0x58>
800050aa:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800050ac:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800050b0:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800050b2:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800050b6:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800050b8:	30 19       	mov	r9,1
800050ba:	b0 89       	st.b	r8[0x0],r9
800050bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800050c0:	00 00       	add	r0,r0
800050c2:	0b 5c       	ld.sh	r12,--r5
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	72 ac       	ld.w	r12,r9[0x28]
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	50 14       	stdsp	sp[0x4],r4
800050cc:	00 00       	add	r0,r0
800050ce:	0b 62       	ld.uh	r2,--r5

800050d0 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800050d0:	d4 01       	pushm	lr
800050d2:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800050d6:	e0 68 40 0e 	mov	r8,16398
800050da:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050dc:	3f f8       	mov	r8,-1
800050de:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800050e0:	30 38       	mov	r8,3
800050e2:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800050e4:	30 08       	mov	r8,0
800050e6:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800050e8:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800050ea:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800050ec:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800050ee:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800050f0:	1a 9c       	mov	r12,sp
800050f2:	f0 1f 00 03 	mcall	800050fc <xnl_send_device_master_query+0x2c>
}
800050f6:	2c 0d       	sub	sp,-256
800050f8:	d8 02       	popm	pc
800050fa:	00 00       	add	r0,r0
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	4d b0       	lddpc	r0,80005268 <ReadRawRC+0x18>

80005100 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80005100:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80005102:	48 78       	lddpc	r8,8000511c <RC522_SPI_SetSpeed+0x1c>
80005104:	70 09       	ld.w	r9,r8[0x0]
80005106:	72 ca       	ld.w	r10,r9[0x30]
80005108:	5c 7c       	castu.h	r12
8000510a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000510e:	f9 ea 10 0a 	or	r10,r12,r10
80005112:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80005114:	70 0c       	ld.w	r12,r8[0x0]
80005116:	f0 1f 00 03 	mcall	80005120 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000511a:	d8 02       	popm	pc
8000511c:	00 00       	add	r0,r0
8000511e:	1e 28       	rsub	r8,pc
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	67 9c       	ld.w	r12,r3[0x64]

80005124 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80005124:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80005126:	e0 6c 0a 00 	mov	r12,2560
8000512a:	f0 1f 00 02 	mcall	80005130 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000512e:	d8 02       	popm	pc
80005130:	80 00       	ld.sh	r0,r0[0x0]
80005132:	51 00       	stdsp	sp[0x40],r0

80005134 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80005134:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80005138:	48 76       	lddpc	r6,80005154 <RC522_ReadByte+0x20>
8000513a:	e0 6b 00 ff 	mov	r11,255
8000513e:	6c 0c       	ld.w	r12,r6[0x0]
80005140:	f0 1f 00 06 	mcall	80005158 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80005144:	30 07       	mov	r7,0
80005146:	0e 9b       	mov	r11,r7
80005148:	6c 0c       	ld.w	r12,r6[0x0]
8000514a:	f0 1f 00 05 	mcall	8000515c <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000514e:	0f 9c       	ld.ub	r12,r7[0x1]
80005150:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005154:	00 00       	add	r0,r0
80005156:	1e 28       	rsub	r8,pc
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	67 a2       	ld.w	r2,r3[0x68]
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	67 be       	ld.w	lr,r3[0x6c]

80005160 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80005160:	eb cd 40 80 	pushm	r7,lr
80005164:	20 1d       	sub	sp,4
80005166:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80005168:	48 77       	lddpc	r7,80005184 <RC522_WriteByte+0x24>
8000516a:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000516e:	6e 0c       	ld.w	r12,r7[0x0]
80005170:	f0 1f 00 06 	mcall	80005188 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80005174:	1a 9b       	mov	r11,sp
80005176:	6e 0c       	ld.w	r12,r7[0x0]
80005178:	f0 1f 00 05 	mcall	8000518c <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
8000517c:	5c 5c       	castu.b	r12
8000517e:	2f fd       	sub	sp,-4
80005180:	e3 cd 80 80 	ldm	sp++,r7,pc
80005184:	00 00       	add	r0,r0
80005186:	1e 28       	rsub	r8,pc
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	67 a2       	ld.w	r2,r3[0x68]
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	67 be       	ld.w	lr,r3[0x6c]

80005190 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005190:	eb cd 40 e0 	pushm	r5-r7,lr
80005194:	18 96       	mov	r6,r12
80005196:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005198:	48 a7       	lddpc	r7,800051c0 <WriteRawRC+0x30>
8000519a:	30 0b       	mov	r11,0
8000519c:	6e 0c       	ld.w	r12,r7[0x0]
8000519e:	f0 1f 00 0a 	mcall	800051c4 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800051a2:	ec 0c 15 01 	lsl	r12,r6,0x1
800051a6:	e2 1c 00 7e 	andl	r12,0x7e,COH
800051aa:	f0 1f 00 08 	mcall	800051c8 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800051ae:	0a 9c       	mov	r12,r5
800051b0:	f0 1f 00 06 	mcall	800051c8 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800051b4:	30 0b       	mov	r11,0
800051b6:	6e 0c       	ld.w	r12,r7[0x0]
800051b8:	f0 1f 00 05 	mcall	800051cc <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800051bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051c0:	00 00       	add	r0,r0
800051c2:	1e 28       	rsub	r8,pc
800051c4:	80 00       	ld.sh	r0,r0[0x0]
800051c6:	69 08       	ld.w	r8,r4[0x40]
800051c8:	80 00       	ld.sh	r0,r0[0x0]
800051ca:	51 60       	stdsp	sp[0x58],r0
800051cc:	80 00       	ld.sh	r0,r0[0x0]
800051ce:	68 c8       	ld.w	r8,r4[0x30]

800051d0 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800051d0:	d4 01       	pushm	lr

	SET_RC522RST;
800051d2:	31 9c       	mov	r12,25
800051d4:	f0 1f 00 1b 	mcall	80005240 <PcdReset+0x70>
	delay_ns(10);
800051d8:	30 ac       	mov	r12,10
800051da:	f0 1f 00 1b 	mcall	80005244 <PcdReset+0x74>

	CLR_RC522RST;
800051de:	31 9c       	mov	r12,25
800051e0:	f0 1f 00 1a 	mcall	80005248 <PcdReset+0x78>
	delay_ns(10);
800051e4:	30 ac       	mov	r12,10
800051e6:	f0 1f 00 18 	mcall	80005244 <PcdReset+0x74>

	SET_RC522RST;
800051ea:	31 9c       	mov	r12,25
800051ec:	f0 1f 00 15 	mcall	80005240 <PcdReset+0x70>
	delay_ns(10);
800051f0:	30 ac       	mov	r12,10
800051f2:	f0 1f 00 15 	mcall	80005244 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800051f6:	30 fb       	mov	r11,15
800051f8:	30 1c       	mov	r12,1
800051fa:	f0 1f 00 15 	mcall	8000524c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800051fe:	30 fb       	mov	r11,15
80005200:	30 1c       	mov	r12,1
80005202:	f0 1f 00 13 	mcall	8000524c <PcdReset+0x7c>
	delay_ns(10);
80005206:	30 ac       	mov	r12,10
80005208:	f0 1f 00 0f 	mcall	80005244 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
8000520c:	33 db       	mov	r11,61
8000520e:	31 1c       	mov	r12,17
80005210:	f0 1f 00 0f 	mcall	8000524c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80005214:	31 eb       	mov	r11,30
80005216:	32 dc       	mov	r12,45
80005218:	f0 1f 00 0d 	mcall	8000524c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
8000521c:	30 0b       	mov	r11,0
8000521e:	32 cc       	mov	r12,44
80005220:	f0 1f 00 0b 	mcall	8000524c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80005224:	e0 6b 00 8d 	mov	r11,141
80005228:	32 ac       	mov	r12,42
8000522a:	f0 1f 00 09 	mcall	8000524c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000522e:	33 eb       	mov	r11,62
80005230:	32 bc       	mov	r12,43
80005232:	f0 1f 00 07 	mcall	8000524c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80005236:	34 0b       	mov	r11,64
80005238:	31 5c       	mov	r12,21
8000523a:	f0 1f 00 05 	mcall	8000524c <PcdReset+0x7c>
	
	return MI_OK;
}
8000523e:	d8 0a       	popm	pc,r12=0
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	63 10       	ld.w	r0,r1[0x44]
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	5b 38       	cp.w	r8,-13
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	63 2c       	ld.w	r12,r1[0x48]
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	51 90       	stdsp	sp[0x64],r0

80005250 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80005250:	eb cd 40 c0 	pushm	r6-r7,lr
80005254:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005256:	48 c7       	lddpc	r7,80005284 <ReadRawRC+0x34>
80005258:	30 0b       	mov	r11,0
8000525a:	6e 0c       	ld.w	r12,r7[0x0]
8000525c:	f0 1f 00 0b 	mcall	80005288 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80005260:	a1 76       	lsl	r6,0x1
80005262:	0c 9c       	mov	r12,r6
80005264:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005268:	a7 bc       	sbr	r12,0x7
8000526a:	f0 1f 00 09 	mcall	8000528c <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000526e:	f0 1f 00 09 	mcall	80005290 <ReadRawRC+0x40>
80005272:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80005274:	30 0b       	mov	r11,0
80005276:	6e 0c       	ld.w	r12,r7[0x0]
80005278:	f0 1f 00 07 	mcall	80005294 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
8000527c:	0c 9c       	mov	r12,r6
8000527e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005282:	00 00       	add	r0,r0
80005284:	00 00       	add	r0,r0
80005286:	1e 28       	rsub	r8,pc
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	69 08       	ld.w	r8,r4[0x40]
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	51 60       	stdsp	sp[0x58],r0
80005290:	80 00       	ld.sh	r0,r0[0x0]
80005292:	51 34       	stdsp	sp[0x4c],r4
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	68 c8       	ld.w	r8,r4[0x30]

80005298 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005298:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
8000529a:	30 1c       	mov	r12,1
8000529c:	f0 1f 00 02 	mcall	800052a4 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800052a0:	d8 02       	popm	pc
800052a2:	00 00       	add	r0,r0
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	52 50       	stdsp	sp[0x94],r0

800052a8 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800052a8:	eb cd 40 80 	pushm	r7,lr
800052ac:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800052ae:	30 1c       	mov	r12,1
800052b0:	f0 1f 00 0d 	mcall	800052e4 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800052b4:	30 18       	mov	r8,1
800052b6:	f0 07 18 00 	cp.b	r7,r8
800052ba:	c0 91       	brne	800052cc <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800052bc:	18 9b       	mov	r11,r12
800052be:	a5 ab       	sbr	r11,0x4
800052c0:	5c 5b       	castu.b	r11
800052c2:	30 1c       	mov	r12,1
800052c4:	f0 1f 00 09 	mcall	800052e8 <Powerdown_RC522+0x40>
800052c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800052cc:	18 9b       	mov	r11,r12
800052ce:	30 1c       	mov	r12,1
800052d0:	f0 1f 00 06 	mcall	800052e8 <Powerdown_RC522+0x40>
		delay_ns(2);
800052d4:	30 2c       	mov	r12,2
800052d6:	f0 1f 00 06 	mcall	800052ec <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800052da:	f0 1f 00 06 	mcall	800052f0 <Powerdown_RC522+0x48>
800052de:	e3 cd 80 80 	ldm	sp++,r7,pc
800052e2:	00 00       	add	r0,r0
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	52 50       	stdsp	sp[0x94],r0
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	51 90       	stdsp	sp[0x64],r0
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	5b 38       	cp.w	r8,-13
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	52 98       	stdsp	sp[0xa4],r8

800052f4 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800052f4:	eb cd 40 c0 	pushm	r6-r7,lr
800052f8:	18 97       	mov	r7,r12
800052fa:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800052fc:	f0 1f 00 05 	mcall	80005310 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005300:	f9 e6 10 0b 	or	r11,r12,r6
80005304:	5c 5b       	castu.b	r11
80005306:	0e 9c       	mov	r12,r7
80005308:	f0 1f 00 03 	mcall	80005314 <SetBitMask+0x20>
}
8000530c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	52 50       	stdsp	sp[0x94],r0
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	51 90       	stdsp	sp[0x64],r0

80005318 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80005318:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000531a:	31 4c       	mov	r12,20
8000531c:	f0 1f 00 05 	mcall	80005330 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005320:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80005324:	c0 51       	brne	8000532e <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80005326:	30 3b       	mov	r11,3
80005328:	31 4c       	mov	r12,20
8000532a:	f0 1f 00 03 	mcall	80005334 <PcdAntennaOn+0x1c>
8000532e:	d8 02       	popm	pc
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	52 50       	stdsp	sp[0x94],r0
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	52 f4       	stdsp	sp[0xbc],r4

80005338 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80005338:	eb cd 40 c0 	pushm	r6-r7,lr
8000533c:	18 97       	mov	r7,r12
8000533e:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80005340:	f0 1f 00 06 	mcall	80005358 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80005344:	5c d6       	com	r6
80005346:	f9 e6 00 06 	and	r6,r12,r6
8000534a:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000534e:	0e 9c       	mov	r12,r7
80005350:	f0 1f 00 03 	mcall	8000535c <ClearBitMask+0x24>
	
}
80005354:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	52 50       	stdsp	sp[0x94],r0
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	51 90       	stdsp	sp[0x64],r0

80005360 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80005360:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80005362:	30 3b       	mov	r11,3
80005364:	31 4c       	mov	r12,20
80005366:	f0 1f 00 02 	mcall	8000536c <PcdAntennaOff+0xc>
}
8000536a:	d8 02       	popm	pc
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	53 38       	stdsp	sp[0xcc],r8

80005370 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80005370:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80005372:	34 18       	mov	r8,65
80005374:	f0 0c 18 00 	cp.b	r12,r8
80005378:	c0 20       	breq	8000537c <M500PcdConfigISOType+0xc>
8000537a:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
8000537c:	30 8b       	mov	r11,8
8000537e:	16 9c       	mov	r12,r11
80005380:	f0 1f 00 14 	mcall	800053d0 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80005384:	33 db       	mov	r11,61
80005386:	31 1c       	mov	r12,17
80005388:	f0 1f 00 13 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
8000538c:	e0 6b 00 86 	mov	r11,134
80005390:	31 7c       	mov	r12,23
80005392:	f0 1f 00 11 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80005396:	37 fb       	mov	r11,127
80005398:	32 6c       	mov	r12,38
8000539a:	f0 1f 00 0f 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000539e:	31 eb       	mov	r11,30
800053a0:	32 dc       	mov	r12,45
800053a2:	f0 1f 00 0d 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800053a6:	30 0b       	mov	r11,0
800053a8:	32 cc       	mov	r12,44
800053aa:	f0 1f 00 0b 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800053ae:	e0 6b 00 8d 	mov	r11,141
800053b2:	32 ac       	mov	r12,42
800053b4:	f0 1f 00 08 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800053b8:	33 eb       	mov	r11,62
800053ba:	32 bc       	mov	r12,43
800053bc:	f0 1f 00 06 	mcall	800053d4 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800053c0:	e0 6c 03 e8 	mov	r12,1000
800053c4:	f0 1f 00 05 	mcall	800053d8 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800053c8:	f0 1f 00 05 	mcall	800053dc <M500PcdConfigISOType+0x6c>
800053cc:	d8 0a       	popm	pc,r12=0
800053ce:	00 00       	add	r0,r0
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	53 38       	stdsp	sp[0xcc],r8
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	51 90       	stdsp	sp[0x64],r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	5b 38       	cp.w	r8,-13
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	53 18       	stdsp	sp[0xc4],r8

800053e0 <rc522_init>:


//mfrc522 init

void rc522_init()
{
800053e0:	eb cd 40 80 	pushm	r7,lr
800053e4:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800053e6:	49 d8       	lddpc	r8,80005458 <rc522_init+0x78>
800053e8:	1a 97       	mov	r7,sp
800053ea:	f0 ea 00 00 	ld.d	r10,r8[0]
800053ee:	fa eb 00 00 	st.d	sp[0],r10
800053f2:	f0 e8 00 08 	ld.d	r8,r8[8]
800053f6:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
800053fa:	30 1b       	mov	r11,1
800053fc:	49 8c       	lddpc	r12,8000545c <rc522_init+0x7c>
800053fe:	f0 1f 00 19 	mcall	80005460 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80005402:	31 9c       	mov	r12,25
80005404:	f0 1f 00 18 	mcall	80005464 <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80005408:	31 9c       	mov	r12,25
8000540a:	f0 1f 00 18 	mcall	80005468 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000540e:	fe 7c 24 00 	mov	r12,-56320
80005412:	49 78       	lddpc	r8,8000546c <rc522_init+0x8c>
80005414:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80005416:	e0 6a 36 00 	mov	r10,13824
8000541a:	ea 1a 01 6e 	orh	r10,0x16e
8000541e:	1a 9b       	mov	r11,sp
80005420:	f0 1f 00 14 	mcall	80005470 <rc522_init+0x90>
80005424:	c0 50       	breq	8000542e <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80005426:	30 29       	mov	r9,2
80005428:	49 38       	lddpc	r8,80005474 <rc522_init+0x94>
8000542a:	b0 89       	st.b	r8[0x0],r9
8000542c:	c0 38       	rjmp	80005432 <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
8000542e:	f0 1f 00 13 	mcall	80005478 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80005432:	f0 1f 00 13 	mcall	8000547c <rc522_init+0x9c>
	
	PcdAntennaOff();
80005436:	f0 1f 00 13 	mcall	80005480 <rc522_init+0xa0>
	
	delay_ms(2); 
8000543a:	30 2c       	mov	r12,2
8000543c:	f0 1f 00 12 	mcall	80005484 <rc522_init+0xa4>
	
	PcdAntennaOn();
80005440:	f0 1f 00 12 	mcall	80005488 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
80005444:	34 1c       	mov	r12,65
80005446:	f0 1f 00 12 	mcall	8000548c <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
8000544a:	30 1c       	mov	r12,1
8000544c:	f0 1f 00 11 	mcall	80005490 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80005450:	2f cd       	sub	sp,-16
80005452:	e3 cd 80 80 	ldm	sp++,r7,pc
80005456:	00 00       	add	r0,r0
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	e9 94       	*unknown*
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	e9 a4 80 00 	ldc.w	cp4,cr0,r4[0x0]
80005462:	62 c8       	ld.w	r8,r1[0x30]
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	62 f8       	ld.w	r8,r1[0x3c]
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	63 10       	ld.w	r0,r1[0x44]
8000546c:	00 00       	add	r0,r0
8000546e:	1e 28       	rsub	r8,pc
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	67 e0       	ld.w	r0,r3[0x78]
80005474:	00 00       	add	r0,r0
80005476:	0b 80       	ld.ub	r0,r5[0x0]
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	51 24       	stdsp	sp[0x48],r4
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	51 d0       	stdsp	sp[0x74],r0
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	53 60       	stdsp	sp[0xd8],r0
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	5b 78       	cp.w	r8,-9
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	53 18       	stdsp	sp[0xc4],r8
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	53 70       	stdsp	sp[0xdc],r0
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	52 a8       	stdsp	sp[0xa8],r8

80005494 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80005494:	d4 31       	pushm	r0-r7,lr
80005496:	20 1d       	sub	sp,4
80005498:	18 92       	mov	r2,r12
8000549a:	16 95       	mov	r5,r11
8000549c:	14 96       	mov	r6,r10
8000549e:	50 09       	stdsp	sp[0x0],r9
800054a0:	10 90       	mov	r0,r8
800054a2:	f8 c8 00 0c 	sub	r8,r12,12
800054a6:	5c 58       	castu.b	r8
800054a8:	30 29       	mov	r9,2
800054aa:	f2 08 18 00 	cp.b	r8,r9
800054ae:	e0 88 00 05 	brls	800054b8 <PcdComMF522+0x24>
800054b2:	30 03       	mov	r3,0
800054b4:	06 91       	mov	r1,r3
800054b6:	c0 78       	rjmp	800054c4 <PcdComMF522+0x30>
800054b8:	4c f9       	lddpc	r9,800055f4 <PcdComMF522+0x160>
800054ba:	f2 08 07 01 	ld.ub	r1,r9[r8]
800054be:	4c f9       	lddpc	r9,800055f8 <PcdComMF522+0x164>
800054c0:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
800054c4:	02 9b       	mov	r11,r1
800054c6:	a7 bb       	sbr	r11,0x7
800054c8:	30 2c       	mov	r12,2
800054ca:	f0 1f 00 4d 	mcall	800055fc <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
800054ce:	e0 6b 00 80 	mov	r11,128
800054d2:	30 4c       	mov	r12,4
800054d4:	f0 1f 00 4b 	mcall	80005600 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
800054d8:	30 0b       	mov	r11,0
800054da:	30 1c       	mov	r12,1
800054dc:	f0 1f 00 48 	mcall	800055fc <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
800054e0:	e0 6b 00 80 	mov	r11,128
800054e4:	30 ac       	mov	r12,10
800054e6:	f0 1f 00 48 	mcall	80005604 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
800054ea:	58 06       	cp.w	r6,0
800054ec:	c0 c0       	breq	80005504 <PcdComMF522+0x70>
800054ee:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
800054f0:	30 94       	mov	r4,9
800054f2:	0f 3b       	ld.ub	r11,r7++
800054f4:	08 9c       	mov	r12,r4
800054f6:	f0 1f 00 42 	mcall	800055fc <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
800054fa:	0e 98       	mov	r8,r7
800054fc:	0a 18       	sub	r8,r5
800054fe:	ec 08 19 00 	cp.h	r8,r6
80005502:	cf 83       	brcs	800054f2 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80005504:	04 9b       	mov	r11,r2
80005506:	30 1c       	mov	r12,1
80005508:	f0 1f 00 3d 	mcall	800055fc <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
8000550c:	30 c8       	mov	r8,12
8000550e:	f0 02 18 00 	cp.b	r2,r8
80005512:	c0 61       	brne	8000551e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80005514:	e0 6b 00 80 	mov	r11,128
80005518:	30 dc       	mov	r12,13
8000551a:	f0 1f 00 3b 	mcall	80005604 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
8000551e:	30 4c       	mov	r12,4
80005520:	f0 1f 00 3a 	mcall	80005608 <PcdComMF522+0x174>
80005524:	18 97       	mov	r7,r12
80005526:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
8000552a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
8000552c:	30 44       	mov	r4,4
8000552e:	c0 88       	rjmp	8000553e <PcdComMF522+0xaa>
80005530:	08 9c       	mov	r12,r4
80005532:	f0 1f 00 36 	mcall	80005608 <PcdComMF522+0x174>
80005536:	18 97       	mov	r7,r12
		i--;
80005538:	20 16       	sub	r6,1
8000553a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
8000553c:	c0 a0       	breq	80005550 <PcdComMF522+0xbc>
8000553e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80005542:	c4 c1       	brne	800055da <PcdComMF522+0x146>
80005544:	ef e3 00 08 	and	r8,r7,r3
80005548:	ea 08 18 00 	cp.b	r8,r5
8000554c:	cf 20       	breq	80005530 <PcdComMF522+0x9c>
8000554e:	c4 68       	rjmp	800055da <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80005550:	e0 6b 00 80 	mov	r11,128
80005554:	30 dc       	mov	r12,13
80005556:	f0 1f 00 2b 	mcall	80005600 <PcdComMF522+0x16c>
8000555a:	30 27       	mov	r7,2
8000555c:	c3 38       	rjmp	800055c2 <PcdComMF522+0x12e>
8000555e:	02 67       	and	r7,r1
80005560:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80005564:	30 c8       	mov	r8,12
80005566:	f0 02 18 00 	cp.b	r2,r8
8000556a:	c2 c1       	brne	800055c2 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
8000556c:	30 ac       	mov	r12,10
8000556e:	f0 1f 00 27 	mcall	80005608 <PcdComMF522+0x174>
80005572:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80005574:	30 cc       	mov	r12,12
80005576:	f0 1f 00 25 	mcall	80005608 <PcdComMF522+0x174>
8000557a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
8000557e:	c0 70       	breq	8000558c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005580:	08 98       	mov	r8,r4
80005582:	20 18       	sub	r8,1
80005584:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005588:	a0 8c       	st.b	r0[0x0],r12
8000558a:	c0 48       	rjmp	80005592 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
8000558c:	e8 08 15 03 	lsl	r8,r4,0x3
80005590:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80005592:	58 04       	cp.w	r4,0
80005594:	c0 61       	brne	800055a0 <PcdComMF522+0x10c>
80005596:	30 14       	mov	r4,1
80005598:	40 05       	lddsp	r5,sp[0x0]
8000559a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
8000559c:	30 93       	mov	r3,9
8000559e:	c0 98       	rjmp	800055b0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800055a0:	31 28       	mov	r8,18
800055a2:	f0 04 18 00 	cp.b	r4,r8
800055a6:	f9 b4 0b 12 	movhi	r4,18
800055aa:	58 04       	cp.w	r4,0
800055ac:	cf 61       	brne	80005598 <PcdComMF522+0x104>
800055ae:	c0 a8       	rjmp	800055c2 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800055b0:	06 9c       	mov	r12,r3
800055b2:	f0 1f 00 16 	mcall	80005608 <PcdComMF522+0x174>
800055b6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800055b8:	ec 05 01 08 	sub	r8,r6,r5
800055bc:	e8 08 19 00 	cp.h	r8,r4
800055c0:	cf 83       	brcs	800055b0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
800055c2:	e0 6b 00 80 	mov	r11,128
800055c6:	30 cc       	mov	r12,12
800055c8:	f0 1f 00 0f 	mcall	80005604 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
800055cc:	30 0b       	mov	r11,0
800055ce:	30 1c       	mov	r12,1
800055d0:	f0 1f 00 0b 	mcall	800055fc <PcdComMF522+0x168>
	return status;
}
800055d4:	0e 9c       	mov	r12,r7
800055d6:	2f fd       	sub	sp,-4
800055d8:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
800055da:	e0 6b 00 80 	mov	r11,128
800055de:	30 dc       	mov	r12,13
800055e0:	f0 1f 00 08 	mcall	80005600 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
800055e4:	30 6c       	mov	r12,6
800055e6:	f0 1f 00 09 	mcall	80005608 <PcdComMF522+0x174>
800055ea:	e2 1c 00 1b 	andl	r12,0x1b,COH
800055ee:	cb 80       	breq	8000555e <PcdComMF522+0xca>
800055f0:	30 27       	mov	r7,2
800055f2:	ce 8b       	rjmp	800055c2 <PcdComMF522+0x12e>
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	e9 8c       	*unknown*
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	e9 90       	*unknown*
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	51 90       	stdsp	sp[0x64],r0
80005600:	80 00       	ld.sh	r0,r0[0x0]
80005602:	53 38       	stdsp	sp[0xcc],r8
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	52 f4       	stdsp	sp[0xbc],r4
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	52 50       	stdsp	sp[0x94],r0

8000560c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
8000560c:	eb cd 40 c0 	pushm	r6-r7,lr
80005610:	20 5d       	sub	sp,20
80005612:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80005614:	30 8b       	mov	r11,8
80005616:	16 9c       	mov	r12,r11
80005618:	f0 1f 00 1a 	mcall	80005680 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
8000561c:	30 0b       	mov	r11,0
8000561e:	30 dc       	mov	r12,13
80005620:	f0 1f 00 19 	mcall	80005684 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80005624:	e0 6b 00 80 	mov	r11,128
80005628:	30 ec       	mov	r12,14
8000562a:	f0 1f 00 16 	mcall	80005680 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000562e:	39 38       	mov	r8,-109
80005630:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80005632:	32 08       	mov	r8,32
80005634:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80005636:	1a 9b       	mov	r11,sp
80005638:	fa c8 ff ed 	sub	r8,sp,-19
8000563c:	1a 99       	mov	r9,sp
8000563e:	30 2a       	mov	r10,2
80005640:	30 cc       	mov	r12,12
80005642:	f0 1f 00 12 	mcall	80005688 <PcdAnticoll+0x7c>
80005646:	18 97       	mov	r7,r12

	if (status == MI_OK)
80005648:	c1 21       	brne	8000566c <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000564a:	1b 89       	ld.ub	r9,sp[0x0]
8000564c:	ac 89       	st.b	r6[0x0],r9
8000564e:	1b 98       	ld.ub	r8,sp[0x1]
80005650:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80005652:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005654:	1b a8       	ld.ub	r8,sp[0x2]
80005656:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80005658:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000565c:	1b b9       	ld.ub	r9,sp[0x3]
8000565e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80005660:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80005662:	1b c9       	ld.ub	r9,sp[0x4]
80005664:	f0 09 18 00 	cp.b	r9,r8
80005668:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
8000566c:	e0 6b 00 80 	mov	r11,128
80005670:	30 ec       	mov	r12,14
80005672:	f0 1f 00 07 	mcall	8000568c <PcdAnticoll+0x80>
	return status;
}
80005676:	0e 9c       	mov	r12,r7
80005678:	2f bd       	sub	sp,-20
8000567a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000567e:	00 00       	add	r0,r0
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	53 38       	stdsp	sp[0xcc],r8
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	51 90       	stdsp	sp[0x64],r0
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	54 94       	stdsp	sp[0x124],r4
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	52 f4       	stdsp	sp[0xbc],r4

80005690 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005690:	eb cd 40 c0 	pushm	r6-r7,lr
80005694:	20 5d       	sub	sp,20
80005696:	18 97       	mov	r7,r12
80005698:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
8000569a:	30 8b       	mov	r11,8
8000569c:	16 9c       	mov	r12,r11
8000569e:	f0 1f 00 12 	mcall	800056e4 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
800056a2:	30 7b       	mov	r11,7
800056a4:	30 dc       	mov	r12,13
800056a6:	f0 1f 00 11 	mcall	800056e8 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
800056aa:	30 3b       	mov	r11,3
800056ac:	31 4c       	mov	r12,20
800056ae:	f0 1f 00 10 	mcall	800056ec <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
800056b2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
800056b4:	1a 9b       	mov	r11,sp
800056b6:	fa c8 ff ed 	sub	r8,sp,-19
800056ba:	1a 99       	mov	r9,sp
800056bc:	30 1a       	mov	r10,1
800056be:	30 cc       	mov	r12,12
800056c0:	f0 1f 00 0c 	mcall	800056f0 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
800056c4:	c0 c1       	brne	800056dc <PcdRequest+0x4c>
800056c6:	31 08       	mov	r8,16
800056c8:	fb 39 00 13 	ld.ub	r9,sp[19]
800056cc:	f0 09 18 00 	cp.b	r9,r8
800056d0:	c0 61       	brne	800056dc <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
800056d2:	1b 88       	ld.ub	r8,sp[0x0]
800056d4:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
800056d6:	1b 98       	ld.ub	r8,sp[0x1]
800056d8:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
800056da:	c0 28       	rjmp	800056de <PcdRequest+0x4e>
800056dc:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
800056de:	2f bd       	sub	sp,-20
800056e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	53 38       	stdsp	sp[0xcc],r8
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	51 90       	stdsp	sp[0x64],r0
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	52 f4       	stdsp	sp[0xbc],r4
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	54 94       	stdsp	sp[0x124],r4

800056f4 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
800056f4:	eb cd 40 f8 	pushm	r3-r7,lr
800056f8:	18 95       	mov	r5,r12
800056fa:	16 96       	mov	r6,r11
800056fc:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
800056fe:	30 4b       	mov	r11,4
80005700:	30 5c       	mov	r12,5
80005702:	f0 1f 00 1c 	mcall	80005770 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80005706:	30 0b       	mov	r11,0
80005708:	30 1c       	mov	r12,1
8000570a:	f0 1f 00 1b 	mcall	80005774 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
8000570e:	e0 6b 00 80 	mov	r11,128
80005712:	30 ac       	mov	r12,10
80005714:	f0 1f 00 19 	mcall	80005778 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005718:	58 06       	cp.w	r6,0
8000571a:	c0 c0       	breq	80005732 <CalulateCRC+0x3e>
8000571c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
8000571e:	30 94       	mov	r4,9
80005720:	0f 3b       	ld.ub	r11,r7++
80005722:	08 9c       	mov	r12,r4
80005724:	f0 1f 00 14 	mcall	80005774 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80005728:	0e 98       	mov	r8,r7
8000572a:	0a 18       	sub	r8,r5
8000572c:	ec 08 18 00 	cp.b	r8,r6
80005730:	cf 83       	brcs	80005720 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80005732:	30 3b       	mov	r11,3
80005734:	30 1c       	mov	r12,1
80005736:	f0 1f 00 10 	mcall	80005774 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
8000573a:	30 5c       	mov	r12,5
8000573c:	f0 1f 00 10 	mcall	8000577c <CalulateCRC+0x88>
80005740:	e0 67 00 fe 	mov	r7,254
80005744:	30 56       	mov	r6,5
80005746:	c0 78       	rjmp	80005754 <CalulateCRC+0x60>
80005748:	0c 9c       	mov	r12,r6
8000574a:	f0 1f 00 0d 	mcall	8000577c <CalulateCRC+0x88>
		i--;
8000574e:	20 17       	sub	r7,1
80005750:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80005752:	c0 40       	breq	8000575a <CalulateCRC+0x66>
80005754:	e2 1c 00 04 	andl	r12,0x4,COH
80005758:	cf 80       	breq	80005748 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
8000575a:	32 2c       	mov	r12,34
8000575c:	f0 1f 00 08 	mcall	8000577c <CalulateCRC+0x88>
80005760:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80005762:	32 1c       	mov	r12,33
80005764:	f0 1f 00 06 	mcall	8000577c <CalulateCRC+0x88>
80005768:	a6 9c       	st.b	r3[0x1],r12
}
8000576a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000576e:	00 00       	add	r0,r0
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	53 38       	stdsp	sp[0xcc],r8
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	51 90       	stdsp	sp[0x64],r0
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	52 f4       	stdsp	sp[0xbc],r4
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	52 50       	stdsp	sp[0x94],r0

80005780 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005780:	eb cd 40 80 	pushm	r7,lr
80005784:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005786:	39 38       	mov	r8,-109
80005788:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000578a:	37 08       	mov	r8,112
8000578c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
8000578e:	30 08       	mov	r8,0
80005790:	ba e8       	st.b	sp[0x6],r8
80005792:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80005796:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000579a:	19 89       	ld.ub	r9,r12[0x0]
8000579c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
8000579e:	19 3a       	ld.ub	r10,r12++
800057a0:	1b e9       	ld.ub	r9,sp[0x6]
800057a2:	f5 e9 20 09 	eor	r9,r10,r9
800057a6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
800057a8:	16 38       	cp.w	r8,r11
800057aa:	cf 81       	brne	8000579a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
800057ac:	1a 97       	mov	r7,sp
800057ae:	fa ca ff f9 	sub	r10,sp,-7
800057b2:	30 7b       	mov	r11,7
800057b4:	1a 9c       	mov	r12,sp
800057b6:	f0 1f 00 0d 	mcall	800057e8 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
800057ba:	30 8b       	mov	r11,8
800057bc:	16 9c       	mov	r12,r11
800057be:	f0 1f 00 0c 	mcall	800057ec <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
800057c2:	fa c8 ff ed 	sub	r8,sp,-19
800057c6:	1a 99       	mov	r9,sp
800057c8:	30 9a       	mov	r10,9
800057ca:	1a 9b       	mov	r11,sp
800057cc:	30 cc       	mov	r12,12
800057ce:	f0 1f 00 09 	mcall	800057f0 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
800057d2:	c0 71       	brne	800057e0 <PcdSelect+0x60>
800057d4:	31 88       	mov	r8,24
800057d6:	fb 39 00 13 	ld.ub	r9,sp[19]
800057da:	f0 09 18 00 	cp.b	r9,r8
800057de:	c0 20       	breq	800057e2 <PcdSelect+0x62>
800057e0:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
800057e2:	2f bd       	sub	sp,-20
800057e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	56 f4       	stdsp	sp[0x1bc],r4
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	53 38       	stdsp	sp[0xcc],r8
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	54 94       	stdsp	sp[0x124],r4

800057f4 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
800057f4:	eb cd 40 c0 	pushm	r6-r7,lr
800057f8:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
800057fa:	f0 1f 00 37 	mcall	800058d4 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800057fe:	4b 7b       	lddpc	r11,800058d8 <rfid_auto_reader+0xe4>
80005800:	35 2c       	mov	r12,82
80005802:	f0 1f 00 37 	mcall	800058dc <rfid_auto_reader+0xe8>
80005806:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005808:	c6 31       	brne	800058ce <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000580a:	4b 48       	lddpc	r8,800058d8 <rfid_auto_reader+0xe4>
8000580c:	11 88       	ld.ub	r8,r8[0x0]
8000580e:	30 49       	mov	r9,4
80005810:	f2 08 18 00 	cp.b	r8,r9
80005814:	c0 b1       	brne	8000582a <rfid_auto_reader+0x36>
80005816:	4b 19       	lddpc	r9,800058d8 <rfid_auto_reader+0xe4>
80005818:	13 9a       	ld.ub	r10,r9[0x1]
8000581a:	30 09       	mov	r9,0
8000581c:	f2 0a 18 00 	cp.b	r10,r9
80005820:	c0 51       	brne	8000582a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80005822:	4b 0c       	lddpc	r12,800058e0 <rfid_auto_reader+0xec>
80005824:	f0 1f 00 30 	mcall	800058e4 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005828:	c3 c8       	rjmp	800058a0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000582a:	30 29       	mov	r9,2
8000582c:	f2 08 18 00 	cp.b	r8,r9
80005830:	c0 b1       	brne	80005846 <rfid_auto_reader+0x52>
80005832:	4a a9       	lddpc	r9,800058d8 <rfid_auto_reader+0xe4>
80005834:	13 9a       	ld.ub	r10,r9[0x1]
80005836:	30 09       	mov	r9,0
80005838:	f2 0a 18 00 	cp.b	r10,r9
8000583c:	c0 51       	brne	80005846 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
8000583e:	4a bc       	lddpc	r12,800058e8 <rfid_auto_reader+0xf4>
80005840:	f0 1f 00 29 	mcall	800058e4 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005844:	c2 e8       	rjmp	800058a0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005846:	34 49       	mov	r9,68
80005848:	f2 08 18 00 	cp.b	r8,r9
8000584c:	c0 b1       	brne	80005862 <rfid_auto_reader+0x6e>
8000584e:	4a 39       	lddpc	r9,800058d8 <rfid_auto_reader+0xe4>
80005850:	13 9a       	ld.ub	r10,r9[0x1]
80005852:	30 09       	mov	r9,0
80005854:	f2 0a 18 00 	cp.b	r10,r9
80005858:	c0 51       	brne	80005862 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
8000585a:	4a 5c       	lddpc	r12,800058ec <rfid_auto_reader+0xf8>
8000585c:	f0 1f 00 22 	mcall	800058e4 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005860:	c2 08       	rjmp	800058a0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005862:	30 89       	mov	r9,8
80005864:	f2 08 18 00 	cp.b	r8,r9
80005868:	c0 b1       	brne	8000587e <rfid_auto_reader+0x8a>
8000586a:	49 c9       	lddpc	r9,800058d8 <rfid_auto_reader+0xe4>
8000586c:	13 9a       	ld.ub	r10,r9[0x1]
8000586e:	30 09       	mov	r9,0
80005870:	f2 0a 18 00 	cp.b	r10,r9
80005874:	c0 51       	brne	8000587e <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005876:	49 fc       	lddpc	r12,800058f0 <rfid_auto_reader+0xfc>
80005878:	f0 1f 00 1b 	mcall	800058e4 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000587c:	c1 28       	rjmp	800058a0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000587e:	34 49       	mov	r9,68
80005880:	f2 08 18 00 	cp.b	r8,r9
80005884:	c0 b1       	brne	8000589a <rfid_auto_reader+0xa6>
80005886:	49 58       	lddpc	r8,800058d8 <rfid_auto_reader+0xe4>
80005888:	11 99       	ld.ub	r9,r8[0x1]
8000588a:	30 38       	mov	r8,3
8000588c:	f0 09 18 00 	cp.b	r9,r8
80005890:	c0 51       	brne	8000589a <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80005892:	49 9c       	lddpc	r12,800058f4 <rfid_auto_reader+0x100>
80005894:	f0 1f 00 14 	mcall	800058e4 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005898:	c0 48       	rjmp	800058a0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
8000589a:	49 8c       	lddpc	r12,800058f8 <rfid_auto_reader+0x104>
8000589c:	f0 1f 00 12 	mcall	800058e4 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800058a0:	49 7c       	lddpc	r12,800058fc <rfid_auto_reader+0x108>
800058a2:	f0 1f 00 18 	mcall	80005900 <rfid_auto_reader+0x10c>
800058a6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800058a8:	c0 60       	breq	800058b4 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
800058aa:	34 fb       	mov	r11,79
800058ac:	30 1c       	mov	r12,1
800058ae:	f0 1f 00 16 	mcall	80005904 <rfid_auto_reader+0x110>
		return status;
800058b2:	c0 e8       	rjmp	800058ce <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800058b4:	49 2c       	lddpc	r12,800058fc <rfid_auto_reader+0x108>
800058b6:	f0 1f 00 15 	mcall	80005908 <rfid_auto_reader+0x114>
800058ba:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800058bc:	c0 91       	brne	800058ce <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800058be:	30 4a       	mov	r10,4
800058c0:	48 fb       	lddpc	r11,800058fc <rfid_auto_reader+0x108>
800058c2:	0c 9c       	mov	r12,r6
800058c4:	f0 1f 00 12 	mcall	8000590c <rfid_auto_reader+0x118>
		log("select okay\n");
800058c8:	49 2c       	lddpc	r12,80005910 <rfid_auto_reader+0x11c>
800058ca:	f0 1f 00 07 	mcall	800058e4 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800058ce:	0e 9c       	mov	r12,r7
800058d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	51 d0       	stdsp	sp[0x74],r0
800058d8:	00 00       	add	r0,r0
800058da:	97 b0       	st.w	r11[0x2c],r0
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	56 90       	stdsp	sp[0x1a4],r0
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	e9 ac 80 00 	ldc.w	cp4,cr0,r12[0x0]
800058e6:	7e fc       	ld.w	r12,pc[0x3c]
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	e9 b8       	*unknown*
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	e9 c4 80 00 	stm	r4,pc
800058f2:	e9 d4 80 00 	ldswp.w	r4,r4[0]
800058f6:	e9 dc 80 00 	ldswp.w	r12,r4[0]
800058fa:	e9 e8 00 00 	and	r0,r4,r8
800058fe:	97 b4       	st.w	r11[0x2c],r4
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	56 0c       	stdsp	sp[0x180],r12
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	49 24       	lddpc	r4,8000594c <scan_patrol+0x38>
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	57 80       	stdsp	sp[0x1e0],r0
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	87 a6       	st.w	r3[0x28],r6
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	e9 f4 eb cd 	st.wqs	r4[0x734],r4

80005914 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005914:	eb cd 40 80 	pushm	r7,lr
80005918:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
8000591a:	f0 1f 00 0d 	mcall	8000594c <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
8000591e:	30 0c       	mov	r12,0
80005920:	f0 1f 00 0c 	mcall	80005950 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005924:	0e 9c       	mov	r12,r7
80005926:	f0 1f 00 0c 	mcall	80005954 <scan_patrol+0x40>
8000592a:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
8000592c:	30 1c       	mov	r12,1
8000592e:	f0 1f 00 09 	mcall	80005950 <scan_patrol+0x3c>
	if(return_err == 0)
80005932:	58 07       	cp.w	r7,0
80005934:	c0 51       	brne	8000593e <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80005936:	48 9c       	lddpc	r12,80005958 <scan_patrol+0x44>
80005938:	f0 1f 00 09 	mcall	8000595c <scan_patrol+0x48>
8000593c:	c0 48       	rjmp	80005944 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
8000593e:	48 9c       	lddpc	r12,80005960 <scan_patrol+0x4c>
80005940:	f0 1f 00 07 	mcall	8000595c <scan_patrol+0x48>
		
	return return_err;

}
80005944:	0e 9c       	mov	r12,r7
80005946:	e3 cd 80 80 	ldm	sp++,r7,pc
8000594a:	00 00       	add	r0,r0
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	51 d0       	stdsp	sp[0x74],r0
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	52 a8       	stdsp	sp[0xa8],r8
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	57 f4       	stdsp	sp[0x1fc],r4
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	ea 04       	*unknown*
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	7e fc       	ld.w	r12,pc[0x3c]
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	ea 18 eb cd 	orh	r8,0xebcd

80005964 <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
80005964:	eb cd 40 e0 	pushm	r5-r7,lr
80005968:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
8000596a:	4e 0c       	lddpc	r12,80005ae8 <scan_rfid_save_message+0x184>
8000596c:	30 08       	mov	r8,0
8000596e:	30 09       	mov	r9,0
80005970:	f8 e9 00 00 	st.d	r12[0],r8
80005974:	30 0a       	mov	r10,0
80005976:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005978:	fa e9 00 24 	st.d	sp[36],r8
8000597c:	fa e9 00 2c 	st.d	sp[44],r8
80005980:	fa e9 00 34 	st.d	sp[52],r8
80005984:	fa e9 00 3c 	st.d	sp[60],r8
80005988:	fa e9 00 44 	st.d	sp[68],r8
8000598c:	fa e9 00 4c 	st.d	sp[76],r8
80005990:	fa e9 00 54 	st.d	sp[84],r8
80005994:	fa e9 00 5c 	st.d	sp[92],r8
80005998:	fa e9 00 64 	st.d	sp[100],r8
8000599c:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
800059a0:	f0 1f 00 53 	mcall	80005aec <scan_rfid_save_message+0x188>
800059a4:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800059a6:	e0 81 00 95 	brne	80005ad0 <scan_rfid_save_message+0x16c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800059aa:	4d 06       	lddpc	r6,80005ae8 <scan_rfid_save_message+0x184>
800059ac:	0d b8       	ld.ub	r8,r6[0x3]
800059ae:	1a d8       	st.w	--sp,r8
800059b0:	0d a8       	ld.ub	r8,r6[0x2]
800059b2:	1a d8       	st.w	--sp,r8
800059b4:	0d 98       	ld.ub	r8,r6[0x1]
800059b6:	1a d8       	st.w	--sp,r8
800059b8:	0d 88       	ld.ub	r8,r6[0x0]
800059ba:	1a d8       	st.w	--sp,r8
800059bc:	4c dc       	lddpc	r12,80005af0 <scan_rfid_save_message+0x18c>
800059be:	f0 1f 00 4e 	mcall	80005af4 <scan_rfid_save_message+0x190>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
800059c2:	34 4b       	mov	r11,68
800059c4:	30 1c       	mov	r12,1
800059c6:	f0 1f 00 4d 	mcall	80005af8 <scan_rfid_save_message+0x194>
800059ca:	fa c8 ff ec 	sub	r8,sp,-20
800059ce:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
800059d2:	ec c5 ff fc 	sub	r5,r6,-4
800059d6:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800059d8:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800059da:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800059dc:	0d 8a       	ld.ub	r10,r6[0x0]
800059de:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800059e2:	fc 0b 18 00 	cp.b	r11,lr
800059e6:	f7 bb 08 d0 	subls	r11,-48
800059ea:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800059ee:	f7 bb 0b a9 	subhi	r11,-87
800059f2:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800059f6:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
800059f8:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800059fc:	fc 0a 18 00 	cp.b	r10,lr
80005a00:	f7 ba 08 d0 	subls	r10,-48
80005a04:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005a08:	f7 ba 0b a9 	subhi	r10,-87
80005a0c:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005a10:	b0 bc       	st.b	r8[0x3],r12
80005a12:	2f f6       	sub	r6,-1
80005a14:	2f c8       	sub	r8,-4
80005a16:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005a18:	0a 36       	cp.w	r6,r5
80005a1a:	ce 11       	brne	800059dc <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005a1c:	30 6a       	mov	r10,6
80005a1e:	4b 8b       	lddpc	r11,80005afc <scan_rfid_save_message+0x198>
80005a20:	fa cc ff ec 	sub	r12,sp,-20
80005a24:	f0 1f 00 37 	mcall	80005b00 <scan_rfid_save_message+0x19c>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005a28:	4b 78       	lddpc	r8,80005b04 <scan_rfid_save_message+0x1a0>
80005a2a:	11 89       	ld.ub	r9,r8[0x0]
80005a2c:	39 f8       	mov	r8,-97
80005a2e:	f0 09 18 00 	cp.b	r9,r8
80005a32:	e0 88 00 05 	brls	80005a3c <scan_rfid_save_message+0xd8>
80005a36:	38 09       	mov	r9,-128
80005a38:	4b 38       	lddpc	r8,80005b04 <scan_rfid_save_message+0x1a0>
80005a3a:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005a3c:	4b 28       	lddpc	r8,80005b04 <scan_rfid_save_message+0x1a0>
80005a3e:	11 86       	ld.ub	r6,r8[0x0]
80005a40:	2f f6       	sub	r6,-1
80005a42:	5c 56       	castu.b	r6
80005a44:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005a46:	30 5a       	mov	r10,5
80005a48:	4b 0b       	lddpc	r11,80005b08 <scan_rfid_save_message+0x1a4>
80005a4a:	fa cc ff e1 	sub	r12,sp,-31
80005a4e:	f0 1f 00 2d 	mcall	80005b00 <scan_rfid_save_message+0x19c>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005a52:	31 e8       	mov	r8,30
80005a54:	fb 58 00 1a 	st.h	sp[26],r8
80005a58:	fb 66 00 1e 	st.b	sp[30],r6
80005a5c:	fe 78 e0 00 	mov	r8,-8192
80005a60:	fb 58 00 1c 	st.h	sp[28],r8
80005a64:	30 aa       	mov	r10,10
80005a66:	fa cb ff e6 	sub	r11,sp,-26
80005a6a:	fa cc ff dc 	sub	r12,sp,-36
80005a6e:	f0 1f 00 25 	mcall	80005b00 <scan_rfid_save_message+0x19c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005a72:	31 6a       	mov	r10,22
80005a74:	fa cb ff fc 	sub	r11,sp,-4
80005a78:	fa cc ff d2 	sub	r12,sp,-46
80005a7c:	f0 1f 00 21 	mcall	80005b00 <scan_rfid_save_message+0x19c>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005a80:	4a 38       	lddpc	r8,80005b0c <scan_rfid_save_message+0x1a8>
80005a82:	70 0c       	ld.w	r12,r8[0x0]
80005a84:	f0 1f 00 23 	mcall	80005b10 <scan_rfid_save_message+0x1ac>
80005a88:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005a8a:	c1 f0       	breq	80005ac8 <scan_rfid_save_message+0x164>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005a8c:	32 0a       	mov	r10,32
80005a8e:	fa cb ff dc 	sub	r11,sp,-36
80005a92:	f0 1f 00 1c 	mcall	80005b00 <scan_rfid_save_message+0x19c>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005a96:	4a 08       	lddpc	r8,80005b14 <scan_rfid_save_message+0x1b0>
80005a98:	70 0c       	ld.w	r12,r8[0x0]
80005a9a:	30 09       	mov	r9,0
80005a9c:	12 9a       	mov	r10,r9
80005a9e:	1a 9b       	mov	r11,sp
80005aa0:	f0 1f 00 1e 	mcall	80005b18 <scan_rfid_save_message+0x1b4>
80005aa4:	58 1c       	cp.w	r12,1
80005aa6:	c1 c0       	breq	80005ade <scan_rfid_save_message+0x17a>
			{
				log("xg_resend_queue: full\n" );
80005aa8:	49 dc       	lddpc	r12,80005b1c <scan_rfid_save_message+0x1b8>
80005aaa:	f0 1f 00 13 	mcall	80005af4 <scan_rfid_save_message+0x190>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005aae:	32 3b       	mov	r11,35
80005ab0:	30 1c       	mov	r12,1
80005ab2:	f0 1f 00 12 	mcall	80005af8 <scan_rfid_save_message+0x194>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005ab6:	e0 6c 17 70 	mov	r12,6000
80005aba:	f0 1f 00 1a 	mcall	80005b20 <scan_rfid_save_message+0x1bc>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005abe:	32 3b       	mov	r11,35
80005ac0:	30 0c       	mov	r12,0
80005ac2:	f0 1f 00 0e 	mcall	80005af8 <scan_rfid_save_message+0x194>
80005ac6:	c0 c8       	rjmp	80005ade <scan_rfid_save_message+0x17a>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005ac8:	49 7c       	lddpc	r12,80005b24 <scan_rfid_save_message+0x1c0>
80005aca:	f0 1f 00 0b 	mcall	80005af4 <scan_rfid_save_message+0x190>
80005ace:	c0 88       	rjmp	80005ade <scan_rfid_save_message+0x17a>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005ad0:	34 fb       	mov	r11,79
80005ad2:	30 1c       	mov	r12,1
80005ad4:	f0 1f 00 09 	mcall	80005af8 <scan_rfid_save_message+0x194>
		log("no card find...\n");
80005ad8:	49 4c       	lddpc	r12,80005b28 <scan_rfid_save_message+0x1c4>
80005ada:	f0 1f 00 07 	mcall	80005af4 <scan_rfid_save_message+0x190>
	}
	
	return return_err;
	

}
80005ade:	0e 9c       	mov	r12,r7
80005ae0:	2e 3d       	sub	sp,-116
80005ae2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005ae6:	00 00       	add	r0,r0
80005ae8:	00 00       	add	r0,r0
80005aea:	0b 84       	ld.ub	r4,r5[0x0]
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	59 14       	cp.w	r4,17
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	ea 2c 80 00 	sub	r12,688128
80005af6:	7e fc       	ld.w	r12,pc[0x3c]
80005af8:	80 00       	ld.sh	r0,r0[0x0]
80005afa:	49 24       	lddpc	r4,80005b40 <delay_ns+0x8>
80005afc:	00 00       	add	r0,r0
80005afe:	0e 20       	rsub	r0,r7
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	87 a6       	st.w	r3[0x28],r6
80005b04:	00 00       	add	r0,r0
80005b06:	05 3c       	ld.ub	r12,r2++
80005b08:	00 00       	add	r0,r0
80005b0a:	05 34       	ld.ub	r4,r2++
80005b0c:	00 00       	add	r0,r0
80005b0e:	0b 9c       	ld.ub	r12,r5[0x1]
80005b10:	80 00       	ld.sh	r0,r0[0x0]
80005b12:	36 68       	mov	r8,102
80005b14:	00 00       	add	r0,r0
80005b16:	0b 90       	ld.ub	r0,r5[0x1]
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	72 ac       	ld.w	r12,r9[0x28]
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	e8 54 80 00 	cp.w	r4,622592
80005b22:	79 90       	ld.w	r0,r12[0x64]
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	e8 6c 80 00 	mov	r12,557056
80005b2a:	ea 48 d4 01 	cp.w	r8,709633

80005b2c <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80005b2c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005b2e:	f0 1f 00 02 	mcall	80005b34 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005b32:	d8 02       	popm	pc
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	53 e0       	stdsp	sp[0xf8],r0

80005b38 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005b38:	58 0c       	cp.w	r12,0
80005b3a:	5e 0c       	reteq	r12
80005b3c:	30 08       	mov	r8,0
	{
		nop();
80005b3e:	d7 03       	nop
		nop();
80005b40:	d7 03       	nop
		nop();
80005b42:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005b44:	2f f8       	sub	r8,-1
80005b46:	10 3c       	cp.w	r12,r8
80005b48:	fe 9b ff fb 	brhi	80005b3e <delay_ns+0x6>
80005b4c:	5e fc       	retal	r12
80005b4e:	d7 03       	nop

80005b50 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005b50:	eb cd 40 e0 	pushm	r5-r7,lr
80005b54:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005b56:	58 0c       	cp.w	r12,0
80005b58:	c0 b0       	breq	80005b6e <delay_us+0x1e>
80005b5a:	30 07       	mov	r7,0
		delay_ns(1000);
80005b5c:	e0 65 03 e8 	mov	r5,1000
80005b60:	0a 9c       	mov	r12,r5
80005b62:	f0 1f 00 05 	mcall	80005b74 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005b66:	2f f7       	sub	r7,-1
80005b68:	0e 36       	cp.w	r6,r7
80005b6a:	fe 9b ff fb 	brhi	80005b60 <delay_us+0x10>
80005b6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b72:	00 00       	add	r0,r0
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	5b 38       	cp.w	r8,-13

80005b78 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005b78:	eb cd 40 e0 	pushm	r5-r7,lr
80005b7c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005b7e:	58 0c       	cp.w	r12,0
80005b80:	c0 b0       	breq	80005b96 <delay_ms+0x1e>
80005b82:	30 07       	mov	r7,0
		delay_us(1000);
80005b84:	e0 65 03 e8 	mov	r5,1000
80005b88:	0a 9c       	mov	r12,r5
80005b8a:	f0 1f 00 05 	mcall	80005b9c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005b8e:	2f f7       	sub	r7,-1
80005b90:	0e 36       	cp.w	r6,r7
80005b92:	fe 9b ff fb 	brhi	80005b88 <delay_ms+0x10>
80005b96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b9a:	00 00       	add	r0,r0
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	5b 50       	cp.w	r0,-11

80005ba0 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005ba0:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005ba2:	30 3b       	mov	r11,3
80005ba4:	48 8c       	lddpc	r12,80005bc4 <local_start_timer+0x24>
80005ba6:	f0 1f 00 09 	mcall	80005bc8 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005baa:	fe 78 38 00 	mov	r8,-51200
80005bae:	e0 69 91 0d 	mov	r9,37133
80005bb2:	ea 19 00 52 	orh	r9,0x52
80005bb6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005bb8:	32 09       	mov	r9,32
80005bba:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005bbc:	30 59       	mov	r9,5
80005bbe:	91 09       	st.w	r8[0x0],r9
}
80005bc0:	d8 02       	popm	pc
80005bc2:	00 00       	add	r0,r0
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	ea 5c 80 00 	cp.w	r12,753664
80005bca:	62 c8       	ld.w	r8,r1[0x30]

80005bcc <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005bcc:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005bce:	30 3a       	mov	r10,3
80005bd0:	e0 6b 1b 00 	mov	r11,6912
80005bd4:	ea 1b 00 b7 	orh	r11,0xb7
80005bd8:	fe 7c 0c 00 	mov	r12,-62464
80005bdc:	f0 1f 00 19 	mcall	80005c40 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005be0:	31 08       	mov	r8,16
80005be2:	1a d8       	st.w	--sp,r8
80005be4:	30 08       	mov	r8,0
80005be6:	30 19       	mov	r9,1
80005be8:	30 7a       	mov	r10,7
80005bea:	10 9b       	mov	r11,r8
80005bec:	fe 7c 0c 00 	mov	r12,-62464
80005bf0:	f0 1f 00 15 	mcall	80005c44 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005bf4:	30 08       	mov	r8,0
80005bf6:	30 19       	mov	r9,1
80005bf8:	12 9a       	mov	r10,r9
80005bfa:	10 9b       	mov	r11,r8
80005bfc:	fe 7c 0c 00 	mov	r12,-62464
80005c00:	f0 1f 00 12 	mcall	80005c48 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005c04:	30 0b       	mov	r11,0
80005c06:	fe 7c 0c 00 	mov	r12,-62464
80005c0a:	f0 1f 00 11 	mcall	80005c4c <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005c0e:	fe 7c 0c 00 	mov	r12,-62464
80005c12:	f0 1f 00 10 	mcall	80005c50 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005c16:	30 0a       	mov	r10,0
80005c18:	1a da       	st.w	--sp,r10
80005c1a:	1a da       	st.w	--sp,r10
80005c1c:	14 98       	mov	r8,r10
80005c1e:	14 99       	mov	r9,r10
80005c20:	30 1b       	mov	r11,1
80005c22:	fe 7c 0c 00 	mov	r12,-62464
80005c26:	f0 1f 00 0c 	mcall	80005c54 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005c2a:	30 1c       	mov	r12,1
80005c2c:	f0 1f 00 0b 	mcall	80005c58 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005c30:	30 2b       	mov	r11,2
80005c32:	fe 7c 0c 00 	mov	r12,-62464
80005c36:	f0 1f 00 0a 	mcall	80005c5c <local_start_pll0+0x90>
80005c3a:	2f dd       	sub	sp,-12
/****/
}
80005c3c:	d8 02       	popm	pc
80005c3e:	00 00       	add	r0,r0
80005c40:	80 00       	ld.sh	r0,r0[0x0]
80005c42:	65 d0       	ld.w	r0,r2[0x74]
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	65 72       	ld.w	r2,r2[0x5c]
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	65 94       	ld.w	r4,r2[0x64]
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	65 ae       	ld.w	lr,r2[0x68]
80005c50:	80 00       	ld.sh	r0,r0[0x0]
80005c52:	65 bc       	ld.w	r12,r2[0x6c]
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	65 2c       	ld.w	r12,r2[0x48]
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	62 68       	ld.w	r8,r1[0x18]
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	65 c6       	ld.w	r6,r2[0x70]

80005c60 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005c60:	d4 31       	pushm	r0-r7,lr
80005c62:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005c64:	f0 1f 00 81 	mcall	80005e68 <xg_flashc_init+0x208>
80005c68:	fe f8 02 04 	ld.w	r8,pc[516]
80005c6c:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005c6e:	70 08       	ld.w	r8,r8[0x0]
80005c70:	58 08       	cp.w	r8,0
80005c72:	c0 41       	brne	80005c7a <xg_flashc_init+0x1a>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005c74:	4f fc       	lddpc	r12,80005e70 <xg_flashc_init+0x210>
80005c76:	f0 1f 00 80 	mcall	80005e74 <xg_flashc_init+0x214>
	//计数最大值为10
	//初始值为1(当flash信息数量为0时：用户扫点 -> flash-save -> flash-count+1 -> take Sem -> send -> wait for give-Sem(success/fail))
	//如果此时反馈成功，则继续查询count值是否等于0/等待用户扫点
	//如果此时反馈失败，则flash-save
	//当flash信息数量！=0时；等待查询count值
	SendM_CountingSemaphore = xSemaphoreCreateCounting(10, 0);
80005c7a:	30 0b       	mov	r11,0
80005c7c:	30 ac       	mov	r12,10
80005c7e:	f0 1f 00 7f 	mcall	80005e78 <xg_flashc_init+0x218>
80005c82:	4f f8       	lddpc	r8,80005e7c <xg_flashc_init+0x21c>
80005c84:	91 0c       	st.w	r8[0x0],r12
	if (SendM_CountingSemaphore == NULL)
80005c86:	70 08       	ld.w	r8,r8[0x0]
80005c88:	58 08       	cp.w	r8,0
80005c8a:	c0 41       	brne	80005c92 <xg_flashc_init+0x32>
	{
		log("Create the SendM_Counting semaphore failure\n");
80005c8c:	4f dc       	lddpc	r12,80005e80 <xg_flashc_init+0x220>
80005c8e:	f0 1f 00 7a 	mcall	80005e74 <xg_flashc_init+0x214>
	}
	
	xg_resend_queue = xQueueCreate(40, sizeof(U32));
80005c92:	30 4b       	mov	r11,4
80005c94:	32 8c       	mov	r12,40
80005c96:	f0 1f 00 7c 	mcall	80005e84 <xg_flashc_init+0x224>
80005c9a:	4f c8       	lddpc	r8,80005e88 <xg_flashc_init+0x228>
80005c9c:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005c9e:	30 4b       	mov	r11,4
80005ca0:	33 2c       	mov	r12,50
80005ca2:	f0 1f 00 79 	mcall	80005e84 <xg_flashc_init+0x224>
80005ca6:	4f a8       	lddpc	r8,80005e8c <xg_flashc_init+0x22c>
80005ca8:	91 0c       	st.w	r8[0x0],r12
80005caa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005cac:	10 96       	mov	r6,r8
80005cae:	4f 95       	lddpc	r5,80005e90 <xg_flashc_init+0x230>
80005cb0:	6c 0c       	ld.w	r12,r6[0x0]
80005cb2:	ea 07 00 0b 	add	r11,r5,r7
80005cb6:	f0 1f 00 78 	mcall	80005e94 <xg_flashc_init+0x234>
80005cba:	2e 07       	sub	r7,-32
	}
	
	xg_resend_queue = xQueueCreate(40, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005cbc:	e0 47 06 40 	cp.w	r7,1600
80005cc0:	cf 81       	brne	80005cb0 <xg_flashc_init+0x50>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005cc2:	f0 1f 00 76 	mcall	80005e98 <xg_flashc_init+0x238>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005cc6:	30 0a       	mov	r10,0
80005cc8:	30 0b       	mov	r11,0
80005cca:	4f 58       	lddpc	r8,80005e9c <xg_flashc_init+0x23c>
80005ccc:	b1 2a       	st.d	r8++,r10
80005cce:	b1 2a       	st.d	r8++,r10
80005cd0:	b1 2a       	st.d	r8++,r10
80005cd2:	b1 2a       	st.d	r8++,r10
80005cd4:	b1 2a       	st.d	r8++,r10
80005cd6:	b1 2a       	st.d	r8++,r10
80005cd8:	b1 2a       	st.d	r8++,r10
80005cda:	b1 2a       	st.d	r8++,r10
80005cdc:	b1 2a       	st.d	r8++,r10
80005cde:	f0 eb 00 00 	st.d	r8[0],r10
80005ce2:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005ce4:	4e e7       	lddpc	r7,80005e9c <xg_flashc_init+0x23c>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005ce6:	ee c4 ff f8 	sub	r4,r7,-8
80005cea:	e8 c3 ff f8 	sub	r3,r4,-8
80005cee:	e6 c2 ff f8 	sub	r2,r3,-8
80005cf2:	e4 c1 ff f8 	sub	r1,r2,-8
80005cf6:	e2 c0 ff f8 	sub	r0,r1,-8
80005cfa:	e0 ca ff f8 	sub	r10,r0,-8
80005cfe:	50 0a       	stdsp	sp[0x0],r10
80005d00:	2f 8a       	sub	r10,-8
80005d02:	50 1a       	stdsp	sp[0x4],r10
80005d04:	2f 8a       	sub	r10,-8
80005d06:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005d08:	0e 9a       	mov	r10,r7
80005d0a:	30 6b       	mov	r11,6
80005d0c:	30 0c       	mov	r12,0
80005d0e:	f0 1f 00 65 	mcall	80005ea0 <xg_flashc_init+0x240>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005d12:	30 6a       	mov	r10,6
80005d14:	0e 9b       	mov	r11,r7
80005d16:	4e 4c       	lddpc	r12,80005ea4 <xg_flashc_init+0x244>
80005d18:	f0 1f 00 64 	mcall	80005ea8 <xg_flashc_init+0x248>
80005d1c:	c1 c0       	breq	80005d54 <xg_flashc_init+0xf4>
80005d1e:	c8 b8       	rjmp	80005e34 <xg_flashc_init+0x1d4>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005d20:	30 6a       	mov	r10,6
80005d22:	30 0b       	mov	r11,0
80005d24:	4e 0c       	lddpc	r12,80005ea4 <xg_flashc_init+0x244>
80005d26:	f0 1f 00 62 	mcall	80005eac <xg_flashc_init+0x24c>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005d2a:	4d d7       	lddpc	r7,80005e9c <xg_flashc_init+0x23c>
80005d2c:	35 0a       	mov	r10,80
80005d2e:	30 0b       	mov	r11,0
80005d30:	0e 9c       	mov	r12,r7
80005d32:	f0 1f 00 60 	mcall	80005eb0 <xg_flashc_init+0x250>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005d36:	30 2a       	mov	r10,2
80005d38:	30 6b       	mov	r11,6
80005d3a:	0e 9c       	mov	r12,r7
80005d3c:	f0 1f 00 5c 	mcall	80005eac <xg_flashc_init+0x24c>
			if(return_code != DF_WRITE_COMPLETED)
80005d40:	58 7c       	cp.w	r12,7
80005d42:	e0 81 00 90 	brne	80005e62 <xg_flashc_init+0x202>
			{
				return FALSE;
			}
			current_message_index = 0;
80005d46:	30 09       	mov	r9,0
80005d48:	4d b8       	lddpc	r8,80005eb4 <xg_flashc_init+0x254>
80005d4a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005d4c:	4d bc       	lddpc	r12,80005eb8 <xg_flashc_init+0x258>
80005d4e:	f0 1f 00 4a 	mcall	80005e74 <xg_flashc_init+0x214>
80005d52:	c8 58       	rjmp	80005e5c <xg_flashc_init+0x1fc>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005d54:	1a d7       	st.w	--sp,r7
80005d56:	4d ac       	lddpc	r12,80005ebc <xg_flashc_init+0x25c>
80005d58:	f0 1f 00 47 	mcall	80005e74 <xg_flashc_init+0x214>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005d5c:	4d 6a       	lddpc	r10,80005eb4 <xg_flashc_init+0x254>
80005d5e:	30 2b       	mov	r11,2
80005d60:	30 6c       	mov	r12,6
80005d62:	f0 1f 00 50 	mcall	80005ea0 <xg_flashc_init+0x240>
			if(return_code == DF_OK)
80005d66:	2f fd       	sub	sp,-4
80005d68:	58 0c       	cp.w	r12,0
80005d6a:	e0 81 00 7c 	brne	80005e62 <xg_flashc_init+0x202>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005d6e:	4d 28       	lddpc	r8,80005eb4 <xg_flashc_init+0x254>
80005d70:	90 08       	ld.sh	r8,r8[0x0]
80005d72:	58 08       	cp.w	r8,0
80005d74:	c7 10       	breq	80005e56 <xg_flashc_init+0x1f6>
					
					log("current_message_index: %d\n", current_message_index);
80005d76:	5c 78       	castu.h	r8
80005d78:	1a d8       	st.w	--sp,r8
80005d7a:	4d 2c       	lddpc	r12,80005ec0 <xg_flashc_init+0x260>
80005d7c:	f0 1f 00 3e 	mcall	80005e74 <xg_flashc_init+0x214>
					memset(str, 0x00, sizeof(str));	
80005d80:	30 08       	mov	r8,0
80005d82:	30 09       	mov	r9,0
80005d84:	ee e9 00 00 	st.d	r7[0],r8
80005d88:	e8 e9 00 00 	st.d	r4[0],r8
80005d8c:	e6 e9 00 00 	st.d	r3[0],r8
80005d90:	e4 e9 00 00 	st.d	r2[0],r8
80005d94:	e2 e9 00 00 	st.d	r1[0],r8
80005d98:	e0 e9 00 00 	st.d	r0[0],r8
80005d9c:	40 1a       	lddsp	r10,sp[0x4]
80005d9e:	f4 e9 00 00 	st.d	r10[0],r8
80005da2:	40 2a       	lddsp	r10,sp[0x8]
80005da4:	f4 e9 00 00 	st.d	r10[0],r8
80005da8:	40 3a       	lddsp	r10,sp[0xc]
80005daa:	b5 28       	st.d	r10++,r8
80005dac:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005db0:	4c 18       	lddpc	r8,80005eb4 <xg_flashc_init+0x254>
80005db2:	90 85       	ld.uh	r5,r8[0x0]
80005db4:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005db6:	0e 9a       	mov	r10,r7
80005db8:	30 8b       	mov	r11,8
80005dba:	0a 9c       	mov	r12,r5
80005dbc:	f0 1f 00 39 	mcall	80005ea0 <xg_flashc_init+0x240>
					if(return_code == DF_OK)
80005dc0:	2f fd       	sub	sp,-4
80005dc2:	58 0c       	cp.w	r12,0
80005dc4:	c4 91       	brne	80005e56 <xg_flashc_init+0x1f6>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005dc6:	0f 89       	ld.ub	r9,r7[0x0]
80005dc8:	0f 98       	ld.ub	r8,r7[0x1]
80005dca:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005dce:	4b a9       	lddpc	r9,80005eb4 <xg_flashc_init+0x254>
80005dd0:	92 09       	ld.sh	r9,r9[0x0]
80005dd2:	f0 09 19 00 	cp.h	r9,r8
80005dd6:	c2 c1       	brne	80005e2e <xg_flashc_init+0x1ce>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005dd8:	0f e9       	ld.ub	r9,r7[0x6]
80005dda:	0f f8       	ld.ub	r8,r7[0x7]
80005ddc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005de0:	0f aa       	ld.ub	r10,r7[0x2]
80005de2:	0f b8       	ld.ub	r8,r7[0x3]
80005de4:	b1 68       	lsl	r8,0x10
80005de6:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005dea:	0f ca       	ld.ub	r10,r7[0x4]
80005dec:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005df0:	0f da       	ld.ub	r10,r7[0x5]
80005df2:	f5 e8 10 08 	or	r8,r10,r8
80005df6:	f2 08 00 08 	add	r8,r9,r8
80005dfa:	4b 36       	lddpc	r6,80005ec4 <xg_flashc_init+0x264>
80005dfc:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005dfe:	1a d8       	st.w	--sp,r8
80005e00:	4b 2c       	lddpc	r12,80005ec8 <xg_flashc_init+0x268>
80005e02:	f0 1f 00 1d 	mcall	80005e74 <xg_flashc_init+0x214>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005e06:	2f fd       	sub	sp,-4
80005e08:	6c 08       	ld.w	r8,r6[0x0]
80005e0a:	e0 69 ff ff 	mov	r9,65535
80005e0e:	ea 19 00 7f 	orh	r9,0x7f
80005e12:	12 38       	cp.w	r8,r9
80005e14:	e0 88 00 21 	brls	80005e56 <xg_flashc_init+0x1f6>
										
								log("\r\n----message storage is full!!!----\r\n");
80005e18:	4a dc       	lddpc	r12,80005ecc <xg_flashc_init+0x26c>
80005e1a:	f0 1f 00 17 	mcall	80005e74 <xg_flashc_init+0x214>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005e1e:	30 4b       	mov	r11,4
80005e20:	30 0c       	mov	r12,0
80005e22:	f0 1f 00 2c 	mcall	80005ed0 <xg_flashc_init+0x270>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005e26:	58 5c       	cp.w	r12,5
80005e28:	fe 90 ff 70 	breq	80005d08 <xg_flashc_init+0xa8>
80005e2c:	c1 b8       	rjmp	80005e62 <xg_flashc_init+0x202>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005e2e:	4a ac       	lddpc	r12,80005ed4 <xg_flashc_init+0x274>
80005e30:	f0 1f 00 11 	mcall	80005e74 <xg_flashc_init+0x214>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005e34:	30 3b       	mov	r11,3
80005e36:	0a 9c       	mov	r12,r5
80005e38:	f0 1f 00 26 	mcall	80005ed0 <xg_flashc_init+0x270>
				if(return_code != DF_ERASE_COMPLETED)
80005e3c:	58 5c       	cp.w	r12,5
80005e3e:	c1 21       	brne	80005e62 <xg_flashc_init+0x202>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005e40:	30 3b       	mov	r11,3
80005e42:	e0 78 00 00 	mov	r8,65536
80005e46:	ea 08 00 0c 	add	r12,r5,r8
80005e4a:	f0 1f 00 22 	mcall	80005ed0 <xg_flashc_init+0x270>
				if(return_code != DF_ERASE_COMPLETED)
80005e4e:	58 5c       	cp.w	r12,5
80005e50:	fe 90 ff 68 	breq	80005d20 <xg_flashc_init+0xc0>
80005e54:	c0 78       	rjmp	80005e62 <xg_flashc_init+0x202>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005e56:	4a 1c       	lddpc	r12,80005ed8 <xg_flashc_init+0x278>
80005e58:	f0 1f 00 07 	mcall	80005e74 <xg_flashc_init+0x214>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005e5c:	30 19       	mov	r9,1
80005e5e:	4a 08       	lddpc	r8,80005edc <xg_flashc_init+0x27c>
80005e60:	b0 89       	st.b	r8[0x0],r9
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005e62:	2f dd       	sub	sp,-12
80005e64:	d8 32       	popm	r0-r7,pc
80005e66:	00 00       	add	r0,r0
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	73 ac       	ld.w	r12,r9[0x68]
80005e6c:	00 00       	add	r0,r0
80005e6e:	0b 98       	ld.ub	r8,r5[0x1]
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	ea 74 80 00 	mov	r4,753664
80005e76:	7e fc       	ld.w	r12,pc[0x3c]
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	74 78       	ld.w	r8,r10[0x1c]
80005e7c:	00 00       	add	r0,r0
80005e7e:	0b a8       	ld.ub	r8,r5[0x2]
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	ea a0 80 00 	rcall	80155e82 <_data_lma+0x146872>
80005e86:	74 04       	ld.w	r4,r10[0x0]
80005e88:	00 00       	add	r0,r0
80005e8a:	0b 90       	ld.ub	r0,r5[0x1]
80005e8c:	00 00       	add	r0,r0
80005e8e:	0b 9c       	ld.ub	r12,r5[0x1]
80005e90:	00 00       	add	r0,r0
80005e92:	97 b8       	st.w	r11[0x2c],r8
80005e94:	80 00       	ld.sh	r0,r0[0x0]
80005e96:	34 bc       	mov	r12,75
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	31 84       	mov	r4,24
80005e9c:	00 00       	add	r0,r0
80005e9e:	0b ac       	ld.ub	r12,r5[0x2]
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	2e 28       	sub	r8,-30
80005ea4:	00 00       	add	r0,r0
80005ea6:	05 40       	ld.w	r0,--r2
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	87 80       	st.w	r3[0x20],r0
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	30 60       	mov	r0,6
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	88 ee       	ld.uh	lr,r4[0xc]
80005eb4:	00 00       	add	r0,r0
80005eb6:	0b a4       	ld.ub	r4,r5[0x2]
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	ea d0 80 00 	satsub.w	r0,r5,-32768
80005ebe:	ea fc 80 00 	ld.w	r12,r5[-32768]
80005ec2:	eb 08 00 00 	ld.sh	r8,r5[0]
80005ec6:	05 48       	ld.w	r8,--r2
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	eb 24 80 00 	ld.sb	r4,r5[-32768]
80005ece:	eb 48 80 00 	st.w	r5[-32768],r8
80005ed2:	2f c0       	sub	r0,-4
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	eb 70 80 00 	stcond	r5[-32768],r0
80005eda:	eb 98       	*unknown*
80005edc:	00 00       	add	r0,r0
80005ede:	0b 94       	ld.ub	r4,r5[0x1]

80005ee0 <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005ee0:	d4 31       	pushm	r0-r7,lr
80005ee2:	20 4d       	sub	sp,16
80005ee4:	18 96       	mov	r6,r12
80005ee6:	16 95       	mov	r5,r11
80005ee8:	14 94       	mov	r4,r10
	if(!list_init_success_flag)return XG_ERROR;
80005eea:	4d c8       	lddpc	r8,80006058 <xgflash_get_message_data+0x178>
80005eec:	11 89       	ld.ub	r9,r8[0x0]
80005eee:	30 08       	mov	r8,0
80005ef0:	f0 09 18 00 	cp.b	r9,r8
80005ef4:	c0 31       	brne	80005efa <xgflash_get_message_data+0x1a>
80005ef6:	3f fc       	mov	r12,-1
80005ef8:	ca e8       	rjmp	80006054 <xgflash_get_message_data+0x174>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005efa:	4d 98       	lddpc	r8,8000605c <xgflash_get_message_data+0x17c>
80005efc:	70 0c       	ld.w	r12,r8[0x0]
80005efe:	30 09       	mov	r9,0
80005f00:	3f fa       	mov	r10,-1
80005f02:	12 9b       	mov	r11,r9
80005f04:	f0 1f 00 57 	mcall	80006060 <xgflash_get_message_data+0x180>
	/* check input parameter */
	if (message_index > current_message_index)
80005f08:	4d 78       	lddpc	r8,80006064 <xgflash_get_message_data+0x184>
80005f0a:	90 88       	ld.uh	r8,r8[0x0]
80005f0c:	0c 38       	cp.w	r8,r6
80005f0e:	c0 a2       	brcc	80005f22 <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005f10:	4d 38       	lddpc	r8,8000605c <xgflash_get_message_data+0x17c>
80005f12:	70 0c       	ld.w	r12,r8[0x0]
80005f14:	30 09       	mov	r9,0
80005f16:	12 9a       	mov	r10,r9
80005f18:	12 9b       	mov	r11,r9
80005f1a:	f0 1f 00 54 	mcall	80006068 <xgflash_get_message_data+0x188>
80005f1e:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005f20:	c9 a8       	rjmp	80006054 <xgflash_get_message_data+0x174>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80005f22:	fa ca ff f0 	sub	r10,sp,-16
80005f26:	30 08       	mov	r8,0
80005f28:	30 09       	mov	r9,0
80005f2a:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005f2c:	ec 00 15 03 	lsl	r0,r6,0x3
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80005f30:	30 8b       	mov	r11,8
80005f32:	00 9c       	mov	r12,r0
80005f34:	f0 1f 00 4e 	mcall	8000606c <xgflash_get_message_data+0x18c>
	if (return_code == DF_OK)
80005f38:	e0 81 00 86 	brne	80006044 <xgflash_get_message_data+0x164>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80005f3c:	9a 48       	ld.sh	r8,sp[0x8]
80005f3e:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80005f42:	0c 39       	cp.w	r9,r6
80005f44:	c5 d1       	brne	80005ffe <xgflash_get_message_data+0x11e>
		{
			bytes_remained = ptr->offset;
80005f46:	40 38       	lddsp	r8,sp[0xc]
80005f48:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005f4c:	50 09       	stdsp	sp[0x0],r9
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80005f4e:	9a d9       	ld.uh	r9,sp[0xa]
80005f50:	b1 88       	lsr	r8,0x10
80005f52:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80005f56:	50 18       	stdsp	sp[0x4],r8
80005f58:	40 06       	lddsp	r6,sp[0x0]
80005f5a:	5c 86       	casts.h	r6
80005f5c:	10 97       	mov	r7,r8
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005f5e:	30 03       	mov	r3,0
80005f60:	06 92       	mov	r2,r3
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005f62:	e0 61 01 ff 	mov	r1,511
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005f66:	c1 a8       	rjmp	80005f9a <xgflash_get_message_data+0xba>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005f68:	e2 06 19 00 	cp.h	r6,r1
80005f6c:	e0 8b 00 0a 	brhi	80005f80 <xgflash_get_message_data+0xa0>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80005f70:	0a 9a       	mov	r10,r5
80005f72:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80005f76:	0e 9c       	mov	r12,r7
80005f78:	f0 1f 00 3d 	mcall	8000606c <xgflash_get_message_data+0x18c>
80005f7c:	30 06       	mov	r6,0
80005f7e:	c0 e8       	rjmp	80005f9a <xgflash_get_message_data+0xba>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80005f80:	0a 9a       	mov	r10,r5
80005f82:	e0 6b 02 00 	mov	r11,512
80005f86:	0e 9c       	mov	r12,r7
80005f88:	f0 1f 00 39 	mcall	8000606c <xgflash_get_message_data+0x18c>
					bytes_remained-=DF_DATA_SPACE_SIZE;
80005f8c:	ec c6 02 00 	sub	r6,r6,512
80005f90:	5c 86       	casts.h	r6
					data_address+=DF_DATA_SPACE_SIZE;
80005f92:	ee c7 fe 00 	sub	r7,r7,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80005f96:	ea c5 fe 00 	sub	r5,r5,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005f9a:	e6 06 19 00 	cp.h	r6,r3
80005f9e:	5f 19       	srne	r9
80005fa0:	58 0c       	cp.w	r12,0
80005fa2:	5f 08       	sreq	r8
80005fa4:	f3 e8 00 08 	and	r8,r9,r8
80005fa8:	e4 08 18 00 	cp.b	r8,r2
80005fac:	cd e1       	brne	80005f68 <xgflash_get_message_data+0x88>
						
				}
				//memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			
			if(erase)//erase the message
80005fae:	58 04       	cp.w	r4,0
80005fb0:	c1 e0       	breq	80005fec <xgflash_get_message_data+0x10c>
			{
				memset(str, 0xFF, sizeof(str));
80005fb2:	fa c7 ff f0 	sub	r7,sp,-16
80005fb6:	3f f8       	mov	r8,-1
80005fb8:	3f f9       	mov	r9,-1
80005fba:	af 29       	st.d	--r7,r8
				//reset:current_message_index and erase info
				current_message_index-=1;
80005fbc:	4a ac       	lddpc	r12,80006064 <xgflash_get_message_data+0x184>
80005fbe:	98 08       	ld.sh	r8,r12[0x0]
80005fc0:	20 18       	sub	r8,1
80005fc2:	b8 08       	st.h	r12[0x0],r8
				return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005fc4:	30 2a       	mov	r10,2
80005fc6:	30 6b       	mov	r11,6
80005fc8:	f0 1f 00 2a 	mcall	80006070 <xgflash_get_message_data+0x190>
				return_code = data_flash_write((U8 *)str, info_address, XG_MESSAGE_INFO_HEADER_LENGTH);
80005fcc:	30 8a       	mov	r10,8
80005fce:	00 9b       	mov	r11,r0
80005fd0:	0e 9c       	mov	r12,r7
80005fd2:	f0 1f 00 28 	mcall	80006070 <xgflash_get_message_data+0x190>
				
				//erase data and reset:current_save_message_offset
				return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
80005fd6:	30 8a       	mov	r10,8
80005fd8:	40 1b       	lddsp	r11,sp[0x4]
80005fda:	0e 9c       	mov	r12,r7
80005fdc:	f0 1f 00 25 	mcall	80006070 <xgflash_get_message_data+0x190>
				current_save_message_offset-=erase_length;//出错在这...如果掉线，未执行，则会出现存储碎片
80005fe0:	4a 58       	lddpc	r8,80006074 <xgflash_get_message_data+0x194>
80005fe2:	40 09       	lddsp	r9,sp[0x0]
80005fe4:	5c 79       	castu.h	r9
80005fe6:	70 0a       	ld.w	r10,r8[0x0]
80005fe8:	12 1a       	sub	r10,r9
80005fea:	91 0a       	st.w	r8[0x0],r10
				
			}
		
			xSemaphoreGive(xgflash_mutex);//unlock
80005fec:	49 c8       	lddpc	r8,8000605c <xgflash_get_message_data+0x17c>
80005fee:	70 0c       	ld.w	r12,r8[0x0]
80005ff0:	30 09       	mov	r9,0
80005ff2:	12 9a       	mov	r10,r9
80005ff4:	12 9b       	mov	r11,r9
80005ff6:	f0 1f 00 1d 	mcall	80006068 <xgflash_get_message_data+0x188>
80005ffa:	30 0c       	mov	r12,0
			return XG_OK;
80005ffc:	c2 c8       	rjmp	80006054 <xgflash_get_message_data+0x174>
		}
		else
		{
			log("ptr->numb : %x\n", ptr->numb);
80005ffe:	5c 78       	castu.h	r8
80006000:	1a d8       	st.w	--sp,r8
80006002:	49 ec       	lddpc	r12,80006078 <xgflash_get_message_data+0x198>
80006004:	f0 1f 00 1e 	mcall	8000607c <xgflash_get_message_data+0x19c>
			log("ptr->offset : %x\n", ptr->offset);
80006008:	fb 18 00 12 	ld.uh	r8,sp[18]
8000600c:	1a d8       	st.w	--sp,r8
8000600e:	49 dc       	lddpc	r12,80006080 <xgflash_get_message_data+0x1a0>
80006010:	f0 1f 00 1b 	mcall	8000607c <xgflash_get_message_data+0x19c>
			log("ptr->address : %x\n", ptr->address);
80006014:	fb 19 00 12 	ld.uh	r9,sp[18]
80006018:	fb 18 00 14 	ld.uh	r8,sp[20]
8000601c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80006020:	1a d8       	st.w	--sp,r8
80006022:	49 9c       	lddpc	r12,80006084 <xgflash_get_message_data+0x1a4>
80006024:	f0 1f 00 16 	mcall	8000607c <xgflash_get_message_data+0x19c>
			log("message_index : %x\n",message_index);
80006028:	1a d6       	st.w	--sp,r6
8000602a:	49 8c       	lddpc	r12,80006088 <xgflash_get_message_data+0x1a8>
8000602c:	f0 1f 00 14 	mcall	8000607c <xgflash_get_message_data+0x19c>
			
			xSemaphoreGive(xgflash_mutex);//unlock
80006030:	48 b8       	lddpc	r8,8000605c <xgflash_get_message_data+0x17c>
80006032:	70 0c       	ld.w	r12,r8[0x0]
80006034:	30 09       	mov	r9,0
80006036:	12 9a       	mov	r10,r9
80006038:	12 9b       	mov	r11,r9
8000603a:	f0 1f 00 0c 	mcall	80006068 <xgflash_get_message_data+0x188>
8000603e:	30 7c       	mov	r12,7
			return 7;
80006040:	2f cd       	sub	sp,-16
80006042:	c0 98       	rjmp	80006054 <xgflash_get_message_data+0x174>
		}
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80006044:	48 68       	lddpc	r8,8000605c <xgflash_get_message_data+0x17c>
80006046:	70 0c       	ld.w	r12,r8[0x0]
80006048:	30 09       	mov	r9,0
8000604a:	12 9a       	mov	r10,r9
8000604c:	12 9b       	mov	r11,r9
8000604e:	f0 1f 00 07 	mcall	80006068 <xgflash_get_message_data+0x188>
80006052:	30 6c       	mov	r12,6
	return XG_FLASH_ACTION_FAIL;
		
}
80006054:	2f cd       	sub	sp,-16
80006056:	d8 32       	popm	r0-r7,pc
80006058:	00 00       	add	r0,r0
8000605a:	0b 94       	ld.ub	r4,r5[0x1]
8000605c:	00 00       	add	r0,r0
8000605e:	0b 98       	ld.ub	r8,r5[0x1]
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	70 a0       	ld.w	r0,r8[0x28]
80006064:	00 00       	add	r0,r0
80006066:	0b a4       	ld.ub	r4,r5[0x2]
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	72 ac       	ld.w	r12,r9[0x28]
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	2e 28       	sub	r8,-30
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	30 60       	mov	r0,6
80006074:	00 00       	add	r0,r0
80006076:	05 48       	ld.w	r8,--r2
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	eb d4 80 00 	ldswp.w	r4,r5[0]
8000607e:	7e fc       	ld.w	r12,pc[0x3c]
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	eb e4 80 00 	sthh.w	r0[r0],r5:b,r4:b
80006086:	eb f8 80 00 	ld.wls	r8,r5[0x0]
8000608a:	ec 0c       	*unknown*

8000608c <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
8000608c:	d4 21       	pushm	r4-r7,lr
8000608e:	20 2d       	sub	sp,8
80006090:	18 96       	mov	r6,r12
80006092:	16 97       	mov	r7,r11
80006094:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80006096:	4d 68       	lddpc	r8,800061ec <xgflash_message_save+0x160>
80006098:	11 89       	ld.ub	r9,r8[0x0]
8000609a:	30 08       	mov	r8,0
8000609c:	f0 09 18 00 	cp.b	r9,r8
800060a0:	c0 31       	brne	800060a6 <xgflash_message_save+0x1a>
800060a2:	3f fc       	mov	r12,-1
800060a4:	ca 28       	rjmp	800061e8 <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
800060a6:	4d 38       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
800060a8:	70 0c       	ld.w	r12,r8[0x0]
800060aa:	30 09       	mov	r9,0
800060ac:	3f fa       	mov	r10,-1
800060ae:	12 9b       	mov	r11,r9
800060b0:	f0 1f 00 51 	mcall	800061f4 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
800060b4:	58 06       	cp.w	r6,0
800060b6:	5f 09       	sreq	r9
800060b8:	e0 68 02 00 	mov	r8,512
800060bc:	f0 07 19 00 	cp.h	r7,r8
800060c0:	5f b8       	srhi	r8
800060c2:	f3 e8 10 08 	or	r8,r9,r8
800060c6:	c0 30       	breq	800060cc <xgflash_message_save+0x40>
800060c8:	30 1c       	mov	r12,1
800060ca:	c8 f8       	rjmp	800061e8 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
800060cc:	0e 94       	mov	r4,r7
800060ce:	5c 74       	castu.h	r4
800060d0:	4c a9       	lddpc	r9,800061f8 <xgflash_message_save+0x16c>
800060d2:	72 08       	ld.w	r8,r9[0x0]
800060d4:	e8 08 00 08 	add	r8,r4,r8
800060d8:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
800060da:	e0 48 f0 00 	cp.w	r8,61440
800060de:	e0 88 00 07 	brls	800060ec <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
800060e2:	30 09       	mov	r9,0
800060e4:	4c 58       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
800060e6:	91 09       	st.w	r8[0x0],r9
800060e8:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
800060ea:	c7 f8       	rjmp	800061e8 <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
800060ec:	4c 48       	lddpc	r8,800061fc <xgflash_message_save+0x170>
800060ee:	70 0b       	ld.w	r11,r8[0x0]
800060f0:	e0 68 ff ff 	mov	r8,65535
800060f4:	ea 18 00 7f 	orh	r8,0x7f
800060f8:	10 3b       	cp.w	r11,r8
800060fa:	e0 88 00 10 	brls	8000611a <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
800060fe:	4c 1c       	lddpc	r12,80006200 <xgflash_message_save+0x174>
80006100:	f0 1f 00 41 	mcall	80006204 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
80006104:	30 0b       	mov	r11,0
80006106:	4b d8       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
80006108:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000610a:	4b a8       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
8000610c:	70 0c       	ld.w	r12,r8[0x0]
8000610e:	16 99       	mov	r9,r11
80006110:	16 9a       	mov	r10,r11
80006112:	f0 1f 00 3e 	mcall	80006208 <xgflash_message_save+0x17c>
80006116:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80006118:	c6 88       	rjmp	800061e8 <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000611a:	0e 9a       	mov	r10,r7
8000611c:	5c 7a       	castu.h	r10
8000611e:	0c 9c       	mov	r12,r6
80006120:	f0 1f 00 3b 	mcall	8000620c <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
80006124:	58 7c       	cp.w	r12,7
80006126:	c0 c0       	breq	8000613e <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
80006128:	30 0b       	mov	r11,0
8000612a:	4b 48       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
8000612c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000612e:	4b 18       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
80006130:	70 0c       	ld.w	r12,r8[0x0]
80006132:	16 99       	mov	r9,r11
80006134:	16 9a       	mov	r10,r11
80006136:	f0 1f 00 35 	mcall	80006208 <xgflash_message_save+0x17c>
8000613a:	30 6c       	mov	r12,6
		return XG_FLASH_ACTION_FAIL;
8000613c:	c5 68       	rjmp	800061e8 <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
8000613e:	4b 08       	lddpc	r8,800061fc <xgflash_message_save+0x170>
80006140:	70 09       	ld.w	r9,r8[0x0]
80006142:	12 04       	add	r4,r9
80006144:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
80006146:	1a d4       	st.w	--sp,r4
80006148:	4b 2c       	lddpc	r12,80006210 <xgflash_message_save+0x184>
8000614a:	f0 1f 00 2f 	mcall	80006204 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
8000614e:	2f fd       	sub	sp,-4
80006150:	30 18       	mov	r8,1
80006152:	f0 05 18 00 	cp.b	r5,r8
80006156:	c4 11       	brne	800061d8 <xgflash_message_save+0x14c>
	{
		current_message_index++;
80006158:	4a f9       	lddpc	r9,80006214 <xgflash_message_save+0x188>
8000615a:	92 08       	ld.sh	r8,r9[0x0]
8000615c:	2f f8       	sub	r8,-1
8000615e:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80006160:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80006162:	4a 69       	lddpc	r9,800061f8 <xgflash_message_save+0x16c>
80006164:	72 09       	ld.w	r9,r9[0x0]
80006166:	4a 6a       	lddpc	r10,800061fc <xgflash_message_save+0x170>
80006168:	74 0a       	ld.w	r10,r10[0x0]
8000616a:	12 1a       	sub	r10,r9
8000616c:	40 0b       	lddsp	r11,sp[0x0]
8000616e:	e0 1b 00 00 	andl	r11,0x0
80006172:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
80006176:	50 0b       	stdsp	sp[0x0],r11
80006178:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
8000617a:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
8000617c:	5c 78       	castu.h	r8
8000617e:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80006182:	e2 4b 00 00 	cp.w	r11,131072
80006186:	e0 88 00 10 	brls	800061a6 <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
8000618a:	4a 4c       	lddpc	r12,80006218 <xgflash_message_save+0x18c>
8000618c:	f0 1f 00 1e 	mcall	80006204 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
80006190:	30 0b       	mov	r11,0
80006192:	49 a8       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
80006194:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006196:	49 78       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
80006198:	70 0c       	ld.w	r12,r8[0x0]
8000619a:	16 99       	mov	r9,r11
8000619c:	16 9a       	mov	r10,r11
8000619e:	f0 1f 00 1b 	mcall	80006208 <xgflash_message_save+0x17c>
800061a2:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
800061a4:	c2 28       	rjmp	800061e8 <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
800061a6:	30 8a       	mov	r10,8
800061a8:	1a 9c       	mov	r12,sp
800061aa:	f0 1f 00 19 	mcall	8000620c <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800061ae:	30 2a       	mov	r10,2
800061b0:	30 6b       	mov	r11,6
800061b2:	49 9c       	lddpc	r12,80006214 <xgflash_message_save+0x188>
800061b4:	f0 1f 00 16 	mcall	8000620c <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
800061b8:	58 7c       	cp.w	r12,7
800061ba:	c0 c0       	breq	800061d2 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
800061bc:	30 0b       	mov	r11,0
800061be:	48 f8       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
800061c0:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
800061c2:	48 c8       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
800061c4:	70 0c       	ld.w	r12,r8[0x0]
800061c6:	16 99       	mov	r9,r11
800061c8:	16 9a       	mov	r10,r11
800061ca:	f0 1f 00 10 	mcall	80006208 <xgflash_message_save+0x17c>
800061ce:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
800061d0:	c0 c8       	rjmp	800061e8 <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
800061d2:	30 09       	mov	r9,0
800061d4:	48 98       	lddpc	r8,800061f8 <xgflash_message_save+0x16c>
800061d6:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
800061d8:	48 68       	lddpc	r8,800061f0 <xgflash_message_save+0x164>
800061da:	70 0c       	ld.w	r12,r8[0x0]
800061dc:	30 09       	mov	r9,0
800061de:	12 9a       	mov	r10,r9
800061e0:	12 9b       	mov	r11,r9
800061e2:	f0 1f 00 0a 	mcall	80006208 <xgflash_message_save+0x17c>
800061e6:	30 0c       	mov	r12,0
	return XG_OK;

}
800061e8:	2f ed       	sub	sp,-8
800061ea:	d8 22       	popm	r4-r7,pc
800061ec:	00 00       	add	r0,r0
800061ee:	0b 94       	ld.ub	r4,r5[0x1]
800061f0:	00 00       	add	r0,r0
800061f2:	0b 98       	ld.ub	r8,r5[0x1]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	70 a0       	ld.w	r0,r8[0x28]
800061f8:	00 00       	add	r0,r0
800061fa:	0b a0       	ld.ub	r0,r5[0x2]
800061fc:	00 00       	add	r0,r0
800061fe:	05 48       	ld.w	r8,--r2
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	ec 20 80 00 	sub	r0,819200
80006206:	7e fc       	ld.w	r12,pc[0x3c]
80006208:	80 00       	ld.sh	r0,r0[0x0]
8000620a:	72 ac       	ld.w	r12,r9[0x28]
8000620c:	80 00       	ld.sh	r0,r0[0x0]
8000620e:	30 60       	mov	r0,6
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	eb 24 00 00 	ld.sb	r4,r5[0]
80006216:	0b a4       	ld.ub	r4,r5[0x2]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	ec 50 eb cd 	cp.w	r0,912333

8000621c <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
8000621c:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80006220:	48 d8       	lddpc	r8,80006254 <xgflash_get_message_count+0x38>
80006222:	11 89       	ld.ub	r9,r8[0x0]
80006224:	30 08       	mov	r8,0
80006226:	f0 09 18 00 	cp.b	r9,r8
8000622a:	c0 31       	brne	80006230 <xgflash_get_message_count+0x14>
8000622c:	3f f7       	mov	r7,-1
8000622e:	c1 08       	rjmp	8000624e <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80006230:	48 a6       	lddpc	r6,80006258 <xgflash_get_message_count+0x3c>
80006232:	6c 0c       	ld.w	r12,r6[0x0]
80006234:	30 09       	mov	r9,0
80006236:	3f fa       	mov	r10,-1
80006238:	12 9b       	mov	r11,r9
8000623a:	f0 1f 00 09 	mcall	8000625c <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
8000623e:	48 98       	lddpc	r8,80006260 <xgflash_get_message_count+0x44>
80006240:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
80006242:	6c 0c       	ld.w	r12,r6[0x0]
80006244:	30 09       	mov	r9,0
80006246:	12 9a       	mov	r10,r9
80006248:	12 9b       	mov	r11,r9
8000624a:	f0 1f 00 07 	mcall	80006264 <xgflash_get_message_count+0x48>

	return return_value;
	
}
8000624e:	0e 9c       	mov	r12,r7
80006250:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006254:	00 00       	add	r0,r0
80006256:	0b 94       	ld.ub	r4,r5[0x1]
80006258:	00 00       	add	r0,r0
8000625a:	0b 98       	ld.ub	r8,r5[0x1]
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	70 a0       	ld.w	r0,r8[0x28]
80006260:	00 00       	add	r0,r0
80006262:	0b a4       	ld.ub	r4,r5[0x2]
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	72 ac       	ld.w	r12,r9[0x28]

80006268 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006268:	fe 68 14 00 	mov	r8,-125952
8000626c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000626e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006272:	91 09       	st.w	r8[0x0],r9
}
80006274:	5e fc       	retal	r12

80006276 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006276:	f8 08 16 05 	lsr	r8,r12,0x5
8000627a:	a9 68       	lsl	r8,0x8
8000627c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006280:	58 1b       	cp.w	r11,1
80006282:	c0 d0       	breq	8000629c <gpio_enable_module_pin+0x26>
80006284:	c0 63       	brcs	80006290 <gpio_enable_module_pin+0x1a>
80006286:	58 2b       	cp.w	r11,2
80006288:	c1 00       	breq	800062a8 <gpio_enable_module_pin+0x32>
8000628a:	58 3b       	cp.w	r11,3
8000628c:	c1 40       	breq	800062b4 <gpio_enable_module_pin+0x3e>
8000628e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006290:	30 19       	mov	r9,1
80006292:	f2 0c 09 49 	lsl	r9,r9,r12
80006296:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006298:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000629a:	c1 28       	rjmp	800062be <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000629c:	30 19       	mov	r9,1
8000629e:	f2 0c 09 49 	lsl	r9,r9,r12
800062a2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800062a4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800062a6:	c0 c8       	rjmp	800062be <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800062a8:	30 19       	mov	r9,1
800062aa:	f2 0c 09 49 	lsl	r9,r9,r12
800062ae:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800062b0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800062b2:	c0 68       	rjmp	800062be <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800062b4:	30 19       	mov	r9,1
800062b6:	f2 0c 09 49 	lsl	r9,r9,r12
800062ba:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800062bc:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800062be:	30 19       	mov	r9,1
800062c0:	f2 0c 09 4c 	lsl	r12,r9,r12
800062c4:	91 2c       	st.w	r8[0x8],r12
800062c6:	5e fd       	retal	0

800062c8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800062c8:	d4 21       	pushm	r4-r7,lr
800062ca:	18 97       	mov	r7,r12
800062cc:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800062ce:	58 0b       	cp.w	r11,0
800062d0:	c0 31       	brne	800062d6 <gpio_enable_module+0xe>
800062d2:	30 05       	mov	r5,0
800062d4:	c0 d8       	rjmp	800062ee <gpio_enable_module+0x26>
800062d6:	30 06       	mov	r6,0
800062d8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800062da:	6e 1b       	ld.w	r11,r7[0x4]
800062dc:	6e 0c       	ld.w	r12,r7[0x0]
800062de:	f0 1f 00 06 	mcall	800062f4 <gpio_enable_module+0x2c>
800062e2:	18 45       	or	r5,r12
		gpiomap++;
800062e4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800062e6:	2f f6       	sub	r6,-1
800062e8:	0c 34       	cp.w	r4,r6
800062ea:	fe 9b ff f8 	brhi	800062da <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800062ee:	0a 9c       	mov	r12,r5
800062f0:	d8 22       	popm	r4-r7,pc
800062f2:	00 00       	add	r0,r0
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	62 76       	ld.w	r6,r1[0x1c]

800062f8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800062f8:	f8 08 16 05 	lsr	r8,r12,0x5
800062fc:	a9 68       	lsl	r8,0x8
800062fe:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006302:	30 19       	mov	r9,1
80006304:	f2 0c 09 4c 	lsl	r12,r9,r12
80006308:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000630c:	91 1c       	st.w	r8[0x4],r12
}
8000630e:	5e fc       	retal	r12

80006310 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006310:	f8 08 16 05 	lsr	r8,r12,0x5
80006314:	a9 68       	lsl	r8,0x8
80006316:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000631a:	30 19       	mov	r9,1
8000631c:	f2 0c 09 4c 	lsl	r12,r9,r12
80006320:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006324:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006328:	91 1c       	st.w	r8[0x4],r12
}
8000632a:	5e fc       	retal	r12

8000632c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000632c:	f8 08 16 05 	lsr	r8,r12,0x5
80006330:	a9 68       	lsl	r8,0x8
80006332:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80006336:	30 19       	mov	r9,1
80006338:	f2 0c 09 4c 	lsl	r12,r9,r12
8000633c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80006340:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006344:	91 1c       	st.w	r8[0x4],r12
}
80006346:	5e fc       	retal	r12

80006348 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80006348:	c0 08       	rjmp	80006348 <_unhandled_interrupt>
8000634a:	d7 03       	nop

8000634c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000634c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006350:	49 99       	lddpc	r9,800063b4 <INTC_register_interrupt+0x68>
80006352:	f2 08 00 39 	add	r9,r9,r8<<0x3
80006356:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000635a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000635c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006360:	58 0a       	cp.w	r10,0
80006362:	c0 91       	brne	80006374 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006364:	49 59       	lddpc	r9,800063b8 <INTC_register_interrupt+0x6c>
80006366:	49 6a       	lddpc	r10,800063bc <INTC_register_interrupt+0x70>
80006368:	12 1a       	sub	r10,r9
8000636a:	fe 79 08 00 	mov	r9,-63488
8000636e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006372:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80006374:	58 1a       	cp.w	r10,1
80006376:	c0 a1       	brne	8000638a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006378:	49 09       	lddpc	r9,800063b8 <INTC_register_interrupt+0x6c>
8000637a:	49 2a       	lddpc	r10,800063c0 <INTC_register_interrupt+0x74>
8000637c:	12 1a       	sub	r10,r9
8000637e:	bf aa       	sbr	r10,0x1e
80006380:	fe 79 08 00 	mov	r9,-63488
80006384:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006388:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000638a:	58 2a       	cp.w	r10,2
8000638c:	c0 a1       	brne	800063a0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000638e:	48 b9       	lddpc	r9,800063b8 <INTC_register_interrupt+0x6c>
80006390:	48 da       	lddpc	r10,800063c4 <INTC_register_interrupt+0x78>
80006392:	12 1a       	sub	r10,r9
80006394:	bf ba       	sbr	r10,0x1f
80006396:	fe 79 08 00 	mov	r9,-63488
8000639a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000639e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800063a0:	48 69       	lddpc	r9,800063b8 <INTC_register_interrupt+0x6c>
800063a2:	48 aa       	lddpc	r10,800063c8 <INTC_register_interrupt+0x7c>
800063a4:	12 1a       	sub	r10,r9
800063a6:	ea 1a c0 00 	orh	r10,0xc000
800063aa:	fe 79 08 00 	mov	r9,-63488
800063ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800063b2:	5e fc       	retal	r12
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	ec e0 80 00 	ld.d	r0,r6[-32768]
800063ba:	de 00       	acall	0xe0
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	df 04       	*unknown*
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	df 12       	popm	r0-r3,r11-r12,lr-pc
800063c4:	80 00       	ld.sh	r0,r0[0x0]
800063c6:	df 20       	acall	0xf2
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	df 2e       	*unknown*

800063cc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800063cc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800063ce:	49 18       	lddpc	r8,80006410 <INTC_init_interrupts+0x44>
800063d0:	e3 b8 00 01 	mtsr	0x4,r8
800063d4:	49 0e       	lddpc	lr,80006414 <INTC_init_interrupts+0x48>
800063d6:	30 07       	mov	r7,0
800063d8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800063da:	49 0c       	lddpc	r12,80006418 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800063dc:	49 05       	lddpc	r5,8000641c <INTC_init_interrupts+0x50>
800063de:	10 15       	sub	r5,r8
800063e0:	fe 76 08 00 	mov	r6,-63488
800063e4:	c1 08       	rjmp	80006404 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800063e6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800063e8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800063ea:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800063ec:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800063f0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800063f2:	10 3a       	cp.w	r10,r8
800063f4:	fe 9b ff fc 	brhi	800063ec <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800063f8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800063fc:	2f f7       	sub	r7,-1
800063fe:	2f 8e       	sub	lr,-8
80006400:	59 37       	cp.w	r7,19
80006402:	c0 50       	breq	8000640c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006404:	7c 08       	ld.w	r8,lr[0x0]
80006406:	58 08       	cp.w	r8,0
80006408:	ce f1       	brne	800063e6 <INTC_init_interrupts+0x1a>
8000640a:	cf 7b       	rjmp	800063f8 <INTC_init_interrupts+0x2c>
8000640c:	d8 22       	popm	r4-r7,pc
8000640e:	00 00       	add	r0,r0
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	de 00       	acall	0xe0
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	ec e0 80 00 	ld.d	r0,r6[-32768]
8000641a:	63 48       	ld.w	r8,r1[0x50]
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	df 04       	*unknown*

80006420 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006420:	fe 78 08 00 	mov	r8,-63488
80006424:	e0 69 00 83 	mov	r9,131
80006428:	f2 0c 01 0c 	sub	r12,r9,r12
8000642c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006430:	f2 ca ff c0 	sub	r10,r9,-64
80006434:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006438:	58 08       	cp.w	r8,0
8000643a:	c0 21       	brne	8000643e <_get_interrupt_handler+0x1e>
8000643c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000643e:	f0 08 12 00 	clz	r8,r8
80006442:	48 5a       	lddpc	r10,80006454 <_get_interrupt_handler+0x34>
80006444:	f4 09 00 39 	add	r9,r10,r9<<0x3
80006448:	f0 08 11 1f 	rsub	r8,r8,31
8000644c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000644e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006452:	5e fc       	retal	r12
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	ec e0 78 a8 	ld.d	r0,r6[30888]

80006458 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006458:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000645a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000645e:	99 a8       	st.w	r12[0x28],r8
}
80006460:	5e fc       	retal	r12
80006462:	d7 03       	nop

80006464 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80006464:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80006466:	ec 5b bb 9f 	cp.w	r11,899999
8000646a:	e0 8b 00 04 	brhi	80006472 <pm_enable_osc0_crystal+0xe>
8000646e:	30 4b       	mov	r11,4
80006470:	c1 38       	rjmp	80006496 <pm_enable_osc0_crystal+0x32>
80006472:	e0 68 c6 bf 	mov	r8,50879
80006476:	ea 18 00 2d 	orh	r8,0x2d
8000647a:	10 3b       	cp.w	r11,r8
8000647c:	e0 8b 00 04 	brhi	80006484 <pm_enable_osc0_crystal+0x20>
80006480:	30 5b       	mov	r11,5
80006482:	c0 a8       	rjmp	80006496 <pm_enable_osc0_crystal+0x32>
80006484:	e0 68 12 00 	mov	r8,4608
80006488:	ea 18 00 7a 	orh	r8,0x7a
8000648c:	10 3b       	cp.w	r11,r8
8000648e:	f9 bb 03 06 	movlo	r11,6
80006492:	f9 bb 02 07 	movhs	r11,7
80006496:	f0 1f 00 02 	mcall	8000649c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000649a:	d8 02       	popm	pc
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	64 58       	ld.w	r8,r2[0x14]

800064a0 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800064a0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800064a2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800064a6:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800064a8:	78 08       	ld.w	r8,r12[0x0]
800064aa:	a3 a8       	sbr	r8,0x2
800064ac:	99 08       	st.w	r12[0x0],r8
}
800064ae:	5e fc       	retal	r12

800064b0 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800064b0:	79 58       	ld.w	r8,r12[0x54]
800064b2:	e2 18 00 80 	andl	r8,0x80,COH
800064b6:	cf d0       	breq	800064b0 <pm_wait_for_clk0_ready>
}
800064b8:	5e fc       	retal	r12
800064ba:	d7 03       	nop

800064bc <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800064bc:	eb cd 40 80 	pushm	r7,lr
800064c0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800064c2:	f0 1f 00 04 	mcall	800064d0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800064c6:	0e 9c       	mov	r12,r7
800064c8:	f0 1f 00 03 	mcall	800064d4 <pm_enable_clk0+0x18>
}
800064cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	64 a0       	ld.w	r0,r2[0x28]
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	64 b0       	ld.w	r0,r2[0x2c]

800064d8 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800064d8:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800064da:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800064de:	99 c8       	st.w	r12[0x30],r8
}
800064e0:	5e fc       	retal	r12
800064e2:	d7 03       	nop

800064e4 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800064e4:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800064e6:	30 1b       	mov	r11,1
800064e8:	f0 1f 00 02 	mcall	800064f0 <pm_enable_osc32_crystal+0xc>
}
800064ec:	d8 02       	popm	pc
800064ee:	00 00       	add	r0,r0
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	64 d8       	ld.w	r8,r2[0x34]

800064f4 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800064f4:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800064f6:	30 19       	mov	r9,1
800064f8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800064fc:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006500:	99 c8       	st.w	r12[0x30],r8
}
80006502:	5e fc       	retal	r12

80006504 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80006504:	79 58       	ld.w	r8,r12[0x54]
80006506:	e2 18 02 00 	andl	r8,0x200,COH
8000650a:	cf d0       	breq	80006504 <pm_wait_for_clk32_ready>
}
8000650c:	5e fc       	retal	r12
8000650e:	d7 03       	nop

80006510 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006510:	eb cd 40 80 	pushm	r7,lr
80006514:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80006516:	f0 1f 00 04 	mcall	80006524 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000651a:	0e 9c       	mov	r12,r7
8000651c:	f0 1f 00 03 	mcall	80006528 <pm_enable_clk32+0x18>
}
80006520:	e3 cd 80 80 	ldm	sp++,r7,pc
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	64 f4       	ld.w	r4,r2[0x3c]
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	65 04       	ld.w	r4,r2[0x40]

8000652c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000652c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006530:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80006534:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80006536:	09 f7       	ld.ub	r7,r4[0x7]
80006538:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000653c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006540:	09 b4       	ld.ub	r4,r4[0x3]
80006542:	08 96       	mov	r6,r4
80006544:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006548:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000654c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006550:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80006554:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006558:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000655c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006560:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80006564:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80006566:	79 58       	ld.w	r8,r12[0x54]
80006568:	e2 18 00 20 	andl	r8,0x20,COH
8000656c:	cf d0       	breq	80006566 <pm_cksel+0x3a>
}
8000656e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80006572 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80006572:	eb cd 40 80 	pushm	r7,lr
80006576:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006578:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000657a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000657e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006582:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006586:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000658a:	2f 8b       	sub	r11,-8
8000658c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006590:	e3 cd 80 80 	ldm	sp++,r7,pc

80006594 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006594:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006596:	2f 8b       	sub	r11,-8
80006598:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000659c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800065a0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800065a4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800065a8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800065ac:	d8 02       	popm	pc

800065ae <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800065ae:	2f 8b       	sub	r11,-8
800065b0:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800065b4:	a1 a8       	sbr	r8,0x0
800065b6:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800065ba:	5e fc       	retal	r12

800065bc <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800065bc:	79 58       	ld.w	r8,r12[0x54]
800065be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800065c2:	cf d0       	breq	800065bc <pm_wait_for_pll0_locked>
}
800065c4:	5e fc       	retal	r12

800065c6 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800065c6:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800065c8:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800065cc:	99 08       	st.w	r12[0x0],r8
}
800065ce:	5e fc       	retal	r12

800065d0 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800065d0:	eb cd 40 c0 	pushm	r6-r7,lr
800065d4:	18 97       	mov	r7,r12
800065d6:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800065d8:	f0 1f 00 06 	mcall	800065f0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800065dc:	0c 9b       	mov	r11,r6
800065de:	0e 9c       	mov	r12,r7
800065e0:	f0 1f 00 05 	mcall	800065f4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800065e4:	30 1b       	mov	r11,1
800065e6:	0e 9c       	mov	r12,r7
800065e8:	f0 1f 00 04 	mcall	800065f8 <pm_switch_to_osc0+0x28>
}
800065ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	64 64       	ld.w	r4,r2[0x18]
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	64 bc       	ld.w	r12,r2[0x2c]
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	65 c6       	ld.w	r6,r2[0x70]

800065fc <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800065fc:	78 0c       	ld.w	r12,r12[0x0]
}
800065fe:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80006602:	5e fc       	retal	r12

80006604 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80006604:	eb cd 40 c0 	pushm	r6-r7,lr
80006608:	18 97       	mov	r7,r12
8000660a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000660c:	0e 9c       	mov	r12,r7
8000660e:	f0 1f 00 06 	mcall	80006624 <rtc_set_value+0x20>
80006612:	cf d1       	brne	8000660c <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80006614:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006616:	0e 9c       	mov	r12,r7
80006618:	f0 1f 00 03 	mcall	80006624 <rtc_set_value+0x20>
8000661c:	cf d1       	brne	80006616 <rtc_set_value+0x12>
}
8000661e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006622:	00 00       	add	r0,r0
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	65 fc       	ld.w	r12,r2[0x7c]

80006628 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80006628:	eb cd 40 80 	pushm	r7,lr
8000662c:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000662e:	0e 9c       	mov	r12,r7
80006630:	f0 1f 00 06 	mcall	80006648 <rtc_enable+0x20>
80006634:	cf d1       	brne	8000662e <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80006636:	6e 08       	ld.w	r8,r7[0x0]
80006638:	a1 a8       	sbr	r8,0x0
8000663a:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000663c:	0e 9c       	mov	r12,r7
8000663e:	f0 1f 00 03 	mcall	80006648 <rtc_enable+0x20>
80006642:	cf d1       	brne	8000663c <rtc_enable+0x14>
}
80006644:	e3 cd 80 80 	ldm	sp++,r7,pc
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	65 fc       	ld.w	r12,r2[0x7c]

8000664c <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
8000664c:	30 18       	mov	r8,1
8000664e:	99 48       	st.w	r12[0x10],r8
}
80006650:	5e fc       	retal	r12
80006652:	d7 03       	nop

80006654 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80006654:	eb cd 40 c0 	pushm	r6-r7,lr
80006658:	18 97       	mov	r7,r12
8000665a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000665c:	0e 9c       	mov	r12,r7
8000665e:	f0 1f 00 06 	mcall	80006674 <rtc_set_top_value+0x20>
80006662:	cf d1       	brne	8000665c <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80006664:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006666:	0e 9c       	mov	r12,r7
80006668:	f0 1f 00 03 	mcall	80006674 <rtc_set_top_value+0x20>
8000666c:	cf d1       	brne	80006666 <rtc_set_top_value+0x12>
}
8000666e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006672:	00 00       	add	r0,r0
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	65 fc       	ld.w	r12,r2[0x7c]

80006678 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006678:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
8000667c:	e6 18 00 01 	andh	r8,0x1,COH
80006680:	c0 71       	brne	8000668e <rtc_clear_interrupt+0x16>
80006682:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006684:	30 18       	mov	r8,1
80006686:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006688:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000668a:	d5 03       	csrf	0x10
8000668c:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000668e:	30 18       	mov	r8,1
80006690:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006692:	78 78       	ld.w	r8,r12[0x1c]
80006694:	5e fc       	retal	r12
80006696:	d7 03       	nop

80006698 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006698:	eb cd 40 e0 	pushm	r5-r7,lr
8000669c:	18 97       	mov	r7,r12
8000669e:	16 96       	mov	r6,r11
800066a0:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800066a2:	30 18       	mov	r8,1
800066a4:	f0 0b 18 00 	cp.b	r11,r8
800066a8:	5f b9       	srhi	r9
800066aa:	30 f8       	mov	r8,15
800066ac:	f0 0a 18 00 	cp.b	r10,r8
800066b0:	5f b8       	srhi	r8
800066b2:	f3 e8 10 08 	or	r8,r9,r8
800066b6:	c0 30       	breq	800066bc <rtc_init+0x24>
800066b8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800066bc:	30 18       	mov	r8,1
800066be:	f0 0b 18 00 	cp.b	r11,r8
800066c2:	c0 a1       	brne	800066d6 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800066c4:	fe 7c 0c 00 	mov	r12,-62464
800066c8:	f0 1f 00 0f 	mcall	80006704 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800066cc:	30 0b       	mov	r11,0
800066ce:	fe 7c 0c 00 	mov	r12,-62464
800066d2:	f0 1f 00 0e 	mcall	80006708 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800066d6:	0e 9c       	mov	r12,r7
800066d8:	f0 1f 00 0d 	mcall	8000670c <rtc_init+0x74>
800066dc:	cf d1       	brne	800066d6 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800066de:	a3 76       	lsl	r6,0x3
800066e0:	b1 a6       	sbr	r6,0x10
800066e2:	ed e5 10 85 	or	r5,r6,r5<<0x8
800066e6:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800066e8:	0e 9c       	mov	r12,r7
800066ea:	f0 1f 00 09 	mcall	8000670c <rtc_init+0x74>
800066ee:	cf d1       	brne	800066e8 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800066f0:	30 0b       	mov	r11,0
800066f2:	0e 9c       	mov	r12,r7
800066f4:	f0 1f 00 07 	mcall	80006710 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800066f8:	3f fb       	mov	r11,-1
800066fa:	0e 9c       	mov	r12,r7
800066fc:	f0 1f 00 06 	mcall	80006714 <rtc_init+0x7c>
80006700:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	64 e4       	ld.w	r4,r2[0x38]
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	65 10       	ld.w	r0,r2[0x44]
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	65 fc       	ld.w	r12,r2[0x7c]
80006710:	80 00       	ld.sh	r0,r0[0x0]
80006712:	66 04       	ld.w	r4,r3[0x0]
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	66 54       	ld.w	r4,r3[0x14]

80006718 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80006718:	f8 c8 00 01 	sub	r8,r12,1
8000671c:	f0 0b 00 0b 	add	r11,r8,r11
80006720:	f6 0c 0d 0a 	divu	r10,r11,r12
80006724:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80006726:	f4 c8 00 01 	sub	r8,r10,1
8000672a:	e0 48 00 fe 	cp.w	r8,254
8000672e:	e0 88 00 03 	brls	80006734 <getBaudDiv+0x1c>
80006732:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80006734:	5c 8c       	casts.h	r12
}
80006736:	5e fc       	retal	r12

80006738 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80006738:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000673c:	30 18       	mov	r8,1
8000673e:	f0 09 18 00 	cp.b	r9,r8
80006742:	e0 88 00 04 	brls	8000674a <spi_initMaster+0x12>
80006746:	30 2c       	mov	r12,2
80006748:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000674a:	e0 68 00 80 	mov	r8,128
8000674e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80006750:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80006752:	30 19       	mov	r9,1
80006754:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80006758:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000675c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80006760:	30 09       	mov	r9,0
80006762:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80006766:	30 fa       	mov	r10,15
80006768:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000676c:	99 18       	st.w	r12[0x4],r8
8000676e:	5e f9       	retal	r9

80006770 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80006770:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80006772:	30 18       	mov	r8,1
80006774:	f0 0b 18 00 	cp.b	r11,r8
80006778:	5f be       	srhi	lr
8000677a:	f0 0a 18 00 	cp.b	r10,r8
8000677e:	5f b8       	srhi	r8
80006780:	fd e8 10 08 	or	r8,lr,r8
80006784:	c0 30       	breq	8000678a <spi_selectionMode+0x1a>
80006786:	30 2c       	mov	r12,2
80006788:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000678a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000678c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006790:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006794:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006798:	99 18       	st.w	r12[0x4],r8
8000679a:	d8 0a       	popm	pc,r12=0

8000679c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000679c:	30 18       	mov	r8,1
8000679e:	99 08       	st.w	r12[0x0],r8
}
800067a0:	5e fc       	retal	r12

800067a2 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800067a2:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800067a6:	c0 58       	rjmp	800067b0 <spi_write+0xe>
		if (!timeout--) {
800067a8:	58 08       	cp.w	r8,0
800067aa:	c0 21       	brne	800067ae <spi_write+0xc>
800067ac:	5e ff       	retal	1
800067ae:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800067b0:	78 49       	ld.w	r9,r12[0x10]
800067b2:	e2 19 00 02 	andl	r9,0x2,COH
800067b6:	cf 90       	breq	800067a8 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800067b8:	5c 7b       	castu.h	r11
800067ba:	99 3b       	st.w	r12[0xc],r11
800067bc:	5e fd       	retal	0

800067be <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800067be:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800067c2:	c0 58       	rjmp	800067cc <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800067c4:	58 08       	cp.w	r8,0
800067c6:	c0 21       	brne	800067ca <spi_read+0xc>
800067c8:	5e ff       	retal	1
800067ca:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800067cc:	78 49       	ld.w	r9,r12[0x10]
800067ce:	e2 19 02 01 	andl	r9,0x201,COH
800067d2:	e0 49 02 01 	cp.w	r9,513
800067d6:	cf 71       	brne	800067c4 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800067d8:	78 28       	ld.w	r8,r12[0x8]
800067da:	b6 08       	st.h	r11[0x0],r8
800067dc:	5e fd       	retal	0
800067de:	d7 03       	nop

800067e0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800067e0:	eb cd 40 f8 	pushm	r3-r7,lr
800067e4:	18 95       	mov	r5,r12
800067e6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800067e8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800067ec:	30 38       	mov	r8,3
800067ee:	f0 06 18 00 	cp.b	r6,r8
800067f2:	e0 8b 00 5e 	brhi	800068ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800067f6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800067fa:	30 18       	mov	r8,1
800067fc:	f0 04 18 00 	cp.b	r4,r8
80006800:	e0 8b 00 57 	brhi	800068ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006804:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006808:	30 78       	mov	r8,7
8000680a:	f0 03 18 00 	cp.b	r3,r8
8000680e:	e0 88 00 50 	brls	800068ae <spi_setupChipReg+0xce>
80006812:	31 08       	mov	r8,16
80006814:	f0 03 18 00 	cp.b	r3,r8
80006818:	e0 8b 00 4b 	brhi	800068ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000681c:	14 9b       	mov	r11,r10
8000681e:	6e 1c       	ld.w	r12,r7[0x4]
80006820:	f0 1f 00 26 	mcall	800068b8 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80006824:	c4 55       	brlt	800068ae <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80006826:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80006828:	ec 09 16 01 	lsr	r9,r6,0x1
8000682c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80006830:	ec 16 00 01 	eorl	r6,0x1
80006834:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80006838:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000683c:	20 83       	sub	r3,8
8000683e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80006842:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80006846:	ef 39 00 09 	ld.ub	r9,r7[9]
8000684a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000684e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80006852:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80006856:	0f 89       	ld.ub	r9,r7[0x0]
80006858:	30 1a       	mov	r10,1
8000685a:	f4 09 18 00 	cp.b	r9,r10
8000685e:	c0 d0       	breq	80006878 <spi_setupChipReg+0x98>
80006860:	c0 a3       	brcs	80006874 <spi_setupChipReg+0x94>
80006862:	30 2a       	mov	r10,2
80006864:	f4 09 18 00 	cp.b	r9,r10
80006868:	c0 a0       	breq	8000687c <spi_setupChipReg+0x9c>
8000686a:	30 3a       	mov	r10,3
8000686c:	f4 09 18 00 	cp.b	r9,r10
80006870:	c1 f1       	brne	800068ae <spi_setupChipReg+0xce>
80006872:	c0 78       	rjmp	80006880 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80006874:	8b c8       	st.w	r5[0x30],r8
		break;
80006876:	c0 68       	rjmp	80006882 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80006878:	8b d8       	st.w	r5[0x34],r8
		break;
8000687a:	c0 48       	rjmp	80006882 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000687c:	8b e8       	st.w	r5[0x38],r8
		break;
8000687e:	c0 28       	rjmp	80006882 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006880:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006882:	48 f8       	lddpc	r8,800068bc <spi_setupChipReg+0xdc>
80006884:	70 08       	ld.w	r8,r8[0x0]
80006886:	58 08       	cp.w	r8,0
80006888:	c1 61       	brne	800068b4 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000688a:	30 0b       	mov	r11,0
8000688c:	30 1c       	mov	r12,1
8000688e:	f0 1f 00 0d 	mcall	800068c0 <spi_setupChipReg+0xe0>
80006892:	48 b8       	lddpc	r8,800068bc <spi_setupChipReg+0xdc>
80006894:	91 0c       	st.w	r8[0x0],r12
80006896:	58 0c       	cp.w	r12,0
80006898:	c0 a0       	breq	800068ac <spi_setupChipReg+0xcc>
8000689a:	30 09       	mov	r9,0
8000689c:	12 9a       	mov	r10,r9
8000689e:	12 9b       	mov	r11,r9
800068a0:	f0 1f 00 09 	mcall	800068c4 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800068a4:	48 68       	lddpc	r8,800068bc <spi_setupChipReg+0xdc>
800068a6:	70 08       	ld.w	r8,r8[0x0]
800068a8:	58 08       	cp.w	r8,0
800068aa:	c0 51       	brne	800068b4 <spi_setupChipReg+0xd4>
800068ac:	c0 08       	rjmp	800068ac <spi_setupChipReg+0xcc>
800068ae:	30 2c       	mov	r12,2
800068b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800068b4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	67 18       	ld.w	r8,r3[0x44]
800068bc:	00 00       	add	r0,r0
800068be:	9d fc       	st.w	lr[0x3c],r12
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	74 04       	ld.w	r4,r10[0x0]
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	72 ac       	ld.w	r12,r9[0x28]

800068c8 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800068c8:	d4 01       	pushm	lr
800068ca:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800068ce:	c0 58       	rjmp	800068d8 <spi_unselectChip+0x10>
		if (!timeout--) {
800068d0:	58 08       	cp.w	r8,0
800068d2:	c0 21       	brne	800068d6 <spi_unselectChip+0xe>
800068d4:	da 0a       	popm	pc,r12=1
800068d6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800068d8:	78 49       	ld.w	r9,r12[0x10]
800068da:	e2 19 02 00 	andl	r9,0x200,COH
800068de:	cf 90       	breq	800068d0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800068e0:	78 18       	ld.w	r8,r12[0x4]
800068e2:	ea 18 00 0f 	orh	r8,0xf
800068e6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800068e8:	fc 18 01 00 	movh	r8,0x100
800068ec:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800068ee:	30 09       	mov	r9,0
800068f0:	12 9a       	mov	r10,r9
800068f2:	12 9b       	mov	r11,r9
800068f4:	48 38       	lddpc	r8,80006900 <spi_unselectChip+0x38>
800068f6:	70 0c       	ld.w	r12,r8[0x0]
800068f8:	f0 1f 00 03 	mcall	80006904 <spi_unselectChip+0x3c>
800068fc:	d8 0a       	popm	pc,r12=0
800068fe:	00 00       	add	r0,r0
80006900:	00 00       	add	r0,r0
80006902:	9d fc       	st.w	lr[0x3c],r12
80006904:	80 00       	ld.sh	r0,r0[0x0]
80006906:	72 ac       	ld.w	r12,r9[0x28]

80006908 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006908:	eb cd 40 f8 	pushm	r3-r7,lr
8000690c:	18 94       	mov	r4,r12
8000690e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006910:	49 a6       	lddpc	r6,80006978 <spi_selectChip+0x70>
80006912:	30 07       	mov	r7,0
80006914:	31 45       	mov	r5,20
80006916:	0e 99       	mov	r9,r7
80006918:	0a 9a       	mov	r10,r5
8000691a:	0e 9b       	mov	r11,r7
8000691c:	6c 0c       	ld.w	r12,r6[0x0]
8000691e:	f0 1f 00 18 	mcall	8000697c <spi_selectChip+0x74>
80006922:	cf a0       	breq	80006916 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006924:	68 18       	ld.w	r8,r4[0x4]
80006926:	ea 18 00 0f 	orh	r8,0xf
8000692a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000692c:	68 18       	ld.w	r8,r4[0x4]
8000692e:	e2 18 00 04 	andl	r8,0x4,COH
80006932:	c1 10       	breq	80006954 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80006934:	30 e8       	mov	r8,14
80006936:	f0 03 18 00 	cp.b	r3,r8
8000693a:	e0 8b 00 1c 	brhi	80006972 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000693e:	68 19       	ld.w	r9,r4[0x4]
80006940:	e6 08 15 10 	lsl	r8,r3,0x10
80006944:	ea 18 ff f0 	orh	r8,0xfff0
80006948:	e8 18 ff ff 	orl	r8,0xffff
8000694c:	12 68       	and	r8,r9
8000694e:	89 18       	st.w	r4[0x4],r8
80006950:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80006954:	30 38       	mov	r8,3
80006956:	f0 03 18 00 	cp.b	r3,r8
8000695a:	e0 8b 00 0c 	brhi	80006972 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000695e:	68 19       	ld.w	r9,r4[0x4]
80006960:	2f 03       	sub	r3,-16
80006962:	30 18       	mov	r8,1
80006964:	f0 03 09 48 	lsl	r8,r8,r3
80006968:	5c d8       	com	r8
8000696a:	12 68       	and	r8,r9
8000696c:	89 18       	st.w	r4[0x4],r8
8000696e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006972:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80006974:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006978:	00 00       	add	r0,r0
8000697a:	9d fc       	st.w	lr[0x3c],r12
8000697c:	80 00       	ld.sh	r0,r0[0x0]
8000697e:	70 a0       	ld.w	r0,r8[0x28]

80006980 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006980:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006982:	f6 08 15 04 	lsl	r8,r11,0x4
80006986:	14 38       	cp.w	r8,r10
80006988:	f9 b8 08 10 	movls	r8,16
8000698c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006990:	f0 0b 02 4b 	mul	r11,r8,r11
80006994:	f6 09 16 01 	lsr	r9,r11,0x1
80006998:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000699c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800069a0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800069a4:	f2 cb 00 01 	sub	r11,r9,1
800069a8:	e0 4b ff fe 	cp.w	r11,65534
800069ac:	e0 88 00 03 	brls	800069b2 <usart_set_async_baudrate+0x32>
800069b0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800069b2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800069b4:	e8 6e 00 00 	mov	lr,524288
800069b8:	59 08       	cp.w	r8,16
800069ba:	fc 08 17 10 	movne	r8,lr
800069be:	f9 b8 00 00 	moveq	r8,0
800069c2:	e4 1b ff f7 	andh	r11,0xfff7
800069c6:	e0 1b fe cf 	andl	r11,0xfecf
800069ca:	16 48       	or	r8,r11
800069cc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800069ce:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800069d2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800069d6:	99 89       	st.w	r12[0x20],r9
800069d8:	d8 0a       	popm	pc,r12=0

800069da <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800069da:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800069dc:	e2 18 00 02 	andl	r8,0x2,COH
800069e0:	c0 31       	brne	800069e6 <usart_write_char+0xc>
800069e2:	30 2c       	mov	r12,2
800069e4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800069e6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800069ea:	99 7b       	st.w	r12[0x1c],r11
800069ec:	5e fd       	retal	0
800069ee:	d7 03       	nop

800069f0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800069f0:	eb cd 40 e0 	pushm	r5-r7,lr
800069f4:	18 96       	mov	r6,r12
800069f6:	16 95       	mov	r5,r11
800069f8:	e0 67 27 0f 	mov	r7,9999
800069fc:	c0 68       	rjmp	80006a08 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800069fe:	58 07       	cp.w	r7,0
80006a00:	c0 31       	brne	80006a06 <usart_putchar+0x16>
80006a02:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006a06:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006a08:	0a 9b       	mov	r11,r5
80006a0a:	0c 9c       	mov	r12,r6
80006a0c:	f0 1f 00 03 	mcall	80006a18 <usart_putchar+0x28>
80006a10:	cf 71       	brne	800069fe <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006a16:	00 00       	add	r0,r0
80006a18:	80 00       	ld.sh	r0,r0[0x0]
80006a1a:	69 da       	ld.w	r10,r4[0x74]

80006a1c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006a1c:	78 58       	ld.w	r8,r12[0x14]
80006a1e:	e2 18 00 e0 	andl	r8,0xe0,COH
80006a22:	c0 30       	breq	80006a28 <usart_read_char+0xc>
80006a24:	30 4c       	mov	r12,4
80006a26:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006a28:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006a2a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006a2e:	c0 31       	brne	80006a34 <usart_read_char+0x18>
80006a30:	30 3c       	mov	r12,3
80006a32:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006a34:	78 68       	ld.w	r8,r12[0x18]
80006a36:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006a3a:	97 08       	st.w	r11[0x0],r8
80006a3c:	5e fd       	retal	0
80006a3e:	d7 03       	nop

80006a40 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006a40:	eb cd 40 c0 	pushm	r6-r7,lr
80006a44:	20 1d       	sub	sp,4
80006a46:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006a48:	1a 97       	mov	r7,sp
80006a4a:	1a 9b       	mov	r11,sp
80006a4c:	0c 9c       	mov	r12,r6
80006a4e:	f0 1f 00 07 	mcall	80006a68 <usart_getchar+0x28>
80006a52:	58 3c       	cp.w	r12,3
80006a54:	cf b0       	breq	80006a4a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006a56:	58 4c       	cp.w	r12,4
80006a58:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006a5c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006a60:	2f fd       	sub	sp,-4
80006a62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a66:	00 00       	add	r0,r0
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	6a 1c       	ld.w	r12,r5[0x4]

80006a6c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006a6c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a70:	18 96       	mov	r6,r12
80006a72:	16 97       	mov	r7,r11
  while (*string != '\0')
80006a74:	17 8b       	ld.ub	r11,r11[0x0]
80006a76:	58 0b       	cp.w	r11,0
80006a78:	c0 80       	breq	80006a88 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006a7a:	2f f7       	sub	r7,-1
80006a7c:	0c 9c       	mov	r12,r6
80006a7e:	f0 1f 00 04 	mcall	80006a8c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006a82:	0f 8b       	ld.ub	r11,r7[0x0]
80006a84:	58 0b       	cp.w	r11,0
80006a86:	cf a1       	brne	80006a7a <usart_write_line+0xe>
80006a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	69 f0       	ld.w	r0,r4[0x7c]

80006a90 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006a90:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006a94:	e6 18 00 01 	andh	r8,0x1,COH
80006a98:	c0 71       	brne	80006aa6 <usart_reset+0x16>
80006a9a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006a9c:	3f f8       	mov	r8,-1
80006a9e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006aa0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006aa2:	d5 03       	csrf	0x10
80006aa4:	c0 48       	rjmp	80006aac <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006aa6:	3f f8       	mov	r8,-1
80006aa8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006aaa:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006aac:	30 08       	mov	r8,0
80006aae:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006ab0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006ab2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006ab4:	ea 68 61 0c 	mov	r8,680204
80006ab8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006aba:	5e fc       	retal	r12

80006abc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006abc:	eb cd 40 e0 	pushm	r5-r7,lr
80006ac0:	18 96       	mov	r6,r12
80006ac2:	16 97       	mov	r7,r11
80006ac4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006ac6:	f0 1f 00 2f 	mcall	80006b80 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006aca:	58 07       	cp.w	r7,0
80006acc:	c5 80       	breq	80006b7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006ace:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006ad0:	30 49       	mov	r9,4
80006ad2:	f2 08 18 00 	cp.b	r8,r9
80006ad6:	e0 88 00 53 	brls	80006b7c <usart_init_rs232+0xc0>
80006ada:	30 99       	mov	r9,9
80006adc:	f2 08 18 00 	cp.b	r8,r9
80006ae0:	e0 8b 00 4e 	brhi	80006b7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006ae4:	0f d9       	ld.ub	r9,r7[0x5]
80006ae6:	30 78       	mov	r8,7
80006ae8:	f0 09 18 00 	cp.b	r9,r8
80006aec:	e0 8b 00 48 	brhi	80006b7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006af0:	8e 39       	ld.sh	r9,r7[0x6]
80006af2:	e0 68 01 01 	mov	r8,257
80006af6:	f0 09 19 00 	cp.h	r9,r8
80006afa:	e0 8b 00 41 	brhi	80006b7c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006afe:	ef 39 00 08 	ld.ub	r9,r7[8]
80006b02:	30 38       	mov	r8,3
80006b04:	f0 09 18 00 	cp.b	r9,r8
80006b08:	e0 8b 00 3a 	brhi	80006b7c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006b0c:	0a 9a       	mov	r10,r5
80006b0e:	6e 0b       	ld.w	r11,r7[0x0]
80006b10:	0c 9c       	mov	r12,r6
80006b12:	f0 1f 00 1d 	mcall	80006b84 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b16:	58 1c       	cp.w	r12,1
80006b18:	c3 20       	breq	80006b7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006b1a:	0f c8       	ld.ub	r8,r7[0x4]
80006b1c:	30 99       	mov	r9,9
80006b1e:	f2 08 18 00 	cp.b	r8,r9
80006b22:	c0 51       	brne	80006b2c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006b24:	6c 18       	ld.w	r8,r6[0x4]
80006b26:	b1 b8       	sbr	r8,0x11
80006b28:	8d 18       	st.w	r6[0x4],r8
80006b2a:	c0 68       	rjmp	80006b36 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006b2c:	6c 19       	ld.w	r9,r6[0x4]
80006b2e:	20 58       	sub	r8,5
80006b30:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006b34:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006b36:	6c 19       	ld.w	r9,r6[0x4]
80006b38:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006b3c:	0f d8       	ld.ub	r8,r7[0x5]
80006b3e:	a9 78       	lsl	r8,0x9
80006b40:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006b44:	12 48       	or	r8,r9
80006b46:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006b48:	8e 38       	ld.sh	r8,r7[0x6]
80006b4a:	30 29       	mov	r9,2
80006b4c:	f2 08 19 00 	cp.h	r8,r9
80006b50:	e0 88 00 09 	brls	80006b62 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006b54:	6c 18       	ld.w	r8,r6[0x4]
80006b56:	ad b8       	sbr	r8,0xd
80006b58:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006b5a:	8e b8       	ld.uh	r8,r7[0x6]
80006b5c:	20 28       	sub	r8,2
80006b5e:	8d a8       	st.w	r6[0x28],r8
80006b60:	c0 68       	rjmp	80006b6c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006b62:	6c 19       	ld.w	r9,r6[0x4]
80006b64:	5c 78       	castu.h	r8
80006b66:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006b6a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006b6c:	6c 18       	ld.w	r8,r6[0x4]
80006b6e:	e0 18 ff f0 	andl	r8,0xfff0
80006b72:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006b74:	35 08       	mov	r8,80
80006b76:	8d 08       	st.w	r6[0x0],r8
80006b78:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006b7c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	6a 90       	ld.w	r0,r5[0x24]
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	69 80       	ld.w	r0,r4[0x60]

80006b88 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006b88:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006b8c:	fe c0 8d 8c 	sub	r0,pc,-29300

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006b90:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006b94:	d5 53       	csrf	0x15
  cp      r0, r1
80006b96:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006b98:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006b9c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006b9e:	c0 62       	brcc	80006baa <idata_load_loop_end>
  cp      r0, r1
80006ba0:	48 92       	lddpc	r2,80006bc4 <udata_clear_loop_end+0x4>

80006ba2 <idata_load_loop>:
  brlo    idata_load_loop
80006ba2:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006ba4:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006ba6:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006ba8:	cf d3       	brcs	80006ba2 <idata_load_loop>

80006baa <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006baa:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006bae:	e0 61 9e 10 	mov	r1,40464
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006bb2:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006bb4:	c0 62       	brcc	80006bc0 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006bb6:	30 02       	mov	r2,0
80006bb8:	30 03       	mov	r3,0

80006bba <udata_clear_loop>:
80006bba:	a1 22       	st.d	r0++,r2
80006bbc:	02 30       	cp.w	r0,r1
80006bbe:	cf e3       	brcs	80006bba <udata_clear_loop>

80006bc0 <udata_clear_loop_end>:
80006bc0:	fe cf e9 10 	sub	pc,pc,-5872
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	f6 10 f8 c8 	memc	-7392,0x1

80006bc8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006bc8:	f8 c8 ff f8 	sub	r8,r12,-8
80006bcc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006bce:	3f f9       	mov	r9,-1
80006bd0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006bd2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006bd4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006bd6:	30 08       	mov	r8,0
80006bd8:	99 08       	st.w	r12[0x0],r8
}
80006bda:	5e fc       	retal	r12

80006bdc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006bdc:	30 08       	mov	r8,0
80006bde:	99 48       	st.w	r12[0x10],r8
}
80006be0:	5e fc       	retal	r12

80006be2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006be2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006be4:	70 19       	ld.w	r9,r8[0x4]
80006be6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006be8:	78 19       	ld.w	r9,r12[0x4]
80006bea:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006bec:	70 19       	ld.w	r9,r8[0x4]
80006bee:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006bf0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006bf2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006bf4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006bf6:	78 08       	ld.w	r8,r12[0x0]
80006bf8:	2f f8       	sub	r8,-1
80006bfa:	99 08       	st.w	r12[0x0],r8
}
80006bfc:	5e fc       	retal	r12

80006bfe <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006bfe:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006c00:	5b fa       	cp.w	r10,-1
80006c02:	c0 31       	brne	80006c08 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006c04:	78 48       	ld.w	r8,r12[0x10]
80006c06:	c0 c8       	rjmp	80006c1e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006c08:	f8 c8 ff f8 	sub	r8,r12,-8
80006c0c:	70 19       	ld.w	r9,r8[0x4]
80006c0e:	72 09       	ld.w	r9,r9[0x0]
80006c10:	12 3a       	cp.w	r10,r9
80006c12:	c0 63       	brcs	80006c1e <vListInsert+0x20>
80006c14:	70 18       	ld.w	r8,r8[0x4]
80006c16:	70 19       	ld.w	r9,r8[0x4]
80006c18:	72 09       	ld.w	r9,r9[0x0]
80006c1a:	12 3a       	cp.w	r10,r9
80006c1c:	cf c2       	brcc	80006c14 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006c1e:	70 19       	ld.w	r9,r8[0x4]
80006c20:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006c22:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006c24:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006c26:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006c28:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006c2a:	78 08       	ld.w	r8,r12[0x0]
80006c2c:	2f f8       	sub	r8,-1
80006c2e:	99 08       	st.w	r12[0x0],r8
}
80006c30:	5e fc       	retal	r12

80006c32 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006c32:	78 18       	ld.w	r8,r12[0x4]
80006c34:	78 29       	ld.w	r9,r12[0x8]
80006c36:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006c38:	78 28       	ld.w	r8,r12[0x8]
80006c3a:	78 19       	ld.w	r9,r12[0x4]
80006c3c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006c3e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006c40:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006c42:	18 39       	cp.w	r9,r12
80006c44:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006c48:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006c4c:	30 09       	mov	r9,0
80006c4e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006c50:	70 09       	ld.w	r9,r8[0x0]
80006c52:	20 19       	sub	r9,1
80006c54:	91 09       	st.w	r8[0x0],r9
}
80006c56:	5e fc       	retal	r12

80006c58 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006c58:	e0 68 08 08 	mov	r8,2056
80006c5c:	ea 18 08 08 	orh	r8,0x808
80006c60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006c62:	e0 68 09 09 	mov	r8,2313
80006c66:	ea 18 09 09 	orh	r8,0x909
80006c6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006c6c:	e0 68 0a 0a 	mov	r8,2570
80006c70:	ea 18 0a 0a 	orh	r8,0xa0a
80006c74:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006c76:	e0 68 0b 0b 	mov	r8,2827
80006c7a:	ea 18 0b 0b 	orh	r8,0xb0b
80006c7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006c80:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006c82:	e0 68 be ef 	mov	r8,48879
80006c86:	ea 18 de ad 	orh	r8,0xdead
80006c8a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006c8c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006c8e:	fc 18 00 40 	movh	r8,0x40
80006c92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006c94:	e0 68 00 ff 	mov	r8,255
80006c98:	ea 18 ff 00 	orh	r8,0xff00
80006c9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006c9e:	e0 68 01 01 	mov	r8,257
80006ca2:	ea 18 01 01 	orh	r8,0x101
80006ca6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006ca8:	e0 68 02 02 	mov	r8,514
80006cac:	ea 18 02 02 	orh	r8,0x202
80006cb0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006cb2:	e0 68 03 03 	mov	r8,771
80006cb6:	ea 18 03 03 	orh	r8,0x303
80006cba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006cbc:	e0 68 04 04 	mov	r8,1028
80006cc0:	ea 18 04 04 	orh	r8,0x404
80006cc4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006cc6:	e0 68 05 05 	mov	r8,1285
80006cca:	ea 18 05 05 	orh	r8,0x505
80006cce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006cd0:	e0 68 06 06 	mov	r8,1542
80006cd4:	ea 18 06 06 	orh	r8,0x606
80006cd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006cda:	e0 68 07 07 	mov	r8,1799
80006cde:	ea 18 07 07 	orh	r8,0x707
80006ce2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006ce4:	30 08       	mov	r8,0
80006ce6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006ce8:	5e fc       	retal	r12
80006cea:	d7 03       	nop

80006cec <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006cec:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006cee:	48 38       	lddpc	r8,80006cf8 <vPortEnterCritical+0xc>
80006cf0:	70 09       	ld.w	r9,r8[0x0]
80006cf2:	2f f9       	sub	r9,-1
80006cf4:	91 09       	st.w	r8[0x0],r9
}
80006cf6:	5e fc       	retal	r12
80006cf8:	00 00       	add	r0,r0
80006cfa:	05 4c       	ld.w	r12,--r2

80006cfc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006cfc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006cfe:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006d00:	30 0a       	mov	r10,0
80006d02:	14 9b       	mov	r11,r10
80006d04:	49 2c       	lddpc	r12,80006d4c <xPortStartScheduler+0x50>
80006d06:	f0 1f 00 13 	mcall	80006d50 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006d0a:	e0 68 5d c0 	mov	r8,24000
80006d0e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006d12:	30 08       	mov	r8,0
80006d14:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006d18:	e0 68 0d 74 	mov	r8,3444
80006d1c:	ea 18 00 00 	orh	r8,0x0
80006d20:	70 00       	ld.w	r0,r8[0x0]
80006d22:	60 0d       	ld.w	sp,r0[0x0]
80006d24:	1b 00       	ld.w	r0,sp++
80006d26:	e0 68 05 4c 	mov	r8,1356
80006d2a:	ea 18 00 00 	orh	r8,0x0
80006d2e:	91 00       	st.w	r8[0x0],r0
80006d30:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006d34:	2f ed       	sub	sp,-8
80006d36:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006d3a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006d3e:	e3 b0 00 00 	mtsr	0x0,r0
80006d42:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006d46:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006d4a:	d8 0a       	popm	pc,r12=0
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	6e 18       	ld.w	r8,r7[0x4]
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	63 4c       	ld.w	r12,r1[0x50]

80006d54 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006d54:	20 6d       	sub	sp,24
80006d56:	eb cd 00 ff 	pushm	r0-r7
80006d5a:	fa c7 ff c0 	sub	r7,sp,-64
80006d5e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006d62:	ef 40 ff e0 	st.w	r7[-32],r0
80006d66:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006d6a:	ef 40 ff e4 	st.w	r7[-28],r0
80006d6e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006d72:	e0 68 05 4c 	mov	r8,1356
80006d76:	ea 18 00 00 	orh	r8,0x0
80006d7a:	70 00       	ld.w	r0,r8[0x0]
80006d7c:	1a d0       	st.w	--sp,r0
80006d7e:	f0 1f 00 1a 	mcall	80006de4 <LABEL_RET_SCALL_263+0x14>
80006d82:	e0 68 0d 74 	mov	r8,3444
80006d86:	ea 18 00 00 	orh	r8,0x0
80006d8a:	70 00       	ld.w	r0,r8[0x0]
80006d8c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006d8e:	f0 1f 00 17 	mcall	80006de8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006d92:	e0 68 0d 74 	mov	r8,3444
80006d96:	ea 18 00 00 	orh	r8,0x0
80006d9a:	70 00       	ld.w	r0,r8[0x0]
80006d9c:	60 0d       	ld.w	sp,r0[0x0]
80006d9e:	1b 00       	ld.w	r0,sp++
80006da0:	e0 68 05 4c 	mov	r8,1356
80006da4:	ea 18 00 00 	orh	r8,0x0
80006da8:	91 00       	st.w	r8[0x0],r0
80006daa:	fa c7 ff d8 	sub	r7,sp,-40
80006dae:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006db2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006db6:	e0 61 05 4c 	mov	r1,1356
80006dba:	ea 11 00 00 	orh	r1,0x0
80006dbe:	62 02       	ld.w	r2,r1[0x0]
80006dc0:	58 02       	cp.w	r2,0
80006dc2:	c0 70       	breq	80006dd0 <LABEL_RET_SCALL_263>
80006dc4:	e4 c2 00 01 	sub	r2,r2,1
80006dc8:	83 02       	st.w	r1[0x0],r2
80006dca:	58 02       	cp.w	r2,0
80006dcc:	c0 21       	brne	80006dd0 <LABEL_RET_SCALL_263>
80006dce:	b1 c0       	cbr	r0,0x10

80006dd0 <LABEL_RET_SCALL_263>:
80006dd0:	ef 40 ff f8 	st.w	r7[-8],r0
80006dd4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006dd8:	ef 40 ff fc 	st.w	r7[-4],r0
80006ddc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006de0:	2f ad       	sub	sp,-24
80006de2:	d6 13       	rets
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	6c ec       	ld.w	r12,r6[0x38]
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	74 a0       	ld.w	r0,r10[0x28]

80006dec <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006dec:	e1 b8 00 43 	mfsr	r8,0x10c
80006df0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006df4:	5e fc       	retal	r12
80006df6:	d7 03       	nop

80006df8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006df8:	48 78       	lddpc	r8,80006e14 <vPortExitCritical+0x1c>
80006dfa:	70 08       	ld.w	r8,r8[0x0]
80006dfc:	58 08       	cp.w	r8,0
80006dfe:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006e00:	48 58       	lddpc	r8,80006e14 <vPortExitCritical+0x1c>
80006e02:	70 09       	ld.w	r9,r8[0x0]
80006e04:	20 19       	sub	r9,1
80006e06:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006e08:	70 08       	ld.w	r8,r8[0x0]
80006e0a:	58 08       	cp.w	r8,0
80006e0c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006e0e:	d5 03       	csrf	0x10
80006e10:	5e fc       	retal	r12
80006e12:	00 00       	add	r0,r0
80006e14:	00 00       	add	r0,r0
80006e16:	05 4c       	ld.w	r12,--r2

80006e18 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006e18:	eb cd 00 ff 	pushm	r0-r7
80006e1c:	e0 68 05 4c 	mov	r8,1356
80006e20:	ea 18 00 00 	orh	r8,0x0
80006e24:	70 00       	ld.w	r0,r8[0x0]
80006e26:	1a d0       	st.w	--sp,r0
80006e28:	7a 90       	ld.w	r0,sp[0x24]
80006e2a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006e2e:	58 10       	cp.w	r0,1
80006e30:	e0 8b 00 08 	brhi	80006e40 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006e34:	e0 68 0d 74 	mov	r8,3444
80006e38:	ea 18 00 00 	orh	r8,0x0
80006e3c:	70 00       	ld.w	r0,r8[0x0]
80006e3e:	81 0d       	st.w	r0[0x0],sp

80006e40 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006e40:	f0 1f 00 12 	mcall	80006e88 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006e44:	f0 1f 00 12 	mcall	80006e8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006e48:	f0 1f 00 12 	mcall	80006e90 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006e4c:	f0 1f 00 12 	mcall	80006e94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006e50:	7a 90       	ld.w	r0,sp[0x24]
80006e52:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006e56:	58 10       	cp.w	r0,1
80006e58:	e0 8b 00 0e 	brhi	80006e74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006e5c:	f0 1f 00 0c 	mcall	80006e8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006e60:	f0 1f 00 0e 	mcall	80006e98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006e64:	f0 1f 00 0c 	mcall	80006e94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006e68:	e0 68 0d 74 	mov	r8,3444
80006e6c:	ea 18 00 00 	orh	r8,0x0
80006e70:	70 00       	ld.w	r0,r8[0x0]
80006e72:	60 0d       	ld.w	sp,r0[0x0]

80006e74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006e74:	1b 00       	ld.w	r0,sp++
80006e76:	e0 68 05 4c 	mov	r8,1356
80006e7a:	ea 18 00 00 	orh	r8,0x0
80006e7e:	91 00       	st.w	r8[0x0],r0
80006e80:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006e84:	d6 03       	rete
80006e86:	00 00       	add	r0,r0
80006e88:	80 00       	ld.sh	r0,r0[0x0]
80006e8a:	6d ec       	ld.w	r12,r6[0x78]
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	6c ec       	ld.w	r12,r6[0x38]
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	76 a4       	ld.w	r4,r11[0x28]
80006e94:	80 00       	ld.sh	r0,r0[0x0]
80006e96:	6d f8       	ld.w	r8,r6[0x7c]
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	74 a0       	ld.w	r0,r10[0x28]

80006e9c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006e9c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006e9e:	f0 1f 00 02 	mcall	80006ea4 <__malloc_lock+0x8>
}
80006ea2:	d8 02       	popm	pc
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	74 90       	ld.w	r0,r10[0x24]

80006ea8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006ea8:	d4 01       	pushm	lr
	xTaskResumeAll();
80006eaa:	f0 1f 00 02 	mcall	80006eb0 <__malloc_unlock+0x8>
}
80006eae:	d8 02       	popm	pc
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	78 4c       	ld.w	r12,r12[0x10]

80006eb4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006eb4:	d4 21       	pushm	r4-r7,lr
80006eb6:	16 95       	mov	r5,r11
80006eb8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006eba:	58 0c       	cp.w	r12,0
80006ebc:	c0 30       	breq	80006ec2 <_read+0xe>
80006ebe:	3f f7       	mov	r7,-1
80006ec0:	c1 48       	rjmp	80006ee8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006ec2:	58 0a       	cp.w	r10,0
80006ec4:	e0 89 00 04 	brgt	80006ecc <_read+0x18>
80006ec8:	30 07       	mov	r7,0
80006eca:	c0 f8       	rjmp	80006ee8 <_read+0x34>
80006ecc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006ece:	48 84       	lddpc	r4,80006eec <_read+0x38>
80006ed0:	68 0c       	ld.w	r12,r4[0x0]
80006ed2:	f0 1f 00 08 	mcall	80006ef0 <_read+0x3c>
    if (c < 0)
80006ed6:	c0 95       	brlt	80006ee8 <_read+0x34>
      break;

    *ptr++ = c;
80006ed8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006edc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006ede:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006ee2:	58 08       	cp.w	r8,0
80006ee4:	fe 99 ff f6 	brgt	80006ed0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006ee8:	0e 9c       	mov	r12,r7
80006eea:	d8 22       	popm	r4-r7,pc
80006eec:	00 00       	add	r0,r0
80006eee:	9e 00       	ld.sh	r0,pc[0x0]
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	6a 40       	ld.w	r0,r5[0x10]

80006ef4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006ef4:	d4 21       	pushm	r4-r7,lr
80006ef6:	16 95       	mov	r5,r11
80006ef8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006efa:	20 1c       	sub	r12,1
80006efc:	58 2c       	cp.w	r12,2
80006efe:	e0 8b 00 12 	brhi	80006f22 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f02:	58 0a       	cp.w	r10,0
80006f04:	c0 31       	brne	80006f0a <_write+0x16>
80006f06:	30 07       	mov	r7,0
80006f08:	c0 e8       	rjmp	80006f24 <_write+0x30>
80006f0a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006f0c:	48 74       	lddpc	r4,80006f28 <_write+0x34>
80006f0e:	68 0c       	ld.w	r12,r4[0x0]
80006f10:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006f14:	f0 1f 00 06 	mcall	80006f2c <_write+0x38>
80006f18:	c0 55       	brlt	80006f22 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006f1a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f1c:	0e 36       	cp.w	r6,r7
80006f1e:	cf 81       	brne	80006f0e <_write+0x1a>
80006f20:	c0 28       	rjmp	80006f24 <_write+0x30>
80006f22:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006f24:	0e 9c       	mov	r12,r7
80006f26:	d8 22       	popm	r4-r7,pc
80006f28:	00 00       	add	r0,r0
80006f2a:	9e 00       	ld.sh	r0,pc[0x0]
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	69 f0       	ld.w	r0,r4[0x7c]

80006f30 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006f30:	eb cd 40 80 	pushm	r7,lr
80006f34:	18 97       	mov	r7,r12
	if( pv )
80006f36:	58 0c       	cp.w	r12,0
80006f38:	c0 80       	breq	80006f48 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006f3a:	f0 1f 00 05 	mcall	80006f4c <vPortFree+0x1c>
		{
			free( pv );
80006f3e:	0e 9c       	mov	r12,r7
80006f40:	f0 1f 00 04 	mcall	80006f50 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006f44:	f0 1f 00 04 	mcall	80006f54 <vPortFree+0x24>
80006f48:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f4c:	80 00       	ld.sh	r0,r0[0x0]
80006f4e:	74 90       	ld.w	r0,r10[0x24]
80006f50:	80 00       	ld.sh	r0,r0[0x0]
80006f52:	83 28       	st.w	r1[0x8],r8
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	78 4c       	ld.w	r12,r12[0x10]

80006f58 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006f58:	eb cd 40 80 	pushm	r7,lr
80006f5c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006f5e:	f0 1f 00 06 	mcall	80006f74 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006f62:	0e 9c       	mov	r12,r7
80006f64:	f0 1f 00 05 	mcall	80006f78 <pvPortMalloc+0x20>
80006f68:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006f6a:	f0 1f 00 05 	mcall	80006f7c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006f6e:	0e 9c       	mov	r12,r7
80006f70:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	74 90       	ld.w	r0,r10[0x24]
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	83 38       	st.w	r1[0xc],r8
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	78 4c       	ld.w	r12,r12[0x10]

80006f80 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006f80:	d4 01       	pushm	lr
80006f82:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006f84:	78 09       	ld.w	r9,r12[0x0]
80006f86:	58 09       	cp.w	r9,0
80006f88:	c1 10       	breq	80006faa <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006f8a:	78 3a       	ld.w	r10,r12[0xc]
80006f8c:	79 09       	ld.w	r9,r12[0x40]
80006f8e:	f4 09 00 09 	add	r9,r10,r9
80006f92:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006f94:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006f96:	14 39       	cp.w	r9,r10
80006f98:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006f9c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006fa0:	79 0a       	ld.w	r10,r12[0x40]
80006fa2:	78 3b       	ld.w	r11,r12[0xc]
80006fa4:	10 9c       	mov	r12,r8
80006fa6:	f0 1f 00 02 	mcall	80006fac <prvCopyDataFromQueue+0x2c>
80006faa:	d8 02       	popm	pc
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	87 a6       	st.w	r3[0x28],r6

80006fb0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006fb0:	eb cd 40 c0 	pushm	r6-r7,lr
80006fb4:	18 97       	mov	r7,r12
80006fb6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006fb8:	78 e8       	ld.w	r8,r12[0x38]
80006fba:	58 08       	cp.w	r8,0
80006fbc:	c0 31       	brne	80006fc2 <xQueueReceiveFromISR+0x12>
80006fbe:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006fc2:	f0 1f 00 0e 	mcall	80006ff8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006fc6:	6e e8       	ld.w	r8,r7[0x38]
80006fc8:	20 18       	sub	r8,1
80006fca:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006fcc:	6f 18       	ld.w	r8,r7[0x44]
80006fce:	5b f8       	cp.w	r8,-1
80006fd0:	c0 d1       	brne	80006fea <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006fd2:	6e 48       	ld.w	r8,r7[0x10]
80006fd4:	58 08       	cp.w	r8,0
80006fd6:	c0 f0       	breq	80006ff4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006fd8:	ee cc ff f0 	sub	r12,r7,-16
80006fdc:	f0 1f 00 08 	mcall	80006ffc <xQueueReceiveFromISR+0x4c>
80006fe0:	c0 a0       	breq	80006ff4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006fe2:	30 1c       	mov	r12,1
80006fe4:	8d 0c       	st.w	r6[0x0],r12
80006fe6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006fea:	2f f8       	sub	r8,-1
80006fec:	ef 48 00 44 	st.w	r7[68],r8
80006ff0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006ff4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	6f 80       	ld.w	r0,r7[0x60]
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	76 28       	ld.w	r8,r11[0x8]

80007000 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80007000:	eb cd 40 c0 	pushm	r6-r7,lr
80007004:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80007006:	f0 1f 00 23 	mcall	80007090 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000700a:	6f 28       	ld.w	r8,r7[0x48]
8000700c:	58 08       	cp.w	r8,0
8000700e:	e0 8a 00 18 	brle	8000703e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007012:	6e 98       	ld.w	r8,r7[0x24]
80007014:	58 08       	cp.w	r8,0
80007016:	c1 40       	breq	8000703e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007018:	ee c6 ff dc 	sub	r6,r7,-36
8000701c:	c0 48       	rjmp	80007024 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000701e:	6e 98       	ld.w	r8,r7[0x24]
80007020:	58 08       	cp.w	r8,0
80007022:	c0 e0       	breq	8000703e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007024:	0c 9c       	mov	r12,r6
80007026:	f0 1f 00 1c 	mcall	80007094 <prvUnlockQueue+0x94>
8000702a:	c0 30       	breq	80007030 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000702c:	f0 1f 00 1b 	mcall	80007098 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80007030:	6f 28       	ld.w	r8,r7[0x48]
80007032:	20 18       	sub	r8,1
80007034:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80007038:	58 08       	cp.w	r8,0
8000703a:	fe 99 ff f2 	brgt	8000701e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000703e:	3f f8       	mov	r8,-1
80007040:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80007044:	f0 1f 00 16 	mcall	8000709c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80007048:	f0 1f 00 12 	mcall	80007090 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000704c:	6f 18       	ld.w	r8,r7[0x44]
8000704e:	58 08       	cp.w	r8,0
80007050:	e0 8a 00 18 	brle	80007080 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007054:	6e 48       	ld.w	r8,r7[0x10]
80007056:	58 08       	cp.w	r8,0
80007058:	c1 40       	breq	80007080 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000705a:	ee c6 ff f0 	sub	r6,r7,-16
8000705e:	c0 48       	rjmp	80007066 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007060:	6e 48       	ld.w	r8,r7[0x10]
80007062:	58 08       	cp.w	r8,0
80007064:	c0 e0       	breq	80007080 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007066:	0c 9c       	mov	r12,r6
80007068:	f0 1f 00 0b 	mcall	80007094 <prvUnlockQueue+0x94>
8000706c:	c0 30       	breq	80007072 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000706e:	f0 1f 00 0b 	mcall	80007098 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80007072:	6f 18       	ld.w	r8,r7[0x44]
80007074:	20 18       	sub	r8,1
80007076:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000707a:	58 08       	cp.w	r8,0
8000707c:	fe 99 ff f2 	brgt	80007060 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80007080:	3f f8       	mov	r8,-1
80007082:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80007086:	f0 1f 00 06 	mcall	8000709c <prvUnlockQueue+0x9c>
}
8000708a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000708e:	00 00       	add	r0,r0
80007090:	80 00       	ld.sh	r0,r0[0x0]
80007092:	6c ec       	ld.w	r12,r6[0x38]
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	76 28       	ld.w	r8,r11[0x8]
80007098:	80 00       	ld.sh	r0,r0[0x0]
8000709a:	75 34       	ld.w	r4,r10[0x4c]
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	6d f8       	ld.w	r8,r6[0x7c]

800070a0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800070a0:	d4 31       	pushm	r0-r7,lr
800070a2:	20 5d       	sub	sp,20
800070a4:	18 97       	mov	r7,r12
800070a6:	50 0b       	stdsp	sp[0x0],r11
800070a8:	50 2a       	stdsp	sp[0x8],r10
800070aa:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800070ac:	f8 c2 ff dc 	sub	r2,r12,-36
800070b0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800070b2:	fa c4 ff f4 	sub	r4,sp,-12
800070b6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800070b8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800070ba:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800070be:	f0 1f 00 3e 	mcall	800071b4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800070c2:	6e e8       	ld.w	r8,r7[0x38]
800070c4:	58 08       	cp.w	r8,0
800070c6:	c2 a0       	breq	8000711a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800070c8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800070ca:	40 0b       	lddsp	r11,sp[0x0]
800070cc:	0e 9c       	mov	r12,r7
800070ce:	f0 1f 00 3b 	mcall	800071b8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800070d2:	40 18       	lddsp	r8,sp[0x4]
800070d4:	58 08       	cp.w	r8,0
800070d6:	c1 51       	brne	80007100 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800070d8:	6e e8       	ld.w	r8,r7[0x38]
800070da:	20 18       	sub	r8,1
800070dc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800070de:	6e 08       	ld.w	r8,r7[0x0]
800070e0:	58 08       	cp.w	r8,0
800070e2:	c0 41       	brne	800070ea <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800070e4:	f0 1f 00 36 	mcall	800071bc <xQueueGenericReceive+0x11c>
800070e8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070ea:	6e 48       	ld.w	r8,r7[0x10]
800070ec:	58 08       	cp.w	r8,0
800070ee:	c1 20       	breq	80007112 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800070f0:	ee cc ff f0 	sub	r12,r7,-16
800070f4:	f0 1f 00 33 	mcall	800071c0 <xQueueGenericReceive+0x120>
800070f8:	58 1c       	cp.w	r12,1
800070fa:	c0 c1       	brne	80007112 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800070fc:	d7 33       	scall
800070fe:	c0 a8       	rjmp	80007112 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80007100:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007102:	6e 98       	ld.w	r8,r7[0x24]
80007104:	58 08       	cp.w	r8,0
80007106:	c0 60       	breq	80007112 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007108:	04 9c       	mov	r12,r2
8000710a:	f0 1f 00 2e 	mcall	800071c0 <xQueueGenericReceive+0x120>
8000710e:	c0 20       	breq	80007112 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80007110:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80007112:	f0 1f 00 2d 	mcall	800071c4 <xQueueGenericReceive+0x124>
80007116:	30 1c       	mov	r12,1
				return pdPASS;
80007118:	c4 c8       	rjmp	800071b0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000711a:	40 28       	lddsp	r8,sp[0x8]
8000711c:	58 08       	cp.w	r8,0
8000711e:	c0 51       	brne	80007128 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007120:	f0 1f 00 29 	mcall	800071c4 <xQueueGenericReceive+0x124>
80007124:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80007126:	c4 58       	rjmp	800071b0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80007128:	58 05       	cp.w	r5,0
8000712a:	c0 51       	brne	80007134 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000712c:	08 9c       	mov	r12,r4
8000712e:	f0 1f 00 27 	mcall	800071c8 <xQueueGenericReceive+0x128>
80007132:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007134:	f0 1f 00 24 	mcall	800071c4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007138:	f0 1f 00 25 	mcall	800071cc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000713c:	f0 1f 00 1e 	mcall	800071b4 <xQueueGenericReceive+0x114>
80007140:	6f 18       	ld.w	r8,r7[0x44]
80007142:	5b f8       	cp.w	r8,-1
80007144:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007148:	6f 28       	ld.w	r8,r7[0x48]
8000714a:	5b f8       	cp.w	r8,-1
8000714c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007150:	f0 1f 00 1d 	mcall	800071c4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007154:	06 9b       	mov	r11,r3
80007156:	08 9c       	mov	r12,r4
80007158:	f0 1f 00 1e 	mcall	800071d0 <xQueueGenericReceive+0x130>
8000715c:	c2 41       	brne	800071a4 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000715e:	f0 1f 00 16 	mcall	800071b4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80007162:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80007164:	f0 1f 00 18 	mcall	800071c4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80007168:	58 06       	cp.w	r6,0
8000716a:	c1 71       	brne	80007198 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000716c:	6e 08       	ld.w	r8,r7[0x0]
8000716e:	58 08       	cp.w	r8,0
80007170:	c0 81       	brne	80007180 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80007172:	f0 1f 00 11 	mcall	800071b4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80007176:	6e 1c       	ld.w	r12,r7[0x4]
80007178:	f0 1f 00 17 	mcall	800071d4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000717c:	f0 1f 00 12 	mcall	800071c4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007180:	40 2b       	lddsp	r11,sp[0x8]
80007182:	04 9c       	mov	r12,r2
80007184:	f0 1f 00 15 	mcall	800071d8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80007188:	0e 9c       	mov	r12,r7
8000718a:	f0 1f 00 15 	mcall	800071dc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000718e:	f0 1f 00 15 	mcall	800071e0 <xQueueGenericReceive+0x140>
80007192:	c9 61       	brne	800070be <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007194:	d7 33       	scall
80007196:	c9 4b       	rjmp	800070be <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007198:	0e 9c       	mov	r12,r7
8000719a:	f0 1f 00 11 	mcall	800071dc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000719e:	f0 1f 00 11 	mcall	800071e0 <xQueueGenericReceive+0x140>
800071a2:	c8 eb       	rjmp	800070be <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800071a4:	0e 9c       	mov	r12,r7
800071a6:	f0 1f 00 0e 	mcall	800071dc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800071aa:	f0 1f 00 0e 	mcall	800071e0 <xQueueGenericReceive+0x140>
800071ae:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800071b0:	2f bd       	sub	sp,-20
800071b2:	d8 32       	popm	r0-r7,pc
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	6c ec       	ld.w	r12,r6[0x38]
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	6f 80       	ld.w	r0,r7[0x60]
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	75 40       	ld.w	r0,r10[0x50]
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	76 28       	ld.w	r8,r11[0x8]
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	6d f8       	ld.w	r8,r6[0x7c]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	75 1c       	ld.w	r12,r10[0x44]
800071cc:	80 00       	ld.sh	r0,r0[0x0]
800071ce:	74 90       	ld.w	r0,r10[0x24]
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	77 b8       	ld.w	r8,r11[0x6c]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	75 a4       	ld.w	r4,r10[0x68]
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	7a 58       	ld.w	r8,sp[0x14]
800071dc:	80 00       	ld.sh	r0,r0[0x0]
800071de:	70 00       	ld.w	r0,r8[0x0]
800071e0:	80 00       	ld.sh	r0,r0[0x0]
800071e2:	78 4c       	ld.w	r12,r12[0x10]

800071e4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800071e4:	eb cd 40 80 	pushm	r7,lr
800071e8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800071ea:	79 08       	ld.w	r8,r12[0x40]
800071ec:	58 08       	cp.w	r8,0
800071ee:	c0 a1       	brne	80007202 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800071f0:	78 08       	ld.w	r8,r12[0x0]
800071f2:	58 08       	cp.w	r8,0
800071f4:	c2 b1       	brne	8000724a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800071f6:	78 1c       	ld.w	r12,r12[0x4]
800071f8:	f0 1f 00 17 	mcall	80007254 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800071fc:	30 08       	mov	r8,0
800071fe:	8f 18       	st.w	r7[0x4],r8
80007200:	c2 58       	rjmp	8000724a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80007202:	58 0a       	cp.w	r10,0
80007204:	c1 01       	brne	80007224 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007206:	10 9a       	mov	r10,r8
80007208:	78 2c       	ld.w	r12,r12[0x8]
8000720a:	f0 1f 00 14 	mcall	80007258 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000720e:	6e 29       	ld.w	r9,r7[0x8]
80007210:	6f 08       	ld.w	r8,r7[0x40]
80007212:	f2 08 00 08 	add	r8,r9,r8
80007216:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80007218:	6e 19       	ld.w	r9,r7[0x4]
8000721a:	12 38       	cp.w	r8,r9
8000721c:	c1 73       	brcs	8000724a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000721e:	6e 08       	ld.w	r8,r7[0x0]
80007220:	8f 28       	st.w	r7[0x8],r8
80007222:	c1 48       	rjmp	8000724a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007224:	10 9a       	mov	r10,r8
80007226:	78 3c       	ld.w	r12,r12[0xc]
80007228:	f0 1f 00 0c 	mcall	80007258 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000722c:	6f 08       	ld.w	r8,r7[0x40]
8000722e:	6e 39       	ld.w	r9,r7[0xc]
80007230:	f2 08 01 08 	sub	r8,r9,r8
80007234:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80007236:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80007238:	12 38       	cp.w	r8,r9
8000723a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000723e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80007242:	f3 d8 e3 19 	subcs	r9,r9,r8
80007246:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000724a:	6e e8       	ld.w	r8,r7[0x38]
8000724c:	2f f8       	sub	r8,-1
8000724e:	8f e8       	st.w	r7[0x38],r8
}
80007250:	e3 cd 80 80 	ldm	sp++,r7,pc
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	75 4c       	ld.w	r12,r10[0x50]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	87 a6       	st.w	r3[0x28],r6

8000725c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000725c:	eb cd 40 c0 	pushm	r6-r7,lr
80007260:	18 97       	mov	r7,r12
80007262:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80007264:	78 ec       	ld.w	r12,r12[0x38]
80007266:	6e f8       	ld.w	r8,r7[0x3c]
80007268:	10 3c       	cp.w	r12,r8
8000726a:	c0 33       	brcs	80007270 <xQueueGenericSendFromISR+0x14>
8000726c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007270:	12 9a       	mov	r10,r9
80007272:	0e 9c       	mov	r12,r7
80007274:	f0 1f 00 0c 	mcall	800072a4 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80007278:	6f 28       	ld.w	r8,r7[0x48]
8000727a:	5b f8       	cp.w	r8,-1
8000727c:	c0 d1       	brne	80007296 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000727e:	6e 98       	ld.w	r8,r7[0x24]
80007280:	58 08       	cp.w	r8,0
80007282:	c0 f0       	breq	800072a0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007284:	ee cc ff dc 	sub	r12,r7,-36
80007288:	f0 1f 00 08 	mcall	800072a8 <xQueueGenericSendFromISR+0x4c>
8000728c:	c0 a0       	breq	800072a0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000728e:	30 1c       	mov	r12,1
80007290:	8d 0c       	st.w	r6[0x0],r12
80007292:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80007296:	2f f8       	sub	r8,-1
80007298:	ef 48 00 48 	st.w	r7[72],r8
8000729c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800072a0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	71 e4       	ld.w	r4,r8[0x78]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	76 28       	ld.w	r8,r11[0x8]

800072ac <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800072ac:	d4 31       	pushm	r0-r7,lr
800072ae:	20 5d       	sub	sp,20
800072b0:	18 97       	mov	r7,r12
800072b2:	50 0b       	stdsp	sp[0x0],r11
800072b4:	50 2a       	stdsp	sp[0x8],r10
800072b6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800072b8:	f8 c0 ff f0 	sub	r0,r12,-16
800072bc:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800072be:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800072c2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800072c4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800072c8:	f0 1f 00 2f 	mcall	80007384 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800072cc:	6e e9       	ld.w	r9,r7[0x38]
800072ce:	6e f8       	ld.w	r8,r7[0x3c]
800072d0:	10 39       	cp.w	r9,r8
800072d2:	c1 42       	brcc	800072fa <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800072d4:	40 1a       	lddsp	r10,sp[0x4]
800072d6:	40 0b       	lddsp	r11,sp[0x0]
800072d8:	0e 9c       	mov	r12,r7
800072da:	f0 1f 00 2c 	mcall	80007388 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800072de:	6e 98       	ld.w	r8,r7[0x24]
800072e0:	58 08       	cp.w	r8,0
800072e2:	c0 80       	breq	800072f2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800072e4:	ee cc ff dc 	sub	r12,r7,-36
800072e8:	f0 1f 00 29 	mcall	8000738c <xQueueGenericSend+0xe0>
800072ec:	58 1c       	cp.w	r12,1
800072ee:	c0 21       	brne	800072f2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800072f0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800072f2:	f0 1f 00 28 	mcall	80007390 <xQueueGenericSend+0xe4>
800072f6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800072f8:	c4 38       	rjmp	8000737e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800072fa:	40 28       	lddsp	r8,sp[0x8]
800072fc:	58 08       	cp.w	r8,0
800072fe:	c0 51       	brne	80007308 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007300:	f0 1f 00 24 	mcall	80007390 <xQueueGenericSend+0xe4>
80007304:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80007306:	c3 c8       	rjmp	8000737e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80007308:	58 04       	cp.w	r4,0
8000730a:	c0 51       	brne	80007314 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000730c:	06 9c       	mov	r12,r3
8000730e:	f0 1f 00 22 	mcall	80007394 <xQueueGenericSend+0xe8>
80007312:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007314:	f0 1f 00 1f 	mcall	80007390 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007318:	f0 1f 00 20 	mcall	80007398 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000731c:	f0 1f 00 1a 	mcall	80007384 <xQueueGenericSend+0xd8>
80007320:	6f 18       	ld.w	r8,r7[0x44]
80007322:	5b f8       	cp.w	r8,-1
80007324:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007328:	6f 28       	ld.w	r8,r7[0x48]
8000732a:	5b f8       	cp.w	r8,-1
8000732c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007330:	f0 1f 00 18 	mcall	80007390 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007334:	04 9b       	mov	r11,r2
80007336:	06 9c       	mov	r12,r3
80007338:	f0 1f 00 19 	mcall	8000739c <xQueueGenericSend+0xf0>
8000733c:	c1 b1       	brne	80007372 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000733e:	f0 1f 00 12 	mcall	80007384 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80007342:	6e e5       	ld.w	r5,r7[0x38]
80007344:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80007346:	f0 1f 00 13 	mcall	80007390 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000734a:	0c 35       	cp.w	r5,r6
8000734c:	c0 d1       	brne	80007366 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000734e:	40 2b       	lddsp	r11,sp[0x8]
80007350:	00 9c       	mov	r12,r0
80007352:	f0 1f 00 14 	mcall	800073a0 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80007356:	0e 9c       	mov	r12,r7
80007358:	f0 1f 00 13 	mcall	800073a4 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000735c:	f0 1f 00 13 	mcall	800073a8 <xQueueGenericSend+0xfc>
80007360:	cb 41       	brne	800072c8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80007362:	d7 33       	scall
80007364:	cb 2b       	rjmp	800072c8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007366:	0e 9c       	mov	r12,r7
80007368:	f0 1f 00 0f 	mcall	800073a4 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000736c:	f0 1f 00 0f 	mcall	800073a8 <xQueueGenericSend+0xfc>
80007370:	ca cb       	rjmp	800072c8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80007372:	0e 9c       	mov	r12,r7
80007374:	f0 1f 00 0c 	mcall	800073a4 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80007378:	f0 1f 00 0c 	mcall	800073a8 <xQueueGenericSend+0xfc>
8000737c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000737e:	2f bd       	sub	sp,-20
80007380:	d8 32       	popm	r0-r7,pc
80007382:	00 00       	add	r0,r0
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	6c ec       	ld.w	r12,r6[0x38]
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	71 e4       	ld.w	r4,r8[0x78]
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	76 28       	ld.w	r8,r11[0x8]
80007390:	80 00       	ld.sh	r0,r0[0x0]
80007392:	6d f8       	ld.w	r8,r6[0x7c]
80007394:	80 00       	ld.sh	r0,r0[0x0]
80007396:	75 1c       	ld.w	r12,r10[0x44]
80007398:	80 00       	ld.sh	r0,r0[0x0]
8000739a:	74 90       	ld.w	r0,r10[0x24]
8000739c:	80 00       	ld.sh	r0,r0[0x0]
8000739e:	77 b8       	ld.w	r8,r11[0x6c]
800073a0:	80 00       	ld.sh	r0,r0[0x0]
800073a2:	7a 58       	ld.w	r8,sp[0x14]
800073a4:	80 00       	ld.sh	r0,r0[0x0]
800073a6:	70 00       	ld.w	r0,r8[0x0]
800073a8:	80 00       	ld.sh	r0,r0[0x0]
800073aa:	78 4c       	ld.w	r12,r12[0x10]

800073ac <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800073ac:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800073b0:	34 cc       	mov	r12,76
800073b2:	f0 1f 00 12 	mcall	800073f8 <xQueueCreateMutex+0x4c>
800073b6:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800073b8:	c1 d0       	breq	800073f2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800073ba:	30 06       	mov	r6,0
800073bc:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800073be:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800073c0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800073c2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800073c4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800073c6:	30 18       	mov	r8,1
800073c8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800073ca:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800073ce:	3f f8       	mov	r8,-1
800073d0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800073d4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800073d8:	2f 0c       	sub	r12,-16
800073da:	f0 1f 00 09 	mcall	800073fc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800073de:	ee cc ff dc 	sub	r12,r7,-36
800073e2:	f0 1f 00 07 	mcall	800073fc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800073e6:	0c 99       	mov	r9,r6
800073e8:	0c 9a       	mov	r10,r6
800073ea:	0c 9b       	mov	r11,r6
800073ec:	0e 9c       	mov	r12,r7
800073ee:	f0 1f 00 05 	mcall	80007400 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800073f2:	0e 9c       	mov	r12,r7
800073f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	6f 58       	ld.w	r8,r7[0x54]
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	6b c8       	ld.w	r8,r5[0x70]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	72 ac       	ld.w	r12,r9[0x28]

80007404 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80007404:	d4 21       	pushm	r4-r7,lr
80007406:	18 97       	mov	r7,r12
80007408:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000740a:	58 0c       	cp.w	r12,0
8000740c:	c2 f0       	breq	8000746a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000740e:	34 cc       	mov	r12,76
80007410:	f0 1f 00 17 	mcall	8000746c <xQueueCreate+0x68>
80007414:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80007416:	c2 a0       	breq	8000746a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80007418:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000741c:	e8 cc ff ff 	sub	r12,r4,-1
80007420:	f0 1f 00 13 	mcall	8000746c <xQueueCreate+0x68>
80007424:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80007426:	c1 e0       	breq	80007462 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80007428:	f8 04 00 04 	add	r4,r12,r4
8000742c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000742e:	30 08       	mov	r8,0
80007430:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80007432:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80007434:	ee c8 00 01 	sub	r8,r7,1
80007438:	ad 38       	mul	r8,r6
8000743a:	10 0c       	add	r12,r8
8000743c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000743e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80007440:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80007444:	3f f8       	mov	r8,-1
80007446:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000744a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000744e:	ea cc ff f0 	sub	r12,r5,-16
80007452:	f0 1f 00 08 	mcall	80007470 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80007456:	ea cc ff dc 	sub	r12,r5,-36
8000745a:	f0 1f 00 06 	mcall	80007470 <xQueueCreate+0x6c>
8000745e:	0a 9c       	mov	r12,r5
80007460:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80007462:	0a 9c       	mov	r12,r5
80007464:	f0 1f 00 04 	mcall	80007474 <xQueueCreate+0x70>
80007468:	d8 2a       	popm	r4-r7,pc,r12=0
8000746a:	d8 2a       	popm	r4-r7,pc,r12=0
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	6f 58       	ld.w	r8,r7[0x54]
80007470:	80 00       	ld.sh	r0,r0[0x0]
80007472:	6b c8       	ld.w	r8,r5[0x70]
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	6f 30       	ld.w	r0,r7[0x4c]

80007478 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
80007478:	eb cd 40 80 	pushm	r7,lr
8000747c:	16 97       	mov	r7,r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
8000747e:	30 0b       	mov	r11,0
80007480:	f0 1f 00 03 	mcall	8000748c <xQueueCreateCountingSemaphore+0x14>

		if( pxHandle != NULL )
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
80007484:	f9 f7 1a 0e 	st.wne	r12[0x38],r7
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
80007488:	e3 cd 80 80 	ldm	sp++,r7,pc
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	74 04       	ld.w	r4,r10[0x0]

80007490 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80007490:	48 38       	lddpc	r8,8000749c <vTaskSuspendAll+0xc>
80007492:	70 09       	ld.w	r9,r8[0x0]
80007494:	2f f9       	sub	r9,-1
80007496:	91 09       	st.w	r8[0x0],r9
}
80007498:	5e fc       	retal	r12
8000749a:	00 00       	add	r0,r0
8000749c:	00 00       	add	r0,r0
8000749e:	0d a4       	ld.ub	r4,r6[0x2]

800074a0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800074a0:	49 a8       	lddpc	r8,80007508 <vTaskSwitchContext+0x68>
800074a2:	70 08       	ld.w	r8,r8[0x0]
800074a4:	58 08       	cp.w	r8,0
800074a6:	c0 b1       	brne	800074bc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800074a8:	49 98       	lddpc	r8,8000750c <vTaskSwitchContext+0x6c>
800074aa:	70 08       	ld.w	r8,r8[0x0]
800074ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800074b0:	49 89       	lddpc	r9,80007510 <vTaskSwitchContext+0x70>
800074b2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800074b6:	58 08       	cp.w	r8,0
800074b8:	c0 60       	breq	800074c4 <vTaskSwitchContext+0x24>
800074ba:	c1 18       	rjmp	800074dc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800074bc:	30 19       	mov	r9,1
800074be:	49 68       	lddpc	r8,80007514 <vTaskSwitchContext+0x74>
800074c0:	91 09       	st.w	r8[0x0],r9
800074c2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800074c4:	49 28       	lddpc	r8,8000750c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800074c6:	49 3a       	lddpc	r10,80007510 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800074c8:	70 09       	ld.w	r9,r8[0x0]
800074ca:	20 19       	sub	r9,1
800074cc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800074ce:	70 09       	ld.w	r9,r8[0x0]
800074d0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800074d4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800074d8:	58 09       	cp.w	r9,0
800074da:	cf 70       	breq	800074c8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800074dc:	48 c8       	lddpc	r8,8000750c <vTaskSwitchContext+0x6c>
800074de:	70 08       	ld.w	r8,r8[0x0]
800074e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800074e4:	48 b9       	lddpc	r9,80007510 <vTaskSwitchContext+0x70>
800074e6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800074ea:	70 19       	ld.w	r9,r8[0x4]
800074ec:	72 19       	ld.w	r9,r9[0x4]
800074ee:	91 19       	st.w	r8[0x4],r9
800074f0:	f0 ca ff f8 	sub	r10,r8,-8
800074f4:	14 39       	cp.w	r9,r10
800074f6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800074fa:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800074fe:	70 18       	ld.w	r8,r8[0x4]
80007500:	70 39       	ld.w	r9,r8[0xc]
80007502:	48 68       	lddpc	r8,80007518 <vTaskSwitchContext+0x78>
80007504:	91 09       	st.w	r8[0x0],r9
80007506:	5e fc       	retal	r12
80007508:	00 00       	add	r0,r0
8000750a:	0d a4       	ld.ub	r4,r6[0x2]
8000750c:	00 00       	add	r0,r0
8000750e:	0d dc       	ld.ub	r12,r6[0x5]
80007510:	00 00       	add	r0,r0
80007512:	0c c0       	st.b	r6++,r0
80007514:	00 00       	add	r0,r0
80007516:	0d c4       	ld.ub	r4,r6[0x4]
80007518:	00 00       	add	r0,r0
8000751a:	0d 74       	ld.ub	r4,--r6

8000751c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000751c:	48 48       	lddpc	r8,8000752c <vTaskSetTimeOutState+0x10>
8000751e:	70 08       	ld.w	r8,r8[0x0]
80007520:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80007522:	48 48       	lddpc	r8,80007530 <vTaskSetTimeOutState+0x14>
80007524:	70 08       	ld.w	r8,r8[0x0]
80007526:	99 18       	st.w	r12[0x4],r8
}
80007528:	5e fc       	retal	r12
8000752a:	00 00       	add	r0,r0
8000752c:	00 00       	add	r0,r0
8000752e:	0c b8       	st.h	r6++,r8
80007530:	00 00       	add	r0,r0
80007532:	0d a0       	ld.ub	r0,r6[0x2]

80007534 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80007534:	30 19       	mov	r9,1
80007536:	48 28       	lddpc	r8,8000753c <vTaskMissedYield+0x8>
80007538:	91 09       	st.w	r8[0x0],r9
}
8000753a:	5e fc       	retal	r12
8000753c:	00 00       	add	r0,r0
8000753e:	0d c4       	ld.ub	r4,r6[0x4]

80007540 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80007540:	48 28       	lddpc	r8,80007548 <xTaskGetCurrentTaskHandle+0x8>
80007542:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80007544:	5e fc       	retal	r12
80007546:	00 00       	add	r0,r0
80007548:	00 00       	add	r0,r0
8000754a:	0d 74       	ld.ub	r4,--r6

8000754c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000754c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80007550:	58 0c       	cp.w	r12,0
80007552:	c1 f0       	breq	80007590 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80007554:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80007556:	78 b9       	ld.w	r9,r12[0x2c]
80007558:	79 18       	ld.w	r8,r12[0x44]
8000755a:	10 39       	cp.w	r9,r8
8000755c:	c1 a0       	breq	80007590 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000755e:	f8 c6 ff fc 	sub	r6,r12,-4
80007562:	0c 9c       	mov	r12,r6
80007564:	f0 1f 00 0c 	mcall	80007594 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80007568:	6f 1c       	ld.w	r12,r7[0x44]
8000756a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000756c:	f8 08 11 08 	rsub	r8,r12,8
80007570:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80007572:	48 a8       	lddpc	r8,80007598 <vTaskPriorityDisinherit+0x4c>
80007574:	70 08       	ld.w	r8,r8[0x0]
80007576:	10 3c       	cp.w	r12,r8
80007578:	e0 88 00 04 	brls	80007580 <vTaskPriorityDisinherit+0x34>
8000757c:	48 78       	lddpc	r8,80007598 <vTaskPriorityDisinherit+0x4c>
8000757e:	91 0c       	st.w	r8[0x0],r12
80007580:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007584:	0c 9b       	mov	r11,r6
80007586:	48 68       	lddpc	r8,8000759c <vTaskPriorityDisinherit+0x50>
80007588:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000758c:	f0 1f 00 05 	mcall	800075a0 <vTaskPriorityDisinherit+0x54>
80007590:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007594:	80 00       	ld.sh	r0,r0[0x0]
80007596:	6c 32       	ld.w	r2,r6[0xc]
80007598:	00 00       	add	r0,r0
8000759a:	0d dc       	ld.ub	r12,r6[0x5]
8000759c:	00 00       	add	r0,r0
8000759e:	0c c0       	st.b	r6++,r0
800075a0:	80 00       	ld.sh	r0,r0[0x0]
800075a2:	6b e2       	ld.w	r2,r5[0x78]

800075a4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800075a4:	eb cd 40 c0 	pushm	r6-r7,lr
800075a8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800075aa:	49 b8       	lddpc	r8,80007614 <vTaskPriorityInherit+0x70>
800075ac:	70 08       	ld.w	r8,r8[0x0]
800075ae:	78 b9       	ld.w	r9,r12[0x2c]
800075b0:	70 b8       	ld.w	r8,r8[0x2c]
800075b2:	10 39       	cp.w	r9,r8
800075b4:	c2 d2       	brcc	8000760e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800075b6:	49 88       	lddpc	r8,80007614 <vTaskPriorityInherit+0x70>
800075b8:	70 08       	ld.w	r8,r8[0x0]
800075ba:	70 b8       	ld.w	r8,r8[0x2c]
800075bc:	f0 08 11 08 	rsub	r8,r8,8
800075c0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800075c2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800075c6:	49 59       	lddpc	r9,80007618 <vTaskPriorityInherit+0x74>
800075c8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800075cc:	78 59       	ld.w	r9,r12[0x14]
800075ce:	10 39       	cp.w	r9,r8
800075d0:	c1 b1       	brne	80007606 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800075d2:	f8 c6 ff fc 	sub	r6,r12,-4
800075d6:	0c 9c       	mov	r12,r6
800075d8:	f0 1f 00 11 	mcall	8000761c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800075dc:	48 e8       	lddpc	r8,80007614 <vTaskPriorityInherit+0x70>
800075de:	70 08       	ld.w	r8,r8[0x0]
800075e0:	70 bc       	ld.w	r12,r8[0x2c]
800075e2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800075e4:	48 f8       	lddpc	r8,80007620 <vTaskPriorityInherit+0x7c>
800075e6:	70 08       	ld.w	r8,r8[0x0]
800075e8:	10 3c       	cp.w	r12,r8
800075ea:	e0 88 00 04 	brls	800075f2 <vTaskPriorityInherit+0x4e>
800075ee:	48 d8       	lddpc	r8,80007620 <vTaskPriorityInherit+0x7c>
800075f0:	91 0c       	st.w	r8[0x0],r12
800075f2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075f6:	0c 9b       	mov	r11,r6
800075f8:	48 88       	lddpc	r8,80007618 <vTaskPriorityInherit+0x74>
800075fa:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075fe:	f0 1f 00 0a 	mcall	80007624 <vTaskPriorityInherit+0x80>
80007602:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007606:	48 48       	lddpc	r8,80007614 <vTaskPriorityInherit+0x70>
80007608:	70 08       	ld.w	r8,r8[0x0]
8000760a:	70 b8       	ld.w	r8,r8[0x2c]
8000760c:	99 b8       	st.w	r12[0x2c],r8
8000760e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007612:	00 00       	add	r0,r0
80007614:	00 00       	add	r0,r0
80007616:	0d 74       	ld.ub	r4,--r6
80007618:	00 00       	add	r0,r0
8000761a:	0c c0       	st.b	r6++,r0
8000761c:	80 00       	ld.sh	r0,r0[0x0]
8000761e:	6c 32       	ld.w	r2,r6[0xc]
80007620:	00 00       	add	r0,r0
80007622:	0d dc       	ld.ub	r12,r6[0x5]
80007624:	80 00       	ld.sh	r0,r0[0x0]
80007626:	6b e2       	ld.w	r2,r5[0x78]

80007628 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80007628:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000762c:	78 38       	ld.w	r8,r12[0xc]
8000762e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007630:	ee c6 ff e8 	sub	r6,r7,-24
80007634:	0c 9c       	mov	r12,r6
80007636:	f0 1f 00 15 	mcall	80007688 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000763a:	49 58       	lddpc	r8,8000768c <xTaskRemoveFromEventList+0x64>
8000763c:	70 08       	ld.w	r8,r8[0x0]
8000763e:	58 08       	cp.w	r8,0
80007640:	c1 71       	brne	8000766e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80007642:	ee c6 ff fc 	sub	r6,r7,-4
80007646:	0c 9c       	mov	r12,r6
80007648:	f0 1f 00 10 	mcall	80007688 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000764c:	6e bc       	ld.w	r12,r7[0x2c]
8000764e:	49 18       	lddpc	r8,80007690 <xTaskRemoveFromEventList+0x68>
80007650:	70 08       	ld.w	r8,r8[0x0]
80007652:	10 3c       	cp.w	r12,r8
80007654:	e0 88 00 04 	brls	8000765c <xTaskRemoveFromEventList+0x34>
80007658:	48 e8       	lddpc	r8,80007690 <xTaskRemoveFromEventList+0x68>
8000765a:	91 0c       	st.w	r8[0x0],r12
8000765c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007660:	0c 9b       	mov	r11,r6
80007662:	48 d8       	lddpc	r8,80007694 <xTaskRemoveFromEventList+0x6c>
80007664:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007668:	f0 1f 00 0c 	mcall	80007698 <xTaskRemoveFromEventList+0x70>
8000766c:	c0 58       	rjmp	80007676 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000766e:	0c 9b       	mov	r11,r6
80007670:	48 bc       	lddpc	r12,8000769c <xTaskRemoveFromEventList+0x74>
80007672:	f0 1f 00 0a 	mcall	80007698 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007676:	48 b8       	lddpc	r8,800076a0 <xTaskRemoveFromEventList+0x78>
80007678:	70 08       	ld.w	r8,r8[0x0]
8000767a:	6e b9       	ld.w	r9,r7[0x2c]
8000767c:	70 b8       	ld.w	r8,r8[0x2c]
8000767e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80007680:	5f 2c       	srhs	r12
80007682:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007686:	00 00       	add	r0,r0
80007688:	80 00       	ld.sh	r0,r0[0x0]
8000768a:	6c 32       	ld.w	r2,r6[0xc]
8000768c:	00 00       	add	r0,r0
8000768e:	0d a4       	ld.ub	r4,r6[0x2]
80007690:	00 00       	add	r0,r0
80007692:	0d dc       	ld.ub	r12,r6[0x5]
80007694:	00 00       	add	r0,r0
80007696:	0c c0       	st.b	r6++,r0
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	6b e2       	ld.w	r2,r5[0x78]
8000769c:	00 00       	add	r0,r0
8000769e:	0d 78       	ld.ub	r8,--r6
800076a0:	00 00       	add	r0,r0
800076a2:	0d 74       	ld.ub	r4,--r6

800076a4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800076a4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800076a8:	4b 98       	lddpc	r8,8000778c <vTaskIncrementTick+0xe8>
800076aa:	70 08       	ld.w	r8,r8[0x0]
800076ac:	58 08       	cp.w	r8,0
800076ae:	c6 91       	brne	80007780 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800076b0:	4b 88       	lddpc	r8,80007790 <vTaskIncrementTick+0xec>
800076b2:	70 09       	ld.w	r9,r8[0x0]
800076b4:	2f f9       	sub	r9,-1
800076b6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800076b8:	70 08       	ld.w	r8,r8[0x0]
800076ba:	58 08       	cp.w	r8,0
800076bc:	c1 a1       	brne	800076f0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800076be:	4b 68       	lddpc	r8,80007794 <vTaskIncrementTick+0xf0>
800076c0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800076c2:	4b 69       	lddpc	r9,80007798 <vTaskIncrementTick+0xf4>
800076c4:	72 0b       	ld.w	r11,r9[0x0]
800076c6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800076c8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800076ca:	4b 59       	lddpc	r9,8000779c <vTaskIncrementTick+0xf8>
800076cc:	72 0a       	ld.w	r10,r9[0x0]
800076ce:	2f fa       	sub	r10,-1
800076d0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800076d2:	70 08       	ld.w	r8,r8[0x0]
800076d4:	70 08       	ld.w	r8,r8[0x0]
800076d6:	58 08       	cp.w	r8,0
800076d8:	c0 51       	brne	800076e2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800076da:	3f f9       	mov	r9,-1
800076dc:	4b 18       	lddpc	r8,800077a0 <vTaskIncrementTick+0xfc>
800076de:	91 09       	st.w	r8[0x0],r9
800076e0:	c0 88       	rjmp	800076f0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800076e2:	4a d8       	lddpc	r8,80007794 <vTaskIncrementTick+0xf0>
800076e4:	70 08       	ld.w	r8,r8[0x0]
800076e6:	70 38       	ld.w	r8,r8[0xc]
800076e8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800076ea:	70 19       	ld.w	r9,r8[0x4]
800076ec:	4a d8       	lddpc	r8,800077a0 <vTaskIncrementTick+0xfc>
800076ee:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800076f0:	4a 88       	lddpc	r8,80007790 <vTaskIncrementTick+0xec>
800076f2:	70 09       	ld.w	r9,r8[0x0]
800076f4:	4a b8       	lddpc	r8,800077a0 <vTaskIncrementTick+0xfc>
800076f6:	70 08       	ld.w	r8,r8[0x0]
800076f8:	10 39       	cp.w	r9,r8
800076fa:	c4 73       	brcs	80007788 <vTaskIncrementTick+0xe4>
800076fc:	4a 68       	lddpc	r8,80007794 <vTaskIncrementTick+0xf0>
800076fe:	70 08       	ld.w	r8,r8[0x0]
80007700:	70 08       	ld.w	r8,r8[0x0]
80007702:	58 08       	cp.w	r8,0
80007704:	c0 c0       	breq	8000771c <vTaskIncrementTick+0x78>
80007706:	4a 48       	lddpc	r8,80007794 <vTaskIncrementTick+0xf0>
80007708:	70 08       	ld.w	r8,r8[0x0]
8000770a:	70 38       	ld.w	r8,r8[0xc]
8000770c:	70 37       	ld.w	r7,r8[0xc]
8000770e:	6e 18       	ld.w	r8,r7[0x4]
80007710:	4a 09       	lddpc	r9,80007790 <vTaskIncrementTick+0xec>
80007712:	72 09       	ld.w	r9,r9[0x0]
80007714:	12 38       	cp.w	r8,r9
80007716:	e0 88 00 14 	brls	8000773e <vTaskIncrementTick+0x9a>
8000771a:	c0 e8       	rjmp	80007736 <vTaskIncrementTick+0x92>
8000771c:	3f f9       	mov	r9,-1
8000771e:	4a 18       	lddpc	r8,800077a0 <vTaskIncrementTick+0xfc>
80007720:	91 09       	st.w	r8[0x0],r9
80007722:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007726:	6a 08       	ld.w	r8,r5[0x0]
80007728:	70 38       	ld.w	r8,r8[0xc]
8000772a:	70 37       	ld.w	r7,r8[0xc]
8000772c:	6e 18       	ld.w	r8,r7[0x4]
8000772e:	64 09       	ld.w	r9,r2[0x0]
80007730:	12 38       	cp.w	r8,r9
80007732:	e0 88 00 0a 	brls	80007746 <vTaskIncrementTick+0xa2>
80007736:	49 b9       	lddpc	r9,800077a0 <vTaskIncrementTick+0xfc>
80007738:	93 08       	st.w	r9[0x0],r8
8000773a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000773e:	49 a4       	lddpc	r4,800077a4 <vTaskIncrementTick+0x100>
80007740:	49 a3       	lddpc	r3,800077a8 <vTaskIncrementTick+0x104>
80007742:	49 55       	lddpc	r5,80007794 <vTaskIncrementTick+0xf0>
80007744:	49 32       	lddpc	r2,80007790 <vTaskIncrementTick+0xec>
80007746:	ee c6 ff fc 	sub	r6,r7,-4
8000774a:	0c 9c       	mov	r12,r6
8000774c:	f0 1f 00 18 	mcall	800077ac <vTaskIncrementTick+0x108>
80007750:	6e a8       	ld.w	r8,r7[0x28]
80007752:	58 08       	cp.w	r8,0
80007754:	c0 50       	breq	8000775e <vTaskIncrementTick+0xba>
80007756:	ee cc ff e8 	sub	r12,r7,-24
8000775a:	f0 1f 00 15 	mcall	800077ac <vTaskIncrementTick+0x108>
8000775e:	6e bc       	ld.w	r12,r7[0x2c]
80007760:	68 08       	ld.w	r8,r4[0x0]
80007762:	10 3c       	cp.w	r12,r8
80007764:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007768:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000776c:	0c 9b       	mov	r11,r6
8000776e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80007772:	f0 1f 00 10 	mcall	800077b0 <vTaskIncrementTick+0x10c>
80007776:	6a 08       	ld.w	r8,r5[0x0]
80007778:	70 08       	ld.w	r8,r8[0x0]
8000777a:	58 08       	cp.w	r8,0
8000777c:	cd 51       	brne	80007726 <vTaskIncrementTick+0x82>
8000777e:	cc fb       	rjmp	8000771c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80007780:	48 d8       	lddpc	r8,800077b4 <vTaskIncrementTick+0x110>
80007782:	70 09       	ld.w	r9,r8[0x0]
80007784:	2f f9       	sub	r9,-1
80007786:	91 09       	st.w	r8[0x0],r9
80007788:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000778c:	00 00       	add	r0,r0
8000778e:	0d a4       	ld.ub	r4,r6[0x2]
80007790:	00 00       	add	r0,r0
80007792:	0d a0       	ld.ub	r0,r6[0x2]
80007794:	00 00       	add	r0,r0
80007796:	0c ac       	st.w	r6++,r12
80007798:	00 00       	add	r0,r0
8000779a:	0c bc       	st.h	r6++,r12
8000779c:	00 00       	add	r0,r0
8000779e:	0c b8       	st.h	r6++,r8
800077a0:	00 00       	add	r0,r0
800077a2:	05 50       	ld.sh	r0,--r2
800077a4:	00 00       	add	r0,r0
800077a6:	0d dc       	ld.ub	r12,r6[0x5]
800077a8:	00 00       	add	r0,r0
800077aa:	0c c0       	st.b	r6++,r0
800077ac:	80 00       	ld.sh	r0,r0[0x0]
800077ae:	6c 32       	ld.w	r2,r6[0xc]
800077b0:	80 00       	ld.sh	r0,r0[0x0]
800077b2:	6b e2       	ld.w	r2,r5[0x78]
800077b4:	00 00       	add	r0,r0
800077b6:	0c a4       	st.w	r6++,r4

800077b8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800077b8:	eb cd 40 c0 	pushm	r6-r7,lr
800077bc:	18 97       	mov	r7,r12
800077be:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800077c0:	f0 1f 00 15 	mcall	80007814 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800077c4:	6c 08       	ld.w	r8,r6[0x0]
800077c6:	5b f8       	cp.w	r8,-1
800077c8:	c0 31       	brne	800077ce <xTaskCheckForTimeOut+0x16>
800077ca:	30 07       	mov	r7,0
800077cc:	c1 f8       	rjmp	8000780a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800077ce:	49 39       	lddpc	r9,80007818 <xTaskCheckForTimeOut+0x60>
800077d0:	72 09       	ld.w	r9,r9[0x0]
800077d2:	6e 0a       	ld.w	r10,r7[0x0]
800077d4:	12 3a       	cp.w	r10,r9
800077d6:	c0 70       	breq	800077e4 <xTaskCheckForTimeOut+0x2c>
800077d8:	49 19       	lddpc	r9,8000781c <xTaskCheckForTimeOut+0x64>
800077da:	72 09       	ld.w	r9,r9[0x0]
800077dc:	6e 1a       	ld.w	r10,r7[0x4]
800077de:	12 3a       	cp.w	r10,r9
800077e0:	e0 88 00 14 	brls	80007808 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800077e4:	48 e9       	lddpc	r9,8000781c <xTaskCheckForTimeOut+0x64>
800077e6:	72 0a       	ld.w	r10,r9[0x0]
800077e8:	6e 19       	ld.w	r9,r7[0x4]
800077ea:	12 1a       	sub	r10,r9
800077ec:	14 38       	cp.w	r8,r10
800077ee:	e0 88 00 0d 	brls	80007808 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800077f2:	48 ba       	lddpc	r10,8000781c <xTaskCheckForTimeOut+0x64>
800077f4:	74 0a       	ld.w	r10,r10[0x0]
800077f6:	14 19       	sub	r9,r10
800077f8:	f2 08 00 08 	add	r8,r9,r8
800077fc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800077fe:	0e 9c       	mov	r12,r7
80007800:	f0 1f 00 08 	mcall	80007820 <xTaskCheckForTimeOut+0x68>
80007804:	30 07       	mov	r7,0
80007806:	c0 28       	rjmp	8000780a <xTaskCheckForTimeOut+0x52>
80007808:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000780a:	f0 1f 00 07 	mcall	80007824 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000780e:	0e 9c       	mov	r12,r7
80007810:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007814:	80 00       	ld.sh	r0,r0[0x0]
80007816:	6c ec       	ld.w	r12,r6[0x38]
80007818:	00 00       	add	r0,r0
8000781a:	0c b8       	st.h	r6++,r8
8000781c:	00 00       	add	r0,r0
8000781e:	0d a0       	ld.ub	r0,r6[0x2]
80007820:	80 00       	ld.sh	r0,r0[0x0]
80007822:	75 1c       	ld.w	r12,r10[0x44]
80007824:	80 00       	ld.sh	r0,r0[0x0]
80007826:	6d f8       	ld.w	r8,r6[0x7c]

80007828 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007828:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000782c:	f0 1f 00 05 	mcall	80007840 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007830:	48 58       	lddpc	r8,80007844 <xTaskGetTickCount+0x1c>
80007832:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80007834:	f0 1f 00 05 	mcall	80007848 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007838:	0e 9c       	mov	r12,r7
8000783a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000783e:	00 00       	add	r0,r0
80007840:	80 00       	ld.sh	r0,r0[0x0]
80007842:	6c ec       	ld.w	r12,r6[0x38]
80007844:	00 00       	add	r0,r0
80007846:	0d a0       	ld.ub	r0,r6[0x2]
80007848:	80 00       	ld.sh	r0,r0[0x0]
8000784a:	6d f8       	ld.w	r8,r6[0x7c]

8000784c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000784c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80007850:	f0 1f 00 2c 	mcall	80007900 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80007854:	4a c8       	lddpc	r8,80007904 <xTaskResumeAll+0xb8>
80007856:	70 09       	ld.w	r9,r8[0x0]
80007858:	20 19       	sub	r9,1
8000785a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000785c:	70 08       	ld.w	r8,r8[0x0]
8000785e:	58 08       	cp.w	r8,0
80007860:	c4 91       	brne	800078f2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80007862:	4a a8       	lddpc	r8,80007908 <xTaskResumeAll+0xbc>
80007864:	70 08       	ld.w	r8,r8[0x0]
80007866:	58 08       	cp.w	r8,0
80007868:	c4 50       	breq	800078f2 <xTaskResumeAll+0xa6>
8000786a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000786c:	4a 85       	lddpc	r5,8000790c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000786e:	4a 93       	lddpc	r3,80007910 <xTaskResumeAll+0xc4>
80007870:	4a 92       	lddpc	r2,80007914 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007872:	4a a1       	lddpc	r1,80007918 <xTaskResumeAll+0xcc>
80007874:	c1 e8       	rjmp	800078b0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80007876:	6a 38       	ld.w	r8,r5[0xc]
80007878:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000787a:	ee cc ff e8 	sub	r12,r7,-24
8000787e:	f0 1f 00 28 	mcall	8000791c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80007882:	ee c6 ff fc 	sub	r6,r7,-4
80007886:	0c 9c       	mov	r12,r6
80007888:	f0 1f 00 25 	mcall	8000791c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000788c:	6e bc       	ld.w	r12,r7[0x2c]
8000788e:	66 08       	ld.w	r8,r3[0x0]
80007890:	10 3c       	cp.w	r12,r8
80007892:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007896:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000789a:	0c 9b       	mov	r11,r6
8000789c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800078a0:	f0 1f 00 20 	mcall	80007920 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800078a4:	62 08       	ld.w	r8,r1[0x0]
800078a6:	6e b9       	ld.w	r9,r7[0x2c]
800078a8:	70 b8       	ld.w	r8,r8[0x2c]
800078aa:	10 39       	cp.w	r9,r8
800078ac:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800078b0:	6a 08       	ld.w	r8,r5[0x0]
800078b2:	58 08       	cp.w	r8,0
800078b4:	ce 11       	brne	80007876 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800078b6:	49 c8       	lddpc	r8,80007924 <xTaskResumeAll+0xd8>
800078b8:	70 08       	ld.w	r8,r8[0x0]
800078ba:	58 08       	cp.w	r8,0
800078bc:	c0 f0       	breq	800078da <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800078be:	49 a8       	lddpc	r8,80007924 <xTaskResumeAll+0xd8>
800078c0:	70 08       	ld.w	r8,r8[0x0]
800078c2:	58 08       	cp.w	r8,0
800078c4:	c1 10       	breq	800078e6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800078c6:	49 87       	lddpc	r7,80007924 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800078c8:	f0 1f 00 18 	mcall	80007928 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800078cc:	6e 08       	ld.w	r8,r7[0x0]
800078ce:	20 18       	sub	r8,1
800078d0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800078d2:	6e 08       	ld.w	r8,r7[0x0]
800078d4:	58 08       	cp.w	r8,0
800078d6:	cf 91       	brne	800078c8 <xTaskResumeAll+0x7c>
800078d8:	c0 78       	rjmp	800078e6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800078da:	58 14       	cp.w	r4,1
800078dc:	c0 50       	breq	800078e6 <xTaskResumeAll+0x9a>
800078de:	49 48       	lddpc	r8,8000792c <xTaskResumeAll+0xe0>
800078e0:	70 08       	ld.w	r8,r8[0x0]
800078e2:	58 18       	cp.w	r8,1
800078e4:	c0 71       	brne	800078f2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800078e6:	30 09       	mov	r9,0
800078e8:	49 18       	lddpc	r8,8000792c <xTaskResumeAll+0xe0>
800078ea:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800078ec:	d7 33       	scall
800078ee:	30 17       	mov	r7,1
800078f0:	c0 28       	rjmp	800078f4 <xTaskResumeAll+0xa8>
800078f2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800078f4:	f0 1f 00 0f 	mcall	80007930 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800078f8:	0e 9c       	mov	r12,r7
800078fa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800078fe:	00 00       	add	r0,r0
80007900:	80 00       	ld.sh	r0,r0[0x0]
80007902:	6c ec       	ld.w	r12,r6[0x38]
80007904:	00 00       	add	r0,r0
80007906:	0d a4       	ld.ub	r4,r6[0x2]
80007908:	00 00       	add	r0,r0
8000790a:	0d c0       	ld.ub	r0,r6[0x4]
8000790c:	00 00       	add	r0,r0
8000790e:	0d 78       	ld.ub	r8,--r6
80007910:	00 00       	add	r0,r0
80007912:	0d dc       	ld.ub	r12,r6[0x5]
80007914:	00 00       	add	r0,r0
80007916:	0c c0       	st.b	r6++,r0
80007918:	00 00       	add	r0,r0
8000791a:	0d 74       	ld.ub	r4,--r6
8000791c:	80 00       	ld.sh	r0,r0[0x0]
8000791e:	6c 32       	ld.w	r2,r6[0xc]
80007920:	80 00       	ld.sh	r0,r0[0x0]
80007922:	6b e2       	ld.w	r2,r5[0x78]
80007924:	00 00       	add	r0,r0
80007926:	0c a4       	st.w	r6++,r4
80007928:	80 00       	ld.sh	r0,r0[0x0]
8000792a:	76 a4       	ld.w	r4,r11[0x28]
8000792c:	00 00       	add	r0,r0
8000792e:	0d c4       	ld.ub	r4,r6[0x4]
80007930:	80 00       	ld.sh	r0,r0[0x0]
80007932:	6d f8       	ld.w	r8,r6[0x7c]

80007934 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80007934:	eb cd 40 80 	pushm	r7,lr
80007938:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000793a:	49 08       	lddpc	r8,80007978 <prvAddCurrentTaskToDelayedList+0x44>
8000793c:	70 08       	ld.w	r8,r8[0x0]
8000793e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80007940:	48 f8       	lddpc	r8,8000797c <prvAddCurrentTaskToDelayedList+0x48>
80007942:	70 08       	ld.w	r8,r8[0x0]
80007944:	10 3c       	cp.w	r12,r8
80007946:	c0 a2       	brcc	8000795a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007948:	48 c8       	lddpc	r8,80007978 <prvAddCurrentTaskToDelayedList+0x44>
8000794a:	70 0b       	ld.w	r11,r8[0x0]
8000794c:	48 d8       	lddpc	r8,80007980 <prvAddCurrentTaskToDelayedList+0x4c>
8000794e:	70 0c       	ld.w	r12,r8[0x0]
80007950:	2f cb       	sub	r11,-4
80007952:	f0 1f 00 0d 	mcall	80007984 <prvAddCurrentTaskToDelayedList+0x50>
80007956:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000795a:	48 88       	lddpc	r8,80007978 <prvAddCurrentTaskToDelayedList+0x44>
8000795c:	70 0b       	ld.w	r11,r8[0x0]
8000795e:	48 b8       	lddpc	r8,80007988 <prvAddCurrentTaskToDelayedList+0x54>
80007960:	70 0c       	ld.w	r12,r8[0x0]
80007962:	2f cb       	sub	r11,-4
80007964:	f0 1f 00 08 	mcall	80007984 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80007968:	48 98       	lddpc	r8,8000798c <prvAddCurrentTaskToDelayedList+0x58>
8000796a:	70 08       	ld.w	r8,r8[0x0]
8000796c:	10 37       	cp.w	r7,r8
8000796e:	c0 32       	brcc	80007974 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80007970:	48 78       	lddpc	r8,8000798c <prvAddCurrentTaskToDelayedList+0x58>
80007972:	91 07       	st.w	r8[0x0],r7
80007974:	e3 cd 80 80 	ldm	sp++,r7,pc
80007978:	00 00       	add	r0,r0
8000797a:	0d 74       	ld.ub	r4,--r6
8000797c:	00 00       	add	r0,r0
8000797e:	0d a0       	ld.ub	r0,r6[0x2]
80007980:	00 00       	add	r0,r0
80007982:	0c bc       	st.h	r6++,r12
80007984:	80 00       	ld.sh	r0,r0[0x0]
80007986:	6b fe       	ld.w	lr,r5[0x7c]
80007988:	00 00       	add	r0,r0
8000798a:	0c ac       	st.w	r6++,r12
8000798c:	00 00       	add	r0,r0
8000798e:	05 50       	ld.sh	r0,--r2

80007990 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80007990:	eb cd 40 c0 	pushm	r6-r7,lr
80007994:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80007996:	58 0c       	cp.w	r12,0
80007998:	c1 10       	breq	800079ba <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000799a:	f0 1f 00 0a 	mcall	800079c0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000799e:	48 a8       	lddpc	r8,800079c4 <vTaskDelay+0x34>
800079a0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079a2:	48 a8       	lddpc	r8,800079c8 <vTaskDelay+0x38>
800079a4:	70 0c       	ld.w	r12,r8[0x0]
800079a6:	2f cc       	sub	r12,-4
800079a8:	f0 1f 00 09 	mcall	800079cc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800079ac:	ee 06 00 0c 	add	r12,r7,r6
800079b0:	f0 1f 00 08 	mcall	800079d0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800079b4:	f0 1f 00 08 	mcall	800079d4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800079b8:	c0 21       	brne	800079bc <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800079ba:	d7 33       	scall
800079bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800079c0:	80 00       	ld.sh	r0,r0[0x0]
800079c2:	74 90       	ld.w	r0,r10[0x24]
800079c4:	00 00       	add	r0,r0
800079c6:	0d a0       	ld.ub	r0,r6[0x2]
800079c8:	00 00       	add	r0,r0
800079ca:	0d 74       	ld.ub	r4,--r6
800079cc:	80 00       	ld.sh	r0,r0[0x0]
800079ce:	6c 32       	ld.w	r2,r6[0xc]
800079d0:	80 00       	ld.sh	r0,r0[0x0]
800079d2:	79 34       	ld.w	r4,r12[0x4c]
800079d4:	80 00       	ld.sh	r0,r0[0x0]
800079d6:	78 4c       	ld.w	r12,r12[0x10]

800079d8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800079d8:	eb cd 40 c0 	pushm	r6-r7,lr
800079dc:	18 96       	mov	r6,r12
800079de:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800079e0:	f0 1f 00 18 	mcall	80007a40 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800079e4:	6c 08       	ld.w	r8,r6[0x0]
800079e6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800079e8:	49 79       	lddpc	r9,80007a44 <vTaskDelayUntil+0x6c>
800079ea:	72 09       	ld.w	r9,r9[0x0]
800079ec:	12 38       	cp.w	r8,r9
800079ee:	e0 88 00 0c 	brls	80007a06 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800079f2:	0e 38       	cp.w	r8,r7
800079f4:	e0 88 00 22 	brls	80007a38 <vTaskDelayUntil+0x60>
800079f8:	49 38       	lddpc	r8,80007a44 <vTaskDelayUntil+0x6c>
800079fa:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800079fc:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800079fe:	10 37       	cp.w	r7,r8
80007a00:	e0 88 00 14 	brls	80007a28 <vTaskDelayUntil+0x50>
80007a04:	c0 a8       	rjmp	80007a18 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007a06:	0e 38       	cp.w	r8,r7
80007a08:	e0 8b 00 16 	brhi	80007a34 <vTaskDelayUntil+0x5c>
80007a0c:	48 e8       	lddpc	r8,80007a44 <vTaskDelayUntil+0x6c>
80007a0e:	70 08       	ld.w	r8,r8[0x0]
80007a10:	10 37       	cp.w	r7,r8
80007a12:	e0 8b 00 11 	brhi	80007a34 <vTaskDelayUntil+0x5c>
80007a16:	c1 18       	rjmp	80007a38 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a18:	48 c8       	lddpc	r8,80007a48 <vTaskDelayUntil+0x70>
80007a1a:	70 0c       	ld.w	r12,r8[0x0]
80007a1c:	2f cc       	sub	r12,-4
80007a1e:	f0 1f 00 0c 	mcall	80007a4c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a22:	0e 9c       	mov	r12,r7
80007a24:	f0 1f 00 0b 	mcall	80007a50 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007a28:	f0 1f 00 0b 	mcall	80007a54 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a2c:	c0 81       	brne	80007a3c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007a2e:	d7 33       	scall
80007a30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a34:	8d 07       	st.w	r6[0x0],r7
80007a36:	cf 1b       	rjmp	80007a18 <vTaskDelayUntil+0x40>
80007a38:	8d 07       	st.w	r6[0x0],r7
80007a3a:	cf 7b       	rjmp	80007a28 <vTaskDelayUntil+0x50>
80007a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a40:	80 00       	ld.sh	r0,r0[0x0]
80007a42:	74 90       	ld.w	r0,r10[0x24]
80007a44:	00 00       	add	r0,r0
80007a46:	0d a0       	ld.ub	r0,r6[0x2]
80007a48:	00 00       	add	r0,r0
80007a4a:	0d 74       	ld.ub	r4,--r6
80007a4c:	80 00       	ld.sh	r0,r0[0x0]
80007a4e:	6c 32       	ld.w	r2,r6[0xc]
80007a50:	80 00       	ld.sh	r0,r0[0x0]
80007a52:	79 34       	ld.w	r4,r12[0x4c]
80007a54:	80 00       	ld.sh	r0,r0[0x0]
80007a56:	78 4c       	ld.w	r12,r12[0x10]

80007a58 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007a58:	eb cd 40 c0 	pushm	r6-r7,lr
80007a5c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007a5e:	48 e7       	lddpc	r7,80007a94 <vTaskPlaceOnEventList+0x3c>
80007a60:	6e 0b       	ld.w	r11,r7[0x0]
80007a62:	2e 8b       	sub	r11,-24
80007a64:	f0 1f 00 0d 	mcall	80007a98 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a68:	6e 0c       	ld.w	r12,r7[0x0]
80007a6a:	2f cc       	sub	r12,-4
80007a6c:	f0 1f 00 0c 	mcall	80007a9c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007a70:	5b f6       	cp.w	r6,-1
80007a72:	c0 81       	brne	80007a82 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a74:	6e 0b       	ld.w	r11,r7[0x0]
80007a76:	2f cb       	sub	r11,-4
80007a78:	48 ac       	lddpc	r12,80007aa0 <vTaskPlaceOnEventList+0x48>
80007a7a:	f0 1f 00 0b 	mcall	80007aa4 <vTaskPlaceOnEventList+0x4c>
80007a7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007a82:	48 a8       	lddpc	r8,80007aa8 <vTaskPlaceOnEventList+0x50>
80007a84:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a86:	ec 0c 00 0c 	add	r12,r6,r12
80007a8a:	f0 1f 00 09 	mcall	80007aac <vTaskPlaceOnEventList+0x54>
80007a8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a92:	00 00       	add	r0,r0
80007a94:	00 00       	add	r0,r0
80007a96:	0d 74       	ld.ub	r4,--r6
80007a98:	80 00       	ld.sh	r0,r0[0x0]
80007a9a:	6b fe       	ld.w	lr,r5[0x7c]
80007a9c:	80 00       	ld.sh	r0,r0[0x0]
80007a9e:	6c 32       	ld.w	r2,r6[0xc]
80007aa0:	00 00       	add	r0,r0
80007aa2:	0d c8       	ld.ub	r8,r6[0x4]
80007aa4:	80 00       	ld.sh	r0,r0[0x0]
80007aa6:	6b e2       	ld.w	r2,r5[0x78]
80007aa8:	00 00       	add	r0,r0
80007aaa:	0d a0       	ld.ub	r0,r6[0x2]
80007aac:	80 00       	ld.sh	r0,r0[0x0]
80007aae:	79 34       	ld.w	r4,r12[0x4c]

80007ab0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007ab0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007ab4:	49 67       	lddpc	r7,80007b0c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007ab6:	49 74       	lddpc	r4,80007b10 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007ab8:	49 73       	lddpc	r3,80007b14 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007aba:	49 85       	lddpc	r5,80007b18 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007abc:	6e 08       	ld.w	r8,r7[0x0]
80007abe:	58 08       	cp.w	r8,0
80007ac0:	c1 e0       	breq	80007afc <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007ac2:	f0 1f 00 17 	mcall	80007b1c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007ac6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007ac8:	f0 1f 00 16 	mcall	80007b20 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007acc:	58 06       	cp.w	r6,0
80007ace:	c1 70       	breq	80007afc <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007ad0:	f0 1f 00 15 	mcall	80007b24 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007ad4:	68 38       	ld.w	r8,r4[0xc]
80007ad6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007ad8:	ec cc ff fc 	sub	r12,r6,-4
80007adc:	f0 1f 00 13 	mcall	80007b28 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007ae0:	66 08       	ld.w	r8,r3[0x0]
80007ae2:	20 18       	sub	r8,1
80007ae4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007ae6:	6e 08       	ld.w	r8,r7[0x0]
80007ae8:	20 18       	sub	r8,1
80007aea:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007aec:	f0 1f 00 10 	mcall	80007b2c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007af0:	6c cc       	ld.w	r12,r6[0x30]
80007af2:	f0 1f 00 10 	mcall	80007b30 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007af6:	0c 9c       	mov	r12,r6
80007af8:	f0 1f 00 0e 	mcall	80007b30 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007afc:	6a 08       	ld.w	r8,r5[0x0]
80007afe:	58 18       	cp.w	r8,1
80007b00:	e0 88 00 03 	brls	80007b06 <prvIdleTask+0x56>
			{
				taskYIELD();
80007b04:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007b06:	f0 1f 00 0c 	mcall	80007b34 <prvIdleTask+0x84>
		}
		#endif
	}
80007b0a:	cd 9b       	rjmp	80007abc <prvIdleTask+0xc>
80007b0c:	00 00       	add	r0,r0
80007b0e:	0c b4       	st.h	r6++,r4
80007b10:	00 00       	add	r0,r0
80007b12:	0d 60       	ld.uh	r0,--r6
80007b14:	00 00       	add	r0,r0
80007b16:	0d c0       	ld.ub	r0,r6[0x4]
80007b18:	00 00       	add	r0,r0
80007b1a:	0c c0       	st.b	r6++,r0
80007b1c:	80 00       	ld.sh	r0,r0[0x0]
80007b1e:	74 90       	ld.w	r0,r10[0x24]
80007b20:	80 00       	ld.sh	r0,r0[0x0]
80007b22:	78 4c       	ld.w	r12,r12[0x10]
80007b24:	80 00       	ld.sh	r0,r0[0x0]
80007b26:	6c ec       	ld.w	r12,r6[0x38]
80007b28:	80 00       	ld.sh	r0,r0[0x0]
80007b2a:	6c 32       	ld.w	r2,r6[0xc]
80007b2c:	80 00       	ld.sh	r0,r0[0x0]
80007b2e:	6d f8       	ld.w	r8,r6[0x7c]
80007b30:	80 00       	ld.sh	r0,r0[0x0]
80007b32:	6f 30       	ld.w	r0,r7[0x4c]
80007b34:	80 00       	ld.sh	r0,r0[0x0]
80007b36:	20 2c       	sub	r12,2

80007b38 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007b38:	d4 31       	pushm	r0-r7,lr
80007b3a:	20 1d       	sub	sp,4
80007b3c:	fa c4 ff d8 	sub	r4,sp,-40
80007b40:	50 0c       	stdsp	sp[0x0],r12
80007b42:	16 91       	mov	r1,r11
80007b44:	14 97       	mov	r7,r10
80007b46:	12 90       	mov	r0,r9
80007b48:	10 93       	mov	r3,r8
80007b4a:	68 02       	ld.w	r2,r4[0x0]
80007b4c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007b4e:	34 8c       	mov	r12,72
80007b50:	f0 1f 00 5c 	mcall	80007cc0 <xTaskGenericCreate+0x188>
80007b54:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007b56:	c0 31       	brne	80007b5c <xTaskGenericCreate+0x24>
80007b58:	3f fc       	mov	r12,-1
80007b5a:	ca f8       	rjmp	80007cb8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007b5c:	58 06       	cp.w	r6,0
80007b5e:	e0 81 00 af 	brne	80007cbc <xTaskGenericCreate+0x184>
80007b62:	0e 9c       	mov	r12,r7
80007b64:	5c 7c       	castu.h	r12
80007b66:	a3 6c       	lsl	r12,0x2
80007b68:	f0 1f 00 56 	mcall	80007cc0 <xTaskGenericCreate+0x188>
80007b6c:	18 96       	mov	r6,r12
80007b6e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007b70:	c0 61       	brne	80007b7c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007b72:	0a 9c       	mov	r12,r5
80007b74:	f0 1f 00 54 	mcall	80007cc4 <xTaskGenericCreate+0x18c>
80007b78:	3f fc       	mov	r12,-1
80007b7a:	c9 f8       	rjmp	80007cb8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007b7c:	5c 77       	castu.h	r7
80007b7e:	ee 0a 15 02 	lsl	r10,r7,0x2
80007b82:	e0 6b 00 a5 	mov	r11,165
80007b86:	0c 9c       	mov	r12,r6
80007b88:	f0 1f 00 50 	mcall	80007cc8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007b8c:	ee c6 00 01 	sub	r6,r7,1
80007b90:	6a c8       	ld.w	r8,r5[0x30]
80007b92:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007b96:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007b9a:	31 0a       	mov	r10,16
80007b9c:	02 9b       	mov	r11,r1
80007b9e:	ea cc ff cc 	sub	r12,r5,-52
80007ba2:	f0 1f 00 4b 	mcall	80007ccc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007ba6:	30 08       	mov	r8,0
80007ba8:	eb 68 00 43 	st.b	r5[67],r8
80007bac:	58 73       	cp.w	r3,7
80007bae:	e6 07 17 80 	movls	r7,r3
80007bb2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007bb6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007bb8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007bbc:	ea c4 ff fc 	sub	r4,r5,-4
80007bc0:	08 9c       	mov	r12,r4
80007bc2:	f0 1f 00 44 	mcall	80007cd0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007bc6:	ea cc ff e8 	sub	r12,r5,-24
80007bca:	f0 1f 00 42 	mcall	80007cd0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007bce:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007bd0:	ee 07 11 08 	rsub	r7,r7,8
80007bd4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007bd6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007bd8:	00 9a       	mov	r10,r0
80007bda:	40 0b       	lddsp	r11,sp[0x0]
80007bdc:	0c 9c       	mov	r12,r6
80007bde:	f0 1f 00 3e 	mcall	80007cd4 <xTaskGenericCreate+0x19c>
80007be2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007be4:	58 02       	cp.w	r2,0
80007be6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007bea:	f0 1f 00 3c 	mcall	80007cd8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007bee:	4b c8       	lddpc	r8,80007cdc <xTaskGenericCreate+0x1a4>
80007bf0:	70 09       	ld.w	r9,r8[0x0]
80007bf2:	2f f9       	sub	r9,-1
80007bf4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007bf6:	4b b8       	lddpc	r8,80007ce0 <xTaskGenericCreate+0x1a8>
80007bf8:	70 08       	ld.w	r8,r8[0x0]
80007bfa:	58 08       	cp.w	r8,0
80007bfc:	c2 61       	brne	80007c48 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007bfe:	4b 98       	lddpc	r8,80007ce0 <xTaskGenericCreate+0x1a8>
80007c00:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007c02:	4b 78       	lddpc	r8,80007cdc <xTaskGenericCreate+0x1a4>
80007c04:	70 08       	ld.w	r8,r8[0x0]
80007c06:	58 18       	cp.w	r8,1
80007c08:	c2 b1       	brne	80007c5e <xTaskGenericCreate+0x126>
80007c0a:	4b 77       	lddpc	r7,80007ce4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007c0c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007c10:	0e 9c       	mov	r12,r7
80007c12:	f0 1f 00 36 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>
80007c16:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007c18:	0c 37       	cp.w	r7,r6
80007c1a:	cf b1       	brne	80007c10 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007c1c:	4b 47       	lddpc	r7,80007cec <xTaskGenericCreate+0x1b4>
80007c1e:	0e 9c       	mov	r12,r7
80007c20:	f0 1f 00 32 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007c24:	4b 36       	lddpc	r6,80007cf0 <xTaskGenericCreate+0x1b8>
80007c26:	0c 9c       	mov	r12,r6
80007c28:	f0 1f 00 30 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007c2c:	4b 2c       	lddpc	r12,80007cf4 <xTaskGenericCreate+0x1bc>
80007c2e:	f0 1f 00 2f 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007c32:	4b 2c       	lddpc	r12,80007cf8 <xTaskGenericCreate+0x1c0>
80007c34:	f0 1f 00 2d 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007c38:	4b 1c       	lddpc	r12,80007cfc <xTaskGenericCreate+0x1c4>
80007c3a:	f0 1f 00 2c 	mcall	80007ce8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007c3e:	4b 18       	lddpc	r8,80007d00 <xTaskGenericCreate+0x1c8>
80007c40:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007c42:	4b 18       	lddpc	r8,80007d04 <xTaskGenericCreate+0x1cc>
80007c44:	91 06       	st.w	r8[0x0],r6
80007c46:	c0 c8       	rjmp	80007c5e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007c48:	4b 08       	lddpc	r8,80007d08 <xTaskGenericCreate+0x1d0>
80007c4a:	70 08       	ld.w	r8,r8[0x0]
80007c4c:	58 08       	cp.w	r8,0
80007c4e:	c0 81       	brne	80007c5e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007c50:	4a 48       	lddpc	r8,80007ce0 <xTaskGenericCreate+0x1a8>
80007c52:	70 08       	ld.w	r8,r8[0x0]
80007c54:	70 b8       	ld.w	r8,r8[0x2c]
80007c56:	10 33       	cp.w	r3,r8
80007c58:	c0 33       	brcs	80007c5e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007c5a:	4a 28       	lddpc	r8,80007ce0 <xTaskGenericCreate+0x1a8>
80007c5c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007c5e:	6a b8       	ld.w	r8,r5[0x2c]
80007c60:	4a b9       	lddpc	r9,80007d0c <xTaskGenericCreate+0x1d4>
80007c62:	72 09       	ld.w	r9,r9[0x0]
80007c64:	12 38       	cp.w	r8,r9
80007c66:	e0 88 00 04 	brls	80007c6e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007c6a:	4a 99       	lddpc	r9,80007d0c <xTaskGenericCreate+0x1d4>
80007c6c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007c6e:	4a 98       	lddpc	r8,80007d10 <xTaskGenericCreate+0x1d8>
80007c70:	70 09       	ld.w	r9,r8[0x0]
80007c72:	2f f9       	sub	r9,-1
80007c74:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007c76:	6a b8       	ld.w	r8,r5[0x2c]
80007c78:	4a 79       	lddpc	r9,80007d14 <xTaskGenericCreate+0x1dc>
80007c7a:	72 09       	ld.w	r9,r9[0x0]
80007c7c:	12 38       	cp.w	r8,r9
80007c7e:	e0 88 00 04 	brls	80007c86 <xTaskGenericCreate+0x14e>
80007c82:	4a 59       	lddpc	r9,80007d14 <xTaskGenericCreate+0x1dc>
80007c84:	93 08       	st.w	r9[0x0],r8
80007c86:	6a bc       	ld.w	r12,r5[0x2c]
80007c88:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007c8c:	08 9b       	mov	r11,r4
80007c8e:	49 68       	lddpc	r8,80007ce4 <xTaskGenericCreate+0x1ac>
80007c90:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007c94:	f0 1f 00 21 	mcall	80007d18 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007c98:	f0 1f 00 21 	mcall	80007d1c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007c9c:	49 b8       	lddpc	r8,80007d08 <xTaskGenericCreate+0x1d0>
80007c9e:	70 08       	ld.w	r8,r8[0x0]
80007ca0:	58 08       	cp.w	r8,0
80007ca2:	c0 a0       	breq	80007cb6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007ca4:	48 f8       	lddpc	r8,80007ce0 <xTaskGenericCreate+0x1a8>
80007ca6:	70 08       	ld.w	r8,r8[0x0]
80007ca8:	70 b8       	ld.w	r8,r8[0x2c]
80007caa:	10 33       	cp.w	r3,r8
80007cac:	e0 88 00 05 	brls	80007cb6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007cb0:	d7 33       	scall
80007cb2:	30 1c       	mov	r12,1
80007cb4:	c0 28       	rjmp	80007cb8 <xTaskGenericCreate+0x180>
80007cb6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007cb8:	2f fd       	sub	sp,-4
80007cba:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007cbc:	99 c6       	st.w	r12[0x30],r6
80007cbe:	c5 fb       	rjmp	80007b7c <xTaskGenericCreate+0x44>
80007cc0:	80 00       	ld.sh	r0,r0[0x0]
80007cc2:	6f 58       	ld.w	r8,r7[0x54]
80007cc4:	80 00       	ld.sh	r0,r0[0x0]
80007cc6:	6f 30       	ld.w	r0,r7[0x4c]
80007cc8:	80 00       	ld.sh	r0,r0[0x0]
80007cca:	88 ee       	ld.uh	lr,r4[0xc]
80007ccc:	80 00       	ld.sh	r0,r0[0x0]
80007cce:	8c 18       	ld.sh	r8,r6[0x2]
80007cd0:	80 00       	ld.sh	r0,r0[0x0]
80007cd2:	6b dc       	ld.w	r12,r5[0x74]
80007cd4:	80 00       	ld.sh	r0,r0[0x0]
80007cd6:	6c 58       	ld.w	r8,r6[0x14]
80007cd8:	80 00       	ld.sh	r0,r0[0x0]
80007cda:	6c ec       	ld.w	r12,r6[0x38]
80007cdc:	00 00       	add	r0,r0
80007cde:	0d c0       	ld.ub	r0,r6[0x4]
80007ce0:	00 00       	add	r0,r0
80007ce2:	0d 74       	ld.ub	r4,--r6
80007ce4:	00 00       	add	r0,r0
80007ce6:	0c c0       	st.b	r6++,r0
80007ce8:	80 00       	ld.sh	r0,r0[0x0]
80007cea:	6b c8       	ld.w	r8,r5[0x70]
80007cec:	00 00       	add	r0,r0
80007cee:	0d 8c       	ld.ub	r12,r6[0x0]
80007cf0:	00 00       	add	r0,r0
80007cf2:	0d a8       	ld.ub	r8,r6[0x2]
80007cf4:	00 00       	add	r0,r0
80007cf6:	0d 78       	ld.ub	r8,--r6
80007cf8:	00 00       	add	r0,r0
80007cfa:	0d 60       	ld.uh	r0,--r6
80007cfc:	00 00       	add	r0,r0
80007cfe:	0d c8       	ld.ub	r8,r6[0x4]
80007d00:	00 00       	add	r0,r0
80007d02:	0c ac       	st.w	r6++,r12
80007d04:	00 00       	add	r0,r0
80007d06:	0c bc       	st.h	r6++,r12
80007d08:	00 00       	add	r0,r0
80007d0a:	0c b0       	st.h	r6++,r0
80007d0c:	00 00       	add	r0,r0
80007d0e:	0c a8       	st.w	r6++,r8
80007d10:	00 00       	add	r0,r0
80007d12:	0d bc       	ld.ub	r12,r6[0x3]
80007d14:	00 00       	add	r0,r0
80007d16:	0d dc       	ld.ub	r12,r6[0x5]
80007d18:	80 00       	ld.sh	r0,r0[0x0]
80007d1a:	6b e2       	ld.w	r2,r5[0x78]
80007d1c:	80 00       	ld.sh	r0,r0[0x0]
80007d1e:	6d f8       	ld.w	r8,r6[0x7c]

80007d20 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007d20:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007d22:	30 09       	mov	r9,0
80007d24:	1a d9       	st.w	--sp,r9
80007d26:	1a d9       	st.w	--sp,r9
80007d28:	1a d9       	st.w	--sp,r9
80007d2a:	12 98       	mov	r8,r9
80007d2c:	e0 6a 01 00 	mov	r10,256
80007d30:	48 9b       	lddpc	r11,80007d54 <vTaskStartScheduler+0x34>
80007d32:	48 ac       	lddpc	r12,80007d58 <vTaskStartScheduler+0x38>
80007d34:	f0 1f 00 0a 	mcall	80007d5c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007d38:	2f dd       	sub	sp,-12
80007d3a:	58 1c       	cp.w	r12,1
80007d3c:	c0 a1       	brne	80007d50 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007d3e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007d40:	30 19       	mov	r9,1
80007d42:	48 88       	lddpc	r8,80007d60 <vTaskStartScheduler+0x40>
80007d44:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007d46:	30 09       	mov	r9,0
80007d48:	48 78       	lddpc	r8,80007d64 <vTaskStartScheduler+0x44>
80007d4a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007d4c:	f0 1f 00 07 	mcall	80007d68 <vTaskStartScheduler+0x48>
80007d50:	d8 02       	popm	pc
80007d52:	00 00       	add	r0,r0
80007d54:	80 00       	ld.sh	r0,r0[0x0]
80007d56:	ed 78 80 00 	stcond	r6[-32768],r8
80007d5a:	7a b0       	ld.w	r0,sp[0x2c]
80007d5c:	80 00       	ld.sh	r0,r0[0x0]
80007d5e:	7b 38       	ld.w	r8,sp[0x4c]
80007d60:	00 00       	add	r0,r0
80007d62:	0c b0       	st.h	r6++,r0
80007d64:	00 00       	add	r0,r0
80007d66:	0d a0       	ld.ub	r0,r6[0x2]
80007d68:	80 00       	ld.sh	r0,r0[0x0]
80007d6a:	6c fc       	ld.w	r12,r6[0x3c]

80007d6c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007d6c:	16 cc       	st.b	r11++,r12
	return str;
}
80007d6e:	5e fb       	retal	r11

80007d70 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007d70:	eb cd 40 c0 	pushm	r6-r7,lr
80007d74:	20 3d       	sub	sp,12
80007d76:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007d78:	30 06       	mov	r6,0
80007d7a:	30 07       	mov	r7,0
80007d7c:	fa e7 00 00 	st.d	sp[0],r6
80007d80:	30 0c       	mov	r12,0
80007d82:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007d84:	58 08       	cp.w	r8,0
80007d86:	c1 30       	breq	80007dac <PrintHex+0x3c>
80007d88:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007d8a:	1a 9c       	mov	r12,sp
80007d8c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007d90:	58 9e       	cp.w	lr,9
80007d92:	e0 8a 00 04 	brle	80007d9a <PrintHex+0x2a>
80007d96:	2c 9e       	sub	lr,-55
80007d98:	c0 48       	rjmp	80007da0 <PrintHex+0x30>
80007d9a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007d9e:	2d 0e       	sub	lr,-48
80007da0:	f8 09 0b 0e 	st.b	r12[r9],lr
80007da4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007da6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007da8:	cf 21       	brne	80007d8c <PrintHex+0x1c>
80007daa:	c0 48       	rjmp	80007db2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007dac:	33 08       	mov	r8,48
80007dae:	ba 88       	st.b	sp[0x0],r8
80007db0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007db2:	f6 09 01 08 	sub	r8,r11,r9
80007db6:	58 08       	cp.w	r8,0
80007db8:	e0 8a 00 13 	brle	80007dde <PrintHex+0x6e>
	{
		char num = len - cnt;
80007dbc:	12 1b       	sub	r11,r9
80007dbe:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007dc2:	18 9e       	mov	lr,r12
80007dc4:	58 0c       	cp.w	r12,0
80007dc6:	e0 8a 00 0c 	brle	80007dde <PrintHex+0x6e>
80007dca:	1a 9b       	mov	r11,sp
80007dcc:	12 0b       	add	r11,r9
80007dce:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007dd0:	33 07       	mov	r7,48
80007dd2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007dd4:	2f f8       	sub	r8,-1
80007dd6:	1c 38       	cp.w	r8,lr
80007dd8:	cf d5       	brlt	80007dd2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007dda:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007dde:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007de2:	f0 cb ff ff 	sub	r11,r8,-1
80007de6:	58 0b       	cp.w	r11,0
80007de8:	e0 8a 00 19 	brle	80007e1a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007dec:	fa cb ff f4 	sub	r11,sp,-12
80007df0:	f6 09 00 09 	add	r9,r11,r9
80007df4:	37 8b       	mov	r11,120
80007df6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007dfa:	fa c9 ff f4 	sub	r9,sp,-12
80007dfe:	10 09       	add	r9,r8
80007e00:	33 0b       	mov	r11,48
80007e02:	f3 6b ff f4 	st.b	r9[-12],r11
80007e06:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e0a:	fa ce 00 01 	sub	lr,sp,1
80007e0e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007e10:	11 8b       	ld.ub	r11,r8[0x0]
80007e12:	12 cb       	st.b	r9++,r11
80007e14:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007e16:	1c 38       	cp.w	r8,lr
80007e18:	cf c1       	brne	80007e10 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007e1a:	14 9c       	mov	r12,r10
80007e1c:	2f dd       	sub	sp,-12
80007e1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007e22 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007e22:	d4 21       	pushm	r4-r7,lr
80007e24:	20 3d       	sub	sp,12
80007e26:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007e28:	30 06       	mov	r6,0
80007e2a:	30 07       	mov	r7,0
80007e2c:	fa e7 00 00 	st.d	sp[0],r6
80007e30:	30 0c       	mov	r12,0
80007e32:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007e34:	58 08       	cp.w	r8,0
80007e36:	c0 35       	brlt	80007e3c <PrintDec+0x1a>
80007e38:	14 97       	mov	r7,r10
80007e3a:	c0 58       	rjmp	80007e44 <PrintDec+0x22>
	{
		*p++ = '-';
80007e3c:	14 97       	mov	r7,r10
80007e3e:	32 d9       	mov	r9,45
80007e40:	0e c9       	st.b	r7++,r9
		i = -i;
80007e42:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007e44:	58 08       	cp.w	r8,0
80007e46:	c0 51       	brne	80007e50 <PrintDec+0x2e>
80007e48:	33 08       	mov	r8,48
80007e4a:	ba 88       	st.b	sp[0x0],r8
80007e4c:	30 1e       	mov	lr,1
80007e4e:	c2 f8       	rjmp	80007eac <PrintDec+0x8a>
	
	int ten = i%10;
80007e50:	e0 65 66 67 	mov	r5,26215
80007e54:	ea 15 66 66 	orh	r5,0x6666
80007e58:	f0 05 04 44 	muls.d	r4,r8,r5
80007e5c:	ea 0c 14 02 	asr	r12,r5,0x2
80007e60:	f0 09 14 1f 	asr	r9,r8,0x1f
80007e64:	f8 09 01 09 	sub	r9,r12,r9
80007e68:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007e6c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007e70:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007e72:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007e74:	e0 66 66 67 	mov	r6,26215
80007e78:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007e7c:	2d 09       	sub	r9,-48
80007e7e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007e82:	2f fe       	sub	lr,-1
		i /= 10;
80007e84:	f0 06 04 44 	muls.d	r4,r8,r6
80007e88:	ea 09 14 02 	asr	r9,r5,0x2
80007e8c:	bf 58       	asr	r8,0x1f
80007e8e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007e92:	f0 06 04 44 	muls.d	r4,r8,r6
80007e96:	ea 09 14 02 	asr	r9,r5,0x2
80007e9a:	f0 05 14 1f 	asr	r5,r8,0x1f
80007e9e:	0a 19       	sub	r9,r5
80007ea0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ea4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007ea8:	58 08       	cp.w	r8,0
80007eaa:	ce 91       	brne	80007e7c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007eac:	f6 0e 01 08 	sub	r8,r11,lr
80007eb0:	58 08       	cp.w	r8,0
80007eb2:	e0 89 00 06 	brgt	80007ebe <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007eb6:	58 0e       	cp.w	lr,0
80007eb8:	e0 89 00 14 	brgt	80007ee0 <PrintDec+0xbe>
80007ebc:	c1 d8       	rjmp	80007ef6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007ebe:	1c 1b       	sub	r11,lr
80007ec0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007ec2:	16 9c       	mov	r12,r11
80007ec4:	58 0b       	cp.w	r11,0
80007ec6:	fe 9a ff f8 	brle	80007eb6 <PrintDec+0x94>
80007eca:	1a 99       	mov	r9,sp
80007ecc:	1c 09       	add	r9,lr
80007ece:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007ed0:	33 06       	mov	r6,48
80007ed2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007ed4:	2f f8       	sub	r8,-1
80007ed6:	18 38       	cp.w	r8,r12
80007ed8:	cf d5       	brlt	80007ed2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007eda:	f6 0e 00 0e 	add	lr,r11,lr
80007ede:	ce cb       	rjmp	80007eb6 <PrintDec+0x94>
80007ee0:	fa c8 ff f4 	sub	r8,sp,-12
80007ee4:	1c 08       	add	r8,lr
80007ee6:	20 d8       	sub	r8,13
80007ee8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007eec:	11 89       	ld.ub	r9,r8[0x0]
80007eee:	0e c9       	st.b	r7++,r9
80007ef0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007ef2:	16 38       	cp.w	r8,r11
80007ef4:	cf c1       	brne	80007eec <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007ef6:	14 9c       	mov	r12,r10
80007ef8:	2f dd       	sub	sp,-12
80007efa:	d8 22       	popm	r4-r7,pc

80007efc <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007efc:	d4 31       	pushm	r0-r7,lr
80007efe:	fa cd 02 08 	sub	sp,sp,520
80007f02:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007f04:	e0 6a 01 00 	mov	r10,256
80007f08:	30 0b       	mov	r11,0
80007f0a:	fa cc fe f8 	sub	r12,sp,-264
80007f0e:	f0 1f 00 4e 	mcall	80008044 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007f12:	fa c4 fd d4 	sub	r4,sp,-556
80007f16:	30 0a       	mov	r10,0
80007f18:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f1a:	fa c3 ff fc 	sub	r3,sp,-4
80007f1e:	e0 61 01 00 	mov	r1,256
80007f22:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007f24:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007f26:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f2a:	02 9a       	mov	r10,r1
80007f2c:	00 9b       	mov	r11,r0
80007f2e:	06 9c       	mov	r12,r3
80007f30:	f0 1f 00 45 	mcall	80008044 <log+0x148>
			
					if(*str == '%')
80007f34:	0f 88       	ld.ub	r8,r7[0x0]
80007f36:	e4 08 18 00 	cp.b	r8,r2
80007f3a:	c5 71       	brne	80007fe8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007f3c:	ee c8 ff ff 	sub	r8,r7,-1
80007f40:	11 89       	ld.ub	r9,r8[0x0]
80007f42:	4c 2a       	lddpc	r10,80008048 <log+0x14c>
80007f44:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007f46:	23 09       	sub	r9,48
80007f48:	30 9a       	mov	r10,9
80007f4a:	f4 09 18 00 	cp.b	r9,r10
80007f4e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007f52:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007f56:	f7 b9 08 30 	subls	r9,48
80007f5a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007f5e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007f62:	0f 88       	ld.ub	r8,r7[0x0]
80007f64:	22 58       	sub	r8,37
80007f66:	e0 48 00 53 	cp.w	r8,83
80007f6a:	e0 8b 00 31 	brhi	80007fcc <log+0xd0>
80007f6e:	4b 89       	lddpc	r9,8000804c <log+0x150>
80007f70:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007f74:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007f78:	06 9a       	mov	r10,r3
80007f7a:	40 0b       	lddsp	r11,sp[0x0]
80007f7c:	5c 5b       	castu.b	r11
80007f7e:	68 0c       	ld.w	r12,r4[0x0]
80007f80:	f0 1f 00 34 	mcall	80008050 <log+0x154>
							break;
80007f84:	c2 98       	rjmp	80007fd6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007f86:	4b 4c       	lddpc	r12,80008054 <log+0x158>
80007f88:	f0 1f 00 34 	mcall	80008058 <log+0x15c>
80007f8c:	08 95       	mov	r5,r4
80007f8e:	06 9c       	mov	r12,r3
							break;
80007f90:	c2 38       	rjmp	80007fd6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007f92:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007f96:	06 9a       	mov	r10,r3
80007f98:	40 0b       	lddsp	r11,sp[0x0]
80007f9a:	5c 5b       	castu.b	r11
80007f9c:	68 0c       	ld.w	r12,r4[0x0]
80007f9e:	f0 1f 00 30 	mcall	8000805c <log+0x160>
80007fa2:	06 9c       	mov	r12,r3
							break;
80007fa4:	c1 98       	rjmp	80007fd6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007fa6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007faa:	06 9b       	mov	r11,r3
80007fac:	09 bc       	ld.ub	r12,r4[0x3]
80007fae:	f0 1f 00 2d 	mcall	80008060 <log+0x164>
80007fb2:	06 9c       	mov	r12,r3
							break;
80007fb4:	c1 18       	rjmp	80007fd6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007fb6:	e8 c5 ff fc 	sub	r5,r4,-4
80007fba:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007fbc:	c0 d8       	rjmp	80007fd6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007fbe:	06 9b       	mov	r11,r3
80007fc0:	32 5c       	mov	r12,37
80007fc2:	f0 1f 00 28 	mcall	80008060 <log+0x164>
80007fc6:	08 95       	mov	r5,r4
80007fc8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007fca:	c0 68       	rjmp	80007fd6 <log+0xda>
							
							default:
							log("I need relax.");
80007fcc:	4a 6c       	lddpc	r12,80008064 <log+0x168>
80007fce:	f0 1f 00 23 	mcall	80008058 <log+0x15c>
80007fd2:	08 95       	mov	r5,r4
80007fd4:	06 9c       	mov	r12,r3
						}
						str++;
80007fd6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007fd8:	1a dc       	st.w	--sp,r12
80007fda:	1a d6       	st.w	--sp,r6
80007fdc:	4a 3b       	lddpc	r11,80008068 <log+0x16c>
80007fde:	0c 9c       	mov	r12,r6
80007fe0:	f0 1f 00 23 	mcall	8000806c <log+0x170>
80007fe4:	2f ed       	sub	sp,-8
80007fe6:	c0 a8       	rjmp	80007ffa <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007fe8:	2f f7       	sub	r7,-1
80007fea:	1a d8       	st.w	--sp,r8
80007fec:	1a d6       	st.w	--sp,r6
80007fee:	4a 1b       	lddpc	r11,80008070 <log+0x174>
80007ff0:	0c 9c       	mov	r12,r6
80007ff2:	f0 1f 00 1f 	mcall	8000806c <log+0x170>
80007ff6:	08 95       	mov	r5,r4
80007ff8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007ffa:	0f 89       	ld.ub	r9,r7[0x0]
80007ffc:	30 08       	mov	r8,0
80007ffe:	f0 09 18 00 	cp.b	r9,r8
80008002:	c0 30       	breq	80008008 <log+0x10c>
80008004:	0a 94       	mov	r4,r5
80008006:	c9 2b       	rjmp	80007f2a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80008008:	fa c7 fe f8 	sub	r7,sp,-264
8000800c:	1a d7       	st.w	--sp,r7
8000800e:	49 ab       	lddpc	r11,80008074 <log+0x178>
80008010:	0e 9c       	mov	r12,r7
80008012:	f0 1f 00 17 	mcall	8000806c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80008016:	5c 5c       	castu.b	r12
80008018:	f8 c6 ff ff 	sub	r6,r12,-1
8000801c:	0c 9c       	mov	r12,r6
8000801e:	f0 1f 00 17 	mcall	80008078 <log+0x17c>
80008022:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80008024:	0c 9a       	mov	r10,r6
80008026:	0e 9b       	mov	r11,r7
80008028:	f0 1f 00 15 	mcall	8000807c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000802c:	30 09       	mov	r9,0
8000802e:	30 5a       	mov	r10,5
80008030:	fa cb fe f8 	sub	r11,sp,-264
80008034:	49 38       	lddpc	r8,80008080 <log+0x184>
80008036:	70 0c       	ld.w	r12,r8[0x0]
80008038:	f0 1f 00 13 	mcall	80008084 <log+0x188>
8000803c:	2f fd       	sub	sp,-4
	
	
}
8000803e:	fe 3d fd f8 	sub	sp,-520
80008042:	d8 32       	popm	r0-r7,pc
80008044:	80 00       	ld.sh	r0,r0[0x0]
80008046:	88 ee       	ld.uh	lr,r4[0xc]
80008048:	00 00       	add	r0,r0
8000804a:	0d e0       	ld.ub	r0,r6[0x6]
8000804c:	80 00       	ld.sh	r0,r0[0x0]
8000804e:	ed 80       	*unknown*
80008050:	80 00       	ld.sh	r0,r0[0x0]
80008052:	7e 22       	ld.w	r2,pc[0x8]
80008054:	80 00       	ld.sh	r0,r0[0x0]
80008056:	f0 2c 80 00 	sub	r12,-1015808
8000805a:	7e fc       	ld.w	r12,pc[0x3c]
8000805c:	80 00       	ld.sh	r0,r0[0x0]
8000805e:	7d 70       	ld.w	r0,lr[0x5c]
80008060:	80 00       	ld.sh	r0,r0[0x0]
80008062:	7d 6c       	ld.w	r12,lr[0x58]
80008064:	80 00       	ld.sh	r0,r0[0x0]
80008066:	f0 3c 80 00 	sub	r12,-950272
8000806a:	f0 4c 80 00 	cp.w	r12,-1015808
8000806e:	8b dc       	st.w	r5[0x34],r12
80008070:	80 00       	ld.sh	r0,r0[0x0]
80008072:	f0 54 80 00 	cp.w	r4,-950272
80008076:	f0 5c 80 00 	cp.w	r12,-950272
8000807a:	6f 58       	ld.w	r8,r7[0x54]
8000807c:	80 00       	ld.sh	r0,r0[0x0]
8000807e:	87 a6       	st.w	r3[0x28],r6
80008080:	00 00       	add	r0,r0
80008082:	9e 04       	ld.sh	r4,pc[0x0]
80008084:	80 00       	ld.sh	r0,r0[0x0]
80008086:	72 ac       	ld.w	r12,r9[0x28]

80008088 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80008088:	d4 31       	pushm	r0-r7,lr
8000808a:	fa cd 02 0c 	sub	sp,sp,524
8000808e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80008090:	e0 6a 01 00 	mov	r10,256
80008094:	30 0b       	mov	r11,0
80008096:	fa cc fe f4 	sub	r12,sp,-268
8000809a:	f0 1f 00 4c 	mcall	800081c8 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000809e:	fa c4 fd d0 	sub	r4,sp,-560
800080a2:	30 0a       	mov	r10,0
800080a4:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800080a6:	fa c3 ff fc 	sub	r3,sp,-4
800080aa:	e0 61 01 00 	mov	r1,256
800080ae:	14 90       	mov	r0,r10
			
			if(*str == '%')
800080b0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800080b2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800080b6:	02 9a       	mov	r10,r1
800080b8:	00 9b       	mov	r11,r0
800080ba:	06 9c       	mov	r12,r3
800080bc:	f0 1f 00 43 	mcall	800081c8 <logFromISR+0x140>
			
			if(*str == '%')
800080c0:	0f 88       	ld.ub	r8,r7[0x0]
800080c2:	e4 08 18 00 	cp.b	r8,r2
800080c6:	c5 11       	brne	80008168 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800080c8:	ee c8 ff ff 	sub	r8,r7,-1
800080cc:	11 89       	ld.ub	r9,r8[0x0]
800080ce:	4c 0a       	lddpc	r10,800081cc <logFromISR+0x144>
800080d0:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800080d2:	23 09       	sub	r9,48
800080d4:	30 9a       	mov	r10,9
800080d6:	f4 09 18 00 	cp.b	r9,r10
800080da:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800080de:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800080e2:	f7 b9 08 30 	subls	r9,48
800080e6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800080ea:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800080ee:	0f 88       	ld.ub	r8,r7[0x0]
800080f0:	22 58       	sub	r8,37
800080f2:	e0 48 00 53 	cp.w	r8,83
800080f6:	e0 8b 00 2b 	brhi	8000814c <logFromISR+0xc4>
800080fa:	4b 69       	lddpc	r9,800081d0 <logFromISR+0x148>
800080fc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80008100:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80008104:	06 9a       	mov	r10,r3
80008106:	40 0b       	lddsp	r11,sp[0x0]
80008108:	5c 5b       	castu.b	r11
8000810a:	68 0c       	ld.w	r12,r4[0x0]
8000810c:	f0 1f 00 32 	mcall	800081d4 <logFromISR+0x14c>
					break;
80008110:	c2 38       	rjmp	80008156 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80008112:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80008116:	06 9a       	mov	r10,r3
80008118:	40 0b       	lddsp	r11,sp[0x0]
8000811a:	5c 5b       	castu.b	r11
8000811c:	68 0c       	ld.w	r12,r4[0x0]
8000811e:	f0 1f 00 2f 	mcall	800081d8 <logFromISR+0x150>
80008122:	06 9c       	mov	r12,r3
					break;
80008124:	c1 98       	rjmp	80008156 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80008126:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000812a:	06 9b       	mov	r11,r3
8000812c:	09 bc       	ld.ub	r12,r4[0x3]
8000812e:	f0 1f 00 2c 	mcall	800081dc <logFromISR+0x154>
80008132:	06 9c       	mov	r12,r3
					break;
80008134:	c1 18       	rjmp	80008156 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80008136:	e8 c5 ff fc 	sub	r5,r4,-4
8000813a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000813c:	c0 d8       	rjmp	80008156 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000813e:	06 9b       	mov	r11,r3
80008140:	32 5c       	mov	r12,37
80008142:	f0 1f 00 27 	mcall	800081dc <logFromISR+0x154>
80008146:	08 95       	mov	r5,r4
80008148:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000814a:	c0 68       	rjmp	80008156 <logFromISR+0xce>
					default:
					log("I need relax.");
8000814c:	4a 5c       	lddpc	r12,800081e0 <logFromISR+0x158>
8000814e:	f0 1f 00 26 	mcall	800081e4 <logFromISR+0x15c>
80008152:	08 95       	mov	r5,r4
80008154:	06 9c       	mov	r12,r3
				}
				str++;
80008156:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008158:	1a dc       	st.w	--sp,r12
8000815a:	1a d6       	st.w	--sp,r6
8000815c:	4a 3b       	lddpc	r11,800081e8 <logFromISR+0x160>
8000815e:	0c 9c       	mov	r12,r6
80008160:	f0 1f 00 23 	mcall	800081ec <logFromISR+0x164>
80008164:	2f ed       	sub	sp,-8
80008166:	c0 a8       	rjmp	8000817a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008168:	2f f7       	sub	r7,-1
8000816a:	1a d8       	st.w	--sp,r8
8000816c:	1a d6       	st.w	--sp,r6
8000816e:	4a 1b       	lddpc	r11,800081f0 <logFromISR+0x168>
80008170:	0c 9c       	mov	r12,r6
80008172:	f0 1f 00 1f 	mcall	800081ec <logFromISR+0x164>
80008176:	08 95       	mov	r5,r4
80008178:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000817a:	0f 89       	ld.ub	r9,r7[0x0]
8000817c:	30 08       	mov	r8,0
8000817e:	f0 09 18 00 	cp.b	r9,r8
80008182:	c0 30       	breq	80008188 <logFromISR+0x100>
80008184:	0a 94       	mov	r4,r5
80008186:	c9 8b       	rjmp	800080b6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80008188:	fa c7 fe f4 	sub	r7,sp,-268
8000818c:	1a d7       	st.w	--sp,r7
8000818e:	49 ab       	lddpc	r11,800081f4 <logFromISR+0x16c>
80008190:	0e 9c       	mov	r12,r7
80008192:	f0 1f 00 17 	mcall	800081ec <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80008196:	5c 5c       	castu.b	r12
80008198:	f8 c6 ff ff 	sub	r6,r12,-1
8000819c:	0c 9c       	mov	r12,r6
8000819e:	f0 1f 00 17 	mcall	800081f8 <logFromISR+0x170>
800081a2:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800081a4:	0c 9a       	mov	r10,r6
800081a6:	0e 9b       	mov	r11,r7
800081a8:	f0 1f 00 15 	mcall	800081fc <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800081ac:	30 09       	mov	r9,0
800081ae:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800081b0:	fa ca fe f8 	sub	r10,sp,-264
800081b4:	fa cb fe f4 	sub	r11,sp,-268
800081b8:	49 28       	lddpc	r8,80008200 <logFromISR+0x178>
800081ba:	70 0c       	ld.w	r12,r8[0x0]
800081bc:	f0 1f 00 12 	mcall	80008204 <logFromISR+0x17c>
800081c0:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800081c2:	fe 3d fd f4 	sub	sp,-524
800081c6:	d8 32       	popm	r0-r7,pc
800081c8:	80 00       	ld.sh	r0,r0[0x0]
800081ca:	88 ee       	ld.uh	lr,r4[0xc]
800081cc:	00 00       	add	r0,r0
800081ce:	0d e1       	ld.ub	r1,r6[0x6]
800081d0:	80 00       	ld.sh	r0,r0[0x0]
800081d2:	ee d0 80 00 	satsub.w	r0,r7,-32768
800081d6:	7e 22       	ld.w	r2,pc[0x8]
800081d8:	80 00       	ld.sh	r0,r0[0x0]
800081da:	7d 70       	ld.w	r0,lr[0x5c]
800081dc:	80 00       	ld.sh	r0,r0[0x0]
800081de:	7d 6c       	ld.w	r12,lr[0x58]
800081e0:	80 00       	ld.sh	r0,r0[0x0]
800081e2:	f0 3c 80 00 	sub	r12,-950272
800081e6:	7e fc       	ld.w	r12,pc[0x3c]
800081e8:	80 00       	ld.sh	r0,r0[0x0]
800081ea:	f0 4c 80 00 	cp.w	r12,-1015808
800081ee:	8b dc       	st.w	r5[0x34],r12
800081f0:	80 00       	ld.sh	r0,r0[0x0]
800081f2:	f0 54 80 00 	cp.w	r4,-950272
800081f6:	f0 5c 80 00 	cp.w	r12,-950272
800081fa:	6f 58       	ld.w	r8,r7[0x54]
800081fc:	80 00       	ld.sh	r0,r0[0x0]
800081fe:	87 a6       	st.w	r3[0x28],r6
80008200:	00 00       	add	r0,r0
80008202:	9e 04       	ld.sh	r4,pc[0x0]
80008204:	80 00       	ld.sh	r0,r0[0x0]
80008206:	72 5c       	ld.w	r12,r9[0x14]

80008208 <log_init>:
		
	return str;
}

void log_init(void)
{
80008208:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000820a:	30 2b       	mov	r11,2
8000820c:	48 fc       	lddpc	r12,80008248 <log_init+0x40>
8000820e:	f0 1f 00 10 	mcall	8000824c <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80008212:	e0 6a 36 00 	mov	r10,13824
80008216:	ea 1a 01 6e 	orh	r10,0x16e
8000821a:	48 eb       	lddpc	r11,80008250 <log_init+0x48>
8000821c:	fe 7c 18 00 	mov	r12,-59392
80008220:	f0 1f 00 0d 	mcall	80008254 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80008224:	30 4b       	mov	r11,4
80008226:	33 2c       	mov	r12,50
80008228:	f0 1f 00 0c 	mcall	80008258 <log_init+0x50>
8000822c:	48 c8       	lddpc	r8,8000825c <log_init+0x54>
8000822e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80008230:	30 09       	mov	r9,0
80008232:	1a d9       	st.w	--sp,r9
80008234:	1a d9       	st.w	--sp,r9
80008236:	1a d9       	st.w	--sp,r9
80008238:	30 28       	mov	r8,2
8000823a:	36 4a       	mov	r10,100
8000823c:	48 9b       	lddpc	r11,80008260 <log_init+0x58>
8000823e:	48 ac       	lddpc	r12,80008264 <log_init+0x5c>
80008240:	f0 1f 00 0a 	mcall	80008268 <log_init+0x60>
80008244:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80008246:	d8 02       	popm	pc
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	f0 68 80 00 	mov	r8,-1015808
8000824e:	62 c8       	ld.w	r8,r1[0x30]
80008250:	80 00       	ld.sh	r0,r0[0x0]
80008252:	f0 20 80 00 	sub	r0,-1015808
80008256:	6a bc       	ld.w	r12,r5[0x2c]
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	74 04       	ld.w	r4,r10[0x0]
8000825c:	00 00       	add	r0,r0
8000825e:	9e 04       	ld.sh	r4,pc[0x0]
80008260:	80 00       	ld.sh	r0,r0[0x0]
80008262:	f0 64 80 00 	mov	r4,-1015808
80008266:	82 6c       	ld.sh	r12,r1[0xc]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	7b 38       	ld.w	r8,sp[0x4c]

8000826c <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
8000826c:	eb cd 40 f8 	pushm	r3-r7,lr
80008270:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80008272:	48 c7       	lddpc	r7,800082a0 <task_log+0x34>
80008274:	30 05       	mov	r5,0
80008276:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80008278:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000827c:	0a 99       	mov	r9,r5
8000827e:	08 9a       	mov	r10,r4
80008280:	1a 9b       	mov	r11,sp
80008282:	6e 0c       	ld.w	r12,r7[0x0]
80008284:	f0 1f 00 08 	mcall	800082a4 <task_log+0x38>
80008288:	58 1c       	cp.w	r12,1
8000828a:	cf 91       	brne	8000827c <task_log+0x10>
		{
			if( NULL != str)
8000828c:	40 0b       	lddsp	r11,sp[0x0]
8000828e:	58 0b       	cp.w	r11,0
80008290:	cf 60       	breq	8000827c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80008292:	06 9c       	mov	r12,r3
80008294:	f0 1f 00 05 	mcall	800082a8 <task_log+0x3c>
				vPortFree(str);
80008298:	40 0c       	lddsp	r12,sp[0x0]
8000829a:	f0 1f 00 05 	mcall	800082ac <task_log+0x40>
8000829e:	ce fb       	rjmp	8000827c <task_log+0x10>
800082a0:	00 00       	add	r0,r0
800082a2:	9e 04       	ld.sh	r4,pc[0x0]
800082a4:	80 00       	ld.sh	r0,r0[0x0]
800082a6:	70 a0       	ld.w	r0,r8[0x28]
800082a8:	80 00       	ld.sh	r0,r0[0x0]
800082aa:	6a 6c       	ld.w	r12,r5[0x18]
800082ac:	80 00       	ld.sh	r0,r0[0x0]
800082ae:	6f 30       	ld.w	r0,r7[0x4c]

800082b0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800082b0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800082b2:	fe 78 10 00 	mov	r8,-61440
800082b6:	30 19       	mov	r9,1
800082b8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800082bc:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800082c0:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800082c4:	d3 03       	ssrf	0x10
	local_start_pll0();
800082c6:	f0 1f 00 0d 	mcall	800082f8 <main+0x48>
		
	INTC_init_interrupts();
800082ca:	f0 1f 00 0d 	mcall	800082fc <main+0x4c>
		
	log_init();
800082ce:	f0 1f 00 0d 	mcall	80008300 <main+0x50>
	log("----start debug----");
800082d2:	48 dc       	lddpc	r12,80008304 <main+0x54>
800082d4:	f0 1f 00 0d 	mcall	80008308 <main+0x58>
	
	xg_flashc_init();
800082d8:	f0 1f 00 0d 	mcall	8000830c <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800082dc:	f0 1f 00 0d 	mcall	80008310 <main+0x60>
		
	app_init();
800082e0:	f0 1f 00 0d 	mcall	80008314 <main+0x64>
	
	xg_rtc_init();
800082e4:	f0 1f 00 0d 	mcall	80008318 <main+0x68>
		
	xcmp_init();
800082e8:	f0 1f 00 0d 	mcall	8000831c <main+0x6c>

	local_start_timer();
800082ec:	f0 1f 00 0d 	mcall	80008320 <main+0x70>
		
	vTaskStartScheduler();
800082f0:	f0 1f 00 0d 	mcall	80008324 <main+0x74>
	return 0;
	
}
800082f4:	d8 0a       	popm	pc,r12=0
800082f6:	00 00       	add	r0,r0
800082f8:	80 00       	ld.sh	r0,r0[0x0]
800082fa:	5b cc       	cp.w	r12,-4
800082fc:	80 00       	ld.sh	r0,r0[0x0]
800082fe:	63 cc       	ld.w	r12,r1[0x70]
80008300:	80 00       	ld.sh	r0,r0[0x0]
80008302:	82 08       	ld.sh	r8,r1[0x0]
80008304:	80 00       	ld.sh	r0,r0[0x0]
80008306:	f0 78 80 00 	mov	r8,-950272
8000830a:	7e fc       	ld.w	r12,pc[0x3c]
8000830c:	80 00       	ld.sh	r0,r0[0x0]
8000830e:	5c 60       	casts.b	r0
80008310:	80 00       	ld.sh	r0,r0[0x0]
80008312:	5b 2c       	cp.w	r12,-14
80008314:	80 00       	ld.sh	r0,r0[0x0]
80008316:	20 3c       	sub	r12,3
80008318:	80 00       	ld.sh	r0,r0[0x0]
8000831a:	32 b0       	mov	r0,43
8000831c:	80 00       	ld.sh	r0,r0[0x0]
8000831e:	49 84       	lddpc	r4,8000837c <_malloc_r+0x34>
80008320:	80 00       	ld.sh	r0,r0[0x0]
80008322:	5b a0       	cp.w	r0,-6
80008324:	80 00       	ld.sh	r0,r0[0x0]
80008326:	7d 20       	ld.w	r0,lr[0x48]

80008328 <free>:
80008328:	d4 01       	pushm	lr
8000832a:	e0 68 0a 54 	mov	r8,2644
8000832e:	18 9b       	mov	r11,r12
80008330:	70 0c       	ld.w	r12,r8[0x0]
80008332:	e0 a0 1e 73 	rcall	8000c018 <_free_r>
80008336:	d8 02       	popm	pc

80008338 <malloc>:
80008338:	d4 01       	pushm	lr
8000833a:	e0 68 0a 54 	mov	r8,2644
8000833e:	18 9b       	mov	r11,r12
80008340:	70 0c       	ld.w	r12,r8[0x0]
80008342:	c0 3c       	rcall	80008348 <_malloc_r>
80008344:	d8 02       	popm	pc
80008346:	d7 03       	nop

80008348 <_malloc_r>:
80008348:	d4 31       	pushm	r0-r7,lr
8000834a:	f6 c8 ff f5 	sub	r8,r11,-11
8000834e:	18 95       	mov	r5,r12
80008350:	10 97       	mov	r7,r8
80008352:	e0 17 ff f8 	andl	r7,0xfff8
80008356:	59 68       	cp.w	r8,22
80008358:	f9 b7 08 10 	movls	r7,16
8000835c:	16 37       	cp.w	r7,r11
8000835e:	5f 38       	srlo	r8
80008360:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80008364:	c0 50       	breq	8000836e <_malloc_r+0x26>
80008366:	30 c8       	mov	r8,12
80008368:	99 38       	st.w	r12[0xc],r8
8000836a:	e0 8f 01 fa 	bral	8000875e <_malloc_r+0x416>
8000836e:	fe b0 f5 97 	rcall	80006e9c <__malloc_lock>
80008372:	e0 47 01 f7 	cp.w	r7,503
80008376:	e0 8b 00 1d 	brhi	800083b0 <_malloc_r+0x68>
8000837a:	ee 03 16 03 	lsr	r3,r7,0x3
8000837e:	e0 68 05 54 	mov	r8,1364
80008382:	f0 03 00 38 	add	r8,r8,r3<<0x3
80008386:	70 36       	ld.w	r6,r8[0xc]
80008388:	10 36       	cp.w	r6,r8
8000838a:	c0 61       	brne	80008396 <_malloc_r+0x4e>
8000838c:	ec c8 ff f8 	sub	r8,r6,-8
80008390:	70 36       	ld.w	r6,r8[0xc]
80008392:	10 36       	cp.w	r6,r8
80008394:	c0 c0       	breq	800083ac <_malloc_r+0x64>
80008396:	6c 18       	ld.w	r8,r6[0x4]
80008398:	e0 18 ff fc 	andl	r8,0xfffc
8000839c:	6c 3a       	ld.w	r10,r6[0xc]
8000839e:	ec 08 00 09 	add	r9,r6,r8
800083a2:	0a 9c       	mov	r12,r5
800083a4:	6c 28       	ld.w	r8,r6[0x8]
800083a6:	95 28       	st.w	r10[0x8],r8
800083a8:	91 3a       	st.w	r8[0xc],r10
800083aa:	c4 78       	rjmp	80008438 <_malloc_r+0xf0>
800083ac:	2f e3       	sub	r3,-2
800083ae:	c4 d8       	rjmp	80008448 <_malloc_r+0x100>
800083b0:	ee 03 16 09 	lsr	r3,r7,0x9
800083b4:	c0 41       	brne	800083bc <_malloc_r+0x74>
800083b6:	ee 03 16 03 	lsr	r3,r7,0x3
800083ba:	c2 68       	rjmp	80008406 <_malloc_r+0xbe>
800083bc:	58 43       	cp.w	r3,4
800083be:	e0 8b 00 06 	brhi	800083ca <_malloc_r+0x82>
800083c2:	ee 03 16 06 	lsr	r3,r7,0x6
800083c6:	2c 83       	sub	r3,-56
800083c8:	c1 f8       	rjmp	80008406 <_malloc_r+0xbe>
800083ca:	59 43       	cp.w	r3,20
800083cc:	e0 8b 00 04 	brhi	800083d4 <_malloc_r+0x8c>
800083d0:	2a 53       	sub	r3,-91
800083d2:	c1 a8       	rjmp	80008406 <_malloc_r+0xbe>
800083d4:	e0 43 00 54 	cp.w	r3,84
800083d8:	e0 8b 00 06 	brhi	800083e4 <_malloc_r+0x9c>
800083dc:	ee 03 16 0c 	lsr	r3,r7,0xc
800083e0:	29 23       	sub	r3,-110
800083e2:	c1 28       	rjmp	80008406 <_malloc_r+0xbe>
800083e4:	e0 43 01 54 	cp.w	r3,340
800083e8:	e0 8b 00 06 	brhi	800083f4 <_malloc_r+0xac>
800083ec:	ee 03 16 0f 	lsr	r3,r7,0xf
800083f0:	28 93       	sub	r3,-119
800083f2:	c0 a8       	rjmp	80008406 <_malloc_r+0xbe>
800083f4:	e0 43 05 54 	cp.w	r3,1364
800083f8:	e0 88 00 04 	brls	80008400 <_malloc_r+0xb8>
800083fc:	37 e3       	mov	r3,126
800083fe:	c0 48       	rjmp	80008406 <_malloc_r+0xbe>
80008400:	ee 03 16 12 	lsr	r3,r7,0x12
80008404:	28 43       	sub	r3,-124
80008406:	e0 6a 05 54 	mov	r10,1364
8000840a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000840e:	74 36       	ld.w	r6,r10[0xc]
80008410:	c1 98       	rjmp	80008442 <_malloc_r+0xfa>
80008412:	6c 19       	ld.w	r9,r6[0x4]
80008414:	e0 19 ff fc 	andl	r9,0xfffc
80008418:	f2 07 01 0b 	sub	r11,r9,r7
8000841c:	58 fb       	cp.w	r11,15
8000841e:	e0 8a 00 04 	brle	80008426 <_malloc_r+0xde>
80008422:	20 13       	sub	r3,1
80008424:	c1 18       	rjmp	80008446 <_malloc_r+0xfe>
80008426:	6c 38       	ld.w	r8,r6[0xc]
80008428:	58 0b       	cp.w	r11,0
8000842a:	c0 b5       	brlt	80008440 <_malloc_r+0xf8>
8000842c:	6c 2a       	ld.w	r10,r6[0x8]
8000842e:	ec 09 00 09 	add	r9,r6,r9
80008432:	0a 9c       	mov	r12,r5
80008434:	91 2a       	st.w	r8[0x8],r10
80008436:	95 38       	st.w	r10[0xc],r8
80008438:	72 18       	ld.w	r8,r9[0x4]
8000843a:	a1 a8       	sbr	r8,0x0
8000843c:	93 18       	st.w	r9[0x4],r8
8000843e:	cb c8       	rjmp	800085b6 <_malloc_r+0x26e>
80008440:	10 96       	mov	r6,r8
80008442:	14 36       	cp.w	r6,r10
80008444:	ce 71       	brne	80008412 <_malloc_r+0xca>
80008446:	2f f3       	sub	r3,-1
80008448:	e0 6a 05 54 	mov	r10,1364
8000844c:	f4 cc ff f8 	sub	r12,r10,-8
80008450:	78 26       	ld.w	r6,r12[0x8]
80008452:	18 36       	cp.w	r6,r12
80008454:	c6 c0       	breq	8000852c <_malloc_r+0x1e4>
80008456:	6c 19       	ld.w	r9,r6[0x4]
80008458:	e0 19 ff fc 	andl	r9,0xfffc
8000845c:	f2 07 01 08 	sub	r8,r9,r7
80008460:	58 f8       	cp.w	r8,15
80008462:	e0 89 00 8f 	brgt	80008580 <_malloc_r+0x238>
80008466:	99 3c       	st.w	r12[0xc],r12
80008468:	99 2c       	st.w	r12[0x8],r12
8000846a:	58 08       	cp.w	r8,0
8000846c:	c0 55       	brlt	80008476 <_malloc_r+0x12e>
8000846e:	ec 09 00 09 	add	r9,r6,r9
80008472:	0a 9c       	mov	r12,r5
80008474:	ce 2b       	rjmp	80008438 <_malloc_r+0xf0>
80008476:	e0 49 01 ff 	cp.w	r9,511
8000847a:	e0 8b 00 13 	brhi	800084a0 <_malloc_r+0x158>
8000847e:	a3 99       	lsr	r9,0x3
80008480:	f4 09 00 38 	add	r8,r10,r9<<0x3
80008484:	70 2b       	ld.w	r11,r8[0x8]
80008486:	8d 38       	st.w	r6[0xc],r8
80008488:	8d 2b       	st.w	r6[0x8],r11
8000848a:	97 36       	st.w	r11[0xc],r6
8000848c:	91 26       	st.w	r8[0x8],r6
8000848e:	a3 49       	asr	r9,0x2
80008490:	74 18       	ld.w	r8,r10[0x4]
80008492:	30 1b       	mov	r11,1
80008494:	f6 09 09 49 	lsl	r9,r11,r9
80008498:	f1 e9 10 09 	or	r9,r8,r9
8000849c:	95 19       	st.w	r10[0x4],r9
8000849e:	c4 78       	rjmp	8000852c <_malloc_r+0x1e4>
800084a0:	f2 0a 16 09 	lsr	r10,r9,0x9
800084a4:	58 4a       	cp.w	r10,4
800084a6:	e0 8b 00 07 	brhi	800084b4 <_malloc_r+0x16c>
800084aa:	f2 0a 16 06 	lsr	r10,r9,0x6
800084ae:	2c 8a       	sub	r10,-56
800084b0:	c2 08       	rjmp	800084f0 <_malloc_r+0x1a8>
800084b2:	d7 03       	nop
800084b4:	59 4a       	cp.w	r10,20
800084b6:	e0 8b 00 04 	brhi	800084be <_malloc_r+0x176>
800084ba:	2a 5a       	sub	r10,-91
800084bc:	c1 a8       	rjmp	800084f0 <_malloc_r+0x1a8>
800084be:	e0 4a 00 54 	cp.w	r10,84
800084c2:	e0 8b 00 06 	brhi	800084ce <_malloc_r+0x186>
800084c6:	f2 0a 16 0c 	lsr	r10,r9,0xc
800084ca:	29 2a       	sub	r10,-110
800084cc:	c1 28       	rjmp	800084f0 <_malloc_r+0x1a8>
800084ce:	e0 4a 01 54 	cp.w	r10,340
800084d2:	e0 8b 00 06 	brhi	800084de <_malloc_r+0x196>
800084d6:	f2 0a 16 0f 	lsr	r10,r9,0xf
800084da:	28 9a       	sub	r10,-119
800084dc:	c0 a8       	rjmp	800084f0 <_malloc_r+0x1a8>
800084de:	e0 4a 05 54 	cp.w	r10,1364
800084e2:	e0 88 00 04 	brls	800084ea <_malloc_r+0x1a2>
800084e6:	37 ea       	mov	r10,126
800084e8:	c0 48       	rjmp	800084f0 <_malloc_r+0x1a8>
800084ea:	f2 0a 16 12 	lsr	r10,r9,0x12
800084ee:	28 4a       	sub	r10,-124
800084f0:	e0 6b 05 54 	mov	r11,1364
800084f4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800084f8:	68 28       	ld.w	r8,r4[0x8]
800084fa:	08 38       	cp.w	r8,r4
800084fc:	c0 e1       	brne	80008518 <_malloc_r+0x1d0>
800084fe:	76 19       	ld.w	r9,r11[0x4]
80008500:	a3 4a       	asr	r10,0x2
80008502:	30 1e       	mov	lr,1
80008504:	fc 0a 09 4a 	lsl	r10,lr,r10
80008508:	f3 ea 10 0a 	or	r10,r9,r10
8000850c:	10 99       	mov	r9,r8
8000850e:	97 1a       	st.w	r11[0x4],r10
80008510:	c0 a8       	rjmp	80008524 <_malloc_r+0x1dc>
80008512:	70 28       	ld.w	r8,r8[0x8]
80008514:	08 38       	cp.w	r8,r4
80008516:	c0 60       	breq	80008522 <_malloc_r+0x1da>
80008518:	70 1a       	ld.w	r10,r8[0x4]
8000851a:	e0 1a ff fc 	andl	r10,0xfffc
8000851e:	14 39       	cp.w	r9,r10
80008520:	cf 93       	brcs	80008512 <_malloc_r+0x1ca>
80008522:	70 39       	ld.w	r9,r8[0xc]
80008524:	8d 39       	st.w	r6[0xc],r9
80008526:	8d 28       	st.w	r6[0x8],r8
80008528:	91 36       	st.w	r8[0xc],r6
8000852a:	93 26       	st.w	r9[0x8],r6
8000852c:	e6 08 14 02 	asr	r8,r3,0x2
80008530:	30 1b       	mov	r11,1
80008532:	e0 64 05 54 	mov	r4,1364
80008536:	f6 08 09 4b 	lsl	r11,r11,r8
8000853a:	68 18       	ld.w	r8,r4[0x4]
8000853c:	10 3b       	cp.w	r11,r8
8000853e:	e0 8b 00 6b 	brhi	80008614 <_malloc_r+0x2cc>
80008542:	f7 e8 00 09 	and	r9,r11,r8
80008546:	c0 b1       	brne	8000855c <_malloc_r+0x214>
80008548:	e0 13 ff fc 	andl	r3,0xfffc
8000854c:	a1 7b       	lsl	r11,0x1
8000854e:	2f c3       	sub	r3,-4
80008550:	c0 38       	rjmp	80008556 <_malloc_r+0x20e>
80008552:	2f c3       	sub	r3,-4
80008554:	a1 7b       	lsl	r11,0x1
80008556:	f7 e8 00 09 	and	r9,r11,r8
8000855a:	cf c0       	breq	80008552 <_malloc_r+0x20a>
8000855c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80008560:	06 92       	mov	r2,r3
80008562:	1c 91       	mov	r1,lr
80008564:	62 36       	ld.w	r6,r1[0xc]
80008566:	c2 e8       	rjmp	800085c2 <_malloc_r+0x27a>
80008568:	6c 1a       	ld.w	r10,r6[0x4]
8000856a:	e0 1a ff fc 	andl	r10,0xfffc
8000856e:	f4 07 01 08 	sub	r8,r10,r7
80008572:	58 f8       	cp.w	r8,15
80008574:	e0 8a 00 15 	brle	8000859e <_malloc_r+0x256>
80008578:	6c 3a       	ld.w	r10,r6[0xc]
8000857a:	6c 29       	ld.w	r9,r6[0x8]
8000857c:	95 29       	st.w	r10[0x8],r9
8000857e:	93 3a       	st.w	r9[0xc],r10
80008580:	0e 99       	mov	r9,r7
80008582:	ec 07 00 07 	add	r7,r6,r7
80008586:	a1 a9       	sbr	r9,0x0
80008588:	99 37       	st.w	r12[0xc],r7
8000858a:	99 27       	st.w	r12[0x8],r7
8000858c:	8d 19       	st.w	r6[0x4],r9
8000858e:	ee 08 09 08 	st.w	r7[r8],r8
80008592:	8f 2c       	st.w	r7[0x8],r12
80008594:	8f 3c       	st.w	r7[0xc],r12
80008596:	a1 a8       	sbr	r8,0x0
80008598:	0a 9c       	mov	r12,r5
8000859a:	8f 18       	st.w	r7[0x4],r8
8000859c:	c0 d8       	rjmp	800085b6 <_malloc_r+0x26e>
8000859e:	6c 39       	ld.w	r9,r6[0xc]
800085a0:	58 08       	cp.w	r8,0
800085a2:	c0 f5       	brlt	800085c0 <_malloc_r+0x278>
800085a4:	ec 0a 00 0a 	add	r10,r6,r10
800085a8:	74 18       	ld.w	r8,r10[0x4]
800085aa:	a1 a8       	sbr	r8,0x0
800085ac:	0a 9c       	mov	r12,r5
800085ae:	95 18       	st.w	r10[0x4],r8
800085b0:	6c 28       	ld.w	r8,r6[0x8]
800085b2:	93 28       	st.w	r9[0x8],r8
800085b4:	91 39       	st.w	r8[0xc],r9
800085b6:	fe b0 f4 79 	rcall	80006ea8 <__malloc_unlock>
800085ba:	ec cc ff f8 	sub	r12,r6,-8
800085be:	d8 32       	popm	r0-r7,pc
800085c0:	12 96       	mov	r6,r9
800085c2:	02 36       	cp.w	r6,r1
800085c4:	cd 21       	brne	80008568 <_malloc_r+0x220>
800085c6:	2f f2       	sub	r2,-1
800085c8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800085cc:	c0 30       	breq	800085d2 <_malloc_r+0x28a>
800085ce:	2f 81       	sub	r1,-8
800085d0:	cc ab       	rjmp	80008564 <_malloc_r+0x21c>
800085d2:	1c 98       	mov	r8,lr
800085d4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800085d8:	c0 81       	brne	800085e8 <_malloc_r+0x2a0>
800085da:	68 19       	ld.w	r9,r4[0x4]
800085dc:	f6 08 11 ff 	rsub	r8,r11,-1
800085e0:	f3 e8 00 08 	and	r8,r9,r8
800085e4:	89 18       	st.w	r4[0x4],r8
800085e6:	c0 78       	rjmp	800085f4 <_malloc_r+0x2ac>
800085e8:	f0 c9 00 08 	sub	r9,r8,8
800085ec:	20 13       	sub	r3,1
800085ee:	70 08       	ld.w	r8,r8[0x0]
800085f0:	12 38       	cp.w	r8,r9
800085f2:	cf 10       	breq	800085d4 <_malloc_r+0x28c>
800085f4:	a1 7b       	lsl	r11,0x1
800085f6:	68 18       	ld.w	r8,r4[0x4]
800085f8:	10 3b       	cp.w	r11,r8
800085fa:	e0 8b 00 0d 	brhi	80008614 <_malloc_r+0x2cc>
800085fe:	58 0b       	cp.w	r11,0
80008600:	c0 a0       	breq	80008614 <_malloc_r+0x2cc>
80008602:	04 93       	mov	r3,r2
80008604:	c0 38       	rjmp	8000860a <_malloc_r+0x2c2>
80008606:	2f c3       	sub	r3,-4
80008608:	a1 7b       	lsl	r11,0x1
8000860a:	f7 e8 00 09 	and	r9,r11,r8
8000860e:	ca 71       	brne	8000855c <_malloc_r+0x214>
80008610:	cf bb       	rjmp	80008606 <_malloc_r+0x2be>
80008612:	d7 03       	nop
80008614:	68 23       	ld.w	r3,r4[0x8]
80008616:	66 12       	ld.w	r2,r3[0x4]
80008618:	e0 12 ff fc 	andl	r2,0xfffc
8000861c:	0e 32       	cp.w	r2,r7
8000861e:	5f 39       	srlo	r9
80008620:	e4 07 01 08 	sub	r8,r2,r7
80008624:	58 f8       	cp.w	r8,15
80008626:	5f aa       	srle	r10
80008628:	f5 e9 10 09 	or	r9,r10,r9
8000862c:	e0 80 00 9a 	breq	80008760 <_malloc_r+0x418>
80008630:	e0 68 0d ec 	mov	r8,3564
80008634:	70 01       	ld.w	r1,r8[0x0]
80008636:	e0 68 09 60 	mov	r8,2400
8000863a:	2f 01       	sub	r1,-16
8000863c:	70 08       	ld.w	r8,r8[0x0]
8000863e:	0e 01       	add	r1,r7
80008640:	5b f8       	cp.w	r8,-1
80008642:	c0 40       	breq	8000864a <_malloc_r+0x302>
80008644:	28 11       	sub	r1,-127
80008646:	e0 11 ff 80 	andl	r1,0xff80
8000864a:	02 9b       	mov	r11,r1
8000864c:	0a 9c       	mov	r12,r5
8000864e:	e0 a0 02 b7 	rcall	80008bbc <_sbrk_r>
80008652:	18 96       	mov	r6,r12
80008654:	5b fc       	cp.w	r12,-1
80008656:	c7 50       	breq	80008740 <_malloc_r+0x3f8>
80008658:	e6 02 00 08 	add	r8,r3,r2
8000865c:	10 3c       	cp.w	r12,r8
8000865e:	c0 32       	brcc	80008664 <_malloc_r+0x31c>
80008660:	08 33       	cp.w	r3,r4
80008662:	c6 f1       	brne	80008740 <_malloc_r+0x3f8>
80008664:	e0 6a 0d f0 	mov	r10,3568
80008668:	74 09       	ld.w	r9,r10[0x0]
8000866a:	e2 09 00 09 	add	r9,r1,r9
8000866e:	95 09       	st.w	r10[0x0],r9
80008670:	10 36       	cp.w	r6,r8
80008672:	c0 a1       	brne	80008686 <_malloc_r+0x33e>
80008674:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80008678:	c0 71       	brne	80008686 <_malloc_r+0x33e>
8000867a:	e2 02 00 02 	add	r2,r1,r2
8000867e:	68 28       	ld.w	r8,r4[0x8]
80008680:	a1 a2       	sbr	r2,0x0
80008682:	91 12       	st.w	r8[0x4],r2
80008684:	c4 f8       	rjmp	80008722 <_malloc_r+0x3da>
80008686:	e0 6a 09 60 	mov	r10,2400
8000868a:	74 0b       	ld.w	r11,r10[0x0]
8000868c:	5b fb       	cp.w	r11,-1
8000868e:	c0 31       	brne	80008694 <_malloc_r+0x34c>
80008690:	95 06       	st.w	r10[0x0],r6
80008692:	c0 78       	rjmp	800086a0 <_malloc_r+0x358>
80008694:	ec 09 00 09 	add	r9,r6,r9
80008698:	e0 6a 0d f0 	mov	r10,3568
8000869c:	10 19       	sub	r9,r8
8000869e:	95 09       	st.w	r10[0x0],r9
800086a0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800086a4:	f0 09 11 08 	rsub	r9,r8,8
800086a8:	58 08       	cp.w	r8,0
800086aa:	f2 08 17 10 	movne	r8,r9
800086ae:	ed d8 e1 06 	addne	r6,r6,r8
800086b2:	28 08       	sub	r8,-128
800086b4:	ec 01 00 01 	add	r1,r6,r1
800086b8:	0a 9c       	mov	r12,r5
800086ba:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800086be:	f0 01 01 01 	sub	r1,r8,r1
800086c2:	02 9b       	mov	r11,r1
800086c4:	e0 a0 02 7c 	rcall	80008bbc <_sbrk_r>
800086c8:	e0 68 0d f0 	mov	r8,3568
800086cc:	5b fc       	cp.w	r12,-1
800086ce:	ec 0c 17 00 	moveq	r12,r6
800086d2:	f9 b1 00 00 	moveq	r1,0
800086d6:	70 09       	ld.w	r9,r8[0x0]
800086d8:	0c 1c       	sub	r12,r6
800086da:	89 26       	st.w	r4[0x8],r6
800086dc:	02 0c       	add	r12,r1
800086de:	12 01       	add	r1,r9
800086e0:	a1 ac       	sbr	r12,0x0
800086e2:	91 01       	st.w	r8[0x0],r1
800086e4:	8d 1c       	st.w	r6[0x4],r12
800086e6:	08 33       	cp.w	r3,r4
800086e8:	c1 d0       	breq	80008722 <_malloc_r+0x3da>
800086ea:	58 f2       	cp.w	r2,15
800086ec:	e0 8b 00 05 	brhi	800086f6 <_malloc_r+0x3ae>
800086f0:	30 18       	mov	r8,1
800086f2:	8d 18       	st.w	r6[0x4],r8
800086f4:	c2 68       	rjmp	80008740 <_malloc_r+0x3f8>
800086f6:	30 59       	mov	r9,5
800086f8:	20 c2       	sub	r2,12
800086fa:	e0 12 ff f8 	andl	r2,0xfff8
800086fe:	e6 02 00 08 	add	r8,r3,r2
80008702:	91 29       	st.w	r8[0x8],r9
80008704:	91 19       	st.w	r8[0x4],r9
80008706:	66 18       	ld.w	r8,r3[0x4]
80008708:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000870c:	e5 e8 10 08 	or	r8,r2,r8
80008710:	87 18       	st.w	r3[0x4],r8
80008712:	58 f2       	cp.w	r2,15
80008714:	e0 88 00 07 	brls	80008722 <_malloc_r+0x3da>
80008718:	e6 cb ff f8 	sub	r11,r3,-8
8000871c:	0a 9c       	mov	r12,r5
8000871e:	e0 a0 1c 7d 	rcall	8000c018 <_free_r>
80008722:	e0 69 0d e8 	mov	r9,3560
80008726:	72 0a       	ld.w	r10,r9[0x0]
80008728:	e0 68 0d f0 	mov	r8,3568
8000872c:	70 08       	ld.w	r8,r8[0x0]
8000872e:	14 38       	cp.w	r8,r10
80008730:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008734:	e0 69 0d e4 	mov	r9,3556
80008738:	72 0a       	ld.w	r10,r9[0x0]
8000873a:	14 38       	cp.w	r8,r10
8000873c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008740:	68 28       	ld.w	r8,r4[0x8]
80008742:	70 18       	ld.w	r8,r8[0x4]
80008744:	e0 18 ff fc 	andl	r8,0xfffc
80008748:	0e 38       	cp.w	r8,r7
8000874a:	5f 39       	srlo	r9
8000874c:	0e 18       	sub	r8,r7
8000874e:	58 f8       	cp.w	r8,15
80008750:	5f aa       	srle	r10
80008752:	f5 e9 10 09 	or	r9,r10,r9
80008756:	c0 50       	breq	80008760 <_malloc_r+0x418>
80008758:	0a 9c       	mov	r12,r5
8000875a:	fe b0 f3 a7 	rcall	80006ea8 <__malloc_unlock>
8000875e:	d8 3a       	popm	r0-r7,pc,r12=0
80008760:	68 26       	ld.w	r6,r4[0x8]
80008762:	a1 a8       	sbr	r8,0x0
80008764:	0e 99       	mov	r9,r7
80008766:	a1 a9       	sbr	r9,0x0
80008768:	8d 19       	st.w	r6[0x4],r9
8000876a:	ec 07 00 07 	add	r7,r6,r7
8000876e:	0a 9c       	mov	r12,r5
80008770:	89 27       	st.w	r4[0x8],r7
80008772:	8f 18       	st.w	r7[0x4],r8
80008774:	fe b0 f3 9a 	rcall	80006ea8 <__malloc_unlock>
80008778:	ec cc ff f8 	sub	r12,r6,-8
8000877c:	d8 32       	popm	r0-r7,pc
8000877e:	d7 03       	nop

80008780 <memcmp>:
80008780:	d4 01       	pushm	lr
80008782:	30 08       	mov	r8,0
80008784:	c0 d8       	rjmp	8000879e <memcmp+0x1e>
80008786:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000878a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000878e:	20 1a       	sub	r10,1
80008790:	2f f8       	sub	r8,-1
80008792:	f2 0e 18 00 	cp.b	lr,r9
80008796:	c0 40       	breq	8000879e <memcmp+0x1e>
80008798:	fc 09 01 0c 	sub	r12,lr,r9
8000879c:	d8 02       	popm	pc
8000879e:	58 0a       	cp.w	r10,0
800087a0:	cf 31       	brne	80008786 <memcmp+0x6>
800087a2:	14 9c       	mov	r12,r10
800087a4:	d8 02       	popm	pc

800087a6 <memcpy>:
800087a6:	58 8a       	cp.w	r10,8
800087a8:	c2 f5       	brlt	80008806 <memcpy+0x60>
800087aa:	f9 eb 10 09 	or	r9,r12,r11
800087ae:	e2 19 00 03 	andl	r9,0x3,COH
800087b2:	e0 81 00 97 	brne	800088e0 <memcpy+0x13a>
800087b6:	e0 4a 00 20 	cp.w	r10,32
800087ba:	c3 b4       	brge	80008830 <memcpy+0x8a>
800087bc:	f4 08 14 02 	asr	r8,r10,0x2
800087c0:	f0 09 11 08 	rsub	r9,r8,8
800087c4:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800087c8:	76 69       	ld.w	r9,r11[0x18]
800087ca:	99 69       	st.w	r12[0x18],r9
800087cc:	76 59       	ld.w	r9,r11[0x14]
800087ce:	99 59       	st.w	r12[0x14],r9
800087d0:	76 49       	ld.w	r9,r11[0x10]
800087d2:	99 49       	st.w	r12[0x10],r9
800087d4:	76 39       	ld.w	r9,r11[0xc]
800087d6:	99 39       	st.w	r12[0xc],r9
800087d8:	76 29       	ld.w	r9,r11[0x8]
800087da:	99 29       	st.w	r12[0x8],r9
800087dc:	76 19       	ld.w	r9,r11[0x4]
800087de:	99 19       	st.w	r12[0x4],r9
800087e0:	76 09       	ld.w	r9,r11[0x0]
800087e2:	99 09       	st.w	r12[0x0],r9
800087e4:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800087e8:	f8 08 00 28 	add	r8,r12,r8<<0x2
800087ec:	e0 1a 00 03 	andl	r10,0x3
800087f0:	f4 0a 11 04 	rsub	r10,r10,4
800087f4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800087f8:	17 a9       	ld.ub	r9,r11[0x2]
800087fa:	b0 a9       	st.b	r8[0x2],r9
800087fc:	17 99       	ld.ub	r9,r11[0x1]
800087fe:	b0 99       	st.b	r8[0x1],r9
80008800:	17 89       	ld.ub	r9,r11[0x0]
80008802:	b0 89       	st.b	r8[0x0],r9
80008804:	5e fc       	retal	r12
80008806:	f4 0a 11 09 	rsub	r10,r10,9
8000880a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000880e:	17 f9       	ld.ub	r9,r11[0x7]
80008810:	b8 f9       	st.b	r12[0x7],r9
80008812:	17 e9       	ld.ub	r9,r11[0x6]
80008814:	b8 e9       	st.b	r12[0x6],r9
80008816:	17 d9       	ld.ub	r9,r11[0x5]
80008818:	b8 d9       	st.b	r12[0x5],r9
8000881a:	17 c9       	ld.ub	r9,r11[0x4]
8000881c:	b8 c9       	st.b	r12[0x4],r9
8000881e:	17 b9       	ld.ub	r9,r11[0x3]
80008820:	b8 b9       	st.b	r12[0x3],r9
80008822:	17 a9       	ld.ub	r9,r11[0x2]
80008824:	b8 a9       	st.b	r12[0x2],r9
80008826:	17 99       	ld.ub	r9,r11[0x1]
80008828:	b8 99       	st.b	r12[0x1],r9
8000882a:	17 89       	ld.ub	r9,r11[0x0]
8000882c:	b8 89       	st.b	r12[0x0],r9
8000882e:	5e fc       	retal	r12
80008830:	eb cd 40 c0 	pushm	r6-r7,lr
80008834:	18 99       	mov	r9,r12
80008836:	22 0a       	sub	r10,32
80008838:	b7 07       	ld.d	r6,r11++
8000883a:	b3 26       	st.d	r9++,r6
8000883c:	b7 07       	ld.d	r6,r11++
8000883e:	b3 26       	st.d	r9++,r6
80008840:	b7 07       	ld.d	r6,r11++
80008842:	b3 26       	st.d	r9++,r6
80008844:	b7 07       	ld.d	r6,r11++
80008846:	b3 26       	st.d	r9++,r6
80008848:	22 0a       	sub	r10,32
8000884a:	cf 74       	brge	80008838 <memcpy+0x92>
8000884c:	2f 0a       	sub	r10,-16
8000884e:	c0 65       	brlt	8000885a <memcpy+0xb4>
80008850:	b7 07       	ld.d	r6,r11++
80008852:	b3 26       	st.d	r9++,r6
80008854:	b7 07       	ld.d	r6,r11++
80008856:	b3 26       	st.d	r9++,r6
80008858:	21 0a       	sub	r10,16
8000885a:	5c 3a       	neg	r10
8000885c:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80008860:	d7 03       	nop
80008862:	d7 03       	nop
80008864:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008868:	f3 66 00 0e 	st.b	r9[14],r6
8000886c:	f7 36 00 0d 	ld.ub	r6,r11[13]
80008870:	f3 66 00 0d 	st.b	r9[13],r6
80008874:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008878:	f3 66 00 0c 	st.b	r9[12],r6
8000887c:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008880:	f3 66 00 0b 	st.b	r9[11],r6
80008884:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008888:	f3 66 00 0a 	st.b	r9[10],r6
8000888c:	f7 36 00 09 	ld.ub	r6,r11[9]
80008890:	f3 66 00 09 	st.b	r9[9],r6
80008894:	f7 36 00 08 	ld.ub	r6,r11[8]
80008898:	f3 66 00 08 	st.b	r9[8],r6
8000889c:	f7 36 00 07 	ld.ub	r6,r11[7]
800088a0:	f3 66 00 07 	st.b	r9[7],r6
800088a4:	f7 36 00 06 	ld.ub	r6,r11[6]
800088a8:	f3 66 00 06 	st.b	r9[6],r6
800088ac:	f7 36 00 05 	ld.ub	r6,r11[5]
800088b0:	f3 66 00 05 	st.b	r9[5],r6
800088b4:	f7 36 00 04 	ld.ub	r6,r11[4]
800088b8:	f3 66 00 04 	st.b	r9[4],r6
800088bc:	f7 36 00 03 	ld.ub	r6,r11[3]
800088c0:	f3 66 00 03 	st.b	r9[3],r6
800088c4:	f7 36 00 02 	ld.ub	r6,r11[2]
800088c8:	f3 66 00 02 	st.b	r9[2],r6
800088cc:	f7 36 00 01 	ld.ub	r6,r11[1]
800088d0:	f3 66 00 01 	st.b	r9[1],r6
800088d4:	f7 36 00 00 	ld.ub	r6,r11[0]
800088d8:	f3 66 00 00 	st.b	r9[0],r6
800088dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800088e0:	20 1a       	sub	r10,1
800088e2:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800088e6:	f8 0a 0b 09 	st.b	r12[r10],r9
800088ea:	cf b1       	brne	800088e0 <memcpy+0x13a>
800088ec:	5e fc       	retal	r12

800088ee <memset>:
800088ee:	18 98       	mov	r8,r12
800088f0:	c0 38       	rjmp	800088f6 <memset+0x8>
800088f2:	10 cb       	st.b	r8++,r11
800088f4:	20 1a       	sub	r10,1
800088f6:	58 0a       	cp.w	r10,0
800088f8:	cf d1       	brne	800088f2 <memset+0x4>
800088fa:	5e fc       	retal	r12

800088fc <_realloc_r>:
800088fc:	d4 31       	pushm	r0-r7,lr
800088fe:	20 1d       	sub	sp,4
80008900:	16 94       	mov	r4,r11
80008902:	18 92       	mov	r2,r12
80008904:	14 9b       	mov	r11,r10
80008906:	58 04       	cp.w	r4,0
80008908:	c0 51       	brne	80008912 <_realloc_r+0x16>
8000890a:	fe b0 fd 1f 	rcall	80008348 <_malloc_r>
8000890e:	18 95       	mov	r5,r12
80008910:	c5 39       	rjmp	80008bb6 <_realloc_r+0x2ba>
80008912:	50 0a       	stdsp	sp[0x0],r10
80008914:	fe b0 f2 c4 	rcall	80006e9c <__malloc_lock>
80008918:	40 0b       	lddsp	r11,sp[0x0]
8000891a:	f6 c8 ff f5 	sub	r8,r11,-11
8000891e:	e8 c1 00 08 	sub	r1,r4,8
80008922:	10 96       	mov	r6,r8
80008924:	62 1c       	ld.w	r12,r1[0x4]
80008926:	e0 16 ff f8 	andl	r6,0xfff8
8000892a:	59 68       	cp.w	r8,22
8000892c:	f9 b6 08 10 	movls	r6,16
80008930:	16 36       	cp.w	r6,r11
80008932:	5f 38       	srlo	r8
80008934:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008938:	c0 50       	breq	80008942 <_realloc_r+0x46>
8000893a:	30 c8       	mov	r8,12
8000893c:	30 05       	mov	r5,0
8000893e:	85 38       	st.w	r2[0xc],r8
80008940:	c3 b9       	rjmp	80008bb6 <_realloc_r+0x2ba>
80008942:	18 90       	mov	r0,r12
80008944:	e0 10 ff fc 	andl	r0,0xfffc
80008948:	0c 30       	cp.w	r0,r6
8000894a:	e0 84 01 0b 	brge	80008b60 <_realloc_r+0x264>
8000894e:	e0 68 05 54 	mov	r8,1364
80008952:	e2 00 00 09 	add	r9,r1,r0
80008956:	70 25       	ld.w	r5,r8[0x8]
80008958:	0a 39       	cp.w	r9,r5
8000895a:	c0 90       	breq	8000896c <_realloc_r+0x70>
8000895c:	72 1a       	ld.w	r10,r9[0x4]
8000895e:	a1 ca       	cbr	r10,0x0
80008960:	f2 0a 00 0a 	add	r10,r9,r10
80008964:	74 1a       	ld.w	r10,r10[0x4]
80008966:	ed ba 00 00 	bld	r10,0x0
8000896a:	c2 20       	breq	800089ae <_realloc_r+0xb2>
8000896c:	72 1a       	ld.w	r10,r9[0x4]
8000896e:	e0 1a ff fc 	andl	r10,0xfffc
80008972:	f4 00 00 03 	add	r3,r10,r0
80008976:	0a 39       	cp.w	r9,r5
80008978:	c1 31       	brne	8000899e <_realloc_r+0xa2>
8000897a:	ec c7 ff f0 	sub	r7,r6,-16
8000897e:	0e 33       	cp.w	r3,r7
80008980:	c1 95       	brlt	800089b2 <_realloc_r+0xb6>
80008982:	e2 06 00 09 	add	r9,r1,r6
80008986:	0c 13       	sub	r3,r6
80008988:	a1 a3       	sbr	r3,0x0
8000898a:	93 13       	st.w	r9[0x4],r3
8000898c:	91 29       	st.w	r8[0x8],r9
8000898e:	04 9c       	mov	r12,r2
80008990:	62 18       	ld.w	r8,r1[0x4]
80008992:	08 95       	mov	r5,r4
80008994:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008998:	10 46       	or	r6,r8
8000899a:	83 16       	st.w	r1[0x4],r6
8000899c:	c0 b9       	rjmp	80008bb2 <_realloc_r+0x2b6>
8000899e:	0c 33       	cp.w	r3,r6
800089a0:	c0 95       	brlt	800089b2 <_realloc_r+0xb6>
800089a2:	72 28       	ld.w	r8,r9[0x8]
800089a4:	02 97       	mov	r7,r1
800089a6:	72 39       	ld.w	r9,r9[0xc]
800089a8:	93 28       	st.w	r9[0x8],r8
800089aa:	91 39       	st.w	r8[0xc],r9
800089ac:	cd c8       	rjmp	80008b64 <_realloc_r+0x268>
800089ae:	30 0a       	mov	r10,0
800089b0:	14 99       	mov	r9,r10
800089b2:	ed bc 00 00 	bld	r12,0x0
800089b6:	e0 80 00 95 	breq	80008ae0 <_realloc_r+0x1e4>
800089ba:	62 07       	ld.w	r7,r1[0x0]
800089bc:	e2 07 01 07 	sub	r7,r1,r7
800089c0:	6e 1c       	ld.w	r12,r7[0x4]
800089c2:	e0 1c ff fc 	andl	r12,0xfffc
800089c6:	58 09       	cp.w	r9,0
800089c8:	c5 60       	breq	80008a74 <_realloc_r+0x178>
800089ca:	f8 00 00 03 	add	r3,r12,r0
800089ce:	0a 39       	cp.w	r9,r5
800089d0:	c4 81       	brne	80008a60 <_realloc_r+0x164>
800089d2:	14 03       	add	r3,r10
800089d4:	ec c9 ff f0 	sub	r9,r6,-16
800089d8:	12 33       	cp.w	r3,r9
800089da:	c4 d5       	brlt	80008a74 <_realloc_r+0x178>
800089dc:	6e 3a       	ld.w	r10,r7[0xc]
800089de:	6e 29       	ld.w	r9,r7[0x8]
800089e0:	95 29       	st.w	r10[0x8],r9
800089e2:	93 3a       	st.w	r9[0xc],r10
800089e4:	ee c5 ff f8 	sub	r5,r7,-8
800089e8:	e0 ca 00 04 	sub	r10,r0,4
800089ec:	e0 4a 00 24 	cp.w	r10,36
800089f0:	e0 8b 00 25 	brhi	80008a3a <_realloc_r+0x13e>
800089f4:	0a 99       	mov	r9,r5
800089f6:	59 3a       	cp.w	r10,19
800089f8:	e0 88 00 1a 	brls	80008a2c <_realloc_r+0x130>
800089fc:	09 09       	ld.w	r9,r4++
800089fe:	8b 09       	st.w	r5[0x0],r9
80008a00:	09 09       	ld.w	r9,r4++
80008a02:	8f 39       	st.w	r7[0xc],r9
80008a04:	ee c9 ff f0 	sub	r9,r7,-16
80008a08:	59 ba       	cp.w	r10,27
80008a0a:	e0 88 00 11 	brls	80008a2c <_realloc_r+0x130>
80008a0e:	09 0b       	ld.w	r11,r4++
80008a10:	93 0b       	st.w	r9[0x0],r11
80008a12:	09 09       	ld.w	r9,r4++
80008a14:	8f 59       	st.w	r7[0x14],r9
80008a16:	ee c9 ff e8 	sub	r9,r7,-24
80008a1a:	e0 4a 00 24 	cp.w	r10,36
80008a1e:	c0 71       	brne	80008a2c <_realloc_r+0x130>
80008a20:	09 0a       	ld.w	r10,r4++
80008a22:	93 0a       	st.w	r9[0x0],r10
80008a24:	ee c9 ff e0 	sub	r9,r7,-32
80008a28:	09 0a       	ld.w	r10,r4++
80008a2a:	8f 7a       	st.w	r7[0x1c],r10
80008a2c:	09 0a       	ld.w	r10,r4++
80008a2e:	12 aa       	st.w	r9++,r10
80008a30:	68 0a       	ld.w	r10,r4[0x0]
80008a32:	93 0a       	st.w	r9[0x0],r10
80008a34:	68 1a       	ld.w	r10,r4[0x4]
80008a36:	93 1a       	st.w	r9[0x4],r10
80008a38:	c0 78       	rjmp	80008a46 <_realloc_r+0x14a>
80008a3a:	50 08       	stdsp	sp[0x0],r8
80008a3c:	08 9b       	mov	r11,r4
80008a3e:	0a 9c       	mov	r12,r5
80008a40:	e0 a0 1d 8f 	rcall	8000c55e <memmove>
80008a44:	40 08       	lddsp	r8,sp[0x0]
80008a46:	ee 06 00 09 	add	r9,r7,r6
80008a4a:	0c 13       	sub	r3,r6
80008a4c:	a1 a3       	sbr	r3,0x0
80008a4e:	93 13       	st.w	r9[0x4],r3
80008a50:	91 29       	st.w	r8[0x8],r9
80008a52:	04 9c       	mov	r12,r2
80008a54:	6e 18       	ld.w	r8,r7[0x4]
80008a56:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a5a:	10 46       	or	r6,r8
80008a5c:	8f 16       	st.w	r7[0x4],r6
80008a5e:	ca a8       	rjmp	80008bb2 <_realloc_r+0x2b6>
80008a60:	14 03       	add	r3,r10
80008a62:	0c 33       	cp.w	r3,r6
80008a64:	c0 85       	brlt	80008a74 <_realloc_r+0x178>
80008a66:	72 28       	ld.w	r8,r9[0x8]
80008a68:	72 39       	ld.w	r9,r9[0xc]
80008a6a:	93 28       	st.w	r9[0x8],r8
80008a6c:	91 39       	st.w	r8[0xc],r9
80008a6e:	6e 28       	ld.w	r8,r7[0x8]
80008a70:	6e 39       	ld.w	r9,r7[0xc]
80008a72:	c0 78       	rjmp	80008a80 <_realloc_r+0x184>
80008a74:	f8 00 00 03 	add	r3,r12,r0
80008a78:	0c 33       	cp.w	r3,r6
80008a7a:	c3 35       	brlt	80008ae0 <_realloc_r+0x1e4>
80008a7c:	6e 39       	ld.w	r9,r7[0xc]
80008a7e:	6e 28       	ld.w	r8,r7[0x8]
80008a80:	93 28       	st.w	r9[0x8],r8
80008a82:	91 39       	st.w	r8[0xc],r9
80008a84:	e0 ca 00 04 	sub	r10,r0,4
80008a88:	ee cc ff f8 	sub	r12,r7,-8
80008a8c:	e0 4a 00 24 	cp.w	r10,36
80008a90:	e0 8b 00 24 	brhi	80008ad8 <_realloc_r+0x1dc>
80008a94:	59 3a       	cp.w	r10,19
80008a96:	e0 88 00 1a 	brls	80008aca <_realloc_r+0x1ce>
80008a9a:	09 08       	ld.w	r8,r4++
80008a9c:	99 08       	st.w	r12[0x0],r8
80008a9e:	09 08       	ld.w	r8,r4++
80008aa0:	8f 38       	st.w	r7[0xc],r8
80008aa2:	ee cc ff f0 	sub	r12,r7,-16
80008aa6:	59 ba       	cp.w	r10,27
80008aa8:	e0 88 00 11 	brls	80008aca <_realloc_r+0x1ce>
80008aac:	09 08       	ld.w	r8,r4++
80008aae:	99 08       	st.w	r12[0x0],r8
80008ab0:	09 08       	ld.w	r8,r4++
80008ab2:	8f 58       	st.w	r7[0x14],r8
80008ab4:	ee cc ff e8 	sub	r12,r7,-24
80008ab8:	e0 4a 00 24 	cp.w	r10,36
80008abc:	c0 71       	brne	80008aca <_realloc_r+0x1ce>
80008abe:	09 08       	ld.w	r8,r4++
80008ac0:	99 08       	st.w	r12[0x0],r8
80008ac2:	ee cc ff e0 	sub	r12,r7,-32
80008ac6:	09 08       	ld.w	r8,r4++
80008ac8:	8f 78       	st.w	r7[0x1c],r8
80008aca:	09 08       	ld.w	r8,r4++
80008acc:	18 a8       	st.w	r12++,r8
80008ace:	68 08       	ld.w	r8,r4[0x0]
80008ad0:	99 08       	st.w	r12[0x0],r8
80008ad2:	68 18       	ld.w	r8,r4[0x4]
80008ad4:	99 18       	st.w	r12[0x4],r8
80008ad6:	c4 78       	rjmp	80008b64 <_realloc_r+0x268>
80008ad8:	08 9b       	mov	r11,r4
80008ada:	e0 a0 1d 42 	rcall	8000c55e <memmove>
80008ade:	c4 38       	rjmp	80008b64 <_realloc_r+0x268>
80008ae0:	04 9c       	mov	r12,r2
80008ae2:	fe b0 fc 33 	rcall	80008348 <_malloc_r>
80008ae6:	18 95       	mov	r5,r12
80008ae8:	c3 a0       	breq	80008b5c <_realloc_r+0x260>
80008aea:	62 18       	ld.w	r8,r1[0x4]
80008aec:	f8 c9 00 08 	sub	r9,r12,8
80008af0:	a1 c8       	cbr	r8,0x0
80008af2:	e2 08 00 08 	add	r8,r1,r8
80008af6:	10 39       	cp.w	r9,r8
80008af8:	c0 71       	brne	80008b06 <_realloc_r+0x20a>
80008afa:	72 13       	ld.w	r3,r9[0x4]
80008afc:	02 97       	mov	r7,r1
80008afe:	e0 13 ff fc 	andl	r3,0xfffc
80008b02:	00 03       	add	r3,r0
80008b04:	c3 08       	rjmp	80008b64 <_realloc_r+0x268>
80008b06:	e0 ca 00 04 	sub	r10,r0,4
80008b0a:	e0 4a 00 24 	cp.w	r10,36
80008b0e:	e0 8b 00 20 	brhi	80008b4e <_realloc_r+0x252>
80008b12:	08 99       	mov	r9,r4
80008b14:	18 98       	mov	r8,r12
80008b16:	59 3a       	cp.w	r10,19
80008b18:	e0 88 00 14 	brls	80008b40 <_realloc_r+0x244>
80008b1c:	13 0b       	ld.w	r11,r9++
80008b1e:	10 ab       	st.w	r8++,r11
80008b20:	13 0b       	ld.w	r11,r9++
80008b22:	10 ab       	st.w	r8++,r11
80008b24:	59 ba       	cp.w	r10,27
80008b26:	e0 88 00 0d 	brls	80008b40 <_realloc_r+0x244>
80008b2a:	13 0b       	ld.w	r11,r9++
80008b2c:	10 ab       	st.w	r8++,r11
80008b2e:	13 0b       	ld.w	r11,r9++
80008b30:	10 ab       	st.w	r8++,r11
80008b32:	e0 4a 00 24 	cp.w	r10,36
80008b36:	c0 51       	brne	80008b40 <_realloc_r+0x244>
80008b38:	13 0a       	ld.w	r10,r9++
80008b3a:	10 aa       	st.w	r8++,r10
80008b3c:	13 0a       	ld.w	r10,r9++
80008b3e:	10 aa       	st.w	r8++,r10
80008b40:	13 0a       	ld.w	r10,r9++
80008b42:	10 aa       	st.w	r8++,r10
80008b44:	72 0a       	ld.w	r10,r9[0x0]
80008b46:	91 0a       	st.w	r8[0x0],r10
80008b48:	72 19       	ld.w	r9,r9[0x4]
80008b4a:	91 19       	st.w	r8[0x4],r9
80008b4c:	c0 48       	rjmp	80008b54 <_realloc_r+0x258>
80008b4e:	08 9b       	mov	r11,r4
80008b50:	e0 a0 1d 07 	rcall	8000c55e <memmove>
80008b54:	08 9b       	mov	r11,r4
80008b56:	04 9c       	mov	r12,r2
80008b58:	e0 a0 1a 60 	rcall	8000c018 <_free_r>
80008b5c:	04 9c       	mov	r12,r2
80008b5e:	c2 a8       	rjmp	80008bb2 <_realloc_r+0x2b6>
80008b60:	00 93       	mov	r3,r0
80008b62:	02 97       	mov	r7,r1
80008b64:	e6 06 01 09 	sub	r9,r3,r6
80008b68:	6e 18       	ld.w	r8,r7[0x4]
80008b6a:	58 f9       	cp.w	r9,15
80008b6c:	e0 88 00 16 	brls	80008b98 <_realloc_r+0x29c>
80008b70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008b74:	ed e8 10 08 	or	r8,r6,r8
80008b78:	8f 18       	st.w	r7[0x4],r8
80008b7a:	12 98       	mov	r8,r9
80008b7c:	a1 a8       	sbr	r8,0x0
80008b7e:	ee 06 00 0b 	add	r11,r7,r6
80008b82:	f6 09 00 09 	add	r9,r11,r9
80008b86:	97 18       	st.w	r11[0x4],r8
80008b88:	72 18       	ld.w	r8,r9[0x4]
80008b8a:	a1 a8       	sbr	r8,0x0
80008b8c:	2f 8b       	sub	r11,-8
80008b8e:	93 18       	st.w	r9[0x4],r8
80008b90:	04 9c       	mov	r12,r2
80008b92:	e0 a0 1a 43 	rcall	8000c018 <_free_r>
80008b96:	c0 b8       	rjmp	80008bac <_realloc_r+0x2b0>
80008b98:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008b9c:	e7 e8 10 08 	or	r8,r3,r8
80008ba0:	8f 18       	st.w	r7[0x4],r8
80008ba2:	ee 03 00 03 	add	r3,r7,r3
80008ba6:	66 18       	ld.w	r8,r3[0x4]
80008ba8:	a1 a8       	sbr	r8,0x0
80008baa:	87 18       	st.w	r3[0x4],r8
80008bac:	04 9c       	mov	r12,r2
80008bae:	ee c5 ff f8 	sub	r5,r7,-8
80008bb2:	fe b0 f1 7b 	rcall	80006ea8 <__malloc_unlock>
80008bb6:	0a 9c       	mov	r12,r5
80008bb8:	2f fd       	sub	sp,-4
80008bba:	d8 32       	popm	r0-r7,pc

80008bbc <_sbrk_r>:
80008bbc:	d4 21       	pushm	r4-r7,lr
80008bbe:	30 08       	mov	r8,0
80008bc0:	18 97       	mov	r7,r12
80008bc2:	e0 66 9e 08 	mov	r6,40456
80008bc6:	16 9c       	mov	r12,r11
80008bc8:	8d 08       	st.w	r6[0x0],r8
80008bca:	c8 5c       	rcall	80008cd4 <_sbrk>
80008bcc:	5b fc       	cp.w	r12,-1
80008bce:	c0 51       	brne	80008bd8 <_sbrk_r+0x1c>
80008bd0:	6c 08       	ld.w	r8,r6[0x0]
80008bd2:	58 08       	cp.w	r8,0
80008bd4:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008bd8:	d8 22       	popm	r4-r7,pc
80008bda:	d7 03       	nop

80008bdc <sprintf>:
80008bdc:	d4 01       	pushm	lr
80008bde:	21 7d       	sub	sp,92
80008be0:	e0 68 ff ff 	mov	r8,65535
80008be4:	ea 18 7f ff 	orh	r8,0x7fff
80008be8:	50 58       	stdsp	sp[0x14],r8
80008bea:	50 28       	stdsp	sp[0x8],r8
80008bec:	e0 68 02 08 	mov	r8,520
80008bf0:	ba 68       	st.h	sp[0xc],r8
80008bf2:	3f f8       	mov	r8,-1
80008bf4:	ba 78       	st.h	sp[0xe],r8
80008bf6:	e0 68 0a 54 	mov	r8,2644
80008bfa:	50 4c       	stdsp	sp[0x10],r12
80008bfc:	16 9a       	mov	r10,r11
80008bfe:	50 0c       	stdsp	sp[0x0],r12
80008c00:	fa c9 ff a0 	sub	r9,sp,-96
80008c04:	70 0c       	ld.w	r12,r8[0x0]
80008c06:	1a 9b       	mov	r11,sp
80008c08:	e0 a0 02 1a 	rcall	8000903c <_vfprintf_r>
80008c0c:	30 09       	mov	r9,0
80008c0e:	40 08       	lddsp	r8,sp[0x0]
80008c10:	b0 89       	st.b	r8[0x0],r9
80008c12:	2e 9d       	sub	sp,-92
80008c14:	d8 02       	popm	pc
80008c16:	d7 03       	nop

80008c18 <strncpy>:
80008c18:	30 08       	mov	r8,0
80008c1a:	10 3a       	cp.w	r10,r8
80008c1c:	5e 0c       	reteq	r12
80008c1e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008c22:	f8 08 0b 09 	st.b	r12[r8],r9
80008c26:	2f f8       	sub	r8,-1
80008c28:	58 09       	cp.w	r9,0
80008c2a:	cf 81       	brne	80008c1a <strncpy+0x2>
80008c2c:	10 3a       	cp.w	r10,r8
80008c2e:	5e 0c       	reteq	r12
80008c30:	f8 08 0b 09 	st.b	r12[r8],r9
80008c34:	2f f8       	sub	r8,-1
80008c36:	cf bb       	rjmp	80008c2c <strncpy+0x14>

80008c38 <_close>:
80008c38:	30 28       	mov	r8,2
80008c3a:	d6 73       	breakpoint
80008c3c:	3f fc       	mov	r12,-1
80008c3e:	35 8b       	mov	r11,88
80008c40:	58 0c       	cp.w	r12,0
80008c42:	5e 4c       	retge	r12
80008c44:	e0 6a 9e 08 	mov	r10,40456
80008c48:	95 0b       	st.w	r10[0x0],r11
80008c4a:	5e fc       	retal	r12

80008c4c <_lseek>:
80008c4c:	30 58       	mov	r8,5
80008c4e:	d6 73       	breakpoint
80008c50:	3f fc       	mov	r12,-1
80008c52:	35 8b       	mov	r11,88
80008c54:	58 0c       	cp.w	r12,0
80008c56:	5e 4c       	retge	r12
80008c58:	e0 6a 9e 08 	mov	r10,40456
80008c5c:	95 0b       	st.w	r10[0x0],r11
80008c5e:	5e fc       	retal	r12

80008c60 <isatty>:
80008c60:	30 b8       	mov	r8,11
80008c62:	d6 73       	breakpoint
80008c64:	3f fc       	mov	r12,-1
80008c66:	35 8b       	mov	r11,88
80008c68:	58 0c       	cp.w	r12,0
80008c6a:	5e 4c       	retge	r12
80008c6c:	e0 6a 9e 08 	mov	r10,40456
80008c70:	95 0b       	st.w	r10[0x0],r11
80008c72:	5e fc       	retal	r12

80008c74 <_fstat_host>:
80008c74:	30 98       	mov	r8,9
80008c76:	d6 73       	breakpoint
80008c78:	3f fc       	mov	r12,-1
80008c7a:	35 8b       	mov	r11,88
80008c7c:	58 0c       	cp.w	r12,0
80008c7e:	5e 4c       	retge	r12
80008c80:	e0 6a 9e 08 	mov	r10,40456
80008c84:	95 0b       	st.w	r10[0x0],r11
80008c86:	5e fc       	retal	r12

80008c88 <_fstat>:
80008c88:	d4 21       	pushm	r4-r7,lr
80008c8a:	21 0d       	sub	sp,64
80008c8c:	16 97       	mov	r7,r11
80008c8e:	1a 9b       	mov	r11,sp
80008c90:	cf 2f       	rcall	80008c74 <_fstat_host>
80008c92:	c0 34       	brge	80008c98 <_fstat+0x10>
80008c94:	3f fc       	mov	r12,-1
80008c96:	c1 c8       	rjmp	80008cce <_fstat+0x46>
80008c98:	40 08       	lddsp	r8,sp[0x0]
80008c9a:	ae 08       	st.h	r7[0x0],r8
80008c9c:	40 18       	lddsp	r8,sp[0x4]
80008c9e:	ae 18       	st.h	r7[0x2],r8
80008ca0:	40 28       	lddsp	r8,sp[0x8]
80008ca2:	8f 18       	st.w	r7[0x4],r8
80008ca4:	40 38       	lddsp	r8,sp[0xc]
80008ca6:	ae 48       	st.h	r7[0x8],r8
80008ca8:	40 48       	lddsp	r8,sp[0x10]
80008caa:	ae 58       	st.h	r7[0xa],r8
80008cac:	40 58       	lddsp	r8,sp[0x14]
80008cae:	ae 68       	st.h	r7[0xc],r8
80008cb0:	40 68       	lddsp	r8,sp[0x18]
80008cb2:	ae 78       	st.h	r7[0xe],r8
80008cb4:	40 88       	lddsp	r8,sp[0x20]
80008cb6:	8f 48       	st.w	r7[0x10],r8
80008cb8:	40 a8       	lddsp	r8,sp[0x28]
80008cba:	8f b8       	st.w	r7[0x2c],r8
80008cbc:	40 c8       	lddsp	r8,sp[0x30]
80008cbe:	8f c8       	st.w	r7[0x30],r8
80008cc0:	40 d8       	lddsp	r8,sp[0x34]
80008cc2:	8f 58       	st.w	r7[0x14],r8
80008cc4:	40 e8       	lddsp	r8,sp[0x38]
80008cc6:	30 0c       	mov	r12,0
80008cc8:	8f 78       	st.w	r7[0x1c],r8
80008cca:	40 f8       	lddsp	r8,sp[0x3c]
80008ccc:	8f 98       	st.w	r7[0x24],r8
80008cce:	2f 0d       	sub	sp,-64
80008cd0:	d8 22       	popm	r4-r7,pc
80008cd2:	d7 03       	nop

80008cd4 <_sbrk>:
80008cd4:	d4 01       	pushm	lr
80008cd6:	e0 68 0e 18 	mov	r8,3608
80008cda:	70 09       	ld.w	r9,r8[0x0]
80008cdc:	58 09       	cp.w	r9,0
80008cde:	c0 41       	brne	80008ce6 <_sbrk+0x12>
80008ce0:	e0 69 9e 10 	mov	r9,40464
80008ce4:	91 09       	st.w	r8[0x0],r9
80008ce6:	e0 69 0e 18 	mov	r9,3608
80008cea:	e0 7a 70 00 	mov	r10,94208
80008cee:	72 08       	ld.w	r8,r9[0x0]
80008cf0:	f0 0c 00 0c 	add	r12,r8,r12
80008cf4:	14 3c       	cp.w	r12,r10
80008cf6:	e0 8b 00 04 	brhi	80008cfe <_sbrk+0x2a>
80008cfa:	93 0c       	st.w	r9[0x0],r12
80008cfc:	c0 68       	rjmp	80008d08 <_sbrk+0x34>
80008cfe:	e0 a0 18 15 	rcall	8000bd28 <__errno>
80008d02:	30 c8       	mov	r8,12
80008d04:	99 08       	st.w	r12[0x0],r8
80008d06:	3f f8       	mov	r8,-1
80008d08:	10 9c       	mov	r12,r8
80008d0a:	d8 02       	popm	pc

80008d0c <get_arg>:
80008d0c:	d4 31       	pushm	r0-r7,lr
80008d0e:	20 8d       	sub	sp,32
80008d10:	fa c4 ff bc 	sub	r4,sp,-68
80008d14:	50 4b       	stdsp	sp[0x10],r11
80008d16:	68 2e       	ld.w	lr,r4[0x8]
80008d18:	50 58       	stdsp	sp[0x14],r8
80008d1a:	12 96       	mov	r6,r9
80008d1c:	7c 0b       	ld.w	r11,lr[0x0]
80008d1e:	70 05       	ld.w	r5,r8[0x0]
80008d20:	50 6e       	stdsp	sp[0x18],lr
80008d22:	58 0b       	cp.w	r11,0
80008d24:	f4 0b 17 00 	moveq	r11,r10
80008d28:	68 03       	ld.w	r3,r4[0x0]
80008d2a:	68 11       	ld.w	r1,r4[0x4]
80008d2c:	40 49       	lddsp	r9,sp[0x10]
80008d2e:	30 08       	mov	r8,0
80008d30:	c2 89       	rjmp	80008f80 <get_arg+0x274>
80008d32:	2f fb       	sub	r11,-1
80008d34:	32 5c       	mov	r12,37
80008d36:	17 8a       	ld.ub	r10,r11[0x0]
80008d38:	f8 0a 18 00 	cp.b	r10,r12
80008d3c:	5f 1e       	srne	lr
80008d3e:	f0 0a 18 00 	cp.b	r10,r8
80008d42:	5f 1c       	srne	r12
80008d44:	fd ec 00 0c 	and	r12,lr,r12
80008d48:	f0 0c 18 00 	cp.b	r12,r8
80008d4c:	cf 31       	brne	80008d32 <get_arg+0x26>
80008d4e:	58 0a       	cp.w	r10,0
80008d50:	e0 80 01 25 	breq	80008f9a <get_arg+0x28e>
80008d54:	30 0c       	mov	r12,0
80008d56:	3f fa       	mov	r10,-1
80008d58:	18 90       	mov	r0,r12
80008d5a:	50 3a       	stdsp	sp[0xc],r10
80008d5c:	18 94       	mov	r4,r12
80008d5e:	18 92       	mov	r2,r12
80008d60:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008d64:	16 97       	mov	r7,r11
80008d66:	50 7c       	stdsp	sp[0x1c],r12
80008d68:	fe cc 9a 08 	sub	r12,pc,-26104
80008d6c:	0f 3a       	ld.ub	r10,r7++
80008d6e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008d72:	40 7c       	lddsp	r12,sp[0x1c]
80008d74:	1c 0c       	add	r12,lr
80008d76:	fe ce 9a de 	sub	lr,pc,-25890
80008d7a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008d7e:	20 1e       	sub	lr,1
80008d80:	50 0e       	stdsp	sp[0x0],lr
80008d82:	fe ce 9b 56 	sub	lr,pc,-25770
80008d86:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008d8a:	50 7c       	stdsp	sp[0x1c],r12
80008d8c:	40 0c       	lddsp	r12,sp[0x0]
80008d8e:	58 7c       	cp.w	r12,7
80008d90:	e0 8b 00 f1 	brhi	80008f72 <get_arg+0x266>
80008d94:	fe ce 9d 08 	sub	lr,pc,-25336
80008d98:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008d9c:	36 8b       	mov	r11,104
80008d9e:	f6 0a 18 00 	cp.b	r10,r11
80008da2:	e0 80 00 e8 	breq	80008f72 <get_arg+0x266>
80008da6:	37 1b       	mov	r11,113
80008da8:	f6 0a 18 00 	cp.b	r10,r11
80008dac:	c0 70       	breq	80008dba <get_arg+0xae>
80008dae:	34 cb       	mov	r11,76
80008db0:	f6 0a 18 00 	cp.b	r10,r11
80008db4:	c0 51       	brne	80008dbe <get_arg+0xb2>
80008db6:	a3 b4       	sbr	r4,0x3
80008db8:	cd d8       	rjmp	80008f72 <get_arg+0x266>
80008dba:	a5 b4       	sbr	r4,0x5
80008dbc:	cd b8       	rjmp	80008f72 <get_arg+0x266>
80008dbe:	08 9a       	mov	r10,r4
80008dc0:	0e 9b       	mov	r11,r7
80008dc2:	a5 aa       	sbr	r10,0x4
80008dc4:	17 3c       	ld.ub	r12,r11++
80008dc6:	a5 b4       	sbr	r4,0x5
80008dc8:	36 ce       	mov	lr,108
80008dca:	fc 0c 18 00 	cp.b	r12,lr
80008dce:	e0 80 00 d3 	breq	80008f74 <get_arg+0x268>
80008dd2:	14 94       	mov	r4,r10
80008dd4:	cc f8       	rjmp	80008f72 <get_arg+0x266>
80008dd6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008dda:	36 7c       	mov	r12,103
80008ddc:	f8 0a 18 00 	cp.b	r10,r12
80008de0:	e0 8b 00 27 	brhi	80008e2e <get_arg+0x122>
80008de4:	36 5b       	mov	r11,101
80008de6:	f6 0a 18 00 	cp.b	r10,r11
80008dea:	c4 82       	brcc	80008e7a <get_arg+0x16e>
80008dec:	34 fb       	mov	r11,79
80008dee:	f6 0a 18 00 	cp.b	r10,r11
80008df2:	c4 80       	breq	80008e82 <get_arg+0x176>
80008df4:	e0 8b 00 0c 	brhi	80008e0c <get_arg+0x100>
80008df8:	34 5b       	mov	r11,69
80008dfa:	f6 0a 18 00 	cp.b	r10,r11
80008dfe:	c3 e0       	breq	80008e7a <get_arg+0x16e>
80008e00:	34 7b       	mov	r11,71
80008e02:	f6 0a 18 00 	cp.b	r10,r11
80008e06:	c3 a0       	breq	80008e7a <get_arg+0x16e>
80008e08:	34 4b       	mov	r11,68
80008e0a:	c0 88       	rjmp	80008e1a <get_arg+0x10e>
80008e0c:	35 8b       	mov	r11,88
80008e0e:	f6 0a 18 00 	cp.b	r10,r11
80008e12:	c2 c0       	breq	80008e6a <get_arg+0x15e>
80008e14:	e0 8b 00 07 	brhi	80008e22 <get_arg+0x116>
80008e18:	35 5b       	mov	r11,85
80008e1a:	f6 0a 18 00 	cp.b	r10,r11
80008e1e:	c3 51       	brne	80008e88 <get_arg+0x17c>
80008e20:	c3 18       	rjmp	80008e82 <get_arg+0x176>
80008e22:	36 3b       	mov	r11,99
80008e24:	f6 0a 18 00 	cp.b	r10,r11
80008e28:	c2 f0       	breq	80008e86 <get_arg+0x17a>
80008e2a:	36 4b       	mov	r11,100
80008e2c:	c0 e8       	rjmp	80008e48 <get_arg+0x13c>
80008e2e:	37 0b       	mov	r11,112
80008e30:	f6 0a 18 00 	cp.b	r10,r11
80008e34:	c2 50       	breq	80008e7e <get_arg+0x172>
80008e36:	e0 8b 00 0d 	brhi	80008e50 <get_arg+0x144>
80008e3a:	36 eb       	mov	r11,110
80008e3c:	f6 0a 18 00 	cp.b	r10,r11
80008e40:	c1 f0       	breq	80008e7e <get_arg+0x172>
80008e42:	e0 8b 00 14 	brhi	80008e6a <get_arg+0x15e>
80008e46:	36 9b       	mov	r11,105
80008e48:	f6 0a 18 00 	cp.b	r10,r11
80008e4c:	c1 e1       	brne	80008e88 <get_arg+0x17c>
80008e4e:	c0 e8       	rjmp	80008e6a <get_arg+0x15e>
80008e50:	37 5b       	mov	r11,117
80008e52:	f6 0a 18 00 	cp.b	r10,r11
80008e56:	c0 a0       	breq	80008e6a <get_arg+0x15e>
80008e58:	37 8b       	mov	r11,120
80008e5a:	f6 0a 18 00 	cp.b	r10,r11
80008e5e:	c0 60       	breq	80008e6a <get_arg+0x15e>
80008e60:	37 3b       	mov	r11,115
80008e62:	f6 0a 18 00 	cp.b	r10,r11
80008e66:	c1 11       	brne	80008e88 <get_arg+0x17c>
80008e68:	c0 b8       	rjmp	80008e7e <get_arg+0x172>
80008e6a:	ed b4 00 04 	bld	r4,0x4
80008e6e:	c0 a0       	breq	80008e82 <get_arg+0x176>
80008e70:	ed b4 00 05 	bld	r4,0x5
80008e74:	c0 91       	brne	80008e86 <get_arg+0x17a>
80008e76:	30 20       	mov	r0,2
80008e78:	c0 88       	rjmp	80008e88 <get_arg+0x17c>
80008e7a:	30 40       	mov	r0,4
80008e7c:	c0 68       	rjmp	80008e88 <get_arg+0x17c>
80008e7e:	30 30       	mov	r0,3
80008e80:	c0 48       	rjmp	80008e88 <get_arg+0x17c>
80008e82:	30 10       	mov	r0,1
80008e84:	c0 28       	rjmp	80008e88 <get_arg+0x17c>
80008e86:	30 00       	mov	r0,0
80008e88:	40 3b       	lddsp	r11,sp[0xc]
80008e8a:	5b fb       	cp.w	r11,-1
80008e8c:	c0 40       	breq	80008e94 <get_arg+0x188>
80008e8e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008e92:	c7 08       	rjmp	80008f72 <get_arg+0x266>
80008e94:	58 60       	cp.w	r0,6
80008e96:	e0 8b 00 6e 	brhi	80008f72 <get_arg+0x266>
80008e9a:	6c 0a       	ld.w	r10,r6[0x0]
80008e9c:	ea cc ff ff 	sub	r12,r5,-1
80008ea0:	fe ce 9d f4 	sub	lr,pc,-25100
80008ea4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008ea8:	f4 cb ff f8 	sub	r11,r10,-8
80008eac:	8d 0b       	st.w	r6[0x0],r11
80008eae:	f4 ea 00 00 	ld.d	r10,r10[0]
80008eb2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008eb6:	c0 f8       	rjmp	80008ed4 <get_arg+0x1c8>
80008eb8:	f4 cb ff fc 	sub	r11,r10,-4
80008ebc:	8d 0b       	st.w	r6[0x0],r11
80008ebe:	74 0a       	ld.w	r10,r10[0x0]
80008ec0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008ec4:	c0 88       	rjmp	80008ed4 <get_arg+0x1c8>
80008ec6:	f4 cb ff f8 	sub	r11,r10,-8
80008eca:	8d 0b       	st.w	r6[0x0],r11
80008ecc:	f4 ea 00 00 	ld.d	r10,r10[0]
80008ed0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008ed4:	0e 9b       	mov	r11,r7
80008ed6:	18 95       	mov	r5,r12
80008ed8:	c4 e8       	rjmp	80008f74 <get_arg+0x268>
80008eda:	62 0a       	ld.w	r10,r1[0x0]
80008edc:	5b fa       	cp.w	r10,-1
80008ede:	c0 b1       	brne	80008ef4 <get_arg+0x1e8>
80008ee0:	50 19       	stdsp	sp[0x4],r9
80008ee2:	50 28       	stdsp	sp[0x8],r8
80008ee4:	e0 6a 00 80 	mov	r10,128
80008ee8:	30 0b       	mov	r11,0
80008eea:	02 9c       	mov	r12,r1
80008eec:	fe b0 fd 01 	rcall	800088ee <memset>
80008ef0:	40 28       	lddsp	r8,sp[0x8]
80008ef2:	40 19       	lddsp	r9,sp[0x4]
80008ef4:	e4 cc 00 01 	sub	r12,r2,1
80008ef8:	0e 9b       	mov	r11,r7
80008efa:	50 3c       	stdsp	sp[0xc],r12
80008efc:	f2 0c 0c 49 	max	r9,r9,r12
80008f00:	c3 a8       	rjmp	80008f74 <get_arg+0x268>
80008f02:	62 0a       	ld.w	r10,r1[0x0]
80008f04:	5b fa       	cp.w	r10,-1
80008f06:	c0 b1       	brne	80008f1c <get_arg+0x210>
80008f08:	50 19       	stdsp	sp[0x4],r9
80008f0a:	50 28       	stdsp	sp[0x8],r8
80008f0c:	e0 6a 00 80 	mov	r10,128
80008f10:	30 0b       	mov	r11,0
80008f12:	02 9c       	mov	r12,r1
80008f14:	fe b0 fc ed 	rcall	800088ee <memset>
80008f18:	40 28       	lddsp	r8,sp[0x8]
80008f1a:	40 19       	lddsp	r9,sp[0x4]
80008f1c:	20 12       	sub	r2,1
80008f1e:	30 0a       	mov	r10,0
80008f20:	0e 9b       	mov	r11,r7
80008f22:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008f26:	f2 02 0c 49 	max	r9,r9,r2
80008f2a:	c2 58       	rjmp	80008f74 <get_arg+0x268>
80008f2c:	16 97       	mov	r7,r11
80008f2e:	6c 0a       	ld.w	r10,r6[0x0]
80008f30:	f4 cb ff fc 	sub	r11,r10,-4
80008f34:	8d 0b       	st.w	r6[0x0],r11
80008f36:	74 0a       	ld.w	r10,r10[0x0]
80008f38:	0e 9b       	mov	r11,r7
80008f3a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f3e:	2f f5       	sub	r5,-1
80008f40:	c1 a8       	rjmp	80008f74 <get_arg+0x268>
80008f42:	f4 c2 00 30 	sub	r2,r10,48
80008f46:	c0 68       	rjmp	80008f52 <get_arg+0x246>
80008f48:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008f4c:	2f f7       	sub	r7,-1
80008f4e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008f52:	0f 8a       	ld.ub	r10,r7[0x0]
80008f54:	58 0a       	cp.w	r10,0
80008f56:	c0 e0       	breq	80008f72 <get_arg+0x266>
80008f58:	23 0a       	sub	r10,48
80008f5a:	58 9a       	cp.w	r10,9
80008f5c:	fe 98 ff f6 	brls	80008f48 <get_arg+0x23c>
80008f60:	c0 98       	rjmp	80008f72 <get_arg+0x266>
80008f62:	2f f7       	sub	r7,-1
80008f64:	0f 8a       	ld.ub	r10,r7[0x0]
80008f66:	58 0a       	cp.w	r10,0
80008f68:	c0 50       	breq	80008f72 <get_arg+0x266>
80008f6a:	23 0a       	sub	r10,48
80008f6c:	58 9a       	cp.w	r10,9
80008f6e:	fe 98 ff fa 	brls	80008f62 <get_arg+0x256>
80008f72:	0e 9b       	mov	r11,r7
80008f74:	40 7c       	lddsp	r12,sp[0x1c]
80008f76:	30 ba       	mov	r10,11
80008f78:	f4 0c 18 00 	cp.b	r12,r10
80008f7c:	fe 91 fe f2 	brne	80008d60 <get_arg+0x54>
80008f80:	40 42       	lddsp	r2,sp[0x10]
80008f82:	17 8c       	ld.ub	r12,r11[0x0]
80008f84:	0a 32       	cp.w	r2,r5
80008f86:	5f 4a       	srge	r10
80008f88:	f0 0c 18 00 	cp.b	r12,r8
80008f8c:	5f 1c       	srne	r12
80008f8e:	f9 ea 00 0a 	and	r10,r12,r10
80008f92:	f0 0a 18 00 	cp.b	r10,r8
80008f96:	fe 91 fe cf 	brne	80008d34 <get_arg+0x28>
80008f9a:	30 08       	mov	r8,0
80008f9c:	40 4e       	lddsp	lr,sp[0x10]
80008f9e:	17 8a       	ld.ub	r10,r11[0x0]
80008fa0:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008fa4:	f0 0a 18 00 	cp.b	r10,r8
80008fa8:	fc 09 17 10 	movne	r9,lr
80008fac:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008fb0:	06 9e       	mov	lr,r3
80008fb2:	c2 a8       	rjmp	80009006 <get_arg+0x2fa>
80008fb4:	62 0a       	ld.w	r10,r1[0x0]
80008fb6:	58 3a       	cp.w	r10,3
80008fb8:	c1 e0       	breq	80008ff4 <get_arg+0x2e8>
80008fba:	e0 89 00 07 	brgt	80008fc8 <get_arg+0x2bc>
80008fbe:	58 1a       	cp.w	r10,1
80008fc0:	c1 a0       	breq	80008ff4 <get_arg+0x2e8>
80008fc2:	58 2a       	cp.w	r10,2
80008fc4:	c1 81       	brne	80008ff4 <get_arg+0x2e8>
80008fc6:	c0 58       	rjmp	80008fd0 <get_arg+0x2c4>
80008fc8:	58 5a       	cp.w	r10,5
80008fca:	c0 c0       	breq	80008fe2 <get_arg+0x2d6>
80008fcc:	c0 b5       	brlt	80008fe2 <get_arg+0x2d6>
80008fce:	c1 38       	rjmp	80008ff4 <get_arg+0x2e8>
80008fd0:	6c 0a       	ld.w	r10,r6[0x0]
80008fd2:	f4 cc ff f8 	sub	r12,r10,-8
80008fd6:	8d 0c       	st.w	r6[0x0],r12
80008fd8:	f4 e2 00 00 	ld.d	r2,r10[0]
80008fdc:	f0 e3 00 00 	st.d	r8[0],r2
80008fe0:	c1 08       	rjmp	80009000 <get_arg+0x2f4>
80008fe2:	6c 0a       	ld.w	r10,r6[0x0]
80008fe4:	f4 cc ff f8 	sub	r12,r10,-8
80008fe8:	8d 0c       	st.w	r6[0x0],r12
80008fea:	f4 e2 00 00 	ld.d	r2,r10[0]
80008fee:	f0 e3 00 00 	st.d	r8[0],r2
80008ff2:	c0 78       	rjmp	80009000 <get_arg+0x2f4>
80008ff4:	6c 0a       	ld.w	r10,r6[0x0]
80008ff6:	f4 cc ff fc 	sub	r12,r10,-4
80008ffa:	8d 0c       	st.w	r6[0x0],r12
80008ffc:	74 0a       	ld.w	r10,r10[0x0]
80008ffe:	91 0a       	st.w	r8[0x0],r10
80009000:	2f f5       	sub	r5,-1
80009002:	2f 88       	sub	r8,-8
80009004:	2f c1       	sub	r1,-4
80009006:	12 35       	cp.w	r5,r9
80009008:	fe 9a ff d6 	brle	80008fb4 <get_arg+0x2a8>
8000900c:	1c 93       	mov	r3,lr
8000900e:	40 52       	lddsp	r2,sp[0x14]
80009010:	40 6e       	lddsp	lr,sp[0x18]
80009012:	85 05       	st.w	r2[0x0],r5
80009014:	9d 0b       	st.w	lr[0x0],r11
80009016:	40 4b       	lddsp	r11,sp[0x10]
80009018:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000901c:	2f 8d       	sub	sp,-32
8000901e:	d8 32       	popm	r0-r7,pc

80009020 <__sprint_r>:
80009020:	d4 21       	pushm	r4-r7,lr
80009022:	14 97       	mov	r7,r10
80009024:	74 28       	ld.w	r8,r10[0x8]
80009026:	58 08       	cp.w	r8,0
80009028:	c0 41       	brne	80009030 <__sprint_r+0x10>
8000902a:	95 18       	st.w	r10[0x4],r8
8000902c:	10 9c       	mov	r12,r8
8000902e:	d8 22       	popm	r4-r7,pc
80009030:	e0 a0 18 ba 	rcall	8000c1a4 <__sfvwrite_r>
80009034:	30 08       	mov	r8,0
80009036:	8f 18       	st.w	r7[0x4],r8
80009038:	8f 28       	st.w	r7[0x8],r8
8000903a:	d8 22       	popm	r4-r7,pc

8000903c <_vfprintf_r>:
8000903c:	d4 31       	pushm	r0-r7,lr
8000903e:	fa cd 06 bc 	sub	sp,sp,1724
80009042:	51 09       	stdsp	sp[0x40],r9
80009044:	16 91       	mov	r1,r11
80009046:	14 97       	mov	r7,r10
80009048:	18 95       	mov	r5,r12
8000904a:	e0 a0 1a 1d 	rcall	8000c484 <_localeconv_r>
8000904e:	78 0c       	ld.w	r12,r12[0x0]
80009050:	50 cc       	stdsp	sp[0x30],r12
80009052:	58 05       	cp.w	r5,0
80009054:	c0 70       	breq	80009062 <_vfprintf_r+0x26>
80009056:	6a 68       	ld.w	r8,r5[0x18]
80009058:	58 08       	cp.w	r8,0
8000905a:	c0 41       	brne	80009062 <_vfprintf_r+0x26>
8000905c:	0a 9c       	mov	r12,r5
8000905e:	e0 a0 17 43 	rcall	8000bee4 <__sinit>
80009062:	fe c8 9b f2 	sub	r8,pc,-25614
80009066:	10 31       	cp.w	r1,r8
80009068:	c0 31       	brne	8000906e <_vfprintf_r+0x32>
8000906a:	6a 01       	ld.w	r1,r5[0x0]
8000906c:	c0 c8       	rjmp	80009084 <_vfprintf_r+0x48>
8000906e:	fe c8 9b de 	sub	r8,pc,-25634
80009072:	10 31       	cp.w	r1,r8
80009074:	c0 31       	brne	8000907a <_vfprintf_r+0x3e>
80009076:	6a 11       	ld.w	r1,r5[0x4]
80009078:	c0 68       	rjmp	80009084 <_vfprintf_r+0x48>
8000907a:	fe c8 9b ca 	sub	r8,pc,-25654
8000907e:	10 31       	cp.w	r1,r8
80009080:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80009084:	82 68       	ld.sh	r8,r1[0xc]
80009086:	ed b8 00 03 	bld	r8,0x3
8000908a:	c0 41       	brne	80009092 <_vfprintf_r+0x56>
8000908c:	62 48       	ld.w	r8,r1[0x10]
8000908e:	58 08       	cp.w	r8,0
80009090:	c0 71       	brne	8000909e <_vfprintf_r+0x62>
80009092:	02 9b       	mov	r11,r1
80009094:	0a 9c       	mov	r12,r5
80009096:	e0 a0 0f 5d 	rcall	8000af50 <__swsetup_r>
8000909a:	e0 81 0f 54 	brne	8000af42 <_vfprintf_r+0x1f06>
8000909e:	82 68       	ld.sh	r8,r1[0xc]
800090a0:	10 99       	mov	r9,r8
800090a2:	e2 19 00 1a 	andl	r9,0x1a,COH
800090a6:	58 a9       	cp.w	r9,10
800090a8:	c3 c1       	brne	80009120 <_vfprintf_r+0xe4>
800090aa:	82 79       	ld.sh	r9,r1[0xe]
800090ac:	30 0a       	mov	r10,0
800090ae:	f4 09 19 00 	cp.h	r9,r10
800090b2:	c3 75       	brlt	80009120 <_vfprintf_r+0xe4>
800090b4:	a1 d8       	cbr	r8,0x1
800090b6:	fb 58 05 d0 	st.h	sp[1488],r8
800090ba:	62 88       	ld.w	r8,r1[0x20]
800090bc:	fb 48 05 e4 	st.w	sp[1508],r8
800090c0:	62 a8       	ld.w	r8,r1[0x28]
800090c2:	fb 48 05 ec 	st.w	sp[1516],r8
800090c6:	fa c8 ff bc 	sub	r8,sp,-68
800090ca:	fb 48 05 d4 	st.w	sp[1492],r8
800090ce:	fb 48 05 c4 	st.w	sp[1476],r8
800090d2:	e0 68 04 00 	mov	r8,1024
800090d6:	fb 48 05 d8 	st.w	sp[1496],r8
800090da:	fb 48 05 cc 	st.w	sp[1484],r8
800090de:	30 08       	mov	r8,0
800090e0:	fb 59 05 d2 	st.h	sp[1490],r9
800090e4:	0e 9a       	mov	r10,r7
800090e6:	41 09       	lddsp	r9,sp[0x40]
800090e8:	fa c7 fa 3c 	sub	r7,sp,-1476
800090ec:	fb 48 05 dc 	st.w	sp[1500],r8
800090f0:	0a 9c       	mov	r12,r5
800090f2:	0e 9b       	mov	r11,r7
800090f4:	ca 4f       	rcall	8000903c <_vfprintf_r>
800090f6:	50 bc       	stdsp	sp[0x2c],r12
800090f8:	c0 95       	brlt	8000910a <_vfprintf_r+0xce>
800090fa:	0e 9b       	mov	r11,r7
800090fc:	0a 9c       	mov	r12,r5
800090fe:	e0 a0 16 1b 	rcall	8000bd34 <_fflush_r>
80009102:	40 be       	lddsp	lr,sp[0x2c]
80009104:	f9 be 01 ff 	movne	lr,-1
80009108:	50 be       	stdsp	sp[0x2c],lr
8000910a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000910e:	ed b8 00 06 	bld	r8,0x6
80009112:	e0 81 0f 1a 	brne	8000af46 <_vfprintf_r+0x1f0a>
80009116:	82 68       	ld.sh	r8,r1[0xc]
80009118:	a7 a8       	sbr	r8,0x6
8000911a:	a2 68       	st.h	r1[0xc],r8
8000911c:	e0 8f 0f 15 	bral	8000af46 <_vfprintf_r+0x1f0a>
80009120:	30 08       	mov	r8,0
80009122:	fb 48 06 b4 	st.w	sp[1716],r8
80009126:	fb 48 06 90 	st.w	sp[1680],r8
8000912a:	fb 48 06 8c 	st.w	sp[1676],r8
8000912e:	fb 48 06 b0 	st.w	sp[1712],r8
80009132:	30 08       	mov	r8,0
80009134:	30 09       	mov	r9,0
80009136:	50 a7       	stdsp	sp[0x28],r7
80009138:	50 78       	stdsp	sp[0x1c],r8
8000913a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000913e:	3f f8       	mov	r8,-1
80009140:	50 59       	stdsp	sp[0x14],r9
80009142:	fb 43 06 88 	st.w	sp[1672],r3
80009146:	fb 48 05 44 	st.w	sp[1348],r8
8000914a:	12 9c       	mov	r12,r9
8000914c:	50 69       	stdsp	sp[0x18],r9
8000914e:	50 d9       	stdsp	sp[0x34],r9
80009150:	50 e9       	stdsp	sp[0x38],r9
80009152:	50 b9       	stdsp	sp[0x2c],r9
80009154:	12 97       	mov	r7,r9
80009156:	0a 94       	mov	r4,r5
80009158:	40 a2       	lddsp	r2,sp[0x28]
8000915a:	32 5a       	mov	r10,37
8000915c:	30 08       	mov	r8,0
8000915e:	c0 28       	rjmp	80009162 <_vfprintf_r+0x126>
80009160:	2f f2       	sub	r2,-1
80009162:	05 89       	ld.ub	r9,r2[0x0]
80009164:	f0 09 18 00 	cp.b	r9,r8
80009168:	5f 1b       	srne	r11
8000916a:	f4 09 18 00 	cp.b	r9,r10
8000916e:	5f 19       	srne	r9
80009170:	f3 eb 00 0b 	and	r11,r9,r11
80009174:	f0 0b 18 00 	cp.b	r11,r8
80009178:	cf 41       	brne	80009160 <_vfprintf_r+0x124>
8000917a:	40 ab       	lddsp	r11,sp[0x28]
8000917c:	e4 0b 01 06 	sub	r6,r2,r11
80009180:	c1 e0       	breq	800091bc <_vfprintf_r+0x180>
80009182:	fa f8 06 90 	ld.w	r8,sp[1680]
80009186:	0c 08       	add	r8,r6
80009188:	87 0b       	st.w	r3[0x0],r11
8000918a:	fb 48 06 90 	st.w	sp[1680],r8
8000918e:	87 16       	st.w	r3[0x4],r6
80009190:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009194:	2f f8       	sub	r8,-1
80009196:	fb 48 06 8c 	st.w	sp[1676],r8
8000919a:	58 78       	cp.w	r8,7
8000919c:	e0 89 00 04 	brgt	800091a4 <_vfprintf_r+0x168>
800091a0:	2f 83       	sub	r3,-8
800091a2:	c0 a8       	rjmp	800091b6 <_vfprintf_r+0x17a>
800091a4:	fa ca f9 78 	sub	r10,sp,-1672
800091a8:	02 9b       	mov	r11,r1
800091aa:	08 9c       	mov	r12,r4
800091ac:	c3 af       	rcall	80009020 <__sprint_r>
800091ae:	e0 81 0e c6 	brne	8000af3a <_vfprintf_r+0x1efe>
800091b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800091b6:	40 ba       	lddsp	r10,sp[0x2c]
800091b8:	0c 0a       	add	r10,r6
800091ba:	50 ba       	stdsp	sp[0x2c],r10
800091bc:	05 89       	ld.ub	r9,r2[0x0]
800091be:	30 08       	mov	r8,0
800091c0:	f0 09 18 00 	cp.b	r9,r8
800091c4:	e0 80 0e aa 	breq	8000af18 <_vfprintf_r+0x1edc>
800091c8:	30 09       	mov	r9,0
800091ca:	fb 68 06 bb 	st.b	sp[1723],r8
800091ce:	0e 96       	mov	r6,r7
800091d0:	e4 c8 ff ff 	sub	r8,r2,-1
800091d4:	3f fe       	mov	lr,-1
800091d6:	50 93       	stdsp	sp[0x24],r3
800091d8:	50 41       	stdsp	sp[0x10],r1
800091da:	0e 93       	mov	r3,r7
800091dc:	04 91       	mov	r1,r2
800091de:	50 89       	stdsp	sp[0x20],r9
800091e0:	50 a8       	stdsp	sp[0x28],r8
800091e2:	50 2e       	stdsp	sp[0x8],lr
800091e4:	50 39       	stdsp	sp[0xc],r9
800091e6:	12 95       	mov	r5,r9
800091e8:	12 90       	mov	r0,r9
800091ea:	10 97       	mov	r7,r8
800091ec:	08 92       	mov	r2,r4
800091ee:	c0 78       	rjmp	800091fc <_vfprintf_r+0x1c0>
800091f0:	3f fc       	mov	r12,-1
800091f2:	08 97       	mov	r7,r4
800091f4:	50 2c       	stdsp	sp[0x8],r12
800091f6:	c0 38       	rjmp	800091fc <_vfprintf_r+0x1c0>
800091f8:	30 0b       	mov	r11,0
800091fa:	50 3b       	stdsp	sp[0xc],r11
800091fc:	0f 38       	ld.ub	r8,r7++
800091fe:	c0 28       	rjmp	80009202 <_vfprintf_r+0x1c6>
80009200:	12 90       	mov	r0,r9
80009202:	f0 c9 00 20 	sub	r9,r8,32
80009206:	e0 49 00 58 	cp.w	r9,88
8000920a:	e0 8b 0a 30 	brhi	8000a66a <_vfprintf_r+0x162e>
8000920e:	fe ca a1 46 	sub	r10,pc,-24250
80009212:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80009216:	50 a7       	stdsp	sp[0x28],r7
80009218:	50 80       	stdsp	sp[0x20],r0
8000921a:	0c 97       	mov	r7,r6
8000921c:	04 94       	mov	r4,r2
8000921e:	06 96       	mov	r6,r3
80009220:	02 92       	mov	r2,r1
80009222:	fe c9 9f 1e 	sub	r9,pc,-24802
80009226:	40 93       	lddsp	r3,sp[0x24]
80009228:	10 90       	mov	r0,r8
8000922a:	40 41       	lddsp	r1,sp[0x10]
8000922c:	50 d9       	stdsp	sp[0x34],r9
8000922e:	e0 8f 08 8e 	bral	8000a34a <_vfprintf_r+0x130e>
80009232:	30 08       	mov	r8,0
80009234:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80009238:	f0 09 18 00 	cp.b	r9,r8
8000923c:	ce 01       	brne	800091fc <_vfprintf_r+0x1c0>
8000923e:	32 08       	mov	r8,32
80009240:	c6 e8       	rjmp	8000931c <_vfprintf_r+0x2e0>
80009242:	a1 a5       	sbr	r5,0x0
80009244:	cd cb       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009246:	0f 89       	ld.ub	r9,r7[0x0]
80009248:	f2 c8 00 30 	sub	r8,r9,48
8000924c:	58 98       	cp.w	r8,9
8000924e:	e0 8b 00 1d 	brhi	80009288 <_vfprintf_r+0x24c>
80009252:	ee c8 ff ff 	sub	r8,r7,-1
80009256:	30 0b       	mov	r11,0
80009258:	23 09       	sub	r9,48
8000925a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000925e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80009262:	11 39       	ld.ub	r9,r8++
80009264:	f2 ca 00 30 	sub	r10,r9,48
80009268:	58 9a       	cp.w	r10,9
8000926a:	fe 98 ff f7 	brls	80009258 <_vfprintf_r+0x21c>
8000926e:	e0 49 00 24 	cp.w	r9,36
80009272:	cc 31       	brne	800091f8 <_vfprintf_r+0x1bc>
80009274:	e0 4b 00 20 	cp.w	r11,32
80009278:	e0 89 0e 60 	brgt	8000af38 <_vfprintf_r+0x1efc>
8000927c:	20 1b       	sub	r11,1
8000927e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80009282:	12 3b       	cp.w	r11,r9
80009284:	c0 95       	brlt	80009296 <_vfprintf_r+0x25a>
80009286:	c1 08       	rjmp	800092a6 <_vfprintf_r+0x26a>
80009288:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000928c:	ec ca ff ff 	sub	r10,r6,-1
80009290:	12 36       	cp.w	r6,r9
80009292:	c1 f5       	brlt	800092d0 <_vfprintf_r+0x294>
80009294:	c2 68       	rjmp	800092e0 <_vfprintf_r+0x2a4>
80009296:	fa ce f9 44 	sub	lr,sp,-1724
8000929a:	10 97       	mov	r7,r8
8000929c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800092a0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800092a4:	c3 58       	rjmp	8000930e <_vfprintf_r+0x2d2>
800092a6:	10 97       	mov	r7,r8
800092a8:	fa c8 f9 50 	sub	r8,sp,-1712
800092ac:	1a d8       	st.w	--sp,r8
800092ae:	fa c8 fa b8 	sub	r8,sp,-1352
800092b2:	1a d8       	st.w	--sp,r8
800092b4:	fa c8 fb b4 	sub	r8,sp,-1100
800092b8:	02 9a       	mov	r10,r1
800092ba:	1a d8       	st.w	--sp,r8
800092bc:	04 9c       	mov	r12,r2
800092be:	fa c8 f9 40 	sub	r8,sp,-1728
800092c2:	fa c9 ff b4 	sub	r9,sp,-76
800092c6:	fe b0 fd 23 	rcall	80008d0c <get_arg>
800092ca:	2f dd       	sub	sp,-12
800092cc:	78 00       	ld.w	r0,r12[0x0]
800092ce:	c2 08       	rjmp	8000930e <_vfprintf_r+0x2d2>
800092d0:	fa cc f9 44 	sub	r12,sp,-1724
800092d4:	14 96       	mov	r6,r10
800092d6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800092da:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800092de:	c1 88       	rjmp	8000930e <_vfprintf_r+0x2d2>
800092e0:	41 08       	lddsp	r8,sp[0x40]
800092e2:	59 f9       	cp.w	r9,31
800092e4:	e0 89 00 11 	brgt	80009306 <_vfprintf_r+0x2ca>
800092e8:	f0 cb ff fc 	sub	r11,r8,-4
800092ec:	51 0b       	stdsp	sp[0x40],r11
800092ee:	70 00       	ld.w	r0,r8[0x0]
800092f0:	fa cb f9 44 	sub	r11,sp,-1724
800092f4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800092f8:	f1 40 fd 88 	st.w	r8[-632],r0
800092fc:	2f f9       	sub	r9,-1
800092fe:	14 96       	mov	r6,r10
80009300:	fb 49 06 b4 	st.w	sp[1716],r9
80009304:	c0 58       	rjmp	8000930e <_vfprintf_r+0x2d2>
80009306:	70 00       	ld.w	r0,r8[0x0]
80009308:	14 96       	mov	r6,r10
8000930a:	2f c8       	sub	r8,-4
8000930c:	51 08       	stdsp	sp[0x40],r8
8000930e:	58 00       	cp.w	r0,0
80009310:	fe 94 ff 76 	brge	800091fc <_vfprintf_r+0x1c0>
80009314:	5c 30       	neg	r0
80009316:	a3 a5       	sbr	r5,0x2
80009318:	c7 2b       	rjmp	800091fc <_vfprintf_r+0x1c0>
8000931a:	32 b8       	mov	r8,43
8000931c:	fb 68 06 bb 	st.b	sp[1723],r8
80009320:	c6 eb       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009322:	0f 38       	ld.ub	r8,r7++
80009324:	e0 48 00 2a 	cp.w	r8,42
80009328:	c0 30       	breq	8000932e <_vfprintf_r+0x2f2>
8000932a:	30 09       	mov	r9,0
8000932c:	c7 98       	rjmp	8000941e <_vfprintf_r+0x3e2>
8000932e:	0f 88       	ld.ub	r8,r7[0x0]
80009330:	f0 c9 00 30 	sub	r9,r8,48
80009334:	58 99       	cp.w	r9,9
80009336:	e0 8b 00 1f 	brhi	80009374 <_vfprintf_r+0x338>
8000933a:	ee c4 ff ff 	sub	r4,r7,-1
8000933e:	30 0b       	mov	r11,0
80009340:	23 08       	sub	r8,48
80009342:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80009346:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000934a:	09 38       	ld.ub	r8,r4++
8000934c:	f0 c9 00 30 	sub	r9,r8,48
80009350:	58 99       	cp.w	r9,9
80009352:	fe 98 ff f7 	brls	80009340 <_vfprintf_r+0x304>
80009356:	e0 48 00 24 	cp.w	r8,36
8000935a:	fe 91 ff 4f 	brne	800091f8 <_vfprintf_r+0x1bc>
8000935e:	e0 4b 00 20 	cp.w	r11,32
80009362:	e0 89 0d eb 	brgt	8000af38 <_vfprintf_r+0x1efc>
80009366:	20 1b       	sub	r11,1
80009368:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000936c:	10 3b       	cp.w	r11,r8
8000936e:	c0 a5       	brlt	80009382 <_vfprintf_r+0x346>
80009370:	c1 18       	rjmp	80009392 <_vfprintf_r+0x356>
80009372:	d7 03       	nop
80009374:	fa fa 06 b4 	ld.w	r10,sp[1716]
80009378:	ec c9 ff ff 	sub	r9,r6,-1
8000937c:	14 36       	cp.w	r6,r10
8000937e:	c1 f5       	brlt	800093bc <_vfprintf_r+0x380>
80009380:	c2 88       	rjmp	800093d0 <_vfprintf_r+0x394>
80009382:	fa ca f9 44 	sub	r10,sp,-1724
80009386:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000938a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000938e:	50 2b       	stdsp	sp[0x8],r11
80009390:	c3 c8       	rjmp	80009408 <_vfprintf_r+0x3cc>
80009392:	fa c8 f9 50 	sub	r8,sp,-1712
80009396:	1a d8       	st.w	--sp,r8
80009398:	fa c8 fa b8 	sub	r8,sp,-1352
8000939c:	1a d8       	st.w	--sp,r8
8000939e:	fa c8 fb b4 	sub	r8,sp,-1100
800093a2:	02 9a       	mov	r10,r1
800093a4:	1a d8       	st.w	--sp,r8
800093a6:	04 9c       	mov	r12,r2
800093a8:	fa c8 f9 40 	sub	r8,sp,-1728
800093ac:	fa c9 ff b4 	sub	r9,sp,-76
800093b0:	fe b0 fc ae 	rcall	80008d0c <get_arg>
800093b4:	2f dd       	sub	sp,-12
800093b6:	78 0c       	ld.w	r12,r12[0x0]
800093b8:	50 2c       	stdsp	sp[0x8],r12
800093ba:	c2 78       	rjmp	80009408 <_vfprintf_r+0x3cc>
800093bc:	12 96       	mov	r6,r9
800093be:	0e 94       	mov	r4,r7
800093c0:	fa c9 f9 44 	sub	r9,sp,-1724
800093c4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800093c8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800093cc:	50 28       	stdsp	sp[0x8],r8
800093ce:	c1 d8       	rjmp	80009408 <_vfprintf_r+0x3cc>
800093d0:	41 08       	lddsp	r8,sp[0x40]
800093d2:	59 fa       	cp.w	r10,31
800093d4:	e0 89 00 14 	brgt	800093fc <_vfprintf_r+0x3c0>
800093d8:	f0 cb ff fc 	sub	r11,r8,-4
800093dc:	70 08       	ld.w	r8,r8[0x0]
800093de:	51 0b       	stdsp	sp[0x40],r11
800093e0:	50 28       	stdsp	sp[0x8],r8
800093e2:	fa c6 f9 44 	sub	r6,sp,-1724
800093e6:	40 2e       	lddsp	lr,sp[0x8]
800093e8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800093ec:	f1 4e fd 88 	st.w	r8[-632],lr
800093f0:	2f fa       	sub	r10,-1
800093f2:	0e 94       	mov	r4,r7
800093f4:	fb 4a 06 b4 	st.w	sp[1716],r10
800093f8:	12 96       	mov	r6,r9
800093fa:	c0 78       	rjmp	80009408 <_vfprintf_r+0x3cc>
800093fc:	70 0c       	ld.w	r12,r8[0x0]
800093fe:	0e 94       	mov	r4,r7
80009400:	2f c8       	sub	r8,-4
80009402:	50 2c       	stdsp	sp[0x8],r12
80009404:	12 96       	mov	r6,r9
80009406:	51 08       	stdsp	sp[0x40],r8
80009408:	40 2b       	lddsp	r11,sp[0x8]
8000940a:	58 0b       	cp.w	r11,0
8000940c:	fe 95 fe f2 	brlt	800091f0 <_vfprintf_r+0x1b4>
80009410:	08 97       	mov	r7,r4
80009412:	cf 5a       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009414:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009418:	0f 38       	ld.ub	r8,r7++
8000941a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000941e:	f0 ca 00 30 	sub	r10,r8,48
80009422:	58 9a       	cp.w	r10,9
80009424:	fe 98 ff f8 	brls	80009414 <_vfprintf_r+0x3d8>
80009428:	3f fa       	mov	r10,-1
8000942a:	f2 0a 0c 49 	max	r9,r9,r10
8000942e:	50 29       	stdsp	sp[0x8],r9
80009430:	ce 9a       	rjmp	80009202 <_vfprintf_r+0x1c6>
80009432:	a7 b5       	sbr	r5,0x7
80009434:	ce 4a       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009436:	30 09       	mov	r9,0
80009438:	23 08       	sub	r8,48
8000943a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000943e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80009442:	0f 38       	ld.ub	r8,r7++
80009444:	f0 ca 00 30 	sub	r10,r8,48
80009448:	58 9a       	cp.w	r10,9
8000944a:	fe 98 ff f7 	brls	80009438 <_vfprintf_r+0x3fc>
8000944e:	e0 48 00 24 	cp.w	r8,36
80009452:	fe 91 fe d7 	brne	80009200 <_vfprintf_r+0x1c4>
80009456:	e0 49 00 20 	cp.w	r9,32
8000945a:	e0 89 0d 6f 	brgt	8000af38 <_vfprintf_r+0x1efc>
8000945e:	f2 c3 00 01 	sub	r3,r9,1
80009462:	30 19       	mov	r9,1
80009464:	50 39       	stdsp	sp[0xc],r9
80009466:	cc ba       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009468:	a3 b5       	sbr	r5,0x3
8000946a:	cc 9a       	rjmp	800091fc <_vfprintf_r+0x1c0>
8000946c:	a7 a5       	sbr	r5,0x6
8000946e:	cc 7a       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009470:	0a 98       	mov	r8,r5
80009472:	a5 b5       	sbr	r5,0x5
80009474:	a5 a8       	sbr	r8,0x4
80009476:	0f 89       	ld.ub	r9,r7[0x0]
80009478:	36 ce       	mov	lr,108
8000947a:	fc 09 18 00 	cp.b	r9,lr
8000947e:	f7 b7 00 ff 	subeq	r7,-1
80009482:	f0 05 17 10 	movne	r5,r8
80009486:	cb ba       	rjmp	800091fc <_vfprintf_r+0x1c0>
80009488:	a5 b5       	sbr	r5,0x5
8000948a:	cb 9a       	rjmp	800091fc <_vfprintf_r+0x1c0>
8000948c:	50 a7       	stdsp	sp[0x28],r7
8000948e:	50 80       	stdsp	sp[0x20],r0
80009490:	0c 97       	mov	r7,r6
80009492:	10 90       	mov	r0,r8
80009494:	06 96       	mov	r6,r3
80009496:	04 94       	mov	r4,r2
80009498:	40 93       	lddsp	r3,sp[0x24]
8000949a:	02 92       	mov	r2,r1
8000949c:	0e 99       	mov	r9,r7
8000949e:	40 41       	lddsp	r1,sp[0x10]
800094a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094a4:	40 3c       	lddsp	r12,sp[0xc]
800094a6:	58 0c       	cp.w	r12,0
800094a8:	c1 d0       	breq	800094e2 <_vfprintf_r+0x4a6>
800094aa:	10 36       	cp.w	r6,r8
800094ac:	c0 64       	brge	800094b8 <_vfprintf_r+0x47c>
800094ae:	fa cb f9 44 	sub	r11,sp,-1724
800094b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094b6:	c1 d8       	rjmp	800094f0 <_vfprintf_r+0x4b4>
800094b8:	fa c8 f9 50 	sub	r8,sp,-1712
800094bc:	1a d8       	st.w	--sp,r8
800094be:	fa c8 fa b8 	sub	r8,sp,-1352
800094c2:	1a d8       	st.w	--sp,r8
800094c4:	fa c8 fb b4 	sub	r8,sp,-1100
800094c8:	1a d8       	st.w	--sp,r8
800094ca:	fa c8 f9 40 	sub	r8,sp,-1728
800094ce:	fa c9 ff b4 	sub	r9,sp,-76
800094d2:	04 9a       	mov	r10,r2
800094d4:	0c 9b       	mov	r11,r6
800094d6:	08 9c       	mov	r12,r4
800094d8:	fe b0 fc 1a 	rcall	80008d0c <get_arg>
800094dc:	2f dd       	sub	sp,-12
800094de:	19 b8       	ld.ub	r8,r12[0x3]
800094e0:	c2 28       	rjmp	80009524 <_vfprintf_r+0x4e8>
800094e2:	2f f7       	sub	r7,-1
800094e4:	10 39       	cp.w	r9,r8
800094e6:	c0 84       	brge	800094f6 <_vfprintf_r+0x4ba>
800094e8:	fa ca f9 44 	sub	r10,sp,-1724
800094ec:	f4 06 00 36 	add	r6,r10,r6<<0x3
800094f0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800094f4:	c1 88       	rjmp	80009524 <_vfprintf_r+0x4e8>
800094f6:	41 09       	lddsp	r9,sp[0x40]
800094f8:	59 f8       	cp.w	r8,31
800094fa:	e0 89 00 12 	brgt	8000951e <_vfprintf_r+0x4e2>
800094fe:	f2 ca ff fc 	sub	r10,r9,-4
80009502:	51 0a       	stdsp	sp[0x40],r10
80009504:	72 09       	ld.w	r9,r9[0x0]
80009506:	fa c6 f9 44 	sub	r6,sp,-1724
8000950a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000950e:	2f f8       	sub	r8,-1
80009510:	f5 49 fd 88 	st.w	r10[-632],r9
80009514:	fb 48 06 b4 	st.w	sp[1716],r8
80009518:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000951c:	c0 48       	rjmp	80009524 <_vfprintf_r+0x4e8>
8000951e:	13 b8       	ld.ub	r8,r9[0x3]
80009520:	2f c9       	sub	r9,-4
80009522:	51 09       	stdsp	sp[0x40],r9
80009524:	fb 68 06 60 	st.b	sp[1632],r8
80009528:	30 0e       	mov	lr,0
8000952a:	30 08       	mov	r8,0
8000952c:	30 12       	mov	r2,1
8000952e:	fb 68 06 bb 	st.b	sp[1723],r8
80009532:	50 2e       	stdsp	sp[0x8],lr
80009534:	e0 8f 08 ad 	bral	8000a68e <_vfprintf_r+0x1652>
80009538:	50 a7       	stdsp	sp[0x28],r7
8000953a:	50 80       	stdsp	sp[0x20],r0
8000953c:	0c 97       	mov	r7,r6
8000953e:	04 94       	mov	r4,r2
80009540:	06 96       	mov	r6,r3
80009542:	02 92       	mov	r2,r1
80009544:	40 93       	lddsp	r3,sp[0x24]
80009546:	10 90       	mov	r0,r8
80009548:	40 41       	lddsp	r1,sp[0x10]
8000954a:	a5 a5       	sbr	r5,0x4
8000954c:	c0 a8       	rjmp	80009560 <_vfprintf_r+0x524>
8000954e:	50 a7       	stdsp	sp[0x28],r7
80009550:	50 80       	stdsp	sp[0x20],r0
80009552:	0c 97       	mov	r7,r6
80009554:	04 94       	mov	r4,r2
80009556:	06 96       	mov	r6,r3
80009558:	02 92       	mov	r2,r1
8000955a:	40 93       	lddsp	r3,sp[0x24]
8000955c:	10 90       	mov	r0,r8
8000955e:	40 41       	lddsp	r1,sp[0x10]
80009560:	ed b5 00 05 	bld	r5,0x5
80009564:	c5 11       	brne	80009606 <_vfprintf_r+0x5ca>
80009566:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000956a:	40 3c       	lddsp	r12,sp[0xc]
8000956c:	58 0c       	cp.w	r12,0
8000956e:	c1 e0       	breq	800095aa <_vfprintf_r+0x56e>
80009570:	10 36       	cp.w	r6,r8
80009572:	c0 64       	brge	8000957e <_vfprintf_r+0x542>
80009574:	fa cb f9 44 	sub	r11,sp,-1724
80009578:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000957c:	c2 08       	rjmp	800095bc <_vfprintf_r+0x580>
8000957e:	fa c8 f9 50 	sub	r8,sp,-1712
80009582:	1a d8       	st.w	--sp,r8
80009584:	fa c8 fa b8 	sub	r8,sp,-1352
80009588:	0c 9b       	mov	r11,r6
8000958a:	1a d8       	st.w	--sp,r8
8000958c:	fa c8 fb b4 	sub	r8,sp,-1100
80009590:	1a d8       	st.w	--sp,r8
80009592:	fa c9 ff b4 	sub	r9,sp,-76
80009596:	fa c8 f9 40 	sub	r8,sp,-1728
8000959a:	04 9a       	mov	r10,r2
8000959c:	08 9c       	mov	r12,r4
8000959e:	fe b0 fb b7 	rcall	80008d0c <get_arg>
800095a2:	2f dd       	sub	sp,-12
800095a4:	78 1b       	ld.w	r11,r12[0x4]
800095a6:	78 09       	ld.w	r9,r12[0x0]
800095a8:	c2 b8       	rjmp	800095fe <_vfprintf_r+0x5c2>
800095aa:	ee ca ff ff 	sub	r10,r7,-1
800095ae:	10 37       	cp.w	r7,r8
800095b0:	c0 b4       	brge	800095c6 <_vfprintf_r+0x58a>
800095b2:	fa c9 f9 44 	sub	r9,sp,-1724
800095b6:	14 97       	mov	r7,r10
800095b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095bc:	ec fb fd 8c 	ld.w	r11,r6[-628]
800095c0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800095c4:	c1 d8       	rjmp	800095fe <_vfprintf_r+0x5c2>
800095c6:	41 09       	lddsp	r9,sp[0x40]
800095c8:	59 f8       	cp.w	r8,31
800095ca:	e0 89 00 14 	brgt	800095f2 <_vfprintf_r+0x5b6>
800095ce:	f2 cb ff f8 	sub	r11,r9,-8
800095d2:	51 0b       	stdsp	sp[0x40],r11
800095d4:	fa c6 f9 44 	sub	r6,sp,-1724
800095d8:	72 1b       	ld.w	r11,r9[0x4]
800095da:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800095de:	72 09       	ld.w	r9,r9[0x0]
800095e0:	f9 4b fd 8c 	st.w	r12[-628],r11
800095e4:	f9 49 fd 88 	st.w	r12[-632],r9
800095e8:	2f f8       	sub	r8,-1
800095ea:	14 97       	mov	r7,r10
800095ec:	fb 48 06 b4 	st.w	sp[1716],r8
800095f0:	c0 78       	rjmp	800095fe <_vfprintf_r+0x5c2>
800095f2:	f2 c8 ff f8 	sub	r8,r9,-8
800095f6:	72 1b       	ld.w	r11,r9[0x4]
800095f8:	14 97       	mov	r7,r10
800095fa:	51 08       	stdsp	sp[0x40],r8
800095fc:	72 09       	ld.w	r9,r9[0x0]
800095fe:	16 98       	mov	r8,r11
80009600:	fa e9 00 00 	st.d	sp[0],r8
80009604:	ca e8       	rjmp	80009760 <_vfprintf_r+0x724>
80009606:	ed b5 00 04 	bld	r5,0x4
8000960a:	c1 71       	brne	80009638 <_vfprintf_r+0x5fc>
8000960c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009610:	40 3e       	lddsp	lr,sp[0xc]
80009612:	58 0e       	cp.w	lr,0
80009614:	c0 80       	breq	80009624 <_vfprintf_r+0x5e8>
80009616:	10 36       	cp.w	r6,r8
80009618:	c6 94       	brge	800096ea <_vfprintf_r+0x6ae>
8000961a:	fa cc f9 44 	sub	r12,sp,-1724
8000961e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009622:	c8 28       	rjmp	80009726 <_vfprintf_r+0x6ea>
80009624:	ee ca ff ff 	sub	r10,r7,-1
80009628:	10 37       	cp.w	r7,r8
8000962a:	e0 84 00 81 	brge	8000972c <_vfprintf_r+0x6f0>
8000962e:	fa cb f9 44 	sub	r11,sp,-1724
80009632:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009636:	c7 78       	rjmp	80009724 <_vfprintf_r+0x6e8>
80009638:	ed b5 00 06 	bld	r5,0x6
8000963c:	c4 b1       	brne	800096d2 <_vfprintf_r+0x696>
8000963e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009642:	40 3c       	lddsp	r12,sp[0xc]
80009644:	58 0c       	cp.w	r12,0
80009646:	c1 d0       	breq	80009680 <_vfprintf_r+0x644>
80009648:	10 36       	cp.w	r6,r8
8000964a:	c0 64       	brge	80009656 <_vfprintf_r+0x61a>
8000964c:	fa cb f9 44 	sub	r11,sp,-1724
80009650:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009654:	c1 f8       	rjmp	80009692 <_vfprintf_r+0x656>
80009656:	fa c8 f9 50 	sub	r8,sp,-1712
8000965a:	1a d8       	st.w	--sp,r8
8000965c:	fa c8 fa b8 	sub	r8,sp,-1352
80009660:	1a d8       	st.w	--sp,r8
80009662:	fa c8 fb b4 	sub	r8,sp,-1100
80009666:	1a d8       	st.w	--sp,r8
80009668:	fa c8 f9 40 	sub	r8,sp,-1728
8000966c:	fa c9 ff b4 	sub	r9,sp,-76
80009670:	04 9a       	mov	r10,r2
80009672:	0c 9b       	mov	r11,r6
80009674:	08 9c       	mov	r12,r4
80009676:	fe b0 fb 4b 	rcall	80008d0c <get_arg>
8000967a:	2f dd       	sub	sp,-12
8000967c:	98 18       	ld.sh	r8,r12[0x2]
8000967e:	c2 68       	rjmp	800096ca <_vfprintf_r+0x68e>
80009680:	ee ca ff ff 	sub	r10,r7,-1
80009684:	10 37       	cp.w	r7,r8
80009686:	c0 94       	brge	80009698 <_vfprintf_r+0x65c>
80009688:	fa c9 f9 44 	sub	r9,sp,-1724
8000968c:	14 97       	mov	r7,r10
8000968e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009692:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009696:	c1 a8       	rjmp	800096ca <_vfprintf_r+0x68e>
80009698:	41 09       	lddsp	r9,sp[0x40]
8000969a:	59 f8       	cp.w	r8,31
8000969c:	e0 89 00 13 	brgt	800096c2 <_vfprintf_r+0x686>
800096a0:	f2 cb ff fc 	sub	r11,r9,-4
800096a4:	51 0b       	stdsp	sp[0x40],r11
800096a6:	72 09       	ld.w	r9,r9[0x0]
800096a8:	fa c6 f9 44 	sub	r6,sp,-1724
800096ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800096b0:	2f f8       	sub	r8,-1
800096b2:	f7 49 fd 88 	st.w	r11[-632],r9
800096b6:	fb 48 06 b4 	st.w	sp[1716],r8
800096ba:	14 97       	mov	r7,r10
800096bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800096c0:	c0 58       	rjmp	800096ca <_vfprintf_r+0x68e>
800096c2:	92 18       	ld.sh	r8,r9[0x2]
800096c4:	14 97       	mov	r7,r10
800096c6:	2f c9       	sub	r9,-4
800096c8:	51 09       	stdsp	sp[0x40],r9
800096ca:	50 18       	stdsp	sp[0x4],r8
800096cc:	bf 58       	asr	r8,0x1f
800096ce:	50 08       	stdsp	sp[0x0],r8
800096d0:	c4 88       	rjmp	80009760 <_vfprintf_r+0x724>
800096d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096d6:	40 3c       	lddsp	r12,sp[0xc]
800096d8:	58 0c       	cp.w	r12,0
800096da:	c1 d0       	breq	80009714 <_vfprintf_r+0x6d8>
800096dc:	10 36       	cp.w	r6,r8
800096de:	c0 64       	brge	800096ea <_vfprintf_r+0x6ae>
800096e0:	fa cb f9 44 	sub	r11,sp,-1724
800096e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096e8:	c1 f8       	rjmp	80009726 <_vfprintf_r+0x6ea>
800096ea:	fa c8 f9 50 	sub	r8,sp,-1712
800096ee:	1a d8       	st.w	--sp,r8
800096f0:	fa c8 fa b8 	sub	r8,sp,-1352
800096f4:	0c 9b       	mov	r11,r6
800096f6:	1a d8       	st.w	--sp,r8
800096f8:	fa c8 fb b4 	sub	r8,sp,-1100
800096fc:	04 9a       	mov	r10,r2
800096fe:	1a d8       	st.w	--sp,r8
80009700:	08 9c       	mov	r12,r4
80009702:	fa c8 f9 40 	sub	r8,sp,-1728
80009706:	fa c9 ff b4 	sub	r9,sp,-76
8000970a:	fe b0 fb 01 	rcall	80008d0c <get_arg>
8000970e:	2f dd       	sub	sp,-12
80009710:	78 0b       	ld.w	r11,r12[0x0]
80009712:	c2 48       	rjmp	8000975a <_vfprintf_r+0x71e>
80009714:	ee ca ff ff 	sub	r10,r7,-1
80009718:	10 37       	cp.w	r7,r8
8000971a:	c0 94       	brge	8000972c <_vfprintf_r+0x6f0>
8000971c:	fa c9 f9 44 	sub	r9,sp,-1724
80009720:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009724:	14 97       	mov	r7,r10
80009726:	ec fb fd 88 	ld.w	r11,r6[-632]
8000972a:	c1 88       	rjmp	8000975a <_vfprintf_r+0x71e>
8000972c:	41 09       	lddsp	r9,sp[0x40]
8000972e:	59 f8       	cp.w	r8,31
80009730:	e0 89 00 11 	brgt	80009752 <_vfprintf_r+0x716>
80009734:	f2 cb ff fc 	sub	r11,r9,-4
80009738:	51 0b       	stdsp	sp[0x40],r11
8000973a:	fa c6 f9 44 	sub	r6,sp,-1724
8000973e:	72 0b       	ld.w	r11,r9[0x0]
80009740:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009744:	f3 4b fd 88 	st.w	r9[-632],r11
80009748:	2f f8       	sub	r8,-1
8000974a:	14 97       	mov	r7,r10
8000974c:	fb 48 06 b4 	st.w	sp[1716],r8
80009750:	c0 58       	rjmp	8000975a <_vfprintf_r+0x71e>
80009752:	72 0b       	ld.w	r11,r9[0x0]
80009754:	14 97       	mov	r7,r10
80009756:	2f c9       	sub	r9,-4
80009758:	51 09       	stdsp	sp[0x40],r9
8000975a:	50 1b       	stdsp	sp[0x4],r11
8000975c:	bf 5b       	asr	r11,0x1f
8000975e:	50 0b       	stdsp	sp[0x0],r11
80009760:	fa ea 00 00 	ld.d	r10,sp[0]
80009764:	58 0a       	cp.w	r10,0
80009766:	5c 2b       	cpc	r11
80009768:	c0 e4       	brge	80009784 <_vfprintf_r+0x748>
8000976a:	30 08       	mov	r8,0
8000976c:	fa ea 00 00 	ld.d	r10,sp[0]
80009770:	30 09       	mov	r9,0
80009772:	f0 0a 01 0a 	sub	r10,r8,r10
80009776:	f2 0b 01 4b 	sbc	r11,r9,r11
8000977a:	32 d8       	mov	r8,45
8000977c:	fa eb 00 00 	st.d	sp[0],r10
80009780:	fb 68 06 bb 	st.b	sp[1723],r8
80009784:	30 18       	mov	r8,1
80009786:	e0 8f 06 fa 	bral	8000a57a <_vfprintf_r+0x153e>
8000978a:	50 a7       	stdsp	sp[0x28],r7
8000978c:	50 80       	stdsp	sp[0x20],r0
8000978e:	0c 97       	mov	r7,r6
80009790:	04 94       	mov	r4,r2
80009792:	06 96       	mov	r6,r3
80009794:	02 92       	mov	r2,r1
80009796:	40 93       	lddsp	r3,sp[0x24]
80009798:	10 90       	mov	r0,r8
8000979a:	40 41       	lddsp	r1,sp[0x10]
8000979c:	0e 99       	mov	r9,r7
8000979e:	ed b5 00 03 	bld	r5,0x3
800097a2:	c4 11       	brne	80009824 <_vfprintf_r+0x7e8>
800097a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097a8:	40 3a       	lddsp	r10,sp[0xc]
800097aa:	58 0a       	cp.w	r10,0
800097ac:	c1 90       	breq	800097de <_vfprintf_r+0x7a2>
800097ae:	10 36       	cp.w	r6,r8
800097b0:	c6 45       	brlt	80009878 <_vfprintf_r+0x83c>
800097b2:	fa c8 f9 50 	sub	r8,sp,-1712
800097b6:	1a d8       	st.w	--sp,r8
800097b8:	fa c8 fa b8 	sub	r8,sp,-1352
800097bc:	1a d8       	st.w	--sp,r8
800097be:	fa c8 fb b4 	sub	r8,sp,-1100
800097c2:	0c 9b       	mov	r11,r6
800097c4:	1a d8       	st.w	--sp,r8
800097c6:	04 9a       	mov	r10,r2
800097c8:	fa c8 f9 40 	sub	r8,sp,-1728
800097cc:	fa c9 ff b4 	sub	r9,sp,-76
800097d0:	08 9c       	mov	r12,r4
800097d2:	fe b0 fa 9d 	rcall	80008d0c <get_arg>
800097d6:	2f dd       	sub	sp,-12
800097d8:	78 16       	ld.w	r6,r12[0x4]
800097da:	50 76       	stdsp	sp[0x1c],r6
800097dc:	c4 88       	rjmp	8000986c <_vfprintf_r+0x830>
800097de:	2f f7       	sub	r7,-1
800097e0:	10 39       	cp.w	r9,r8
800097e2:	c0 c4       	brge	800097fa <_vfprintf_r+0x7be>
800097e4:	fa ce f9 44 	sub	lr,sp,-1724
800097e8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800097ec:	ec fc fd 8c 	ld.w	r12,r6[-628]
800097f0:	50 7c       	stdsp	sp[0x1c],r12
800097f2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800097f6:	50 56       	stdsp	sp[0x14],r6
800097f8:	c6 68       	rjmp	800098c4 <_vfprintf_r+0x888>
800097fa:	41 09       	lddsp	r9,sp[0x40]
800097fc:	59 f8       	cp.w	r8,31
800097fe:	e0 89 00 10 	brgt	8000981e <_vfprintf_r+0x7e2>
80009802:	f2 ca ff f8 	sub	r10,r9,-8
80009806:	72 1b       	ld.w	r11,r9[0x4]
80009808:	51 0a       	stdsp	sp[0x40],r10
8000980a:	72 09       	ld.w	r9,r9[0x0]
8000980c:	fa ca f9 44 	sub	r10,sp,-1724
80009810:	50 7b       	stdsp	sp[0x1c],r11
80009812:	50 59       	stdsp	sp[0x14],r9
80009814:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009818:	40 5b       	lddsp	r11,sp[0x14]
8000981a:	40 7a       	lddsp	r10,sp[0x1c]
8000981c:	c4 78       	rjmp	800098aa <_vfprintf_r+0x86e>
8000981e:	72 18       	ld.w	r8,r9[0x4]
80009820:	50 78       	stdsp	sp[0x1c],r8
80009822:	c4 c8       	rjmp	800098ba <_vfprintf_r+0x87e>
80009824:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009828:	40 3e       	lddsp	lr,sp[0xc]
8000982a:	58 0e       	cp.w	lr,0
8000982c:	c2 30       	breq	80009872 <_vfprintf_r+0x836>
8000982e:	10 36       	cp.w	r6,r8
80009830:	c0 94       	brge	80009842 <_vfprintf_r+0x806>
80009832:	fa cc f9 44 	sub	r12,sp,-1724
80009836:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000983a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000983e:	50 7b       	stdsp	sp[0x1c],r11
80009840:	cd 9b       	rjmp	800097f2 <_vfprintf_r+0x7b6>
80009842:	fa c8 f9 50 	sub	r8,sp,-1712
80009846:	1a d8       	st.w	--sp,r8
80009848:	fa c8 fa b8 	sub	r8,sp,-1352
8000984c:	04 9a       	mov	r10,r2
8000984e:	1a d8       	st.w	--sp,r8
80009850:	fa c8 fb b4 	sub	r8,sp,-1100
80009854:	0c 9b       	mov	r11,r6
80009856:	1a d8       	st.w	--sp,r8
80009858:	08 9c       	mov	r12,r4
8000985a:	fa c8 f9 40 	sub	r8,sp,-1728
8000985e:	fa c9 ff b4 	sub	r9,sp,-76
80009862:	fe b0 fa 55 	rcall	80008d0c <get_arg>
80009866:	2f dd       	sub	sp,-12
80009868:	78 1a       	ld.w	r10,r12[0x4]
8000986a:	50 7a       	stdsp	sp[0x1c],r10
8000986c:	78 0c       	ld.w	r12,r12[0x0]
8000986e:	50 5c       	stdsp	sp[0x14],r12
80009870:	c2 a8       	rjmp	800098c4 <_vfprintf_r+0x888>
80009872:	2f f7       	sub	r7,-1
80009874:	10 39       	cp.w	r9,r8
80009876:	c0 94       	brge	80009888 <_vfprintf_r+0x84c>
80009878:	fa c9 f9 44 	sub	r9,sp,-1724
8000987c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009880:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009884:	50 78       	stdsp	sp[0x1c],r8
80009886:	cb 6b       	rjmp	800097f2 <_vfprintf_r+0x7b6>
80009888:	41 09       	lddsp	r9,sp[0x40]
8000988a:	59 f8       	cp.w	r8,31
8000988c:	e0 89 00 15 	brgt	800098b6 <_vfprintf_r+0x87a>
80009890:	f2 ca ff f8 	sub	r10,r9,-8
80009894:	72 16       	ld.w	r6,r9[0x4]
80009896:	72 09       	ld.w	r9,r9[0x0]
80009898:	51 0a       	stdsp	sp[0x40],r10
8000989a:	50 59       	stdsp	sp[0x14],r9
8000989c:	fa ce f9 44 	sub	lr,sp,-1724
800098a0:	50 76       	stdsp	sp[0x1c],r6
800098a2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800098a6:	40 5b       	lddsp	r11,sp[0x14]
800098a8:	0c 9a       	mov	r10,r6
800098aa:	f2 eb fd 88 	st.d	r9[-632],r10
800098ae:	2f f8       	sub	r8,-1
800098b0:	fb 48 06 b4 	st.w	sp[1716],r8
800098b4:	c0 88       	rjmp	800098c4 <_vfprintf_r+0x888>
800098b6:	72 1c       	ld.w	r12,r9[0x4]
800098b8:	50 7c       	stdsp	sp[0x1c],r12
800098ba:	f2 c8 ff f8 	sub	r8,r9,-8
800098be:	51 08       	stdsp	sp[0x40],r8
800098c0:	72 09       	ld.w	r9,r9[0x0]
800098c2:	50 59       	stdsp	sp[0x14],r9
800098c4:	40 5b       	lddsp	r11,sp[0x14]
800098c6:	40 7a       	lddsp	r10,sp[0x1c]
800098c8:	e0 a0 19 54 	rcall	8000cb70 <__isinfd>
800098cc:	18 96       	mov	r6,r12
800098ce:	c1 70       	breq	800098fc <_vfprintf_r+0x8c0>
800098d0:	30 08       	mov	r8,0
800098d2:	30 09       	mov	r9,0
800098d4:	40 5b       	lddsp	r11,sp[0x14]
800098d6:	40 7a       	lddsp	r10,sp[0x1c]
800098d8:	e0 a0 1d b4 	rcall	8000d440 <__avr32_f64_cmp_lt>
800098dc:	c0 40       	breq	800098e4 <_vfprintf_r+0x8a8>
800098de:	32 d8       	mov	r8,45
800098e0:	fb 68 06 bb 	st.b	sp[1723],r8
800098e4:	fe c8 a5 cc 	sub	r8,pc,-23092
800098e8:	fe c6 a5 cc 	sub	r6,pc,-23092
800098ec:	a7 d5       	cbr	r5,0x7
800098ee:	e0 40 00 47 	cp.w	r0,71
800098f2:	f0 06 17 a0 	movle	r6,r8
800098f6:	30 32       	mov	r2,3
800098f8:	e0 8f 06 ce 	bral	8000a694 <_vfprintf_r+0x1658>
800098fc:	40 5b       	lddsp	r11,sp[0x14]
800098fe:	40 7a       	lddsp	r10,sp[0x1c]
80009900:	e0 a0 19 4d 	rcall	8000cb9a <__isnand>
80009904:	c0 e0       	breq	80009920 <_vfprintf_r+0x8e4>
80009906:	50 26       	stdsp	sp[0x8],r6
80009908:	fe c8 a5 e8 	sub	r8,pc,-23064
8000990c:	fe c6 a5 e8 	sub	r6,pc,-23064
80009910:	a7 d5       	cbr	r5,0x7
80009912:	e0 40 00 47 	cp.w	r0,71
80009916:	f0 06 17 a0 	movle	r6,r8
8000991a:	30 32       	mov	r2,3
8000991c:	e0 8f 06 c2 	bral	8000a6a0 <_vfprintf_r+0x1664>
80009920:	40 2a       	lddsp	r10,sp[0x8]
80009922:	5b fa       	cp.w	r10,-1
80009924:	c0 41       	brne	8000992c <_vfprintf_r+0x8f0>
80009926:	30 69       	mov	r9,6
80009928:	50 29       	stdsp	sp[0x8],r9
8000992a:	c1 18       	rjmp	8000994c <_vfprintf_r+0x910>
8000992c:	e0 40 00 47 	cp.w	r0,71
80009930:	5f 09       	sreq	r9
80009932:	e0 40 00 67 	cp.w	r0,103
80009936:	5f 08       	sreq	r8
80009938:	f3 e8 10 08 	or	r8,r9,r8
8000993c:	f8 08 18 00 	cp.b	r8,r12
80009940:	c0 60       	breq	8000994c <_vfprintf_r+0x910>
80009942:	40 28       	lddsp	r8,sp[0x8]
80009944:	58 08       	cp.w	r8,0
80009946:	f9 b8 00 01 	moveq	r8,1
8000994a:	50 28       	stdsp	sp[0x8],r8
8000994c:	40 78       	lddsp	r8,sp[0x1c]
8000994e:	40 59       	lddsp	r9,sp[0x14]
80009950:	fa e9 06 94 	st.d	sp[1684],r8
80009954:	a9 a5       	sbr	r5,0x8
80009956:	fa f8 06 94 	ld.w	r8,sp[1684]
8000995a:	58 08       	cp.w	r8,0
8000995c:	c0 65       	brlt	80009968 <_vfprintf_r+0x92c>
8000995e:	40 5e       	lddsp	lr,sp[0x14]
80009960:	30 0c       	mov	r12,0
80009962:	50 6e       	stdsp	sp[0x18],lr
80009964:	50 9c       	stdsp	sp[0x24],r12
80009966:	c0 78       	rjmp	80009974 <_vfprintf_r+0x938>
80009968:	40 5b       	lddsp	r11,sp[0x14]
8000996a:	32 da       	mov	r10,45
8000996c:	ee 1b 80 00 	eorh	r11,0x8000
80009970:	50 9a       	stdsp	sp[0x24],r10
80009972:	50 6b       	stdsp	sp[0x18],r11
80009974:	e0 40 00 46 	cp.w	r0,70
80009978:	5f 09       	sreq	r9
8000997a:	e0 40 00 66 	cp.w	r0,102
8000997e:	5f 08       	sreq	r8
80009980:	f3 e8 10 08 	or	r8,r9,r8
80009984:	50 48       	stdsp	sp[0x10],r8
80009986:	c0 40       	breq	8000998e <_vfprintf_r+0x952>
80009988:	40 22       	lddsp	r2,sp[0x8]
8000998a:	30 39       	mov	r9,3
8000998c:	c1 08       	rjmp	800099ac <_vfprintf_r+0x970>
8000998e:	e0 40 00 45 	cp.w	r0,69
80009992:	5f 09       	sreq	r9
80009994:	e0 40 00 65 	cp.w	r0,101
80009998:	5f 08       	sreq	r8
8000999a:	40 22       	lddsp	r2,sp[0x8]
8000999c:	10 49       	or	r9,r8
8000999e:	2f f2       	sub	r2,-1
800099a0:	40 46       	lddsp	r6,sp[0x10]
800099a2:	ec 09 18 00 	cp.b	r9,r6
800099a6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800099aa:	30 29       	mov	r9,2
800099ac:	fa c8 f9 5c 	sub	r8,sp,-1700
800099b0:	1a d8       	st.w	--sp,r8
800099b2:	fa c8 f9 54 	sub	r8,sp,-1708
800099b6:	1a d8       	st.w	--sp,r8
800099b8:	fa c8 f9 4c 	sub	r8,sp,-1716
800099bc:	08 9c       	mov	r12,r4
800099be:	1a d8       	st.w	--sp,r8
800099c0:	04 98       	mov	r8,r2
800099c2:	40 9b       	lddsp	r11,sp[0x24]
800099c4:	40 aa       	lddsp	r10,sp[0x28]
800099c6:	e0 a0 0b c3 	rcall	8000b14c <_dtoa_r>
800099ca:	e0 40 00 47 	cp.w	r0,71
800099ce:	5f 19       	srne	r9
800099d0:	e0 40 00 67 	cp.w	r0,103
800099d4:	5f 18       	srne	r8
800099d6:	18 96       	mov	r6,r12
800099d8:	2f dd       	sub	sp,-12
800099da:	f3 e8 00 08 	and	r8,r9,r8
800099de:	c0 41       	brne	800099e6 <_vfprintf_r+0x9aa>
800099e0:	ed b5 00 00 	bld	r5,0x0
800099e4:	c3 01       	brne	80009a44 <_vfprintf_r+0xa08>
800099e6:	ec 02 00 0e 	add	lr,r6,r2
800099ea:	50 3e       	stdsp	sp[0xc],lr
800099ec:	40 4c       	lddsp	r12,sp[0x10]
800099ee:	58 0c       	cp.w	r12,0
800099f0:	c1 50       	breq	80009a1a <_vfprintf_r+0x9de>
800099f2:	0d 89       	ld.ub	r9,r6[0x0]
800099f4:	33 08       	mov	r8,48
800099f6:	f0 09 18 00 	cp.b	r9,r8
800099fa:	c0 b1       	brne	80009a10 <_vfprintf_r+0x9d4>
800099fc:	30 08       	mov	r8,0
800099fe:	30 09       	mov	r9,0
80009a00:	40 6b       	lddsp	r11,sp[0x18]
80009a02:	40 7a       	lddsp	r10,sp[0x1c]
80009a04:	e0 a0 1c d7 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
80009a08:	fb b2 00 01 	rsubeq	r2,1
80009a0c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009a10:	40 3b       	lddsp	r11,sp[0xc]
80009a12:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a16:	10 0b       	add	r11,r8
80009a18:	50 3b       	stdsp	sp[0xc],r11
80009a1a:	40 6b       	lddsp	r11,sp[0x18]
80009a1c:	30 08       	mov	r8,0
80009a1e:	30 09       	mov	r9,0
80009a20:	40 7a       	lddsp	r10,sp[0x1c]
80009a22:	e0 a0 1c c8 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
80009a26:	c0 90       	breq	80009a38 <_vfprintf_r+0x9fc>
80009a28:	40 3a       	lddsp	r10,sp[0xc]
80009a2a:	fb 4a 06 a4 	st.w	sp[1700],r10
80009a2e:	c0 58       	rjmp	80009a38 <_vfprintf_r+0x9fc>
80009a30:	10 c9       	st.b	r8++,r9
80009a32:	fb 48 06 a4 	st.w	sp[1700],r8
80009a36:	c0 28       	rjmp	80009a3a <_vfprintf_r+0x9fe>
80009a38:	33 09       	mov	r9,48
80009a3a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009a3e:	40 3e       	lddsp	lr,sp[0xc]
80009a40:	1c 38       	cp.w	r8,lr
80009a42:	cf 73       	brcs	80009a30 <_vfprintf_r+0x9f4>
80009a44:	e0 40 00 47 	cp.w	r0,71
80009a48:	5f 09       	sreq	r9
80009a4a:	e0 40 00 67 	cp.w	r0,103
80009a4e:	5f 08       	sreq	r8
80009a50:	f3 e8 10 08 	or	r8,r9,r8
80009a54:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009a58:	0c 19       	sub	r9,r6
80009a5a:	50 69       	stdsp	sp[0x18],r9
80009a5c:	58 08       	cp.w	r8,0
80009a5e:	c0 b0       	breq	80009a74 <_vfprintf_r+0xa38>
80009a60:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a64:	5b d8       	cp.w	r8,-3
80009a66:	c0 55       	brlt	80009a70 <_vfprintf_r+0xa34>
80009a68:	40 2c       	lddsp	r12,sp[0x8]
80009a6a:	18 38       	cp.w	r8,r12
80009a6c:	e0 8a 00 6a 	brle	80009b40 <_vfprintf_r+0xb04>
80009a70:	20 20       	sub	r0,2
80009a72:	c0 58       	rjmp	80009a7c <_vfprintf_r+0xa40>
80009a74:	e0 40 00 65 	cp.w	r0,101
80009a78:	e0 89 00 46 	brgt	80009b04 <_vfprintf_r+0xac8>
80009a7c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009a80:	fb 60 06 9c 	st.b	sp[1692],r0
80009a84:	20 1b       	sub	r11,1
80009a86:	fb 4b 06 ac 	st.w	sp[1708],r11
80009a8a:	c0 47       	brpl	80009a92 <_vfprintf_r+0xa56>
80009a8c:	5c 3b       	neg	r11
80009a8e:	32 d8       	mov	r8,45
80009a90:	c0 28       	rjmp	80009a94 <_vfprintf_r+0xa58>
80009a92:	32 b8       	mov	r8,43
80009a94:	fb 68 06 9d 	st.b	sp[1693],r8
80009a98:	58 9b       	cp.w	r11,9
80009a9a:	e0 8a 00 1d 	brle	80009ad4 <_vfprintf_r+0xa98>
80009a9e:	fa c9 fa 35 	sub	r9,sp,-1483
80009aa2:	30 aa       	mov	r10,10
80009aa4:	12 98       	mov	r8,r9
80009aa6:	0e 9c       	mov	r12,r7
80009aa8:	0c 92       	mov	r2,r6
80009aaa:	f6 0a 0c 06 	divs	r6,r11,r10
80009aae:	0e 9b       	mov	r11,r7
80009ab0:	2d 0b       	sub	r11,-48
80009ab2:	10 fb       	st.b	--r8,r11
80009ab4:	0c 9b       	mov	r11,r6
80009ab6:	58 96       	cp.w	r6,9
80009ab8:	fe 99 ff f9 	brgt	80009aaa <_vfprintf_r+0xa6e>
80009abc:	2d 0b       	sub	r11,-48
80009abe:	18 97       	mov	r7,r12
80009ac0:	04 96       	mov	r6,r2
80009ac2:	10 fb       	st.b	--r8,r11
80009ac4:	fa ca f9 62 	sub	r10,sp,-1694
80009ac8:	c0 38       	rjmp	80009ace <_vfprintf_r+0xa92>
80009aca:	11 3b       	ld.ub	r11,r8++
80009acc:	14 cb       	st.b	r10++,r11
80009ace:	12 38       	cp.w	r8,r9
80009ad0:	cf d3       	brcs	80009aca <_vfprintf_r+0xa8e>
80009ad2:	c0 98       	rjmp	80009ae4 <_vfprintf_r+0xaa8>
80009ad4:	2d 0b       	sub	r11,-48
80009ad6:	33 08       	mov	r8,48
80009ad8:	fb 6b 06 9f 	st.b	sp[1695],r11
80009adc:	fb 68 06 9e 	st.b	sp[1694],r8
80009ae0:	fa ca f9 60 	sub	r10,sp,-1696
80009ae4:	fa c8 f9 64 	sub	r8,sp,-1692
80009ae8:	f4 08 01 08 	sub	r8,r10,r8
80009aec:	50 e8       	stdsp	sp[0x38],r8
80009aee:	10 92       	mov	r2,r8
80009af0:	40 6b       	lddsp	r11,sp[0x18]
80009af2:	16 02       	add	r2,r11
80009af4:	58 1b       	cp.w	r11,1
80009af6:	e0 89 00 05 	brgt	80009b00 <_vfprintf_r+0xac4>
80009afa:	ed b5 00 00 	bld	r5,0x0
80009afe:	c3 51       	brne	80009b68 <_vfprintf_r+0xb2c>
80009b00:	2f f2       	sub	r2,-1
80009b02:	c3 38       	rjmp	80009b68 <_vfprintf_r+0xb2c>
80009b04:	e0 40 00 66 	cp.w	r0,102
80009b08:	c1 c1       	brne	80009b40 <_vfprintf_r+0xb04>
80009b0a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b0e:	58 02       	cp.w	r2,0
80009b10:	e0 8a 00 0c 	brle	80009b28 <_vfprintf_r+0xaec>
80009b14:	40 2a       	lddsp	r10,sp[0x8]
80009b16:	58 0a       	cp.w	r10,0
80009b18:	c0 41       	brne	80009b20 <_vfprintf_r+0xae4>
80009b1a:	ed b5 00 00 	bld	r5,0x0
80009b1e:	c2 51       	brne	80009b68 <_vfprintf_r+0xb2c>
80009b20:	2f f2       	sub	r2,-1
80009b22:	40 29       	lddsp	r9,sp[0x8]
80009b24:	12 02       	add	r2,r9
80009b26:	c0 b8       	rjmp	80009b3c <_vfprintf_r+0xb00>
80009b28:	40 28       	lddsp	r8,sp[0x8]
80009b2a:	58 08       	cp.w	r8,0
80009b2c:	c0 61       	brne	80009b38 <_vfprintf_r+0xafc>
80009b2e:	ed b5 00 00 	bld	r5,0x0
80009b32:	c0 30       	breq	80009b38 <_vfprintf_r+0xafc>
80009b34:	30 12       	mov	r2,1
80009b36:	c1 98       	rjmp	80009b68 <_vfprintf_r+0xb2c>
80009b38:	40 22       	lddsp	r2,sp[0x8]
80009b3a:	2f e2       	sub	r2,-2
80009b3c:	36 60       	mov	r0,102
80009b3e:	c1 58       	rjmp	80009b68 <_vfprintf_r+0xb2c>
80009b40:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b44:	40 6e       	lddsp	lr,sp[0x18]
80009b46:	1c 32       	cp.w	r2,lr
80009b48:	c0 65       	brlt	80009b54 <_vfprintf_r+0xb18>
80009b4a:	ed b5 00 00 	bld	r5,0x0
80009b4e:	f7 b2 00 ff 	subeq	r2,-1
80009b52:	c0 a8       	rjmp	80009b66 <_vfprintf_r+0xb2a>
80009b54:	e4 08 11 02 	rsub	r8,r2,2
80009b58:	40 6c       	lddsp	r12,sp[0x18]
80009b5a:	58 02       	cp.w	r2,0
80009b5c:	f0 02 17 a0 	movle	r2,r8
80009b60:	f9 b2 09 01 	movgt	r2,1
80009b64:	18 02       	add	r2,r12
80009b66:	36 70       	mov	r0,103
80009b68:	40 9b       	lddsp	r11,sp[0x24]
80009b6a:	58 0b       	cp.w	r11,0
80009b6c:	e0 80 05 94 	breq	8000a694 <_vfprintf_r+0x1658>
80009b70:	32 d8       	mov	r8,45
80009b72:	fb 68 06 bb 	st.b	sp[1723],r8
80009b76:	e0 8f 05 93 	bral	8000a69c <_vfprintf_r+0x1660>
80009b7a:	50 a7       	stdsp	sp[0x28],r7
80009b7c:	04 94       	mov	r4,r2
80009b7e:	0c 97       	mov	r7,r6
80009b80:	02 92       	mov	r2,r1
80009b82:	06 96       	mov	r6,r3
80009b84:	40 41       	lddsp	r1,sp[0x10]
80009b86:	40 93       	lddsp	r3,sp[0x24]
80009b88:	0e 99       	mov	r9,r7
80009b8a:	ed b5 00 05 	bld	r5,0x5
80009b8e:	c4 81       	brne	80009c1e <_vfprintf_r+0xbe2>
80009b90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b94:	40 3e       	lddsp	lr,sp[0xc]
80009b96:	58 0e       	cp.w	lr,0
80009b98:	c1 d0       	breq	80009bd2 <_vfprintf_r+0xb96>
80009b9a:	10 36       	cp.w	r6,r8
80009b9c:	c0 64       	brge	80009ba8 <_vfprintf_r+0xb6c>
80009b9e:	fa cc f9 44 	sub	r12,sp,-1724
80009ba2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009ba6:	c1 d8       	rjmp	80009be0 <_vfprintf_r+0xba4>
80009ba8:	fa c8 f9 50 	sub	r8,sp,-1712
80009bac:	1a d8       	st.w	--sp,r8
80009bae:	fa c8 fa b8 	sub	r8,sp,-1352
80009bb2:	04 9a       	mov	r10,r2
80009bb4:	1a d8       	st.w	--sp,r8
80009bb6:	fa c8 fb b4 	sub	r8,sp,-1100
80009bba:	0c 9b       	mov	r11,r6
80009bbc:	1a d8       	st.w	--sp,r8
80009bbe:	08 9c       	mov	r12,r4
80009bc0:	fa c8 f9 40 	sub	r8,sp,-1728
80009bc4:	fa c9 ff b4 	sub	r9,sp,-76
80009bc8:	fe b0 f8 a2 	rcall	80008d0c <get_arg>
80009bcc:	2f dd       	sub	sp,-12
80009bce:	78 0a       	ld.w	r10,r12[0x0]
80009bd0:	c2 08       	rjmp	80009c10 <_vfprintf_r+0xbd4>
80009bd2:	2f f7       	sub	r7,-1
80009bd4:	10 39       	cp.w	r9,r8
80009bd6:	c0 84       	brge	80009be6 <_vfprintf_r+0xbaa>
80009bd8:	fa cb f9 44 	sub	r11,sp,-1724
80009bdc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009be0:	ec fa fd 88 	ld.w	r10,r6[-632]
80009be4:	c1 68       	rjmp	80009c10 <_vfprintf_r+0xbd4>
80009be6:	41 09       	lddsp	r9,sp[0x40]
80009be8:	59 f8       	cp.w	r8,31
80009bea:	e0 89 00 10 	brgt	80009c0a <_vfprintf_r+0xbce>
80009bee:	f2 ca ff fc 	sub	r10,r9,-4
80009bf2:	51 0a       	stdsp	sp[0x40],r10
80009bf4:	fa c6 f9 44 	sub	r6,sp,-1724
80009bf8:	72 0a       	ld.w	r10,r9[0x0]
80009bfa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009bfe:	f3 4a fd 88 	st.w	r9[-632],r10
80009c02:	2f f8       	sub	r8,-1
80009c04:	fb 48 06 b4 	st.w	sp[1716],r8
80009c08:	c0 48       	rjmp	80009c10 <_vfprintf_r+0xbd4>
80009c0a:	72 0a       	ld.w	r10,r9[0x0]
80009c0c:	2f c9       	sub	r9,-4
80009c0e:	51 09       	stdsp	sp[0x40],r9
80009c10:	40 be       	lddsp	lr,sp[0x2c]
80009c12:	1c 98       	mov	r8,lr
80009c14:	95 1e       	st.w	r10[0x4],lr
80009c16:	bf 58       	asr	r8,0x1f
80009c18:	95 08       	st.w	r10[0x0],r8
80009c1a:	fe 9f fa 9f 	bral	80009158 <_vfprintf_r+0x11c>
80009c1e:	ed b5 00 04 	bld	r5,0x4
80009c22:	c4 80       	breq	80009cb2 <_vfprintf_r+0xc76>
80009c24:	e2 15 00 40 	andl	r5,0x40,COH
80009c28:	c4 50       	breq	80009cb2 <_vfprintf_r+0xc76>
80009c2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c2e:	40 3c       	lddsp	r12,sp[0xc]
80009c30:	58 0c       	cp.w	r12,0
80009c32:	c1 d0       	breq	80009c6c <_vfprintf_r+0xc30>
80009c34:	10 36       	cp.w	r6,r8
80009c36:	c0 64       	brge	80009c42 <_vfprintf_r+0xc06>
80009c38:	fa cb f9 44 	sub	r11,sp,-1724
80009c3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c40:	c1 d8       	rjmp	80009c7a <_vfprintf_r+0xc3e>
80009c42:	fa c8 f9 50 	sub	r8,sp,-1712
80009c46:	1a d8       	st.w	--sp,r8
80009c48:	fa c8 fa b8 	sub	r8,sp,-1352
80009c4c:	04 9a       	mov	r10,r2
80009c4e:	1a d8       	st.w	--sp,r8
80009c50:	fa c8 fb b4 	sub	r8,sp,-1100
80009c54:	0c 9b       	mov	r11,r6
80009c56:	1a d8       	st.w	--sp,r8
80009c58:	08 9c       	mov	r12,r4
80009c5a:	fa c8 f9 40 	sub	r8,sp,-1728
80009c5e:	fa c9 ff b4 	sub	r9,sp,-76
80009c62:	fe b0 f8 55 	rcall	80008d0c <get_arg>
80009c66:	2f dd       	sub	sp,-12
80009c68:	78 0a       	ld.w	r10,r12[0x0]
80009c6a:	c2 08       	rjmp	80009caa <_vfprintf_r+0xc6e>
80009c6c:	2f f7       	sub	r7,-1
80009c6e:	10 39       	cp.w	r9,r8
80009c70:	c0 84       	brge	80009c80 <_vfprintf_r+0xc44>
80009c72:	fa ca f9 44 	sub	r10,sp,-1724
80009c76:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009c7a:	ec fa fd 88 	ld.w	r10,r6[-632]
80009c7e:	c1 68       	rjmp	80009caa <_vfprintf_r+0xc6e>
80009c80:	41 09       	lddsp	r9,sp[0x40]
80009c82:	59 f8       	cp.w	r8,31
80009c84:	e0 89 00 10 	brgt	80009ca4 <_vfprintf_r+0xc68>
80009c88:	f2 ca ff fc 	sub	r10,r9,-4
80009c8c:	51 0a       	stdsp	sp[0x40],r10
80009c8e:	fa c6 f9 44 	sub	r6,sp,-1724
80009c92:	72 0a       	ld.w	r10,r9[0x0]
80009c94:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c98:	f3 4a fd 88 	st.w	r9[-632],r10
80009c9c:	2f f8       	sub	r8,-1
80009c9e:	fb 48 06 b4 	st.w	sp[1716],r8
80009ca2:	c0 48       	rjmp	80009caa <_vfprintf_r+0xc6e>
80009ca4:	72 0a       	ld.w	r10,r9[0x0]
80009ca6:	2f c9       	sub	r9,-4
80009ca8:	51 09       	stdsp	sp[0x40],r9
80009caa:	40 be       	lddsp	lr,sp[0x2c]
80009cac:	b4 0e       	st.h	r10[0x0],lr
80009cae:	fe 9f fa 55 	bral	80009158 <_vfprintf_r+0x11c>
80009cb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cb6:	40 3c       	lddsp	r12,sp[0xc]
80009cb8:	58 0c       	cp.w	r12,0
80009cba:	c1 d0       	breq	80009cf4 <_vfprintf_r+0xcb8>
80009cbc:	10 36       	cp.w	r6,r8
80009cbe:	c0 64       	brge	80009cca <_vfprintf_r+0xc8e>
80009cc0:	fa cb f9 44 	sub	r11,sp,-1724
80009cc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cc8:	c1 d8       	rjmp	80009d02 <_vfprintf_r+0xcc6>
80009cca:	fa c8 f9 50 	sub	r8,sp,-1712
80009cce:	1a d8       	st.w	--sp,r8
80009cd0:	fa c8 fa b8 	sub	r8,sp,-1352
80009cd4:	04 9a       	mov	r10,r2
80009cd6:	1a d8       	st.w	--sp,r8
80009cd8:	fa c8 fb b4 	sub	r8,sp,-1100
80009cdc:	0c 9b       	mov	r11,r6
80009cde:	1a d8       	st.w	--sp,r8
80009ce0:	08 9c       	mov	r12,r4
80009ce2:	fa c8 f9 40 	sub	r8,sp,-1728
80009ce6:	fa c9 ff b4 	sub	r9,sp,-76
80009cea:	fe b0 f8 11 	rcall	80008d0c <get_arg>
80009cee:	2f dd       	sub	sp,-12
80009cf0:	78 0a       	ld.w	r10,r12[0x0]
80009cf2:	c2 08       	rjmp	80009d32 <_vfprintf_r+0xcf6>
80009cf4:	2f f7       	sub	r7,-1
80009cf6:	10 39       	cp.w	r9,r8
80009cf8:	c0 84       	brge	80009d08 <_vfprintf_r+0xccc>
80009cfa:	fa ca f9 44 	sub	r10,sp,-1724
80009cfe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009d02:	ec fa fd 88 	ld.w	r10,r6[-632]
80009d06:	c1 68       	rjmp	80009d32 <_vfprintf_r+0xcf6>
80009d08:	41 09       	lddsp	r9,sp[0x40]
80009d0a:	59 f8       	cp.w	r8,31
80009d0c:	e0 89 00 10 	brgt	80009d2c <_vfprintf_r+0xcf0>
80009d10:	f2 ca ff fc 	sub	r10,r9,-4
80009d14:	51 0a       	stdsp	sp[0x40],r10
80009d16:	fa c6 f9 44 	sub	r6,sp,-1724
80009d1a:	72 0a       	ld.w	r10,r9[0x0]
80009d1c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d20:	f3 4a fd 88 	st.w	r9[-632],r10
80009d24:	2f f8       	sub	r8,-1
80009d26:	fb 48 06 b4 	st.w	sp[1716],r8
80009d2a:	c0 48       	rjmp	80009d32 <_vfprintf_r+0xcf6>
80009d2c:	72 0a       	ld.w	r10,r9[0x0]
80009d2e:	2f c9       	sub	r9,-4
80009d30:	51 09       	stdsp	sp[0x40],r9
80009d32:	40 be       	lddsp	lr,sp[0x2c]
80009d34:	95 0e       	st.w	r10[0x0],lr
80009d36:	fe 9f fa 11 	bral	80009158 <_vfprintf_r+0x11c>
80009d3a:	50 a7       	stdsp	sp[0x28],r7
80009d3c:	50 80       	stdsp	sp[0x20],r0
80009d3e:	0c 97       	mov	r7,r6
80009d40:	04 94       	mov	r4,r2
80009d42:	06 96       	mov	r6,r3
80009d44:	02 92       	mov	r2,r1
80009d46:	40 93       	lddsp	r3,sp[0x24]
80009d48:	10 90       	mov	r0,r8
80009d4a:	40 41       	lddsp	r1,sp[0x10]
80009d4c:	a5 a5       	sbr	r5,0x4
80009d4e:	c0 a8       	rjmp	80009d62 <_vfprintf_r+0xd26>
80009d50:	50 a7       	stdsp	sp[0x28],r7
80009d52:	50 80       	stdsp	sp[0x20],r0
80009d54:	0c 97       	mov	r7,r6
80009d56:	04 94       	mov	r4,r2
80009d58:	06 96       	mov	r6,r3
80009d5a:	02 92       	mov	r2,r1
80009d5c:	40 93       	lddsp	r3,sp[0x24]
80009d5e:	10 90       	mov	r0,r8
80009d60:	40 41       	lddsp	r1,sp[0x10]
80009d62:	ed b5 00 05 	bld	r5,0x5
80009d66:	c5 d1       	brne	80009e20 <_vfprintf_r+0xde4>
80009d68:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d6c:	40 3c       	lddsp	r12,sp[0xc]
80009d6e:	58 0c       	cp.w	r12,0
80009d70:	c2 60       	breq	80009dbc <_vfprintf_r+0xd80>
80009d72:	10 36       	cp.w	r6,r8
80009d74:	c0 a4       	brge	80009d88 <_vfprintf_r+0xd4c>
80009d76:	fa cb f9 44 	sub	r11,sp,-1724
80009d7a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d7e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009d82:	fa e9 00 00 	st.d	sp[0],r8
80009d86:	c1 88       	rjmp	80009db6 <_vfprintf_r+0xd7a>
80009d88:	fa c8 f9 50 	sub	r8,sp,-1712
80009d8c:	1a d8       	st.w	--sp,r8
80009d8e:	fa c8 fa b8 	sub	r8,sp,-1352
80009d92:	04 9a       	mov	r10,r2
80009d94:	1a d8       	st.w	--sp,r8
80009d96:	0c 9b       	mov	r11,r6
80009d98:	fa c8 fb b4 	sub	r8,sp,-1100
80009d9c:	08 9c       	mov	r12,r4
80009d9e:	1a d8       	st.w	--sp,r8
80009da0:	fa c8 f9 40 	sub	r8,sp,-1728
80009da4:	fa c9 ff b4 	sub	r9,sp,-76
80009da8:	fe b0 f7 b2 	rcall	80008d0c <get_arg>
80009dac:	2f dd       	sub	sp,-12
80009dae:	f8 ea 00 00 	ld.d	r10,r12[0]
80009db2:	fa eb 00 00 	st.d	sp[0],r10
80009db6:	30 08       	mov	r8,0
80009db8:	e0 8f 03 de 	bral	8000a574 <_vfprintf_r+0x1538>
80009dbc:	ee ca ff ff 	sub	r10,r7,-1
80009dc0:	10 37       	cp.w	r7,r8
80009dc2:	c0 b4       	brge	80009dd8 <_vfprintf_r+0xd9c>
80009dc4:	fa c9 f9 44 	sub	r9,sp,-1724
80009dc8:	14 97       	mov	r7,r10
80009dca:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009dce:	ec ea fd 88 	ld.d	r10,r6[-632]
80009dd2:	fa eb 00 00 	st.d	sp[0],r10
80009dd6:	c1 88       	rjmp	80009e06 <_vfprintf_r+0xdca>
80009dd8:	41 09       	lddsp	r9,sp[0x40]
80009dda:	59 f8       	cp.w	r8,31
80009ddc:	e0 89 00 18 	brgt	80009e0c <_vfprintf_r+0xdd0>
80009de0:	f2 e6 00 00 	ld.d	r6,r9[0]
80009de4:	f2 cb ff f8 	sub	r11,r9,-8
80009de8:	fa e7 00 00 	st.d	sp[0],r6
80009dec:	51 0b       	stdsp	sp[0x40],r11
80009dee:	fa c6 f9 44 	sub	r6,sp,-1724
80009df2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009df6:	fa e6 00 00 	ld.d	r6,sp[0]
80009dfa:	f2 e7 fd 88 	st.d	r9[-632],r6
80009dfe:	2f f8       	sub	r8,-1
80009e00:	14 97       	mov	r7,r10
80009e02:	fb 48 06 b4 	st.w	sp[1716],r8
80009e06:	40 38       	lddsp	r8,sp[0xc]
80009e08:	e0 8f 03 b6 	bral	8000a574 <_vfprintf_r+0x1538>
80009e0c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e10:	40 38       	lddsp	r8,sp[0xc]
80009e12:	fa e7 00 00 	st.d	sp[0],r6
80009e16:	2f 89       	sub	r9,-8
80009e18:	14 97       	mov	r7,r10
80009e1a:	51 09       	stdsp	sp[0x40],r9
80009e1c:	e0 8f 03 ac 	bral	8000a574 <_vfprintf_r+0x1538>
80009e20:	ed b5 00 04 	bld	r5,0x4
80009e24:	c1 61       	brne	80009e50 <_vfprintf_r+0xe14>
80009e26:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e2a:	40 3e       	lddsp	lr,sp[0xc]
80009e2c:	58 0e       	cp.w	lr,0
80009e2e:	c0 80       	breq	80009e3e <_vfprintf_r+0xe02>
80009e30:	10 36       	cp.w	r6,r8
80009e32:	c6 74       	brge	80009f00 <_vfprintf_r+0xec4>
80009e34:	fa cc f9 44 	sub	r12,sp,-1724
80009e38:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009e3c:	c8 08       	rjmp	80009f3c <_vfprintf_r+0xf00>
80009e3e:	ee ca ff ff 	sub	r10,r7,-1
80009e42:	10 37       	cp.w	r7,r8
80009e44:	c7 f4       	brge	80009f42 <_vfprintf_r+0xf06>
80009e46:	fa cb f9 44 	sub	r11,sp,-1724
80009e4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e4e:	c7 68       	rjmp	80009f3a <_vfprintf_r+0xefe>
80009e50:	ed b5 00 06 	bld	r5,0x6
80009e54:	c4 a1       	brne	80009ee8 <_vfprintf_r+0xeac>
80009e56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e5a:	40 3c       	lddsp	r12,sp[0xc]
80009e5c:	58 0c       	cp.w	r12,0
80009e5e:	c1 d0       	breq	80009e98 <_vfprintf_r+0xe5c>
80009e60:	10 36       	cp.w	r6,r8
80009e62:	c0 64       	brge	80009e6e <_vfprintf_r+0xe32>
80009e64:	fa cb f9 44 	sub	r11,sp,-1724
80009e68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e6c:	c1 f8       	rjmp	80009eaa <_vfprintf_r+0xe6e>
80009e6e:	fa c8 f9 50 	sub	r8,sp,-1712
80009e72:	1a d8       	st.w	--sp,r8
80009e74:	fa c8 fa b8 	sub	r8,sp,-1352
80009e78:	1a d8       	st.w	--sp,r8
80009e7a:	fa c8 fb b4 	sub	r8,sp,-1100
80009e7e:	1a d8       	st.w	--sp,r8
80009e80:	fa c8 f9 40 	sub	r8,sp,-1728
80009e84:	fa c9 ff b4 	sub	r9,sp,-76
80009e88:	04 9a       	mov	r10,r2
80009e8a:	0c 9b       	mov	r11,r6
80009e8c:	08 9c       	mov	r12,r4
80009e8e:	fe b0 f7 3f 	rcall	80008d0c <get_arg>
80009e92:	2f dd       	sub	sp,-12
80009e94:	98 18       	ld.sh	r8,r12[0x2]
80009e96:	c2 68       	rjmp	80009ee2 <_vfprintf_r+0xea6>
80009e98:	ee ca ff ff 	sub	r10,r7,-1
80009e9c:	10 37       	cp.w	r7,r8
80009e9e:	c0 94       	brge	80009eb0 <_vfprintf_r+0xe74>
80009ea0:	fa c9 f9 44 	sub	r9,sp,-1724
80009ea4:	14 97       	mov	r7,r10
80009ea6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009eaa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009eae:	c1 a8       	rjmp	80009ee2 <_vfprintf_r+0xea6>
80009eb0:	41 09       	lddsp	r9,sp[0x40]
80009eb2:	59 f8       	cp.w	r8,31
80009eb4:	e0 89 00 13 	brgt	80009eda <_vfprintf_r+0xe9e>
80009eb8:	f2 cb ff fc 	sub	r11,r9,-4
80009ebc:	51 0b       	stdsp	sp[0x40],r11
80009ebe:	72 09       	ld.w	r9,r9[0x0]
80009ec0:	fa c6 f9 44 	sub	r6,sp,-1724
80009ec4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009ec8:	2f f8       	sub	r8,-1
80009eca:	f7 49 fd 88 	st.w	r11[-632],r9
80009ece:	fb 48 06 b4 	st.w	sp[1716],r8
80009ed2:	14 97       	mov	r7,r10
80009ed4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009ed8:	c0 58       	rjmp	80009ee2 <_vfprintf_r+0xea6>
80009eda:	92 18       	ld.sh	r8,r9[0x2]
80009edc:	14 97       	mov	r7,r10
80009ede:	2f c9       	sub	r9,-4
80009ee0:	51 09       	stdsp	sp[0x40],r9
80009ee2:	5c 78       	castu.h	r8
80009ee4:	50 18       	stdsp	sp[0x4],r8
80009ee6:	c4 68       	rjmp	80009f72 <_vfprintf_r+0xf36>
80009ee8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009eec:	40 3c       	lddsp	r12,sp[0xc]
80009eee:	58 0c       	cp.w	r12,0
80009ef0:	c1 d0       	breq	80009f2a <_vfprintf_r+0xeee>
80009ef2:	10 36       	cp.w	r6,r8
80009ef4:	c0 64       	brge	80009f00 <_vfprintf_r+0xec4>
80009ef6:	fa cb f9 44 	sub	r11,sp,-1724
80009efa:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009efe:	c1 f8       	rjmp	80009f3c <_vfprintf_r+0xf00>
80009f00:	fa c8 f9 50 	sub	r8,sp,-1712
80009f04:	1a d8       	st.w	--sp,r8
80009f06:	fa c8 fa b8 	sub	r8,sp,-1352
80009f0a:	0c 9b       	mov	r11,r6
80009f0c:	1a d8       	st.w	--sp,r8
80009f0e:	fa c8 fb b4 	sub	r8,sp,-1100
80009f12:	04 9a       	mov	r10,r2
80009f14:	1a d8       	st.w	--sp,r8
80009f16:	08 9c       	mov	r12,r4
80009f18:	fa c8 f9 40 	sub	r8,sp,-1728
80009f1c:	fa c9 ff b4 	sub	r9,sp,-76
80009f20:	fe b0 f6 f6 	rcall	80008d0c <get_arg>
80009f24:	2f dd       	sub	sp,-12
80009f26:	78 0b       	ld.w	r11,r12[0x0]
80009f28:	c2 48       	rjmp	80009f70 <_vfprintf_r+0xf34>
80009f2a:	ee ca ff ff 	sub	r10,r7,-1
80009f2e:	10 37       	cp.w	r7,r8
80009f30:	c0 94       	brge	80009f42 <_vfprintf_r+0xf06>
80009f32:	fa c9 f9 44 	sub	r9,sp,-1724
80009f36:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f3a:	14 97       	mov	r7,r10
80009f3c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009f40:	c1 88       	rjmp	80009f70 <_vfprintf_r+0xf34>
80009f42:	41 09       	lddsp	r9,sp[0x40]
80009f44:	59 f8       	cp.w	r8,31
80009f46:	e0 89 00 11 	brgt	80009f68 <_vfprintf_r+0xf2c>
80009f4a:	f2 cb ff fc 	sub	r11,r9,-4
80009f4e:	51 0b       	stdsp	sp[0x40],r11
80009f50:	fa c6 f9 44 	sub	r6,sp,-1724
80009f54:	72 0b       	ld.w	r11,r9[0x0]
80009f56:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009f5a:	f3 4b fd 88 	st.w	r9[-632],r11
80009f5e:	2f f8       	sub	r8,-1
80009f60:	14 97       	mov	r7,r10
80009f62:	fb 48 06 b4 	st.w	sp[1716],r8
80009f66:	c0 58       	rjmp	80009f70 <_vfprintf_r+0xf34>
80009f68:	72 0b       	ld.w	r11,r9[0x0]
80009f6a:	14 97       	mov	r7,r10
80009f6c:	2f c9       	sub	r9,-4
80009f6e:	51 09       	stdsp	sp[0x40],r9
80009f70:	50 1b       	stdsp	sp[0x4],r11
80009f72:	30 0e       	mov	lr,0
80009f74:	50 0e       	stdsp	sp[0x0],lr
80009f76:	1c 98       	mov	r8,lr
80009f78:	e0 8f 02 fe 	bral	8000a574 <_vfprintf_r+0x1538>
80009f7c:	50 a7       	stdsp	sp[0x28],r7
80009f7e:	50 80       	stdsp	sp[0x20],r0
80009f80:	0c 97       	mov	r7,r6
80009f82:	04 94       	mov	r4,r2
80009f84:	06 96       	mov	r6,r3
80009f86:	02 92       	mov	r2,r1
80009f88:	40 93       	lddsp	r3,sp[0x24]
80009f8a:	40 41       	lddsp	r1,sp[0x10]
80009f8c:	0e 99       	mov	r9,r7
80009f8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f92:	40 3c       	lddsp	r12,sp[0xc]
80009f94:	58 0c       	cp.w	r12,0
80009f96:	c1 d0       	breq	80009fd0 <_vfprintf_r+0xf94>
80009f98:	10 36       	cp.w	r6,r8
80009f9a:	c0 64       	brge	80009fa6 <_vfprintf_r+0xf6a>
80009f9c:	fa cb f9 44 	sub	r11,sp,-1724
80009fa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009fa4:	c1 d8       	rjmp	80009fde <_vfprintf_r+0xfa2>
80009fa6:	fa c8 f9 50 	sub	r8,sp,-1712
80009faa:	1a d8       	st.w	--sp,r8
80009fac:	fa c8 fa b8 	sub	r8,sp,-1352
80009fb0:	1a d8       	st.w	--sp,r8
80009fb2:	fa c8 fb b4 	sub	r8,sp,-1100
80009fb6:	1a d8       	st.w	--sp,r8
80009fb8:	fa c9 ff b4 	sub	r9,sp,-76
80009fbc:	fa c8 f9 40 	sub	r8,sp,-1728
80009fc0:	04 9a       	mov	r10,r2
80009fc2:	0c 9b       	mov	r11,r6
80009fc4:	08 9c       	mov	r12,r4
80009fc6:	fe b0 f6 a3 	rcall	80008d0c <get_arg>
80009fca:	2f dd       	sub	sp,-12
80009fcc:	78 09       	ld.w	r9,r12[0x0]
80009fce:	c2 18       	rjmp	8000a010 <_vfprintf_r+0xfd4>
80009fd0:	2f f7       	sub	r7,-1
80009fd2:	10 39       	cp.w	r9,r8
80009fd4:	c0 84       	brge	80009fe4 <_vfprintf_r+0xfa8>
80009fd6:	fa ca f9 44 	sub	r10,sp,-1724
80009fda:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009fde:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009fe2:	c1 78       	rjmp	8000a010 <_vfprintf_r+0xfd4>
80009fe4:	41 09       	lddsp	r9,sp[0x40]
80009fe6:	59 f8       	cp.w	r8,31
80009fe8:	e0 89 00 10 	brgt	8000a008 <_vfprintf_r+0xfcc>
80009fec:	f2 ca ff fc 	sub	r10,r9,-4
80009ff0:	51 0a       	stdsp	sp[0x40],r10
80009ff2:	fa c6 f9 44 	sub	r6,sp,-1724
80009ff6:	72 09       	ld.w	r9,r9[0x0]
80009ff8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009ffc:	f5 49 fd 88 	st.w	r10[-632],r9
8000a000:	2f f8       	sub	r8,-1
8000a002:	fb 48 06 b4 	st.w	sp[1716],r8
8000a006:	c0 58       	rjmp	8000a010 <_vfprintf_r+0xfd4>
8000a008:	f2 c8 ff fc 	sub	r8,r9,-4
8000a00c:	51 08       	stdsp	sp[0x40],r8
8000a00e:	72 09       	ld.w	r9,r9[0x0]
8000a010:	33 08       	mov	r8,48
8000a012:	fb 68 06 b8 	st.b	sp[1720],r8
8000a016:	37 88       	mov	r8,120
8000a018:	30 0e       	mov	lr,0
8000a01a:	fb 68 06 b9 	st.b	sp[1721],r8
8000a01e:	fe cc ac f6 	sub	r12,pc,-21258
8000a022:	50 19       	stdsp	sp[0x4],r9
8000a024:	a1 b5       	sbr	r5,0x1
8000a026:	50 0e       	stdsp	sp[0x0],lr
8000a028:	50 dc       	stdsp	sp[0x34],r12
8000a02a:	30 28       	mov	r8,2
8000a02c:	37 80       	mov	r0,120
8000a02e:	e0 8f 02 a3 	bral	8000a574 <_vfprintf_r+0x1538>
8000a032:	50 a7       	stdsp	sp[0x28],r7
8000a034:	50 80       	stdsp	sp[0x20],r0
8000a036:	10 90       	mov	r0,r8
8000a038:	30 08       	mov	r8,0
8000a03a:	fb 68 06 bb 	st.b	sp[1723],r8
8000a03e:	0c 97       	mov	r7,r6
8000a040:	04 94       	mov	r4,r2
8000a042:	06 96       	mov	r6,r3
8000a044:	02 92       	mov	r2,r1
8000a046:	40 93       	lddsp	r3,sp[0x24]
8000a048:	40 41       	lddsp	r1,sp[0x10]
8000a04a:	0e 99       	mov	r9,r7
8000a04c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a050:	40 3b       	lddsp	r11,sp[0xc]
8000a052:	58 0b       	cp.w	r11,0
8000a054:	c1 d0       	breq	8000a08e <_vfprintf_r+0x1052>
8000a056:	10 36       	cp.w	r6,r8
8000a058:	c0 64       	brge	8000a064 <_vfprintf_r+0x1028>
8000a05a:	fa ca f9 44 	sub	r10,sp,-1724
8000a05e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a062:	c1 d8       	rjmp	8000a09c <_vfprintf_r+0x1060>
8000a064:	fa c8 f9 50 	sub	r8,sp,-1712
8000a068:	1a d8       	st.w	--sp,r8
8000a06a:	fa c8 fa b8 	sub	r8,sp,-1352
8000a06e:	1a d8       	st.w	--sp,r8
8000a070:	fa c8 fb b4 	sub	r8,sp,-1100
8000a074:	0c 9b       	mov	r11,r6
8000a076:	1a d8       	st.w	--sp,r8
8000a078:	04 9a       	mov	r10,r2
8000a07a:	fa c8 f9 40 	sub	r8,sp,-1728
8000a07e:	fa c9 ff b4 	sub	r9,sp,-76
8000a082:	08 9c       	mov	r12,r4
8000a084:	fe b0 f6 44 	rcall	80008d0c <get_arg>
8000a088:	2f dd       	sub	sp,-12
8000a08a:	78 06       	ld.w	r6,r12[0x0]
8000a08c:	c2 08       	rjmp	8000a0cc <_vfprintf_r+0x1090>
8000a08e:	2f f7       	sub	r7,-1
8000a090:	10 39       	cp.w	r9,r8
8000a092:	c0 84       	brge	8000a0a2 <_vfprintf_r+0x1066>
8000a094:	fa c9 f9 44 	sub	r9,sp,-1724
8000a098:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a09c:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a0a0:	c1 68       	rjmp	8000a0cc <_vfprintf_r+0x1090>
8000a0a2:	41 09       	lddsp	r9,sp[0x40]
8000a0a4:	59 f8       	cp.w	r8,31
8000a0a6:	e0 89 00 10 	brgt	8000a0c6 <_vfprintf_r+0x108a>
8000a0aa:	f2 ca ff fc 	sub	r10,r9,-4
8000a0ae:	51 0a       	stdsp	sp[0x40],r10
8000a0b0:	72 06       	ld.w	r6,r9[0x0]
8000a0b2:	fa ce f9 44 	sub	lr,sp,-1724
8000a0b6:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a0ba:	f3 46 fd 88 	st.w	r9[-632],r6
8000a0be:	2f f8       	sub	r8,-1
8000a0c0:	fb 48 06 b4 	st.w	sp[1716],r8
8000a0c4:	c0 48       	rjmp	8000a0cc <_vfprintf_r+0x1090>
8000a0c6:	72 06       	ld.w	r6,r9[0x0]
8000a0c8:	2f c9       	sub	r9,-4
8000a0ca:	51 09       	stdsp	sp[0x40],r9
8000a0cc:	40 2c       	lddsp	r12,sp[0x8]
8000a0ce:	58 0c       	cp.w	r12,0
8000a0d0:	c1 05       	brlt	8000a0f0 <_vfprintf_r+0x10b4>
8000a0d2:	18 9a       	mov	r10,r12
8000a0d4:	30 0b       	mov	r11,0
8000a0d6:	0c 9c       	mov	r12,r6
8000a0d8:	e0 a0 12 38 	rcall	8000c548 <memchr>
8000a0dc:	e0 80 02 df 	breq	8000a69a <_vfprintf_r+0x165e>
8000a0e0:	f8 06 01 02 	sub	r2,r12,r6
8000a0e4:	40 2b       	lddsp	r11,sp[0x8]
8000a0e6:	16 32       	cp.w	r2,r11
8000a0e8:	e0 89 02 d9 	brgt	8000a69a <_vfprintf_r+0x165e>
8000a0ec:	e0 8f 02 d4 	bral	8000a694 <_vfprintf_r+0x1658>
8000a0f0:	30 0a       	mov	r10,0
8000a0f2:	0c 9c       	mov	r12,r6
8000a0f4:	50 2a       	stdsp	sp[0x8],r10
8000a0f6:	e0 a0 15 99 	rcall	8000cc28 <strlen>
8000a0fa:	18 92       	mov	r2,r12
8000a0fc:	e0 8f 02 d2 	bral	8000a6a0 <_vfprintf_r+0x1664>
8000a100:	50 a7       	stdsp	sp[0x28],r7
8000a102:	50 80       	stdsp	sp[0x20],r0
8000a104:	0c 97       	mov	r7,r6
8000a106:	04 94       	mov	r4,r2
8000a108:	06 96       	mov	r6,r3
8000a10a:	02 92       	mov	r2,r1
8000a10c:	40 93       	lddsp	r3,sp[0x24]
8000a10e:	10 90       	mov	r0,r8
8000a110:	40 41       	lddsp	r1,sp[0x10]
8000a112:	a5 a5       	sbr	r5,0x4
8000a114:	c0 a8       	rjmp	8000a128 <_vfprintf_r+0x10ec>
8000a116:	50 a7       	stdsp	sp[0x28],r7
8000a118:	50 80       	stdsp	sp[0x20],r0
8000a11a:	0c 97       	mov	r7,r6
8000a11c:	04 94       	mov	r4,r2
8000a11e:	06 96       	mov	r6,r3
8000a120:	02 92       	mov	r2,r1
8000a122:	40 93       	lddsp	r3,sp[0x24]
8000a124:	10 90       	mov	r0,r8
8000a126:	40 41       	lddsp	r1,sp[0x10]
8000a128:	ed b5 00 05 	bld	r5,0x5
8000a12c:	c5 61       	brne	8000a1d8 <_vfprintf_r+0x119c>
8000a12e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a132:	40 39       	lddsp	r9,sp[0xc]
8000a134:	58 09       	cp.w	r9,0
8000a136:	c2 10       	breq	8000a178 <_vfprintf_r+0x113c>
8000a138:	10 36       	cp.w	r6,r8
8000a13a:	c0 74       	brge	8000a148 <_vfprintf_r+0x110c>
8000a13c:	fa c8 f9 44 	sub	r8,sp,-1724
8000a140:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a144:	c2 38       	rjmp	8000a18a <_vfprintf_r+0x114e>
8000a146:	d7 03       	nop
8000a148:	fa c8 f9 50 	sub	r8,sp,-1712
8000a14c:	1a d8       	st.w	--sp,r8
8000a14e:	fa c8 fa b8 	sub	r8,sp,-1352
8000a152:	1a d8       	st.w	--sp,r8
8000a154:	fa c8 fb b4 	sub	r8,sp,-1100
8000a158:	1a d8       	st.w	--sp,r8
8000a15a:	fa c8 f9 40 	sub	r8,sp,-1728
8000a15e:	fa c9 ff b4 	sub	r9,sp,-76
8000a162:	04 9a       	mov	r10,r2
8000a164:	0c 9b       	mov	r11,r6
8000a166:	08 9c       	mov	r12,r4
8000a168:	fe b0 f5 d2 	rcall	80008d0c <get_arg>
8000a16c:	2f dd       	sub	sp,-12
8000a16e:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a172:	fa e9 00 00 	st.d	sp[0],r8
8000a176:	c2 e8       	rjmp	8000a1d2 <_vfprintf_r+0x1196>
8000a178:	ee ca ff ff 	sub	r10,r7,-1
8000a17c:	10 37       	cp.w	r7,r8
8000a17e:	c0 b4       	brge	8000a194 <_vfprintf_r+0x1158>
8000a180:	fa c8 f9 44 	sub	r8,sp,-1724
8000a184:	14 97       	mov	r7,r10
8000a186:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a18a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a18e:	fa eb 00 00 	st.d	sp[0],r10
8000a192:	c2 08       	rjmp	8000a1d2 <_vfprintf_r+0x1196>
8000a194:	41 09       	lddsp	r9,sp[0x40]
8000a196:	59 f8       	cp.w	r8,31
8000a198:	e0 89 00 16 	brgt	8000a1c4 <_vfprintf_r+0x1188>
8000a19c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a1a0:	f2 cb ff f8 	sub	r11,r9,-8
8000a1a4:	fa e7 00 00 	st.d	sp[0],r6
8000a1a8:	51 0b       	stdsp	sp[0x40],r11
8000a1aa:	fa c6 f9 44 	sub	r6,sp,-1724
8000a1ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a1b2:	fa e6 00 00 	ld.d	r6,sp[0]
8000a1b6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a1ba:	2f f8       	sub	r8,-1
8000a1bc:	14 97       	mov	r7,r10
8000a1be:	fb 48 06 b4 	st.w	sp[1716],r8
8000a1c2:	c0 88       	rjmp	8000a1d2 <_vfprintf_r+0x1196>
8000a1c4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a1c8:	2f 89       	sub	r9,-8
8000a1ca:	fa e7 00 00 	st.d	sp[0],r6
8000a1ce:	51 09       	stdsp	sp[0x40],r9
8000a1d0:	14 97       	mov	r7,r10
8000a1d2:	30 18       	mov	r8,1
8000a1d4:	e0 8f 01 d0 	bral	8000a574 <_vfprintf_r+0x1538>
8000a1d8:	ed b5 00 04 	bld	r5,0x4
8000a1dc:	c1 61       	brne	8000a208 <_vfprintf_r+0x11cc>
8000a1de:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a1e2:	40 3e       	lddsp	lr,sp[0xc]
8000a1e4:	58 0e       	cp.w	lr,0
8000a1e6:	c0 80       	breq	8000a1f6 <_vfprintf_r+0x11ba>
8000a1e8:	10 36       	cp.w	r6,r8
8000a1ea:	c6 74       	brge	8000a2b8 <_vfprintf_r+0x127c>
8000a1ec:	fa cc f9 44 	sub	r12,sp,-1724
8000a1f0:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a1f4:	c8 08       	rjmp	8000a2f4 <_vfprintf_r+0x12b8>
8000a1f6:	ee ca ff ff 	sub	r10,r7,-1
8000a1fa:	10 37       	cp.w	r7,r8
8000a1fc:	c7 f4       	brge	8000a2fa <_vfprintf_r+0x12be>
8000a1fe:	fa cb f9 44 	sub	r11,sp,-1724
8000a202:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a206:	c7 68       	rjmp	8000a2f2 <_vfprintf_r+0x12b6>
8000a208:	ed b5 00 06 	bld	r5,0x6
8000a20c:	c4 a1       	brne	8000a2a0 <_vfprintf_r+0x1264>
8000a20e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a212:	40 3c       	lddsp	r12,sp[0xc]
8000a214:	58 0c       	cp.w	r12,0
8000a216:	c1 d0       	breq	8000a250 <_vfprintf_r+0x1214>
8000a218:	10 36       	cp.w	r6,r8
8000a21a:	c0 64       	brge	8000a226 <_vfprintf_r+0x11ea>
8000a21c:	fa cb f9 44 	sub	r11,sp,-1724
8000a220:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a224:	c1 f8       	rjmp	8000a262 <_vfprintf_r+0x1226>
8000a226:	fa c8 f9 50 	sub	r8,sp,-1712
8000a22a:	1a d8       	st.w	--sp,r8
8000a22c:	fa c8 fa b8 	sub	r8,sp,-1352
8000a230:	1a d8       	st.w	--sp,r8
8000a232:	fa c8 fb b4 	sub	r8,sp,-1100
8000a236:	1a d8       	st.w	--sp,r8
8000a238:	fa c8 f9 40 	sub	r8,sp,-1728
8000a23c:	fa c9 ff b4 	sub	r9,sp,-76
8000a240:	04 9a       	mov	r10,r2
8000a242:	0c 9b       	mov	r11,r6
8000a244:	08 9c       	mov	r12,r4
8000a246:	fe b0 f5 63 	rcall	80008d0c <get_arg>
8000a24a:	2f dd       	sub	sp,-12
8000a24c:	98 18       	ld.sh	r8,r12[0x2]
8000a24e:	c2 68       	rjmp	8000a29a <_vfprintf_r+0x125e>
8000a250:	ee ca ff ff 	sub	r10,r7,-1
8000a254:	10 37       	cp.w	r7,r8
8000a256:	c0 94       	brge	8000a268 <_vfprintf_r+0x122c>
8000a258:	fa c9 f9 44 	sub	r9,sp,-1724
8000a25c:	14 97       	mov	r7,r10
8000a25e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a262:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a266:	c1 a8       	rjmp	8000a29a <_vfprintf_r+0x125e>
8000a268:	41 09       	lddsp	r9,sp[0x40]
8000a26a:	59 f8       	cp.w	r8,31
8000a26c:	e0 89 00 13 	brgt	8000a292 <_vfprintf_r+0x1256>
8000a270:	f2 cb ff fc 	sub	r11,r9,-4
8000a274:	51 0b       	stdsp	sp[0x40],r11
8000a276:	72 09       	ld.w	r9,r9[0x0]
8000a278:	fa c6 f9 44 	sub	r6,sp,-1724
8000a27c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a280:	2f f8       	sub	r8,-1
8000a282:	f7 49 fd 88 	st.w	r11[-632],r9
8000a286:	fb 48 06 b4 	st.w	sp[1716],r8
8000a28a:	14 97       	mov	r7,r10
8000a28c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a290:	c0 58       	rjmp	8000a29a <_vfprintf_r+0x125e>
8000a292:	92 18       	ld.sh	r8,r9[0x2]
8000a294:	14 97       	mov	r7,r10
8000a296:	2f c9       	sub	r9,-4
8000a298:	51 09       	stdsp	sp[0x40],r9
8000a29a:	5c 78       	castu.h	r8
8000a29c:	50 18       	stdsp	sp[0x4],r8
8000a29e:	c4 68       	rjmp	8000a32a <_vfprintf_r+0x12ee>
8000a2a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2a4:	40 3c       	lddsp	r12,sp[0xc]
8000a2a6:	58 0c       	cp.w	r12,0
8000a2a8:	c1 d0       	breq	8000a2e2 <_vfprintf_r+0x12a6>
8000a2aa:	10 36       	cp.w	r6,r8
8000a2ac:	c0 64       	brge	8000a2b8 <_vfprintf_r+0x127c>
8000a2ae:	fa cb f9 44 	sub	r11,sp,-1724
8000a2b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a2b6:	c1 f8       	rjmp	8000a2f4 <_vfprintf_r+0x12b8>
8000a2b8:	fa c8 f9 50 	sub	r8,sp,-1712
8000a2bc:	1a d8       	st.w	--sp,r8
8000a2be:	fa c8 fa b8 	sub	r8,sp,-1352
8000a2c2:	0c 9b       	mov	r11,r6
8000a2c4:	1a d8       	st.w	--sp,r8
8000a2c6:	fa c8 fb b4 	sub	r8,sp,-1100
8000a2ca:	04 9a       	mov	r10,r2
8000a2cc:	1a d8       	st.w	--sp,r8
8000a2ce:	08 9c       	mov	r12,r4
8000a2d0:	fa c8 f9 40 	sub	r8,sp,-1728
8000a2d4:	fa c9 ff b4 	sub	r9,sp,-76
8000a2d8:	fe b0 f5 1a 	rcall	80008d0c <get_arg>
8000a2dc:	2f dd       	sub	sp,-12
8000a2de:	78 0b       	ld.w	r11,r12[0x0]
8000a2e0:	c2 48       	rjmp	8000a328 <_vfprintf_r+0x12ec>
8000a2e2:	ee ca ff ff 	sub	r10,r7,-1
8000a2e6:	10 37       	cp.w	r7,r8
8000a2e8:	c0 94       	brge	8000a2fa <_vfprintf_r+0x12be>
8000a2ea:	fa c9 f9 44 	sub	r9,sp,-1724
8000a2ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a2f2:	14 97       	mov	r7,r10
8000a2f4:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a2f8:	c1 88       	rjmp	8000a328 <_vfprintf_r+0x12ec>
8000a2fa:	41 09       	lddsp	r9,sp[0x40]
8000a2fc:	59 f8       	cp.w	r8,31
8000a2fe:	e0 89 00 11 	brgt	8000a320 <_vfprintf_r+0x12e4>
8000a302:	f2 cb ff fc 	sub	r11,r9,-4
8000a306:	51 0b       	stdsp	sp[0x40],r11
8000a308:	fa c6 f9 44 	sub	r6,sp,-1724
8000a30c:	72 0b       	ld.w	r11,r9[0x0]
8000a30e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a312:	f3 4b fd 88 	st.w	r9[-632],r11
8000a316:	2f f8       	sub	r8,-1
8000a318:	14 97       	mov	r7,r10
8000a31a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a31e:	c0 58       	rjmp	8000a328 <_vfprintf_r+0x12ec>
8000a320:	72 0b       	ld.w	r11,r9[0x0]
8000a322:	14 97       	mov	r7,r10
8000a324:	2f c9       	sub	r9,-4
8000a326:	51 09       	stdsp	sp[0x40],r9
8000a328:	50 1b       	stdsp	sp[0x4],r11
8000a32a:	30 0e       	mov	lr,0
8000a32c:	30 18       	mov	r8,1
8000a32e:	50 0e       	stdsp	sp[0x0],lr
8000a330:	c2 29       	rjmp	8000a574 <_vfprintf_r+0x1538>
8000a332:	50 a7       	stdsp	sp[0x28],r7
8000a334:	50 80       	stdsp	sp[0x20],r0
8000a336:	0c 97       	mov	r7,r6
8000a338:	04 94       	mov	r4,r2
8000a33a:	06 96       	mov	r6,r3
8000a33c:	02 92       	mov	r2,r1
8000a33e:	fe cc b0 16 	sub	r12,pc,-20458
8000a342:	40 93       	lddsp	r3,sp[0x24]
8000a344:	10 90       	mov	r0,r8
8000a346:	40 41       	lddsp	r1,sp[0x10]
8000a348:	50 dc       	stdsp	sp[0x34],r12
8000a34a:	ed b5 00 05 	bld	r5,0x5
8000a34e:	c5 51       	brne	8000a3f8 <_vfprintf_r+0x13bc>
8000a350:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a354:	40 3b       	lddsp	r11,sp[0xc]
8000a356:	58 0b       	cp.w	r11,0
8000a358:	c2 20       	breq	8000a39c <_vfprintf_r+0x1360>
8000a35a:	10 36       	cp.w	r6,r8
8000a35c:	c0 a4       	brge	8000a370 <_vfprintf_r+0x1334>
8000a35e:	fa ca f9 44 	sub	r10,sp,-1724
8000a362:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a366:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a36a:	fa e9 00 00 	st.d	sp[0],r8
8000a36e:	cf 28       	rjmp	8000a552 <_vfprintf_r+0x1516>
8000a370:	fa c8 f9 50 	sub	r8,sp,-1712
8000a374:	1a d8       	st.w	--sp,r8
8000a376:	fa c8 fa b8 	sub	r8,sp,-1352
8000a37a:	04 9a       	mov	r10,r2
8000a37c:	1a d8       	st.w	--sp,r8
8000a37e:	0c 9b       	mov	r11,r6
8000a380:	fa c8 fb b4 	sub	r8,sp,-1100
8000a384:	08 9c       	mov	r12,r4
8000a386:	1a d8       	st.w	--sp,r8
8000a388:	fa c8 f9 40 	sub	r8,sp,-1728
8000a38c:	fa c9 ff b4 	sub	r9,sp,-76
8000a390:	fe b0 f4 be 	rcall	80008d0c <get_arg>
8000a394:	2f dd       	sub	sp,-12
8000a396:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a39a:	c0 c8       	rjmp	8000a3b2 <_vfprintf_r+0x1376>
8000a39c:	ee ca ff ff 	sub	r10,r7,-1
8000a3a0:	10 37       	cp.w	r7,r8
8000a3a2:	c0 b4       	brge	8000a3b8 <_vfprintf_r+0x137c>
8000a3a4:	fa c9 f9 44 	sub	r9,sp,-1724
8000a3a8:	14 97       	mov	r7,r10
8000a3aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a3ae:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a3b2:	fa eb 00 00 	st.d	sp[0],r10
8000a3b6:	cc e8       	rjmp	8000a552 <_vfprintf_r+0x1516>
8000a3b8:	41 09       	lddsp	r9,sp[0x40]
8000a3ba:	59 f8       	cp.w	r8,31
8000a3bc:	e0 89 00 16 	brgt	8000a3e8 <_vfprintf_r+0x13ac>
8000a3c0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a3c4:	f2 cb ff f8 	sub	r11,r9,-8
8000a3c8:	fa e7 00 00 	st.d	sp[0],r6
8000a3cc:	51 0b       	stdsp	sp[0x40],r11
8000a3ce:	fa c6 f9 44 	sub	r6,sp,-1724
8000a3d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a3d6:	fa e6 00 00 	ld.d	r6,sp[0]
8000a3da:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a3de:	2f f8       	sub	r8,-1
8000a3e0:	14 97       	mov	r7,r10
8000a3e2:	fb 48 06 b4 	st.w	sp[1716],r8
8000a3e6:	cb 68       	rjmp	8000a552 <_vfprintf_r+0x1516>
8000a3e8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a3ec:	2f 89       	sub	r9,-8
8000a3ee:	fa e7 00 00 	st.d	sp[0],r6
8000a3f2:	51 09       	stdsp	sp[0x40],r9
8000a3f4:	14 97       	mov	r7,r10
8000a3f6:	ca e8       	rjmp	8000a552 <_vfprintf_r+0x1516>
8000a3f8:	ed b5 00 04 	bld	r5,0x4
8000a3fc:	c1 71       	brne	8000a42a <_vfprintf_r+0x13ee>
8000a3fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a402:	40 3e       	lddsp	lr,sp[0xc]
8000a404:	58 0e       	cp.w	lr,0
8000a406:	c0 80       	breq	8000a416 <_vfprintf_r+0x13da>
8000a408:	10 36       	cp.w	r6,r8
8000a40a:	c6 94       	brge	8000a4dc <_vfprintf_r+0x14a0>
8000a40c:	fa cc f9 44 	sub	r12,sp,-1724
8000a410:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a414:	c8 28       	rjmp	8000a518 <_vfprintf_r+0x14dc>
8000a416:	ee ca ff ff 	sub	r10,r7,-1
8000a41a:	10 37       	cp.w	r7,r8
8000a41c:	e0 84 00 81 	brge	8000a51e <_vfprintf_r+0x14e2>
8000a420:	fa cb f9 44 	sub	r11,sp,-1724
8000a424:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a428:	c7 78       	rjmp	8000a516 <_vfprintf_r+0x14da>
8000a42a:	ed b5 00 06 	bld	r5,0x6
8000a42e:	c4 b1       	brne	8000a4c4 <_vfprintf_r+0x1488>
8000a430:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a434:	40 3c       	lddsp	r12,sp[0xc]
8000a436:	58 0c       	cp.w	r12,0
8000a438:	c1 d0       	breq	8000a472 <_vfprintf_r+0x1436>
8000a43a:	10 36       	cp.w	r6,r8
8000a43c:	c0 64       	brge	8000a448 <_vfprintf_r+0x140c>
8000a43e:	fa cb f9 44 	sub	r11,sp,-1724
8000a442:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a446:	c1 f8       	rjmp	8000a484 <_vfprintf_r+0x1448>
8000a448:	fa c8 f9 50 	sub	r8,sp,-1712
8000a44c:	1a d8       	st.w	--sp,r8
8000a44e:	fa c8 fa b8 	sub	r8,sp,-1352
8000a452:	1a d8       	st.w	--sp,r8
8000a454:	fa c8 fb b4 	sub	r8,sp,-1100
8000a458:	1a d8       	st.w	--sp,r8
8000a45a:	fa c8 f9 40 	sub	r8,sp,-1728
8000a45e:	fa c9 ff b4 	sub	r9,sp,-76
8000a462:	04 9a       	mov	r10,r2
8000a464:	0c 9b       	mov	r11,r6
8000a466:	08 9c       	mov	r12,r4
8000a468:	fe b0 f4 52 	rcall	80008d0c <get_arg>
8000a46c:	2f dd       	sub	sp,-12
8000a46e:	98 18       	ld.sh	r8,r12[0x2]
8000a470:	c2 78       	rjmp	8000a4be <_vfprintf_r+0x1482>
8000a472:	ee ca ff ff 	sub	r10,r7,-1
8000a476:	10 37       	cp.w	r7,r8
8000a478:	c0 a4       	brge	8000a48c <_vfprintf_r+0x1450>
8000a47a:	fa c9 f9 44 	sub	r9,sp,-1724
8000a47e:	14 97       	mov	r7,r10
8000a480:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a484:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a488:	c1 b8       	rjmp	8000a4be <_vfprintf_r+0x1482>
8000a48a:	d7 03       	nop
8000a48c:	41 09       	lddsp	r9,sp[0x40]
8000a48e:	59 f8       	cp.w	r8,31
8000a490:	e0 89 00 13 	brgt	8000a4b6 <_vfprintf_r+0x147a>
8000a494:	f2 cb ff fc 	sub	r11,r9,-4
8000a498:	51 0b       	stdsp	sp[0x40],r11
8000a49a:	72 09       	ld.w	r9,r9[0x0]
8000a49c:	fa c6 f9 44 	sub	r6,sp,-1724
8000a4a0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a4a4:	2f f8       	sub	r8,-1
8000a4a6:	f7 49 fd 88 	st.w	r11[-632],r9
8000a4aa:	fb 48 06 b4 	st.w	sp[1716],r8
8000a4ae:	14 97       	mov	r7,r10
8000a4b0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a4b4:	c0 58       	rjmp	8000a4be <_vfprintf_r+0x1482>
8000a4b6:	92 18       	ld.sh	r8,r9[0x2]
8000a4b8:	14 97       	mov	r7,r10
8000a4ba:	2f c9       	sub	r9,-4
8000a4bc:	51 09       	stdsp	sp[0x40],r9
8000a4be:	5c 78       	castu.h	r8
8000a4c0:	50 18       	stdsp	sp[0x4],r8
8000a4c2:	c4 68       	rjmp	8000a54e <_vfprintf_r+0x1512>
8000a4c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a4c8:	40 3c       	lddsp	r12,sp[0xc]
8000a4ca:	58 0c       	cp.w	r12,0
8000a4cc:	c1 d0       	breq	8000a506 <_vfprintf_r+0x14ca>
8000a4ce:	10 36       	cp.w	r6,r8
8000a4d0:	c0 64       	brge	8000a4dc <_vfprintf_r+0x14a0>
8000a4d2:	fa cb f9 44 	sub	r11,sp,-1724
8000a4d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a4da:	c1 f8       	rjmp	8000a518 <_vfprintf_r+0x14dc>
8000a4dc:	fa c8 f9 50 	sub	r8,sp,-1712
8000a4e0:	1a d8       	st.w	--sp,r8
8000a4e2:	fa c8 fa b8 	sub	r8,sp,-1352
8000a4e6:	0c 9b       	mov	r11,r6
8000a4e8:	1a d8       	st.w	--sp,r8
8000a4ea:	fa c8 fb b4 	sub	r8,sp,-1100
8000a4ee:	04 9a       	mov	r10,r2
8000a4f0:	1a d8       	st.w	--sp,r8
8000a4f2:	08 9c       	mov	r12,r4
8000a4f4:	fa c8 f9 40 	sub	r8,sp,-1728
8000a4f8:	fa c9 ff b4 	sub	r9,sp,-76
8000a4fc:	fe b0 f4 08 	rcall	80008d0c <get_arg>
8000a500:	2f dd       	sub	sp,-12
8000a502:	78 0b       	ld.w	r11,r12[0x0]
8000a504:	c2 48       	rjmp	8000a54c <_vfprintf_r+0x1510>
8000a506:	ee ca ff ff 	sub	r10,r7,-1
8000a50a:	10 37       	cp.w	r7,r8
8000a50c:	c0 94       	brge	8000a51e <_vfprintf_r+0x14e2>
8000a50e:	fa c9 f9 44 	sub	r9,sp,-1724
8000a512:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a516:	14 97       	mov	r7,r10
8000a518:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a51c:	c1 88       	rjmp	8000a54c <_vfprintf_r+0x1510>
8000a51e:	41 09       	lddsp	r9,sp[0x40]
8000a520:	59 f8       	cp.w	r8,31
8000a522:	e0 89 00 11 	brgt	8000a544 <_vfprintf_r+0x1508>
8000a526:	f2 cb ff fc 	sub	r11,r9,-4
8000a52a:	51 0b       	stdsp	sp[0x40],r11
8000a52c:	fa c6 f9 44 	sub	r6,sp,-1724
8000a530:	72 0b       	ld.w	r11,r9[0x0]
8000a532:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a536:	f3 4b fd 88 	st.w	r9[-632],r11
8000a53a:	2f f8       	sub	r8,-1
8000a53c:	14 97       	mov	r7,r10
8000a53e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a542:	c0 58       	rjmp	8000a54c <_vfprintf_r+0x1510>
8000a544:	72 0b       	ld.w	r11,r9[0x0]
8000a546:	14 97       	mov	r7,r10
8000a548:	2f c9       	sub	r9,-4
8000a54a:	51 09       	stdsp	sp[0x40],r9
8000a54c:	50 1b       	stdsp	sp[0x4],r11
8000a54e:	30 0e       	mov	lr,0
8000a550:	50 0e       	stdsp	sp[0x0],lr
8000a552:	40 08       	lddsp	r8,sp[0x0]
8000a554:	40 1c       	lddsp	r12,sp[0x4]
8000a556:	18 48       	or	r8,r12
8000a558:	5f 19       	srne	r9
8000a55a:	0a 98       	mov	r8,r5
8000a55c:	eb e9 00 09 	and	r9,r5,r9
8000a560:	a1 b8       	sbr	r8,0x1
8000a562:	58 09       	cp.w	r9,0
8000a564:	c0 70       	breq	8000a572 <_vfprintf_r+0x1536>
8000a566:	10 95       	mov	r5,r8
8000a568:	fb 60 06 b9 	st.b	sp[1721],r0
8000a56c:	33 08       	mov	r8,48
8000a56e:	fb 68 06 b8 	st.b	sp[1720],r8
8000a572:	30 28       	mov	r8,2
8000a574:	30 09       	mov	r9,0
8000a576:	fb 69 06 bb 	st.b	sp[1723],r9
8000a57a:	0a 99       	mov	r9,r5
8000a57c:	a7 d9       	cbr	r9,0x7
8000a57e:	40 2b       	lddsp	r11,sp[0x8]
8000a580:	40 16       	lddsp	r6,sp[0x4]
8000a582:	58 0b       	cp.w	r11,0
8000a584:	5f 1a       	srne	r10
8000a586:	f2 05 17 40 	movge	r5,r9
8000a58a:	fa c2 f9 78 	sub	r2,sp,-1672
8000a58e:	40 09       	lddsp	r9,sp[0x0]
8000a590:	0c 49       	or	r9,r6
8000a592:	5f 19       	srne	r9
8000a594:	f5 e9 10 09 	or	r9,r10,r9
8000a598:	c5 c0       	breq	8000a650 <_vfprintf_r+0x1614>
8000a59a:	30 19       	mov	r9,1
8000a59c:	f2 08 18 00 	cp.b	r8,r9
8000a5a0:	c0 60       	breq	8000a5ac <_vfprintf_r+0x1570>
8000a5a2:	30 29       	mov	r9,2
8000a5a4:	f2 08 18 00 	cp.b	r8,r9
8000a5a8:	c0 41       	brne	8000a5b0 <_vfprintf_r+0x1574>
8000a5aa:	c3 c8       	rjmp	8000a622 <_vfprintf_r+0x15e6>
8000a5ac:	04 96       	mov	r6,r2
8000a5ae:	c3 08       	rjmp	8000a60e <_vfprintf_r+0x15d2>
8000a5b0:	04 96       	mov	r6,r2
8000a5b2:	fa e8 00 00 	ld.d	r8,sp[0]
8000a5b6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a5ba:	2d 0a       	sub	r10,-48
8000a5bc:	0c fa       	st.b	--r6,r10
8000a5be:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a5c2:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a5c6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a5ca:	18 99       	mov	r9,r12
8000a5cc:	16 98       	mov	r8,r11
8000a5ce:	58 08       	cp.w	r8,0
8000a5d0:	5c 29       	cpc	r9
8000a5d2:	cf 21       	brne	8000a5b6 <_vfprintf_r+0x157a>
8000a5d4:	fa e9 00 00 	st.d	sp[0],r8
8000a5d8:	ed b5 00 00 	bld	r5,0x0
8000a5dc:	c4 51       	brne	8000a666 <_vfprintf_r+0x162a>
8000a5de:	33 09       	mov	r9,48
8000a5e0:	f2 0a 18 00 	cp.b	r10,r9
8000a5e4:	c4 10       	breq	8000a666 <_vfprintf_r+0x162a>
8000a5e6:	0c f9       	st.b	--r6,r9
8000a5e8:	c3 f8       	rjmp	8000a666 <_vfprintf_r+0x162a>
8000a5ea:	fa ea 00 00 	ld.d	r10,sp[0]
8000a5ee:	30 a8       	mov	r8,10
8000a5f0:	30 09       	mov	r9,0
8000a5f2:	e0 a0 1a 19 	rcall	8000da24 <__avr32_umod64>
8000a5f6:	30 a8       	mov	r8,10
8000a5f8:	2d 0a       	sub	r10,-48
8000a5fa:	30 09       	mov	r9,0
8000a5fc:	ac 8a       	st.b	r6[0x0],r10
8000a5fe:	fa ea 00 00 	ld.d	r10,sp[0]
8000a602:	e0 a0 18 df 	rcall	8000d7c0 <__avr32_udiv64>
8000a606:	16 99       	mov	r9,r11
8000a608:	14 98       	mov	r8,r10
8000a60a:	fa e9 00 00 	st.d	sp[0],r8
8000a60e:	20 16       	sub	r6,1
8000a610:	fa ea 00 00 	ld.d	r10,sp[0]
8000a614:	58 9a       	cp.w	r10,9
8000a616:	5c 2b       	cpc	r11
8000a618:	fe 9b ff e9 	brhi	8000a5ea <_vfprintf_r+0x15ae>
8000a61c:	1b f8       	ld.ub	r8,sp[0x7]
8000a61e:	2d 08       	sub	r8,-48
8000a620:	c2 08       	rjmp	8000a660 <_vfprintf_r+0x1624>
8000a622:	04 96       	mov	r6,r2
8000a624:	fa e8 00 00 	ld.d	r8,sp[0]
8000a628:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a62c:	40 de       	lddsp	lr,sp[0x34]
8000a62e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a632:	0c fa       	st.b	--r6,r10
8000a634:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a638:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a63c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a640:	16 99       	mov	r9,r11
8000a642:	14 98       	mov	r8,r10
8000a644:	58 08       	cp.w	r8,0
8000a646:	5c 29       	cpc	r9
8000a648:	cf 01       	brne	8000a628 <_vfprintf_r+0x15ec>
8000a64a:	fa e9 00 00 	st.d	sp[0],r8
8000a64e:	c0 c8       	rjmp	8000a666 <_vfprintf_r+0x162a>
8000a650:	58 08       	cp.w	r8,0
8000a652:	c0 91       	brne	8000a664 <_vfprintf_r+0x1628>
8000a654:	ed b5 00 00 	bld	r5,0x0
8000a658:	c0 61       	brne	8000a664 <_vfprintf_r+0x1628>
8000a65a:	fa c6 f9 79 	sub	r6,sp,-1671
8000a65e:	33 08       	mov	r8,48
8000a660:	ac 88       	st.b	r6[0x0],r8
8000a662:	c0 28       	rjmp	8000a666 <_vfprintf_r+0x162a>
8000a664:	04 96       	mov	r6,r2
8000a666:	0c 12       	sub	r2,r6
8000a668:	c1 c8       	rjmp	8000a6a0 <_vfprintf_r+0x1664>
8000a66a:	50 a7       	stdsp	sp[0x28],r7
8000a66c:	50 80       	stdsp	sp[0x20],r0
8000a66e:	40 93       	lddsp	r3,sp[0x24]
8000a670:	0c 97       	mov	r7,r6
8000a672:	10 90       	mov	r0,r8
8000a674:	04 94       	mov	r4,r2
8000a676:	40 41       	lddsp	r1,sp[0x10]
8000a678:	58 08       	cp.w	r8,0
8000a67a:	e0 80 04 4f 	breq	8000af18 <_vfprintf_r+0x1edc>
8000a67e:	fb 68 06 60 	st.b	sp[1632],r8
8000a682:	30 0c       	mov	r12,0
8000a684:	30 08       	mov	r8,0
8000a686:	30 12       	mov	r2,1
8000a688:	fb 68 06 bb 	st.b	sp[1723],r8
8000a68c:	50 2c       	stdsp	sp[0x8],r12
8000a68e:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a692:	c0 78       	rjmp	8000a6a0 <_vfprintf_r+0x1664>
8000a694:	30 0b       	mov	r11,0
8000a696:	50 2b       	stdsp	sp[0x8],r11
8000a698:	c0 48       	rjmp	8000a6a0 <_vfprintf_r+0x1664>
8000a69a:	40 22       	lddsp	r2,sp[0x8]
8000a69c:	30 0a       	mov	r10,0
8000a69e:	50 2a       	stdsp	sp[0x8],r10
8000a6a0:	40 29       	lddsp	r9,sp[0x8]
8000a6a2:	e4 09 0c 49 	max	r9,r2,r9
8000a6a6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a6aa:	50 39       	stdsp	sp[0xc],r9
8000a6ac:	0a 9e       	mov	lr,r5
8000a6ae:	30 09       	mov	r9,0
8000a6b0:	e2 1e 00 02 	andl	lr,0x2,COH
8000a6b4:	f2 08 18 00 	cp.b	r8,r9
8000a6b8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a6bc:	f7 b8 01 ff 	subne	r8,-1
8000a6c0:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a6c4:	0a 9b       	mov	r11,r5
8000a6c6:	58 0e       	cp.w	lr,0
8000a6c8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a6cc:	f7 bc 01 fe 	subne	r12,-2
8000a6d0:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a6d4:	e2 1b 00 84 	andl	r11,0x84,COH
8000a6d8:	50 fe       	stdsp	sp[0x3c],lr
8000a6da:	50 9b       	stdsp	sp[0x24],r11
8000a6dc:	c4 71       	brne	8000a76a <_vfprintf_r+0x172e>
8000a6de:	40 8a       	lddsp	r10,sp[0x20]
8000a6e0:	40 39       	lddsp	r9,sp[0xc]
8000a6e2:	12 1a       	sub	r10,r9
8000a6e4:	50 4a       	stdsp	sp[0x10],r10
8000a6e6:	58 0a       	cp.w	r10,0
8000a6e8:	e0 89 00 20 	brgt	8000a728 <_vfprintf_r+0x16ec>
8000a6ec:	c3 f8       	rjmp	8000a76a <_vfprintf_r+0x172e>
8000a6ee:	2f 09       	sub	r9,-16
8000a6f0:	2f f8       	sub	r8,-1
8000a6f2:	fe ce b3 b2 	sub	lr,pc,-19534
8000a6f6:	31 0c       	mov	r12,16
8000a6f8:	fb 49 06 90 	st.w	sp[1680],r9
8000a6fc:	87 0e       	st.w	r3[0x0],lr
8000a6fe:	87 1c       	st.w	r3[0x4],r12
8000a700:	fb 48 06 8c 	st.w	sp[1676],r8
8000a704:	58 78       	cp.w	r8,7
8000a706:	e0 89 00 04 	brgt	8000a70e <_vfprintf_r+0x16d2>
8000a70a:	2f 83       	sub	r3,-8
8000a70c:	c0 b8       	rjmp	8000a722 <_vfprintf_r+0x16e6>
8000a70e:	fa ca f9 78 	sub	r10,sp,-1672
8000a712:	02 9b       	mov	r11,r1
8000a714:	08 9c       	mov	r12,r4
8000a716:	fe b0 f4 85 	rcall	80009020 <__sprint_r>
8000a71a:	e0 81 04 10 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a71e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a722:	40 4b       	lddsp	r11,sp[0x10]
8000a724:	21 0b       	sub	r11,16
8000a726:	50 4b       	stdsp	sp[0x10],r11
8000a728:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a72c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a730:	fe ca b3 f0 	sub	r10,pc,-19472
8000a734:	40 4e       	lddsp	lr,sp[0x10]
8000a736:	59 0e       	cp.w	lr,16
8000a738:	fe 99 ff db 	brgt	8000a6ee <_vfprintf_r+0x16b2>
8000a73c:	1c 09       	add	r9,lr
8000a73e:	2f f8       	sub	r8,-1
8000a740:	87 0a       	st.w	r3[0x0],r10
8000a742:	fb 49 06 90 	st.w	sp[1680],r9
8000a746:	87 1e       	st.w	r3[0x4],lr
8000a748:	fb 48 06 8c 	st.w	sp[1676],r8
8000a74c:	58 78       	cp.w	r8,7
8000a74e:	e0 89 00 04 	brgt	8000a756 <_vfprintf_r+0x171a>
8000a752:	2f 83       	sub	r3,-8
8000a754:	c0 b8       	rjmp	8000a76a <_vfprintf_r+0x172e>
8000a756:	fa ca f9 78 	sub	r10,sp,-1672
8000a75a:	02 9b       	mov	r11,r1
8000a75c:	08 9c       	mov	r12,r4
8000a75e:	fe b0 f4 61 	rcall	80009020 <__sprint_r>
8000a762:	e0 81 03 ec 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a766:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a76a:	30 09       	mov	r9,0
8000a76c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a770:	f2 08 18 00 	cp.b	r8,r9
8000a774:	c1 f0       	breq	8000a7b2 <_vfprintf_r+0x1776>
8000a776:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a77a:	fa c9 f9 45 	sub	r9,sp,-1723
8000a77e:	2f f8       	sub	r8,-1
8000a780:	87 09       	st.w	r3[0x0],r9
8000a782:	fb 48 06 90 	st.w	sp[1680],r8
8000a786:	30 19       	mov	r9,1
8000a788:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a78c:	87 19       	st.w	r3[0x4],r9
8000a78e:	2f f8       	sub	r8,-1
8000a790:	fb 48 06 8c 	st.w	sp[1676],r8
8000a794:	58 78       	cp.w	r8,7
8000a796:	e0 89 00 04 	brgt	8000a79e <_vfprintf_r+0x1762>
8000a79a:	2f 83       	sub	r3,-8
8000a79c:	c0 b8       	rjmp	8000a7b2 <_vfprintf_r+0x1776>
8000a79e:	fa ca f9 78 	sub	r10,sp,-1672
8000a7a2:	02 9b       	mov	r11,r1
8000a7a4:	08 9c       	mov	r12,r4
8000a7a6:	fe b0 f4 3d 	rcall	80009020 <__sprint_r>
8000a7aa:	e0 81 03 c8 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a7ae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7b2:	40 fc       	lddsp	r12,sp[0x3c]
8000a7b4:	58 0c       	cp.w	r12,0
8000a7b6:	c1 f0       	breq	8000a7f4 <_vfprintf_r+0x17b8>
8000a7b8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7bc:	fa c9 f9 48 	sub	r9,sp,-1720
8000a7c0:	2f e8       	sub	r8,-2
8000a7c2:	87 09       	st.w	r3[0x0],r9
8000a7c4:	fb 48 06 90 	st.w	sp[1680],r8
8000a7c8:	30 29       	mov	r9,2
8000a7ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7ce:	87 19       	st.w	r3[0x4],r9
8000a7d0:	2f f8       	sub	r8,-1
8000a7d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7d6:	58 78       	cp.w	r8,7
8000a7d8:	e0 89 00 04 	brgt	8000a7e0 <_vfprintf_r+0x17a4>
8000a7dc:	2f 83       	sub	r3,-8
8000a7de:	c0 b8       	rjmp	8000a7f4 <_vfprintf_r+0x17b8>
8000a7e0:	fa ca f9 78 	sub	r10,sp,-1672
8000a7e4:	02 9b       	mov	r11,r1
8000a7e6:	08 9c       	mov	r12,r4
8000a7e8:	fe b0 f4 1c 	rcall	80009020 <__sprint_r>
8000a7ec:	e0 81 03 a7 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a7f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7f4:	40 9b       	lddsp	r11,sp[0x24]
8000a7f6:	e0 4b 00 80 	cp.w	r11,128
8000a7fa:	c4 71       	brne	8000a888 <_vfprintf_r+0x184c>
8000a7fc:	40 8a       	lddsp	r10,sp[0x20]
8000a7fe:	40 39       	lddsp	r9,sp[0xc]
8000a800:	12 1a       	sub	r10,r9
8000a802:	50 4a       	stdsp	sp[0x10],r10
8000a804:	58 0a       	cp.w	r10,0
8000a806:	e0 89 00 20 	brgt	8000a846 <_vfprintf_r+0x180a>
8000a80a:	c3 f8       	rjmp	8000a888 <_vfprintf_r+0x184c>
8000a80c:	2f 09       	sub	r9,-16
8000a80e:	2f f8       	sub	r8,-1
8000a810:	fe ce b4 c0 	sub	lr,pc,-19264
8000a814:	31 0c       	mov	r12,16
8000a816:	fb 49 06 90 	st.w	sp[1680],r9
8000a81a:	87 0e       	st.w	r3[0x0],lr
8000a81c:	87 1c       	st.w	r3[0x4],r12
8000a81e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a822:	58 78       	cp.w	r8,7
8000a824:	e0 89 00 04 	brgt	8000a82c <_vfprintf_r+0x17f0>
8000a828:	2f 83       	sub	r3,-8
8000a82a:	c0 b8       	rjmp	8000a840 <_vfprintf_r+0x1804>
8000a82c:	fa ca f9 78 	sub	r10,sp,-1672
8000a830:	02 9b       	mov	r11,r1
8000a832:	08 9c       	mov	r12,r4
8000a834:	fe b0 f3 f6 	rcall	80009020 <__sprint_r>
8000a838:	e0 81 03 81 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a83c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a840:	40 4b       	lddsp	r11,sp[0x10]
8000a842:	21 0b       	sub	r11,16
8000a844:	50 4b       	stdsp	sp[0x10],r11
8000a846:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a84a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a84e:	fe ca b4 fe 	sub	r10,pc,-19202
8000a852:	40 4e       	lddsp	lr,sp[0x10]
8000a854:	59 0e       	cp.w	lr,16
8000a856:	fe 99 ff db 	brgt	8000a80c <_vfprintf_r+0x17d0>
8000a85a:	1c 09       	add	r9,lr
8000a85c:	2f f8       	sub	r8,-1
8000a85e:	87 0a       	st.w	r3[0x0],r10
8000a860:	fb 49 06 90 	st.w	sp[1680],r9
8000a864:	87 1e       	st.w	r3[0x4],lr
8000a866:	fb 48 06 8c 	st.w	sp[1676],r8
8000a86a:	58 78       	cp.w	r8,7
8000a86c:	e0 89 00 04 	brgt	8000a874 <_vfprintf_r+0x1838>
8000a870:	2f 83       	sub	r3,-8
8000a872:	c0 b8       	rjmp	8000a888 <_vfprintf_r+0x184c>
8000a874:	fa ca f9 78 	sub	r10,sp,-1672
8000a878:	02 9b       	mov	r11,r1
8000a87a:	08 9c       	mov	r12,r4
8000a87c:	fe b0 f3 d2 	rcall	80009020 <__sprint_r>
8000a880:	e0 81 03 5d 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a884:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a888:	40 2c       	lddsp	r12,sp[0x8]
8000a88a:	04 1c       	sub	r12,r2
8000a88c:	50 2c       	stdsp	sp[0x8],r12
8000a88e:	58 0c       	cp.w	r12,0
8000a890:	e0 89 00 20 	brgt	8000a8d0 <_vfprintf_r+0x1894>
8000a894:	c3 f8       	rjmp	8000a912 <_vfprintf_r+0x18d6>
8000a896:	2f 09       	sub	r9,-16
8000a898:	2f f8       	sub	r8,-1
8000a89a:	fe cb b5 4a 	sub	r11,pc,-19126
8000a89e:	31 0a       	mov	r10,16
8000a8a0:	fb 49 06 90 	st.w	sp[1680],r9
8000a8a4:	87 0b       	st.w	r3[0x0],r11
8000a8a6:	87 1a       	st.w	r3[0x4],r10
8000a8a8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8ac:	58 78       	cp.w	r8,7
8000a8ae:	e0 89 00 04 	brgt	8000a8b6 <_vfprintf_r+0x187a>
8000a8b2:	2f 83       	sub	r3,-8
8000a8b4:	c0 b8       	rjmp	8000a8ca <_vfprintf_r+0x188e>
8000a8b6:	fa ca f9 78 	sub	r10,sp,-1672
8000a8ba:	02 9b       	mov	r11,r1
8000a8bc:	08 9c       	mov	r12,r4
8000a8be:	fe b0 f3 b1 	rcall	80009020 <__sprint_r>
8000a8c2:	e0 81 03 3c 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a8c6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8ca:	40 29       	lddsp	r9,sp[0x8]
8000a8cc:	21 09       	sub	r9,16
8000a8ce:	50 29       	stdsp	sp[0x8],r9
8000a8d0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a8d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a8d8:	fe ca b5 88 	sub	r10,pc,-19064
8000a8dc:	40 2e       	lddsp	lr,sp[0x8]
8000a8de:	59 0e       	cp.w	lr,16
8000a8e0:	fe 99 ff db 	brgt	8000a896 <_vfprintf_r+0x185a>
8000a8e4:	1c 09       	add	r9,lr
8000a8e6:	2f f8       	sub	r8,-1
8000a8e8:	87 0a       	st.w	r3[0x0],r10
8000a8ea:	fb 49 06 90 	st.w	sp[1680],r9
8000a8ee:	87 1e       	st.w	r3[0x4],lr
8000a8f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8f4:	58 78       	cp.w	r8,7
8000a8f6:	e0 89 00 04 	brgt	8000a8fe <_vfprintf_r+0x18c2>
8000a8fa:	2f 83       	sub	r3,-8
8000a8fc:	c0 b8       	rjmp	8000a912 <_vfprintf_r+0x18d6>
8000a8fe:	fa ca f9 78 	sub	r10,sp,-1672
8000a902:	02 9b       	mov	r11,r1
8000a904:	08 9c       	mov	r12,r4
8000a906:	fe b0 f3 8d 	rcall	80009020 <__sprint_r>
8000a90a:	e0 81 03 18 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a90e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a912:	ed b5 00 08 	bld	r5,0x8
8000a916:	c0 b0       	breq	8000a92c <_vfprintf_r+0x18f0>
8000a918:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a91c:	87 12       	st.w	r3[0x4],r2
8000a91e:	87 06       	st.w	r3[0x0],r6
8000a920:	f0 02 00 02 	add	r2,r8,r2
8000a924:	fb 42 06 90 	st.w	sp[1680],r2
8000a928:	e0 8f 01 d4 	bral	8000acd0 <_vfprintf_r+0x1c94>
8000a92c:	e0 40 00 65 	cp.w	r0,101
8000a930:	e0 8a 01 d6 	brle	8000acdc <_vfprintf_r+0x1ca0>
8000a934:	30 08       	mov	r8,0
8000a936:	30 09       	mov	r9,0
8000a938:	40 5b       	lddsp	r11,sp[0x14]
8000a93a:	40 7a       	lddsp	r10,sp[0x1c]
8000a93c:	e0 a0 15 3b 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000a940:	c7 90       	breq	8000aa32 <_vfprintf_r+0x19f6>
8000a942:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a946:	fe c9 b6 0a 	sub	r9,pc,-18934
8000a94a:	2f f8       	sub	r8,-1
8000a94c:	87 09       	st.w	r3[0x0],r9
8000a94e:	fb 48 06 90 	st.w	sp[1680],r8
8000a952:	30 19       	mov	r9,1
8000a954:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a958:	87 19       	st.w	r3[0x4],r9
8000a95a:	2f f8       	sub	r8,-1
8000a95c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a960:	58 78       	cp.w	r8,7
8000a962:	e0 89 00 05 	brgt	8000a96c <_vfprintf_r+0x1930>
8000a966:	2f 83       	sub	r3,-8
8000a968:	c0 c8       	rjmp	8000a980 <_vfprintf_r+0x1944>
8000a96a:	d7 03       	nop
8000a96c:	fa ca f9 78 	sub	r10,sp,-1672
8000a970:	02 9b       	mov	r11,r1
8000a972:	08 9c       	mov	r12,r4
8000a974:	fe b0 f3 56 	rcall	80009020 <__sprint_r>
8000a978:	e0 81 02 e1 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a97c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a980:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a984:	40 6c       	lddsp	r12,sp[0x18]
8000a986:	18 38       	cp.w	r8,r12
8000a988:	c0 55       	brlt	8000a992 <_vfprintf_r+0x1956>
8000a98a:	ed b5 00 00 	bld	r5,0x0
8000a98e:	e0 81 02 6b 	brne	8000ae64 <_vfprintf_r+0x1e28>
8000a992:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a996:	2f f8       	sub	r8,-1
8000a998:	40 cb       	lddsp	r11,sp[0x30]
8000a99a:	fb 48 06 90 	st.w	sp[1680],r8
8000a99e:	30 19       	mov	r9,1
8000a9a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9a4:	87 0b       	st.w	r3[0x0],r11
8000a9a6:	2f f8       	sub	r8,-1
8000a9a8:	87 19       	st.w	r3[0x4],r9
8000a9aa:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9ae:	58 78       	cp.w	r8,7
8000a9b0:	e0 89 00 04 	brgt	8000a9b8 <_vfprintf_r+0x197c>
8000a9b4:	2f 83       	sub	r3,-8
8000a9b6:	c0 b8       	rjmp	8000a9cc <_vfprintf_r+0x1990>
8000a9b8:	fa ca f9 78 	sub	r10,sp,-1672
8000a9bc:	02 9b       	mov	r11,r1
8000a9be:	08 9c       	mov	r12,r4
8000a9c0:	fe b0 f3 30 	rcall	80009020 <__sprint_r>
8000a9c4:	e0 81 02 bb 	brne	8000af3a <_vfprintf_r+0x1efe>
8000a9c8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9cc:	40 66       	lddsp	r6,sp[0x18]
8000a9ce:	20 16       	sub	r6,1
8000a9d0:	58 06       	cp.w	r6,0
8000a9d2:	e0 89 00 1d 	brgt	8000aa0c <_vfprintf_r+0x19d0>
8000a9d6:	e0 8f 02 47 	bral	8000ae64 <_vfprintf_r+0x1e28>
8000a9da:	2f 09       	sub	r9,-16
8000a9dc:	2f f8       	sub	r8,-1
8000a9de:	fb 49 06 90 	st.w	sp[1680],r9
8000a9e2:	87 02       	st.w	r3[0x0],r2
8000a9e4:	87 10       	st.w	r3[0x4],r0
8000a9e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9ea:	58 78       	cp.w	r8,7
8000a9ec:	e0 89 00 04 	brgt	8000a9f4 <_vfprintf_r+0x19b8>
8000a9f0:	2f 83       	sub	r3,-8
8000a9f2:	c0 b8       	rjmp	8000aa08 <_vfprintf_r+0x19cc>
8000a9f4:	fa ca f9 78 	sub	r10,sp,-1672
8000a9f8:	02 9b       	mov	r11,r1
8000a9fa:	08 9c       	mov	r12,r4
8000a9fc:	fe b0 f3 12 	rcall	80009020 <__sprint_r>
8000aa00:	e0 81 02 9d 	brne	8000af3a <_vfprintf_r+0x1efe>
8000aa04:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa08:	21 06       	sub	r6,16
8000aa0a:	c0 48       	rjmp	8000aa12 <_vfprintf_r+0x19d6>
8000aa0c:	fe c2 b6 bc 	sub	r2,pc,-18756
8000aa10:	31 00       	mov	r0,16
8000aa12:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa16:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa1a:	fe ca b6 ca 	sub	r10,pc,-18742
8000aa1e:	59 06       	cp.w	r6,16
8000aa20:	fe 99 ff dd 	brgt	8000a9da <_vfprintf_r+0x199e>
8000aa24:	0c 09       	add	r9,r6
8000aa26:	87 0a       	st.w	r3[0x0],r10
8000aa28:	fb 49 06 90 	st.w	sp[1680],r9
8000aa2c:	2f f8       	sub	r8,-1
8000aa2e:	87 16       	st.w	r3[0x4],r6
8000aa30:	c5 39       	rjmp	8000acd6 <_vfprintf_r+0x1c9a>
8000aa32:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000aa36:	58 0a       	cp.w	r10,0
8000aa38:	e0 89 00 92 	brgt	8000ab5c <_vfprintf_r+0x1b20>
8000aa3c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa40:	fe c9 b7 04 	sub	r9,pc,-18684
8000aa44:	2f f8       	sub	r8,-1
8000aa46:	87 09       	st.w	r3[0x0],r9
8000aa48:	fb 48 06 90 	st.w	sp[1680],r8
8000aa4c:	30 19       	mov	r9,1
8000aa4e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa52:	87 19       	st.w	r3[0x4],r9
8000aa54:	2f f8       	sub	r8,-1
8000aa56:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa5a:	58 78       	cp.w	r8,7
8000aa5c:	e0 89 00 04 	brgt	8000aa64 <_vfprintf_r+0x1a28>
8000aa60:	2f 83       	sub	r3,-8
8000aa62:	c0 b8       	rjmp	8000aa78 <_vfprintf_r+0x1a3c>
8000aa64:	fa ca f9 78 	sub	r10,sp,-1672
8000aa68:	02 9b       	mov	r11,r1
8000aa6a:	08 9c       	mov	r12,r4
8000aa6c:	fe b0 f2 da 	rcall	80009020 <__sprint_r>
8000aa70:	e0 81 02 65 	brne	8000af3a <_vfprintf_r+0x1efe>
8000aa74:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa78:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aa7c:	58 08       	cp.w	r8,0
8000aa7e:	c0 81       	brne	8000aa8e <_vfprintf_r+0x1a52>
8000aa80:	40 6a       	lddsp	r10,sp[0x18]
8000aa82:	58 0a       	cp.w	r10,0
8000aa84:	c0 51       	brne	8000aa8e <_vfprintf_r+0x1a52>
8000aa86:	ed b5 00 00 	bld	r5,0x0
8000aa8a:	e0 81 01 ed 	brne	8000ae64 <_vfprintf_r+0x1e28>
8000aa8e:	40 c9       	lddsp	r9,sp[0x30]
8000aa90:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa94:	2f f8       	sub	r8,-1
8000aa96:	87 09       	st.w	r3[0x0],r9
8000aa98:	fb 48 06 90 	st.w	sp[1680],r8
8000aa9c:	30 19       	mov	r9,1
8000aa9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aaa2:	87 19       	st.w	r3[0x4],r9
8000aaa4:	2f f8       	sub	r8,-1
8000aaa6:	fb 48 06 8c 	st.w	sp[1676],r8
8000aaaa:	58 78       	cp.w	r8,7
8000aaac:	e0 89 00 04 	brgt	8000aab4 <_vfprintf_r+0x1a78>
8000aab0:	2f 83       	sub	r3,-8
8000aab2:	c0 b8       	rjmp	8000aac8 <_vfprintf_r+0x1a8c>
8000aab4:	fa ca f9 78 	sub	r10,sp,-1672
8000aab8:	02 9b       	mov	r11,r1
8000aaba:	08 9c       	mov	r12,r4
8000aabc:	fe b0 f2 b2 	rcall	80009020 <__sprint_r>
8000aac0:	e0 81 02 3d 	brne	8000af3a <_vfprintf_r+0x1efe>
8000aac4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aac8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000aacc:	5c 32       	neg	r2
8000aace:	58 02       	cp.w	r2,0
8000aad0:	e0 89 00 1d 	brgt	8000ab0a <_vfprintf_r+0x1ace>
8000aad4:	c3 d8       	rjmp	8000ab4e <_vfprintf_r+0x1b12>
8000aad6:	2f 09       	sub	r9,-16
8000aad8:	2f f8       	sub	r8,-1
8000aada:	31 0e       	mov	lr,16
8000aadc:	fb 49 06 90 	st.w	sp[1680],r9
8000aae0:	87 00       	st.w	r3[0x0],r0
8000aae2:	87 1e       	st.w	r3[0x4],lr
8000aae4:	fb 48 06 8c 	st.w	sp[1676],r8
8000aae8:	58 78       	cp.w	r8,7
8000aaea:	e0 89 00 04 	brgt	8000aaf2 <_vfprintf_r+0x1ab6>
8000aaee:	2f 83       	sub	r3,-8
8000aaf0:	c0 b8       	rjmp	8000ab06 <_vfprintf_r+0x1aca>
8000aaf2:	fa ca f9 78 	sub	r10,sp,-1672
8000aaf6:	02 9b       	mov	r11,r1
8000aaf8:	08 9c       	mov	r12,r4
8000aafa:	fe b0 f2 93 	rcall	80009020 <__sprint_r>
8000aafe:	e0 81 02 1e 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ab02:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab06:	21 02       	sub	r2,16
8000ab08:	c0 38       	rjmp	8000ab0e <_vfprintf_r+0x1ad2>
8000ab0a:	fe c0 b7 ba 	sub	r0,pc,-18502
8000ab0e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab12:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab16:	fe ca b7 c6 	sub	r10,pc,-18490
8000ab1a:	59 02       	cp.w	r2,16
8000ab1c:	fe 99 ff dd 	brgt	8000aad6 <_vfprintf_r+0x1a9a>
8000ab20:	04 09       	add	r9,r2
8000ab22:	2f f8       	sub	r8,-1
8000ab24:	87 0a       	st.w	r3[0x0],r10
8000ab26:	fb 49 06 90 	st.w	sp[1680],r9
8000ab2a:	87 12       	st.w	r3[0x4],r2
8000ab2c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab30:	58 78       	cp.w	r8,7
8000ab32:	e0 89 00 04 	brgt	8000ab3a <_vfprintf_r+0x1afe>
8000ab36:	2f 83       	sub	r3,-8
8000ab38:	c0 b8       	rjmp	8000ab4e <_vfprintf_r+0x1b12>
8000ab3a:	fa ca f9 78 	sub	r10,sp,-1672
8000ab3e:	02 9b       	mov	r11,r1
8000ab40:	08 9c       	mov	r12,r4
8000ab42:	fe b0 f2 6f 	rcall	80009020 <__sprint_r>
8000ab46:	e0 81 01 fa 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ab4a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab4e:	40 6c       	lddsp	r12,sp[0x18]
8000ab50:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab54:	87 06       	st.w	r3[0x0],r6
8000ab56:	87 1c       	st.w	r3[0x4],r12
8000ab58:	18 08       	add	r8,r12
8000ab5a:	cb 98       	rjmp	8000accc <_vfprintf_r+0x1c90>
8000ab5c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab60:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab64:	40 6b       	lddsp	r11,sp[0x18]
8000ab66:	16 3a       	cp.w	r10,r11
8000ab68:	c6 f5       	brlt	8000ac46 <_vfprintf_r+0x1c0a>
8000ab6a:	16 09       	add	r9,r11
8000ab6c:	2f f8       	sub	r8,-1
8000ab6e:	87 06       	st.w	r3[0x0],r6
8000ab70:	fb 49 06 90 	st.w	sp[1680],r9
8000ab74:	87 1b       	st.w	r3[0x4],r11
8000ab76:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab7a:	58 78       	cp.w	r8,7
8000ab7c:	e0 89 00 04 	brgt	8000ab84 <_vfprintf_r+0x1b48>
8000ab80:	2f 83       	sub	r3,-8
8000ab82:	c0 b8       	rjmp	8000ab98 <_vfprintf_r+0x1b5c>
8000ab84:	fa ca f9 78 	sub	r10,sp,-1672
8000ab88:	02 9b       	mov	r11,r1
8000ab8a:	08 9c       	mov	r12,r4
8000ab8c:	fe b0 f2 4a 	rcall	80009020 <__sprint_r>
8000ab90:	e0 81 01 d5 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ab94:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab98:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ab9c:	40 6a       	lddsp	r10,sp[0x18]
8000ab9e:	14 16       	sub	r6,r10
8000aba0:	58 06       	cp.w	r6,0
8000aba2:	e0 89 00 1c 	brgt	8000abda <_vfprintf_r+0x1b9e>
8000aba6:	c3 d8       	rjmp	8000ac20 <_vfprintf_r+0x1be4>
8000aba8:	2f 09       	sub	r9,-16
8000abaa:	2f f8       	sub	r8,-1
8000abac:	fb 49 06 90 	st.w	sp[1680],r9
8000abb0:	87 02       	st.w	r3[0x0],r2
8000abb2:	87 10       	st.w	r3[0x4],r0
8000abb4:	fb 48 06 8c 	st.w	sp[1676],r8
8000abb8:	58 78       	cp.w	r8,7
8000abba:	e0 89 00 04 	brgt	8000abc2 <_vfprintf_r+0x1b86>
8000abbe:	2f 83       	sub	r3,-8
8000abc0:	c0 b8       	rjmp	8000abd6 <_vfprintf_r+0x1b9a>
8000abc2:	fa ca f9 78 	sub	r10,sp,-1672
8000abc6:	02 9b       	mov	r11,r1
8000abc8:	08 9c       	mov	r12,r4
8000abca:	fe b0 f2 2b 	rcall	80009020 <__sprint_r>
8000abce:	e0 81 01 b6 	brne	8000af3a <_vfprintf_r+0x1efe>
8000abd2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abd6:	21 06       	sub	r6,16
8000abd8:	c0 48       	rjmp	8000abe0 <_vfprintf_r+0x1ba4>
8000abda:	fe c2 b8 8a 	sub	r2,pc,-18294
8000abde:	31 00       	mov	r0,16
8000abe0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000abe4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abe8:	fe ca b8 98 	sub	r10,pc,-18280
8000abec:	59 06       	cp.w	r6,16
8000abee:	fe 99 ff dd 	brgt	8000aba8 <_vfprintf_r+0x1b6c>
8000abf2:	0c 09       	add	r9,r6
8000abf4:	2f f8       	sub	r8,-1
8000abf6:	87 0a       	st.w	r3[0x0],r10
8000abf8:	fb 49 06 90 	st.w	sp[1680],r9
8000abfc:	87 16       	st.w	r3[0x4],r6
8000abfe:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac02:	58 78       	cp.w	r8,7
8000ac04:	e0 89 00 04 	brgt	8000ac0c <_vfprintf_r+0x1bd0>
8000ac08:	2f 83       	sub	r3,-8
8000ac0a:	c0 b8       	rjmp	8000ac20 <_vfprintf_r+0x1be4>
8000ac0c:	fa ca f9 78 	sub	r10,sp,-1672
8000ac10:	02 9b       	mov	r11,r1
8000ac12:	08 9c       	mov	r12,r4
8000ac14:	fe b0 f2 06 	rcall	80009020 <__sprint_r>
8000ac18:	e0 81 01 91 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ac1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac20:	ed b5 00 00 	bld	r5,0x0
8000ac24:	e0 81 01 20 	brne	8000ae64 <_vfprintf_r+0x1e28>
8000ac28:	40 c9       	lddsp	r9,sp[0x30]
8000ac2a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac2e:	2f f8       	sub	r8,-1
8000ac30:	87 09       	st.w	r3[0x0],r9
8000ac32:	fb 48 06 90 	st.w	sp[1680],r8
8000ac36:	30 19       	mov	r9,1
8000ac38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac3c:	87 19       	st.w	r3[0x4],r9
8000ac3e:	2f f8       	sub	r8,-1
8000ac40:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac44:	c0 29       	rjmp	8000ae48 <_vfprintf_r+0x1e0c>
8000ac46:	14 09       	add	r9,r10
8000ac48:	2f f8       	sub	r8,-1
8000ac4a:	fb 49 06 90 	st.w	sp[1680],r9
8000ac4e:	87 06       	st.w	r3[0x0],r6
8000ac50:	87 1a       	st.w	r3[0x4],r10
8000ac52:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac56:	58 78       	cp.w	r8,7
8000ac58:	e0 89 00 04 	brgt	8000ac60 <_vfprintf_r+0x1c24>
8000ac5c:	2f 83       	sub	r3,-8
8000ac5e:	c0 b8       	rjmp	8000ac74 <_vfprintf_r+0x1c38>
8000ac60:	fa ca f9 78 	sub	r10,sp,-1672
8000ac64:	02 9b       	mov	r11,r1
8000ac66:	08 9c       	mov	r12,r4
8000ac68:	fe b0 f1 dc 	rcall	80009020 <__sprint_r>
8000ac6c:	e0 81 01 67 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ac70:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac74:	40 c8       	lddsp	r8,sp[0x30]
8000ac76:	87 08       	st.w	r3[0x0],r8
8000ac78:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac7c:	2f f8       	sub	r8,-1
8000ac7e:	30 19       	mov	r9,1
8000ac80:	fb 48 06 90 	st.w	sp[1680],r8
8000ac84:	87 19       	st.w	r3[0x4],r9
8000ac86:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac8a:	2f f8       	sub	r8,-1
8000ac8c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac90:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ac94:	58 78       	cp.w	r8,7
8000ac96:	e0 89 00 04 	brgt	8000ac9e <_vfprintf_r+0x1c62>
8000ac9a:	2f 83       	sub	r3,-8
8000ac9c:	c0 b8       	rjmp	8000acb2 <_vfprintf_r+0x1c76>
8000ac9e:	fa ca f9 78 	sub	r10,sp,-1672
8000aca2:	02 9b       	mov	r11,r1
8000aca4:	08 9c       	mov	r12,r4
8000aca6:	fe b0 f1 bd 	rcall	80009020 <__sprint_r>
8000acaa:	e0 81 01 48 	brne	8000af3a <_vfprintf_r+0x1efe>
8000acae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000acb2:	04 06       	add	r6,r2
8000acb4:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000acb8:	87 06       	st.w	r3[0x0],r6
8000acba:	fa f9 06 90 	ld.w	r9,sp[1680]
8000acbe:	40 66       	lddsp	r6,sp[0x18]
8000acc0:	40 6e       	lddsp	lr,sp[0x18]
8000acc2:	10 16       	sub	r6,r8
8000acc4:	f2 08 01 08 	sub	r8,r9,r8
8000acc8:	87 16       	st.w	r3[0x4],r6
8000acca:	1c 08       	add	r8,lr
8000accc:	fb 48 06 90 	st.w	sp[1680],r8
8000acd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acd4:	2f f8       	sub	r8,-1
8000acd6:	fb 48 06 8c 	st.w	sp[1676],r8
8000acda:	cb 78       	rjmp	8000ae48 <_vfprintf_r+0x1e0c>
8000acdc:	40 6c       	lddsp	r12,sp[0x18]
8000acde:	58 1c       	cp.w	r12,1
8000ace0:	e0 89 00 06 	brgt	8000acec <_vfprintf_r+0x1cb0>
8000ace4:	ed b5 00 00 	bld	r5,0x0
8000ace8:	e0 81 00 85 	brne	8000adf2 <_vfprintf_r+0x1db6>
8000acec:	fa f8 06 90 	ld.w	r8,sp[1680]
8000acf0:	2f f8       	sub	r8,-1
8000acf2:	30 19       	mov	r9,1
8000acf4:	fb 48 06 90 	st.w	sp[1680],r8
8000acf8:	87 06       	st.w	r3[0x0],r6
8000acfa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acfe:	87 19       	st.w	r3[0x4],r9
8000ad00:	2f f8       	sub	r8,-1
8000ad02:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad06:	58 78       	cp.w	r8,7
8000ad08:	e0 89 00 04 	brgt	8000ad10 <_vfprintf_r+0x1cd4>
8000ad0c:	2f 83       	sub	r3,-8
8000ad0e:	c0 b8       	rjmp	8000ad24 <_vfprintf_r+0x1ce8>
8000ad10:	fa ca f9 78 	sub	r10,sp,-1672
8000ad14:	02 9b       	mov	r11,r1
8000ad16:	08 9c       	mov	r12,r4
8000ad18:	fe b0 f1 84 	rcall	80009020 <__sprint_r>
8000ad1c:	e0 81 01 0f 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ad20:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad24:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad28:	2f f8       	sub	r8,-1
8000ad2a:	40 cb       	lddsp	r11,sp[0x30]
8000ad2c:	fb 48 06 90 	st.w	sp[1680],r8
8000ad30:	30 19       	mov	r9,1
8000ad32:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad36:	87 0b       	st.w	r3[0x0],r11
8000ad38:	2f f8       	sub	r8,-1
8000ad3a:	87 19       	st.w	r3[0x4],r9
8000ad3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad40:	58 78       	cp.w	r8,7
8000ad42:	e0 89 00 05 	brgt	8000ad4c <_vfprintf_r+0x1d10>
8000ad46:	2f 83       	sub	r3,-8
8000ad48:	c0 c8       	rjmp	8000ad60 <_vfprintf_r+0x1d24>
8000ad4a:	d7 03       	nop
8000ad4c:	fa ca f9 78 	sub	r10,sp,-1672
8000ad50:	02 9b       	mov	r11,r1
8000ad52:	08 9c       	mov	r12,r4
8000ad54:	fe b0 f1 66 	rcall	80009020 <__sprint_r>
8000ad58:	e0 81 00 f1 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ad5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad60:	30 08       	mov	r8,0
8000ad62:	30 09       	mov	r9,0
8000ad64:	40 5b       	lddsp	r11,sp[0x14]
8000ad66:	40 7a       	lddsp	r10,sp[0x1c]
8000ad68:	e0 a0 13 25 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000ad6c:	40 68       	lddsp	r8,sp[0x18]
8000ad6e:	20 18       	sub	r8,1
8000ad70:	58 0c       	cp.w	r12,0
8000ad72:	c0 d1       	brne	8000ad8c <_vfprintf_r+0x1d50>
8000ad74:	2f f6       	sub	r6,-1
8000ad76:	87 18       	st.w	r3[0x4],r8
8000ad78:	87 06       	st.w	r3[0x0],r6
8000ad7a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ad7e:	10 06       	add	r6,r8
8000ad80:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad84:	fb 46 06 90 	st.w	sp[1680],r6
8000ad88:	2f f8       	sub	r8,-1
8000ad8a:	c3 18       	rjmp	8000adec <_vfprintf_r+0x1db0>
8000ad8c:	10 96       	mov	r6,r8
8000ad8e:	58 08       	cp.w	r8,0
8000ad90:	e0 89 00 1c 	brgt	8000adc8 <_vfprintf_r+0x1d8c>
8000ad94:	c4 b8       	rjmp	8000ae2a <_vfprintf_r+0x1dee>
8000ad96:	2f 09       	sub	r9,-16
8000ad98:	2f f8       	sub	r8,-1
8000ad9a:	fb 49 06 90 	st.w	sp[1680],r9
8000ad9e:	87 02       	st.w	r3[0x0],r2
8000ada0:	87 10       	st.w	r3[0x4],r0
8000ada2:	fb 48 06 8c 	st.w	sp[1676],r8
8000ada6:	58 78       	cp.w	r8,7
8000ada8:	e0 89 00 04 	brgt	8000adb0 <_vfprintf_r+0x1d74>
8000adac:	2f 83       	sub	r3,-8
8000adae:	c0 b8       	rjmp	8000adc4 <_vfprintf_r+0x1d88>
8000adb0:	fa ca f9 78 	sub	r10,sp,-1672
8000adb4:	02 9b       	mov	r11,r1
8000adb6:	08 9c       	mov	r12,r4
8000adb8:	fe b0 f1 34 	rcall	80009020 <__sprint_r>
8000adbc:	e0 81 00 bf 	brne	8000af3a <_vfprintf_r+0x1efe>
8000adc0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adc4:	21 06       	sub	r6,16
8000adc6:	c0 48       	rjmp	8000adce <_vfprintf_r+0x1d92>
8000adc8:	fe c2 ba 78 	sub	r2,pc,-17800
8000adcc:	31 00       	mov	r0,16
8000adce:	fa f9 06 90 	ld.w	r9,sp[1680]
8000add2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000add6:	fe ca ba 86 	sub	r10,pc,-17786
8000adda:	59 06       	cp.w	r6,16
8000addc:	fe 99 ff dd 	brgt	8000ad96 <_vfprintf_r+0x1d5a>
8000ade0:	0c 09       	add	r9,r6
8000ade2:	87 0a       	st.w	r3[0x0],r10
8000ade4:	fb 49 06 90 	st.w	sp[1680],r9
8000ade8:	2f f8       	sub	r8,-1
8000adea:	87 16       	st.w	r3[0x4],r6
8000adec:	fb 48 06 8c 	st.w	sp[1676],r8
8000adf0:	c0 e8       	rjmp	8000ae0c <_vfprintf_r+0x1dd0>
8000adf2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000adf6:	2f f8       	sub	r8,-1
8000adf8:	30 19       	mov	r9,1
8000adfa:	fb 48 06 90 	st.w	sp[1680],r8
8000adfe:	87 06       	st.w	r3[0x0],r6
8000ae00:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae04:	87 19       	st.w	r3[0x4],r9
8000ae06:	2f f8       	sub	r8,-1
8000ae08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae0c:	58 78       	cp.w	r8,7
8000ae0e:	e0 89 00 04 	brgt	8000ae16 <_vfprintf_r+0x1dda>
8000ae12:	2f 83       	sub	r3,-8
8000ae14:	c0 b8       	rjmp	8000ae2a <_vfprintf_r+0x1dee>
8000ae16:	fa ca f9 78 	sub	r10,sp,-1672
8000ae1a:	02 9b       	mov	r11,r1
8000ae1c:	08 9c       	mov	r12,r4
8000ae1e:	fe b0 f1 01 	rcall	80009020 <__sprint_r>
8000ae22:	e0 81 00 8c 	brne	8000af3a <_vfprintf_r+0x1efe>
8000ae26:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae2a:	40 ea       	lddsp	r10,sp[0x38]
8000ae2c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae30:	14 08       	add	r8,r10
8000ae32:	fa c9 f9 64 	sub	r9,sp,-1692
8000ae36:	fb 48 06 90 	st.w	sp[1680],r8
8000ae3a:	87 1a       	st.w	r3[0x4],r10
8000ae3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae40:	87 09       	st.w	r3[0x0],r9
8000ae42:	2f f8       	sub	r8,-1
8000ae44:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae48:	58 78       	cp.w	r8,7
8000ae4a:	e0 89 00 04 	brgt	8000ae52 <_vfprintf_r+0x1e16>
8000ae4e:	2f 83       	sub	r3,-8
8000ae50:	c0 a8       	rjmp	8000ae64 <_vfprintf_r+0x1e28>
8000ae52:	fa ca f9 78 	sub	r10,sp,-1672
8000ae56:	02 9b       	mov	r11,r1
8000ae58:	08 9c       	mov	r12,r4
8000ae5a:	fe b0 f0 e3 	rcall	80009020 <__sprint_r>
8000ae5e:	c6 e1       	brne	8000af3a <_vfprintf_r+0x1efe>
8000ae60:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae64:	e2 15 00 04 	andl	r5,0x4,COH
8000ae68:	c3 f0       	breq	8000aee6 <_vfprintf_r+0x1eaa>
8000ae6a:	40 86       	lddsp	r6,sp[0x20]
8000ae6c:	40 39       	lddsp	r9,sp[0xc]
8000ae6e:	12 16       	sub	r6,r9
8000ae70:	58 06       	cp.w	r6,0
8000ae72:	e0 89 00 1a 	brgt	8000aea6 <_vfprintf_r+0x1e6a>
8000ae76:	c3 88       	rjmp	8000aee6 <_vfprintf_r+0x1eaa>
8000ae78:	2f 09       	sub	r9,-16
8000ae7a:	2f f8       	sub	r8,-1
8000ae7c:	fb 49 06 90 	st.w	sp[1680],r9
8000ae80:	87 05       	st.w	r3[0x0],r5
8000ae82:	87 12       	st.w	r3[0x4],r2
8000ae84:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae88:	58 78       	cp.w	r8,7
8000ae8a:	e0 89 00 04 	brgt	8000ae92 <_vfprintf_r+0x1e56>
8000ae8e:	2f 83       	sub	r3,-8
8000ae90:	c0 98       	rjmp	8000aea2 <_vfprintf_r+0x1e66>
8000ae92:	00 9a       	mov	r10,r0
8000ae94:	02 9b       	mov	r11,r1
8000ae96:	08 9c       	mov	r12,r4
8000ae98:	fe b0 f0 c4 	rcall	80009020 <__sprint_r>
8000ae9c:	c4 f1       	brne	8000af3a <_vfprintf_r+0x1efe>
8000ae9e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aea2:	21 06       	sub	r6,16
8000aea4:	c0 68       	rjmp	8000aeb0 <_vfprintf_r+0x1e74>
8000aea6:	fe c5 bb 66 	sub	r5,pc,-17562
8000aeaa:	31 02       	mov	r2,16
8000aeac:	fa c0 f9 78 	sub	r0,sp,-1672
8000aeb0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aeb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aeb8:	fe ca bb 78 	sub	r10,pc,-17544
8000aebc:	59 06       	cp.w	r6,16
8000aebe:	fe 99 ff dd 	brgt	8000ae78 <_vfprintf_r+0x1e3c>
8000aec2:	0c 09       	add	r9,r6
8000aec4:	2f f8       	sub	r8,-1
8000aec6:	87 0a       	st.w	r3[0x0],r10
8000aec8:	87 16       	st.w	r3[0x4],r6
8000aeca:	fb 49 06 90 	st.w	sp[1680],r9
8000aece:	fb 48 06 8c 	st.w	sp[1676],r8
8000aed2:	58 78       	cp.w	r8,7
8000aed4:	e0 8a 00 09 	brle	8000aee6 <_vfprintf_r+0x1eaa>
8000aed8:	fa ca f9 78 	sub	r10,sp,-1672
8000aedc:	02 9b       	mov	r11,r1
8000aede:	08 9c       	mov	r12,r4
8000aee0:	fe b0 f0 a0 	rcall	80009020 <__sprint_r>
8000aee4:	c2 b1       	brne	8000af3a <_vfprintf_r+0x1efe>
8000aee6:	40 bc       	lddsp	r12,sp[0x2c]
8000aee8:	40 36       	lddsp	r6,sp[0xc]
8000aeea:	40 8e       	lddsp	lr,sp[0x20]
8000aeec:	ec 0e 0c 48 	max	r8,r6,lr
8000aef0:	10 0c       	add	r12,r8
8000aef2:	50 bc       	stdsp	sp[0x2c],r12
8000aef4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aef8:	58 08       	cp.w	r8,0
8000aefa:	c0 80       	breq	8000af0a <_vfprintf_r+0x1ece>
8000aefc:	fa ca f9 78 	sub	r10,sp,-1672
8000af00:	02 9b       	mov	r11,r1
8000af02:	08 9c       	mov	r12,r4
8000af04:	fe b0 f0 8e 	rcall	80009020 <__sprint_r>
8000af08:	c1 91       	brne	8000af3a <_vfprintf_r+0x1efe>
8000af0a:	30 0b       	mov	r11,0
8000af0c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af10:	fb 4b 06 8c 	st.w	sp[1676],r11
8000af14:	fe 9f f1 22 	bral	80009158 <_vfprintf_r+0x11c>
8000af18:	08 95       	mov	r5,r4
8000af1a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af1e:	58 08       	cp.w	r8,0
8000af20:	c0 80       	breq	8000af30 <_vfprintf_r+0x1ef4>
8000af22:	08 9c       	mov	r12,r4
8000af24:	fa ca f9 78 	sub	r10,sp,-1672
8000af28:	02 9b       	mov	r11,r1
8000af2a:	fe b0 f0 7b 	rcall	80009020 <__sprint_r>
8000af2e:	c0 61       	brne	8000af3a <_vfprintf_r+0x1efe>
8000af30:	30 08       	mov	r8,0
8000af32:	fb 48 06 8c 	st.w	sp[1676],r8
8000af36:	c0 28       	rjmp	8000af3a <_vfprintf_r+0x1efe>
8000af38:	40 41       	lddsp	r1,sp[0x10]
8000af3a:	82 68       	ld.sh	r8,r1[0xc]
8000af3c:	ed b8 00 06 	bld	r8,0x6
8000af40:	c0 31       	brne	8000af46 <_vfprintf_r+0x1f0a>
8000af42:	3f fa       	mov	r10,-1
8000af44:	50 ba       	stdsp	sp[0x2c],r10
8000af46:	40 bc       	lddsp	r12,sp[0x2c]
8000af48:	fe 3d f9 44 	sub	sp,-1724
8000af4c:	d8 32       	popm	r0-r7,pc
8000af4e:	d7 03       	nop

8000af50 <__swsetup_r>:
8000af50:	d4 21       	pushm	r4-r7,lr
8000af52:	e0 68 0a 54 	mov	r8,2644
8000af56:	18 96       	mov	r6,r12
8000af58:	16 97       	mov	r7,r11
8000af5a:	70 0c       	ld.w	r12,r8[0x0]
8000af5c:	58 0c       	cp.w	r12,0
8000af5e:	c0 60       	breq	8000af6a <__swsetup_r+0x1a>
8000af60:	78 68       	ld.w	r8,r12[0x18]
8000af62:	58 08       	cp.w	r8,0
8000af64:	c0 31       	brne	8000af6a <__swsetup_r+0x1a>
8000af66:	e0 a0 07 bf 	rcall	8000bee4 <__sinit>
8000af6a:	fe c8 ba fa 	sub	r8,pc,-17670
8000af6e:	10 37       	cp.w	r7,r8
8000af70:	c0 61       	brne	8000af7c <__swsetup_r+0x2c>
8000af72:	e0 68 0a 54 	mov	r8,2644
8000af76:	70 08       	ld.w	r8,r8[0x0]
8000af78:	70 07       	ld.w	r7,r8[0x0]
8000af7a:	c1 28       	rjmp	8000af9e <__swsetup_r+0x4e>
8000af7c:	fe c8 ba ec 	sub	r8,pc,-17684
8000af80:	10 37       	cp.w	r7,r8
8000af82:	c0 61       	brne	8000af8e <__swsetup_r+0x3e>
8000af84:	e0 68 0a 54 	mov	r8,2644
8000af88:	70 08       	ld.w	r8,r8[0x0]
8000af8a:	70 17       	ld.w	r7,r8[0x4]
8000af8c:	c0 98       	rjmp	8000af9e <__swsetup_r+0x4e>
8000af8e:	fe c8 ba de 	sub	r8,pc,-17698
8000af92:	10 37       	cp.w	r7,r8
8000af94:	c0 51       	brne	8000af9e <__swsetup_r+0x4e>
8000af96:	e0 68 0a 54 	mov	r8,2644
8000af9a:	70 08       	ld.w	r8,r8[0x0]
8000af9c:	70 27       	ld.w	r7,r8[0x8]
8000af9e:	8e 68       	ld.sh	r8,r7[0xc]
8000afa0:	ed b8 00 03 	bld	r8,0x3
8000afa4:	c1 e0       	breq	8000afe0 <__swsetup_r+0x90>
8000afa6:	ed b8 00 04 	bld	r8,0x4
8000afaa:	c3 e1       	brne	8000b026 <__swsetup_r+0xd6>
8000afac:	ed b8 00 02 	bld	r8,0x2
8000afb0:	c1 51       	brne	8000afda <__swsetup_r+0x8a>
8000afb2:	6e db       	ld.w	r11,r7[0x34]
8000afb4:	58 0b       	cp.w	r11,0
8000afb6:	c0 a0       	breq	8000afca <__swsetup_r+0x7a>
8000afb8:	ee c8 ff bc 	sub	r8,r7,-68
8000afbc:	10 3b       	cp.w	r11,r8
8000afbe:	c0 40       	breq	8000afc6 <__swsetup_r+0x76>
8000afc0:	0c 9c       	mov	r12,r6
8000afc2:	e0 a0 08 2b 	rcall	8000c018 <_free_r>
8000afc6:	30 08       	mov	r8,0
8000afc8:	8f d8       	st.w	r7[0x34],r8
8000afca:	8e 68       	ld.sh	r8,r7[0xc]
8000afcc:	e0 18 ff db 	andl	r8,0xffdb
8000afd0:	ae 68       	st.h	r7[0xc],r8
8000afd2:	30 08       	mov	r8,0
8000afd4:	8f 18       	st.w	r7[0x4],r8
8000afd6:	6e 48       	ld.w	r8,r7[0x10]
8000afd8:	8f 08       	st.w	r7[0x0],r8
8000afda:	8e 68       	ld.sh	r8,r7[0xc]
8000afdc:	a3 b8       	sbr	r8,0x3
8000afde:	ae 68       	st.h	r7[0xc],r8
8000afe0:	6e 48       	ld.w	r8,r7[0x10]
8000afe2:	58 08       	cp.w	r8,0
8000afe4:	c0 b1       	brne	8000affa <__swsetup_r+0xaa>
8000afe6:	8e 68       	ld.sh	r8,r7[0xc]
8000afe8:	e2 18 02 80 	andl	r8,0x280,COH
8000afec:	e0 48 02 00 	cp.w	r8,512
8000aff0:	c0 50       	breq	8000affa <__swsetup_r+0xaa>
8000aff2:	0c 9c       	mov	r12,r6
8000aff4:	0e 9b       	mov	r11,r7
8000aff6:	e0 a0 0a 4b 	rcall	8000c48c <__smakebuf_r>
8000affa:	8e 69       	ld.sh	r9,r7[0xc]
8000affc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000b000:	c0 70       	breq	8000b00e <__swsetup_r+0xbe>
8000b002:	30 08       	mov	r8,0
8000b004:	8f 28       	st.w	r7[0x8],r8
8000b006:	6e 58       	ld.w	r8,r7[0x14]
8000b008:	5c 38       	neg	r8
8000b00a:	8f 68       	st.w	r7[0x18],r8
8000b00c:	c0 68       	rjmp	8000b018 <__swsetup_r+0xc8>
8000b00e:	ed b9 00 01 	bld	r9,0x1
8000b012:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000b016:	8f 28       	st.w	r7[0x8],r8
8000b018:	6e 48       	ld.w	r8,r7[0x10]
8000b01a:	58 08       	cp.w	r8,0
8000b01c:	c0 61       	brne	8000b028 <__swsetup_r+0xd8>
8000b01e:	8e 68       	ld.sh	r8,r7[0xc]
8000b020:	ed b8 00 07 	bld	r8,0x7
8000b024:	c0 21       	brne	8000b028 <__swsetup_r+0xd8>
8000b026:	dc 2a       	popm	r4-r7,pc,r12=-1
8000b028:	d8 2a       	popm	r4-r7,pc,r12=0
8000b02a:	d7 03       	nop

8000b02c <quorem>:
8000b02c:	d4 31       	pushm	r0-r7,lr
8000b02e:	20 2d       	sub	sp,8
8000b030:	18 97       	mov	r7,r12
8000b032:	78 48       	ld.w	r8,r12[0x10]
8000b034:	76 46       	ld.w	r6,r11[0x10]
8000b036:	0c 38       	cp.w	r8,r6
8000b038:	c0 34       	brge	8000b03e <quorem+0x12>
8000b03a:	30 0c       	mov	r12,0
8000b03c:	c8 58       	rjmp	8000b146 <quorem+0x11a>
8000b03e:	ec c2 ff fc 	sub	r2,r6,-4
8000b042:	f6 c3 ff ec 	sub	r3,r11,-20
8000b046:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000b04a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000b04e:	2f f9       	sub	r9,-1
8000b050:	20 16       	sub	r6,1
8000b052:	f8 09 0d 08 	divu	r8,r12,r9
8000b056:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000b05a:	ee c4 ff ec 	sub	r4,r7,-20
8000b05e:	10 95       	mov	r5,r8
8000b060:	58 08       	cp.w	r8,0
8000b062:	c4 10       	breq	8000b0e4 <quorem+0xb8>
8000b064:	30 09       	mov	r9,0
8000b066:	06 9a       	mov	r10,r3
8000b068:	08 98       	mov	r8,r4
8000b06a:	12 91       	mov	r1,r9
8000b06c:	50 0b       	stdsp	sp[0x0],r11
8000b06e:	70 0e       	ld.w	lr,r8[0x0]
8000b070:	b1 8e       	lsr	lr,0x10
8000b072:	50 1e       	stdsp	sp[0x4],lr
8000b074:	15 0e       	ld.w	lr,r10++
8000b076:	fc 00 16 10 	lsr	r0,lr,0x10
8000b07a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b07e:	ea 0e 03 41 	mac	r1,r5,lr
8000b082:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000b086:	b1 81       	lsr	r1,0x10
8000b088:	40 1b       	lddsp	r11,sp[0x4]
8000b08a:	ea 00 02 40 	mul	r0,r5,r0
8000b08e:	e2 00 00 00 	add	r0,r1,r0
8000b092:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000b096:	02 1b       	sub	r11,r1
8000b098:	50 1b       	stdsp	sp[0x4],r11
8000b09a:	70 0b       	ld.w	r11,r8[0x0]
8000b09c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000b0a0:	02 09       	add	r9,r1
8000b0a2:	f2 0e 01 0e 	sub	lr,r9,lr
8000b0a6:	b0 1e       	st.h	r8[0x2],lr
8000b0a8:	fc 09 14 10 	asr	r9,lr,0x10
8000b0ac:	40 1e       	lddsp	lr,sp[0x4]
8000b0ae:	fc 09 00 09 	add	r9,lr,r9
8000b0b2:	b0 09       	st.h	r8[0x0],r9
8000b0b4:	e0 01 16 10 	lsr	r1,r0,0x10
8000b0b8:	2f c8       	sub	r8,-4
8000b0ba:	b1 49       	asr	r9,0x10
8000b0bc:	04 3a       	cp.w	r10,r2
8000b0be:	fe 98 ff d8 	brls	8000b06e <quorem+0x42>
8000b0c2:	40 0b       	lddsp	r11,sp[0x0]
8000b0c4:	58 0c       	cp.w	r12,0
8000b0c6:	c0 f1       	brne	8000b0e4 <quorem+0xb8>
8000b0c8:	ec c8 ff fb 	sub	r8,r6,-5
8000b0cc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b0d0:	c0 28       	rjmp	8000b0d4 <quorem+0xa8>
8000b0d2:	20 16       	sub	r6,1
8000b0d4:	20 48       	sub	r8,4
8000b0d6:	08 38       	cp.w	r8,r4
8000b0d8:	e0 88 00 05 	brls	8000b0e2 <quorem+0xb6>
8000b0dc:	70 09       	ld.w	r9,r8[0x0]
8000b0de:	58 09       	cp.w	r9,0
8000b0e0:	cf 90       	breq	8000b0d2 <quorem+0xa6>
8000b0e2:	8f 46       	st.w	r7[0x10],r6
8000b0e4:	0e 9c       	mov	r12,r7
8000b0e6:	e0 a0 0a d2 	rcall	8000c68a <__mcmp>
8000b0ea:	c2 d5       	brlt	8000b144 <quorem+0x118>
8000b0ec:	2f f5       	sub	r5,-1
8000b0ee:	08 98       	mov	r8,r4
8000b0f0:	30 09       	mov	r9,0
8000b0f2:	07 0b       	ld.w	r11,r3++
8000b0f4:	f6 0a 16 10 	lsr	r10,r11,0x10
8000b0f8:	70 0c       	ld.w	r12,r8[0x0]
8000b0fa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b0fe:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b102:	14 1e       	sub	lr,r10
8000b104:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b108:	16 1a       	sub	r10,r11
8000b10a:	12 0a       	add	r10,r9
8000b10c:	b0 1a       	st.h	r8[0x2],r10
8000b10e:	b1 4a       	asr	r10,0x10
8000b110:	fc 0a 00 09 	add	r9,lr,r10
8000b114:	b0 09       	st.h	r8[0x0],r9
8000b116:	2f c8       	sub	r8,-4
8000b118:	b1 49       	asr	r9,0x10
8000b11a:	04 33       	cp.w	r3,r2
8000b11c:	fe 98 ff eb 	brls	8000b0f2 <quorem+0xc6>
8000b120:	ec c8 ff fb 	sub	r8,r6,-5
8000b124:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b128:	58 09       	cp.w	r9,0
8000b12a:	c0 d1       	brne	8000b144 <quorem+0x118>
8000b12c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b130:	c0 28       	rjmp	8000b134 <quorem+0x108>
8000b132:	20 16       	sub	r6,1
8000b134:	20 48       	sub	r8,4
8000b136:	08 38       	cp.w	r8,r4
8000b138:	e0 88 00 05 	brls	8000b142 <quorem+0x116>
8000b13c:	70 09       	ld.w	r9,r8[0x0]
8000b13e:	58 09       	cp.w	r9,0
8000b140:	cf 90       	breq	8000b132 <quorem+0x106>
8000b142:	8f 46       	st.w	r7[0x10],r6
8000b144:	0a 9c       	mov	r12,r5
8000b146:	2f ed       	sub	sp,-8
8000b148:	d8 32       	popm	r0-r7,pc
8000b14a:	d7 03       	nop

8000b14c <_dtoa_r>:
8000b14c:	d4 31       	pushm	r0-r7,lr
8000b14e:	21 ad       	sub	sp,104
8000b150:	fa c4 ff 74 	sub	r4,sp,-140
8000b154:	18 97       	mov	r7,r12
8000b156:	16 95       	mov	r5,r11
8000b158:	68 2c       	ld.w	r12,r4[0x8]
8000b15a:	50 c9       	stdsp	sp[0x30],r9
8000b15c:	68 16       	ld.w	r6,r4[0x4]
8000b15e:	68 09       	ld.w	r9,r4[0x0]
8000b160:	50 e8       	stdsp	sp[0x38],r8
8000b162:	14 94       	mov	r4,r10
8000b164:	51 2c       	stdsp	sp[0x48],r12
8000b166:	fa e5 00 08 	st.d	sp[8],r4
8000b16a:	51 59       	stdsp	sp[0x54],r9
8000b16c:	6e 95       	ld.w	r5,r7[0x24]
8000b16e:	58 05       	cp.w	r5,0
8000b170:	c0 91       	brne	8000b182 <_dtoa_r+0x36>
8000b172:	31 0c       	mov	r12,16
8000b174:	fe b0 e8 e2 	rcall	80008338 <malloc>
8000b178:	99 35       	st.w	r12[0xc],r5
8000b17a:	8f 9c       	st.w	r7[0x24],r12
8000b17c:	99 15       	st.w	r12[0x4],r5
8000b17e:	99 25       	st.w	r12[0x8],r5
8000b180:	99 05       	st.w	r12[0x0],r5
8000b182:	6e 99       	ld.w	r9,r7[0x24]
8000b184:	72 08       	ld.w	r8,r9[0x0]
8000b186:	58 08       	cp.w	r8,0
8000b188:	c0 f0       	breq	8000b1a6 <_dtoa_r+0x5a>
8000b18a:	72 1a       	ld.w	r10,r9[0x4]
8000b18c:	91 1a       	st.w	r8[0x4],r10
8000b18e:	30 1a       	mov	r10,1
8000b190:	72 19       	ld.w	r9,r9[0x4]
8000b192:	f4 09 09 49 	lsl	r9,r10,r9
8000b196:	10 9b       	mov	r11,r8
8000b198:	91 29       	st.w	r8[0x8],r9
8000b19a:	0e 9c       	mov	r12,r7
8000b19c:	e0 a0 0a 90 	rcall	8000c6bc <_Bfree>
8000b1a0:	6e 98       	ld.w	r8,r7[0x24]
8000b1a2:	30 09       	mov	r9,0
8000b1a4:	91 09       	st.w	r8[0x0],r9
8000b1a6:	40 28       	lddsp	r8,sp[0x8]
8000b1a8:	10 94       	mov	r4,r8
8000b1aa:	58 08       	cp.w	r8,0
8000b1ac:	c0 64       	brge	8000b1b8 <_dtoa_r+0x6c>
8000b1ae:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b1b2:	50 28       	stdsp	sp[0x8],r8
8000b1b4:	30 18       	mov	r8,1
8000b1b6:	c0 28       	rjmp	8000b1ba <_dtoa_r+0x6e>
8000b1b8:	30 08       	mov	r8,0
8000b1ba:	8d 08       	st.w	r6[0x0],r8
8000b1bc:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b1c0:	40 26       	lddsp	r6,sp[0x8]
8000b1c2:	0c 98       	mov	r8,r6
8000b1c4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b1c8:	18 38       	cp.w	r8,r12
8000b1ca:	c2 01       	brne	8000b20a <_dtoa_r+0xbe>
8000b1cc:	e0 68 27 0f 	mov	r8,9999
8000b1d0:	41 5b       	lddsp	r11,sp[0x54]
8000b1d2:	97 08       	st.w	r11[0x0],r8
8000b1d4:	40 3a       	lddsp	r10,sp[0xc]
8000b1d6:	58 0a       	cp.w	r10,0
8000b1d8:	c0 71       	brne	8000b1e6 <_dtoa_r+0x9a>
8000b1da:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b1de:	c0 41       	brne	8000b1e6 <_dtoa_r+0x9a>
8000b1e0:	fe cc bd 80 	sub	r12,pc,-17024
8000b1e4:	c0 38       	rjmp	8000b1ea <_dtoa_r+0x9e>
8000b1e6:	fe cc bd 7a 	sub	r12,pc,-17030
8000b1ea:	41 29       	lddsp	r9,sp[0x48]
8000b1ec:	58 09       	cp.w	r9,0
8000b1ee:	e0 80 05 9a 	breq	8000bd22 <_dtoa_r+0xbd6>
8000b1f2:	f8 c8 ff fd 	sub	r8,r12,-3
8000b1f6:	f8 c9 ff f8 	sub	r9,r12,-8
8000b1fa:	11 8b       	ld.ub	r11,r8[0x0]
8000b1fc:	30 0a       	mov	r10,0
8000b1fe:	41 25       	lddsp	r5,sp[0x48]
8000b200:	f4 0b 18 00 	cp.b	r11,r10
8000b204:	f2 08 17 10 	movne	r8,r9
8000b208:	c1 68       	rjmp	8000b234 <_dtoa_r+0xe8>
8000b20a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b20e:	30 08       	mov	r8,0
8000b210:	fa eb 00 3c 	st.d	sp[60],r10
8000b214:	30 09       	mov	r9,0
8000b216:	e0 a0 10 ce 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000b21a:	c1 00       	breq	8000b23a <_dtoa_r+0xee>
8000b21c:	30 18       	mov	r8,1
8000b21e:	41 5a       	lddsp	r10,sp[0x54]
8000b220:	95 08       	st.w	r10[0x0],r8
8000b222:	fe cc be e6 	sub	r12,pc,-16666
8000b226:	41 29       	lddsp	r9,sp[0x48]
8000b228:	f8 08 00 08 	add	r8,r12,r8
8000b22c:	58 09       	cp.w	r9,0
8000b22e:	e0 80 05 7a 	breq	8000bd22 <_dtoa_r+0xbd6>
8000b232:	12 95       	mov	r5,r9
8000b234:	8b 08       	st.w	r5[0x0],r8
8000b236:	e0 8f 05 76 	bral	8000bd22 <_dtoa_r+0xbd6>
8000b23a:	fa c8 ff 9c 	sub	r8,sp,-100
8000b23e:	fa c9 ff a0 	sub	r9,sp,-96
8000b242:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b246:	0e 9c       	mov	r12,r7
8000b248:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b24c:	e0 a0 0a 8a 	rcall	8000c760 <__d2b>
8000b250:	18 93       	mov	r3,r12
8000b252:	58 05       	cp.w	r5,0
8000b254:	c0 d0       	breq	8000b26e <_dtoa_r+0x122>
8000b256:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b25a:	30 04       	mov	r4,0
8000b25c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b260:	ea c5 03 ff 	sub	r5,r5,1023
8000b264:	10 9b       	mov	r11,r8
8000b266:	51 74       	stdsp	sp[0x5c],r4
8000b268:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b26c:	c2 58       	rjmp	8000b2b6 <_dtoa_r+0x16a>
8000b26e:	41 88       	lddsp	r8,sp[0x60]
8000b270:	41 9c       	lddsp	r12,sp[0x64]
8000b272:	10 0c       	add	r12,r8
8000b274:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b278:	e0 45 00 20 	cp.w	r5,32
8000b27c:	e0 8a 00 0e 	brle	8000b298 <_dtoa_r+0x14c>
8000b280:	f8 cc fb ee 	sub	r12,r12,-1042
8000b284:	40 3b       	lddsp	r11,sp[0xc]
8000b286:	ea 08 11 40 	rsub	r8,r5,64
8000b28a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b28e:	ec 08 09 46 	lsl	r6,r6,r8
8000b292:	0c 4c       	or	r12,r6
8000b294:	c0 78       	rjmp	8000b2a2 <_dtoa_r+0x156>
8000b296:	d7 03       	nop
8000b298:	ea 0c 11 20 	rsub	r12,r5,32
8000b29c:	40 3a       	lddsp	r10,sp[0xc]
8000b29e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b2a2:	e0 a0 10 14 	rcall	8000d2ca <__avr32_u32_to_f64>
8000b2a6:	fc 18 fe 10 	movh	r8,0xfe10
8000b2aa:	30 19       	mov	r9,1
8000b2ac:	ea c5 04 33 	sub	r5,r5,1075
8000b2b0:	f0 0b 00 0b 	add	r11,r8,r11
8000b2b4:	51 79       	stdsp	sp[0x5c],r9
8000b2b6:	30 08       	mov	r8,0
8000b2b8:	fc 19 3f f8 	movh	r9,0x3ff8
8000b2bc:	e0 a0 0e 9c 	rcall	8000cff4 <__avr32_f64_sub>
8000b2c0:	e0 68 43 61 	mov	r8,17249
8000b2c4:	ea 18 63 6f 	orh	r8,0x636f
8000b2c8:	e0 69 87 a7 	mov	r9,34727
8000b2cc:	ea 19 3f d2 	orh	r9,0x3fd2
8000b2d0:	e0 a0 0d a6 	rcall	8000ce1c <__avr32_f64_mul>
8000b2d4:	e0 68 c8 b3 	mov	r8,51379
8000b2d8:	ea 18 8b 60 	orh	r8,0x8b60
8000b2dc:	e0 69 8a 28 	mov	r9,35368
8000b2e0:	ea 19 3f c6 	orh	r9,0x3fc6
8000b2e4:	e0 a0 0f 56 	rcall	8000d190 <__avr32_f64_add>
8000b2e8:	0a 9c       	mov	r12,r5
8000b2ea:	14 90       	mov	r0,r10
8000b2ec:	16 91       	mov	r1,r11
8000b2ee:	e0 a0 0f f2 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b2f2:	e0 68 79 fb 	mov	r8,31227
8000b2f6:	ea 18 50 9f 	orh	r8,0x509f
8000b2fa:	e0 69 44 13 	mov	r9,17427
8000b2fe:	ea 19 3f d3 	orh	r9,0x3fd3
8000b302:	e0 a0 0d 8d 	rcall	8000ce1c <__avr32_f64_mul>
8000b306:	14 98       	mov	r8,r10
8000b308:	16 99       	mov	r9,r11
8000b30a:	00 9a       	mov	r10,r0
8000b30c:	02 9b       	mov	r11,r1
8000b30e:	e0 a0 0f 41 	rcall	8000d190 <__avr32_f64_add>
8000b312:	14 90       	mov	r0,r10
8000b314:	16 91       	mov	r1,r11
8000b316:	e0 a0 0f c7 	rcall	8000d2a4 <__avr32_f64_to_s32>
8000b31a:	30 08       	mov	r8,0
8000b31c:	18 96       	mov	r6,r12
8000b31e:	30 09       	mov	r9,0
8000b320:	00 9a       	mov	r10,r0
8000b322:	02 9b       	mov	r11,r1
8000b324:	e0 a0 10 8e 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b328:	c0 c0       	breq	8000b340 <_dtoa_r+0x1f4>
8000b32a:	0c 9c       	mov	r12,r6
8000b32c:	e0 a0 0f d3 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b330:	14 98       	mov	r8,r10
8000b332:	16 99       	mov	r9,r11
8000b334:	00 9a       	mov	r10,r0
8000b336:	02 9b       	mov	r11,r1
8000b338:	e0 a0 10 3d 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000b33c:	f7 b6 00 01 	subeq	r6,1
8000b340:	59 66       	cp.w	r6,22
8000b342:	e0 88 00 05 	brls	8000b34c <_dtoa_r+0x200>
8000b346:	30 18       	mov	r8,1
8000b348:	51 48       	stdsp	sp[0x50],r8
8000b34a:	c1 38       	rjmp	8000b370 <_dtoa_r+0x224>
8000b34c:	fe c8 be 2c 	sub	r8,pc,-16852
8000b350:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b354:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b358:	e0 a0 10 74 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b35c:	f9 b4 00 00 	moveq	r4,0
8000b360:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b364:	f7 b6 01 01 	subne	r6,1
8000b368:	f9 bc 01 00 	movne	r12,0
8000b36c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b370:	41 90       	lddsp	r0,sp[0x64]
8000b372:	20 10       	sub	r0,1
8000b374:	0a 10       	sub	r0,r5
8000b376:	c0 46       	brmi	8000b37e <_dtoa_r+0x232>
8000b378:	50 40       	stdsp	sp[0x10],r0
8000b37a:	30 00       	mov	r0,0
8000b37c:	c0 48       	rjmp	8000b384 <_dtoa_r+0x238>
8000b37e:	30 0b       	mov	r11,0
8000b380:	5c 30       	neg	r0
8000b382:	50 4b       	stdsp	sp[0x10],r11
8000b384:	ec 02 11 00 	rsub	r2,r6,0
8000b388:	58 06       	cp.w	r6,0
8000b38a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b38e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b392:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b396:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b39a:	f9 b2 04 00 	movge	r2,0
8000b39e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b3a2:	f9 b9 05 00 	movlt	r9,0
8000b3a6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b3aa:	40 c8       	lddsp	r8,sp[0x30]
8000b3ac:	58 98       	cp.w	r8,9
8000b3ae:	e0 8b 00 20 	brhi	8000b3ee <_dtoa_r+0x2a2>
8000b3b2:	58 58       	cp.w	r8,5
8000b3b4:	f9 b4 0a 01 	movle	r4,1
8000b3b8:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b3bc:	f7 b5 09 04 	subgt	r5,4
8000b3c0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b3c4:	f9 b4 09 00 	movgt	r4,0
8000b3c8:	40 cc       	lddsp	r12,sp[0x30]
8000b3ca:	58 3c       	cp.w	r12,3
8000b3cc:	c2 d0       	breq	8000b426 <_dtoa_r+0x2da>
8000b3ce:	e0 89 00 05 	brgt	8000b3d8 <_dtoa_r+0x28c>
8000b3d2:	58 2c       	cp.w	r12,2
8000b3d4:	c1 01       	brne	8000b3f4 <_dtoa_r+0x2a8>
8000b3d6:	c1 88       	rjmp	8000b406 <_dtoa_r+0x2ba>
8000b3d8:	40 cb       	lddsp	r11,sp[0x30]
8000b3da:	58 4b       	cp.w	r11,4
8000b3dc:	c0 60       	breq	8000b3e8 <_dtoa_r+0x29c>
8000b3de:	58 5b       	cp.w	r11,5
8000b3e0:	c0 a1       	brne	8000b3f4 <_dtoa_r+0x2a8>
8000b3e2:	30 1a       	mov	r10,1
8000b3e4:	50 da       	stdsp	sp[0x34],r10
8000b3e6:	c2 28       	rjmp	8000b42a <_dtoa_r+0x2de>
8000b3e8:	30 19       	mov	r9,1
8000b3ea:	50 d9       	stdsp	sp[0x34],r9
8000b3ec:	c0 f8       	rjmp	8000b40a <_dtoa_r+0x2be>
8000b3ee:	30 08       	mov	r8,0
8000b3f0:	30 14       	mov	r4,1
8000b3f2:	50 c8       	stdsp	sp[0x30],r8
8000b3f4:	3f f5       	mov	r5,-1
8000b3f6:	30 1c       	mov	r12,1
8000b3f8:	30 0b       	mov	r11,0
8000b3fa:	50 95       	stdsp	sp[0x24],r5
8000b3fc:	50 dc       	stdsp	sp[0x34],r12
8000b3fe:	0a 91       	mov	r1,r5
8000b400:	31 28       	mov	r8,18
8000b402:	50 eb       	stdsp	sp[0x38],r11
8000b404:	c2 08       	rjmp	8000b444 <_dtoa_r+0x2f8>
8000b406:	30 0a       	mov	r10,0
8000b408:	50 da       	stdsp	sp[0x34],r10
8000b40a:	40 e9       	lddsp	r9,sp[0x38]
8000b40c:	58 09       	cp.w	r9,0
8000b40e:	e0 89 00 07 	brgt	8000b41c <_dtoa_r+0x2d0>
8000b412:	30 18       	mov	r8,1
8000b414:	50 98       	stdsp	sp[0x24],r8
8000b416:	10 91       	mov	r1,r8
8000b418:	50 e8       	stdsp	sp[0x38],r8
8000b41a:	c1 58       	rjmp	8000b444 <_dtoa_r+0x2f8>
8000b41c:	40 e5       	lddsp	r5,sp[0x38]
8000b41e:	50 95       	stdsp	sp[0x24],r5
8000b420:	0a 91       	mov	r1,r5
8000b422:	0a 98       	mov	r8,r5
8000b424:	c1 08       	rjmp	8000b444 <_dtoa_r+0x2f8>
8000b426:	30 0c       	mov	r12,0
8000b428:	50 dc       	stdsp	sp[0x34],r12
8000b42a:	40 eb       	lddsp	r11,sp[0x38]
8000b42c:	ec 0b 00 0b 	add	r11,r6,r11
8000b430:	50 9b       	stdsp	sp[0x24],r11
8000b432:	16 98       	mov	r8,r11
8000b434:	2f f8       	sub	r8,-1
8000b436:	58 08       	cp.w	r8,0
8000b438:	e0 89 00 05 	brgt	8000b442 <_dtoa_r+0x2f6>
8000b43c:	10 91       	mov	r1,r8
8000b43e:	30 18       	mov	r8,1
8000b440:	c0 28       	rjmp	8000b444 <_dtoa_r+0x2f8>
8000b442:	10 91       	mov	r1,r8
8000b444:	30 09       	mov	r9,0
8000b446:	6e 9a       	ld.w	r10,r7[0x24]
8000b448:	95 19       	st.w	r10[0x4],r9
8000b44a:	30 49       	mov	r9,4
8000b44c:	c0 68       	rjmp	8000b458 <_dtoa_r+0x30c>
8000b44e:	d7 03       	nop
8000b450:	6a 1a       	ld.w	r10,r5[0x4]
8000b452:	a1 79       	lsl	r9,0x1
8000b454:	2f fa       	sub	r10,-1
8000b456:	8b 1a       	st.w	r5[0x4],r10
8000b458:	6e 95       	ld.w	r5,r7[0x24]
8000b45a:	f2 ca ff ec 	sub	r10,r9,-20
8000b45e:	10 3a       	cp.w	r10,r8
8000b460:	fe 98 ff f8 	brls	8000b450 <_dtoa_r+0x304>
8000b464:	6a 1b       	ld.w	r11,r5[0x4]
8000b466:	0e 9c       	mov	r12,r7
8000b468:	e0 a0 09 44 	rcall	8000c6f0 <_Balloc>
8000b46c:	58 e1       	cp.w	r1,14
8000b46e:	5f 88       	srls	r8
8000b470:	8b 0c       	st.w	r5[0x0],r12
8000b472:	f1 e4 00 04 	and	r4,r8,r4
8000b476:	6e 98       	ld.w	r8,r7[0x24]
8000b478:	70 08       	ld.w	r8,r8[0x0]
8000b47a:	50 88       	stdsp	sp[0x20],r8
8000b47c:	e0 80 01 82 	breq	8000b780 <_dtoa_r+0x634>
8000b480:	58 06       	cp.w	r6,0
8000b482:	e0 8a 00 43 	brle	8000b508 <_dtoa_r+0x3bc>
8000b486:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b48a:	fe c8 bf 6a 	sub	r8,pc,-16534
8000b48e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b492:	fa e5 00 18 	st.d	sp[24],r4
8000b496:	ec 04 14 04 	asr	r4,r6,0x4
8000b49a:	ed b4 00 04 	bld	r4,0x4
8000b49e:	c0 30       	breq	8000b4a4 <_dtoa_r+0x358>
8000b4a0:	30 25       	mov	r5,2
8000b4a2:	c1 08       	rjmp	8000b4c2 <_dtoa_r+0x376>
8000b4a4:	fe c8 be bc 	sub	r8,pc,-16708
8000b4a8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b4ac:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b4b0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b4b4:	e0 a0 0f fa 	rcall	8000d4a8 <__avr32_f64_div>
8000b4b8:	30 35       	mov	r5,3
8000b4ba:	14 98       	mov	r8,r10
8000b4bc:	16 99       	mov	r9,r11
8000b4be:	fa e9 00 08 	st.d	sp[8],r8
8000b4c2:	fe cc be da 	sub	r12,pc,-16678
8000b4c6:	50 a3       	stdsp	sp[0x28],r3
8000b4c8:	0c 93       	mov	r3,r6
8000b4ca:	18 96       	mov	r6,r12
8000b4cc:	c0 f8       	rjmp	8000b4ea <_dtoa_r+0x39e>
8000b4ce:	fa ea 00 18 	ld.d	r10,sp[24]
8000b4d2:	ed b4 00 00 	bld	r4,0x0
8000b4d6:	c0 81       	brne	8000b4e6 <_dtoa_r+0x39a>
8000b4d8:	ec e8 00 00 	ld.d	r8,r6[0]
8000b4dc:	2f f5       	sub	r5,-1
8000b4de:	e0 a0 0c 9f 	rcall	8000ce1c <__avr32_f64_mul>
8000b4e2:	fa eb 00 18 	st.d	sp[24],r10
8000b4e6:	a1 54       	asr	r4,0x1
8000b4e8:	2f 86       	sub	r6,-8
8000b4ea:	58 04       	cp.w	r4,0
8000b4ec:	cf 11       	brne	8000b4ce <_dtoa_r+0x382>
8000b4ee:	fa e8 00 18 	ld.d	r8,sp[24]
8000b4f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b4f6:	06 96       	mov	r6,r3
8000b4f8:	e0 a0 0f d8 	rcall	8000d4a8 <__avr32_f64_div>
8000b4fc:	40 a3       	lddsp	r3,sp[0x28]
8000b4fe:	14 98       	mov	r8,r10
8000b500:	16 99       	mov	r9,r11
8000b502:	fa e9 00 08 	st.d	sp[8],r8
8000b506:	c2 f8       	rjmp	8000b564 <_dtoa_r+0x418>
8000b508:	ec 08 11 00 	rsub	r8,r6,0
8000b50c:	c0 31       	brne	8000b512 <_dtoa_r+0x3c6>
8000b50e:	30 25       	mov	r5,2
8000b510:	c2 a8       	rjmp	8000b564 <_dtoa_r+0x418>
8000b512:	fe cc bf 2a 	sub	r12,pc,-16598
8000b516:	f0 04 14 04 	asr	r4,r8,0x4
8000b51a:	50 1c       	stdsp	sp[0x4],r12
8000b51c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b520:	fe c9 c0 00 	sub	r9,pc,-16384
8000b524:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b528:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b52c:	e0 a0 0c 78 	rcall	8000ce1c <__avr32_f64_mul>
8000b530:	40 1c       	lddsp	r12,sp[0x4]
8000b532:	50 63       	stdsp	sp[0x18],r3
8000b534:	30 25       	mov	r5,2
8000b536:	0c 93       	mov	r3,r6
8000b538:	fa eb 00 08 	st.d	sp[8],r10
8000b53c:	18 96       	mov	r6,r12
8000b53e:	c0 f8       	rjmp	8000b55c <_dtoa_r+0x410>
8000b540:	fa ea 00 08 	ld.d	r10,sp[8]
8000b544:	ed b4 00 00 	bld	r4,0x0
8000b548:	c0 81       	brne	8000b558 <_dtoa_r+0x40c>
8000b54a:	ec e8 00 00 	ld.d	r8,r6[0]
8000b54e:	2f f5       	sub	r5,-1
8000b550:	e0 a0 0c 66 	rcall	8000ce1c <__avr32_f64_mul>
8000b554:	fa eb 00 08 	st.d	sp[8],r10
8000b558:	a1 54       	asr	r4,0x1
8000b55a:	2f 86       	sub	r6,-8
8000b55c:	58 04       	cp.w	r4,0
8000b55e:	cf 11       	brne	8000b540 <_dtoa_r+0x3f4>
8000b560:	06 96       	mov	r6,r3
8000b562:	40 63       	lddsp	r3,sp[0x18]
8000b564:	41 4a       	lddsp	r10,sp[0x50]
8000b566:	58 0a       	cp.w	r10,0
8000b568:	c2 a0       	breq	8000b5bc <_dtoa_r+0x470>
8000b56a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b56e:	58 01       	cp.w	r1,0
8000b570:	5f 94       	srgt	r4
8000b572:	fa e9 00 18 	st.d	sp[24],r8
8000b576:	30 08       	mov	r8,0
8000b578:	fc 19 3f f0 	movh	r9,0x3ff0
8000b57c:	fa ea 00 18 	ld.d	r10,sp[24]
8000b580:	e0 a0 0f 60 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b584:	f9 bc 00 00 	moveq	r12,0
8000b588:	f9 bc 01 01 	movne	r12,1
8000b58c:	e9 ec 00 0c 	and	r12,r4,r12
8000b590:	c1 60       	breq	8000b5bc <_dtoa_r+0x470>
8000b592:	40 98       	lddsp	r8,sp[0x24]
8000b594:	58 08       	cp.w	r8,0
8000b596:	e0 8a 00 f1 	brle	8000b778 <_dtoa_r+0x62c>
8000b59a:	30 08       	mov	r8,0
8000b59c:	fc 19 40 24 	movh	r9,0x4024
8000b5a0:	ec c4 00 01 	sub	r4,r6,1
8000b5a4:	fa ea 00 18 	ld.d	r10,sp[24]
8000b5a8:	2f f5       	sub	r5,-1
8000b5aa:	50 64       	stdsp	sp[0x18],r4
8000b5ac:	e0 a0 0c 38 	rcall	8000ce1c <__avr32_f64_mul>
8000b5b0:	40 94       	lddsp	r4,sp[0x24]
8000b5b2:	14 98       	mov	r8,r10
8000b5b4:	16 99       	mov	r9,r11
8000b5b6:	fa e9 00 08 	st.d	sp[8],r8
8000b5ba:	c0 38       	rjmp	8000b5c0 <_dtoa_r+0x474>
8000b5bc:	50 66       	stdsp	sp[0x18],r6
8000b5be:	02 94       	mov	r4,r1
8000b5c0:	0a 9c       	mov	r12,r5
8000b5c2:	e0 a0 0e 88 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b5c6:	fa e8 00 08 	ld.d	r8,sp[8]
8000b5ca:	e0 a0 0c 29 	rcall	8000ce1c <__avr32_f64_mul>
8000b5ce:	30 08       	mov	r8,0
8000b5d0:	fc 19 40 1c 	movh	r9,0x401c
8000b5d4:	e0 a0 0d de 	rcall	8000d190 <__avr32_f64_add>
8000b5d8:	14 98       	mov	r8,r10
8000b5da:	16 99       	mov	r9,r11
8000b5dc:	fa e9 00 28 	st.d	sp[40],r8
8000b5e0:	fc 18 fc c0 	movh	r8,0xfcc0
8000b5e4:	40 a5       	lddsp	r5,sp[0x28]
8000b5e6:	10 05       	add	r5,r8
8000b5e8:	50 a5       	stdsp	sp[0x28],r5
8000b5ea:	58 04       	cp.w	r4,0
8000b5ec:	c2 11       	brne	8000b62e <_dtoa_r+0x4e2>
8000b5ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5f2:	30 08       	mov	r8,0
8000b5f4:	fc 19 40 14 	movh	r9,0x4014
8000b5f8:	e0 a0 0c fe 	rcall	8000cff4 <__avr32_f64_sub>
8000b5fc:	40 bc       	lddsp	r12,sp[0x2c]
8000b5fe:	fa eb 00 08 	st.d	sp[8],r10
8000b602:	14 98       	mov	r8,r10
8000b604:	16 99       	mov	r9,r11
8000b606:	18 9a       	mov	r10,r12
8000b608:	0a 9b       	mov	r11,r5
8000b60a:	e0 a0 0f 1b 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b60e:	e0 81 02 54 	brne	8000bab6 <_dtoa_r+0x96a>
8000b612:	0a 98       	mov	r8,r5
8000b614:	40 b9       	lddsp	r9,sp[0x2c]
8000b616:	ee 18 80 00 	eorh	r8,0x8000
8000b61a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b61e:	10 95       	mov	r5,r8
8000b620:	12 98       	mov	r8,r9
8000b622:	0a 99       	mov	r9,r5
8000b624:	e0 a0 0f 0e 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b628:	e0 81 02 3e 	brne	8000baa4 <_dtoa_r+0x958>
8000b62c:	ca 68       	rjmp	8000b778 <_dtoa_r+0x62c>
8000b62e:	fe c9 c1 0e 	sub	r9,pc,-16114
8000b632:	e8 c8 00 01 	sub	r8,r4,1
8000b636:	40 d5       	lddsp	r5,sp[0x34]
8000b638:	58 05       	cp.w	r5,0
8000b63a:	c4 f0       	breq	8000b6d8 <_dtoa_r+0x58c>
8000b63c:	30 0c       	mov	r12,0
8000b63e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b642:	51 3c       	stdsp	sp[0x4c],r12
8000b644:	30 0a       	mov	r10,0
8000b646:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b64a:	e0 a0 0f 2f 	rcall	8000d4a8 <__avr32_f64_div>
8000b64e:	fa e8 00 28 	ld.d	r8,sp[40]
8000b652:	40 85       	lddsp	r5,sp[0x20]
8000b654:	e0 a0 0c d0 	rcall	8000cff4 <__avr32_f64_sub>
8000b658:	fa eb 00 28 	st.d	sp[40],r10
8000b65c:	fa ea 00 08 	ld.d	r10,sp[8]
8000b660:	e0 a0 0e 22 	rcall	8000d2a4 <__avr32_f64_to_s32>
8000b664:	51 6c       	stdsp	sp[0x58],r12
8000b666:	e0 a0 0e 36 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b66a:	14 98       	mov	r8,r10
8000b66c:	16 99       	mov	r9,r11
8000b66e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b672:	e0 a0 0c c1 	rcall	8000cff4 <__avr32_f64_sub>
8000b676:	fa eb 00 08 	st.d	sp[8],r10
8000b67a:	41 68       	lddsp	r8,sp[0x58]
8000b67c:	2d 08       	sub	r8,-48
8000b67e:	0a c8       	st.b	r5++,r8
8000b680:	41 39       	lddsp	r9,sp[0x4c]
8000b682:	2f f9       	sub	r9,-1
8000b684:	51 39       	stdsp	sp[0x4c],r9
8000b686:	fa e8 00 28 	ld.d	r8,sp[40]
8000b68a:	e0 a0 0e db 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b68e:	e0 81 03 39 	brne	8000bd00 <_dtoa_r+0xbb4>
8000b692:	fa e8 00 08 	ld.d	r8,sp[8]
8000b696:	30 0a       	mov	r10,0
8000b698:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b69c:	e0 a0 0c ac 	rcall	8000cff4 <__avr32_f64_sub>
8000b6a0:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6a4:	e0 a0 0e ce 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b6a8:	fa ea 00 28 	ld.d	r10,sp[40]
8000b6ac:	30 08       	mov	r8,0
8000b6ae:	fc 19 40 24 	movh	r9,0x4024
8000b6b2:	e0 81 00 da 	brne	8000b866 <_dtoa_r+0x71a>
8000b6b6:	41 3c       	lddsp	r12,sp[0x4c]
8000b6b8:	08 3c       	cp.w	r12,r4
8000b6ba:	c5 f4       	brge	8000b778 <_dtoa_r+0x62c>
8000b6bc:	e0 a0 0b b0 	rcall	8000ce1c <__avr32_f64_mul>
8000b6c0:	30 08       	mov	r8,0
8000b6c2:	fa eb 00 28 	st.d	sp[40],r10
8000b6c6:	fc 19 40 24 	movh	r9,0x4024
8000b6ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6ce:	e0 a0 0b a7 	rcall	8000ce1c <__avr32_f64_mul>
8000b6d2:	fa eb 00 08 	st.d	sp[8],r10
8000b6d6:	cc 3b       	rjmp	8000b65c <_dtoa_r+0x510>
8000b6d8:	40 85       	lddsp	r5,sp[0x20]
8000b6da:	08 05       	add	r5,r4
8000b6dc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b6e0:	51 35       	stdsp	sp[0x4c],r5
8000b6e2:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6e6:	40 85       	lddsp	r5,sp[0x20]
8000b6e8:	e0 a0 0b 9a 	rcall	8000ce1c <__avr32_f64_mul>
8000b6ec:	fa eb 00 28 	st.d	sp[40],r10
8000b6f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6f4:	e0 a0 0d d8 	rcall	8000d2a4 <__avr32_f64_to_s32>
8000b6f8:	51 6c       	stdsp	sp[0x58],r12
8000b6fa:	e0 a0 0d ec 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b6fe:	14 98       	mov	r8,r10
8000b700:	16 99       	mov	r9,r11
8000b702:	fa ea 00 08 	ld.d	r10,sp[8]
8000b706:	e0 a0 0c 77 	rcall	8000cff4 <__avr32_f64_sub>
8000b70a:	fa eb 00 08 	st.d	sp[8],r10
8000b70e:	41 68       	lddsp	r8,sp[0x58]
8000b710:	2d 08       	sub	r8,-48
8000b712:	0a c8       	st.b	r5++,r8
8000b714:	41 3c       	lddsp	r12,sp[0x4c]
8000b716:	18 35       	cp.w	r5,r12
8000b718:	c2 81       	brne	8000b768 <_dtoa_r+0x61c>
8000b71a:	30 08       	mov	r8,0
8000b71c:	fc 19 3f e0 	movh	r9,0x3fe0
8000b720:	fa ea 00 28 	ld.d	r10,sp[40]
8000b724:	e0 a0 0d 36 	rcall	8000d190 <__avr32_f64_add>
8000b728:	40 85       	lddsp	r5,sp[0x20]
8000b72a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b72e:	08 05       	add	r5,r4
8000b730:	e0 a0 0e 88 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b734:	e0 81 00 99 	brne	8000b866 <_dtoa_r+0x71a>
8000b738:	fa e8 00 28 	ld.d	r8,sp[40]
8000b73c:	30 0a       	mov	r10,0
8000b73e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b742:	e0 a0 0c 59 	rcall	8000cff4 <__avr32_f64_sub>
8000b746:	14 98       	mov	r8,r10
8000b748:	16 99       	mov	r9,r11
8000b74a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b74e:	e0 a0 0e 79 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b752:	c1 30       	breq	8000b778 <_dtoa_r+0x62c>
8000b754:	33 09       	mov	r9,48
8000b756:	0a 98       	mov	r8,r5
8000b758:	11 7a       	ld.ub	r10,--r8
8000b75a:	f2 0a 18 00 	cp.b	r10,r9
8000b75e:	e0 81 02 d1 	brne	8000bd00 <_dtoa_r+0xbb4>
8000b762:	10 95       	mov	r5,r8
8000b764:	cf 9b       	rjmp	8000b756 <_dtoa_r+0x60a>
8000b766:	d7 03       	nop
8000b768:	30 08       	mov	r8,0
8000b76a:	fc 19 40 24 	movh	r9,0x4024
8000b76e:	e0 a0 0b 57 	rcall	8000ce1c <__avr32_f64_mul>
8000b772:	fa eb 00 08 	st.d	sp[8],r10
8000b776:	cb db       	rjmp	8000b6f0 <_dtoa_r+0x5a4>
8000b778:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b77c:	fa eb 00 08 	st.d	sp[8],r10
8000b780:	58 e6       	cp.w	r6,14
8000b782:	5f ab       	srle	r11
8000b784:	41 8a       	lddsp	r10,sp[0x60]
8000b786:	30 08       	mov	r8,0
8000b788:	f4 09 11 ff 	rsub	r9,r10,-1
8000b78c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b790:	f0 09 18 00 	cp.b	r9,r8
8000b794:	e0 80 00 82 	breq	8000b898 <_dtoa_r+0x74c>
8000b798:	40 ea       	lddsp	r10,sp[0x38]
8000b79a:	58 01       	cp.w	r1,0
8000b79c:	5f a9       	srle	r9
8000b79e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b7a2:	fe ca c2 82 	sub	r10,pc,-15742
8000b7a6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b7aa:	fa e5 00 10 	st.d	sp[16],r4
8000b7ae:	f0 09 18 00 	cp.b	r9,r8
8000b7b2:	c1 40       	breq	8000b7da <_dtoa_r+0x68e>
8000b7b4:	58 01       	cp.w	r1,0
8000b7b6:	e0 81 01 77 	brne	8000baa4 <_dtoa_r+0x958>
8000b7ba:	30 08       	mov	r8,0
8000b7bc:	fc 19 40 14 	movh	r9,0x4014
8000b7c0:	08 9a       	mov	r10,r4
8000b7c2:	0a 9b       	mov	r11,r5
8000b7c4:	e0 a0 0b 2c 	rcall	8000ce1c <__avr32_f64_mul>
8000b7c8:	fa e8 00 08 	ld.d	r8,sp[8]
8000b7cc:	e0 a0 0e 06 	rcall	8000d3d8 <__avr32_f64_cmp_ge>
8000b7d0:	e0 81 01 6a 	brne	8000baa4 <_dtoa_r+0x958>
8000b7d4:	02 92       	mov	r2,r1
8000b7d6:	e0 8f 01 72 	bral	8000baba <_dtoa_r+0x96e>
8000b7da:	40 85       	lddsp	r5,sp[0x20]
8000b7dc:	30 14       	mov	r4,1
8000b7de:	fa e8 00 10 	ld.d	r8,sp[16]
8000b7e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7e6:	e0 a0 0e 61 	rcall	8000d4a8 <__avr32_f64_div>
8000b7ea:	e0 a0 0d 5d 	rcall	8000d2a4 <__avr32_f64_to_s32>
8000b7ee:	18 92       	mov	r2,r12
8000b7f0:	e0 a0 0d 71 	rcall	8000d2d2 <__avr32_s32_to_f64>
8000b7f4:	fa e8 00 10 	ld.d	r8,sp[16]
8000b7f8:	e0 a0 0b 12 	rcall	8000ce1c <__avr32_f64_mul>
8000b7fc:	14 98       	mov	r8,r10
8000b7fe:	16 99       	mov	r9,r11
8000b800:	fa ea 00 08 	ld.d	r10,sp[8]
8000b804:	e0 a0 0b f8 	rcall	8000cff4 <__avr32_f64_sub>
8000b808:	fa eb 00 08 	st.d	sp[8],r10
8000b80c:	e4 c8 ff d0 	sub	r8,r2,-48
8000b810:	0a c8       	st.b	r5++,r8
8000b812:	fc 19 40 24 	movh	r9,0x4024
8000b816:	30 08       	mov	r8,0
8000b818:	02 34       	cp.w	r4,r1
8000b81a:	c3 31       	brne	8000b880 <_dtoa_r+0x734>
8000b81c:	fa e8 00 08 	ld.d	r8,sp[8]
8000b820:	e0 a0 0c b8 	rcall	8000d190 <__avr32_f64_add>
8000b824:	16 91       	mov	r1,r11
8000b826:	14 90       	mov	r0,r10
8000b828:	14 98       	mov	r8,r10
8000b82a:	02 99       	mov	r9,r1
8000b82c:	fa ea 00 10 	ld.d	r10,sp[16]
8000b830:	e0 a0 0e 08 	rcall	8000d440 <__avr32_f64_cmp_lt>
8000b834:	c1 a1       	brne	8000b868 <_dtoa_r+0x71c>
8000b836:	fa e8 00 10 	ld.d	r8,sp[16]
8000b83a:	00 9a       	mov	r10,r0
8000b83c:	02 9b       	mov	r11,r1
8000b83e:	e0 a0 0d ba 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000b842:	e0 80 02 5e 	breq	8000bcfe <_dtoa_r+0xbb2>
8000b846:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b84a:	c0 f1       	brne	8000b868 <_dtoa_r+0x71c>
8000b84c:	e0 8f 02 59 	bral	8000bcfe <_dtoa_r+0xbb2>
8000b850:	40 8a       	lddsp	r10,sp[0x20]
8000b852:	14 38       	cp.w	r8,r10
8000b854:	c0 30       	breq	8000b85a <_dtoa_r+0x70e>
8000b856:	10 95       	mov	r5,r8
8000b858:	c0 98       	rjmp	8000b86a <_dtoa_r+0x71e>
8000b85a:	33 08       	mov	r8,48
8000b85c:	40 89       	lddsp	r9,sp[0x20]
8000b85e:	2f f6       	sub	r6,-1
8000b860:	b2 88       	st.b	r9[0x0],r8
8000b862:	40 88       	lddsp	r8,sp[0x20]
8000b864:	c0 88       	rjmp	8000b874 <_dtoa_r+0x728>
8000b866:	40 66       	lddsp	r6,sp[0x18]
8000b868:	33 99       	mov	r9,57
8000b86a:	0a 98       	mov	r8,r5
8000b86c:	11 7a       	ld.ub	r10,--r8
8000b86e:	f2 0a 18 00 	cp.b	r10,r9
8000b872:	ce f0       	breq	8000b850 <_dtoa_r+0x704>
8000b874:	50 66       	stdsp	sp[0x18],r6
8000b876:	11 89       	ld.ub	r9,r8[0x0]
8000b878:	2f f9       	sub	r9,-1
8000b87a:	b0 89       	st.b	r8[0x0],r9
8000b87c:	e0 8f 02 42 	bral	8000bd00 <_dtoa_r+0xbb4>
8000b880:	e0 a0 0a ce 	rcall	8000ce1c <__avr32_f64_mul>
8000b884:	2f f4       	sub	r4,-1
8000b886:	fa eb 00 08 	st.d	sp[8],r10
8000b88a:	30 08       	mov	r8,0
8000b88c:	30 09       	mov	r9,0
8000b88e:	e0 a0 0d 92 	rcall	8000d3b2 <__avr32_f64_cmp_eq>
8000b892:	ca 60       	breq	8000b7de <_dtoa_r+0x692>
8000b894:	e0 8f 02 35 	bral	8000bcfe <_dtoa_r+0xbb2>
8000b898:	40 d8       	lddsp	r8,sp[0x34]
8000b89a:	58 08       	cp.w	r8,0
8000b89c:	c0 51       	brne	8000b8a6 <_dtoa_r+0x75a>
8000b89e:	04 98       	mov	r8,r2
8000b8a0:	00 95       	mov	r5,r0
8000b8a2:	40 d4       	lddsp	r4,sp[0x34]
8000b8a4:	c3 78       	rjmp	8000b912 <_dtoa_r+0x7c6>
8000b8a6:	40 c5       	lddsp	r5,sp[0x30]
8000b8a8:	58 15       	cp.w	r5,1
8000b8aa:	e0 89 00 0f 	brgt	8000b8c8 <_dtoa_r+0x77c>
8000b8ae:	41 74       	lddsp	r4,sp[0x5c]
8000b8b0:	58 04       	cp.w	r4,0
8000b8b2:	c0 40       	breq	8000b8ba <_dtoa_r+0x76e>
8000b8b4:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b8b8:	c0 48       	rjmp	8000b8c0 <_dtoa_r+0x774>
8000b8ba:	41 99       	lddsp	r9,sp[0x64]
8000b8bc:	f2 09 11 36 	rsub	r9,r9,54
8000b8c0:	04 98       	mov	r8,r2
8000b8c2:	00 95       	mov	r5,r0
8000b8c4:	c1 c8       	rjmp	8000b8fc <_dtoa_r+0x7b0>
8000b8c6:	d7 03       	nop
8000b8c8:	e2 c8 00 01 	sub	r8,r1,1
8000b8cc:	58 01       	cp.w	r1,0
8000b8ce:	e0 05 17 40 	movge	r5,r0
8000b8d2:	e2 09 17 40 	movge	r9,r1
8000b8d6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b8da:	f9 b9 05 00 	movlt	r9,0
8000b8de:	10 32       	cp.w	r2,r8
8000b8e0:	e5 d8 e4 18 	subge	r8,r2,r8
8000b8e4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b8e8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b8ec:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b8f0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b8f4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b8f8:	f9 b8 05 00 	movlt	r8,0
8000b8fc:	40 4b       	lddsp	r11,sp[0x10]
8000b8fe:	12 0b       	add	r11,r9
8000b900:	50 08       	stdsp	sp[0x0],r8
8000b902:	50 4b       	stdsp	sp[0x10],r11
8000b904:	12 00       	add	r0,r9
8000b906:	30 1b       	mov	r11,1
8000b908:	0e 9c       	mov	r12,r7
8000b90a:	e0 a0 08 a7 	rcall	8000ca58 <__i2b>
8000b90e:	40 08       	lddsp	r8,sp[0x0]
8000b910:	18 94       	mov	r4,r12
8000b912:	40 4a       	lddsp	r10,sp[0x10]
8000b914:	58 05       	cp.w	r5,0
8000b916:	5f 99       	srgt	r9
8000b918:	58 0a       	cp.w	r10,0
8000b91a:	5f 9a       	srgt	r10
8000b91c:	f5 e9 00 09 	and	r9,r10,r9
8000b920:	c0 80       	breq	8000b930 <_dtoa_r+0x7e4>
8000b922:	40 4c       	lddsp	r12,sp[0x10]
8000b924:	f8 05 0d 49 	min	r9,r12,r5
8000b928:	12 1c       	sub	r12,r9
8000b92a:	12 10       	sub	r0,r9
8000b92c:	50 4c       	stdsp	sp[0x10],r12
8000b92e:	12 15       	sub	r5,r9
8000b930:	58 02       	cp.w	r2,0
8000b932:	e0 8a 00 27 	brle	8000b980 <_dtoa_r+0x834>
8000b936:	40 db       	lddsp	r11,sp[0x34]
8000b938:	58 0b       	cp.w	r11,0
8000b93a:	c1 d0       	breq	8000b974 <_dtoa_r+0x828>
8000b93c:	58 08       	cp.w	r8,0
8000b93e:	e0 8a 00 17 	brle	8000b96c <_dtoa_r+0x820>
8000b942:	10 9a       	mov	r10,r8
8000b944:	50 08       	stdsp	sp[0x0],r8
8000b946:	08 9b       	mov	r11,r4
8000b948:	0e 9c       	mov	r12,r7
8000b94a:	e0 a0 08 cd 	rcall	8000cae4 <__pow5mult>
8000b94e:	06 9a       	mov	r10,r3
8000b950:	18 9b       	mov	r11,r12
8000b952:	18 94       	mov	r4,r12
8000b954:	0e 9c       	mov	r12,r7
8000b956:	e0 a0 08 01 	rcall	8000c958 <__multiply>
8000b95a:	18 99       	mov	r9,r12
8000b95c:	06 9b       	mov	r11,r3
8000b95e:	50 19       	stdsp	sp[0x4],r9
8000b960:	0e 9c       	mov	r12,r7
8000b962:	e0 a0 06 ad 	rcall	8000c6bc <_Bfree>
8000b966:	40 19       	lddsp	r9,sp[0x4]
8000b968:	40 08       	lddsp	r8,sp[0x0]
8000b96a:	12 93       	mov	r3,r9
8000b96c:	e4 08 01 0a 	sub	r10,r2,r8
8000b970:	c0 80       	breq	8000b980 <_dtoa_r+0x834>
8000b972:	c0 28       	rjmp	8000b976 <_dtoa_r+0x82a>
8000b974:	04 9a       	mov	r10,r2
8000b976:	06 9b       	mov	r11,r3
8000b978:	0e 9c       	mov	r12,r7
8000b97a:	e0 a0 08 b5 	rcall	8000cae4 <__pow5mult>
8000b97e:	18 93       	mov	r3,r12
8000b980:	30 1b       	mov	r11,1
8000b982:	0e 9c       	mov	r12,r7
8000b984:	e0 a0 08 6a 	rcall	8000ca58 <__i2b>
8000b988:	41 1a       	lddsp	r10,sp[0x44]
8000b98a:	18 92       	mov	r2,r12
8000b98c:	58 0a       	cp.w	r10,0
8000b98e:	e0 8a 00 07 	brle	8000b99c <_dtoa_r+0x850>
8000b992:	18 9b       	mov	r11,r12
8000b994:	0e 9c       	mov	r12,r7
8000b996:	e0 a0 08 a7 	rcall	8000cae4 <__pow5mult>
8000b99a:	18 92       	mov	r2,r12
8000b99c:	40 c9       	lddsp	r9,sp[0x30]
8000b99e:	58 19       	cp.w	r9,1
8000b9a0:	e0 89 00 14 	brgt	8000b9c8 <_dtoa_r+0x87c>
8000b9a4:	40 38       	lddsp	r8,sp[0xc]
8000b9a6:	58 08       	cp.w	r8,0
8000b9a8:	c1 01       	brne	8000b9c8 <_dtoa_r+0x87c>
8000b9aa:	40 29       	lddsp	r9,sp[0x8]
8000b9ac:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b9b0:	c0 c1       	brne	8000b9c8 <_dtoa_r+0x87c>
8000b9b2:	12 98       	mov	r8,r9
8000b9b4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b9b8:	c0 80       	breq	8000b9c8 <_dtoa_r+0x87c>
8000b9ba:	40 4c       	lddsp	r12,sp[0x10]
8000b9bc:	30 1b       	mov	r11,1
8000b9be:	2f fc       	sub	r12,-1
8000b9c0:	2f f0       	sub	r0,-1
8000b9c2:	50 4c       	stdsp	sp[0x10],r12
8000b9c4:	50 6b       	stdsp	sp[0x18],r11
8000b9c6:	c0 38       	rjmp	8000b9cc <_dtoa_r+0x880>
8000b9c8:	30 0a       	mov	r10,0
8000b9ca:	50 6a       	stdsp	sp[0x18],r10
8000b9cc:	41 19       	lddsp	r9,sp[0x44]
8000b9ce:	58 09       	cp.w	r9,0
8000b9d0:	c0 31       	brne	8000b9d6 <_dtoa_r+0x88a>
8000b9d2:	30 1c       	mov	r12,1
8000b9d4:	c0 98       	rjmp	8000b9e6 <_dtoa_r+0x89a>
8000b9d6:	64 48       	ld.w	r8,r2[0x10]
8000b9d8:	2f c8       	sub	r8,-4
8000b9da:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b9de:	e0 a0 05 df 	rcall	8000c59c <__hi0bits>
8000b9e2:	f8 0c 11 20 	rsub	r12,r12,32
8000b9e6:	40 4b       	lddsp	r11,sp[0x10]
8000b9e8:	f8 0b 00 08 	add	r8,r12,r11
8000b9ec:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b9f0:	c0 c0       	breq	8000ba08 <_dtoa_r+0x8bc>
8000b9f2:	f0 08 11 20 	rsub	r8,r8,32
8000b9f6:	58 48       	cp.w	r8,4
8000b9f8:	e0 8a 00 06 	brle	8000ba04 <_dtoa_r+0x8b8>
8000b9fc:	20 48       	sub	r8,4
8000b9fe:	10 0b       	add	r11,r8
8000ba00:	50 4b       	stdsp	sp[0x10],r11
8000ba02:	c0 78       	rjmp	8000ba10 <_dtoa_r+0x8c4>
8000ba04:	58 48       	cp.w	r8,4
8000ba06:	c0 70       	breq	8000ba14 <_dtoa_r+0x8c8>
8000ba08:	40 4a       	lddsp	r10,sp[0x10]
8000ba0a:	2e 48       	sub	r8,-28
8000ba0c:	10 0a       	add	r10,r8
8000ba0e:	50 4a       	stdsp	sp[0x10],r10
8000ba10:	10 00       	add	r0,r8
8000ba12:	10 05       	add	r5,r8
8000ba14:	58 00       	cp.w	r0,0
8000ba16:	e0 8a 00 08 	brle	8000ba26 <_dtoa_r+0x8da>
8000ba1a:	06 9b       	mov	r11,r3
8000ba1c:	00 9a       	mov	r10,r0
8000ba1e:	0e 9c       	mov	r12,r7
8000ba20:	e0 a0 07 58 	rcall	8000c8d0 <__lshift>
8000ba24:	18 93       	mov	r3,r12
8000ba26:	40 49       	lddsp	r9,sp[0x10]
8000ba28:	58 09       	cp.w	r9,0
8000ba2a:	e0 8a 00 08 	brle	8000ba3a <_dtoa_r+0x8ee>
8000ba2e:	04 9b       	mov	r11,r2
8000ba30:	12 9a       	mov	r10,r9
8000ba32:	0e 9c       	mov	r12,r7
8000ba34:	e0 a0 07 4e 	rcall	8000c8d0 <__lshift>
8000ba38:	18 92       	mov	r2,r12
8000ba3a:	41 48       	lddsp	r8,sp[0x50]
8000ba3c:	58 08       	cp.w	r8,0
8000ba3e:	c1 b0       	breq	8000ba74 <_dtoa_r+0x928>
8000ba40:	04 9b       	mov	r11,r2
8000ba42:	06 9c       	mov	r12,r3
8000ba44:	e0 a0 06 23 	rcall	8000c68a <__mcmp>
8000ba48:	c1 64       	brge	8000ba74 <_dtoa_r+0x928>
8000ba4a:	06 9b       	mov	r11,r3
8000ba4c:	30 09       	mov	r9,0
8000ba4e:	30 aa       	mov	r10,10
8000ba50:	0e 9c       	mov	r12,r7
8000ba52:	e0 a0 08 0b 	rcall	8000ca68 <__multadd>
8000ba56:	20 16       	sub	r6,1
8000ba58:	18 93       	mov	r3,r12
8000ba5a:	40 dc       	lddsp	r12,sp[0x34]
8000ba5c:	58 0c       	cp.w	r12,0
8000ba5e:	c0 31       	brne	8000ba64 <_dtoa_r+0x918>
8000ba60:	40 91       	lddsp	r1,sp[0x24]
8000ba62:	c0 98       	rjmp	8000ba74 <_dtoa_r+0x928>
8000ba64:	08 9b       	mov	r11,r4
8000ba66:	40 91       	lddsp	r1,sp[0x24]
8000ba68:	30 09       	mov	r9,0
8000ba6a:	30 aa       	mov	r10,10
8000ba6c:	0e 9c       	mov	r12,r7
8000ba6e:	e0 a0 07 fd 	rcall	8000ca68 <__multadd>
8000ba72:	18 94       	mov	r4,r12
8000ba74:	58 01       	cp.w	r1,0
8000ba76:	5f a9       	srle	r9
8000ba78:	40 cb       	lddsp	r11,sp[0x30]
8000ba7a:	58 2b       	cp.w	r11,2
8000ba7c:	5f 98       	srgt	r8
8000ba7e:	f3 e8 00 08 	and	r8,r9,r8
8000ba82:	c2 50       	breq	8000bacc <_dtoa_r+0x980>
8000ba84:	58 01       	cp.w	r1,0
8000ba86:	c1 11       	brne	8000baa8 <_dtoa_r+0x95c>
8000ba88:	04 9b       	mov	r11,r2
8000ba8a:	02 99       	mov	r9,r1
8000ba8c:	30 5a       	mov	r10,5
8000ba8e:	0e 9c       	mov	r12,r7
8000ba90:	e0 a0 07 ec 	rcall	8000ca68 <__multadd>
8000ba94:	18 92       	mov	r2,r12
8000ba96:	18 9b       	mov	r11,r12
8000ba98:	06 9c       	mov	r12,r3
8000ba9a:	e0 a0 05 f8 	rcall	8000c68a <__mcmp>
8000ba9e:	e0 89 00 0f 	brgt	8000babc <_dtoa_r+0x970>
8000baa2:	c0 38       	rjmp	8000baa8 <_dtoa_r+0x95c>
8000baa4:	30 02       	mov	r2,0
8000baa6:	04 94       	mov	r4,r2
8000baa8:	40 ea       	lddsp	r10,sp[0x38]
8000baaa:	30 09       	mov	r9,0
8000baac:	5c da       	com	r10
8000baae:	40 85       	lddsp	r5,sp[0x20]
8000bab0:	50 6a       	stdsp	sp[0x18],r10
8000bab2:	50 49       	stdsp	sp[0x10],r9
8000bab4:	c0 f9       	rjmp	8000bcd2 <_dtoa_r+0xb86>
8000bab6:	08 92       	mov	r2,r4
8000bab8:	40 66       	lddsp	r6,sp[0x18]
8000baba:	04 94       	mov	r4,r2
8000babc:	2f f6       	sub	r6,-1
8000babe:	50 66       	stdsp	sp[0x18],r6
8000bac0:	33 18       	mov	r8,49
8000bac2:	40 85       	lddsp	r5,sp[0x20]
8000bac4:	0a c8       	st.b	r5++,r8
8000bac6:	30 08       	mov	r8,0
8000bac8:	50 48       	stdsp	sp[0x10],r8
8000baca:	c0 49       	rjmp	8000bcd2 <_dtoa_r+0xb86>
8000bacc:	40 dc       	lddsp	r12,sp[0x34]
8000bace:	58 0c       	cp.w	r12,0
8000bad0:	e0 80 00 b5 	breq	8000bc3a <_dtoa_r+0xaee>
8000bad4:	58 05       	cp.w	r5,0
8000bad6:	e0 8a 00 08 	brle	8000bae6 <_dtoa_r+0x99a>
8000bada:	08 9b       	mov	r11,r4
8000badc:	0a 9a       	mov	r10,r5
8000bade:	0e 9c       	mov	r12,r7
8000bae0:	e0 a0 06 f8 	rcall	8000c8d0 <__lshift>
8000bae4:	18 94       	mov	r4,r12
8000bae6:	40 6b       	lddsp	r11,sp[0x18]
8000bae8:	58 0b       	cp.w	r11,0
8000baea:	c0 31       	brne	8000baf0 <_dtoa_r+0x9a4>
8000baec:	08 9c       	mov	r12,r4
8000baee:	c1 38       	rjmp	8000bb14 <_dtoa_r+0x9c8>
8000baf0:	68 1b       	ld.w	r11,r4[0x4]
8000baf2:	0e 9c       	mov	r12,r7
8000baf4:	e0 a0 05 fe 	rcall	8000c6f0 <_Balloc>
8000baf8:	68 4a       	ld.w	r10,r4[0x10]
8000bafa:	18 95       	mov	r5,r12
8000bafc:	e8 cb ff f4 	sub	r11,r4,-12
8000bb00:	2f ea       	sub	r10,-2
8000bb02:	2f 4c       	sub	r12,-12
8000bb04:	a3 6a       	lsl	r10,0x2
8000bb06:	fe b0 e6 50 	rcall	800087a6 <memcpy>
8000bb0a:	0a 9b       	mov	r11,r5
8000bb0c:	30 1a       	mov	r10,1
8000bb0e:	0e 9c       	mov	r12,r7
8000bb10:	e0 a0 06 e0 	rcall	8000c8d0 <__lshift>
8000bb14:	50 44       	stdsp	sp[0x10],r4
8000bb16:	40 3a       	lddsp	r10,sp[0xc]
8000bb18:	30 19       	mov	r9,1
8000bb1a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000bb1e:	18 94       	mov	r4,r12
8000bb20:	50 da       	stdsp	sp[0x34],r10
8000bb22:	40 85       	lddsp	r5,sp[0x20]
8000bb24:	50 99       	stdsp	sp[0x24],r9
8000bb26:	50 26       	stdsp	sp[0x8],r6
8000bb28:	50 e1       	stdsp	sp[0x38],r1
8000bb2a:	04 9b       	mov	r11,r2
8000bb2c:	06 9c       	mov	r12,r3
8000bb2e:	fe b0 fa 7f 	rcall	8000b02c <quorem>
8000bb32:	40 4b       	lddsp	r11,sp[0x10]
8000bb34:	f8 c0 ff d0 	sub	r0,r12,-48
8000bb38:	06 9c       	mov	r12,r3
8000bb3a:	e0 a0 05 a8 	rcall	8000c68a <__mcmp>
8000bb3e:	08 9a       	mov	r10,r4
8000bb40:	50 6c       	stdsp	sp[0x18],r12
8000bb42:	04 9b       	mov	r11,r2
8000bb44:	0e 9c       	mov	r12,r7
8000bb46:	e0 a0 06 5d 	rcall	8000c800 <__mdiff>
8000bb4a:	18 91       	mov	r1,r12
8000bb4c:	78 38       	ld.w	r8,r12[0xc]
8000bb4e:	58 08       	cp.w	r8,0
8000bb50:	c0 30       	breq	8000bb56 <_dtoa_r+0xa0a>
8000bb52:	30 16       	mov	r6,1
8000bb54:	c0 68       	rjmp	8000bb60 <_dtoa_r+0xa14>
8000bb56:	18 9b       	mov	r11,r12
8000bb58:	06 9c       	mov	r12,r3
8000bb5a:	e0 a0 05 98 	rcall	8000c68a <__mcmp>
8000bb5e:	18 96       	mov	r6,r12
8000bb60:	0e 9c       	mov	r12,r7
8000bb62:	02 9b       	mov	r11,r1
8000bb64:	e0 a0 05 ac 	rcall	8000c6bc <_Bfree>
8000bb68:	40 cc       	lddsp	r12,sp[0x30]
8000bb6a:	ed ec 10 08 	or	r8,r6,r12
8000bb6e:	c0 d1       	brne	8000bb88 <_dtoa_r+0xa3c>
8000bb70:	40 db       	lddsp	r11,sp[0x34]
8000bb72:	58 0b       	cp.w	r11,0
8000bb74:	c0 a1       	brne	8000bb88 <_dtoa_r+0xa3c>
8000bb76:	40 26       	lddsp	r6,sp[0x8]
8000bb78:	e0 40 00 39 	cp.w	r0,57
8000bb7c:	c3 00       	breq	8000bbdc <_dtoa_r+0xa90>
8000bb7e:	40 6a       	lddsp	r10,sp[0x18]
8000bb80:	58 0a       	cp.w	r10,0
8000bb82:	e0 89 00 24 	brgt	8000bbca <_dtoa_r+0xa7e>
8000bb86:	c2 f8       	rjmp	8000bbe4 <_dtoa_r+0xa98>
8000bb88:	40 69       	lddsp	r9,sp[0x18]
8000bb8a:	58 09       	cp.w	r9,0
8000bb8c:	c0 85       	brlt	8000bb9c <_dtoa_r+0xa50>
8000bb8e:	12 98       	mov	r8,r9
8000bb90:	40 cc       	lddsp	r12,sp[0x30]
8000bb92:	18 48       	or	r8,r12
8000bb94:	c1 d1       	brne	8000bbce <_dtoa_r+0xa82>
8000bb96:	40 db       	lddsp	r11,sp[0x34]
8000bb98:	58 0b       	cp.w	r11,0
8000bb9a:	c1 a1       	brne	8000bbce <_dtoa_r+0xa82>
8000bb9c:	0c 99       	mov	r9,r6
8000bb9e:	40 26       	lddsp	r6,sp[0x8]
8000bba0:	58 09       	cp.w	r9,0
8000bba2:	e0 8a 00 21 	brle	8000bbe4 <_dtoa_r+0xa98>
8000bba6:	06 9b       	mov	r11,r3
8000bba8:	30 1a       	mov	r10,1
8000bbaa:	0e 9c       	mov	r12,r7
8000bbac:	e0 a0 06 92 	rcall	8000c8d0 <__lshift>
8000bbb0:	04 9b       	mov	r11,r2
8000bbb2:	18 93       	mov	r3,r12
8000bbb4:	e0 a0 05 6b 	rcall	8000c68a <__mcmp>
8000bbb8:	e0 89 00 06 	brgt	8000bbc4 <_dtoa_r+0xa78>
8000bbbc:	c1 41       	brne	8000bbe4 <_dtoa_r+0xa98>
8000bbbe:	ed b0 00 00 	bld	r0,0x0
8000bbc2:	c1 11       	brne	8000bbe4 <_dtoa_r+0xa98>
8000bbc4:	e0 40 00 39 	cp.w	r0,57
8000bbc8:	c0 a0       	breq	8000bbdc <_dtoa_r+0xa90>
8000bbca:	2f f0       	sub	r0,-1
8000bbcc:	c0 c8       	rjmp	8000bbe4 <_dtoa_r+0xa98>
8000bbce:	58 06       	cp.w	r6,0
8000bbd0:	e0 8a 00 0c 	brle	8000bbe8 <_dtoa_r+0xa9c>
8000bbd4:	40 26       	lddsp	r6,sp[0x8]
8000bbd6:	e0 40 00 39 	cp.w	r0,57
8000bbda:	c0 41       	brne	8000bbe2 <_dtoa_r+0xa96>
8000bbdc:	33 98       	mov	r8,57
8000bbde:	0a c8       	st.b	r5++,r8
8000bbe0:	c6 78       	rjmp	8000bcae <_dtoa_r+0xb62>
8000bbe2:	2f f0       	sub	r0,-1
8000bbe4:	0a c0       	st.b	r5++,r0
8000bbe6:	c7 58       	rjmp	8000bcd0 <_dtoa_r+0xb84>
8000bbe8:	0a c0       	st.b	r5++,r0
8000bbea:	40 9a       	lddsp	r10,sp[0x24]
8000bbec:	40 e9       	lddsp	r9,sp[0x38]
8000bbee:	12 3a       	cp.w	r10,r9
8000bbf0:	c4 30       	breq	8000bc76 <_dtoa_r+0xb2a>
8000bbf2:	06 9b       	mov	r11,r3
8000bbf4:	30 09       	mov	r9,0
8000bbf6:	30 aa       	mov	r10,10
8000bbf8:	0e 9c       	mov	r12,r7
8000bbfa:	e0 a0 07 37 	rcall	8000ca68 <__multadd>
8000bbfe:	40 48       	lddsp	r8,sp[0x10]
8000bc00:	18 93       	mov	r3,r12
8000bc02:	08 38       	cp.w	r8,r4
8000bc04:	c0 91       	brne	8000bc16 <_dtoa_r+0xaca>
8000bc06:	10 9b       	mov	r11,r8
8000bc08:	30 09       	mov	r9,0
8000bc0a:	30 aa       	mov	r10,10
8000bc0c:	0e 9c       	mov	r12,r7
8000bc0e:	e0 a0 07 2d 	rcall	8000ca68 <__multadd>
8000bc12:	50 4c       	stdsp	sp[0x10],r12
8000bc14:	c0 e8       	rjmp	8000bc30 <_dtoa_r+0xae4>
8000bc16:	40 4b       	lddsp	r11,sp[0x10]
8000bc18:	30 09       	mov	r9,0
8000bc1a:	30 aa       	mov	r10,10
8000bc1c:	0e 9c       	mov	r12,r7
8000bc1e:	e0 a0 07 25 	rcall	8000ca68 <__multadd>
8000bc22:	08 9b       	mov	r11,r4
8000bc24:	50 4c       	stdsp	sp[0x10],r12
8000bc26:	30 09       	mov	r9,0
8000bc28:	30 aa       	mov	r10,10
8000bc2a:	0e 9c       	mov	r12,r7
8000bc2c:	e0 a0 07 1e 	rcall	8000ca68 <__multadd>
8000bc30:	18 94       	mov	r4,r12
8000bc32:	40 9c       	lddsp	r12,sp[0x24]
8000bc34:	2f fc       	sub	r12,-1
8000bc36:	50 9c       	stdsp	sp[0x24],r12
8000bc38:	c7 9b       	rjmp	8000bb2a <_dtoa_r+0x9de>
8000bc3a:	30 18       	mov	r8,1
8000bc3c:	06 90       	mov	r0,r3
8000bc3e:	40 85       	lddsp	r5,sp[0x20]
8000bc40:	08 93       	mov	r3,r4
8000bc42:	0c 94       	mov	r4,r6
8000bc44:	10 96       	mov	r6,r8
8000bc46:	04 9b       	mov	r11,r2
8000bc48:	00 9c       	mov	r12,r0
8000bc4a:	fe b0 f9 f1 	rcall	8000b02c <quorem>
8000bc4e:	2d 0c       	sub	r12,-48
8000bc50:	0a cc       	st.b	r5++,r12
8000bc52:	02 36       	cp.w	r6,r1
8000bc54:	c0 a4       	brge	8000bc68 <_dtoa_r+0xb1c>
8000bc56:	00 9b       	mov	r11,r0
8000bc58:	30 09       	mov	r9,0
8000bc5a:	30 aa       	mov	r10,10
8000bc5c:	0e 9c       	mov	r12,r7
8000bc5e:	2f f6       	sub	r6,-1
8000bc60:	e0 a0 07 04 	rcall	8000ca68 <__multadd>
8000bc64:	18 90       	mov	r0,r12
8000bc66:	cf 0b       	rjmp	8000bc46 <_dtoa_r+0xafa>
8000bc68:	08 96       	mov	r6,r4
8000bc6a:	30 0b       	mov	r11,0
8000bc6c:	06 94       	mov	r4,r3
8000bc6e:	50 4b       	stdsp	sp[0x10],r11
8000bc70:	00 93       	mov	r3,r0
8000bc72:	18 90       	mov	r0,r12
8000bc74:	c0 28       	rjmp	8000bc78 <_dtoa_r+0xb2c>
8000bc76:	40 26       	lddsp	r6,sp[0x8]
8000bc78:	06 9b       	mov	r11,r3
8000bc7a:	30 1a       	mov	r10,1
8000bc7c:	0e 9c       	mov	r12,r7
8000bc7e:	e0 a0 06 29 	rcall	8000c8d0 <__lshift>
8000bc82:	04 9b       	mov	r11,r2
8000bc84:	18 93       	mov	r3,r12
8000bc86:	e0 a0 05 02 	rcall	8000c68a <__mcmp>
8000bc8a:	e0 89 00 12 	brgt	8000bcae <_dtoa_r+0xb62>
8000bc8e:	c1 b1       	brne	8000bcc4 <_dtoa_r+0xb78>
8000bc90:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bc94:	c0 d1       	brne	8000bcae <_dtoa_r+0xb62>
8000bc96:	c1 78       	rjmp	8000bcc4 <_dtoa_r+0xb78>
8000bc98:	40 89       	lddsp	r9,sp[0x20]
8000bc9a:	12 38       	cp.w	r8,r9
8000bc9c:	c0 30       	breq	8000bca2 <_dtoa_r+0xb56>
8000bc9e:	10 95       	mov	r5,r8
8000bca0:	c0 88       	rjmp	8000bcb0 <_dtoa_r+0xb64>
8000bca2:	2f f6       	sub	r6,-1
8000bca4:	50 66       	stdsp	sp[0x18],r6
8000bca6:	33 18       	mov	r8,49
8000bca8:	40 8c       	lddsp	r12,sp[0x20]
8000bcaa:	b8 88       	st.b	r12[0x0],r8
8000bcac:	c1 38       	rjmp	8000bcd2 <_dtoa_r+0xb86>
8000bcae:	33 9a       	mov	r10,57
8000bcb0:	0a 98       	mov	r8,r5
8000bcb2:	11 79       	ld.ub	r9,--r8
8000bcb4:	f4 09 18 00 	cp.b	r9,r10
8000bcb8:	cf 00       	breq	8000bc98 <_dtoa_r+0xb4c>
8000bcba:	2f f9       	sub	r9,-1
8000bcbc:	b0 89       	st.b	r8[0x0],r9
8000bcbe:	c0 98       	rjmp	8000bcd0 <_dtoa_r+0xb84>
8000bcc0:	10 95       	mov	r5,r8
8000bcc2:	c0 28       	rjmp	8000bcc6 <_dtoa_r+0xb7a>
8000bcc4:	33 09       	mov	r9,48
8000bcc6:	0a 98       	mov	r8,r5
8000bcc8:	11 7a       	ld.ub	r10,--r8
8000bcca:	f2 0a 18 00 	cp.b	r10,r9
8000bcce:	cf 90       	breq	8000bcc0 <_dtoa_r+0xb74>
8000bcd0:	50 66       	stdsp	sp[0x18],r6
8000bcd2:	04 9b       	mov	r11,r2
8000bcd4:	0e 9c       	mov	r12,r7
8000bcd6:	e0 a0 04 f3 	rcall	8000c6bc <_Bfree>
8000bcda:	58 04       	cp.w	r4,0
8000bcdc:	c1 20       	breq	8000bd00 <_dtoa_r+0xbb4>
8000bcde:	40 4b       	lddsp	r11,sp[0x10]
8000bce0:	08 3b       	cp.w	r11,r4
8000bce2:	5f 19       	srne	r9
8000bce4:	58 0b       	cp.w	r11,0
8000bce6:	5f 18       	srne	r8
8000bce8:	f3 e8 00 08 	and	r8,r9,r8
8000bcec:	c0 40       	breq	8000bcf4 <_dtoa_r+0xba8>
8000bcee:	0e 9c       	mov	r12,r7
8000bcf0:	e0 a0 04 e6 	rcall	8000c6bc <_Bfree>
8000bcf4:	08 9b       	mov	r11,r4
8000bcf6:	0e 9c       	mov	r12,r7
8000bcf8:	e0 a0 04 e2 	rcall	8000c6bc <_Bfree>
8000bcfc:	c0 28       	rjmp	8000bd00 <_dtoa_r+0xbb4>
8000bcfe:	50 66       	stdsp	sp[0x18],r6
8000bd00:	0e 9c       	mov	r12,r7
8000bd02:	06 9b       	mov	r11,r3
8000bd04:	e0 a0 04 dc 	rcall	8000c6bc <_Bfree>
8000bd08:	30 08       	mov	r8,0
8000bd0a:	aa 88       	st.b	r5[0x0],r8
8000bd0c:	40 68       	lddsp	r8,sp[0x18]
8000bd0e:	41 5a       	lddsp	r10,sp[0x54]
8000bd10:	2f f8       	sub	r8,-1
8000bd12:	41 29       	lddsp	r9,sp[0x48]
8000bd14:	95 08       	st.w	r10[0x0],r8
8000bd16:	40 8c       	lddsp	r12,sp[0x20]
8000bd18:	58 09       	cp.w	r9,0
8000bd1a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bd1e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bd22:	2e 6d       	sub	sp,-104
8000bd24:	d8 32       	popm	r0-r7,pc
8000bd26:	d7 03       	nop

8000bd28 <__errno>:
8000bd28:	e0 68 0a 54 	mov	r8,2644
8000bd2c:	70 0c       	ld.w	r12,r8[0x0]
8000bd2e:	2f 4c       	sub	r12,-12
8000bd30:	5e fc       	retal	r12
8000bd32:	d7 03       	nop

8000bd34 <_fflush_r>:
8000bd34:	d4 21       	pushm	r4-r7,lr
8000bd36:	16 97       	mov	r7,r11
8000bd38:	18 96       	mov	r6,r12
8000bd3a:	76 48       	ld.w	r8,r11[0x10]
8000bd3c:	58 08       	cp.w	r8,0
8000bd3e:	c7 f0       	breq	8000be3c <_fflush_r+0x108>
8000bd40:	58 0c       	cp.w	r12,0
8000bd42:	c0 50       	breq	8000bd4c <_fflush_r+0x18>
8000bd44:	78 68       	ld.w	r8,r12[0x18]
8000bd46:	58 08       	cp.w	r8,0
8000bd48:	c0 21       	brne	8000bd4c <_fflush_r+0x18>
8000bd4a:	cc dc       	rcall	8000bee4 <__sinit>
8000bd4c:	fe c8 c8 dc 	sub	r8,pc,-14116
8000bd50:	10 37       	cp.w	r7,r8
8000bd52:	c0 31       	brne	8000bd58 <_fflush_r+0x24>
8000bd54:	6c 07       	ld.w	r7,r6[0x0]
8000bd56:	c0 c8       	rjmp	8000bd6e <_fflush_r+0x3a>
8000bd58:	fe c8 c8 c8 	sub	r8,pc,-14136
8000bd5c:	10 37       	cp.w	r7,r8
8000bd5e:	c0 31       	brne	8000bd64 <_fflush_r+0x30>
8000bd60:	6c 17       	ld.w	r7,r6[0x4]
8000bd62:	c0 68       	rjmp	8000bd6e <_fflush_r+0x3a>
8000bd64:	fe c8 c8 b4 	sub	r8,pc,-14156
8000bd68:	10 37       	cp.w	r7,r8
8000bd6a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bd6e:	8e 6a       	ld.sh	r10,r7[0xc]
8000bd70:	14 98       	mov	r8,r10
8000bd72:	ed ba 00 03 	bld	r10,0x3
8000bd76:	c4 20       	breq	8000bdfa <_fflush_r+0xc6>
8000bd78:	ab ba       	sbr	r10,0xb
8000bd7a:	ae 6a       	st.h	r7[0xc],r10
8000bd7c:	6e 18       	ld.w	r8,r7[0x4]
8000bd7e:	58 08       	cp.w	r8,0
8000bd80:	e0 89 00 06 	brgt	8000bd8c <_fflush_r+0x58>
8000bd84:	6f 08       	ld.w	r8,r7[0x40]
8000bd86:	58 08       	cp.w	r8,0
8000bd88:	e0 8a 00 5a 	brle	8000be3c <_fflush_r+0x108>
8000bd8c:	6e b8       	ld.w	r8,r7[0x2c]
8000bd8e:	58 08       	cp.w	r8,0
8000bd90:	c5 60       	breq	8000be3c <_fflush_r+0x108>
8000bd92:	e2 1a 10 00 	andl	r10,0x1000,COH
8000bd96:	c0 30       	breq	8000bd9c <_fflush_r+0x68>
8000bd98:	6f 55       	ld.w	r5,r7[0x54]
8000bd9a:	c0 f8       	rjmp	8000bdb8 <_fflush_r+0x84>
8000bd9c:	30 19       	mov	r9,1
8000bd9e:	6e 8b       	ld.w	r11,r7[0x20]
8000bda0:	0c 9c       	mov	r12,r6
8000bda2:	5d 18       	icall	r8
8000bda4:	18 95       	mov	r5,r12
8000bda6:	5b fc       	cp.w	r12,-1
8000bda8:	c0 81       	brne	8000bdb8 <_fflush_r+0x84>
8000bdaa:	6c 38       	ld.w	r8,r6[0xc]
8000bdac:	59 d8       	cp.w	r8,29
8000bdae:	c4 70       	breq	8000be3c <_fflush_r+0x108>
8000bdb0:	8e 68       	ld.sh	r8,r7[0xc]
8000bdb2:	a7 a8       	sbr	r8,0x6
8000bdb4:	ae 68       	st.h	r7[0xc],r8
8000bdb6:	d8 22       	popm	r4-r7,pc
8000bdb8:	8e 68       	ld.sh	r8,r7[0xc]
8000bdba:	ed b8 00 02 	bld	r8,0x2
8000bdbe:	c0 91       	brne	8000bdd0 <_fflush_r+0x9c>
8000bdc0:	6e 18       	ld.w	r8,r7[0x4]
8000bdc2:	10 15       	sub	r5,r8
8000bdc4:	6e d8       	ld.w	r8,r7[0x34]
8000bdc6:	58 08       	cp.w	r8,0
8000bdc8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000bdcc:	eb d8 e1 15 	subne	r5,r5,r8
8000bdd0:	6e b8       	ld.w	r8,r7[0x2c]
8000bdd2:	0c 9c       	mov	r12,r6
8000bdd4:	30 09       	mov	r9,0
8000bdd6:	0a 9a       	mov	r10,r5
8000bdd8:	6e 8b       	ld.w	r11,r7[0x20]
8000bdda:	5d 18       	icall	r8
8000bddc:	8e 68       	ld.sh	r8,r7[0xc]
8000bdde:	0a 3c       	cp.w	r12,r5
8000bde0:	c2 61       	brne	8000be2c <_fflush_r+0xf8>
8000bde2:	ab d8       	cbr	r8,0xb
8000bde4:	30 0c       	mov	r12,0
8000bde6:	6e 49       	ld.w	r9,r7[0x10]
8000bde8:	ae 68       	st.h	r7[0xc],r8
8000bdea:	8f 1c       	st.w	r7[0x4],r12
8000bdec:	8f 09       	st.w	r7[0x0],r9
8000bdee:	ed b8 00 0c 	bld	r8,0xc
8000bdf2:	c2 51       	brne	8000be3c <_fflush_r+0x108>
8000bdf4:	ef 45 00 54 	st.w	r7[84],r5
8000bdf8:	d8 22       	popm	r4-r7,pc
8000bdfa:	6e 45       	ld.w	r5,r7[0x10]
8000bdfc:	58 05       	cp.w	r5,0
8000bdfe:	c1 f0       	breq	8000be3c <_fflush_r+0x108>
8000be00:	6e 04       	ld.w	r4,r7[0x0]
8000be02:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000be06:	8f 05       	st.w	r7[0x0],r5
8000be08:	f9 b8 01 00 	movne	r8,0
8000be0c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000be10:	0a 14       	sub	r4,r5
8000be12:	8f 28       	st.w	r7[0x8],r8
8000be14:	c1 18       	rjmp	8000be36 <_fflush_r+0x102>
8000be16:	08 99       	mov	r9,r4
8000be18:	0a 9a       	mov	r10,r5
8000be1a:	6e a8       	ld.w	r8,r7[0x28]
8000be1c:	6e 8b       	ld.w	r11,r7[0x20]
8000be1e:	0c 9c       	mov	r12,r6
8000be20:	5d 18       	icall	r8
8000be22:	18 14       	sub	r4,r12
8000be24:	58 0c       	cp.w	r12,0
8000be26:	e0 89 00 07 	brgt	8000be34 <_fflush_r+0x100>
8000be2a:	8e 68       	ld.sh	r8,r7[0xc]
8000be2c:	a7 a8       	sbr	r8,0x6
8000be2e:	3f fc       	mov	r12,-1
8000be30:	ae 68       	st.h	r7[0xc],r8
8000be32:	d8 22       	popm	r4-r7,pc
8000be34:	18 05       	add	r5,r12
8000be36:	58 04       	cp.w	r4,0
8000be38:	fe 99 ff ef 	brgt	8000be16 <_fflush_r+0xe2>
8000be3c:	d8 2a       	popm	r4-r7,pc,r12=0
8000be3e:	d7 03       	nop

8000be40 <__sfp_lock_acquire>:
8000be40:	5e fc       	retal	r12

8000be42 <__sfp_lock_release>:
8000be42:	5e fc       	retal	r12

8000be44 <_cleanup_r>:
8000be44:	d4 01       	pushm	lr
8000be46:	fe cb f0 ae 	sub	r11,pc,-3922
8000be4a:	e0 a0 02 f7 	rcall	8000c438 <_fwalk>
8000be4e:	d8 02       	popm	pc

8000be50 <__sfmoreglue>:
8000be50:	d4 21       	pushm	r4-r7,lr
8000be52:	16 95       	mov	r5,r11
8000be54:	f6 06 10 5c 	mul	r6,r11,92
8000be58:	ec cb ff f4 	sub	r11,r6,-12
8000be5c:	fe b0 e2 76 	rcall	80008348 <_malloc_r>
8000be60:	18 97       	mov	r7,r12
8000be62:	c0 90       	breq	8000be74 <__sfmoreglue+0x24>
8000be64:	99 15       	st.w	r12[0x4],r5
8000be66:	30 0b       	mov	r11,0
8000be68:	2f 4c       	sub	r12,-12
8000be6a:	0c 9a       	mov	r10,r6
8000be6c:	8f 2c       	st.w	r7[0x8],r12
8000be6e:	8f 0b       	st.w	r7[0x0],r11
8000be70:	fe b0 e5 3f 	rcall	800088ee <memset>
8000be74:	0e 9c       	mov	r12,r7
8000be76:	d8 22       	popm	r4-r7,pc

8000be78 <__sfp>:
8000be78:	d4 21       	pushm	r4-r7,lr
8000be7a:	fe c8 c9 a6 	sub	r8,pc,-13914
8000be7e:	18 96       	mov	r6,r12
8000be80:	70 07       	ld.w	r7,r8[0x0]
8000be82:	6e 68       	ld.w	r8,r7[0x18]
8000be84:	58 08       	cp.w	r8,0
8000be86:	c0 31       	brne	8000be8c <__sfp+0x14>
8000be88:	0e 9c       	mov	r12,r7
8000be8a:	c2 dc       	rcall	8000bee4 <__sinit>
8000be8c:	ee c7 ff 28 	sub	r7,r7,-216
8000be90:	30 05       	mov	r5,0
8000be92:	6e 2c       	ld.w	r12,r7[0x8]
8000be94:	6e 18       	ld.w	r8,r7[0x4]
8000be96:	c0 68       	rjmp	8000bea2 <__sfp+0x2a>
8000be98:	98 69       	ld.sh	r9,r12[0xc]
8000be9a:	ea 09 19 00 	cp.h	r9,r5
8000be9e:	c1 10       	breq	8000bec0 <__sfp+0x48>
8000bea0:	2a 4c       	sub	r12,-92
8000bea2:	20 18       	sub	r8,1
8000bea4:	cf a7       	brpl	8000be98 <__sfp+0x20>
8000bea6:	6e 08       	ld.w	r8,r7[0x0]
8000bea8:	58 08       	cp.w	r8,0
8000beaa:	c0 61       	brne	8000beb6 <__sfp+0x3e>
8000beac:	30 4b       	mov	r11,4
8000beae:	0c 9c       	mov	r12,r6
8000beb0:	cd 0f       	rcall	8000be50 <__sfmoreglue>
8000beb2:	8f 0c       	st.w	r7[0x0],r12
8000beb4:	c0 30       	breq	8000beba <__sfp+0x42>
8000beb6:	6e 07       	ld.w	r7,r7[0x0]
8000beb8:	ce db       	rjmp	8000be92 <__sfp+0x1a>
8000beba:	30 c8       	mov	r8,12
8000bebc:	8d 38       	st.w	r6[0xc],r8
8000bebe:	d8 22       	popm	r4-r7,pc
8000bec0:	30 08       	mov	r8,0
8000bec2:	f9 48 00 4c 	st.w	r12[76],r8
8000bec6:	99 08       	st.w	r12[0x0],r8
8000bec8:	99 28       	st.w	r12[0x8],r8
8000beca:	99 18       	st.w	r12[0x4],r8
8000becc:	99 48       	st.w	r12[0x10],r8
8000bece:	99 58       	st.w	r12[0x14],r8
8000bed0:	99 68       	st.w	r12[0x18],r8
8000bed2:	99 d8       	st.w	r12[0x34],r8
8000bed4:	99 e8       	st.w	r12[0x38],r8
8000bed6:	f9 48 00 48 	st.w	r12[72],r8
8000beda:	3f f8       	mov	r8,-1
8000bedc:	b8 78       	st.h	r12[0xe],r8
8000bede:	30 18       	mov	r8,1
8000bee0:	b8 68       	st.h	r12[0xc],r8
8000bee2:	d8 22       	popm	r4-r7,pc

8000bee4 <__sinit>:
8000bee4:	d4 21       	pushm	r4-r7,lr
8000bee6:	18 96       	mov	r6,r12
8000bee8:	78 67       	ld.w	r7,r12[0x18]
8000beea:	58 07       	cp.w	r7,0
8000beec:	c4 91       	brne	8000bf7e <__sinit+0x9a>
8000beee:	fe c8 00 aa 	sub	r8,pc,170
8000bef2:	30 15       	mov	r5,1
8000bef4:	99 a8       	st.w	r12[0x28],r8
8000bef6:	f9 47 00 d8 	st.w	r12[216],r7
8000befa:	f9 47 00 dc 	st.w	r12[220],r7
8000befe:	f9 47 00 e0 	st.w	r12[224],r7
8000bf02:	99 65       	st.w	r12[0x18],r5
8000bf04:	cb af       	rcall	8000be78 <__sfp>
8000bf06:	8d 0c       	st.w	r6[0x0],r12
8000bf08:	0c 9c       	mov	r12,r6
8000bf0a:	cb 7f       	rcall	8000be78 <__sfp>
8000bf0c:	8d 1c       	st.w	r6[0x4],r12
8000bf0e:	0c 9c       	mov	r12,r6
8000bf10:	cb 4f       	rcall	8000be78 <__sfp>
8000bf12:	6c 09       	ld.w	r9,r6[0x0]
8000bf14:	30 48       	mov	r8,4
8000bf16:	93 07       	st.w	r9[0x0],r7
8000bf18:	b2 68       	st.h	r9[0xc],r8
8000bf1a:	93 17       	st.w	r9[0x4],r7
8000bf1c:	93 27       	st.w	r9[0x8],r7
8000bf1e:	6c 18       	ld.w	r8,r6[0x4]
8000bf20:	b2 77       	st.h	r9[0xe],r7
8000bf22:	93 47       	st.w	r9[0x10],r7
8000bf24:	93 57       	st.w	r9[0x14],r7
8000bf26:	93 67       	st.w	r9[0x18],r7
8000bf28:	93 89       	st.w	r9[0x20],r9
8000bf2a:	91 07       	st.w	r8[0x0],r7
8000bf2c:	91 17       	st.w	r8[0x4],r7
8000bf2e:	91 27       	st.w	r8[0x8],r7
8000bf30:	fe ce f3 24 	sub	lr,pc,-3292
8000bf34:	fe cb f3 54 	sub	r11,pc,-3244
8000bf38:	93 9e       	st.w	r9[0x24],lr
8000bf3a:	93 ab       	st.w	r9[0x28],r11
8000bf3c:	fe ca f3 7c 	sub	r10,pc,-3204
8000bf40:	fe c4 f3 88 	sub	r4,pc,-3192
8000bf44:	93 ba       	st.w	r9[0x2c],r10
8000bf46:	93 c4       	st.w	r9[0x30],r4
8000bf48:	30 99       	mov	r9,9
8000bf4a:	b0 69       	st.h	r8[0xc],r9
8000bf4c:	b0 75       	st.h	r8[0xe],r5
8000bf4e:	91 c4       	st.w	r8[0x30],r4
8000bf50:	91 47       	st.w	r8[0x10],r7
8000bf52:	91 57       	st.w	r8[0x14],r7
8000bf54:	91 67       	st.w	r8[0x18],r7
8000bf56:	91 88       	st.w	r8[0x20],r8
8000bf58:	91 9e       	st.w	r8[0x24],lr
8000bf5a:	91 ab       	st.w	r8[0x28],r11
8000bf5c:	91 ba       	st.w	r8[0x2c],r10
8000bf5e:	8d 2c       	st.w	r6[0x8],r12
8000bf60:	31 28       	mov	r8,18
8000bf62:	99 07       	st.w	r12[0x0],r7
8000bf64:	b8 68       	st.h	r12[0xc],r8
8000bf66:	99 17       	st.w	r12[0x4],r7
8000bf68:	99 27       	st.w	r12[0x8],r7
8000bf6a:	30 28       	mov	r8,2
8000bf6c:	b8 78       	st.h	r12[0xe],r8
8000bf6e:	99 c4       	st.w	r12[0x30],r4
8000bf70:	99 67       	st.w	r12[0x18],r7
8000bf72:	99 9e       	st.w	r12[0x24],lr
8000bf74:	99 ab       	st.w	r12[0x28],r11
8000bf76:	99 ba       	st.w	r12[0x2c],r10
8000bf78:	99 47       	st.w	r12[0x10],r7
8000bf7a:	99 57       	st.w	r12[0x14],r7
8000bf7c:	99 8c       	st.w	r12[0x20],r12
8000bf7e:	d8 22       	popm	r4-r7,pc

8000bf80 <_malloc_trim_r>:
8000bf80:	d4 21       	pushm	r4-r7,lr
8000bf82:	16 95       	mov	r5,r11
8000bf84:	18 97       	mov	r7,r12
8000bf86:	fe b0 d7 8b 	rcall	80006e9c <__malloc_lock>
8000bf8a:	e0 64 05 54 	mov	r4,1364
8000bf8e:	68 28       	ld.w	r8,r4[0x8]
8000bf90:	70 16       	ld.w	r6,r8[0x4]
8000bf92:	e0 16 ff fc 	andl	r6,0xfffc
8000bf96:	ec c8 ff 91 	sub	r8,r6,-111
8000bf9a:	f0 05 01 05 	sub	r5,r8,r5
8000bf9e:	e0 15 ff 80 	andl	r5,0xff80
8000bfa2:	ea c5 00 80 	sub	r5,r5,128
8000bfa6:	e0 45 00 7f 	cp.w	r5,127
8000bfaa:	e0 8a 00 25 	brle	8000bff4 <_malloc_trim_r+0x74>
8000bfae:	30 0b       	mov	r11,0
8000bfb0:	0e 9c       	mov	r12,r7
8000bfb2:	fe b0 e6 05 	rcall	80008bbc <_sbrk_r>
8000bfb6:	68 28       	ld.w	r8,r4[0x8]
8000bfb8:	0c 08       	add	r8,r6
8000bfba:	10 3c       	cp.w	r12,r8
8000bfbc:	c1 c1       	brne	8000bff4 <_malloc_trim_r+0x74>
8000bfbe:	ea 0b 11 00 	rsub	r11,r5,0
8000bfc2:	0e 9c       	mov	r12,r7
8000bfc4:	fe b0 e5 fc 	rcall	80008bbc <_sbrk_r>
8000bfc8:	5b fc       	cp.w	r12,-1
8000bfca:	c1 91       	brne	8000bffc <_malloc_trim_r+0x7c>
8000bfcc:	30 0b       	mov	r11,0
8000bfce:	0e 9c       	mov	r12,r7
8000bfd0:	fe b0 e5 f6 	rcall	80008bbc <_sbrk_r>
8000bfd4:	68 28       	ld.w	r8,r4[0x8]
8000bfd6:	f8 08 01 09 	sub	r9,r12,r8
8000bfda:	58 f9       	cp.w	r9,15
8000bfdc:	e0 8a 00 0c 	brle	8000bff4 <_malloc_trim_r+0x74>
8000bfe0:	a1 a9       	sbr	r9,0x0
8000bfe2:	91 19       	st.w	r8[0x4],r9
8000bfe4:	e0 68 09 60 	mov	r8,2400
8000bfe8:	70 09       	ld.w	r9,r8[0x0]
8000bfea:	e0 68 0d f0 	mov	r8,3568
8000bfee:	f8 09 01 09 	sub	r9,r12,r9
8000bff2:	91 09       	st.w	r8[0x0],r9
8000bff4:	0e 9c       	mov	r12,r7
8000bff6:	fe b0 d7 59 	rcall	80006ea8 <__malloc_unlock>
8000bffa:	d8 2a       	popm	r4-r7,pc,r12=0
8000bffc:	68 28       	ld.w	r8,r4[0x8]
8000bffe:	0a 16       	sub	r6,r5
8000c000:	a1 a6       	sbr	r6,0x0
8000c002:	91 16       	st.w	r8[0x4],r6
8000c004:	e0 68 0d f0 	mov	r8,3568
8000c008:	70 09       	ld.w	r9,r8[0x0]
8000c00a:	0a 19       	sub	r9,r5
8000c00c:	0e 9c       	mov	r12,r7
8000c00e:	91 09       	st.w	r8[0x0],r9
8000c010:	fe b0 d7 4c 	rcall	80006ea8 <__malloc_unlock>
8000c014:	da 2a       	popm	r4-r7,pc,r12=1
8000c016:	d7 03       	nop

8000c018 <_free_r>:
8000c018:	d4 21       	pushm	r4-r7,lr
8000c01a:	16 96       	mov	r6,r11
8000c01c:	18 97       	mov	r7,r12
8000c01e:	58 0b       	cp.w	r11,0
8000c020:	e0 80 00 c0 	breq	8000c1a0 <_free_r+0x188>
8000c024:	fe b0 d7 3c 	rcall	80006e9c <__malloc_lock>
8000c028:	20 86       	sub	r6,8
8000c02a:	e0 6a 05 54 	mov	r10,1364
8000c02e:	6c 18       	ld.w	r8,r6[0x4]
8000c030:	74 2e       	ld.w	lr,r10[0x8]
8000c032:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000c036:	a1 c8       	cbr	r8,0x0
8000c038:	ec 08 00 09 	add	r9,r6,r8
8000c03c:	72 1b       	ld.w	r11,r9[0x4]
8000c03e:	e0 1b ff fc 	andl	r11,0xfffc
8000c042:	1c 39       	cp.w	r9,lr
8000c044:	c1 e1       	brne	8000c080 <_free_r+0x68>
8000c046:	f6 08 00 08 	add	r8,r11,r8
8000c04a:	58 0c       	cp.w	r12,0
8000c04c:	c0 81       	brne	8000c05c <_free_r+0x44>
8000c04e:	6c 09       	ld.w	r9,r6[0x0]
8000c050:	12 16       	sub	r6,r9
8000c052:	12 08       	add	r8,r9
8000c054:	6c 3b       	ld.w	r11,r6[0xc]
8000c056:	6c 29       	ld.w	r9,r6[0x8]
8000c058:	97 29       	st.w	r11[0x8],r9
8000c05a:	93 3b       	st.w	r9[0xc],r11
8000c05c:	10 99       	mov	r9,r8
8000c05e:	95 26       	st.w	r10[0x8],r6
8000c060:	a1 a9       	sbr	r9,0x0
8000c062:	8d 19       	st.w	r6[0x4],r9
8000c064:	e0 69 09 5c 	mov	r9,2396
8000c068:	72 09       	ld.w	r9,r9[0x0]
8000c06a:	12 38       	cp.w	r8,r9
8000c06c:	c0 63       	brcs	8000c078 <_free_r+0x60>
8000c06e:	e0 68 0d ec 	mov	r8,3564
8000c072:	0e 9c       	mov	r12,r7
8000c074:	70 0b       	ld.w	r11,r8[0x0]
8000c076:	c8 5f       	rcall	8000bf80 <_malloc_trim_r>
8000c078:	0e 9c       	mov	r12,r7
8000c07a:	fe b0 d7 17 	rcall	80006ea8 <__malloc_unlock>
8000c07e:	d8 22       	popm	r4-r7,pc
8000c080:	93 1b       	st.w	r9[0x4],r11
8000c082:	58 0c       	cp.w	r12,0
8000c084:	c0 30       	breq	8000c08a <_free_r+0x72>
8000c086:	30 0c       	mov	r12,0
8000c088:	c1 08       	rjmp	8000c0a8 <_free_r+0x90>
8000c08a:	6c 0e       	ld.w	lr,r6[0x0]
8000c08c:	f4 c5 ff f8 	sub	r5,r10,-8
8000c090:	1c 16       	sub	r6,lr
8000c092:	1c 08       	add	r8,lr
8000c094:	6c 2e       	ld.w	lr,r6[0x8]
8000c096:	0a 3e       	cp.w	lr,r5
8000c098:	f9 bc 00 01 	moveq	r12,1
8000c09c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000c0a0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000c0a4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000c0a8:	f2 0b 00 0e 	add	lr,r9,r11
8000c0ac:	7c 1e       	ld.w	lr,lr[0x4]
8000c0ae:	ed be 00 00 	bld	lr,0x0
8000c0b2:	c1 40       	breq	8000c0da <_free_r+0xc2>
8000c0b4:	16 08       	add	r8,r11
8000c0b6:	58 0c       	cp.w	r12,0
8000c0b8:	c0 d1       	brne	8000c0d2 <_free_r+0xba>
8000c0ba:	e0 6e 05 54 	mov	lr,1364
8000c0be:	72 2b       	ld.w	r11,r9[0x8]
8000c0c0:	2f 8e       	sub	lr,-8
8000c0c2:	1c 3b       	cp.w	r11,lr
8000c0c4:	c0 71       	brne	8000c0d2 <_free_r+0xba>
8000c0c6:	97 36       	st.w	r11[0xc],r6
8000c0c8:	97 26       	st.w	r11[0x8],r6
8000c0ca:	8d 2b       	st.w	r6[0x8],r11
8000c0cc:	8d 3b       	st.w	r6[0xc],r11
8000c0ce:	30 1c       	mov	r12,1
8000c0d0:	c0 58       	rjmp	8000c0da <_free_r+0xc2>
8000c0d2:	72 2b       	ld.w	r11,r9[0x8]
8000c0d4:	72 39       	ld.w	r9,r9[0xc]
8000c0d6:	93 2b       	st.w	r9[0x8],r11
8000c0d8:	97 39       	st.w	r11[0xc],r9
8000c0da:	10 99       	mov	r9,r8
8000c0dc:	ec 08 09 08 	st.w	r6[r8],r8
8000c0e0:	a1 a9       	sbr	r9,0x0
8000c0e2:	8d 19       	st.w	r6[0x4],r9
8000c0e4:	58 0c       	cp.w	r12,0
8000c0e6:	c5 a1       	brne	8000c19a <_free_r+0x182>
8000c0e8:	e0 48 01 ff 	cp.w	r8,511
8000c0ec:	e0 8b 00 13 	brhi	8000c112 <_free_r+0xfa>
8000c0f0:	a3 98       	lsr	r8,0x3
8000c0f2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c0f6:	72 2b       	ld.w	r11,r9[0x8]
8000c0f8:	8d 39       	st.w	r6[0xc],r9
8000c0fa:	8d 2b       	st.w	r6[0x8],r11
8000c0fc:	97 36       	st.w	r11[0xc],r6
8000c0fe:	93 26       	st.w	r9[0x8],r6
8000c100:	a3 48       	asr	r8,0x2
8000c102:	74 19       	ld.w	r9,r10[0x4]
8000c104:	30 1b       	mov	r11,1
8000c106:	f6 08 09 48 	lsl	r8,r11,r8
8000c10a:	f3 e8 10 08 	or	r8,r9,r8
8000c10e:	95 18       	st.w	r10[0x4],r8
8000c110:	c4 58       	rjmp	8000c19a <_free_r+0x182>
8000c112:	f0 0b 16 09 	lsr	r11,r8,0x9
8000c116:	58 4b       	cp.w	r11,4
8000c118:	e0 8b 00 06 	brhi	8000c124 <_free_r+0x10c>
8000c11c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c120:	2c 8b       	sub	r11,-56
8000c122:	c2 08       	rjmp	8000c162 <_free_r+0x14a>
8000c124:	59 4b       	cp.w	r11,20
8000c126:	e0 8b 00 04 	brhi	8000c12e <_free_r+0x116>
8000c12a:	2a 5b       	sub	r11,-91
8000c12c:	c1 b8       	rjmp	8000c162 <_free_r+0x14a>
8000c12e:	e0 4b 00 54 	cp.w	r11,84
8000c132:	e0 8b 00 06 	brhi	8000c13e <_free_r+0x126>
8000c136:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c13a:	29 2b       	sub	r11,-110
8000c13c:	c1 38       	rjmp	8000c162 <_free_r+0x14a>
8000c13e:	e0 4b 01 54 	cp.w	r11,340
8000c142:	e0 8b 00 06 	brhi	8000c14e <_free_r+0x136>
8000c146:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c14a:	28 9b       	sub	r11,-119
8000c14c:	c0 b8       	rjmp	8000c162 <_free_r+0x14a>
8000c14e:	e0 4b 05 54 	cp.w	r11,1364
8000c152:	e0 88 00 05 	brls	8000c15c <_free_r+0x144>
8000c156:	37 eb       	mov	r11,126
8000c158:	c0 58       	rjmp	8000c162 <_free_r+0x14a>
8000c15a:	d7 03       	nop
8000c15c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c160:	28 4b       	sub	r11,-124
8000c162:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c166:	78 29       	ld.w	r9,r12[0x8]
8000c168:	18 39       	cp.w	r9,r12
8000c16a:	c0 e1       	brne	8000c186 <_free_r+0x16e>
8000c16c:	74 18       	ld.w	r8,r10[0x4]
8000c16e:	a3 4b       	asr	r11,0x2
8000c170:	30 1c       	mov	r12,1
8000c172:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c176:	f1 eb 10 0b 	or	r11,r8,r11
8000c17a:	12 98       	mov	r8,r9
8000c17c:	95 1b       	st.w	r10[0x4],r11
8000c17e:	c0 a8       	rjmp	8000c192 <_free_r+0x17a>
8000c180:	72 29       	ld.w	r9,r9[0x8]
8000c182:	18 39       	cp.w	r9,r12
8000c184:	c0 60       	breq	8000c190 <_free_r+0x178>
8000c186:	72 1a       	ld.w	r10,r9[0x4]
8000c188:	e0 1a ff fc 	andl	r10,0xfffc
8000c18c:	14 38       	cp.w	r8,r10
8000c18e:	cf 93       	brcs	8000c180 <_free_r+0x168>
8000c190:	72 38       	ld.w	r8,r9[0xc]
8000c192:	8d 38       	st.w	r6[0xc],r8
8000c194:	8d 29       	st.w	r6[0x8],r9
8000c196:	93 36       	st.w	r9[0xc],r6
8000c198:	91 26       	st.w	r8[0x8],r6
8000c19a:	0e 9c       	mov	r12,r7
8000c19c:	fe b0 d6 86 	rcall	80006ea8 <__malloc_unlock>
8000c1a0:	d8 22       	popm	r4-r7,pc
8000c1a2:	d7 03       	nop

8000c1a4 <__sfvwrite_r>:
8000c1a4:	d4 31       	pushm	r0-r7,lr
8000c1a6:	20 3d       	sub	sp,12
8000c1a8:	14 94       	mov	r4,r10
8000c1aa:	18 95       	mov	r5,r12
8000c1ac:	16 97       	mov	r7,r11
8000c1ae:	74 28       	ld.w	r8,r10[0x8]
8000c1b0:	58 08       	cp.w	r8,0
8000c1b2:	e0 80 01 40 	breq	8000c432 <__sfvwrite_r+0x28e>
8000c1b6:	96 68       	ld.sh	r8,r11[0xc]
8000c1b8:	ed b8 00 03 	bld	r8,0x3
8000c1bc:	c0 41       	brne	8000c1c4 <__sfvwrite_r+0x20>
8000c1be:	76 48       	ld.w	r8,r11[0x10]
8000c1c0:	58 08       	cp.w	r8,0
8000c1c2:	c0 c1       	brne	8000c1da <__sfvwrite_r+0x36>
8000c1c4:	0e 9b       	mov	r11,r7
8000c1c6:	0a 9c       	mov	r12,r5
8000c1c8:	fe b0 f6 c4 	rcall	8000af50 <__swsetup_r>
8000c1cc:	c0 70       	breq	8000c1da <__sfvwrite_r+0x36>
8000c1ce:	8e 68       	ld.sh	r8,r7[0xc]
8000c1d0:	a7 a8       	sbr	r8,0x6
8000c1d2:	ae 68       	st.h	r7[0xc],r8
8000c1d4:	30 98       	mov	r8,9
8000c1d6:	8b 38       	st.w	r5[0xc],r8
8000c1d8:	c2 b9       	rjmp	8000c42e <__sfvwrite_r+0x28a>
8000c1da:	8e 63       	ld.sh	r3,r7[0xc]
8000c1dc:	68 00       	ld.w	r0,r4[0x0]
8000c1de:	06 96       	mov	r6,r3
8000c1e0:	e2 16 00 02 	andl	r6,0x2,COH
8000c1e4:	c2 10       	breq	8000c226 <__sfvwrite_r+0x82>
8000c1e6:	30 03       	mov	r3,0
8000c1e8:	e0 62 04 00 	mov	r2,1024
8000c1ec:	06 96       	mov	r6,r3
8000c1ee:	c0 48       	rjmp	8000c1f6 <__sfvwrite_r+0x52>
8000c1f0:	60 03       	ld.w	r3,r0[0x0]
8000c1f2:	60 16       	ld.w	r6,r0[0x4]
8000c1f4:	2f 80       	sub	r0,-8
8000c1f6:	58 06       	cp.w	r6,0
8000c1f8:	cf c0       	breq	8000c1f0 <__sfvwrite_r+0x4c>
8000c1fa:	e0 46 04 00 	cp.w	r6,1024
8000c1fe:	ec 09 17 80 	movls	r9,r6
8000c202:	e4 09 17 b0 	movhi	r9,r2
8000c206:	06 9a       	mov	r10,r3
8000c208:	6e a8       	ld.w	r8,r7[0x28]
8000c20a:	6e 8b       	ld.w	r11,r7[0x20]
8000c20c:	0a 9c       	mov	r12,r5
8000c20e:	5d 18       	icall	r8
8000c210:	18 16       	sub	r6,r12
8000c212:	58 0c       	cp.w	r12,0
8000c214:	e0 8a 01 0a 	brle	8000c428 <__sfvwrite_r+0x284>
8000c218:	68 28       	ld.w	r8,r4[0x8]
8000c21a:	18 18       	sub	r8,r12
8000c21c:	89 28       	st.w	r4[0x8],r8
8000c21e:	e0 80 01 0a 	breq	8000c432 <__sfvwrite_r+0x28e>
8000c222:	18 03       	add	r3,r12
8000c224:	ce 9b       	rjmp	8000c1f6 <__sfvwrite_r+0x52>
8000c226:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c22a:	c0 70       	breq	8000c238 <__sfvwrite_r+0x94>
8000c22c:	50 06       	stdsp	sp[0x0],r6
8000c22e:	0c 93       	mov	r3,r6
8000c230:	0c 91       	mov	r1,r6
8000c232:	50 15       	stdsp	sp[0x4],r5
8000c234:	08 92       	mov	r2,r4
8000c236:	c9 c8       	rjmp	8000c36e <__sfvwrite_r+0x1ca>
8000c238:	06 96       	mov	r6,r3
8000c23a:	08 91       	mov	r1,r4
8000c23c:	c0 48       	rjmp	8000c244 <__sfvwrite_r+0xa0>
8000c23e:	60 03       	ld.w	r3,r0[0x0]
8000c240:	60 16       	ld.w	r6,r0[0x4]
8000c242:	2f 80       	sub	r0,-8
8000c244:	58 06       	cp.w	r6,0
8000c246:	cf c0       	breq	8000c23e <__sfvwrite_r+0x9a>
8000c248:	8e 68       	ld.sh	r8,r7[0xc]
8000c24a:	6e 24       	ld.w	r4,r7[0x8]
8000c24c:	10 99       	mov	r9,r8
8000c24e:	e2 19 02 00 	andl	r9,0x200,COH
8000c252:	c5 50       	breq	8000c2fc <__sfvwrite_r+0x158>
8000c254:	08 36       	cp.w	r6,r4
8000c256:	c4 43       	brcs	8000c2de <__sfvwrite_r+0x13a>
8000c258:	10 99       	mov	r9,r8
8000c25a:	e2 19 04 80 	andl	r9,0x480,COH
8000c25e:	c4 00       	breq	8000c2de <__sfvwrite_r+0x13a>
8000c260:	6e 4b       	ld.w	r11,r7[0x10]
8000c262:	6e 09       	ld.w	r9,r7[0x0]
8000c264:	16 19       	sub	r9,r11
8000c266:	50 09       	stdsp	sp[0x0],r9
8000c268:	6e 59       	ld.w	r9,r7[0x14]
8000c26a:	10 9c       	mov	r12,r8
8000c26c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c270:	30 28       	mov	r8,2
8000c272:	f4 08 0c 08 	divs	r8,r10,r8
8000c276:	fa e9 00 04 	st.d	sp[4],r8
8000c27a:	10 94       	mov	r4,r8
8000c27c:	40 09       	lddsp	r9,sp[0x0]
8000c27e:	e2 1c 04 00 	andl	r12,0x400,COH
8000c282:	2f f9       	sub	r9,-1
8000c284:	0c 09       	add	r9,r6
8000c286:	12 38       	cp.w	r8,r9
8000c288:	f2 04 17 30 	movlo	r4,r9
8000c28c:	58 0c       	cp.w	r12,0
8000c28e:	c1 10       	breq	8000c2b0 <__sfvwrite_r+0x10c>
8000c290:	08 9b       	mov	r11,r4
8000c292:	0a 9c       	mov	r12,r5
8000c294:	fe b0 e0 5a 	rcall	80008348 <_malloc_r>
8000c298:	18 92       	mov	r2,r12
8000c29a:	c1 40       	breq	8000c2c2 <__sfvwrite_r+0x11e>
8000c29c:	40 0a       	lddsp	r10,sp[0x0]
8000c29e:	6e 4b       	ld.w	r11,r7[0x10]
8000c2a0:	fe b0 e2 83 	rcall	800087a6 <memcpy>
8000c2a4:	8e 68       	ld.sh	r8,r7[0xc]
8000c2a6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c2aa:	a7 b8       	sbr	r8,0x7
8000c2ac:	ae 68       	st.h	r7[0xc],r8
8000c2ae:	c0 d8       	rjmp	8000c2c8 <__sfvwrite_r+0x124>
8000c2b0:	08 9a       	mov	r10,r4
8000c2b2:	0a 9c       	mov	r12,r5
8000c2b4:	fe b0 e3 24 	rcall	800088fc <_realloc_r>
8000c2b8:	18 92       	mov	r2,r12
8000c2ba:	c0 71       	brne	8000c2c8 <__sfvwrite_r+0x124>
8000c2bc:	6e 4b       	ld.w	r11,r7[0x10]
8000c2be:	0a 9c       	mov	r12,r5
8000c2c0:	ca ce       	rcall	8000c018 <_free_r>
8000c2c2:	30 c8       	mov	r8,12
8000c2c4:	8b 38       	st.w	r5[0xc],r8
8000c2c6:	cb 18       	rjmp	8000c428 <__sfvwrite_r+0x284>
8000c2c8:	40 0a       	lddsp	r10,sp[0x0]
8000c2ca:	40 09       	lddsp	r9,sp[0x0]
8000c2cc:	e8 0a 01 0a 	sub	r10,r4,r10
8000c2d0:	e4 09 00 08 	add	r8,r2,r9
8000c2d4:	8f 54       	st.w	r7[0x14],r4
8000c2d6:	8f 2a       	st.w	r7[0x8],r10
8000c2d8:	8f 08       	st.w	r7[0x0],r8
8000c2da:	8f 42       	st.w	r7[0x10],r2
8000c2dc:	0c 94       	mov	r4,r6
8000c2de:	08 36       	cp.w	r6,r4
8000c2e0:	ec 04 17 30 	movlo	r4,r6
8000c2e4:	06 9b       	mov	r11,r3
8000c2e6:	08 9a       	mov	r10,r4
8000c2e8:	6e 0c       	ld.w	r12,r7[0x0]
8000c2ea:	c3 ad       	rcall	8000c55e <memmove>
8000c2ec:	6e 08       	ld.w	r8,r7[0x0]
8000c2ee:	08 08       	add	r8,r4
8000c2f0:	8f 08       	st.w	r7[0x0],r8
8000c2f2:	6e 28       	ld.w	r8,r7[0x8]
8000c2f4:	08 18       	sub	r8,r4
8000c2f6:	0c 94       	mov	r4,r6
8000c2f8:	8f 28       	st.w	r7[0x8],r8
8000c2fa:	c2 e8       	rjmp	8000c356 <__sfvwrite_r+0x1b2>
8000c2fc:	08 36       	cp.w	r6,r4
8000c2fe:	5f ba       	srhi	r10
8000c300:	6e 0c       	ld.w	r12,r7[0x0]
8000c302:	6e 48       	ld.w	r8,r7[0x10]
8000c304:	10 3c       	cp.w	r12,r8
8000c306:	5f b8       	srhi	r8
8000c308:	f5 e8 00 08 	and	r8,r10,r8
8000c30c:	f2 08 18 00 	cp.b	r8,r9
8000c310:	c0 d0       	breq	8000c32a <__sfvwrite_r+0x186>
8000c312:	06 9b       	mov	r11,r3
8000c314:	08 9a       	mov	r10,r4
8000c316:	c2 4d       	rcall	8000c55e <memmove>
8000c318:	6e 08       	ld.w	r8,r7[0x0]
8000c31a:	08 08       	add	r8,r4
8000c31c:	0e 9b       	mov	r11,r7
8000c31e:	8f 08       	st.w	r7[0x0],r8
8000c320:	0a 9c       	mov	r12,r5
8000c322:	fe b0 fd 09 	rcall	8000bd34 <_fflush_r>
8000c326:	c1 80       	breq	8000c356 <__sfvwrite_r+0x1b2>
8000c328:	c8 08       	rjmp	8000c428 <__sfvwrite_r+0x284>
8000c32a:	6e 59       	ld.w	r9,r7[0x14]
8000c32c:	12 36       	cp.w	r6,r9
8000c32e:	c0 a3       	brcs	8000c342 <__sfvwrite_r+0x19e>
8000c330:	6e a8       	ld.w	r8,r7[0x28]
8000c332:	06 9a       	mov	r10,r3
8000c334:	6e 8b       	ld.w	r11,r7[0x20]
8000c336:	0a 9c       	mov	r12,r5
8000c338:	5d 18       	icall	r8
8000c33a:	18 94       	mov	r4,r12
8000c33c:	e0 89 00 0d 	brgt	8000c356 <__sfvwrite_r+0x1b2>
8000c340:	c7 48       	rjmp	8000c428 <__sfvwrite_r+0x284>
8000c342:	0c 9a       	mov	r10,r6
8000c344:	06 9b       	mov	r11,r3
8000c346:	c0 cd       	rcall	8000c55e <memmove>
8000c348:	6e 08       	ld.w	r8,r7[0x0]
8000c34a:	0c 08       	add	r8,r6
8000c34c:	0c 94       	mov	r4,r6
8000c34e:	8f 08       	st.w	r7[0x0],r8
8000c350:	6e 28       	ld.w	r8,r7[0x8]
8000c352:	0c 18       	sub	r8,r6
8000c354:	8f 28       	st.w	r7[0x8],r8
8000c356:	62 28       	ld.w	r8,r1[0x8]
8000c358:	08 18       	sub	r8,r4
8000c35a:	83 28       	st.w	r1[0x8],r8
8000c35c:	c6 b0       	breq	8000c432 <__sfvwrite_r+0x28e>
8000c35e:	08 16       	sub	r6,r4
8000c360:	08 03       	add	r3,r4
8000c362:	c7 1b       	rjmp	8000c244 <__sfvwrite_r+0xa0>
8000c364:	60 03       	ld.w	r3,r0[0x0]
8000c366:	60 11       	ld.w	r1,r0[0x4]
8000c368:	30 08       	mov	r8,0
8000c36a:	2f 80       	sub	r0,-8
8000c36c:	50 08       	stdsp	sp[0x0],r8
8000c36e:	58 01       	cp.w	r1,0
8000c370:	cf a0       	breq	8000c364 <__sfvwrite_r+0x1c0>
8000c372:	40 0a       	lddsp	r10,sp[0x0]
8000c374:	58 0a       	cp.w	r10,0
8000c376:	c1 41       	brne	8000c39e <__sfvwrite_r+0x1fa>
8000c378:	e2 c6 ff ff 	sub	r6,r1,-1
8000c37c:	02 9a       	mov	r10,r1
8000c37e:	30 ab       	mov	r11,10
8000c380:	06 9c       	mov	r12,r3
8000c382:	ce 3c       	rcall	8000c548 <memchr>
8000c384:	f8 c8 ff ff 	sub	r8,r12,-1
8000c388:	58 0c       	cp.w	r12,0
8000c38a:	f1 d3 e1 16 	subne	r6,r8,r3
8000c38e:	f9 b9 01 01 	movne	r9,1
8000c392:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c396:	f9 b8 00 01 	moveq	r8,1
8000c39a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c39e:	02 36       	cp.w	r6,r1
8000c3a0:	ec 04 17 80 	movls	r4,r6
8000c3a4:	e2 04 17 b0 	movhi	r4,r1
8000c3a8:	6e 59       	ld.w	r9,r7[0x14]
8000c3aa:	6e 25       	ld.w	r5,r7[0x8]
8000c3ac:	f2 05 00 05 	add	r5,r9,r5
8000c3b0:	0a 34       	cp.w	r4,r5
8000c3b2:	5f 9a       	srgt	r10
8000c3b4:	6e 0c       	ld.w	r12,r7[0x0]
8000c3b6:	6e 48       	ld.w	r8,r7[0x10]
8000c3b8:	10 3c       	cp.w	r12,r8
8000c3ba:	5f b8       	srhi	r8
8000c3bc:	f5 e8 00 08 	and	r8,r10,r8
8000c3c0:	30 0a       	mov	r10,0
8000c3c2:	f4 08 18 00 	cp.b	r8,r10
8000c3c6:	c0 d0       	breq	8000c3e0 <__sfvwrite_r+0x23c>
8000c3c8:	06 9b       	mov	r11,r3
8000c3ca:	0a 9a       	mov	r10,r5
8000c3cc:	cc 9c       	rcall	8000c55e <memmove>
8000c3ce:	6e 08       	ld.w	r8,r7[0x0]
8000c3d0:	0a 08       	add	r8,r5
8000c3d2:	0e 9b       	mov	r11,r7
8000c3d4:	8f 08       	st.w	r7[0x0],r8
8000c3d6:	40 1c       	lddsp	r12,sp[0x4]
8000c3d8:	fe b0 fc ae 	rcall	8000bd34 <_fflush_r>
8000c3dc:	c1 70       	breq	8000c40a <__sfvwrite_r+0x266>
8000c3de:	c2 58       	rjmp	8000c428 <__sfvwrite_r+0x284>
8000c3e0:	12 34       	cp.w	r4,r9
8000c3e2:	c0 a5       	brlt	8000c3f6 <__sfvwrite_r+0x252>
8000c3e4:	6e a8       	ld.w	r8,r7[0x28]
8000c3e6:	06 9a       	mov	r10,r3
8000c3e8:	6e 8b       	ld.w	r11,r7[0x20]
8000c3ea:	40 1c       	lddsp	r12,sp[0x4]
8000c3ec:	5d 18       	icall	r8
8000c3ee:	18 95       	mov	r5,r12
8000c3f0:	e0 89 00 0d 	brgt	8000c40a <__sfvwrite_r+0x266>
8000c3f4:	c1 a8       	rjmp	8000c428 <__sfvwrite_r+0x284>
8000c3f6:	08 9a       	mov	r10,r4
8000c3f8:	06 9b       	mov	r11,r3
8000c3fa:	cb 2c       	rcall	8000c55e <memmove>
8000c3fc:	6e 08       	ld.w	r8,r7[0x0]
8000c3fe:	08 08       	add	r8,r4
8000c400:	08 95       	mov	r5,r4
8000c402:	8f 08       	st.w	r7[0x0],r8
8000c404:	6e 28       	ld.w	r8,r7[0x8]
8000c406:	08 18       	sub	r8,r4
8000c408:	8f 28       	st.w	r7[0x8],r8
8000c40a:	0a 16       	sub	r6,r5
8000c40c:	c0 71       	brne	8000c41a <__sfvwrite_r+0x276>
8000c40e:	0e 9b       	mov	r11,r7
8000c410:	40 1c       	lddsp	r12,sp[0x4]
8000c412:	fe b0 fc 91 	rcall	8000bd34 <_fflush_r>
8000c416:	c0 91       	brne	8000c428 <__sfvwrite_r+0x284>
8000c418:	50 06       	stdsp	sp[0x0],r6
8000c41a:	64 28       	ld.w	r8,r2[0x8]
8000c41c:	0a 18       	sub	r8,r5
8000c41e:	85 28       	st.w	r2[0x8],r8
8000c420:	c0 90       	breq	8000c432 <__sfvwrite_r+0x28e>
8000c422:	0a 11       	sub	r1,r5
8000c424:	0a 03       	add	r3,r5
8000c426:	ca 4b       	rjmp	8000c36e <__sfvwrite_r+0x1ca>
8000c428:	8e 68       	ld.sh	r8,r7[0xc]
8000c42a:	a7 a8       	sbr	r8,0x6
8000c42c:	ae 68       	st.h	r7[0xc],r8
8000c42e:	3f fc       	mov	r12,-1
8000c430:	c0 28       	rjmp	8000c434 <__sfvwrite_r+0x290>
8000c432:	30 0c       	mov	r12,0
8000c434:	2f dd       	sub	sp,-12
8000c436:	d8 32       	popm	r0-r7,pc

8000c438 <_fwalk>:
8000c438:	d4 31       	pushm	r0-r7,lr
8000c43a:	30 05       	mov	r5,0
8000c43c:	16 91       	mov	r1,r11
8000c43e:	f8 c7 ff 28 	sub	r7,r12,-216
8000c442:	0a 92       	mov	r2,r5
8000c444:	fe b0 fc fe 	rcall	8000be40 <__sfp_lock_acquire>
8000c448:	3f f3       	mov	r3,-1
8000c44a:	c1 68       	rjmp	8000c476 <_fwalk+0x3e>
8000c44c:	6e 26       	ld.w	r6,r7[0x8]
8000c44e:	6e 14       	ld.w	r4,r7[0x4]
8000c450:	2f 46       	sub	r6,-12
8000c452:	c0 c8       	rjmp	8000c46a <_fwalk+0x32>
8000c454:	8c 08       	ld.sh	r8,r6[0x0]
8000c456:	e4 08 19 00 	cp.h	r8,r2
8000c45a:	c0 70       	breq	8000c468 <_fwalk+0x30>
8000c45c:	8c 18       	ld.sh	r8,r6[0x2]
8000c45e:	e6 08 19 00 	cp.h	r8,r3
8000c462:	c0 30       	breq	8000c468 <_fwalk+0x30>
8000c464:	5d 11       	icall	r1
8000c466:	18 45       	or	r5,r12
8000c468:	2a 46       	sub	r6,-92
8000c46a:	20 14       	sub	r4,1
8000c46c:	ec cc 00 0c 	sub	r12,r6,12
8000c470:	58 04       	cp.w	r4,0
8000c472:	cf 14       	brge	8000c454 <_fwalk+0x1c>
8000c474:	6e 07       	ld.w	r7,r7[0x0]
8000c476:	58 07       	cp.w	r7,0
8000c478:	ce a1       	brne	8000c44c <_fwalk+0x14>
8000c47a:	fe b0 fc e4 	rcall	8000be42 <__sfp_lock_release>
8000c47e:	0a 9c       	mov	r12,r5
8000c480:	d8 32       	popm	r0-r7,pc
8000c482:	d7 03       	nop

8000c484 <_localeconv_r>:
8000c484:	fe cc cf ac 	sub	r12,pc,-12372
8000c488:	5e fc       	retal	r12
8000c48a:	d7 03       	nop

8000c48c <__smakebuf_r>:
8000c48c:	d4 21       	pushm	r4-r7,lr
8000c48e:	20 fd       	sub	sp,60
8000c490:	96 68       	ld.sh	r8,r11[0xc]
8000c492:	16 97       	mov	r7,r11
8000c494:	18 96       	mov	r6,r12
8000c496:	e2 18 00 02 	andl	r8,0x2,COH
8000c49a:	c3 d1       	brne	8000c514 <__smakebuf_r+0x88>
8000c49c:	96 7b       	ld.sh	r11,r11[0xe]
8000c49e:	f0 0b 19 00 	cp.h	r11,r8
8000c4a2:	c0 55       	brlt	8000c4ac <__smakebuf_r+0x20>
8000c4a4:	1a 9a       	mov	r10,sp
8000c4a6:	e0 a0 04 81 	rcall	8000cda8 <_fstat_r>
8000c4aa:	c0 f4       	brge	8000c4c8 <__smakebuf_r+0x3c>
8000c4ac:	8e 65       	ld.sh	r5,r7[0xc]
8000c4ae:	0a 98       	mov	r8,r5
8000c4b0:	ab b8       	sbr	r8,0xb
8000c4b2:	e2 15 00 80 	andl	r5,0x80,COH
8000c4b6:	ae 68       	st.h	r7[0xc],r8
8000c4b8:	30 04       	mov	r4,0
8000c4ba:	e0 68 04 00 	mov	r8,1024
8000c4be:	f9 b5 01 40 	movne	r5,64
8000c4c2:	f0 05 17 00 	moveq	r5,r8
8000c4c6:	c1 c8       	rjmp	8000c4fe <__smakebuf_r+0x72>
8000c4c8:	40 18       	lddsp	r8,sp[0x4]
8000c4ca:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c4ce:	e0 48 20 00 	cp.w	r8,8192
8000c4d2:	5f 04       	sreq	r4
8000c4d4:	e0 48 80 00 	cp.w	r8,32768
8000c4d8:	c0 e1       	brne	8000c4f4 <__smakebuf_r+0x68>
8000c4da:	6e b9       	ld.w	r9,r7[0x2c]
8000c4dc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c4e0:	10 39       	cp.w	r9,r8
8000c4e2:	c0 91       	brne	8000c4f4 <__smakebuf_r+0x68>
8000c4e4:	8e 68       	ld.sh	r8,r7[0xc]
8000c4e6:	e0 65 04 00 	mov	r5,1024
8000c4ea:	ab a8       	sbr	r8,0xa
8000c4ec:	ef 45 00 50 	st.w	r7[80],r5
8000c4f0:	ae 68       	st.h	r7[0xc],r8
8000c4f2:	c0 68       	rjmp	8000c4fe <__smakebuf_r+0x72>
8000c4f4:	8e 68       	ld.sh	r8,r7[0xc]
8000c4f6:	e0 65 04 00 	mov	r5,1024
8000c4fa:	ab b8       	sbr	r8,0xb
8000c4fc:	ae 68       	st.h	r7[0xc],r8
8000c4fe:	0a 9b       	mov	r11,r5
8000c500:	0c 9c       	mov	r12,r6
8000c502:	fe b0 df 23 	rcall	80008348 <_malloc_r>
8000c506:	8e 68       	ld.sh	r8,r7[0xc]
8000c508:	c0 d1       	brne	8000c522 <__smakebuf_r+0x96>
8000c50a:	ed b8 00 09 	bld	r8,0x9
8000c50e:	c1 b0       	breq	8000c544 <__smakebuf_r+0xb8>
8000c510:	a1 b8       	sbr	r8,0x1
8000c512:	ae 68       	st.h	r7[0xc],r8
8000c514:	ee c8 ff b9 	sub	r8,r7,-71
8000c518:	8f 48       	st.w	r7[0x10],r8
8000c51a:	8f 08       	st.w	r7[0x0],r8
8000c51c:	30 18       	mov	r8,1
8000c51e:	8f 58       	st.w	r7[0x14],r8
8000c520:	c1 28       	rjmp	8000c544 <__smakebuf_r+0xb8>
8000c522:	a7 b8       	sbr	r8,0x7
8000c524:	8f 4c       	st.w	r7[0x10],r12
8000c526:	ae 68       	st.h	r7[0xc],r8
8000c528:	8f 55       	st.w	r7[0x14],r5
8000c52a:	fe c8 06 e6 	sub	r8,pc,1766
8000c52e:	8f 0c       	st.w	r7[0x0],r12
8000c530:	8d a8       	st.w	r6[0x28],r8
8000c532:	58 04       	cp.w	r4,0
8000c534:	c0 80       	breq	8000c544 <__smakebuf_r+0xb8>
8000c536:	8e 7c       	ld.sh	r12,r7[0xe]
8000c538:	fe b0 e3 94 	rcall	80008c60 <isatty>
8000c53c:	c0 40       	breq	8000c544 <__smakebuf_r+0xb8>
8000c53e:	8e 68       	ld.sh	r8,r7[0xc]
8000c540:	a1 a8       	sbr	r8,0x0
8000c542:	ae 68       	st.h	r7[0xc],r8
8000c544:	2f 1d       	sub	sp,-60
8000c546:	d8 22       	popm	r4-r7,pc

8000c548 <memchr>:
8000c548:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c54c:	c0 68       	rjmp	8000c558 <memchr+0x10>
8000c54e:	20 1a       	sub	r10,1
8000c550:	19 88       	ld.ub	r8,r12[0x0]
8000c552:	16 38       	cp.w	r8,r11
8000c554:	5e 0c       	reteq	r12
8000c556:	2f fc       	sub	r12,-1
8000c558:	58 0a       	cp.w	r10,0
8000c55a:	cf a1       	brne	8000c54e <memchr+0x6>
8000c55c:	5e fa       	retal	r10

8000c55e <memmove>:
8000c55e:	d4 01       	pushm	lr
8000c560:	18 3b       	cp.w	r11,r12
8000c562:	c1 92       	brcc	8000c594 <memmove+0x36>
8000c564:	f6 0a 00 09 	add	r9,r11,r10
8000c568:	12 3c       	cp.w	r12,r9
8000c56a:	c1 52       	brcc	8000c594 <memmove+0x36>
8000c56c:	f8 0a 00 0b 	add	r11,r12,r10
8000c570:	30 08       	mov	r8,0
8000c572:	c0 68       	rjmp	8000c57e <memmove+0x20>
8000c574:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c578:	20 1a       	sub	r10,1
8000c57a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c57e:	20 18       	sub	r8,1
8000c580:	58 0a       	cp.w	r10,0
8000c582:	cf 91       	brne	8000c574 <memmove+0x16>
8000c584:	d8 02       	popm	pc
8000c586:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c58a:	20 1a       	sub	r10,1
8000c58c:	f8 08 0b 09 	st.b	r12[r8],r9
8000c590:	2f f8       	sub	r8,-1
8000c592:	c0 28       	rjmp	8000c596 <memmove+0x38>
8000c594:	30 08       	mov	r8,0
8000c596:	58 0a       	cp.w	r10,0
8000c598:	cf 71       	brne	8000c586 <memmove+0x28>
8000c59a:	d8 02       	popm	pc

8000c59c <__hi0bits>:
8000c59c:	18 98       	mov	r8,r12
8000c59e:	e0 1c 00 00 	andl	r12,0x0
8000c5a2:	f0 09 15 10 	lsl	r9,r8,0x10
8000c5a6:	58 0c       	cp.w	r12,0
8000c5a8:	f2 08 17 00 	moveq	r8,r9
8000c5ac:	f9 bc 00 10 	moveq	r12,16
8000c5b0:	f9 bc 01 00 	movne	r12,0
8000c5b4:	10 9a       	mov	r10,r8
8000c5b6:	f0 09 15 08 	lsl	r9,r8,0x8
8000c5ba:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c5be:	f7 bc 00 f8 	subeq	r12,-8
8000c5c2:	f2 08 17 00 	moveq	r8,r9
8000c5c6:	10 9a       	mov	r10,r8
8000c5c8:	f0 09 15 04 	lsl	r9,r8,0x4
8000c5cc:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c5d0:	f7 bc 00 fc 	subeq	r12,-4
8000c5d4:	f2 08 17 00 	moveq	r8,r9
8000c5d8:	10 9a       	mov	r10,r8
8000c5da:	f0 09 15 02 	lsl	r9,r8,0x2
8000c5de:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c5e2:	f7 bc 00 fe 	subeq	r12,-2
8000c5e6:	f2 08 17 00 	moveq	r8,r9
8000c5ea:	58 08       	cp.w	r8,0
8000c5ec:	5e 5c       	retlt	r12
8000c5ee:	ed b8 00 1e 	bld	r8,0x1e
8000c5f2:	f9 bc 01 20 	movne	r12,32
8000c5f6:	f7 bc 00 ff 	subeq	r12,-1
8000c5fa:	5e fc       	retal	r12

8000c5fc <__lo0bits>:
8000c5fc:	18 99       	mov	r9,r12
8000c5fe:	78 08       	ld.w	r8,r12[0x0]
8000c600:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c604:	c1 50       	breq	8000c62e <__lo0bits+0x32>
8000c606:	ed b8 00 00 	bld	r8,0x0
8000c60a:	c0 21       	brne	8000c60e <__lo0bits+0x12>
8000c60c:	5e fd       	retal	0
8000c60e:	10 9b       	mov	r11,r8
8000c610:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c614:	e2 1b 00 02 	andl	r11,0x2,COH
8000c618:	a3 88       	lsr	r8,0x2
8000c61a:	58 0b       	cp.w	r11,0
8000c61c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c620:	f9 bc 01 01 	movne	r12,1
8000c624:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c628:	f9 bc 00 02 	moveq	r12,2
8000c62c:	5e fc       	retal	r12
8000c62e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c632:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c636:	58 0a       	cp.w	r10,0
8000c638:	f6 08 17 00 	moveq	r8,r11
8000c63c:	f9 bc 00 10 	moveq	r12,16
8000c640:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c644:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c648:	58 0b       	cp.w	r11,0
8000c64a:	f7 bc 00 f8 	subeq	r12,-8
8000c64e:	f4 08 17 00 	moveq	r8,r10
8000c652:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c656:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c65a:	58 0b       	cp.w	r11,0
8000c65c:	f7 bc 00 fc 	subeq	r12,-4
8000c660:	f4 08 17 00 	moveq	r8,r10
8000c664:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c668:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c66c:	58 0b       	cp.w	r11,0
8000c66e:	f7 bc 00 fe 	subeq	r12,-2
8000c672:	f4 08 17 00 	moveq	r8,r10
8000c676:	ed b8 00 00 	bld	r8,0x0
8000c67a:	c0 60       	breq	8000c686 <__lo0bits+0x8a>
8000c67c:	a1 98       	lsr	r8,0x1
8000c67e:	c0 31       	brne	8000c684 <__lo0bits+0x88>
8000c680:	32 0c       	mov	r12,32
8000c682:	5e fc       	retal	r12
8000c684:	2f fc       	sub	r12,-1
8000c686:	93 08       	st.w	r9[0x0],r8
8000c688:	5e fc       	retal	r12

8000c68a <__mcmp>:
8000c68a:	d4 01       	pushm	lr
8000c68c:	18 98       	mov	r8,r12
8000c68e:	76 49       	ld.w	r9,r11[0x10]
8000c690:	78 4c       	ld.w	r12,r12[0x10]
8000c692:	12 1c       	sub	r12,r9
8000c694:	c1 31       	brne	8000c6ba <__mcmp+0x30>
8000c696:	2f b9       	sub	r9,-5
8000c698:	a3 69       	lsl	r9,0x2
8000c69a:	12 0b       	add	r11,r9
8000c69c:	f0 09 00 09 	add	r9,r8,r9
8000c6a0:	2e c8       	sub	r8,-20
8000c6a2:	13 4e       	ld.w	lr,--r9
8000c6a4:	17 4a       	ld.w	r10,--r11
8000c6a6:	14 3e       	cp.w	lr,r10
8000c6a8:	c0 60       	breq	8000c6b4 <__mcmp+0x2a>
8000c6aa:	f9 bc 03 ff 	movlo	r12,-1
8000c6ae:	f9 bc 02 01 	movhs	r12,1
8000c6b2:	d8 02       	popm	pc
8000c6b4:	10 39       	cp.w	r9,r8
8000c6b6:	fe 9b ff f6 	brhi	8000c6a2 <__mcmp+0x18>
8000c6ba:	d8 02       	popm	pc

8000c6bc <_Bfree>:
8000c6bc:	d4 21       	pushm	r4-r7,lr
8000c6be:	18 97       	mov	r7,r12
8000c6c0:	16 95       	mov	r5,r11
8000c6c2:	78 96       	ld.w	r6,r12[0x24]
8000c6c4:	58 06       	cp.w	r6,0
8000c6c6:	c0 91       	brne	8000c6d8 <_Bfree+0x1c>
8000c6c8:	31 0c       	mov	r12,16
8000c6ca:	fe b0 de 37 	rcall	80008338 <malloc>
8000c6ce:	99 36       	st.w	r12[0xc],r6
8000c6d0:	8f 9c       	st.w	r7[0x24],r12
8000c6d2:	99 16       	st.w	r12[0x4],r6
8000c6d4:	99 26       	st.w	r12[0x8],r6
8000c6d6:	99 06       	st.w	r12[0x0],r6
8000c6d8:	58 05       	cp.w	r5,0
8000c6da:	c0 90       	breq	8000c6ec <_Bfree+0x30>
8000c6dc:	6a 19       	ld.w	r9,r5[0x4]
8000c6de:	6e 98       	ld.w	r8,r7[0x24]
8000c6e0:	70 38       	ld.w	r8,r8[0xc]
8000c6e2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c6e6:	8b 0a       	st.w	r5[0x0],r10
8000c6e8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c6ec:	d8 22       	popm	r4-r7,pc
8000c6ee:	d7 03       	nop

8000c6f0 <_Balloc>:
8000c6f0:	d4 21       	pushm	r4-r7,lr
8000c6f2:	18 97       	mov	r7,r12
8000c6f4:	16 96       	mov	r6,r11
8000c6f6:	78 95       	ld.w	r5,r12[0x24]
8000c6f8:	58 05       	cp.w	r5,0
8000c6fa:	c0 91       	brne	8000c70c <_Balloc+0x1c>
8000c6fc:	31 0c       	mov	r12,16
8000c6fe:	fe b0 de 1d 	rcall	80008338 <malloc>
8000c702:	99 35       	st.w	r12[0xc],r5
8000c704:	8f 9c       	st.w	r7[0x24],r12
8000c706:	99 15       	st.w	r12[0x4],r5
8000c708:	99 25       	st.w	r12[0x8],r5
8000c70a:	99 05       	st.w	r12[0x0],r5
8000c70c:	6e 95       	ld.w	r5,r7[0x24]
8000c70e:	6a 38       	ld.w	r8,r5[0xc]
8000c710:	58 08       	cp.w	r8,0
8000c712:	c0 b1       	brne	8000c728 <_Balloc+0x38>
8000c714:	31 0a       	mov	r10,16
8000c716:	30 4b       	mov	r11,4
8000c718:	0e 9c       	mov	r12,r7
8000c71a:	e0 a0 02 a7 	rcall	8000cc68 <_calloc_r>
8000c71e:	8b 3c       	st.w	r5[0xc],r12
8000c720:	6e 98       	ld.w	r8,r7[0x24]
8000c722:	70 3c       	ld.w	r12,r8[0xc]
8000c724:	58 0c       	cp.w	r12,0
8000c726:	c1 b0       	breq	8000c75c <_Balloc+0x6c>
8000c728:	6e 98       	ld.w	r8,r7[0x24]
8000c72a:	70 38       	ld.w	r8,r8[0xc]
8000c72c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c730:	70 0c       	ld.w	r12,r8[0x0]
8000c732:	58 0c       	cp.w	r12,0
8000c734:	c0 40       	breq	8000c73c <_Balloc+0x4c>
8000c736:	78 09       	ld.w	r9,r12[0x0]
8000c738:	91 09       	st.w	r8[0x0],r9
8000c73a:	c0 e8       	rjmp	8000c756 <_Balloc+0x66>
8000c73c:	0e 9c       	mov	r12,r7
8000c73e:	30 17       	mov	r7,1
8000c740:	0e 9b       	mov	r11,r7
8000c742:	ee 06 09 47 	lsl	r7,r7,r6
8000c746:	ee ca ff fb 	sub	r10,r7,-5
8000c74a:	a3 6a       	lsl	r10,0x2
8000c74c:	e0 a0 02 8e 	rcall	8000cc68 <_calloc_r>
8000c750:	c0 60       	breq	8000c75c <_Balloc+0x6c>
8000c752:	99 16       	st.w	r12[0x4],r6
8000c754:	99 27       	st.w	r12[0x8],r7
8000c756:	30 08       	mov	r8,0
8000c758:	99 38       	st.w	r12[0xc],r8
8000c75a:	99 48       	st.w	r12[0x10],r8
8000c75c:	d8 22       	popm	r4-r7,pc
8000c75e:	d7 03       	nop

8000c760 <__d2b>:
8000c760:	d4 31       	pushm	r0-r7,lr
8000c762:	20 2d       	sub	sp,8
8000c764:	16 93       	mov	r3,r11
8000c766:	12 96       	mov	r6,r9
8000c768:	10 95       	mov	r5,r8
8000c76a:	14 92       	mov	r2,r10
8000c76c:	30 1b       	mov	r11,1
8000c76e:	cc 1f       	rcall	8000c6f0 <_Balloc>
8000c770:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c774:	50 09       	stdsp	sp[0x0],r9
8000c776:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c77a:	b5 a9       	sbr	r9,0x14
8000c77c:	f0 01 16 14 	lsr	r1,r8,0x14
8000c780:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c784:	18 94       	mov	r4,r12
8000c786:	58 02       	cp.w	r2,0
8000c788:	c1 d0       	breq	8000c7c2 <__d2b+0x62>
8000c78a:	fa cc ff f8 	sub	r12,sp,-8
8000c78e:	18 d2       	st.w	--r12,r2
8000c790:	c3 6f       	rcall	8000c5fc <__lo0bits>
8000c792:	40 18       	lddsp	r8,sp[0x4]
8000c794:	c0 d0       	breq	8000c7ae <__d2b+0x4e>
8000c796:	40 09       	lddsp	r9,sp[0x0]
8000c798:	f8 0a 11 20 	rsub	r10,r12,32
8000c79c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c7a0:	f5 e8 10 08 	or	r8,r10,r8
8000c7a4:	89 58       	st.w	r4[0x14],r8
8000c7a6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c7aa:	50 09       	stdsp	sp[0x0],r9
8000c7ac:	c0 28       	rjmp	8000c7b0 <__d2b+0x50>
8000c7ae:	89 58       	st.w	r4[0x14],r8
8000c7b0:	40 08       	lddsp	r8,sp[0x0]
8000c7b2:	58 08       	cp.w	r8,0
8000c7b4:	f9 b3 01 02 	movne	r3,2
8000c7b8:	f9 b3 00 01 	moveq	r3,1
8000c7bc:	89 68       	st.w	r4[0x18],r8
8000c7be:	89 43       	st.w	r4[0x10],r3
8000c7c0:	c0 88       	rjmp	8000c7d0 <__d2b+0x70>
8000c7c2:	1a 9c       	mov	r12,sp
8000c7c4:	c1 cf       	rcall	8000c5fc <__lo0bits>
8000c7c6:	30 13       	mov	r3,1
8000c7c8:	40 08       	lddsp	r8,sp[0x0]
8000c7ca:	2e 0c       	sub	r12,-32
8000c7cc:	89 43       	st.w	r4[0x10],r3
8000c7ce:	89 58       	st.w	r4[0x14],r8
8000c7d0:	58 01       	cp.w	r1,0
8000c7d2:	c0 90       	breq	8000c7e4 <__d2b+0x84>
8000c7d4:	e2 c1 04 33 	sub	r1,r1,1075
8000c7d8:	18 01       	add	r1,r12
8000c7da:	8d 01       	st.w	r6[0x0],r1
8000c7dc:	f8 0c 11 35 	rsub	r12,r12,53
8000c7e0:	8b 0c       	st.w	r5[0x0],r12
8000c7e2:	c0 c8       	rjmp	8000c7fa <__d2b+0x9a>
8000c7e4:	e6 c8 ff fc 	sub	r8,r3,-4
8000c7e8:	f8 cc 04 32 	sub	r12,r12,1074
8000c7ec:	a5 73       	lsl	r3,0x5
8000c7ee:	8d 0c       	st.w	r6[0x0],r12
8000c7f0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c7f4:	cd 4e       	rcall	8000c59c <__hi0bits>
8000c7f6:	18 13       	sub	r3,r12
8000c7f8:	8b 03       	st.w	r5[0x0],r3
8000c7fa:	08 9c       	mov	r12,r4
8000c7fc:	2f ed       	sub	sp,-8
8000c7fe:	d8 32       	popm	r0-r7,pc

8000c800 <__mdiff>:
8000c800:	d4 31       	pushm	r0-r7,lr
8000c802:	74 48       	ld.w	r8,r10[0x10]
8000c804:	76 45       	ld.w	r5,r11[0x10]
8000c806:	16 97       	mov	r7,r11
8000c808:	14 96       	mov	r6,r10
8000c80a:	10 15       	sub	r5,r8
8000c80c:	c1 31       	brne	8000c832 <__mdiff+0x32>
8000c80e:	2f b8       	sub	r8,-5
8000c810:	ee ce ff ec 	sub	lr,r7,-20
8000c814:	a3 68       	lsl	r8,0x2
8000c816:	f4 08 00 0b 	add	r11,r10,r8
8000c81a:	ee 08 00 08 	add	r8,r7,r8
8000c81e:	11 4a       	ld.w	r10,--r8
8000c820:	17 49       	ld.w	r9,--r11
8000c822:	12 3a       	cp.w	r10,r9
8000c824:	c0 30       	breq	8000c82a <__mdiff+0x2a>
8000c826:	c0 e2       	brcc	8000c842 <__mdiff+0x42>
8000c828:	c0 78       	rjmp	8000c836 <__mdiff+0x36>
8000c82a:	1c 38       	cp.w	r8,lr
8000c82c:	fe 9b ff f9 	brhi	8000c81e <__mdiff+0x1e>
8000c830:	c4 98       	rjmp	8000c8c2 <__mdiff+0xc2>
8000c832:	58 05       	cp.w	r5,0
8000c834:	c0 64       	brge	8000c840 <__mdiff+0x40>
8000c836:	0e 98       	mov	r8,r7
8000c838:	30 15       	mov	r5,1
8000c83a:	0c 97       	mov	r7,r6
8000c83c:	10 96       	mov	r6,r8
8000c83e:	c0 28       	rjmp	8000c842 <__mdiff+0x42>
8000c840:	30 05       	mov	r5,0
8000c842:	6e 1b       	ld.w	r11,r7[0x4]
8000c844:	c5 6f       	rcall	8000c6f0 <_Balloc>
8000c846:	6e 49       	ld.w	r9,r7[0x10]
8000c848:	6c 44       	ld.w	r4,r6[0x10]
8000c84a:	99 35       	st.w	r12[0xc],r5
8000c84c:	2f b4       	sub	r4,-5
8000c84e:	f2 c5 ff fb 	sub	r5,r9,-5
8000c852:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c856:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c85a:	2e c6       	sub	r6,-20
8000c85c:	2e c7       	sub	r7,-20
8000c85e:	f8 c8 ff ec 	sub	r8,r12,-20
8000c862:	30 0a       	mov	r10,0
8000c864:	0f 0e       	ld.w	lr,r7++
8000c866:	0d 0b       	ld.w	r11,r6++
8000c868:	fc 02 16 10 	lsr	r2,lr,0x10
8000c86c:	f6 03 16 10 	lsr	r3,r11,0x10
8000c870:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c874:	e4 03 01 03 	sub	r3,r2,r3
8000c878:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c87c:	fc 0b 01 0b 	sub	r11,lr,r11
8000c880:	f6 0a 00 0a 	add	r10,r11,r10
8000c884:	b0 1a       	st.h	r8[0x2],r10
8000c886:	b1 4a       	asr	r10,0x10
8000c888:	e6 0a 00 0a 	add	r10,r3,r10
8000c88c:	b0 0a       	st.h	r8[0x0],r10
8000c88e:	2f c8       	sub	r8,-4
8000c890:	b1 4a       	asr	r10,0x10
8000c892:	08 36       	cp.w	r6,r4
8000c894:	ce 83       	brcs	8000c864 <__mdiff+0x64>
8000c896:	c0 d8       	rjmp	8000c8b0 <__mdiff+0xb0>
8000c898:	0f 0b       	ld.w	r11,r7++
8000c89a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c89e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c8a2:	16 0a       	add	r10,r11
8000c8a4:	b0 1a       	st.h	r8[0x2],r10
8000c8a6:	b1 4a       	asr	r10,0x10
8000c8a8:	1c 0a       	add	r10,lr
8000c8aa:	b0 0a       	st.h	r8[0x0],r10
8000c8ac:	2f c8       	sub	r8,-4
8000c8ae:	b1 4a       	asr	r10,0x10
8000c8b0:	0a 37       	cp.w	r7,r5
8000c8b2:	cf 33       	brcs	8000c898 <__mdiff+0x98>
8000c8b4:	c0 28       	rjmp	8000c8b8 <__mdiff+0xb8>
8000c8b6:	20 19       	sub	r9,1
8000c8b8:	11 4a       	ld.w	r10,--r8
8000c8ba:	58 0a       	cp.w	r10,0
8000c8bc:	cf d0       	breq	8000c8b6 <__mdiff+0xb6>
8000c8be:	99 49       	st.w	r12[0x10],r9
8000c8c0:	d8 32       	popm	r0-r7,pc
8000c8c2:	30 0b       	mov	r11,0
8000c8c4:	c1 6f       	rcall	8000c6f0 <_Balloc>
8000c8c6:	30 18       	mov	r8,1
8000c8c8:	99 48       	st.w	r12[0x10],r8
8000c8ca:	30 08       	mov	r8,0
8000c8cc:	99 58       	st.w	r12[0x14],r8
8000c8ce:	d8 32       	popm	r0-r7,pc

8000c8d0 <__lshift>:
8000c8d0:	d4 31       	pushm	r0-r7,lr
8000c8d2:	16 97       	mov	r7,r11
8000c8d4:	76 46       	ld.w	r6,r11[0x10]
8000c8d6:	f4 02 14 05 	asr	r2,r10,0x5
8000c8da:	2f f6       	sub	r6,-1
8000c8dc:	14 93       	mov	r3,r10
8000c8de:	18 94       	mov	r4,r12
8000c8e0:	04 06       	add	r6,r2
8000c8e2:	76 1b       	ld.w	r11,r11[0x4]
8000c8e4:	6e 28       	ld.w	r8,r7[0x8]
8000c8e6:	c0 38       	rjmp	8000c8ec <__lshift+0x1c>
8000c8e8:	2f fb       	sub	r11,-1
8000c8ea:	a1 78       	lsl	r8,0x1
8000c8ec:	10 36       	cp.w	r6,r8
8000c8ee:	fe 99 ff fd 	brgt	8000c8e8 <__lshift+0x18>
8000c8f2:	08 9c       	mov	r12,r4
8000c8f4:	cf ee       	rcall	8000c6f0 <_Balloc>
8000c8f6:	30 09       	mov	r9,0
8000c8f8:	18 95       	mov	r5,r12
8000c8fa:	f8 c8 ff ec 	sub	r8,r12,-20
8000c8fe:	12 9a       	mov	r10,r9
8000c900:	c0 38       	rjmp	8000c906 <__lshift+0x36>
8000c902:	10 aa       	st.w	r8++,r10
8000c904:	2f f9       	sub	r9,-1
8000c906:	04 39       	cp.w	r9,r2
8000c908:	cf d5       	brlt	8000c902 <__lshift+0x32>
8000c90a:	6e 4b       	ld.w	r11,r7[0x10]
8000c90c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c910:	2f bb       	sub	r11,-5
8000c912:	ee c9 ff ec 	sub	r9,r7,-20
8000c916:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c91a:	58 03       	cp.w	r3,0
8000c91c:	c1 30       	breq	8000c942 <__lshift+0x72>
8000c91e:	e6 0c 11 20 	rsub	r12,r3,32
8000c922:	30 0a       	mov	r10,0
8000c924:	72 02       	ld.w	r2,r9[0x0]
8000c926:	e4 03 09 42 	lsl	r2,r2,r3
8000c92a:	04 4a       	or	r10,r2
8000c92c:	10 aa       	st.w	r8++,r10
8000c92e:	13 0a       	ld.w	r10,r9++
8000c930:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c934:	16 39       	cp.w	r9,r11
8000c936:	cf 73       	brcs	8000c924 <__lshift+0x54>
8000c938:	91 0a       	st.w	r8[0x0],r10
8000c93a:	58 0a       	cp.w	r10,0
8000c93c:	c0 70       	breq	8000c94a <__lshift+0x7a>
8000c93e:	2f f6       	sub	r6,-1
8000c940:	c0 58       	rjmp	8000c94a <__lshift+0x7a>
8000c942:	13 0a       	ld.w	r10,r9++
8000c944:	10 aa       	st.w	r8++,r10
8000c946:	16 39       	cp.w	r9,r11
8000c948:	cf d3       	brcs	8000c942 <__lshift+0x72>
8000c94a:	08 9c       	mov	r12,r4
8000c94c:	20 16       	sub	r6,1
8000c94e:	0e 9b       	mov	r11,r7
8000c950:	8b 46       	st.w	r5[0x10],r6
8000c952:	cb 5e       	rcall	8000c6bc <_Bfree>
8000c954:	0a 9c       	mov	r12,r5
8000c956:	d8 32       	popm	r0-r7,pc

8000c958 <__multiply>:
8000c958:	d4 31       	pushm	r0-r7,lr
8000c95a:	20 2d       	sub	sp,8
8000c95c:	76 49       	ld.w	r9,r11[0x10]
8000c95e:	74 48       	ld.w	r8,r10[0x10]
8000c960:	16 96       	mov	r6,r11
8000c962:	14 95       	mov	r5,r10
8000c964:	10 39       	cp.w	r9,r8
8000c966:	ec 08 17 50 	movlt	r8,r6
8000c96a:	ea 06 17 50 	movlt	r6,r5
8000c96e:	f0 05 17 50 	movlt	r5,r8
8000c972:	6c 28       	ld.w	r8,r6[0x8]
8000c974:	76 43       	ld.w	r3,r11[0x10]
8000c976:	74 42       	ld.w	r2,r10[0x10]
8000c978:	76 1b       	ld.w	r11,r11[0x4]
8000c97a:	e4 03 00 07 	add	r7,r2,r3
8000c97e:	10 37       	cp.w	r7,r8
8000c980:	f7 bb 09 ff 	subgt	r11,-1
8000c984:	cb 6e       	rcall	8000c6f0 <_Balloc>
8000c986:	ee c4 ff fb 	sub	r4,r7,-5
8000c98a:	f8 c9 ff ec 	sub	r9,r12,-20
8000c98e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c992:	30 0a       	mov	r10,0
8000c994:	12 98       	mov	r8,r9
8000c996:	c0 28       	rjmp	8000c99a <__multiply+0x42>
8000c998:	10 aa       	st.w	r8++,r10
8000c99a:	08 38       	cp.w	r8,r4
8000c99c:	cf e3       	brcs	8000c998 <__multiply+0x40>
8000c99e:	2f b3       	sub	r3,-5
8000c9a0:	2f b2       	sub	r2,-5
8000c9a2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c9a6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c9aa:	ec cb ff ec 	sub	r11,r6,-20
8000c9ae:	50 12       	stdsp	sp[0x4],r2
8000c9b0:	ea ca ff ec 	sub	r10,r5,-20
8000c9b4:	c4 48       	rjmp	8000ca3c <__multiply+0xe4>
8000c9b6:	94 95       	ld.uh	r5,r10[0x2]
8000c9b8:	58 05       	cp.w	r5,0
8000c9ba:	c2 00       	breq	8000c9fa <__multiply+0xa2>
8000c9bc:	12 98       	mov	r8,r9
8000c9be:	16 96       	mov	r6,r11
8000c9c0:	30 0e       	mov	lr,0
8000c9c2:	50 09       	stdsp	sp[0x0],r9
8000c9c4:	0d 02       	ld.w	r2,r6++
8000c9c6:	e4 00 16 10 	lsr	r0,r2,0x10
8000c9ca:	70 01       	ld.w	r1,r8[0x0]
8000c9cc:	70 09       	ld.w	r9,r8[0x0]
8000c9ce:	b1 81       	lsr	r1,0x10
8000c9d0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c9d4:	e0 05 03 41 	mac	r1,r0,r5
8000c9d8:	ab 32       	mul	r2,r5
8000c9da:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c9de:	00 02       	add	r2,r0
8000c9e0:	e4 0e 00 0e 	add	lr,r2,lr
8000c9e4:	b0 1e       	st.h	r8[0x2],lr
8000c9e6:	b1 8e       	lsr	lr,0x10
8000c9e8:	1c 01       	add	r1,lr
8000c9ea:	b0 01       	st.h	r8[0x0],r1
8000c9ec:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c9f0:	2f c8       	sub	r8,-4
8000c9f2:	06 36       	cp.w	r6,r3
8000c9f4:	ce 83       	brcs	8000c9c4 <__multiply+0x6c>
8000c9f6:	40 09       	lddsp	r9,sp[0x0]
8000c9f8:	91 0e       	st.w	r8[0x0],lr
8000c9fa:	94 86       	ld.uh	r6,r10[0x0]
8000c9fc:	58 06       	cp.w	r6,0
8000c9fe:	c1 d0       	breq	8000ca38 <__multiply+0xe0>
8000ca00:	72 02       	ld.w	r2,r9[0x0]
8000ca02:	12 98       	mov	r8,r9
8000ca04:	16 9e       	mov	lr,r11
8000ca06:	30 05       	mov	r5,0
8000ca08:	b0 12       	st.h	r8[0x2],r2
8000ca0a:	1d 01       	ld.w	r1,lr++
8000ca0c:	90 82       	ld.uh	r2,r8[0x0]
8000ca0e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ca12:	ad 30       	mul	r0,r6
8000ca14:	e0 02 00 02 	add	r2,r0,r2
8000ca18:	e4 05 00 05 	add	r5,r2,r5
8000ca1c:	b0 05       	st.h	r8[0x0],r5
8000ca1e:	b1 85       	lsr	r5,0x10
8000ca20:	b1 81       	lsr	r1,0x10
8000ca22:	2f c8       	sub	r8,-4
8000ca24:	ad 31       	mul	r1,r6
8000ca26:	90 92       	ld.uh	r2,r8[0x2]
8000ca28:	e2 02 00 02 	add	r2,r1,r2
8000ca2c:	0a 02       	add	r2,r5
8000ca2e:	e4 05 16 10 	lsr	r5,r2,0x10
8000ca32:	06 3e       	cp.w	lr,r3
8000ca34:	ce a3       	brcs	8000ca08 <__multiply+0xb0>
8000ca36:	91 02       	st.w	r8[0x0],r2
8000ca38:	2f ca       	sub	r10,-4
8000ca3a:	2f c9       	sub	r9,-4
8000ca3c:	40 18       	lddsp	r8,sp[0x4]
8000ca3e:	10 3a       	cp.w	r10,r8
8000ca40:	cb b3       	brcs	8000c9b6 <__multiply+0x5e>
8000ca42:	c0 28       	rjmp	8000ca46 <__multiply+0xee>
8000ca44:	20 17       	sub	r7,1
8000ca46:	58 07       	cp.w	r7,0
8000ca48:	e0 8a 00 05 	brle	8000ca52 <__multiply+0xfa>
8000ca4c:	09 48       	ld.w	r8,--r4
8000ca4e:	58 08       	cp.w	r8,0
8000ca50:	cf a0       	breq	8000ca44 <__multiply+0xec>
8000ca52:	99 47       	st.w	r12[0x10],r7
8000ca54:	2f ed       	sub	sp,-8
8000ca56:	d8 32       	popm	r0-r7,pc

8000ca58 <__i2b>:
8000ca58:	d4 21       	pushm	r4-r7,lr
8000ca5a:	16 97       	mov	r7,r11
8000ca5c:	30 1b       	mov	r11,1
8000ca5e:	c4 9e       	rcall	8000c6f0 <_Balloc>
8000ca60:	30 19       	mov	r9,1
8000ca62:	99 57       	st.w	r12[0x14],r7
8000ca64:	99 49       	st.w	r12[0x10],r9
8000ca66:	d8 22       	popm	r4-r7,pc

8000ca68 <__multadd>:
8000ca68:	d4 31       	pushm	r0-r7,lr
8000ca6a:	30 08       	mov	r8,0
8000ca6c:	12 95       	mov	r5,r9
8000ca6e:	16 97       	mov	r7,r11
8000ca70:	18 96       	mov	r6,r12
8000ca72:	76 44       	ld.w	r4,r11[0x10]
8000ca74:	f6 c9 ff ec 	sub	r9,r11,-20
8000ca78:	72 0b       	ld.w	r11,r9[0x0]
8000ca7a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ca7e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ca82:	f4 0c 02 4c 	mul	r12,r10,r12
8000ca86:	f4 0b 03 45 	mac	r5,r10,r11
8000ca8a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ca8e:	b1 85       	lsr	r5,0x10
8000ca90:	18 05       	add	r5,r12
8000ca92:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ca96:	f8 0b 00 0b 	add	r11,r12,r11
8000ca9a:	12 ab       	st.w	r9++,r11
8000ca9c:	2f f8       	sub	r8,-1
8000ca9e:	b1 85       	lsr	r5,0x10
8000caa0:	08 38       	cp.w	r8,r4
8000caa2:	ce b5       	brlt	8000ca78 <__multadd+0x10>
8000caa4:	58 05       	cp.w	r5,0
8000caa6:	c1 c0       	breq	8000cade <__multadd+0x76>
8000caa8:	6e 28       	ld.w	r8,r7[0x8]
8000caaa:	10 34       	cp.w	r4,r8
8000caac:	c1 35       	brlt	8000cad2 <__multadd+0x6a>
8000caae:	6e 1b       	ld.w	r11,r7[0x4]
8000cab0:	0c 9c       	mov	r12,r6
8000cab2:	2f fb       	sub	r11,-1
8000cab4:	c1 ee       	rcall	8000c6f0 <_Balloc>
8000cab6:	6e 4a       	ld.w	r10,r7[0x10]
8000cab8:	ee cb ff f4 	sub	r11,r7,-12
8000cabc:	18 93       	mov	r3,r12
8000cabe:	2f ea       	sub	r10,-2
8000cac0:	2f 4c       	sub	r12,-12
8000cac2:	a3 6a       	lsl	r10,0x2
8000cac4:	fe b0 de 71 	rcall	800087a6 <memcpy>
8000cac8:	0e 9b       	mov	r11,r7
8000caca:	0c 9c       	mov	r12,r6
8000cacc:	fe b0 fd f8 	rcall	8000c6bc <_Bfree>
8000cad0:	06 97       	mov	r7,r3
8000cad2:	e8 c8 ff ff 	sub	r8,r4,-1
8000cad6:	2f b4       	sub	r4,-5
8000cad8:	8f 48       	st.w	r7[0x10],r8
8000cada:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000cade:	0e 9c       	mov	r12,r7
8000cae0:	d8 32       	popm	r0-r7,pc
8000cae2:	d7 03       	nop

8000cae4 <__pow5mult>:
8000cae4:	d4 31       	pushm	r0-r7,lr
8000cae6:	14 96       	mov	r6,r10
8000cae8:	18 97       	mov	r7,r12
8000caea:	16 94       	mov	r4,r11
8000caec:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000caf0:	c0 90       	breq	8000cb02 <__pow5mult+0x1e>
8000caf2:	20 18       	sub	r8,1
8000caf4:	fe c9 d5 e0 	sub	r9,pc,-10784
8000caf8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000cafc:	30 09       	mov	r9,0
8000cafe:	cb 5f       	rcall	8000ca68 <__multadd>
8000cb00:	18 94       	mov	r4,r12
8000cb02:	a3 46       	asr	r6,0x2
8000cb04:	c3 40       	breq	8000cb6c <__pow5mult+0x88>
8000cb06:	6e 95       	ld.w	r5,r7[0x24]
8000cb08:	58 05       	cp.w	r5,0
8000cb0a:	c0 91       	brne	8000cb1c <__pow5mult+0x38>
8000cb0c:	31 0c       	mov	r12,16
8000cb0e:	fe b0 dc 15 	rcall	80008338 <malloc>
8000cb12:	99 35       	st.w	r12[0xc],r5
8000cb14:	8f 9c       	st.w	r7[0x24],r12
8000cb16:	99 15       	st.w	r12[0x4],r5
8000cb18:	99 25       	st.w	r12[0x8],r5
8000cb1a:	99 05       	st.w	r12[0x0],r5
8000cb1c:	6e 93       	ld.w	r3,r7[0x24]
8000cb1e:	66 25       	ld.w	r5,r3[0x8]
8000cb20:	58 05       	cp.w	r5,0
8000cb22:	c0 c1       	brne	8000cb3a <__pow5mult+0x56>
8000cb24:	e0 6b 02 71 	mov	r11,625
8000cb28:	0e 9c       	mov	r12,r7
8000cb2a:	c9 7f       	rcall	8000ca58 <__i2b>
8000cb2c:	87 2c       	st.w	r3[0x8],r12
8000cb2e:	30 08       	mov	r8,0
8000cb30:	18 95       	mov	r5,r12
8000cb32:	99 08       	st.w	r12[0x0],r8
8000cb34:	c0 38       	rjmp	8000cb3a <__pow5mult+0x56>
8000cb36:	06 9c       	mov	r12,r3
8000cb38:	18 95       	mov	r5,r12
8000cb3a:	ed b6 00 00 	bld	r6,0x0
8000cb3e:	c0 b1       	brne	8000cb54 <__pow5mult+0x70>
8000cb40:	08 9b       	mov	r11,r4
8000cb42:	0a 9a       	mov	r10,r5
8000cb44:	0e 9c       	mov	r12,r7
8000cb46:	c0 9f       	rcall	8000c958 <__multiply>
8000cb48:	08 9b       	mov	r11,r4
8000cb4a:	18 93       	mov	r3,r12
8000cb4c:	0e 9c       	mov	r12,r7
8000cb4e:	06 94       	mov	r4,r3
8000cb50:	fe b0 fd b6 	rcall	8000c6bc <_Bfree>
8000cb54:	a1 56       	asr	r6,0x1
8000cb56:	c0 b0       	breq	8000cb6c <__pow5mult+0x88>
8000cb58:	6a 03       	ld.w	r3,r5[0x0]
8000cb5a:	58 03       	cp.w	r3,0
8000cb5c:	ce d1       	brne	8000cb36 <__pow5mult+0x52>
8000cb5e:	0a 9a       	mov	r10,r5
8000cb60:	0a 9b       	mov	r11,r5
8000cb62:	0e 9c       	mov	r12,r7
8000cb64:	cf ae       	rcall	8000c958 <__multiply>
8000cb66:	8b 0c       	st.w	r5[0x0],r12
8000cb68:	99 03       	st.w	r12[0x0],r3
8000cb6a:	ce 7b       	rjmp	8000cb38 <__pow5mult+0x54>
8000cb6c:	08 9c       	mov	r12,r4
8000cb6e:	d8 32       	popm	r0-r7,pc

8000cb70 <__isinfd>:
8000cb70:	14 98       	mov	r8,r10
8000cb72:	fc 19 7f f0 	movh	r9,0x7ff0
8000cb76:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cb7a:	f0 0b 11 00 	rsub	r11,r8,0
8000cb7e:	f7 e8 10 08 	or	r8,r11,r8
8000cb82:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000cb86:	f2 08 01 08 	sub	r8,r9,r8
8000cb8a:	f0 0c 11 00 	rsub	r12,r8,0
8000cb8e:	f9 e8 10 08 	or	r8,r12,r8
8000cb92:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000cb96:	2f fc       	sub	r12,-1
8000cb98:	5e fc       	retal	r12

8000cb9a <__isnand>:
8000cb9a:	14 98       	mov	r8,r10
8000cb9c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cba0:	f0 0c 11 00 	rsub	r12,r8,0
8000cba4:	10 4c       	or	r12,r8
8000cba6:	fc 18 7f f0 	movh	r8,0x7ff0
8000cbaa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000cbae:	f0 0c 01 0c 	sub	r12,r8,r12
8000cbb2:	bf 9c       	lsr	r12,0x1f
8000cbb4:	5e fc       	retal	r12
8000cbb6:	d7 03       	nop

8000cbb8 <__sclose>:
8000cbb8:	d4 01       	pushm	lr
8000cbba:	96 7b       	ld.sh	r11,r11[0xe]
8000cbbc:	c8 2c       	rcall	8000ccc0 <_close_r>
8000cbbe:	d8 02       	popm	pc

8000cbc0 <__sseek>:
8000cbc0:	d4 21       	pushm	r4-r7,lr
8000cbc2:	16 97       	mov	r7,r11
8000cbc4:	96 7b       	ld.sh	r11,r11[0xe]
8000cbc6:	c0 3d       	rcall	8000cdcc <_lseek_r>
8000cbc8:	8e 68       	ld.sh	r8,r7[0xc]
8000cbca:	10 99       	mov	r9,r8
8000cbcc:	ad c8       	cbr	r8,0xc
8000cbce:	ad a9       	sbr	r9,0xc
8000cbd0:	5b fc       	cp.w	r12,-1
8000cbd2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cbd6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cbda:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cbde:	d8 22       	popm	r4-r7,pc

8000cbe0 <__swrite>:
8000cbe0:	d4 21       	pushm	r4-r7,lr
8000cbe2:	96 68       	ld.sh	r8,r11[0xc]
8000cbe4:	16 97       	mov	r7,r11
8000cbe6:	14 95       	mov	r5,r10
8000cbe8:	12 94       	mov	r4,r9
8000cbea:	e2 18 01 00 	andl	r8,0x100,COH
8000cbee:	18 96       	mov	r6,r12
8000cbf0:	c0 50       	breq	8000cbfa <__swrite+0x1a>
8000cbf2:	30 29       	mov	r9,2
8000cbf4:	30 0a       	mov	r10,0
8000cbf6:	96 7b       	ld.sh	r11,r11[0xe]
8000cbf8:	ce ac       	rcall	8000cdcc <_lseek_r>
8000cbfa:	8e 68       	ld.sh	r8,r7[0xc]
8000cbfc:	ad c8       	cbr	r8,0xc
8000cbfe:	08 99       	mov	r9,r4
8000cc00:	0a 9a       	mov	r10,r5
8000cc02:	8e 7b       	ld.sh	r11,r7[0xe]
8000cc04:	0c 9c       	mov	r12,r6
8000cc06:	ae 68       	st.h	r7[0xc],r8
8000cc08:	c1 cc       	rcall	8000cc40 <_write_r>
8000cc0a:	d8 22       	popm	r4-r7,pc

8000cc0c <__sread>:
8000cc0c:	d4 21       	pushm	r4-r7,lr
8000cc0e:	16 97       	mov	r7,r11
8000cc10:	96 7b       	ld.sh	r11,r11[0xe]
8000cc12:	cf 1c       	rcall	8000cdf4 <_read_r>
8000cc14:	c0 65       	brlt	8000cc20 <__sread+0x14>
8000cc16:	6f 58       	ld.w	r8,r7[0x54]
8000cc18:	18 08       	add	r8,r12
8000cc1a:	ef 48 00 54 	st.w	r7[84],r8
8000cc1e:	d8 22       	popm	r4-r7,pc
8000cc20:	8e 68       	ld.sh	r8,r7[0xc]
8000cc22:	ad c8       	cbr	r8,0xc
8000cc24:	ae 68       	st.h	r7[0xc],r8
8000cc26:	d8 22       	popm	r4-r7,pc

8000cc28 <strlen>:
8000cc28:	30 09       	mov	r9,0
8000cc2a:	18 98       	mov	r8,r12
8000cc2c:	c0 28       	rjmp	8000cc30 <strlen+0x8>
8000cc2e:	2f f8       	sub	r8,-1
8000cc30:	11 8a       	ld.ub	r10,r8[0x0]
8000cc32:	f2 0a 18 00 	cp.b	r10,r9
8000cc36:	cf c1       	brne	8000cc2e <strlen+0x6>
8000cc38:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc3c:	5e fc       	retal	r12
8000cc3e:	d7 03       	nop

8000cc40 <_write_r>:
8000cc40:	d4 21       	pushm	r4-r7,lr
8000cc42:	16 98       	mov	r8,r11
8000cc44:	18 97       	mov	r7,r12
8000cc46:	10 9c       	mov	r12,r8
8000cc48:	30 08       	mov	r8,0
8000cc4a:	14 9b       	mov	r11,r10
8000cc4c:	e0 66 9e 08 	mov	r6,40456
8000cc50:	12 9a       	mov	r10,r9
8000cc52:	8d 08       	st.w	r6[0x0],r8
8000cc54:	fe b0 d1 50 	rcall	80006ef4 <_write>
8000cc58:	5b fc       	cp.w	r12,-1
8000cc5a:	c0 51       	brne	8000cc64 <_write_r+0x24>
8000cc5c:	6c 08       	ld.w	r8,r6[0x0]
8000cc5e:	58 08       	cp.w	r8,0
8000cc60:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cc64:	d8 22       	popm	r4-r7,pc
8000cc66:	d7 03       	nop

8000cc68 <_calloc_r>:
8000cc68:	d4 21       	pushm	r4-r7,lr
8000cc6a:	f4 0b 02 4b 	mul	r11,r10,r11
8000cc6e:	fe b0 db 6d 	rcall	80008348 <_malloc_r>
8000cc72:	18 97       	mov	r7,r12
8000cc74:	c2 30       	breq	8000ccba <_calloc_r+0x52>
8000cc76:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cc7a:	e0 1a ff fc 	andl	r10,0xfffc
8000cc7e:	20 4a       	sub	r10,4
8000cc80:	e0 4a 00 24 	cp.w	r10,36
8000cc84:	e0 8b 00 18 	brhi	8000ccb4 <_calloc_r+0x4c>
8000cc88:	18 98       	mov	r8,r12
8000cc8a:	59 3a       	cp.w	r10,19
8000cc8c:	e0 88 00 0f 	brls	8000ccaa <_calloc_r+0x42>
8000cc90:	30 09       	mov	r9,0
8000cc92:	10 a9       	st.w	r8++,r9
8000cc94:	10 a9       	st.w	r8++,r9
8000cc96:	59 ba       	cp.w	r10,27
8000cc98:	e0 88 00 09 	brls	8000ccaa <_calloc_r+0x42>
8000cc9c:	10 a9       	st.w	r8++,r9
8000cc9e:	10 a9       	st.w	r8++,r9
8000cca0:	e0 4a 00 24 	cp.w	r10,36
8000cca4:	c0 31       	brne	8000ccaa <_calloc_r+0x42>
8000cca6:	10 a9       	st.w	r8++,r9
8000cca8:	10 a9       	st.w	r8++,r9
8000ccaa:	30 09       	mov	r9,0
8000ccac:	10 a9       	st.w	r8++,r9
8000ccae:	91 19       	st.w	r8[0x4],r9
8000ccb0:	91 09       	st.w	r8[0x0],r9
8000ccb2:	c0 48       	rjmp	8000ccba <_calloc_r+0x52>
8000ccb4:	30 0b       	mov	r11,0
8000ccb6:	fe b0 de 1c 	rcall	800088ee <memset>
8000ccba:	0e 9c       	mov	r12,r7
8000ccbc:	d8 22       	popm	r4-r7,pc
8000ccbe:	d7 03       	nop

8000ccc0 <_close_r>:
8000ccc0:	d4 21       	pushm	r4-r7,lr
8000ccc2:	30 08       	mov	r8,0
8000ccc4:	18 97       	mov	r7,r12
8000ccc6:	e0 66 9e 08 	mov	r6,40456
8000ccca:	16 9c       	mov	r12,r11
8000cccc:	8d 08       	st.w	r6[0x0],r8
8000ccce:	fe b0 df b5 	rcall	80008c38 <_close>
8000ccd2:	5b fc       	cp.w	r12,-1
8000ccd4:	c0 51       	brne	8000ccde <_close_r+0x1e>
8000ccd6:	6c 08       	ld.w	r8,r6[0x0]
8000ccd8:	58 08       	cp.w	r8,0
8000ccda:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ccde:	d8 22       	popm	r4-r7,pc

8000cce0 <_fclose_r>:
8000cce0:	d4 21       	pushm	r4-r7,lr
8000cce2:	18 96       	mov	r6,r12
8000cce4:	16 97       	mov	r7,r11
8000cce6:	58 0b       	cp.w	r11,0
8000cce8:	c0 31       	brne	8000ccee <_fclose_r+0xe>
8000ccea:	16 95       	mov	r5,r11
8000ccec:	c5 38       	rjmp	8000cd92 <_fclose_r+0xb2>
8000ccee:	fe b0 f8 a9 	rcall	8000be40 <__sfp_lock_acquire>
8000ccf2:	58 06       	cp.w	r6,0
8000ccf4:	c0 70       	breq	8000cd02 <_fclose_r+0x22>
8000ccf6:	6c 68       	ld.w	r8,r6[0x18]
8000ccf8:	58 08       	cp.w	r8,0
8000ccfa:	c0 41       	brne	8000cd02 <_fclose_r+0x22>
8000ccfc:	0c 9c       	mov	r12,r6
8000ccfe:	fe b0 f8 f3 	rcall	8000bee4 <__sinit>
8000cd02:	fe c8 d8 92 	sub	r8,pc,-10094
8000cd06:	10 37       	cp.w	r7,r8
8000cd08:	c0 31       	brne	8000cd0e <_fclose_r+0x2e>
8000cd0a:	6c 07       	ld.w	r7,r6[0x0]
8000cd0c:	c0 c8       	rjmp	8000cd24 <_fclose_r+0x44>
8000cd0e:	fe c8 d8 7e 	sub	r8,pc,-10114
8000cd12:	10 37       	cp.w	r7,r8
8000cd14:	c0 31       	brne	8000cd1a <_fclose_r+0x3a>
8000cd16:	6c 17       	ld.w	r7,r6[0x4]
8000cd18:	c0 68       	rjmp	8000cd24 <_fclose_r+0x44>
8000cd1a:	fe c8 d8 6a 	sub	r8,pc,-10134
8000cd1e:	10 37       	cp.w	r7,r8
8000cd20:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cd24:	8e 69       	ld.sh	r9,r7[0xc]
8000cd26:	30 08       	mov	r8,0
8000cd28:	f0 09 19 00 	cp.h	r9,r8
8000cd2c:	c0 51       	brne	8000cd36 <_fclose_r+0x56>
8000cd2e:	fe b0 f8 8a 	rcall	8000be42 <__sfp_lock_release>
8000cd32:	30 05       	mov	r5,0
8000cd34:	c2 f8       	rjmp	8000cd92 <_fclose_r+0xb2>
8000cd36:	0e 9b       	mov	r11,r7
8000cd38:	0c 9c       	mov	r12,r6
8000cd3a:	fe b0 f7 fd 	rcall	8000bd34 <_fflush_r>
8000cd3e:	6e c8       	ld.w	r8,r7[0x30]
8000cd40:	18 95       	mov	r5,r12
8000cd42:	58 08       	cp.w	r8,0
8000cd44:	c0 60       	breq	8000cd50 <_fclose_r+0x70>
8000cd46:	6e 8b       	ld.w	r11,r7[0x20]
8000cd48:	0c 9c       	mov	r12,r6
8000cd4a:	5d 18       	icall	r8
8000cd4c:	f9 b5 05 ff 	movlt	r5,-1
8000cd50:	8e 68       	ld.sh	r8,r7[0xc]
8000cd52:	ed b8 00 07 	bld	r8,0x7
8000cd56:	c0 51       	brne	8000cd60 <_fclose_r+0x80>
8000cd58:	6e 4b       	ld.w	r11,r7[0x10]
8000cd5a:	0c 9c       	mov	r12,r6
8000cd5c:	fe b0 f9 5e 	rcall	8000c018 <_free_r>
8000cd60:	6e db       	ld.w	r11,r7[0x34]
8000cd62:	58 0b       	cp.w	r11,0
8000cd64:	c0 a0       	breq	8000cd78 <_fclose_r+0x98>
8000cd66:	ee c8 ff bc 	sub	r8,r7,-68
8000cd6a:	10 3b       	cp.w	r11,r8
8000cd6c:	c0 40       	breq	8000cd74 <_fclose_r+0x94>
8000cd6e:	0c 9c       	mov	r12,r6
8000cd70:	fe b0 f9 54 	rcall	8000c018 <_free_r>
8000cd74:	30 08       	mov	r8,0
8000cd76:	8f d8       	st.w	r7[0x34],r8
8000cd78:	6f 2b       	ld.w	r11,r7[0x48]
8000cd7a:	58 0b       	cp.w	r11,0
8000cd7c:	c0 70       	breq	8000cd8a <_fclose_r+0xaa>
8000cd7e:	0c 9c       	mov	r12,r6
8000cd80:	fe b0 f9 4c 	rcall	8000c018 <_free_r>
8000cd84:	30 08       	mov	r8,0
8000cd86:	ef 48 00 48 	st.w	r7[72],r8
8000cd8a:	30 08       	mov	r8,0
8000cd8c:	ae 68       	st.h	r7[0xc],r8
8000cd8e:	fe b0 f8 5a 	rcall	8000be42 <__sfp_lock_release>
8000cd92:	0a 9c       	mov	r12,r5
8000cd94:	d8 22       	popm	r4-r7,pc
8000cd96:	d7 03       	nop

8000cd98 <fclose>:
8000cd98:	d4 01       	pushm	lr
8000cd9a:	e0 68 0a 54 	mov	r8,2644
8000cd9e:	18 9b       	mov	r11,r12
8000cda0:	70 0c       	ld.w	r12,r8[0x0]
8000cda2:	c9 ff       	rcall	8000cce0 <_fclose_r>
8000cda4:	d8 02       	popm	pc
8000cda6:	d7 03       	nop

8000cda8 <_fstat_r>:
8000cda8:	d4 21       	pushm	r4-r7,lr
8000cdaa:	16 98       	mov	r8,r11
8000cdac:	18 97       	mov	r7,r12
8000cdae:	10 9c       	mov	r12,r8
8000cdb0:	30 08       	mov	r8,0
8000cdb2:	e0 66 9e 08 	mov	r6,40456
8000cdb6:	14 9b       	mov	r11,r10
8000cdb8:	8d 08       	st.w	r6[0x0],r8
8000cdba:	fe b0 df 67 	rcall	80008c88 <_fstat>
8000cdbe:	5b fc       	cp.w	r12,-1
8000cdc0:	c0 51       	brne	8000cdca <_fstat_r+0x22>
8000cdc2:	6c 08       	ld.w	r8,r6[0x0]
8000cdc4:	58 08       	cp.w	r8,0
8000cdc6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cdca:	d8 22       	popm	r4-r7,pc

8000cdcc <_lseek_r>:
8000cdcc:	d4 21       	pushm	r4-r7,lr
8000cdce:	16 98       	mov	r8,r11
8000cdd0:	18 97       	mov	r7,r12
8000cdd2:	10 9c       	mov	r12,r8
8000cdd4:	30 08       	mov	r8,0
8000cdd6:	14 9b       	mov	r11,r10
8000cdd8:	e0 66 9e 08 	mov	r6,40456
8000cddc:	12 9a       	mov	r10,r9
8000cdde:	8d 08       	st.w	r6[0x0],r8
8000cde0:	fe b0 df 36 	rcall	80008c4c <_lseek>
8000cde4:	5b fc       	cp.w	r12,-1
8000cde6:	c0 51       	brne	8000cdf0 <_lseek_r+0x24>
8000cde8:	6c 08       	ld.w	r8,r6[0x0]
8000cdea:	58 08       	cp.w	r8,0
8000cdec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cdf0:	d8 22       	popm	r4-r7,pc
8000cdf2:	d7 03       	nop

8000cdf4 <_read_r>:
8000cdf4:	d4 21       	pushm	r4-r7,lr
8000cdf6:	16 98       	mov	r8,r11
8000cdf8:	18 97       	mov	r7,r12
8000cdfa:	10 9c       	mov	r12,r8
8000cdfc:	30 08       	mov	r8,0
8000cdfe:	14 9b       	mov	r11,r10
8000ce00:	e0 66 9e 08 	mov	r6,40456
8000ce04:	12 9a       	mov	r10,r9
8000ce06:	8d 08       	st.w	r6[0x0],r8
8000ce08:	fe b0 d0 56 	rcall	80006eb4 <_read>
8000ce0c:	5b fc       	cp.w	r12,-1
8000ce0e:	c0 51       	brne	8000ce18 <_read_r+0x24>
8000ce10:	6c 08       	ld.w	r8,r6[0x0]
8000ce12:	58 08       	cp.w	r8,0
8000ce14:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce18:	d8 22       	popm	r4-r7,pc
8000ce1a:	d7 03       	nop

8000ce1c <__avr32_f64_mul>:
8000ce1c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ce20:	e0 80 00 dc 	breq	8000cfd8 <__avr32_f64_mul_op1_zero>
8000ce24:	d4 21       	pushm	r4-r7,lr
8000ce26:	f7 e9 20 0e 	eor	lr,r11,r9
8000ce2a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ce2e:	30 15       	mov	r5,1
8000ce30:	c4 30       	breq	8000ceb6 <__avr32_f64_mul_op1_subnormal>
8000ce32:	ab 6b       	lsl	r11,0xa
8000ce34:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ce38:	ab 6a       	lsl	r10,0xa
8000ce3a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ce3e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ce42:	c5 c0       	breq	8000cefa <__avr32_f64_mul_op2_subnormal>
8000ce44:	a1 78       	lsl	r8,0x1
8000ce46:	5c f9       	rol	r9
8000ce48:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ce4c:	e0 47 07 ff 	cp.w	r7,2047
8000ce50:	c7 70       	breq	8000cf3e <__avr32_f64_mul_op_nan_or_inf>
8000ce52:	e0 46 07 ff 	cp.w	r6,2047
8000ce56:	c7 40       	breq	8000cf3e <__avr32_f64_mul_op_nan_or_inf>
8000ce58:	ee 06 00 0c 	add	r12,r7,r6
8000ce5c:	e0 2c 03 fe 	sub	r12,1022
8000ce60:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ce64:	f4 09 07 44 	macu.d	r4,r10,r9
8000ce68:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ce6c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ce70:	08 07       	add	r7,r4
8000ce72:	f4 05 00 4a 	adc	r10,r10,r5
8000ce76:	5c 0b       	acr	r11
8000ce78:	ed bb 00 14 	bld	r11,0x14
8000ce7c:	c0 50       	breq	8000ce86 <__avr32_f64_mul+0x6a>
8000ce7e:	a1 77       	lsl	r7,0x1
8000ce80:	5c fa       	rol	r10
8000ce82:	5c fb       	rol	r11
8000ce84:	20 1c       	sub	r12,1
8000ce86:	58 0c       	cp.w	r12,0
8000ce88:	e0 8a 00 6f 	brle	8000cf66 <__avr32_f64_mul_res_subnormal>
8000ce8c:	e0 4c 07 ff 	cp.w	r12,2047
8000ce90:	e0 84 00 9c 	brge	8000cfc8 <__avr32_f64_mul_res_inf>
8000ce94:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ce98:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ce9c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cea0:	ee 17 80 00 	eorh	r7,0x8000
8000cea4:	f1 b7 04 20 	satu	r7,0x1
8000cea8:	0e 0a       	add	r10,r7
8000ceaa:	5c 0b       	acr	r11
8000ceac:	ed be 00 1f 	bld	lr,0x1f
8000ceb0:	ef bb 00 1f 	bst	r11,0x1f
8000ceb4:	d8 22       	popm	r4-r7,pc

8000ceb6 <__avr32_f64_mul_op1_subnormal>:
8000ceb6:	e4 1b 00 0f 	andh	r11,0xf
8000ceba:	f4 0c 12 00 	clz	r12,r10
8000cebe:	f6 06 12 00 	clz	r6,r11
8000cec2:	f7 bc 03 e1 	sublo	r12,-31
8000cec6:	f8 06 17 30 	movlo	r6,r12
8000ceca:	f7 b6 02 01 	subhs	r6,1
8000cece:	e0 46 00 20 	cp.w	r6,32
8000ced2:	c0 d4       	brge	8000ceec <__avr32_f64_mul_op1_subnormal+0x36>
8000ced4:	ec 0c 11 20 	rsub	r12,r6,32
8000ced8:	f6 06 09 4b 	lsl	r11,r11,r6
8000cedc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cee0:	18 4b       	or	r11,r12
8000cee2:	f4 06 09 4a 	lsl	r10,r10,r6
8000cee6:	20 b6       	sub	r6,11
8000cee8:	0c 17       	sub	r7,r6
8000ceea:	ca ab       	rjmp	8000ce3e <__avr32_f64_mul+0x22>
8000ceec:	f4 06 09 4b 	lsl	r11,r10,r6
8000cef0:	c6 40       	breq	8000cfb8 <__avr32_f64_mul_res_zero>
8000cef2:	30 0a       	mov	r10,0
8000cef4:	20 b6       	sub	r6,11
8000cef6:	0c 17       	sub	r7,r6
8000cef8:	ca 3b       	rjmp	8000ce3e <__avr32_f64_mul+0x22>

8000cefa <__avr32_f64_mul_op2_subnormal>:
8000cefa:	e4 19 00 0f 	andh	r9,0xf
8000cefe:	f0 0c 12 00 	clz	r12,r8
8000cf02:	f2 05 12 00 	clz	r5,r9
8000cf06:	f7 bc 03 ea 	sublo	r12,-22
8000cf0a:	f8 05 17 30 	movlo	r5,r12
8000cf0e:	f7 b5 02 0a 	subhs	r5,10
8000cf12:	e0 45 00 20 	cp.w	r5,32
8000cf16:	c0 d4       	brge	8000cf30 <__avr32_f64_mul_op2_subnormal+0x36>
8000cf18:	ea 0c 11 20 	rsub	r12,r5,32
8000cf1c:	f2 05 09 49 	lsl	r9,r9,r5
8000cf20:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cf24:	18 49       	or	r9,r12
8000cf26:	f0 05 09 48 	lsl	r8,r8,r5
8000cf2a:	20 25       	sub	r5,2
8000cf2c:	0a 16       	sub	r6,r5
8000cf2e:	c8 fb       	rjmp	8000ce4c <__avr32_f64_mul+0x30>
8000cf30:	f0 05 09 49 	lsl	r9,r8,r5
8000cf34:	c4 20       	breq	8000cfb8 <__avr32_f64_mul_res_zero>
8000cf36:	30 08       	mov	r8,0
8000cf38:	20 25       	sub	r5,2
8000cf3a:	0a 16       	sub	r6,r5
8000cf3c:	c8 8b       	rjmp	8000ce4c <__avr32_f64_mul+0x30>

8000cf3e <__avr32_f64_mul_op_nan_or_inf>:
8000cf3e:	e4 19 00 0f 	andh	r9,0xf
8000cf42:	e4 1b 00 0f 	andh	r11,0xf
8000cf46:	14 4b       	or	r11,r10
8000cf48:	10 49       	or	r9,r8
8000cf4a:	e0 47 07 ff 	cp.w	r7,2047
8000cf4e:	c0 91       	brne	8000cf60 <__avr32_f64_mul_op1_not_naninf>
8000cf50:	58 0b       	cp.w	r11,0
8000cf52:	c3 81       	brne	8000cfc2 <__avr32_f64_mul_res_nan>
8000cf54:	e0 46 07 ff 	cp.w	r6,2047
8000cf58:	c3 81       	brne	8000cfc8 <__avr32_f64_mul_res_inf>
8000cf5a:	58 09       	cp.w	r9,0
8000cf5c:	c3 60       	breq	8000cfc8 <__avr32_f64_mul_res_inf>
8000cf5e:	c3 28       	rjmp	8000cfc2 <__avr32_f64_mul_res_nan>

8000cf60 <__avr32_f64_mul_op1_not_naninf>:
8000cf60:	58 09       	cp.w	r9,0
8000cf62:	c3 30       	breq	8000cfc8 <__avr32_f64_mul_res_inf>
8000cf64:	c2 f8       	rjmp	8000cfc2 <__avr32_f64_mul_res_nan>

8000cf66 <__avr32_f64_mul_res_subnormal>:
8000cf66:	5c 3c       	neg	r12
8000cf68:	2f fc       	sub	r12,-1
8000cf6a:	f1 bc 04 c0 	satu	r12,0x6
8000cf6e:	e0 4c 00 20 	cp.w	r12,32
8000cf72:	c1 14       	brge	8000cf94 <__avr32_f64_mul_res_subnormal+0x2e>
8000cf74:	f8 08 11 20 	rsub	r8,r12,32
8000cf78:	0e 46       	or	r6,r7
8000cf7a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000cf7e:	f4 08 09 49 	lsl	r9,r10,r8
8000cf82:	12 47       	or	r7,r9
8000cf84:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000cf88:	f6 08 09 49 	lsl	r9,r11,r8
8000cf8c:	12 4a       	or	r10,r9
8000cf8e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cf92:	c8 3b       	rjmp	8000ce98 <__avr32_f64_mul+0x7c>
8000cf94:	f8 08 11 20 	rsub	r8,r12,32
8000cf98:	f9 b9 00 00 	moveq	r9,0
8000cf9c:	c0 30       	breq	8000cfa2 <__avr32_f64_mul_res_subnormal+0x3c>
8000cf9e:	f6 08 09 49 	lsl	r9,r11,r8
8000cfa2:	0e 46       	or	r6,r7
8000cfa4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000cfa8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000cfac:	f3 ea 10 07 	or	r7,r9,r10
8000cfb0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000cfb4:	30 0b       	mov	r11,0
8000cfb6:	c7 1b       	rjmp	8000ce98 <__avr32_f64_mul+0x7c>

8000cfb8 <__avr32_f64_mul_res_zero>:
8000cfb8:	1c 9b       	mov	r11,lr
8000cfba:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cfbe:	30 0a       	mov	r10,0
8000cfc0:	d8 22       	popm	r4-r7,pc

8000cfc2 <__avr32_f64_mul_res_nan>:
8000cfc2:	3f fb       	mov	r11,-1
8000cfc4:	3f fa       	mov	r10,-1
8000cfc6:	d8 22       	popm	r4-r7,pc

8000cfc8 <__avr32_f64_mul_res_inf>:
8000cfc8:	f0 6b 00 00 	mov	r11,-1048576
8000cfcc:	ed be 00 1f 	bld	lr,0x1f
8000cfd0:	ef bb 00 1f 	bst	r11,0x1f
8000cfd4:	30 0a       	mov	r10,0
8000cfd6:	d8 22       	popm	r4-r7,pc

8000cfd8 <__avr32_f64_mul_op1_zero>:
8000cfd8:	f7 e9 20 0b 	eor	r11,r11,r9
8000cfdc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cfe0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000cfe4:	e0 4c 07 ff 	cp.w	r12,2047
8000cfe8:	5e 1c       	retne	r12
8000cfea:	3f fa       	mov	r10,-1
8000cfec:	3f fb       	mov	r11,-1
8000cfee:	5e fc       	retal	r12

8000cff0 <__avr32_f64_sub_from_add>:
8000cff0:	ee 19 80 00 	eorh	r9,0x8000

8000cff4 <__avr32_f64_sub>:
8000cff4:	f7 e9 20 0c 	eor	r12,r11,r9
8000cff8:	e0 86 00 ca 	brmi	8000d18c <__avr32_f64_add_from_sub>
8000cffc:	eb cd 40 e0 	pushm	r5-r7,lr
8000d000:	16 9c       	mov	r12,r11
8000d002:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d006:	bf db       	cbr	r11,0x1f
8000d008:	bf d9       	cbr	r9,0x1f
8000d00a:	10 3a       	cp.w	r10,r8
8000d00c:	f2 0b 13 00 	cpc	r11,r9
8000d010:	c0 92       	brcc	8000d022 <__avr32_f64_sub+0x2e>
8000d012:	16 97       	mov	r7,r11
8000d014:	12 9b       	mov	r11,r9
8000d016:	0e 99       	mov	r9,r7
8000d018:	14 97       	mov	r7,r10
8000d01a:	10 9a       	mov	r10,r8
8000d01c:	0e 98       	mov	r8,r7
8000d01e:	ee 1c 80 00 	eorh	r12,0x8000
8000d022:	f6 07 16 14 	lsr	r7,r11,0x14
8000d026:	ab 7b       	lsl	r11,0xb
8000d028:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d02c:	ab 7a       	lsl	r10,0xb
8000d02e:	bf bb       	sbr	r11,0x1f
8000d030:	f2 06 16 14 	lsr	r6,r9,0x14
8000d034:	c4 40       	breq	8000d0bc <__avr32_f64_sub_opL_subnormal>
8000d036:	ab 79       	lsl	r9,0xb
8000d038:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d03c:	ab 78       	lsl	r8,0xb
8000d03e:	bf b9       	sbr	r9,0x1f

8000d040 <__avr32_f64_sub_opL_subnormal_done>:
8000d040:	e0 47 07 ff 	cp.w	r7,2047
8000d044:	c4 f0       	breq	8000d0e2 <__avr32_f64_sub_opH_nan_or_inf>
8000d046:	0e 26       	rsub	r6,r7
8000d048:	c1 20       	breq	8000d06c <__avr32_f64_sub_shift_done>
8000d04a:	ec 05 11 20 	rsub	r5,r6,32
8000d04e:	e0 46 00 20 	cp.w	r6,32
8000d052:	c7 c2       	brcc	8000d14a <__avr32_f64_sub_longshift>
8000d054:	f0 05 09 4e 	lsl	lr,r8,r5
8000d058:	f2 05 09 45 	lsl	r5,r9,r5
8000d05c:	f0 06 0a 48 	lsr	r8,r8,r6
8000d060:	f2 06 0a 49 	lsr	r9,r9,r6
8000d064:	0a 48       	or	r8,r5
8000d066:	58 0e       	cp.w	lr,0
8000d068:	5f 1e       	srne	lr
8000d06a:	1c 48       	or	r8,lr

8000d06c <__avr32_f64_sub_shift_done>:
8000d06c:	10 1a       	sub	r10,r8
8000d06e:	f6 09 01 4b 	sbc	r11,r11,r9
8000d072:	f6 06 12 00 	clz	r6,r11
8000d076:	c0 e0       	breq	8000d092 <__avr32_f64_sub_longnormalize_done>
8000d078:	c7 83       	brcs	8000d168 <__avr32_f64_sub_longnormalize>
8000d07a:	ec 0e 11 20 	rsub	lr,r6,32
8000d07e:	f6 06 09 4b 	lsl	r11,r11,r6
8000d082:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d086:	1c 4b       	or	r11,lr
8000d088:	f4 06 09 4a 	lsl	r10,r10,r6
8000d08c:	0c 17       	sub	r7,r6
8000d08e:	e0 8a 00 39 	brle	8000d100 <__avr32_f64_sub_subnormal_result>

8000d092 <__avr32_f64_sub_longnormalize_done>:
8000d092:	f4 09 15 15 	lsl	r9,r10,0x15
8000d096:	ab 9a       	lsr	r10,0xb
8000d098:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d09c:	ab 9b       	lsr	r11,0xb
8000d09e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d0a2:	18 4b       	or	r11,r12

8000d0a4 <__avr32_f64_sub_round>:
8000d0a4:	fc 17 80 00 	movh	r7,0x8000
8000d0a8:	ed ba 00 00 	bld	r10,0x0
8000d0ac:	f7 b7 01 ff 	subne	r7,-1
8000d0b0:	0e 39       	cp.w	r9,r7
8000d0b2:	5f 29       	srhs	r9
8000d0b4:	12 0a       	add	r10,r9
8000d0b6:	5c 0b       	acr	r11
8000d0b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0bc <__avr32_f64_sub_opL_subnormal>:
8000d0bc:	ab 79       	lsl	r9,0xb
8000d0be:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d0c2:	ab 78       	lsl	r8,0xb
8000d0c4:	f3 e8 10 0e 	or	lr,r9,r8
8000d0c8:	f9 b6 01 01 	movne	r6,1
8000d0cc:	ee 0e 11 00 	rsub	lr,r7,0
8000d0d0:	f9 b7 00 01 	moveq	r7,1
8000d0d4:	ef bb 00 1f 	bst	r11,0x1f
8000d0d8:	f7 ea 10 0e 	or	lr,r11,r10
8000d0dc:	f9 b7 00 00 	moveq	r7,0
8000d0e0:	cb 0b       	rjmp	8000d040 <__avr32_f64_sub_opL_subnormal_done>

8000d0e2 <__avr32_f64_sub_opH_nan_or_inf>:
8000d0e2:	bf db       	cbr	r11,0x1f
8000d0e4:	f7 ea 10 0e 	or	lr,r11,r10
8000d0e8:	c0 81       	brne	8000d0f8 <__avr32_f64_sub_return_nan>
8000d0ea:	e0 46 07 ff 	cp.w	r6,2047
8000d0ee:	c0 50       	breq	8000d0f8 <__avr32_f64_sub_return_nan>
8000d0f0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000d0f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d0f8 <__avr32_f64_sub_return_nan>:
8000d0f8:	3f fa       	mov	r10,-1
8000d0fa:	3f fb       	mov	r11,-1
8000d0fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d100 <__avr32_f64_sub_subnormal_result>:
8000d100:	5c 37       	neg	r7
8000d102:	2f f7       	sub	r7,-1
8000d104:	f1 b7 04 c0 	satu	r7,0x6
8000d108:	e0 47 00 20 	cp.w	r7,32
8000d10c:	c1 14       	brge	8000d12e <__avr32_f64_sub_subnormal_result+0x2e>
8000d10e:	ee 08 11 20 	rsub	r8,r7,32
8000d112:	f4 08 09 49 	lsl	r9,r10,r8
8000d116:	5f 16       	srne	r6
8000d118:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d11c:	0c 4a       	or	r10,r6
8000d11e:	f6 08 09 49 	lsl	r9,r11,r8
8000d122:	f5 e9 10 0a 	or	r10,r10,r9
8000d126:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d12a:	30 07       	mov	r7,0
8000d12c:	cb 3b       	rjmp	8000d092 <__avr32_f64_sub_longnormalize_done>
8000d12e:	ee 08 11 40 	rsub	r8,r7,64
8000d132:	f6 08 09 49 	lsl	r9,r11,r8
8000d136:	14 49       	or	r9,r10
8000d138:	5f 16       	srne	r6
8000d13a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d13e:	0c 4a       	or	r10,r6
8000d140:	30 0b       	mov	r11,0
8000d142:	30 07       	mov	r7,0
8000d144:	ca 7b       	rjmp	8000d092 <__avr32_f64_sub_longnormalize_done>
8000d146:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d14a <__avr32_f64_sub_longshift>:
8000d14a:	f1 b6 04 c0 	satu	r6,0x6
8000d14e:	f0 0e 17 00 	moveq	lr,r8
8000d152:	c0 40       	breq	8000d15a <__avr32_f64_sub_longshift+0x10>
8000d154:	f2 05 09 4e 	lsl	lr,r9,r5
8000d158:	10 4e       	or	lr,r8
8000d15a:	f2 06 0a 48 	lsr	r8,r9,r6
8000d15e:	30 09       	mov	r9,0
8000d160:	58 0e       	cp.w	lr,0
8000d162:	5f 1e       	srne	lr
8000d164:	1c 48       	or	r8,lr
8000d166:	c8 3b       	rjmp	8000d06c <__avr32_f64_sub_shift_done>

8000d168 <__avr32_f64_sub_longnormalize>:
8000d168:	f4 06 12 00 	clz	r6,r10
8000d16c:	f9 b7 03 00 	movlo	r7,0
8000d170:	f9 b6 03 00 	movlo	r6,0
8000d174:	f9 bc 03 00 	movlo	r12,0
8000d178:	f7 b6 02 e0 	subhs	r6,-32
8000d17c:	f4 06 09 4b 	lsl	r11,r10,r6
8000d180:	30 0a       	mov	r10,0
8000d182:	0c 17       	sub	r7,r6
8000d184:	fe 9a ff be 	brle	8000d100 <__avr32_f64_sub_subnormal_result>
8000d188:	c8 5b       	rjmp	8000d092 <__avr32_f64_sub_longnormalize_done>
8000d18a:	d7 03       	nop

8000d18c <__avr32_f64_add_from_sub>:
8000d18c:	ee 19 80 00 	eorh	r9,0x8000

8000d190 <__avr32_f64_add>:
8000d190:	f7 e9 20 0c 	eor	r12,r11,r9
8000d194:	fe 96 ff 2e 	brmi	8000cff0 <__avr32_f64_sub_from_add>
8000d198:	eb cd 40 e0 	pushm	r5-r7,lr
8000d19c:	16 9c       	mov	r12,r11
8000d19e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d1a2:	bf db       	cbr	r11,0x1f
8000d1a4:	bf d9       	cbr	r9,0x1f
8000d1a6:	12 3b       	cp.w	r11,r9
8000d1a8:	c0 72       	brcc	8000d1b6 <__avr32_f64_add+0x26>
8000d1aa:	16 97       	mov	r7,r11
8000d1ac:	12 9b       	mov	r11,r9
8000d1ae:	0e 99       	mov	r9,r7
8000d1b0:	14 97       	mov	r7,r10
8000d1b2:	10 9a       	mov	r10,r8
8000d1b4:	0e 98       	mov	r8,r7
8000d1b6:	30 0e       	mov	lr,0
8000d1b8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d1bc:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d1c0:	b5 ab       	sbr	r11,0x14
8000d1c2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d1c6:	c6 20       	breq	8000d28a <__avr32_f64_add_op2_subnormal>
8000d1c8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d1cc:	b5 a9       	sbr	r9,0x14
8000d1ce:	e0 47 07 ff 	cp.w	r7,2047
8000d1d2:	c2 80       	breq	8000d222 <__avr32_f64_add_opH_nan_or_inf>
8000d1d4:	0e 26       	rsub	r6,r7
8000d1d6:	c1 20       	breq	8000d1fa <__avr32_f64_add_shift_done>
8000d1d8:	e0 46 00 36 	cp.w	r6,54
8000d1dc:	c1 52       	brcc	8000d206 <__avr32_f64_add_res_of_done>
8000d1de:	ec 05 11 20 	rsub	r5,r6,32
8000d1e2:	e0 46 00 20 	cp.w	r6,32
8000d1e6:	c3 52       	brcc	8000d250 <__avr32_f64_add_longshift>
8000d1e8:	f0 05 09 4e 	lsl	lr,r8,r5
8000d1ec:	f2 05 09 45 	lsl	r5,r9,r5
8000d1f0:	f0 06 0a 48 	lsr	r8,r8,r6
8000d1f4:	f2 06 0a 49 	lsr	r9,r9,r6
8000d1f8:	0a 48       	or	r8,r5

8000d1fa <__avr32_f64_add_shift_done>:
8000d1fa:	10 0a       	add	r10,r8
8000d1fc:	f6 09 00 4b 	adc	r11,r11,r9
8000d200:	ed bb 00 15 	bld	r11,0x15
8000d204:	c3 40       	breq	8000d26c <__avr32_f64_add_res_of>

8000d206 <__avr32_f64_add_res_of_done>:
8000d206:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d20a:	18 4b       	or	r11,r12

8000d20c <__avr32_f64_add_round>:
8000d20c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d210:	18 4e       	or	lr,r12
8000d212:	ee 1e 80 00 	eorh	lr,0x8000
8000d216:	f1 be 04 20 	satu	lr,0x1
8000d21a:	1c 0a       	add	r10,lr
8000d21c:	5c 0b       	acr	r11
8000d21e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d222 <__avr32_f64_add_opH_nan_or_inf>:
8000d222:	b5 cb       	cbr	r11,0x14
8000d224:	f7 ea 10 0e 	or	lr,r11,r10
8000d228:	c1 01       	brne	8000d248 <__avr32_f64_add_return_nan>
8000d22a:	e0 46 07 ff 	cp.w	r6,2047
8000d22e:	c0 30       	breq	8000d234 <__avr32_f64_add_opL_nan_or_inf>
8000d230:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d234 <__avr32_f64_add_opL_nan_or_inf>:
8000d234:	b5 c9       	cbr	r9,0x14
8000d236:	f3 e8 10 0e 	or	lr,r9,r8
8000d23a:	c0 71       	brne	8000d248 <__avr32_f64_add_return_nan>
8000d23c:	30 0a       	mov	r10,0
8000d23e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d242:	18 4b       	or	r11,r12
8000d244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d248 <__avr32_f64_add_return_nan>:
8000d248:	3f fa       	mov	r10,-1
8000d24a:	3f fb       	mov	r11,-1
8000d24c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d250 <__avr32_f64_add_longshift>:
8000d250:	f1 b6 04 c0 	satu	r6,0x6
8000d254:	f0 0e 17 00 	moveq	lr,r8
8000d258:	c0 60       	breq	8000d264 <__avr32_f64_add_longshift+0x14>
8000d25a:	f2 05 09 4e 	lsl	lr,r9,r5
8000d25e:	58 08       	cp.w	r8,0
8000d260:	5f 18       	srne	r8
8000d262:	10 4e       	or	lr,r8
8000d264:	f2 06 0a 48 	lsr	r8,r9,r6
8000d268:	30 09       	mov	r9,0
8000d26a:	cc 8b       	rjmp	8000d1fa <__avr32_f64_add_shift_done>

8000d26c <__avr32_f64_add_res_of>:
8000d26c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d270:	a1 9b       	lsr	r11,0x1
8000d272:	5d 0a       	ror	r10
8000d274:	5d 0e       	ror	lr
8000d276:	2f f7       	sub	r7,-1
8000d278:	e0 47 07 ff 	cp.w	r7,2047
8000d27c:	f9 ba 00 00 	moveq	r10,0
8000d280:	f9 bb 00 00 	moveq	r11,0
8000d284:	f9 be 00 00 	moveq	lr,0
8000d288:	cb fb       	rjmp	8000d206 <__avr32_f64_add_res_of_done>

8000d28a <__avr32_f64_add_op2_subnormal>:
8000d28a:	30 16       	mov	r6,1
8000d28c:	58 07       	cp.w	r7,0
8000d28e:	ca 01       	brne	8000d1ce <__avr32_f64_add+0x3e>
8000d290:	b5 cb       	cbr	r11,0x14
8000d292:	10 0a       	add	r10,r8
8000d294:	f6 09 00 4b 	adc	r11,r11,r9
8000d298:	18 4b       	or	r11,r12
8000d29a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d29e:	d7 03       	nop

8000d2a0 <__avr32_f64_to_u32>:
8000d2a0:	58 0b       	cp.w	r11,0
8000d2a2:	5e 6d       	retmi	0

8000d2a4 <__avr32_f64_to_s32>:
8000d2a4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d2a8:	b5 9c       	lsr	r12,0x15
8000d2aa:	e0 2c 03 ff 	sub	r12,1023
8000d2ae:	5e 3d       	retlo	0
8000d2b0:	f8 0c 11 1f 	rsub	r12,r12,31
8000d2b4:	16 99       	mov	r9,r11
8000d2b6:	ab 7b       	lsl	r11,0xb
8000d2b8:	bf bb       	sbr	r11,0x1f
8000d2ba:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d2be:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d2c2:	a1 79       	lsl	r9,0x1
8000d2c4:	5e 2b       	reths	r11
8000d2c6:	5c 3b       	neg	r11
8000d2c8:	5e fb       	retal	r11

8000d2ca <__avr32_u32_to_f64>:
8000d2ca:	f8 cb 00 00 	sub	r11,r12,0
8000d2ce:	30 0c       	mov	r12,0
8000d2d0:	c0 38       	rjmp	8000d2d6 <__avr32_s32_to_f64+0x4>

8000d2d2 <__avr32_s32_to_f64>:
8000d2d2:	18 9b       	mov	r11,r12
8000d2d4:	5c 4b       	abs	r11
8000d2d6:	30 0a       	mov	r10,0
8000d2d8:	5e 0b       	reteq	r11
8000d2da:	d4 01       	pushm	lr
8000d2dc:	e0 69 04 1e 	mov	r9,1054
8000d2e0:	f6 08 12 00 	clz	r8,r11
8000d2e4:	c1 70       	breq	8000d312 <__avr32_s32_to_f64+0x40>
8000d2e6:	c0 c3       	brcs	8000d2fe <__avr32_s32_to_f64+0x2c>
8000d2e8:	f0 0e 11 20 	rsub	lr,r8,32
8000d2ec:	f6 08 09 4b 	lsl	r11,r11,r8
8000d2f0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d2f4:	1c 4b       	or	r11,lr
8000d2f6:	f4 08 09 4a 	lsl	r10,r10,r8
8000d2fa:	10 19       	sub	r9,r8
8000d2fc:	c0 b8       	rjmp	8000d312 <__avr32_s32_to_f64+0x40>
8000d2fe:	f4 08 12 00 	clz	r8,r10
8000d302:	f9 b8 03 00 	movlo	r8,0
8000d306:	f7 b8 02 e0 	subhs	r8,-32
8000d30a:	f4 08 09 4b 	lsl	r11,r10,r8
8000d30e:	30 0a       	mov	r10,0
8000d310:	10 19       	sub	r9,r8
8000d312:	58 09       	cp.w	r9,0
8000d314:	e0 89 00 30 	brgt	8000d374 <__avr32_s32_to_f64+0xa2>
8000d318:	5c 39       	neg	r9
8000d31a:	2f f9       	sub	r9,-1
8000d31c:	e0 49 00 36 	cp.w	r9,54
8000d320:	c0 43       	brcs	8000d328 <__avr32_s32_to_f64+0x56>
8000d322:	30 0b       	mov	r11,0
8000d324:	30 0a       	mov	r10,0
8000d326:	c2 68       	rjmp	8000d372 <__avr32_s32_to_f64+0xa0>
8000d328:	2f 69       	sub	r9,-10
8000d32a:	f2 08 11 20 	rsub	r8,r9,32
8000d32e:	e0 49 00 20 	cp.w	r9,32
8000d332:	c0 b2       	brcc	8000d348 <__avr32_s32_to_f64+0x76>
8000d334:	f4 08 09 4e 	lsl	lr,r10,r8
8000d338:	f6 08 09 48 	lsl	r8,r11,r8
8000d33c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d340:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d344:	10 4b       	or	r11,r8
8000d346:	c0 88       	rjmp	8000d356 <__avr32_s32_to_f64+0x84>
8000d348:	f6 08 09 4e 	lsl	lr,r11,r8
8000d34c:	14 4e       	or	lr,r10
8000d34e:	16 9a       	mov	r10,r11
8000d350:	30 0b       	mov	r11,0
8000d352:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d356:	ed ba 00 00 	bld	r10,0x0
8000d35a:	c0 92       	brcc	8000d36c <__avr32_s32_to_f64+0x9a>
8000d35c:	1c 7e       	tst	lr,lr
8000d35e:	c0 41       	brne	8000d366 <__avr32_s32_to_f64+0x94>
8000d360:	ed ba 00 01 	bld	r10,0x1
8000d364:	c0 42       	brcc	8000d36c <__avr32_s32_to_f64+0x9a>
8000d366:	2f fa       	sub	r10,-1
8000d368:	f7 bb 02 ff 	subhs	r11,-1
8000d36c:	5c fc       	rol	r12
8000d36e:	5d 0b       	ror	r11
8000d370:	5d 0a       	ror	r10
8000d372:	d8 02       	popm	pc
8000d374:	e0 68 03 ff 	mov	r8,1023
8000d378:	ed ba 00 0b 	bld	r10,0xb
8000d37c:	f7 b8 00 ff 	subeq	r8,-1
8000d380:	10 0a       	add	r10,r8
8000d382:	5c 0b       	acr	r11
8000d384:	f7 b9 03 fe 	sublo	r9,-2
8000d388:	e0 49 07 ff 	cp.w	r9,2047
8000d38c:	c0 55       	brlt	8000d396 <__avr32_s32_to_f64+0xc4>
8000d38e:	30 0a       	mov	r10,0
8000d390:	fc 1b ff e0 	movh	r11,0xffe0
8000d394:	c0 c8       	rjmp	8000d3ac <__floatsidf_return_op1>
8000d396:	ed bb 00 1f 	bld	r11,0x1f
8000d39a:	f7 b9 01 01 	subne	r9,1
8000d39e:	ab 9a       	lsr	r10,0xb
8000d3a0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d3a4:	a1 7b       	lsl	r11,0x1
8000d3a6:	ab 9b       	lsr	r11,0xb
8000d3a8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d3ac <__floatsidf_return_op1>:
8000d3ac:	a1 7c       	lsl	r12,0x1
8000d3ae:	5d 0b       	ror	r11
8000d3b0:	d8 02       	popm	pc

8000d3b2 <__avr32_f64_cmp_eq>:
8000d3b2:	10 3a       	cp.w	r10,r8
8000d3b4:	f2 0b 13 00 	cpc	r11,r9
8000d3b8:	c0 80       	breq	8000d3c8 <__avr32_f64_cmp_eq+0x16>
8000d3ba:	a1 7b       	lsl	r11,0x1
8000d3bc:	a1 79       	lsl	r9,0x1
8000d3be:	14 4b       	or	r11,r10
8000d3c0:	12 4b       	or	r11,r9
8000d3c2:	10 4b       	or	r11,r8
8000d3c4:	5e 0f       	reteq	1
8000d3c6:	5e fd       	retal	0
8000d3c8:	a1 7b       	lsl	r11,0x1
8000d3ca:	fc 1c ff e0 	movh	r12,0xffe0
8000d3ce:	58 0a       	cp.w	r10,0
8000d3d0:	f8 0b 13 00 	cpc	r11,r12
8000d3d4:	5e 8f       	retls	1
8000d3d6:	5e fd       	retal	0

8000d3d8 <__avr32_f64_cmp_ge>:
8000d3d8:	1a de       	st.w	--sp,lr
8000d3da:	1a d7       	st.w	--sp,r7
8000d3dc:	a1 7b       	lsl	r11,0x1
8000d3de:	5f 3c       	srlo	r12
8000d3e0:	a1 79       	lsl	r9,0x1
8000d3e2:	5f 37       	srlo	r7
8000d3e4:	5c fc       	rol	r12
8000d3e6:	fc 1e ff e0 	movh	lr,0xffe0
8000d3ea:	58 0a       	cp.w	r10,0
8000d3ec:	fc 0b 13 00 	cpc	r11,lr
8000d3f0:	e0 8b 00 1d 	brhi	8000d42a <__avr32_f64_cmp_ge+0x52>
8000d3f4:	58 08       	cp.w	r8,0
8000d3f6:	fc 09 13 00 	cpc	r9,lr
8000d3fa:	e0 8b 00 18 	brhi	8000d42a <__avr32_f64_cmp_ge+0x52>
8000d3fe:	58 0b       	cp.w	r11,0
8000d400:	f5 ba 00 00 	subfeq	r10,0
8000d404:	c1 50       	breq	8000d42e <__avr32_f64_cmp_ge+0x56>
8000d406:	1b 07       	ld.w	r7,sp++
8000d408:	1b 0e       	ld.w	lr,sp++
8000d40a:	58 3c       	cp.w	r12,3
8000d40c:	c0 a0       	breq	8000d420 <__avr32_f64_cmp_ge+0x48>
8000d40e:	58 1c       	cp.w	r12,1
8000d410:	c0 33       	brcs	8000d416 <__avr32_f64_cmp_ge+0x3e>
8000d412:	5e 0f       	reteq	1
8000d414:	5e 1d       	retne	0
8000d416:	10 3a       	cp.w	r10,r8
8000d418:	f2 0b 13 00 	cpc	r11,r9
8000d41c:	5e 2f       	reths	1
8000d41e:	5e 3d       	retlo	0
8000d420:	14 38       	cp.w	r8,r10
8000d422:	f6 09 13 00 	cpc	r9,r11
8000d426:	5e 2f       	reths	1
8000d428:	5e 3d       	retlo	0
8000d42a:	1b 07       	ld.w	r7,sp++
8000d42c:	d8 0a       	popm	pc,r12=0
8000d42e:	58 17       	cp.w	r7,1
8000d430:	5f 0c       	sreq	r12
8000d432:	58 09       	cp.w	r9,0
8000d434:	f5 b8 00 00 	subfeq	r8,0
8000d438:	1b 07       	ld.w	r7,sp++
8000d43a:	1b 0e       	ld.w	lr,sp++
8000d43c:	5e 0f       	reteq	1
8000d43e:	5e fc       	retal	r12

8000d440 <__avr32_f64_cmp_lt>:
8000d440:	1a de       	st.w	--sp,lr
8000d442:	1a d7       	st.w	--sp,r7
8000d444:	a1 7b       	lsl	r11,0x1
8000d446:	5f 3c       	srlo	r12
8000d448:	a1 79       	lsl	r9,0x1
8000d44a:	5f 37       	srlo	r7
8000d44c:	5c fc       	rol	r12
8000d44e:	fc 1e ff e0 	movh	lr,0xffe0
8000d452:	58 0a       	cp.w	r10,0
8000d454:	fc 0b 13 00 	cpc	r11,lr
8000d458:	e0 8b 00 1d 	brhi	8000d492 <__avr32_f64_cmp_lt+0x52>
8000d45c:	58 08       	cp.w	r8,0
8000d45e:	fc 09 13 00 	cpc	r9,lr
8000d462:	e0 8b 00 18 	brhi	8000d492 <__avr32_f64_cmp_lt+0x52>
8000d466:	58 0b       	cp.w	r11,0
8000d468:	f5 ba 00 00 	subfeq	r10,0
8000d46c:	c1 50       	breq	8000d496 <__avr32_f64_cmp_lt+0x56>
8000d46e:	1b 07       	ld.w	r7,sp++
8000d470:	1b 0e       	ld.w	lr,sp++
8000d472:	58 3c       	cp.w	r12,3
8000d474:	c0 a0       	breq	8000d488 <__avr32_f64_cmp_lt+0x48>
8000d476:	58 1c       	cp.w	r12,1
8000d478:	c0 33       	brcs	8000d47e <__avr32_f64_cmp_lt+0x3e>
8000d47a:	5e 0d       	reteq	0
8000d47c:	5e 1f       	retne	1
8000d47e:	10 3a       	cp.w	r10,r8
8000d480:	f2 0b 13 00 	cpc	r11,r9
8000d484:	5e 2d       	reths	0
8000d486:	5e 3f       	retlo	1
8000d488:	14 38       	cp.w	r8,r10
8000d48a:	f6 09 13 00 	cpc	r9,r11
8000d48e:	5e 2d       	reths	0
8000d490:	5e 3f       	retlo	1
8000d492:	1b 07       	ld.w	r7,sp++
8000d494:	d8 0a       	popm	pc,r12=0
8000d496:	58 17       	cp.w	r7,1
8000d498:	5f 1c       	srne	r12
8000d49a:	58 09       	cp.w	r9,0
8000d49c:	f5 b8 00 00 	subfeq	r8,0
8000d4a0:	1b 07       	ld.w	r7,sp++
8000d4a2:	1b 0e       	ld.w	lr,sp++
8000d4a4:	5e 0d       	reteq	0
8000d4a6:	5e fc       	retal	r12

8000d4a8 <__avr32_f64_div>:
8000d4a8:	eb cd 40 ff 	pushm	r0-r7,lr
8000d4ac:	f7 e9 20 0e 	eor	lr,r11,r9
8000d4b0:	f6 07 16 14 	lsr	r7,r11,0x14
8000d4b4:	a9 7b       	lsl	r11,0x9
8000d4b6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d4ba:	a9 7a       	lsl	r10,0x9
8000d4bc:	bd bb       	sbr	r11,0x1d
8000d4be:	e4 1b 3f ff 	andh	r11,0x3fff
8000d4c2:	ab d7       	cbr	r7,0xb
8000d4c4:	e0 80 00 cc 	breq	8000d65c <__avr32_f64_div_round_subnormal+0x54>
8000d4c8:	e0 47 07 ff 	cp.w	r7,2047
8000d4cc:	e0 84 00 b5 	brge	8000d636 <__avr32_f64_div_round_subnormal+0x2e>
8000d4d0:	f2 06 16 14 	lsr	r6,r9,0x14
8000d4d4:	a9 79       	lsl	r9,0x9
8000d4d6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d4da:	a9 78       	lsl	r8,0x9
8000d4dc:	bd b9       	sbr	r9,0x1d
8000d4de:	e4 19 3f ff 	andh	r9,0x3fff
8000d4e2:	ab d6       	cbr	r6,0xb
8000d4e4:	e0 80 00 e2 	breq	8000d6a8 <__avr32_f64_div_round_subnormal+0xa0>
8000d4e8:	e0 46 07 ff 	cp.w	r6,2047
8000d4ec:	e0 84 00 b2 	brge	8000d650 <__avr32_f64_div_round_subnormal+0x48>
8000d4f0:	0c 17       	sub	r7,r6
8000d4f2:	fe 37 fc 01 	sub	r7,-1023
8000d4f6:	fc 1c 80 00 	movh	r12,0x8000
8000d4fa:	f8 03 16 01 	lsr	r3,r12,0x1
8000d4fe:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d502:	5c d4       	com	r4
8000d504:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d508:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d50c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d510:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d514:	ea 03 15 02 	lsl	r3,r5,0x2
8000d518:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d51c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d520:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d524:	ea 03 15 02 	lsl	r3,r5,0x2
8000d528:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d52c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d530:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d534:	ea 03 15 02 	lsl	r3,r5,0x2
8000d538:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d53c:	e4 09 07 40 	macu.d	r0,r2,r9
8000d540:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d544:	02 04       	add	r4,r1
8000d546:	5c 05       	acr	r5
8000d548:	a3 65       	lsl	r5,0x2
8000d54a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d54e:	a3 64       	lsl	r4,0x2
8000d550:	5c 34       	neg	r4
8000d552:	f8 05 01 45 	sbc	r5,r12,r5
8000d556:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d55a:	e4 05 07 40 	macu.d	r0,r2,r5
8000d55e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d562:	02 04       	add	r4,r1
8000d564:	5c 05       	acr	r5
8000d566:	ea 03 15 02 	lsl	r3,r5,0x2
8000d56a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d56e:	e8 02 15 02 	lsl	r2,r4,0x2
8000d572:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d576:	e4 09 07 40 	macu.d	r0,r2,r9
8000d57a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d57e:	02 04       	add	r4,r1
8000d580:	5c 05       	acr	r5
8000d582:	a3 65       	lsl	r5,0x2
8000d584:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d588:	a3 64       	lsl	r4,0x2
8000d58a:	5c 34       	neg	r4
8000d58c:	f8 05 01 45 	sbc	r5,r12,r5
8000d590:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d594:	e4 05 07 40 	macu.d	r0,r2,r5
8000d598:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d59c:	02 04       	add	r4,r1
8000d59e:	5c 05       	acr	r5
8000d5a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5a4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d5a8:	e8 02 15 02 	lsl	r2,r4,0x2
8000d5ac:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d5b0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d5b4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d5b8:	02 02       	add	r2,r1
8000d5ba:	5c 03       	acr	r3
8000d5bc:	ed b3 00 1c 	bld	r3,0x1c
8000d5c0:	c0 90       	breq	8000d5d2 <__avr32_f64_div+0x12a>
8000d5c2:	a1 72       	lsl	r2,0x1
8000d5c4:	5c f3       	rol	r3
8000d5c6:	20 17       	sub	r7,1
8000d5c8:	a3 9a       	lsr	r10,0x3
8000d5ca:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d5ce:	a3 9b       	lsr	r11,0x3
8000d5d0:	c0 58       	rjmp	8000d5da <__avr32_f64_div+0x132>
8000d5d2:	a5 8a       	lsr	r10,0x4
8000d5d4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d5d8:	a5 8b       	lsr	r11,0x4
8000d5da:	58 07       	cp.w	r7,0
8000d5dc:	e0 8a 00 8b 	brle	8000d6f2 <__avr32_f64_div_res_subnormal>
8000d5e0:	e0 12 ff 00 	andl	r2,0xff00
8000d5e4:	e8 12 00 80 	orl	r2,0x80
8000d5e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5ec:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5f0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d5f4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d5f8:	00 05       	add	r5,r0
8000d5fa:	f0 01 00 48 	adc	r8,r8,r1
8000d5fe:	5c 09       	acr	r9
8000d600:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d604:	58 04       	cp.w	r4,0
8000d606:	5c 25       	cpc	r5

8000d608 <__avr32_f64_div_round_subnormal>:
8000d608:	f4 08 13 00 	cpc	r8,r10
8000d60c:	f6 09 13 00 	cpc	r9,r11
8000d610:	5f 36       	srlo	r6
8000d612:	f8 06 17 00 	moveq	r6,r12
8000d616:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d61a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d61e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d622:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d626:	ed be 00 1f 	bld	lr,0x1f
8000d62a:	ef bb 00 1f 	bst	r11,0x1f
8000d62e:	0c 0a       	add	r10,r6
8000d630:	5c 0b       	acr	r11
8000d632:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d636:	e4 1b 00 0f 	andh	r11,0xf
8000d63a:	14 4b       	or	r11,r10
8000d63c:	e0 81 00 a7 	brne	8000d78a <__avr32_f64_div_res_subnormal+0x98>
8000d640:	f2 06 16 14 	lsr	r6,r9,0x14
8000d644:	ab d6       	cbr	r6,0xb
8000d646:	e0 46 07 ff 	cp.w	r6,2047
8000d64a:	e0 81 00 a4 	brne	8000d792 <__avr32_f64_div_res_subnormal+0xa0>
8000d64e:	c9 e8       	rjmp	8000d78a <__avr32_f64_div_res_subnormal+0x98>
8000d650:	e4 19 00 0f 	andh	r9,0xf
8000d654:	10 49       	or	r9,r8
8000d656:	e0 81 00 9a 	brne	8000d78a <__avr32_f64_div_res_subnormal+0x98>
8000d65a:	c9 28       	rjmp	8000d77e <__avr32_f64_div_res_subnormal+0x8c>
8000d65c:	a3 7b       	lsl	r11,0x3
8000d65e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d662:	a3 7a       	lsl	r10,0x3
8000d664:	f5 eb 10 04 	or	r4,r10,r11
8000d668:	e0 80 00 a0 	breq	8000d7a8 <__avr32_f64_div_op1_zero>
8000d66c:	f6 04 12 00 	clz	r4,r11
8000d670:	c1 70       	breq	8000d69e <__avr32_f64_div_round_subnormal+0x96>
8000d672:	c0 c3       	brcs	8000d68a <__avr32_f64_div_round_subnormal+0x82>
8000d674:	e8 05 11 20 	rsub	r5,r4,32
8000d678:	f6 04 09 4b 	lsl	r11,r11,r4
8000d67c:	f4 05 0a 45 	lsr	r5,r10,r5
8000d680:	0a 4b       	or	r11,r5
8000d682:	f4 04 09 4a 	lsl	r10,r10,r4
8000d686:	08 17       	sub	r7,r4
8000d688:	c0 b8       	rjmp	8000d69e <__avr32_f64_div_round_subnormal+0x96>
8000d68a:	f4 04 12 00 	clz	r4,r10
8000d68e:	f9 b4 03 00 	movlo	r4,0
8000d692:	f7 b4 02 e0 	subhs	r4,-32
8000d696:	f4 04 09 4b 	lsl	r11,r10,r4
8000d69a:	30 0a       	mov	r10,0
8000d69c:	08 17       	sub	r7,r4
8000d69e:	a3 8a       	lsr	r10,0x2
8000d6a0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d6a4:	a3 8b       	lsr	r11,0x2
8000d6a6:	c1 1b       	rjmp	8000d4c8 <__avr32_f64_div+0x20>
8000d6a8:	a3 79       	lsl	r9,0x3
8000d6aa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d6ae:	a3 78       	lsl	r8,0x3
8000d6b0:	f3 e8 10 04 	or	r4,r9,r8
8000d6b4:	c6 f0       	breq	8000d792 <__avr32_f64_div_res_subnormal+0xa0>
8000d6b6:	f2 04 12 00 	clz	r4,r9
8000d6ba:	c1 70       	breq	8000d6e8 <__avr32_f64_div_round_subnormal+0xe0>
8000d6bc:	c0 c3       	brcs	8000d6d4 <__avr32_f64_div_round_subnormal+0xcc>
8000d6be:	e8 05 11 20 	rsub	r5,r4,32
8000d6c2:	f2 04 09 49 	lsl	r9,r9,r4
8000d6c6:	f0 05 0a 45 	lsr	r5,r8,r5
8000d6ca:	0a 49       	or	r9,r5
8000d6cc:	f0 04 09 48 	lsl	r8,r8,r4
8000d6d0:	08 16       	sub	r6,r4
8000d6d2:	c0 b8       	rjmp	8000d6e8 <__avr32_f64_div_round_subnormal+0xe0>
8000d6d4:	f0 04 12 00 	clz	r4,r8
8000d6d8:	f9 b4 03 00 	movlo	r4,0
8000d6dc:	f7 b4 02 e0 	subhs	r4,-32
8000d6e0:	f0 04 09 49 	lsl	r9,r8,r4
8000d6e4:	30 08       	mov	r8,0
8000d6e6:	08 16       	sub	r6,r4
8000d6e8:	a3 88       	lsr	r8,0x2
8000d6ea:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d6ee:	a3 89       	lsr	r9,0x2
8000d6f0:	cf ca       	rjmp	8000d4e8 <__avr32_f64_div+0x40>

8000d6f2 <__avr32_f64_div_res_subnormal>:
8000d6f2:	5c 37       	neg	r7
8000d6f4:	2f f7       	sub	r7,-1
8000d6f6:	f1 b7 04 c0 	satu	r7,0x6
8000d6fa:	e0 47 00 20 	cp.w	r7,32
8000d6fe:	c1 54       	brge	8000d728 <__avr32_f64_div_res_subnormal+0x36>
8000d700:	ee 06 11 20 	rsub	r6,r7,32
8000d704:	e4 07 0a 42 	lsr	r2,r2,r7
8000d708:	e6 06 09 4c 	lsl	r12,r3,r6
8000d70c:	18 42       	or	r2,r12
8000d70e:	e6 07 0a 43 	lsr	r3,r3,r7
8000d712:	f4 06 09 41 	lsl	r1,r10,r6
8000d716:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d71a:	f6 06 09 4c 	lsl	r12,r11,r6
8000d71e:	18 4a       	or	r10,r12
8000d720:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d724:	30 00       	mov	r0,0
8000d726:	c1 58       	rjmp	8000d750 <__avr32_f64_div_res_subnormal+0x5e>
8000d728:	ee 06 11 20 	rsub	r6,r7,32
8000d72c:	f9 b0 00 00 	moveq	r0,0
8000d730:	f9 bc 00 00 	moveq	r12,0
8000d734:	c0 50       	breq	8000d73e <__avr32_f64_div_res_subnormal+0x4c>
8000d736:	f4 06 09 40 	lsl	r0,r10,r6
8000d73a:	f6 06 09 4c 	lsl	r12,r11,r6
8000d73e:	e6 07 0a 42 	lsr	r2,r3,r7
8000d742:	30 03       	mov	r3,0
8000d744:	f4 07 0a 41 	lsr	r1,r10,r7
8000d748:	18 41       	or	r1,r12
8000d74a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d74e:	30 0b       	mov	r11,0
8000d750:	e0 12 ff 00 	andl	r2,0xff00
8000d754:	e8 12 00 80 	orl	r2,0x80
8000d758:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d75c:	e4 09 07 46 	macu.d	r6,r2,r9
8000d760:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d764:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d768:	0c 05       	add	r5,r6
8000d76a:	f0 07 00 48 	adc	r8,r8,r7
8000d76e:	5c 09       	acr	r9
8000d770:	30 07       	mov	r7,0
8000d772:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d776:	00 34       	cp.w	r4,r0
8000d778:	e2 05 13 00 	cpc	r5,r1
8000d77c:	c4 6b       	rjmp	8000d608 <__avr32_f64_div_round_subnormal>
8000d77e:	1c 9b       	mov	r11,lr
8000d780:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d784:	30 0a       	mov	r10,0
8000d786:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d78a:	3f fb       	mov	r11,-1
8000d78c:	30 0a       	mov	r10,0
8000d78e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d792:	f5 eb 10 04 	or	r4,r10,r11
8000d796:	c0 90       	breq	8000d7a8 <__avr32_f64_div_op1_zero>
8000d798:	1c 9b       	mov	r11,lr
8000d79a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d79e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d7a2:	30 0a       	mov	r10,0
8000d7a4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d7a8 <__avr32_f64_div_op1_zero>:
8000d7a8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d7ac:	ce f0       	breq	8000d78a <__avr32_f64_div_res_subnormal+0x98>
8000d7ae:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d7b2:	e0 44 07 ff 	cp.w	r4,2047
8000d7b6:	ce 41       	brne	8000d77e <__avr32_f64_div_res_subnormal+0x8c>
8000d7b8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d7bc:	ce 10       	breq	8000d77e <__avr32_f64_div_res_subnormal+0x8c>
8000d7be:	ce 6b       	rjmp	8000d78a <__avr32_f64_div_res_subnormal+0x98>

8000d7c0 <__avr32_udiv64>:
8000d7c0:	d4 31       	pushm	r0-r7,lr
8000d7c2:	1a 97       	mov	r7,sp
8000d7c4:	20 3d       	sub	sp,12
8000d7c6:	10 9c       	mov	r12,r8
8000d7c8:	12 9e       	mov	lr,r9
8000d7ca:	14 93       	mov	r3,r10
8000d7cc:	58 09       	cp.w	r9,0
8000d7ce:	e0 81 00 bd 	brne	8000d948 <__avr32_udiv64+0x188>
8000d7d2:	16 38       	cp.w	r8,r11
8000d7d4:	e0 88 00 40 	brls	8000d854 <__avr32_udiv64+0x94>
8000d7d8:	f0 08 12 00 	clz	r8,r8
8000d7dc:	c0 d0       	breq	8000d7f6 <__avr32_udiv64+0x36>
8000d7de:	f6 08 09 4b 	lsl	r11,r11,r8
8000d7e2:	f0 09 11 20 	rsub	r9,r8,32
8000d7e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000d7ea:	f4 09 0a 49 	lsr	r9,r10,r9
8000d7ee:	f4 08 09 43 	lsl	r3,r10,r8
8000d7f2:	f3 eb 10 0b 	or	r11,r9,r11
8000d7f6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d7fa:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d7fe:	f6 0e 0d 00 	divu	r0,r11,lr
8000d802:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d806:	00 99       	mov	r9,r0
8000d808:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d80c:	e0 0a 02 48 	mul	r8,r0,r10
8000d810:	10 3b       	cp.w	r11,r8
8000d812:	c0 a2       	brcc	8000d826 <__avr32_udiv64+0x66>
8000d814:	20 19       	sub	r9,1
8000d816:	18 0b       	add	r11,r12
8000d818:	18 3b       	cp.w	r11,r12
8000d81a:	c0 63       	brcs	8000d826 <__avr32_udiv64+0x66>
8000d81c:	10 3b       	cp.w	r11,r8
8000d81e:	f7 b9 03 01 	sublo	r9,1
8000d822:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d826:	f6 08 01 01 	sub	r1,r11,r8
8000d82a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d82e:	e2 0e 0d 00 	divu	r0,r1,lr
8000d832:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d836:	00 98       	mov	r8,r0
8000d838:	e0 0a 02 4a 	mul	r10,r0,r10
8000d83c:	14 33       	cp.w	r3,r10
8000d83e:	c0 82       	brcc	8000d84e <__avr32_udiv64+0x8e>
8000d840:	20 18       	sub	r8,1
8000d842:	18 03       	add	r3,r12
8000d844:	18 33       	cp.w	r3,r12
8000d846:	c0 43       	brcs	8000d84e <__avr32_udiv64+0x8e>
8000d848:	14 33       	cp.w	r3,r10
8000d84a:	f7 b8 03 01 	sublo	r8,1
8000d84e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d852:	cd f8       	rjmp	8000da10 <__avr32_udiv64+0x250>
8000d854:	58 08       	cp.w	r8,0
8000d856:	c0 51       	brne	8000d860 <__avr32_udiv64+0xa0>
8000d858:	30 19       	mov	r9,1
8000d85a:	f2 08 0d 08 	divu	r8,r9,r8
8000d85e:	10 9c       	mov	r12,r8
8000d860:	f8 06 12 00 	clz	r6,r12
8000d864:	c0 41       	brne	8000d86c <__avr32_udiv64+0xac>
8000d866:	18 1b       	sub	r11,r12
8000d868:	30 19       	mov	r9,1
8000d86a:	c4 08       	rjmp	8000d8ea <__avr32_udiv64+0x12a>
8000d86c:	ec 01 11 20 	rsub	r1,r6,32
8000d870:	f4 01 0a 49 	lsr	r9,r10,r1
8000d874:	f8 06 09 4c 	lsl	r12,r12,r6
8000d878:	f6 06 09 48 	lsl	r8,r11,r6
8000d87c:	f6 01 0a 41 	lsr	r1,r11,r1
8000d880:	f3 e8 10 08 	or	r8,r9,r8
8000d884:	f8 03 16 10 	lsr	r3,r12,0x10
8000d888:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d88c:	e2 03 0d 00 	divu	r0,r1,r3
8000d890:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d894:	00 9e       	mov	lr,r0
8000d896:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d89a:	e0 05 02 49 	mul	r9,r0,r5
8000d89e:	12 3b       	cp.w	r11,r9
8000d8a0:	c0 a2       	brcc	8000d8b4 <__avr32_udiv64+0xf4>
8000d8a2:	20 1e       	sub	lr,1
8000d8a4:	18 0b       	add	r11,r12
8000d8a6:	18 3b       	cp.w	r11,r12
8000d8a8:	c0 63       	brcs	8000d8b4 <__avr32_udiv64+0xf4>
8000d8aa:	12 3b       	cp.w	r11,r9
8000d8ac:	f7 be 03 01 	sublo	lr,1
8000d8b0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d8b4:	12 1b       	sub	r11,r9
8000d8b6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d8ba:	f6 03 0d 02 	divu	r2,r11,r3
8000d8be:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d8c2:	04 99       	mov	r9,r2
8000d8c4:	e4 05 02 4b 	mul	r11,r2,r5
8000d8c8:	16 38       	cp.w	r8,r11
8000d8ca:	c0 a2       	brcc	8000d8de <__avr32_udiv64+0x11e>
8000d8cc:	20 19       	sub	r9,1
8000d8ce:	18 08       	add	r8,r12
8000d8d0:	18 38       	cp.w	r8,r12
8000d8d2:	c0 63       	brcs	8000d8de <__avr32_udiv64+0x11e>
8000d8d4:	16 38       	cp.w	r8,r11
8000d8d6:	f7 b9 03 01 	sublo	r9,1
8000d8da:	f1 dc e3 08 	addcs	r8,r8,r12
8000d8de:	f4 06 09 43 	lsl	r3,r10,r6
8000d8e2:	f0 0b 01 0b 	sub	r11,r8,r11
8000d8e6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d8ea:	f8 06 16 10 	lsr	r6,r12,0x10
8000d8ee:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d8f2:	f6 06 0d 00 	divu	r0,r11,r6
8000d8f6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d8fa:	00 9a       	mov	r10,r0
8000d8fc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d900:	e0 0e 02 48 	mul	r8,r0,lr
8000d904:	10 3b       	cp.w	r11,r8
8000d906:	c0 a2       	brcc	8000d91a <__avr32_udiv64+0x15a>
8000d908:	20 1a       	sub	r10,1
8000d90a:	18 0b       	add	r11,r12
8000d90c:	18 3b       	cp.w	r11,r12
8000d90e:	c0 63       	brcs	8000d91a <__avr32_udiv64+0x15a>
8000d910:	10 3b       	cp.w	r11,r8
8000d912:	f7 ba 03 01 	sublo	r10,1
8000d916:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d91a:	f6 08 01 01 	sub	r1,r11,r8
8000d91e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d922:	e2 06 0d 00 	divu	r0,r1,r6
8000d926:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d92a:	00 98       	mov	r8,r0
8000d92c:	e0 0e 02 4b 	mul	r11,r0,lr
8000d930:	16 33       	cp.w	r3,r11
8000d932:	c0 82       	brcc	8000d942 <__avr32_udiv64+0x182>
8000d934:	20 18       	sub	r8,1
8000d936:	18 03       	add	r3,r12
8000d938:	18 33       	cp.w	r3,r12
8000d93a:	c0 43       	brcs	8000d942 <__avr32_udiv64+0x182>
8000d93c:	16 33       	cp.w	r3,r11
8000d93e:	f7 b8 03 01 	sublo	r8,1
8000d942:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d946:	c6 98       	rjmp	8000da18 <__avr32_udiv64+0x258>
8000d948:	16 39       	cp.w	r9,r11
8000d94a:	e0 8b 00 65 	brhi	8000da14 <__avr32_udiv64+0x254>
8000d94e:	f2 09 12 00 	clz	r9,r9
8000d952:	c0 b1       	brne	8000d968 <__avr32_udiv64+0x1a8>
8000d954:	10 3a       	cp.w	r10,r8
8000d956:	5f 2a       	srhs	r10
8000d958:	1c 3b       	cp.w	r11,lr
8000d95a:	5f b8       	srhi	r8
8000d95c:	10 4a       	or	r10,r8
8000d95e:	f2 0a 18 00 	cp.b	r10,r9
8000d962:	c5 90       	breq	8000da14 <__avr32_udiv64+0x254>
8000d964:	30 18       	mov	r8,1
8000d966:	c5 98       	rjmp	8000da18 <__avr32_udiv64+0x258>
8000d968:	f0 09 09 46 	lsl	r6,r8,r9
8000d96c:	f2 03 11 20 	rsub	r3,r9,32
8000d970:	fc 09 09 4e 	lsl	lr,lr,r9
8000d974:	f0 03 0a 48 	lsr	r8,r8,r3
8000d978:	f6 09 09 4c 	lsl	r12,r11,r9
8000d97c:	f4 03 0a 42 	lsr	r2,r10,r3
8000d980:	ef 46 ff f4 	st.w	r7[-12],r6
8000d984:	f6 03 0a 43 	lsr	r3,r11,r3
8000d988:	18 42       	or	r2,r12
8000d98a:	f1 ee 10 0c 	or	r12,r8,lr
8000d98e:	f8 01 16 10 	lsr	r1,r12,0x10
8000d992:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d996:	e6 01 0d 04 	divu	r4,r3,r1
8000d99a:	e4 03 16 10 	lsr	r3,r2,0x10
8000d99e:	08 9e       	mov	lr,r4
8000d9a0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d9a4:	e8 06 02 48 	mul	r8,r4,r6
8000d9a8:	10 33       	cp.w	r3,r8
8000d9aa:	c0 a2       	brcc	8000d9be <__avr32_udiv64+0x1fe>
8000d9ac:	20 1e       	sub	lr,1
8000d9ae:	18 03       	add	r3,r12
8000d9b0:	18 33       	cp.w	r3,r12
8000d9b2:	c0 63       	brcs	8000d9be <__avr32_udiv64+0x1fe>
8000d9b4:	10 33       	cp.w	r3,r8
8000d9b6:	f7 be 03 01 	sublo	lr,1
8000d9ba:	e7 dc e3 03 	addcs	r3,r3,r12
8000d9be:	10 13       	sub	r3,r8
8000d9c0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d9c4:	e6 01 0d 00 	divu	r0,r3,r1
8000d9c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d9cc:	00 98       	mov	r8,r0
8000d9ce:	e0 06 02 46 	mul	r6,r0,r6
8000d9d2:	0c 3b       	cp.w	r11,r6
8000d9d4:	c0 a2       	brcc	8000d9e8 <__avr32_udiv64+0x228>
8000d9d6:	20 18       	sub	r8,1
8000d9d8:	18 0b       	add	r11,r12
8000d9da:	18 3b       	cp.w	r11,r12
8000d9dc:	c0 63       	brcs	8000d9e8 <__avr32_udiv64+0x228>
8000d9de:	0c 3b       	cp.w	r11,r6
8000d9e0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d9e4:	f7 b8 03 01 	sublo	r8,1
8000d9e8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d9ec:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d9f0:	0c 1b       	sub	r11,r6
8000d9f2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d9f6:	06 95       	mov	r5,r3
8000d9f8:	16 35       	cp.w	r5,r11
8000d9fa:	e0 8b 00 0a 	brhi	8000da0e <__avr32_udiv64+0x24e>
8000d9fe:	5f 0b       	sreq	r11
8000da00:	f4 09 09 49 	lsl	r9,r10,r9
8000da04:	12 32       	cp.w	r2,r9
8000da06:	5f b9       	srhi	r9
8000da08:	f7 e9 00 09 	and	r9,r11,r9
8000da0c:	c0 60       	breq	8000da18 <__avr32_udiv64+0x258>
8000da0e:	20 18       	sub	r8,1
8000da10:	30 09       	mov	r9,0
8000da12:	c0 38       	rjmp	8000da18 <__avr32_udiv64+0x258>
8000da14:	30 09       	mov	r9,0
8000da16:	12 98       	mov	r8,r9
8000da18:	10 9a       	mov	r10,r8
8000da1a:	12 93       	mov	r3,r9
8000da1c:	10 92       	mov	r2,r8
8000da1e:	12 9b       	mov	r11,r9
8000da20:	2f dd       	sub	sp,-12
8000da22:	d8 32       	popm	r0-r7,pc

8000da24 <__avr32_umod64>:
8000da24:	d4 31       	pushm	r0-r7,lr
8000da26:	1a 97       	mov	r7,sp
8000da28:	20 3d       	sub	sp,12
8000da2a:	10 9c       	mov	r12,r8
8000da2c:	12 95       	mov	r5,r9
8000da2e:	14 9e       	mov	lr,r10
8000da30:	16 91       	mov	r1,r11
8000da32:	16 96       	mov	r6,r11
8000da34:	58 09       	cp.w	r9,0
8000da36:	e0 81 00 81 	brne	8000db38 <__avr32_umod64+0x114>
8000da3a:	16 38       	cp.w	r8,r11
8000da3c:	e0 88 00 12 	brls	8000da60 <__avr32_umod64+0x3c>
8000da40:	f0 08 12 00 	clz	r8,r8
8000da44:	c4 e0       	breq	8000dae0 <__avr32_umod64+0xbc>
8000da46:	f6 08 09 46 	lsl	r6,r11,r8
8000da4a:	f8 08 09 4c 	lsl	r12,r12,r8
8000da4e:	f0 0b 11 20 	rsub	r11,r8,32
8000da52:	f4 08 09 4e 	lsl	lr,r10,r8
8000da56:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000da5a:	f7 e6 10 06 	or	r6,r11,r6
8000da5e:	c4 18       	rjmp	8000dae0 <__avr32_umod64+0xbc>
8000da60:	58 08       	cp.w	r8,0
8000da62:	c0 51       	brne	8000da6c <__avr32_umod64+0x48>
8000da64:	30 19       	mov	r9,1
8000da66:	f2 08 0d 08 	divu	r8,r9,r8
8000da6a:	10 9c       	mov	r12,r8
8000da6c:	f8 08 12 00 	clz	r8,r12
8000da70:	c0 31       	brne	8000da76 <__avr32_umod64+0x52>
8000da72:	18 16       	sub	r6,r12
8000da74:	c3 68       	rjmp	8000dae0 <__avr32_umod64+0xbc>
8000da76:	f0 03 11 20 	rsub	r3,r8,32
8000da7a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000da7e:	f8 08 09 4c 	lsl	r12,r12,r8
8000da82:	ec 08 09 49 	lsl	r9,r6,r8
8000da86:	ec 03 0a 43 	lsr	r3,r6,r3
8000da8a:	f7 e9 10 09 	or	r9,r11,r9
8000da8e:	f8 05 16 10 	lsr	r5,r12,0x10
8000da92:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000da96:	e6 05 0d 02 	divu	r2,r3,r5
8000da9a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000da9e:	ec 02 02 4b 	mul	r11,r6,r2
8000daa2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000daa6:	16 3e       	cp.w	lr,r11
8000daa8:	c0 72       	brcc	8000dab6 <__avr32_umod64+0x92>
8000daaa:	18 0e       	add	lr,r12
8000daac:	18 3e       	cp.w	lr,r12
8000daae:	c0 43       	brcs	8000dab6 <__avr32_umod64+0x92>
8000dab0:	16 3e       	cp.w	lr,r11
8000dab2:	fd dc e3 0e 	addcs	lr,lr,r12
8000dab6:	fc 0b 01 03 	sub	r3,lr,r11
8000daba:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000dabe:	e6 05 0d 02 	divu	r2,r3,r5
8000dac2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000dac6:	a5 36       	mul	r6,r2
8000dac8:	0c 39       	cp.w	r9,r6
8000daca:	c0 72       	brcc	8000dad8 <__avr32_umod64+0xb4>
8000dacc:	18 09       	add	r9,r12
8000dace:	18 39       	cp.w	r9,r12
8000dad0:	c0 43       	brcs	8000dad8 <__avr32_umod64+0xb4>
8000dad2:	0c 39       	cp.w	r9,r6
8000dad4:	f3 dc e3 09 	addcs	r9,r9,r12
8000dad8:	f2 06 01 06 	sub	r6,r9,r6
8000dadc:	f4 08 09 4e 	lsl	lr,r10,r8
8000dae0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000dae4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000dae8:	ec 0a 0d 02 	divu	r2,r6,r10
8000daec:	fc 09 16 10 	lsr	r9,lr,0x10
8000daf0:	ea 02 02 4b 	mul	r11,r5,r2
8000daf4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000daf8:	16 39       	cp.w	r9,r11
8000dafa:	c0 72       	brcc	8000db08 <__avr32_umod64+0xe4>
8000dafc:	18 09       	add	r9,r12
8000dafe:	18 39       	cp.w	r9,r12
8000db00:	c0 43       	brcs	8000db08 <__avr32_umod64+0xe4>
8000db02:	16 39       	cp.w	r9,r11
8000db04:	f3 dc e3 09 	addcs	r9,r9,r12
8000db08:	f2 0b 01 0b 	sub	r11,r9,r11
8000db0c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000db10:	f6 0a 0d 0a 	divu	r10,r11,r10
8000db14:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000db18:	ea 0a 02 4a 	mul	r10,r5,r10
8000db1c:	14 3e       	cp.w	lr,r10
8000db1e:	c0 72       	brcc	8000db2c <__avr32_umod64+0x108>
8000db20:	18 0e       	add	lr,r12
8000db22:	18 3e       	cp.w	lr,r12
8000db24:	c0 43       	brcs	8000db2c <__avr32_umod64+0x108>
8000db26:	14 3e       	cp.w	lr,r10
8000db28:	fd dc e3 0e 	addcs	lr,lr,r12
8000db2c:	fc 0a 01 0a 	sub	r10,lr,r10
8000db30:	30 0b       	mov	r11,0
8000db32:	f4 08 0a 4a 	lsr	r10,r10,r8
8000db36:	c7 b8       	rjmp	8000dc2c <__avr32_umod64+0x208>
8000db38:	16 39       	cp.w	r9,r11
8000db3a:	e0 8b 00 79 	brhi	8000dc2c <__avr32_umod64+0x208>
8000db3e:	f2 09 12 00 	clz	r9,r9
8000db42:	c1 21       	brne	8000db66 <__avr32_umod64+0x142>
8000db44:	10 3a       	cp.w	r10,r8
8000db46:	5f 2b       	srhs	r11
8000db48:	0a 31       	cp.w	r1,r5
8000db4a:	5f ba       	srhi	r10
8000db4c:	f7 ea 10 0a 	or	r10,r11,r10
8000db50:	f2 0a 18 00 	cp.b	r10,r9
8000db54:	c0 60       	breq	8000db60 <__avr32_umod64+0x13c>
8000db56:	fc 08 01 0c 	sub	r12,lr,r8
8000db5a:	e2 05 01 46 	sbc	r6,r1,r5
8000db5e:	18 9e       	mov	lr,r12
8000db60:	0c 9b       	mov	r11,r6
8000db62:	1c 9a       	mov	r10,lr
8000db64:	c6 48       	rjmp	8000dc2c <__avr32_umod64+0x208>
8000db66:	ea 09 09 4c 	lsl	r12,r5,r9
8000db6a:	f2 06 11 20 	rsub	r6,r9,32
8000db6e:	f6 09 09 4b 	lsl	r11,r11,r9
8000db72:	f0 09 09 42 	lsl	r2,r8,r9
8000db76:	ef 46 ff f4 	st.w	r7[-12],r6
8000db7a:	f0 06 0a 48 	lsr	r8,r8,r6
8000db7e:	18 48       	or	r8,r12
8000db80:	e2 06 0a 4c 	lsr	r12,r1,r6
8000db84:	f4 09 09 43 	lsl	r3,r10,r9
8000db88:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000db8c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000db90:	16 4a       	or	r10,r11
8000db92:	f0 0b 16 10 	lsr	r11,r8,0x10
8000db96:	f8 0b 0d 04 	divu	r4,r12,r11
8000db9a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000db9e:	08 91       	mov	r1,r4
8000dba0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000dba4:	e8 0e 02 46 	mul	r6,r4,lr
8000dba8:	0c 3c       	cp.w	r12,r6
8000dbaa:	c0 a2       	brcc	8000dbbe <__avr32_umod64+0x19a>
8000dbac:	20 11       	sub	r1,1
8000dbae:	10 0c       	add	r12,r8
8000dbb0:	10 3c       	cp.w	r12,r8
8000dbb2:	c0 63       	brcs	8000dbbe <__avr32_umod64+0x19a>
8000dbb4:	0c 3c       	cp.w	r12,r6
8000dbb6:	f7 b1 03 01 	sublo	r1,1
8000dbba:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000dbbe:	0c 1c       	sub	r12,r6
8000dbc0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000dbc4:	f8 0b 0d 04 	divu	r4,r12,r11
8000dbc8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dbcc:	08 96       	mov	r6,r4
8000dbce:	e8 0e 02 4e 	mul	lr,r4,lr
8000dbd2:	1c 3b       	cp.w	r11,lr
8000dbd4:	c0 a2       	brcc	8000dbe8 <__avr32_umod64+0x1c4>
8000dbd6:	20 16       	sub	r6,1
8000dbd8:	10 0b       	add	r11,r8
8000dbda:	10 3b       	cp.w	r11,r8
8000dbdc:	c0 63       	brcs	8000dbe8 <__avr32_umod64+0x1c4>
8000dbde:	1c 3b       	cp.w	r11,lr
8000dbe0:	f7 b6 03 01 	sublo	r6,1
8000dbe4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dbe8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dbec:	1c 1b       	sub	r11,lr
8000dbee:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dbf2:	00 9e       	mov	lr,r0
8000dbf4:	02 9c       	mov	r12,r1
8000dbf6:	16 3c       	cp.w	r12,r11
8000dbf8:	e0 8b 00 08 	brhi	8000dc08 <__avr32_umod64+0x1e4>
8000dbfc:	5f 06       	sreq	r6
8000dbfe:	06 30       	cp.w	r0,r3
8000dc00:	5f ba       	srhi	r10
8000dc02:	ed ea 00 0a 	and	r10,r6,r10
8000dc06:	c0 60       	breq	8000dc12 <__avr32_umod64+0x1ee>
8000dc08:	fc 02 01 04 	sub	r4,lr,r2
8000dc0c:	f8 08 01 4c 	sbc	r12,r12,r8
8000dc10:	08 9e       	mov	lr,r4
8000dc12:	e6 0e 01 0a 	sub	r10,r3,lr
8000dc16:	f6 0c 01 4c 	sbc	r12,r11,r12
8000dc1a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000dc1e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000dc22:	f4 09 0a 4a 	lsr	r10,r10,r9
8000dc26:	f8 01 09 4c 	lsl	r12,r12,r1
8000dc2a:	18 4a       	or	r10,r12
8000dc2c:	2f dd       	sub	sp,-12
8000dc2e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000de00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000de00:	c0 08       	rjmp	8000de00 <_evba>
	...

8000de04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000de04:	c0 08       	rjmp	8000de04 <_handle_TLB_Multiple_Hit>
	...

8000de08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000de08:	c0 08       	rjmp	8000de08 <_handle_Bus_Error_Data_Fetch>
	...

8000de0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000de0c:	c0 08       	rjmp	8000de0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000de10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000de10:	c0 08       	rjmp	8000de10 <_handle_NMI>
	...

8000de14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000de14:	c0 08       	rjmp	8000de14 <_handle_Instruction_Address>
	...

8000de18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000de18:	c0 08       	rjmp	8000de18 <_handle_ITLB_Protection>
	...

8000de1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000de1c:	c0 08       	rjmp	8000de1c <_handle_Breakpoint>
	...

8000de20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000de20:	c0 08       	rjmp	8000de20 <_handle_Illegal_Opcode>
	...

8000de24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000de24:	c0 08       	rjmp	8000de24 <_handle_Unimplemented_Instruction>
	...

8000de28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000de28:	c0 08       	rjmp	8000de28 <_handle_Privilege_Violation>
	...

8000de2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000de2c:	c0 08       	rjmp	8000de2c <_handle_Floating_Point>
	...

8000de30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000de30:	c0 08       	rjmp	8000de30 <_handle_Coprocessor_Absent>
	...

8000de34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000de34:	c0 08       	rjmp	8000de34 <_handle_Data_Address_Read>
	...

8000de38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000de38:	c0 08       	rjmp	8000de38 <_handle_Data_Address_Write>
	...

8000de3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000de3c:	c0 08       	rjmp	8000de3c <_handle_DTLB_Protection_Read>
	...

8000de40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000de40:	c0 08       	rjmp	8000de40 <_handle_DTLB_Protection_Write>
	...

8000de44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000de44:	c0 08       	rjmp	8000de44 <_handle_DTLB_Modified>
	...

8000de50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000de50:	c0 08       	rjmp	8000de50 <_handle_ITLB_Miss>
	...

8000de60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000de60:	c0 08       	rjmp	8000de60 <_handle_DTLB_Miss_Read>
	...

8000de70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000de70:	c0 08       	rjmp	8000de70 <_handle_DTLB_Miss_Write>
	...

8000df00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000df00:	fe cf 71 ac 	sub	pc,pc,29100

8000df04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000df04:	30 0c       	mov	r12,0
8000df06:	fe b0 c2 8d 	rcall	80006420 <_get_interrupt_handler>
8000df0a:	58 0c       	cp.w	r12,0
8000df0c:	f8 0f 17 10 	movne	pc,r12
8000df10:	d6 03       	rete

8000df12 <_int1>:
8000df12:	30 1c       	mov	r12,1
8000df14:	fe b0 c2 86 	rcall	80006420 <_get_interrupt_handler>
8000df18:	58 0c       	cp.w	r12,0
8000df1a:	f8 0f 17 10 	movne	pc,r12
8000df1e:	d6 03       	rete

8000df20 <_int2>:
8000df20:	30 2c       	mov	r12,2
8000df22:	fe b0 c2 7f 	rcall	80006420 <_get_interrupt_handler>
8000df26:	58 0c       	cp.w	r12,0
8000df28:	f8 0f 17 10 	movne	pc,r12
8000df2c:	d6 03       	rete

8000df2e <_int3>:
8000df2e:	30 3c       	mov	r12,3
8000df30:	fe b0 c2 78 	rcall	80006420 <_get_interrupt_handler>
8000df34:	58 0c       	cp.w	r12,0
8000df36:	f8 0f 17 10 	movne	pc,r12
8000df3a:	d6 03       	rete

8000df3c <ipr_val>:
8000df3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000df4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dffc:	d7 03 d7 03                                         ....
