
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a6f0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000115c  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000db5c  8000db5c  0000df5c  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000db60  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e598  0000ea3c  2**0
                  ALLOC
  8 .bss          000036e0  00000a40  8000e598  0000ea40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001218  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002732  00000000  00000000  0000fc88  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000289e3  00000000  00000000  000123ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000069b7  00000000  00000000  0003ad9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c20f  00000000  00000000  00041754  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003028  00000000  00000000  0004d964  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00006fc7  00000000  00000000  0005098c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d2ec  00000000  00000000  00057953  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000012f8  00000000  00000000  00064c40  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c8 e8 	sub	pc,pc,-14104

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 78       	ld.ub	r8,--r6

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 54       	eor	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3c e8       	mov	r8,-50
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 fc       	sub	r12,15
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 10       	sub	r0,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f0       	sub	r0,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ca 00       	breq	80001fc2 <_trampoline+0x1fc2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	66 10       	ld.w	r0,r3[0x4]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 44       	or	r4,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	eb cd 40 fc 	pushm	r2-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002094:	f0 1f 00 13 	mcall	800020e0 <app_cfg+0x50>
80002098:	49 38       	lddpc	r8,800020e4 <app_cfg+0x54>
8000209a:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209c:	49 36       	lddpc	r6,800020e8 <app_cfg+0x58>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000209e:	49 47       	lddpc	r7,800020ec <app_cfg+0x5c>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020a0:	30 c2       	mov	r2,12
			connect_flag=1;	
800020a2:	30 13       	mov	r3,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a4:	10 95       	mov	r5,r8
800020a6:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020aa:	6c 08       	ld.w	r8,r6[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c0 91       	brne	800020c4 <app_cfg+0x34>
800020b4:	0f 88       	ld.ub	r8,r7[0x0]
800020b6:	58 08       	cp.w	r8,0
800020b8:	c0 61       	brne	800020c4 <app_cfg+0x34>
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020ba:	04 9c       	mov	r12,r2
800020bc:	f0 1f 00 0d 	mcall	800020f0 <app_cfg+0x60>
			connect_flag=1;	
800020c0:	ae 83       	st.b	r7[0x0],r3
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c2:	c0 a8       	rjmp	800020d6 <app_cfg+0x46>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
800020c4:	0f 88       	ld.ub	r8,r7[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 40       	breq	800020d0 <app_cfg+0x40>
		{
				
				rfid_sendID_message();
800020ca:	f0 1f 00 0b 	mcall	800020f4 <app_cfg+0x64>
800020ce:	c0 48       	rjmp	800020d6 <app_cfg+0x46>
				//}
				
		}
		else
		{
			nop();
800020d0:	d7 03       	nop
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020d6:	08 9b       	mov	r11,r4
800020d8:	0a 9c       	mov	r12,r5
800020da:	f0 1f 00 08 	mcall	800020f8 <app_cfg+0x68>
	}
800020de:	ce 6b       	rjmp	800020aa <app_cfg+0x1a>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	63 48       	ld.w	r8,r1[0x50]
800020e4:	00 00       	add	r0,r0
800020e6:	0a 48       	or	r8,r5
800020e8:	00 00       	add	r0,r0
800020ea:	0d 78       	ld.ub	r8,--r6
800020ec:	00 00       	add	r0,r0
800020ee:	0a 50       	eor	r0,r5
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	3e 74       	mov	r4,-25
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	4e 90       	lddpc	r0,80002298 <ButtonConfig_brdcst_func+0x78>
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	64 b0       	ld.w	r0,r2[0x2c]

800020fc <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020fc:	d4 01       	pushm	lr
  log("R");
800020fe:	48 3c       	lddpc	r12,80002108 <app_payload_tx_proc+0xc>
80002100:	f0 1f 00 03 	mcall	8000210c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002104:	d8 02       	popm	pc
80002106:	00 00       	add	r0,r0
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	ca 08       	rjmp	8000224a <ButtonConfig_brdcst_func+0x2a>
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	69 d4       	ld.w	r4,r4[0x74]

80002110 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002110:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002112:	48 99       	lddpc	r9,80002134 <app_payload_rx_proc+0x24>
80002114:	13 88       	ld.ub	r8,r9[0x0]
80002116:	2f f8       	sub	r8,-1
80002118:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000211a:	30 39       	mov	r9,3
8000211c:	f2 08 18 00 	cp.b	r8,r9
80002120:	c0 71       	brne	8000212e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002122:	30 09       	mov	r9,0
80002124:	48 48       	lddpc	r8,80002134 <app_payload_rx_proc+0x24>
80002126:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002128:	48 4c       	lddpc	r12,80002138 <app_payload_rx_proc+0x28>
8000212a:	f0 1f 00 05 	mcall	8000213c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000212e:	48 58       	lddpc	r8,80002140 <app_payload_rx_proc+0x30>
80002130:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002132:	d8 02       	popm	pc
80002134:	00 00       	add	r0,r0
80002136:	0a 52       	eor	r2,r5
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	ca 0c       	rcall	8000227a <ButtonConfig_brdcst_func+0x5a>
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	69 d4       	ld.w	r4,r4[0x74]
80002140:	00 00       	add	r0,r0
80002142:	0a 4e       	or	lr,r5

80002144 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_brdcst_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_brdcst_func+0x10>
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ca 18       	rjmp	80002294 <ButtonConfig_brdcst_func+0x74>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	69 d4       	ld.w	r4,r4[0x74]

80002158 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <FD_reply_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <FD_reply_func+0x10>
	
	
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	ca 38       	rjmp	800022ac <ButtonConfig_brdcst_func+0x8c>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	69 d4       	ld.w	r4,r4[0x74]

8000216c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000216c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000216e:	48 3c       	lddpc	r12,80002178 <FD_request_func+0xc>
80002170:	f0 1f 00 03 	mcall	8000217c <FD_request_func+0x10>
	
	
}
80002174:	d8 02       	popm	pc
80002176:	00 00       	add	r0,r0
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	ca 54       	brge	800020c4 <app_cfg+0x34>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	69 d4       	ld.w	r4,r4[0x74]

80002180 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002180:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002182:	48 3c       	lddpc	r12,8000218c <EnOB_brdcst_func+0xc>
80002184:	f0 1f 00 03 	mcall	80002190 <EnOB_brdcst_func+0x10>
}
80002188:	d8 02       	popm	pc
8000218a:	00 00       	add	r0,r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ca 70       	breq	800020dc <app_cfg+0x4c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	69 d4       	ld.w	r4,r4[0x74]

80002194 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002194:	eb cd 40 80 	pushm	r7,lr
80002198:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	30 08       	mov	r8,0
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c1 91       	brne	800021d4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021a4:	19 b8       	ld.ub	r8,r12[0x3]
800021a6:	30 19       	mov	r9,1
800021a8:	f2 08 18 00 	cp.b	r8,r9
800021ac:	c0 61       	brne	800021b8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021ae:	49 0c       	lddpc	r12,800021ec <EnOB_reply_func+0x58>
800021b0:	f0 1f 00 10 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021b8:	58 08       	cp.w	r8,0
800021ba:	c0 61       	brne	800021c6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021bc:	48 ec       	lddpc	r12,800021f4 <EnOB_reply_func+0x60>
800021be:	f0 1f 00 0d 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021c2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021c6:	1a d8       	st.w	--sp,r8
800021c8:	48 cc       	lddpc	r12,800021f8 <EnOB_reply_func+0x64>
800021ca:	f0 1f 00 0a 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021ce:	2f fd       	sub	sp,-4
800021d0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021d4:	48 ac       	lddpc	r12,800021fc <EnOB_reply_func+0x68>
800021d6:	f0 1f 00 07 	mcall	800021f0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021da:	0f a8       	ld.ub	r8,r7[0x2]
800021dc:	1a d8       	st.w	--sp,r8
800021de:	48 9c       	lddpc	r12,80002200 <EnOB_reply_func+0x6c>
800021e0:	f0 1f 00 04 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021e4:	2f fd       	sub	sp,-4
800021e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ea:	00 00       	add	r0,r0
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	ca 88       	rjmp	8000233e <Phyuserinput_brdcst_func+0x42>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	69 d4       	ld.w	r4,r4[0x74]
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	ca a0       	breq	8000214a <FD_brdcst_func+0x6>
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	ca b4       	brge	80002150 <FD_brdcst_func+0xc>
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	ca cc       	rcall	80002356 <ButtonConfig_reply_func+0x16>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	ca e8       	rjmp	8000235e <ButtonConfig_reply_func+0x1e>

80002204 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002204:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
80002206:	19 a9       	ld.ub	r9,r12[0x2]
80002208:	31 18       	mov	r8,17
8000220a:	f0 09 18 00 	cp.b	r9,r8
8000220e:	c0 41       	brne	80002216 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002210:	48 2c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x14>
80002212:	f0 1f 00 03 	mcall	8000221c <SingleDetection_brdcst_func+0x18>
80002216:	d8 02       	popm	pc
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	cb 00       	breq	8000217a <FD_request_func+0xe>
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	69 d4       	ld.w	r4,r4[0x74]

80002220 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002220:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002222:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002226:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002228:	4a bc       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xb4>
8000222a:	f0 1f 00 2c 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222e:	0f 88       	ld.ub	r8,r7[0x0]
80002230:	1a d8       	st.w	--sp,r8
80002232:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xbc>
80002234:	f0 1f 00 29 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002238:	1a d5       	st.w	--sp,r5
8000223a:	4a ac       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc0>
8000223c:	f0 1f 00 27 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002240:	0f a8       	ld.ub	r8,r7[0x2]
80002242:	1a d8       	st.w	--sp,r8
80002244:	4a 8c       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xc4>
80002246:	f0 1f 00 25 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000224a:	2f dd       	sub	sp,-12
8000224c:	58 05       	cp.w	r5,0
8000224e:	c4 10       	breq	800022d0 <ButtonConfig_brdcst_func+0xb0>
80002250:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002252:	4a 64       	lddpc	r4,800022e8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002254:	4a 63       	lddpc	r3,800022ec <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002256:	4a 72       	lddpc	r2,800022f0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	4a 71       	lddpc	r1,800022f4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000225a:	4a 80       	lddpc	r0,800022f8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225c:	0f b9       	ld.ub	r9,r7[0x3]
8000225e:	0f c8       	ld.ub	r8,r7[0x4]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	08 9c       	mov	r12,r4
8000226a:	f0 1f 00 1c 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226e:	0f d9       	ld.ub	r9,r7[0x5]
80002270:	0f e8       	ld.ub	r8,r7[0x6]
80002272:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002276:	1a d8       	st.w	--sp,r8
80002278:	1a d6       	st.w	--sp,r6
8000227a:	06 9c       	mov	r12,r3
8000227c:	f0 1f 00 17 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002280:	0f f9       	ld.ub	r9,r7[0x7]
80002282:	ef 38 00 08 	ld.ub	r8,r7[8]
80002286:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000228a:	1a d8       	st.w	--sp,r8
8000228c:	1a d6       	st.w	--sp,r6
8000228e:	04 9c       	mov	r12,r2
80002290:	f0 1f 00 12 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002294:	ef 39 00 09 	ld.ub	r9,r7[9]
80002298:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000229c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a0:	1a d8       	st.w	--sp,r8
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	02 9c       	mov	r12,r1
800022a6:	f0 1f 00 0d 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022aa:	2f 8d       	sub	sp,-32
800022ac:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b8:	1a d8       	st.w	--sp,r8
800022ba:	1a d6       	st.w	--sp,r6
800022bc:	00 9c       	mov	r12,r0
800022be:	f0 1f 00 07 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
800022c2:	2f f6       	sub	r6,-1
800022c4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c6:	2f ed       	sub	sp,-8
800022c8:	ec 05 18 00 	cp.b	r5,r6
800022cc:	fe 9b ff c8 	brhi	8000225c <ButtonConfig_brdcst_func+0x3c>
800022d0:	d8 32       	popm	r0-r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	cb 14       	brge	80002238 <ButtonConfig_brdcst_func+0x18>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	69 d4       	ld.w	r4,r4[0x74]
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cb 34       	brge	80002244 <ButtonConfig_brdcst_func+0x24>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	cb 48       	rjmp	8000244a <DataSession_brdcst_func+0xc6>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cb 60       	breq	80002252 <ButtonConfig_brdcst_func+0x32>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cb 80       	breq	8000225a <ButtonConfig_brdcst_func+0x3a>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	cb a8       	rjmp	80002462 <DataSession_brdcst_func+0xde>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	cb d0       	breq	8000226c <ButtonConfig_brdcst_func+0x4c>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	cb f4       	brge	80002274 <ButtonConfig_brdcst_func+0x54>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	cc 1c       	rcall	8000247c <DataSession_reply_func+0x18>

800022fc <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002308:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000230a:	48 ac       	lddpc	r12,80002330 <Phyuserinput_brdcst_func+0x34>
8000230c:	f0 1f 00 0a 	mcall	80002334 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002310:	36 08       	mov	r8,96
80002312:	f0 07 19 00 	cp.h	r7,r8
80002316:	c0 a1       	brne	8000232a <Phyuserinput_brdcst_func+0x2e>
80002318:	48 88       	lddpc	r8,80002338 <Phyuserinput_brdcst_func+0x3c>
8000231a:	11 89       	ld.ub	r9,r8[0x0]
8000231c:	30 18       	mov	r8,1
8000231e:	f0 09 18 00 	cp.b	r9,r8
80002322:	c0 41       	brne	8000232a <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
80002324:	48 6c       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <Phyuserinput_brdcst_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	cc 40       	breq	800022ba <ButtonConfig_brdcst_func+0x9a>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	69 d4       	ld.w	r4,r4[0x74]
80002338:	00 00       	add	r0,r0
8000233a:	0a 50       	eor	r0,r5
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	cc 60       	breq	800022ca <ButtonConfig_brdcst_func+0xaa>

80002340 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002340:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002344:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002348:	0f 89       	ld.ub	r9,r7[0x0]
8000234a:	30 08       	mov	r8,0
8000234c:	f0 09 18 00 	cp.b	r9,r8
80002350:	c0 c1       	brne	80002368 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002352:	48 9c       	lddpc	r12,80002374 <ButtonConfig_reply_func+0x34>
80002354:	f0 1f 00 09 	mcall	80002378 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 8c       	lddpc	r12,8000237c <ButtonConfig_reply_func+0x3c>
8000235e:	f0 1f 00 07 	mcall	80002378 <ButtonConfig_reply_func+0x38>
80002362:	2f fd       	sub	sp,-4
80002364:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002368:	48 6c       	lddpc	r12,80002380 <ButtonConfig_reply_func+0x40>
8000236a:	f0 1f 00 04 	mcall	80002378 <ButtonConfig_reply_func+0x38>
8000236e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002372:	00 00       	add	r0,r0
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	cc 70       	breq	80002304 <Phyuserinput_brdcst_func+0x8>
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	69 d4       	ld.w	r4,r4[0x74]
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	cb 34       	brge	800022e4 <ButtonConfig_brdcst_func+0xc4>
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	cc 88       	rjmp	80002512 <CallControl_brdcst_func+0x32>

80002384 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002384:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002386:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000238a:	0d 88       	ld.ub	r8,r6[0x0]
8000238c:	32 49       	mov	r9,36
8000238e:	f2 08 18 00 	cp.b	r8,r9
80002392:	c2 91       	brne	800023e4 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002394:	4a dc       	lddpc	r12,80002448 <DataSession_brdcst_func+0xc4>
80002396:	f0 1f 00 2e 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000239a:	0d a5       	ld.ub	r5,r6[0x2]
8000239c:	0d b8       	ld.ub	r8,r6[0x3]
8000239e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023a2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023a4:	0d 98       	ld.ub	r8,r6[0x1]
800023a6:	1a d8       	st.w	--sp,r8
800023a8:	4a ac       	lddpc	r12,80002450 <DataSession_brdcst_func+0xcc>
800023aa:	f0 1f 00 29 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023ae:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	4a 8c       	lddpc	r12,80002454 <DataSession_brdcst_func+0xd0>
800023b6:	f0 1f 00 26 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023ba:	2f ed       	sub	sp,-8
800023bc:	58 05       	cp.w	r5,0
800023be:	c4 40       	breq	80002446 <DataSession_brdcst_func+0xc2>
800023c0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023c2:	4a 64       	lddpc	r4,80002458 <DataSession_brdcst_func+0xd4>
800023c4:	ec 07 00 08 	add	r8,r6,r7
800023c8:	11 c8       	ld.ub	r8,r8[0x4]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	1a d7       	st.w	--sp,r7
800023ce:	08 9c       	mov	r12,r4
800023d0:	f0 1f 00 1f 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023d4:	2f f7       	sub	r7,-1
800023d6:	5c 57       	castu.b	r7
800023d8:	2f ed       	sub	sp,-8
800023da:	ee 05 19 00 	cp.h	r5,r7
800023de:	fe 9b ff f3 	brhi	800023c4 <DataSession_brdcst_func+0x40>
800023e2:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	49 ec       	lddpc	r12,8000245c <DataSession_brdcst_func+0xd8>
800023e8:	f0 1f 00 19 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		if (ptr->State)
800023ec:	2f fd       	sub	sp,-4
800023ee:	0d 89       	ld.ub	r9,r6[0x0]
800023f0:	30 08       	mov	r8,0
800023f2:	f0 09 18 00 	cp.b	r9,r8
800023f6:	c0 40       	breq	800023fe <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
800023f8:	49 ac       	lddpc	r12,80002460 <DataSession_brdcst_func+0xdc>
800023fa:	f0 1f 00 15 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023fe:	0d a5       	ld.ub	r5,r6[0x2]
80002400:	0d b8       	ld.ub	r8,r6[0x3]
80002402:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002406:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002408:	0d 98       	ld.ub	r8,r6[0x1]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	49 1c       	lddpc	r12,80002450 <DataSession_brdcst_func+0xcc>
8000240e:	f0 1f 00 10 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002412:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002416:	1a d8       	st.w	--sp,r8
80002418:	48 fc       	lddpc	r12,80002454 <DataSession_brdcst_func+0xd0>
8000241a:	f0 1f 00 0d 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000241e:	2f ed       	sub	sp,-8
80002420:	58 05       	cp.w	r5,0
80002422:	c1 20       	breq	80002446 <DataSession_brdcst_func+0xc2>
80002424:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002426:	48 d4       	lddpc	r4,80002458 <DataSession_brdcst_func+0xd4>
80002428:	ec 07 00 08 	add	r8,r6,r7
8000242c:	11 c8       	ld.ub	r8,r8[0x4]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	1a d7       	st.w	--sp,r7
80002432:	08 9c       	mov	r12,r4
80002434:	f0 1f 00 06 	mcall	8000244c <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002438:	2f f7       	sub	r7,-1
8000243a:	5c 57       	castu.b	r7
8000243c:	2f ed       	sub	sp,-8
8000243e:	ee 05 19 00 	cp.h	r5,r7
80002442:	fe 9b ff f3 	brhi	80002428 <DataSession_brdcst_func+0xa4>
80002446:	d8 22       	popm	r4-r7,pc
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	cc a4       	brge	800023de <DataSession_brdcst_func+0x5a>
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	69 d4       	ld.w	r4,r4[0x74]
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	cc b8       	rjmp	800025e8 <AudioRoutingControl_reply_func+0x1c>
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	cc d0       	breq	800023f0 <DataSession_brdcst_func+0x6c>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	cc ec       	rcall	800025f6 <Volume_reply_func+0x2>
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	cd 04       	brge	800023fe <DataSession_brdcst_func+0x7a>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	cd 14       	brge	80002404 <DataSession_brdcst_func+0x80>

80002464 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
80002468:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246a:	19 a9       	ld.ub	r9,r12[0x2]
8000246c:	30 08       	mov	r8,0
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c1 11       	brne	80002494 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002474:	49 3c       	lddpc	r12,800024c0 <DataSession_reply_func+0x5c>
80002476:	f0 1f 00 14 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000247a:	0f b8       	ld.ub	r8,r7[0x3]
8000247c:	1a d8       	st.w	--sp,r8
8000247e:	49 3c       	lddpc	r12,800024c8 <DataSession_reply_func+0x64>
80002480:	f0 1f 00 11 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002484:	0f c8       	ld.ub	r8,r7[0x4]
80002486:	1a d8       	st.w	--sp,r8
80002488:	49 1c       	lddpc	r12,800024cc <DataSession_reply_func+0x68>
8000248a:	f0 1f 00 0f 	mcall	800024c4 <DataSession_reply_func+0x60>
8000248e:	2f ed       	sub	sp,-8
80002490:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002494:	48 fc       	lddpc	r12,800024d0 <DataSession_reply_func+0x6c>
80002496:	f0 1f 00 0c 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000249a:	0f a8       	ld.ub	r8,r7[0x2]
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 ec       	lddpc	r12,800024d4 <DataSession_reply_func+0x70>
800024a0:	f0 1f 00 09 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800024a4:	0f b8       	ld.ub	r8,r7[0x3]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 cc       	lddpc	r12,800024d8 <DataSession_reply_func+0x74>
800024aa:	f0 1f 00 07 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800024ae:	0f c8       	ld.ub	r8,r7[0x4]
800024b0:	1a d8       	st.w	--sp,r8
800024b2:	48 bc       	lddpc	r12,800024dc <DataSession_reply_func+0x78>
800024b4:	f0 1f 00 04 	mcall	800024c4 <DataSession_reply_func+0x60>
800024b8:	2f dd       	sub	sp,-12
800024ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800024be:	00 00       	add	r0,r0
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	cd 2c       	rcall	80002666 <spk_brdcst_func+0xe>
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	69 d4       	ld.w	r4,r4[0x74]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cd 3c       	rcall	80002670 <spk_brdcst_func+0x18>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	cd 48       	rjmp	80002676 <spk_brdcst_func+0x1e>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	cd 54       	brge	8000247c <DataSession_reply_func+0x18>
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	cd 64       	brge	80002482 <DataSession_reply_func+0x1e>
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	cd 74       	brge	80002488 <DataSession_reply_func+0x24>
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	cd 80       	breq	8000248e <DataSession_reply_func+0x2a>

800024e0 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800024e4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800024e8:	0f 98       	ld.ub	r8,r7[0x1]
800024ea:	1a d8       	st.w	--sp,r8
800024ec:	48 bc       	lddpc	r12,80002518 <CallControl_brdcst_func+0x38>
800024ee:	f0 1f 00 0c 	mcall	8000251c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024f2:	2f fd       	sub	sp,-4
800024f4:	0f 99       	ld.ub	r9,r7[0x1]
800024f6:	30 38       	mov	r8,3
800024f8:	f0 09 18 00 	cp.b	r9,r8
800024fc:	c0 41       	brne	80002504 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024fe:	30 09       	mov	r9,0
80002500:	48 88       	lddpc	r8,80002520 <CallControl_brdcst_func+0x40>
80002502:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002504:	0f 99       	ld.ub	r9,r7[0x1]
80002506:	30 48       	mov	r8,4
80002508:	f0 09 18 00 	cp.b	r9,r8
8000250c:	c0 41       	brne	80002514 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000250e:	30 19       	mov	r9,1
80002510:	48 48       	lddpc	r8,80002520 <CallControl_brdcst_func+0x40>
80002512:	b0 89       	st.b	r8[0x0],r9
80002514:	e3 cd 80 80 	ldm	sp++,r7,pc
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	cd 8c       	rcall	800026ca <spk_reply_func+0x3a>
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	69 d4       	ld.w	r4,r4[0x74]
80002520:	00 00       	add	r0,r0
80002522:	0a 4d       	or	sp,r5

80002524 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002524:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002528:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000252c:	0f 99       	ld.ub	r9,r7[0x1]
8000252e:	30 08       	mov	r8,0
80002530:	f0 09 18 00 	cp.b	r9,r8
80002534:	c0 71       	brne	80002542 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002536:	48 ac       	lddpc	r12,8000255c <TransmitControl_brdcst_func+0x38>
80002538:	f0 1f 00 0a 	mcall	80002560 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
8000253c:	30 09       	mov	r9,0
8000253e:	48 a8       	lddpc	r8,80002564 <TransmitControl_brdcst_func+0x40>
80002540:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
80002542:	0f 99       	ld.ub	r9,r7[0x1]
80002544:	30 18       	mov	r8,1
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 71       	brne	80002558 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
8000254c:	48 7c       	lddpc	r12,80002568 <TransmitControl_brdcst_func+0x44>
8000254e:	f0 1f 00 05 	mcall	80002560 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002552:	30 19       	mov	r9,1
80002554:	48 48       	lddpc	r8,80002564 <TransmitControl_brdcst_func+0x40>
80002556:	b0 89       	st.b	r8[0x0],r9
80002558:	e3 cd 80 80 	ldm	sp++,r7,pc
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	cd a4       	brge	80002512 <CallControl_brdcst_func+0x32>
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	69 d4       	ld.w	r4,r4[0x74]
80002564:	00 00       	add	r0,r0
80002566:	0a 4c       	or	r12,r5
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	cd bc       	rcall	80002720 <mic_brdcst_func+0x48>

8000256c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000256c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002570:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002574:	0f 89       	ld.ub	r9,r7[0x0]
80002576:	30 08       	mov	r8,0
80002578:	f0 09 18 00 	cp.b	r9,r8
8000257c:	c1 61       	brne	800025a8 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000257e:	48 ec       	lddpc	r12,800025b4 <TransmitControl_reply_func+0x48>
80002580:	f0 1f 00 0e 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002584:	0f 98       	ld.ub	r8,r7[0x1]
80002586:	1a d8       	st.w	--sp,r8
80002588:	48 dc       	lddpc	r12,800025bc <TransmitControl_reply_func+0x50>
8000258a:	f0 1f 00 0c 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000258e:	0f a8       	ld.ub	r8,r7[0x2]
80002590:	1a d8       	st.w	--sp,r8
80002592:	48 cc       	lddpc	r12,800025c0 <TransmitControl_reply_func+0x54>
80002594:	f0 1f 00 09 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002598:	0f b8       	ld.ub	r8,r7[0x3]
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 ac       	lddpc	r12,800025c4 <TransmitControl_reply_func+0x58>
8000259e:	f0 1f 00 07 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
800025a2:	2f dd       	sub	sp,-12
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800025a8:	48 8c       	lddpc	r12,800025c8 <TransmitControl_reply_func+0x5c>
800025aa:	f0 1f 00 04 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
800025ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b2:	00 00       	add	r0,r0
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	cd d0       	breq	80002570 <TransmitControl_reply_func+0x4>
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	69 d4       	ld.w	r4,r4[0x74]
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	cd ec       	rcall	8000277a <mic_reply_func+0x4a>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	ce 00       	breq	80002582 <TransmitControl_reply_func+0x16>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	ce 1c       	rcall	80002788 <mic_reply_func+0x58>
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	ce 2c       	rcall	8000278e <mic_reply_func+0x5e>

800025cc <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800025cc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ce:	19 a9       	ld.ub	r9,r12[0x2]
800025d0:	30 08       	mov	r8,0
800025d2:	f0 09 18 00 	cp.b	r9,r8
800025d6:	c0 51       	brne	800025e0 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800025d8:	48 4c       	lddpc	r12,800025e8 <AudioRoutingControl_reply_func+0x1c>
800025da:	f0 1f 00 05 	mcall	800025ec <AudioRoutingControl_reply_func+0x20>
800025de:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800025e0:	48 4c       	lddpc	r12,800025f0 <AudioRoutingControl_reply_func+0x24>
800025e2:	f0 1f 00 03 	mcall	800025ec <AudioRoutingControl_reply_func+0x20>
800025e6:	d8 02       	popm	pc
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	ce 44       	brge	800025b2 <TransmitControl_reply_func+0x46>
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	69 d4       	ld.w	r4,r4[0x74]
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	ce 54       	brge	800025bc <TransmitControl_reply_func+0x50>

800025f4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025fc:	0f 89       	ld.ub	r9,r7[0x0]
800025fe:	30 08       	mov	r8,0
80002600:	f0 09 18 00 	cp.b	r9,r8
80002604:	c1 b1       	brne	8000263a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002606:	0f b8       	ld.ub	r8,r7[0x3]
80002608:	31 09       	mov	r9,16
8000260a:	f2 08 18 00 	cp.b	r8,r9
8000260e:	c0 f1       	brne	8000262c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002610:	48 dc       	lddpc	r12,80002644 <Volume_reply_func+0x50>
80002612:	f0 1f 00 0e 	mcall	80002648 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002616:	0f 99       	ld.ub	r9,r7[0x1]
80002618:	0f a8       	ld.ub	r8,r7[0x2]
8000261a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000261e:	1a d8       	st.w	--sp,r8
80002620:	48 bc       	lddpc	r12,8000264c <Volume_reply_func+0x58>
80002622:	f0 1f 00 0a 	mcall	80002648 <Volume_reply_func+0x54>
80002626:	2f fd       	sub	sp,-4
80002628:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000262c:	1a d8       	st.w	--sp,r8
8000262e:	48 9c       	lddpc	r12,80002650 <Volume_reply_func+0x5c>
80002630:	f0 1f 00 06 	mcall	80002648 <Volume_reply_func+0x54>
80002634:	2f fd       	sub	sp,-4
80002636:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000263a:	48 7c       	lddpc	r12,80002654 <Volume_reply_func+0x60>
8000263c:	f0 1f 00 03 	mcall	80002648 <Volume_reply_func+0x54>
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	ce 68       	rjmp	80002812 <dcm_reply_func+0x6>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	69 d4       	ld.w	r4,r4[0x74]
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	ce 7c       	rcall	8000281c <dcm_reply_func+0x10>
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	ce 98       	rjmp	80002824 <dcm_reply_func+0x18>
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	ce b0       	breq	8000262c <Volume_reply_func+0x38>

80002658 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002658:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000265a:	19 d9       	ld.ub	r9,r12[0x5]
8000265c:	30 08       	mov	r8,0
8000265e:	f0 09 18 00 	cp.b	r9,r8
80002662:	c0 81       	brne	80002672 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002664:	10 99       	mov	r9,r8
80002666:	48 78       	lddpc	r8,80002680 <spk_brdcst_func+0x28>
80002668:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000266a:	48 7c       	lddpc	r12,80002684 <spk_brdcst_func+0x2c>
8000266c:	f0 1f 00 07 	mcall	80002688 <spk_brdcst_func+0x30>
80002670:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002672:	30 19       	mov	r9,1
80002674:	48 38       	lddpc	r8,80002680 <spk_brdcst_func+0x28>
80002676:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002678:	48 5c       	lddpc	r12,8000268c <spk_brdcst_func+0x34>
8000267a:	f0 1f 00 04 	mcall	80002688 <spk_brdcst_func+0x30>
8000267e:	d8 02       	popm	pc
80002680:	00 00       	add	r0,r0
80002682:	0a 40       	or	r0,r5
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	ce c8       	rjmp	8000285e <dcm_reply_func+0x52>
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	69 d4       	ld.w	r4,r4[0x74]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	ce d8       	rjmp	80002868 <dcm_reply_func+0x5c>

80002690 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002690:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002692:	19 a9       	ld.ub	r9,r12[0x2]
80002694:	30 08       	mov	r8,0
80002696:	f0 09 18 00 	cp.b	r9,r8
8000269a:	c0 f1       	brne	800026b8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000269c:	19 e9       	ld.ub	r9,r12[0x6]
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c0 40       	breq	800026aa <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800026a4:	30 19       	mov	r9,1
800026a6:	48 98       	lddpc	r8,800026c8 <spk_reply_func+0x38>
800026a8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026aa:	19 e8       	ld.ub	r8,r12[0x6]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	48 8c       	lddpc	r12,800026cc <spk_reply_func+0x3c>
800026b0:	f0 1f 00 08 	mcall	800026d0 <spk_reply_func+0x40>
800026b4:	2f fd       	sub	sp,-4
800026b6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800026b8:	30 09       	mov	r9,0
800026ba:	48 48       	lddpc	r8,800026c8 <spk_reply_func+0x38>
800026bc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800026be:	48 6c       	lddpc	r12,800026d4 <spk_reply_func+0x44>
800026c0:	f0 1f 00 04 	mcall	800026d0 <spk_reply_func+0x40>
800026c4:	d8 02       	popm	pc
800026c6:	00 00       	add	r0,r0
800026c8:	00 00       	add	r0,r0
800026ca:	0a 40       	or	r0,r5
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	ce e4       	brge	800026aa <spk_reply_func+0x1a>
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	69 d4       	ld.w	r4,r4[0x74]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	ce f4       	brge	800026b4 <spk_reply_func+0x24>

800026d8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800026dc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800026e0:	0f a9       	ld.ub	r9,r7[0x2]
800026e2:	30 08       	mov	r8,0
800026e4:	f0 09 18 00 	cp.b	r9,r8
800026e8:	c0 71       	brne	800026f6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026ea:	48 dc       	lddpc	r12,8000271c <mic_brdcst_func+0x44>
800026ec:	f0 1f 00 0d 	mcall	80002720 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026f0:	30 09       	mov	r9,0
800026f2:	48 d8       	lddpc	r8,80002724 <mic_brdcst_func+0x4c>
800026f4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026f6:	0f a9       	ld.ub	r9,r7[0x2]
800026f8:	31 18       	mov	r8,17
800026fa:	f0 09 18 00 	cp.b	r9,r8
800026fe:	c0 d1       	brne	80002718 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002700:	48 ac       	lddpc	r12,80002728 <mic_brdcst_func+0x50>
80002702:	f0 1f 00 08 	mcall	80002720 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002706:	48 89       	lddpc	r9,80002724 <mic_brdcst_func+0x4c>
80002708:	30 18       	mov	r8,1
8000270a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000270c:	13 89       	ld.ub	r9,r9[0x0]
8000270e:	f0 09 18 00 	cp.b	r9,r8
80002712:	c0 31       	brne	80002718 <mic_brdcst_func+0x40>
80002714:	48 68       	lddpc	r8,8000272c <mic_brdcst_func+0x54>
80002716:	11 88       	ld.ub	r8,r8[0x0]
80002718:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	cf 00       	breq	800026fe <mic_brdcst_func+0x26>
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	69 d4       	ld.w	r4,r4[0x74]
80002724:	00 00       	add	r0,r0
80002726:	0a 51       	eor	r1,r5
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	cf 14       	brge	8000270c <mic_brdcst_func+0x34>
8000272c:	00 00       	add	r0,r0
8000272e:	0a 4d       	or	sp,r5

80002730 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002730:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002734:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002738:	49 ac       	lddpc	r12,800027a0 <mic_reply_func+0x70>
8000273a:	f0 1f 00 1b 	mcall	800027a4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000273e:	0f 89       	ld.ub	r9,r7[0x0]
80002740:	30 08       	mov	r8,0
80002742:	f0 09 18 00 	cp.b	r9,r8
80002746:	c2 71       	brne	80002794 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002748:	0f 98       	ld.ub	r8,r7[0x1]
8000274a:	30 29       	mov	r9,2
8000274c:	f2 08 18 00 	cp.b	r8,r9
80002750:	c1 b1       	brne	80002786 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002752:	49 6c       	lddpc	r12,800027a8 <mic_reply_func+0x78>
80002754:	f0 1f 00 14 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002758:	0f a8       	ld.ub	r8,r7[0x2]
8000275a:	1a d8       	st.w	--sp,r8
8000275c:	49 4c       	lddpc	r12,800027ac <mic_reply_func+0x7c>
8000275e:	f0 1f 00 12 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002762:	0f b8       	ld.ub	r8,r7[0x3]
80002764:	1a d8       	st.w	--sp,r8
80002766:	49 3c       	lddpc	r12,800027b0 <mic_reply_func+0x80>
80002768:	f0 1f 00 0f 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000276c:	0f c8       	ld.ub	r8,r7[0x4]
8000276e:	1a d8       	st.w	--sp,r8
80002770:	49 1c       	lddpc	r12,800027b4 <mic_reply_func+0x84>
80002772:	f0 1f 00 0d 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002776:	0f d8       	ld.ub	r8,r7[0x5]
80002778:	1a d8       	st.w	--sp,r8
8000277a:	49 0c       	lddpc	r12,800027b8 <mic_reply_func+0x88>
8000277c:	f0 1f 00 0a 	mcall	800027a4 <mic_reply_func+0x74>
80002780:	2f cd       	sub	sp,-16
80002782:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002786:	1a d8       	st.w	--sp,r8
80002788:	48 dc       	lddpc	r12,800027bc <mic_reply_func+0x8c>
8000278a:	f0 1f 00 07 	mcall	800027a4 <mic_reply_func+0x74>
8000278e:	2f fd       	sub	sp,-4
80002790:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002794:	48 bc       	lddpc	r12,800027c0 <mic_reply_func+0x90>
80002796:	f0 1f 00 04 	mcall	800027a4 <mic_reply_func+0x74>
8000279a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	cf 28       	rjmp	80002986 <set_idle_store_isr+0x12>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	69 d4       	ld.w	r4,r4[0x74]
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	cf 38       	rjmp	80002990 <phy_rx>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	cf 4c       	rcall	80002996 <phy_rx+0x6>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	cf 60       	breq	8000279e <mic_reply_func+0x6e>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	cf 7c       	rcall	800029a4 <phy_rx+0x14>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	cf 94       	brge	800027ac <mic_reply_func+0x7c>
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	cf ac       	rcall	800029b2 <phy_rx+0x22>
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	cf c4       	brge	800027ba <mic_reply_func+0x8a>

800027c4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800027c4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800027c8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800027cc:	48 bc       	lddpc	r12,800027f8 <dcm_brdcst_func+0x34>
800027ce:	f0 1f 00 0c 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800027d2:	0f 88       	ld.ub	r8,r7[0x0]
800027d4:	1a d8       	st.w	--sp,r8
800027d6:	48 bc       	lddpc	r12,80002800 <dcm_brdcst_func+0x3c>
800027d8:	f0 1f 00 09 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800027dc:	0f a8       	ld.ub	r8,r7[0x2]
800027de:	1a d8       	st.w	--sp,r8
800027e0:	48 9c       	lddpc	r12,80002804 <dcm_brdcst_func+0x40>
800027e2:	f0 1f 00 07 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800027e6:	0f 98       	ld.ub	r8,r7[0x1]
800027e8:	1a d8       	st.w	--sp,r8
800027ea:	48 8c       	lddpc	r12,80002808 <dcm_brdcst_func+0x44>
800027ec:	f0 1f 00 04 	mcall	800027fc <dcm_brdcst_func+0x38>
800027f0:	2f dd       	sub	sp,-12
	
	
}
800027f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027f6:	00 00       	add	r0,r0
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	cf d4       	brge	800027f4 <dcm_brdcst_func+0x30>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	69 d4       	ld.w	r4,r4[0x74]
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	cf e8       	rjmp	800029fe <phy_tx+0x16>
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	cf fc       	rcall	80002a04 <phy_tx+0x1c>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	d0 14       	*unknown*

8000280c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000280c:	eb cd 40 80 	pushm	r7,lr
80002810:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002812:	19 a9       	ld.ub	r9,r12[0x2]
80002814:	30 08       	mov	r8,0
80002816:	f0 09 18 00 	cp.b	r9,r8
8000281a:	c1 b1       	brne	80002850 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000281c:	19 b8       	ld.ub	r8,r12[0x3]
8000281e:	30 19       	mov	r9,1
80002820:	f2 08 18 00 	cp.b	r8,r9
80002824:	c0 51       	brne	8000282e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002826:	48 ec       	lddpc	r12,8000285c <dcm_reply_func+0x50>
80002828:	f0 1f 00 0e 	mcall	80002860 <dcm_reply_func+0x54>
8000282c:	c0 a8       	rjmp	80002840 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000282e:	58 08       	cp.w	r8,0
80002830:	c0 51       	brne	8000283a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002832:	48 dc       	lddpc	r12,80002864 <dcm_reply_func+0x58>
80002834:	f0 1f 00 0b 	mcall	80002860 <dcm_reply_func+0x54>
80002838:	c0 48       	rjmp	80002840 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000283a:	48 cc       	lddpc	r12,80002868 <dcm_reply_func+0x5c>
8000283c:	f0 1f 00 09 	mcall	80002860 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002840:	0f d8       	ld.ub	r8,r7[0x5]
80002842:	1a d8       	st.w	--sp,r8
80002844:	48 ac       	lddpc	r12,8000286c <dcm_reply_func+0x60>
80002846:	f0 1f 00 07 	mcall	80002860 <dcm_reply_func+0x54>
8000284a:	2f fd       	sub	sp,-4
8000284c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002850:	48 8c       	lddpc	r12,80002870 <dcm_reply_func+0x64>
80002852:	f0 1f 00 04 	mcall	80002860 <dcm_reply_func+0x54>
80002856:	e3 cd 80 80 	ldm	sp++,r7,pc
8000285a:	00 00       	add	r0,r0
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	d0 30       	acall	0x3
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	69 d4       	ld.w	r4,r4[0x74]
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	d0 44       	*unknown*
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	d0 58       	*unknown*
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d0 6c       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d0 78       	*unknown*

80002874 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002874:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002876:	19 a9       	ld.ub	r9,r12[0x2]
80002878:	30 08       	mov	r8,0
8000287a:	f0 09 18 00 	cp.b	r9,r8
8000287e:	c0 51       	brne	80002888 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002880:	48 4c       	lddpc	r12,80002890 <ToneControl_reply_func+0x1c>
80002882:	f0 1f 00 05 	mcall	80002894 <ToneControl_reply_func+0x20>
80002886:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002888:	48 4c       	lddpc	r12,80002898 <ToneControl_reply_func+0x24>
8000288a:	f0 1f 00 03 	mcall	80002894 <ToneControl_reply_func+0x20>
8000288e:	d8 02       	popm	pc
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	d0 84       	*unknown*
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	69 d4       	ld.w	r4,r4[0x74]
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	d0 90       	acall	0x9

8000289c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000289c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000289e:	19 e8       	ld.ub	r8,r12[0x6]
800028a0:	30 19       	mov	r9,1
800028a2:	f2 08 18 00 	cp.b	r8,r9
800028a6:	c0 61       	brne	800028b2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a8:	48 98       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028aa:	70 09       	ld.w	r9,r8[0x0]
800028ac:	a1 a9       	sbr	r9,0x0
800028ae:	91 09       	st.w	r8[0x0],r9
800028b0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028b2:	30 29       	mov	r9,2
800028b4:	f2 08 18 00 	cp.b	r8,r9
800028b8:	c0 80       	breq	800028c8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ba:	48 58       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028bc:	70 09       	ld.w	r9,r8[0x0]
800028be:	e0 19 ff fc 	andl	r9,0xfffc
800028c2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028c4:	f0 1f 00 03 	mcall	800028d0 <DeviceInitializationStatus_brdcst_func+0x34>
800028c8:	d8 02       	popm	pc
800028ca:	00 00       	add	r0,r0
800028cc:	00 00       	add	r0,r0
800028ce:	0d 78       	ld.ub	r8,--r6
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	3d c8       	mov	r8,-36

800028d4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028d4:	20 1c       	sub	r12,1
800028d6:	5c 5c       	castu.b	r12
800028d8:	31 18       	mov	r8,17
800028da:	f0 0c 18 00 	cp.b	r12,r8
800028de:	e0 88 00 03 	brls	800028e4 <CalculateBurst+0x10>
800028e2:	5e fd       	retal	0
800028e4:	48 28       	lddpc	r8,800028ec <CalculateBurst+0x18>
800028e6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028ea:	5e fc       	retal	r12
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	d0 9c       	*unknown*

800028f0 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028f0:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028f2:	48 98       	lddpc	r8,80002914 <payload_init+0x24>
800028f4:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028f6:	48 98       	lddpc	r8,80002918 <payload_init+0x28>
800028f8:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028fa:	30 09       	mov	r9,0
800028fc:	1a d9       	st.w	--sp,r9
800028fe:	1a d9       	st.w	--sp,r9
80002900:	1a d9       	st.w	--sp,r9
80002902:	30 28       	mov	r8,2
80002904:	e0 6a 04 00 	mov	r10,1024
80002908:	48 5b       	lddpc	r11,8000291c <payload_init+0x2c>
8000290a:	48 6c       	lddpc	r12,80002920 <payload_init+0x30>
8000290c:	f0 1f 00 06 	mcall	80002924 <payload_init+0x34>
80002910:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002912:	d8 02       	popm	pc
80002914:	00 00       	add	r0,r0
80002916:	0a 58       	eor	r8,r5
80002918:	00 00       	add	r0,r0
8000291a:	0a 5c       	eor	r12,r5
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	d0 e4       	*unknown*
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	29 28       	sub	r8,-110
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	66 10       	ld.w	r0,r3[0x4]

80002928 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002928:	eb cd 40 f8 	pushm	r3-r7,lr
8000292c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000292e:	48 e8       	lddpc	r8,80002964 <payload_rx_process+0x3c>
80002930:	70 08       	ld.w	r8,r8[0x0]
80002932:	58 08       	cp.w	r8,0
80002934:	c0 71       	brne	80002942 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002936:	30 4b       	mov	r11,4
80002938:	30 5c       	mov	r12,5
8000293a:	f0 1f 00 0c 	mcall	80002968 <payload_rx_process+0x40>
8000293e:	48 a8       	lddpc	r8,80002964 <payload_rx_process+0x3c>
80002940:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	48 96       	lddpc	r6,80002964 <payload_rx_process+0x3c>
80002944:	30 05       	mov	r5,0
80002946:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002948:	48 93       	lddpc	r3,8000296c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000294a:	6c 0c       	ld.w	r12,r6[0x0]
8000294c:	0a 99       	mov	r9,r5
8000294e:	08 9a       	mov	r10,r4
80002950:	1a 9b       	mov	r11,sp
80002952:	f0 1f 00 08 	mcall	80002970 <payload_rx_process+0x48>
80002956:	58 1c       	cp.w	r12,1
80002958:	cf 91       	brne	8000294a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000295a:	66 08       	ld.w	r8,r3[0x0]
8000295c:	40 0c       	lddsp	r12,sp[0x0]
8000295e:	5d 18       	icall	r8
80002960:	cf 5b       	rjmp	8000294a <payload_rx_process+0x22>
80002962:	00 00       	add	r0,r0
80002964:	00 00       	add	r0,r0
80002966:	0a 88       	andn	r8,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	5f 3c       	srlo	r12
8000296c:	00 00       	add	r0,r0
8000296e:	0a 58       	eor	r8,r5
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	5c 30       	neg	r0

80002974 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002974:	d4 01       	pushm	lr
80002976:	20 2d       	sub	sp,8
80002978:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000297a:	30 09       	mov	r9,0
8000297c:	fa ca ff f8 	sub	r10,sp,-8
80002980:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002982:	1a 9b       	mov	r11,sp
80002984:	f0 1f 00 02 	mcall	8000298c <set_idle_store_isr+0x18>
}
80002988:	2f ed       	sub	sp,-8
8000298a:	d8 02       	popm	pc
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	5d ec       	*unknown*

80002990 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002990:	d4 01       	pushm	lr
80002992:	20 2d       	sub	sp,8
80002994:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002996:	58 0c       	cp.w	r12,0
80002998:	c1 10       	breq	800029ba <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000299a:	30 08       	mov	r8,0
8000299c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000299e:	98 88       	ld.uh	r8,r12[0x0]
800029a0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029a4:	e0 48 40 00 	cp.w	r8,16384
800029a8:	c0 91       	brne	800029ba <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029aa:	48 68       	lddpc	r8,800029c0 <phy_rx+0x30>
800029ac:	70 0c       	ld.w	r12,r8[0x0]
800029ae:	30 09       	mov	r9,0
800029b0:	fa ca ff fc 	sub	r10,sp,-4
800029b4:	1a 9b       	mov	r11,sp
800029b6:	f0 1f 00 04 	mcall	800029c4 <phy_rx+0x34>
		}	

    }
		
 
}
800029ba:	2f ed       	sub	sp,-8
800029bc:	d8 02       	popm	pc
800029be:	00 00       	add	r0,r0
800029c0:	00 00       	add	r0,r0
800029c2:	0a b4       	st.h	r5++,r4
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	5d ec       	*unknown*

800029c8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c8:	eb cd 40 80 	pushm	r7,lr
800029cc:	20 1d       	sub	sp,4
800029ce:	fa c7 ff fc 	sub	r7,sp,-4
800029d2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029d4:	30 09       	mov	r9,0
800029d6:	12 9a       	mov	r10,r9
800029d8:	1a 9b       	mov	r11,sp
800029da:	f0 1f 00 03 	mcall	800029e4 <set_idle_store+0x1c>
}
800029de:	2f fd       	sub	sp,-4
800029e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	5e 3c       	retlo	r12

800029e8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e8:	d4 01       	pushm	lr
800029ea:	20 1d       	sub	sp,4
800029ec:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029ee:	98 88       	ld.uh	r8,r12[0x0]
800029f0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029f4:	e0 48 40 00 	cp.w	r8,16384
800029f8:	c0 d1       	brne	80002a12 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029fa:	49 08       	lddpc	r8,80002a38 <phy_tx+0x50>
800029fc:	70 08       	ld.w	r8,r8[0x0]
800029fe:	58 08       	cp.w	r8,0
80002a00:	c1 a0       	breq	80002a34 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a02:	48 e8       	lddpc	r8,80002a38 <phy_tx+0x50>
80002a04:	70 0c       	ld.w	r12,r8[0x0]
80002a06:	30 09       	mov	r9,0
80002a08:	12 9a       	mov	r10,r9
80002a0a:	1a 9b       	mov	r11,sp
80002a0c:	f0 1f 00 0c 	mcall	80002a3c <phy_tx+0x54>
80002a10:	c1 28       	rjmp	80002a34 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a12:	e0 48 10 00 	cp.w	r8,4096
80002a16:	5f 0a       	sreq	r10
80002a18:	e0 48 20 00 	cp.w	r8,8192
80002a1c:	5f 09       	sreq	r9
80002a1e:	f5 e9 10 09 	or	r9,r10,r9
80002a22:	c0 71       	brne	80002a30 <phy_tx+0x48>
80002a24:	e0 48 50 00 	cp.w	r8,20480
80002a28:	c0 40       	breq	80002a30 <phy_tx+0x48>
80002a2a:	e0 48 60 00 	cp.w	r8,24576
80002a2e:	c0 31       	brne	80002a34 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a30:	48 48       	lddpc	r8,80002a40 <phy_tx+0x58>
80002a32:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a34:	2f fd       	sub	sp,-4
80002a36:	d8 02       	popm	pc
80002a38:	00 00       	add	r0,r0
80002a3a:	0a c0       	st.b	r5++,r0
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	5e 3c       	retlo	r12
80002a40:	00 00       	add	r0,r0
80002a42:	0a a8       	st.w	r5++,r8

80002a44 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a44:	d4 01       	pushm	lr
80002a46:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a48:	30 08       	mov	r8,0
80002a4a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a4c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a4e:	1a 9a       	mov	r10,sp
80002a50:	fa cb ff fc 	sub	r11,sp,-4
80002a54:	f0 1f 00 05 	mcall	80002a68 <get_idle_store_isr+0x24>
80002a58:	58 1c       	cp.w	r12,1
80002a5a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a5e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a62:	2f ed       	sub	sp,-8
80002a64:	d8 02       	popm	pc
80002a66:	00 00       	add	r0,r0
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	5b 40       	cp.w	r0,-12

80002a6c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a6c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a70:	20 1d       	sub	sp,4
80002a72:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a74:	4b a8       	lddpc	r8,80002b5c <phy_tx_func+0xf0>
80002a76:	70 08       	ld.w	r8,r8[0x0]
80002a78:	58 08       	cp.w	r8,0
80002a7a:	c6 60       	breq	80002b46 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a7c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a7e:	30 08       	mov	r8,0
80002a80:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a82:	4b 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002a84:	70 08       	ld.w	r8,r8[0x0]
80002a86:	58 18       	cp.w	r8,1
80002a88:	c2 60       	breq	80002ad4 <phy_tx_func+0x68>
80002a8a:	c0 43       	brcs	80002a92 <phy_tx_func+0x26>
80002a8c:	58 28       	cp.w	r8,2
80002a8e:	c5 c1       	brne	80002b46 <phy_tx_func+0xda>
80002a90:	c5 58       	rjmp	80002b3a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a92:	4b 38       	lddpc	r8,80002b5c <phy_tx_func+0xf0>
80002a94:	70 0c       	ld.w	r12,r8[0x0]
80002a96:	1a 9a       	mov	r10,sp
80002a98:	4b 3b       	lddpc	r11,80002b64 <phy_tx_func+0xf8>
80002a9a:	f0 1f 00 34 	mcall	80002b68 <phy_tx_func+0xfc>
80002a9e:	58 1c       	cp.w	r12,1
80002aa0:	c1 41       	brne	80002ac8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aa2:	4b 18       	lddpc	r8,80002b64 <phy_tx_func+0xf8>
80002aa4:	70 08       	ld.w	r8,r8[0x0]
80002aa6:	90 08       	ld.sh	r8,r8[0x0]
80002aa8:	10 9a       	mov	r10,r8
80002aaa:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002aae:	4b 09       	lddpc	r9,80002b6c <phy_tx_func+0x100>
80002ab0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ab2:	5c 78       	castu.h	r8
80002ab4:	ea 18 ab cd 	orh	r8,0xabcd
80002ab8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002aba:	30 19       	mov	r9,1
80002abc:	4a d8       	lddpc	r8,80002b70 <phy_tx_func+0x104>
80002abe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac0:	30 19       	mov	r9,1
80002ac2:	4a 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002ac4:	91 09       	st.w	r8[0x0],r9
80002ac6:	c4 08       	rjmp	80002b46 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ac8:	e0 68 5a 5a 	mov	r8,23130
80002acc:	ea 18 ab cd 	orh	r8,0xabcd
80002ad0:	8f 18       	st.w	r7[0x4],r8
80002ad2:	c3 a8       	rjmp	80002b46 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad4:	4a 7a       	lddpc	r10,80002b70 <phy_tx_func+0x104>
80002ad6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ad8:	4a 39       	lddpc	r9,80002b64 <phy_tx_func+0xf8>
80002ada:	72 09       	ld.w	r9,r9[0x0]
80002adc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ae0:	b1 69       	lsl	r9,0x10
80002ae2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ae4:	2f f8       	sub	r8,-1
80002ae6:	5c 58       	castu.b	r8
80002ae8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002aea:	4a 1b       	lddpc	r11,80002b6c <phy_tx_func+0x100>
80002aec:	96 0c       	ld.sh	r12,r11[0x0]
80002aee:	20 2c       	sub	r12,2
80002af0:	5c 8c       	casts.h	r12
80002af2:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002af6:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002af8:	30 0b       	mov	r11,0
80002afa:	f6 0a 19 00 	cp.h	r10,r11
80002afe:	e0 89 00 09 	brgt	80002b10 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b02:	e8 19 00 ba 	orl	r9,0xba
80002b06:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b08:	30 09       	mov	r9,0
80002b0a:	49 68       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b0c:	91 09       	st.w	r8[0x0],r9
80002b0e:	c1 c8       	rjmp	80002b46 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b10:	49 5a       	lddpc	r10,80002b64 <phy_tx_func+0xf8>
80002b12:	74 0a       	ld.w	r10,r10[0x0]
80002b14:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b18:	14 49       	or	r9,r10
80002b1a:	8f 19       	st.w	r7[0x4],r9
80002b1c:	2f f8       	sub	r8,-1
80002b1e:	49 59       	lddpc	r9,80002b70 <phy_tx_func+0x104>
80002b20:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b22:	20 2c       	sub	r12,2
80002b24:	49 28       	lddpc	r8,80002b6c <phy_tx_func+0x100>
80002b26:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b28:	30 08       	mov	r8,0
80002b2a:	f0 0c 19 00 	cp.h	r12,r8
80002b2e:	e0 89 00 0c 	brgt	80002b46 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b32:	30 29       	mov	r9,2
80002b34:	48 b8       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b36:	91 09       	st.w	r8[0x0],r9
80002b38:	c0 78       	rjmp	80002b46 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b3a:	fc 18 00 ba 	movh	r8,0xba
80002b3e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b40:	30 09       	mov	r9,0
80002b42:	48 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b44:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b46:	e0 68 5a 5a 	mov	r8,23130
80002b4a:	ea 18 ab cd 	orh	r8,0xabcd
80002b4e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b50:	30 08       	mov	r8,0
80002b52:	8f 38       	st.w	r7[0xc],r8
}
80002b54:	2f fd       	sub	sp,-4
80002b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b5a:	00 00       	add	r0,r0
80002b5c:	00 00       	add	r0,r0
80002b5e:	0a c0       	st.b	r5++,r0
80002b60:	00 00       	add	r0,r0
80002b62:	0a 7c       	tst	r12,r5
80002b64:	00 00       	add	r0,r0
80002b66:	0a c8       	st.b	r5++,r8
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	5b 40       	cp.w	r0,-12
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a a4       	st.w	r5++,r4
80002b70:	00 00       	add	r0,r0
80002b72:	0a 60       	and	r0,r5

80002b74 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b74:	d4 01       	pushm	lr
80002b76:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b78:	30 0a       	mov	r10,0
80002b7a:	fa cb ff fc 	sub	r11,sp,-4
80002b7e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b80:	14 99       	mov	r9,r10
80002b82:	1a 9b       	mov	r11,sp
80002b84:	f0 1f 00 05 	mcall	80002b98 <get_idle_store+0x24>
80002b88:	58 1c       	cp.w	r12,1
80002b8a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b8e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002b92:	2f fd       	sub	sp,-4
80002b94:	d8 02       	popm	pc
80002b96:	00 00       	add	r0,r0
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	5c 30       	neg	r0

80002b9c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002b9c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002b9e:	48 5b       	lddpc	r11,80002bb0 <phy_init+0x14>
80002ba0:	48 5c       	lddpc	r12,80002bb4 <phy_init+0x18>
80002ba2:	f0 1f 00 06 	mcall	80002bb8 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002ba6:	f0 1f 00 06 	mcall	80002bbc <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002baa:	f0 1f 00 06 	mcall	80002bc0 <phy_init+0x24>
	
}
80002bae:	d8 02       	popm	pc
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	2a 6c       	sub	r12,-90
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	2c 24       	sub	r4,-62
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	3c 6c       	mov	r12,-58
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	3c 80       	mov	r0,-56
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	46 20       	lddsp	r0,sp[0x188]

80002bc4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bc4:	d4 01       	pushm	lr
80002bc6:	20 2d       	sub	sp,8
80002bc8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bca:	30 08       	mov	r8,0
80002bcc:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002bce:	48 f8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002bd0:	70 08       	ld.w	r8,r8[0x0]
80002bd2:	58 08       	cp.w	r8,0
80002bd4:	c0 71       	brne	80002be2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bd6:	30 4b       	mov	r11,4
80002bd8:	30 5c       	mov	r12,5
80002bda:	f0 1f 00 0d 	mcall	80002c0c <payload_rx+0x48>
80002bde:	48 b8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002be0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002be2:	48 a8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002be4:	70 0c       	ld.w	r12,r8[0x0]
80002be6:	30 09       	mov	r9,0
80002be8:	fa ca ff fc 	sub	r10,sp,-4
80002bec:	1a 9b       	mov	r11,sp
80002bee:	f0 1f 00 09 	mcall	80002c10 <payload_rx+0x4c>
80002bf2:	c0 91       	brne	80002c04 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002bf4:	48 88       	lddpc	r8,80002c14 <payload_rx+0x50>
80002bf6:	70 0c       	ld.w	r12,r8[0x0]
80002bf8:	40 0b       	lddsp	r11,sp[0x0]
80002bfa:	f0 1f 00 08 	mcall	80002c18 <payload_rx+0x54>
		logFromISR("mm");
80002bfe:	48 8c       	lddpc	r12,80002c1c <payload_rx+0x58>
80002c00:	f0 1f 00 08 	mcall	80002c20 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002c04:	2f ed       	sub	sp,-8
80002c06:	d8 02       	popm	pc
80002c08:	00 00       	add	r0,r0
80002c0a:	0a 88       	andn	r8,r5
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	5f 3c       	srlo	r12
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	5d ec       	*unknown*
80002c14:	00 00       	add	r0,r0
80002c16:	0a 6c       	and	r12,r5
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	29 74       	sub	r4,-105
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	d0 f0       	acall	0xf
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	6b 60       	ld.w	r0,r5[0x58]

80002c24 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c24:	eb cd 40 e0 	pushm	r5-r7,lr
80002c28:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c2a:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c2e:	70 08       	ld.w	r8,r8[0x0]
80002c30:	58 08       	cp.w	r8,0
80002c32:	e0 80 01 08 	breq	80002e42 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c36:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c38:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c3c:	70 09       	ld.w	r9,r8[0x0]
80002c3e:	2f f9       	sub	r9,-1
80002c40:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c42:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c46:	70 08       	ld.w	r8,r8[0x0]
80002c48:	58 18       	cp.w	r8,1
80002c4a:	e0 80 00 85 	breq	80002d54 <phy_rx_func+0x130>
80002c4e:	c0 73       	brcs	80002c5c <phy_rx_func+0x38>
80002c50:	58 28       	cp.w	r8,2
80002c52:	c5 c0       	breq	80002d0a <phy_rx_func+0xe6>
80002c54:	58 38       	cp.w	r8,3
80002c56:	e0 81 00 f6 	brne	80002e42 <phy_rx_func+0x21e>
80002c5a:	cd 58       	rjmp	80002e04 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c5c:	e0 6a 5a 5a 	mov	r10,23130
80002c60:	ea 1a ab cd 	orh	r10,0xabcd
80002c64:	14 36       	cp.w	r6,r10
80002c66:	e0 80 00 ee 	breq	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c6a:	ec 08 16 10 	lsr	r8,r6,0x10
80002c6e:	e0 48 ab cd 	cp.w	r8,43981
80002c72:	e0 81 00 e8 	brne	80002e42 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c76:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c7a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c7e:	20 28       	sub	r8,2
80002c80:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c84:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c86:	30 09       	mov	r9,0
80002c88:	f2 08 19 00 	cp.h	r8,r9
80002c8c:	e0 8a 00 db 	brle	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002c90:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002c94:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002c96:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002c9a:	70 0c       	ld.w	r12,r8[0x0]
80002c9c:	f0 1f 03 88 	mcall	80003abc <phy_rx_func+0xe98>
80002ca0:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002ca4:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002ca6:	58 0c       	cp.w	r12,0
80002ca8:	e0 80 00 cd 	breq	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002cac:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cb0:	90 09       	ld.sh	r9,r8[0x0]
80002cb2:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cb6:	2f f9       	sub	r9,-1
80002cb8:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cba:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cbe:	74 0a       	ld.w	r10,r10[0x0]
80002cc0:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002cc4:	76 0b       	ld.w	r11,r11[0x0]
80002cc6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cca:	2f f9       	sub	r9,-1
80002ccc:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002cce:	e2 16 0f 00 	andl	r6,0xf00,COH
80002cd2:	e0 46 01 00 	cp.w	r6,256
80002cd6:	c0 c0       	breq	80002cee <phy_rx_func+0xca>
80002cd8:	e0 8b 00 05 	brhi	80002ce2 <phy_rx_func+0xbe>
80002cdc:	58 06       	cp.w	r6,0
80002cde:	c0 80       	breq	80002cee <phy_rx_func+0xca>
80002ce0:	c0 c8       	rjmp	80002cf8 <phy_rx_func+0xd4>
80002ce2:	e0 46 02 00 	cp.w	r6,512
80002ce6:	c0 40       	breq	80002cee <phy_rx_func+0xca>
80002ce8:	e0 46 03 00 	cp.w	r6,768
80002cec:	c0 61       	brne	80002cf8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002cee:	30 29       	mov	r9,2
80002cf0:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002cf4:	91 09       	st.w	r8[0x0],r9
80002cf6:	ca 68       	rjmp	80002e42 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002cf8:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002cfc:	70 0c       	ld.w	r12,r8[0x0]
80002cfe:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d02:	70 0b       	ld.w	r11,r8[0x0]
80002d04:	f0 1f 03 70 	mcall	80003ac4 <phy_rx_func+0xea0>
80002d08:	c9 d8       	rjmp	80002e42 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d0a:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d0e:	b1 86       	lsr	r6,0x10
80002d10:	14 06       	add	r6,r10
80002d12:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d16:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d18:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d1c:	90 09       	ld.sh	r9,r8[0x0]
80002d1e:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d22:	76 0b       	ld.w	r11,r11[0x0]
80002d24:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d28:	2f f9       	sub	r9,-1
80002d2a:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d2c:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d30:	92 08       	ld.sh	r8,r9[0x0]
80002d32:	20 28       	sub	r8,2
80002d34:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d36:	30 09       	mov	r9,0
80002d38:	f2 08 19 00 	cp.h	r8,r9
80002d3c:	e0 8a 00 07 	brle	80002d4a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d40:	30 19       	mov	r9,1
80002d42:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d46:	91 09       	st.w	r8[0x0],r9
80002d48:	c7 d8       	rjmp	80002e42 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d4a:	30 39       	mov	r9,3
80002d4c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d50:	91 09       	st.w	r8[0x0],r9
80002d52:	c7 88       	rjmp	80002e42 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d54:	ec 0a 14 10 	asr	r10,r6,0x10
80002d58:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d5c:	90 09       	ld.sh	r9,r8[0x0]
80002d5e:	14 09       	add	r9,r10
80002d60:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d62:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d66:	92 08       	ld.sh	r8,r9[0x0]
80002d68:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d6c:	76 0b       	ld.w	r11,r11[0x0]
80002d6e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d72:	2f f8       	sub	r8,-1
80002d74:	5c 88       	casts.h	r8
80002d76:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d78:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d7c:	94 09       	ld.sh	r9,r10[0x0]
80002d7e:	20 29       	sub	r9,2
80002d80:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d82:	30 0a       	mov	r10,0
80002d84:	f4 09 19 00 	cp.h	r9,r10
80002d88:	e0 89 00 20 	brgt	80002dc8 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002d8c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002d90:	e0 46 00 ba 	cp.w	r6,186
80002d94:	c0 d1       	brne	80002dae <phy_rx_func+0x18a>
80002d96:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002d9a:	90 09       	ld.sh	r9,r8[0x0]
80002d9c:	f4 09 19 00 	cp.h	r9,r10
80002da0:	c0 71       	brne	80002dae <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002da2:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002da6:	70 0c       	ld.w	r12,r8[0x0]
80002da8:	f0 1f 03 49 	mcall	80003acc <phy_rx_func+0xea8>
80002dac:	c0 98       	rjmp	80002dbe <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002dae:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002db2:	70 0c       	ld.w	r12,r8[0x0]
80002db4:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002db8:	70 0b       	ld.w	r11,r8[0x0]
80002dba:	f0 1f 03 43 	mcall	80003ac4 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dbe:	30 09       	mov	r9,0
80002dc0:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dc4:	91 09       	st.w	r8[0x0],r9
80002dc6:	c3 e8       	rjmp	80002e42 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002dc8:	5c 86       	casts.h	r6
80002dca:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002dce:	92 0a       	ld.sh	r10,r9[0x0]
80002dd0:	0c 0a       	add	r10,r6
80002dd2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dd4:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002dd8:	72 09       	ld.w	r9,r9[0x0]
80002dda:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002dde:	2f f8       	sub	r8,-1
80002de0:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002de4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002de6:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002dea:	92 08       	ld.sh	r8,r9[0x0]
80002dec:	20 28       	sub	r8,2
80002dee:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002df0:	30 09       	mov	r9,0
80002df2:	f2 08 19 00 	cp.h	r8,r9
80002df6:	e0 89 00 26 	brgt	80002e42 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002dfa:	30 39       	mov	r9,3
80002dfc:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e00:	91 09       	st.w	r8[0x0],r9
80002e02:	c2 08       	rjmp	80002e42 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e04:	e6 16 00 ff 	andh	r6,0xff,COH
80002e08:	fc 19 00 ba 	movh	r9,0xba
80002e0c:	12 36       	cp.w	r6,r9
80002e0e:	c0 e1       	brne	80002e2a <phy_rx_func+0x206>
80002e10:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e14:	90 09       	ld.sh	r9,r8[0x0]
80002e16:	30 08       	mov	r8,0
80002e18:	f0 09 19 00 	cp.h	r9,r8
80002e1c:	c0 71       	brne	80002e2a <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e1e:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e22:	70 0c       	ld.w	r12,r8[0x0]
80002e24:	f0 1f 03 2a 	mcall	80003acc <phy_rx_func+0xea8>
80002e28:	c0 98       	rjmp	80002e3a <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e2a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e2e:	70 0c       	ld.w	r12,r8[0x0]
80002e30:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e34:	70 0b       	ld.w	r11,r8[0x0]
80002e36:	f0 1f 03 24 	mcall	80003ac4 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e3a:	30 09       	mov	r9,0
80002e3c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e40:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e42:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e46:	11 89       	ld.ub	r9,r8[0x0]
80002e48:	30 08       	mov	r8,0
80002e4a:	f0 09 18 00 	cp.b	r9,r8
80002e4e:	c1 31       	brne	80002e74 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e50:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e54:	6c 0c       	ld.w	r12,r6[0x0]
80002e56:	f0 1f 03 1a 	mcall	80003abc <phy_rx_func+0xe98>
80002e5a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e5e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e60:	6c 0c       	ld.w	r12,r6[0x0]
80002e62:	f0 1f 03 17 	mcall	80003abc <phy_rx_func+0xe98>
80002e66:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e6a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e6c:	30 19       	mov	r9,1
80002e6e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e72:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e74:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e78:	70 08       	ld.w	r8,r8[0x0]
80002e7a:	58 28       	cp.w	r8,2
80002e7c:	e0 80 01 98 	breq	800031ac <phy_rx_func+0x588>
80002e80:	e0 8b 00 06 	brhi	80002e8c <phy_rx_func+0x268>
80002e84:	58 08       	cp.w	r8,0
80002e86:	c0 b0       	breq	80002e9c <phy_rx_func+0x278>
80002e88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e8c:	58 38       	cp.w	r8,3
80002e8e:	e0 80 05 c5 	breq	80003a18 <phy_rx_func+0xdf4>
80002e92:	58 48       	cp.w	r8,4
80002e94:	e0 81 06 05 	brne	80003a9e <phy_rx_func+0xe7a>
80002e98:	e0 8f 02 4b 	bral	8000332e <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002e9c:	6e 28       	ld.w	r8,r7[0x8]
80002e9e:	e0 6a 5a 5a 	mov	r10,23130
80002ea2:	ea 1a ab cd 	orh	r10,0xabcd
80002ea6:	14 38       	cp.w	r8,r10
80002ea8:	c0 71       	brne	80002eb6 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002eaa:	30 09       	mov	r9,0
80002eac:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002eb0:	91 09       	st.w	r8[0x0],r9
80002eb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002eb6:	10 99       	mov	r9,r8
80002eb8:	e0 19 00 00 	andl	r9,0x0
80002ebc:	fc 1a ab cd 	movh	r10,0xabcd
80002ec0:	14 39       	cp.w	r9,r10
80002ec2:	e0 81 05 ee 	brne	80003a9e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002ec6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002eca:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ece:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ed0:	6e 29       	ld.w	r9,r7[0x8]
80002ed2:	e2 19 f0 00 	andl	r9,0xf000,COH
80002ed6:	e0 49 c0 00 	cp.w	r9,49152
80002eda:	e0 81 00 ce 	brne	80003076 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ede:	30 1a       	mov	r10,1
80002ee0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002ee4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002ee6:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002eea:	72 09       	ld.w	r9,r9[0x0]
80002eec:	58 09       	cp.w	r9,0
80002eee:	c0 71       	brne	80002efc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002ef0:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002ef4:	f0 1f 03 00 	mcall	80003af4 <phy_rx_func+0xed0>
80002ef8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002efc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f00:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f04:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f06:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f0a:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f0e:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f12:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f14:	13 89       	ld.ub	r9,r9[0x0]
80002f16:	37 fa       	mov	r10,127
80002f18:	f4 09 18 00 	cp.b	r9,r10
80002f1c:	c6 d0       	breq	80002ff6 <phy_rx_func+0x3d2>
80002f1e:	e0 8b 00 0c 	brhi	80002f36 <phy_rx_func+0x312>
80002f22:	31 2a       	mov	r10,18
80002f24:	f4 09 18 00 	cp.b	r9,r10
80002f28:	c4 20       	breq	80002fac <phy_rx_func+0x388>
80002f2a:	31 3a       	mov	r10,19
80002f2c:	f4 09 18 00 	cp.b	r9,r10
80002f30:	e0 81 00 83 	brne	80003036 <phy_rx_func+0x412>
80002f34:	c5 b8       	rjmp	80002fea <phy_rx_func+0x3c6>
80002f36:	2f 09       	sub	r9,-16
80002f38:	30 1a       	mov	r10,1
80002f3a:	f4 09 18 00 	cp.b	r9,r10
80002f3e:	e0 8b 00 7c 	brhi	80003036 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f42:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f46:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f4a:	59 08       	cp.w	r8,16
80002f4c:	c0 71       	brne	80002f5a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f4e:	30 19       	mov	r9,1
80002f50:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f54:	91 09       	st.w	r8[0x0],r9
80002f56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f5a:	e0 48 00 20 	cp.w	r8,32
80002f5e:	c2 11       	brne	80002fa0 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f60:	30 a9       	mov	r9,10
80002f62:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f66:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f68:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f6c:	6c 08       	ld.w	r8,r6[0x0]
80002f6e:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f72:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f76:	2f f8       	sub	r8,-1
80002f78:	6e 0c       	ld.w	r12,r7[0x0]
80002f7a:	f4 ca fe 00 	sub	r10,r10,-512
80002f7e:	30 0b       	mov	r11,0
80002f80:	10 0c       	add	r12,r8
80002f82:	f0 1f 02 e1 	mcall	80003b04 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f86:	30 08       	mov	r8,0
80002f88:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f8a:	6e 0c       	ld.w	r12,r7[0x0]
80002f8c:	f0 1f 02 df 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002f90:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002f94:	70 0c       	ld.w	r12,r8[0x0]
80002f96:	f0 1f 02 ca 	mcall	80003abc <phy_rx_func+0xe98>
80002f9a:	8f 0c       	st.w	r7[0x0],r12
80002f9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fa0:	30 09       	mov	r9,0
80002fa2:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fa6:	91 09       	st.w	r8[0x0],r9
80002fa8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fac:	20 48       	sub	r8,4
80002fae:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fb2:	93 08       	st.w	r9[0x0],r8
80002fb4:	58 08       	cp.w	r8,0
80002fb6:	e0 80 05 74 	breq	80003a9e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fba:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fbe:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fc2:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fc6:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fc8:	8e 69       	ld.sh	r9,r7[0xc]
80002fca:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fce:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fd0:	8e 79       	ld.sh	r9,r7[0xe]
80002fd2:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fd4:	f0 1f 02 d0 	mcall	80003b14 <phy_rx_func+0xef0>
80002fd8:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002fdc:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002fde:	30 49       	mov	r9,4
80002fe0:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002fe4:	91 09       	st.w	r8[0x0],r9
80002fe6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002fea:	30 09       	mov	r9,0
80002fec:	fe f8 0a f8 	ld.w	r8,pc[2808]
80002ff0:	91 09       	st.w	r8[0x0],r9
80002ff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002ff6:	20 48       	sub	r8,4
80002ff8:	fe f9 0a f0 	ld.w	r9,pc[2800]
80002ffc:	93 08       	st.w	r9[0x0],r8
80002ffe:	58 08       	cp.w	r8,0
80003000:	e0 80 05 4f 	breq	80003a9e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003004:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003008:	70 09       	ld.w	r9,r8[0x0]
8000300a:	8e 7b       	ld.sh	r11,r7[0xe]
8000300c:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003010:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003014:	2f f9       	sub	r9,-1
80003016:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003018:	fe f8 0a e4 	ld.w	r8,pc[2788]
8000301c:	70 09       	ld.w	r9,r8[0x0]
8000301e:	20 29       	sub	r9,2
80003020:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003022:	30 29       	mov	r9,2
80003024:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003028:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000302a:	30 39       	mov	r9,3
8000302c:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003030:	91 09       	st.w	r8[0x0],r9
80003032:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003036:	30 3a       	mov	r10,3
80003038:	fe f9 0a ac 	ld.w	r9,pc[2732]
8000303c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000303e:	6e 2a       	ld.w	r10,r7[0x8]
80003040:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003044:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003046:	6e 3a       	ld.w	r10,r7[0xc]
80003048:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000304a:	59 48       	cp.w	r8,20
8000304c:	c0 61       	brne	80003058 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000304e:	31 89       	mov	r9,24
80003050:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003054:	91 09       	st.w	r8[0x0],r9
80003056:	c0 a8       	rjmp	8000306a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003058:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	59 08       	cp.w	r8,16
80003060:	c0 51       	brne	8000306a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003062:	31 09       	mov	r9,16
80003064:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003068:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000306a:	30 49       	mov	r9,4
8000306c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003070:	91 09       	st.w	r8[0x0],r9
80003072:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003076:	e0 49 10 00 	cp.w	r9,4096
8000307a:	5f 1a       	srne	r10
8000307c:	e0 49 20 00 	cp.w	r9,8192
80003080:	5f 19       	srne	r9
80003082:	f5 e9 00 09 	and	r9,r10,r9
80003086:	e0 81 05 0c 	brne	80003a9e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000308a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000308e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003090:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003094:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003096:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000309a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000309c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030a0:	72 09       	ld.w	r9,r9[0x0]
800030a2:	58 09       	cp.w	r9,0
800030a4:	c0 71       	brne	800030b2 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030a6:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030aa:	f0 1f 02 93 	mcall	80003af4 <phy_rx_func+0xed0>
800030ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030b2:	6e 2a       	ld.w	r10,r7[0x8]
800030b4:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030b8:	58 1a       	cp.w	r10,1
800030ba:	e0 8b 00 4d 	brhi	80003154 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030be:	20 48       	sub	r8,4
800030c0:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030c4:	93 08       	st.w	r9[0x0],r8
800030c6:	58 08       	cp.w	r8,0
800030c8:	e0 80 04 eb 	breq	80003a9e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030cc:	8e 68       	ld.sh	r8,r7[0xc]
800030ce:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030d2:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030d6:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030d8:	30 09       	mov	r9,0
800030da:	f2 08 19 00 	cp.h	r8,r9
800030de:	c0 70       	breq	800030ec <phy_rx_func+0x4c8>
800030e0:	30 19       	mov	r9,1
800030e2:	f2 08 19 00 	cp.h	r8,r9
800030e6:	e0 81 04 dc 	brne	80003a9e <phy_rx_func+0xe7a>
800030ea:	c2 68       	rjmp	80003136 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800030ec:	fe f8 0a 44 	ld.w	r8,pc[2628]
800030f0:	70 0a       	ld.w	r10,r8[0x0]
800030f2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800030f6:	72 09       	ld.w	r9,r9[0x0]
800030f8:	8e 7b       	ld.sh	r11,r7[0xe]
800030fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800030fe:	70 09       	ld.w	r9,r8[0x0]
80003100:	2f f9       	sub	r9,-1
80003102:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003104:	e0 49 00 ff 	cp.w	r9,255
80003108:	e0 88 00 11 	brls	8000312a <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
8000310c:	30 09       	mov	r9,0
8000310e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003110:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003114:	6e 0c       	ld.w	r12,r7[0x0]
80003116:	f0 1f 02 7d 	mcall	80003b08 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000311a:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000311e:	70 0c       	ld.w	r12,r8[0x0]
80003120:	f0 1f 02 67 	mcall	80003abc <phy_rx_func+0xe98>
80003124:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003126:	e0 80 04 bc 	breq	80003a9e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000312a:	30 29       	mov	r9,2
8000312c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003136:	8e 79       	ld.sh	r9,r7[0xe]
80003138:	30 38       	mov	r8,3
8000313a:	f0 09 19 00 	cp.h	r9,r8
8000313e:	c0 51       	brne	80003148 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003140:	30 19       	mov	r9,1
80003142:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003146:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003148:	30 29       	mov	r9,2
8000314a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000314e:	91 09       	st.w	r8[0x0],r9
80003150:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003154:	58 18       	cp.w	r8,1
80003156:	e0 88 04 a4 	brls	80003a9e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000315a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000315e:	70 0a       	ld.w	r10,r8[0x0]
80003160:	6e 3b       	ld.w	r11,r7[0xc]
80003162:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003166:	70 09       	ld.w	r9,r8[0x0]
80003168:	2f f9       	sub	r9,-1
8000316a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000316c:	e0 49 00 ff 	cp.w	r9,255
80003170:	e0 88 00 11 	brls	80003192 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003174:	30 09       	mov	r9,0
80003176:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003178:	fe f7 09 60 	ld.w	r7,pc[2400]
8000317c:	6e 0c       	ld.w	r12,r7[0x0]
8000317e:	f0 1f 02 63 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003182:	fe f8 09 52 	ld.w	r8,pc[2386]
80003186:	70 0c       	ld.w	r12,r8[0x0]
80003188:	f0 1f 02 4d 	mcall	80003abc <phy_rx_func+0xe98>
8000318c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000318e:	e0 80 04 88 	breq	80003a9e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003192:	fe f9 09 56 	ld.w	r9,pc[2390]
80003196:	72 08       	ld.w	r8,r9[0x0]
80003198:	20 28       	sub	r8,2
8000319a:	93 08       	st.w	r9[0x0],r8
8000319c:	e0 80 04 81 	breq	80003a9e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031a0:	30 29       	mov	r9,2
800031a2:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031a6:	91 09       	st.w	r8[0x0],r9
800031a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031ac:	fe f8 09 84 	ld.w	r8,pc[2436]
800031b0:	70 0a       	ld.w	r10,r8[0x0]
800031b2:	fe f9 09 26 	ld.w	r9,pc[2342]
800031b6:	72 09       	ld.w	r9,r9[0x0]
800031b8:	8e 4b       	ld.sh	r11,r7[0x8]
800031ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031be:	70 09       	ld.w	r9,r8[0x0]
800031c0:	2f f9       	sub	r9,-1
800031c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031c4:	e0 49 00 ff 	cp.w	r9,255
800031c8:	e0 88 00 16 	brls	800031f4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031cc:	30 09       	mov	r9,0
800031ce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031d0:	fe f6 09 08 	ld.w	r6,pc[2312]
800031d4:	6c 0c       	ld.w	r12,r6[0x0]
800031d6:	f0 1f 02 4d 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031da:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031de:	70 0c       	ld.w	r12,r8[0x0]
800031e0:	f0 1f 02 37 	mcall	80003abc <phy_rx_func+0xe98>
800031e4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031e6:	c0 71       	brne	800031f4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031e8:	30 09       	mov	r9,0
800031ea:	fe f8 08 f6 	ld.w	r8,pc[2294]
800031ee:	91 09       	st.w	r8[0x0],r9
800031f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800031f4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800031f8:	72 08       	ld.w	r8,r9[0x0]
800031fa:	20 28       	sub	r8,2
800031fc:	93 08       	st.w	r9[0x0],r8
800031fe:	c0 71       	brne	8000320c <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003200:	30 09       	mov	r9,0
80003202:	fe f8 08 de 	ld.w	r8,pc[2270]
80003206:	91 09       	st.w	r8[0x0],r9
80003208:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000320c:	fe f8 09 24 	ld.w	r8,pc[2340]
80003210:	70 0a       	ld.w	r10,r8[0x0]
80003212:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003216:	72 09       	ld.w	r9,r9[0x0]
80003218:	8e 5b       	ld.sh	r11,r7[0xa]
8000321a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000321e:	70 09       	ld.w	r9,r8[0x0]
80003220:	2f f9       	sub	r9,-1
80003222:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003224:	e0 49 00 ff 	cp.w	r9,255
80003228:	e0 88 00 16 	brls	80003254 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
8000322c:	30 09       	mov	r9,0
8000322e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003230:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003234:	6c 0c       	ld.w	r12,r6[0x0]
80003236:	f0 1f 02 35 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000323a:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000323e:	70 0c       	ld.w	r12,r8[0x0]
80003240:	f0 1f 02 1f 	mcall	80003abc <phy_rx_func+0xe98>
80003244:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003246:	c0 71       	brne	80003254 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003248:	30 09       	mov	r9,0
8000324a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000324e:	91 09       	st.w	r8[0x0],r9
80003250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003254:	fe f9 08 94 	ld.w	r9,pc[2196]
80003258:	72 08       	ld.w	r8,r9[0x0]
8000325a:	20 28       	sub	r8,2
8000325c:	93 08       	st.w	r9[0x0],r8
8000325e:	c0 71       	brne	8000326c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003260:	30 09       	mov	r9,0
80003262:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003266:	91 09       	st.w	r8[0x0],r9
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000326c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003270:	70 0a       	ld.w	r10,r8[0x0]
80003272:	fe f9 08 66 	ld.w	r9,pc[2150]
80003276:	72 09       	ld.w	r9,r9[0x0]
80003278:	8e 6b       	ld.sh	r11,r7[0xc]
8000327a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000327e:	70 09       	ld.w	r9,r8[0x0]
80003280:	2f f9       	sub	r9,-1
80003282:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003284:	e0 49 00 ff 	cp.w	r9,255
80003288:	e0 88 00 16 	brls	800032b4 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000328c:	30 09       	mov	r9,0
8000328e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003290:	fe f6 08 48 	ld.w	r6,pc[2120]
80003294:	6c 0c       	ld.w	r12,r6[0x0]
80003296:	f0 1f 02 1d 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000329a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000329e:	70 0c       	ld.w	r12,r8[0x0]
800032a0:	f0 1f 02 07 	mcall	80003abc <phy_rx_func+0xe98>
800032a4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032a6:	c0 71       	brne	800032b4 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032a8:	30 09       	mov	r9,0
800032aa:	fe f8 08 36 	ld.w	r8,pc[2102]
800032ae:	91 09       	st.w	r8[0x0],r9
800032b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032b4:	fe f9 08 34 	ld.w	r9,pc[2100]
800032b8:	72 08       	ld.w	r8,r9[0x0]
800032ba:	20 28       	sub	r8,2
800032bc:	93 08       	st.w	r9[0x0],r8
800032be:	c0 71       	brne	800032cc <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032c0:	30 09       	mov	r9,0
800032c2:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032c6:	91 09       	st.w	r8[0x0],r9
800032c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032cc:	fe f8 08 64 	ld.w	r8,pc[2148]
800032d0:	70 0a       	ld.w	r10,r8[0x0]
800032d2:	fe f9 08 06 	ld.w	r9,pc[2054]
800032d6:	72 09       	ld.w	r9,r9[0x0]
800032d8:	8e 7b       	ld.sh	r11,r7[0xe]
800032da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032de:	70 09       	ld.w	r9,r8[0x0]
800032e0:	2f f9       	sub	r9,-1
800032e2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e4:	e0 49 00 ff 	cp.w	r9,255
800032e8:	e0 88 00 16 	brls	80003314 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800032ec:	30 09       	mov	r9,0
800032ee:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032f0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800032f4:	6e 0c       	ld.w	r12,r7[0x0]
800032f6:	f0 1f 02 05 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032fa:	fe f8 07 da 	ld.w	r8,pc[2010]
800032fe:	70 0c       	ld.w	r12,r8[0x0]
80003300:	f0 1f 01 ef 	mcall	80003abc <phy_rx_func+0xe98>
80003304:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003306:	c0 71       	brne	80003314 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003308:	30 09       	mov	r9,0
8000330a:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000330e:	91 09       	st.w	r8[0x0],r9
80003310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003314:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003318:	72 08       	ld.w	r8,r9[0x0]
8000331a:	20 28       	sub	r8,2
8000331c:	93 08       	st.w	r9[0x0],r8
8000331e:	e0 81 03 c0 	brne	80003a9e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003322:	30 09       	mov	r9,0
80003324:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003328:	91 09       	st.w	r8[0x0],r9
8000332a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000332e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003332:	11 89       	ld.ub	r9,r8[0x0]
80003334:	31 28       	mov	r8,18
80003336:	f0 09 18 00 	cp.b	r9,r8
8000333a:	e0 81 01 4c 	brne	800035d2 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000333e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003342:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003346:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003348:	11 89       	ld.ub	r9,r8[0x0]
8000334a:	3f 28       	mov	r8,-14
8000334c:	f0 09 18 00 	cp.b	r9,r8
80003350:	e0 81 01 3b 	brne	800035c6 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003354:	30 19       	mov	r9,1
80003356:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000335a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000335c:	6e 29       	ld.w	r9,r7[0x8]
8000335e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003362:	fe f8 07 86 	ld.w	r8,pc[1926]
80003366:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003368:	8e 59       	ld.sh	r9,r7[0xa]
8000336a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000336e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003370:	8e 69       	ld.sh	r9,r7[0xc]
80003372:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003374:	8e 79       	ld.sh	r9,r7[0xe]
80003376:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003378:	fe f8 07 88 	ld.w	r8,pc[1928]
8000337c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003380:	72 0a       	ld.w	r10,r9[0x0]
80003382:	70 09       	ld.w	r9,r8[0x0]
80003384:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003388:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000338c:	70 09       	ld.w	r9,r8[0x0]
8000338e:	2f f9       	sub	r9,-1
80003390:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003392:	e0 49 01 ff 	cp.w	r9,511
80003396:	e0 88 00 16 	brls	800033c2 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000339a:	30 09       	mov	r9,0
8000339c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000339e:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033a2:	6c 0c       	ld.w	r12,r6[0x0]
800033a4:	f0 1f 01 d9 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033a8:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033ac:	70 0c       	ld.w	r12,r8[0x0]
800033ae:	f0 1f 01 c4 	mcall	80003abc <phy_rx_func+0xe98>
800033b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033b4:	c0 71       	brne	800033c2 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033b6:	30 09       	mov	r9,0
800033b8:	fe f8 07 28 	ld.w	r8,pc[1832]
800033bc:	91 09       	st.w	r8[0x0],r9
800033be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033c2:	fe f9 07 26 	ld.w	r9,pc[1830]
800033c6:	72 08       	ld.w	r8,r9[0x0]
800033c8:	20 18       	sub	r8,1
800033ca:	93 08       	st.w	r9[0x0],r8
800033cc:	c0 71       	brne	800033da <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033ce:	30 09       	mov	r9,0
800033d0:	fe f8 07 10 	ld.w	r8,pc[1808]
800033d4:	91 09       	st.w	r8[0x0],r9
800033d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033da:	fe f8 07 26 	ld.w	r8,pc[1830]
800033de:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033e2:	72 0a       	ld.w	r10,r9[0x0]
800033e4:	70 09       	ld.w	r9,r8[0x0]
800033e6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033ee:	70 09       	ld.w	r9,r8[0x0]
800033f0:	2f f9       	sub	r9,-1
800033f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033f4:	e0 49 01 ff 	cp.w	r9,511
800033f8:	e0 88 00 16 	brls	80003424 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800033fc:	30 09       	mov	r9,0
800033fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003400:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003404:	6c 0c       	ld.w	r12,r6[0x0]
80003406:	f0 1f 01 c1 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000340a:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000340e:	70 0c       	ld.w	r12,r8[0x0]
80003410:	f0 1f 01 ab 	mcall	80003abc <phy_rx_func+0xe98>
80003414:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003416:	c0 71       	brne	80003424 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003418:	30 09       	mov	r9,0
8000341a:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003424:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003428:	72 08       	ld.w	r8,r9[0x0]
8000342a:	20 18       	sub	r8,1
8000342c:	93 08       	st.w	r9[0x0],r8
8000342e:	c0 71       	brne	8000343c <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003430:	30 09       	mov	r9,0
80003432:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003436:	91 09       	st.w	r8[0x0],r9
80003438:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000343c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003440:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003444:	72 0a       	ld.w	r10,r9[0x0]
80003446:	70 09       	ld.w	r9,r8[0x0]
80003448:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000344c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003450:	70 09       	ld.w	r9,r8[0x0]
80003452:	2f f9       	sub	r9,-1
80003454:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003456:	e0 49 01 ff 	cp.w	r9,511
8000345a:	e0 88 00 16 	brls	80003486 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000345e:	30 09       	mov	r9,0
80003460:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003462:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003466:	6c 0c       	ld.w	r12,r6[0x0]
80003468:	f0 1f 01 a8 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000346c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003470:	70 0c       	ld.w	r12,r8[0x0]
80003472:	f0 1f 01 93 	mcall	80003abc <phy_rx_func+0xe98>
80003476:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003478:	c0 71       	brne	80003486 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000347a:	30 09       	mov	r9,0
8000347c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003480:	91 09       	st.w	r8[0x0],r9
80003482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003486:	fe f9 06 62 	ld.w	r9,pc[1634]
8000348a:	72 08       	ld.w	r8,r9[0x0]
8000348c:	20 18       	sub	r8,1
8000348e:	93 08       	st.w	r9[0x0],r8
80003490:	c0 71       	brne	8000349e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003492:	30 09       	mov	r9,0
80003494:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003498:	91 09       	st.w	r8[0x0],r9
8000349a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000349e:	fe f8 06 62 	ld.w	r8,pc[1634]
800034a2:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034a6:	72 0a       	ld.w	r10,r9[0x0]
800034a8:	70 09       	ld.w	r9,r8[0x0]
800034aa:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034b2:	70 09       	ld.w	r9,r8[0x0]
800034b4:	2f f9       	sub	r9,-1
800034b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034b8:	e0 49 01 ff 	cp.w	r9,511
800034bc:	e0 88 00 16 	brls	800034e8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034c0:	30 09       	mov	r9,0
800034c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034c4:	fe f6 06 18 	ld.w	r6,pc[1560]
800034c8:	6c 0c       	ld.w	r12,r6[0x0]
800034ca:	f0 1f 01 90 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034ce:	fe f8 06 06 	ld.w	r8,pc[1542]
800034d2:	70 0c       	ld.w	r12,r8[0x0]
800034d4:	f0 1f 01 7a 	mcall	80003abc <phy_rx_func+0xe98>
800034d8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034da:	c0 71       	brne	800034e8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034dc:	30 09       	mov	r9,0
800034de:	fe f8 06 02 	ld.w	r8,pc[1538]
800034e2:	91 09       	st.w	r8[0x0],r9
800034e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034e8:	fe f9 06 00 	ld.w	r9,pc[1536]
800034ec:	72 08       	ld.w	r8,r9[0x0]
800034ee:	20 18       	sub	r8,1
800034f0:	93 08       	st.w	r9[0x0],r8
800034f2:	c0 71       	brne	80003500 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800034f4:	30 09       	mov	r9,0
800034f6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800034fa:	91 09       	st.w	r8[0x0],r9
800034fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003500:	fe f8 06 00 	ld.w	r8,pc[1536]
80003504:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003508:	72 0a       	ld.w	r10,r9[0x0]
8000350a:	70 09       	ld.w	r9,r8[0x0]
8000350c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003510:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003514:	70 09       	ld.w	r9,r8[0x0]
80003516:	2f f9       	sub	r9,-1
80003518:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000351a:	e0 49 01 ff 	cp.w	r9,511
8000351e:	e0 88 00 16 	brls	8000354a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003522:	30 09       	mov	r9,0
80003524:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003526:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000352a:	6c 0c       	ld.w	r12,r6[0x0]
8000352c:	f0 1f 01 77 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003530:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003534:	70 0c       	ld.w	r12,r8[0x0]
80003536:	f0 1f 01 62 	mcall	80003abc <phy_rx_func+0xe98>
8000353a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000353c:	c0 71       	brne	8000354a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000353e:	30 09       	mov	r9,0
80003540:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000354a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000354e:	72 08       	ld.w	r8,r9[0x0]
80003550:	20 18       	sub	r8,1
80003552:	93 08       	st.w	r9[0x0],r8
80003554:	c0 71       	brne	80003562 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003556:	30 09       	mov	r9,0
80003558:	fe f8 05 88 	ld.w	r8,pc[1416]
8000355c:	91 09       	st.w	r8[0x0],r9
8000355e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003562:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003566:	fe f9 05 76 	ld.w	r9,pc[1398]
8000356a:	72 0a       	ld.w	r10,r9[0x0]
8000356c:	70 09       	ld.w	r9,r8[0x0]
8000356e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003572:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003576:	70 09       	ld.w	r9,r8[0x0]
80003578:	2f f9       	sub	r9,-1
8000357a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000357c:	e0 49 01 ff 	cp.w	r9,511
80003580:	e0 88 00 16 	brls	800035ac <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003584:	30 09       	mov	r9,0
80003586:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003588:	fe f7 05 54 	ld.w	r7,pc[1364]
8000358c:	6e 0c       	ld.w	r12,r7[0x0]
8000358e:	f0 1f 01 5f 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003592:	fe f8 05 42 	ld.w	r8,pc[1346]
80003596:	70 0c       	ld.w	r12,r8[0x0]
80003598:	f0 1f 01 49 	mcall	80003abc <phy_rx_func+0xe98>
8000359c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000359e:	c0 71       	brne	800035ac <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035a0:	30 09       	mov	r9,0
800035a2:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035a6:	91 09       	st.w	r8[0x0],r9
800035a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035ac:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035b0:	72 08       	ld.w	r8,r9[0x0]
800035b2:	20 18       	sub	r8,1
800035b4:	93 08       	st.w	r9[0x0],r8
800035b6:	e0 81 02 74 	brne	80003a9e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035ba:	30 09       	mov	r9,0
800035bc:	fe f8 05 24 	ld.w	r8,pc[1316]
800035c0:	91 09       	st.w	r8[0x0],r9
800035c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035c6:	30 09       	mov	r9,0
800035c8:	fe f8 05 18 	ld.w	r8,pc[1304]
800035cc:	91 09       	st.w	r8[0x0],r9
800035ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035d2:	fe f8 05 26 	ld.w	r8,pc[1318]
800035d6:	11 89       	ld.ub	r9,r8[0x0]
800035d8:	3f 28       	mov	r8,-14
800035da:	f0 09 18 00 	cp.b	r9,r8
800035de:	c4 31       	brne	80003664 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035e0:	8e 49       	ld.sh	r9,r7[0x8]
800035e2:	fe f8 05 56 	ld.w	r8,pc[1366]
800035e6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035e8:	fe f8 05 18 	ld.w	r8,pc[1304]
800035ec:	fe f9 04 f0 	ld.w	r9,pc[1264]
800035f0:	72 0a       	ld.w	r10,r9[0x0]
800035f2:	70 09       	ld.w	r9,r8[0x0]
800035f4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800035f8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800035fc:	70 09       	ld.w	r9,r8[0x0]
800035fe:	2f f9       	sub	r9,-1
80003600:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003602:	e0 49 01 ff 	cp.w	r9,511
80003606:	e0 88 00 16 	brls	80003632 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000360a:	30 09       	mov	r9,0
8000360c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000360e:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003612:	6e 0c       	ld.w	r12,r7[0x0]
80003614:	f0 1f 01 3d 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003618:	fe f8 04 bc 	ld.w	r8,pc[1212]
8000361c:	70 0c       	ld.w	r12,r8[0x0]
8000361e:	f0 1f 01 28 	mcall	80003abc <phy_rx_func+0xe98>
80003622:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003624:	c0 71       	brne	80003632 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003626:	30 09       	mov	r9,0
80003628:	fe f8 04 b8 	ld.w	r8,pc[1208]
8000362c:	91 09       	st.w	r8[0x0],r9
8000362e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003632:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003636:	72 08       	ld.w	r8,r9[0x0]
80003638:	20 18       	sub	r8,1
8000363a:	93 08       	st.w	r9[0x0],r8
8000363c:	c0 71       	brne	8000364a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000363e:	30 09       	mov	r9,0
80003640:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003644:	91 09       	st.w	r8[0x0],r9
80003646:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000364a:	20 18       	sub	r8,1
8000364c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003650:	93 08       	st.w	r9[0x0],r8
80003652:	58 08       	cp.w	r8,0
80003654:	e0 81 02 25 	brne	80003a9e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003658:	30 09       	mov	r9,0
8000365a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000365e:	91 09       	st.w	r8[0x0],r9
80003660:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003664:	fe f8 04 94 	ld.w	r8,pc[1172]
80003668:	11 89       	ld.ub	r9,r8[0x0]
8000366a:	3f 38       	mov	r8,-13
8000366c:	f0 09 18 00 	cp.b	r9,r8
80003670:	e0 81 01 0c 	brne	80003888 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003674:	8e 49       	ld.sh	r9,r7[0x8]
80003676:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000367a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000367c:	8e 59       	ld.sh	r9,r7[0xa]
8000367e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003680:	8e 69       	ld.sh	r9,r7[0xc]
80003682:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003684:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003688:	fe f9 04 54 	ld.w	r9,pc[1108]
8000368c:	72 0a       	ld.w	r10,r9[0x0]
8000368e:	70 09       	ld.w	r9,r8[0x0]
80003690:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003694:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003698:	70 09       	ld.w	r9,r8[0x0]
8000369a:	2f f9       	sub	r9,-1
8000369c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000369e:	e0 49 01 ff 	cp.w	r9,511
800036a2:	e0 88 00 16 	brls	800036ce <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036a6:	30 09       	mov	r9,0
800036a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036aa:	fe f6 04 32 	ld.w	r6,pc[1074]
800036ae:	6c 0c       	ld.w	r12,r6[0x0]
800036b0:	f0 1f 01 16 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036b4:	fe f8 04 20 	ld.w	r8,pc[1056]
800036b8:	70 0c       	ld.w	r12,r8[0x0]
800036ba:	f0 1f 01 01 	mcall	80003abc <phy_rx_func+0xe98>
800036be:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036c0:	c0 71       	brne	800036ce <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036c2:	30 09       	mov	r9,0
800036c4:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036c8:	91 09       	st.w	r8[0x0],r9
800036ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036ce:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036d2:	72 08       	ld.w	r8,r9[0x0]
800036d4:	20 18       	sub	r8,1
800036d6:	93 08       	st.w	r9[0x0],r8
800036d8:	c0 71       	brne	800036e6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036da:	30 09       	mov	r9,0
800036dc:	fe f8 04 04 	ld.w	r8,pc[1028]
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036e6:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036ea:	fe f9 03 f2 	ld.w	r9,pc[1010]
800036ee:	72 0a       	ld.w	r10,r9[0x0]
800036f0:	70 09       	ld.w	r9,r8[0x0]
800036f2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800036f6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036fa:	70 09       	ld.w	r9,r8[0x0]
800036fc:	2f f9       	sub	r9,-1
800036fe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003700:	e0 49 01 ff 	cp.w	r9,511
80003704:	e0 88 00 16 	brls	80003730 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003708:	30 09       	mov	r9,0
8000370a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000370c:	fe f6 03 d0 	ld.w	r6,pc[976]
80003710:	6c 0c       	ld.w	r12,r6[0x0]
80003712:	f0 1f 00 fe 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003716:	fe f8 03 be 	ld.w	r8,pc[958]
8000371a:	70 0c       	ld.w	r12,r8[0x0]
8000371c:	f0 1f 00 e8 	mcall	80003abc <phy_rx_func+0xe98>
80003720:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003722:	c0 71       	brne	80003730 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003724:	30 09       	mov	r9,0
80003726:	fe f8 03 ba 	ld.w	r8,pc[954]
8000372a:	91 09       	st.w	r8[0x0],r9
8000372c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003730:	fe f9 03 b8 	ld.w	r9,pc[952]
80003734:	72 08       	ld.w	r8,r9[0x0]
80003736:	20 18       	sub	r8,1
80003738:	93 08       	st.w	r9[0x0],r8
8000373a:	c0 71       	brne	80003748 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
8000373c:	30 09       	mov	r9,0
8000373e:	fe f8 03 a2 	ld.w	r8,pc[930]
80003742:	91 09       	st.w	r8[0x0],r9
80003744:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003748:	fe f8 03 b8 	ld.w	r8,pc[952]
8000374c:	fe f9 03 90 	ld.w	r9,pc[912]
80003750:	72 0a       	ld.w	r10,r9[0x0]
80003752:	70 09       	ld.w	r9,r8[0x0]
80003754:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003758:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000375c:	70 09       	ld.w	r9,r8[0x0]
8000375e:	2f f9       	sub	r9,-1
80003760:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003762:	e0 49 01 ff 	cp.w	r9,511
80003766:	e0 88 00 16 	brls	80003792 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000376a:	30 09       	mov	r9,0
8000376c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000376e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003772:	6c 0c       	ld.w	r12,r6[0x0]
80003774:	f0 1f 00 e5 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003778:	fe f8 03 5c 	ld.w	r8,pc[860]
8000377c:	70 0c       	ld.w	r12,r8[0x0]
8000377e:	f0 1f 00 d0 	mcall	80003abc <phy_rx_func+0xe98>
80003782:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003784:	c0 71       	brne	80003792 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003786:	30 09       	mov	r9,0
80003788:	fe f8 03 58 	ld.w	r8,pc[856]
8000378c:	91 09       	st.w	r8[0x0],r9
8000378e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003792:	fe f9 03 56 	ld.w	r9,pc[854]
80003796:	72 08       	ld.w	r8,r9[0x0]
80003798:	20 18       	sub	r8,1
8000379a:	93 08       	st.w	r9[0x0],r8
8000379c:	c0 71       	brne	800037aa <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000379e:	30 09       	mov	r9,0
800037a0:	fe f8 03 40 	ld.w	r8,pc[832]
800037a4:	91 09       	st.w	r8[0x0],r9
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037aa:	fe f8 03 56 	ld.w	r8,pc[854]
800037ae:	fe f9 03 2e 	ld.w	r9,pc[814]
800037b2:	72 0a       	ld.w	r10,r9[0x0]
800037b4:	70 09       	ld.w	r9,r8[0x0]
800037b6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037ba:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037be:	70 09       	ld.w	r9,r8[0x0]
800037c0:	2f f9       	sub	r9,-1
800037c2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037c4:	e0 49 01 ff 	cp.w	r9,511
800037c8:	e0 88 00 16 	brls	800037f4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037cc:	30 09       	mov	r9,0
800037ce:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037d0:	fe f6 03 0c 	ld.w	r6,pc[780]
800037d4:	6c 0c       	ld.w	r12,r6[0x0]
800037d6:	f0 1f 00 cd 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037da:	fe f8 02 fa 	ld.w	r8,pc[762]
800037de:	70 0c       	ld.w	r12,r8[0x0]
800037e0:	f0 1f 00 b7 	mcall	80003abc <phy_rx_func+0xe98>
800037e4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037e6:	c0 71       	brne	800037f4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037e8:	30 09       	mov	r9,0
800037ea:	fe f8 02 f6 	ld.w	r8,pc[758]
800037ee:	91 09       	st.w	r8[0x0],r9
800037f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037f4:	fe f9 02 f4 	ld.w	r9,pc[756]
800037f8:	72 08       	ld.w	r8,r9[0x0]
800037fa:	20 18       	sub	r8,1
800037fc:	93 08       	st.w	r9[0x0],r8
800037fe:	c0 71       	brne	8000380c <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003800:	30 09       	mov	r9,0
80003802:	fe f8 02 de 	ld.w	r8,pc[734]
80003806:	91 09       	st.w	r8[0x0],r9
80003808:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
8000380c:	fe f8 02 f4 	ld.w	r8,pc[756]
80003810:	fe f9 02 cc 	ld.w	r9,pc[716]
80003814:	72 0a       	ld.w	r10,r9[0x0]
80003816:	70 09       	ld.w	r9,r8[0x0]
80003818:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000381c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	2f f9       	sub	r9,-1
80003824:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003826:	e0 49 01 ff 	cp.w	r9,511
8000382a:	e0 88 00 16 	brls	80003856 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000382e:	30 09       	mov	r9,0
80003830:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003832:	fe f7 02 aa 	ld.w	r7,pc[682]
80003836:	6e 0c       	ld.w	r12,r7[0x0]
80003838:	f0 1f 00 b4 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000383c:	fe f8 02 98 	ld.w	r8,pc[664]
80003840:	70 0c       	ld.w	r12,r8[0x0]
80003842:	f0 1f 00 9f 	mcall	80003abc <phy_rx_func+0xe98>
80003846:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003848:	c0 71       	brne	80003856 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000384a:	30 09       	mov	r9,0
8000384c:	fe f8 02 94 	ld.w	r8,pc[660]
80003850:	91 09       	st.w	r8[0x0],r9
80003852:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003856:	fe f9 02 92 	ld.w	r9,pc[658]
8000385a:	72 08       	ld.w	r8,r9[0x0]
8000385c:	20 18       	sub	r8,1
8000385e:	93 08       	st.w	r9[0x0],r8
80003860:	c0 71       	brne	8000386e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003862:	30 09       	mov	r9,0
80003864:	fe f8 02 7c 	ld.w	r8,pc[636]
80003868:	91 09       	st.w	r8[0x0],r9
8000386a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000386e:	20 18       	sub	r8,1
80003870:	fe f9 02 78 	ld.w	r9,pc[632]
80003874:	93 08       	st.w	r9[0x0],r8
80003876:	58 08       	cp.w	r8,0
80003878:	e0 81 01 13 	brne	80003a9e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000387c:	30 09       	mov	r9,0
8000387e:	fe f8 02 62 	ld.w	r8,pc[610]
80003882:	91 09       	st.w	r8[0x0],r9
80003884:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003888:	fe f8 02 70 	ld.w	r8,pc[624]
8000388c:	11 89       	ld.ub	r9,r8[0x0]
8000388e:	30 48       	mov	r8,4
80003890:	f0 09 18 00 	cp.b	r9,r8
80003894:	c0 80       	breq	800038a4 <phy_rx_func+0xc80>
80003896:	fe f8 02 62 	ld.w	r8,pc[610]
8000389a:	11 89       	ld.ub	r9,r8[0x0]
8000389c:	30 38       	mov	r8,3
8000389e:	f0 09 18 00 	cp.b	r9,r8
800038a2:	c1 41       	brne	800038ca <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038a4:	6e 29       	ld.w	r9,r7[0x8]
800038a6:	fe f8 02 7a 	ld.w	r8,pc[634]
800038aa:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038ac:	6e 39       	ld.w	r9,r7[0xc]
800038ae:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038b0:	fe f9 02 38 	ld.w	r9,pc[568]
800038b4:	72 08       	ld.w	r8,r9[0x0]
800038b6:	20 88       	sub	r8,8
800038b8:	93 08       	st.w	r9[0x0],r8
800038ba:	e0 81 00 f2 	brne	80003a9e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038be:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038c0:	fe f9 02 20 	ld.w	r9,pc[544]
800038c4:	93 08       	st.w	r9[0x0],r8
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038ca:	fe f8 02 2e 	ld.w	r8,pc[558]
800038ce:	11 89       	ld.ub	r9,r8[0x0]
800038d0:	31 38       	mov	r8,19
800038d2:	f0 09 18 00 	cp.b	r9,r8
800038d6:	e0 81 00 9c 	brne	80003a0e <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038da:	fe f8 02 62 	ld.w	r8,pc[610]
800038de:	11 88       	ld.ub	r8,r8[0x0]
800038e0:	30 c9       	mov	r9,12
800038e2:	f2 08 18 00 	cp.b	r8,r9
800038e6:	e0 81 00 7b 	brne	800039dc <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038ea:	8e 49       	ld.sh	r9,r7[0x8]
800038ec:	fe f8 02 54 	ld.w	r8,pc[596]
800038f0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800038f4:	30 09       	mov	r9,0
800038f6:	fe f8 02 46 	ld.w	r8,pc[582]
800038fa:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038fc:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003900:	3f 38       	mov	r8,-13
80003902:	f0 09 18 00 	cp.b	r9,r8
80003906:	c6 61       	brne	800039d2 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003908:	10 99       	mov	r9,r8
8000390a:	4f c8       	lddpc	r8,80003af8 <phy_rx_func+0xed4>
8000390c:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000390e:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003912:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003916:	4f 58       	lddpc	r8,80003ae8 <phy_rx_func+0xec4>
80003918:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000391a:	30 19       	mov	r9,1
8000391c:	fe f8 02 0c 	ld.w	r8,pc[524]
80003920:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003922:	8e 79       	ld.sh	r9,r7[0xe]
80003924:	fe f8 02 14 	ld.w	r8,pc[532]
80003928:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000392a:	4f 68       	lddpc	r8,80003b00 <phy_rx_func+0xedc>
8000392c:	4e c9       	lddpc	r9,80003adc <phy_rx_func+0xeb8>
8000392e:	72 0a       	ld.w	r10,r9[0x0]
80003930:	70 09       	ld.w	r9,r8[0x0]
80003932:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003936:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000393a:	70 09       	ld.w	r9,r8[0x0]
8000393c:	2f f9       	sub	r9,-1
8000393e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003940:	e0 49 01 ff 	cp.w	r9,511
80003944:	e0 88 00 13 	brls	8000396a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003948:	30 09       	mov	r9,0
8000394a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000394c:	4e 46       	lddpc	r6,80003adc <phy_rx_func+0xeb8>
8000394e:	6c 0c       	ld.w	r12,r6[0x0]
80003950:	f0 1f 00 6e 	mcall	80003b08 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003954:	4e 08       	lddpc	r8,80003ad4 <phy_rx_func+0xeb0>
80003956:	70 0c       	ld.w	r12,r8[0x0]
80003958:	f0 1f 00 59 	mcall	80003abc <phy_rx_func+0xe98>
8000395c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000395e:	c0 61       	brne	8000396a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003960:	30 09       	mov	r9,0
80003962:	4e 08       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000396a:	4e 09       	lddpc	r9,80003ae8 <phy_rx_func+0xec4>
8000396c:	72 08       	ld.w	r8,r9[0x0]
8000396e:	20 18       	sub	r8,1
80003970:	93 08       	st.w	r9[0x0],r8
80003972:	c0 61       	brne	8000397e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003974:	30 09       	mov	r9,0
80003976:	4d b8       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003978:	91 09       	st.w	r8[0x0],r9
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000397e:	4e 18       	lddpc	r8,80003b00 <phy_rx_func+0xedc>
80003980:	4d 79       	lddpc	r9,80003adc <phy_rx_func+0xeb8>
80003982:	72 0a       	ld.w	r10,r9[0x0]
80003984:	70 09       	ld.w	r9,r8[0x0]
80003986:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000398a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000398e:	70 09       	ld.w	r9,r8[0x0]
80003990:	2f f9       	sub	r9,-1
80003992:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003994:	e0 49 01 ff 	cp.w	r9,511
80003998:	e0 88 00 13 	brls	800039be <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000399c:	30 09       	mov	r9,0
8000399e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039a0:	4c f7       	lddpc	r7,80003adc <phy_rx_func+0xeb8>
800039a2:	6e 0c       	ld.w	r12,r7[0x0]
800039a4:	f0 1f 00 59 	mcall	80003b08 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039a8:	4c b8       	lddpc	r8,80003ad4 <phy_rx_func+0xeb0>
800039aa:	70 0c       	ld.w	r12,r8[0x0]
800039ac:	f0 1f 00 44 	mcall	80003abc <phy_rx_func+0xe98>
800039b0:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039b2:	c0 61       	brne	800039be <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039b4:	30 09       	mov	r9,0
800039b6:	4c b8       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039b8:	91 09       	st.w	r8[0x0],r9
800039ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039be:	4c b9       	lddpc	r9,80003ae8 <phy_rx_func+0xec4>
800039c0:	72 08       	ld.w	r8,r9[0x0]
800039c2:	20 18       	sub	r8,1
800039c4:	93 08       	st.w	r9[0x0],r8
800039c6:	c6 c1       	brne	80003a9e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039c8:	30 09       	mov	r9,0
800039ca:	4c 68       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039cc:	91 09       	st.w	r8[0x0],r9
800039ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039d2:	30 09       	mov	r9,0
800039d4:	4c 38       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039d6:	91 09       	st.w	r8[0x0],r9
800039d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039dc:	8e 4a       	ld.sh	r10,r7[0x8]
800039de:	4d 99       	lddpc	r9,80003b40 <phy_rx_func+0xf1c>
800039e0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039e4:	4d 6a       	lddpc	r10,80003b3c <phy_rx_func+0xf18>
800039e6:	15 88       	ld.ub	r8,r10[0x0]
800039e8:	f0 cb ff ff 	sub	r11,r8,-1
800039ec:	8e 5c       	ld.sh	r12,r7[0xa]
800039ee:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800039f2:	f0 cb ff fe 	sub	r11,r8,-2
800039f6:	8e 6c       	ld.sh	r12,r7[0xc]
800039f8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800039fc:	f0 cb ff fd 	sub	r11,r8,-3
80003a00:	8e 7c       	ld.sh	r12,r7[0xe]
80003a02:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a06:	2f c8       	sub	r8,-4
80003a08:	b4 88       	st.b	r10[0x0],r8
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	4b 48       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a12:	91 09       	st.w	r8[0x0],r9
80003a14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a18:	4c 08       	lddpc	r8,80003b18 <phy_rx_func+0xef4>
80003a1a:	70 09       	ld.w	r9,r8[0x0]
80003a1c:	8e 4b       	ld.sh	r11,r7[0x8]
80003a1e:	4c 0a       	lddpc	r10,80003b1c <phy_rx_func+0xef8>
80003a20:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a24:	2f f9       	sub	r9,-1
80003a26:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a28:	4b 58       	lddpc	r8,80003afc <phy_rx_func+0xed8>
80003a2a:	70 09       	ld.w	r9,r8[0x0]
80003a2c:	20 29       	sub	r9,2
80003a2e:	91 09       	st.w	r8[0x0],r9
80003a30:	70 08       	ld.w	r8,r8[0x0]
80003a32:	58 08       	cp.w	r8,0
80003a34:	c2 f1       	brne	80003a92 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a36:	30 09       	mov	r9,0
80003a38:	4b 88       	lddpc	r8,80003b18 <phy_rx_func+0xef4>
80003a3a:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a3c:	8e 59       	ld.sh	r9,r7[0xa]
80003a3e:	fe 78 82 12 	mov	r8,-32238
80003a42:	f0 09 19 00 	cp.h	r9,r8
80003a46:	c2 11       	brne	80003a88 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a48:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a4c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a50:	4a f8       	lddpc	r8,80003b0c <phy_rx_func+0xee8>
80003a52:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a54:	8e 59       	ld.sh	r9,r7[0xa]
80003a56:	4a f8       	lddpc	r8,80003b10 <phy_rx_func+0xeec>
80003a58:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a5a:	8e 69       	ld.sh	r9,r7[0xc]
80003a5c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a5e:	f0 1f 00 2e 	mcall	80003b14 <phy_rx_func+0xef0>
80003a62:	4a 18       	lddpc	r8,80003ae4 <phy_rx_func+0xec0>
80003a64:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a66:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a6a:	31 38       	mov	r8,19
80003a6c:	f0 09 18 00 	cp.b	r9,r8
80003a70:	c0 71       	brne	80003a7e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a72:	10 99       	mov	r9,r8
80003a74:	4a 18       	lddpc	r8,80003af8 <phy_rx_func+0xed4>
80003a76:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a78:	30 09       	mov	r9,0
80003a7a:	49 c8       	lddpc	r8,80003ae8 <phy_rx_func+0xec4>
80003a7c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a7e:	30 49       	mov	r9,4
80003a80:	49 88       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a82:	91 09       	st.w	r8[0x0],r9
80003a84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a88:	30 09       	mov	r9,0
80003a8a:	49 68       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a8c:	91 09       	st.w	r8[0x0],r9
80003a8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003a92:	4a dc       	lddpc	r12,80003b44 <phy_rx_func+0xf20>
80003a94:	f0 1f 00 18 	mcall	80003af4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003a98:	30 09       	mov	r9,0
80003a9a:	49 28       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a9c:	91 09       	st.w	r8[0x0],r9
80003a9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003aa2:	00 00       	add	r0,r0
80003aa4:	00 00       	add	r0,r0
80003aa6:	0a b4       	st.h	r5++,r4
80003aa8:	00 00       	add	r0,r0
80003aaa:	0a b8       	st.h	r5++,r8
80003aac:	00 00       	add	r0,r0
80003aae:	0a 9c       	mov	r12,r5
80003ab0:	00 00       	add	r0,r0
80003ab2:	0a 78       	tst	r8,r5
80003ab4:	00 00       	add	r0,r0
80003ab6:	0a 70       	tst	r0,r5
80003ab8:	00 00       	add	r0,r0
80003aba:	0a b0       	st.h	r5++,r0
80003abc:	80 00       	ld.sh	r0,r0[0x0]
80003abe:	2a 44       	sub	r4,-92
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a 84       	andn	r4,r5
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	29 74       	sub	r4,-105
80003ac8:	00 00       	add	r0,r0
80003aca:	0a 68       	and	r8,r5
80003acc:	80 00       	ld.sh	r0,r0[0x0]
80003ace:	29 90       	sub	r0,-103
80003ad0:	00 00       	add	r0,r0
80003ad2:	0a 81       	andn	r1,r5
80003ad4:	00 00       	add	r0,r0
80003ad6:	0a 6c       	and	r12,r5
80003ad8:	00 00       	add	r0,r0
80003ada:	0a 98       	mov	r8,r5
80003adc:	00 00       	add	r0,r0
80003ade:	0a 90       	mov	r0,r5
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a cc       	st.b	r5++,r12
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 64       	and	r4,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	0a 74       	tst	r4,r5
80003aec:	00 00       	add	r0,r0
80003aee:	0a 4f       	or	pc,r5
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	d0 f4       	*unknown*
80003af4:	80 00       	ld.sh	r0,r0[0x0]
80003af6:	6b 60       	ld.w	r0,r5[0x58]
80003af8:	00 00       	add	r0,r0
80003afa:	0a 80       	andn	r0,r5
80003afc:	00 00       	add	r0,r0
80003afe:	0a 8c       	andn	r12,r5
80003b00:	00 00       	add	r0,r0
80003b02:	0a a0       	st.w	r5++,r0
80003b04:	80 00       	ld.sh	r0,r0[0x0]
80003b06:	73 b0       	ld.w	r0,r9[0x6c]
80003b08:	80 00       	ld.sh	r0,r0[0x0]
80003b0a:	2b c4       	sub	r4,-68
80003b0c:	00 00       	add	r0,r0
80003b0e:	0a 42       	or	r2,r5
80003b10:	00 00       	add	r0,r0
80003b12:	0e 80       	andn	r0,r7
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	28 d4       	sub	r4,-115
80003b18:	00 00       	add	r0,r0
80003b1a:	0a bc       	st.h	r5++,r12
80003b1c:	00 00       	add	r0,r0
80003b1e:	0d 84       	ld.ub	r4,r6[0x0]
80003b20:	00 00       	add	r0,r0
80003b22:	0a d0       	st.w	--r5,r0
80003b24:	00 00       	add	r0,r0
80003b26:	0a 4e       	or	lr,r5
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 41       	or	r1,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a ac       	st.w	r5++,r12
80003b30:	00 00       	add	r0,r0
80003b32:	0a 94       	mov	r4,r5
80003b34:	00 00       	add	r0,r0
80003b36:	0a 53       	eor	r3,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	0d 7c       	ld.ub	r12,--r6
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a c4       	st.b	r5++,r4
80003b40:	00 00       	add	r0,r0
80003b42:	0e 84       	andn	r4,r7
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	d1 0c       	*unknown*

80003b48 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b48:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b4a:	49 88       	lddpc	r8,80003ba8 <pdca_int_handler+0x60>
80003b4c:	11 89       	ld.ub	r9,r8[0x0]
80003b4e:	ec 19 00 01 	eorl	r9,0x1
80003b52:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b54:	11 89       	ld.ub	r9,r8[0x0]
80003b56:	a5 69       	lsl	r9,0x4
80003b58:	2f c9       	sub	r9,-4
80003b5a:	49 5a       	lddpc	r10,80003bac <pdca_int_handler+0x64>
80003b5c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b5e:	fe 7a 00 40 	mov	r10,-65472
80003b62:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b64:	30 39       	mov	r9,3
80003b66:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b68:	11 8a       	ld.ub	r10,r8[0x0]
80003b6a:	a5 6a       	lsl	r10,0x4
80003b6c:	2f ca       	sub	r10,-4
80003b6e:	49 18       	lddpc	r8,80003bb0 <pdca_int_handler+0x68>
80003b70:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b72:	fe 78 00 00 	mov	r8,-65536
80003b76:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b78:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b7a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b7c:	48 e8       	lddpc	r8,80003bb4 <pdca_int_handler+0x6c>
80003b7e:	70 08       	ld.w	r8,r8[0x0]
80003b80:	58 08       	cp.w	r8,0
80003b82:	c0 70       	breq	80003b90 <pdca_int_handler+0x48>
80003b84:	48 99       	lddpc	r9,80003ba8 <pdca_int_handler+0x60>
80003b86:	13 89       	ld.ub	r9,r9[0x0]
80003b88:	a5 69       	lsl	r9,0x4
80003b8a:	48 ac       	lddpc	r12,80003bb0 <pdca_int_handler+0x68>
80003b8c:	12 0c       	add	r12,r9
80003b8e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003b90:	48 a8       	lddpc	r8,80003bb8 <pdca_int_handler+0x70>
80003b92:	70 08       	ld.w	r8,r8[0x0]
80003b94:	58 08       	cp.w	r8,0
80003b96:	c0 70       	breq	80003ba4 <pdca_int_handler+0x5c>
80003b98:	48 49       	lddpc	r9,80003ba8 <pdca_int_handler+0x60>
80003b9a:	13 89       	ld.ub	r9,r9[0x0]
80003b9c:	a5 69       	lsl	r9,0x4
80003b9e:	48 4c       	lddpc	r12,80003bac <pdca_int_handler+0x64>
80003ba0:	12 0c       	add	r12,r9
80003ba2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003ba4:	d4 02       	popm	lr
80003ba6:	d6 03       	rete
80003ba8:	00 00       	add	r0,r0
80003baa:	40 a4       	lddsp	r4,sp[0x28]
80003bac:	00 00       	add	r0,r0
80003bae:	40 cc       	lddsp	r12,sp[0x30]
80003bb0:	00 00       	add	r0,r0
80003bb2:	40 ac       	lddsp	r12,sp[0x28]
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a d8       	st.w	--r5,r8
80003bb8:	00 00       	add	r0,r0
80003bba:	0a dc       	st.w	--r5,r12

80003bbc <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bbc:	fe 78 10 00 	mov	r8,-61440
80003bc0:	e0 69 0d c0 	mov	r9,3520
80003bc4:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bc8:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bcc:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bd0:	fe 78 34 00 	mov	r8,-52224
80003bd4:	e0 69 80 00 	mov	r9,32768
80003bd8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003bda:	30 09       	mov	r9,0
80003bdc:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003bde:	e0 69 04 21 	mov	r9,1057
80003be2:	ea 19 3f 20 	orh	r9,0x3f20
80003be6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003be8:	e0 69 02 9f 	mov	r9,671
80003bec:	ea 19 01 00 	orh	r9,0x100
80003bf0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003bf2:	e0 6a 04 02 	mov	r10,1026
80003bf6:	ea 1a 3f 20 	orh	r10,0x3f20
80003bfa:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003bfc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003bfe:	5e fc       	retal	r12

80003c00 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c00:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c02:	30 19       	mov	r9,1
80003c04:	49 78       	lddpc	r8,80003c60 <local_start_PDC+0x60>
80003c06:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c08:	fe 78 00 00 	mov	r8,-65536
80003c0c:	30 7b       	mov	r11,7
80003c0e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c10:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c12:	49 59       	lddpc	r9,80003c64 <local_start_PDC+0x64>
80003c14:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c18:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c1a:	30 3a       	mov	r10,3
80003c1c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c1e:	30 1c       	mov	r12,1
80003c20:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c22:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c24:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c26:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c28:	30 2c       	mov	r12,2
80003c2a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c2c:	48 f9       	lddpc	r9,80003c68 <local_start_PDC+0x68>
80003c2e:	e0 68 5a 5a 	mov	r8,23130
80003c32:	ea 18 ab cd 	orh	r8,0xabcd
80003c36:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c38:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c3a:	30 0e       	mov	lr,0
80003c3c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c3e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c40:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c42:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c44:	fe 78 00 40 	mov	r8,-65472
80003c48:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c4a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c4c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c50:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c52:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c54:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c56:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c58:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c5a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c5c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c5e:	d8 02       	popm	pc
80003c60:	00 00       	add	r0,r0
80003c62:	40 a4       	lddsp	r4,sp[0x28]
80003c64:	00 00       	add	r0,r0
80003c66:	40 ac       	lddsp	r12,sp[0x28]
80003c68:	00 00       	add	r0,r0
80003c6a:	40 cc       	lddsp	r12,sp[0x30]

80003c6c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c6c:	48 38       	lddpc	r8,80003c78 <register_rx_tx_func+0xc>
80003c6e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c70:	48 38       	lddpc	r8,80003c7c <register_rx_tx_func+0x10>
80003c72:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c74:	5e fc       	retal	r12
80003c76:	00 00       	add	r0,r0
80003c78:	00 00       	add	r0,r0
80003c7a:	0a d8       	st.w	--r5,r8
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a dc       	st.w	--r5,r12

80003c80 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c80:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c82:	fe 78 10 00 	mov	r8,-61440
80003c86:	30 29       	mov	r9,2
80003c88:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c8c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003c90:	10 99       	mov	r9,r8
80003c92:	f2 f8 01 60 	ld.w	r8,r9[352]
80003c96:	e2 18 00 02 	andl	r8,0x2,COH
80003c9a:	cf c0       	breq	80003c92 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003c9c:	fe 79 10 00 	mov	r9,-61440
80003ca0:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ca4:	e2 18 00 02 	andl	r8,0x2,COH
80003ca8:	cf c1       	brne	80003ca0 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003caa:	30 3a       	mov	r10,3
80003cac:	36 0b       	mov	r11,96
80003cae:	48 bc       	lddpc	r12,80003cd8 <ssc_init+0x58>
80003cb0:	f0 1f 00 0b 	mcall	80003cdc <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003cb4:	f0 1f 00 0b 	mcall	80003ce0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003cb8:	f0 1f 00 0b 	mcall	80003ce4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cbc:	fe 79 00 00 	mov	r9,-65536
80003cc0:	30 18       	mov	r8,1
80003cc2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cc4:	fe 7a 00 40 	mov	r10,-65472
80003cc8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cca:	e0 6b 01 01 	mov	r11,257
80003cce:	fe 7a 34 00 	mov	r10,-52224
80003cd2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003cd4:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003cd6:	d8 02       	popm	pc
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	3b 48       	mov	r8,-76
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	51 9c       	stdsp	sp[0x64],r12
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	3b bc       	mov	r12,-69
80003ce4:	80 00       	ld.sh	r0,r0[0x0]
80003ce6:	3c 00       	mov	r0,-64

80003ce8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ce8:	48 28       	lddpc	r8,80003cf0 <xcmp_register_app_list+0x8>
80003cea:	91 0c       	st.w	r8[0x0],r12
}
80003cec:	5e fc       	retal	r12
80003cee:	00 00       	add	r0,r0
80003cf0:	00 00       	add	r0,r0
80003cf2:	40 ec       	lddsp	r12,sp[0x38]

80003cf4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003cf4:	eb cd 40 80 	pushm	r7,lr
80003cf8:	fa cd 01 00 	sub	sp,sp,256
80003cfc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003cfe:	16 98       	mov	r8,r11
80003d00:	2f 08       	sub	r8,-16
80003d02:	af a8       	sbr	r8,0xe
80003d04:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d06:	3f f8       	mov	r8,-1
80003d08:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d0a:	30 b9       	mov	r9,11
80003d0c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d0e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d10:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d12:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d14:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d16:	f6 ca ff fe 	sub	r10,r11,-2
80003d1a:	18 9b       	mov	r11,r12
80003d1c:	fa cc ff f0 	sub	r12,sp,-16
80003d20:	f0 1f 00 05 	mcall	80003d34 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d24:	2f e7       	sub	r7,-2
80003d26:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d28:	1a 9c       	mov	r12,sp
80003d2a:	f0 1f 00 04 	mcall	80003d38 <xcmp_tx+0x44>
}
80003d2e:	2c 0d       	sub	sp,-256
80003d30:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d34:	80 00       	ld.sh	r0,r0[0x0]
80003d36:	72 68       	ld.w	r8,r9[0x18]
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	43 00       	lddsp	r0,sp[0xc0]

80003d3c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d3c:	d4 21       	pushm	r4-r7,lr
80003d3e:	fa cd 00 d0 	sub	sp,sp,208
80003d42:	18 94       	mov	r4,r12
80003d44:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d46:	e0 68 01 00 	mov	r8,256
80003d4a:	f0 0b 19 00 	cp.h	r11,r8
80003d4e:	e0 8b 00 36 	brhi	80003dba <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d52:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d56:	e0 68 04 1d 	mov	r8,1053
80003d5a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003d5c:	30 18       	mov	r8,1
80003d5e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003d60:	32 08       	mov	r8,32
80003d62:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003d64:	30 28       	mov	r8,2
80003d66:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003d68:	30 48       	mov	r8,4
80003d6a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003d6c:	ea 1a 0c 00 	orh	r10,0xc00
80003d70:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003d72:	30 4a       	mov	r10,4
80003d74:	1a 9b       	mov	r11,sp
80003d76:	fa cc ff f4 	sub	r12,sp,-12
80003d7a:	f0 1f 00 12 	mcall	80003dc0 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003d7e:	30 f8       	mov	r8,15
80003d80:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003d84:	3a 78       	mov	r8,-89
80003d86:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003d8a:	30 08       	mov	r8,0
80003d8c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003d90:	0e 9a       	mov	r10,r7
80003d92:	5c 7a       	castu.h	r10
80003d94:	f4 08 16 08 	lsr	r8,r10,0x8
80003d98:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003d9c:	0e 96       	mov	r6,r7
80003d9e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003da2:	08 9b       	mov	r11,r4
80003da4:	fa cc ff eb 	sub	r12,sp,-21
80003da8:	f0 1f 00 06 	mcall	80003dc0 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003dac:	ee cb ff f3 	sub	r11,r7,-13
80003db0:	5c 5b       	castu.b	r11
80003db2:	fa cc ff fa 	sub	r12,sp,-6
80003db6:	f0 1f 00 04 	mcall	80003dc4 <xcmp_data_session_req+0x88>
}
80003dba:	2c cd       	sub	sp,-208
80003dbc:	d8 22       	popm	r4-r7,pc
80003dbe:	00 00       	add	r0,r0
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	72 68       	ld.w	r8,r9[0x18]
80003dc4:	80 00       	ld.sh	r0,r0[0x0]
80003dc6:	3c f4       	mov	r4,-49

80003dc8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003dc8:	d4 01       	pushm	lr
80003dca:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dce:	fe 78 b4 00 	mov	r8,-19456
80003dd2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003dd4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003dd8:	30 89       	mov	r9,8
80003dda:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ddc:	30 19       	mov	r9,1
80003dde:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003de0:	30 09       	mov	r9,0
80003de2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003de4:	30 5a       	mov	r10,5
80003de6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003de8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003dea:	30 7a       	mov	r10,7
80003dec:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003dee:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003df0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003df2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003df6:	30 9b       	mov	r11,9
80003df8:	fa cc ff fe 	sub	r12,sp,-2
80003dfc:	f0 1f 00 02 	mcall	80003e04 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e00:	2c dd       	sub	sp,-204
80003e02:	d8 02       	popm	pc
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	3c f4       	mov	r4,-49

80003e08 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e08:	d4 01       	pushm	lr
80003e0a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e0e:	fe 78 80 00 	mov	r8,-32768
80003e12:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e14:	30 38       	mov	r8,3
80003e16:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e18:	30 1b       	mov	r11,1
80003e1a:	fa cc ff fe 	sub	r12,sp,-2
80003e1e:	f0 1f 00 03 	mcall	80003e28 <xcmp_opcode_not_supported+0x20>
}
80003e22:	2c dd       	sub	sp,-204
80003e24:	d8 02       	popm	pc
80003e26:	00 00       	add	r0,r0
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	3c f4       	mov	r4,-49

80003e2c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e2c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e2e:	96 88       	ld.uh	r8,r11[0x0]
80003e30:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e34:	e0 48 80 00 	cp.w	r8,32768
80003e38:	c0 f0       	breq	80003e56 <xcmp_exec_func+0x2a>
80003e3a:	e0 48 b0 00 	cp.w	r8,45056
80003e3e:	c1 20       	breq	80003e62 <xcmp_exec_func+0x36>
80003e40:	58 08       	cp.w	r8,0
80003e42:	c1 51       	brne	80003e6c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e44:	78 08       	ld.w	r8,r12[0x0]
80003e46:	58 08       	cp.w	r8,0
80003e48:	c0 40       	breq	80003e50 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e4a:	16 9c       	mov	r12,r11
80003e4c:	5d 18       	icall	r8
80003e4e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e50:	f0 1f 00 08 	mcall	80003e70 <xcmp_exec_func+0x44>
80003e54:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e56:	78 18       	ld.w	r8,r12[0x4]
80003e58:	58 08       	cp.w	r8,0
80003e5a:	c0 90       	breq	80003e6c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e5c:	16 9c       	mov	r12,r11
80003e5e:	5d 18       	icall	r8
80003e60:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e62:	78 28       	ld.w	r8,r12[0x8]
80003e64:	58 08       	cp.w	r8,0
80003e66:	c0 30       	breq	80003e6c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e68:	16 9c       	mov	r12,r11
80003e6a:	5d 18       	icall	r8
80003e6c:	d8 02       	popm	pc
80003e6e:	00 00       	add	r0,r0
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	3e 08       	mov	r8,-32

80003e74 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
80003e74:	d4 01       	pushm	lr
80003e76:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003e7a:	e0 68 04 09 	mov	r8,1033
80003e7e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003e80:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003e84:	30 19       	mov	r9,1
80003e86:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
80003e88:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80003e8c:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
80003e8e:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003e90:	30 09       	mov	r9,0
80003e92:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003e94:	fb 69 00 08 	st.b	sp[8],r9
80003e98:	fa c8 ff f7 	sub	r8,sp,-9
80003e9c:	b0 89       	st.b	r8[0x0],r9
80003e9e:	fa c8 ff f6 	sub	r8,sp,-10
80003ea2:	b0 89       	st.b	r8[0x0],r9
80003ea4:	fa c8 ff f5 	sub	r8,sp,-11
80003ea8:	b0 89       	st.b	r8[0x0],r9
80003eaa:	fa c8 ff f4 	sub	r8,sp,-12
80003eae:	b0 89       	st.b	r8[0x0],r9
80003eb0:	fa c8 ff f3 	sub	r8,sp,-13
80003eb4:	b0 89       	st.b	r8[0x0],r9
80003eb6:	fa c8 ff f2 	sub	r8,sp,-14
80003eba:	b0 89       	st.b	r8[0x0],r9
80003ebc:	fa c8 ff f1 	sub	r8,sp,-15
80003ec0:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003ec2:	30 cb       	mov	r11,12
80003ec4:	fa cc ff fe 	sub	r12,sp,-2
80003ec8:	f0 1f 00 02 	mcall	80003ed0 <xcmp_IdleTestTone+0x5c>
}
80003ecc:	2c dd       	sub	sp,-204
80003ece:	d8 02       	popm	pc
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	3c f4       	mov	r4,-49

80003ed4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ed4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ed6:	48 dc       	lddpc	r12,80003f08 <xcmp_init+0x34>
80003ed8:	f0 1f 00 0d 	mcall	80003f0c <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003edc:	30 4b       	mov	r11,4
80003ede:	31 4c       	mov	r12,20
80003ee0:	f0 1f 00 0c 	mcall	80003f10 <xcmp_init+0x3c>
80003ee4:	48 c8       	lddpc	r8,80003f14 <xcmp_init+0x40>
80003ee6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ee8:	30 09       	mov	r9,0
80003eea:	1a d9       	st.w	--sp,r9
80003eec:	1a d9       	st.w	--sp,r9
80003eee:	1a d9       	st.w	--sp,r9
80003ef0:	30 38       	mov	r8,3
80003ef2:	e0 6a 01 80 	mov	r10,384
80003ef6:	48 9b       	lddpc	r11,80003f18 <xcmp_init+0x44>
80003ef8:	48 9c       	lddpc	r12,80003f1c <xcmp_init+0x48>
80003efa:	f0 1f 00 0a 	mcall	80003f20 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003efe:	f0 1f 00 0a 	mcall	80003f24 <xcmp_init+0x50>
80003f02:	2f dd       	sub	sp,-12
	
}
80003f04:	d8 02       	popm	pc
80003f06:	00 00       	add	r0,r0
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	40 24       	lddsp	r4,sp[0x8]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	40 70       	lddsp	r0,sp[0x1c]
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	5f 3c       	srlo	r12
80003f14:	00 00       	add	r0,r0
80003f16:	0a f8       	st.b	--r5,r8
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	d1 38       	*unknown*
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	3f 28       	mov	r8,-14
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	66 10       	ld.w	r0,r3[0x4]
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	40 a8       	lddsp	r8,sp[0x28]

80003f28 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f28:	d4 31       	pushm	r0-r7,lr
80003f2a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f2c:	4b 16       	lddpc	r6,80003ff0 <xcmp_rx_process+0xc8>
80003f2e:	30 05       	mov	r5,0
80003f30:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f32:	4b 13       	lddpc	r3,80003ff4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f34:	4b 12       	lddpc	r2,80003ff8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f36:	4b 21       	lddpc	r1,80003ffc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f38:	4b 20       	lddpc	r0,80004000 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f3a:	6c 0c       	ld.w	r12,r6[0x0]
80003f3c:	0a 99       	mov	r9,r5
80003f3e:	08 9a       	mov	r10,r4
80003f40:	1a 9b       	mov	r11,sp
80003f42:	f0 1f 00 31 	mcall	80004004 <xcmp_rx_process+0xdc>
80003f46:	58 1c       	cp.w	r12,1
80003f48:	cf 91       	brne	80003f3a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f4a:	40 0b       	lddsp	r11,sp[0x0]
80003f4c:	58 0b       	cp.w	r11,0
80003f4e:	cf 60       	breq	80003f3a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f50:	96 0a       	ld.sh	r10,r11[0x0]
80003f52:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f56:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f5a:	59 c8       	cp.w	r8,28
80003f5c:	c1 e0       	breq	80003f98 <xcmp_rx_process+0x70>
80003f5e:	e0 89 00 07 	brgt	80003f6c <xcmp_rx_process+0x44>
80003f62:	58 e8       	cp.w	r8,14
80003f64:	c0 e0       	breq	80003f80 <xcmp_rx_process+0x58>
80003f66:	58 f8       	cp.w	r8,15
80003f68:	c2 41       	brne	80003fb0 <xcmp_rx_process+0x88>
80003f6a:	c0 f8       	rjmp	80003f88 <xcmp_rx_process+0x60>
80003f6c:	e0 48 01 09 	cp.w	r8,265
80003f70:	c1 80       	breq	80003fa0 <xcmp_rx_process+0x78>
80003f72:	e0 48 01 0a 	cp.w	r8,266
80003f76:	c1 90       	breq	80003fa8 <xcmp_rx_process+0x80>
80003f78:	e0 48 00 2c 	cp.w	r8,44
80003f7c:	c1 a1       	brne	80003fb0 <xcmp_rx_process+0x88>
80003f7e:	c0 98       	rjmp	80003f90 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003f80:	4a 2c       	lddpc	r12,80004008 <xcmp_rx_process+0xe0>
80003f82:	f0 1f 00 23 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f86:	c2 f8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003f88:	4a 2c       	lddpc	r12,80004010 <xcmp_rx_process+0xe8>
80003f8a:	f0 1f 00 21 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f8e:	c2 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003f90:	4a 1c       	lddpc	r12,80004014 <xcmp_rx_process+0xec>
80003f92:	f0 1f 00 1f 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f96:	c2 78       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f98:	04 9c       	mov	r12,r2
80003f9a:	f0 1f 00 1d 	mcall	8000400c <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003f9e:	c2 38       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fa0:	02 9c       	mov	r12,r1
80003fa2:	f0 1f 00 1b 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003fa6:	c1 f8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fa8:	00 9c       	mov	r12,r0
80003faa:	f0 1f 00 19 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003fae:	c1 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fb0:	12 98       	mov	r8,r9
80003fb2:	e2 18 04 00 	andl	r8,0x400,COH
80003fb6:	c0 70       	breq	80003fc4 <xcmp_rx_process+0x9c>
80003fb8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fbc:	e0 48 00 68 	cp.w	r8,104
80003fc0:	e0 8a 00 08 	brle	80003fd0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003fc4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003fc8:	c0 e1       	brne	80003fe4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003fca:	f0 1f 00 14 	mcall	80004018 <xcmp_rx_process+0xf0>
80003fce:	c0 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003fd0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003fd4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003fd8:	49 19       	lddpc	r9,8000401c <xcmp_rx_process+0xf4>
80003fda:	72 08       	ld.w	r8,r9[0x0]
80003fdc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003fe0:	f0 1f 00 0b 	mcall	8000400c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003fe4:	66 0c       	ld.w	r12,r3[0x0]
80003fe6:	40 0b       	lddsp	r11,sp[0x0]
80003fe8:	f0 1f 00 0e 	mcall	80004020 <xcmp_rx_process+0xf8>
80003fec:	ca 7b       	rjmp	80003f3a <xcmp_rx_process+0x12>
80003fee:	00 00       	add	r0,r0
80003ff0:	00 00       	add	r0,r0
80003ff2:	0a f8       	st.b	--r5,r8
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a b0       	st.h	r5++,r0
80003ff8:	00 00       	add	r0,r0
80003ffa:	0b 08       	ld.w	r8,r5++
80003ffc:	00 00       	add	r0,r0
80003ffe:	0a fc       	st.b	--r5,r12
80004000:	00 00       	add	r0,r0
80004002:	0a ec       	st.h	--r5,r12
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	5c 30       	neg	r0
80004008:	00 00       	add	r0,r0
8000400a:	0b 20       	ld.uh	r0,r5++
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3e 2c       	mov	r12,-30
80004010:	00 00       	add	r0,r0
80004012:	0a e0       	st.h	--r5,r0
80004014:	00 00       	add	r0,r0
80004016:	0b 14       	ld.sh	r4,r5++
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	3e 08       	mov	r8,-32
8000401c:	00 00       	add	r0,r0
8000401e:	40 ec       	lddsp	r12,sp[0x38]
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	29 c8       	sub	r8,-100

80004024 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004024:	eb cd 40 90 	pushm	r4,r7,lr
80004028:	20 1d       	sub	sp,4
8000402a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000402e:	48 c8       	lddpc	r8,8000405c <xcmp_rx+0x38>
80004030:	70 0c       	ld.w	r12,r8[0x0]
80004032:	f0 1f 00 0c 	mcall	80004060 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004036:	c1 00       	breq	80004056 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004038:	fa c7 ff fc 	sub	r7,sp,-4
8000403c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000403e:	e0 6a 00 ca 	mov	r10,202
80004042:	08 9b       	mov	r11,r4
80004044:	f0 1f 00 08 	mcall	80004064 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004048:	48 88       	lddpc	r8,80004068 <xcmp_rx+0x44>
8000404a:	70 0c       	ld.w	r12,r8[0x0]
8000404c:	30 09       	mov	r9,0
8000404e:	12 9a       	mov	r10,r9
80004050:	1a 9b       	mov	r11,sp
80004052:	f0 1f 00 07 	mcall	8000406c <xcmp_rx+0x48>
	}	
}
80004056:	2f fd       	sub	sp,-4
80004058:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000405c:	00 00       	add	r0,r0
8000405e:	0a b0       	st.h	r5++,r0
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	2b 74       	sub	r4,-73
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	72 68       	ld.w	r8,r9[0x18]
80004068:	00 00       	add	r0,r0
8000406a:	0a f8       	st.b	--r5,r8
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	5e 3c       	retlo	r12

80004070 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004070:	48 28       	lddpc	r8,80004078 <xnl_register_xcmp_func+0x8>
80004072:	91 0c       	st.w	r8[0x0],r12
}
80004074:	5e fc       	retal	r12
80004076:	00 00       	add	r0,r0
80004078:	00 00       	add	r0,r0
8000407a:	0b 50       	ld.sh	r0,--r5

8000407c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000407c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000407e:	48 88       	lddpc	r8,8000409c <xnl_get_msg_ack_func+0x20>
80004080:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004082:	98 49       	ld.sh	r9,r12[0x8]
80004084:	f0 09 19 00 	cp.h	r9,r8
80004088:	c0 81       	brne	80004098 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000408a:	48 68       	lddpc	r8,800040a0 <xnl_get_msg_ack_func+0x24>
8000408c:	70 0c       	ld.w	r12,r8[0x0]
8000408e:	30 09       	mov	r9,0
80004090:	12 9a       	mov	r10,r9
80004092:	12 9b       	mov	r11,r9
80004094:	f0 1f 00 04 	mcall	800040a4 <xnl_get_msg_ack_func+0x28>
80004098:	d8 02       	popm	pc
8000409a:	00 00       	add	r0,r0
8000409c:	00 00       	add	r0,r0
8000409e:	0b 30       	ld.ub	r0,r5++
800040a0:	00 00       	add	r0,r0
800040a2:	0b 2c       	ld.uh	r12,r5++
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	5e 3c       	retlo	r12

800040a8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040a8:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040ac:	30 09       	mov	r9,0
800040ae:	4b 78       	lddpc	r8,80004188 <xnl_init+0xe0>
800040b0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040b2:	30 0b       	mov	r11,0
800040b4:	30 1c       	mov	r12,1
800040b6:	f0 1f 00 36 	mcall	8000418c <xnl_init+0xe4>
800040ba:	4b 68       	lddpc	r8,80004190 <xnl_init+0xe8>
800040bc:	91 0c       	st.w	r8[0x0],r12
800040be:	70 08       	ld.w	r8,r8[0x0]
800040c0:	58 08       	cp.w	r8,0
800040c2:	c0 80       	breq	800040d2 <xnl_init+0x2a>
800040c4:	4b 38       	lddpc	r8,80004190 <xnl_init+0xe8>
800040c6:	70 0c       	ld.w	r12,r8[0x0]
800040c8:	30 09       	mov	r9,0
800040ca:	12 9a       	mov	r10,r9
800040cc:	12 9b       	mov	r11,r9
800040ce:	f0 1f 00 32 	mcall	80004194 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800040d2:	30 4b       	mov	r11,4
800040d4:	31 4c       	mov	r12,20
800040d6:	f0 1f 00 2e 	mcall	8000418c <xnl_init+0xe4>
800040da:	4b 08       	lddpc	r8,80004198 <xnl_init+0xf0>
800040dc:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040de:	30 4b       	mov	r11,4
800040e0:	31 ec       	mov	r12,30
800040e2:	f0 1f 00 2b 	mcall	8000418c <xnl_init+0xe4>
800040e6:	4a e8       	lddpc	r8,8000419c <xnl_init+0xf4>
800040e8:	91 0c       	st.w	r8[0x0],r12
800040ea:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040ec:	10 96       	mov	r6,r8
800040ee:	4a d5       	lddpc	r5,800041a0 <xnl_init+0xf8>
800040f0:	6c 0c       	ld.w	r12,r6[0x0]
800040f2:	ea 07 00 0b 	add	r11,r5,r7
800040f6:	f0 1f 00 2c 	mcall	800041a4 <xnl_init+0xfc>
800040fa:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800040fe:	e0 47 1e 00 	cp.w	r7,7680
80004102:	cf 71       	brne	800040f0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004104:	30 4b       	mov	r11,4
80004106:	31 4c       	mov	r12,20
80004108:	f0 1f 00 21 	mcall	8000418c <xnl_init+0xe4>
8000410c:	4a 78       	lddpc	r8,800041a8 <xnl_init+0x100>
8000410e:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004110:	30 4b       	mov	r11,4
80004112:	30 ac       	mov	r12,10
80004114:	f0 1f 00 1e 	mcall	8000418c <xnl_init+0xe4>
80004118:	4a 58       	lddpc	r8,800041ac <xnl_init+0x104>
8000411a:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000411c:	30 4b       	mov	r11,4
8000411e:	30 ac       	mov	r12,10
80004120:	f0 1f 00 1b 	mcall	8000418c <xnl_init+0xe4>
80004124:	4a 38       	lddpc	r8,800041b0 <xnl_init+0x108>
80004126:	91 0c       	st.w	r8[0x0],r12
80004128:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000412a:	10 96       	mov	r6,r8
8000412c:	4a 25       	lddpc	r5,800041b4 <xnl_init+0x10c>
8000412e:	6c 0c       	ld.w	r12,r6[0x0]
80004130:	ea 07 00 0b 	add	r11,r5,r7
80004134:	f0 1f 00 1c 	mcall	800041a4 <xnl_init+0xfc>
80004138:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000413c:	e0 47 14 00 	cp.w	r7,5120
80004140:	cf 71       	brne	8000412e <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004142:	30 4b       	mov	r11,4
80004144:	30 5c       	mov	r12,5
80004146:	f0 1f 00 12 	mcall	8000418c <xnl_init+0xe4>
8000414a:	49 c8       	lddpc	r8,800041b8 <xnl_init+0x110>
8000414c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000414e:	30 07       	mov	r7,0
80004150:	1a d7       	st.w	--sp,r7
80004152:	1a d7       	st.w	--sp,r7
80004154:	1a d7       	st.w	--sp,r7
80004156:	30 38       	mov	r8,3
80004158:	0e 99       	mov	r9,r7
8000415a:	e0 6a 02 00 	mov	r10,512
8000415e:	49 8b       	lddpc	r11,800041bc <xnl_init+0x114>
80004160:	49 8c       	lddpc	r12,800041c0 <xnl_init+0x118>
80004162:	f0 1f 00 19 	mcall	800041c4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004166:	1a d7       	st.w	--sp,r7
80004168:	1a d7       	st.w	--sp,r7
8000416a:	1a d7       	st.w	--sp,r7
8000416c:	30 38       	mov	r8,3
8000416e:	0e 99       	mov	r9,r7
80004170:	e0 6a 03 20 	mov	r10,800
80004174:	49 5b       	lddpc	r11,800041c8 <xnl_init+0x120>
80004176:	49 6c       	lddpc	r12,800041cc <xnl_init+0x124>
80004178:	f0 1f 00 13 	mcall	800041c4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000417c:	f0 1f 00 15 	mcall	800041d0 <xnl_init+0x128>
80004180:	2f ad       	sub	sp,-24
}
80004182:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004186:	00 00       	add	r0,r0
80004188:	00 00       	add	r0,r0
8000418a:	0b 30       	ld.ub	r0,r5++
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	5f 3c       	srlo	r12
80004190:	00 00       	add	r0,r0
80004192:	0b 2c       	ld.uh	r12,r5++
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	5e 3c       	retlo	r12
80004198:	00 00       	add	r0,r0
8000419a:	0b 3c       	ld.ub	r12,r5++
8000419c:	00 00       	add	r0,r0
8000419e:	0a b0       	st.h	r5++,r0
800041a0:	00 00       	add	r0,r0
800041a2:	22 9e       	sub	lr,41
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	29 c8       	sub	r8,-100
800041a8:	00 00       	add	r0,r0
800041aa:	0a c0       	st.b	r5++,r0
800041ac:	00 00       	add	r0,r0
800041ae:	0a b4       	st.h	r5++,r4
800041b0:	00 00       	add	r0,r0
800041b2:	0a 6c       	and	r12,r5
800041b4:	00 00       	add	r0,r0
800041b6:	0e 9e       	mov	lr,r7
800041b8:	00 00       	add	r0,r0
800041ba:	0a 88       	andn	r8,r5
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	d1 40       	acall	0x14
800041c0:	80 00       	ld.sh	r0,r0[0x0]
800041c2:	41 d4       	lddsp	r4,sp[0x74]
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	66 10       	ld.w	r0,r3[0x4]
800041c8:	80 00       	ld.sh	r0,r0[0x0]
800041ca:	ca 00       	breq	8000410a <xnl_init+0x62>
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	42 34       	lddsp	r4,sp[0x8c]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	2b 9c       	sub	r12,-71

800041d4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041d4:	eb cd 40 fe 	pushm	r1-r7,lr
800041d8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041da:	49 26       	lddpc	r6,80004220 <xnl_rx_process+0x4c>
800041dc:	30 05       	mov	r5,0
800041de:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041e0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041e2:	49 11       	lddpc	r1,80004224 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041e4:	49 12       	lddpc	r2,80004228 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041e6:	6c 0c       	ld.w	r12,r6[0x0]
800041e8:	0a 99       	mov	r9,r5
800041ea:	08 9a       	mov	r10,r4
800041ec:	1a 9b       	mov	r11,sp
800041ee:	f0 1f 00 10 	mcall	8000422c <xnl_rx_process+0x58>
800041f2:	58 1c       	cp.w	r12,1
800041f4:	cf 91       	brne	800041e6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800041f6:	40 0c       	lddsp	r12,sp[0x0]
800041f8:	58 0c       	cp.w	r12,0
800041fa:	cf 60       	breq	800041e6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041fc:	98 28       	ld.sh	r8,r12[0x4]
800041fe:	e6 08 19 00 	cp.h	r8,r3
80004202:	e0 8b 00 0a 	brhi	80004216 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004206:	5c 78       	castu.h	r8
80004208:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000420c:	58 09       	cp.w	r9,0
8000420e:	c0 40       	breq	80004216 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004210:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004214:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004216:	62 0c       	ld.w	r12,r1[0x0]
80004218:	40 0b       	lddsp	r11,sp[0x0]
8000421a:	f0 1f 00 06 	mcall	80004230 <xnl_rx_process+0x5c>
8000421e:	ce 4b       	rjmp	800041e6 <xnl_rx_process+0x12>
80004220:	00 00       	add	r0,r0
80004222:	0a b4       	st.h	r5++,r4
80004224:	00 00       	add	r0,r0
80004226:	0a b0       	st.h	r5++,r0
80004228:	00 00       	add	r0,r0
8000422a:	04 f0       	st.b	--r2,r0
8000422c:	80 00       	ld.sh	r0,r0[0x0]
8000422e:	5c 30       	neg	r0
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	29 c8       	sub	r8,-100

80004234 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004234:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004236:	4a a6       	lddpc	r6,800042dc <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004238:	4a a2       	lddpc	r2,800042e0 <xnl_tx_process+0xac>
8000423a:	4a b4       	lddpc	r4,800042e4 <xnl_tx_process+0xb0>
8000423c:	30 07       	mov	r7,0
8000423e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004240:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004242:	4a a5       	lddpc	r5,800042e8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004244:	4a a3       	lddpc	r3,800042ec <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004246:	6c 08       	ld.w	r8,r6[0x0]
80004248:	58 08       	cp.w	r8,0
8000424a:	c0 40       	breq	80004252 <xnl_tx_process+0x1e>
8000424c:	58 18       	cp.w	r8,1
8000424e:	cf d1       	brne	80004248 <xnl_tx_process+0x14>
80004250:	c2 48       	rjmp	80004298 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004252:	64 0c       	ld.w	r12,r2[0x0]
80004254:	0e 99       	mov	r9,r7
80004256:	02 9a       	mov	r10,r1
80004258:	08 9b       	mov	r11,r4
8000425a:	f0 1f 00 26 	mcall	800042f0 <xnl_tx_process+0xbc>
8000425e:	58 1c       	cp.w	r12,1
80004260:	cf 31       	brne	80004246 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004262:	68 0b       	ld.w	r11,r4[0x0]
80004264:	58 0b       	cp.w	r11,0
80004266:	cf 00       	breq	80004246 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004268:	96 28       	ld.sh	r8,r11[0x4]
8000426a:	e0 08 19 00 	cp.h	r8,r0
8000426e:	c0 71       	brne	8000427c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004270:	4a 18       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
80004272:	70 08       	ld.w	r8,r8[0x0]
80004274:	10 9c       	mov	r12,r8
80004276:	f0 1f 00 21 	mcall	800042f8 <xnl_tx_process+0xc4>
						break;
8000427a:	ce 6b       	rjmp	80004246 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000427c:	16 9c       	mov	r12,r11
8000427e:	f0 1f 00 20 	mcall	800042fc <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004282:	30 18       	mov	r8,1
80004284:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004286:	66 0c       	ld.w	r12,r3[0x0]
80004288:	0e 99       	mov	r9,r7
8000428a:	0e 9a       	mov	r10,r7
8000428c:	0e 9b       	mov	r11,r7
8000428e:	f0 1f 00 19 	mcall	800042f0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004292:	30 18       	mov	r8,1
80004294:	8d 08       	st.w	r6[0x0],r8
80004296:	cd 8b       	rjmp	80004246 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004298:	66 0c       	ld.w	r12,r3[0x0]
8000429a:	0e 99       	mov	r9,r7
8000429c:	36 4a       	mov	r10,100
8000429e:	0e 9b       	mov	r11,r7
800042a0:	f0 1f 00 14 	mcall	800042f0 <xnl_tx_process+0xbc>
800042a4:	58 1c       	cp.w	r12,1
800042a6:	c0 81       	brne	800042b6 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042a8:	49 38       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
800042aa:	70 0c       	ld.w	r12,r8[0x0]
800042ac:	68 0b       	ld.w	r11,r4[0x0]
800042ae:	f0 1f 00 13 	mcall	800042f8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042b2:	8d 07       	st.w	r6[0x0],r7
800042b4:	cc 9b       	rjmp	80004246 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042b6:	6a 08       	ld.w	r8,r5[0x0]
800042b8:	58 38       	cp.w	r8,3
800042ba:	e0 89 00 09 	brgt	800042cc <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042be:	68 0c       	ld.w	r12,r4[0x0]
800042c0:	f0 1f 00 0f 	mcall	800042fc <xnl_tx_process+0xc8>
						xnl_send_times++;
800042c4:	6a 08       	ld.w	r8,r5[0x0]
800042c6:	2f f8       	sub	r8,-1
800042c8:	8b 08       	st.w	r5[0x0],r8
800042ca:	cb eb       	rjmp	80004246 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042cc:	48 a8       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
800042ce:	70 0c       	ld.w	r12,r8[0x0]
800042d0:	68 0b       	ld.w	r11,r4[0x0]
800042d2:	f0 1f 00 0a 	mcall	800042f8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042d6:	8d 07       	st.w	r6[0x0],r7
800042d8:	cb 7b       	rjmp	80004246 <xnl_tx_process+0x12>
800042da:	00 00       	add	r0,r0
800042dc:	00 00       	add	r0,r0
800042de:	0b 4c       	ld.w	r12,--r5
800042e0:	00 00       	add	r0,r0
800042e2:	0b 3c       	ld.ub	r12,r5++
800042e4:	00 00       	add	r0,r0
800042e6:	0b 44       	ld.w	r4,--r5
800042e8:	00 00       	add	r0,r0
800042ea:	0b 40       	ld.w	r0,--r5
800042ec:	00 00       	add	r0,r0
800042ee:	0b 2c       	ld.uh	r12,r5++
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	5c 30       	neg	r0
800042f4:	00 00       	add	r0,r0
800042f6:	0a b0       	st.h	r5++,r0
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	29 c8       	sub	r8,-100
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	29 e8       	sub	r8,-98

80004300 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004300:	eb cd 40 c0 	pushm	r6-r7,lr
80004304:	20 1d       	sub	sp,4
80004306:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004308:	98 39       	ld.sh	r9,r12[0x6]
8000430a:	3f f8       	mov	r8,-1
8000430c:	f0 09 19 00 	cp.h	r9,r8
80004310:	c0 a1       	brne	80004324 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004312:	4a e9       	lddpc	r9,800043c8 <xnl_tx+0xc8>
80004314:	13 88       	ld.ub	r8,r9[0x0]
80004316:	2f f8       	sub	r8,-1
80004318:	5c 58       	castu.b	r8
8000431a:	b2 88       	st.b	r9[0x0],r8
8000431c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004320:	a9 a8       	sbr	r8,0x8
80004322:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004324:	8c 49       	ld.sh	r9,r6[0x8]
80004326:	3f f8       	mov	r8,-1
80004328:	f0 09 19 00 	cp.h	r9,r8
8000432c:	c0 41       	brne	80004334 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000432e:	4a 88       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004330:	90 18       	ld.sh	r8,r8[0x2]
80004332:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004334:	8c 59       	ld.sh	r9,r6[0xa]
80004336:	3f f8       	mov	r8,-1
80004338:	f0 09 19 00 	cp.h	r9,r8
8000433c:	c0 41       	brne	80004344 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000433e:	4a 48       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004340:	90 28       	ld.sh	r8,r8[0x4]
80004342:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004344:	8c 69       	ld.sh	r9,r6[0xc]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 e1       	brne	80004368 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000434e:	4a 08       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004350:	90 49       	ld.sh	r9,r8[0x8]
80004352:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004354:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004356:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004358:	90 49       	ld.sh	r9,r8[0x8]
8000435a:	e0 19 ff 00 	andl	r9,0xff00
8000435e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004362:	f3 e8 10 08 	or	r8,r9,r8
80004366:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004368:	0d 98       	ld.ub	r8,r6[0x1]
8000436a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000436c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004370:	10 0c       	add	r12,r8
80004372:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004374:	58 0c       	cp.w	r12,0
80004376:	e0 89 00 04 	brgt	8000437e <xnl_tx+0x7e>
8000437a:	30 09       	mov	r9,0
8000437c:	c0 d8       	rjmp	80004396 <xnl_tx+0x96>
8000437e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004382:	2f ec       	sub	r12,-2
80004384:	30 09       	mov	r9,0
80004386:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004388:	15 1b       	ld.sh	r11,r10++
8000438a:	f6 09 00 09 	add	r9,r11,r9
8000438e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004390:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004392:	18 38       	cp.w	r8,r12
80004394:	cf a1       	brne	80004388 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004396:	5c 39       	neg	r9
80004398:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000439a:	48 e8       	lddpc	r8,800043d0 <xnl_tx+0xd0>
8000439c:	70 0c       	ld.w	r12,r8[0x0]
8000439e:	f0 1f 00 0e 	mcall	800043d4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043a2:	c1 00       	breq	800043c2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043a4:	fa c7 ff fc 	sub	r7,sp,-4
800043a8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043aa:	e0 6a 01 00 	mov	r10,256
800043ae:	0c 9b       	mov	r11,r6
800043b0:	f0 1f 00 0a 	mcall	800043d8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043b4:	48 a8       	lddpc	r8,800043dc <xnl_tx+0xdc>
800043b6:	70 0c       	ld.w	r12,r8[0x0]
800043b8:	30 09       	mov	r9,0
800043ba:	12 9a       	mov	r10,r9
800043bc:	1a 9b       	mov	r11,sp
800043be:	f0 1f 00 09 	mcall	800043e0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043c2:	2f fd       	sub	sp,-4
800043c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043c8:	00 00       	add	r0,r0
800043ca:	0b 48       	ld.w	r8,--r5
800043cc:	00 00       	add	r0,r0
800043ce:	0b 30       	ld.ub	r0,r5++
800043d0:	00 00       	add	r0,r0
800043d2:	0a b0       	st.h	r5++,r0
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	2b 74       	sub	r4,-73
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	72 68       	ld.w	r8,r9[0x18]
800043dc:	00 00       	add	r0,r0
800043de:	0b 3c       	ld.ub	r12,r5++
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	5e 3c       	retlo	r12

800043e4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800043e4:	eb cd 40 80 	pushm	r7,lr
800043e8:	fa cd 01 00 	sub	sp,sp,256
800043ec:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800043ee:	e0 68 40 0e 	mov	r8,16398
800043f2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800043f4:	3f f8       	mov	r8,-1
800043f6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800043f8:	30 c8       	mov	r8,12
800043fa:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800043fc:	98 38       	ld.sh	r8,r12[0x6]
800043fe:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004400:	98 58       	ld.sh	r8,r12[0xa]
80004402:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004404:	98 48       	ld.sh	r8,r12[0x8]
80004406:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004408:	98 68       	ld.sh	r8,r12[0xc]
8000440a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000440c:	30 08       	mov	r8,0
8000440e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004410:	1a 9c       	mov	r12,sp
80004412:	f0 1f 00 0a 	mcall	80004438 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004416:	fa cd 00 cc 	sub	sp,sp,204
8000441a:	e0 6a 00 ca 	mov	r10,202
8000441e:	ee cb ff f0 	sub	r11,r7,-16
80004422:	1a 9c       	mov	r12,sp
80004424:	f0 1f 00 06 	mcall	8000443c <xnl_data_msg_func+0x58>
80004428:	48 68       	lddpc	r8,80004440 <xnl_data_msg_func+0x5c>
8000442a:	70 08       	ld.w	r8,r8[0x0]
8000442c:	5d 18       	icall	r8
8000442e:	fa cd ff 34 	sub	sp,sp,-204
}
80004432:	2c 0d       	sub	sp,-256
80004434:	e3 cd 80 80 	ldm	sp++,r7,pc
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	43 00       	lddsp	r0,sp[0xc0]
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	72 68       	ld.w	r8,r9[0x18]
80004440:	00 00       	add	r0,r0
80004442:	0b 50       	ld.sh	r0,--r5

80004444 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004444:	d4 21       	pushm	r4-r7,lr
80004446:	fa cd 01 00 	sub	sp,sp,256
8000444a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000444c:	4c 28       	lddpc	r8,80004554 <xnl_device_auth_reply_func+0x110>
8000444e:	11 88       	ld.ub	r8,r8[0x0]
80004450:	58 08       	cp.w	r8,0
80004452:	e0 81 00 7f 	brne	80004550 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004456:	4c 18       	lddpc	r8,80004558 <xnl_device_auth_reply_func+0x114>
80004458:	70 0c       	ld.w	r12,r8[0x0]
8000445a:	30 09       	mov	r9,0
8000445c:	12 9a       	mov	r10,r9
8000445e:	12 9b       	mov	r11,r9
80004460:	f0 1f 00 3f 	mcall	8000455c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004464:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004468:	4b b8       	lddpc	r8,80004554 <xnl_device_auth_reply_func+0x110>
8000446a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000446c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004470:	ef 38 00 13 	ld.ub	r8,r7[19]
80004474:	b1 68       	lsl	r8,0x10
80004476:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000447a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000447e:	f3 e8 10 08 	or	r8,r9,r8
80004482:	ef 39 00 14 	ld.ub	r9,r7[20]
80004486:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000448a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000448e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004492:	b1 68       	lsl	r8,0x10
80004494:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004498:	ef 38 00 19 	ld.ub	r8,r7[25]
8000449c:	f5 e8 10 08 	or	r8,r10,r8
800044a0:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044a4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044a8:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044aa:	e0 64 79 b9 	mov	r4,31161
800044ae:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044b2:	e0 65 45 07 	mov	r5,17671
800044b6:	ea 15 8a bd 	orh	r5,0x8abd
800044ba:	e0 66 f9 3d 	mov	r6,63805
800044be:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044c2:	e0 6e b8 cf 	mov	lr,47311
800044c6:	ea 1e 36 83 	orh	lr,0x3683
800044ca:	e0 67 aa 1c 	mov	r7,43548
800044ce:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044d2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044d4:	f4 08 00 0c 	add	r12,r10,r8
800044d8:	f0 0b 15 04 	lsl	r11,r8,0x4
800044dc:	0a 0b       	add	r11,r5
800044de:	f9 eb 20 0b 	eor	r11,r12,r11
800044e2:	f0 0c 16 05 	lsr	r12,r8,0x5
800044e6:	0c 0c       	add	r12,r6
800044e8:	18 5b       	eor	r11,r12
800044ea:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044ec:	f2 0c 15 04 	lsl	r12,r9,0x4
800044f0:	1c 0c       	add	r12,lr
800044f2:	f2 0b 16 05 	lsr	r11,r9,0x5
800044f6:	0e 0b       	add	r11,r7
800044f8:	f9 eb 20 0b 	eor	r11,r12,r11
800044fc:	f2 0a 00 0c 	add	r12,r9,r10
80004500:	18 5b       	eor	r11,r12
80004502:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004504:	e0 6b 37 20 	mov	r11,14112
80004508:	ea 1b c6 ef 	orh	r11,0xc6ef
8000450c:	16 3a       	cp.w	r10,r11
8000450e:	ce 21       	brne	800044d2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004510:	e0 6a 40 1a 	mov	r10,16410
80004514:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004516:	3f fa       	mov	r10,-1
80004518:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000451a:	30 6b       	mov	r11,6
8000451c:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000451e:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004520:	48 db       	lddpc	r11,80004554 <xnl_device_auth_reply_func+0x110>
80004522:	96 1c       	ld.sh	r12,r11[0x2]
80004524:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004526:	96 2b       	ld.sh	r11,r11[0x4]
80004528:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000452a:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000452c:	30 ca       	mov	r10,12
8000452e:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004530:	30 0a       	mov	r10,0
80004532:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004536:	30 7a       	mov	r10,7
80004538:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000453c:	30 2a       	mov	r10,2
8000453e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004542:	fa ca ff ec 	sub	r10,sp,-20
80004546:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004548:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000454a:	1a 9c       	mov	r12,sp
8000454c:	f0 1f 00 05 	mcall	80004560 <xnl_device_auth_reply_func+0x11c>
}
80004550:	2c 0d       	sub	sp,-256
80004552:	d8 22       	popm	r4-r7,pc
80004554:	00 00       	add	r0,r0
80004556:	0b 30       	ld.ub	r0,r5++
80004558:	00 00       	add	r0,r0
8000455a:	0b 2c       	ld.uh	r12,r5++
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	5e 3c       	retlo	r12
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	43 00       	lddsp	r0,sp[0xc0]

80004564 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004564:	eb cd 40 80 	pushm	r7,lr
80004568:	fa cd 01 00 	sub	sp,sp,256
8000456c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000456e:	49 28       	lddpc	r8,800045b4 <xnl_master_status_brdcst_func+0x50>
80004570:	11 88       	ld.ub	r8,r8[0x0]
80004572:	58 08       	cp.w	r8,0
80004574:	c1 c1       	brne	800045ac <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004576:	49 18       	lddpc	r8,800045b8 <xnl_master_status_brdcst_func+0x54>
80004578:	70 0c       	ld.w	r12,r8[0x0]
8000457a:	30 09       	mov	r9,0
8000457c:	12 9a       	mov	r10,r9
8000457e:	12 9b       	mov	r11,r9
80004580:	f0 1f 00 0f 	mcall	800045bc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004584:	8e 58       	ld.sh	r8,r7[0xa]
80004586:	48 c9       	lddpc	r9,800045b4 <xnl_master_status_brdcst_func+0x50>
80004588:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000458a:	e0 68 40 0e 	mov	r8,16398
8000458e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004590:	3f f8       	mov	r8,-1
80004592:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004594:	30 4a       	mov	r10,4
80004596:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004598:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000459a:	92 19       	ld.sh	r9,r9[0x2]
8000459c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000459e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045a0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045a2:	30 08       	mov	r8,0
800045a4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045a6:	1a 9c       	mov	r12,sp
800045a8:	f0 1f 00 06 	mcall	800045c0 <xnl_master_status_brdcst_func+0x5c>
}
800045ac:	2c 0d       	sub	sp,-256
800045ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800045b2:	00 00       	add	r0,r0
800045b4:	00 00       	add	r0,r0
800045b6:	0b 30       	ld.ub	r0,r5++
800045b8:	00 00       	add	r0,r0
800045ba:	0b 2c       	ld.uh	r12,r5++
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	5e 3c       	retlo	r12
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	43 00       	lddsp	r0,sp[0xc0]

800045c4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800045c4:	eb cd 40 80 	pushm	r7,lr
800045c8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800045ca:	49 28       	lddpc	r8,80004610 <xnl_device_conn_reply_func+0x4c>
800045cc:	70 0c       	ld.w	r12,r8[0x0]
800045ce:	30 09       	mov	r9,0
800045d0:	12 9a       	mov	r10,r9
800045d2:	12 9b       	mov	r11,r9
800045d4:	f0 1f 00 10 	mcall	80004614 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045d8:	ef 18 00 10 	ld.uh	r8,r7[16]
800045dc:	10 99       	mov	r9,r8
800045de:	e2 19 ff 00 	andl	r9,0xff00,COH
800045e2:	e0 49 01 00 	cp.w	r9,256
800045e6:	c0 60       	breq	800045f2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800045e8:	0e 9c       	mov	r12,r7
800045ea:	f0 1f 00 0c 	mcall	80004618 <xnl_device_conn_reply_func+0x54>
800045ee:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800045f2:	a9 68       	lsl	r8,0x8
800045f4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800045f8:	48 98       	lddpc	r8,8000461c <xnl_device_conn_reply_func+0x58>
800045fa:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800045fc:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004600:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004602:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004606:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004608:	30 19       	mov	r9,1
8000460a:	b0 89       	st.b	r8[0x0],r9
8000460c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004610:	00 00       	add	r0,r0
80004612:	0b 2c       	ld.uh	r12,r5++
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	5e 3c       	retlo	r12
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	45 64       	lddsp	r4,sp[0x158]
8000461c:	00 00       	add	r0,r0
8000461e:	0b 30       	ld.ub	r0,r5++

80004620 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004620:	d4 01       	pushm	lr
80004622:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004626:	e0 68 40 0e 	mov	r8,16398
8000462a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000462c:	3f f8       	mov	r8,-1
8000462e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004630:	30 38       	mov	r8,3
80004632:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004634:	30 08       	mov	r8,0
80004636:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004638:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000463a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000463c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000463e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004640:	1a 9c       	mov	r12,sp
80004642:	f0 1f 00 03 	mcall	8000464c <xnl_send_device_master_query+0x2c>
}
80004646:	2c 0d       	sub	sp,-256
80004648:	d8 02       	popm	pc
8000464a:	00 00       	add	r0,r0
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	43 00       	lddsp	r0,sp[0xc0]

80004650 <delay_ns>:
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004650:	58 0c       	cp.w	r12,0
80004652:	5e 0c       	reteq	r12
80004654:	30 08       	mov	r8,0
	{
		nop();
80004656:	d7 03       	nop
		nop();
80004658:	d7 03       	nop
		nop();
8000465a:	d7 03       	nop
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000465c:	2f f8       	sub	r8,-1
8000465e:	10 3c       	cp.w	r12,r8
80004660:	fe 9b ff fb 	brhi	80004656 <delay_ns+0x6>
80004664:	5e fc       	retal	r12
80004666:	d7 03       	nop

80004668 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80004668:	eb cd 40 e0 	pushm	r5-r7,lr
8000466c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000466e:	58 0c       	cp.w	r12,0
80004670:	c0 b0       	breq	80004686 <delay_us+0x1e>
80004672:	30 07       	mov	r7,0
		delay_ns(1000);
80004674:	e0 65 03 e8 	mov	r5,1000
80004678:	0a 9c       	mov	r12,r5
8000467a:	f0 1f 00 05 	mcall	8000468c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000467e:	2f f7       	sub	r7,-1
80004680:	0e 36       	cp.w	r6,r7
80004682:	fe 9b ff fb 	brhi	80004678 <delay_us+0x10>
80004686:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000468a:	00 00       	add	r0,r0
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	46 50       	lddsp	r0,sp[0x194]

80004690 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80004690:	eb cd 40 e0 	pushm	r5-r7,lr
80004694:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80004696:	58 0c       	cp.w	r12,0
80004698:	c0 b0       	breq	800046ae <delay_ms+0x1e>
8000469a:	30 07       	mov	r7,0
		delay_us(1000);
8000469c:	e0 65 03 e8 	mov	r5,1000
800046a0:	0a 9c       	mov	r12,r5
800046a2:	f0 1f 00 05 	mcall	800046b4 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800046a6:	2f f7       	sub	r7,-1
800046a8:	0e 36       	cp.w	r6,r7
800046aa:	fe 9b ff fb 	brhi	800046a0 <delay_ms+0x10>
800046ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800046b2:	00 00       	add	r0,r0
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	46 68       	lddsp	r8,sp[0x198]

800046b8 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800046b8:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800046ba:	48 78       	lddpc	r8,800046d4 <RC522_SPI_SetSpeed+0x1c>
800046bc:	70 09       	ld.w	r9,r8[0x0]
800046be:	72 ca       	ld.w	r10,r9[0x30]
800046c0:	5c 7c       	castu.h	r12
800046c2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800046c6:	f9 ea 10 0a 	or	r10,r12,r10
800046ca:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800046cc:	70 0c       	ld.w	r12,r8[0x0]
800046ce:	f0 1f 00 03 	mcall	800046d8 <RC522_SPI_SetSpeed+0x20>
		
	
}
800046d2:	d8 02       	popm	pc
800046d4:	00 00       	add	r0,r0
800046d6:	40 f0       	lddsp	r0,sp[0x3c]
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	53 2c       	stdsp	sp[0xc8],r12

800046dc <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800046dc:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
800046de:	e0 6c 04 00 	mov	r12,1024
800046e2:	f0 1f 00 02 	mcall	800046e8 <RC522_SPI_SetSpeedLow+0xc>
	
}
800046e6:	d8 02       	popm	pc
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	46 b8       	lddsp	r8,sp[0x1ac]

800046ec <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800046ec:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
800046f0:	48 b7       	lddpc	r7,8000471c <RC522_ReadByte+0x30>
800046f2:	30 0b       	mov	r11,0
800046f4:	6e 0c       	ld.w	r12,r7[0x0]
800046f6:	f0 1f 00 0b 	mcall	80004720 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046fa:	e0 6b 00 ff 	mov	r11,255
800046fe:	6e 0c       	ld.w	r12,r7[0x0]
80004700:	f0 1f 00 09 	mcall	80004724 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004704:	30 06       	mov	r6,0
80004706:	0c 9b       	mov	r11,r6
80004708:	6e 0c       	ld.w	r12,r7[0x0]
8000470a:	f0 1f 00 08 	mcall	80004728 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000470e:	0c 9b       	mov	r11,r6
80004710:	6e 0c       	ld.w	r12,r7[0x0]
80004712:	f0 1f 00 07 	mcall	8000472c <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004716:	0d 9c       	ld.ub	r12,r6[0x1]
80004718:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000471c:	00 00       	add	r0,r0
8000471e:	40 f0       	lddsp	r0,sp[0x3c]
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	54 98       	stdsp	sp[0x124],r8
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	53 32       	stdsp	sp[0xcc],r2
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	53 4e       	stdsp	sp[0xd0],lr
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	54 58       	stdsp	sp[0x114],r8

80004730 <RC522_WriteByte>:
	
}


U8 RC522_WriteByte(U8 Data)
{
80004730:	eb cd 40 c0 	pushm	r6-r7,lr
80004734:	20 1d       	sub	sp,4
80004736:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004738:	48 c7       	lddpc	r7,80004768 <RC522_WriteByte+0x38>
8000473a:	30 0b       	mov	r11,0
8000473c:	6e 0c       	ld.w	r12,r7[0x0]
8000473e:	f0 1f 00 0c 	mcall	8000476c <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004742:	1b 8b       	ld.ub	r11,sp[0x0]
80004744:	6e 0c       	ld.w	r12,r7[0x0]
80004746:	f0 1f 00 0b 	mcall	80004770 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000474a:	1a 9b       	mov	r11,sp
8000474c:	6e 0c       	ld.w	r12,r7[0x0]
8000474e:	f0 1f 00 0a 	mcall	80004774 <RC522_WriteByte+0x44>
80004752:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004754:	30 0b       	mov	r11,0
80004756:	6e 0c       	ld.w	r12,r7[0x0]
80004758:	f0 1f 00 08 	mcall	80004778 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
8000475c:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004760:	2f fd       	sub	sp,-4
80004762:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004766:	00 00       	add	r0,r0
80004768:	00 00       	add	r0,r0
8000476a:	40 f0       	lddsp	r0,sp[0x3c]
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	54 98       	stdsp	sp[0x124],r8
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	53 32       	stdsp	sp[0xcc],r2
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	53 4e       	stdsp	sp[0xd0],lr
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	54 58       	stdsp	sp[0x114],r8

8000477c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000477c:	eb cd 40 c0 	pushm	r6-r7,lr
80004780:	18 96       	mov	r6,r12
80004782:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004784:	31 8c       	mov	r12,24
80004786:	f0 1f 00 09 	mcall	800047a8 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000478a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000478e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004792:	f0 1f 00 07 	mcall	800047ac <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004796:	0e 9c       	mov	r12,r7
80004798:	f0 1f 00 05 	mcall	800047ac <WriteRawRC+0x30>
	
	SET_SPI_CS;
8000479c:	31 8c       	mov	r12,24
8000479e:	f0 1f 00 05 	mcall	800047b0 <WriteRawRC+0x34>

}
800047a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047a6:	00 00       	add	r0,r0
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	51 7c       	stdsp	sp[0x5c],r12
800047ac:	80 00       	ld.sh	r0,r0[0x0]
800047ae:	47 30       	lddsp	r0,sp[0x1cc]
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	51 60       	stdsp	sp[0x58],r0

800047b4 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047b4:	d4 01       	pushm	lr

	SET_RC522RST;
800047b6:	31 9c       	mov	r12,25
800047b8:	f0 1f 00 1b 	mcall	80004824 <PcdReset+0x70>
	delay_ns(10);
800047bc:	30 ac       	mov	r12,10
800047be:	f0 1f 00 1b 	mcall	80004828 <PcdReset+0x74>

	CLR_RC522RST;
800047c2:	31 9c       	mov	r12,25
800047c4:	f0 1f 00 1a 	mcall	8000482c <PcdReset+0x78>
	delay_ns(10);
800047c8:	30 ac       	mov	r12,10
800047ca:	f0 1f 00 18 	mcall	80004828 <PcdReset+0x74>

	SET_RC522RST;
800047ce:	31 9c       	mov	r12,25
800047d0:	f0 1f 00 15 	mcall	80004824 <PcdReset+0x70>
	delay_ns(10);
800047d4:	30 ac       	mov	r12,10
800047d6:	f0 1f 00 15 	mcall	80004828 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047da:	30 fb       	mov	r11,15
800047dc:	30 1c       	mov	r12,1
800047de:	f0 1f 00 15 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047e2:	30 fb       	mov	r11,15
800047e4:	30 1c       	mov	r12,1
800047e6:	f0 1f 00 13 	mcall	80004830 <PcdReset+0x7c>
	delay_ns(10);
800047ea:	30 ac       	mov	r12,10
800047ec:	f0 1f 00 0f 	mcall	80004828 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800047f0:	33 db       	mov	r11,61
800047f2:	31 1c       	mov	r12,17
800047f4:	f0 1f 00 0f 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047f8:	31 eb       	mov	r11,30
800047fa:	32 dc       	mov	r12,45
800047fc:	f0 1f 00 0d 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004800:	30 0b       	mov	r11,0
80004802:	32 cc       	mov	r12,44
80004804:	f0 1f 00 0b 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004808:	e0 6b 00 8d 	mov	r11,141
8000480c:	32 ac       	mov	r12,42
8000480e:	f0 1f 00 09 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004812:	33 eb       	mov	r11,62
80004814:	32 bc       	mov	r12,43
80004816:	f0 1f 00 07 	mcall	80004830 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000481a:	34 0b       	mov	r11,64
8000481c:	31 5c       	mov	r12,21
8000481e:	f0 1f 00 05 	mcall	80004830 <PcdReset+0x7c>
	
	return MI_OK;
}
80004822:	d8 0a       	popm	pc,r12=0
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	51 60       	stdsp	sp[0x58],r0
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	46 50       	lddsp	r0,sp[0x194]
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	51 7c       	stdsp	sp[0x5c],r12
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	47 7c       	lddsp	r12,sp[0x1dc]

80004834 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004834:	eb cd 40 80 	pushm	r7,lr
80004838:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
8000483a:	31 8c       	mov	r12,24
8000483c:	f0 1f 00 0a 	mcall	80004864 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004840:	ee 08 15 01 	lsl	r8,r7,0x1
80004844:	10 9c       	mov	r12,r8
80004846:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000484a:	a7 bc       	sbr	r12,0x7
8000484c:	f0 1f 00 07 	mcall	80004868 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004850:	f0 1f 00 07 	mcall	8000486c <ReadRawRC+0x38>
80004854:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004856:	31 8c       	mov	r12,24
80004858:	f0 1f 00 06 	mcall	80004870 <ReadRawRC+0x3c>
	return ucResult;
}
8000485c:	0e 9c       	mov	r12,r7
8000485e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004862:	00 00       	add	r0,r0
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	51 7c       	stdsp	sp[0x5c],r12
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	47 30       	lddsp	r0,sp[0x1cc]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	46 ec       	lddsp	r12,sp[0x1b8]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	51 60       	stdsp	sp[0x58],r0

80004874 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004874:	eb cd 40 c0 	pushm	r6-r7,lr
80004878:	18 97       	mov	r7,r12
8000487a:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
8000487c:	f0 1f 00 05 	mcall	80004890 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004880:	f9 e6 10 0b 	or	r11,r12,r6
80004884:	5c 5b       	castu.b	r11
80004886:	0e 9c       	mov	r12,r7
80004888:	f0 1f 00 03 	mcall	80004894 <SetBitMask+0x20>
}
8000488c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	48 34       	lddpc	r4,8000489c <PcdAntennaOn+0x4>
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	47 7c       	lddsp	r12,sp[0x1dc]

80004898 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004898:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000489a:	31 4c       	mov	r12,20
8000489c:	f0 1f 00 05 	mcall	800048b0 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800048a0:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800048a4:	c0 51       	brne	800048ae <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800048a6:	30 3b       	mov	r11,3
800048a8:	31 4c       	mov	r12,20
800048aa:	f0 1f 00 03 	mcall	800048b4 <PcdAntennaOn+0x1c>
800048ae:	d8 02       	popm	pc
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	48 34       	lddpc	r4,800048bc <ClearBitMask+0x4>
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	48 74       	lddpc	r4,800048d0 <ClearBitMask+0x18>

800048b8 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800048b8:	eb cd 40 c0 	pushm	r6-r7,lr
800048bc:	18 97       	mov	r7,r12
800048be:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800048c0:	f0 1f 00 06 	mcall	800048d8 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800048c4:	5c d6       	com	r6
800048c6:	f9 e6 00 06 	and	r6,r12,r6
800048ca:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800048ce:	0e 9c       	mov	r12,r7
800048d0:	f0 1f 00 03 	mcall	800048dc <ClearBitMask+0x24>
	
}
800048d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	48 34       	lddpc	r4,800048e4 <PcdAntennaOff+0x4>
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	47 7c       	lddsp	r12,sp[0x1dc]

800048e0 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800048e0:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800048e2:	30 3b       	mov	r11,3
800048e4:	31 4c       	mov	r12,20
800048e6:	f0 1f 00 02 	mcall	800048ec <PcdAntennaOff+0xc>
}
800048ea:	d8 02       	popm	pc
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	48 b8       	lddpc	r8,80004918 <M500PcdConfigISOType+0x28>

800048f0 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800048f0:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800048f2:	34 18       	mov	r8,65
800048f4:	f0 0c 18 00 	cp.b	r12,r8
800048f8:	c0 20       	breq	800048fc <M500PcdConfigISOType+0xc>
800048fa:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048fc:	30 8b       	mov	r11,8
800048fe:	16 9c       	mov	r12,r11
80004900:	f0 1f 00 14 	mcall	80004950 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004904:	33 db       	mov	r11,61
80004906:	31 1c       	mov	r12,17
80004908:	f0 1f 00 13 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
8000490c:	e0 6b 00 86 	mov	r11,134
80004910:	31 7c       	mov	r12,23
80004912:	f0 1f 00 11 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004916:	37 fb       	mov	r11,127
80004918:	32 6c       	mov	r12,38
8000491a:	f0 1f 00 0f 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000491e:	31 eb       	mov	r11,30
80004920:	32 dc       	mov	r12,45
80004922:	f0 1f 00 0d 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004926:	30 0b       	mov	r11,0
80004928:	32 cc       	mov	r12,44
8000492a:	f0 1f 00 0b 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000492e:	e0 6b 00 8d 	mov	r11,141
80004932:	32 ac       	mov	r12,42
80004934:	f0 1f 00 08 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004938:	33 eb       	mov	r11,62
8000493a:	32 bc       	mov	r12,43
8000493c:	f0 1f 00 06 	mcall	80004954 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004940:	e0 6c 03 e8 	mov	r12,1000
80004944:	f0 1f 00 05 	mcall	80004958 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004948:	f0 1f 00 05 	mcall	8000495c <M500PcdConfigISOType+0x6c>
8000494c:	d8 0a       	popm	pc,r12=0
8000494e:	00 00       	add	r0,r0
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	48 b8       	lddpc	r8,8000497c <rc522_init+0x1c>
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	47 7c       	lddsp	r12,sp[0x1dc]
80004958:	80 00       	ld.sh	r0,r0[0x0]
8000495a:	46 50       	lddsp	r0,sp[0x194]
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	48 98       	lddpc	r8,80004980 <rc522_init+0x20>

80004960 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004960:	eb cd 40 c0 	pushm	r6-r7,lr
80004964:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004966:	4a 28       	lddpc	r8,800049ec <rc522_init+0x8c>
80004968:	1a 96       	mov	r6,sp
8000496a:	f0 ea 00 00 	ld.d	r10,r8[0]
8000496e:	fa eb 00 00 	st.d	sp[0],r10
80004972:	f0 e8 00 08 	ld.d	r8,r8[8]
80004976:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
8000497a:	30 4b       	mov	r11,4
8000497c:	49 dc       	lddpc	r12,800049f0 <rc522_init+0x90>
8000497e:	f0 1f 00 1e 	mcall	800049f4 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004982:	31 9c       	mov	r12,25
80004984:	f0 1f 00 1d 	mcall	800049f8 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004988:	31 9c       	mov	r12,25
8000498a:	f0 1f 00 1d 	mcall	800049fc <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000498e:	49 d7       	lddpc	r7,80004a00 <rc522_init+0xa0>
80004990:	fe 7c 24 00 	mov	r12,-56320
80004994:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004996:	1a 9b       	mov	r11,sp
80004998:	f0 1f 00 1b 	mcall	80004a04 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000499c:	30 09       	mov	r9,0
8000499e:	12 9a       	mov	r10,r9
800049a0:	12 9b       	mov	r11,r9
800049a2:	6e 0c       	ld.w	r12,r7[0x0]
800049a4:	f0 1f 00 19 	mcall	80004a08 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
800049a8:	6e 0c       	ld.w	r12,r7[0x0]
800049aa:	f0 1f 00 19 	mcall	80004a0c <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800049ae:	e0 6a 36 00 	mov	r10,13824
800049b2:	ea 1a 01 6e 	orh	r10,0x16e
800049b6:	1a 9b       	mov	r11,sp
800049b8:	6e 0c       	ld.w	r12,r7[0x0]
800049ba:	f0 1f 00 16 	mcall	80004a10 <rc522_init+0xb0>
800049be:	c0 50       	breq	800049c8 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800049c0:	30 29       	mov	r9,2
800049c2:	49 58       	lddpc	r8,80004a14 <rc522_init+0xb4>
800049c4:	b0 89       	st.b	r8[0x0],r9
800049c6:	c0 38       	rjmp	800049cc <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800049c8:	f0 1f 00 14 	mcall	80004a18 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800049cc:	f0 1f 00 14 	mcall	80004a1c <rc522_init+0xbc>
	
	PcdAntennaOff();
800049d0:	f0 1f 00 14 	mcall	80004a20 <rc522_init+0xc0>
	
	delay_ms(2); 
800049d4:	30 2c       	mov	r12,2
800049d6:	f0 1f 00 14 	mcall	80004a24 <rc522_init+0xc4>
	
	PcdAntennaOn();
800049da:	f0 1f 00 14 	mcall	80004a28 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
800049de:	34 1c       	mov	r12,65
800049e0:	f0 1f 00 13 	mcall	80004a2c <rc522_init+0xcc>
	

800049e4:	2f cd       	sub	sp,-16
800049e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049ea:	00 00       	add	r0,r0
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	d1 4c       	*unknown*
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	d1 60       	acall	0x16
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	51 18       	stdsp	sp[0x44],r8
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	51 48       	stdsp	sp[0x50],r8
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	51 60       	stdsp	sp[0x58],r0
80004a00:	00 00       	add	r0,r0
80004a02:	40 f0       	lddsp	r0,sp[0x3c]
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	52 c8       	stdsp	sp[0xb0],r8
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	53 00       	stdsp	sp[0xc0],r0
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	53 2c       	stdsp	sp[0xc8],r12
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	53 70       	stdsp	sp[0xdc],r0
80004a14:	00 00       	add	r0,r0
80004a16:	0b 54       	ld.sh	r4,--r5
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	46 dc       	lddsp	r12,sp[0x1b4]
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	47 b4       	lddsp	r4,sp[0x1ec]
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	48 e0       	lddpc	r0,80004a58 <PcdComMF522+0x28>
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	46 90       	lddsp	r0,sp[0x1a4]
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	48 98       	lddpc	r8,80004a4c <PcdComMF522+0x1c>
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	48 f0       	lddpc	r0,80004a68 <PcdComMF522+0x38>

80004a30 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004a30:	d4 31       	pushm	r0-r7,lr
80004a32:	20 1d       	sub	sp,4
80004a34:	18 92       	mov	r2,r12
80004a36:	16 95       	mov	r5,r11
80004a38:	14 96       	mov	r6,r10
80004a3a:	50 09       	stdsp	sp[0x0],r9
80004a3c:	10 90       	mov	r0,r8
80004a3e:	f8 c8 00 0c 	sub	r8,r12,12
80004a42:	5c 58       	castu.b	r8
80004a44:	30 29       	mov	r9,2
80004a46:	f2 08 18 00 	cp.b	r8,r9
80004a4a:	e0 88 00 05 	brls	80004a54 <PcdComMF522+0x24>
80004a4e:	30 03       	mov	r3,0
80004a50:	06 91       	mov	r1,r3
80004a52:	c0 78       	rjmp	80004a60 <PcdComMF522+0x30>
80004a54:	4c f9       	lddpc	r9,80004b90 <PcdComMF522+0x160>
80004a56:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a5a:	4c f9       	lddpc	r9,80004b94 <PcdComMF522+0x164>
80004a5c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a60:	02 9b       	mov	r11,r1
80004a62:	a7 bb       	sbr	r11,0x7
80004a64:	30 2c       	mov	r12,2
80004a66:	f0 1f 00 4d 	mcall	80004b98 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a6a:	e0 6b 00 80 	mov	r11,128
80004a6e:	30 4c       	mov	r12,4
80004a70:	f0 1f 00 4b 	mcall	80004b9c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a74:	30 0b       	mov	r11,0
80004a76:	30 1c       	mov	r12,1
80004a78:	f0 1f 00 48 	mcall	80004b98 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a7c:	e0 6b 00 80 	mov	r11,128
80004a80:	30 ac       	mov	r12,10
80004a82:	f0 1f 00 48 	mcall	80004ba0 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a86:	58 06       	cp.w	r6,0
80004a88:	c0 c0       	breq	80004aa0 <PcdComMF522+0x70>
80004a8a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a8c:	30 94       	mov	r4,9
80004a8e:	0f 3b       	ld.ub	r11,r7++
80004a90:	08 9c       	mov	r12,r4
80004a92:	f0 1f 00 42 	mcall	80004b98 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a96:	0e 98       	mov	r8,r7
80004a98:	0a 18       	sub	r8,r5
80004a9a:	ec 08 19 00 	cp.h	r8,r6
80004a9e:	cf 83       	brcs	80004a8e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004aa0:	04 9b       	mov	r11,r2
80004aa2:	30 1c       	mov	r12,1
80004aa4:	f0 1f 00 3d 	mcall	80004b98 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004aa8:	30 c8       	mov	r8,12
80004aaa:	f0 02 18 00 	cp.b	r2,r8
80004aae:	c0 61       	brne	80004aba <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004ab0:	e0 6b 00 80 	mov	r11,128
80004ab4:	30 dc       	mov	r12,13
80004ab6:	f0 1f 00 3b 	mcall	80004ba0 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004aba:	30 4c       	mov	r12,4
80004abc:	f0 1f 00 3a 	mcall	80004ba4 <PcdComMF522+0x174>
80004ac0:	18 97       	mov	r7,r12
80004ac2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ac6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ac8:	30 44       	mov	r4,4
80004aca:	c0 88       	rjmp	80004ada <PcdComMF522+0xaa>
80004acc:	08 9c       	mov	r12,r4
80004ace:	f0 1f 00 36 	mcall	80004ba4 <PcdComMF522+0x174>
80004ad2:	18 97       	mov	r7,r12
		i--;
80004ad4:	20 16       	sub	r6,1
80004ad6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ad8:	c0 a0       	breq	80004aec <PcdComMF522+0xbc>
80004ada:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004ade:	c4 c1       	brne	80004b76 <PcdComMF522+0x146>
80004ae0:	ef e3 00 08 	and	r8,r7,r3
80004ae4:	ea 08 18 00 	cp.b	r8,r5
80004ae8:	cf 20       	breq	80004acc <PcdComMF522+0x9c>
80004aea:	c4 68       	rjmp	80004b76 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004aec:	e0 6b 00 80 	mov	r11,128
80004af0:	30 dc       	mov	r12,13
80004af2:	f0 1f 00 2b 	mcall	80004b9c <PcdComMF522+0x16c>
80004af6:	30 27       	mov	r7,2
80004af8:	c3 38       	rjmp	80004b5e <PcdComMF522+0x12e>
80004afa:	02 67       	and	r7,r1
80004afc:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004b00:	30 c8       	mov	r8,12
80004b02:	f0 02 18 00 	cp.b	r2,r8
80004b06:	c2 c1       	brne	80004b5e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004b08:	30 ac       	mov	r12,10
80004b0a:	f0 1f 00 27 	mcall	80004ba4 <PcdComMF522+0x174>
80004b0e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004b10:	30 cc       	mov	r12,12
80004b12:	f0 1f 00 25 	mcall	80004ba4 <PcdComMF522+0x174>
80004b16:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004b1a:	c0 70       	breq	80004b28 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004b1c:	08 98       	mov	r8,r4
80004b1e:	20 18       	sub	r8,1
80004b20:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004b24:	a0 8c       	st.b	r0[0x0],r12
80004b26:	c0 48       	rjmp	80004b2e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004b28:	e8 08 15 03 	lsl	r8,r4,0x3
80004b2c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004b2e:	58 04       	cp.w	r4,0
80004b30:	c0 61       	brne	80004b3c <PcdComMF522+0x10c>
80004b32:	30 14       	mov	r4,1
80004b34:	40 05       	lddsp	r5,sp[0x0]
80004b36:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b38:	30 93       	mov	r3,9
80004b3a:	c0 98       	rjmp	80004b4c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b3c:	31 28       	mov	r8,18
80004b3e:	f0 04 18 00 	cp.b	r4,r8
80004b42:	f9 b4 0b 12 	movhi	r4,18
80004b46:	58 04       	cp.w	r4,0
80004b48:	cf 61       	brne	80004b34 <PcdComMF522+0x104>
80004b4a:	c0 a8       	rjmp	80004b5e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b4c:	06 9c       	mov	r12,r3
80004b4e:	f0 1f 00 16 	mcall	80004ba4 <PcdComMF522+0x174>
80004b52:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b54:	ec 05 01 08 	sub	r8,r6,r5
80004b58:	e8 08 19 00 	cp.h	r8,r4
80004b5c:	cf 83       	brcs	80004b4c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b5e:	e0 6b 00 80 	mov	r11,128
80004b62:	30 cc       	mov	r12,12
80004b64:	f0 1f 00 0f 	mcall	80004ba0 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b68:	30 0b       	mov	r11,0
80004b6a:	30 1c       	mov	r12,1
80004b6c:	f0 1f 00 0b 	mcall	80004b98 <PcdComMF522+0x168>
	return status;
}
80004b70:	0e 9c       	mov	r12,r7
80004b72:	2f fd       	sub	sp,-4
80004b74:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b76:	e0 6b 00 80 	mov	r11,128
80004b7a:	30 dc       	mov	r12,13
80004b7c:	f0 1f 00 08 	mcall	80004b9c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b80:	30 6c       	mov	r12,6
80004b82:	f0 1f 00 09 	mcall	80004ba4 <PcdComMF522+0x174>
80004b86:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b8a:	cb 80       	breq	80004afa <PcdComMF522+0xca>
80004b8c:	30 27       	mov	r7,2
80004b8e:	ce 8b       	rjmp	80004b5e <PcdComMF522+0x12e>
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	d1 5c       	*unknown*
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	d1 48       	*unknown*
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	47 7c       	lddsp	r12,sp[0x1dc]
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	48 b8       	lddpc	r8,80004bc8 <PcdAnticoll+0x20>
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	48 74       	lddpc	r4,80004bbc <PcdAnticoll+0x14>
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	48 34       	lddpc	r4,80004bb0 <PcdAnticoll+0x8>

80004ba8 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bac:	20 5d       	sub	sp,20
80004bae:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004bb0:	30 8b       	mov	r11,8
80004bb2:	16 9c       	mov	r12,r11
80004bb4:	f0 1f 00 1a 	mcall	80004c1c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004bb8:	30 0b       	mov	r11,0
80004bba:	30 dc       	mov	r12,13
80004bbc:	f0 1f 00 19 	mcall	80004c20 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004bc0:	e0 6b 00 80 	mov	r11,128
80004bc4:	30 ec       	mov	r12,14
80004bc6:	f0 1f 00 16 	mcall	80004c1c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004bca:	39 38       	mov	r8,-109
80004bcc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004bce:	32 08       	mov	r8,32
80004bd0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004bd2:	1a 9b       	mov	r11,sp
80004bd4:	fa c8 ff ed 	sub	r8,sp,-19
80004bd8:	1a 99       	mov	r9,sp
80004bda:	30 2a       	mov	r10,2
80004bdc:	30 cc       	mov	r12,12
80004bde:	f0 1f 00 12 	mcall	80004c24 <PcdAnticoll+0x7c>
80004be2:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004be4:	c1 21       	brne	80004c08 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004be6:	1b 89       	ld.ub	r9,sp[0x0]
80004be8:	ac 89       	st.b	r6[0x0],r9
80004bea:	1b 98       	ld.ub	r8,sp[0x1]
80004bec:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004bee:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bf0:	1b a8       	ld.ub	r8,sp[0x2]
80004bf2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004bf4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bf8:	1b b9       	ld.ub	r9,sp[0x3]
80004bfa:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004bfc:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004bfe:	1b c9       	ld.ub	r9,sp[0x4]
80004c00:	f0 09 18 00 	cp.b	r9,r8
80004c04:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004c08:	e0 6b 00 80 	mov	r11,128
80004c0c:	30 ec       	mov	r12,14
80004c0e:	f0 1f 00 07 	mcall	80004c28 <PcdAnticoll+0x80>
	return status;
}
80004c12:	0e 9c       	mov	r12,r7
80004c14:	2f bd       	sub	sp,-20
80004c16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c1a:	00 00       	add	r0,r0
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	48 b8       	lddpc	r8,80004c48 <PcdRequest+0x1c>
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	47 7c       	lddsp	r12,sp[0x1dc]
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	4a 30       	lddpc	r0,80004cb0 <CalulateCRC+0x20>
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	48 74       	lddpc	r4,80004c44 <PcdRequest+0x18>

80004c2c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004c2c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c30:	20 5d       	sub	sp,20
80004c32:	18 97       	mov	r7,r12
80004c34:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004c36:	30 8b       	mov	r11,8
80004c38:	16 9c       	mov	r12,r11
80004c3a:	f0 1f 00 12 	mcall	80004c80 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004c3e:	30 7b       	mov	r11,7
80004c40:	30 dc       	mov	r12,13
80004c42:	f0 1f 00 11 	mcall	80004c84 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004c46:	30 3b       	mov	r11,3
80004c48:	31 4c       	mov	r12,20
80004c4a:	f0 1f 00 10 	mcall	80004c88 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004c4e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004c50:	1a 9b       	mov	r11,sp
80004c52:	fa c8 ff ed 	sub	r8,sp,-19
80004c56:	1a 99       	mov	r9,sp
80004c58:	30 1a       	mov	r10,1
80004c5a:	30 cc       	mov	r12,12
80004c5c:	f0 1f 00 0c 	mcall	80004c8c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c60:	c0 c1       	brne	80004c78 <PcdRequest+0x4c>
80004c62:	31 08       	mov	r8,16
80004c64:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c68:	f0 09 18 00 	cp.b	r9,r8
80004c6c:	c0 61       	brne	80004c78 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c6e:	1b 88       	ld.ub	r8,sp[0x0]
80004c70:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c72:	1b 98       	ld.ub	r8,sp[0x1]
80004c74:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c76:	c0 28       	rjmp	80004c7a <PcdRequest+0x4e>
80004c78:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c7a:	2f bd       	sub	sp,-20
80004c7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	48 b8       	lddpc	r8,80004cac <CalulateCRC+0x1c>
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	47 7c       	lddsp	r12,sp[0x1dc]
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	48 74       	lddpc	r4,80004ca4 <CalulateCRC+0x14>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	4a 30       	lddpc	r0,80004d18 <CalulateCRC+0x88>

80004c90 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c90:	eb cd 40 f8 	pushm	r3-r7,lr
80004c94:	18 95       	mov	r5,r12
80004c96:	16 96       	mov	r6,r11
80004c98:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c9a:	30 4b       	mov	r11,4
80004c9c:	30 5c       	mov	r12,5
80004c9e:	f0 1f 00 1c 	mcall	80004d0c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ca2:	30 0b       	mov	r11,0
80004ca4:	30 1c       	mov	r12,1
80004ca6:	f0 1f 00 1b 	mcall	80004d10 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004caa:	e0 6b 00 80 	mov	r11,128
80004cae:	30 ac       	mov	r12,10
80004cb0:	f0 1f 00 19 	mcall	80004d14 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004cb4:	58 06       	cp.w	r6,0
80004cb6:	c0 c0       	breq	80004cce <CalulateCRC+0x3e>
80004cb8:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004cba:	30 94       	mov	r4,9
80004cbc:	0f 3b       	ld.ub	r11,r7++
80004cbe:	08 9c       	mov	r12,r4
80004cc0:	f0 1f 00 14 	mcall	80004d10 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004cc4:	0e 98       	mov	r8,r7
80004cc6:	0a 18       	sub	r8,r5
80004cc8:	ec 08 18 00 	cp.b	r8,r6
80004ccc:	cf 83       	brcs	80004cbc <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004cce:	30 3b       	mov	r11,3
80004cd0:	30 1c       	mov	r12,1
80004cd2:	f0 1f 00 10 	mcall	80004d10 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004cd6:	30 5c       	mov	r12,5
80004cd8:	f0 1f 00 10 	mcall	80004d18 <CalulateCRC+0x88>
80004cdc:	e0 67 00 fe 	mov	r7,254
80004ce0:	30 56       	mov	r6,5
80004ce2:	c0 78       	rjmp	80004cf0 <CalulateCRC+0x60>
80004ce4:	0c 9c       	mov	r12,r6
80004ce6:	f0 1f 00 0d 	mcall	80004d18 <CalulateCRC+0x88>
		i--;
80004cea:	20 17       	sub	r7,1
80004cec:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004cee:	c0 40       	breq	80004cf6 <CalulateCRC+0x66>
80004cf0:	e2 1c 00 04 	andl	r12,0x4,COH
80004cf4:	cf 80       	breq	80004ce4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004cf6:	32 2c       	mov	r12,34
80004cf8:	f0 1f 00 08 	mcall	80004d18 <CalulateCRC+0x88>
80004cfc:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004cfe:	32 1c       	mov	r12,33
80004d00:	f0 1f 00 06 	mcall	80004d18 <CalulateCRC+0x88>
80004d04:	a6 9c       	st.b	r3[0x1],r12
}
80004d06:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004d0a:	00 00       	add	r0,r0
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	48 b8       	lddpc	r8,80004d38 <PcdSelect+0x1c>
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	47 7c       	lddsp	r12,sp[0x1dc]
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	48 74       	lddpc	r4,80004d30 <PcdSelect+0x14>
80004d18:	80 00       	ld.sh	r0,r0[0x0]
80004d1a:	48 34       	lddpc	r4,80004d24 <PcdSelect+0x8>

80004d1c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004d1c:	eb cd 40 80 	pushm	r7,lr
80004d20:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d22:	39 38       	mov	r8,-109
80004d24:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004d26:	37 08       	mov	r8,112
80004d28:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004d2a:	30 08       	mov	r8,0
80004d2c:	ba e8       	st.b	sp[0x6],r8
80004d2e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004d32:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004d36:	19 89       	ld.ub	r9,r12[0x0]
80004d38:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004d3a:	19 3a       	ld.ub	r10,r12++
80004d3c:	1b e9       	ld.ub	r9,sp[0x6]
80004d3e:	f5 e9 20 09 	eor	r9,r10,r9
80004d42:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004d44:	16 38       	cp.w	r8,r11
80004d46:	cf 81       	brne	80004d36 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004d48:	1a 97       	mov	r7,sp
80004d4a:	fa ca ff f9 	sub	r10,sp,-7
80004d4e:	30 7b       	mov	r11,7
80004d50:	1a 9c       	mov	r12,sp
80004d52:	f0 1f 00 0d 	mcall	80004d84 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004d56:	30 8b       	mov	r11,8
80004d58:	16 9c       	mov	r12,r11
80004d5a:	f0 1f 00 0c 	mcall	80004d88 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d5e:	fa c8 ff ed 	sub	r8,sp,-19
80004d62:	1a 99       	mov	r9,sp
80004d64:	30 9a       	mov	r10,9
80004d66:	1a 9b       	mov	r11,sp
80004d68:	30 cc       	mov	r12,12
80004d6a:	f0 1f 00 09 	mcall	80004d8c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d6e:	c0 71       	brne	80004d7c <PcdSelect+0x60>
80004d70:	31 88       	mov	r8,24
80004d72:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d76:	f0 09 18 00 	cp.b	r9,r8
80004d7a:	c0 20       	breq	80004d7e <PcdSelect+0x62>
80004d7c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d7e:	2f bd       	sub	sp,-20
80004d80:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4c 90       	lddpc	r0,80004ea8 <rfid_sendID_message+0x18>
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	48 b8       	lddpc	r8,80004db4 <rfid_auto_reader+0x24>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4a 30       	lddpc	r0,80004e18 <rfid_auto_reader+0x88>

80004d90 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d90:	d4 31       	pushm	r0-r7,lr
80004d92:	18 90       	mov	r0,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d94:	f0 1f 00 30 	mcall	80004e54 <rfid_auto_reader+0xc4>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d98:	4b 07       	lddpc	r7,80004e58 <rfid_auto_reader+0xc8>
80004d9a:	35 25       	mov	r5,82
	if(status!=MI_OK) //return;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d9c:	30 43       	mov	r3,4
	else if(CT[0]==0x44&&CT[1]==0x03)
		log("MF Desire\n");
	else
		log("Unknown\n");
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004d9e:	4b 04       	lddpc	r4,80004e5c <rfid_auto_reader+0xcc>
	if(status!=MI_OK) //return;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004da0:	30 22       	mov	r2,2
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004da2:	34 46       	mov	r6,68
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004da4:	30 81       	mov	r1,8
{
	U8 status = MI_ERR;
	
	PcdReset();
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004da6:	0e 9b       	mov	r11,r7
80004da8:	0a 9c       	mov	r12,r5
80004daa:	f0 1f 00 2e 	mcall	80004e60 <rfid_auto_reader+0xd0>
	if(status!=MI_OK) //return;
80004dae:	cf c1       	brne	80004da6 <rfid_auto_reader+0x16>
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004db0:	0f 88       	ld.ub	r8,r7[0x0]
80004db2:	e6 08 18 00 	cp.b	r8,r3
80004db6:	c0 a1       	brne	80004dca <rfid_auto_reader+0x3a>
80004db8:	0f 9a       	ld.ub	r10,r7[0x1]
80004dba:	30 09       	mov	r9,0
80004dbc:	f2 0a 18 00 	cp.b	r10,r9
80004dc0:	c0 51       	brne	80004dca <rfid_auto_reader+0x3a>
		log("MFOne-S50\n");
80004dc2:	4a 9c       	lddpc	r12,80004e64 <rfid_auto_reader+0xd4>
80004dc4:	f0 1f 00 29 	mcall	80004e68 <rfid_auto_reader+0xd8>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) //return;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004dc8:	c3 48       	rjmp	80004e30 <rfid_auto_reader+0xa0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004dca:	e4 08 18 00 	cp.b	r8,r2
80004dce:	c0 a1       	brne	80004de2 <rfid_auto_reader+0x52>
80004dd0:	0f 9a       	ld.ub	r10,r7[0x1]
80004dd2:	30 09       	mov	r9,0
80004dd4:	f2 0a 18 00 	cp.b	r10,r9
80004dd8:	c0 51       	brne	80004de2 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004dda:	4a 5c       	lddpc	r12,80004e6c <rfid_auto_reader+0xdc>
80004ddc:	f0 1f 00 23 	mcall	80004e68 <rfid_auto_reader+0xd8>
	if(status!=MI_OK) //return;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004de0:	c2 88       	rjmp	80004e30 <rfid_auto_reader+0xa0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004de2:	ec 08 18 00 	cp.b	r8,r6
80004de6:	c0 a1       	brne	80004dfa <rfid_auto_reader+0x6a>
80004de8:	0f 9a       	ld.ub	r10,r7[0x1]
80004dea:	30 09       	mov	r9,0
80004dec:	f2 0a 18 00 	cp.b	r10,r9
80004df0:	c0 51       	brne	80004dfa <rfid_auto_reader+0x6a>
		log("MF-UltraLight\n");
80004df2:	4a 0c       	lddpc	r12,80004e70 <rfid_auto_reader+0xe0>
80004df4:	f0 1f 00 1d 	mcall	80004e68 <rfid_auto_reader+0xd8>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004df8:	c1 c8       	rjmp	80004e30 <rfid_auto_reader+0xa0>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dfa:	e2 08 18 00 	cp.b	r8,r1
80004dfe:	c0 a1       	brne	80004e12 <rfid_auto_reader+0x82>
80004e00:	0f 9a       	ld.ub	r10,r7[0x1]
80004e02:	30 09       	mov	r9,0
80004e04:	f2 0a 18 00 	cp.b	r10,r9
80004e08:	c0 51       	brne	80004e12 <rfid_auto_reader+0x82>
		log("MF-Pro\n");
80004e0a:	49 bc       	lddpc	r12,80004e74 <rfid_auto_reader+0xe4>
80004e0c:	f0 1f 00 17 	mcall	80004e68 <rfid_auto_reader+0xd8>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004e10:	c1 08       	rjmp	80004e30 <rfid_auto_reader+0xa0>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e12:	ec 08 18 00 	cp.b	r8,r6
80004e16:	c0 a1       	brne	80004e2a <rfid_auto_reader+0x9a>
80004e18:	0f 99       	ld.ub	r9,r7[0x1]
80004e1a:	30 38       	mov	r8,3
80004e1c:	f0 09 18 00 	cp.b	r9,r8
80004e20:	c0 51       	brne	80004e2a <rfid_auto_reader+0x9a>
		log("MF Desire\n");
80004e22:	49 6c       	lddpc	r12,80004e78 <rfid_auto_reader+0xe8>
80004e24:	f0 1f 00 11 	mcall	80004e68 <rfid_auto_reader+0xd8>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e28:	c0 48       	rjmp	80004e30 <rfid_auto_reader+0xa0>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004e2a:	49 5c       	lddpc	r12,80004e7c <rfid_auto_reader+0xec>
80004e2c:	f0 1f 00 0f 	mcall	80004e68 <rfid_auto_reader+0xd8>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004e30:	08 9c       	mov	r12,r4
80004e32:	f0 1f 00 14 	mcall	80004e80 <rfid_auto_reader+0xf0>
	if(status!=MI_OK)//return;
80004e36:	cb 81       	brne	80004da6 <rfid_auto_reader+0x16>
	continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004e38:	08 9c       	mov	r12,r4
80004e3a:	f0 1f 00 13 	mcall	80004e84 <rfid_auto_reader+0xf4>
	if(status!=MI_OK)//return;
80004e3e:	cb 41       	brne	80004da6 <rfid_auto_reader+0x16>
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e40:	30 4a       	mov	r10,4
80004e42:	08 9b       	mov	r11,r4
80004e44:	00 9c       	mov	r12,r0
80004e46:	f0 1f 00 11 	mcall	80004e88 <rfid_auto_reader+0xf8>
		log("select okay\n");
80004e4a:	49 1c       	lddpc	r12,80004e8c <rfid_auto_reader+0xfc>
80004e4c:	f0 1f 00 07 	mcall	80004e68 <rfid_auto_reader+0xd8>
80004e50:	ca bb       	rjmp	80004da6 <rfid_auto_reader+0x16>
80004e52:	00 00       	add	r0,r0
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	47 b4       	lddsp	r4,sp[0x1ec]
80004e58:	00 00       	add	r0,r0
80004e5a:	41 04       	lddsp	r4,sp[0x40]
80004e5c:	00 00       	add	r0,r0
80004e5e:	41 08       	lddsp	r8,sp[0x40]
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	4c 2c       	lddpc	r12,80004f68 <rfid_sendID_message+0xd8>
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	d1 80       	acall	0x18
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	69 d4       	ld.w	r4,r4[0x74]
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	d1 8c       	*unknown*
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	d1 98       	*unknown*
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	d1 a8       	*unknown*
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	d1 b0       	acall	0x1b
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	d1 bc       	*unknown*
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4b a8       	lddpc	r8,80004f68 <rfid_sendID_message+0xd8>
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	4d 1c       	lddpc	r12,80004fc8 <rfid_sendID_message+0x138>
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	72 68       	ld.w	r8,r9[0x18]
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	d1 c8       	*unknown*

80004e90 <rfid_sendID_message>:
	
}


U8 rfid_sendID_message()
{
80004e90:	eb cd 40 e0 	pushm	r5-r7,lr
80004e94:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004e96:	fa ca ff a4 	sub	r10,sp,-92
80004e9a:	30 08       	mov	r8,0
80004e9c:	30 09       	mov	r9,0
80004e9e:	f4 e9 00 00 	st.d	r10[0],r8
80004ea2:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80004ea6:	fa cc ff 94 	sub	r12,sp,-108
80004eaa:	f8 e9 00 00 	st.d	r12[0],r8
80004eae:	30 0a       	mov	r10,0
80004eb0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004eb2:	fa e9 00 0c 	st.d	sp[12],r8
80004eb6:	fa e9 00 14 	st.d	sp[20],r8
80004eba:	fa e9 00 1c 	st.d	sp[28],r8
80004ebe:	fa e9 00 24 	st.d	sp[36],r8
80004ec2:	fa e9 00 2c 	st.d	sp[44],r8
80004ec6:	fa e9 00 34 	st.d	sp[52],r8
80004eca:	fa e9 00 3c 	st.d	sp[60],r8
80004ece:	fa e9 00 44 	st.d	sp[68],r8
80004ed2:	fa e9 00 4c 	st.d	sp[76],r8
80004ed6:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
80004eda:	f0 1f 00 3c 	mcall	80004fc8 <rfid_sendID_message+0x138>
80004ede:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ee0:	c6 d1       	brne	80004fba <rfid_sendID_message+0x12a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ee2:	fb 38 00 6f 	ld.ub	r8,sp[111]
80004ee6:	1a d8       	st.w	--sp,r8
80004ee8:	fb 38 00 72 	ld.ub	r8,sp[114]
80004eec:	1a d8       	st.w	--sp,r8
80004eee:	fb 38 00 75 	ld.ub	r8,sp[117]
80004ef2:	1a d8       	st.w	--sp,r8
80004ef4:	fb 38 00 78 	ld.ub	r8,sp[120]
80004ef8:	1a d8       	st.w	--sp,r8
80004efa:	4b 5c       	lddpc	r12,80004fcc <rfid_sendID_message+0x13c>
80004efc:	f0 1f 00 35 	mcall	80004fd0 <rfid_sendID_message+0x140>
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
80004f00:	33 7c       	mov	r12,55
80004f02:	f0 1f 00 35 	mcall	80004fd4 <rfid_sendID_message+0x144>
80004f06:	fa c9 ff 84 	sub	r9,sp,-124
80004f0a:	fa c8 ff 94 	sub	r8,sp,-108
80004f0e:	fa ca ff 92 	sub	r10,sp,-110
}
	
}


U8 rfid_sendID_message()
80004f12:	fa c5 ff 80 	sub	r5,sp,-128
80004f16:	2f cd       	sub	sp,-16
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004f18:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80004f1a:	30 06       	mov	r6,0
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004f1c:	13 8b       	ld.ub	r11,r9[0x0]
80004f1e:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004f22:	fc 0c 18 00 	cp.b	r12,lr
80004f26:	f7 bc 08 d0 	subls	r12,-48
80004f2a:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80004f2e:	f7 bc 0b a9 	subhi	r12,-87
80004f32:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
80004f36:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f38:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80004f3c:	fc 0b 18 00 	cp.b	r11,lr
80004f40:	f7 bb 08 d0 	subls	r11,-48
80004f44:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80004f48:	f7 bb 0b a9 	subhi	r11,-87
80004f4c:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80004f50:	b0 b6       	st.b	r8[0x3],r6
80004f52:	2f f9       	sub	r9,-1
80004f54:	2f c8       	sub	r8,-4
80004f56:	2f ca       	sub	r10,-4
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f58:	0a 39       	cp.w	r9,r5
80004f5a:	ce 11       	brne	80004f1c <rfid_sendID_message+0x8c>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f5c:	49 f8       	lddpc	r8,80004fd8 <rfid_sendID_message+0x148>
80004f5e:	11 89       	ld.ub	r9,r8[0x0]
80004f60:	39 f8       	mov	r8,-97
80004f62:	f0 09 18 00 	cp.b	r9,r8
80004f66:	e0 88 00 05 	brls	80004f70 <rfid_sendID_message+0xe0>
80004f6a:	38 09       	mov	r9,-128
80004f6c:	49 b8       	lddpc	r8,80004fd8 <rfid_sendID_message+0x148>
80004f6e:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f70:	49 a8       	lddpc	r8,80004fd8 <rfid_sendID_message+0x148>
80004f72:	11 86       	ld.ub	r6,r8[0x0]
80004f74:	2f f6       	sub	r6,-1
80004f76:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f78:	30 5a       	mov	r10,5
80004f7a:	49 9b       	lddpc	r11,80004fdc <rfid_sendID_message+0x14c>
80004f7c:	fa cc ff f9 	sub	r12,sp,-7
80004f80:	f0 1f 00 18 	mcall	80004fe0 <rfid_sendID_message+0x150>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f84:	31 88       	mov	r8,24
80004f86:	ba 18       	st.h	sp[0x2],r8
80004f88:	ba e6       	st.b	sp[0x6],r6
80004f8a:	fe 78 e0 00 	mov	r8,-8192
80004f8e:	ba 28       	st.h	sp[0x4],r8
80004f90:	fa c6 ff f4 	sub	r6,sp,-12
80004f94:	30 aa       	mov	r10,10
80004f96:	fa cb ff fe 	sub	r11,sp,-2
80004f9a:	0c 9c       	mov	r12,r6
80004f9c:	f0 1f 00 11 	mcall	80004fe0 <rfid_sendID_message+0x150>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80004fa0:	31 0a       	mov	r10,16
80004fa2:	fa cb ff a4 	sub	r11,sp,-92
80004fa6:	fa cc ff ea 	sub	r12,sp,-22
80004faa:	f0 1f 00 0e 	mcall	80004fe0 <rfid_sendID_message+0x150>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80004fae:	30 9a       	mov	r10,9
80004fb0:	31 ab       	mov	r11,26
80004fb2:	0c 9c       	mov	r12,r6
80004fb4:	f0 1f 00 0c 	mcall	80004fe4 <rfid_sendID_message+0x154>
80004fb8:	c0 48       	rjmp	80004fc0 <rfid_sendID_message+0x130>
		
	}
	else
	{
		log("no card find...\n");
80004fba:	48 cc       	lddpc	r12,80004fe8 <rfid_sendID_message+0x158>
80004fbc:	f0 1f 00 05 	mcall	80004fd0 <rfid_sendID_message+0x140>
	}
	
	return return_err;
	
}
80004fc0:	0e 9c       	mov	r12,r7
80004fc2:	2e 2d       	sub	sp,-120
80004fc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	4d 90       	lddpc	r0,8000512c <gpio_enable_module+0x14>
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	d1 d8       	*unknown*
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	69 d4       	ld.w	r4,r4[0x74]
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	3e 74       	mov	r4,-25
80004fd8:	00 00       	add	r0,r0
80004fda:	05 2c       	ld.uh	r12,r2++
80004fdc:	00 00       	add	r0,r0
80004fde:	05 24       	ld.uh	r4,r2++
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	72 68       	ld.w	r8,r9[0x18]
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	3d 3c       	mov	r12,-45
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	d1 f4       	*unknown*

80004fec <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004fec:	eb cd 40 80 	pushm	r7,lr
80004ff0:	20 1d       	sub	sp,4
	char card_id[4]={0};
80004ff2:	fa c7 ff fc 	sub	r7,sp,-4
80004ff6:	30 08       	mov	r8,0
80004ff8:	0e d8       	st.w	--r7,r8
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004ffa:	f0 1f 00 0d 	mcall	8000502c <rfid_init+0x40>
	
	if(rfid_auto_reader(card_id) == 0){
80004ffe:	1a 9c       	mov	r12,sp
80005000:	f0 1f 00 0c 	mcall	80005030 <rfid_init+0x44>
80005004:	c1 11       	brne	80005026 <rfid_init+0x3a>
		log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
80005006:	fa c8 ff fd 	sub	r8,sp,-3
8000500a:	1a d8       	st.w	--sp,r8
8000500c:	fa c8 ff fa 	sub	r8,sp,-6
80005010:	1a d8       	st.w	--sp,r8
80005012:	fa c8 ff f7 	sub	r8,sp,-9
80005016:	1a d8       	st.w	--sp,r8
80005018:	fa c8 ff f4 	sub	r8,sp,-12
8000501c:	1a d8       	st.w	--sp,r8
8000501e:	48 6c       	lddpc	r12,80005034 <rfid_init+0x48>
80005020:	f0 1f 00 06 	mcall	80005038 <rfid_init+0x4c>
80005024:	2f cd       	sub	sp,-16
	}
		
}
80005026:	2f fd       	sub	sp,-4
80005028:	e3 cd 80 80 	ldm	sp++,r7,pc
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	49 60       	lddpc	r0,80005084 <local_start_pll0+0x48>
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	4d 90       	lddpc	r0,80005194 <gpio_clr_gpio_pin+0x18>
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	d2 08       	*unknown*
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	69 d4       	ld.w	r4,r4[0x74]

8000503c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000503c:	fe 78 0c 00 	mov	r8,-62464
80005040:	e0 69 03 07 	mov	r9,775
80005044:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005046:	30 49       	mov	r9,4
80005048:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000504a:	71 59       	ld.w	r9,r8[0x54]
8000504c:	e2 19 00 80 	andl	r9,0x80,COH
80005050:	cf d0       	breq	8000504a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005052:	fe 78 0c 00 	mov	r8,-62464
80005056:	30 59       	mov	r9,5
80005058:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000505a:	e0 69 01 0d 	mov	r9,269
8000505e:	ea 19 10 07 	orh	r9,0x1007
80005062:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005064:	71 59       	ld.w	r9,r8[0x54]
80005066:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000506a:	cf d0       	breq	80005064 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000506c:	fe 78 0c 00 	mov	r8,-62464
80005070:	fc 19 00 80 	movh	r9,0x80
80005074:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005076:	34 0a       	mov	r10,64
80005078:	fe 69 14 00 	mov	r9,-125952
8000507c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000507e:	30 69       	mov	r9,6
80005080:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005082:	30 19       	mov	r9,1
80005084:	fe 68 10 00 	mov	r8,-126976
80005088:	91 19       	st.w	r8[0x4],r9
}
8000508a:	5e fc       	retal	r12

8000508c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000508c:	fe 78 10 00 	mov	r8,-61440
80005090:	fc 19 00 10 	movh	r9,0x10
80005094:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005096:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005098:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000509a:	30 39       	mov	r9,3
8000509c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800050a0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800050a4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800050a8:	fe 78 38 00 	mov	r8,-51200
800050ac:	30 49       	mov	r9,4
800050ae:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800050b2:	e0 69 91 0d 	mov	r9,37133
800050b6:	ea 19 00 52 	orh	r9,0x52
800050ba:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800050bc:	32 09       	mov	r9,32
800050be:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050c0:	30 59       	mov	r9,5
800050c2:	91 09       	st.w	r8[0x0],r9
}
800050c4:	5e fc       	retal	r12

800050c6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800050c6:	f8 08 16 05 	lsr	r8,r12,0x5
800050ca:	a9 68       	lsl	r8,0x8
800050cc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800050d0:	58 1b       	cp.w	r11,1
800050d2:	c0 d0       	breq	800050ec <gpio_enable_module_pin+0x26>
800050d4:	c0 63       	brcs	800050e0 <gpio_enable_module_pin+0x1a>
800050d6:	58 2b       	cp.w	r11,2
800050d8:	c1 00       	breq	800050f8 <gpio_enable_module_pin+0x32>
800050da:	58 3b       	cp.w	r11,3
800050dc:	c1 40       	breq	80005104 <gpio_enable_module_pin+0x3e>
800050de:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050e0:	30 19       	mov	r9,1
800050e2:	f2 0c 09 49 	lsl	r9,r9,r12
800050e6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050e8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050ea:	c1 28       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050ec:	30 19       	mov	r9,1
800050ee:	f2 0c 09 49 	lsl	r9,r9,r12
800050f2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050f4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050f6:	c0 c8       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050f8:	30 19       	mov	r9,1
800050fa:	f2 0c 09 49 	lsl	r9,r9,r12
800050fe:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005100:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005102:	c0 68       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005104:	30 19       	mov	r9,1
80005106:	f2 0c 09 49 	lsl	r9,r9,r12
8000510a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000510c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000510e:	30 19       	mov	r9,1
80005110:	f2 0c 09 4c 	lsl	r12,r9,r12
80005114:	91 2c       	st.w	r8[0x8],r12
80005116:	5e fd       	retal	0

80005118 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005118:	d4 21       	pushm	r4-r7,lr
8000511a:	18 97       	mov	r7,r12
8000511c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000511e:	58 0b       	cp.w	r11,0
80005120:	c0 31       	brne	80005126 <gpio_enable_module+0xe>
80005122:	30 05       	mov	r5,0
80005124:	c0 d8       	rjmp	8000513e <gpio_enable_module+0x26>
80005126:	30 06       	mov	r6,0
80005128:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000512a:	6e 1b       	ld.w	r11,r7[0x4]
8000512c:	6e 0c       	ld.w	r12,r7[0x0]
8000512e:	f0 1f 00 06 	mcall	80005144 <gpio_enable_module+0x2c>
80005132:	18 45       	or	r5,r12
		gpiomap++;
80005134:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005136:	2f f6       	sub	r6,-1
80005138:	0c 34       	cp.w	r4,r6
8000513a:	fe 9b ff f8 	brhi	8000512a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000513e:	0a 9c       	mov	r12,r5
80005140:	d8 22       	popm	r4-r7,pc
80005142:	00 00       	add	r0,r0
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	50 c6       	stdsp	sp[0x30],r6

80005148 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005148:	f8 08 16 05 	lsr	r8,r12,0x5
8000514c:	a9 68       	lsl	r8,0x8
8000514e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005152:	30 19       	mov	r9,1
80005154:	f2 0c 09 4c 	lsl	r12,r9,r12
80005158:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000515c:	91 1c       	st.w	r8[0x4],r12
}
8000515e:	5e fc       	retal	r12

80005160 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005160:	f8 08 16 05 	lsr	r8,r12,0x5
80005164:	a9 68       	lsl	r8,0x8
80005166:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000516a:	30 19       	mov	r9,1
8000516c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005170:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005174:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005178:	91 1c       	st.w	r8[0x4],r12
}
8000517a:	5e fc       	retal	r12

8000517c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000517c:	f8 08 16 05 	lsr	r8,r12,0x5
80005180:	a9 68       	lsl	r8,0x8
80005182:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005186:	30 19       	mov	r9,1
80005188:	f2 0c 09 4c 	lsl	r12,r9,r12
8000518c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005190:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005194:	91 1c       	st.w	r8[0x4],r12
}
80005196:	5e fc       	retal	r12

80005198 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005198:	c0 08       	rjmp	80005198 <_unhandled_interrupt>
8000519a:	d7 03       	nop

8000519c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000519c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800051a0:	49 99       	lddpc	r9,80005204 <INTC_register_interrupt+0x68>
800051a2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800051a6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800051aa:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800051ac:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800051b0:	58 0a       	cp.w	r10,0
800051b2:	c0 91       	brne	800051c4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800051b4:	49 59       	lddpc	r9,80005208 <INTC_register_interrupt+0x6c>
800051b6:	49 6a       	lddpc	r10,8000520c <INTC_register_interrupt+0x70>
800051b8:	12 1a       	sub	r10,r9
800051ba:	fe 79 08 00 	mov	r9,-63488
800051be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051c2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800051c4:	58 1a       	cp.w	r10,1
800051c6:	c0 a1       	brne	800051da <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800051c8:	49 09       	lddpc	r9,80005208 <INTC_register_interrupt+0x6c>
800051ca:	49 2a       	lddpc	r10,80005210 <INTC_register_interrupt+0x74>
800051cc:	12 1a       	sub	r10,r9
800051ce:	bf aa       	sbr	r10,0x1e
800051d0:	fe 79 08 00 	mov	r9,-63488
800051d4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051d8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800051da:	58 2a       	cp.w	r10,2
800051dc:	c0 a1       	brne	800051f0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800051de:	48 b9       	lddpc	r9,80005208 <INTC_register_interrupt+0x6c>
800051e0:	48 da       	lddpc	r10,80005214 <INTC_register_interrupt+0x78>
800051e2:	12 1a       	sub	r10,r9
800051e4:	bf ba       	sbr	r10,0x1f
800051e6:	fe 79 08 00 	mov	r9,-63488
800051ea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051ee:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800051f0:	48 69       	lddpc	r9,80005208 <INTC_register_interrupt+0x6c>
800051f2:	48 aa       	lddpc	r10,80005218 <INTC_register_interrupt+0x7c>
800051f4:	12 1a       	sub	r10,r9
800051f6:	ea 1a c0 00 	orh	r10,0xc000
800051fa:	fe 79 08 00 	mov	r9,-63488
800051fe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005202:	5e fc       	retal	r12
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	d2 2c       	*unknown*
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	c8 00       	breq	8000510a <gpio_enable_module_pin+0x44>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	c9 04       	brge	8000512e <gpio_enable_module+0x16>
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	c9 12       	brcc	80005134 <gpio_enable_module+0x1c>
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	c9 20       	breq	8000513a <gpio_enable_module+0x22>
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	c9 2e       	rcall	80004f3e <rfid_sendID_message+0xae>

8000521c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000521c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000521e:	49 18       	lddpc	r8,80005260 <INTC_init_interrupts+0x44>
80005220:	e3 b8 00 01 	mtsr	0x4,r8
80005224:	49 0e       	lddpc	lr,80005264 <INTC_init_interrupts+0x48>
80005226:	30 07       	mov	r7,0
80005228:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000522a:	49 0c       	lddpc	r12,80005268 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000522c:	49 05       	lddpc	r5,8000526c <INTC_init_interrupts+0x50>
8000522e:	10 15       	sub	r5,r8
80005230:	fe 76 08 00 	mov	r6,-63488
80005234:	c1 08       	rjmp	80005254 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005236:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005238:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000523a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000523c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005240:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005242:	10 3a       	cp.w	r10,r8
80005244:	fe 9b ff fc 	brhi	8000523c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005248:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000524c:	2f f7       	sub	r7,-1
8000524e:	2f 8e       	sub	lr,-8
80005250:	59 37       	cp.w	r7,19
80005252:	c0 50       	breq	8000525c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005254:	7c 08       	ld.w	r8,lr[0x0]
80005256:	58 08       	cp.w	r8,0
80005258:	ce f1       	brne	80005236 <INTC_init_interrupts+0x1a>
8000525a:	cf 7b       	rjmp	80005248 <INTC_init_interrupts+0x2c>
8000525c:	d8 22       	popm	r4-r7,pc
8000525e:	00 00       	add	r0,r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	c8 00       	breq	80005162 <gpio_set_gpio_pin+0x2>
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	d2 2c       	*unknown*
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	51 98       	stdsp	sp[0x64],r8
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	c9 04       	brge	8000518e <gpio_clr_gpio_pin+0x12>

80005270 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005270:	fe 78 08 00 	mov	r8,-63488
80005274:	e0 69 00 83 	mov	r9,131
80005278:	f2 0c 01 0c 	sub	r12,r9,r12
8000527c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005280:	f2 ca ff c0 	sub	r10,r9,-64
80005284:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005288:	58 08       	cp.w	r8,0
8000528a:	c0 21       	brne	8000528e <_get_interrupt_handler+0x1e>
8000528c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000528e:	f0 08 12 00 	clz	r8,r8
80005292:	48 5a       	lddpc	r10,800052a4 <_get_interrupt_handler+0x34>
80005294:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005298:	f0 08 11 1f 	rsub	r8,r8,31
8000529c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000529e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800052a2:	5e fc       	retal	r12
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	d2 2c       	*unknown*

800052a8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800052a8:	f8 c8 00 01 	sub	r8,r12,1
800052ac:	f0 0b 00 0b 	add	r11,r8,r11
800052b0:	f6 0c 0d 0a 	divu	r10,r11,r12
800052b4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800052b6:	f4 c8 00 01 	sub	r8,r10,1
800052ba:	e0 48 00 fe 	cp.w	r8,254
800052be:	e0 88 00 03 	brls	800052c4 <getBaudDiv+0x1c>
800052c2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800052c4:	5c 8c       	casts.h	r12
}
800052c6:	5e fc       	retal	r12

800052c8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800052c8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800052cc:	30 18       	mov	r8,1
800052ce:	f0 09 18 00 	cp.b	r9,r8
800052d2:	e0 88 00 04 	brls	800052da <spi_initMaster+0x12>
800052d6:	30 2c       	mov	r12,2
800052d8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800052da:	e0 68 00 80 	mov	r8,128
800052de:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800052e0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800052e2:	30 19       	mov	r9,1
800052e4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800052e8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800052ec:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800052f0:	30 09       	mov	r9,0
800052f2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800052f6:	30 fa       	mov	r10,15
800052f8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800052fc:	99 18       	st.w	r12[0x4],r8
800052fe:	5e f9       	retal	r9

80005300 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005300:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005302:	30 18       	mov	r8,1
80005304:	f0 0b 18 00 	cp.b	r11,r8
80005308:	5f be       	srhi	lr
8000530a:	f0 0a 18 00 	cp.b	r10,r8
8000530e:	5f b8       	srhi	r8
80005310:	fd e8 10 08 	or	r8,lr,r8
80005314:	c0 30       	breq	8000531a <spi_selectionMode+0x1a>
80005316:	30 2c       	mov	r12,2
80005318:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000531a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000531c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005320:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005324:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005328:	99 18       	st.w	r12[0x4],r8
8000532a:	d8 0a       	popm	pc,r12=0

8000532c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000532c:	30 18       	mov	r8,1
8000532e:	99 08       	st.w	r12[0x0],r8
}
80005330:	5e fc       	retal	r12

80005332 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005332:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005336:	c0 58       	rjmp	80005340 <spi_write+0xe>
		if (!timeout--) {
80005338:	58 08       	cp.w	r8,0
8000533a:	c0 21       	brne	8000533e <spi_write+0xc>
8000533c:	5e ff       	retal	1
8000533e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005340:	78 49       	ld.w	r9,r12[0x10]
80005342:	e2 19 00 02 	andl	r9,0x2,COH
80005346:	cf 90       	breq	80005338 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005348:	5c 7b       	castu.h	r11
8000534a:	99 3b       	st.w	r12[0xc],r11
8000534c:	5e fd       	retal	0

8000534e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000534e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005352:	c0 58       	rjmp	8000535c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005354:	58 08       	cp.w	r8,0
80005356:	c0 21       	brne	8000535a <spi_read+0xc>
80005358:	5e ff       	retal	1
8000535a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000535c:	78 49       	ld.w	r9,r12[0x10]
8000535e:	e2 19 02 01 	andl	r9,0x201,COH
80005362:	e0 49 02 01 	cp.w	r9,513
80005366:	cf 71       	brne	80005354 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005368:	78 28       	ld.w	r8,r12[0x8]
8000536a:	b6 08       	st.h	r11[0x0],r8
8000536c:	5e fd       	retal	0
8000536e:	d7 03       	nop

80005370 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005370:	eb cd 40 f8 	pushm	r3-r7,lr
80005374:	18 95       	mov	r5,r12
80005376:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005378:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000537c:	30 38       	mov	r8,3
8000537e:	f0 06 18 00 	cp.b	r6,r8
80005382:	e0 8b 00 5e 	brhi	8000543e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005386:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000538a:	30 18       	mov	r8,1
8000538c:	f0 04 18 00 	cp.b	r4,r8
80005390:	e0 8b 00 57 	brhi	8000543e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005394:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005398:	30 78       	mov	r8,7
8000539a:	f0 03 18 00 	cp.b	r3,r8
8000539e:	e0 88 00 50 	brls	8000543e <spi_setupChipReg+0xce>
800053a2:	31 08       	mov	r8,16
800053a4:	f0 03 18 00 	cp.b	r3,r8
800053a8:	e0 8b 00 4b 	brhi	8000543e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800053ac:	14 9b       	mov	r11,r10
800053ae:	6e 1c       	ld.w	r12,r7[0x4]
800053b0:	f0 1f 00 26 	mcall	80005448 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800053b4:	c4 55       	brlt	8000543e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800053b6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800053b8:	ec 09 16 01 	lsr	r9,r6,0x1
800053bc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800053c0:	ec 16 00 01 	eorl	r6,0x1
800053c4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800053c8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800053cc:	20 83       	sub	r3,8
800053ce:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800053d2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800053d6:	ef 39 00 09 	ld.ub	r9,r7[9]
800053da:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800053de:	ef 39 00 0a 	ld.ub	r9,r7[10]
800053e2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800053e6:	0f 89       	ld.ub	r9,r7[0x0]
800053e8:	30 1a       	mov	r10,1
800053ea:	f4 09 18 00 	cp.b	r9,r10
800053ee:	c0 d0       	breq	80005408 <spi_setupChipReg+0x98>
800053f0:	c0 a3       	brcs	80005404 <spi_setupChipReg+0x94>
800053f2:	30 2a       	mov	r10,2
800053f4:	f4 09 18 00 	cp.b	r9,r10
800053f8:	c0 a0       	breq	8000540c <spi_setupChipReg+0x9c>
800053fa:	30 3a       	mov	r10,3
800053fc:	f4 09 18 00 	cp.b	r9,r10
80005400:	c1 f1       	brne	8000543e <spi_setupChipReg+0xce>
80005402:	c0 78       	rjmp	80005410 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005404:	8b c8       	st.w	r5[0x30],r8
		break;
80005406:	c0 68       	rjmp	80005412 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005408:	8b d8       	st.w	r5[0x34],r8
		break;
8000540a:	c0 48       	rjmp	80005412 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000540c:	8b e8       	st.w	r5[0x38],r8
		break;
8000540e:	c0 28       	rjmp	80005412 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005410:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005412:	48 f8       	lddpc	r8,8000544c <spi_setupChipReg+0xdc>
80005414:	70 08       	ld.w	r8,r8[0x0]
80005416:	58 08       	cp.w	r8,0
80005418:	c1 61       	brne	80005444 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000541a:	30 0b       	mov	r11,0
8000541c:	30 1c       	mov	r12,1
8000541e:	f0 1f 00 0d 	mcall	80005450 <spi_setupChipReg+0xe0>
80005422:	48 b8       	lddpc	r8,8000544c <spi_setupChipReg+0xdc>
80005424:	91 0c       	st.w	r8[0x0],r12
80005426:	58 0c       	cp.w	r12,0
80005428:	c0 a0       	breq	8000543c <spi_setupChipReg+0xcc>
8000542a:	30 09       	mov	r9,0
8000542c:	12 9a       	mov	r10,r9
8000542e:	12 9b       	mov	r11,r9
80005430:	f0 1f 00 09 	mcall	80005454 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005434:	48 68       	lddpc	r8,8000544c <spi_setupChipReg+0xdc>
80005436:	70 08       	ld.w	r8,r8[0x0]
80005438:	58 08       	cp.w	r8,0
8000543a:	c0 51       	brne	80005444 <spi_setupChipReg+0xd4>
8000543c:	c0 08       	rjmp	8000543c <spi_setupChipReg+0xcc>
8000543e:	30 2c       	mov	r12,2
80005440:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005444:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	52 a8       	stdsp	sp[0xa8],r8
8000544c:	00 00       	add	r0,r0
8000544e:	41 0c       	lddsp	r12,sp[0x40]
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	5f 3c       	srlo	r12
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	5e 3c       	retlo	r12

80005458 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005458:	d4 01       	pushm	lr
8000545a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000545e:	c0 58       	rjmp	80005468 <spi_unselectChip+0x10>
		if (!timeout--) {
80005460:	58 08       	cp.w	r8,0
80005462:	c0 21       	brne	80005466 <spi_unselectChip+0xe>
80005464:	da 0a       	popm	pc,r12=1
80005466:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005468:	78 49       	ld.w	r9,r12[0x10]
8000546a:	e2 19 02 00 	andl	r9,0x200,COH
8000546e:	cf 90       	breq	80005460 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005470:	78 18       	ld.w	r8,r12[0x4]
80005472:	ea 18 00 0f 	orh	r8,0xf
80005476:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005478:	fc 18 01 00 	movh	r8,0x100
8000547c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000547e:	30 09       	mov	r9,0
80005480:	12 9a       	mov	r10,r9
80005482:	12 9b       	mov	r11,r9
80005484:	48 38       	lddpc	r8,80005490 <spi_unselectChip+0x38>
80005486:	70 0c       	ld.w	r12,r8[0x0]
80005488:	f0 1f 00 03 	mcall	80005494 <spi_unselectChip+0x3c>
8000548c:	d8 0a       	popm	pc,r12=0
8000548e:	00 00       	add	r0,r0
80005490:	00 00       	add	r0,r0
80005492:	41 0c       	lddsp	r12,sp[0x40]
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	5e 3c       	retlo	r12

80005498 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005498:	eb cd 40 f8 	pushm	r3-r7,lr
8000549c:	18 94       	mov	r4,r12
8000549e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800054a0:	49 a6       	lddpc	r6,80005508 <spi_selectChip+0x70>
800054a2:	30 07       	mov	r7,0
800054a4:	31 45       	mov	r5,20
800054a6:	0e 99       	mov	r9,r7
800054a8:	0a 9a       	mov	r10,r5
800054aa:	0e 9b       	mov	r11,r7
800054ac:	6c 0c       	ld.w	r12,r6[0x0]
800054ae:	f0 1f 00 18 	mcall	8000550c <spi_selectChip+0x74>
800054b2:	cf a0       	breq	800054a6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800054b4:	68 18       	ld.w	r8,r4[0x4]
800054b6:	ea 18 00 0f 	orh	r8,0xf
800054ba:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800054bc:	68 18       	ld.w	r8,r4[0x4]
800054be:	e2 18 00 04 	andl	r8,0x4,COH
800054c2:	c1 10       	breq	800054e4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800054c4:	30 e8       	mov	r8,14
800054c6:	f0 03 18 00 	cp.b	r3,r8
800054ca:	e0 8b 00 1c 	brhi	80005502 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800054ce:	68 19       	ld.w	r9,r4[0x4]
800054d0:	e6 08 15 10 	lsl	r8,r3,0x10
800054d4:	ea 18 ff f0 	orh	r8,0xfff0
800054d8:	e8 18 ff ff 	orl	r8,0xffff
800054dc:	12 68       	and	r8,r9
800054de:	89 18       	st.w	r4[0x4],r8
800054e0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800054e4:	30 38       	mov	r8,3
800054e6:	f0 03 18 00 	cp.b	r3,r8
800054ea:	e0 8b 00 0c 	brhi	80005502 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800054ee:	68 19       	ld.w	r9,r4[0x4]
800054f0:	2f 03       	sub	r3,-16
800054f2:	30 18       	mov	r8,1
800054f4:	f0 03 09 48 	lsl	r8,r8,r3
800054f8:	5c d8       	com	r8
800054fa:	12 68       	and	r8,r9
800054fc:	89 18       	st.w	r4[0x4],r8
800054fe:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005502:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005504:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005508:	00 00       	add	r0,r0
8000550a:	41 0c       	lddsp	r12,sp[0x40]
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	5c 30       	neg	r0

80005510 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005510:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005512:	f6 08 15 04 	lsl	r8,r11,0x4
80005516:	14 38       	cp.w	r8,r10
80005518:	f9 b8 08 10 	movls	r8,16
8000551c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005520:	f0 0b 02 4b 	mul	r11,r8,r11
80005524:	f6 09 16 01 	lsr	r9,r11,0x1
80005528:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000552c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005530:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005534:	f2 cb 00 01 	sub	r11,r9,1
80005538:	e0 4b ff fe 	cp.w	r11,65534
8000553c:	e0 88 00 03 	brls	80005542 <usart_set_async_baudrate+0x32>
80005540:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005542:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005544:	e8 6e 00 00 	mov	lr,524288
80005548:	59 08       	cp.w	r8,16
8000554a:	fc 08 17 10 	movne	r8,lr
8000554e:	f9 b8 00 00 	moveq	r8,0
80005552:	e4 1b ff f7 	andh	r11,0xfff7
80005556:	e0 1b fe cf 	andl	r11,0xfecf
8000555a:	16 48       	or	r8,r11
8000555c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000555e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005562:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005566:	99 89       	st.w	r12[0x20],r9
80005568:	d8 0a       	popm	pc,r12=0

8000556a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000556a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000556c:	e2 18 00 02 	andl	r8,0x2,COH
80005570:	c0 31       	brne	80005576 <usart_write_char+0xc>
80005572:	30 2c       	mov	r12,2
80005574:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005576:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000557a:	99 7b       	st.w	r12[0x1c],r11
8000557c:	5e fd       	retal	0
8000557e:	d7 03       	nop

80005580 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005580:	eb cd 40 e0 	pushm	r5-r7,lr
80005584:	18 96       	mov	r6,r12
80005586:	16 95       	mov	r5,r11
80005588:	e0 67 27 0f 	mov	r7,9999
8000558c:	c0 68       	rjmp	80005598 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000558e:	58 07       	cp.w	r7,0
80005590:	c0 31       	brne	80005596 <usart_putchar+0x16>
80005592:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005596:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005598:	0a 9b       	mov	r11,r5
8000559a:	0c 9c       	mov	r12,r6
8000559c:	f0 1f 00 03 	mcall	800055a8 <usart_putchar+0x28>
800055a0:	cf 71       	brne	8000558e <usart_putchar+0xe>

  return USART_SUCCESS;
}
800055a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800055a6:	00 00       	add	r0,r0
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	55 6a       	stdsp	sp[0x158],r10

800055ac <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800055ac:	78 58       	ld.w	r8,r12[0x14]
800055ae:	e2 18 00 e0 	andl	r8,0xe0,COH
800055b2:	c0 30       	breq	800055b8 <usart_read_char+0xc>
800055b4:	30 4c       	mov	r12,4
800055b6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800055b8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800055ba:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055be:	c0 31       	brne	800055c4 <usart_read_char+0x18>
800055c0:	30 3c       	mov	r12,3
800055c2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800055c4:	78 68       	ld.w	r8,r12[0x18]
800055c6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800055ca:	97 08       	st.w	r11[0x0],r8
800055cc:	5e fd       	retal	0
800055ce:	d7 03       	nop

800055d0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800055d0:	eb cd 40 c0 	pushm	r6-r7,lr
800055d4:	20 1d       	sub	sp,4
800055d6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800055d8:	1a 97       	mov	r7,sp
800055da:	1a 9b       	mov	r11,sp
800055dc:	0c 9c       	mov	r12,r6
800055de:	f0 1f 00 07 	mcall	800055f8 <usart_getchar+0x28>
800055e2:	58 3c       	cp.w	r12,3
800055e4:	cf b0       	breq	800055da <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800055e6:	58 4c       	cp.w	r12,4
800055e8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800055ec:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800055f0:	2f fd       	sub	sp,-4
800055f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055f6:	00 00       	add	r0,r0
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	55 ac       	stdsp	sp[0x168],r12

800055fc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800055fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005600:	18 96       	mov	r6,r12
80005602:	16 97       	mov	r7,r11
  while (*string != '\0')
80005604:	17 8b       	ld.ub	r11,r11[0x0]
80005606:	58 0b       	cp.w	r11,0
80005608:	c0 80       	breq	80005618 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000560a:	2f f7       	sub	r7,-1
8000560c:	0c 9c       	mov	r12,r6
8000560e:	f0 1f 00 04 	mcall	8000561c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005612:	0f 8b       	ld.ub	r11,r7[0x0]
80005614:	58 0b       	cp.w	r11,0
80005616:	cf a1       	brne	8000560a <usart_write_line+0xe>
80005618:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	55 80       	stdsp	sp[0x160],r0

80005620 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005620:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005624:	e6 18 00 01 	andh	r8,0x1,COH
80005628:	c0 71       	brne	80005636 <usart_reset+0x16>
8000562a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000562c:	3f f8       	mov	r8,-1
8000562e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005630:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005632:	d5 03       	csrf	0x10
80005634:	c0 48       	rjmp	8000563c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005636:	3f f8       	mov	r8,-1
80005638:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000563a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000563c:	30 08       	mov	r8,0
8000563e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005640:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005642:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005644:	ea 68 61 0c 	mov	r8,680204
80005648:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000564a:	5e fc       	retal	r12

8000564c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000564c:	eb cd 40 e0 	pushm	r5-r7,lr
80005650:	18 96       	mov	r6,r12
80005652:	16 97       	mov	r7,r11
80005654:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005656:	f0 1f 00 2f 	mcall	80005710 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000565a:	58 07       	cp.w	r7,0
8000565c:	c5 80       	breq	8000570c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000565e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005660:	30 49       	mov	r9,4
80005662:	f2 08 18 00 	cp.b	r8,r9
80005666:	e0 88 00 53 	brls	8000570c <usart_init_rs232+0xc0>
8000566a:	30 99       	mov	r9,9
8000566c:	f2 08 18 00 	cp.b	r8,r9
80005670:	e0 8b 00 4e 	brhi	8000570c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005674:	0f d9       	ld.ub	r9,r7[0x5]
80005676:	30 78       	mov	r8,7
80005678:	f0 09 18 00 	cp.b	r9,r8
8000567c:	e0 8b 00 48 	brhi	8000570c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005680:	8e 39       	ld.sh	r9,r7[0x6]
80005682:	e0 68 01 01 	mov	r8,257
80005686:	f0 09 19 00 	cp.h	r9,r8
8000568a:	e0 8b 00 41 	brhi	8000570c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000568e:	ef 39 00 08 	ld.ub	r9,r7[8]
80005692:	30 38       	mov	r8,3
80005694:	f0 09 18 00 	cp.b	r9,r8
80005698:	e0 8b 00 3a 	brhi	8000570c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
8000569c:	0a 9a       	mov	r10,r5
8000569e:	6e 0b       	ld.w	r11,r7[0x0]
800056a0:	0c 9c       	mov	r12,r6
800056a2:	f0 1f 00 1d 	mcall	80005714 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800056a6:	58 1c       	cp.w	r12,1
800056a8:	c3 20       	breq	8000570c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800056aa:	0f c8       	ld.ub	r8,r7[0x4]
800056ac:	30 99       	mov	r9,9
800056ae:	f2 08 18 00 	cp.b	r8,r9
800056b2:	c0 51       	brne	800056bc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800056b4:	6c 18       	ld.w	r8,r6[0x4]
800056b6:	b1 b8       	sbr	r8,0x11
800056b8:	8d 18       	st.w	r6[0x4],r8
800056ba:	c0 68       	rjmp	800056c6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800056bc:	6c 19       	ld.w	r9,r6[0x4]
800056be:	20 58       	sub	r8,5
800056c0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800056c4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800056c6:	6c 19       	ld.w	r9,r6[0x4]
800056c8:	ef 3a 00 08 	ld.ub	r10,r7[8]
800056cc:	0f d8       	ld.ub	r8,r7[0x5]
800056ce:	a9 78       	lsl	r8,0x9
800056d0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800056d4:	12 48       	or	r8,r9
800056d6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800056d8:	8e 38       	ld.sh	r8,r7[0x6]
800056da:	30 29       	mov	r9,2
800056dc:	f2 08 19 00 	cp.h	r8,r9
800056e0:	e0 88 00 09 	brls	800056f2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800056e4:	6c 18       	ld.w	r8,r6[0x4]
800056e6:	ad b8       	sbr	r8,0xd
800056e8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800056ea:	8e b8       	ld.uh	r8,r7[0x6]
800056ec:	20 28       	sub	r8,2
800056ee:	8d a8       	st.w	r6[0x28],r8
800056f0:	c0 68       	rjmp	800056fc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800056f2:	6c 19       	ld.w	r9,r6[0x4]
800056f4:	5c 78       	castu.h	r8
800056f6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800056fa:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800056fc:	6c 18       	ld.w	r8,r6[0x4]
800056fe:	e0 18 ff f0 	andl	r8,0xfff0
80005702:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005704:	35 08       	mov	r8,80
80005706:	8d 08       	st.w	r6[0x0],r8
80005708:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000570c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	56 20       	stdsp	sp[0x188],r0
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	55 10       	stdsp	sp[0x144],r0

80005718 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005718:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000571c:	fe c0 8f 1c 	sub	r0,pc,-28900

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005720:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005724:	d5 53       	csrf	0x15
  cp      r0, r1
80005726:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005728:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000572c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000572e:	c0 62       	brcc	8000573a <idata_load_loop_end>
  cp      r0, r1
80005730:	48 92       	lddpc	r2,80005754 <udata_clear_loop_end+0x4>

80005732 <idata_load_loop>:
  brlo    idata_load_loop
80005732:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005734:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005736:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005738:	cf d3       	brcs	80005732 <idata_load_loop>

8000573a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000573a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000573e:	e0 61 41 20 	mov	r1,16672
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005742:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005744:	c0 62       	brcc	80005750 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005746:	30 02       	mov	r2,0
80005748:	30 03       	mov	r3,0

8000574a <udata_clear_loop>:
8000574a:	a1 22       	st.d	r0++,r2
8000574c:	02 30       	cp.w	r0,r1
8000574e:	cf e3       	brcs	8000574a <udata_clear_loop>

80005750 <udata_clear_loop_end>:
80005750:	fe cf e9 c4 	sub	pc,pc,-5692
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	db 60       	acall	0xb6

80005758 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005758:	f8 c8 ff f8 	sub	r8,r12,-8
8000575c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000575e:	3f f9       	mov	r9,-1
80005760:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005762:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005764:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005766:	30 08       	mov	r8,0
80005768:	99 08       	st.w	r12[0x0],r8
}
8000576a:	5e fc       	retal	r12

8000576c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000576c:	30 08       	mov	r8,0
8000576e:	99 48       	st.w	r12[0x10],r8
}
80005770:	5e fc       	retal	r12

80005772 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005772:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005774:	70 19       	ld.w	r9,r8[0x4]
80005776:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005778:	78 19       	ld.w	r9,r12[0x4]
8000577a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000577c:	70 19       	ld.w	r9,r8[0x4]
8000577e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005780:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005782:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005784:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005786:	78 08       	ld.w	r8,r12[0x0]
80005788:	2f f8       	sub	r8,-1
8000578a:	99 08       	st.w	r12[0x0],r8
}
8000578c:	5e fc       	retal	r12

8000578e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000578e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005790:	5b fa       	cp.w	r10,-1
80005792:	c0 31       	brne	80005798 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005794:	78 48       	ld.w	r8,r12[0x10]
80005796:	c0 c8       	rjmp	800057ae <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005798:	f8 c8 ff f8 	sub	r8,r12,-8
8000579c:	70 19       	ld.w	r9,r8[0x4]
8000579e:	72 09       	ld.w	r9,r9[0x0]
800057a0:	12 3a       	cp.w	r10,r9
800057a2:	c0 63       	brcs	800057ae <vListInsert+0x20>
800057a4:	70 18       	ld.w	r8,r8[0x4]
800057a6:	70 19       	ld.w	r9,r8[0x4]
800057a8:	72 09       	ld.w	r9,r9[0x0]
800057aa:	12 3a       	cp.w	r10,r9
800057ac:	cf c2       	brcc	800057a4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800057ae:	70 19       	ld.w	r9,r8[0x4]
800057b0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800057b2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800057b4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800057b6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800057b8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800057ba:	78 08       	ld.w	r8,r12[0x0]
800057bc:	2f f8       	sub	r8,-1
800057be:	99 08       	st.w	r12[0x0],r8
}
800057c0:	5e fc       	retal	r12

800057c2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800057c2:	78 18       	ld.w	r8,r12[0x4]
800057c4:	78 29       	ld.w	r9,r12[0x8]
800057c6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800057c8:	78 28       	ld.w	r8,r12[0x8]
800057ca:	78 19       	ld.w	r9,r12[0x4]
800057cc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800057ce:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800057d0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800057d2:	18 39       	cp.w	r9,r12
800057d4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057d8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057dc:	30 09       	mov	r9,0
800057de:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057e0:	70 09       	ld.w	r9,r8[0x0]
800057e2:	20 19       	sub	r9,1
800057e4:	91 09       	st.w	r8[0x0],r9
}
800057e6:	5e fc       	retal	r12

800057e8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057e8:	e0 68 08 08 	mov	r8,2056
800057ec:	ea 18 08 08 	orh	r8,0x808
800057f0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057f2:	e0 68 09 09 	mov	r8,2313
800057f6:	ea 18 09 09 	orh	r8,0x909
800057fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057fc:	e0 68 0a 0a 	mov	r8,2570
80005800:	ea 18 0a 0a 	orh	r8,0xa0a
80005804:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005806:	e0 68 0b 0b 	mov	r8,2827
8000580a:	ea 18 0b 0b 	orh	r8,0xb0b
8000580e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005810:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005812:	e0 68 be ef 	mov	r8,48879
80005816:	ea 18 de ad 	orh	r8,0xdead
8000581a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000581c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000581e:	fc 18 00 40 	movh	r8,0x40
80005822:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005824:	e0 68 00 ff 	mov	r8,255
80005828:	ea 18 ff 00 	orh	r8,0xff00
8000582c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000582e:	e0 68 01 01 	mov	r8,257
80005832:	ea 18 01 01 	orh	r8,0x101
80005836:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005838:	e0 68 02 02 	mov	r8,514
8000583c:	ea 18 02 02 	orh	r8,0x202
80005840:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005842:	e0 68 03 03 	mov	r8,771
80005846:	ea 18 03 03 	orh	r8,0x303
8000584a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000584c:	e0 68 04 04 	mov	r8,1028
80005850:	ea 18 04 04 	orh	r8,0x404
80005854:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005856:	e0 68 05 05 	mov	r8,1285
8000585a:	ea 18 05 05 	orh	r8,0x505
8000585e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005860:	e0 68 06 06 	mov	r8,1542
80005864:	ea 18 06 06 	orh	r8,0x606
80005868:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000586a:	e0 68 07 07 	mov	r8,1799
8000586e:	ea 18 07 07 	orh	r8,0x707
80005872:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005874:	30 08       	mov	r8,0
80005876:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005878:	5e fc       	retal	r12
8000587a:	d7 03       	nop

8000587c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000587c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000587e:	48 38       	lddpc	r8,80005888 <vPortEnterCritical+0xc>
80005880:	70 09       	ld.w	r9,r8[0x0]
80005882:	2f f9       	sub	r9,-1
80005884:	91 09       	st.w	r8[0x0],r9
}
80005886:	5e fc       	retal	r12
80005888:	00 00       	add	r0,r0
8000588a:	05 30       	ld.ub	r0,r2++

8000588c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000588c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000588e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005890:	30 0a       	mov	r10,0
80005892:	14 9b       	mov	r11,r10
80005894:	49 2c       	lddpc	r12,800058dc <xPortStartScheduler+0x50>
80005896:	f0 1f 00 13 	mcall	800058e0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000589a:	e0 68 5d c0 	mov	r8,24000
8000589e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800058a2:	30 08       	mov	r8,0
800058a4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800058a8:	e0 68 0c d0 	mov	r8,3280
800058ac:	ea 18 00 00 	orh	r8,0x0
800058b0:	70 00       	ld.w	r0,r8[0x0]
800058b2:	60 0d       	ld.w	sp,r0[0x0]
800058b4:	1b 00       	ld.w	r0,sp++
800058b6:	e0 68 05 30 	mov	r8,1328
800058ba:	ea 18 00 00 	orh	r8,0x0
800058be:	91 00       	st.w	r8[0x0],r0
800058c0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800058c4:	2f ed       	sub	sp,-8
800058c6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800058ca:	fa f0 ff e0 	ld.w	r0,sp[-32]
800058ce:	e3 b0 00 00 	mtsr	0x0,r0
800058d2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058d6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058da:	d8 0a       	popm	pc,r12=0
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	59 a8       	cp.w	r8,26
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	51 9c       	stdsp	sp[0x64],r12

800058e4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058e4:	20 6d       	sub	sp,24
800058e6:	eb cd 00 ff 	pushm	r0-r7
800058ea:	fa c7 ff c0 	sub	r7,sp,-64
800058ee:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058f2:	ef 40 ff e0 	st.w	r7[-32],r0
800058f6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058fa:	ef 40 ff e4 	st.w	r7[-28],r0
800058fe:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005902:	e0 68 05 30 	mov	r8,1328
80005906:	ea 18 00 00 	orh	r8,0x0
8000590a:	70 00       	ld.w	r0,r8[0x0]
8000590c:	1a d0       	st.w	--sp,r0
8000590e:	f0 1f 00 1a 	mcall	80005974 <LABEL_RET_SCALL_263+0x14>
80005912:	e0 68 0c d0 	mov	r8,3280
80005916:	ea 18 00 00 	orh	r8,0x0
8000591a:	70 00       	ld.w	r0,r8[0x0]
8000591c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000591e:	f0 1f 00 17 	mcall	80005978 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005922:	e0 68 0c d0 	mov	r8,3280
80005926:	ea 18 00 00 	orh	r8,0x0
8000592a:	70 00       	ld.w	r0,r8[0x0]
8000592c:	60 0d       	ld.w	sp,r0[0x0]
8000592e:	1b 00       	ld.w	r0,sp++
80005930:	e0 68 05 30 	mov	r8,1328
80005934:	ea 18 00 00 	orh	r8,0x0
80005938:	91 00       	st.w	r8[0x0],r0
8000593a:	fa c7 ff d8 	sub	r7,sp,-40
8000593e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005942:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005946:	e0 61 05 30 	mov	r1,1328
8000594a:	ea 11 00 00 	orh	r1,0x0
8000594e:	62 02       	ld.w	r2,r1[0x0]
80005950:	58 02       	cp.w	r2,0
80005952:	c0 70       	breq	80005960 <LABEL_RET_SCALL_263>
80005954:	e4 c2 00 01 	sub	r2,r2,1
80005958:	83 02       	st.w	r1[0x0],r2
8000595a:	58 02       	cp.w	r2,0
8000595c:	c0 21       	brne	80005960 <LABEL_RET_SCALL_263>
8000595e:	b1 c0       	cbr	r0,0x10

80005960 <LABEL_RET_SCALL_263>:
80005960:	ef 40 ff f8 	st.w	r7[-8],r0
80005964:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005968:	ef 40 ff fc 	st.w	r7[-4],r0
8000596c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005970:	2f ad       	sub	sp,-24
80005972:	d6 13       	rets
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	58 7c       	cp.w	r12,7
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	5f c0       	srvs	r0

8000597c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000597c:	e1 b8 00 43 	mfsr	r8,0x10c
80005980:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005984:	5e fc       	retal	r12
80005986:	d7 03       	nop

80005988 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005988:	48 78       	lddpc	r8,800059a4 <vPortExitCritical+0x1c>
8000598a:	70 08       	ld.w	r8,r8[0x0]
8000598c:	58 08       	cp.w	r8,0
8000598e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005990:	48 58       	lddpc	r8,800059a4 <vPortExitCritical+0x1c>
80005992:	70 09       	ld.w	r9,r8[0x0]
80005994:	20 19       	sub	r9,1
80005996:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005998:	70 08       	ld.w	r8,r8[0x0]
8000599a:	58 08       	cp.w	r8,0
8000599c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000599e:	d5 03       	csrf	0x10
800059a0:	5e fc       	retal	r12
800059a2:	00 00       	add	r0,r0
800059a4:	00 00       	add	r0,r0
800059a6:	05 30       	ld.ub	r0,r2++

800059a8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800059a8:	eb cd 00 ff 	pushm	r0-r7
800059ac:	e0 68 05 30 	mov	r8,1328
800059b0:	ea 18 00 00 	orh	r8,0x0
800059b4:	70 00       	ld.w	r0,r8[0x0]
800059b6:	1a d0       	st.w	--sp,r0
800059b8:	7a 90       	ld.w	r0,sp[0x24]
800059ba:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059be:	58 10       	cp.w	r0,1
800059c0:	e0 8b 00 08 	brhi	800059d0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800059c4:	e0 68 0c d0 	mov	r8,3280
800059c8:	ea 18 00 00 	orh	r8,0x0
800059cc:	70 00       	ld.w	r0,r8[0x0]
800059ce:	81 0d       	st.w	r0[0x0],sp

800059d0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800059d0:	f0 1f 00 12 	mcall	80005a18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059d4:	f0 1f 00 12 	mcall	80005a1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800059d8:	f0 1f 00 12 	mcall	80005a20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059dc:	f0 1f 00 12 	mcall	80005a24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059e0:	7a 90       	ld.w	r0,sp[0x24]
800059e2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059e6:	58 10       	cp.w	r0,1
800059e8:	e0 8b 00 0e 	brhi	80005a04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059ec:	f0 1f 00 0c 	mcall	80005a1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059f0:	f0 1f 00 0e 	mcall	80005a28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800059f4:	f0 1f 00 0c 	mcall	80005a24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800059f8:	e0 68 0c d0 	mov	r8,3280
800059fc:	ea 18 00 00 	orh	r8,0x0
80005a00:	70 00       	ld.w	r0,r8[0x0]
80005a02:	60 0d       	ld.w	sp,r0[0x0]

80005a04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005a04:	1b 00       	ld.w	r0,sp++
80005a06:	e0 68 05 30 	mov	r8,1328
80005a0a:	ea 18 00 00 	orh	r8,0x0
80005a0e:	91 00       	st.w	r8[0x0],r0
80005a10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005a14:	d6 03       	rete
80005a16:	00 00       	add	r0,r0
80005a18:	80 00       	ld.sh	r0,r0[0x0]
80005a1a:	59 7c       	cp.w	r12,23
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	58 7c       	cp.w	r12,7
80005a20:	80 00       	ld.sh	r0,r0[0x0]
80005a22:	61 c4       	ld.w	r4,r0[0x70]
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	59 88       	cp.w	r8,24
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	5f c0       	srvs	r0

80005a2c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005a2c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005a2e:	f0 1f 00 02 	mcall	80005a34 <__malloc_lock+0x8>
}
80005a32:	d8 02       	popm	pc
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	5f b0       	srhi	r0

80005a38 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005a38:	d4 01       	pushm	lr
	xTaskResumeAll();
80005a3a:	f0 1f 00 02 	mcall	80005a40 <__malloc_unlock+0x8>
}
80005a3e:	d8 02       	popm	pc
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	63 6c       	ld.w	r12,r1[0x58]

80005a44 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a44:	d4 21       	pushm	r4-r7,lr
80005a46:	16 95       	mov	r5,r11
80005a48:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a4a:	58 0c       	cp.w	r12,0
80005a4c:	c0 30       	breq	80005a52 <_read+0xe>
80005a4e:	3f f7       	mov	r7,-1
80005a50:	c1 48       	rjmp	80005a78 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a52:	58 0a       	cp.w	r10,0
80005a54:	e0 89 00 04 	brgt	80005a5c <_read+0x18>
80005a58:	30 07       	mov	r7,0
80005a5a:	c0 f8       	rjmp	80005a78 <_read+0x34>
80005a5c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a5e:	48 84       	lddpc	r4,80005a7c <_read+0x38>
80005a60:	68 0c       	ld.w	r12,r4[0x0]
80005a62:	f0 1f 00 08 	mcall	80005a80 <_read+0x3c>
    if (c < 0)
80005a66:	c0 95       	brlt	80005a78 <_read+0x34>
      break;

    *ptr++ = c;
80005a68:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a6c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a6e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a72:	58 08       	cp.w	r8,0
80005a74:	fe 99 ff f6 	brgt	80005a60 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a78:	0e 9c       	mov	r12,r7
80005a7a:	d8 22       	popm	r4-r7,pc
80005a7c:	00 00       	add	r0,r0
80005a7e:	41 10       	lddsp	r0,sp[0x44]
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	55 d0       	stdsp	sp[0x174],r0

80005a84 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a84:	d4 21       	pushm	r4-r7,lr
80005a86:	16 95       	mov	r5,r11
80005a88:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a8a:	20 1c       	sub	r12,1
80005a8c:	58 2c       	cp.w	r12,2
80005a8e:	e0 8b 00 12 	brhi	80005ab2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a92:	58 0a       	cp.w	r10,0
80005a94:	c0 31       	brne	80005a9a <_write+0x16>
80005a96:	30 07       	mov	r7,0
80005a98:	c0 e8       	rjmp	80005ab4 <_write+0x30>
80005a9a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005a9c:	48 74       	lddpc	r4,80005ab8 <_write+0x34>
80005a9e:	68 0c       	ld.w	r12,r4[0x0]
80005aa0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005aa4:	f0 1f 00 06 	mcall	80005abc <_write+0x38>
80005aa8:	c0 55       	brlt	80005ab2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005aaa:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005aac:	0e 36       	cp.w	r6,r7
80005aae:	cf 81       	brne	80005a9e <_write+0x1a>
80005ab0:	c0 28       	rjmp	80005ab4 <_write+0x30>
80005ab2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005ab4:	0e 9c       	mov	r12,r7
80005ab6:	d8 22       	popm	r4-r7,pc
80005ab8:	00 00       	add	r0,r0
80005aba:	41 10       	lddsp	r0,sp[0x44]
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	55 80       	stdsp	sp[0x160],r0

80005ac0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005ac0:	eb cd 40 80 	pushm	r7,lr
80005ac4:	18 97       	mov	r7,r12
	if( pv )
80005ac6:	58 0c       	cp.w	r12,0
80005ac8:	c0 80       	breq	80005ad8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005aca:	f0 1f 00 05 	mcall	80005adc <vPortFree+0x1c>
		{
			free( pv );
80005ace:	0e 9c       	mov	r12,r7
80005ad0:	f0 1f 00 04 	mcall	80005ae0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005ad4:	f0 1f 00 04 	mcall	80005ae4 <vPortFree+0x24>
80005ad8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005adc:	80 00       	ld.sh	r0,r0[0x0]
80005ade:	5f b0       	srhi	r0
80005ae0:	80 00       	ld.sh	r0,r0[0x0]
80005ae2:	6e 10       	ld.w	r0,r7[0x4]
80005ae4:	80 00       	ld.sh	r0,r0[0x0]
80005ae6:	63 6c       	ld.w	r12,r1[0x58]

80005ae8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ae8:	eb cd 40 80 	pushm	r7,lr
80005aec:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005aee:	f0 1f 00 06 	mcall	80005b04 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005af2:	0e 9c       	mov	r12,r7
80005af4:	f0 1f 00 05 	mcall	80005b08 <pvPortMalloc+0x20>
80005af8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005afa:	f0 1f 00 05 	mcall	80005b0c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005afe:	0e 9c       	mov	r12,r7
80005b00:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	5f b0       	srhi	r0
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	6e 20       	ld.w	r0,r7[0x8]
80005b0c:	80 00       	ld.sh	r0,r0[0x0]
80005b0e:	63 6c       	ld.w	r12,r1[0x58]

80005b10 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005b10:	d4 01       	pushm	lr
80005b12:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005b14:	78 09       	ld.w	r9,r12[0x0]
80005b16:	58 09       	cp.w	r9,0
80005b18:	c1 10       	breq	80005b3a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005b1a:	78 3a       	ld.w	r10,r12[0xc]
80005b1c:	79 09       	ld.w	r9,r12[0x40]
80005b1e:	f4 09 00 09 	add	r9,r10,r9
80005b22:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005b24:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005b26:	14 39       	cp.w	r9,r10
80005b28:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005b2c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005b30:	79 0a       	ld.w	r10,r12[0x40]
80005b32:	78 3b       	ld.w	r11,r12[0xc]
80005b34:	10 9c       	mov	r12,r8
80005b36:	f0 1f 00 02 	mcall	80005b3c <prvCopyDataFromQueue+0x2c>
80005b3a:	d8 02       	popm	pc
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	72 68       	ld.w	r8,r9[0x18]

80005b40 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b40:	eb cd 40 c0 	pushm	r6-r7,lr
80005b44:	18 97       	mov	r7,r12
80005b46:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b48:	78 e8       	ld.w	r8,r12[0x38]
80005b4a:	58 08       	cp.w	r8,0
80005b4c:	c0 31       	brne	80005b52 <xQueueReceiveFromISR+0x12>
80005b4e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b52:	f0 1f 00 0e 	mcall	80005b88 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b56:	6e e8       	ld.w	r8,r7[0x38]
80005b58:	20 18       	sub	r8,1
80005b5a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b5c:	6f 18       	ld.w	r8,r7[0x44]
80005b5e:	5b f8       	cp.w	r8,-1
80005b60:	c0 d1       	brne	80005b7a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b62:	6e 48       	ld.w	r8,r7[0x10]
80005b64:	58 08       	cp.w	r8,0
80005b66:	c0 f0       	breq	80005b84 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b68:	ee cc ff f0 	sub	r12,r7,-16
80005b6c:	f0 1f 00 08 	mcall	80005b8c <xQueueReceiveFromISR+0x4c>
80005b70:	c0 a0       	breq	80005b84 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b72:	30 1c       	mov	r12,1
80005b74:	8d 0c       	st.w	r6[0x0],r12
80005b76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b7a:	2f f8       	sub	r8,-1
80005b7c:	ef 48 00 44 	st.w	r7[68],r8
80005b80:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b84:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	5b 10       	cp.w	r0,-15
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	61 48       	ld.w	r8,r0[0x50]

80005b90 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b90:	eb cd 40 c0 	pushm	r6-r7,lr
80005b94:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005b96:	f0 1f 00 23 	mcall	80005c20 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b9a:	6f 28       	ld.w	r8,r7[0x48]
80005b9c:	58 08       	cp.w	r8,0
80005b9e:	e0 8a 00 18 	brle	80005bce <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ba2:	6e 98       	ld.w	r8,r7[0x24]
80005ba4:	58 08       	cp.w	r8,0
80005ba6:	c1 40       	breq	80005bce <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ba8:	ee c6 ff dc 	sub	r6,r7,-36
80005bac:	c0 48       	rjmp	80005bb4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005bae:	6e 98       	ld.w	r8,r7[0x24]
80005bb0:	58 08       	cp.w	r8,0
80005bb2:	c0 e0       	breq	80005bce <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005bb4:	0c 9c       	mov	r12,r6
80005bb6:	f0 1f 00 1c 	mcall	80005c24 <prvUnlockQueue+0x94>
80005bba:	c0 30       	breq	80005bc0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005bbc:	f0 1f 00 1b 	mcall	80005c28 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005bc0:	6f 28       	ld.w	r8,r7[0x48]
80005bc2:	20 18       	sub	r8,1
80005bc4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005bc8:	58 08       	cp.w	r8,0
80005bca:	fe 99 ff f2 	brgt	80005bae <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005bce:	3f f8       	mov	r8,-1
80005bd0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005bd4:	f0 1f 00 16 	mcall	80005c2c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005bd8:	f0 1f 00 12 	mcall	80005c20 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bdc:	6f 18       	ld.w	r8,r7[0x44]
80005bde:	58 08       	cp.w	r8,0
80005be0:	e0 8a 00 18 	brle	80005c10 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005be4:	6e 48       	ld.w	r8,r7[0x10]
80005be6:	58 08       	cp.w	r8,0
80005be8:	c1 40       	breq	80005c10 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bea:	ee c6 ff f0 	sub	r6,r7,-16
80005bee:	c0 48       	rjmp	80005bf6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bf0:	6e 48       	ld.w	r8,r7[0x10]
80005bf2:	58 08       	cp.w	r8,0
80005bf4:	c0 e0       	breq	80005c10 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bf6:	0c 9c       	mov	r12,r6
80005bf8:	f0 1f 00 0b 	mcall	80005c24 <prvUnlockQueue+0x94>
80005bfc:	c0 30       	breq	80005c02 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005bfe:	f0 1f 00 0b 	mcall	80005c28 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005c02:	6f 18       	ld.w	r8,r7[0x44]
80005c04:	20 18       	sub	r8,1
80005c06:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c0a:	58 08       	cp.w	r8,0
80005c0c:	fe 99 ff f2 	brgt	80005bf0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005c10:	3f f8       	mov	r8,-1
80005c12:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005c16:	f0 1f 00 06 	mcall	80005c2c <prvUnlockQueue+0x9c>
}
80005c1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c1e:	00 00       	add	r0,r0
80005c20:	80 00       	ld.sh	r0,r0[0x0]
80005c22:	58 7c       	cp.w	r12,7
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	61 48       	ld.w	r8,r0[0x50]
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	60 54       	ld.w	r4,r0[0x14]
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	59 88       	cp.w	r8,24

80005c30 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005c30:	d4 31       	pushm	r0-r7,lr
80005c32:	20 5d       	sub	sp,20
80005c34:	18 97       	mov	r7,r12
80005c36:	50 0b       	stdsp	sp[0x0],r11
80005c38:	50 2a       	stdsp	sp[0x8],r10
80005c3a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c3c:	f8 c2 ff dc 	sub	r2,r12,-36
80005c40:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c42:	fa c4 ff f4 	sub	r4,sp,-12
80005c46:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c48:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c4a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c4e:	f0 1f 00 3e 	mcall	80005d44 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c52:	6e e8       	ld.w	r8,r7[0x38]
80005c54:	58 08       	cp.w	r8,0
80005c56:	c2 a0       	breq	80005caa <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c58:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c5a:	40 0b       	lddsp	r11,sp[0x0]
80005c5c:	0e 9c       	mov	r12,r7
80005c5e:	f0 1f 00 3b 	mcall	80005d48 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c62:	40 18       	lddsp	r8,sp[0x4]
80005c64:	58 08       	cp.w	r8,0
80005c66:	c1 51       	brne	80005c90 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c68:	6e e8       	ld.w	r8,r7[0x38]
80005c6a:	20 18       	sub	r8,1
80005c6c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c6e:	6e 08       	ld.w	r8,r7[0x0]
80005c70:	58 08       	cp.w	r8,0
80005c72:	c0 41       	brne	80005c7a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c74:	f0 1f 00 36 	mcall	80005d4c <xQueueGenericReceive+0x11c>
80005c78:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c7a:	6e 48       	ld.w	r8,r7[0x10]
80005c7c:	58 08       	cp.w	r8,0
80005c7e:	c1 20       	breq	80005ca2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c80:	ee cc ff f0 	sub	r12,r7,-16
80005c84:	f0 1f 00 33 	mcall	80005d50 <xQueueGenericReceive+0x120>
80005c88:	58 1c       	cp.w	r12,1
80005c8a:	c0 c1       	brne	80005ca2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c8c:	d7 33       	scall
80005c8e:	c0 a8       	rjmp	80005ca2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c90:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c92:	6e 98       	ld.w	r8,r7[0x24]
80005c94:	58 08       	cp.w	r8,0
80005c96:	c0 60       	breq	80005ca2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c98:	04 9c       	mov	r12,r2
80005c9a:	f0 1f 00 2e 	mcall	80005d50 <xQueueGenericReceive+0x120>
80005c9e:	c0 20       	breq	80005ca2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005ca0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005ca2:	f0 1f 00 2d 	mcall	80005d54 <xQueueGenericReceive+0x124>
80005ca6:	30 1c       	mov	r12,1
				return pdPASS;
80005ca8:	c4 c8       	rjmp	80005d40 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005caa:	40 28       	lddsp	r8,sp[0x8]
80005cac:	58 08       	cp.w	r8,0
80005cae:	c0 51       	brne	80005cb8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005cb0:	f0 1f 00 29 	mcall	80005d54 <xQueueGenericReceive+0x124>
80005cb4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005cb6:	c4 58       	rjmp	80005d40 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005cb8:	58 05       	cp.w	r5,0
80005cba:	c0 51       	brne	80005cc4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005cbc:	08 9c       	mov	r12,r4
80005cbe:	f0 1f 00 27 	mcall	80005d58 <xQueueGenericReceive+0x128>
80005cc2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005cc4:	f0 1f 00 24 	mcall	80005d54 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005cc8:	f0 1f 00 25 	mcall	80005d5c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005ccc:	f0 1f 00 1e 	mcall	80005d44 <xQueueGenericReceive+0x114>
80005cd0:	6f 18       	ld.w	r8,r7[0x44]
80005cd2:	5b f8       	cp.w	r8,-1
80005cd4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005cd8:	6f 28       	ld.w	r8,r7[0x48]
80005cda:	5b f8       	cp.w	r8,-1
80005cdc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ce0:	f0 1f 00 1d 	mcall	80005d54 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ce4:	06 9b       	mov	r11,r3
80005ce6:	08 9c       	mov	r12,r4
80005ce8:	f0 1f 00 1e 	mcall	80005d60 <xQueueGenericReceive+0x130>
80005cec:	c2 41       	brne	80005d34 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cee:	f0 1f 00 16 	mcall	80005d44 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cf2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005cf4:	f0 1f 00 18 	mcall	80005d54 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005cf8:	58 06       	cp.w	r6,0
80005cfa:	c1 71       	brne	80005d28 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cfc:	6e 08       	ld.w	r8,r7[0x0]
80005cfe:	58 08       	cp.w	r8,0
80005d00:	c0 81       	brne	80005d10 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005d02:	f0 1f 00 11 	mcall	80005d44 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005d06:	6e 1c       	ld.w	r12,r7[0x4]
80005d08:	f0 1f 00 17 	mcall	80005d64 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005d0c:	f0 1f 00 12 	mcall	80005d54 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005d10:	40 2b       	lddsp	r11,sp[0x8]
80005d12:	04 9c       	mov	r12,r2
80005d14:	f0 1f 00 15 	mcall	80005d68 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005d18:	0e 9c       	mov	r12,r7
80005d1a:	f0 1f 00 15 	mcall	80005d6c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005d1e:	f0 1f 00 15 	mcall	80005d70 <xQueueGenericReceive+0x140>
80005d22:	c9 61       	brne	80005c4e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005d24:	d7 33       	scall
80005d26:	c9 4b       	rjmp	80005c4e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005d28:	0e 9c       	mov	r12,r7
80005d2a:	f0 1f 00 11 	mcall	80005d6c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005d2e:	f0 1f 00 11 	mcall	80005d70 <xQueueGenericReceive+0x140>
80005d32:	c8 eb       	rjmp	80005c4e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005d34:	0e 9c       	mov	r12,r7
80005d36:	f0 1f 00 0e 	mcall	80005d6c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005d3a:	f0 1f 00 0e 	mcall	80005d70 <xQueueGenericReceive+0x140>
80005d3e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d40:	2f bd       	sub	sp,-20
80005d42:	d8 32       	popm	r0-r7,pc
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	58 7c       	cp.w	r12,7
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	5b 10       	cp.w	r0,-15
80005d4c:	80 00       	ld.sh	r0,r0[0x0]
80005d4e:	60 60       	ld.w	r0,r0[0x18]
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	61 48       	ld.w	r8,r0[0x50]
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	59 88       	cp.w	r8,24
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	60 3c       	ld.w	r12,r0[0xc]
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	5f b0       	srhi	r0
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	62 d8       	ld.w	r8,r1[0x34]
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	60 c4       	ld.w	r4,r0[0x30]
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	65 30       	ld.w	r0,r2[0x4c]
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	5b 90       	cp.w	r0,-7
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	63 6c       	ld.w	r12,r1[0x58]

80005d74 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d74:	eb cd 40 80 	pushm	r7,lr
80005d78:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d7a:	79 08       	ld.w	r8,r12[0x40]
80005d7c:	58 08       	cp.w	r8,0
80005d7e:	c0 a1       	brne	80005d92 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d80:	78 08       	ld.w	r8,r12[0x0]
80005d82:	58 08       	cp.w	r8,0
80005d84:	c2 b1       	brne	80005dda <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d86:	78 1c       	ld.w	r12,r12[0x4]
80005d88:	f0 1f 00 17 	mcall	80005de4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d8c:	30 08       	mov	r8,0
80005d8e:	8f 18       	st.w	r7[0x4],r8
80005d90:	c2 58       	rjmp	80005dda <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d92:	58 0a       	cp.w	r10,0
80005d94:	c1 01       	brne	80005db4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d96:	10 9a       	mov	r10,r8
80005d98:	78 2c       	ld.w	r12,r12[0x8]
80005d9a:	f0 1f 00 14 	mcall	80005de8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005d9e:	6e 29       	ld.w	r9,r7[0x8]
80005da0:	6f 08       	ld.w	r8,r7[0x40]
80005da2:	f2 08 00 08 	add	r8,r9,r8
80005da6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005da8:	6e 19       	ld.w	r9,r7[0x4]
80005daa:	12 38       	cp.w	r8,r9
80005dac:	c1 73       	brcs	80005dda <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005dae:	6e 08       	ld.w	r8,r7[0x0]
80005db0:	8f 28       	st.w	r7[0x8],r8
80005db2:	c1 48       	rjmp	80005dda <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005db4:	10 9a       	mov	r10,r8
80005db6:	78 3c       	ld.w	r12,r12[0xc]
80005db8:	f0 1f 00 0c 	mcall	80005de8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005dbc:	6f 08       	ld.w	r8,r7[0x40]
80005dbe:	6e 39       	ld.w	r9,r7[0xc]
80005dc0:	f2 08 01 08 	sub	r8,r9,r8
80005dc4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005dc6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005dc8:	12 38       	cp.w	r8,r9
80005dca:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005dce:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005dd2:	f3 d8 e3 19 	subcs	r9,r9,r8
80005dd6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005dda:	6e e8       	ld.w	r8,r7[0x38]
80005ddc:	2f f8       	sub	r8,-1
80005dde:	8f e8       	st.w	r7[0x38],r8
}
80005de0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	60 6c       	ld.w	r12,r0[0x18]
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	72 68       	ld.w	r8,r9[0x18]

80005dec <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005dec:	eb cd 40 c0 	pushm	r6-r7,lr
80005df0:	18 97       	mov	r7,r12
80005df2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005df4:	78 ec       	ld.w	r12,r12[0x38]
80005df6:	6e f8       	ld.w	r8,r7[0x3c]
80005df8:	10 3c       	cp.w	r12,r8
80005dfa:	c0 33       	brcs	80005e00 <xQueueGenericSendFromISR+0x14>
80005dfc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e00:	12 9a       	mov	r10,r9
80005e02:	0e 9c       	mov	r12,r7
80005e04:	f0 1f 00 0c 	mcall	80005e34 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005e08:	6f 28       	ld.w	r8,r7[0x48]
80005e0a:	5b f8       	cp.w	r8,-1
80005e0c:	c0 d1       	brne	80005e26 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e0e:	6e 98       	ld.w	r8,r7[0x24]
80005e10:	58 08       	cp.w	r8,0
80005e12:	c0 f0       	breq	80005e30 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005e14:	ee cc ff dc 	sub	r12,r7,-36
80005e18:	f0 1f 00 08 	mcall	80005e38 <xQueueGenericSendFromISR+0x4c>
80005e1c:	c0 a0       	breq	80005e30 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005e1e:	30 1c       	mov	r12,1
80005e20:	8d 0c       	st.w	r6[0x0],r12
80005e22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005e26:	2f f8       	sub	r8,-1
80005e28:	ef 48 00 48 	st.w	r7[72],r8
80005e2c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e30:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	5d 74       	*unknown*
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	61 48       	ld.w	r8,r0[0x50]

80005e3c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e3c:	d4 31       	pushm	r0-r7,lr
80005e3e:	20 5d       	sub	sp,20
80005e40:	18 97       	mov	r7,r12
80005e42:	50 0b       	stdsp	sp[0x0],r11
80005e44:	50 2a       	stdsp	sp[0x8],r10
80005e46:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e48:	f8 c0 ff f0 	sub	r0,r12,-16
80005e4c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e4e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e52:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e54:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e58:	f0 1f 00 2f 	mcall	80005f14 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e5c:	6e e9       	ld.w	r9,r7[0x38]
80005e5e:	6e f8       	ld.w	r8,r7[0x3c]
80005e60:	10 39       	cp.w	r9,r8
80005e62:	c1 42       	brcc	80005e8a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e64:	40 1a       	lddsp	r10,sp[0x4]
80005e66:	40 0b       	lddsp	r11,sp[0x0]
80005e68:	0e 9c       	mov	r12,r7
80005e6a:	f0 1f 00 2c 	mcall	80005f18 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e6e:	6e 98       	ld.w	r8,r7[0x24]
80005e70:	58 08       	cp.w	r8,0
80005e72:	c0 80       	breq	80005e82 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e74:	ee cc ff dc 	sub	r12,r7,-36
80005e78:	f0 1f 00 29 	mcall	80005f1c <xQueueGenericSend+0xe0>
80005e7c:	58 1c       	cp.w	r12,1
80005e7e:	c0 21       	brne	80005e82 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e80:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e82:	f0 1f 00 28 	mcall	80005f20 <xQueueGenericSend+0xe4>
80005e86:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e88:	c4 38       	rjmp	80005f0e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e8a:	40 28       	lddsp	r8,sp[0x8]
80005e8c:	58 08       	cp.w	r8,0
80005e8e:	c0 51       	brne	80005e98 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e90:	f0 1f 00 24 	mcall	80005f20 <xQueueGenericSend+0xe4>
80005e94:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005e96:	c3 c8       	rjmp	80005f0e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005e98:	58 04       	cp.w	r4,0
80005e9a:	c0 51       	brne	80005ea4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e9c:	06 9c       	mov	r12,r3
80005e9e:	f0 1f 00 22 	mcall	80005f24 <xQueueGenericSend+0xe8>
80005ea2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005ea4:	f0 1f 00 1f 	mcall	80005f20 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005ea8:	f0 1f 00 20 	mcall	80005f28 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005eac:	f0 1f 00 1a 	mcall	80005f14 <xQueueGenericSend+0xd8>
80005eb0:	6f 18       	ld.w	r8,r7[0x44]
80005eb2:	5b f8       	cp.w	r8,-1
80005eb4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005eb8:	6f 28       	ld.w	r8,r7[0x48]
80005eba:	5b f8       	cp.w	r8,-1
80005ebc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ec0:	f0 1f 00 18 	mcall	80005f20 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ec4:	04 9b       	mov	r11,r2
80005ec6:	06 9c       	mov	r12,r3
80005ec8:	f0 1f 00 19 	mcall	80005f2c <xQueueGenericSend+0xf0>
80005ecc:	c1 b1       	brne	80005f02 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005ece:	f0 1f 00 12 	mcall	80005f14 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005ed2:	6e e5       	ld.w	r5,r7[0x38]
80005ed4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005ed6:	f0 1f 00 13 	mcall	80005f20 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005eda:	0c 35       	cp.w	r5,r6
80005edc:	c0 d1       	brne	80005ef6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ede:	40 2b       	lddsp	r11,sp[0x8]
80005ee0:	00 9c       	mov	r12,r0
80005ee2:	f0 1f 00 14 	mcall	80005f30 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005ee6:	0e 9c       	mov	r12,r7
80005ee8:	f0 1f 00 13 	mcall	80005f34 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005eec:	f0 1f 00 13 	mcall	80005f38 <xQueueGenericSend+0xfc>
80005ef0:	cb 41       	brne	80005e58 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005ef2:	d7 33       	scall
80005ef4:	cb 2b       	rjmp	80005e58 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005ef6:	0e 9c       	mov	r12,r7
80005ef8:	f0 1f 00 0f 	mcall	80005f34 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005efc:	f0 1f 00 0f 	mcall	80005f38 <xQueueGenericSend+0xfc>
80005f00:	ca cb       	rjmp	80005e58 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005f02:	0e 9c       	mov	r12,r7
80005f04:	f0 1f 00 0c 	mcall	80005f34 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005f08:	f0 1f 00 0c 	mcall	80005f38 <xQueueGenericSend+0xfc>
80005f0c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005f0e:	2f bd       	sub	sp,-20
80005f10:	d8 32       	popm	r0-r7,pc
80005f12:	00 00       	add	r0,r0
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	58 7c       	cp.w	r12,7
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	5d 74       	*unknown*
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	61 48       	ld.w	r8,r0[0x50]
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	59 88       	cp.w	r8,24
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	60 3c       	ld.w	r12,r0[0xc]
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	5f b0       	srhi	r0
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	62 d8       	ld.w	r8,r1[0x34]
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	65 30       	ld.w	r0,r2[0x4c]
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5b 90       	cp.w	r0,-7
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	63 6c       	ld.w	r12,r1[0x58]

80005f3c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f3c:	d4 21       	pushm	r4-r7,lr
80005f3e:	18 97       	mov	r7,r12
80005f40:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f42:	58 0c       	cp.w	r12,0
80005f44:	c2 f0       	breq	80005fa2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f46:	34 cc       	mov	r12,76
80005f48:	f0 1f 00 17 	mcall	80005fa4 <xQueueCreate+0x68>
80005f4c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f4e:	c2 a0       	breq	80005fa2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f50:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f54:	e8 cc ff ff 	sub	r12,r4,-1
80005f58:	f0 1f 00 13 	mcall	80005fa4 <xQueueCreate+0x68>
80005f5c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f5e:	c1 e0       	breq	80005f9a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f60:	f8 04 00 04 	add	r4,r12,r4
80005f64:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f66:	30 08       	mov	r8,0
80005f68:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f6a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f6c:	ee c8 00 01 	sub	r8,r7,1
80005f70:	ad 38       	mul	r8,r6
80005f72:	10 0c       	add	r12,r8
80005f74:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f76:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f78:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f7c:	3f f8       	mov	r8,-1
80005f7e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f82:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f86:	ea cc ff f0 	sub	r12,r5,-16
80005f8a:	f0 1f 00 08 	mcall	80005fa8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f8e:	ea cc ff dc 	sub	r12,r5,-36
80005f92:	f0 1f 00 06 	mcall	80005fa8 <xQueueCreate+0x6c>
80005f96:	0a 9c       	mov	r12,r5
80005f98:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005f9a:	0a 9c       	mov	r12,r5
80005f9c:	f0 1f 00 04 	mcall	80005fac <xQueueCreate+0x70>
80005fa0:	d8 2a       	popm	r4-r7,pc,r12=0
80005fa2:	d8 2a       	popm	r4-r7,pc,r12=0
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	5a e8       	cp.w	r8,-18
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	57 58       	stdsp	sp[0x1d4],r8
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	5a c0       	cp.w	r0,-20

80005fb0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005fb0:	48 38       	lddpc	r8,80005fbc <vTaskSuspendAll+0xc>
80005fb2:	70 09       	ld.w	r9,r8[0x0]
80005fb4:	2f f9       	sub	r9,-1
80005fb6:	91 09       	st.w	r8[0x0],r9
}
80005fb8:	5e fc       	retal	r12
80005fba:	00 00       	add	r0,r0
80005fbc:	00 00       	add	r0,r0
80005fbe:	0d 00       	ld.w	r0,r6++

80005fc0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005fc0:	49 a8       	lddpc	r8,80006028 <vTaskSwitchContext+0x68>
80005fc2:	70 08       	ld.w	r8,r8[0x0]
80005fc4:	58 08       	cp.w	r8,0
80005fc6:	c0 b1       	brne	80005fdc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fc8:	49 98       	lddpc	r8,8000602c <vTaskSwitchContext+0x6c>
80005fca:	70 08       	ld.w	r8,r8[0x0]
80005fcc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fd0:	49 89       	lddpc	r9,80006030 <vTaskSwitchContext+0x70>
80005fd2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005fd6:	58 08       	cp.w	r8,0
80005fd8:	c0 60       	breq	80005fe4 <vTaskSwitchContext+0x24>
80005fda:	c1 18       	rjmp	80005ffc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005fdc:	30 19       	mov	r9,1
80005fde:	49 68       	lddpc	r8,80006034 <vTaskSwitchContext+0x74>
80005fe0:	91 09       	st.w	r8[0x0],r9
80005fe2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fe4:	49 28       	lddpc	r8,8000602c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fe6:	49 3a       	lddpc	r10,80006030 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fe8:	70 09       	ld.w	r9,r8[0x0]
80005fea:	20 19       	sub	r9,1
80005fec:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fee:	70 09       	ld.w	r9,r8[0x0]
80005ff0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ff4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005ff8:	58 09       	cp.w	r9,0
80005ffa:	cf 70       	breq	80005fe8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005ffc:	48 c8       	lddpc	r8,8000602c <vTaskSwitchContext+0x6c>
80005ffe:	70 08       	ld.w	r8,r8[0x0]
80006000:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006004:	48 b9       	lddpc	r9,80006030 <vTaskSwitchContext+0x70>
80006006:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000600a:	70 19       	ld.w	r9,r8[0x4]
8000600c:	72 19       	ld.w	r9,r9[0x4]
8000600e:	91 19       	st.w	r8[0x4],r9
80006010:	f0 ca ff f8 	sub	r10,r8,-8
80006014:	14 39       	cp.w	r9,r10
80006016:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000601a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000601e:	70 18       	ld.w	r8,r8[0x4]
80006020:	70 39       	ld.w	r9,r8[0xc]
80006022:	48 68       	lddpc	r8,80006038 <vTaskSwitchContext+0x78>
80006024:	91 09       	st.w	r8[0x0],r9
80006026:	5e fc       	retal	r12
80006028:	00 00       	add	r0,r0
8000602a:	0d 00       	ld.w	r0,r6++
8000602c:	00 00       	add	r0,r0
8000602e:	0d 38       	ld.ub	r8,r6++
80006030:	00 00       	add	r0,r0
80006032:	0c 1c       	sub	r12,r6
80006034:	00 00       	add	r0,r0
80006036:	0d 20       	ld.uh	r0,r6++
80006038:	00 00       	add	r0,r0
8000603a:	0c d0       	st.w	--r6,r0

8000603c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000603c:	48 48       	lddpc	r8,8000604c <vTaskSetTimeOutState+0x10>
8000603e:	70 08       	ld.w	r8,r8[0x0]
80006040:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006042:	48 48       	lddpc	r8,80006050 <vTaskSetTimeOutState+0x14>
80006044:	70 08       	ld.w	r8,r8[0x0]
80006046:	99 18       	st.w	r12[0x4],r8
}
80006048:	5e fc       	retal	r12
8000604a:	00 00       	add	r0,r0
8000604c:	00 00       	add	r0,r0
8000604e:	0c 14       	sub	r4,r6
80006050:	00 00       	add	r0,r0
80006052:	0c fc       	st.b	--r6,r12

80006054 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006054:	30 19       	mov	r9,1
80006056:	48 28       	lddpc	r8,8000605c <vTaskMissedYield+0x8>
80006058:	91 09       	st.w	r8[0x0],r9
}
8000605a:	5e fc       	retal	r12
8000605c:	00 00       	add	r0,r0
8000605e:	0d 20       	ld.uh	r0,r6++

80006060 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006060:	48 28       	lddpc	r8,80006068 <xTaskGetCurrentTaskHandle+0x8>
80006062:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006064:	5e fc       	retal	r12
80006066:	00 00       	add	r0,r0
80006068:	00 00       	add	r0,r0
8000606a:	0c d0       	st.w	--r6,r0

8000606c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000606c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006070:	58 0c       	cp.w	r12,0
80006072:	c1 f0       	breq	800060b0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006074:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006076:	78 b9       	ld.w	r9,r12[0x2c]
80006078:	79 18       	ld.w	r8,r12[0x44]
8000607a:	10 39       	cp.w	r9,r8
8000607c:	c1 a0       	breq	800060b0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000607e:	f8 c6 ff fc 	sub	r6,r12,-4
80006082:	0c 9c       	mov	r12,r6
80006084:	f0 1f 00 0c 	mcall	800060b4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006088:	6f 1c       	ld.w	r12,r7[0x44]
8000608a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000608c:	f8 08 11 08 	rsub	r8,r12,8
80006090:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006092:	48 a8       	lddpc	r8,800060b8 <vTaskPriorityDisinherit+0x4c>
80006094:	70 08       	ld.w	r8,r8[0x0]
80006096:	10 3c       	cp.w	r12,r8
80006098:	e0 88 00 04 	brls	800060a0 <vTaskPriorityDisinherit+0x34>
8000609c:	48 78       	lddpc	r8,800060b8 <vTaskPriorityDisinherit+0x4c>
8000609e:	91 0c       	st.w	r8[0x0],r12
800060a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060a4:	0c 9b       	mov	r11,r6
800060a6:	48 68       	lddpc	r8,800060bc <vTaskPriorityDisinherit+0x50>
800060a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060ac:	f0 1f 00 05 	mcall	800060c0 <vTaskPriorityDisinherit+0x54>
800060b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	57 c2       	stdsp	sp[0x1f0],r2
800060b8:	00 00       	add	r0,r0
800060ba:	0d 38       	ld.ub	r8,r6++
800060bc:	00 00       	add	r0,r0
800060be:	0c 1c       	sub	r12,r6
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	57 72       	stdsp	sp[0x1dc],r2

800060c4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800060c4:	eb cd 40 c0 	pushm	r6-r7,lr
800060c8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800060ca:	49 b8       	lddpc	r8,80006134 <vTaskPriorityInherit+0x70>
800060cc:	70 08       	ld.w	r8,r8[0x0]
800060ce:	78 b9       	ld.w	r9,r12[0x2c]
800060d0:	70 b8       	ld.w	r8,r8[0x2c]
800060d2:	10 39       	cp.w	r9,r8
800060d4:	c2 d2       	brcc	8000612e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060d6:	49 88       	lddpc	r8,80006134 <vTaskPriorityInherit+0x70>
800060d8:	70 08       	ld.w	r8,r8[0x0]
800060da:	70 b8       	ld.w	r8,r8[0x2c]
800060dc:	f0 08 11 08 	rsub	r8,r8,8
800060e0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060e2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800060e6:	49 59       	lddpc	r9,80006138 <vTaskPriorityInherit+0x74>
800060e8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800060ec:	78 59       	ld.w	r9,r12[0x14]
800060ee:	10 39       	cp.w	r9,r8
800060f0:	c1 b1       	brne	80006126 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800060f2:	f8 c6 ff fc 	sub	r6,r12,-4
800060f6:	0c 9c       	mov	r12,r6
800060f8:	f0 1f 00 11 	mcall	8000613c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800060fc:	48 e8       	lddpc	r8,80006134 <vTaskPriorityInherit+0x70>
800060fe:	70 08       	ld.w	r8,r8[0x0]
80006100:	70 bc       	ld.w	r12,r8[0x2c]
80006102:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006104:	48 f8       	lddpc	r8,80006140 <vTaskPriorityInherit+0x7c>
80006106:	70 08       	ld.w	r8,r8[0x0]
80006108:	10 3c       	cp.w	r12,r8
8000610a:	e0 88 00 04 	brls	80006112 <vTaskPriorityInherit+0x4e>
8000610e:	48 d8       	lddpc	r8,80006140 <vTaskPriorityInherit+0x7c>
80006110:	91 0c       	st.w	r8[0x0],r12
80006112:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006116:	0c 9b       	mov	r11,r6
80006118:	48 88       	lddpc	r8,80006138 <vTaskPriorityInherit+0x74>
8000611a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000611e:	f0 1f 00 0a 	mcall	80006144 <vTaskPriorityInherit+0x80>
80006122:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006126:	48 48       	lddpc	r8,80006134 <vTaskPriorityInherit+0x70>
80006128:	70 08       	ld.w	r8,r8[0x0]
8000612a:	70 b8       	ld.w	r8,r8[0x2c]
8000612c:	99 b8       	st.w	r12[0x2c],r8
8000612e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006132:	00 00       	add	r0,r0
80006134:	00 00       	add	r0,r0
80006136:	0c d0       	st.w	--r6,r0
80006138:	00 00       	add	r0,r0
8000613a:	0c 1c       	sub	r12,r6
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	57 c2       	stdsp	sp[0x1f0],r2
80006140:	00 00       	add	r0,r0
80006142:	0d 38       	ld.ub	r8,r6++
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	57 72       	stdsp	sp[0x1dc],r2

80006148 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006148:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000614c:	78 38       	ld.w	r8,r12[0xc]
8000614e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006150:	ee c6 ff e8 	sub	r6,r7,-24
80006154:	0c 9c       	mov	r12,r6
80006156:	f0 1f 00 15 	mcall	800061a8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000615a:	49 58       	lddpc	r8,800061ac <xTaskRemoveFromEventList+0x64>
8000615c:	70 08       	ld.w	r8,r8[0x0]
8000615e:	58 08       	cp.w	r8,0
80006160:	c1 71       	brne	8000618e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006162:	ee c6 ff fc 	sub	r6,r7,-4
80006166:	0c 9c       	mov	r12,r6
80006168:	f0 1f 00 10 	mcall	800061a8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000616c:	6e bc       	ld.w	r12,r7[0x2c]
8000616e:	49 18       	lddpc	r8,800061b0 <xTaskRemoveFromEventList+0x68>
80006170:	70 08       	ld.w	r8,r8[0x0]
80006172:	10 3c       	cp.w	r12,r8
80006174:	e0 88 00 04 	brls	8000617c <xTaskRemoveFromEventList+0x34>
80006178:	48 e8       	lddpc	r8,800061b0 <xTaskRemoveFromEventList+0x68>
8000617a:	91 0c       	st.w	r8[0x0],r12
8000617c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006180:	0c 9b       	mov	r11,r6
80006182:	48 d8       	lddpc	r8,800061b4 <xTaskRemoveFromEventList+0x6c>
80006184:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006188:	f0 1f 00 0c 	mcall	800061b8 <xTaskRemoveFromEventList+0x70>
8000618c:	c0 58       	rjmp	80006196 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000618e:	0c 9b       	mov	r11,r6
80006190:	48 bc       	lddpc	r12,800061bc <xTaskRemoveFromEventList+0x74>
80006192:	f0 1f 00 0a 	mcall	800061b8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006196:	48 b8       	lddpc	r8,800061c0 <xTaskRemoveFromEventList+0x78>
80006198:	70 08       	ld.w	r8,r8[0x0]
8000619a:	6e b9       	ld.w	r9,r7[0x2c]
8000619c:	70 b8       	ld.w	r8,r8[0x2c]
8000619e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800061a0:	5f 2c       	srhs	r12
800061a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061a6:	00 00       	add	r0,r0
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	57 c2       	stdsp	sp[0x1f0],r2
800061ac:	00 00       	add	r0,r0
800061ae:	0d 00       	ld.w	r0,r6++
800061b0:	00 00       	add	r0,r0
800061b2:	0d 38       	ld.ub	r8,r6++
800061b4:	00 00       	add	r0,r0
800061b6:	0c 1c       	sub	r12,r6
800061b8:	80 00       	ld.sh	r0,r0[0x0]
800061ba:	57 72       	stdsp	sp[0x1dc],r2
800061bc:	00 00       	add	r0,r0
800061be:	0c d4       	st.w	--r6,r4
800061c0:	00 00       	add	r0,r0
800061c2:	0c d0       	st.w	--r6,r0

800061c4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800061c4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061c8:	4b 98       	lddpc	r8,800062ac <vTaskIncrementTick+0xe8>
800061ca:	70 08       	ld.w	r8,r8[0x0]
800061cc:	58 08       	cp.w	r8,0
800061ce:	c6 91       	brne	800062a0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800061d0:	4b 88       	lddpc	r8,800062b0 <vTaskIncrementTick+0xec>
800061d2:	70 09       	ld.w	r9,r8[0x0]
800061d4:	2f f9       	sub	r9,-1
800061d6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061d8:	70 08       	ld.w	r8,r8[0x0]
800061da:	58 08       	cp.w	r8,0
800061dc:	c1 a1       	brne	80006210 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061de:	4b 68       	lddpc	r8,800062b4 <vTaskIncrementTick+0xf0>
800061e0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061e2:	4b 69       	lddpc	r9,800062b8 <vTaskIncrementTick+0xf4>
800061e4:	72 0b       	ld.w	r11,r9[0x0]
800061e6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800061e8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800061ea:	4b 59       	lddpc	r9,800062bc <vTaskIncrementTick+0xf8>
800061ec:	72 0a       	ld.w	r10,r9[0x0]
800061ee:	2f fa       	sub	r10,-1
800061f0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800061f2:	70 08       	ld.w	r8,r8[0x0]
800061f4:	70 08       	ld.w	r8,r8[0x0]
800061f6:	58 08       	cp.w	r8,0
800061f8:	c0 51       	brne	80006202 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800061fa:	3f f9       	mov	r9,-1
800061fc:	4b 18       	lddpc	r8,800062c0 <vTaskIncrementTick+0xfc>
800061fe:	91 09       	st.w	r8[0x0],r9
80006200:	c0 88       	rjmp	80006210 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006202:	4a d8       	lddpc	r8,800062b4 <vTaskIncrementTick+0xf0>
80006204:	70 08       	ld.w	r8,r8[0x0]
80006206:	70 38       	ld.w	r8,r8[0xc]
80006208:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000620a:	70 19       	ld.w	r9,r8[0x4]
8000620c:	4a d8       	lddpc	r8,800062c0 <vTaskIncrementTick+0xfc>
8000620e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006210:	4a 88       	lddpc	r8,800062b0 <vTaskIncrementTick+0xec>
80006212:	70 09       	ld.w	r9,r8[0x0]
80006214:	4a b8       	lddpc	r8,800062c0 <vTaskIncrementTick+0xfc>
80006216:	70 08       	ld.w	r8,r8[0x0]
80006218:	10 39       	cp.w	r9,r8
8000621a:	c4 73       	brcs	800062a8 <vTaskIncrementTick+0xe4>
8000621c:	4a 68       	lddpc	r8,800062b4 <vTaskIncrementTick+0xf0>
8000621e:	70 08       	ld.w	r8,r8[0x0]
80006220:	70 08       	ld.w	r8,r8[0x0]
80006222:	58 08       	cp.w	r8,0
80006224:	c0 c0       	breq	8000623c <vTaskIncrementTick+0x78>
80006226:	4a 48       	lddpc	r8,800062b4 <vTaskIncrementTick+0xf0>
80006228:	70 08       	ld.w	r8,r8[0x0]
8000622a:	70 38       	ld.w	r8,r8[0xc]
8000622c:	70 37       	ld.w	r7,r8[0xc]
8000622e:	6e 18       	ld.w	r8,r7[0x4]
80006230:	4a 09       	lddpc	r9,800062b0 <vTaskIncrementTick+0xec>
80006232:	72 09       	ld.w	r9,r9[0x0]
80006234:	12 38       	cp.w	r8,r9
80006236:	e0 88 00 14 	brls	8000625e <vTaskIncrementTick+0x9a>
8000623a:	c0 e8       	rjmp	80006256 <vTaskIncrementTick+0x92>
8000623c:	3f f9       	mov	r9,-1
8000623e:	4a 18       	lddpc	r8,800062c0 <vTaskIncrementTick+0xfc>
80006240:	91 09       	st.w	r8[0x0],r9
80006242:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006246:	6a 08       	ld.w	r8,r5[0x0]
80006248:	70 38       	ld.w	r8,r8[0xc]
8000624a:	70 37       	ld.w	r7,r8[0xc]
8000624c:	6e 18       	ld.w	r8,r7[0x4]
8000624e:	64 09       	ld.w	r9,r2[0x0]
80006250:	12 38       	cp.w	r8,r9
80006252:	e0 88 00 0a 	brls	80006266 <vTaskIncrementTick+0xa2>
80006256:	49 b9       	lddpc	r9,800062c0 <vTaskIncrementTick+0xfc>
80006258:	93 08       	st.w	r9[0x0],r8
8000625a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000625e:	49 a4       	lddpc	r4,800062c4 <vTaskIncrementTick+0x100>
80006260:	49 a3       	lddpc	r3,800062c8 <vTaskIncrementTick+0x104>
80006262:	49 55       	lddpc	r5,800062b4 <vTaskIncrementTick+0xf0>
80006264:	49 32       	lddpc	r2,800062b0 <vTaskIncrementTick+0xec>
80006266:	ee c6 ff fc 	sub	r6,r7,-4
8000626a:	0c 9c       	mov	r12,r6
8000626c:	f0 1f 00 18 	mcall	800062cc <vTaskIncrementTick+0x108>
80006270:	6e a8       	ld.w	r8,r7[0x28]
80006272:	58 08       	cp.w	r8,0
80006274:	c0 50       	breq	8000627e <vTaskIncrementTick+0xba>
80006276:	ee cc ff e8 	sub	r12,r7,-24
8000627a:	f0 1f 00 15 	mcall	800062cc <vTaskIncrementTick+0x108>
8000627e:	6e bc       	ld.w	r12,r7[0x2c]
80006280:	68 08       	ld.w	r8,r4[0x0]
80006282:	10 3c       	cp.w	r12,r8
80006284:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006288:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000628c:	0c 9b       	mov	r11,r6
8000628e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006292:	f0 1f 00 10 	mcall	800062d0 <vTaskIncrementTick+0x10c>
80006296:	6a 08       	ld.w	r8,r5[0x0]
80006298:	70 08       	ld.w	r8,r8[0x0]
8000629a:	58 08       	cp.w	r8,0
8000629c:	cd 51       	brne	80006246 <vTaskIncrementTick+0x82>
8000629e:	cc fb       	rjmp	8000623c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800062a0:	48 d8       	lddpc	r8,800062d4 <vTaskIncrementTick+0x110>
800062a2:	70 09       	ld.w	r9,r8[0x0]
800062a4:	2f f9       	sub	r9,-1
800062a6:	91 09       	st.w	r8[0x0],r9
800062a8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062ac:	00 00       	add	r0,r0
800062ae:	0d 00       	ld.w	r0,r6++
800062b0:	00 00       	add	r0,r0
800062b2:	0c fc       	st.b	--r6,r12
800062b4:	00 00       	add	r0,r0
800062b6:	0c 08       	add	r8,r6
800062b8:	00 00       	add	r0,r0
800062ba:	0c 18       	sub	r8,r6
800062bc:	00 00       	add	r0,r0
800062be:	0c 14       	sub	r4,r6
800062c0:	00 00       	add	r0,r0
800062c2:	05 34       	ld.ub	r4,r2++
800062c4:	00 00       	add	r0,r0
800062c6:	0d 38       	ld.ub	r8,r6++
800062c8:	00 00       	add	r0,r0
800062ca:	0c 1c       	sub	r12,r6
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	57 c2       	stdsp	sp[0x1f0],r2
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	57 72       	stdsp	sp[0x1dc],r2
800062d4:	00 00       	add	r0,r0
800062d6:	0c 00       	add	r0,r6

800062d8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062d8:	eb cd 40 c0 	pushm	r6-r7,lr
800062dc:	18 97       	mov	r7,r12
800062de:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062e0:	f0 1f 00 15 	mcall	80006334 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062e4:	6c 08       	ld.w	r8,r6[0x0]
800062e6:	5b f8       	cp.w	r8,-1
800062e8:	c0 31       	brne	800062ee <xTaskCheckForTimeOut+0x16>
800062ea:	30 07       	mov	r7,0
800062ec:	c1 f8       	rjmp	8000632a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062ee:	49 39       	lddpc	r9,80006338 <xTaskCheckForTimeOut+0x60>
800062f0:	72 09       	ld.w	r9,r9[0x0]
800062f2:	6e 0a       	ld.w	r10,r7[0x0]
800062f4:	12 3a       	cp.w	r10,r9
800062f6:	c0 70       	breq	80006304 <xTaskCheckForTimeOut+0x2c>
800062f8:	49 19       	lddpc	r9,8000633c <xTaskCheckForTimeOut+0x64>
800062fa:	72 09       	ld.w	r9,r9[0x0]
800062fc:	6e 1a       	ld.w	r10,r7[0x4]
800062fe:	12 3a       	cp.w	r10,r9
80006300:	e0 88 00 14 	brls	80006328 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006304:	48 e9       	lddpc	r9,8000633c <xTaskCheckForTimeOut+0x64>
80006306:	72 0a       	ld.w	r10,r9[0x0]
80006308:	6e 19       	ld.w	r9,r7[0x4]
8000630a:	12 1a       	sub	r10,r9
8000630c:	14 38       	cp.w	r8,r10
8000630e:	e0 88 00 0d 	brls	80006328 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006312:	48 ba       	lddpc	r10,8000633c <xTaskCheckForTimeOut+0x64>
80006314:	74 0a       	ld.w	r10,r10[0x0]
80006316:	14 19       	sub	r9,r10
80006318:	f2 08 00 08 	add	r8,r9,r8
8000631c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000631e:	0e 9c       	mov	r12,r7
80006320:	f0 1f 00 08 	mcall	80006340 <xTaskCheckForTimeOut+0x68>
80006324:	30 07       	mov	r7,0
80006326:	c0 28       	rjmp	8000632a <xTaskCheckForTimeOut+0x52>
80006328:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000632a:	f0 1f 00 07 	mcall	80006344 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000632e:	0e 9c       	mov	r12,r7
80006330:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	58 7c       	cp.w	r12,7
80006338:	00 00       	add	r0,r0
8000633a:	0c 14       	sub	r4,r6
8000633c:	00 00       	add	r0,r0
8000633e:	0c fc       	st.b	--r6,r12
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	60 3c       	ld.w	r12,r0[0xc]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	59 88       	cp.w	r8,24

80006348 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006348:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000634c:	f0 1f 00 05 	mcall	80006360 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006350:	48 58       	lddpc	r8,80006364 <xTaskGetTickCount+0x1c>
80006352:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006354:	f0 1f 00 05 	mcall	80006368 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006358:	0e 9c       	mov	r12,r7
8000635a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000635e:	00 00       	add	r0,r0
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	58 7c       	cp.w	r12,7
80006364:	00 00       	add	r0,r0
80006366:	0c fc       	st.b	--r6,r12
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	59 88       	cp.w	r8,24

8000636c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000636c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006370:	f0 1f 00 2c 	mcall	80006420 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006374:	4a c8       	lddpc	r8,80006424 <xTaskResumeAll+0xb8>
80006376:	70 09       	ld.w	r9,r8[0x0]
80006378:	20 19       	sub	r9,1
8000637a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000637c:	70 08       	ld.w	r8,r8[0x0]
8000637e:	58 08       	cp.w	r8,0
80006380:	c4 91       	brne	80006412 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006382:	4a a8       	lddpc	r8,80006428 <xTaskResumeAll+0xbc>
80006384:	70 08       	ld.w	r8,r8[0x0]
80006386:	58 08       	cp.w	r8,0
80006388:	c4 50       	breq	80006412 <xTaskResumeAll+0xa6>
8000638a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000638c:	4a 85       	lddpc	r5,8000642c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000638e:	4a 93       	lddpc	r3,80006430 <xTaskResumeAll+0xc4>
80006390:	4a 92       	lddpc	r2,80006434 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006392:	4a a1       	lddpc	r1,80006438 <xTaskResumeAll+0xcc>
80006394:	c1 e8       	rjmp	800063d0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006396:	6a 38       	ld.w	r8,r5[0xc]
80006398:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000639a:	ee cc ff e8 	sub	r12,r7,-24
8000639e:	f0 1f 00 28 	mcall	8000643c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800063a2:	ee c6 ff fc 	sub	r6,r7,-4
800063a6:	0c 9c       	mov	r12,r6
800063a8:	f0 1f 00 25 	mcall	8000643c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800063ac:	6e bc       	ld.w	r12,r7[0x2c]
800063ae:	66 08       	ld.w	r8,r3[0x0]
800063b0:	10 3c       	cp.w	r12,r8
800063b2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800063b6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063ba:	0c 9b       	mov	r11,r6
800063bc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800063c0:	f0 1f 00 20 	mcall	80006440 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063c4:	62 08       	ld.w	r8,r1[0x0]
800063c6:	6e b9       	ld.w	r9,r7[0x2c]
800063c8:	70 b8       	ld.w	r8,r8[0x2c]
800063ca:	10 39       	cp.w	r9,r8
800063cc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063d0:	6a 08       	ld.w	r8,r5[0x0]
800063d2:	58 08       	cp.w	r8,0
800063d4:	ce 11       	brne	80006396 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063d6:	49 c8       	lddpc	r8,80006444 <xTaskResumeAll+0xd8>
800063d8:	70 08       	ld.w	r8,r8[0x0]
800063da:	58 08       	cp.w	r8,0
800063dc:	c0 f0       	breq	800063fa <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063de:	49 a8       	lddpc	r8,80006444 <xTaskResumeAll+0xd8>
800063e0:	70 08       	ld.w	r8,r8[0x0]
800063e2:	58 08       	cp.w	r8,0
800063e4:	c1 10       	breq	80006406 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800063e6:	49 87       	lddpc	r7,80006444 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800063e8:	f0 1f 00 18 	mcall	80006448 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800063ec:	6e 08       	ld.w	r8,r7[0x0]
800063ee:	20 18       	sub	r8,1
800063f0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063f2:	6e 08       	ld.w	r8,r7[0x0]
800063f4:	58 08       	cp.w	r8,0
800063f6:	cf 91       	brne	800063e8 <xTaskResumeAll+0x7c>
800063f8:	c0 78       	rjmp	80006406 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800063fa:	58 14       	cp.w	r4,1
800063fc:	c0 50       	breq	80006406 <xTaskResumeAll+0x9a>
800063fe:	49 48       	lddpc	r8,8000644c <xTaskResumeAll+0xe0>
80006400:	70 08       	ld.w	r8,r8[0x0]
80006402:	58 18       	cp.w	r8,1
80006404:	c0 71       	brne	80006412 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006406:	30 09       	mov	r9,0
80006408:	49 18       	lddpc	r8,8000644c <xTaskResumeAll+0xe0>
8000640a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000640c:	d7 33       	scall
8000640e:	30 17       	mov	r7,1
80006410:	c0 28       	rjmp	80006414 <xTaskResumeAll+0xa8>
80006412:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006414:	f0 1f 00 0f 	mcall	80006450 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006418:	0e 9c       	mov	r12,r7
8000641a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000641e:	00 00       	add	r0,r0
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	58 7c       	cp.w	r12,7
80006424:	00 00       	add	r0,r0
80006426:	0d 00       	ld.w	r0,r6++
80006428:	00 00       	add	r0,r0
8000642a:	0d 1c       	ld.sh	r12,r6++
8000642c:	00 00       	add	r0,r0
8000642e:	0c d4       	st.w	--r6,r4
80006430:	00 00       	add	r0,r0
80006432:	0d 38       	ld.ub	r8,r6++
80006434:	00 00       	add	r0,r0
80006436:	0c 1c       	sub	r12,r6
80006438:	00 00       	add	r0,r0
8000643a:	0c d0       	st.w	--r6,r0
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	57 c2       	stdsp	sp[0x1f0],r2
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	57 72       	stdsp	sp[0x1dc],r2
80006444:	00 00       	add	r0,r0
80006446:	0c 00       	add	r0,r6
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	61 c4       	ld.w	r4,r0[0x70]
8000644c:	00 00       	add	r0,r0
8000644e:	0d 20       	ld.uh	r0,r6++
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	59 88       	cp.w	r8,24

80006454 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006454:	eb cd 40 80 	pushm	r7,lr
80006458:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000645a:	49 08       	lddpc	r8,80006498 <prvAddCurrentTaskToDelayedList+0x44>
8000645c:	70 08       	ld.w	r8,r8[0x0]
8000645e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006460:	48 f8       	lddpc	r8,8000649c <prvAddCurrentTaskToDelayedList+0x48>
80006462:	70 08       	ld.w	r8,r8[0x0]
80006464:	10 3c       	cp.w	r12,r8
80006466:	c0 a2       	brcc	8000647a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006468:	48 c8       	lddpc	r8,80006498 <prvAddCurrentTaskToDelayedList+0x44>
8000646a:	70 0b       	ld.w	r11,r8[0x0]
8000646c:	48 d8       	lddpc	r8,800064a0 <prvAddCurrentTaskToDelayedList+0x4c>
8000646e:	70 0c       	ld.w	r12,r8[0x0]
80006470:	2f cb       	sub	r11,-4
80006472:	f0 1f 00 0d 	mcall	800064a4 <prvAddCurrentTaskToDelayedList+0x50>
80006476:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000647a:	48 88       	lddpc	r8,80006498 <prvAddCurrentTaskToDelayedList+0x44>
8000647c:	70 0b       	ld.w	r11,r8[0x0]
8000647e:	48 b8       	lddpc	r8,800064a8 <prvAddCurrentTaskToDelayedList+0x54>
80006480:	70 0c       	ld.w	r12,r8[0x0]
80006482:	2f cb       	sub	r11,-4
80006484:	f0 1f 00 08 	mcall	800064a4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006488:	48 98       	lddpc	r8,800064ac <prvAddCurrentTaskToDelayedList+0x58>
8000648a:	70 08       	ld.w	r8,r8[0x0]
8000648c:	10 37       	cp.w	r7,r8
8000648e:	c0 32       	brcc	80006494 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006490:	48 78       	lddpc	r8,800064ac <prvAddCurrentTaskToDelayedList+0x58>
80006492:	91 07       	st.w	r8[0x0],r7
80006494:	e3 cd 80 80 	ldm	sp++,r7,pc
80006498:	00 00       	add	r0,r0
8000649a:	0c d0       	st.w	--r6,r0
8000649c:	00 00       	add	r0,r0
8000649e:	0c fc       	st.b	--r6,r12
800064a0:	00 00       	add	r0,r0
800064a2:	0c 18       	sub	r8,r6
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	57 8e       	stdsp	sp[0x1e0],lr
800064a8:	00 00       	add	r0,r0
800064aa:	0c 08       	add	r8,r6
800064ac:	00 00       	add	r0,r0
800064ae:	05 34       	ld.ub	r4,r2++

800064b0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800064b0:	eb cd 40 c0 	pushm	r6-r7,lr
800064b4:	18 96       	mov	r6,r12
800064b6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800064b8:	f0 1f 00 18 	mcall	80006518 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800064bc:	6c 08       	ld.w	r8,r6[0x0]
800064be:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800064c0:	49 79       	lddpc	r9,8000651c <vTaskDelayUntil+0x6c>
800064c2:	72 09       	ld.w	r9,r9[0x0]
800064c4:	12 38       	cp.w	r8,r9
800064c6:	e0 88 00 0c 	brls	800064de <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800064ca:	0e 38       	cp.w	r8,r7
800064cc:	e0 88 00 22 	brls	80006510 <vTaskDelayUntil+0x60>
800064d0:	49 38       	lddpc	r8,8000651c <vTaskDelayUntil+0x6c>
800064d2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064d4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800064d6:	10 37       	cp.w	r7,r8
800064d8:	e0 88 00 14 	brls	80006500 <vTaskDelayUntil+0x50>
800064dc:	c0 a8       	rjmp	800064f0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800064de:	0e 38       	cp.w	r8,r7
800064e0:	e0 8b 00 16 	brhi	8000650c <vTaskDelayUntil+0x5c>
800064e4:	48 e8       	lddpc	r8,8000651c <vTaskDelayUntil+0x6c>
800064e6:	70 08       	ld.w	r8,r8[0x0]
800064e8:	10 37       	cp.w	r7,r8
800064ea:	e0 8b 00 11 	brhi	8000650c <vTaskDelayUntil+0x5c>
800064ee:	c1 18       	rjmp	80006510 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064f0:	48 c8       	lddpc	r8,80006520 <vTaskDelayUntil+0x70>
800064f2:	70 0c       	ld.w	r12,r8[0x0]
800064f4:	2f cc       	sub	r12,-4
800064f6:	f0 1f 00 0c 	mcall	80006524 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800064fa:	0e 9c       	mov	r12,r7
800064fc:	f0 1f 00 0b 	mcall	80006528 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006500:	f0 1f 00 0b 	mcall	8000652c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006504:	c0 81       	brne	80006514 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006506:	d7 33       	scall
80006508:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000650c:	8d 07       	st.w	r6[0x0],r7
8000650e:	cf 1b       	rjmp	800064f0 <vTaskDelayUntil+0x40>
80006510:	8d 07       	st.w	r6[0x0],r7
80006512:	cf 7b       	rjmp	80006500 <vTaskDelayUntil+0x50>
80006514:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	5f b0       	srhi	r0
8000651c:	00 00       	add	r0,r0
8000651e:	0c fc       	st.b	--r6,r12
80006520:	00 00       	add	r0,r0
80006522:	0c d0       	st.w	--r6,r0
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	57 c2       	stdsp	sp[0x1f0],r2
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	64 54       	ld.w	r4,r2[0x14]
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	63 6c       	ld.w	r12,r1[0x58]

80006530 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006530:	eb cd 40 c0 	pushm	r6-r7,lr
80006534:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006536:	48 e7       	lddpc	r7,8000656c <vTaskPlaceOnEventList+0x3c>
80006538:	6e 0b       	ld.w	r11,r7[0x0]
8000653a:	2e 8b       	sub	r11,-24
8000653c:	f0 1f 00 0d 	mcall	80006570 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006540:	6e 0c       	ld.w	r12,r7[0x0]
80006542:	2f cc       	sub	r12,-4
80006544:	f0 1f 00 0c 	mcall	80006574 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006548:	5b f6       	cp.w	r6,-1
8000654a:	c0 81       	brne	8000655a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000654c:	6e 0b       	ld.w	r11,r7[0x0]
8000654e:	2f cb       	sub	r11,-4
80006550:	48 ac       	lddpc	r12,80006578 <vTaskPlaceOnEventList+0x48>
80006552:	f0 1f 00 0b 	mcall	8000657c <vTaskPlaceOnEventList+0x4c>
80006556:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000655a:	48 a8       	lddpc	r8,80006580 <vTaskPlaceOnEventList+0x50>
8000655c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000655e:	ec 0c 00 0c 	add	r12,r6,r12
80006562:	f0 1f 00 09 	mcall	80006584 <vTaskPlaceOnEventList+0x54>
80006566:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000656a:	00 00       	add	r0,r0
8000656c:	00 00       	add	r0,r0
8000656e:	0c d0       	st.w	--r6,r0
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	57 8e       	stdsp	sp[0x1e0],lr
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	57 c2       	stdsp	sp[0x1f0],r2
80006578:	00 00       	add	r0,r0
8000657a:	0d 24       	ld.uh	r4,r6++
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	57 72       	stdsp	sp[0x1dc],r2
80006580:	00 00       	add	r0,r0
80006582:	0c fc       	st.b	--r6,r12
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	64 54       	ld.w	r4,r2[0x14]

80006588 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006588:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000658c:	49 67       	lddpc	r7,800065e4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000658e:	49 74       	lddpc	r4,800065e8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006590:	49 73       	lddpc	r3,800065ec <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006592:	49 85       	lddpc	r5,800065f0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006594:	6e 08       	ld.w	r8,r7[0x0]
80006596:	58 08       	cp.w	r8,0
80006598:	c1 e0       	breq	800065d4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000659a:	f0 1f 00 17 	mcall	800065f4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000659e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800065a0:	f0 1f 00 16 	mcall	800065f8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800065a4:	58 06       	cp.w	r6,0
800065a6:	c1 70       	breq	800065d4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800065a8:	f0 1f 00 15 	mcall	800065fc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800065ac:	68 38       	ld.w	r8,r4[0xc]
800065ae:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800065b0:	ec cc ff fc 	sub	r12,r6,-4
800065b4:	f0 1f 00 13 	mcall	80006600 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800065b8:	66 08       	ld.w	r8,r3[0x0]
800065ba:	20 18       	sub	r8,1
800065bc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800065be:	6e 08       	ld.w	r8,r7[0x0]
800065c0:	20 18       	sub	r8,1
800065c2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800065c4:	f0 1f 00 10 	mcall	80006604 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800065c8:	6c cc       	ld.w	r12,r6[0x30]
800065ca:	f0 1f 00 10 	mcall	80006608 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800065ce:	0c 9c       	mov	r12,r6
800065d0:	f0 1f 00 0e 	mcall	80006608 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065d4:	6a 08       	ld.w	r8,r5[0x0]
800065d6:	58 18       	cp.w	r8,1
800065d8:	e0 88 00 03 	brls	800065de <prvIdleTask+0x56>
			{
				taskYIELD();
800065dc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800065de:	f0 1f 00 0c 	mcall	8000660c <prvIdleTask+0x84>
		}
		#endif
	}
800065e2:	cd 9b       	rjmp	80006594 <prvIdleTask+0xc>
800065e4:	00 00       	add	r0,r0
800065e6:	0c 10       	sub	r0,r6
800065e8:	00 00       	add	r0,r0
800065ea:	0c bc       	st.h	r6++,r12
800065ec:	00 00       	add	r0,r0
800065ee:	0d 1c       	ld.sh	r12,r6++
800065f0:	00 00       	add	r0,r0
800065f2:	0c 1c       	sub	r12,r6
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	5f b0       	srhi	r0
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	63 6c       	ld.w	r12,r1[0x58]
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	58 7c       	cp.w	r12,7
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	57 c2       	stdsp	sp[0x1f0],r2
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	59 88       	cp.w	r8,24
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	5a c0       	cp.w	r0,-20
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	20 2c       	sub	r12,2

80006610 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006610:	d4 31       	pushm	r0-r7,lr
80006612:	20 1d       	sub	sp,4
80006614:	fa c4 ff d8 	sub	r4,sp,-40
80006618:	50 0c       	stdsp	sp[0x0],r12
8000661a:	16 91       	mov	r1,r11
8000661c:	14 97       	mov	r7,r10
8000661e:	12 90       	mov	r0,r9
80006620:	10 93       	mov	r3,r8
80006622:	68 02       	ld.w	r2,r4[0x0]
80006624:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006626:	34 8c       	mov	r12,72
80006628:	f0 1f 00 5c 	mcall	80006798 <xTaskGenericCreate+0x188>
8000662c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000662e:	c0 31       	brne	80006634 <xTaskGenericCreate+0x24>
80006630:	3f fc       	mov	r12,-1
80006632:	ca f8       	rjmp	80006790 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006634:	58 06       	cp.w	r6,0
80006636:	e0 81 00 af 	brne	80006794 <xTaskGenericCreate+0x184>
8000663a:	0e 9c       	mov	r12,r7
8000663c:	5c 7c       	castu.h	r12
8000663e:	a3 6c       	lsl	r12,0x2
80006640:	f0 1f 00 56 	mcall	80006798 <xTaskGenericCreate+0x188>
80006644:	18 96       	mov	r6,r12
80006646:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006648:	c0 61       	brne	80006654 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000664a:	0a 9c       	mov	r12,r5
8000664c:	f0 1f 00 54 	mcall	8000679c <xTaskGenericCreate+0x18c>
80006650:	3f fc       	mov	r12,-1
80006652:	c9 f8       	rjmp	80006790 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006654:	5c 77       	castu.h	r7
80006656:	ee 0a 15 02 	lsl	r10,r7,0x2
8000665a:	e0 6b 00 a5 	mov	r11,165
8000665e:	0c 9c       	mov	r12,r6
80006660:	f0 1f 00 50 	mcall	800067a0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006664:	ee c6 00 01 	sub	r6,r7,1
80006668:	6a c8       	ld.w	r8,r5[0x30]
8000666a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000666e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006672:	31 0a       	mov	r10,16
80006674:	02 9b       	mov	r11,r1
80006676:	ea cc ff cc 	sub	r12,r5,-52
8000667a:	f0 1f 00 4b 	mcall	800067a4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000667e:	30 08       	mov	r8,0
80006680:	eb 68 00 43 	st.b	r5[67],r8
80006684:	58 73       	cp.w	r3,7
80006686:	e6 07 17 80 	movls	r7,r3
8000668a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000668e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006690:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006694:	ea c4 ff fc 	sub	r4,r5,-4
80006698:	08 9c       	mov	r12,r4
8000669a:	f0 1f 00 44 	mcall	800067a8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000669e:	ea cc ff e8 	sub	r12,r5,-24
800066a2:	f0 1f 00 42 	mcall	800067a8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800066a6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800066a8:	ee 07 11 08 	rsub	r7,r7,8
800066ac:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800066ae:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800066b0:	00 9a       	mov	r10,r0
800066b2:	40 0b       	lddsp	r11,sp[0x0]
800066b4:	0c 9c       	mov	r12,r6
800066b6:	f0 1f 00 3e 	mcall	800067ac <xTaskGenericCreate+0x19c>
800066ba:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800066bc:	58 02       	cp.w	r2,0
800066be:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800066c2:	f0 1f 00 3c 	mcall	800067b0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800066c6:	4b c8       	lddpc	r8,800067b4 <xTaskGenericCreate+0x1a4>
800066c8:	70 09       	ld.w	r9,r8[0x0]
800066ca:	2f f9       	sub	r9,-1
800066cc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800066ce:	4b b8       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1a8>
800066d0:	70 08       	ld.w	r8,r8[0x0]
800066d2:	58 08       	cp.w	r8,0
800066d4:	c2 61       	brne	80006720 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800066d6:	4b 98       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1a8>
800066d8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800066da:	4b 78       	lddpc	r8,800067b4 <xTaskGenericCreate+0x1a4>
800066dc:	70 08       	ld.w	r8,r8[0x0]
800066de:	58 18       	cp.w	r8,1
800066e0:	c2 b1       	brne	80006736 <xTaskGenericCreate+0x126>
800066e2:	4b 77       	lddpc	r7,800067bc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800066e4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800066e8:	0e 9c       	mov	r12,r7
800066ea:	f0 1f 00 36 	mcall	800067c0 <xTaskGenericCreate+0x1b0>
800066ee:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800066f0:	0c 37       	cp.w	r7,r6
800066f2:	cf b1       	brne	800066e8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800066f4:	4b 47       	lddpc	r7,800067c4 <xTaskGenericCreate+0x1b4>
800066f6:	0e 9c       	mov	r12,r7
800066f8:	f0 1f 00 32 	mcall	800067c0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800066fc:	4b 36       	lddpc	r6,800067c8 <xTaskGenericCreate+0x1b8>
800066fe:	0c 9c       	mov	r12,r6
80006700:	f0 1f 00 30 	mcall	800067c0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006704:	4b 2c       	lddpc	r12,800067cc <xTaskGenericCreate+0x1bc>
80006706:	f0 1f 00 2f 	mcall	800067c0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000670a:	4b 2c       	lddpc	r12,800067d0 <xTaskGenericCreate+0x1c0>
8000670c:	f0 1f 00 2d 	mcall	800067c0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006710:	4b 1c       	lddpc	r12,800067d4 <xTaskGenericCreate+0x1c4>
80006712:	f0 1f 00 2c 	mcall	800067c0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006716:	4b 18       	lddpc	r8,800067d8 <xTaskGenericCreate+0x1c8>
80006718:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000671a:	4b 18       	lddpc	r8,800067dc <xTaskGenericCreate+0x1cc>
8000671c:	91 06       	st.w	r8[0x0],r6
8000671e:	c0 c8       	rjmp	80006736 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006720:	4b 08       	lddpc	r8,800067e0 <xTaskGenericCreate+0x1d0>
80006722:	70 08       	ld.w	r8,r8[0x0]
80006724:	58 08       	cp.w	r8,0
80006726:	c0 81       	brne	80006736 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006728:	4a 48       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1a8>
8000672a:	70 08       	ld.w	r8,r8[0x0]
8000672c:	70 b8       	ld.w	r8,r8[0x2c]
8000672e:	10 33       	cp.w	r3,r8
80006730:	c0 33       	brcs	80006736 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006732:	4a 28       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1a8>
80006734:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006736:	6a b8       	ld.w	r8,r5[0x2c]
80006738:	4a b9       	lddpc	r9,800067e4 <xTaskGenericCreate+0x1d4>
8000673a:	72 09       	ld.w	r9,r9[0x0]
8000673c:	12 38       	cp.w	r8,r9
8000673e:	e0 88 00 04 	brls	80006746 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006742:	4a 99       	lddpc	r9,800067e4 <xTaskGenericCreate+0x1d4>
80006744:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006746:	4a 98       	lddpc	r8,800067e8 <xTaskGenericCreate+0x1d8>
80006748:	70 09       	ld.w	r9,r8[0x0]
8000674a:	2f f9       	sub	r9,-1
8000674c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000674e:	6a b8       	ld.w	r8,r5[0x2c]
80006750:	4a 79       	lddpc	r9,800067ec <xTaskGenericCreate+0x1dc>
80006752:	72 09       	ld.w	r9,r9[0x0]
80006754:	12 38       	cp.w	r8,r9
80006756:	e0 88 00 04 	brls	8000675e <xTaskGenericCreate+0x14e>
8000675a:	4a 59       	lddpc	r9,800067ec <xTaskGenericCreate+0x1dc>
8000675c:	93 08       	st.w	r9[0x0],r8
8000675e:	6a bc       	ld.w	r12,r5[0x2c]
80006760:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006764:	08 9b       	mov	r11,r4
80006766:	49 68       	lddpc	r8,800067bc <xTaskGenericCreate+0x1ac>
80006768:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000676c:	f0 1f 00 21 	mcall	800067f0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006770:	f0 1f 00 21 	mcall	800067f4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006774:	49 b8       	lddpc	r8,800067e0 <xTaskGenericCreate+0x1d0>
80006776:	70 08       	ld.w	r8,r8[0x0]
80006778:	58 08       	cp.w	r8,0
8000677a:	c0 a0       	breq	8000678e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000677c:	48 f8       	lddpc	r8,800067b8 <xTaskGenericCreate+0x1a8>
8000677e:	70 08       	ld.w	r8,r8[0x0]
80006780:	70 b8       	ld.w	r8,r8[0x2c]
80006782:	10 33       	cp.w	r3,r8
80006784:	e0 88 00 05 	brls	8000678e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006788:	d7 33       	scall
8000678a:	30 1c       	mov	r12,1
8000678c:	c0 28       	rjmp	80006790 <xTaskGenericCreate+0x180>
8000678e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006790:	2f fd       	sub	sp,-4
80006792:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006794:	99 c6       	st.w	r12[0x30],r6
80006796:	c5 fb       	rjmp	80006654 <xTaskGenericCreate+0x44>
80006798:	80 00       	ld.sh	r0,r0[0x0]
8000679a:	5a e8       	cp.w	r8,-18
8000679c:	80 00       	ld.sh	r0,r0[0x0]
8000679e:	5a c0       	cp.w	r0,-20
800067a0:	80 00       	ld.sh	r0,r0[0x0]
800067a2:	73 b0       	ld.w	r0,r9[0x6c]
800067a4:	80 00       	ld.sh	r0,r0[0x0]
800067a6:	76 dc       	ld.w	r12,r11[0x34]
800067a8:	80 00       	ld.sh	r0,r0[0x0]
800067aa:	57 6c       	stdsp	sp[0x1d8],r12
800067ac:	80 00       	ld.sh	r0,r0[0x0]
800067ae:	57 e8       	stdsp	sp[0x1f8],r8
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	58 7c       	cp.w	r12,7
800067b4:	00 00       	add	r0,r0
800067b6:	0d 1c       	ld.sh	r12,r6++
800067b8:	00 00       	add	r0,r0
800067ba:	0c d0       	st.w	--r6,r0
800067bc:	00 00       	add	r0,r0
800067be:	0c 1c       	sub	r12,r6
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	57 58       	stdsp	sp[0x1d4],r8
800067c4:	00 00       	add	r0,r0
800067c6:	0c e8       	st.h	--r6,r8
800067c8:	00 00       	add	r0,r0
800067ca:	0d 04       	ld.w	r4,r6++
800067cc:	00 00       	add	r0,r0
800067ce:	0c d4       	st.w	--r6,r4
800067d0:	00 00       	add	r0,r0
800067d2:	0c bc       	st.h	r6++,r12
800067d4:	00 00       	add	r0,r0
800067d6:	0d 24       	ld.uh	r4,r6++
800067d8:	00 00       	add	r0,r0
800067da:	0c 08       	add	r8,r6
800067dc:	00 00       	add	r0,r0
800067de:	0c 18       	sub	r8,r6
800067e0:	00 00       	add	r0,r0
800067e2:	0c 0c       	add	r12,r6
800067e4:	00 00       	add	r0,r0
800067e6:	0c 04       	add	r4,r6
800067e8:	00 00       	add	r0,r0
800067ea:	0d 18       	ld.sh	r8,r6++
800067ec:	00 00       	add	r0,r0
800067ee:	0d 38       	ld.ub	r8,r6++
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	57 72       	stdsp	sp[0x1dc],r2
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	59 88       	cp.w	r8,24

800067f8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800067f8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800067fa:	30 09       	mov	r9,0
800067fc:	1a d9       	st.w	--sp,r9
800067fe:	1a d9       	st.w	--sp,r9
80006800:	1a d9       	st.w	--sp,r9
80006802:	12 98       	mov	r8,r9
80006804:	e0 6a 01 00 	mov	r10,256
80006808:	48 9b       	lddpc	r11,8000682c <vTaskStartScheduler+0x34>
8000680a:	48 ac       	lddpc	r12,80006830 <vTaskStartScheduler+0x38>
8000680c:	f0 1f 00 0a 	mcall	80006834 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006810:	2f dd       	sub	sp,-12
80006812:	58 1c       	cp.w	r12,1
80006814:	c0 a1       	brne	80006828 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006816:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006818:	30 19       	mov	r9,1
8000681a:	48 88       	lddpc	r8,80006838 <vTaskStartScheduler+0x40>
8000681c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000681e:	30 09       	mov	r9,0
80006820:	48 78       	lddpc	r8,8000683c <vTaskStartScheduler+0x44>
80006822:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006824:	f0 1f 00 07 	mcall	80006840 <vTaskStartScheduler+0x48>
80006828:	d8 02       	popm	pc
8000682a:	00 00       	add	r0,r0
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	d2 c4       	*unknown*
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	65 88       	ld.w	r8,r2[0x60]
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	66 10       	ld.w	r0,r3[0x4]
80006838:	00 00       	add	r0,r0
8000683a:	0c 0c       	add	r12,r6
8000683c:	00 00       	add	r0,r0
8000683e:	0c fc       	st.b	--r6,r12
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	58 8c       	cp.w	r12,8

80006844 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006844:	16 cc       	st.b	r11++,r12
	return str;
}
80006846:	5e fb       	retal	r11

80006848 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006848:	eb cd 40 c0 	pushm	r6-r7,lr
8000684c:	20 3d       	sub	sp,12
8000684e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006850:	30 06       	mov	r6,0
80006852:	30 07       	mov	r7,0
80006854:	fa e7 00 00 	st.d	sp[0],r6
80006858:	30 0c       	mov	r12,0
8000685a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000685c:	58 08       	cp.w	r8,0
8000685e:	c1 30       	breq	80006884 <PrintHex+0x3c>
80006860:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006862:	1a 9c       	mov	r12,sp
80006864:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006868:	58 9e       	cp.w	lr,9
8000686a:	e0 8a 00 04 	brle	80006872 <PrintHex+0x2a>
8000686e:	2c 9e       	sub	lr,-55
80006870:	c0 48       	rjmp	80006878 <PrintHex+0x30>
80006872:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006876:	2d 0e       	sub	lr,-48
80006878:	f8 09 0b 0e 	st.b	r12[r9],lr
8000687c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000687e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006880:	cf 21       	brne	80006864 <PrintHex+0x1c>
80006882:	c0 48       	rjmp	8000688a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006884:	33 08       	mov	r8,48
80006886:	ba 88       	st.b	sp[0x0],r8
80006888:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000688a:	f6 09 01 08 	sub	r8,r11,r9
8000688e:	58 08       	cp.w	r8,0
80006890:	e0 8a 00 13 	brle	800068b6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006894:	12 1b       	sub	r11,r9
80006896:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000689a:	18 9e       	mov	lr,r12
8000689c:	58 0c       	cp.w	r12,0
8000689e:	e0 8a 00 0c 	brle	800068b6 <PrintHex+0x6e>
800068a2:	1a 9b       	mov	r11,sp
800068a4:	12 0b       	add	r11,r9
800068a6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800068a8:	33 07       	mov	r7,48
800068aa:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800068ac:	2f f8       	sub	r8,-1
800068ae:	1c 38       	cp.w	r8,lr
800068b0:	cf d5       	brlt	800068aa <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068b2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068b6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800068ba:	f0 cb ff ff 	sub	r11,r8,-1
800068be:	58 0b       	cp.w	r11,0
800068c0:	e0 8a 00 19 	brle	800068f2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068c4:	fa cb ff f4 	sub	r11,sp,-12
800068c8:	f6 09 00 09 	add	r9,r11,r9
800068cc:	37 8b       	mov	r11,120
800068ce:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800068d2:	fa c9 ff f4 	sub	r9,sp,-12
800068d6:	10 09       	add	r9,r8
800068d8:	33 0b       	mov	r11,48
800068da:	f3 6b ff f4 	st.b	r9[-12],r11
800068de:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068e2:	fa ce 00 01 	sub	lr,sp,1
800068e6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800068e8:	11 8b       	ld.ub	r11,r8[0x0]
800068ea:	12 cb       	st.b	r9++,r11
800068ec:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800068ee:	1c 38       	cp.w	r8,lr
800068f0:	cf c1       	brne	800068e8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800068f2:	14 9c       	mov	r12,r10
800068f4:	2f dd       	sub	sp,-12
800068f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800068fa <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800068fa:	d4 21       	pushm	r4-r7,lr
800068fc:	20 3d       	sub	sp,12
800068fe:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006900:	30 06       	mov	r6,0
80006902:	30 07       	mov	r7,0
80006904:	fa e7 00 00 	st.d	sp[0],r6
80006908:	30 0c       	mov	r12,0
8000690a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000690c:	58 08       	cp.w	r8,0
8000690e:	c0 35       	brlt	80006914 <PrintDec+0x1a>
80006910:	14 97       	mov	r7,r10
80006912:	c0 58       	rjmp	8000691c <PrintDec+0x22>
	{
		*p++ = '-';
80006914:	14 97       	mov	r7,r10
80006916:	32 d9       	mov	r9,45
80006918:	0e c9       	st.b	r7++,r9
		i = -i;
8000691a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000691c:	58 08       	cp.w	r8,0
8000691e:	c0 51       	brne	80006928 <PrintDec+0x2e>
80006920:	33 08       	mov	r8,48
80006922:	ba 88       	st.b	sp[0x0],r8
80006924:	30 1e       	mov	lr,1
80006926:	c2 f8       	rjmp	80006984 <PrintDec+0x8a>
	
	int ten = i%10;
80006928:	e0 65 66 67 	mov	r5,26215
8000692c:	ea 15 66 66 	orh	r5,0x6666
80006930:	f0 05 04 44 	muls.d	r4,r8,r5
80006934:	ea 0c 14 02 	asr	r12,r5,0x2
80006938:	f0 09 14 1f 	asr	r9,r8,0x1f
8000693c:	f8 09 01 09 	sub	r9,r12,r9
80006940:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006944:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006948:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000694a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000694c:	e0 66 66 67 	mov	r6,26215
80006950:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006954:	2d 09       	sub	r9,-48
80006956:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000695a:	2f fe       	sub	lr,-1
		i /= 10;
8000695c:	f0 06 04 44 	muls.d	r4,r8,r6
80006960:	ea 09 14 02 	asr	r9,r5,0x2
80006964:	bf 58       	asr	r8,0x1f
80006966:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000696a:	f0 06 04 44 	muls.d	r4,r8,r6
8000696e:	ea 09 14 02 	asr	r9,r5,0x2
80006972:	f0 05 14 1f 	asr	r5,r8,0x1f
80006976:	0a 19       	sub	r9,r5
80006978:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000697c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006980:	58 08       	cp.w	r8,0
80006982:	ce 91       	brne	80006954 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006984:	f6 0e 01 08 	sub	r8,r11,lr
80006988:	58 08       	cp.w	r8,0
8000698a:	e0 89 00 06 	brgt	80006996 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000698e:	58 0e       	cp.w	lr,0
80006990:	e0 89 00 14 	brgt	800069b8 <PrintDec+0xbe>
80006994:	c1 d8       	rjmp	800069ce <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006996:	1c 1b       	sub	r11,lr
80006998:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000699a:	16 9c       	mov	r12,r11
8000699c:	58 0b       	cp.w	r11,0
8000699e:	fe 9a ff f8 	brle	8000698e <PrintDec+0x94>
800069a2:	1a 99       	mov	r9,sp
800069a4:	1c 09       	add	r9,lr
800069a6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800069a8:	33 06       	mov	r6,48
800069aa:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800069ac:	2f f8       	sub	r8,-1
800069ae:	18 38       	cp.w	r8,r12
800069b0:	cf d5       	brlt	800069aa <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800069b2:	f6 0e 00 0e 	add	lr,r11,lr
800069b6:	ce cb       	rjmp	8000698e <PrintDec+0x94>
800069b8:	fa c8 ff f4 	sub	r8,sp,-12
800069bc:	1c 08       	add	r8,lr
800069be:	20 d8       	sub	r8,13
800069c0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800069c4:	11 89       	ld.ub	r9,r8[0x0]
800069c6:	0e c9       	st.b	r7++,r9
800069c8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800069ca:	16 38       	cp.w	r8,r11
800069cc:	cf c1       	brne	800069c4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800069ce:	14 9c       	mov	r12,r10
800069d0:	2f dd       	sub	sp,-12
800069d2:	d8 22       	popm	r4-r7,pc

800069d4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800069d4:	d4 31       	pushm	r0-r7,lr
800069d6:	fa cd 02 08 	sub	sp,sp,520
800069da:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800069dc:	e0 6a 01 00 	mov	r10,256
800069e0:	30 0b       	mov	r11,0
800069e2:	fa cc fe f8 	sub	r12,sp,-264
800069e6:	f0 1f 00 4e 	mcall	80006b1c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800069ea:	fa c4 fd d4 	sub	r4,sp,-556
800069ee:	30 0a       	mov	r10,0
800069f0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069f2:	fa c3 ff fc 	sub	r3,sp,-4
800069f6:	e0 61 01 00 	mov	r1,256
800069fa:	14 90       	mov	r0,r10
			
					if(*str == '%')
800069fc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800069fe:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a02:	02 9a       	mov	r10,r1
80006a04:	00 9b       	mov	r11,r0
80006a06:	06 9c       	mov	r12,r3
80006a08:	f0 1f 00 45 	mcall	80006b1c <log+0x148>
			
					if(*str == '%')
80006a0c:	0f 88       	ld.ub	r8,r7[0x0]
80006a0e:	e4 08 18 00 	cp.b	r8,r2
80006a12:	c5 71       	brne	80006ac0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006a14:	ee c8 ff ff 	sub	r8,r7,-1
80006a18:	11 89       	ld.ub	r9,r8[0x0]
80006a1a:	4c 2a       	lddpc	r10,80006b20 <log+0x14c>
80006a1c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006a1e:	23 09       	sub	r9,48
80006a20:	30 9a       	mov	r10,9
80006a22:	f4 09 18 00 	cp.b	r9,r10
80006a26:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006a2a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006a2e:	f7 b9 08 30 	subls	r9,48
80006a32:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a36:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a3a:	0f 88       	ld.ub	r8,r7[0x0]
80006a3c:	22 58       	sub	r8,37
80006a3e:	e0 48 00 53 	cp.w	r8,83
80006a42:	e0 8b 00 31 	brhi	80006aa4 <log+0xd0>
80006a46:	4b 89       	lddpc	r9,80006b24 <log+0x150>
80006a48:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006a4c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006a50:	06 9a       	mov	r10,r3
80006a52:	40 0b       	lddsp	r11,sp[0x0]
80006a54:	5c 5b       	castu.b	r11
80006a56:	68 0c       	ld.w	r12,r4[0x0]
80006a58:	f0 1f 00 34 	mcall	80006b28 <log+0x154>
							break;
80006a5c:	c2 98       	rjmp	80006aae <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006a5e:	4b 4c       	lddpc	r12,80006b2c <log+0x158>
80006a60:	f0 1f 00 34 	mcall	80006b30 <log+0x15c>
80006a64:	08 95       	mov	r5,r4
80006a66:	06 9c       	mov	r12,r3
							break;
80006a68:	c2 38       	rjmp	80006aae <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006a6a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006a6e:	06 9a       	mov	r10,r3
80006a70:	40 0b       	lddsp	r11,sp[0x0]
80006a72:	5c 5b       	castu.b	r11
80006a74:	68 0c       	ld.w	r12,r4[0x0]
80006a76:	f0 1f 00 30 	mcall	80006b34 <log+0x160>
80006a7a:	06 9c       	mov	r12,r3
							break;
80006a7c:	c1 98       	rjmp	80006aae <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006a7e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006a82:	06 9b       	mov	r11,r3
80006a84:	09 bc       	ld.ub	r12,r4[0x3]
80006a86:	f0 1f 00 2d 	mcall	80006b38 <log+0x164>
80006a8a:	06 9c       	mov	r12,r3
							break;
80006a8c:	c1 18       	rjmp	80006aae <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006a8e:	e8 c5 ff fc 	sub	r5,r4,-4
80006a92:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006a94:	c0 d8       	rjmp	80006aae <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006a96:	06 9b       	mov	r11,r3
80006a98:	32 5c       	mov	r12,37
80006a9a:	f0 1f 00 28 	mcall	80006b38 <log+0x164>
80006a9e:	08 95       	mov	r5,r4
80006aa0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006aa2:	c0 68       	rjmp	80006aae <log+0xda>
							
							default:
							log("I need relax.");
80006aa4:	4a 6c       	lddpc	r12,80006b3c <log+0x168>
80006aa6:	f0 1f 00 23 	mcall	80006b30 <log+0x15c>
80006aaa:	08 95       	mov	r5,r4
80006aac:	06 9c       	mov	r12,r3
						}
						str++;
80006aae:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006ab0:	1a dc       	st.w	--sp,r12
80006ab2:	1a d6       	st.w	--sp,r6
80006ab4:	4a 3b       	lddpc	r11,80006b40 <log+0x16c>
80006ab6:	0c 9c       	mov	r12,r6
80006ab8:	f0 1f 00 23 	mcall	80006b44 <log+0x170>
80006abc:	2f ed       	sub	sp,-8
80006abe:	c0 a8       	rjmp	80006ad2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ac0:	2f f7       	sub	r7,-1
80006ac2:	1a d8       	st.w	--sp,r8
80006ac4:	1a d6       	st.w	--sp,r6
80006ac6:	4a 1b       	lddpc	r11,80006b48 <log+0x174>
80006ac8:	0c 9c       	mov	r12,r6
80006aca:	f0 1f 00 1f 	mcall	80006b44 <log+0x170>
80006ace:	08 95       	mov	r5,r4
80006ad0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006ad2:	0f 89       	ld.ub	r9,r7[0x0]
80006ad4:	30 08       	mov	r8,0
80006ad6:	f0 09 18 00 	cp.b	r9,r8
80006ada:	c0 30       	breq	80006ae0 <log+0x10c>
80006adc:	0a 94       	mov	r4,r5
80006ade:	c9 2b       	rjmp	80006a02 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006ae0:	fa c7 fe f8 	sub	r7,sp,-264
80006ae4:	1a d7       	st.w	--sp,r7
80006ae6:	49 ab       	lddpc	r11,80006b4c <log+0x178>
80006ae8:	0e 9c       	mov	r12,r7
80006aea:	f0 1f 00 17 	mcall	80006b44 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006aee:	5c 5c       	castu.b	r12
80006af0:	f8 c6 ff ff 	sub	r6,r12,-1
80006af4:	0c 9c       	mov	r12,r6
80006af6:	f0 1f 00 17 	mcall	80006b50 <log+0x17c>
80006afa:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006afc:	0c 9a       	mov	r10,r6
80006afe:	0e 9b       	mov	r11,r7
80006b00:	f0 1f 00 15 	mcall	80006b54 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006b04:	30 09       	mov	r9,0
80006b06:	30 5a       	mov	r10,5
80006b08:	fa cb fe f8 	sub	r11,sp,-264
80006b0c:	49 38       	lddpc	r8,80006b58 <log+0x184>
80006b0e:	70 0c       	ld.w	r12,r8[0x0]
80006b10:	f0 1f 00 13 	mcall	80006b5c <log+0x188>
80006b14:	2f fd       	sub	sp,-4
	
	
}
80006b16:	fe 3d fd f8 	sub	sp,-520
80006b1a:	d8 32       	popm	r0-r7,pc
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	73 b0       	ld.w	r0,r9[0x6c]
80006b20:	00 00       	add	r0,r0
80006b22:	0d 3c       	ld.ub	r12,r6++
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	d2 cc       	*unknown*
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	68 fa       	ld.w	r10,r4[0x3c]
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	d5 78       	*unknown*
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	69 d4       	ld.w	r4,r4[0x74]
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	68 48       	ld.w	r8,r4[0x10]
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	68 44       	ld.w	r4,r4[0x10]
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	d5 88       	*unknown*
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	d5 98       	*unknown*
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	76 a0       	ld.w	r0,r11[0x28]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	d5 a0       	acall	0x5a
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	d5 a8       	*unknown*
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	5a e8       	cp.w	r8,-18
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	72 68       	ld.w	r8,r9[0x18]
80006b58:	00 00       	add	r0,r0
80006b5a:	41 14       	lddsp	r4,sp[0x44]
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5e 3c       	retlo	r12

80006b60 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006b60:	d4 31       	pushm	r0-r7,lr
80006b62:	fa cd 02 0c 	sub	sp,sp,524
80006b66:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006b68:	e0 6a 01 00 	mov	r10,256
80006b6c:	30 0b       	mov	r11,0
80006b6e:	fa cc fe f4 	sub	r12,sp,-268
80006b72:	f0 1f 00 4c 	mcall	80006ca0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006b76:	fa c4 fd d0 	sub	r4,sp,-560
80006b7a:	30 0a       	mov	r10,0
80006b7c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b7e:	fa c3 ff fc 	sub	r3,sp,-4
80006b82:	e0 61 01 00 	mov	r1,256
80006b86:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006b88:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b8a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b8e:	02 9a       	mov	r10,r1
80006b90:	00 9b       	mov	r11,r0
80006b92:	06 9c       	mov	r12,r3
80006b94:	f0 1f 00 43 	mcall	80006ca0 <logFromISR+0x140>
			
			if(*str == '%')
80006b98:	0f 88       	ld.ub	r8,r7[0x0]
80006b9a:	e4 08 18 00 	cp.b	r8,r2
80006b9e:	c5 11       	brne	80006c40 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006ba0:	ee c8 ff ff 	sub	r8,r7,-1
80006ba4:	11 89       	ld.ub	r9,r8[0x0]
80006ba6:	4c 0a       	lddpc	r10,80006ca4 <logFromISR+0x144>
80006ba8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006baa:	23 09       	sub	r9,48
80006bac:	30 9a       	mov	r10,9
80006bae:	f4 09 18 00 	cp.b	r9,r10
80006bb2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006bb6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006bba:	f7 b9 08 30 	subls	r9,48
80006bbe:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006bc2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006bc6:	0f 88       	ld.ub	r8,r7[0x0]
80006bc8:	22 58       	sub	r8,37
80006bca:	e0 48 00 53 	cp.w	r8,83
80006bce:	e0 8b 00 2b 	brhi	80006c24 <logFromISR+0xc4>
80006bd2:	4b 69       	lddpc	r9,80006ca8 <logFromISR+0x148>
80006bd4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006bd8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006bdc:	06 9a       	mov	r10,r3
80006bde:	40 0b       	lddsp	r11,sp[0x0]
80006be0:	5c 5b       	castu.b	r11
80006be2:	68 0c       	ld.w	r12,r4[0x0]
80006be4:	f0 1f 00 32 	mcall	80006cac <logFromISR+0x14c>
					break;
80006be8:	c2 38       	rjmp	80006c2e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006bea:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006bee:	06 9a       	mov	r10,r3
80006bf0:	40 0b       	lddsp	r11,sp[0x0]
80006bf2:	5c 5b       	castu.b	r11
80006bf4:	68 0c       	ld.w	r12,r4[0x0]
80006bf6:	f0 1f 00 2f 	mcall	80006cb0 <logFromISR+0x150>
80006bfa:	06 9c       	mov	r12,r3
					break;
80006bfc:	c1 98       	rjmp	80006c2e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006bfe:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006c02:	06 9b       	mov	r11,r3
80006c04:	09 bc       	ld.ub	r12,r4[0x3]
80006c06:	f0 1f 00 2c 	mcall	80006cb4 <logFromISR+0x154>
80006c0a:	06 9c       	mov	r12,r3
					break;
80006c0c:	c1 18       	rjmp	80006c2e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006c0e:	e8 c5 ff fc 	sub	r5,r4,-4
80006c12:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006c14:	c0 d8       	rjmp	80006c2e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006c16:	06 9b       	mov	r11,r3
80006c18:	32 5c       	mov	r12,37
80006c1a:	f0 1f 00 27 	mcall	80006cb4 <logFromISR+0x154>
80006c1e:	08 95       	mov	r5,r4
80006c20:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006c22:	c0 68       	rjmp	80006c2e <logFromISR+0xce>
					default:
					log("I need relax.");
80006c24:	4a 5c       	lddpc	r12,80006cb8 <logFromISR+0x158>
80006c26:	f0 1f 00 26 	mcall	80006cbc <logFromISR+0x15c>
80006c2a:	08 95       	mov	r5,r4
80006c2c:	06 9c       	mov	r12,r3
				}
				str++;
80006c2e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006c30:	1a dc       	st.w	--sp,r12
80006c32:	1a d6       	st.w	--sp,r6
80006c34:	4a 3b       	lddpc	r11,80006cc0 <logFromISR+0x160>
80006c36:	0c 9c       	mov	r12,r6
80006c38:	f0 1f 00 23 	mcall	80006cc4 <logFromISR+0x164>
80006c3c:	2f ed       	sub	sp,-8
80006c3e:	c0 a8       	rjmp	80006c52 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c40:	2f f7       	sub	r7,-1
80006c42:	1a d8       	st.w	--sp,r8
80006c44:	1a d6       	st.w	--sp,r6
80006c46:	4a 1b       	lddpc	r11,80006cc8 <logFromISR+0x168>
80006c48:	0c 9c       	mov	r12,r6
80006c4a:	f0 1f 00 1f 	mcall	80006cc4 <logFromISR+0x164>
80006c4e:	08 95       	mov	r5,r4
80006c50:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006c52:	0f 89       	ld.ub	r9,r7[0x0]
80006c54:	30 08       	mov	r8,0
80006c56:	f0 09 18 00 	cp.b	r9,r8
80006c5a:	c0 30       	breq	80006c60 <logFromISR+0x100>
80006c5c:	0a 94       	mov	r4,r5
80006c5e:	c9 8b       	rjmp	80006b8e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006c60:	fa c7 fe f4 	sub	r7,sp,-268
80006c64:	1a d7       	st.w	--sp,r7
80006c66:	49 ab       	lddpc	r11,80006ccc <logFromISR+0x16c>
80006c68:	0e 9c       	mov	r12,r7
80006c6a:	f0 1f 00 17 	mcall	80006cc4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006c6e:	5c 5c       	castu.b	r12
80006c70:	f8 c6 ff ff 	sub	r6,r12,-1
80006c74:	0c 9c       	mov	r12,r6
80006c76:	f0 1f 00 17 	mcall	80006cd0 <logFromISR+0x170>
80006c7a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006c7c:	0c 9a       	mov	r10,r6
80006c7e:	0e 9b       	mov	r11,r7
80006c80:	f0 1f 00 15 	mcall	80006cd4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006c84:	30 09       	mov	r9,0
80006c86:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006c88:	fa ca fe f8 	sub	r10,sp,-264
80006c8c:	fa cb fe f4 	sub	r11,sp,-268
80006c90:	49 28       	lddpc	r8,80006cd8 <logFromISR+0x178>
80006c92:	70 0c       	ld.w	r12,r8[0x0]
80006c94:	f0 1f 00 12 	mcall	80006cdc <logFromISR+0x17c>
80006c98:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006c9a:	fe 3d fd f4 	sub	sp,-524
80006c9e:	d8 32       	popm	r0-r7,pc
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	73 b0       	ld.w	r0,r9[0x6c]
80006ca4:	00 00       	add	r0,r0
80006ca6:	0d 3d       	ld.ub	sp,r6++
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	d4 1c       	*unknown*
80006cac:	80 00       	ld.sh	r0,r0[0x0]
80006cae:	68 fa       	ld.w	r10,r4[0x3c]
80006cb0:	80 00       	ld.sh	r0,r0[0x0]
80006cb2:	68 48       	ld.w	r8,r4[0x10]
80006cb4:	80 00       	ld.sh	r0,r0[0x0]
80006cb6:	68 44       	ld.w	r4,r4[0x10]
80006cb8:	80 00       	ld.sh	r0,r0[0x0]
80006cba:	d5 88       	*unknown*
80006cbc:	80 00       	ld.sh	r0,r0[0x0]
80006cbe:	69 d4       	ld.w	r4,r4[0x74]
80006cc0:	80 00       	ld.sh	r0,r0[0x0]
80006cc2:	d5 98       	*unknown*
80006cc4:	80 00       	ld.sh	r0,r0[0x0]
80006cc6:	76 a0       	ld.w	r0,r11[0x28]
80006cc8:	80 00       	ld.sh	r0,r0[0x0]
80006cca:	d5 a0       	acall	0x5a
80006ccc:	80 00       	ld.sh	r0,r0[0x0]
80006cce:	d5 a8       	*unknown*
80006cd0:	80 00       	ld.sh	r0,r0[0x0]
80006cd2:	5a e8       	cp.w	r8,-18
80006cd4:	80 00       	ld.sh	r0,r0[0x0]
80006cd6:	72 68       	ld.w	r8,r9[0x18]
80006cd8:	00 00       	add	r0,r0
80006cda:	41 14       	lddsp	r4,sp[0x44]
80006cdc:	80 00       	ld.sh	r0,r0[0x0]
80006cde:	5d ec       	*unknown*

80006ce0 <log_init>:
		
	return str;
}

void log_init(void)
{
80006ce0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006ce2:	30 2b       	mov	r11,2
80006ce4:	49 0c       	lddpc	r12,80006d24 <log_init+0x44>
80006ce6:	f0 1f 00 11 	mcall	80006d28 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006cea:	e0 6a 36 00 	mov	r10,13824
80006cee:	ea 1a 01 6e 	orh	r10,0x16e
80006cf2:	48 fb       	lddpc	r11,80006d2c <log_init+0x4c>
80006cf4:	fe 7c 18 00 	mov	r12,-59392
80006cf8:	f0 1f 00 0e 	mcall	80006d30 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006cfc:	30 4b       	mov	r11,4
80006cfe:	33 2c       	mov	r12,50
80006d00:	f0 1f 00 0d 	mcall	80006d34 <log_init+0x54>
80006d04:	48 d8       	lddpc	r8,80006d38 <log_init+0x58>
80006d06:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006d08:	30 09       	mov	r9,0
80006d0a:	1a d9       	st.w	--sp,r9
80006d0c:	1a d9       	st.w	--sp,r9
80006d0e:	1a d9       	st.w	--sp,r9
80006d10:	30 28       	mov	r8,2
80006d12:	e0 6a 01 80 	mov	r10,384
80006d16:	48 ab       	lddpc	r11,80006d3c <log_init+0x5c>
80006d18:	48 ac       	lddpc	r12,80006d40 <log_init+0x60>
80006d1a:	f0 1f 00 0b 	mcall	80006d44 <log_init+0x64>
80006d1e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006d20:	d8 02       	popm	pc
80006d22:	00 00       	add	r0,r0
80006d24:	80 00       	ld.sh	r0,r0[0x0]
80006d26:	d5 b4       	*unknown*
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	51 18       	stdsp	sp[0x44],r8
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	d5 6c       	*unknown*
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	56 4c       	stdsp	sp[0x190],r12
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	5f 3c       	srlo	r12
80006d38:	00 00       	add	r0,r0
80006d3a:	41 14       	lddsp	r4,sp[0x44]
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	d5 b0       	acall	0x5b
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	6d 48       	ld.w	r8,r6[0x50]
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	66 10       	ld.w	r0,r3[0x4]

80006d48 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006d48:	eb cd 40 f8 	pushm	r3-r7,lr
80006d4c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d4e:	48 c7       	lddpc	r7,80006d7c <task_log+0x34>
80006d50:	30 05       	mov	r5,0
80006d52:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006d54:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d58:	0a 99       	mov	r9,r5
80006d5a:	08 9a       	mov	r10,r4
80006d5c:	1a 9b       	mov	r11,sp
80006d5e:	6e 0c       	ld.w	r12,r7[0x0]
80006d60:	f0 1f 00 08 	mcall	80006d80 <task_log+0x38>
80006d64:	58 1c       	cp.w	r12,1
80006d66:	cf 91       	brne	80006d58 <task_log+0x10>
		{
			if( NULL != str)
80006d68:	40 0b       	lddsp	r11,sp[0x0]
80006d6a:	58 0b       	cp.w	r11,0
80006d6c:	cf 60       	breq	80006d58 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006d6e:	06 9c       	mov	r12,r3
80006d70:	f0 1f 00 05 	mcall	80006d84 <task_log+0x3c>
				vPortFree(str);
80006d74:	40 0c       	lddsp	r12,sp[0x0]
80006d76:	f0 1f 00 05 	mcall	80006d88 <task_log+0x40>
80006d7a:	ce fb       	rjmp	80006d58 <task_log+0x10>
80006d7c:	00 00       	add	r0,r0
80006d7e:	41 14       	lddsp	r4,sp[0x44]
80006d80:	80 00       	ld.sh	r0,r0[0x0]
80006d82:	5c 30       	neg	r0
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	55 fc       	stdsp	sp[0x17c],r12
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	5a c0       	cp.w	r0,-20

80006d8c <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006d8c:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006d8e:	fe 78 10 00 	mov	r8,-61440
80006d92:	30 19       	mov	r9,1
80006d94:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006d98:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006d9c:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006da0:	d3 03       	ssrf	0x10
	local_start_pll0();
80006da2:	f0 1f 00 12 	mcall	80006de8 <main+0x5c>
		
	INTC_init_interrupts();
80006da6:	f0 1f 00 12 	mcall	80006dec <main+0x60>
		
	log_init();
80006daa:	f0 1f 00 12 	mcall	80006df0 <main+0x64>
	log("----start debug----");
80006dae:	49 2c       	lddpc	r12,80006df4 <main+0x68>
80006db0:	f0 1f 00 12 	mcall	80006df8 <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006db4:	f0 1f 00 12 	mcall	80006dfc <main+0x70>
		
	app_init();
80006db8:	f0 1f 00 12 	mcall	80006e00 <main+0x74>
		
	xcmp_init();
80006dbc:	f0 1f 00 12 	mcall	80006e04 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006dc0:	fe 79 10 00 	mov	r9,-61440
80006dc4:	f2 f8 01 60 	ld.w	r8,r9[352]
80006dc8:	e2 18 00 02 	andl	r8,0x2,COH
80006dcc:	cf c0       	breq	80006dc4 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006dce:	fe 79 10 00 	mov	r9,-61440
80006dd2:	f2 f8 01 60 	ld.w	r8,r9[352]
80006dd6:	e2 18 00 02 	andl	r8,0x2,COH
80006dda:	cf c1       	brne	80006dd2 <main+0x46>
	local_start_timer();
80006ddc:	f0 1f 00 0b 	mcall	80006e08 <main+0x7c>
		
	Enable_global_interrupt();
80006de0:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006de2:	f0 1f 00 0b 	mcall	80006e0c <main+0x80>
	return 0;
	
}
80006de6:	d8 0a       	popm	pc,r12=0
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	50 3c       	stdsp	sp[0xc],r12
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	52 1c       	stdsp	sp[0x84],r12
80006df0:	80 00       	ld.sh	r0,r0[0x0]
80006df2:	6c e0       	ld.w	r0,r6[0x38]
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	d5 c4       	*unknown*
80006df8:	80 00       	ld.sh	r0,r0[0x0]
80006dfa:	69 d4       	ld.w	r4,r4[0x74]
80006dfc:	80 00       	ld.sh	r0,r0[0x0]
80006dfe:	4f ec       	lddpc	r12,80006ff4 <_malloc_r+0x1c4>
80006e00:	80 00       	ld.sh	r0,r0[0x0]
80006e02:	20 3c       	sub	r12,3
80006e04:	80 00       	ld.sh	r0,r0[0x0]
80006e06:	3e d4       	mov	r4,-19
80006e08:	80 00       	ld.sh	r0,r0[0x0]
80006e0a:	50 8c       	stdsp	sp[0x20],r12
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	67 f8       	ld.w	r8,r3[0x7c]

80006e10 <free>:
80006e10:	d4 01       	pushm	lr
80006e12:	e0 68 0a 38 	mov	r8,2616
80006e16:	18 9b       	mov	r11,r12
80006e18:	70 0c       	ld.w	r12,r8[0x0]
80006e1a:	e0 a0 1e 61 	rcall	8000aadc <_free_r>
80006e1e:	d8 02       	popm	pc

80006e20 <malloc>:
80006e20:	d4 01       	pushm	lr
80006e22:	e0 68 0a 38 	mov	r8,2616
80006e26:	18 9b       	mov	r11,r12
80006e28:	70 0c       	ld.w	r12,r8[0x0]
80006e2a:	c0 3c       	rcall	80006e30 <_malloc_r>
80006e2c:	d8 02       	popm	pc
80006e2e:	d7 03       	nop

80006e30 <_malloc_r>:
80006e30:	d4 31       	pushm	r0-r7,lr
80006e32:	f6 c8 ff f5 	sub	r8,r11,-11
80006e36:	18 95       	mov	r5,r12
80006e38:	10 97       	mov	r7,r8
80006e3a:	e0 17 ff f8 	andl	r7,0xfff8
80006e3e:	59 68       	cp.w	r8,22
80006e40:	f9 b7 08 10 	movls	r7,16
80006e44:	16 37       	cp.w	r7,r11
80006e46:	5f 38       	srlo	r8
80006e48:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006e4c:	c0 50       	breq	80006e56 <_malloc_r+0x26>
80006e4e:	30 c8       	mov	r8,12
80006e50:	99 38       	st.w	r12[0xc],r8
80006e52:	e0 8f 01 fa 	bral	80007246 <_malloc_r+0x416>
80006e56:	fe b0 f5 eb 	rcall	80005a2c <__malloc_lock>
80006e5a:	e0 47 01 f7 	cp.w	r7,503
80006e5e:	e0 8b 00 1d 	brhi	80006e98 <_malloc_r+0x68>
80006e62:	ee 03 16 03 	lsr	r3,r7,0x3
80006e66:	e0 68 05 38 	mov	r8,1336
80006e6a:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006e6e:	70 36       	ld.w	r6,r8[0xc]
80006e70:	10 36       	cp.w	r6,r8
80006e72:	c0 61       	brne	80006e7e <_malloc_r+0x4e>
80006e74:	ec c8 ff f8 	sub	r8,r6,-8
80006e78:	70 36       	ld.w	r6,r8[0xc]
80006e7a:	10 36       	cp.w	r6,r8
80006e7c:	c0 c0       	breq	80006e94 <_malloc_r+0x64>
80006e7e:	6c 18       	ld.w	r8,r6[0x4]
80006e80:	e0 18 ff fc 	andl	r8,0xfffc
80006e84:	6c 3a       	ld.w	r10,r6[0xc]
80006e86:	ec 08 00 09 	add	r9,r6,r8
80006e8a:	0a 9c       	mov	r12,r5
80006e8c:	6c 28       	ld.w	r8,r6[0x8]
80006e8e:	95 28       	st.w	r10[0x8],r8
80006e90:	91 3a       	st.w	r8[0xc],r10
80006e92:	c4 78       	rjmp	80006f20 <_malloc_r+0xf0>
80006e94:	2f e3       	sub	r3,-2
80006e96:	c4 d8       	rjmp	80006f30 <_malloc_r+0x100>
80006e98:	ee 03 16 09 	lsr	r3,r7,0x9
80006e9c:	c0 41       	brne	80006ea4 <_malloc_r+0x74>
80006e9e:	ee 03 16 03 	lsr	r3,r7,0x3
80006ea2:	c2 68       	rjmp	80006eee <_malloc_r+0xbe>
80006ea4:	58 43       	cp.w	r3,4
80006ea6:	e0 8b 00 06 	brhi	80006eb2 <_malloc_r+0x82>
80006eaa:	ee 03 16 06 	lsr	r3,r7,0x6
80006eae:	2c 83       	sub	r3,-56
80006eb0:	c1 f8       	rjmp	80006eee <_malloc_r+0xbe>
80006eb2:	59 43       	cp.w	r3,20
80006eb4:	e0 8b 00 04 	brhi	80006ebc <_malloc_r+0x8c>
80006eb8:	2a 53       	sub	r3,-91
80006eba:	c1 a8       	rjmp	80006eee <_malloc_r+0xbe>
80006ebc:	e0 43 00 54 	cp.w	r3,84
80006ec0:	e0 8b 00 06 	brhi	80006ecc <_malloc_r+0x9c>
80006ec4:	ee 03 16 0c 	lsr	r3,r7,0xc
80006ec8:	29 23       	sub	r3,-110
80006eca:	c1 28       	rjmp	80006eee <_malloc_r+0xbe>
80006ecc:	e0 43 01 54 	cp.w	r3,340
80006ed0:	e0 8b 00 06 	brhi	80006edc <_malloc_r+0xac>
80006ed4:	ee 03 16 0f 	lsr	r3,r7,0xf
80006ed8:	28 93       	sub	r3,-119
80006eda:	c0 a8       	rjmp	80006eee <_malloc_r+0xbe>
80006edc:	e0 43 05 54 	cp.w	r3,1364
80006ee0:	e0 88 00 04 	brls	80006ee8 <_malloc_r+0xb8>
80006ee4:	37 e3       	mov	r3,126
80006ee6:	c0 48       	rjmp	80006eee <_malloc_r+0xbe>
80006ee8:	ee 03 16 12 	lsr	r3,r7,0x12
80006eec:	28 43       	sub	r3,-124
80006eee:	e0 6a 05 38 	mov	r10,1336
80006ef2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006ef6:	74 36       	ld.w	r6,r10[0xc]
80006ef8:	c1 98       	rjmp	80006f2a <_malloc_r+0xfa>
80006efa:	6c 19       	ld.w	r9,r6[0x4]
80006efc:	e0 19 ff fc 	andl	r9,0xfffc
80006f00:	f2 07 01 0b 	sub	r11,r9,r7
80006f04:	58 fb       	cp.w	r11,15
80006f06:	e0 8a 00 04 	brle	80006f0e <_malloc_r+0xde>
80006f0a:	20 13       	sub	r3,1
80006f0c:	c1 18       	rjmp	80006f2e <_malloc_r+0xfe>
80006f0e:	6c 38       	ld.w	r8,r6[0xc]
80006f10:	58 0b       	cp.w	r11,0
80006f12:	c0 b5       	brlt	80006f28 <_malloc_r+0xf8>
80006f14:	6c 2a       	ld.w	r10,r6[0x8]
80006f16:	ec 09 00 09 	add	r9,r6,r9
80006f1a:	0a 9c       	mov	r12,r5
80006f1c:	91 2a       	st.w	r8[0x8],r10
80006f1e:	95 38       	st.w	r10[0xc],r8
80006f20:	72 18       	ld.w	r8,r9[0x4]
80006f22:	a1 a8       	sbr	r8,0x0
80006f24:	93 18       	st.w	r9[0x4],r8
80006f26:	cb c8       	rjmp	8000709e <_malloc_r+0x26e>
80006f28:	10 96       	mov	r6,r8
80006f2a:	14 36       	cp.w	r6,r10
80006f2c:	ce 71       	brne	80006efa <_malloc_r+0xca>
80006f2e:	2f f3       	sub	r3,-1
80006f30:	e0 6a 05 38 	mov	r10,1336
80006f34:	f4 cc ff f8 	sub	r12,r10,-8
80006f38:	78 26       	ld.w	r6,r12[0x8]
80006f3a:	18 36       	cp.w	r6,r12
80006f3c:	c6 c0       	breq	80007014 <_malloc_r+0x1e4>
80006f3e:	6c 19       	ld.w	r9,r6[0x4]
80006f40:	e0 19 ff fc 	andl	r9,0xfffc
80006f44:	f2 07 01 08 	sub	r8,r9,r7
80006f48:	58 f8       	cp.w	r8,15
80006f4a:	e0 89 00 8f 	brgt	80007068 <_malloc_r+0x238>
80006f4e:	99 3c       	st.w	r12[0xc],r12
80006f50:	99 2c       	st.w	r12[0x8],r12
80006f52:	58 08       	cp.w	r8,0
80006f54:	c0 55       	brlt	80006f5e <_malloc_r+0x12e>
80006f56:	ec 09 00 09 	add	r9,r6,r9
80006f5a:	0a 9c       	mov	r12,r5
80006f5c:	ce 2b       	rjmp	80006f20 <_malloc_r+0xf0>
80006f5e:	e0 49 01 ff 	cp.w	r9,511
80006f62:	e0 8b 00 13 	brhi	80006f88 <_malloc_r+0x158>
80006f66:	a3 99       	lsr	r9,0x3
80006f68:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006f6c:	70 2b       	ld.w	r11,r8[0x8]
80006f6e:	8d 38       	st.w	r6[0xc],r8
80006f70:	8d 2b       	st.w	r6[0x8],r11
80006f72:	97 36       	st.w	r11[0xc],r6
80006f74:	91 26       	st.w	r8[0x8],r6
80006f76:	a3 49       	asr	r9,0x2
80006f78:	74 18       	ld.w	r8,r10[0x4]
80006f7a:	30 1b       	mov	r11,1
80006f7c:	f6 09 09 49 	lsl	r9,r11,r9
80006f80:	f1 e9 10 09 	or	r9,r8,r9
80006f84:	95 19       	st.w	r10[0x4],r9
80006f86:	c4 78       	rjmp	80007014 <_malloc_r+0x1e4>
80006f88:	f2 0a 16 09 	lsr	r10,r9,0x9
80006f8c:	58 4a       	cp.w	r10,4
80006f8e:	e0 8b 00 07 	brhi	80006f9c <_malloc_r+0x16c>
80006f92:	f2 0a 16 06 	lsr	r10,r9,0x6
80006f96:	2c 8a       	sub	r10,-56
80006f98:	c2 08       	rjmp	80006fd8 <_malloc_r+0x1a8>
80006f9a:	d7 03       	nop
80006f9c:	59 4a       	cp.w	r10,20
80006f9e:	e0 8b 00 04 	brhi	80006fa6 <_malloc_r+0x176>
80006fa2:	2a 5a       	sub	r10,-91
80006fa4:	c1 a8       	rjmp	80006fd8 <_malloc_r+0x1a8>
80006fa6:	e0 4a 00 54 	cp.w	r10,84
80006faa:	e0 8b 00 06 	brhi	80006fb6 <_malloc_r+0x186>
80006fae:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006fb2:	29 2a       	sub	r10,-110
80006fb4:	c1 28       	rjmp	80006fd8 <_malloc_r+0x1a8>
80006fb6:	e0 4a 01 54 	cp.w	r10,340
80006fba:	e0 8b 00 06 	brhi	80006fc6 <_malloc_r+0x196>
80006fbe:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006fc2:	28 9a       	sub	r10,-119
80006fc4:	c0 a8       	rjmp	80006fd8 <_malloc_r+0x1a8>
80006fc6:	e0 4a 05 54 	cp.w	r10,1364
80006fca:	e0 88 00 04 	brls	80006fd2 <_malloc_r+0x1a2>
80006fce:	37 ea       	mov	r10,126
80006fd0:	c0 48       	rjmp	80006fd8 <_malloc_r+0x1a8>
80006fd2:	f2 0a 16 12 	lsr	r10,r9,0x12
80006fd6:	28 4a       	sub	r10,-124
80006fd8:	e0 6b 05 38 	mov	r11,1336
80006fdc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006fe0:	68 28       	ld.w	r8,r4[0x8]
80006fe2:	08 38       	cp.w	r8,r4
80006fe4:	c0 e1       	brne	80007000 <_malloc_r+0x1d0>
80006fe6:	76 19       	ld.w	r9,r11[0x4]
80006fe8:	a3 4a       	asr	r10,0x2
80006fea:	30 1e       	mov	lr,1
80006fec:	fc 0a 09 4a 	lsl	r10,lr,r10
80006ff0:	f3 ea 10 0a 	or	r10,r9,r10
80006ff4:	10 99       	mov	r9,r8
80006ff6:	97 1a       	st.w	r11[0x4],r10
80006ff8:	c0 a8       	rjmp	8000700c <_malloc_r+0x1dc>
80006ffa:	70 28       	ld.w	r8,r8[0x8]
80006ffc:	08 38       	cp.w	r8,r4
80006ffe:	c0 60       	breq	8000700a <_malloc_r+0x1da>
80007000:	70 1a       	ld.w	r10,r8[0x4]
80007002:	e0 1a ff fc 	andl	r10,0xfffc
80007006:	14 39       	cp.w	r9,r10
80007008:	cf 93       	brcs	80006ffa <_malloc_r+0x1ca>
8000700a:	70 39       	ld.w	r9,r8[0xc]
8000700c:	8d 39       	st.w	r6[0xc],r9
8000700e:	8d 28       	st.w	r6[0x8],r8
80007010:	91 36       	st.w	r8[0xc],r6
80007012:	93 26       	st.w	r9[0x8],r6
80007014:	e6 08 14 02 	asr	r8,r3,0x2
80007018:	30 1b       	mov	r11,1
8000701a:	e0 64 05 38 	mov	r4,1336
8000701e:	f6 08 09 4b 	lsl	r11,r11,r8
80007022:	68 18       	ld.w	r8,r4[0x4]
80007024:	10 3b       	cp.w	r11,r8
80007026:	e0 8b 00 6b 	brhi	800070fc <_malloc_r+0x2cc>
8000702a:	f7 e8 00 09 	and	r9,r11,r8
8000702e:	c0 b1       	brne	80007044 <_malloc_r+0x214>
80007030:	e0 13 ff fc 	andl	r3,0xfffc
80007034:	a1 7b       	lsl	r11,0x1
80007036:	2f c3       	sub	r3,-4
80007038:	c0 38       	rjmp	8000703e <_malloc_r+0x20e>
8000703a:	2f c3       	sub	r3,-4
8000703c:	a1 7b       	lsl	r11,0x1
8000703e:	f7 e8 00 09 	and	r9,r11,r8
80007042:	cf c0       	breq	8000703a <_malloc_r+0x20a>
80007044:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007048:	06 92       	mov	r2,r3
8000704a:	1c 91       	mov	r1,lr
8000704c:	62 36       	ld.w	r6,r1[0xc]
8000704e:	c2 e8       	rjmp	800070aa <_malloc_r+0x27a>
80007050:	6c 1a       	ld.w	r10,r6[0x4]
80007052:	e0 1a ff fc 	andl	r10,0xfffc
80007056:	f4 07 01 08 	sub	r8,r10,r7
8000705a:	58 f8       	cp.w	r8,15
8000705c:	e0 8a 00 15 	brle	80007086 <_malloc_r+0x256>
80007060:	6c 3a       	ld.w	r10,r6[0xc]
80007062:	6c 29       	ld.w	r9,r6[0x8]
80007064:	95 29       	st.w	r10[0x8],r9
80007066:	93 3a       	st.w	r9[0xc],r10
80007068:	0e 99       	mov	r9,r7
8000706a:	ec 07 00 07 	add	r7,r6,r7
8000706e:	a1 a9       	sbr	r9,0x0
80007070:	99 37       	st.w	r12[0xc],r7
80007072:	99 27       	st.w	r12[0x8],r7
80007074:	8d 19       	st.w	r6[0x4],r9
80007076:	ee 08 09 08 	st.w	r7[r8],r8
8000707a:	8f 2c       	st.w	r7[0x8],r12
8000707c:	8f 3c       	st.w	r7[0xc],r12
8000707e:	a1 a8       	sbr	r8,0x0
80007080:	0a 9c       	mov	r12,r5
80007082:	8f 18       	st.w	r7[0x4],r8
80007084:	c0 d8       	rjmp	8000709e <_malloc_r+0x26e>
80007086:	6c 39       	ld.w	r9,r6[0xc]
80007088:	58 08       	cp.w	r8,0
8000708a:	c0 f5       	brlt	800070a8 <_malloc_r+0x278>
8000708c:	ec 0a 00 0a 	add	r10,r6,r10
80007090:	74 18       	ld.w	r8,r10[0x4]
80007092:	a1 a8       	sbr	r8,0x0
80007094:	0a 9c       	mov	r12,r5
80007096:	95 18       	st.w	r10[0x4],r8
80007098:	6c 28       	ld.w	r8,r6[0x8]
8000709a:	93 28       	st.w	r9[0x8],r8
8000709c:	91 39       	st.w	r8[0xc],r9
8000709e:	fe b0 f4 cd 	rcall	80005a38 <__malloc_unlock>
800070a2:	ec cc ff f8 	sub	r12,r6,-8
800070a6:	d8 32       	popm	r0-r7,pc
800070a8:	12 96       	mov	r6,r9
800070aa:	02 36       	cp.w	r6,r1
800070ac:	cd 21       	brne	80007050 <_malloc_r+0x220>
800070ae:	2f f2       	sub	r2,-1
800070b0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800070b4:	c0 30       	breq	800070ba <_malloc_r+0x28a>
800070b6:	2f 81       	sub	r1,-8
800070b8:	cc ab       	rjmp	8000704c <_malloc_r+0x21c>
800070ba:	1c 98       	mov	r8,lr
800070bc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800070c0:	c0 81       	brne	800070d0 <_malloc_r+0x2a0>
800070c2:	68 19       	ld.w	r9,r4[0x4]
800070c4:	f6 08 11 ff 	rsub	r8,r11,-1
800070c8:	f3 e8 00 08 	and	r8,r9,r8
800070cc:	89 18       	st.w	r4[0x4],r8
800070ce:	c0 78       	rjmp	800070dc <_malloc_r+0x2ac>
800070d0:	f0 c9 00 08 	sub	r9,r8,8
800070d4:	20 13       	sub	r3,1
800070d6:	70 08       	ld.w	r8,r8[0x0]
800070d8:	12 38       	cp.w	r8,r9
800070da:	cf 10       	breq	800070bc <_malloc_r+0x28c>
800070dc:	a1 7b       	lsl	r11,0x1
800070de:	68 18       	ld.w	r8,r4[0x4]
800070e0:	10 3b       	cp.w	r11,r8
800070e2:	e0 8b 00 0d 	brhi	800070fc <_malloc_r+0x2cc>
800070e6:	58 0b       	cp.w	r11,0
800070e8:	c0 a0       	breq	800070fc <_malloc_r+0x2cc>
800070ea:	04 93       	mov	r3,r2
800070ec:	c0 38       	rjmp	800070f2 <_malloc_r+0x2c2>
800070ee:	2f c3       	sub	r3,-4
800070f0:	a1 7b       	lsl	r11,0x1
800070f2:	f7 e8 00 09 	and	r9,r11,r8
800070f6:	ca 71       	brne	80007044 <_malloc_r+0x214>
800070f8:	cf bb       	rjmp	800070ee <_malloc_r+0x2be>
800070fa:	d7 03       	nop
800070fc:	68 23       	ld.w	r3,r4[0x8]
800070fe:	66 12       	ld.w	r2,r3[0x4]
80007100:	e0 12 ff fc 	andl	r2,0xfffc
80007104:	0e 32       	cp.w	r2,r7
80007106:	5f 39       	srlo	r9
80007108:	e4 07 01 08 	sub	r8,r2,r7
8000710c:	58 f8       	cp.w	r8,15
8000710e:	5f aa       	srle	r10
80007110:	f5 e9 10 09 	or	r9,r10,r9
80007114:	e0 80 00 9a 	breq	80007248 <_malloc_r+0x418>
80007118:	e0 68 0d 48 	mov	r8,3400
8000711c:	70 01       	ld.w	r1,r8[0x0]
8000711e:	e0 68 09 44 	mov	r8,2372
80007122:	2f 01       	sub	r1,-16
80007124:	70 08       	ld.w	r8,r8[0x0]
80007126:	0e 01       	add	r1,r7
80007128:	5b f8       	cp.w	r8,-1
8000712a:	c0 40       	breq	80007132 <_malloc_r+0x302>
8000712c:	28 11       	sub	r1,-127
8000712e:	e0 11 ff 80 	andl	r1,0xff80
80007132:	02 9b       	mov	r11,r1
80007134:	0a 9c       	mov	r12,r5
80007136:	e0 a0 02 a5 	rcall	80007680 <_sbrk_r>
8000713a:	18 96       	mov	r6,r12
8000713c:	5b fc       	cp.w	r12,-1
8000713e:	c7 50       	breq	80007228 <_malloc_r+0x3f8>
80007140:	e6 02 00 08 	add	r8,r3,r2
80007144:	10 3c       	cp.w	r12,r8
80007146:	c0 32       	brcc	8000714c <_malloc_r+0x31c>
80007148:	08 33       	cp.w	r3,r4
8000714a:	c6 f1       	brne	80007228 <_malloc_r+0x3f8>
8000714c:	e0 6a 0d 4c 	mov	r10,3404
80007150:	74 09       	ld.w	r9,r10[0x0]
80007152:	e2 09 00 09 	add	r9,r1,r9
80007156:	95 09       	st.w	r10[0x0],r9
80007158:	10 36       	cp.w	r6,r8
8000715a:	c0 a1       	brne	8000716e <_malloc_r+0x33e>
8000715c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007160:	c0 71       	brne	8000716e <_malloc_r+0x33e>
80007162:	e2 02 00 02 	add	r2,r1,r2
80007166:	68 28       	ld.w	r8,r4[0x8]
80007168:	a1 a2       	sbr	r2,0x0
8000716a:	91 12       	st.w	r8[0x4],r2
8000716c:	c4 f8       	rjmp	8000720a <_malloc_r+0x3da>
8000716e:	e0 6a 09 44 	mov	r10,2372
80007172:	74 0b       	ld.w	r11,r10[0x0]
80007174:	5b fb       	cp.w	r11,-1
80007176:	c0 31       	brne	8000717c <_malloc_r+0x34c>
80007178:	95 06       	st.w	r10[0x0],r6
8000717a:	c0 78       	rjmp	80007188 <_malloc_r+0x358>
8000717c:	ec 09 00 09 	add	r9,r6,r9
80007180:	e0 6a 0d 4c 	mov	r10,3404
80007184:	10 19       	sub	r9,r8
80007186:	95 09       	st.w	r10[0x0],r9
80007188:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000718c:	f0 09 11 08 	rsub	r9,r8,8
80007190:	58 08       	cp.w	r8,0
80007192:	f2 08 17 10 	movne	r8,r9
80007196:	ed d8 e1 06 	addne	r6,r6,r8
8000719a:	28 08       	sub	r8,-128
8000719c:	ec 01 00 01 	add	r1,r6,r1
800071a0:	0a 9c       	mov	r12,r5
800071a2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800071a6:	f0 01 01 01 	sub	r1,r8,r1
800071aa:	02 9b       	mov	r11,r1
800071ac:	e0 a0 02 6a 	rcall	80007680 <_sbrk_r>
800071b0:	e0 68 0d 4c 	mov	r8,3404
800071b4:	5b fc       	cp.w	r12,-1
800071b6:	ec 0c 17 00 	moveq	r12,r6
800071ba:	f9 b1 00 00 	moveq	r1,0
800071be:	70 09       	ld.w	r9,r8[0x0]
800071c0:	0c 1c       	sub	r12,r6
800071c2:	89 26       	st.w	r4[0x8],r6
800071c4:	02 0c       	add	r12,r1
800071c6:	12 01       	add	r1,r9
800071c8:	a1 ac       	sbr	r12,0x0
800071ca:	91 01       	st.w	r8[0x0],r1
800071cc:	8d 1c       	st.w	r6[0x4],r12
800071ce:	08 33       	cp.w	r3,r4
800071d0:	c1 d0       	breq	8000720a <_malloc_r+0x3da>
800071d2:	58 f2       	cp.w	r2,15
800071d4:	e0 8b 00 05 	brhi	800071de <_malloc_r+0x3ae>
800071d8:	30 18       	mov	r8,1
800071da:	8d 18       	st.w	r6[0x4],r8
800071dc:	c2 68       	rjmp	80007228 <_malloc_r+0x3f8>
800071de:	30 59       	mov	r9,5
800071e0:	20 c2       	sub	r2,12
800071e2:	e0 12 ff f8 	andl	r2,0xfff8
800071e6:	e6 02 00 08 	add	r8,r3,r2
800071ea:	91 29       	st.w	r8[0x8],r9
800071ec:	91 19       	st.w	r8[0x4],r9
800071ee:	66 18       	ld.w	r8,r3[0x4]
800071f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071f4:	e5 e8 10 08 	or	r8,r2,r8
800071f8:	87 18       	st.w	r3[0x4],r8
800071fa:	58 f2       	cp.w	r2,15
800071fc:	e0 88 00 07 	brls	8000720a <_malloc_r+0x3da>
80007200:	e6 cb ff f8 	sub	r11,r3,-8
80007204:	0a 9c       	mov	r12,r5
80007206:	e0 a0 1c 6b 	rcall	8000aadc <_free_r>
8000720a:	e0 69 0d 44 	mov	r9,3396
8000720e:	72 0a       	ld.w	r10,r9[0x0]
80007210:	e0 68 0d 4c 	mov	r8,3404
80007214:	70 08       	ld.w	r8,r8[0x0]
80007216:	14 38       	cp.w	r8,r10
80007218:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000721c:	e0 69 0d 40 	mov	r9,3392
80007220:	72 0a       	ld.w	r10,r9[0x0]
80007222:	14 38       	cp.w	r8,r10
80007224:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007228:	68 28       	ld.w	r8,r4[0x8]
8000722a:	70 18       	ld.w	r8,r8[0x4]
8000722c:	e0 18 ff fc 	andl	r8,0xfffc
80007230:	0e 38       	cp.w	r8,r7
80007232:	5f 39       	srlo	r9
80007234:	0e 18       	sub	r8,r7
80007236:	58 f8       	cp.w	r8,15
80007238:	5f aa       	srle	r10
8000723a:	f5 e9 10 09 	or	r9,r10,r9
8000723e:	c0 50       	breq	80007248 <_malloc_r+0x418>
80007240:	0a 9c       	mov	r12,r5
80007242:	fe b0 f3 fb 	rcall	80005a38 <__malloc_unlock>
80007246:	d8 3a       	popm	r0-r7,pc,r12=0
80007248:	68 26       	ld.w	r6,r4[0x8]
8000724a:	a1 a8       	sbr	r8,0x0
8000724c:	0e 99       	mov	r9,r7
8000724e:	a1 a9       	sbr	r9,0x0
80007250:	8d 19       	st.w	r6[0x4],r9
80007252:	ec 07 00 07 	add	r7,r6,r7
80007256:	0a 9c       	mov	r12,r5
80007258:	89 27       	st.w	r4[0x8],r7
8000725a:	8f 18       	st.w	r7[0x4],r8
8000725c:	fe b0 f3 ee 	rcall	80005a38 <__malloc_unlock>
80007260:	ec cc ff f8 	sub	r12,r6,-8
80007264:	d8 32       	popm	r0-r7,pc
80007266:	d7 03       	nop

80007268 <memcpy>:
80007268:	58 8a       	cp.w	r10,8
8000726a:	c2 f5       	brlt	800072c8 <memcpy+0x60>
8000726c:	f9 eb 10 09 	or	r9,r12,r11
80007270:	e2 19 00 03 	andl	r9,0x3,COH
80007274:	e0 81 00 97 	brne	800073a2 <memcpy+0x13a>
80007278:	e0 4a 00 20 	cp.w	r10,32
8000727c:	c3 b4       	brge	800072f2 <memcpy+0x8a>
8000727e:	f4 08 14 02 	asr	r8,r10,0x2
80007282:	f0 09 11 08 	rsub	r9,r8,8
80007286:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000728a:	76 69       	ld.w	r9,r11[0x18]
8000728c:	99 69       	st.w	r12[0x18],r9
8000728e:	76 59       	ld.w	r9,r11[0x14]
80007290:	99 59       	st.w	r12[0x14],r9
80007292:	76 49       	ld.w	r9,r11[0x10]
80007294:	99 49       	st.w	r12[0x10],r9
80007296:	76 39       	ld.w	r9,r11[0xc]
80007298:	99 39       	st.w	r12[0xc],r9
8000729a:	76 29       	ld.w	r9,r11[0x8]
8000729c:	99 29       	st.w	r12[0x8],r9
8000729e:	76 19       	ld.w	r9,r11[0x4]
800072a0:	99 19       	st.w	r12[0x4],r9
800072a2:	76 09       	ld.w	r9,r11[0x0]
800072a4:	99 09       	st.w	r12[0x0],r9
800072a6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800072aa:	f8 08 00 28 	add	r8,r12,r8<<0x2
800072ae:	e0 1a 00 03 	andl	r10,0x3
800072b2:	f4 0a 11 04 	rsub	r10,r10,4
800072b6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072ba:	17 a9       	ld.ub	r9,r11[0x2]
800072bc:	b0 a9       	st.b	r8[0x2],r9
800072be:	17 99       	ld.ub	r9,r11[0x1]
800072c0:	b0 99       	st.b	r8[0x1],r9
800072c2:	17 89       	ld.ub	r9,r11[0x0]
800072c4:	b0 89       	st.b	r8[0x0],r9
800072c6:	5e fc       	retal	r12
800072c8:	f4 0a 11 09 	rsub	r10,r10,9
800072cc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072d0:	17 f9       	ld.ub	r9,r11[0x7]
800072d2:	b8 f9       	st.b	r12[0x7],r9
800072d4:	17 e9       	ld.ub	r9,r11[0x6]
800072d6:	b8 e9       	st.b	r12[0x6],r9
800072d8:	17 d9       	ld.ub	r9,r11[0x5]
800072da:	b8 d9       	st.b	r12[0x5],r9
800072dc:	17 c9       	ld.ub	r9,r11[0x4]
800072de:	b8 c9       	st.b	r12[0x4],r9
800072e0:	17 b9       	ld.ub	r9,r11[0x3]
800072e2:	b8 b9       	st.b	r12[0x3],r9
800072e4:	17 a9       	ld.ub	r9,r11[0x2]
800072e6:	b8 a9       	st.b	r12[0x2],r9
800072e8:	17 99       	ld.ub	r9,r11[0x1]
800072ea:	b8 99       	st.b	r12[0x1],r9
800072ec:	17 89       	ld.ub	r9,r11[0x0]
800072ee:	b8 89       	st.b	r12[0x0],r9
800072f0:	5e fc       	retal	r12
800072f2:	eb cd 40 c0 	pushm	r6-r7,lr
800072f6:	18 99       	mov	r9,r12
800072f8:	22 0a       	sub	r10,32
800072fa:	b7 07       	ld.d	r6,r11++
800072fc:	b3 26       	st.d	r9++,r6
800072fe:	b7 07       	ld.d	r6,r11++
80007300:	b3 26       	st.d	r9++,r6
80007302:	b7 07       	ld.d	r6,r11++
80007304:	b3 26       	st.d	r9++,r6
80007306:	b7 07       	ld.d	r6,r11++
80007308:	b3 26       	st.d	r9++,r6
8000730a:	22 0a       	sub	r10,32
8000730c:	cf 74       	brge	800072fa <memcpy+0x92>
8000730e:	2f 0a       	sub	r10,-16
80007310:	c0 65       	brlt	8000731c <memcpy+0xb4>
80007312:	b7 07       	ld.d	r6,r11++
80007314:	b3 26       	st.d	r9++,r6
80007316:	b7 07       	ld.d	r6,r11++
80007318:	b3 26       	st.d	r9++,r6
8000731a:	21 0a       	sub	r10,16
8000731c:	5c 3a       	neg	r10
8000731e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007322:	d7 03       	nop
80007324:	d7 03       	nop
80007326:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000732a:	f3 66 00 0e 	st.b	r9[14],r6
8000732e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007332:	f3 66 00 0d 	st.b	r9[13],r6
80007336:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000733a:	f3 66 00 0c 	st.b	r9[12],r6
8000733e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007342:	f3 66 00 0b 	st.b	r9[11],r6
80007346:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000734a:	f3 66 00 0a 	st.b	r9[10],r6
8000734e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007352:	f3 66 00 09 	st.b	r9[9],r6
80007356:	f7 36 00 08 	ld.ub	r6,r11[8]
8000735a:	f3 66 00 08 	st.b	r9[8],r6
8000735e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007362:	f3 66 00 07 	st.b	r9[7],r6
80007366:	f7 36 00 06 	ld.ub	r6,r11[6]
8000736a:	f3 66 00 06 	st.b	r9[6],r6
8000736e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007372:	f3 66 00 05 	st.b	r9[5],r6
80007376:	f7 36 00 04 	ld.ub	r6,r11[4]
8000737a:	f3 66 00 04 	st.b	r9[4],r6
8000737e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007382:	f3 66 00 03 	st.b	r9[3],r6
80007386:	f7 36 00 02 	ld.ub	r6,r11[2]
8000738a:	f3 66 00 02 	st.b	r9[2],r6
8000738e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007392:	f3 66 00 01 	st.b	r9[1],r6
80007396:	f7 36 00 00 	ld.ub	r6,r11[0]
8000739a:	f3 66 00 00 	st.b	r9[0],r6
8000739e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073a2:	20 1a       	sub	r10,1
800073a4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800073a8:	f8 0a 0b 09 	st.b	r12[r10],r9
800073ac:	cf b1       	brne	800073a2 <memcpy+0x13a>
800073ae:	5e fc       	retal	r12

800073b0 <memset>:
800073b0:	18 98       	mov	r8,r12
800073b2:	c0 38       	rjmp	800073b8 <memset+0x8>
800073b4:	10 cb       	st.b	r8++,r11
800073b6:	20 1a       	sub	r10,1
800073b8:	58 0a       	cp.w	r10,0
800073ba:	cf d1       	brne	800073b4 <memset+0x4>
800073bc:	5e fc       	retal	r12
800073be:	d7 03       	nop

800073c0 <_realloc_r>:
800073c0:	d4 31       	pushm	r0-r7,lr
800073c2:	20 1d       	sub	sp,4
800073c4:	16 94       	mov	r4,r11
800073c6:	18 92       	mov	r2,r12
800073c8:	14 9b       	mov	r11,r10
800073ca:	58 04       	cp.w	r4,0
800073cc:	c0 51       	brne	800073d6 <_realloc_r+0x16>
800073ce:	fe b0 fd 31 	rcall	80006e30 <_malloc_r>
800073d2:	18 95       	mov	r5,r12
800073d4:	c5 39       	rjmp	8000767a <_realloc_r+0x2ba>
800073d6:	50 0a       	stdsp	sp[0x0],r10
800073d8:	fe b0 f3 2a 	rcall	80005a2c <__malloc_lock>
800073dc:	40 0b       	lddsp	r11,sp[0x0]
800073de:	f6 c8 ff f5 	sub	r8,r11,-11
800073e2:	e8 c1 00 08 	sub	r1,r4,8
800073e6:	10 96       	mov	r6,r8
800073e8:	62 1c       	ld.w	r12,r1[0x4]
800073ea:	e0 16 ff f8 	andl	r6,0xfff8
800073ee:	59 68       	cp.w	r8,22
800073f0:	f9 b6 08 10 	movls	r6,16
800073f4:	16 36       	cp.w	r6,r11
800073f6:	5f 38       	srlo	r8
800073f8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800073fc:	c0 50       	breq	80007406 <_realloc_r+0x46>
800073fe:	30 c8       	mov	r8,12
80007400:	30 05       	mov	r5,0
80007402:	85 38       	st.w	r2[0xc],r8
80007404:	c3 b9       	rjmp	8000767a <_realloc_r+0x2ba>
80007406:	18 90       	mov	r0,r12
80007408:	e0 10 ff fc 	andl	r0,0xfffc
8000740c:	0c 30       	cp.w	r0,r6
8000740e:	e0 84 01 0b 	brge	80007624 <_realloc_r+0x264>
80007412:	e0 68 05 38 	mov	r8,1336
80007416:	e2 00 00 09 	add	r9,r1,r0
8000741a:	70 25       	ld.w	r5,r8[0x8]
8000741c:	0a 39       	cp.w	r9,r5
8000741e:	c0 90       	breq	80007430 <_realloc_r+0x70>
80007420:	72 1a       	ld.w	r10,r9[0x4]
80007422:	a1 ca       	cbr	r10,0x0
80007424:	f2 0a 00 0a 	add	r10,r9,r10
80007428:	74 1a       	ld.w	r10,r10[0x4]
8000742a:	ed ba 00 00 	bld	r10,0x0
8000742e:	c2 20       	breq	80007472 <_realloc_r+0xb2>
80007430:	72 1a       	ld.w	r10,r9[0x4]
80007432:	e0 1a ff fc 	andl	r10,0xfffc
80007436:	f4 00 00 03 	add	r3,r10,r0
8000743a:	0a 39       	cp.w	r9,r5
8000743c:	c1 31       	brne	80007462 <_realloc_r+0xa2>
8000743e:	ec c7 ff f0 	sub	r7,r6,-16
80007442:	0e 33       	cp.w	r3,r7
80007444:	c1 95       	brlt	80007476 <_realloc_r+0xb6>
80007446:	e2 06 00 09 	add	r9,r1,r6
8000744a:	0c 13       	sub	r3,r6
8000744c:	a1 a3       	sbr	r3,0x0
8000744e:	93 13       	st.w	r9[0x4],r3
80007450:	91 29       	st.w	r8[0x8],r9
80007452:	04 9c       	mov	r12,r2
80007454:	62 18       	ld.w	r8,r1[0x4]
80007456:	08 95       	mov	r5,r4
80007458:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000745c:	10 46       	or	r6,r8
8000745e:	83 16       	st.w	r1[0x4],r6
80007460:	c0 b9       	rjmp	80007676 <_realloc_r+0x2b6>
80007462:	0c 33       	cp.w	r3,r6
80007464:	c0 95       	brlt	80007476 <_realloc_r+0xb6>
80007466:	72 28       	ld.w	r8,r9[0x8]
80007468:	02 97       	mov	r7,r1
8000746a:	72 39       	ld.w	r9,r9[0xc]
8000746c:	93 28       	st.w	r9[0x8],r8
8000746e:	91 39       	st.w	r8[0xc],r9
80007470:	cd c8       	rjmp	80007628 <_realloc_r+0x268>
80007472:	30 0a       	mov	r10,0
80007474:	14 99       	mov	r9,r10
80007476:	ed bc 00 00 	bld	r12,0x0
8000747a:	e0 80 00 95 	breq	800075a4 <_realloc_r+0x1e4>
8000747e:	62 07       	ld.w	r7,r1[0x0]
80007480:	e2 07 01 07 	sub	r7,r1,r7
80007484:	6e 1c       	ld.w	r12,r7[0x4]
80007486:	e0 1c ff fc 	andl	r12,0xfffc
8000748a:	58 09       	cp.w	r9,0
8000748c:	c5 60       	breq	80007538 <_realloc_r+0x178>
8000748e:	f8 00 00 03 	add	r3,r12,r0
80007492:	0a 39       	cp.w	r9,r5
80007494:	c4 81       	brne	80007524 <_realloc_r+0x164>
80007496:	14 03       	add	r3,r10
80007498:	ec c9 ff f0 	sub	r9,r6,-16
8000749c:	12 33       	cp.w	r3,r9
8000749e:	c4 d5       	brlt	80007538 <_realloc_r+0x178>
800074a0:	6e 3a       	ld.w	r10,r7[0xc]
800074a2:	6e 29       	ld.w	r9,r7[0x8]
800074a4:	95 29       	st.w	r10[0x8],r9
800074a6:	93 3a       	st.w	r9[0xc],r10
800074a8:	ee c5 ff f8 	sub	r5,r7,-8
800074ac:	e0 ca 00 04 	sub	r10,r0,4
800074b0:	e0 4a 00 24 	cp.w	r10,36
800074b4:	e0 8b 00 25 	brhi	800074fe <_realloc_r+0x13e>
800074b8:	0a 99       	mov	r9,r5
800074ba:	59 3a       	cp.w	r10,19
800074bc:	e0 88 00 1a 	brls	800074f0 <_realloc_r+0x130>
800074c0:	09 09       	ld.w	r9,r4++
800074c2:	8b 09       	st.w	r5[0x0],r9
800074c4:	09 09       	ld.w	r9,r4++
800074c6:	8f 39       	st.w	r7[0xc],r9
800074c8:	ee c9 ff f0 	sub	r9,r7,-16
800074cc:	59 ba       	cp.w	r10,27
800074ce:	e0 88 00 11 	brls	800074f0 <_realloc_r+0x130>
800074d2:	09 0b       	ld.w	r11,r4++
800074d4:	93 0b       	st.w	r9[0x0],r11
800074d6:	09 09       	ld.w	r9,r4++
800074d8:	8f 59       	st.w	r7[0x14],r9
800074da:	ee c9 ff e8 	sub	r9,r7,-24
800074de:	e0 4a 00 24 	cp.w	r10,36
800074e2:	c0 71       	brne	800074f0 <_realloc_r+0x130>
800074e4:	09 0a       	ld.w	r10,r4++
800074e6:	93 0a       	st.w	r9[0x0],r10
800074e8:	ee c9 ff e0 	sub	r9,r7,-32
800074ec:	09 0a       	ld.w	r10,r4++
800074ee:	8f 7a       	st.w	r7[0x1c],r10
800074f0:	09 0a       	ld.w	r10,r4++
800074f2:	12 aa       	st.w	r9++,r10
800074f4:	68 0a       	ld.w	r10,r4[0x0]
800074f6:	93 0a       	st.w	r9[0x0],r10
800074f8:	68 1a       	ld.w	r10,r4[0x4]
800074fa:	93 1a       	st.w	r9[0x4],r10
800074fc:	c0 78       	rjmp	8000750a <_realloc_r+0x14a>
800074fe:	50 08       	stdsp	sp[0x0],r8
80007500:	08 9b       	mov	r11,r4
80007502:	0a 9c       	mov	r12,r5
80007504:	e0 a0 1d 8f 	rcall	8000b022 <memmove>
80007508:	40 08       	lddsp	r8,sp[0x0]
8000750a:	ee 06 00 09 	add	r9,r7,r6
8000750e:	0c 13       	sub	r3,r6
80007510:	a1 a3       	sbr	r3,0x0
80007512:	93 13       	st.w	r9[0x4],r3
80007514:	91 29       	st.w	r8[0x8],r9
80007516:	04 9c       	mov	r12,r2
80007518:	6e 18       	ld.w	r8,r7[0x4]
8000751a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000751e:	10 46       	or	r6,r8
80007520:	8f 16       	st.w	r7[0x4],r6
80007522:	ca a8       	rjmp	80007676 <_realloc_r+0x2b6>
80007524:	14 03       	add	r3,r10
80007526:	0c 33       	cp.w	r3,r6
80007528:	c0 85       	brlt	80007538 <_realloc_r+0x178>
8000752a:	72 28       	ld.w	r8,r9[0x8]
8000752c:	72 39       	ld.w	r9,r9[0xc]
8000752e:	93 28       	st.w	r9[0x8],r8
80007530:	91 39       	st.w	r8[0xc],r9
80007532:	6e 28       	ld.w	r8,r7[0x8]
80007534:	6e 39       	ld.w	r9,r7[0xc]
80007536:	c0 78       	rjmp	80007544 <_realloc_r+0x184>
80007538:	f8 00 00 03 	add	r3,r12,r0
8000753c:	0c 33       	cp.w	r3,r6
8000753e:	c3 35       	brlt	800075a4 <_realloc_r+0x1e4>
80007540:	6e 39       	ld.w	r9,r7[0xc]
80007542:	6e 28       	ld.w	r8,r7[0x8]
80007544:	93 28       	st.w	r9[0x8],r8
80007546:	91 39       	st.w	r8[0xc],r9
80007548:	e0 ca 00 04 	sub	r10,r0,4
8000754c:	ee cc ff f8 	sub	r12,r7,-8
80007550:	e0 4a 00 24 	cp.w	r10,36
80007554:	e0 8b 00 24 	brhi	8000759c <_realloc_r+0x1dc>
80007558:	59 3a       	cp.w	r10,19
8000755a:	e0 88 00 1a 	brls	8000758e <_realloc_r+0x1ce>
8000755e:	09 08       	ld.w	r8,r4++
80007560:	99 08       	st.w	r12[0x0],r8
80007562:	09 08       	ld.w	r8,r4++
80007564:	8f 38       	st.w	r7[0xc],r8
80007566:	ee cc ff f0 	sub	r12,r7,-16
8000756a:	59 ba       	cp.w	r10,27
8000756c:	e0 88 00 11 	brls	8000758e <_realloc_r+0x1ce>
80007570:	09 08       	ld.w	r8,r4++
80007572:	99 08       	st.w	r12[0x0],r8
80007574:	09 08       	ld.w	r8,r4++
80007576:	8f 58       	st.w	r7[0x14],r8
80007578:	ee cc ff e8 	sub	r12,r7,-24
8000757c:	e0 4a 00 24 	cp.w	r10,36
80007580:	c0 71       	brne	8000758e <_realloc_r+0x1ce>
80007582:	09 08       	ld.w	r8,r4++
80007584:	99 08       	st.w	r12[0x0],r8
80007586:	ee cc ff e0 	sub	r12,r7,-32
8000758a:	09 08       	ld.w	r8,r4++
8000758c:	8f 78       	st.w	r7[0x1c],r8
8000758e:	09 08       	ld.w	r8,r4++
80007590:	18 a8       	st.w	r12++,r8
80007592:	68 08       	ld.w	r8,r4[0x0]
80007594:	99 08       	st.w	r12[0x0],r8
80007596:	68 18       	ld.w	r8,r4[0x4]
80007598:	99 18       	st.w	r12[0x4],r8
8000759a:	c4 78       	rjmp	80007628 <_realloc_r+0x268>
8000759c:	08 9b       	mov	r11,r4
8000759e:	e0 a0 1d 42 	rcall	8000b022 <memmove>
800075a2:	c4 38       	rjmp	80007628 <_realloc_r+0x268>
800075a4:	04 9c       	mov	r12,r2
800075a6:	fe b0 fc 45 	rcall	80006e30 <_malloc_r>
800075aa:	18 95       	mov	r5,r12
800075ac:	c3 a0       	breq	80007620 <_realloc_r+0x260>
800075ae:	62 18       	ld.w	r8,r1[0x4]
800075b0:	f8 c9 00 08 	sub	r9,r12,8
800075b4:	a1 c8       	cbr	r8,0x0
800075b6:	e2 08 00 08 	add	r8,r1,r8
800075ba:	10 39       	cp.w	r9,r8
800075bc:	c0 71       	brne	800075ca <_realloc_r+0x20a>
800075be:	72 13       	ld.w	r3,r9[0x4]
800075c0:	02 97       	mov	r7,r1
800075c2:	e0 13 ff fc 	andl	r3,0xfffc
800075c6:	00 03       	add	r3,r0
800075c8:	c3 08       	rjmp	80007628 <_realloc_r+0x268>
800075ca:	e0 ca 00 04 	sub	r10,r0,4
800075ce:	e0 4a 00 24 	cp.w	r10,36
800075d2:	e0 8b 00 20 	brhi	80007612 <_realloc_r+0x252>
800075d6:	08 99       	mov	r9,r4
800075d8:	18 98       	mov	r8,r12
800075da:	59 3a       	cp.w	r10,19
800075dc:	e0 88 00 14 	brls	80007604 <_realloc_r+0x244>
800075e0:	13 0b       	ld.w	r11,r9++
800075e2:	10 ab       	st.w	r8++,r11
800075e4:	13 0b       	ld.w	r11,r9++
800075e6:	10 ab       	st.w	r8++,r11
800075e8:	59 ba       	cp.w	r10,27
800075ea:	e0 88 00 0d 	brls	80007604 <_realloc_r+0x244>
800075ee:	13 0b       	ld.w	r11,r9++
800075f0:	10 ab       	st.w	r8++,r11
800075f2:	13 0b       	ld.w	r11,r9++
800075f4:	10 ab       	st.w	r8++,r11
800075f6:	e0 4a 00 24 	cp.w	r10,36
800075fa:	c0 51       	brne	80007604 <_realloc_r+0x244>
800075fc:	13 0a       	ld.w	r10,r9++
800075fe:	10 aa       	st.w	r8++,r10
80007600:	13 0a       	ld.w	r10,r9++
80007602:	10 aa       	st.w	r8++,r10
80007604:	13 0a       	ld.w	r10,r9++
80007606:	10 aa       	st.w	r8++,r10
80007608:	72 0a       	ld.w	r10,r9[0x0]
8000760a:	91 0a       	st.w	r8[0x0],r10
8000760c:	72 19       	ld.w	r9,r9[0x4]
8000760e:	91 19       	st.w	r8[0x4],r9
80007610:	c0 48       	rjmp	80007618 <_realloc_r+0x258>
80007612:	08 9b       	mov	r11,r4
80007614:	e0 a0 1d 07 	rcall	8000b022 <memmove>
80007618:	08 9b       	mov	r11,r4
8000761a:	04 9c       	mov	r12,r2
8000761c:	e0 a0 1a 60 	rcall	8000aadc <_free_r>
80007620:	04 9c       	mov	r12,r2
80007622:	c2 a8       	rjmp	80007676 <_realloc_r+0x2b6>
80007624:	00 93       	mov	r3,r0
80007626:	02 97       	mov	r7,r1
80007628:	e6 06 01 09 	sub	r9,r3,r6
8000762c:	6e 18       	ld.w	r8,r7[0x4]
8000762e:	58 f9       	cp.w	r9,15
80007630:	e0 88 00 16 	brls	8000765c <_realloc_r+0x29c>
80007634:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007638:	ed e8 10 08 	or	r8,r6,r8
8000763c:	8f 18       	st.w	r7[0x4],r8
8000763e:	12 98       	mov	r8,r9
80007640:	a1 a8       	sbr	r8,0x0
80007642:	ee 06 00 0b 	add	r11,r7,r6
80007646:	f6 09 00 09 	add	r9,r11,r9
8000764a:	97 18       	st.w	r11[0x4],r8
8000764c:	72 18       	ld.w	r8,r9[0x4]
8000764e:	a1 a8       	sbr	r8,0x0
80007650:	2f 8b       	sub	r11,-8
80007652:	93 18       	st.w	r9[0x4],r8
80007654:	04 9c       	mov	r12,r2
80007656:	e0 a0 1a 43 	rcall	8000aadc <_free_r>
8000765a:	c0 b8       	rjmp	80007670 <_realloc_r+0x2b0>
8000765c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007660:	e7 e8 10 08 	or	r8,r3,r8
80007664:	8f 18       	st.w	r7[0x4],r8
80007666:	ee 03 00 03 	add	r3,r7,r3
8000766a:	66 18       	ld.w	r8,r3[0x4]
8000766c:	a1 a8       	sbr	r8,0x0
8000766e:	87 18       	st.w	r3[0x4],r8
80007670:	04 9c       	mov	r12,r2
80007672:	ee c5 ff f8 	sub	r5,r7,-8
80007676:	fe b0 f1 e1 	rcall	80005a38 <__malloc_unlock>
8000767a:	0a 9c       	mov	r12,r5
8000767c:	2f fd       	sub	sp,-4
8000767e:	d8 32       	popm	r0-r7,pc

80007680 <_sbrk_r>:
80007680:	d4 21       	pushm	r4-r7,lr
80007682:	30 08       	mov	r8,0
80007684:	18 97       	mov	r7,r12
80007686:	e0 66 41 18 	mov	r6,16664
8000768a:	16 9c       	mov	r12,r11
8000768c:	8d 08       	st.w	r6[0x0],r8
8000768e:	c8 5c       	rcall	80007798 <_sbrk>
80007690:	5b fc       	cp.w	r12,-1
80007692:	c0 51       	brne	8000769c <_sbrk_r+0x1c>
80007694:	6c 08       	ld.w	r8,r6[0x0]
80007696:	58 08       	cp.w	r8,0
80007698:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000769c:	d8 22       	popm	r4-r7,pc
8000769e:	d7 03       	nop

800076a0 <sprintf>:
800076a0:	d4 01       	pushm	lr
800076a2:	21 7d       	sub	sp,92
800076a4:	e0 68 ff ff 	mov	r8,65535
800076a8:	ea 18 7f ff 	orh	r8,0x7fff
800076ac:	50 58       	stdsp	sp[0x14],r8
800076ae:	50 28       	stdsp	sp[0x8],r8
800076b0:	e0 68 02 08 	mov	r8,520
800076b4:	ba 68       	st.h	sp[0xc],r8
800076b6:	3f f8       	mov	r8,-1
800076b8:	ba 78       	st.h	sp[0xe],r8
800076ba:	e0 68 0a 38 	mov	r8,2616
800076be:	50 4c       	stdsp	sp[0x10],r12
800076c0:	16 9a       	mov	r10,r11
800076c2:	50 0c       	stdsp	sp[0x0],r12
800076c4:	fa c9 ff a0 	sub	r9,sp,-96
800076c8:	70 0c       	ld.w	r12,r8[0x0]
800076ca:	1a 9b       	mov	r11,sp
800076cc:	e0 a0 02 1a 	rcall	80007b00 <_vfprintf_r>
800076d0:	30 09       	mov	r9,0
800076d2:	40 08       	lddsp	r8,sp[0x0]
800076d4:	b0 89       	st.b	r8[0x0],r9
800076d6:	2e 9d       	sub	sp,-92
800076d8:	d8 02       	popm	pc
800076da:	d7 03       	nop

800076dc <strncpy>:
800076dc:	30 08       	mov	r8,0
800076de:	10 3a       	cp.w	r10,r8
800076e0:	5e 0c       	reteq	r12
800076e2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800076e6:	f8 08 0b 09 	st.b	r12[r8],r9
800076ea:	2f f8       	sub	r8,-1
800076ec:	58 09       	cp.w	r9,0
800076ee:	cf 81       	brne	800076de <strncpy+0x2>
800076f0:	10 3a       	cp.w	r10,r8
800076f2:	5e 0c       	reteq	r12
800076f4:	f8 08 0b 09 	st.b	r12[r8],r9
800076f8:	2f f8       	sub	r8,-1
800076fa:	cf bb       	rjmp	800076f0 <strncpy+0x14>

800076fc <_close>:
800076fc:	30 28       	mov	r8,2
800076fe:	d6 73       	breakpoint
80007700:	3f fc       	mov	r12,-1
80007702:	35 8b       	mov	r11,88
80007704:	58 0c       	cp.w	r12,0
80007706:	5e 4c       	retge	r12
80007708:	e0 6a 41 18 	mov	r10,16664
8000770c:	95 0b       	st.w	r10[0x0],r11
8000770e:	5e fc       	retal	r12

80007710 <_lseek>:
80007710:	30 58       	mov	r8,5
80007712:	d6 73       	breakpoint
80007714:	3f fc       	mov	r12,-1
80007716:	35 8b       	mov	r11,88
80007718:	58 0c       	cp.w	r12,0
8000771a:	5e 4c       	retge	r12
8000771c:	e0 6a 41 18 	mov	r10,16664
80007720:	95 0b       	st.w	r10[0x0],r11
80007722:	5e fc       	retal	r12

80007724 <isatty>:
80007724:	30 b8       	mov	r8,11
80007726:	d6 73       	breakpoint
80007728:	3f fc       	mov	r12,-1
8000772a:	35 8b       	mov	r11,88
8000772c:	58 0c       	cp.w	r12,0
8000772e:	5e 4c       	retge	r12
80007730:	e0 6a 41 18 	mov	r10,16664
80007734:	95 0b       	st.w	r10[0x0],r11
80007736:	5e fc       	retal	r12

80007738 <_fstat_host>:
80007738:	30 98       	mov	r8,9
8000773a:	d6 73       	breakpoint
8000773c:	3f fc       	mov	r12,-1
8000773e:	35 8b       	mov	r11,88
80007740:	58 0c       	cp.w	r12,0
80007742:	5e 4c       	retge	r12
80007744:	e0 6a 41 18 	mov	r10,16664
80007748:	95 0b       	st.w	r10[0x0],r11
8000774a:	5e fc       	retal	r12

8000774c <_fstat>:
8000774c:	d4 21       	pushm	r4-r7,lr
8000774e:	21 0d       	sub	sp,64
80007750:	16 97       	mov	r7,r11
80007752:	1a 9b       	mov	r11,sp
80007754:	cf 2f       	rcall	80007738 <_fstat_host>
80007756:	c0 34       	brge	8000775c <_fstat+0x10>
80007758:	3f fc       	mov	r12,-1
8000775a:	c1 c8       	rjmp	80007792 <_fstat+0x46>
8000775c:	40 08       	lddsp	r8,sp[0x0]
8000775e:	ae 08       	st.h	r7[0x0],r8
80007760:	40 18       	lddsp	r8,sp[0x4]
80007762:	ae 18       	st.h	r7[0x2],r8
80007764:	40 28       	lddsp	r8,sp[0x8]
80007766:	8f 18       	st.w	r7[0x4],r8
80007768:	40 38       	lddsp	r8,sp[0xc]
8000776a:	ae 48       	st.h	r7[0x8],r8
8000776c:	40 48       	lddsp	r8,sp[0x10]
8000776e:	ae 58       	st.h	r7[0xa],r8
80007770:	40 58       	lddsp	r8,sp[0x14]
80007772:	ae 68       	st.h	r7[0xc],r8
80007774:	40 68       	lddsp	r8,sp[0x18]
80007776:	ae 78       	st.h	r7[0xe],r8
80007778:	40 88       	lddsp	r8,sp[0x20]
8000777a:	8f 48       	st.w	r7[0x10],r8
8000777c:	40 a8       	lddsp	r8,sp[0x28]
8000777e:	8f b8       	st.w	r7[0x2c],r8
80007780:	40 c8       	lddsp	r8,sp[0x30]
80007782:	8f c8       	st.w	r7[0x30],r8
80007784:	40 d8       	lddsp	r8,sp[0x34]
80007786:	8f 58       	st.w	r7[0x14],r8
80007788:	40 e8       	lddsp	r8,sp[0x38]
8000778a:	30 0c       	mov	r12,0
8000778c:	8f 78       	st.w	r7[0x1c],r8
8000778e:	40 f8       	lddsp	r8,sp[0x3c]
80007790:	8f 98       	st.w	r7[0x24],r8
80007792:	2f 0d       	sub	sp,-64
80007794:	d8 22       	popm	r4-r7,pc
80007796:	d7 03       	nop

80007798 <_sbrk>:
80007798:	d4 01       	pushm	lr
8000779a:	e0 68 0d 74 	mov	r8,3444
8000779e:	70 09       	ld.w	r9,r8[0x0]
800077a0:	58 09       	cp.w	r9,0
800077a2:	c0 41       	brne	800077aa <_sbrk+0x12>
800077a4:	e0 69 41 20 	mov	r9,16672
800077a8:	91 09       	st.w	r8[0x0],r9
800077aa:	e0 69 0d 74 	mov	r9,3444
800077ae:	e0 7a 70 00 	mov	r10,94208
800077b2:	72 08       	ld.w	r8,r9[0x0]
800077b4:	f0 0c 00 0c 	add	r12,r8,r12
800077b8:	14 3c       	cp.w	r12,r10
800077ba:	e0 8b 00 04 	brhi	800077c2 <_sbrk+0x2a>
800077be:	93 0c       	st.w	r9[0x0],r12
800077c0:	c0 68       	rjmp	800077cc <_sbrk+0x34>
800077c2:	e0 a0 18 15 	rcall	8000a7ec <__errno>
800077c6:	30 c8       	mov	r8,12
800077c8:	99 08       	st.w	r12[0x0],r8
800077ca:	3f f8       	mov	r8,-1
800077cc:	10 9c       	mov	r12,r8
800077ce:	d8 02       	popm	pc

800077d0 <get_arg>:
800077d0:	d4 31       	pushm	r0-r7,lr
800077d2:	20 8d       	sub	sp,32
800077d4:	fa c4 ff bc 	sub	r4,sp,-68
800077d8:	50 4b       	stdsp	sp[0x10],r11
800077da:	68 2e       	ld.w	lr,r4[0x8]
800077dc:	50 58       	stdsp	sp[0x14],r8
800077de:	12 96       	mov	r6,r9
800077e0:	7c 0b       	ld.w	r11,lr[0x0]
800077e2:	70 05       	ld.w	r5,r8[0x0]
800077e4:	50 6e       	stdsp	sp[0x18],lr
800077e6:	58 0b       	cp.w	r11,0
800077e8:	f4 0b 17 00 	moveq	r11,r10
800077ec:	68 03       	ld.w	r3,r4[0x0]
800077ee:	68 11       	ld.w	r1,r4[0x4]
800077f0:	40 49       	lddsp	r9,sp[0x10]
800077f2:	30 08       	mov	r8,0
800077f4:	c2 89       	rjmp	80007a44 <get_arg+0x274>
800077f6:	2f fb       	sub	r11,-1
800077f8:	32 5c       	mov	r12,37
800077fa:	17 8a       	ld.ub	r10,r11[0x0]
800077fc:	f8 0a 18 00 	cp.b	r10,r12
80007800:	5f 1e       	srne	lr
80007802:	f0 0a 18 00 	cp.b	r10,r8
80007806:	5f 1c       	srne	r12
80007808:	fd ec 00 0c 	and	r12,lr,r12
8000780c:	f0 0c 18 00 	cp.b	r12,r8
80007810:	cf 31       	brne	800077f6 <get_arg+0x26>
80007812:	58 0a       	cp.w	r10,0
80007814:	e0 80 01 25 	breq	80007a5e <get_arg+0x28e>
80007818:	30 0c       	mov	r12,0
8000781a:	3f fa       	mov	r10,-1
8000781c:	18 90       	mov	r0,r12
8000781e:	50 3a       	stdsp	sp[0xc],r10
80007820:	18 94       	mov	r4,r12
80007822:	18 92       	mov	r2,r12
80007824:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007828:	16 97       	mov	r7,r11
8000782a:	50 7c       	stdsp	sp[0x1c],r12
8000782c:	fe cc 9f 80 	sub	r12,pc,-24704
80007830:	0f 3a       	ld.ub	r10,r7++
80007832:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007836:	40 7c       	lddsp	r12,sp[0x1c]
80007838:	1c 0c       	add	r12,lr
8000783a:	fe ce a0 56 	sub	lr,pc,-24490
8000783e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007842:	20 1e       	sub	lr,1
80007844:	50 0e       	stdsp	sp[0x0],lr
80007846:	fe ce a0 ce 	sub	lr,pc,-24370
8000784a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000784e:	50 7c       	stdsp	sp[0x1c],r12
80007850:	40 0c       	lddsp	r12,sp[0x0]
80007852:	58 7c       	cp.w	r12,7
80007854:	e0 8b 00 f1 	brhi	80007a36 <get_arg+0x266>
80007858:	fe ce a2 80 	sub	lr,pc,-23936
8000785c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007860:	36 8b       	mov	r11,104
80007862:	f6 0a 18 00 	cp.b	r10,r11
80007866:	e0 80 00 e8 	breq	80007a36 <get_arg+0x266>
8000786a:	37 1b       	mov	r11,113
8000786c:	f6 0a 18 00 	cp.b	r10,r11
80007870:	c0 70       	breq	8000787e <get_arg+0xae>
80007872:	34 cb       	mov	r11,76
80007874:	f6 0a 18 00 	cp.b	r10,r11
80007878:	c0 51       	brne	80007882 <get_arg+0xb2>
8000787a:	a3 b4       	sbr	r4,0x3
8000787c:	cd d8       	rjmp	80007a36 <get_arg+0x266>
8000787e:	a5 b4       	sbr	r4,0x5
80007880:	cd b8       	rjmp	80007a36 <get_arg+0x266>
80007882:	08 9a       	mov	r10,r4
80007884:	0e 9b       	mov	r11,r7
80007886:	a5 aa       	sbr	r10,0x4
80007888:	17 3c       	ld.ub	r12,r11++
8000788a:	a5 b4       	sbr	r4,0x5
8000788c:	36 ce       	mov	lr,108
8000788e:	fc 0c 18 00 	cp.b	r12,lr
80007892:	e0 80 00 d3 	breq	80007a38 <get_arg+0x268>
80007896:	14 94       	mov	r4,r10
80007898:	cc f8       	rjmp	80007a36 <get_arg+0x266>
8000789a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000789e:	36 7c       	mov	r12,103
800078a0:	f8 0a 18 00 	cp.b	r10,r12
800078a4:	e0 8b 00 27 	brhi	800078f2 <get_arg+0x122>
800078a8:	36 5b       	mov	r11,101
800078aa:	f6 0a 18 00 	cp.b	r10,r11
800078ae:	c4 82       	brcc	8000793e <get_arg+0x16e>
800078b0:	34 fb       	mov	r11,79
800078b2:	f6 0a 18 00 	cp.b	r10,r11
800078b6:	c4 80       	breq	80007946 <get_arg+0x176>
800078b8:	e0 8b 00 0c 	brhi	800078d0 <get_arg+0x100>
800078bc:	34 5b       	mov	r11,69
800078be:	f6 0a 18 00 	cp.b	r10,r11
800078c2:	c3 e0       	breq	8000793e <get_arg+0x16e>
800078c4:	34 7b       	mov	r11,71
800078c6:	f6 0a 18 00 	cp.b	r10,r11
800078ca:	c3 a0       	breq	8000793e <get_arg+0x16e>
800078cc:	34 4b       	mov	r11,68
800078ce:	c0 88       	rjmp	800078de <get_arg+0x10e>
800078d0:	35 8b       	mov	r11,88
800078d2:	f6 0a 18 00 	cp.b	r10,r11
800078d6:	c2 c0       	breq	8000792e <get_arg+0x15e>
800078d8:	e0 8b 00 07 	brhi	800078e6 <get_arg+0x116>
800078dc:	35 5b       	mov	r11,85
800078de:	f6 0a 18 00 	cp.b	r10,r11
800078e2:	c3 51       	brne	8000794c <get_arg+0x17c>
800078e4:	c3 18       	rjmp	80007946 <get_arg+0x176>
800078e6:	36 3b       	mov	r11,99
800078e8:	f6 0a 18 00 	cp.b	r10,r11
800078ec:	c2 f0       	breq	8000794a <get_arg+0x17a>
800078ee:	36 4b       	mov	r11,100
800078f0:	c0 e8       	rjmp	8000790c <get_arg+0x13c>
800078f2:	37 0b       	mov	r11,112
800078f4:	f6 0a 18 00 	cp.b	r10,r11
800078f8:	c2 50       	breq	80007942 <get_arg+0x172>
800078fa:	e0 8b 00 0d 	brhi	80007914 <get_arg+0x144>
800078fe:	36 eb       	mov	r11,110
80007900:	f6 0a 18 00 	cp.b	r10,r11
80007904:	c1 f0       	breq	80007942 <get_arg+0x172>
80007906:	e0 8b 00 14 	brhi	8000792e <get_arg+0x15e>
8000790a:	36 9b       	mov	r11,105
8000790c:	f6 0a 18 00 	cp.b	r10,r11
80007910:	c1 e1       	brne	8000794c <get_arg+0x17c>
80007912:	c0 e8       	rjmp	8000792e <get_arg+0x15e>
80007914:	37 5b       	mov	r11,117
80007916:	f6 0a 18 00 	cp.b	r10,r11
8000791a:	c0 a0       	breq	8000792e <get_arg+0x15e>
8000791c:	37 8b       	mov	r11,120
8000791e:	f6 0a 18 00 	cp.b	r10,r11
80007922:	c0 60       	breq	8000792e <get_arg+0x15e>
80007924:	37 3b       	mov	r11,115
80007926:	f6 0a 18 00 	cp.b	r10,r11
8000792a:	c1 11       	brne	8000794c <get_arg+0x17c>
8000792c:	c0 b8       	rjmp	80007942 <get_arg+0x172>
8000792e:	ed b4 00 04 	bld	r4,0x4
80007932:	c0 a0       	breq	80007946 <get_arg+0x176>
80007934:	ed b4 00 05 	bld	r4,0x5
80007938:	c0 91       	brne	8000794a <get_arg+0x17a>
8000793a:	30 20       	mov	r0,2
8000793c:	c0 88       	rjmp	8000794c <get_arg+0x17c>
8000793e:	30 40       	mov	r0,4
80007940:	c0 68       	rjmp	8000794c <get_arg+0x17c>
80007942:	30 30       	mov	r0,3
80007944:	c0 48       	rjmp	8000794c <get_arg+0x17c>
80007946:	30 10       	mov	r0,1
80007948:	c0 28       	rjmp	8000794c <get_arg+0x17c>
8000794a:	30 00       	mov	r0,0
8000794c:	40 3b       	lddsp	r11,sp[0xc]
8000794e:	5b fb       	cp.w	r11,-1
80007950:	c0 40       	breq	80007958 <get_arg+0x188>
80007952:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007956:	c7 08       	rjmp	80007a36 <get_arg+0x266>
80007958:	58 60       	cp.w	r0,6
8000795a:	e0 8b 00 6e 	brhi	80007a36 <get_arg+0x266>
8000795e:	6c 0a       	ld.w	r10,r6[0x0]
80007960:	ea cc ff ff 	sub	r12,r5,-1
80007964:	fe ce a3 6c 	sub	lr,pc,-23700
80007968:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000796c:	f4 cb ff f8 	sub	r11,r10,-8
80007970:	8d 0b       	st.w	r6[0x0],r11
80007972:	f4 ea 00 00 	ld.d	r10,r10[0]
80007976:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000797a:	c0 f8       	rjmp	80007998 <get_arg+0x1c8>
8000797c:	f4 cb ff fc 	sub	r11,r10,-4
80007980:	8d 0b       	st.w	r6[0x0],r11
80007982:	74 0a       	ld.w	r10,r10[0x0]
80007984:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007988:	c0 88       	rjmp	80007998 <get_arg+0x1c8>
8000798a:	f4 cb ff f8 	sub	r11,r10,-8
8000798e:	8d 0b       	st.w	r6[0x0],r11
80007990:	f4 ea 00 00 	ld.d	r10,r10[0]
80007994:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007998:	0e 9b       	mov	r11,r7
8000799a:	18 95       	mov	r5,r12
8000799c:	c4 e8       	rjmp	80007a38 <get_arg+0x268>
8000799e:	62 0a       	ld.w	r10,r1[0x0]
800079a0:	5b fa       	cp.w	r10,-1
800079a2:	c0 b1       	brne	800079b8 <get_arg+0x1e8>
800079a4:	50 19       	stdsp	sp[0x4],r9
800079a6:	50 28       	stdsp	sp[0x8],r8
800079a8:	e0 6a 00 80 	mov	r10,128
800079ac:	30 0b       	mov	r11,0
800079ae:	02 9c       	mov	r12,r1
800079b0:	fe b0 fd 00 	rcall	800073b0 <memset>
800079b4:	40 28       	lddsp	r8,sp[0x8]
800079b6:	40 19       	lddsp	r9,sp[0x4]
800079b8:	e4 cc 00 01 	sub	r12,r2,1
800079bc:	0e 9b       	mov	r11,r7
800079be:	50 3c       	stdsp	sp[0xc],r12
800079c0:	f2 0c 0c 49 	max	r9,r9,r12
800079c4:	c3 a8       	rjmp	80007a38 <get_arg+0x268>
800079c6:	62 0a       	ld.w	r10,r1[0x0]
800079c8:	5b fa       	cp.w	r10,-1
800079ca:	c0 b1       	brne	800079e0 <get_arg+0x210>
800079cc:	50 19       	stdsp	sp[0x4],r9
800079ce:	50 28       	stdsp	sp[0x8],r8
800079d0:	e0 6a 00 80 	mov	r10,128
800079d4:	30 0b       	mov	r11,0
800079d6:	02 9c       	mov	r12,r1
800079d8:	fe b0 fc ec 	rcall	800073b0 <memset>
800079dc:	40 28       	lddsp	r8,sp[0x8]
800079de:	40 19       	lddsp	r9,sp[0x4]
800079e0:	20 12       	sub	r2,1
800079e2:	30 0a       	mov	r10,0
800079e4:	0e 9b       	mov	r11,r7
800079e6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800079ea:	f2 02 0c 49 	max	r9,r9,r2
800079ee:	c2 58       	rjmp	80007a38 <get_arg+0x268>
800079f0:	16 97       	mov	r7,r11
800079f2:	6c 0a       	ld.w	r10,r6[0x0]
800079f4:	f4 cb ff fc 	sub	r11,r10,-4
800079f8:	8d 0b       	st.w	r6[0x0],r11
800079fa:	74 0a       	ld.w	r10,r10[0x0]
800079fc:	0e 9b       	mov	r11,r7
800079fe:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a02:	2f f5       	sub	r5,-1
80007a04:	c1 a8       	rjmp	80007a38 <get_arg+0x268>
80007a06:	f4 c2 00 30 	sub	r2,r10,48
80007a0a:	c0 68       	rjmp	80007a16 <get_arg+0x246>
80007a0c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007a10:	2f f7       	sub	r7,-1
80007a12:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007a16:	0f 8a       	ld.ub	r10,r7[0x0]
80007a18:	58 0a       	cp.w	r10,0
80007a1a:	c0 e0       	breq	80007a36 <get_arg+0x266>
80007a1c:	23 0a       	sub	r10,48
80007a1e:	58 9a       	cp.w	r10,9
80007a20:	fe 98 ff f6 	brls	80007a0c <get_arg+0x23c>
80007a24:	c0 98       	rjmp	80007a36 <get_arg+0x266>
80007a26:	2f f7       	sub	r7,-1
80007a28:	0f 8a       	ld.ub	r10,r7[0x0]
80007a2a:	58 0a       	cp.w	r10,0
80007a2c:	c0 50       	breq	80007a36 <get_arg+0x266>
80007a2e:	23 0a       	sub	r10,48
80007a30:	58 9a       	cp.w	r10,9
80007a32:	fe 98 ff fa 	brls	80007a26 <get_arg+0x256>
80007a36:	0e 9b       	mov	r11,r7
80007a38:	40 7c       	lddsp	r12,sp[0x1c]
80007a3a:	30 ba       	mov	r10,11
80007a3c:	f4 0c 18 00 	cp.b	r12,r10
80007a40:	fe 91 fe f2 	brne	80007824 <get_arg+0x54>
80007a44:	40 42       	lddsp	r2,sp[0x10]
80007a46:	17 8c       	ld.ub	r12,r11[0x0]
80007a48:	0a 32       	cp.w	r2,r5
80007a4a:	5f 4a       	srge	r10
80007a4c:	f0 0c 18 00 	cp.b	r12,r8
80007a50:	5f 1c       	srne	r12
80007a52:	f9 ea 00 0a 	and	r10,r12,r10
80007a56:	f0 0a 18 00 	cp.b	r10,r8
80007a5a:	fe 91 fe cf 	brne	800077f8 <get_arg+0x28>
80007a5e:	30 08       	mov	r8,0
80007a60:	40 4e       	lddsp	lr,sp[0x10]
80007a62:	17 8a       	ld.ub	r10,r11[0x0]
80007a64:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007a68:	f0 0a 18 00 	cp.b	r10,r8
80007a6c:	fc 09 17 10 	movne	r9,lr
80007a70:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007a74:	06 9e       	mov	lr,r3
80007a76:	c2 a8       	rjmp	80007aca <get_arg+0x2fa>
80007a78:	62 0a       	ld.w	r10,r1[0x0]
80007a7a:	58 3a       	cp.w	r10,3
80007a7c:	c1 e0       	breq	80007ab8 <get_arg+0x2e8>
80007a7e:	e0 89 00 07 	brgt	80007a8c <get_arg+0x2bc>
80007a82:	58 1a       	cp.w	r10,1
80007a84:	c1 a0       	breq	80007ab8 <get_arg+0x2e8>
80007a86:	58 2a       	cp.w	r10,2
80007a88:	c1 81       	brne	80007ab8 <get_arg+0x2e8>
80007a8a:	c0 58       	rjmp	80007a94 <get_arg+0x2c4>
80007a8c:	58 5a       	cp.w	r10,5
80007a8e:	c0 c0       	breq	80007aa6 <get_arg+0x2d6>
80007a90:	c0 b5       	brlt	80007aa6 <get_arg+0x2d6>
80007a92:	c1 38       	rjmp	80007ab8 <get_arg+0x2e8>
80007a94:	6c 0a       	ld.w	r10,r6[0x0]
80007a96:	f4 cc ff f8 	sub	r12,r10,-8
80007a9a:	8d 0c       	st.w	r6[0x0],r12
80007a9c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007aa0:	f0 e3 00 00 	st.d	r8[0],r2
80007aa4:	c1 08       	rjmp	80007ac4 <get_arg+0x2f4>
80007aa6:	6c 0a       	ld.w	r10,r6[0x0]
80007aa8:	f4 cc ff f8 	sub	r12,r10,-8
80007aac:	8d 0c       	st.w	r6[0x0],r12
80007aae:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ab2:	f0 e3 00 00 	st.d	r8[0],r2
80007ab6:	c0 78       	rjmp	80007ac4 <get_arg+0x2f4>
80007ab8:	6c 0a       	ld.w	r10,r6[0x0]
80007aba:	f4 cc ff fc 	sub	r12,r10,-4
80007abe:	8d 0c       	st.w	r6[0x0],r12
80007ac0:	74 0a       	ld.w	r10,r10[0x0]
80007ac2:	91 0a       	st.w	r8[0x0],r10
80007ac4:	2f f5       	sub	r5,-1
80007ac6:	2f 88       	sub	r8,-8
80007ac8:	2f c1       	sub	r1,-4
80007aca:	12 35       	cp.w	r5,r9
80007acc:	fe 9a ff d6 	brle	80007a78 <get_arg+0x2a8>
80007ad0:	1c 93       	mov	r3,lr
80007ad2:	40 52       	lddsp	r2,sp[0x14]
80007ad4:	40 6e       	lddsp	lr,sp[0x18]
80007ad6:	85 05       	st.w	r2[0x0],r5
80007ad8:	9d 0b       	st.w	lr[0x0],r11
80007ada:	40 4b       	lddsp	r11,sp[0x10]
80007adc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007ae0:	2f 8d       	sub	sp,-32
80007ae2:	d8 32       	popm	r0-r7,pc

80007ae4 <__sprint_r>:
80007ae4:	d4 21       	pushm	r4-r7,lr
80007ae6:	14 97       	mov	r7,r10
80007ae8:	74 28       	ld.w	r8,r10[0x8]
80007aea:	58 08       	cp.w	r8,0
80007aec:	c0 41       	brne	80007af4 <__sprint_r+0x10>
80007aee:	95 18       	st.w	r10[0x4],r8
80007af0:	10 9c       	mov	r12,r8
80007af2:	d8 22       	popm	r4-r7,pc
80007af4:	e0 a0 18 ba 	rcall	8000ac68 <__sfvwrite_r>
80007af8:	30 08       	mov	r8,0
80007afa:	8f 18       	st.w	r7[0x4],r8
80007afc:	8f 28       	st.w	r7[0x8],r8
80007afe:	d8 22       	popm	r4-r7,pc

80007b00 <_vfprintf_r>:
80007b00:	d4 31       	pushm	r0-r7,lr
80007b02:	fa cd 06 bc 	sub	sp,sp,1724
80007b06:	51 09       	stdsp	sp[0x40],r9
80007b08:	16 91       	mov	r1,r11
80007b0a:	14 97       	mov	r7,r10
80007b0c:	18 95       	mov	r5,r12
80007b0e:	e0 a0 1a 1d 	rcall	8000af48 <_localeconv_r>
80007b12:	78 0c       	ld.w	r12,r12[0x0]
80007b14:	50 cc       	stdsp	sp[0x30],r12
80007b16:	58 05       	cp.w	r5,0
80007b18:	c0 70       	breq	80007b26 <_vfprintf_r+0x26>
80007b1a:	6a 68       	ld.w	r8,r5[0x18]
80007b1c:	58 08       	cp.w	r8,0
80007b1e:	c0 41       	brne	80007b26 <_vfprintf_r+0x26>
80007b20:	0a 9c       	mov	r12,r5
80007b22:	e0 a0 17 43 	rcall	8000a9a8 <__sinit>
80007b26:	fe c8 a1 6a 	sub	r8,pc,-24214
80007b2a:	10 31       	cp.w	r1,r8
80007b2c:	c0 31       	brne	80007b32 <_vfprintf_r+0x32>
80007b2e:	6a 01       	ld.w	r1,r5[0x0]
80007b30:	c0 c8       	rjmp	80007b48 <_vfprintf_r+0x48>
80007b32:	fe c8 a1 56 	sub	r8,pc,-24234
80007b36:	10 31       	cp.w	r1,r8
80007b38:	c0 31       	brne	80007b3e <_vfprintf_r+0x3e>
80007b3a:	6a 11       	ld.w	r1,r5[0x4]
80007b3c:	c0 68       	rjmp	80007b48 <_vfprintf_r+0x48>
80007b3e:	fe c8 a1 42 	sub	r8,pc,-24254
80007b42:	10 31       	cp.w	r1,r8
80007b44:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007b48:	82 68       	ld.sh	r8,r1[0xc]
80007b4a:	ed b8 00 03 	bld	r8,0x3
80007b4e:	c0 41       	brne	80007b56 <_vfprintf_r+0x56>
80007b50:	62 48       	ld.w	r8,r1[0x10]
80007b52:	58 08       	cp.w	r8,0
80007b54:	c0 71       	brne	80007b62 <_vfprintf_r+0x62>
80007b56:	02 9b       	mov	r11,r1
80007b58:	0a 9c       	mov	r12,r5
80007b5a:	e0 a0 0f 5d 	rcall	80009a14 <__swsetup_r>
80007b5e:	e0 81 0f 54 	brne	80009a06 <_vfprintf_r+0x1f06>
80007b62:	82 68       	ld.sh	r8,r1[0xc]
80007b64:	10 99       	mov	r9,r8
80007b66:	e2 19 00 1a 	andl	r9,0x1a,COH
80007b6a:	58 a9       	cp.w	r9,10
80007b6c:	c3 c1       	brne	80007be4 <_vfprintf_r+0xe4>
80007b6e:	82 79       	ld.sh	r9,r1[0xe]
80007b70:	30 0a       	mov	r10,0
80007b72:	f4 09 19 00 	cp.h	r9,r10
80007b76:	c3 75       	brlt	80007be4 <_vfprintf_r+0xe4>
80007b78:	a1 d8       	cbr	r8,0x1
80007b7a:	fb 58 05 d0 	st.h	sp[1488],r8
80007b7e:	62 88       	ld.w	r8,r1[0x20]
80007b80:	fb 48 05 e4 	st.w	sp[1508],r8
80007b84:	62 a8       	ld.w	r8,r1[0x28]
80007b86:	fb 48 05 ec 	st.w	sp[1516],r8
80007b8a:	fa c8 ff bc 	sub	r8,sp,-68
80007b8e:	fb 48 05 d4 	st.w	sp[1492],r8
80007b92:	fb 48 05 c4 	st.w	sp[1476],r8
80007b96:	e0 68 04 00 	mov	r8,1024
80007b9a:	fb 48 05 d8 	st.w	sp[1496],r8
80007b9e:	fb 48 05 cc 	st.w	sp[1484],r8
80007ba2:	30 08       	mov	r8,0
80007ba4:	fb 59 05 d2 	st.h	sp[1490],r9
80007ba8:	0e 9a       	mov	r10,r7
80007baa:	41 09       	lddsp	r9,sp[0x40]
80007bac:	fa c7 fa 3c 	sub	r7,sp,-1476
80007bb0:	fb 48 05 dc 	st.w	sp[1500],r8
80007bb4:	0a 9c       	mov	r12,r5
80007bb6:	0e 9b       	mov	r11,r7
80007bb8:	ca 4f       	rcall	80007b00 <_vfprintf_r>
80007bba:	50 bc       	stdsp	sp[0x2c],r12
80007bbc:	c0 95       	brlt	80007bce <_vfprintf_r+0xce>
80007bbe:	0e 9b       	mov	r11,r7
80007bc0:	0a 9c       	mov	r12,r5
80007bc2:	e0 a0 16 1b 	rcall	8000a7f8 <_fflush_r>
80007bc6:	40 be       	lddsp	lr,sp[0x2c]
80007bc8:	f9 be 01 ff 	movne	lr,-1
80007bcc:	50 be       	stdsp	sp[0x2c],lr
80007bce:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007bd2:	ed b8 00 06 	bld	r8,0x6
80007bd6:	e0 81 0f 1a 	brne	80009a0a <_vfprintf_r+0x1f0a>
80007bda:	82 68       	ld.sh	r8,r1[0xc]
80007bdc:	a7 a8       	sbr	r8,0x6
80007bde:	a2 68       	st.h	r1[0xc],r8
80007be0:	e0 8f 0f 15 	bral	80009a0a <_vfprintf_r+0x1f0a>
80007be4:	30 08       	mov	r8,0
80007be6:	fb 48 06 b4 	st.w	sp[1716],r8
80007bea:	fb 48 06 90 	st.w	sp[1680],r8
80007bee:	fb 48 06 8c 	st.w	sp[1676],r8
80007bf2:	fb 48 06 b0 	st.w	sp[1712],r8
80007bf6:	30 08       	mov	r8,0
80007bf8:	30 09       	mov	r9,0
80007bfa:	50 a7       	stdsp	sp[0x28],r7
80007bfc:	50 78       	stdsp	sp[0x1c],r8
80007bfe:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c02:	3f f8       	mov	r8,-1
80007c04:	50 59       	stdsp	sp[0x14],r9
80007c06:	fb 43 06 88 	st.w	sp[1672],r3
80007c0a:	fb 48 05 44 	st.w	sp[1348],r8
80007c0e:	12 9c       	mov	r12,r9
80007c10:	50 69       	stdsp	sp[0x18],r9
80007c12:	50 d9       	stdsp	sp[0x34],r9
80007c14:	50 e9       	stdsp	sp[0x38],r9
80007c16:	50 b9       	stdsp	sp[0x2c],r9
80007c18:	12 97       	mov	r7,r9
80007c1a:	0a 94       	mov	r4,r5
80007c1c:	40 a2       	lddsp	r2,sp[0x28]
80007c1e:	32 5a       	mov	r10,37
80007c20:	30 08       	mov	r8,0
80007c22:	c0 28       	rjmp	80007c26 <_vfprintf_r+0x126>
80007c24:	2f f2       	sub	r2,-1
80007c26:	05 89       	ld.ub	r9,r2[0x0]
80007c28:	f0 09 18 00 	cp.b	r9,r8
80007c2c:	5f 1b       	srne	r11
80007c2e:	f4 09 18 00 	cp.b	r9,r10
80007c32:	5f 19       	srne	r9
80007c34:	f3 eb 00 0b 	and	r11,r9,r11
80007c38:	f0 0b 18 00 	cp.b	r11,r8
80007c3c:	cf 41       	brne	80007c24 <_vfprintf_r+0x124>
80007c3e:	40 ab       	lddsp	r11,sp[0x28]
80007c40:	e4 0b 01 06 	sub	r6,r2,r11
80007c44:	c1 e0       	breq	80007c80 <_vfprintf_r+0x180>
80007c46:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c4a:	0c 08       	add	r8,r6
80007c4c:	87 0b       	st.w	r3[0x0],r11
80007c4e:	fb 48 06 90 	st.w	sp[1680],r8
80007c52:	87 16       	st.w	r3[0x4],r6
80007c54:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c58:	2f f8       	sub	r8,-1
80007c5a:	fb 48 06 8c 	st.w	sp[1676],r8
80007c5e:	58 78       	cp.w	r8,7
80007c60:	e0 89 00 04 	brgt	80007c68 <_vfprintf_r+0x168>
80007c64:	2f 83       	sub	r3,-8
80007c66:	c0 a8       	rjmp	80007c7a <_vfprintf_r+0x17a>
80007c68:	fa ca f9 78 	sub	r10,sp,-1672
80007c6c:	02 9b       	mov	r11,r1
80007c6e:	08 9c       	mov	r12,r4
80007c70:	c3 af       	rcall	80007ae4 <__sprint_r>
80007c72:	e0 81 0e c6 	brne	800099fe <_vfprintf_r+0x1efe>
80007c76:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c7a:	40 ba       	lddsp	r10,sp[0x2c]
80007c7c:	0c 0a       	add	r10,r6
80007c7e:	50 ba       	stdsp	sp[0x2c],r10
80007c80:	05 89       	ld.ub	r9,r2[0x0]
80007c82:	30 08       	mov	r8,0
80007c84:	f0 09 18 00 	cp.b	r9,r8
80007c88:	e0 80 0e aa 	breq	800099dc <_vfprintf_r+0x1edc>
80007c8c:	30 09       	mov	r9,0
80007c8e:	fb 68 06 bb 	st.b	sp[1723],r8
80007c92:	0e 96       	mov	r6,r7
80007c94:	e4 c8 ff ff 	sub	r8,r2,-1
80007c98:	3f fe       	mov	lr,-1
80007c9a:	50 93       	stdsp	sp[0x24],r3
80007c9c:	50 41       	stdsp	sp[0x10],r1
80007c9e:	0e 93       	mov	r3,r7
80007ca0:	04 91       	mov	r1,r2
80007ca2:	50 89       	stdsp	sp[0x20],r9
80007ca4:	50 a8       	stdsp	sp[0x28],r8
80007ca6:	50 2e       	stdsp	sp[0x8],lr
80007ca8:	50 39       	stdsp	sp[0xc],r9
80007caa:	12 95       	mov	r5,r9
80007cac:	12 90       	mov	r0,r9
80007cae:	10 97       	mov	r7,r8
80007cb0:	08 92       	mov	r2,r4
80007cb2:	c0 78       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007cb4:	3f fc       	mov	r12,-1
80007cb6:	08 97       	mov	r7,r4
80007cb8:	50 2c       	stdsp	sp[0x8],r12
80007cba:	c0 38       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007cbc:	30 0b       	mov	r11,0
80007cbe:	50 3b       	stdsp	sp[0xc],r11
80007cc0:	0f 38       	ld.ub	r8,r7++
80007cc2:	c0 28       	rjmp	80007cc6 <_vfprintf_r+0x1c6>
80007cc4:	12 90       	mov	r0,r9
80007cc6:	f0 c9 00 20 	sub	r9,r8,32
80007cca:	e0 49 00 58 	cp.w	r9,88
80007cce:	e0 8b 0a 30 	brhi	8000912e <_vfprintf_r+0x162e>
80007cd2:	fe ca a6 be 	sub	r10,pc,-22850
80007cd6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007cda:	50 a7       	stdsp	sp[0x28],r7
80007cdc:	50 80       	stdsp	sp[0x20],r0
80007cde:	0c 97       	mov	r7,r6
80007ce0:	04 94       	mov	r4,r2
80007ce2:	06 96       	mov	r6,r3
80007ce4:	02 92       	mov	r2,r1
80007ce6:	fe c9 a4 96 	sub	r9,pc,-23402
80007cea:	40 93       	lddsp	r3,sp[0x24]
80007cec:	10 90       	mov	r0,r8
80007cee:	40 41       	lddsp	r1,sp[0x10]
80007cf0:	50 d9       	stdsp	sp[0x34],r9
80007cf2:	e0 8f 08 8e 	bral	80008e0e <_vfprintf_r+0x130e>
80007cf6:	30 08       	mov	r8,0
80007cf8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007cfc:	f0 09 18 00 	cp.b	r9,r8
80007d00:	ce 01       	brne	80007cc0 <_vfprintf_r+0x1c0>
80007d02:	32 08       	mov	r8,32
80007d04:	c6 e8       	rjmp	80007de0 <_vfprintf_r+0x2e0>
80007d06:	a1 a5       	sbr	r5,0x0
80007d08:	cd cb       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007d0a:	0f 89       	ld.ub	r9,r7[0x0]
80007d0c:	f2 c8 00 30 	sub	r8,r9,48
80007d10:	58 98       	cp.w	r8,9
80007d12:	e0 8b 00 1d 	brhi	80007d4c <_vfprintf_r+0x24c>
80007d16:	ee c8 ff ff 	sub	r8,r7,-1
80007d1a:	30 0b       	mov	r11,0
80007d1c:	23 09       	sub	r9,48
80007d1e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d22:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007d26:	11 39       	ld.ub	r9,r8++
80007d28:	f2 ca 00 30 	sub	r10,r9,48
80007d2c:	58 9a       	cp.w	r10,9
80007d2e:	fe 98 ff f7 	brls	80007d1c <_vfprintf_r+0x21c>
80007d32:	e0 49 00 24 	cp.w	r9,36
80007d36:	cc 31       	brne	80007cbc <_vfprintf_r+0x1bc>
80007d38:	e0 4b 00 20 	cp.w	r11,32
80007d3c:	e0 89 0e 60 	brgt	800099fc <_vfprintf_r+0x1efc>
80007d40:	20 1b       	sub	r11,1
80007d42:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d46:	12 3b       	cp.w	r11,r9
80007d48:	c0 95       	brlt	80007d5a <_vfprintf_r+0x25a>
80007d4a:	c1 08       	rjmp	80007d6a <_vfprintf_r+0x26a>
80007d4c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d50:	ec ca ff ff 	sub	r10,r6,-1
80007d54:	12 36       	cp.w	r6,r9
80007d56:	c1 f5       	brlt	80007d94 <_vfprintf_r+0x294>
80007d58:	c2 68       	rjmp	80007da4 <_vfprintf_r+0x2a4>
80007d5a:	fa ce f9 44 	sub	lr,sp,-1724
80007d5e:	10 97       	mov	r7,r8
80007d60:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007d64:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007d68:	c3 58       	rjmp	80007dd2 <_vfprintf_r+0x2d2>
80007d6a:	10 97       	mov	r7,r8
80007d6c:	fa c8 f9 50 	sub	r8,sp,-1712
80007d70:	1a d8       	st.w	--sp,r8
80007d72:	fa c8 fa b8 	sub	r8,sp,-1352
80007d76:	1a d8       	st.w	--sp,r8
80007d78:	fa c8 fb b4 	sub	r8,sp,-1100
80007d7c:	02 9a       	mov	r10,r1
80007d7e:	1a d8       	st.w	--sp,r8
80007d80:	04 9c       	mov	r12,r2
80007d82:	fa c8 f9 40 	sub	r8,sp,-1728
80007d86:	fa c9 ff b4 	sub	r9,sp,-76
80007d8a:	fe b0 fd 23 	rcall	800077d0 <get_arg>
80007d8e:	2f dd       	sub	sp,-12
80007d90:	78 00       	ld.w	r0,r12[0x0]
80007d92:	c2 08       	rjmp	80007dd2 <_vfprintf_r+0x2d2>
80007d94:	fa cc f9 44 	sub	r12,sp,-1724
80007d98:	14 96       	mov	r6,r10
80007d9a:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007d9e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007da2:	c1 88       	rjmp	80007dd2 <_vfprintf_r+0x2d2>
80007da4:	41 08       	lddsp	r8,sp[0x40]
80007da6:	59 f9       	cp.w	r9,31
80007da8:	e0 89 00 11 	brgt	80007dca <_vfprintf_r+0x2ca>
80007dac:	f0 cb ff fc 	sub	r11,r8,-4
80007db0:	51 0b       	stdsp	sp[0x40],r11
80007db2:	70 00       	ld.w	r0,r8[0x0]
80007db4:	fa cb f9 44 	sub	r11,sp,-1724
80007db8:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007dbc:	f1 40 fd 88 	st.w	r8[-632],r0
80007dc0:	2f f9       	sub	r9,-1
80007dc2:	14 96       	mov	r6,r10
80007dc4:	fb 49 06 b4 	st.w	sp[1716],r9
80007dc8:	c0 58       	rjmp	80007dd2 <_vfprintf_r+0x2d2>
80007dca:	70 00       	ld.w	r0,r8[0x0]
80007dcc:	14 96       	mov	r6,r10
80007dce:	2f c8       	sub	r8,-4
80007dd0:	51 08       	stdsp	sp[0x40],r8
80007dd2:	58 00       	cp.w	r0,0
80007dd4:	fe 94 ff 76 	brge	80007cc0 <_vfprintf_r+0x1c0>
80007dd8:	5c 30       	neg	r0
80007dda:	a3 a5       	sbr	r5,0x2
80007ddc:	c7 2b       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007dde:	32 b8       	mov	r8,43
80007de0:	fb 68 06 bb 	st.b	sp[1723],r8
80007de4:	c6 eb       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007de6:	0f 38       	ld.ub	r8,r7++
80007de8:	e0 48 00 2a 	cp.w	r8,42
80007dec:	c0 30       	breq	80007df2 <_vfprintf_r+0x2f2>
80007dee:	30 09       	mov	r9,0
80007df0:	c7 98       	rjmp	80007ee2 <_vfprintf_r+0x3e2>
80007df2:	0f 88       	ld.ub	r8,r7[0x0]
80007df4:	f0 c9 00 30 	sub	r9,r8,48
80007df8:	58 99       	cp.w	r9,9
80007dfa:	e0 8b 00 1f 	brhi	80007e38 <_vfprintf_r+0x338>
80007dfe:	ee c4 ff ff 	sub	r4,r7,-1
80007e02:	30 0b       	mov	r11,0
80007e04:	23 08       	sub	r8,48
80007e06:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007e0a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007e0e:	09 38       	ld.ub	r8,r4++
80007e10:	f0 c9 00 30 	sub	r9,r8,48
80007e14:	58 99       	cp.w	r9,9
80007e16:	fe 98 ff f7 	brls	80007e04 <_vfprintf_r+0x304>
80007e1a:	e0 48 00 24 	cp.w	r8,36
80007e1e:	fe 91 ff 4f 	brne	80007cbc <_vfprintf_r+0x1bc>
80007e22:	e0 4b 00 20 	cp.w	r11,32
80007e26:	e0 89 0d eb 	brgt	800099fc <_vfprintf_r+0x1efc>
80007e2a:	20 1b       	sub	r11,1
80007e2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e30:	10 3b       	cp.w	r11,r8
80007e32:	c0 a5       	brlt	80007e46 <_vfprintf_r+0x346>
80007e34:	c1 18       	rjmp	80007e56 <_vfprintf_r+0x356>
80007e36:	d7 03       	nop
80007e38:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007e3c:	ec c9 ff ff 	sub	r9,r6,-1
80007e40:	14 36       	cp.w	r6,r10
80007e42:	c1 f5       	brlt	80007e80 <_vfprintf_r+0x380>
80007e44:	c2 88       	rjmp	80007e94 <_vfprintf_r+0x394>
80007e46:	fa ca f9 44 	sub	r10,sp,-1724
80007e4a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007e4e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007e52:	50 2b       	stdsp	sp[0x8],r11
80007e54:	c3 c8       	rjmp	80007ecc <_vfprintf_r+0x3cc>
80007e56:	fa c8 f9 50 	sub	r8,sp,-1712
80007e5a:	1a d8       	st.w	--sp,r8
80007e5c:	fa c8 fa b8 	sub	r8,sp,-1352
80007e60:	1a d8       	st.w	--sp,r8
80007e62:	fa c8 fb b4 	sub	r8,sp,-1100
80007e66:	02 9a       	mov	r10,r1
80007e68:	1a d8       	st.w	--sp,r8
80007e6a:	04 9c       	mov	r12,r2
80007e6c:	fa c8 f9 40 	sub	r8,sp,-1728
80007e70:	fa c9 ff b4 	sub	r9,sp,-76
80007e74:	fe b0 fc ae 	rcall	800077d0 <get_arg>
80007e78:	2f dd       	sub	sp,-12
80007e7a:	78 0c       	ld.w	r12,r12[0x0]
80007e7c:	50 2c       	stdsp	sp[0x8],r12
80007e7e:	c2 78       	rjmp	80007ecc <_vfprintf_r+0x3cc>
80007e80:	12 96       	mov	r6,r9
80007e82:	0e 94       	mov	r4,r7
80007e84:	fa c9 f9 44 	sub	r9,sp,-1724
80007e88:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007e8c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007e90:	50 28       	stdsp	sp[0x8],r8
80007e92:	c1 d8       	rjmp	80007ecc <_vfprintf_r+0x3cc>
80007e94:	41 08       	lddsp	r8,sp[0x40]
80007e96:	59 fa       	cp.w	r10,31
80007e98:	e0 89 00 14 	brgt	80007ec0 <_vfprintf_r+0x3c0>
80007e9c:	f0 cb ff fc 	sub	r11,r8,-4
80007ea0:	70 08       	ld.w	r8,r8[0x0]
80007ea2:	51 0b       	stdsp	sp[0x40],r11
80007ea4:	50 28       	stdsp	sp[0x8],r8
80007ea6:	fa c6 f9 44 	sub	r6,sp,-1724
80007eaa:	40 2e       	lddsp	lr,sp[0x8]
80007eac:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007eb0:	f1 4e fd 88 	st.w	r8[-632],lr
80007eb4:	2f fa       	sub	r10,-1
80007eb6:	0e 94       	mov	r4,r7
80007eb8:	fb 4a 06 b4 	st.w	sp[1716],r10
80007ebc:	12 96       	mov	r6,r9
80007ebe:	c0 78       	rjmp	80007ecc <_vfprintf_r+0x3cc>
80007ec0:	70 0c       	ld.w	r12,r8[0x0]
80007ec2:	0e 94       	mov	r4,r7
80007ec4:	2f c8       	sub	r8,-4
80007ec6:	50 2c       	stdsp	sp[0x8],r12
80007ec8:	12 96       	mov	r6,r9
80007eca:	51 08       	stdsp	sp[0x40],r8
80007ecc:	40 2b       	lddsp	r11,sp[0x8]
80007ece:	58 0b       	cp.w	r11,0
80007ed0:	fe 95 fe f2 	brlt	80007cb4 <_vfprintf_r+0x1b4>
80007ed4:	08 97       	mov	r7,r4
80007ed6:	cf 5a       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007ed8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007edc:	0f 38       	ld.ub	r8,r7++
80007ede:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007ee2:	f0 ca 00 30 	sub	r10,r8,48
80007ee6:	58 9a       	cp.w	r10,9
80007ee8:	fe 98 ff f8 	brls	80007ed8 <_vfprintf_r+0x3d8>
80007eec:	3f fa       	mov	r10,-1
80007eee:	f2 0a 0c 49 	max	r9,r9,r10
80007ef2:	50 29       	stdsp	sp[0x8],r9
80007ef4:	ce 9a       	rjmp	80007cc6 <_vfprintf_r+0x1c6>
80007ef6:	a7 b5       	sbr	r5,0x7
80007ef8:	ce 4a       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007efa:	30 09       	mov	r9,0
80007efc:	23 08       	sub	r8,48
80007efe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f02:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007f06:	0f 38       	ld.ub	r8,r7++
80007f08:	f0 ca 00 30 	sub	r10,r8,48
80007f0c:	58 9a       	cp.w	r10,9
80007f0e:	fe 98 ff f7 	brls	80007efc <_vfprintf_r+0x3fc>
80007f12:	e0 48 00 24 	cp.w	r8,36
80007f16:	fe 91 fe d7 	brne	80007cc4 <_vfprintf_r+0x1c4>
80007f1a:	e0 49 00 20 	cp.w	r9,32
80007f1e:	e0 89 0d 6f 	brgt	800099fc <_vfprintf_r+0x1efc>
80007f22:	f2 c3 00 01 	sub	r3,r9,1
80007f26:	30 19       	mov	r9,1
80007f28:	50 39       	stdsp	sp[0xc],r9
80007f2a:	cc ba       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007f2c:	a3 b5       	sbr	r5,0x3
80007f2e:	cc 9a       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007f30:	a7 a5       	sbr	r5,0x6
80007f32:	cc 7a       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007f34:	0a 98       	mov	r8,r5
80007f36:	a5 b5       	sbr	r5,0x5
80007f38:	a5 a8       	sbr	r8,0x4
80007f3a:	0f 89       	ld.ub	r9,r7[0x0]
80007f3c:	36 ce       	mov	lr,108
80007f3e:	fc 09 18 00 	cp.b	r9,lr
80007f42:	f7 b7 00 ff 	subeq	r7,-1
80007f46:	f0 05 17 10 	movne	r5,r8
80007f4a:	cb ba       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007f4c:	a5 b5       	sbr	r5,0x5
80007f4e:	cb 9a       	rjmp	80007cc0 <_vfprintf_r+0x1c0>
80007f50:	50 a7       	stdsp	sp[0x28],r7
80007f52:	50 80       	stdsp	sp[0x20],r0
80007f54:	0c 97       	mov	r7,r6
80007f56:	10 90       	mov	r0,r8
80007f58:	06 96       	mov	r6,r3
80007f5a:	04 94       	mov	r4,r2
80007f5c:	40 93       	lddsp	r3,sp[0x24]
80007f5e:	02 92       	mov	r2,r1
80007f60:	0e 99       	mov	r9,r7
80007f62:	40 41       	lddsp	r1,sp[0x10]
80007f64:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f68:	40 3c       	lddsp	r12,sp[0xc]
80007f6a:	58 0c       	cp.w	r12,0
80007f6c:	c1 d0       	breq	80007fa6 <_vfprintf_r+0x4a6>
80007f6e:	10 36       	cp.w	r6,r8
80007f70:	c0 64       	brge	80007f7c <_vfprintf_r+0x47c>
80007f72:	fa cb f9 44 	sub	r11,sp,-1724
80007f76:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f7a:	c1 d8       	rjmp	80007fb4 <_vfprintf_r+0x4b4>
80007f7c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f80:	1a d8       	st.w	--sp,r8
80007f82:	fa c8 fa b8 	sub	r8,sp,-1352
80007f86:	1a d8       	st.w	--sp,r8
80007f88:	fa c8 fb b4 	sub	r8,sp,-1100
80007f8c:	1a d8       	st.w	--sp,r8
80007f8e:	fa c8 f9 40 	sub	r8,sp,-1728
80007f92:	fa c9 ff b4 	sub	r9,sp,-76
80007f96:	04 9a       	mov	r10,r2
80007f98:	0c 9b       	mov	r11,r6
80007f9a:	08 9c       	mov	r12,r4
80007f9c:	fe b0 fc 1a 	rcall	800077d0 <get_arg>
80007fa0:	2f dd       	sub	sp,-12
80007fa2:	19 b8       	ld.ub	r8,r12[0x3]
80007fa4:	c2 28       	rjmp	80007fe8 <_vfprintf_r+0x4e8>
80007fa6:	2f f7       	sub	r7,-1
80007fa8:	10 39       	cp.w	r9,r8
80007faa:	c0 84       	brge	80007fba <_vfprintf_r+0x4ba>
80007fac:	fa ca f9 44 	sub	r10,sp,-1724
80007fb0:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007fb4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007fb8:	c1 88       	rjmp	80007fe8 <_vfprintf_r+0x4e8>
80007fba:	41 09       	lddsp	r9,sp[0x40]
80007fbc:	59 f8       	cp.w	r8,31
80007fbe:	e0 89 00 12 	brgt	80007fe2 <_vfprintf_r+0x4e2>
80007fc2:	f2 ca ff fc 	sub	r10,r9,-4
80007fc6:	51 0a       	stdsp	sp[0x40],r10
80007fc8:	72 09       	ld.w	r9,r9[0x0]
80007fca:	fa c6 f9 44 	sub	r6,sp,-1724
80007fce:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007fd2:	2f f8       	sub	r8,-1
80007fd4:	f5 49 fd 88 	st.w	r10[-632],r9
80007fd8:	fb 48 06 b4 	st.w	sp[1716],r8
80007fdc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007fe0:	c0 48       	rjmp	80007fe8 <_vfprintf_r+0x4e8>
80007fe2:	13 b8       	ld.ub	r8,r9[0x3]
80007fe4:	2f c9       	sub	r9,-4
80007fe6:	51 09       	stdsp	sp[0x40],r9
80007fe8:	fb 68 06 60 	st.b	sp[1632],r8
80007fec:	30 0e       	mov	lr,0
80007fee:	30 08       	mov	r8,0
80007ff0:	30 12       	mov	r2,1
80007ff2:	fb 68 06 bb 	st.b	sp[1723],r8
80007ff6:	50 2e       	stdsp	sp[0x8],lr
80007ff8:	e0 8f 08 ad 	bral	80009152 <_vfprintf_r+0x1652>
80007ffc:	50 a7       	stdsp	sp[0x28],r7
80007ffe:	50 80       	stdsp	sp[0x20],r0
80008000:	0c 97       	mov	r7,r6
80008002:	04 94       	mov	r4,r2
80008004:	06 96       	mov	r6,r3
80008006:	02 92       	mov	r2,r1
80008008:	40 93       	lddsp	r3,sp[0x24]
8000800a:	10 90       	mov	r0,r8
8000800c:	40 41       	lddsp	r1,sp[0x10]
8000800e:	a5 a5       	sbr	r5,0x4
80008010:	c0 a8       	rjmp	80008024 <_vfprintf_r+0x524>
80008012:	50 a7       	stdsp	sp[0x28],r7
80008014:	50 80       	stdsp	sp[0x20],r0
80008016:	0c 97       	mov	r7,r6
80008018:	04 94       	mov	r4,r2
8000801a:	06 96       	mov	r6,r3
8000801c:	02 92       	mov	r2,r1
8000801e:	40 93       	lddsp	r3,sp[0x24]
80008020:	10 90       	mov	r0,r8
80008022:	40 41       	lddsp	r1,sp[0x10]
80008024:	ed b5 00 05 	bld	r5,0x5
80008028:	c5 11       	brne	800080ca <_vfprintf_r+0x5ca>
8000802a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000802e:	40 3c       	lddsp	r12,sp[0xc]
80008030:	58 0c       	cp.w	r12,0
80008032:	c1 e0       	breq	8000806e <_vfprintf_r+0x56e>
80008034:	10 36       	cp.w	r6,r8
80008036:	c0 64       	brge	80008042 <_vfprintf_r+0x542>
80008038:	fa cb f9 44 	sub	r11,sp,-1724
8000803c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008040:	c2 08       	rjmp	80008080 <_vfprintf_r+0x580>
80008042:	fa c8 f9 50 	sub	r8,sp,-1712
80008046:	1a d8       	st.w	--sp,r8
80008048:	fa c8 fa b8 	sub	r8,sp,-1352
8000804c:	0c 9b       	mov	r11,r6
8000804e:	1a d8       	st.w	--sp,r8
80008050:	fa c8 fb b4 	sub	r8,sp,-1100
80008054:	1a d8       	st.w	--sp,r8
80008056:	fa c9 ff b4 	sub	r9,sp,-76
8000805a:	fa c8 f9 40 	sub	r8,sp,-1728
8000805e:	04 9a       	mov	r10,r2
80008060:	08 9c       	mov	r12,r4
80008062:	fe b0 fb b7 	rcall	800077d0 <get_arg>
80008066:	2f dd       	sub	sp,-12
80008068:	78 1b       	ld.w	r11,r12[0x4]
8000806a:	78 09       	ld.w	r9,r12[0x0]
8000806c:	c2 b8       	rjmp	800080c2 <_vfprintf_r+0x5c2>
8000806e:	ee ca ff ff 	sub	r10,r7,-1
80008072:	10 37       	cp.w	r7,r8
80008074:	c0 b4       	brge	8000808a <_vfprintf_r+0x58a>
80008076:	fa c9 f9 44 	sub	r9,sp,-1724
8000807a:	14 97       	mov	r7,r10
8000807c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008080:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008084:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008088:	c1 d8       	rjmp	800080c2 <_vfprintf_r+0x5c2>
8000808a:	41 09       	lddsp	r9,sp[0x40]
8000808c:	59 f8       	cp.w	r8,31
8000808e:	e0 89 00 14 	brgt	800080b6 <_vfprintf_r+0x5b6>
80008092:	f2 cb ff f8 	sub	r11,r9,-8
80008096:	51 0b       	stdsp	sp[0x40],r11
80008098:	fa c6 f9 44 	sub	r6,sp,-1724
8000809c:	72 1b       	ld.w	r11,r9[0x4]
8000809e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800080a2:	72 09       	ld.w	r9,r9[0x0]
800080a4:	f9 4b fd 8c 	st.w	r12[-628],r11
800080a8:	f9 49 fd 88 	st.w	r12[-632],r9
800080ac:	2f f8       	sub	r8,-1
800080ae:	14 97       	mov	r7,r10
800080b0:	fb 48 06 b4 	st.w	sp[1716],r8
800080b4:	c0 78       	rjmp	800080c2 <_vfprintf_r+0x5c2>
800080b6:	f2 c8 ff f8 	sub	r8,r9,-8
800080ba:	72 1b       	ld.w	r11,r9[0x4]
800080bc:	14 97       	mov	r7,r10
800080be:	51 08       	stdsp	sp[0x40],r8
800080c0:	72 09       	ld.w	r9,r9[0x0]
800080c2:	16 98       	mov	r8,r11
800080c4:	fa e9 00 00 	st.d	sp[0],r8
800080c8:	ca e8       	rjmp	80008224 <_vfprintf_r+0x724>
800080ca:	ed b5 00 04 	bld	r5,0x4
800080ce:	c1 71       	brne	800080fc <_vfprintf_r+0x5fc>
800080d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080d4:	40 3e       	lddsp	lr,sp[0xc]
800080d6:	58 0e       	cp.w	lr,0
800080d8:	c0 80       	breq	800080e8 <_vfprintf_r+0x5e8>
800080da:	10 36       	cp.w	r6,r8
800080dc:	c6 94       	brge	800081ae <_vfprintf_r+0x6ae>
800080de:	fa cc f9 44 	sub	r12,sp,-1724
800080e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080e6:	c8 28       	rjmp	800081ea <_vfprintf_r+0x6ea>
800080e8:	ee ca ff ff 	sub	r10,r7,-1
800080ec:	10 37       	cp.w	r7,r8
800080ee:	e0 84 00 81 	brge	800081f0 <_vfprintf_r+0x6f0>
800080f2:	fa cb f9 44 	sub	r11,sp,-1724
800080f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080fa:	c7 78       	rjmp	800081e8 <_vfprintf_r+0x6e8>
800080fc:	ed b5 00 06 	bld	r5,0x6
80008100:	c4 b1       	brne	80008196 <_vfprintf_r+0x696>
80008102:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008106:	40 3c       	lddsp	r12,sp[0xc]
80008108:	58 0c       	cp.w	r12,0
8000810a:	c1 d0       	breq	80008144 <_vfprintf_r+0x644>
8000810c:	10 36       	cp.w	r6,r8
8000810e:	c0 64       	brge	8000811a <_vfprintf_r+0x61a>
80008110:	fa cb f9 44 	sub	r11,sp,-1724
80008114:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008118:	c1 f8       	rjmp	80008156 <_vfprintf_r+0x656>
8000811a:	fa c8 f9 50 	sub	r8,sp,-1712
8000811e:	1a d8       	st.w	--sp,r8
80008120:	fa c8 fa b8 	sub	r8,sp,-1352
80008124:	1a d8       	st.w	--sp,r8
80008126:	fa c8 fb b4 	sub	r8,sp,-1100
8000812a:	1a d8       	st.w	--sp,r8
8000812c:	fa c8 f9 40 	sub	r8,sp,-1728
80008130:	fa c9 ff b4 	sub	r9,sp,-76
80008134:	04 9a       	mov	r10,r2
80008136:	0c 9b       	mov	r11,r6
80008138:	08 9c       	mov	r12,r4
8000813a:	fe b0 fb 4b 	rcall	800077d0 <get_arg>
8000813e:	2f dd       	sub	sp,-12
80008140:	98 18       	ld.sh	r8,r12[0x2]
80008142:	c2 68       	rjmp	8000818e <_vfprintf_r+0x68e>
80008144:	ee ca ff ff 	sub	r10,r7,-1
80008148:	10 37       	cp.w	r7,r8
8000814a:	c0 94       	brge	8000815c <_vfprintf_r+0x65c>
8000814c:	fa c9 f9 44 	sub	r9,sp,-1724
80008150:	14 97       	mov	r7,r10
80008152:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008156:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000815a:	c1 a8       	rjmp	8000818e <_vfprintf_r+0x68e>
8000815c:	41 09       	lddsp	r9,sp[0x40]
8000815e:	59 f8       	cp.w	r8,31
80008160:	e0 89 00 13 	brgt	80008186 <_vfprintf_r+0x686>
80008164:	f2 cb ff fc 	sub	r11,r9,-4
80008168:	51 0b       	stdsp	sp[0x40],r11
8000816a:	72 09       	ld.w	r9,r9[0x0]
8000816c:	fa c6 f9 44 	sub	r6,sp,-1724
80008170:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008174:	2f f8       	sub	r8,-1
80008176:	f7 49 fd 88 	st.w	r11[-632],r9
8000817a:	fb 48 06 b4 	st.w	sp[1716],r8
8000817e:	14 97       	mov	r7,r10
80008180:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008184:	c0 58       	rjmp	8000818e <_vfprintf_r+0x68e>
80008186:	92 18       	ld.sh	r8,r9[0x2]
80008188:	14 97       	mov	r7,r10
8000818a:	2f c9       	sub	r9,-4
8000818c:	51 09       	stdsp	sp[0x40],r9
8000818e:	50 18       	stdsp	sp[0x4],r8
80008190:	bf 58       	asr	r8,0x1f
80008192:	50 08       	stdsp	sp[0x0],r8
80008194:	c4 88       	rjmp	80008224 <_vfprintf_r+0x724>
80008196:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000819a:	40 3c       	lddsp	r12,sp[0xc]
8000819c:	58 0c       	cp.w	r12,0
8000819e:	c1 d0       	breq	800081d8 <_vfprintf_r+0x6d8>
800081a0:	10 36       	cp.w	r6,r8
800081a2:	c0 64       	brge	800081ae <_vfprintf_r+0x6ae>
800081a4:	fa cb f9 44 	sub	r11,sp,-1724
800081a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081ac:	c1 f8       	rjmp	800081ea <_vfprintf_r+0x6ea>
800081ae:	fa c8 f9 50 	sub	r8,sp,-1712
800081b2:	1a d8       	st.w	--sp,r8
800081b4:	fa c8 fa b8 	sub	r8,sp,-1352
800081b8:	0c 9b       	mov	r11,r6
800081ba:	1a d8       	st.w	--sp,r8
800081bc:	fa c8 fb b4 	sub	r8,sp,-1100
800081c0:	04 9a       	mov	r10,r2
800081c2:	1a d8       	st.w	--sp,r8
800081c4:	08 9c       	mov	r12,r4
800081c6:	fa c8 f9 40 	sub	r8,sp,-1728
800081ca:	fa c9 ff b4 	sub	r9,sp,-76
800081ce:	fe b0 fb 01 	rcall	800077d0 <get_arg>
800081d2:	2f dd       	sub	sp,-12
800081d4:	78 0b       	ld.w	r11,r12[0x0]
800081d6:	c2 48       	rjmp	8000821e <_vfprintf_r+0x71e>
800081d8:	ee ca ff ff 	sub	r10,r7,-1
800081dc:	10 37       	cp.w	r7,r8
800081de:	c0 94       	brge	800081f0 <_vfprintf_r+0x6f0>
800081e0:	fa c9 f9 44 	sub	r9,sp,-1724
800081e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081e8:	14 97       	mov	r7,r10
800081ea:	ec fb fd 88 	ld.w	r11,r6[-632]
800081ee:	c1 88       	rjmp	8000821e <_vfprintf_r+0x71e>
800081f0:	41 09       	lddsp	r9,sp[0x40]
800081f2:	59 f8       	cp.w	r8,31
800081f4:	e0 89 00 11 	brgt	80008216 <_vfprintf_r+0x716>
800081f8:	f2 cb ff fc 	sub	r11,r9,-4
800081fc:	51 0b       	stdsp	sp[0x40],r11
800081fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008202:	72 0b       	ld.w	r11,r9[0x0]
80008204:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008208:	f3 4b fd 88 	st.w	r9[-632],r11
8000820c:	2f f8       	sub	r8,-1
8000820e:	14 97       	mov	r7,r10
80008210:	fb 48 06 b4 	st.w	sp[1716],r8
80008214:	c0 58       	rjmp	8000821e <_vfprintf_r+0x71e>
80008216:	72 0b       	ld.w	r11,r9[0x0]
80008218:	14 97       	mov	r7,r10
8000821a:	2f c9       	sub	r9,-4
8000821c:	51 09       	stdsp	sp[0x40],r9
8000821e:	50 1b       	stdsp	sp[0x4],r11
80008220:	bf 5b       	asr	r11,0x1f
80008222:	50 0b       	stdsp	sp[0x0],r11
80008224:	fa ea 00 00 	ld.d	r10,sp[0]
80008228:	58 0a       	cp.w	r10,0
8000822a:	5c 2b       	cpc	r11
8000822c:	c0 e4       	brge	80008248 <_vfprintf_r+0x748>
8000822e:	30 08       	mov	r8,0
80008230:	fa ea 00 00 	ld.d	r10,sp[0]
80008234:	30 09       	mov	r9,0
80008236:	f0 0a 01 0a 	sub	r10,r8,r10
8000823a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000823e:	32 d8       	mov	r8,45
80008240:	fa eb 00 00 	st.d	sp[0],r10
80008244:	fb 68 06 bb 	st.b	sp[1723],r8
80008248:	30 18       	mov	r8,1
8000824a:	e0 8f 06 fa 	bral	8000903e <_vfprintf_r+0x153e>
8000824e:	50 a7       	stdsp	sp[0x28],r7
80008250:	50 80       	stdsp	sp[0x20],r0
80008252:	0c 97       	mov	r7,r6
80008254:	04 94       	mov	r4,r2
80008256:	06 96       	mov	r6,r3
80008258:	02 92       	mov	r2,r1
8000825a:	40 93       	lddsp	r3,sp[0x24]
8000825c:	10 90       	mov	r0,r8
8000825e:	40 41       	lddsp	r1,sp[0x10]
80008260:	0e 99       	mov	r9,r7
80008262:	ed b5 00 03 	bld	r5,0x3
80008266:	c4 11       	brne	800082e8 <_vfprintf_r+0x7e8>
80008268:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000826c:	40 3a       	lddsp	r10,sp[0xc]
8000826e:	58 0a       	cp.w	r10,0
80008270:	c1 90       	breq	800082a2 <_vfprintf_r+0x7a2>
80008272:	10 36       	cp.w	r6,r8
80008274:	c6 45       	brlt	8000833c <_vfprintf_r+0x83c>
80008276:	fa c8 f9 50 	sub	r8,sp,-1712
8000827a:	1a d8       	st.w	--sp,r8
8000827c:	fa c8 fa b8 	sub	r8,sp,-1352
80008280:	1a d8       	st.w	--sp,r8
80008282:	fa c8 fb b4 	sub	r8,sp,-1100
80008286:	0c 9b       	mov	r11,r6
80008288:	1a d8       	st.w	--sp,r8
8000828a:	04 9a       	mov	r10,r2
8000828c:	fa c8 f9 40 	sub	r8,sp,-1728
80008290:	fa c9 ff b4 	sub	r9,sp,-76
80008294:	08 9c       	mov	r12,r4
80008296:	fe b0 fa 9d 	rcall	800077d0 <get_arg>
8000829a:	2f dd       	sub	sp,-12
8000829c:	78 16       	ld.w	r6,r12[0x4]
8000829e:	50 76       	stdsp	sp[0x1c],r6
800082a0:	c4 88       	rjmp	80008330 <_vfprintf_r+0x830>
800082a2:	2f f7       	sub	r7,-1
800082a4:	10 39       	cp.w	r9,r8
800082a6:	c0 c4       	brge	800082be <_vfprintf_r+0x7be>
800082a8:	fa ce f9 44 	sub	lr,sp,-1724
800082ac:	fc 06 00 36 	add	r6,lr,r6<<0x3
800082b0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800082b4:	50 7c       	stdsp	sp[0x1c],r12
800082b6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082ba:	50 56       	stdsp	sp[0x14],r6
800082bc:	c6 68       	rjmp	80008388 <_vfprintf_r+0x888>
800082be:	41 09       	lddsp	r9,sp[0x40]
800082c0:	59 f8       	cp.w	r8,31
800082c2:	e0 89 00 10 	brgt	800082e2 <_vfprintf_r+0x7e2>
800082c6:	f2 ca ff f8 	sub	r10,r9,-8
800082ca:	72 1b       	ld.w	r11,r9[0x4]
800082cc:	51 0a       	stdsp	sp[0x40],r10
800082ce:	72 09       	ld.w	r9,r9[0x0]
800082d0:	fa ca f9 44 	sub	r10,sp,-1724
800082d4:	50 7b       	stdsp	sp[0x1c],r11
800082d6:	50 59       	stdsp	sp[0x14],r9
800082d8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800082dc:	40 5b       	lddsp	r11,sp[0x14]
800082de:	40 7a       	lddsp	r10,sp[0x1c]
800082e0:	c4 78       	rjmp	8000836e <_vfprintf_r+0x86e>
800082e2:	72 18       	ld.w	r8,r9[0x4]
800082e4:	50 78       	stdsp	sp[0x1c],r8
800082e6:	c4 c8       	rjmp	8000837e <_vfprintf_r+0x87e>
800082e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082ec:	40 3e       	lddsp	lr,sp[0xc]
800082ee:	58 0e       	cp.w	lr,0
800082f0:	c2 30       	breq	80008336 <_vfprintf_r+0x836>
800082f2:	10 36       	cp.w	r6,r8
800082f4:	c0 94       	brge	80008306 <_vfprintf_r+0x806>
800082f6:	fa cc f9 44 	sub	r12,sp,-1724
800082fa:	f8 06 00 36 	add	r6,r12,r6<<0x3
800082fe:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008302:	50 7b       	stdsp	sp[0x1c],r11
80008304:	cd 9b       	rjmp	800082b6 <_vfprintf_r+0x7b6>
80008306:	fa c8 f9 50 	sub	r8,sp,-1712
8000830a:	1a d8       	st.w	--sp,r8
8000830c:	fa c8 fa b8 	sub	r8,sp,-1352
80008310:	04 9a       	mov	r10,r2
80008312:	1a d8       	st.w	--sp,r8
80008314:	fa c8 fb b4 	sub	r8,sp,-1100
80008318:	0c 9b       	mov	r11,r6
8000831a:	1a d8       	st.w	--sp,r8
8000831c:	08 9c       	mov	r12,r4
8000831e:	fa c8 f9 40 	sub	r8,sp,-1728
80008322:	fa c9 ff b4 	sub	r9,sp,-76
80008326:	fe b0 fa 55 	rcall	800077d0 <get_arg>
8000832a:	2f dd       	sub	sp,-12
8000832c:	78 1a       	ld.w	r10,r12[0x4]
8000832e:	50 7a       	stdsp	sp[0x1c],r10
80008330:	78 0c       	ld.w	r12,r12[0x0]
80008332:	50 5c       	stdsp	sp[0x14],r12
80008334:	c2 a8       	rjmp	80008388 <_vfprintf_r+0x888>
80008336:	2f f7       	sub	r7,-1
80008338:	10 39       	cp.w	r9,r8
8000833a:	c0 94       	brge	8000834c <_vfprintf_r+0x84c>
8000833c:	fa c9 f9 44 	sub	r9,sp,-1724
80008340:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008344:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008348:	50 78       	stdsp	sp[0x1c],r8
8000834a:	cb 6b       	rjmp	800082b6 <_vfprintf_r+0x7b6>
8000834c:	41 09       	lddsp	r9,sp[0x40]
8000834e:	59 f8       	cp.w	r8,31
80008350:	e0 89 00 15 	brgt	8000837a <_vfprintf_r+0x87a>
80008354:	f2 ca ff f8 	sub	r10,r9,-8
80008358:	72 16       	ld.w	r6,r9[0x4]
8000835a:	72 09       	ld.w	r9,r9[0x0]
8000835c:	51 0a       	stdsp	sp[0x40],r10
8000835e:	50 59       	stdsp	sp[0x14],r9
80008360:	fa ce f9 44 	sub	lr,sp,-1724
80008364:	50 76       	stdsp	sp[0x1c],r6
80008366:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000836a:	40 5b       	lddsp	r11,sp[0x14]
8000836c:	0c 9a       	mov	r10,r6
8000836e:	f2 eb fd 88 	st.d	r9[-632],r10
80008372:	2f f8       	sub	r8,-1
80008374:	fb 48 06 b4 	st.w	sp[1716],r8
80008378:	c0 88       	rjmp	80008388 <_vfprintf_r+0x888>
8000837a:	72 1c       	ld.w	r12,r9[0x4]
8000837c:	50 7c       	stdsp	sp[0x1c],r12
8000837e:	f2 c8 ff f8 	sub	r8,r9,-8
80008382:	51 08       	stdsp	sp[0x40],r8
80008384:	72 09       	ld.w	r9,r9[0x0]
80008386:	50 59       	stdsp	sp[0x14],r9
80008388:	40 5b       	lddsp	r11,sp[0x14]
8000838a:	40 7a       	lddsp	r10,sp[0x1c]
8000838c:	e0 a0 19 54 	rcall	8000b634 <__isinfd>
80008390:	18 96       	mov	r6,r12
80008392:	c1 70       	breq	800083c0 <_vfprintf_r+0x8c0>
80008394:	30 08       	mov	r8,0
80008396:	30 09       	mov	r9,0
80008398:	40 5b       	lddsp	r11,sp[0x14]
8000839a:	40 7a       	lddsp	r10,sp[0x1c]
8000839c:	e0 a0 1d b4 	rcall	8000bf04 <__avr32_f64_cmp_lt>
800083a0:	c0 40       	breq	800083a8 <_vfprintf_r+0x8a8>
800083a2:	32 d8       	mov	r8,45
800083a4:	fb 68 06 bb 	st.b	sp[1723],r8
800083a8:	fe c8 ab 44 	sub	r8,pc,-21692
800083ac:	fe c6 ab 44 	sub	r6,pc,-21692
800083b0:	a7 d5       	cbr	r5,0x7
800083b2:	e0 40 00 47 	cp.w	r0,71
800083b6:	f0 06 17 a0 	movle	r6,r8
800083ba:	30 32       	mov	r2,3
800083bc:	e0 8f 06 ce 	bral	80009158 <_vfprintf_r+0x1658>
800083c0:	40 5b       	lddsp	r11,sp[0x14]
800083c2:	40 7a       	lddsp	r10,sp[0x1c]
800083c4:	e0 a0 19 4d 	rcall	8000b65e <__isnand>
800083c8:	c0 e0       	breq	800083e4 <_vfprintf_r+0x8e4>
800083ca:	50 26       	stdsp	sp[0x8],r6
800083cc:	fe c8 ab 60 	sub	r8,pc,-21664
800083d0:	fe c6 ab 60 	sub	r6,pc,-21664
800083d4:	a7 d5       	cbr	r5,0x7
800083d6:	e0 40 00 47 	cp.w	r0,71
800083da:	f0 06 17 a0 	movle	r6,r8
800083de:	30 32       	mov	r2,3
800083e0:	e0 8f 06 c2 	bral	80009164 <_vfprintf_r+0x1664>
800083e4:	40 2a       	lddsp	r10,sp[0x8]
800083e6:	5b fa       	cp.w	r10,-1
800083e8:	c0 41       	brne	800083f0 <_vfprintf_r+0x8f0>
800083ea:	30 69       	mov	r9,6
800083ec:	50 29       	stdsp	sp[0x8],r9
800083ee:	c1 18       	rjmp	80008410 <_vfprintf_r+0x910>
800083f0:	e0 40 00 47 	cp.w	r0,71
800083f4:	5f 09       	sreq	r9
800083f6:	e0 40 00 67 	cp.w	r0,103
800083fa:	5f 08       	sreq	r8
800083fc:	f3 e8 10 08 	or	r8,r9,r8
80008400:	f8 08 18 00 	cp.b	r8,r12
80008404:	c0 60       	breq	80008410 <_vfprintf_r+0x910>
80008406:	40 28       	lddsp	r8,sp[0x8]
80008408:	58 08       	cp.w	r8,0
8000840a:	f9 b8 00 01 	moveq	r8,1
8000840e:	50 28       	stdsp	sp[0x8],r8
80008410:	40 78       	lddsp	r8,sp[0x1c]
80008412:	40 59       	lddsp	r9,sp[0x14]
80008414:	fa e9 06 94 	st.d	sp[1684],r8
80008418:	a9 a5       	sbr	r5,0x8
8000841a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000841e:	58 08       	cp.w	r8,0
80008420:	c0 65       	brlt	8000842c <_vfprintf_r+0x92c>
80008422:	40 5e       	lddsp	lr,sp[0x14]
80008424:	30 0c       	mov	r12,0
80008426:	50 6e       	stdsp	sp[0x18],lr
80008428:	50 9c       	stdsp	sp[0x24],r12
8000842a:	c0 78       	rjmp	80008438 <_vfprintf_r+0x938>
8000842c:	40 5b       	lddsp	r11,sp[0x14]
8000842e:	32 da       	mov	r10,45
80008430:	ee 1b 80 00 	eorh	r11,0x8000
80008434:	50 9a       	stdsp	sp[0x24],r10
80008436:	50 6b       	stdsp	sp[0x18],r11
80008438:	e0 40 00 46 	cp.w	r0,70
8000843c:	5f 09       	sreq	r9
8000843e:	e0 40 00 66 	cp.w	r0,102
80008442:	5f 08       	sreq	r8
80008444:	f3 e8 10 08 	or	r8,r9,r8
80008448:	50 48       	stdsp	sp[0x10],r8
8000844a:	c0 40       	breq	80008452 <_vfprintf_r+0x952>
8000844c:	40 22       	lddsp	r2,sp[0x8]
8000844e:	30 39       	mov	r9,3
80008450:	c1 08       	rjmp	80008470 <_vfprintf_r+0x970>
80008452:	e0 40 00 45 	cp.w	r0,69
80008456:	5f 09       	sreq	r9
80008458:	e0 40 00 65 	cp.w	r0,101
8000845c:	5f 08       	sreq	r8
8000845e:	40 22       	lddsp	r2,sp[0x8]
80008460:	10 49       	or	r9,r8
80008462:	2f f2       	sub	r2,-1
80008464:	40 46       	lddsp	r6,sp[0x10]
80008466:	ec 09 18 00 	cp.b	r9,r6
8000846a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000846e:	30 29       	mov	r9,2
80008470:	fa c8 f9 5c 	sub	r8,sp,-1700
80008474:	1a d8       	st.w	--sp,r8
80008476:	fa c8 f9 54 	sub	r8,sp,-1708
8000847a:	1a d8       	st.w	--sp,r8
8000847c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008480:	08 9c       	mov	r12,r4
80008482:	1a d8       	st.w	--sp,r8
80008484:	04 98       	mov	r8,r2
80008486:	40 9b       	lddsp	r11,sp[0x24]
80008488:	40 aa       	lddsp	r10,sp[0x28]
8000848a:	e0 a0 0b c3 	rcall	80009c10 <_dtoa_r>
8000848e:	e0 40 00 47 	cp.w	r0,71
80008492:	5f 19       	srne	r9
80008494:	e0 40 00 67 	cp.w	r0,103
80008498:	5f 18       	srne	r8
8000849a:	18 96       	mov	r6,r12
8000849c:	2f dd       	sub	sp,-12
8000849e:	f3 e8 00 08 	and	r8,r9,r8
800084a2:	c0 41       	brne	800084aa <_vfprintf_r+0x9aa>
800084a4:	ed b5 00 00 	bld	r5,0x0
800084a8:	c3 01       	brne	80008508 <_vfprintf_r+0xa08>
800084aa:	ec 02 00 0e 	add	lr,r6,r2
800084ae:	50 3e       	stdsp	sp[0xc],lr
800084b0:	40 4c       	lddsp	r12,sp[0x10]
800084b2:	58 0c       	cp.w	r12,0
800084b4:	c1 50       	breq	800084de <_vfprintf_r+0x9de>
800084b6:	0d 89       	ld.ub	r9,r6[0x0]
800084b8:	33 08       	mov	r8,48
800084ba:	f0 09 18 00 	cp.b	r9,r8
800084be:	c0 b1       	brne	800084d4 <_vfprintf_r+0x9d4>
800084c0:	30 08       	mov	r8,0
800084c2:	30 09       	mov	r9,0
800084c4:	40 6b       	lddsp	r11,sp[0x18]
800084c6:	40 7a       	lddsp	r10,sp[0x1c]
800084c8:	e0 a0 1c d7 	rcall	8000be76 <__avr32_f64_cmp_eq>
800084cc:	fb b2 00 01 	rsubeq	r2,1
800084d0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800084d4:	40 3b       	lddsp	r11,sp[0xc]
800084d6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084da:	10 0b       	add	r11,r8
800084dc:	50 3b       	stdsp	sp[0xc],r11
800084de:	40 6b       	lddsp	r11,sp[0x18]
800084e0:	30 08       	mov	r8,0
800084e2:	30 09       	mov	r9,0
800084e4:	40 7a       	lddsp	r10,sp[0x1c]
800084e6:	e0 a0 1c c8 	rcall	8000be76 <__avr32_f64_cmp_eq>
800084ea:	c0 90       	breq	800084fc <_vfprintf_r+0x9fc>
800084ec:	40 3a       	lddsp	r10,sp[0xc]
800084ee:	fb 4a 06 a4 	st.w	sp[1700],r10
800084f2:	c0 58       	rjmp	800084fc <_vfprintf_r+0x9fc>
800084f4:	10 c9       	st.b	r8++,r9
800084f6:	fb 48 06 a4 	st.w	sp[1700],r8
800084fa:	c0 28       	rjmp	800084fe <_vfprintf_r+0x9fe>
800084fc:	33 09       	mov	r9,48
800084fe:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008502:	40 3e       	lddsp	lr,sp[0xc]
80008504:	1c 38       	cp.w	r8,lr
80008506:	cf 73       	brcs	800084f4 <_vfprintf_r+0x9f4>
80008508:	e0 40 00 47 	cp.w	r0,71
8000850c:	5f 09       	sreq	r9
8000850e:	e0 40 00 67 	cp.w	r0,103
80008512:	5f 08       	sreq	r8
80008514:	f3 e8 10 08 	or	r8,r9,r8
80008518:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000851c:	0c 19       	sub	r9,r6
8000851e:	50 69       	stdsp	sp[0x18],r9
80008520:	58 08       	cp.w	r8,0
80008522:	c0 b0       	breq	80008538 <_vfprintf_r+0xa38>
80008524:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008528:	5b d8       	cp.w	r8,-3
8000852a:	c0 55       	brlt	80008534 <_vfprintf_r+0xa34>
8000852c:	40 2c       	lddsp	r12,sp[0x8]
8000852e:	18 38       	cp.w	r8,r12
80008530:	e0 8a 00 6a 	brle	80008604 <_vfprintf_r+0xb04>
80008534:	20 20       	sub	r0,2
80008536:	c0 58       	rjmp	80008540 <_vfprintf_r+0xa40>
80008538:	e0 40 00 65 	cp.w	r0,101
8000853c:	e0 89 00 46 	brgt	800085c8 <_vfprintf_r+0xac8>
80008540:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008544:	fb 60 06 9c 	st.b	sp[1692],r0
80008548:	20 1b       	sub	r11,1
8000854a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000854e:	c0 47       	brpl	80008556 <_vfprintf_r+0xa56>
80008550:	5c 3b       	neg	r11
80008552:	32 d8       	mov	r8,45
80008554:	c0 28       	rjmp	80008558 <_vfprintf_r+0xa58>
80008556:	32 b8       	mov	r8,43
80008558:	fb 68 06 9d 	st.b	sp[1693],r8
8000855c:	58 9b       	cp.w	r11,9
8000855e:	e0 8a 00 1d 	brle	80008598 <_vfprintf_r+0xa98>
80008562:	fa c9 fa 35 	sub	r9,sp,-1483
80008566:	30 aa       	mov	r10,10
80008568:	12 98       	mov	r8,r9
8000856a:	0e 9c       	mov	r12,r7
8000856c:	0c 92       	mov	r2,r6
8000856e:	f6 0a 0c 06 	divs	r6,r11,r10
80008572:	0e 9b       	mov	r11,r7
80008574:	2d 0b       	sub	r11,-48
80008576:	10 fb       	st.b	--r8,r11
80008578:	0c 9b       	mov	r11,r6
8000857a:	58 96       	cp.w	r6,9
8000857c:	fe 99 ff f9 	brgt	8000856e <_vfprintf_r+0xa6e>
80008580:	2d 0b       	sub	r11,-48
80008582:	18 97       	mov	r7,r12
80008584:	04 96       	mov	r6,r2
80008586:	10 fb       	st.b	--r8,r11
80008588:	fa ca f9 62 	sub	r10,sp,-1694
8000858c:	c0 38       	rjmp	80008592 <_vfprintf_r+0xa92>
8000858e:	11 3b       	ld.ub	r11,r8++
80008590:	14 cb       	st.b	r10++,r11
80008592:	12 38       	cp.w	r8,r9
80008594:	cf d3       	brcs	8000858e <_vfprintf_r+0xa8e>
80008596:	c0 98       	rjmp	800085a8 <_vfprintf_r+0xaa8>
80008598:	2d 0b       	sub	r11,-48
8000859a:	33 08       	mov	r8,48
8000859c:	fb 6b 06 9f 	st.b	sp[1695],r11
800085a0:	fb 68 06 9e 	st.b	sp[1694],r8
800085a4:	fa ca f9 60 	sub	r10,sp,-1696
800085a8:	fa c8 f9 64 	sub	r8,sp,-1692
800085ac:	f4 08 01 08 	sub	r8,r10,r8
800085b0:	50 e8       	stdsp	sp[0x38],r8
800085b2:	10 92       	mov	r2,r8
800085b4:	40 6b       	lddsp	r11,sp[0x18]
800085b6:	16 02       	add	r2,r11
800085b8:	58 1b       	cp.w	r11,1
800085ba:	e0 89 00 05 	brgt	800085c4 <_vfprintf_r+0xac4>
800085be:	ed b5 00 00 	bld	r5,0x0
800085c2:	c3 51       	brne	8000862c <_vfprintf_r+0xb2c>
800085c4:	2f f2       	sub	r2,-1
800085c6:	c3 38       	rjmp	8000862c <_vfprintf_r+0xb2c>
800085c8:	e0 40 00 66 	cp.w	r0,102
800085cc:	c1 c1       	brne	80008604 <_vfprintf_r+0xb04>
800085ce:	fa f2 06 ac 	ld.w	r2,sp[1708]
800085d2:	58 02       	cp.w	r2,0
800085d4:	e0 8a 00 0c 	brle	800085ec <_vfprintf_r+0xaec>
800085d8:	40 2a       	lddsp	r10,sp[0x8]
800085da:	58 0a       	cp.w	r10,0
800085dc:	c0 41       	brne	800085e4 <_vfprintf_r+0xae4>
800085de:	ed b5 00 00 	bld	r5,0x0
800085e2:	c2 51       	brne	8000862c <_vfprintf_r+0xb2c>
800085e4:	2f f2       	sub	r2,-1
800085e6:	40 29       	lddsp	r9,sp[0x8]
800085e8:	12 02       	add	r2,r9
800085ea:	c0 b8       	rjmp	80008600 <_vfprintf_r+0xb00>
800085ec:	40 28       	lddsp	r8,sp[0x8]
800085ee:	58 08       	cp.w	r8,0
800085f0:	c0 61       	brne	800085fc <_vfprintf_r+0xafc>
800085f2:	ed b5 00 00 	bld	r5,0x0
800085f6:	c0 30       	breq	800085fc <_vfprintf_r+0xafc>
800085f8:	30 12       	mov	r2,1
800085fa:	c1 98       	rjmp	8000862c <_vfprintf_r+0xb2c>
800085fc:	40 22       	lddsp	r2,sp[0x8]
800085fe:	2f e2       	sub	r2,-2
80008600:	36 60       	mov	r0,102
80008602:	c1 58       	rjmp	8000862c <_vfprintf_r+0xb2c>
80008604:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008608:	40 6e       	lddsp	lr,sp[0x18]
8000860a:	1c 32       	cp.w	r2,lr
8000860c:	c0 65       	brlt	80008618 <_vfprintf_r+0xb18>
8000860e:	ed b5 00 00 	bld	r5,0x0
80008612:	f7 b2 00 ff 	subeq	r2,-1
80008616:	c0 a8       	rjmp	8000862a <_vfprintf_r+0xb2a>
80008618:	e4 08 11 02 	rsub	r8,r2,2
8000861c:	40 6c       	lddsp	r12,sp[0x18]
8000861e:	58 02       	cp.w	r2,0
80008620:	f0 02 17 a0 	movle	r2,r8
80008624:	f9 b2 09 01 	movgt	r2,1
80008628:	18 02       	add	r2,r12
8000862a:	36 70       	mov	r0,103
8000862c:	40 9b       	lddsp	r11,sp[0x24]
8000862e:	58 0b       	cp.w	r11,0
80008630:	e0 80 05 94 	breq	80009158 <_vfprintf_r+0x1658>
80008634:	32 d8       	mov	r8,45
80008636:	fb 68 06 bb 	st.b	sp[1723],r8
8000863a:	e0 8f 05 93 	bral	80009160 <_vfprintf_r+0x1660>
8000863e:	50 a7       	stdsp	sp[0x28],r7
80008640:	04 94       	mov	r4,r2
80008642:	0c 97       	mov	r7,r6
80008644:	02 92       	mov	r2,r1
80008646:	06 96       	mov	r6,r3
80008648:	40 41       	lddsp	r1,sp[0x10]
8000864a:	40 93       	lddsp	r3,sp[0x24]
8000864c:	0e 99       	mov	r9,r7
8000864e:	ed b5 00 05 	bld	r5,0x5
80008652:	c4 81       	brne	800086e2 <_vfprintf_r+0xbe2>
80008654:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008658:	40 3e       	lddsp	lr,sp[0xc]
8000865a:	58 0e       	cp.w	lr,0
8000865c:	c1 d0       	breq	80008696 <_vfprintf_r+0xb96>
8000865e:	10 36       	cp.w	r6,r8
80008660:	c0 64       	brge	8000866c <_vfprintf_r+0xb6c>
80008662:	fa cc f9 44 	sub	r12,sp,-1724
80008666:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000866a:	c1 d8       	rjmp	800086a4 <_vfprintf_r+0xba4>
8000866c:	fa c8 f9 50 	sub	r8,sp,-1712
80008670:	1a d8       	st.w	--sp,r8
80008672:	fa c8 fa b8 	sub	r8,sp,-1352
80008676:	04 9a       	mov	r10,r2
80008678:	1a d8       	st.w	--sp,r8
8000867a:	fa c8 fb b4 	sub	r8,sp,-1100
8000867e:	0c 9b       	mov	r11,r6
80008680:	1a d8       	st.w	--sp,r8
80008682:	08 9c       	mov	r12,r4
80008684:	fa c8 f9 40 	sub	r8,sp,-1728
80008688:	fa c9 ff b4 	sub	r9,sp,-76
8000868c:	fe b0 f8 a2 	rcall	800077d0 <get_arg>
80008690:	2f dd       	sub	sp,-12
80008692:	78 0a       	ld.w	r10,r12[0x0]
80008694:	c2 08       	rjmp	800086d4 <_vfprintf_r+0xbd4>
80008696:	2f f7       	sub	r7,-1
80008698:	10 39       	cp.w	r9,r8
8000869a:	c0 84       	brge	800086aa <_vfprintf_r+0xbaa>
8000869c:	fa cb f9 44 	sub	r11,sp,-1724
800086a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086a4:	ec fa fd 88 	ld.w	r10,r6[-632]
800086a8:	c1 68       	rjmp	800086d4 <_vfprintf_r+0xbd4>
800086aa:	41 09       	lddsp	r9,sp[0x40]
800086ac:	59 f8       	cp.w	r8,31
800086ae:	e0 89 00 10 	brgt	800086ce <_vfprintf_r+0xbce>
800086b2:	f2 ca ff fc 	sub	r10,r9,-4
800086b6:	51 0a       	stdsp	sp[0x40],r10
800086b8:	fa c6 f9 44 	sub	r6,sp,-1724
800086bc:	72 0a       	ld.w	r10,r9[0x0]
800086be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086c2:	f3 4a fd 88 	st.w	r9[-632],r10
800086c6:	2f f8       	sub	r8,-1
800086c8:	fb 48 06 b4 	st.w	sp[1716],r8
800086cc:	c0 48       	rjmp	800086d4 <_vfprintf_r+0xbd4>
800086ce:	72 0a       	ld.w	r10,r9[0x0]
800086d0:	2f c9       	sub	r9,-4
800086d2:	51 09       	stdsp	sp[0x40],r9
800086d4:	40 be       	lddsp	lr,sp[0x2c]
800086d6:	1c 98       	mov	r8,lr
800086d8:	95 1e       	st.w	r10[0x4],lr
800086da:	bf 58       	asr	r8,0x1f
800086dc:	95 08       	st.w	r10[0x0],r8
800086de:	fe 9f fa 9f 	bral	80007c1c <_vfprintf_r+0x11c>
800086e2:	ed b5 00 04 	bld	r5,0x4
800086e6:	c4 80       	breq	80008776 <_vfprintf_r+0xc76>
800086e8:	e2 15 00 40 	andl	r5,0x40,COH
800086ec:	c4 50       	breq	80008776 <_vfprintf_r+0xc76>
800086ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f2:	40 3c       	lddsp	r12,sp[0xc]
800086f4:	58 0c       	cp.w	r12,0
800086f6:	c1 d0       	breq	80008730 <_vfprintf_r+0xc30>
800086f8:	10 36       	cp.w	r6,r8
800086fa:	c0 64       	brge	80008706 <_vfprintf_r+0xc06>
800086fc:	fa cb f9 44 	sub	r11,sp,-1724
80008700:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008704:	c1 d8       	rjmp	8000873e <_vfprintf_r+0xc3e>
80008706:	fa c8 f9 50 	sub	r8,sp,-1712
8000870a:	1a d8       	st.w	--sp,r8
8000870c:	fa c8 fa b8 	sub	r8,sp,-1352
80008710:	04 9a       	mov	r10,r2
80008712:	1a d8       	st.w	--sp,r8
80008714:	fa c8 fb b4 	sub	r8,sp,-1100
80008718:	0c 9b       	mov	r11,r6
8000871a:	1a d8       	st.w	--sp,r8
8000871c:	08 9c       	mov	r12,r4
8000871e:	fa c8 f9 40 	sub	r8,sp,-1728
80008722:	fa c9 ff b4 	sub	r9,sp,-76
80008726:	fe b0 f8 55 	rcall	800077d0 <get_arg>
8000872a:	2f dd       	sub	sp,-12
8000872c:	78 0a       	ld.w	r10,r12[0x0]
8000872e:	c2 08       	rjmp	8000876e <_vfprintf_r+0xc6e>
80008730:	2f f7       	sub	r7,-1
80008732:	10 39       	cp.w	r9,r8
80008734:	c0 84       	brge	80008744 <_vfprintf_r+0xc44>
80008736:	fa ca f9 44 	sub	r10,sp,-1724
8000873a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000873e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008742:	c1 68       	rjmp	8000876e <_vfprintf_r+0xc6e>
80008744:	41 09       	lddsp	r9,sp[0x40]
80008746:	59 f8       	cp.w	r8,31
80008748:	e0 89 00 10 	brgt	80008768 <_vfprintf_r+0xc68>
8000874c:	f2 ca ff fc 	sub	r10,r9,-4
80008750:	51 0a       	stdsp	sp[0x40],r10
80008752:	fa c6 f9 44 	sub	r6,sp,-1724
80008756:	72 0a       	ld.w	r10,r9[0x0]
80008758:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000875c:	f3 4a fd 88 	st.w	r9[-632],r10
80008760:	2f f8       	sub	r8,-1
80008762:	fb 48 06 b4 	st.w	sp[1716],r8
80008766:	c0 48       	rjmp	8000876e <_vfprintf_r+0xc6e>
80008768:	72 0a       	ld.w	r10,r9[0x0]
8000876a:	2f c9       	sub	r9,-4
8000876c:	51 09       	stdsp	sp[0x40],r9
8000876e:	40 be       	lddsp	lr,sp[0x2c]
80008770:	b4 0e       	st.h	r10[0x0],lr
80008772:	fe 9f fa 55 	bral	80007c1c <_vfprintf_r+0x11c>
80008776:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000877a:	40 3c       	lddsp	r12,sp[0xc]
8000877c:	58 0c       	cp.w	r12,0
8000877e:	c1 d0       	breq	800087b8 <_vfprintf_r+0xcb8>
80008780:	10 36       	cp.w	r6,r8
80008782:	c0 64       	brge	8000878e <_vfprintf_r+0xc8e>
80008784:	fa cb f9 44 	sub	r11,sp,-1724
80008788:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000878c:	c1 d8       	rjmp	800087c6 <_vfprintf_r+0xcc6>
8000878e:	fa c8 f9 50 	sub	r8,sp,-1712
80008792:	1a d8       	st.w	--sp,r8
80008794:	fa c8 fa b8 	sub	r8,sp,-1352
80008798:	04 9a       	mov	r10,r2
8000879a:	1a d8       	st.w	--sp,r8
8000879c:	fa c8 fb b4 	sub	r8,sp,-1100
800087a0:	0c 9b       	mov	r11,r6
800087a2:	1a d8       	st.w	--sp,r8
800087a4:	08 9c       	mov	r12,r4
800087a6:	fa c8 f9 40 	sub	r8,sp,-1728
800087aa:	fa c9 ff b4 	sub	r9,sp,-76
800087ae:	fe b0 f8 11 	rcall	800077d0 <get_arg>
800087b2:	2f dd       	sub	sp,-12
800087b4:	78 0a       	ld.w	r10,r12[0x0]
800087b6:	c2 08       	rjmp	800087f6 <_vfprintf_r+0xcf6>
800087b8:	2f f7       	sub	r7,-1
800087ba:	10 39       	cp.w	r9,r8
800087bc:	c0 84       	brge	800087cc <_vfprintf_r+0xccc>
800087be:	fa ca f9 44 	sub	r10,sp,-1724
800087c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087c6:	ec fa fd 88 	ld.w	r10,r6[-632]
800087ca:	c1 68       	rjmp	800087f6 <_vfprintf_r+0xcf6>
800087cc:	41 09       	lddsp	r9,sp[0x40]
800087ce:	59 f8       	cp.w	r8,31
800087d0:	e0 89 00 10 	brgt	800087f0 <_vfprintf_r+0xcf0>
800087d4:	f2 ca ff fc 	sub	r10,r9,-4
800087d8:	51 0a       	stdsp	sp[0x40],r10
800087da:	fa c6 f9 44 	sub	r6,sp,-1724
800087de:	72 0a       	ld.w	r10,r9[0x0]
800087e0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087e4:	f3 4a fd 88 	st.w	r9[-632],r10
800087e8:	2f f8       	sub	r8,-1
800087ea:	fb 48 06 b4 	st.w	sp[1716],r8
800087ee:	c0 48       	rjmp	800087f6 <_vfprintf_r+0xcf6>
800087f0:	72 0a       	ld.w	r10,r9[0x0]
800087f2:	2f c9       	sub	r9,-4
800087f4:	51 09       	stdsp	sp[0x40],r9
800087f6:	40 be       	lddsp	lr,sp[0x2c]
800087f8:	95 0e       	st.w	r10[0x0],lr
800087fa:	fe 9f fa 11 	bral	80007c1c <_vfprintf_r+0x11c>
800087fe:	50 a7       	stdsp	sp[0x28],r7
80008800:	50 80       	stdsp	sp[0x20],r0
80008802:	0c 97       	mov	r7,r6
80008804:	04 94       	mov	r4,r2
80008806:	06 96       	mov	r6,r3
80008808:	02 92       	mov	r2,r1
8000880a:	40 93       	lddsp	r3,sp[0x24]
8000880c:	10 90       	mov	r0,r8
8000880e:	40 41       	lddsp	r1,sp[0x10]
80008810:	a5 a5       	sbr	r5,0x4
80008812:	c0 a8       	rjmp	80008826 <_vfprintf_r+0xd26>
80008814:	50 a7       	stdsp	sp[0x28],r7
80008816:	50 80       	stdsp	sp[0x20],r0
80008818:	0c 97       	mov	r7,r6
8000881a:	04 94       	mov	r4,r2
8000881c:	06 96       	mov	r6,r3
8000881e:	02 92       	mov	r2,r1
80008820:	40 93       	lddsp	r3,sp[0x24]
80008822:	10 90       	mov	r0,r8
80008824:	40 41       	lddsp	r1,sp[0x10]
80008826:	ed b5 00 05 	bld	r5,0x5
8000882a:	c5 d1       	brne	800088e4 <_vfprintf_r+0xde4>
8000882c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008830:	40 3c       	lddsp	r12,sp[0xc]
80008832:	58 0c       	cp.w	r12,0
80008834:	c2 60       	breq	80008880 <_vfprintf_r+0xd80>
80008836:	10 36       	cp.w	r6,r8
80008838:	c0 a4       	brge	8000884c <_vfprintf_r+0xd4c>
8000883a:	fa cb f9 44 	sub	r11,sp,-1724
8000883e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008842:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008846:	fa e9 00 00 	st.d	sp[0],r8
8000884a:	c1 88       	rjmp	8000887a <_vfprintf_r+0xd7a>
8000884c:	fa c8 f9 50 	sub	r8,sp,-1712
80008850:	1a d8       	st.w	--sp,r8
80008852:	fa c8 fa b8 	sub	r8,sp,-1352
80008856:	04 9a       	mov	r10,r2
80008858:	1a d8       	st.w	--sp,r8
8000885a:	0c 9b       	mov	r11,r6
8000885c:	fa c8 fb b4 	sub	r8,sp,-1100
80008860:	08 9c       	mov	r12,r4
80008862:	1a d8       	st.w	--sp,r8
80008864:	fa c8 f9 40 	sub	r8,sp,-1728
80008868:	fa c9 ff b4 	sub	r9,sp,-76
8000886c:	fe b0 f7 b2 	rcall	800077d0 <get_arg>
80008870:	2f dd       	sub	sp,-12
80008872:	f8 ea 00 00 	ld.d	r10,r12[0]
80008876:	fa eb 00 00 	st.d	sp[0],r10
8000887a:	30 08       	mov	r8,0
8000887c:	e0 8f 03 de 	bral	80009038 <_vfprintf_r+0x1538>
80008880:	ee ca ff ff 	sub	r10,r7,-1
80008884:	10 37       	cp.w	r7,r8
80008886:	c0 b4       	brge	8000889c <_vfprintf_r+0xd9c>
80008888:	fa c9 f9 44 	sub	r9,sp,-1724
8000888c:	14 97       	mov	r7,r10
8000888e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008892:	ec ea fd 88 	ld.d	r10,r6[-632]
80008896:	fa eb 00 00 	st.d	sp[0],r10
8000889a:	c1 88       	rjmp	800088ca <_vfprintf_r+0xdca>
8000889c:	41 09       	lddsp	r9,sp[0x40]
8000889e:	59 f8       	cp.w	r8,31
800088a0:	e0 89 00 18 	brgt	800088d0 <_vfprintf_r+0xdd0>
800088a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800088a8:	f2 cb ff f8 	sub	r11,r9,-8
800088ac:	fa e7 00 00 	st.d	sp[0],r6
800088b0:	51 0b       	stdsp	sp[0x40],r11
800088b2:	fa c6 f9 44 	sub	r6,sp,-1724
800088b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088ba:	fa e6 00 00 	ld.d	r6,sp[0]
800088be:	f2 e7 fd 88 	st.d	r9[-632],r6
800088c2:	2f f8       	sub	r8,-1
800088c4:	14 97       	mov	r7,r10
800088c6:	fb 48 06 b4 	st.w	sp[1716],r8
800088ca:	40 38       	lddsp	r8,sp[0xc]
800088cc:	e0 8f 03 b6 	bral	80009038 <_vfprintf_r+0x1538>
800088d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800088d4:	40 38       	lddsp	r8,sp[0xc]
800088d6:	fa e7 00 00 	st.d	sp[0],r6
800088da:	2f 89       	sub	r9,-8
800088dc:	14 97       	mov	r7,r10
800088de:	51 09       	stdsp	sp[0x40],r9
800088e0:	e0 8f 03 ac 	bral	80009038 <_vfprintf_r+0x1538>
800088e4:	ed b5 00 04 	bld	r5,0x4
800088e8:	c1 61       	brne	80008914 <_vfprintf_r+0xe14>
800088ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088ee:	40 3e       	lddsp	lr,sp[0xc]
800088f0:	58 0e       	cp.w	lr,0
800088f2:	c0 80       	breq	80008902 <_vfprintf_r+0xe02>
800088f4:	10 36       	cp.w	r6,r8
800088f6:	c6 74       	brge	800089c4 <_vfprintf_r+0xec4>
800088f8:	fa cc f9 44 	sub	r12,sp,-1724
800088fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008900:	c8 08       	rjmp	80008a00 <_vfprintf_r+0xf00>
80008902:	ee ca ff ff 	sub	r10,r7,-1
80008906:	10 37       	cp.w	r7,r8
80008908:	c7 f4       	brge	80008a06 <_vfprintf_r+0xf06>
8000890a:	fa cb f9 44 	sub	r11,sp,-1724
8000890e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008912:	c7 68       	rjmp	800089fe <_vfprintf_r+0xefe>
80008914:	ed b5 00 06 	bld	r5,0x6
80008918:	c4 a1       	brne	800089ac <_vfprintf_r+0xeac>
8000891a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000891e:	40 3c       	lddsp	r12,sp[0xc]
80008920:	58 0c       	cp.w	r12,0
80008922:	c1 d0       	breq	8000895c <_vfprintf_r+0xe5c>
80008924:	10 36       	cp.w	r6,r8
80008926:	c0 64       	brge	80008932 <_vfprintf_r+0xe32>
80008928:	fa cb f9 44 	sub	r11,sp,-1724
8000892c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008930:	c1 f8       	rjmp	8000896e <_vfprintf_r+0xe6e>
80008932:	fa c8 f9 50 	sub	r8,sp,-1712
80008936:	1a d8       	st.w	--sp,r8
80008938:	fa c8 fa b8 	sub	r8,sp,-1352
8000893c:	1a d8       	st.w	--sp,r8
8000893e:	fa c8 fb b4 	sub	r8,sp,-1100
80008942:	1a d8       	st.w	--sp,r8
80008944:	fa c8 f9 40 	sub	r8,sp,-1728
80008948:	fa c9 ff b4 	sub	r9,sp,-76
8000894c:	04 9a       	mov	r10,r2
8000894e:	0c 9b       	mov	r11,r6
80008950:	08 9c       	mov	r12,r4
80008952:	fe b0 f7 3f 	rcall	800077d0 <get_arg>
80008956:	2f dd       	sub	sp,-12
80008958:	98 18       	ld.sh	r8,r12[0x2]
8000895a:	c2 68       	rjmp	800089a6 <_vfprintf_r+0xea6>
8000895c:	ee ca ff ff 	sub	r10,r7,-1
80008960:	10 37       	cp.w	r7,r8
80008962:	c0 94       	brge	80008974 <_vfprintf_r+0xe74>
80008964:	fa c9 f9 44 	sub	r9,sp,-1724
80008968:	14 97       	mov	r7,r10
8000896a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000896e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008972:	c1 a8       	rjmp	800089a6 <_vfprintf_r+0xea6>
80008974:	41 09       	lddsp	r9,sp[0x40]
80008976:	59 f8       	cp.w	r8,31
80008978:	e0 89 00 13 	brgt	8000899e <_vfprintf_r+0xe9e>
8000897c:	f2 cb ff fc 	sub	r11,r9,-4
80008980:	51 0b       	stdsp	sp[0x40],r11
80008982:	72 09       	ld.w	r9,r9[0x0]
80008984:	fa c6 f9 44 	sub	r6,sp,-1724
80008988:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000898c:	2f f8       	sub	r8,-1
8000898e:	f7 49 fd 88 	st.w	r11[-632],r9
80008992:	fb 48 06 b4 	st.w	sp[1716],r8
80008996:	14 97       	mov	r7,r10
80008998:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000899c:	c0 58       	rjmp	800089a6 <_vfprintf_r+0xea6>
8000899e:	92 18       	ld.sh	r8,r9[0x2]
800089a0:	14 97       	mov	r7,r10
800089a2:	2f c9       	sub	r9,-4
800089a4:	51 09       	stdsp	sp[0x40],r9
800089a6:	5c 78       	castu.h	r8
800089a8:	50 18       	stdsp	sp[0x4],r8
800089aa:	c4 68       	rjmp	80008a36 <_vfprintf_r+0xf36>
800089ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089b0:	40 3c       	lddsp	r12,sp[0xc]
800089b2:	58 0c       	cp.w	r12,0
800089b4:	c1 d0       	breq	800089ee <_vfprintf_r+0xeee>
800089b6:	10 36       	cp.w	r6,r8
800089b8:	c0 64       	brge	800089c4 <_vfprintf_r+0xec4>
800089ba:	fa cb f9 44 	sub	r11,sp,-1724
800089be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089c2:	c1 f8       	rjmp	80008a00 <_vfprintf_r+0xf00>
800089c4:	fa c8 f9 50 	sub	r8,sp,-1712
800089c8:	1a d8       	st.w	--sp,r8
800089ca:	fa c8 fa b8 	sub	r8,sp,-1352
800089ce:	0c 9b       	mov	r11,r6
800089d0:	1a d8       	st.w	--sp,r8
800089d2:	fa c8 fb b4 	sub	r8,sp,-1100
800089d6:	04 9a       	mov	r10,r2
800089d8:	1a d8       	st.w	--sp,r8
800089da:	08 9c       	mov	r12,r4
800089dc:	fa c8 f9 40 	sub	r8,sp,-1728
800089e0:	fa c9 ff b4 	sub	r9,sp,-76
800089e4:	fe b0 f6 f6 	rcall	800077d0 <get_arg>
800089e8:	2f dd       	sub	sp,-12
800089ea:	78 0b       	ld.w	r11,r12[0x0]
800089ec:	c2 48       	rjmp	80008a34 <_vfprintf_r+0xf34>
800089ee:	ee ca ff ff 	sub	r10,r7,-1
800089f2:	10 37       	cp.w	r7,r8
800089f4:	c0 94       	brge	80008a06 <_vfprintf_r+0xf06>
800089f6:	fa c9 f9 44 	sub	r9,sp,-1724
800089fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089fe:	14 97       	mov	r7,r10
80008a00:	ec fb fd 88 	ld.w	r11,r6[-632]
80008a04:	c1 88       	rjmp	80008a34 <_vfprintf_r+0xf34>
80008a06:	41 09       	lddsp	r9,sp[0x40]
80008a08:	59 f8       	cp.w	r8,31
80008a0a:	e0 89 00 11 	brgt	80008a2c <_vfprintf_r+0xf2c>
80008a0e:	f2 cb ff fc 	sub	r11,r9,-4
80008a12:	51 0b       	stdsp	sp[0x40],r11
80008a14:	fa c6 f9 44 	sub	r6,sp,-1724
80008a18:	72 0b       	ld.w	r11,r9[0x0]
80008a1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a1e:	f3 4b fd 88 	st.w	r9[-632],r11
80008a22:	2f f8       	sub	r8,-1
80008a24:	14 97       	mov	r7,r10
80008a26:	fb 48 06 b4 	st.w	sp[1716],r8
80008a2a:	c0 58       	rjmp	80008a34 <_vfprintf_r+0xf34>
80008a2c:	72 0b       	ld.w	r11,r9[0x0]
80008a2e:	14 97       	mov	r7,r10
80008a30:	2f c9       	sub	r9,-4
80008a32:	51 09       	stdsp	sp[0x40],r9
80008a34:	50 1b       	stdsp	sp[0x4],r11
80008a36:	30 0e       	mov	lr,0
80008a38:	50 0e       	stdsp	sp[0x0],lr
80008a3a:	1c 98       	mov	r8,lr
80008a3c:	e0 8f 02 fe 	bral	80009038 <_vfprintf_r+0x1538>
80008a40:	50 a7       	stdsp	sp[0x28],r7
80008a42:	50 80       	stdsp	sp[0x20],r0
80008a44:	0c 97       	mov	r7,r6
80008a46:	04 94       	mov	r4,r2
80008a48:	06 96       	mov	r6,r3
80008a4a:	02 92       	mov	r2,r1
80008a4c:	40 93       	lddsp	r3,sp[0x24]
80008a4e:	40 41       	lddsp	r1,sp[0x10]
80008a50:	0e 99       	mov	r9,r7
80008a52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a56:	40 3c       	lddsp	r12,sp[0xc]
80008a58:	58 0c       	cp.w	r12,0
80008a5a:	c1 d0       	breq	80008a94 <_vfprintf_r+0xf94>
80008a5c:	10 36       	cp.w	r6,r8
80008a5e:	c0 64       	brge	80008a6a <_vfprintf_r+0xf6a>
80008a60:	fa cb f9 44 	sub	r11,sp,-1724
80008a64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a68:	c1 d8       	rjmp	80008aa2 <_vfprintf_r+0xfa2>
80008a6a:	fa c8 f9 50 	sub	r8,sp,-1712
80008a6e:	1a d8       	st.w	--sp,r8
80008a70:	fa c8 fa b8 	sub	r8,sp,-1352
80008a74:	1a d8       	st.w	--sp,r8
80008a76:	fa c8 fb b4 	sub	r8,sp,-1100
80008a7a:	1a d8       	st.w	--sp,r8
80008a7c:	fa c9 ff b4 	sub	r9,sp,-76
80008a80:	fa c8 f9 40 	sub	r8,sp,-1728
80008a84:	04 9a       	mov	r10,r2
80008a86:	0c 9b       	mov	r11,r6
80008a88:	08 9c       	mov	r12,r4
80008a8a:	fe b0 f6 a3 	rcall	800077d0 <get_arg>
80008a8e:	2f dd       	sub	sp,-12
80008a90:	78 09       	ld.w	r9,r12[0x0]
80008a92:	c2 18       	rjmp	80008ad4 <_vfprintf_r+0xfd4>
80008a94:	2f f7       	sub	r7,-1
80008a96:	10 39       	cp.w	r9,r8
80008a98:	c0 84       	brge	80008aa8 <_vfprintf_r+0xfa8>
80008a9a:	fa ca f9 44 	sub	r10,sp,-1724
80008a9e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008aa2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008aa6:	c1 78       	rjmp	80008ad4 <_vfprintf_r+0xfd4>
80008aa8:	41 09       	lddsp	r9,sp[0x40]
80008aaa:	59 f8       	cp.w	r8,31
80008aac:	e0 89 00 10 	brgt	80008acc <_vfprintf_r+0xfcc>
80008ab0:	f2 ca ff fc 	sub	r10,r9,-4
80008ab4:	51 0a       	stdsp	sp[0x40],r10
80008ab6:	fa c6 f9 44 	sub	r6,sp,-1724
80008aba:	72 09       	ld.w	r9,r9[0x0]
80008abc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008ac0:	f5 49 fd 88 	st.w	r10[-632],r9
80008ac4:	2f f8       	sub	r8,-1
80008ac6:	fb 48 06 b4 	st.w	sp[1716],r8
80008aca:	c0 58       	rjmp	80008ad4 <_vfprintf_r+0xfd4>
80008acc:	f2 c8 ff fc 	sub	r8,r9,-4
80008ad0:	51 08       	stdsp	sp[0x40],r8
80008ad2:	72 09       	ld.w	r9,r9[0x0]
80008ad4:	33 08       	mov	r8,48
80008ad6:	fb 68 06 b8 	st.b	sp[1720],r8
80008ada:	37 88       	mov	r8,120
80008adc:	30 0e       	mov	lr,0
80008ade:	fb 68 06 b9 	st.b	sp[1721],r8
80008ae2:	fe cc b2 6e 	sub	r12,pc,-19858
80008ae6:	50 19       	stdsp	sp[0x4],r9
80008ae8:	a1 b5       	sbr	r5,0x1
80008aea:	50 0e       	stdsp	sp[0x0],lr
80008aec:	50 dc       	stdsp	sp[0x34],r12
80008aee:	30 28       	mov	r8,2
80008af0:	37 80       	mov	r0,120
80008af2:	e0 8f 02 a3 	bral	80009038 <_vfprintf_r+0x1538>
80008af6:	50 a7       	stdsp	sp[0x28],r7
80008af8:	50 80       	stdsp	sp[0x20],r0
80008afa:	10 90       	mov	r0,r8
80008afc:	30 08       	mov	r8,0
80008afe:	fb 68 06 bb 	st.b	sp[1723],r8
80008b02:	0c 97       	mov	r7,r6
80008b04:	04 94       	mov	r4,r2
80008b06:	06 96       	mov	r6,r3
80008b08:	02 92       	mov	r2,r1
80008b0a:	40 93       	lddsp	r3,sp[0x24]
80008b0c:	40 41       	lddsp	r1,sp[0x10]
80008b0e:	0e 99       	mov	r9,r7
80008b10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b14:	40 3b       	lddsp	r11,sp[0xc]
80008b16:	58 0b       	cp.w	r11,0
80008b18:	c1 d0       	breq	80008b52 <_vfprintf_r+0x1052>
80008b1a:	10 36       	cp.w	r6,r8
80008b1c:	c0 64       	brge	80008b28 <_vfprintf_r+0x1028>
80008b1e:	fa ca f9 44 	sub	r10,sp,-1724
80008b22:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b26:	c1 d8       	rjmp	80008b60 <_vfprintf_r+0x1060>
80008b28:	fa c8 f9 50 	sub	r8,sp,-1712
80008b2c:	1a d8       	st.w	--sp,r8
80008b2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b32:	1a d8       	st.w	--sp,r8
80008b34:	fa c8 fb b4 	sub	r8,sp,-1100
80008b38:	0c 9b       	mov	r11,r6
80008b3a:	1a d8       	st.w	--sp,r8
80008b3c:	04 9a       	mov	r10,r2
80008b3e:	fa c8 f9 40 	sub	r8,sp,-1728
80008b42:	fa c9 ff b4 	sub	r9,sp,-76
80008b46:	08 9c       	mov	r12,r4
80008b48:	fe b0 f6 44 	rcall	800077d0 <get_arg>
80008b4c:	2f dd       	sub	sp,-12
80008b4e:	78 06       	ld.w	r6,r12[0x0]
80008b50:	c2 08       	rjmp	80008b90 <_vfprintf_r+0x1090>
80008b52:	2f f7       	sub	r7,-1
80008b54:	10 39       	cp.w	r9,r8
80008b56:	c0 84       	brge	80008b66 <_vfprintf_r+0x1066>
80008b58:	fa c9 f9 44 	sub	r9,sp,-1724
80008b5c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b60:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008b64:	c1 68       	rjmp	80008b90 <_vfprintf_r+0x1090>
80008b66:	41 09       	lddsp	r9,sp[0x40]
80008b68:	59 f8       	cp.w	r8,31
80008b6a:	e0 89 00 10 	brgt	80008b8a <_vfprintf_r+0x108a>
80008b6e:	f2 ca ff fc 	sub	r10,r9,-4
80008b72:	51 0a       	stdsp	sp[0x40],r10
80008b74:	72 06       	ld.w	r6,r9[0x0]
80008b76:	fa ce f9 44 	sub	lr,sp,-1724
80008b7a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008b7e:	f3 46 fd 88 	st.w	r9[-632],r6
80008b82:	2f f8       	sub	r8,-1
80008b84:	fb 48 06 b4 	st.w	sp[1716],r8
80008b88:	c0 48       	rjmp	80008b90 <_vfprintf_r+0x1090>
80008b8a:	72 06       	ld.w	r6,r9[0x0]
80008b8c:	2f c9       	sub	r9,-4
80008b8e:	51 09       	stdsp	sp[0x40],r9
80008b90:	40 2c       	lddsp	r12,sp[0x8]
80008b92:	58 0c       	cp.w	r12,0
80008b94:	c1 05       	brlt	80008bb4 <_vfprintf_r+0x10b4>
80008b96:	18 9a       	mov	r10,r12
80008b98:	30 0b       	mov	r11,0
80008b9a:	0c 9c       	mov	r12,r6
80008b9c:	e0 a0 12 38 	rcall	8000b00c <memchr>
80008ba0:	e0 80 02 df 	breq	8000915e <_vfprintf_r+0x165e>
80008ba4:	f8 06 01 02 	sub	r2,r12,r6
80008ba8:	40 2b       	lddsp	r11,sp[0x8]
80008baa:	16 32       	cp.w	r2,r11
80008bac:	e0 89 02 d9 	brgt	8000915e <_vfprintf_r+0x165e>
80008bb0:	e0 8f 02 d4 	bral	80009158 <_vfprintf_r+0x1658>
80008bb4:	30 0a       	mov	r10,0
80008bb6:	0c 9c       	mov	r12,r6
80008bb8:	50 2a       	stdsp	sp[0x8],r10
80008bba:	e0 a0 15 99 	rcall	8000b6ec <strlen>
80008bbe:	18 92       	mov	r2,r12
80008bc0:	e0 8f 02 d2 	bral	80009164 <_vfprintf_r+0x1664>
80008bc4:	50 a7       	stdsp	sp[0x28],r7
80008bc6:	50 80       	stdsp	sp[0x20],r0
80008bc8:	0c 97       	mov	r7,r6
80008bca:	04 94       	mov	r4,r2
80008bcc:	06 96       	mov	r6,r3
80008bce:	02 92       	mov	r2,r1
80008bd0:	40 93       	lddsp	r3,sp[0x24]
80008bd2:	10 90       	mov	r0,r8
80008bd4:	40 41       	lddsp	r1,sp[0x10]
80008bd6:	a5 a5       	sbr	r5,0x4
80008bd8:	c0 a8       	rjmp	80008bec <_vfprintf_r+0x10ec>
80008bda:	50 a7       	stdsp	sp[0x28],r7
80008bdc:	50 80       	stdsp	sp[0x20],r0
80008bde:	0c 97       	mov	r7,r6
80008be0:	04 94       	mov	r4,r2
80008be2:	06 96       	mov	r6,r3
80008be4:	02 92       	mov	r2,r1
80008be6:	40 93       	lddsp	r3,sp[0x24]
80008be8:	10 90       	mov	r0,r8
80008bea:	40 41       	lddsp	r1,sp[0x10]
80008bec:	ed b5 00 05 	bld	r5,0x5
80008bf0:	c5 61       	brne	80008c9c <_vfprintf_r+0x119c>
80008bf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bf6:	40 39       	lddsp	r9,sp[0xc]
80008bf8:	58 09       	cp.w	r9,0
80008bfa:	c2 10       	breq	80008c3c <_vfprintf_r+0x113c>
80008bfc:	10 36       	cp.w	r6,r8
80008bfe:	c0 74       	brge	80008c0c <_vfprintf_r+0x110c>
80008c00:	fa c8 f9 44 	sub	r8,sp,-1724
80008c04:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c08:	c2 38       	rjmp	80008c4e <_vfprintf_r+0x114e>
80008c0a:	d7 03       	nop
80008c0c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c10:	1a d8       	st.w	--sp,r8
80008c12:	fa c8 fa b8 	sub	r8,sp,-1352
80008c16:	1a d8       	st.w	--sp,r8
80008c18:	fa c8 fb b4 	sub	r8,sp,-1100
80008c1c:	1a d8       	st.w	--sp,r8
80008c1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008c22:	fa c9 ff b4 	sub	r9,sp,-76
80008c26:	04 9a       	mov	r10,r2
80008c28:	0c 9b       	mov	r11,r6
80008c2a:	08 9c       	mov	r12,r4
80008c2c:	fe b0 f5 d2 	rcall	800077d0 <get_arg>
80008c30:	2f dd       	sub	sp,-12
80008c32:	f8 e8 00 00 	ld.d	r8,r12[0]
80008c36:	fa e9 00 00 	st.d	sp[0],r8
80008c3a:	c2 e8       	rjmp	80008c96 <_vfprintf_r+0x1196>
80008c3c:	ee ca ff ff 	sub	r10,r7,-1
80008c40:	10 37       	cp.w	r7,r8
80008c42:	c0 b4       	brge	80008c58 <_vfprintf_r+0x1158>
80008c44:	fa c8 f9 44 	sub	r8,sp,-1724
80008c48:	14 97       	mov	r7,r10
80008c4a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c4e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c52:	fa eb 00 00 	st.d	sp[0],r10
80008c56:	c2 08       	rjmp	80008c96 <_vfprintf_r+0x1196>
80008c58:	41 09       	lddsp	r9,sp[0x40]
80008c5a:	59 f8       	cp.w	r8,31
80008c5c:	e0 89 00 16 	brgt	80008c88 <_vfprintf_r+0x1188>
80008c60:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c64:	f2 cb ff f8 	sub	r11,r9,-8
80008c68:	fa e7 00 00 	st.d	sp[0],r6
80008c6c:	51 0b       	stdsp	sp[0x40],r11
80008c6e:	fa c6 f9 44 	sub	r6,sp,-1724
80008c72:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c76:	fa e6 00 00 	ld.d	r6,sp[0]
80008c7a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c7e:	2f f8       	sub	r8,-1
80008c80:	14 97       	mov	r7,r10
80008c82:	fb 48 06 b4 	st.w	sp[1716],r8
80008c86:	c0 88       	rjmp	80008c96 <_vfprintf_r+0x1196>
80008c88:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c8c:	2f 89       	sub	r9,-8
80008c8e:	fa e7 00 00 	st.d	sp[0],r6
80008c92:	51 09       	stdsp	sp[0x40],r9
80008c94:	14 97       	mov	r7,r10
80008c96:	30 18       	mov	r8,1
80008c98:	e0 8f 01 d0 	bral	80009038 <_vfprintf_r+0x1538>
80008c9c:	ed b5 00 04 	bld	r5,0x4
80008ca0:	c1 61       	brne	80008ccc <_vfprintf_r+0x11cc>
80008ca2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ca6:	40 3e       	lddsp	lr,sp[0xc]
80008ca8:	58 0e       	cp.w	lr,0
80008caa:	c0 80       	breq	80008cba <_vfprintf_r+0x11ba>
80008cac:	10 36       	cp.w	r6,r8
80008cae:	c6 74       	brge	80008d7c <_vfprintf_r+0x127c>
80008cb0:	fa cc f9 44 	sub	r12,sp,-1724
80008cb4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cb8:	c8 08       	rjmp	80008db8 <_vfprintf_r+0x12b8>
80008cba:	ee ca ff ff 	sub	r10,r7,-1
80008cbe:	10 37       	cp.w	r7,r8
80008cc0:	c7 f4       	brge	80008dbe <_vfprintf_r+0x12be>
80008cc2:	fa cb f9 44 	sub	r11,sp,-1724
80008cc6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cca:	c7 68       	rjmp	80008db6 <_vfprintf_r+0x12b6>
80008ccc:	ed b5 00 06 	bld	r5,0x6
80008cd0:	c4 a1       	brne	80008d64 <_vfprintf_r+0x1264>
80008cd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cd6:	40 3c       	lddsp	r12,sp[0xc]
80008cd8:	58 0c       	cp.w	r12,0
80008cda:	c1 d0       	breq	80008d14 <_vfprintf_r+0x1214>
80008cdc:	10 36       	cp.w	r6,r8
80008cde:	c0 64       	brge	80008cea <_vfprintf_r+0x11ea>
80008ce0:	fa cb f9 44 	sub	r11,sp,-1724
80008ce4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ce8:	c1 f8       	rjmp	80008d26 <_vfprintf_r+0x1226>
80008cea:	fa c8 f9 50 	sub	r8,sp,-1712
80008cee:	1a d8       	st.w	--sp,r8
80008cf0:	fa c8 fa b8 	sub	r8,sp,-1352
80008cf4:	1a d8       	st.w	--sp,r8
80008cf6:	fa c8 fb b4 	sub	r8,sp,-1100
80008cfa:	1a d8       	st.w	--sp,r8
80008cfc:	fa c8 f9 40 	sub	r8,sp,-1728
80008d00:	fa c9 ff b4 	sub	r9,sp,-76
80008d04:	04 9a       	mov	r10,r2
80008d06:	0c 9b       	mov	r11,r6
80008d08:	08 9c       	mov	r12,r4
80008d0a:	fe b0 f5 63 	rcall	800077d0 <get_arg>
80008d0e:	2f dd       	sub	sp,-12
80008d10:	98 18       	ld.sh	r8,r12[0x2]
80008d12:	c2 68       	rjmp	80008d5e <_vfprintf_r+0x125e>
80008d14:	ee ca ff ff 	sub	r10,r7,-1
80008d18:	10 37       	cp.w	r7,r8
80008d1a:	c0 94       	brge	80008d2c <_vfprintf_r+0x122c>
80008d1c:	fa c9 f9 44 	sub	r9,sp,-1724
80008d20:	14 97       	mov	r7,r10
80008d22:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d26:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d2a:	c1 a8       	rjmp	80008d5e <_vfprintf_r+0x125e>
80008d2c:	41 09       	lddsp	r9,sp[0x40]
80008d2e:	59 f8       	cp.w	r8,31
80008d30:	e0 89 00 13 	brgt	80008d56 <_vfprintf_r+0x1256>
80008d34:	f2 cb ff fc 	sub	r11,r9,-4
80008d38:	51 0b       	stdsp	sp[0x40],r11
80008d3a:	72 09       	ld.w	r9,r9[0x0]
80008d3c:	fa c6 f9 44 	sub	r6,sp,-1724
80008d40:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d44:	2f f8       	sub	r8,-1
80008d46:	f7 49 fd 88 	st.w	r11[-632],r9
80008d4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d4e:	14 97       	mov	r7,r10
80008d50:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d54:	c0 58       	rjmp	80008d5e <_vfprintf_r+0x125e>
80008d56:	92 18       	ld.sh	r8,r9[0x2]
80008d58:	14 97       	mov	r7,r10
80008d5a:	2f c9       	sub	r9,-4
80008d5c:	51 09       	stdsp	sp[0x40],r9
80008d5e:	5c 78       	castu.h	r8
80008d60:	50 18       	stdsp	sp[0x4],r8
80008d62:	c4 68       	rjmp	80008dee <_vfprintf_r+0x12ee>
80008d64:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d68:	40 3c       	lddsp	r12,sp[0xc]
80008d6a:	58 0c       	cp.w	r12,0
80008d6c:	c1 d0       	breq	80008da6 <_vfprintf_r+0x12a6>
80008d6e:	10 36       	cp.w	r6,r8
80008d70:	c0 64       	brge	80008d7c <_vfprintf_r+0x127c>
80008d72:	fa cb f9 44 	sub	r11,sp,-1724
80008d76:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d7a:	c1 f8       	rjmp	80008db8 <_vfprintf_r+0x12b8>
80008d7c:	fa c8 f9 50 	sub	r8,sp,-1712
80008d80:	1a d8       	st.w	--sp,r8
80008d82:	fa c8 fa b8 	sub	r8,sp,-1352
80008d86:	0c 9b       	mov	r11,r6
80008d88:	1a d8       	st.w	--sp,r8
80008d8a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d8e:	04 9a       	mov	r10,r2
80008d90:	1a d8       	st.w	--sp,r8
80008d92:	08 9c       	mov	r12,r4
80008d94:	fa c8 f9 40 	sub	r8,sp,-1728
80008d98:	fa c9 ff b4 	sub	r9,sp,-76
80008d9c:	fe b0 f5 1a 	rcall	800077d0 <get_arg>
80008da0:	2f dd       	sub	sp,-12
80008da2:	78 0b       	ld.w	r11,r12[0x0]
80008da4:	c2 48       	rjmp	80008dec <_vfprintf_r+0x12ec>
80008da6:	ee ca ff ff 	sub	r10,r7,-1
80008daa:	10 37       	cp.w	r7,r8
80008dac:	c0 94       	brge	80008dbe <_vfprintf_r+0x12be>
80008dae:	fa c9 f9 44 	sub	r9,sp,-1724
80008db2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008db6:	14 97       	mov	r7,r10
80008db8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008dbc:	c1 88       	rjmp	80008dec <_vfprintf_r+0x12ec>
80008dbe:	41 09       	lddsp	r9,sp[0x40]
80008dc0:	59 f8       	cp.w	r8,31
80008dc2:	e0 89 00 11 	brgt	80008de4 <_vfprintf_r+0x12e4>
80008dc6:	f2 cb ff fc 	sub	r11,r9,-4
80008dca:	51 0b       	stdsp	sp[0x40],r11
80008dcc:	fa c6 f9 44 	sub	r6,sp,-1724
80008dd0:	72 0b       	ld.w	r11,r9[0x0]
80008dd2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dd6:	f3 4b fd 88 	st.w	r9[-632],r11
80008dda:	2f f8       	sub	r8,-1
80008ddc:	14 97       	mov	r7,r10
80008dde:	fb 48 06 b4 	st.w	sp[1716],r8
80008de2:	c0 58       	rjmp	80008dec <_vfprintf_r+0x12ec>
80008de4:	72 0b       	ld.w	r11,r9[0x0]
80008de6:	14 97       	mov	r7,r10
80008de8:	2f c9       	sub	r9,-4
80008dea:	51 09       	stdsp	sp[0x40],r9
80008dec:	50 1b       	stdsp	sp[0x4],r11
80008dee:	30 0e       	mov	lr,0
80008df0:	30 18       	mov	r8,1
80008df2:	50 0e       	stdsp	sp[0x0],lr
80008df4:	c2 29       	rjmp	80009038 <_vfprintf_r+0x1538>
80008df6:	50 a7       	stdsp	sp[0x28],r7
80008df8:	50 80       	stdsp	sp[0x20],r0
80008dfa:	0c 97       	mov	r7,r6
80008dfc:	04 94       	mov	r4,r2
80008dfe:	06 96       	mov	r6,r3
80008e00:	02 92       	mov	r2,r1
80008e02:	fe cc b5 8e 	sub	r12,pc,-19058
80008e06:	40 93       	lddsp	r3,sp[0x24]
80008e08:	10 90       	mov	r0,r8
80008e0a:	40 41       	lddsp	r1,sp[0x10]
80008e0c:	50 dc       	stdsp	sp[0x34],r12
80008e0e:	ed b5 00 05 	bld	r5,0x5
80008e12:	c5 51       	brne	80008ebc <_vfprintf_r+0x13bc>
80008e14:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e18:	40 3b       	lddsp	r11,sp[0xc]
80008e1a:	58 0b       	cp.w	r11,0
80008e1c:	c2 20       	breq	80008e60 <_vfprintf_r+0x1360>
80008e1e:	10 36       	cp.w	r6,r8
80008e20:	c0 a4       	brge	80008e34 <_vfprintf_r+0x1334>
80008e22:	fa ca f9 44 	sub	r10,sp,-1724
80008e26:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e2a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e2e:	fa e9 00 00 	st.d	sp[0],r8
80008e32:	cf 28       	rjmp	80009016 <_vfprintf_r+0x1516>
80008e34:	fa c8 f9 50 	sub	r8,sp,-1712
80008e38:	1a d8       	st.w	--sp,r8
80008e3a:	fa c8 fa b8 	sub	r8,sp,-1352
80008e3e:	04 9a       	mov	r10,r2
80008e40:	1a d8       	st.w	--sp,r8
80008e42:	0c 9b       	mov	r11,r6
80008e44:	fa c8 fb b4 	sub	r8,sp,-1100
80008e48:	08 9c       	mov	r12,r4
80008e4a:	1a d8       	st.w	--sp,r8
80008e4c:	fa c8 f9 40 	sub	r8,sp,-1728
80008e50:	fa c9 ff b4 	sub	r9,sp,-76
80008e54:	fe b0 f4 be 	rcall	800077d0 <get_arg>
80008e58:	2f dd       	sub	sp,-12
80008e5a:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e5e:	c0 c8       	rjmp	80008e76 <_vfprintf_r+0x1376>
80008e60:	ee ca ff ff 	sub	r10,r7,-1
80008e64:	10 37       	cp.w	r7,r8
80008e66:	c0 b4       	brge	80008e7c <_vfprintf_r+0x137c>
80008e68:	fa c9 f9 44 	sub	r9,sp,-1724
80008e6c:	14 97       	mov	r7,r10
80008e6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e72:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e76:	fa eb 00 00 	st.d	sp[0],r10
80008e7a:	cc e8       	rjmp	80009016 <_vfprintf_r+0x1516>
80008e7c:	41 09       	lddsp	r9,sp[0x40]
80008e7e:	59 f8       	cp.w	r8,31
80008e80:	e0 89 00 16 	brgt	80008eac <_vfprintf_r+0x13ac>
80008e84:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e88:	f2 cb ff f8 	sub	r11,r9,-8
80008e8c:	fa e7 00 00 	st.d	sp[0],r6
80008e90:	51 0b       	stdsp	sp[0x40],r11
80008e92:	fa c6 f9 44 	sub	r6,sp,-1724
80008e96:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e9a:	fa e6 00 00 	ld.d	r6,sp[0]
80008e9e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ea2:	2f f8       	sub	r8,-1
80008ea4:	14 97       	mov	r7,r10
80008ea6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eaa:	cb 68       	rjmp	80009016 <_vfprintf_r+0x1516>
80008eac:	f2 e6 00 00 	ld.d	r6,r9[0]
80008eb0:	2f 89       	sub	r9,-8
80008eb2:	fa e7 00 00 	st.d	sp[0],r6
80008eb6:	51 09       	stdsp	sp[0x40],r9
80008eb8:	14 97       	mov	r7,r10
80008eba:	ca e8       	rjmp	80009016 <_vfprintf_r+0x1516>
80008ebc:	ed b5 00 04 	bld	r5,0x4
80008ec0:	c1 71       	brne	80008eee <_vfprintf_r+0x13ee>
80008ec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ec6:	40 3e       	lddsp	lr,sp[0xc]
80008ec8:	58 0e       	cp.w	lr,0
80008eca:	c0 80       	breq	80008eda <_vfprintf_r+0x13da>
80008ecc:	10 36       	cp.w	r6,r8
80008ece:	c6 94       	brge	80008fa0 <_vfprintf_r+0x14a0>
80008ed0:	fa cc f9 44 	sub	r12,sp,-1724
80008ed4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ed8:	c8 28       	rjmp	80008fdc <_vfprintf_r+0x14dc>
80008eda:	ee ca ff ff 	sub	r10,r7,-1
80008ede:	10 37       	cp.w	r7,r8
80008ee0:	e0 84 00 81 	brge	80008fe2 <_vfprintf_r+0x14e2>
80008ee4:	fa cb f9 44 	sub	r11,sp,-1724
80008ee8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eec:	c7 78       	rjmp	80008fda <_vfprintf_r+0x14da>
80008eee:	ed b5 00 06 	bld	r5,0x6
80008ef2:	c4 b1       	brne	80008f88 <_vfprintf_r+0x1488>
80008ef4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ef8:	40 3c       	lddsp	r12,sp[0xc]
80008efa:	58 0c       	cp.w	r12,0
80008efc:	c1 d0       	breq	80008f36 <_vfprintf_r+0x1436>
80008efe:	10 36       	cp.w	r6,r8
80008f00:	c0 64       	brge	80008f0c <_vfprintf_r+0x140c>
80008f02:	fa cb f9 44 	sub	r11,sp,-1724
80008f06:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f0a:	c1 f8       	rjmp	80008f48 <_vfprintf_r+0x1448>
80008f0c:	fa c8 f9 50 	sub	r8,sp,-1712
80008f10:	1a d8       	st.w	--sp,r8
80008f12:	fa c8 fa b8 	sub	r8,sp,-1352
80008f16:	1a d8       	st.w	--sp,r8
80008f18:	fa c8 fb b4 	sub	r8,sp,-1100
80008f1c:	1a d8       	st.w	--sp,r8
80008f1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008f22:	fa c9 ff b4 	sub	r9,sp,-76
80008f26:	04 9a       	mov	r10,r2
80008f28:	0c 9b       	mov	r11,r6
80008f2a:	08 9c       	mov	r12,r4
80008f2c:	fe b0 f4 52 	rcall	800077d0 <get_arg>
80008f30:	2f dd       	sub	sp,-12
80008f32:	98 18       	ld.sh	r8,r12[0x2]
80008f34:	c2 78       	rjmp	80008f82 <_vfprintf_r+0x1482>
80008f36:	ee ca ff ff 	sub	r10,r7,-1
80008f3a:	10 37       	cp.w	r7,r8
80008f3c:	c0 a4       	brge	80008f50 <_vfprintf_r+0x1450>
80008f3e:	fa c9 f9 44 	sub	r9,sp,-1724
80008f42:	14 97       	mov	r7,r10
80008f44:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f48:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f4c:	c1 b8       	rjmp	80008f82 <_vfprintf_r+0x1482>
80008f4e:	d7 03       	nop
80008f50:	41 09       	lddsp	r9,sp[0x40]
80008f52:	59 f8       	cp.w	r8,31
80008f54:	e0 89 00 13 	brgt	80008f7a <_vfprintf_r+0x147a>
80008f58:	f2 cb ff fc 	sub	r11,r9,-4
80008f5c:	51 0b       	stdsp	sp[0x40],r11
80008f5e:	72 09       	ld.w	r9,r9[0x0]
80008f60:	fa c6 f9 44 	sub	r6,sp,-1724
80008f64:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f68:	2f f8       	sub	r8,-1
80008f6a:	f7 49 fd 88 	st.w	r11[-632],r9
80008f6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f72:	14 97       	mov	r7,r10
80008f74:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f78:	c0 58       	rjmp	80008f82 <_vfprintf_r+0x1482>
80008f7a:	92 18       	ld.sh	r8,r9[0x2]
80008f7c:	14 97       	mov	r7,r10
80008f7e:	2f c9       	sub	r9,-4
80008f80:	51 09       	stdsp	sp[0x40],r9
80008f82:	5c 78       	castu.h	r8
80008f84:	50 18       	stdsp	sp[0x4],r8
80008f86:	c4 68       	rjmp	80009012 <_vfprintf_r+0x1512>
80008f88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f8c:	40 3c       	lddsp	r12,sp[0xc]
80008f8e:	58 0c       	cp.w	r12,0
80008f90:	c1 d0       	breq	80008fca <_vfprintf_r+0x14ca>
80008f92:	10 36       	cp.w	r6,r8
80008f94:	c0 64       	brge	80008fa0 <_vfprintf_r+0x14a0>
80008f96:	fa cb f9 44 	sub	r11,sp,-1724
80008f9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f9e:	c1 f8       	rjmp	80008fdc <_vfprintf_r+0x14dc>
80008fa0:	fa c8 f9 50 	sub	r8,sp,-1712
80008fa4:	1a d8       	st.w	--sp,r8
80008fa6:	fa c8 fa b8 	sub	r8,sp,-1352
80008faa:	0c 9b       	mov	r11,r6
80008fac:	1a d8       	st.w	--sp,r8
80008fae:	fa c8 fb b4 	sub	r8,sp,-1100
80008fb2:	04 9a       	mov	r10,r2
80008fb4:	1a d8       	st.w	--sp,r8
80008fb6:	08 9c       	mov	r12,r4
80008fb8:	fa c8 f9 40 	sub	r8,sp,-1728
80008fbc:	fa c9 ff b4 	sub	r9,sp,-76
80008fc0:	fe b0 f4 08 	rcall	800077d0 <get_arg>
80008fc4:	2f dd       	sub	sp,-12
80008fc6:	78 0b       	ld.w	r11,r12[0x0]
80008fc8:	c2 48       	rjmp	80009010 <_vfprintf_r+0x1510>
80008fca:	ee ca ff ff 	sub	r10,r7,-1
80008fce:	10 37       	cp.w	r7,r8
80008fd0:	c0 94       	brge	80008fe2 <_vfprintf_r+0x14e2>
80008fd2:	fa c9 f9 44 	sub	r9,sp,-1724
80008fd6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fda:	14 97       	mov	r7,r10
80008fdc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fe0:	c1 88       	rjmp	80009010 <_vfprintf_r+0x1510>
80008fe2:	41 09       	lddsp	r9,sp[0x40]
80008fe4:	59 f8       	cp.w	r8,31
80008fe6:	e0 89 00 11 	brgt	80009008 <_vfprintf_r+0x1508>
80008fea:	f2 cb ff fc 	sub	r11,r9,-4
80008fee:	51 0b       	stdsp	sp[0x40],r11
80008ff0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ff4:	72 0b       	ld.w	r11,r9[0x0]
80008ff6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ffa:	f3 4b fd 88 	st.w	r9[-632],r11
80008ffe:	2f f8       	sub	r8,-1
80009000:	14 97       	mov	r7,r10
80009002:	fb 48 06 b4 	st.w	sp[1716],r8
80009006:	c0 58       	rjmp	80009010 <_vfprintf_r+0x1510>
80009008:	72 0b       	ld.w	r11,r9[0x0]
8000900a:	14 97       	mov	r7,r10
8000900c:	2f c9       	sub	r9,-4
8000900e:	51 09       	stdsp	sp[0x40],r9
80009010:	50 1b       	stdsp	sp[0x4],r11
80009012:	30 0e       	mov	lr,0
80009014:	50 0e       	stdsp	sp[0x0],lr
80009016:	40 08       	lddsp	r8,sp[0x0]
80009018:	40 1c       	lddsp	r12,sp[0x4]
8000901a:	18 48       	or	r8,r12
8000901c:	5f 19       	srne	r9
8000901e:	0a 98       	mov	r8,r5
80009020:	eb e9 00 09 	and	r9,r5,r9
80009024:	a1 b8       	sbr	r8,0x1
80009026:	58 09       	cp.w	r9,0
80009028:	c0 70       	breq	80009036 <_vfprintf_r+0x1536>
8000902a:	10 95       	mov	r5,r8
8000902c:	fb 60 06 b9 	st.b	sp[1721],r0
80009030:	33 08       	mov	r8,48
80009032:	fb 68 06 b8 	st.b	sp[1720],r8
80009036:	30 28       	mov	r8,2
80009038:	30 09       	mov	r9,0
8000903a:	fb 69 06 bb 	st.b	sp[1723],r9
8000903e:	0a 99       	mov	r9,r5
80009040:	a7 d9       	cbr	r9,0x7
80009042:	40 2b       	lddsp	r11,sp[0x8]
80009044:	40 16       	lddsp	r6,sp[0x4]
80009046:	58 0b       	cp.w	r11,0
80009048:	5f 1a       	srne	r10
8000904a:	f2 05 17 40 	movge	r5,r9
8000904e:	fa c2 f9 78 	sub	r2,sp,-1672
80009052:	40 09       	lddsp	r9,sp[0x0]
80009054:	0c 49       	or	r9,r6
80009056:	5f 19       	srne	r9
80009058:	f5 e9 10 09 	or	r9,r10,r9
8000905c:	c5 c0       	breq	80009114 <_vfprintf_r+0x1614>
8000905e:	30 19       	mov	r9,1
80009060:	f2 08 18 00 	cp.b	r8,r9
80009064:	c0 60       	breq	80009070 <_vfprintf_r+0x1570>
80009066:	30 29       	mov	r9,2
80009068:	f2 08 18 00 	cp.b	r8,r9
8000906c:	c0 41       	brne	80009074 <_vfprintf_r+0x1574>
8000906e:	c3 c8       	rjmp	800090e6 <_vfprintf_r+0x15e6>
80009070:	04 96       	mov	r6,r2
80009072:	c3 08       	rjmp	800090d2 <_vfprintf_r+0x15d2>
80009074:	04 96       	mov	r6,r2
80009076:	fa e8 00 00 	ld.d	r8,sp[0]
8000907a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000907e:	2d 0a       	sub	r10,-48
80009080:	0c fa       	st.b	--r6,r10
80009082:	f0 0b 16 03 	lsr	r11,r8,0x3
80009086:	f2 0c 16 03 	lsr	r12,r9,0x3
8000908a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000908e:	18 99       	mov	r9,r12
80009090:	16 98       	mov	r8,r11
80009092:	58 08       	cp.w	r8,0
80009094:	5c 29       	cpc	r9
80009096:	cf 21       	brne	8000907a <_vfprintf_r+0x157a>
80009098:	fa e9 00 00 	st.d	sp[0],r8
8000909c:	ed b5 00 00 	bld	r5,0x0
800090a0:	c4 51       	brne	8000912a <_vfprintf_r+0x162a>
800090a2:	33 09       	mov	r9,48
800090a4:	f2 0a 18 00 	cp.b	r10,r9
800090a8:	c4 10       	breq	8000912a <_vfprintf_r+0x162a>
800090aa:	0c f9       	st.b	--r6,r9
800090ac:	c3 f8       	rjmp	8000912a <_vfprintf_r+0x162a>
800090ae:	fa ea 00 00 	ld.d	r10,sp[0]
800090b2:	30 a8       	mov	r8,10
800090b4:	30 09       	mov	r9,0
800090b6:	e0 a0 1a 19 	rcall	8000c4e8 <__avr32_umod64>
800090ba:	30 a8       	mov	r8,10
800090bc:	2d 0a       	sub	r10,-48
800090be:	30 09       	mov	r9,0
800090c0:	ac 8a       	st.b	r6[0x0],r10
800090c2:	fa ea 00 00 	ld.d	r10,sp[0]
800090c6:	e0 a0 18 df 	rcall	8000c284 <__avr32_udiv64>
800090ca:	16 99       	mov	r9,r11
800090cc:	14 98       	mov	r8,r10
800090ce:	fa e9 00 00 	st.d	sp[0],r8
800090d2:	20 16       	sub	r6,1
800090d4:	fa ea 00 00 	ld.d	r10,sp[0]
800090d8:	58 9a       	cp.w	r10,9
800090da:	5c 2b       	cpc	r11
800090dc:	fe 9b ff e9 	brhi	800090ae <_vfprintf_r+0x15ae>
800090e0:	1b f8       	ld.ub	r8,sp[0x7]
800090e2:	2d 08       	sub	r8,-48
800090e4:	c2 08       	rjmp	80009124 <_vfprintf_r+0x1624>
800090e6:	04 96       	mov	r6,r2
800090e8:	fa e8 00 00 	ld.d	r8,sp[0]
800090ec:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800090f0:	40 de       	lddsp	lr,sp[0x34]
800090f2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800090f6:	0c fa       	st.b	--r6,r10
800090f8:	f2 0b 16 04 	lsr	r11,r9,0x4
800090fc:	f0 0a 16 04 	lsr	r10,r8,0x4
80009100:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009104:	16 99       	mov	r9,r11
80009106:	14 98       	mov	r8,r10
80009108:	58 08       	cp.w	r8,0
8000910a:	5c 29       	cpc	r9
8000910c:	cf 01       	brne	800090ec <_vfprintf_r+0x15ec>
8000910e:	fa e9 00 00 	st.d	sp[0],r8
80009112:	c0 c8       	rjmp	8000912a <_vfprintf_r+0x162a>
80009114:	58 08       	cp.w	r8,0
80009116:	c0 91       	brne	80009128 <_vfprintf_r+0x1628>
80009118:	ed b5 00 00 	bld	r5,0x0
8000911c:	c0 61       	brne	80009128 <_vfprintf_r+0x1628>
8000911e:	fa c6 f9 79 	sub	r6,sp,-1671
80009122:	33 08       	mov	r8,48
80009124:	ac 88       	st.b	r6[0x0],r8
80009126:	c0 28       	rjmp	8000912a <_vfprintf_r+0x162a>
80009128:	04 96       	mov	r6,r2
8000912a:	0c 12       	sub	r2,r6
8000912c:	c1 c8       	rjmp	80009164 <_vfprintf_r+0x1664>
8000912e:	50 a7       	stdsp	sp[0x28],r7
80009130:	50 80       	stdsp	sp[0x20],r0
80009132:	40 93       	lddsp	r3,sp[0x24]
80009134:	0c 97       	mov	r7,r6
80009136:	10 90       	mov	r0,r8
80009138:	04 94       	mov	r4,r2
8000913a:	40 41       	lddsp	r1,sp[0x10]
8000913c:	58 08       	cp.w	r8,0
8000913e:	e0 80 04 4f 	breq	800099dc <_vfprintf_r+0x1edc>
80009142:	fb 68 06 60 	st.b	sp[1632],r8
80009146:	30 0c       	mov	r12,0
80009148:	30 08       	mov	r8,0
8000914a:	30 12       	mov	r2,1
8000914c:	fb 68 06 bb 	st.b	sp[1723],r8
80009150:	50 2c       	stdsp	sp[0x8],r12
80009152:	fa c6 f9 a0 	sub	r6,sp,-1632
80009156:	c0 78       	rjmp	80009164 <_vfprintf_r+0x1664>
80009158:	30 0b       	mov	r11,0
8000915a:	50 2b       	stdsp	sp[0x8],r11
8000915c:	c0 48       	rjmp	80009164 <_vfprintf_r+0x1664>
8000915e:	40 22       	lddsp	r2,sp[0x8]
80009160:	30 0a       	mov	r10,0
80009162:	50 2a       	stdsp	sp[0x8],r10
80009164:	40 29       	lddsp	r9,sp[0x8]
80009166:	e4 09 0c 49 	max	r9,r2,r9
8000916a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000916e:	50 39       	stdsp	sp[0xc],r9
80009170:	0a 9e       	mov	lr,r5
80009172:	30 09       	mov	r9,0
80009174:	e2 1e 00 02 	andl	lr,0x2,COH
80009178:	f2 08 18 00 	cp.b	r8,r9
8000917c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009180:	f7 b8 01 ff 	subne	r8,-1
80009184:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009188:	0a 9b       	mov	r11,r5
8000918a:	58 0e       	cp.w	lr,0
8000918c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009190:	f7 bc 01 fe 	subne	r12,-2
80009194:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009198:	e2 1b 00 84 	andl	r11,0x84,COH
8000919c:	50 fe       	stdsp	sp[0x3c],lr
8000919e:	50 9b       	stdsp	sp[0x24],r11
800091a0:	c4 71       	brne	8000922e <_vfprintf_r+0x172e>
800091a2:	40 8a       	lddsp	r10,sp[0x20]
800091a4:	40 39       	lddsp	r9,sp[0xc]
800091a6:	12 1a       	sub	r10,r9
800091a8:	50 4a       	stdsp	sp[0x10],r10
800091aa:	58 0a       	cp.w	r10,0
800091ac:	e0 89 00 20 	brgt	800091ec <_vfprintf_r+0x16ec>
800091b0:	c3 f8       	rjmp	8000922e <_vfprintf_r+0x172e>
800091b2:	2f 09       	sub	r9,-16
800091b4:	2f f8       	sub	r8,-1
800091b6:	fe ce b9 2a 	sub	lr,pc,-18134
800091ba:	31 0c       	mov	r12,16
800091bc:	fb 49 06 90 	st.w	sp[1680],r9
800091c0:	87 0e       	st.w	r3[0x0],lr
800091c2:	87 1c       	st.w	r3[0x4],r12
800091c4:	fb 48 06 8c 	st.w	sp[1676],r8
800091c8:	58 78       	cp.w	r8,7
800091ca:	e0 89 00 04 	brgt	800091d2 <_vfprintf_r+0x16d2>
800091ce:	2f 83       	sub	r3,-8
800091d0:	c0 b8       	rjmp	800091e6 <_vfprintf_r+0x16e6>
800091d2:	fa ca f9 78 	sub	r10,sp,-1672
800091d6:	02 9b       	mov	r11,r1
800091d8:	08 9c       	mov	r12,r4
800091da:	fe b0 f4 85 	rcall	80007ae4 <__sprint_r>
800091de:	e0 81 04 10 	brne	800099fe <_vfprintf_r+0x1efe>
800091e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800091e6:	40 4b       	lddsp	r11,sp[0x10]
800091e8:	21 0b       	sub	r11,16
800091ea:	50 4b       	stdsp	sp[0x10],r11
800091ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800091f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091f4:	fe ca b9 68 	sub	r10,pc,-18072
800091f8:	40 4e       	lddsp	lr,sp[0x10]
800091fa:	59 0e       	cp.w	lr,16
800091fc:	fe 99 ff db 	brgt	800091b2 <_vfprintf_r+0x16b2>
80009200:	1c 09       	add	r9,lr
80009202:	2f f8       	sub	r8,-1
80009204:	87 0a       	st.w	r3[0x0],r10
80009206:	fb 49 06 90 	st.w	sp[1680],r9
8000920a:	87 1e       	st.w	r3[0x4],lr
8000920c:	fb 48 06 8c 	st.w	sp[1676],r8
80009210:	58 78       	cp.w	r8,7
80009212:	e0 89 00 04 	brgt	8000921a <_vfprintf_r+0x171a>
80009216:	2f 83       	sub	r3,-8
80009218:	c0 b8       	rjmp	8000922e <_vfprintf_r+0x172e>
8000921a:	fa ca f9 78 	sub	r10,sp,-1672
8000921e:	02 9b       	mov	r11,r1
80009220:	08 9c       	mov	r12,r4
80009222:	fe b0 f4 61 	rcall	80007ae4 <__sprint_r>
80009226:	e0 81 03 ec 	brne	800099fe <_vfprintf_r+0x1efe>
8000922a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000922e:	30 09       	mov	r9,0
80009230:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009234:	f2 08 18 00 	cp.b	r8,r9
80009238:	c1 f0       	breq	80009276 <_vfprintf_r+0x1776>
8000923a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000923e:	fa c9 f9 45 	sub	r9,sp,-1723
80009242:	2f f8       	sub	r8,-1
80009244:	87 09       	st.w	r3[0x0],r9
80009246:	fb 48 06 90 	st.w	sp[1680],r8
8000924a:	30 19       	mov	r9,1
8000924c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009250:	87 19       	st.w	r3[0x4],r9
80009252:	2f f8       	sub	r8,-1
80009254:	fb 48 06 8c 	st.w	sp[1676],r8
80009258:	58 78       	cp.w	r8,7
8000925a:	e0 89 00 04 	brgt	80009262 <_vfprintf_r+0x1762>
8000925e:	2f 83       	sub	r3,-8
80009260:	c0 b8       	rjmp	80009276 <_vfprintf_r+0x1776>
80009262:	fa ca f9 78 	sub	r10,sp,-1672
80009266:	02 9b       	mov	r11,r1
80009268:	08 9c       	mov	r12,r4
8000926a:	fe b0 f4 3d 	rcall	80007ae4 <__sprint_r>
8000926e:	e0 81 03 c8 	brne	800099fe <_vfprintf_r+0x1efe>
80009272:	fa c3 f9 e0 	sub	r3,sp,-1568
80009276:	40 fc       	lddsp	r12,sp[0x3c]
80009278:	58 0c       	cp.w	r12,0
8000927a:	c1 f0       	breq	800092b8 <_vfprintf_r+0x17b8>
8000927c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009280:	fa c9 f9 48 	sub	r9,sp,-1720
80009284:	2f e8       	sub	r8,-2
80009286:	87 09       	st.w	r3[0x0],r9
80009288:	fb 48 06 90 	st.w	sp[1680],r8
8000928c:	30 29       	mov	r9,2
8000928e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009292:	87 19       	st.w	r3[0x4],r9
80009294:	2f f8       	sub	r8,-1
80009296:	fb 48 06 8c 	st.w	sp[1676],r8
8000929a:	58 78       	cp.w	r8,7
8000929c:	e0 89 00 04 	brgt	800092a4 <_vfprintf_r+0x17a4>
800092a0:	2f 83       	sub	r3,-8
800092a2:	c0 b8       	rjmp	800092b8 <_vfprintf_r+0x17b8>
800092a4:	fa ca f9 78 	sub	r10,sp,-1672
800092a8:	02 9b       	mov	r11,r1
800092aa:	08 9c       	mov	r12,r4
800092ac:	fe b0 f4 1c 	rcall	80007ae4 <__sprint_r>
800092b0:	e0 81 03 a7 	brne	800099fe <_vfprintf_r+0x1efe>
800092b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092b8:	40 9b       	lddsp	r11,sp[0x24]
800092ba:	e0 4b 00 80 	cp.w	r11,128
800092be:	c4 71       	brne	8000934c <_vfprintf_r+0x184c>
800092c0:	40 8a       	lddsp	r10,sp[0x20]
800092c2:	40 39       	lddsp	r9,sp[0xc]
800092c4:	12 1a       	sub	r10,r9
800092c6:	50 4a       	stdsp	sp[0x10],r10
800092c8:	58 0a       	cp.w	r10,0
800092ca:	e0 89 00 20 	brgt	8000930a <_vfprintf_r+0x180a>
800092ce:	c3 f8       	rjmp	8000934c <_vfprintf_r+0x184c>
800092d0:	2f 09       	sub	r9,-16
800092d2:	2f f8       	sub	r8,-1
800092d4:	fe ce ba 38 	sub	lr,pc,-17864
800092d8:	31 0c       	mov	r12,16
800092da:	fb 49 06 90 	st.w	sp[1680],r9
800092de:	87 0e       	st.w	r3[0x0],lr
800092e0:	87 1c       	st.w	r3[0x4],r12
800092e2:	fb 48 06 8c 	st.w	sp[1676],r8
800092e6:	58 78       	cp.w	r8,7
800092e8:	e0 89 00 04 	brgt	800092f0 <_vfprintf_r+0x17f0>
800092ec:	2f 83       	sub	r3,-8
800092ee:	c0 b8       	rjmp	80009304 <_vfprintf_r+0x1804>
800092f0:	fa ca f9 78 	sub	r10,sp,-1672
800092f4:	02 9b       	mov	r11,r1
800092f6:	08 9c       	mov	r12,r4
800092f8:	fe b0 f3 f6 	rcall	80007ae4 <__sprint_r>
800092fc:	e0 81 03 81 	brne	800099fe <_vfprintf_r+0x1efe>
80009300:	fa c3 f9 e0 	sub	r3,sp,-1568
80009304:	40 4b       	lddsp	r11,sp[0x10]
80009306:	21 0b       	sub	r11,16
80009308:	50 4b       	stdsp	sp[0x10],r11
8000930a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000930e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009312:	fe ca ba 76 	sub	r10,pc,-17802
80009316:	40 4e       	lddsp	lr,sp[0x10]
80009318:	59 0e       	cp.w	lr,16
8000931a:	fe 99 ff db 	brgt	800092d0 <_vfprintf_r+0x17d0>
8000931e:	1c 09       	add	r9,lr
80009320:	2f f8       	sub	r8,-1
80009322:	87 0a       	st.w	r3[0x0],r10
80009324:	fb 49 06 90 	st.w	sp[1680],r9
80009328:	87 1e       	st.w	r3[0x4],lr
8000932a:	fb 48 06 8c 	st.w	sp[1676],r8
8000932e:	58 78       	cp.w	r8,7
80009330:	e0 89 00 04 	brgt	80009338 <_vfprintf_r+0x1838>
80009334:	2f 83       	sub	r3,-8
80009336:	c0 b8       	rjmp	8000934c <_vfprintf_r+0x184c>
80009338:	fa ca f9 78 	sub	r10,sp,-1672
8000933c:	02 9b       	mov	r11,r1
8000933e:	08 9c       	mov	r12,r4
80009340:	fe b0 f3 d2 	rcall	80007ae4 <__sprint_r>
80009344:	e0 81 03 5d 	brne	800099fe <_vfprintf_r+0x1efe>
80009348:	fa c3 f9 e0 	sub	r3,sp,-1568
8000934c:	40 2c       	lddsp	r12,sp[0x8]
8000934e:	04 1c       	sub	r12,r2
80009350:	50 2c       	stdsp	sp[0x8],r12
80009352:	58 0c       	cp.w	r12,0
80009354:	e0 89 00 20 	brgt	80009394 <_vfprintf_r+0x1894>
80009358:	c3 f8       	rjmp	800093d6 <_vfprintf_r+0x18d6>
8000935a:	2f 09       	sub	r9,-16
8000935c:	2f f8       	sub	r8,-1
8000935e:	fe cb ba c2 	sub	r11,pc,-17726
80009362:	31 0a       	mov	r10,16
80009364:	fb 49 06 90 	st.w	sp[1680],r9
80009368:	87 0b       	st.w	r3[0x0],r11
8000936a:	87 1a       	st.w	r3[0x4],r10
8000936c:	fb 48 06 8c 	st.w	sp[1676],r8
80009370:	58 78       	cp.w	r8,7
80009372:	e0 89 00 04 	brgt	8000937a <_vfprintf_r+0x187a>
80009376:	2f 83       	sub	r3,-8
80009378:	c0 b8       	rjmp	8000938e <_vfprintf_r+0x188e>
8000937a:	fa ca f9 78 	sub	r10,sp,-1672
8000937e:	02 9b       	mov	r11,r1
80009380:	08 9c       	mov	r12,r4
80009382:	fe b0 f3 b1 	rcall	80007ae4 <__sprint_r>
80009386:	e0 81 03 3c 	brne	800099fe <_vfprintf_r+0x1efe>
8000938a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000938e:	40 29       	lddsp	r9,sp[0x8]
80009390:	21 09       	sub	r9,16
80009392:	50 29       	stdsp	sp[0x8],r9
80009394:	fa f9 06 90 	ld.w	r9,sp[1680]
80009398:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000939c:	fe ca bb 00 	sub	r10,pc,-17664
800093a0:	40 2e       	lddsp	lr,sp[0x8]
800093a2:	59 0e       	cp.w	lr,16
800093a4:	fe 99 ff db 	brgt	8000935a <_vfprintf_r+0x185a>
800093a8:	1c 09       	add	r9,lr
800093aa:	2f f8       	sub	r8,-1
800093ac:	87 0a       	st.w	r3[0x0],r10
800093ae:	fb 49 06 90 	st.w	sp[1680],r9
800093b2:	87 1e       	st.w	r3[0x4],lr
800093b4:	fb 48 06 8c 	st.w	sp[1676],r8
800093b8:	58 78       	cp.w	r8,7
800093ba:	e0 89 00 04 	brgt	800093c2 <_vfprintf_r+0x18c2>
800093be:	2f 83       	sub	r3,-8
800093c0:	c0 b8       	rjmp	800093d6 <_vfprintf_r+0x18d6>
800093c2:	fa ca f9 78 	sub	r10,sp,-1672
800093c6:	02 9b       	mov	r11,r1
800093c8:	08 9c       	mov	r12,r4
800093ca:	fe b0 f3 8d 	rcall	80007ae4 <__sprint_r>
800093ce:	e0 81 03 18 	brne	800099fe <_vfprintf_r+0x1efe>
800093d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800093d6:	ed b5 00 08 	bld	r5,0x8
800093da:	c0 b0       	breq	800093f0 <_vfprintf_r+0x18f0>
800093dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800093e0:	87 12       	st.w	r3[0x4],r2
800093e2:	87 06       	st.w	r3[0x0],r6
800093e4:	f0 02 00 02 	add	r2,r8,r2
800093e8:	fb 42 06 90 	st.w	sp[1680],r2
800093ec:	e0 8f 01 d4 	bral	80009794 <_vfprintf_r+0x1c94>
800093f0:	e0 40 00 65 	cp.w	r0,101
800093f4:	e0 8a 01 d6 	brle	800097a0 <_vfprintf_r+0x1ca0>
800093f8:	30 08       	mov	r8,0
800093fa:	30 09       	mov	r9,0
800093fc:	40 5b       	lddsp	r11,sp[0x14]
800093fe:	40 7a       	lddsp	r10,sp[0x1c]
80009400:	e0 a0 15 3b 	rcall	8000be76 <__avr32_f64_cmp_eq>
80009404:	c7 90       	breq	800094f6 <_vfprintf_r+0x19f6>
80009406:	fa f8 06 90 	ld.w	r8,sp[1680]
8000940a:	fe c9 bb 82 	sub	r9,pc,-17534
8000940e:	2f f8       	sub	r8,-1
80009410:	87 09       	st.w	r3[0x0],r9
80009412:	fb 48 06 90 	st.w	sp[1680],r8
80009416:	30 19       	mov	r9,1
80009418:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000941c:	87 19       	st.w	r3[0x4],r9
8000941e:	2f f8       	sub	r8,-1
80009420:	fb 48 06 8c 	st.w	sp[1676],r8
80009424:	58 78       	cp.w	r8,7
80009426:	e0 89 00 05 	brgt	80009430 <_vfprintf_r+0x1930>
8000942a:	2f 83       	sub	r3,-8
8000942c:	c0 c8       	rjmp	80009444 <_vfprintf_r+0x1944>
8000942e:	d7 03       	nop
80009430:	fa ca f9 78 	sub	r10,sp,-1672
80009434:	02 9b       	mov	r11,r1
80009436:	08 9c       	mov	r12,r4
80009438:	fe b0 f3 56 	rcall	80007ae4 <__sprint_r>
8000943c:	e0 81 02 e1 	brne	800099fe <_vfprintf_r+0x1efe>
80009440:	fa c3 f9 e0 	sub	r3,sp,-1568
80009444:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009448:	40 6c       	lddsp	r12,sp[0x18]
8000944a:	18 38       	cp.w	r8,r12
8000944c:	c0 55       	brlt	80009456 <_vfprintf_r+0x1956>
8000944e:	ed b5 00 00 	bld	r5,0x0
80009452:	e0 81 02 6b 	brne	80009928 <_vfprintf_r+0x1e28>
80009456:	fa f8 06 90 	ld.w	r8,sp[1680]
8000945a:	2f f8       	sub	r8,-1
8000945c:	40 cb       	lddsp	r11,sp[0x30]
8000945e:	fb 48 06 90 	st.w	sp[1680],r8
80009462:	30 19       	mov	r9,1
80009464:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009468:	87 0b       	st.w	r3[0x0],r11
8000946a:	2f f8       	sub	r8,-1
8000946c:	87 19       	st.w	r3[0x4],r9
8000946e:	fb 48 06 8c 	st.w	sp[1676],r8
80009472:	58 78       	cp.w	r8,7
80009474:	e0 89 00 04 	brgt	8000947c <_vfprintf_r+0x197c>
80009478:	2f 83       	sub	r3,-8
8000947a:	c0 b8       	rjmp	80009490 <_vfprintf_r+0x1990>
8000947c:	fa ca f9 78 	sub	r10,sp,-1672
80009480:	02 9b       	mov	r11,r1
80009482:	08 9c       	mov	r12,r4
80009484:	fe b0 f3 30 	rcall	80007ae4 <__sprint_r>
80009488:	e0 81 02 bb 	brne	800099fe <_vfprintf_r+0x1efe>
8000948c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009490:	40 66       	lddsp	r6,sp[0x18]
80009492:	20 16       	sub	r6,1
80009494:	58 06       	cp.w	r6,0
80009496:	e0 89 00 1d 	brgt	800094d0 <_vfprintf_r+0x19d0>
8000949a:	e0 8f 02 47 	bral	80009928 <_vfprintf_r+0x1e28>
8000949e:	2f 09       	sub	r9,-16
800094a0:	2f f8       	sub	r8,-1
800094a2:	fb 49 06 90 	st.w	sp[1680],r9
800094a6:	87 02       	st.w	r3[0x0],r2
800094a8:	87 10       	st.w	r3[0x4],r0
800094aa:	fb 48 06 8c 	st.w	sp[1676],r8
800094ae:	58 78       	cp.w	r8,7
800094b0:	e0 89 00 04 	brgt	800094b8 <_vfprintf_r+0x19b8>
800094b4:	2f 83       	sub	r3,-8
800094b6:	c0 b8       	rjmp	800094cc <_vfprintf_r+0x19cc>
800094b8:	fa ca f9 78 	sub	r10,sp,-1672
800094bc:	02 9b       	mov	r11,r1
800094be:	08 9c       	mov	r12,r4
800094c0:	fe b0 f3 12 	rcall	80007ae4 <__sprint_r>
800094c4:	e0 81 02 9d 	brne	800099fe <_vfprintf_r+0x1efe>
800094c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800094cc:	21 06       	sub	r6,16
800094ce:	c0 48       	rjmp	800094d6 <_vfprintf_r+0x19d6>
800094d0:	fe c2 bc 34 	sub	r2,pc,-17356
800094d4:	31 00       	mov	r0,16
800094d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800094da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094de:	fe ca bc 42 	sub	r10,pc,-17342
800094e2:	59 06       	cp.w	r6,16
800094e4:	fe 99 ff dd 	brgt	8000949e <_vfprintf_r+0x199e>
800094e8:	0c 09       	add	r9,r6
800094ea:	87 0a       	st.w	r3[0x0],r10
800094ec:	fb 49 06 90 	st.w	sp[1680],r9
800094f0:	2f f8       	sub	r8,-1
800094f2:	87 16       	st.w	r3[0x4],r6
800094f4:	c5 39       	rjmp	8000979a <_vfprintf_r+0x1c9a>
800094f6:	fa fa 06 ac 	ld.w	r10,sp[1708]
800094fa:	58 0a       	cp.w	r10,0
800094fc:	e0 89 00 92 	brgt	80009620 <_vfprintf_r+0x1b20>
80009500:	fa f8 06 90 	ld.w	r8,sp[1680]
80009504:	fe c9 bc 7c 	sub	r9,pc,-17284
80009508:	2f f8       	sub	r8,-1
8000950a:	87 09       	st.w	r3[0x0],r9
8000950c:	fb 48 06 90 	st.w	sp[1680],r8
80009510:	30 19       	mov	r9,1
80009512:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009516:	87 19       	st.w	r3[0x4],r9
80009518:	2f f8       	sub	r8,-1
8000951a:	fb 48 06 8c 	st.w	sp[1676],r8
8000951e:	58 78       	cp.w	r8,7
80009520:	e0 89 00 04 	brgt	80009528 <_vfprintf_r+0x1a28>
80009524:	2f 83       	sub	r3,-8
80009526:	c0 b8       	rjmp	8000953c <_vfprintf_r+0x1a3c>
80009528:	fa ca f9 78 	sub	r10,sp,-1672
8000952c:	02 9b       	mov	r11,r1
8000952e:	08 9c       	mov	r12,r4
80009530:	fe b0 f2 da 	rcall	80007ae4 <__sprint_r>
80009534:	e0 81 02 65 	brne	800099fe <_vfprintf_r+0x1efe>
80009538:	fa c3 f9 e0 	sub	r3,sp,-1568
8000953c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009540:	58 08       	cp.w	r8,0
80009542:	c0 81       	brne	80009552 <_vfprintf_r+0x1a52>
80009544:	40 6a       	lddsp	r10,sp[0x18]
80009546:	58 0a       	cp.w	r10,0
80009548:	c0 51       	brne	80009552 <_vfprintf_r+0x1a52>
8000954a:	ed b5 00 00 	bld	r5,0x0
8000954e:	e0 81 01 ed 	brne	80009928 <_vfprintf_r+0x1e28>
80009552:	40 c9       	lddsp	r9,sp[0x30]
80009554:	fa f8 06 90 	ld.w	r8,sp[1680]
80009558:	2f f8       	sub	r8,-1
8000955a:	87 09       	st.w	r3[0x0],r9
8000955c:	fb 48 06 90 	st.w	sp[1680],r8
80009560:	30 19       	mov	r9,1
80009562:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009566:	87 19       	st.w	r3[0x4],r9
80009568:	2f f8       	sub	r8,-1
8000956a:	fb 48 06 8c 	st.w	sp[1676],r8
8000956e:	58 78       	cp.w	r8,7
80009570:	e0 89 00 04 	brgt	80009578 <_vfprintf_r+0x1a78>
80009574:	2f 83       	sub	r3,-8
80009576:	c0 b8       	rjmp	8000958c <_vfprintf_r+0x1a8c>
80009578:	fa ca f9 78 	sub	r10,sp,-1672
8000957c:	02 9b       	mov	r11,r1
8000957e:	08 9c       	mov	r12,r4
80009580:	fe b0 f2 b2 	rcall	80007ae4 <__sprint_r>
80009584:	e0 81 02 3d 	brne	800099fe <_vfprintf_r+0x1efe>
80009588:	fa c3 f9 e0 	sub	r3,sp,-1568
8000958c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009590:	5c 32       	neg	r2
80009592:	58 02       	cp.w	r2,0
80009594:	e0 89 00 1d 	brgt	800095ce <_vfprintf_r+0x1ace>
80009598:	c3 d8       	rjmp	80009612 <_vfprintf_r+0x1b12>
8000959a:	2f 09       	sub	r9,-16
8000959c:	2f f8       	sub	r8,-1
8000959e:	31 0e       	mov	lr,16
800095a0:	fb 49 06 90 	st.w	sp[1680],r9
800095a4:	87 00       	st.w	r3[0x0],r0
800095a6:	87 1e       	st.w	r3[0x4],lr
800095a8:	fb 48 06 8c 	st.w	sp[1676],r8
800095ac:	58 78       	cp.w	r8,7
800095ae:	e0 89 00 04 	brgt	800095b6 <_vfprintf_r+0x1ab6>
800095b2:	2f 83       	sub	r3,-8
800095b4:	c0 b8       	rjmp	800095ca <_vfprintf_r+0x1aca>
800095b6:	fa ca f9 78 	sub	r10,sp,-1672
800095ba:	02 9b       	mov	r11,r1
800095bc:	08 9c       	mov	r12,r4
800095be:	fe b0 f2 93 	rcall	80007ae4 <__sprint_r>
800095c2:	e0 81 02 1e 	brne	800099fe <_vfprintf_r+0x1efe>
800095c6:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ca:	21 02       	sub	r2,16
800095cc:	c0 38       	rjmp	800095d2 <_vfprintf_r+0x1ad2>
800095ce:	fe c0 bd 32 	sub	r0,pc,-17102
800095d2:	fa f9 06 90 	ld.w	r9,sp[1680]
800095d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095da:	fe ca bd 3e 	sub	r10,pc,-17090
800095de:	59 02       	cp.w	r2,16
800095e0:	fe 99 ff dd 	brgt	8000959a <_vfprintf_r+0x1a9a>
800095e4:	04 09       	add	r9,r2
800095e6:	2f f8       	sub	r8,-1
800095e8:	87 0a       	st.w	r3[0x0],r10
800095ea:	fb 49 06 90 	st.w	sp[1680],r9
800095ee:	87 12       	st.w	r3[0x4],r2
800095f0:	fb 48 06 8c 	st.w	sp[1676],r8
800095f4:	58 78       	cp.w	r8,7
800095f6:	e0 89 00 04 	brgt	800095fe <_vfprintf_r+0x1afe>
800095fa:	2f 83       	sub	r3,-8
800095fc:	c0 b8       	rjmp	80009612 <_vfprintf_r+0x1b12>
800095fe:	fa ca f9 78 	sub	r10,sp,-1672
80009602:	02 9b       	mov	r11,r1
80009604:	08 9c       	mov	r12,r4
80009606:	fe b0 f2 6f 	rcall	80007ae4 <__sprint_r>
8000960a:	e0 81 01 fa 	brne	800099fe <_vfprintf_r+0x1efe>
8000960e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009612:	40 6c       	lddsp	r12,sp[0x18]
80009614:	fa f8 06 90 	ld.w	r8,sp[1680]
80009618:	87 06       	st.w	r3[0x0],r6
8000961a:	87 1c       	st.w	r3[0x4],r12
8000961c:	18 08       	add	r8,r12
8000961e:	cb 98       	rjmp	80009790 <_vfprintf_r+0x1c90>
80009620:	fa f9 06 90 	ld.w	r9,sp[1680]
80009624:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009628:	40 6b       	lddsp	r11,sp[0x18]
8000962a:	16 3a       	cp.w	r10,r11
8000962c:	c6 f5       	brlt	8000970a <_vfprintf_r+0x1c0a>
8000962e:	16 09       	add	r9,r11
80009630:	2f f8       	sub	r8,-1
80009632:	87 06       	st.w	r3[0x0],r6
80009634:	fb 49 06 90 	st.w	sp[1680],r9
80009638:	87 1b       	st.w	r3[0x4],r11
8000963a:	fb 48 06 8c 	st.w	sp[1676],r8
8000963e:	58 78       	cp.w	r8,7
80009640:	e0 89 00 04 	brgt	80009648 <_vfprintf_r+0x1b48>
80009644:	2f 83       	sub	r3,-8
80009646:	c0 b8       	rjmp	8000965c <_vfprintf_r+0x1b5c>
80009648:	fa ca f9 78 	sub	r10,sp,-1672
8000964c:	02 9b       	mov	r11,r1
8000964e:	08 9c       	mov	r12,r4
80009650:	fe b0 f2 4a 	rcall	80007ae4 <__sprint_r>
80009654:	e0 81 01 d5 	brne	800099fe <_vfprintf_r+0x1efe>
80009658:	fa c3 f9 e0 	sub	r3,sp,-1568
8000965c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009660:	40 6a       	lddsp	r10,sp[0x18]
80009662:	14 16       	sub	r6,r10
80009664:	58 06       	cp.w	r6,0
80009666:	e0 89 00 1c 	brgt	8000969e <_vfprintf_r+0x1b9e>
8000966a:	c3 d8       	rjmp	800096e4 <_vfprintf_r+0x1be4>
8000966c:	2f 09       	sub	r9,-16
8000966e:	2f f8       	sub	r8,-1
80009670:	fb 49 06 90 	st.w	sp[1680],r9
80009674:	87 02       	st.w	r3[0x0],r2
80009676:	87 10       	st.w	r3[0x4],r0
80009678:	fb 48 06 8c 	st.w	sp[1676],r8
8000967c:	58 78       	cp.w	r8,7
8000967e:	e0 89 00 04 	brgt	80009686 <_vfprintf_r+0x1b86>
80009682:	2f 83       	sub	r3,-8
80009684:	c0 b8       	rjmp	8000969a <_vfprintf_r+0x1b9a>
80009686:	fa ca f9 78 	sub	r10,sp,-1672
8000968a:	02 9b       	mov	r11,r1
8000968c:	08 9c       	mov	r12,r4
8000968e:	fe b0 f2 2b 	rcall	80007ae4 <__sprint_r>
80009692:	e0 81 01 b6 	brne	800099fe <_vfprintf_r+0x1efe>
80009696:	fa c3 f9 e0 	sub	r3,sp,-1568
8000969a:	21 06       	sub	r6,16
8000969c:	c0 48       	rjmp	800096a4 <_vfprintf_r+0x1ba4>
8000969e:	fe c2 be 02 	sub	r2,pc,-16894
800096a2:	31 00       	mov	r0,16
800096a4:	fa f9 06 90 	ld.w	r9,sp[1680]
800096a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096ac:	fe ca be 10 	sub	r10,pc,-16880
800096b0:	59 06       	cp.w	r6,16
800096b2:	fe 99 ff dd 	brgt	8000966c <_vfprintf_r+0x1b6c>
800096b6:	0c 09       	add	r9,r6
800096b8:	2f f8       	sub	r8,-1
800096ba:	87 0a       	st.w	r3[0x0],r10
800096bc:	fb 49 06 90 	st.w	sp[1680],r9
800096c0:	87 16       	st.w	r3[0x4],r6
800096c2:	fb 48 06 8c 	st.w	sp[1676],r8
800096c6:	58 78       	cp.w	r8,7
800096c8:	e0 89 00 04 	brgt	800096d0 <_vfprintf_r+0x1bd0>
800096cc:	2f 83       	sub	r3,-8
800096ce:	c0 b8       	rjmp	800096e4 <_vfprintf_r+0x1be4>
800096d0:	fa ca f9 78 	sub	r10,sp,-1672
800096d4:	02 9b       	mov	r11,r1
800096d6:	08 9c       	mov	r12,r4
800096d8:	fe b0 f2 06 	rcall	80007ae4 <__sprint_r>
800096dc:	e0 81 01 91 	brne	800099fe <_vfprintf_r+0x1efe>
800096e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096e4:	ed b5 00 00 	bld	r5,0x0
800096e8:	e0 81 01 20 	brne	80009928 <_vfprintf_r+0x1e28>
800096ec:	40 c9       	lddsp	r9,sp[0x30]
800096ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800096f2:	2f f8       	sub	r8,-1
800096f4:	87 09       	st.w	r3[0x0],r9
800096f6:	fb 48 06 90 	st.w	sp[1680],r8
800096fa:	30 19       	mov	r9,1
800096fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009700:	87 19       	st.w	r3[0x4],r9
80009702:	2f f8       	sub	r8,-1
80009704:	fb 48 06 8c 	st.w	sp[1676],r8
80009708:	c0 29       	rjmp	8000990c <_vfprintf_r+0x1e0c>
8000970a:	14 09       	add	r9,r10
8000970c:	2f f8       	sub	r8,-1
8000970e:	fb 49 06 90 	st.w	sp[1680],r9
80009712:	87 06       	st.w	r3[0x0],r6
80009714:	87 1a       	st.w	r3[0x4],r10
80009716:	fb 48 06 8c 	st.w	sp[1676],r8
8000971a:	58 78       	cp.w	r8,7
8000971c:	e0 89 00 04 	brgt	80009724 <_vfprintf_r+0x1c24>
80009720:	2f 83       	sub	r3,-8
80009722:	c0 b8       	rjmp	80009738 <_vfprintf_r+0x1c38>
80009724:	fa ca f9 78 	sub	r10,sp,-1672
80009728:	02 9b       	mov	r11,r1
8000972a:	08 9c       	mov	r12,r4
8000972c:	fe b0 f1 dc 	rcall	80007ae4 <__sprint_r>
80009730:	e0 81 01 67 	brne	800099fe <_vfprintf_r+0x1efe>
80009734:	fa c3 f9 e0 	sub	r3,sp,-1568
80009738:	40 c8       	lddsp	r8,sp[0x30]
8000973a:	87 08       	st.w	r3[0x0],r8
8000973c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009740:	2f f8       	sub	r8,-1
80009742:	30 19       	mov	r9,1
80009744:	fb 48 06 90 	st.w	sp[1680],r8
80009748:	87 19       	st.w	r3[0x4],r9
8000974a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000974e:	2f f8       	sub	r8,-1
80009750:	fb 48 06 8c 	st.w	sp[1676],r8
80009754:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009758:	58 78       	cp.w	r8,7
8000975a:	e0 89 00 04 	brgt	80009762 <_vfprintf_r+0x1c62>
8000975e:	2f 83       	sub	r3,-8
80009760:	c0 b8       	rjmp	80009776 <_vfprintf_r+0x1c76>
80009762:	fa ca f9 78 	sub	r10,sp,-1672
80009766:	02 9b       	mov	r11,r1
80009768:	08 9c       	mov	r12,r4
8000976a:	fe b0 f1 bd 	rcall	80007ae4 <__sprint_r>
8000976e:	e0 81 01 48 	brne	800099fe <_vfprintf_r+0x1efe>
80009772:	fa c3 f9 e0 	sub	r3,sp,-1568
80009776:	04 06       	add	r6,r2
80009778:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000977c:	87 06       	st.w	r3[0x0],r6
8000977e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009782:	40 66       	lddsp	r6,sp[0x18]
80009784:	40 6e       	lddsp	lr,sp[0x18]
80009786:	10 16       	sub	r6,r8
80009788:	f2 08 01 08 	sub	r8,r9,r8
8000978c:	87 16       	st.w	r3[0x4],r6
8000978e:	1c 08       	add	r8,lr
80009790:	fb 48 06 90 	st.w	sp[1680],r8
80009794:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009798:	2f f8       	sub	r8,-1
8000979a:	fb 48 06 8c 	st.w	sp[1676],r8
8000979e:	cb 78       	rjmp	8000990c <_vfprintf_r+0x1e0c>
800097a0:	40 6c       	lddsp	r12,sp[0x18]
800097a2:	58 1c       	cp.w	r12,1
800097a4:	e0 89 00 06 	brgt	800097b0 <_vfprintf_r+0x1cb0>
800097a8:	ed b5 00 00 	bld	r5,0x0
800097ac:	e0 81 00 85 	brne	800098b6 <_vfprintf_r+0x1db6>
800097b0:	fa f8 06 90 	ld.w	r8,sp[1680]
800097b4:	2f f8       	sub	r8,-1
800097b6:	30 19       	mov	r9,1
800097b8:	fb 48 06 90 	st.w	sp[1680],r8
800097bc:	87 06       	st.w	r3[0x0],r6
800097be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c2:	87 19       	st.w	r3[0x4],r9
800097c4:	2f f8       	sub	r8,-1
800097c6:	fb 48 06 8c 	st.w	sp[1676],r8
800097ca:	58 78       	cp.w	r8,7
800097cc:	e0 89 00 04 	brgt	800097d4 <_vfprintf_r+0x1cd4>
800097d0:	2f 83       	sub	r3,-8
800097d2:	c0 b8       	rjmp	800097e8 <_vfprintf_r+0x1ce8>
800097d4:	fa ca f9 78 	sub	r10,sp,-1672
800097d8:	02 9b       	mov	r11,r1
800097da:	08 9c       	mov	r12,r4
800097dc:	fe b0 f1 84 	rcall	80007ae4 <__sprint_r>
800097e0:	e0 81 01 0f 	brne	800099fe <_vfprintf_r+0x1efe>
800097e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ec:	2f f8       	sub	r8,-1
800097ee:	40 cb       	lddsp	r11,sp[0x30]
800097f0:	fb 48 06 90 	st.w	sp[1680],r8
800097f4:	30 19       	mov	r9,1
800097f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097fa:	87 0b       	st.w	r3[0x0],r11
800097fc:	2f f8       	sub	r8,-1
800097fe:	87 19       	st.w	r3[0x4],r9
80009800:	fb 48 06 8c 	st.w	sp[1676],r8
80009804:	58 78       	cp.w	r8,7
80009806:	e0 89 00 05 	brgt	80009810 <_vfprintf_r+0x1d10>
8000980a:	2f 83       	sub	r3,-8
8000980c:	c0 c8       	rjmp	80009824 <_vfprintf_r+0x1d24>
8000980e:	d7 03       	nop
80009810:	fa ca f9 78 	sub	r10,sp,-1672
80009814:	02 9b       	mov	r11,r1
80009816:	08 9c       	mov	r12,r4
80009818:	fe b0 f1 66 	rcall	80007ae4 <__sprint_r>
8000981c:	e0 81 00 f1 	brne	800099fe <_vfprintf_r+0x1efe>
80009820:	fa c3 f9 e0 	sub	r3,sp,-1568
80009824:	30 08       	mov	r8,0
80009826:	30 09       	mov	r9,0
80009828:	40 5b       	lddsp	r11,sp[0x14]
8000982a:	40 7a       	lddsp	r10,sp[0x1c]
8000982c:	e0 a0 13 25 	rcall	8000be76 <__avr32_f64_cmp_eq>
80009830:	40 68       	lddsp	r8,sp[0x18]
80009832:	20 18       	sub	r8,1
80009834:	58 0c       	cp.w	r12,0
80009836:	c0 d1       	brne	80009850 <_vfprintf_r+0x1d50>
80009838:	2f f6       	sub	r6,-1
8000983a:	87 18       	st.w	r3[0x4],r8
8000983c:	87 06       	st.w	r3[0x0],r6
8000983e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009842:	10 06       	add	r6,r8
80009844:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009848:	fb 46 06 90 	st.w	sp[1680],r6
8000984c:	2f f8       	sub	r8,-1
8000984e:	c3 18       	rjmp	800098b0 <_vfprintf_r+0x1db0>
80009850:	10 96       	mov	r6,r8
80009852:	58 08       	cp.w	r8,0
80009854:	e0 89 00 1c 	brgt	8000988c <_vfprintf_r+0x1d8c>
80009858:	c4 b8       	rjmp	800098ee <_vfprintf_r+0x1dee>
8000985a:	2f 09       	sub	r9,-16
8000985c:	2f f8       	sub	r8,-1
8000985e:	fb 49 06 90 	st.w	sp[1680],r9
80009862:	87 02       	st.w	r3[0x0],r2
80009864:	87 10       	st.w	r3[0x4],r0
80009866:	fb 48 06 8c 	st.w	sp[1676],r8
8000986a:	58 78       	cp.w	r8,7
8000986c:	e0 89 00 04 	brgt	80009874 <_vfprintf_r+0x1d74>
80009870:	2f 83       	sub	r3,-8
80009872:	c0 b8       	rjmp	80009888 <_vfprintf_r+0x1d88>
80009874:	fa ca f9 78 	sub	r10,sp,-1672
80009878:	02 9b       	mov	r11,r1
8000987a:	08 9c       	mov	r12,r4
8000987c:	fe b0 f1 34 	rcall	80007ae4 <__sprint_r>
80009880:	e0 81 00 bf 	brne	800099fe <_vfprintf_r+0x1efe>
80009884:	fa c3 f9 e0 	sub	r3,sp,-1568
80009888:	21 06       	sub	r6,16
8000988a:	c0 48       	rjmp	80009892 <_vfprintf_r+0x1d92>
8000988c:	fe c2 bf f0 	sub	r2,pc,-16400
80009890:	31 00       	mov	r0,16
80009892:	fa f9 06 90 	ld.w	r9,sp[1680]
80009896:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000989a:	fe ca bf fe 	sub	r10,pc,-16386
8000989e:	59 06       	cp.w	r6,16
800098a0:	fe 99 ff dd 	brgt	8000985a <_vfprintf_r+0x1d5a>
800098a4:	0c 09       	add	r9,r6
800098a6:	87 0a       	st.w	r3[0x0],r10
800098a8:	fb 49 06 90 	st.w	sp[1680],r9
800098ac:	2f f8       	sub	r8,-1
800098ae:	87 16       	st.w	r3[0x4],r6
800098b0:	fb 48 06 8c 	st.w	sp[1676],r8
800098b4:	c0 e8       	rjmp	800098d0 <_vfprintf_r+0x1dd0>
800098b6:	fa f8 06 90 	ld.w	r8,sp[1680]
800098ba:	2f f8       	sub	r8,-1
800098bc:	30 19       	mov	r9,1
800098be:	fb 48 06 90 	st.w	sp[1680],r8
800098c2:	87 06       	st.w	r3[0x0],r6
800098c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098c8:	87 19       	st.w	r3[0x4],r9
800098ca:	2f f8       	sub	r8,-1
800098cc:	fb 48 06 8c 	st.w	sp[1676],r8
800098d0:	58 78       	cp.w	r8,7
800098d2:	e0 89 00 04 	brgt	800098da <_vfprintf_r+0x1dda>
800098d6:	2f 83       	sub	r3,-8
800098d8:	c0 b8       	rjmp	800098ee <_vfprintf_r+0x1dee>
800098da:	fa ca f9 78 	sub	r10,sp,-1672
800098de:	02 9b       	mov	r11,r1
800098e0:	08 9c       	mov	r12,r4
800098e2:	fe b0 f1 01 	rcall	80007ae4 <__sprint_r>
800098e6:	e0 81 00 8c 	brne	800099fe <_vfprintf_r+0x1efe>
800098ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800098ee:	40 ea       	lddsp	r10,sp[0x38]
800098f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800098f4:	14 08       	add	r8,r10
800098f6:	fa c9 f9 64 	sub	r9,sp,-1692
800098fa:	fb 48 06 90 	st.w	sp[1680],r8
800098fe:	87 1a       	st.w	r3[0x4],r10
80009900:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009904:	87 09       	st.w	r3[0x0],r9
80009906:	2f f8       	sub	r8,-1
80009908:	fb 48 06 8c 	st.w	sp[1676],r8
8000990c:	58 78       	cp.w	r8,7
8000990e:	e0 89 00 04 	brgt	80009916 <_vfprintf_r+0x1e16>
80009912:	2f 83       	sub	r3,-8
80009914:	c0 a8       	rjmp	80009928 <_vfprintf_r+0x1e28>
80009916:	fa ca f9 78 	sub	r10,sp,-1672
8000991a:	02 9b       	mov	r11,r1
8000991c:	08 9c       	mov	r12,r4
8000991e:	fe b0 f0 e3 	rcall	80007ae4 <__sprint_r>
80009922:	c6 e1       	brne	800099fe <_vfprintf_r+0x1efe>
80009924:	fa c3 f9 e0 	sub	r3,sp,-1568
80009928:	e2 15 00 04 	andl	r5,0x4,COH
8000992c:	c3 f0       	breq	800099aa <_vfprintf_r+0x1eaa>
8000992e:	40 86       	lddsp	r6,sp[0x20]
80009930:	40 39       	lddsp	r9,sp[0xc]
80009932:	12 16       	sub	r6,r9
80009934:	58 06       	cp.w	r6,0
80009936:	e0 89 00 1a 	brgt	8000996a <_vfprintf_r+0x1e6a>
8000993a:	c3 88       	rjmp	800099aa <_vfprintf_r+0x1eaa>
8000993c:	2f 09       	sub	r9,-16
8000993e:	2f f8       	sub	r8,-1
80009940:	fb 49 06 90 	st.w	sp[1680],r9
80009944:	87 05       	st.w	r3[0x0],r5
80009946:	87 12       	st.w	r3[0x4],r2
80009948:	fb 48 06 8c 	st.w	sp[1676],r8
8000994c:	58 78       	cp.w	r8,7
8000994e:	e0 89 00 04 	brgt	80009956 <_vfprintf_r+0x1e56>
80009952:	2f 83       	sub	r3,-8
80009954:	c0 98       	rjmp	80009966 <_vfprintf_r+0x1e66>
80009956:	00 9a       	mov	r10,r0
80009958:	02 9b       	mov	r11,r1
8000995a:	08 9c       	mov	r12,r4
8000995c:	fe b0 f0 c4 	rcall	80007ae4 <__sprint_r>
80009960:	c4 f1       	brne	800099fe <_vfprintf_r+0x1efe>
80009962:	fa c3 f9 e0 	sub	r3,sp,-1568
80009966:	21 06       	sub	r6,16
80009968:	c0 68       	rjmp	80009974 <_vfprintf_r+0x1e74>
8000996a:	fe c5 c0 de 	sub	r5,pc,-16162
8000996e:	31 02       	mov	r2,16
80009970:	fa c0 f9 78 	sub	r0,sp,-1672
80009974:	fa f9 06 90 	ld.w	r9,sp[1680]
80009978:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000997c:	fe ca c0 f0 	sub	r10,pc,-16144
80009980:	59 06       	cp.w	r6,16
80009982:	fe 99 ff dd 	brgt	8000993c <_vfprintf_r+0x1e3c>
80009986:	0c 09       	add	r9,r6
80009988:	2f f8       	sub	r8,-1
8000998a:	87 0a       	st.w	r3[0x0],r10
8000998c:	87 16       	st.w	r3[0x4],r6
8000998e:	fb 49 06 90 	st.w	sp[1680],r9
80009992:	fb 48 06 8c 	st.w	sp[1676],r8
80009996:	58 78       	cp.w	r8,7
80009998:	e0 8a 00 09 	brle	800099aa <_vfprintf_r+0x1eaa>
8000999c:	fa ca f9 78 	sub	r10,sp,-1672
800099a0:	02 9b       	mov	r11,r1
800099a2:	08 9c       	mov	r12,r4
800099a4:	fe b0 f0 a0 	rcall	80007ae4 <__sprint_r>
800099a8:	c2 b1       	brne	800099fe <_vfprintf_r+0x1efe>
800099aa:	40 bc       	lddsp	r12,sp[0x2c]
800099ac:	40 36       	lddsp	r6,sp[0xc]
800099ae:	40 8e       	lddsp	lr,sp[0x20]
800099b0:	ec 0e 0c 48 	max	r8,r6,lr
800099b4:	10 0c       	add	r12,r8
800099b6:	50 bc       	stdsp	sp[0x2c],r12
800099b8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099bc:	58 08       	cp.w	r8,0
800099be:	c0 80       	breq	800099ce <_vfprintf_r+0x1ece>
800099c0:	fa ca f9 78 	sub	r10,sp,-1672
800099c4:	02 9b       	mov	r11,r1
800099c6:	08 9c       	mov	r12,r4
800099c8:	fe b0 f0 8e 	rcall	80007ae4 <__sprint_r>
800099cc:	c1 91       	brne	800099fe <_vfprintf_r+0x1efe>
800099ce:	30 0b       	mov	r11,0
800099d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d4:	fb 4b 06 8c 	st.w	sp[1676],r11
800099d8:	fe 9f f1 22 	bral	80007c1c <_vfprintf_r+0x11c>
800099dc:	08 95       	mov	r5,r4
800099de:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e2:	58 08       	cp.w	r8,0
800099e4:	c0 80       	breq	800099f4 <_vfprintf_r+0x1ef4>
800099e6:	08 9c       	mov	r12,r4
800099e8:	fa ca f9 78 	sub	r10,sp,-1672
800099ec:	02 9b       	mov	r11,r1
800099ee:	fe b0 f0 7b 	rcall	80007ae4 <__sprint_r>
800099f2:	c0 61       	brne	800099fe <_vfprintf_r+0x1efe>
800099f4:	30 08       	mov	r8,0
800099f6:	fb 48 06 8c 	st.w	sp[1676],r8
800099fa:	c0 28       	rjmp	800099fe <_vfprintf_r+0x1efe>
800099fc:	40 41       	lddsp	r1,sp[0x10]
800099fe:	82 68       	ld.sh	r8,r1[0xc]
80009a00:	ed b8 00 06 	bld	r8,0x6
80009a04:	c0 31       	brne	80009a0a <_vfprintf_r+0x1f0a>
80009a06:	3f fa       	mov	r10,-1
80009a08:	50 ba       	stdsp	sp[0x2c],r10
80009a0a:	40 bc       	lddsp	r12,sp[0x2c]
80009a0c:	fe 3d f9 44 	sub	sp,-1724
80009a10:	d8 32       	popm	r0-r7,pc
80009a12:	d7 03       	nop

80009a14 <__swsetup_r>:
80009a14:	d4 21       	pushm	r4-r7,lr
80009a16:	e0 68 0a 38 	mov	r8,2616
80009a1a:	18 96       	mov	r6,r12
80009a1c:	16 97       	mov	r7,r11
80009a1e:	70 0c       	ld.w	r12,r8[0x0]
80009a20:	58 0c       	cp.w	r12,0
80009a22:	c0 60       	breq	80009a2e <__swsetup_r+0x1a>
80009a24:	78 68       	ld.w	r8,r12[0x18]
80009a26:	58 08       	cp.w	r8,0
80009a28:	c0 31       	brne	80009a2e <__swsetup_r+0x1a>
80009a2a:	e0 a0 07 bf 	rcall	8000a9a8 <__sinit>
80009a2e:	fe c8 c0 72 	sub	r8,pc,-16270
80009a32:	10 37       	cp.w	r7,r8
80009a34:	c0 61       	brne	80009a40 <__swsetup_r+0x2c>
80009a36:	e0 68 0a 38 	mov	r8,2616
80009a3a:	70 08       	ld.w	r8,r8[0x0]
80009a3c:	70 07       	ld.w	r7,r8[0x0]
80009a3e:	c1 28       	rjmp	80009a62 <__swsetup_r+0x4e>
80009a40:	fe c8 c0 64 	sub	r8,pc,-16284
80009a44:	10 37       	cp.w	r7,r8
80009a46:	c0 61       	brne	80009a52 <__swsetup_r+0x3e>
80009a48:	e0 68 0a 38 	mov	r8,2616
80009a4c:	70 08       	ld.w	r8,r8[0x0]
80009a4e:	70 17       	ld.w	r7,r8[0x4]
80009a50:	c0 98       	rjmp	80009a62 <__swsetup_r+0x4e>
80009a52:	fe c8 c0 56 	sub	r8,pc,-16298
80009a56:	10 37       	cp.w	r7,r8
80009a58:	c0 51       	brne	80009a62 <__swsetup_r+0x4e>
80009a5a:	e0 68 0a 38 	mov	r8,2616
80009a5e:	70 08       	ld.w	r8,r8[0x0]
80009a60:	70 27       	ld.w	r7,r8[0x8]
80009a62:	8e 68       	ld.sh	r8,r7[0xc]
80009a64:	ed b8 00 03 	bld	r8,0x3
80009a68:	c1 e0       	breq	80009aa4 <__swsetup_r+0x90>
80009a6a:	ed b8 00 04 	bld	r8,0x4
80009a6e:	c3 e1       	brne	80009aea <__swsetup_r+0xd6>
80009a70:	ed b8 00 02 	bld	r8,0x2
80009a74:	c1 51       	brne	80009a9e <__swsetup_r+0x8a>
80009a76:	6e db       	ld.w	r11,r7[0x34]
80009a78:	58 0b       	cp.w	r11,0
80009a7a:	c0 a0       	breq	80009a8e <__swsetup_r+0x7a>
80009a7c:	ee c8 ff bc 	sub	r8,r7,-68
80009a80:	10 3b       	cp.w	r11,r8
80009a82:	c0 40       	breq	80009a8a <__swsetup_r+0x76>
80009a84:	0c 9c       	mov	r12,r6
80009a86:	e0 a0 08 2b 	rcall	8000aadc <_free_r>
80009a8a:	30 08       	mov	r8,0
80009a8c:	8f d8       	st.w	r7[0x34],r8
80009a8e:	8e 68       	ld.sh	r8,r7[0xc]
80009a90:	e0 18 ff db 	andl	r8,0xffdb
80009a94:	ae 68       	st.h	r7[0xc],r8
80009a96:	30 08       	mov	r8,0
80009a98:	8f 18       	st.w	r7[0x4],r8
80009a9a:	6e 48       	ld.w	r8,r7[0x10]
80009a9c:	8f 08       	st.w	r7[0x0],r8
80009a9e:	8e 68       	ld.sh	r8,r7[0xc]
80009aa0:	a3 b8       	sbr	r8,0x3
80009aa2:	ae 68       	st.h	r7[0xc],r8
80009aa4:	6e 48       	ld.w	r8,r7[0x10]
80009aa6:	58 08       	cp.w	r8,0
80009aa8:	c0 b1       	brne	80009abe <__swsetup_r+0xaa>
80009aaa:	8e 68       	ld.sh	r8,r7[0xc]
80009aac:	e2 18 02 80 	andl	r8,0x280,COH
80009ab0:	e0 48 02 00 	cp.w	r8,512
80009ab4:	c0 50       	breq	80009abe <__swsetup_r+0xaa>
80009ab6:	0c 9c       	mov	r12,r6
80009ab8:	0e 9b       	mov	r11,r7
80009aba:	e0 a0 0a 4b 	rcall	8000af50 <__smakebuf_r>
80009abe:	8e 69       	ld.sh	r9,r7[0xc]
80009ac0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ac4:	c0 70       	breq	80009ad2 <__swsetup_r+0xbe>
80009ac6:	30 08       	mov	r8,0
80009ac8:	8f 28       	st.w	r7[0x8],r8
80009aca:	6e 58       	ld.w	r8,r7[0x14]
80009acc:	5c 38       	neg	r8
80009ace:	8f 68       	st.w	r7[0x18],r8
80009ad0:	c0 68       	rjmp	80009adc <__swsetup_r+0xc8>
80009ad2:	ed b9 00 01 	bld	r9,0x1
80009ad6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009ada:	8f 28       	st.w	r7[0x8],r8
80009adc:	6e 48       	ld.w	r8,r7[0x10]
80009ade:	58 08       	cp.w	r8,0
80009ae0:	c0 61       	brne	80009aec <__swsetup_r+0xd8>
80009ae2:	8e 68       	ld.sh	r8,r7[0xc]
80009ae4:	ed b8 00 07 	bld	r8,0x7
80009ae8:	c0 21       	brne	80009aec <__swsetup_r+0xd8>
80009aea:	dc 2a       	popm	r4-r7,pc,r12=-1
80009aec:	d8 2a       	popm	r4-r7,pc,r12=0
80009aee:	d7 03       	nop

80009af0 <quorem>:
80009af0:	d4 31       	pushm	r0-r7,lr
80009af2:	20 2d       	sub	sp,8
80009af4:	18 97       	mov	r7,r12
80009af6:	78 48       	ld.w	r8,r12[0x10]
80009af8:	76 46       	ld.w	r6,r11[0x10]
80009afa:	0c 38       	cp.w	r8,r6
80009afc:	c0 34       	brge	80009b02 <quorem+0x12>
80009afe:	30 0c       	mov	r12,0
80009b00:	c8 58       	rjmp	80009c0a <quorem+0x11a>
80009b02:	ec c2 ff fc 	sub	r2,r6,-4
80009b06:	f6 c3 ff ec 	sub	r3,r11,-20
80009b0a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009b0e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009b12:	2f f9       	sub	r9,-1
80009b14:	20 16       	sub	r6,1
80009b16:	f8 09 0d 08 	divu	r8,r12,r9
80009b1a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009b1e:	ee c4 ff ec 	sub	r4,r7,-20
80009b22:	10 95       	mov	r5,r8
80009b24:	58 08       	cp.w	r8,0
80009b26:	c4 10       	breq	80009ba8 <quorem+0xb8>
80009b28:	30 09       	mov	r9,0
80009b2a:	06 9a       	mov	r10,r3
80009b2c:	08 98       	mov	r8,r4
80009b2e:	12 91       	mov	r1,r9
80009b30:	50 0b       	stdsp	sp[0x0],r11
80009b32:	70 0e       	ld.w	lr,r8[0x0]
80009b34:	b1 8e       	lsr	lr,0x10
80009b36:	50 1e       	stdsp	sp[0x4],lr
80009b38:	15 0e       	ld.w	lr,r10++
80009b3a:	fc 00 16 10 	lsr	r0,lr,0x10
80009b3e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b42:	ea 0e 03 41 	mac	r1,r5,lr
80009b46:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009b4a:	b1 81       	lsr	r1,0x10
80009b4c:	40 1b       	lddsp	r11,sp[0x4]
80009b4e:	ea 00 02 40 	mul	r0,r5,r0
80009b52:	e2 00 00 00 	add	r0,r1,r0
80009b56:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009b5a:	02 1b       	sub	r11,r1
80009b5c:	50 1b       	stdsp	sp[0x4],r11
80009b5e:	70 0b       	ld.w	r11,r8[0x0]
80009b60:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009b64:	02 09       	add	r9,r1
80009b66:	f2 0e 01 0e 	sub	lr,r9,lr
80009b6a:	b0 1e       	st.h	r8[0x2],lr
80009b6c:	fc 09 14 10 	asr	r9,lr,0x10
80009b70:	40 1e       	lddsp	lr,sp[0x4]
80009b72:	fc 09 00 09 	add	r9,lr,r9
80009b76:	b0 09       	st.h	r8[0x0],r9
80009b78:	e0 01 16 10 	lsr	r1,r0,0x10
80009b7c:	2f c8       	sub	r8,-4
80009b7e:	b1 49       	asr	r9,0x10
80009b80:	04 3a       	cp.w	r10,r2
80009b82:	fe 98 ff d8 	brls	80009b32 <quorem+0x42>
80009b86:	40 0b       	lddsp	r11,sp[0x0]
80009b88:	58 0c       	cp.w	r12,0
80009b8a:	c0 f1       	brne	80009ba8 <quorem+0xb8>
80009b8c:	ec c8 ff fb 	sub	r8,r6,-5
80009b90:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009b94:	c0 28       	rjmp	80009b98 <quorem+0xa8>
80009b96:	20 16       	sub	r6,1
80009b98:	20 48       	sub	r8,4
80009b9a:	08 38       	cp.w	r8,r4
80009b9c:	e0 88 00 05 	brls	80009ba6 <quorem+0xb6>
80009ba0:	70 09       	ld.w	r9,r8[0x0]
80009ba2:	58 09       	cp.w	r9,0
80009ba4:	cf 90       	breq	80009b96 <quorem+0xa6>
80009ba6:	8f 46       	st.w	r7[0x10],r6
80009ba8:	0e 9c       	mov	r12,r7
80009baa:	e0 a0 0a d2 	rcall	8000b14e <__mcmp>
80009bae:	c2 d5       	brlt	80009c08 <quorem+0x118>
80009bb0:	2f f5       	sub	r5,-1
80009bb2:	08 98       	mov	r8,r4
80009bb4:	30 09       	mov	r9,0
80009bb6:	07 0b       	ld.w	r11,r3++
80009bb8:	f6 0a 16 10 	lsr	r10,r11,0x10
80009bbc:	70 0c       	ld.w	r12,r8[0x0]
80009bbe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009bc2:	f8 0e 16 10 	lsr	lr,r12,0x10
80009bc6:	14 1e       	sub	lr,r10
80009bc8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009bcc:	16 1a       	sub	r10,r11
80009bce:	12 0a       	add	r10,r9
80009bd0:	b0 1a       	st.h	r8[0x2],r10
80009bd2:	b1 4a       	asr	r10,0x10
80009bd4:	fc 0a 00 09 	add	r9,lr,r10
80009bd8:	b0 09       	st.h	r8[0x0],r9
80009bda:	2f c8       	sub	r8,-4
80009bdc:	b1 49       	asr	r9,0x10
80009bde:	04 33       	cp.w	r3,r2
80009be0:	fe 98 ff eb 	brls	80009bb6 <quorem+0xc6>
80009be4:	ec c8 ff fb 	sub	r8,r6,-5
80009be8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009bec:	58 09       	cp.w	r9,0
80009bee:	c0 d1       	brne	80009c08 <quorem+0x118>
80009bf0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009bf4:	c0 28       	rjmp	80009bf8 <quorem+0x108>
80009bf6:	20 16       	sub	r6,1
80009bf8:	20 48       	sub	r8,4
80009bfa:	08 38       	cp.w	r8,r4
80009bfc:	e0 88 00 05 	brls	80009c06 <quorem+0x116>
80009c00:	70 09       	ld.w	r9,r8[0x0]
80009c02:	58 09       	cp.w	r9,0
80009c04:	cf 90       	breq	80009bf6 <quorem+0x106>
80009c06:	8f 46       	st.w	r7[0x10],r6
80009c08:	0a 9c       	mov	r12,r5
80009c0a:	2f ed       	sub	sp,-8
80009c0c:	d8 32       	popm	r0-r7,pc
80009c0e:	d7 03       	nop

80009c10 <_dtoa_r>:
80009c10:	d4 31       	pushm	r0-r7,lr
80009c12:	21 ad       	sub	sp,104
80009c14:	fa c4 ff 74 	sub	r4,sp,-140
80009c18:	18 97       	mov	r7,r12
80009c1a:	16 95       	mov	r5,r11
80009c1c:	68 2c       	ld.w	r12,r4[0x8]
80009c1e:	50 c9       	stdsp	sp[0x30],r9
80009c20:	68 16       	ld.w	r6,r4[0x4]
80009c22:	68 09       	ld.w	r9,r4[0x0]
80009c24:	50 e8       	stdsp	sp[0x38],r8
80009c26:	14 94       	mov	r4,r10
80009c28:	51 2c       	stdsp	sp[0x48],r12
80009c2a:	fa e5 00 08 	st.d	sp[8],r4
80009c2e:	51 59       	stdsp	sp[0x54],r9
80009c30:	6e 95       	ld.w	r5,r7[0x24]
80009c32:	58 05       	cp.w	r5,0
80009c34:	c0 91       	brne	80009c46 <_dtoa_r+0x36>
80009c36:	31 0c       	mov	r12,16
80009c38:	fe b0 e8 f4 	rcall	80006e20 <malloc>
80009c3c:	99 35       	st.w	r12[0xc],r5
80009c3e:	8f 9c       	st.w	r7[0x24],r12
80009c40:	99 15       	st.w	r12[0x4],r5
80009c42:	99 25       	st.w	r12[0x8],r5
80009c44:	99 05       	st.w	r12[0x0],r5
80009c46:	6e 99       	ld.w	r9,r7[0x24]
80009c48:	72 08       	ld.w	r8,r9[0x0]
80009c4a:	58 08       	cp.w	r8,0
80009c4c:	c0 f0       	breq	80009c6a <_dtoa_r+0x5a>
80009c4e:	72 1a       	ld.w	r10,r9[0x4]
80009c50:	91 1a       	st.w	r8[0x4],r10
80009c52:	30 1a       	mov	r10,1
80009c54:	72 19       	ld.w	r9,r9[0x4]
80009c56:	f4 09 09 49 	lsl	r9,r10,r9
80009c5a:	10 9b       	mov	r11,r8
80009c5c:	91 29       	st.w	r8[0x8],r9
80009c5e:	0e 9c       	mov	r12,r7
80009c60:	e0 a0 0a 90 	rcall	8000b180 <_Bfree>
80009c64:	6e 98       	ld.w	r8,r7[0x24]
80009c66:	30 09       	mov	r9,0
80009c68:	91 09       	st.w	r8[0x0],r9
80009c6a:	40 28       	lddsp	r8,sp[0x8]
80009c6c:	10 94       	mov	r4,r8
80009c6e:	58 08       	cp.w	r8,0
80009c70:	c0 64       	brge	80009c7c <_dtoa_r+0x6c>
80009c72:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009c76:	50 28       	stdsp	sp[0x8],r8
80009c78:	30 18       	mov	r8,1
80009c7a:	c0 28       	rjmp	80009c7e <_dtoa_r+0x6e>
80009c7c:	30 08       	mov	r8,0
80009c7e:	8d 08       	st.w	r6[0x0],r8
80009c80:	fc 1c 7f f0 	movh	r12,0x7ff0
80009c84:	40 26       	lddsp	r6,sp[0x8]
80009c86:	0c 98       	mov	r8,r6
80009c88:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009c8c:	18 38       	cp.w	r8,r12
80009c8e:	c2 01       	brne	80009cce <_dtoa_r+0xbe>
80009c90:	e0 68 27 0f 	mov	r8,9999
80009c94:	41 5b       	lddsp	r11,sp[0x54]
80009c96:	97 08       	st.w	r11[0x0],r8
80009c98:	40 3a       	lddsp	r10,sp[0xc]
80009c9a:	58 0a       	cp.w	r10,0
80009c9c:	c0 71       	brne	80009caa <_dtoa_r+0x9a>
80009c9e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009ca2:	c0 41       	brne	80009caa <_dtoa_r+0x9a>
80009ca4:	fe cc c2 f8 	sub	r12,pc,-15624
80009ca8:	c0 38       	rjmp	80009cae <_dtoa_r+0x9e>
80009caa:	fe cc c2 f2 	sub	r12,pc,-15630
80009cae:	41 29       	lddsp	r9,sp[0x48]
80009cb0:	58 09       	cp.w	r9,0
80009cb2:	e0 80 05 9a 	breq	8000a7e6 <_dtoa_r+0xbd6>
80009cb6:	f8 c8 ff fd 	sub	r8,r12,-3
80009cba:	f8 c9 ff f8 	sub	r9,r12,-8
80009cbe:	11 8b       	ld.ub	r11,r8[0x0]
80009cc0:	30 0a       	mov	r10,0
80009cc2:	41 25       	lddsp	r5,sp[0x48]
80009cc4:	f4 0b 18 00 	cp.b	r11,r10
80009cc8:	f2 08 17 10 	movne	r8,r9
80009ccc:	c1 68       	rjmp	80009cf8 <_dtoa_r+0xe8>
80009cce:	fa ea 00 08 	ld.d	r10,sp[8]
80009cd2:	30 08       	mov	r8,0
80009cd4:	fa eb 00 3c 	st.d	sp[60],r10
80009cd8:	30 09       	mov	r9,0
80009cda:	e0 a0 10 ce 	rcall	8000be76 <__avr32_f64_cmp_eq>
80009cde:	c1 00       	breq	80009cfe <_dtoa_r+0xee>
80009ce0:	30 18       	mov	r8,1
80009ce2:	41 5a       	lddsp	r10,sp[0x54]
80009ce4:	95 08       	st.w	r10[0x0],r8
80009ce6:	fe cc c4 5e 	sub	r12,pc,-15266
80009cea:	41 29       	lddsp	r9,sp[0x48]
80009cec:	f8 08 00 08 	add	r8,r12,r8
80009cf0:	58 09       	cp.w	r9,0
80009cf2:	e0 80 05 7a 	breq	8000a7e6 <_dtoa_r+0xbd6>
80009cf6:	12 95       	mov	r5,r9
80009cf8:	8b 08       	st.w	r5[0x0],r8
80009cfa:	e0 8f 05 76 	bral	8000a7e6 <_dtoa_r+0xbd6>
80009cfe:	fa c8 ff 9c 	sub	r8,sp,-100
80009d02:	fa c9 ff a0 	sub	r9,sp,-96
80009d06:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d0a:	0e 9c       	mov	r12,r7
80009d0c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009d10:	e0 a0 0a 8a 	rcall	8000b224 <__d2b>
80009d14:	18 93       	mov	r3,r12
80009d16:	58 05       	cp.w	r5,0
80009d18:	c0 d0       	breq	80009d32 <_dtoa_r+0x122>
80009d1a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d1e:	30 04       	mov	r4,0
80009d20:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009d24:	ea c5 03 ff 	sub	r5,r5,1023
80009d28:	10 9b       	mov	r11,r8
80009d2a:	51 74       	stdsp	sp[0x5c],r4
80009d2c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009d30:	c2 58       	rjmp	80009d7a <_dtoa_r+0x16a>
80009d32:	41 88       	lddsp	r8,sp[0x60]
80009d34:	41 9c       	lddsp	r12,sp[0x64]
80009d36:	10 0c       	add	r12,r8
80009d38:	f8 c5 fb ce 	sub	r5,r12,-1074
80009d3c:	e0 45 00 20 	cp.w	r5,32
80009d40:	e0 8a 00 0e 	brle	80009d5c <_dtoa_r+0x14c>
80009d44:	f8 cc fb ee 	sub	r12,r12,-1042
80009d48:	40 3b       	lddsp	r11,sp[0xc]
80009d4a:	ea 08 11 40 	rsub	r8,r5,64
80009d4e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009d52:	ec 08 09 46 	lsl	r6,r6,r8
80009d56:	0c 4c       	or	r12,r6
80009d58:	c0 78       	rjmp	80009d66 <_dtoa_r+0x156>
80009d5a:	d7 03       	nop
80009d5c:	ea 0c 11 20 	rsub	r12,r5,32
80009d60:	40 3a       	lddsp	r10,sp[0xc]
80009d62:	f4 0c 09 4c 	lsl	r12,r10,r12
80009d66:	e0 a0 10 14 	rcall	8000bd8e <__avr32_u32_to_f64>
80009d6a:	fc 18 fe 10 	movh	r8,0xfe10
80009d6e:	30 19       	mov	r9,1
80009d70:	ea c5 04 33 	sub	r5,r5,1075
80009d74:	f0 0b 00 0b 	add	r11,r8,r11
80009d78:	51 79       	stdsp	sp[0x5c],r9
80009d7a:	30 08       	mov	r8,0
80009d7c:	fc 19 3f f8 	movh	r9,0x3ff8
80009d80:	e0 a0 0e 9c 	rcall	8000bab8 <__avr32_f64_sub>
80009d84:	e0 68 43 61 	mov	r8,17249
80009d88:	ea 18 63 6f 	orh	r8,0x636f
80009d8c:	e0 69 87 a7 	mov	r9,34727
80009d90:	ea 19 3f d2 	orh	r9,0x3fd2
80009d94:	e0 a0 0d a6 	rcall	8000b8e0 <__avr32_f64_mul>
80009d98:	e0 68 c8 b3 	mov	r8,51379
80009d9c:	ea 18 8b 60 	orh	r8,0x8b60
80009da0:	e0 69 8a 28 	mov	r9,35368
80009da4:	ea 19 3f c6 	orh	r9,0x3fc6
80009da8:	e0 a0 0f 56 	rcall	8000bc54 <__avr32_f64_add>
80009dac:	0a 9c       	mov	r12,r5
80009dae:	14 90       	mov	r0,r10
80009db0:	16 91       	mov	r1,r11
80009db2:	e0 a0 0f f2 	rcall	8000bd96 <__avr32_s32_to_f64>
80009db6:	e0 68 79 fb 	mov	r8,31227
80009dba:	ea 18 50 9f 	orh	r8,0x509f
80009dbe:	e0 69 44 13 	mov	r9,17427
80009dc2:	ea 19 3f d3 	orh	r9,0x3fd3
80009dc6:	e0 a0 0d 8d 	rcall	8000b8e0 <__avr32_f64_mul>
80009dca:	14 98       	mov	r8,r10
80009dcc:	16 99       	mov	r9,r11
80009dce:	00 9a       	mov	r10,r0
80009dd0:	02 9b       	mov	r11,r1
80009dd2:	e0 a0 0f 41 	rcall	8000bc54 <__avr32_f64_add>
80009dd6:	14 90       	mov	r0,r10
80009dd8:	16 91       	mov	r1,r11
80009dda:	e0 a0 0f c7 	rcall	8000bd68 <__avr32_f64_to_s32>
80009dde:	30 08       	mov	r8,0
80009de0:	18 96       	mov	r6,r12
80009de2:	30 09       	mov	r9,0
80009de4:	00 9a       	mov	r10,r0
80009de6:	02 9b       	mov	r11,r1
80009de8:	e0 a0 10 8e 	rcall	8000bf04 <__avr32_f64_cmp_lt>
80009dec:	c0 c0       	breq	80009e04 <_dtoa_r+0x1f4>
80009dee:	0c 9c       	mov	r12,r6
80009df0:	e0 a0 0f d3 	rcall	8000bd96 <__avr32_s32_to_f64>
80009df4:	14 98       	mov	r8,r10
80009df6:	16 99       	mov	r9,r11
80009df8:	00 9a       	mov	r10,r0
80009dfa:	02 9b       	mov	r11,r1
80009dfc:	e0 a0 10 3d 	rcall	8000be76 <__avr32_f64_cmp_eq>
80009e00:	f7 b6 00 01 	subeq	r6,1
80009e04:	59 66       	cp.w	r6,22
80009e06:	e0 88 00 05 	brls	80009e10 <_dtoa_r+0x200>
80009e0a:	30 18       	mov	r8,1
80009e0c:	51 48       	stdsp	sp[0x50],r8
80009e0e:	c1 38       	rjmp	80009e34 <_dtoa_r+0x224>
80009e10:	fe c8 c3 a4 	sub	r8,pc,-15452
80009e14:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e18:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009e1c:	e0 a0 10 74 	rcall	8000bf04 <__avr32_f64_cmp_lt>
80009e20:	f9 b4 00 00 	moveq	r4,0
80009e24:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009e28:	f7 b6 01 01 	subne	r6,1
80009e2c:	f9 bc 01 00 	movne	r12,0
80009e30:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009e34:	41 90       	lddsp	r0,sp[0x64]
80009e36:	20 10       	sub	r0,1
80009e38:	0a 10       	sub	r0,r5
80009e3a:	c0 46       	brmi	80009e42 <_dtoa_r+0x232>
80009e3c:	50 40       	stdsp	sp[0x10],r0
80009e3e:	30 00       	mov	r0,0
80009e40:	c0 48       	rjmp	80009e48 <_dtoa_r+0x238>
80009e42:	30 0b       	mov	r11,0
80009e44:	5c 30       	neg	r0
80009e46:	50 4b       	stdsp	sp[0x10],r11
80009e48:	ec 02 11 00 	rsub	r2,r6,0
80009e4c:	58 06       	cp.w	r6,0
80009e4e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009e52:	f5 d6 e4 0a 	addge	r10,r10,r6
80009e56:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009e5a:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009e5e:	f9 b2 04 00 	movge	r2,0
80009e62:	e1 d6 e5 10 	sublt	r0,r0,r6
80009e66:	f9 b9 05 00 	movlt	r9,0
80009e6a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009e6e:	40 c8       	lddsp	r8,sp[0x30]
80009e70:	58 98       	cp.w	r8,9
80009e72:	e0 8b 00 20 	brhi	80009eb2 <_dtoa_r+0x2a2>
80009e76:	58 58       	cp.w	r8,5
80009e78:	f9 b4 0a 01 	movle	r4,1
80009e7c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009e80:	f7 b5 09 04 	subgt	r5,4
80009e84:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009e88:	f9 b4 09 00 	movgt	r4,0
80009e8c:	40 cc       	lddsp	r12,sp[0x30]
80009e8e:	58 3c       	cp.w	r12,3
80009e90:	c2 d0       	breq	80009eea <_dtoa_r+0x2da>
80009e92:	e0 89 00 05 	brgt	80009e9c <_dtoa_r+0x28c>
80009e96:	58 2c       	cp.w	r12,2
80009e98:	c1 01       	brne	80009eb8 <_dtoa_r+0x2a8>
80009e9a:	c1 88       	rjmp	80009eca <_dtoa_r+0x2ba>
80009e9c:	40 cb       	lddsp	r11,sp[0x30]
80009e9e:	58 4b       	cp.w	r11,4
80009ea0:	c0 60       	breq	80009eac <_dtoa_r+0x29c>
80009ea2:	58 5b       	cp.w	r11,5
80009ea4:	c0 a1       	brne	80009eb8 <_dtoa_r+0x2a8>
80009ea6:	30 1a       	mov	r10,1
80009ea8:	50 da       	stdsp	sp[0x34],r10
80009eaa:	c2 28       	rjmp	80009eee <_dtoa_r+0x2de>
80009eac:	30 19       	mov	r9,1
80009eae:	50 d9       	stdsp	sp[0x34],r9
80009eb0:	c0 f8       	rjmp	80009ece <_dtoa_r+0x2be>
80009eb2:	30 08       	mov	r8,0
80009eb4:	30 14       	mov	r4,1
80009eb6:	50 c8       	stdsp	sp[0x30],r8
80009eb8:	3f f5       	mov	r5,-1
80009eba:	30 1c       	mov	r12,1
80009ebc:	30 0b       	mov	r11,0
80009ebe:	50 95       	stdsp	sp[0x24],r5
80009ec0:	50 dc       	stdsp	sp[0x34],r12
80009ec2:	0a 91       	mov	r1,r5
80009ec4:	31 28       	mov	r8,18
80009ec6:	50 eb       	stdsp	sp[0x38],r11
80009ec8:	c2 08       	rjmp	80009f08 <_dtoa_r+0x2f8>
80009eca:	30 0a       	mov	r10,0
80009ecc:	50 da       	stdsp	sp[0x34],r10
80009ece:	40 e9       	lddsp	r9,sp[0x38]
80009ed0:	58 09       	cp.w	r9,0
80009ed2:	e0 89 00 07 	brgt	80009ee0 <_dtoa_r+0x2d0>
80009ed6:	30 18       	mov	r8,1
80009ed8:	50 98       	stdsp	sp[0x24],r8
80009eda:	10 91       	mov	r1,r8
80009edc:	50 e8       	stdsp	sp[0x38],r8
80009ede:	c1 58       	rjmp	80009f08 <_dtoa_r+0x2f8>
80009ee0:	40 e5       	lddsp	r5,sp[0x38]
80009ee2:	50 95       	stdsp	sp[0x24],r5
80009ee4:	0a 91       	mov	r1,r5
80009ee6:	0a 98       	mov	r8,r5
80009ee8:	c1 08       	rjmp	80009f08 <_dtoa_r+0x2f8>
80009eea:	30 0c       	mov	r12,0
80009eec:	50 dc       	stdsp	sp[0x34],r12
80009eee:	40 eb       	lddsp	r11,sp[0x38]
80009ef0:	ec 0b 00 0b 	add	r11,r6,r11
80009ef4:	50 9b       	stdsp	sp[0x24],r11
80009ef6:	16 98       	mov	r8,r11
80009ef8:	2f f8       	sub	r8,-1
80009efa:	58 08       	cp.w	r8,0
80009efc:	e0 89 00 05 	brgt	80009f06 <_dtoa_r+0x2f6>
80009f00:	10 91       	mov	r1,r8
80009f02:	30 18       	mov	r8,1
80009f04:	c0 28       	rjmp	80009f08 <_dtoa_r+0x2f8>
80009f06:	10 91       	mov	r1,r8
80009f08:	30 09       	mov	r9,0
80009f0a:	6e 9a       	ld.w	r10,r7[0x24]
80009f0c:	95 19       	st.w	r10[0x4],r9
80009f0e:	30 49       	mov	r9,4
80009f10:	c0 68       	rjmp	80009f1c <_dtoa_r+0x30c>
80009f12:	d7 03       	nop
80009f14:	6a 1a       	ld.w	r10,r5[0x4]
80009f16:	a1 79       	lsl	r9,0x1
80009f18:	2f fa       	sub	r10,-1
80009f1a:	8b 1a       	st.w	r5[0x4],r10
80009f1c:	6e 95       	ld.w	r5,r7[0x24]
80009f1e:	f2 ca ff ec 	sub	r10,r9,-20
80009f22:	10 3a       	cp.w	r10,r8
80009f24:	fe 98 ff f8 	brls	80009f14 <_dtoa_r+0x304>
80009f28:	6a 1b       	ld.w	r11,r5[0x4]
80009f2a:	0e 9c       	mov	r12,r7
80009f2c:	e0 a0 09 44 	rcall	8000b1b4 <_Balloc>
80009f30:	58 e1       	cp.w	r1,14
80009f32:	5f 88       	srls	r8
80009f34:	8b 0c       	st.w	r5[0x0],r12
80009f36:	f1 e4 00 04 	and	r4,r8,r4
80009f3a:	6e 98       	ld.w	r8,r7[0x24]
80009f3c:	70 08       	ld.w	r8,r8[0x0]
80009f3e:	50 88       	stdsp	sp[0x20],r8
80009f40:	e0 80 01 82 	breq	8000a244 <_dtoa_r+0x634>
80009f44:	58 06       	cp.w	r6,0
80009f46:	e0 8a 00 43 	brle	80009fcc <_dtoa_r+0x3bc>
80009f4a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009f4e:	fe c8 c4 e2 	sub	r8,pc,-15134
80009f52:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009f56:	fa e5 00 18 	st.d	sp[24],r4
80009f5a:	ec 04 14 04 	asr	r4,r6,0x4
80009f5e:	ed b4 00 04 	bld	r4,0x4
80009f62:	c0 30       	breq	80009f68 <_dtoa_r+0x358>
80009f64:	30 25       	mov	r5,2
80009f66:	c1 08       	rjmp	80009f86 <_dtoa_r+0x376>
80009f68:	fe c8 c4 34 	sub	r8,pc,-15308
80009f6c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009f70:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f74:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009f78:	e0 a0 0f fa 	rcall	8000bf6c <__avr32_f64_div>
80009f7c:	30 35       	mov	r5,3
80009f7e:	14 98       	mov	r8,r10
80009f80:	16 99       	mov	r9,r11
80009f82:	fa e9 00 08 	st.d	sp[8],r8
80009f86:	fe cc c4 52 	sub	r12,pc,-15278
80009f8a:	50 a3       	stdsp	sp[0x28],r3
80009f8c:	0c 93       	mov	r3,r6
80009f8e:	18 96       	mov	r6,r12
80009f90:	c0 f8       	rjmp	80009fae <_dtoa_r+0x39e>
80009f92:	fa ea 00 18 	ld.d	r10,sp[24]
80009f96:	ed b4 00 00 	bld	r4,0x0
80009f9a:	c0 81       	brne	80009faa <_dtoa_r+0x39a>
80009f9c:	ec e8 00 00 	ld.d	r8,r6[0]
80009fa0:	2f f5       	sub	r5,-1
80009fa2:	e0 a0 0c 9f 	rcall	8000b8e0 <__avr32_f64_mul>
80009fa6:	fa eb 00 18 	st.d	sp[24],r10
80009faa:	a1 54       	asr	r4,0x1
80009fac:	2f 86       	sub	r6,-8
80009fae:	58 04       	cp.w	r4,0
80009fb0:	cf 11       	brne	80009f92 <_dtoa_r+0x382>
80009fb2:	fa e8 00 18 	ld.d	r8,sp[24]
80009fb6:	fa ea 00 08 	ld.d	r10,sp[8]
80009fba:	06 96       	mov	r6,r3
80009fbc:	e0 a0 0f d8 	rcall	8000bf6c <__avr32_f64_div>
80009fc0:	40 a3       	lddsp	r3,sp[0x28]
80009fc2:	14 98       	mov	r8,r10
80009fc4:	16 99       	mov	r9,r11
80009fc6:	fa e9 00 08 	st.d	sp[8],r8
80009fca:	c2 f8       	rjmp	8000a028 <_dtoa_r+0x418>
80009fcc:	ec 08 11 00 	rsub	r8,r6,0
80009fd0:	c0 31       	brne	80009fd6 <_dtoa_r+0x3c6>
80009fd2:	30 25       	mov	r5,2
80009fd4:	c2 a8       	rjmp	8000a028 <_dtoa_r+0x418>
80009fd6:	fe cc c4 a2 	sub	r12,pc,-15198
80009fda:	f0 04 14 04 	asr	r4,r8,0x4
80009fde:	50 1c       	stdsp	sp[0x4],r12
80009fe0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009fe4:	fe c9 c5 78 	sub	r9,pc,-14984
80009fe8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009fec:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ff0:	e0 a0 0c 78 	rcall	8000b8e0 <__avr32_f64_mul>
80009ff4:	40 1c       	lddsp	r12,sp[0x4]
80009ff6:	50 63       	stdsp	sp[0x18],r3
80009ff8:	30 25       	mov	r5,2
80009ffa:	0c 93       	mov	r3,r6
80009ffc:	fa eb 00 08 	st.d	sp[8],r10
8000a000:	18 96       	mov	r6,r12
8000a002:	c0 f8       	rjmp	8000a020 <_dtoa_r+0x410>
8000a004:	fa ea 00 08 	ld.d	r10,sp[8]
8000a008:	ed b4 00 00 	bld	r4,0x0
8000a00c:	c0 81       	brne	8000a01c <_dtoa_r+0x40c>
8000a00e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a012:	2f f5       	sub	r5,-1
8000a014:	e0 a0 0c 66 	rcall	8000b8e0 <__avr32_f64_mul>
8000a018:	fa eb 00 08 	st.d	sp[8],r10
8000a01c:	a1 54       	asr	r4,0x1
8000a01e:	2f 86       	sub	r6,-8
8000a020:	58 04       	cp.w	r4,0
8000a022:	cf 11       	brne	8000a004 <_dtoa_r+0x3f4>
8000a024:	06 96       	mov	r6,r3
8000a026:	40 63       	lddsp	r3,sp[0x18]
8000a028:	41 4a       	lddsp	r10,sp[0x50]
8000a02a:	58 0a       	cp.w	r10,0
8000a02c:	c2 a0       	breq	8000a080 <_dtoa_r+0x470>
8000a02e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a032:	58 01       	cp.w	r1,0
8000a034:	5f 94       	srgt	r4
8000a036:	fa e9 00 18 	st.d	sp[24],r8
8000a03a:	30 08       	mov	r8,0
8000a03c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a040:	fa ea 00 18 	ld.d	r10,sp[24]
8000a044:	e0 a0 0f 60 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a048:	f9 bc 00 00 	moveq	r12,0
8000a04c:	f9 bc 01 01 	movne	r12,1
8000a050:	e9 ec 00 0c 	and	r12,r4,r12
8000a054:	c1 60       	breq	8000a080 <_dtoa_r+0x470>
8000a056:	40 98       	lddsp	r8,sp[0x24]
8000a058:	58 08       	cp.w	r8,0
8000a05a:	e0 8a 00 f1 	brle	8000a23c <_dtoa_r+0x62c>
8000a05e:	30 08       	mov	r8,0
8000a060:	fc 19 40 24 	movh	r9,0x4024
8000a064:	ec c4 00 01 	sub	r4,r6,1
8000a068:	fa ea 00 18 	ld.d	r10,sp[24]
8000a06c:	2f f5       	sub	r5,-1
8000a06e:	50 64       	stdsp	sp[0x18],r4
8000a070:	e0 a0 0c 38 	rcall	8000b8e0 <__avr32_f64_mul>
8000a074:	40 94       	lddsp	r4,sp[0x24]
8000a076:	14 98       	mov	r8,r10
8000a078:	16 99       	mov	r9,r11
8000a07a:	fa e9 00 08 	st.d	sp[8],r8
8000a07e:	c0 38       	rjmp	8000a084 <_dtoa_r+0x474>
8000a080:	50 66       	stdsp	sp[0x18],r6
8000a082:	02 94       	mov	r4,r1
8000a084:	0a 9c       	mov	r12,r5
8000a086:	e0 a0 0e 88 	rcall	8000bd96 <__avr32_s32_to_f64>
8000a08a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a08e:	e0 a0 0c 29 	rcall	8000b8e0 <__avr32_f64_mul>
8000a092:	30 08       	mov	r8,0
8000a094:	fc 19 40 1c 	movh	r9,0x401c
8000a098:	e0 a0 0d de 	rcall	8000bc54 <__avr32_f64_add>
8000a09c:	14 98       	mov	r8,r10
8000a09e:	16 99       	mov	r9,r11
8000a0a0:	fa e9 00 28 	st.d	sp[40],r8
8000a0a4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a0a8:	40 a5       	lddsp	r5,sp[0x28]
8000a0aa:	10 05       	add	r5,r8
8000a0ac:	50 a5       	stdsp	sp[0x28],r5
8000a0ae:	58 04       	cp.w	r4,0
8000a0b0:	c2 11       	brne	8000a0f2 <_dtoa_r+0x4e2>
8000a0b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0b6:	30 08       	mov	r8,0
8000a0b8:	fc 19 40 14 	movh	r9,0x4014
8000a0bc:	e0 a0 0c fe 	rcall	8000bab8 <__avr32_f64_sub>
8000a0c0:	40 bc       	lddsp	r12,sp[0x2c]
8000a0c2:	fa eb 00 08 	st.d	sp[8],r10
8000a0c6:	14 98       	mov	r8,r10
8000a0c8:	16 99       	mov	r9,r11
8000a0ca:	18 9a       	mov	r10,r12
8000a0cc:	0a 9b       	mov	r11,r5
8000a0ce:	e0 a0 0f 1b 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a0d2:	e0 81 02 54 	brne	8000a57a <_dtoa_r+0x96a>
8000a0d6:	0a 98       	mov	r8,r5
8000a0d8:	40 b9       	lddsp	r9,sp[0x2c]
8000a0da:	ee 18 80 00 	eorh	r8,0x8000
8000a0de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0e2:	10 95       	mov	r5,r8
8000a0e4:	12 98       	mov	r8,r9
8000a0e6:	0a 99       	mov	r9,r5
8000a0e8:	e0 a0 0f 0e 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a0ec:	e0 81 02 3e 	brne	8000a568 <_dtoa_r+0x958>
8000a0f0:	ca 68       	rjmp	8000a23c <_dtoa_r+0x62c>
8000a0f2:	fe c9 c6 86 	sub	r9,pc,-14714
8000a0f6:	e8 c8 00 01 	sub	r8,r4,1
8000a0fa:	40 d5       	lddsp	r5,sp[0x34]
8000a0fc:	58 05       	cp.w	r5,0
8000a0fe:	c4 f0       	breq	8000a19c <_dtoa_r+0x58c>
8000a100:	30 0c       	mov	r12,0
8000a102:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a106:	51 3c       	stdsp	sp[0x4c],r12
8000a108:	30 0a       	mov	r10,0
8000a10a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a10e:	e0 a0 0f 2f 	rcall	8000bf6c <__avr32_f64_div>
8000a112:	fa e8 00 28 	ld.d	r8,sp[40]
8000a116:	40 85       	lddsp	r5,sp[0x20]
8000a118:	e0 a0 0c d0 	rcall	8000bab8 <__avr32_f64_sub>
8000a11c:	fa eb 00 28 	st.d	sp[40],r10
8000a120:	fa ea 00 08 	ld.d	r10,sp[8]
8000a124:	e0 a0 0e 22 	rcall	8000bd68 <__avr32_f64_to_s32>
8000a128:	51 6c       	stdsp	sp[0x58],r12
8000a12a:	e0 a0 0e 36 	rcall	8000bd96 <__avr32_s32_to_f64>
8000a12e:	14 98       	mov	r8,r10
8000a130:	16 99       	mov	r9,r11
8000a132:	fa ea 00 08 	ld.d	r10,sp[8]
8000a136:	e0 a0 0c c1 	rcall	8000bab8 <__avr32_f64_sub>
8000a13a:	fa eb 00 08 	st.d	sp[8],r10
8000a13e:	41 68       	lddsp	r8,sp[0x58]
8000a140:	2d 08       	sub	r8,-48
8000a142:	0a c8       	st.b	r5++,r8
8000a144:	41 39       	lddsp	r9,sp[0x4c]
8000a146:	2f f9       	sub	r9,-1
8000a148:	51 39       	stdsp	sp[0x4c],r9
8000a14a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a14e:	e0 a0 0e db 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a152:	e0 81 03 39 	brne	8000a7c4 <_dtoa_r+0xbb4>
8000a156:	fa e8 00 08 	ld.d	r8,sp[8]
8000a15a:	30 0a       	mov	r10,0
8000a15c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a160:	e0 a0 0c ac 	rcall	8000bab8 <__avr32_f64_sub>
8000a164:	fa e8 00 28 	ld.d	r8,sp[40]
8000a168:	e0 a0 0e ce 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a16c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a170:	30 08       	mov	r8,0
8000a172:	fc 19 40 24 	movh	r9,0x4024
8000a176:	e0 81 00 da 	brne	8000a32a <_dtoa_r+0x71a>
8000a17a:	41 3c       	lddsp	r12,sp[0x4c]
8000a17c:	08 3c       	cp.w	r12,r4
8000a17e:	c5 f4       	brge	8000a23c <_dtoa_r+0x62c>
8000a180:	e0 a0 0b b0 	rcall	8000b8e0 <__avr32_f64_mul>
8000a184:	30 08       	mov	r8,0
8000a186:	fa eb 00 28 	st.d	sp[40],r10
8000a18a:	fc 19 40 24 	movh	r9,0x4024
8000a18e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a192:	e0 a0 0b a7 	rcall	8000b8e0 <__avr32_f64_mul>
8000a196:	fa eb 00 08 	st.d	sp[8],r10
8000a19a:	cc 3b       	rjmp	8000a120 <_dtoa_r+0x510>
8000a19c:	40 85       	lddsp	r5,sp[0x20]
8000a19e:	08 05       	add	r5,r4
8000a1a0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a1a4:	51 35       	stdsp	sp[0x4c],r5
8000a1a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1aa:	40 85       	lddsp	r5,sp[0x20]
8000a1ac:	e0 a0 0b 9a 	rcall	8000b8e0 <__avr32_f64_mul>
8000a1b0:	fa eb 00 28 	st.d	sp[40],r10
8000a1b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1b8:	e0 a0 0d d8 	rcall	8000bd68 <__avr32_f64_to_s32>
8000a1bc:	51 6c       	stdsp	sp[0x58],r12
8000a1be:	e0 a0 0d ec 	rcall	8000bd96 <__avr32_s32_to_f64>
8000a1c2:	14 98       	mov	r8,r10
8000a1c4:	16 99       	mov	r9,r11
8000a1c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1ca:	e0 a0 0c 77 	rcall	8000bab8 <__avr32_f64_sub>
8000a1ce:	fa eb 00 08 	st.d	sp[8],r10
8000a1d2:	41 68       	lddsp	r8,sp[0x58]
8000a1d4:	2d 08       	sub	r8,-48
8000a1d6:	0a c8       	st.b	r5++,r8
8000a1d8:	41 3c       	lddsp	r12,sp[0x4c]
8000a1da:	18 35       	cp.w	r5,r12
8000a1dc:	c2 81       	brne	8000a22c <_dtoa_r+0x61c>
8000a1de:	30 08       	mov	r8,0
8000a1e0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a1e4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a1e8:	e0 a0 0d 36 	rcall	8000bc54 <__avr32_f64_add>
8000a1ec:	40 85       	lddsp	r5,sp[0x20]
8000a1ee:	fa e8 00 08 	ld.d	r8,sp[8]
8000a1f2:	08 05       	add	r5,r4
8000a1f4:	e0 a0 0e 88 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a1f8:	e0 81 00 99 	brne	8000a32a <_dtoa_r+0x71a>
8000a1fc:	fa e8 00 28 	ld.d	r8,sp[40]
8000a200:	30 0a       	mov	r10,0
8000a202:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a206:	e0 a0 0c 59 	rcall	8000bab8 <__avr32_f64_sub>
8000a20a:	14 98       	mov	r8,r10
8000a20c:	16 99       	mov	r9,r11
8000a20e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a212:	e0 a0 0e 79 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a216:	c1 30       	breq	8000a23c <_dtoa_r+0x62c>
8000a218:	33 09       	mov	r9,48
8000a21a:	0a 98       	mov	r8,r5
8000a21c:	11 7a       	ld.ub	r10,--r8
8000a21e:	f2 0a 18 00 	cp.b	r10,r9
8000a222:	e0 81 02 d1 	brne	8000a7c4 <_dtoa_r+0xbb4>
8000a226:	10 95       	mov	r5,r8
8000a228:	cf 9b       	rjmp	8000a21a <_dtoa_r+0x60a>
8000a22a:	d7 03       	nop
8000a22c:	30 08       	mov	r8,0
8000a22e:	fc 19 40 24 	movh	r9,0x4024
8000a232:	e0 a0 0b 57 	rcall	8000b8e0 <__avr32_f64_mul>
8000a236:	fa eb 00 08 	st.d	sp[8],r10
8000a23a:	cb db       	rjmp	8000a1b4 <_dtoa_r+0x5a4>
8000a23c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a240:	fa eb 00 08 	st.d	sp[8],r10
8000a244:	58 e6       	cp.w	r6,14
8000a246:	5f ab       	srle	r11
8000a248:	41 8a       	lddsp	r10,sp[0x60]
8000a24a:	30 08       	mov	r8,0
8000a24c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a250:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a254:	f0 09 18 00 	cp.b	r9,r8
8000a258:	e0 80 00 82 	breq	8000a35c <_dtoa_r+0x74c>
8000a25c:	40 ea       	lddsp	r10,sp[0x38]
8000a25e:	58 01       	cp.w	r1,0
8000a260:	5f a9       	srle	r9
8000a262:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a266:	fe ca c7 fa 	sub	r10,pc,-14342
8000a26a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a26e:	fa e5 00 10 	st.d	sp[16],r4
8000a272:	f0 09 18 00 	cp.b	r9,r8
8000a276:	c1 40       	breq	8000a29e <_dtoa_r+0x68e>
8000a278:	58 01       	cp.w	r1,0
8000a27a:	e0 81 01 77 	brne	8000a568 <_dtoa_r+0x958>
8000a27e:	30 08       	mov	r8,0
8000a280:	fc 19 40 14 	movh	r9,0x4014
8000a284:	08 9a       	mov	r10,r4
8000a286:	0a 9b       	mov	r11,r5
8000a288:	e0 a0 0b 2c 	rcall	8000b8e0 <__avr32_f64_mul>
8000a28c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a290:	e0 a0 0e 06 	rcall	8000be9c <__avr32_f64_cmp_ge>
8000a294:	e0 81 01 6a 	brne	8000a568 <_dtoa_r+0x958>
8000a298:	02 92       	mov	r2,r1
8000a29a:	e0 8f 01 72 	bral	8000a57e <_dtoa_r+0x96e>
8000a29e:	40 85       	lddsp	r5,sp[0x20]
8000a2a0:	30 14       	mov	r4,1
8000a2a2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2aa:	e0 a0 0e 61 	rcall	8000bf6c <__avr32_f64_div>
8000a2ae:	e0 a0 0d 5d 	rcall	8000bd68 <__avr32_f64_to_s32>
8000a2b2:	18 92       	mov	r2,r12
8000a2b4:	e0 a0 0d 71 	rcall	8000bd96 <__avr32_s32_to_f64>
8000a2b8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2bc:	e0 a0 0b 12 	rcall	8000b8e0 <__avr32_f64_mul>
8000a2c0:	14 98       	mov	r8,r10
8000a2c2:	16 99       	mov	r9,r11
8000a2c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2c8:	e0 a0 0b f8 	rcall	8000bab8 <__avr32_f64_sub>
8000a2cc:	fa eb 00 08 	st.d	sp[8],r10
8000a2d0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a2d4:	0a c8       	st.b	r5++,r8
8000a2d6:	fc 19 40 24 	movh	r9,0x4024
8000a2da:	30 08       	mov	r8,0
8000a2dc:	02 34       	cp.w	r4,r1
8000a2de:	c3 31       	brne	8000a344 <_dtoa_r+0x734>
8000a2e0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2e4:	e0 a0 0c b8 	rcall	8000bc54 <__avr32_f64_add>
8000a2e8:	16 91       	mov	r1,r11
8000a2ea:	14 90       	mov	r0,r10
8000a2ec:	14 98       	mov	r8,r10
8000a2ee:	02 99       	mov	r9,r1
8000a2f0:	fa ea 00 10 	ld.d	r10,sp[16]
8000a2f4:	e0 a0 0e 08 	rcall	8000bf04 <__avr32_f64_cmp_lt>
8000a2f8:	c1 a1       	brne	8000a32c <_dtoa_r+0x71c>
8000a2fa:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2fe:	00 9a       	mov	r10,r0
8000a300:	02 9b       	mov	r11,r1
8000a302:	e0 a0 0d ba 	rcall	8000be76 <__avr32_f64_cmp_eq>
8000a306:	e0 80 02 5e 	breq	8000a7c2 <_dtoa_r+0xbb2>
8000a30a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a30e:	c0 f1       	brne	8000a32c <_dtoa_r+0x71c>
8000a310:	e0 8f 02 59 	bral	8000a7c2 <_dtoa_r+0xbb2>
8000a314:	40 8a       	lddsp	r10,sp[0x20]
8000a316:	14 38       	cp.w	r8,r10
8000a318:	c0 30       	breq	8000a31e <_dtoa_r+0x70e>
8000a31a:	10 95       	mov	r5,r8
8000a31c:	c0 98       	rjmp	8000a32e <_dtoa_r+0x71e>
8000a31e:	33 08       	mov	r8,48
8000a320:	40 89       	lddsp	r9,sp[0x20]
8000a322:	2f f6       	sub	r6,-1
8000a324:	b2 88       	st.b	r9[0x0],r8
8000a326:	40 88       	lddsp	r8,sp[0x20]
8000a328:	c0 88       	rjmp	8000a338 <_dtoa_r+0x728>
8000a32a:	40 66       	lddsp	r6,sp[0x18]
8000a32c:	33 99       	mov	r9,57
8000a32e:	0a 98       	mov	r8,r5
8000a330:	11 7a       	ld.ub	r10,--r8
8000a332:	f2 0a 18 00 	cp.b	r10,r9
8000a336:	ce f0       	breq	8000a314 <_dtoa_r+0x704>
8000a338:	50 66       	stdsp	sp[0x18],r6
8000a33a:	11 89       	ld.ub	r9,r8[0x0]
8000a33c:	2f f9       	sub	r9,-1
8000a33e:	b0 89       	st.b	r8[0x0],r9
8000a340:	e0 8f 02 42 	bral	8000a7c4 <_dtoa_r+0xbb4>
8000a344:	e0 a0 0a ce 	rcall	8000b8e0 <__avr32_f64_mul>
8000a348:	2f f4       	sub	r4,-1
8000a34a:	fa eb 00 08 	st.d	sp[8],r10
8000a34e:	30 08       	mov	r8,0
8000a350:	30 09       	mov	r9,0
8000a352:	e0 a0 0d 92 	rcall	8000be76 <__avr32_f64_cmp_eq>
8000a356:	ca 60       	breq	8000a2a2 <_dtoa_r+0x692>
8000a358:	e0 8f 02 35 	bral	8000a7c2 <_dtoa_r+0xbb2>
8000a35c:	40 d8       	lddsp	r8,sp[0x34]
8000a35e:	58 08       	cp.w	r8,0
8000a360:	c0 51       	brne	8000a36a <_dtoa_r+0x75a>
8000a362:	04 98       	mov	r8,r2
8000a364:	00 95       	mov	r5,r0
8000a366:	40 d4       	lddsp	r4,sp[0x34]
8000a368:	c3 78       	rjmp	8000a3d6 <_dtoa_r+0x7c6>
8000a36a:	40 c5       	lddsp	r5,sp[0x30]
8000a36c:	58 15       	cp.w	r5,1
8000a36e:	e0 89 00 0f 	brgt	8000a38c <_dtoa_r+0x77c>
8000a372:	41 74       	lddsp	r4,sp[0x5c]
8000a374:	58 04       	cp.w	r4,0
8000a376:	c0 40       	breq	8000a37e <_dtoa_r+0x76e>
8000a378:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a37c:	c0 48       	rjmp	8000a384 <_dtoa_r+0x774>
8000a37e:	41 99       	lddsp	r9,sp[0x64]
8000a380:	f2 09 11 36 	rsub	r9,r9,54
8000a384:	04 98       	mov	r8,r2
8000a386:	00 95       	mov	r5,r0
8000a388:	c1 c8       	rjmp	8000a3c0 <_dtoa_r+0x7b0>
8000a38a:	d7 03       	nop
8000a38c:	e2 c8 00 01 	sub	r8,r1,1
8000a390:	58 01       	cp.w	r1,0
8000a392:	e0 05 17 40 	movge	r5,r0
8000a396:	e2 09 17 40 	movge	r9,r1
8000a39a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a39e:	f9 b9 05 00 	movlt	r9,0
8000a3a2:	10 32       	cp.w	r2,r8
8000a3a4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a3a8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a3ac:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a3b0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a3b4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a3b8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a3bc:	f9 b8 05 00 	movlt	r8,0
8000a3c0:	40 4b       	lddsp	r11,sp[0x10]
8000a3c2:	12 0b       	add	r11,r9
8000a3c4:	50 08       	stdsp	sp[0x0],r8
8000a3c6:	50 4b       	stdsp	sp[0x10],r11
8000a3c8:	12 00       	add	r0,r9
8000a3ca:	30 1b       	mov	r11,1
8000a3cc:	0e 9c       	mov	r12,r7
8000a3ce:	e0 a0 08 a7 	rcall	8000b51c <__i2b>
8000a3d2:	40 08       	lddsp	r8,sp[0x0]
8000a3d4:	18 94       	mov	r4,r12
8000a3d6:	40 4a       	lddsp	r10,sp[0x10]
8000a3d8:	58 05       	cp.w	r5,0
8000a3da:	5f 99       	srgt	r9
8000a3dc:	58 0a       	cp.w	r10,0
8000a3de:	5f 9a       	srgt	r10
8000a3e0:	f5 e9 00 09 	and	r9,r10,r9
8000a3e4:	c0 80       	breq	8000a3f4 <_dtoa_r+0x7e4>
8000a3e6:	40 4c       	lddsp	r12,sp[0x10]
8000a3e8:	f8 05 0d 49 	min	r9,r12,r5
8000a3ec:	12 1c       	sub	r12,r9
8000a3ee:	12 10       	sub	r0,r9
8000a3f0:	50 4c       	stdsp	sp[0x10],r12
8000a3f2:	12 15       	sub	r5,r9
8000a3f4:	58 02       	cp.w	r2,0
8000a3f6:	e0 8a 00 27 	brle	8000a444 <_dtoa_r+0x834>
8000a3fa:	40 db       	lddsp	r11,sp[0x34]
8000a3fc:	58 0b       	cp.w	r11,0
8000a3fe:	c1 d0       	breq	8000a438 <_dtoa_r+0x828>
8000a400:	58 08       	cp.w	r8,0
8000a402:	e0 8a 00 17 	brle	8000a430 <_dtoa_r+0x820>
8000a406:	10 9a       	mov	r10,r8
8000a408:	50 08       	stdsp	sp[0x0],r8
8000a40a:	08 9b       	mov	r11,r4
8000a40c:	0e 9c       	mov	r12,r7
8000a40e:	e0 a0 08 cd 	rcall	8000b5a8 <__pow5mult>
8000a412:	06 9a       	mov	r10,r3
8000a414:	18 9b       	mov	r11,r12
8000a416:	18 94       	mov	r4,r12
8000a418:	0e 9c       	mov	r12,r7
8000a41a:	e0 a0 08 01 	rcall	8000b41c <__multiply>
8000a41e:	18 99       	mov	r9,r12
8000a420:	06 9b       	mov	r11,r3
8000a422:	50 19       	stdsp	sp[0x4],r9
8000a424:	0e 9c       	mov	r12,r7
8000a426:	e0 a0 06 ad 	rcall	8000b180 <_Bfree>
8000a42a:	40 19       	lddsp	r9,sp[0x4]
8000a42c:	40 08       	lddsp	r8,sp[0x0]
8000a42e:	12 93       	mov	r3,r9
8000a430:	e4 08 01 0a 	sub	r10,r2,r8
8000a434:	c0 80       	breq	8000a444 <_dtoa_r+0x834>
8000a436:	c0 28       	rjmp	8000a43a <_dtoa_r+0x82a>
8000a438:	04 9a       	mov	r10,r2
8000a43a:	06 9b       	mov	r11,r3
8000a43c:	0e 9c       	mov	r12,r7
8000a43e:	e0 a0 08 b5 	rcall	8000b5a8 <__pow5mult>
8000a442:	18 93       	mov	r3,r12
8000a444:	30 1b       	mov	r11,1
8000a446:	0e 9c       	mov	r12,r7
8000a448:	e0 a0 08 6a 	rcall	8000b51c <__i2b>
8000a44c:	41 1a       	lddsp	r10,sp[0x44]
8000a44e:	18 92       	mov	r2,r12
8000a450:	58 0a       	cp.w	r10,0
8000a452:	e0 8a 00 07 	brle	8000a460 <_dtoa_r+0x850>
8000a456:	18 9b       	mov	r11,r12
8000a458:	0e 9c       	mov	r12,r7
8000a45a:	e0 a0 08 a7 	rcall	8000b5a8 <__pow5mult>
8000a45e:	18 92       	mov	r2,r12
8000a460:	40 c9       	lddsp	r9,sp[0x30]
8000a462:	58 19       	cp.w	r9,1
8000a464:	e0 89 00 14 	brgt	8000a48c <_dtoa_r+0x87c>
8000a468:	40 38       	lddsp	r8,sp[0xc]
8000a46a:	58 08       	cp.w	r8,0
8000a46c:	c1 01       	brne	8000a48c <_dtoa_r+0x87c>
8000a46e:	40 29       	lddsp	r9,sp[0x8]
8000a470:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a474:	c0 c1       	brne	8000a48c <_dtoa_r+0x87c>
8000a476:	12 98       	mov	r8,r9
8000a478:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a47c:	c0 80       	breq	8000a48c <_dtoa_r+0x87c>
8000a47e:	40 4c       	lddsp	r12,sp[0x10]
8000a480:	30 1b       	mov	r11,1
8000a482:	2f fc       	sub	r12,-1
8000a484:	2f f0       	sub	r0,-1
8000a486:	50 4c       	stdsp	sp[0x10],r12
8000a488:	50 6b       	stdsp	sp[0x18],r11
8000a48a:	c0 38       	rjmp	8000a490 <_dtoa_r+0x880>
8000a48c:	30 0a       	mov	r10,0
8000a48e:	50 6a       	stdsp	sp[0x18],r10
8000a490:	41 19       	lddsp	r9,sp[0x44]
8000a492:	58 09       	cp.w	r9,0
8000a494:	c0 31       	brne	8000a49a <_dtoa_r+0x88a>
8000a496:	30 1c       	mov	r12,1
8000a498:	c0 98       	rjmp	8000a4aa <_dtoa_r+0x89a>
8000a49a:	64 48       	ld.w	r8,r2[0x10]
8000a49c:	2f c8       	sub	r8,-4
8000a49e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a4a2:	e0 a0 05 df 	rcall	8000b060 <__hi0bits>
8000a4a6:	f8 0c 11 20 	rsub	r12,r12,32
8000a4aa:	40 4b       	lddsp	r11,sp[0x10]
8000a4ac:	f8 0b 00 08 	add	r8,r12,r11
8000a4b0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a4b4:	c0 c0       	breq	8000a4cc <_dtoa_r+0x8bc>
8000a4b6:	f0 08 11 20 	rsub	r8,r8,32
8000a4ba:	58 48       	cp.w	r8,4
8000a4bc:	e0 8a 00 06 	brle	8000a4c8 <_dtoa_r+0x8b8>
8000a4c0:	20 48       	sub	r8,4
8000a4c2:	10 0b       	add	r11,r8
8000a4c4:	50 4b       	stdsp	sp[0x10],r11
8000a4c6:	c0 78       	rjmp	8000a4d4 <_dtoa_r+0x8c4>
8000a4c8:	58 48       	cp.w	r8,4
8000a4ca:	c0 70       	breq	8000a4d8 <_dtoa_r+0x8c8>
8000a4cc:	40 4a       	lddsp	r10,sp[0x10]
8000a4ce:	2e 48       	sub	r8,-28
8000a4d0:	10 0a       	add	r10,r8
8000a4d2:	50 4a       	stdsp	sp[0x10],r10
8000a4d4:	10 00       	add	r0,r8
8000a4d6:	10 05       	add	r5,r8
8000a4d8:	58 00       	cp.w	r0,0
8000a4da:	e0 8a 00 08 	brle	8000a4ea <_dtoa_r+0x8da>
8000a4de:	06 9b       	mov	r11,r3
8000a4e0:	00 9a       	mov	r10,r0
8000a4e2:	0e 9c       	mov	r12,r7
8000a4e4:	e0 a0 07 58 	rcall	8000b394 <__lshift>
8000a4e8:	18 93       	mov	r3,r12
8000a4ea:	40 49       	lddsp	r9,sp[0x10]
8000a4ec:	58 09       	cp.w	r9,0
8000a4ee:	e0 8a 00 08 	brle	8000a4fe <_dtoa_r+0x8ee>
8000a4f2:	04 9b       	mov	r11,r2
8000a4f4:	12 9a       	mov	r10,r9
8000a4f6:	0e 9c       	mov	r12,r7
8000a4f8:	e0 a0 07 4e 	rcall	8000b394 <__lshift>
8000a4fc:	18 92       	mov	r2,r12
8000a4fe:	41 48       	lddsp	r8,sp[0x50]
8000a500:	58 08       	cp.w	r8,0
8000a502:	c1 b0       	breq	8000a538 <_dtoa_r+0x928>
8000a504:	04 9b       	mov	r11,r2
8000a506:	06 9c       	mov	r12,r3
8000a508:	e0 a0 06 23 	rcall	8000b14e <__mcmp>
8000a50c:	c1 64       	brge	8000a538 <_dtoa_r+0x928>
8000a50e:	06 9b       	mov	r11,r3
8000a510:	30 09       	mov	r9,0
8000a512:	30 aa       	mov	r10,10
8000a514:	0e 9c       	mov	r12,r7
8000a516:	e0 a0 08 0b 	rcall	8000b52c <__multadd>
8000a51a:	20 16       	sub	r6,1
8000a51c:	18 93       	mov	r3,r12
8000a51e:	40 dc       	lddsp	r12,sp[0x34]
8000a520:	58 0c       	cp.w	r12,0
8000a522:	c0 31       	brne	8000a528 <_dtoa_r+0x918>
8000a524:	40 91       	lddsp	r1,sp[0x24]
8000a526:	c0 98       	rjmp	8000a538 <_dtoa_r+0x928>
8000a528:	08 9b       	mov	r11,r4
8000a52a:	40 91       	lddsp	r1,sp[0x24]
8000a52c:	30 09       	mov	r9,0
8000a52e:	30 aa       	mov	r10,10
8000a530:	0e 9c       	mov	r12,r7
8000a532:	e0 a0 07 fd 	rcall	8000b52c <__multadd>
8000a536:	18 94       	mov	r4,r12
8000a538:	58 01       	cp.w	r1,0
8000a53a:	5f a9       	srle	r9
8000a53c:	40 cb       	lddsp	r11,sp[0x30]
8000a53e:	58 2b       	cp.w	r11,2
8000a540:	5f 98       	srgt	r8
8000a542:	f3 e8 00 08 	and	r8,r9,r8
8000a546:	c2 50       	breq	8000a590 <_dtoa_r+0x980>
8000a548:	58 01       	cp.w	r1,0
8000a54a:	c1 11       	brne	8000a56c <_dtoa_r+0x95c>
8000a54c:	04 9b       	mov	r11,r2
8000a54e:	02 99       	mov	r9,r1
8000a550:	30 5a       	mov	r10,5
8000a552:	0e 9c       	mov	r12,r7
8000a554:	e0 a0 07 ec 	rcall	8000b52c <__multadd>
8000a558:	18 92       	mov	r2,r12
8000a55a:	18 9b       	mov	r11,r12
8000a55c:	06 9c       	mov	r12,r3
8000a55e:	e0 a0 05 f8 	rcall	8000b14e <__mcmp>
8000a562:	e0 89 00 0f 	brgt	8000a580 <_dtoa_r+0x970>
8000a566:	c0 38       	rjmp	8000a56c <_dtoa_r+0x95c>
8000a568:	30 02       	mov	r2,0
8000a56a:	04 94       	mov	r4,r2
8000a56c:	40 ea       	lddsp	r10,sp[0x38]
8000a56e:	30 09       	mov	r9,0
8000a570:	5c da       	com	r10
8000a572:	40 85       	lddsp	r5,sp[0x20]
8000a574:	50 6a       	stdsp	sp[0x18],r10
8000a576:	50 49       	stdsp	sp[0x10],r9
8000a578:	c0 f9       	rjmp	8000a796 <_dtoa_r+0xb86>
8000a57a:	08 92       	mov	r2,r4
8000a57c:	40 66       	lddsp	r6,sp[0x18]
8000a57e:	04 94       	mov	r4,r2
8000a580:	2f f6       	sub	r6,-1
8000a582:	50 66       	stdsp	sp[0x18],r6
8000a584:	33 18       	mov	r8,49
8000a586:	40 85       	lddsp	r5,sp[0x20]
8000a588:	0a c8       	st.b	r5++,r8
8000a58a:	30 08       	mov	r8,0
8000a58c:	50 48       	stdsp	sp[0x10],r8
8000a58e:	c0 49       	rjmp	8000a796 <_dtoa_r+0xb86>
8000a590:	40 dc       	lddsp	r12,sp[0x34]
8000a592:	58 0c       	cp.w	r12,0
8000a594:	e0 80 00 b5 	breq	8000a6fe <_dtoa_r+0xaee>
8000a598:	58 05       	cp.w	r5,0
8000a59a:	e0 8a 00 08 	brle	8000a5aa <_dtoa_r+0x99a>
8000a59e:	08 9b       	mov	r11,r4
8000a5a0:	0a 9a       	mov	r10,r5
8000a5a2:	0e 9c       	mov	r12,r7
8000a5a4:	e0 a0 06 f8 	rcall	8000b394 <__lshift>
8000a5a8:	18 94       	mov	r4,r12
8000a5aa:	40 6b       	lddsp	r11,sp[0x18]
8000a5ac:	58 0b       	cp.w	r11,0
8000a5ae:	c0 31       	brne	8000a5b4 <_dtoa_r+0x9a4>
8000a5b0:	08 9c       	mov	r12,r4
8000a5b2:	c1 38       	rjmp	8000a5d8 <_dtoa_r+0x9c8>
8000a5b4:	68 1b       	ld.w	r11,r4[0x4]
8000a5b6:	0e 9c       	mov	r12,r7
8000a5b8:	e0 a0 05 fe 	rcall	8000b1b4 <_Balloc>
8000a5bc:	68 4a       	ld.w	r10,r4[0x10]
8000a5be:	18 95       	mov	r5,r12
8000a5c0:	e8 cb ff f4 	sub	r11,r4,-12
8000a5c4:	2f ea       	sub	r10,-2
8000a5c6:	2f 4c       	sub	r12,-12
8000a5c8:	a3 6a       	lsl	r10,0x2
8000a5ca:	fe b0 e6 4f 	rcall	80007268 <memcpy>
8000a5ce:	0a 9b       	mov	r11,r5
8000a5d0:	30 1a       	mov	r10,1
8000a5d2:	0e 9c       	mov	r12,r7
8000a5d4:	e0 a0 06 e0 	rcall	8000b394 <__lshift>
8000a5d8:	50 44       	stdsp	sp[0x10],r4
8000a5da:	40 3a       	lddsp	r10,sp[0xc]
8000a5dc:	30 19       	mov	r9,1
8000a5de:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a5e2:	18 94       	mov	r4,r12
8000a5e4:	50 da       	stdsp	sp[0x34],r10
8000a5e6:	40 85       	lddsp	r5,sp[0x20]
8000a5e8:	50 99       	stdsp	sp[0x24],r9
8000a5ea:	50 26       	stdsp	sp[0x8],r6
8000a5ec:	50 e1       	stdsp	sp[0x38],r1
8000a5ee:	04 9b       	mov	r11,r2
8000a5f0:	06 9c       	mov	r12,r3
8000a5f2:	fe b0 fa 7f 	rcall	80009af0 <quorem>
8000a5f6:	40 4b       	lddsp	r11,sp[0x10]
8000a5f8:	f8 c0 ff d0 	sub	r0,r12,-48
8000a5fc:	06 9c       	mov	r12,r3
8000a5fe:	e0 a0 05 a8 	rcall	8000b14e <__mcmp>
8000a602:	08 9a       	mov	r10,r4
8000a604:	50 6c       	stdsp	sp[0x18],r12
8000a606:	04 9b       	mov	r11,r2
8000a608:	0e 9c       	mov	r12,r7
8000a60a:	e0 a0 06 5d 	rcall	8000b2c4 <__mdiff>
8000a60e:	18 91       	mov	r1,r12
8000a610:	78 38       	ld.w	r8,r12[0xc]
8000a612:	58 08       	cp.w	r8,0
8000a614:	c0 30       	breq	8000a61a <_dtoa_r+0xa0a>
8000a616:	30 16       	mov	r6,1
8000a618:	c0 68       	rjmp	8000a624 <_dtoa_r+0xa14>
8000a61a:	18 9b       	mov	r11,r12
8000a61c:	06 9c       	mov	r12,r3
8000a61e:	e0 a0 05 98 	rcall	8000b14e <__mcmp>
8000a622:	18 96       	mov	r6,r12
8000a624:	0e 9c       	mov	r12,r7
8000a626:	02 9b       	mov	r11,r1
8000a628:	e0 a0 05 ac 	rcall	8000b180 <_Bfree>
8000a62c:	40 cc       	lddsp	r12,sp[0x30]
8000a62e:	ed ec 10 08 	or	r8,r6,r12
8000a632:	c0 d1       	brne	8000a64c <_dtoa_r+0xa3c>
8000a634:	40 db       	lddsp	r11,sp[0x34]
8000a636:	58 0b       	cp.w	r11,0
8000a638:	c0 a1       	brne	8000a64c <_dtoa_r+0xa3c>
8000a63a:	40 26       	lddsp	r6,sp[0x8]
8000a63c:	e0 40 00 39 	cp.w	r0,57
8000a640:	c3 00       	breq	8000a6a0 <_dtoa_r+0xa90>
8000a642:	40 6a       	lddsp	r10,sp[0x18]
8000a644:	58 0a       	cp.w	r10,0
8000a646:	e0 89 00 24 	brgt	8000a68e <_dtoa_r+0xa7e>
8000a64a:	c2 f8       	rjmp	8000a6a8 <_dtoa_r+0xa98>
8000a64c:	40 69       	lddsp	r9,sp[0x18]
8000a64e:	58 09       	cp.w	r9,0
8000a650:	c0 85       	brlt	8000a660 <_dtoa_r+0xa50>
8000a652:	12 98       	mov	r8,r9
8000a654:	40 cc       	lddsp	r12,sp[0x30]
8000a656:	18 48       	or	r8,r12
8000a658:	c1 d1       	brne	8000a692 <_dtoa_r+0xa82>
8000a65a:	40 db       	lddsp	r11,sp[0x34]
8000a65c:	58 0b       	cp.w	r11,0
8000a65e:	c1 a1       	brne	8000a692 <_dtoa_r+0xa82>
8000a660:	0c 99       	mov	r9,r6
8000a662:	40 26       	lddsp	r6,sp[0x8]
8000a664:	58 09       	cp.w	r9,0
8000a666:	e0 8a 00 21 	brle	8000a6a8 <_dtoa_r+0xa98>
8000a66a:	06 9b       	mov	r11,r3
8000a66c:	30 1a       	mov	r10,1
8000a66e:	0e 9c       	mov	r12,r7
8000a670:	e0 a0 06 92 	rcall	8000b394 <__lshift>
8000a674:	04 9b       	mov	r11,r2
8000a676:	18 93       	mov	r3,r12
8000a678:	e0 a0 05 6b 	rcall	8000b14e <__mcmp>
8000a67c:	e0 89 00 06 	brgt	8000a688 <_dtoa_r+0xa78>
8000a680:	c1 41       	brne	8000a6a8 <_dtoa_r+0xa98>
8000a682:	ed b0 00 00 	bld	r0,0x0
8000a686:	c1 11       	brne	8000a6a8 <_dtoa_r+0xa98>
8000a688:	e0 40 00 39 	cp.w	r0,57
8000a68c:	c0 a0       	breq	8000a6a0 <_dtoa_r+0xa90>
8000a68e:	2f f0       	sub	r0,-1
8000a690:	c0 c8       	rjmp	8000a6a8 <_dtoa_r+0xa98>
8000a692:	58 06       	cp.w	r6,0
8000a694:	e0 8a 00 0c 	brle	8000a6ac <_dtoa_r+0xa9c>
8000a698:	40 26       	lddsp	r6,sp[0x8]
8000a69a:	e0 40 00 39 	cp.w	r0,57
8000a69e:	c0 41       	brne	8000a6a6 <_dtoa_r+0xa96>
8000a6a0:	33 98       	mov	r8,57
8000a6a2:	0a c8       	st.b	r5++,r8
8000a6a4:	c6 78       	rjmp	8000a772 <_dtoa_r+0xb62>
8000a6a6:	2f f0       	sub	r0,-1
8000a6a8:	0a c0       	st.b	r5++,r0
8000a6aa:	c7 58       	rjmp	8000a794 <_dtoa_r+0xb84>
8000a6ac:	0a c0       	st.b	r5++,r0
8000a6ae:	40 9a       	lddsp	r10,sp[0x24]
8000a6b0:	40 e9       	lddsp	r9,sp[0x38]
8000a6b2:	12 3a       	cp.w	r10,r9
8000a6b4:	c4 30       	breq	8000a73a <_dtoa_r+0xb2a>
8000a6b6:	06 9b       	mov	r11,r3
8000a6b8:	30 09       	mov	r9,0
8000a6ba:	30 aa       	mov	r10,10
8000a6bc:	0e 9c       	mov	r12,r7
8000a6be:	e0 a0 07 37 	rcall	8000b52c <__multadd>
8000a6c2:	40 48       	lddsp	r8,sp[0x10]
8000a6c4:	18 93       	mov	r3,r12
8000a6c6:	08 38       	cp.w	r8,r4
8000a6c8:	c0 91       	brne	8000a6da <_dtoa_r+0xaca>
8000a6ca:	10 9b       	mov	r11,r8
8000a6cc:	30 09       	mov	r9,0
8000a6ce:	30 aa       	mov	r10,10
8000a6d0:	0e 9c       	mov	r12,r7
8000a6d2:	e0 a0 07 2d 	rcall	8000b52c <__multadd>
8000a6d6:	50 4c       	stdsp	sp[0x10],r12
8000a6d8:	c0 e8       	rjmp	8000a6f4 <_dtoa_r+0xae4>
8000a6da:	40 4b       	lddsp	r11,sp[0x10]
8000a6dc:	30 09       	mov	r9,0
8000a6de:	30 aa       	mov	r10,10
8000a6e0:	0e 9c       	mov	r12,r7
8000a6e2:	e0 a0 07 25 	rcall	8000b52c <__multadd>
8000a6e6:	08 9b       	mov	r11,r4
8000a6e8:	50 4c       	stdsp	sp[0x10],r12
8000a6ea:	30 09       	mov	r9,0
8000a6ec:	30 aa       	mov	r10,10
8000a6ee:	0e 9c       	mov	r12,r7
8000a6f0:	e0 a0 07 1e 	rcall	8000b52c <__multadd>
8000a6f4:	18 94       	mov	r4,r12
8000a6f6:	40 9c       	lddsp	r12,sp[0x24]
8000a6f8:	2f fc       	sub	r12,-1
8000a6fa:	50 9c       	stdsp	sp[0x24],r12
8000a6fc:	c7 9b       	rjmp	8000a5ee <_dtoa_r+0x9de>
8000a6fe:	30 18       	mov	r8,1
8000a700:	06 90       	mov	r0,r3
8000a702:	40 85       	lddsp	r5,sp[0x20]
8000a704:	08 93       	mov	r3,r4
8000a706:	0c 94       	mov	r4,r6
8000a708:	10 96       	mov	r6,r8
8000a70a:	04 9b       	mov	r11,r2
8000a70c:	00 9c       	mov	r12,r0
8000a70e:	fe b0 f9 f1 	rcall	80009af0 <quorem>
8000a712:	2d 0c       	sub	r12,-48
8000a714:	0a cc       	st.b	r5++,r12
8000a716:	02 36       	cp.w	r6,r1
8000a718:	c0 a4       	brge	8000a72c <_dtoa_r+0xb1c>
8000a71a:	00 9b       	mov	r11,r0
8000a71c:	30 09       	mov	r9,0
8000a71e:	30 aa       	mov	r10,10
8000a720:	0e 9c       	mov	r12,r7
8000a722:	2f f6       	sub	r6,-1
8000a724:	e0 a0 07 04 	rcall	8000b52c <__multadd>
8000a728:	18 90       	mov	r0,r12
8000a72a:	cf 0b       	rjmp	8000a70a <_dtoa_r+0xafa>
8000a72c:	08 96       	mov	r6,r4
8000a72e:	30 0b       	mov	r11,0
8000a730:	06 94       	mov	r4,r3
8000a732:	50 4b       	stdsp	sp[0x10],r11
8000a734:	00 93       	mov	r3,r0
8000a736:	18 90       	mov	r0,r12
8000a738:	c0 28       	rjmp	8000a73c <_dtoa_r+0xb2c>
8000a73a:	40 26       	lddsp	r6,sp[0x8]
8000a73c:	06 9b       	mov	r11,r3
8000a73e:	30 1a       	mov	r10,1
8000a740:	0e 9c       	mov	r12,r7
8000a742:	e0 a0 06 29 	rcall	8000b394 <__lshift>
8000a746:	04 9b       	mov	r11,r2
8000a748:	18 93       	mov	r3,r12
8000a74a:	e0 a0 05 02 	rcall	8000b14e <__mcmp>
8000a74e:	e0 89 00 12 	brgt	8000a772 <_dtoa_r+0xb62>
8000a752:	c1 b1       	brne	8000a788 <_dtoa_r+0xb78>
8000a754:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a758:	c0 d1       	brne	8000a772 <_dtoa_r+0xb62>
8000a75a:	c1 78       	rjmp	8000a788 <_dtoa_r+0xb78>
8000a75c:	40 89       	lddsp	r9,sp[0x20]
8000a75e:	12 38       	cp.w	r8,r9
8000a760:	c0 30       	breq	8000a766 <_dtoa_r+0xb56>
8000a762:	10 95       	mov	r5,r8
8000a764:	c0 88       	rjmp	8000a774 <_dtoa_r+0xb64>
8000a766:	2f f6       	sub	r6,-1
8000a768:	50 66       	stdsp	sp[0x18],r6
8000a76a:	33 18       	mov	r8,49
8000a76c:	40 8c       	lddsp	r12,sp[0x20]
8000a76e:	b8 88       	st.b	r12[0x0],r8
8000a770:	c1 38       	rjmp	8000a796 <_dtoa_r+0xb86>
8000a772:	33 9a       	mov	r10,57
8000a774:	0a 98       	mov	r8,r5
8000a776:	11 79       	ld.ub	r9,--r8
8000a778:	f4 09 18 00 	cp.b	r9,r10
8000a77c:	cf 00       	breq	8000a75c <_dtoa_r+0xb4c>
8000a77e:	2f f9       	sub	r9,-1
8000a780:	b0 89       	st.b	r8[0x0],r9
8000a782:	c0 98       	rjmp	8000a794 <_dtoa_r+0xb84>
8000a784:	10 95       	mov	r5,r8
8000a786:	c0 28       	rjmp	8000a78a <_dtoa_r+0xb7a>
8000a788:	33 09       	mov	r9,48
8000a78a:	0a 98       	mov	r8,r5
8000a78c:	11 7a       	ld.ub	r10,--r8
8000a78e:	f2 0a 18 00 	cp.b	r10,r9
8000a792:	cf 90       	breq	8000a784 <_dtoa_r+0xb74>
8000a794:	50 66       	stdsp	sp[0x18],r6
8000a796:	04 9b       	mov	r11,r2
8000a798:	0e 9c       	mov	r12,r7
8000a79a:	e0 a0 04 f3 	rcall	8000b180 <_Bfree>
8000a79e:	58 04       	cp.w	r4,0
8000a7a0:	c1 20       	breq	8000a7c4 <_dtoa_r+0xbb4>
8000a7a2:	40 4b       	lddsp	r11,sp[0x10]
8000a7a4:	08 3b       	cp.w	r11,r4
8000a7a6:	5f 19       	srne	r9
8000a7a8:	58 0b       	cp.w	r11,0
8000a7aa:	5f 18       	srne	r8
8000a7ac:	f3 e8 00 08 	and	r8,r9,r8
8000a7b0:	c0 40       	breq	8000a7b8 <_dtoa_r+0xba8>
8000a7b2:	0e 9c       	mov	r12,r7
8000a7b4:	e0 a0 04 e6 	rcall	8000b180 <_Bfree>
8000a7b8:	08 9b       	mov	r11,r4
8000a7ba:	0e 9c       	mov	r12,r7
8000a7bc:	e0 a0 04 e2 	rcall	8000b180 <_Bfree>
8000a7c0:	c0 28       	rjmp	8000a7c4 <_dtoa_r+0xbb4>
8000a7c2:	50 66       	stdsp	sp[0x18],r6
8000a7c4:	0e 9c       	mov	r12,r7
8000a7c6:	06 9b       	mov	r11,r3
8000a7c8:	e0 a0 04 dc 	rcall	8000b180 <_Bfree>
8000a7cc:	30 08       	mov	r8,0
8000a7ce:	aa 88       	st.b	r5[0x0],r8
8000a7d0:	40 68       	lddsp	r8,sp[0x18]
8000a7d2:	41 5a       	lddsp	r10,sp[0x54]
8000a7d4:	2f f8       	sub	r8,-1
8000a7d6:	41 29       	lddsp	r9,sp[0x48]
8000a7d8:	95 08       	st.w	r10[0x0],r8
8000a7da:	40 8c       	lddsp	r12,sp[0x20]
8000a7dc:	58 09       	cp.w	r9,0
8000a7de:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a7e2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a7e6:	2e 6d       	sub	sp,-104
8000a7e8:	d8 32       	popm	r0-r7,pc
8000a7ea:	d7 03       	nop

8000a7ec <__errno>:
8000a7ec:	e0 68 0a 38 	mov	r8,2616
8000a7f0:	70 0c       	ld.w	r12,r8[0x0]
8000a7f2:	2f 4c       	sub	r12,-12
8000a7f4:	5e fc       	retal	r12
8000a7f6:	d7 03       	nop

8000a7f8 <_fflush_r>:
8000a7f8:	d4 21       	pushm	r4-r7,lr
8000a7fa:	16 97       	mov	r7,r11
8000a7fc:	18 96       	mov	r6,r12
8000a7fe:	76 48       	ld.w	r8,r11[0x10]
8000a800:	58 08       	cp.w	r8,0
8000a802:	c7 f0       	breq	8000a900 <_fflush_r+0x108>
8000a804:	58 0c       	cp.w	r12,0
8000a806:	c0 50       	breq	8000a810 <_fflush_r+0x18>
8000a808:	78 68       	ld.w	r8,r12[0x18]
8000a80a:	58 08       	cp.w	r8,0
8000a80c:	c0 21       	brne	8000a810 <_fflush_r+0x18>
8000a80e:	cc dc       	rcall	8000a9a8 <__sinit>
8000a810:	fe c8 ce 54 	sub	r8,pc,-12716
8000a814:	10 37       	cp.w	r7,r8
8000a816:	c0 31       	brne	8000a81c <_fflush_r+0x24>
8000a818:	6c 07       	ld.w	r7,r6[0x0]
8000a81a:	c0 c8       	rjmp	8000a832 <_fflush_r+0x3a>
8000a81c:	fe c8 ce 40 	sub	r8,pc,-12736
8000a820:	10 37       	cp.w	r7,r8
8000a822:	c0 31       	brne	8000a828 <_fflush_r+0x30>
8000a824:	6c 17       	ld.w	r7,r6[0x4]
8000a826:	c0 68       	rjmp	8000a832 <_fflush_r+0x3a>
8000a828:	fe c8 ce 2c 	sub	r8,pc,-12756
8000a82c:	10 37       	cp.w	r7,r8
8000a82e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a832:	8e 6a       	ld.sh	r10,r7[0xc]
8000a834:	14 98       	mov	r8,r10
8000a836:	ed ba 00 03 	bld	r10,0x3
8000a83a:	c4 20       	breq	8000a8be <_fflush_r+0xc6>
8000a83c:	ab ba       	sbr	r10,0xb
8000a83e:	ae 6a       	st.h	r7[0xc],r10
8000a840:	6e 18       	ld.w	r8,r7[0x4]
8000a842:	58 08       	cp.w	r8,0
8000a844:	e0 89 00 06 	brgt	8000a850 <_fflush_r+0x58>
8000a848:	6f 08       	ld.w	r8,r7[0x40]
8000a84a:	58 08       	cp.w	r8,0
8000a84c:	e0 8a 00 5a 	brle	8000a900 <_fflush_r+0x108>
8000a850:	6e b8       	ld.w	r8,r7[0x2c]
8000a852:	58 08       	cp.w	r8,0
8000a854:	c5 60       	breq	8000a900 <_fflush_r+0x108>
8000a856:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a85a:	c0 30       	breq	8000a860 <_fflush_r+0x68>
8000a85c:	6f 55       	ld.w	r5,r7[0x54]
8000a85e:	c0 f8       	rjmp	8000a87c <_fflush_r+0x84>
8000a860:	30 19       	mov	r9,1
8000a862:	6e 8b       	ld.w	r11,r7[0x20]
8000a864:	0c 9c       	mov	r12,r6
8000a866:	5d 18       	icall	r8
8000a868:	18 95       	mov	r5,r12
8000a86a:	5b fc       	cp.w	r12,-1
8000a86c:	c0 81       	brne	8000a87c <_fflush_r+0x84>
8000a86e:	6c 38       	ld.w	r8,r6[0xc]
8000a870:	59 d8       	cp.w	r8,29
8000a872:	c4 70       	breq	8000a900 <_fflush_r+0x108>
8000a874:	8e 68       	ld.sh	r8,r7[0xc]
8000a876:	a7 a8       	sbr	r8,0x6
8000a878:	ae 68       	st.h	r7[0xc],r8
8000a87a:	d8 22       	popm	r4-r7,pc
8000a87c:	8e 68       	ld.sh	r8,r7[0xc]
8000a87e:	ed b8 00 02 	bld	r8,0x2
8000a882:	c0 91       	brne	8000a894 <_fflush_r+0x9c>
8000a884:	6e 18       	ld.w	r8,r7[0x4]
8000a886:	10 15       	sub	r5,r8
8000a888:	6e d8       	ld.w	r8,r7[0x34]
8000a88a:	58 08       	cp.w	r8,0
8000a88c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a890:	eb d8 e1 15 	subne	r5,r5,r8
8000a894:	6e b8       	ld.w	r8,r7[0x2c]
8000a896:	0c 9c       	mov	r12,r6
8000a898:	30 09       	mov	r9,0
8000a89a:	0a 9a       	mov	r10,r5
8000a89c:	6e 8b       	ld.w	r11,r7[0x20]
8000a89e:	5d 18       	icall	r8
8000a8a0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8a2:	0a 3c       	cp.w	r12,r5
8000a8a4:	c2 61       	brne	8000a8f0 <_fflush_r+0xf8>
8000a8a6:	ab d8       	cbr	r8,0xb
8000a8a8:	30 0c       	mov	r12,0
8000a8aa:	6e 49       	ld.w	r9,r7[0x10]
8000a8ac:	ae 68       	st.h	r7[0xc],r8
8000a8ae:	8f 1c       	st.w	r7[0x4],r12
8000a8b0:	8f 09       	st.w	r7[0x0],r9
8000a8b2:	ed b8 00 0c 	bld	r8,0xc
8000a8b6:	c2 51       	brne	8000a900 <_fflush_r+0x108>
8000a8b8:	ef 45 00 54 	st.w	r7[84],r5
8000a8bc:	d8 22       	popm	r4-r7,pc
8000a8be:	6e 45       	ld.w	r5,r7[0x10]
8000a8c0:	58 05       	cp.w	r5,0
8000a8c2:	c1 f0       	breq	8000a900 <_fflush_r+0x108>
8000a8c4:	6e 04       	ld.w	r4,r7[0x0]
8000a8c6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a8ca:	8f 05       	st.w	r7[0x0],r5
8000a8cc:	f9 b8 01 00 	movne	r8,0
8000a8d0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a8d4:	0a 14       	sub	r4,r5
8000a8d6:	8f 28       	st.w	r7[0x8],r8
8000a8d8:	c1 18       	rjmp	8000a8fa <_fflush_r+0x102>
8000a8da:	08 99       	mov	r9,r4
8000a8dc:	0a 9a       	mov	r10,r5
8000a8de:	6e a8       	ld.w	r8,r7[0x28]
8000a8e0:	6e 8b       	ld.w	r11,r7[0x20]
8000a8e2:	0c 9c       	mov	r12,r6
8000a8e4:	5d 18       	icall	r8
8000a8e6:	18 14       	sub	r4,r12
8000a8e8:	58 0c       	cp.w	r12,0
8000a8ea:	e0 89 00 07 	brgt	8000a8f8 <_fflush_r+0x100>
8000a8ee:	8e 68       	ld.sh	r8,r7[0xc]
8000a8f0:	a7 a8       	sbr	r8,0x6
8000a8f2:	3f fc       	mov	r12,-1
8000a8f4:	ae 68       	st.h	r7[0xc],r8
8000a8f6:	d8 22       	popm	r4-r7,pc
8000a8f8:	18 05       	add	r5,r12
8000a8fa:	58 04       	cp.w	r4,0
8000a8fc:	fe 99 ff ef 	brgt	8000a8da <_fflush_r+0xe2>
8000a900:	d8 2a       	popm	r4-r7,pc,r12=0
8000a902:	d7 03       	nop

8000a904 <__sfp_lock_acquire>:
8000a904:	5e fc       	retal	r12

8000a906 <__sfp_lock_release>:
8000a906:	5e fc       	retal	r12

8000a908 <_cleanup_r>:
8000a908:	d4 01       	pushm	lr
8000a90a:	fe cb f0 ae 	sub	r11,pc,-3922
8000a90e:	e0 a0 02 f7 	rcall	8000aefc <_fwalk>
8000a912:	d8 02       	popm	pc

8000a914 <__sfmoreglue>:
8000a914:	d4 21       	pushm	r4-r7,lr
8000a916:	16 95       	mov	r5,r11
8000a918:	f6 06 10 5c 	mul	r6,r11,92
8000a91c:	ec cb ff f4 	sub	r11,r6,-12
8000a920:	fe b0 e2 88 	rcall	80006e30 <_malloc_r>
8000a924:	18 97       	mov	r7,r12
8000a926:	c0 90       	breq	8000a938 <__sfmoreglue+0x24>
8000a928:	99 15       	st.w	r12[0x4],r5
8000a92a:	30 0b       	mov	r11,0
8000a92c:	2f 4c       	sub	r12,-12
8000a92e:	0c 9a       	mov	r10,r6
8000a930:	8f 2c       	st.w	r7[0x8],r12
8000a932:	8f 0b       	st.w	r7[0x0],r11
8000a934:	fe b0 e5 3e 	rcall	800073b0 <memset>
8000a938:	0e 9c       	mov	r12,r7
8000a93a:	d8 22       	popm	r4-r7,pc

8000a93c <__sfp>:
8000a93c:	d4 21       	pushm	r4-r7,lr
8000a93e:	fe c8 cf 1e 	sub	r8,pc,-12514
8000a942:	18 96       	mov	r6,r12
8000a944:	70 07       	ld.w	r7,r8[0x0]
8000a946:	6e 68       	ld.w	r8,r7[0x18]
8000a948:	58 08       	cp.w	r8,0
8000a94a:	c0 31       	brne	8000a950 <__sfp+0x14>
8000a94c:	0e 9c       	mov	r12,r7
8000a94e:	c2 dc       	rcall	8000a9a8 <__sinit>
8000a950:	ee c7 ff 28 	sub	r7,r7,-216
8000a954:	30 05       	mov	r5,0
8000a956:	6e 2c       	ld.w	r12,r7[0x8]
8000a958:	6e 18       	ld.w	r8,r7[0x4]
8000a95a:	c0 68       	rjmp	8000a966 <__sfp+0x2a>
8000a95c:	98 69       	ld.sh	r9,r12[0xc]
8000a95e:	ea 09 19 00 	cp.h	r9,r5
8000a962:	c1 10       	breq	8000a984 <__sfp+0x48>
8000a964:	2a 4c       	sub	r12,-92
8000a966:	20 18       	sub	r8,1
8000a968:	cf a7       	brpl	8000a95c <__sfp+0x20>
8000a96a:	6e 08       	ld.w	r8,r7[0x0]
8000a96c:	58 08       	cp.w	r8,0
8000a96e:	c0 61       	brne	8000a97a <__sfp+0x3e>
8000a970:	30 4b       	mov	r11,4
8000a972:	0c 9c       	mov	r12,r6
8000a974:	cd 0f       	rcall	8000a914 <__sfmoreglue>
8000a976:	8f 0c       	st.w	r7[0x0],r12
8000a978:	c0 30       	breq	8000a97e <__sfp+0x42>
8000a97a:	6e 07       	ld.w	r7,r7[0x0]
8000a97c:	ce db       	rjmp	8000a956 <__sfp+0x1a>
8000a97e:	30 c8       	mov	r8,12
8000a980:	8d 38       	st.w	r6[0xc],r8
8000a982:	d8 22       	popm	r4-r7,pc
8000a984:	30 08       	mov	r8,0
8000a986:	f9 48 00 4c 	st.w	r12[76],r8
8000a98a:	99 08       	st.w	r12[0x0],r8
8000a98c:	99 28       	st.w	r12[0x8],r8
8000a98e:	99 18       	st.w	r12[0x4],r8
8000a990:	99 48       	st.w	r12[0x10],r8
8000a992:	99 58       	st.w	r12[0x14],r8
8000a994:	99 68       	st.w	r12[0x18],r8
8000a996:	99 d8       	st.w	r12[0x34],r8
8000a998:	99 e8       	st.w	r12[0x38],r8
8000a99a:	f9 48 00 48 	st.w	r12[72],r8
8000a99e:	3f f8       	mov	r8,-1
8000a9a0:	b8 78       	st.h	r12[0xe],r8
8000a9a2:	30 18       	mov	r8,1
8000a9a4:	b8 68       	st.h	r12[0xc],r8
8000a9a6:	d8 22       	popm	r4-r7,pc

8000a9a8 <__sinit>:
8000a9a8:	d4 21       	pushm	r4-r7,lr
8000a9aa:	18 96       	mov	r6,r12
8000a9ac:	78 67       	ld.w	r7,r12[0x18]
8000a9ae:	58 07       	cp.w	r7,0
8000a9b0:	c4 91       	brne	8000aa42 <__sinit+0x9a>
8000a9b2:	fe c8 00 aa 	sub	r8,pc,170
8000a9b6:	30 15       	mov	r5,1
8000a9b8:	99 a8       	st.w	r12[0x28],r8
8000a9ba:	f9 47 00 d8 	st.w	r12[216],r7
8000a9be:	f9 47 00 dc 	st.w	r12[220],r7
8000a9c2:	f9 47 00 e0 	st.w	r12[224],r7
8000a9c6:	99 65       	st.w	r12[0x18],r5
8000a9c8:	cb af       	rcall	8000a93c <__sfp>
8000a9ca:	8d 0c       	st.w	r6[0x0],r12
8000a9cc:	0c 9c       	mov	r12,r6
8000a9ce:	cb 7f       	rcall	8000a93c <__sfp>
8000a9d0:	8d 1c       	st.w	r6[0x4],r12
8000a9d2:	0c 9c       	mov	r12,r6
8000a9d4:	cb 4f       	rcall	8000a93c <__sfp>
8000a9d6:	6c 09       	ld.w	r9,r6[0x0]
8000a9d8:	30 48       	mov	r8,4
8000a9da:	93 07       	st.w	r9[0x0],r7
8000a9dc:	b2 68       	st.h	r9[0xc],r8
8000a9de:	93 17       	st.w	r9[0x4],r7
8000a9e0:	93 27       	st.w	r9[0x8],r7
8000a9e2:	6c 18       	ld.w	r8,r6[0x4]
8000a9e4:	b2 77       	st.h	r9[0xe],r7
8000a9e6:	93 47       	st.w	r9[0x10],r7
8000a9e8:	93 57       	st.w	r9[0x14],r7
8000a9ea:	93 67       	st.w	r9[0x18],r7
8000a9ec:	93 89       	st.w	r9[0x20],r9
8000a9ee:	91 07       	st.w	r8[0x0],r7
8000a9f0:	91 17       	st.w	r8[0x4],r7
8000a9f2:	91 27       	st.w	r8[0x8],r7
8000a9f4:	fe ce f3 24 	sub	lr,pc,-3292
8000a9f8:	fe cb f3 54 	sub	r11,pc,-3244
8000a9fc:	93 9e       	st.w	r9[0x24],lr
8000a9fe:	93 ab       	st.w	r9[0x28],r11
8000aa00:	fe ca f3 7c 	sub	r10,pc,-3204
8000aa04:	fe c4 f3 88 	sub	r4,pc,-3192
8000aa08:	93 ba       	st.w	r9[0x2c],r10
8000aa0a:	93 c4       	st.w	r9[0x30],r4
8000aa0c:	30 99       	mov	r9,9
8000aa0e:	b0 69       	st.h	r8[0xc],r9
8000aa10:	b0 75       	st.h	r8[0xe],r5
8000aa12:	91 c4       	st.w	r8[0x30],r4
8000aa14:	91 47       	st.w	r8[0x10],r7
8000aa16:	91 57       	st.w	r8[0x14],r7
8000aa18:	91 67       	st.w	r8[0x18],r7
8000aa1a:	91 88       	st.w	r8[0x20],r8
8000aa1c:	91 9e       	st.w	r8[0x24],lr
8000aa1e:	91 ab       	st.w	r8[0x28],r11
8000aa20:	91 ba       	st.w	r8[0x2c],r10
8000aa22:	8d 2c       	st.w	r6[0x8],r12
8000aa24:	31 28       	mov	r8,18
8000aa26:	99 07       	st.w	r12[0x0],r7
8000aa28:	b8 68       	st.h	r12[0xc],r8
8000aa2a:	99 17       	st.w	r12[0x4],r7
8000aa2c:	99 27       	st.w	r12[0x8],r7
8000aa2e:	30 28       	mov	r8,2
8000aa30:	b8 78       	st.h	r12[0xe],r8
8000aa32:	99 c4       	st.w	r12[0x30],r4
8000aa34:	99 67       	st.w	r12[0x18],r7
8000aa36:	99 9e       	st.w	r12[0x24],lr
8000aa38:	99 ab       	st.w	r12[0x28],r11
8000aa3a:	99 ba       	st.w	r12[0x2c],r10
8000aa3c:	99 47       	st.w	r12[0x10],r7
8000aa3e:	99 57       	st.w	r12[0x14],r7
8000aa40:	99 8c       	st.w	r12[0x20],r12
8000aa42:	d8 22       	popm	r4-r7,pc

8000aa44 <_malloc_trim_r>:
8000aa44:	d4 21       	pushm	r4-r7,lr
8000aa46:	16 95       	mov	r5,r11
8000aa48:	18 97       	mov	r7,r12
8000aa4a:	fe b0 d7 f1 	rcall	80005a2c <__malloc_lock>
8000aa4e:	e0 64 05 38 	mov	r4,1336
8000aa52:	68 28       	ld.w	r8,r4[0x8]
8000aa54:	70 16       	ld.w	r6,r8[0x4]
8000aa56:	e0 16 ff fc 	andl	r6,0xfffc
8000aa5a:	ec c8 ff 91 	sub	r8,r6,-111
8000aa5e:	f0 05 01 05 	sub	r5,r8,r5
8000aa62:	e0 15 ff 80 	andl	r5,0xff80
8000aa66:	ea c5 00 80 	sub	r5,r5,128
8000aa6a:	e0 45 00 7f 	cp.w	r5,127
8000aa6e:	e0 8a 00 25 	brle	8000aab8 <_malloc_trim_r+0x74>
8000aa72:	30 0b       	mov	r11,0
8000aa74:	0e 9c       	mov	r12,r7
8000aa76:	fe b0 e6 05 	rcall	80007680 <_sbrk_r>
8000aa7a:	68 28       	ld.w	r8,r4[0x8]
8000aa7c:	0c 08       	add	r8,r6
8000aa7e:	10 3c       	cp.w	r12,r8
8000aa80:	c1 c1       	brne	8000aab8 <_malloc_trim_r+0x74>
8000aa82:	ea 0b 11 00 	rsub	r11,r5,0
8000aa86:	0e 9c       	mov	r12,r7
8000aa88:	fe b0 e5 fc 	rcall	80007680 <_sbrk_r>
8000aa8c:	5b fc       	cp.w	r12,-1
8000aa8e:	c1 91       	brne	8000aac0 <_malloc_trim_r+0x7c>
8000aa90:	30 0b       	mov	r11,0
8000aa92:	0e 9c       	mov	r12,r7
8000aa94:	fe b0 e5 f6 	rcall	80007680 <_sbrk_r>
8000aa98:	68 28       	ld.w	r8,r4[0x8]
8000aa9a:	f8 08 01 09 	sub	r9,r12,r8
8000aa9e:	58 f9       	cp.w	r9,15
8000aaa0:	e0 8a 00 0c 	brle	8000aab8 <_malloc_trim_r+0x74>
8000aaa4:	a1 a9       	sbr	r9,0x0
8000aaa6:	91 19       	st.w	r8[0x4],r9
8000aaa8:	e0 68 09 44 	mov	r8,2372
8000aaac:	70 09       	ld.w	r9,r8[0x0]
8000aaae:	e0 68 0d 4c 	mov	r8,3404
8000aab2:	f8 09 01 09 	sub	r9,r12,r9
8000aab6:	91 09       	st.w	r8[0x0],r9
8000aab8:	0e 9c       	mov	r12,r7
8000aaba:	fe b0 d7 bf 	rcall	80005a38 <__malloc_unlock>
8000aabe:	d8 2a       	popm	r4-r7,pc,r12=0
8000aac0:	68 28       	ld.w	r8,r4[0x8]
8000aac2:	0a 16       	sub	r6,r5
8000aac4:	a1 a6       	sbr	r6,0x0
8000aac6:	91 16       	st.w	r8[0x4],r6
8000aac8:	e0 68 0d 4c 	mov	r8,3404
8000aacc:	70 09       	ld.w	r9,r8[0x0]
8000aace:	0a 19       	sub	r9,r5
8000aad0:	0e 9c       	mov	r12,r7
8000aad2:	91 09       	st.w	r8[0x0],r9
8000aad4:	fe b0 d7 b2 	rcall	80005a38 <__malloc_unlock>
8000aad8:	da 2a       	popm	r4-r7,pc,r12=1
8000aada:	d7 03       	nop

8000aadc <_free_r>:
8000aadc:	d4 21       	pushm	r4-r7,lr
8000aade:	16 96       	mov	r6,r11
8000aae0:	18 97       	mov	r7,r12
8000aae2:	58 0b       	cp.w	r11,0
8000aae4:	e0 80 00 c0 	breq	8000ac64 <_free_r+0x188>
8000aae8:	fe b0 d7 a2 	rcall	80005a2c <__malloc_lock>
8000aaec:	20 86       	sub	r6,8
8000aaee:	e0 6a 05 38 	mov	r10,1336
8000aaf2:	6c 18       	ld.w	r8,r6[0x4]
8000aaf4:	74 2e       	ld.w	lr,r10[0x8]
8000aaf6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aafa:	a1 c8       	cbr	r8,0x0
8000aafc:	ec 08 00 09 	add	r9,r6,r8
8000ab00:	72 1b       	ld.w	r11,r9[0x4]
8000ab02:	e0 1b ff fc 	andl	r11,0xfffc
8000ab06:	1c 39       	cp.w	r9,lr
8000ab08:	c1 e1       	brne	8000ab44 <_free_r+0x68>
8000ab0a:	f6 08 00 08 	add	r8,r11,r8
8000ab0e:	58 0c       	cp.w	r12,0
8000ab10:	c0 81       	brne	8000ab20 <_free_r+0x44>
8000ab12:	6c 09       	ld.w	r9,r6[0x0]
8000ab14:	12 16       	sub	r6,r9
8000ab16:	12 08       	add	r8,r9
8000ab18:	6c 3b       	ld.w	r11,r6[0xc]
8000ab1a:	6c 29       	ld.w	r9,r6[0x8]
8000ab1c:	97 29       	st.w	r11[0x8],r9
8000ab1e:	93 3b       	st.w	r9[0xc],r11
8000ab20:	10 99       	mov	r9,r8
8000ab22:	95 26       	st.w	r10[0x8],r6
8000ab24:	a1 a9       	sbr	r9,0x0
8000ab26:	8d 19       	st.w	r6[0x4],r9
8000ab28:	e0 69 09 40 	mov	r9,2368
8000ab2c:	72 09       	ld.w	r9,r9[0x0]
8000ab2e:	12 38       	cp.w	r8,r9
8000ab30:	c0 63       	brcs	8000ab3c <_free_r+0x60>
8000ab32:	e0 68 0d 48 	mov	r8,3400
8000ab36:	0e 9c       	mov	r12,r7
8000ab38:	70 0b       	ld.w	r11,r8[0x0]
8000ab3a:	c8 5f       	rcall	8000aa44 <_malloc_trim_r>
8000ab3c:	0e 9c       	mov	r12,r7
8000ab3e:	fe b0 d7 7d 	rcall	80005a38 <__malloc_unlock>
8000ab42:	d8 22       	popm	r4-r7,pc
8000ab44:	93 1b       	st.w	r9[0x4],r11
8000ab46:	58 0c       	cp.w	r12,0
8000ab48:	c0 30       	breq	8000ab4e <_free_r+0x72>
8000ab4a:	30 0c       	mov	r12,0
8000ab4c:	c1 08       	rjmp	8000ab6c <_free_r+0x90>
8000ab4e:	6c 0e       	ld.w	lr,r6[0x0]
8000ab50:	f4 c5 ff f8 	sub	r5,r10,-8
8000ab54:	1c 16       	sub	r6,lr
8000ab56:	1c 08       	add	r8,lr
8000ab58:	6c 2e       	ld.w	lr,r6[0x8]
8000ab5a:	0a 3e       	cp.w	lr,r5
8000ab5c:	f9 bc 00 01 	moveq	r12,1
8000ab60:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ab64:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ab68:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ab6c:	f2 0b 00 0e 	add	lr,r9,r11
8000ab70:	7c 1e       	ld.w	lr,lr[0x4]
8000ab72:	ed be 00 00 	bld	lr,0x0
8000ab76:	c1 40       	breq	8000ab9e <_free_r+0xc2>
8000ab78:	16 08       	add	r8,r11
8000ab7a:	58 0c       	cp.w	r12,0
8000ab7c:	c0 d1       	brne	8000ab96 <_free_r+0xba>
8000ab7e:	e0 6e 05 38 	mov	lr,1336
8000ab82:	72 2b       	ld.w	r11,r9[0x8]
8000ab84:	2f 8e       	sub	lr,-8
8000ab86:	1c 3b       	cp.w	r11,lr
8000ab88:	c0 71       	brne	8000ab96 <_free_r+0xba>
8000ab8a:	97 36       	st.w	r11[0xc],r6
8000ab8c:	97 26       	st.w	r11[0x8],r6
8000ab8e:	8d 2b       	st.w	r6[0x8],r11
8000ab90:	8d 3b       	st.w	r6[0xc],r11
8000ab92:	30 1c       	mov	r12,1
8000ab94:	c0 58       	rjmp	8000ab9e <_free_r+0xc2>
8000ab96:	72 2b       	ld.w	r11,r9[0x8]
8000ab98:	72 39       	ld.w	r9,r9[0xc]
8000ab9a:	93 2b       	st.w	r9[0x8],r11
8000ab9c:	97 39       	st.w	r11[0xc],r9
8000ab9e:	10 99       	mov	r9,r8
8000aba0:	ec 08 09 08 	st.w	r6[r8],r8
8000aba4:	a1 a9       	sbr	r9,0x0
8000aba6:	8d 19       	st.w	r6[0x4],r9
8000aba8:	58 0c       	cp.w	r12,0
8000abaa:	c5 a1       	brne	8000ac5e <_free_r+0x182>
8000abac:	e0 48 01 ff 	cp.w	r8,511
8000abb0:	e0 8b 00 13 	brhi	8000abd6 <_free_r+0xfa>
8000abb4:	a3 98       	lsr	r8,0x3
8000abb6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000abba:	72 2b       	ld.w	r11,r9[0x8]
8000abbc:	8d 39       	st.w	r6[0xc],r9
8000abbe:	8d 2b       	st.w	r6[0x8],r11
8000abc0:	97 36       	st.w	r11[0xc],r6
8000abc2:	93 26       	st.w	r9[0x8],r6
8000abc4:	a3 48       	asr	r8,0x2
8000abc6:	74 19       	ld.w	r9,r10[0x4]
8000abc8:	30 1b       	mov	r11,1
8000abca:	f6 08 09 48 	lsl	r8,r11,r8
8000abce:	f3 e8 10 08 	or	r8,r9,r8
8000abd2:	95 18       	st.w	r10[0x4],r8
8000abd4:	c4 58       	rjmp	8000ac5e <_free_r+0x182>
8000abd6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000abda:	58 4b       	cp.w	r11,4
8000abdc:	e0 8b 00 06 	brhi	8000abe8 <_free_r+0x10c>
8000abe0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000abe4:	2c 8b       	sub	r11,-56
8000abe6:	c2 08       	rjmp	8000ac26 <_free_r+0x14a>
8000abe8:	59 4b       	cp.w	r11,20
8000abea:	e0 8b 00 04 	brhi	8000abf2 <_free_r+0x116>
8000abee:	2a 5b       	sub	r11,-91
8000abf0:	c1 b8       	rjmp	8000ac26 <_free_r+0x14a>
8000abf2:	e0 4b 00 54 	cp.w	r11,84
8000abf6:	e0 8b 00 06 	brhi	8000ac02 <_free_r+0x126>
8000abfa:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000abfe:	29 2b       	sub	r11,-110
8000ac00:	c1 38       	rjmp	8000ac26 <_free_r+0x14a>
8000ac02:	e0 4b 01 54 	cp.w	r11,340
8000ac06:	e0 8b 00 06 	brhi	8000ac12 <_free_r+0x136>
8000ac0a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ac0e:	28 9b       	sub	r11,-119
8000ac10:	c0 b8       	rjmp	8000ac26 <_free_r+0x14a>
8000ac12:	e0 4b 05 54 	cp.w	r11,1364
8000ac16:	e0 88 00 05 	brls	8000ac20 <_free_r+0x144>
8000ac1a:	37 eb       	mov	r11,126
8000ac1c:	c0 58       	rjmp	8000ac26 <_free_r+0x14a>
8000ac1e:	d7 03       	nop
8000ac20:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ac24:	28 4b       	sub	r11,-124
8000ac26:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ac2a:	78 29       	ld.w	r9,r12[0x8]
8000ac2c:	18 39       	cp.w	r9,r12
8000ac2e:	c0 e1       	brne	8000ac4a <_free_r+0x16e>
8000ac30:	74 18       	ld.w	r8,r10[0x4]
8000ac32:	a3 4b       	asr	r11,0x2
8000ac34:	30 1c       	mov	r12,1
8000ac36:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ac3a:	f1 eb 10 0b 	or	r11,r8,r11
8000ac3e:	12 98       	mov	r8,r9
8000ac40:	95 1b       	st.w	r10[0x4],r11
8000ac42:	c0 a8       	rjmp	8000ac56 <_free_r+0x17a>
8000ac44:	72 29       	ld.w	r9,r9[0x8]
8000ac46:	18 39       	cp.w	r9,r12
8000ac48:	c0 60       	breq	8000ac54 <_free_r+0x178>
8000ac4a:	72 1a       	ld.w	r10,r9[0x4]
8000ac4c:	e0 1a ff fc 	andl	r10,0xfffc
8000ac50:	14 38       	cp.w	r8,r10
8000ac52:	cf 93       	brcs	8000ac44 <_free_r+0x168>
8000ac54:	72 38       	ld.w	r8,r9[0xc]
8000ac56:	8d 38       	st.w	r6[0xc],r8
8000ac58:	8d 29       	st.w	r6[0x8],r9
8000ac5a:	93 36       	st.w	r9[0xc],r6
8000ac5c:	91 26       	st.w	r8[0x8],r6
8000ac5e:	0e 9c       	mov	r12,r7
8000ac60:	fe b0 d6 ec 	rcall	80005a38 <__malloc_unlock>
8000ac64:	d8 22       	popm	r4-r7,pc
8000ac66:	d7 03       	nop

8000ac68 <__sfvwrite_r>:
8000ac68:	d4 31       	pushm	r0-r7,lr
8000ac6a:	20 3d       	sub	sp,12
8000ac6c:	14 94       	mov	r4,r10
8000ac6e:	18 95       	mov	r5,r12
8000ac70:	16 97       	mov	r7,r11
8000ac72:	74 28       	ld.w	r8,r10[0x8]
8000ac74:	58 08       	cp.w	r8,0
8000ac76:	e0 80 01 40 	breq	8000aef6 <__sfvwrite_r+0x28e>
8000ac7a:	96 68       	ld.sh	r8,r11[0xc]
8000ac7c:	ed b8 00 03 	bld	r8,0x3
8000ac80:	c0 41       	brne	8000ac88 <__sfvwrite_r+0x20>
8000ac82:	76 48       	ld.w	r8,r11[0x10]
8000ac84:	58 08       	cp.w	r8,0
8000ac86:	c0 c1       	brne	8000ac9e <__sfvwrite_r+0x36>
8000ac88:	0e 9b       	mov	r11,r7
8000ac8a:	0a 9c       	mov	r12,r5
8000ac8c:	fe b0 f6 c4 	rcall	80009a14 <__swsetup_r>
8000ac90:	c0 70       	breq	8000ac9e <__sfvwrite_r+0x36>
8000ac92:	8e 68       	ld.sh	r8,r7[0xc]
8000ac94:	a7 a8       	sbr	r8,0x6
8000ac96:	ae 68       	st.h	r7[0xc],r8
8000ac98:	30 98       	mov	r8,9
8000ac9a:	8b 38       	st.w	r5[0xc],r8
8000ac9c:	c2 b9       	rjmp	8000aef2 <__sfvwrite_r+0x28a>
8000ac9e:	8e 63       	ld.sh	r3,r7[0xc]
8000aca0:	68 00       	ld.w	r0,r4[0x0]
8000aca2:	06 96       	mov	r6,r3
8000aca4:	e2 16 00 02 	andl	r6,0x2,COH
8000aca8:	c2 10       	breq	8000acea <__sfvwrite_r+0x82>
8000acaa:	30 03       	mov	r3,0
8000acac:	e0 62 04 00 	mov	r2,1024
8000acb0:	06 96       	mov	r6,r3
8000acb2:	c0 48       	rjmp	8000acba <__sfvwrite_r+0x52>
8000acb4:	60 03       	ld.w	r3,r0[0x0]
8000acb6:	60 16       	ld.w	r6,r0[0x4]
8000acb8:	2f 80       	sub	r0,-8
8000acba:	58 06       	cp.w	r6,0
8000acbc:	cf c0       	breq	8000acb4 <__sfvwrite_r+0x4c>
8000acbe:	e0 46 04 00 	cp.w	r6,1024
8000acc2:	ec 09 17 80 	movls	r9,r6
8000acc6:	e4 09 17 b0 	movhi	r9,r2
8000acca:	06 9a       	mov	r10,r3
8000accc:	6e a8       	ld.w	r8,r7[0x28]
8000acce:	6e 8b       	ld.w	r11,r7[0x20]
8000acd0:	0a 9c       	mov	r12,r5
8000acd2:	5d 18       	icall	r8
8000acd4:	18 16       	sub	r6,r12
8000acd6:	58 0c       	cp.w	r12,0
8000acd8:	e0 8a 01 0a 	brle	8000aeec <__sfvwrite_r+0x284>
8000acdc:	68 28       	ld.w	r8,r4[0x8]
8000acde:	18 18       	sub	r8,r12
8000ace0:	89 28       	st.w	r4[0x8],r8
8000ace2:	e0 80 01 0a 	breq	8000aef6 <__sfvwrite_r+0x28e>
8000ace6:	18 03       	add	r3,r12
8000ace8:	ce 9b       	rjmp	8000acba <__sfvwrite_r+0x52>
8000acea:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000acee:	c0 70       	breq	8000acfc <__sfvwrite_r+0x94>
8000acf0:	50 06       	stdsp	sp[0x0],r6
8000acf2:	0c 93       	mov	r3,r6
8000acf4:	0c 91       	mov	r1,r6
8000acf6:	50 15       	stdsp	sp[0x4],r5
8000acf8:	08 92       	mov	r2,r4
8000acfa:	c9 c8       	rjmp	8000ae32 <__sfvwrite_r+0x1ca>
8000acfc:	06 96       	mov	r6,r3
8000acfe:	08 91       	mov	r1,r4
8000ad00:	c0 48       	rjmp	8000ad08 <__sfvwrite_r+0xa0>
8000ad02:	60 03       	ld.w	r3,r0[0x0]
8000ad04:	60 16       	ld.w	r6,r0[0x4]
8000ad06:	2f 80       	sub	r0,-8
8000ad08:	58 06       	cp.w	r6,0
8000ad0a:	cf c0       	breq	8000ad02 <__sfvwrite_r+0x9a>
8000ad0c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad0e:	6e 24       	ld.w	r4,r7[0x8]
8000ad10:	10 99       	mov	r9,r8
8000ad12:	e2 19 02 00 	andl	r9,0x200,COH
8000ad16:	c5 50       	breq	8000adc0 <__sfvwrite_r+0x158>
8000ad18:	08 36       	cp.w	r6,r4
8000ad1a:	c4 43       	brcs	8000ada2 <__sfvwrite_r+0x13a>
8000ad1c:	10 99       	mov	r9,r8
8000ad1e:	e2 19 04 80 	andl	r9,0x480,COH
8000ad22:	c4 00       	breq	8000ada2 <__sfvwrite_r+0x13a>
8000ad24:	6e 4b       	ld.w	r11,r7[0x10]
8000ad26:	6e 09       	ld.w	r9,r7[0x0]
8000ad28:	16 19       	sub	r9,r11
8000ad2a:	50 09       	stdsp	sp[0x0],r9
8000ad2c:	6e 59       	ld.w	r9,r7[0x14]
8000ad2e:	10 9c       	mov	r12,r8
8000ad30:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ad34:	30 28       	mov	r8,2
8000ad36:	f4 08 0c 08 	divs	r8,r10,r8
8000ad3a:	fa e9 00 04 	st.d	sp[4],r8
8000ad3e:	10 94       	mov	r4,r8
8000ad40:	40 09       	lddsp	r9,sp[0x0]
8000ad42:	e2 1c 04 00 	andl	r12,0x400,COH
8000ad46:	2f f9       	sub	r9,-1
8000ad48:	0c 09       	add	r9,r6
8000ad4a:	12 38       	cp.w	r8,r9
8000ad4c:	f2 04 17 30 	movlo	r4,r9
8000ad50:	58 0c       	cp.w	r12,0
8000ad52:	c1 10       	breq	8000ad74 <__sfvwrite_r+0x10c>
8000ad54:	08 9b       	mov	r11,r4
8000ad56:	0a 9c       	mov	r12,r5
8000ad58:	fe b0 e0 6c 	rcall	80006e30 <_malloc_r>
8000ad5c:	18 92       	mov	r2,r12
8000ad5e:	c1 40       	breq	8000ad86 <__sfvwrite_r+0x11e>
8000ad60:	40 0a       	lddsp	r10,sp[0x0]
8000ad62:	6e 4b       	ld.w	r11,r7[0x10]
8000ad64:	fe b0 e2 82 	rcall	80007268 <memcpy>
8000ad68:	8e 68       	ld.sh	r8,r7[0xc]
8000ad6a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ad6e:	a7 b8       	sbr	r8,0x7
8000ad70:	ae 68       	st.h	r7[0xc],r8
8000ad72:	c0 d8       	rjmp	8000ad8c <__sfvwrite_r+0x124>
8000ad74:	08 9a       	mov	r10,r4
8000ad76:	0a 9c       	mov	r12,r5
8000ad78:	fe b0 e3 24 	rcall	800073c0 <_realloc_r>
8000ad7c:	18 92       	mov	r2,r12
8000ad7e:	c0 71       	brne	8000ad8c <__sfvwrite_r+0x124>
8000ad80:	6e 4b       	ld.w	r11,r7[0x10]
8000ad82:	0a 9c       	mov	r12,r5
8000ad84:	ca ce       	rcall	8000aadc <_free_r>
8000ad86:	30 c8       	mov	r8,12
8000ad88:	8b 38       	st.w	r5[0xc],r8
8000ad8a:	cb 18       	rjmp	8000aeec <__sfvwrite_r+0x284>
8000ad8c:	40 0a       	lddsp	r10,sp[0x0]
8000ad8e:	40 09       	lddsp	r9,sp[0x0]
8000ad90:	e8 0a 01 0a 	sub	r10,r4,r10
8000ad94:	e4 09 00 08 	add	r8,r2,r9
8000ad98:	8f 54       	st.w	r7[0x14],r4
8000ad9a:	8f 2a       	st.w	r7[0x8],r10
8000ad9c:	8f 08       	st.w	r7[0x0],r8
8000ad9e:	8f 42       	st.w	r7[0x10],r2
8000ada0:	0c 94       	mov	r4,r6
8000ada2:	08 36       	cp.w	r6,r4
8000ada4:	ec 04 17 30 	movlo	r4,r6
8000ada8:	06 9b       	mov	r11,r3
8000adaa:	08 9a       	mov	r10,r4
8000adac:	6e 0c       	ld.w	r12,r7[0x0]
8000adae:	c3 ad       	rcall	8000b022 <memmove>
8000adb0:	6e 08       	ld.w	r8,r7[0x0]
8000adb2:	08 08       	add	r8,r4
8000adb4:	8f 08       	st.w	r7[0x0],r8
8000adb6:	6e 28       	ld.w	r8,r7[0x8]
8000adb8:	08 18       	sub	r8,r4
8000adba:	0c 94       	mov	r4,r6
8000adbc:	8f 28       	st.w	r7[0x8],r8
8000adbe:	c2 e8       	rjmp	8000ae1a <__sfvwrite_r+0x1b2>
8000adc0:	08 36       	cp.w	r6,r4
8000adc2:	5f ba       	srhi	r10
8000adc4:	6e 0c       	ld.w	r12,r7[0x0]
8000adc6:	6e 48       	ld.w	r8,r7[0x10]
8000adc8:	10 3c       	cp.w	r12,r8
8000adca:	5f b8       	srhi	r8
8000adcc:	f5 e8 00 08 	and	r8,r10,r8
8000add0:	f2 08 18 00 	cp.b	r8,r9
8000add4:	c0 d0       	breq	8000adee <__sfvwrite_r+0x186>
8000add6:	06 9b       	mov	r11,r3
8000add8:	08 9a       	mov	r10,r4
8000adda:	c2 4d       	rcall	8000b022 <memmove>
8000addc:	6e 08       	ld.w	r8,r7[0x0]
8000adde:	08 08       	add	r8,r4
8000ade0:	0e 9b       	mov	r11,r7
8000ade2:	8f 08       	st.w	r7[0x0],r8
8000ade4:	0a 9c       	mov	r12,r5
8000ade6:	fe b0 fd 09 	rcall	8000a7f8 <_fflush_r>
8000adea:	c1 80       	breq	8000ae1a <__sfvwrite_r+0x1b2>
8000adec:	c8 08       	rjmp	8000aeec <__sfvwrite_r+0x284>
8000adee:	6e 59       	ld.w	r9,r7[0x14]
8000adf0:	12 36       	cp.w	r6,r9
8000adf2:	c0 a3       	brcs	8000ae06 <__sfvwrite_r+0x19e>
8000adf4:	6e a8       	ld.w	r8,r7[0x28]
8000adf6:	06 9a       	mov	r10,r3
8000adf8:	6e 8b       	ld.w	r11,r7[0x20]
8000adfa:	0a 9c       	mov	r12,r5
8000adfc:	5d 18       	icall	r8
8000adfe:	18 94       	mov	r4,r12
8000ae00:	e0 89 00 0d 	brgt	8000ae1a <__sfvwrite_r+0x1b2>
8000ae04:	c7 48       	rjmp	8000aeec <__sfvwrite_r+0x284>
8000ae06:	0c 9a       	mov	r10,r6
8000ae08:	06 9b       	mov	r11,r3
8000ae0a:	c0 cd       	rcall	8000b022 <memmove>
8000ae0c:	6e 08       	ld.w	r8,r7[0x0]
8000ae0e:	0c 08       	add	r8,r6
8000ae10:	0c 94       	mov	r4,r6
8000ae12:	8f 08       	st.w	r7[0x0],r8
8000ae14:	6e 28       	ld.w	r8,r7[0x8]
8000ae16:	0c 18       	sub	r8,r6
8000ae18:	8f 28       	st.w	r7[0x8],r8
8000ae1a:	62 28       	ld.w	r8,r1[0x8]
8000ae1c:	08 18       	sub	r8,r4
8000ae1e:	83 28       	st.w	r1[0x8],r8
8000ae20:	c6 b0       	breq	8000aef6 <__sfvwrite_r+0x28e>
8000ae22:	08 16       	sub	r6,r4
8000ae24:	08 03       	add	r3,r4
8000ae26:	c7 1b       	rjmp	8000ad08 <__sfvwrite_r+0xa0>
8000ae28:	60 03       	ld.w	r3,r0[0x0]
8000ae2a:	60 11       	ld.w	r1,r0[0x4]
8000ae2c:	30 08       	mov	r8,0
8000ae2e:	2f 80       	sub	r0,-8
8000ae30:	50 08       	stdsp	sp[0x0],r8
8000ae32:	58 01       	cp.w	r1,0
8000ae34:	cf a0       	breq	8000ae28 <__sfvwrite_r+0x1c0>
8000ae36:	40 0a       	lddsp	r10,sp[0x0]
8000ae38:	58 0a       	cp.w	r10,0
8000ae3a:	c1 41       	brne	8000ae62 <__sfvwrite_r+0x1fa>
8000ae3c:	e2 c6 ff ff 	sub	r6,r1,-1
8000ae40:	02 9a       	mov	r10,r1
8000ae42:	30 ab       	mov	r11,10
8000ae44:	06 9c       	mov	r12,r3
8000ae46:	ce 3c       	rcall	8000b00c <memchr>
8000ae48:	f8 c8 ff ff 	sub	r8,r12,-1
8000ae4c:	58 0c       	cp.w	r12,0
8000ae4e:	f1 d3 e1 16 	subne	r6,r8,r3
8000ae52:	f9 b9 01 01 	movne	r9,1
8000ae56:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae5a:	f9 b8 00 01 	moveq	r8,1
8000ae5e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ae62:	02 36       	cp.w	r6,r1
8000ae64:	ec 04 17 80 	movls	r4,r6
8000ae68:	e2 04 17 b0 	movhi	r4,r1
8000ae6c:	6e 59       	ld.w	r9,r7[0x14]
8000ae6e:	6e 25       	ld.w	r5,r7[0x8]
8000ae70:	f2 05 00 05 	add	r5,r9,r5
8000ae74:	0a 34       	cp.w	r4,r5
8000ae76:	5f 9a       	srgt	r10
8000ae78:	6e 0c       	ld.w	r12,r7[0x0]
8000ae7a:	6e 48       	ld.w	r8,r7[0x10]
8000ae7c:	10 3c       	cp.w	r12,r8
8000ae7e:	5f b8       	srhi	r8
8000ae80:	f5 e8 00 08 	and	r8,r10,r8
8000ae84:	30 0a       	mov	r10,0
8000ae86:	f4 08 18 00 	cp.b	r8,r10
8000ae8a:	c0 d0       	breq	8000aea4 <__sfvwrite_r+0x23c>
8000ae8c:	06 9b       	mov	r11,r3
8000ae8e:	0a 9a       	mov	r10,r5
8000ae90:	cc 9c       	rcall	8000b022 <memmove>
8000ae92:	6e 08       	ld.w	r8,r7[0x0]
8000ae94:	0a 08       	add	r8,r5
8000ae96:	0e 9b       	mov	r11,r7
8000ae98:	8f 08       	st.w	r7[0x0],r8
8000ae9a:	40 1c       	lddsp	r12,sp[0x4]
8000ae9c:	fe b0 fc ae 	rcall	8000a7f8 <_fflush_r>
8000aea0:	c1 70       	breq	8000aece <__sfvwrite_r+0x266>
8000aea2:	c2 58       	rjmp	8000aeec <__sfvwrite_r+0x284>
8000aea4:	12 34       	cp.w	r4,r9
8000aea6:	c0 a5       	brlt	8000aeba <__sfvwrite_r+0x252>
8000aea8:	6e a8       	ld.w	r8,r7[0x28]
8000aeaa:	06 9a       	mov	r10,r3
8000aeac:	6e 8b       	ld.w	r11,r7[0x20]
8000aeae:	40 1c       	lddsp	r12,sp[0x4]
8000aeb0:	5d 18       	icall	r8
8000aeb2:	18 95       	mov	r5,r12
8000aeb4:	e0 89 00 0d 	brgt	8000aece <__sfvwrite_r+0x266>
8000aeb8:	c1 a8       	rjmp	8000aeec <__sfvwrite_r+0x284>
8000aeba:	08 9a       	mov	r10,r4
8000aebc:	06 9b       	mov	r11,r3
8000aebe:	cb 2c       	rcall	8000b022 <memmove>
8000aec0:	6e 08       	ld.w	r8,r7[0x0]
8000aec2:	08 08       	add	r8,r4
8000aec4:	08 95       	mov	r5,r4
8000aec6:	8f 08       	st.w	r7[0x0],r8
8000aec8:	6e 28       	ld.w	r8,r7[0x8]
8000aeca:	08 18       	sub	r8,r4
8000aecc:	8f 28       	st.w	r7[0x8],r8
8000aece:	0a 16       	sub	r6,r5
8000aed0:	c0 71       	brne	8000aede <__sfvwrite_r+0x276>
8000aed2:	0e 9b       	mov	r11,r7
8000aed4:	40 1c       	lddsp	r12,sp[0x4]
8000aed6:	fe b0 fc 91 	rcall	8000a7f8 <_fflush_r>
8000aeda:	c0 91       	brne	8000aeec <__sfvwrite_r+0x284>
8000aedc:	50 06       	stdsp	sp[0x0],r6
8000aede:	64 28       	ld.w	r8,r2[0x8]
8000aee0:	0a 18       	sub	r8,r5
8000aee2:	85 28       	st.w	r2[0x8],r8
8000aee4:	c0 90       	breq	8000aef6 <__sfvwrite_r+0x28e>
8000aee6:	0a 11       	sub	r1,r5
8000aee8:	0a 03       	add	r3,r5
8000aeea:	ca 4b       	rjmp	8000ae32 <__sfvwrite_r+0x1ca>
8000aeec:	8e 68       	ld.sh	r8,r7[0xc]
8000aeee:	a7 a8       	sbr	r8,0x6
8000aef0:	ae 68       	st.h	r7[0xc],r8
8000aef2:	3f fc       	mov	r12,-1
8000aef4:	c0 28       	rjmp	8000aef8 <__sfvwrite_r+0x290>
8000aef6:	30 0c       	mov	r12,0
8000aef8:	2f dd       	sub	sp,-12
8000aefa:	d8 32       	popm	r0-r7,pc

8000aefc <_fwalk>:
8000aefc:	d4 31       	pushm	r0-r7,lr
8000aefe:	30 05       	mov	r5,0
8000af00:	16 91       	mov	r1,r11
8000af02:	f8 c7 ff 28 	sub	r7,r12,-216
8000af06:	0a 92       	mov	r2,r5
8000af08:	fe b0 fc fe 	rcall	8000a904 <__sfp_lock_acquire>
8000af0c:	3f f3       	mov	r3,-1
8000af0e:	c1 68       	rjmp	8000af3a <_fwalk+0x3e>
8000af10:	6e 26       	ld.w	r6,r7[0x8]
8000af12:	6e 14       	ld.w	r4,r7[0x4]
8000af14:	2f 46       	sub	r6,-12
8000af16:	c0 c8       	rjmp	8000af2e <_fwalk+0x32>
8000af18:	8c 08       	ld.sh	r8,r6[0x0]
8000af1a:	e4 08 19 00 	cp.h	r8,r2
8000af1e:	c0 70       	breq	8000af2c <_fwalk+0x30>
8000af20:	8c 18       	ld.sh	r8,r6[0x2]
8000af22:	e6 08 19 00 	cp.h	r8,r3
8000af26:	c0 30       	breq	8000af2c <_fwalk+0x30>
8000af28:	5d 11       	icall	r1
8000af2a:	18 45       	or	r5,r12
8000af2c:	2a 46       	sub	r6,-92
8000af2e:	20 14       	sub	r4,1
8000af30:	ec cc 00 0c 	sub	r12,r6,12
8000af34:	58 04       	cp.w	r4,0
8000af36:	cf 14       	brge	8000af18 <_fwalk+0x1c>
8000af38:	6e 07       	ld.w	r7,r7[0x0]
8000af3a:	58 07       	cp.w	r7,0
8000af3c:	ce a1       	brne	8000af10 <_fwalk+0x14>
8000af3e:	fe b0 fc e4 	rcall	8000a906 <__sfp_lock_release>
8000af42:	0a 9c       	mov	r12,r5
8000af44:	d8 32       	popm	r0-r7,pc
8000af46:	d7 03       	nop

8000af48 <_localeconv_r>:
8000af48:	fe cc d5 24 	sub	r12,pc,-10972
8000af4c:	5e fc       	retal	r12
8000af4e:	d7 03       	nop

8000af50 <__smakebuf_r>:
8000af50:	d4 21       	pushm	r4-r7,lr
8000af52:	20 fd       	sub	sp,60
8000af54:	96 68       	ld.sh	r8,r11[0xc]
8000af56:	16 97       	mov	r7,r11
8000af58:	18 96       	mov	r6,r12
8000af5a:	e2 18 00 02 	andl	r8,0x2,COH
8000af5e:	c3 d1       	brne	8000afd8 <__smakebuf_r+0x88>
8000af60:	96 7b       	ld.sh	r11,r11[0xe]
8000af62:	f0 0b 19 00 	cp.h	r11,r8
8000af66:	c0 55       	brlt	8000af70 <__smakebuf_r+0x20>
8000af68:	1a 9a       	mov	r10,sp
8000af6a:	e0 a0 04 81 	rcall	8000b86c <_fstat_r>
8000af6e:	c0 f4       	brge	8000af8c <__smakebuf_r+0x3c>
8000af70:	8e 65       	ld.sh	r5,r7[0xc]
8000af72:	0a 98       	mov	r8,r5
8000af74:	ab b8       	sbr	r8,0xb
8000af76:	e2 15 00 80 	andl	r5,0x80,COH
8000af7a:	ae 68       	st.h	r7[0xc],r8
8000af7c:	30 04       	mov	r4,0
8000af7e:	e0 68 04 00 	mov	r8,1024
8000af82:	f9 b5 01 40 	movne	r5,64
8000af86:	f0 05 17 00 	moveq	r5,r8
8000af8a:	c1 c8       	rjmp	8000afc2 <__smakebuf_r+0x72>
8000af8c:	40 18       	lddsp	r8,sp[0x4]
8000af8e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000af92:	e0 48 20 00 	cp.w	r8,8192
8000af96:	5f 04       	sreq	r4
8000af98:	e0 48 80 00 	cp.w	r8,32768
8000af9c:	c0 e1       	brne	8000afb8 <__smakebuf_r+0x68>
8000af9e:	6e b9       	ld.w	r9,r7[0x2c]
8000afa0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000afa4:	10 39       	cp.w	r9,r8
8000afa6:	c0 91       	brne	8000afb8 <__smakebuf_r+0x68>
8000afa8:	8e 68       	ld.sh	r8,r7[0xc]
8000afaa:	e0 65 04 00 	mov	r5,1024
8000afae:	ab a8       	sbr	r8,0xa
8000afb0:	ef 45 00 50 	st.w	r7[80],r5
8000afb4:	ae 68       	st.h	r7[0xc],r8
8000afb6:	c0 68       	rjmp	8000afc2 <__smakebuf_r+0x72>
8000afb8:	8e 68       	ld.sh	r8,r7[0xc]
8000afba:	e0 65 04 00 	mov	r5,1024
8000afbe:	ab b8       	sbr	r8,0xb
8000afc0:	ae 68       	st.h	r7[0xc],r8
8000afc2:	0a 9b       	mov	r11,r5
8000afc4:	0c 9c       	mov	r12,r6
8000afc6:	fe b0 df 35 	rcall	80006e30 <_malloc_r>
8000afca:	8e 68       	ld.sh	r8,r7[0xc]
8000afcc:	c0 d1       	brne	8000afe6 <__smakebuf_r+0x96>
8000afce:	ed b8 00 09 	bld	r8,0x9
8000afd2:	c1 b0       	breq	8000b008 <__smakebuf_r+0xb8>
8000afd4:	a1 b8       	sbr	r8,0x1
8000afd6:	ae 68       	st.h	r7[0xc],r8
8000afd8:	ee c8 ff b9 	sub	r8,r7,-71
8000afdc:	8f 48       	st.w	r7[0x10],r8
8000afde:	8f 08       	st.w	r7[0x0],r8
8000afe0:	30 18       	mov	r8,1
8000afe2:	8f 58       	st.w	r7[0x14],r8
8000afe4:	c1 28       	rjmp	8000b008 <__smakebuf_r+0xb8>
8000afe6:	a7 b8       	sbr	r8,0x7
8000afe8:	8f 4c       	st.w	r7[0x10],r12
8000afea:	ae 68       	st.h	r7[0xc],r8
8000afec:	8f 55       	st.w	r7[0x14],r5
8000afee:	fe c8 06 e6 	sub	r8,pc,1766
8000aff2:	8f 0c       	st.w	r7[0x0],r12
8000aff4:	8d a8       	st.w	r6[0x28],r8
8000aff6:	58 04       	cp.w	r4,0
8000aff8:	c0 80       	breq	8000b008 <__smakebuf_r+0xb8>
8000affa:	8e 7c       	ld.sh	r12,r7[0xe]
8000affc:	fe b0 e3 94 	rcall	80007724 <isatty>
8000b000:	c0 40       	breq	8000b008 <__smakebuf_r+0xb8>
8000b002:	8e 68       	ld.sh	r8,r7[0xc]
8000b004:	a1 a8       	sbr	r8,0x0
8000b006:	ae 68       	st.h	r7[0xc],r8
8000b008:	2f 1d       	sub	sp,-60
8000b00a:	d8 22       	popm	r4-r7,pc

8000b00c <memchr>:
8000b00c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b010:	c0 68       	rjmp	8000b01c <memchr+0x10>
8000b012:	20 1a       	sub	r10,1
8000b014:	19 88       	ld.ub	r8,r12[0x0]
8000b016:	16 38       	cp.w	r8,r11
8000b018:	5e 0c       	reteq	r12
8000b01a:	2f fc       	sub	r12,-1
8000b01c:	58 0a       	cp.w	r10,0
8000b01e:	cf a1       	brne	8000b012 <memchr+0x6>
8000b020:	5e fa       	retal	r10

8000b022 <memmove>:
8000b022:	d4 01       	pushm	lr
8000b024:	18 3b       	cp.w	r11,r12
8000b026:	c1 92       	brcc	8000b058 <memmove+0x36>
8000b028:	f6 0a 00 09 	add	r9,r11,r10
8000b02c:	12 3c       	cp.w	r12,r9
8000b02e:	c1 52       	brcc	8000b058 <memmove+0x36>
8000b030:	f8 0a 00 0b 	add	r11,r12,r10
8000b034:	30 08       	mov	r8,0
8000b036:	c0 68       	rjmp	8000b042 <memmove+0x20>
8000b038:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b03c:	20 1a       	sub	r10,1
8000b03e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b042:	20 18       	sub	r8,1
8000b044:	58 0a       	cp.w	r10,0
8000b046:	cf 91       	brne	8000b038 <memmove+0x16>
8000b048:	d8 02       	popm	pc
8000b04a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b04e:	20 1a       	sub	r10,1
8000b050:	f8 08 0b 09 	st.b	r12[r8],r9
8000b054:	2f f8       	sub	r8,-1
8000b056:	c0 28       	rjmp	8000b05a <memmove+0x38>
8000b058:	30 08       	mov	r8,0
8000b05a:	58 0a       	cp.w	r10,0
8000b05c:	cf 71       	brne	8000b04a <memmove+0x28>
8000b05e:	d8 02       	popm	pc

8000b060 <__hi0bits>:
8000b060:	18 98       	mov	r8,r12
8000b062:	e0 1c 00 00 	andl	r12,0x0
8000b066:	f0 09 15 10 	lsl	r9,r8,0x10
8000b06a:	58 0c       	cp.w	r12,0
8000b06c:	f2 08 17 00 	moveq	r8,r9
8000b070:	f9 bc 00 10 	moveq	r12,16
8000b074:	f9 bc 01 00 	movne	r12,0
8000b078:	10 9a       	mov	r10,r8
8000b07a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b07e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b082:	f7 bc 00 f8 	subeq	r12,-8
8000b086:	f2 08 17 00 	moveq	r8,r9
8000b08a:	10 9a       	mov	r10,r8
8000b08c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b090:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b094:	f7 bc 00 fc 	subeq	r12,-4
8000b098:	f2 08 17 00 	moveq	r8,r9
8000b09c:	10 9a       	mov	r10,r8
8000b09e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b0a2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b0a6:	f7 bc 00 fe 	subeq	r12,-2
8000b0aa:	f2 08 17 00 	moveq	r8,r9
8000b0ae:	58 08       	cp.w	r8,0
8000b0b0:	5e 5c       	retlt	r12
8000b0b2:	ed b8 00 1e 	bld	r8,0x1e
8000b0b6:	f9 bc 01 20 	movne	r12,32
8000b0ba:	f7 bc 00 ff 	subeq	r12,-1
8000b0be:	5e fc       	retal	r12

8000b0c0 <__lo0bits>:
8000b0c0:	18 99       	mov	r9,r12
8000b0c2:	78 08       	ld.w	r8,r12[0x0]
8000b0c4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b0c8:	c1 50       	breq	8000b0f2 <__lo0bits+0x32>
8000b0ca:	ed b8 00 00 	bld	r8,0x0
8000b0ce:	c0 21       	brne	8000b0d2 <__lo0bits+0x12>
8000b0d0:	5e fd       	retal	0
8000b0d2:	10 9b       	mov	r11,r8
8000b0d4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b0d8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b0dc:	a3 88       	lsr	r8,0x2
8000b0de:	58 0b       	cp.w	r11,0
8000b0e0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b0e4:	f9 bc 01 01 	movne	r12,1
8000b0e8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b0ec:	f9 bc 00 02 	moveq	r12,2
8000b0f0:	5e fc       	retal	r12
8000b0f2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b0f6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b0fa:	58 0a       	cp.w	r10,0
8000b0fc:	f6 08 17 00 	moveq	r8,r11
8000b100:	f9 bc 00 10 	moveq	r12,16
8000b104:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b108:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b10c:	58 0b       	cp.w	r11,0
8000b10e:	f7 bc 00 f8 	subeq	r12,-8
8000b112:	f4 08 17 00 	moveq	r8,r10
8000b116:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b11a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b11e:	58 0b       	cp.w	r11,0
8000b120:	f7 bc 00 fc 	subeq	r12,-4
8000b124:	f4 08 17 00 	moveq	r8,r10
8000b128:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b12c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b130:	58 0b       	cp.w	r11,0
8000b132:	f7 bc 00 fe 	subeq	r12,-2
8000b136:	f4 08 17 00 	moveq	r8,r10
8000b13a:	ed b8 00 00 	bld	r8,0x0
8000b13e:	c0 60       	breq	8000b14a <__lo0bits+0x8a>
8000b140:	a1 98       	lsr	r8,0x1
8000b142:	c0 31       	brne	8000b148 <__lo0bits+0x88>
8000b144:	32 0c       	mov	r12,32
8000b146:	5e fc       	retal	r12
8000b148:	2f fc       	sub	r12,-1
8000b14a:	93 08       	st.w	r9[0x0],r8
8000b14c:	5e fc       	retal	r12

8000b14e <__mcmp>:
8000b14e:	d4 01       	pushm	lr
8000b150:	18 98       	mov	r8,r12
8000b152:	76 49       	ld.w	r9,r11[0x10]
8000b154:	78 4c       	ld.w	r12,r12[0x10]
8000b156:	12 1c       	sub	r12,r9
8000b158:	c1 31       	brne	8000b17e <__mcmp+0x30>
8000b15a:	2f b9       	sub	r9,-5
8000b15c:	a3 69       	lsl	r9,0x2
8000b15e:	12 0b       	add	r11,r9
8000b160:	f0 09 00 09 	add	r9,r8,r9
8000b164:	2e c8       	sub	r8,-20
8000b166:	13 4e       	ld.w	lr,--r9
8000b168:	17 4a       	ld.w	r10,--r11
8000b16a:	14 3e       	cp.w	lr,r10
8000b16c:	c0 60       	breq	8000b178 <__mcmp+0x2a>
8000b16e:	f9 bc 03 ff 	movlo	r12,-1
8000b172:	f9 bc 02 01 	movhs	r12,1
8000b176:	d8 02       	popm	pc
8000b178:	10 39       	cp.w	r9,r8
8000b17a:	fe 9b ff f6 	brhi	8000b166 <__mcmp+0x18>
8000b17e:	d8 02       	popm	pc

8000b180 <_Bfree>:
8000b180:	d4 21       	pushm	r4-r7,lr
8000b182:	18 97       	mov	r7,r12
8000b184:	16 95       	mov	r5,r11
8000b186:	78 96       	ld.w	r6,r12[0x24]
8000b188:	58 06       	cp.w	r6,0
8000b18a:	c0 91       	brne	8000b19c <_Bfree+0x1c>
8000b18c:	31 0c       	mov	r12,16
8000b18e:	fe b0 de 49 	rcall	80006e20 <malloc>
8000b192:	99 36       	st.w	r12[0xc],r6
8000b194:	8f 9c       	st.w	r7[0x24],r12
8000b196:	99 16       	st.w	r12[0x4],r6
8000b198:	99 26       	st.w	r12[0x8],r6
8000b19a:	99 06       	st.w	r12[0x0],r6
8000b19c:	58 05       	cp.w	r5,0
8000b19e:	c0 90       	breq	8000b1b0 <_Bfree+0x30>
8000b1a0:	6a 19       	ld.w	r9,r5[0x4]
8000b1a2:	6e 98       	ld.w	r8,r7[0x24]
8000b1a4:	70 38       	ld.w	r8,r8[0xc]
8000b1a6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b1aa:	8b 0a       	st.w	r5[0x0],r10
8000b1ac:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b1b0:	d8 22       	popm	r4-r7,pc
8000b1b2:	d7 03       	nop

8000b1b4 <_Balloc>:
8000b1b4:	d4 21       	pushm	r4-r7,lr
8000b1b6:	18 97       	mov	r7,r12
8000b1b8:	16 96       	mov	r6,r11
8000b1ba:	78 95       	ld.w	r5,r12[0x24]
8000b1bc:	58 05       	cp.w	r5,0
8000b1be:	c0 91       	brne	8000b1d0 <_Balloc+0x1c>
8000b1c0:	31 0c       	mov	r12,16
8000b1c2:	fe b0 de 2f 	rcall	80006e20 <malloc>
8000b1c6:	99 35       	st.w	r12[0xc],r5
8000b1c8:	8f 9c       	st.w	r7[0x24],r12
8000b1ca:	99 15       	st.w	r12[0x4],r5
8000b1cc:	99 25       	st.w	r12[0x8],r5
8000b1ce:	99 05       	st.w	r12[0x0],r5
8000b1d0:	6e 95       	ld.w	r5,r7[0x24]
8000b1d2:	6a 38       	ld.w	r8,r5[0xc]
8000b1d4:	58 08       	cp.w	r8,0
8000b1d6:	c0 b1       	brne	8000b1ec <_Balloc+0x38>
8000b1d8:	31 0a       	mov	r10,16
8000b1da:	30 4b       	mov	r11,4
8000b1dc:	0e 9c       	mov	r12,r7
8000b1de:	e0 a0 02 a7 	rcall	8000b72c <_calloc_r>
8000b1e2:	8b 3c       	st.w	r5[0xc],r12
8000b1e4:	6e 98       	ld.w	r8,r7[0x24]
8000b1e6:	70 3c       	ld.w	r12,r8[0xc]
8000b1e8:	58 0c       	cp.w	r12,0
8000b1ea:	c1 b0       	breq	8000b220 <_Balloc+0x6c>
8000b1ec:	6e 98       	ld.w	r8,r7[0x24]
8000b1ee:	70 38       	ld.w	r8,r8[0xc]
8000b1f0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b1f4:	70 0c       	ld.w	r12,r8[0x0]
8000b1f6:	58 0c       	cp.w	r12,0
8000b1f8:	c0 40       	breq	8000b200 <_Balloc+0x4c>
8000b1fa:	78 09       	ld.w	r9,r12[0x0]
8000b1fc:	91 09       	st.w	r8[0x0],r9
8000b1fe:	c0 e8       	rjmp	8000b21a <_Balloc+0x66>
8000b200:	0e 9c       	mov	r12,r7
8000b202:	30 17       	mov	r7,1
8000b204:	0e 9b       	mov	r11,r7
8000b206:	ee 06 09 47 	lsl	r7,r7,r6
8000b20a:	ee ca ff fb 	sub	r10,r7,-5
8000b20e:	a3 6a       	lsl	r10,0x2
8000b210:	e0 a0 02 8e 	rcall	8000b72c <_calloc_r>
8000b214:	c0 60       	breq	8000b220 <_Balloc+0x6c>
8000b216:	99 16       	st.w	r12[0x4],r6
8000b218:	99 27       	st.w	r12[0x8],r7
8000b21a:	30 08       	mov	r8,0
8000b21c:	99 38       	st.w	r12[0xc],r8
8000b21e:	99 48       	st.w	r12[0x10],r8
8000b220:	d8 22       	popm	r4-r7,pc
8000b222:	d7 03       	nop

8000b224 <__d2b>:
8000b224:	d4 31       	pushm	r0-r7,lr
8000b226:	20 2d       	sub	sp,8
8000b228:	16 93       	mov	r3,r11
8000b22a:	12 96       	mov	r6,r9
8000b22c:	10 95       	mov	r5,r8
8000b22e:	14 92       	mov	r2,r10
8000b230:	30 1b       	mov	r11,1
8000b232:	cc 1f       	rcall	8000b1b4 <_Balloc>
8000b234:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b238:	50 09       	stdsp	sp[0x0],r9
8000b23a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b23e:	b5 a9       	sbr	r9,0x14
8000b240:	f0 01 16 14 	lsr	r1,r8,0x14
8000b244:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b248:	18 94       	mov	r4,r12
8000b24a:	58 02       	cp.w	r2,0
8000b24c:	c1 d0       	breq	8000b286 <__d2b+0x62>
8000b24e:	fa cc ff f8 	sub	r12,sp,-8
8000b252:	18 d2       	st.w	--r12,r2
8000b254:	c3 6f       	rcall	8000b0c0 <__lo0bits>
8000b256:	40 18       	lddsp	r8,sp[0x4]
8000b258:	c0 d0       	breq	8000b272 <__d2b+0x4e>
8000b25a:	40 09       	lddsp	r9,sp[0x0]
8000b25c:	f8 0a 11 20 	rsub	r10,r12,32
8000b260:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b264:	f5 e8 10 08 	or	r8,r10,r8
8000b268:	89 58       	st.w	r4[0x14],r8
8000b26a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b26e:	50 09       	stdsp	sp[0x0],r9
8000b270:	c0 28       	rjmp	8000b274 <__d2b+0x50>
8000b272:	89 58       	st.w	r4[0x14],r8
8000b274:	40 08       	lddsp	r8,sp[0x0]
8000b276:	58 08       	cp.w	r8,0
8000b278:	f9 b3 01 02 	movne	r3,2
8000b27c:	f9 b3 00 01 	moveq	r3,1
8000b280:	89 68       	st.w	r4[0x18],r8
8000b282:	89 43       	st.w	r4[0x10],r3
8000b284:	c0 88       	rjmp	8000b294 <__d2b+0x70>
8000b286:	1a 9c       	mov	r12,sp
8000b288:	c1 cf       	rcall	8000b0c0 <__lo0bits>
8000b28a:	30 13       	mov	r3,1
8000b28c:	40 08       	lddsp	r8,sp[0x0]
8000b28e:	2e 0c       	sub	r12,-32
8000b290:	89 43       	st.w	r4[0x10],r3
8000b292:	89 58       	st.w	r4[0x14],r8
8000b294:	58 01       	cp.w	r1,0
8000b296:	c0 90       	breq	8000b2a8 <__d2b+0x84>
8000b298:	e2 c1 04 33 	sub	r1,r1,1075
8000b29c:	18 01       	add	r1,r12
8000b29e:	8d 01       	st.w	r6[0x0],r1
8000b2a0:	f8 0c 11 35 	rsub	r12,r12,53
8000b2a4:	8b 0c       	st.w	r5[0x0],r12
8000b2a6:	c0 c8       	rjmp	8000b2be <__d2b+0x9a>
8000b2a8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b2ac:	f8 cc 04 32 	sub	r12,r12,1074
8000b2b0:	a5 73       	lsl	r3,0x5
8000b2b2:	8d 0c       	st.w	r6[0x0],r12
8000b2b4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b2b8:	cd 4e       	rcall	8000b060 <__hi0bits>
8000b2ba:	18 13       	sub	r3,r12
8000b2bc:	8b 03       	st.w	r5[0x0],r3
8000b2be:	08 9c       	mov	r12,r4
8000b2c0:	2f ed       	sub	sp,-8
8000b2c2:	d8 32       	popm	r0-r7,pc

8000b2c4 <__mdiff>:
8000b2c4:	d4 31       	pushm	r0-r7,lr
8000b2c6:	74 48       	ld.w	r8,r10[0x10]
8000b2c8:	76 45       	ld.w	r5,r11[0x10]
8000b2ca:	16 97       	mov	r7,r11
8000b2cc:	14 96       	mov	r6,r10
8000b2ce:	10 15       	sub	r5,r8
8000b2d0:	c1 31       	brne	8000b2f6 <__mdiff+0x32>
8000b2d2:	2f b8       	sub	r8,-5
8000b2d4:	ee ce ff ec 	sub	lr,r7,-20
8000b2d8:	a3 68       	lsl	r8,0x2
8000b2da:	f4 08 00 0b 	add	r11,r10,r8
8000b2de:	ee 08 00 08 	add	r8,r7,r8
8000b2e2:	11 4a       	ld.w	r10,--r8
8000b2e4:	17 49       	ld.w	r9,--r11
8000b2e6:	12 3a       	cp.w	r10,r9
8000b2e8:	c0 30       	breq	8000b2ee <__mdiff+0x2a>
8000b2ea:	c0 e2       	brcc	8000b306 <__mdiff+0x42>
8000b2ec:	c0 78       	rjmp	8000b2fa <__mdiff+0x36>
8000b2ee:	1c 38       	cp.w	r8,lr
8000b2f0:	fe 9b ff f9 	brhi	8000b2e2 <__mdiff+0x1e>
8000b2f4:	c4 98       	rjmp	8000b386 <__mdiff+0xc2>
8000b2f6:	58 05       	cp.w	r5,0
8000b2f8:	c0 64       	brge	8000b304 <__mdiff+0x40>
8000b2fa:	0e 98       	mov	r8,r7
8000b2fc:	30 15       	mov	r5,1
8000b2fe:	0c 97       	mov	r7,r6
8000b300:	10 96       	mov	r6,r8
8000b302:	c0 28       	rjmp	8000b306 <__mdiff+0x42>
8000b304:	30 05       	mov	r5,0
8000b306:	6e 1b       	ld.w	r11,r7[0x4]
8000b308:	c5 6f       	rcall	8000b1b4 <_Balloc>
8000b30a:	6e 49       	ld.w	r9,r7[0x10]
8000b30c:	6c 44       	ld.w	r4,r6[0x10]
8000b30e:	99 35       	st.w	r12[0xc],r5
8000b310:	2f b4       	sub	r4,-5
8000b312:	f2 c5 ff fb 	sub	r5,r9,-5
8000b316:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b31a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b31e:	2e c6       	sub	r6,-20
8000b320:	2e c7       	sub	r7,-20
8000b322:	f8 c8 ff ec 	sub	r8,r12,-20
8000b326:	30 0a       	mov	r10,0
8000b328:	0f 0e       	ld.w	lr,r7++
8000b32a:	0d 0b       	ld.w	r11,r6++
8000b32c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b330:	f6 03 16 10 	lsr	r3,r11,0x10
8000b334:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b338:	e4 03 01 03 	sub	r3,r2,r3
8000b33c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b340:	fc 0b 01 0b 	sub	r11,lr,r11
8000b344:	f6 0a 00 0a 	add	r10,r11,r10
8000b348:	b0 1a       	st.h	r8[0x2],r10
8000b34a:	b1 4a       	asr	r10,0x10
8000b34c:	e6 0a 00 0a 	add	r10,r3,r10
8000b350:	b0 0a       	st.h	r8[0x0],r10
8000b352:	2f c8       	sub	r8,-4
8000b354:	b1 4a       	asr	r10,0x10
8000b356:	08 36       	cp.w	r6,r4
8000b358:	ce 83       	brcs	8000b328 <__mdiff+0x64>
8000b35a:	c0 d8       	rjmp	8000b374 <__mdiff+0xb0>
8000b35c:	0f 0b       	ld.w	r11,r7++
8000b35e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b362:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b366:	16 0a       	add	r10,r11
8000b368:	b0 1a       	st.h	r8[0x2],r10
8000b36a:	b1 4a       	asr	r10,0x10
8000b36c:	1c 0a       	add	r10,lr
8000b36e:	b0 0a       	st.h	r8[0x0],r10
8000b370:	2f c8       	sub	r8,-4
8000b372:	b1 4a       	asr	r10,0x10
8000b374:	0a 37       	cp.w	r7,r5
8000b376:	cf 33       	brcs	8000b35c <__mdiff+0x98>
8000b378:	c0 28       	rjmp	8000b37c <__mdiff+0xb8>
8000b37a:	20 19       	sub	r9,1
8000b37c:	11 4a       	ld.w	r10,--r8
8000b37e:	58 0a       	cp.w	r10,0
8000b380:	cf d0       	breq	8000b37a <__mdiff+0xb6>
8000b382:	99 49       	st.w	r12[0x10],r9
8000b384:	d8 32       	popm	r0-r7,pc
8000b386:	30 0b       	mov	r11,0
8000b388:	c1 6f       	rcall	8000b1b4 <_Balloc>
8000b38a:	30 18       	mov	r8,1
8000b38c:	99 48       	st.w	r12[0x10],r8
8000b38e:	30 08       	mov	r8,0
8000b390:	99 58       	st.w	r12[0x14],r8
8000b392:	d8 32       	popm	r0-r7,pc

8000b394 <__lshift>:
8000b394:	d4 31       	pushm	r0-r7,lr
8000b396:	16 97       	mov	r7,r11
8000b398:	76 46       	ld.w	r6,r11[0x10]
8000b39a:	f4 02 14 05 	asr	r2,r10,0x5
8000b39e:	2f f6       	sub	r6,-1
8000b3a0:	14 93       	mov	r3,r10
8000b3a2:	18 94       	mov	r4,r12
8000b3a4:	04 06       	add	r6,r2
8000b3a6:	76 1b       	ld.w	r11,r11[0x4]
8000b3a8:	6e 28       	ld.w	r8,r7[0x8]
8000b3aa:	c0 38       	rjmp	8000b3b0 <__lshift+0x1c>
8000b3ac:	2f fb       	sub	r11,-1
8000b3ae:	a1 78       	lsl	r8,0x1
8000b3b0:	10 36       	cp.w	r6,r8
8000b3b2:	fe 99 ff fd 	brgt	8000b3ac <__lshift+0x18>
8000b3b6:	08 9c       	mov	r12,r4
8000b3b8:	cf ee       	rcall	8000b1b4 <_Balloc>
8000b3ba:	30 09       	mov	r9,0
8000b3bc:	18 95       	mov	r5,r12
8000b3be:	f8 c8 ff ec 	sub	r8,r12,-20
8000b3c2:	12 9a       	mov	r10,r9
8000b3c4:	c0 38       	rjmp	8000b3ca <__lshift+0x36>
8000b3c6:	10 aa       	st.w	r8++,r10
8000b3c8:	2f f9       	sub	r9,-1
8000b3ca:	04 39       	cp.w	r9,r2
8000b3cc:	cf d5       	brlt	8000b3c6 <__lshift+0x32>
8000b3ce:	6e 4b       	ld.w	r11,r7[0x10]
8000b3d0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b3d4:	2f bb       	sub	r11,-5
8000b3d6:	ee c9 ff ec 	sub	r9,r7,-20
8000b3da:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b3de:	58 03       	cp.w	r3,0
8000b3e0:	c1 30       	breq	8000b406 <__lshift+0x72>
8000b3e2:	e6 0c 11 20 	rsub	r12,r3,32
8000b3e6:	30 0a       	mov	r10,0
8000b3e8:	72 02       	ld.w	r2,r9[0x0]
8000b3ea:	e4 03 09 42 	lsl	r2,r2,r3
8000b3ee:	04 4a       	or	r10,r2
8000b3f0:	10 aa       	st.w	r8++,r10
8000b3f2:	13 0a       	ld.w	r10,r9++
8000b3f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3f8:	16 39       	cp.w	r9,r11
8000b3fa:	cf 73       	brcs	8000b3e8 <__lshift+0x54>
8000b3fc:	91 0a       	st.w	r8[0x0],r10
8000b3fe:	58 0a       	cp.w	r10,0
8000b400:	c0 70       	breq	8000b40e <__lshift+0x7a>
8000b402:	2f f6       	sub	r6,-1
8000b404:	c0 58       	rjmp	8000b40e <__lshift+0x7a>
8000b406:	13 0a       	ld.w	r10,r9++
8000b408:	10 aa       	st.w	r8++,r10
8000b40a:	16 39       	cp.w	r9,r11
8000b40c:	cf d3       	brcs	8000b406 <__lshift+0x72>
8000b40e:	08 9c       	mov	r12,r4
8000b410:	20 16       	sub	r6,1
8000b412:	0e 9b       	mov	r11,r7
8000b414:	8b 46       	st.w	r5[0x10],r6
8000b416:	cb 5e       	rcall	8000b180 <_Bfree>
8000b418:	0a 9c       	mov	r12,r5
8000b41a:	d8 32       	popm	r0-r7,pc

8000b41c <__multiply>:
8000b41c:	d4 31       	pushm	r0-r7,lr
8000b41e:	20 2d       	sub	sp,8
8000b420:	76 49       	ld.w	r9,r11[0x10]
8000b422:	74 48       	ld.w	r8,r10[0x10]
8000b424:	16 96       	mov	r6,r11
8000b426:	14 95       	mov	r5,r10
8000b428:	10 39       	cp.w	r9,r8
8000b42a:	ec 08 17 50 	movlt	r8,r6
8000b42e:	ea 06 17 50 	movlt	r6,r5
8000b432:	f0 05 17 50 	movlt	r5,r8
8000b436:	6c 28       	ld.w	r8,r6[0x8]
8000b438:	76 43       	ld.w	r3,r11[0x10]
8000b43a:	74 42       	ld.w	r2,r10[0x10]
8000b43c:	76 1b       	ld.w	r11,r11[0x4]
8000b43e:	e4 03 00 07 	add	r7,r2,r3
8000b442:	10 37       	cp.w	r7,r8
8000b444:	f7 bb 09 ff 	subgt	r11,-1
8000b448:	cb 6e       	rcall	8000b1b4 <_Balloc>
8000b44a:	ee c4 ff fb 	sub	r4,r7,-5
8000b44e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b452:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b456:	30 0a       	mov	r10,0
8000b458:	12 98       	mov	r8,r9
8000b45a:	c0 28       	rjmp	8000b45e <__multiply+0x42>
8000b45c:	10 aa       	st.w	r8++,r10
8000b45e:	08 38       	cp.w	r8,r4
8000b460:	cf e3       	brcs	8000b45c <__multiply+0x40>
8000b462:	2f b3       	sub	r3,-5
8000b464:	2f b2       	sub	r2,-5
8000b466:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b46a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b46e:	ec cb ff ec 	sub	r11,r6,-20
8000b472:	50 12       	stdsp	sp[0x4],r2
8000b474:	ea ca ff ec 	sub	r10,r5,-20
8000b478:	c4 48       	rjmp	8000b500 <__multiply+0xe4>
8000b47a:	94 95       	ld.uh	r5,r10[0x2]
8000b47c:	58 05       	cp.w	r5,0
8000b47e:	c2 00       	breq	8000b4be <__multiply+0xa2>
8000b480:	12 98       	mov	r8,r9
8000b482:	16 96       	mov	r6,r11
8000b484:	30 0e       	mov	lr,0
8000b486:	50 09       	stdsp	sp[0x0],r9
8000b488:	0d 02       	ld.w	r2,r6++
8000b48a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b48e:	70 01       	ld.w	r1,r8[0x0]
8000b490:	70 09       	ld.w	r9,r8[0x0]
8000b492:	b1 81       	lsr	r1,0x10
8000b494:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b498:	e0 05 03 41 	mac	r1,r0,r5
8000b49c:	ab 32       	mul	r2,r5
8000b49e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b4a2:	00 02       	add	r2,r0
8000b4a4:	e4 0e 00 0e 	add	lr,r2,lr
8000b4a8:	b0 1e       	st.h	r8[0x2],lr
8000b4aa:	b1 8e       	lsr	lr,0x10
8000b4ac:	1c 01       	add	r1,lr
8000b4ae:	b0 01       	st.h	r8[0x0],r1
8000b4b0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b4b4:	2f c8       	sub	r8,-4
8000b4b6:	06 36       	cp.w	r6,r3
8000b4b8:	ce 83       	brcs	8000b488 <__multiply+0x6c>
8000b4ba:	40 09       	lddsp	r9,sp[0x0]
8000b4bc:	91 0e       	st.w	r8[0x0],lr
8000b4be:	94 86       	ld.uh	r6,r10[0x0]
8000b4c0:	58 06       	cp.w	r6,0
8000b4c2:	c1 d0       	breq	8000b4fc <__multiply+0xe0>
8000b4c4:	72 02       	ld.w	r2,r9[0x0]
8000b4c6:	12 98       	mov	r8,r9
8000b4c8:	16 9e       	mov	lr,r11
8000b4ca:	30 05       	mov	r5,0
8000b4cc:	b0 12       	st.h	r8[0x2],r2
8000b4ce:	1d 01       	ld.w	r1,lr++
8000b4d0:	90 82       	ld.uh	r2,r8[0x0]
8000b4d2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b4d6:	ad 30       	mul	r0,r6
8000b4d8:	e0 02 00 02 	add	r2,r0,r2
8000b4dc:	e4 05 00 05 	add	r5,r2,r5
8000b4e0:	b0 05       	st.h	r8[0x0],r5
8000b4e2:	b1 85       	lsr	r5,0x10
8000b4e4:	b1 81       	lsr	r1,0x10
8000b4e6:	2f c8       	sub	r8,-4
8000b4e8:	ad 31       	mul	r1,r6
8000b4ea:	90 92       	ld.uh	r2,r8[0x2]
8000b4ec:	e2 02 00 02 	add	r2,r1,r2
8000b4f0:	0a 02       	add	r2,r5
8000b4f2:	e4 05 16 10 	lsr	r5,r2,0x10
8000b4f6:	06 3e       	cp.w	lr,r3
8000b4f8:	ce a3       	brcs	8000b4cc <__multiply+0xb0>
8000b4fa:	91 02       	st.w	r8[0x0],r2
8000b4fc:	2f ca       	sub	r10,-4
8000b4fe:	2f c9       	sub	r9,-4
8000b500:	40 18       	lddsp	r8,sp[0x4]
8000b502:	10 3a       	cp.w	r10,r8
8000b504:	cb b3       	brcs	8000b47a <__multiply+0x5e>
8000b506:	c0 28       	rjmp	8000b50a <__multiply+0xee>
8000b508:	20 17       	sub	r7,1
8000b50a:	58 07       	cp.w	r7,0
8000b50c:	e0 8a 00 05 	brle	8000b516 <__multiply+0xfa>
8000b510:	09 48       	ld.w	r8,--r4
8000b512:	58 08       	cp.w	r8,0
8000b514:	cf a0       	breq	8000b508 <__multiply+0xec>
8000b516:	99 47       	st.w	r12[0x10],r7
8000b518:	2f ed       	sub	sp,-8
8000b51a:	d8 32       	popm	r0-r7,pc

8000b51c <__i2b>:
8000b51c:	d4 21       	pushm	r4-r7,lr
8000b51e:	16 97       	mov	r7,r11
8000b520:	30 1b       	mov	r11,1
8000b522:	c4 9e       	rcall	8000b1b4 <_Balloc>
8000b524:	30 19       	mov	r9,1
8000b526:	99 57       	st.w	r12[0x14],r7
8000b528:	99 49       	st.w	r12[0x10],r9
8000b52a:	d8 22       	popm	r4-r7,pc

8000b52c <__multadd>:
8000b52c:	d4 31       	pushm	r0-r7,lr
8000b52e:	30 08       	mov	r8,0
8000b530:	12 95       	mov	r5,r9
8000b532:	16 97       	mov	r7,r11
8000b534:	18 96       	mov	r6,r12
8000b536:	76 44       	ld.w	r4,r11[0x10]
8000b538:	f6 c9 ff ec 	sub	r9,r11,-20
8000b53c:	72 0b       	ld.w	r11,r9[0x0]
8000b53e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b542:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b546:	f4 0c 02 4c 	mul	r12,r10,r12
8000b54a:	f4 0b 03 45 	mac	r5,r10,r11
8000b54e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b552:	b1 85       	lsr	r5,0x10
8000b554:	18 05       	add	r5,r12
8000b556:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b55a:	f8 0b 00 0b 	add	r11,r12,r11
8000b55e:	12 ab       	st.w	r9++,r11
8000b560:	2f f8       	sub	r8,-1
8000b562:	b1 85       	lsr	r5,0x10
8000b564:	08 38       	cp.w	r8,r4
8000b566:	ce b5       	brlt	8000b53c <__multadd+0x10>
8000b568:	58 05       	cp.w	r5,0
8000b56a:	c1 c0       	breq	8000b5a2 <__multadd+0x76>
8000b56c:	6e 28       	ld.w	r8,r7[0x8]
8000b56e:	10 34       	cp.w	r4,r8
8000b570:	c1 35       	brlt	8000b596 <__multadd+0x6a>
8000b572:	6e 1b       	ld.w	r11,r7[0x4]
8000b574:	0c 9c       	mov	r12,r6
8000b576:	2f fb       	sub	r11,-1
8000b578:	c1 ee       	rcall	8000b1b4 <_Balloc>
8000b57a:	6e 4a       	ld.w	r10,r7[0x10]
8000b57c:	ee cb ff f4 	sub	r11,r7,-12
8000b580:	18 93       	mov	r3,r12
8000b582:	2f ea       	sub	r10,-2
8000b584:	2f 4c       	sub	r12,-12
8000b586:	a3 6a       	lsl	r10,0x2
8000b588:	fe b0 de 70 	rcall	80007268 <memcpy>
8000b58c:	0e 9b       	mov	r11,r7
8000b58e:	0c 9c       	mov	r12,r6
8000b590:	fe b0 fd f8 	rcall	8000b180 <_Bfree>
8000b594:	06 97       	mov	r7,r3
8000b596:	e8 c8 ff ff 	sub	r8,r4,-1
8000b59a:	2f b4       	sub	r4,-5
8000b59c:	8f 48       	st.w	r7[0x10],r8
8000b59e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b5a2:	0e 9c       	mov	r12,r7
8000b5a4:	d8 32       	popm	r0-r7,pc
8000b5a6:	d7 03       	nop

8000b5a8 <__pow5mult>:
8000b5a8:	d4 31       	pushm	r0-r7,lr
8000b5aa:	14 96       	mov	r6,r10
8000b5ac:	18 97       	mov	r7,r12
8000b5ae:	16 94       	mov	r4,r11
8000b5b0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b5b4:	c0 90       	breq	8000b5c6 <__pow5mult+0x1e>
8000b5b6:	20 18       	sub	r8,1
8000b5b8:	fe c9 db 58 	sub	r9,pc,-9384
8000b5bc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b5c0:	30 09       	mov	r9,0
8000b5c2:	cb 5f       	rcall	8000b52c <__multadd>
8000b5c4:	18 94       	mov	r4,r12
8000b5c6:	a3 46       	asr	r6,0x2
8000b5c8:	c3 40       	breq	8000b630 <__pow5mult+0x88>
8000b5ca:	6e 95       	ld.w	r5,r7[0x24]
8000b5cc:	58 05       	cp.w	r5,0
8000b5ce:	c0 91       	brne	8000b5e0 <__pow5mult+0x38>
8000b5d0:	31 0c       	mov	r12,16
8000b5d2:	fe b0 dc 27 	rcall	80006e20 <malloc>
8000b5d6:	99 35       	st.w	r12[0xc],r5
8000b5d8:	8f 9c       	st.w	r7[0x24],r12
8000b5da:	99 15       	st.w	r12[0x4],r5
8000b5dc:	99 25       	st.w	r12[0x8],r5
8000b5de:	99 05       	st.w	r12[0x0],r5
8000b5e0:	6e 93       	ld.w	r3,r7[0x24]
8000b5e2:	66 25       	ld.w	r5,r3[0x8]
8000b5e4:	58 05       	cp.w	r5,0
8000b5e6:	c0 c1       	brne	8000b5fe <__pow5mult+0x56>
8000b5e8:	e0 6b 02 71 	mov	r11,625
8000b5ec:	0e 9c       	mov	r12,r7
8000b5ee:	c9 7f       	rcall	8000b51c <__i2b>
8000b5f0:	87 2c       	st.w	r3[0x8],r12
8000b5f2:	30 08       	mov	r8,0
8000b5f4:	18 95       	mov	r5,r12
8000b5f6:	99 08       	st.w	r12[0x0],r8
8000b5f8:	c0 38       	rjmp	8000b5fe <__pow5mult+0x56>
8000b5fa:	06 9c       	mov	r12,r3
8000b5fc:	18 95       	mov	r5,r12
8000b5fe:	ed b6 00 00 	bld	r6,0x0
8000b602:	c0 b1       	brne	8000b618 <__pow5mult+0x70>
8000b604:	08 9b       	mov	r11,r4
8000b606:	0a 9a       	mov	r10,r5
8000b608:	0e 9c       	mov	r12,r7
8000b60a:	c0 9f       	rcall	8000b41c <__multiply>
8000b60c:	08 9b       	mov	r11,r4
8000b60e:	18 93       	mov	r3,r12
8000b610:	0e 9c       	mov	r12,r7
8000b612:	06 94       	mov	r4,r3
8000b614:	fe b0 fd b6 	rcall	8000b180 <_Bfree>
8000b618:	a1 56       	asr	r6,0x1
8000b61a:	c0 b0       	breq	8000b630 <__pow5mult+0x88>
8000b61c:	6a 03       	ld.w	r3,r5[0x0]
8000b61e:	58 03       	cp.w	r3,0
8000b620:	ce d1       	brne	8000b5fa <__pow5mult+0x52>
8000b622:	0a 9a       	mov	r10,r5
8000b624:	0a 9b       	mov	r11,r5
8000b626:	0e 9c       	mov	r12,r7
8000b628:	cf ae       	rcall	8000b41c <__multiply>
8000b62a:	8b 0c       	st.w	r5[0x0],r12
8000b62c:	99 03       	st.w	r12[0x0],r3
8000b62e:	ce 7b       	rjmp	8000b5fc <__pow5mult+0x54>
8000b630:	08 9c       	mov	r12,r4
8000b632:	d8 32       	popm	r0-r7,pc

8000b634 <__isinfd>:
8000b634:	14 98       	mov	r8,r10
8000b636:	fc 19 7f f0 	movh	r9,0x7ff0
8000b63a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b63e:	f0 0b 11 00 	rsub	r11,r8,0
8000b642:	f7 e8 10 08 	or	r8,r11,r8
8000b646:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b64a:	f2 08 01 08 	sub	r8,r9,r8
8000b64e:	f0 0c 11 00 	rsub	r12,r8,0
8000b652:	f9 e8 10 08 	or	r8,r12,r8
8000b656:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b65a:	2f fc       	sub	r12,-1
8000b65c:	5e fc       	retal	r12

8000b65e <__isnand>:
8000b65e:	14 98       	mov	r8,r10
8000b660:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b664:	f0 0c 11 00 	rsub	r12,r8,0
8000b668:	10 4c       	or	r12,r8
8000b66a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b66e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b672:	f0 0c 01 0c 	sub	r12,r8,r12
8000b676:	bf 9c       	lsr	r12,0x1f
8000b678:	5e fc       	retal	r12
8000b67a:	d7 03       	nop

8000b67c <__sclose>:
8000b67c:	d4 01       	pushm	lr
8000b67e:	96 7b       	ld.sh	r11,r11[0xe]
8000b680:	c8 2c       	rcall	8000b784 <_close_r>
8000b682:	d8 02       	popm	pc

8000b684 <__sseek>:
8000b684:	d4 21       	pushm	r4-r7,lr
8000b686:	16 97       	mov	r7,r11
8000b688:	96 7b       	ld.sh	r11,r11[0xe]
8000b68a:	c0 3d       	rcall	8000b890 <_lseek_r>
8000b68c:	8e 68       	ld.sh	r8,r7[0xc]
8000b68e:	10 99       	mov	r9,r8
8000b690:	ad c8       	cbr	r8,0xc
8000b692:	ad a9       	sbr	r9,0xc
8000b694:	5b fc       	cp.w	r12,-1
8000b696:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b69a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b69e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b6a2:	d8 22       	popm	r4-r7,pc

8000b6a4 <__swrite>:
8000b6a4:	d4 21       	pushm	r4-r7,lr
8000b6a6:	96 68       	ld.sh	r8,r11[0xc]
8000b6a8:	16 97       	mov	r7,r11
8000b6aa:	14 95       	mov	r5,r10
8000b6ac:	12 94       	mov	r4,r9
8000b6ae:	e2 18 01 00 	andl	r8,0x100,COH
8000b6b2:	18 96       	mov	r6,r12
8000b6b4:	c0 50       	breq	8000b6be <__swrite+0x1a>
8000b6b6:	30 29       	mov	r9,2
8000b6b8:	30 0a       	mov	r10,0
8000b6ba:	96 7b       	ld.sh	r11,r11[0xe]
8000b6bc:	ce ac       	rcall	8000b890 <_lseek_r>
8000b6be:	8e 68       	ld.sh	r8,r7[0xc]
8000b6c0:	ad c8       	cbr	r8,0xc
8000b6c2:	08 99       	mov	r9,r4
8000b6c4:	0a 9a       	mov	r10,r5
8000b6c6:	8e 7b       	ld.sh	r11,r7[0xe]
8000b6c8:	0c 9c       	mov	r12,r6
8000b6ca:	ae 68       	st.h	r7[0xc],r8
8000b6cc:	c1 cc       	rcall	8000b704 <_write_r>
8000b6ce:	d8 22       	popm	r4-r7,pc

8000b6d0 <__sread>:
8000b6d0:	d4 21       	pushm	r4-r7,lr
8000b6d2:	16 97       	mov	r7,r11
8000b6d4:	96 7b       	ld.sh	r11,r11[0xe]
8000b6d6:	cf 1c       	rcall	8000b8b8 <_read_r>
8000b6d8:	c0 65       	brlt	8000b6e4 <__sread+0x14>
8000b6da:	6f 58       	ld.w	r8,r7[0x54]
8000b6dc:	18 08       	add	r8,r12
8000b6de:	ef 48 00 54 	st.w	r7[84],r8
8000b6e2:	d8 22       	popm	r4-r7,pc
8000b6e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b6e6:	ad c8       	cbr	r8,0xc
8000b6e8:	ae 68       	st.h	r7[0xc],r8
8000b6ea:	d8 22       	popm	r4-r7,pc

8000b6ec <strlen>:
8000b6ec:	30 09       	mov	r9,0
8000b6ee:	18 98       	mov	r8,r12
8000b6f0:	c0 28       	rjmp	8000b6f4 <strlen+0x8>
8000b6f2:	2f f8       	sub	r8,-1
8000b6f4:	11 8a       	ld.ub	r10,r8[0x0]
8000b6f6:	f2 0a 18 00 	cp.b	r10,r9
8000b6fa:	cf c1       	brne	8000b6f2 <strlen+0x6>
8000b6fc:	f0 0c 01 0c 	sub	r12,r8,r12
8000b700:	5e fc       	retal	r12
8000b702:	d7 03       	nop

8000b704 <_write_r>:
8000b704:	d4 21       	pushm	r4-r7,lr
8000b706:	16 98       	mov	r8,r11
8000b708:	18 97       	mov	r7,r12
8000b70a:	10 9c       	mov	r12,r8
8000b70c:	30 08       	mov	r8,0
8000b70e:	14 9b       	mov	r11,r10
8000b710:	e0 66 41 18 	mov	r6,16664
8000b714:	12 9a       	mov	r10,r9
8000b716:	8d 08       	st.w	r6[0x0],r8
8000b718:	fe b0 d1 b6 	rcall	80005a84 <_write>
8000b71c:	5b fc       	cp.w	r12,-1
8000b71e:	c0 51       	brne	8000b728 <_write_r+0x24>
8000b720:	6c 08       	ld.w	r8,r6[0x0]
8000b722:	58 08       	cp.w	r8,0
8000b724:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b728:	d8 22       	popm	r4-r7,pc
8000b72a:	d7 03       	nop

8000b72c <_calloc_r>:
8000b72c:	d4 21       	pushm	r4-r7,lr
8000b72e:	f4 0b 02 4b 	mul	r11,r10,r11
8000b732:	fe b0 db 7f 	rcall	80006e30 <_malloc_r>
8000b736:	18 97       	mov	r7,r12
8000b738:	c2 30       	breq	8000b77e <_calloc_r+0x52>
8000b73a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b73e:	e0 1a ff fc 	andl	r10,0xfffc
8000b742:	20 4a       	sub	r10,4
8000b744:	e0 4a 00 24 	cp.w	r10,36
8000b748:	e0 8b 00 18 	brhi	8000b778 <_calloc_r+0x4c>
8000b74c:	18 98       	mov	r8,r12
8000b74e:	59 3a       	cp.w	r10,19
8000b750:	e0 88 00 0f 	brls	8000b76e <_calloc_r+0x42>
8000b754:	30 09       	mov	r9,0
8000b756:	10 a9       	st.w	r8++,r9
8000b758:	10 a9       	st.w	r8++,r9
8000b75a:	59 ba       	cp.w	r10,27
8000b75c:	e0 88 00 09 	brls	8000b76e <_calloc_r+0x42>
8000b760:	10 a9       	st.w	r8++,r9
8000b762:	10 a9       	st.w	r8++,r9
8000b764:	e0 4a 00 24 	cp.w	r10,36
8000b768:	c0 31       	brne	8000b76e <_calloc_r+0x42>
8000b76a:	10 a9       	st.w	r8++,r9
8000b76c:	10 a9       	st.w	r8++,r9
8000b76e:	30 09       	mov	r9,0
8000b770:	10 a9       	st.w	r8++,r9
8000b772:	91 19       	st.w	r8[0x4],r9
8000b774:	91 09       	st.w	r8[0x0],r9
8000b776:	c0 48       	rjmp	8000b77e <_calloc_r+0x52>
8000b778:	30 0b       	mov	r11,0
8000b77a:	fe b0 de 1b 	rcall	800073b0 <memset>
8000b77e:	0e 9c       	mov	r12,r7
8000b780:	d8 22       	popm	r4-r7,pc
8000b782:	d7 03       	nop

8000b784 <_close_r>:
8000b784:	d4 21       	pushm	r4-r7,lr
8000b786:	30 08       	mov	r8,0
8000b788:	18 97       	mov	r7,r12
8000b78a:	e0 66 41 18 	mov	r6,16664
8000b78e:	16 9c       	mov	r12,r11
8000b790:	8d 08       	st.w	r6[0x0],r8
8000b792:	fe b0 df b5 	rcall	800076fc <_close>
8000b796:	5b fc       	cp.w	r12,-1
8000b798:	c0 51       	brne	8000b7a2 <_close_r+0x1e>
8000b79a:	6c 08       	ld.w	r8,r6[0x0]
8000b79c:	58 08       	cp.w	r8,0
8000b79e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7a2:	d8 22       	popm	r4-r7,pc

8000b7a4 <_fclose_r>:
8000b7a4:	d4 21       	pushm	r4-r7,lr
8000b7a6:	18 96       	mov	r6,r12
8000b7a8:	16 97       	mov	r7,r11
8000b7aa:	58 0b       	cp.w	r11,0
8000b7ac:	c0 31       	brne	8000b7b2 <_fclose_r+0xe>
8000b7ae:	16 95       	mov	r5,r11
8000b7b0:	c5 38       	rjmp	8000b856 <_fclose_r+0xb2>
8000b7b2:	fe b0 f8 a9 	rcall	8000a904 <__sfp_lock_acquire>
8000b7b6:	58 06       	cp.w	r6,0
8000b7b8:	c0 70       	breq	8000b7c6 <_fclose_r+0x22>
8000b7ba:	6c 68       	ld.w	r8,r6[0x18]
8000b7bc:	58 08       	cp.w	r8,0
8000b7be:	c0 41       	brne	8000b7c6 <_fclose_r+0x22>
8000b7c0:	0c 9c       	mov	r12,r6
8000b7c2:	fe b0 f8 f3 	rcall	8000a9a8 <__sinit>
8000b7c6:	fe c8 de 0a 	sub	r8,pc,-8694
8000b7ca:	10 37       	cp.w	r7,r8
8000b7cc:	c0 31       	brne	8000b7d2 <_fclose_r+0x2e>
8000b7ce:	6c 07       	ld.w	r7,r6[0x0]
8000b7d0:	c0 c8       	rjmp	8000b7e8 <_fclose_r+0x44>
8000b7d2:	fe c8 dd f6 	sub	r8,pc,-8714
8000b7d6:	10 37       	cp.w	r7,r8
8000b7d8:	c0 31       	brne	8000b7de <_fclose_r+0x3a>
8000b7da:	6c 17       	ld.w	r7,r6[0x4]
8000b7dc:	c0 68       	rjmp	8000b7e8 <_fclose_r+0x44>
8000b7de:	fe c8 dd e2 	sub	r8,pc,-8734
8000b7e2:	10 37       	cp.w	r7,r8
8000b7e4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b7e8:	8e 69       	ld.sh	r9,r7[0xc]
8000b7ea:	30 08       	mov	r8,0
8000b7ec:	f0 09 19 00 	cp.h	r9,r8
8000b7f0:	c0 51       	brne	8000b7fa <_fclose_r+0x56>
8000b7f2:	fe b0 f8 8a 	rcall	8000a906 <__sfp_lock_release>
8000b7f6:	30 05       	mov	r5,0
8000b7f8:	c2 f8       	rjmp	8000b856 <_fclose_r+0xb2>
8000b7fa:	0e 9b       	mov	r11,r7
8000b7fc:	0c 9c       	mov	r12,r6
8000b7fe:	fe b0 f7 fd 	rcall	8000a7f8 <_fflush_r>
8000b802:	6e c8       	ld.w	r8,r7[0x30]
8000b804:	18 95       	mov	r5,r12
8000b806:	58 08       	cp.w	r8,0
8000b808:	c0 60       	breq	8000b814 <_fclose_r+0x70>
8000b80a:	6e 8b       	ld.w	r11,r7[0x20]
8000b80c:	0c 9c       	mov	r12,r6
8000b80e:	5d 18       	icall	r8
8000b810:	f9 b5 05 ff 	movlt	r5,-1
8000b814:	8e 68       	ld.sh	r8,r7[0xc]
8000b816:	ed b8 00 07 	bld	r8,0x7
8000b81a:	c0 51       	brne	8000b824 <_fclose_r+0x80>
8000b81c:	6e 4b       	ld.w	r11,r7[0x10]
8000b81e:	0c 9c       	mov	r12,r6
8000b820:	fe b0 f9 5e 	rcall	8000aadc <_free_r>
8000b824:	6e db       	ld.w	r11,r7[0x34]
8000b826:	58 0b       	cp.w	r11,0
8000b828:	c0 a0       	breq	8000b83c <_fclose_r+0x98>
8000b82a:	ee c8 ff bc 	sub	r8,r7,-68
8000b82e:	10 3b       	cp.w	r11,r8
8000b830:	c0 40       	breq	8000b838 <_fclose_r+0x94>
8000b832:	0c 9c       	mov	r12,r6
8000b834:	fe b0 f9 54 	rcall	8000aadc <_free_r>
8000b838:	30 08       	mov	r8,0
8000b83a:	8f d8       	st.w	r7[0x34],r8
8000b83c:	6f 2b       	ld.w	r11,r7[0x48]
8000b83e:	58 0b       	cp.w	r11,0
8000b840:	c0 70       	breq	8000b84e <_fclose_r+0xaa>
8000b842:	0c 9c       	mov	r12,r6
8000b844:	fe b0 f9 4c 	rcall	8000aadc <_free_r>
8000b848:	30 08       	mov	r8,0
8000b84a:	ef 48 00 48 	st.w	r7[72],r8
8000b84e:	30 08       	mov	r8,0
8000b850:	ae 68       	st.h	r7[0xc],r8
8000b852:	fe b0 f8 5a 	rcall	8000a906 <__sfp_lock_release>
8000b856:	0a 9c       	mov	r12,r5
8000b858:	d8 22       	popm	r4-r7,pc
8000b85a:	d7 03       	nop

8000b85c <fclose>:
8000b85c:	d4 01       	pushm	lr
8000b85e:	e0 68 0a 38 	mov	r8,2616
8000b862:	18 9b       	mov	r11,r12
8000b864:	70 0c       	ld.w	r12,r8[0x0]
8000b866:	c9 ff       	rcall	8000b7a4 <_fclose_r>
8000b868:	d8 02       	popm	pc
8000b86a:	d7 03       	nop

8000b86c <_fstat_r>:
8000b86c:	d4 21       	pushm	r4-r7,lr
8000b86e:	16 98       	mov	r8,r11
8000b870:	18 97       	mov	r7,r12
8000b872:	10 9c       	mov	r12,r8
8000b874:	30 08       	mov	r8,0
8000b876:	e0 66 41 18 	mov	r6,16664
8000b87a:	14 9b       	mov	r11,r10
8000b87c:	8d 08       	st.w	r6[0x0],r8
8000b87e:	fe b0 df 67 	rcall	8000774c <_fstat>
8000b882:	5b fc       	cp.w	r12,-1
8000b884:	c0 51       	brne	8000b88e <_fstat_r+0x22>
8000b886:	6c 08       	ld.w	r8,r6[0x0]
8000b888:	58 08       	cp.w	r8,0
8000b88a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b88e:	d8 22       	popm	r4-r7,pc

8000b890 <_lseek_r>:
8000b890:	d4 21       	pushm	r4-r7,lr
8000b892:	16 98       	mov	r8,r11
8000b894:	18 97       	mov	r7,r12
8000b896:	10 9c       	mov	r12,r8
8000b898:	30 08       	mov	r8,0
8000b89a:	14 9b       	mov	r11,r10
8000b89c:	e0 66 41 18 	mov	r6,16664
8000b8a0:	12 9a       	mov	r10,r9
8000b8a2:	8d 08       	st.w	r6[0x0],r8
8000b8a4:	fe b0 df 36 	rcall	80007710 <_lseek>
8000b8a8:	5b fc       	cp.w	r12,-1
8000b8aa:	c0 51       	brne	8000b8b4 <_lseek_r+0x24>
8000b8ac:	6c 08       	ld.w	r8,r6[0x0]
8000b8ae:	58 08       	cp.w	r8,0
8000b8b0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8b4:	d8 22       	popm	r4-r7,pc
8000b8b6:	d7 03       	nop

8000b8b8 <_read_r>:
8000b8b8:	d4 21       	pushm	r4-r7,lr
8000b8ba:	16 98       	mov	r8,r11
8000b8bc:	18 97       	mov	r7,r12
8000b8be:	10 9c       	mov	r12,r8
8000b8c0:	30 08       	mov	r8,0
8000b8c2:	14 9b       	mov	r11,r10
8000b8c4:	e0 66 41 18 	mov	r6,16664
8000b8c8:	12 9a       	mov	r10,r9
8000b8ca:	8d 08       	st.w	r6[0x0],r8
8000b8cc:	fe b0 d0 bc 	rcall	80005a44 <_read>
8000b8d0:	5b fc       	cp.w	r12,-1
8000b8d2:	c0 51       	brne	8000b8dc <_read_r+0x24>
8000b8d4:	6c 08       	ld.w	r8,r6[0x0]
8000b8d6:	58 08       	cp.w	r8,0
8000b8d8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8dc:	d8 22       	popm	r4-r7,pc
8000b8de:	d7 03       	nop

8000b8e0 <__avr32_f64_mul>:
8000b8e0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b8e4:	e0 80 00 dc 	breq	8000ba9c <__avr32_f64_mul_op1_zero>
8000b8e8:	d4 21       	pushm	r4-r7,lr
8000b8ea:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8ee:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b8f2:	30 15       	mov	r5,1
8000b8f4:	c4 30       	breq	8000b97a <__avr32_f64_mul_op1_subnormal>
8000b8f6:	ab 6b       	lsl	r11,0xa
8000b8f8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b8fc:	ab 6a       	lsl	r10,0xa
8000b8fe:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b902:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b906:	c5 c0       	breq	8000b9be <__avr32_f64_mul_op2_subnormal>
8000b908:	a1 78       	lsl	r8,0x1
8000b90a:	5c f9       	rol	r9
8000b90c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b910:	e0 47 07 ff 	cp.w	r7,2047
8000b914:	c7 70       	breq	8000ba02 <__avr32_f64_mul_op_nan_or_inf>
8000b916:	e0 46 07 ff 	cp.w	r6,2047
8000b91a:	c7 40       	breq	8000ba02 <__avr32_f64_mul_op_nan_or_inf>
8000b91c:	ee 06 00 0c 	add	r12,r7,r6
8000b920:	e0 2c 03 fe 	sub	r12,1022
8000b924:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b928:	f4 09 07 44 	macu.d	r4,r10,r9
8000b92c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b930:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b934:	08 07       	add	r7,r4
8000b936:	f4 05 00 4a 	adc	r10,r10,r5
8000b93a:	5c 0b       	acr	r11
8000b93c:	ed bb 00 14 	bld	r11,0x14
8000b940:	c0 50       	breq	8000b94a <__avr32_f64_mul+0x6a>
8000b942:	a1 77       	lsl	r7,0x1
8000b944:	5c fa       	rol	r10
8000b946:	5c fb       	rol	r11
8000b948:	20 1c       	sub	r12,1
8000b94a:	58 0c       	cp.w	r12,0
8000b94c:	e0 8a 00 6f 	brle	8000ba2a <__avr32_f64_mul_res_subnormal>
8000b950:	e0 4c 07 ff 	cp.w	r12,2047
8000b954:	e0 84 00 9c 	brge	8000ba8c <__avr32_f64_mul_res_inf>
8000b958:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b95c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b960:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b964:	ee 17 80 00 	eorh	r7,0x8000
8000b968:	f1 b7 04 20 	satu	r7,0x1
8000b96c:	0e 0a       	add	r10,r7
8000b96e:	5c 0b       	acr	r11
8000b970:	ed be 00 1f 	bld	lr,0x1f
8000b974:	ef bb 00 1f 	bst	r11,0x1f
8000b978:	d8 22       	popm	r4-r7,pc

8000b97a <__avr32_f64_mul_op1_subnormal>:
8000b97a:	e4 1b 00 0f 	andh	r11,0xf
8000b97e:	f4 0c 12 00 	clz	r12,r10
8000b982:	f6 06 12 00 	clz	r6,r11
8000b986:	f7 bc 03 e1 	sublo	r12,-31
8000b98a:	f8 06 17 30 	movlo	r6,r12
8000b98e:	f7 b6 02 01 	subhs	r6,1
8000b992:	e0 46 00 20 	cp.w	r6,32
8000b996:	c0 d4       	brge	8000b9b0 <__avr32_f64_mul_op1_subnormal+0x36>
8000b998:	ec 0c 11 20 	rsub	r12,r6,32
8000b99c:	f6 06 09 4b 	lsl	r11,r11,r6
8000b9a0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b9a4:	18 4b       	or	r11,r12
8000b9a6:	f4 06 09 4a 	lsl	r10,r10,r6
8000b9aa:	20 b6       	sub	r6,11
8000b9ac:	0c 17       	sub	r7,r6
8000b9ae:	ca ab       	rjmp	8000b902 <__avr32_f64_mul+0x22>
8000b9b0:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9b4:	c6 40       	breq	8000ba7c <__avr32_f64_mul_res_zero>
8000b9b6:	30 0a       	mov	r10,0
8000b9b8:	20 b6       	sub	r6,11
8000b9ba:	0c 17       	sub	r7,r6
8000b9bc:	ca 3b       	rjmp	8000b902 <__avr32_f64_mul+0x22>

8000b9be <__avr32_f64_mul_op2_subnormal>:
8000b9be:	e4 19 00 0f 	andh	r9,0xf
8000b9c2:	f0 0c 12 00 	clz	r12,r8
8000b9c6:	f2 05 12 00 	clz	r5,r9
8000b9ca:	f7 bc 03 ea 	sublo	r12,-22
8000b9ce:	f8 05 17 30 	movlo	r5,r12
8000b9d2:	f7 b5 02 0a 	subhs	r5,10
8000b9d6:	e0 45 00 20 	cp.w	r5,32
8000b9da:	c0 d4       	brge	8000b9f4 <__avr32_f64_mul_op2_subnormal+0x36>
8000b9dc:	ea 0c 11 20 	rsub	r12,r5,32
8000b9e0:	f2 05 09 49 	lsl	r9,r9,r5
8000b9e4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b9e8:	18 49       	or	r9,r12
8000b9ea:	f0 05 09 48 	lsl	r8,r8,r5
8000b9ee:	20 25       	sub	r5,2
8000b9f0:	0a 16       	sub	r6,r5
8000b9f2:	c8 fb       	rjmp	8000b910 <__avr32_f64_mul+0x30>
8000b9f4:	f0 05 09 49 	lsl	r9,r8,r5
8000b9f8:	c4 20       	breq	8000ba7c <__avr32_f64_mul_res_zero>
8000b9fa:	30 08       	mov	r8,0
8000b9fc:	20 25       	sub	r5,2
8000b9fe:	0a 16       	sub	r6,r5
8000ba00:	c8 8b       	rjmp	8000b910 <__avr32_f64_mul+0x30>

8000ba02 <__avr32_f64_mul_op_nan_or_inf>:
8000ba02:	e4 19 00 0f 	andh	r9,0xf
8000ba06:	e4 1b 00 0f 	andh	r11,0xf
8000ba0a:	14 4b       	or	r11,r10
8000ba0c:	10 49       	or	r9,r8
8000ba0e:	e0 47 07 ff 	cp.w	r7,2047
8000ba12:	c0 91       	brne	8000ba24 <__avr32_f64_mul_op1_not_naninf>
8000ba14:	58 0b       	cp.w	r11,0
8000ba16:	c3 81       	brne	8000ba86 <__avr32_f64_mul_res_nan>
8000ba18:	e0 46 07 ff 	cp.w	r6,2047
8000ba1c:	c3 81       	brne	8000ba8c <__avr32_f64_mul_res_inf>
8000ba1e:	58 09       	cp.w	r9,0
8000ba20:	c3 60       	breq	8000ba8c <__avr32_f64_mul_res_inf>
8000ba22:	c3 28       	rjmp	8000ba86 <__avr32_f64_mul_res_nan>

8000ba24 <__avr32_f64_mul_op1_not_naninf>:
8000ba24:	58 09       	cp.w	r9,0
8000ba26:	c3 30       	breq	8000ba8c <__avr32_f64_mul_res_inf>
8000ba28:	c2 f8       	rjmp	8000ba86 <__avr32_f64_mul_res_nan>

8000ba2a <__avr32_f64_mul_res_subnormal>:
8000ba2a:	5c 3c       	neg	r12
8000ba2c:	2f fc       	sub	r12,-1
8000ba2e:	f1 bc 04 c0 	satu	r12,0x6
8000ba32:	e0 4c 00 20 	cp.w	r12,32
8000ba36:	c1 14       	brge	8000ba58 <__avr32_f64_mul_res_subnormal+0x2e>
8000ba38:	f8 08 11 20 	rsub	r8,r12,32
8000ba3c:	0e 46       	or	r6,r7
8000ba3e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ba42:	f4 08 09 49 	lsl	r9,r10,r8
8000ba46:	12 47       	or	r7,r9
8000ba48:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba4c:	f6 08 09 49 	lsl	r9,r11,r8
8000ba50:	12 4a       	or	r10,r9
8000ba52:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba56:	c8 3b       	rjmp	8000b95c <__avr32_f64_mul+0x7c>
8000ba58:	f8 08 11 20 	rsub	r8,r12,32
8000ba5c:	f9 b9 00 00 	moveq	r9,0
8000ba60:	c0 30       	breq	8000ba66 <__avr32_f64_mul_res_subnormal+0x3c>
8000ba62:	f6 08 09 49 	lsl	r9,r11,r8
8000ba66:	0e 46       	or	r6,r7
8000ba68:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ba6c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba70:	f3 ea 10 07 	or	r7,r9,r10
8000ba74:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ba78:	30 0b       	mov	r11,0
8000ba7a:	c7 1b       	rjmp	8000b95c <__avr32_f64_mul+0x7c>

8000ba7c <__avr32_f64_mul_res_zero>:
8000ba7c:	1c 9b       	mov	r11,lr
8000ba7e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ba82:	30 0a       	mov	r10,0
8000ba84:	d8 22       	popm	r4-r7,pc

8000ba86 <__avr32_f64_mul_res_nan>:
8000ba86:	3f fb       	mov	r11,-1
8000ba88:	3f fa       	mov	r10,-1
8000ba8a:	d8 22       	popm	r4-r7,pc

8000ba8c <__avr32_f64_mul_res_inf>:
8000ba8c:	f0 6b 00 00 	mov	r11,-1048576
8000ba90:	ed be 00 1f 	bld	lr,0x1f
8000ba94:	ef bb 00 1f 	bst	r11,0x1f
8000ba98:	30 0a       	mov	r10,0
8000ba9a:	d8 22       	popm	r4-r7,pc

8000ba9c <__avr32_f64_mul_op1_zero>:
8000ba9c:	f7 e9 20 0b 	eor	r11,r11,r9
8000baa0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000baa4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000baa8:	e0 4c 07 ff 	cp.w	r12,2047
8000baac:	5e 1c       	retne	r12
8000baae:	3f fa       	mov	r10,-1
8000bab0:	3f fb       	mov	r11,-1
8000bab2:	5e fc       	retal	r12

8000bab4 <__avr32_f64_sub_from_add>:
8000bab4:	ee 19 80 00 	eorh	r9,0x8000

8000bab8 <__avr32_f64_sub>:
8000bab8:	f7 e9 20 0c 	eor	r12,r11,r9
8000babc:	e0 86 00 ca 	brmi	8000bc50 <__avr32_f64_add_from_sub>
8000bac0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bac4:	16 9c       	mov	r12,r11
8000bac6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000baca:	bf db       	cbr	r11,0x1f
8000bacc:	bf d9       	cbr	r9,0x1f
8000bace:	10 3a       	cp.w	r10,r8
8000bad0:	f2 0b 13 00 	cpc	r11,r9
8000bad4:	c0 92       	brcc	8000bae6 <__avr32_f64_sub+0x2e>
8000bad6:	16 97       	mov	r7,r11
8000bad8:	12 9b       	mov	r11,r9
8000bada:	0e 99       	mov	r9,r7
8000badc:	14 97       	mov	r7,r10
8000bade:	10 9a       	mov	r10,r8
8000bae0:	0e 98       	mov	r8,r7
8000bae2:	ee 1c 80 00 	eorh	r12,0x8000
8000bae6:	f6 07 16 14 	lsr	r7,r11,0x14
8000baea:	ab 7b       	lsl	r11,0xb
8000baec:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000baf0:	ab 7a       	lsl	r10,0xb
8000baf2:	bf bb       	sbr	r11,0x1f
8000baf4:	f2 06 16 14 	lsr	r6,r9,0x14
8000baf8:	c4 40       	breq	8000bb80 <__avr32_f64_sub_opL_subnormal>
8000bafa:	ab 79       	lsl	r9,0xb
8000bafc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb00:	ab 78       	lsl	r8,0xb
8000bb02:	bf b9       	sbr	r9,0x1f

8000bb04 <__avr32_f64_sub_opL_subnormal_done>:
8000bb04:	e0 47 07 ff 	cp.w	r7,2047
8000bb08:	c4 f0       	breq	8000bba6 <__avr32_f64_sub_opH_nan_or_inf>
8000bb0a:	0e 26       	rsub	r6,r7
8000bb0c:	c1 20       	breq	8000bb30 <__avr32_f64_sub_shift_done>
8000bb0e:	ec 05 11 20 	rsub	r5,r6,32
8000bb12:	e0 46 00 20 	cp.w	r6,32
8000bb16:	c7 c2       	brcc	8000bc0e <__avr32_f64_sub_longshift>
8000bb18:	f0 05 09 4e 	lsl	lr,r8,r5
8000bb1c:	f2 05 09 45 	lsl	r5,r9,r5
8000bb20:	f0 06 0a 48 	lsr	r8,r8,r6
8000bb24:	f2 06 0a 49 	lsr	r9,r9,r6
8000bb28:	0a 48       	or	r8,r5
8000bb2a:	58 0e       	cp.w	lr,0
8000bb2c:	5f 1e       	srne	lr
8000bb2e:	1c 48       	or	r8,lr

8000bb30 <__avr32_f64_sub_shift_done>:
8000bb30:	10 1a       	sub	r10,r8
8000bb32:	f6 09 01 4b 	sbc	r11,r11,r9
8000bb36:	f6 06 12 00 	clz	r6,r11
8000bb3a:	c0 e0       	breq	8000bb56 <__avr32_f64_sub_longnormalize_done>
8000bb3c:	c7 83       	brcs	8000bc2c <__avr32_f64_sub_longnormalize>
8000bb3e:	ec 0e 11 20 	rsub	lr,r6,32
8000bb42:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb46:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb4a:	1c 4b       	or	r11,lr
8000bb4c:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb50:	0c 17       	sub	r7,r6
8000bb52:	e0 8a 00 39 	brle	8000bbc4 <__avr32_f64_sub_subnormal_result>

8000bb56 <__avr32_f64_sub_longnormalize_done>:
8000bb56:	f4 09 15 15 	lsl	r9,r10,0x15
8000bb5a:	ab 9a       	lsr	r10,0xb
8000bb5c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb60:	ab 9b       	lsr	r11,0xb
8000bb62:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bb66:	18 4b       	or	r11,r12

8000bb68 <__avr32_f64_sub_round>:
8000bb68:	fc 17 80 00 	movh	r7,0x8000
8000bb6c:	ed ba 00 00 	bld	r10,0x0
8000bb70:	f7 b7 01 ff 	subne	r7,-1
8000bb74:	0e 39       	cp.w	r9,r7
8000bb76:	5f 29       	srhs	r9
8000bb78:	12 0a       	add	r10,r9
8000bb7a:	5c 0b       	acr	r11
8000bb7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb80 <__avr32_f64_sub_opL_subnormal>:
8000bb80:	ab 79       	lsl	r9,0xb
8000bb82:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb86:	ab 78       	lsl	r8,0xb
8000bb88:	f3 e8 10 0e 	or	lr,r9,r8
8000bb8c:	f9 b6 01 01 	movne	r6,1
8000bb90:	ee 0e 11 00 	rsub	lr,r7,0
8000bb94:	f9 b7 00 01 	moveq	r7,1
8000bb98:	ef bb 00 1f 	bst	r11,0x1f
8000bb9c:	f7 ea 10 0e 	or	lr,r11,r10
8000bba0:	f9 b7 00 00 	moveq	r7,0
8000bba4:	cb 0b       	rjmp	8000bb04 <__avr32_f64_sub_opL_subnormal_done>

8000bba6 <__avr32_f64_sub_opH_nan_or_inf>:
8000bba6:	bf db       	cbr	r11,0x1f
8000bba8:	f7 ea 10 0e 	or	lr,r11,r10
8000bbac:	c0 81       	brne	8000bbbc <__avr32_f64_sub_return_nan>
8000bbae:	e0 46 07 ff 	cp.w	r6,2047
8000bbb2:	c0 50       	breq	8000bbbc <__avr32_f64_sub_return_nan>
8000bbb4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bbb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbbc <__avr32_f64_sub_return_nan>:
8000bbbc:	3f fa       	mov	r10,-1
8000bbbe:	3f fb       	mov	r11,-1
8000bbc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbc4 <__avr32_f64_sub_subnormal_result>:
8000bbc4:	5c 37       	neg	r7
8000bbc6:	2f f7       	sub	r7,-1
8000bbc8:	f1 b7 04 c0 	satu	r7,0x6
8000bbcc:	e0 47 00 20 	cp.w	r7,32
8000bbd0:	c1 14       	brge	8000bbf2 <__avr32_f64_sub_subnormal_result+0x2e>
8000bbd2:	ee 08 11 20 	rsub	r8,r7,32
8000bbd6:	f4 08 09 49 	lsl	r9,r10,r8
8000bbda:	5f 16       	srne	r6
8000bbdc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bbe0:	0c 4a       	or	r10,r6
8000bbe2:	f6 08 09 49 	lsl	r9,r11,r8
8000bbe6:	f5 e9 10 0a 	or	r10,r10,r9
8000bbea:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bbee:	30 07       	mov	r7,0
8000bbf0:	cb 3b       	rjmp	8000bb56 <__avr32_f64_sub_longnormalize_done>
8000bbf2:	ee 08 11 40 	rsub	r8,r7,64
8000bbf6:	f6 08 09 49 	lsl	r9,r11,r8
8000bbfa:	14 49       	or	r9,r10
8000bbfc:	5f 16       	srne	r6
8000bbfe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bc02:	0c 4a       	or	r10,r6
8000bc04:	30 0b       	mov	r11,0
8000bc06:	30 07       	mov	r7,0
8000bc08:	ca 7b       	rjmp	8000bb56 <__avr32_f64_sub_longnormalize_done>
8000bc0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc0e <__avr32_f64_sub_longshift>:
8000bc0e:	f1 b6 04 c0 	satu	r6,0x6
8000bc12:	f0 0e 17 00 	moveq	lr,r8
8000bc16:	c0 40       	breq	8000bc1e <__avr32_f64_sub_longshift+0x10>
8000bc18:	f2 05 09 4e 	lsl	lr,r9,r5
8000bc1c:	10 4e       	or	lr,r8
8000bc1e:	f2 06 0a 48 	lsr	r8,r9,r6
8000bc22:	30 09       	mov	r9,0
8000bc24:	58 0e       	cp.w	lr,0
8000bc26:	5f 1e       	srne	lr
8000bc28:	1c 48       	or	r8,lr
8000bc2a:	c8 3b       	rjmp	8000bb30 <__avr32_f64_sub_shift_done>

8000bc2c <__avr32_f64_sub_longnormalize>:
8000bc2c:	f4 06 12 00 	clz	r6,r10
8000bc30:	f9 b7 03 00 	movlo	r7,0
8000bc34:	f9 b6 03 00 	movlo	r6,0
8000bc38:	f9 bc 03 00 	movlo	r12,0
8000bc3c:	f7 b6 02 e0 	subhs	r6,-32
8000bc40:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc44:	30 0a       	mov	r10,0
8000bc46:	0c 17       	sub	r7,r6
8000bc48:	fe 9a ff be 	brle	8000bbc4 <__avr32_f64_sub_subnormal_result>
8000bc4c:	c8 5b       	rjmp	8000bb56 <__avr32_f64_sub_longnormalize_done>
8000bc4e:	d7 03       	nop

8000bc50 <__avr32_f64_add_from_sub>:
8000bc50:	ee 19 80 00 	eorh	r9,0x8000

8000bc54 <__avr32_f64_add>:
8000bc54:	f7 e9 20 0c 	eor	r12,r11,r9
8000bc58:	fe 96 ff 2e 	brmi	8000bab4 <__avr32_f64_sub_from_add>
8000bc5c:	eb cd 40 e0 	pushm	r5-r7,lr
8000bc60:	16 9c       	mov	r12,r11
8000bc62:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bc66:	bf db       	cbr	r11,0x1f
8000bc68:	bf d9       	cbr	r9,0x1f
8000bc6a:	12 3b       	cp.w	r11,r9
8000bc6c:	c0 72       	brcc	8000bc7a <__avr32_f64_add+0x26>
8000bc6e:	16 97       	mov	r7,r11
8000bc70:	12 9b       	mov	r11,r9
8000bc72:	0e 99       	mov	r9,r7
8000bc74:	14 97       	mov	r7,r10
8000bc76:	10 9a       	mov	r10,r8
8000bc78:	0e 98       	mov	r8,r7
8000bc7a:	30 0e       	mov	lr,0
8000bc7c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc80:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bc84:	b5 ab       	sbr	r11,0x14
8000bc86:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc8a:	c6 20       	breq	8000bd4e <__avr32_f64_add_op2_subnormal>
8000bc8c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bc90:	b5 a9       	sbr	r9,0x14
8000bc92:	e0 47 07 ff 	cp.w	r7,2047
8000bc96:	c2 80       	breq	8000bce6 <__avr32_f64_add_opH_nan_or_inf>
8000bc98:	0e 26       	rsub	r6,r7
8000bc9a:	c1 20       	breq	8000bcbe <__avr32_f64_add_shift_done>
8000bc9c:	e0 46 00 36 	cp.w	r6,54
8000bca0:	c1 52       	brcc	8000bcca <__avr32_f64_add_res_of_done>
8000bca2:	ec 05 11 20 	rsub	r5,r6,32
8000bca6:	e0 46 00 20 	cp.w	r6,32
8000bcaa:	c3 52       	brcc	8000bd14 <__avr32_f64_add_longshift>
8000bcac:	f0 05 09 4e 	lsl	lr,r8,r5
8000bcb0:	f2 05 09 45 	lsl	r5,r9,r5
8000bcb4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcb8:	f2 06 0a 49 	lsr	r9,r9,r6
8000bcbc:	0a 48       	or	r8,r5

8000bcbe <__avr32_f64_add_shift_done>:
8000bcbe:	10 0a       	add	r10,r8
8000bcc0:	f6 09 00 4b 	adc	r11,r11,r9
8000bcc4:	ed bb 00 15 	bld	r11,0x15
8000bcc8:	c3 40       	breq	8000bd30 <__avr32_f64_add_res_of>

8000bcca <__avr32_f64_add_res_of_done>:
8000bcca:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bcce:	18 4b       	or	r11,r12

8000bcd0 <__avr32_f64_add_round>:
8000bcd0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bcd4:	18 4e       	or	lr,r12
8000bcd6:	ee 1e 80 00 	eorh	lr,0x8000
8000bcda:	f1 be 04 20 	satu	lr,0x1
8000bcde:	1c 0a       	add	r10,lr
8000bce0:	5c 0b       	acr	r11
8000bce2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bce6 <__avr32_f64_add_opH_nan_or_inf>:
8000bce6:	b5 cb       	cbr	r11,0x14
8000bce8:	f7 ea 10 0e 	or	lr,r11,r10
8000bcec:	c1 01       	brne	8000bd0c <__avr32_f64_add_return_nan>
8000bcee:	e0 46 07 ff 	cp.w	r6,2047
8000bcf2:	c0 30       	breq	8000bcf8 <__avr32_f64_add_opL_nan_or_inf>
8000bcf4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcf8 <__avr32_f64_add_opL_nan_or_inf>:
8000bcf8:	b5 c9       	cbr	r9,0x14
8000bcfa:	f3 e8 10 0e 	or	lr,r9,r8
8000bcfe:	c0 71       	brne	8000bd0c <__avr32_f64_add_return_nan>
8000bd00:	30 0a       	mov	r10,0
8000bd02:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bd06:	18 4b       	or	r11,r12
8000bd08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd0c <__avr32_f64_add_return_nan>:
8000bd0c:	3f fa       	mov	r10,-1
8000bd0e:	3f fb       	mov	r11,-1
8000bd10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd14 <__avr32_f64_add_longshift>:
8000bd14:	f1 b6 04 c0 	satu	r6,0x6
8000bd18:	f0 0e 17 00 	moveq	lr,r8
8000bd1c:	c0 60       	breq	8000bd28 <__avr32_f64_add_longshift+0x14>
8000bd1e:	f2 05 09 4e 	lsl	lr,r9,r5
8000bd22:	58 08       	cp.w	r8,0
8000bd24:	5f 18       	srne	r8
8000bd26:	10 4e       	or	lr,r8
8000bd28:	f2 06 0a 48 	lsr	r8,r9,r6
8000bd2c:	30 09       	mov	r9,0
8000bd2e:	cc 8b       	rjmp	8000bcbe <__avr32_f64_add_shift_done>

8000bd30 <__avr32_f64_add_res_of>:
8000bd30:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bd34:	a1 9b       	lsr	r11,0x1
8000bd36:	5d 0a       	ror	r10
8000bd38:	5d 0e       	ror	lr
8000bd3a:	2f f7       	sub	r7,-1
8000bd3c:	e0 47 07 ff 	cp.w	r7,2047
8000bd40:	f9 ba 00 00 	moveq	r10,0
8000bd44:	f9 bb 00 00 	moveq	r11,0
8000bd48:	f9 be 00 00 	moveq	lr,0
8000bd4c:	cb fb       	rjmp	8000bcca <__avr32_f64_add_res_of_done>

8000bd4e <__avr32_f64_add_op2_subnormal>:
8000bd4e:	30 16       	mov	r6,1
8000bd50:	58 07       	cp.w	r7,0
8000bd52:	ca 01       	brne	8000bc92 <__avr32_f64_add+0x3e>
8000bd54:	b5 cb       	cbr	r11,0x14
8000bd56:	10 0a       	add	r10,r8
8000bd58:	f6 09 00 4b 	adc	r11,r11,r9
8000bd5c:	18 4b       	or	r11,r12
8000bd5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bd62:	d7 03       	nop

8000bd64 <__avr32_f64_to_u32>:
8000bd64:	58 0b       	cp.w	r11,0
8000bd66:	5e 6d       	retmi	0

8000bd68 <__avr32_f64_to_s32>:
8000bd68:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bd6c:	b5 9c       	lsr	r12,0x15
8000bd6e:	e0 2c 03 ff 	sub	r12,1023
8000bd72:	5e 3d       	retlo	0
8000bd74:	f8 0c 11 1f 	rsub	r12,r12,31
8000bd78:	16 99       	mov	r9,r11
8000bd7a:	ab 7b       	lsl	r11,0xb
8000bd7c:	bf bb       	sbr	r11,0x1f
8000bd7e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bd82:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bd86:	a1 79       	lsl	r9,0x1
8000bd88:	5e 2b       	reths	r11
8000bd8a:	5c 3b       	neg	r11
8000bd8c:	5e fb       	retal	r11

8000bd8e <__avr32_u32_to_f64>:
8000bd8e:	f8 cb 00 00 	sub	r11,r12,0
8000bd92:	30 0c       	mov	r12,0
8000bd94:	c0 38       	rjmp	8000bd9a <__avr32_s32_to_f64+0x4>

8000bd96 <__avr32_s32_to_f64>:
8000bd96:	18 9b       	mov	r11,r12
8000bd98:	5c 4b       	abs	r11
8000bd9a:	30 0a       	mov	r10,0
8000bd9c:	5e 0b       	reteq	r11
8000bd9e:	d4 01       	pushm	lr
8000bda0:	e0 69 04 1e 	mov	r9,1054
8000bda4:	f6 08 12 00 	clz	r8,r11
8000bda8:	c1 70       	breq	8000bdd6 <__avr32_s32_to_f64+0x40>
8000bdaa:	c0 c3       	brcs	8000bdc2 <__avr32_s32_to_f64+0x2c>
8000bdac:	f0 0e 11 20 	rsub	lr,r8,32
8000bdb0:	f6 08 09 4b 	lsl	r11,r11,r8
8000bdb4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bdb8:	1c 4b       	or	r11,lr
8000bdba:	f4 08 09 4a 	lsl	r10,r10,r8
8000bdbe:	10 19       	sub	r9,r8
8000bdc0:	c0 b8       	rjmp	8000bdd6 <__avr32_s32_to_f64+0x40>
8000bdc2:	f4 08 12 00 	clz	r8,r10
8000bdc6:	f9 b8 03 00 	movlo	r8,0
8000bdca:	f7 b8 02 e0 	subhs	r8,-32
8000bdce:	f4 08 09 4b 	lsl	r11,r10,r8
8000bdd2:	30 0a       	mov	r10,0
8000bdd4:	10 19       	sub	r9,r8
8000bdd6:	58 09       	cp.w	r9,0
8000bdd8:	e0 89 00 30 	brgt	8000be38 <__avr32_s32_to_f64+0xa2>
8000bddc:	5c 39       	neg	r9
8000bdde:	2f f9       	sub	r9,-1
8000bde0:	e0 49 00 36 	cp.w	r9,54
8000bde4:	c0 43       	brcs	8000bdec <__avr32_s32_to_f64+0x56>
8000bde6:	30 0b       	mov	r11,0
8000bde8:	30 0a       	mov	r10,0
8000bdea:	c2 68       	rjmp	8000be36 <__avr32_s32_to_f64+0xa0>
8000bdec:	2f 69       	sub	r9,-10
8000bdee:	f2 08 11 20 	rsub	r8,r9,32
8000bdf2:	e0 49 00 20 	cp.w	r9,32
8000bdf6:	c0 b2       	brcc	8000be0c <__avr32_s32_to_f64+0x76>
8000bdf8:	f4 08 09 4e 	lsl	lr,r10,r8
8000bdfc:	f6 08 09 48 	lsl	r8,r11,r8
8000be00:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be04:	f6 09 0a 4b 	lsr	r11,r11,r9
8000be08:	10 4b       	or	r11,r8
8000be0a:	c0 88       	rjmp	8000be1a <__avr32_s32_to_f64+0x84>
8000be0c:	f6 08 09 4e 	lsl	lr,r11,r8
8000be10:	14 4e       	or	lr,r10
8000be12:	16 9a       	mov	r10,r11
8000be14:	30 0b       	mov	r11,0
8000be16:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be1a:	ed ba 00 00 	bld	r10,0x0
8000be1e:	c0 92       	brcc	8000be30 <__avr32_s32_to_f64+0x9a>
8000be20:	1c 7e       	tst	lr,lr
8000be22:	c0 41       	brne	8000be2a <__avr32_s32_to_f64+0x94>
8000be24:	ed ba 00 01 	bld	r10,0x1
8000be28:	c0 42       	brcc	8000be30 <__avr32_s32_to_f64+0x9a>
8000be2a:	2f fa       	sub	r10,-1
8000be2c:	f7 bb 02 ff 	subhs	r11,-1
8000be30:	5c fc       	rol	r12
8000be32:	5d 0b       	ror	r11
8000be34:	5d 0a       	ror	r10
8000be36:	d8 02       	popm	pc
8000be38:	e0 68 03 ff 	mov	r8,1023
8000be3c:	ed ba 00 0b 	bld	r10,0xb
8000be40:	f7 b8 00 ff 	subeq	r8,-1
8000be44:	10 0a       	add	r10,r8
8000be46:	5c 0b       	acr	r11
8000be48:	f7 b9 03 fe 	sublo	r9,-2
8000be4c:	e0 49 07 ff 	cp.w	r9,2047
8000be50:	c0 55       	brlt	8000be5a <__avr32_s32_to_f64+0xc4>
8000be52:	30 0a       	mov	r10,0
8000be54:	fc 1b ff e0 	movh	r11,0xffe0
8000be58:	c0 c8       	rjmp	8000be70 <__floatsidf_return_op1>
8000be5a:	ed bb 00 1f 	bld	r11,0x1f
8000be5e:	f7 b9 01 01 	subne	r9,1
8000be62:	ab 9a       	lsr	r10,0xb
8000be64:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000be68:	a1 7b       	lsl	r11,0x1
8000be6a:	ab 9b       	lsr	r11,0xb
8000be6c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000be70 <__floatsidf_return_op1>:
8000be70:	a1 7c       	lsl	r12,0x1
8000be72:	5d 0b       	ror	r11
8000be74:	d8 02       	popm	pc

8000be76 <__avr32_f64_cmp_eq>:
8000be76:	10 3a       	cp.w	r10,r8
8000be78:	f2 0b 13 00 	cpc	r11,r9
8000be7c:	c0 80       	breq	8000be8c <__avr32_f64_cmp_eq+0x16>
8000be7e:	a1 7b       	lsl	r11,0x1
8000be80:	a1 79       	lsl	r9,0x1
8000be82:	14 4b       	or	r11,r10
8000be84:	12 4b       	or	r11,r9
8000be86:	10 4b       	or	r11,r8
8000be88:	5e 0f       	reteq	1
8000be8a:	5e fd       	retal	0
8000be8c:	a1 7b       	lsl	r11,0x1
8000be8e:	fc 1c ff e0 	movh	r12,0xffe0
8000be92:	58 0a       	cp.w	r10,0
8000be94:	f8 0b 13 00 	cpc	r11,r12
8000be98:	5e 8f       	retls	1
8000be9a:	5e fd       	retal	0

8000be9c <__avr32_f64_cmp_ge>:
8000be9c:	1a de       	st.w	--sp,lr
8000be9e:	1a d7       	st.w	--sp,r7
8000bea0:	a1 7b       	lsl	r11,0x1
8000bea2:	5f 3c       	srlo	r12
8000bea4:	a1 79       	lsl	r9,0x1
8000bea6:	5f 37       	srlo	r7
8000bea8:	5c fc       	rol	r12
8000beaa:	fc 1e ff e0 	movh	lr,0xffe0
8000beae:	58 0a       	cp.w	r10,0
8000beb0:	fc 0b 13 00 	cpc	r11,lr
8000beb4:	e0 8b 00 1d 	brhi	8000beee <__avr32_f64_cmp_ge+0x52>
8000beb8:	58 08       	cp.w	r8,0
8000beba:	fc 09 13 00 	cpc	r9,lr
8000bebe:	e0 8b 00 18 	brhi	8000beee <__avr32_f64_cmp_ge+0x52>
8000bec2:	58 0b       	cp.w	r11,0
8000bec4:	f5 ba 00 00 	subfeq	r10,0
8000bec8:	c1 50       	breq	8000bef2 <__avr32_f64_cmp_ge+0x56>
8000beca:	1b 07       	ld.w	r7,sp++
8000becc:	1b 0e       	ld.w	lr,sp++
8000bece:	58 3c       	cp.w	r12,3
8000bed0:	c0 a0       	breq	8000bee4 <__avr32_f64_cmp_ge+0x48>
8000bed2:	58 1c       	cp.w	r12,1
8000bed4:	c0 33       	brcs	8000beda <__avr32_f64_cmp_ge+0x3e>
8000bed6:	5e 0f       	reteq	1
8000bed8:	5e 1d       	retne	0
8000beda:	10 3a       	cp.w	r10,r8
8000bedc:	f2 0b 13 00 	cpc	r11,r9
8000bee0:	5e 2f       	reths	1
8000bee2:	5e 3d       	retlo	0
8000bee4:	14 38       	cp.w	r8,r10
8000bee6:	f6 09 13 00 	cpc	r9,r11
8000beea:	5e 2f       	reths	1
8000beec:	5e 3d       	retlo	0
8000beee:	1b 07       	ld.w	r7,sp++
8000bef0:	d8 0a       	popm	pc,r12=0
8000bef2:	58 17       	cp.w	r7,1
8000bef4:	5f 0c       	sreq	r12
8000bef6:	58 09       	cp.w	r9,0
8000bef8:	f5 b8 00 00 	subfeq	r8,0
8000befc:	1b 07       	ld.w	r7,sp++
8000befe:	1b 0e       	ld.w	lr,sp++
8000bf00:	5e 0f       	reteq	1
8000bf02:	5e fc       	retal	r12

8000bf04 <__avr32_f64_cmp_lt>:
8000bf04:	1a de       	st.w	--sp,lr
8000bf06:	1a d7       	st.w	--sp,r7
8000bf08:	a1 7b       	lsl	r11,0x1
8000bf0a:	5f 3c       	srlo	r12
8000bf0c:	a1 79       	lsl	r9,0x1
8000bf0e:	5f 37       	srlo	r7
8000bf10:	5c fc       	rol	r12
8000bf12:	fc 1e ff e0 	movh	lr,0xffe0
8000bf16:	58 0a       	cp.w	r10,0
8000bf18:	fc 0b 13 00 	cpc	r11,lr
8000bf1c:	e0 8b 00 1d 	brhi	8000bf56 <__avr32_f64_cmp_lt+0x52>
8000bf20:	58 08       	cp.w	r8,0
8000bf22:	fc 09 13 00 	cpc	r9,lr
8000bf26:	e0 8b 00 18 	brhi	8000bf56 <__avr32_f64_cmp_lt+0x52>
8000bf2a:	58 0b       	cp.w	r11,0
8000bf2c:	f5 ba 00 00 	subfeq	r10,0
8000bf30:	c1 50       	breq	8000bf5a <__avr32_f64_cmp_lt+0x56>
8000bf32:	1b 07       	ld.w	r7,sp++
8000bf34:	1b 0e       	ld.w	lr,sp++
8000bf36:	58 3c       	cp.w	r12,3
8000bf38:	c0 a0       	breq	8000bf4c <__avr32_f64_cmp_lt+0x48>
8000bf3a:	58 1c       	cp.w	r12,1
8000bf3c:	c0 33       	brcs	8000bf42 <__avr32_f64_cmp_lt+0x3e>
8000bf3e:	5e 0d       	reteq	0
8000bf40:	5e 1f       	retne	1
8000bf42:	10 3a       	cp.w	r10,r8
8000bf44:	f2 0b 13 00 	cpc	r11,r9
8000bf48:	5e 2d       	reths	0
8000bf4a:	5e 3f       	retlo	1
8000bf4c:	14 38       	cp.w	r8,r10
8000bf4e:	f6 09 13 00 	cpc	r9,r11
8000bf52:	5e 2d       	reths	0
8000bf54:	5e 3f       	retlo	1
8000bf56:	1b 07       	ld.w	r7,sp++
8000bf58:	d8 0a       	popm	pc,r12=0
8000bf5a:	58 17       	cp.w	r7,1
8000bf5c:	5f 1c       	srne	r12
8000bf5e:	58 09       	cp.w	r9,0
8000bf60:	f5 b8 00 00 	subfeq	r8,0
8000bf64:	1b 07       	ld.w	r7,sp++
8000bf66:	1b 0e       	ld.w	lr,sp++
8000bf68:	5e 0d       	reteq	0
8000bf6a:	5e fc       	retal	r12

8000bf6c <__avr32_f64_div>:
8000bf6c:	eb cd 40 ff 	pushm	r0-r7,lr
8000bf70:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf74:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf78:	a9 7b       	lsl	r11,0x9
8000bf7a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bf7e:	a9 7a       	lsl	r10,0x9
8000bf80:	bd bb       	sbr	r11,0x1d
8000bf82:	e4 1b 3f ff 	andh	r11,0x3fff
8000bf86:	ab d7       	cbr	r7,0xb
8000bf88:	e0 80 00 cc 	breq	8000c120 <__avr32_f64_div_round_subnormal+0x54>
8000bf8c:	e0 47 07 ff 	cp.w	r7,2047
8000bf90:	e0 84 00 b5 	brge	8000c0fa <__avr32_f64_div_round_subnormal+0x2e>
8000bf94:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf98:	a9 79       	lsl	r9,0x9
8000bf9a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bf9e:	a9 78       	lsl	r8,0x9
8000bfa0:	bd b9       	sbr	r9,0x1d
8000bfa2:	e4 19 3f ff 	andh	r9,0x3fff
8000bfa6:	ab d6       	cbr	r6,0xb
8000bfa8:	e0 80 00 e2 	breq	8000c16c <__avr32_f64_div_round_subnormal+0xa0>
8000bfac:	e0 46 07 ff 	cp.w	r6,2047
8000bfb0:	e0 84 00 b2 	brge	8000c114 <__avr32_f64_div_round_subnormal+0x48>
8000bfb4:	0c 17       	sub	r7,r6
8000bfb6:	fe 37 fc 01 	sub	r7,-1023
8000bfba:	fc 1c 80 00 	movh	r12,0x8000
8000bfbe:	f8 03 16 01 	lsr	r3,r12,0x1
8000bfc2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bfc6:	5c d4       	com	r4
8000bfc8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bfcc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfd0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfd4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfd8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfdc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfe0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfe4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfe8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bff0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bff4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bff8:	ea 03 15 02 	lsl	r3,r5,0x2
8000bffc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c000:	e4 09 07 40 	macu.d	r0,r2,r9
8000c004:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c008:	02 04       	add	r4,r1
8000c00a:	5c 05       	acr	r5
8000c00c:	a3 65       	lsl	r5,0x2
8000c00e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c012:	a3 64       	lsl	r4,0x2
8000c014:	5c 34       	neg	r4
8000c016:	f8 05 01 45 	sbc	r5,r12,r5
8000c01a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c01e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c022:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c026:	02 04       	add	r4,r1
8000c028:	5c 05       	acr	r5
8000c02a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c02e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c032:	e8 02 15 02 	lsl	r2,r4,0x2
8000c036:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c03a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c03e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c042:	02 04       	add	r4,r1
8000c044:	5c 05       	acr	r5
8000c046:	a3 65       	lsl	r5,0x2
8000c048:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c04c:	a3 64       	lsl	r4,0x2
8000c04e:	5c 34       	neg	r4
8000c050:	f8 05 01 45 	sbc	r5,r12,r5
8000c054:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c058:	e4 05 07 40 	macu.d	r0,r2,r5
8000c05c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c060:	02 04       	add	r4,r1
8000c062:	5c 05       	acr	r5
8000c064:	ea 03 15 02 	lsl	r3,r5,0x2
8000c068:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c06c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c070:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c074:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c078:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c07c:	02 02       	add	r2,r1
8000c07e:	5c 03       	acr	r3
8000c080:	ed b3 00 1c 	bld	r3,0x1c
8000c084:	c0 90       	breq	8000c096 <__avr32_f64_div+0x12a>
8000c086:	a1 72       	lsl	r2,0x1
8000c088:	5c f3       	rol	r3
8000c08a:	20 17       	sub	r7,1
8000c08c:	a3 9a       	lsr	r10,0x3
8000c08e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c092:	a3 9b       	lsr	r11,0x3
8000c094:	c0 58       	rjmp	8000c09e <__avr32_f64_div+0x132>
8000c096:	a5 8a       	lsr	r10,0x4
8000c098:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c09c:	a5 8b       	lsr	r11,0x4
8000c09e:	58 07       	cp.w	r7,0
8000c0a0:	e0 8a 00 8b 	brle	8000c1b6 <__avr32_f64_div_res_subnormal>
8000c0a4:	e0 12 ff 00 	andl	r2,0xff00
8000c0a8:	e8 12 00 80 	orl	r2,0x80
8000c0ac:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0b0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0b4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c0b8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c0bc:	00 05       	add	r5,r0
8000c0be:	f0 01 00 48 	adc	r8,r8,r1
8000c0c2:	5c 09       	acr	r9
8000c0c4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c0c8:	58 04       	cp.w	r4,0
8000c0ca:	5c 25       	cpc	r5

8000c0cc <__avr32_f64_div_round_subnormal>:
8000c0cc:	f4 08 13 00 	cpc	r8,r10
8000c0d0:	f6 09 13 00 	cpc	r9,r11
8000c0d4:	5f 36       	srlo	r6
8000c0d6:	f8 06 17 00 	moveq	r6,r12
8000c0da:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c0de:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c0e2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c0e6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0ea:	ed be 00 1f 	bld	lr,0x1f
8000c0ee:	ef bb 00 1f 	bst	r11,0x1f
8000c0f2:	0c 0a       	add	r10,r6
8000c0f4:	5c 0b       	acr	r11
8000c0f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c0fa:	e4 1b 00 0f 	andh	r11,0xf
8000c0fe:	14 4b       	or	r11,r10
8000c100:	e0 81 00 a7 	brne	8000c24e <__avr32_f64_div_res_subnormal+0x98>
8000c104:	f2 06 16 14 	lsr	r6,r9,0x14
8000c108:	ab d6       	cbr	r6,0xb
8000c10a:	e0 46 07 ff 	cp.w	r6,2047
8000c10e:	e0 81 00 a4 	brne	8000c256 <__avr32_f64_div_res_subnormal+0xa0>
8000c112:	c9 e8       	rjmp	8000c24e <__avr32_f64_div_res_subnormal+0x98>
8000c114:	e4 19 00 0f 	andh	r9,0xf
8000c118:	10 49       	or	r9,r8
8000c11a:	e0 81 00 9a 	brne	8000c24e <__avr32_f64_div_res_subnormal+0x98>
8000c11e:	c9 28       	rjmp	8000c242 <__avr32_f64_div_res_subnormal+0x8c>
8000c120:	a3 7b       	lsl	r11,0x3
8000c122:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c126:	a3 7a       	lsl	r10,0x3
8000c128:	f5 eb 10 04 	or	r4,r10,r11
8000c12c:	e0 80 00 a0 	breq	8000c26c <__avr32_f64_div_op1_zero>
8000c130:	f6 04 12 00 	clz	r4,r11
8000c134:	c1 70       	breq	8000c162 <__avr32_f64_div_round_subnormal+0x96>
8000c136:	c0 c3       	brcs	8000c14e <__avr32_f64_div_round_subnormal+0x82>
8000c138:	e8 05 11 20 	rsub	r5,r4,32
8000c13c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c140:	f4 05 0a 45 	lsr	r5,r10,r5
8000c144:	0a 4b       	or	r11,r5
8000c146:	f4 04 09 4a 	lsl	r10,r10,r4
8000c14a:	08 17       	sub	r7,r4
8000c14c:	c0 b8       	rjmp	8000c162 <__avr32_f64_div_round_subnormal+0x96>
8000c14e:	f4 04 12 00 	clz	r4,r10
8000c152:	f9 b4 03 00 	movlo	r4,0
8000c156:	f7 b4 02 e0 	subhs	r4,-32
8000c15a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c15e:	30 0a       	mov	r10,0
8000c160:	08 17       	sub	r7,r4
8000c162:	a3 8a       	lsr	r10,0x2
8000c164:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c168:	a3 8b       	lsr	r11,0x2
8000c16a:	c1 1b       	rjmp	8000bf8c <__avr32_f64_div+0x20>
8000c16c:	a3 79       	lsl	r9,0x3
8000c16e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c172:	a3 78       	lsl	r8,0x3
8000c174:	f3 e8 10 04 	or	r4,r9,r8
8000c178:	c6 f0       	breq	8000c256 <__avr32_f64_div_res_subnormal+0xa0>
8000c17a:	f2 04 12 00 	clz	r4,r9
8000c17e:	c1 70       	breq	8000c1ac <__avr32_f64_div_round_subnormal+0xe0>
8000c180:	c0 c3       	brcs	8000c198 <__avr32_f64_div_round_subnormal+0xcc>
8000c182:	e8 05 11 20 	rsub	r5,r4,32
8000c186:	f2 04 09 49 	lsl	r9,r9,r4
8000c18a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c18e:	0a 49       	or	r9,r5
8000c190:	f0 04 09 48 	lsl	r8,r8,r4
8000c194:	08 16       	sub	r6,r4
8000c196:	c0 b8       	rjmp	8000c1ac <__avr32_f64_div_round_subnormal+0xe0>
8000c198:	f0 04 12 00 	clz	r4,r8
8000c19c:	f9 b4 03 00 	movlo	r4,0
8000c1a0:	f7 b4 02 e0 	subhs	r4,-32
8000c1a4:	f0 04 09 49 	lsl	r9,r8,r4
8000c1a8:	30 08       	mov	r8,0
8000c1aa:	08 16       	sub	r6,r4
8000c1ac:	a3 88       	lsr	r8,0x2
8000c1ae:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c1b2:	a3 89       	lsr	r9,0x2
8000c1b4:	cf ca       	rjmp	8000bfac <__avr32_f64_div+0x40>

8000c1b6 <__avr32_f64_div_res_subnormal>:
8000c1b6:	5c 37       	neg	r7
8000c1b8:	2f f7       	sub	r7,-1
8000c1ba:	f1 b7 04 c0 	satu	r7,0x6
8000c1be:	e0 47 00 20 	cp.w	r7,32
8000c1c2:	c1 54       	brge	8000c1ec <__avr32_f64_div_res_subnormal+0x36>
8000c1c4:	ee 06 11 20 	rsub	r6,r7,32
8000c1c8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c1cc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c1d0:	18 42       	or	r2,r12
8000c1d2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c1d6:	f4 06 09 41 	lsl	r1,r10,r6
8000c1da:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1de:	f6 06 09 4c 	lsl	r12,r11,r6
8000c1e2:	18 4a       	or	r10,r12
8000c1e4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c1e8:	30 00       	mov	r0,0
8000c1ea:	c1 58       	rjmp	8000c214 <__avr32_f64_div_res_subnormal+0x5e>
8000c1ec:	ee 06 11 20 	rsub	r6,r7,32
8000c1f0:	f9 b0 00 00 	moveq	r0,0
8000c1f4:	f9 bc 00 00 	moveq	r12,0
8000c1f8:	c0 50       	breq	8000c202 <__avr32_f64_div_res_subnormal+0x4c>
8000c1fa:	f4 06 09 40 	lsl	r0,r10,r6
8000c1fe:	f6 06 09 4c 	lsl	r12,r11,r6
8000c202:	e6 07 0a 42 	lsr	r2,r3,r7
8000c206:	30 03       	mov	r3,0
8000c208:	f4 07 0a 41 	lsr	r1,r10,r7
8000c20c:	18 41       	or	r1,r12
8000c20e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c212:	30 0b       	mov	r11,0
8000c214:	e0 12 ff 00 	andl	r2,0xff00
8000c218:	e8 12 00 80 	orl	r2,0x80
8000c21c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c220:	e4 09 07 46 	macu.d	r6,r2,r9
8000c224:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c228:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c22c:	0c 05       	add	r5,r6
8000c22e:	f0 07 00 48 	adc	r8,r8,r7
8000c232:	5c 09       	acr	r9
8000c234:	30 07       	mov	r7,0
8000c236:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c23a:	00 34       	cp.w	r4,r0
8000c23c:	e2 05 13 00 	cpc	r5,r1
8000c240:	c4 6b       	rjmp	8000c0cc <__avr32_f64_div_round_subnormal>
8000c242:	1c 9b       	mov	r11,lr
8000c244:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c248:	30 0a       	mov	r10,0
8000c24a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c24e:	3f fb       	mov	r11,-1
8000c250:	30 0a       	mov	r10,0
8000c252:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c256:	f5 eb 10 04 	or	r4,r10,r11
8000c25a:	c0 90       	breq	8000c26c <__avr32_f64_div_op1_zero>
8000c25c:	1c 9b       	mov	r11,lr
8000c25e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c262:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c266:	30 0a       	mov	r10,0
8000c268:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c26c <__avr32_f64_div_op1_zero>:
8000c26c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c270:	ce f0       	breq	8000c24e <__avr32_f64_div_res_subnormal+0x98>
8000c272:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c276:	e0 44 07 ff 	cp.w	r4,2047
8000c27a:	ce 41       	brne	8000c242 <__avr32_f64_div_res_subnormal+0x8c>
8000c27c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c280:	ce 10       	breq	8000c242 <__avr32_f64_div_res_subnormal+0x8c>
8000c282:	ce 6b       	rjmp	8000c24e <__avr32_f64_div_res_subnormal+0x98>

8000c284 <__avr32_udiv64>:
8000c284:	d4 31       	pushm	r0-r7,lr
8000c286:	1a 97       	mov	r7,sp
8000c288:	20 3d       	sub	sp,12
8000c28a:	10 9c       	mov	r12,r8
8000c28c:	12 9e       	mov	lr,r9
8000c28e:	14 93       	mov	r3,r10
8000c290:	58 09       	cp.w	r9,0
8000c292:	e0 81 00 bd 	brne	8000c40c <__avr32_udiv64+0x188>
8000c296:	16 38       	cp.w	r8,r11
8000c298:	e0 88 00 40 	brls	8000c318 <__avr32_udiv64+0x94>
8000c29c:	f0 08 12 00 	clz	r8,r8
8000c2a0:	c0 d0       	breq	8000c2ba <__avr32_udiv64+0x36>
8000c2a2:	f6 08 09 4b 	lsl	r11,r11,r8
8000c2a6:	f0 09 11 20 	rsub	r9,r8,32
8000c2aa:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2ae:	f4 09 0a 49 	lsr	r9,r10,r9
8000c2b2:	f4 08 09 43 	lsl	r3,r10,r8
8000c2b6:	f3 eb 10 0b 	or	r11,r9,r11
8000c2ba:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c2be:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c2c2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c2c6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c2ca:	00 99       	mov	r9,r0
8000c2cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c2d0:	e0 0a 02 48 	mul	r8,r0,r10
8000c2d4:	10 3b       	cp.w	r11,r8
8000c2d6:	c0 a2       	brcc	8000c2ea <__avr32_udiv64+0x66>
8000c2d8:	20 19       	sub	r9,1
8000c2da:	18 0b       	add	r11,r12
8000c2dc:	18 3b       	cp.w	r11,r12
8000c2de:	c0 63       	brcs	8000c2ea <__avr32_udiv64+0x66>
8000c2e0:	10 3b       	cp.w	r11,r8
8000c2e2:	f7 b9 03 01 	sublo	r9,1
8000c2e6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c2ea:	f6 08 01 01 	sub	r1,r11,r8
8000c2ee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c2f2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c2f6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c2fa:	00 98       	mov	r8,r0
8000c2fc:	e0 0a 02 4a 	mul	r10,r0,r10
8000c300:	14 33       	cp.w	r3,r10
8000c302:	c0 82       	brcc	8000c312 <__avr32_udiv64+0x8e>
8000c304:	20 18       	sub	r8,1
8000c306:	18 03       	add	r3,r12
8000c308:	18 33       	cp.w	r3,r12
8000c30a:	c0 43       	brcs	8000c312 <__avr32_udiv64+0x8e>
8000c30c:	14 33       	cp.w	r3,r10
8000c30e:	f7 b8 03 01 	sublo	r8,1
8000c312:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c316:	cd f8       	rjmp	8000c4d4 <__avr32_udiv64+0x250>
8000c318:	58 08       	cp.w	r8,0
8000c31a:	c0 51       	brne	8000c324 <__avr32_udiv64+0xa0>
8000c31c:	30 19       	mov	r9,1
8000c31e:	f2 08 0d 08 	divu	r8,r9,r8
8000c322:	10 9c       	mov	r12,r8
8000c324:	f8 06 12 00 	clz	r6,r12
8000c328:	c0 41       	brne	8000c330 <__avr32_udiv64+0xac>
8000c32a:	18 1b       	sub	r11,r12
8000c32c:	30 19       	mov	r9,1
8000c32e:	c4 08       	rjmp	8000c3ae <__avr32_udiv64+0x12a>
8000c330:	ec 01 11 20 	rsub	r1,r6,32
8000c334:	f4 01 0a 49 	lsr	r9,r10,r1
8000c338:	f8 06 09 4c 	lsl	r12,r12,r6
8000c33c:	f6 06 09 48 	lsl	r8,r11,r6
8000c340:	f6 01 0a 41 	lsr	r1,r11,r1
8000c344:	f3 e8 10 08 	or	r8,r9,r8
8000c348:	f8 03 16 10 	lsr	r3,r12,0x10
8000c34c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c350:	e2 03 0d 00 	divu	r0,r1,r3
8000c354:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c358:	00 9e       	mov	lr,r0
8000c35a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c35e:	e0 05 02 49 	mul	r9,r0,r5
8000c362:	12 3b       	cp.w	r11,r9
8000c364:	c0 a2       	brcc	8000c378 <__avr32_udiv64+0xf4>
8000c366:	20 1e       	sub	lr,1
8000c368:	18 0b       	add	r11,r12
8000c36a:	18 3b       	cp.w	r11,r12
8000c36c:	c0 63       	brcs	8000c378 <__avr32_udiv64+0xf4>
8000c36e:	12 3b       	cp.w	r11,r9
8000c370:	f7 be 03 01 	sublo	lr,1
8000c374:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c378:	12 1b       	sub	r11,r9
8000c37a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c37e:	f6 03 0d 02 	divu	r2,r11,r3
8000c382:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c386:	04 99       	mov	r9,r2
8000c388:	e4 05 02 4b 	mul	r11,r2,r5
8000c38c:	16 38       	cp.w	r8,r11
8000c38e:	c0 a2       	brcc	8000c3a2 <__avr32_udiv64+0x11e>
8000c390:	20 19       	sub	r9,1
8000c392:	18 08       	add	r8,r12
8000c394:	18 38       	cp.w	r8,r12
8000c396:	c0 63       	brcs	8000c3a2 <__avr32_udiv64+0x11e>
8000c398:	16 38       	cp.w	r8,r11
8000c39a:	f7 b9 03 01 	sublo	r9,1
8000c39e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c3a2:	f4 06 09 43 	lsl	r3,r10,r6
8000c3a6:	f0 0b 01 0b 	sub	r11,r8,r11
8000c3aa:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c3ae:	f8 06 16 10 	lsr	r6,r12,0x10
8000c3b2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c3b6:	f6 06 0d 00 	divu	r0,r11,r6
8000c3ba:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c3be:	00 9a       	mov	r10,r0
8000c3c0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c3c4:	e0 0e 02 48 	mul	r8,r0,lr
8000c3c8:	10 3b       	cp.w	r11,r8
8000c3ca:	c0 a2       	brcc	8000c3de <__avr32_udiv64+0x15a>
8000c3cc:	20 1a       	sub	r10,1
8000c3ce:	18 0b       	add	r11,r12
8000c3d0:	18 3b       	cp.w	r11,r12
8000c3d2:	c0 63       	brcs	8000c3de <__avr32_udiv64+0x15a>
8000c3d4:	10 3b       	cp.w	r11,r8
8000c3d6:	f7 ba 03 01 	sublo	r10,1
8000c3da:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c3de:	f6 08 01 01 	sub	r1,r11,r8
8000c3e2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c3e6:	e2 06 0d 00 	divu	r0,r1,r6
8000c3ea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c3ee:	00 98       	mov	r8,r0
8000c3f0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c3f4:	16 33       	cp.w	r3,r11
8000c3f6:	c0 82       	brcc	8000c406 <__avr32_udiv64+0x182>
8000c3f8:	20 18       	sub	r8,1
8000c3fa:	18 03       	add	r3,r12
8000c3fc:	18 33       	cp.w	r3,r12
8000c3fe:	c0 43       	brcs	8000c406 <__avr32_udiv64+0x182>
8000c400:	16 33       	cp.w	r3,r11
8000c402:	f7 b8 03 01 	sublo	r8,1
8000c406:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c40a:	c6 98       	rjmp	8000c4dc <__avr32_udiv64+0x258>
8000c40c:	16 39       	cp.w	r9,r11
8000c40e:	e0 8b 00 65 	brhi	8000c4d8 <__avr32_udiv64+0x254>
8000c412:	f2 09 12 00 	clz	r9,r9
8000c416:	c0 b1       	brne	8000c42c <__avr32_udiv64+0x1a8>
8000c418:	10 3a       	cp.w	r10,r8
8000c41a:	5f 2a       	srhs	r10
8000c41c:	1c 3b       	cp.w	r11,lr
8000c41e:	5f b8       	srhi	r8
8000c420:	10 4a       	or	r10,r8
8000c422:	f2 0a 18 00 	cp.b	r10,r9
8000c426:	c5 90       	breq	8000c4d8 <__avr32_udiv64+0x254>
8000c428:	30 18       	mov	r8,1
8000c42a:	c5 98       	rjmp	8000c4dc <__avr32_udiv64+0x258>
8000c42c:	f0 09 09 46 	lsl	r6,r8,r9
8000c430:	f2 03 11 20 	rsub	r3,r9,32
8000c434:	fc 09 09 4e 	lsl	lr,lr,r9
8000c438:	f0 03 0a 48 	lsr	r8,r8,r3
8000c43c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c440:	f4 03 0a 42 	lsr	r2,r10,r3
8000c444:	ef 46 ff f4 	st.w	r7[-12],r6
8000c448:	f6 03 0a 43 	lsr	r3,r11,r3
8000c44c:	18 42       	or	r2,r12
8000c44e:	f1 ee 10 0c 	or	r12,r8,lr
8000c452:	f8 01 16 10 	lsr	r1,r12,0x10
8000c456:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c45a:	e6 01 0d 04 	divu	r4,r3,r1
8000c45e:	e4 03 16 10 	lsr	r3,r2,0x10
8000c462:	08 9e       	mov	lr,r4
8000c464:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c468:	e8 06 02 48 	mul	r8,r4,r6
8000c46c:	10 33       	cp.w	r3,r8
8000c46e:	c0 a2       	brcc	8000c482 <__avr32_udiv64+0x1fe>
8000c470:	20 1e       	sub	lr,1
8000c472:	18 03       	add	r3,r12
8000c474:	18 33       	cp.w	r3,r12
8000c476:	c0 63       	brcs	8000c482 <__avr32_udiv64+0x1fe>
8000c478:	10 33       	cp.w	r3,r8
8000c47a:	f7 be 03 01 	sublo	lr,1
8000c47e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c482:	10 13       	sub	r3,r8
8000c484:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c488:	e6 01 0d 00 	divu	r0,r3,r1
8000c48c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c490:	00 98       	mov	r8,r0
8000c492:	e0 06 02 46 	mul	r6,r0,r6
8000c496:	0c 3b       	cp.w	r11,r6
8000c498:	c0 a2       	brcc	8000c4ac <__avr32_udiv64+0x228>
8000c49a:	20 18       	sub	r8,1
8000c49c:	18 0b       	add	r11,r12
8000c49e:	18 3b       	cp.w	r11,r12
8000c4a0:	c0 63       	brcs	8000c4ac <__avr32_udiv64+0x228>
8000c4a2:	0c 3b       	cp.w	r11,r6
8000c4a4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4a8:	f7 b8 03 01 	sublo	r8,1
8000c4ac:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c4b0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c4b4:	0c 1b       	sub	r11,r6
8000c4b6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c4ba:	06 95       	mov	r5,r3
8000c4bc:	16 35       	cp.w	r5,r11
8000c4be:	e0 8b 00 0a 	brhi	8000c4d2 <__avr32_udiv64+0x24e>
8000c4c2:	5f 0b       	sreq	r11
8000c4c4:	f4 09 09 49 	lsl	r9,r10,r9
8000c4c8:	12 32       	cp.w	r2,r9
8000c4ca:	5f b9       	srhi	r9
8000c4cc:	f7 e9 00 09 	and	r9,r11,r9
8000c4d0:	c0 60       	breq	8000c4dc <__avr32_udiv64+0x258>
8000c4d2:	20 18       	sub	r8,1
8000c4d4:	30 09       	mov	r9,0
8000c4d6:	c0 38       	rjmp	8000c4dc <__avr32_udiv64+0x258>
8000c4d8:	30 09       	mov	r9,0
8000c4da:	12 98       	mov	r8,r9
8000c4dc:	10 9a       	mov	r10,r8
8000c4de:	12 93       	mov	r3,r9
8000c4e0:	10 92       	mov	r2,r8
8000c4e2:	12 9b       	mov	r11,r9
8000c4e4:	2f dd       	sub	sp,-12
8000c4e6:	d8 32       	popm	r0-r7,pc

8000c4e8 <__avr32_umod64>:
8000c4e8:	d4 31       	pushm	r0-r7,lr
8000c4ea:	1a 97       	mov	r7,sp
8000c4ec:	20 3d       	sub	sp,12
8000c4ee:	10 9c       	mov	r12,r8
8000c4f0:	12 95       	mov	r5,r9
8000c4f2:	14 9e       	mov	lr,r10
8000c4f4:	16 91       	mov	r1,r11
8000c4f6:	16 96       	mov	r6,r11
8000c4f8:	58 09       	cp.w	r9,0
8000c4fa:	e0 81 00 81 	brne	8000c5fc <__avr32_umod64+0x114>
8000c4fe:	16 38       	cp.w	r8,r11
8000c500:	e0 88 00 12 	brls	8000c524 <__avr32_umod64+0x3c>
8000c504:	f0 08 12 00 	clz	r8,r8
8000c508:	c4 e0       	breq	8000c5a4 <__avr32_umod64+0xbc>
8000c50a:	f6 08 09 46 	lsl	r6,r11,r8
8000c50e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c512:	f0 0b 11 20 	rsub	r11,r8,32
8000c516:	f4 08 09 4e 	lsl	lr,r10,r8
8000c51a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c51e:	f7 e6 10 06 	or	r6,r11,r6
8000c522:	c4 18       	rjmp	8000c5a4 <__avr32_umod64+0xbc>
8000c524:	58 08       	cp.w	r8,0
8000c526:	c0 51       	brne	8000c530 <__avr32_umod64+0x48>
8000c528:	30 19       	mov	r9,1
8000c52a:	f2 08 0d 08 	divu	r8,r9,r8
8000c52e:	10 9c       	mov	r12,r8
8000c530:	f8 08 12 00 	clz	r8,r12
8000c534:	c0 31       	brne	8000c53a <__avr32_umod64+0x52>
8000c536:	18 16       	sub	r6,r12
8000c538:	c3 68       	rjmp	8000c5a4 <__avr32_umod64+0xbc>
8000c53a:	f0 03 11 20 	rsub	r3,r8,32
8000c53e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c542:	f8 08 09 4c 	lsl	r12,r12,r8
8000c546:	ec 08 09 49 	lsl	r9,r6,r8
8000c54a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c54e:	f7 e9 10 09 	or	r9,r11,r9
8000c552:	f8 05 16 10 	lsr	r5,r12,0x10
8000c556:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c55a:	e6 05 0d 02 	divu	r2,r3,r5
8000c55e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c562:	ec 02 02 4b 	mul	r11,r6,r2
8000c566:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c56a:	16 3e       	cp.w	lr,r11
8000c56c:	c0 72       	brcc	8000c57a <__avr32_umod64+0x92>
8000c56e:	18 0e       	add	lr,r12
8000c570:	18 3e       	cp.w	lr,r12
8000c572:	c0 43       	brcs	8000c57a <__avr32_umod64+0x92>
8000c574:	16 3e       	cp.w	lr,r11
8000c576:	fd dc e3 0e 	addcs	lr,lr,r12
8000c57a:	fc 0b 01 03 	sub	r3,lr,r11
8000c57e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c582:	e6 05 0d 02 	divu	r2,r3,r5
8000c586:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c58a:	a5 36       	mul	r6,r2
8000c58c:	0c 39       	cp.w	r9,r6
8000c58e:	c0 72       	brcc	8000c59c <__avr32_umod64+0xb4>
8000c590:	18 09       	add	r9,r12
8000c592:	18 39       	cp.w	r9,r12
8000c594:	c0 43       	brcs	8000c59c <__avr32_umod64+0xb4>
8000c596:	0c 39       	cp.w	r9,r6
8000c598:	f3 dc e3 09 	addcs	r9,r9,r12
8000c59c:	f2 06 01 06 	sub	r6,r9,r6
8000c5a0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c5a4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c5a8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c5ac:	ec 0a 0d 02 	divu	r2,r6,r10
8000c5b0:	fc 09 16 10 	lsr	r9,lr,0x10
8000c5b4:	ea 02 02 4b 	mul	r11,r5,r2
8000c5b8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c5bc:	16 39       	cp.w	r9,r11
8000c5be:	c0 72       	brcc	8000c5cc <__avr32_umod64+0xe4>
8000c5c0:	18 09       	add	r9,r12
8000c5c2:	18 39       	cp.w	r9,r12
8000c5c4:	c0 43       	brcs	8000c5cc <__avr32_umod64+0xe4>
8000c5c6:	16 39       	cp.w	r9,r11
8000c5c8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5cc:	f2 0b 01 0b 	sub	r11,r9,r11
8000c5d0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c5d4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c5d8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c5dc:	ea 0a 02 4a 	mul	r10,r5,r10
8000c5e0:	14 3e       	cp.w	lr,r10
8000c5e2:	c0 72       	brcc	8000c5f0 <__avr32_umod64+0x108>
8000c5e4:	18 0e       	add	lr,r12
8000c5e6:	18 3e       	cp.w	lr,r12
8000c5e8:	c0 43       	brcs	8000c5f0 <__avr32_umod64+0x108>
8000c5ea:	14 3e       	cp.w	lr,r10
8000c5ec:	fd dc e3 0e 	addcs	lr,lr,r12
8000c5f0:	fc 0a 01 0a 	sub	r10,lr,r10
8000c5f4:	30 0b       	mov	r11,0
8000c5f6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c5fa:	c7 b8       	rjmp	8000c6f0 <__avr32_umod64+0x208>
8000c5fc:	16 39       	cp.w	r9,r11
8000c5fe:	e0 8b 00 79 	brhi	8000c6f0 <__avr32_umod64+0x208>
8000c602:	f2 09 12 00 	clz	r9,r9
8000c606:	c1 21       	brne	8000c62a <__avr32_umod64+0x142>
8000c608:	10 3a       	cp.w	r10,r8
8000c60a:	5f 2b       	srhs	r11
8000c60c:	0a 31       	cp.w	r1,r5
8000c60e:	5f ba       	srhi	r10
8000c610:	f7 ea 10 0a 	or	r10,r11,r10
8000c614:	f2 0a 18 00 	cp.b	r10,r9
8000c618:	c0 60       	breq	8000c624 <__avr32_umod64+0x13c>
8000c61a:	fc 08 01 0c 	sub	r12,lr,r8
8000c61e:	e2 05 01 46 	sbc	r6,r1,r5
8000c622:	18 9e       	mov	lr,r12
8000c624:	0c 9b       	mov	r11,r6
8000c626:	1c 9a       	mov	r10,lr
8000c628:	c6 48       	rjmp	8000c6f0 <__avr32_umod64+0x208>
8000c62a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c62e:	f2 06 11 20 	rsub	r6,r9,32
8000c632:	f6 09 09 4b 	lsl	r11,r11,r9
8000c636:	f0 09 09 42 	lsl	r2,r8,r9
8000c63a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c63e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c642:	18 48       	or	r8,r12
8000c644:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c648:	f4 09 09 43 	lsl	r3,r10,r9
8000c64c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c650:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c654:	16 4a       	or	r10,r11
8000c656:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c65a:	f8 0b 0d 04 	divu	r4,r12,r11
8000c65e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c662:	08 91       	mov	r1,r4
8000c664:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c668:	e8 0e 02 46 	mul	r6,r4,lr
8000c66c:	0c 3c       	cp.w	r12,r6
8000c66e:	c0 a2       	brcc	8000c682 <__avr32_umod64+0x19a>
8000c670:	20 11       	sub	r1,1
8000c672:	10 0c       	add	r12,r8
8000c674:	10 3c       	cp.w	r12,r8
8000c676:	c0 63       	brcs	8000c682 <__avr32_umod64+0x19a>
8000c678:	0c 3c       	cp.w	r12,r6
8000c67a:	f7 b1 03 01 	sublo	r1,1
8000c67e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c682:	0c 1c       	sub	r12,r6
8000c684:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c688:	f8 0b 0d 04 	divu	r4,r12,r11
8000c68c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c690:	08 96       	mov	r6,r4
8000c692:	e8 0e 02 4e 	mul	lr,r4,lr
8000c696:	1c 3b       	cp.w	r11,lr
8000c698:	c0 a2       	brcc	8000c6ac <__avr32_umod64+0x1c4>
8000c69a:	20 16       	sub	r6,1
8000c69c:	10 0b       	add	r11,r8
8000c69e:	10 3b       	cp.w	r11,r8
8000c6a0:	c0 63       	brcs	8000c6ac <__avr32_umod64+0x1c4>
8000c6a2:	1c 3b       	cp.w	r11,lr
8000c6a4:	f7 b6 03 01 	sublo	r6,1
8000c6a8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c6ac:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c6b0:	1c 1b       	sub	r11,lr
8000c6b2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c6b6:	00 9e       	mov	lr,r0
8000c6b8:	02 9c       	mov	r12,r1
8000c6ba:	16 3c       	cp.w	r12,r11
8000c6bc:	e0 8b 00 08 	brhi	8000c6cc <__avr32_umod64+0x1e4>
8000c6c0:	5f 06       	sreq	r6
8000c6c2:	06 30       	cp.w	r0,r3
8000c6c4:	5f ba       	srhi	r10
8000c6c6:	ed ea 00 0a 	and	r10,r6,r10
8000c6ca:	c0 60       	breq	8000c6d6 <__avr32_umod64+0x1ee>
8000c6cc:	fc 02 01 04 	sub	r4,lr,r2
8000c6d0:	f8 08 01 4c 	sbc	r12,r12,r8
8000c6d4:	08 9e       	mov	lr,r4
8000c6d6:	e6 0e 01 0a 	sub	r10,r3,lr
8000c6da:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c6de:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c6e2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c6e6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c6ea:	f8 01 09 4c 	lsl	r12,r12,r1
8000c6ee:	18 4a       	or	r10,r12
8000c6f0:	2f dd       	sub	sp,-12
8000c6f2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 1c 	sub	pc,pc,28700

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c4 b5 	rcall	80005270 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c4 ae 	rcall	80005270 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c4 a7 	rcall	80005270 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c4 a0 	rcall	80005270 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
