
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ad7c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000e2b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000ecf8  0000f244  2**0
                  ALLOC
  7 .bss          00004990  00000a48  8000ecf8  0000f248  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f244  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001750  00000000  00000000  0000f278  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000037a6  00000000  00000000  000109c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002dd7d  00000000  00000000  0001416e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000076d8  00000000  00000000  00041eeb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d959  00000000  00000000  000495c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003f00  00000000  00000000  00056f1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00008124  00000000  00000000  0005ae1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f817  00000000  00000000  00062f40  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001808  00000000  00000000  00072758  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c2 ec 	sub	pc,pc,-15636

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d a0       	ld.ub	r0,r6[0x2]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 64       	and	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e f0       	mov	r0,-17
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 8c       	sub	r12,-72
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6c ac       	ld.w	r12,r6[0x28]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 5c       	eor	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	70 70       	ld.w	r0,r8[0x1c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 4e       	or	lr,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	70 70       	ld.w	r0,r8[0x1c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 4b       	or	r11,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	70 70       	ld.w	r0,r8[0x1c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	70 70       	ld.w	r0,r8[0x1c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	70 70       	ld.w	r0,r8[0x1c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	70 70       	ld.w	r0,r8[0x1c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	70 70       	ld.w	r0,r8[0x1c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d1 00       	acall	0x10
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	70 70       	ld.w	r0,r8[0x1c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d1 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d1 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d1 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	70 70       	ld.w	r0,r8[0x1c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d1 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d1 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d1 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d1 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d1 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d2 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 40       	acall	0x24

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d2 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	70 70       	ld.w	r0,r8[0x1c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d1 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d2 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	70 70       	ld.w	r0,r8[0x1c]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c0       	acall	0x2c
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d2 d0       	acall	0x2d
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 e0       	acall	0x2e
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	d2 f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	70 70       	ld.w	r0,r8[0x1c]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 4d       	or	sp,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d3 10       	acall	0x31
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	70 70       	ld.w	r0,r8[0x1c]
80002404:	00 00       	add	r0,r0
80002406:	0a 4c       	or	r12,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d3 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	70 70       	ld.w	r0,r8[0x1c]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 b0       	acall	0x3b
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	70 70       	ld.w	r0,r8[0x1c]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c0       	acall	0x3c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d3 d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	70 70       	ld.w	r0,r8[0x1c]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d4 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	70 70       	ld.w	r0,r8[0x1c]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 50       	acall	0x45
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	70 70       	ld.w	r0,r8[0x1c]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 60       	acall	0x46

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d4 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	70 70       	ld.w	r0,r8[0x1c]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 55       	eor	r5,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d4 80       	acall	0x48
800025cc:	00 00       	add	r0,r0
800025ce:	0a 4d       	or	sp,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	70 70       	ld.w	r0,r8[0x1c]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d4 b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 00       	acall	0x50
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 30       	acall	0x53

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 40       	acall	0x54
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	70 70       	ld.w	r0,r8[0x1c]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	d5 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 80       	acall	0x58

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	70 70       	ld.w	r0,r8[0x1c]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b0       	acall	0x5b
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d5 c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d5 f0       	acall	0x5f
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	70 70       	ld.w	r0,r8[0x1c]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d5 fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	69 9c       	ld.w	r12,r4[0x64]
80002828:	00 00       	add	r0,r0
8000282a:	0a 58       	eor	r8,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 50       	eor	r0,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0b 74       	ld.ub	r4,--r5
80002838:	00 00       	add	r0,r0
8000283a:	0d a0       	ld.ub	r0,r6[0x2]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 54       	eor	r4,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	40 7c       	lddsp	r12,sp[0x1c]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d6 08       	*unknown*
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	70 70       	ld.w	r0,r8[0x1c]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d6 1c       	*unknown*
80002850:	00 00       	add	r0,r0
80002852:	0d a4       	ld.ub	r4,r6[0x2]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	d6 2c       	*unknown*
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	d6 58       	*unknown*
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	3f 44       	mov	r4,-12
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	62 2c       	ld.w	r12,r1[0x8]
80002864:	00 00       	add	r0,r0
80002866:	0b 7c       	ld.ub	r12,--r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	2c 0c       	sub	r12,-64
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d6 68       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d6 78       	*unknown*
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	6b 4c       	ld.w	r12,r5[0x50]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	d6 88       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	70 70       	ld.w	r0,r8[0x1c]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 54       	eor	r4,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	40 7c       	lddsp	r12,sp[0x1c]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	6b 04       	ld.w	r4,r5[0x40]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	50 c0       	stdsp	sp[0x30],r0

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d6 a8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	70 70       	ld.w	r0,r8[0x1c]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	d6 bc       	*unknown*
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	d6 d4       	*unknown*
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d6 f0       	acall	0x6f
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	d7 08       	*unknown*
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	d7 14       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	78 f4       	ld.w	r4,r12[0x3c]
800029b4:	00 00       	add	r0,r0
800029b6:	0b 7c       	ld.ub	r12,--r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	2d b8       	sub	r8,-37
800029bc:	00 00       	add	r0,r0
800029be:	0b 74       	ld.ub	r4,--r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	64 38       	ld.w	r8,r2[0xc]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	d7 2c       	*unknown*

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0d a0       	ld.ub	r0,r6[0x2]
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	3f d0       	mov	r0,-3

80002a00 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002a00:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80002a02:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002a04:	30 0a       	mov	r10,0
80002a06:	32 8b       	mov	r11,40
80002a08:	49 5c       	lddpc	r12,80002a5c <xg_rtc_init+0x5c>
80002a0a:	f0 1f 00 16 	mcall	80002a60 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80002a0e:	30 ea       	mov	r10,14
80002a10:	30 1b       	mov	r11,1
80002a12:	fe 7c 0d 00 	mov	r12,-62208
80002a16:	f0 1f 00 14 	mcall	80002a64 <xg_rtc_init+0x64>
80002a1a:	c0 41       	brne	80002a22 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80002a1c:	49 3c       	lddpc	r12,80002a68 <xg_rtc_init+0x68>
80002a1e:	f0 1f 00 14 	mcall	80002a6c <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80002a22:	30 0b       	mov	r11,0
80002a24:	fe 7c 0d 00 	mov	r12,-62208
80002a28:	f0 1f 00 12 	mcall	80002a70 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80002a2c:	fe 7c 0d 00 	mov	r12,-62208
80002a30:	f0 1f 00 11 	mcall	80002a74 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002a34:	fe 7c 0d 00 	mov	r12,-62208
80002a38:	f0 1f 00 10 	mcall	80002a78 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002a3c:	49 08       	lddpc	r8,80002a7c <xg_rtc_init+0x7c>
80002a3e:	31 09       	mov	r9,16
80002a40:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002a42:	30 29       	mov	r9,2
80002a44:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002a46:	31 d9       	mov	r9,29
80002a48:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a4a:	31 79       	mov	r9,23
80002a4c:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a4e:	33 b9       	mov	r9,59
80002a50:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a52:	32 89       	mov	r9,40
80002a54:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002a56:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a58:	d8 02       	popm	pc
80002a5a:	00 00       	add	r0,r0
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	2a 80       	sub	r0,-88
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	54 d8       	stdsp	sp[0x134],r8
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	58 24       	cp.w	r4,2
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	d7 3c       	*unknown*
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	70 70       	ld.w	r0,r8[0x1c]
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	57 e0       	stdsp	sp[0x1f8],r0
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	57 d8       	stdsp	sp[0x1f4],r8
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	57 b4       	stdsp	sp[0x1ec],r4
80002a7c:	00 00       	add	r0,r0
80002a7e:	0d a4       	ld.ub	r4,r6[0x2]

80002a80 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a80:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a82:	4b 98       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a84:	11 d9       	ld.ub	r9,r8[0x5]
80002a86:	2f f9       	sub	r9,-1
80002a88:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a8a:	11 d9       	ld.ub	r9,r8[0x5]
80002a8c:	33 b8       	mov	r8,59
80002a8e:	f0 09 18 00 	cp.b	r9,r8
80002a92:	e0 88 00 5f 	brls	80002b50 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a96:	4b 48       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a98:	30 09       	mov	r9,0
80002a9a:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a9c:	11 c9       	ld.ub	r9,r8[0x4]
80002a9e:	2f f9       	sub	r9,-1
80002aa0:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002aa2:	11 c9       	ld.ub	r9,r8[0x4]
80002aa4:	33 b8       	mov	r8,59
80002aa6:	f0 09 18 00 	cp.b	r9,r8
80002aaa:	e0 88 00 53 	brls	80002b50 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002aae:	4a e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ab0:	30 09       	mov	r9,0
80002ab2:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002ab4:	11 b9       	ld.ub	r9,r8[0x3]
80002ab6:	2f f9       	sub	r9,-1
80002ab8:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002aba:	11 b9       	ld.ub	r9,r8[0x3]
80002abc:	31 78       	mov	r8,23
80002abe:	f0 09 18 00 	cp.b	r9,r8
80002ac2:	e0 88 00 47 	brls	80002b50 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002ac6:	4a 88       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ac8:	30 09       	mov	r9,0
80002aca:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002acc:	11 88       	ld.ub	r8,r8[0x0]
80002ace:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002ad2:	e0 69 01 6e 	mov	r9,366
80002ad6:	e0 6a 01 6d 	mov	r10,365
80002ada:	f4 08 17 10 	movne	r8,r10
80002ade:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002ae2:	4a 19       	lddpc	r9,80002b64 <rtc_irq+0xe4>
80002ae4:	13 9a       	ld.ub	r10,r9[0x1]
80002ae6:	30 29       	mov	r9,2
80002ae8:	f2 0a 18 00 	cp.b	r10,r9
80002aec:	c0 b0       	breq	80002b02 <rtc_irq+0x82>
80002aee:	49 e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002af0:	11 99       	ld.ub	r9,r8[0x1]
80002af2:	11 9a       	ld.ub	r10,r8[0x1]
80002af4:	a3 9a       	lsr	r10,0x3
80002af6:	12 0a       	add	r10,r9
80002af8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002afc:	2e 2a       	sub	r10,-30
80002afe:	5c 5a       	castu.b	r10
80002b00:	c0 58       	rjmp	80002b0a <rtc_irq+0x8a>
80002b02:	f0 c8 01 51 	sub	r8,r8,337
80002b06:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002b0a:	49 78       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b0c:	11 a9       	ld.ub	r9,r8[0x2]
80002b0e:	2f f9       	sub	r9,-1
80002b10:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002b12:	11 a8       	ld.ub	r8,r8[0x2]
80002b14:	f0 0a 18 00 	cp.b	r10,r8
80002b18:	c1 c2       	brcc	80002b50 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002b1a:	49 38       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b1c:	30 19       	mov	r9,1
80002b1e:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002b20:	11 99       	ld.ub	r9,r8[0x1]
80002b22:	2f f9       	sub	r9,-1
80002b24:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002b26:	11 99       	ld.ub	r9,r8[0x1]
80002b28:	30 c8       	mov	r8,12
80002b2a:	f0 09 18 00 	cp.b	r9,r8
80002b2e:	e0 88 00 11 	brls	80002b50 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002b32:	48 d8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b34:	30 19       	mov	r9,1
80002b36:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002b38:	11 89       	ld.ub	r9,r8[0x0]
80002b3a:	2f f9       	sub	r9,-1
80002b3c:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002b3e:	11 89       	ld.ub	r9,r8[0x0]
80002b40:	39 68       	mov	r8,-106
80002b42:	f0 09 18 00 	cp.b	r9,r8
80002b46:	e0 88 00 05 	brls	80002b50 <rtc_irq+0xd0>
80002b4a:	30 09       	mov	r9,0
80002b4c:	48 68       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b4e:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b50:	fe 7c 0d 00 	mov	r12,-62208
80002b54:	f0 1f 00 05 	mcall	80002b68 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b58:	30 19       	mov	r9,1
80002b5a:	48 58       	lddpc	r8,80002b6c <rtc_irq+0xec>
80002b5c:	91 09       	st.w	r8[0x0],r9
}
80002b5e:	d4 02       	popm	lr
80002b60:	d6 03       	rete
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0d a4       	ld.ub	r4,r6[0x2]
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	58 04       	cp.w	r4,0
80002b6c:	00 00       	add	r0,r0
80002b6e:	04 f4       	st.b	--r2,r4

80002b70 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b70:	20 1c       	sub	r12,1
80002b72:	5c 5c       	castu.b	r12
80002b74:	31 18       	mov	r8,17
80002b76:	f0 0c 18 00 	cp.b	r12,r8
80002b7a:	e0 88 00 03 	brls	80002b80 <CalculateBurst+0x10>
80002b7e:	5e fd       	retal	0
80002b80:	48 28       	lddpc	r8,80002b88 <CalculateBurst+0x18>
80002b82:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b86:	5e fc       	retal	r12
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	d7 5c       	*unknown*

80002b8c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b8c:	48 38       	lddpc	r8,80002b98 <payload_init+0xc>
80002b8e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b90:	48 38       	lddpc	r8,80002b9c <payload_init+0x10>
80002b92:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b94:	5e fc       	retal	r12
80002b96:	00 00       	add	r0,r0
80002b98:	00 00       	add	r0,r0
80002b9a:	0a 68       	and	r8,r5
80002b9c:	00 00       	add	r0,r0
80002b9e:	0a 6c       	and	r12,r5

80002ba0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
80002ba4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba6:	30 09       	mov	r9,0
80002ba8:	fa ca ff f8 	sub	r10,sp,-8
80002bac:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bae:	1a 9b       	mov	r11,sp
80002bb0:	f0 1f 00 02 	mcall	80002bb8 <set_idle_store_isr+0x18>
}
80002bb4:	2f ed       	sub	sp,-8
80002bb6:	d8 02       	popm	pc
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	63 e8       	ld.w	r8,r1[0x78]

80002bbc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bbc:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002bbe:	48 48       	lddpc	r8,80002bcc <payload_rx+0x10>
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	18 9b       	mov	r11,r12
80002bc4:	10 9c       	mov	r12,r8
80002bc6:	f0 1f 00 03 	mcall	80002bd0 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002bca:	d8 02       	popm	pc
80002bcc:	00 00       	add	r0,r0
80002bce:	0a a4       	st.w	r5++,r4
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	2b a0       	sub	r0,-70

80002bd4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002bd4:	d4 01       	pushm	lr
80002bd6:	20 2d       	sub	sp,8
80002bd8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bda:	58 0c       	cp.w	r12,0
80002bdc:	c1 10       	breq	80002bfe <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bde:	30 08       	mov	r8,0
80002be0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002be2:	98 88       	ld.uh	r8,r12[0x0]
80002be4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002be8:	e0 48 40 00 	cp.w	r8,16384
80002bec:	c0 91       	brne	80002bfe <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bee:	48 68       	lddpc	r8,80002c04 <phy_rx+0x30>
80002bf0:	70 0c       	ld.w	r12,r8[0x0]
80002bf2:	30 09       	mov	r9,0
80002bf4:	fa ca ff fc 	sub	r10,sp,-4
80002bf8:	1a 9b       	mov	r11,sp
80002bfa:	f0 1f 00 04 	mcall	80002c08 <phy_rx+0x34>
		}	

    }
		
 
}
80002bfe:	2f ed       	sub	sp,-8
80002c00:	d8 02       	popm	pc
80002c02:	00 00       	add	r0,r0
80002c04:	00 00       	add	r0,r0
80002c06:	0a b0       	st.h	r5++,r0
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	63 e8       	ld.w	r8,r1[0x78]

80002c0c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c0c:	eb cd 40 80 	pushm	r7,lr
80002c10:	20 1d       	sub	sp,4
80002c12:	fa c7 ff fc 	sub	r7,sp,-4
80002c16:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c18:	30 09       	mov	r9,0
80002c1a:	12 9a       	mov	r10,r9
80002c1c:	1a 9b       	mov	r11,sp
80002c1e:	f0 1f 00 03 	mcall	80002c28 <set_idle_store+0x1c>
}
80002c22:	2f fd       	sub	sp,-4
80002c24:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	64 38       	ld.w	r8,r2[0xc]

80002c2c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c2c:	d4 01       	pushm	lr
80002c2e:	20 1d       	sub	sp,4
80002c30:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c32:	98 88       	ld.uh	r8,r12[0x0]
80002c34:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c38:	e0 48 40 00 	cp.w	r8,16384
80002c3c:	c0 d1       	brne	80002c56 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c3e:	49 08       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c40:	70 08       	ld.w	r8,r8[0x0]
80002c42:	58 08       	cp.w	r8,0
80002c44:	c1 a0       	breq	80002c78 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c46:	48 e8       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c48:	70 0c       	ld.w	r12,r8[0x0]
80002c4a:	30 09       	mov	r9,0
80002c4c:	12 9a       	mov	r10,r9
80002c4e:	1a 9b       	mov	r11,sp
80002c50:	f0 1f 00 0c 	mcall	80002c80 <phy_tx+0x54>
80002c54:	c1 28       	rjmp	80002c78 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c56:	e0 48 10 00 	cp.w	r8,4096
80002c5a:	5f 0a       	sreq	r10
80002c5c:	e0 48 20 00 	cp.w	r8,8192
80002c60:	5f 09       	sreq	r9
80002c62:	f5 e9 10 09 	or	r9,r10,r9
80002c66:	c0 71       	brne	80002c74 <phy_tx+0x48>
80002c68:	e0 48 50 00 	cp.w	r8,20480
80002c6c:	c0 40       	breq	80002c74 <phy_tx+0x48>
80002c6e:	e0 48 60 00 	cp.w	r8,24576
80002c72:	c0 31       	brne	80002c78 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c74:	48 48       	lddpc	r8,80002c84 <phy_tx+0x58>
80002c76:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c78:	2f fd       	sub	sp,-4
80002c7a:	d8 02       	popm	pc
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a d0       	st.w	--r5,r0
80002c80:	80 00       	ld.sh	r0,r0[0x0]
80002c82:	64 38       	ld.w	r8,r2[0xc]
80002c84:	00 00       	add	r0,r0
80002c86:	0a c4       	st.b	r5++,r4

80002c88 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c88:	d4 01       	pushm	lr
80002c8a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c8c:	30 08       	mov	r8,0
80002c8e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c90:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c92:	1a 9a       	mov	r10,sp
80002c94:	fa cb ff fc 	sub	r11,sp,-4
80002c98:	f0 1f 00 05 	mcall	80002cac <get_idle_store_isr+0x24>
80002c9c:	58 1c       	cp.w	r12,1
80002c9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ca2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ca6:	2f ed       	sub	sp,-8
80002ca8:	d8 02       	popm	pc
80002caa:	00 00       	add	r0,r0
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	61 3c       	ld.w	r12,r0[0x4c]

80002cb0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80002cb4:	20 1d       	sub	sp,4
80002cb6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002cb8:	4b a8       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cba:	70 08       	ld.w	r8,r8[0x0]
80002cbc:	58 08       	cp.w	r8,0
80002cbe:	c6 60       	breq	80002d8a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002cc0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cc2:	30 08       	mov	r8,0
80002cc4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cc6:	4b 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002cc8:	70 08       	ld.w	r8,r8[0x0]
80002cca:	58 18       	cp.w	r8,1
80002ccc:	c2 60       	breq	80002d18 <phy_tx_func+0x68>
80002cce:	c0 43       	brcs	80002cd6 <phy_tx_func+0x26>
80002cd0:	58 28       	cp.w	r8,2
80002cd2:	c5 c1       	brne	80002d8a <phy_tx_func+0xda>
80002cd4:	c5 58       	rjmp	80002d7e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002cd6:	4b 38       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cd8:	70 0c       	ld.w	r12,r8[0x0]
80002cda:	1a 9a       	mov	r10,sp
80002cdc:	4b 3b       	lddpc	r11,80002da8 <phy_tx_func+0xf8>
80002cde:	f0 1f 00 34 	mcall	80002dac <phy_tx_func+0xfc>
80002ce2:	58 1c       	cp.w	r12,1
80002ce4:	c1 41       	brne	80002d0c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ce6:	4b 18       	lddpc	r8,80002da8 <phy_tx_func+0xf8>
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	90 08       	ld.sh	r8,r8[0x0]
80002cec:	10 9a       	mov	r10,r8
80002cee:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cf2:	4b 09       	lddpc	r9,80002db0 <phy_tx_func+0x100>
80002cf4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cf6:	5c 78       	castu.h	r8
80002cf8:	ea 18 ab cd 	orh	r8,0xabcd
80002cfc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cfe:	30 19       	mov	r9,1
80002d00:	4a d8       	lddpc	r8,80002db4 <phy_tx_func+0x104>
80002d02:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d04:	30 19       	mov	r9,1
80002d06:	4a 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d08:	91 09       	st.w	r8[0x0],r9
80002d0a:	c4 08       	rjmp	80002d8a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d0c:	e0 68 5a 5a 	mov	r8,23130
80002d10:	ea 18 ab cd 	orh	r8,0xabcd
80002d14:	8f 18       	st.w	r7[0x4],r8
80002d16:	c3 a8       	rjmp	80002d8a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d18:	4a 7a       	lddpc	r10,80002db4 <phy_tx_func+0x104>
80002d1a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d1c:	4a 39       	lddpc	r9,80002da8 <phy_tx_func+0xf8>
80002d1e:	72 09       	ld.w	r9,r9[0x0]
80002d20:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d24:	b1 69       	lsl	r9,0x10
80002d26:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d28:	2f f8       	sub	r8,-1
80002d2a:	5c 58       	castu.b	r8
80002d2c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d2e:	4a 1b       	lddpc	r11,80002db0 <phy_tx_func+0x100>
80002d30:	96 0c       	ld.sh	r12,r11[0x0]
80002d32:	20 2c       	sub	r12,2
80002d34:	5c 8c       	casts.h	r12
80002d36:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d3a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d3c:	30 0b       	mov	r11,0
80002d3e:	f6 0a 19 00 	cp.h	r10,r11
80002d42:	e0 89 00 09 	brgt	80002d54 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d46:	e8 19 00 ba 	orl	r9,0xba
80002d4a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d4c:	30 09       	mov	r9,0
80002d4e:	49 68       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d50:	91 09       	st.w	r8[0x0],r9
80002d52:	c1 c8       	rjmp	80002d8a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d54:	49 5a       	lddpc	r10,80002da8 <phy_tx_func+0xf8>
80002d56:	74 0a       	ld.w	r10,r10[0x0]
80002d58:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d5c:	14 49       	or	r9,r10
80002d5e:	8f 19       	st.w	r7[0x4],r9
80002d60:	2f f8       	sub	r8,-1
80002d62:	49 59       	lddpc	r9,80002db4 <phy_tx_func+0x104>
80002d64:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d66:	20 2c       	sub	r12,2
80002d68:	49 28       	lddpc	r8,80002db0 <phy_tx_func+0x100>
80002d6a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d6c:	30 08       	mov	r8,0
80002d6e:	f0 0c 19 00 	cp.h	r12,r8
80002d72:	e0 89 00 0c 	brgt	80002d8a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d76:	30 29       	mov	r9,2
80002d78:	48 b8       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d7a:	91 09       	st.w	r8[0x0],r9
80002d7c:	c0 78       	rjmp	80002d8a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d7e:	fc 18 00 ba 	movh	r8,0xba
80002d82:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d84:	30 09       	mov	r9,0
80002d86:	48 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d88:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d8a:	e0 68 5a 5a 	mov	r8,23130
80002d8e:	ea 18 ab cd 	orh	r8,0xabcd
80002d92:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d94:	30 08       	mov	r8,0
80002d96:	8f 38       	st.w	r7[0xc],r8
}
80002d98:	2f fd       	sub	sp,-4
80002d9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d9e:	00 00       	add	r0,r0
80002da0:	00 00       	add	r0,r0
80002da2:	0a d0       	st.w	--r5,r0
80002da4:	00 00       	add	r0,r0
80002da6:	0a 90       	mov	r0,r5
80002da8:	00 00       	add	r0,r0
80002daa:	0a 9c       	mov	r12,r5
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	61 3c       	ld.w	r12,r0[0x4c]
80002db0:	00 00       	add	r0,r0
80002db2:	0a b8       	st.h	r5++,r8
80002db4:	00 00       	add	r0,r0
80002db6:	0a 70       	tst	r0,r5

80002db8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002db8:	d4 01       	pushm	lr
80002dba:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002dbc:	30 0a       	mov	r10,0
80002dbe:	fa cb ff fc 	sub	r11,sp,-4
80002dc2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002dc4:	14 99       	mov	r9,r10
80002dc6:	1a 9b       	mov	r11,sp
80002dc8:	f0 1f 00 05 	mcall	80002ddc <get_idle_store+0x24>
80002dcc:	58 1c       	cp.w	r12,1
80002dce:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002dd2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002dd6:	2f fd       	sub	sp,-4
80002dd8:	d8 02       	popm	pc
80002dda:	00 00       	add	r0,r0
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	62 2c       	ld.w	r12,r1[0x8]

80002de0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002de0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002de2:	48 5b       	lddpc	r11,80002df4 <phy_init+0x14>
80002de4:	48 5c       	lddpc	r12,80002df8 <phy_init+0x18>
80002de6:	f0 1f 00 06 	mcall	80002dfc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dea:	f0 1f 00 06 	mcall	80002e00 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dee:	f0 1f 00 06 	mcall	80002e04 <phy_init+0x24>
	
}
80002df2:	d8 02       	popm	pc
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	2c b0       	sub	r0,-53
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2e 08       	sub	r8,-32
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	3e 68       	mov	r8,-26
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	3e 7c       	mov	r12,-25
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	48 28       	lddpc	r8,80002e0c <phy_rx_func+0x4>

80002e08 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e08:	eb cd 40 e0 	pushm	r5-r7,lr
80002e0c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e0e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e12:	70 08       	ld.w	r8,r8[0x0]
80002e14:	58 08       	cp.w	r8,0
80002e16:	e0 80 01 08 	breq	80003026 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e1a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e1c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e20:	70 09       	ld.w	r9,r8[0x0]
80002e22:	2f f9       	sub	r9,-1
80002e24:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e26:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e2a:	70 08       	ld.w	r8,r8[0x0]
80002e2c:	58 18       	cp.w	r8,1
80002e2e:	e0 80 00 85 	breq	80002f38 <phy_rx_func+0x130>
80002e32:	c0 73       	brcs	80002e40 <phy_rx_func+0x38>
80002e34:	58 28       	cp.w	r8,2
80002e36:	c5 c0       	breq	80002eee <phy_rx_func+0xe6>
80002e38:	58 38       	cp.w	r8,3
80002e3a:	e0 81 00 f6 	brne	80003026 <phy_rx_func+0x21e>
80002e3e:	cd 58       	rjmp	80002fe8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e40:	e0 6a 5a 5a 	mov	r10,23130
80002e44:	ea 1a ab cd 	orh	r10,0xabcd
80002e48:	14 36       	cp.w	r6,r10
80002e4a:	e0 80 00 ee 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e4e:	ec 08 16 10 	lsr	r8,r6,0x10
80002e52:	e0 48 ab cd 	cp.w	r8,43981
80002e56:	e0 81 00 e8 	brne	80003026 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e5a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e5e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e62:	20 28       	sub	r8,2
80002e64:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e68:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e6a:	30 09       	mov	r9,0
80002e6c:	f2 08 19 00 	cp.h	r8,r9
80002e70:	e0 8a 00 db 	brle	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e74:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e78:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e7a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e7e:	70 0c       	ld.w	r12,r8[0x0]
80002e80:	f0 1f 03 88 	mcall	80003ca0 <phy_rx_func+0xe98>
80002e84:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e88:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e8a:	58 0c       	cp.w	r12,0
80002e8c:	e0 80 00 cd 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e90:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e94:	90 09       	ld.sh	r9,r8[0x0]
80002e96:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e9a:	2f f9       	sub	r9,-1
80002e9c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e9e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002ea2:	74 0a       	ld.w	r10,r10[0x0]
80002ea4:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ea8:	76 0b       	ld.w	r11,r11[0x0]
80002eaa:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002eae:	2f f9       	sub	r9,-1
80002eb0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002eb2:	e2 16 0f 00 	andl	r6,0xf00,COH
80002eb6:	e0 46 01 00 	cp.w	r6,256
80002eba:	c0 c0       	breq	80002ed2 <phy_rx_func+0xca>
80002ebc:	e0 8b 00 05 	brhi	80002ec6 <phy_rx_func+0xbe>
80002ec0:	58 06       	cp.w	r6,0
80002ec2:	c0 80       	breq	80002ed2 <phy_rx_func+0xca>
80002ec4:	c0 c8       	rjmp	80002edc <phy_rx_func+0xd4>
80002ec6:	e0 46 02 00 	cp.w	r6,512
80002eca:	c0 40       	breq	80002ed2 <phy_rx_func+0xca>
80002ecc:	e0 46 03 00 	cp.w	r6,768
80002ed0:	c0 61       	brne	80002edc <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ed2:	30 29       	mov	r9,2
80002ed4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002ed8:	91 09       	st.w	r8[0x0],r9
80002eda:	ca 68       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002edc:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002ee0:	70 0c       	ld.w	r12,r8[0x0]
80002ee2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002ee6:	70 0b       	ld.w	r11,r8[0x0]
80002ee8:	f0 1f 03 70 	mcall	80003ca8 <phy_rx_func+0xea0>
80002eec:	c9 d8       	rjmp	80003026 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eee:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002ef2:	b1 86       	lsr	r6,0x10
80002ef4:	14 06       	add	r6,r10
80002ef6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002efa:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002efc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f00:	90 09       	ld.sh	r9,r8[0x0]
80002f02:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f06:	76 0b       	ld.w	r11,r11[0x0]
80002f08:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f0c:	2f f9       	sub	r9,-1
80002f0e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f10:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f14:	92 08       	ld.sh	r8,r9[0x0]
80002f16:	20 28       	sub	r8,2
80002f18:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f1a:	30 09       	mov	r9,0
80002f1c:	f2 08 19 00 	cp.h	r8,r9
80002f20:	e0 8a 00 07 	brle	80002f2e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f24:	30 19       	mov	r9,1
80002f26:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f2a:	91 09       	st.w	r8[0x0],r9
80002f2c:	c7 d8       	rjmp	80003026 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f2e:	30 39       	mov	r9,3
80002f30:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f34:	91 09       	st.w	r8[0x0],r9
80002f36:	c7 88       	rjmp	80003026 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f38:	ec 0a 14 10 	asr	r10,r6,0x10
80002f3c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f40:	90 09       	ld.sh	r9,r8[0x0]
80002f42:	14 09       	add	r9,r10
80002f44:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f46:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f4a:	92 08       	ld.sh	r8,r9[0x0]
80002f4c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f50:	76 0b       	ld.w	r11,r11[0x0]
80002f52:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f56:	2f f8       	sub	r8,-1
80002f58:	5c 88       	casts.h	r8
80002f5a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f5c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f60:	94 09       	ld.sh	r9,r10[0x0]
80002f62:	20 29       	sub	r9,2
80002f64:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f66:	30 0a       	mov	r10,0
80002f68:	f4 09 19 00 	cp.h	r9,r10
80002f6c:	e0 89 00 20 	brgt	80002fac <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f70:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f74:	e0 46 00 ba 	cp.w	r6,186
80002f78:	c0 d1       	brne	80002f92 <phy_rx_func+0x18a>
80002f7a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f7e:	90 09       	ld.sh	r9,r8[0x0]
80002f80:	f4 09 19 00 	cp.h	r9,r10
80002f84:	c0 71       	brne	80002f92 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f86:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f8a:	70 0c       	ld.w	r12,r8[0x0]
80002f8c:	f0 1f 03 49 	mcall	80003cb0 <phy_rx_func+0xea8>
80002f90:	c0 98       	rjmp	80002fa2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f92:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f96:	70 0c       	ld.w	r12,r8[0x0]
80002f98:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f9c:	70 0b       	ld.w	r11,r8[0x0]
80002f9e:	f0 1f 03 43 	mcall	80003ca8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002fa2:	30 09       	mov	r9,0
80002fa4:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002fa8:	91 09       	st.w	r8[0x0],r9
80002faa:	c3 e8       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002fac:	5c 86       	casts.h	r6
80002fae:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002fb2:	92 0a       	ld.sh	r10,r9[0x0]
80002fb4:	0c 0a       	add	r10,r6
80002fb6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fb8:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002fbc:	72 09       	ld.w	r9,r9[0x0]
80002fbe:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002fc2:	2f f8       	sub	r8,-1
80002fc4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002fc8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002fca:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002fce:	92 08       	ld.sh	r8,r9[0x0]
80002fd0:	20 28       	sub	r8,2
80002fd2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fd4:	30 09       	mov	r9,0
80002fd6:	f2 08 19 00 	cp.h	r8,r9
80002fda:	e0 89 00 26 	brgt	80003026 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fde:	30 39       	mov	r9,3
80002fe0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fe4:	91 09       	st.w	r8[0x0],r9
80002fe6:	c2 08       	rjmp	80003026 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fe8:	e6 16 00 ff 	andh	r6,0xff,COH
80002fec:	fc 19 00 ba 	movh	r9,0xba
80002ff0:	12 36       	cp.w	r6,r9
80002ff2:	c0 e1       	brne	8000300e <phy_rx_func+0x206>
80002ff4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ff8:	90 09       	ld.sh	r9,r8[0x0]
80002ffa:	30 08       	mov	r8,0
80002ffc:	f0 09 19 00 	cp.h	r9,r8
80003000:	c0 71       	brne	8000300e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003002:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003006:	70 0c       	ld.w	r12,r8[0x0]
80003008:	f0 1f 03 2a 	mcall	80003cb0 <phy_rx_func+0xea8>
8000300c:	c0 98       	rjmp	8000301e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000300e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003012:	70 0c       	ld.w	r12,r8[0x0]
80003014:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003018:	70 0b       	ld.w	r11,r8[0x0]
8000301a:	f0 1f 03 24 	mcall	80003ca8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000301e:	30 09       	mov	r9,0
80003020:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003024:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003026:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000302a:	11 89       	ld.ub	r9,r8[0x0]
8000302c:	30 08       	mov	r8,0
8000302e:	f0 09 18 00 	cp.b	r9,r8
80003032:	c1 31       	brne	80003058 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003034:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003038:	6c 0c       	ld.w	r12,r6[0x0]
8000303a:	f0 1f 03 1a 	mcall	80003ca0 <phy_rx_func+0xe98>
8000303e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003042:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003044:	6c 0c       	ld.w	r12,r6[0x0]
80003046:	f0 1f 03 17 	mcall	80003ca0 <phy_rx_func+0xe98>
8000304a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000304e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003050:	30 19       	mov	r9,1
80003052:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003056:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003058:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	58 28       	cp.w	r8,2
80003060:	e0 80 01 98 	breq	80003390 <phy_rx_func+0x588>
80003064:	e0 8b 00 06 	brhi	80003070 <phy_rx_func+0x268>
80003068:	58 08       	cp.w	r8,0
8000306a:	c0 b0       	breq	80003080 <phy_rx_func+0x278>
8000306c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003070:	58 38       	cp.w	r8,3
80003072:	e0 80 05 c5 	breq	80003bfc <phy_rx_func+0xdf4>
80003076:	58 48       	cp.w	r8,4
80003078:	e0 81 06 05 	brne	80003c82 <phy_rx_func+0xe7a>
8000307c:	e0 8f 02 4b 	bral	80003512 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003080:	6e 28       	ld.w	r8,r7[0x8]
80003082:	e0 6a 5a 5a 	mov	r10,23130
80003086:	ea 1a ab cd 	orh	r10,0xabcd
8000308a:	14 38       	cp.w	r8,r10
8000308c:	c0 71       	brne	8000309a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000308e:	30 09       	mov	r9,0
80003090:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003094:	91 09       	st.w	r8[0x0],r9
80003096:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000309a:	10 99       	mov	r9,r8
8000309c:	e0 19 00 00 	andl	r9,0x0
800030a0:	fc 1a ab cd 	movh	r10,0xabcd
800030a4:	14 39       	cp.w	r9,r10
800030a6:	e0 81 05 ee 	brne	80003c82 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800030aa:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800030ae:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800030b2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800030b4:	6e 29       	ld.w	r9,r7[0x8]
800030b6:	e2 19 f0 00 	andl	r9,0xf000,COH
800030ba:	e0 49 c0 00 	cp.w	r9,49152
800030be:	e0 81 00 ce 	brne	8000325a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800030c2:	30 1a       	mov	r10,1
800030c4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030c8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030ca:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030ce:	72 09       	ld.w	r9,r9[0x0]
800030d0:	58 09       	cp.w	r9,0
800030d2:	c0 71       	brne	800030e0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030d4:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030d8:	f0 1f 03 00 	mcall	80003cd8 <phy_rx_func+0xed0>
800030dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030e0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030e4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030e8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030ea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030ee:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030f2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030f6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030f8:	13 89       	ld.ub	r9,r9[0x0]
800030fa:	37 fa       	mov	r10,127
800030fc:	f4 09 18 00 	cp.b	r9,r10
80003100:	c6 d0       	breq	800031da <phy_rx_func+0x3d2>
80003102:	e0 8b 00 0c 	brhi	8000311a <phy_rx_func+0x312>
80003106:	31 2a       	mov	r10,18
80003108:	f4 09 18 00 	cp.b	r9,r10
8000310c:	c4 20       	breq	80003190 <phy_rx_func+0x388>
8000310e:	31 3a       	mov	r10,19
80003110:	f4 09 18 00 	cp.b	r9,r10
80003114:	e0 81 00 83 	brne	8000321a <phy_rx_func+0x412>
80003118:	c5 b8       	rjmp	800031ce <phy_rx_func+0x3c6>
8000311a:	2f 09       	sub	r9,-16
8000311c:	30 1a       	mov	r10,1
8000311e:	f4 09 18 00 	cp.b	r9,r10
80003122:	e0 8b 00 7c 	brhi	8000321a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003126:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000312a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000312e:	59 08       	cp.w	r8,16
80003130:	c0 71       	brne	8000313e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003132:	30 19       	mov	r9,1
80003134:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003138:	91 09       	st.w	r8[0x0],r9
8000313a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000313e:	e0 48 00 20 	cp.w	r8,32
80003142:	c2 11       	brne	80003184 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003144:	30 a9       	mov	r9,10
80003146:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000314a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000314c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003150:	6c 08       	ld.w	r8,r6[0x0]
80003152:	f0 0a 11 ff 	rsub	r10,r8,-1
80003156:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000315a:	2f f8       	sub	r8,-1
8000315c:	6e 0c       	ld.w	r12,r7[0x0]
8000315e:	f4 ca fe 00 	sub	r10,r10,-512
80003162:	30 0b       	mov	r11,0
80003164:	10 0c       	add	r12,r8
80003166:	f0 1f 02 e1 	mcall	80003ce8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000316a:	30 08       	mov	r8,0
8000316c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000316e:	6e 0c       	ld.w	r12,r7[0x0]
80003170:	f0 1f 02 df 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003174:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003178:	70 0c       	ld.w	r12,r8[0x0]
8000317a:	f0 1f 02 ca 	mcall	80003ca0 <phy_rx_func+0xe98>
8000317e:	8f 0c       	st.w	r7[0x0],r12
80003180:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003184:	30 09       	mov	r9,0
80003186:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003190:	20 48       	sub	r8,4
80003192:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003196:	93 08       	st.w	r9[0x0],r8
80003198:	58 08       	cp.w	r8,0
8000319a:	e0 80 05 74 	breq	80003c82 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000319e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800031a2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800031a6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800031aa:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800031ac:	8e 69       	ld.sh	r9,r7[0xc]
800031ae:	fe f8 0b 46 	ld.w	r8,pc[2886]
800031b2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800031b4:	8e 79       	ld.sh	r9,r7[0xe]
800031b6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800031b8:	f0 1f 02 d0 	mcall	80003cf8 <phy_rx_func+0xef0>
800031bc:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800031c0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800031c2:	30 49       	mov	r9,4
800031c4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031c8:	91 09       	st.w	r8[0x0],r9
800031ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031ce:	30 09       	mov	r9,0
800031d0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031d4:	91 09       	st.w	r8[0x0],r9
800031d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031da:	20 48       	sub	r8,4
800031dc:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031e0:	93 08       	st.w	r9[0x0],r8
800031e2:	58 08       	cp.w	r8,0
800031e4:	e0 80 05 4f 	breq	80003c82 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031e8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031ec:	70 09       	ld.w	r9,r8[0x0]
800031ee:	8e 7b       	ld.sh	r11,r7[0xe]
800031f0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031f4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031f8:	2f f9       	sub	r9,-1
800031fa:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031fc:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003200:	70 09       	ld.w	r9,r8[0x0]
80003202:	20 29       	sub	r9,2
80003204:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003206:	30 29       	mov	r9,2
80003208:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000320c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000320e:	30 39       	mov	r9,3
80003210:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000321a:	30 3a       	mov	r10,3
8000321c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003220:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003222:	6e 2a       	ld.w	r10,r7[0x8]
80003224:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003228:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000322a:	6e 3a       	ld.w	r10,r7[0xc]
8000322c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000322e:	59 48       	cp.w	r8,20
80003230:	c0 61       	brne	8000323c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003232:	31 89       	mov	r9,24
80003234:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	c0 a8       	rjmp	8000324e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000323c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003240:	70 08       	ld.w	r8,r8[0x0]
80003242:	59 08       	cp.w	r8,16
80003244:	c0 51       	brne	8000324e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003246:	31 09       	mov	r9,16
80003248:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000324c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000324e:	30 49       	mov	r9,4
80003250:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003254:	91 09       	st.w	r8[0x0],r9
80003256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000325a:	e0 49 10 00 	cp.w	r9,4096
8000325e:	5f 1a       	srne	r10
80003260:	e0 49 20 00 	cp.w	r9,8192
80003264:	5f 19       	srne	r9
80003266:	f5 e9 00 09 	and	r9,r10,r9
8000326a:	e0 81 05 0c 	brne	80003c82 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000326e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003272:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003274:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003278:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000327a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000327e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003280:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003284:	72 09       	ld.w	r9,r9[0x0]
80003286:	58 09       	cp.w	r9,0
80003288:	c0 71       	brne	80003296 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000328a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000328e:	f0 1f 02 93 	mcall	80003cd8 <phy_rx_func+0xed0>
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003296:	6e 2a       	ld.w	r10,r7[0x8]
80003298:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000329c:	58 1a       	cp.w	r10,1
8000329e:	e0 8b 00 4d 	brhi	80003338 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800032a2:	20 48       	sub	r8,4
800032a4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800032a8:	93 08       	st.w	r9[0x0],r8
800032aa:	58 08       	cp.w	r8,0
800032ac:	e0 80 04 eb 	breq	80003c82 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800032b0:	8e 68       	ld.sh	r8,r7[0xc]
800032b2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800032b6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800032ba:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800032bc:	30 09       	mov	r9,0
800032be:	f2 08 19 00 	cp.h	r8,r9
800032c2:	c0 70       	breq	800032d0 <phy_rx_func+0x4c8>
800032c4:	30 19       	mov	r9,1
800032c6:	f2 08 19 00 	cp.h	r8,r9
800032ca:	e0 81 04 dc 	brne	80003c82 <phy_rx_func+0xe7a>
800032ce:	c2 68       	rjmp	8000331a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032d0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032d4:	70 0a       	ld.w	r10,r8[0x0]
800032d6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032da:	72 09       	ld.w	r9,r9[0x0]
800032dc:	8e 7b       	ld.sh	r11,r7[0xe]
800032de:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032e2:	70 09       	ld.w	r9,r8[0x0]
800032e4:	2f f9       	sub	r9,-1
800032e6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e8:	e0 49 00 ff 	cp.w	r9,255
800032ec:	e0 88 00 11 	brls	8000330e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032f0:	30 09       	mov	r9,0
800032f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032f4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032f8:	6e 0c       	ld.w	r12,r7[0x0]
800032fa:	f0 1f 02 7d 	mcall	80003cec <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032fe:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003302:	70 0c       	ld.w	r12,r8[0x0]
80003304:	f0 1f 02 67 	mcall	80003ca0 <phy_rx_func+0xe98>
80003308:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000330a:	e0 80 04 bc 	breq	80003c82 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000330e:	30 29       	mov	r9,2
80003310:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003314:	91 09       	st.w	r8[0x0],r9
80003316:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000331a:	8e 79       	ld.sh	r9,r7[0xe]
8000331c:	30 38       	mov	r8,3
8000331e:	f0 09 19 00 	cp.h	r9,r8
80003322:	c0 51       	brne	8000332c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003324:	30 19       	mov	r9,1
80003326:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000332a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000332c:	30 29       	mov	r9,2
8000332e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003332:	91 09       	st.w	r8[0x0],r9
80003334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003338:	58 18       	cp.w	r8,1
8000333a:	e0 88 04 a4 	brls	80003c82 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000333e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003342:	70 0a       	ld.w	r10,r8[0x0]
80003344:	6e 3b       	ld.w	r11,r7[0xc]
80003346:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000334a:	70 09       	ld.w	r9,r8[0x0]
8000334c:	2f f9       	sub	r9,-1
8000334e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003350:	e0 49 00 ff 	cp.w	r9,255
80003354:	e0 88 00 11 	brls	80003376 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003358:	30 09       	mov	r9,0
8000335a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000335c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003360:	6e 0c       	ld.w	r12,r7[0x0]
80003362:	f0 1f 02 63 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003366:	fe f8 09 52 	ld.w	r8,pc[2386]
8000336a:	70 0c       	ld.w	r12,r8[0x0]
8000336c:	f0 1f 02 4d 	mcall	80003ca0 <phy_rx_func+0xe98>
80003370:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003372:	e0 80 04 88 	breq	80003c82 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003376:	fe f9 09 56 	ld.w	r9,pc[2390]
8000337a:	72 08       	ld.w	r8,r9[0x0]
8000337c:	20 28       	sub	r8,2
8000337e:	93 08       	st.w	r9[0x0],r8
80003380:	e0 80 04 81 	breq	80003c82 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003384:	30 29       	mov	r9,2
80003386:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000338a:	91 09       	st.w	r8[0x0],r9
8000338c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003390:	fe f8 09 84 	ld.w	r8,pc[2436]
80003394:	70 0a       	ld.w	r10,r8[0x0]
80003396:	fe f9 09 26 	ld.w	r9,pc[2342]
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	8e 4b       	ld.sh	r11,r7[0x8]
8000339e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800033a2:	70 09       	ld.w	r9,r8[0x0]
800033a4:	2f f9       	sub	r9,-1
800033a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a8:	e0 49 00 ff 	cp.w	r9,255
800033ac:	e0 88 00 16 	brls	800033d8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800033b0:	30 09       	mov	r9,0
800033b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033b4:	fe f6 09 08 	ld.w	r6,pc[2312]
800033b8:	6c 0c       	ld.w	r12,r6[0x0]
800033ba:	f0 1f 02 4d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033be:	fe f8 08 fa 	ld.w	r8,pc[2298]
800033c2:	70 0c       	ld.w	r12,r8[0x0]
800033c4:	f0 1f 02 37 	mcall	80003ca0 <phy_rx_func+0xe98>
800033c8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033ca:	c0 71       	brne	800033d8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033cc:	30 09       	mov	r9,0
800033ce:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033d2:	91 09       	st.w	r8[0x0],r9
800033d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033d8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033dc:	72 08       	ld.w	r8,r9[0x0]
800033de:	20 28       	sub	r8,2
800033e0:	93 08       	st.w	r9[0x0],r8
800033e2:	c0 71       	brne	800033f0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033e4:	30 09       	mov	r9,0
800033e6:	fe f8 08 de 	ld.w	r8,pc[2270]
800033ea:	91 09       	st.w	r8[0x0],r9
800033ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033f0:	fe f8 09 24 	ld.w	r8,pc[2340]
800033f4:	70 0a       	ld.w	r10,r8[0x0]
800033f6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033fa:	72 09       	ld.w	r9,r9[0x0]
800033fc:	8e 5b       	ld.sh	r11,r7[0xa]
800033fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003402:	70 09       	ld.w	r9,r8[0x0]
80003404:	2f f9       	sub	r9,-1
80003406:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003408:	e0 49 00 ff 	cp.w	r9,255
8000340c:	e0 88 00 16 	brls	80003438 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003410:	30 09       	mov	r9,0
80003412:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003414:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003418:	6c 0c       	ld.w	r12,r6[0x0]
8000341a:	f0 1f 02 35 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000341e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003422:	70 0c       	ld.w	r12,r8[0x0]
80003424:	f0 1f 02 1f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003428:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000342a:	c0 71       	brne	80003438 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000342c:	30 09       	mov	r9,0
8000342e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003438:	fe f9 08 94 	ld.w	r9,pc[2196]
8000343c:	72 08       	ld.w	r8,r9[0x0]
8000343e:	20 28       	sub	r8,2
80003440:	93 08       	st.w	r9[0x0],r8
80003442:	c0 71       	brne	80003450 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003444:	30 09       	mov	r9,0
80003446:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000344a:	91 09       	st.w	r8[0x0],r9
8000344c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003450:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003454:	70 0a       	ld.w	r10,r8[0x0]
80003456:	fe f9 08 66 	ld.w	r9,pc[2150]
8000345a:	72 09       	ld.w	r9,r9[0x0]
8000345c:	8e 6b       	ld.sh	r11,r7[0xc]
8000345e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003462:	70 09       	ld.w	r9,r8[0x0]
80003464:	2f f9       	sub	r9,-1
80003466:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003468:	e0 49 00 ff 	cp.w	r9,255
8000346c:	e0 88 00 16 	brls	80003498 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003470:	30 09       	mov	r9,0
80003472:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003474:	fe f6 08 48 	ld.w	r6,pc[2120]
80003478:	6c 0c       	ld.w	r12,r6[0x0]
8000347a:	f0 1f 02 1d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000347e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003482:	70 0c       	ld.w	r12,r8[0x0]
80003484:	f0 1f 02 07 	mcall	80003ca0 <phy_rx_func+0xe98>
80003488:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000348a:	c0 71       	brne	80003498 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000348c:	30 09       	mov	r9,0
8000348e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003492:	91 09       	st.w	r8[0x0],r9
80003494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003498:	fe f9 08 34 	ld.w	r9,pc[2100]
8000349c:	72 08       	ld.w	r8,r9[0x0]
8000349e:	20 28       	sub	r8,2
800034a0:	93 08       	st.w	r9[0x0],r8
800034a2:	c0 71       	brne	800034b0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800034a4:	30 09       	mov	r9,0
800034a6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800034aa:	91 09       	st.w	r8[0x0],r9
800034ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034b0:	fe f8 08 64 	ld.w	r8,pc[2148]
800034b4:	70 0a       	ld.w	r10,r8[0x0]
800034b6:	fe f9 08 06 	ld.w	r9,pc[2054]
800034ba:	72 09       	ld.w	r9,r9[0x0]
800034bc:	8e 7b       	ld.sh	r11,r7[0xe]
800034be:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034c2:	70 09       	ld.w	r9,r8[0x0]
800034c4:	2f f9       	sub	r9,-1
800034c6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034c8:	e0 49 00 ff 	cp.w	r9,255
800034cc:	e0 88 00 16 	brls	800034f8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034d0:	30 09       	mov	r9,0
800034d2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034d4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034d8:	6e 0c       	ld.w	r12,r7[0x0]
800034da:	f0 1f 02 05 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034de:	fe f8 07 da 	ld.w	r8,pc[2010]
800034e2:	70 0c       	ld.w	r12,r8[0x0]
800034e4:	f0 1f 01 ef 	mcall	80003ca0 <phy_rx_func+0xe98>
800034e8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034ea:	c0 71       	brne	800034f8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034ec:	30 09       	mov	r9,0
800034ee:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034f2:	91 09       	st.w	r8[0x0],r9
800034f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034f8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034fc:	72 08       	ld.w	r8,r9[0x0]
800034fe:	20 28       	sub	r8,2
80003500:	93 08       	st.w	r9[0x0],r8
80003502:	e0 81 03 c0 	brne	80003c82 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003506:	30 09       	mov	r9,0
80003508:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000350c:	91 09       	st.w	r8[0x0],r9
8000350e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003512:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003516:	11 89       	ld.ub	r9,r8[0x0]
80003518:	31 28       	mov	r8,18
8000351a:	f0 09 18 00 	cp.b	r9,r8
8000351e:	e0 81 01 4c 	brne	800037b6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003522:	ef 39 00 09 	ld.ub	r9,r7[9]
80003526:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000352a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000352c:	11 89       	ld.ub	r9,r8[0x0]
8000352e:	3f 28       	mov	r8,-14
80003530:	f0 09 18 00 	cp.b	r9,r8
80003534:	e0 81 01 3b 	brne	800037aa <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003538:	30 19       	mov	r9,1
8000353a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000353e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003540:	6e 29       	ld.w	r9,r7[0x8]
80003542:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003546:	fe f8 07 86 	ld.w	r8,pc[1926]
8000354a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000354c:	8e 59       	ld.sh	r9,r7[0xa]
8000354e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003552:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003554:	8e 69       	ld.sh	r9,r7[0xc]
80003556:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003558:	8e 79       	ld.sh	r9,r7[0xe]
8000355a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000355c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003560:	fe f9 07 60 	ld.w	r9,pc[1888]
80003564:	72 0a       	ld.w	r10,r9[0x0]
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000356c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003570:	70 09       	ld.w	r9,r8[0x0]
80003572:	2f f9       	sub	r9,-1
80003574:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003576:	e0 49 01 ff 	cp.w	r9,511
8000357a:	e0 88 00 16 	brls	800035a6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000357e:	30 09       	mov	r9,0
80003580:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003582:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003586:	6c 0c       	ld.w	r12,r6[0x0]
80003588:	f0 1f 01 d9 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000358c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003590:	70 0c       	ld.w	r12,r8[0x0]
80003592:	f0 1f 01 c4 	mcall	80003ca0 <phy_rx_func+0xe98>
80003596:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003598:	c0 71       	brne	800035a6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000359a:	30 09       	mov	r9,0
8000359c:	fe f8 07 28 	ld.w	r8,pc[1832]
800035a0:	91 09       	st.w	r8[0x0],r9
800035a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a6:	fe f9 07 26 	ld.w	r9,pc[1830]
800035aa:	72 08       	ld.w	r8,r9[0x0]
800035ac:	20 18       	sub	r8,1
800035ae:	93 08       	st.w	r9[0x0],r8
800035b0:	c0 71       	brne	800035be <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800035b2:	30 09       	mov	r9,0
800035b4:	fe f8 07 10 	ld.w	r8,pc[1808]
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035be:	fe f8 07 26 	ld.w	r8,pc[1830]
800035c2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800035c6:	72 0a       	ld.w	r10,r9[0x0]
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035ce:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035d2:	70 09       	ld.w	r9,r8[0x0]
800035d4:	2f f9       	sub	r9,-1
800035d6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035d8:	e0 49 01 ff 	cp.w	r9,511
800035dc:	e0 88 00 16 	brls	80003608 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035e0:	30 09       	mov	r9,0
800035e2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035e8:	6c 0c       	ld.w	r12,r6[0x0]
800035ea:	f0 1f 01 c1 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ee:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035f2:	70 0c       	ld.w	r12,r8[0x0]
800035f4:	f0 1f 01 ab 	mcall	80003ca0 <phy_rx_func+0xe98>
800035f8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035fa:	c0 71       	brne	80003608 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035fc:	30 09       	mov	r9,0
800035fe:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003602:	91 09       	st.w	r8[0x0],r9
80003604:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003608:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000360c:	72 08       	ld.w	r8,r9[0x0]
8000360e:	20 18       	sub	r8,1
80003610:	93 08       	st.w	r9[0x0],r8
80003612:	c0 71       	brne	80003620 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003614:	30 09       	mov	r9,0
80003616:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000361a:	91 09       	st.w	r8[0x0],r9
8000361c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003620:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003624:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003628:	72 0a       	ld.w	r10,r9[0x0]
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003630:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003634:	70 09       	ld.w	r9,r8[0x0]
80003636:	2f f9       	sub	r9,-1
80003638:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363a:	e0 49 01 ff 	cp.w	r9,511
8000363e:	e0 88 00 16 	brls	8000366a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003642:	30 09       	mov	r9,0
80003644:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003646:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000364a:	6c 0c       	ld.w	r12,r6[0x0]
8000364c:	f0 1f 01 a8 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003650:	fe f8 06 68 	ld.w	r8,pc[1640]
80003654:	70 0c       	ld.w	r12,r8[0x0]
80003656:	f0 1f 01 93 	mcall	80003ca0 <phy_rx_func+0xe98>
8000365a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000365c:	c0 71       	brne	8000366a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000365e:	30 09       	mov	r9,0
80003660:	fe f8 06 64 	ld.w	r8,pc[1636]
80003664:	91 09       	st.w	r8[0x0],r9
80003666:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000366a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000366e:	72 08       	ld.w	r8,r9[0x0]
80003670:	20 18       	sub	r8,1
80003672:	93 08       	st.w	r9[0x0],r8
80003674:	c0 71       	brne	80003682 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003676:	30 09       	mov	r9,0
80003678:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000367c:	91 09       	st.w	r8[0x0],r9
8000367e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003682:	fe f8 06 62 	ld.w	r8,pc[1634]
80003686:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000368a:	72 0a       	ld.w	r10,r9[0x0]
8000368c:	70 09       	ld.w	r9,r8[0x0]
8000368e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003692:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	2f f9       	sub	r9,-1
8000369a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000369c:	e0 49 01 ff 	cp.w	r9,511
800036a0:	e0 88 00 16 	brls	800036cc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800036a4:	30 09       	mov	r9,0
800036a6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036a8:	fe f6 06 18 	ld.w	r6,pc[1560]
800036ac:	6c 0c       	ld.w	r12,r6[0x0]
800036ae:	f0 1f 01 90 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036b2:	fe f8 06 06 	ld.w	r8,pc[1542]
800036b6:	70 0c       	ld.w	r12,r8[0x0]
800036b8:	f0 1f 01 7a 	mcall	80003ca0 <phy_rx_func+0xe98>
800036bc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036be:	c0 71       	brne	800036cc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800036c0:	30 09       	mov	r9,0
800036c2:	fe f8 06 02 	ld.w	r8,pc[1538]
800036c6:	91 09       	st.w	r8[0x0],r9
800036c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036cc:	fe f9 06 00 	ld.w	r9,pc[1536]
800036d0:	72 08       	ld.w	r8,r9[0x0]
800036d2:	20 18       	sub	r8,1
800036d4:	93 08       	st.w	r9[0x0],r8
800036d6:	c0 71       	brne	800036e4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036de:	91 09       	st.w	r8[0x0],r9
800036e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036e4:	fe f8 06 00 	ld.w	r8,pc[1536]
800036e8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036ec:	72 0a       	ld.w	r10,r9[0x0]
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036f4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	2f f9       	sub	r9,-1
800036fc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036fe:	e0 49 01 ff 	cp.w	r9,511
80003702:	e0 88 00 16 	brls	8000372e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003706:	30 09       	mov	r9,0
80003708:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000370a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000370e:	6c 0c       	ld.w	r12,r6[0x0]
80003710:	f0 1f 01 77 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003714:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003718:	70 0c       	ld.w	r12,r8[0x0]
8000371a:	f0 1f 01 62 	mcall	80003ca0 <phy_rx_func+0xe98>
8000371e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003720:	c0 71       	brne	8000372e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003722:	30 09       	mov	r9,0
80003724:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003728:	91 09       	st.w	r8[0x0],r9
8000372a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000372e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003732:	72 08       	ld.w	r8,r9[0x0]
80003734:	20 18       	sub	r8,1
80003736:	93 08       	st.w	r9[0x0],r8
80003738:	c0 71       	brne	80003746 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003746:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000374a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000374e:	72 0a       	ld.w	r10,r9[0x0]
80003750:	70 09       	ld.w	r9,r8[0x0]
80003752:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003756:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	2f f9       	sub	r9,-1
8000375e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003760:	e0 49 01 ff 	cp.w	r9,511
80003764:	e0 88 00 16 	brls	80003790 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003768:	30 09       	mov	r9,0
8000376a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000376c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003770:	6e 0c       	ld.w	r12,r7[0x0]
80003772:	f0 1f 01 5f 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003776:	fe f8 05 42 	ld.w	r8,pc[1346]
8000377a:	70 0c       	ld.w	r12,r8[0x0]
8000377c:	f0 1f 01 49 	mcall	80003ca0 <phy_rx_func+0xe98>
80003780:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003782:	c0 71       	brne	80003790 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003784:	30 09       	mov	r9,0
80003786:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000378a:	91 09       	st.w	r8[0x0],r9
8000378c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003790:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003794:	72 08       	ld.w	r8,r9[0x0]
80003796:	20 18       	sub	r8,1
80003798:	93 08       	st.w	r9[0x0],r8
8000379a:	e0 81 02 74 	brne	80003c82 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000379e:	30 09       	mov	r9,0
800037a0:	fe f8 05 24 	ld.w	r8,pc[1316]
800037a4:	91 09       	st.w	r8[0x0],r9
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037aa:	30 09       	mov	r9,0
800037ac:	fe f8 05 18 	ld.w	r8,pc[1304]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037b6:	fe f8 05 26 	ld.w	r8,pc[1318]
800037ba:	11 89       	ld.ub	r9,r8[0x0]
800037bc:	3f 28       	mov	r8,-14
800037be:	f0 09 18 00 	cp.b	r9,r8
800037c2:	c4 31       	brne	80003848 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037c4:	8e 49       	ld.sh	r9,r7[0x8]
800037c6:	fe f8 05 56 	ld.w	r8,pc[1366]
800037ca:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037cc:	fe f8 05 18 	ld.w	r8,pc[1304]
800037d0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037d4:	72 0a       	ld.w	r10,r9[0x0]
800037d6:	70 09       	ld.w	r9,r8[0x0]
800037d8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037e0:	70 09       	ld.w	r9,r8[0x0]
800037e2:	2f f9       	sub	r9,-1
800037e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037e6:	e0 49 01 ff 	cp.w	r9,511
800037ea:	e0 88 00 16 	brls	80003816 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ee:	30 09       	mov	r9,0
800037f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037f2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037f6:	6e 0c       	ld.w	r12,r7[0x0]
800037f8:	f0 1f 01 3d 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037fc:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003800:	70 0c       	ld.w	r12,r8[0x0]
80003802:	f0 1f 01 28 	mcall	80003ca0 <phy_rx_func+0xe98>
80003806:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003808:	c0 71       	brne	80003816 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000380a:	30 09       	mov	r9,0
8000380c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003816:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000381a:	72 08       	ld.w	r8,r9[0x0]
8000381c:	20 18       	sub	r8,1
8000381e:	93 08       	st.w	r9[0x0],r8
80003820:	c0 71       	brne	8000382e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003822:	30 09       	mov	r9,0
80003824:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003828:	91 09       	st.w	r8[0x0],r9
8000382a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000382e:	20 18       	sub	r8,1
80003830:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003834:	93 08       	st.w	r9[0x0],r8
80003836:	58 08       	cp.w	r8,0
80003838:	e0 81 02 25 	brne	80003c82 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000383c:	30 09       	mov	r9,0
8000383e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003842:	91 09       	st.w	r8[0x0],r9
80003844:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003848:	fe f8 04 94 	ld.w	r8,pc[1172]
8000384c:	11 89       	ld.ub	r9,r8[0x0]
8000384e:	3f 38       	mov	r8,-13
80003850:	f0 09 18 00 	cp.b	r9,r8
80003854:	e0 81 01 0c 	brne	80003a6c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003858:	8e 49       	ld.sh	r9,r7[0x8]
8000385a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000385e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003860:	8e 59       	ld.sh	r9,r7[0xa]
80003862:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003864:	8e 69       	ld.sh	r9,r7[0xc]
80003866:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003868:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000386c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003870:	72 0a       	ld.w	r10,r9[0x0]
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003878:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000387c:	70 09       	ld.w	r9,r8[0x0]
8000387e:	2f f9       	sub	r9,-1
80003880:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003882:	e0 49 01 ff 	cp.w	r9,511
80003886:	e0 88 00 16 	brls	800038b2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388a:	30 09       	mov	r9,0
8000388c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000388e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003892:	6c 0c       	ld.w	r12,r6[0x0]
80003894:	f0 1f 01 16 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003898:	fe f8 04 20 	ld.w	r8,pc[1056]
8000389c:	70 0c       	ld.w	r12,r8[0x0]
8000389e:	f0 1f 01 01 	mcall	80003ca0 <phy_rx_func+0xe98>
800038a2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800038a6:	30 09       	mov	r9,0
800038a8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800038ac:	91 09       	st.w	r8[0x0],r9
800038ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800038b6:	72 08       	ld.w	r8,r9[0x0]
800038b8:	20 18       	sub	r8,1
800038ba:	93 08       	st.w	r9[0x0],r8
800038bc:	c0 71       	brne	800038ca <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800038be:	30 09       	mov	r9,0
800038c0:	fe f8 04 04 	ld.w	r8,pc[1028]
800038c4:	91 09       	st.w	r8[0x0],r9
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038ca:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038ce:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038d2:	72 0a       	ld.w	r10,r9[0x0]
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038da:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038de:	70 09       	ld.w	r9,r8[0x0]
800038e0:	2f f9       	sub	r9,-1
800038e2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e4:	e0 49 01 ff 	cp.w	r9,511
800038e8:	e0 88 00 16 	brls	80003914 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ec:	30 09       	mov	r9,0
800038ee:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038f0:	fe f6 03 d0 	ld.w	r6,pc[976]
800038f4:	6c 0c       	ld.w	r12,r6[0x0]
800038f6:	f0 1f 00 fe 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038fa:	fe f8 03 be 	ld.w	r8,pc[958]
800038fe:	70 0c       	ld.w	r12,r8[0x0]
80003900:	f0 1f 00 e8 	mcall	80003ca0 <phy_rx_func+0xe98>
80003904:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003906:	c0 71       	brne	80003914 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003908:	30 09       	mov	r9,0
8000390a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000390e:	91 09       	st.w	r8[0x0],r9
80003910:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003914:	fe f9 03 b8 	ld.w	r9,pc[952]
80003918:	72 08       	ld.w	r8,r9[0x0]
8000391a:	20 18       	sub	r8,1
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	c0 71       	brne	8000392c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003920:	30 09       	mov	r9,0
80003922:	fe f8 03 a2 	ld.w	r8,pc[930]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000392c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003930:	fe f9 03 90 	ld.w	r9,pc[912]
80003934:	72 0a       	ld.w	r10,r9[0x0]
80003936:	70 09       	ld.w	r9,r8[0x0]
80003938:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000393c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003940:	70 09       	ld.w	r9,r8[0x0]
80003942:	2f f9       	sub	r9,-1
80003944:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003946:	e0 49 01 ff 	cp.w	r9,511
8000394a:	e0 88 00 16 	brls	80003976 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000394e:	30 09       	mov	r9,0
80003950:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003952:	fe f6 03 6e 	ld.w	r6,pc[878]
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 00 e5 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003960:	70 0c       	ld.w	r12,r8[0x0]
80003962:	f0 1f 00 d0 	mcall	80003ca0 <phy_rx_func+0xe98>
80003966:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003968:	c0 71       	brne	80003976 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000396a:	30 09       	mov	r9,0
8000396c:	fe f8 03 58 	ld.w	r8,pc[856]
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003976:	fe f9 03 56 	ld.w	r9,pc[854]
8000397a:	72 08       	ld.w	r8,r9[0x0]
8000397c:	20 18       	sub	r8,1
8000397e:	93 08       	st.w	r9[0x0],r8
80003980:	c0 71       	brne	8000398e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003982:	30 09       	mov	r9,0
80003984:	fe f8 03 40 	ld.w	r8,pc[832]
80003988:	91 09       	st.w	r8[0x0],r9
8000398a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000398e:	fe f8 03 56 	ld.w	r8,pc[854]
80003992:	fe f9 03 2e 	ld.w	r9,pc[814]
80003996:	72 0a       	ld.w	r10,r9[0x0]
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000399e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039a2:	70 09       	ld.w	r9,r8[0x0]
800039a4:	2f f9       	sub	r9,-1
800039a6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039a8:	e0 49 01 ff 	cp.w	r9,511
800039ac:	e0 88 00 16 	brls	800039d8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800039b0:	30 09       	mov	r9,0
800039b2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039b4:	fe f6 03 0c 	ld.w	r6,pc[780]
800039b8:	6c 0c       	ld.w	r12,r6[0x0]
800039ba:	f0 1f 00 cd 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039be:	fe f8 02 fa 	ld.w	r8,pc[762]
800039c2:	70 0c       	ld.w	r12,r8[0x0]
800039c4:	f0 1f 00 b7 	mcall	80003ca0 <phy_rx_func+0xe98>
800039c8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039cc:	30 09       	mov	r9,0
800039ce:	fe f8 02 f6 	ld.w	r8,pc[758]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039d8:	fe f9 02 f4 	ld.w	r9,pc[756]
800039dc:	72 08       	ld.w	r8,r9[0x0]
800039de:	20 18       	sub	r8,1
800039e0:	93 08       	st.w	r9[0x0],r8
800039e2:	c0 71       	brne	800039f0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039e4:	30 09       	mov	r9,0
800039e6:	fe f8 02 de 	ld.w	r8,pc[734]
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039f0:	fe f8 02 f4 	ld.w	r8,pc[756]
800039f4:	fe f9 02 cc 	ld.w	r9,pc[716]
800039f8:	72 0a       	ld.w	r10,r9[0x0]
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a00:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a04:	70 09       	ld.w	r9,r8[0x0]
80003a06:	2f f9       	sub	r9,-1
80003a08:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a0a:	e0 49 01 ff 	cp.w	r9,511
80003a0e:	e0 88 00 16 	brls	80003a3a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a12:	30 09       	mov	r9,0
80003a14:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a16:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a1a:	6e 0c       	ld.w	r12,r7[0x0]
80003a1c:	f0 1f 00 b4 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a20:	fe f8 02 98 	ld.w	r8,pc[664]
80003a24:	70 0c       	ld.w	r12,r8[0x0]
80003a26:	f0 1f 00 9f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003a2a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a2c:	c0 71       	brne	80003a3a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a2e:	30 09       	mov	r9,0
80003a30:	fe f8 02 94 	ld.w	r8,pc[660]
80003a34:	91 09       	st.w	r8[0x0],r9
80003a36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a3a:	fe f9 02 92 	ld.w	r9,pc[658]
80003a3e:	72 08       	ld.w	r8,r9[0x0]
80003a40:	20 18       	sub	r8,1
80003a42:	93 08       	st.w	r9[0x0],r8
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a4c:	91 09       	st.w	r8[0x0],r9
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a52:	20 18       	sub	r8,1
80003a54:	fe f9 02 78 	ld.w	r9,pc[632]
80003a58:	93 08       	st.w	r9[0x0],r8
80003a5a:	58 08       	cp.w	r8,0
80003a5c:	e0 81 01 13 	brne	80003c82 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a60:	30 09       	mov	r9,0
80003a62:	fe f8 02 62 	ld.w	r8,pc[610]
80003a66:	91 09       	st.w	r8[0x0],r9
80003a68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a6c:	fe f8 02 70 	ld.w	r8,pc[624]
80003a70:	11 89       	ld.ub	r9,r8[0x0]
80003a72:	30 48       	mov	r8,4
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	c0 80       	breq	80003a88 <phy_rx_func+0xc80>
80003a7a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a7e:	11 89       	ld.ub	r9,r8[0x0]
80003a80:	30 38       	mov	r8,3
80003a82:	f0 09 18 00 	cp.b	r9,r8
80003a86:	c1 41       	brne	80003aae <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a88:	6e 29       	ld.w	r9,r7[0x8]
80003a8a:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a8e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a90:	6e 39       	ld.w	r9,r7[0xc]
80003a92:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a94:	fe f9 02 38 	ld.w	r9,pc[568]
80003a98:	72 08       	ld.w	r8,r9[0x0]
80003a9a:	20 88       	sub	r8,8
80003a9c:	93 08       	st.w	r9[0x0],r8
80003a9e:	e0 81 00 f2 	brne	80003c82 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003aa2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003aa4:	fe f9 02 20 	ld.w	r9,pc[544]
80003aa8:	93 08       	st.w	r9[0x0],r8
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003aae:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ab2:	11 89       	ld.ub	r9,r8[0x0]
80003ab4:	31 38       	mov	r8,19
80003ab6:	f0 09 18 00 	cp.b	r9,r8
80003aba:	e0 81 00 9c 	brne	80003bf2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003abe:	fe f8 02 62 	ld.w	r8,pc[610]
80003ac2:	11 88       	ld.ub	r8,r8[0x0]
80003ac4:	30 c9       	mov	r9,12
80003ac6:	f2 08 18 00 	cp.b	r8,r9
80003aca:	e0 81 00 7b 	brne	80003bc0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003ace:	8e 49       	ld.sh	r9,r7[0x8]
80003ad0:	fe f8 02 54 	ld.w	r8,pc[596]
80003ad4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ad8:	30 09       	mov	r9,0
80003ada:	fe f8 02 46 	ld.w	r8,pc[582]
80003ade:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ae0:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ae4:	3f 38       	mov	r8,-13
80003ae6:	f0 09 18 00 	cp.b	r9,r8
80003aea:	c6 61       	brne	80003bb6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003aec:	10 99       	mov	r9,r8
80003aee:	4f c8       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003af0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003af2:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003af6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003afa:	4f 58       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003afc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003afe:	30 19       	mov	r9,1
80003b00:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b04:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b06:	8e 79       	ld.sh	r9,r7[0xe]
80003b08:	fe f8 02 14 	ld.w	r8,pc[532]
80003b0c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b0e:	4f 68       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b10:	4e c9       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b12:	72 0a       	ld.w	r10,r9[0x0]
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b1a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b1e:	70 09       	ld.w	r9,r8[0x0]
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b24:	e0 49 01 ff 	cp.w	r9,511
80003b28:	e0 88 00 13 	brls	80003b4e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2c:	30 09       	mov	r9,0
80003b2e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b30:	4e 46       	lddpc	r6,80003cc0 <phy_rx_func+0xeb8>
80003b32:	6c 0c       	ld.w	r12,r6[0x0]
80003b34:	f0 1f 00 6e 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b38:	4e 08       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b3a:	70 0c       	ld.w	r12,r8[0x0]
80003b3c:	f0 1f 00 59 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b40:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b42:	c0 61       	brne	80003b4e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b44:	30 09       	mov	r9,0
80003b46:	4e 08       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b48:	91 09       	st.w	r8[0x0],r9
80003b4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b4e:	4e 09       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003b50:	72 08       	ld.w	r8,r9[0x0]
80003b52:	20 18       	sub	r8,1
80003b54:	93 08       	st.w	r9[0x0],r8
80003b56:	c0 61       	brne	80003b62 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b58:	30 09       	mov	r9,0
80003b5a:	4d b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b62:	4e 18       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b64:	4d 79       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b66:	72 0a       	ld.w	r10,r9[0x0]
80003b68:	70 09       	ld.w	r9,r8[0x0]
80003b6a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b6e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b72:	70 09       	ld.w	r9,r8[0x0]
80003b74:	2f f9       	sub	r9,-1
80003b76:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b78:	e0 49 01 ff 	cp.w	r9,511
80003b7c:	e0 88 00 13 	brls	80003ba2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b80:	30 09       	mov	r9,0
80003b82:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b84:	4c f7       	lddpc	r7,80003cc0 <phy_rx_func+0xeb8>
80003b86:	6e 0c       	ld.w	r12,r7[0x0]
80003b88:	f0 1f 00 59 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b8c:	4c b8       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b8e:	70 0c       	ld.w	r12,r8[0x0]
80003b90:	f0 1f 00 44 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b94:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b96:	c0 61       	brne	80003ba2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b98:	30 09       	mov	r9,0
80003b9a:	4c b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b9c:	91 09       	st.w	r8[0x0],r9
80003b9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003ba2:	4c b9       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003ba4:	72 08       	ld.w	r8,r9[0x0]
80003ba6:	20 18       	sub	r8,1
80003ba8:	93 08       	st.w	r9[0x0],r8
80003baa:	c6 c1       	brne	80003c82 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003bac:	30 09       	mov	r9,0
80003bae:	4c 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bb0:	91 09       	st.w	r8[0x0],r9
80003bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003bb6:	30 09       	mov	r9,0
80003bb8:	4c 38       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bba:	91 09       	st.w	r8[0x0],r9
80003bbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003bc0:	8e 4a       	ld.sh	r10,r7[0x8]
80003bc2:	4d 99       	lddpc	r9,80003d24 <phy_rx_func+0xf1c>
80003bc4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bc8:	4d 6a       	lddpc	r10,80003d20 <phy_rx_func+0xf18>
80003bca:	15 88       	ld.ub	r8,r10[0x0]
80003bcc:	f0 cb ff ff 	sub	r11,r8,-1
80003bd0:	8e 5c       	ld.sh	r12,r7[0xa]
80003bd2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bd6:	f0 cb ff fe 	sub	r11,r8,-2
80003bda:	8e 6c       	ld.sh	r12,r7[0xc]
80003bdc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003be0:	f0 cb ff fd 	sub	r11,r8,-3
80003be4:	8e 7c       	ld.sh	r12,r7[0xe]
80003be6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bea:	2f c8       	sub	r8,-4
80003bec:	b4 88       	st.b	r10[0x0],r8
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bf2:	30 09       	mov	r9,0
80003bf4:	4b 48       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bf6:	91 09       	st.w	r8[0x0],r9
80003bf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bfc:	4c 08       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003bfe:	70 09       	ld.w	r9,r8[0x0]
80003c00:	8e 4b       	ld.sh	r11,r7[0x8]
80003c02:	4c 0a       	lddpc	r10,80003d00 <phy_rx_func+0xef8>
80003c04:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c08:	2f f9       	sub	r9,-1
80003c0a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c0c:	4b 58       	lddpc	r8,80003ce0 <phy_rx_func+0xed8>
80003c0e:	70 09       	ld.w	r9,r8[0x0]
80003c10:	20 29       	sub	r9,2
80003c12:	91 09       	st.w	r8[0x0],r9
80003c14:	70 08       	ld.w	r8,r8[0x0]
80003c16:	58 08       	cp.w	r8,0
80003c18:	c2 f1       	brne	80003c76 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c1a:	30 09       	mov	r9,0
80003c1c:	4b 88       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003c1e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c20:	8e 59       	ld.sh	r9,r7[0xa]
80003c22:	fe 78 82 12 	mov	r8,-32238
80003c26:	f0 09 19 00 	cp.h	r9,r8
80003c2a:	c2 11       	brne	80003c6c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c2c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c30:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c34:	4a f8       	lddpc	r8,80003cf0 <phy_rx_func+0xee8>
80003c36:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c38:	8e 59       	ld.sh	r9,r7[0xa]
80003c3a:	4a f8       	lddpc	r8,80003cf4 <phy_rx_func+0xeec>
80003c3c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c3e:	8e 69       	ld.sh	r9,r7[0xc]
80003c40:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c42:	f0 1f 00 2e 	mcall	80003cf8 <phy_rx_func+0xef0>
80003c46:	4a 18       	lddpc	r8,80003cc8 <phy_rx_func+0xec0>
80003c48:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c4a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c4e:	31 38       	mov	r8,19
80003c50:	f0 09 18 00 	cp.b	r9,r8
80003c54:	c0 71       	brne	80003c62 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c56:	10 99       	mov	r9,r8
80003c58:	4a 18       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003c5a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c5c:	30 09       	mov	r9,0
80003c5e:	49 c8       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003c60:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c62:	30 49       	mov	r9,4
80003c64:	49 88       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c6c:	30 09       	mov	r9,0
80003c6e:	49 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c70:	91 09       	st.w	r8[0x0],r9
80003c72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c76:	4a dc       	lddpc	r12,80003d28 <phy_rx_func+0xf20>
80003c78:	f0 1f 00 18 	mcall	80003cd8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c7c:	30 09       	mov	r9,0
80003c7e:	49 28       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c80:	91 09       	st.w	r8[0x0],r9
80003c82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c86:	00 00       	add	r0,r0
80003c88:	00 00       	add	r0,r0
80003c8a:	0a b0       	st.h	r5++,r0
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a c8       	st.b	r5++,r8
80003c90:	00 00       	add	r0,r0
80003c92:	0a a8       	st.w	r5++,r8
80003c94:	00 00       	add	r0,r0
80003c96:	0a 8a       	andn	r10,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 78       	tst	r8,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a a0       	st.w	r5++,r0
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	2c 88       	sub	r8,-56
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 98       	mov	r8,r5
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	2b a0       	sub	r0,-70
80003cac:	00 00       	add	r0,r0
80003cae:	0a ac       	st.w	r5++,r12
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	2b d4       	sub	r4,-67
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 89       	andn	r9,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0a a4       	st.w	r5++,r4
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a b4       	st.h	r5++,r4
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 8c       	andn	r12,r5
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a d4       	st.w	--r5,r4
80003cc8:	00 00       	add	r0,r0
80003cca:	0a bc       	st.h	r5++,r12
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 74       	tst	r4,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 4f       	or	pc,r5
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	d7 a4       	*unknown*
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	71 fc       	ld.w	r12,r8[0x7c]
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 88       	andn	r8,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a e0       	st.h	--r5,r0
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a c0       	st.b	r5++,r0
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	7a 3c       	ld.w	r12,sp[0xc]
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	2b bc       	sub	r12,-69
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 4a       	or	r10,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	21 34       	sub	r4,19
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	2b 70       	sub	r0,-73
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a 7c       	tst	r12,r5
80003d00:	00 00       	add	r0,r0
80003d02:	20 38       	sub	r8,3
80003d04:	00 00       	add	r0,r0
80003d06:	0a 80       	andn	r0,r5
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 4b       	or	r11,r5
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a 49       	or	r9,r5
80003d10:	00 00       	add	r0,r0
80003d12:	0a d8       	st.w	--r5,r8
80003d14:	00 00       	add	r0,r0
80003d16:	0a 94       	mov	r4,r5
80003d18:	00 00       	add	r0,r0
80003d1a:	0a 60       	and	r0,r5
80003d1c:	00 00       	add	r0,r0
80003d1e:	20 30       	sub	r0,3
80003d20:	00 00       	add	r0,r0
80003d22:	0a cc       	st.b	r5++,r12
80003d24:	00 00       	add	r0,r0
80003d26:	21 38       	sub	r8,19
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	d7 bc       	*unknown*

80003d2c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d2c:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003d2e:	30 09       	mov	r9,0
80003d30:	49 b8       	lddpc	r8,80003d9c <pdca_int_handler+0x70>
80003d32:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d34:	49 b8       	lddpc	r8,80003da0 <pdca_int_handler+0x74>
80003d36:	70 09       	ld.w	r9,r8[0x0]
80003d38:	2f f9       	sub	r9,-1
80003d3a:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d3c:	49 a8       	lddpc	r8,80003da4 <pdca_int_handler+0x78>
80003d3e:	11 89       	ld.ub	r9,r8[0x0]
80003d40:	ec 19 00 01 	eorl	r9,0x1
80003d44:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d46:	11 89       	ld.ub	r9,r8[0x0]
80003d48:	a5 69       	lsl	r9,0x4
80003d4a:	2f c9       	sub	r9,-4
80003d4c:	49 7a       	lddpc	r10,80003da8 <pdca_int_handler+0x7c>
80003d4e:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d50:	fe 7a 00 40 	mov	r10,-65472
80003d54:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d56:	30 39       	mov	r9,3
80003d58:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d5a:	11 8a       	ld.ub	r10,r8[0x0]
80003d5c:	a5 6a       	lsl	r10,0x4
80003d5e:	2f ca       	sub	r10,-4
80003d60:	49 38       	lddpc	r8,80003dac <pdca_int_handler+0x80>
80003d62:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d64:	fe 78 00 00 	mov	r8,-65536
80003d68:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d6a:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d6c:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d6e:	49 18       	lddpc	r8,80003db0 <pdca_int_handler+0x84>
80003d70:	70 08       	ld.w	r8,r8[0x0]
80003d72:	58 08       	cp.w	r8,0
80003d74:	c0 70       	breq	80003d82 <pdca_int_handler+0x56>
80003d76:	48 c9       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d78:	13 89       	ld.ub	r9,r9[0x0]
80003d7a:	a5 69       	lsl	r9,0x4
80003d7c:	48 cc       	lddpc	r12,80003dac <pdca_int_handler+0x80>
80003d7e:	12 0c       	add	r12,r9
80003d80:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d82:	48 d8       	lddpc	r8,80003db4 <pdca_int_handler+0x88>
80003d84:	70 08       	ld.w	r8,r8[0x0]
80003d86:	58 08       	cp.w	r8,0
80003d88:	c0 70       	breq	80003d96 <pdca_int_handler+0x6a>
80003d8a:	48 79       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d8c:	13 89       	ld.ub	r9,r9[0x0]
80003d8e:	a5 69       	lsl	r9,0x4
80003d90:	48 6c       	lddpc	r12,80003da8 <pdca_int_handler+0x7c>
80003d92:	12 0c       	add	r12,r9
80003d94:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d96:	d4 02       	popm	lr
80003d98:	d6 03       	rete
80003d9a:	00 00       	add	r0,r0
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a e8       	st.h	--r5,r8
80003da0:	00 00       	add	r0,r0
80003da2:	0a ec       	st.h	--r5,r12
80003da4:	00 00       	add	r0,r0
80003da6:	53 58       	stdsp	sp[0xd4],r8
80003da8:	00 00       	add	r0,r0
80003daa:	53 80       	stdsp	sp[0xe0],r0
80003dac:	00 00       	add	r0,r0
80003dae:	53 60       	stdsp	sp[0xd8],r0
80003db0:	00 00       	add	r0,r0
80003db2:	0a e4       	st.h	--r5,r4
80003db4:	00 00       	add	r0,r0
80003db6:	0a f0       	st.b	--r5,r0

80003db8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003db8:	fe 78 10 00 	mov	r8,-61440
80003dbc:	e0 69 0d c0 	mov	r9,3520
80003dc0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003dc4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003dc8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003dcc:	fe 78 34 00 	mov	r8,-52224
80003dd0:	e0 69 80 00 	mov	r9,32768
80003dd4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dd6:	30 09       	mov	r9,0
80003dd8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003dda:	e0 69 04 21 	mov	r9,1057
80003dde:	ea 19 3f 20 	orh	r9,0x3f20
80003de2:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003de4:	e0 69 02 9f 	mov	r9,671
80003de8:	ea 19 01 00 	orh	r9,0x100
80003dec:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003dee:	e0 6a 04 02 	mov	r10,1026
80003df2:	ea 1a 3f 20 	orh	r10,0x3f20
80003df6:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003df8:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dfa:	5e fc       	retal	r12

80003dfc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dfc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dfe:	30 19       	mov	r9,1
80003e00:	49 78       	lddpc	r8,80003e5c <local_start_PDC+0x60>
80003e02:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e04:	fe 78 00 00 	mov	r8,-65536
80003e08:	30 7b       	mov	r11,7
80003e0a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e0c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e0e:	49 59       	lddpc	r9,80003e60 <local_start_PDC+0x64>
80003e10:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e14:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e16:	30 3a       	mov	r10,3
80003e18:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e1a:	30 1c       	mov	r12,1
80003e1c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e1e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e20:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e22:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e24:	30 2c       	mov	r12,2
80003e26:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e28:	48 f9       	lddpc	r9,80003e64 <local_start_PDC+0x68>
80003e2a:	e0 68 5a 5a 	mov	r8,23130
80003e2e:	ea 18 ab cd 	orh	r8,0xabcd
80003e32:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e34:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e36:	30 0e       	mov	lr,0
80003e38:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e3a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e3c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e3e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e40:	fe 78 00 40 	mov	r8,-65472
80003e44:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e46:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e48:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e4c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e4e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e50:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e52:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e54:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e56:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e58:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e5a:	d8 02       	popm	pc
80003e5c:	00 00       	add	r0,r0
80003e5e:	53 58       	stdsp	sp[0xd4],r8
80003e60:	00 00       	add	r0,r0
80003e62:	53 60       	stdsp	sp[0xd8],r0
80003e64:	00 00       	add	r0,r0
80003e66:	53 80       	stdsp	sp[0xe0],r0

80003e68 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e68:	48 38       	lddpc	r8,80003e74 <register_rx_tx_func+0xc>
80003e6a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e6c:	48 38       	lddpc	r8,80003e78 <register_rx_tx_func+0x10>
80003e6e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e70:	5e fc       	retal	r12
80003e72:	00 00       	add	r0,r0
80003e74:	00 00       	add	r0,r0
80003e76:	0a e4       	st.h	--r5,r4
80003e78:	00 00       	add	r0,r0
80003e7a:	0a f0       	st.b	--r5,r0

80003e7c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e7c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e7e:	fe 78 10 00 	mov	r8,-61440
80003e82:	30 29       	mov	r9,2
80003e84:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e88:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e8c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e8e:	30 3a       	mov	r10,3
80003e90:	36 0b       	mov	r11,96
80003e92:	49 4c       	lddpc	r12,80003ee0 <ssc_init+0x64>
80003e94:	f0 1f 00 14 	mcall	80003ee4 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e98:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e9a:	fe 79 10 00 	mov	r9,-61440
80003e9e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ea2:	e2 18 00 02 	andl	r8,0x2,COH
80003ea6:	cf c0       	breq	80003e9e <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ea8:	fe 79 10 00 	mov	r9,-61440
80003eac:	f2 f8 01 60 	ld.w	r8,r9[352]
80003eb0:	e2 18 00 02 	andl	r8,0x2,COH
80003eb4:	cf c1       	brne	80003eac <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003eb6:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003eb8:	f0 1f 00 0c 	mcall	80003ee8 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ebc:	f0 1f 00 0c 	mcall	80003eec <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec0:	fe 79 00 00 	mov	r9,-65536
80003ec4:	30 18       	mov	r8,1
80003ec6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec8:	fe 7a 00 40 	mov	r10,-65472
80003ecc:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ece:	e0 6b 01 01 	mov	r11,257
80003ed2:	fe 7a 34 00 	mov	r10,-52224
80003ed6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ed8:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003eda:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3d 2c       	mov	r12,-46
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	54 d8       	stdsp	sp[0x134],r8
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	3d b8       	mov	r8,-37
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	3d fc       	mov	r12,-33

80003ef0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ef0:	48 28       	lddpc	r8,80003ef8 <xcmp_register_app_list+0x8>
80003ef2:	91 0c       	st.w	r8[0x0],r12
}
80003ef4:	5e fc       	retal	r12
80003ef6:	00 00       	add	r0,r0
80003ef8:	00 00       	add	r0,r0
80003efa:	53 a0       	stdsp	sp[0xe8],r0

80003efc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003efc:	eb cd 40 80 	pushm	r7,lr
80003f00:	fa cd 01 00 	sub	sp,sp,256
80003f04:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f06:	16 98       	mov	r8,r11
80003f08:	2f 08       	sub	r8,-16
80003f0a:	af a8       	sbr	r8,0xe
80003f0c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f0e:	3f f8       	mov	r8,-1
80003f10:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f12:	30 b9       	mov	r9,11
80003f14:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f16:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f18:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f1a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f1c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f1e:	f6 ca ff fe 	sub	r10,r11,-2
80003f22:	18 9b       	mov	r11,r12
80003f24:	fa cc ff f0 	sub	r12,sp,-16
80003f28:	f0 1f 00 05 	mcall	80003f3c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f2c:	2f e7       	sub	r7,-2
80003f2e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f30:	1a 9c       	mov	r12,sp
80003f32:	f0 1f 00 04 	mcall	80003f40 <xcmp_tx+0x44>
}
80003f36:	2c 0d       	sub	sp,-256
80003f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	78 f4       	ld.w	r4,r12[0x3c]
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	45 08       	lddsp	r8,sp[0x140]

80003f44 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f44:	d4 21       	pushm	r4-r7,lr
80003f46:	fa cd 00 d0 	sub	sp,sp,208
80003f4a:	18 94       	mov	r4,r12
80003f4c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f4e:	e0 68 01 00 	mov	r8,256
80003f52:	f0 0b 19 00 	cp.h	r11,r8
80003f56:	e0 8b 00 36 	brhi	80003fc2 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f5a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f5e:	e0 68 04 1d 	mov	r8,1053
80003f62:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f64:	30 18       	mov	r8,1
80003f66:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f68:	32 08       	mov	r8,32
80003f6a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f6c:	30 28       	mov	r8,2
80003f6e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f70:	30 48       	mov	r8,4
80003f72:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f74:	ea 1a 0c 00 	orh	r10,0xc00
80003f78:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f7a:	30 4a       	mov	r10,4
80003f7c:	1a 9b       	mov	r11,sp
80003f7e:	fa cc ff f4 	sub	r12,sp,-12
80003f82:	f0 1f 00 12 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f86:	30 f8       	mov	r8,15
80003f88:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f8c:	3a 78       	mov	r8,-89
80003f8e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f92:	30 08       	mov	r8,0
80003f94:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f98:	0e 9a       	mov	r10,r7
80003f9a:	5c 7a       	castu.h	r10
80003f9c:	f4 08 16 08 	lsr	r8,r10,0x8
80003fa0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003fa4:	0e 96       	mov	r6,r7
80003fa6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003faa:	08 9b       	mov	r11,r4
80003fac:	fa cc ff eb 	sub	r12,sp,-21
80003fb0:	f0 1f 00 06 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003fb4:	ee cb ff f3 	sub	r11,r7,-13
80003fb8:	5c 5b       	castu.b	r11
80003fba:	fa cc ff fa 	sub	r12,sp,-6
80003fbe:	f0 1f 00 04 	mcall	80003fcc <xcmp_data_session_req+0x88>
}
80003fc2:	2c cd       	sub	sp,-208
80003fc4:	d8 22       	popm	r4-r7,pc
80003fc6:	00 00       	add	r0,r0
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	78 f4       	ld.w	r4,r12[0x3c]
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e fc       	mov	r12,-17

80003fd0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fd0:	d4 01       	pushm	lr
80003fd2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fd6:	fe 78 b4 00 	mov	r8,-19456
80003fda:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fdc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fe0:	30 89       	mov	r9,8
80003fe2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fe4:	30 19       	mov	r9,1
80003fe6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fe8:	30 09       	mov	r9,0
80003fea:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fec:	30 5a       	mov	r10,5
80003fee:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003ff0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003ff2:	30 7a       	mov	r10,7
80003ff4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ff6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ff8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ffa:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ffe:	30 9b       	mov	r11,9
80004000:	fa cc ff fe 	sub	r12,sp,-2
80004004:	f0 1f 00 02 	mcall	8000400c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004008:	2c dd       	sub	sp,-204
8000400a:	d8 02       	popm	pc
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3e fc       	mov	r12,-17

80004010 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004010:	d4 01       	pushm	lr
80004012:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004016:	fe 78 80 00 	mov	r8,-32768
8000401a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000401c:	30 38       	mov	r8,3
8000401e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004020:	30 1b       	mov	r11,1
80004022:	fa cc ff fe 	sub	r12,sp,-2
80004026:	f0 1f 00 03 	mcall	80004030 <xcmp_opcode_not_supported+0x20>
}
8000402a:	2c dd       	sub	sp,-204
8000402c:	d8 02       	popm	pc
8000402e:	00 00       	add	r0,r0
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	3e fc       	mov	r12,-17

80004034 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004034:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004036:	96 88       	ld.uh	r8,r11[0x0]
80004038:	e2 18 f0 00 	andl	r8,0xf000,COH
8000403c:	e0 48 80 00 	cp.w	r8,32768
80004040:	c0 f0       	breq	8000405e <xcmp_exec_func+0x2a>
80004042:	e0 48 b0 00 	cp.w	r8,45056
80004046:	c1 20       	breq	8000406a <xcmp_exec_func+0x36>
80004048:	58 08       	cp.w	r8,0
8000404a:	c1 51       	brne	80004074 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000404c:	78 08       	ld.w	r8,r12[0x0]
8000404e:	58 08       	cp.w	r8,0
80004050:	c0 40       	breq	80004058 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004052:	16 9c       	mov	r12,r11
80004054:	5d 18       	icall	r8
80004056:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004058:	f0 1f 00 08 	mcall	80004078 <xcmp_exec_func+0x44>
8000405c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000405e:	78 18       	ld.w	r8,r12[0x4]
80004060:	58 08       	cp.w	r8,0
80004062:	c0 90       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004064:	16 9c       	mov	r12,r11
80004066:	5d 18       	icall	r8
80004068:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000406a:	78 28       	ld.w	r8,r12[0x8]
8000406c:	58 08       	cp.w	r8,0
8000406e:	c0 30       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004070:	16 9c       	mov	r12,r11
80004072:	5d 18       	icall	r8
80004074:	d8 02       	popm	pc
80004076:	00 00       	add	r0,r0
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	40 10       	lddsp	r0,sp[0x4]

8000407c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000407c:	d4 01       	pushm	lr
8000407e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004082:	e0 68 04 09 	mov	r8,1033
80004086:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004088:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000408c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000408e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004092:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004094:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004096:	30 09       	mov	r9,0
80004098:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000409a:	fb 69 00 08 	st.b	sp[8],r9
8000409e:	fa c8 ff f7 	sub	r8,sp,-9
800040a2:	b0 89       	st.b	r8[0x0],r9
800040a4:	fa c8 ff f6 	sub	r8,sp,-10
800040a8:	b0 89       	st.b	r8[0x0],r9
800040aa:	fa c8 ff f5 	sub	r8,sp,-11
800040ae:	b0 89       	st.b	r8[0x0],r9
800040b0:	fa c8 ff f4 	sub	r8,sp,-12
800040b4:	b0 89       	st.b	r8[0x0],r9
800040b6:	fa c8 ff f3 	sub	r8,sp,-13
800040ba:	b0 89       	st.b	r8[0x0],r9
800040bc:	fa c8 ff f2 	sub	r8,sp,-14
800040c0:	b0 89       	st.b	r8[0x0],r9
800040c2:	fa c8 ff f1 	sub	r8,sp,-15
800040c6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040c8:	30 cb       	mov	r11,12
800040ca:	fa cc ff fe 	sub	r12,sp,-2
800040ce:	f0 1f 00 03 	mcall	800040d8 <xcmp_IdleTestTone+0x5c>
}
800040d2:	2c dd       	sub	sp,-204
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e fc       	mov	r12,-17

800040dc <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040dc:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040de:	48 dc       	lddpc	r12,80004110 <xcmp_init+0x34>
800040e0:	f0 1f 00 0d 	mcall	80004114 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040e4:	30 4b       	mov	r11,4
800040e6:	31 4c       	mov	r12,20
800040e8:	f0 1f 00 0c 	mcall	80004118 <xcmp_init+0x3c>
800040ec:	48 c8       	lddpc	r8,8000411c <xcmp_init+0x40>
800040ee:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040f0:	30 09       	mov	r9,0
800040f2:	1a d9       	st.w	--sp,r9
800040f4:	1a d9       	st.w	--sp,r9
800040f6:	1a d9       	st.w	--sp,r9
800040f8:	30 38       	mov	r8,3
800040fa:	e0 6a 04 00 	mov	r10,1024
800040fe:	48 9b       	lddpc	r11,80004120 <xcmp_init+0x44>
80004100:	48 9c       	lddpc	r12,80004124 <xcmp_init+0x48>
80004102:	f0 1f 00 0a 	mcall	80004128 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004106:	f0 1f 00 0a 	mcall	8000412c <xcmp_init+0x50>
8000410a:	2f dd       	sub	sp,-12
	
}
8000410c:	d8 02       	popm	pc
8000410e:	00 00       	add	r0,r0
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	42 2c       	lddsp	r12,sp[0x88]
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	42 78       	lddsp	r8,sp[0x9c]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	65 90       	ld.w	r0,r2[0x64]
8000411c:	00 00       	add	r0,r0
8000411e:	0b 0c       	ld.w	r12,r5++
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	d7 e8       	*unknown*
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	41 30       	lddsp	r0,sp[0x4c]
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	6c ac       	ld.w	r12,r6[0x28]
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	42 b0       	lddsp	r0,sp[0xac]

80004130 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004130:	d4 31       	pushm	r0-r7,lr
80004132:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004134:	4b 16       	lddpc	r6,800041f8 <xcmp_rx_process+0xc8>
80004136:	30 05       	mov	r5,0
80004138:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000413a:	4b 13       	lddpc	r3,800041fc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000413c:	4b 12       	lddpc	r2,80004200 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000413e:	4b 21       	lddpc	r1,80004204 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004140:	4b 20       	lddpc	r0,80004208 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004142:	6c 0c       	ld.w	r12,r6[0x0]
80004144:	0a 99       	mov	r9,r5
80004146:	08 9a       	mov	r10,r4
80004148:	1a 9b       	mov	r11,sp
8000414a:	f0 1f 00 31 	mcall	8000420c <xcmp_rx_process+0xdc>
8000414e:	58 1c       	cp.w	r12,1
80004150:	cf 91       	brne	80004142 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004152:	40 0b       	lddsp	r11,sp[0x0]
80004154:	58 0b       	cp.w	r11,0
80004156:	cf 60       	breq	80004142 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004158:	96 0a       	ld.sh	r10,r11[0x0]
8000415a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000415e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004162:	59 c8       	cp.w	r8,28
80004164:	c1 e0       	breq	800041a0 <xcmp_rx_process+0x70>
80004166:	e0 89 00 07 	brgt	80004174 <xcmp_rx_process+0x44>
8000416a:	58 e8       	cp.w	r8,14
8000416c:	c0 e0       	breq	80004188 <xcmp_rx_process+0x58>
8000416e:	58 f8       	cp.w	r8,15
80004170:	c2 41       	brne	800041b8 <xcmp_rx_process+0x88>
80004172:	c0 f8       	rjmp	80004190 <xcmp_rx_process+0x60>
80004174:	e0 48 01 09 	cp.w	r8,265
80004178:	c1 80       	breq	800041a8 <xcmp_rx_process+0x78>
8000417a:	e0 48 01 0a 	cp.w	r8,266
8000417e:	c1 90       	breq	800041b0 <xcmp_rx_process+0x80>
80004180:	e0 48 00 2c 	cp.w	r8,44
80004184:	c1 a1       	brne	800041b8 <xcmp_rx_process+0x88>
80004186:	c0 98       	rjmp	80004198 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004188:	4a 2c       	lddpc	r12,80004210 <xcmp_rx_process+0xe0>
8000418a:	f0 1f 00 23 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000418e:	c2 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004190:	4a 2c       	lddpc	r12,80004218 <xcmp_rx_process+0xe8>
80004192:	f0 1f 00 21 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
80004196:	c2 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004198:	4a 1c       	lddpc	r12,8000421c <xcmp_rx_process+0xec>
8000419a:	f0 1f 00 1f 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000419e:	c2 78       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041a0:	04 9c       	mov	r12,r2
800041a2:	f0 1f 00 1d 	mcall	80004214 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041a6:	c2 38       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041a8:	02 9c       	mov	r12,r1
800041aa:	f0 1f 00 1b 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041ae:	c1 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041b0:	00 9c       	mov	r12,r0
800041b2:	f0 1f 00 19 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041b6:	c1 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041b8:	12 98       	mov	r8,r9
800041ba:	e2 18 04 00 	andl	r8,0x400,COH
800041be:	c0 70       	breq	800041cc <xcmp_rx_process+0x9c>
800041c0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041c4:	e0 48 00 68 	cp.w	r8,104
800041c8:	e0 8a 00 08 	brle	800041d8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041cc:	e2 19 f0 00 	andl	r9,0xf000,COH
800041d0:	c0 e1       	brne	800041ec <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041d2:	f0 1f 00 14 	mcall	80004220 <xcmp_rx_process+0xf0>
800041d6:	c0 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041d8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041dc:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041e0:	49 19       	lddpc	r9,80004224 <xcmp_rx_process+0xf4>
800041e2:	72 08       	ld.w	r8,r9[0x0]
800041e4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041e8:	f0 1f 00 0b 	mcall	80004214 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041ec:	66 0c       	ld.w	r12,r3[0x0]
800041ee:	40 0b       	lddsp	r11,sp[0x0]
800041f0:	f0 1f 00 0e 	mcall	80004228 <xcmp_rx_process+0xf8>
800041f4:	ca 7b       	rjmp	80004142 <xcmp_rx_process+0x12>
800041f6:	00 00       	add	r0,r0
800041f8:	00 00       	add	r0,r0
800041fa:	0b 0c       	ld.w	r12,r5++
800041fc:	00 00       	add	r0,r0
800041fe:	0a a0       	st.w	r5++,r0
80004200:	00 00       	add	r0,r0
80004202:	0b 1c       	ld.sh	r12,r5++
80004204:	00 00       	add	r0,r0
80004206:	0b 10       	ld.sh	r0,r5++
80004208:	00 00       	add	r0,r0
8000420a:	0b 00       	ld.w	r0,r5++
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	62 2c       	ld.w	r12,r1[0x8]
80004210:	00 00       	add	r0,r0
80004212:	0b 34       	ld.ub	r4,r5++
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	40 34       	lddsp	r4,sp[0xc]
80004218:	00 00       	add	r0,r0
8000421a:	0a f4       	st.b	--r5,r4
8000421c:	00 00       	add	r0,r0
8000421e:	0b 28       	ld.uh	r8,r5++
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	40 10       	lddsp	r0,sp[0x4]
80004224:	00 00       	add	r0,r0
80004226:	53 a0       	stdsp	sp[0xe8],r0
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	2c 0c       	sub	r12,-64

8000422c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000422c:	eb cd 40 90 	pushm	r4,r7,lr
80004230:	20 1d       	sub	sp,4
80004232:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004236:	48 c8       	lddpc	r8,80004264 <xcmp_rx+0x38>
80004238:	70 0c       	ld.w	r12,r8[0x0]
8000423a:	f0 1f 00 0c 	mcall	80004268 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000423e:	c1 00       	breq	8000425e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004240:	fa c7 ff fc 	sub	r7,sp,-4
80004244:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004246:	e0 6a 00 ca 	mov	r10,202
8000424a:	08 9b       	mov	r11,r4
8000424c:	f0 1f 00 08 	mcall	8000426c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004250:	48 88       	lddpc	r8,80004270 <xcmp_rx+0x44>
80004252:	70 0c       	ld.w	r12,r8[0x0]
80004254:	30 09       	mov	r9,0
80004256:	12 9a       	mov	r10,r9
80004258:	1a 9b       	mov	r11,sp
8000425a:	f0 1f 00 07 	mcall	80004274 <xcmp_rx+0x48>
	}	
}
8000425e:	2f fd       	sub	sp,-4
80004260:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004264:	00 00       	add	r0,r0
80004266:	0a a0       	st.w	r5++,r0
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	2d b8       	sub	r8,-37
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	78 f4       	ld.w	r4,r12[0x3c]
80004270:	00 00       	add	r0,r0
80004272:	0b 0c       	ld.w	r12,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	64 38       	ld.w	r8,r2[0xc]

80004278 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004278:	48 28       	lddpc	r8,80004280 <xnl_register_xcmp_func+0x8>
8000427a:	91 0c       	st.w	r8[0x0],r12
}
8000427c:	5e fc       	retal	r12
8000427e:	00 00       	add	r0,r0
80004280:	00 00       	add	r0,r0
80004282:	0b 60       	ld.uh	r0,--r5

80004284 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004284:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004286:	48 88       	lddpc	r8,800042a4 <xnl_get_msg_ack_func+0x20>
80004288:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000428a:	98 49       	ld.sh	r9,r12[0x8]
8000428c:	f0 09 19 00 	cp.h	r9,r8
80004290:	c0 81       	brne	800042a0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004292:	48 68       	lddpc	r8,800042a8 <xnl_get_msg_ack_func+0x24>
80004294:	70 0c       	ld.w	r12,r8[0x0]
80004296:	30 09       	mov	r9,0
80004298:	12 9a       	mov	r10,r9
8000429a:	12 9b       	mov	r11,r9
8000429c:	f0 1f 00 04 	mcall	800042ac <xnl_get_msg_ack_func+0x28>
800042a0:	d8 02       	popm	pc
800042a2:	00 00       	add	r0,r0
800042a4:	00 00       	add	r0,r0
800042a6:	0b 46       	ld.w	r6,--r5
800042a8:	00 00       	add	r0,r0
800042aa:	0b 40       	ld.w	r0,--r5
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	64 38       	ld.w	r8,r2[0xc]

800042b0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042b0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800042b4:	30 09       	mov	r9,0
800042b6:	4b 78       	lddpc	r8,80004390 <xnl_init+0xe0>
800042b8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042ba:	30 0b       	mov	r11,0
800042bc:	30 1c       	mov	r12,1
800042be:	f0 1f 00 36 	mcall	80004394 <xnl_init+0xe4>
800042c2:	4b 68       	lddpc	r8,80004398 <xnl_init+0xe8>
800042c4:	91 0c       	st.w	r8[0x0],r12
800042c6:	70 08       	ld.w	r8,r8[0x0]
800042c8:	58 08       	cp.w	r8,0
800042ca:	c0 80       	breq	800042da <xnl_init+0x2a>
800042cc:	4b 38       	lddpc	r8,80004398 <xnl_init+0xe8>
800042ce:	70 0c       	ld.w	r12,r8[0x0]
800042d0:	30 09       	mov	r9,0
800042d2:	12 9a       	mov	r10,r9
800042d4:	12 9b       	mov	r11,r9
800042d6:	f0 1f 00 32 	mcall	8000439c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042da:	30 4b       	mov	r11,4
800042dc:	31 4c       	mov	r12,20
800042de:	f0 1f 00 2e 	mcall	80004394 <xnl_init+0xe4>
800042e2:	4b 08       	lddpc	r8,800043a0 <xnl_init+0xf0>
800042e4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042e6:	30 4b       	mov	r11,4
800042e8:	31 ec       	mov	r12,30
800042ea:	f0 1f 00 2b 	mcall	80004394 <xnl_init+0xe4>
800042ee:	4a e8       	lddpc	r8,800043a4 <xnl_init+0xf4>
800042f0:	91 0c       	st.w	r8[0x0],r12
800042f2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042f4:	10 96       	mov	r6,r8
800042f6:	4a d5       	lddpc	r5,800043a8 <xnl_init+0xf8>
800042f8:	6c 0c       	ld.w	r12,r6[0x0]
800042fa:	ea 07 00 0b 	add	r11,r5,r7
800042fe:	f0 1f 00 2c 	mcall	800043ac <xnl_init+0xfc>
80004302:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004306:	e0 47 1e 00 	cp.w	r7,7680
8000430a:	cf 71       	brne	800042f8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000430c:	30 4b       	mov	r11,4
8000430e:	31 4c       	mov	r12,20
80004310:	f0 1f 00 21 	mcall	80004394 <xnl_init+0xe4>
80004314:	4a 78       	lddpc	r8,800043b0 <xnl_init+0x100>
80004316:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004318:	30 4b       	mov	r11,4
8000431a:	30 ac       	mov	r12,10
8000431c:	f0 1f 00 1e 	mcall	80004394 <xnl_init+0xe4>
80004320:	4a 58       	lddpc	r8,800043b4 <xnl_init+0x104>
80004322:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004324:	30 4b       	mov	r11,4
80004326:	30 ac       	mov	r12,10
80004328:	f0 1f 00 1b 	mcall	80004394 <xnl_init+0xe4>
8000432c:	4a 38       	lddpc	r8,800043b8 <xnl_init+0x108>
8000432e:	91 0c       	st.w	r8[0x0],r12
80004330:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004332:	10 96       	mov	r6,r8
80004334:	4a 25       	lddpc	r5,800043bc <xnl_init+0x10c>
80004336:	6c 0c       	ld.w	r12,r6[0x0]
80004338:	ea 07 00 0b 	add	r11,r5,r7
8000433c:	f0 1f 00 1c 	mcall	800043ac <xnl_init+0xfc>
80004340:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004344:	e0 47 14 00 	cp.w	r7,5120
80004348:	cf 71       	brne	80004336 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000434a:	30 4b       	mov	r11,4
8000434c:	30 5c       	mov	r12,5
8000434e:	f0 1f 00 12 	mcall	80004394 <xnl_init+0xe4>
80004352:	49 c8       	lddpc	r8,800043c0 <xnl_init+0x110>
80004354:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004356:	30 07       	mov	r7,0
80004358:	1a d7       	st.w	--sp,r7
8000435a:	1a d7       	st.w	--sp,r7
8000435c:	1a d7       	st.w	--sp,r7
8000435e:	30 38       	mov	r8,3
80004360:	0e 99       	mov	r9,r7
80004362:	e0 6a 00 dc 	mov	r10,220
80004366:	49 8b       	lddpc	r11,800043c4 <xnl_init+0x114>
80004368:	49 8c       	lddpc	r12,800043c8 <xnl_init+0x118>
8000436a:	f0 1f 00 19 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000436e:	1a d7       	st.w	--sp,r7
80004370:	1a d7       	st.w	--sp,r7
80004372:	1a d7       	st.w	--sp,r7
80004374:	30 38       	mov	r8,3
80004376:	0e 99       	mov	r9,r7
80004378:	e0 6a 00 82 	mov	r10,130
8000437c:	49 5b       	lddpc	r11,800043d0 <xnl_init+0x120>
8000437e:	49 6c       	lddpc	r12,800043d4 <xnl_init+0x124>
80004380:	f0 1f 00 13 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004384:	f0 1f 00 15 	mcall	800043d8 <xnl_init+0x128>
80004388:	2f ad       	sub	sp,-24
}
8000438a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000438e:	00 00       	add	r0,r0
80004390:	00 00       	add	r0,r0
80004392:	0b 46       	ld.w	r6,--r5
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	65 90       	ld.w	r0,r2[0x64]
80004398:	00 00       	add	r0,r0
8000439a:	0b 40       	ld.w	r0,--r5
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	64 38       	ld.w	r8,r2[0xc]
800043a0:	00 00       	add	r0,r0
800043a2:	0b 54       	ld.sh	r4,--r5
800043a4:	00 00       	add	r0,r0
800043a6:	0a a0       	st.w	r5++,r0
800043a8:	00 00       	add	r0,r0
800043aa:	35 52       	mov	r2,85
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	2c 0c       	sub	r12,-64
800043b0:	00 00       	add	r0,r0
800043b2:	0a d0       	st.w	--r5,r0
800043b4:	00 00       	add	r0,r0
800043b6:	0a b0       	st.h	r5++,r0
800043b8:	00 00       	add	r0,r0
800043ba:	0a a4       	st.w	r5++,r4
800043bc:	00 00       	add	r0,r0
800043be:	21 52       	sub	r2,21
800043c0:	00 00       	add	r0,r0
800043c2:	0a dc       	st.w	--r5,r12
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	d7 f0       	acall	0x7f
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	43 dc       	lddsp	r12,sp[0xf4]
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	6c ac       	ld.w	r12,r6[0x28]
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	d7 f8       	*unknown*
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	44 3c       	lddsp	r12,sp[0x10c]
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	2d e0       	sub	r0,-34

800043dc <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043dc:	eb cd 40 fe 	pushm	r1-r7,lr
800043e0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043e2:	49 26       	lddpc	r6,80004428 <xnl_rx_process+0x4c>
800043e4:	30 05       	mov	r5,0
800043e6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043e8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ea:	49 11       	lddpc	r1,8000442c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043ec:	49 12       	lddpc	r2,80004430 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043ee:	6c 0c       	ld.w	r12,r6[0x0]
800043f0:	0a 99       	mov	r9,r5
800043f2:	08 9a       	mov	r10,r4
800043f4:	1a 9b       	mov	r11,sp
800043f6:	f0 1f 00 10 	mcall	80004434 <xnl_rx_process+0x58>
800043fa:	58 1c       	cp.w	r12,1
800043fc:	cf 91       	brne	800043ee <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043fe:	40 0c       	lddsp	r12,sp[0x0]
80004400:	58 0c       	cp.w	r12,0
80004402:	cf 60       	breq	800043ee <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004404:	98 28       	ld.sh	r8,r12[0x4]
80004406:	e6 08 19 00 	cp.h	r8,r3
8000440a:	e0 8b 00 0a 	brhi	8000441e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000440e:	5c 78       	castu.h	r8
80004410:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004414:	58 09       	cp.w	r9,0
80004416:	c0 40       	breq	8000441e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004418:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000441c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000441e:	62 0c       	ld.w	r12,r1[0x0]
80004420:	40 0b       	lddsp	r11,sp[0x0]
80004422:	f0 1f 00 06 	mcall	80004438 <xnl_rx_process+0x5c>
80004426:	ce 4b       	rjmp	800043ee <xnl_rx_process+0x12>
80004428:	00 00       	add	r0,r0
8000442a:	0a b0       	st.h	r5++,r0
8000442c:	00 00       	add	r0,r0
8000442e:	0a a0       	st.w	r5++,r0
80004430:	00 00       	add	r0,r0
80004432:	04 f8       	st.b	--r2,r8
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	62 2c       	ld.w	r12,r1[0x8]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	2c 0c       	sub	r12,-64

8000443c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000443c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000443e:	4a a6       	lddpc	r6,800044e4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004440:	4a a2       	lddpc	r2,800044e8 <xnl_tx_process+0xac>
80004442:	4a b4       	lddpc	r4,800044ec <xnl_tx_process+0xb0>
80004444:	30 07       	mov	r7,0
80004446:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004448:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000444a:	4a a5       	lddpc	r5,800044f0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000444c:	4a a3       	lddpc	r3,800044f4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000444e:	6c 08       	ld.w	r8,r6[0x0]
80004450:	58 08       	cp.w	r8,0
80004452:	c0 40       	breq	8000445a <xnl_tx_process+0x1e>
80004454:	58 18       	cp.w	r8,1
80004456:	cf d1       	brne	80004450 <xnl_tx_process+0x14>
80004458:	c2 48       	rjmp	800044a0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000445a:	64 0c       	ld.w	r12,r2[0x0]
8000445c:	0e 99       	mov	r9,r7
8000445e:	02 9a       	mov	r10,r1
80004460:	08 9b       	mov	r11,r4
80004462:	f0 1f 00 26 	mcall	800044f8 <xnl_tx_process+0xbc>
80004466:	58 1c       	cp.w	r12,1
80004468:	cf 31       	brne	8000444e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000446a:	68 0b       	ld.w	r11,r4[0x0]
8000446c:	58 0b       	cp.w	r11,0
8000446e:	cf 00       	breq	8000444e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004470:	96 28       	ld.sh	r8,r11[0x4]
80004472:	e0 08 19 00 	cp.h	r8,r0
80004476:	c0 71       	brne	80004484 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004478:	4a 18       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
8000447a:	70 08       	ld.w	r8,r8[0x0]
8000447c:	10 9c       	mov	r12,r8
8000447e:	f0 1f 00 21 	mcall	80004500 <xnl_tx_process+0xc4>
						break;
80004482:	ce 6b       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004484:	16 9c       	mov	r12,r11
80004486:	f0 1f 00 20 	mcall	80004504 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000448a:	30 18       	mov	r8,1
8000448c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000448e:	66 0c       	ld.w	r12,r3[0x0]
80004490:	0e 99       	mov	r9,r7
80004492:	0e 9a       	mov	r10,r7
80004494:	0e 9b       	mov	r11,r7
80004496:	f0 1f 00 19 	mcall	800044f8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000449a:	30 18       	mov	r8,1
8000449c:	8d 08       	st.w	r6[0x0],r8
8000449e:	cd 8b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044a0:	66 0c       	ld.w	r12,r3[0x0]
800044a2:	0e 99       	mov	r9,r7
800044a4:	36 4a       	mov	r10,100
800044a6:	0e 9b       	mov	r11,r7
800044a8:	f0 1f 00 14 	mcall	800044f8 <xnl_tx_process+0xbc>
800044ac:	58 1c       	cp.w	r12,1
800044ae:	c0 81       	brne	800044be <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800044b0:	49 38       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044b2:	70 0c       	ld.w	r12,r8[0x0]
800044b4:	68 0b       	ld.w	r11,r4[0x0]
800044b6:	f0 1f 00 13 	mcall	80004500 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800044ba:	8d 07       	st.w	r6[0x0],r7
800044bc:	cc 9b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800044be:	6a 08       	ld.w	r8,r5[0x0]
800044c0:	58 38       	cp.w	r8,3
800044c2:	e0 89 00 09 	brgt	800044d4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800044c6:	68 0c       	ld.w	r12,r4[0x0]
800044c8:	f0 1f 00 0f 	mcall	80004504 <xnl_tx_process+0xc8>
						xnl_send_times++;
800044cc:	6a 08       	ld.w	r8,r5[0x0]
800044ce:	2f f8       	sub	r8,-1
800044d0:	8b 08       	st.w	r5[0x0],r8
800044d2:	cb eb       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044d4:	48 a8       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044d6:	70 0c       	ld.w	r12,r8[0x0]
800044d8:	68 0b       	ld.w	r11,r4[0x0]
800044da:	f0 1f 00 0a 	mcall	80004500 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044de:	8d 07       	st.w	r6[0x0],r7
800044e0:	cb 7b       	rjmp	8000444e <xnl_tx_process+0x12>
800044e2:	00 00       	add	r0,r0
800044e4:	00 00       	add	r0,r0
800044e6:	0b 50       	ld.sh	r0,--r5
800044e8:	00 00       	add	r0,r0
800044ea:	0b 54       	ld.sh	r4,--r5
800044ec:	00 00       	add	r0,r0
800044ee:	0b 5c       	ld.sh	r12,--r5
800044f0:	00 00       	add	r0,r0
800044f2:	0b 58       	ld.sh	r8,--r5
800044f4:	00 00       	add	r0,r0
800044f6:	0b 40       	ld.w	r0,--r5
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	62 2c       	ld.w	r12,r1[0x8]
800044fc:	00 00       	add	r0,r0
800044fe:	0a a0       	st.w	r5++,r0
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	2c 0c       	sub	r12,-64
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	2c 2c       	sub	r12,-62

80004508 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004508:	eb cd 40 c0 	pushm	r6-r7,lr
8000450c:	20 1d       	sub	sp,4
8000450e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004510:	98 39       	ld.sh	r9,r12[0x6]
80004512:	3f f8       	mov	r8,-1
80004514:	f0 09 19 00 	cp.h	r9,r8
80004518:	c0 a1       	brne	8000452c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000451a:	4a e9       	lddpc	r9,800045d0 <xnl_tx+0xc8>
8000451c:	13 88       	ld.ub	r8,r9[0x0]
8000451e:	2f f8       	sub	r8,-1
80004520:	5c 58       	castu.b	r8
80004522:	b2 88       	st.b	r9[0x0],r8
80004524:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004528:	a9 a8       	sbr	r8,0x8
8000452a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000452c:	8c 49       	ld.sh	r9,r6[0x8]
8000452e:	3f f8       	mov	r8,-1
80004530:	f0 09 19 00 	cp.h	r9,r8
80004534:	c0 41       	brne	8000453c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004536:	4a 88       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004538:	90 18       	ld.sh	r8,r8[0x2]
8000453a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000453c:	8c 59       	ld.sh	r9,r6[0xa]
8000453e:	3f f8       	mov	r8,-1
80004540:	f0 09 19 00 	cp.h	r9,r8
80004544:	c0 41       	brne	8000454c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004546:	4a 48       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004548:	90 28       	ld.sh	r8,r8[0x4]
8000454a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000454c:	8c 69       	ld.sh	r9,r6[0xc]
8000454e:	3f f8       	mov	r8,-1
80004550:	f0 09 19 00 	cp.h	r9,r8
80004554:	c0 e1       	brne	80004570 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004556:	4a 08       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004558:	90 49       	ld.sh	r9,r8[0x8]
8000455a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000455c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000455e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004560:	90 49       	ld.sh	r9,r8[0x8]
80004562:	e0 19 ff 00 	andl	r9,0xff00
80004566:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000456a:	f3 e8 10 08 	or	r8,r9,r8
8000456e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004570:	0d 98       	ld.ub	r8,r6[0x1]
80004572:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004574:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004578:	10 0c       	add	r12,r8
8000457a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000457c:	58 0c       	cp.w	r12,0
8000457e:	e0 89 00 04 	brgt	80004586 <xnl_tx+0x7e>
80004582:	30 09       	mov	r9,0
80004584:	c0 d8       	rjmp	8000459e <xnl_tx+0x96>
80004586:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000458a:	2f ec       	sub	r12,-2
8000458c:	30 09       	mov	r9,0
8000458e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004590:	15 1b       	ld.sh	r11,r10++
80004592:	f6 09 00 09 	add	r9,r11,r9
80004596:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004598:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000459a:	18 38       	cp.w	r8,r12
8000459c:	cf a1       	brne	80004590 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000459e:	5c 39       	neg	r9
800045a0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045a2:	48 e8       	lddpc	r8,800045d8 <xnl_tx+0xd0>
800045a4:	70 0c       	ld.w	r12,r8[0x0]
800045a6:	f0 1f 00 0e 	mcall	800045dc <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045aa:	c1 00       	breq	800045ca <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045ac:	fa c7 ff fc 	sub	r7,sp,-4
800045b0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045b2:	e0 6a 01 00 	mov	r10,256
800045b6:	0c 9b       	mov	r11,r6
800045b8:	f0 1f 00 0a 	mcall	800045e0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045bc:	48 a8       	lddpc	r8,800045e4 <xnl_tx+0xdc>
800045be:	70 0c       	ld.w	r12,r8[0x0]
800045c0:	30 09       	mov	r9,0
800045c2:	12 9a       	mov	r10,r9
800045c4:	1a 9b       	mov	r11,sp
800045c6:	f0 1f 00 09 	mcall	800045e8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800045ca:	2f fd       	sub	sp,-4
800045cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045d0:	00 00       	add	r0,r0
800045d2:	0b 44       	ld.w	r4,--r5
800045d4:	00 00       	add	r0,r0
800045d6:	0b 46       	ld.w	r6,--r5
800045d8:	00 00       	add	r0,r0
800045da:	0a a0       	st.w	r5++,r0
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	2d b8       	sub	r8,-37
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	78 f4       	ld.w	r4,r12[0x3c]
800045e4:	00 00       	add	r0,r0
800045e6:	0b 54       	ld.sh	r4,--r5
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	64 38       	ld.w	r8,r2[0xc]

800045ec <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045ec:	eb cd 40 80 	pushm	r7,lr
800045f0:	fa cd 01 00 	sub	sp,sp,256
800045f4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045f6:	e0 68 40 0e 	mov	r8,16398
800045fa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045fc:	3f f8       	mov	r8,-1
800045fe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004600:	30 c8       	mov	r8,12
80004602:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004604:	98 38       	ld.sh	r8,r12[0x6]
80004606:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004608:	98 58       	ld.sh	r8,r12[0xa]
8000460a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000460c:	98 48       	ld.sh	r8,r12[0x8]
8000460e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004610:	98 68       	ld.sh	r8,r12[0xc]
80004612:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004614:	30 08       	mov	r8,0
80004616:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004618:	1a 9c       	mov	r12,sp
8000461a:	f0 1f 00 0a 	mcall	80004640 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000461e:	fa cd 00 cc 	sub	sp,sp,204
80004622:	e0 6a 00 ca 	mov	r10,202
80004626:	ee cb ff f0 	sub	r11,r7,-16
8000462a:	1a 9c       	mov	r12,sp
8000462c:	f0 1f 00 06 	mcall	80004644 <xnl_data_msg_func+0x58>
80004630:	48 68       	lddpc	r8,80004648 <xnl_data_msg_func+0x5c>
80004632:	70 08       	ld.w	r8,r8[0x0]
80004634:	5d 18       	icall	r8
80004636:	fa cd ff 34 	sub	sp,sp,-204
}
8000463a:	2c 0d       	sub	sp,-256
8000463c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	45 08       	lddsp	r8,sp[0x140]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	78 f4       	ld.w	r4,r12[0x3c]
80004648:	00 00       	add	r0,r0
8000464a:	0b 60       	ld.uh	r0,--r5

8000464c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000464c:	d4 21       	pushm	r4-r7,lr
8000464e:	fa cd 01 00 	sub	sp,sp,256
80004652:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004654:	4c 28       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004656:	11 88       	ld.ub	r8,r8[0x0]
80004658:	58 08       	cp.w	r8,0
8000465a:	e0 81 00 7f 	brne	80004758 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000465e:	4c 18       	lddpc	r8,80004760 <xnl_device_auth_reply_func+0x114>
80004660:	70 0c       	ld.w	r12,r8[0x0]
80004662:	30 09       	mov	r9,0
80004664:	12 9a       	mov	r10,r9
80004666:	12 9b       	mov	r11,r9
80004668:	f0 1f 00 3f 	mcall	80004764 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000466c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004670:	4b b8       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004672:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004674:	ef 39 00 12 	ld.ub	r9,r7[18]
80004678:	ef 38 00 13 	ld.ub	r8,r7[19]
8000467c:	b1 68       	lsl	r8,0x10
8000467e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004682:	ef 38 00 15 	ld.ub	r8,r7[21]
80004686:	f3 e8 10 08 	or	r8,r9,r8
8000468a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000468e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004692:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004696:	ef 38 00 17 	ld.ub	r8,r7[23]
8000469a:	b1 68       	lsl	r8,0x10
8000469c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046a0:	ef 38 00 19 	ld.ub	r8,r7[25]
800046a4:	f5 e8 10 08 	or	r8,r10,r8
800046a8:	ef 3a 00 18 	ld.ub	r10,r7[24]
800046ac:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800046b0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046b2:	e0 64 79 b9 	mov	r4,31161
800046b6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046ba:	e0 65 45 07 	mov	r5,17671
800046be:	ea 15 8a bd 	orh	r5,0x8abd
800046c2:	e0 66 f9 3d 	mov	r6,63805
800046c6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046ca:	e0 6e b8 cf 	mov	lr,47311
800046ce:	ea 1e 36 83 	orh	lr,0x3683
800046d2:	e0 67 aa 1c 	mov	r7,43548
800046d6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046da:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046dc:	f4 08 00 0c 	add	r12,r10,r8
800046e0:	f0 0b 15 04 	lsl	r11,r8,0x4
800046e4:	0a 0b       	add	r11,r5
800046e6:	f9 eb 20 0b 	eor	r11,r12,r11
800046ea:	f0 0c 16 05 	lsr	r12,r8,0x5
800046ee:	0c 0c       	add	r12,r6
800046f0:	18 5b       	eor	r11,r12
800046f2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046f4:	f2 0c 15 04 	lsl	r12,r9,0x4
800046f8:	1c 0c       	add	r12,lr
800046fa:	f2 0b 16 05 	lsr	r11,r9,0x5
800046fe:	0e 0b       	add	r11,r7
80004700:	f9 eb 20 0b 	eor	r11,r12,r11
80004704:	f2 0a 00 0c 	add	r12,r9,r10
80004708:	18 5b       	eor	r11,r12
8000470a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000470c:	e0 6b 37 20 	mov	r11,14112
80004710:	ea 1b c6 ef 	orh	r11,0xc6ef
80004714:	16 3a       	cp.w	r10,r11
80004716:	ce 21       	brne	800046da <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004718:	e0 6a 40 1a 	mov	r10,16410
8000471c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000471e:	3f fa       	mov	r10,-1
80004720:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004722:	30 6b       	mov	r11,6
80004724:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004726:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004728:	48 db       	lddpc	r11,8000475c <xnl_device_auth_reply_func+0x110>
8000472a:	96 1c       	ld.sh	r12,r11[0x2]
8000472c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000472e:	96 2b       	ld.sh	r11,r11[0x4]
80004730:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004732:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004734:	30 ca       	mov	r10,12
80004736:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004738:	30 0a       	mov	r10,0
8000473a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000473e:	30 7a       	mov	r10,7
80004740:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004744:	30 2a       	mov	r10,2
80004746:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000474a:	fa ca ff ec 	sub	r10,sp,-20
8000474e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004750:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004752:	1a 9c       	mov	r12,sp
80004754:	f0 1f 00 05 	mcall	80004768 <xnl_device_auth_reply_func+0x11c>
}
80004758:	2c 0d       	sub	sp,-256
8000475a:	d8 22       	popm	r4-r7,pc
8000475c:	00 00       	add	r0,r0
8000475e:	0b 46       	ld.w	r6,--r5
80004760:	00 00       	add	r0,r0
80004762:	0b 40       	ld.w	r0,--r5
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	64 38       	ld.w	r8,r2[0xc]
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	45 08       	lddsp	r8,sp[0x140]

8000476c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000476c:	eb cd 40 80 	pushm	r7,lr
80004770:	fa cd 01 00 	sub	sp,sp,256
80004774:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004776:	49 28       	lddpc	r8,800047bc <xnl_master_status_brdcst_func+0x50>
80004778:	11 88       	ld.ub	r8,r8[0x0]
8000477a:	58 08       	cp.w	r8,0
8000477c:	c1 c1       	brne	800047b4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000477e:	49 18       	lddpc	r8,800047c0 <xnl_master_status_brdcst_func+0x54>
80004780:	70 0c       	ld.w	r12,r8[0x0]
80004782:	30 09       	mov	r9,0
80004784:	12 9a       	mov	r10,r9
80004786:	12 9b       	mov	r11,r9
80004788:	f0 1f 00 0f 	mcall	800047c4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000478c:	8e 58       	ld.sh	r8,r7[0xa]
8000478e:	48 c9       	lddpc	r9,800047bc <xnl_master_status_brdcst_func+0x50>
80004790:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004792:	e0 68 40 0e 	mov	r8,16398
80004796:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004798:	3f f8       	mov	r8,-1
8000479a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000479c:	30 4a       	mov	r10,4
8000479e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047a0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047a2:	92 19       	ld.sh	r9,r9[0x2]
800047a4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047a6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047a8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047aa:	30 08       	mov	r8,0
800047ac:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800047ae:	1a 9c       	mov	r12,sp
800047b0:	f0 1f 00 06 	mcall	800047c8 <xnl_master_status_brdcst_func+0x5c>
}
800047b4:	2c 0d       	sub	sp,-256
800047b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ba:	00 00       	add	r0,r0
800047bc:	00 00       	add	r0,r0
800047be:	0b 46       	ld.w	r6,--r5
800047c0:	00 00       	add	r0,r0
800047c2:	0b 40       	ld.w	r0,--r5
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	64 38       	ld.w	r8,r2[0xc]
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	45 08       	lddsp	r8,sp[0x140]

800047cc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800047cc:	eb cd 40 80 	pushm	r7,lr
800047d0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047d2:	49 28       	lddpc	r8,80004818 <xnl_device_conn_reply_func+0x4c>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	30 09       	mov	r9,0
800047d8:	12 9a       	mov	r10,r9
800047da:	12 9b       	mov	r11,r9
800047dc:	f0 1f 00 10 	mcall	8000481c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047e0:	ef 18 00 10 	ld.uh	r8,r7[16]
800047e4:	10 99       	mov	r9,r8
800047e6:	e2 19 ff 00 	andl	r9,0xff00,COH
800047ea:	e0 49 01 00 	cp.w	r9,256
800047ee:	c0 60       	breq	800047fa <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047f0:	0e 9c       	mov	r12,r7
800047f2:	f0 1f 00 0c 	mcall	80004820 <xnl_device_conn_reply_func+0x54>
800047f6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047fa:	a9 68       	lsl	r8,0x8
800047fc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004800:	48 98       	lddpc	r8,80004824 <xnl_device_conn_reply_func+0x58>
80004802:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004804:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004808:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000480a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000480e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004810:	30 19       	mov	r9,1
80004812:	b0 89       	st.b	r8[0x0],r9
80004814:	e3 cd 80 80 	ldm	sp++,r7,pc
80004818:	00 00       	add	r0,r0
8000481a:	0b 40       	ld.w	r0,--r5
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	64 38       	ld.w	r8,r2[0xc]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	47 6c       	lddsp	r12,sp[0x1d8]
80004824:	00 00       	add	r0,r0
80004826:	0b 46       	ld.w	r6,--r5

80004828 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004828:	d4 01       	pushm	lr
8000482a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000482e:	e0 68 40 0e 	mov	r8,16398
80004832:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004834:	3f f8       	mov	r8,-1
80004836:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004838:	30 38       	mov	r8,3
8000483a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000483c:	30 08       	mov	r8,0
8000483e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004840:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004842:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004844:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004846:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004848:	1a 9c       	mov	r12,sp
8000484a:	f0 1f 00 03 	mcall	80004854 <xnl_send_device_master_query+0x2c>
}
8000484e:	2c 0d       	sub	sp,-256
80004850:	d8 02       	popm	pc
80004852:	00 00       	add	r0,r0
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	45 08       	lddsp	r8,sp[0x140]

80004858 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004858:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000485a:	48 78       	lddpc	r8,80004874 <RC522_SPI_SetSpeed+0x1c>
8000485c:	70 09       	ld.w	r9,r8[0x0]
8000485e:	72 ca       	ld.w	r10,r9[0x30]
80004860:	5c 7c       	castu.h	r12
80004862:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004866:	f9 ea 10 0a 	or	r10,r12,r10
8000486a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000486c:	70 0c       	ld.w	r12,r8[0x0]
8000486e:	f0 1f 00 03 	mcall	80004878 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004872:	d8 02       	popm	pc
80004874:	00 00       	add	r0,r0
80004876:	20 2c       	sub	r12,2
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	59 28       	cp.w	r8,18

8000487c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000487c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000487e:	e0 6c 04 00 	mov	r12,1024
80004882:	f0 1f 00 02 	mcall	80004888 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004886:	d8 02       	popm	pc
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	48 58       	lddpc	r8,8000489c <RC522_ReadByte+0x10>

8000488c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000488c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004890:	48 76       	lddpc	r6,800048ac <RC522_ReadByte+0x20>
80004892:	e0 6b 00 ff 	mov	r11,255
80004896:	6c 0c       	ld.w	r12,r6[0x0]
80004898:	f0 1f 00 06 	mcall	800048b0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000489c:	30 07       	mov	r7,0
8000489e:	0e 9b       	mov	r11,r7
800048a0:	6c 0c       	ld.w	r12,r6[0x0]
800048a2:	f0 1f 00 05 	mcall	800048b4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800048a6:	0f 9c       	ld.ub	r12,r7[0x1]
800048a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ac:	00 00       	add	r0,r0
800048ae:	20 2c       	sub	r12,2
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	59 2e       	cp.w	lr,18
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	59 4a       	cp.w	r10,20

800048b8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800048b8:	eb cd 40 80 	pushm	r7,lr
800048bc:	20 1d       	sub	sp,4
800048be:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048c0:	48 77       	lddpc	r7,800048dc <RC522_WriteByte+0x24>
800048c2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800048c6:	6e 0c       	ld.w	r12,r7[0x0]
800048c8:	f0 1f 00 06 	mcall	800048e0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048cc:	1a 9b       	mov	r11,sp
800048ce:	6e 0c       	ld.w	r12,r7[0x0]
800048d0:	f0 1f 00 05 	mcall	800048e4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048d4:	5c 5c       	castu.b	r12
800048d6:	2f fd       	sub	sp,-4
800048d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800048dc:	00 00       	add	r0,r0
800048de:	20 2c       	sub	r12,2
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	59 2e       	cp.w	lr,18
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	59 4a       	cp.w	r10,20

800048e8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048e8:	eb cd 40 e0 	pushm	r5-r7,lr
800048ec:	18 96       	mov	r6,r12
800048ee:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048f0:	48 a7       	lddpc	r7,80004918 <WriteRawRC+0x30>
800048f2:	30 0b       	mov	r11,0
800048f4:	6e 0c       	ld.w	r12,r7[0x0]
800048f6:	f0 1f 00 0a 	mcall	8000491c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048fa:	ec 0c 15 01 	lsl	r12,r6,0x1
800048fe:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004902:	f0 1f 00 08 	mcall	80004920 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004906:	0a 9c       	mov	r12,r5
80004908:	f0 1f 00 06 	mcall	80004920 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000490c:	30 0b       	mov	r11,0
8000490e:	6e 0c       	ld.w	r12,r7[0x0]
80004910:	f0 1f 00 05 	mcall	80004924 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004914:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004918:	00 00       	add	r0,r0
8000491a:	20 2c       	sub	r12,2
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	5a 94       	cp.w	r4,-23
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	48 b8       	lddpc	r8,8000494c <PcdReset+0x24>
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	5a 54       	cp.w	r4,-27

80004928 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004928:	d4 01       	pushm	lr

	SET_RC522RST;
8000492a:	31 9c       	mov	r12,25
8000492c:	f0 1f 00 1b 	mcall	80004998 <PcdReset+0x70>
	delay_ns(10);
80004930:	30 ac       	mov	r12,10
80004932:	f0 1f 00 1b 	mcall	8000499c <PcdReset+0x74>

	CLR_RC522RST;
80004936:	31 9c       	mov	r12,25
80004938:	f0 1f 00 1a 	mcall	800049a0 <PcdReset+0x78>
	delay_ns(10);
8000493c:	30 ac       	mov	r12,10
8000493e:	f0 1f 00 18 	mcall	8000499c <PcdReset+0x74>

	SET_RC522RST;
80004942:	31 9c       	mov	r12,25
80004944:	f0 1f 00 15 	mcall	80004998 <PcdReset+0x70>
	delay_ns(10);
80004948:	30 ac       	mov	r12,10
8000494a:	f0 1f 00 15 	mcall	8000499c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000494e:	30 fb       	mov	r11,15
80004950:	30 1c       	mov	r12,1
80004952:	f0 1f 00 15 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004956:	30 fb       	mov	r11,15
80004958:	30 1c       	mov	r12,1
8000495a:	f0 1f 00 13 	mcall	800049a4 <PcdReset+0x7c>
	delay_ns(10);
8000495e:	30 ac       	mov	r12,10
80004960:	f0 1f 00 0f 	mcall	8000499c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004964:	33 db       	mov	r11,61
80004966:	31 1c       	mov	r12,17
80004968:	f0 1f 00 0f 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000496c:	31 eb       	mov	r11,30
8000496e:	32 dc       	mov	r12,45
80004970:	f0 1f 00 0d 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004974:	30 0b       	mov	r11,0
80004976:	32 cc       	mov	r12,44
80004978:	f0 1f 00 0b 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000497c:	e0 6b 00 8d 	mov	r11,141
80004980:	32 ac       	mov	r12,42
80004982:	f0 1f 00 09 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004986:	33 eb       	mov	r11,62
80004988:	32 bc       	mov	r12,43
8000498a:	f0 1f 00 07 	mcall	800049a4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000498e:	34 0b       	mov	r11,64
80004990:	31 5c       	mov	r12,21
80004992:	f0 1f 00 05 	mcall	800049a4 <PcdReset+0x7c>
	
	return MI_OK;
}
80004996:	d8 0a       	popm	pc,r12=0
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	54 9c       	stdsp	sp[0x124],r12
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	52 34       	stdsp	sp[0x8c],r4
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	54 b8       	stdsp	sp[0x12c],r8
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	48 e8       	lddpc	r8,800049dc <ReadRawRC+0x34>

800049a8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049a8:	eb cd 40 c0 	pushm	r6-r7,lr
800049ac:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800049ae:	48 c7       	lddpc	r7,800049dc <ReadRawRC+0x34>
800049b0:	30 0b       	mov	r11,0
800049b2:	6e 0c       	ld.w	r12,r7[0x0]
800049b4:	f0 1f 00 0b 	mcall	800049e0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049b8:	a1 76       	lsl	r6,0x1
800049ba:	0c 9c       	mov	r12,r6
800049bc:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049c0:	a7 bc       	sbr	r12,0x7
800049c2:	f0 1f 00 09 	mcall	800049e4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800049c6:	f0 1f 00 09 	mcall	800049e8 <ReadRawRC+0x40>
800049ca:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049cc:	30 0b       	mov	r11,0
800049ce:	6e 0c       	ld.w	r12,r7[0x0]
800049d0:	f0 1f 00 07 	mcall	800049ec <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800049d4:	0c 9c       	mov	r12,r6
800049d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049da:	00 00       	add	r0,r0
800049dc:	00 00       	add	r0,r0
800049de:	20 2c       	sub	r12,2
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	5a 94       	cp.w	r4,-23
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	48 b8       	lddpc	r8,80004a10 <Powerdown_RC522+0x10>
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	48 8c       	lddpc	r12,80004a08 <Powerdown_RC522+0x8>
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	5a 54       	cp.w	r4,-27

800049f0 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800049f0:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800049f2:	30 1c       	mov	r12,1
800049f4:	f0 1f 00 02 	mcall	800049fc <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800049f8:	d8 02       	popm	pc
800049fa:	00 00       	add	r0,r0
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	49 a8       	lddpc	r8,80004a64 <SetBitMask+0x18>

80004a00 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004a00:	eb cd 40 80 	pushm	r7,lr
80004a04:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004a06:	30 1c       	mov	r12,1
80004a08:	f0 1f 00 0d 	mcall	80004a3c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004a0c:	30 18       	mov	r8,1
80004a0e:	f0 07 18 00 	cp.b	r7,r8
80004a12:	c0 91       	brne	80004a24 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004a14:	18 9b       	mov	r11,r12
80004a16:	a5 ab       	sbr	r11,0x4
80004a18:	5c 5b       	castu.b	r11
80004a1a:	30 1c       	mov	r12,1
80004a1c:	f0 1f 00 09 	mcall	80004a40 <Powerdown_RC522+0x40>
80004a20:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004a24:	18 9b       	mov	r11,r12
80004a26:	30 1c       	mov	r12,1
80004a28:	f0 1f 00 06 	mcall	80004a40 <Powerdown_RC522+0x40>
		delay_ns(2);
80004a2c:	30 2c       	mov	r12,2
80004a2e:	f0 1f 00 06 	mcall	80004a44 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004a32:	f0 1f 00 06 	mcall	80004a48 <Powerdown_RC522+0x48>
80004a36:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a3a:	00 00       	add	r0,r0
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	49 a8       	lddpc	r8,80004aa4 <ClearBitMask+0x14>
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	48 e8       	lddpc	r8,80004a78 <PcdAntennaOn+0x8>
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	52 34       	stdsp	sp[0x8c],r4
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	49 f0       	lddpc	r0,80004ac4 <PcdAntennaOff+0xc>

80004a4c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a4c:	eb cd 40 c0 	pushm	r6-r7,lr
80004a50:	18 97       	mov	r7,r12
80004a52:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a54:	f0 1f 00 05 	mcall	80004a68 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a58:	f9 e6 10 0b 	or	r11,r12,r6
80004a5c:	5c 5b       	castu.b	r11
80004a5e:	0e 9c       	mov	r12,r7
80004a60:	f0 1f 00 03 	mcall	80004a6c <SetBitMask+0x20>
}
80004a64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	49 a8       	lddpc	r8,80004ad0 <M500PcdConfigISOType+0x8>
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	48 e8       	lddpc	r8,80004aa4 <ClearBitMask+0x14>

80004a70 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a70:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a72:	31 4c       	mov	r12,20
80004a74:	f0 1f 00 05 	mcall	80004a88 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a78:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a7c:	c0 51       	brne	80004a86 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a7e:	30 3b       	mov	r11,3
80004a80:	31 4c       	mov	r12,20
80004a82:	f0 1f 00 03 	mcall	80004a8c <PcdAntennaOn+0x1c>
80004a86:	d8 02       	popm	pc
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	49 a8       	lddpc	r8,80004af0 <M500PcdConfigISOType+0x28>
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	4a 4c       	lddpc	r12,80004b1c <M500PcdConfigISOType+0x54>

80004a90 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a90:	eb cd 40 c0 	pushm	r6-r7,lr
80004a94:	18 97       	mov	r7,r12
80004a96:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a98:	f0 1f 00 06 	mcall	80004ab0 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a9c:	5c d6       	com	r6
80004a9e:	f9 e6 00 06 	and	r6,r12,r6
80004aa2:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004aa6:	0e 9c       	mov	r12,r7
80004aa8:	f0 1f 00 03 	mcall	80004ab4 <ClearBitMask+0x24>
	
}
80004aac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	49 a8       	lddpc	r8,80004b18 <M500PcdConfigISOType+0x50>
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	48 e8       	lddpc	r8,80004aec <M500PcdConfigISOType+0x24>

80004ab8 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004ab8:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004aba:	30 3b       	mov	r11,3
80004abc:	31 4c       	mov	r12,20
80004abe:	f0 1f 00 02 	mcall	80004ac4 <PcdAntennaOff+0xc>
}
80004ac2:	d8 02       	popm	pc
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	4a 90       	lddpc	r0,80004b68 <rc522_init+0x30>

80004ac8 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004ac8:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004aca:	34 18       	mov	r8,65
80004acc:	f0 0c 18 00 	cp.b	r12,r8
80004ad0:	c0 20       	breq	80004ad4 <M500PcdConfigISOType+0xc>
80004ad2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004ad4:	30 8b       	mov	r11,8
80004ad6:	16 9c       	mov	r12,r11
80004ad8:	f0 1f 00 14 	mcall	80004b28 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004adc:	33 db       	mov	r11,61
80004ade:	31 1c       	mov	r12,17
80004ae0:	f0 1f 00 13 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004ae4:	e0 6b 00 86 	mov	r11,134
80004ae8:	31 7c       	mov	r12,23
80004aea:	f0 1f 00 11 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004aee:	37 fb       	mov	r11,127
80004af0:	32 6c       	mov	r12,38
80004af2:	f0 1f 00 0f 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004af6:	31 eb       	mov	r11,30
80004af8:	32 dc       	mov	r12,45
80004afa:	f0 1f 00 0d 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004afe:	30 0b       	mov	r11,0
80004b00:	32 cc       	mov	r12,44
80004b02:	f0 1f 00 0b 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b06:	e0 6b 00 8d 	mov	r11,141
80004b0a:	32 ac       	mov	r12,42
80004b0c:	f0 1f 00 08 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b10:	33 eb       	mov	r11,62
80004b12:	32 bc       	mov	r12,43
80004b14:	f0 1f 00 06 	mcall	80004b2c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004b18:	e0 6c 03 e8 	mov	r12,1000
80004b1c:	f0 1f 00 05 	mcall	80004b30 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004b20:	f0 1f 00 05 	mcall	80004b34 <M500PcdConfigISOType+0x6c>
80004b24:	d8 0a       	popm	pc,r12=0
80004b26:	00 00       	add	r0,r0
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	4a 90       	lddpc	r0,80004bcc <rc522_init+0x94>
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	48 e8       	lddpc	r8,80004b64 <rc522_init+0x2c>
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	52 34       	stdsp	sp[0x8c],r4
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4a 70       	lddpc	r0,80004bd0 <rc522_init+0x98>

80004b38 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b38:	eb cd 40 c0 	pushm	r6-r7,lr
80004b3c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b3e:	4a 38       	lddpc	r8,80004bc8 <rc522_init+0x90>
80004b40:	1a 96       	mov	r6,sp
80004b42:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b46:	fa eb 00 00 	st.d	sp[0],r10
80004b4a:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b4e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b52:	30 4b       	mov	r11,4
80004b54:	49 ec       	lddpc	r12,80004bcc <rc522_init+0x94>
80004b56:	f0 1f 00 1f 	mcall	80004bd0 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b5a:	31 9c       	mov	r12,25
80004b5c:	f0 1f 00 1e 	mcall	80004bd4 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b60:	31 9c       	mov	r12,25
80004b62:	f0 1f 00 1e 	mcall	80004bd8 <rc522_init+0xa0>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004b66:	49 e7       	lddpc	r7,80004bdc <rc522_init+0xa4>
80004b68:	fe 7c 24 00 	mov	r12,-56320
80004b6c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b6e:	1a 9b       	mov	r11,sp
80004b70:	f0 1f 00 1c 	mcall	80004be0 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b74:	30 09       	mov	r9,0
80004b76:	12 9a       	mov	r10,r9
80004b78:	12 9b       	mov	r11,r9
80004b7a:	6e 0c       	ld.w	r12,r7[0x0]
80004b7c:	f0 1f 00 1a 	mcall	80004be4 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004b80:	6e 0c       	ld.w	r12,r7[0x0]
80004b82:	f0 1f 00 1a 	mcall	80004be8 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b86:	e0 6a 36 00 	mov	r10,13824
80004b8a:	ea 1a 01 6e 	orh	r10,0x16e
80004b8e:	1a 9b       	mov	r11,sp
80004b90:	6e 0c       	ld.w	r12,r7[0x0]
80004b92:	f0 1f 00 17 	mcall	80004bec <rc522_init+0xb4>
80004b96:	c0 50       	breq	80004ba0 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b98:	30 29       	mov	r9,2
80004b9a:	49 68       	lddpc	r8,80004bf0 <rc522_init+0xb8>
80004b9c:	b0 89       	st.b	r8[0x0],r9
80004b9e:	c0 38       	rjmp	80004ba4 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004ba0:	f0 1f 00 15 	mcall	80004bf4 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004ba4:	f0 1f 00 15 	mcall	80004bf8 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004ba8:	f0 1f 00 15 	mcall	80004bfc <rc522_init+0xc4>
	
	delay_ms(2); 
80004bac:	30 2c       	mov	r12,2
80004bae:	f0 1f 00 15 	mcall	80004c00 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004bb2:	f0 1f 00 15 	mcall	80004c04 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004bb6:	34 1c       	mov	r12,65
80004bb8:	f0 1f 00 14 	mcall	80004c08 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004bbc:	30 1c       	mov	r12,1
80004bbe:	f0 1f 00 14 	mcall	80004c0c <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004bc2:	2f cd       	sub	sp,-16
80004bc4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	d8 00       	acall	0x80
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	d8 18       	*unknown*
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	54 54       	stdsp	sp[0x114],r4
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	54 84       	stdsp	sp[0x120],r4
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	54 9c       	stdsp	sp[0x124],r12
80004bdc:	00 00       	add	r0,r0
80004bde:	20 2c       	sub	r12,2
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	58 c4       	cp.w	r4,12
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	58 fc       	cp.w	r12,15
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	59 28       	cp.w	r8,18
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	59 6c       	cp.w	r12,22
80004bf0:	00 00       	add	r0,r0
80004bf2:	0b 64       	ld.uh	r4,--r5
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	48 7c       	lddpc	r12,80004c10 <PcdComMF522>
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	49 28       	lddpc	r8,80004c40 <PcdComMF522+0x30>
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	4a b8       	lddpc	r8,80004ca8 <PcdComMF522+0x98>
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	52 74       	stdsp	sp[0x9c],r4
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	4a 70       	lddpc	r0,80004ca0 <PcdComMF522+0x90>
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	4a c8       	lddpc	r8,80004cb8 <PcdComMF522+0xa8>
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	4a 00       	lddpc	r0,80004c8c <PcdComMF522+0x7c>

80004c10 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c10:	d4 31       	pushm	r0-r7,lr
80004c12:	20 1d       	sub	sp,4
80004c14:	18 92       	mov	r2,r12
80004c16:	16 95       	mov	r5,r11
80004c18:	14 96       	mov	r6,r10
80004c1a:	50 09       	stdsp	sp[0x0],r9
80004c1c:	10 90       	mov	r0,r8
80004c1e:	f8 c8 00 0c 	sub	r8,r12,12
80004c22:	5c 58       	castu.b	r8
80004c24:	30 29       	mov	r9,2
80004c26:	f2 08 18 00 	cp.b	r8,r9
80004c2a:	e0 88 00 05 	brls	80004c34 <PcdComMF522+0x24>
80004c2e:	30 03       	mov	r3,0
80004c30:	06 91       	mov	r1,r3
80004c32:	c0 78       	rjmp	80004c40 <PcdComMF522+0x30>
80004c34:	4c f9       	lddpc	r9,80004d70 <PcdComMF522+0x160>
80004c36:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c3a:	4c f9       	lddpc	r9,80004d74 <PcdComMF522+0x164>
80004c3c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c40:	02 9b       	mov	r11,r1
80004c42:	a7 bb       	sbr	r11,0x7
80004c44:	30 2c       	mov	r12,2
80004c46:	f0 1f 00 4d 	mcall	80004d78 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c4a:	e0 6b 00 80 	mov	r11,128
80004c4e:	30 4c       	mov	r12,4
80004c50:	f0 1f 00 4b 	mcall	80004d7c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c54:	30 0b       	mov	r11,0
80004c56:	30 1c       	mov	r12,1
80004c58:	f0 1f 00 48 	mcall	80004d78 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c5c:	e0 6b 00 80 	mov	r11,128
80004c60:	30 ac       	mov	r12,10
80004c62:	f0 1f 00 48 	mcall	80004d80 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c66:	58 06       	cp.w	r6,0
80004c68:	c0 c0       	breq	80004c80 <PcdComMF522+0x70>
80004c6a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c6c:	30 94       	mov	r4,9
80004c6e:	0f 3b       	ld.ub	r11,r7++
80004c70:	08 9c       	mov	r12,r4
80004c72:	f0 1f 00 42 	mcall	80004d78 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c76:	0e 98       	mov	r8,r7
80004c78:	0a 18       	sub	r8,r5
80004c7a:	ec 08 19 00 	cp.h	r8,r6
80004c7e:	cf 83       	brcs	80004c6e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c80:	04 9b       	mov	r11,r2
80004c82:	30 1c       	mov	r12,1
80004c84:	f0 1f 00 3d 	mcall	80004d78 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c88:	30 c8       	mov	r8,12
80004c8a:	f0 02 18 00 	cp.b	r2,r8
80004c8e:	c0 61       	brne	80004c9a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c90:	e0 6b 00 80 	mov	r11,128
80004c94:	30 dc       	mov	r12,13
80004c96:	f0 1f 00 3b 	mcall	80004d80 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c9a:	30 4c       	mov	r12,4
80004c9c:	f0 1f 00 3a 	mcall	80004d84 <PcdComMF522+0x174>
80004ca0:	18 97       	mov	r7,r12
80004ca2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ca6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ca8:	30 44       	mov	r4,4
80004caa:	c0 88       	rjmp	80004cba <PcdComMF522+0xaa>
80004cac:	08 9c       	mov	r12,r4
80004cae:	f0 1f 00 36 	mcall	80004d84 <PcdComMF522+0x174>
80004cb2:	18 97       	mov	r7,r12
		i--;
80004cb4:	20 16       	sub	r6,1
80004cb6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004cb8:	c0 a0       	breq	80004ccc <PcdComMF522+0xbc>
80004cba:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004cbe:	c4 c1       	brne	80004d56 <PcdComMF522+0x146>
80004cc0:	ef e3 00 08 	and	r8,r7,r3
80004cc4:	ea 08 18 00 	cp.b	r8,r5
80004cc8:	cf 20       	breq	80004cac <PcdComMF522+0x9c>
80004cca:	c4 68       	rjmp	80004d56 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ccc:	e0 6b 00 80 	mov	r11,128
80004cd0:	30 dc       	mov	r12,13
80004cd2:	f0 1f 00 2b 	mcall	80004d7c <PcdComMF522+0x16c>
80004cd6:	30 27       	mov	r7,2
80004cd8:	c3 38       	rjmp	80004d3e <PcdComMF522+0x12e>
80004cda:	02 67       	and	r7,r1
80004cdc:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ce0:	30 c8       	mov	r8,12
80004ce2:	f0 02 18 00 	cp.b	r2,r8
80004ce6:	c2 c1       	brne	80004d3e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ce8:	30 ac       	mov	r12,10
80004cea:	f0 1f 00 27 	mcall	80004d84 <PcdComMF522+0x174>
80004cee:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004cf0:	30 cc       	mov	r12,12
80004cf2:	f0 1f 00 25 	mcall	80004d84 <PcdComMF522+0x174>
80004cf6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004cfa:	c0 70       	breq	80004d08 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004cfc:	08 98       	mov	r8,r4
80004cfe:	20 18       	sub	r8,1
80004d00:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d04:	a0 8c       	st.b	r0[0x0],r12
80004d06:	c0 48       	rjmp	80004d0e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d08:	e8 08 15 03 	lsl	r8,r4,0x3
80004d0c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d0e:	58 04       	cp.w	r4,0
80004d10:	c0 61       	brne	80004d1c <PcdComMF522+0x10c>
80004d12:	30 14       	mov	r4,1
80004d14:	40 05       	lddsp	r5,sp[0x0]
80004d16:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d18:	30 93       	mov	r3,9
80004d1a:	c0 98       	rjmp	80004d2c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d1c:	31 28       	mov	r8,18
80004d1e:	f0 04 18 00 	cp.b	r4,r8
80004d22:	f9 b4 0b 12 	movhi	r4,18
80004d26:	58 04       	cp.w	r4,0
80004d28:	cf 61       	brne	80004d14 <PcdComMF522+0x104>
80004d2a:	c0 a8       	rjmp	80004d3e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d2c:	06 9c       	mov	r12,r3
80004d2e:	f0 1f 00 16 	mcall	80004d84 <PcdComMF522+0x174>
80004d32:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d34:	ec 05 01 08 	sub	r8,r6,r5
80004d38:	e8 08 19 00 	cp.h	r8,r4
80004d3c:	cf 83       	brcs	80004d2c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d3e:	e0 6b 00 80 	mov	r11,128
80004d42:	30 cc       	mov	r12,12
80004d44:	f0 1f 00 0f 	mcall	80004d80 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d48:	30 0b       	mov	r11,0
80004d4a:	30 1c       	mov	r12,1
80004d4c:	f0 1f 00 0b 	mcall	80004d78 <PcdComMF522+0x168>
	return status;
}
80004d50:	0e 9c       	mov	r12,r7
80004d52:	2f fd       	sub	sp,-4
80004d54:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d56:	e0 6b 00 80 	mov	r11,128
80004d5a:	30 dc       	mov	r12,13
80004d5c:	f0 1f 00 08 	mcall	80004d7c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d60:	30 6c       	mov	r12,6
80004d62:	f0 1f 00 09 	mcall	80004d84 <PcdComMF522+0x174>
80004d66:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d6a:	cb 80       	breq	80004cda <PcdComMF522+0xca>
80004d6c:	30 27       	mov	r7,2
80004d6e:	ce 8b       	rjmp	80004d3e <PcdComMF522+0x12e>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	d8 14       	*unknown*
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	d8 10       	acall	0x81
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	48 e8       	lddpc	r8,80004db0 <PcdAnticoll+0x28>
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	4a 90       	lddpc	r0,80004e20 <PcdRequest+0x14>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4a 4c       	lddpc	r12,80004e10 <PcdRequest+0x4>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	49 a8       	lddpc	r8,80004dec <PcdAnticoll+0x64>

80004d88 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d88:	eb cd 40 c0 	pushm	r6-r7,lr
80004d8c:	20 5d       	sub	sp,20
80004d8e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d90:	30 8b       	mov	r11,8
80004d92:	16 9c       	mov	r12,r11
80004d94:	f0 1f 00 1a 	mcall	80004dfc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d98:	30 0b       	mov	r11,0
80004d9a:	30 dc       	mov	r12,13
80004d9c:	f0 1f 00 19 	mcall	80004e00 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004da0:	e0 6b 00 80 	mov	r11,128
80004da4:	30 ec       	mov	r12,14
80004da6:	f0 1f 00 16 	mcall	80004dfc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004daa:	39 38       	mov	r8,-109
80004dac:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004dae:	32 08       	mov	r8,32
80004db0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004db2:	1a 9b       	mov	r11,sp
80004db4:	fa c8 ff ed 	sub	r8,sp,-19
80004db8:	1a 99       	mov	r9,sp
80004dba:	30 2a       	mov	r10,2
80004dbc:	30 cc       	mov	r12,12
80004dbe:	f0 1f 00 12 	mcall	80004e04 <PcdAnticoll+0x7c>
80004dc2:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004dc4:	c1 21       	brne	80004de8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dc6:	1b 89       	ld.ub	r9,sp[0x0]
80004dc8:	ac 89       	st.b	r6[0x0],r9
80004dca:	1b 98       	ld.ub	r8,sp[0x1]
80004dcc:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004dce:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dd0:	1b a8       	ld.ub	r8,sp[0x2]
80004dd2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004dd4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dd8:	1b b9       	ld.ub	r9,sp[0x3]
80004dda:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ddc:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004dde:	1b c9       	ld.ub	r9,sp[0x4]
80004de0:	f0 09 18 00 	cp.b	r9,r8
80004de4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004de8:	e0 6b 00 80 	mov	r11,128
80004dec:	30 ec       	mov	r12,14
80004dee:	f0 1f 00 07 	mcall	80004e08 <PcdAnticoll+0x80>
	return status;
}
80004df2:	0e 9c       	mov	r12,r7
80004df4:	2f bd       	sub	sp,-20
80004df6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dfa:	00 00       	add	r0,r0
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4a 90       	lddpc	r0,80004ea0 <CalulateCRC+0x30>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	48 e8       	lddpc	r8,80004e38 <PcdRequest+0x2c>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	4c 10       	lddpc	r0,80004f08 <PcdSelect+0xc>
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	4a 4c       	lddpc	r12,80004e98 <CalulateCRC+0x28>

80004e0c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e0c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e10:	20 5d       	sub	sp,20
80004e12:	18 97       	mov	r7,r12
80004e14:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e16:	30 8b       	mov	r11,8
80004e18:	16 9c       	mov	r12,r11
80004e1a:	f0 1f 00 12 	mcall	80004e60 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e1e:	30 7b       	mov	r11,7
80004e20:	30 dc       	mov	r12,13
80004e22:	f0 1f 00 11 	mcall	80004e64 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004e26:	30 3b       	mov	r11,3
80004e28:	31 4c       	mov	r12,20
80004e2a:	f0 1f 00 10 	mcall	80004e68 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004e2e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004e30:	1a 9b       	mov	r11,sp
80004e32:	fa c8 ff ed 	sub	r8,sp,-19
80004e36:	1a 99       	mov	r9,sp
80004e38:	30 1a       	mov	r10,1
80004e3a:	30 cc       	mov	r12,12
80004e3c:	f0 1f 00 0c 	mcall	80004e6c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e40:	c0 c1       	brne	80004e58 <PcdRequest+0x4c>
80004e42:	31 08       	mov	r8,16
80004e44:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e48:	f0 09 18 00 	cp.b	r9,r8
80004e4c:	c0 61       	brne	80004e58 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e4e:	1b 88       	ld.ub	r8,sp[0x0]
80004e50:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e52:	1b 98       	ld.ub	r8,sp[0x1]
80004e54:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e56:	c0 28       	rjmp	80004e5a <PcdRequest+0x4e>
80004e58:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e5a:	2f bd       	sub	sp,-20
80004e5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	4a 90       	lddpc	r0,80004f04 <PcdSelect+0x8>
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	48 e8       	lddpc	r8,80004e9c <CalulateCRC+0x2c>
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	4a 4c       	lddpc	r12,80004ef8 <CalulateCRC+0x88>
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4c 10       	lddpc	r0,80004f70 <rfid_auto_reader>

80004e70 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e70:	eb cd 40 f8 	pushm	r3-r7,lr
80004e74:	18 95       	mov	r5,r12
80004e76:	16 96       	mov	r6,r11
80004e78:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e7a:	30 4b       	mov	r11,4
80004e7c:	30 5c       	mov	r12,5
80004e7e:	f0 1f 00 1c 	mcall	80004eec <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e82:	30 0b       	mov	r11,0
80004e84:	30 1c       	mov	r12,1
80004e86:	f0 1f 00 1b 	mcall	80004ef0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e8a:	e0 6b 00 80 	mov	r11,128
80004e8e:	30 ac       	mov	r12,10
80004e90:	f0 1f 00 19 	mcall	80004ef4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e94:	58 06       	cp.w	r6,0
80004e96:	c0 c0       	breq	80004eae <CalulateCRC+0x3e>
80004e98:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e9a:	30 94       	mov	r4,9
80004e9c:	0f 3b       	ld.ub	r11,r7++
80004e9e:	08 9c       	mov	r12,r4
80004ea0:	f0 1f 00 14 	mcall	80004ef0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004ea4:	0e 98       	mov	r8,r7
80004ea6:	0a 18       	sub	r8,r5
80004ea8:	ec 08 18 00 	cp.b	r8,r6
80004eac:	cf 83       	brcs	80004e9c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004eae:	30 3b       	mov	r11,3
80004eb0:	30 1c       	mov	r12,1
80004eb2:	f0 1f 00 10 	mcall	80004ef0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004eb6:	30 5c       	mov	r12,5
80004eb8:	f0 1f 00 10 	mcall	80004ef8 <CalulateCRC+0x88>
80004ebc:	e0 67 00 fe 	mov	r7,254
80004ec0:	30 56       	mov	r6,5
80004ec2:	c0 78       	rjmp	80004ed0 <CalulateCRC+0x60>
80004ec4:	0c 9c       	mov	r12,r6
80004ec6:	f0 1f 00 0d 	mcall	80004ef8 <CalulateCRC+0x88>
		i--;
80004eca:	20 17       	sub	r7,1
80004ecc:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004ece:	c0 40       	breq	80004ed6 <CalulateCRC+0x66>
80004ed0:	e2 1c 00 04 	andl	r12,0x4,COH
80004ed4:	cf 80       	breq	80004ec4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004ed6:	32 2c       	mov	r12,34
80004ed8:	f0 1f 00 08 	mcall	80004ef8 <CalulateCRC+0x88>
80004edc:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ede:	32 1c       	mov	r12,33
80004ee0:	f0 1f 00 06 	mcall	80004ef8 <CalulateCRC+0x88>
80004ee4:	a6 9c       	st.b	r3[0x1],r12
}
80004ee6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004eea:	00 00       	add	r0,r0
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	4a 90       	lddpc	r0,80004f90 <rfid_auto_reader+0x20>
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	48 e8       	lddpc	r8,80004f28 <PcdSelect+0x2c>
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4a 4c       	lddpc	r12,80004f84 <rfid_auto_reader+0x14>
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	49 a8       	lddpc	r8,80004f60 <PcdSelect+0x64>

80004efc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004efc:	eb cd 40 80 	pushm	r7,lr
80004f00:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f02:	39 38       	mov	r8,-109
80004f04:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f06:	37 08       	mov	r8,112
80004f08:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f0a:	30 08       	mov	r8,0
80004f0c:	ba e8       	st.b	sp[0x6],r8
80004f0e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f12:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f16:	19 89       	ld.ub	r9,r12[0x0]
80004f18:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f1a:	19 3a       	ld.ub	r10,r12++
80004f1c:	1b e9       	ld.ub	r9,sp[0x6]
80004f1e:	f5 e9 20 09 	eor	r9,r10,r9
80004f22:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004f24:	16 38       	cp.w	r8,r11
80004f26:	cf 81       	brne	80004f16 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004f28:	1a 97       	mov	r7,sp
80004f2a:	fa ca ff f9 	sub	r10,sp,-7
80004f2e:	30 7b       	mov	r11,7
80004f30:	1a 9c       	mov	r12,sp
80004f32:	f0 1f 00 0d 	mcall	80004f64 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004f36:	30 8b       	mov	r11,8
80004f38:	16 9c       	mov	r12,r11
80004f3a:	f0 1f 00 0c 	mcall	80004f68 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f3e:	fa c8 ff ed 	sub	r8,sp,-19
80004f42:	1a 99       	mov	r9,sp
80004f44:	30 9a       	mov	r10,9
80004f46:	1a 9b       	mov	r11,sp
80004f48:	30 cc       	mov	r12,12
80004f4a:	f0 1f 00 09 	mcall	80004f6c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f4e:	c0 71       	brne	80004f5c <PcdSelect+0x60>
80004f50:	31 88       	mov	r8,24
80004f52:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f56:	f0 09 18 00 	cp.b	r9,r8
80004f5a:	c0 20       	breq	80004f5e <PcdSelect+0x62>
80004f5c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f5e:	2f bd       	sub	sp,-20
80004f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4e 70       	lddpc	r0,80005100 <rfid_sendID_message+0x40>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	4a 90       	lddpc	r0,8000500c <rfid_auto_reader+0x9c>
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	4c 10       	lddpc	r0,80005070 <rfid_auto_reader+0x100>

80004f70 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f70:	eb cd 40 c0 	pushm	r6-r7,lr
80004f74:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f76:	f0 1f 00 37 	mcall	80005050 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f7a:	4b 7b       	lddpc	r11,80005054 <rfid_auto_reader+0xe4>
80004f7c:	35 2c       	mov	r12,82
80004f7e:	f0 1f 00 37 	mcall	80005058 <rfid_auto_reader+0xe8>
80004f82:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f84:	c6 31       	brne	8000504a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f86:	4b 48       	lddpc	r8,80005054 <rfid_auto_reader+0xe4>
80004f88:	11 88       	ld.ub	r8,r8[0x0]
80004f8a:	30 49       	mov	r9,4
80004f8c:	f2 08 18 00 	cp.b	r8,r9
80004f90:	c0 b1       	brne	80004fa6 <rfid_auto_reader+0x36>
80004f92:	4b 19       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004f94:	13 9a       	ld.ub	r10,r9[0x1]
80004f96:	30 09       	mov	r9,0
80004f98:	f2 0a 18 00 	cp.b	r10,r9
80004f9c:	c0 51       	brne	80004fa6 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f9e:	4b 0c       	lddpc	r12,8000505c <rfid_auto_reader+0xec>
80004fa0:	f0 1f 00 30 	mcall	80005060 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004fa4:	c3 c8       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fa6:	30 29       	mov	r9,2
80004fa8:	f2 08 18 00 	cp.b	r8,r9
80004fac:	c0 b1       	brne	80004fc2 <rfid_auto_reader+0x52>
80004fae:	4a a9       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fb0:	13 9a       	ld.ub	r10,r9[0x1]
80004fb2:	30 09       	mov	r9,0
80004fb4:	f2 0a 18 00 	cp.b	r10,r9
80004fb8:	c0 51       	brne	80004fc2 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004fba:	4a bc       	lddpc	r12,80005064 <rfid_auto_reader+0xf4>
80004fbc:	f0 1f 00 29 	mcall	80005060 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fc0:	c2 e8       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fc2:	34 49       	mov	r9,68
80004fc4:	f2 08 18 00 	cp.b	r8,r9
80004fc8:	c0 b1       	brne	80004fde <rfid_auto_reader+0x6e>
80004fca:	4a 39       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fcc:	13 9a       	ld.ub	r10,r9[0x1]
80004fce:	30 09       	mov	r9,0
80004fd0:	f2 0a 18 00 	cp.b	r10,r9
80004fd4:	c0 51       	brne	80004fde <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004fd6:	4a 5c       	lddpc	r12,80005068 <rfid_auto_reader+0xf8>
80004fd8:	f0 1f 00 22 	mcall	80005060 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fdc:	c2 08       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fde:	30 89       	mov	r9,8
80004fe0:	f2 08 18 00 	cp.b	r8,r9
80004fe4:	c0 b1       	brne	80004ffa <rfid_auto_reader+0x8a>
80004fe6:	49 c9       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fe8:	13 9a       	ld.ub	r10,r9[0x1]
80004fea:	30 09       	mov	r9,0
80004fec:	f2 0a 18 00 	cp.b	r10,r9
80004ff0:	c0 51       	brne	80004ffa <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004ff2:	49 fc       	lddpc	r12,8000506c <rfid_auto_reader+0xfc>
80004ff4:	f0 1f 00 1b 	mcall	80005060 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ff8:	c1 28       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ffa:	34 49       	mov	r9,68
80004ffc:	f2 08 18 00 	cp.b	r8,r9
80005000:	c0 b1       	brne	80005016 <rfid_auto_reader+0xa6>
80005002:	49 58       	lddpc	r8,80005054 <rfid_auto_reader+0xe4>
80005004:	11 99       	ld.ub	r9,r8[0x1]
80005006:	30 38       	mov	r8,3
80005008:	f0 09 18 00 	cp.b	r9,r8
8000500c:	c0 51       	brne	80005016 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000500e:	49 9c       	lddpc	r12,80005070 <rfid_auto_reader+0x100>
80005010:	f0 1f 00 14 	mcall	80005060 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005014:	c0 48       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005016:	49 8c       	lddpc	r12,80005074 <rfid_auto_reader+0x104>
80005018:	f0 1f 00 12 	mcall	80005060 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000501c:	49 7c       	lddpc	r12,80005078 <rfid_auto_reader+0x108>
8000501e:	f0 1f 00 18 	mcall	8000507c <rfid_auto_reader+0x10c>
80005022:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005024:	c0 60       	breq	80005030 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80005026:	37 8b       	mov	r11,120
80005028:	30 1c       	mov	r12,1
8000502a:	f0 1f 00 16 	mcall	80005080 <rfid_auto_reader+0x110>
		return status;
8000502e:	c0 e8       	rjmp	8000504a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005030:	49 2c       	lddpc	r12,80005078 <rfid_auto_reader+0x108>
80005032:	f0 1f 00 15 	mcall	80005084 <rfid_auto_reader+0x114>
80005036:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005038:	c0 91       	brne	8000504a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
8000503a:	30 4a       	mov	r10,4
8000503c:	48 fb       	lddpc	r11,80005078 <rfid_auto_reader+0x108>
8000503e:	0c 9c       	mov	r12,r6
80005040:	f0 1f 00 12 	mcall	80005088 <rfid_auto_reader+0x118>
		log("select okay\n");
80005044:	49 2c       	lddpc	r12,8000508c <rfid_auto_reader+0x11c>
80005046:	f0 1f 00 07 	mcall	80005060 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000504a:	0e 9c       	mov	r12,r7
8000504c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	49 28       	lddpc	r8,80005098 <scan_patrol+0x8>
80005054:	00 00       	add	r0,r0
80005056:	53 b4       	stdsp	sp[0xec],r4
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	4e 0c       	lddpc	r12,800051d8 <rfid_sendID_message+0x118>
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	d8 38       	*unknown*
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	70 70       	ld.w	r0,r8[0x1c]
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	d8 44       	*unknown*
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	d8 50       	acall	0x85
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	d8 60       	acall	0x86
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	d8 68       	*unknown*
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	d8 74       	*unknown*
80005078:	00 00       	add	r0,r0
8000507a:	53 b8       	stdsp	sp[0xec],r8
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	4d 88       	lddpc	r8,800051dc <rfid_sendID_message+0x11c>
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	40 7c       	lddsp	r12,sp[0x1c]
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4e fc       	lddpc	r12,80005240 <delay_ns+0xc>
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	78 f4       	ld.w	r4,r12[0x3c]
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	d8 80       	acall	0x88

80005090 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005090:	eb cd 40 80 	pushm	r7,lr
80005094:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005096:	f0 1f 00 08 	mcall	800050b4 <scan_patrol+0x24>
	Powerdown_RC522(WAKEUP_RC522);
8000509a:	30 0c       	mov	r12,0
8000509c:	f0 1f 00 07 	mcall	800050b8 <scan_patrol+0x28>
	return_err = rfid_auto_reader(SN);
800050a0:	0e 9c       	mov	r12,r7
800050a2:	f0 1f 00 07 	mcall	800050bc <scan_patrol+0x2c>
800050a6:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800050a8:	30 1c       	mov	r12,1
800050aa:	f0 1f 00 04 	mcall	800050b8 <scan_patrol+0x28>
	//else
		//log("scan_patrol err!\n");
		
	return return_err;

}
800050ae:	0e 9c       	mov	r12,r7
800050b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	49 28       	lddpc	r8,800050fc <rfid_sendID_message+0x3c>
800050b8:	80 00       	ld.sh	r0,r0[0x0]
800050ba:	4a 00       	lddpc	r0,80005138 <rfid_sendID_message+0x78>
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	4f 70       	lddpc	r0,80005298 <delay_ms+0x24>

800050c0 <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
800050c0:	eb cd 40 e0 	pushm	r5-r7,lr
800050c4:	21 cd       	sub	sp,112
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800050c6:	4c ec       	lddpc	r12,800051fc <rfid_sendID_message+0x13c>
800050c8:	30 08       	mov	r8,0
800050ca:	30 09       	mov	r9,0
800050cc:	f8 e9 00 00 	st.d	r12[0],r8
800050d0:	30 0a       	mov	r10,0
800050d2:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800050d4:	fa e9 00 20 	st.d	sp[32],r8
800050d8:	fa e9 00 28 	st.d	sp[40],r8
800050dc:	fa e9 00 30 	st.d	sp[48],r8
800050e0:	fa e9 00 38 	st.d	sp[56],r8
800050e4:	fa e9 00 40 	st.d	sp[64],r8
800050e8:	fa e9 00 48 	st.d	sp[72],r8
800050ec:	fa e9 00 50 	st.d	sp[80],r8
800050f0:	fa e9 00 58 	st.d	sp[88],r8
800050f4:	fa e9 00 60 	st.d	sp[96],r8
800050f8:	fa e9 00 68 	st.d	sp[104],r8
	//PcdReset();
	//Powerdown_RC522(WAKEUP_RC522);
	//return_err = rfid_auto_reader(SN);
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	return_err = scan_patrol(SN);
800050fc:	f0 1f 00 41 	mcall	80005200 <rfid_sendID_message+0x140>
80005100:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005102:	c7 11       	brne	800051e4 <rfid_sendID_message+0x124>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005104:	4b e6       	lddpc	r6,800051fc <rfid_sendID_message+0x13c>
80005106:	0d b8       	ld.ub	r8,r6[0x3]
80005108:	1a d8       	st.w	--sp,r8
8000510a:	0d a8       	ld.ub	r8,r6[0x2]
8000510c:	1a d8       	st.w	--sp,r8
8000510e:	0d 98       	ld.ub	r8,r6[0x1]
80005110:	1a d8       	st.w	--sp,r8
80005112:	0d 88       	ld.ub	r8,r6[0x0]
80005114:	1a d8       	st.w	--sp,r8
80005116:	4b cc       	lddpc	r12,80005204 <rfid_sendID_message+0x144>
80005118:	f0 1f 00 3c 	mcall	80005208 <rfid_sendID_message+0x148>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
8000511c:	37 7b       	mov	r11,119
8000511e:	30 1c       	mov	r12,1
80005120:	f0 1f 00 3b 	mcall	8000520c <rfid_sendID_message+0x14c>
80005124:	fa c8 ff f0 	sub	r8,sp,-16
80005128:	fa c9 ff ee 	sub	r9,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
8000512c:	ec c5 ff fc 	sub	r5,r6,-4
80005130:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005132:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005134:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005136:	0d 8a       	ld.ub	r10,r6[0x0]
80005138:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000513c:	fc 0b 18 00 	cp.b	r11,lr
80005140:	f7 bb 08 d0 	subls	r11,-48
80005144:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005148:	f7 bb 0b a9 	subhi	r11,-87
8000514c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005150:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005152:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005156:	fc 0a 18 00 	cp.b	r10,lr
8000515a:	f7 ba 08 d0 	subls	r10,-48
8000515e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005162:	f7 ba 0b a9 	subhi	r10,-87
80005166:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000516a:	b0 bc       	st.b	r8[0x3],r12
8000516c:	2f f6       	sub	r6,-1
8000516e:	2f c8       	sub	r8,-4
80005170:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005172:	0a 36       	cp.w	r6,r5
80005174:	ce 11       	brne	80005136 <rfid_sendID_message+0x76>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005176:	30 6a       	mov	r10,6
80005178:	4a 6b       	lddpc	r11,80005210 <rfid_sendID_message+0x150>
8000517a:	fa cc ff f0 	sub	r12,sp,-16
8000517e:	f0 1f 00 26 	mcall	80005214 <rfid_sendID_message+0x154>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80005182:	4a 68       	lddpc	r8,80005218 <rfid_sendID_message+0x158>
80005184:	11 89       	ld.ub	r9,r8[0x0]
80005186:	39 f8       	mov	r8,-97
80005188:	f0 09 18 00 	cp.b	r9,r8
8000518c:	e0 88 00 05 	brls	80005196 <rfid_sendID_message+0xd6>
80005190:	38 09       	mov	r9,-128
80005192:	4a 28       	lddpc	r8,80005218 <rfid_sendID_message+0x158>
80005194:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005196:	4a 18       	lddpc	r8,80005218 <rfid_sendID_message+0x158>
80005198:	11 86       	ld.ub	r6,r8[0x0]
8000519a:	2f f6       	sub	r6,-1
8000519c:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000519e:	30 5a       	mov	r10,5
800051a0:	49 fb       	lddpc	r11,8000521c <rfid_sendID_message+0x15c>
800051a2:	fa cc ff e5 	sub	r12,sp,-27
800051a6:	f0 1f 00 1c 	mcall	80005214 <rfid_sendID_message+0x154>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800051aa:	31 e8       	mov	r8,30
800051ac:	fb 58 00 16 	st.h	sp[22],r8
800051b0:	fb 66 00 1a 	st.b	sp[26],r6
800051b4:	fe 78 e0 00 	mov	r8,-8192
800051b8:	fb 58 00 18 	st.h	sp[24],r8
800051bc:	fa c6 ff e0 	sub	r6,sp,-32
800051c0:	30 aa       	mov	r10,10
800051c2:	fa cb ff ea 	sub	r11,sp,-22
800051c6:	0c 9c       	mov	r12,r6
800051c8:	f0 1f 00 13 	mcall	80005214 <rfid_sendID_message+0x154>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800051cc:	31 6a       	mov	r10,22
800051ce:	1a 9b       	mov	r11,sp
800051d0:	fa cc ff d6 	sub	r12,sp,-42
800051d4:	f0 1f 00 10 	mcall	80005214 <rfid_sendID_message+0x154>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800051d8:	30 9a       	mov	r10,9
800051da:	32 0b       	mov	r11,32
800051dc:	0c 9c       	mov	r12,r6
800051de:	f0 1f 00 11 	mcall	80005220 <rfid_sendID_message+0x160>
800051e2:	c0 88       	rjmp	800051f2 <rfid_sendID_message+0x132>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800051e4:	37 8b       	mov	r11,120
800051e6:	30 1c       	mov	r12,1
800051e8:	f0 1f 00 09 	mcall	8000520c <rfid_sendID_message+0x14c>
		log("no card find...\n");
800051ec:	48 ec       	lddpc	r12,80005224 <rfid_sendID_message+0x164>
800051ee:	f0 1f 00 07 	mcall	80005208 <rfid_sendID_message+0x148>
	}
	
	return return_err;
	
}
800051f2:	0e 9c       	mov	r12,r7
800051f4:	2e 4d       	sub	sp,-112
800051f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051fa:	00 00       	add	r0,r0
800051fc:	00 00       	add	r0,r0
800051fe:	0b 68       	ld.uh	r8,--r5
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	50 90       	stdsp	sp[0x24],r0
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	d8 90       	acall	0x89
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	70 70       	ld.w	r0,r8[0x1c]
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	40 7c       	lddsp	r12,sp[0x1c]
80005210:	00 00       	add	r0,r0
80005212:	0d a4       	ld.ub	r4,r6[0x2]
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	78 f4       	ld.w	r4,r12[0x3c]
80005218:	00 00       	add	r0,r0
8000521a:	05 34       	ld.ub	r4,r2++
8000521c:	00 00       	add	r0,r0
8000521e:	05 2c       	ld.uh	r12,r2++
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	3f 44       	mov	r4,-12
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	d8 ac       	*unknown*

80005228 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80005228:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000522a:	f0 1f 00 02 	mcall	80005230 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000522e:	d8 02       	popm	pc
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	4b 38       	lddpc	r8,800052fc <local_start_pll0+0x34>

80005234 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005234:	58 0c       	cp.w	r12,0
80005236:	5e 0c       	reteq	r12
80005238:	30 08       	mov	r8,0
	{
		nop();
8000523a:	d7 03       	nop
		nop();
8000523c:	d7 03       	nop
		nop();
8000523e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005240:	2f f8       	sub	r8,-1
80005242:	10 3c       	cp.w	r12,r8
80005244:	fe 9b ff fb 	brhi	8000523a <delay_ns+0x6>
80005248:	5e fc       	retal	r12
8000524a:	d7 03       	nop

8000524c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000524c:	eb cd 40 e0 	pushm	r5-r7,lr
80005250:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005252:	58 0c       	cp.w	r12,0
80005254:	c0 b0       	breq	8000526a <delay_us+0x1e>
80005256:	30 07       	mov	r7,0
		delay_ns(1000);
80005258:	e0 65 03 e8 	mov	r5,1000
8000525c:	0a 9c       	mov	r12,r5
8000525e:	f0 1f 00 05 	mcall	80005270 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005262:	2f f7       	sub	r7,-1
80005264:	0e 36       	cp.w	r6,r7
80005266:	fe 9b ff fb 	brhi	8000525c <delay_us+0x10>
8000526a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000526e:	00 00       	add	r0,r0
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	52 34       	stdsp	sp[0x8c],r4

80005274 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005274:	eb cd 40 e0 	pushm	r5-r7,lr
80005278:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000527a:	58 0c       	cp.w	r12,0
8000527c:	c0 b0       	breq	80005292 <delay_ms+0x1e>
8000527e:	30 07       	mov	r7,0
		delay_us(1000);
80005280:	e0 65 03 e8 	mov	r5,1000
80005284:	0a 9c       	mov	r12,r5
80005286:	f0 1f 00 05 	mcall	80005298 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000528a:	2f f7       	sub	r7,-1
8000528c:	0e 36       	cp.w	r6,r7
8000528e:	fe 9b ff fb 	brhi	80005284 <delay_ms+0x10>
80005292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005296:	00 00       	add	r0,r0
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	52 4c       	stdsp	sp[0x90],r12

8000529c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
8000529c:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000529e:	30 3b       	mov	r11,3
800052a0:	48 8c       	lddpc	r12,800052c0 <local_start_timer+0x24>
800052a2:	f0 1f 00 09 	mcall	800052c4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800052a6:	fe 78 38 00 	mov	r8,-51200
800052aa:	e0 69 91 0d 	mov	r9,37133
800052ae:	ea 19 00 52 	orh	r9,0x52
800052b2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800052b4:	32 09       	mov	r9,32
800052b6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800052b8:	30 59       	mov	r9,5
800052ba:	91 09       	st.w	r8[0x0],r9
}
800052bc:	d8 02       	popm	pc
800052be:	00 00       	add	r0,r0
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	d8 c0       	acall	0x8c
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	54 54       	stdsp	sp[0x114],r4

800052c8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800052c8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800052ca:	30 3a       	mov	r10,3
800052cc:	e0 6b 1b 00 	mov	r11,6912
800052d0:	ea 1b 00 b7 	orh	r11,0xb7
800052d4:	fe 7c 0c 00 	mov	r12,-62464
800052d8:	f0 1f 00 19 	mcall	8000533c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800052dc:	31 08       	mov	r8,16
800052de:	1a d8       	st.w	--sp,r8
800052e0:	30 08       	mov	r8,0
800052e2:	30 19       	mov	r9,1
800052e4:	30 7a       	mov	r10,7
800052e6:	10 9b       	mov	r11,r8
800052e8:	fe 7c 0c 00 	mov	r12,-62464
800052ec:	f0 1f 00 15 	mcall	80005340 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800052f0:	30 08       	mov	r8,0
800052f2:	30 19       	mov	r9,1
800052f4:	12 9a       	mov	r10,r9
800052f6:	10 9b       	mov	r11,r8
800052f8:	fe 7c 0c 00 	mov	r12,-62464
800052fc:	f0 1f 00 12 	mcall	80005344 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005300:	30 0b       	mov	r11,0
80005302:	fe 7c 0c 00 	mov	r12,-62464
80005306:	f0 1f 00 11 	mcall	80005348 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000530a:	fe 7c 0c 00 	mov	r12,-62464
8000530e:	f0 1f 00 10 	mcall	8000534c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005312:	30 0a       	mov	r10,0
80005314:	1a da       	st.w	--sp,r10
80005316:	1a da       	st.w	--sp,r10
80005318:	14 98       	mov	r8,r10
8000531a:	14 99       	mov	r9,r10
8000531c:	30 1b       	mov	r11,1
8000531e:	fe 7c 0c 00 	mov	r12,-62464
80005322:	f0 1f 00 0c 	mcall	80005350 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005326:	30 1c       	mov	r12,1
80005328:	f0 1f 00 0b 	mcall	80005354 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000532c:	30 2b       	mov	r11,2
8000532e:	fe 7c 0c 00 	mov	r12,-62464
80005332:	f0 1f 00 0a 	mcall	80005358 <local_start_pll0+0x90>
80005336:	2f dd       	sub	sp,-12
/****/
}
80005338:	d8 02       	popm	pc
8000533a:	00 00       	add	r0,r0
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	57 5c       	stdsp	sp[0x1d4],r12
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	56 fe       	stdsp	sp[0x1bc],lr
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	57 20       	stdsp	sp[0x1c8],r0
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	57 3a       	stdsp	sp[0x1cc],r10
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	57 48       	stdsp	sp[0x1d0],r8
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	56 b8       	stdsp	sp[0x1ac],r8
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	53 f4       	stdsp	sp[0xfc],r4
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	57 52       	stdsp	sp[0x1d4],r2

8000535c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
8000535c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005360:	f0 1f 00 1a 	mcall	800053c8 <xg_flashc_init+0x6c>
80005364:	49 a8       	lddpc	r8,800053cc <xg_flashc_init+0x70>
80005366:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005368:	70 08       	ld.w	r8,r8[0x0]
8000536a:	58 08       	cp.w	r8,0
8000536c:	c0 41       	brne	80005374 <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
8000536e:	49 9c       	lddpc	r12,800053d0 <xg_flashc_init+0x74>
80005370:	f0 1f 00 19 	mcall	800053d4 <xg_flashc_init+0x78>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005374:	30 0b       	mov	r11,0
80005376:	30 1c       	mov	r12,1
80005378:	f0 1f 00 18 	mcall	800053d8 <xg_flashc_init+0x7c>
8000537c:	49 88       	lddpc	r8,800053dc <xg_flashc_init+0x80>
8000537e:	91 0c       	st.w	r8[0x0],r12
80005380:	70 08       	ld.w	r8,r8[0x0]
80005382:	58 08       	cp.w	r8,0
80005384:	c0 80       	breq	80005394 <xg_flashc_init+0x38>
80005386:	49 68       	lddpc	r8,800053dc <xg_flashc_init+0x80>
80005388:	70 0c       	ld.w	r12,r8[0x0]
8000538a:	30 09       	mov	r9,0
8000538c:	12 9a       	mov	r10,r9
8000538e:	12 9b       	mov	r11,r9
80005390:	f0 1f 00 14 	mcall	800053e0 <xg_flashc_init+0x84>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80005394:	30 4b       	mov	r11,4
80005396:	31 4c       	mov	r12,20
80005398:	f0 1f 00 10 	mcall	800053d8 <xg_flashc_init+0x7c>
8000539c:	49 28       	lddpc	r8,800053e4 <xg_flashc_init+0x88>
8000539e:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
800053a0:	30 4b       	mov	r11,4
800053a2:	31 4c       	mov	r12,20
800053a4:	f0 1f 00 0d 	mcall	800053d8 <xg_flashc_init+0x7c>
800053a8:	49 08       	lddpc	r8,800053e8 <xg_flashc_init+0x8c>
800053aa:	91 0c       	st.w	r8[0x0],r12
800053ac:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800053ae:	10 96       	mov	r6,r8
800053b0:	48 f5       	lddpc	r5,800053ec <xg_flashc_init+0x90>
800053b2:	6c 0c       	ld.w	r12,r6[0x0]
800053b4:	ea 07 00 0b 	add	r11,r5,r7
800053b8:	f0 1f 00 0e 	mcall	800053f0 <xg_flashc_init+0x94>
800053bc:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
800053be:	e0 47 02 80 	cp.w	r7,640
800053c2:	cf 81       	brne	800053b2 <xg_flashc_init+0x56>
	
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	//create_xg_flash_test_task();

}
800053c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	65 38       	ld.w	r8,r2[0x4c]
800053cc:	00 00       	add	r0,r0
800053ce:	0b 78       	ld.ub	r8,--r5
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	d8 d8       	*unknown*
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	70 70       	ld.w	r0,r8[0x1c]
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	65 90       	ld.w	r0,r2[0x64]
800053dc:	00 00       	add	r0,r0
800053de:	53 bc       	stdsp	sp[0xec],r12
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	64 38       	ld.w	r8,r2[0xc]
800053e4:	00 00       	add	r0,r0
800053e6:	0b 74       	ld.ub	r4,--r5
800053e8:	00 00       	add	r0,r0
800053ea:	0b 7c       	ld.ub	r12,--r5
800053ec:	00 00       	add	r0,r0
800053ee:	0d aa       	ld.ub	r10,r6[0x2]
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	2c 0c       	sub	r12,-64

800053f4 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800053f4:	fe 68 14 00 	mov	r8,-125952
800053f8:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800053fa:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800053fe:	91 09       	st.w	r8[0x0],r9
}
80005400:	5e fc       	retal	r12

80005402 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005402:	f8 08 16 05 	lsr	r8,r12,0x5
80005406:	a9 68       	lsl	r8,0x8
80005408:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000540c:	58 1b       	cp.w	r11,1
8000540e:	c0 d0       	breq	80005428 <gpio_enable_module_pin+0x26>
80005410:	c0 63       	brcs	8000541c <gpio_enable_module_pin+0x1a>
80005412:	58 2b       	cp.w	r11,2
80005414:	c1 00       	breq	80005434 <gpio_enable_module_pin+0x32>
80005416:	58 3b       	cp.w	r11,3
80005418:	c1 40       	breq	80005440 <gpio_enable_module_pin+0x3e>
8000541a:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000541c:	30 19       	mov	r9,1
8000541e:	f2 0c 09 49 	lsl	r9,r9,r12
80005422:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005424:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005426:	c1 28       	rjmp	8000544a <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005428:	30 19       	mov	r9,1
8000542a:	f2 0c 09 49 	lsl	r9,r9,r12
8000542e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005430:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005432:	c0 c8       	rjmp	8000544a <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005434:	30 19       	mov	r9,1
80005436:	f2 0c 09 49 	lsl	r9,r9,r12
8000543a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000543c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000543e:	c0 68       	rjmp	8000544a <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005440:	30 19       	mov	r9,1
80005442:	f2 0c 09 49 	lsl	r9,r9,r12
80005446:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005448:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000544a:	30 19       	mov	r9,1
8000544c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005450:	91 2c       	st.w	r8[0x8],r12
80005452:	5e fd       	retal	0

80005454 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005454:	d4 21       	pushm	r4-r7,lr
80005456:	18 97       	mov	r7,r12
80005458:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000545a:	58 0b       	cp.w	r11,0
8000545c:	c0 31       	brne	80005462 <gpio_enable_module+0xe>
8000545e:	30 05       	mov	r5,0
80005460:	c0 d8       	rjmp	8000547a <gpio_enable_module+0x26>
80005462:	30 06       	mov	r6,0
80005464:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005466:	6e 1b       	ld.w	r11,r7[0x4]
80005468:	6e 0c       	ld.w	r12,r7[0x0]
8000546a:	f0 1f 00 06 	mcall	80005480 <gpio_enable_module+0x2c>
8000546e:	18 45       	or	r5,r12
		gpiomap++;
80005470:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005472:	2f f6       	sub	r6,-1
80005474:	0c 34       	cp.w	r4,r6
80005476:	fe 9b ff f8 	brhi	80005466 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000547a:	0a 9c       	mov	r12,r5
8000547c:	d8 22       	popm	r4-r7,pc
8000547e:	00 00       	add	r0,r0
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	54 02       	stdsp	sp[0x100],r2

80005484 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005484:	f8 08 16 05 	lsr	r8,r12,0x5
80005488:	a9 68       	lsl	r8,0x8
8000548a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000548e:	30 19       	mov	r9,1
80005490:	f2 0c 09 4c 	lsl	r12,r9,r12
80005494:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005498:	91 1c       	st.w	r8[0x4],r12
}
8000549a:	5e fc       	retal	r12

8000549c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000549c:	f8 08 16 05 	lsr	r8,r12,0x5
800054a0:	a9 68       	lsl	r8,0x8
800054a2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800054a6:	30 19       	mov	r9,1
800054a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800054ac:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800054b0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800054b4:	91 1c       	st.w	r8[0x4],r12
}
800054b6:	5e fc       	retal	r12

800054b8 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054b8:	f8 08 16 05 	lsr	r8,r12,0x5
800054bc:	a9 68       	lsl	r8,0x8
800054be:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800054c2:	30 19       	mov	r9,1
800054c4:	f2 0c 09 4c 	lsl	r12,r9,r12
800054c8:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800054cc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800054d0:	91 1c       	st.w	r8[0x4],r12
}
800054d2:	5e fc       	retal	r12

800054d4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800054d4:	c0 08       	rjmp	800054d4 <_unhandled_interrupt>
800054d6:	d7 03       	nop

800054d8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800054d8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800054dc:	49 99       	lddpc	r9,80005540 <INTC_register_interrupt+0x68>
800054de:	f2 08 00 39 	add	r9,r9,r8<<0x3
800054e2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800054e6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800054e8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800054ec:	58 0a       	cp.w	r10,0
800054ee:	c0 91       	brne	80005500 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054f0:	49 59       	lddpc	r9,80005544 <INTC_register_interrupt+0x6c>
800054f2:	49 6a       	lddpc	r10,80005548 <INTC_register_interrupt+0x70>
800054f4:	12 1a       	sub	r10,r9
800054f6:	fe 79 08 00 	mov	r9,-63488
800054fa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054fe:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005500:	58 1a       	cp.w	r10,1
80005502:	c0 a1       	brne	80005516 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005504:	49 09       	lddpc	r9,80005544 <INTC_register_interrupt+0x6c>
80005506:	49 2a       	lddpc	r10,8000554c <INTC_register_interrupt+0x74>
80005508:	12 1a       	sub	r10,r9
8000550a:	bf aa       	sbr	r10,0x1e
8000550c:	fe 79 08 00 	mov	r9,-63488
80005510:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005514:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005516:	58 2a       	cp.w	r10,2
80005518:	c0 a1       	brne	8000552c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000551a:	48 b9       	lddpc	r9,80005544 <INTC_register_interrupt+0x6c>
8000551c:	48 da       	lddpc	r10,80005550 <INTC_register_interrupt+0x78>
8000551e:	12 1a       	sub	r10,r9
80005520:	bf ba       	sbr	r10,0x1f
80005522:	fe 79 08 00 	mov	r9,-63488
80005526:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000552a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000552c:	48 69       	lddpc	r9,80005544 <INTC_register_interrupt+0x6c>
8000552e:	48 aa       	lddpc	r10,80005554 <INTC_register_interrupt+0x7c>
80005530:	12 1a       	sub	r10,r9
80005532:	ea 1a c0 00 	orh	r10,0xc000
80005536:	fe 79 08 00 	mov	r9,-63488
8000553a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000553e:	5e fc       	retal	r12
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	d9 88       	*unknown*
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	ce 00       	breq	80005506 <INTC_register_interrupt+0x2e>
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	cf 04       	brge	8000552a <INTC_register_interrupt+0x52>
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	cf 12       	brcc	80005530 <INTC_register_interrupt+0x58>
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	cf 20       	breq	80005536 <INTC_register_interrupt+0x5e>
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	cf 2e       	rcall	8000533a <local_start_pll0+0x72>

80005558 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005558:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000555a:	49 18       	lddpc	r8,8000559c <INTC_init_interrupts+0x44>
8000555c:	e3 b8 00 01 	mtsr	0x4,r8
80005560:	49 0e       	lddpc	lr,800055a0 <INTC_init_interrupts+0x48>
80005562:	30 07       	mov	r7,0
80005564:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005566:	49 0c       	lddpc	r12,800055a4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005568:	49 05       	lddpc	r5,800055a8 <INTC_init_interrupts+0x50>
8000556a:	10 15       	sub	r5,r8
8000556c:	fe 76 08 00 	mov	r6,-63488
80005570:	c1 08       	rjmp	80005590 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005572:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005574:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005576:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005578:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000557c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000557e:	10 3a       	cp.w	r10,r8
80005580:	fe 9b ff fc 	brhi	80005578 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005584:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005588:	2f f7       	sub	r7,-1
8000558a:	2f 8e       	sub	lr,-8
8000558c:	59 37       	cp.w	r7,19
8000558e:	c0 50       	breq	80005598 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005590:	7c 08       	ld.w	r8,lr[0x0]
80005592:	58 08       	cp.w	r8,0
80005594:	ce f1       	brne	80005572 <INTC_init_interrupts+0x1a>
80005596:	cf 7b       	rjmp	80005584 <INTC_init_interrupts+0x2c>
80005598:	d8 22       	popm	r4-r7,pc
8000559a:	00 00       	add	r0,r0
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	ce 00       	breq	8000555e <INTC_init_interrupts+0x6>
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	d9 88       	*unknown*
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	54 d4       	stdsp	sp[0x134],r4
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	cf 04       	brge	8000558a <INTC_init_interrupts+0x32>

800055ac <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800055ac:	fe 78 08 00 	mov	r8,-63488
800055b0:	e0 69 00 83 	mov	r9,131
800055b4:	f2 0c 01 0c 	sub	r12,r9,r12
800055b8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800055bc:	f2 ca ff c0 	sub	r10,r9,-64
800055c0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800055c4:	58 08       	cp.w	r8,0
800055c6:	c0 21       	brne	800055ca <_get_interrupt_handler+0x1e>
800055c8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800055ca:	f0 08 12 00 	clz	r8,r8
800055ce:	48 5a       	lddpc	r10,800055e0 <_get_interrupt_handler+0x34>
800055d0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800055d4:	f0 08 11 1f 	rsub	r8,r8,31
800055d8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800055da:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800055de:	5e fc       	retal	r12
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	d9 88       	*unknown*

800055e4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800055e4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800055e6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800055ea:	99 a8       	st.w	r12[0x28],r8
}
800055ec:	5e fc       	retal	r12
800055ee:	d7 03       	nop

800055f0 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800055f0:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800055f2:	ec 5b bb 9f 	cp.w	r11,899999
800055f6:	e0 8b 00 04 	brhi	800055fe <pm_enable_osc0_crystal+0xe>
800055fa:	30 4b       	mov	r11,4
800055fc:	c1 38       	rjmp	80005622 <pm_enable_osc0_crystal+0x32>
800055fe:	e0 68 c6 bf 	mov	r8,50879
80005602:	ea 18 00 2d 	orh	r8,0x2d
80005606:	10 3b       	cp.w	r11,r8
80005608:	e0 8b 00 04 	brhi	80005610 <pm_enable_osc0_crystal+0x20>
8000560c:	30 5b       	mov	r11,5
8000560e:	c0 a8       	rjmp	80005622 <pm_enable_osc0_crystal+0x32>
80005610:	e0 68 12 00 	mov	r8,4608
80005614:	ea 18 00 7a 	orh	r8,0x7a
80005618:	10 3b       	cp.w	r11,r8
8000561a:	f9 bb 03 06 	movlo	r11,6
8000561e:	f9 bb 02 07 	movhs	r11,7
80005622:	f0 1f 00 02 	mcall	80005628 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005626:	d8 02       	popm	pc
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	55 e4       	stdsp	sp[0x178],r4

8000562c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000562c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000562e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005632:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005634:	78 08       	ld.w	r8,r12[0x0]
80005636:	a3 a8       	sbr	r8,0x2
80005638:	99 08       	st.w	r12[0x0],r8
}
8000563a:	5e fc       	retal	r12

8000563c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000563c:	79 58       	ld.w	r8,r12[0x54]
8000563e:	e2 18 00 80 	andl	r8,0x80,COH
80005642:	cf d0       	breq	8000563c <pm_wait_for_clk0_ready>
}
80005644:	5e fc       	retal	r12
80005646:	d7 03       	nop

80005648 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005648:	eb cd 40 80 	pushm	r7,lr
8000564c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000564e:	f0 1f 00 04 	mcall	8000565c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005652:	0e 9c       	mov	r12,r7
80005654:	f0 1f 00 03 	mcall	80005660 <pm_enable_clk0+0x18>
}
80005658:	e3 cd 80 80 	ldm	sp++,r7,pc
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	56 2c       	stdsp	sp[0x188],r12
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	56 3c       	stdsp	sp[0x18c],r12

80005664 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005664:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005666:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000566a:	99 c8       	st.w	r12[0x30],r8
}
8000566c:	5e fc       	retal	r12
8000566e:	d7 03       	nop

80005670 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005670:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80005672:	30 1b       	mov	r11,1
80005674:	f0 1f 00 02 	mcall	8000567c <pm_enable_osc32_crystal+0xc>
}
80005678:	d8 02       	popm	pc
8000567a:	00 00       	add	r0,r0
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	56 64       	stdsp	sp[0x198],r4

80005680 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005680:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80005682:	30 19       	mov	r9,1
80005684:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005688:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000568c:	99 c8       	st.w	r12[0x30],r8
}
8000568e:	5e fc       	retal	r12

80005690 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005690:	79 58       	ld.w	r8,r12[0x54]
80005692:	e2 18 02 00 	andl	r8,0x200,COH
80005696:	cf d0       	breq	80005690 <pm_wait_for_clk32_ready>
}
80005698:	5e fc       	retal	r12
8000569a:	d7 03       	nop

8000569c <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
8000569c:	eb cd 40 80 	pushm	r7,lr
800056a0:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
800056a2:	f0 1f 00 04 	mcall	800056b0 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
800056a6:	0e 9c       	mov	r12,r7
800056a8:	f0 1f 00 03 	mcall	800056b4 <pm_enable_clk32+0x18>
}
800056ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800056b0:	80 00       	ld.sh	r0,r0[0x0]
800056b2:	56 80       	stdsp	sp[0x1a0],r0
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	56 90       	stdsp	sp[0x1a4],r0

800056b8 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800056b8:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800056bc:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800056c0:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800056c2:	09 f7       	ld.ub	r7,r4[0x7]
800056c4:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800056c8:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800056cc:	09 b4       	ld.ub	r4,r4[0x3]
800056ce:	08 96       	mov	r6,r4
800056d0:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800056d4:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800056d8:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800056dc:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800056e0:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800056e4:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800056e8:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800056ec:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800056f0:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800056f2:	79 58       	ld.w	r8,r12[0x54]
800056f4:	e2 18 00 20 	andl	r8,0x20,COH
800056f8:	cf d0       	breq	800056f2 <pm_cksel+0x3a>
}
800056fa:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800056fe <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800056fe:	eb cd 40 80 	pushm	r7,lr
80005702:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005704:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005706:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000570a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000570e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005712:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005716:	2f 8b       	sub	r11,-8
80005718:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000571c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005720 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005720:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005722:	2f 8b       	sub	r11,-8
80005724:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005728:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000572c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005730:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005734:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005738:	d8 02       	popm	pc

8000573a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000573a:	2f 8b       	sub	r11,-8
8000573c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005740:	a1 a8       	sbr	r8,0x0
80005742:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005746:	5e fc       	retal	r12

80005748 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005748:	79 58       	ld.w	r8,r12[0x54]
8000574a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000574e:	cf d0       	breq	80005748 <pm_wait_for_pll0_locked>
}
80005750:	5e fc       	retal	r12

80005752 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005752:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005754:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005758:	99 08       	st.w	r12[0x0],r8
}
8000575a:	5e fc       	retal	r12

8000575c <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
8000575c:	eb cd 40 c0 	pushm	r6-r7,lr
80005760:	18 97       	mov	r7,r12
80005762:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005764:	f0 1f 00 06 	mcall	8000577c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005768:	0c 9b       	mov	r11,r6
8000576a:	0e 9c       	mov	r12,r7
8000576c:	f0 1f 00 05 	mcall	80005780 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005770:	30 1b       	mov	r11,1
80005772:	0e 9c       	mov	r12,r7
80005774:	f0 1f 00 04 	mcall	80005784 <pm_switch_to_osc0+0x28>
}
80005778:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	55 f0       	stdsp	sp[0x17c],r0
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	56 48       	stdsp	sp[0x190],r8
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	57 52       	stdsp	sp[0x1d4],r2

80005788 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005788:	78 0c       	ld.w	r12,r12[0x0]
}
8000578a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000578e:	5e fc       	retal	r12

80005790 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005790:	eb cd 40 c0 	pushm	r6-r7,lr
80005794:	18 97       	mov	r7,r12
80005796:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005798:	0e 9c       	mov	r12,r7
8000579a:	f0 1f 00 06 	mcall	800057b0 <rtc_set_value+0x20>
8000579e:	cf d1       	brne	80005798 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
800057a0:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800057a2:	0e 9c       	mov	r12,r7
800057a4:	f0 1f 00 03 	mcall	800057b0 <rtc_set_value+0x20>
800057a8:	cf d1       	brne	800057a2 <rtc_set_value+0x12>
}
800057aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057ae:	00 00       	add	r0,r0
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	57 88       	stdsp	sp[0x1e0],r8

800057b4 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800057b4:	eb cd 40 80 	pushm	r7,lr
800057b8:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800057ba:	0e 9c       	mov	r12,r7
800057bc:	f0 1f 00 06 	mcall	800057d4 <rtc_enable+0x20>
800057c0:	cf d1       	brne	800057ba <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800057c2:	6e 08       	ld.w	r8,r7[0x0]
800057c4:	a1 a8       	sbr	r8,0x0
800057c6:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800057c8:	0e 9c       	mov	r12,r7
800057ca:	f0 1f 00 03 	mcall	800057d4 <rtc_enable+0x20>
800057ce:	cf d1       	brne	800057c8 <rtc_enable+0x14>
}
800057d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	57 88       	stdsp	sp[0x1e0],r8

800057d8 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800057d8:	30 18       	mov	r8,1
800057da:	99 48       	st.w	r12[0x10],r8
}
800057dc:	5e fc       	retal	r12
800057de:	d7 03       	nop

800057e0 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800057e0:	eb cd 40 c0 	pushm	r6-r7,lr
800057e4:	18 97       	mov	r7,r12
800057e6:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800057e8:	0e 9c       	mov	r12,r7
800057ea:	f0 1f 00 06 	mcall	80005800 <rtc_set_top_value+0x20>
800057ee:	cf d1       	brne	800057e8 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800057f0:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800057f2:	0e 9c       	mov	r12,r7
800057f4:	f0 1f 00 03 	mcall	80005800 <rtc_set_top_value+0x20>
800057f8:	cf d1       	brne	800057f2 <rtc_set_top_value+0x12>
}
800057fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057fe:	00 00       	add	r0,r0
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	57 88       	stdsp	sp[0x1e0],r8

80005804 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005804:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005808:	e6 18 00 01 	andh	r8,0x1,COH
8000580c:	c0 71       	brne	8000581a <rtc_clear_interrupt+0x16>
8000580e:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005810:	30 18       	mov	r8,1
80005812:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005814:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80005816:	d5 03       	csrf	0x10
80005818:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000581a:	30 18       	mov	r8,1
8000581c:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000581e:	78 78       	ld.w	r8,r12[0x1c]
80005820:	5e fc       	retal	r12
80005822:	d7 03       	nop

80005824 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005824:	eb cd 40 e0 	pushm	r5-r7,lr
80005828:	18 97       	mov	r7,r12
8000582a:	16 96       	mov	r6,r11
8000582c:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000582e:	30 18       	mov	r8,1
80005830:	f0 0b 18 00 	cp.b	r11,r8
80005834:	5f b9       	srhi	r9
80005836:	30 f8       	mov	r8,15
80005838:	f0 0a 18 00 	cp.b	r10,r8
8000583c:	5f b8       	srhi	r8
8000583e:	f3 e8 10 08 	or	r8,r9,r8
80005842:	c0 30       	breq	80005848 <rtc_init+0x24>
80005844:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80005848:	30 18       	mov	r8,1
8000584a:	f0 0b 18 00 	cp.b	r11,r8
8000584e:	c0 a1       	brne	80005862 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80005850:	fe 7c 0c 00 	mov	r12,-62464
80005854:	f0 1f 00 0f 	mcall	80005890 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80005858:	30 0b       	mov	r11,0
8000585a:	fe 7c 0c 00 	mov	r12,-62464
8000585e:	f0 1f 00 0e 	mcall	80005894 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80005862:	0e 9c       	mov	r12,r7
80005864:	f0 1f 00 0d 	mcall	80005898 <rtc_init+0x74>
80005868:	cf d1       	brne	80005862 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
8000586a:	a3 76       	lsl	r6,0x3
8000586c:	b1 a6       	sbr	r6,0x10
8000586e:	ed e5 10 85 	or	r5,r6,r5<<0x8
80005872:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80005874:	0e 9c       	mov	r12,r7
80005876:	f0 1f 00 09 	mcall	80005898 <rtc_init+0x74>
8000587a:	cf d1       	brne	80005874 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
8000587c:	30 0b       	mov	r11,0
8000587e:	0e 9c       	mov	r12,r7
80005880:	f0 1f 00 07 	mcall	8000589c <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80005884:	3f fb       	mov	r11,-1
80005886:	0e 9c       	mov	r12,r7
80005888:	f0 1f 00 06 	mcall	800058a0 <rtc_init+0x7c>
8000588c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	56 70       	stdsp	sp[0x19c],r0
80005894:	80 00       	ld.sh	r0,r0[0x0]
80005896:	56 9c       	stdsp	sp[0x1a4],r12
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	57 88       	stdsp	sp[0x1e0],r8
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	57 90       	stdsp	sp[0x1e4],r0
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	57 e0       	stdsp	sp[0x1f8],r0

800058a4 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800058a4:	f8 c8 00 01 	sub	r8,r12,1
800058a8:	f0 0b 00 0b 	add	r11,r8,r11
800058ac:	f6 0c 0d 0a 	divu	r10,r11,r12
800058b0:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800058b2:	f4 c8 00 01 	sub	r8,r10,1
800058b6:	e0 48 00 fe 	cp.w	r8,254
800058ba:	e0 88 00 03 	brls	800058c0 <getBaudDiv+0x1c>
800058be:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800058c0:	5c 8c       	casts.h	r12
}
800058c2:	5e fc       	retal	r12

800058c4 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800058c4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058c8:	30 18       	mov	r8,1
800058ca:	f0 09 18 00 	cp.b	r9,r8
800058ce:	e0 88 00 04 	brls	800058d6 <spi_initMaster+0x12>
800058d2:	30 2c       	mov	r12,2
800058d4:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800058d6:	e0 68 00 80 	mov	r8,128
800058da:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800058dc:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800058de:	30 19       	mov	r9,1
800058e0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800058e4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058e8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800058ec:	30 09       	mov	r9,0
800058ee:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800058f2:	30 fa       	mov	r10,15
800058f4:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800058f8:	99 18       	st.w	r12[0x4],r8
800058fa:	5e f9       	retal	r9

800058fc <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800058fc:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800058fe:	30 18       	mov	r8,1
80005900:	f0 0b 18 00 	cp.b	r11,r8
80005904:	5f be       	srhi	lr
80005906:	f0 0a 18 00 	cp.b	r10,r8
8000590a:	5f b8       	srhi	r8
8000590c:	fd e8 10 08 	or	r8,lr,r8
80005910:	c0 30       	breq	80005916 <spi_selectionMode+0x1a>
80005912:	30 2c       	mov	r12,2
80005914:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005916:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005918:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000591c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005920:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005924:	99 18       	st.w	r12[0x4],r8
80005926:	d8 0a       	popm	pc,r12=0

80005928 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005928:	30 18       	mov	r8,1
8000592a:	99 08       	st.w	r12[0x0],r8
}
8000592c:	5e fc       	retal	r12

8000592e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000592e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005932:	c0 58       	rjmp	8000593c <spi_write+0xe>
		if (!timeout--) {
80005934:	58 08       	cp.w	r8,0
80005936:	c0 21       	brne	8000593a <spi_write+0xc>
80005938:	5e ff       	retal	1
8000593a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000593c:	78 49       	ld.w	r9,r12[0x10]
8000593e:	e2 19 00 02 	andl	r9,0x2,COH
80005942:	cf 90       	breq	80005934 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005944:	5c 7b       	castu.h	r11
80005946:	99 3b       	st.w	r12[0xc],r11
80005948:	5e fd       	retal	0

8000594a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000594a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000594e:	c0 58       	rjmp	80005958 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005950:	58 08       	cp.w	r8,0
80005952:	c0 21       	brne	80005956 <spi_read+0xc>
80005954:	5e ff       	retal	1
80005956:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005958:	78 49       	ld.w	r9,r12[0x10]
8000595a:	e2 19 02 01 	andl	r9,0x201,COH
8000595e:	e0 49 02 01 	cp.w	r9,513
80005962:	cf 71       	brne	80005950 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005964:	78 28       	ld.w	r8,r12[0x8]
80005966:	b6 08       	st.h	r11[0x0],r8
80005968:	5e fd       	retal	0
8000596a:	d7 03       	nop

8000596c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000596c:	eb cd 40 f8 	pushm	r3-r7,lr
80005970:	18 95       	mov	r5,r12
80005972:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005974:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005978:	30 38       	mov	r8,3
8000597a:	f0 06 18 00 	cp.b	r6,r8
8000597e:	e0 8b 00 5e 	brhi	80005a3a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005982:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005986:	30 18       	mov	r8,1
80005988:	f0 04 18 00 	cp.b	r4,r8
8000598c:	e0 8b 00 57 	brhi	80005a3a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005990:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005994:	30 78       	mov	r8,7
80005996:	f0 03 18 00 	cp.b	r3,r8
8000599a:	e0 88 00 50 	brls	80005a3a <spi_setupChipReg+0xce>
8000599e:	31 08       	mov	r8,16
800059a0:	f0 03 18 00 	cp.b	r3,r8
800059a4:	e0 8b 00 4b 	brhi	80005a3a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800059a8:	14 9b       	mov	r11,r10
800059aa:	6e 1c       	ld.w	r12,r7[0x4]
800059ac:	f0 1f 00 26 	mcall	80005a44 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800059b0:	c4 55       	brlt	80005a3a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800059b2:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800059b4:	ec 09 16 01 	lsr	r9,r6,0x1
800059b8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800059bc:	ec 16 00 01 	eorl	r6,0x1
800059c0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800059c4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800059c8:	20 83       	sub	r3,8
800059ca:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800059ce:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800059d2:	ef 39 00 09 	ld.ub	r9,r7[9]
800059d6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800059da:	ef 39 00 0a 	ld.ub	r9,r7[10]
800059de:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800059e2:	0f 89       	ld.ub	r9,r7[0x0]
800059e4:	30 1a       	mov	r10,1
800059e6:	f4 09 18 00 	cp.b	r9,r10
800059ea:	c0 d0       	breq	80005a04 <spi_setupChipReg+0x98>
800059ec:	c0 a3       	brcs	80005a00 <spi_setupChipReg+0x94>
800059ee:	30 2a       	mov	r10,2
800059f0:	f4 09 18 00 	cp.b	r9,r10
800059f4:	c0 a0       	breq	80005a08 <spi_setupChipReg+0x9c>
800059f6:	30 3a       	mov	r10,3
800059f8:	f4 09 18 00 	cp.b	r9,r10
800059fc:	c1 f1       	brne	80005a3a <spi_setupChipReg+0xce>
800059fe:	c0 78       	rjmp	80005a0c <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005a00:	8b c8       	st.w	r5[0x30],r8
		break;
80005a02:	c0 68       	rjmp	80005a0e <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005a04:	8b d8       	st.w	r5[0x34],r8
		break;
80005a06:	c0 48       	rjmp	80005a0e <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005a08:	8b e8       	st.w	r5[0x38],r8
		break;
80005a0a:	c0 28       	rjmp	80005a0e <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005a0c:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005a0e:	48 f8       	lddpc	r8,80005a48 <spi_setupChipReg+0xdc>
80005a10:	70 08       	ld.w	r8,r8[0x0]
80005a12:	58 08       	cp.w	r8,0
80005a14:	c1 61       	brne	80005a40 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005a16:	30 0b       	mov	r11,0
80005a18:	30 1c       	mov	r12,1
80005a1a:	f0 1f 00 0d 	mcall	80005a4c <spi_setupChipReg+0xe0>
80005a1e:	48 b8       	lddpc	r8,80005a48 <spi_setupChipReg+0xdc>
80005a20:	91 0c       	st.w	r8[0x0],r12
80005a22:	58 0c       	cp.w	r12,0
80005a24:	c0 a0       	breq	80005a38 <spi_setupChipReg+0xcc>
80005a26:	30 09       	mov	r9,0
80005a28:	12 9a       	mov	r10,r9
80005a2a:	12 9b       	mov	r11,r9
80005a2c:	f0 1f 00 09 	mcall	80005a50 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005a30:	48 68       	lddpc	r8,80005a48 <spi_setupChipReg+0xdc>
80005a32:	70 08       	ld.w	r8,r8[0x0]
80005a34:	58 08       	cp.w	r8,0
80005a36:	c0 51       	brne	80005a40 <spi_setupChipReg+0xd4>
80005a38:	c0 08       	rjmp	80005a38 <spi_setupChipReg+0xcc>
80005a3a:	30 2c       	mov	r12,2
80005a3c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a40:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	58 a4       	cp.w	r4,10
80005a48:	00 00       	add	r0,r0
80005a4a:	53 c4       	stdsp	sp[0xf0],r4
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	65 90       	ld.w	r0,r2[0x64]
80005a50:	80 00       	ld.sh	r0,r0[0x0]
80005a52:	64 38       	ld.w	r8,r2[0xc]

80005a54 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a54:	d4 01       	pushm	lr
80005a56:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a5a:	c0 58       	rjmp	80005a64 <spi_unselectChip+0x10>
		if (!timeout--) {
80005a5c:	58 08       	cp.w	r8,0
80005a5e:	c0 21       	brne	80005a62 <spi_unselectChip+0xe>
80005a60:	da 0a       	popm	pc,r12=1
80005a62:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a64:	78 49       	ld.w	r9,r12[0x10]
80005a66:	e2 19 02 00 	andl	r9,0x200,COH
80005a6a:	cf 90       	breq	80005a5c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a6c:	78 18       	ld.w	r8,r12[0x4]
80005a6e:	ea 18 00 0f 	orh	r8,0xf
80005a72:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a74:	fc 18 01 00 	movh	r8,0x100
80005a78:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005a7a:	30 09       	mov	r9,0
80005a7c:	12 9a       	mov	r10,r9
80005a7e:	12 9b       	mov	r11,r9
80005a80:	48 38       	lddpc	r8,80005a8c <spi_unselectChip+0x38>
80005a82:	70 0c       	ld.w	r12,r8[0x0]
80005a84:	f0 1f 00 03 	mcall	80005a90 <spi_unselectChip+0x3c>
80005a88:	d8 0a       	popm	pc,r12=0
80005a8a:	00 00       	add	r0,r0
80005a8c:	00 00       	add	r0,r0
80005a8e:	53 c4       	stdsp	sp[0xf0],r4
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	64 38       	ld.w	r8,r2[0xc]

80005a94 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a94:	eb cd 40 f8 	pushm	r3-r7,lr
80005a98:	18 94       	mov	r4,r12
80005a9a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a9c:	49 a6       	lddpc	r6,80005b04 <spi_selectChip+0x70>
80005a9e:	30 07       	mov	r7,0
80005aa0:	31 45       	mov	r5,20
80005aa2:	0e 99       	mov	r9,r7
80005aa4:	0a 9a       	mov	r10,r5
80005aa6:	0e 9b       	mov	r11,r7
80005aa8:	6c 0c       	ld.w	r12,r6[0x0]
80005aaa:	f0 1f 00 18 	mcall	80005b08 <spi_selectChip+0x74>
80005aae:	cf a0       	breq	80005aa2 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005ab0:	68 18       	ld.w	r8,r4[0x4]
80005ab2:	ea 18 00 0f 	orh	r8,0xf
80005ab6:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005ab8:	68 18       	ld.w	r8,r4[0x4]
80005aba:	e2 18 00 04 	andl	r8,0x4,COH
80005abe:	c1 10       	breq	80005ae0 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005ac0:	30 e8       	mov	r8,14
80005ac2:	f0 03 18 00 	cp.b	r3,r8
80005ac6:	e0 8b 00 1c 	brhi	80005afe <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005aca:	68 19       	ld.w	r9,r4[0x4]
80005acc:	e6 08 15 10 	lsl	r8,r3,0x10
80005ad0:	ea 18 ff f0 	orh	r8,0xfff0
80005ad4:	e8 18 ff ff 	orl	r8,0xffff
80005ad8:	12 68       	and	r8,r9
80005ada:	89 18       	st.w	r4[0x4],r8
80005adc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005ae0:	30 38       	mov	r8,3
80005ae2:	f0 03 18 00 	cp.b	r3,r8
80005ae6:	e0 8b 00 0c 	brhi	80005afe <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005aea:	68 19       	ld.w	r9,r4[0x4]
80005aec:	2f 03       	sub	r3,-16
80005aee:	30 18       	mov	r8,1
80005af0:	f0 03 09 48 	lsl	r8,r8,r3
80005af4:	5c d8       	com	r8
80005af6:	12 68       	and	r8,r9
80005af8:	89 18       	st.w	r4[0x4],r8
80005afa:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005afe:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005b00:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005b04:	00 00       	add	r0,r0
80005b06:	53 c4       	stdsp	sp[0xf0],r4
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	62 2c       	ld.w	r12,r1[0x8]

80005b0c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005b0c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005b0e:	f6 08 15 04 	lsl	r8,r11,0x4
80005b12:	14 38       	cp.w	r8,r10
80005b14:	f9 b8 08 10 	movls	r8,16
80005b18:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005b1c:	f0 0b 02 4b 	mul	r11,r8,r11
80005b20:	f6 09 16 01 	lsr	r9,r11,0x1
80005b24:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005b28:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005b2c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005b30:	f2 cb 00 01 	sub	r11,r9,1
80005b34:	e0 4b ff fe 	cp.w	r11,65534
80005b38:	e0 88 00 03 	brls	80005b3e <usart_set_async_baudrate+0x32>
80005b3c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005b3e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005b40:	e8 6e 00 00 	mov	lr,524288
80005b44:	59 08       	cp.w	r8,16
80005b46:	fc 08 17 10 	movne	r8,lr
80005b4a:	f9 b8 00 00 	moveq	r8,0
80005b4e:	e4 1b ff f7 	andh	r11,0xfff7
80005b52:	e0 1b fe cf 	andl	r11,0xfecf
80005b56:	16 48       	or	r8,r11
80005b58:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005b5a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005b5e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005b62:	99 89       	st.w	r12[0x20],r9
80005b64:	d8 0a       	popm	pc,r12=0

80005b66 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005b66:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005b68:	e2 18 00 02 	andl	r8,0x2,COH
80005b6c:	c0 31       	brne	80005b72 <usart_write_char+0xc>
80005b6e:	30 2c       	mov	r12,2
80005b70:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005b72:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005b76:	99 7b       	st.w	r12[0x1c],r11
80005b78:	5e fd       	retal	0
80005b7a:	d7 03       	nop

80005b7c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005b7c:	eb cd 40 e0 	pushm	r5-r7,lr
80005b80:	18 96       	mov	r6,r12
80005b82:	16 95       	mov	r5,r11
80005b84:	e0 67 27 0f 	mov	r7,9999
80005b88:	c0 68       	rjmp	80005b94 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005b8a:	58 07       	cp.w	r7,0
80005b8c:	c0 31       	brne	80005b92 <usart_putchar+0x16>
80005b8e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b92:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b94:	0a 9b       	mov	r11,r5
80005b96:	0c 9c       	mov	r12,r6
80005b98:	f0 1f 00 03 	mcall	80005ba4 <usart_putchar+0x28>
80005b9c:	cf 71       	brne	80005b8a <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005ba2:	00 00       	add	r0,r0
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	5b 66       	cp.w	r6,-10

80005ba8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005ba8:	78 58       	ld.w	r8,r12[0x14]
80005baa:	e2 18 00 e0 	andl	r8,0xe0,COH
80005bae:	c0 30       	breq	80005bb4 <usart_read_char+0xc>
80005bb0:	30 4c       	mov	r12,4
80005bb2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005bb4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005bb6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005bba:	c0 31       	brne	80005bc0 <usart_read_char+0x18>
80005bbc:	30 3c       	mov	r12,3
80005bbe:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005bc0:	78 68       	ld.w	r8,r12[0x18]
80005bc2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005bc6:	97 08       	st.w	r11[0x0],r8
80005bc8:	5e fd       	retal	0
80005bca:	d7 03       	nop

80005bcc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005bcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005bd0:	20 1d       	sub	sp,4
80005bd2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005bd4:	1a 97       	mov	r7,sp
80005bd6:	1a 9b       	mov	r11,sp
80005bd8:	0c 9c       	mov	r12,r6
80005bda:	f0 1f 00 07 	mcall	80005bf4 <usart_getchar+0x28>
80005bde:	58 3c       	cp.w	r12,3
80005be0:	cf b0       	breq	80005bd6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005be2:	58 4c       	cp.w	r12,4
80005be4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005be8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005bec:	2f fd       	sub	sp,-4
80005bee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bf2:	00 00       	add	r0,r0
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	5b a8       	cp.w	r8,-6

80005bf8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005bf8:	eb cd 40 c0 	pushm	r6-r7,lr
80005bfc:	18 96       	mov	r6,r12
80005bfe:	16 97       	mov	r7,r11
  while (*string != '\0')
80005c00:	17 8b       	ld.ub	r11,r11[0x0]
80005c02:	58 0b       	cp.w	r11,0
80005c04:	c0 80       	breq	80005c14 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005c06:	2f f7       	sub	r7,-1
80005c08:	0c 9c       	mov	r12,r6
80005c0a:	f0 1f 00 04 	mcall	80005c18 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005c0e:	0f 8b       	ld.ub	r11,r7[0x0]
80005c10:	58 0b       	cp.w	r11,0
80005c12:	cf a1       	brne	80005c06 <usart_write_line+0xe>
80005c14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	5b 7c       	cp.w	r12,-9

80005c1c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005c1c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005c20:	e6 18 00 01 	andh	r8,0x1,COH
80005c24:	c0 71       	brne	80005c32 <usart_reset+0x16>
80005c26:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005c28:	3f f8       	mov	r8,-1
80005c2a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c2c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005c2e:	d5 03       	csrf	0x10
80005c30:	c0 48       	rjmp	80005c38 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005c32:	3f f8       	mov	r8,-1
80005c34:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c36:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005c38:	30 08       	mov	r8,0
80005c3a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005c3c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005c3e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005c40:	ea 68 61 0c 	mov	r8,680204
80005c44:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005c46:	5e fc       	retal	r12

80005c48 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005c48:	eb cd 40 e0 	pushm	r5-r7,lr
80005c4c:	18 96       	mov	r6,r12
80005c4e:	16 97       	mov	r7,r11
80005c50:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005c52:	f0 1f 00 2f 	mcall	80005d0c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005c56:	58 07       	cp.w	r7,0
80005c58:	c5 80       	breq	80005d08 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005c5a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c5c:	30 49       	mov	r9,4
80005c5e:	f2 08 18 00 	cp.b	r8,r9
80005c62:	e0 88 00 53 	brls	80005d08 <usart_init_rs232+0xc0>
80005c66:	30 99       	mov	r9,9
80005c68:	f2 08 18 00 	cp.b	r8,r9
80005c6c:	e0 8b 00 4e 	brhi	80005d08 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005c70:	0f d9       	ld.ub	r9,r7[0x5]
80005c72:	30 78       	mov	r8,7
80005c74:	f0 09 18 00 	cp.b	r9,r8
80005c78:	e0 8b 00 48 	brhi	80005d08 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005c7c:	8e 39       	ld.sh	r9,r7[0x6]
80005c7e:	e0 68 01 01 	mov	r8,257
80005c82:	f0 09 19 00 	cp.h	r9,r8
80005c86:	e0 8b 00 41 	brhi	80005d08 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005c8a:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c8e:	30 38       	mov	r8,3
80005c90:	f0 09 18 00 	cp.b	r9,r8
80005c94:	e0 8b 00 3a 	brhi	80005d08 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c98:	0a 9a       	mov	r10,r5
80005c9a:	6e 0b       	ld.w	r11,r7[0x0]
80005c9c:	0c 9c       	mov	r12,r6
80005c9e:	f0 1f 00 1d 	mcall	80005d10 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005ca2:	58 1c       	cp.w	r12,1
80005ca4:	c3 20       	breq	80005d08 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005ca6:	0f c8       	ld.ub	r8,r7[0x4]
80005ca8:	30 99       	mov	r9,9
80005caa:	f2 08 18 00 	cp.b	r8,r9
80005cae:	c0 51       	brne	80005cb8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005cb0:	6c 18       	ld.w	r8,r6[0x4]
80005cb2:	b1 b8       	sbr	r8,0x11
80005cb4:	8d 18       	st.w	r6[0x4],r8
80005cb6:	c0 68       	rjmp	80005cc2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005cb8:	6c 19       	ld.w	r9,r6[0x4]
80005cba:	20 58       	sub	r8,5
80005cbc:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005cc0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005cc2:	6c 19       	ld.w	r9,r6[0x4]
80005cc4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005cc8:	0f d8       	ld.ub	r8,r7[0x5]
80005cca:	a9 78       	lsl	r8,0x9
80005ccc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005cd0:	12 48       	or	r8,r9
80005cd2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005cd4:	8e 38       	ld.sh	r8,r7[0x6]
80005cd6:	30 29       	mov	r9,2
80005cd8:	f2 08 19 00 	cp.h	r8,r9
80005cdc:	e0 88 00 09 	brls	80005cee <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005ce0:	6c 18       	ld.w	r8,r6[0x4]
80005ce2:	ad b8       	sbr	r8,0xd
80005ce4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005ce6:	8e b8       	ld.uh	r8,r7[0x6]
80005ce8:	20 28       	sub	r8,2
80005cea:	8d a8       	st.w	r6[0x28],r8
80005cec:	c0 68       	rjmp	80005cf8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005cee:	6c 19       	ld.w	r9,r6[0x4]
80005cf0:	5c 78       	castu.h	r8
80005cf2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005cf6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005cf8:	6c 18       	ld.w	r8,r6[0x4]
80005cfa:	e0 18 ff f0 	andl	r8,0xfff0
80005cfe:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005d00:	35 08       	mov	r8,80
80005d02:	8d 08       	st.w	r6[0x0],r8
80005d04:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005d08:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	5c 1c       	scr	r12
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	5b 0c       	cp.w	r12,-16

80005d14 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005d14:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005d18:	fe c0 8f 18 	sub	r0,pc,-28904

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005d1c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005d20:	d5 53       	csrf	0x15
  cp      r0, r1
80005d22:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005d24:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005d28:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005d2a:	c0 62       	brcc	80005d36 <idata_load_loop_end>
  cp      r0, r1
80005d2c:	48 92       	lddpc	r2,80005d50 <udata_clear_loop_end+0x4>

80005d2e <idata_load_loop>:
  brlo    idata_load_loop
80005d2e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005d30:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005d32:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005d34:	cf d3       	brcs	80005d2e <idata_load_loop>

80005d36 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005d36:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80005d3a:	e0 61 53 d8 	mov	r1,21464
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005d3e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005d40:	c0 62       	brcc	80005d4c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005d42:	30 02       	mov	r2,0
80005d44:	30 03       	mov	r3,0

80005d46 <udata_clear_loop>:
80005d46:	a1 22       	st.d	r0++,r2
80005d48:	02 30       	cp.w	r0,r1
80005d4a:	cf e3       	brcs	80005d46 <udata_clear_loop>

80005d4c <udata_clear_loop_end>:
80005d4c:	fe cf e9 28 	sub	pc,pc,-5848
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	e2 b8       	*unknown*

80005d54 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005d54:	f8 c8 ff f8 	sub	r8,r12,-8
80005d58:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005d5a:	3f f9       	mov	r9,-1
80005d5c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005d5e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005d60:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005d62:	30 08       	mov	r8,0
80005d64:	99 08       	st.w	r12[0x0],r8
}
80005d66:	5e fc       	retal	r12

80005d68 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005d68:	30 08       	mov	r8,0
80005d6a:	99 48       	st.w	r12[0x10],r8
}
80005d6c:	5e fc       	retal	r12

80005d6e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005d6e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005d70:	70 19       	ld.w	r9,r8[0x4]
80005d72:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005d74:	78 19       	ld.w	r9,r12[0x4]
80005d76:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d78:	70 19       	ld.w	r9,r8[0x4]
80005d7a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d7c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005d7e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d80:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d82:	78 08       	ld.w	r8,r12[0x0]
80005d84:	2f f8       	sub	r8,-1
80005d86:	99 08       	st.w	r12[0x0],r8
}
80005d88:	5e fc       	retal	r12

80005d8a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005d8a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d8c:	5b fa       	cp.w	r10,-1
80005d8e:	c0 31       	brne	80005d94 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d90:	78 48       	ld.w	r8,r12[0x10]
80005d92:	c0 c8       	rjmp	80005daa <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d94:	f8 c8 ff f8 	sub	r8,r12,-8
80005d98:	70 19       	ld.w	r9,r8[0x4]
80005d9a:	72 09       	ld.w	r9,r9[0x0]
80005d9c:	12 3a       	cp.w	r10,r9
80005d9e:	c0 63       	brcs	80005daa <vListInsert+0x20>
80005da0:	70 18       	ld.w	r8,r8[0x4]
80005da2:	70 19       	ld.w	r9,r8[0x4]
80005da4:	72 09       	ld.w	r9,r9[0x0]
80005da6:	12 3a       	cp.w	r10,r9
80005da8:	cf c2       	brcc	80005da0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005daa:	70 19       	ld.w	r9,r8[0x4]
80005dac:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005dae:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005db0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005db2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005db4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005db6:	78 08       	ld.w	r8,r12[0x0]
80005db8:	2f f8       	sub	r8,-1
80005dba:	99 08       	st.w	r12[0x0],r8
}
80005dbc:	5e fc       	retal	r12

80005dbe <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005dbe:	78 18       	ld.w	r8,r12[0x4]
80005dc0:	78 29       	ld.w	r9,r12[0x8]
80005dc2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005dc4:	78 28       	ld.w	r8,r12[0x8]
80005dc6:	78 19       	ld.w	r9,r12[0x4]
80005dc8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005dca:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005dcc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005dce:	18 39       	cp.w	r9,r12
80005dd0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005dd4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005dd8:	30 09       	mov	r9,0
80005dda:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005ddc:	70 09       	ld.w	r9,r8[0x0]
80005dde:	20 19       	sub	r9,1
80005de0:	91 09       	st.w	r8[0x0],r9
}
80005de2:	5e fc       	retal	r12

80005de4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005de4:	e0 68 08 08 	mov	r8,2056
80005de8:	ea 18 08 08 	orh	r8,0x808
80005dec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005dee:	e0 68 09 09 	mov	r8,2313
80005df2:	ea 18 09 09 	orh	r8,0x909
80005df6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005df8:	e0 68 0a 0a 	mov	r8,2570
80005dfc:	ea 18 0a 0a 	orh	r8,0xa0a
80005e00:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005e02:	e0 68 0b 0b 	mov	r8,2827
80005e06:	ea 18 0b 0b 	orh	r8,0xb0b
80005e0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005e0c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005e0e:	e0 68 be ef 	mov	r8,48879
80005e12:	ea 18 de ad 	orh	r8,0xdead
80005e16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005e18:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005e1a:	fc 18 00 40 	movh	r8,0x40
80005e1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005e20:	e0 68 00 ff 	mov	r8,255
80005e24:	ea 18 ff 00 	orh	r8,0xff00
80005e28:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005e2a:	e0 68 01 01 	mov	r8,257
80005e2e:	ea 18 01 01 	orh	r8,0x101
80005e32:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005e34:	e0 68 02 02 	mov	r8,514
80005e38:	ea 18 02 02 	orh	r8,0x202
80005e3c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005e3e:	e0 68 03 03 	mov	r8,771
80005e42:	ea 18 03 03 	orh	r8,0x303
80005e46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005e48:	e0 68 04 04 	mov	r8,1028
80005e4c:	ea 18 04 04 	orh	r8,0x404
80005e50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005e52:	e0 68 05 05 	mov	r8,1285
80005e56:	ea 18 05 05 	orh	r8,0x505
80005e5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005e5c:	e0 68 06 06 	mov	r8,1542
80005e60:	ea 18 06 06 	orh	r8,0x606
80005e64:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005e66:	e0 68 07 07 	mov	r8,1799
80005e6a:	ea 18 07 07 	orh	r8,0x707
80005e6e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005e70:	30 08       	mov	r8,0
80005e72:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005e74:	5e fc       	retal	r12
80005e76:	d7 03       	nop

80005e78 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005e78:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005e7a:	48 38       	lddpc	r8,80005e84 <vPortEnterCritical+0xc>
80005e7c:	70 09       	ld.w	r9,r8[0x0]
80005e7e:	2f f9       	sub	r9,-1
80005e80:	91 09       	st.w	r8[0x0],r9
}
80005e82:	5e fc       	retal	r12
80005e84:	00 00       	add	r0,r0
80005e86:	05 38       	ld.ub	r8,r2++

80005e88 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005e88:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005e8a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e8c:	30 0a       	mov	r10,0
80005e8e:	14 9b       	mov	r11,r10
80005e90:	49 2c       	lddpc	r12,80005ed8 <xPortStartScheduler+0x50>
80005e92:	f0 1f 00 13 	mcall	80005edc <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e96:	e0 68 5d c0 	mov	r8,24000
80005e9a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e9e:	30 08       	mov	r8,0
80005ea0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005ea4:	e0 68 0c f8 	mov	r8,3320
80005ea8:	ea 18 00 00 	orh	r8,0x0
80005eac:	70 00       	ld.w	r0,r8[0x0]
80005eae:	60 0d       	ld.w	sp,r0[0x0]
80005eb0:	1b 00       	ld.w	r0,sp++
80005eb2:	e0 68 05 38 	mov	r8,1336
80005eb6:	ea 18 00 00 	orh	r8,0x0
80005eba:	91 00       	st.w	r8[0x0],r0
80005ebc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ec0:	2f ed       	sub	sp,-8
80005ec2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005ec6:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005eca:	e3 b0 00 00 	mtsr	0x0,r0
80005ece:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005ed2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005ed6:	d8 0a       	popm	pc,r12=0
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	5f a4       	srle	r4
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	54 d8       	stdsp	sp[0x134],r8

80005ee0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005ee0:	20 6d       	sub	sp,24
80005ee2:	eb cd 00 ff 	pushm	r0-r7
80005ee6:	fa c7 ff c0 	sub	r7,sp,-64
80005eea:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005eee:	ef 40 ff e0 	st.w	r7[-32],r0
80005ef2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005ef6:	ef 40 ff e4 	st.w	r7[-28],r0
80005efa:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005efe:	e0 68 05 38 	mov	r8,1336
80005f02:	ea 18 00 00 	orh	r8,0x0
80005f06:	70 00       	ld.w	r0,r8[0x0]
80005f08:	1a d0       	st.w	--sp,r0
80005f0a:	f0 1f 00 1a 	mcall	80005f70 <LABEL_RET_SCALL_263+0x14>
80005f0e:	e0 68 0c f8 	mov	r8,3320
80005f12:	ea 18 00 00 	orh	r8,0x0
80005f16:	70 00       	ld.w	r0,r8[0x0]
80005f18:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005f1a:	f0 1f 00 17 	mcall	80005f74 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005f1e:	e0 68 0c f8 	mov	r8,3320
80005f22:	ea 18 00 00 	orh	r8,0x0
80005f26:	70 00       	ld.w	r0,r8[0x0]
80005f28:	60 0d       	ld.w	sp,r0[0x0]
80005f2a:	1b 00       	ld.w	r0,sp++
80005f2c:	e0 68 05 38 	mov	r8,1336
80005f30:	ea 18 00 00 	orh	r8,0x0
80005f34:	91 00       	st.w	r8[0x0],r0
80005f36:	fa c7 ff d8 	sub	r7,sp,-40
80005f3a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005f3e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005f42:	e0 61 05 38 	mov	r1,1336
80005f46:	ea 11 00 00 	orh	r1,0x0
80005f4a:	62 02       	ld.w	r2,r1[0x0]
80005f4c:	58 02       	cp.w	r2,0
80005f4e:	c0 70       	breq	80005f5c <LABEL_RET_SCALL_263>
80005f50:	e4 c2 00 01 	sub	r2,r2,1
80005f54:	83 02       	st.w	r1[0x0],r2
80005f56:	58 02       	cp.w	r2,0
80005f58:	c0 21       	brne	80005f5c <LABEL_RET_SCALL_263>
80005f5a:	b1 c0       	cbr	r0,0x10

80005f5c <LABEL_RET_SCALL_263>:
80005f5c:	ef 40 ff f8 	st.w	r7[-8],r0
80005f60:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005f64:	ef 40 ff fc 	st.w	r7[-4],r0
80005f68:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f6c:	2f ad       	sub	sp,-24
80005f6e:	d6 13       	rets
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5e 78       	retpl	r8
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	66 14       	ld.w	r4,r3[0x4]

80005f78 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005f78:	e1 b8 00 43 	mfsr	r8,0x10c
80005f7c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005f80:	5e fc       	retal	r12
80005f82:	d7 03       	nop

80005f84 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005f84:	48 78       	lddpc	r8,80005fa0 <vPortExitCritical+0x1c>
80005f86:	70 08       	ld.w	r8,r8[0x0]
80005f88:	58 08       	cp.w	r8,0
80005f8a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f8c:	48 58       	lddpc	r8,80005fa0 <vPortExitCritical+0x1c>
80005f8e:	70 09       	ld.w	r9,r8[0x0]
80005f90:	20 19       	sub	r9,1
80005f92:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f94:	70 08       	ld.w	r8,r8[0x0]
80005f96:	58 08       	cp.w	r8,0
80005f98:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f9a:	d5 03       	csrf	0x10
80005f9c:	5e fc       	retal	r12
80005f9e:	00 00       	add	r0,r0
80005fa0:	00 00       	add	r0,r0
80005fa2:	05 38       	ld.ub	r8,r2++

80005fa4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005fa4:	eb cd 00 ff 	pushm	r0-r7
80005fa8:	e0 68 05 38 	mov	r8,1336
80005fac:	ea 18 00 00 	orh	r8,0x0
80005fb0:	70 00       	ld.w	r0,r8[0x0]
80005fb2:	1a d0       	st.w	--sp,r0
80005fb4:	7a 90       	ld.w	r0,sp[0x24]
80005fb6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005fba:	58 10       	cp.w	r0,1
80005fbc:	e0 8b 00 08 	brhi	80005fcc <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005fc0:	e0 68 0c f8 	mov	r8,3320
80005fc4:	ea 18 00 00 	orh	r8,0x0
80005fc8:	70 00       	ld.w	r0,r8[0x0]
80005fca:	81 0d       	st.w	r0[0x0],sp

80005fcc <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005fcc:	f0 1f 00 12 	mcall	80006014 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005fd0:	f0 1f 00 12 	mcall	80006018 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005fd4:	f0 1f 00 12 	mcall	8000601c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005fd8:	f0 1f 00 12 	mcall	80006020 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005fdc:	7a 90       	ld.w	r0,sp[0x24]
80005fde:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005fe2:	58 10       	cp.w	r0,1
80005fe4:	e0 8b 00 0e 	brhi	80006000 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005fe8:	f0 1f 00 0c 	mcall	80006018 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005fec:	f0 1f 00 0e 	mcall	80006024 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005ff0:	f0 1f 00 0c 	mcall	80006020 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005ff4:	e0 68 0c f8 	mov	r8,3320
80005ff8:	ea 18 00 00 	orh	r8,0x0
80005ffc:	70 00       	ld.w	r0,r8[0x0]
80005ffe:	60 0d       	ld.w	sp,r0[0x0]

80006000 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006000:	1b 00       	ld.w	r0,sp++
80006002:	e0 68 05 38 	mov	r8,1336
80006006:	ea 18 00 00 	orh	r8,0x0
8000600a:	91 00       	st.w	r8[0x0],r0
8000600c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006010:	d6 03       	rete
80006012:	00 00       	add	r0,r0
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	5f 78       	srpl	r8
80006018:	80 00       	ld.sh	r0,r0[0x0]
8000601a:	5e 78       	retpl	r8
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	68 18       	ld.w	r8,r4[0x4]
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	5f 84       	srls	r4
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	66 14       	ld.w	r4,r3[0x4]

80006028 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006028:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000602a:	f0 1f 00 02 	mcall	80006030 <__malloc_lock+0x8>
}
8000602e:	d8 02       	popm	pc
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	66 04       	ld.w	r4,r3[0x0]

80006034 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006034:	d4 01       	pushm	lr
	xTaskResumeAll();
80006036:	f0 1f 00 02 	mcall	8000603c <__malloc_unlock+0x8>
}
8000603a:	d8 02       	popm	pc
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	69 c0       	ld.w	r0,r4[0x70]

80006040 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006040:	d4 21       	pushm	r4-r7,lr
80006042:	16 95       	mov	r5,r11
80006044:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006046:	58 0c       	cp.w	r12,0
80006048:	c0 30       	breq	8000604e <_read+0xe>
8000604a:	3f f7       	mov	r7,-1
8000604c:	c1 48       	rjmp	80006074 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000604e:	58 0a       	cp.w	r10,0
80006050:	e0 89 00 04 	brgt	80006058 <_read+0x18>
80006054:	30 07       	mov	r7,0
80006056:	c0 f8       	rjmp	80006074 <_read+0x34>
80006058:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000605a:	48 84       	lddpc	r4,80006078 <_read+0x38>
8000605c:	68 0c       	ld.w	r12,r4[0x0]
8000605e:	f0 1f 00 08 	mcall	8000607c <_read+0x3c>
    if (c < 0)
80006062:	c0 95       	brlt	80006074 <_read+0x34>
      break;

    *ptr++ = c;
80006064:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006068:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000606a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000606e:	58 08       	cp.w	r8,0
80006070:	fe 99 ff f6 	brgt	8000605c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006074:	0e 9c       	mov	r12,r7
80006076:	d8 22       	popm	r4-r7,pc
80006078:	00 00       	add	r0,r0
8000607a:	53 c8       	stdsp	sp[0xf0],r8
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	5b cc       	cp.w	r12,-4

80006080 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006080:	d4 21       	pushm	r4-r7,lr
80006082:	16 95       	mov	r5,r11
80006084:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006086:	20 1c       	sub	r12,1
80006088:	58 2c       	cp.w	r12,2
8000608a:	e0 8b 00 12 	brhi	800060ae <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000608e:	58 0a       	cp.w	r10,0
80006090:	c0 31       	brne	80006096 <_write+0x16>
80006092:	30 07       	mov	r7,0
80006094:	c0 e8       	rjmp	800060b0 <_write+0x30>
80006096:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006098:	48 74       	lddpc	r4,800060b4 <_write+0x34>
8000609a:	68 0c       	ld.w	r12,r4[0x0]
8000609c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800060a0:	f0 1f 00 06 	mcall	800060b8 <_write+0x38>
800060a4:	c0 55       	brlt	800060ae <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800060a6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800060a8:	0e 36       	cp.w	r6,r7
800060aa:	cf 81       	brne	8000609a <_write+0x1a>
800060ac:	c0 28       	rjmp	800060b0 <_write+0x30>
800060ae:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800060b0:	0e 9c       	mov	r12,r7
800060b2:	d8 22       	popm	r4-r7,pc
800060b4:	00 00       	add	r0,r0
800060b6:	53 c8       	stdsp	sp[0xf0],r8
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	5b 7c       	cp.w	r12,-9

800060bc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800060bc:	eb cd 40 80 	pushm	r7,lr
800060c0:	18 97       	mov	r7,r12
	if( pv )
800060c2:	58 0c       	cp.w	r12,0
800060c4:	c0 80       	breq	800060d4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800060c6:	f0 1f 00 05 	mcall	800060d8 <vPortFree+0x1c>
		{
			free( pv );
800060ca:	0e 9c       	mov	r12,r7
800060cc:	f0 1f 00 04 	mcall	800060dc <vPortFree+0x20>
		}
		xTaskResumeAll();
800060d0:	f0 1f 00 04 	mcall	800060e0 <vPortFree+0x24>
800060d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	66 04       	ld.w	r4,r3[0x0]
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	74 9c       	ld.w	r12,r10[0x24]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	69 c0       	ld.w	r0,r4[0x70]

800060e4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800060e4:	eb cd 40 80 	pushm	r7,lr
800060e8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800060ea:	f0 1f 00 06 	mcall	80006100 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800060ee:	0e 9c       	mov	r12,r7
800060f0:	f0 1f 00 05 	mcall	80006104 <pvPortMalloc+0x20>
800060f4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800060f6:	f0 1f 00 05 	mcall	80006108 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800060fa:	0e 9c       	mov	r12,r7
800060fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	66 04       	ld.w	r4,r3[0x0]
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	74 ac       	ld.w	r12,r10[0x28]
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	69 c0       	ld.w	r0,r4[0x70]

8000610c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000610c:	d4 01       	pushm	lr
8000610e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006110:	78 09       	ld.w	r9,r12[0x0]
80006112:	58 09       	cp.w	r9,0
80006114:	c1 10       	breq	80006136 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006116:	78 3a       	ld.w	r10,r12[0xc]
80006118:	79 09       	ld.w	r9,r12[0x40]
8000611a:	f4 09 00 09 	add	r9,r10,r9
8000611e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006120:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006122:	14 39       	cp.w	r9,r10
80006124:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006128:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000612c:	79 0a       	ld.w	r10,r12[0x40]
8000612e:	78 3b       	ld.w	r11,r12[0xc]
80006130:	10 9c       	mov	r12,r8
80006132:	f0 1f 00 02 	mcall	80006138 <prvCopyDataFromQueue+0x2c>
80006136:	d8 02       	popm	pc
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	78 f4       	ld.w	r4,r12[0x3c]

8000613c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000613c:	eb cd 40 c0 	pushm	r6-r7,lr
80006140:	18 97       	mov	r7,r12
80006142:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006144:	78 e8       	ld.w	r8,r12[0x38]
80006146:	58 08       	cp.w	r8,0
80006148:	c0 31       	brne	8000614e <xQueueReceiveFromISR+0x12>
8000614a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000614e:	f0 1f 00 0e 	mcall	80006184 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006152:	6e e8       	ld.w	r8,r7[0x38]
80006154:	20 18       	sub	r8,1
80006156:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006158:	6f 18       	ld.w	r8,r7[0x44]
8000615a:	5b f8       	cp.w	r8,-1
8000615c:	c0 d1       	brne	80006176 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000615e:	6e 48       	ld.w	r8,r7[0x10]
80006160:	58 08       	cp.w	r8,0
80006162:	c0 f0       	breq	80006180 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006164:	ee cc ff f0 	sub	r12,r7,-16
80006168:	f0 1f 00 08 	mcall	80006188 <xQueueReceiveFromISR+0x4c>
8000616c:	c0 a0       	breq	80006180 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000616e:	30 1c       	mov	r12,1
80006170:	8d 0c       	st.w	r6[0x0],r12
80006172:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006176:	2f f8       	sub	r8,-1
80006178:	ef 48 00 44 	st.w	r7[68],r8
8000617c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006180:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	61 0c       	ld.w	r12,r0[0x40]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	67 9c       	ld.w	r12,r3[0x64]

8000618c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000618c:	eb cd 40 c0 	pushm	r6-r7,lr
80006190:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006192:	f0 1f 00 23 	mcall	8000621c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006196:	6f 28       	ld.w	r8,r7[0x48]
80006198:	58 08       	cp.w	r8,0
8000619a:	e0 8a 00 18 	brle	800061ca <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000619e:	6e 98       	ld.w	r8,r7[0x24]
800061a0:	58 08       	cp.w	r8,0
800061a2:	c1 40       	breq	800061ca <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061a4:	ee c6 ff dc 	sub	r6,r7,-36
800061a8:	c0 48       	rjmp	800061b0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061aa:	6e 98       	ld.w	r8,r7[0x24]
800061ac:	58 08       	cp.w	r8,0
800061ae:	c0 e0       	breq	800061ca <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061b0:	0c 9c       	mov	r12,r6
800061b2:	f0 1f 00 1c 	mcall	80006220 <prvUnlockQueue+0x94>
800061b6:	c0 30       	breq	800061bc <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800061b8:	f0 1f 00 1b 	mcall	80006224 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800061bc:	6f 28       	ld.w	r8,r7[0x48]
800061be:	20 18       	sub	r8,1
800061c0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800061c4:	58 08       	cp.w	r8,0
800061c6:	fe 99 ff f2 	brgt	800061aa <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800061ca:	3f f8       	mov	r8,-1
800061cc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800061d0:	f0 1f 00 16 	mcall	80006228 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800061d4:	f0 1f 00 12 	mcall	8000621c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061d8:	6f 18       	ld.w	r8,r7[0x44]
800061da:	58 08       	cp.w	r8,0
800061dc:	e0 8a 00 18 	brle	8000620c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061e0:	6e 48       	ld.w	r8,r7[0x10]
800061e2:	58 08       	cp.w	r8,0
800061e4:	c1 40       	breq	8000620c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061e6:	ee c6 ff f0 	sub	r6,r7,-16
800061ea:	c0 48       	rjmp	800061f2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061ec:	6e 48       	ld.w	r8,r7[0x10]
800061ee:	58 08       	cp.w	r8,0
800061f0:	c0 e0       	breq	8000620c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061f2:	0c 9c       	mov	r12,r6
800061f4:	f0 1f 00 0b 	mcall	80006220 <prvUnlockQueue+0x94>
800061f8:	c0 30       	breq	800061fe <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800061fa:	f0 1f 00 0b 	mcall	80006224 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800061fe:	6f 18       	ld.w	r8,r7[0x44]
80006200:	20 18       	sub	r8,1
80006202:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006206:	58 08       	cp.w	r8,0
80006208:	fe 99 ff f2 	brgt	800061ec <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000620c:	3f f8       	mov	r8,-1
8000620e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006212:	f0 1f 00 06 	mcall	80006228 <prvUnlockQueue+0x9c>
}
80006216:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000621a:	00 00       	add	r0,r0
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	5e 78       	retpl	r8
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	67 9c       	ld.w	r12,r3[0x64]
80006224:	80 00       	ld.sh	r0,r0[0x0]
80006226:	66 a8       	ld.w	r8,r3[0x28]
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	5f 84       	srls	r4

8000622c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000622c:	d4 31       	pushm	r0-r7,lr
8000622e:	20 5d       	sub	sp,20
80006230:	18 97       	mov	r7,r12
80006232:	50 0b       	stdsp	sp[0x0],r11
80006234:	50 2a       	stdsp	sp[0x8],r10
80006236:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006238:	f8 c2 ff dc 	sub	r2,r12,-36
8000623c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000623e:	fa c4 ff f4 	sub	r4,sp,-12
80006242:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006244:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006246:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000624a:	f0 1f 00 3e 	mcall	80006340 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000624e:	6e e8       	ld.w	r8,r7[0x38]
80006250:	58 08       	cp.w	r8,0
80006252:	c2 a0       	breq	800062a6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006254:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006256:	40 0b       	lddsp	r11,sp[0x0]
80006258:	0e 9c       	mov	r12,r7
8000625a:	f0 1f 00 3b 	mcall	80006344 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000625e:	40 18       	lddsp	r8,sp[0x4]
80006260:	58 08       	cp.w	r8,0
80006262:	c1 51       	brne	8000628c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006264:	6e e8       	ld.w	r8,r7[0x38]
80006266:	20 18       	sub	r8,1
80006268:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000626a:	6e 08       	ld.w	r8,r7[0x0]
8000626c:	58 08       	cp.w	r8,0
8000626e:	c0 41       	brne	80006276 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006270:	f0 1f 00 36 	mcall	80006348 <xQueueGenericReceive+0x11c>
80006274:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006276:	6e 48       	ld.w	r8,r7[0x10]
80006278:	58 08       	cp.w	r8,0
8000627a:	c1 20       	breq	8000629e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000627c:	ee cc ff f0 	sub	r12,r7,-16
80006280:	f0 1f 00 33 	mcall	8000634c <xQueueGenericReceive+0x120>
80006284:	58 1c       	cp.w	r12,1
80006286:	c0 c1       	brne	8000629e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006288:	d7 33       	scall
8000628a:	c0 a8       	rjmp	8000629e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000628c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000628e:	6e 98       	ld.w	r8,r7[0x24]
80006290:	58 08       	cp.w	r8,0
80006292:	c0 60       	breq	8000629e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006294:	04 9c       	mov	r12,r2
80006296:	f0 1f 00 2e 	mcall	8000634c <xQueueGenericReceive+0x120>
8000629a:	c0 20       	breq	8000629e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000629c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000629e:	f0 1f 00 2d 	mcall	80006350 <xQueueGenericReceive+0x124>
800062a2:	30 1c       	mov	r12,1
				return pdPASS;
800062a4:	c4 c8       	rjmp	8000633c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800062a6:	40 28       	lddsp	r8,sp[0x8]
800062a8:	58 08       	cp.w	r8,0
800062aa:	c0 51       	brne	800062b4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800062ac:	f0 1f 00 29 	mcall	80006350 <xQueueGenericReceive+0x124>
800062b0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800062b2:	c4 58       	rjmp	8000633c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800062b4:	58 05       	cp.w	r5,0
800062b6:	c0 51       	brne	800062c0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062b8:	08 9c       	mov	r12,r4
800062ba:	f0 1f 00 27 	mcall	80006354 <xQueueGenericReceive+0x128>
800062be:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062c0:	f0 1f 00 24 	mcall	80006350 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062c4:	f0 1f 00 25 	mcall	80006358 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800062c8:	f0 1f 00 1e 	mcall	80006340 <xQueueGenericReceive+0x114>
800062cc:	6f 18       	ld.w	r8,r7[0x44]
800062ce:	5b f8       	cp.w	r8,-1
800062d0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062d4:	6f 28       	ld.w	r8,r7[0x48]
800062d6:	5b f8       	cp.w	r8,-1
800062d8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062dc:	f0 1f 00 1d 	mcall	80006350 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062e0:	06 9b       	mov	r11,r3
800062e2:	08 9c       	mov	r12,r4
800062e4:	f0 1f 00 1e 	mcall	8000635c <xQueueGenericReceive+0x130>
800062e8:	c2 41       	brne	80006330 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062ea:	f0 1f 00 16 	mcall	80006340 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800062ee:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800062f0:	f0 1f 00 18 	mcall	80006350 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800062f4:	58 06       	cp.w	r6,0
800062f6:	c1 71       	brne	80006324 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062f8:	6e 08       	ld.w	r8,r7[0x0]
800062fa:	58 08       	cp.w	r8,0
800062fc:	c0 81       	brne	8000630c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800062fe:	f0 1f 00 11 	mcall	80006340 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006302:	6e 1c       	ld.w	r12,r7[0x4]
80006304:	f0 1f 00 17 	mcall	80006360 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006308:	f0 1f 00 12 	mcall	80006350 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000630c:	40 2b       	lddsp	r11,sp[0x8]
8000630e:	04 9c       	mov	r12,r2
80006310:	f0 1f 00 15 	mcall	80006364 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006314:	0e 9c       	mov	r12,r7
80006316:	f0 1f 00 15 	mcall	80006368 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000631a:	f0 1f 00 15 	mcall	8000636c <xQueueGenericReceive+0x140>
8000631e:	c9 61       	brne	8000624a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006320:	d7 33       	scall
80006322:	c9 4b       	rjmp	8000624a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006324:	0e 9c       	mov	r12,r7
80006326:	f0 1f 00 11 	mcall	80006368 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000632a:	f0 1f 00 11 	mcall	8000636c <xQueueGenericReceive+0x140>
8000632e:	c8 eb       	rjmp	8000624a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006330:	0e 9c       	mov	r12,r7
80006332:	f0 1f 00 0e 	mcall	80006368 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006336:	f0 1f 00 0e 	mcall	8000636c <xQueueGenericReceive+0x140>
8000633a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000633c:	2f bd       	sub	sp,-20
8000633e:	d8 32       	popm	r0-r7,pc
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	5e 78       	retpl	r8
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	61 0c       	ld.w	r12,r0[0x40]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	66 b4       	ld.w	r4,r3[0x2c]
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	67 9c       	ld.w	r12,r3[0x64]
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	5f 84       	srls	r4
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	66 90       	ld.w	r0,r3[0x24]
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	66 04       	ld.w	r4,r3[0x0]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	69 2c       	ld.w	r12,r4[0x48]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	67 18       	ld.w	r8,r3[0x44]
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	6b cc       	ld.w	r12,r5[0x70]
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	61 8c       	ld.w	r12,r0[0x60]
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	69 c0       	ld.w	r0,r4[0x70]

80006370 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006370:	eb cd 40 80 	pushm	r7,lr
80006374:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006376:	79 08       	ld.w	r8,r12[0x40]
80006378:	58 08       	cp.w	r8,0
8000637a:	c0 a1       	brne	8000638e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000637c:	78 08       	ld.w	r8,r12[0x0]
8000637e:	58 08       	cp.w	r8,0
80006380:	c2 b1       	brne	800063d6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006382:	78 1c       	ld.w	r12,r12[0x4]
80006384:	f0 1f 00 17 	mcall	800063e0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006388:	30 08       	mov	r8,0
8000638a:	8f 18       	st.w	r7[0x4],r8
8000638c:	c2 58       	rjmp	800063d6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000638e:	58 0a       	cp.w	r10,0
80006390:	c1 01       	brne	800063b0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006392:	10 9a       	mov	r10,r8
80006394:	78 2c       	ld.w	r12,r12[0x8]
80006396:	f0 1f 00 14 	mcall	800063e4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000639a:	6e 29       	ld.w	r9,r7[0x8]
8000639c:	6f 08       	ld.w	r8,r7[0x40]
8000639e:	f2 08 00 08 	add	r8,r9,r8
800063a2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800063a4:	6e 19       	ld.w	r9,r7[0x4]
800063a6:	12 38       	cp.w	r8,r9
800063a8:	c1 73       	brcs	800063d6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800063aa:	6e 08       	ld.w	r8,r7[0x0]
800063ac:	8f 28       	st.w	r7[0x8],r8
800063ae:	c1 48       	rjmp	800063d6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800063b0:	10 9a       	mov	r10,r8
800063b2:	78 3c       	ld.w	r12,r12[0xc]
800063b4:	f0 1f 00 0c 	mcall	800063e4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800063b8:	6f 08       	ld.w	r8,r7[0x40]
800063ba:	6e 39       	ld.w	r9,r7[0xc]
800063bc:	f2 08 01 08 	sub	r8,r9,r8
800063c0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800063c2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800063c4:	12 38       	cp.w	r8,r9
800063c6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800063ca:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800063ce:	f3 d8 e3 19 	subcs	r9,r9,r8
800063d2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800063d6:	6e e8       	ld.w	r8,r7[0x38]
800063d8:	2f f8       	sub	r8,-1
800063da:	8f e8       	st.w	r7[0x38],r8
}
800063dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	66 c0       	ld.w	r0,r3[0x30]
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	78 f4       	ld.w	r4,r12[0x3c]

800063e8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800063e8:	eb cd 40 c0 	pushm	r6-r7,lr
800063ec:	18 97       	mov	r7,r12
800063ee:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063f0:	78 ec       	ld.w	r12,r12[0x38]
800063f2:	6e f8       	ld.w	r8,r7[0x3c]
800063f4:	10 3c       	cp.w	r12,r8
800063f6:	c0 33       	brcs	800063fc <xQueueGenericSendFromISR+0x14>
800063f8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063fc:	12 9a       	mov	r10,r9
800063fe:	0e 9c       	mov	r12,r7
80006400:	f0 1f 00 0c 	mcall	80006430 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006404:	6f 28       	ld.w	r8,r7[0x48]
80006406:	5b f8       	cp.w	r8,-1
80006408:	c0 d1       	brne	80006422 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000640a:	6e 98       	ld.w	r8,r7[0x24]
8000640c:	58 08       	cp.w	r8,0
8000640e:	c0 f0       	breq	8000642c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006410:	ee cc ff dc 	sub	r12,r7,-36
80006414:	f0 1f 00 08 	mcall	80006434 <xQueueGenericSendFromISR+0x4c>
80006418:	c0 a0       	breq	8000642c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000641a:	30 1c       	mov	r12,1
8000641c:	8d 0c       	st.w	r6[0x0],r12
8000641e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006422:	2f f8       	sub	r8,-1
80006424:	ef 48 00 48 	st.w	r7[72],r8
80006428:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000642c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	63 70       	ld.w	r0,r1[0x5c]
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	67 9c       	ld.w	r12,r3[0x64]

80006438 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006438:	d4 31       	pushm	r0-r7,lr
8000643a:	20 5d       	sub	sp,20
8000643c:	18 97       	mov	r7,r12
8000643e:	50 0b       	stdsp	sp[0x0],r11
80006440:	50 2a       	stdsp	sp[0x8],r10
80006442:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006444:	f8 c0 ff f0 	sub	r0,r12,-16
80006448:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000644a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000644e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006450:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006454:	f0 1f 00 2f 	mcall	80006510 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006458:	6e e9       	ld.w	r9,r7[0x38]
8000645a:	6e f8       	ld.w	r8,r7[0x3c]
8000645c:	10 39       	cp.w	r9,r8
8000645e:	c1 42       	brcc	80006486 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006460:	40 1a       	lddsp	r10,sp[0x4]
80006462:	40 0b       	lddsp	r11,sp[0x0]
80006464:	0e 9c       	mov	r12,r7
80006466:	f0 1f 00 2c 	mcall	80006514 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000646a:	6e 98       	ld.w	r8,r7[0x24]
8000646c:	58 08       	cp.w	r8,0
8000646e:	c0 80       	breq	8000647e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006470:	ee cc ff dc 	sub	r12,r7,-36
80006474:	f0 1f 00 29 	mcall	80006518 <xQueueGenericSend+0xe0>
80006478:	58 1c       	cp.w	r12,1
8000647a:	c0 21       	brne	8000647e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000647c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000647e:	f0 1f 00 28 	mcall	8000651c <xQueueGenericSend+0xe4>
80006482:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006484:	c4 38       	rjmp	8000650a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006486:	40 28       	lddsp	r8,sp[0x8]
80006488:	58 08       	cp.w	r8,0
8000648a:	c0 51       	brne	80006494 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000648c:	f0 1f 00 24 	mcall	8000651c <xQueueGenericSend+0xe4>
80006490:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006492:	c3 c8       	rjmp	8000650a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006494:	58 04       	cp.w	r4,0
80006496:	c0 51       	brne	800064a0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006498:	06 9c       	mov	r12,r3
8000649a:	f0 1f 00 22 	mcall	80006520 <xQueueGenericSend+0xe8>
8000649e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800064a0:	f0 1f 00 1f 	mcall	8000651c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800064a4:	f0 1f 00 20 	mcall	80006524 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800064a8:	f0 1f 00 1a 	mcall	80006510 <xQueueGenericSend+0xd8>
800064ac:	6f 18       	ld.w	r8,r7[0x44]
800064ae:	5b f8       	cp.w	r8,-1
800064b0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800064b4:	6f 28       	ld.w	r8,r7[0x48]
800064b6:	5b f8       	cp.w	r8,-1
800064b8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800064bc:	f0 1f 00 18 	mcall	8000651c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800064c0:	04 9b       	mov	r11,r2
800064c2:	06 9c       	mov	r12,r3
800064c4:	f0 1f 00 19 	mcall	80006528 <xQueueGenericSend+0xf0>
800064c8:	c1 b1       	brne	800064fe <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800064ca:	f0 1f 00 12 	mcall	80006510 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800064ce:	6e e5       	ld.w	r5,r7[0x38]
800064d0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800064d2:	f0 1f 00 13 	mcall	8000651c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800064d6:	0c 35       	cp.w	r5,r6
800064d8:	c0 d1       	brne	800064f2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800064da:	40 2b       	lddsp	r11,sp[0x8]
800064dc:	00 9c       	mov	r12,r0
800064de:	f0 1f 00 14 	mcall	8000652c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800064e2:	0e 9c       	mov	r12,r7
800064e4:	f0 1f 00 13 	mcall	80006530 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800064e8:	f0 1f 00 13 	mcall	80006534 <xQueueGenericSend+0xfc>
800064ec:	cb 41       	brne	80006454 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800064ee:	d7 33       	scall
800064f0:	cb 2b       	rjmp	80006454 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800064f2:	0e 9c       	mov	r12,r7
800064f4:	f0 1f 00 0f 	mcall	80006530 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800064f8:	f0 1f 00 0f 	mcall	80006534 <xQueueGenericSend+0xfc>
800064fc:	ca cb       	rjmp	80006454 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800064fe:	0e 9c       	mov	r12,r7
80006500:	f0 1f 00 0c 	mcall	80006530 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006504:	f0 1f 00 0c 	mcall	80006534 <xQueueGenericSend+0xfc>
80006508:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000650a:	2f bd       	sub	sp,-20
8000650c:	d8 32       	popm	r0-r7,pc
8000650e:	00 00       	add	r0,r0
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	5e 78       	retpl	r8
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	63 70       	ld.w	r0,r1[0x5c]
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	67 9c       	ld.w	r12,r3[0x64]
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	5f 84       	srls	r4
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	66 90       	ld.w	r0,r3[0x24]
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	66 04       	ld.w	r4,r3[0x0]
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	69 2c       	ld.w	r12,r4[0x48]
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	6b cc       	ld.w	r12,r5[0x70]
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	61 8c       	ld.w	r12,r0[0x60]
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	69 c0       	ld.w	r0,r4[0x70]

80006538 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006538:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000653c:	34 cc       	mov	r12,76
8000653e:	f0 1f 00 12 	mcall	80006584 <xQueueCreateMutex+0x4c>
80006542:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006544:	c1 d0       	breq	8000657e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006546:	30 06       	mov	r6,0
80006548:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000654a:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
8000654c:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000654e:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006550:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80006552:	30 18       	mov	r8,1
80006554:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006556:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000655a:	3f f8       	mov	r8,-1
8000655c:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006560:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006564:	2f 0c       	sub	r12,-16
80006566:	f0 1f 00 09 	mcall	80006588 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000656a:	ee cc ff dc 	sub	r12,r7,-36
8000656e:	f0 1f 00 07 	mcall	80006588 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006572:	0c 99       	mov	r9,r6
80006574:	0c 9a       	mov	r10,r6
80006576:	0c 9b       	mov	r11,r6
80006578:	0e 9c       	mov	r12,r7
8000657a:	f0 1f 00 05 	mcall	8000658c <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000657e:	0e 9c       	mov	r12,r7
80006580:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	60 e4       	ld.w	r4,r0[0x38]
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	5d 54       	*unknown*
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	64 38       	ld.w	r8,r2[0xc]

80006590 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006590:	d4 21       	pushm	r4-r7,lr
80006592:	18 97       	mov	r7,r12
80006594:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006596:	58 0c       	cp.w	r12,0
80006598:	c2 f0       	breq	800065f6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000659a:	34 cc       	mov	r12,76
8000659c:	f0 1f 00 17 	mcall	800065f8 <xQueueCreate+0x68>
800065a0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800065a2:	c2 a0       	breq	800065f6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800065a4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800065a8:	e8 cc ff ff 	sub	r12,r4,-1
800065ac:	f0 1f 00 13 	mcall	800065f8 <xQueueCreate+0x68>
800065b0:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800065b2:	c1 e0       	breq	800065ee <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800065b4:	f8 04 00 04 	add	r4,r12,r4
800065b8:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800065ba:	30 08       	mov	r8,0
800065bc:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800065be:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800065c0:	ee c8 00 01 	sub	r8,r7,1
800065c4:	ad 38       	mul	r8,r6
800065c6:	10 0c       	add	r12,r8
800065c8:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800065ca:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800065cc:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800065d0:	3f f8       	mov	r8,-1
800065d2:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800065d6:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800065da:	ea cc ff f0 	sub	r12,r5,-16
800065de:	f0 1f 00 08 	mcall	800065fc <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800065e2:	ea cc ff dc 	sub	r12,r5,-36
800065e6:	f0 1f 00 06 	mcall	800065fc <xQueueCreate+0x6c>
800065ea:	0a 9c       	mov	r12,r5
800065ec:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800065ee:	0a 9c       	mov	r12,r5
800065f0:	f0 1f 00 04 	mcall	80006600 <xQueueCreate+0x70>
800065f4:	d8 2a       	popm	r4-r7,pc,r12=0
800065f6:	d8 2a       	popm	r4-r7,pc,r12=0
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	60 e4       	ld.w	r4,r0[0x38]
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	5d 54       	*unknown*
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	60 bc       	ld.w	r12,r0[0x2c]

80006604 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006604:	48 38       	lddpc	r8,80006610 <vTaskSuspendAll+0xc>
80006606:	70 09       	ld.w	r9,r8[0x0]
80006608:	2f f9       	sub	r9,-1
8000660a:	91 09       	st.w	r8[0x0],r9
}
8000660c:	5e fc       	retal	r12
8000660e:	00 00       	add	r0,r0
80006610:	00 00       	add	r0,r0
80006612:	0d 28       	ld.uh	r8,r6++

80006614 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006614:	49 a8       	lddpc	r8,8000667c <vTaskSwitchContext+0x68>
80006616:	70 08       	ld.w	r8,r8[0x0]
80006618:	58 08       	cp.w	r8,0
8000661a:	c0 b1       	brne	80006630 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000661c:	49 98       	lddpc	r8,80006680 <vTaskSwitchContext+0x6c>
8000661e:	70 08       	ld.w	r8,r8[0x0]
80006620:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006624:	49 89       	lddpc	r9,80006684 <vTaskSwitchContext+0x70>
80006626:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000662a:	58 08       	cp.w	r8,0
8000662c:	c0 60       	breq	80006638 <vTaskSwitchContext+0x24>
8000662e:	c1 18       	rjmp	80006650 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006630:	30 19       	mov	r9,1
80006632:	49 68       	lddpc	r8,80006688 <vTaskSwitchContext+0x74>
80006634:	91 09       	st.w	r8[0x0],r9
80006636:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006638:	49 28       	lddpc	r8,80006680 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000663a:	49 3a       	lddpc	r10,80006684 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000663c:	70 09       	ld.w	r9,r8[0x0]
8000663e:	20 19       	sub	r9,1
80006640:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006642:	70 09       	ld.w	r9,r8[0x0]
80006644:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006648:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000664c:	58 09       	cp.w	r9,0
8000664e:	cf 70       	breq	8000663c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006650:	48 c8       	lddpc	r8,80006680 <vTaskSwitchContext+0x6c>
80006652:	70 08       	ld.w	r8,r8[0x0]
80006654:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006658:	48 b9       	lddpc	r9,80006684 <vTaskSwitchContext+0x70>
8000665a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000665e:	70 19       	ld.w	r9,r8[0x4]
80006660:	72 19       	ld.w	r9,r9[0x4]
80006662:	91 19       	st.w	r8[0x4],r9
80006664:	f0 ca ff f8 	sub	r10,r8,-8
80006668:	14 39       	cp.w	r9,r10
8000666a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000666e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006672:	70 18       	ld.w	r8,r8[0x4]
80006674:	70 39       	ld.w	r9,r8[0xc]
80006676:	48 68       	lddpc	r8,8000668c <vTaskSwitchContext+0x78>
80006678:	91 09       	st.w	r8[0x0],r9
8000667a:	5e fc       	retal	r12
8000667c:	00 00       	add	r0,r0
8000667e:	0d 28       	ld.uh	r8,r6++
80006680:	00 00       	add	r0,r0
80006682:	0d 60       	ld.uh	r0,--r6
80006684:	00 00       	add	r0,r0
80006686:	0c 44       	or	r4,r6
80006688:	00 00       	add	r0,r0
8000668a:	0d 48       	ld.w	r8,--r6
8000668c:	00 00       	add	r0,r0
8000668e:	0c f8       	st.b	--r6,r8

80006690 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006690:	48 48       	lddpc	r8,800066a0 <vTaskSetTimeOutState+0x10>
80006692:	70 08       	ld.w	r8,r8[0x0]
80006694:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006696:	48 48       	lddpc	r8,800066a4 <vTaskSetTimeOutState+0x14>
80006698:	70 08       	ld.w	r8,r8[0x0]
8000669a:	99 18       	st.w	r12[0x4],r8
}
8000669c:	5e fc       	retal	r12
8000669e:	00 00       	add	r0,r0
800066a0:	00 00       	add	r0,r0
800066a2:	0c 3c       	cp.w	r12,r6
800066a4:	00 00       	add	r0,r0
800066a6:	0d 24       	ld.uh	r4,r6++

800066a8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800066a8:	30 19       	mov	r9,1
800066aa:	48 28       	lddpc	r8,800066b0 <vTaskMissedYield+0x8>
800066ac:	91 09       	st.w	r8[0x0],r9
}
800066ae:	5e fc       	retal	r12
800066b0:	00 00       	add	r0,r0
800066b2:	0d 48       	ld.w	r8,--r6

800066b4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800066b4:	48 28       	lddpc	r8,800066bc <xTaskGetCurrentTaskHandle+0x8>
800066b6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800066b8:	5e fc       	retal	r12
800066ba:	00 00       	add	r0,r0
800066bc:	00 00       	add	r0,r0
800066be:	0c f8       	st.b	--r6,r8

800066c0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800066c0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800066c4:	58 0c       	cp.w	r12,0
800066c6:	c1 f0       	breq	80006704 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800066c8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800066ca:	78 b9       	ld.w	r9,r12[0x2c]
800066cc:	79 18       	ld.w	r8,r12[0x44]
800066ce:	10 39       	cp.w	r9,r8
800066d0:	c1 a0       	breq	80006704 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800066d2:	f8 c6 ff fc 	sub	r6,r12,-4
800066d6:	0c 9c       	mov	r12,r6
800066d8:	f0 1f 00 0c 	mcall	80006708 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800066dc:	6f 1c       	ld.w	r12,r7[0x44]
800066de:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800066e0:	f8 08 11 08 	rsub	r8,r12,8
800066e4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800066e6:	48 a8       	lddpc	r8,8000670c <vTaskPriorityDisinherit+0x4c>
800066e8:	70 08       	ld.w	r8,r8[0x0]
800066ea:	10 3c       	cp.w	r12,r8
800066ec:	e0 88 00 04 	brls	800066f4 <vTaskPriorityDisinherit+0x34>
800066f0:	48 78       	lddpc	r8,8000670c <vTaskPriorityDisinherit+0x4c>
800066f2:	91 0c       	st.w	r8[0x0],r12
800066f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066f8:	0c 9b       	mov	r11,r6
800066fa:	48 68       	lddpc	r8,80006710 <vTaskPriorityDisinherit+0x50>
800066fc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006700:	f0 1f 00 05 	mcall	80006714 <vTaskPriorityDisinherit+0x54>
80006704:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	5d be       	*unknown*
8000670c:	00 00       	add	r0,r0
8000670e:	0d 60       	ld.uh	r0,--r6
80006710:	00 00       	add	r0,r0
80006712:	0c 44       	or	r4,r6
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	5d 6e       	*unknown*

80006718 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006718:	eb cd 40 c0 	pushm	r6-r7,lr
8000671c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000671e:	49 b8       	lddpc	r8,80006788 <vTaskPriorityInherit+0x70>
80006720:	70 08       	ld.w	r8,r8[0x0]
80006722:	78 b9       	ld.w	r9,r12[0x2c]
80006724:	70 b8       	ld.w	r8,r8[0x2c]
80006726:	10 39       	cp.w	r9,r8
80006728:	c2 d2       	brcc	80006782 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000672a:	49 88       	lddpc	r8,80006788 <vTaskPriorityInherit+0x70>
8000672c:	70 08       	ld.w	r8,r8[0x0]
8000672e:	70 b8       	ld.w	r8,r8[0x2c]
80006730:	f0 08 11 08 	rsub	r8,r8,8
80006734:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006736:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000673a:	49 59       	lddpc	r9,8000678c <vTaskPriorityInherit+0x74>
8000673c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006740:	78 59       	ld.w	r9,r12[0x14]
80006742:	10 39       	cp.w	r9,r8
80006744:	c1 b1       	brne	8000677a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006746:	f8 c6 ff fc 	sub	r6,r12,-4
8000674a:	0c 9c       	mov	r12,r6
8000674c:	f0 1f 00 11 	mcall	80006790 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006750:	48 e8       	lddpc	r8,80006788 <vTaskPriorityInherit+0x70>
80006752:	70 08       	ld.w	r8,r8[0x0]
80006754:	70 bc       	ld.w	r12,r8[0x2c]
80006756:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006758:	48 f8       	lddpc	r8,80006794 <vTaskPriorityInherit+0x7c>
8000675a:	70 08       	ld.w	r8,r8[0x0]
8000675c:	10 3c       	cp.w	r12,r8
8000675e:	e0 88 00 04 	brls	80006766 <vTaskPriorityInherit+0x4e>
80006762:	48 d8       	lddpc	r8,80006794 <vTaskPriorityInherit+0x7c>
80006764:	91 0c       	st.w	r8[0x0],r12
80006766:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000676a:	0c 9b       	mov	r11,r6
8000676c:	48 88       	lddpc	r8,8000678c <vTaskPriorityInherit+0x74>
8000676e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006772:	f0 1f 00 0a 	mcall	80006798 <vTaskPriorityInherit+0x80>
80006776:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000677a:	48 48       	lddpc	r8,80006788 <vTaskPriorityInherit+0x70>
8000677c:	70 08       	ld.w	r8,r8[0x0]
8000677e:	70 b8       	ld.w	r8,r8[0x2c]
80006780:	99 b8       	st.w	r12[0x2c],r8
80006782:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006786:	00 00       	add	r0,r0
80006788:	00 00       	add	r0,r0
8000678a:	0c f8       	st.b	--r6,r8
8000678c:	00 00       	add	r0,r0
8000678e:	0c 44       	or	r4,r6
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	5d be       	*unknown*
80006794:	00 00       	add	r0,r0
80006796:	0d 60       	ld.uh	r0,--r6
80006798:	80 00       	ld.sh	r0,r0[0x0]
8000679a:	5d 6e       	*unknown*

8000679c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000679c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800067a0:	78 38       	ld.w	r8,r12[0xc]
800067a2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800067a4:	ee c6 ff e8 	sub	r6,r7,-24
800067a8:	0c 9c       	mov	r12,r6
800067aa:	f0 1f 00 15 	mcall	800067fc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800067ae:	49 58       	lddpc	r8,80006800 <xTaskRemoveFromEventList+0x64>
800067b0:	70 08       	ld.w	r8,r8[0x0]
800067b2:	58 08       	cp.w	r8,0
800067b4:	c1 71       	brne	800067e2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800067b6:	ee c6 ff fc 	sub	r6,r7,-4
800067ba:	0c 9c       	mov	r12,r6
800067bc:	f0 1f 00 10 	mcall	800067fc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800067c0:	6e bc       	ld.w	r12,r7[0x2c]
800067c2:	49 18       	lddpc	r8,80006804 <xTaskRemoveFromEventList+0x68>
800067c4:	70 08       	ld.w	r8,r8[0x0]
800067c6:	10 3c       	cp.w	r12,r8
800067c8:	e0 88 00 04 	brls	800067d0 <xTaskRemoveFromEventList+0x34>
800067cc:	48 e8       	lddpc	r8,80006804 <xTaskRemoveFromEventList+0x68>
800067ce:	91 0c       	st.w	r8[0x0],r12
800067d0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067d4:	0c 9b       	mov	r11,r6
800067d6:	48 d8       	lddpc	r8,80006808 <xTaskRemoveFromEventList+0x6c>
800067d8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067dc:	f0 1f 00 0c 	mcall	8000680c <xTaskRemoveFromEventList+0x70>
800067e0:	c0 58       	rjmp	800067ea <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800067e2:	0c 9b       	mov	r11,r6
800067e4:	48 bc       	lddpc	r12,80006810 <xTaskRemoveFromEventList+0x74>
800067e6:	f0 1f 00 0a 	mcall	8000680c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067ea:	48 b8       	lddpc	r8,80006814 <xTaskRemoveFromEventList+0x78>
800067ec:	70 08       	ld.w	r8,r8[0x0]
800067ee:	6e b9       	ld.w	r9,r7[0x2c]
800067f0:	70 b8       	ld.w	r8,r8[0x2c]
800067f2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800067f4:	5f 2c       	srhs	r12
800067f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067fa:	00 00       	add	r0,r0
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	5d be       	*unknown*
80006800:	00 00       	add	r0,r0
80006802:	0d 28       	ld.uh	r8,r6++
80006804:	00 00       	add	r0,r0
80006806:	0d 60       	ld.uh	r0,--r6
80006808:	00 00       	add	r0,r0
8000680a:	0c 44       	or	r4,r6
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	5d 6e       	*unknown*
80006810:	00 00       	add	r0,r0
80006812:	0c fc       	st.b	--r6,r12
80006814:	00 00       	add	r0,r0
80006816:	0c f8       	st.b	--r6,r8

80006818 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006818:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000681c:	4b 98       	lddpc	r8,80006900 <vTaskIncrementTick+0xe8>
8000681e:	70 08       	ld.w	r8,r8[0x0]
80006820:	58 08       	cp.w	r8,0
80006822:	c6 91       	brne	800068f4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006824:	4b 88       	lddpc	r8,80006904 <vTaskIncrementTick+0xec>
80006826:	70 09       	ld.w	r9,r8[0x0]
80006828:	2f f9       	sub	r9,-1
8000682a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000682c:	70 08       	ld.w	r8,r8[0x0]
8000682e:	58 08       	cp.w	r8,0
80006830:	c1 a1       	brne	80006864 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006832:	4b 68       	lddpc	r8,80006908 <vTaskIncrementTick+0xf0>
80006834:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006836:	4b 69       	lddpc	r9,8000690c <vTaskIncrementTick+0xf4>
80006838:	72 0b       	ld.w	r11,r9[0x0]
8000683a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000683c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000683e:	4b 59       	lddpc	r9,80006910 <vTaskIncrementTick+0xf8>
80006840:	72 0a       	ld.w	r10,r9[0x0]
80006842:	2f fa       	sub	r10,-1
80006844:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006846:	70 08       	ld.w	r8,r8[0x0]
80006848:	70 08       	ld.w	r8,r8[0x0]
8000684a:	58 08       	cp.w	r8,0
8000684c:	c0 51       	brne	80006856 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000684e:	3f f9       	mov	r9,-1
80006850:	4b 18       	lddpc	r8,80006914 <vTaskIncrementTick+0xfc>
80006852:	91 09       	st.w	r8[0x0],r9
80006854:	c0 88       	rjmp	80006864 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006856:	4a d8       	lddpc	r8,80006908 <vTaskIncrementTick+0xf0>
80006858:	70 08       	ld.w	r8,r8[0x0]
8000685a:	70 38       	ld.w	r8,r8[0xc]
8000685c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000685e:	70 19       	ld.w	r9,r8[0x4]
80006860:	4a d8       	lddpc	r8,80006914 <vTaskIncrementTick+0xfc>
80006862:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006864:	4a 88       	lddpc	r8,80006904 <vTaskIncrementTick+0xec>
80006866:	70 09       	ld.w	r9,r8[0x0]
80006868:	4a b8       	lddpc	r8,80006914 <vTaskIncrementTick+0xfc>
8000686a:	70 08       	ld.w	r8,r8[0x0]
8000686c:	10 39       	cp.w	r9,r8
8000686e:	c4 73       	brcs	800068fc <vTaskIncrementTick+0xe4>
80006870:	4a 68       	lddpc	r8,80006908 <vTaskIncrementTick+0xf0>
80006872:	70 08       	ld.w	r8,r8[0x0]
80006874:	70 08       	ld.w	r8,r8[0x0]
80006876:	58 08       	cp.w	r8,0
80006878:	c0 c0       	breq	80006890 <vTaskIncrementTick+0x78>
8000687a:	4a 48       	lddpc	r8,80006908 <vTaskIncrementTick+0xf0>
8000687c:	70 08       	ld.w	r8,r8[0x0]
8000687e:	70 38       	ld.w	r8,r8[0xc]
80006880:	70 37       	ld.w	r7,r8[0xc]
80006882:	6e 18       	ld.w	r8,r7[0x4]
80006884:	4a 09       	lddpc	r9,80006904 <vTaskIncrementTick+0xec>
80006886:	72 09       	ld.w	r9,r9[0x0]
80006888:	12 38       	cp.w	r8,r9
8000688a:	e0 88 00 14 	brls	800068b2 <vTaskIncrementTick+0x9a>
8000688e:	c0 e8       	rjmp	800068aa <vTaskIncrementTick+0x92>
80006890:	3f f9       	mov	r9,-1
80006892:	4a 18       	lddpc	r8,80006914 <vTaskIncrementTick+0xfc>
80006894:	91 09       	st.w	r8[0x0],r9
80006896:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000689a:	6a 08       	ld.w	r8,r5[0x0]
8000689c:	70 38       	ld.w	r8,r8[0xc]
8000689e:	70 37       	ld.w	r7,r8[0xc]
800068a0:	6e 18       	ld.w	r8,r7[0x4]
800068a2:	64 09       	ld.w	r9,r2[0x0]
800068a4:	12 38       	cp.w	r8,r9
800068a6:	e0 88 00 0a 	brls	800068ba <vTaskIncrementTick+0xa2>
800068aa:	49 b9       	lddpc	r9,80006914 <vTaskIncrementTick+0xfc>
800068ac:	93 08       	st.w	r9[0x0],r8
800068ae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800068b2:	49 a4       	lddpc	r4,80006918 <vTaskIncrementTick+0x100>
800068b4:	49 a3       	lddpc	r3,8000691c <vTaskIncrementTick+0x104>
800068b6:	49 55       	lddpc	r5,80006908 <vTaskIncrementTick+0xf0>
800068b8:	49 32       	lddpc	r2,80006904 <vTaskIncrementTick+0xec>
800068ba:	ee c6 ff fc 	sub	r6,r7,-4
800068be:	0c 9c       	mov	r12,r6
800068c0:	f0 1f 00 18 	mcall	80006920 <vTaskIncrementTick+0x108>
800068c4:	6e a8       	ld.w	r8,r7[0x28]
800068c6:	58 08       	cp.w	r8,0
800068c8:	c0 50       	breq	800068d2 <vTaskIncrementTick+0xba>
800068ca:	ee cc ff e8 	sub	r12,r7,-24
800068ce:	f0 1f 00 15 	mcall	80006920 <vTaskIncrementTick+0x108>
800068d2:	6e bc       	ld.w	r12,r7[0x2c]
800068d4:	68 08       	ld.w	r8,r4[0x0]
800068d6:	10 3c       	cp.w	r12,r8
800068d8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800068dc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800068e0:	0c 9b       	mov	r11,r6
800068e2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800068e6:	f0 1f 00 10 	mcall	80006924 <vTaskIncrementTick+0x10c>
800068ea:	6a 08       	ld.w	r8,r5[0x0]
800068ec:	70 08       	ld.w	r8,r8[0x0]
800068ee:	58 08       	cp.w	r8,0
800068f0:	cd 51       	brne	8000689a <vTaskIncrementTick+0x82>
800068f2:	cc fb       	rjmp	80006890 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800068f4:	48 d8       	lddpc	r8,80006928 <vTaskIncrementTick+0x110>
800068f6:	70 09       	ld.w	r9,r8[0x0]
800068f8:	2f f9       	sub	r9,-1
800068fa:	91 09       	st.w	r8[0x0],r9
800068fc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006900:	00 00       	add	r0,r0
80006902:	0d 28       	ld.uh	r8,r6++
80006904:	00 00       	add	r0,r0
80006906:	0d 24       	ld.uh	r4,r6++
80006908:	00 00       	add	r0,r0
8000690a:	0c 30       	cp.w	r0,r6
8000690c:	00 00       	add	r0,r0
8000690e:	0c 40       	or	r0,r6
80006910:	00 00       	add	r0,r0
80006912:	0c 3c       	cp.w	r12,r6
80006914:	00 00       	add	r0,r0
80006916:	05 3c       	ld.ub	r12,r2++
80006918:	00 00       	add	r0,r0
8000691a:	0d 60       	ld.uh	r0,--r6
8000691c:	00 00       	add	r0,r0
8000691e:	0c 44       	or	r4,r6
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	5d be       	*unknown*
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	5d 6e       	*unknown*
80006928:	00 00       	add	r0,r0
8000692a:	0c 28       	rsub	r8,r6

8000692c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000692c:	eb cd 40 c0 	pushm	r6-r7,lr
80006930:	18 97       	mov	r7,r12
80006932:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006934:	f0 1f 00 15 	mcall	80006988 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006938:	6c 08       	ld.w	r8,r6[0x0]
8000693a:	5b f8       	cp.w	r8,-1
8000693c:	c0 31       	brne	80006942 <xTaskCheckForTimeOut+0x16>
8000693e:	30 07       	mov	r7,0
80006940:	c1 f8       	rjmp	8000697e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006942:	49 39       	lddpc	r9,8000698c <xTaskCheckForTimeOut+0x60>
80006944:	72 09       	ld.w	r9,r9[0x0]
80006946:	6e 0a       	ld.w	r10,r7[0x0]
80006948:	12 3a       	cp.w	r10,r9
8000694a:	c0 70       	breq	80006958 <xTaskCheckForTimeOut+0x2c>
8000694c:	49 19       	lddpc	r9,80006990 <xTaskCheckForTimeOut+0x64>
8000694e:	72 09       	ld.w	r9,r9[0x0]
80006950:	6e 1a       	ld.w	r10,r7[0x4]
80006952:	12 3a       	cp.w	r10,r9
80006954:	e0 88 00 14 	brls	8000697c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006958:	48 e9       	lddpc	r9,80006990 <xTaskCheckForTimeOut+0x64>
8000695a:	72 0a       	ld.w	r10,r9[0x0]
8000695c:	6e 19       	ld.w	r9,r7[0x4]
8000695e:	12 1a       	sub	r10,r9
80006960:	14 38       	cp.w	r8,r10
80006962:	e0 88 00 0d 	brls	8000697c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006966:	48 ba       	lddpc	r10,80006990 <xTaskCheckForTimeOut+0x64>
80006968:	74 0a       	ld.w	r10,r10[0x0]
8000696a:	14 19       	sub	r9,r10
8000696c:	f2 08 00 08 	add	r8,r9,r8
80006970:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006972:	0e 9c       	mov	r12,r7
80006974:	f0 1f 00 08 	mcall	80006994 <xTaskCheckForTimeOut+0x68>
80006978:	30 07       	mov	r7,0
8000697a:	c0 28       	rjmp	8000697e <xTaskCheckForTimeOut+0x52>
8000697c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000697e:	f0 1f 00 07 	mcall	80006998 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006982:	0e 9c       	mov	r12,r7
80006984:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	5e 78       	retpl	r8
8000698c:	00 00       	add	r0,r0
8000698e:	0c 3c       	cp.w	r12,r6
80006990:	00 00       	add	r0,r0
80006992:	0d 24       	ld.uh	r4,r6++
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	66 90       	ld.w	r0,r3[0x24]
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	5f 84       	srls	r4

8000699c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000699c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800069a0:	f0 1f 00 05 	mcall	800069b4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800069a4:	48 58       	lddpc	r8,800069b8 <xTaskGetTickCount+0x1c>
800069a6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800069a8:	f0 1f 00 05 	mcall	800069bc <xTaskGetTickCount+0x20>

	return xTicks;
}
800069ac:	0e 9c       	mov	r12,r7
800069ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800069b2:	00 00       	add	r0,r0
800069b4:	80 00       	ld.sh	r0,r0[0x0]
800069b6:	5e 78       	retpl	r8
800069b8:	00 00       	add	r0,r0
800069ba:	0d 24       	ld.uh	r4,r6++
800069bc:	80 00       	ld.sh	r0,r0[0x0]
800069be:	5f 84       	srls	r4

800069c0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800069c0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800069c4:	f0 1f 00 2c 	mcall	80006a74 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800069c8:	4a c8       	lddpc	r8,80006a78 <xTaskResumeAll+0xb8>
800069ca:	70 09       	ld.w	r9,r8[0x0]
800069cc:	20 19       	sub	r9,1
800069ce:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800069d0:	70 08       	ld.w	r8,r8[0x0]
800069d2:	58 08       	cp.w	r8,0
800069d4:	c4 91       	brne	80006a66 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800069d6:	4a a8       	lddpc	r8,80006a7c <xTaskResumeAll+0xbc>
800069d8:	70 08       	ld.w	r8,r8[0x0]
800069da:	58 08       	cp.w	r8,0
800069dc:	c4 50       	breq	80006a66 <xTaskResumeAll+0xa6>
800069de:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069e0:	4a 85       	lddpc	r5,80006a80 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800069e2:	4a 93       	lddpc	r3,80006a84 <xTaskResumeAll+0xc4>
800069e4:	4a 92       	lddpc	r2,80006a88 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069e6:	4a a1       	lddpc	r1,80006a8c <xTaskResumeAll+0xcc>
800069e8:	c1 e8       	rjmp	80006a24 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800069ea:	6a 38       	ld.w	r8,r5[0xc]
800069ec:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800069ee:	ee cc ff e8 	sub	r12,r7,-24
800069f2:	f0 1f 00 28 	mcall	80006a90 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800069f6:	ee c6 ff fc 	sub	r6,r7,-4
800069fa:	0c 9c       	mov	r12,r6
800069fc:	f0 1f 00 25 	mcall	80006a90 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006a00:	6e bc       	ld.w	r12,r7[0x2c]
80006a02:	66 08       	ld.w	r8,r3[0x0]
80006a04:	10 3c       	cp.w	r12,r8
80006a06:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006a0a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006a0e:	0c 9b       	mov	r11,r6
80006a10:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006a14:	f0 1f 00 20 	mcall	80006a94 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006a18:	62 08       	ld.w	r8,r1[0x0]
80006a1a:	6e b9       	ld.w	r9,r7[0x2c]
80006a1c:	70 b8       	ld.w	r8,r8[0x2c]
80006a1e:	10 39       	cp.w	r9,r8
80006a20:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006a24:	6a 08       	ld.w	r8,r5[0x0]
80006a26:	58 08       	cp.w	r8,0
80006a28:	ce 11       	brne	800069ea <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a2a:	49 c8       	lddpc	r8,80006a98 <xTaskResumeAll+0xd8>
80006a2c:	70 08       	ld.w	r8,r8[0x0]
80006a2e:	58 08       	cp.w	r8,0
80006a30:	c0 f0       	breq	80006a4e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a32:	49 a8       	lddpc	r8,80006a98 <xTaskResumeAll+0xd8>
80006a34:	70 08       	ld.w	r8,r8[0x0]
80006a36:	58 08       	cp.w	r8,0
80006a38:	c1 10       	breq	80006a5a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006a3a:	49 87       	lddpc	r7,80006a98 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006a3c:	f0 1f 00 18 	mcall	80006a9c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006a40:	6e 08       	ld.w	r8,r7[0x0]
80006a42:	20 18       	sub	r8,1
80006a44:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a46:	6e 08       	ld.w	r8,r7[0x0]
80006a48:	58 08       	cp.w	r8,0
80006a4a:	cf 91       	brne	80006a3c <xTaskResumeAll+0x7c>
80006a4c:	c0 78       	rjmp	80006a5a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006a4e:	58 14       	cp.w	r4,1
80006a50:	c0 50       	breq	80006a5a <xTaskResumeAll+0x9a>
80006a52:	49 48       	lddpc	r8,80006aa0 <xTaskResumeAll+0xe0>
80006a54:	70 08       	ld.w	r8,r8[0x0]
80006a56:	58 18       	cp.w	r8,1
80006a58:	c0 71       	brne	80006a66 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006a5a:	30 09       	mov	r9,0
80006a5c:	49 18       	lddpc	r8,80006aa0 <xTaskResumeAll+0xe0>
80006a5e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006a60:	d7 33       	scall
80006a62:	30 17       	mov	r7,1
80006a64:	c0 28       	rjmp	80006a68 <xTaskResumeAll+0xa8>
80006a66:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006a68:	f0 1f 00 0f 	mcall	80006aa4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006a6c:	0e 9c       	mov	r12,r7
80006a6e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006a72:	00 00       	add	r0,r0
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	5e 78       	retpl	r8
80006a78:	00 00       	add	r0,r0
80006a7a:	0d 28       	ld.uh	r8,r6++
80006a7c:	00 00       	add	r0,r0
80006a7e:	0d 44       	ld.w	r4,--r6
80006a80:	00 00       	add	r0,r0
80006a82:	0c fc       	st.b	--r6,r12
80006a84:	00 00       	add	r0,r0
80006a86:	0d 60       	ld.uh	r0,--r6
80006a88:	00 00       	add	r0,r0
80006a8a:	0c 44       	or	r4,r6
80006a8c:	00 00       	add	r0,r0
80006a8e:	0c f8       	st.b	--r6,r8
80006a90:	80 00       	ld.sh	r0,r0[0x0]
80006a92:	5d be       	*unknown*
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	5d 6e       	*unknown*
80006a98:	00 00       	add	r0,r0
80006a9a:	0c 28       	rsub	r8,r6
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	68 18       	ld.w	r8,r4[0x4]
80006aa0:	00 00       	add	r0,r0
80006aa2:	0d 48       	ld.w	r8,--r6
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	5f 84       	srls	r4

80006aa8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006aa8:	eb cd 40 80 	pushm	r7,lr
80006aac:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006aae:	49 08       	lddpc	r8,80006aec <prvAddCurrentTaskToDelayedList+0x44>
80006ab0:	70 08       	ld.w	r8,r8[0x0]
80006ab2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006ab4:	48 f8       	lddpc	r8,80006af0 <prvAddCurrentTaskToDelayedList+0x48>
80006ab6:	70 08       	ld.w	r8,r8[0x0]
80006ab8:	10 3c       	cp.w	r12,r8
80006aba:	c0 a2       	brcc	80006ace <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006abc:	48 c8       	lddpc	r8,80006aec <prvAddCurrentTaskToDelayedList+0x44>
80006abe:	70 0b       	ld.w	r11,r8[0x0]
80006ac0:	48 d8       	lddpc	r8,80006af4 <prvAddCurrentTaskToDelayedList+0x4c>
80006ac2:	70 0c       	ld.w	r12,r8[0x0]
80006ac4:	2f cb       	sub	r11,-4
80006ac6:	f0 1f 00 0d 	mcall	80006af8 <prvAddCurrentTaskToDelayedList+0x50>
80006aca:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ace:	48 88       	lddpc	r8,80006aec <prvAddCurrentTaskToDelayedList+0x44>
80006ad0:	70 0b       	ld.w	r11,r8[0x0]
80006ad2:	48 b8       	lddpc	r8,80006afc <prvAddCurrentTaskToDelayedList+0x54>
80006ad4:	70 0c       	ld.w	r12,r8[0x0]
80006ad6:	2f cb       	sub	r11,-4
80006ad8:	f0 1f 00 08 	mcall	80006af8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006adc:	48 98       	lddpc	r8,80006b00 <prvAddCurrentTaskToDelayedList+0x58>
80006ade:	70 08       	ld.w	r8,r8[0x0]
80006ae0:	10 37       	cp.w	r7,r8
80006ae2:	c0 32       	brcc	80006ae8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006ae4:	48 78       	lddpc	r8,80006b00 <prvAddCurrentTaskToDelayedList+0x58>
80006ae6:	91 07       	st.w	r8[0x0],r7
80006ae8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006aec:	00 00       	add	r0,r0
80006aee:	0c f8       	st.b	--r6,r8
80006af0:	00 00       	add	r0,r0
80006af2:	0d 24       	ld.uh	r4,r6++
80006af4:	00 00       	add	r0,r0
80006af6:	0c 40       	or	r0,r6
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	5d 8a       	*unknown*
80006afc:	00 00       	add	r0,r0
80006afe:	0c 30       	cp.w	r0,r6
80006b00:	00 00       	add	r0,r0
80006b02:	05 3c       	ld.ub	r12,r2++

80006b04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006b04:	eb cd 40 c0 	pushm	r6-r7,lr
80006b08:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006b0a:	58 0c       	cp.w	r12,0
80006b0c:	c1 10       	breq	80006b2e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006b0e:	f0 1f 00 0a 	mcall	80006b34 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006b12:	48 a8       	lddpc	r8,80006b38 <vTaskDelay+0x34>
80006b14:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b16:	48 a8       	lddpc	r8,80006b3c <vTaskDelay+0x38>
80006b18:	70 0c       	ld.w	r12,r8[0x0]
80006b1a:	2f cc       	sub	r12,-4
80006b1c:	f0 1f 00 09 	mcall	80006b40 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b20:	ee 06 00 0c 	add	r12,r7,r6
80006b24:	f0 1f 00 08 	mcall	80006b44 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006b28:	f0 1f 00 08 	mcall	80006b48 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b2c:	c0 21       	brne	80006b30 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006b2e:	d7 33       	scall
80006b30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	66 04       	ld.w	r4,r3[0x0]
80006b38:	00 00       	add	r0,r0
80006b3a:	0d 24       	ld.uh	r4,r6++
80006b3c:	00 00       	add	r0,r0
80006b3e:	0c f8       	st.b	--r6,r8
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	5d be       	*unknown*
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	6a a8       	ld.w	r8,r5[0x28]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	69 c0       	ld.w	r0,r4[0x70]

80006b4c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006b4c:	eb cd 40 c0 	pushm	r6-r7,lr
80006b50:	18 96       	mov	r6,r12
80006b52:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006b54:	f0 1f 00 18 	mcall	80006bb4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006b58:	6c 08       	ld.w	r8,r6[0x0]
80006b5a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006b5c:	49 79       	lddpc	r9,80006bb8 <vTaskDelayUntil+0x6c>
80006b5e:	72 09       	ld.w	r9,r9[0x0]
80006b60:	12 38       	cp.w	r8,r9
80006b62:	e0 88 00 0c 	brls	80006b7a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006b66:	0e 38       	cp.w	r8,r7
80006b68:	e0 88 00 22 	brls	80006bac <vTaskDelayUntil+0x60>
80006b6c:	49 38       	lddpc	r8,80006bb8 <vTaskDelayUntil+0x6c>
80006b6e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b70:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006b72:	10 37       	cp.w	r7,r8
80006b74:	e0 88 00 14 	brls	80006b9c <vTaskDelayUntil+0x50>
80006b78:	c0 a8       	rjmp	80006b8c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006b7a:	0e 38       	cp.w	r8,r7
80006b7c:	e0 8b 00 16 	brhi	80006ba8 <vTaskDelayUntil+0x5c>
80006b80:	48 e8       	lddpc	r8,80006bb8 <vTaskDelayUntil+0x6c>
80006b82:	70 08       	ld.w	r8,r8[0x0]
80006b84:	10 37       	cp.w	r7,r8
80006b86:	e0 8b 00 11 	brhi	80006ba8 <vTaskDelayUntil+0x5c>
80006b8a:	c1 18       	rjmp	80006bac <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b8c:	48 c8       	lddpc	r8,80006bbc <vTaskDelayUntil+0x70>
80006b8e:	70 0c       	ld.w	r12,r8[0x0]
80006b90:	2f cc       	sub	r12,-4
80006b92:	f0 1f 00 0c 	mcall	80006bc0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b96:	0e 9c       	mov	r12,r7
80006b98:	f0 1f 00 0b 	mcall	80006bc4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b9c:	f0 1f 00 0b 	mcall	80006bc8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006ba0:	c0 81       	brne	80006bb0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006ba2:	d7 33       	scall
80006ba4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ba8:	8d 07       	st.w	r6[0x0],r7
80006baa:	cf 1b       	rjmp	80006b8c <vTaskDelayUntil+0x40>
80006bac:	8d 07       	st.w	r6[0x0],r7
80006bae:	cf 7b       	rjmp	80006b9c <vTaskDelayUntil+0x50>
80006bb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	66 04       	ld.w	r4,r3[0x0]
80006bb8:	00 00       	add	r0,r0
80006bba:	0d 24       	ld.uh	r4,r6++
80006bbc:	00 00       	add	r0,r0
80006bbe:	0c f8       	st.b	--r6,r8
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	5d be       	*unknown*
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	6a a8       	ld.w	r8,r5[0x28]
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	69 c0       	ld.w	r0,r4[0x70]

80006bcc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006bcc:	eb cd 40 c0 	pushm	r6-r7,lr
80006bd0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006bd2:	48 e7       	lddpc	r7,80006c08 <vTaskPlaceOnEventList+0x3c>
80006bd4:	6e 0b       	ld.w	r11,r7[0x0]
80006bd6:	2e 8b       	sub	r11,-24
80006bd8:	f0 1f 00 0d 	mcall	80006c0c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bdc:	6e 0c       	ld.w	r12,r7[0x0]
80006bde:	2f cc       	sub	r12,-4
80006be0:	f0 1f 00 0c 	mcall	80006c10 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006be4:	5b f6       	cp.w	r6,-1
80006be6:	c0 81       	brne	80006bf6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006be8:	6e 0b       	ld.w	r11,r7[0x0]
80006bea:	2f cb       	sub	r11,-4
80006bec:	48 ac       	lddpc	r12,80006c14 <vTaskPlaceOnEventList+0x48>
80006bee:	f0 1f 00 0b 	mcall	80006c18 <vTaskPlaceOnEventList+0x4c>
80006bf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006bf6:	48 a8       	lddpc	r8,80006c1c <vTaskPlaceOnEventList+0x50>
80006bf8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006bfa:	ec 0c 00 0c 	add	r12,r6,r12
80006bfe:	f0 1f 00 09 	mcall	80006c20 <vTaskPlaceOnEventList+0x54>
80006c02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c06:	00 00       	add	r0,r0
80006c08:	00 00       	add	r0,r0
80006c0a:	0c f8       	st.b	--r6,r8
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	5d 8a       	*unknown*
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	5d be       	*unknown*
80006c14:	00 00       	add	r0,r0
80006c16:	0d 4c       	ld.w	r12,--r6
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	5d 6e       	*unknown*
80006c1c:	00 00       	add	r0,r0
80006c1e:	0d 24       	ld.uh	r4,r6++
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	6a a8       	ld.w	r8,r5[0x28]

80006c24 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006c24:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c28:	49 67       	lddpc	r7,80006c80 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c2a:	49 74       	lddpc	r4,80006c84 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006c2c:	49 73       	lddpc	r3,80006c88 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c2e:	49 85       	lddpc	r5,80006c8c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c30:	6e 08       	ld.w	r8,r7[0x0]
80006c32:	58 08       	cp.w	r8,0
80006c34:	c1 e0       	breq	80006c70 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006c36:	f0 1f 00 17 	mcall	80006c90 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c3a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006c3c:	f0 1f 00 16 	mcall	80006c94 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006c40:	58 06       	cp.w	r6,0
80006c42:	c1 70       	breq	80006c70 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006c44:	f0 1f 00 15 	mcall	80006c98 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006c48:	68 38       	ld.w	r8,r4[0xc]
80006c4a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006c4c:	ec cc ff fc 	sub	r12,r6,-4
80006c50:	f0 1f 00 13 	mcall	80006c9c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006c54:	66 08       	ld.w	r8,r3[0x0]
80006c56:	20 18       	sub	r8,1
80006c58:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006c5a:	6e 08       	ld.w	r8,r7[0x0]
80006c5c:	20 18       	sub	r8,1
80006c5e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006c60:	f0 1f 00 10 	mcall	80006ca0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006c64:	6c cc       	ld.w	r12,r6[0x30]
80006c66:	f0 1f 00 10 	mcall	80006ca4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006c6a:	0c 9c       	mov	r12,r6
80006c6c:	f0 1f 00 0e 	mcall	80006ca4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c70:	6a 08       	ld.w	r8,r5[0x0]
80006c72:	58 18       	cp.w	r8,1
80006c74:	e0 88 00 03 	brls	80006c7a <prvIdleTask+0x56>
			{
				taskYIELD();
80006c78:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006c7a:	f0 1f 00 0c 	mcall	80006ca8 <prvIdleTask+0x84>
		}
		#endif
	}
80006c7e:	cd 9b       	rjmp	80006c30 <prvIdleTask+0xc>
80006c80:	00 00       	add	r0,r0
80006c82:	0c 38       	cp.w	r8,r6
80006c84:	00 00       	add	r0,r0
80006c86:	0c e4       	st.h	--r6,r4
80006c88:	00 00       	add	r0,r0
80006c8a:	0d 44       	ld.w	r4,--r6
80006c8c:	00 00       	add	r0,r0
80006c8e:	0c 44       	or	r4,r6
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	66 04       	ld.w	r4,r3[0x0]
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	69 c0       	ld.w	r0,r4[0x70]
80006c98:	80 00       	ld.sh	r0,r0[0x0]
80006c9a:	5e 78       	retpl	r8
80006c9c:	80 00       	ld.sh	r0,r0[0x0]
80006c9e:	5d be       	*unknown*
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	5f 84       	srls	r4
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	60 bc       	ld.w	r12,r0[0x2c]
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	20 2c       	sub	r12,2

80006cac <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006cac:	d4 31       	pushm	r0-r7,lr
80006cae:	20 1d       	sub	sp,4
80006cb0:	fa c4 ff d8 	sub	r4,sp,-40
80006cb4:	50 0c       	stdsp	sp[0x0],r12
80006cb6:	16 91       	mov	r1,r11
80006cb8:	14 97       	mov	r7,r10
80006cba:	12 90       	mov	r0,r9
80006cbc:	10 93       	mov	r3,r8
80006cbe:	68 02       	ld.w	r2,r4[0x0]
80006cc0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006cc2:	34 8c       	mov	r12,72
80006cc4:	f0 1f 00 5c 	mcall	80006e34 <xTaskGenericCreate+0x188>
80006cc8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006cca:	c0 31       	brne	80006cd0 <xTaskGenericCreate+0x24>
80006ccc:	3f fc       	mov	r12,-1
80006cce:	ca f8       	rjmp	80006e2c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006cd0:	58 06       	cp.w	r6,0
80006cd2:	e0 81 00 af 	brne	80006e30 <xTaskGenericCreate+0x184>
80006cd6:	0e 9c       	mov	r12,r7
80006cd8:	5c 7c       	castu.h	r12
80006cda:	a3 6c       	lsl	r12,0x2
80006cdc:	f0 1f 00 56 	mcall	80006e34 <xTaskGenericCreate+0x188>
80006ce0:	18 96       	mov	r6,r12
80006ce2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006ce4:	c0 61       	brne	80006cf0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006ce6:	0a 9c       	mov	r12,r5
80006ce8:	f0 1f 00 54 	mcall	80006e38 <xTaskGenericCreate+0x18c>
80006cec:	3f fc       	mov	r12,-1
80006cee:	c9 f8       	rjmp	80006e2c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006cf0:	5c 77       	castu.h	r7
80006cf2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006cf6:	e0 6b 00 a5 	mov	r11,165
80006cfa:	0c 9c       	mov	r12,r6
80006cfc:	f0 1f 00 50 	mcall	80006e3c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006d00:	ee c6 00 01 	sub	r6,r7,1
80006d04:	6a c8       	ld.w	r8,r5[0x30]
80006d06:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006d0a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006d0e:	31 0a       	mov	r10,16
80006d10:	02 9b       	mov	r11,r1
80006d12:	ea cc ff cc 	sub	r12,r5,-52
80006d16:	f0 1f 00 4b 	mcall	80006e40 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006d1a:	30 08       	mov	r8,0
80006d1c:	eb 68 00 43 	st.b	r5[67],r8
80006d20:	58 73       	cp.w	r3,7
80006d22:	e6 07 17 80 	movls	r7,r3
80006d26:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006d2a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006d2c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006d30:	ea c4 ff fc 	sub	r4,r5,-4
80006d34:	08 9c       	mov	r12,r4
80006d36:	f0 1f 00 44 	mcall	80006e44 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006d3a:	ea cc ff e8 	sub	r12,r5,-24
80006d3e:	f0 1f 00 42 	mcall	80006e44 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006d42:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006d44:	ee 07 11 08 	rsub	r7,r7,8
80006d48:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006d4a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006d4c:	00 9a       	mov	r10,r0
80006d4e:	40 0b       	lddsp	r11,sp[0x0]
80006d50:	0c 9c       	mov	r12,r6
80006d52:	f0 1f 00 3e 	mcall	80006e48 <xTaskGenericCreate+0x19c>
80006d56:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006d58:	58 02       	cp.w	r2,0
80006d5a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006d5e:	f0 1f 00 3c 	mcall	80006e4c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006d62:	4b c8       	lddpc	r8,80006e50 <xTaskGenericCreate+0x1a4>
80006d64:	70 09       	ld.w	r9,r8[0x0]
80006d66:	2f f9       	sub	r9,-1
80006d68:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006d6a:	4b b8       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1a8>
80006d6c:	70 08       	ld.w	r8,r8[0x0]
80006d6e:	58 08       	cp.w	r8,0
80006d70:	c2 61       	brne	80006dbc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006d72:	4b 98       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1a8>
80006d74:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006d76:	4b 78       	lddpc	r8,80006e50 <xTaskGenericCreate+0x1a4>
80006d78:	70 08       	ld.w	r8,r8[0x0]
80006d7a:	58 18       	cp.w	r8,1
80006d7c:	c2 b1       	brne	80006dd2 <xTaskGenericCreate+0x126>
80006d7e:	4b 77       	lddpc	r7,80006e58 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006d80:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006d84:	0e 9c       	mov	r12,r7
80006d86:	f0 1f 00 36 	mcall	80006e5c <xTaskGenericCreate+0x1b0>
80006d8a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d8c:	0c 37       	cp.w	r7,r6
80006d8e:	cf b1       	brne	80006d84 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d90:	4b 47       	lddpc	r7,80006e60 <xTaskGenericCreate+0x1b4>
80006d92:	0e 9c       	mov	r12,r7
80006d94:	f0 1f 00 32 	mcall	80006e5c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d98:	4b 36       	lddpc	r6,80006e64 <xTaskGenericCreate+0x1b8>
80006d9a:	0c 9c       	mov	r12,r6
80006d9c:	f0 1f 00 30 	mcall	80006e5c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006da0:	4b 2c       	lddpc	r12,80006e68 <xTaskGenericCreate+0x1bc>
80006da2:	f0 1f 00 2f 	mcall	80006e5c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006da6:	4b 2c       	lddpc	r12,80006e6c <xTaskGenericCreate+0x1c0>
80006da8:	f0 1f 00 2d 	mcall	80006e5c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006dac:	4b 1c       	lddpc	r12,80006e70 <xTaskGenericCreate+0x1c4>
80006dae:	f0 1f 00 2c 	mcall	80006e5c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006db2:	4b 18       	lddpc	r8,80006e74 <xTaskGenericCreate+0x1c8>
80006db4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006db6:	4b 18       	lddpc	r8,80006e78 <xTaskGenericCreate+0x1cc>
80006db8:	91 06       	st.w	r8[0x0],r6
80006dba:	c0 c8       	rjmp	80006dd2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006dbc:	4b 08       	lddpc	r8,80006e7c <xTaskGenericCreate+0x1d0>
80006dbe:	70 08       	ld.w	r8,r8[0x0]
80006dc0:	58 08       	cp.w	r8,0
80006dc2:	c0 81       	brne	80006dd2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006dc4:	4a 48       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1a8>
80006dc6:	70 08       	ld.w	r8,r8[0x0]
80006dc8:	70 b8       	ld.w	r8,r8[0x2c]
80006dca:	10 33       	cp.w	r3,r8
80006dcc:	c0 33       	brcs	80006dd2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006dce:	4a 28       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1a8>
80006dd0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006dd2:	6a b8       	ld.w	r8,r5[0x2c]
80006dd4:	4a b9       	lddpc	r9,80006e80 <xTaskGenericCreate+0x1d4>
80006dd6:	72 09       	ld.w	r9,r9[0x0]
80006dd8:	12 38       	cp.w	r8,r9
80006dda:	e0 88 00 04 	brls	80006de2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006dde:	4a 99       	lddpc	r9,80006e80 <xTaskGenericCreate+0x1d4>
80006de0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006de2:	4a 98       	lddpc	r8,80006e84 <xTaskGenericCreate+0x1d8>
80006de4:	70 09       	ld.w	r9,r8[0x0]
80006de6:	2f f9       	sub	r9,-1
80006de8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006dea:	6a b8       	ld.w	r8,r5[0x2c]
80006dec:	4a 79       	lddpc	r9,80006e88 <xTaskGenericCreate+0x1dc>
80006dee:	72 09       	ld.w	r9,r9[0x0]
80006df0:	12 38       	cp.w	r8,r9
80006df2:	e0 88 00 04 	brls	80006dfa <xTaskGenericCreate+0x14e>
80006df6:	4a 59       	lddpc	r9,80006e88 <xTaskGenericCreate+0x1dc>
80006df8:	93 08       	st.w	r9[0x0],r8
80006dfa:	6a bc       	ld.w	r12,r5[0x2c]
80006dfc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006e00:	08 9b       	mov	r11,r4
80006e02:	49 68       	lddpc	r8,80006e58 <xTaskGenericCreate+0x1ac>
80006e04:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006e08:	f0 1f 00 21 	mcall	80006e8c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006e0c:	f0 1f 00 21 	mcall	80006e90 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006e10:	49 b8       	lddpc	r8,80006e7c <xTaskGenericCreate+0x1d0>
80006e12:	70 08       	ld.w	r8,r8[0x0]
80006e14:	58 08       	cp.w	r8,0
80006e16:	c0 a0       	breq	80006e2a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006e18:	48 f8       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1a8>
80006e1a:	70 08       	ld.w	r8,r8[0x0]
80006e1c:	70 b8       	ld.w	r8,r8[0x2c]
80006e1e:	10 33       	cp.w	r3,r8
80006e20:	e0 88 00 05 	brls	80006e2a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006e24:	d7 33       	scall
80006e26:	30 1c       	mov	r12,1
80006e28:	c0 28       	rjmp	80006e2c <xTaskGenericCreate+0x180>
80006e2a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006e2c:	2f fd       	sub	sp,-4
80006e2e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006e30:	99 c6       	st.w	r12[0x30],r6
80006e32:	c5 fb       	rjmp	80006cf0 <xTaskGenericCreate+0x44>
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	60 e4       	ld.w	r4,r0[0x38]
80006e38:	80 00       	ld.sh	r0,r0[0x0]
80006e3a:	60 bc       	ld.w	r12,r0[0x2c]
80006e3c:	80 00       	ld.sh	r0,r0[0x0]
80006e3e:	7a 3c       	ld.w	r12,sp[0xc]
80006e40:	80 00       	ld.sh	r0,r0[0x0]
80006e42:	7d 68       	ld.w	r8,lr[0x58]
80006e44:	80 00       	ld.sh	r0,r0[0x0]
80006e46:	5d 68       	*unknown*
80006e48:	80 00       	ld.sh	r0,r0[0x0]
80006e4a:	5d e4       	*unknown*
80006e4c:	80 00       	ld.sh	r0,r0[0x0]
80006e4e:	5e 78       	retpl	r8
80006e50:	00 00       	add	r0,r0
80006e52:	0d 44       	ld.w	r4,--r6
80006e54:	00 00       	add	r0,r0
80006e56:	0c f8       	st.b	--r6,r8
80006e58:	00 00       	add	r0,r0
80006e5a:	0c 44       	or	r4,r6
80006e5c:	80 00       	ld.sh	r0,r0[0x0]
80006e5e:	5d 54       	*unknown*
80006e60:	00 00       	add	r0,r0
80006e62:	0d 10       	ld.sh	r0,r6++
80006e64:	00 00       	add	r0,r0
80006e66:	0d 2c       	ld.uh	r12,r6++
80006e68:	00 00       	add	r0,r0
80006e6a:	0c fc       	st.b	--r6,r12
80006e6c:	00 00       	add	r0,r0
80006e6e:	0c e4       	st.h	--r6,r4
80006e70:	00 00       	add	r0,r0
80006e72:	0d 4c       	ld.w	r12,--r6
80006e74:	00 00       	add	r0,r0
80006e76:	0c 30       	cp.w	r0,r6
80006e78:	00 00       	add	r0,r0
80006e7a:	0c 40       	or	r0,r6
80006e7c:	00 00       	add	r0,r0
80006e7e:	0c 34       	cp.w	r4,r6
80006e80:	00 00       	add	r0,r0
80006e82:	0c 2c       	rsub	r12,r6
80006e84:	00 00       	add	r0,r0
80006e86:	0d 40       	ld.w	r0,--r6
80006e88:	00 00       	add	r0,r0
80006e8a:	0d 60       	ld.uh	r0,--r6
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	5d 6e       	*unknown*
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	5f 84       	srls	r4

80006e94 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e94:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e96:	30 09       	mov	r9,0
80006e98:	1a d9       	st.w	--sp,r9
80006e9a:	1a d9       	st.w	--sp,r9
80006e9c:	1a d9       	st.w	--sp,r9
80006e9e:	12 98       	mov	r8,r9
80006ea0:	e0 6a 01 00 	mov	r10,256
80006ea4:	48 9b       	lddpc	r11,80006ec8 <vTaskStartScheduler+0x34>
80006ea6:	48 ac       	lddpc	r12,80006ecc <vTaskStartScheduler+0x38>
80006ea8:	f0 1f 00 0a 	mcall	80006ed0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006eac:	2f dd       	sub	sp,-12
80006eae:	58 1c       	cp.w	r12,1
80006eb0:	c0 a1       	brne	80006ec4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006eb2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006eb4:	30 19       	mov	r9,1
80006eb6:	48 88       	lddpc	r8,80006ed4 <vTaskStartScheduler+0x40>
80006eb8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006eba:	30 09       	mov	r9,0
80006ebc:	48 78       	lddpc	r8,80006ed8 <vTaskStartScheduler+0x44>
80006ebe:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006ec0:	f0 1f 00 07 	mcall	80006edc <vTaskStartScheduler+0x48>
80006ec4:	d8 02       	popm	pc
80006ec6:	00 00       	add	r0,r0
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	da 20       	acall	0xa2
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	6c 24       	ld.w	r4,r6[0x8]
80006ed0:	80 00       	ld.sh	r0,r0[0x0]
80006ed2:	6c ac       	ld.w	r12,r6[0x28]
80006ed4:	00 00       	add	r0,r0
80006ed6:	0c 34       	cp.w	r4,r6
80006ed8:	00 00       	add	r0,r0
80006eda:	0d 24       	ld.uh	r4,r6++
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	5e 88       	retls	r8

80006ee0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006ee0:	16 cc       	st.b	r11++,r12
	return str;
}
80006ee2:	5e fb       	retal	r11

80006ee4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006ee4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ee8:	20 3d       	sub	sp,12
80006eea:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006eec:	30 06       	mov	r6,0
80006eee:	30 07       	mov	r7,0
80006ef0:	fa e7 00 00 	st.d	sp[0],r6
80006ef4:	30 0c       	mov	r12,0
80006ef6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006ef8:	58 08       	cp.w	r8,0
80006efa:	c1 30       	breq	80006f20 <PrintHex+0x3c>
80006efc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006efe:	1a 9c       	mov	r12,sp
80006f00:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006f04:	58 9e       	cp.w	lr,9
80006f06:	e0 8a 00 04 	brle	80006f0e <PrintHex+0x2a>
80006f0a:	2c 9e       	sub	lr,-55
80006f0c:	c0 48       	rjmp	80006f14 <PrintHex+0x30>
80006f0e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006f12:	2d 0e       	sub	lr,-48
80006f14:	f8 09 0b 0e 	st.b	r12[r9],lr
80006f18:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006f1a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006f1c:	cf 21       	brne	80006f00 <PrintHex+0x1c>
80006f1e:	c0 48       	rjmp	80006f26 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006f20:	33 08       	mov	r8,48
80006f22:	ba 88       	st.b	sp[0x0],r8
80006f24:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006f26:	f6 09 01 08 	sub	r8,r11,r9
80006f2a:	58 08       	cp.w	r8,0
80006f2c:	e0 8a 00 13 	brle	80006f52 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006f30:	12 1b       	sub	r11,r9
80006f32:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006f36:	18 9e       	mov	lr,r12
80006f38:	58 0c       	cp.w	r12,0
80006f3a:	e0 8a 00 0c 	brle	80006f52 <PrintHex+0x6e>
80006f3e:	1a 9b       	mov	r11,sp
80006f40:	12 0b       	add	r11,r9
80006f42:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f44:	33 07       	mov	r7,48
80006f46:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f48:	2f f8       	sub	r8,-1
80006f4a:	1c 38       	cp.w	r8,lr
80006f4c:	cf d5       	brlt	80006f46 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f4e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f52:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006f56:	f0 cb ff ff 	sub	r11,r8,-1
80006f5a:	58 0b       	cp.w	r11,0
80006f5c:	e0 8a 00 19 	brle	80006f8e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f60:	fa cb ff f4 	sub	r11,sp,-12
80006f64:	f6 09 00 09 	add	r9,r11,r9
80006f68:	37 8b       	mov	r11,120
80006f6a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006f6e:	fa c9 ff f4 	sub	r9,sp,-12
80006f72:	10 09       	add	r9,r8
80006f74:	33 0b       	mov	r11,48
80006f76:	f3 6b ff f4 	st.b	r9[-12],r11
80006f7a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f7e:	fa ce 00 01 	sub	lr,sp,1
80006f82:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f84:	11 8b       	ld.ub	r11,r8[0x0]
80006f86:	12 cb       	st.b	r9++,r11
80006f88:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006f8a:	1c 38       	cp.w	r8,lr
80006f8c:	cf c1       	brne	80006f84 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f8e:	14 9c       	mov	r12,r10
80006f90:	2f dd       	sub	sp,-12
80006f92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f96 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f96:	d4 21       	pushm	r4-r7,lr
80006f98:	20 3d       	sub	sp,12
80006f9a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f9c:	30 06       	mov	r6,0
80006f9e:	30 07       	mov	r7,0
80006fa0:	fa e7 00 00 	st.d	sp[0],r6
80006fa4:	30 0c       	mov	r12,0
80006fa6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006fa8:	58 08       	cp.w	r8,0
80006faa:	c0 35       	brlt	80006fb0 <PrintDec+0x1a>
80006fac:	14 97       	mov	r7,r10
80006fae:	c0 58       	rjmp	80006fb8 <PrintDec+0x22>
	{
		*p++ = '-';
80006fb0:	14 97       	mov	r7,r10
80006fb2:	32 d9       	mov	r9,45
80006fb4:	0e c9       	st.b	r7++,r9
		i = -i;
80006fb6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006fb8:	58 08       	cp.w	r8,0
80006fba:	c0 51       	brne	80006fc4 <PrintDec+0x2e>
80006fbc:	33 08       	mov	r8,48
80006fbe:	ba 88       	st.b	sp[0x0],r8
80006fc0:	30 1e       	mov	lr,1
80006fc2:	c2 f8       	rjmp	80007020 <PrintDec+0x8a>
	
	int ten = i%10;
80006fc4:	e0 65 66 67 	mov	r5,26215
80006fc8:	ea 15 66 66 	orh	r5,0x6666
80006fcc:	f0 05 04 44 	muls.d	r4,r8,r5
80006fd0:	ea 0c 14 02 	asr	r12,r5,0x2
80006fd4:	f0 09 14 1f 	asr	r9,r8,0x1f
80006fd8:	f8 09 01 09 	sub	r9,r12,r9
80006fdc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fe0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006fe4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006fe6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006fe8:	e0 66 66 67 	mov	r6,26215
80006fec:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006ff0:	2d 09       	sub	r9,-48
80006ff2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006ff6:	2f fe       	sub	lr,-1
		i /= 10;
80006ff8:	f0 06 04 44 	muls.d	r4,r8,r6
80006ffc:	ea 09 14 02 	asr	r9,r5,0x2
80007000:	bf 58       	asr	r8,0x1f
80007002:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007006:	f0 06 04 44 	muls.d	r4,r8,r6
8000700a:	ea 09 14 02 	asr	r9,r5,0x2
8000700e:	f0 05 14 1f 	asr	r5,r8,0x1f
80007012:	0a 19       	sub	r9,r5
80007014:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007018:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000701c:	58 08       	cp.w	r8,0
8000701e:	ce 91       	brne	80006ff0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007020:	f6 0e 01 08 	sub	r8,r11,lr
80007024:	58 08       	cp.w	r8,0
80007026:	e0 89 00 06 	brgt	80007032 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000702a:	58 0e       	cp.w	lr,0
8000702c:	e0 89 00 14 	brgt	80007054 <PrintDec+0xbe>
80007030:	c1 d8       	rjmp	8000706a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007032:	1c 1b       	sub	r11,lr
80007034:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007036:	16 9c       	mov	r12,r11
80007038:	58 0b       	cp.w	r11,0
8000703a:	fe 9a ff f8 	brle	8000702a <PrintDec+0x94>
8000703e:	1a 99       	mov	r9,sp
80007040:	1c 09       	add	r9,lr
80007042:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007044:	33 06       	mov	r6,48
80007046:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007048:	2f f8       	sub	r8,-1
8000704a:	18 38       	cp.w	r8,r12
8000704c:	cf d5       	brlt	80007046 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000704e:	f6 0e 00 0e 	add	lr,r11,lr
80007052:	ce cb       	rjmp	8000702a <PrintDec+0x94>
80007054:	fa c8 ff f4 	sub	r8,sp,-12
80007058:	1c 08       	add	r8,lr
8000705a:	20 d8       	sub	r8,13
8000705c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007060:	11 89       	ld.ub	r9,r8[0x0]
80007062:	0e c9       	st.b	r7++,r9
80007064:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007066:	16 38       	cp.w	r8,r11
80007068:	cf c1       	brne	80007060 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000706a:	14 9c       	mov	r12,r10
8000706c:	2f dd       	sub	sp,-12
8000706e:	d8 22       	popm	r4-r7,pc

80007070 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007070:	d4 31       	pushm	r0-r7,lr
80007072:	fa cd 02 08 	sub	sp,sp,520
80007076:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007078:	e0 6a 01 00 	mov	r10,256
8000707c:	30 0b       	mov	r11,0
8000707e:	fa cc fe f8 	sub	r12,sp,-264
80007082:	f0 1f 00 4e 	mcall	800071b8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007086:	fa c4 fd d4 	sub	r4,sp,-556
8000708a:	30 0a       	mov	r10,0
8000708c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000708e:	fa c3 ff fc 	sub	r3,sp,-4
80007092:	e0 61 01 00 	mov	r1,256
80007096:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007098:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000709a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000709e:	02 9a       	mov	r10,r1
800070a0:	00 9b       	mov	r11,r0
800070a2:	06 9c       	mov	r12,r3
800070a4:	f0 1f 00 45 	mcall	800071b8 <log+0x148>
			
					if(*str == '%')
800070a8:	0f 88       	ld.ub	r8,r7[0x0]
800070aa:	e4 08 18 00 	cp.b	r8,r2
800070ae:	c5 71       	brne	8000715c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800070b0:	ee c8 ff ff 	sub	r8,r7,-1
800070b4:	11 89       	ld.ub	r9,r8[0x0]
800070b6:	4c 2a       	lddpc	r10,800071bc <log+0x14c>
800070b8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800070ba:	23 09       	sub	r9,48
800070bc:	30 9a       	mov	r10,9
800070be:	f4 09 18 00 	cp.b	r9,r10
800070c2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800070c6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800070ca:	f7 b9 08 30 	subls	r9,48
800070ce:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800070d2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800070d6:	0f 88       	ld.ub	r8,r7[0x0]
800070d8:	22 58       	sub	r8,37
800070da:	e0 48 00 53 	cp.w	r8,83
800070de:	e0 8b 00 31 	brhi	80007140 <log+0xd0>
800070e2:	4b 89       	lddpc	r9,800071c0 <log+0x150>
800070e4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800070e8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800070ec:	06 9a       	mov	r10,r3
800070ee:	40 0b       	lddsp	r11,sp[0x0]
800070f0:	5c 5b       	castu.b	r11
800070f2:	68 0c       	ld.w	r12,r4[0x0]
800070f4:	f0 1f 00 34 	mcall	800071c4 <log+0x154>
							break;
800070f8:	c2 98       	rjmp	8000714a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800070fa:	4b 4c       	lddpc	r12,800071c8 <log+0x158>
800070fc:	f0 1f 00 34 	mcall	800071cc <log+0x15c>
80007100:	08 95       	mov	r5,r4
80007102:	06 9c       	mov	r12,r3
							break;
80007104:	c2 38       	rjmp	8000714a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007106:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000710a:	06 9a       	mov	r10,r3
8000710c:	40 0b       	lddsp	r11,sp[0x0]
8000710e:	5c 5b       	castu.b	r11
80007110:	68 0c       	ld.w	r12,r4[0x0]
80007112:	f0 1f 00 30 	mcall	800071d0 <log+0x160>
80007116:	06 9c       	mov	r12,r3
							break;
80007118:	c1 98       	rjmp	8000714a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000711a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000711e:	06 9b       	mov	r11,r3
80007120:	09 bc       	ld.ub	r12,r4[0x3]
80007122:	f0 1f 00 2d 	mcall	800071d4 <log+0x164>
80007126:	06 9c       	mov	r12,r3
							break;
80007128:	c1 18       	rjmp	8000714a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000712a:	e8 c5 ff fc 	sub	r5,r4,-4
8000712e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007130:	c0 d8       	rjmp	8000714a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007132:	06 9b       	mov	r11,r3
80007134:	32 5c       	mov	r12,37
80007136:	f0 1f 00 28 	mcall	800071d4 <log+0x164>
8000713a:	08 95       	mov	r5,r4
8000713c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000713e:	c0 68       	rjmp	8000714a <log+0xda>
							
							default:
							log("I need relax.");
80007140:	4a 6c       	lddpc	r12,800071d8 <log+0x168>
80007142:	f0 1f 00 23 	mcall	800071cc <log+0x15c>
80007146:	08 95       	mov	r5,r4
80007148:	06 9c       	mov	r12,r3
						}
						str++;
8000714a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000714c:	1a dc       	st.w	--sp,r12
8000714e:	1a d6       	st.w	--sp,r6
80007150:	4a 3b       	lddpc	r11,800071dc <log+0x16c>
80007152:	0c 9c       	mov	r12,r6
80007154:	f0 1f 00 23 	mcall	800071e0 <log+0x170>
80007158:	2f ed       	sub	sp,-8
8000715a:	c0 a8       	rjmp	8000716e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000715c:	2f f7       	sub	r7,-1
8000715e:	1a d8       	st.w	--sp,r8
80007160:	1a d6       	st.w	--sp,r6
80007162:	4a 1b       	lddpc	r11,800071e4 <log+0x174>
80007164:	0c 9c       	mov	r12,r6
80007166:	f0 1f 00 1f 	mcall	800071e0 <log+0x170>
8000716a:	08 95       	mov	r5,r4
8000716c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000716e:	0f 89       	ld.ub	r9,r7[0x0]
80007170:	30 08       	mov	r8,0
80007172:	f0 09 18 00 	cp.b	r9,r8
80007176:	c0 30       	breq	8000717c <log+0x10c>
80007178:	0a 94       	mov	r4,r5
8000717a:	c9 2b       	rjmp	8000709e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000717c:	fa c7 fe f8 	sub	r7,sp,-264
80007180:	1a d7       	st.w	--sp,r7
80007182:	49 ab       	lddpc	r11,800071e8 <log+0x178>
80007184:	0e 9c       	mov	r12,r7
80007186:	f0 1f 00 17 	mcall	800071e0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000718a:	5c 5c       	castu.b	r12
8000718c:	f8 c6 ff ff 	sub	r6,r12,-1
80007190:	0c 9c       	mov	r12,r6
80007192:	f0 1f 00 17 	mcall	800071ec <log+0x17c>
80007196:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007198:	0c 9a       	mov	r10,r6
8000719a:	0e 9b       	mov	r11,r7
8000719c:	f0 1f 00 15 	mcall	800071f0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800071a0:	30 09       	mov	r9,0
800071a2:	30 5a       	mov	r10,5
800071a4:	fa cb fe f8 	sub	r11,sp,-264
800071a8:	49 38       	lddpc	r8,800071f4 <log+0x184>
800071aa:	70 0c       	ld.w	r12,r8[0x0]
800071ac:	f0 1f 00 13 	mcall	800071f8 <log+0x188>
800071b0:	2f fd       	sub	sp,-4
	
	
}
800071b2:	fe 3d fd f8 	sub	sp,-520
800071b6:	d8 32       	popm	r0-r7,pc
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	7a 3c       	ld.w	r12,sp[0xc]
800071bc:	00 00       	add	r0,r0
800071be:	0d 64       	ld.uh	r4,--r6
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	da 28       	*unknown*
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	6f 96       	ld.w	r6,r7[0x64]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	dc d4       	*unknown*
800071cc:	80 00       	ld.sh	r0,r0[0x0]
800071ce:	70 70       	ld.w	r0,r8[0x1c]
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	6e e4       	ld.w	r4,r7[0x38]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	6e e0       	ld.w	r0,r7[0x38]
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	dc e4       	*unknown*
800071dc:	80 00       	ld.sh	r0,r0[0x0]
800071de:	dc f4       	*unknown*
800071e0:	80 00       	ld.sh	r0,r0[0x0]
800071e2:	7d 2c       	ld.w	r12,lr[0x48]
800071e4:	80 00       	ld.sh	r0,r0[0x0]
800071e6:	dc fc       	*unknown*
800071e8:	80 00       	ld.sh	r0,r0[0x0]
800071ea:	dd 04       	*unknown*
800071ec:	80 00       	ld.sh	r0,r0[0x0]
800071ee:	60 e4       	ld.w	r4,r0[0x38]
800071f0:	80 00       	ld.sh	r0,r0[0x0]
800071f2:	78 f4       	ld.w	r4,r12[0x3c]
800071f4:	00 00       	add	r0,r0
800071f6:	53 cc       	stdsp	sp[0xf0],r12
800071f8:	80 00       	ld.sh	r0,r0[0x0]
800071fa:	64 38       	ld.w	r8,r2[0xc]

800071fc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800071fc:	d4 31       	pushm	r0-r7,lr
800071fe:	fa cd 02 0c 	sub	sp,sp,524
80007202:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007204:	e0 6a 01 00 	mov	r10,256
80007208:	30 0b       	mov	r11,0
8000720a:	fa cc fe f4 	sub	r12,sp,-268
8000720e:	f0 1f 00 4c 	mcall	8000733c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007212:	fa c4 fd d0 	sub	r4,sp,-560
80007216:	30 0a       	mov	r10,0
80007218:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000721a:	fa c3 ff fc 	sub	r3,sp,-4
8000721e:	e0 61 01 00 	mov	r1,256
80007222:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007224:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007226:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000722a:	02 9a       	mov	r10,r1
8000722c:	00 9b       	mov	r11,r0
8000722e:	06 9c       	mov	r12,r3
80007230:	f0 1f 00 43 	mcall	8000733c <logFromISR+0x140>
			
			if(*str == '%')
80007234:	0f 88       	ld.ub	r8,r7[0x0]
80007236:	e4 08 18 00 	cp.b	r8,r2
8000723a:	c5 11       	brne	800072dc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000723c:	ee c8 ff ff 	sub	r8,r7,-1
80007240:	11 89       	ld.ub	r9,r8[0x0]
80007242:	4c 0a       	lddpc	r10,80007340 <logFromISR+0x144>
80007244:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007246:	23 09       	sub	r9,48
80007248:	30 9a       	mov	r10,9
8000724a:	f4 09 18 00 	cp.b	r9,r10
8000724e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007252:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007256:	f7 b9 08 30 	subls	r9,48
8000725a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000725e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007262:	0f 88       	ld.ub	r8,r7[0x0]
80007264:	22 58       	sub	r8,37
80007266:	e0 48 00 53 	cp.w	r8,83
8000726a:	e0 8b 00 2b 	brhi	800072c0 <logFromISR+0xc4>
8000726e:	4b 69       	lddpc	r9,80007344 <logFromISR+0x148>
80007270:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007274:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007278:	06 9a       	mov	r10,r3
8000727a:	40 0b       	lddsp	r11,sp[0x0]
8000727c:	5c 5b       	castu.b	r11
8000727e:	68 0c       	ld.w	r12,r4[0x0]
80007280:	f0 1f 00 32 	mcall	80007348 <logFromISR+0x14c>
					break;
80007284:	c2 38       	rjmp	800072ca <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007286:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000728a:	06 9a       	mov	r10,r3
8000728c:	40 0b       	lddsp	r11,sp[0x0]
8000728e:	5c 5b       	castu.b	r11
80007290:	68 0c       	ld.w	r12,r4[0x0]
80007292:	f0 1f 00 2f 	mcall	8000734c <logFromISR+0x150>
80007296:	06 9c       	mov	r12,r3
					break;
80007298:	c1 98       	rjmp	800072ca <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000729a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000729e:	06 9b       	mov	r11,r3
800072a0:	09 bc       	ld.ub	r12,r4[0x3]
800072a2:	f0 1f 00 2c 	mcall	80007350 <logFromISR+0x154>
800072a6:	06 9c       	mov	r12,r3
					break;
800072a8:	c1 18       	rjmp	800072ca <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800072aa:	e8 c5 ff fc 	sub	r5,r4,-4
800072ae:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800072b0:	c0 d8       	rjmp	800072ca <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800072b2:	06 9b       	mov	r11,r3
800072b4:	32 5c       	mov	r12,37
800072b6:	f0 1f 00 27 	mcall	80007350 <logFromISR+0x154>
800072ba:	08 95       	mov	r5,r4
800072bc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800072be:	c0 68       	rjmp	800072ca <logFromISR+0xce>
					default:
					log("I need relax.");
800072c0:	4a 5c       	lddpc	r12,80007354 <logFromISR+0x158>
800072c2:	f0 1f 00 26 	mcall	80007358 <logFromISR+0x15c>
800072c6:	08 95       	mov	r5,r4
800072c8:	06 9c       	mov	r12,r3
				}
				str++;
800072ca:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800072cc:	1a dc       	st.w	--sp,r12
800072ce:	1a d6       	st.w	--sp,r6
800072d0:	4a 3b       	lddpc	r11,8000735c <logFromISR+0x160>
800072d2:	0c 9c       	mov	r12,r6
800072d4:	f0 1f 00 23 	mcall	80007360 <logFromISR+0x164>
800072d8:	2f ed       	sub	sp,-8
800072da:	c0 a8       	rjmp	800072ee <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072dc:	2f f7       	sub	r7,-1
800072de:	1a d8       	st.w	--sp,r8
800072e0:	1a d6       	st.w	--sp,r6
800072e2:	4a 1b       	lddpc	r11,80007364 <logFromISR+0x168>
800072e4:	0c 9c       	mov	r12,r6
800072e6:	f0 1f 00 1f 	mcall	80007360 <logFromISR+0x164>
800072ea:	08 95       	mov	r5,r4
800072ec:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800072ee:	0f 89       	ld.ub	r9,r7[0x0]
800072f0:	30 08       	mov	r8,0
800072f2:	f0 09 18 00 	cp.b	r9,r8
800072f6:	c0 30       	breq	800072fc <logFromISR+0x100>
800072f8:	0a 94       	mov	r4,r5
800072fa:	c9 8b       	rjmp	8000722a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800072fc:	fa c7 fe f4 	sub	r7,sp,-268
80007300:	1a d7       	st.w	--sp,r7
80007302:	49 ab       	lddpc	r11,80007368 <logFromISR+0x16c>
80007304:	0e 9c       	mov	r12,r7
80007306:	f0 1f 00 17 	mcall	80007360 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000730a:	5c 5c       	castu.b	r12
8000730c:	f8 c6 ff ff 	sub	r6,r12,-1
80007310:	0c 9c       	mov	r12,r6
80007312:	f0 1f 00 17 	mcall	8000736c <logFromISR+0x170>
80007316:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007318:	0c 9a       	mov	r10,r6
8000731a:	0e 9b       	mov	r11,r7
8000731c:	f0 1f 00 15 	mcall	80007370 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007320:	30 09       	mov	r9,0
80007322:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007324:	fa ca fe f8 	sub	r10,sp,-264
80007328:	fa cb fe f4 	sub	r11,sp,-268
8000732c:	49 28       	lddpc	r8,80007374 <logFromISR+0x178>
8000732e:	70 0c       	ld.w	r12,r8[0x0]
80007330:	f0 1f 00 12 	mcall	80007378 <logFromISR+0x17c>
80007334:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007336:	fe 3d fd f4 	sub	sp,-524
8000733a:	d8 32       	popm	r0-r7,pc
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	7a 3c       	ld.w	r12,sp[0xc]
80007340:	00 00       	add	r0,r0
80007342:	0d 65       	ld.uh	r5,--r6
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	db 78       	*unknown*
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	6f 96       	ld.w	r6,r7[0x64]
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	6e e4       	ld.w	r4,r7[0x38]
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	6e e0       	ld.w	r0,r7[0x38]
80007354:	80 00       	ld.sh	r0,r0[0x0]
80007356:	dc e4       	*unknown*
80007358:	80 00       	ld.sh	r0,r0[0x0]
8000735a:	70 70       	ld.w	r0,r8[0x1c]
8000735c:	80 00       	ld.sh	r0,r0[0x0]
8000735e:	dc f4       	*unknown*
80007360:	80 00       	ld.sh	r0,r0[0x0]
80007362:	7d 2c       	ld.w	r12,lr[0x48]
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	dc fc       	*unknown*
80007368:	80 00       	ld.sh	r0,r0[0x0]
8000736a:	dd 04       	*unknown*
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	60 e4       	ld.w	r4,r0[0x38]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	78 f4       	ld.w	r4,r12[0x3c]
80007374:	00 00       	add	r0,r0
80007376:	53 cc       	stdsp	sp[0xf0],r12
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	63 e8       	ld.w	r8,r1[0x78]

8000737c <log_init>:
		
	return str;
}

void log_init(void)
{
8000737c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000737e:	30 2b       	mov	r11,2
80007380:	48 fc       	lddpc	r12,800073bc <log_init+0x40>
80007382:	f0 1f 00 10 	mcall	800073c0 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007386:	e0 6a 36 00 	mov	r10,13824
8000738a:	ea 1a 01 6e 	orh	r10,0x16e
8000738e:	48 eb       	lddpc	r11,800073c4 <log_init+0x48>
80007390:	fe 7c 18 00 	mov	r12,-59392
80007394:	f0 1f 00 0d 	mcall	800073c8 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007398:	30 4b       	mov	r11,4
8000739a:	33 2c       	mov	r12,50
8000739c:	f0 1f 00 0c 	mcall	800073cc <log_init+0x50>
800073a0:	48 c8       	lddpc	r8,800073d0 <log_init+0x54>
800073a2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800073a4:	30 09       	mov	r9,0
800073a6:	1a d9       	st.w	--sp,r9
800073a8:	1a d9       	st.w	--sp,r9
800073aa:	1a d9       	st.w	--sp,r9
800073ac:	30 28       	mov	r8,2
800073ae:	36 4a       	mov	r10,100
800073b0:	48 9b       	lddpc	r11,800073d4 <log_init+0x58>
800073b2:	48 ac       	lddpc	r12,800073d8 <log_init+0x5c>
800073b4:	f0 1f 00 0a 	mcall	800073dc <log_init+0x60>
800073b8:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800073ba:	d8 02       	popm	pc
800073bc:	80 00       	ld.sh	r0,r0[0x0]
800073be:	dd 10       	acall	0xd1
800073c0:	80 00       	ld.sh	r0,r0[0x0]
800073c2:	54 54       	stdsp	sp[0x114],r4
800073c4:	80 00       	ld.sh	r0,r0[0x0]
800073c6:	dc c8       	*unknown*
800073c8:	80 00       	ld.sh	r0,r0[0x0]
800073ca:	5c 48       	abs	r8
800073cc:	80 00       	ld.sh	r0,r0[0x0]
800073ce:	65 90       	ld.w	r0,r2[0x64]
800073d0:	00 00       	add	r0,r0
800073d2:	53 cc       	stdsp	sp[0xf0],r12
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	dd 0c       	*unknown*
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	73 e0       	ld.w	r0,r9[0x78]
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	6c ac       	ld.w	r12,r6[0x28]

800073e0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800073e0:	eb cd 40 f8 	pushm	r3-r7,lr
800073e4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073e6:	48 c7       	lddpc	r7,80007414 <task_log+0x34>
800073e8:	30 05       	mov	r5,0
800073ea:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800073ec:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073f0:	0a 99       	mov	r9,r5
800073f2:	08 9a       	mov	r10,r4
800073f4:	1a 9b       	mov	r11,sp
800073f6:	6e 0c       	ld.w	r12,r7[0x0]
800073f8:	f0 1f 00 08 	mcall	80007418 <task_log+0x38>
800073fc:	58 1c       	cp.w	r12,1
800073fe:	cf 91       	brne	800073f0 <task_log+0x10>
		{
			if( NULL != str)
80007400:	40 0b       	lddsp	r11,sp[0x0]
80007402:	58 0b       	cp.w	r11,0
80007404:	cf 60       	breq	800073f0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007406:	06 9c       	mov	r12,r3
80007408:	f0 1f 00 05 	mcall	8000741c <task_log+0x3c>
				vPortFree(str);
8000740c:	40 0c       	lddsp	r12,sp[0x0]
8000740e:	f0 1f 00 05 	mcall	80007420 <task_log+0x40>
80007412:	ce fb       	rjmp	800073f0 <task_log+0x10>
80007414:	00 00       	add	r0,r0
80007416:	53 cc       	stdsp	sp[0xf0],r12
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	62 2c       	ld.w	r12,r1[0x8]
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	5b f8       	cp.w	r8,-1
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	60 bc       	ld.w	r12,r0[0x2c]

80007424 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007424:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007426:	fe 78 10 00 	mov	r8,-61440
8000742a:	30 19       	mov	r9,1
8000742c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007430:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007434:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007438:	d3 03       	ssrf	0x10
	local_start_pll0();
8000743a:	f0 1f 00 0d 	mcall	8000746c <main+0x48>
		
	INTC_init_interrupts();
8000743e:	f0 1f 00 0d 	mcall	80007470 <main+0x4c>
		
	log_init();
80007442:	f0 1f 00 0d 	mcall	80007474 <main+0x50>
	log("----start debug----");
80007446:	48 dc       	lddpc	r12,80007478 <main+0x54>
80007448:	f0 1f 00 0d 	mcall	8000747c <main+0x58>
	
	xg_flashc_init();
8000744c:	f0 1f 00 0d 	mcall	80007480 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007450:	f0 1f 00 0d 	mcall	80007484 <main+0x60>
		
	app_init();
80007454:	f0 1f 00 0d 	mcall	80007488 <main+0x64>
	
	xg_rtc_init();
80007458:	f0 1f 00 0d 	mcall	8000748c <main+0x68>
		
	xcmp_init();
8000745c:	f0 1f 00 0d 	mcall	80007490 <main+0x6c>

	local_start_timer();
80007460:	f0 1f 00 0d 	mcall	80007494 <main+0x70>
		
	vTaskStartScheduler();
80007464:	f0 1f 00 0d 	mcall	80007498 <main+0x74>
	return 0;
	
}
80007468:	d8 0a       	popm	pc,r12=0
8000746a:	00 00       	add	r0,r0
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	52 c8       	stdsp	sp[0xb0],r8
80007470:	80 00       	ld.sh	r0,r0[0x0]
80007472:	55 58       	stdsp	sp[0x154],r8
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	73 7c       	ld.w	r12,r9[0x5c]
80007478:	80 00       	ld.sh	r0,r0[0x0]
8000747a:	dd 20       	acall	0xd2
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	70 70       	ld.w	r0,r8[0x1c]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	53 5c       	stdsp	sp[0xd4],r12
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	52 28       	stdsp	sp[0x88],r8
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	20 3c       	sub	r12,3
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	2a 00       	sub	r0,-96
80007490:	80 00       	ld.sh	r0,r0[0x0]
80007492:	40 dc       	lddsp	r12,sp[0x34]
80007494:	80 00       	ld.sh	r0,r0[0x0]
80007496:	52 9c       	stdsp	sp[0xa4],r12
80007498:	80 00       	ld.sh	r0,r0[0x0]
8000749a:	6e 94       	ld.w	r4,r7[0x24]

8000749c <free>:
8000749c:	d4 01       	pushm	lr
8000749e:	e0 68 0a 40 	mov	r8,2624
800074a2:	18 9b       	mov	r11,r12
800074a4:	70 0c       	ld.w	r12,r8[0x0]
800074a6:	e0 a0 1e 61 	rcall	8000b168 <_free_r>
800074aa:	d8 02       	popm	pc

800074ac <malloc>:
800074ac:	d4 01       	pushm	lr
800074ae:	e0 68 0a 40 	mov	r8,2624
800074b2:	18 9b       	mov	r11,r12
800074b4:	70 0c       	ld.w	r12,r8[0x0]
800074b6:	c0 3c       	rcall	800074bc <_malloc_r>
800074b8:	d8 02       	popm	pc
800074ba:	d7 03       	nop

800074bc <_malloc_r>:
800074bc:	d4 31       	pushm	r0-r7,lr
800074be:	f6 c8 ff f5 	sub	r8,r11,-11
800074c2:	18 95       	mov	r5,r12
800074c4:	10 97       	mov	r7,r8
800074c6:	e0 17 ff f8 	andl	r7,0xfff8
800074ca:	59 68       	cp.w	r8,22
800074cc:	f9 b7 08 10 	movls	r7,16
800074d0:	16 37       	cp.w	r7,r11
800074d2:	5f 38       	srlo	r8
800074d4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800074d8:	c0 50       	breq	800074e2 <_malloc_r+0x26>
800074da:	30 c8       	mov	r8,12
800074dc:	99 38       	st.w	r12[0xc],r8
800074de:	e0 8f 01 fa 	bral	800078d2 <_malloc_r+0x416>
800074e2:	fe b0 f5 a3 	rcall	80006028 <__malloc_lock>
800074e6:	e0 47 01 f7 	cp.w	r7,503
800074ea:	e0 8b 00 1d 	brhi	80007524 <_malloc_r+0x68>
800074ee:	ee 03 16 03 	lsr	r3,r7,0x3
800074f2:	e0 68 05 40 	mov	r8,1344
800074f6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800074fa:	70 36       	ld.w	r6,r8[0xc]
800074fc:	10 36       	cp.w	r6,r8
800074fe:	c0 61       	brne	8000750a <_malloc_r+0x4e>
80007500:	ec c8 ff f8 	sub	r8,r6,-8
80007504:	70 36       	ld.w	r6,r8[0xc]
80007506:	10 36       	cp.w	r6,r8
80007508:	c0 c0       	breq	80007520 <_malloc_r+0x64>
8000750a:	6c 18       	ld.w	r8,r6[0x4]
8000750c:	e0 18 ff fc 	andl	r8,0xfffc
80007510:	6c 3a       	ld.w	r10,r6[0xc]
80007512:	ec 08 00 09 	add	r9,r6,r8
80007516:	0a 9c       	mov	r12,r5
80007518:	6c 28       	ld.w	r8,r6[0x8]
8000751a:	95 28       	st.w	r10[0x8],r8
8000751c:	91 3a       	st.w	r8[0xc],r10
8000751e:	c4 78       	rjmp	800075ac <_malloc_r+0xf0>
80007520:	2f e3       	sub	r3,-2
80007522:	c4 d8       	rjmp	800075bc <_malloc_r+0x100>
80007524:	ee 03 16 09 	lsr	r3,r7,0x9
80007528:	c0 41       	brne	80007530 <_malloc_r+0x74>
8000752a:	ee 03 16 03 	lsr	r3,r7,0x3
8000752e:	c2 68       	rjmp	8000757a <_malloc_r+0xbe>
80007530:	58 43       	cp.w	r3,4
80007532:	e0 8b 00 06 	brhi	8000753e <_malloc_r+0x82>
80007536:	ee 03 16 06 	lsr	r3,r7,0x6
8000753a:	2c 83       	sub	r3,-56
8000753c:	c1 f8       	rjmp	8000757a <_malloc_r+0xbe>
8000753e:	59 43       	cp.w	r3,20
80007540:	e0 8b 00 04 	brhi	80007548 <_malloc_r+0x8c>
80007544:	2a 53       	sub	r3,-91
80007546:	c1 a8       	rjmp	8000757a <_malloc_r+0xbe>
80007548:	e0 43 00 54 	cp.w	r3,84
8000754c:	e0 8b 00 06 	brhi	80007558 <_malloc_r+0x9c>
80007550:	ee 03 16 0c 	lsr	r3,r7,0xc
80007554:	29 23       	sub	r3,-110
80007556:	c1 28       	rjmp	8000757a <_malloc_r+0xbe>
80007558:	e0 43 01 54 	cp.w	r3,340
8000755c:	e0 8b 00 06 	brhi	80007568 <_malloc_r+0xac>
80007560:	ee 03 16 0f 	lsr	r3,r7,0xf
80007564:	28 93       	sub	r3,-119
80007566:	c0 a8       	rjmp	8000757a <_malloc_r+0xbe>
80007568:	e0 43 05 54 	cp.w	r3,1364
8000756c:	e0 88 00 04 	brls	80007574 <_malloc_r+0xb8>
80007570:	37 e3       	mov	r3,126
80007572:	c0 48       	rjmp	8000757a <_malloc_r+0xbe>
80007574:	ee 03 16 12 	lsr	r3,r7,0x12
80007578:	28 43       	sub	r3,-124
8000757a:	e0 6a 05 40 	mov	r10,1344
8000757e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007582:	74 36       	ld.w	r6,r10[0xc]
80007584:	c1 98       	rjmp	800075b6 <_malloc_r+0xfa>
80007586:	6c 19       	ld.w	r9,r6[0x4]
80007588:	e0 19 ff fc 	andl	r9,0xfffc
8000758c:	f2 07 01 0b 	sub	r11,r9,r7
80007590:	58 fb       	cp.w	r11,15
80007592:	e0 8a 00 04 	brle	8000759a <_malloc_r+0xde>
80007596:	20 13       	sub	r3,1
80007598:	c1 18       	rjmp	800075ba <_malloc_r+0xfe>
8000759a:	6c 38       	ld.w	r8,r6[0xc]
8000759c:	58 0b       	cp.w	r11,0
8000759e:	c0 b5       	brlt	800075b4 <_malloc_r+0xf8>
800075a0:	6c 2a       	ld.w	r10,r6[0x8]
800075a2:	ec 09 00 09 	add	r9,r6,r9
800075a6:	0a 9c       	mov	r12,r5
800075a8:	91 2a       	st.w	r8[0x8],r10
800075aa:	95 38       	st.w	r10[0xc],r8
800075ac:	72 18       	ld.w	r8,r9[0x4]
800075ae:	a1 a8       	sbr	r8,0x0
800075b0:	93 18       	st.w	r9[0x4],r8
800075b2:	cb c8       	rjmp	8000772a <_malloc_r+0x26e>
800075b4:	10 96       	mov	r6,r8
800075b6:	14 36       	cp.w	r6,r10
800075b8:	ce 71       	brne	80007586 <_malloc_r+0xca>
800075ba:	2f f3       	sub	r3,-1
800075bc:	e0 6a 05 40 	mov	r10,1344
800075c0:	f4 cc ff f8 	sub	r12,r10,-8
800075c4:	78 26       	ld.w	r6,r12[0x8]
800075c6:	18 36       	cp.w	r6,r12
800075c8:	c6 c0       	breq	800076a0 <_malloc_r+0x1e4>
800075ca:	6c 19       	ld.w	r9,r6[0x4]
800075cc:	e0 19 ff fc 	andl	r9,0xfffc
800075d0:	f2 07 01 08 	sub	r8,r9,r7
800075d4:	58 f8       	cp.w	r8,15
800075d6:	e0 89 00 8f 	brgt	800076f4 <_malloc_r+0x238>
800075da:	99 3c       	st.w	r12[0xc],r12
800075dc:	99 2c       	st.w	r12[0x8],r12
800075de:	58 08       	cp.w	r8,0
800075e0:	c0 55       	brlt	800075ea <_malloc_r+0x12e>
800075e2:	ec 09 00 09 	add	r9,r6,r9
800075e6:	0a 9c       	mov	r12,r5
800075e8:	ce 2b       	rjmp	800075ac <_malloc_r+0xf0>
800075ea:	e0 49 01 ff 	cp.w	r9,511
800075ee:	e0 8b 00 13 	brhi	80007614 <_malloc_r+0x158>
800075f2:	a3 99       	lsr	r9,0x3
800075f4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800075f8:	70 2b       	ld.w	r11,r8[0x8]
800075fa:	8d 38       	st.w	r6[0xc],r8
800075fc:	8d 2b       	st.w	r6[0x8],r11
800075fe:	97 36       	st.w	r11[0xc],r6
80007600:	91 26       	st.w	r8[0x8],r6
80007602:	a3 49       	asr	r9,0x2
80007604:	74 18       	ld.w	r8,r10[0x4]
80007606:	30 1b       	mov	r11,1
80007608:	f6 09 09 49 	lsl	r9,r11,r9
8000760c:	f1 e9 10 09 	or	r9,r8,r9
80007610:	95 19       	st.w	r10[0x4],r9
80007612:	c4 78       	rjmp	800076a0 <_malloc_r+0x1e4>
80007614:	f2 0a 16 09 	lsr	r10,r9,0x9
80007618:	58 4a       	cp.w	r10,4
8000761a:	e0 8b 00 07 	brhi	80007628 <_malloc_r+0x16c>
8000761e:	f2 0a 16 06 	lsr	r10,r9,0x6
80007622:	2c 8a       	sub	r10,-56
80007624:	c2 08       	rjmp	80007664 <_malloc_r+0x1a8>
80007626:	d7 03       	nop
80007628:	59 4a       	cp.w	r10,20
8000762a:	e0 8b 00 04 	brhi	80007632 <_malloc_r+0x176>
8000762e:	2a 5a       	sub	r10,-91
80007630:	c1 a8       	rjmp	80007664 <_malloc_r+0x1a8>
80007632:	e0 4a 00 54 	cp.w	r10,84
80007636:	e0 8b 00 06 	brhi	80007642 <_malloc_r+0x186>
8000763a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000763e:	29 2a       	sub	r10,-110
80007640:	c1 28       	rjmp	80007664 <_malloc_r+0x1a8>
80007642:	e0 4a 01 54 	cp.w	r10,340
80007646:	e0 8b 00 06 	brhi	80007652 <_malloc_r+0x196>
8000764a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000764e:	28 9a       	sub	r10,-119
80007650:	c0 a8       	rjmp	80007664 <_malloc_r+0x1a8>
80007652:	e0 4a 05 54 	cp.w	r10,1364
80007656:	e0 88 00 04 	brls	8000765e <_malloc_r+0x1a2>
8000765a:	37 ea       	mov	r10,126
8000765c:	c0 48       	rjmp	80007664 <_malloc_r+0x1a8>
8000765e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007662:	28 4a       	sub	r10,-124
80007664:	e0 6b 05 40 	mov	r11,1344
80007668:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000766c:	68 28       	ld.w	r8,r4[0x8]
8000766e:	08 38       	cp.w	r8,r4
80007670:	c0 e1       	brne	8000768c <_malloc_r+0x1d0>
80007672:	76 19       	ld.w	r9,r11[0x4]
80007674:	a3 4a       	asr	r10,0x2
80007676:	30 1e       	mov	lr,1
80007678:	fc 0a 09 4a 	lsl	r10,lr,r10
8000767c:	f3 ea 10 0a 	or	r10,r9,r10
80007680:	10 99       	mov	r9,r8
80007682:	97 1a       	st.w	r11[0x4],r10
80007684:	c0 a8       	rjmp	80007698 <_malloc_r+0x1dc>
80007686:	70 28       	ld.w	r8,r8[0x8]
80007688:	08 38       	cp.w	r8,r4
8000768a:	c0 60       	breq	80007696 <_malloc_r+0x1da>
8000768c:	70 1a       	ld.w	r10,r8[0x4]
8000768e:	e0 1a ff fc 	andl	r10,0xfffc
80007692:	14 39       	cp.w	r9,r10
80007694:	cf 93       	brcs	80007686 <_malloc_r+0x1ca>
80007696:	70 39       	ld.w	r9,r8[0xc]
80007698:	8d 39       	st.w	r6[0xc],r9
8000769a:	8d 28       	st.w	r6[0x8],r8
8000769c:	91 36       	st.w	r8[0xc],r6
8000769e:	93 26       	st.w	r9[0x8],r6
800076a0:	e6 08 14 02 	asr	r8,r3,0x2
800076a4:	30 1b       	mov	r11,1
800076a6:	e0 64 05 40 	mov	r4,1344
800076aa:	f6 08 09 4b 	lsl	r11,r11,r8
800076ae:	68 18       	ld.w	r8,r4[0x4]
800076b0:	10 3b       	cp.w	r11,r8
800076b2:	e0 8b 00 6b 	brhi	80007788 <_malloc_r+0x2cc>
800076b6:	f7 e8 00 09 	and	r9,r11,r8
800076ba:	c0 b1       	brne	800076d0 <_malloc_r+0x214>
800076bc:	e0 13 ff fc 	andl	r3,0xfffc
800076c0:	a1 7b       	lsl	r11,0x1
800076c2:	2f c3       	sub	r3,-4
800076c4:	c0 38       	rjmp	800076ca <_malloc_r+0x20e>
800076c6:	2f c3       	sub	r3,-4
800076c8:	a1 7b       	lsl	r11,0x1
800076ca:	f7 e8 00 09 	and	r9,r11,r8
800076ce:	cf c0       	breq	800076c6 <_malloc_r+0x20a>
800076d0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800076d4:	06 92       	mov	r2,r3
800076d6:	1c 91       	mov	r1,lr
800076d8:	62 36       	ld.w	r6,r1[0xc]
800076da:	c2 e8       	rjmp	80007736 <_malloc_r+0x27a>
800076dc:	6c 1a       	ld.w	r10,r6[0x4]
800076de:	e0 1a ff fc 	andl	r10,0xfffc
800076e2:	f4 07 01 08 	sub	r8,r10,r7
800076e6:	58 f8       	cp.w	r8,15
800076e8:	e0 8a 00 15 	brle	80007712 <_malloc_r+0x256>
800076ec:	6c 3a       	ld.w	r10,r6[0xc]
800076ee:	6c 29       	ld.w	r9,r6[0x8]
800076f0:	95 29       	st.w	r10[0x8],r9
800076f2:	93 3a       	st.w	r9[0xc],r10
800076f4:	0e 99       	mov	r9,r7
800076f6:	ec 07 00 07 	add	r7,r6,r7
800076fa:	a1 a9       	sbr	r9,0x0
800076fc:	99 37       	st.w	r12[0xc],r7
800076fe:	99 27       	st.w	r12[0x8],r7
80007700:	8d 19       	st.w	r6[0x4],r9
80007702:	ee 08 09 08 	st.w	r7[r8],r8
80007706:	8f 2c       	st.w	r7[0x8],r12
80007708:	8f 3c       	st.w	r7[0xc],r12
8000770a:	a1 a8       	sbr	r8,0x0
8000770c:	0a 9c       	mov	r12,r5
8000770e:	8f 18       	st.w	r7[0x4],r8
80007710:	c0 d8       	rjmp	8000772a <_malloc_r+0x26e>
80007712:	6c 39       	ld.w	r9,r6[0xc]
80007714:	58 08       	cp.w	r8,0
80007716:	c0 f5       	brlt	80007734 <_malloc_r+0x278>
80007718:	ec 0a 00 0a 	add	r10,r6,r10
8000771c:	74 18       	ld.w	r8,r10[0x4]
8000771e:	a1 a8       	sbr	r8,0x0
80007720:	0a 9c       	mov	r12,r5
80007722:	95 18       	st.w	r10[0x4],r8
80007724:	6c 28       	ld.w	r8,r6[0x8]
80007726:	93 28       	st.w	r9[0x8],r8
80007728:	91 39       	st.w	r8[0xc],r9
8000772a:	fe b0 f4 85 	rcall	80006034 <__malloc_unlock>
8000772e:	ec cc ff f8 	sub	r12,r6,-8
80007732:	d8 32       	popm	r0-r7,pc
80007734:	12 96       	mov	r6,r9
80007736:	02 36       	cp.w	r6,r1
80007738:	cd 21       	brne	800076dc <_malloc_r+0x220>
8000773a:	2f f2       	sub	r2,-1
8000773c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007740:	c0 30       	breq	80007746 <_malloc_r+0x28a>
80007742:	2f 81       	sub	r1,-8
80007744:	cc ab       	rjmp	800076d8 <_malloc_r+0x21c>
80007746:	1c 98       	mov	r8,lr
80007748:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000774c:	c0 81       	brne	8000775c <_malloc_r+0x2a0>
8000774e:	68 19       	ld.w	r9,r4[0x4]
80007750:	f6 08 11 ff 	rsub	r8,r11,-1
80007754:	f3 e8 00 08 	and	r8,r9,r8
80007758:	89 18       	st.w	r4[0x4],r8
8000775a:	c0 78       	rjmp	80007768 <_malloc_r+0x2ac>
8000775c:	f0 c9 00 08 	sub	r9,r8,8
80007760:	20 13       	sub	r3,1
80007762:	70 08       	ld.w	r8,r8[0x0]
80007764:	12 38       	cp.w	r8,r9
80007766:	cf 10       	breq	80007748 <_malloc_r+0x28c>
80007768:	a1 7b       	lsl	r11,0x1
8000776a:	68 18       	ld.w	r8,r4[0x4]
8000776c:	10 3b       	cp.w	r11,r8
8000776e:	e0 8b 00 0d 	brhi	80007788 <_malloc_r+0x2cc>
80007772:	58 0b       	cp.w	r11,0
80007774:	c0 a0       	breq	80007788 <_malloc_r+0x2cc>
80007776:	04 93       	mov	r3,r2
80007778:	c0 38       	rjmp	8000777e <_malloc_r+0x2c2>
8000777a:	2f c3       	sub	r3,-4
8000777c:	a1 7b       	lsl	r11,0x1
8000777e:	f7 e8 00 09 	and	r9,r11,r8
80007782:	ca 71       	brne	800076d0 <_malloc_r+0x214>
80007784:	cf bb       	rjmp	8000777a <_malloc_r+0x2be>
80007786:	d7 03       	nop
80007788:	68 23       	ld.w	r3,r4[0x8]
8000778a:	66 12       	ld.w	r2,r3[0x4]
8000778c:	e0 12 ff fc 	andl	r2,0xfffc
80007790:	0e 32       	cp.w	r2,r7
80007792:	5f 39       	srlo	r9
80007794:	e4 07 01 08 	sub	r8,r2,r7
80007798:	58 f8       	cp.w	r8,15
8000779a:	5f aa       	srle	r10
8000779c:	f5 e9 10 09 	or	r9,r10,r9
800077a0:	e0 80 00 9a 	breq	800078d4 <_malloc_r+0x418>
800077a4:	e0 68 0d 70 	mov	r8,3440
800077a8:	70 01       	ld.w	r1,r8[0x0]
800077aa:	e0 68 09 4c 	mov	r8,2380
800077ae:	2f 01       	sub	r1,-16
800077b0:	70 08       	ld.w	r8,r8[0x0]
800077b2:	0e 01       	add	r1,r7
800077b4:	5b f8       	cp.w	r8,-1
800077b6:	c0 40       	breq	800077be <_malloc_r+0x302>
800077b8:	28 11       	sub	r1,-127
800077ba:	e0 11 ff 80 	andl	r1,0xff80
800077be:	02 9b       	mov	r11,r1
800077c0:	0a 9c       	mov	r12,r5
800077c2:	e0 a0 02 a5 	rcall	80007d0c <_sbrk_r>
800077c6:	18 96       	mov	r6,r12
800077c8:	5b fc       	cp.w	r12,-1
800077ca:	c7 50       	breq	800078b4 <_malloc_r+0x3f8>
800077cc:	e6 02 00 08 	add	r8,r3,r2
800077d0:	10 3c       	cp.w	r12,r8
800077d2:	c0 32       	brcc	800077d8 <_malloc_r+0x31c>
800077d4:	08 33       	cp.w	r3,r4
800077d6:	c6 f1       	brne	800078b4 <_malloc_r+0x3f8>
800077d8:	e0 6a 0d 74 	mov	r10,3444
800077dc:	74 09       	ld.w	r9,r10[0x0]
800077de:	e2 09 00 09 	add	r9,r1,r9
800077e2:	95 09       	st.w	r10[0x0],r9
800077e4:	10 36       	cp.w	r6,r8
800077e6:	c0 a1       	brne	800077fa <_malloc_r+0x33e>
800077e8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800077ec:	c0 71       	brne	800077fa <_malloc_r+0x33e>
800077ee:	e2 02 00 02 	add	r2,r1,r2
800077f2:	68 28       	ld.w	r8,r4[0x8]
800077f4:	a1 a2       	sbr	r2,0x0
800077f6:	91 12       	st.w	r8[0x4],r2
800077f8:	c4 f8       	rjmp	80007896 <_malloc_r+0x3da>
800077fa:	e0 6a 09 4c 	mov	r10,2380
800077fe:	74 0b       	ld.w	r11,r10[0x0]
80007800:	5b fb       	cp.w	r11,-1
80007802:	c0 31       	brne	80007808 <_malloc_r+0x34c>
80007804:	95 06       	st.w	r10[0x0],r6
80007806:	c0 78       	rjmp	80007814 <_malloc_r+0x358>
80007808:	ec 09 00 09 	add	r9,r6,r9
8000780c:	e0 6a 0d 74 	mov	r10,3444
80007810:	10 19       	sub	r9,r8
80007812:	95 09       	st.w	r10[0x0],r9
80007814:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007818:	f0 09 11 08 	rsub	r9,r8,8
8000781c:	58 08       	cp.w	r8,0
8000781e:	f2 08 17 10 	movne	r8,r9
80007822:	ed d8 e1 06 	addne	r6,r6,r8
80007826:	28 08       	sub	r8,-128
80007828:	ec 01 00 01 	add	r1,r6,r1
8000782c:	0a 9c       	mov	r12,r5
8000782e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007832:	f0 01 01 01 	sub	r1,r8,r1
80007836:	02 9b       	mov	r11,r1
80007838:	e0 a0 02 6a 	rcall	80007d0c <_sbrk_r>
8000783c:	e0 68 0d 74 	mov	r8,3444
80007840:	5b fc       	cp.w	r12,-1
80007842:	ec 0c 17 00 	moveq	r12,r6
80007846:	f9 b1 00 00 	moveq	r1,0
8000784a:	70 09       	ld.w	r9,r8[0x0]
8000784c:	0c 1c       	sub	r12,r6
8000784e:	89 26       	st.w	r4[0x8],r6
80007850:	02 0c       	add	r12,r1
80007852:	12 01       	add	r1,r9
80007854:	a1 ac       	sbr	r12,0x0
80007856:	91 01       	st.w	r8[0x0],r1
80007858:	8d 1c       	st.w	r6[0x4],r12
8000785a:	08 33       	cp.w	r3,r4
8000785c:	c1 d0       	breq	80007896 <_malloc_r+0x3da>
8000785e:	58 f2       	cp.w	r2,15
80007860:	e0 8b 00 05 	brhi	8000786a <_malloc_r+0x3ae>
80007864:	30 18       	mov	r8,1
80007866:	8d 18       	st.w	r6[0x4],r8
80007868:	c2 68       	rjmp	800078b4 <_malloc_r+0x3f8>
8000786a:	30 59       	mov	r9,5
8000786c:	20 c2       	sub	r2,12
8000786e:	e0 12 ff f8 	andl	r2,0xfff8
80007872:	e6 02 00 08 	add	r8,r3,r2
80007876:	91 29       	st.w	r8[0x8],r9
80007878:	91 19       	st.w	r8[0x4],r9
8000787a:	66 18       	ld.w	r8,r3[0x4]
8000787c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007880:	e5 e8 10 08 	or	r8,r2,r8
80007884:	87 18       	st.w	r3[0x4],r8
80007886:	58 f2       	cp.w	r2,15
80007888:	e0 88 00 07 	brls	80007896 <_malloc_r+0x3da>
8000788c:	e6 cb ff f8 	sub	r11,r3,-8
80007890:	0a 9c       	mov	r12,r5
80007892:	e0 a0 1c 6b 	rcall	8000b168 <_free_r>
80007896:	e0 69 0d 6c 	mov	r9,3436
8000789a:	72 0a       	ld.w	r10,r9[0x0]
8000789c:	e0 68 0d 74 	mov	r8,3444
800078a0:	70 08       	ld.w	r8,r8[0x0]
800078a2:	14 38       	cp.w	r8,r10
800078a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800078a8:	e0 69 0d 68 	mov	r9,3432
800078ac:	72 0a       	ld.w	r10,r9[0x0]
800078ae:	14 38       	cp.w	r8,r10
800078b0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800078b4:	68 28       	ld.w	r8,r4[0x8]
800078b6:	70 18       	ld.w	r8,r8[0x4]
800078b8:	e0 18 ff fc 	andl	r8,0xfffc
800078bc:	0e 38       	cp.w	r8,r7
800078be:	5f 39       	srlo	r9
800078c0:	0e 18       	sub	r8,r7
800078c2:	58 f8       	cp.w	r8,15
800078c4:	5f aa       	srle	r10
800078c6:	f5 e9 10 09 	or	r9,r10,r9
800078ca:	c0 50       	breq	800078d4 <_malloc_r+0x418>
800078cc:	0a 9c       	mov	r12,r5
800078ce:	fe b0 f3 b3 	rcall	80006034 <__malloc_unlock>
800078d2:	d8 3a       	popm	r0-r7,pc,r12=0
800078d4:	68 26       	ld.w	r6,r4[0x8]
800078d6:	a1 a8       	sbr	r8,0x0
800078d8:	0e 99       	mov	r9,r7
800078da:	a1 a9       	sbr	r9,0x0
800078dc:	8d 19       	st.w	r6[0x4],r9
800078de:	ec 07 00 07 	add	r7,r6,r7
800078e2:	0a 9c       	mov	r12,r5
800078e4:	89 27       	st.w	r4[0x8],r7
800078e6:	8f 18       	st.w	r7[0x4],r8
800078e8:	fe b0 f3 a6 	rcall	80006034 <__malloc_unlock>
800078ec:	ec cc ff f8 	sub	r12,r6,-8
800078f0:	d8 32       	popm	r0-r7,pc
800078f2:	d7 03       	nop

800078f4 <memcpy>:
800078f4:	58 8a       	cp.w	r10,8
800078f6:	c2 f5       	brlt	80007954 <memcpy+0x60>
800078f8:	f9 eb 10 09 	or	r9,r12,r11
800078fc:	e2 19 00 03 	andl	r9,0x3,COH
80007900:	e0 81 00 97 	brne	80007a2e <memcpy+0x13a>
80007904:	e0 4a 00 20 	cp.w	r10,32
80007908:	c3 b4       	brge	8000797e <memcpy+0x8a>
8000790a:	f4 08 14 02 	asr	r8,r10,0x2
8000790e:	f0 09 11 08 	rsub	r9,r8,8
80007912:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007916:	76 69       	ld.w	r9,r11[0x18]
80007918:	99 69       	st.w	r12[0x18],r9
8000791a:	76 59       	ld.w	r9,r11[0x14]
8000791c:	99 59       	st.w	r12[0x14],r9
8000791e:	76 49       	ld.w	r9,r11[0x10]
80007920:	99 49       	st.w	r12[0x10],r9
80007922:	76 39       	ld.w	r9,r11[0xc]
80007924:	99 39       	st.w	r12[0xc],r9
80007926:	76 29       	ld.w	r9,r11[0x8]
80007928:	99 29       	st.w	r12[0x8],r9
8000792a:	76 19       	ld.w	r9,r11[0x4]
8000792c:	99 19       	st.w	r12[0x4],r9
8000792e:	76 09       	ld.w	r9,r11[0x0]
80007930:	99 09       	st.w	r12[0x0],r9
80007932:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007936:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000793a:	e0 1a 00 03 	andl	r10,0x3
8000793e:	f4 0a 11 04 	rsub	r10,r10,4
80007942:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007946:	17 a9       	ld.ub	r9,r11[0x2]
80007948:	b0 a9       	st.b	r8[0x2],r9
8000794a:	17 99       	ld.ub	r9,r11[0x1]
8000794c:	b0 99       	st.b	r8[0x1],r9
8000794e:	17 89       	ld.ub	r9,r11[0x0]
80007950:	b0 89       	st.b	r8[0x0],r9
80007952:	5e fc       	retal	r12
80007954:	f4 0a 11 09 	rsub	r10,r10,9
80007958:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000795c:	17 f9       	ld.ub	r9,r11[0x7]
8000795e:	b8 f9       	st.b	r12[0x7],r9
80007960:	17 e9       	ld.ub	r9,r11[0x6]
80007962:	b8 e9       	st.b	r12[0x6],r9
80007964:	17 d9       	ld.ub	r9,r11[0x5]
80007966:	b8 d9       	st.b	r12[0x5],r9
80007968:	17 c9       	ld.ub	r9,r11[0x4]
8000796a:	b8 c9       	st.b	r12[0x4],r9
8000796c:	17 b9       	ld.ub	r9,r11[0x3]
8000796e:	b8 b9       	st.b	r12[0x3],r9
80007970:	17 a9       	ld.ub	r9,r11[0x2]
80007972:	b8 a9       	st.b	r12[0x2],r9
80007974:	17 99       	ld.ub	r9,r11[0x1]
80007976:	b8 99       	st.b	r12[0x1],r9
80007978:	17 89       	ld.ub	r9,r11[0x0]
8000797a:	b8 89       	st.b	r12[0x0],r9
8000797c:	5e fc       	retal	r12
8000797e:	eb cd 40 c0 	pushm	r6-r7,lr
80007982:	18 99       	mov	r9,r12
80007984:	22 0a       	sub	r10,32
80007986:	b7 07       	ld.d	r6,r11++
80007988:	b3 26       	st.d	r9++,r6
8000798a:	b7 07       	ld.d	r6,r11++
8000798c:	b3 26       	st.d	r9++,r6
8000798e:	b7 07       	ld.d	r6,r11++
80007990:	b3 26       	st.d	r9++,r6
80007992:	b7 07       	ld.d	r6,r11++
80007994:	b3 26       	st.d	r9++,r6
80007996:	22 0a       	sub	r10,32
80007998:	cf 74       	brge	80007986 <memcpy+0x92>
8000799a:	2f 0a       	sub	r10,-16
8000799c:	c0 65       	brlt	800079a8 <memcpy+0xb4>
8000799e:	b7 07       	ld.d	r6,r11++
800079a0:	b3 26       	st.d	r9++,r6
800079a2:	b7 07       	ld.d	r6,r11++
800079a4:	b3 26       	st.d	r9++,r6
800079a6:	21 0a       	sub	r10,16
800079a8:	5c 3a       	neg	r10
800079aa:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800079ae:	d7 03       	nop
800079b0:	d7 03       	nop
800079b2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800079b6:	f3 66 00 0e 	st.b	r9[14],r6
800079ba:	f7 36 00 0d 	ld.ub	r6,r11[13]
800079be:	f3 66 00 0d 	st.b	r9[13],r6
800079c2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800079c6:	f3 66 00 0c 	st.b	r9[12],r6
800079ca:	f7 36 00 0b 	ld.ub	r6,r11[11]
800079ce:	f3 66 00 0b 	st.b	r9[11],r6
800079d2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800079d6:	f3 66 00 0a 	st.b	r9[10],r6
800079da:	f7 36 00 09 	ld.ub	r6,r11[9]
800079de:	f3 66 00 09 	st.b	r9[9],r6
800079e2:	f7 36 00 08 	ld.ub	r6,r11[8]
800079e6:	f3 66 00 08 	st.b	r9[8],r6
800079ea:	f7 36 00 07 	ld.ub	r6,r11[7]
800079ee:	f3 66 00 07 	st.b	r9[7],r6
800079f2:	f7 36 00 06 	ld.ub	r6,r11[6]
800079f6:	f3 66 00 06 	st.b	r9[6],r6
800079fa:	f7 36 00 05 	ld.ub	r6,r11[5]
800079fe:	f3 66 00 05 	st.b	r9[5],r6
80007a02:	f7 36 00 04 	ld.ub	r6,r11[4]
80007a06:	f3 66 00 04 	st.b	r9[4],r6
80007a0a:	f7 36 00 03 	ld.ub	r6,r11[3]
80007a0e:	f3 66 00 03 	st.b	r9[3],r6
80007a12:	f7 36 00 02 	ld.ub	r6,r11[2]
80007a16:	f3 66 00 02 	st.b	r9[2],r6
80007a1a:	f7 36 00 01 	ld.ub	r6,r11[1]
80007a1e:	f3 66 00 01 	st.b	r9[1],r6
80007a22:	f7 36 00 00 	ld.ub	r6,r11[0]
80007a26:	f3 66 00 00 	st.b	r9[0],r6
80007a2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a2e:	20 1a       	sub	r10,1
80007a30:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007a34:	f8 0a 0b 09 	st.b	r12[r10],r9
80007a38:	cf b1       	brne	80007a2e <memcpy+0x13a>
80007a3a:	5e fc       	retal	r12

80007a3c <memset>:
80007a3c:	18 98       	mov	r8,r12
80007a3e:	c0 38       	rjmp	80007a44 <memset+0x8>
80007a40:	10 cb       	st.b	r8++,r11
80007a42:	20 1a       	sub	r10,1
80007a44:	58 0a       	cp.w	r10,0
80007a46:	cf d1       	brne	80007a40 <memset+0x4>
80007a48:	5e fc       	retal	r12
80007a4a:	d7 03       	nop

80007a4c <_realloc_r>:
80007a4c:	d4 31       	pushm	r0-r7,lr
80007a4e:	20 1d       	sub	sp,4
80007a50:	16 94       	mov	r4,r11
80007a52:	18 92       	mov	r2,r12
80007a54:	14 9b       	mov	r11,r10
80007a56:	58 04       	cp.w	r4,0
80007a58:	c0 51       	brne	80007a62 <_realloc_r+0x16>
80007a5a:	fe b0 fd 31 	rcall	800074bc <_malloc_r>
80007a5e:	18 95       	mov	r5,r12
80007a60:	c5 39       	rjmp	80007d06 <_realloc_r+0x2ba>
80007a62:	50 0a       	stdsp	sp[0x0],r10
80007a64:	fe b0 f2 e2 	rcall	80006028 <__malloc_lock>
80007a68:	40 0b       	lddsp	r11,sp[0x0]
80007a6a:	f6 c8 ff f5 	sub	r8,r11,-11
80007a6e:	e8 c1 00 08 	sub	r1,r4,8
80007a72:	10 96       	mov	r6,r8
80007a74:	62 1c       	ld.w	r12,r1[0x4]
80007a76:	e0 16 ff f8 	andl	r6,0xfff8
80007a7a:	59 68       	cp.w	r8,22
80007a7c:	f9 b6 08 10 	movls	r6,16
80007a80:	16 36       	cp.w	r6,r11
80007a82:	5f 38       	srlo	r8
80007a84:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007a88:	c0 50       	breq	80007a92 <_realloc_r+0x46>
80007a8a:	30 c8       	mov	r8,12
80007a8c:	30 05       	mov	r5,0
80007a8e:	85 38       	st.w	r2[0xc],r8
80007a90:	c3 b9       	rjmp	80007d06 <_realloc_r+0x2ba>
80007a92:	18 90       	mov	r0,r12
80007a94:	e0 10 ff fc 	andl	r0,0xfffc
80007a98:	0c 30       	cp.w	r0,r6
80007a9a:	e0 84 01 0b 	brge	80007cb0 <_realloc_r+0x264>
80007a9e:	e0 68 05 40 	mov	r8,1344
80007aa2:	e2 00 00 09 	add	r9,r1,r0
80007aa6:	70 25       	ld.w	r5,r8[0x8]
80007aa8:	0a 39       	cp.w	r9,r5
80007aaa:	c0 90       	breq	80007abc <_realloc_r+0x70>
80007aac:	72 1a       	ld.w	r10,r9[0x4]
80007aae:	a1 ca       	cbr	r10,0x0
80007ab0:	f2 0a 00 0a 	add	r10,r9,r10
80007ab4:	74 1a       	ld.w	r10,r10[0x4]
80007ab6:	ed ba 00 00 	bld	r10,0x0
80007aba:	c2 20       	breq	80007afe <_realloc_r+0xb2>
80007abc:	72 1a       	ld.w	r10,r9[0x4]
80007abe:	e0 1a ff fc 	andl	r10,0xfffc
80007ac2:	f4 00 00 03 	add	r3,r10,r0
80007ac6:	0a 39       	cp.w	r9,r5
80007ac8:	c1 31       	brne	80007aee <_realloc_r+0xa2>
80007aca:	ec c7 ff f0 	sub	r7,r6,-16
80007ace:	0e 33       	cp.w	r3,r7
80007ad0:	c1 95       	brlt	80007b02 <_realloc_r+0xb6>
80007ad2:	e2 06 00 09 	add	r9,r1,r6
80007ad6:	0c 13       	sub	r3,r6
80007ad8:	a1 a3       	sbr	r3,0x0
80007ada:	93 13       	st.w	r9[0x4],r3
80007adc:	91 29       	st.w	r8[0x8],r9
80007ade:	04 9c       	mov	r12,r2
80007ae0:	62 18       	ld.w	r8,r1[0x4]
80007ae2:	08 95       	mov	r5,r4
80007ae4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ae8:	10 46       	or	r6,r8
80007aea:	83 16       	st.w	r1[0x4],r6
80007aec:	c0 b9       	rjmp	80007d02 <_realloc_r+0x2b6>
80007aee:	0c 33       	cp.w	r3,r6
80007af0:	c0 95       	brlt	80007b02 <_realloc_r+0xb6>
80007af2:	72 28       	ld.w	r8,r9[0x8]
80007af4:	02 97       	mov	r7,r1
80007af6:	72 39       	ld.w	r9,r9[0xc]
80007af8:	93 28       	st.w	r9[0x8],r8
80007afa:	91 39       	st.w	r8[0xc],r9
80007afc:	cd c8       	rjmp	80007cb4 <_realloc_r+0x268>
80007afe:	30 0a       	mov	r10,0
80007b00:	14 99       	mov	r9,r10
80007b02:	ed bc 00 00 	bld	r12,0x0
80007b06:	e0 80 00 95 	breq	80007c30 <_realloc_r+0x1e4>
80007b0a:	62 07       	ld.w	r7,r1[0x0]
80007b0c:	e2 07 01 07 	sub	r7,r1,r7
80007b10:	6e 1c       	ld.w	r12,r7[0x4]
80007b12:	e0 1c ff fc 	andl	r12,0xfffc
80007b16:	58 09       	cp.w	r9,0
80007b18:	c5 60       	breq	80007bc4 <_realloc_r+0x178>
80007b1a:	f8 00 00 03 	add	r3,r12,r0
80007b1e:	0a 39       	cp.w	r9,r5
80007b20:	c4 81       	brne	80007bb0 <_realloc_r+0x164>
80007b22:	14 03       	add	r3,r10
80007b24:	ec c9 ff f0 	sub	r9,r6,-16
80007b28:	12 33       	cp.w	r3,r9
80007b2a:	c4 d5       	brlt	80007bc4 <_realloc_r+0x178>
80007b2c:	6e 3a       	ld.w	r10,r7[0xc]
80007b2e:	6e 29       	ld.w	r9,r7[0x8]
80007b30:	95 29       	st.w	r10[0x8],r9
80007b32:	93 3a       	st.w	r9[0xc],r10
80007b34:	ee c5 ff f8 	sub	r5,r7,-8
80007b38:	e0 ca 00 04 	sub	r10,r0,4
80007b3c:	e0 4a 00 24 	cp.w	r10,36
80007b40:	e0 8b 00 25 	brhi	80007b8a <_realloc_r+0x13e>
80007b44:	0a 99       	mov	r9,r5
80007b46:	59 3a       	cp.w	r10,19
80007b48:	e0 88 00 1a 	brls	80007b7c <_realloc_r+0x130>
80007b4c:	09 09       	ld.w	r9,r4++
80007b4e:	8b 09       	st.w	r5[0x0],r9
80007b50:	09 09       	ld.w	r9,r4++
80007b52:	8f 39       	st.w	r7[0xc],r9
80007b54:	ee c9 ff f0 	sub	r9,r7,-16
80007b58:	59 ba       	cp.w	r10,27
80007b5a:	e0 88 00 11 	brls	80007b7c <_realloc_r+0x130>
80007b5e:	09 0b       	ld.w	r11,r4++
80007b60:	93 0b       	st.w	r9[0x0],r11
80007b62:	09 09       	ld.w	r9,r4++
80007b64:	8f 59       	st.w	r7[0x14],r9
80007b66:	ee c9 ff e8 	sub	r9,r7,-24
80007b6a:	e0 4a 00 24 	cp.w	r10,36
80007b6e:	c0 71       	brne	80007b7c <_realloc_r+0x130>
80007b70:	09 0a       	ld.w	r10,r4++
80007b72:	93 0a       	st.w	r9[0x0],r10
80007b74:	ee c9 ff e0 	sub	r9,r7,-32
80007b78:	09 0a       	ld.w	r10,r4++
80007b7a:	8f 7a       	st.w	r7[0x1c],r10
80007b7c:	09 0a       	ld.w	r10,r4++
80007b7e:	12 aa       	st.w	r9++,r10
80007b80:	68 0a       	ld.w	r10,r4[0x0]
80007b82:	93 0a       	st.w	r9[0x0],r10
80007b84:	68 1a       	ld.w	r10,r4[0x4]
80007b86:	93 1a       	st.w	r9[0x4],r10
80007b88:	c0 78       	rjmp	80007b96 <_realloc_r+0x14a>
80007b8a:	50 08       	stdsp	sp[0x0],r8
80007b8c:	08 9b       	mov	r11,r4
80007b8e:	0a 9c       	mov	r12,r5
80007b90:	e0 a0 1d 8f 	rcall	8000b6ae <memmove>
80007b94:	40 08       	lddsp	r8,sp[0x0]
80007b96:	ee 06 00 09 	add	r9,r7,r6
80007b9a:	0c 13       	sub	r3,r6
80007b9c:	a1 a3       	sbr	r3,0x0
80007b9e:	93 13       	st.w	r9[0x4],r3
80007ba0:	91 29       	st.w	r8[0x8],r9
80007ba2:	04 9c       	mov	r12,r2
80007ba4:	6e 18       	ld.w	r8,r7[0x4]
80007ba6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007baa:	10 46       	or	r6,r8
80007bac:	8f 16       	st.w	r7[0x4],r6
80007bae:	ca a8       	rjmp	80007d02 <_realloc_r+0x2b6>
80007bb0:	14 03       	add	r3,r10
80007bb2:	0c 33       	cp.w	r3,r6
80007bb4:	c0 85       	brlt	80007bc4 <_realloc_r+0x178>
80007bb6:	72 28       	ld.w	r8,r9[0x8]
80007bb8:	72 39       	ld.w	r9,r9[0xc]
80007bba:	93 28       	st.w	r9[0x8],r8
80007bbc:	91 39       	st.w	r8[0xc],r9
80007bbe:	6e 28       	ld.w	r8,r7[0x8]
80007bc0:	6e 39       	ld.w	r9,r7[0xc]
80007bc2:	c0 78       	rjmp	80007bd0 <_realloc_r+0x184>
80007bc4:	f8 00 00 03 	add	r3,r12,r0
80007bc8:	0c 33       	cp.w	r3,r6
80007bca:	c3 35       	brlt	80007c30 <_realloc_r+0x1e4>
80007bcc:	6e 39       	ld.w	r9,r7[0xc]
80007bce:	6e 28       	ld.w	r8,r7[0x8]
80007bd0:	93 28       	st.w	r9[0x8],r8
80007bd2:	91 39       	st.w	r8[0xc],r9
80007bd4:	e0 ca 00 04 	sub	r10,r0,4
80007bd8:	ee cc ff f8 	sub	r12,r7,-8
80007bdc:	e0 4a 00 24 	cp.w	r10,36
80007be0:	e0 8b 00 24 	brhi	80007c28 <_realloc_r+0x1dc>
80007be4:	59 3a       	cp.w	r10,19
80007be6:	e0 88 00 1a 	brls	80007c1a <_realloc_r+0x1ce>
80007bea:	09 08       	ld.w	r8,r4++
80007bec:	99 08       	st.w	r12[0x0],r8
80007bee:	09 08       	ld.w	r8,r4++
80007bf0:	8f 38       	st.w	r7[0xc],r8
80007bf2:	ee cc ff f0 	sub	r12,r7,-16
80007bf6:	59 ba       	cp.w	r10,27
80007bf8:	e0 88 00 11 	brls	80007c1a <_realloc_r+0x1ce>
80007bfc:	09 08       	ld.w	r8,r4++
80007bfe:	99 08       	st.w	r12[0x0],r8
80007c00:	09 08       	ld.w	r8,r4++
80007c02:	8f 58       	st.w	r7[0x14],r8
80007c04:	ee cc ff e8 	sub	r12,r7,-24
80007c08:	e0 4a 00 24 	cp.w	r10,36
80007c0c:	c0 71       	brne	80007c1a <_realloc_r+0x1ce>
80007c0e:	09 08       	ld.w	r8,r4++
80007c10:	99 08       	st.w	r12[0x0],r8
80007c12:	ee cc ff e0 	sub	r12,r7,-32
80007c16:	09 08       	ld.w	r8,r4++
80007c18:	8f 78       	st.w	r7[0x1c],r8
80007c1a:	09 08       	ld.w	r8,r4++
80007c1c:	18 a8       	st.w	r12++,r8
80007c1e:	68 08       	ld.w	r8,r4[0x0]
80007c20:	99 08       	st.w	r12[0x0],r8
80007c22:	68 18       	ld.w	r8,r4[0x4]
80007c24:	99 18       	st.w	r12[0x4],r8
80007c26:	c4 78       	rjmp	80007cb4 <_realloc_r+0x268>
80007c28:	08 9b       	mov	r11,r4
80007c2a:	e0 a0 1d 42 	rcall	8000b6ae <memmove>
80007c2e:	c4 38       	rjmp	80007cb4 <_realloc_r+0x268>
80007c30:	04 9c       	mov	r12,r2
80007c32:	fe b0 fc 45 	rcall	800074bc <_malloc_r>
80007c36:	18 95       	mov	r5,r12
80007c38:	c3 a0       	breq	80007cac <_realloc_r+0x260>
80007c3a:	62 18       	ld.w	r8,r1[0x4]
80007c3c:	f8 c9 00 08 	sub	r9,r12,8
80007c40:	a1 c8       	cbr	r8,0x0
80007c42:	e2 08 00 08 	add	r8,r1,r8
80007c46:	10 39       	cp.w	r9,r8
80007c48:	c0 71       	brne	80007c56 <_realloc_r+0x20a>
80007c4a:	72 13       	ld.w	r3,r9[0x4]
80007c4c:	02 97       	mov	r7,r1
80007c4e:	e0 13 ff fc 	andl	r3,0xfffc
80007c52:	00 03       	add	r3,r0
80007c54:	c3 08       	rjmp	80007cb4 <_realloc_r+0x268>
80007c56:	e0 ca 00 04 	sub	r10,r0,4
80007c5a:	e0 4a 00 24 	cp.w	r10,36
80007c5e:	e0 8b 00 20 	brhi	80007c9e <_realloc_r+0x252>
80007c62:	08 99       	mov	r9,r4
80007c64:	18 98       	mov	r8,r12
80007c66:	59 3a       	cp.w	r10,19
80007c68:	e0 88 00 14 	brls	80007c90 <_realloc_r+0x244>
80007c6c:	13 0b       	ld.w	r11,r9++
80007c6e:	10 ab       	st.w	r8++,r11
80007c70:	13 0b       	ld.w	r11,r9++
80007c72:	10 ab       	st.w	r8++,r11
80007c74:	59 ba       	cp.w	r10,27
80007c76:	e0 88 00 0d 	brls	80007c90 <_realloc_r+0x244>
80007c7a:	13 0b       	ld.w	r11,r9++
80007c7c:	10 ab       	st.w	r8++,r11
80007c7e:	13 0b       	ld.w	r11,r9++
80007c80:	10 ab       	st.w	r8++,r11
80007c82:	e0 4a 00 24 	cp.w	r10,36
80007c86:	c0 51       	brne	80007c90 <_realloc_r+0x244>
80007c88:	13 0a       	ld.w	r10,r9++
80007c8a:	10 aa       	st.w	r8++,r10
80007c8c:	13 0a       	ld.w	r10,r9++
80007c8e:	10 aa       	st.w	r8++,r10
80007c90:	13 0a       	ld.w	r10,r9++
80007c92:	10 aa       	st.w	r8++,r10
80007c94:	72 0a       	ld.w	r10,r9[0x0]
80007c96:	91 0a       	st.w	r8[0x0],r10
80007c98:	72 19       	ld.w	r9,r9[0x4]
80007c9a:	91 19       	st.w	r8[0x4],r9
80007c9c:	c0 48       	rjmp	80007ca4 <_realloc_r+0x258>
80007c9e:	08 9b       	mov	r11,r4
80007ca0:	e0 a0 1d 07 	rcall	8000b6ae <memmove>
80007ca4:	08 9b       	mov	r11,r4
80007ca6:	04 9c       	mov	r12,r2
80007ca8:	e0 a0 1a 60 	rcall	8000b168 <_free_r>
80007cac:	04 9c       	mov	r12,r2
80007cae:	c2 a8       	rjmp	80007d02 <_realloc_r+0x2b6>
80007cb0:	00 93       	mov	r3,r0
80007cb2:	02 97       	mov	r7,r1
80007cb4:	e6 06 01 09 	sub	r9,r3,r6
80007cb8:	6e 18       	ld.w	r8,r7[0x4]
80007cba:	58 f9       	cp.w	r9,15
80007cbc:	e0 88 00 16 	brls	80007ce8 <_realloc_r+0x29c>
80007cc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cc4:	ed e8 10 08 	or	r8,r6,r8
80007cc8:	8f 18       	st.w	r7[0x4],r8
80007cca:	12 98       	mov	r8,r9
80007ccc:	a1 a8       	sbr	r8,0x0
80007cce:	ee 06 00 0b 	add	r11,r7,r6
80007cd2:	f6 09 00 09 	add	r9,r11,r9
80007cd6:	97 18       	st.w	r11[0x4],r8
80007cd8:	72 18       	ld.w	r8,r9[0x4]
80007cda:	a1 a8       	sbr	r8,0x0
80007cdc:	2f 8b       	sub	r11,-8
80007cde:	93 18       	st.w	r9[0x4],r8
80007ce0:	04 9c       	mov	r12,r2
80007ce2:	e0 a0 1a 43 	rcall	8000b168 <_free_r>
80007ce6:	c0 b8       	rjmp	80007cfc <_realloc_r+0x2b0>
80007ce8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cec:	e7 e8 10 08 	or	r8,r3,r8
80007cf0:	8f 18       	st.w	r7[0x4],r8
80007cf2:	ee 03 00 03 	add	r3,r7,r3
80007cf6:	66 18       	ld.w	r8,r3[0x4]
80007cf8:	a1 a8       	sbr	r8,0x0
80007cfa:	87 18       	st.w	r3[0x4],r8
80007cfc:	04 9c       	mov	r12,r2
80007cfe:	ee c5 ff f8 	sub	r5,r7,-8
80007d02:	fe b0 f1 99 	rcall	80006034 <__malloc_unlock>
80007d06:	0a 9c       	mov	r12,r5
80007d08:	2f fd       	sub	sp,-4
80007d0a:	d8 32       	popm	r0-r7,pc

80007d0c <_sbrk_r>:
80007d0c:	d4 21       	pushm	r4-r7,lr
80007d0e:	30 08       	mov	r8,0
80007d10:	18 97       	mov	r7,r12
80007d12:	e0 66 53 d0 	mov	r6,21456
80007d16:	16 9c       	mov	r12,r11
80007d18:	8d 08       	st.w	r6[0x0],r8
80007d1a:	c8 5c       	rcall	80007e24 <_sbrk>
80007d1c:	5b fc       	cp.w	r12,-1
80007d1e:	c0 51       	brne	80007d28 <_sbrk_r+0x1c>
80007d20:	6c 08       	ld.w	r8,r6[0x0]
80007d22:	58 08       	cp.w	r8,0
80007d24:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007d28:	d8 22       	popm	r4-r7,pc
80007d2a:	d7 03       	nop

80007d2c <sprintf>:
80007d2c:	d4 01       	pushm	lr
80007d2e:	21 7d       	sub	sp,92
80007d30:	e0 68 ff ff 	mov	r8,65535
80007d34:	ea 18 7f ff 	orh	r8,0x7fff
80007d38:	50 58       	stdsp	sp[0x14],r8
80007d3a:	50 28       	stdsp	sp[0x8],r8
80007d3c:	e0 68 02 08 	mov	r8,520
80007d40:	ba 68       	st.h	sp[0xc],r8
80007d42:	3f f8       	mov	r8,-1
80007d44:	ba 78       	st.h	sp[0xe],r8
80007d46:	e0 68 0a 40 	mov	r8,2624
80007d4a:	50 4c       	stdsp	sp[0x10],r12
80007d4c:	16 9a       	mov	r10,r11
80007d4e:	50 0c       	stdsp	sp[0x0],r12
80007d50:	fa c9 ff a0 	sub	r9,sp,-96
80007d54:	70 0c       	ld.w	r12,r8[0x0]
80007d56:	1a 9b       	mov	r11,sp
80007d58:	e0 a0 02 1a 	rcall	8000818c <_vfprintf_r>
80007d5c:	30 09       	mov	r9,0
80007d5e:	40 08       	lddsp	r8,sp[0x0]
80007d60:	b0 89       	st.b	r8[0x0],r9
80007d62:	2e 9d       	sub	sp,-92
80007d64:	d8 02       	popm	pc
80007d66:	d7 03       	nop

80007d68 <strncpy>:
80007d68:	30 08       	mov	r8,0
80007d6a:	10 3a       	cp.w	r10,r8
80007d6c:	5e 0c       	reteq	r12
80007d6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007d72:	f8 08 0b 09 	st.b	r12[r8],r9
80007d76:	2f f8       	sub	r8,-1
80007d78:	58 09       	cp.w	r9,0
80007d7a:	cf 81       	brne	80007d6a <strncpy+0x2>
80007d7c:	10 3a       	cp.w	r10,r8
80007d7e:	5e 0c       	reteq	r12
80007d80:	f8 08 0b 09 	st.b	r12[r8],r9
80007d84:	2f f8       	sub	r8,-1
80007d86:	cf bb       	rjmp	80007d7c <strncpy+0x14>

80007d88 <_close>:
80007d88:	30 28       	mov	r8,2
80007d8a:	d6 73       	breakpoint
80007d8c:	3f fc       	mov	r12,-1
80007d8e:	35 8b       	mov	r11,88
80007d90:	58 0c       	cp.w	r12,0
80007d92:	5e 4c       	retge	r12
80007d94:	e0 6a 53 d0 	mov	r10,21456
80007d98:	95 0b       	st.w	r10[0x0],r11
80007d9a:	5e fc       	retal	r12

80007d9c <_lseek>:
80007d9c:	30 58       	mov	r8,5
80007d9e:	d6 73       	breakpoint
80007da0:	3f fc       	mov	r12,-1
80007da2:	35 8b       	mov	r11,88
80007da4:	58 0c       	cp.w	r12,0
80007da6:	5e 4c       	retge	r12
80007da8:	e0 6a 53 d0 	mov	r10,21456
80007dac:	95 0b       	st.w	r10[0x0],r11
80007dae:	5e fc       	retal	r12

80007db0 <isatty>:
80007db0:	30 b8       	mov	r8,11
80007db2:	d6 73       	breakpoint
80007db4:	3f fc       	mov	r12,-1
80007db6:	35 8b       	mov	r11,88
80007db8:	58 0c       	cp.w	r12,0
80007dba:	5e 4c       	retge	r12
80007dbc:	e0 6a 53 d0 	mov	r10,21456
80007dc0:	95 0b       	st.w	r10[0x0],r11
80007dc2:	5e fc       	retal	r12

80007dc4 <_fstat_host>:
80007dc4:	30 98       	mov	r8,9
80007dc6:	d6 73       	breakpoint
80007dc8:	3f fc       	mov	r12,-1
80007dca:	35 8b       	mov	r11,88
80007dcc:	58 0c       	cp.w	r12,0
80007dce:	5e 4c       	retge	r12
80007dd0:	e0 6a 53 d0 	mov	r10,21456
80007dd4:	95 0b       	st.w	r10[0x0],r11
80007dd6:	5e fc       	retal	r12

80007dd8 <_fstat>:
80007dd8:	d4 21       	pushm	r4-r7,lr
80007dda:	21 0d       	sub	sp,64
80007ddc:	16 97       	mov	r7,r11
80007dde:	1a 9b       	mov	r11,sp
80007de0:	cf 2f       	rcall	80007dc4 <_fstat_host>
80007de2:	c0 34       	brge	80007de8 <_fstat+0x10>
80007de4:	3f fc       	mov	r12,-1
80007de6:	c1 c8       	rjmp	80007e1e <_fstat+0x46>
80007de8:	40 08       	lddsp	r8,sp[0x0]
80007dea:	ae 08       	st.h	r7[0x0],r8
80007dec:	40 18       	lddsp	r8,sp[0x4]
80007dee:	ae 18       	st.h	r7[0x2],r8
80007df0:	40 28       	lddsp	r8,sp[0x8]
80007df2:	8f 18       	st.w	r7[0x4],r8
80007df4:	40 38       	lddsp	r8,sp[0xc]
80007df6:	ae 48       	st.h	r7[0x8],r8
80007df8:	40 48       	lddsp	r8,sp[0x10]
80007dfa:	ae 58       	st.h	r7[0xa],r8
80007dfc:	40 58       	lddsp	r8,sp[0x14]
80007dfe:	ae 68       	st.h	r7[0xc],r8
80007e00:	40 68       	lddsp	r8,sp[0x18]
80007e02:	ae 78       	st.h	r7[0xe],r8
80007e04:	40 88       	lddsp	r8,sp[0x20]
80007e06:	8f 48       	st.w	r7[0x10],r8
80007e08:	40 a8       	lddsp	r8,sp[0x28]
80007e0a:	8f b8       	st.w	r7[0x2c],r8
80007e0c:	40 c8       	lddsp	r8,sp[0x30]
80007e0e:	8f c8       	st.w	r7[0x30],r8
80007e10:	40 d8       	lddsp	r8,sp[0x34]
80007e12:	8f 58       	st.w	r7[0x14],r8
80007e14:	40 e8       	lddsp	r8,sp[0x38]
80007e16:	30 0c       	mov	r12,0
80007e18:	8f 78       	st.w	r7[0x1c],r8
80007e1a:	40 f8       	lddsp	r8,sp[0x3c]
80007e1c:	8f 98       	st.w	r7[0x24],r8
80007e1e:	2f 0d       	sub	sp,-64
80007e20:	d8 22       	popm	r4-r7,pc
80007e22:	d7 03       	nop

80007e24 <_sbrk>:
80007e24:	d4 01       	pushm	lr
80007e26:	e0 68 0d 9c 	mov	r8,3484
80007e2a:	70 09       	ld.w	r9,r8[0x0]
80007e2c:	58 09       	cp.w	r9,0
80007e2e:	c0 41       	brne	80007e36 <_sbrk+0x12>
80007e30:	e0 69 53 d8 	mov	r9,21464
80007e34:	91 09       	st.w	r8[0x0],r9
80007e36:	e0 69 0d 9c 	mov	r9,3484
80007e3a:	e0 7a 70 00 	mov	r10,94208
80007e3e:	72 08       	ld.w	r8,r9[0x0]
80007e40:	f0 0c 00 0c 	add	r12,r8,r12
80007e44:	14 3c       	cp.w	r12,r10
80007e46:	e0 8b 00 04 	brhi	80007e4e <_sbrk+0x2a>
80007e4a:	93 0c       	st.w	r9[0x0],r12
80007e4c:	c0 68       	rjmp	80007e58 <_sbrk+0x34>
80007e4e:	e0 a0 18 15 	rcall	8000ae78 <__errno>
80007e52:	30 c8       	mov	r8,12
80007e54:	99 08       	st.w	r12[0x0],r8
80007e56:	3f f8       	mov	r8,-1
80007e58:	10 9c       	mov	r12,r8
80007e5a:	d8 02       	popm	pc

80007e5c <get_arg>:
80007e5c:	d4 31       	pushm	r0-r7,lr
80007e5e:	20 8d       	sub	sp,32
80007e60:	fa c4 ff bc 	sub	r4,sp,-68
80007e64:	50 4b       	stdsp	sp[0x10],r11
80007e66:	68 2e       	ld.w	lr,r4[0x8]
80007e68:	50 58       	stdsp	sp[0x14],r8
80007e6a:	12 96       	mov	r6,r9
80007e6c:	7c 0b       	ld.w	r11,lr[0x0]
80007e6e:	70 05       	ld.w	r5,r8[0x0]
80007e70:	50 6e       	stdsp	sp[0x18],lr
80007e72:	58 0b       	cp.w	r11,0
80007e74:	f4 0b 17 00 	moveq	r11,r10
80007e78:	68 03       	ld.w	r3,r4[0x0]
80007e7a:	68 11       	ld.w	r1,r4[0x4]
80007e7c:	40 49       	lddsp	r9,sp[0x10]
80007e7e:	30 08       	mov	r8,0
80007e80:	c2 89       	rjmp	800080d0 <get_arg+0x274>
80007e82:	2f fb       	sub	r11,-1
80007e84:	32 5c       	mov	r12,37
80007e86:	17 8a       	ld.ub	r10,r11[0x0]
80007e88:	f8 0a 18 00 	cp.b	r10,r12
80007e8c:	5f 1e       	srne	lr
80007e8e:	f0 0a 18 00 	cp.b	r10,r8
80007e92:	5f 1c       	srne	r12
80007e94:	fd ec 00 0c 	and	r12,lr,r12
80007e98:	f0 0c 18 00 	cp.b	r12,r8
80007e9c:	cf 31       	brne	80007e82 <get_arg+0x26>
80007e9e:	58 0a       	cp.w	r10,0
80007ea0:	e0 80 01 25 	breq	800080ea <get_arg+0x28e>
80007ea4:	30 0c       	mov	r12,0
80007ea6:	3f fa       	mov	r10,-1
80007ea8:	18 90       	mov	r0,r12
80007eaa:	50 3a       	stdsp	sp[0xc],r10
80007eac:	18 94       	mov	r4,r12
80007eae:	18 92       	mov	r2,r12
80007eb0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007eb4:	16 97       	mov	r7,r11
80007eb6:	50 7c       	stdsp	sp[0x1c],r12
80007eb8:	fe cc 9e b0 	sub	r12,pc,-24912
80007ebc:	0f 3a       	ld.ub	r10,r7++
80007ebe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007ec2:	40 7c       	lddsp	r12,sp[0x1c]
80007ec4:	1c 0c       	add	r12,lr
80007ec6:	fe ce 9f 86 	sub	lr,pc,-24698
80007eca:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007ece:	20 1e       	sub	lr,1
80007ed0:	50 0e       	stdsp	sp[0x0],lr
80007ed2:	fe ce 9f fe 	sub	lr,pc,-24578
80007ed6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007eda:	50 7c       	stdsp	sp[0x1c],r12
80007edc:	40 0c       	lddsp	r12,sp[0x0]
80007ede:	58 7c       	cp.w	r12,7
80007ee0:	e0 8b 00 f1 	brhi	800080c2 <get_arg+0x266>
80007ee4:	fe ce a1 b0 	sub	lr,pc,-24144
80007ee8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007eec:	36 8b       	mov	r11,104
80007eee:	f6 0a 18 00 	cp.b	r10,r11
80007ef2:	e0 80 00 e8 	breq	800080c2 <get_arg+0x266>
80007ef6:	37 1b       	mov	r11,113
80007ef8:	f6 0a 18 00 	cp.b	r10,r11
80007efc:	c0 70       	breq	80007f0a <get_arg+0xae>
80007efe:	34 cb       	mov	r11,76
80007f00:	f6 0a 18 00 	cp.b	r10,r11
80007f04:	c0 51       	brne	80007f0e <get_arg+0xb2>
80007f06:	a3 b4       	sbr	r4,0x3
80007f08:	cd d8       	rjmp	800080c2 <get_arg+0x266>
80007f0a:	a5 b4       	sbr	r4,0x5
80007f0c:	cd b8       	rjmp	800080c2 <get_arg+0x266>
80007f0e:	08 9a       	mov	r10,r4
80007f10:	0e 9b       	mov	r11,r7
80007f12:	a5 aa       	sbr	r10,0x4
80007f14:	17 3c       	ld.ub	r12,r11++
80007f16:	a5 b4       	sbr	r4,0x5
80007f18:	36 ce       	mov	lr,108
80007f1a:	fc 0c 18 00 	cp.b	r12,lr
80007f1e:	e0 80 00 d3 	breq	800080c4 <get_arg+0x268>
80007f22:	14 94       	mov	r4,r10
80007f24:	cc f8       	rjmp	800080c2 <get_arg+0x266>
80007f26:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007f2a:	36 7c       	mov	r12,103
80007f2c:	f8 0a 18 00 	cp.b	r10,r12
80007f30:	e0 8b 00 27 	brhi	80007f7e <get_arg+0x122>
80007f34:	36 5b       	mov	r11,101
80007f36:	f6 0a 18 00 	cp.b	r10,r11
80007f3a:	c4 82       	brcc	80007fca <get_arg+0x16e>
80007f3c:	34 fb       	mov	r11,79
80007f3e:	f6 0a 18 00 	cp.b	r10,r11
80007f42:	c4 80       	breq	80007fd2 <get_arg+0x176>
80007f44:	e0 8b 00 0c 	brhi	80007f5c <get_arg+0x100>
80007f48:	34 5b       	mov	r11,69
80007f4a:	f6 0a 18 00 	cp.b	r10,r11
80007f4e:	c3 e0       	breq	80007fca <get_arg+0x16e>
80007f50:	34 7b       	mov	r11,71
80007f52:	f6 0a 18 00 	cp.b	r10,r11
80007f56:	c3 a0       	breq	80007fca <get_arg+0x16e>
80007f58:	34 4b       	mov	r11,68
80007f5a:	c0 88       	rjmp	80007f6a <get_arg+0x10e>
80007f5c:	35 8b       	mov	r11,88
80007f5e:	f6 0a 18 00 	cp.b	r10,r11
80007f62:	c2 c0       	breq	80007fba <get_arg+0x15e>
80007f64:	e0 8b 00 07 	brhi	80007f72 <get_arg+0x116>
80007f68:	35 5b       	mov	r11,85
80007f6a:	f6 0a 18 00 	cp.b	r10,r11
80007f6e:	c3 51       	brne	80007fd8 <get_arg+0x17c>
80007f70:	c3 18       	rjmp	80007fd2 <get_arg+0x176>
80007f72:	36 3b       	mov	r11,99
80007f74:	f6 0a 18 00 	cp.b	r10,r11
80007f78:	c2 f0       	breq	80007fd6 <get_arg+0x17a>
80007f7a:	36 4b       	mov	r11,100
80007f7c:	c0 e8       	rjmp	80007f98 <get_arg+0x13c>
80007f7e:	37 0b       	mov	r11,112
80007f80:	f6 0a 18 00 	cp.b	r10,r11
80007f84:	c2 50       	breq	80007fce <get_arg+0x172>
80007f86:	e0 8b 00 0d 	brhi	80007fa0 <get_arg+0x144>
80007f8a:	36 eb       	mov	r11,110
80007f8c:	f6 0a 18 00 	cp.b	r10,r11
80007f90:	c1 f0       	breq	80007fce <get_arg+0x172>
80007f92:	e0 8b 00 14 	brhi	80007fba <get_arg+0x15e>
80007f96:	36 9b       	mov	r11,105
80007f98:	f6 0a 18 00 	cp.b	r10,r11
80007f9c:	c1 e1       	brne	80007fd8 <get_arg+0x17c>
80007f9e:	c0 e8       	rjmp	80007fba <get_arg+0x15e>
80007fa0:	37 5b       	mov	r11,117
80007fa2:	f6 0a 18 00 	cp.b	r10,r11
80007fa6:	c0 a0       	breq	80007fba <get_arg+0x15e>
80007fa8:	37 8b       	mov	r11,120
80007faa:	f6 0a 18 00 	cp.b	r10,r11
80007fae:	c0 60       	breq	80007fba <get_arg+0x15e>
80007fb0:	37 3b       	mov	r11,115
80007fb2:	f6 0a 18 00 	cp.b	r10,r11
80007fb6:	c1 11       	brne	80007fd8 <get_arg+0x17c>
80007fb8:	c0 b8       	rjmp	80007fce <get_arg+0x172>
80007fba:	ed b4 00 04 	bld	r4,0x4
80007fbe:	c0 a0       	breq	80007fd2 <get_arg+0x176>
80007fc0:	ed b4 00 05 	bld	r4,0x5
80007fc4:	c0 91       	brne	80007fd6 <get_arg+0x17a>
80007fc6:	30 20       	mov	r0,2
80007fc8:	c0 88       	rjmp	80007fd8 <get_arg+0x17c>
80007fca:	30 40       	mov	r0,4
80007fcc:	c0 68       	rjmp	80007fd8 <get_arg+0x17c>
80007fce:	30 30       	mov	r0,3
80007fd0:	c0 48       	rjmp	80007fd8 <get_arg+0x17c>
80007fd2:	30 10       	mov	r0,1
80007fd4:	c0 28       	rjmp	80007fd8 <get_arg+0x17c>
80007fd6:	30 00       	mov	r0,0
80007fd8:	40 3b       	lddsp	r11,sp[0xc]
80007fda:	5b fb       	cp.w	r11,-1
80007fdc:	c0 40       	breq	80007fe4 <get_arg+0x188>
80007fde:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007fe2:	c7 08       	rjmp	800080c2 <get_arg+0x266>
80007fe4:	58 60       	cp.w	r0,6
80007fe6:	e0 8b 00 6e 	brhi	800080c2 <get_arg+0x266>
80007fea:	6c 0a       	ld.w	r10,r6[0x0]
80007fec:	ea cc ff ff 	sub	r12,r5,-1
80007ff0:	fe ce a2 9c 	sub	lr,pc,-23908
80007ff4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007ff8:	f4 cb ff f8 	sub	r11,r10,-8
80007ffc:	8d 0b       	st.w	r6[0x0],r11
80007ffe:	f4 ea 00 00 	ld.d	r10,r10[0]
80008002:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008006:	c0 f8       	rjmp	80008024 <get_arg+0x1c8>
80008008:	f4 cb ff fc 	sub	r11,r10,-4
8000800c:	8d 0b       	st.w	r6[0x0],r11
8000800e:	74 0a       	ld.w	r10,r10[0x0]
80008010:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008014:	c0 88       	rjmp	80008024 <get_arg+0x1c8>
80008016:	f4 cb ff f8 	sub	r11,r10,-8
8000801a:	8d 0b       	st.w	r6[0x0],r11
8000801c:	f4 ea 00 00 	ld.d	r10,r10[0]
80008020:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008024:	0e 9b       	mov	r11,r7
80008026:	18 95       	mov	r5,r12
80008028:	c4 e8       	rjmp	800080c4 <get_arg+0x268>
8000802a:	62 0a       	ld.w	r10,r1[0x0]
8000802c:	5b fa       	cp.w	r10,-1
8000802e:	c0 b1       	brne	80008044 <get_arg+0x1e8>
80008030:	50 19       	stdsp	sp[0x4],r9
80008032:	50 28       	stdsp	sp[0x8],r8
80008034:	e0 6a 00 80 	mov	r10,128
80008038:	30 0b       	mov	r11,0
8000803a:	02 9c       	mov	r12,r1
8000803c:	fe b0 fd 00 	rcall	80007a3c <memset>
80008040:	40 28       	lddsp	r8,sp[0x8]
80008042:	40 19       	lddsp	r9,sp[0x4]
80008044:	e4 cc 00 01 	sub	r12,r2,1
80008048:	0e 9b       	mov	r11,r7
8000804a:	50 3c       	stdsp	sp[0xc],r12
8000804c:	f2 0c 0c 49 	max	r9,r9,r12
80008050:	c3 a8       	rjmp	800080c4 <get_arg+0x268>
80008052:	62 0a       	ld.w	r10,r1[0x0]
80008054:	5b fa       	cp.w	r10,-1
80008056:	c0 b1       	brne	8000806c <get_arg+0x210>
80008058:	50 19       	stdsp	sp[0x4],r9
8000805a:	50 28       	stdsp	sp[0x8],r8
8000805c:	e0 6a 00 80 	mov	r10,128
80008060:	30 0b       	mov	r11,0
80008062:	02 9c       	mov	r12,r1
80008064:	fe b0 fc ec 	rcall	80007a3c <memset>
80008068:	40 28       	lddsp	r8,sp[0x8]
8000806a:	40 19       	lddsp	r9,sp[0x4]
8000806c:	20 12       	sub	r2,1
8000806e:	30 0a       	mov	r10,0
80008070:	0e 9b       	mov	r11,r7
80008072:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008076:	f2 02 0c 49 	max	r9,r9,r2
8000807a:	c2 58       	rjmp	800080c4 <get_arg+0x268>
8000807c:	16 97       	mov	r7,r11
8000807e:	6c 0a       	ld.w	r10,r6[0x0]
80008080:	f4 cb ff fc 	sub	r11,r10,-4
80008084:	8d 0b       	st.w	r6[0x0],r11
80008086:	74 0a       	ld.w	r10,r10[0x0]
80008088:	0e 9b       	mov	r11,r7
8000808a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000808e:	2f f5       	sub	r5,-1
80008090:	c1 a8       	rjmp	800080c4 <get_arg+0x268>
80008092:	f4 c2 00 30 	sub	r2,r10,48
80008096:	c0 68       	rjmp	800080a2 <get_arg+0x246>
80008098:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000809c:	2f f7       	sub	r7,-1
8000809e:	f4 02 00 12 	add	r2,r10,r2<<0x1
800080a2:	0f 8a       	ld.ub	r10,r7[0x0]
800080a4:	58 0a       	cp.w	r10,0
800080a6:	c0 e0       	breq	800080c2 <get_arg+0x266>
800080a8:	23 0a       	sub	r10,48
800080aa:	58 9a       	cp.w	r10,9
800080ac:	fe 98 ff f6 	brls	80008098 <get_arg+0x23c>
800080b0:	c0 98       	rjmp	800080c2 <get_arg+0x266>
800080b2:	2f f7       	sub	r7,-1
800080b4:	0f 8a       	ld.ub	r10,r7[0x0]
800080b6:	58 0a       	cp.w	r10,0
800080b8:	c0 50       	breq	800080c2 <get_arg+0x266>
800080ba:	23 0a       	sub	r10,48
800080bc:	58 9a       	cp.w	r10,9
800080be:	fe 98 ff fa 	brls	800080b2 <get_arg+0x256>
800080c2:	0e 9b       	mov	r11,r7
800080c4:	40 7c       	lddsp	r12,sp[0x1c]
800080c6:	30 ba       	mov	r10,11
800080c8:	f4 0c 18 00 	cp.b	r12,r10
800080cc:	fe 91 fe f2 	brne	80007eb0 <get_arg+0x54>
800080d0:	40 42       	lddsp	r2,sp[0x10]
800080d2:	17 8c       	ld.ub	r12,r11[0x0]
800080d4:	0a 32       	cp.w	r2,r5
800080d6:	5f 4a       	srge	r10
800080d8:	f0 0c 18 00 	cp.b	r12,r8
800080dc:	5f 1c       	srne	r12
800080de:	f9 ea 00 0a 	and	r10,r12,r10
800080e2:	f0 0a 18 00 	cp.b	r10,r8
800080e6:	fe 91 fe cf 	brne	80007e84 <get_arg+0x28>
800080ea:	30 08       	mov	r8,0
800080ec:	40 4e       	lddsp	lr,sp[0x10]
800080ee:	17 8a       	ld.ub	r10,r11[0x0]
800080f0:	e2 05 00 21 	add	r1,r1,r5<<0x2
800080f4:	f0 0a 18 00 	cp.b	r10,r8
800080f8:	fc 09 17 10 	movne	r9,lr
800080fc:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008100:	06 9e       	mov	lr,r3
80008102:	c2 a8       	rjmp	80008156 <get_arg+0x2fa>
80008104:	62 0a       	ld.w	r10,r1[0x0]
80008106:	58 3a       	cp.w	r10,3
80008108:	c1 e0       	breq	80008144 <get_arg+0x2e8>
8000810a:	e0 89 00 07 	brgt	80008118 <get_arg+0x2bc>
8000810e:	58 1a       	cp.w	r10,1
80008110:	c1 a0       	breq	80008144 <get_arg+0x2e8>
80008112:	58 2a       	cp.w	r10,2
80008114:	c1 81       	brne	80008144 <get_arg+0x2e8>
80008116:	c0 58       	rjmp	80008120 <get_arg+0x2c4>
80008118:	58 5a       	cp.w	r10,5
8000811a:	c0 c0       	breq	80008132 <get_arg+0x2d6>
8000811c:	c0 b5       	brlt	80008132 <get_arg+0x2d6>
8000811e:	c1 38       	rjmp	80008144 <get_arg+0x2e8>
80008120:	6c 0a       	ld.w	r10,r6[0x0]
80008122:	f4 cc ff f8 	sub	r12,r10,-8
80008126:	8d 0c       	st.w	r6[0x0],r12
80008128:	f4 e2 00 00 	ld.d	r2,r10[0]
8000812c:	f0 e3 00 00 	st.d	r8[0],r2
80008130:	c1 08       	rjmp	80008150 <get_arg+0x2f4>
80008132:	6c 0a       	ld.w	r10,r6[0x0]
80008134:	f4 cc ff f8 	sub	r12,r10,-8
80008138:	8d 0c       	st.w	r6[0x0],r12
8000813a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000813e:	f0 e3 00 00 	st.d	r8[0],r2
80008142:	c0 78       	rjmp	80008150 <get_arg+0x2f4>
80008144:	6c 0a       	ld.w	r10,r6[0x0]
80008146:	f4 cc ff fc 	sub	r12,r10,-4
8000814a:	8d 0c       	st.w	r6[0x0],r12
8000814c:	74 0a       	ld.w	r10,r10[0x0]
8000814e:	91 0a       	st.w	r8[0x0],r10
80008150:	2f f5       	sub	r5,-1
80008152:	2f 88       	sub	r8,-8
80008154:	2f c1       	sub	r1,-4
80008156:	12 35       	cp.w	r5,r9
80008158:	fe 9a ff d6 	brle	80008104 <get_arg+0x2a8>
8000815c:	1c 93       	mov	r3,lr
8000815e:	40 52       	lddsp	r2,sp[0x14]
80008160:	40 6e       	lddsp	lr,sp[0x18]
80008162:	85 05       	st.w	r2[0x0],r5
80008164:	9d 0b       	st.w	lr[0x0],r11
80008166:	40 4b       	lddsp	r11,sp[0x10]
80008168:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000816c:	2f 8d       	sub	sp,-32
8000816e:	d8 32       	popm	r0-r7,pc

80008170 <__sprint_r>:
80008170:	d4 21       	pushm	r4-r7,lr
80008172:	14 97       	mov	r7,r10
80008174:	74 28       	ld.w	r8,r10[0x8]
80008176:	58 08       	cp.w	r8,0
80008178:	c0 41       	brne	80008180 <__sprint_r+0x10>
8000817a:	95 18       	st.w	r10[0x4],r8
8000817c:	10 9c       	mov	r12,r8
8000817e:	d8 22       	popm	r4-r7,pc
80008180:	e0 a0 18 ba 	rcall	8000b2f4 <__sfvwrite_r>
80008184:	30 08       	mov	r8,0
80008186:	8f 18       	st.w	r7[0x4],r8
80008188:	8f 28       	st.w	r7[0x8],r8
8000818a:	d8 22       	popm	r4-r7,pc

8000818c <_vfprintf_r>:
8000818c:	d4 31       	pushm	r0-r7,lr
8000818e:	fa cd 06 bc 	sub	sp,sp,1724
80008192:	51 09       	stdsp	sp[0x40],r9
80008194:	16 91       	mov	r1,r11
80008196:	14 97       	mov	r7,r10
80008198:	18 95       	mov	r5,r12
8000819a:	e0 a0 1a 1d 	rcall	8000b5d4 <_localeconv_r>
8000819e:	78 0c       	ld.w	r12,r12[0x0]
800081a0:	50 cc       	stdsp	sp[0x30],r12
800081a2:	58 05       	cp.w	r5,0
800081a4:	c0 70       	breq	800081b2 <_vfprintf_r+0x26>
800081a6:	6a 68       	ld.w	r8,r5[0x18]
800081a8:	58 08       	cp.w	r8,0
800081aa:	c0 41       	brne	800081b2 <_vfprintf_r+0x26>
800081ac:	0a 9c       	mov	r12,r5
800081ae:	e0 a0 17 43 	rcall	8000b034 <__sinit>
800081b2:	fe c8 a0 9a 	sub	r8,pc,-24422
800081b6:	10 31       	cp.w	r1,r8
800081b8:	c0 31       	brne	800081be <_vfprintf_r+0x32>
800081ba:	6a 01       	ld.w	r1,r5[0x0]
800081bc:	c0 c8       	rjmp	800081d4 <_vfprintf_r+0x48>
800081be:	fe c8 a0 86 	sub	r8,pc,-24442
800081c2:	10 31       	cp.w	r1,r8
800081c4:	c0 31       	brne	800081ca <_vfprintf_r+0x3e>
800081c6:	6a 11       	ld.w	r1,r5[0x4]
800081c8:	c0 68       	rjmp	800081d4 <_vfprintf_r+0x48>
800081ca:	fe c8 a0 72 	sub	r8,pc,-24462
800081ce:	10 31       	cp.w	r1,r8
800081d0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800081d4:	82 68       	ld.sh	r8,r1[0xc]
800081d6:	ed b8 00 03 	bld	r8,0x3
800081da:	c0 41       	brne	800081e2 <_vfprintf_r+0x56>
800081dc:	62 48       	ld.w	r8,r1[0x10]
800081de:	58 08       	cp.w	r8,0
800081e0:	c0 71       	brne	800081ee <_vfprintf_r+0x62>
800081e2:	02 9b       	mov	r11,r1
800081e4:	0a 9c       	mov	r12,r5
800081e6:	e0 a0 0f 5d 	rcall	8000a0a0 <__swsetup_r>
800081ea:	e0 81 0f 54 	brne	8000a092 <_vfprintf_r+0x1f06>
800081ee:	82 68       	ld.sh	r8,r1[0xc]
800081f0:	10 99       	mov	r9,r8
800081f2:	e2 19 00 1a 	andl	r9,0x1a,COH
800081f6:	58 a9       	cp.w	r9,10
800081f8:	c3 c1       	brne	80008270 <_vfprintf_r+0xe4>
800081fa:	82 79       	ld.sh	r9,r1[0xe]
800081fc:	30 0a       	mov	r10,0
800081fe:	f4 09 19 00 	cp.h	r9,r10
80008202:	c3 75       	brlt	80008270 <_vfprintf_r+0xe4>
80008204:	a1 d8       	cbr	r8,0x1
80008206:	fb 58 05 d0 	st.h	sp[1488],r8
8000820a:	62 88       	ld.w	r8,r1[0x20]
8000820c:	fb 48 05 e4 	st.w	sp[1508],r8
80008210:	62 a8       	ld.w	r8,r1[0x28]
80008212:	fb 48 05 ec 	st.w	sp[1516],r8
80008216:	fa c8 ff bc 	sub	r8,sp,-68
8000821a:	fb 48 05 d4 	st.w	sp[1492],r8
8000821e:	fb 48 05 c4 	st.w	sp[1476],r8
80008222:	e0 68 04 00 	mov	r8,1024
80008226:	fb 48 05 d8 	st.w	sp[1496],r8
8000822a:	fb 48 05 cc 	st.w	sp[1484],r8
8000822e:	30 08       	mov	r8,0
80008230:	fb 59 05 d2 	st.h	sp[1490],r9
80008234:	0e 9a       	mov	r10,r7
80008236:	41 09       	lddsp	r9,sp[0x40]
80008238:	fa c7 fa 3c 	sub	r7,sp,-1476
8000823c:	fb 48 05 dc 	st.w	sp[1500],r8
80008240:	0a 9c       	mov	r12,r5
80008242:	0e 9b       	mov	r11,r7
80008244:	ca 4f       	rcall	8000818c <_vfprintf_r>
80008246:	50 bc       	stdsp	sp[0x2c],r12
80008248:	c0 95       	brlt	8000825a <_vfprintf_r+0xce>
8000824a:	0e 9b       	mov	r11,r7
8000824c:	0a 9c       	mov	r12,r5
8000824e:	e0 a0 16 1b 	rcall	8000ae84 <_fflush_r>
80008252:	40 be       	lddsp	lr,sp[0x2c]
80008254:	f9 be 01 ff 	movne	lr,-1
80008258:	50 be       	stdsp	sp[0x2c],lr
8000825a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000825e:	ed b8 00 06 	bld	r8,0x6
80008262:	e0 81 0f 1a 	brne	8000a096 <_vfprintf_r+0x1f0a>
80008266:	82 68       	ld.sh	r8,r1[0xc]
80008268:	a7 a8       	sbr	r8,0x6
8000826a:	a2 68       	st.h	r1[0xc],r8
8000826c:	e0 8f 0f 15 	bral	8000a096 <_vfprintf_r+0x1f0a>
80008270:	30 08       	mov	r8,0
80008272:	fb 48 06 b4 	st.w	sp[1716],r8
80008276:	fb 48 06 90 	st.w	sp[1680],r8
8000827a:	fb 48 06 8c 	st.w	sp[1676],r8
8000827e:	fb 48 06 b0 	st.w	sp[1712],r8
80008282:	30 08       	mov	r8,0
80008284:	30 09       	mov	r9,0
80008286:	50 a7       	stdsp	sp[0x28],r7
80008288:	50 78       	stdsp	sp[0x1c],r8
8000828a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000828e:	3f f8       	mov	r8,-1
80008290:	50 59       	stdsp	sp[0x14],r9
80008292:	fb 43 06 88 	st.w	sp[1672],r3
80008296:	fb 48 05 44 	st.w	sp[1348],r8
8000829a:	12 9c       	mov	r12,r9
8000829c:	50 69       	stdsp	sp[0x18],r9
8000829e:	50 d9       	stdsp	sp[0x34],r9
800082a0:	50 e9       	stdsp	sp[0x38],r9
800082a2:	50 b9       	stdsp	sp[0x2c],r9
800082a4:	12 97       	mov	r7,r9
800082a6:	0a 94       	mov	r4,r5
800082a8:	40 a2       	lddsp	r2,sp[0x28]
800082aa:	32 5a       	mov	r10,37
800082ac:	30 08       	mov	r8,0
800082ae:	c0 28       	rjmp	800082b2 <_vfprintf_r+0x126>
800082b0:	2f f2       	sub	r2,-1
800082b2:	05 89       	ld.ub	r9,r2[0x0]
800082b4:	f0 09 18 00 	cp.b	r9,r8
800082b8:	5f 1b       	srne	r11
800082ba:	f4 09 18 00 	cp.b	r9,r10
800082be:	5f 19       	srne	r9
800082c0:	f3 eb 00 0b 	and	r11,r9,r11
800082c4:	f0 0b 18 00 	cp.b	r11,r8
800082c8:	cf 41       	brne	800082b0 <_vfprintf_r+0x124>
800082ca:	40 ab       	lddsp	r11,sp[0x28]
800082cc:	e4 0b 01 06 	sub	r6,r2,r11
800082d0:	c1 e0       	breq	8000830c <_vfprintf_r+0x180>
800082d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800082d6:	0c 08       	add	r8,r6
800082d8:	87 0b       	st.w	r3[0x0],r11
800082da:	fb 48 06 90 	st.w	sp[1680],r8
800082de:	87 16       	st.w	r3[0x4],r6
800082e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800082e4:	2f f8       	sub	r8,-1
800082e6:	fb 48 06 8c 	st.w	sp[1676],r8
800082ea:	58 78       	cp.w	r8,7
800082ec:	e0 89 00 04 	brgt	800082f4 <_vfprintf_r+0x168>
800082f0:	2f 83       	sub	r3,-8
800082f2:	c0 a8       	rjmp	80008306 <_vfprintf_r+0x17a>
800082f4:	fa ca f9 78 	sub	r10,sp,-1672
800082f8:	02 9b       	mov	r11,r1
800082fa:	08 9c       	mov	r12,r4
800082fc:	c3 af       	rcall	80008170 <__sprint_r>
800082fe:	e0 81 0e c6 	brne	8000a08a <_vfprintf_r+0x1efe>
80008302:	fa c3 f9 e0 	sub	r3,sp,-1568
80008306:	40 ba       	lddsp	r10,sp[0x2c]
80008308:	0c 0a       	add	r10,r6
8000830a:	50 ba       	stdsp	sp[0x2c],r10
8000830c:	05 89       	ld.ub	r9,r2[0x0]
8000830e:	30 08       	mov	r8,0
80008310:	f0 09 18 00 	cp.b	r9,r8
80008314:	e0 80 0e aa 	breq	8000a068 <_vfprintf_r+0x1edc>
80008318:	30 09       	mov	r9,0
8000831a:	fb 68 06 bb 	st.b	sp[1723],r8
8000831e:	0e 96       	mov	r6,r7
80008320:	e4 c8 ff ff 	sub	r8,r2,-1
80008324:	3f fe       	mov	lr,-1
80008326:	50 93       	stdsp	sp[0x24],r3
80008328:	50 41       	stdsp	sp[0x10],r1
8000832a:	0e 93       	mov	r3,r7
8000832c:	04 91       	mov	r1,r2
8000832e:	50 89       	stdsp	sp[0x20],r9
80008330:	50 a8       	stdsp	sp[0x28],r8
80008332:	50 2e       	stdsp	sp[0x8],lr
80008334:	50 39       	stdsp	sp[0xc],r9
80008336:	12 95       	mov	r5,r9
80008338:	12 90       	mov	r0,r9
8000833a:	10 97       	mov	r7,r8
8000833c:	08 92       	mov	r2,r4
8000833e:	c0 78       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008340:	3f fc       	mov	r12,-1
80008342:	08 97       	mov	r7,r4
80008344:	50 2c       	stdsp	sp[0x8],r12
80008346:	c0 38       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008348:	30 0b       	mov	r11,0
8000834a:	50 3b       	stdsp	sp[0xc],r11
8000834c:	0f 38       	ld.ub	r8,r7++
8000834e:	c0 28       	rjmp	80008352 <_vfprintf_r+0x1c6>
80008350:	12 90       	mov	r0,r9
80008352:	f0 c9 00 20 	sub	r9,r8,32
80008356:	e0 49 00 58 	cp.w	r9,88
8000835a:	e0 8b 0a 30 	brhi	800097ba <_vfprintf_r+0x162e>
8000835e:	fe ca a5 ee 	sub	r10,pc,-23058
80008362:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008366:	50 a7       	stdsp	sp[0x28],r7
80008368:	50 80       	stdsp	sp[0x20],r0
8000836a:	0c 97       	mov	r7,r6
8000836c:	04 94       	mov	r4,r2
8000836e:	06 96       	mov	r6,r3
80008370:	02 92       	mov	r2,r1
80008372:	fe c9 a3 c6 	sub	r9,pc,-23610
80008376:	40 93       	lddsp	r3,sp[0x24]
80008378:	10 90       	mov	r0,r8
8000837a:	40 41       	lddsp	r1,sp[0x10]
8000837c:	50 d9       	stdsp	sp[0x34],r9
8000837e:	e0 8f 08 8e 	bral	8000949a <_vfprintf_r+0x130e>
80008382:	30 08       	mov	r8,0
80008384:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008388:	f0 09 18 00 	cp.b	r9,r8
8000838c:	ce 01       	brne	8000834c <_vfprintf_r+0x1c0>
8000838e:	32 08       	mov	r8,32
80008390:	c6 e8       	rjmp	8000846c <_vfprintf_r+0x2e0>
80008392:	a1 a5       	sbr	r5,0x0
80008394:	cd cb       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008396:	0f 89       	ld.ub	r9,r7[0x0]
80008398:	f2 c8 00 30 	sub	r8,r9,48
8000839c:	58 98       	cp.w	r8,9
8000839e:	e0 8b 00 1d 	brhi	800083d8 <_vfprintf_r+0x24c>
800083a2:	ee c8 ff ff 	sub	r8,r7,-1
800083a6:	30 0b       	mov	r11,0
800083a8:	23 09       	sub	r9,48
800083aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800083ae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800083b2:	11 39       	ld.ub	r9,r8++
800083b4:	f2 ca 00 30 	sub	r10,r9,48
800083b8:	58 9a       	cp.w	r10,9
800083ba:	fe 98 ff f7 	brls	800083a8 <_vfprintf_r+0x21c>
800083be:	e0 49 00 24 	cp.w	r9,36
800083c2:	cc 31       	brne	80008348 <_vfprintf_r+0x1bc>
800083c4:	e0 4b 00 20 	cp.w	r11,32
800083c8:	e0 89 0e 60 	brgt	8000a088 <_vfprintf_r+0x1efc>
800083cc:	20 1b       	sub	r11,1
800083ce:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083d2:	12 3b       	cp.w	r11,r9
800083d4:	c0 95       	brlt	800083e6 <_vfprintf_r+0x25a>
800083d6:	c1 08       	rjmp	800083f6 <_vfprintf_r+0x26a>
800083d8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083dc:	ec ca ff ff 	sub	r10,r6,-1
800083e0:	12 36       	cp.w	r6,r9
800083e2:	c1 f5       	brlt	80008420 <_vfprintf_r+0x294>
800083e4:	c2 68       	rjmp	80008430 <_vfprintf_r+0x2a4>
800083e6:	fa ce f9 44 	sub	lr,sp,-1724
800083ea:	10 97       	mov	r7,r8
800083ec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800083f0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800083f4:	c3 58       	rjmp	8000845e <_vfprintf_r+0x2d2>
800083f6:	10 97       	mov	r7,r8
800083f8:	fa c8 f9 50 	sub	r8,sp,-1712
800083fc:	1a d8       	st.w	--sp,r8
800083fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008402:	1a d8       	st.w	--sp,r8
80008404:	fa c8 fb b4 	sub	r8,sp,-1100
80008408:	02 9a       	mov	r10,r1
8000840a:	1a d8       	st.w	--sp,r8
8000840c:	04 9c       	mov	r12,r2
8000840e:	fa c8 f9 40 	sub	r8,sp,-1728
80008412:	fa c9 ff b4 	sub	r9,sp,-76
80008416:	fe b0 fd 23 	rcall	80007e5c <get_arg>
8000841a:	2f dd       	sub	sp,-12
8000841c:	78 00       	ld.w	r0,r12[0x0]
8000841e:	c2 08       	rjmp	8000845e <_vfprintf_r+0x2d2>
80008420:	fa cc f9 44 	sub	r12,sp,-1724
80008424:	14 96       	mov	r6,r10
80008426:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000842a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000842e:	c1 88       	rjmp	8000845e <_vfprintf_r+0x2d2>
80008430:	41 08       	lddsp	r8,sp[0x40]
80008432:	59 f9       	cp.w	r9,31
80008434:	e0 89 00 11 	brgt	80008456 <_vfprintf_r+0x2ca>
80008438:	f0 cb ff fc 	sub	r11,r8,-4
8000843c:	51 0b       	stdsp	sp[0x40],r11
8000843e:	70 00       	ld.w	r0,r8[0x0]
80008440:	fa cb f9 44 	sub	r11,sp,-1724
80008444:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008448:	f1 40 fd 88 	st.w	r8[-632],r0
8000844c:	2f f9       	sub	r9,-1
8000844e:	14 96       	mov	r6,r10
80008450:	fb 49 06 b4 	st.w	sp[1716],r9
80008454:	c0 58       	rjmp	8000845e <_vfprintf_r+0x2d2>
80008456:	70 00       	ld.w	r0,r8[0x0]
80008458:	14 96       	mov	r6,r10
8000845a:	2f c8       	sub	r8,-4
8000845c:	51 08       	stdsp	sp[0x40],r8
8000845e:	58 00       	cp.w	r0,0
80008460:	fe 94 ff 76 	brge	8000834c <_vfprintf_r+0x1c0>
80008464:	5c 30       	neg	r0
80008466:	a3 a5       	sbr	r5,0x2
80008468:	c7 2b       	rjmp	8000834c <_vfprintf_r+0x1c0>
8000846a:	32 b8       	mov	r8,43
8000846c:	fb 68 06 bb 	st.b	sp[1723],r8
80008470:	c6 eb       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008472:	0f 38       	ld.ub	r8,r7++
80008474:	e0 48 00 2a 	cp.w	r8,42
80008478:	c0 30       	breq	8000847e <_vfprintf_r+0x2f2>
8000847a:	30 09       	mov	r9,0
8000847c:	c7 98       	rjmp	8000856e <_vfprintf_r+0x3e2>
8000847e:	0f 88       	ld.ub	r8,r7[0x0]
80008480:	f0 c9 00 30 	sub	r9,r8,48
80008484:	58 99       	cp.w	r9,9
80008486:	e0 8b 00 1f 	brhi	800084c4 <_vfprintf_r+0x338>
8000848a:	ee c4 ff ff 	sub	r4,r7,-1
8000848e:	30 0b       	mov	r11,0
80008490:	23 08       	sub	r8,48
80008492:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008496:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000849a:	09 38       	ld.ub	r8,r4++
8000849c:	f0 c9 00 30 	sub	r9,r8,48
800084a0:	58 99       	cp.w	r9,9
800084a2:	fe 98 ff f7 	brls	80008490 <_vfprintf_r+0x304>
800084a6:	e0 48 00 24 	cp.w	r8,36
800084aa:	fe 91 ff 4f 	brne	80008348 <_vfprintf_r+0x1bc>
800084ae:	e0 4b 00 20 	cp.w	r11,32
800084b2:	e0 89 0d eb 	brgt	8000a088 <_vfprintf_r+0x1efc>
800084b6:	20 1b       	sub	r11,1
800084b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084bc:	10 3b       	cp.w	r11,r8
800084be:	c0 a5       	brlt	800084d2 <_vfprintf_r+0x346>
800084c0:	c1 18       	rjmp	800084e2 <_vfprintf_r+0x356>
800084c2:	d7 03       	nop
800084c4:	fa fa 06 b4 	ld.w	r10,sp[1716]
800084c8:	ec c9 ff ff 	sub	r9,r6,-1
800084cc:	14 36       	cp.w	r6,r10
800084ce:	c1 f5       	brlt	8000850c <_vfprintf_r+0x380>
800084d0:	c2 88       	rjmp	80008520 <_vfprintf_r+0x394>
800084d2:	fa ca f9 44 	sub	r10,sp,-1724
800084d6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800084da:	f6 fb fd 88 	ld.w	r11,r11[-632]
800084de:	50 2b       	stdsp	sp[0x8],r11
800084e0:	c3 c8       	rjmp	80008558 <_vfprintf_r+0x3cc>
800084e2:	fa c8 f9 50 	sub	r8,sp,-1712
800084e6:	1a d8       	st.w	--sp,r8
800084e8:	fa c8 fa b8 	sub	r8,sp,-1352
800084ec:	1a d8       	st.w	--sp,r8
800084ee:	fa c8 fb b4 	sub	r8,sp,-1100
800084f2:	02 9a       	mov	r10,r1
800084f4:	1a d8       	st.w	--sp,r8
800084f6:	04 9c       	mov	r12,r2
800084f8:	fa c8 f9 40 	sub	r8,sp,-1728
800084fc:	fa c9 ff b4 	sub	r9,sp,-76
80008500:	fe b0 fc ae 	rcall	80007e5c <get_arg>
80008504:	2f dd       	sub	sp,-12
80008506:	78 0c       	ld.w	r12,r12[0x0]
80008508:	50 2c       	stdsp	sp[0x8],r12
8000850a:	c2 78       	rjmp	80008558 <_vfprintf_r+0x3cc>
8000850c:	12 96       	mov	r6,r9
8000850e:	0e 94       	mov	r4,r7
80008510:	fa c9 f9 44 	sub	r9,sp,-1724
80008514:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008518:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000851c:	50 28       	stdsp	sp[0x8],r8
8000851e:	c1 d8       	rjmp	80008558 <_vfprintf_r+0x3cc>
80008520:	41 08       	lddsp	r8,sp[0x40]
80008522:	59 fa       	cp.w	r10,31
80008524:	e0 89 00 14 	brgt	8000854c <_vfprintf_r+0x3c0>
80008528:	f0 cb ff fc 	sub	r11,r8,-4
8000852c:	70 08       	ld.w	r8,r8[0x0]
8000852e:	51 0b       	stdsp	sp[0x40],r11
80008530:	50 28       	stdsp	sp[0x8],r8
80008532:	fa c6 f9 44 	sub	r6,sp,-1724
80008536:	40 2e       	lddsp	lr,sp[0x8]
80008538:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000853c:	f1 4e fd 88 	st.w	r8[-632],lr
80008540:	2f fa       	sub	r10,-1
80008542:	0e 94       	mov	r4,r7
80008544:	fb 4a 06 b4 	st.w	sp[1716],r10
80008548:	12 96       	mov	r6,r9
8000854a:	c0 78       	rjmp	80008558 <_vfprintf_r+0x3cc>
8000854c:	70 0c       	ld.w	r12,r8[0x0]
8000854e:	0e 94       	mov	r4,r7
80008550:	2f c8       	sub	r8,-4
80008552:	50 2c       	stdsp	sp[0x8],r12
80008554:	12 96       	mov	r6,r9
80008556:	51 08       	stdsp	sp[0x40],r8
80008558:	40 2b       	lddsp	r11,sp[0x8]
8000855a:	58 0b       	cp.w	r11,0
8000855c:	fe 95 fe f2 	brlt	80008340 <_vfprintf_r+0x1b4>
80008560:	08 97       	mov	r7,r4
80008562:	cf 5a       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008564:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008568:	0f 38       	ld.ub	r8,r7++
8000856a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000856e:	f0 ca 00 30 	sub	r10,r8,48
80008572:	58 9a       	cp.w	r10,9
80008574:	fe 98 ff f8 	brls	80008564 <_vfprintf_r+0x3d8>
80008578:	3f fa       	mov	r10,-1
8000857a:	f2 0a 0c 49 	max	r9,r9,r10
8000857e:	50 29       	stdsp	sp[0x8],r9
80008580:	ce 9a       	rjmp	80008352 <_vfprintf_r+0x1c6>
80008582:	a7 b5       	sbr	r5,0x7
80008584:	ce 4a       	rjmp	8000834c <_vfprintf_r+0x1c0>
80008586:	30 09       	mov	r9,0
80008588:	23 08       	sub	r8,48
8000858a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000858e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008592:	0f 38       	ld.ub	r8,r7++
80008594:	f0 ca 00 30 	sub	r10,r8,48
80008598:	58 9a       	cp.w	r10,9
8000859a:	fe 98 ff f7 	brls	80008588 <_vfprintf_r+0x3fc>
8000859e:	e0 48 00 24 	cp.w	r8,36
800085a2:	fe 91 fe d7 	brne	80008350 <_vfprintf_r+0x1c4>
800085a6:	e0 49 00 20 	cp.w	r9,32
800085aa:	e0 89 0d 6f 	brgt	8000a088 <_vfprintf_r+0x1efc>
800085ae:	f2 c3 00 01 	sub	r3,r9,1
800085b2:	30 19       	mov	r9,1
800085b4:	50 39       	stdsp	sp[0xc],r9
800085b6:	cc ba       	rjmp	8000834c <_vfprintf_r+0x1c0>
800085b8:	a3 b5       	sbr	r5,0x3
800085ba:	cc 9a       	rjmp	8000834c <_vfprintf_r+0x1c0>
800085bc:	a7 a5       	sbr	r5,0x6
800085be:	cc 7a       	rjmp	8000834c <_vfprintf_r+0x1c0>
800085c0:	0a 98       	mov	r8,r5
800085c2:	a5 b5       	sbr	r5,0x5
800085c4:	a5 a8       	sbr	r8,0x4
800085c6:	0f 89       	ld.ub	r9,r7[0x0]
800085c8:	36 ce       	mov	lr,108
800085ca:	fc 09 18 00 	cp.b	r9,lr
800085ce:	f7 b7 00 ff 	subeq	r7,-1
800085d2:	f0 05 17 10 	movne	r5,r8
800085d6:	cb ba       	rjmp	8000834c <_vfprintf_r+0x1c0>
800085d8:	a5 b5       	sbr	r5,0x5
800085da:	cb 9a       	rjmp	8000834c <_vfprintf_r+0x1c0>
800085dc:	50 a7       	stdsp	sp[0x28],r7
800085de:	50 80       	stdsp	sp[0x20],r0
800085e0:	0c 97       	mov	r7,r6
800085e2:	10 90       	mov	r0,r8
800085e4:	06 96       	mov	r6,r3
800085e6:	04 94       	mov	r4,r2
800085e8:	40 93       	lddsp	r3,sp[0x24]
800085ea:	02 92       	mov	r2,r1
800085ec:	0e 99       	mov	r9,r7
800085ee:	40 41       	lddsp	r1,sp[0x10]
800085f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085f4:	40 3c       	lddsp	r12,sp[0xc]
800085f6:	58 0c       	cp.w	r12,0
800085f8:	c1 d0       	breq	80008632 <_vfprintf_r+0x4a6>
800085fa:	10 36       	cp.w	r6,r8
800085fc:	c0 64       	brge	80008608 <_vfprintf_r+0x47c>
800085fe:	fa cb f9 44 	sub	r11,sp,-1724
80008602:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008606:	c1 d8       	rjmp	80008640 <_vfprintf_r+0x4b4>
80008608:	fa c8 f9 50 	sub	r8,sp,-1712
8000860c:	1a d8       	st.w	--sp,r8
8000860e:	fa c8 fa b8 	sub	r8,sp,-1352
80008612:	1a d8       	st.w	--sp,r8
80008614:	fa c8 fb b4 	sub	r8,sp,-1100
80008618:	1a d8       	st.w	--sp,r8
8000861a:	fa c8 f9 40 	sub	r8,sp,-1728
8000861e:	fa c9 ff b4 	sub	r9,sp,-76
80008622:	04 9a       	mov	r10,r2
80008624:	0c 9b       	mov	r11,r6
80008626:	08 9c       	mov	r12,r4
80008628:	fe b0 fc 1a 	rcall	80007e5c <get_arg>
8000862c:	2f dd       	sub	sp,-12
8000862e:	19 b8       	ld.ub	r8,r12[0x3]
80008630:	c2 28       	rjmp	80008674 <_vfprintf_r+0x4e8>
80008632:	2f f7       	sub	r7,-1
80008634:	10 39       	cp.w	r9,r8
80008636:	c0 84       	brge	80008646 <_vfprintf_r+0x4ba>
80008638:	fa ca f9 44 	sub	r10,sp,-1724
8000863c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008640:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008644:	c1 88       	rjmp	80008674 <_vfprintf_r+0x4e8>
80008646:	41 09       	lddsp	r9,sp[0x40]
80008648:	59 f8       	cp.w	r8,31
8000864a:	e0 89 00 12 	brgt	8000866e <_vfprintf_r+0x4e2>
8000864e:	f2 ca ff fc 	sub	r10,r9,-4
80008652:	51 0a       	stdsp	sp[0x40],r10
80008654:	72 09       	ld.w	r9,r9[0x0]
80008656:	fa c6 f9 44 	sub	r6,sp,-1724
8000865a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000865e:	2f f8       	sub	r8,-1
80008660:	f5 49 fd 88 	st.w	r10[-632],r9
80008664:	fb 48 06 b4 	st.w	sp[1716],r8
80008668:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000866c:	c0 48       	rjmp	80008674 <_vfprintf_r+0x4e8>
8000866e:	13 b8       	ld.ub	r8,r9[0x3]
80008670:	2f c9       	sub	r9,-4
80008672:	51 09       	stdsp	sp[0x40],r9
80008674:	fb 68 06 60 	st.b	sp[1632],r8
80008678:	30 0e       	mov	lr,0
8000867a:	30 08       	mov	r8,0
8000867c:	30 12       	mov	r2,1
8000867e:	fb 68 06 bb 	st.b	sp[1723],r8
80008682:	50 2e       	stdsp	sp[0x8],lr
80008684:	e0 8f 08 ad 	bral	800097de <_vfprintf_r+0x1652>
80008688:	50 a7       	stdsp	sp[0x28],r7
8000868a:	50 80       	stdsp	sp[0x20],r0
8000868c:	0c 97       	mov	r7,r6
8000868e:	04 94       	mov	r4,r2
80008690:	06 96       	mov	r6,r3
80008692:	02 92       	mov	r2,r1
80008694:	40 93       	lddsp	r3,sp[0x24]
80008696:	10 90       	mov	r0,r8
80008698:	40 41       	lddsp	r1,sp[0x10]
8000869a:	a5 a5       	sbr	r5,0x4
8000869c:	c0 a8       	rjmp	800086b0 <_vfprintf_r+0x524>
8000869e:	50 a7       	stdsp	sp[0x28],r7
800086a0:	50 80       	stdsp	sp[0x20],r0
800086a2:	0c 97       	mov	r7,r6
800086a4:	04 94       	mov	r4,r2
800086a6:	06 96       	mov	r6,r3
800086a8:	02 92       	mov	r2,r1
800086aa:	40 93       	lddsp	r3,sp[0x24]
800086ac:	10 90       	mov	r0,r8
800086ae:	40 41       	lddsp	r1,sp[0x10]
800086b0:	ed b5 00 05 	bld	r5,0x5
800086b4:	c5 11       	brne	80008756 <_vfprintf_r+0x5ca>
800086b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086ba:	40 3c       	lddsp	r12,sp[0xc]
800086bc:	58 0c       	cp.w	r12,0
800086be:	c1 e0       	breq	800086fa <_vfprintf_r+0x56e>
800086c0:	10 36       	cp.w	r6,r8
800086c2:	c0 64       	brge	800086ce <_vfprintf_r+0x542>
800086c4:	fa cb f9 44 	sub	r11,sp,-1724
800086c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086cc:	c2 08       	rjmp	8000870c <_vfprintf_r+0x580>
800086ce:	fa c8 f9 50 	sub	r8,sp,-1712
800086d2:	1a d8       	st.w	--sp,r8
800086d4:	fa c8 fa b8 	sub	r8,sp,-1352
800086d8:	0c 9b       	mov	r11,r6
800086da:	1a d8       	st.w	--sp,r8
800086dc:	fa c8 fb b4 	sub	r8,sp,-1100
800086e0:	1a d8       	st.w	--sp,r8
800086e2:	fa c9 ff b4 	sub	r9,sp,-76
800086e6:	fa c8 f9 40 	sub	r8,sp,-1728
800086ea:	04 9a       	mov	r10,r2
800086ec:	08 9c       	mov	r12,r4
800086ee:	fe b0 fb b7 	rcall	80007e5c <get_arg>
800086f2:	2f dd       	sub	sp,-12
800086f4:	78 1b       	ld.w	r11,r12[0x4]
800086f6:	78 09       	ld.w	r9,r12[0x0]
800086f8:	c2 b8       	rjmp	8000874e <_vfprintf_r+0x5c2>
800086fa:	ee ca ff ff 	sub	r10,r7,-1
800086fe:	10 37       	cp.w	r7,r8
80008700:	c0 b4       	brge	80008716 <_vfprintf_r+0x58a>
80008702:	fa c9 f9 44 	sub	r9,sp,-1724
80008706:	14 97       	mov	r7,r10
80008708:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000870c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008710:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008714:	c1 d8       	rjmp	8000874e <_vfprintf_r+0x5c2>
80008716:	41 09       	lddsp	r9,sp[0x40]
80008718:	59 f8       	cp.w	r8,31
8000871a:	e0 89 00 14 	brgt	80008742 <_vfprintf_r+0x5b6>
8000871e:	f2 cb ff f8 	sub	r11,r9,-8
80008722:	51 0b       	stdsp	sp[0x40],r11
80008724:	fa c6 f9 44 	sub	r6,sp,-1724
80008728:	72 1b       	ld.w	r11,r9[0x4]
8000872a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000872e:	72 09       	ld.w	r9,r9[0x0]
80008730:	f9 4b fd 8c 	st.w	r12[-628],r11
80008734:	f9 49 fd 88 	st.w	r12[-632],r9
80008738:	2f f8       	sub	r8,-1
8000873a:	14 97       	mov	r7,r10
8000873c:	fb 48 06 b4 	st.w	sp[1716],r8
80008740:	c0 78       	rjmp	8000874e <_vfprintf_r+0x5c2>
80008742:	f2 c8 ff f8 	sub	r8,r9,-8
80008746:	72 1b       	ld.w	r11,r9[0x4]
80008748:	14 97       	mov	r7,r10
8000874a:	51 08       	stdsp	sp[0x40],r8
8000874c:	72 09       	ld.w	r9,r9[0x0]
8000874e:	16 98       	mov	r8,r11
80008750:	fa e9 00 00 	st.d	sp[0],r8
80008754:	ca e8       	rjmp	800088b0 <_vfprintf_r+0x724>
80008756:	ed b5 00 04 	bld	r5,0x4
8000875a:	c1 71       	brne	80008788 <_vfprintf_r+0x5fc>
8000875c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008760:	40 3e       	lddsp	lr,sp[0xc]
80008762:	58 0e       	cp.w	lr,0
80008764:	c0 80       	breq	80008774 <_vfprintf_r+0x5e8>
80008766:	10 36       	cp.w	r6,r8
80008768:	c6 94       	brge	8000883a <_vfprintf_r+0x6ae>
8000876a:	fa cc f9 44 	sub	r12,sp,-1724
8000876e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008772:	c8 28       	rjmp	80008876 <_vfprintf_r+0x6ea>
80008774:	ee ca ff ff 	sub	r10,r7,-1
80008778:	10 37       	cp.w	r7,r8
8000877a:	e0 84 00 81 	brge	8000887c <_vfprintf_r+0x6f0>
8000877e:	fa cb f9 44 	sub	r11,sp,-1724
80008782:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008786:	c7 78       	rjmp	80008874 <_vfprintf_r+0x6e8>
80008788:	ed b5 00 06 	bld	r5,0x6
8000878c:	c4 b1       	brne	80008822 <_vfprintf_r+0x696>
8000878e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008792:	40 3c       	lddsp	r12,sp[0xc]
80008794:	58 0c       	cp.w	r12,0
80008796:	c1 d0       	breq	800087d0 <_vfprintf_r+0x644>
80008798:	10 36       	cp.w	r6,r8
8000879a:	c0 64       	brge	800087a6 <_vfprintf_r+0x61a>
8000879c:	fa cb f9 44 	sub	r11,sp,-1724
800087a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087a4:	c1 f8       	rjmp	800087e2 <_vfprintf_r+0x656>
800087a6:	fa c8 f9 50 	sub	r8,sp,-1712
800087aa:	1a d8       	st.w	--sp,r8
800087ac:	fa c8 fa b8 	sub	r8,sp,-1352
800087b0:	1a d8       	st.w	--sp,r8
800087b2:	fa c8 fb b4 	sub	r8,sp,-1100
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 f9 40 	sub	r8,sp,-1728
800087bc:	fa c9 ff b4 	sub	r9,sp,-76
800087c0:	04 9a       	mov	r10,r2
800087c2:	0c 9b       	mov	r11,r6
800087c4:	08 9c       	mov	r12,r4
800087c6:	fe b0 fb 4b 	rcall	80007e5c <get_arg>
800087ca:	2f dd       	sub	sp,-12
800087cc:	98 18       	ld.sh	r8,r12[0x2]
800087ce:	c2 68       	rjmp	8000881a <_vfprintf_r+0x68e>
800087d0:	ee ca ff ff 	sub	r10,r7,-1
800087d4:	10 37       	cp.w	r7,r8
800087d6:	c0 94       	brge	800087e8 <_vfprintf_r+0x65c>
800087d8:	fa c9 f9 44 	sub	r9,sp,-1724
800087dc:	14 97       	mov	r7,r10
800087de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087e2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800087e6:	c1 a8       	rjmp	8000881a <_vfprintf_r+0x68e>
800087e8:	41 09       	lddsp	r9,sp[0x40]
800087ea:	59 f8       	cp.w	r8,31
800087ec:	e0 89 00 13 	brgt	80008812 <_vfprintf_r+0x686>
800087f0:	f2 cb ff fc 	sub	r11,r9,-4
800087f4:	51 0b       	stdsp	sp[0x40],r11
800087f6:	72 09       	ld.w	r9,r9[0x0]
800087f8:	fa c6 f9 44 	sub	r6,sp,-1724
800087fc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008800:	2f f8       	sub	r8,-1
80008802:	f7 49 fd 88 	st.w	r11[-632],r9
80008806:	fb 48 06 b4 	st.w	sp[1716],r8
8000880a:	14 97       	mov	r7,r10
8000880c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008810:	c0 58       	rjmp	8000881a <_vfprintf_r+0x68e>
80008812:	92 18       	ld.sh	r8,r9[0x2]
80008814:	14 97       	mov	r7,r10
80008816:	2f c9       	sub	r9,-4
80008818:	51 09       	stdsp	sp[0x40],r9
8000881a:	50 18       	stdsp	sp[0x4],r8
8000881c:	bf 58       	asr	r8,0x1f
8000881e:	50 08       	stdsp	sp[0x0],r8
80008820:	c4 88       	rjmp	800088b0 <_vfprintf_r+0x724>
80008822:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008826:	40 3c       	lddsp	r12,sp[0xc]
80008828:	58 0c       	cp.w	r12,0
8000882a:	c1 d0       	breq	80008864 <_vfprintf_r+0x6d8>
8000882c:	10 36       	cp.w	r6,r8
8000882e:	c0 64       	brge	8000883a <_vfprintf_r+0x6ae>
80008830:	fa cb f9 44 	sub	r11,sp,-1724
80008834:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008838:	c1 f8       	rjmp	80008876 <_vfprintf_r+0x6ea>
8000883a:	fa c8 f9 50 	sub	r8,sp,-1712
8000883e:	1a d8       	st.w	--sp,r8
80008840:	fa c8 fa b8 	sub	r8,sp,-1352
80008844:	0c 9b       	mov	r11,r6
80008846:	1a d8       	st.w	--sp,r8
80008848:	fa c8 fb b4 	sub	r8,sp,-1100
8000884c:	04 9a       	mov	r10,r2
8000884e:	1a d8       	st.w	--sp,r8
80008850:	08 9c       	mov	r12,r4
80008852:	fa c8 f9 40 	sub	r8,sp,-1728
80008856:	fa c9 ff b4 	sub	r9,sp,-76
8000885a:	fe b0 fb 01 	rcall	80007e5c <get_arg>
8000885e:	2f dd       	sub	sp,-12
80008860:	78 0b       	ld.w	r11,r12[0x0]
80008862:	c2 48       	rjmp	800088aa <_vfprintf_r+0x71e>
80008864:	ee ca ff ff 	sub	r10,r7,-1
80008868:	10 37       	cp.w	r7,r8
8000886a:	c0 94       	brge	8000887c <_vfprintf_r+0x6f0>
8000886c:	fa c9 f9 44 	sub	r9,sp,-1724
80008870:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008874:	14 97       	mov	r7,r10
80008876:	ec fb fd 88 	ld.w	r11,r6[-632]
8000887a:	c1 88       	rjmp	800088aa <_vfprintf_r+0x71e>
8000887c:	41 09       	lddsp	r9,sp[0x40]
8000887e:	59 f8       	cp.w	r8,31
80008880:	e0 89 00 11 	brgt	800088a2 <_vfprintf_r+0x716>
80008884:	f2 cb ff fc 	sub	r11,r9,-4
80008888:	51 0b       	stdsp	sp[0x40],r11
8000888a:	fa c6 f9 44 	sub	r6,sp,-1724
8000888e:	72 0b       	ld.w	r11,r9[0x0]
80008890:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008894:	f3 4b fd 88 	st.w	r9[-632],r11
80008898:	2f f8       	sub	r8,-1
8000889a:	14 97       	mov	r7,r10
8000889c:	fb 48 06 b4 	st.w	sp[1716],r8
800088a0:	c0 58       	rjmp	800088aa <_vfprintf_r+0x71e>
800088a2:	72 0b       	ld.w	r11,r9[0x0]
800088a4:	14 97       	mov	r7,r10
800088a6:	2f c9       	sub	r9,-4
800088a8:	51 09       	stdsp	sp[0x40],r9
800088aa:	50 1b       	stdsp	sp[0x4],r11
800088ac:	bf 5b       	asr	r11,0x1f
800088ae:	50 0b       	stdsp	sp[0x0],r11
800088b0:	fa ea 00 00 	ld.d	r10,sp[0]
800088b4:	58 0a       	cp.w	r10,0
800088b6:	5c 2b       	cpc	r11
800088b8:	c0 e4       	brge	800088d4 <_vfprintf_r+0x748>
800088ba:	30 08       	mov	r8,0
800088bc:	fa ea 00 00 	ld.d	r10,sp[0]
800088c0:	30 09       	mov	r9,0
800088c2:	f0 0a 01 0a 	sub	r10,r8,r10
800088c6:	f2 0b 01 4b 	sbc	r11,r9,r11
800088ca:	32 d8       	mov	r8,45
800088cc:	fa eb 00 00 	st.d	sp[0],r10
800088d0:	fb 68 06 bb 	st.b	sp[1723],r8
800088d4:	30 18       	mov	r8,1
800088d6:	e0 8f 06 fa 	bral	800096ca <_vfprintf_r+0x153e>
800088da:	50 a7       	stdsp	sp[0x28],r7
800088dc:	50 80       	stdsp	sp[0x20],r0
800088de:	0c 97       	mov	r7,r6
800088e0:	04 94       	mov	r4,r2
800088e2:	06 96       	mov	r6,r3
800088e4:	02 92       	mov	r2,r1
800088e6:	40 93       	lddsp	r3,sp[0x24]
800088e8:	10 90       	mov	r0,r8
800088ea:	40 41       	lddsp	r1,sp[0x10]
800088ec:	0e 99       	mov	r9,r7
800088ee:	ed b5 00 03 	bld	r5,0x3
800088f2:	c4 11       	brne	80008974 <_vfprintf_r+0x7e8>
800088f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088f8:	40 3a       	lddsp	r10,sp[0xc]
800088fa:	58 0a       	cp.w	r10,0
800088fc:	c1 90       	breq	8000892e <_vfprintf_r+0x7a2>
800088fe:	10 36       	cp.w	r6,r8
80008900:	c6 45       	brlt	800089c8 <_vfprintf_r+0x83c>
80008902:	fa c8 f9 50 	sub	r8,sp,-1712
80008906:	1a d8       	st.w	--sp,r8
80008908:	fa c8 fa b8 	sub	r8,sp,-1352
8000890c:	1a d8       	st.w	--sp,r8
8000890e:	fa c8 fb b4 	sub	r8,sp,-1100
80008912:	0c 9b       	mov	r11,r6
80008914:	1a d8       	st.w	--sp,r8
80008916:	04 9a       	mov	r10,r2
80008918:	fa c8 f9 40 	sub	r8,sp,-1728
8000891c:	fa c9 ff b4 	sub	r9,sp,-76
80008920:	08 9c       	mov	r12,r4
80008922:	fe b0 fa 9d 	rcall	80007e5c <get_arg>
80008926:	2f dd       	sub	sp,-12
80008928:	78 16       	ld.w	r6,r12[0x4]
8000892a:	50 76       	stdsp	sp[0x1c],r6
8000892c:	c4 88       	rjmp	800089bc <_vfprintf_r+0x830>
8000892e:	2f f7       	sub	r7,-1
80008930:	10 39       	cp.w	r9,r8
80008932:	c0 c4       	brge	8000894a <_vfprintf_r+0x7be>
80008934:	fa ce f9 44 	sub	lr,sp,-1724
80008938:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000893c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008940:	50 7c       	stdsp	sp[0x1c],r12
80008942:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008946:	50 56       	stdsp	sp[0x14],r6
80008948:	c6 68       	rjmp	80008a14 <_vfprintf_r+0x888>
8000894a:	41 09       	lddsp	r9,sp[0x40]
8000894c:	59 f8       	cp.w	r8,31
8000894e:	e0 89 00 10 	brgt	8000896e <_vfprintf_r+0x7e2>
80008952:	f2 ca ff f8 	sub	r10,r9,-8
80008956:	72 1b       	ld.w	r11,r9[0x4]
80008958:	51 0a       	stdsp	sp[0x40],r10
8000895a:	72 09       	ld.w	r9,r9[0x0]
8000895c:	fa ca f9 44 	sub	r10,sp,-1724
80008960:	50 7b       	stdsp	sp[0x1c],r11
80008962:	50 59       	stdsp	sp[0x14],r9
80008964:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008968:	40 5b       	lddsp	r11,sp[0x14]
8000896a:	40 7a       	lddsp	r10,sp[0x1c]
8000896c:	c4 78       	rjmp	800089fa <_vfprintf_r+0x86e>
8000896e:	72 18       	ld.w	r8,r9[0x4]
80008970:	50 78       	stdsp	sp[0x1c],r8
80008972:	c4 c8       	rjmp	80008a0a <_vfprintf_r+0x87e>
80008974:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008978:	40 3e       	lddsp	lr,sp[0xc]
8000897a:	58 0e       	cp.w	lr,0
8000897c:	c2 30       	breq	800089c2 <_vfprintf_r+0x836>
8000897e:	10 36       	cp.w	r6,r8
80008980:	c0 94       	brge	80008992 <_vfprintf_r+0x806>
80008982:	fa cc f9 44 	sub	r12,sp,-1724
80008986:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000898a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000898e:	50 7b       	stdsp	sp[0x1c],r11
80008990:	cd 9b       	rjmp	80008942 <_vfprintf_r+0x7b6>
80008992:	fa c8 f9 50 	sub	r8,sp,-1712
80008996:	1a d8       	st.w	--sp,r8
80008998:	fa c8 fa b8 	sub	r8,sp,-1352
8000899c:	04 9a       	mov	r10,r2
8000899e:	1a d8       	st.w	--sp,r8
800089a0:	fa c8 fb b4 	sub	r8,sp,-1100
800089a4:	0c 9b       	mov	r11,r6
800089a6:	1a d8       	st.w	--sp,r8
800089a8:	08 9c       	mov	r12,r4
800089aa:	fa c8 f9 40 	sub	r8,sp,-1728
800089ae:	fa c9 ff b4 	sub	r9,sp,-76
800089b2:	fe b0 fa 55 	rcall	80007e5c <get_arg>
800089b6:	2f dd       	sub	sp,-12
800089b8:	78 1a       	ld.w	r10,r12[0x4]
800089ba:	50 7a       	stdsp	sp[0x1c],r10
800089bc:	78 0c       	ld.w	r12,r12[0x0]
800089be:	50 5c       	stdsp	sp[0x14],r12
800089c0:	c2 a8       	rjmp	80008a14 <_vfprintf_r+0x888>
800089c2:	2f f7       	sub	r7,-1
800089c4:	10 39       	cp.w	r9,r8
800089c6:	c0 94       	brge	800089d8 <_vfprintf_r+0x84c>
800089c8:	fa c9 f9 44 	sub	r9,sp,-1724
800089cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089d0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800089d4:	50 78       	stdsp	sp[0x1c],r8
800089d6:	cb 6b       	rjmp	80008942 <_vfprintf_r+0x7b6>
800089d8:	41 09       	lddsp	r9,sp[0x40]
800089da:	59 f8       	cp.w	r8,31
800089dc:	e0 89 00 15 	brgt	80008a06 <_vfprintf_r+0x87a>
800089e0:	f2 ca ff f8 	sub	r10,r9,-8
800089e4:	72 16       	ld.w	r6,r9[0x4]
800089e6:	72 09       	ld.w	r9,r9[0x0]
800089e8:	51 0a       	stdsp	sp[0x40],r10
800089ea:	50 59       	stdsp	sp[0x14],r9
800089ec:	fa ce f9 44 	sub	lr,sp,-1724
800089f0:	50 76       	stdsp	sp[0x1c],r6
800089f2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800089f6:	40 5b       	lddsp	r11,sp[0x14]
800089f8:	0c 9a       	mov	r10,r6
800089fa:	f2 eb fd 88 	st.d	r9[-632],r10
800089fe:	2f f8       	sub	r8,-1
80008a00:	fb 48 06 b4 	st.w	sp[1716],r8
80008a04:	c0 88       	rjmp	80008a14 <_vfprintf_r+0x888>
80008a06:	72 1c       	ld.w	r12,r9[0x4]
80008a08:	50 7c       	stdsp	sp[0x1c],r12
80008a0a:	f2 c8 ff f8 	sub	r8,r9,-8
80008a0e:	51 08       	stdsp	sp[0x40],r8
80008a10:	72 09       	ld.w	r9,r9[0x0]
80008a12:	50 59       	stdsp	sp[0x14],r9
80008a14:	40 5b       	lddsp	r11,sp[0x14]
80008a16:	40 7a       	lddsp	r10,sp[0x1c]
80008a18:	e0 a0 19 54 	rcall	8000bcc0 <__isinfd>
80008a1c:	18 96       	mov	r6,r12
80008a1e:	c1 70       	breq	80008a4c <_vfprintf_r+0x8c0>
80008a20:	30 08       	mov	r8,0
80008a22:	30 09       	mov	r9,0
80008a24:	40 5b       	lddsp	r11,sp[0x14]
80008a26:	40 7a       	lddsp	r10,sp[0x1c]
80008a28:	e0 a0 1d b4 	rcall	8000c590 <__avr32_f64_cmp_lt>
80008a2c:	c0 40       	breq	80008a34 <_vfprintf_r+0x8a8>
80008a2e:	32 d8       	mov	r8,45
80008a30:	fb 68 06 bb 	st.b	sp[1723],r8
80008a34:	fe c8 aa 74 	sub	r8,pc,-21900
80008a38:	fe c6 aa 74 	sub	r6,pc,-21900
80008a3c:	a7 d5       	cbr	r5,0x7
80008a3e:	e0 40 00 47 	cp.w	r0,71
80008a42:	f0 06 17 a0 	movle	r6,r8
80008a46:	30 32       	mov	r2,3
80008a48:	e0 8f 06 ce 	bral	800097e4 <_vfprintf_r+0x1658>
80008a4c:	40 5b       	lddsp	r11,sp[0x14]
80008a4e:	40 7a       	lddsp	r10,sp[0x1c]
80008a50:	e0 a0 19 4d 	rcall	8000bcea <__isnand>
80008a54:	c0 e0       	breq	80008a70 <_vfprintf_r+0x8e4>
80008a56:	50 26       	stdsp	sp[0x8],r6
80008a58:	fe c8 aa 90 	sub	r8,pc,-21872
80008a5c:	fe c6 aa 90 	sub	r6,pc,-21872
80008a60:	a7 d5       	cbr	r5,0x7
80008a62:	e0 40 00 47 	cp.w	r0,71
80008a66:	f0 06 17 a0 	movle	r6,r8
80008a6a:	30 32       	mov	r2,3
80008a6c:	e0 8f 06 c2 	bral	800097f0 <_vfprintf_r+0x1664>
80008a70:	40 2a       	lddsp	r10,sp[0x8]
80008a72:	5b fa       	cp.w	r10,-1
80008a74:	c0 41       	brne	80008a7c <_vfprintf_r+0x8f0>
80008a76:	30 69       	mov	r9,6
80008a78:	50 29       	stdsp	sp[0x8],r9
80008a7a:	c1 18       	rjmp	80008a9c <_vfprintf_r+0x910>
80008a7c:	e0 40 00 47 	cp.w	r0,71
80008a80:	5f 09       	sreq	r9
80008a82:	e0 40 00 67 	cp.w	r0,103
80008a86:	5f 08       	sreq	r8
80008a88:	f3 e8 10 08 	or	r8,r9,r8
80008a8c:	f8 08 18 00 	cp.b	r8,r12
80008a90:	c0 60       	breq	80008a9c <_vfprintf_r+0x910>
80008a92:	40 28       	lddsp	r8,sp[0x8]
80008a94:	58 08       	cp.w	r8,0
80008a96:	f9 b8 00 01 	moveq	r8,1
80008a9a:	50 28       	stdsp	sp[0x8],r8
80008a9c:	40 78       	lddsp	r8,sp[0x1c]
80008a9e:	40 59       	lddsp	r9,sp[0x14]
80008aa0:	fa e9 06 94 	st.d	sp[1684],r8
80008aa4:	a9 a5       	sbr	r5,0x8
80008aa6:	fa f8 06 94 	ld.w	r8,sp[1684]
80008aaa:	58 08       	cp.w	r8,0
80008aac:	c0 65       	brlt	80008ab8 <_vfprintf_r+0x92c>
80008aae:	40 5e       	lddsp	lr,sp[0x14]
80008ab0:	30 0c       	mov	r12,0
80008ab2:	50 6e       	stdsp	sp[0x18],lr
80008ab4:	50 9c       	stdsp	sp[0x24],r12
80008ab6:	c0 78       	rjmp	80008ac4 <_vfprintf_r+0x938>
80008ab8:	40 5b       	lddsp	r11,sp[0x14]
80008aba:	32 da       	mov	r10,45
80008abc:	ee 1b 80 00 	eorh	r11,0x8000
80008ac0:	50 9a       	stdsp	sp[0x24],r10
80008ac2:	50 6b       	stdsp	sp[0x18],r11
80008ac4:	e0 40 00 46 	cp.w	r0,70
80008ac8:	5f 09       	sreq	r9
80008aca:	e0 40 00 66 	cp.w	r0,102
80008ace:	5f 08       	sreq	r8
80008ad0:	f3 e8 10 08 	or	r8,r9,r8
80008ad4:	50 48       	stdsp	sp[0x10],r8
80008ad6:	c0 40       	breq	80008ade <_vfprintf_r+0x952>
80008ad8:	40 22       	lddsp	r2,sp[0x8]
80008ada:	30 39       	mov	r9,3
80008adc:	c1 08       	rjmp	80008afc <_vfprintf_r+0x970>
80008ade:	e0 40 00 45 	cp.w	r0,69
80008ae2:	5f 09       	sreq	r9
80008ae4:	e0 40 00 65 	cp.w	r0,101
80008ae8:	5f 08       	sreq	r8
80008aea:	40 22       	lddsp	r2,sp[0x8]
80008aec:	10 49       	or	r9,r8
80008aee:	2f f2       	sub	r2,-1
80008af0:	40 46       	lddsp	r6,sp[0x10]
80008af2:	ec 09 18 00 	cp.b	r9,r6
80008af6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008afa:	30 29       	mov	r9,2
80008afc:	fa c8 f9 5c 	sub	r8,sp,-1700
80008b00:	1a d8       	st.w	--sp,r8
80008b02:	fa c8 f9 54 	sub	r8,sp,-1708
80008b06:	1a d8       	st.w	--sp,r8
80008b08:	fa c8 f9 4c 	sub	r8,sp,-1716
80008b0c:	08 9c       	mov	r12,r4
80008b0e:	1a d8       	st.w	--sp,r8
80008b10:	04 98       	mov	r8,r2
80008b12:	40 9b       	lddsp	r11,sp[0x24]
80008b14:	40 aa       	lddsp	r10,sp[0x28]
80008b16:	e0 a0 0b c3 	rcall	8000a29c <_dtoa_r>
80008b1a:	e0 40 00 47 	cp.w	r0,71
80008b1e:	5f 19       	srne	r9
80008b20:	e0 40 00 67 	cp.w	r0,103
80008b24:	5f 18       	srne	r8
80008b26:	18 96       	mov	r6,r12
80008b28:	2f dd       	sub	sp,-12
80008b2a:	f3 e8 00 08 	and	r8,r9,r8
80008b2e:	c0 41       	brne	80008b36 <_vfprintf_r+0x9aa>
80008b30:	ed b5 00 00 	bld	r5,0x0
80008b34:	c3 01       	brne	80008b94 <_vfprintf_r+0xa08>
80008b36:	ec 02 00 0e 	add	lr,r6,r2
80008b3a:	50 3e       	stdsp	sp[0xc],lr
80008b3c:	40 4c       	lddsp	r12,sp[0x10]
80008b3e:	58 0c       	cp.w	r12,0
80008b40:	c1 50       	breq	80008b6a <_vfprintf_r+0x9de>
80008b42:	0d 89       	ld.ub	r9,r6[0x0]
80008b44:	33 08       	mov	r8,48
80008b46:	f0 09 18 00 	cp.b	r9,r8
80008b4a:	c0 b1       	brne	80008b60 <_vfprintf_r+0x9d4>
80008b4c:	30 08       	mov	r8,0
80008b4e:	30 09       	mov	r9,0
80008b50:	40 6b       	lddsp	r11,sp[0x18]
80008b52:	40 7a       	lddsp	r10,sp[0x1c]
80008b54:	e0 a0 1c d7 	rcall	8000c502 <__avr32_f64_cmp_eq>
80008b58:	fb b2 00 01 	rsubeq	r2,1
80008b5c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008b60:	40 3b       	lddsp	r11,sp[0xc]
80008b62:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b66:	10 0b       	add	r11,r8
80008b68:	50 3b       	stdsp	sp[0xc],r11
80008b6a:	40 6b       	lddsp	r11,sp[0x18]
80008b6c:	30 08       	mov	r8,0
80008b6e:	30 09       	mov	r9,0
80008b70:	40 7a       	lddsp	r10,sp[0x1c]
80008b72:	e0 a0 1c c8 	rcall	8000c502 <__avr32_f64_cmp_eq>
80008b76:	c0 90       	breq	80008b88 <_vfprintf_r+0x9fc>
80008b78:	40 3a       	lddsp	r10,sp[0xc]
80008b7a:	fb 4a 06 a4 	st.w	sp[1700],r10
80008b7e:	c0 58       	rjmp	80008b88 <_vfprintf_r+0x9fc>
80008b80:	10 c9       	st.b	r8++,r9
80008b82:	fb 48 06 a4 	st.w	sp[1700],r8
80008b86:	c0 28       	rjmp	80008b8a <_vfprintf_r+0x9fe>
80008b88:	33 09       	mov	r9,48
80008b8a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b8e:	40 3e       	lddsp	lr,sp[0xc]
80008b90:	1c 38       	cp.w	r8,lr
80008b92:	cf 73       	brcs	80008b80 <_vfprintf_r+0x9f4>
80008b94:	e0 40 00 47 	cp.w	r0,71
80008b98:	5f 09       	sreq	r9
80008b9a:	e0 40 00 67 	cp.w	r0,103
80008b9e:	5f 08       	sreq	r8
80008ba0:	f3 e8 10 08 	or	r8,r9,r8
80008ba4:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008ba8:	0c 19       	sub	r9,r6
80008baa:	50 69       	stdsp	sp[0x18],r9
80008bac:	58 08       	cp.w	r8,0
80008bae:	c0 b0       	breq	80008bc4 <_vfprintf_r+0xa38>
80008bb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bb4:	5b d8       	cp.w	r8,-3
80008bb6:	c0 55       	brlt	80008bc0 <_vfprintf_r+0xa34>
80008bb8:	40 2c       	lddsp	r12,sp[0x8]
80008bba:	18 38       	cp.w	r8,r12
80008bbc:	e0 8a 00 6a 	brle	80008c90 <_vfprintf_r+0xb04>
80008bc0:	20 20       	sub	r0,2
80008bc2:	c0 58       	rjmp	80008bcc <_vfprintf_r+0xa40>
80008bc4:	e0 40 00 65 	cp.w	r0,101
80008bc8:	e0 89 00 46 	brgt	80008c54 <_vfprintf_r+0xac8>
80008bcc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008bd0:	fb 60 06 9c 	st.b	sp[1692],r0
80008bd4:	20 1b       	sub	r11,1
80008bd6:	fb 4b 06 ac 	st.w	sp[1708],r11
80008bda:	c0 47       	brpl	80008be2 <_vfprintf_r+0xa56>
80008bdc:	5c 3b       	neg	r11
80008bde:	32 d8       	mov	r8,45
80008be0:	c0 28       	rjmp	80008be4 <_vfprintf_r+0xa58>
80008be2:	32 b8       	mov	r8,43
80008be4:	fb 68 06 9d 	st.b	sp[1693],r8
80008be8:	58 9b       	cp.w	r11,9
80008bea:	e0 8a 00 1d 	brle	80008c24 <_vfprintf_r+0xa98>
80008bee:	fa c9 fa 35 	sub	r9,sp,-1483
80008bf2:	30 aa       	mov	r10,10
80008bf4:	12 98       	mov	r8,r9
80008bf6:	0e 9c       	mov	r12,r7
80008bf8:	0c 92       	mov	r2,r6
80008bfa:	f6 0a 0c 06 	divs	r6,r11,r10
80008bfe:	0e 9b       	mov	r11,r7
80008c00:	2d 0b       	sub	r11,-48
80008c02:	10 fb       	st.b	--r8,r11
80008c04:	0c 9b       	mov	r11,r6
80008c06:	58 96       	cp.w	r6,9
80008c08:	fe 99 ff f9 	brgt	80008bfa <_vfprintf_r+0xa6e>
80008c0c:	2d 0b       	sub	r11,-48
80008c0e:	18 97       	mov	r7,r12
80008c10:	04 96       	mov	r6,r2
80008c12:	10 fb       	st.b	--r8,r11
80008c14:	fa ca f9 62 	sub	r10,sp,-1694
80008c18:	c0 38       	rjmp	80008c1e <_vfprintf_r+0xa92>
80008c1a:	11 3b       	ld.ub	r11,r8++
80008c1c:	14 cb       	st.b	r10++,r11
80008c1e:	12 38       	cp.w	r8,r9
80008c20:	cf d3       	brcs	80008c1a <_vfprintf_r+0xa8e>
80008c22:	c0 98       	rjmp	80008c34 <_vfprintf_r+0xaa8>
80008c24:	2d 0b       	sub	r11,-48
80008c26:	33 08       	mov	r8,48
80008c28:	fb 6b 06 9f 	st.b	sp[1695],r11
80008c2c:	fb 68 06 9e 	st.b	sp[1694],r8
80008c30:	fa ca f9 60 	sub	r10,sp,-1696
80008c34:	fa c8 f9 64 	sub	r8,sp,-1692
80008c38:	f4 08 01 08 	sub	r8,r10,r8
80008c3c:	50 e8       	stdsp	sp[0x38],r8
80008c3e:	10 92       	mov	r2,r8
80008c40:	40 6b       	lddsp	r11,sp[0x18]
80008c42:	16 02       	add	r2,r11
80008c44:	58 1b       	cp.w	r11,1
80008c46:	e0 89 00 05 	brgt	80008c50 <_vfprintf_r+0xac4>
80008c4a:	ed b5 00 00 	bld	r5,0x0
80008c4e:	c3 51       	brne	80008cb8 <_vfprintf_r+0xb2c>
80008c50:	2f f2       	sub	r2,-1
80008c52:	c3 38       	rjmp	80008cb8 <_vfprintf_r+0xb2c>
80008c54:	e0 40 00 66 	cp.w	r0,102
80008c58:	c1 c1       	brne	80008c90 <_vfprintf_r+0xb04>
80008c5a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c5e:	58 02       	cp.w	r2,0
80008c60:	e0 8a 00 0c 	brle	80008c78 <_vfprintf_r+0xaec>
80008c64:	40 2a       	lddsp	r10,sp[0x8]
80008c66:	58 0a       	cp.w	r10,0
80008c68:	c0 41       	brne	80008c70 <_vfprintf_r+0xae4>
80008c6a:	ed b5 00 00 	bld	r5,0x0
80008c6e:	c2 51       	brne	80008cb8 <_vfprintf_r+0xb2c>
80008c70:	2f f2       	sub	r2,-1
80008c72:	40 29       	lddsp	r9,sp[0x8]
80008c74:	12 02       	add	r2,r9
80008c76:	c0 b8       	rjmp	80008c8c <_vfprintf_r+0xb00>
80008c78:	40 28       	lddsp	r8,sp[0x8]
80008c7a:	58 08       	cp.w	r8,0
80008c7c:	c0 61       	brne	80008c88 <_vfprintf_r+0xafc>
80008c7e:	ed b5 00 00 	bld	r5,0x0
80008c82:	c0 30       	breq	80008c88 <_vfprintf_r+0xafc>
80008c84:	30 12       	mov	r2,1
80008c86:	c1 98       	rjmp	80008cb8 <_vfprintf_r+0xb2c>
80008c88:	40 22       	lddsp	r2,sp[0x8]
80008c8a:	2f e2       	sub	r2,-2
80008c8c:	36 60       	mov	r0,102
80008c8e:	c1 58       	rjmp	80008cb8 <_vfprintf_r+0xb2c>
80008c90:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c94:	40 6e       	lddsp	lr,sp[0x18]
80008c96:	1c 32       	cp.w	r2,lr
80008c98:	c0 65       	brlt	80008ca4 <_vfprintf_r+0xb18>
80008c9a:	ed b5 00 00 	bld	r5,0x0
80008c9e:	f7 b2 00 ff 	subeq	r2,-1
80008ca2:	c0 a8       	rjmp	80008cb6 <_vfprintf_r+0xb2a>
80008ca4:	e4 08 11 02 	rsub	r8,r2,2
80008ca8:	40 6c       	lddsp	r12,sp[0x18]
80008caa:	58 02       	cp.w	r2,0
80008cac:	f0 02 17 a0 	movle	r2,r8
80008cb0:	f9 b2 09 01 	movgt	r2,1
80008cb4:	18 02       	add	r2,r12
80008cb6:	36 70       	mov	r0,103
80008cb8:	40 9b       	lddsp	r11,sp[0x24]
80008cba:	58 0b       	cp.w	r11,0
80008cbc:	e0 80 05 94 	breq	800097e4 <_vfprintf_r+0x1658>
80008cc0:	32 d8       	mov	r8,45
80008cc2:	fb 68 06 bb 	st.b	sp[1723],r8
80008cc6:	e0 8f 05 93 	bral	800097ec <_vfprintf_r+0x1660>
80008cca:	50 a7       	stdsp	sp[0x28],r7
80008ccc:	04 94       	mov	r4,r2
80008cce:	0c 97       	mov	r7,r6
80008cd0:	02 92       	mov	r2,r1
80008cd2:	06 96       	mov	r6,r3
80008cd4:	40 41       	lddsp	r1,sp[0x10]
80008cd6:	40 93       	lddsp	r3,sp[0x24]
80008cd8:	0e 99       	mov	r9,r7
80008cda:	ed b5 00 05 	bld	r5,0x5
80008cde:	c4 81       	brne	80008d6e <_vfprintf_r+0xbe2>
80008ce0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ce4:	40 3e       	lddsp	lr,sp[0xc]
80008ce6:	58 0e       	cp.w	lr,0
80008ce8:	c1 d0       	breq	80008d22 <_vfprintf_r+0xb96>
80008cea:	10 36       	cp.w	r6,r8
80008cec:	c0 64       	brge	80008cf8 <_vfprintf_r+0xb6c>
80008cee:	fa cc f9 44 	sub	r12,sp,-1724
80008cf2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cf6:	c1 d8       	rjmp	80008d30 <_vfprintf_r+0xba4>
80008cf8:	fa c8 f9 50 	sub	r8,sp,-1712
80008cfc:	1a d8       	st.w	--sp,r8
80008cfe:	fa c8 fa b8 	sub	r8,sp,-1352
80008d02:	04 9a       	mov	r10,r2
80008d04:	1a d8       	st.w	--sp,r8
80008d06:	fa c8 fb b4 	sub	r8,sp,-1100
80008d0a:	0c 9b       	mov	r11,r6
80008d0c:	1a d8       	st.w	--sp,r8
80008d0e:	08 9c       	mov	r12,r4
80008d10:	fa c8 f9 40 	sub	r8,sp,-1728
80008d14:	fa c9 ff b4 	sub	r9,sp,-76
80008d18:	fe b0 f8 a2 	rcall	80007e5c <get_arg>
80008d1c:	2f dd       	sub	sp,-12
80008d1e:	78 0a       	ld.w	r10,r12[0x0]
80008d20:	c2 08       	rjmp	80008d60 <_vfprintf_r+0xbd4>
80008d22:	2f f7       	sub	r7,-1
80008d24:	10 39       	cp.w	r9,r8
80008d26:	c0 84       	brge	80008d36 <_vfprintf_r+0xbaa>
80008d28:	fa cb f9 44 	sub	r11,sp,-1724
80008d2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d30:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d34:	c1 68       	rjmp	80008d60 <_vfprintf_r+0xbd4>
80008d36:	41 09       	lddsp	r9,sp[0x40]
80008d38:	59 f8       	cp.w	r8,31
80008d3a:	e0 89 00 10 	brgt	80008d5a <_vfprintf_r+0xbce>
80008d3e:	f2 ca ff fc 	sub	r10,r9,-4
80008d42:	51 0a       	stdsp	sp[0x40],r10
80008d44:	fa c6 f9 44 	sub	r6,sp,-1724
80008d48:	72 0a       	ld.w	r10,r9[0x0]
80008d4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d4e:	f3 4a fd 88 	st.w	r9[-632],r10
80008d52:	2f f8       	sub	r8,-1
80008d54:	fb 48 06 b4 	st.w	sp[1716],r8
80008d58:	c0 48       	rjmp	80008d60 <_vfprintf_r+0xbd4>
80008d5a:	72 0a       	ld.w	r10,r9[0x0]
80008d5c:	2f c9       	sub	r9,-4
80008d5e:	51 09       	stdsp	sp[0x40],r9
80008d60:	40 be       	lddsp	lr,sp[0x2c]
80008d62:	1c 98       	mov	r8,lr
80008d64:	95 1e       	st.w	r10[0x4],lr
80008d66:	bf 58       	asr	r8,0x1f
80008d68:	95 08       	st.w	r10[0x0],r8
80008d6a:	fe 9f fa 9f 	bral	800082a8 <_vfprintf_r+0x11c>
80008d6e:	ed b5 00 04 	bld	r5,0x4
80008d72:	c4 80       	breq	80008e02 <_vfprintf_r+0xc76>
80008d74:	e2 15 00 40 	andl	r5,0x40,COH
80008d78:	c4 50       	breq	80008e02 <_vfprintf_r+0xc76>
80008d7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d7e:	40 3c       	lddsp	r12,sp[0xc]
80008d80:	58 0c       	cp.w	r12,0
80008d82:	c1 d0       	breq	80008dbc <_vfprintf_r+0xc30>
80008d84:	10 36       	cp.w	r6,r8
80008d86:	c0 64       	brge	80008d92 <_vfprintf_r+0xc06>
80008d88:	fa cb f9 44 	sub	r11,sp,-1724
80008d8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d90:	c1 d8       	rjmp	80008dca <_vfprintf_r+0xc3e>
80008d92:	fa c8 f9 50 	sub	r8,sp,-1712
80008d96:	1a d8       	st.w	--sp,r8
80008d98:	fa c8 fa b8 	sub	r8,sp,-1352
80008d9c:	04 9a       	mov	r10,r2
80008d9e:	1a d8       	st.w	--sp,r8
80008da0:	fa c8 fb b4 	sub	r8,sp,-1100
80008da4:	0c 9b       	mov	r11,r6
80008da6:	1a d8       	st.w	--sp,r8
80008da8:	08 9c       	mov	r12,r4
80008daa:	fa c8 f9 40 	sub	r8,sp,-1728
80008dae:	fa c9 ff b4 	sub	r9,sp,-76
80008db2:	fe b0 f8 55 	rcall	80007e5c <get_arg>
80008db6:	2f dd       	sub	sp,-12
80008db8:	78 0a       	ld.w	r10,r12[0x0]
80008dba:	c2 08       	rjmp	80008dfa <_vfprintf_r+0xc6e>
80008dbc:	2f f7       	sub	r7,-1
80008dbe:	10 39       	cp.w	r9,r8
80008dc0:	c0 84       	brge	80008dd0 <_vfprintf_r+0xc44>
80008dc2:	fa ca f9 44 	sub	r10,sp,-1724
80008dc6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dca:	ec fa fd 88 	ld.w	r10,r6[-632]
80008dce:	c1 68       	rjmp	80008dfa <_vfprintf_r+0xc6e>
80008dd0:	41 09       	lddsp	r9,sp[0x40]
80008dd2:	59 f8       	cp.w	r8,31
80008dd4:	e0 89 00 10 	brgt	80008df4 <_vfprintf_r+0xc68>
80008dd8:	f2 ca ff fc 	sub	r10,r9,-4
80008ddc:	51 0a       	stdsp	sp[0x40],r10
80008dde:	fa c6 f9 44 	sub	r6,sp,-1724
80008de2:	72 0a       	ld.w	r10,r9[0x0]
80008de4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008de8:	f3 4a fd 88 	st.w	r9[-632],r10
80008dec:	2f f8       	sub	r8,-1
80008dee:	fb 48 06 b4 	st.w	sp[1716],r8
80008df2:	c0 48       	rjmp	80008dfa <_vfprintf_r+0xc6e>
80008df4:	72 0a       	ld.w	r10,r9[0x0]
80008df6:	2f c9       	sub	r9,-4
80008df8:	51 09       	stdsp	sp[0x40],r9
80008dfa:	40 be       	lddsp	lr,sp[0x2c]
80008dfc:	b4 0e       	st.h	r10[0x0],lr
80008dfe:	fe 9f fa 55 	bral	800082a8 <_vfprintf_r+0x11c>
80008e02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e06:	40 3c       	lddsp	r12,sp[0xc]
80008e08:	58 0c       	cp.w	r12,0
80008e0a:	c1 d0       	breq	80008e44 <_vfprintf_r+0xcb8>
80008e0c:	10 36       	cp.w	r6,r8
80008e0e:	c0 64       	brge	80008e1a <_vfprintf_r+0xc8e>
80008e10:	fa cb f9 44 	sub	r11,sp,-1724
80008e14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e18:	c1 d8       	rjmp	80008e52 <_vfprintf_r+0xcc6>
80008e1a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e1e:	1a d8       	st.w	--sp,r8
80008e20:	fa c8 fa b8 	sub	r8,sp,-1352
80008e24:	04 9a       	mov	r10,r2
80008e26:	1a d8       	st.w	--sp,r8
80008e28:	fa c8 fb b4 	sub	r8,sp,-1100
80008e2c:	0c 9b       	mov	r11,r6
80008e2e:	1a d8       	st.w	--sp,r8
80008e30:	08 9c       	mov	r12,r4
80008e32:	fa c8 f9 40 	sub	r8,sp,-1728
80008e36:	fa c9 ff b4 	sub	r9,sp,-76
80008e3a:	fe b0 f8 11 	rcall	80007e5c <get_arg>
80008e3e:	2f dd       	sub	sp,-12
80008e40:	78 0a       	ld.w	r10,r12[0x0]
80008e42:	c2 08       	rjmp	80008e82 <_vfprintf_r+0xcf6>
80008e44:	2f f7       	sub	r7,-1
80008e46:	10 39       	cp.w	r9,r8
80008e48:	c0 84       	brge	80008e58 <_vfprintf_r+0xccc>
80008e4a:	fa ca f9 44 	sub	r10,sp,-1724
80008e4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e52:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e56:	c1 68       	rjmp	80008e82 <_vfprintf_r+0xcf6>
80008e58:	41 09       	lddsp	r9,sp[0x40]
80008e5a:	59 f8       	cp.w	r8,31
80008e5c:	e0 89 00 10 	brgt	80008e7c <_vfprintf_r+0xcf0>
80008e60:	f2 ca ff fc 	sub	r10,r9,-4
80008e64:	51 0a       	stdsp	sp[0x40],r10
80008e66:	fa c6 f9 44 	sub	r6,sp,-1724
80008e6a:	72 0a       	ld.w	r10,r9[0x0]
80008e6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e70:	f3 4a fd 88 	st.w	r9[-632],r10
80008e74:	2f f8       	sub	r8,-1
80008e76:	fb 48 06 b4 	st.w	sp[1716],r8
80008e7a:	c0 48       	rjmp	80008e82 <_vfprintf_r+0xcf6>
80008e7c:	72 0a       	ld.w	r10,r9[0x0]
80008e7e:	2f c9       	sub	r9,-4
80008e80:	51 09       	stdsp	sp[0x40],r9
80008e82:	40 be       	lddsp	lr,sp[0x2c]
80008e84:	95 0e       	st.w	r10[0x0],lr
80008e86:	fe 9f fa 11 	bral	800082a8 <_vfprintf_r+0x11c>
80008e8a:	50 a7       	stdsp	sp[0x28],r7
80008e8c:	50 80       	stdsp	sp[0x20],r0
80008e8e:	0c 97       	mov	r7,r6
80008e90:	04 94       	mov	r4,r2
80008e92:	06 96       	mov	r6,r3
80008e94:	02 92       	mov	r2,r1
80008e96:	40 93       	lddsp	r3,sp[0x24]
80008e98:	10 90       	mov	r0,r8
80008e9a:	40 41       	lddsp	r1,sp[0x10]
80008e9c:	a5 a5       	sbr	r5,0x4
80008e9e:	c0 a8       	rjmp	80008eb2 <_vfprintf_r+0xd26>
80008ea0:	50 a7       	stdsp	sp[0x28],r7
80008ea2:	50 80       	stdsp	sp[0x20],r0
80008ea4:	0c 97       	mov	r7,r6
80008ea6:	04 94       	mov	r4,r2
80008ea8:	06 96       	mov	r6,r3
80008eaa:	02 92       	mov	r2,r1
80008eac:	40 93       	lddsp	r3,sp[0x24]
80008eae:	10 90       	mov	r0,r8
80008eb0:	40 41       	lddsp	r1,sp[0x10]
80008eb2:	ed b5 00 05 	bld	r5,0x5
80008eb6:	c5 d1       	brne	80008f70 <_vfprintf_r+0xde4>
80008eb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ebc:	40 3c       	lddsp	r12,sp[0xc]
80008ebe:	58 0c       	cp.w	r12,0
80008ec0:	c2 60       	breq	80008f0c <_vfprintf_r+0xd80>
80008ec2:	10 36       	cp.w	r6,r8
80008ec4:	c0 a4       	brge	80008ed8 <_vfprintf_r+0xd4c>
80008ec6:	fa cb f9 44 	sub	r11,sp,-1724
80008eca:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ece:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008ed2:	fa e9 00 00 	st.d	sp[0],r8
80008ed6:	c1 88       	rjmp	80008f06 <_vfprintf_r+0xd7a>
80008ed8:	fa c8 f9 50 	sub	r8,sp,-1712
80008edc:	1a d8       	st.w	--sp,r8
80008ede:	fa c8 fa b8 	sub	r8,sp,-1352
80008ee2:	04 9a       	mov	r10,r2
80008ee4:	1a d8       	st.w	--sp,r8
80008ee6:	0c 9b       	mov	r11,r6
80008ee8:	fa c8 fb b4 	sub	r8,sp,-1100
80008eec:	08 9c       	mov	r12,r4
80008eee:	1a d8       	st.w	--sp,r8
80008ef0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ef4:	fa c9 ff b4 	sub	r9,sp,-76
80008ef8:	fe b0 f7 b2 	rcall	80007e5c <get_arg>
80008efc:	2f dd       	sub	sp,-12
80008efe:	f8 ea 00 00 	ld.d	r10,r12[0]
80008f02:	fa eb 00 00 	st.d	sp[0],r10
80008f06:	30 08       	mov	r8,0
80008f08:	e0 8f 03 de 	bral	800096c4 <_vfprintf_r+0x1538>
80008f0c:	ee ca ff ff 	sub	r10,r7,-1
80008f10:	10 37       	cp.w	r7,r8
80008f12:	c0 b4       	brge	80008f28 <_vfprintf_r+0xd9c>
80008f14:	fa c9 f9 44 	sub	r9,sp,-1724
80008f18:	14 97       	mov	r7,r10
80008f1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f22:	fa eb 00 00 	st.d	sp[0],r10
80008f26:	c1 88       	rjmp	80008f56 <_vfprintf_r+0xdca>
80008f28:	41 09       	lddsp	r9,sp[0x40]
80008f2a:	59 f8       	cp.w	r8,31
80008f2c:	e0 89 00 18 	brgt	80008f5c <_vfprintf_r+0xdd0>
80008f30:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f34:	f2 cb ff f8 	sub	r11,r9,-8
80008f38:	fa e7 00 00 	st.d	sp[0],r6
80008f3c:	51 0b       	stdsp	sp[0x40],r11
80008f3e:	fa c6 f9 44 	sub	r6,sp,-1724
80008f42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f46:	fa e6 00 00 	ld.d	r6,sp[0]
80008f4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008f4e:	2f f8       	sub	r8,-1
80008f50:	14 97       	mov	r7,r10
80008f52:	fb 48 06 b4 	st.w	sp[1716],r8
80008f56:	40 38       	lddsp	r8,sp[0xc]
80008f58:	e0 8f 03 b6 	bral	800096c4 <_vfprintf_r+0x1538>
80008f5c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f60:	40 38       	lddsp	r8,sp[0xc]
80008f62:	fa e7 00 00 	st.d	sp[0],r6
80008f66:	2f 89       	sub	r9,-8
80008f68:	14 97       	mov	r7,r10
80008f6a:	51 09       	stdsp	sp[0x40],r9
80008f6c:	e0 8f 03 ac 	bral	800096c4 <_vfprintf_r+0x1538>
80008f70:	ed b5 00 04 	bld	r5,0x4
80008f74:	c1 61       	brne	80008fa0 <_vfprintf_r+0xe14>
80008f76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f7a:	40 3e       	lddsp	lr,sp[0xc]
80008f7c:	58 0e       	cp.w	lr,0
80008f7e:	c0 80       	breq	80008f8e <_vfprintf_r+0xe02>
80008f80:	10 36       	cp.w	r6,r8
80008f82:	c6 74       	brge	80009050 <_vfprintf_r+0xec4>
80008f84:	fa cc f9 44 	sub	r12,sp,-1724
80008f88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f8c:	c8 08       	rjmp	8000908c <_vfprintf_r+0xf00>
80008f8e:	ee ca ff ff 	sub	r10,r7,-1
80008f92:	10 37       	cp.w	r7,r8
80008f94:	c7 f4       	brge	80009092 <_vfprintf_r+0xf06>
80008f96:	fa cb f9 44 	sub	r11,sp,-1724
80008f9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f9e:	c7 68       	rjmp	8000908a <_vfprintf_r+0xefe>
80008fa0:	ed b5 00 06 	bld	r5,0x6
80008fa4:	c4 a1       	brne	80009038 <_vfprintf_r+0xeac>
80008fa6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008faa:	40 3c       	lddsp	r12,sp[0xc]
80008fac:	58 0c       	cp.w	r12,0
80008fae:	c1 d0       	breq	80008fe8 <_vfprintf_r+0xe5c>
80008fb0:	10 36       	cp.w	r6,r8
80008fb2:	c0 64       	brge	80008fbe <_vfprintf_r+0xe32>
80008fb4:	fa cb f9 44 	sub	r11,sp,-1724
80008fb8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fbc:	c1 f8       	rjmp	80008ffa <_vfprintf_r+0xe6e>
80008fbe:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc2:	1a d8       	st.w	--sp,r8
80008fc4:	fa c8 fa b8 	sub	r8,sp,-1352
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	fa c8 fb b4 	sub	r8,sp,-1100
80008fce:	1a d8       	st.w	--sp,r8
80008fd0:	fa c8 f9 40 	sub	r8,sp,-1728
80008fd4:	fa c9 ff b4 	sub	r9,sp,-76
80008fd8:	04 9a       	mov	r10,r2
80008fda:	0c 9b       	mov	r11,r6
80008fdc:	08 9c       	mov	r12,r4
80008fde:	fe b0 f7 3f 	rcall	80007e5c <get_arg>
80008fe2:	2f dd       	sub	sp,-12
80008fe4:	98 18       	ld.sh	r8,r12[0x2]
80008fe6:	c2 68       	rjmp	80009032 <_vfprintf_r+0xea6>
80008fe8:	ee ca ff ff 	sub	r10,r7,-1
80008fec:	10 37       	cp.w	r7,r8
80008fee:	c0 94       	brge	80009000 <_vfprintf_r+0xe74>
80008ff0:	fa c9 f9 44 	sub	r9,sp,-1724
80008ff4:	14 97       	mov	r7,r10
80008ff6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ffe:	c1 a8       	rjmp	80009032 <_vfprintf_r+0xea6>
80009000:	41 09       	lddsp	r9,sp[0x40]
80009002:	59 f8       	cp.w	r8,31
80009004:	e0 89 00 13 	brgt	8000902a <_vfprintf_r+0xe9e>
80009008:	f2 cb ff fc 	sub	r11,r9,-4
8000900c:	51 0b       	stdsp	sp[0x40],r11
8000900e:	72 09       	ld.w	r9,r9[0x0]
80009010:	fa c6 f9 44 	sub	r6,sp,-1724
80009014:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009018:	2f f8       	sub	r8,-1
8000901a:	f7 49 fd 88 	st.w	r11[-632],r9
8000901e:	fb 48 06 b4 	st.w	sp[1716],r8
80009022:	14 97       	mov	r7,r10
80009024:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009028:	c0 58       	rjmp	80009032 <_vfprintf_r+0xea6>
8000902a:	92 18       	ld.sh	r8,r9[0x2]
8000902c:	14 97       	mov	r7,r10
8000902e:	2f c9       	sub	r9,-4
80009030:	51 09       	stdsp	sp[0x40],r9
80009032:	5c 78       	castu.h	r8
80009034:	50 18       	stdsp	sp[0x4],r8
80009036:	c4 68       	rjmp	800090c2 <_vfprintf_r+0xf36>
80009038:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000903c:	40 3c       	lddsp	r12,sp[0xc]
8000903e:	58 0c       	cp.w	r12,0
80009040:	c1 d0       	breq	8000907a <_vfprintf_r+0xeee>
80009042:	10 36       	cp.w	r6,r8
80009044:	c0 64       	brge	80009050 <_vfprintf_r+0xec4>
80009046:	fa cb f9 44 	sub	r11,sp,-1724
8000904a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000904e:	c1 f8       	rjmp	8000908c <_vfprintf_r+0xf00>
80009050:	fa c8 f9 50 	sub	r8,sp,-1712
80009054:	1a d8       	st.w	--sp,r8
80009056:	fa c8 fa b8 	sub	r8,sp,-1352
8000905a:	0c 9b       	mov	r11,r6
8000905c:	1a d8       	st.w	--sp,r8
8000905e:	fa c8 fb b4 	sub	r8,sp,-1100
80009062:	04 9a       	mov	r10,r2
80009064:	1a d8       	st.w	--sp,r8
80009066:	08 9c       	mov	r12,r4
80009068:	fa c8 f9 40 	sub	r8,sp,-1728
8000906c:	fa c9 ff b4 	sub	r9,sp,-76
80009070:	fe b0 f6 f6 	rcall	80007e5c <get_arg>
80009074:	2f dd       	sub	sp,-12
80009076:	78 0b       	ld.w	r11,r12[0x0]
80009078:	c2 48       	rjmp	800090c0 <_vfprintf_r+0xf34>
8000907a:	ee ca ff ff 	sub	r10,r7,-1
8000907e:	10 37       	cp.w	r7,r8
80009080:	c0 94       	brge	80009092 <_vfprintf_r+0xf06>
80009082:	fa c9 f9 44 	sub	r9,sp,-1724
80009086:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000908a:	14 97       	mov	r7,r10
8000908c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009090:	c1 88       	rjmp	800090c0 <_vfprintf_r+0xf34>
80009092:	41 09       	lddsp	r9,sp[0x40]
80009094:	59 f8       	cp.w	r8,31
80009096:	e0 89 00 11 	brgt	800090b8 <_vfprintf_r+0xf2c>
8000909a:	f2 cb ff fc 	sub	r11,r9,-4
8000909e:	51 0b       	stdsp	sp[0x40],r11
800090a0:	fa c6 f9 44 	sub	r6,sp,-1724
800090a4:	72 0b       	ld.w	r11,r9[0x0]
800090a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090aa:	f3 4b fd 88 	st.w	r9[-632],r11
800090ae:	2f f8       	sub	r8,-1
800090b0:	14 97       	mov	r7,r10
800090b2:	fb 48 06 b4 	st.w	sp[1716],r8
800090b6:	c0 58       	rjmp	800090c0 <_vfprintf_r+0xf34>
800090b8:	72 0b       	ld.w	r11,r9[0x0]
800090ba:	14 97       	mov	r7,r10
800090bc:	2f c9       	sub	r9,-4
800090be:	51 09       	stdsp	sp[0x40],r9
800090c0:	50 1b       	stdsp	sp[0x4],r11
800090c2:	30 0e       	mov	lr,0
800090c4:	50 0e       	stdsp	sp[0x0],lr
800090c6:	1c 98       	mov	r8,lr
800090c8:	e0 8f 02 fe 	bral	800096c4 <_vfprintf_r+0x1538>
800090cc:	50 a7       	stdsp	sp[0x28],r7
800090ce:	50 80       	stdsp	sp[0x20],r0
800090d0:	0c 97       	mov	r7,r6
800090d2:	04 94       	mov	r4,r2
800090d4:	06 96       	mov	r6,r3
800090d6:	02 92       	mov	r2,r1
800090d8:	40 93       	lddsp	r3,sp[0x24]
800090da:	40 41       	lddsp	r1,sp[0x10]
800090dc:	0e 99       	mov	r9,r7
800090de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e2:	40 3c       	lddsp	r12,sp[0xc]
800090e4:	58 0c       	cp.w	r12,0
800090e6:	c1 d0       	breq	80009120 <_vfprintf_r+0xf94>
800090e8:	10 36       	cp.w	r6,r8
800090ea:	c0 64       	brge	800090f6 <_vfprintf_r+0xf6a>
800090ec:	fa cb f9 44 	sub	r11,sp,-1724
800090f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090f4:	c1 d8       	rjmp	8000912e <_vfprintf_r+0xfa2>
800090f6:	fa c8 f9 50 	sub	r8,sp,-1712
800090fa:	1a d8       	st.w	--sp,r8
800090fc:	fa c8 fa b8 	sub	r8,sp,-1352
80009100:	1a d8       	st.w	--sp,r8
80009102:	fa c8 fb b4 	sub	r8,sp,-1100
80009106:	1a d8       	st.w	--sp,r8
80009108:	fa c9 ff b4 	sub	r9,sp,-76
8000910c:	fa c8 f9 40 	sub	r8,sp,-1728
80009110:	04 9a       	mov	r10,r2
80009112:	0c 9b       	mov	r11,r6
80009114:	08 9c       	mov	r12,r4
80009116:	fe b0 f6 a3 	rcall	80007e5c <get_arg>
8000911a:	2f dd       	sub	sp,-12
8000911c:	78 09       	ld.w	r9,r12[0x0]
8000911e:	c2 18       	rjmp	80009160 <_vfprintf_r+0xfd4>
80009120:	2f f7       	sub	r7,-1
80009122:	10 39       	cp.w	r9,r8
80009124:	c0 84       	brge	80009134 <_vfprintf_r+0xfa8>
80009126:	fa ca f9 44 	sub	r10,sp,-1724
8000912a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000912e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009132:	c1 78       	rjmp	80009160 <_vfprintf_r+0xfd4>
80009134:	41 09       	lddsp	r9,sp[0x40]
80009136:	59 f8       	cp.w	r8,31
80009138:	e0 89 00 10 	brgt	80009158 <_vfprintf_r+0xfcc>
8000913c:	f2 ca ff fc 	sub	r10,r9,-4
80009140:	51 0a       	stdsp	sp[0x40],r10
80009142:	fa c6 f9 44 	sub	r6,sp,-1724
80009146:	72 09       	ld.w	r9,r9[0x0]
80009148:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000914c:	f5 49 fd 88 	st.w	r10[-632],r9
80009150:	2f f8       	sub	r8,-1
80009152:	fb 48 06 b4 	st.w	sp[1716],r8
80009156:	c0 58       	rjmp	80009160 <_vfprintf_r+0xfd4>
80009158:	f2 c8 ff fc 	sub	r8,r9,-4
8000915c:	51 08       	stdsp	sp[0x40],r8
8000915e:	72 09       	ld.w	r9,r9[0x0]
80009160:	33 08       	mov	r8,48
80009162:	fb 68 06 b8 	st.b	sp[1720],r8
80009166:	37 88       	mov	r8,120
80009168:	30 0e       	mov	lr,0
8000916a:	fb 68 06 b9 	st.b	sp[1721],r8
8000916e:	fe cc b1 9e 	sub	r12,pc,-20066
80009172:	50 19       	stdsp	sp[0x4],r9
80009174:	a1 b5       	sbr	r5,0x1
80009176:	50 0e       	stdsp	sp[0x0],lr
80009178:	50 dc       	stdsp	sp[0x34],r12
8000917a:	30 28       	mov	r8,2
8000917c:	37 80       	mov	r0,120
8000917e:	e0 8f 02 a3 	bral	800096c4 <_vfprintf_r+0x1538>
80009182:	50 a7       	stdsp	sp[0x28],r7
80009184:	50 80       	stdsp	sp[0x20],r0
80009186:	10 90       	mov	r0,r8
80009188:	30 08       	mov	r8,0
8000918a:	fb 68 06 bb 	st.b	sp[1723],r8
8000918e:	0c 97       	mov	r7,r6
80009190:	04 94       	mov	r4,r2
80009192:	06 96       	mov	r6,r3
80009194:	02 92       	mov	r2,r1
80009196:	40 93       	lddsp	r3,sp[0x24]
80009198:	40 41       	lddsp	r1,sp[0x10]
8000919a:	0e 99       	mov	r9,r7
8000919c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091a0:	40 3b       	lddsp	r11,sp[0xc]
800091a2:	58 0b       	cp.w	r11,0
800091a4:	c1 d0       	breq	800091de <_vfprintf_r+0x1052>
800091a6:	10 36       	cp.w	r6,r8
800091a8:	c0 64       	brge	800091b4 <_vfprintf_r+0x1028>
800091aa:	fa ca f9 44 	sub	r10,sp,-1724
800091ae:	f4 06 00 36 	add	r6,r10,r6<<0x3
800091b2:	c1 d8       	rjmp	800091ec <_vfprintf_r+0x1060>
800091b4:	fa c8 f9 50 	sub	r8,sp,-1712
800091b8:	1a d8       	st.w	--sp,r8
800091ba:	fa c8 fa b8 	sub	r8,sp,-1352
800091be:	1a d8       	st.w	--sp,r8
800091c0:	fa c8 fb b4 	sub	r8,sp,-1100
800091c4:	0c 9b       	mov	r11,r6
800091c6:	1a d8       	st.w	--sp,r8
800091c8:	04 9a       	mov	r10,r2
800091ca:	fa c8 f9 40 	sub	r8,sp,-1728
800091ce:	fa c9 ff b4 	sub	r9,sp,-76
800091d2:	08 9c       	mov	r12,r4
800091d4:	fe b0 f6 44 	rcall	80007e5c <get_arg>
800091d8:	2f dd       	sub	sp,-12
800091da:	78 06       	ld.w	r6,r12[0x0]
800091dc:	c2 08       	rjmp	8000921c <_vfprintf_r+0x1090>
800091de:	2f f7       	sub	r7,-1
800091e0:	10 39       	cp.w	r9,r8
800091e2:	c0 84       	brge	800091f2 <_vfprintf_r+0x1066>
800091e4:	fa c9 f9 44 	sub	r9,sp,-1724
800091e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091ec:	ec f6 fd 88 	ld.w	r6,r6[-632]
800091f0:	c1 68       	rjmp	8000921c <_vfprintf_r+0x1090>
800091f2:	41 09       	lddsp	r9,sp[0x40]
800091f4:	59 f8       	cp.w	r8,31
800091f6:	e0 89 00 10 	brgt	80009216 <_vfprintf_r+0x108a>
800091fa:	f2 ca ff fc 	sub	r10,r9,-4
800091fe:	51 0a       	stdsp	sp[0x40],r10
80009200:	72 06       	ld.w	r6,r9[0x0]
80009202:	fa ce f9 44 	sub	lr,sp,-1724
80009206:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000920a:	f3 46 fd 88 	st.w	r9[-632],r6
8000920e:	2f f8       	sub	r8,-1
80009210:	fb 48 06 b4 	st.w	sp[1716],r8
80009214:	c0 48       	rjmp	8000921c <_vfprintf_r+0x1090>
80009216:	72 06       	ld.w	r6,r9[0x0]
80009218:	2f c9       	sub	r9,-4
8000921a:	51 09       	stdsp	sp[0x40],r9
8000921c:	40 2c       	lddsp	r12,sp[0x8]
8000921e:	58 0c       	cp.w	r12,0
80009220:	c1 05       	brlt	80009240 <_vfprintf_r+0x10b4>
80009222:	18 9a       	mov	r10,r12
80009224:	30 0b       	mov	r11,0
80009226:	0c 9c       	mov	r12,r6
80009228:	e0 a0 12 38 	rcall	8000b698 <memchr>
8000922c:	e0 80 02 df 	breq	800097ea <_vfprintf_r+0x165e>
80009230:	f8 06 01 02 	sub	r2,r12,r6
80009234:	40 2b       	lddsp	r11,sp[0x8]
80009236:	16 32       	cp.w	r2,r11
80009238:	e0 89 02 d9 	brgt	800097ea <_vfprintf_r+0x165e>
8000923c:	e0 8f 02 d4 	bral	800097e4 <_vfprintf_r+0x1658>
80009240:	30 0a       	mov	r10,0
80009242:	0c 9c       	mov	r12,r6
80009244:	50 2a       	stdsp	sp[0x8],r10
80009246:	e0 a0 15 99 	rcall	8000bd78 <strlen>
8000924a:	18 92       	mov	r2,r12
8000924c:	e0 8f 02 d2 	bral	800097f0 <_vfprintf_r+0x1664>
80009250:	50 a7       	stdsp	sp[0x28],r7
80009252:	50 80       	stdsp	sp[0x20],r0
80009254:	0c 97       	mov	r7,r6
80009256:	04 94       	mov	r4,r2
80009258:	06 96       	mov	r6,r3
8000925a:	02 92       	mov	r2,r1
8000925c:	40 93       	lddsp	r3,sp[0x24]
8000925e:	10 90       	mov	r0,r8
80009260:	40 41       	lddsp	r1,sp[0x10]
80009262:	a5 a5       	sbr	r5,0x4
80009264:	c0 a8       	rjmp	80009278 <_vfprintf_r+0x10ec>
80009266:	50 a7       	stdsp	sp[0x28],r7
80009268:	50 80       	stdsp	sp[0x20],r0
8000926a:	0c 97       	mov	r7,r6
8000926c:	04 94       	mov	r4,r2
8000926e:	06 96       	mov	r6,r3
80009270:	02 92       	mov	r2,r1
80009272:	40 93       	lddsp	r3,sp[0x24]
80009274:	10 90       	mov	r0,r8
80009276:	40 41       	lddsp	r1,sp[0x10]
80009278:	ed b5 00 05 	bld	r5,0x5
8000927c:	c5 61       	brne	80009328 <_vfprintf_r+0x119c>
8000927e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009282:	40 39       	lddsp	r9,sp[0xc]
80009284:	58 09       	cp.w	r9,0
80009286:	c2 10       	breq	800092c8 <_vfprintf_r+0x113c>
80009288:	10 36       	cp.w	r6,r8
8000928a:	c0 74       	brge	80009298 <_vfprintf_r+0x110c>
8000928c:	fa c8 f9 44 	sub	r8,sp,-1724
80009290:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009294:	c2 38       	rjmp	800092da <_vfprintf_r+0x114e>
80009296:	d7 03       	nop
80009298:	fa c8 f9 50 	sub	r8,sp,-1712
8000929c:	1a d8       	st.w	--sp,r8
8000929e:	fa c8 fa b8 	sub	r8,sp,-1352
800092a2:	1a d8       	st.w	--sp,r8
800092a4:	fa c8 fb b4 	sub	r8,sp,-1100
800092a8:	1a d8       	st.w	--sp,r8
800092aa:	fa c8 f9 40 	sub	r8,sp,-1728
800092ae:	fa c9 ff b4 	sub	r9,sp,-76
800092b2:	04 9a       	mov	r10,r2
800092b4:	0c 9b       	mov	r11,r6
800092b6:	08 9c       	mov	r12,r4
800092b8:	fe b0 f5 d2 	rcall	80007e5c <get_arg>
800092bc:	2f dd       	sub	sp,-12
800092be:	f8 e8 00 00 	ld.d	r8,r12[0]
800092c2:	fa e9 00 00 	st.d	sp[0],r8
800092c6:	c2 e8       	rjmp	80009322 <_vfprintf_r+0x1196>
800092c8:	ee ca ff ff 	sub	r10,r7,-1
800092cc:	10 37       	cp.w	r7,r8
800092ce:	c0 b4       	brge	800092e4 <_vfprintf_r+0x1158>
800092d0:	fa c8 f9 44 	sub	r8,sp,-1724
800092d4:	14 97       	mov	r7,r10
800092d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800092da:	ec ea fd 88 	ld.d	r10,r6[-632]
800092de:	fa eb 00 00 	st.d	sp[0],r10
800092e2:	c2 08       	rjmp	80009322 <_vfprintf_r+0x1196>
800092e4:	41 09       	lddsp	r9,sp[0x40]
800092e6:	59 f8       	cp.w	r8,31
800092e8:	e0 89 00 16 	brgt	80009314 <_vfprintf_r+0x1188>
800092ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800092f0:	f2 cb ff f8 	sub	r11,r9,-8
800092f4:	fa e7 00 00 	st.d	sp[0],r6
800092f8:	51 0b       	stdsp	sp[0x40],r11
800092fa:	fa c6 f9 44 	sub	r6,sp,-1724
800092fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009302:	fa e6 00 00 	ld.d	r6,sp[0]
80009306:	f2 e7 fd 88 	st.d	r9[-632],r6
8000930a:	2f f8       	sub	r8,-1
8000930c:	14 97       	mov	r7,r10
8000930e:	fb 48 06 b4 	st.w	sp[1716],r8
80009312:	c0 88       	rjmp	80009322 <_vfprintf_r+0x1196>
80009314:	f2 e6 00 00 	ld.d	r6,r9[0]
80009318:	2f 89       	sub	r9,-8
8000931a:	fa e7 00 00 	st.d	sp[0],r6
8000931e:	51 09       	stdsp	sp[0x40],r9
80009320:	14 97       	mov	r7,r10
80009322:	30 18       	mov	r8,1
80009324:	e0 8f 01 d0 	bral	800096c4 <_vfprintf_r+0x1538>
80009328:	ed b5 00 04 	bld	r5,0x4
8000932c:	c1 61       	brne	80009358 <_vfprintf_r+0x11cc>
8000932e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009332:	40 3e       	lddsp	lr,sp[0xc]
80009334:	58 0e       	cp.w	lr,0
80009336:	c0 80       	breq	80009346 <_vfprintf_r+0x11ba>
80009338:	10 36       	cp.w	r6,r8
8000933a:	c6 74       	brge	80009408 <_vfprintf_r+0x127c>
8000933c:	fa cc f9 44 	sub	r12,sp,-1724
80009340:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009344:	c8 08       	rjmp	80009444 <_vfprintf_r+0x12b8>
80009346:	ee ca ff ff 	sub	r10,r7,-1
8000934a:	10 37       	cp.w	r7,r8
8000934c:	c7 f4       	brge	8000944a <_vfprintf_r+0x12be>
8000934e:	fa cb f9 44 	sub	r11,sp,-1724
80009352:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009356:	c7 68       	rjmp	80009442 <_vfprintf_r+0x12b6>
80009358:	ed b5 00 06 	bld	r5,0x6
8000935c:	c4 a1       	brne	800093f0 <_vfprintf_r+0x1264>
8000935e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009362:	40 3c       	lddsp	r12,sp[0xc]
80009364:	58 0c       	cp.w	r12,0
80009366:	c1 d0       	breq	800093a0 <_vfprintf_r+0x1214>
80009368:	10 36       	cp.w	r6,r8
8000936a:	c0 64       	brge	80009376 <_vfprintf_r+0x11ea>
8000936c:	fa cb f9 44 	sub	r11,sp,-1724
80009370:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009374:	c1 f8       	rjmp	800093b2 <_vfprintf_r+0x1226>
80009376:	fa c8 f9 50 	sub	r8,sp,-1712
8000937a:	1a d8       	st.w	--sp,r8
8000937c:	fa c8 fa b8 	sub	r8,sp,-1352
80009380:	1a d8       	st.w	--sp,r8
80009382:	fa c8 fb b4 	sub	r8,sp,-1100
80009386:	1a d8       	st.w	--sp,r8
80009388:	fa c8 f9 40 	sub	r8,sp,-1728
8000938c:	fa c9 ff b4 	sub	r9,sp,-76
80009390:	04 9a       	mov	r10,r2
80009392:	0c 9b       	mov	r11,r6
80009394:	08 9c       	mov	r12,r4
80009396:	fe b0 f5 63 	rcall	80007e5c <get_arg>
8000939a:	2f dd       	sub	sp,-12
8000939c:	98 18       	ld.sh	r8,r12[0x2]
8000939e:	c2 68       	rjmp	800093ea <_vfprintf_r+0x125e>
800093a0:	ee ca ff ff 	sub	r10,r7,-1
800093a4:	10 37       	cp.w	r7,r8
800093a6:	c0 94       	brge	800093b8 <_vfprintf_r+0x122c>
800093a8:	fa c9 f9 44 	sub	r9,sp,-1724
800093ac:	14 97       	mov	r7,r10
800093ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800093b6:	c1 a8       	rjmp	800093ea <_vfprintf_r+0x125e>
800093b8:	41 09       	lddsp	r9,sp[0x40]
800093ba:	59 f8       	cp.w	r8,31
800093bc:	e0 89 00 13 	brgt	800093e2 <_vfprintf_r+0x1256>
800093c0:	f2 cb ff fc 	sub	r11,r9,-4
800093c4:	51 0b       	stdsp	sp[0x40],r11
800093c6:	72 09       	ld.w	r9,r9[0x0]
800093c8:	fa c6 f9 44 	sub	r6,sp,-1724
800093cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800093d0:	2f f8       	sub	r8,-1
800093d2:	f7 49 fd 88 	st.w	r11[-632],r9
800093d6:	fb 48 06 b4 	st.w	sp[1716],r8
800093da:	14 97       	mov	r7,r10
800093dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800093e0:	c0 58       	rjmp	800093ea <_vfprintf_r+0x125e>
800093e2:	92 18       	ld.sh	r8,r9[0x2]
800093e4:	14 97       	mov	r7,r10
800093e6:	2f c9       	sub	r9,-4
800093e8:	51 09       	stdsp	sp[0x40],r9
800093ea:	5c 78       	castu.h	r8
800093ec:	50 18       	stdsp	sp[0x4],r8
800093ee:	c4 68       	rjmp	8000947a <_vfprintf_r+0x12ee>
800093f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093f4:	40 3c       	lddsp	r12,sp[0xc]
800093f6:	58 0c       	cp.w	r12,0
800093f8:	c1 d0       	breq	80009432 <_vfprintf_r+0x12a6>
800093fa:	10 36       	cp.w	r6,r8
800093fc:	c0 64       	brge	80009408 <_vfprintf_r+0x127c>
800093fe:	fa cb f9 44 	sub	r11,sp,-1724
80009402:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009406:	c1 f8       	rjmp	80009444 <_vfprintf_r+0x12b8>
80009408:	fa c8 f9 50 	sub	r8,sp,-1712
8000940c:	1a d8       	st.w	--sp,r8
8000940e:	fa c8 fa b8 	sub	r8,sp,-1352
80009412:	0c 9b       	mov	r11,r6
80009414:	1a d8       	st.w	--sp,r8
80009416:	fa c8 fb b4 	sub	r8,sp,-1100
8000941a:	04 9a       	mov	r10,r2
8000941c:	1a d8       	st.w	--sp,r8
8000941e:	08 9c       	mov	r12,r4
80009420:	fa c8 f9 40 	sub	r8,sp,-1728
80009424:	fa c9 ff b4 	sub	r9,sp,-76
80009428:	fe b0 f5 1a 	rcall	80007e5c <get_arg>
8000942c:	2f dd       	sub	sp,-12
8000942e:	78 0b       	ld.w	r11,r12[0x0]
80009430:	c2 48       	rjmp	80009478 <_vfprintf_r+0x12ec>
80009432:	ee ca ff ff 	sub	r10,r7,-1
80009436:	10 37       	cp.w	r7,r8
80009438:	c0 94       	brge	8000944a <_vfprintf_r+0x12be>
8000943a:	fa c9 f9 44 	sub	r9,sp,-1724
8000943e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009442:	14 97       	mov	r7,r10
80009444:	ec fb fd 88 	ld.w	r11,r6[-632]
80009448:	c1 88       	rjmp	80009478 <_vfprintf_r+0x12ec>
8000944a:	41 09       	lddsp	r9,sp[0x40]
8000944c:	59 f8       	cp.w	r8,31
8000944e:	e0 89 00 11 	brgt	80009470 <_vfprintf_r+0x12e4>
80009452:	f2 cb ff fc 	sub	r11,r9,-4
80009456:	51 0b       	stdsp	sp[0x40],r11
80009458:	fa c6 f9 44 	sub	r6,sp,-1724
8000945c:	72 0b       	ld.w	r11,r9[0x0]
8000945e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009462:	f3 4b fd 88 	st.w	r9[-632],r11
80009466:	2f f8       	sub	r8,-1
80009468:	14 97       	mov	r7,r10
8000946a:	fb 48 06 b4 	st.w	sp[1716],r8
8000946e:	c0 58       	rjmp	80009478 <_vfprintf_r+0x12ec>
80009470:	72 0b       	ld.w	r11,r9[0x0]
80009472:	14 97       	mov	r7,r10
80009474:	2f c9       	sub	r9,-4
80009476:	51 09       	stdsp	sp[0x40],r9
80009478:	50 1b       	stdsp	sp[0x4],r11
8000947a:	30 0e       	mov	lr,0
8000947c:	30 18       	mov	r8,1
8000947e:	50 0e       	stdsp	sp[0x0],lr
80009480:	c2 29       	rjmp	800096c4 <_vfprintf_r+0x1538>
80009482:	50 a7       	stdsp	sp[0x28],r7
80009484:	50 80       	stdsp	sp[0x20],r0
80009486:	0c 97       	mov	r7,r6
80009488:	04 94       	mov	r4,r2
8000948a:	06 96       	mov	r6,r3
8000948c:	02 92       	mov	r2,r1
8000948e:	fe cc b4 be 	sub	r12,pc,-19266
80009492:	40 93       	lddsp	r3,sp[0x24]
80009494:	10 90       	mov	r0,r8
80009496:	40 41       	lddsp	r1,sp[0x10]
80009498:	50 dc       	stdsp	sp[0x34],r12
8000949a:	ed b5 00 05 	bld	r5,0x5
8000949e:	c5 51       	brne	80009548 <_vfprintf_r+0x13bc>
800094a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094a4:	40 3b       	lddsp	r11,sp[0xc]
800094a6:	58 0b       	cp.w	r11,0
800094a8:	c2 20       	breq	800094ec <_vfprintf_r+0x1360>
800094aa:	10 36       	cp.w	r6,r8
800094ac:	c0 a4       	brge	800094c0 <_vfprintf_r+0x1334>
800094ae:	fa ca f9 44 	sub	r10,sp,-1724
800094b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800094b6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800094ba:	fa e9 00 00 	st.d	sp[0],r8
800094be:	cf 28       	rjmp	800096a2 <_vfprintf_r+0x1516>
800094c0:	fa c8 f9 50 	sub	r8,sp,-1712
800094c4:	1a d8       	st.w	--sp,r8
800094c6:	fa c8 fa b8 	sub	r8,sp,-1352
800094ca:	04 9a       	mov	r10,r2
800094cc:	1a d8       	st.w	--sp,r8
800094ce:	0c 9b       	mov	r11,r6
800094d0:	fa c8 fb b4 	sub	r8,sp,-1100
800094d4:	08 9c       	mov	r12,r4
800094d6:	1a d8       	st.w	--sp,r8
800094d8:	fa c8 f9 40 	sub	r8,sp,-1728
800094dc:	fa c9 ff b4 	sub	r9,sp,-76
800094e0:	fe b0 f4 be 	rcall	80007e5c <get_arg>
800094e4:	2f dd       	sub	sp,-12
800094e6:	f8 ea 00 00 	ld.d	r10,r12[0]
800094ea:	c0 c8       	rjmp	80009502 <_vfprintf_r+0x1376>
800094ec:	ee ca ff ff 	sub	r10,r7,-1
800094f0:	10 37       	cp.w	r7,r8
800094f2:	c0 b4       	brge	80009508 <_vfprintf_r+0x137c>
800094f4:	fa c9 f9 44 	sub	r9,sp,-1724
800094f8:	14 97       	mov	r7,r10
800094fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80009502:	fa eb 00 00 	st.d	sp[0],r10
80009506:	cc e8       	rjmp	800096a2 <_vfprintf_r+0x1516>
80009508:	41 09       	lddsp	r9,sp[0x40]
8000950a:	59 f8       	cp.w	r8,31
8000950c:	e0 89 00 16 	brgt	80009538 <_vfprintf_r+0x13ac>
80009510:	f2 e6 00 00 	ld.d	r6,r9[0]
80009514:	f2 cb ff f8 	sub	r11,r9,-8
80009518:	fa e7 00 00 	st.d	sp[0],r6
8000951c:	51 0b       	stdsp	sp[0x40],r11
8000951e:	fa c6 f9 44 	sub	r6,sp,-1724
80009522:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009526:	fa e6 00 00 	ld.d	r6,sp[0]
8000952a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000952e:	2f f8       	sub	r8,-1
80009530:	14 97       	mov	r7,r10
80009532:	fb 48 06 b4 	st.w	sp[1716],r8
80009536:	cb 68       	rjmp	800096a2 <_vfprintf_r+0x1516>
80009538:	f2 e6 00 00 	ld.d	r6,r9[0]
8000953c:	2f 89       	sub	r9,-8
8000953e:	fa e7 00 00 	st.d	sp[0],r6
80009542:	51 09       	stdsp	sp[0x40],r9
80009544:	14 97       	mov	r7,r10
80009546:	ca e8       	rjmp	800096a2 <_vfprintf_r+0x1516>
80009548:	ed b5 00 04 	bld	r5,0x4
8000954c:	c1 71       	brne	8000957a <_vfprintf_r+0x13ee>
8000954e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009552:	40 3e       	lddsp	lr,sp[0xc]
80009554:	58 0e       	cp.w	lr,0
80009556:	c0 80       	breq	80009566 <_vfprintf_r+0x13da>
80009558:	10 36       	cp.w	r6,r8
8000955a:	c6 94       	brge	8000962c <_vfprintf_r+0x14a0>
8000955c:	fa cc f9 44 	sub	r12,sp,-1724
80009560:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009564:	c8 28       	rjmp	80009668 <_vfprintf_r+0x14dc>
80009566:	ee ca ff ff 	sub	r10,r7,-1
8000956a:	10 37       	cp.w	r7,r8
8000956c:	e0 84 00 81 	brge	8000966e <_vfprintf_r+0x14e2>
80009570:	fa cb f9 44 	sub	r11,sp,-1724
80009574:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009578:	c7 78       	rjmp	80009666 <_vfprintf_r+0x14da>
8000957a:	ed b5 00 06 	bld	r5,0x6
8000957e:	c4 b1       	brne	80009614 <_vfprintf_r+0x1488>
80009580:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009584:	40 3c       	lddsp	r12,sp[0xc]
80009586:	58 0c       	cp.w	r12,0
80009588:	c1 d0       	breq	800095c2 <_vfprintf_r+0x1436>
8000958a:	10 36       	cp.w	r6,r8
8000958c:	c0 64       	brge	80009598 <_vfprintf_r+0x140c>
8000958e:	fa cb f9 44 	sub	r11,sp,-1724
80009592:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009596:	c1 f8       	rjmp	800095d4 <_vfprintf_r+0x1448>
80009598:	fa c8 f9 50 	sub	r8,sp,-1712
8000959c:	1a d8       	st.w	--sp,r8
8000959e:	fa c8 fa b8 	sub	r8,sp,-1352
800095a2:	1a d8       	st.w	--sp,r8
800095a4:	fa c8 fb b4 	sub	r8,sp,-1100
800095a8:	1a d8       	st.w	--sp,r8
800095aa:	fa c8 f9 40 	sub	r8,sp,-1728
800095ae:	fa c9 ff b4 	sub	r9,sp,-76
800095b2:	04 9a       	mov	r10,r2
800095b4:	0c 9b       	mov	r11,r6
800095b6:	08 9c       	mov	r12,r4
800095b8:	fe b0 f4 52 	rcall	80007e5c <get_arg>
800095bc:	2f dd       	sub	sp,-12
800095be:	98 18       	ld.sh	r8,r12[0x2]
800095c0:	c2 78       	rjmp	8000960e <_vfprintf_r+0x1482>
800095c2:	ee ca ff ff 	sub	r10,r7,-1
800095c6:	10 37       	cp.w	r7,r8
800095c8:	c0 a4       	brge	800095dc <_vfprintf_r+0x1450>
800095ca:	fa c9 f9 44 	sub	r9,sp,-1724
800095ce:	14 97       	mov	r7,r10
800095d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095d4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800095d8:	c1 b8       	rjmp	8000960e <_vfprintf_r+0x1482>
800095da:	d7 03       	nop
800095dc:	41 09       	lddsp	r9,sp[0x40]
800095de:	59 f8       	cp.w	r8,31
800095e0:	e0 89 00 13 	brgt	80009606 <_vfprintf_r+0x147a>
800095e4:	f2 cb ff fc 	sub	r11,r9,-4
800095e8:	51 0b       	stdsp	sp[0x40],r11
800095ea:	72 09       	ld.w	r9,r9[0x0]
800095ec:	fa c6 f9 44 	sub	r6,sp,-1724
800095f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800095f4:	2f f8       	sub	r8,-1
800095f6:	f7 49 fd 88 	st.w	r11[-632],r9
800095fa:	fb 48 06 b4 	st.w	sp[1716],r8
800095fe:	14 97       	mov	r7,r10
80009600:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009604:	c0 58       	rjmp	8000960e <_vfprintf_r+0x1482>
80009606:	92 18       	ld.sh	r8,r9[0x2]
80009608:	14 97       	mov	r7,r10
8000960a:	2f c9       	sub	r9,-4
8000960c:	51 09       	stdsp	sp[0x40],r9
8000960e:	5c 78       	castu.h	r8
80009610:	50 18       	stdsp	sp[0x4],r8
80009612:	c4 68       	rjmp	8000969e <_vfprintf_r+0x1512>
80009614:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009618:	40 3c       	lddsp	r12,sp[0xc]
8000961a:	58 0c       	cp.w	r12,0
8000961c:	c1 d0       	breq	80009656 <_vfprintf_r+0x14ca>
8000961e:	10 36       	cp.w	r6,r8
80009620:	c0 64       	brge	8000962c <_vfprintf_r+0x14a0>
80009622:	fa cb f9 44 	sub	r11,sp,-1724
80009626:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000962a:	c1 f8       	rjmp	80009668 <_vfprintf_r+0x14dc>
8000962c:	fa c8 f9 50 	sub	r8,sp,-1712
80009630:	1a d8       	st.w	--sp,r8
80009632:	fa c8 fa b8 	sub	r8,sp,-1352
80009636:	0c 9b       	mov	r11,r6
80009638:	1a d8       	st.w	--sp,r8
8000963a:	fa c8 fb b4 	sub	r8,sp,-1100
8000963e:	04 9a       	mov	r10,r2
80009640:	1a d8       	st.w	--sp,r8
80009642:	08 9c       	mov	r12,r4
80009644:	fa c8 f9 40 	sub	r8,sp,-1728
80009648:	fa c9 ff b4 	sub	r9,sp,-76
8000964c:	fe b0 f4 08 	rcall	80007e5c <get_arg>
80009650:	2f dd       	sub	sp,-12
80009652:	78 0b       	ld.w	r11,r12[0x0]
80009654:	c2 48       	rjmp	8000969c <_vfprintf_r+0x1510>
80009656:	ee ca ff ff 	sub	r10,r7,-1
8000965a:	10 37       	cp.w	r7,r8
8000965c:	c0 94       	brge	8000966e <_vfprintf_r+0x14e2>
8000965e:	fa c9 f9 44 	sub	r9,sp,-1724
80009662:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009666:	14 97       	mov	r7,r10
80009668:	ec fb fd 88 	ld.w	r11,r6[-632]
8000966c:	c1 88       	rjmp	8000969c <_vfprintf_r+0x1510>
8000966e:	41 09       	lddsp	r9,sp[0x40]
80009670:	59 f8       	cp.w	r8,31
80009672:	e0 89 00 11 	brgt	80009694 <_vfprintf_r+0x1508>
80009676:	f2 cb ff fc 	sub	r11,r9,-4
8000967a:	51 0b       	stdsp	sp[0x40],r11
8000967c:	fa c6 f9 44 	sub	r6,sp,-1724
80009680:	72 0b       	ld.w	r11,r9[0x0]
80009682:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009686:	f3 4b fd 88 	st.w	r9[-632],r11
8000968a:	2f f8       	sub	r8,-1
8000968c:	14 97       	mov	r7,r10
8000968e:	fb 48 06 b4 	st.w	sp[1716],r8
80009692:	c0 58       	rjmp	8000969c <_vfprintf_r+0x1510>
80009694:	72 0b       	ld.w	r11,r9[0x0]
80009696:	14 97       	mov	r7,r10
80009698:	2f c9       	sub	r9,-4
8000969a:	51 09       	stdsp	sp[0x40],r9
8000969c:	50 1b       	stdsp	sp[0x4],r11
8000969e:	30 0e       	mov	lr,0
800096a0:	50 0e       	stdsp	sp[0x0],lr
800096a2:	40 08       	lddsp	r8,sp[0x0]
800096a4:	40 1c       	lddsp	r12,sp[0x4]
800096a6:	18 48       	or	r8,r12
800096a8:	5f 19       	srne	r9
800096aa:	0a 98       	mov	r8,r5
800096ac:	eb e9 00 09 	and	r9,r5,r9
800096b0:	a1 b8       	sbr	r8,0x1
800096b2:	58 09       	cp.w	r9,0
800096b4:	c0 70       	breq	800096c2 <_vfprintf_r+0x1536>
800096b6:	10 95       	mov	r5,r8
800096b8:	fb 60 06 b9 	st.b	sp[1721],r0
800096bc:	33 08       	mov	r8,48
800096be:	fb 68 06 b8 	st.b	sp[1720],r8
800096c2:	30 28       	mov	r8,2
800096c4:	30 09       	mov	r9,0
800096c6:	fb 69 06 bb 	st.b	sp[1723],r9
800096ca:	0a 99       	mov	r9,r5
800096cc:	a7 d9       	cbr	r9,0x7
800096ce:	40 2b       	lddsp	r11,sp[0x8]
800096d0:	40 16       	lddsp	r6,sp[0x4]
800096d2:	58 0b       	cp.w	r11,0
800096d4:	5f 1a       	srne	r10
800096d6:	f2 05 17 40 	movge	r5,r9
800096da:	fa c2 f9 78 	sub	r2,sp,-1672
800096de:	40 09       	lddsp	r9,sp[0x0]
800096e0:	0c 49       	or	r9,r6
800096e2:	5f 19       	srne	r9
800096e4:	f5 e9 10 09 	or	r9,r10,r9
800096e8:	c5 c0       	breq	800097a0 <_vfprintf_r+0x1614>
800096ea:	30 19       	mov	r9,1
800096ec:	f2 08 18 00 	cp.b	r8,r9
800096f0:	c0 60       	breq	800096fc <_vfprintf_r+0x1570>
800096f2:	30 29       	mov	r9,2
800096f4:	f2 08 18 00 	cp.b	r8,r9
800096f8:	c0 41       	brne	80009700 <_vfprintf_r+0x1574>
800096fa:	c3 c8       	rjmp	80009772 <_vfprintf_r+0x15e6>
800096fc:	04 96       	mov	r6,r2
800096fe:	c3 08       	rjmp	8000975e <_vfprintf_r+0x15d2>
80009700:	04 96       	mov	r6,r2
80009702:	fa e8 00 00 	ld.d	r8,sp[0]
80009706:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000970a:	2d 0a       	sub	r10,-48
8000970c:	0c fa       	st.b	--r6,r10
8000970e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009712:	f2 0c 16 03 	lsr	r12,r9,0x3
80009716:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000971a:	18 99       	mov	r9,r12
8000971c:	16 98       	mov	r8,r11
8000971e:	58 08       	cp.w	r8,0
80009720:	5c 29       	cpc	r9
80009722:	cf 21       	brne	80009706 <_vfprintf_r+0x157a>
80009724:	fa e9 00 00 	st.d	sp[0],r8
80009728:	ed b5 00 00 	bld	r5,0x0
8000972c:	c4 51       	brne	800097b6 <_vfprintf_r+0x162a>
8000972e:	33 09       	mov	r9,48
80009730:	f2 0a 18 00 	cp.b	r10,r9
80009734:	c4 10       	breq	800097b6 <_vfprintf_r+0x162a>
80009736:	0c f9       	st.b	--r6,r9
80009738:	c3 f8       	rjmp	800097b6 <_vfprintf_r+0x162a>
8000973a:	fa ea 00 00 	ld.d	r10,sp[0]
8000973e:	30 a8       	mov	r8,10
80009740:	30 09       	mov	r9,0
80009742:	e0 a0 1a 19 	rcall	8000cb74 <__avr32_umod64>
80009746:	30 a8       	mov	r8,10
80009748:	2d 0a       	sub	r10,-48
8000974a:	30 09       	mov	r9,0
8000974c:	ac 8a       	st.b	r6[0x0],r10
8000974e:	fa ea 00 00 	ld.d	r10,sp[0]
80009752:	e0 a0 18 df 	rcall	8000c910 <__avr32_udiv64>
80009756:	16 99       	mov	r9,r11
80009758:	14 98       	mov	r8,r10
8000975a:	fa e9 00 00 	st.d	sp[0],r8
8000975e:	20 16       	sub	r6,1
80009760:	fa ea 00 00 	ld.d	r10,sp[0]
80009764:	58 9a       	cp.w	r10,9
80009766:	5c 2b       	cpc	r11
80009768:	fe 9b ff e9 	brhi	8000973a <_vfprintf_r+0x15ae>
8000976c:	1b f8       	ld.ub	r8,sp[0x7]
8000976e:	2d 08       	sub	r8,-48
80009770:	c2 08       	rjmp	800097b0 <_vfprintf_r+0x1624>
80009772:	04 96       	mov	r6,r2
80009774:	fa e8 00 00 	ld.d	r8,sp[0]
80009778:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000977c:	40 de       	lddsp	lr,sp[0x34]
8000977e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009782:	0c fa       	st.b	--r6,r10
80009784:	f2 0b 16 04 	lsr	r11,r9,0x4
80009788:	f0 0a 16 04 	lsr	r10,r8,0x4
8000978c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009790:	16 99       	mov	r9,r11
80009792:	14 98       	mov	r8,r10
80009794:	58 08       	cp.w	r8,0
80009796:	5c 29       	cpc	r9
80009798:	cf 01       	brne	80009778 <_vfprintf_r+0x15ec>
8000979a:	fa e9 00 00 	st.d	sp[0],r8
8000979e:	c0 c8       	rjmp	800097b6 <_vfprintf_r+0x162a>
800097a0:	58 08       	cp.w	r8,0
800097a2:	c0 91       	brne	800097b4 <_vfprintf_r+0x1628>
800097a4:	ed b5 00 00 	bld	r5,0x0
800097a8:	c0 61       	brne	800097b4 <_vfprintf_r+0x1628>
800097aa:	fa c6 f9 79 	sub	r6,sp,-1671
800097ae:	33 08       	mov	r8,48
800097b0:	ac 88       	st.b	r6[0x0],r8
800097b2:	c0 28       	rjmp	800097b6 <_vfprintf_r+0x162a>
800097b4:	04 96       	mov	r6,r2
800097b6:	0c 12       	sub	r2,r6
800097b8:	c1 c8       	rjmp	800097f0 <_vfprintf_r+0x1664>
800097ba:	50 a7       	stdsp	sp[0x28],r7
800097bc:	50 80       	stdsp	sp[0x20],r0
800097be:	40 93       	lddsp	r3,sp[0x24]
800097c0:	0c 97       	mov	r7,r6
800097c2:	10 90       	mov	r0,r8
800097c4:	04 94       	mov	r4,r2
800097c6:	40 41       	lddsp	r1,sp[0x10]
800097c8:	58 08       	cp.w	r8,0
800097ca:	e0 80 04 4f 	breq	8000a068 <_vfprintf_r+0x1edc>
800097ce:	fb 68 06 60 	st.b	sp[1632],r8
800097d2:	30 0c       	mov	r12,0
800097d4:	30 08       	mov	r8,0
800097d6:	30 12       	mov	r2,1
800097d8:	fb 68 06 bb 	st.b	sp[1723],r8
800097dc:	50 2c       	stdsp	sp[0x8],r12
800097de:	fa c6 f9 a0 	sub	r6,sp,-1632
800097e2:	c0 78       	rjmp	800097f0 <_vfprintf_r+0x1664>
800097e4:	30 0b       	mov	r11,0
800097e6:	50 2b       	stdsp	sp[0x8],r11
800097e8:	c0 48       	rjmp	800097f0 <_vfprintf_r+0x1664>
800097ea:	40 22       	lddsp	r2,sp[0x8]
800097ec:	30 0a       	mov	r10,0
800097ee:	50 2a       	stdsp	sp[0x8],r10
800097f0:	40 29       	lddsp	r9,sp[0x8]
800097f2:	e4 09 0c 49 	max	r9,r2,r9
800097f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800097fa:	50 39       	stdsp	sp[0xc],r9
800097fc:	0a 9e       	mov	lr,r5
800097fe:	30 09       	mov	r9,0
80009800:	e2 1e 00 02 	andl	lr,0x2,COH
80009804:	f2 08 18 00 	cp.b	r8,r9
80009808:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000980c:	f7 b8 01 ff 	subne	r8,-1
80009810:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009814:	0a 9b       	mov	r11,r5
80009816:	58 0e       	cp.w	lr,0
80009818:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000981c:	f7 bc 01 fe 	subne	r12,-2
80009820:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009824:	e2 1b 00 84 	andl	r11,0x84,COH
80009828:	50 fe       	stdsp	sp[0x3c],lr
8000982a:	50 9b       	stdsp	sp[0x24],r11
8000982c:	c4 71       	brne	800098ba <_vfprintf_r+0x172e>
8000982e:	40 8a       	lddsp	r10,sp[0x20]
80009830:	40 39       	lddsp	r9,sp[0xc]
80009832:	12 1a       	sub	r10,r9
80009834:	50 4a       	stdsp	sp[0x10],r10
80009836:	58 0a       	cp.w	r10,0
80009838:	e0 89 00 20 	brgt	80009878 <_vfprintf_r+0x16ec>
8000983c:	c3 f8       	rjmp	800098ba <_vfprintf_r+0x172e>
8000983e:	2f 09       	sub	r9,-16
80009840:	2f f8       	sub	r8,-1
80009842:	fe ce b8 5a 	sub	lr,pc,-18342
80009846:	31 0c       	mov	r12,16
80009848:	fb 49 06 90 	st.w	sp[1680],r9
8000984c:	87 0e       	st.w	r3[0x0],lr
8000984e:	87 1c       	st.w	r3[0x4],r12
80009850:	fb 48 06 8c 	st.w	sp[1676],r8
80009854:	58 78       	cp.w	r8,7
80009856:	e0 89 00 04 	brgt	8000985e <_vfprintf_r+0x16d2>
8000985a:	2f 83       	sub	r3,-8
8000985c:	c0 b8       	rjmp	80009872 <_vfprintf_r+0x16e6>
8000985e:	fa ca f9 78 	sub	r10,sp,-1672
80009862:	02 9b       	mov	r11,r1
80009864:	08 9c       	mov	r12,r4
80009866:	fe b0 f4 85 	rcall	80008170 <__sprint_r>
8000986a:	e0 81 04 10 	brne	8000a08a <_vfprintf_r+0x1efe>
8000986e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009872:	40 4b       	lddsp	r11,sp[0x10]
80009874:	21 0b       	sub	r11,16
80009876:	50 4b       	stdsp	sp[0x10],r11
80009878:	fa f9 06 90 	ld.w	r9,sp[1680]
8000987c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009880:	fe ca b8 98 	sub	r10,pc,-18280
80009884:	40 4e       	lddsp	lr,sp[0x10]
80009886:	59 0e       	cp.w	lr,16
80009888:	fe 99 ff db 	brgt	8000983e <_vfprintf_r+0x16b2>
8000988c:	1c 09       	add	r9,lr
8000988e:	2f f8       	sub	r8,-1
80009890:	87 0a       	st.w	r3[0x0],r10
80009892:	fb 49 06 90 	st.w	sp[1680],r9
80009896:	87 1e       	st.w	r3[0x4],lr
80009898:	fb 48 06 8c 	st.w	sp[1676],r8
8000989c:	58 78       	cp.w	r8,7
8000989e:	e0 89 00 04 	brgt	800098a6 <_vfprintf_r+0x171a>
800098a2:	2f 83       	sub	r3,-8
800098a4:	c0 b8       	rjmp	800098ba <_vfprintf_r+0x172e>
800098a6:	fa ca f9 78 	sub	r10,sp,-1672
800098aa:	02 9b       	mov	r11,r1
800098ac:	08 9c       	mov	r12,r4
800098ae:	fe b0 f4 61 	rcall	80008170 <__sprint_r>
800098b2:	e0 81 03 ec 	brne	8000a08a <_vfprintf_r+0x1efe>
800098b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800098ba:	30 09       	mov	r9,0
800098bc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800098c0:	f2 08 18 00 	cp.b	r8,r9
800098c4:	c1 f0       	breq	80009902 <_vfprintf_r+0x1776>
800098c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800098ca:	fa c9 f9 45 	sub	r9,sp,-1723
800098ce:	2f f8       	sub	r8,-1
800098d0:	87 09       	st.w	r3[0x0],r9
800098d2:	fb 48 06 90 	st.w	sp[1680],r8
800098d6:	30 19       	mov	r9,1
800098d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098dc:	87 19       	st.w	r3[0x4],r9
800098de:	2f f8       	sub	r8,-1
800098e0:	fb 48 06 8c 	st.w	sp[1676],r8
800098e4:	58 78       	cp.w	r8,7
800098e6:	e0 89 00 04 	brgt	800098ee <_vfprintf_r+0x1762>
800098ea:	2f 83       	sub	r3,-8
800098ec:	c0 b8       	rjmp	80009902 <_vfprintf_r+0x1776>
800098ee:	fa ca f9 78 	sub	r10,sp,-1672
800098f2:	02 9b       	mov	r11,r1
800098f4:	08 9c       	mov	r12,r4
800098f6:	fe b0 f4 3d 	rcall	80008170 <__sprint_r>
800098fa:	e0 81 03 c8 	brne	8000a08a <_vfprintf_r+0x1efe>
800098fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009902:	40 fc       	lddsp	r12,sp[0x3c]
80009904:	58 0c       	cp.w	r12,0
80009906:	c1 f0       	breq	80009944 <_vfprintf_r+0x17b8>
80009908:	fa f8 06 90 	ld.w	r8,sp[1680]
8000990c:	fa c9 f9 48 	sub	r9,sp,-1720
80009910:	2f e8       	sub	r8,-2
80009912:	87 09       	st.w	r3[0x0],r9
80009914:	fb 48 06 90 	st.w	sp[1680],r8
80009918:	30 29       	mov	r9,2
8000991a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000991e:	87 19       	st.w	r3[0x4],r9
80009920:	2f f8       	sub	r8,-1
80009922:	fb 48 06 8c 	st.w	sp[1676],r8
80009926:	58 78       	cp.w	r8,7
80009928:	e0 89 00 04 	brgt	80009930 <_vfprintf_r+0x17a4>
8000992c:	2f 83       	sub	r3,-8
8000992e:	c0 b8       	rjmp	80009944 <_vfprintf_r+0x17b8>
80009930:	fa ca f9 78 	sub	r10,sp,-1672
80009934:	02 9b       	mov	r11,r1
80009936:	08 9c       	mov	r12,r4
80009938:	fe b0 f4 1c 	rcall	80008170 <__sprint_r>
8000993c:	e0 81 03 a7 	brne	8000a08a <_vfprintf_r+0x1efe>
80009940:	fa c3 f9 e0 	sub	r3,sp,-1568
80009944:	40 9b       	lddsp	r11,sp[0x24]
80009946:	e0 4b 00 80 	cp.w	r11,128
8000994a:	c4 71       	brne	800099d8 <_vfprintf_r+0x184c>
8000994c:	40 8a       	lddsp	r10,sp[0x20]
8000994e:	40 39       	lddsp	r9,sp[0xc]
80009950:	12 1a       	sub	r10,r9
80009952:	50 4a       	stdsp	sp[0x10],r10
80009954:	58 0a       	cp.w	r10,0
80009956:	e0 89 00 20 	brgt	80009996 <_vfprintf_r+0x180a>
8000995a:	c3 f8       	rjmp	800099d8 <_vfprintf_r+0x184c>
8000995c:	2f 09       	sub	r9,-16
8000995e:	2f f8       	sub	r8,-1
80009960:	fe ce b9 68 	sub	lr,pc,-18072
80009964:	31 0c       	mov	r12,16
80009966:	fb 49 06 90 	st.w	sp[1680],r9
8000996a:	87 0e       	st.w	r3[0x0],lr
8000996c:	87 1c       	st.w	r3[0x4],r12
8000996e:	fb 48 06 8c 	st.w	sp[1676],r8
80009972:	58 78       	cp.w	r8,7
80009974:	e0 89 00 04 	brgt	8000997c <_vfprintf_r+0x17f0>
80009978:	2f 83       	sub	r3,-8
8000997a:	c0 b8       	rjmp	80009990 <_vfprintf_r+0x1804>
8000997c:	fa ca f9 78 	sub	r10,sp,-1672
80009980:	02 9b       	mov	r11,r1
80009982:	08 9c       	mov	r12,r4
80009984:	fe b0 f3 f6 	rcall	80008170 <__sprint_r>
80009988:	e0 81 03 81 	brne	8000a08a <_vfprintf_r+0x1efe>
8000998c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009990:	40 4b       	lddsp	r11,sp[0x10]
80009992:	21 0b       	sub	r11,16
80009994:	50 4b       	stdsp	sp[0x10],r11
80009996:	fa f9 06 90 	ld.w	r9,sp[1680]
8000999a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000999e:	fe ca b9 a6 	sub	r10,pc,-18010
800099a2:	40 4e       	lddsp	lr,sp[0x10]
800099a4:	59 0e       	cp.w	lr,16
800099a6:	fe 99 ff db 	brgt	8000995c <_vfprintf_r+0x17d0>
800099aa:	1c 09       	add	r9,lr
800099ac:	2f f8       	sub	r8,-1
800099ae:	87 0a       	st.w	r3[0x0],r10
800099b0:	fb 49 06 90 	st.w	sp[1680],r9
800099b4:	87 1e       	st.w	r3[0x4],lr
800099b6:	fb 48 06 8c 	st.w	sp[1676],r8
800099ba:	58 78       	cp.w	r8,7
800099bc:	e0 89 00 04 	brgt	800099c4 <_vfprintf_r+0x1838>
800099c0:	2f 83       	sub	r3,-8
800099c2:	c0 b8       	rjmp	800099d8 <_vfprintf_r+0x184c>
800099c4:	fa ca f9 78 	sub	r10,sp,-1672
800099c8:	02 9b       	mov	r11,r1
800099ca:	08 9c       	mov	r12,r4
800099cc:	fe b0 f3 d2 	rcall	80008170 <__sprint_r>
800099d0:	e0 81 03 5d 	brne	8000a08a <_vfprintf_r+0x1efe>
800099d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d8:	40 2c       	lddsp	r12,sp[0x8]
800099da:	04 1c       	sub	r12,r2
800099dc:	50 2c       	stdsp	sp[0x8],r12
800099de:	58 0c       	cp.w	r12,0
800099e0:	e0 89 00 20 	brgt	80009a20 <_vfprintf_r+0x1894>
800099e4:	c3 f8       	rjmp	80009a62 <_vfprintf_r+0x18d6>
800099e6:	2f 09       	sub	r9,-16
800099e8:	2f f8       	sub	r8,-1
800099ea:	fe cb b9 f2 	sub	r11,pc,-17934
800099ee:	31 0a       	mov	r10,16
800099f0:	fb 49 06 90 	st.w	sp[1680],r9
800099f4:	87 0b       	st.w	r3[0x0],r11
800099f6:	87 1a       	st.w	r3[0x4],r10
800099f8:	fb 48 06 8c 	st.w	sp[1676],r8
800099fc:	58 78       	cp.w	r8,7
800099fe:	e0 89 00 04 	brgt	80009a06 <_vfprintf_r+0x187a>
80009a02:	2f 83       	sub	r3,-8
80009a04:	c0 b8       	rjmp	80009a1a <_vfprintf_r+0x188e>
80009a06:	fa ca f9 78 	sub	r10,sp,-1672
80009a0a:	02 9b       	mov	r11,r1
80009a0c:	08 9c       	mov	r12,r4
80009a0e:	fe b0 f3 b1 	rcall	80008170 <__sprint_r>
80009a12:	e0 81 03 3c 	brne	8000a08a <_vfprintf_r+0x1efe>
80009a16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a1a:	40 29       	lddsp	r9,sp[0x8]
80009a1c:	21 09       	sub	r9,16
80009a1e:	50 29       	stdsp	sp[0x8],r9
80009a20:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a28:	fe ca ba 30 	sub	r10,pc,-17872
80009a2c:	40 2e       	lddsp	lr,sp[0x8]
80009a2e:	59 0e       	cp.w	lr,16
80009a30:	fe 99 ff db 	brgt	800099e6 <_vfprintf_r+0x185a>
80009a34:	1c 09       	add	r9,lr
80009a36:	2f f8       	sub	r8,-1
80009a38:	87 0a       	st.w	r3[0x0],r10
80009a3a:	fb 49 06 90 	st.w	sp[1680],r9
80009a3e:	87 1e       	st.w	r3[0x4],lr
80009a40:	fb 48 06 8c 	st.w	sp[1676],r8
80009a44:	58 78       	cp.w	r8,7
80009a46:	e0 89 00 04 	brgt	80009a4e <_vfprintf_r+0x18c2>
80009a4a:	2f 83       	sub	r3,-8
80009a4c:	c0 b8       	rjmp	80009a62 <_vfprintf_r+0x18d6>
80009a4e:	fa ca f9 78 	sub	r10,sp,-1672
80009a52:	02 9b       	mov	r11,r1
80009a54:	08 9c       	mov	r12,r4
80009a56:	fe b0 f3 8d 	rcall	80008170 <__sprint_r>
80009a5a:	e0 81 03 18 	brne	8000a08a <_vfprintf_r+0x1efe>
80009a5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a62:	ed b5 00 08 	bld	r5,0x8
80009a66:	c0 b0       	breq	80009a7c <_vfprintf_r+0x18f0>
80009a68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a6c:	87 12       	st.w	r3[0x4],r2
80009a6e:	87 06       	st.w	r3[0x0],r6
80009a70:	f0 02 00 02 	add	r2,r8,r2
80009a74:	fb 42 06 90 	st.w	sp[1680],r2
80009a78:	e0 8f 01 d4 	bral	80009e20 <_vfprintf_r+0x1c94>
80009a7c:	e0 40 00 65 	cp.w	r0,101
80009a80:	e0 8a 01 d6 	brle	80009e2c <_vfprintf_r+0x1ca0>
80009a84:	30 08       	mov	r8,0
80009a86:	30 09       	mov	r9,0
80009a88:	40 5b       	lddsp	r11,sp[0x14]
80009a8a:	40 7a       	lddsp	r10,sp[0x1c]
80009a8c:	e0 a0 15 3b 	rcall	8000c502 <__avr32_f64_cmp_eq>
80009a90:	c7 90       	breq	80009b82 <_vfprintf_r+0x19f6>
80009a92:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a96:	fe c9 ba b2 	sub	r9,pc,-17742
80009a9a:	2f f8       	sub	r8,-1
80009a9c:	87 09       	st.w	r3[0x0],r9
80009a9e:	fb 48 06 90 	st.w	sp[1680],r8
80009aa2:	30 19       	mov	r9,1
80009aa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aa8:	87 19       	st.w	r3[0x4],r9
80009aaa:	2f f8       	sub	r8,-1
80009aac:	fb 48 06 8c 	st.w	sp[1676],r8
80009ab0:	58 78       	cp.w	r8,7
80009ab2:	e0 89 00 05 	brgt	80009abc <_vfprintf_r+0x1930>
80009ab6:	2f 83       	sub	r3,-8
80009ab8:	c0 c8       	rjmp	80009ad0 <_vfprintf_r+0x1944>
80009aba:	d7 03       	nop
80009abc:	fa ca f9 78 	sub	r10,sp,-1672
80009ac0:	02 9b       	mov	r11,r1
80009ac2:	08 9c       	mov	r12,r4
80009ac4:	fe b0 f3 56 	rcall	80008170 <__sprint_r>
80009ac8:	e0 81 02 e1 	brne	8000a08a <_vfprintf_r+0x1efe>
80009acc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ad0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ad4:	40 6c       	lddsp	r12,sp[0x18]
80009ad6:	18 38       	cp.w	r8,r12
80009ad8:	c0 55       	brlt	80009ae2 <_vfprintf_r+0x1956>
80009ada:	ed b5 00 00 	bld	r5,0x0
80009ade:	e0 81 02 6b 	brne	80009fb4 <_vfprintf_r+0x1e28>
80009ae2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ae6:	2f f8       	sub	r8,-1
80009ae8:	40 cb       	lddsp	r11,sp[0x30]
80009aea:	fb 48 06 90 	st.w	sp[1680],r8
80009aee:	30 19       	mov	r9,1
80009af0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009af4:	87 0b       	st.w	r3[0x0],r11
80009af6:	2f f8       	sub	r8,-1
80009af8:	87 19       	st.w	r3[0x4],r9
80009afa:	fb 48 06 8c 	st.w	sp[1676],r8
80009afe:	58 78       	cp.w	r8,7
80009b00:	e0 89 00 04 	brgt	80009b08 <_vfprintf_r+0x197c>
80009b04:	2f 83       	sub	r3,-8
80009b06:	c0 b8       	rjmp	80009b1c <_vfprintf_r+0x1990>
80009b08:	fa ca f9 78 	sub	r10,sp,-1672
80009b0c:	02 9b       	mov	r11,r1
80009b0e:	08 9c       	mov	r12,r4
80009b10:	fe b0 f3 30 	rcall	80008170 <__sprint_r>
80009b14:	e0 81 02 bb 	brne	8000a08a <_vfprintf_r+0x1efe>
80009b18:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b1c:	40 66       	lddsp	r6,sp[0x18]
80009b1e:	20 16       	sub	r6,1
80009b20:	58 06       	cp.w	r6,0
80009b22:	e0 89 00 1d 	brgt	80009b5c <_vfprintf_r+0x19d0>
80009b26:	e0 8f 02 47 	bral	80009fb4 <_vfprintf_r+0x1e28>
80009b2a:	2f 09       	sub	r9,-16
80009b2c:	2f f8       	sub	r8,-1
80009b2e:	fb 49 06 90 	st.w	sp[1680],r9
80009b32:	87 02       	st.w	r3[0x0],r2
80009b34:	87 10       	st.w	r3[0x4],r0
80009b36:	fb 48 06 8c 	st.w	sp[1676],r8
80009b3a:	58 78       	cp.w	r8,7
80009b3c:	e0 89 00 04 	brgt	80009b44 <_vfprintf_r+0x19b8>
80009b40:	2f 83       	sub	r3,-8
80009b42:	c0 b8       	rjmp	80009b58 <_vfprintf_r+0x19cc>
80009b44:	fa ca f9 78 	sub	r10,sp,-1672
80009b48:	02 9b       	mov	r11,r1
80009b4a:	08 9c       	mov	r12,r4
80009b4c:	fe b0 f3 12 	rcall	80008170 <__sprint_r>
80009b50:	e0 81 02 9d 	brne	8000a08a <_vfprintf_r+0x1efe>
80009b54:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b58:	21 06       	sub	r6,16
80009b5a:	c0 48       	rjmp	80009b62 <_vfprintf_r+0x19d6>
80009b5c:	fe c2 bb 64 	sub	r2,pc,-17564
80009b60:	31 00       	mov	r0,16
80009b62:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b66:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b6a:	fe ca bb 72 	sub	r10,pc,-17550
80009b6e:	59 06       	cp.w	r6,16
80009b70:	fe 99 ff dd 	brgt	80009b2a <_vfprintf_r+0x199e>
80009b74:	0c 09       	add	r9,r6
80009b76:	87 0a       	st.w	r3[0x0],r10
80009b78:	fb 49 06 90 	st.w	sp[1680],r9
80009b7c:	2f f8       	sub	r8,-1
80009b7e:	87 16       	st.w	r3[0x4],r6
80009b80:	c5 39       	rjmp	80009e26 <_vfprintf_r+0x1c9a>
80009b82:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009b86:	58 0a       	cp.w	r10,0
80009b88:	e0 89 00 92 	brgt	80009cac <_vfprintf_r+0x1b20>
80009b8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b90:	fe c9 bb ac 	sub	r9,pc,-17492
80009b94:	2f f8       	sub	r8,-1
80009b96:	87 09       	st.w	r3[0x0],r9
80009b98:	fb 48 06 90 	st.w	sp[1680],r8
80009b9c:	30 19       	mov	r9,1
80009b9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ba2:	87 19       	st.w	r3[0x4],r9
80009ba4:	2f f8       	sub	r8,-1
80009ba6:	fb 48 06 8c 	st.w	sp[1676],r8
80009baa:	58 78       	cp.w	r8,7
80009bac:	e0 89 00 04 	brgt	80009bb4 <_vfprintf_r+0x1a28>
80009bb0:	2f 83       	sub	r3,-8
80009bb2:	c0 b8       	rjmp	80009bc8 <_vfprintf_r+0x1a3c>
80009bb4:	fa ca f9 78 	sub	r10,sp,-1672
80009bb8:	02 9b       	mov	r11,r1
80009bba:	08 9c       	mov	r12,r4
80009bbc:	fe b0 f2 da 	rcall	80008170 <__sprint_r>
80009bc0:	e0 81 02 65 	brne	8000a08a <_vfprintf_r+0x1efe>
80009bc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bc8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bcc:	58 08       	cp.w	r8,0
80009bce:	c0 81       	brne	80009bde <_vfprintf_r+0x1a52>
80009bd0:	40 6a       	lddsp	r10,sp[0x18]
80009bd2:	58 0a       	cp.w	r10,0
80009bd4:	c0 51       	brne	80009bde <_vfprintf_r+0x1a52>
80009bd6:	ed b5 00 00 	bld	r5,0x0
80009bda:	e0 81 01 ed 	brne	80009fb4 <_vfprintf_r+0x1e28>
80009bde:	40 c9       	lddsp	r9,sp[0x30]
80009be0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009be4:	2f f8       	sub	r8,-1
80009be6:	87 09       	st.w	r3[0x0],r9
80009be8:	fb 48 06 90 	st.w	sp[1680],r8
80009bec:	30 19       	mov	r9,1
80009bee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bf2:	87 19       	st.w	r3[0x4],r9
80009bf4:	2f f8       	sub	r8,-1
80009bf6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bfa:	58 78       	cp.w	r8,7
80009bfc:	e0 89 00 04 	brgt	80009c04 <_vfprintf_r+0x1a78>
80009c00:	2f 83       	sub	r3,-8
80009c02:	c0 b8       	rjmp	80009c18 <_vfprintf_r+0x1a8c>
80009c04:	fa ca f9 78 	sub	r10,sp,-1672
80009c08:	02 9b       	mov	r11,r1
80009c0a:	08 9c       	mov	r12,r4
80009c0c:	fe b0 f2 b2 	rcall	80008170 <__sprint_r>
80009c10:	e0 81 02 3d 	brne	8000a08a <_vfprintf_r+0x1efe>
80009c14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c18:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c1c:	5c 32       	neg	r2
80009c1e:	58 02       	cp.w	r2,0
80009c20:	e0 89 00 1d 	brgt	80009c5a <_vfprintf_r+0x1ace>
80009c24:	c3 d8       	rjmp	80009c9e <_vfprintf_r+0x1b12>
80009c26:	2f 09       	sub	r9,-16
80009c28:	2f f8       	sub	r8,-1
80009c2a:	31 0e       	mov	lr,16
80009c2c:	fb 49 06 90 	st.w	sp[1680],r9
80009c30:	87 00       	st.w	r3[0x0],r0
80009c32:	87 1e       	st.w	r3[0x4],lr
80009c34:	fb 48 06 8c 	st.w	sp[1676],r8
80009c38:	58 78       	cp.w	r8,7
80009c3a:	e0 89 00 04 	brgt	80009c42 <_vfprintf_r+0x1ab6>
80009c3e:	2f 83       	sub	r3,-8
80009c40:	c0 b8       	rjmp	80009c56 <_vfprintf_r+0x1aca>
80009c42:	fa ca f9 78 	sub	r10,sp,-1672
80009c46:	02 9b       	mov	r11,r1
80009c48:	08 9c       	mov	r12,r4
80009c4a:	fe b0 f2 93 	rcall	80008170 <__sprint_r>
80009c4e:	e0 81 02 1e 	brne	8000a08a <_vfprintf_r+0x1efe>
80009c52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c56:	21 02       	sub	r2,16
80009c58:	c0 38       	rjmp	80009c5e <_vfprintf_r+0x1ad2>
80009c5a:	fe c0 bc 62 	sub	r0,pc,-17310
80009c5e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c66:	fe ca bc 6e 	sub	r10,pc,-17298
80009c6a:	59 02       	cp.w	r2,16
80009c6c:	fe 99 ff dd 	brgt	80009c26 <_vfprintf_r+0x1a9a>
80009c70:	04 09       	add	r9,r2
80009c72:	2f f8       	sub	r8,-1
80009c74:	87 0a       	st.w	r3[0x0],r10
80009c76:	fb 49 06 90 	st.w	sp[1680],r9
80009c7a:	87 12       	st.w	r3[0x4],r2
80009c7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c80:	58 78       	cp.w	r8,7
80009c82:	e0 89 00 04 	brgt	80009c8a <_vfprintf_r+0x1afe>
80009c86:	2f 83       	sub	r3,-8
80009c88:	c0 b8       	rjmp	80009c9e <_vfprintf_r+0x1b12>
80009c8a:	fa ca f9 78 	sub	r10,sp,-1672
80009c8e:	02 9b       	mov	r11,r1
80009c90:	08 9c       	mov	r12,r4
80009c92:	fe b0 f2 6f 	rcall	80008170 <__sprint_r>
80009c96:	e0 81 01 fa 	brne	8000a08a <_vfprintf_r+0x1efe>
80009c9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c9e:	40 6c       	lddsp	r12,sp[0x18]
80009ca0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ca4:	87 06       	st.w	r3[0x0],r6
80009ca6:	87 1c       	st.w	r3[0x4],r12
80009ca8:	18 08       	add	r8,r12
80009caa:	cb 98       	rjmp	80009e1c <_vfprintf_r+0x1c90>
80009cac:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cb0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cb4:	40 6b       	lddsp	r11,sp[0x18]
80009cb6:	16 3a       	cp.w	r10,r11
80009cb8:	c6 f5       	brlt	80009d96 <_vfprintf_r+0x1c0a>
80009cba:	16 09       	add	r9,r11
80009cbc:	2f f8       	sub	r8,-1
80009cbe:	87 06       	st.w	r3[0x0],r6
80009cc0:	fb 49 06 90 	st.w	sp[1680],r9
80009cc4:	87 1b       	st.w	r3[0x4],r11
80009cc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009cca:	58 78       	cp.w	r8,7
80009ccc:	e0 89 00 04 	brgt	80009cd4 <_vfprintf_r+0x1b48>
80009cd0:	2f 83       	sub	r3,-8
80009cd2:	c0 b8       	rjmp	80009ce8 <_vfprintf_r+0x1b5c>
80009cd4:	fa ca f9 78 	sub	r10,sp,-1672
80009cd8:	02 9b       	mov	r11,r1
80009cda:	08 9c       	mov	r12,r4
80009cdc:	fe b0 f2 4a 	rcall	80008170 <__sprint_r>
80009ce0:	e0 81 01 d5 	brne	8000a08a <_vfprintf_r+0x1efe>
80009ce4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ce8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009cec:	40 6a       	lddsp	r10,sp[0x18]
80009cee:	14 16       	sub	r6,r10
80009cf0:	58 06       	cp.w	r6,0
80009cf2:	e0 89 00 1c 	brgt	80009d2a <_vfprintf_r+0x1b9e>
80009cf6:	c3 d8       	rjmp	80009d70 <_vfprintf_r+0x1be4>
80009cf8:	2f 09       	sub	r9,-16
80009cfa:	2f f8       	sub	r8,-1
80009cfc:	fb 49 06 90 	st.w	sp[1680],r9
80009d00:	87 02       	st.w	r3[0x0],r2
80009d02:	87 10       	st.w	r3[0x4],r0
80009d04:	fb 48 06 8c 	st.w	sp[1676],r8
80009d08:	58 78       	cp.w	r8,7
80009d0a:	e0 89 00 04 	brgt	80009d12 <_vfprintf_r+0x1b86>
80009d0e:	2f 83       	sub	r3,-8
80009d10:	c0 b8       	rjmp	80009d26 <_vfprintf_r+0x1b9a>
80009d12:	fa ca f9 78 	sub	r10,sp,-1672
80009d16:	02 9b       	mov	r11,r1
80009d18:	08 9c       	mov	r12,r4
80009d1a:	fe b0 f2 2b 	rcall	80008170 <__sprint_r>
80009d1e:	e0 81 01 b6 	brne	8000a08a <_vfprintf_r+0x1efe>
80009d22:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d26:	21 06       	sub	r6,16
80009d28:	c0 48       	rjmp	80009d30 <_vfprintf_r+0x1ba4>
80009d2a:	fe c2 bd 32 	sub	r2,pc,-17102
80009d2e:	31 00       	mov	r0,16
80009d30:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d38:	fe ca bd 40 	sub	r10,pc,-17088
80009d3c:	59 06       	cp.w	r6,16
80009d3e:	fe 99 ff dd 	brgt	80009cf8 <_vfprintf_r+0x1b6c>
80009d42:	0c 09       	add	r9,r6
80009d44:	2f f8       	sub	r8,-1
80009d46:	87 0a       	st.w	r3[0x0],r10
80009d48:	fb 49 06 90 	st.w	sp[1680],r9
80009d4c:	87 16       	st.w	r3[0x4],r6
80009d4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009d52:	58 78       	cp.w	r8,7
80009d54:	e0 89 00 04 	brgt	80009d5c <_vfprintf_r+0x1bd0>
80009d58:	2f 83       	sub	r3,-8
80009d5a:	c0 b8       	rjmp	80009d70 <_vfprintf_r+0x1be4>
80009d5c:	fa ca f9 78 	sub	r10,sp,-1672
80009d60:	02 9b       	mov	r11,r1
80009d62:	08 9c       	mov	r12,r4
80009d64:	fe b0 f2 06 	rcall	80008170 <__sprint_r>
80009d68:	e0 81 01 91 	brne	8000a08a <_vfprintf_r+0x1efe>
80009d6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d70:	ed b5 00 00 	bld	r5,0x0
80009d74:	e0 81 01 20 	brne	80009fb4 <_vfprintf_r+0x1e28>
80009d78:	40 c9       	lddsp	r9,sp[0x30]
80009d7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d7e:	2f f8       	sub	r8,-1
80009d80:	87 09       	st.w	r3[0x0],r9
80009d82:	fb 48 06 90 	st.w	sp[1680],r8
80009d86:	30 19       	mov	r9,1
80009d88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d8c:	87 19       	st.w	r3[0x4],r9
80009d8e:	2f f8       	sub	r8,-1
80009d90:	fb 48 06 8c 	st.w	sp[1676],r8
80009d94:	c0 29       	rjmp	80009f98 <_vfprintf_r+0x1e0c>
80009d96:	14 09       	add	r9,r10
80009d98:	2f f8       	sub	r8,-1
80009d9a:	fb 49 06 90 	st.w	sp[1680],r9
80009d9e:	87 06       	st.w	r3[0x0],r6
80009da0:	87 1a       	st.w	r3[0x4],r10
80009da2:	fb 48 06 8c 	st.w	sp[1676],r8
80009da6:	58 78       	cp.w	r8,7
80009da8:	e0 89 00 04 	brgt	80009db0 <_vfprintf_r+0x1c24>
80009dac:	2f 83       	sub	r3,-8
80009dae:	c0 b8       	rjmp	80009dc4 <_vfprintf_r+0x1c38>
80009db0:	fa ca f9 78 	sub	r10,sp,-1672
80009db4:	02 9b       	mov	r11,r1
80009db6:	08 9c       	mov	r12,r4
80009db8:	fe b0 f1 dc 	rcall	80008170 <__sprint_r>
80009dbc:	e0 81 01 67 	brne	8000a08a <_vfprintf_r+0x1efe>
80009dc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dc4:	40 c8       	lddsp	r8,sp[0x30]
80009dc6:	87 08       	st.w	r3[0x0],r8
80009dc8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dcc:	2f f8       	sub	r8,-1
80009dce:	30 19       	mov	r9,1
80009dd0:	fb 48 06 90 	st.w	sp[1680],r8
80009dd4:	87 19       	st.w	r3[0x4],r9
80009dd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dda:	2f f8       	sub	r8,-1
80009ddc:	fb 48 06 8c 	st.w	sp[1676],r8
80009de0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009de4:	58 78       	cp.w	r8,7
80009de6:	e0 89 00 04 	brgt	80009dee <_vfprintf_r+0x1c62>
80009dea:	2f 83       	sub	r3,-8
80009dec:	c0 b8       	rjmp	80009e02 <_vfprintf_r+0x1c76>
80009dee:	fa ca f9 78 	sub	r10,sp,-1672
80009df2:	02 9b       	mov	r11,r1
80009df4:	08 9c       	mov	r12,r4
80009df6:	fe b0 f1 bd 	rcall	80008170 <__sprint_r>
80009dfa:	e0 81 01 48 	brne	8000a08a <_vfprintf_r+0x1efe>
80009dfe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e02:	04 06       	add	r6,r2
80009e04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009e08:	87 06       	st.w	r3[0x0],r6
80009e0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e0e:	40 66       	lddsp	r6,sp[0x18]
80009e10:	40 6e       	lddsp	lr,sp[0x18]
80009e12:	10 16       	sub	r6,r8
80009e14:	f2 08 01 08 	sub	r8,r9,r8
80009e18:	87 16       	st.w	r3[0x4],r6
80009e1a:	1c 08       	add	r8,lr
80009e1c:	fb 48 06 90 	st.w	sp[1680],r8
80009e20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e24:	2f f8       	sub	r8,-1
80009e26:	fb 48 06 8c 	st.w	sp[1676],r8
80009e2a:	cb 78       	rjmp	80009f98 <_vfprintf_r+0x1e0c>
80009e2c:	40 6c       	lddsp	r12,sp[0x18]
80009e2e:	58 1c       	cp.w	r12,1
80009e30:	e0 89 00 06 	brgt	80009e3c <_vfprintf_r+0x1cb0>
80009e34:	ed b5 00 00 	bld	r5,0x0
80009e38:	e0 81 00 85 	brne	80009f42 <_vfprintf_r+0x1db6>
80009e3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e40:	2f f8       	sub	r8,-1
80009e42:	30 19       	mov	r9,1
80009e44:	fb 48 06 90 	st.w	sp[1680],r8
80009e48:	87 06       	st.w	r3[0x0],r6
80009e4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e4e:	87 19       	st.w	r3[0x4],r9
80009e50:	2f f8       	sub	r8,-1
80009e52:	fb 48 06 8c 	st.w	sp[1676],r8
80009e56:	58 78       	cp.w	r8,7
80009e58:	e0 89 00 04 	brgt	80009e60 <_vfprintf_r+0x1cd4>
80009e5c:	2f 83       	sub	r3,-8
80009e5e:	c0 b8       	rjmp	80009e74 <_vfprintf_r+0x1ce8>
80009e60:	fa ca f9 78 	sub	r10,sp,-1672
80009e64:	02 9b       	mov	r11,r1
80009e66:	08 9c       	mov	r12,r4
80009e68:	fe b0 f1 84 	rcall	80008170 <__sprint_r>
80009e6c:	e0 81 01 0f 	brne	8000a08a <_vfprintf_r+0x1efe>
80009e70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e74:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e78:	2f f8       	sub	r8,-1
80009e7a:	40 cb       	lddsp	r11,sp[0x30]
80009e7c:	fb 48 06 90 	st.w	sp[1680],r8
80009e80:	30 19       	mov	r9,1
80009e82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e86:	87 0b       	st.w	r3[0x0],r11
80009e88:	2f f8       	sub	r8,-1
80009e8a:	87 19       	st.w	r3[0x4],r9
80009e8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e90:	58 78       	cp.w	r8,7
80009e92:	e0 89 00 05 	brgt	80009e9c <_vfprintf_r+0x1d10>
80009e96:	2f 83       	sub	r3,-8
80009e98:	c0 c8       	rjmp	80009eb0 <_vfprintf_r+0x1d24>
80009e9a:	d7 03       	nop
80009e9c:	fa ca f9 78 	sub	r10,sp,-1672
80009ea0:	02 9b       	mov	r11,r1
80009ea2:	08 9c       	mov	r12,r4
80009ea4:	fe b0 f1 66 	rcall	80008170 <__sprint_r>
80009ea8:	e0 81 00 f1 	brne	8000a08a <_vfprintf_r+0x1efe>
80009eac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eb0:	30 08       	mov	r8,0
80009eb2:	30 09       	mov	r9,0
80009eb4:	40 5b       	lddsp	r11,sp[0x14]
80009eb6:	40 7a       	lddsp	r10,sp[0x1c]
80009eb8:	e0 a0 13 25 	rcall	8000c502 <__avr32_f64_cmp_eq>
80009ebc:	40 68       	lddsp	r8,sp[0x18]
80009ebe:	20 18       	sub	r8,1
80009ec0:	58 0c       	cp.w	r12,0
80009ec2:	c0 d1       	brne	80009edc <_vfprintf_r+0x1d50>
80009ec4:	2f f6       	sub	r6,-1
80009ec6:	87 18       	st.w	r3[0x4],r8
80009ec8:	87 06       	st.w	r3[0x0],r6
80009eca:	fa f6 06 90 	ld.w	r6,sp[1680]
80009ece:	10 06       	add	r6,r8
80009ed0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ed4:	fb 46 06 90 	st.w	sp[1680],r6
80009ed8:	2f f8       	sub	r8,-1
80009eda:	c3 18       	rjmp	80009f3c <_vfprintf_r+0x1db0>
80009edc:	10 96       	mov	r6,r8
80009ede:	58 08       	cp.w	r8,0
80009ee0:	e0 89 00 1c 	brgt	80009f18 <_vfprintf_r+0x1d8c>
80009ee4:	c4 b8       	rjmp	80009f7a <_vfprintf_r+0x1dee>
80009ee6:	2f 09       	sub	r9,-16
80009ee8:	2f f8       	sub	r8,-1
80009eea:	fb 49 06 90 	st.w	sp[1680],r9
80009eee:	87 02       	st.w	r3[0x0],r2
80009ef0:	87 10       	st.w	r3[0x4],r0
80009ef2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ef6:	58 78       	cp.w	r8,7
80009ef8:	e0 89 00 04 	brgt	80009f00 <_vfprintf_r+0x1d74>
80009efc:	2f 83       	sub	r3,-8
80009efe:	c0 b8       	rjmp	80009f14 <_vfprintf_r+0x1d88>
80009f00:	fa ca f9 78 	sub	r10,sp,-1672
80009f04:	02 9b       	mov	r11,r1
80009f06:	08 9c       	mov	r12,r4
80009f08:	fe b0 f1 34 	rcall	80008170 <__sprint_r>
80009f0c:	e0 81 00 bf 	brne	8000a08a <_vfprintf_r+0x1efe>
80009f10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f14:	21 06       	sub	r6,16
80009f16:	c0 48       	rjmp	80009f1e <_vfprintf_r+0x1d92>
80009f18:	fe c2 bf 20 	sub	r2,pc,-16608
80009f1c:	31 00       	mov	r0,16
80009f1e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f26:	fe ca bf 2e 	sub	r10,pc,-16594
80009f2a:	59 06       	cp.w	r6,16
80009f2c:	fe 99 ff dd 	brgt	80009ee6 <_vfprintf_r+0x1d5a>
80009f30:	0c 09       	add	r9,r6
80009f32:	87 0a       	st.w	r3[0x0],r10
80009f34:	fb 49 06 90 	st.w	sp[1680],r9
80009f38:	2f f8       	sub	r8,-1
80009f3a:	87 16       	st.w	r3[0x4],r6
80009f3c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f40:	c0 e8       	rjmp	80009f5c <_vfprintf_r+0x1dd0>
80009f42:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f46:	2f f8       	sub	r8,-1
80009f48:	30 19       	mov	r9,1
80009f4a:	fb 48 06 90 	st.w	sp[1680],r8
80009f4e:	87 06       	st.w	r3[0x0],r6
80009f50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f54:	87 19       	st.w	r3[0x4],r9
80009f56:	2f f8       	sub	r8,-1
80009f58:	fb 48 06 8c 	st.w	sp[1676],r8
80009f5c:	58 78       	cp.w	r8,7
80009f5e:	e0 89 00 04 	brgt	80009f66 <_vfprintf_r+0x1dda>
80009f62:	2f 83       	sub	r3,-8
80009f64:	c0 b8       	rjmp	80009f7a <_vfprintf_r+0x1dee>
80009f66:	fa ca f9 78 	sub	r10,sp,-1672
80009f6a:	02 9b       	mov	r11,r1
80009f6c:	08 9c       	mov	r12,r4
80009f6e:	fe b0 f1 01 	rcall	80008170 <__sprint_r>
80009f72:	e0 81 00 8c 	brne	8000a08a <_vfprintf_r+0x1efe>
80009f76:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f7a:	40 ea       	lddsp	r10,sp[0x38]
80009f7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f80:	14 08       	add	r8,r10
80009f82:	fa c9 f9 64 	sub	r9,sp,-1692
80009f86:	fb 48 06 90 	st.w	sp[1680],r8
80009f8a:	87 1a       	st.w	r3[0x4],r10
80009f8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f90:	87 09       	st.w	r3[0x0],r9
80009f92:	2f f8       	sub	r8,-1
80009f94:	fb 48 06 8c 	st.w	sp[1676],r8
80009f98:	58 78       	cp.w	r8,7
80009f9a:	e0 89 00 04 	brgt	80009fa2 <_vfprintf_r+0x1e16>
80009f9e:	2f 83       	sub	r3,-8
80009fa0:	c0 a8       	rjmp	80009fb4 <_vfprintf_r+0x1e28>
80009fa2:	fa ca f9 78 	sub	r10,sp,-1672
80009fa6:	02 9b       	mov	r11,r1
80009fa8:	08 9c       	mov	r12,r4
80009faa:	fe b0 f0 e3 	rcall	80008170 <__sprint_r>
80009fae:	c6 e1       	brne	8000a08a <_vfprintf_r+0x1efe>
80009fb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fb4:	e2 15 00 04 	andl	r5,0x4,COH
80009fb8:	c3 f0       	breq	8000a036 <_vfprintf_r+0x1eaa>
80009fba:	40 86       	lddsp	r6,sp[0x20]
80009fbc:	40 39       	lddsp	r9,sp[0xc]
80009fbe:	12 16       	sub	r6,r9
80009fc0:	58 06       	cp.w	r6,0
80009fc2:	e0 89 00 1a 	brgt	80009ff6 <_vfprintf_r+0x1e6a>
80009fc6:	c3 88       	rjmp	8000a036 <_vfprintf_r+0x1eaa>
80009fc8:	2f 09       	sub	r9,-16
80009fca:	2f f8       	sub	r8,-1
80009fcc:	fb 49 06 90 	st.w	sp[1680],r9
80009fd0:	87 05       	st.w	r3[0x0],r5
80009fd2:	87 12       	st.w	r3[0x4],r2
80009fd4:	fb 48 06 8c 	st.w	sp[1676],r8
80009fd8:	58 78       	cp.w	r8,7
80009fda:	e0 89 00 04 	brgt	80009fe2 <_vfprintf_r+0x1e56>
80009fde:	2f 83       	sub	r3,-8
80009fe0:	c0 98       	rjmp	80009ff2 <_vfprintf_r+0x1e66>
80009fe2:	00 9a       	mov	r10,r0
80009fe4:	02 9b       	mov	r11,r1
80009fe6:	08 9c       	mov	r12,r4
80009fe8:	fe b0 f0 c4 	rcall	80008170 <__sprint_r>
80009fec:	c4 f1       	brne	8000a08a <_vfprintf_r+0x1efe>
80009fee:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ff2:	21 06       	sub	r6,16
80009ff4:	c0 68       	rjmp	8000a000 <_vfprintf_r+0x1e74>
80009ff6:	fe c5 c0 0e 	sub	r5,pc,-16370
80009ffa:	31 02       	mov	r2,16
80009ffc:	fa c0 f9 78 	sub	r0,sp,-1672
8000a000:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a004:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a008:	fe ca c0 20 	sub	r10,pc,-16352
8000a00c:	59 06       	cp.w	r6,16
8000a00e:	fe 99 ff dd 	brgt	80009fc8 <_vfprintf_r+0x1e3c>
8000a012:	0c 09       	add	r9,r6
8000a014:	2f f8       	sub	r8,-1
8000a016:	87 0a       	st.w	r3[0x0],r10
8000a018:	87 16       	st.w	r3[0x4],r6
8000a01a:	fb 49 06 90 	st.w	sp[1680],r9
8000a01e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a022:	58 78       	cp.w	r8,7
8000a024:	e0 8a 00 09 	brle	8000a036 <_vfprintf_r+0x1eaa>
8000a028:	fa ca f9 78 	sub	r10,sp,-1672
8000a02c:	02 9b       	mov	r11,r1
8000a02e:	08 9c       	mov	r12,r4
8000a030:	fe b0 f0 a0 	rcall	80008170 <__sprint_r>
8000a034:	c2 b1       	brne	8000a08a <_vfprintf_r+0x1efe>
8000a036:	40 bc       	lddsp	r12,sp[0x2c]
8000a038:	40 36       	lddsp	r6,sp[0xc]
8000a03a:	40 8e       	lddsp	lr,sp[0x20]
8000a03c:	ec 0e 0c 48 	max	r8,r6,lr
8000a040:	10 0c       	add	r12,r8
8000a042:	50 bc       	stdsp	sp[0x2c],r12
8000a044:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a048:	58 08       	cp.w	r8,0
8000a04a:	c0 80       	breq	8000a05a <_vfprintf_r+0x1ece>
8000a04c:	fa ca f9 78 	sub	r10,sp,-1672
8000a050:	02 9b       	mov	r11,r1
8000a052:	08 9c       	mov	r12,r4
8000a054:	fe b0 f0 8e 	rcall	80008170 <__sprint_r>
8000a058:	c1 91       	brne	8000a08a <_vfprintf_r+0x1efe>
8000a05a:	30 0b       	mov	r11,0
8000a05c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a060:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a064:	fe 9f f1 22 	bral	800082a8 <_vfprintf_r+0x11c>
8000a068:	08 95       	mov	r5,r4
8000a06a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a06e:	58 08       	cp.w	r8,0
8000a070:	c0 80       	breq	8000a080 <_vfprintf_r+0x1ef4>
8000a072:	08 9c       	mov	r12,r4
8000a074:	fa ca f9 78 	sub	r10,sp,-1672
8000a078:	02 9b       	mov	r11,r1
8000a07a:	fe b0 f0 7b 	rcall	80008170 <__sprint_r>
8000a07e:	c0 61       	brne	8000a08a <_vfprintf_r+0x1efe>
8000a080:	30 08       	mov	r8,0
8000a082:	fb 48 06 8c 	st.w	sp[1676],r8
8000a086:	c0 28       	rjmp	8000a08a <_vfprintf_r+0x1efe>
8000a088:	40 41       	lddsp	r1,sp[0x10]
8000a08a:	82 68       	ld.sh	r8,r1[0xc]
8000a08c:	ed b8 00 06 	bld	r8,0x6
8000a090:	c0 31       	brne	8000a096 <_vfprintf_r+0x1f0a>
8000a092:	3f fa       	mov	r10,-1
8000a094:	50 ba       	stdsp	sp[0x2c],r10
8000a096:	40 bc       	lddsp	r12,sp[0x2c]
8000a098:	fe 3d f9 44 	sub	sp,-1724
8000a09c:	d8 32       	popm	r0-r7,pc
8000a09e:	d7 03       	nop

8000a0a0 <__swsetup_r>:
8000a0a0:	d4 21       	pushm	r4-r7,lr
8000a0a2:	e0 68 0a 40 	mov	r8,2624
8000a0a6:	18 96       	mov	r6,r12
8000a0a8:	16 97       	mov	r7,r11
8000a0aa:	70 0c       	ld.w	r12,r8[0x0]
8000a0ac:	58 0c       	cp.w	r12,0
8000a0ae:	c0 60       	breq	8000a0ba <__swsetup_r+0x1a>
8000a0b0:	78 68       	ld.w	r8,r12[0x18]
8000a0b2:	58 08       	cp.w	r8,0
8000a0b4:	c0 31       	brne	8000a0ba <__swsetup_r+0x1a>
8000a0b6:	e0 a0 07 bf 	rcall	8000b034 <__sinit>
8000a0ba:	fe c8 bf a2 	sub	r8,pc,-16478
8000a0be:	10 37       	cp.w	r7,r8
8000a0c0:	c0 61       	brne	8000a0cc <__swsetup_r+0x2c>
8000a0c2:	e0 68 0a 40 	mov	r8,2624
8000a0c6:	70 08       	ld.w	r8,r8[0x0]
8000a0c8:	70 07       	ld.w	r7,r8[0x0]
8000a0ca:	c1 28       	rjmp	8000a0ee <__swsetup_r+0x4e>
8000a0cc:	fe c8 bf 94 	sub	r8,pc,-16492
8000a0d0:	10 37       	cp.w	r7,r8
8000a0d2:	c0 61       	brne	8000a0de <__swsetup_r+0x3e>
8000a0d4:	e0 68 0a 40 	mov	r8,2624
8000a0d8:	70 08       	ld.w	r8,r8[0x0]
8000a0da:	70 17       	ld.w	r7,r8[0x4]
8000a0dc:	c0 98       	rjmp	8000a0ee <__swsetup_r+0x4e>
8000a0de:	fe c8 bf 86 	sub	r8,pc,-16506
8000a0e2:	10 37       	cp.w	r7,r8
8000a0e4:	c0 51       	brne	8000a0ee <__swsetup_r+0x4e>
8000a0e6:	e0 68 0a 40 	mov	r8,2624
8000a0ea:	70 08       	ld.w	r8,r8[0x0]
8000a0ec:	70 27       	ld.w	r7,r8[0x8]
8000a0ee:	8e 68       	ld.sh	r8,r7[0xc]
8000a0f0:	ed b8 00 03 	bld	r8,0x3
8000a0f4:	c1 e0       	breq	8000a130 <__swsetup_r+0x90>
8000a0f6:	ed b8 00 04 	bld	r8,0x4
8000a0fa:	c3 e1       	brne	8000a176 <__swsetup_r+0xd6>
8000a0fc:	ed b8 00 02 	bld	r8,0x2
8000a100:	c1 51       	brne	8000a12a <__swsetup_r+0x8a>
8000a102:	6e db       	ld.w	r11,r7[0x34]
8000a104:	58 0b       	cp.w	r11,0
8000a106:	c0 a0       	breq	8000a11a <__swsetup_r+0x7a>
8000a108:	ee c8 ff bc 	sub	r8,r7,-68
8000a10c:	10 3b       	cp.w	r11,r8
8000a10e:	c0 40       	breq	8000a116 <__swsetup_r+0x76>
8000a110:	0c 9c       	mov	r12,r6
8000a112:	e0 a0 08 2b 	rcall	8000b168 <_free_r>
8000a116:	30 08       	mov	r8,0
8000a118:	8f d8       	st.w	r7[0x34],r8
8000a11a:	8e 68       	ld.sh	r8,r7[0xc]
8000a11c:	e0 18 ff db 	andl	r8,0xffdb
8000a120:	ae 68       	st.h	r7[0xc],r8
8000a122:	30 08       	mov	r8,0
8000a124:	8f 18       	st.w	r7[0x4],r8
8000a126:	6e 48       	ld.w	r8,r7[0x10]
8000a128:	8f 08       	st.w	r7[0x0],r8
8000a12a:	8e 68       	ld.sh	r8,r7[0xc]
8000a12c:	a3 b8       	sbr	r8,0x3
8000a12e:	ae 68       	st.h	r7[0xc],r8
8000a130:	6e 48       	ld.w	r8,r7[0x10]
8000a132:	58 08       	cp.w	r8,0
8000a134:	c0 b1       	brne	8000a14a <__swsetup_r+0xaa>
8000a136:	8e 68       	ld.sh	r8,r7[0xc]
8000a138:	e2 18 02 80 	andl	r8,0x280,COH
8000a13c:	e0 48 02 00 	cp.w	r8,512
8000a140:	c0 50       	breq	8000a14a <__swsetup_r+0xaa>
8000a142:	0c 9c       	mov	r12,r6
8000a144:	0e 9b       	mov	r11,r7
8000a146:	e0 a0 0a 4b 	rcall	8000b5dc <__smakebuf_r>
8000a14a:	8e 69       	ld.sh	r9,r7[0xc]
8000a14c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a150:	c0 70       	breq	8000a15e <__swsetup_r+0xbe>
8000a152:	30 08       	mov	r8,0
8000a154:	8f 28       	st.w	r7[0x8],r8
8000a156:	6e 58       	ld.w	r8,r7[0x14]
8000a158:	5c 38       	neg	r8
8000a15a:	8f 68       	st.w	r7[0x18],r8
8000a15c:	c0 68       	rjmp	8000a168 <__swsetup_r+0xc8>
8000a15e:	ed b9 00 01 	bld	r9,0x1
8000a162:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a166:	8f 28       	st.w	r7[0x8],r8
8000a168:	6e 48       	ld.w	r8,r7[0x10]
8000a16a:	58 08       	cp.w	r8,0
8000a16c:	c0 61       	brne	8000a178 <__swsetup_r+0xd8>
8000a16e:	8e 68       	ld.sh	r8,r7[0xc]
8000a170:	ed b8 00 07 	bld	r8,0x7
8000a174:	c0 21       	brne	8000a178 <__swsetup_r+0xd8>
8000a176:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a178:	d8 2a       	popm	r4-r7,pc,r12=0
8000a17a:	d7 03       	nop

8000a17c <quorem>:
8000a17c:	d4 31       	pushm	r0-r7,lr
8000a17e:	20 2d       	sub	sp,8
8000a180:	18 97       	mov	r7,r12
8000a182:	78 48       	ld.w	r8,r12[0x10]
8000a184:	76 46       	ld.w	r6,r11[0x10]
8000a186:	0c 38       	cp.w	r8,r6
8000a188:	c0 34       	brge	8000a18e <quorem+0x12>
8000a18a:	30 0c       	mov	r12,0
8000a18c:	c8 58       	rjmp	8000a296 <quorem+0x11a>
8000a18e:	ec c2 ff fc 	sub	r2,r6,-4
8000a192:	f6 c3 ff ec 	sub	r3,r11,-20
8000a196:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a19a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a19e:	2f f9       	sub	r9,-1
8000a1a0:	20 16       	sub	r6,1
8000a1a2:	f8 09 0d 08 	divu	r8,r12,r9
8000a1a6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a1aa:	ee c4 ff ec 	sub	r4,r7,-20
8000a1ae:	10 95       	mov	r5,r8
8000a1b0:	58 08       	cp.w	r8,0
8000a1b2:	c4 10       	breq	8000a234 <quorem+0xb8>
8000a1b4:	30 09       	mov	r9,0
8000a1b6:	06 9a       	mov	r10,r3
8000a1b8:	08 98       	mov	r8,r4
8000a1ba:	12 91       	mov	r1,r9
8000a1bc:	50 0b       	stdsp	sp[0x0],r11
8000a1be:	70 0e       	ld.w	lr,r8[0x0]
8000a1c0:	b1 8e       	lsr	lr,0x10
8000a1c2:	50 1e       	stdsp	sp[0x4],lr
8000a1c4:	15 0e       	ld.w	lr,r10++
8000a1c6:	fc 00 16 10 	lsr	r0,lr,0x10
8000a1ca:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a1ce:	ea 0e 03 41 	mac	r1,r5,lr
8000a1d2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a1d6:	b1 81       	lsr	r1,0x10
8000a1d8:	40 1b       	lddsp	r11,sp[0x4]
8000a1da:	ea 00 02 40 	mul	r0,r5,r0
8000a1de:	e2 00 00 00 	add	r0,r1,r0
8000a1e2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a1e6:	02 1b       	sub	r11,r1
8000a1e8:	50 1b       	stdsp	sp[0x4],r11
8000a1ea:	70 0b       	ld.w	r11,r8[0x0]
8000a1ec:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a1f0:	02 09       	add	r9,r1
8000a1f2:	f2 0e 01 0e 	sub	lr,r9,lr
8000a1f6:	b0 1e       	st.h	r8[0x2],lr
8000a1f8:	fc 09 14 10 	asr	r9,lr,0x10
8000a1fc:	40 1e       	lddsp	lr,sp[0x4]
8000a1fe:	fc 09 00 09 	add	r9,lr,r9
8000a202:	b0 09       	st.h	r8[0x0],r9
8000a204:	e0 01 16 10 	lsr	r1,r0,0x10
8000a208:	2f c8       	sub	r8,-4
8000a20a:	b1 49       	asr	r9,0x10
8000a20c:	04 3a       	cp.w	r10,r2
8000a20e:	fe 98 ff d8 	brls	8000a1be <quorem+0x42>
8000a212:	40 0b       	lddsp	r11,sp[0x0]
8000a214:	58 0c       	cp.w	r12,0
8000a216:	c0 f1       	brne	8000a234 <quorem+0xb8>
8000a218:	ec c8 ff fb 	sub	r8,r6,-5
8000a21c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a220:	c0 28       	rjmp	8000a224 <quorem+0xa8>
8000a222:	20 16       	sub	r6,1
8000a224:	20 48       	sub	r8,4
8000a226:	08 38       	cp.w	r8,r4
8000a228:	e0 88 00 05 	brls	8000a232 <quorem+0xb6>
8000a22c:	70 09       	ld.w	r9,r8[0x0]
8000a22e:	58 09       	cp.w	r9,0
8000a230:	cf 90       	breq	8000a222 <quorem+0xa6>
8000a232:	8f 46       	st.w	r7[0x10],r6
8000a234:	0e 9c       	mov	r12,r7
8000a236:	e0 a0 0a d2 	rcall	8000b7da <__mcmp>
8000a23a:	c2 d5       	brlt	8000a294 <quorem+0x118>
8000a23c:	2f f5       	sub	r5,-1
8000a23e:	08 98       	mov	r8,r4
8000a240:	30 09       	mov	r9,0
8000a242:	07 0b       	ld.w	r11,r3++
8000a244:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a248:	70 0c       	ld.w	r12,r8[0x0]
8000a24a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a24e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a252:	14 1e       	sub	lr,r10
8000a254:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a258:	16 1a       	sub	r10,r11
8000a25a:	12 0a       	add	r10,r9
8000a25c:	b0 1a       	st.h	r8[0x2],r10
8000a25e:	b1 4a       	asr	r10,0x10
8000a260:	fc 0a 00 09 	add	r9,lr,r10
8000a264:	b0 09       	st.h	r8[0x0],r9
8000a266:	2f c8       	sub	r8,-4
8000a268:	b1 49       	asr	r9,0x10
8000a26a:	04 33       	cp.w	r3,r2
8000a26c:	fe 98 ff eb 	brls	8000a242 <quorem+0xc6>
8000a270:	ec c8 ff fb 	sub	r8,r6,-5
8000a274:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a278:	58 09       	cp.w	r9,0
8000a27a:	c0 d1       	brne	8000a294 <quorem+0x118>
8000a27c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a280:	c0 28       	rjmp	8000a284 <quorem+0x108>
8000a282:	20 16       	sub	r6,1
8000a284:	20 48       	sub	r8,4
8000a286:	08 38       	cp.w	r8,r4
8000a288:	e0 88 00 05 	brls	8000a292 <quorem+0x116>
8000a28c:	70 09       	ld.w	r9,r8[0x0]
8000a28e:	58 09       	cp.w	r9,0
8000a290:	cf 90       	breq	8000a282 <quorem+0x106>
8000a292:	8f 46       	st.w	r7[0x10],r6
8000a294:	0a 9c       	mov	r12,r5
8000a296:	2f ed       	sub	sp,-8
8000a298:	d8 32       	popm	r0-r7,pc
8000a29a:	d7 03       	nop

8000a29c <_dtoa_r>:
8000a29c:	d4 31       	pushm	r0-r7,lr
8000a29e:	21 ad       	sub	sp,104
8000a2a0:	fa c4 ff 74 	sub	r4,sp,-140
8000a2a4:	18 97       	mov	r7,r12
8000a2a6:	16 95       	mov	r5,r11
8000a2a8:	68 2c       	ld.w	r12,r4[0x8]
8000a2aa:	50 c9       	stdsp	sp[0x30],r9
8000a2ac:	68 16       	ld.w	r6,r4[0x4]
8000a2ae:	68 09       	ld.w	r9,r4[0x0]
8000a2b0:	50 e8       	stdsp	sp[0x38],r8
8000a2b2:	14 94       	mov	r4,r10
8000a2b4:	51 2c       	stdsp	sp[0x48],r12
8000a2b6:	fa e5 00 08 	st.d	sp[8],r4
8000a2ba:	51 59       	stdsp	sp[0x54],r9
8000a2bc:	6e 95       	ld.w	r5,r7[0x24]
8000a2be:	58 05       	cp.w	r5,0
8000a2c0:	c0 91       	brne	8000a2d2 <_dtoa_r+0x36>
8000a2c2:	31 0c       	mov	r12,16
8000a2c4:	fe b0 e8 f4 	rcall	800074ac <malloc>
8000a2c8:	99 35       	st.w	r12[0xc],r5
8000a2ca:	8f 9c       	st.w	r7[0x24],r12
8000a2cc:	99 15       	st.w	r12[0x4],r5
8000a2ce:	99 25       	st.w	r12[0x8],r5
8000a2d0:	99 05       	st.w	r12[0x0],r5
8000a2d2:	6e 99       	ld.w	r9,r7[0x24]
8000a2d4:	72 08       	ld.w	r8,r9[0x0]
8000a2d6:	58 08       	cp.w	r8,0
8000a2d8:	c0 f0       	breq	8000a2f6 <_dtoa_r+0x5a>
8000a2da:	72 1a       	ld.w	r10,r9[0x4]
8000a2dc:	91 1a       	st.w	r8[0x4],r10
8000a2de:	30 1a       	mov	r10,1
8000a2e0:	72 19       	ld.w	r9,r9[0x4]
8000a2e2:	f4 09 09 49 	lsl	r9,r10,r9
8000a2e6:	10 9b       	mov	r11,r8
8000a2e8:	91 29       	st.w	r8[0x8],r9
8000a2ea:	0e 9c       	mov	r12,r7
8000a2ec:	e0 a0 0a 90 	rcall	8000b80c <_Bfree>
8000a2f0:	6e 98       	ld.w	r8,r7[0x24]
8000a2f2:	30 09       	mov	r9,0
8000a2f4:	91 09       	st.w	r8[0x0],r9
8000a2f6:	40 28       	lddsp	r8,sp[0x8]
8000a2f8:	10 94       	mov	r4,r8
8000a2fa:	58 08       	cp.w	r8,0
8000a2fc:	c0 64       	brge	8000a308 <_dtoa_r+0x6c>
8000a2fe:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a302:	50 28       	stdsp	sp[0x8],r8
8000a304:	30 18       	mov	r8,1
8000a306:	c0 28       	rjmp	8000a30a <_dtoa_r+0x6e>
8000a308:	30 08       	mov	r8,0
8000a30a:	8d 08       	st.w	r6[0x0],r8
8000a30c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a310:	40 26       	lddsp	r6,sp[0x8]
8000a312:	0c 98       	mov	r8,r6
8000a314:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a318:	18 38       	cp.w	r8,r12
8000a31a:	c2 01       	brne	8000a35a <_dtoa_r+0xbe>
8000a31c:	e0 68 27 0f 	mov	r8,9999
8000a320:	41 5b       	lddsp	r11,sp[0x54]
8000a322:	97 08       	st.w	r11[0x0],r8
8000a324:	40 3a       	lddsp	r10,sp[0xc]
8000a326:	58 0a       	cp.w	r10,0
8000a328:	c0 71       	brne	8000a336 <_dtoa_r+0x9a>
8000a32a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a32e:	c0 41       	brne	8000a336 <_dtoa_r+0x9a>
8000a330:	fe cc c2 28 	sub	r12,pc,-15832
8000a334:	c0 38       	rjmp	8000a33a <_dtoa_r+0x9e>
8000a336:	fe cc c2 22 	sub	r12,pc,-15838
8000a33a:	41 29       	lddsp	r9,sp[0x48]
8000a33c:	58 09       	cp.w	r9,0
8000a33e:	e0 80 05 9a 	breq	8000ae72 <_dtoa_r+0xbd6>
8000a342:	f8 c8 ff fd 	sub	r8,r12,-3
8000a346:	f8 c9 ff f8 	sub	r9,r12,-8
8000a34a:	11 8b       	ld.ub	r11,r8[0x0]
8000a34c:	30 0a       	mov	r10,0
8000a34e:	41 25       	lddsp	r5,sp[0x48]
8000a350:	f4 0b 18 00 	cp.b	r11,r10
8000a354:	f2 08 17 10 	movne	r8,r9
8000a358:	c1 68       	rjmp	8000a384 <_dtoa_r+0xe8>
8000a35a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a35e:	30 08       	mov	r8,0
8000a360:	fa eb 00 3c 	st.d	sp[60],r10
8000a364:	30 09       	mov	r9,0
8000a366:	e0 a0 10 ce 	rcall	8000c502 <__avr32_f64_cmp_eq>
8000a36a:	c1 00       	breq	8000a38a <_dtoa_r+0xee>
8000a36c:	30 18       	mov	r8,1
8000a36e:	41 5a       	lddsp	r10,sp[0x54]
8000a370:	95 08       	st.w	r10[0x0],r8
8000a372:	fe cc c3 8e 	sub	r12,pc,-15474
8000a376:	41 29       	lddsp	r9,sp[0x48]
8000a378:	f8 08 00 08 	add	r8,r12,r8
8000a37c:	58 09       	cp.w	r9,0
8000a37e:	e0 80 05 7a 	breq	8000ae72 <_dtoa_r+0xbd6>
8000a382:	12 95       	mov	r5,r9
8000a384:	8b 08       	st.w	r5[0x0],r8
8000a386:	e0 8f 05 76 	bral	8000ae72 <_dtoa_r+0xbd6>
8000a38a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a38e:	fa c9 ff a0 	sub	r9,sp,-96
8000a392:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a396:	0e 9c       	mov	r12,r7
8000a398:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a39c:	e0 a0 0a 8a 	rcall	8000b8b0 <__d2b>
8000a3a0:	18 93       	mov	r3,r12
8000a3a2:	58 05       	cp.w	r5,0
8000a3a4:	c0 d0       	breq	8000a3be <_dtoa_r+0x122>
8000a3a6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3aa:	30 04       	mov	r4,0
8000a3ac:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a3b0:	ea c5 03 ff 	sub	r5,r5,1023
8000a3b4:	10 9b       	mov	r11,r8
8000a3b6:	51 74       	stdsp	sp[0x5c],r4
8000a3b8:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a3bc:	c2 58       	rjmp	8000a406 <_dtoa_r+0x16a>
8000a3be:	41 88       	lddsp	r8,sp[0x60]
8000a3c0:	41 9c       	lddsp	r12,sp[0x64]
8000a3c2:	10 0c       	add	r12,r8
8000a3c4:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a3c8:	e0 45 00 20 	cp.w	r5,32
8000a3cc:	e0 8a 00 0e 	brle	8000a3e8 <_dtoa_r+0x14c>
8000a3d0:	f8 cc fb ee 	sub	r12,r12,-1042
8000a3d4:	40 3b       	lddsp	r11,sp[0xc]
8000a3d6:	ea 08 11 40 	rsub	r8,r5,64
8000a3da:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a3de:	ec 08 09 46 	lsl	r6,r6,r8
8000a3e2:	0c 4c       	or	r12,r6
8000a3e4:	c0 78       	rjmp	8000a3f2 <_dtoa_r+0x156>
8000a3e6:	d7 03       	nop
8000a3e8:	ea 0c 11 20 	rsub	r12,r5,32
8000a3ec:	40 3a       	lddsp	r10,sp[0xc]
8000a3ee:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a3f2:	e0 a0 10 14 	rcall	8000c41a <__avr32_u32_to_f64>
8000a3f6:	fc 18 fe 10 	movh	r8,0xfe10
8000a3fa:	30 19       	mov	r9,1
8000a3fc:	ea c5 04 33 	sub	r5,r5,1075
8000a400:	f0 0b 00 0b 	add	r11,r8,r11
8000a404:	51 79       	stdsp	sp[0x5c],r9
8000a406:	30 08       	mov	r8,0
8000a408:	fc 19 3f f8 	movh	r9,0x3ff8
8000a40c:	e0 a0 0e 9c 	rcall	8000c144 <__avr32_f64_sub>
8000a410:	e0 68 43 61 	mov	r8,17249
8000a414:	ea 18 63 6f 	orh	r8,0x636f
8000a418:	e0 69 87 a7 	mov	r9,34727
8000a41c:	ea 19 3f d2 	orh	r9,0x3fd2
8000a420:	e0 a0 0d a6 	rcall	8000bf6c <__avr32_f64_mul>
8000a424:	e0 68 c8 b3 	mov	r8,51379
8000a428:	ea 18 8b 60 	orh	r8,0x8b60
8000a42c:	e0 69 8a 28 	mov	r9,35368
8000a430:	ea 19 3f c6 	orh	r9,0x3fc6
8000a434:	e0 a0 0f 56 	rcall	8000c2e0 <__avr32_f64_add>
8000a438:	0a 9c       	mov	r12,r5
8000a43a:	14 90       	mov	r0,r10
8000a43c:	16 91       	mov	r1,r11
8000a43e:	e0 a0 0f f2 	rcall	8000c422 <__avr32_s32_to_f64>
8000a442:	e0 68 79 fb 	mov	r8,31227
8000a446:	ea 18 50 9f 	orh	r8,0x509f
8000a44a:	e0 69 44 13 	mov	r9,17427
8000a44e:	ea 19 3f d3 	orh	r9,0x3fd3
8000a452:	e0 a0 0d 8d 	rcall	8000bf6c <__avr32_f64_mul>
8000a456:	14 98       	mov	r8,r10
8000a458:	16 99       	mov	r9,r11
8000a45a:	00 9a       	mov	r10,r0
8000a45c:	02 9b       	mov	r11,r1
8000a45e:	e0 a0 0f 41 	rcall	8000c2e0 <__avr32_f64_add>
8000a462:	14 90       	mov	r0,r10
8000a464:	16 91       	mov	r1,r11
8000a466:	e0 a0 0f c7 	rcall	8000c3f4 <__avr32_f64_to_s32>
8000a46a:	30 08       	mov	r8,0
8000a46c:	18 96       	mov	r6,r12
8000a46e:	30 09       	mov	r9,0
8000a470:	00 9a       	mov	r10,r0
8000a472:	02 9b       	mov	r11,r1
8000a474:	e0 a0 10 8e 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a478:	c0 c0       	breq	8000a490 <_dtoa_r+0x1f4>
8000a47a:	0c 9c       	mov	r12,r6
8000a47c:	e0 a0 0f d3 	rcall	8000c422 <__avr32_s32_to_f64>
8000a480:	14 98       	mov	r8,r10
8000a482:	16 99       	mov	r9,r11
8000a484:	00 9a       	mov	r10,r0
8000a486:	02 9b       	mov	r11,r1
8000a488:	e0 a0 10 3d 	rcall	8000c502 <__avr32_f64_cmp_eq>
8000a48c:	f7 b6 00 01 	subeq	r6,1
8000a490:	59 66       	cp.w	r6,22
8000a492:	e0 88 00 05 	brls	8000a49c <_dtoa_r+0x200>
8000a496:	30 18       	mov	r8,1
8000a498:	51 48       	stdsp	sp[0x50],r8
8000a49a:	c1 38       	rjmp	8000a4c0 <_dtoa_r+0x224>
8000a49c:	fe c8 c2 d4 	sub	r8,pc,-15660
8000a4a0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4a4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a4a8:	e0 a0 10 74 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a4ac:	f9 b4 00 00 	moveq	r4,0
8000a4b0:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a4b4:	f7 b6 01 01 	subne	r6,1
8000a4b8:	f9 bc 01 00 	movne	r12,0
8000a4bc:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a4c0:	41 90       	lddsp	r0,sp[0x64]
8000a4c2:	20 10       	sub	r0,1
8000a4c4:	0a 10       	sub	r0,r5
8000a4c6:	c0 46       	brmi	8000a4ce <_dtoa_r+0x232>
8000a4c8:	50 40       	stdsp	sp[0x10],r0
8000a4ca:	30 00       	mov	r0,0
8000a4cc:	c0 48       	rjmp	8000a4d4 <_dtoa_r+0x238>
8000a4ce:	30 0b       	mov	r11,0
8000a4d0:	5c 30       	neg	r0
8000a4d2:	50 4b       	stdsp	sp[0x10],r11
8000a4d4:	ec 02 11 00 	rsub	r2,r6,0
8000a4d8:	58 06       	cp.w	r6,0
8000a4da:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a4de:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a4e2:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a4e6:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a4ea:	f9 b2 04 00 	movge	r2,0
8000a4ee:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a4f2:	f9 b9 05 00 	movlt	r9,0
8000a4f6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a4fa:	40 c8       	lddsp	r8,sp[0x30]
8000a4fc:	58 98       	cp.w	r8,9
8000a4fe:	e0 8b 00 20 	brhi	8000a53e <_dtoa_r+0x2a2>
8000a502:	58 58       	cp.w	r8,5
8000a504:	f9 b4 0a 01 	movle	r4,1
8000a508:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a50c:	f7 b5 09 04 	subgt	r5,4
8000a510:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a514:	f9 b4 09 00 	movgt	r4,0
8000a518:	40 cc       	lddsp	r12,sp[0x30]
8000a51a:	58 3c       	cp.w	r12,3
8000a51c:	c2 d0       	breq	8000a576 <_dtoa_r+0x2da>
8000a51e:	e0 89 00 05 	brgt	8000a528 <_dtoa_r+0x28c>
8000a522:	58 2c       	cp.w	r12,2
8000a524:	c1 01       	brne	8000a544 <_dtoa_r+0x2a8>
8000a526:	c1 88       	rjmp	8000a556 <_dtoa_r+0x2ba>
8000a528:	40 cb       	lddsp	r11,sp[0x30]
8000a52a:	58 4b       	cp.w	r11,4
8000a52c:	c0 60       	breq	8000a538 <_dtoa_r+0x29c>
8000a52e:	58 5b       	cp.w	r11,5
8000a530:	c0 a1       	brne	8000a544 <_dtoa_r+0x2a8>
8000a532:	30 1a       	mov	r10,1
8000a534:	50 da       	stdsp	sp[0x34],r10
8000a536:	c2 28       	rjmp	8000a57a <_dtoa_r+0x2de>
8000a538:	30 19       	mov	r9,1
8000a53a:	50 d9       	stdsp	sp[0x34],r9
8000a53c:	c0 f8       	rjmp	8000a55a <_dtoa_r+0x2be>
8000a53e:	30 08       	mov	r8,0
8000a540:	30 14       	mov	r4,1
8000a542:	50 c8       	stdsp	sp[0x30],r8
8000a544:	3f f5       	mov	r5,-1
8000a546:	30 1c       	mov	r12,1
8000a548:	30 0b       	mov	r11,0
8000a54a:	50 95       	stdsp	sp[0x24],r5
8000a54c:	50 dc       	stdsp	sp[0x34],r12
8000a54e:	0a 91       	mov	r1,r5
8000a550:	31 28       	mov	r8,18
8000a552:	50 eb       	stdsp	sp[0x38],r11
8000a554:	c2 08       	rjmp	8000a594 <_dtoa_r+0x2f8>
8000a556:	30 0a       	mov	r10,0
8000a558:	50 da       	stdsp	sp[0x34],r10
8000a55a:	40 e9       	lddsp	r9,sp[0x38]
8000a55c:	58 09       	cp.w	r9,0
8000a55e:	e0 89 00 07 	brgt	8000a56c <_dtoa_r+0x2d0>
8000a562:	30 18       	mov	r8,1
8000a564:	50 98       	stdsp	sp[0x24],r8
8000a566:	10 91       	mov	r1,r8
8000a568:	50 e8       	stdsp	sp[0x38],r8
8000a56a:	c1 58       	rjmp	8000a594 <_dtoa_r+0x2f8>
8000a56c:	40 e5       	lddsp	r5,sp[0x38]
8000a56e:	50 95       	stdsp	sp[0x24],r5
8000a570:	0a 91       	mov	r1,r5
8000a572:	0a 98       	mov	r8,r5
8000a574:	c1 08       	rjmp	8000a594 <_dtoa_r+0x2f8>
8000a576:	30 0c       	mov	r12,0
8000a578:	50 dc       	stdsp	sp[0x34],r12
8000a57a:	40 eb       	lddsp	r11,sp[0x38]
8000a57c:	ec 0b 00 0b 	add	r11,r6,r11
8000a580:	50 9b       	stdsp	sp[0x24],r11
8000a582:	16 98       	mov	r8,r11
8000a584:	2f f8       	sub	r8,-1
8000a586:	58 08       	cp.w	r8,0
8000a588:	e0 89 00 05 	brgt	8000a592 <_dtoa_r+0x2f6>
8000a58c:	10 91       	mov	r1,r8
8000a58e:	30 18       	mov	r8,1
8000a590:	c0 28       	rjmp	8000a594 <_dtoa_r+0x2f8>
8000a592:	10 91       	mov	r1,r8
8000a594:	30 09       	mov	r9,0
8000a596:	6e 9a       	ld.w	r10,r7[0x24]
8000a598:	95 19       	st.w	r10[0x4],r9
8000a59a:	30 49       	mov	r9,4
8000a59c:	c0 68       	rjmp	8000a5a8 <_dtoa_r+0x30c>
8000a59e:	d7 03       	nop
8000a5a0:	6a 1a       	ld.w	r10,r5[0x4]
8000a5a2:	a1 79       	lsl	r9,0x1
8000a5a4:	2f fa       	sub	r10,-1
8000a5a6:	8b 1a       	st.w	r5[0x4],r10
8000a5a8:	6e 95       	ld.w	r5,r7[0x24]
8000a5aa:	f2 ca ff ec 	sub	r10,r9,-20
8000a5ae:	10 3a       	cp.w	r10,r8
8000a5b0:	fe 98 ff f8 	brls	8000a5a0 <_dtoa_r+0x304>
8000a5b4:	6a 1b       	ld.w	r11,r5[0x4]
8000a5b6:	0e 9c       	mov	r12,r7
8000a5b8:	e0 a0 09 44 	rcall	8000b840 <_Balloc>
8000a5bc:	58 e1       	cp.w	r1,14
8000a5be:	5f 88       	srls	r8
8000a5c0:	8b 0c       	st.w	r5[0x0],r12
8000a5c2:	f1 e4 00 04 	and	r4,r8,r4
8000a5c6:	6e 98       	ld.w	r8,r7[0x24]
8000a5c8:	70 08       	ld.w	r8,r8[0x0]
8000a5ca:	50 88       	stdsp	sp[0x20],r8
8000a5cc:	e0 80 01 82 	breq	8000a8d0 <_dtoa_r+0x634>
8000a5d0:	58 06       	cp.w	r6,0
8000a5d2:	e0 8a 00 43 	brle	8000a658 <_dtoa_r+0x3bc>
8000a5d6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a5da:	fe c8 c4 12 	sub	r8,pc,-15342
8000a5de:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a5e2:	fa e5 00 18 	st.d	sp[24],r4
8000a5e6:	ec 04 14 04 	asr	r4,r6,0x4
8000a5ea:	ed b4 00 04 	bld	r4,0x4
8000a5ee:	c0 30       	breq	8000a5f4 <_dtoa_r+0x358>
8000a5f0:	30 25       	mov	r5,2
8000a5f2:	c1 08       	rjmp	8000a612 <_dtoa_r+0x376>
8000a5f4:	fe c8 c3 64 	sub	r8,pc,-15516
8000a5f8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a5fc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a600:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a604:	e0 a0 0f fa 	rcall	8000c5f8 <__avr32_f64_div>
8000a608:	30 35       	mov	r5,3
8000a60a:	14 98       	mov	r8,r10
8000a60c:	16 99       	mov	r9,r11
8000a60e:	fa e9 00 08 	st.d	sp[8],r8
8000a612:	fe cc c3 82 	sub	r12,pc,-15486
8000a616:	50 a3       	stdsp	sp[0x28],r3
8000a618:	0c 93       	mov	r3,r6
8000a61a:	18 96       	mov	r6,r12
8000a61c:	c0 f8       	rjmp	8000a63a <_dtoa_r+0x39e>
8000a61e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a622:	ed b4 00 00 	bld	r4,0x0
8000a626:	c0 81       	brne	8000a636 <_dtoa_r+0x39a>
8000a628:	ec e8 00 00 	ld.d	r8,r6[0]
8000a62c:	2f f5       	sub	r5,-1
8000a62e:	e0 a0 0c 9f 	rcall	8000bf6c <__avr32_f64_mul>
8000a632:	fa eb 00 18 	st.d	sp[24],r10
8000a636:	a1 54       	asr	r4,0x1
8000a638:	2f 86       	sub	r6,-8
8000a63a:	58 04       	cp.w	r4,0
8000a63c:	cf 11       	brne	8000a61e <_dtoa_r+0x382>
8000a63e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a642:	fa ea 00 08 	ld.d	r10,sp[8]
8000a646:	06 96       	mov	r6,r3
8000a648:	e0 a0 0f d8 	rcall	8000c5f8 <__avr32_f64_div>
8000a64c:	40 a3       	lddsp	r3,sp[0x28]
8000a64e:	14 98       	mov	r8,r10
8000a650:	16 99       	mov	r9,r11
8000a652:	fa e9 00 08 	st.d	sp[8],r8
8000a656:	c2 f8       	rjmp	8000a6b4 <_dtoa_r+0x418>
8000a658:	ec 08 11 00 	rsub	r8,r6,0
8000a65c:	c0 31       	brne	8000a662 <_dtoa_r+0x3c6>
8000a65e:	30 25       	mov	r5,2
8000a660:	c2 a8       	rjmp	8000a6b4 <_dtoa_r+0x418>
8000a662:	fe cc c3 d2 	sub	r12,pc,-15406
8000a666:	f0 04 14 04 	asr	r4,r8,0x4
8000a66a:	50 1c       	stdsp	sp[0x4],r12
8000a66c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a670:	fe c9 c4 a8 	sub	r9,pc,-15192
8000a674:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a678:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a67c:	e0 a0 0c 78 	rcall	8000bf6c <__avr32_f64_mul>
8000a680:	40 1c       	lddsp	r12,sp[0x4]
8000a682:	50 63       	stdsp	sp[0x18],r3
8000a684:	30 25       	mov	r5,2
8000a686:	0c 93       	mov	r3,r6
8000a688:	fa eb 00 08 	st.d	sp[8],r10
8000a68c:	18 96       	mov	r6,r12
8000a68e:	c0 f8       	rjmp	8000a6ac <_dtoa_r+0x410>
8000a690:	fa ea 00 08 	ld.d	r10,sp[8]
8000a694:	ed b4 00 00 	bld	r4,0x0
8000a698:	c0 81       	brne	8000a6a8 <_dtoa_r+0x40c>
8000a69a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a69e:	2f f5       	sub	r5,-1
8000a6a0:	e0 a0 0c 66 	rcall	8000bf6c <__avr32_f64_mul>
8000a6a4:	fa eb 00 08 	st.d	sp[8],r10
8000a6a8:	a1 54       	asr	r4,0x1
8000a6aa:	2f 86       	sub	r6,-8
8000a6ac:	58 04       	cp.w	r4,0
8000a6ae:	cf 11       	brne	8000a690 <_dtoa_r+0x3f4>
8000a6b0:	06 96       	mov	r6,r3
8000a6b2:	40 63       	lddsp	r3,sp[0x18]
8000a6b4:	41 4a       	lddsp	r10,sp[0x50]
8000a6b6:	58 0a       	cp.w	r10,0
8000a6b8:	c2 a0       	breq	8000a70c <_dtoa_r+0x470>
8000a6ba:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6be:	58 01       	cp.w	r1,0
8000a6c0:	5f 94       	srgt	r4
8000a6c2:	fa e9 00 18 	st.d	sp[24],r8
8000a6c6:	30 08       	mov	r8,0
8000a6c8:	fc 19 3f f0 	movh	r9,0x3ff0
8000a6cc:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6d0:	e0 a0 0f 60 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a6d4:	f9 bc 00 00 	moveq	r12,0
8000a6d8:	f9 bc 01 01 	movne	r12,1
8000a6dc:	e9 ec 00 0c 	and	r12,r4,r12
8000a6e0:	c1 60       	breq	8000a70c <_dtoa_r+0x470>
8000a6e2:	40 98       	lddsp	r8,sp[0x24]
8000a6e4:	58 08       	cp.w	r8,0
8000a6e6:	e0 8a 00 f1 	brle	8000a8c8 <_dtoa_r+0x62c>
8000a6ea:	30 08       	mov	r8,0
8000a6ec:	fc 19 40 24 	movh	r9,0x4024
8000a6f0:	ec c4 00 01 	sub	r4,r6,1
8000a6f4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6f8:	2f f5       	sub	r5,-1
8000a6fa:	50 64       	stdsp	sp[0x18],r4
8000a6fc:	e0 a0 0c 38 	rcall	8000bf6c <__avr32_f64_mul>
8000a700:	40 94       	lddsp	r4,sp[0x24]
8000a702:	14 98       	mov	r8,r10
8000a704:	16 99       	mov	r9,r11
8000a706:	fa e9 00 08 	st.d	sp[8],r8
8000a70a:	c0 38       	rjmp	8000a710 <_dtoa_r+0x474>
8000a70c:	50 66       	stdsp	sp[0x18],r6
8000a70e:	02 94       	mov	r4,r1
8000a710:	0a 9c       	mov	r12,r5
8000a712:	e0 a0 0e 88 	rcall	8000c422 <__avr32_s32_to_f64>
8000a716:	fa e8 00 08 	ld.d	r8,sp[8]
8000a71a:	e0 a0 0c 29 	rcall	8000bf6c <__avr32_f64_mul>
8000a71e:	30 08       	mov	r8,0
8000a720:	fc 19 40 1c 	movh	r9,0x401c
8000a724:	e0 a0 0d de 	rcall	8000c2e0 <__avr32_f64_add>
8000a728:	14 98       	mov	r8,r10
8000a72a:	16 99       	mov	r9,r11
8000a72c:	fa e9 00 28 	st.d	sp[40],r8
8000a730:	fc 18 fc c0 	movh	r8,0xfcc0
8000a734:	40 a5       	lddsp	r5,sp[0x28]
8000a736:	10 05       	add	r5,r8
8000a738:	50 a5       	stdsp	sp[0x28],r5
8000a73a:	58 04       	cp.w	r4,0
8000a73c:	c2 11       	brne	8000a77e <_dtoa_r+0x4e2>
8000a73e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a742:	30 08       	mov	r8,0
8000a744:	fc 19 40 14 	movh	r9,0x4014
8000a748:	e0 a0 0c fe 	rcall	8000c144 <__avr32_f64_sub>
8000a74c:	40 bc       	lddsp	r12,sp[0x2c]
8000a74e:	fa eb 00 08 	st.d	sp[8],r10
8000a752:	14 98       	mov	r8,r10
8000a754:	16 99       	mov	r9,r11
8000a756:	18 9a       	mov	r10,r12
8000a758:	0a 9b       	mov	r11,r5
8000a75a:	e0 a0 0f 1b 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a75e:	e0 81 02 54 	brne	8000ac06 <_dtoa_r+0x96a>
8000a762:	0a 98       	mov	r8,r5
8000a764:	40 b9       	lddsp	r9,sp[0x2c]
8000a766:	ee 18 80 00 	eorh	r8,0x8000
8000a76a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a76e:	10 95       	mov	r5,r8
8000a770:	12 98       	mov	r8,r9
8000a772:	0a 99       	mov	r9,r5
8000a774:	e0 a0 0f 0e 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a778:	e0 81 02 3e 	brne	8000abf4 <_dtoa_r+0x958>
8000a77c:	ca 68       	rjmp	8000a8c8 <_dtoa_r+0x62c>
8000a77e:	fe c9 c5 b6 	sub	r9,pc,-14922
8000a782:	e8 c8 00 01 	sub	r8,r4,1
8000a786:	40 d5       	lddsp	r5,sp[0x34]
8000a788:	58 05       	cp.w	r5,0
8000a78a:	c4 f0       	breq	8000a828 <_dtoa_r+0x58c>
8000a78c:	30 0c       	mov	r12,0
8000a78e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a792:	51 3c       	stdsp	sp[0x4c],r12
8000a794:	30 0a       	mov	r10,0
8000a796:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a79a:	e0 a0 0f 2f 	rcall	8000c5f8 <__avr32_f64_div>
8000a79e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7a2:	40 85       	lddsp	r5,sp[0x20]
8000a7a4:	e0 a0 0c d0 	rcall	8000c144 <__avr32_f64_sub>
8000a7a8:	fa eb 00 28 	st.d	sp[40],r10
8000a7ac:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7b0:	e0 a0 0e 22 	rcall	8000c3f4 <__avr32_f64_to_s32>
8000a7b4:	51 6c       	stdsp	sp[0x58],r12
8000a7b6:	e0 a0 0e 36 	rcall	8000c422 <__avr32_s32_to_f64>
8000a7ba:	14 98       	mov	r8,r10
8000a7bc:	16 99       	mov	r9,r11
8000a7be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7c2:	e0 a0 0c c1 	rcall	8000c144 <__avr32_f64_sub>
8000a7c6:	fa eb 00 08 	st.d	sp[8],r10
8000a7ca:	41 68       	lddsp	r8,sp[0x58]
8000a7cc:	2d 08       	sub	r8,-48
8000a7ce:	0a c8       	st.b	r5++,r8
8000a7d0:	41 39       	lddsp	r9,sp[0x4c]
8000a7d2:	2f f9       	sub	r9,-1
8000a7d4:	51 39       	stdsp	sp[0x4c],r9
8000a7d6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7da:	e0 a0 0e db 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a7de:	e0 81 03 39 	brne	8000ae50 <_dtoa_r+0xbb4>
8000a7e2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7e6:	30 0a       	mov	r10,0
8000a7e8:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a7ec:	e0 a0 0c ac 	rcall	8000c144 <__avr32_f64_sub>
8000a7f0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7f4:	e0 a0 0e ce 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a7f8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7fc:	30 08       	mov	r8,0
8000a7fe:	fc 19 40 24 	movh	r9,0x4024
8000a802:	e0 81 00 da 	brne	8000a9b6 <_dtoa_r+0x71a>
8000a806:	41 3c       	lddsp	r12,sp[0x4c]
8000a808:	08 3c       	cp.w	r12,r4
8000a80a:	c5 f4       	brge	8000a8c8 <_dtoa_r+0x62c>
8000a80c:	e0 a0 0b b0 	rcall	8000bf6c <__avr32_f64_mul>
8000a810:	30 08       	mov	r8,0
8000a812:	fa eb 00 28 	st.d	sp[40],r10
8000a816:	fc 19 40 24 	movh	r9,0x4024
8000a81a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a81e:	e0 a0 0b a7 	rcall	8000bf6c <__avr32_f64_mul>
8000a822:	fa eb 00 08 	st.d	sp[8],r10
8000a826:	cc 3b       	rjmp	8000a7ac <_dtoa_r+0x510>
8000a828:	40 85       	lddsp	r5,sp[0x20]
8000a82a:	08 05       	add	r5,r4
8000a82c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a830:	51 35       	stdsp	sp[0x4c],r5
8000a832:	fa e8 00 28 	ld.d	r8,sp[40]
8000a836:	40 85       	lddsp	r5,sp[0x20]
8000a838:	e0 a0 0b 9a 	rcall	8000bf6c <__avr32_f64_mul>
8000a83c:	fa eb 00 28 	st.d	sp[40],r10
8000a840:	fa ea 00 08 	ld.d	r10,sp[8]
8000a844:	e0 a0 0d d8 	rcall	8000c3f4 <__avr32_f64_to_s32>
8000a848:	51 6c       	stdsp	sp[0x58],r12
8000a84a:	e0 a0 0d ec 	rcall	8000c422 <__avr32_s32_to_f64>
8000a84e:	14 98       	mov	r8,r10
8000a850:	16 99       	mov	r9,r11
8000a852:	fa ea 00 08 	ld.d	r10,sp[8]
8000a856:	e0 a0 0c 77 	rcall	8000c144 <__avr32_f64_sub>
8000a85a:	fa eb 00 08 	st.d	sp[8],r10
8000a85e:	41 68       	lddsp	r8,sp[0x58]
8000a860:	2d 08       	sub	r8,-48
8000a862:	0a c8       	st.b	r5++,r8
8000a864:	41 3c       	lddsp	r12,sp[0x4c]
8000a866:	18 35       	cp.w	r5,r12
8000a868:	c2 81       	brne	8000a8b8 <_dtoa_r+0x61c>
8000a86a:	30 08       	mov	r8,0
8000a86c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a870:	fa ea 00 28 	ld.d	r10,sp[40]
8000a874:	e0 a0 0d 36 	rcall	8000c2e0 <__avr32_f64_add>
8000a878:	40 85       	lddsp	r5,sp[0x20]
8000a87a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a87e:	08 05       	add	r5,r4
8000a880:	e0 a0 0e 88 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a884:	e0 81 00 99 	brne	8000a9b6 <_dtoa_r+0x71a>
8000a888:	fa e8 00 28 	ld.d	r8,sp[40]
8000a88c:	30 0a       	mov	r10,0
8000a88e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a892:	e0 a0 0c 59 	rcall	8000c144 <__avr32_f64_sub>
8000a896:	14 98       	mov	r8,r10
8000a898:	16 99       	mov	r9,r11
8000a89a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a89e:	e0 a0 0e 79 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a8a2:	c1 30       	breq	8000a8c8 <_dtoa_r+0x62c>
8000a8a4:	33 09       	mov	r9,48
8000a8a6:	0a 98       	mov	r8,r5
8000a8a8:	11 7a       	ld.ub	r10,--r8
8000a8aa:	f2 0a 18 00 	cp.b	r10,r9
8000a8ae:	e0 81 02 d1 	brne	8000ae50 <_dtoa_r+0xbb4>
8000a8b2:	10 95       	mov	r5,r8
8000a8b4:	cf 9b       	rjmp	8000a8a6 <_dtoa_r+0x60a>
8000a8b6:	d7 03       	nop
8000a8b8:	30 08       	mov	r8,0
8000a8ba:	fc 19 40 24 	movh	r9,0x4024
8000a8be:	e0 a0 0b 57 	rcall	8000bf6c <__avr32_f64_mul>
8000a8c2:	fa eb 00 08 	st.d	sp[8],r10
8000a8c6:	cb db       	rjmp	8000a840 <_dtoa_r+0x5a4>
8000a8c8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a8cc:	fa eb 00 08 	st.d	sp[8],r10
8000a8d0:	58 e6       	cp.w	r6,14
8000a8d2:	5f ab       	srle	r11
8000a8d4:	41 8a       	lddsp	r10,sp[0x60]
8000a8d6:	30 08       	mov	r8,0
8000a8d8:	f4 09 11 ff 	rsub	r9,r10,-1
8000a8dc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a8e0:	f0 09 18 00 	cp.b	r9,r8
8000a8e4:	e0 80 00 82 	breq	8000a9e8 <_dtoa_r+0x74c>
8000a8e8:	40 ea       	lddsp	r10,sp[0x38]
8000a8ea:	58 01       	cp.w	r1,0
8000a8ec:	5f a9       	srle	r9
8000a8ee:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a8f2:	fe ca c7 2a 	sub	r10,pc,-14550
8000a8f6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a8fa:	fa e5 00 10 	st.d	sp[16],r4
8000a8fe:	f0 09 18 00 	cp.b	r9,r8
8000a902:	c1 40       	breq	8000a92a <_dtoa_r+0x68e>
8000a904:	58 01       	cp.w	r1,0
8000a906:	e0 81 01 77 	brne	8000abf4 <_dtoa_r+0x958>
8000a90a:	30 08       	mov	r8,0
8000a90c:	fc 19 40 14 	movh	r9,0x4014
8000a910:	08 9a       	mov	r10,r4
8000a912:	0a 9b       	mov	r11,r5
8000a914:	e0 a0 0b 2c 	rcall	8000bf6c <__avr32_f64_mul>
8000a918:	fa e8 00 08 	ld.d	r8,sp[8]
8000a91c:	e0 a0 0e 06 	rcall	8000c528 <__avr32_f64_cmp_ge>
8000a920:	e0 81 01 6a 	brne	8000abf4 <_dtoa_r+0x958>
8000a924:	02 92       	mov	r2,r1
8000a926:	e0 8f 01 72 	bral	8000ac0a <_dtoa_r+0x96e>
8000a92a:	40 85       	lddsp	r5,sp[0x20]
8000a92c:	30 14       	mov	r4,1
8000a92e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a932:	fa ea 00 08 	ld.d	r10,sp[8]
8000a936:	e0 a0 0e 61 	rcall	8000c5f8 <__avr32_f64_div>
8000a93a:	e0 a0 0d 5d 	rcall	8000c3f4 <__avr32_f64_to_s32>
8000a93e:	18 92       	mov	r2,r12
8000a940:	e0 a0 0d 71 	rcall	8000c422 <__avr32_s32_to_f64>
8000a944:	fa e8 00 10 	ld.d	r8,sp[16]
8000a948:	e0 a0 0b 12 	rcall	8000bf6c <__avr32_f64_mul>
8000a94c:	14 98       	mov	r8,r10
8000a94e:	16 99       	mov	r9,r11
8000a950:	fa ea 00 08 	ld.d	r10,sp[8]
8000a954:	e0 a0 0b f8 	rcall	8000c144 <__avr32_f64_sub>
8000a958:	fa eb 00 08 	st.d	sp[8],r10
8000a95c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a960:	0a c8       	st.b	r5++,r8
8000a962:	fc 19 40 24 	movh	r9,0x4024
8000a966:	30 08       	mov	r8,0
8000a968:	02 34       	cp.w	r4,r1
8000a96a:	c3 31       	brne	8000a9d0 <_dtoa_r+0x734>
8000a96c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a970:	e0 a0 0c b8 	rcall	8000c2e0 <__avr32_f64_add>
8000a974:	16 91       	mov	r1,r11
8000a976:	14 90       	mov	r0,r10
8000a978:	14 98       	mov	r8,r10
8000a97a:	02 99       	mov	r9,r1
8000a97c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a980:	e0 a0 0e 08 	rcall	8000c590 <__avr32_f64_cmp_lt>
8000a984:	c1 a1       	brne	8000a9b8 <_dtoa_r+0x71c>
8000a986:	fa e8 00 10 	ld.d	r8,sp[16]
8000a98a:	00 9a       	mov	r10,r0
8000a98c:	02 9b       	mov	r11,r1
8000a98e:	e0 a0 0d ba 	rcall	8000c502 <__avr32_f64_cmp_eq>
8000a992:	e0 80 02 5e 	breq	8000ae4e <_dtoa_r+0xbb2>
8000a996:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a99a:	c0 f1       	brne	8000a9b8 <_dtoa_r+0x71c>
8000a99c:	e0 8f 02 59 	bral	8000ae4e <_dtoa_r+0xbb2>
8000a9a0:	40 8a       	lddsp	r10,sp[0x20]
8000a9a2:	14 38       	cp.w	r8,r10
8000a9a4:	c0 30       	breq	8000a9aa <_dtoa_r+0x70e>
8000a9a6:	10 95       	mov	r5,r8
8000a9a8:	c0 98       	rjmp	8000a9ba <_dtoa_r+0x71e>
8000a9aa:	33 08       	mov	r8,48
8000a9ac:	40 89       	lddsp	r9,sp[0x20]
8000a9ae:	2f f6       	sub	r6,-1
8000a9b0:	b2 88       	st.b	r9[0x0],r8
8000a9b2:	40 88       	lddsp	r8,sp[0x20]
8000a9b4:	c0 88       	rjmp	8000a9c4 <_dtoa_r+0x728>
8000a9b6:	40 66       	lddsp	r6,sp[0x18]
8000a9b8:	33 99       	mov	r9,57
8000a9ba:	0a 98       	mov	r8,r5
8000a9bc:	11 7a       	ld.ub	r10,--r8
8000a9be:	f2 0a 18 00 	cp.b	r10,r9
8000a9c2:	ce f0       	breq	8000a9a0 <_dtoa_r+0x704>
8000a9c4:	50 66       	stdsp	sp[0x18],r6
8000a9c6:	11 89       	ld.ub	r9,r8[0x0]
8000a9c8:	2f f9       	sub	r9,-1
8000a9ca:	b0 89       	st.b	r8[0x0],r9
8000a9cc:	e0 8f 02 42 	bral	8000ae50 <_dtoa_r+0xbb4>
8000a9d0:	e0 a0 0a ce 	rcall	8000bf6c <__avr32_f64_mul>
8000a9d4:	2f f4       	sub	r4,-1
8000a9d6:	fa eb 00 08 	st.d	sp[8],r10
8000a9da:	30 08       	mov	r8,0
8000a9dc:	30 09       	mov	r9,0
8000a9de:	e0 a0 0d 92 	rcall	8000c502 <__avr32_f64_cmp_eq>
8000a9e2:	ca 60       	breq	8000a92e <_dtoa_r+0x692>
8000a9e4:	e0 8f 02 35 	bral	8000ae4e <_dtoa_r+0xbb2>
8000a9e8:	40 d8       	lddsp	r8,sp[0x34]
8000a9ea:	58 08       	cp.w	r8,0
8000a9ec:	c0 51       	brne	8000a9f6 <_dtoa_r+0x75a>
8000a9ee:	04 98       	mov	r8,r2
8000a9f0:	00 95       	mov	r5,r0
8000a9f2:	40 d4       	lddsp	r4,sp[0x34]
8000a9f4:	c3 78       	rjmp	8000aa62 <_dtoa_r+0x7c6>
8000a9f6:	40 c5       	lddsp	r5,sp[0x30]
8000a9f8:	58 15       	cp.w	r5,1
8000a9fa:	e0 89 00 0f 	brgt	8000aa18 <_dtoa_r+0x77c>
8000a9fe:	41 74       	lddsp	r4,sp[0x5c]
8000aa00:	58 04       	cp.w	r4,0
8000aa02:	c0 40       	breq	8000aa0a <_dtoa_r+0x76e>
8000aa04:	f4 c9 fb cd 	sub	r9,r10,-1075
8000aa08:	c0 48       	rjmp	8000aa10 <_dtoa_r+0x774>
8000aa0a:	41 99       	lddsp	r9,sp[0x64]
8000aa0c:	f2 09 11 36 	rsub	r9,r9,54
8000aa10:	04 98       	mov	r8,r2
8000aa12:	00 95       	mov	r5,r0
8000aa14:	c1 c8       	rjmp	8000aa4c <_dtoa_r+0x7b0>
8000aa16:	d7 03       	nop
8000aa18:	e2 c8 00 01 	sub	r8,r1,1
8000aa1c:	58 01       	cp.w	r1,0
8000aa1e:	e0 05 17 40 	movge	r5,r0
8000aa22:	e2 09 17 40 	movge	r9,r1
8000aa26:	e1 d1 e5 15 	sublt	r5,r0,r1
8000aa2a:	f9 b9 05 00 	movlt	r9,0
8000aa2e:	10 32       	cp.w	r2,r8
8000aa30:	e5 d8 e4 18 	subge	r8,r2,r8
8000aa34:	f1 d2 e5 18 	sublt	r8,r8,r2
8000aa38:	e5 d8 e5 02 	addlt	r2,r2,r8
8000aa3c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000aa40:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000aa44:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000aa48:	f9 b8 05 00 	movlt	r8,0
8000aa4c:	40 4b       	lddsp	r11,sp[0x10]
8000aa4e:	12 0b       	add	r11,r9
8000aa50:	50 08       	stdsp	sp[0x0],r8
8000aa52:	50 4b       	stdsp	sp[0x10],r11
8000aa54:	12 00       	add	r0,r9
8000aa56:	30 1b       	mov	r11,1
8000aa58:	0e 9c       	mov	r12,r7
8000aa5a:	e0 a0 08 a7 	rcall	8000bba8 <__i2b>
8000aa5e:	40 08       	lddsp	r8,sp[0x0]
8000aa60:	18 94       	mov	r4,r12
8000aa62:	40 4a       	lddsp	r10,sp[0x10]
8000aa64:	58 05       	cp.w	r5,0
8000aa66:	5f 99       	srgt	r9
8000aa68:	58 0a       	cp.w	r10,0
8000aa6a:	5f 9a       	srgt	r10
8000aa6c:	f5 e9 00 09 	and	r9,r10,r9
8000aa70:	c0 80       	breq	8000aa80 <_dtoa_r+0x7e4>
8000aa72:	40 4c       	lddsp	r12,sp[0x10]
8000aa74:	f8 05 0d 49 	min	r9,r12,r5
8000aa78:	12 1c       	sub	r12,r9
8000aa7a:	12 10       	sub	r0,r9
8000aa7c:	50 4c       	stdsp	sp[0x10],r12
8000aa7e:	12 15       	sub	r5,r9
8000aa80:	58 02       	cp.w	r2,0
8000aa82:	e0 8a 00 27 	brle	8000aad0 <_dtoa_r+0x834>
8000aa86:	40 db       	lddsp	r11,sp[0x34]
8000aa88:	58 0b       	cp.w	r11,0
8000aa8a:	c1 d0       	breq	8000aac4 <_dtoa_r+0x828>
8000aa8c:	58 08       	cp.w	r8,0
8000aa8e:	e0 8a 00 17 	brle	8000aabc <_dtoa_r+0x820>
8000aa92:	10 9a       	mov	r10,r8
8000aa94:	50 08       	stdsp	sp[0x0],r8
8000aa96:	08 9b       	mov	r11,r4
8000aa98:	0e 9c       	mov	r12,r7
8000aa9a:	e0 a0 08 cd 	rcall	8000bc34 <__pow5mult>
8000aa9e:	06 9a       	mov	r10,r3
8000aaa0:	18 9b       	mov	r11,r12
8000aaa2:	18 94       	mov	r4,r12
8000aaa4:	0e 9c       	mov	r12,r7
8000aaa6:	e0 a0 08 01 	rcall	8000baa8 <__multiply>
8000aaaa:	18 99       	mov	r9,r12
8000aaac:	06 9b       	mov	r11,r3
8000aaae:	50 19       	stdsp	sp[0x4],r9
8000aab0:	0e 9c       	mov	r12,r7
8000aab2:	e0 a0 06 ad 	rcall	8000b80c <_Bfree>
8000aab6:	40 19       	lddsp	r9,sp[0x4]
8000aab8:	40 08       	lddsp	r8,sp[0x0]
8000aaba:	12 93       	mov	r3,r9
8000aabc:	e4 08 01 0a 	sub	r10,r2,r8
8000aac0:	c0 80       	breq	8000aad0 <_dtoa_r+0x834>
8000aac2:	c0 28       	rjmp	8000aac6 <_dtoa_r+0x82a>
8000aac4:	04 9a       	mov	r10,r2
8000aac6:	06 9b       	mov	r11,r3
8000aac8:	0e 9c       	mov	r12,r7
8000aaca:	e0 a0 08 b5 	rcall	8000bc34 <__pow5mult>
8000aace:	18 93       	mov	r3,r12
8000aad0:	30 1b       	mov	r11,1
8000aad2:	0e 9c       	mov	r12,r7
8000aad4:	e0 a0 08 6a 	rcall	8000bba8 <__i2b>
8000aad8:	41 1a       	lddsp	r10,sp[0x44]
8000aada:	18 92       	mov	r2,r12
8000aadc:	58 0a       	cp.w	r10,0
8000aade:	e0 8a 00 07 	brle	8000aaec <_dtoa_r+0x850>
8000aae2:	18 9b       	mov	r11,r12
8000aae4:	0e 9c       	mov	r12,r7
8000aae6:	e0 a0 08 a7 	rcall	8000bc34 <__pow5mult>
8000aaea:	18 92       	mov	r2,r12
8000aaec:	40 c9       	lddsp	r9,sp[0x30]
8000aaee:	58 19       	cp.w	r9,1
8000aaf0:	e0 89 00 14 	brgt	8000ab18 <_dtoa_r+0x87c>
8000aaf4:	40 38       	lddsp	r8,sp[0xc]
8000aaf6:	58 08       	cp.w	r8,0
8000aaf8:	c1 01       	brne	8000ab18 <_dtoa_r+0x87c>
8000aafa:	40 29       	lddsp	r9,sp[0x8]
8000aafc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ab00:	c0 c1       	brne	8000ab18 <_dtoa_r+0x87c>
8000ab02:	12 98       	mov	r8,r9
8000ab04:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ab08:	c0 80       	breq	8000ab18 <_dtoa_r+0x87c>
8000ab0a:	40 4c       	lddsp	r12,sp[0x10]
8000ab0c:	30 1b       	mov	r11,1
8000ab0e:	2f fc       	sub	r12,-1
8000ab10:	2f f0       	sub	r0,-1
8000ab12:	50 4c       	stdsp	sp[0x10],r12
8000ab14:	50 6b       	stdsp	sp[0x18],r11
8000ab16:	c0 38       	rjmp	8000ab1c <_dtoa_r+0x880>
8000ab18:	30 0a       	mov	r10,0
8000ab1a:	50 6a       	stdsp	sp[0x18],r10
8000ab1c:	41 19       	lddsp	r9,sp[0x44]
8000ab1e:	58 09       	cp.w	r9,0
8000ab20:	c0 31       	brne	8000ab26 <_dtoa_r+0x88a>
8000ab22:	30 1c       	mov	r12,1
8000ab24:	c0 98       	rjmp	8000ab36 <_dtoa_r+0x89a>
8000ab26:	64 48       	ld.w	r8,r2[0x10]
8000ab28:	2f c8       	sub	r8,-4
8000ab2a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ab2e:	e0 a0 05 df 	rcall	8000b6ec <__hi0bits>
8000ab32:	f8 0c 11 20 	rsub	r12,r12,32
8000ab36:	40 4b       	lddsp	r11,sp[0x10]
8000ab38:	f8 0b 00 08 	add	r8,r12,r11
8000ab3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab40:	c0 c0       	breq	8000ab58 <_dtoa_r+0x8bc>
8000ab42:	f0 08 11 20 	rsub	r8,r8,32
8000ab46:	58 48       	cp.w	r8,4
8000ab48:	e0 8a 00 06 	brle	8000ab54 <_dtoa_r+0x8b8>
8000ab4c:	20 48       	sub	r8,4
8000ab4e:	10 0b       	add	r11,r8
8000ab50:	50 4b       	stdsp	sp[0x10],r11
8000ab52:	c0 78       	rjmp	8000ab60 <_dtoa_r+0x8c4>
8000ab54:	58 48       	cp.w	r8,4
8000ab56:	c0 70       	breq	8000ab64 <_dtoa_r+0x8c8>
8000ab58:	40 4a       	lddsp	r10,sp[0x10]
8000ab5a:	2e 48       	sub	r8,-28
8000ab5c:	10 0a       	add	r10,r8
8000ab5e:	50 4a       	stdsp	sp[0x10],r10
8000ab60:	10 00       	add	r0,r8
8000ab62:	10 05       	add	r5,r8
8000ab64:	58 00       	cp.w	r0,0
8000ab66:	e0 8a 00 08 	brle	8000ab76 <_dtoa_r+0x8da>
8000ab6a:	06 9b       	mov	r11,r3
8000ab6c:	00 9a       	mov	r10,r0
8000ab6e:	0e 9c       	mov	r12,r7
8000ab70:	e0 a0 07 58 	rcall	8000ba20 <__lshift>
8000ab74:	18 93       	mov	r3,r12
8000ab76:	40 49       	lddsp	r9,sp[0x10]
8000ab78:	58 09       	cp.w	r9,0
8000ab7a:	e0 8a 00 08 	brle	8000ab8a <_dtoa_r+0x8ee>
8000ab7e:	04 9b       	mov	r11,r2
8000ab80:	12 9a       	mov	r10,r9
8000ab82:	0e 9c       	mov	r12,r7
8000ab84:	e0 a0 07 4e 	rcall	8000ba20 <__lshift>
8000ab88:	18 92       	mov	r2,r12
8000ab8a:	41 48       	lddsp	r8,sp[0x50]
8000ab8c:	58 08       	cp.w	r8,0
8000ab8e:	c1 b0       	breq	8000abc4 <_dtoa_r+0x928>
8000ab90:	04 9b       	mov	r11,r2
8000ab92:	06 9c       	mov	r12,r3
8000ab94:	e0 a0 06 23 	rcall	8000b7da <__mcmp>
8000ab98:	c1 64       	brge	8000abc4 <_dtoa_r+0x928>
8000ab9a:	06 9b       	mov	r11,r3
8000ab9c:	30 09       	mov	r9,0
8000ab9e:	30 aa       	mov	r10,10
8000aba0:	0e 9c       	mov	r12,r7
8000aba2:	e0 a0 08 0b 	rcall	8000bbb8 <__multadd>
8000aba6:	20 16       	sub	r6,1
8000aba8:	18 93       	mov	r3,r12
8000abaa:	40 dc       	lddsp	r12,sp[0x34]
8000abac:	58 0c       	cp.w	r12,0
8000abae:	c0 31       	brne	8000abb4 <_dtoa_r+0x918>
8000abb0:	40 91       	lddsp	r1,sp[0x24]
8000abb2:	c0 98       	rjmp	8000abc4 <_dtoa_r+0x928>
8000abb4:	08 9b       	mov	r11,r4
8000abb6:	40 91       	lddsp	r1,sp[0x24]
8000abb8:	30 09       	mov	r9,0
8000abba:	30 aa       	mov	r10,10
8000abbc:	0e 9c       	mov	r12,r7
8000abbe:	e0 a0 07 fd 	rcall	8000bbb8 <__multadd>
8000abc2:	18 94       	mov	r4,r12
8000abc4:	58 01       	cp.w	r1,0
8000abc6:	5f a9       	srle	r9
8000abc8:	40 cb       	lddsp	r11,sp[0x30]
8000abca:	58 2b       	cp.w	r11,2
8000abcc:	5f 98       	srgt	r8
8000abce:	f3 e8 00 08 	and	r8,r9,r8
8000abd2:	c2 50       	breq	8000ac1c <_dtoa_r+0x980>
8000abd4:	58 01       	cp.w	r1,0
8000abd6:	c1 11       	brne	8000abf8 <_dtoa_r+0x95c>
8000abd8:	04 9b       	mov	r11,r2
8000abda:	02 99       	mov	r9,r1
8000abdc:	30 5a       	mov	r10,5
8000abde:	0e 9c       	mov	r12,r7
8000abe0:	e0 a0 07 ec 	rcall	8000bbb8 <__multadd>
8000abe4:	18 92       	mov	r2,r12
8000abe6:	18 9b       	mov	r11,r12
8000abe8:	06 9c       	mov	r12,r3
8000abea:	e0 a0 05 f8 	rcall	8000b7da <__mcmp>
8000abee:	e0 89 00 0f 	brgt	8000ac0c <_dtoa_r+0x970>
8000abf2:	c0 38       	rjmp	8000abf8 <_dtoa_r+0x95c>
8000abf4:	30 02       	mov	r2,0
8000abf6:	04 94       	mov	r4,r2
8000abf8:	40 ea       	lddsp	r10,sp[0x38]
8000abfa:	30 09       	mov	r9,0
8000abfc:	5c da       	com	r10
8000abfe:	40 85       	lddsp	r5,sp[0x20]
8000ac00:	50 6a       	stdsp	sp[0x18],r10
8000ac02:	50 49       	stdsp	sp[0x10],r9
8000ac04:	c0 f9       	rjmp	8000ae22 <_dtoa_r+0xb86>
8000ac06:	08 92       	mov	r2,r4
8000ac08:	40 66       	lddsp	r6,sp[0x18]
8000ac0a:	04 94       	mov	r4,r2
8000ac0c:	2f f6       	sub	r6,-1
8000ac0e:	50 66       	stdsp	sp[0x18],r6
8000ac10:	33 18       	mov	r8,49
8000ac12:	40 85       	lddsp	r5,sp[0x20]
8000ac14:	0a c8       	st.b	r5++,r8
8000ac16:	30 08       	mov	r8,0
8000ac18:	50 48       	stdsp	sp[0x10],r8
8000ac1a:	c0 49       	rjmp	8000ae22 <_dtoa_r+0xb86>
8000ac1c:	40 dc       	lddsp	r12,sp[0x34]
8000ac1e:	58 0c       	cp.w	r12,0
8000ac20:	e0 80 00 b5 	breq	8000ad8a <_dtoa_r+0xaee>
8000ac24:	58 05       	cp.w	r5,0
8000ac26:	e0 8a 00 08 	brle	8000ac36 <_dtoa_r+0x99a>
8000ac2a:	08 9b       	mov	r11,r4
8000ac2c:	0a 9a       	mov	r10,r5
8000ac2e:	0e 9c       	mov	r12,r7
8000ac30:	e0 a0 06 f8 	rcall	8000ba20 <__lshift>
8000ac34:	18 94       	mov	r4,r12
8000ac36:	40 6b       	lddsp	r11,sp[0x18]
8000ac38:	58 0b       	cp.w	r11,0
8000ac3a:	c0 31       	brne	8000ac40 <_dtoa_r+0x9a4>
8000ac3c:	08 9c       	mov	r12,r4
8000ac3e:	c1 38       	rjmp	8000ac64 <_dtoa_r+0x9c8>
8000ac40:	68 1b       	ld.w	r11,r4[0x4]
8000ac42:	0e 9c       	mov	r12,r7
8000ac44:	e0 a0 05 fe 	rcall	8000b840 <_Balloc>
8000ac48:	68 4a       	ld.w	r10,r4[0x10]
8000ac4a:	18 95       	mov	r5,r12
8000ac4c:	e8 cb ff f4 	sub	r11,r4,-12
8000ac50:	2f ea       	sub	r10,-2
8000ac52:	2f 4c       	sub	r12,-12
8000ac54:	a3 6a       	lsl	r10,0x2
8000ac56:	fe b0 e6 4f 	rcall	800078f4 <memcpy>
8000ac5a:	0a 9b       	mov	r11,r5
8000ac5c:	30 1a       	mov	r10,1
8000ac5e:	0e 9c       	mov	r12,r7
8000ac60:	e0 a0 06 e0 	rcall	8000ba20 <__lshift>
8000ac64:	50 44       	stdsp	sp[0x10],r4
8000ac66:	40 3a       	lddsp	r10,sp[0xc]
8000ac68:	30 19       	mov	r9,1
8000ac6a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ac6e:	18 94       	mov	r4,r12
8000ac70:	50 da       	stdsp	sp[0x34],r10
8000ac72:	40 85       	lddsp	r5,sp[0x20]
8000ac74:	50 99       	stdsp	sp[0x24],r9
8000ac76:	50 26       	stdsp	sp[0x8],r6
8000ac78:	50 e1       	stdsp	sp[0x38],r1
8000ac7a:	04 9b       	mov	r11,r2
8000ac7c:	06 9c       	mov	r12,r3
8000ac7e:	fe b0 fa 7f 	rcall	8000a17c <quorem>
8000ac82:	40 4b       	lddsp	r11,sp[0x10]
8000ac84:	f8 c0 ff d0 	sub	r0,r12,-48
8000ac88:	06 9c       	mov	r12,r3
8000ac8a:	e0 a0 05 a8 	rcall	8000b7da <__mcmp>
8000ac8e:	08 9a       	mov	r10,r4
8000ac90:	50 6c       	stdsp	sp[0x18],r12
8000ac92:	04 9b       	mov	r11,r2
8000ac94:	0e 9c       	mov	r12,r7
8000ac96:	e0 a0 06 5d 	rcall	8000b950 <__mdiff>
8000ac9a:	18 91       	mov	r1,r12
8000ac9c:	78 38       	ld.w	r8,r12[0xc]
8000ac9e:	58 08       	cp.w	r8,0
8000aca0:	c0 30       	breq	8000aca6 <_dtoa_r+0xa0a>
8000aca2:	30 16       	mov	r6,1
8000aca4:	c0 68       	rjmp	8000acb0 <_dtoa_r+0xa14>
8000aca6:	18 9b       	mov	r11,r12
8000aca8:	06 9c       	mov	r12,r3
8000acaa:	e0 a0 05 98 	rcall	8000b7da <__mcmp>
8000acae:	18 96       	mov	r6,r12
8000acb0:	0e 9c       	mov	r12,r7
8000acb2:	02 9b       	mov	r11,r1
8000acb4:	e0 a0 05 ac 	rcall	8000b80c <_Bfree>
8000acb8:	40 cc       	lddsp	r12,sp[0x30]
8000acba:	ed ec 10 08 	or	r8,r6,r12
8000acbe:	c0 d1       	brne	8000acd8 <_dtoa_r+0xa3c>
8000acc0:	40 db       	lddsp	r11,sp[0x34]
8000acc2:	58 0b       	cp.w	r11,0
8000acc4:	c0 a1       	brne	8000acd8 <_dtoa_r+0xa3c>
8000acc6:	40 26       	lddsp	r6,sp[0x8]
8000acc8:	e0 40 00 39 	cp.w	r0,57
8000accc:	c3 00       	breq	8000ad2c <_dtoa_r+0xa90>
8000acce:	40 6a       	lddsp	r10,sp[0x18]
8000acd0:	58 0a       	cp.w	r10,0
8000acd2:	e0 89 00 24 	brgt	8000ad1a <_dtoa_r+0xa7e>
8000acd6:	c2 f8       	rjmp	8000ad34 <_dtoa_r+0xa98>
8000acd8:	40 69       	lddsp	r9,sp[0x18]
8000acda:	58 09       	cp.w	r9,0
8000acdc:	c0 85       	brlt	8000acec <_dtoa_r+0xa50>
8000acde:	12 98       	mov	r8,r9
8000ace0:	40 cc       	lddsp	r12,sp[0x30]
8000ace2:	18 48       	or	r8,r12
8000ace4:	c1 d1       	brne	8000ad1e <_dtoa_r+0xa82>
8000ace6:	40 db       	lddsp	r11,sp[0x34]
8000ace8:	58 0b       	cp.w	r11,0
8000acea:	c1 a1       	brne	8000ad1e <_dtoa_r+0xa82>
8000acec:	0c 99       	mov	r9,r6
8000acee:	40 26       	lddsp	r6,sp[0x8]
8000acf0:	58 09       	cp.w	r9,0
8000acf2:	e0 8a 00 21 	brle	8000ad34 <_dtoa_r+0xa98>
8000acf6:	06 9b       	mov	r11,r3
8000acf8:	30 1a       	mov	r10,1
8000acfa:	0e 9c       	mov	r12,r7
8000acfc:	e0 a0 06 92 	rcall	8000ba20 <__lshift>
8000ad00:	04 9b       	mov	r11,r2
8000ad02:	18 93       	mov	r3,r12
8000ad04:	e0 a0 05 6b 	rcall	8000b7da <__mcmp>
8000ad08:	e0 89 00 06 	brgt	8000ad14 <_dtoa_r+0xa78>
8000ad0c:	c1 41       	brne	8000ad34 <_dtoa_r+0xa98>
8000ad0e:	ed b0 00 00 	bld	r0,0x0
8000ad12:	c1 11       	brne	8000ad34 <_dtoa_r+0xa98>
8000ad14:	e0 40 00 39 	cp.w	r0,57
8000ad18:	c0 a0       	breq	8000ad2c <_dtoa_r+0xa90>
8000ad1a:	2f f0       	sub	r0,-1
8000ad1c:	c0 c8       	rjmp	8000ad34 <_dtoa_r+0xa98>
8000ad1e:	58 06       	cp.w	r6,0
8000ad20:	e0 8a 00 0c 	brle	8000ad38 <_dtoa_r+0xa9c>
8000ad24:	40 26       	lddsp	r6,sp[0x8]
8000ad26:	e0 40 00 39 	cp.w	r0,57
8000ad2a:	c0 41       	brne	8000ad32 <_dtoa_r+0xa96>
8000ad2c:	33 98       	mov	r8,57
8000ad2e:	0a c8       	st.b	r5++,r8
8000ad30:	c6 78       	rjmp	8000adfe <_dtoa_r+0xb62>
8000ad32:	2f f0       	sub	r0,-1
8000ad34:	0a c0       	st.b	r5++,r0
8000ad36:	c7 58       	rjmp	8000ae20 <_dtoa_r+0xb84>
8000ad38:	0a c0       	st.b	r5++,r0
8000ad3a:	40 9a       	lddsp	r10,sp[0x24]
8000ad3c:	40 e9       	lddsp	r9,sp[0x38]
8000ad3e:	12 3a       	cp.w	r10,r9
8000ad40:	c4 30       	breq	8000adc6 <_dtoa_r+0xb2a>
8000ad42:	06 9b       	mov	r11,r3
8000ad44:	30 09       	mov	r9,0
8000ad46:	30 aa       	mov	r10,10
8000ad48:	0e 9c       	mov	r12,r7
8000ad4a:	e0 a0 07 37 	rcall	8000bbb8 <__multadd>
8000ad4e:	40 48       	lddsp	r8,sp[0x10]
8000ad50:	18 93       	mov	r3,r12
8000ad52:	08 38       	cp.w	r8,r4
8000ad54:	c0 91       	brne	8000ad66 <_dtoa_r+0xaca>
8000ad56:	10 9b       	mov	r11,r8
8000ad58:	30 09       	mov	r9,0
8000ad5a:	30 aa       	mov	r10,10
8000ad5c:	0e 9c       	mov	r12,r7
8000ad5e:	e0 a0 07 2d 	rcall	8000bbb8 <__multadd>
8000ad62:	50 4c       	stdsp	sp[0x10],r12
8000ad64:	c0 e8       	rjmp	8000ad80 <_dtoa_r+0xae4>
8000ad66:	40 4b       	lddsp	r11,sp[0x10]
8000ad68:	30 09       	mov	r9,0
8000ad6a:	30 aa       	mov	r10,10
8000ad6c:	0e 9c       	mov	r12,r7
8000ad6e:	e0 a0 07 25 	rcall	8000bbb8 <__multadd>
8000ad72:	08 9b       	mov	r11,r4
8000ad74:	50 4c       	stdsp	sp[0x10],r12
8000ad76:	30 09       	mov	r9,0
8000ad78:	30 aa       	mov	r10,10
8000ad7a:	0e 9c       	mov	r12,r7
8000ad7c:	e0 a0 07 1e 	rcall	8000bbb8 <__multadd>
8000ad80:	18 94       	mov	r4,r12
8000ad82:	40 9c       	lddsp	r12,sp[0x24]
8000ad84:	2f fc       	sub	r12,-1
8000ad86:	50 9c       	stdsp	sp[0x24],r12
8000ad88:	c7 9b       	rjmp	8000ac7a <_dtoa_r+0x9de>
8000ad8a:	30 18       	mov	r8,1
8000ad8c:	06 90       	mov	r0,r3
8000ad8e:	40 85       	lddsp	r5,sp[0x20]
8000ad90:	08 93       	mov	r3,r4
8000ad92:	0c 94       	mov	r4,r6
8000ad94:	10 96       	mov	r6,r8
8000ad96:	04 9b       	mov	r11,r2
8000ad98:	00 9c       	mov	r12,r0
8000ad9a:	fe b0 f9 f1 	rcall	8000a17c <quorem>
8000ad9e:	2d 0c       	sub	r12,-48
8000ada0:	0a cc       	st.b	r5++,r12
8000ada2:	02 36       	cp.w	r6,r1
8000ada4:	c0 a4       	brge	8000adb8 <_dtoa_r+0xb1c>
8000ada6:	00 9b       	mov	r11,r0
8000ada8:	30 09       	mov	r9,0
8000adaa:	30 aa       	mov	r10,10
8000adac:	0e 9c       	mov	r12,r7
8000adae:	2f f6       	sub	r6,-1
8000adb0:	e0 a0 07 04 	rcall	8000bbb8 <__multadd>
8000adb4:	18 90       	mov	r0,r12
8000adb6:	cf 0b       	rjmp	8000ad96 <_dtoa_r+0xafa>
8000adb8:	08 96       	mov	r6,r4
8000adba:	30 0b       	mov	r11,0
8000adbc:	06 94       	mov	r4,r3
8000adbe:	50 4b       	stdsp	sp[0x10],r11
8000adc0:	00 93       	mov	r3,r0
8000adc2:	18 90       	mov	r0,r12
8000adc4:	c0 28       	rjmp	8000adc8 <_dtoa_r+0xb2c>
8000adc6:	40 26       	lddsp	r6,sp[0x8]
8000adc8:	06 9b       	mov	r11,r3
8000adca:	30 1a       	mov	r10,1
8000adcc:	0e 9c       	mov	r12,r7
8000adce:	e0 a0 06 29 	rcall	8000ba20 <__lshift>
8000add2:	04 9b       	mov	r11,r2
8000add4:	18 93       	mov	r3,r12
8000add6:	e0 a0 05 02 	rcall	8000b7da <__mcmp>
8000adda:	e0 89 00 12 	brgt	8000adfe <_dtoa_r+0xb62>
8000adde:	c1 b1       	brne	8000ae14 <_dtoa_r+0xb78>
8000ade0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ade4:	c0 d1       	brne	8000adfe <_dtoa_r+0xb62>
8000ade6:	c1 78       	rjmp	8000ae14 <_dtoa_r+0xb78>
8000ade8:	40 89       	lddsp	r9,sp[0x20]
8000adea:	12 38       	cp.w	r8,r9
8000adec:	c0 30       	breq	8000adf2 <_dtoa_r+0xb56>
8000adee:	10 95       	mov	r5,r8
8000adf0:	c0 88       	rjmp	8000ae00 <_dtoa_r+0xb64>
8000adf2:	2f f6       	sub	r6,-1
8000adf4:	50 66       	stdsp	sp[0x18],r6
8000adf6:	33 18       	mov	r8,49
8000adf8:	40 8c       	lddsp	r12,sp[0x20]
8000adfa:	b8 88       	st.b	r12[0x0],r8
8000adfc:	c1 38       	rjmp	8000ae22 <_dtoa_r+0xb86>
8000adfe:	33 9a       	mov	r10,57
8000ae00:	0a 98       	mov	r8,r5
8000ae02:	11 79       	ld.ub	r9,--r8
8000ae04:	f4 09 18 00 	cp.b	r9,r10
8000ae08:	cf 00       	breq	8000ade8 <_dtoa_r+0xb4c>
8000ae0a:	2f f9       	sub	r9,-1
8000ae0c:	b0 89       	st.b	r8[0x0],r9
8000ae0e:	c0 98       	rjmp	8000ae20 <_dtoa_r+0xb84>
8000ae10:	10 95       	mov	r5,r8
8000ae12:	c0 28       	rjmp	8000ae16 <_dtoa_r+0xb7a>
8000ae14:	33 09       	mov	r9,48
8000ae16:	0a 98       	mov	r8,r5
8000ae18:	11 7a       	ld.ub	r10,--r8
8000ae1a:	f2 0a 18 00 	cp.b	r10,r9
8000ae1e:	cf 90       	breq	8000ae10 <_dtoa_r+0xb74>
8000ae20:	50 66       	stdsp	sp[0x18],r6
8000ae22:	04 9b       	mov	r11,r2
8000ae24:	0e 9c       	mov	r12,r7
8000ae26:	e0 a0 04 f3 	rcall	8000b80c <_Bfree>
8000ae2a:	58 04       	cp.w	r4,0
8000ae2c:	c1 20       	breq	8000ae50 <_dtoa_r+0xbb4>
8000ae2e:	40 4b       	lddsp	r11,sp[0x10]
8000ae30:	08 3b       	cp.w	r11,r4
8000ae32:	5f 19       	srne	r9
8000ae34:	58 0b       	cp.w	r11,0
8000ae36:	5f 18       	srne	r8
8000ae38:	f3 e8 00 08 	and	r8,r9,r8
8000ae3c:	c0 40       	breq	8000ae44 <_dtoa_r+0xba8>
8000ae3e:	0e 9c       	mov	r12,r7
8000ae40:	e0 a0 04 e6 	rcall	8000b80c <_Bfree>
8000ae44:	08 9b       	mov	r11,r4
8000ae46:	0e 9c       	mov	r12,r7
8000ae48:	e0 a0 04 e2 	rcall	8000b80c <_Bfree>
8000ae4c:	c0 28       	rjmp	8000ae50 <_dtoa_r+0xbb4>
8000ae4e:	50 66       	stdsp	sp[0x18],r6
8000ae50:	0e 9c       	mov	r12,r7
8000ae52:	06 9b       	mov	r11,r3
8000ae54:	e0 a0 04 dc 	rcall	8000b80c <_Bfree>
8000ae58:	30 08       	mov	r8,0
8000ae5a:	aa 88       	st.b	r5[0x0],r8
8000ae5c:	40 68       	lddsp	r8,sp[0x18]
8000ae5e:	41 5a       	lddsp	r10,sp[0x54]
8000ae60:	2f f8       	sub	r8,-1
8000ae62:	41 29       	lddsp	r9,sp[0x48]
8000ae64:	95 08       	st.w	r10[0x0],r8
8000ae66:	40 8c       	lddsp	r12,sp[0x20]
8000ae68:	58 09       	cp.w	r9,0
8000ae6a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ae6e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ae72:	2e 6d       	sub	sp,-104
8000ae74:	d8 32       	popm	r0-r7,pc
8000ae76:	d7 03       	nop

8000ae78 <__errno>:
8000ae78:	e0 68 0a 40 	mov	r8,2624
8000ae7c:	70 0c       	ld.w	r12,r8[0x0]
8000ae7e:	2f 4c       	sub	r12,-12
8000ae80:	5e fc       	retal	r12
8000ae82:	d7 03       	nop

8000ae84 <_fflush_r>:
8000ae84:	d4 21       	pushm	r4-r7,lr
8000ae86:	16 97       	mov	r7,r11
8000ae88:	18 96       	mov	r6,r12
8000ae8a:	76 48       	ld.w	r8,r11[0x10]
8000ae8c:	58 08       	cp.w	r8,0
8000ae8e:	c7 f0       	breq	8000af8c <_fflush_r+0x108>
8000ae90:	58 0c       	cp.w	r12,0
8000ae92:	c0 50       	breq	8000ae9c <_fflush_r+0x18>
8000ae94:	78 68       	ld.w	r8,r12[0x18]
8000ae96:	58 08       	cp.w	r8,0
8000ae98:	c0 21       	brne	8000ae9c <_fflush_r+0x18>
8000ae9a:	cc dc       	rcall	8000b034 <__sinit>
8000ae9c:	fe c8 cd 84 	sub	r8,pc,-12924
8000aea0:	10 37       	cp.w	r7,r8
8000aea2:	c0 31       	brne	8000aea8 <_fflush_r+0x24>
8000aea4:	6c 07       	ld.w	r7,r6[0x0]
8000aea6:	c0 c8       	rjmp	8000aebe <_fflush_r+0x3a>
8000aea8:	fe c8 cd 70 	sub	r8,pc,-12944
8000aeac:	10 37       	cp.w	r7,r8
8000aeae:	c0 31       	brne	8000aeb4 <_fflush_r+0x30>
8000aeb0:	6c 17       	ld.w	r7,r6[0x4]
8000aeb2:	c0 68       	rjmp	8000aebe <_fflush_r+0x3a>
8000aeb4:	fe c8 cd 5c 	sub	r8,pc,-12964
8000aeb8:	10 37       	cp.w	r7,r8
8000aeba:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aebe:	8e 6a       	ld.sh	r10,r7[0xc]
8000aec0:	14 98       	mov	r8,r10
8000aec2:	ed ba 00 03 	bld	r10,0x3
8000aec6:	c4 20       	breq	8000af4a <_fflush_r+0xc6>
8000aec8:	ab ba       	sbr	r10,0xb
8000aeca:	ae 6a       	st.h	r7[0xc],r10
8000aecc:	6e 18       	ld.w	r8,r7[0x4]
8000aece:	58 08       	cp.w	r8,0
8000aed0:	e0 89 00 06 	brgt	8000aedc <_fflush_r+0x58>
8000aed4:	6f 08       	ld.w	r8,r7[0x40]
8000aed6:	58 08       	cp.w	r8,0
8000aed8:	e0 8a 00 5a 	brle	8000af8c <_fflush_r+0x108>
8000aedc:	6e b8       	ld.w	r8,r7[0x2c]
8000aede:	58 08       	cp.w	r8,0
8000aee0:	c5 60       	breq	8000af8c <_fflush_r+0x108>
8000aee2:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aee6:	c0 30       	breq	8000aeec <_fflush_r+0x68>
8000aee8:	6f 55       	ld.w	r5,r7[0x54]
8000aeea:	c0 f8       	rjmp	8000af08 <_fflush_r+0x84>
8000aeec:	30 19       	mov	r9,1
8000aeee:	6e 8b       	ld.w	r11,r7[0x20]
8000aef0:	0c 9c       	mov	r12,r6
8000aef2:	5d 18       	icall	r8
8000aef4:	18 95       	mov	r5,r12
8000aef6:	5b fc       	cp.w	r12,-1
8000aef8:	c0 81       	brne	8000af08 <_fflush_r+0x84>
8000aefa:	6c 38       	ld.w	r8,r6[0xc]
8000aefc:	59 d8       	cp.w	r8,29
8000aefe:	c4 70       	breq	8000af8c <_fflush_r+0x108>
8000af00:	8e 68       	ld.sh	r8,r7[0xc]
8000af02:	a7 a8       	sbr	r8,0x6
8000af04:	ae 68       	st.h	r7[0xc],r8
8000af06:	d8 22       	popm	r4-r7,pc
8000af08:	8e 68       	ld.sh	r8,r7[0xc]
8000af0a:	ed b8 00 02 	bld	r8,0x2
8000af0e:	c0 91       	brne	8000af20 <_fflush_r+0x9c>
8000af10:	6e 18       	ld.w	r8,r7[0x4]
8000af12:	10 15       	sub	r5,r8
8000af14:	6e d8       	ld.w	r8,r7[0x34]
8000af16:	58 08       	cp.w	r8,0
8000af18:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000af1c:	eb d8 e1 15 	subne	r5,r5,r8
8000af20:	6e b8       	ld.w	r8,r7[0x2c]
8000af22:	0c 9c       	mov	r12,r6
8000af24:	30 09       	mov	r9,0
8000af26:	0a 9a       	mov	r10,r5
8000af28:	6e 8b       	ld.w	r11,r7[0x20]
8000af2a:	5d 18       	icall	r8
8000af2c:	8e 68       	ld.sh	r8,r7[0xc]
8000af2e:	0a 3c       	cp.w	r12,r5
8000af30:	c2 61       	brne	8000af7c <_fflush_r+0xf8>
8000af32:	ab d8       	cbr	r8,0xb
8000af34:	30 0c       	mov	r12,0
8000af36:	6e 49       	ld.w	r9,r7[0x10]
8000af38:	ae 68       	st.h	r7[0xc],r8
8000af3a:	8f 1c       	st.w	r7[0x4],r12
8000af3c:	8f 09       	st.w	r7[0x0],r9
8000af3e:	ed b8 00 0c 	bld	r8,0xc
8000af42:	c2 51       	brne	8000af8c <_fflush_r+0x108>
8000af44:	ef 45 00 54 	st.w	r7[84],r5
8000af48:	d8 22       	popm	r4-r7,pc
8000af4a:	6e 45       	ld.w	r5,r7[0x10]
8000af4c:	58 05       	cp.w	r5,0
8000af4e:	c1 f0       	breq	8000af8c <_fflush_r+0x108>
8000af50:	6e 04       	ld.w	r4,r7[0x0]
8000af52:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000af56:	8f 05       	st.w	r7[0x0],r5
8000af58:	f9 b8 01 00 	movne	r8,0
8000af5c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000af60:	0a 14       	sub	r4,r5
8000af62:	8f 28       	st.w	r7[0x8],r8
8000af64:	c1 18       	rjmp	8000af86 <_fflush_r+0x102>
8000af66:	08 99       	mov	r9,r4
8000af68:	0a 9a       	mov	r10,r5
8000af6a:	6e a8       	ld.w	r8,r7[0x28]
8000af6c:	6e 8b       	ld.w	r11,r7[0x20]
8000af6e:	0c 9c       	mov	r12,r6
8000af70:	5d 18       	icall	r8
8000af72:	18 14       	sub	r4,r12
8000af74:	58 0c       	cp.w	r12,0
8000af76:	e0 89 00 07 	brgt	8000af84 <_fflush_r+0x100>
8000af7a:	8e 68       	ld.sh	r8,r7[0xc]
8000af7c:	a7 a8       	sbr	r8,0x6
8000af7e:	3f fc       	mov	r12,-1
8000af80:	ae 68       	st.h	r7[0xc],r8
8000af82:	d8 22       	popm	r4-r7,pc
8000af84:	18 05       	add	r5,r12
8000af86:	58 04       	cp.w	r4,0
8000af88:	fe 99 ff ef 	brgt	8000af66 <_fflush_r+0xe2>
8000af8c:	d8 2a       	popm	r4-r7,pc,r12=0
8000af8e:	d7 03       	nop

8000af90 <__sfp_lock_acquire>:
8000af90:	5e fc       	retal	r12

8000af92 <__sfp_lock_release>:
8000af92:	5e fc       	retal	r12

8000af94 <_cleanup_r>:
8000af94:	d4 01       	pushm	lr
8000af96:	fe cb f0 ae 	sub	r11,pc,-3922
8000af9a:	e0 a0 02 f7 	rcall	8000b588 <_fwalk>
8000af9e:	d8 02       	popm	pc

8000afa0 <__sfmoreglue>:
8000afa0:	d4 21       	pushm	r4-r7,lr
8000afa2:	16 95       	mov	r5,r11
8000afa4:	f6 06 10 5c 	mul	r6,r11,92
8000afa8:	ec cb ff f4 	sub	r11,r6,-12
8000afac:	fe b0 e2 88 	rcall	800074bc <_malloc_r>
8000afb0:	18 97       	mov	r7,r12
8000afb2:	c0 90       	breq	8000afc4 <__sfmoreglue+0x24>
8000afb4:	99 15       	st.w	r12[0x4],r5
8000afb6:	30 0b       	mov	r11,0
8000afb8:	2f 4c       	sub	r12,-12
8000afba:	0c 9a       	mov	r10,r6
8000afbc:	8f 2c       	st.w	r7[0x8],r12
8000afbe:	8f 0b       	st.w	r7[0x0],r11
8000afc0:	fe b0 e5 3e 	rcall	80007a3c <memset>
8000afc4:	0e 9c       	mov	r12,r7
8000afc6:	d8 22       	popm	r4-r7,pc

8000afc8 <__sfp>:
8000afc8:	d4 21       	pushm	r4-r7,lr
8000afca:	fe c8 ce 4e 	sub	r8,pc,-12722
8000afce:	18 96       	mov	r6,r12
8000afd0:	70 07       	ld.w	r7,r8[0x0]
8000afd2:	6e 68       	ld.w	r8,r7[0x18]
8000afd4:	58 08       	cp.w	r8,0
8000afd6:	c0 31       	brne	8000afdc <__sfp+0x14>
8000afd8:	0e 9c       	mov	r12,r7
8000afda:	c2 dc       	rcall	8000b034 <__sinit>
8000afdc:	ee c7 ff 28 	sub	r7,r7,-216
8000afe0:	30 05       	mov	r5,0
8000afe2:	6e 2c       	ld.w	r12,r7[0x8]
8000afe4:	6e 18       	ld.w	r8,r7[0x4]
8000afe6:	c0 68       	rjmp	8000aff2 <__sfp+0x2a>
8000afe8:	98 69       	ld.sh	r9,r12[0xc]
8000afea:	ea 09 19 00 	cp.h	r9,r5
8000afee:	c1 10       	breq	8000b010 <__sfp+0x48>
8000aff0:	2a 4c       	sub	r12,-92
8000aff2:	20 18       	sub	r8,1
8000aff4:	cf a7       	brpl	8000afe8 <__sfp+0x20>
8000aff6:	6e 08       	ld.w	r8,r7[0x0]
8000aff8:	58 08       	cp.w	r8,0
8000affa:	c0 61       	brne	8000b006 <__sfp+0x3e>
8000affc:	30 4b       	mov	r11,4
8000affe:	0c 9c       	mov	r12,r6
8000b000:	cd 0f       	rcall	8000afa0 <__sfmoreglue>
8000b002:	8f 0c       	st.w	r7[0x0],r12
8000b004:	c0 30       	breq	8000b00a <__sfp+0x42>
8000b006:	6e 07       	ld.w	r7,r7[0x0]
8000b008:	ce db       	rjmp	8000afe2 <__sfp+0x1a>
8000b00a:	30 c8       	mov	r8,12
8000b00c:	8d 38       	st.w	r6[0xc],r8
8000b00e:	d8 22       	popm	r4-r7,pc
8000b010:	30 08       	mov	r8,0
8000b012:	f9 48 00 4c 	st.w	r12[76],r8
8000b016:	99 08       	st.w	r12[0x0],r8
8000b018:	99 28       	st.w	r12[0x8],r8
8000b01a:	99 18       	st.w	r12[0x4],r8
8000b01c:	99 48       	st.w	r12[0x10],r8
8000b01e:	99 58       	st.w	r12[0x14],r8
8000b020:	99 68       	st.w	r12[0x18],r8
8000b022:	99 d8       	st.w	r12[0x34],r8
8000b024:	99 e8       	st.w	r12[0x38],r8
8000b026:	f9 48 00 48 	st.w	r12[72],r8
8000b02a:	3f f8       	mov	r8,-1
8000b02c:	b8 78       	st.h	r12[0xe],r8
8000b02e:	30 18       	mov	r8,1
8000b030:	b8 68       	st.h	r12[0xc],r8
8000b032:	d8 22       	popm	r4-r7,pc

8000b034 <__sinit>:
8000b034:	d4 21       	pushm	r4-r7,lr
8000b036:	18 96       	mov	r6,r12
8000b038:	78 67       	ld.w	r7,r12[0x18]
8000b03a:	58 07       	cp.w	r7,0
8000b03c:	c4 91       	brne	8000b0ce <__sinit+0x9a>
8000b03e:	fe c8 00 aa 	sub	r8,pc,170
8000b042:	30 15       	mov	r5,1
8000b044:	99 a8       	st.w	r12[0x28],r8
8000b046:	f9 47 00 d8 	st.w	r12[216],r7
8000b04a:	f9 47 00 dc 	st.w	r12[220],r7
8000b04e:	f9 47 00 e0 	st.w	r12[224],r7
8000b052:	99 65       	st.w	r12[0x18],r5
8000b054:	cb af       	rcall	8000afc8 <__sfp>
8000b056:	8d 0c       	st.w	r6[0x0],r12
8000b058:	0c 9c       	mov	r12,r6
8000b05a:	cb 7f       	rcall	8000afc8 <__sfp>
8000b05c:	8d 1c       	st.w	r6[0x4],r12
8000b05e:	0c 9c       	mov	r12,r6
8000b060:	cb 4f       	rcall	8000afc8 <__sfp>
8000b062:	6c 09       	ld.w	r9,r6[0x0]
8000b064:	30 48       	mov	r8,4
8000b066:	93 07       	st.w	r9[0x0],r7
8000b068:	b2 68       	st.h	r9[0xc],r8
8000b06a:	93 17       	st.w	r9[0x4],r7
8000b06c:	93 27       	st.w	r9[0x8],r7
8000b06e:	6c 18       	ld.w	r8,r6[0x4]
8000b070:	b2 77       	st.h	r9[0xe],r7
8000b072:	93 47       	st.w	r9[0x10],r7
8000b074:	93 57       	st.w	r9[0x14],r7
8000b076:	93 67       	st.w	r9[0x18],r7
8000b078:	93 89       	st.w	r9[0x20],r9
8000b07a:	91 07       	st.w	r8[0x0],r7
8000b07c:	91 17       	st.w	r8[0x4],r7
8000b07e:	91 27       	st.w	r8[0x8],r7
8000b080:	fe ce f3 24 	sub	lr,pc,-3292
8000b084:	fe cb f3 54 	sub	r11,pc,-3244
8000b088:	93 9e       	st.w	r9[0x24],lr
8000b08a:	93 ab       	st.w	r9[0x28],r11
8000b08c:	fe ca f3 7c 	sub	r10,pc,-3204
8000b090:	fe c4 f3 88 	sub	r4,pc,-3192
8000b094:	93 ba       	st.w	r9[0x2c],r10
8000b096:	93 c4       	st.w	r9[0x30],r4
8000b098:	30 99       	mov	r9,9
8000b09a:	b0 69       	st.h	r8[0xc],r9
8000b09c:	b0 75       	st.h	r8[0xe],r5
8000b09e:	91 c4       	st.w	r8[0x30],r4
8000b0a0:	91 47       	st.w	r8[0x10],r7
8000b0a2:	91 57       	st.w	r8[0x14],r7
8000b0a4:	91 67       	st.w	r8[0x18],r7
8000b0a6:	91 88       	st.w	r8[0x20],r8
8000b0a8:	91 9e       	st.w	r8[0x24],lr
8000b0aa:	91 ab       	st.w	r8[0x28],r11
8000b0ac:	91 ba       	st.w	r8[0x2c],r10
8000b0ae:	8d 2c       	st.w	r6[0x8],r12
8000b0b0:	31 28       	mov	r8,18
8000b0b2:	99 07       	st.w	r12[0x0],r7
8000b0b4:	b8 68       	st.h	r12[0xc],r8
8000b0b6:	99 17       	st.w	r12[0x4],r7
8000b0b8:	99 27       	st.w	r12[0x8],r7
8000b0ba:	30 28       	mov	r8,2
8000b0bc:	b8 78       	st.h	r12[0xe],r8
8000b0be:	99 c4       	st.w	r12[0x30],r4
8000b0c0:	99 67       	st.w	r12[0x18],r7
8000b0c2:	99 9e       	st.w	r12[0x24],lr
8000b0c4:	99 ab       	st.w	r12[0x28],r11
8000b0c6:	99 ba       	st.w	r12[0x2c],r10
8000b0c8:	99 47       	st.w	r12[0x10],r7
8000b0ca:	99 57       	st.w	r12[0x14],r7
8000b0cc:	99 8c       	st.w	r12[0x20],r12
8000b0ce:	d8 22       	popm	r4-r7,pc

8000b0d0 <_malloc_trim_r>:
8000b0d0:	d4 21       	pushm	r4-r7,lr
8000b0d2:	16 95       	mov	r5,r11
8000b0d4:	18 97       	mov	r7,r12
8000b0d6:	fe b0 d7 a9 	rcall	80006028 <__malloc_lock>
8000b0da:	e0 64 05 40 	mov	r4,1344
8000b0de:	68 28       	ld.w	r8,r4[0x8]
8000b0e0:	70 16       	ld.w	r6,r8[0x4]
8000b0e2:	e0 16 ff fc 	andl	r6,0xfffc
8000b0e6:	ec c8 ff 91 	sub	r8,r6,-111
8000b0ea:	f0 05 01 05 	sub	r5,r8,r5
8000b0ee:	e0 15 ff 80 	andl	r5,0xff80
8000b0f2:	ea c5 00 80 	sub	r5,r5,128
8000b0f6:	e0 45 00 7f 	cp.w	r5,127
8000b0fa:	e0 8a 00 25 	brle	8000b144 <_malloc_trim_r+0x74>
8000b0fe:	30 0b       	mov	r11,0
8000b100:	0e 9c       	mov	r12,r7
8000b102:	fe b0 e6 05 	rcall	80007d0c <_sbrk_r>
8000b106:	68 28       	ld.w	r8,r4[0x8]
8000b108:	0c 08       	add	r8,r6
8000b10a:	10 3c       	cp.w	r12,r8
8000b10c:	c1 c1       	brne	8000b144 <_malloc_trim_r+0x74>
8000b10e:	ea 0b 11 00 	rsub	r11,r5,0
8000b112:	0e 9c       	mov	r12,r7
8000b114:	fe b0 e5 fc 	rcall	80007d0c <_sbrk_r>
8000b118:	5b fc       	cp.w	r12,-1
8000b11a:	c1 91       	brne	8000b14c <_malloc_trim_r+0x7c>
8000b11c:	30 0b       	mov	r11,0
8000b11e:	0e 9c       	mov	r12,r7
8000b120:	fe b0 e5 f6 	rcall	80007d0c <_sbrk_r>
8000b124:	68 28       	ld.w	r8,r4[0x8]
8000b126:	f8 08 01 09 	sub	r9,r12,r8
8000b12a:	58 f9       	cp.w	r9,15
8000b12c:	e0 8a 00 0c 	brle	8000b144 <_malloc_trim_r+0x74>
8000b130:	a1 a9       	sbr	r9,0x0
8000b132:	91 19       	st.w	r8[0x4],r9
8000b134:	e0 68 09 4c 	mov	r8,2380
8000b138:	70 09       	ld.w	r9,r8[0x0]
8000b13a:	e0 68 0d 74 	mov	r8,3444
8000b13e:	f8 09 01 09 	sub	r9,r12,r9
8000b142:	91 09       	st.w	r8[0x0],r9
8000b144:	0e 9c       	mov	r12,r7
8000b146:	fe b0 d7 77 	rcall	80006034 <__malloc_unlock>
8000b14a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b14c:	68 28       	ld.w	r8,r4[0x8]
8000b14e:	0a 16       	sub	r6,r5
8000b150:	a1 a6       	sbr	r6,0x0
8000b152:	91 16       	st.w	r8[0x4],r6
8000b154:	e0 68 0d 74 	mov	r8,3444
8000b158:	70 09       	ld.w	r9,r8[0x0]
8000b15a:	0a 19       	sub	r9,r5
8000b15c:	0e 9c       	mov	r12,r7
8000b15e:	91 09       	st.w	r8[0x0],r9
8000b160:	fe b0 d7 6a 	rcall	80006034 <__malloc_unlock>
8000b164:	da 2a       	popm	r4-r7,pc,r12=1
8000b166:	d7 03       	nop

8000b168 <_free_r>:
8000b168:	d4 21       	pushm	r4-r7,lr
8000b16a:	16 96       	mov	r6,r11
8000b16c:	18 97       	mov	r7,r12
8000b16e:	58 0b       	cp.w	r11,0
8000b170:	e0 80 00 c0 	breq	8000b2f0 <_free_r+0x188>
8000b174:	fe b0 d7 5a 	rcall	80006028 <__malloc_lock>
8000b178:	20 86       	sub	r6,8
8000b17a:	e0 6a 05 40 	mov	r10,1344
8000b17e:	6c 18       	ld.w	r8,r6[0x4]
8000b180:	74 2e       	ld.w	lr,r10[0x8]
8000b182:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b186:	a1 c8       	cbr	r8,0x0
8000b188:	ec 08 00 09 	add	r9,r6,r8
8000b18c:	72 1b       	ld.w	r11,r9[0x4]
8000b18e:	e0 1b ff fc 	andl	r11,0xfffc
8000b192:	1c 39       	cp.w	r9,lr
8000b194:	c1 e1       	brne	8000b1d0 <_free_r+0x68>
8000b196:	f6 08 00 08 	add	r8,r11,r8
8000b19a:	58 0c       	cp.w	r12,0
8000b19c:	c0 81       	brne	8000b1ac <_free_r+0x44>
8000b19e:	6c 09       	ld.w	r9,r6[0x0]
8000b1a0:	12 16       	sub	r6,r9
8000b1a2:	12 08       	add	r8,r9
8000b1a4:	6c 3b       	ld.w	r11,r6[0xc]
8000b1a6:	6c 29       	ld.w	r9,r6[0x8]
8000b1a8:	97 29       	st.w	r11[0x8],r9
8000b1aa:	93 3b       	st.w	r9[0xc],r11
8000b1ac:	10 99       	mov	r9,r8
8000b1ae:	95 26       	st.w	r10[0x8],r6
8000b1b0:	a1 a9       	sbr	r9,0x0
8000b1b2:	8d 19       	st.w	r6[0x4],r9
8000b1b4:	e0 69 09 48 	mov	r9,2376
8000b1b8:	72 09       	ld.w	r9,r9[0x0]
8000b1ba:	12 38       	cp.w	r8,r9
8000b1bc:	c0 63       	brcs	8000b1c8 <_free_r+0x60>
8000b1be:	e0 68 0d 70 	mov	r8,3440
8000b1c2:	0e 9c       	mov	r12,r7
8000b1c4:	70 0b       	ld.w	r11,r8[0x0]
8000b1c6:	c8 5f       	rcall	8000b0d0 <_malloc_trim_r>
8000b1c8:	0e 9c       	mov	r12,r7
8000b1ca:	fe b0 d7 35 	rcall	80006034 <__malloc_unlock>
8000b1ce:	d8 22       	popm	r4-r7,pc
8000b1d0:	93 1b       	st.w	r9[0x4],r11
8000b1d2:	58 0c       	cp.w	r12,0
8000b1d4:	c0 30       	breq	8000b1da <_free_r+0x72>
8000b1d6:	30 0c       	mov	r12,0
8000b1d8:	c1 08       	rjmp	8000b1f8 <_free_r+0x90>
8000b1da:	6c 0e       	ld.w	lr,r6[0x0]
8000b1dc:	f4 c5 ff f8 	sub	r5,r10,-8
8000b1e0:	1c 16       	sub	r6,lr
8000b1e2:	1c 08       	add	r8,lr
8000b1e4:	6c 2e       	ld.w	lr,r6[0x8]
8000b1e6:	0a 3e       	cp.w	lr,r5
8000b1e8:	f9 bc 00 01 	moveq	r12,1
8000b1ec:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b1f0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b1f4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b1f8:	f2 0b 00 0e 	add	lr,r9,r11
8000b1fc:	7c 1e       	ld.w	lr,lr[0x4]
8000b1fe:	ed be 00 00 	bld	lr,0x0
8000b202:	c1 40       	breq	8000b22a <_free_r+0xc2>
8000b204:	16 08       	add	r8,r11
8000b206:	58 0c       	cp.w	r12,0
8000b208:	c0 d1       	brne	8000b222 <_free_r+0xba>
8000b20a:	e0 6e 05 40 	mov	lr,1344
8000b20e:	72 2b       	ld.w	r11,r9[0x8]
8000b210:	2f 8e       	sub	lr,-8
8000b212:	1c 3b       	cp.w	r11,lr
8000b214:	c0 71       	brne	8000b222 <_free_r+0xba>
8000b216:	97 36       	st.w	r11[0xc],r6
8000b218:	97 26       	st.w	r11[0x8],r6
8000b21a:	8d 2b       	st.w	r6[0x8],r11
8000b21c:	8d 3b       	st.w	r6[0xc],r11
8000b21e:	30 1c       	mov	r12,1
8000b220:	c0 58       	rjmp	8000b22a <_free_r+0xc2>
8000b222:	72 2b       	ld.w	r11,r9[0x8]
8000b224:	72 39       	ld.w	r9,r9[0xc]
8000b226:	93 2b       	st.w	r9[0x8],r11
8000b228:	97 39       	st.w	r11[0xc],r9
8000b22a:	10 99       	mov	r9,r8
8000b22c:	ec 08 09 08 	st.w	r6[r8],r8
8000b230:	a1 a9       	sbr	r9,0x0
8000b232:	8d 19       	st.w	r6[0x4],r9
8000b234:	58 0c       	cp.w	r12,0
8000b236:	c5 a1       	brne	8000b2ea <_free_r+0x182>
8000b238:	e0 48 01 ff 	cp.w	r8,511
8000b23c:	e0 8b 00 13 	brhi	8000b262 <_free_r+0xfa>
8000b240:	a3 98       	lsr	r8,0x3
8000b242:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b246:	72 2b       	ld.w	r11,r9[0x8]
8000b248:	8d 39       	st.w	r6[0xc],r9
8000b24a:	8d 2b       	st.w	r6[0x8],r11
8000b24c:	97 36       	st.w	r11[0xc],r6
8000b24e:	93 26       	st.w	r9[0x8],r6
8000b250:	a3 48       	asr	r8,0x2
8000b252:	74 19       	ld.w	r9,r10[0x4]
8000b254:	30 1b       	mov	r11,1
8000b256:	f6 08 09 48 	lsl	r8,r11,r8
8000b25a:	f3 e8 10 08 	or	r8,r9,r8
8000b25e:	95 18       	st.w	r10[0x4],r8
8000b260:	c4 58       	rjmp	8000b2ea <_free_r+0x182>
8000b262:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b266:	58 4b       	cp.w	r11,4
8000b268:	e0 8b 00 06 	brhi	8000b274 <_free_r+0x10c>
8000b26c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b270:	2c 8b       	sub	r11,-56
8000b272:	c2 08       	rjmp	8000b2b2 <_free_r+0x14a>
8000b274:	59 4b       	cp.w	r11,20
8000b276:	e0 8b 00 04 	brhi	8000b27e <_free_r+0x116>
8000b27a:	2a 5b       	sub	r11,-91
8000b27c:	c1 b8       	rjmp	8000b2b2 <_free_r+0x14a>
8000b27e:	e0 4b 00 54 	cp.w	r11,84
8000b282:	e0 8b 00 06 	brhi	8000b28e <_free_r+0x126>
8000b286:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b28a:	29 2b       	sub	r11,-110
8000b28c:	c1 38       	rjmp	8000b2b2 <_free_r+0x14a>
8000b28e:	e0 4b 01 54 	cp.w	r11,340
8000b292:	e0 8b 00 06 	brhi	8000b29e <_free_r+0x136>
8000b296:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b29a:	28 9b       	sub	r11,-119
8000b29c:	c0 b8       	rjmp	8000b2b2 <_free_r+0x14a>
8000b29e:	e0 4b 05 54 	cp.w	r11,1364
8000b2a2:	e0 88 00 05 	brls	8000b2ac <_free_r+0x144>
8000b2a6:	37 eb       	mov	r11,126
8000b2a8:	c0 58       	rjmp	8000b2b2 <_free_r+0x14a>
8000b2aa:	d7 03       	nop
8000b2ac:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b2b0:	28 4b       	sub	r11,-124
8000b2b2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b2b6:	78 29       	ld.w	r9,r12[0x8]
8000b2b8:	18 39       	cp.w	r9,r12
8000b2ba:	c0 e1       	brne	8000b2d6 <_free_r+0x16e>
8000b2bc:	74 18       	ld.w	r8,r10[0x4]
8000b2be:	a3 4b       	asr	r11,0x2
8000b2c0:	30 1c       	mov	r12,1
8000b2c2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b2c6:	f1 eb 10 0b 	or	r11,r8,r11
8000b2ca:	12 98       	mov	r8,r9
8000b2cc:	95 1b       	st.w	r10[0x4],r11
8000b2ce:	c0 a8       	rjmp	8000b2e2 <_free_r+0x17a>
8000b2d0:	72 29       	ld.w	r9,r9[0x8]
8000b2d2:	18 39       	cp.w	r9,r12
8000b2d4:	c0 60       	breq	8000b2e0 <_free_r+0x178>
8000b2d6:	72 1a       	ld.w	r10,r9[0x4]
8000b2d8:	e0 1a ff fc 	andl	r10,0xfffc
8000b2dc:	14 38       	cp.w	r8,r10
8000b2de:	cf 93       	brcs	8000b2d0 <_free_r+0x168>
8000b2e0:	72 38       	ld.w	r8,r9[0xc]
8000b2e2:	8d 38       	st.w	r6[0xc],r8
8000b2e4:	8d 29       	st.w	r6[0x8],r9
8000b2e6:	93 36       	st.w	r9[0xc],r6
8000b2e8:	91 26       	st.w	r8[0x8],r6
8000b2ea:	0e 9c       	mov	r12,r7
8000b2ec:	fe b0 d6 a4 	rcall	80006034 <__malloc_unlock>
8000b2f0:	d8 22       	popm	r4-r7,pc
8000b2f2:	d7 03       	nop

8000b2f4 <__sfvwrite_r>:
8000b2f4:	d4 31       	pushm	r0-r7,lr
8000b2f6:	20 3d       	sub	sp,12
8000b2f8:	14 94       	mov	r4,r10
8000b2fa:	18 95       	mov	r5,r12
8000b2fc:	16 97       	mov	r7,r11
8000b2fe:	74 28       	ld.w	r8,r10[0x8]
8000b300:	58 08       	cp.w	r8,0
8000b302:	e0 80 01 40 	breq	8000b582 <__sfvwrite_r+0x28e>
8000b306:	96 68       	ld.sh	r8,r11[0xc]
8000b308:	ed b8 00 03 	bld	r8,0x3
8000b30c:	c0 41       	brne	8000b314 <__sfvwrite_r+0x20>
8000b30e:	76 48       	ld.w	r8,r11[0x10]
8000b310:	58 08       	cp.w	r8,0
8000b312:	c0 c1       	brne	8000b32a <__sfvwrite_r+0x36>
8000b314:	0e 9b       	mov	r11,r7
8000b316:	0a 9c       	mov	r12,r5
8000b318:	fe b0 f6 c4 	rcall	8000a0a0 <__swsetup_r>
8000b31c:	c0 70       	breq	8000b32a <__sfvwrite_r+0x36>
8000b31e:	8e 68       	ld.sh	r8,r7[0xc]
8000b320:	a7 a8       	sbr	r8,0x6
8000b322:	ae 68       	st.h	r7[0xc],r8
8000b324:	30 98       	mov	r8,9
8000b326:	8b 38       	st.w	r5[0xc],r8
8000b328:	c2 b9       	rjmp	8000b57e <__sfvwrite_r+0x28a>
8000b32a:	8e 63       	ld.sh	r3,r7[0xc]
8000b32c:	68 00       	ld.w	r0,r4[0x0]
8000b32e:	06 96       	mov	r6,r3
8000b330:	e2 16 00 02 	andl	r6,0x2,COH
8000b334:	c2 10       	breq	8000b376 <__sfvwrite_r+0x82>
8000b336:	30 03       	mov	r3,0
8000b338:	e0 62 04 00 	mov	r2,1024
8000b33c:	06 96       	mov	r6,r3
8000b33e:	c0 48       	rjmp	8000b346 <__sfvwrite_r+0x52>
8000b340:	60 03       	ld.w	r3,r0[0x0]
8000b342:	60 16       	ld.w	r6,r0[0x4]
8000b344:	2f 80       	sub	r0,-8
8000b346:	58 06       	cp.w	r6,0
8000b348:	cf c0       	breq	8000b340 <__sfvwrite_r+0x4c>
8000b34a:	e0 46 04 00 	cp.w	r6,1024
8000b34e:	ec 09 17 80 	movls	r9,r6
8000b352:	e4 09 17 b0 	movhi	r9,r2
8000b356:	06 9a       	mov	r10,r3
8000b358:	6e a8       	ld.w	r8,r7[0x28]
8000b35a:	6e 8b       	ld.w	r11,r7[0x20]
8000b35c:	0a 9c       	mov	r12,r5
8000b35e:	5d 18       	icall	r8
8000b360:	18 16       	sub	r6,r12
8000b362:	58 0c       	cp.w	r12,0
8000b364:	e0 8a 01 0a 	brle	8000b578 <__sfvwrite_r+0x284>
8000b368:	68 28       	ld.w	r8,r4[0x8]
8000b36a:	18 18       	sub	r8,r12
8000b36c:	89 28       	st.w	r4[0x8],r8
8000b36e:	e0 80 01 0a 	breq	8000b582 <__sfvwrite_r+0x28e>
8000b372:	18 03       	add	r3,r12
8000b374:	ce 9b       	rjmp	8000b346 <__sfvwrite_r+0x52>
8000b376:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b37a:	c0 70       	breq	8000b388 <__sfvwrite_r+0x94>
8000b37c:	50 06       	stdsp	sp[0x0],r6
8000b37e:	0c 93       	mov	r3,r6
8000b380:	0c 91       	mov	r1,r6
8000b382:	50 15       	stdsp	sp[0x4],r5
8000b384:	08 92       	mov	r2,r4
8000b386:	c9 c8       	rjmp	8000b4be <__sfvwrite_r+0x1ca>
8000b388:	06 96       	mov	r6,r3
8000b38a:	08 91       	mov	r1,r4
8000b38c:	c0 48       	rjmp	8000b394 <__sfvwrite_r+0xa0>
8000b38e:	60 03       	ld.w	r3,r0[0x0]
8000b390:	60 16       	ld.w	r6,r0[0x4]
8000b392:	2f 80       	sub	r0,-8
8000b394:	58 06       	cp.w	r6,0
8000b396:	cf c0       	breq	8000b38e <__sfvwrite_r+0x9a>
8000b398:	8e 68       	ld.sh	r8,r7[0xc]
8000b39a:	6e 24       	ld.w	r4,r7[0x8]
8000b39c:	10 99       	mov	r9,r8
8000b39e:	e2 19 02 00 	andl	r9,0x200,COH
8000b3a2:	c5 50       	breq	8000b44c <__sfvwrite_r+0x158>
8000b3a4:	08 36       	cp.w	r6,r4
8000b3a6:	c4 43       	brcs	8000b42e <__sfvwrite_r+0x13a>
8000b3a8:	10 99       	mov	r9,r8
8000b3aa:	e2 19 04 80 	andl	r9,0x480,COH
8000b3ae:	c4 00       	breq	8000b42e <__sfvwrite_r+0x13a>
8000b3b0:	6e 4b       	ld.w	r11,r7[0x10]
8000b3b2:	6e 09       	ld.w	r9,r7[0x0]
8000b3b4:	16 19       	sub	r9,r11
8000b3b6:	50 09       	stdsp	sp[0x0],r9
8000b3b8:	6e 59       	ld.w	r9,r7[0x14]
8000b3ba:	10 9c       	mov	r12,r8
8000b3bc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b3c0:	30 28       	mov	r8,2
8000b3c2:	f4 08 0c 08 	divs	r8,r10,r8
8000b3c6:	fa e9 00 04 	st.d	sp[4],r8
8000b3ca:	10 94       	mov	r4,r8
8000b3cc:	40 09       	lddsp	r9,sp[0x0]
8000b3ce:	e2 1c 04 00 	andl	r12,0x400,COH
8000b3d2:	2f f9       	sub	r9,-1
8000b3d4:	0c 09       	add	r9,r6
8000b3d6:	12 38       	cp.w	r8,r9
8000b3d8:	f2 04 17 30 	movlo	r4,r9
8000b3dc:	58 0c       	cp.w	r12,0
8000b3de:	c1 10       	breq	8000b400 <__sfvwrite_r+0x10c>
8000b3e0:	08 9b       	mov	r11,r4
8000b3e2:	0a 9c       	mov	r12,r5
8000b3e4:	fe b0 e0 6c 	rcall	800074bc <_malloc_r>
8000b3e8:	18 92       	mov	r2,r12
8000b3ea:	c1 40       	breq	8000b412 <__sfvwrite_r+0x11e>
8000b3ec:	40 0a       	lddsp	r10,sp[0x0]
8000b3ee:	6e 4b       	ld.w	r11,r7[0x10]
8000b3f0:	fe b0 e2 82 	rcall	800078f4 <memcpy>
8000b3f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3f6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b3fa:	a7 b8       	sbr	r8,0x7
8000b3fc:	ae 68       	st.h	r7[0xc],r8
8000b3fe:	c0 d8       	rjmp	8000b418 <__sfvwrite_r+0x124>
8000b400:	08 9a       	mov	r10,r4
8000b402:	0a 9c       	mov	r12,r5
8000b404:	fe b0 e3 24 	rcall	80007a4c <_realloc_r>
8000b408:	18 92       	mov	r2,r12
8000b40a:	c0 71       	brne	8000b418 <__sfvwrite_r+0x124>
8000b40c:	6e 4b       	ld.w	r11,r7[0x10]
8000b40e:	0a 9c       	mov	r12,r5
8000b410:	ca ce       	rcall	8000b168 <_free_r>
8000b412:	30 c8       	mov	r8,12
8000b414:	8b 38       	st.w	r5[0xc],r8
8000b416:	cb 18       	rjmp	8000b578 <__sfvwrite_r+0x284>
8000b418:	40 0a       	lddsp	r10,sp[0x0]
8000b41a:	40 09       	lddsp	r9,sp[0x0]
8000b41c:	e8 0a 01 0a 	sub	r10,r4,r10
8000b420:	e4 09 00 08 	add	r8,r2,r9
8000b424:	8f 54       	st.w	r7[0x14],r4
8000b426:	8f 2a       	st.w	r7[0x8],r10
8000b428:	8f 08       	st.w	r7[0x0],r8
8000b42a:	8f 42       	st.w	r7[0x10],r2
8000b42c:	0c 94       	mov	r4,r6
8000b42e:	08 36       	cp.w	r6,r4
8000b430:	ec 04 17 30 	movlo	r4,r6
8000b434:	06 9b       	mov	r11,r3
8000b436:	08 9a       	mov	r10,r4
8000b438:	6e 0c       	ld.w	r12,r7[0x0]
8000b43a:	c3 ad       	rcall	8000b6ae <memmove>
8000b43c:	6e 08       	ld.w	r8,r7[0x0]
8000b43e:	08 08       	add	r8,r4
8000b440:	8f 08       	st.w	r7[0x0],r8
8000b442:	6e 28       	ld.w	r8,r7[0x8]
8000b444:	08 18       	sub	r8,r4
8000b446:	0c 94       	mov	r4,r6
8000b448:	8f 28       	st.w	r7[0x8],r8
8000b44a:	c2 e8       	rjmp	8000b4a6 <__sfvwrite_r+0x1b2>
8000b44c:	08 36       	cp.w	r6,r4
8000b44e:	5f ba       	srhi	r10
8000b450:	6e 0c       	ld.w	r12,r7[0x0]
8000b452:	6e 48       	ld.w	r8,r7[0x10]
8000b454:	10 3c       	cp.w	r12,r8
8000b456:	5f b8       	srhi	r8
8000b458:	f5 e8 00 08 	and	r8,r10,r8
8000b45c:	f2 08 18 00 	cp.b	r8,r9
8000b460:	c0 d0       	breq	8000b47a <__sfvwrite_r+0x186>
8000b462:	06 9b       	mov	r11,r3
8000b464:	08 9a       	mov	r10,r4
8000b466:	c2 4d       	rcall	8000b6ae <memmove>
8000b468:	6e 08       	ld.w	r8,r7[0x0]
8000b46a:	08 08       	add	r8,r4
8000b46c:	0e 9b       	mov	r11,r7
8000b46e:	8f 08       	st.w	r7[0x0],r8
8000b470:	0a 9c       	mov	r12,r5
8000b472:	fe b0 fd 09 	rcall	8000ae84 <_fflush_r>
8000b476:	c1 80       	breq	8000b4a6 <__sfvwrite_r+0x1b2>
8000b478:	c8 08       	rjmp	8000b578 <__sfvwrite_r+0x284>
8000b47a:	6e 59       	ld.w	r9,r7[0x14]
8000b47c:	12 36       	cp.w	r6,r9
8000b47e:	c0 a3       	brcs	8000b492 <__sfvwrite_r+0x19e>
8000b480:	6e a8       	ld.w	r8,r7[0x28]
8000b482:	06 9a       	mov	r10,r3
8000b484:	6e 8b       	ld.w	r11,r7[0x20]
8000b486:	0a 9c       	mov	r12,r5
8000b488:	5d 18       	icall	r8
8000b48a:	18 94       	mov	r4,r12
8000b48c:	e0 89 00 0d 	brgt	8000b4a6 <__sfvwrite_r+0x1b2>
8000b490:	c7 48       	rjmp	8000b578 <__sfvwrite_r+0x284>
8000b492:	0c 9a       	mov	r10,r6
8000b494:	06 9b       	mov	r11,r3
8000b496:	c0 cd       	rcall	8000b6ae <memmove>
8000b498:	6e 08       	ld.w	r8,r7[0x0]
8000b49a:	0c 08       	add	r8,r6
8000b49c:	0c 94       	mov	r4,r6
8000b49e:	8f 08       	st.w	r7[0x0],r8
8000b4a0:	6e 28       	ld.w	r8,r7[0x8]
8000b4a2:	0c 18       	sub	r8,r6
8000b4a4:	8f 28       	st.w	r7[0x8],r8
8000b4a6:	62 28       	ld.w	r8,r1[0x8]
8000b4a8:	08 18       	sub	r8,r4
8000b4aa:	83 28       	st.w	r1[0x8],r8
8000b4ac:	c6 b0       	breq	8000b582 <__sfvwrite_r+0x28e>
8000b4ae:	08 16       	sub	r6,r4
8000b4b0:	08 03       	add	r3,r4
8000b4b2:	c7 1b       	rjmp	8000b394 <__sfvwrite_r+0xa0>
8000b4b4:	60 03       	ld.w	r3,r0[0x0]
8000b4b6:	60 11       	ld.w	r1,r0[0x4]
8000b4b8:	30 08       	mov	r8,0
8000b4ba:	2f 80       	sub	r0,-8
8000b4bc:	50 08       	stdsp	sp[0x0],r8
8000b4be:	58 01       	cp.w	r1,0
8000b4c0:	cf a0       	breq	8000b4b4 <__sfvwrite_r+0x1c0>
8000b4c2:	40 0a       	lddsp	r10,sp[0x0]
8000b4c4:	58 0a       	cp.w	r10,0
8000b4c6:	c1 41       	brne	8000b4ee <__sfvwrite_r+0x1fa>
8000b4c8:	e2 c6 ff ff 	sub	r6,r1,-1
8000b4cc:	02 9a       	mov	r10,r1
8000b4ce:	30 ab       	mov	r11,10
8000b4d0:	06 9c       	mov	r12,r3
8000b4d2:	ce 3c       	rcall	8000b698 <memchr>
8000b4d4:	f8 c8 ff ff 	sub	r8,r12,-1
8000b4d8:	58 0c       	cp.w	r12,0
8000b4da:	f1 d3 e1 16 	subne	r6,r8,r3
8000b4de:	f9 b9 01 01 	movne	r9,1
8000b4e2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b4e6:	f9 b8 00 01 	moveq	r8,1
8000b4ea:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b4ee:	02 36       	cp.w	r6,r1
8000b4f0:	ec 04 17 80 	movls	r4,r6
8000b4f4:	e2 04 17 b0 	movhi	r4,r1
8000b4f8:	6e 59       	ld.w	r9,r7[0x14]
8000b4fa:	6e 25       	ld.w	r5,r7[0x8]
8000b4fc:	f2 05 00 05 	add	r5,r9,r5
8000b500:	0a 34       	cp.w	r4,r5
8000b502:	5f 9a       	srgt	r10
8000b504:	6e 0c       	ld.w	r12,r7[0x0]
8000b506:	6e 48       	ld.w	r8,r7[0x10]
8000b508:	10 3c       	cp.w	r12,r8
8000b50a:	5f b8       	srhi	r8
8000b50c:	f5 e8 00 08 	and	r8,r10,r8
8000b510:	30 0a       	mov	r10,0
8000b512:	f4 08 18 00 	cp.b	r8,r10
8000b516:	c0 d0       	breq	8000b530 <__sfvwrite_r+0x23c>
8000b518:	06 9b       	mov	r11,r3
8000b51a:	0a 9a       	mov	r10,r5
8000b51c:	cc 9c       	rcall	8000b6ae <memmove>
8000b51e:	6e 08       	ld.w	r8,r7[0x0]
8000b520:	0a 08       	add	r8,r5
8000b522:	0e 9b       	mov	r11,r7
8000b524:	8f 08       	st.w	r7[0x0],r8
8000b526:	40 1c       	lddsp	r12,sp[0x4]
8000b528:	fe b0 fc ae 	rcall	8000ae84 <_fflush_r>
8000b52c:	c1 70       	breq	8000b55a <__sfvwrite_r+0x266>
8000b52e:	c2 58       	rjmp	8000b578 <__sfvwrite_r+0x284>
8000b530:	12 34       	cp.w	r4,r9
8000b532:	c0 a5       	brlt	8000b546 <__sfvwrite_r+0x252>
8000b534:	6e a8       	ld.w	r8,r7[0x28]
8000b536:	06 9a       	mov	r10,r3
8000b538:	6e 8b       	ld.w	r11,r7[0x20]
8000b53a:	40 1c       	lddsp	r12,sp[0x4]
8000b53c:	5d 18       	icall	r8
8000b53e:	18 95       	mov	r5,r12
8000b540:	e0 89 00 0d 	brgt	8000b55a <__sfvwrite_r+0x266>
8000b544:	c1 a8       	rjmp	8000b578 <__sfvwrite_r+0x284>
8000b546:	08 9a       	mov	r10,r4
8000b548:	06 9b       	mov	r11,r3
8000b54a:	cb 2c       	rcall	8000b6ae <memmove>
8000b54c:	6e 08       	ld.w	r8,r7[0x0]
8000b54e:	08 08       	add	r8,r4
8000b550:	08 95       	mov	r5,r4
8000b552:	8f 08       	st.w	r7[0x0],r8
8000b554:	6e 28       	ld.w	r8,r7[0x8]
8000b556:	08 18       	sub	r8,r4
8000b558:	8f 28       	st.w	r7[0x8],r8
8000b55a:	0a 16       	sub	r6,r5
8000b55c:	c0 71       	brne	8000b56a <__sfvwrite_r+0x276>
8000b55e:	0e 9b       	mov	r11,r7
8000b560:	40 1c       	lddsp	r12,sp[0x4]
8000b562:	fe b0 fc 91 	rcall	8000ae84 <_fflush_r>
8000b566:	c0 91       	brne	8000b578 <__sfvwrite_r+0x284>
8000b568:	50 06       	stdsp	sp[0x0],r6
8000b56a:	64 28       	ld.w	r8,r2[0x8]
8000b56c:	0a 18       	sub	r8,r5
8000b56e:	85 28       	st.w	r2[0x8],r8
8000b570:	c0 90       	breq	8000b582 <__sfvwrite_r+0x28e>
8000b572:	0a 11       	sub	r1,r5
8000b574:	0a 03       	add	r3,r5
8000b576:	ca 4b       	rjmp	8000b4be <__sfvwrite_r+0x1ca>
8000b578:	8e 68       	ld.sh	r8,r7[0xc]
8000b57a:	a7 a8       	sbr	r8,0x6
8000b57c:	ae 68       	st.h	r7[0xc],r8
8000b57e:	3f fc       	mov	r12,-1
8000b580:	c0 28       	rjmp	8000b584 <__sfvwrite_r+0x290>
8000b582:	30 0c       	mov	r12,0
8000b584:	2f dd       	sub	sp,-12
8000b586:	d8 32       	popm	r0-r7,pc

8000b588 <_fwalk>:
8000b588:	d4 31       	pushm	r0-r7,lr
8000b58a:	30 05       	mov	r5,0
8000b58c:	16 91       	mov	r1,r11
8000b58e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b592:	0a 92       	mov	r2,r5
8000b594:	fe b0 fc fe 	rcall	8000af90 <__sfp_lock_acquire>
8000b598:	3f f3       	mov	r3,-1
8000b59a:	c1 68       	rjmp	8000b5c6 <_fwalk+0x3e>
8000b59c:	6e 26       	ld.w	r6,r7[0x8]
8000b59e:	6e 14       	ld.w	r4,r7[0x4]
8000b5a0:	2f 46       	sub	r6,-12
8000b5a2:	c0 c8       	rjmp	8000b5ba <_fwalk+0x32>
8000b5a4:	8c 08       	ld.sh	r8,r6[0x0]
8000b5a6:	e4 08 19 00 	cp.h	r8,r2
8000b5aa:	c0 70       	breq	8000b5b8 <_fwalk+0x30>
8000b5ac:	8c 18       	ld.sh	r8,r6[0x2]
8000b5ae:	e6 08 19 00 	cp.h	r8,r3
8000b5b2:	c0 30       	breq	8000b5b8 <_fwalk+0x30>
8000b5b4:	5d 11       	icall	r1
8000b5b6:	18 45       	or	r5,r12
8000b5b8:	2a 46       	sub	r6,-92
8000b5ba:	20 14       	sub	r4,1
8000b5bc:	ec cc 00 0c 	sub	r12,r6,12
8000b5c0:	58 04       	cp.w	r4,0
8000b5c2:	cf 14       	brge	8000b5a4 <_fwalk+0x1c>
8000b5c4:	6e 07       	ld.w	r7,r7[0x0]
8000b5c6:	58 07       	cp.w	r7,0
8000b5c8:	ce a1       	brne	8000b59c <_fwalk+0x14>
8000b5ca:	fe b0 fc e4 	rcall	8000af92 <__sfp_lock_release>
8000b5ce:	0a 9c       	mov	r12,r5
8000b5d0:	d8 32       	popm	r0-r7,pc
8000b5d2:	d7 03       	nop

8000b5d4 <_localeconv_r>:
8000b5d4:	fe cc d4 54 	sub	r12,pc,-11180
8000b5d8:	5e fc       	retal	r12
8000b5da:	d7 03       	nop

8000b5dc <__smakebuf_r>:
8000b5dc:	d4 21       	pushm	r4-r7,lr
8000b5de:	20 fd       	sub	sp,60
8000b5e0:	96 68       	ld.sh	r8,r11[0xc]
8000b5e2:	16 97       	mov	r7,r11
8000b5e4:	18 96       	mov	r6,r12
8000b5e6:	e2 18 00 02 	andl	r8,0x2,COH
8000b5ea:	c3 d1       	brne	8000b664 <__smakebuf_r+0x88>
8000b5ec:	96 7b       	ld.sh	r11,r11[0xe]
8000b5ee:	f0 0b 19 00 	cp.h	r11,r8
8000b5f2:	c0 55       	brlt	8000b5fc <__smakebuf_r+0x20>
8000b5f4:	1a 9a       	mov	r10,sp
8000b5f6:	e0 a0 04 81 	rcall	8000bef8 <_fstat_r>
8000b5fa:	c0 f4       	brge	8000b618 <__smakebuf_r+0x3c>
8000b5fc:	8e 65       	ld.sh	r5,r7[0xc]
8000b5fe:	0a 98       	mov	r8,r5
8000b600:	ab b8       	sbr	r8,0xb
8000b602:	e2 15 00 80 	andl	r5,0x80,COH
8000b606:	ae 68       	st.h	r7[0xc],r8
8000b608:	30 04       	mov	r4,0
8000b60a:	e0 68 04 00 	mov	r8,1024
8000b60e:	f9 b5 01 40 	movne	r5,64
8000b612:	f0 05 17 00 	moveq	r5,r8
8000b616:	c1 c8       	rjmp	8000b64e <__smakebuf_r+0x72>
8000b618:	40 18       	lddsp	r8,sp[0x4]
8000b61a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b61e:	e0 48 20 00 	cp.w	r8,8192
8000b622:	5f 04       	sreq	r4
8000b624:	e0 48 80 00 	cp.w	r8,32768
8000b628:	c0 e1       	brne	8000b644 <__smakebuf_r+0x68>
8000b62a:	6e b9       	ld.w	r9,r7[0x2c]
8000b62c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b630:	10 39       	cp.w	r9,r8
8000b632:	c0 91       	brne	8000b644 <__smakebuf_r+0x68>
8000b634:	8e 68       	ld.sh	r8,r7[0xc]
8000b636:	e0 65 04 00 	mov	r5,1024
8000b63a:	ab a8       	sbr	r8,0xa
8000b63c:	ef 45 00 50 	st.w	r7[80],r5
8000b640:	ae 68       	st.h	r7[0xc],r8
8000b642:	c0 68       	rjmp	8000b64e <__smakebuf_r+0x72>
8000b644:	8e 68       	ld.sh	r8,r7[0xc]
8000b646:	e0 65 04 00 	mov	r5,1024
8000b64a:	ab b8       	sbr	r8,0xb
8000b64c:	ae 68       	st.h	r7[0xc],r8
8000b64e:	0a 9b       	mov	r11,r5
8000b650:	0c 9c       	mov	r12,r6
8000b652:	fe b0 df 35 	rcall	800074bc <_malloc_r>
8000b656:	8e 68       	ld.sh	r8,r7[0xc]
8000b658:	c0 d1       	brne	8000b672 <__smakebuf_r+0x96>
8000b65a:	ed b8 00 09 	bld	r8,0x9
8000b65e:	c1 b0       	breq	8000b694 <__smakebuf_r+0xb8>
8000b660:	a1 b8       	sbr	r8,0x1
8000b662:	ae 68       	st.h	r7[0xc],r8
8000b664:	ee c8 ff b9 	sub	r8,r7,-71
8000b668:	8f 48       	st.w	r7[0x10],r8
8000b66a:	8f 08       	st.w	r7[0x0],r8
8000b66c:	30 18       	mov	r8,1
8000b66e:	8f 58       	st.w	r7[0x14],r8
8000b670:	c1 28       	rjmp	8000b694 <__smakebuf_r+0xb8>
8000b672:	a7 b8       	sbr	r8,0x7
8000b674:	8f 4c       	st.w	r7[0x10],r12
8000b676:	ae 68       	st.h	r7[0xc],r8
8000b678:	8f 55       	st.w	r7[0x14],r5
8000b67a:	fe c8 06 e6 	sub	r8,pc,1766
8000b67e:	8f 0c       	st.w	r7[0x0],r12
8000b680:	8d a8       	st.w	r6[0x28],r8
8000b682:	58 04       	cp.w	r4,0
8000b684:	c0 80       	breq	8000b694 <__smakebuf_r+0xb8>
8000b686:	8e 7c       	ld.sh	r12,r7[0xe]
8000b688:	fe b0 e3 94 	rcall	80007db0 <isatty>
8000b68c:	c0 40       	breq	8000b694 <__smakebuf_r+0xb8>
8000b68e:	8e 68       	ld.sh	r8,r7[0xc]
8000b690:	a1 a8       	sbr	r8,0x0
8000b692:	ae 68       	st.h	r7[0xc],r8
8000b694:	2f 1d       	sub	sp,-60
8000b696:	d8 22       	popm	r4-r7,pc

8000b698 <memchr>:
8000b698:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b69c:	c0 68       	rjmp	8000b6a8 <memchr+0x10>
8000b69e:	20 1a       	sub	r10,1
8000b6a0:	19 88       	ld.ub	r8,r12[0x0]
8000b6a2:	16 38       	cp.w	r8,r11
8000b6a4:	5e 0c       	reteq	r12
8000b6a6:	2f fc       	sub	r12,-1
8000b6a8:	58 0a       	cp.w	r10,0
8000b6aa:	cf a1       	brne	8000b69e <memchr+0x6>
8000b6ac:	5e fa       	retal	r10

8000b6ae <memmove>:
8000b6ae:	d4 01       	pushm	lr
8000b6b0:	18 3b       	cp.w	r11,r12
8000b6b2:	c1 92       	brcc	8000b6e4 <memmove+0x36>
8000b6b4:	f6 0a 00 09 	add	r9,r11,r10
8000b6b8:	12 3c       	cp.w	r12,r9
8000b6ba:	c1 52       	brcc	8000b6e4 <memmove+0x36>
8000b6bc:	f8 0a 00 0b 	add	r11,r12,r10
8000b6c0:	30 08       	mov	r8,0
8000b6c2:	c0 68       	rjmp	8000b6ce <memmove+0x20>
8000b6c4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b6c8:	20 1a       	sub	r10,1
8000b6ca:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b6ce:	20 18       	sub	r8,1
8000b6d0:	58 0a       	cp.w	r10,0
8000b6d2:	cf 91       	brne	8000b6c4 <memmove+0x16>
8000b6d4:	d8 02       	popm	pc
8000b6d6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b6da:	20 1a       	sub	r10,1
8000b6dc:	f8 08 0b 09 	st.b	r12[r8],r9
8000b6e0:	2f f8       	sub	r8,-1
8000b6e2:	c0 28       	rjmp	8000b6e6 <memmove+0x38>
8000b6e4:	30 08       	mov	r8,0
8000b6e6:	58 0a       	cp.w	r10,0
8000b6e8:	cf 71       	brne	8000b6d6 <memmove+0x28>
8000b6ea:	d8 02       	popm	pc

8000b6ec <__hi0bits>:
8000b6ec:	18 98       	mov	r8,r12
8000b6ee:	e0 1c 00 00 	andl	r12,0x0
8000b6f2:	f0 09 15 10 	lsl	r9,r8,0x10
8000b6f6:	58 0c       	cp.w	r12,0
8000b6f8:	f2 08 17 00 	moveq	r8,r9
8000b6fc:	f9 bc 00 10 	moveq	r12,16
8000b700:	f9 bc 01 00 	movne	r12,0
8000b704:	10 9a       	mov	r10,r8
8000b706:	f0 09 15 08 	lsl	r9,r8,0x8
8000b70a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b70e:	f7 bc 00 f8 	subeq	r12,-8
8000b712:	f2 08 17 00 	moveq	r8,r9
8000b716:	10 9a       	mov	r10,r8
8000b718:	f0 09 15 04 	lsl	r9,r8,0x4
8000b71c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b720:	f7 bc 00 fc 	subeq	r12,-4
8000b724:	f2 08 17 00 	moveq	r8,r9
8000b728:	10 9a       	mov	r10,r8
8000b72a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b72e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b732:	f7 bc 00 fe 	subeq	r12,-2
8000b736:	f2 08 17 00 	moveq	r8,r9
8000b73a:	58 08       	cp.w	r8,0
8000b73c:	5e 5c       	retlt	r12
8000b73e:	ed b8 00 1e 	bld	r8,0x1e
8000b742:	f9 bc 01 20 	movne	r12,32
8000b746:	f7 bc 00 ff 	subeq	r12,-1
8000b74a:	5e fc       	retal	r12

8000b74c <__lo0bits>:
8000b74c:	18 99       	mov	r9,r12
8000b74e:	78 08       	ld.w	r8,r12[0x0]
8000b750:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b754:	c1 50       	breq	8000b77e <__lo0bits+0x32>
8000b756:	ed b8 00 00 	bld	r8,0x0
8000b75a:	c0 21       	brne	8000b75e <__lo0bits+0x12>
8000b75c:	5e fd       	retal	0
8000b75e:	10 9b       	mov	r11,r8
8000b760:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b764:	e2 1b 00 02 	andl	r11,0x2,COH
8000b768:	a3 88       	lsr	r8,0x2
8000b76a:	58 0b       	cp.w	r11,0
8000b76c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b770:	f9 bc 01 01 	movne	r12,1
8000b774:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b778:	f9 bc 00 02 	moveq	r12,2
8000b77c:	5e fc       	retal	r12
8000b77e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b782:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b786:	58 0a       	cp.w	r10,0
8000b788:	f6 08 17 00 	moveq	r8,r11
8000b78c:	f9 bc 00 10 	moveq	r12,16
8000b790:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b794:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b798:	58 0b       	cp.w	r11,0
8000b79a:	f7 bc 00 f8 	subeq	r12,-8
8000b79e:	f4 08 17 00 	moveq	r8,r10
8000b7a2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b7a6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b7aa:	58 0b       	cp.w	r11,0
8000b7ac:	f7 bc 00 fc 	subeq	r12,-4
8000b7b0:	f4 08 17 00 	moveq	r8,r10
8000b7b4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b7b8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b7bc:	58 0b       	cp.w	r11,0
8000b7be:	f7 bc 00 fe 	subeq	r12,-2
8000b7c2:	f4 08 17 00 	moveq	r8,r10
8000b7c6:	ed b8 00 00 	bld	r8,0x0
8000b7ca:	c0 60       	breq	8000b7d6 <__lo0bits+0x8a>
8000b7cc:	a1 98       	lsr	r8,0x1
8000b7ce:	c0 31       	brne	8000b7d4 <__lo0bits+0x88>
8000b7d0:	32 0c       	mov	r12,32
8000b7d2:	5e fc       	retal	r12
8000b7d4:	2f fc       	sub	r12,-1
8000b7d6:	93 08       	st.w	r9[0x0],r8
8000b7d8:	5e fc       	retal	r12

8000b7da <__mcmp>:
8000b7da:	d4 01       	pushm	lr
8000b7dc:	18 98       	mov	r8,r12
8000b7de:	76 49       	ld.w	r9,r11[0x10]
8000b7e0:	78 4c       	ld.w	r12,r12[0x10]
8000b7e2:	12 1c       	sub	r12,r9
8000b7e4:	c1 31       	brne	8000b80a <__mcmp+0x30>
8000b7e6:	2f b9       	sub	r9,-5
8000b7e8:	a3 69       	lsl	r9,0x2
8000b7ea:	12 0b       	add	r11,r9
8000b7ec:	f0 09 00 09 	add	r9,r8,r9
8000b7f0:	2e c8       	sub	r8,-20
8000b7f2:	13 4e       	ld.w	lr,--r9
8000b7f4:	17 4a       	ld.w	r10,--r11
8000b7f6:	14 3e       	cp.w	lr,r10
8000b7f8:	c0 60       	breq	8000b804 <__mcmp+0x2a>
8000b7fa:	f9 bc 03 ff 	movlo	r12,-1
8000b7fe:	f9 bc 02 01 	movhs	r12,1
8000b802:	d8 02       	popm	pc
8000b804:	10 39       	cp.w	r9,r8
8000b806:	fe 9b ff f6 	brhi	8000b7f2 <__mcmp+0x18>
8000b80a:	d8 02       	popm	pc

8000b80c <_Bfree>:
8000b80c:	d4 21       	pushm	r4-r7,lr
8000b80e:	18 97       	mov	r7,r12
8000b810:	16 95       	mov	r5,r11
8000b812:	78 96       	ld.w	r6,r12[0x24]
8000b814:	58 06       	cp.w	r6,0
8000b816:	c0 91       	brne	8000b828 <_Bfree+0x1c>
8000b818:	31 0c       	mov	r12,16
8000b81a:	fe b0 de 49 	rcall	800074ac <malloc>
8000b81e:	99 36       	st.w	r12[0xc],r6
8000b820:	8f 9c       	st.w	r7[0x24],r12
8000b822:	99 16       	st.w	r12[0x4],r6
8000b824:	99 26       	st.w	r12[0x8],r6
8000b826:	99 06       	st.w	r12[0x0],r6
8000b828:	58 05       	cp.w	r5,0
8000b82a:	c0 90       	breq	8000b83c <_Bfree+0x30>
8000b82c:	6a 19       	ld.w	r9,r5[0x4]
8000b82e:	6e 98       	ld.w	r8,r7[0x24]
8000b830:	70 38       	ld.w	r8,r8[0xc]
8000b832:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b836:	8b 0a       	st.w	r5[0x0],r10
8000b838:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b83c:	d8 22       	popm	r4-r7,pc
8000b83e:	d7 03       	nop

8000b840 <_Balloc>:
8000b840:	d4 21       	pushm	r4-r7,lr
8000b842:	18 97       	mov	r7,r12
8000b844:	16 96       	mov	r6,r11
8000b846:	78 95       	ld.w	r5,r12[0x24]
8000b848:	58 05       	cp.w	r5,0
8000b84a:	c0 91       	brne	8000b85c <_Balloc+0x1c>
8000b84c:	31 0c       	mov	r12,16
8000b84e:	fe b0 de 2f 	rcall	800074ac <malloc>
8000b852:	99 35       	st.w	r12[0xc],r5
8000b854:	8f 9c       	st.w	r7[0x24],r12
8000b856:	99 15       	st.w	r12[0x4],r5
8000b858:	99 25       	st.w	r12[0x8],r5
8000b85a:	99 05       	st.w	r12[0x0],r5
8000b85c:	6e 95       	ld.w	r5,r7[0x24]
8000b85e:	6a 38       	ld.w	r8,r5[0xc]
8000b860:	58 08       	cp.w	r8,0
8000b862:	c0 b1       	brne	8000b878 <_Balloc+0x38>
8000b864:	31 0a       	mov	r10,16
8000b866:	30 4b       	mov	r11,4
8000b868:	0e 9c       	mov	r12,r7
8000b86a:	e0 a0 02 a7 	rcall	8000bdb8 <_calloc_r>
8000b86e:	8b 3c       	st.w	r5[0xc],r12
8000b870:	6e 98       	ld.w	r8,r7[0x24]
8000b872:	70 3c       	ld.w	r12,r8[0xc]
8000b874:	58 0c       	cp.w	r12,0
8000b876:	c1 b0       	breq	8000b8ac <_Balloc+0x6c>
8000b878:	6e 98       	ld.w	r8,r7[0x24]
8000b87a:	70 38       	ld.w	r8,r8[0xc]
8000b87c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b880:	70 0c       	ld.w	r12,r8[0x0]
8000b882:	58 0c       	cp.w	r12,0
8000b884:	c0 40       	breq	8000b88c <_Balloc+0x4c>
8000b886:	78 09       	ld.w	r9,r12[0x0]
8000b888:	91 09       	st.w	r8[0x0],r9
8000b88a:	c0 e8       	rjmp	8000b8a6 <_Balloc+0x66>
8000b88c:	0e 9c       	mov	r12,r7
8000b88e:	30 17       	mov	r7,1
8000b890:	0e 9b       	mov	r11,r7
8000b892:	ee 06 09 47 	lsl	r7,r7,r6
8000b896:	ee ca ff fb 	sub	r10,r7,-5
8000b89a:	a3 6a       	lsl	r10,0x2
8000b89c:	e0 a0 02 8e 	rcall	8000bdb8 <_calloc_r>
8000b8a0:	c0 60       	breq	8000b8ac <_Balloc+0x6c>
8000b8a2:	99 16       	st.w	r12[0x4],r6
8000b8a4:	99 27       	st.w	r12[0x8],r7
8000b8a6:	30 08       	mov	r8,0
8000b8a8:	99 38       	st.w	r12[0xc],r8
8000b8aa:	99 48       	st.w	r12[0x10],r8
8000b8ac:	d8 22       	popm	r4-r7,pc
8000b8ae:	d7 03       	nop

8000b8b0 <__d2b>:
8000b8b0:	d4 31       	pushm	r0-r7,lr
8000b8b2:	20 2d       	sub	sp,8
8000b8b4:	16 93       	mov	r3,r11
8000b8b6:	12 96       	mov	r6,r9
8000b8b8:	10 95       	mov	r5,r8
8000b8ba:	14 92       	mov	r2,r10
8000b8bc:	30 1b       	mov	r11,1
8000b8be:	cc 1f       	rcall	8000b840 <_Balloc>
8000b8c0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b8c4:	50 09       	stdsp	sp[0x0],r9
8000b8c6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b8ca:	b5 a9       	sbr	r9,0x14
8000b8cc:	f0 01 16 14 	lsr	r1,r8,0x14
8000b8d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b8d4:	18 94       	mov	r4,r12
8000b8d6:	58 02       	cp.w	r2,0
8000b8d8:	c1 d0       	breq	8000b912 <__d2b+0x62>
8000b8da:	fa cc ff f8 	sub	r12,sp,-8
8000b8de:	18 d2       	st.w	--r12,r2
8000b8e0:	c3 6f       	rcall	8000b74c <__lo0bits>
8000b8e2:	40 18       	lddsp	r8,sp[0x4]
8000b8e4:	c0 d0       	breq	8000b8fe <__d2b+0x4e>
8000b8e6:	40 09       	lddsp	r9,sp[0x0]
8000b8e8:	f8 0a 11 20 	rsub	r10,r12,32
8000b8ec:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b8f0:	f5 e8 10 08 	or	r8,r10,r8
8000b8f4:	89 58       	st.w	r4[0x14],r8
8000b8f6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b8fa:	50 09       	stdsp	sp[0x0],r9
8000b8fc:	c0 28       	rjmp	8000b900 <__d2b+0x50>
8000b8fe:	89 58       	st.w	r4[0x14],r8
8000b900:	40 08       	lddsp	r8,sp[0x0]
8000b902:	58 08       	cp.w	r8,0
8000b904:	f9 b3 01 02 	movne	r3,2
8000b908:	f9 b3 00 01 	moveq	r3,1
8000b90c:	89 68       	st.w	r4[0x18],r8
8000b90e:	89 43       	st.w	r4[0x10],r3
8000b910:	c0 88       	rjmp	8000b920 <__d2b+0x70>
8000b912:	1a 9c       	mov	r12,sp
8000b914:	c1 cf       	rcall	8000b74c <__lo0bits>
8000b916:	30 13       	mov	r3,1
8000b918:	40 08       	lddsp	r8,sp[0x0]
8000b91a:	2e 0c       	sub	r12,-32
8000b91c:	89 43       	st.w	r4[0x10],r3
8000b91e:	89 58       	st.w	r4[0x14],r8
8000b920:	58 01       	cp.w	r1,0
8000b922:	c0 90       	breq	8000b934 <__d2b+0x84>
8000b924:	e2 c1 04 33 	sub	r1,r1,1075
8000b928:	18 01       	add	r1,r12
8000b92a:	8d 01       	st.w	r6[0x0],r1
8000b92c:	f8 0c 11 35 	rsub	r12,r12,53
8000b930:	8b 0c       	st.w	r5[0x0],r12
8000b932:	c0 c8       	rjmp	8000b94a <__d2b+0x9a>
8000b934:	e6 c8 ff fc 	sub	r8,r3,-4
8000b938:	f8 cc 04 32 	sub	r12,r12,1074
8000b93c:	a5 73       	lsl	r3,0x5
8000b93e:	8d 0c       	st.w	r6[0x0],r12
8000b940:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b944:	cd 4e       	rcall	8000b6ec <__hi0bits>
8000b946:	18 13       	sub	r3,r12
8000b948:	8b 03       	st.w	r5[0x0],r3
8000b94a:	08 9c       	mov	r12,r4
8000b94c:	2f ed       	sub	sp,-8
8000b94e:	d8 32       	popm	r0-r7,pc

8000b950 <__mdiff>:
8000b950:	d4 31       	pushm	r0-r7,lr
8000b952:	74 48       	ld.w	r8,r10[0x10]
8000b954:	76 45       	ld.w	r5,r11[0x10]
8000b956:	16 97       	mov	r7,r11
8000b958:	14 96       	mov	r6,r10
8000b95a:	10 15       	sub	r5,r8
8000b95c:	c1 31       	brne	8000b982 <__mdiff+0x32>
8000b95e:	2f b8       	sub	r8,-5
8000b960:	ee ce ff ec 	sub	lr,r7,-20
8000b964:	a3 68       	lsl	r8,0x2
8000b966:	f4 08 00 0b 	add	r11,r10,r8
8000b96a:	ee 08 00 08 	add	r8,r7,r8
8000b96e:	11 4a       	ld.w	r10,--r8
8000b970:	17 49       	ld.w	r9,--r11
8000b972:	12 3a       	cp.w	r10,r9
8000b974:	c0 30       	breq	8000b97a <__mdiff+0x2a>
8000b976:	c0 e2       	brcc	8000b992 <__mdiff+0x42>
8000b978:	c0 78       	rjmp	8000b986 <__mdiff+0x36>
8000b97a:	1c 38       	cp.w	r8,lr
8000b97c:	fe 9b ff f9 	brhi	8000b96e <__mdiff+0x1e>
8000b980:	c4 98       	rjmp	8000ba12 <__mdiff+0xc2>
8000b982:	58 05       	cp.w	r5,0
8000b984:	c0 64       	brge	8000b990 <__mdiff+0x40>
8000b986:	0e 98       	mov	r8,r7
8000b988:	30 15       	mov	r5,1
8000b98a:	0c 97       	mov	r7,r6
8000b98c:	10 96       	mov	r6,r8
8000b98e:	c0 28       	rjmp	8000b992 <__mdiff+0x42>
8000b990:	30 05       	mov	r5,0
8000b992:	6e 1b       	ld.w	r11,r7[0x4]
8000b994:	c5 6f       	rcall	8000b840 <_Balloc>
8000b996:	6e 49       	ld.w	r9,r7[0x10]
8000b998:	6c 44       	ld.w	r4,r6[0x10]
8000b99a:	99 35       	st.w	r12[0xc],r5
8000b99c:	2f b4       	sub	r4,-5
8000b99e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b9a2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b9a6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b9aa:	2e c6       	sub	r6,-20
8000b9ac:	2e c7       	sub	r7,-20
8000b9ae:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9b2:	30 0a       	mov	r10,0
8000b9b4:	0f 0e       	ld.w	lr,r7++
8000b9b6:	0d 0b       	ld.w	r11,r6++
8000b9b8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b9bc:	f6 03 16 10 	lsr	r3,r11,0x10
8000b9c0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b9c4:	e4 03 01 03 	sub	r3,r2,r3
8000b9c8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b9cc:	fc 0b 01 0b 	sub	r11,lr,r11
8000b9d0:	f6 0a 00 0a 	add	r10,r11,r10
8000b9d4:	b0 1a       	st.h	r8[0x2],r10
8000b9d6:	b1 4a       	asr	r10,0x10
8000b9d8:	e6 0a 00 0a 	add	r10,r3,r10
8000b9dc:	b0 0a       	st.h	r8[0x0],r10
8000b9de:	2f c8       	sub	r8,-4
8000b9e0:	b1 4a       	asr	r10,0x10
8000b9e2:	08 36       	cp.w	r6,r4
8000b9e4:	ce 83       	brcs	8000b9b4 <__mdiff+0x64>
8000b9e6:	c0 d8       	rjmp	8000ba00 <__mdiff+0xb0>
8000b9e8:	0f 0b       	ld.w	r11,r7++
8000b9ea:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b9ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b9f2:	16 0a       	add	r10,r11
8000b9f4:	b0 1a       	st.h	r8[0x2],r10
8000b9f6:	b1 4a       	asr	r10,0x10
8000b9f8:	1c 0a       	add	r10,lr
8000b9fa:	b0 0a       	st.h	r8[0x0],r10
8000b9fc:	2f c8       	sub	r8,-4
8000b9fe:	b1 4a       	asr	r10,0x10
8000ba00:	0a 37       	cp.w	r7,r5
8000ba02:	cf 33       	brcs	8000b9e8 <__mdiff+0x98>
8000ba04:	c0 28       	rjmp	8000ba08 <__mdiff+0xb8>
8000ba06:	20 19       	sub	r9,1
8000ba08:	11 4a       	ld.w	r10,--r8
8000ba0a:	58 0a       	cp.w	r10,0
8000ba0c:	cf d0       	breq	8000ba06 <__mdiff+0xb6>
8000ba0e:	99 49       	st.w	r12[0x10],r9
8000ba10:	d8 32       	popm	r0-r7,pc
8000ba12:	30 0b       	mov	r11,0
8000ba14:	c1 6f       	rcall	8000b840 <_Balloc>
8000ba16:	30 18       	mov	r8,1
8000ba18:	99 48       	st.w	r12[0x10],r8
8000ba1a:	30 08       	mov	r8,0
8000ba1c:	99 58       	st.w	r12[0x14],r8
8000ba1e:	d8 32       	popm	r0-r7,pc

8000ba20 <__lshift>:
8000ba20:	d4 31       	pushm	r0-r7,lr
8000ba22:	16 97       	mov	r7,r11
8000ba24:	76 46       	ld.w	r6,r11[0x10]
8000ba26:	f4 02 14 05 	asr	r2,r10,0x5
8000ba2a:	2f f6       	sub	r6,-1
8000ba2c:	14 93       	mov	r3,r10
8000ba2e:	18 94       	mov	r4,r12
8000ba30:	04 06       	add	r6,r2
8000ba32:	76 1b       	ld.w	r11,r11[0x4]
8000ba34:	6e 28       	ld.w	r8,r7[0x8]
8000ba36:	c0 38       	rjmp	8000ba3c <__lshift+0x1c>
8000ba38:	2f fb       	sub	r11,-1
8000ba3a:	a1 78       	lsl	r8,0x1
8000ba3c:	10 36       	cp.w	r6,r8
8000ba3e:	fe 99 ff fd 	brgt	8000ba38 <__lshift+0x18>
8000ba42:	08 9c       	mov	r12,r4
8000ba44:	cf ee       	rcall	8000b840 <_Balloc>
8000ba46:	30 09       	mov	r9,0
8000ba48:	18 95       	mov	r5,r12
8000ba4a:	f8 c8 ff ec 	sub	r8,r12,-20
8000ba4e:	12 9a       	mov	r10,r9
8000ba50:	c0 38       	rjmp	8000ba56 <__lshift+0x36>
8000ba52:	10 aa       	st.w	r8++,r10
8000ba54:	2f f9       	sub	r9,-1
8000ba56:	04 39       	cp.w	r9,r2
8000ba58:	cf d5       	brlt	8000ba52 <__lshift+0x32>
8000ba5a:	6e 4b       	ld.w	r11,r7[0x10]
8000ba5c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ba60:	2f bb       	sub	r11,-5
8000ba62:	ee c9 ff ec 	sub	r9,r7,-20
8000ba66:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ba6a:	58 03       	cp.w	r3,0
8000ba6c:	c1 30       	breq	8000ba92 <__lshift+0x72>
8000ba6e:	e6 0c 11 20 	rsub	r12,r3,32
8000ba72:	30 0a       	mov	r10,0
8000ba74:	72 02       	ld.w	r2,r9[0x0]
8000ba76:	e4 03 09 42 	lsl	r2,r2,r3
8000ba7a:	04 4a       	or	r10,r2
8000ba7c:	10 aa       	st.w	r8++,r10
8000ba7e:	13 0a       	ld.w	r10,r9++
8000ba80:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba84:	16 39       	cp.w	r9,r11
8000ba86:	cf 73       	brcs	8000ba74 <__lshift+0x54>
8000ba88:	91 0a       	st.w	r8[0x0],r10
8000ba8a:	58 0a       	cp.w	r10,0
8000ba8c:	c0 70       	breq	8000ba9a <__lshift+0x7a>
8000ba8e:	2f f6       	sub	r6,-1
8000ba90:	c0 58       	rjmp	8000ba9a <__lshift+0x7a>
8000ba92:	13 0a       	ld.w	r10,r9++
8000ba94:	10 aa       	st.w	r8++,r10
8000ba96:	16 39       	cp.w	r9,r11
8000ba98:	cf d3       	brcs	8000ba92 <__lshift+0x72>
8000ba9a:	08 9c       	mov	r12,r4
8000ba9c:	20 16       	sub	r6,1
8000ba9e:	0e 9b       	mov	r11,r7
8000baa0:	8b 46       	st.w	r5[0x10],r6
8000baa2:	cb 5e       	rcall	8000b80c <_Bfree>
8000baa4:	0a 9c       	mov	r12,r5
8000baa6:	d8 32       	popm	r0-r7,pc

8000baa8 <__multiply>:
8000baa8:	d4 31       	pushm	r0-r7,lr
8000baaa:	20 2d       	sub	sp,8
8000baac:	76 49       	ld.w	r9,r11[0x10]
8000baae:	74 48       	ld.w	r8,r10[0x10]
8000bab0:	16 96       	mov	r6,r11
8000bab2:	14 95       	mov	r5,r10
8000bab4:	10 39       	cp.w	r9,r8
8000bab6:	ec 08 17 50 	movlt	r8,r6
8000baba:	ea 06 17 50 	movlt	r6,r5
8000babe:	f0 05 17 50 	movlt	r5,r8
8000bac2:	6c 28       	ld.w	r8,r6[0x8]
8000bac4:	76 43       	ld.w	r3,r11[0x10]
8000bac6:	74 42       	ld.w	r2,r10[0x10]
8000bac8:	76 1b       	ld.w	r11,r11[0x4]
8000baca:	e4 03 00 07 	add	r7,r2,r3
8000bace:	10 37       	cp.w	r7,r8
8000bad0:	f7 bb 09 ff 	subgt	r11,-1
8000bad4:	cb 6e       	rcall	8000b840 <_Balloc>
8000bad6:	ee c4 ff fb 	sub	r4,r7,-5
8000bada:	f8 c9 ff ec 	sub	r9,r12,-20
8000bade:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bae2:	30 0a       	mov	r10,0
8000bae4:	12 98       	mov	r8,r9
8000bae6:	c0 28       	rjmp	8000baea <__multiply+0x42>
8000bae8:	10 aa       	st.w	r8++,r10
8000baea:	08 38       	cp.w	r8,r4
8000baec:	cf e3       	brcs	8000bae8 <__multiply+0x40>
8000baee:	2f b3       	sub	r3,-5
8000baf0:	2f b2       	sub	r2,-5
8000baf2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000baf6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bafa:	ec cb ff ec 	sub	r11,r6,-20
8000bafe:	50 12       	stdsp	sp[0x4],r2
8000bb00:	ea ca ff ec 	sub	r10,r5,-20
8000bb04:	c4 48       	rjmp	8000bb8c <__multiply+0xe4>
8000bb06:	94 95       	ld.uh	r5,r10[0x2]
8000bb08:	58 05       	cp.w	r5,0
8000bb0a:	c2 00       	breq	8000bb4a <__multiply+0xa2>
8000bb0c:	12 98       	mov	r8,r9
8000bb0e:	16 96       	mov	r6,r11
8000bb10:	30 0e       	mov	lr,0
8000bb12:	50 09       	stdsp	sp[0x0],r9
8000bb14:	0d 02       	ld.w	r2,r6++
8000bb16:	e4 00 16 10 	lsr	r0,r2,0x10
8000bb1a:	70 01       	ld.w	r1,r8[0x0]
8000bb1c:	70 09       	ld.w	r9,r8[0x0]
8000bb1e:	b1 81       	lsr	r1,0x10
8000bb20:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bb24:	e0 05 03 41 	mac	r1,r0,r5
8000bb28:	ab 32       	mul	r2,r5
8000bb2a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bb2e:	00 02       	add	r2,r0
8000bb30:	e4 0e 00 0e 	add	lr,r2,lr
8000bb34:	b0 1e       	st.h	r8[0x2],lr
8000bb36:	b1 8e       	lsr	lr,0x10
8000bb38:	1c 01       	add	r1,lr
8000bb3a:	b0 01       	st.h	r8[0x0],r1
8000bb3c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bb40:	2f c8       	sub	r8,-4
8000bb42:	06 36       	cp.w	r6,r3
8000bb44:	ce 83       	brcs	8000bb14 <__multiply+0x6c>
8000bb46:	40 09       	lddsp	r9,sp[0x0]
8000bb48:	91 0e       	st.w	r8[0x0],lr
8000bb4a:	94 86       	ld.uh	r6,r10[0x0]
8000bb4c:	58 06       	cp.w	r6,0
8000bb4e:	c1 d0       	breq	8000bb88 <__multiply+0xe0>
8000bb50:	72 02       	ld.w	r2,r9[0x0]
8000bb52:	12 98       	mov	r8,r9
8000bb54:	16 9e       	mov	lr,r11
8000bb56:	30 05       	mov	r5,0
8000bb58:	b0 12       	st.h	r8[0x2],r2
8000bb5a:	1d 01       	ld.w	r1,lr++
8000bb5c:	90 82       	ld.uh	r2,r8[0x0]
8000bb5e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bb62:	ad 30       	mul	r0,r6
8000bb64:	e0 02 00 02 	add	r2,r0,r2
8000bb68:	e4 05 00 05 	add	r5,r2,r5
8000bb6c:	b0 05       	st.h	r8[0x0],r5
8000bb6e:	b1 85       	lsr	r5,0x10
8000bb70:	b1 81       	lsr	r1,0x10
8000bb72:	2f c8       	sub	r8,-4
8000bb74:	ad 31       	mul	r1,r6
8000bb76:	90 92       	ld.uh	r2,r8[0x2]
8000bb78:	e2 02 00 02 	add	r2,r1,r2
8000bb7c:	0a 02       	add	r2,r5
8000bb7e:	e4 05 16 10 	lsr	r5,r2,0x10
8000bb82:	06 3e       	cp.w	lr,r3
8000bb84:	ce a3       	brcs	8000bb58 <__multiply+0xb0>
8000bb86:	91 02       	st.w	r8[0x0],r2
8000bb88:	2f ca       	sub	r10,-4
8000bb8a:	2f c9       	sub	r9,-4
8000bb8c:	40 18       	lddsp	r8,sp[0x4]
8000bb8e:	10 3a       	cp.w	r10,r8
8000bb90:	cb b3       	brcs	8000bb06 <__multiply+0x5e>
8000bb92:	c0 28       	rjmp	8000bb96 <__multiply+0xee>
8000bb94:	20 17       	sub	r7,1
8000bb96:	58 07       	cp.w	r7,0
8000bb98:	e0 8a 00 05 	brle	8000bba2 <__multiply+0xfa>
8000bb9c:	09 48       	ld.w	r8,--r4
8000bb9e:	58 08       	cp.w	r8,0
8000bba0:	cf a0       	breq	8000bb94 <__multiply+0xec>
8000bba2:	99 47       	st.w	r12[0x10],r7
8000bba4:	2f ed       	sub	sp,-8
8000bba6:	d8 32       	popm	r0-r7,pc

8000bba8 <__i2b>:
8000bba8:	d4 21       	pushm	r4-r7,lr
8000bbaa:	16 97       	mov	r7,r11
8000bbac:	30 1b       	mov	r11,1
8000bbae:	c4 9e       	rcall	8000b840 <_Balloc>
8000bbb0:	30 19       	mov	r9,1
8000bbb2:	99 57       	st.w	r12[0x14],r7
8000bbb4:	99 49       	st.w	r12[0x10],r9
8000bbb6:	d8 22       	popm	r4-r7,pc

8000bbb8 <__multadd>:
8000bbb8:	d4 31       	pushm	r0-r7,lr
8000bbba:	30 08       	mov	r8,0
8000bbbc:	12 95       	mov	r5,r9
8000bbbe:	16 97       	mov	r7,r11
8000bbc0:	18 96       	mov	r6,r12
8000bbc2:	76 44       	ld.w	r4,r11[0x10]
8000bbc4:	f6 c9 ff ec 	sub	r9,r11,-20
8000bbc8:	72 0b       	ld.w	r11,r9[0x0]
8000bbca:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bbce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bbd2:	f4 0c 02 4c 	mul	r12,r10,r12
8000bbd6:	f4 0b 03 45 	mac	r5,r10,r11
8000bbda:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bbde:	b1 85       	lsr	r5,0x10
8000bbe0:	18 05       	add	r5,r12
8000bbe2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bbe6:	f8 0b 00 0b 	add	r11,r12,r11
8000bbea:	12 ab       	st.w	r9++,r11
8000bbec:	2f f8       	sub	r8,-1
8000bbee:	b1 85       	lsr	r5,0x10
8000bbf0:	08 38       	cp.w	r8,r4
8000bbf2:	ce b5       	brlt	8000bbc8 <__multadd+0x10>
8000bbf4:	58 05       	cp.w	r5,0
8000bbf6:	c1 c0       	breq	8000bc2e <__multadd+0x76>
8000bbf8:	6e 28       	ld.w	r8,r7[0x8]
8000bbfa:	10 34       	cp.w	r4,r8
8000bbfc:	c1 35       	brlt	8000bc22 <__multadd+0x6a>
8000bbfe:	6e 1b       	ld.w	r11,r7[0x4]
8000bc00:	0c 9c       	mov	r12,r6
8000bc02:	2f fb       	sub	r11,-1
8000bc04:	c1 ee       	rcall	8000b840 <_Balloc>
8000bc06:	6e 4a       	ld.w	r10,r7[0x10]
8000bc08:	ee cb ff f4 	sub	r11,r7,-12
8000bc0c:	18 93       	mov	r3,r12
8000bc0e:	2f ea       	sub	r10,-2
8000bc10:	2f 4c       	sub	r12,-12
8000bc12:	a3 6a       	lsl	r10,0x2
8000bc14:	fe b0 de 70 	rcall	800078f4 <memcpy>
8000bc18:	0e 9b       	mov	r11,r7
8000bc1a:	0c 9c       	mov	r12,r6
8000bc1c:	fe b0 fd f8 	rcall	8000b80c <_Bfree>
8000bc20:	06 97       	mov	r7,r3
8000bc22:	e8 c8 ff ff 	sub	r8,r4,-1
8000bc26:	2f b4       	sub	r4,-5
8000bc28:	8f 48       	st.w	r7[0x10],r8
8000bc2a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bc2e:	0e 9c       	mov	r12,r7
8000bc30:	d8 32       	popm	r0-r7,pc
8000bc32:	d7 03       	nop

8000bc34 <__pow5mult>:
8000bc34:	d4 31       	pushm	r0-r7,lr
8000bc36:	14 96       	mov	r6,r10
8000bc38:	18 97       	mov	r7,r12
8000bc3a:	16 94       	mov	r4,r11
8000bc3c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bc40:	c0 90       	breq	8000bc52 <__pow5mult+0x1e>
8000bc42:	20 18       	sub	r8,1
8000bc44:	fe c9 da 88 	sub	r9,pc,-9592
8000bc48:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bc4c:	30 09       	mov	r9,0
8000bc4e:	cb 5f       	rcall	8000bbb8 <__multadd>
8000bc50:	18 94       	mov	r4,r12
8000bc52:	a3 46       	asr	r6,0x2
8000bc54:	c3 40       	breq	8000bcbc <__pow5mult+0x88>
8000bc56:	6e 95       	ld.w	r5,r7[0x24]
8000bc58:	58 05       	cp.w	r5,0
8000bc5a:	c0 91       	brne	8000bc6c <__pow5mult+0x38>
8000bc5c:	31 0c       	mov	r12,16
8000bc5e:	fe b0 dc 27 	rcall	800074ac <malloc>
8000bc62:	99 35       	st.w	r12[0xc],r5
8000bc64:	8f 9c       	st.w	r7[0x24],r12
8000bc66:	99 15       	st.w	r12[0x4],r5
8000bc68:	99 25       	st.w	r12[0x8],r5
8000bc6a:	99 05       	st.w	r12[0x0],r5
8000bc6c:	6e 93       	ld.w	r3,r7[0x24]
8000bc6e:	66 25       	ld.w	r5,r3[0x8]
8000bc70:	58 05       	cp.w	r5,0
8000bc72:	c0 c1       	brne	8000bc8a <__pow5mult+0x56>
8000bc74:	e0 6b 02 71 	mov	r11,625
8000bc78:	0e 9c       	mov	r12,r7
8000bc7a:	c9 7f       	rcall	8000bba8 <__i2b>
8000bc7c:	87 2c       	st.w	r3[0x8],r12
8000bc7e:	30 08       	mov	r8,0
8000bc80:	18 95       	mov	r5,r12
8000bc82:	99 08       	st.w	r12[0x0],r8
8000bc84:	c0 38       	rjmp	8000bc8a <__pow5mult+0x56>
8000bc86:	06 9c       	mov	r12,r3
8000bc88:	18 95       	mov	r5,r12
8000bc8a:	ed b6 00 00 	bld	r6,0x0
8000bc8e:	c0 b1       	brne	8000bca4 <__pow5mult+0x70>
8000bc90:	08 9b       	mov	r11,r4
8000bc92:	0a 9a       	mov	r10,r5
8000bc94:	0e 9c       	mov	r12,r7
8000bc96:	c0 9f       	rcall	8000baa8 <__multiply>
8000bc98:	08 9b       	mov	r11,r4
8000bc9a:	18 93       	mov	r3,r12
8000bc9c:	0e 9c       	mov	r12,r7
8000bc9e:	06 94       	mov	r4,r3
8000bca0:	fe b0 fd b6 	rcall	8000b80c <_Bfree>
8000bca4:	a1 56       	asr	r6,0x1
8000bca6:	c0 b0       	breq	8000bcbc <__pow5mult+0x88>
8000bca8:	6a 03       	ld.w	r3,r5[0x0]
8000bcaa:	58 03       	cp.w	r3,0
8000bcac:	ce d1       	brne	8000bc86 <__pow5mult+0x52>
8000bcae:	0a 9a       	mov	r10,r5
8000bcb0:	0a 9b       	mov	r11,r5
8000bcb2:	0e 9c       	mov	r12,r7
8000bcb4:	cf ae       	rcall	8000baa8 <__multiply>
8000bcb6:	8b 0c       	st.w	r5[0x0],r12
8000bcb8:	99 03       	st.w	r12[0x0],r3
8000bcba:	ce 7b       	rjmp	8000bc88 <__pow5mult+0x54>
8000bcbc:	08 9c       	mov	r12,r4
8000bcbe:	d8 32       	popm	r0-r7,pc

8000bcc0 <__isinfd>:
8000bcc0:	14 98       	mov	r8,r10
8000bcc2:	fc 19 7f f0 	movh	r9,0x7ff0
8000bcc6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bcca:	f0 0b 11 00 	rsub	r11,r8,0
8000bcce:	f7 e8 10 08 	or	r8,r11,r8
8000bcd2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bcd6:	f2 08 01 08 	sub	r8,r9,r8
8000bcda:	f0 0c 11 00 	rsub	r12,r8,0
8000bcde:	f9 e8 10 08 	or	r8,r12,r8
8000bce2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bce6:	2f fc       	sub	r12,-1
8000bce8:	5e fc       	retal	r12

8000bcea <__isnand>:
8000bcea:	14 98       	mov	r8,r10
8000bcec:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bcf0:	f0 0c 11 00 	rsub	r12,r8,0
8000bcf4:	10 4c       	or	r12,r8
8000bcf6:	fc 18 7f f0 	movh	r8,0x7ff0
8000bcfa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bcfe:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd02:	bf 9c       	lsr	r12,0x1f
8000bd04:	5e fc       	retal	r12
8000bd06:	d7 03       	nop

8000bd08 <__sclose>:
8000bd08:	d4 01       	pushm	lr
8000bd0a:	96 7b       	ld.sh	r11,r11[0xe]
8000bd0c:	c8 2c       	rcall	8000be10 <_close_r>
8000bd0e:	d8 02       	popm	pc

8000bd10 <__sseek>:
8000bd10:	d4 21       	pushm	r4-r7,lr
8000bd12:	16 97       	mov	r7,r11
8000bd14:	96 7b       	ld.sh	r11,r11[0xe]
8000bd16:	c0 3d       	rcall	8000bf1c <_lseek_r>
8000bd18:	8e 68       	ld.sh	r8,r7[0xc]
8000bd1a:	10 99       	mov	r9,r8
8000bd1c:	ad c8       	cbr	r8,0xc
8000bd1e:	ad a9       	sbr	r9,0xc
8000bd20:	5b fc       	cp.w	r12,-1
8000bd22:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bd26:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bd2a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bd2e:	d8 22       	popm	r4-r7,pc

8000bd30 <__swrite>:
8000bd30:	d4 21       	pushm	r4-r7,lr
8000bd32:	96 68       	ld.sh	r8,r11[0xc]
8000bd34:	16 97       	mov	r7,r11
8000bd36:	14 95       	mov	r5,r10
8000bd38:	12 94       	mov	r4,r9
8000bd3a:	e2 18 01 00 	andl	r8,0x100,COH
8000bd3e:	18 96       	mov	r6,r12
8000bd40:	c0 50       	breq	8000bd4a <__swrite+0x1a>
8000bd42:	30 29       	mov	r9,2
8000bd44:	30 0a       	mov	r10,0
8000bd46:	96 7b       	ld.sh	r11,r11[0xe]
8000bd48:	ce ac       	rcall	8000bf1c <_lseek_r>
8000bd4a:	8e 68       	ld.sh	r8,r7[0xc]
8000bd4c:	ad c8       	cbr	r8,0xc
8000bd4e:	08 99       	mov	r9,r4
8000bd50:	0a 9a       	mov	r10,r5
8000bd52:	8e 7b       	ld.sh	r11,r7[0xe]
8000bd54:	0c 9c       	mov	r12,r6
8000bd56:	ae 68       	st.h	r7[0xc],r8
8000bd58:	c1 cc       	rcall	8000bd90 <_write_r>
8000bd5a:	d8 22       	popm	r4-r7,pc

8000bd5c <__sread>:
8000bd5c:	d4 21       	pushm	r4-r7,lr
8000bd5e:	16 97       	mov	r7,r11
8000bd60:	96 7b       	ld.sh	r11,r11[0xe]
8000bd62:	cf 1c       	rcall	8000bf44 <_read_r>
8000bd64:	c0 65       	brlt	8000bd70 <__sread+0x14>
8000bd66:	6f 58       	ld.w	r8,r7[0x54]
8000bd68:	18 08       	add	r8,r12
8000bd6a:	ef 48 00 54 	st.w	r7[84],r8
8000bd6e:	d8 22       	popm	r4-r7,pc
8000bd70:	8e 68       	ld.sh	r8,r7[0xc]
8000bd72:	ad c8       	cbr	r8,0xc
8000bd74:	ae 68       	st.h	r7[0xc],r8
8000bd76:	d8 22       	popm	r4-r7,pc

8000bd78 <strlen>:
8000bd78:	30 09       	mov	r9,0
8000bd7a:	18 98       	mov	r8,r12
8000bd7c:	c0 28       	rjmp	8000bd80 <strlen+0x8>
8000bd7e:	2f f8       	sub	r8,-1
8000bd80:	11 8a       	ld.ub	r10,r8[0x0]
8000bd82:	f2 0a 18 00 	cp.b	r10,r9
8000bd86:	cf c1       	brne	8000bd7e <strlen+0x6>
8000bd88:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd8c:	5e fc       	retal	r12
8000bd8e:	d7 03       	nop

8000bd90 <_write_r>:
8000bd90:	d4 21       	pushm	r4-r7,lr
8000bd92:	16 98       	mov	r8,r11
8000bd94:	18 97       	mov	r7,r12
8000bd96:	10 9c       	mov	r12,r8
8000bd98:	30 08       	mov	r8,0
8000bd9a:	14 9b       	mov	r11,r10
8000bd9c:	e0 66 53 d0 	mov	r6,21456
8000bda0:	12 9a       	mov	r10,r9
8000bda2:	8d 08       	st.w	r6[0x0],r8
8000bda4:	fe b0 d1 6e 	rcall	80006080 <_write>
8000bda8:	5b fc       	cp.w	r12,-1
8000bdaa:	c0 51       	brne	8000bdb4 <_write_r+0x24>
8000bdac:	6c 08       	ld.w	r8,r6[0x0]
8000bdae:	58 08       	cp.w	r8,0
8000bdb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdb4:	d8 22       	popm	r4-r7,pc
8000bdb6:	d7 03       	nop

8000bdb8 <_calloc_r>:
8000bdb8:	d4 21       	pushm	r4-r7,lr
8000bdba:	f4 0b 02 4b 	mul	r11,r10,r11
8000bdbe:	fe b0 db 7f 	rcall	800074bc <_malloc_r>
8000bdc2:	18 97       	mov	r7,r12
8000bdc4:	c2 30       	breq	8000be0a <_calloc_r+0x52>
8000bdc6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bdca:	e0 1a ff fc 	andl	r10,0xfffc
8000bdce:	20 4a       	sub	r10,4
8000bdd0:	e0 4a 00 24 	cp.w	r10,36
8000bdd4:	e0 8b 00 18 	brhi	8000be04 <_calloc_r+0x4c>
8000bdd8:	18 98       	mov	r8,r12
8000bdda:	59 3a       	cp.w	r10,19
8000bddc:	e0 88 00 0f 	brls	8000bdfa <_calloc_r+0x42>
8000bde0:	30 09       	mov	r9,0
8000bde2:	10 a9       	st.w	r8++,r9
8000bde4:	10 a9       	st.w	r8++,r9
8000bde6:	59 ba       	cp.w	r10,27
8000bde8:	e0 88 00 09 	brls	8000bdfa <_calloc_r+0x42>
8000bdec:	10 a9       	st.w	r8++,r9
8000bdee:	10 a9       	st.w	r8++,r9
8000bdf0:	e0 4a 00 24 	cp.w	r10,36
8000bdf4:	c0 31       	brne	8000bdfa <_calloc_r+0x42>
8000bdf6:	10 a9       	st.w	r8++,r9
8000bdf8:	10 a9       	st.w	r8++,r9
8000bdfa:	30 09       	mov	r9,0
8000bdfc:	10 a9       	st.w	r8++,r9
8000bdfe:	91 19       	st.w	r8[0x4],r9
8000be00:	91 09       	st.w	r8[0x0],r9
8000be02:	c0 48       	rjmp	8000be0a <_calloc_r+0x52>
8000be04:	30 0b       	mov	r11,0
8000be06:	fe b0 de 1b 	rcall	80007a3c <memset>
8000be0a:	0e 9c       	mov	r12,r7
8000be0c:	d8 22       	popm	r4-r7,pc
8000be0e:	d7 03       	nop

8000be10 <_close_r>:
8000be10:	d4 21       	pushm	r4-r7,lr
8000be12:	30 08       	mov	r8,0
8000be14:	18 97       	mov	r7,r12
8000be16:	e0 66 53 d0 	mov	r6,21456
8000be1a:	16 9c       	mov	r12,r11
8000be1c:	8d 08       	st.w	r6[0x0],r8
8000be1e:	fe b0 df b5 	rcall	80007d88 <_close>
8000be22:	5b fc       	cp.w	r12,-1
8000be24:	c0 51       	brne	8000be2e <_close_r+0x1e>
8000be26:	6c 08       	ld.w	r8,r6[0x0]
8000be28:	58 08       	cp.w	r8,0
8000be2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be2e:	d8 22       	popm	r4-r7,pc

8000be30 <_fclose_r>:
8000be30:	d4 21       	pushm	r4-r7,lr
8000be32:	18 96       	mov	r6,r12
8000be34:	16 97       	mov	r7,r11
8000be36:	58 0b       	cp.w	r11,0
8000be38:	c0 31       	brne	8000be3e <_fclose_r+0xe>
8000be3a:	16 95       	mov	r5,r11
8000be3c:	c5 38       	rjmp	8000bee2 <_fclose_r+0xb2>
8000be3e:	fe b0 f8 a9 	rcall	8000af90 <__sfp_lock_acquire>
8000be42:	58 06       	cp.w	r6,0
8000be44:	c0 70       	breq	8000be52 <_fclose_r+0x22>
8000be46:	6c 68       	ld.w	r8,r6[0x18]
8000be48:	58 08       	cp.w	r8,0
8000be4a:	c0 41       	brne	8000be52 <_fclose_r+0x22>
8000be4c:	0c 9c       	mov	r12,r6
8000be4e:	fe b0 f8 f3 	rcall	8000b034 <__sinit>
8000be52:	fe c8 dd 3a 	sub	r8,pc,-8902
8000be56:	10 37       	cp.w	r7,r8
8000be58:	c0 31       	brne	8000be5e <_fclose_r+0x2e>
8000be5a:	6c 07       	ld.w	r7,r6[0x0]
8000be5c:	c0 c8       	rjmp	8000be74 <_fclose_r+0x44>
8000be5e:	fe c8 dd 26 	sub	r8,pc,-8922
8000be62:	10 37       	cp.w	r7,r8
8000be64:	c0 31       	brne	8000be6a <_fclose_r+0x3a>
8000be66:	6c 17       	ld.w	r7,r6[0x4]
8000be68:	c0 68       	rjmp	8000be74 <_fclose_r+0x44>
8000be6a:	fe c8 dd 12 	sub	r8,pc,-8942
8000be6e:	10 37       	cp.w	r7,r8
8000be70:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be74:	8e 69       	ld.sh	r9,r7[0xc]
8000be76:	30 08       	mov	r8,0
8000be78:	f0 09 19 00 	cp.h	r9,r8
8000be7c:	c0 51       	brne	8000be86 <_fclose_r+0x56>
8000be7e:	fe b0 f8 8a 	rcall	8000af92 <__sfp_lock_release>
8000be82:	30 05       	mov	r5,0
8000be84:	c2 f8       	rjmp	8000bee2 <_fclose_r+0xb2>
8000be86:	0e 9b       	mov	r11,r7
8000be88:	0c 9c       	mov	r12,r6
8000be8a:	fe b0 f7 fd 	rcall	8000ae84 <_fflush_r>
8000be8e:	6e c8       	ld.w	r8,r7[0x30]
8000be90:	18 95       	mov	r5,r12
8000be92:	58 08       	cp.w	r8,0
8000be94:	c0 60       	breq	8000bea0 <_fclose_r+0x70>
8000be96:	6e 8b       	ld.w	r11,r7[0x20]
8000be98:	0c 9c       	mov	r12,r6
8000be9a:	5d 18       	icall	r8
8000be9c:	f9 b5 05 ff 	movlt	r5,-1
8000bea0:	8e 68       	ld.sh	r8,r7[0xc]
8000bea2:	ed b8 00 07 	bld	r8,0x7
8000bea6:	c0 51       	brne	8000beb0 <_fclose_r+0x80>
8000bea8:	6e 4b       	ld.w	r11,r7[0x10]
8000beaa:	0c 9c       	mov	r12,r6
8000beac:	fe b0 f9 5e 	rcall	8000b168 <_free_r>
8000beb0:	6e db       	ld.w	r11,r7[0x34]
8000beb2:	58 0b       	cp.w	r11,0
8000beb4:	c0 a0       	breq	8000bec8 <_fclose_r+0x98>
8000beb6:	ee c8 ff bc 	sub	r8,r7,-68
8000beba:	10 3b       	cp.w	r11,r8
8000bebc:	c0 40       	breq	8000bec4 <_fclose_r+0x94>
8000bebe:	0c 9c       	mov	r12,r6
8000bec0:	fe b0 f9 54 	rcall	8000b168 <_free_r>
8000bec4:	30 08       	mov	r8,0
8000bec6:	8f d8       	st.w	r7[0x34],r8
8000bec8:	6f 2b       	ld.w	r11,r7[0x48]
8000beca:	58 0b       	cp.w	r11,0
8000becc:	c0 70       	breq	8000beda <_fclose_r+0xaa>
8000bece:	0c 9c       	mov	r12,r6
8000bed0:	fe b0 f9 4c 	rcall	8000b168 <_free_r>
8000bed4:	30 08       	mov	r8,0
8000bed6:	ef 48 00 48 	st.w	r7[72],r8
8000beda:	30 08       	mov	r8,0
8000bedc:	ae 68       	st.h	r7[0xc],r8
8000bede:	fe b0 f8 5a 	rcall	8000af92 <__sfp_lock_release>
8000bee2:	0a 9c       	mov	r12,r5
8000bee4:	d8 22       	popm	r4-r7,pc
8000bee6:	d7 03       	nop

8000bee8 <fclose>:
8000bee8:	d4 01       	pushm	lr
8000beea:	e0 68 0a 40 	mov	r8,2624
8000beee:	18 9b       	mov	r11,r12
8000bef0:	70 0c       	ld.w	r12,r8[0x0]
8000bef2:	c9 ff       	rcall	8000be30 <_fclose_r>
8000bef4:	d8 02       	popm	pc
8000bef6:	d7 03       	nop

8000bef8 <_fstat_r>:
8000bef8:	d4 21       	pushm	r4-r7,lr
8000befa:	16 98       	mov	r8,r11
8000befc:	18 97       	mov	r7,r12
8000befe:	10 9c       	mov	r12,r8
8000bf00:	30 08       	mov	r8,0
8000bf02:	e0 66 53 d0 	mov	r6,21456
8000bf06:	14 9b       	mov	r11,r10
8000bf08:	8d 08       	st.w	r6[0x0],r8
8000bf0a:	fe b0 df 67 	rcall	80007dd8 <_fstat>
8000bf0e:	5b fc       	cp.w	r12,-1
8000bf10:	c0 51       	brne	8000bf1a <_fstat_r+0x22>
8000bf12:	6c 08       	ld.w	r8,r6[0x0]
8000bf14:	58 08       	cp.w	r8,0
8000bf16:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf1a:	d8 22       	popm	r4-r7,pc

8000bf1c <_lseek_r>:
8000bf1c:	d4 21       	pushm	r4-r7,lr
8000bf1e:	16 98       	mov	r8,r11
8000bf20:	18 97       	mov	r7,r12
8000bf22:	10 9c       	mov	r12,r8
8000bf24:	30 08       	mov	r8,0
8000bf26:	14 9b       	mov	r11,r10
8000bf28:	e0 66 53 d0 	mov	r6,21456
8000bf2c:	12 9a       	mov	r10,r9
8000bf2e:	8d 08       	st.w	r6[0x0],r8
8000bf30:	fe b0 df 36 	rcall	80007d9c <_lseek>
8000bf34:	5b fc       	cp.w	r12,-1
8000bf36:	c0 51       	brne	8000bf40 <_lseek_r+0x24>
8000bf38:	6c 08       	ld.w	r8,r6[0x0]
8000bf3a:	58 08       	cp.w	r8,0
8000bf3c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf40:	d8 22       	popm	r4-r7,pc
8000bf42:	d7 03       	nop

8000bf44 <_read_r>:
8000bf44:	d4 21       	pushm	r4-r7,lr
8000bf46:	16 98       	mov	r8,r11
8000bf48:	18 97       	mov	r7,r12
8000bf4a:	10 9c       	mov	r12,r8
8000bf4c:	30 08       	mov	r8,0
8000bf4e:	14 9b       	mov	r11,r10
8000bf50:	e0 66 53 d0 	mov	r6,21456
8000bf54:	12 9a       	mov	r10,r9
8000bf56:	8d 08       	st.w	r6[0x0],r8
8000bf58:	fe b0 d0 74 	rcall	80006040 <_read>
8000bf5c:	5b fc       	cp.w	r12,-1
8000bf5e:	c0 51       	brne	8000bf68 <_read_r+0x24>
8000bf60:	6c 08       	ld.w	r8,r6[0x0]
8000bf62:	58 08       	cp.w	r8,0
8000bf64:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf68:	d8 22       	popm	r4-r7,pc
8000bf6a:	d7 03       	nop

8000bf6c <__avr32_f64_mul>:
8000bf6c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bf70:	e0 80 00 dc 	breq	8000c128 <__avr32_f64_mul_op1_zero>
8000bf74:	d4 21       	pushm	r4-r7,lr
8000bf76:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf7a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bf7e:	30 15       	mov	r5,1
8000bf80:	c4 30       	breq	8000c006 <__avr32_f64_mul_op1_subnormal>
8000bf82:	ab 6b       	lsl	r11,0xa
8000bf84:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bf88:	ab 6a       	lsl	r10,0xa
8000bf8a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf8e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf92:	c5 c0       	breq	8000c04a <__avr32_f64_mul_op2_subnormal>
8000bf94:	a1 78       	lsl	r8,0x1
8000bf96:	5c f9       	rol	r9
8000bf98:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf9c:	e0 47 07 ff 	cp.w	r7,2047
8000bfa0:	c7 70       	breq	8000c08e <__avr32_f64_mul_op_nan_or_inf>
8000bfa2:	e0 46 07 ff 	cp.w	r6,2047
8000bfa6:	c7 40       	breq	8000c08e <__avr32_f64_mul_op_nan_or_inf>
8000bfa8:	ee 06 00 0c 	add	r12,r7,r6
8000bfac:	e0 2c 03 fe 	sub	r12,1022
8000bfb0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bfb4:	f4 09 07 44 	macu.d	r4,r10,r9
8000bfb8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bfbc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bfc0:	08 07       	add	r7,r4
8000bfc2:	f4 05 00 4a 	adc	r10,r10,r5
8000bfc6:	5c 0b       	acr	r11
8000bfc8:	ed bb 00 14 	bld	r11,0x14
8000bfcc:	c0 50       	breq	8000bfd6 <__avr32_f64_mul+0x6a>
8000bfce:	a1 77       	lsl	r7,0x1
8000bfd0:	5c fa       	rol	r10
8000bfd2:	5c fb       	rol	r11
8000bfd4:	20 1c       	sub	r12,1
8000bfd6:	58 0c       	cp.w	r12,0
8000bfd8:	e0 8a 00 6f 	brle	8000c0b6 <__avr32_f64_mul_res_subnormal>
8000bfdc:	e0 4c 07 ff 	cp.w	r12,2047
8000bfe0:	e0 84 00 9c 	brge	8000c118 <__avr32_f64_mul_res_inf>
8000bfe4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bfe8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bfec:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bff0:	ee 17 80 00 	eorh	r7,0x8000
8000bff4:	f1 b7 04 20 	satu	r7,0x1
8000bff8:	0e 0a       	add	r10,r7
8000bffa:	5c 0b       	acr	r11
8000bffc:	ed be 00 1f 	bld	lr,0x1f
8000c000:	ef bb 00 1f 	bst	r11,0x1f
8000c004:	d8 22       	popm	r4-r7,pc

8000c006 <__avr32_f64_mul_op1_subnormal>:
8000c006:	e4 1b 00 0f 	andh	r11,0xf
8000c00a:	f4 0c 12 00 	clz	r12,r10
8000c00e:	f6 06 12 00 	clz	r6,r11
8000c012:	f7 bc 03 e1 	sublo	r12,-31
8000c016:	f8 06 17 30 	movlo	r6,r12
8000c01a:	f7 b6 02 01 	subhs	r6,1
8000c01e:	e0 46 00 20 	cp.w	r6,32
8000c022:	c0 d4       	brge	8000c03c <__avr32_f64_mul_op1_subnormal+0x36>
8000c024:	ec 0c 11 20 	rsub	r12,r6,32
8000c028:	f6 06 09 4b 	lsl	r11,r11,r6
8000c02c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c030:	18 4b       	or	r11,r12
8000c032:	f4 06 09 4a 	lsl	r10,r10,r6
8000c036:	20 b6       	sub	r6,11
8000c038:	0c 17       	sub	r7,r6
8000c03a:	ca ab       	rjmp	8000bf8e <__avr32_f64_mul+0x22>
8000c03c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c040:	c6 40       	breq	8000c108 <__avr32_f64_mul_res_zero>
8000c042:	30 0a       	mov	r10,0
8000c044:	20 b6       	sub	r6,11
8000c046:	0c 17       	sub	r7,r6
8000c048:	ca 3b       	rjmp	8000bf8e <__avr32_f64_mul+0x22>

8000c04a <__avr32_f64_mul_op2_subnormal>:
8000c04a:	e4 19 00 0f 	andh	r9,0xf
8000c04e:	f0 0c 12 00 	clz	r12,r8
8000c052:	f2 05 12 00 	clz	r5,r9
8000c056:	f7 bc 03 ea 	sublo	r12,-22
8000c05a:	f8 05 17 30 	movlo	r5,r12
8000c05e:	f7 b5 02 0a 	subhs	r5,10
8000c062:	e0 45 00 20 	cp.w	r5,32
8000c066:	c0 d4       	brge	8000c080 <__avr32_f64_mul_op2_subnormal+0x36>
8000c068:	ea 0c 11 20 	rsub	r12,r5,32
8000c06c:	f2 05 09 49 	lsl	r9,r9,r5
8000c070:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c074:	18 49       	or	r9,r12
8000c076:	f0 05 09 48 	lsl	r8,r8,r5
8000c07a:	20 25       	sub	r5,2
8000c07c:	0a 16       	sub	r6,r5
8000c07e:	c8 fb       	rjmp	8000bf9c <__avr32_f64_mul+0x30>
8000c080:	f0 05 09 49 	lsl	r9,r8,r5
8000c084:	c4 20       	breq	8000c108 <__avr32_f64_mul_res_zero>
8000c086:	30 08       	mov	r8,0
8000c088:	20 25       	sub	r5,2
8000c08a:	0a 16       	sub	r6,r5
8000c08c:	c8 8b       	rjmp	8000bf9c <__avr32_f64_mul+0x30>

8000c08e <__avr32_f64_mul_op_nan_or_inf>:
8000c08e:	e4 19 00 0f 	andh	r9,0xf
8000c092:	e4 1b 00 0f 	andh	r11,0xf
8000c096:	14 4b       	or	r11,r10
8000c098:	10 49       	or	r9,r8
8000c09a:	e0 47 07 ff 	cp.w	r7,2047
8000c09e:	c0 91       	brne	8000c0b0 <__avr32_f64_mul_op1_not_naninf>
8000c0a0:	58 0b       	cp.w	r11,0
8000c0a2:	c3 81       	brne	8000c112 <__avr32_f64_mul_res_nan>
8000c0a4:	e0 46 07 ff 	cp.w	r6,2047
8000c0a8:	c3 81       	brne	8000c118 <__avr32_f64_mul_res_inf>
8000c0aa:	58 09       	cp.w	r9,0
8000c0ac:	c3 60       	breq	8000c118 <__avr32_f64_mul_res_inf>
8000c0ae:	c3 28       	rjmp	8000c112 <__avr32_f64_mul_res_nan>

8000c0b0 <__avr32_f64_mul_op1_not_naninf>:
8000c0b0:	58 09       	cp.w	r9,0
8000c0b2:	c3 30       	breq	8000c118 <__avr32_f64_mul_res_inf>
8000c0b4:	c2 f8       	rjmp	8000c112 <__avr32_f64_mul_res_nan>

8000c0b6 <__avr32_f64_mul_res_subnormal>:
8000c0b6:	5c 3c       	neg	r12
8000c0b8:	2f fc       	sub	r12,-1
8000c0ba:	f1 bc 04 c0 	satu	r12,0x6
8000c0be:	e0 4c 00 20 	cp.w	r12,32
8000c0c2:	c1 14       	brge	8000c0e4 <__avr32_f64_mul_res_subnormal+0x2e>
8000c0c4:	f8 08 11 20 	rsub	r8,r12,32
8000c0c8:	0e 46       	or	r6,r7
8000c0ca:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c0ce:	f4 08 09 49 	lsl	r9,r10,r8
8000c0d2:	12 47       	or	r7,r9
8000c0d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0d8:	f6 08 09 49 	lsl	r9,r11,r8
8000c0dc:	12 4a       	or	r10,r9
8000c0de:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0e2:	c8 3b       	rjmp	8000bfe8 <__avr32_f64_mul+0x7c>
8000c0e4:	f8 08 11 20 	rsub	r8,r12,32
8000c0e8:	f9 b9 00 00 	moveq	r9,0
8000c0ec:	c0 30       	breq	8000c0f2 <__avr32_f64_mul_res_subnormal+0x3c>
8000c0ee:	f6 08 09 49 	lsl	r9,r11,r8
8000c0f2:	0e 46       	or	r6,r7
8000c0f4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c0f8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0fc:	f3 ea 10 07 	or	r7,r9,r10
8000c100:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c104:	30 0b       	mov	r11,0
8000c106:	c7 1b       	rjmp	8000bfe8 <__avr32_f64_mul+0x7c>

8000c108 <__avr32_f64_mul_res_zero>:
8000c108:	1c 9b       	mov	r11,lr
8000c10a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c10e:	30 0a       	mov	r10,0
8000c110:	d8 22       	popm	r4-r7,pc

8000c112 <__avr32_f64_mul_res_nan>:
8000c112:	3f fb       	mov	r11,-1
8000c114:	3f fa       	mov	r10,-1
8000c116:	d8 22       	popm	r4-r7,pc

8000c118 <__avr32_f64_mul_res_inf>:
8000c118:	f0 6b 00 00 	mov	r11,-1048576
8000c11c:	ed be 00 1f 	bld	lr,0x1f
8000c120:	ef bb 00 1f 	bst	r11,0x1f
8000c124:	30 0a       	mov	r10,0
8000c126:	d8 22       	popm	r4-r7,pc

8000c128 <__avr32_f64_mul_op1_zero>:
8000c128:	f7 e9 20 0b 	eor	r11,r11,r9
8000c12c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c130:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c134:	e0 4c 07 ff 	cp.w	r12,2047
8000c138:	5e 1c       	retne	r12
8000c13a:	3f fa       	mov	r10,-1
8000c13c:	3f fb       	mov	r11,-1
8000c13e:	5e fc       	retal	r12

8000c140 <__avr32_f64_sub_from_add>:
8000c140:	ee 19 80 00 	eorh	r9,0x8000

8000c144 <__avr32_f64_sub>:
8000c144:	f7 e9 20 0c 	eor	r12,r11,r9
8000c148:	e0 86 00 ca 	brmi	8000c2dc <__avr32_f64_add_from_sub>
8000c14c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c150:	16 9c       	mov	r12,r11
8000c152:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c156:	bf db       	cbr	r11,0x1f
8000c158:	bf d9       	cbr	r9,0x1f
8000c15a:	10 3a       	cp.w	r10,r8
8000c15c:	f2 0b 13 00 	cpc	r11,r9
8000c160:	c0 92       	brcc	8000c172 <__avr32_f64_sub+0x2e>
8000c162:	16 97       	mov	r7,r11
8000c164:	12 9b       	mov	r11,r9
8000c166:	0e 99       	mov	r9,r7
8000c168:	14 97       	mov	r7,r10
8000c16a:	10 9a       	mov	r10,r8
8000c16c:	0e 98       	mov	r8,r7
8000c16e:	ee 1c 80 00 	eorh	r12,0x8000
8000c172:	f6 07 16 14 	lsr	r7,r11,0x14
8000c176:	ab 7b       	lsl	r11,0xb
8000c178:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c17c:	ab 7a       	lsl	r10,0xb
8000c17e:	bf bb       	sbr	r11,0x1f
8000c180:	f2 06 16 14 	lsr	r6,r9,0x14
8000c184:	c4 40       	breq	8000c20c <__avr32_f64_sub_opL_subnormal>
8000c186:	ab 79       	lsl	r9,0xb
8000c188:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c18c:	ab 78       	lsl	r8,0xb
8000c18e:	bf b9       	sbr	r9,0x1f

8000c190 <__avr32_f64_sub_opL_subnormal_done>:
8000c190:	e0 47 07 ff 	cp.w	r7,2047
8000c194:	c4 f0       	breq	8000c232 <__avr32_f64_sub_opH_nan_or_inf>
8000c196:	0e 26       	rsub	r6,r7
8000c198:	c1 20       	breq	8000c1bc <__avr32_f64_sub_shift_done>
8000c19a:	ec 05 11 20 	rsub	r5,r6,32
8000c19e:	e0 46 00 20 	cp.w	r6,32
8000c1a2:	c7 c2       	brcc	8000c29a <__avr32_f64_sub_longshift>
8000c1a4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c1a8:	f2 05 09 45 	lsl	r5,r9,r5
8000c1ac:	f0 06 0a 48 	lsr	r8,r8,r6
8000c1b0:	f2 06 0a 49 	lsr	r9,r9,r6
8000c1b4:	0a 48       	or	r8,r5
8000c1b6:	58 0e       	cp.w	lr,0
8000c1b8:	5f 1e       	srne	lr
8000c1ba:	1c 48       	or	r8,lr

8000c1bc <__avr32_f64_sub_shift_done>:
8000c1bc:	10 1a       	sub	r10,r8
8000c1be:	f6 09 01 4b 	sbc	r11,r11,r9
8000c1c2:	f6 06 12 00 	clz	r6,r11
8000c1c6:	c0 e0       	breq	8000c1e2 <__avr32_f64_sub_longnormalize_done>
8000c1c8:	c7 83       	brcs	8000c2b8 <__avr32_f64_sub_longnormalize>
8000c1ca:	ec 0e 11 20 	rsub	lr,r6,32
8000c1ce:	f6 06 09 4b 	lsl	r11,r11,r6
8000c1d2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1d6:	1c 4b       	or	r11,lr
8000c1d8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c1dc:	0c 17       	sub	r7,r6
8000c1de:	e0 8a 00 39 	brle	8000c250 <__avr32_f64_sub_subnormal_result>

8000c1e2 <__avr32_f64_sub_longnormalize_done>:
8000c1e2:	f4 09 15 15 	lsl	r9,r10,0x15
8000c1e6:	ab 9a       	lsr	r10,0xb
8000c1e8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c1ec:	ab 9b       	lsr	r11,0xb
8000c1ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c1f2:	18 4b       	or	r11,r12

8000c1f4 <__avr32_f64_sub_round>:
8000c1f4:	fc 17 80 00 	movh	r7,0x8000
8000c1f8:	ed ba 00 00 	bld	r10,0x0
8000c1fc:	f7 b7 01 ff 	subne	r7,-1
8000c200:	0e 39       	cp.w	r9,r7
8000c202:	5f 29       	srhs	r9
8000c204:	12 0a       	add	r10,r9
8000c206:	5c 0b       	acr	r11
8000c208:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c20c <__avr32_f64_sub_opL_subnormal>:
8000c20c:	ab 79       	lsl	r9,0xb
8000c20e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c212:	ab 78       	lsl	r8,0xb
8000c214:	f3 e8 10 0e 	or	lr,r9,r8
8000c218:	f9 b6 01 01 	movne	r6,1
8000c21c:	ee 0e 11 00 	rsub	lr,r7,0
8000c220:	f9 b7 00 01 	moveq	r7,1
8000c224:	ef bb 00 1f 	bst	r11,0x1f
8000c228:	f7 ea 10 0e 	or	lr,r11,r10
8000c22c:	f9 b7 00 00 	moveq	r7,0
8000c230:	cb 0b       	rjmp	8000c190 <__avr32_f64_sub_opL_subnormal_done>

8000c232 <__avr32_f64_sub_opH_nan_or_inf>:
8000c232:	bf db       	cbr	r11,0x1f
8000c234:	f7 ea 10 0e 	or	lr,r11,r10
8000c238:	c0 81       	brne	8000c248 <__avr32_f64_sub_return_nan>
8000c23a:	e0 46 07 ff 	cp.w	r6,2047
8000c23e:	c0 50       	breq	8000c248 <__avr32_f64_sub_return_nan>
8000c240:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c248 <__avr32_f64_sub_return_nan>:
8000c248:	3f fa       	mov	r10,-1
8000c24a:	3f fb       	mov	r11,-1
8000c24c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c250 <__avr32_f64_sub_subnormal_result>:
8000c250:	5c 37       	neg	r7
8000c252:	2f f7       	sub	r7,-1
8000c254:	f1 b7 04 c0 	satu	r7,0x6
8000c258:	e0 47 00 20 	cp.w	r7,32
8000c25c:	c1 14       	brge	8000c27e <__avr32_f64_sub_subnormal_result+0x2e>
8000c25e:	ee 08 11 20 	rsub	r8,r7,32
8000c262:	f4 08 09 49 	lsl	r9,r10,r8
8000c266:	5f 16       	srne	r6
8000c268:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c26c:	0c 4a       	or	r10,r6
8000c26e:	f6 08 09 49 	lsl	r9,r11,r8
8000c272:	f5 e9 10 0a 	or	r10,r10,r9
8000c276:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c27a:	30 07       	mov	r7,0
8000c27c:	cb 3b       	rjmp	8000c1e2 <__avr32_f64_sub_longnormalize_done>
8000c27e:	ee 08 11 40 	rsub	r8,r7,64
8000c282:	f6 08 09 49 	lsl	r9,r11,r8
8000c286:	14 49       	or	r9,r10
8000c288:	5f 16       	srne	r6
8000c28a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c28e:	0c 4a       	or	r10,r6
8000c290:	30 0b       	mov	r11,0
8000c292:	30 07       	mov	r7,0
8000c294:	ca 7b       	rjmp	8000c1e2 <__avr32_f64_sub_longnormalize_done>
8000c296:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c29a <__avr32_f64_sub_longshift>:
8000c29a:	f1 b6 04 c0 	satu	r6,0x6
8000c29e:	f0 0e 17 00 	moveq	lr,r8
8000c2a2:	c0 40       	breq	8000c2aa <__avr32_f64_sub_longshift+0x10>
8000c2a4:	f2 05 09 4e 	lsl	lr,r9,r5
8000c2a8:	10 4e       	or	lr,r8
8000c2aa:	f2 06 0a 48 	lsr	r8,r9,r6
8000c2ae:	30 09       	mov	r9,0
8000c2b0:	58 0e       	cp.w	lr,0
8000c2b2:	5f 1e       	srne	lr
8000c2b4:	1c 48       	or	r8,lr
8000c2b6:	c8 3b       	rjmp	8000c1bc <__avr32_f64_sub_shift_done>

8000c2b8 <__avr32_f64_sub_longnormalize>:
8000c2b8:	f4 06 12 00 	clz	r6,r10
8000c2bc:	f9 b7 03 00 	movlo	r7,0
8000c2c0:	f9 b6 03 00 	movlo	r6,0
8000c2c4:	f9 bc 03 00 	movlo	r12,0
8000c2c8:	f7 b6 02 e0 	subhs	r6,-32
8000c2cc:	f4 06 09 4b 	lsl	r11,r10,r6
8000c2d0:	30 0a       	mov	r10,0
8000c2d2:	0c 17       	sub	r7,r6
8000c2d4:	fe 9a ff be 	brle	8000c250 <__avr32_f64_sub_subnormal_result>
8000c2d8:	c8 5b       	rjmp	8000c1e2 <__avr32_f64_sub_longnormalize_done>
8000c2da:	d7 03       	nop

8000c2dc <__avr32_f64_add_from_sub>:
8000c2dc:	ee 19 80 00 	eorh	r9,0x8000

8000c2e0 <__avr32_f64_add>:
8000c2e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000c2e4:	fe 96 ff 2e 	brmi	8000c140 <__avr32_f64_sub_from_add>
8000c2e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000c2ec:	16 9c       	mov	r12,r11
8000c2ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c2f2:	bf db       	cbr	r11,0x1f
8000c2f4:	bf d9       	cbr	r9,0x1f
8000c2f6:	12 3b       	cp.w	r11,r9
8000c2f8:	c0 72       	brcc	8000c306 <__avr32_f64_add+0x26>
8000c2fa:	16 97       	mov	r7,r11
8000c2fc:	12 9b       	mov	r11,r9
8000c2fe:	0e 99       	mov	r9,r7
8000c300:	14 97       	mov	r7,r10
8000c302:	10 9a       	mov	r10,r8
8000c304:	0e 98       	mov	r8,r7
8000c306:	30 0e       	mov	lr,0
8000c308:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c30c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c310:	b5 ab       	sbr	r11,0x14
8000c312:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c316:	c6 20       	breq	8000c3da <__avr32_f64_add_op2_subnormal>
8000c318:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c31c:	b5 a9       	sbr	r9,0x14
8000c31e:	e0 47 07 ff 	cp.w	r7,2047
8000c322:	c2 80       	breq	8000c372 <__avr32_f64_add_opH_nan_or_inf>
8000c324:	0e 26       	rsub	r6,r7
8000c326:	c1 20       	breq	8000c34a <__avr32_f64_add_shift_done>
8000c328:	e0 46 00 36 	cp.w	r6,54
8000c32c:	c1 52       	brcc	8000c356 <__avr32_f64_add_res_of_done>
8000c32e:	ec 05 11 20 	rsub	r5,r6,32
8000c332:	e0 46 00 20 	cp.w	r6,32
8000c336:	c3 52       	brcc	8000c3a0 <__avr32_f64_add_longshift>
8000c338:	f0 05 09 4e 	lsl	lr,r8,r5
8000c33c:	f2 05 09 45 	lsl	r5,r9,r5
8000c340:	f0 06 0a 48 	lsr	r8,r8,r6
8000c344:	f2 06 0a 49 	lsr	r9,r9,r6
8000c348:	0a 48       	or	r8,r5

8000c34a <__avr32_f64_add_shift_done>:
8000c34a:	10 0a       	add	r10,r8
8000c34c:	f6 09 00 4b 	adc	r11,r11,r9
8000c350:	ed bb 00 15 	bld	r11,0x15
8000c354:	c3 40       	breq	8000c3bc <__avr32_f64_add_res_of>

8000c356 <__avr32_f64_add_res_of_done>:
8000c356:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c35a:	18 4b       	or	r11,r12

8000c35c <__avr32_f64_add_round>:
8000c35c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c360:	18 4e       	or	lr,r12
8000c362:	ee 1e 80 00 	eorh	lr,0x8000
8000c366:	f1 be 04 20 	satu	lr,0x1
8000c36a:	1c 0a       	add	r10,lr
8000c36c:	5c 0b       	acr	r11
8000c36e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c372 <__avr32_f64_add_opH_nan_or_inf>:
8000c372:	b5 cb       	cbr	r11,0x14
8000c374:	f7 ea 10 0e 	or	lr,r11,r10
8000c378:	c1 01       	brne	8000c398 <__avr32_f64_add_return_nan>
8000c37a:	e0 46 07 ff 	cp.w	r6,2047
8000c37e:	c0 30       	breq	8000c384 <__avr32_f64_add_opL_nan_or_inf>
8000c380:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c384 <__avr32_f64_add_opL_nan_or_inf>:
8000c384:	b5 c9       	cbr	r9,0x14
8000c386:	f3 e8 10 0e 	or	lr,r9,r8
8000c38a:	c0 71       	brne	8000c398 <__avr32_f64_add_return_nan>
8000c38c:	30 0a       	mov	r10,0
8000c38e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c392:	18 4b       	or	r11,r12
8000c394:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c398 <__avr32_f64_add_return_nan>:
8000c398:	3f fa       	mov	r10,-1
8000c39a:	3f fb       	mov	r11,-1
8000c39c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c3a0 <__avr32_f64_add_longshift>:
8000c3a0:	f1 b6 04 c0 	satu	r6,0x6
8000c3a4:	f0 0e 17 00 	moveq	lr,r8
8000c3a8:	c0 60       	breq	8000c3b4 <__avr32_f64_add_longshift+0x14>
8000c3aa:	f2 05 09 4e 	lsl	lr,r9,r5
8000c3ae:	58 08       	cp.w	r8,0
8000c3b0:	5f 18       	srne	r8
8000c3b2:	10 4e       	or	lr,r8
8000c3b4:	f2 06 0a 48 	lsr	r8,r9,r6
8000c3b8:	30 09       	mov	r9,0
8000c3ba:	cc 8b       	rjmp	8000c34a <__avr32_f64_add_shift_done>

8000c3bc <__avr32_f64_add_res_of>:
8000c3bc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c3c0:	a1 9b       	lsr	r11,0x1
8000c3c2:	5d 0a       	ror	r10
8000c3c4:	5d 0e       	ror	lr
8000c3c6:	2f f7       	sub	r7,-1
8000c3c8:	e0 47 07 ff 	cp.w	r7,2047
8000c3cc:	f9 ba 00 00 	moveq	r10,0
8000c3d0:	f9 bb 00 00 	moveq	r11,0
8000c3d4:	f9 be 00 00 	moveq	lr,0
8000c3d8:	cb fb       	rjmp	8000c356 <__avr32_f64_add_res_of_done>

8000c3da <__avr32_f64_add_op2_subnormal>:
8000c3da:	30 16       	mov	r6,1
8000c3dc:	58 07       	cp.w	r7,0
8000c3de:	ca 01       	brne	8000c31e <__avr32_f64_add+0x3e>
8000c3e0:	b5 cb       	cbr	r11,0x14
8000c3e2:	10 0a       	add	r10,r8
8000c3e4:	f6 09 00 4b 	adc	r11,r11,r9
8000c3e8:	18 4b       	or	r11,r12
8000c3ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c3ee:	d7 03       	nop

8000c3f0 <__avr32_f64_to_u32>:
8000c3f0:	58 0b       	cp.w	r11,0
8000c3f2:	5e 6d       	retmi	0

8000c3f4 <__avr32_f64_to_s32>:
8000c3f4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c3f8:	b5 9c       	lsr	r12,0x15
8000c3fa:	e0 2c 03 ff 	sub	r12,1023
8000c3fe:	5e 3d       	retlo	0
8000c400:	f8 0c 11 1f 	rsub	r12,r12,31
8000c404:	16 99       	mov	r9,r11
8000c406:	ab 7b       	lsl	r11,0xb
8000c408:	bf bb       	sbr	r11,0x1f
8000c40a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c40e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c412:	a1 79       	lsl	r9,0x1
8000c414:	5e 2b       	reths	r11
8000c416:	5c 3b       	neg	r11
8000c418:	5e fb       	retal	r11

8000c41a <__avr32_u32_to_f64>:
8000c41a:	f8 cb 00 00 	sub	r11,r12,0
8000c41e:	30 0c       	mov	r12,0
8000c420:	c0 38       	rjmp	8000c426 <__avr32_s32_to_f64+0x4>

8000c422 <__avr32_s32_to_f64>:
8000c422:	18 9b       	mov	r11,r12
8000c424:	5c 4b       	abs	r11
8000c426:	30 0a       	mov	r10,0
8000c428:	5e 0b       	reteq	r11
8000c42a:	d4 01       	pushm	lr
8000c42c:	e0 69 04 1e 	mov	r9,1054
8000c430:	f6 08 12 00 	clz	r8,r11
8000c434:	c1 70       	breq	8000c462 <__avr32_s32_to_f64+0x40>
8000c436:	c0 c3       	brcs	8000c44e <__avr32_s32_to_f64+0x2c>
8000c438:	f0 0e 11 20 	rsub	lr,r8,32
8000c43c:	f6 08 09 4b 	lsl	r11,r11,r8
8000c440:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c444:	1c 4b       	or	r11,lr
8000c446:	f4 08 09 4a 	lsl	r10,r10,r8
8000c44a:	10 19       	sub	r9,r8
8000c44c:	c0 b8       	rjmp	8000c462 <__avr32_s32_to_f64+0x40>
8000c44e:	f4 08 12 00 	clz	r8,r10
8000c452:	f9 b8 03 00 	movlo	r8,0
8000c456:	f7 b8 02 e0 	subhs	r8,-32
8000c45a:	f4 08 09 4b 	lsl	r11,r10,r8
8000c45e:	30 0a       	mov	r10,0
8000c460:	10 19       	sub	r9,r8
8000c462:	58 09       	cp.w	r9,0
8000c464:	e0 89 00 30 	brgt	8000c4c4 <__avr32_s32_to_f64+0xa2>
8000c468:	5c 39       	neg	r9
8000c46a:	2f f9       	sub	r9,-1
8000c46c:	e0 49 00 36 	cp.w	r9,54
8000c470:	c0 43       	brcs	8000c478 <__avr32_s32_to_f64+0x56>
8000c472:	30 0b       	mov	r11,0
8000c474:	30 0a       	mov	r10,0
8000c476:	c2 68       	rjmp	8000c4c2 <__avr32_s32_to_f64+0xa0>
8000c478:	2f 69       	sub	r9,-10
8000c47a:	f2 08 11 20 	rsub	r8,r9,32
8000c47e:	e0 49 00 20 	cp.w	r9,32
8000c482:	c0 b2       	brcc	8000c498 <__avr32_s32_to_f64+0x76>
8000c484:	f4 08 09 4e 	lsl	lr,r10,r8
8000c488:	f6 08 09 48 	lsl	r8,r11,r8
8000c48c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c490:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c494:	10 4b       	or	r11,r8
8000c496:	c0 88       	rjmp	8000c4a6 <__avr32_s32_to_f64+0x84>
8000c498:	f6 08 09 4e 	lsl	lr,r11,r8
8000c49c:	14 4e       	or	lr,r10
8000c49e:	16 9a       	mov	r10,r11
8000c4a0:	30 0b       	mov	r11,0
8000c4a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c4a6:	ed ba 00 00 	bld	r10,0x0
8000c4aa:	c0 92       	brcc	8000c4bc <__avr32_s32_to_f64+0x9a>
8000c4ac:	1c 7e       	tst	lr,lr
8000c4ae:	c0 41       	brne	8000c4b6 <__avr32_s32_to_f64+0x94>
8000c4b0:	ed ba 00 01 	bld	r10,0x1
8000c4b4:	c0 42       	brcc	8000c4bc <__avr32_s32_to_f64+0x9a>
8000c4b6:	2f fa       	sub	r10,-1
8000c4b8:	f7 bb 02 ff 	subhs	r11,-1
8000c4bc:	5c fc       	rol	r12
8000c4be:	5d 0b       	ror	r11
8000c4c0:	5d 0a       	ror	r10
8000c4c2:	d8 02       	popm	pc
8000c4c4:	e0 68 03 ff 	mov	r8,1023
8000c4c8:	ed ba 00 0b 	bld	r10,0xb
8000c4cc:	f7 b8 00 ff 	subeq	r8,-1
8000c4d0:	10 0a       	add	r10,r8
8000c4d2:	5c 0b       	acr	r11
8000c4d4:	f7 b9 03 fe 	sublo	r9,-2
8000c4d8:	e0 49 07 ff 	cp.w	r9,2047
8000c4dc:	c0 55       	brlt	8000c4e6 <__avr32_s32_to_f64+0xc4>
8000c4de:	30 0a       	mov	r10,0
8000c4e0:	fc 1b ff e0 	movh	r11,0xffe0
8000c4e4:	c0 c8       	rjmp	8000c4fc <__floatsidf_return_op1>
8000c4e6:	ed bb 00 1f 	bld	r11,0x1f
8000c4ea:	f7 b9 01 01 	subne	r9,1
8000c4ee:	ab 9a       	lsr	r10,0xb
8000c4f0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c4f4:	a1 7b       	lsl	r11,0x1
8000c4f6:	ab 9b       	lsr	r11,0xb
8000c4f8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c4fc <__floatsidf_return_op1>:
8000c4fc:	a1 7c       	lsl	r12,0x1
8000c4fe:	5d 0b       	ror	r11
8000c500:	d8 02       	popm	pc

8000c502 <__avr32_f64_cmp_eq>:
8000c502:	10 3a       	cp.w	r10,r8
8000c504:	f2 0b 13 00 	cpc	r11,r9
8000c508:	c0 80       	breq	8000c518 <__avr32_f64_cmp_eq+0x16>
8000c50a:	a1 7b       	lsl	r11,0x1
8000c50c:	a1 79       	lsl	r9,0x1
8000c50e:	14 4b       	or	r11,r10
8000c510:	12 4b       	or	r11,r9
8000c512:	10 4b       	or	r11,r8
8000c514:	5e 0f       	reteq	1
8000c516:	5e fd       	retal	0
8000c518:	a1 7b       	lsl	r11,0x1
8000c51a:	fc 1c ff e0 	movh	r12,0xffe0
8000c51e:	58 0a       	cp.w	r10,0
8000c520:	f8 0b 13 00 	cpc	r11,r12
8000c524:	5e 8f       	retls	1
8000c526:	5e fd       	retal	0

8000c528 <__avr32_f64_cmp_ge>:
8000c528:	1a de       	st.w	--sp,lr
8000c52a:	1a d7       	st.w	--sp,r7
8000c52c:	a1 7b       	lsl	r11,0x1
8000c52e:	5f 3c       	srlo	r12
8000c530:	a1 79       	lsl	r9,0x1
8000c532:	5f 37       	srlo	r7
8000c534:	5c fc       	rol	r12
8000c536:	fc 1e ff e0 	movh	lr,0xffe0
8000c53a:	58 0a       	cp.w	r10,0
8000c53c:	fc 0b 13 00 	cpc	r11,lr
8000c540:	e0 8b 00 1d 	brhi	8000c57a <__avr32_f64_cmp_ge+0x52>
8000c544:	58 08       	cp.w	r8,0
8000c546:	fc 09 13 00 	cpc	r9,lr
8000c54a:	e0 8b 00 18 	brhi	8000c57a <__avr32_f64_cmp_ge+0x52>
8000c54e:	58 0b       	cp.w	r11,0
8000c550:	f5 ba 00 00 	subfeq	r10,0
8000c554:	c1 50       	breq	8000c57e <__avr32_f64_cmp_ge+0x56>
8000c556:	1b 07       	ld.w	r7,sp++
8000c558:	1b 0e       	ld.w	lr,sp++
8000c55a:	58 3c       	cp.w	r12,3
8000c55c:	c0 a0       	breq	8000c570 <__avr32_f64_cmp_ge+0x48>
8000c55e:	58 1c       	cp.w	r12,1
8000c560:	c0 33       	brcs	8000c566 <__avr32_f64_cmp_ge+0x3e>
8000c562:	5e 0f       	reteq	1
8000c564:	5e 1d       	retne	0
8000c566:	10 3a       	cp.w	r10,r8
8000c568:	f2 0b 13 00 	cpc	r11,r9
8000c56c:	5e 2f       	reths	1
8000c56e:	5e 3d       	retlo	0
8000c570:	14 38       	cp.w	r8,r10
8000c572:	f6 09 13 00 	cpc	r9,r11
8000c576:	5e 2f       	reths	1
8000c578:	5e 3d       	retlo	0
8000c57a:	1b 07       	ld.w	r7,sp++
8000c57c:	d8 0a       	popm	pc,r12=0
8000c57e:	58 17       	cp.w	r7,1
8000c580:	5f 0c       	sreq	r12
8000c582:	58 09       	cp.w	r9,0
8000c584:	f5 b8 00 00 	subfeq	r8,0
8000c588:	1b 07       	ld.w	r7,sp++
8000c58a:	1b 0e       	ld.w	lr,sp++
8000c58c:	5e 0f       	reteq	1
8000c58e:	5e fc       	retal	r12

8000c590 <__avr32_f64_cmp_lt>:
8000c590:	1a de       	st.w	--sp,lr
8000c592:	1a d7       	st.w	--sp,r7
8000c594:	a1 7b       	lsl	r11,0x1
8000c596:	5f 3c       	srlo	r12
8000c598:	a1 79       	lsl	r9,0x1
8000c59a:	5f 37       	srlo	r7
8000c59c:	5c fc       	rol	r12
8000c59e:	fc 1e ff e0 	movh	lr,0xffe0
8000c5a2:	58 0a       	cp.w	r10,0
8000c5a4:	fc 0b 13 00 	cpc	r11,lr
8000c5a8:	e0 8b 00 1d 	brhi	8000c5e2 <__avr32_f64_cmp_lt+0x52>
8000c5ac:	58 08       	cp.w	r8,0
8000c5ae:	fc 09 13 00 	cpc	r9,lr
8000c5b2:	e0 8b 00 18 	brhi	8000c5e2 <__avr32_f64_cmp_lt+0x52>
8000c5b6:	58 0b       	cp.w	r11,0
8000c5b8:	f5 ba 00 00 	subfeq	r10,0
8000c5bc:	c1 50       	breq	8000c5e6 <__avr32_f64_cmp_lt+0x56>
8000c5be:	1b 07       	ld.w	r7,sp++
8000c5c0:	1b 0e       	ld.w	lr,sp++
8000c5c2:	58 3c       	cp.w	r12,3
8000c5c4:	c0 a0       	breq	8000c5d8 <__avr32_f64_cmp_lt+0x48>
8000c5c6:	58 1c       	cp.w	r12,1
8000c5c8:	c0 33       	brcs	8000c5ce <__avr32_f64_cmp_lt+0x3e>
8000c5ca:	5e 0d       	reteq	0
8000c5cc:	5e 1f       	retne	1
8000c5ce:	10 3a       	cp.w	r10,r8
8000c5d0:	f2 0b 13 00 	cpc	r11,r9
8000c5d4:	5e 2d       	reths	0
8000c5d6:	5e 3f       	retlo	1
8000c5d8:	14 38       	cp.w	r8,r10
8000c5da:	f6 09 13 00 	cpc	r9,r11
8000c5de:	5e 2d       	reths	0
8000c5e0:	5e 3f       	retlo	1
8000c5e2:	1b 07       	ld.w	r7,sp++
8000c5e4:	d8 0a       	popm	pc,r12=0
8000c5e6:	58 17       	cp.w	r7,1
8000c5e8:	5f 1c       	srne	r12
8000c5ea:	58 09       	cp.w	r9,0
8000c5ec:	f5 b8 00 00 	subfeq	r8,0
8000c5f0:	1b 07       	ld.w	r7,sp++
8000c5f2:	1b 0e       	ld.w	lr,sp++
8000c5f4:	5e 0d       	reteq	0
8000c5f6:	5e fc       	retal	r12

8000c5f8 <__avr32_f64_div>:
8000c5f8:	eb cd 40 ff 	pushm	r0-r7,lr
8000c5fc:	f7 e9 20 0e 	eor	lr,r11,r9
8000c600:	f6 07 16 14 	lsr	r7,r11,0x14
8000c604:	a9 7b       	lsl	r11,0x9
8000c606:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c60a:	a9 7a       	lsl	r10,0x9
8000c60c:	bd bb       	sbr	r11,0x1d
8000c60e:	e4 1b 3f ff 	andh	r11,0x3fff
8000c612:	ab d7       	cbr	r7,0xb
8000c614:	e0 80 00 cc 	breq	8000c7ac <__avr32_f64_div_round_subnormal+0x54>
8000c618:	e0 47 07 ff 	cp.w	r7,2047
8000c61c:	e0 84 00 b5 	brge	8000c786 <__avr32_f64_div_round_subnormal+0x2e>
8000c620:	f2 06 16 14 	lsr	r6,r9,0x14
8000c624:	a9 79       	lsl	r9,0x9
8000c626:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c62a:	a9 78       	lsl	r8,0x9
8000c62c:	bd b9       	sbr	r9,0x1d
8000c62e:	e4 19 3f ff 	andh	r9,0x3fff
8000c632:	ab d6       	cbr	r6,0xb
8000c634:	e0 80 00 e2 	breq	8000c7f8 <__avr32_f64_div_round_subnormal+0xa0>
8000c638:	e0 46 07 ff 	cp.w	r6,2047
8000c63c:	e0 84 00 b2 	brge	8000c7a0 <__avr32_f64_div_round_subnormal+0x48>
8000c640:	0c 17       	sub	r7,r6
8000c642:	fe 37 fc 01 	sub	r7,-1023
8000c646:	fc 1c 80 00 	movh	r12,0x8000
8000c64a:	f8 03 16 01 	lsr	r3,r12,0x1
8000c64e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c652:	5c d4       	com	r4
8000c654:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c658:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c65c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c660:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c664:	ea 03 15 02 	lsl	r3,r5,0x2
8000c668:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c66c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c670:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c674:	ea 03 15 02 	lsl	r3,r5,0x2
8000c678:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c67c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c680:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c684:	ea 03 15 02 	lsl	r3,r5,0x2
8000c688:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c68c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c690:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c694:	02 04       	add	r4,r1
8000c696:	5c 05       	acr	r5
8000c698:	a3 65       	lsl	r5,0x2
8000c69a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c69e:	a3 64       	lsl	r4,0x2
8000c6a0:	5c 34       	neg	r4
8000c6a2:	f8 05 01 45 	sbc	r5,r12,r5
8000c6a6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c6aa:	e4 05 07 40 	macu.d	r0,r2,r5
8000c6ae:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c6b2:	02 04       	add	r4,r1
8000c6b4:	5c 05       	acr	r5
8000c6b6:	ea 03 15 02 	lsl	r3,r5,0x2
8000c6ba:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c6be:	e8 02 15 02 	lsl	r2,r4,0x2
8000c6c2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6c6:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6ca:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c6ce:	02 04       	add	r4,r1
8000c6d0:	5c 05       	acr	r5
8000c6d2:	a3 65       	lsl	r5,0x2
8000c6d4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c6d8:	a3 64       	lsl	r4,0x2
8000c6da:	5c 34       	neg	r4
8000c6dc:	f8 05 01 45 	sbc	r5,r12,r5
8000c6e0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c6e4:	e4 05 07 40 	macu.d	r0,r2,r5
8000c6e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c6ec:	02 04       	add	r4,r1
8000c6ee:	5c 05       	acr	r5
8000c6f0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c6f4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c6f8:	e8 02 15 02 	lsl	r2,r4,0x2
8000c6fc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c700:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c704:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c708:	02 02       	add	r2,r1
8000c70a:	5c 03       	acr	r3
8000c70c:	ed b3 00 1c 	bld	r3,0x1c
8000c710:	c0 90       	breq	8000c722 <__avr32_f64_div+0x12a>
8000c712:	a1 72       	lsl	r2,0x1
8000c714:	5c f3       	rol	r3
8000c716:	20 17       	sub	r7,1
8000c718:	a3 9a       	lsr	r10,0x3
8000c71a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c71e:	a3 9b       	lsr	r11,0x3
8000c720:	c0 58       	rjmp	8000c72a <__avr32_f64_div+0x132>
8000c722:	a5 8a       	lsr	r10,0x4
8000c724:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c728:	a5 8b       	lsr	r11,0x4
8000c72a:	58 07       	cp.w	r7,0
8000c72c:	e0 8a 00 8b 	brle	8000c842 <__avr32_f64_div_res_subnormal>
8000c730:	e0 12 ff 00 	andl	r2,0xff00
8000c734:	e8 12 00 80 	orl	r2,0x80
8000c738:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c73c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c740:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c744:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c748:	00 05       	add	r5,r0
8000c74a:	f0 01 00 48 	adc	r8,r8,r1
8000c74e:	5c 09       	acr	r9
8000c750:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c754:	58 04       	cp.w	r4,0
8000c756:	5c 25       	cpc	r5

8000c758 <__avr32_f64_div_round_subnormal>:
8000c758:	f4 08 13 00 	cpc	r8,r10
8000c75c:	f6 09 13 00 	cpc	r9,r11
8000c760:	5f 36       	srlo	r6
8000c762:	f8 06 17 00 	moveq	r6,r12
8000c766:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c76a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c76e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c772:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c776:	ed be 00 1f 	bld	lr,0x1f
8000c77a:	ef bb 00 1f 	bst	r11,0x1f
8000c77e:	0c 0a       	add	r10,r6
8000c780:	5c 0b       	acr	r11
8000c782:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c786:	e4 1b 00 0f 	andh	r11,0xf
8000c78a:	14 4b       	or	r11,r10
8000c78c:	e0 81 00 a7 	brne	8000c8da <__avr32_f64_div_res_subnormal+0x98>
8000c790:	f2 06 16 14 	lsr	r6,r9,0x14
8000c794:	ab d6       	cbr	r6,0xb
8000c796:	e0 46 07 ff 	cp.w	r6,2047
8000c79a:	e0 81 00 a4 	brne	8000c8e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c79e:	c9 e8       	rjmp	8000c8da <__avr32_f64_div_res_subnormal+0x98>
8000c7a0:	e4 19 00 0f 	andh	r9,0xf
8000c7a4:	10 49       	or	r9,r8
8000c7a6:	e0 81 00 9a 	brne	8000c8da <__avr32_f64_div_res_subnormal+0x98>
8000c7aa:	c9 28       	rjmp	8000c8ce <__avr32_f64_div_res_subnormal+0x8c>
8000c7ac:	a3 7b       	lsl	r11,0x3
8000c7ae:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c7b2:	a3 7a       	lsl	r10,0x3
8000c7b4:	f5 eb 10 04 	or	r4,r10,r11
8000c7b8:	e0 80 00 a0 	breq	8000c8f8 <__avr32_f64_div_op1_zero>
8000c7bc:	f6 04 12 00 	clz	r4,r11
8000c7c0:	c1 70       	breq	8000c7ee <__avr32_f64_div_round_subnormal+0x96>
8000c7c2:	c0 c3       	brcs	8000c7da <__avr32_f64_div_round_subnormal+0x82>
8000c7c4:	e8 05 11 20 	rsub	r5,r4,32
8000c7c8:	f6 04 09 4b 	lsl	r11,r11,r4
8000c7cc:	f4 05 0a 45 	lsr	r5,r10,r5
8000c7d0:	0a 4b       	or	r11,r5
8000c7d2:	f4 04 09 4a 	lsl	r10,r10,r4
8000c7d6:	08 17       	sub	r7,r4
8000c7d8:	c0 b8       	rjmp	8000c7ee <__avr32_f64_div_round_subnormal+0x96>
8000c7da:	f4 04 12 00 	clz	r4,r10
8000c7de:	f9 b4 03 00 	movlo	r4,0
8000c7e2:	f7 b4 02 e0 	subhs	r4,-32
8000c7e6:	f4 04 09 4b 	lsl	r11,r10,r4
8000c7ea:	30 0a       	mov	r10,0
8000c7ec:	08 17       	sub	r7,r4
8000c7ee:	a3 8a       	lsr	r10,0x2
8000c7f0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c7f4:	a3 8b       	lsr	r11,0x2
8000c7f6:	c1 1b       	rjmp	8000c618 <__avr32_f64_div+0x20>
8000c7f8:	a3 79       	lsl	r9,0x3
8000c7fa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c7fe:	a3 78       	lsl	r8,0x3
8000c800:	f3 e8 10 04 	or	r4,r9,r8
8000c804:	c6 f0       	breq	8000c8e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c806:	f2 04 12 00 	clz	r4,r9
8000c80a:	c1 70       	breq	8000c838 <__avr32_f64_div_round_subnormal+0xe0>
8000c80c:	c0 c3       	brcs	8000c824 <__avr32_f64_div_round_subnormal+0xcc>
8000c80e:	e8 05 11 20 	rsub	r5,r4,32
8000c812:	f2 04 09 49 	lsl	r9,r9,r4
8000c816:	f0 05 0a 45 	lsr	r5,r8,r5
8000c81a:	0a 49       	or	r9,r5
8000c81c:	f0 04 09 48 	lsl	r8,r8,r4
8000c820:	08 16       	sub	r6,r4
8000c822:	c0 b8       	rjmp	8000c838 <__avr32_f64_div_round_subnormal+0xe0>
8000c824:	f0 04 12 00 	clz	r4,r8
8000c828:	f9 b4 03 00 	movlo	r4,0
8000c82c:	f7 b4 02 e0 	subhs	r4,-32
8000c830:	f0 04 09 49 	lsl	r9,r8,r4
8000c834:	30 08       	mov	r8,0
8000c836:	08 16       	sub	r6,r4
8000c838:	a3 88       	lsr	r8,0x2
8000c83a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c83e:	a3 89       	lsr	r9,0x2
8000c840:	cf ca       	rjmp	8000c638 <__avr32_f64_div+0x40>

8000c842 <__avr32_f64_div_res_subnormal>:
8000c842:	5c 37       	neg	r7
8000c844:	2f f7       	sub	r7,-1
8000c846:	f1 b7 04 c0 	satu	r7,0x6
8000c84a:	e0 47 00 20 	cp.w	r7,32
8000c84e:	c1 54       	brge	8000c878 <__avr32_f64_div_res_subnormal+0x36>
8000c850:	ee 06 11 20 	rsub	r6,r7,32
8000c854:	e4 07 0a 42 	lsr	r2,r2,r7
8000c858:	e6 06 09 4c 	lsl	r12,r3,r6
8000c85c:	18 42       	or	r2,r12
8000c85e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c862:	f4 06 09 41 	lsl	r1,r10,r6
8000c866:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c86a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c86e:	18 4a       	or	r10,r12
8000c870:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c874:	30 00       	mov	r0,0
8000c876:	c1 58       	rjmp	8000c8a0 <__avr32_f64_div_res_subnormal+0x5e>
8000c878:	ee 06 11 20 	rsub	r6,r7,32
8000c87c:	f9 b0 00 00 	moveq	r0,0
8000c880:	f9 bc 00 00 	moveq	r12,0
8000c884:	c0 50       	breq	8000c88e <__avr32_f64_div_res_subnormal+0x4c>
8000c886:	f4 06 09 40 	lsl	r0,r10,r6
8000c88a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c88e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c892:	30 03       	mov	r3,0
8000c894:	f4 07 0a 41 	lsr	r1,r10,r7
8000c898:	18 41       	or	r1,r12
8000c89a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c89e:	30 0b       	mov	r11,0
8000c8a0:	e0 12 ff 00 	andl	r2,0xff00
8000c8a4:	e8 12 00 80 	orl	r2,0x80
8000c8a8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c8ac:	e4 09 07 46 	macu.d	r6,r2,r9
8000c8b0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c8b4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c8b8:	0c 05       	add	r5,r6
8000c8ba:	f0 07 00 48 	adc	r8,r8,r7
8000c8be:	5c 09       	acr	r9
8000c8c0:	30 07       	mov	r7,0
8000c8c2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c8c6:	00 34       	cp.w	r4,r0
8000c8c8:	e2 05 13 00 	cpc	r5,r1
8000c8cc:	c4 6b       	rjmp	8000c758 <__avr32_f64_div_round_subnormal>
8000c8ce:	1c 9b       	mov	r11,lr
8000c8d0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8d4:	30 0a       	mov	r10,0
8000c8d6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8da:	3f fb       	mov	r11,-1
8000c8dc:	30 0a       	mov	r10,0
8000c8de:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8e2:	f5 eb 10 04 	or	r4,r10,r11
8000c8e6:	c0 90       	breq	8000c8f8 <__avr32_f64_div_op1_zero>
8000c8e8:	1c 9b       	mov	r11,lr
8000c8ea:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8ee:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c8f2:	30 0a       	mov	r10,0
8000c8f4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c8f8 <__avr32_f64_div_op1_zero>:
8000c8f8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c8fc:	ce f0       	breq	8000c8da <__avr32_f64_div_res_subnormal+0x98>
8000c8fe:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c902:	e0 44 07 ff 	cp.w	r4,2047
8000c906:	ce 41       	brne	8000c8ce <__avr32_f64_div_res_subnormal+0x8c>
8000c908:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c90c:	ce 10       	breq	8000c8ce <__avr32_f64_div_res_subnormal+0x8c>
8000c90e:	ce 6b       	rjmp	8000c8da <__avr32_f64_div_res_subnormal+0x98>

8000c910 <__avr32_udiv64>:
8000c910:	d4 31       	pushm	r0-r7,lr
8000c912:	1a 97       	mov	r7,sp
8000c914:	20 3d       	sub	sp,12
8000c916:	10 9c       	mov	r12,r8
8000c918:	12 9e       	mov	lr,r9
8000c91a:	14 93       	mov	r3,r10
8000c91c:	58 09       	cp.w	r9,0
8000c91e:	e0 81 00 bd 	brne	8000ca98 <__avr32_udiv64+0x188>
8000c922:	16 38       	cp.w	r8,r11
8000c924:	e0 88 00 40 	brls	8000c9a4 <__avr32_udiv64+0x94>
8000c928:	f0 08 12 00 	clz	r8,r8
8000c92c:	c0 d0       	breq	8000c946 <__avr32_udiv64+0x36>
8000c92e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c932:	f0 09 11 20 	rsub	r9,r8,32
8000c936:	f8 08 09 4c 	lsl	r12,r12,r8
8000c93a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c93e:	f4 08 09 43 	lsl	r3,r10,r8
8000c942:	f3 eb 10 0b 	or	r11,r9,r11
8000c946:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c94a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c94e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c952:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c956:	00 99       	mov	r9,r0
8000c958:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c95c:	e0 0a 02 48 	mul	r8,r0,r10
8000c960:	10 3b       	cp.w	r11,r8
8000c962:	c0 a2       	brcc	8000c976 <__avr32_udiv64+0x66>
8000c964:	20 19       	sub	r9,1
8000c966:	18 0b       	add	r11,r12
8000c968:	18 3b       	cp.w	r11,r12
8000c96a:	c0 63       	brcs	8000c976 <__avr32_udiv64+0x66>
8000c96c:	10 3b       	cp.w	r11,r8
8000c96e:	f7 b9 03 01 	sublo	r9,1
8000c972:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c976:	f6 08 01 01 	sub	r1,r11,r8
8000c97a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c97e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c982:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c986:	00 98       	mov	r8,r0
8000c988:	e0 0a 02 4a 	mul	r10,r0,r10
8000c98c:	14 33       	cp.w	r3,r10
8000c98e:	c0 82       	brcc	8000c99e <__avr32_udiv64+0x8e>
8000c990:	20 18       	sub	r8,1
8000c992:	18 03       	add	r3,r12
8000c994:	18 33       	cp.w	r3,r12
8000c996:	c0 43       	brcs	8000c99e <__avr32_udiv64+0x8e>
8000c998:	14 33       	cp.w	r3,r10
8000c99a:	f7 b8 03 01 	sublo	r8,1
8000c99e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c9a2:	cd f8       	rjmp	8000cb60 <__avr32_udiv64+0x250>
8000c9a4:	58 08       	cp.w	r8,0
8000c9a6:	c0 51       	brne	8000c9b0 <__avr32_udiv64+0xa0>
8000c9a8:	30 19       	mov	r9,1
8000c9aa:	f2 08 0d 08 	divu	r8,r9,r8
8000c9ae:	10 9c       	mov	r12,r8
8000c9b0:	f8 06 12 00 	clz	r6,r12
8000c9b4:	c0 41       	brne	8000c9bc <__avr32_udiv64+0xac>
8000c9b6:	18 1b       	sub	r11,r12
8000c9b8:	30 19       	mov	r9,1
8000c9ba:	c4 08       	rjmp	8000ca3a <__avr32_udiv64+0x12a>
8000c9bc:	ec 01 11 20 	rsub	r1,r6,32
8000c9c0:	f4 01 0a 49 	lsr	r9,r10,r1
8000c9c4:	f8 06 09 4c 	lsl	r12,r12,r6
8000c9c8:	f6 06 09 48 	lsl	r8,r11,r6
8000c9cc:	f6 01 0a 41 	lsr	r1,r11,r1
8000c9d0:	f3 e8 10 08 	or	r8,r9,r8
8000c9d4:	f8 03 16 10 	lsr	r3,r12,0x10
8000c9d8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9dc:	e2 03 0d 00 	divu	r0,r1,r3
8000c9e0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c9e4:	00 9e       	mov	lr,r0
8000c9e6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9ea:	e0 05 02 49 	mul	r9,r0,r5
8000c9ee:	12 3b       	cp.w	r11,r9
8000c9f0:	c0 a2       	brcc	8000ca04 <__avr32_udiv64+0xf4>
8000c9f2:	20 1e       	sub	lr,1
8000c9f4:	18 0b       	add	r11,r12
8000c9f6:	18 3b       	cp.w	r11,r12
8000c9f8:	c0 63       	brcs	8000ca04 <__avr32_udiv64+0xf4>
8000c9fa:	12 3b       	cp.w	r11,r9
8000c9fc:	f7 be 03 01 	sublo	lr,1
8000ca00:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca04:	12 1b       	sub	r11,r9
8000ca06:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ca0a:	f6 03 0d 02 	divu	r2,r11,r3
8000ca0e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ca12:	04 99       	mov	r9,r2
8000ca14:	e4 05 02 4b 	mul	r11,r2,r5
8000ca18:	16 38       	cp.w	r8,r11
8000ca1a:	c0 a2       	brcc	8000ca2e <__avr32_udiv64+0x11e>
8000ca1c:	20 19       	sub	r9,1
8000ca1e:	18 08       	add	r8,r12
8000ca20:	18 38       	cp.w	r8,r12
8000ca22:	c0 63       	brcs	8000ca2e <__avr32_udiv64+0x11e>
8000ca24:	16 38       	cp.w	r8,r11
8000ca26:	f7 b9 03 01 	sublo	r9,1
8000ca2a:	f1 dc e3 08 	addcs	r8,r8,r12
8000ca2e:	f4 06 09 43 	lsl	r3,r10,r6
8000ca32:	f0 0b 01 0b 	sub	r11,r8,r11
8000ca36:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ca3a:	f8 06 16 10 	lsr	r6,r12,0x10
8000ca3e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ca42:	f6 06 0d 00 	divu	r0,r11,r6
8000ca46:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca4a:	00 9a       	mov	r10,r0
8000ca4c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca50:	e0 0e 02 48 	mul	r8,r0,lr
8000ca54:	10 3b       	cp.w	r11,r8
8000ca56:	c0 a2       	brcc	8000ca6a <__avr32_udiv64+0x15a>
8000ca58:	20 1a       	sub	r10,1
8000ca5a:	18 0b       	add	r11,r12
8000ca5c:	18 3b       	cp.w	r11,r12
8000ca5e:	c0 63       	brcs	8000ca6a <__avr32_udiv64+0x15a>
8000ca60:	10 3b       	cp.w	r11,r8
8000ca62:	f7 ba 03 01 	sublo	r10,1
8000ca66:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca6a:	f6 08 01 01 	sub	r1,r11,r8
8000ca6e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca72:	e2 06 0d 00 	divu	r0,r1,r6
8000ca76:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca7a:	00 98       	mov	r8,r0
8000ca7c:	e0 0e 02 4b 	mul	r11,r0,lr
8000ca80:	16 33       	cp.w	r3,r11
8000ca82:	c0 82       	brcc	8000ca92 <__avr32_udiv64+0x182>
8000ca84:	20 18       	sub	r8,1
8000ca86:	18 03       	add	r3,r12
8000ca88:	18 33       	cp.w	r3,r12
8000ca8a:	c0 43       	brcs	8000ca92 <__avr32_udiv64+0x182>
8000ca8c:	16 33       	cp.w	r3,r11
8000ca8e:	f7 b8 03 01 	sublo	r8,1
8000ca92:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca96:	c6 98       	rjmp	8000cb68 <__avr32_udiv64+0x258>
8000ca98:	16 39       	cp.w	r9,r11
8000ca9a:	e0 8b 00 65 	brhi	8000cb64 <__avr32_udiv64+0x254>
8000ca9e:	f2 09 12 00 	clz	r9,r9
8000caa2:	c0 b1       	brne	8000cab8 <__avr32_udiv64+0x1a8>
8000caa4:	10 3a       	cp.w	r10,r8
8000caa6:	5f 2a       	srhs	r10
8000caa8:	1c 3b       	cp.w	r11,lr
8000caaa:	5f b8       	srhi	r8
8000caac:	10 4a       	or	r10,r8
8000caae:	f2 0a 18 00 	cp.b	r10,r9
8000cab2:	c5 90       	breq	8000cb64 <__avr32_udiv64+0x254>
8000cab4:	30 18       	mov	r8,1
8000cab6:	c5 98       	rjmp	8000cb68 <__avr32_udiv64+0x258>
8000cab8:	f0 09 09 46 	lsl	r6,r8,r9
8000cabc:	f2 03 11 20 	rsub	r3,r9,32
8000cac0:	fc 09 09 4e 	lsl	lr,lr,r9
8000cac4:	f0 03 0a 48 	lsr	r8,r8,r3
8000cac8:	f6 09 09 4c 	lsl	r12,r11,r9
8000cacc:	f4 03 0a 42 	lsr	r2,r10,r3
8000cad0:	ef 46 ff f4 	st.w	r7[-12],r6
8000cad4:	f6 03 0a 43 	lsr	r3,r11,r3
8000cad8:	18 42       	or	r2,r12
8000cada:	f1 ee 10 0c 	or	r12,r8,lr
8000cade:	f8 01 16 10 	lsr	r1,r12,0x10
8000cae2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cae6:	e6 01 0d 04 	divu	r4,r3,r1
8000caea:	e4 03 16 10 	lsr	r3,r2,0x10
8000caee:	08 9e       	mov	lr,r4
8000caf0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000caf4:	e8 06 02 48 	mul	r8,r4,r6
8000caf8:	10 33       	cp.w	r3,r8
8000cafa:	c0 a2       	brcc	8000cb0e <__avr32_udiv64+0x1fe>
8000cafc:	20 1e       	sub	lr,1
8000cafe:	18 03       	add	r3,r12
8000cb00:	18 33       	cp.w	r3,r12
8000cb02:	c0 63       	brcs	8000cb0e <__avr32_udiv64+0x1fe>
8000cb04:	10 33       	cp.w	r3,r8
8000cb06:	f7 be 03 01 	sublo	lr,1
8000cb0a:	e7 dc e3 03 	addcs	r3,r3,r12
8000cb0e:	10 13       	sub	r3,r8
8000cb10:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cb14:	e6 01 0d 00 	divu	r0,r3,r1
8000cb18:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb1c:	00 98       	mov	r8,r0
8000cb1e:	e0 06 02 46 	mul	r6,r0,r6
8000cb22:	0c 3b       	cp.w	r11,r6
8000cb24:	c0 a2       	brcc	8000cb38 <__avr32_udiv64+0x228>
8000cb26:	20 18       	sub	r8,1
8000cb28:	18 0b       	add	r11,r12
8000cb2a:	18 3b       	cp.w	r11,r12
8000cb2c:	c0 63       	brcs	8000cb38 <__avr32_udiv64+0x228>
8000cb2e:	0c 3b       	cp.w	r11,r6
8000cb30:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb34:	f7 b8 03 01 	sublo	r8,1
8000cb38:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cb3c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cb40:	0c 1b       	sub	r11,r6
8000cb42:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cb46:	06 95       	mov	r5,r3
8000cb48:	16 35       	cp.w	r5,r11
8000cb4a:	e0 8b 00 0a 	brhi	8000cb5e <__avr32_udiv64+0x24e>
8000cb4e:	5f 0b       	sreq	r11
8000cb50:	f4 09 09 49 	lsl	r9,r10,r9
8000cb54:	12 32       	cp.w	r2,r9
8000cb56:	5f b9       	srhi	r9
8000cb58:	f7 e9 00 09 	and	r9,r11,r9
8000cb5c:	c0 60       	breq	8000cb68 <__avr32_udiv64+0x258>
8000cb5e:	20 18       	sub	r8,1
8000cb60:	30 09       	mov	r9,0
8000cb62:	c0 38       	rjmp	8000cb68 <__avr32_udiv64+0x258>
8000cb64:	30 09       	mov	r9,0
8000cb66:	12 98       	mov	r8,r9
8000cb68:	10 9a       	mov	r10,r8
8000cb6a:	12 93       	mov	r3,r9
8000cb6c:	10 92       	mov	r2,r8
8000cb6e:	12 9b       	mov	r11,r9
8000cb70:	2f dd       	sub	sp,-12
8000cb72:	d8 32       	popm	r0-r7,pc

8000cb74 <__avr32_umod64>:
8000cb74:	d4 31       	pushm	r0-r7,lr
8000cb76:	1a 97       	mov	r7,sp
8000cb78:	20 3d       	sub	sp,12
8000cb7a:	10 9c       	mov	r12,r8
8000cb7c:	12 95       	mov	r5,r9
8000cb7e:	14 9e       	mov	lr,r10
8000cb80:	16 91       	mov	r1,r11
8000cb82:	16 96       	mov	r6,r11
8000cb84:	58 09       	cp.w	r9,0
8000cb86:	e0 81 00 81 	brne	8000cc88 <__avr32_umod64+0x114>
8000cb8a:	16 38       	cp.w	r8,r11
8000cb8c:	e0 88 00 12 	brls	8000cbb0 <__avr32_umod64+0x3c>
8000cb90:	f0 08 12 00 	clz	r8,r8
8000cb94:	c4 e0       	breq	8000cc30 <__avr32_umod64+0xbc>
8000cb96:	f6 08 09 46 	lsl	r6,r11,r8
8000cb9a:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb9e:	f0 0b 11 20 	rsub	r11,r8,32
8000cba2:	f4 08 09 4e 	lsl	lr,r10,r8
8000cba6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cbaa:	f7 e6 10 06 	or	r6,r11,r6
8000cbae:	c4 18       	rjmp	8000cc30 <__avr32_umod64+0xbc>
8000cbb0:	58 08       	cp.w	r8,0
8000cbb2:	c0 51       	brne	8000cbbc <__avr32_umod64+0x48>
8000cbb4:	30 19       	mov	r9,1
8000cbb6:	f2 08 0d 08 	divu	r8,r9,r8
8000cbba:	10 9c       	mov	r12,r8
8000cbbc:	f8 08 12 00 	clz	r8,r12
8000cbc0:	c0 31       	brne	8000cbc6 <__avr32_umod64+0x52>
8000cbc2:	18 16       	sub	r6,r12
8000cbc4:	c3 68       	rjmp	8000cc30 <__avr32_umod64+0xbc>
8000cbc6:	f0 03 11 20 	rsub	r3,r8,32
8000cbca:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cbce:	f8 08 09 4c 	lsl	r12,r12,r8
8000cbd2:	ec 08 09 49 	lsl	r9,r6,r8
8000cbd6:	ec 03 0a 43 	lsr	r3,r6,r3
8000cbda:	f7 e9 10 09 	or	r9,r11,r9
8000cbde:	f8 05 16 10 	lsr	r5,r12,0x10
8000cbe2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cbe6:	e6 05 0d 02 	divu	r2,r3,r5
8000cbea:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cbee:	ec 02 02 4b 	mul	r11,r6,r2
8000cbf2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cbf6:	16 3e       	cp.w	lr,r11
8000cbf8:	c0 72       	brcc	8000cc06 <__avr32_umod64+0x92>
8000cbfa:	18 0e       	add	lr,r12
8000cbfc:	18 3e       	cp.w	lr,r12
8000cbfe:	c0 43       	brcs	8000cc06 <__avr32_umod64+0x92>
8000cc00:	16 3e       	cp.w	lr,r11
8000cc02:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc06:	fc 0b 01 03 	sub	r3,lr,r11
8000cc0a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cc0e:	e6 05 0d 02 	divu	r2,r3,r5
8000cc12:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cc16:	a5 36       	mul	r6,r2
8000cc18:	0c 39       	cp.w	r9,r6
8000cc1a:	c0 72       	brcc	8000cc28 <__avr32_umod64+0xb4>
8000cc1c:	18 09       	add	r9,r12
8000cc1e:	18 39       	cp.w	r9,r12
8000cc20:	c0 43       	brcs	8000cc28 <__avr32_umod64+0xb4>
8000cc22:	0c 39       	cp.w	r9,r6
8000cc24:	f3 dc e3 09 	addcs	r9,r9,r12
8000cc28:	f2 06 01 06 	sub	r6,r9,r6
8000cc2c:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc30:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cc34:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cc38:	ec 0a 0d 02 	divu	r2,r6,r10
8000cc3c:	fc 09 16 10 	lsr	r9,lr,0x10
8000cc40:	ea 02 02 4b 	mul	r11,r5,r2
8000cc44:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cc48:	16 39       	cp.w	r9,r11
8000cc4a:	c0 72       	brcc	8000cc58 <__avr32_umod64+0xe4>
8000cc4c:	18 09       	add	r9,r12
8000cc4e:	18 39       	cp.w	r9,r12
8000cc50:	c0 43       	brcs	8000cc58 <__avr32_umod64+0xe4>
8000cc52:	16 39       	cp.w	r9,r11
8000cc54:	f3 dc e3 09 	addcs	r9,r9,r12
8000cc58:	f2 0b 01 0b 	sub	r11,r9,r11
8000cc5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cc60:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cc64:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cc68:	ea 0a 02 4a 	mul	r10,r5,r10
8000cc6c:	14 3e       	cp.w	lr,r10
8000cc6e:	c0 72       	brcc	8000cc7c <__avr32_umod64+0x108>
8000cc70:	18 0e       	add	lr,r12
8000cc72:	18 3e       	cp.w	lr,r12
8000cc74:	c0 43       	brcs	8000cc7c <__avr32_umod64+0x108>
8000cc76:	14 3e       	cp.w	lr,r10
8000cc78:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc7c:	fc 0a 01 0a 	sub	r10,lr,r10
8000cc80:	30 0b       	mov	r11,0
8000cc82:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cc86:	c7 b8       	rjmp	8000cd7c <__avr32_umod64+0x208>
8000cc88:	16 39       	cp.w	r9,r11
8000cc8a:	e0 8b 00 79 	brhi	8000cd7c <__avr32_umod64+0x208>
8000cc8e:	f2 09 12 00 	clz	r9,r9
8000cc92:	c1 21       	brne	8000ccb6 <__avr32_umod64+0x142>
8000cc94:	10 3a       	cp.w	r10,r8
8000cc96:	5f 2b       	srhs	r11
8000cc98:	0a 31       	cp.w	r1,r5
8000cc9a:	5f ba       	srhi	r10
8000cc9c:	f7 ea 10 0a 	or	r10,r11,r10
8000cca0:	f2 0a 18 00 	cp.b	r10,r9
8000cca4:	c0 60       	breq	8000ccb0 <__avr32_umod64+0x13c>
8000cca6:	fc 08 01 0c 	sub	r12,lr,r8
8000ccaa:	e2 05 01 46 	sbc	r6,r1,r5
8000ccae:	18 9e       	mov	lr,r12
8000ccb0:	0c 9b       	mov	r11,r6
8000ccb2:	1c 9a       	mov	r10,lr
8000ccb4:	c6 48       	rjmp	8000cd7c <__avr32_umod64+0x208>
8000ccb6:	ea 09 09 4c 	lsl	r12,r5,r9
8000ccba:	f2 06 11 20 	rsub	r6,r9,32
8000ccbe:	f6 09 09 4b 	lsl	r11,r11,r9
8000ccc2:	f0 09 09 42 	lsl	r2,r8,r9
8000ccc6:	ef 46 ff f4 	st.w	r7[-12],r6
8000ccca:	f0 06 0a 48 	lsr	r8,r8,r6
8000ccce:	18 48       	or	r8,r12
8000ccd0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ccd4:	f4 09 09 43 	lsl	r3,r10,r9
8000ccd8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ccdc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cce0:	16 4a       	or	r10,r11
8000cce2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cce6:	f8 0b 0d 04 	divu	r4,r12,r11
8000ccea:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ccee:	08 91       	mov	r1,r4
8000ccf0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ccf4:	e8 0e 02 46 	mul	r6,r4,lr
8000ccf8:	0c 3c       	cp.w	r12,r6
8000ccfa:	c0 a2       	brcc	8000cd0e <__avr32_umod64+0x19a>
8000ccfc:	20 11       	sub	r1,1
8000ccfe:	10 0c       	add	r12,r8
8000cd00:	10 3c       	cp.w	r12,r8
8000cd02:	c0 63       	brcs	8000cd0e <__avr32_umod64+0x19a>
8000cd04:	0c 3c       	cp.w	r12,r6
8000cd06:	f7 b1 03 01 	sublo	r1,1
8000cd0a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cd0e:	0c 1c       	sub	r12,r6
8000cd10:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cd14:	f8 0b 0d 04 	divu	r4,r12,r11
8000cd18:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cd1c:	08 96       	mov	r6,r4
8000cd1e:	e8 0e 02 4e 	mul	lr,r4,lr
8000cd22:	1c 3b       	cp.w	r11,lr
8000cd24:	c0 a2       	brcc	8000cd38 <__avr32_umod64+0x1c4>
8000cd26:	20 16       	sub	r6,1
8000cd28:	10 0b       	add	r11,r8
8000cd2a:	10 3b       	cp.w	r11,r8
8000cd2c:	c0 63       	brcs	8000cd38 <__avr32_umod64+0x1c4>
8000cd2e:	1c 3b       	cp.w	r11,lr
8000cd30:	f7 b6 03 01 	sublo	r6,1
8000cd34:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cd38:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cd3c:	1c 1b       	sub	r11,lr
8000cd3e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cd42:	00 9e       	mov	lr,r0
8000cd44:	02 9c       	mov	r12,r1
8000cd46:	16 3c       	cp.w	r12,r11
8000cd48:	e0 8b 00 08 	brhi	8000cd58 <__avr32_umod64+0x1e4>
8000cd4c:	5f 06       	sreq	r6
8000cd4e:	06 30       	cp.w	r0,r3
8000cd50:	5f ba       	srhi	r10
8000cd52:	ed ea 00 0a 	and	r10,r6,r10
8000cd56:	c0 60       	breq	8000cd62 <__avr32_umod64+0x1ee>
8000cd58:	fc 02 01 04 	sub	r4,lr,r2
8000cd5c:	f8 08 01 4c 	sbc	r12,r12,r8
8000cd60:	08 9e       	mov	lr,r4
8000cd62:	e6 0e 01 0a 	sub	r10,r3,lr
8000cd66:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cd6a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cd6e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cd72:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cd76:	f8 01 09 4c 	lsl	r12,r12,r1
8000cd7a:	18 4a       	or	r10,r12
8000cd7c:	2f dd       	sub	sp,-12
8000cd7e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 20 	sub	pc,pc,28704

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 53 	rcall	800055ac <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 4c 	rcall	800055ac <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 45 	rcall	800055ac <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 3e 	rcall	800055ac <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
