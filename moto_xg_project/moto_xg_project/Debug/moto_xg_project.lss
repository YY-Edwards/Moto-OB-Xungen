
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000b49c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d600  8000d600  0000da00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001350  8000d800  8000d800  0000dc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a4c  00000004  8000eb50  0000f004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000049d8  00000a50  8000f59c  0000fa50  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000fa50  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001728  00000000  00000000  0000fa80  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000036ab  00000000  00000000  000111a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002e844  00000000  00000000  00014853  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000077af  00000000  00000000  00043097  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000dae1  00000000  00000000  0004a846  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003e74  00000000  00000000  00058328  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000081e9  00000000  00000000  0005c19c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f886  00000000  00000000  00064385  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 000017d8  00000000  00000000  00073c10  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf bb f4 	sub	pc,pc,-17420

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d fc       	ld.ub	r12,r6[0x7]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3f 44       	mov	r4,-12
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 44       	sub	r4,-76
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d8 00       	acall	0x80
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 0c       	sub	r12,112
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	73 a4       	ld.w	r4,r9[0x68]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d8 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	77 68       	ld.w	r8,r11[0x58]

800020a4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 64       	and	r4,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d8 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	77 68       	ld.w	r8,r11[0x58]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 53       	eor	r3,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d8 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	77 68       	ld.w	r8,r11[0x58]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d8 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	77 68       	ld.w	r8,r11[0x58]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d8 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	77 68       	ld.w	r8,r11[0x58]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d8 70       	acall	0x87
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	77 68       	ld.w	r8,r11[0x58]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d8 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	77 68       	ld.w	r8,r11[0x58]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d8 a0       	acall	0x8a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d8 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d8 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d8 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	31 18       	mov	r8,17
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c0 41       	brne	800021aa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a4:	48 2c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x14>
800021a6:	f0 1f 00 03 	mcall	800021b0 <SingleDetection_brdcst_func+0x18>
800021aa:	d8 02       	popm	pc
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	d9 00       	acall	0x90
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	77 68       	ld.w	r8,r11[0x58]

800021b4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ba:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021bc:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xb4>
800021be:	f0 1f 00 2c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021c2:	0f 88       	ld.ub	r8,r7[0x0]
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	4a bc       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xbc>
800021c8:	f0 1f 00 29 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021cc:	1a d5       	st.w	--sp,r5
800021ce:	4a ac       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc0>
800021d0:	f0 1f 00 27 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d4:	0f a8       	ld.ub	r8,r7[0x2]
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	4a 8c       	lddpc	r12,80002278 <ButtonConfig_brdcst_func+0xc4>
800021da:	f0 1f 00 25 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021de:	2f dd       	sub	sp,-12
800021e0:	58 05       	cp.w	r5,0
800021e2:	c4 10       	breq	80002264 <ButtonConfig_brdcst_func+0xb0>
800021e4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e6:	4a 64       	lddpc	r4,8000227c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e8:	4a 63       	lddpc	r3,80002280 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ea:	4a 72       	lddpc	r2,80002284 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021ec:	4a 71       	lddpc	r1,80002288 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ee:	4a 80       	lddpc	r0,8000228c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021f0:	0f b9       	ld.ub	r9,r7[0x3]
800021f2:	0f c8       	ld.ub	r8,r7[0x4]
800021f4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f8:	1a d8       	st.w	--sp,r8
800021fa:	1a d6       	st.w	--sp,r6
800021fc:	08 9c       	mov	r12,r4
800021fe:	f0 1f 00 1c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002202:	0f d9       	ld.ub	r9,r7[0x5]
80002204:	0f e8       	ld.ub	r8,r7[0x6]
80002206:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000220a:	1a d8       	st.w	--sp,r8
8000220c:	1a d6       	st.w	--sp,r6
8000220e:	06 9c       	mov	r12,r3
80002210:	f0 1f 00 17 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002214:	0f f9       	ld.ub	r9,r7[0x7]
80002216:	ef 38 00 08 	ld.ub	r8,r7[8]
8000221a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221e:	1a d8       	st.w	--sp,r8
80002220:	1a d6       	st.w	--sp,r6
80002222:	04 9c       	mov	r12,r2
80002224:	f0 1f 00 12 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002228:	ef 39 00 09 	ld.ub	r9,r7[9]
8000222c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	02 9c       	mov	r12,r1
8000223a:	f0 1f 00 0d 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	2f 8d       	sub	sp,-32
80002240:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002244:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	00 9c       	mov	r12,r0
80002252:	f0 1f 00 07 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
80002256:	2f f6       	sub	r6,-1
80002258:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000225a:	2f ed       	sub	sp,-8
8000225c:	ec 05 18 00 	cp.b	r5,r6
80002260:	fe 9b ff c8 	brhi	800021f0 <ButtonConfig_brdcst_func+0x3c>
80002264:	d8 32       	popm	r0-r7,pc
80002266:	00 00       	add	r0,r0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d9 14       	*unknown*
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	77 68       	ld.w	r8,r11[0x58]
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d9 34       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d9 48       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d9 60       	acall	0x96
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d9 80       	acall	0x98
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d9 a8       	*unknown*
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d9 d0       	acall	0x9d
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	d9 f4       	*unknown*
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	da 1c       	*unknown*

80002290 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002290:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002294:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002298:	0f 89       	ld.ub	r9,r7[0x0]
8000229a:	30 08       	mov	r8,0
8000229c:	f0 09 18 00 	cp.b	r9,r8
800022a0:	c0 c1       	brne	800022b8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022a2:	48 9c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x34>
800022a4:	f0 1f 00 09 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a8:	0f 98       	ld.ub	r8,r7[0x1]
800022aa:	1a d8       	st.w	--sp,r8
800022ac:	48 8c       	lddpc	r12,800022cc <ButtonConfig_reply_func+0x3c>
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022b2:	2f fd       	sub	sp,-4
800022b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b8:	48 6c       	lddpc	r12,800022d0 <ButtonConfig_reply_func+0x40>
800022ba:	f0 1f 00 04 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022be:	e3 cd 80 80 	ldm	sp++,r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	da 40       	acall	0xa4
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	77 68       	ld.w	r8,r11[0x58]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d9 34       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	da 58       	*unknown*

800022d4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
800022d8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800022da:	19 a9       	ld.ub	r9,r12[0x2]
800022dc:	30 08       	mov	r8,0
800022de:	f0 09 18 00 	cp.b	r9,r8
800022e2:	c1 11       	brne	80002304 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800022e4:	49 3c       	lddpc	r12,80002330 <DataSession_reply_func+0x5c>
800022e6:	f0 1f 00 14 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800022ea:	0f b8       	ld.ub	r8,r7[0x3]
800022ec:	1a d8       	st.w	--sp,r8
800022ee:	49 3c       	lddpc	r12,80002338 <DataSession_reply_func+0x64>
800022f0:	f0 1f 00 11 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800022f4:	0f c8       	ld.ub	r8,r7[0x4]
800022f6:	1a d8       	st.w	--sp,r8
800022f8:	49 1c       	lddpc	r12,8000233c <DataSession_reply_func+0x68>
800022fa:	f0 1f 00 0f 	mcall	80002334 <DataSession_reply_func+0x60>
800022fe:	2f ed       	sub	sp,-8
80002300:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002304:	48 fc       	lddpc	r12,80002340 <DataSession_reply_func+0x6c>
80002306:	f0 1f 00 0c 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000230a:	0f a8       	ld.ub	r8,r7[0x2]
8000230c:	1a d8       	st.w	--sp,r8
8000230e:	48 ec       	lddpc	r12,80002344 <DataSession_reply_func+0x70>
80002310:	f0 1f 00 09 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002314:	0f b8       	ld.ub	r8,r7[0x3]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 cc       	lddpc	r12,80002348 <DataSession_reply_func+0x74>
8000231a:	f0 1f 00 07 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000231e:	0f c8       	ld.ub	r8,r7[0x4]
80002320:	1a d8       	st.w	--sp,r8
80002322:	48 bc       	lddpc	r12,8000234c <DataSession_reply_func+0x78>
80002324:	f0 1f 00 04 	mcall	80002334 <DataSession_reply_func+0x60>
80002328:	2f dd       	sub	sp,-12
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	da 74       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	77 68       	ld.w	r8,r11[0x58]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	da 84       	*unknown*
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	da 90       	acall	0xa9
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	da 9c       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	da ac       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	da bc       	*unknown*
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	da c8       	*unknown*

80002350 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002350:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002354:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 bc       	lddpc	r12,80002388 <CallControl_brdcst_func+0x38>
8000235e:	f0 1f 00 0c 	mcall	8000238c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002362:	2f fd       	sub	sp,-4
80002364:	0f 99       	ld.ub	r9,r7[0x1]
80002366:	30 38       	mov	r8,3
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 41       	brne	80002374 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000236e:	30 09       	mov	r9,0
80002370:	48 88       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002372:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002374:	0f 99       	ld.ub	r9,r7[0x1]
80002376:	30 48       	mov	r8,4
80002378:	f0 09 18 00 	cp.b	r9,r8
8000237c:	c0 41       	brne	80002384 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000237e:	30 19       	mov	r9,1
80002380:	48 48       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002382:	b0 89       	st.b	r8[0x0],r9
80002384:	e3 cd 80 80 	ldm	sp++,r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	da d4       	*unknown*
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	77 68       	ld.w	r8,r11[0x58]
80002390:	00 00       	add	r0,r0
80002392:	0a 55       	eor	r5,r5

80002394 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002394:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002398:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 08       	mov	r8,0
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 71       	brne	800023b2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023a6:	48 ac       	lddpc	r12,800023cc <TransmitControl_brdcst_func+0x38>
800023a8:	f0 1f 00 0a 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023ac:	30 09       	mov	r9,0
800023ae:	48 a8       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023b0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023b2:	0f 99       	ld.ub	r9,r7[0x1]
800023b4:	30 18       	mov	r8,1
800023b6:	f0 09 18 00 	cp.b	r9,r8
800023ba:	c0 71       	brne	800023c8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023bc:	48 7c       	lddpc	r12,800023d8 <TransmitControl_brdcst_func+0x44>
800023be:	f0 1f 00 05 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023c2:	30 19       	mov	r9,1
800023c4:	48 48       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023c6:	b0 89       	st.b	r8[0x0],r9
800023c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	da ec       	*unknown*
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	77 68       	ld.w	r8,r11[0x58]
800023d4:	00 00       	add	r0,r0
800023d6:	0a 54       	eor	r4,r5
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	db 04       	*unknown*

800023dc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800023e4:	0f 89       	ld.ub	r9,r7[0x0]
800023e6:	30 08       	mov	r8,0
800023e8:	f0 09 18 00 	cp.b	r9,r8
800023ec:	c1 61       	brne	80002418 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800023ee:	48 ec       	lddpc	r12,80002424 <TransmitControl_reply_func+0x48>
800023f0:	f0 1f 00 0e 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 dc       	lddpc	r12,8000242c <TransmitControl_reply_func+0x50>
800023fa:	f0 1f 00 0c 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800023fe:	0f a8       	ld.ub	r8,r7[0x2]
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 cc       	lddpc	r12,80002430 <TransmitControl_reply_func+0x54>
80002404:	f0 1f 00 09 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002408:	0f b8       	ld.ub	r8,r7[0x3]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	48 ac       	lddpc	r12,80002434 <TransmitControl_reply_func+0x58>
8000240e:	f0 1f 00 07 	mcall	80002428 <TransmitControl_reply_func+0x4c>
80002412:	2f dd       	sub	sp,-12
80002414:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002418:	48 8c       	lddpc	r12,80002438 <TransmitControl_reply_func+0x5c>
8000241a:	f0 1f 00 04 	mcall	80002428 <TransmitControl_reply_func+0x4c>
8000241e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002422:	00 00       	add	r0,r0
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	db 18       	*unknown*
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	77 68       	ld.w	r8,r11[0x58]
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	db 34       	*unknown*
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	db 48       	*unknown*
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	db 64       	*unknown*
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	db 74       	*unknown*

8000243c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000243c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a9       	ld.ub	r9,r12[0x2]
80002440:	30 08       	mov	r8,0
80002442:	f0 09 18 00 	cp.b	r9,r8
80002446:	c0 51       	brne	80002450 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002448:	48 4c       	lddpc	r12,80002458 <AudioRoutingControl_reply_func+0x1c>
8000244a:	f0 1f 00 05 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
8000244e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002450:	48 4c       	lddpc	r12,80002460 <AudioRoutingControl_reply_func+0x24>
80002452:	f0 1f 00 03 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
80002456:	d8 02       	popm	pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	db 8c       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	77 68       	ld.w	r8,r11[0x58]
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	db 9c       	*unknown*

80002464 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 b1       	brne	800024aa <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002476:	0f b8       	ld.ub	r8,r7[0x3]
80002478:	31 09       	mov	r9,16
8000247a:	f2 08 18 00 	cp.b	r8,r9
8000247e:	c0 f1       	brne	8000249c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002480:	48 dc       	lddpc	r12,800024b4 <Volume_reply_func+0x50>
80002482:	f0 1f 00 0e 	mcall	800024b8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002486:	0f 99       	ld.ub	r9,r7[0x1]
80002488:	0f a8       	ld.ub	r8,r7[0x2]
8000248a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <Volume_reply_func+0x58>
80002492:	f0 1f 00 0a 	mcall	800024b8 <Volume_reply_func+0x54>
80002496:	2f fd       	sub	sp,-4
80002498:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 9c       	lddpc	r12,800024c0 <Volume_reply_func+0x5c>
800024a0:	f0 1f 00 06 	mcall	800024b8 <Volume_reply_func+0x54>
800024a4:	2f fd       	sub	sp,-4
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024aa:	48 7c       	lddpc	r12,800024c4 <Volume_reply_func+0x60>
800024ac:	f0 1f 00 03 	mcall	800024b8 <Volume_reply_func+0x54>
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	db b0       	acall	0xbb
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	77 68       	ld.w	r8,r11[0x58]
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	db c4       	*unknown*
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	db e0       	acall	0xbe
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	db f8       	*unknown*

800024c8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024ca:	19 d9       	ld.ub	r9,r12[0x5]
800024cc:	30 08       	mov	r8,0
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 81       	brne	800024e2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024d4:	10 99       	mov	r9,r8
800024d6:	48 78       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024d8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024da:	48 7c       	lddpc	r12,800024f4 <spk_brdcst_func+0x2c>
800024dc:	f0 1f 00 07 	mcall	800024f8 <spk_brdcst_func+0x30>
800024e0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024e2:	30 19       	mov	r9,1
800024e4:	48 38       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024e6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800024e8:	48 5c       	lddpc	r12,800024fc <spk_brdcst_func+0x34>
800024ea:	f0 1f 00 04 	mcall	800024f8 <spk_brdcst_func+0x30>
800024ee:	d8 02       	popm	pc
800024f0:	00 00       	add	r0,r0
800024f2:	0a 50       	eor	r0,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	dc 10       	acall	0xc1
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	77 68       	ld.w	r8,r11[0x58]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	dc 20       	acall	0xc2

80002500 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002502:	19 a9       	ld.ub	r9,r12[0x2]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 f1       	brne	80002528 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000250c:	19 e9       	ld.ub	r9,r12[0x6]
8000250e:	f0 09 18 00 	cp.b	r9,r8
80002512:	c0 40       	breq	8000251a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002514:	30 19       	mov	r9,1
80002516:	48 98       	lddpc	r8,80002538 <spk_reply_func+0x38>
80002518:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000251a:	19 e8       	ld.ub	r8,r12[0x6]
8000251c:	1a d8       	st.w	--sp,r8
8000251e:	48 8c       	lddpc	r12,8000253c <spk_reply_func+0x3c>
80002520:	f0 1f 00 08 	mcall	80002540 <spk_reply_func+0x40>
80002524:	2f fd       	sub	sp,-4
80002526:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002528:	30 09       	mov	r9,0
8000252a:	48 48       	lddpc	r8,80002538 <spk_reply_func+0x38>
8000252c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000252e:	48 6c       	lddpc	r12,80002544 <spk_reply_func+0x44>
80002530:	f0 1f 00 04 	mcall	80002540 <spk_reply_func+0x40>
80002534:	d8 02       	popm	pc
80002536:	00 00       	add	r0,r0
80002538:	00 00       	add	r0,r0
8000253a:	0a 50       	eor	r0,r5
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	dc 2c       	*unknown*
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	77 68       	ld.w	r8,r11[0x58]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	dc 3c       	*unknown*

80002548 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002550:	0f a9       	ld.ub	r9,r7[0x2]
80002552:	30 08       	mov	r8,0
80002554:	f0 09 18 00 	cp.b	r9,r8
80002558:	c0 71       	brne	80002566 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000255a:	48 dc       	lddpc	r12,8000258c <mic_brdcst_func+0x44>
8000255c:	f0 1f 00 0d 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 d8       	lddpc	r8,80002594 <mic_brdcst_func+0x4c>
80002564:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002566:	0f a9       	ld.ub	r9,r7[0x2]
80002568:	31 18       	mov	r8,17
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 d1       	brne	80002588 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002570:	48 ac       	lddpc	r12,80002598 <mic_brdcst_func+0x50>
80002572:	f0 1f 00 08 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002576:	48 89       	lddpc	r9,80002594 <mic_brdcst_func+0x4c>
80002578:	30 18       	mov	r8,1
8000257a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000257c:	13 89       	ld.ub	r9,r9[0x0]
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 31       	brne	80002588 <mic_brdcst_func+0x40>
80002584:	48 68       	lddpc	r8,8000259c <mic_brdcst_func+0x54>
80002586:	11 88       	ld.ub	r8,r8[0x0]
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	dc 48       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	77 68       	ld.w	r8,r11[0x58]
80002594:	00 00       	add	r0,r0
80002596:	0a 5d       	eor	sp,r5
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	dc 5c       	*unknown*
8000259c:	00 00       	add	r0,r0
8000259e:	0a 55       	eor	r5,r5

800025a0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025a8:	49 ac       	lddpc	r12,80002610 <mic_reply_func+0x70>
800025aa:	f0 1f 00 1b 	mcall	80002614 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ae:	0f 89       	ld.ub	r9,r7[0x0]
800025b0:	30 08       	mov	r8,0
800025b2:	f0 09 18 00 	cp.b	r9,r8
800025b6:	c2 71       	brne	80002604 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025b8:	0f 98       	ld.ub	r8,r7[0x1]
800025ba:	30 29       	mov	r9,2
800025bc:	f2 08 18 00 	cp.b	r8,r9
800025c0:	c1 b1       	brne	800025f6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025c2:	49 6c       	lddpc	r12,80002618 <mic_reply_func+0x78>
800025c4:	f0 1f 00 14 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	49 4c       	lddpc	r12,8000261c <mic_reply_func+0x7c>
800025ce:	f0 1f 00 12 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025d2:	0f b8       	ld.ub	r8,r7[0x3]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	49 3c       	lddpc	r12,80002620 <mic_reply_func+0x80>
800025d8:	f0 1f 00 0f 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025dc:	0f c8       	ld.ub	r8,r7[0x4]
800025de:	1a d8       	st.w	--sp,r8
800025e0:	49 1c       	lddpc	r12,80002624 <mic_reply_func+0x84>
800025e2:	f0 1f 00 0d 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800025e6:	0f d8       	ld.ub	r8,r7[0x5]
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	49 0c       	lddpc	r12,80002628 <mic_reply_func+0x88>
800025ec:	f0 1f 00 0a 	mcall	80002614 <mic_reply_func+0x74>
800025f0:	2f cd       	sub	sp,-16
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	48 dc       	lddpc	r12,8000262c <mic_reply_func+0x8c>
800025fa:	f0 1f 00 07 	mcall	80002614 <mic_reply_func+0x74>
800025fe:	2f fd       	sub	sp,-4
80002600:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002604:	48 bc       	lddpc	r12,80002630 <mic_reply_func+0x90>
80002606:	f0 1f 00 04 	mcall	80002614 <mic_reply_func+0x74>
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	dc 70       	acall	0xc7
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	77 68       	ld.w	r8,r11[0x58]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	dc 80       	acall	0xc8
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	dc 94       	*unknown*
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	dc a8       	*unknown*
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	dc c4       	*unknown*
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	dc dc       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	dc f4       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	dd 0c       	*unknown*

80002634 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002634:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002638:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000263c:	48 bc       	lddpc	r12,80002668 <dcm_brdcst_func+0x34>
8000263e:	f0 1f 00 0c 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002642:	0f 88       	ld.ub	r8,r7[0x0]
80002644:	1a d8       	st.w	--sp,r8
80002646:	48 bc       	lddpc	r12,80002670 <dcm_brdcst_func+0x3c>
80002648:	f0 1f 00 09 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000264c:	0f a8       	ld.ub	r8,r7[0x2]
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 9c       	lddpc	r12,80002674 <dcm_brdcst_func+0x40>
80002652:	f0 1f 00 07 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002656:	0f 98       	ld.ub	r8,r7[0x1]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <dcm_brdcst_func+0x44>
8000265c:	f0 1f 00 04 	mcall	8000266c <dcm_brdcst_func+0x38>
80002660:	2f dd       	sub	sp,-12
	
	
}
80002662:	e3 cd 80 80 	ldm	sp++,r7,pc
80002666:	00 00       	add	r0,r0
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	dd 1c       	*unknown*
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	77 68       	ld.w	r8,r11[0x58]
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	dd 30       	acall	0xd3
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	dd 44       	*unknown*
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	dd 5c       	*unknown*

8000267c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000267c:	eb cd 40 80 	pushm	r7,lr
80002680:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002682:	19 a9       	ld.ub	r9,r12[0x2]
80002684:	30 08       	mov	r8,0
80002686:	f0 09 18 00 	cp.b	r9,r8
8000268a:	c1 b1       	brne	800026c0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000268c:	19 b8       	ld.ub	r8,r12[0x3]
8000268e:	30 19       	mov	r9,1
80002690:	f2 08 18 00 	cp.b	r8,r9
80002694:	c0 51       	brne	8000269e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002696:	48 ec       	lddpc	r12,800026cc <dcm_reply_func+0x50>
80002698:	f0 1f 00 0e 	mcall	800026d0 <dcm_reply_func+0x54>
8000269c:	c0 a8       	rjmp	800026b0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000269e:	58 08       	cp.w	r8,0
800026a0:	c0 51       	brne	800026aa <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026a2:	48 dc       	lddpc	r12,800026d4 <dcm_reply_func+0x58>
800026a4:	f0 1f 00 0b 	mcall	800026d0 <dcm_reply_func+0x54>
800026a8:	c0 48       	rjmp	800026b0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026aa:	48 cc       	lddpc	r12,800026d8 <dcm_reply_func+0x5c>
800026ac:	f0 1f 00 09 	mcall	800026d0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026b0:	0f d8       	ld.ub	r8,r7[0x5]
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	48 ac       	lddpc	r12,800026dc <dcm_reply_func+0x60>
800026b6:	f0 1f 00 07 	mcall	800026d0 <dcm_reply_func+0x54>
800026ba:	2f fd       	sub	sp,-4
800026bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026c0:	48 8c       	lddpc	r12,800026e0 <dcm_reply_func+0x64>
800026c2:	f0 1f 00 04 	mcall	800026d0 <dcm_reply_func+0x54>
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ca:	00 00       	add	r0,r0
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	dd 78       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	77 68       	ld.w	r8,r11[0x58]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	dd 8c       	*unknown*
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	dd a0       	acall	0xda
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	dd b4       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	dd c0       	acall	0xdc

800026e4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800026e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026e6:	19 a9       	ld.ub	r9,r12[0x2]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c0 51       	brne	800026f8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800026f0:	48 4c       	lddpc	r12,80002700 <ToneControl_reply_func+0x1c>
800026f2:	f0 1f 00 05 	mcall	80002704 <ToneControl_reply_func+0x20>
800026f6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800026f8:	48 4c       	lddpc	r12,80002708 <ToneControl_reply_func+0x24>
800026fa:	f0 1f 00 03 	mcall	80002704 <ToneControl_reply_func+0x20>
800026fe:	d8 02       	popm	pc
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	dd cc       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	77 68       	ld.w	r8,r11[0x58]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	dd d8       	*unknown*

8000270c <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;
extern volatile DateTime_t Current_time;
static __app_Thread_(app_cfg)
{
8000270c:	d4 31       	pushm	r0-r7,lr
8000270e:	20 1d       	sub	sp,4
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	
	 xLastWakeTime = xTaskGetTickCount();
80002710:	f0 1f 00 21 	mcall	80002794 <app_cfg+0x88>
80002714:	4a 18       	lddpc	r8,80002798 <app_cfg+0x8c>
80002716:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002718:	4a 16       	lddpc	r6,8000279c <app_cfg+0x90>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000271a:	4a 25       	lddpc	r5,800027a0 <app_cfg+0x94>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000271c:	30 63       	mov	r3,6
8000271e:	30 14       	mov	r4,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002720:	4a 12       	lddpc	r2,800027a4 <app_cfg+0x98>
80002722:	30 00       	mov	r0,0
80002724:	e0 67 0f a0 	mov	r7,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002728:	6c 08       	ld.w	r8,r6[0x0]
8000272a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000272e:	58 38       	cp.w	r8,3
80002730:	c0 b1       	brne	80002746 <app_cfg+0x3a>
80002732:	0b 88       	ld.ub	r8,r5[0x0]
80002734:	58 08       	cp.w	r8,0
80002736:	c0 81       	brne	80002746 <app_cfg+0x3a>
		{	
			connect_flag=1;	
80002738:	30 18       	mov	r8,1
8000273a:	aa 88       	st.b	r5[0x0],r8
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000273c:	30 cb       	mov	r11,12
8000273e:	08 9c       	mov	r12,r4
80002740:	f0 1f 00 1a 	mcall	800027a8 <app_cfg+0x9c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002744:	c2 28       	rjmp	80002788 <app_cfg+0x7c>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
80002746:	0b 88       	ld.ub	r8,r5[0x0]
80002748:	58 08       	cp.w	r8,0
8000274a:	c1 80       	breq	8000277a <app_cfg+0x6e>
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
8000274c:	64 0c       	ld.w	r12,r2[0x0]
8000274e:	00 99       	mov	r9,r0
80002750:	0e 9a       	mov	r10,r7
80002752:	1a 9b       	mov	r11,sp
80002754:	f0 1f 00 16 	mcall	800027ac <app_cfg+0xa0>
80002758:	58 1c       	cp.w	r12,1
8000275a:	c0 e1       	brne	80002776 <app_cfg+0x6a>
				{
					
					xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
8000275c:	08 9a       	mov	r10,r4
8000275e:	32 0b       	mov	r11,32
80002760:	40 0c       	lddsp	r12,sp[0x0]
80002762:	f0 1f 00 14 	mcall	800027b0 <app_cfg+0xa4>
					set_message_store(data_ptr);
80002766:	49 48       	lddpc	r8,800027b4 <app_cfg+0xa8>
80002768:	70 0c       	ld.w	r12,r8[0x0]
8000276a:	40 0b       	lddsp	r11,sp[0x0]
8000276c:	f0 1f 00 13 	mcall	800027b8 <app_cfg+0xac>
					log("receive okay!\n");			
80002770:	49 3c       	lddpc	r12,800027bc <app_cfg+0xb0>
80002772:	f0 1f 00 14 	mcall	800027c0 <app_cfg+0xb4>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80002776:	d7 03       	nop
80002778:	c0 88       	rjmp	80002788 <app_cfg+0x7c>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
8000277a:	d7 03       	nop
			nop();
8000277c:	d7 03       	nop
			nop();
8000277e:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
80002780:	06 9b       	mov	r11,r3
80002782:	08 9c       	mov	r12,r4
80002784:	f0 1f 00 09 	mcall	800027a8 <app_cfg+0x9c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002788:	0e 9b       	mov	r11,r7
8000278a:	48 4c       	lddpc	r12,80002798 <app_cfg+0x8c>
8000278c:	f0 1f 00 0e 	mcall	800027c4 <app_cfg+0xb8>
	}
80002790:	cc cb       	rjmp	80002728 <app_cfg+0x1c>
80002792:	00 00       	add	r0,r0
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	70 94       	ld.w	r4,r8[0x24]
80002798:	00 00       	add	r0,r0
8000279a:	0a 58       	eor	r8,r5
8000279c:	00 00       	add	r0,r0
8000279e:	0d fc       	ld.ub	r12,r6[0x7]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 5c       	eor	r12,r5
800027a4:	00 00       	add	r0,r0
800027a6:	0b 6c       	ld.uh	r12,--r5
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	40 d0       	lddsp	r0,sp[0x34]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	69 24       	ld.w	r4,r4[0x48]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	55 ec       	stdsp	sp[0x178],r12
800027b4:	00 00       	add	r0,r0
800027b6:	0b 7c       	ld.ub	r12,--r5
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	2c 1c       	sub	r12,-63
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	dd e4       	*unknown*
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	77 68       	ld.w	r8,r11[0x58]
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	72 44       	ld.w	r4,r9[0x10]

800027c8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800027c8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800027cc:	19 c7       	ld.ub	r7,r12[0x4]
800027ce:	19 d8       	ld.ub	r8,r12[0x5]
800027d0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800027d4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800027d6:	48 dc       	lddpc	r12,80002808 <Phyuserinput_brdcst_func+0x40>
800027d8:	f0 1f 00 0d 	mcall	8000280c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800027dc:	36 08       	mov	r8,96
800027de:	f0 07 19 00 	cp.h	r7,r8
800027e2:	c1 11       	brne	80002804 <Phyuserinput_brdcst_func+0x3c>
800027e4:	48 b8       	lddpc	r8,80002810 <Phyuserinput_brdcst_func+0x48>
800027e6:	11 89       	ld.ub	r9,r8[0x0]
800027e8:	30 18       	mov	r8,1
800027ea:	f0 09 18 00 	cp.b	r9,r8
800027ee:	c0 b1       	brne	80002804 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800027f0:	31 4b       	mov	r11,20
800027f2:	30 1c       	mov	r12,1
800027f4:	f0 1f 00 08 	mcall	80002814 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800027f8:	e0 6c 03 20 	mov	r12,800
800027fc:	f0 1f 00 07 	mcall	80002818 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002800:	f0 1f 00 07 	mcall	8000281c <Phyuserinput_brdcst_func+0x54>
80002804:	e3 cd 80 80 	ldm	sp++,r7,pc
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	dd f4       	*unknown*
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	77 68       	ld.w	r8,r11[0x58]
80002810:	00 00       	add	r0,r0
80002812:	0a 5c       	eor	r12,r5
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	40 d0       	lddsp	r0,sp[0x34]
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	71 fc       	ld.w	r12,r8[0x7c]
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	50 a4       	stdsp	sp[0x28],r4

80002820 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002820:	d4 31       	pushm	r0-r7,lr
80002822:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002824:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002828:	0d 88       	ld.ub	r8,r6[0x0]
8000282a:	32 49       	mov	r9,36
8000282c:	f2 08 18 00 	cp.b	r8,r9
80002830:	c2 91       	brne	80002882 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002832:	4c 4c       	lddpc	r12,80002940 <DataSession_brdcst_func+0x120>
80002834:	f0 1f 00 44 	mcall	80002944 <DataSession_brdcst_func+0x124>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002838:	0d a5       	ld.ub	r5,r6[0x2]
8000283a:	0d b8       	ld.ub	r8,r6[0x3]
8000283c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002840:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002842:	0d 98       	ld.ub	r8,r6[0x1]
80002844:	1a d8       	st.w	--sp,r8
80002846:	4c 1c       	lddpc	r12,80002948 <DataSession_brdcst_func+0x128>
80002848:	f0 1f 00 3f 	mcall	80002944 <DataSession_brdcst_func+0x124>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000284c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002850:	1a d8       	st.w	--sp,r8
80002852:	4b fc       	lddpc	r12,8000294c <DataSession_brdcst_func+0x12c>
80002854:	f0 1f 00 3c 	mcall	80002944 <DataSession_brdcst_func+0x124>
		for(i=0; i<data_length; i++)
80002858:	2f ed       	sub	sp,-8
8000285a:	58 05       	cp.w	r5,0
8000285c:	c7 00       	breq	8000293c <DataSession_brdcst_func+0x11c>
8000285e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002860:	4b c4       	lddpc	r4,80002950 <DataSession_brdcst_func+0x130>
80002862:	ec 07 00 08 	add	r8,r6,r7
80002866:	11 c8       	ld.ub	r8,r8[0x4]
80002868:	1a d8       	st.w	--sp,r8
8000286a:	1a d7       	st.w	--sp,r7
8000286c:	08 9c       	mov	r12,r4
8000286e:	f0 1f 00 36 	mcall	80002944 <DataSession_brdcst_func+0x124>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002872:	2f f7       	sub	r7,-1
80002874:	5c 57       	castu.b	r7
80002876:	2f ed       	sub	sp,-8
80002878:	ee 05 19 00 	cp.h	r5,r7
8000287c:	fe 9b ff f3 	brhi	80002862 <DataSession_brdcst_func+0x42>
80002880:	c5 e8       	rjmp	8000293c <DataSession_brdcst_func+0x11c>
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002882:	0d a7       	ld.ub	r7,r6[0x2]
80002884:	0d b5       	ld.ub	r5,r6[0x3]
		log("State: %X \n", ptr->State);
80002886:	1a d8       	st.w	--sp,r8
80002888:	4b 3c       	lddpc	r12,80002954 <DataSession_brdcst_func+0x134>
8000288a:	f0 1f 00 2f 	mcall	80002944 <DataSession_brdcst_func+0x124>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000288e:	0d 88       	ld.ub	r8,r6[0x0]
80002890:	2f fd       	sub	sp,-4
80002892:	30 39       	mov	r9,3
80002894:	f2 08 18 00 	cp.b	r8,r9
80002898:	c0 51       	brne	800028a2 <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
8000289a:	4b 0c       	lddpc	r12,80002958 <DataSession_brdcst_func+0x138>
8000289c:	f0 1f 00 2a 	mcall	80002944 <DataSession_brdcst_func+0x124>
800028a0:	c4 78       	rjmp	8000292e <DataSession_brdcst_func+0x10e>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800028a2:	30 49       	mov	r9,4
800028a4:	f2 08 18 00 	cp.b	r8,r9
800028a8:	c4 31       	brne	8000292e <DataSession_brdcst_func+0x10e>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800028aa:	32 0a       	mov	r10,32
800028ac:	ec cb ff fc 	sub	r11,r6,-4
800028b0:	1a 9c       	mov	r12,sp
800028b2:	f0 1f 00 2b 	mcall	8000295c <DataSession_brdcst_func+0x13c>
800028b6:	fb 36 00 1f 	ld.ub	r6,sp[31]
800028ba:	fb 34 00 1e 	ld.ub	r4,sp[30]
800028be:	fb 33 00 1d 	ld.ub	r3,sp[29]
800028c2:	fb 32 00 1c 	ld.ub	r2,sp[28]
800028c6:	fb 31 00 1b 	ld.ub	r1,sp[27]
800028ca:	fb 30 00 1a 	ld.ub	r0,sp[26]
			log("data transmit failure\n");
800028ce:	4a 5c       	lddpc	r12,80002960 <DataSession_brdcst_func+0x140>
800028d0:	f0 1f 00 1d 	mcall	80002944 <DataSession_brdcst_func+0x124>
			log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800028d4:	1a d6       	st.w	--sp,r6
800028d6:	1a d4       	st.w	--sp,r4
800028d8:	1a d3       	st.w	--sp,r3
800028da:	1a d2       	st.w	--sp,r2
800028dc:	1a d1       	st.w	--sp,r1
800028de:	1a d0       	st.w	--sp,r0
800028e0:	4a 1c       	lddpc	r12,80002964 <DataSession_brdcst_func+0x144>
800028e2:	f0 1f 00 19 	mcall	80002944 <DataSession_brdcst_func+0x124>
			xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
800028e6:	4a 18       	lddpc	r8,80002968 <DataSession_brdcst_func+0x148>
800028e8:	70 0c       	ld.w	r12,r8[0x0]
800028ea:	f0 1f 00 21 	mcall	8000296c <DataSession_brdcst_func+0x14c>
800028ee:	50 ec       	stdsp	sp[0x38],r12
			if(NULL != myptr)
800028f0:	2f ad       	sub	sp,-24
800028f2:	58 0c       	cp.w	r12,0
800028f4:	c1 a0       	breq	80002928 <DataSession_brdcst_func+0x108>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800028f6:	fb 66 00 1f 	st.b	sp[31],r6
800028fa:	fb 64 00 1e 	st.b	sp[30],r4
800028fe:	fb 63 00 1d 	st.b	sp[29],r3
80002902:	fb 62 00 1c 	st.b	sp[28],r2
80002906:	fb 61 00 1b 	st.b	sp[27],r1
8000290a:	fb 60 00 1a 	st.b	sp[26],r0
8000290e:	32 0a       	mov	r10,32
80002910:	1a 9b       	mov	r11,sp
80002912:	f0 1f 00 13 	mcall	8000295c <DataSession_brdcst_func+0x13c>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002916:	49 78       	lddpc	r8,80002970 <DataSession_brdcst_func+0x150>
80002918:	70 0c       	ld.w	r12,r8[0x0]
8000291a:	30 09       	mov	r9,0
8000291c:	12 9a       	mov	r10,r9
8000291e:	fa cb ff e0 	sub	r11,sp,-32
80002922:	f0 1f 00 15 	mcall	80002974 <DataSession_brdcst_func+0x154>
80002926:	c0 48       	rjmp	8000292e <DataSession_brdcst_func+0x10e>
			}
			else
			{
				log("myptr: err\n\r" );
80002928:	49 4c       	lddpc	r12,80002978 <DataSession_brdcst_func+0x158>
8000292a:	f0 1f 00 07 	mcall	80002944 <DataSession_brdcst_func+0x124>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		//log("Session_ID: %x \n\r",Session_number );
		log("paylaod_length: %d \n\r",data_length );
8000292e:	eb e7 10 87 	or	r7,r5,r7<<0x8
80002932:	1a d7       	st.w	--sp,r7
80002934:	49 2c       	lddpc	r12,8000297c <DataSession_brdcst_func+0x15c>
80002936:	f0 1f 00 04 	mcall	80002944 <DataSession_brdcst_func+0x124>
8000293a:	2f fd       	sub	sp,-4
				//
		//}
		
	}
	
}
8000293c:	2f 7d       	sub	sp,-36
8000293e:	d8 32       	popm	r0-r7,pc
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	de 14       	*unknown*
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	77 68       	ld.w	r8,r11[0x58]
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	de 28       	*unknown*
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	de 40       	acall	0xe4
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	de 5c       	*unknown*
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	de 74       	*unknown*
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	de 80       	acall	0xe8
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	80 16       	ld.sh	r6,r0[0x2]
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	de 98       	*unknown*
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	de b0       	acall	0xeb
80002968:	00 00       	add	r0,r0
8000296a:	0b 7c       	ld.ub	r12,--r5
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	2d c8       	sub	r8,-36
80002970:	00 00       	add	r0,r0
80002972:	0b 6c       	ld.uh	r12,--r5
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	6b 30       	ld.w	r0,r5[0x4c]
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	de e4       	*unknown*
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	de f4       	*unknown*

80002980 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002980:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002982:	19 e8       	ld.ub	r8,r12[0x6]
80002984:	30 19       	mov	r9,1
80002986:	f2 08 18 00 	cp.b	r8,r9
8000298a:	c0 61       	brne	80002996 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000298c:	48 98       	lddpc	r8,800029b0 <DeviceInitializationStatus_brdcst_func+0x30>
8000298e:	70 09       	ld.w	r9,r8[0x0]
80002990:	a1 a9       	sbr	r9,0x0
80002992:	91 09       	st.w	r8[0x0],r9
80002994:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002996:	30 29       	mov	r9,2
80002998:	f2 08 18 00 	cp.b	r8,r9
8000299c:	c0 80       	breq	800029ac <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000299e:	48 58       	lddpc	r8,800029b0 <DeviceInitializationStatus_brdcst_func+0x30>
800029a0:	70 09       	ld.w	r9,r8[0x0]
800029a2:	e0 19 ff fc 	andl	r9,0xfffc
800029a6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029a8:	f0 1f 00 03 	mcall	800029b4 <DeviceInitializationStatus_brdcst_func+0x34>
800029ac:	d8 02       	popm	pc
800029ae:	00 00       	add	r0,r0
800029b0:	00 00       	add	r0,r0
800029b2:	0d fc       	ld.ub	r12,r6[0x7]
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	40 24       	lddsp	r4,sp[0x8]

800029b8 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800029b8:	d4 01       	pushm	lr
	//{
		//return 3;
	//}
	  	
	  // Disable all interrupts. */
	  Disable_global_interrupt();
800029ba:	d3 03       	ssrf	0x10
	  
	  // Register the RTC interrupt handler to the interrupt controller.
	  INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800029bc:	30 0a       	mov	r10,0
800029be:	32 8b       	mov	r11,40
800029c0:	49 5c       	lddpc	r12,80002a14 <xg_rtc_init+0x5c>
800029c2:	f0 1f 00 16 	mcall	80002a18 <xg_rtc_init+0x60>

	  // Initialize the RTC
	  if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
800029c6:	30 fa       	mov	r10,15
800029c8:	30 0b       	mov	r11,0
800029ca:	fe 7c 0d 00 	mov	r12,-62208
800029ce:	f0 1f 00 14 	mcall	80002a1c <xg_rtc_init+0x64>
800029d2:	c0 41       	brne	800029da <xg_rtc_init+0x22>
	  //if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	  {
		  log("Error initializing the RTC\r\n");
800029d4:	49 3c       	lddpc	r12,80002a20 <xg_rtc_init+0x68>
800029d6:	f0 1f 00 14 	mcall	80002a24 <xg_rtc_init+0x6c>
	  }
	  // Set top value to 0 to generate an interrupt every seconds */
	  rtc_set_top_value(&AVR32_RTC, 0);
800029da:	30 0b       	mov	r11,0
800029dc:	fe 7c 0d 00 	mov	r12,-62208
800029e0:	f0 1f 00 12 	mcall	80002a28 <xg_rtc_init+0x70>
	  // Enable the interrupts
	  rtc_enable_interrupt(&AVR32_RTC);
800029e4:	fe 7c 0d 00 	mov	r12,-62208
800029e8:	f0 1f 00 11 	mcall	80002a2c <xg_rtc_init+0x74>
	  // Enable the RTC
	  rtc_enable(&AVR32_RTC);
800029ec:	fe 7c 0d 00 	mov	r12,-62208
800029f0:	f0 1f 00 10 	mcall	80002a30 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800029f4:	49 08       	lddpc	r8,80002a34 <xg_rtc_init+0x7c>
800029f6:	31 09       	mov	r9,16
800029f8:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800029fa:	30 29       	mov	r9,2
800029fc:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
800029fe:	31 d9       	mov	r9,29
80002a00:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a02:	31 79       	mov	r9,23
80002a04:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a06:	33 b9       	mov	r9,59
80002a08:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a0a:	32 89       	mov	r9,40
80002a0c:	b0 d9       	st.b	r8[0x5],r9
	/*finished accessing the shared resource.Release the semaphore.*/
	//xSemaphoreGive(rtc_mutex);
	
	//sec = Current_time.Second;
	// Enable global interrupts
	Enable_global_interrupt();
80002a0e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a10:	d8 02       	popm	pc
80002a12:	00 00       	add	r0,r0
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	2a 38       	sub	r8,-93
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	5d 20       	mustr	r0
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	5f 1c       	srne	r12
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	df 0c       	*unknown*
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	77 68       	ld.w	r8,r11[0x58]
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	5e d8       	retvc	r8
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	5e d0       	retvc	r0
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	5e ac       	retle	r12
80002a34:	00 00       	add	r0,r0
80002a36:	0e 00       	add	r0,r7

80002a38 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a38:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a3a:	4b 98       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002a3c:	11 d9       	ld.ub	r9,r8[0x5]
80002a3e:	2f f9       	sub	r9,-1
80002a40:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a42:	11 d9       	ld.ub	r9,r8[0x5]
80002a44:	33 b8       	mov	r8,59
80002a46:	f0 09 18 00 	cp.b	r9,r8
80002a4a:	e0 88 00 5f 	brls	80002b08 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a4e:	4b 48       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002a50:	30 09       	mov	r9,0
80002a52:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a54:	11 c9       	ld.ub	r9,r8[0x4]
80002a56:	2f f9       	sub	r9,-1
80002a58:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002a5a:	11 c9       	ld.ub	r9,r8[0x4]
80002a5c:	33 b8       	mov	r8,59
80002a5e:	f0 09 18 00 	cp.b	r9,r8
80002a62:	e0 88 00 53 	brls	80002b08 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002a66:	4a e8       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002a68:	30 09       	mov	r9,0
80002a6a:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002a6c:	11 b9       	ld.ub	r9,r8[0x3]
80002a6e:	2f f9       	sub	r9,-1
80002a70:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002a72:	11 b9       	ld.ub	r9,r8[0x3]
80002a74:	31 78       	mov	r8,23
80002a76:	f0 09 18 00 	cp.b	r9,r8
80002a7a:	e0 88 00 47 	brls	80002b08 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002a7e:	4a 88       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002a80:	30 09       	mov	r9,0
80002a82:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002a84:	11 88       	ld.ub	r8,r8[0x0]
80002a86:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002a8a:	e0 69 01 6e 	mov	r9,366
80002a8e:	e0 6a 01 6d 	mov	r10,365
80002a92:	f4 08 17 10 	movne	r8,r10
80002a96:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002a9a:	4a 19       	lddpc	r9,80002b1c <rtc_irq+0xe4>
80002a9c:	13 9a       	ld.ub	r10,r9[0x1]
80002a9e:	30 29       	mov	r9,2
80002aa0:	f2 0a 18 00 	cp.b	r10,r9
80002aa4:	c0 b0       	breq	80002aba <rtc_irq+0x82>
80002aa6:	49 e8       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002aa8:	11 99       	ld.ub	r9,r8[0x1]
80002aaa:	11 9a       	ld.ub	r10,r8[0x1]
80002aac:	a3 9a       	lsr	r10,0x3
80002aae:	12 0a       	add	r10,r9
80002ab0:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002ab4:	2e 2a       	sub	r10,-30
80002ab6:	5c 5a       	castu.b	r10
80002ab8:	c0 58       	rjmp	80002ac2 <rtc_irq+0x8a>
80002aba:	f0 c8 01 51 	sub	r8,r8,337
80002abe:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002ac2:	49 78       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002ac4:	11 a9       	ld.ub	r9,r8[0x2]
80002ac6:	2f f9       	sub	r9,-1
80002ac8:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002aca:	11 a8       	ld.ub	r8,r8[0x2]
80002acc:	f0 0a 18 00 	cp.b	r10,r8
80002ad0:	c1 c2       	brcc	80002b08 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002ad2:	49 38       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002ad4:	30 19       	mov	r9,1
80002ad6:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002ad8:	11 99       	ld.ub	r9,r8[0x1]
80002ada:	2f f9       	sub	r9,-1
80002adc:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002ade:	11 99       	ld.ub	r9,r8[0x1]
80002ae0:	30 c8       	mov	r8,12
80002ae2:	f0 09 18 00 	cp.b	r9,r8
80002ae6:	e0 88 00 11 	brls	80002b08 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002aea:	48 d8       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002aec:	30 19       	mov	r9,1
80002aee:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002af0:	11 89       	ld.ub	r9,r8[0x0]
80002af2:	2f f9       	sub	r9,-1
80002af4:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002af6:	11 89       	ld.ub	r9,r8[0x0]
80002af8:	39 68       	mov	r8,-106
80002afa:	f0 09 18 00 	cp.b	r9,r8
80002afe:	e0 88 00 05 	brls	80002b08 <rtc_irq+0xd0>
80002b02:	30 09       	mov	r9,0
80002b04:	48 68       	lddpc	r8,80002b1c <rtc_irq+0xe4>
80002b06:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b08:	fe 7c 0d 00 	mov	r12,-62208
80002b0c:	f0 1f 00 05 	mcall	80002b20 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b10:	30 19       	mov	r9,1
80002b12:	48 58       	lddpc	r8,80002b24 <rtc_irq+0xec>
80002b14:	91 09       	st.w	r8[0x0],r9
}
80002b16:	d4 02       	popm	lr
80002b18:	d6 03       	rete
80002b1a:	00 00       	add	r0,r0
80002b1c:	00 00       	add	r0,r0
80002b1e:	0e 00       	add	r0,r7
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	5e fc       	retal	r12
80002b24:	00 00       	add	r0,r0
80002b26:	04 f0       	st.b	--r2,r0

80002b28 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b28:	20 1c       	sub	r12,1
80002b2a:	5c 5c       	castu.b	r12
80002b2c:	31 18       	mov	r8,17
80002b2e:	f0 0c 18 00 	cp.b	r12,r8
80002b32:	e0 88 00 03 	brls	80002b38 <CalculateBurst+0x10>
80002b36:	5e fd       	retal	0
80002b38:	48 28       	lddpc	r8,80002b40 <CalculateBurst+0x18>
80002b3a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b3e:	5e fc       	retal	r12
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	df 2c       	*unknown*

80002b44 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002b44:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002b46:	48 98       	lddpc	r8,80002b68 <payload_init+0x24>
80002b48:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b4a:	48 98       	lddpc	r8,80002b6c <payload_init+0x28>
80002b4c:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002b4e:	30 09       	mov	r9,0
80002b50:	1a d9       	st.w	--sp,r9
80002b52:	1a d9       	st.w	--sp,r9
80002b54:	1a d9       	st.w	--sp,r9
80002b56:	30 28       	mov	r8,2
80002b58:	e0 6a 04 00 	mov	r10,1024
80002b5c:	48 5b       	lddpc	r11,80002b70 <payload_init+0x2c>
80002b5e:	48 6c       	lddpc	r12,80002b74 <payload_init+0x30>
80002b60:	f0 1f 00 06 	mcall	80002b78 <payload_init+0x34>
80002b64:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002b66:	d8 02       	popm	pc
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 6c       	and	r12,r5
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a 70       	tst	r0,r5
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	df 74       	*unknown*
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	2b 7c       	sub	r12,-73
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	73 a4       	ld.w	r4,r9[0x68]

80002b7c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002b7c:	eb cd 40 f8 	pushm	r3-r7,lr
80002b80:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002b82:	48 e8       	lddpc	r8,80002bb8 <payload_rx_process+0x3c>
80002b84:	70 08       	ld.w	r8,r8[0x0]
80002b86:	58 08       	cp.w	r8,0
80002b88:	c0 71       	brne	80002b96 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002b8a:	30 4b       	mov	r11,4
80002b8c:	30 5c       	mov	r12,5
80002b8e:	f0 1f 00 0c 	mcall	80002bbc <payload_rx_process+0x40>
80002b92:	48 a8       	lddpc	r8,80002bb8 <payload_rx_process+0x3c>
80002b94:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002b96:	48 96       	lddpc	r6,80002bb8 <payload_rx_process+0x3c>
80002b98:	30 05       	mov	r5,0
80002b9a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002b9c:	48 93       	lddpc	r3,80002bc0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002b9e:	6c 0c       	ld.w	r12,r6[0x0]
80002ba0:	0a 99       	mov	r9,r5
80002ba2:	08 9a       	mov	r10,r4
80002ba4:	1a 9b       	mov	r11,sp
80002ba6:	f0 1f 00 08 	mcall	80002bc4 <payload_rx_process+0x48>
80002baa:	58 1c       	cp.w	r12,1
80002bac:	cf 91       	brne	80002b9e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002bae:	66 08       	ld.w	r8,r3[0x0]
80002bb0:	40 0c       	lddsp	r12,sp[0x0]
80002bb2:	5d 18       	icall	r8
80002bb4:	cf 5b       	rjmp	80002b9e <payload_rx_process+0x22>
80002bb6:	00 00       	add	r0,r0
80002bb8:	00 00       	add	r0,r0
80002bba:	0a a0       	st.w	r5++,r0
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	6c 88       	ld.w	r8,r6[0x20]
80002bc0:	00 00       	add	r0,r0
80002bc2:	0a 6c       	and	r12,r5
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	69 24       	ld.w	r4,r4[0x48]

80002bc8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002bc8:	d4 01       	pushm	lr
80002bca:	20 2d       	sub	sp,8
80002bcc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bce:	30 09       	mov	r9,0
80002bd0:	fa ca ff f8 	sub	r10,sp,-8
80002bd4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bd6:	1a 9b       	mov	r11,sp
80002bd8:	f0 1f 00 02 	mcall	80002be0 <set_idle_store_isr+0x18>
}
80002bdc:	2f ed       	sub	sp,-8
80002bde:	d8 02       	popm	pc
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	6a e0       	ld.w	r0,r5[0x38]

80002be4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002be4:	d4 01       	pushm	lr
80002be6:	20 2d       	sub	sp,8
80002be8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bea:	58 0c       	cp.w	r12,0
80002bec:	c1 10       	breq	80002c0e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bee:	30 08       	mov	r8,0
80002bf0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002bf2:	98 88       	ld.uh	r8,r12[0x0]
80002bf4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002bf8:	e0 48 40 00 	cp.w	r8,16384
80002bfc:	c0 91       	brne	80002c0e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bfe:	48 68       	lddpc	r8,80002c14 <phy_rx+0x30>
80002c00:	70 0c       	ld.w	r12,r8[0x0]
80002c02:	30 09       	mov	r9,0
80002c04:	fa ca ff fc 	sub	r10,sp,-4
80002c08:	1a 9b       	mov	r11,sp
80002c0a:	f0 1f 00 04 	mcall	80002c18 <phy_rx+0x34>
		}	

    }
		
 
}
80002c0e:	2f ed       	sub	sp,-8
80002c10:	d8 02       	popm	pc
80002c12:	00 00       	add	r0,r0
80002c14:	00 00       	add	r0,r0
80002c16:	0a b8       	st.h	r5++,r8
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	6a e0       	ld.w	r0,r5[0x38]

80002c1c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c1c:	eb cd 40 80 	pushm	r7,lr
80002c20:	20 1d       	sub	sp,4
80002c22:	fa c7 ff fc 	sub	r7,sp,-4
80002c26:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c28:	30 09       	mov	r9,0
80002c2a:	12 9a       	mov	r10,r9
80002c2c:	1a 9b       	mov	r11,sp
80002c2e:	f0 1f 00 03 	mcall	80002c38 <set_idle_store+0x1c>
}
80002c32:	2f fd       	sub	sp,-4
80002c34:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c38:	80 00       	ld.sh	r0,r0[0x0]
80002c3a:	6b 30       	ld.w	r0,r5[0x4c]

80002c3c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c3c:	d4 01       	pushm	lr
80002c3e:	20 1d       	sub	sp,4
80002c40:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c42:	98 88       	ld.uh	r8,r12[0x0]
80002c44:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c48:	e0 48 40 00 	cp.w	r8,16384
80002c4c:	c0 d1       	brne	80002c66 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c4e:	49 08       	lddpc	r8,80002c8c <phy_tx+0x50>
80002c50:	70 08       	ld.w	r8,r8[0x0]
80002c52:	58 08       	cp.w	r8,0
80002c54:	c1 a0       	breq	80002c88 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c56:	48 e8       	lddpc	r8,80002c8c <phy_tx+0x50>
80002c58:	70 0c       	ld.w	r12,r8[0x0]
80002c5a:	30 09       	mov	r9,0
80002c5c:	12 9a       	mov	r10,r9
80002c5e:	1a 9b       	mov	r11,sp
80002c60:	f0 1f 00 0c 	mcall	80002c90 <phy_tx+0x54>
80002c64:	c1 28       	rjmp	80002c88 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c66:	e0 48 10 00 	cp.w	r8,4096
80002c6a:	5f 0a       	sreq	r10
80002c6c:	e0 48 20 00 	cp.w	r8,8192
80002c70:	5f 09       	sreq	r9
80002c72:	f5 e9 10 09 	or	r9,r10,r9
80002c76:	c0 71       	brne	80002c84 <phy_tx+0x48>
80002c78:	e0 48 50 00 	cp.w	r8,20480
80002c7c:	c0 40       	breq	80002c84 <phy_tx+0x48>
80002c7e:	e0 48 60 00 	cp.w	r8,24576
80002c82:	c0 31       	brne	80002c88 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c84:	48 48       	lddpc	r8,80002c94 <phy_tx+0x58>
80002c86:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c88:	2f fd       	sub	sp,-4
80002c8a:	d8 02       	popm	pc
80002c8c:	00 00       	add	r0,r0
80002c8e:	0a dc       	st.w	--r5,r12
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	6b 30       	ld.w	r0,r5[0x4c]
80002c94:	00 00       	add	r0,r0
80002c96:	0a cc       	st.b	r5++,r12

80002c98 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c98:	d4 01       	pushm	lr
80002c9a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c9c:	30 08       	mov	r8,0
80002c9e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ca0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002ca2:	1a 9a       	mov	r10,sp
80002ca4:	fa cb ff fc 	sub	r11,sp,-4
80002ca8:	f0 1f 00 05 	mcall	80002cbc <get_idle_store_isr+0x24>
80002cac:	58 1c       	cp.w	r12,1
80002cae:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cb2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002cb6:	2f ed       	sub	sp,-8
80002cb8:	d8 02       	popm	pc
80002cba:	00 00       	add	r0,r0
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	68 34       	ld.w	r4,r4[0xc]

80002cc0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002cc0:	eb cd 40 c0 	pushm	r6-r7,lr
80002cc4:	20 1d       	sub	sp,4
80002cc6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002cc8:	4b a8       	lddpc	r8,80002db0 <phy_tx_func+0xf0>
80002cca:	70 08       	ld.w	r8,r8[0x0]
80002ccc:	58 08       	cp.w	r8,0
80002cce:	c6 60       	breq	80002d9a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002cd0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cd2:	30 08       	mov	r8,0
80002cd4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cd6:	4b 88       	lddpc	r8,80002db4 <phy_tx_func+0xf4>
80002cd8:	70 08       	ld.w	r8,r8[0x0]
80002cda:	58 18       	cp.w	r8,1
80002cdc:	c2 60       	breq	80002d28 <phy_tx_func+0x68>
80002cde:	c0 43       	brcs	80002ce6 <phy_tx_func+0x26>
80002ce0:	58 28       	cp.w	r8,2
80002ce2:	c5 c1       	brne	80002d9a <phy_tx_func+0xda>
80002ce4:	c5 58       	rjmp	80002d8e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ce6:	4b 38       	lddpc	r8,80002db0 <phy_tx_func+0xf0>
80002ce8:	70 0c       	ld.w	r12,r8[0x0]
80002cea:	1a 9a       	mov	r10,sp
80002cec:	4b 3b       	lddpc	r11,80002db8 <phy_tx_func+0xf8>
80002cee:	f0 1f 00 34 	mcall	80002dbc <phy_tx_func+0xfc>
80002cf2:	58 1c       	cp.w	r12,1
80002cf4:	c1 41       	brne	80002d1c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002cf6:	4b 18       	lddpc	r8,80002db8 <phy_tx_func+0xf8>
80002cf8:	70 08       	ld.w	r8,r8[0x0]
80002cfa:	90 08       	ld.sh	r8,r8[0x0]
80002cfc:	10 9a       	mov	r10,r8
80002cfe:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d02:	4b 09       	lddpc	r9,80002dc0 <phy_tx_func+0x100>
80002d04:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d06:	5c 78       	castu.h	r8
80002d08:	ea 18 ab cd 	orh	r8,0xabcd
80002d0c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002d0e:	30 19       	mov	r9,1
80002d10:	4a d8       	lddpc	r8,80002dc4 <phy_tx_func+0x104>
80002d12:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d14:	30 19       	mov	r9,1
80002d16:	4a 88       	lddpc	r8,80002db4 <phy_tx_func+0xf4>
80002d18:	91 09       	st.w	r8[0x0],r9
80002d1a:	c4 08       	rjmp	80002d9a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d1c:	e0 68 5a 5a 	mov	r8,23130
80002d20:	ea 18 ab cd 	orh	r8,0xabcd
80002d24:	8f 18       	st.w	r7[0x4],r8
80002d26:	c3 a8       	rjmp	80002d9a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d28:	4a 7a       	lddpc	r10,80002dc4 <phy_tx_func+0x104>
80002d2a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d2c:	4a 39       	lddpc	r9,80002db8 <phy_tx_func+0xf8>
80002d2e:	72 09       	ld.w	r9,r9[0x0]
80002d30:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d34:	b1 69       	lsl	r9,0x10
80002d36:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d38:	2f f8       	sub	r8,-1
80002d3a:	5c 58       	castu.b	r8
80002d3c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d3e:	4a 1b       	lddpc	r11,80002dc0 <phy_tx_func+0x100>
80002d40:	96 0c       	ld.sh	r12,r11[0x0]
80002d42:	20 2c       	sub	r12,2
80002d44:	5c 8c       	casts.h	r12
80002d46:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d4a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d4c:	30 0b       	mov	r11,0
80002d4e:	f6 0a 19 00 	cp.h	r10,r11
80002d52:	e0 89 00 09 	brgt	80002d64 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d56:	e8 19 00 ba 	orl	r9,0xba
80002d5a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d5c:	30 09       	mov	r9,0
80002d5e:	49 68       	lddpc	r8,80002db4 <phy_tx_func+0xf4>
80002d60:	91 09       	st.w	r8[0x0],r9
80002d62:	c1 c8       	rjmp	80002d9a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d64:	49 5a       	lddpc	r10,80002db8 <phy_tx_func+0xf8>
80002d66:	74 0a       	ld.w	r10,r10[0x0]
80002d68:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d6c:	14 49       	or	r9,r10
80002d6e:	8f 19       	st.w	r7[0x4],r9
80002d70:	2f f8       	sub	r8,-1
80002d72:	49 59       	lddpc	r9,80002dc4 <phy_tx_func+0x104>
80002d74:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d76:	20 2c       	sub	r12,2
80002d78:	49 28       	lddpc	r8,80002dc0 <phy_tx_func+0x100>
80002d7a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d7c:	30 08       	mov	r8,0
80002d7e:	f0 0c 19 00 	cp.h	r12,r8
80002d82:	e0 89 00 0c 	brgt	80002d9a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d86:	30 29       	mov	r9,2
80002d88:	48 b8       	lddpc	r8,80002db4 <phy_tx_func+0xf4>
80002d8a:	91 09       	st.w	r8[0x0],r9
80002d8c:	c0 78       	rjmp	80002d9a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d8e:	fc 18 00 ba 	movh	r8,0xba
80002d92:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d94:	30 09       	mov	r9,0
80002d96:	48 88       	lddpc	r8,80002db4 <phy_tx_func+0xf4>
80002d98:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d9a:	e0 68 5a 5a 	mov	r8,23130
80002d9e:	ea 18 ab cd 	orh	r8,0xabcd
80002da2:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002da4:	30 08       	mov	r8,0
80002da6:	8f 38       	st.w	r7[0xc],r8
}
80002da8:	2f fd       	sub	sp,-4
80002daa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002dae:	00 00       	add	r0,r0
80002db0:	00 00       	add	r0,r0
80002db2:	0a dc       	st.w	--r5,r12
80002db4:	00 00       	add	r0,r0
80002db6:	0a 94       	mov	r4,r5
80002db8:	00 00       	add	r0,r0
80002dba:	0a e8       	st.h	--r5,r8
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	68 34       	ld.w	r4,r4[0xc]
80002dc0:	00 00       	add	r0,r0
80002dc2:	0a bc       	st.h	r5++,r12
80002dc4:	00 00       	add	r0,r0
80002dc6:	0a 78       	tst	r8,r5

80002dc8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002dc8:	d4 01       	pushm	lr
80002dca:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002dcc:	30 0a       	mov	r10,0
80002dce:	fa cb ff fc 	sub	r11,sp,-4
80002dd2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002dd4:	14 99       	mov	r9,r10
80002dd6:	1a 9b       	mov	r11,sp
80002dd8:	f0 1f 00 05 	mcall	80002dec <get_idle_store+0x24>
80002ddc:	58 1c       	cp.w	r12,1
80002dde:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002de2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002de6:	2f fd       	sub	sp,-4
80002de8:	d8 02       	popm	pc
80002dea:	00 00       	add	r0,r0
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	69 24       	ld.w	r4,r4[0x48]

80002df0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002df0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002df2:	48 5b       	lddpc	r11,80002e04 <phy_init+0x14>
80002df4:	48 5c       	lddpc	r12,80002e08 <phy_init+0x18>
80002df6:	f0 1f 00 06 	mcall	80002e0c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dfa:	f0 1f 00 06 	mcall	80002e10 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dfe:	f0 1f 00 06 	mcall	80002e14 <phy_init+0x24>
	
}
80002e02:	d8 02       	popm	pc
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	2c c0       	sub	r0,-52
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2e 78       	sub	r8,-25
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	3e c0       	mov	r0,-20
80002e10:	80 00       	ld.sh	r0,r0[0x0]
80002e12:	3e d4       	mov	r4,-19
80002e14:	80 00       	ld.sh	r0,r0[0x0]
80002e16:	48 7c       	lddpc	r12,80002e30 <payload_rx+0x18>

80002e18 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002e18:	d4 01       	pushm	lr
80002e1a:	20 2d       	sub	sp,8
80002e1c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002e1e:	30 08       	mov	r8,0
80002e20:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002e22:	48 f8       	lddpc	r8,80002e5c <payload_rx+0x44>
80002e24:	70 08       	ld.w	r8,r8[0x0]
80002e26:	58 08       	cp.w	r8,0
80002e28:	c0 71       	brne	80002e36 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002e2a:	30 4b       	mov	r11,4
80002e2c:	30 5c       	mov	r12,5
80002e2e:	f0 1f 00 0d 	mcall	80002e60 <payload_rx+0x48>
80002e32:	48 b8       	lddpc	r8,80002e5c <payload_rx+0x44>
80002e34:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002e36:	48 a8       	lddpc	r8,80002e5c <payload_rx+0x44>
80002e38:	70 0c       	ld.w	r12,r8[0x0]
80002e3a:	30 09       	mov	r9,0
80002e3c:	fa ca ff fc 	sub	r10,sp,-4
80002e40:	1a 9b       	mov	r11,sp
80002e42:	f0 1f 00 09 	mcall	80002e64 <payload_rx+0x4c>
80002e46:	c0 91       	brne	80002e58 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002e48:	48 88       	lddpc	r8,80002e68 <payload_rx+0x50>
80002e4a:	70 0c       	ld.w	r12,r8[0x0]
80002e4c:	40 0b       	lddsp	r11,sp[0x0]
80002e4e:	f0 1f 00 08 	mcall	80002e6c <payload_rx+0x54>
		logFromISR("mm");
80002e52:	48 8c       	lddpc	r12,80002e70 <payload_rx+0x58>
80002e54:	f0 1f 00 08 	mcall	80002e74 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002e58:	2f ed       	sub	sp,-8
80002e5a:	d8 02       	popm	pc
80002e5c:	00 00       	add	r0,r0
80002e5e:	0a a0       	st.w	r5++,r0
80002e60:	80 00       	ld.sh	r0,r0[0x0]
80002e62:	6c 88       	ld.w	r8,r6[0x20]
80002e64:	80 00       	ld.sh	r0,r0[0x0]
80002e66:	6a e0       	ld.w	r0,r5[0x38]
80002e68:	00 00       	add	r0,r0
80002e6a:	0a ac       	st.w	r5++,r12
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	2b c8       	sub	r8,-68
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	df 80       	acall	0xf8
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	78 f4       	ld.w	r4,r12[0x3c]

80002e78 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e78:	eb cd 40 e0 	pushm	r5-r7,lr
80002e7c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e7e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e82:	70 08       	ld.w	r8,r8[0x0]
80002e84:	58 08       	cp.w	r8,0
80002e86:	e0 80 01 08 	breq	80003096 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e8a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e8c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e90:	70 09       	ld.w	r9,r8[0x0]
80002e92:	2f f9       	sub	r9,-1
80002e94:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e96:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e9a:	70 08       	ld.w	r8,r8[0x0]
80002e9c:	58 18       	cp.w	r8,1
80002e9e:	e0 80 00 85 	breq	80002fa8 <phy_rx_func+0x130>
80002ea2:	c0 73       	brcs	80002eb0 <phy_rx_func+0x38>
80002ea4:	58 28       	cp.w	r8,2
80002ea6:	c5 c0       	breq	80002f5e <phy_rx_func+0xe6>
80002ea8:	58 38       	cp.w	r8,3
80002eaa:	e0 81 00 f6 	brne	80003096 <phy_rx_func+0x21e>
80002eae:	cd 58       	rjmp	80003058 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002eb0:	e0 6a 5a 5a 	mov	r10,23130
80002eb4:	ea 1a ab cd 	orh	r10,0xabcd
80002eb8:	14 36       	cp.w	r6,r10
80002eba:	e0 80 00 ee 	breq	80003096 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002ebe:	ec 08 16 10 	lsr	r8,r6,0x10
80002ec2:	e0 48 ab cd 	cp.w	r8,43981
80002ec6:	e0 81 00 e8 	brne	80003096 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002eca:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002ece:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002ed2:	20 28       	sub	r8,2
80002ed4:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002ed8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002eda:	30 09       	mov	r9,0
80002edc:	f2 08 19 00 	cp.h	r8,r9
80002ee0:	e0 8a 00 db 	brle	80003096 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ee4:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002ee8:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002eea:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002eee:	70 0c       	ld.w	r12,r8[0x0]
80002ef0:	f0 1f 03 88 	mcall	80003d10 <phy_rx_func+0xe98>
80002ef4:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002ef8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002efa:	58 0c       	cp.w	r12,0
80002efc:	e0 80 00 cd 	breq	80003096 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f00:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002f04:	90 09       	ld.sh	r9,r8[0x0]
80002f06:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f0a:	2f f9       	sub	r9,-1
80002f0c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f0e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002f12:	74 0a       	ld.w	r10,r10[0x0]
80002f14:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002f18:	76 0b       	ld.w	r11,r11[0x0]
80002f1a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f1e:	2f f9       	sub	r9,-1
80002f20:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f22:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f26:	e0 46 01 00 	cp.w	r6,256
80002f2a:	c0 c0       	breq	80002f42 <phy_rx_func+0xca>
80002f2c:	e0 8b 00 05 	brhi	80002f36 <phy_rx_func+0xbe>
80002f30:	58 06       	cp.w	r6,0
80002f32:	c0 80       	breq	80002f42 <phy_rx_func+0xca>
80002f34:	c0 c8       	rjmp	80002f4c <phy_rx_func+0xd4>
80002f36:	e0 46 02 00 	cp.w	r6,512
80002f3a:	c0 40       	breq	80002f42 <phy_rx_func+0xca>
80002f3c:	e0 46 03 00 	cp.w	r6,768
80002f40:	c0 61       	brne	80002f4c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f42:	30 29       	mov	r9,2
80002f44:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002f48:	91 09       	st.w	r8[0x0],r9
80002f4a:	ca 68       	rjmp	80003096 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f4c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f50:	70 0c       	ld.w	r12,r8[0x0]
80002f52:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f56:	70 0b       	ld.w	r11,r8[0x0]
80002f58:	f0 1f 03 70 	mcall	80003d18 <phy_rx_func+0xea0>
80002f5c:	c9 d8       	rjmp	80003096 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f5e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f62:	b1 86       	lsr	r6,0x10
80002f64:	14 06       	add	r6,r10
80002f66:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002f6a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f6c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f70:	90 09       	ld.sh	r9,r8[0x0]
80002f72:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f76:	76 0b       	ld.w	r11,r11[0x0]
80002f78:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f7c:	2f f9       	sub	r9,-1
80002f7e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f80:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f84:	92 08       	ld.sh	r8,r9[0x0]
80002f86:	20 28       	sub	r8,2
80002f88:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f8a:	30 09       	mov	r9,0
80002f8c:	f2 08 19 00 	cp.h	r8,r9
80002f90:	e0 8a 00 07 	brle	80002f9e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f94:	30 19       	mov	r9,1
80002f96:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f9a:	91 09       	st.w	r8[0x0],r9
80002f9c:	c7 d8       	rjmp	80003096 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f9e:	30 39       	mov	r9,3
80002fa0:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002fa4:	91 09       	st.w	r8[0x0],r9
80002fa6:	c7 88       	rjmp	80003096 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002fa8:	ec 0a 14 10 	asr	r10,r6,0x10
80002fac:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002fb0:	90 09       	ld.sh	r9,r8[0x0]
80002fb2:	14 09       	add	r9,r10
80002fb4:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002fb6:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002fba:	92 08       	ld.sh	r8,r9[0x0]
80002fbc:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002fc0:	76 0b       	ld.w	r11,r11[0x0]
80002fc2:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002fc6:	2f f8       	sub	r8,-1
80002fc8:	5c 88       	casts.h	r8
80002fca:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002fcc:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002fd0:	94 09       	ld.sh	r9,r10[0x0]
80002fd2:	20 29       	sub	r9,2
80002fd4:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002fd6:	30 0a       	mov	r10,0
80002fd8:	f4 09 19 00 	cp.h	r9,r10
80002fdc:	e0 89 00 20 	brgt	8000301c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002fe0:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002fe4:	e0 46 00 ba 	cp.w	r6,186
80002fe8:	c0 d1       	brne	80003002 <phy_rx_func+0x18a>
80002fea:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002fee:	90 09       	ld.sh	r9,r8[0x0]
80002ff0:	f4 09 19 00 	cp.h	r9,r10
80002ff4:	c0 71       	brne	80003002 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002ff6:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002ffa:	70 0c       	ld.w	r12,r8[0x0]
80002ffc:	f0 1f 03 49 	mcall	80003d20 <phy_rx_func+0xea8>
80003000:	c0 98       	rjmp	80003012 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003002:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003006:	70 0c       	ld.w	r12,r8[0x0]
80003008:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000300c:	70 0b       	ld.w	r11,r8[0x0]
8000300e:	f0 1f 03 43 	mcall	80003d18 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003012:	30 09       	mov	r9,0
80003014:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003018:	91 09       	st.w	r8[0x0],r9
8000301a:	c3 e8       	rjmp	80003096 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000301c:	5c 86       	casts.h	r6
8000301e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003022:	92 0a       	ld.sh	r10,r9[0x0]
80003024:	0c 0a       	add	r10,r6
80003026:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003028:	fe f9 0c ec 	ld.w	r9,pc[3308]
8000302c:	72 09       	ld.w	r9,r9[0x0]
8000302e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003032:	2f f8       	sub	r8,-1
80003034:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003038:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000303a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000303e:	92 08       	ld.sh	r8,r9[0x0]
80003040:	20 28       	sub	r8,2
80003042:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003044:	30 09       	mov	r9,0
80003046:	f2 08 19 00 	cp.h	r8,r9
8000304a:	e0 89 00 26 	brgt	80003096 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000304e:	30 39       	mov	r9,3
80003050:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003054:	91 09       	st.w	r8[0x0],r9
80003056:	c2 08       	rjmp	80003096 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003058:	e6 16 00 ff 	andh	r6,0xff,COH
8000305c:	fc 19 00 ba 	movh	r9,0xba
80003060:	12 36       	cp.w	r6,r9
80003062:	c0 e1       	brne	8000307e <phy_rx_func+0x206>
80003064:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003068:	90 09       	ld.sh	r9,r8[0x0]
8000306a:	30 08       	mov	r8,0
8000306c:	f0 09 19 00 	cp.h	r9,r8
80003070:	c0 71       	brne	8000307e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003072:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003076:	70 0c       	ld.w	r12,r8[0x0]
80003078:	f0 1f 03 2a 	mcall	80003d20 <phy_rx_func+0xea8>
8000307c:	c0 98       	rjmp	8000308e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000307e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003082:	70 0c       	ld.w	r12,r8[0x0]
80003084:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003088:	70 0b       	ld.w	r11,r8[0x0]
8000308a:	f0 1f 03 24 	mcall	80003d18 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000308e:	30 09       	mov	r9,0
80003090:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003094:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003096:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000309a:	11 89       	ld.ub	r9,r8[0x0]
8000309c:	30 08       	mov	r8,0
8000309e:	f0 09 18 00 	cp.b	r9,r8
800030a2:	c1 31       	brne	800030c8 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800030a4:	fe f6 0c 84 	ld.w	r6,pc[3204]
800030a8:	6c 0c       	ld.w	r12,r6[0x0]
800030aa:	f0 1f 03 1a 	mcall	80003d10 <phy_rx_func+0xe98>
800030ae:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800030b2:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800030b4:	6c 0c       	ld.w	r12,r6[0x0]
800030b6:	f0 1f 03 17 	mcall	80003d10 <phy_rx_func+0xe98>
800030ba:	fe f8 0c 76 	ld.w	r8,pc[3190]
800030be:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800030c0:	30 19       	mov	r9,1
800030c2:	fe f8 0c 62 	ld.w	r8,pc[3170]
800030c6:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800030c8:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800030cc:	70 08       	ld.w	r8,r8[0x0]
800030ce:	58 28       	cp.w	r8,2
800030d0:	e0 80 01 98 	breq	80003400 <phy_rx_func+0x588>
800030d4:	e0 8b 00 06 	brhi	800030e0 <phy_rx_func+0x268>
800030d8:	58 08       	cp.w	r8,0
800030da:	c0 b0       	breq	800030f0 <phy_rx_func+0x278>
800030dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030e0:	58 38       	cp.w	r8,3
800030e2:	e0 80 05 c5 	breq	80003c6c <phy_rx_func+0xdf4>
800030e6:	58 48       	cp.w	r8,4
800030e8:	e0 81 06 05 	brne	80003cf2 <phy_rx_func+0xe7a>
800030ec:	e0 8f 02 4b 	bral	80003582 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800030f0:	6e 28       	ld.w	r8,r7[0x8]
800030f2:	e0 6a 5a 5a 	mov	r10,23130
800030f6:	ea 1a ab cd 	orh	r10,0xabcd
800030fa:	14 38       	cp.w	r8,r10
800030fc:	c0 71       	brne	8000310a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800030fe:	30 09       	mov	r9,0
80003100:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003104:	91 09       	st.w	r8[0x0],r9
80003106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000310a:	10 99       	mov	r9,r8
8000310c:	e0 19 00 00 	andl	r9,0x0
80003110:	fc 1a ab cd 	movh	r10,0xabcd
80003114:	14 39       	cp.w	r9,r10
80003116:	e0 81 05 ee 	brne	80003cf2 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000311a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000311e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003122:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003124:	6e 29       	ld.w	r9,r7[0x8]
80003126:	e2 19 f0 00 	andl	r9,0xf000,COH
8000312a:	e0 49 c0 00 	cp.w	r9,49152
8000312e:	e0 81 00 ce 	brne	800032ca <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003132:	30 1a       	mov	r10,1
80003134:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003138:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000313a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000313e:	72 09       	ld.w	r9,r9[0x0]
80003140:	58 09       	cp.w	r9,0
80003142:	c0 71       	brne	80003150 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003144:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003148:	f0 1f 03 00 	mcall	80003d48 <phy_rx_func+0xed0>
8000314c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003150:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003154:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003158:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000315a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000315e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003162:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003166:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003168:	13 89       	ld.ub	r9,r9[0x0]
8000316a:	37 fa       	mov	r10,127
8000316c:	f4 09 18 00 	cp.b	r9,r10
80003170:	c6 d0       	breq	8000324a <phy_rx_func+0x3d2>
80003172:	e0 8b 00 0c 	brhi	8000318a <phy_rx_func+0x312>
80003176:	31 2a       	mov	r10,18
80003178:	f4 09 18 00 	cp.b	r9,r10
8000317c:	c4 20       	breq	80003200 <phy_rx_func+0x388>
8000317e:	31 3a       	mov	r10,19
80003180:	f4 09 18 00 	cp.b	r9,r10
80003184:	e0 81 00 83 	brne	8000328a <phy_rx_func+0x412>
80003188:	c5 b8       	rjmp	8000323e <phy_rx_func+0x3c6>
8000318a:	2f 09       	sub	r9,-16
8000318c:	30 1a       	mov	r10,1
8000318e:	f4 09 18 00 	cp.b	r9,r10
80003192:	e0 8b 00 7c 	brhi	8000328a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003196:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000319a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000319e:	59 08       	cp.w	r8,16
800031a0:	c0 71       	brne	800031ae <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800031a2:	30 19       	mov	r9,1
800031a4:	fe f8 0b 94 	ld.w	r8,pc[2964]
800031a8:	91 09       	st.w	r8[0x0],r9
800031aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800031ae:	e0 48 00 20 	cp.w	r8,32
800031b2:	c2 11       	brne	800031f4 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800031b4:	30 a9       	mov	r9,10
800031b6:	fe f8 0b 82 	ld.w	r8,pc[2946]
800031ba:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800031bc:	fe f6 0b 98 	ld.w	r6,pc[2968]
800031c0:	6c 08       	ld.w	r8,r6[0x0]
800031c2:	f0 0a 11 ff 	rsub	r10,r8,-1
800031c6:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800031ca:	2f f8       	sub	r8,-1
800031cc:	6e 0c       	ld.w	r12,r7[0x0]
800031ce:	f4 ca fe 00 	sub	r10,r10,-512
800031d2:	30 0b       	mov	r11,0
800031d4:	10 0c       	add	r12,r8
800031d6:	f0 1f 02 e1 	mcall	80003d58 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
800031da:	30 08       	mov	r8,0
800031dc:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800031de:	6e 0c       	ld.w	r12,r7[0x0]
800031e0:	f0 1f 02 df 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800031e4:	fe f8 0b 44 	ld.w	r8,pc[2884]
800031e8:	70 0c       	ld.w	r12,r8[0x0]
800031ea:	f0 1f 02 ca 	mcall	80003d10 <phy_rx_func+0xe98>
800031ee:	8f 0c       	st.w	r7[0x0],r12
800031f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800031f4:	30 09       	mov	r9,0
800031f6:	fe f8 0b 42 	ld.w	r8,pc[2882]
800031fa:	91 09       	st.w	r8[0x0],r9
800031fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003200:	20 48       	sub	r8,4
80003202:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003206:	93 08       	st.w	r9[0x0],r8
80003208:	58 08       	cp.w	r8,0
8000320a:	e0 80 05 74 	breq	80003cf2 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000320e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003212:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003216:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000321a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000321c:	8e 69       	ld.sh	r9,r7[0xc]
8000321e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003222:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003224:	8e 79       	ld.sh	r9,r7[0xe]
80003226:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003228:	f0 1f 02 d0 	mcall	80003d68 <phy_rx_func+0xef0>
8000322c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003230:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003232:	30 49       	mov	r9,4
80003234:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000323e:	30 09       	mov	r9,0
80003240:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003244:	91 09       	st.w	r8[0x0],r9
80003246:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000324a:	20 48       	sub	r8,4
8000324c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003250:	93 08       	st.w	r9[0x0],r8
80003252:	58 08       	cp.w	r8,0
80003254:	e0 80 05 4f 	breq	80003cf2 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003258:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000325c:	70 09       	ld.w	r9,r8[0x0]
8000325e:	8e 7b       	ld.sh	r11,r7[0xe]
80003260:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003264:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003268:	2f f9       	sub	r9,-1
8000326a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000326c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003270:	70 09       	ld.w	r9,r8[0x0]
80003272:	20 29       	sub	r9,2
80003274:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003276:	30 29       	mov	r9,2
80003278:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000327c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000327e:	30 39       	mov	r9,3
80003280:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003284:	91 09       	st.w	r8[0x0],r9
80003286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000328a:	30 3a       	mov	r10,3
8000328c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003290:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003292:	6e 2a       	ld.w	r10,r7[0x8]
80003294:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003298:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000329a:	6e 3a       	ld.w	r10,r7[0xc]
8000329c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000329e:	59 48       	cp.w	r8,20
800032a0:	c0 61       	brne	800032ac <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800032a2:	31 89       	mov	r9,24
800032a4:	fe f8 0a 98 	ld.w	r8,pc[2712]
800032a8:	91 09       	st.w	r8[0x0],r9
800032aa:	c0 a8       	rjmp	800032be <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800032ac:	fe f8 0a 90 	ld.w	r8,pc[2704]
800032b0:	70 08       	ld.w	r8,r8[0x0]
800032b2:	59 08       	cp.w	r8,16
800032b4:	c0 51       	brne	800032be <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800032b6:	31 09       	mov	r9,16
800032b8:	fe f8 0a 84 	ld.w	r8,pc[2692]
800032bc:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800032be:	30 49       	mov	r9,4
800032c0:	fe f8 0a 74 	ld.w	r8,pc[2676]
800032c4:	91 09       	st.w	r8[0x0],r9
800032c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800032ca:	e0 49 10 00 	cp.w	r9,4096
800032ce:	5f 1a       	srne	r10
800032d0:	e0 49 20 00 	cp.w	r9,8192
800032d4:	5f 19       	srne	r9
800032d6:	f5 e9 00 09 	and	r9,r10,r9
800032da:	e0 81 05 0c 	brne	80003cf2 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800032de:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800032e2:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800032e4:	fe fa 0a 98 	ld.w	r10,pc[2712]
800032e8:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800032ea:	fe fa 0a 62 	ld.w	r10,pc[2658]
800032ee:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800032f0:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800032f4:	72 09       	ld.w	r9,r9[0x0]
800032f6:	58 09       	cp.w	r9,0
800032f8:	c0 71       	brne	80003306 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032fa:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800032fe:	f0 1f 02 93 	mcall	80003d48 <phy_rx_func+0xed0>
80003302:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003306:	6e 2a       	ld.w	r10,r7[0x8]
80003308:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000330c:	58 1a       	cp.w	r10,1
8000330e:	e0 8b 00 4d 	brhi	800033a8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003312:	20 48       	sub	r8,4
80003314:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003318:	93 08       	st.w	r9[0x0],r8
8000331a:	58 08       	cp.w	r8,0
8000331c:	e0 80 04 eb 	breq	80003cf2 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003320:	8e 68       	ld.sh	r8,r7[0xc]
80003322:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003326:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000332a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000332c:	30 09       	mov	r9,0
8000332e:	f2 08 19 00 	cp.h	r8,r9
80003332:	c0 70       	breq	80003340 <phy_rx_func+0x4c8>
80003334:	30 19       	mov	r9,1
80003336:	f2 08 19 00 	cp.h	r8,r9
8000333a:	e0 81 04 dc 	brne	80003cf2 <phy_rx_func+0xe7a>
8000333e:	c2 68       	rjmp	8000338a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003340:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003344:	70 0a       	ld.w	r10,r8[0x0]
80003346:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000334a:	72 09       	ld.w	r9,r9[0x0]
8000334c:	8e 7b       	ld.sh	r11,r7[0xe]
8000334e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003352:	70 09       	ld.w	r9,r8[0x0]
80003354:	2f f9       	sub	r9,-1
80003356:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003358:	e0 49 00 ff 	cp.w	r9,255
8000335c:	e0 88 00 11 	brls	8000337e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003360:	30 09       	mov	r9,0
80003362:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003364:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003368:	6e 0c       	ld.w	r12,r7[0x0]
8000336a:	f0 1f 02 7d 	mcall	80003d5c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000336e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003372:	70 0c       	ld.w	r12,r8[0x0]
80003374:	f0 1f 02 67 	mcall	80003d10 <phy_rx_func+0xe98>
80003378:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000337a:	e0 80 04 bc 	breq	80003cf2 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000337e:	30 29       	mov	r9,2
80003380:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003384:	91 09       	st.w	r8[0x0],r9
80003386:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000338a:	8e 79       	ld.sh	r9,r7[0xe]
8000338c:	30 38       	mov	r8,3
8000338e:	f0 09 19 00 	cp.h	r9,r8
80003392:	c0 51       	brne	8000339c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003394:	30 19       	mov	r9,1
80003396:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000339a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000339c:	30 29       	mov	r9,2
8000339e:	fe f8 09 96 	ld.w	r8,pc[2454]
800033a2:	91 09       	st.w	r8[0x0],r9
800033a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800033a8:	58 18       	cp.w	r8,1
800033aa:	e0 88 04 a4 	brls	80003cf2 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800033ae:	fe f8 09 d6 	ld.w	r8,pc[2518]
800033b2:	70 0a       	ld.w	r10,r8[0x0]
800033b4:	6e 3b       	ld.w	r11,r7[0xc]
800033b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033ba:	70 09       	ld.w	r9,r8[0x0]
800033bc:	2f f9       	sub	r9,-1
800033be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033c0:	e0 49 00 ff 	cp.w	r9,255
800033c4:	e0 88 00 11 	brls	800033e6 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800033c8:	30 09       	mov	r9,0
800033ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033cc:	fe f7 09 60 	ld.w	r7,pc[2400]
800033d0:	6e 0c       	ld.w	r12,r7[0x0]
800033d2:	f0 1f 02 63 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033d6:	fe f8 09 52 	ld.w	r8,pc[2386]
800033da:	70 0c       	ld.w	r12,r8[0x0]
800033dc:	f0 1f 02 4d 	mcall	80003d10 <phy_rx_func+0xe98>
800033e0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033e2:	e0 80 04 88 	breq	80003cf2 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800033e6:	fe f9 09 56 	ld.w	r9,pc[2390]
800033ea:	72 08       	ld.w	r8,r9[0x0]
800033ec:	20 28       	sub	r8,2
800033ee:	93 08       	st.w	r9[0x0],r8
800033f0:	e0 80 04 81 	breq	80003cf2 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800033f4:	30 29       	mov	r9,2
800033f6:	fe f8 09 3e 	ld.w	r8,pc[2366]
800033fa:	91 09       	st.w	r8[0x0],r9
800033fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003400:	fe f8 09 84 	ld.w	r8,pc[2436]
80003404:	70 0a       	ld.w	r10,r8[0x0]
80003406:	fe f9 09 26 	ld.w	r9,pc[2342]
8000340a:	72 09       	ld.w	r9,r9[0x0]
8000340c:	8e 4b       	ld.sh	r11,r7[0x8]
8000340e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003412:	70 09       	ld.w	r9,r8[0x0]
80003414:	2f f9       	sub	r9,-1
80003416:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003418:	e0 49 00 ff 	cp.w	r9,255
8000341c:	e0 88 00 16 	brls	80003448 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003420:	30 09       	mov	r9,0
80003422:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003424:	fe f6 09 08 	ld.w	r6,pc[2312]
80003428:	6c 0c       	ld.w	r12,r6[0x0]
8000342a:	f0 1f 02 4d 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000342e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003432:	70 0c       	ld.w	r12,r8[0x0]
80003434:	f0 1f 02 37 	mcall	80003d10 <phy_rx_func+0xe98>
80003438:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000343a:	c0 71       	brne	80003448 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000343c:	30 09       	mov	r9,0
8000343e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003442:	91 09       	st.w	r8[0x0],r9
80003444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003448:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000344c:	72 08       	ld.w	r8,r9[0x0]
8000344e:	20 28       	sub	r8,2
80003450:	93 08       	st.w	r9[0x0],r8
80003452:	c0 71       	brne	80003460 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003454:	30 09       	mov	r9,0
80003456:	fe f8 08 de 	ld.w	r8,pc[2270]
8000345a:	91 09       	st.w	r8[0x0],r9
8000345c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003460:	fe f8 09 24 	ld.w	r8,pc[2340]
80003464:	70 0a       	ld.w	r10,r8[0x0]
80003466:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000346a:	72 09       	ld.w	r9,r9[0x0]
8000346c:	8e 5b       	ld.sh	r11,r7[0xa]
8000346e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003472:	70 09       	ld.w	r9,r8[0x0]
80003474:	2f f9       	sub	r9,-1
80003476:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003478:	e0 49 00 ff 	cp.w	r9,255
8000347c:	e0 88 00 16 	brls	800034a8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003480:	30 09       	mov	r9,0
80003482:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003484:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003488:	6c 0c       	ld.w	r12,r6[0x0]
8000348a:	f0 1f 02 35 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000348e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003492:	70 0c       	ld.w	r12,r8[0x0]
80003494:	f0 1f 02 1f 	mcall	80003d10 <phy_rx_func+0xe98>
80003498:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000349a:	c0 71       	brne	800034a8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000349c:	30 09       	mov	r9,0
8000349e:	fe f8 08 96 	ld.w	r8,pc[2198]
800034a2:	91 09       	st.w	r8[0x0],r9
800034a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034a8:	fe f9 08 94 	ld.w	r9,pc[2196]
800034ac:	72 08       	ld.w	r8,r9[0x0]
800034ae:	20 28       	sub	r8,2
800034b0:	93 08       	st.w	r9[0x0],r8
800034b2:	c0 71       	brne	800034c0 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800034b4:	30 09       	mov	r9,0
800034b6:	fe f8 08 7e 	ld.w	r8,pc[2174]
800034ba:	91 09       	st.w	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800034c0:	fe f8 08 c4 	ld.w	r8,pc[2244]
800034c4:	70 0a       	ld.w	r10,r8[0x0]
800034c6:	fe f9 08 66 	ld.w	r9,pc[2150]
800034ca:	72 09       	ld.w	r9,r9[0x0]
800034cc:	8e 6b       	ld.sh	r11,r7[0xc]
800034ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034d2:	70 09       	ld.w	r9,r8[0x0]
800034d4:	2f f9       	sub	r9,-1
800034d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034d8:	e0 49 00 ff 	cp.w	r9,255
800034dc:	e0 88 00 16 	brls	80003508 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800034e0:	30 09       	mov	r9,0
800034e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034e4:	fe f6 08 48 	ld.w	r6,pc[2120]
800034e8:	6c 0c       	ld.w	r12,r6[0x0]
800034ea:	f0 1f 02 1d 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034ee:	fe f8 08 3a 	ld.w	r8,pc[2106]
800034f2:	70 0c       	ld.w	r12,r8[0x0]
800034f4:	f0 1f 02 07 	mcall	80003d10 <phy_rx_func+0xe98>
800034f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034fa:	c0 71       	brne	80003508 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 08 36 	ld.w	r8,pc[2102]
80003502:	91 09       	st.w	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003508:	fe f9 08 34 	ld.w	r9,pc[2100]
8000350c:	72 08       	ld.w	r8,r9[0x0]
8000350e:	20 28       	sub	r8,2
80003510:	93 08       	st.w	r9[0x0],r8
80003512:	c0 71       	brne	80003520 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003514:	30 09       	mov	r9,0
80003516:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000351a:	91 09       	st.w	r8[0x0],r9
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003520:	fe f8 08 64 	ld.w	r8,pc[2148]
80003524:	70 0a       	ld.w	r10,r8[0x0]
80003526:	fe f9 08 06 	ld.w	r9,pc[2054]
8000352a:	72 09       	ld.w	r9,r9[0x0]
8000352c:	8e 7b       	ld.sh	r11,r7[0xe]
8000352e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003532:	70 09       	ld.w	r9,r8[0x0]
80003534:	2f f9       	sub	r9,-1
80003536:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003538:	e0 49 00 ff 	cp.w	r9,255
8000353c:	e0 88 00 16 	brls	80003568 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003540:	30 09       	mov	r9,0
80003542:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003544:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003548:	6e 0c       	ld.w	r12,r7[0x0]
8000354a:	f0 1f 02 05 	mcall	80003d5c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000354e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003552:	70 0c       	ld.w	r12,r8[0x0]
80003554:	f0 1f 01 ef 	mcall	80003d10 <phy_rx_func+0xe98>
80003558:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000355a:	c0 71       	brne	80003568 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000355c:	30 09       	mov	r9,0
8000355e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003562:	91 09       	st.w	r8[0x0],r9
80003564:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003568:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000356c:	72 08       	ld.w	r8,r9[0x0]
8000356e:	20 28       	sub	r8,2
80003570:	93 08       	st.w	r9[0x0],r8
80003572:	e0 81 03 c0 	brne	80003cf2 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003576:	30 09       	mov	r9,0
80003578:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000357c:	91 09       	st.w	r8[0x0],r9
8000357e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003582:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003586:	11 89       	ld.ub	r9,r8[0x0]
80003588:	31 28       	mov	r8,18
8000358a:	f0 09 18 00 	cp.b	r9,r8
8000358e:	e0 81 01 4c 	brne	80003826 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003592:	ef 39 00 09 	ld.ub	r9,r7[9]
80003596:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000359a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000359c:	11 89       	ld.ub	r9,r8[0x0]
8000359e:	3f 28       	mov	r8,-14
800035a0:	f0 09 18 00 	cp.b	r9,r8
800035a4:	e0 81 01 3b 	brne	8000381a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800035a8:	30 19       	mov	r9,1
800035aa:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035ae:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800035b0:	6e 29       	ld.w	r9,r7[0x8]
800035b2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800035b6:	fe f8 07 86 	ld.w	r8,pc[1926]
800035ba:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800035bc:	8e 59       	ld.sh	r9,r7[0xa]
800035be:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035c2:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800035c4:	8e 69       	ld.sh	r9,r7[0xc]
800035c6:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800035c8:	8e 79       	ld.sh	r9,r7[0xe]
800035ca:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800035cc:	fe f8 07 88 	ld.w	r8,pc[1928]
800035d0:	fe f9 07 60 	ld.w	r9,pc[1888]
800035d4:	72 0a       	ld.w	r10,r9[0x0]
800035d6:	70 09       	ld.w	r9,r8[0x0]
800035d8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800035dc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035e0:	70 09       	ld.w	r9,r8[0x0]
800035e2:	2f f9       	sub	r9,-1
800035e4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035e6:	e0 49 01 ff 	cp.w	r9,511
800035ea:	e0 88 00 16 	brls	80003616 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ee:	30 09       	mov	r9,0
800035f0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035f2:	fe f6 07 3e 	ld.w	r6,pc[1854]
800035f6:	6c 0c       	ld.w	r12,r6[0x0]
800035f8:	f0 1f 01 d9 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035fc:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003600:	70 0c       	ld.w	r12,r8[0x0]
80003602:	f0 1f 01 c4 	mcall	80003d10 <phy_rx_func+0xe98>
80003606:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003608:	c0 71       	brne	80003616 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000360a:	30 09       	mov	r9,0
8000360c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003610:	91 09       	st.w	r8[0x0],r9
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003616:	fe f9 07 26 	ld.w	r9,pc[1830]
8000361a:	72 08       	ld.w	r8,r9[0x0]
8000361c:	20 18       	sub	r8,1
8000361e:	93 08       	st.w	r9[0x0],r8
80003620:	c0 71       	brne	8000362e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003622:	30 09       	mov	r9,0
80003624:	fe f8 07 10 	ld.w	r8,pc[1808]
80003628:	91 09       	st.w	r8[0x0],r9
8000362a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000362e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003632:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003636:	72 0a       	ld.w	r10,r9[0x0]
80003638:	70 09       	ld.w	r9,r8[0x0]
8000363a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000363e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003642:	70 09       	ld.w	r9,r8[0x0]
80003644:	2f f9       	sub	r9,-1
80003646:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003648:	e0 49 01 ff 	cp.w	r9,511
8000364c:	e0 88 00 16 	brls	80003678 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003650:	30 09       	mov	r9,0
80003652:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003654:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003658:	6c 0c       	ld.w	r12,r6[0x0]
8000365a:	f0 1f 01 c1 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000365e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003662:	70 0c       	ld.w	r12,r8[0x0]
80003664:	f0 1f 01 ab 	mcall	80003d10 <phy_rx_func+0xe98>
80003668:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000366a:	c0 71       	brne	80003678 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
8000366c:	30 09       	mov	r9,0
8000366e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003672:	91 09       	st.w	r8[0x0],r9
80003674:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003678:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000367c:	72 08       	ld.w	r8,r9[0x0]
8000367e:	20 18       	sub	r8,1
80003680:	93 08       	st.w	r9[0x0],r8
80003682:	c0 71       	brne	80003690 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003684:	30 09       	mov	r9,0
80003686:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000368a:	91 09       	st.w	r8[0x0],r9
8000368c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003690:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003694:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003698:	72 0a       	ld.w	r10,r9[0x0]
8000369a:	70 09       	ld.w	r9,r8[0x0]
8000369c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800036a0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036a4:	70 09       	ld.w	r9,r8[0x0]
800036a6:	2f f9       	sub	r9,-1
800036a8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036aa:	e0 49 01 ff 	cp.w	r9,511
800036ae:	e0 88 00 16 	brls	800036da <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800036b2:	30 09       	mov	r9,0
800036b4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036b6:	fe f6 06 7a 	ld.w	r6,pc[1658]
800036ba:	6c 0c       	ld.w	r12,r6[0x0]
800036bc:	f0 1f 01 a8 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036c0:	fe f8 06 68 	ld.w	r8,pc[1640]
800036c4:	70 0c       	ld.w	r12,r8[0x0]
800036c6:	f0 1f 01 93 	mcall	80003d10 <phy_rx_func+0xe98>
800036ca:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036cc:	c0 71       	brne	800036da <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800036ce:	30 09       	mov	r9,0
800036d0:	fe f8 06 64 	ld.w	r8,pc[1636]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036da:	fe f9 06 62 	ld.w	r9,pc[1634]
800036de:	72 08       	ld.w	r8,r9[0x0]
800036e0:	20 18       	sub	r8,1
800036e2:	93 08       	st.w	r9[0x0],r8
800036e4:	c0 71       	brne	800036f2 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800036e6:	30 09       	mov	r9,0
800036e8:	fe f8 06 4c 	ld.w	r8,pc[1612]
800036ec:	91 09       	st.w	r8[0x0],r9
800036ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800036f2:	fe f8 06 62 	ld.w	r8,pc[1634]
800036f6:	fe f9 06 3a 	ld.w	r9,pc[1594]
800036fa:	72 0a       	ld.w	r10,r9[0x0]
800036fc:	70 09       	ld.w	r9,r8[0x0]
800036fe:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003702:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003706:	70 09       	ld.w	r9,r8[0x0]
80003708:	2f f9       	sub	r9,-1
8000370a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000370c:	e0 49 01 ff 	cp.w	r9,511
80003710:	e0 88 00 16 	brls	8000373c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003714:	30 09       	mov	r9,0
80003716:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003718:	fe f6 06 18 	ld.w	r6,pc[1560]
8000371c:	6c 0c       	ld.w	r12,r6[0x0]
8000371e:	f0 1f 01 90 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003722:	fe f8 06 06 	ld.w	r8,pc[1542]
80003726:	70 0c       	ld.w	r12,r8[0x0]
80003728:	f0 1f 01 7a 	mcall	80003d10 <phy_rx_func+0xe98>
8000372c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000372e:	c0 71       	brne	8000373c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003730:	30 09       	mov	r9,0
80003732:	fe f8 06 02 	ld.w	r8,pc[1538]
80003736:	91 09       	st.w	r8[0x0],r9
80003738:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000373c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003740:	72 08       	ld.w	r8,r9[0x0]
80003742:	20 18       	sub	r8,1
80003744:	93 08       	st.w	r9[0x0],r8
80003746:	c0 71       	brne	80003754 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003748:	30 09       	mov	r9,0
8000374a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000374e:	91 09       	st.w	r8[0x0],r9
80003750:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003754:	fe f8 06 00 	ld.w	r8,pc[1536]
80003758:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000375c:	72 0a       	ld.w	r10,r9[0x0]
8000375e:	70 09       	ld.w	r9,r8[0x0]
80003760:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003764:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003768:	70 09       	ld.w	r9,r8[0x0]
8000376a:	2f f9       	sub	r9,-1
8000376c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000376e:	e0 49 01 ff 	cp.w	r9,511
80003772:	e0 88 00 16 	brls	8000379e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003776:	30 09       	mov	r9,0
80003778:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000377a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000377e:	6c 0c       	ld.w	r12,r6[0x0]
80003780:	f0 1f 01 77 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003784:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003788:	70 0c       	ld.w	r12,r8[0x0]
8000378a:	f0 1f 01 62 	mcall	80003d10 <phy_rx_func+0xe98>
8000378e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003790:	c0 71       	brne	8000379e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003792:	30 09       	mov	r9,0
80003794:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003798:	91 09       	st.w	r8[0x0],r9
8000379a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000379e:	fe f9 05 9e 	ld.w	r9,pc[1438]
800037a2:	72 08       	ld.w	r8,r9[0x0]
800037a4:	20 18       	sub	r8,1
800037a6:	93 08       	st.w	r9[0x0],r8
800037a8:	c0 71       	brne	800037b6 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800037aa:	30 09       	mov	r9,0
800037ac:	fe f8 05 88 	ld.w	r8,pc[1416]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800037b6:	fe f8 05 9e 	ld.w	r8,pc[1438]
800037ba:	fe f9 05 76 	ld.w	r9,pc[1398]
800037be:	72 0a       	ld.w	r10,r9[0x0]
800037c0:	70 09       	ld.w	r9,r8[0x0]
800037c2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800037c6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037ca:	70 09       	ld.w	r9,r8[0x0]
800037cc:	2f f9       	sub	r9,-1
800037ce:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037d0:	e0 49 01 ff 	cp.w	r9,511
800037d4:	e0 88 00 16 	brls	80003800 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800037d8:	30 09       	mov	r9,0
800037da:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037dc:	fe f7 05 54 	ld.w	r7,pc[1364]
800037e0:	6e 0c       	ld.w	r12,r7[0x0]
800037e2:	f0 1f 01 5f 	mcall	80003d5c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037e6:	fe f8 05 42 	ld.w	r8,pc[1346]
800037ea:	70 0c       	ld.w	r12,r8[0x0]
800037ec:	f0 1f 01 49 	mcall	80003d10 <phy_rx_func+0xe98>
800037f0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f2:	c0 71       	brne	80003800 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800037f4:	30 09       	mov	r9,0
800037f6:	fe f8 05 3e 	ld.w	r8,pc[1342]
800037fa:	91 09       	st.w	r8[0x0],r9
800037fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003800:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003804:	72 08       	ld.w	r8,r9[0x0]
80003806:	20 18       	sub	r8,1
80003808:	93 08       	st.w	r9[0x0],r8
8000380a:	e0 81 02 74 	brne	80003cf2 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000380e:	30 09       	mov	r9,0
80003810:	fe f8 05 24 	ld.w	r8,pc[1316]
80003814:	91 09       	st.w	r8[0x0],r9
80003816:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000381a:	30 09       	mov	r9,0
8000381c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003820:	91 09       	st.w	r8[0x0],r9
80003822:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003826:	fe f8 05 26 	ld.w	r8,pc[1318]
8000382a:	11 89       	ld.ub	r9,r8[0x0]
8000382c:	3f 28       	mov	r8,-14
8000382e:	f0 09 18 00 	cp.b	r9,r8
80003832:	c4 31       	brne	800038b8 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003834:	8e 49       	ld.sh	r9,r7[0x8]
80003836:	fe f8 05 56 	ld.w	r8,pc[1366]
8000383a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000383c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003840:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003844:	72 0a       	ld.w	r10,r9[0x0]
80003846:	70 09       	ld.w	r9,r8[0x0]
80003848:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000384c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003850:	70 09       	ld.w	r9,r8[0x0]
80003852:	2f f9       	sub	r9,-1
80003854:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003856:	e0 49 01 ff 	cp.w	r9,511
8000385a:	e0 88 00 16 	brls	80003886 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000385e:	30 09       	mov	r9,0
80003860:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003862:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003866:	6e 0c       	ld.w	r12,r7[0x0]
80003868:	f0 1f 01 3d 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000386c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003870:	70 0c       	ld.w	r12,r8[0x0]
80003872:	f0 1f 01 28 	mcall	80003d10 <phy_rx_func+0xe98>
80003876:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003878:	c0 71       	brne	80003886 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000387a:	30 09       	mov	r9,0
8000387c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003880:	91 09       	st.w	r8[0x0],r9
80003882:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003886:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000388a:	72 08       	ld.w	r8,r9[0x0]
8000388c:	20 18       	sub	r8,1
8000388e:	93 08       	st.w	r9[0x0],r8
80003890:	c0 71       	brne	8000389e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003892:	30 09       	mov	r9,0
80003894:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003898:	91 09       	st.w	r8[0x0],r9
8000389a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000389e:	20 18       	sub	r8,1
800038a0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800038a4:	93 08       	st.w	r9[0x0],r8
800038a6:	58 08       	cp.w	r8,0
800038a8:	e0 81 02 25 	brne	80003cf2 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800038ac:	30 09       	mov	r9,0
800038ae:	fe f8 04 86 	ld.w	r8,pc[1158]
800038b2:	91 09       	st.w	r8[0x0],r9
800038b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800038b8:	fe f8 04 94 	ld.w	r8,pc[1172]
800038bc:	11 89       	ld.ub	r9,r8[0x0]
800038be:	3f 38       	mov	r8,-13
800038c0:	f0 09 18 00 	cp.b	r9,r8
800038c4:	e0 81 01 0c 	brne	80003adc <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800038c8:	8e 49       	ld.sh	r9,r7[0x8]
800038ca:	fe f8 04 c2 	ld.w	r8,pc[1218]
800038ce:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800038d0:	8e 59       	ld.sh	r9,r7[0xa]
800038d2:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800038d4:	8e 69       	ld.sh	r9,r7[0xc]
800038d6:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800038d8:	fe f8 04 7c 	ld.w	r8,pc[1148]
800038dc:	fe f9 04 54 	ld.w	r9,pc[1108]
800038e0:	72 0a       	ld.w	r10,r9[0x0]
800038e2:	70 09       	ld.w	r9,r8[0x0]
800038e4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800038e8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ec:	70 09       	ld.w	r9,r8[0x0]
800038ee:	2f f9       	sub	r9,-1
800038f0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f2:	e0 49 01 ff 	cp.w	r9,511
800038f6:	e0 88 00 16 	brls	80003922 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800038fa:	30 09       	mov	r9,0
800038fc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038fe:	fe f6 04 32 	ld.w	r6,pc[1074]
80003902:	6c 0c       	ld.w	r12,r6[0x0]
80003904:	f0 1f 01 16 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003908:	fe f8 04 20 	ld.w	r8,pc[1056]
8000390c:	70 0c       	ld.w	r12,r8[0x0]
8000390e:	f0 1f 01 01 	mcall	80003d10 <phy_rx_func+0xe98>
80003912:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003914:	c0 71       	brne	80003922 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003922:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003926:	72 08       	ld.w	r8,r9[0x0]
80003928:	20 18       	sub	r8,1
8000392a:	93 08       	st.w	r9[0x0],r8
8000392c:	c0 71       	brne	8000393a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000392e:	30 09       	mov	r9,0
80003930:	fe f8 04 04 	ld.w	r8,pc[1028]
80003934:	91 09       	st.w	r8[0x0],r9
80003936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000393a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000393e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003942:	72 0a       	ld.w	r10,r9[0x0]
80003944:	70 09       	ld.w	r9,r8[0x0]
80003946:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000394a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000394e:	70 09       	ld.w	r9,r8[0x0]
80003950:	2f f9       	sub	r9,-1
80003952:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003954:	e0 49 01 ff 	cp.w	r9,511
80003958:	e0 88 00 16 	brls	80003984 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000395c:	30 09       	mov	r9,0
8000395e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003960:	fe f6 03 d0 	ld.w	r6,pc[976]
80003964:	6c 0c       	ld.w	r12,r6[0x0]
80003966:	f0 1f 00 fe 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000396a:	fe f8 03 be 	ld.w	r8,pc[958]
8000396e:	70 0c       	ld.w	r12,r8[0x0]
80003970:	f0 1f 00 e8 	mcall	80003d10 <phy_rx_func+0xe98>
80003974:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003976:	c0 71       	brne	80003984 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003984:	fe f9 03 b8 	ld.w	r9,pc[952]
80003988:	72 08       	ld.w	r8,r9[0x0]
8000398a:	20 18       	sub	r8,1
8000398c:	93 08       	st.w	r9[0x0],r8
8000398e:	c0 71       	brne	8000399c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003990:	30 09       	mov	r9,0
80003992:	fe f8 03 a2 	ld.w	r8,pc[930]
80003996:	91 09       	st.w	r8[0x0],r9
80003998:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000399c:	fe f8 03 b8 	ld.w	r8,pc[952]
800039a0:	fe f9 03 90 	ld.w	r9,pc[912]
800039a4:	72 0a       	ld.w	r10,r9[0x0]
800039a6:	70 09       	ld.w	r9,r8[0x0]
800039a8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039ac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039b0:	70 09       	ld.w	r9,r8[0x0]
800039b2:	2f f9       	sub	r9,-1
800039b4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b6:	e0 49 01 ff 	cp.w	r9,511
800039ba:	e0 88 00 16 	brls	800039e6 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039be:	30 09       	mov	r9,0
800039c0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039c2:	fe f6 03 6e 	ld.w	r6,pc[878]
800039c6:	6c 0c       	ld.w	r12,r6[0x0]
800039c8:	f0 1f 00 e5 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039cc:	fe f8 03 5c 	ld.w	r8,pc[860]
800039d0:	70 0c       	ld.w	r12,r8[0x0]
800039d2:	f0 1f 00 d0 	mcall	80003d10 <phy_rx_func+0xe98>
800039d6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039d8:	c0 71       	brne	800039e6 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	fe f8 03 58 	ld.w	r8,pc[856]
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039e6:	fe f9 03 56 	ld.w	r9,pc[854]
800039ea:	72 08       	ld.w	r8,r9[0x0]
800039ec:	20 18       	sub	r8,1
800039ee:	93 08       	st.w	r9[0x0],r8
800039f0:	c0 71       	brne	800039fe <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800039f2:	30 09       	mov	r9,0
800039f4:	fe f8 03 40 	ld.w	r8,pc[832]
800039f8:	91 09       	st.w	r8[0x0],r9
800039fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800039fe:	fe f8 03 56 	ld.w	r8,pc[854]
80003a02:	fe f9 03 2e 	ld.w	r9,pc[814]
80003a06:	72 0a       	ld.w	r10,r9[0x0]
80003a08:	70 09       	ld.w	r9,r8[0x0]
80003a0a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a0e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	2f f9       	sub	r9,-1
80003a16:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a18:	e0 49 01 ff 	cp.w	r9,511
80003a1c:	e0 88 00 16 	brls	80003a48 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a20:	30 09       	mov	r9,0
80003a22:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a24:	fe f6 03 0c 	ld.w	r6,pc[780]
80003a28:	6c 0c       	ld.w	r12,r6[0x0]
80003a2a:	f0 1f 00 cd 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a2e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003a32:	70 0c       	ld.w	r12,r8[0x0]
80003a34:	f0 1f 00 b7 	mcall	80003d10 <phy_rx_func+0xe98>
80003a38:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a3a:	c0 71       	brne	80003a48 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003a3c:	30 09       	mov	r9,0
80003a3e:	fe f8 02 f6 	ld.w	r8,pc[758]
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a48:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a4c:	72 08       	ld.w	r8,r9[0x0]
80003a4e:	20 18       	sub	r8,1
80003a50:	93 08       	st.w	r9[0x0],r8
80003a52:	c0 71       	brne	80003a60 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a54:	30 09       	mov	r9,0
80003a56:	fe f8 02 de 	ld.w	r8,pc[734]
80003a5a:	91 09       	st.w	r8[0x0],r9
80003a5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003a60:	fe f8 02 f4 	ld.w	r8,pc[756]
80003a64:	fe f9 02 cc 	ld.w	r9,pc[716]
80003a68:	72 0a       	ld.w	r10,r9[0x0]
80003a6a:	70 09       	ld.w	r9,r8[0x0]
80003a6c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a70:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a74:	70 09       	ld.w	r9,r8[0x0]
80003a76:	2f f9       	sub	r9,-1
80003a78:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a7a:	e0 49 01 ff 	cp.w	r9,511
80003a7e:	e0 88 00 16 	brls	80003aaa <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a82:	30 09       	mov	r9,0
80003a84:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a86:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a8a:	6e 0c       	ld.w	r12,r7[0x0]
80003a8c:	f0 1f 00 b4 	mcall	80003d5c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a90:	fe f8 02 98 	ld.w	r8,pc[664]
80003a94:	70 0c       	ld.w	r12,r8[0x0]
80003a96:	f0 1f 00 9f 	mcall	80003d10 <phy_rx_func+0xe98>
80003a9a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a9c:	c0 71       	brne	80003aaa <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a9e:	30 09       	mov	r9,0
80003aa0:	fe f8 02 94 	ld.w	r8,pc[660]
80003aa4:	91 09       	st.w	r8[0x0],r9
80003aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003aaa:	fe f9 02 92 	ld.w	r9,pc[658]
80003aae:	72 08       	ld.w	r8,r9[0x0]
80003ab0:	20 18       	sub	r8,1
80003ab2:	93 08       	st.w	r9[0x0],r8
80003ab4:	c0 71       	brne	80003ac2 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	fe f8 02 7c 	ld.w	r8,pc[636]
80003abc:	91 09       	st.w	r8[0x0],r9
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003ac2:	20 18       	sub	r8,1
80003ac4:	fe f9 02 78 	ld.w	r9,pc[632]
80003ac8:	93 08       	st.w	r9[0x0],r8
80003aca:	58 08       	cp.w	r8,0
80003acc:	e0 81 01 13 	brne	80003cf2 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003ad0:	30 09       	mov	r9,0
80003ad2:	fe f8 02 62 	ld.w	r8,pc[610]
80003ad6:	91 09       	st.w	r8[0x0],r9
80003ad8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003adc:	fe f8 02 70 	ld.w	r8,pc[624]
80003ae0:	11 89       	ld.ub	r9,r8[0x0]
80003ae2:	30 48       	mov	r8,4
80003ae4:	f0 09 18 00 	cp.b	r9,r8
80003ae8:	c0 80       	breq	80003af8 <phy_rx_func+0xc80>
80003aea:	fe f8 02 62 	ld.w	r8,pc[610]
80003aee:	11 89       	ld.ub	r9,r8[0x0]
80003af0:	30 38       	mov	r8,3
80003af2:	f0 09 18 00 	cp.b	r9,r8
80003af6:	c1 41       	brne	80003b1e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003af8:	6e 29       	ld.w	r9,r7[0x8]
80003afa:	fe f8 02 7a 	ld.w	r8,pc[634]
80003afe:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b00:	6e 39       	ld.w	r9,r7[0xc]
80003b02:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b04:	fe f9 02 38 	ld.w	r9,pc[568]
80003b08:	72 08       	ld.w	r8,r9[0x0]
80003b0a:	20 88       	sub	r8,8
80003b0c:	93 08       	st.w	r9[0x0],r8
80003b0e:	e0 81 00 f2 	brne	80003cf2 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003b12:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b14:	fe f9 02 20 	ld.w	r9,pc[544]
80003b18:	93 08       	st.w	r9[0x0],r8
80003b1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003b1e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003b22:	11 89       	ld.ub	r9,r8[0x0]
80003b24:	31 38       	mov	r8,19
80003b26:	f0 09 18 00 	cp.b	r9,r8
80003b2a:	e0 81 00 9c 	brne	80003c62 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003b2e:	fe f8 02 62 	ld.w	r8,pc[610]
80003b32:	11 88       	ld.ub	r8,r8[0x0]
80003b34:	30 c9       	mov	r9,12
80003b36:	f2 08 18 00 	cp.b	r8,r9
80003b3a:	e0 81 00 7b 	brne	80003c30 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003b3e:	8e 49       	ld.sh	r9,r7[0x8]
80003b40:	fe f8 02 54 	ld.w	r8,pc[596]
80003b44:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003b48:	30 09       	mov	r9,0
80003b4a:	fe f8 02 46 	ld.w	r8,pc[582]
80003b4e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b50:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b54:	3f 38       	mov	r8,-13
80003b56:	f0 09 18 00 	cp.b	r9,r8
80003b5a:	c6 61       	brne	80003c26 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003b5c:	10 99       	mov	r9,r8
80003b5e:	4f c8       	lddpc	r8,80003d4c <phy_rx_func+0xed4>
80003b60:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003b62:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003b66:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003b6a:	4f 58       	lddpc	r8,80003d3c <phy_rx_func+0xec4>
80003b6c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b6e:	30 19       	mov	r9,1
80003b70:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b74:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b76:	8e 79       	ld.sh	r9,r7[0xe]
80003b78:	fe f8 02 14 	ld.w	r8,pc[532]
80003b7c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b7e:	4f 68       	lddpc	r8,80003d54 <phy_rx_func+0xedc>
80003b80:	4e c9       	lddpc	r9,80003d30 <phy_rx_func+0xeb8>
80003b82:	72 0a       	ld.w	r10,r9[0x0]
80003b84:	70 09       	ld.w	r9,r8[0x0]
80003b86:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b8a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b8e:	70 09       	ld.w	r9,r8[0x0]
80003b90:	2f f9       	sub	r9,-1
80003b92:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b94:	e0 49 01 ff 	cp.w	r9,511
80003b98:	e0 88 00 13 	brls	80003bbe <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b9c:	30 09       	mov	r9,0
80003b9e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ba0:	4e 46       	lddpc	r6,80003d30 <phy_rx_func+0xeb8>
80003ba2:	6c 0c       	ld.w	r12,r6[0x0]
80003ba4:	f0 1f 00 6e 	mcall	80003d5c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ba8:	4e 08       	lddpc	r8,80003d28 <phy_rx_func+0xeb0>
80003baa:	70 0c       	ld.w	r12,r8[0x0]
80003bac:	f0 1f 00 59 	mcall	80003d10 <phy_rx_func+0xe98>
80003bb0:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003bb2:	c0 61       	brne	80003bbe <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003bb4:	30 09       	mov	r9,0
80003bb6:	4e 08       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003bb8:	91 09       	st.w	r8[0x0],r9
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003bbe:	4e 09       	lddpc	r9,80003d3c <phy_rx_func+0xec4>
80003bc0:	72 08       	ld.w	r8,r9[0x0]
80003bc2:	20 18       	sub	r8,1
80003bc4:	93 08       	st.w	r9[0x0],r8
80003bc6:	c0 61       	brne	80003bd2 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003bc8:	30 09       	mov	r9,0
80003bca:	4d b8       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003bcc:	91 09       	st.w	r8[0x0],r9
80003bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003bd2:	4e 18       	lddpc	r8,80003d54 <phy_rx_func+0xedc>
80003bd4:	4d 79       	lddpc	r9,80003d30 <phy_rx_func+0xeb8>
80003bd6:	72 0a       	ld.w	r10,r9[0x0]
80003bd8:	70 09       	ld.w	r9,r8[0x0]
80003bda:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003bde:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003be2:	70 09       	ld.w	r9,r8[0x0]
80003be4:	2f f9       	sub	r9,-1
80003be6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003be8:	e0 49 01 ff 	cp.w	r9,511
80003bec:	e0 88 00 13 	brls	80003c12 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003bf0:	30 09       	mov	r9,0
80003bf2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003bf4:	4c f7       	lddpc	r7,80003d30 <phy_rx_func+0xeb8>
80003bf6:	6e 0c       	ld.w	r12,r7[0x0]
80003bf8:	f0 1f 00 59 	mcall	80003d5c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bfc:	4c b8       	lddpc	r8,80003d28 <phy_rx_func+0xeb0>
80003bfe:	70 0c       	ld.w	r12,r8[0x0]
80003c00:	f0 1f 00 44 	mcall	80003d10 <phy_rx_func+0xe98>
80003c04:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c06:	c0 61       	brne	80003c12 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003c08:	30 09       	mov	r9,0
80003c0a:	4c b8       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c0c:	91 09       	st.w	r8[0x0],r9
80003c0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c12:	4c b9       	lddpc	r9,80003d3c <phy_rx_func+0xec4>
80003c14:	72 08       	ld.w	r8,r9[0x0]
80003c16:	20 18       	sub	r8,1
80003c18:	93 08       	st.w	r9[0x0],r8
80003c1a:	c6 c1       	brne	80003cf2 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003c1c:	30 09       	mov	r9,0
80003c1e:	4c 68       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c20:	91 09       	st.w	r8[0x0],r9
80003c22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003c26:	30 09       	mov	r9,0
80003c28:	4c 38       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003c30:	8e 4a       	ld.sh	r10,r7[0x8]
80003c32:	4d 99       	lddpc	r9,80003d94 <phy_rx_func+0xf1c>
80003c34:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003c38:	4d 6a       	lddpc	r10,80003d90 <phy_rx_func+0xf18>
80003c3a:	15 88       	ld.ub	r8,r10[0x0]
80003c3c:	f0 cb ff ff 	sub	r11,r8,-1
80003c40:	8e 5c       	ld.sh	r12,r7[0xa]
80003c42:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003c46:	f0 cb ff fe 	sub	r11,r8,-2
80003c4a:	8e 6c       	ld.sh	r12,r7[0xc]
80003c4c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c50:	f0 cb ff fd 	sub	r11,r8,-3
80003c54:	8e 7c       	ld.sh	r12,r7[0xe]
80003c56:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003c5a:	2f c8       	sub	r8,-4
80003c5c:	b4 88       	st.b	r10[0x0],r8
80003c5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003c62:	30 09       	mov	r9,0
80003c64:	4b 48       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003c6c:	4c 08       	lddpc	r8,80003d6c <phy_rx_func+0xef4>
80003c6e:	70 09       	ld.w	r9,r8[0x0]
80003c70:	8e 4b       	ld.sh	r11,r7[0x8]
80003c72:	4c 0a       	lddpc	r10,80003d70 <phy_rx_func+0xef8>
80003c74:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c78:	2f f9       	sub	r9,-1
80003c7a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c7c:	4b 58       	lddpc	r8,80003d50 <phy_rx_func+0xed8>
80003c7e:	70 09       	ld.w	r9,r8[0x0]
80003c80:	20 29       	sub	r9,2
80003c82:	91 09       	st.w	r8[0x0],r9
80003c84:	70 08       	ld.w	r8,r8[0x0]
80003c86:	58 08       	cp.w	r8,0
80003c88:	c2 f1       	brne	80003ce6 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c8a:	30 09       	mov	r9,0
80003c8c:	4b 88       	lddpc	r8,80003d6c <phy_rx_func+0xef4>
80003c8e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c90:	8e 59       	ld.sh	r9,r7[0xa]
80003c92:	fe 78 82 12 	mov	r8,-32238
80003c96:	f0 09 19 00 	cp.h	r9,r8
80003c9a:	c2 11       	brne	80003cdc <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c9c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003ca0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003ca4:	4a f8       	lddpc	r8,80003d60 <phy_rx_func+0xee8>
80003ca6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003ca8:	8e 59       	ld.sh	r9,r7[0xa]
80003caa:	4a f8       	lddpc	r8,80003d64 <phy_rx_func+0xeec>
80003cac:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003cae:	8e 69       	ld.sh	r9,r7[0xc]
80003cb0:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003cb2:	f0 1f 00 2e 	mcall	80003d68 <phy_rx_func+0xef0>
80003cb6:	4a 18       	lddpc	r8,80003d38 <phy_rx_func+0xec0>
80003cb8:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cba:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003cbe:	31 38       	mov	r8,19
80003cc0:	f0 09 18 00 	cp.b	r9,r8
80003cc4:	c0 71       	brne	80003cd2 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003cc6:	10 99       	mov	r9,r8
80003cc8:	4a 18       	lddpc	r8,80003d4c <phy_rx_func+0xed4>
80003cca:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003ccc:	30 09       	mov	r9,0
80003cce:	49 c8       	lddpc	r8,80003d3c <phy_rx_func+0xec4>
80003cd0:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003cd2:	30 49       	mov	r9,4
80003cd4:	49 88       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003cd6:	91 09       	st.w	r8[0x0],r9
80003cd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003cdc:	30 09       	mov	r9,0
80003cde:	49 68       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003ce0:	91 09       	st.w	r8[0x0],r9
80003ce2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ce6:	4a dc       	lddpc	r12,80003d98 <phy_rx_func+0xf20>
80003ce8:	f0 1f 00 18 	mcall	80003d48 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003cec:	30 09       	mov	r9,0
80003cee:	49 28       	lddpc	r8,80003d34 <phy_rx_func+0xebc>
80003cf0:	91 09       	st.w	r8[0x0],r9
80003cf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003cf6:	00 00       	add	r0,r0
80003cf8:	00 00       	add	r0,r0
80003cfa:	0a b8       	st.h	r5++,r8
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a d4       	st.w	--r5,r4
80003d00:	00 00       	add	r0,r0
80003d02:	0a b0       	st.h	r5++,r0
80003d04:	00 00       	add	r0,r0
80003d06:	0a 90       	mov	r0,r5
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 80       	andn	r0,r5
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a a4       	st.w	r5++,r4
80003d10:	80 00       	ld.sh	r0,r0[0x0]
80003d12:	2c 98       	sub	r8,-55
80003d14:	00 00       	add	r0,r0
80003d16:	0a d8       	st.w	--r5,r8
80003d18:	80 00       	ld.sh	r0,r0[0x0]
80003d1a:	2b c8       	sub	r8,-68
80003d1c:	00 00       	add	r0,r0
80003d1e:	0a b4       	st.h	r5++,r4
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	2b e4       	sub	r4,-66
80003d24:	00 00       	add	r0,r0
80003d26:	0a e4       	st.h	--r5,r4
80003d28:	00 00       	add	r0,r0
80003d2a:	0a ac       	st.w	r5++,r12
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a c8       	st.b	r5++,r8
80003d30:	00 00       	add	r0,r0
80003d32:	0a 9c       	mov	r12,r5
80003d34:	00 00       	add	r0,r0
80003d36:	0a ec       	st.h	--r5,r12
80003d38:	00 00       	add	r0,r0
80003d3a:	0a c4       	st.b	r5++,r4
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a 8c       	andn	r12,r5
80003d40:	00 00       	add	r0,r0
80003d42:	0a 56       	eor	r6,r5
80003d44:	80 00       	ld.sh	r0,r0[0x0]
80003d46:	df 84       	*unknown*
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	78 f4       	ld.w	r4,r12[0x3c]
80003d4c:	00 00       	add	r0,r0
80003d4e:	0a 98       	mov	r8,r5
80003d50:	00 00       	add	r0,r0
80003d52:	0a 7c       	tst	r12,r5
80003d54:	00 00       	add	r0,r0
80003d56:	0a e0       	st.h	--r5,r0
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	81 5e       	st.w	r0[0x14],lr
80003d5c:	80 00       	ld.sh	r0,r0[0x0]
80003d5e:	2e 18       	sub	r8,-31
80003d60:	00 00       	add	r0,r0
80003d62:	0a 52       	eor	r2,r5
80003d64:	00 00       	add	r0,r0
80003d66:	21 90       	sub	r0,25
80003d68:	80 00       	ld.sh	r0,r0[0x0]
80003d6a:	2b 28       	sub	r8,-78
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a c0       	st.b	r5++,r0
80003d70:	00 00       	add	r0,r0
80003d72:	20 94       	sub	r4,9
80003d74:	00 00       	add	r0,r0
80003d76:	0a 84       	andn	r4,r5
80003d78:	00 00       	add	r0,r0
80003d7a:	0a 53       	eor	r3,r5
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a 51       	eor	r1,r5
80003d80:	00 00       	add	r0,r0
80003d82:	0a 74       	tst	r4,r5
80003d84:	00 00       	add	r0,r0
80003d86:	0a a8       	st.w	r5++,r8
80003d88:	00 00       	add	r0,r0
80003d8a:	0a 65       	and	r5,r5
80003d8c:	00 00       	add	r0,r0
80003d8e:	20 8c       	sub	r12,8
80003d90:	00 00       	add	r0,r0
80003d92:	0a d0       	st.w	--r5,r0
80003d94:	00 00       	add	r0,r0
80003d96:	21 94       	sub	r4,25
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	df 9c       	*unknown*

80003d9c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d9c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d9e:	49 88       	lddpc	r8,80003dfc <pdca_int_handler+0x60>
80003da0:	11 89       	ld.ub	r9,r8[0x0]
80003da2:	ec 19 00 01 	eorl	r9,0x1
80003da6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003da8:	11 89       	ld.ub	r9,r8[0x0]
80003daa:	a5 69       	lsl	r9,0x4
80003dac:	2f c9       	sub	r9,-4
80003dae:	49 5a       	lddpc	r10,80003e00 <pdca_int_handler+0x64>
80003db0:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003db2:	fe 7a 00 40 	mov	r10,-65472
80003db6:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003db8:	30 39       	mov	r9,3
80003dba:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003dbc:	11 8a       	ld.ub	r10,r8[0x0]
80003dbe:	a5 6a       	lsl	r10,0x4
80003dc0:	2f ca       	sub	r10,-4
80003dc2:	49 18       	lddpc	r8,80003e04 <pdca_int_handler+0x68>
80003dc4:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003dc6:	fe 78 00 00 	mov	r8,-65536
80003dca:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dcc:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003dce:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003dd0:	48 e8       	lddpc	r8,80003e08 <pdca_int_handler+0x6c>
80003dd2:	70 08       	ld.w	r8,r8[0x0]
80003dd4:	58 08       	cp.w	r8,0
80003dd6:	c0 70       	breq	80003de4 <pdca_int_handler+0x48>
80003dd8:	48 99       	lddpc	r9,80003dfc <pdca_int_handler+0x60>
80003dda:	13 89       	ld.ub	r9,r9[0x0]
80003ddc:	a5 69       	lsl	r9,0x4
80003dde:	48 ac       	lddpc	r12,80003e04 <pdca_int_handler+0x68>
80003de0:	12 0c       	add	r12,r9
80003de2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003de4:	48 a8       	lddpc	r8,80003e0c <pdca_int_handler+0x70>
80003de6:	70 08       	ld.w	r8,r8[0x0]
80003de8:	58 08       	cp.w	r8,0
80003dea:	c0 70       	breq	80003df8 <pdca_int_handler+0x5c>
80003dec:	48 49       	lddpc	r9,80003dfc <pdca_int_handler+0x60>
80003dee:	13 89       	ld.ub	r9,r9[0x0]
80003df0:	a5 69       	lsl	r9,0x4
80003df2:	48 4c       	lddpc	r12,80003e00 <pdca_int_handler+0x64>
80003df4:	12 0c       	add	r12,r9
80003df6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003df8:	d4 02       	popm	lr
80003dfa:	d6 03       	rete
80003dfc:	00 00       	add	r0,r0
80003dfe:	53 b4       	stdsp	sp[0xec],r4
80003e00:	00 00       	add	r0,r0
80003e02:	53 dc       	stdsp	sp[0xf4],r12
80003e04:	00 00       	add	r0,r0
80003e06:	53 bc       	stdsp	sp[0xec],r12
80003e08:	00 00       	add	r0,r0
80003e0a:	0a f0       	st.b	--r5,r0
80003e0c:	00 00       	add	r0,r0
80003e0e:	0a f4       	st.b	--r5,r4

80003e10 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003e10:	fe 78 10 00 	mov	r8,-61440
80003e14:	e0 69 0d c0 	mov	r9,3520
80003e18:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003e1c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003e20:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003e24:	fe 78 34 00 	mov	r8,-52224
80003e28:	e0 69 80 00 	mov	r9,32768
80003e2c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003e2e:	30 09       	mov	r9,0
80003e30:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003e32:	e0 69 04 21 	mov	r9,1057
80003e36:	ea 19 3f 20 	orh	r9,0x3f20
80003e3a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003e3c:	e0 69 02 9f 	mov	r9,671
80003e40:	ea 19 01 00 	orh	r9,0x100
80003e44:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e46:	e0 6a 04 02 	mov	r10,1026
80003e4a:	ea 1a 3f 20 	orh	r10,0x3f20
80003e4e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003e50:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003e52:	5e fc       	retal	r12

80003e54 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003e54:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003e56:	30 19       	mov	r9,1
80003e58:	49 78       	lddpc	r8,80003eb4 <local_start_PDC+0x60>
80003e5a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e5c:	fe 78 00 00 	mov	r8,-65536
80003e60:	30 7b       	mov	r11,7
80003e62:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e64:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e66:	49 59       	lddpc	r9,80003eb8 <local_start_PDC+0x64>
80003e68:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e6c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e6e:	30 3a       	mov	r10,3
80003e70:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e72:	30 1c       	mov	r12,1
80003e74:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e76:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e78:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e7a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e7c:	30 2c       	mov	r12,2
80003e7e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e80:	48 f9       	lddpc	r9,80003ebc <local_start_PDC+0x68>
80003e82:	e0 68 5a 5a 	mov	r8,23130
80003e86:	ea 18 ab cd 	orh	r8,0xabcd
80003e8a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e8c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e8e:	30 0e       	mov	lr,0
80003e90:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e92:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e94:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e96:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e98:	fe 78 00 40 	mov	r8,-65472
80003e9c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e9e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003ea0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003ea4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003ea6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003ea8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003eaa:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003eac:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003eae:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003eb0:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003eb2:	d8 02       	popm	pc
80003eb4:	00 00       	add	r0,r0
80003eb6:	53 b4       	stdsp	sp[0xec],r4
80003eb8:	00 00       	add	r0,r0
80003eba:	53 bc       	stdsp	sp[0xec],r12
80003ebc:	00 00       	add	r0,r0
80003ebe:	53 dc       	stdsp	sp[0xf4],r12

80003ec0 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003ec0:	48 38       	lddpc	r8,80003ecc <register_rx_tx_func+0xc>
80003ec2:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003ec4:	48 38       	lddpc	r8,80003ed0 <register_rx_tx_func+0x10>
80003ec6:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003ec8:	5e fc       	retal	r12
80003eca:	00 00       	add	r0,r0
80003ecc:	00 00       	add	r0,r0
80003ece:	0a f0       	st.b	--r5,r0
80003ed0:	00 00       	add	r0,r0
80003ed2:	0a f4       	st.b	--r5,r4

80003ed4 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003ed4:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003ed6:	fe 78 10 00 	mov	r8,-61440
80003eda:	30 29       	mov	r9,2
80003edc:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003ee0:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003ee4:	30 3a       	mov	r10,3
80003ee6:	36 0b       	mov	r11,96
80003ee8:	49 3c       	lddpc	r12,80003f34 <ssc_init+0x60>
80003eea:	f0 1f 00 14 	mcall	80003f38 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003eee:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003ef0:	fe 79 10 00 	mov	r9,-61440
80003ef4:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ef8:	e2 18 00 02 	andl	r8,0x2,COH
80003efc:	cf c0       	breq	80003ef4 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003efe:	fe 79 10 00 	mov	r9,-61440
80003f02:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f06:	e2 18 00 02 	andl	r8,0x2,COH
80003f0a:	cf c1       	brne	80003f02 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003f0c:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003f0e:	f0 1f 00 0c 	mcall	80003f3c <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003f12:	f0 1f 00 0c 	mcall	80003f40 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f16:	fe 79 00 00 	mov	r9,-65536
80003f1a:	30 18       	mov	r8,1
80003f1c:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f1e:	fe 7a 00 40 	mov	r10,-65472
80003f22:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003f24:	e0 6b 01 01 	mov	r11,257
80003f28:	fe 7a 34 00 	mov	r10,-52224
80003f2c:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003f2e:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003f30:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f32:	d8 02       	popm	pc
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	3d 9c       	mov	r12,-39
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	5d 20       	mustr	r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e 10       	mov	r0,-31
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	3e 54       	mov	r4,-27

80003f44 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f44:	48 28       	lddpc	r8,80003f4c <xcmp_register_app_list+0x8>
80003f46:	91 0c       	st.w	r8[0x0],r12
}
80003f48:	5e fc       	retal	r12
80003f4a:	00 00       	add	r0,r0
80003f4c:	00 00       	add	r0,r0
80003f4e:	53 fc       	stdsp	sp[0xfc],r12

80003f50 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003f50:	eb cd 40 80 	pushm	r7,lr
80003f54:	fa cd 01 00 	sub	sp,sp,256
80003f58:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f5a:	16 98       	mov	r8,r11
80003f5c:	2f 08       	sub	r8,-16
80003f5e:	af a8       	sbr	r8,0xe
80003f60:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f62:	3f f8       	mov	r8,-1
80003f64:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f66:	30 b9       	mov	r9,11
80003f68:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f6a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f6c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f6e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f70:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f72:	f6 ca ff fe 	sub	r10,r11,-2
80003f76:	18 9b       	mov	r11,r12
80003f78:	fa cc ff f0 	sub	r12,sp,-16
80003f7c:	f0 1f 00 05 	mcall	80003f90 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f80:	2f e7       	sub	r7,-2
80003f82:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f84:	1a 9c       	mov	r12,sp
80003f86:	f0 1f 00 04 	mcall	80003f94 <xcmp_tx+0x44>
}
80003f8a:	2c 0d       	sub	sp,-256
80003f8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	80 16       	ld.sh	r6,r0[0x2]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	45 5c       	lddsp	r12,sp[0x154]

80003f98 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f98:	d4 21       	pushm	r4-r7,lr
80003f9a:	fa cd 00 d0 	sub	sp,sp,208
80003f9e:	18 94       	mov	r4,r12
80003fa0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003fa2:	e0 68 01 00 	mov	r8,256
80003fa6:	f0 0b 19 00 	cp.h	r11,r8
80003faa:	e0 8b 00 36 	brhi	80004016 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003fae:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003fb2:	e0 68 04 1d 	mov	r8,1053
80003fb6:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003fb8:	30 18       	mov	r8,1
80003fba:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003fbc:	32 08       	mov	r8,32
80003fbe:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003fc0:	30 28       	mov	r8,2
80003fc2:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003fc4:	30 48       	mov	r8,4
80003fc6:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003fc8:	ea 1a 0c 00 	orh	r10,0xc00
80003fcc:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003fce:	30 4a       	mov	r10,4
80003fd0:	1a 9b       	mov	r11,sp
80003fd2:	fa cc ff f4 	sub	r12,sp,-12
80003fd6:	f0 1f 00 12 	mcall	8000401c <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003fda:	30 f8       	mov	r8,15
80003fdc:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003fe0:	3a 78       	mov	r8,-89
80003fe2:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003fe6:	30 08       	mov	r8,0
80003fe8:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003fec:	0e 9a       	mov	r10,r7
80003fee:	5c 7a       	castu.h	r10
80003ff0:	f4 08 16 08 	lsr	r8,r10,0x8
80003ff4:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003ff8:	0e 96       	mov	r6,r7
80003ffa:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003ffe:	08 9b       	mov	r11,r4
80004000:	fa cc ff eb 	sub	r12,sp,-21
80004004:	f0 1f 00 06 	mcall	8000401c <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004008:	ee cb ff f3 	sub	r11,r7,-13
8000400c:	5c 5b       	castu.b	r11
8000400e:	fa cc ff fa 	sub	r12,sp,-6
80004012:	f0 1f 00 04 	mcall	80004020 <xcmp_data_session_req+0x88>
}
80004016:	2c cd       	sub	sp,-208
80004018:	d8 22       	popm	r4-r7,pc
8000401a:	00 00       	add	r0,r0
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	80 16       	ld.sh	r6,r0[0x2]
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	3f 50       	mov	r0,-11

80004024 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004024:	d4 01       	pushm	lr
80004026:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000402a:	fe 78 b4 00 	mov	r8,-19456
8000402e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004030:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004034:	30 89       	mov	r9,8
80004036:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004038:	30 19       	mov	r9,1
8000403a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
8000403c:	30 09       	mov	r9,0
8000403e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004040:	30 5a       	mov	r10,5
80004042:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004044:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004046:	30 7a       	mov	r10,7
80004048:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000404a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000404c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000404e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004052:	30 9b       	mov	r11,9
80004054:	fa cc ff fe 	sub	r12,sp,-2
80004058:	f0 1f 00 02 	mcall	80004060 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000405c:	2c dd       	sub	sp,-204
8000405e:	d8 02       	popm	pc
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	3f 50       	mov	r0,-11

80004064 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004064:	d4 01       	pushm	lr
80004066:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000406a:	fe 78 80 00 	mov	r8,-32768
8000406e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004070:	30 38       	mov	r8,3
80004072:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004074:	30 1b       	mov	r11,1
80004076:	fa cc ff fe 	sub	r12,sp,-2
8000407a:	f0 1f 00 03 	mcall	80004084 <xcmp_opcode_not_supported+0x20>
}
8000407e:	2c dd       	sub	sp,-204
80004080:	d8 02       	popm	pc
80004082:	00 00       	add	r0,r0
80004084:	80 00       	ld.sh	r0,r0[0x0]
80004086:	3f 50       	mov	r0,-11

80004088 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004088:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000408a:	96 88       	ld.uh	r8,r11[0x0]
8000408c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004090:	e0 48 80 00 	cp.w	r8,32768
80004094:	c0 f0       	breq	800040b2 <xcmp_exec_func+0x2a>
80004096:	e0 48 b0 00 	cp.w	r8,45056
8000409a:	c1 20       	breq	800040be <xcmp_exec_func+0x36>
8000409c:	58 08       	cp.w	r8,0
8000409e:	c1 51       	brne	800040c8 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800040a0:	78 08       	ld.w	r8,r12[0x0]
800040a2:	58 08       	cp.w	r8,0
800040a4:	c0 40       	breq	800040ac <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800040a6:	16 9c       	mov	r12,r11
800040a8:	5d 18       	icall	r8
800040aa:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800040ac:	f0 1f 00 08 	mcall	800040cc <xcmp_exec_func+0x44>
800040b0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800040b2:	78 18       	ld.w	r8,r12[0x4]
800040b4:	58 08       	cp.w	r8,0
800040b6:	c0 90       	breq	800040c8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800040b8:	16 9c       	mov	r12,r11
800040ba:	5d 18       	icall	r8
800040bc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800040be:	78 28       	ld.w	r8,r12[0x8]
800040c0:	58 08       	cp.w	r8,0
800040c2:	c0 30       	breq	800040c8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800040c4:	16 9c       	mov	r12,r11
800040c6:	5d 18       	icall	r8
800040c8:	d8 02       	popm	pc
800040ca:	00 00       	add	r0,r0
800040cc:	80 00       	ld.sh	r0,r0[0x0]
800040ce:	40 64       	lddsp	r4,sp[0x18]

800040d0 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800040d0:	d4 01       	pushm	lr
800040d2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800040d6:	e0 68 04 09 	mov	r8,1033
800040da:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800040dc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800040e0:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800040e2:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800040e6:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800040e8:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800040ea:	30 09       	mov	r9,0
800040ec:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800040ee:	fb 69 00 08 	st.b	sp[8],r9
800040f2:	fa c8 ff f7 	sub	r8,sp,-9
800040f6:	b0 89       	st.b	r8[0x0],r9
800040f8:	fa c8 ff f6 	sub	r8,sp,-10
800040fc:	b0 89       	st.b	r8[0x0],r9
800040fe:	fa c8 ff f5 	sub	r8,sp,-11
80004102:	b0 89       	st.b	r8[0x0],r9
80004104:	fa c8 ff f4 	sub	r8,sp,-12
80004108:	b0 89       	st.b	r8[0x0],r9
8000410a:	fa c8 ff f3 	sub	r8,sp,-13
8000410e:	b0 89       	st.b	r8[0x0],r9
80004110:	fa c8 ff f2 	sub	r8,sp,-14
80004114:	b0 89       	st.b	r8[0x0],r9
80004116:	fa c8 ff f1 	sub	r8,sp,-15
8000411a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000411c:	30 cb       	mov	r11,12
8000411e:	fa cc ff fe 	sub	r12,sp,-2
80004122:	f0 1f 00 03 	mcall	8000412c <xcmp_IdleTestTone+0x5c>
}
80004126:	2c dd       	sub	sp,-204
80004128:	d8 02       	popm	pc
8000412a:	00 00       	add	r0,r0
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	3f 50       	mov	r0,-11

80004130 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004130:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004132:	48 dc       	lddpc	r12,80004164 <xcmp_init+0x34>
80004134:	f0 1f 00 0d 	mcall	80004168 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004138:	30 4b       	mov	r11,4
8000413a:	31 4c       	mov	r12,20
8000413c:	f0 1f 00 0c 	mcall	8000416c <xcmp_init+0x3c>
80004140:	48 c8       	lddpc	r8,80004170 <xcmp_init+0x40>
80004142:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004144:	30 09       	mov	r9,0
80004146:	1a d9       	st.w	--sp,r9
80004148:	1a d9       	st.w	--sp,r9
8000414a:	1a d9       	st.w	--sp,r9
8000414c:	30 38       	mov	r8,3
8000414e:	e0 6a 01 80 	mov	r10,384
80004152:	48 9b       	lddpc	r11,80004174 <xcmp_init+0x44>
80004154:	48 9c       	lddpc	r12,80004178 <xcmp_init+0x48>
80004156:	f0 1f 00 0a 	mcall	8000417c <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
8000415a:	f0 1f 00 0a 	mcall	80004180 <xcmp_init+0x50>
8000415e:	2f dd       	sub	sp,-12
	
}
80004160:	d8 02       	popm	pc
80004162:	00 00       	add	r0,r0
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	42 80       	lddsp	r0,sp[0xa0]
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	42 cc       	lddsp	r12,sp[0xb0]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	6c 88       	ld.w	r8,r6[0x20]
80004170:	00 00       	add	r0,r0
80004172:	0b 10       	ld.sh	r0,r5++
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	df c8       	*unknown*
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	41 84       	lddsp	r4,sp[0x60]
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	73 a4       	ld.w	r4,r9[0x68]
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	43 04       	lddsp	r4,sp[0xc0]

80004184 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004184:	d4 31       	pushm	r0-r7,lr
80004186:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004188:	4b 16       	lddpc	r6,8000424c <xcmp_rx_process+0xc8>
8000418a:	30 05       	mov	r5,0
8000418c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000418e:	4b 13       	lddpc	r3,80004250 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004190:	4b 12       	lddpc	r2,80004254 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004192:	4b 21       	lddpc	r1,80004258 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004194:	4b 20       	lddpc	r0,8000425c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004196:	6c 0c       	ld.w	r12,r6[0x0]
80004198:	0a 99       	mov	r9,r5
8000419a:	08 9a       	mov	r10,r4
8000419c:	1a 9b       	mov	r11,sp
8000419e:	f0 1f 00 31 	mcall	80004260 <xcmp_rx_process+0xdc>
800041a2:	58 1c       	cp.w	r12,1
800041a4:	cf 91       	brne	80004196 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800041a6:	40 0b       	lddsp	r11,sp[0x0]
800041a8:	58 0b       	cp.w	r11,0
800041aa:	cf 60       	breq	80004196 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800041ac:	96 0a       	ld.sh	r10,r11[0x0]
800041ae:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800041b2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800041b6:	59 c8       	cp.w	r8,28
800041b8:	c1 e0       	breq	800041f4 <xcmp_rx_process+0x70>
800041ba:	e0 89 00 07 	brgt	800041c8 <xcmp_rx_process+0x44>
800041be:	58 e8       	cp.w	r8,14
800041c0:	c0 e0       	breq	800041dc <xcmp_rx_process+0x58>
800041c2:	58 f8       	cp.w	r8,15
800041c4:	c2 41       	brne	8000420c <xcmp_rx_process+0x88>
800041c6:	c0 f8       	rjmp	800041e4 <xcmp_rx_process+0x60>
800041c8:	e0 48 01 09 	cp.w	r8,265
800041cc:	c1 80       	breq	800041fc <xcmp_rx_process+0x78>
800041ce:	e0 48 01 0a 	cp.w	r8,266
800041d2:	c1 90       	breq	80004204 <xcmp_rx_process+0x80>
800041d4:	e0 48 00 2c 	cp.w	r8,44
800041d8:	c1 a1       	brne	8000420c <xcmp_rx_process+0x88>
800041da:	c0 98       	rjmp	800041ec <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800041dc:	4a 2c       	lddpc	r12,80004264 <xcmp_rx_process+0xe0>
800041de:	f0 1f 00 23 	mcall	80004268 <xcmp_rx_process+0xe4>
					break;
800041e2:	c2 f8       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800041e4:	4a 2c       	lddpc	r12,8000426c <xcmp_rx_process+0xe8>
800041e6:	f0 1f 00 21 	mcall	80004268 <xcmp_rx_process+0xe4>
					break;
800041ea:	c2 b8       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800041ec:	4a 1c       	lddpc	r12,80004270 <xcmp_rx_process+0xec>
800041ee:	f0 1f 00 1f 	mcall	80004268 <xcmp_rx_process+0xe4>
					break;
800041f2:	c2 78       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041f4:	04 9c       	mov	r12,r2
800041f6:	f0 1f 00 1d 	mcall	80004268 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041fa:	c2 38       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041fc:	02 9c       	mov	r12,r1
800041fe:	f0 1f 00 1b 	mcall	80004268 <xcmp_rx_process+0xe4>
					break;
80004202:	c1 f8       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004204:	00 9c       	mov	r12,r0
80004206:	f0 1f 00 19 	mcall	80004268 <xcmp_rx_process+0xe4>
					break;
8000420a:	c1 b8       	rjmp	80004240 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000420c:	12 98       	mov	r8,r9
8000420e:	e2 18 04 00 	andl	r8,0x400,COH
80004212:	c0 70       	breq	80004220 <xcmp_rx_process+0x9c>
80004214:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004218:	e0 48 00 68 	cp.w	r8,104
8000421c:	e0 8a 00 08 	brle	8000422c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004220:	e2 19 f0 00 	andl	r9,0xf000,COH
80004224:	c0 e1       	brne	80004240 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004226:	f0 1f 00 14 	mcall	80004274 <xcmp_rx_process+0xf0>
8000422a:	c0 b8       	rjmp	80004240 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000422c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004230:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004234:	49 19       	lddpc	r9,80004278 <xcmp_rx_process+0xf4>
80004236:	72 08       	ld.w	r8,r9[0x0]
80004238:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000423c:	f0 1f 00 0b 	mcall	80004268 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004240:	66 0c       	ld.w	r12,r3[0x0]
80004242:	40 0b       	lddsp	r11,sp[0x0]
80004244:	f0 1f 00 0e 	mcall	8000427c <xcmp_rx_process+0xf8>
80004248:	ca 7b       	rjmp	80004196 <xcmp_rx_process+0x12>
8000424a:	00 00       	add	r0,r0
8000424c:	00 00       	add	r0,r0
8000424e:	0b 10       	ld.sh	r0,r5++
80004250:	00 00       	add	r0,r0
80004252:	0a a4       	st.w	r5++,r4
80004254:	00 00       	add	r0,r0
80004256:	0b 20       	ld.uh	r0,r5++
80004258:	00 00       	add	r0,r0
8000425a:	0b 14       	ld.sh	r4,r5++
8000425c:	00 00       	add	r0,r0
8000425e:	0b 04       	ld.w	r4,r5++
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	69 24       	ld.w	r4,r4[0x48]
80004264:	00 00       	add	r0,r0
80004266:	0b 38       	ld.ub	r8,r5++
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	40 88       	lddsp	r8,sp[0x20]
8000426c:	00 00       	add	r0,r0
8000426e:	0a f8       	st.b	--r5,r8
80004270:	00 00       	add	r0,r0
80004272:	0b 2c       	ld.uh	r12,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	40 64       	lddsp	r4,sp[0x18]
80004278:	00 00       	add	r0,r0
8000427a:	53 fc       	stdsp	sp[0xfc],r12
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	2c 1c       	sub	r12,-63

80004280 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004280:	eb cd 40 90 	pushm	r4,r7,lr
80004284:	20 1d       	sub	sp,4
80004286:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000428a:	48 c8       	lddpc	r8,800042b8 <xcmp_rx+0x38>
8000428c:	70 0c       	ld.w	r12,r8[0x0]
8000428e:	f0 1f 00 0c 	mcall	800042bc <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004292:	c1 00       	breq	800042b2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004294:	fa c7 ff fc 	sub	r7,sp,-4
80004298:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000429a:	e0 6a 00 ca 	mov	r10,202
8000429e:	08 9b       	mov	r11,r4
800042a0:	f0 1f 00 08 	mcall	800042c0 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800042a4:	48 88       	lddpc	r8,800042c4 <xcmp_rx+0x44>
800042a6:	70 0c       	ld.w	r12,r8[0x0]
800042a8:	30 09       	mov	r9,0
800042aa:	12 9a       	mov	r10,r9
800042ac:	1a 9b       	mov	r11,sp
800042ae:	f0 1f 00 07 	mcall	800042c8 <xcmp_rx+0x48>
	}	
}
800042b2:	2f fd       	sub	sp,-4
800042b4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800042b8:	00 00       	add	r0,r0
800042ba:	0a a4       	st.w	r5++,r4
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	2d c8       	sub	r8,-36
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	80 16       	ld.sh	r6,r0[0x2]
800042c4:	00 00       	add	r0,r0
800042c6:	0b 10       	ld.sh	r0,r5++
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	6b 30       	ld.w	r0,r5[0x4c]

800042cc <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800042cc:	48 28       	lddpc	r8,800042d4 <xnl_register_xcmp_func+0x8>
800042ce:	91 0c       	st.w	r8[0x0],r12
}
800042d0:	5e fc       	retal	r12
800042d2:	00 00       	add	r0,r0
800042d4:	00 00       	add	r0,r0
800042d6:	0b 64       	ld.uh	r4,--r5

800042d8 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800042d8:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800042da:	48 88       	lddpc	r8,800042f8 <xnl_get_msg_ack_func+0x20>
800042dc:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800042de:	98 49       	ld.sh	r9,r12[0x8]
800042e0:	f0 09 19 00 	cp.h	r9,r8
800042e4:	c0 81       	brne	800042f4 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800042e6:	48 68       	lddpc	r8,800042fc <xnl_get_msg_ack_func+0x24>
800042e8:	70 0c       	ld.w	r12,r8[0x0]
800042ea:	30 09       	mov	r9,0
800042ec:	12 9a       	mov	r10,r9
800042ee:	12 9b       	mov	r11,r9
800042f0:	f0 1f 00 04 	mcall	80004300 <xnl_get_msg_ack_func+0x28>
800042f4:	d8 02       	popm	pc
800042f6:	00 00       	add	r0,r0
800042f8:	00 00       	add	r0,r0
800042fa:	0b 4a       	ld.w	r10,--r5
800042fc:	00 00       	add	r0,r0
800042fe:	0b 44       	ld.w	r4,--r5
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	6b 30       	ld.w	r0,r5[0x4c]

80004304 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004304:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004308:	30 09       	mov	r9,0
8000430a:	4b 78       	lddpc	r8,800043e4 <xnl_init+0xe0>
8000430c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000430e:	30 0b       	mov	r11,0
80004310:	30 1c       	mov	r12,1
80004312:	f0 1f 00 36 	mcall	800043e8 <xnl_init+0xe4>
80004316:	4b 68       	lddpc	r8,800043ec <xnl_init+0xe8>
80004318:	91 0c       	st.w	r8[0x0],r12
8000431a:	70 08       	ld.w	r8,r8[0x0]
8000431c:	58 08       	cp.w	r8,0
8000431e:	c0 80       	breq	8000432e <xnl_init+0x2a>
80004320:	4b 38       	lddpc	r8,800043ec <xnl_init+0xe8>
80004322:	70 0c       	ld.w	r12,r8[0x0]
80004324:	30 09       	mov	r9,0
80004326:	12 9a       	mov	r10,r9
80004328:	12 9b       	mov	r11,r9
8000432a:	f0 1f 00 32 	mcall	800043f0 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000432e:	30 4b       	mov	r11,4
80004330:	31 4c       	mov	r12,20
80004332:	f0 1f 00 2e 	mcall	800043e8 <xnl_init+0xe4>
80004336:	4b 08       	lddpc	r8,800043f4 <xnl_init+0xf0>
80004338:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000433a:	30 4b       	mov	r11,4
8000433c:	31 ec       	mov	r12,30
8000433e:	f0 1f 00 2b 	mcall	800043e8 <xnl_init+0xe4>
80004342:	4a e8       	lddpc	r8,800043f8 <xnl_init+0xf4>
80004344:	91 0c       	st.w	r8[0x0],r12
80004346:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004348:	10 96       	mov	r6,r8
8000434a:	4a d5       	lddpc	r5,800043fc <xnl_init+0xf8>
8000434c:	6c 0c       	ld.w	r12,r6[0x0]
8000434e:	ea 07 00 0b 	add	r11,r5,r7
80004352:	f0 1f 00 2c 	mcall	80004400 <xnl_init+0xfc>
80004356:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000435a:	e0 47 1e 00 	cp.w	r7,7680
8000435e:	cf 71       	brne	8000434c <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004360:	30 4b       	mov	r11,4
80004362:	31 4c       	mov	r12,20
80004364:	f0 1f 00 21 	mcall	800043e8 <xnl_init+0xe4>
80004368:	4a 78       	lddpc	r8,80004404 <xnl_init+0x100>
8000436a:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000436c:	30 4b       	mov	r11,4
8000436e:	30 ac       	mov	r12,10
80004370:	f0 1f 00 1e 	mcall	800043e8 <xnl_init+0xe4>
80004374:	4a 58       	lddpc	r8,80004408 <xnl_init+0x104>
80004376:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004378:	30 4b       	mov	r11,4
8000437a:	30 ac       	mov	r12,10
8000437c:	f0 1f 00 1b 	mcall	800043e8 <xnl_init+0xe4>
80004380:	4a 38       	lddpc	r8,8000440c <xnl_init+0x108>
80004382:	91 0c       	st.w	r8[0x0],r12
80004384:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004386:	10 96       	mov	r6,r8
80004388:	4a 25       	lddpc	r5,80004410 <xnl_init+0x10c>
8000438a:	6c 0c       	ld.w	r12,r6[0x0]
8000438c:	ea 07 00 0b 	add	r11,r5,r7
80004390:	f0 1f 00 1c 	mcall	80004400 <xnl_init+0xfc>
80004394:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004398:	e0 47 14 00 	cp.w	r7,5120
8000439c:	cf 71       	brne	8000438a <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000439e:	30 4b       	mov	r11,4
800043a0:	30 5c       	mov	r12,5
800043a2:	f0 1f 00 12 	mcall	800043e8 <xnl_init+0xe4>
800043a6:	49 c8       	lddpc	r8,80004414 <xnl_init+0x110>
800043a8:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800043aa:	30 07       	mov	r7,0
800043ac:	1a d7       	st.w	--sp,r7
800043ae:	1a d7       	st.w	--sp,r7
800043b0:	1a d7       	st.w	--sp,r7
800043b2:	30 38       	mov	r8,3
800043b4:	0e 99       	mov	r9,r7
800043b6:	e0 6a 02 00 	mov	r10,512
800043ba:	49 8b       	lddpc	r11,80004418 <xnl_init+0x114>
800043bc:	49 8c       	lddpc	r12,8000441c <xnl_init+0x118>
800043be:	f0 1f 00 19 	mcall	80004420 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800043c2:	1a d7       	st.w	--sp,r7
800043c4:	1a d7       	st.w	--sp,r7
800043c6:	1a d7       	st.w	--sp,r7
800043c8:	30 38       	mov	r8,3
800043ca:	0e 99       	mov	r9,r7
800043cc:	e0 6a 03 20 	mov	r10,800
800043d0:	49 5b       	lddpc	r11,80004424 <xnl_init+0x120>
800043d2:	49 6c       	lddpc	r12,80004428 <xnl_init+0x124>
800043d4:	f0 1f 00 13 	mcall	80004420 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800043d8:	f0 1f 00 15 	mcall	8000442c <xnl_init+0x128>
800043dc:	2f ad       	sub	sp,-24
}
800043de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043e2:	00 00       	add	r0,r0
800043e4:	00 00       	add	r0,r0
800043e6:	0b 4a       	ld.w	r10,--r5
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	6c 88       	ld.w	r8,r6[0x20]
800043ec:	00 00       	add	r0,r0
800043ee:	0b 44       	ld.w	r4,--r5
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	6b 30       	ld.w	r0,r5[0x4c]
800043f4:	00 00       	add	r0,r0
800043f6:	0b 58       	ld.sh	r8,--r5
800043f8:	00 00       	add	r0,r0
800043fa:	0a a4       	st.w	r5++,r4
800043fc:	00 00       	add	r0,r0
800043fe:	35 ae       	mov	lr,90
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	2c 1c       	sub	r12,-63
80004404:	00 00       	add	r0,r0
80004406:	0a dc       	st.w	--r5,r12
80004408:	00 00       	add	r0,r0
8000440a:	0a b8       	st.h	r5++,r8
8000440c:	00 00       	add	r0,r0
8000440e:	0a ac       	st.w	r5++,r12
80004410:	00 00       	add	r0,r0
80004412:	21 ae       	sub	lr,26
80004414:	00 00       	add	r0,r0
80004416:	0a a0       	st.w	r5++,r0
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	df d0       	acall	0xfd
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	44 30       	lddsp	r0,sp[0x10c]
80004420:	80 00       	ld.sh	r0,r0[0x0]
80004422:	73 a4       	ld.w	r4,r9[0x68]
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	d8 00       	acall	0x80
80004428:	80 00       	ld.sh	r0,r0[0x0]
8000442a:	44 90       	lddsp	r0,sp[0x124]
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	2d f0       	sub	r0,-33

80004430 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004430:	eb cd 40 fe 	pushm	r1-r7,lr
80004434:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004436:	49 26       	lddpc	r6,8000447c <xnl_rx_process+0x4c>
80004438:	30 05       	mov	r5,0
8000443a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000443c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000443e:	49 11       	lddpc	r1,80004480 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004440:	49 12       	lddpc	r2,80004484 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004442:	6c 0c       	ld.w	r12,r6[0x0]
80004444:	0a 99       	mov	r9,r5
80004446:	08 9a       	mov	r10,r4
80004448:	1a 9b       	mov	r11,sp
8000444a:	f0 1f 00 10 	mcall	80004488 <xnl_rx_process+0x58>
8000444e:	58 1c       	cp.w	r12,1
80004450:	cf 91       	brne	80004442 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004452:	40 0c       	lddsp	r12,sp[0x0]
80004454:	58 0c       	cp.w	r12,0
80004456:	cf 60       	breq	80004442 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004458:	98 28       	ld.sh	r8,r12[0x4]
8000445a:	e6 08 19 00 	cp.h	r8,r3
8000445e:	e0 8b 00 0a 	brhi	80004472 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004462:	5c 78       	castu.h	r8
80004464:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004468:	58 09       	cp.w	r9,0
8000446a:	c0 40       	breq	80004472 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000446c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004470:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004472:	62 0c       	ld.w	r12,r1[0x0]
80004474:	40 0b       	lddsp	r11,sp[0x0]
80004476:	f0 1f 00 06 	mcall	8000448c <xnl_rx_process+0x5c>
8000447a:	ce 4b       	rjmp	80004442 <xnl_rx_process+0x12>
8000447c:	00 00       	add	r0,r0
8000447e:	0a b8       	st.h	r5++,r8
80004480:	00 00       	add	r0,r0
80004482:	0a a4       	st.w	r5++,r4
80004484:	00 00       	add	r0,r0
80004486:	04 f4       	st.b	--r2,r4
80004488:	80 00       	ld.sh	r0,r0[0x0]
8000448a:	69 24       	ld.w	r4,r4[0x48]
8000448c:	80 00       	ld.sh	r0,r0[0x0]
8000448e:	2c 1c       	sub	r12,-63

80004490 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004490:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004492:	4a a6       	lddpc	r6,80004538 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004494:	4a a2       	lddpc	r2,8000453c <xnl_tx_process+0xac>
80004496:	4a b4       	lddpc	r4,80004540 <xnl_tx_process+0xb0>
80004498:	30 07       	mov	r7,0
8000449a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000449c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000449e:	4a a5       	lddpc	r5,80004544 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044a0:	4a a3       	lddpc	r3,80004548 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800044a2:	6c 08       	ld.w	r8,r6[0x0]
800044a4:	58 08       	cp.w	r8,0
800044a6:	c0 40       	breq	800044ae <xnl_tx_process+0x1e>
800044a8:	58 18       	cp.w	r8,1
800044aa:	cf d1       	brne	800044a4 <xnl_tx_process+0x14>
800044ac:	c2 48       	rjmp	800044f4 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044ae:	64 0c       	ld.w	r12,r2[0x0]
800044b0:	0e 99       	mov	r9,r7
800044b2:	02 9a       	mov	r10,r1
800044b4:	08 9b       	mov	r11,r4
800044b6:	f0 1f 00 26 	mcall	8000454c <xnl_tx_process+0xbc>
800044ba:	58 1c       	cp.w	r12,1
800044bc:	cf 31       	brne	800044a2 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800044be:	68 0b       	ld.w	r11,r4[0x0]
800044c0:	58 0b       	cp.w	r11,0
800044c2:	cf 00       	breq	800044a2 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044c4:	96 28       	ld.sh	r8,r11[0x4]
800044c6:	e0 08 19 00 	cp.h	r8,r0
800044ca:	c0 71       	brne	800044d8 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800044cc:	4a 18       	lddpc	r8,80004550 <xnl_tx_process+0xc0>
800044ce:	70 08       	ld.w	r8,r8[0x0]
800044d0:	10 9c       	mov	r12,r8
800044d2:	f0 1f 00 21 	mcall	80004554 <xnl_tx_process+0xc4>
						break;
800044d6:	ce 6b       	rjmp	800044a2 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800044d8:	16 9c       	mov	r12,r11
800044da:	f0 1f 00 20 	mcall	80004558 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044de:	30 18       	mov	r8,1
800044e0:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044e2:	66 0c       	ld.w	r12,r3[0x0]
800044e4:	0e 99       	mov	r9,r7
800044e6:	0e 9a       	mov	r10,r7
800044e8:	0e 9b       	mov	r11,r7
800044ea:	f0 1f 00 19 	mcall	8000454c <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800044ee:	30 18       	mov	r8,1
800044f0:	8d 08       	st.w	r6[0x0],r8
800044f2:	cd 8b       	rjmp	800044a2 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044f4:	66 0c       	ld.w	r12,r3[0x0]
800044f6:	0e 99       	mov	r9,r7
800044f8:	36 4a       	mov	r10,100
800044fa:	0e 9b       	mov	r11,r7
800044fc:	f0 1f 00 14 	mcall	8000454c <xnl_tx_process+0xbc>
80004500:	58 1c       	cp.w	r12,1
80004502:	c0 81       	brne	80004512 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004504:	49 38       	lddpc	r8,80004550 <xnl_tx_process+0xc0>
80004506:	70 0c       	ld.w	r12,r8[0x0]
80004508:	68 0b       	ld.w	r11,r4[0x0]
8000450a:	f0 1f 00 13 	mcall	80004554 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000450e:	8d 07       	st.w	r6[0x0],r7
80004510:	cc 9b       	rjmp	800044a2 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004512:	6a 08       	ld.w	r8,r5[0x0]
80004514:	58 38       	cp.w	r8,3
80004516:	e0 89 00 09 	brgt	80004528 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000451a:	68 0c       	ld.w	r12,r4[0x0]
8000451c:	f0 1f 00 0f 	mcall	80004558 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004520:	6a 08       	ld.w	r8,r5[0x0]
80004522:	2f f8       	sub	r8,-1
80004524:	8b 08       	st.w	r5[0x0],r8
80004526:	cb eb       	rjmp	800044a2 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004528:	48 a8       	lddpc	r8,80004550 <xnl_tx_process+0xc0>
8000452a:	70 0c       	ld.w	r12,r8[0x0]
8000452c:	68 0b       	ld.w	r11,r4[0x0]
8000452e:	f0 1f 00 0a 	mcall	80004554 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004532:	8d 07       	st.w	r6[0x0],r7
80004534:	cb 7b       	rjmp	800044a2 <xnl_tx_process+0x12>
80004536:	00 00       	add	r0,r0
80004538:	00 00       	add	r0,r0
8000453a:	0b 54       	ld.sh	r4,--r5
8000453c:	00 00       	add	r0,r0
8000453e:	0b 58       	ld.sh	r8,--r5
80004540:	00 00       	add	r0,r0
80004542:	0b 60       	ld.uh	r0,--r5
80004544:	00 00       	add	r0,r0
80004546:	0b 5c       	ld.sh	r12,--r5
80004548:	00 00       	add	r0,r0
8000454a:	0b 44       	ld.w	r4,--r5
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	69 24       	ld.w	r4,r4[0x48]
80004550:	00 00       	add	r0,r0
80004552:	0a a4       	st.w	r5++,r4
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	2c 1c       	sub	r12,-63
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	2c 3c       	sub	r12,-61

8000455c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000455c:	eb cd 40 c0 	pushm	r6-r7,lr
80004560:	20 1d       	sub	sp,4
80004562:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004564:	98 39       	ld.sh	r9,r12[0x6]
80004566:	3f f8       	mov	r8,-1
80004568:	f0 09 19 00 	cp.h	r9,r8
8000456c:	c0 a1       	brne	80004580 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000456e:	4a e9       	lddpc	r9,80004624 <xnl_tx+0xc8>
80004570:	13 88       	ld.ub	r8,r9[0x0]
80004572:	2f f8       	sub	r8,-1
80004574:	5c 58       	castu.b	r8
80004576:	b2 88       	st.b	r9[0x0],r8
80004578:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000457c:	a9 a8       	sbr	r8,0x8
8000457e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004580:	8c 49       	ld.sh	r9,r6[0x8]
80004582:	3f f8       	mov	r8,-1
80004584:	f0 09 19 00 	cp.h	r9,r8
80004588:	c0 41       	brne	80004590 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000458a:	4a 88       	lddpc	r8,80004628 <xnl_tx+0xcc>
8000458c:	90 18       	ld.sh	r8,r8[0x2]
8000458e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004590:	8c 59       	ld.sh	r9,r6[0xa]
80004592:	3f f8       	mov	r8,-1
80004594:	f0 09 19 00 	cp.h	r9,r8
80004598:	c0 41       	brne	800045a0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000459a:	4a 48       	lddpc	r8,80004628 <xnl_tx+0xcc>
8000459c:	90 28       	ld.sh	r8,r8[0x4]
8000459e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800045a0:	8c 69       	ld.sh	r9,r6[0xc]
800045a2:	3f f8       	mov	r8,-1
800045a4:	f0 09 19 00 	cp.h	r9,r8
800045a8:	c0 e1       	brne	800045c4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800045aa:	4a 08       	lddpc	r8,80004628 <xnl_tx+0xcc>
800045ac:	90 49       	ld.sh	r9,r8[0x8]
800045ae:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800045b0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800045b2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800045b4:	90 49       	ld.sh	r9,r8[0x8]
800045b6:	e0 19 ff 00 	andl	r9,0xff00
800045ba:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800045be:	f3 e8 10 08 	or	r8,r9,r8
800045c2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800045c4:	0d 98       	ld.ub	r8,r6[0x1]
800045c6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800045c8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800045cc:	10 0c       	add	r12,r8
800045ce:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045d0:	58 0c       	cp.w	r12,0
800045d2:	e0 89 00 04 	brgt	800045da <xnl_tx+0x7e>
800045d6:	30 09       	mov	r9,0
800045d8:	c0 d8       	rjmp	800045f2 <xnl_tx+0x96>
800045da:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800045de:	2f ec       	sub	r12,-2
800045e0:	30 09       	mov	r9,0
800045e2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800045e4:	15 1b       	ld.sh	r11,r10++
800045e6:	f6 09 00 09 	add	r9,r11,r9
800045ea:	5c 89       	casts.h	r9
		indextohWord     += 1;
800045ec:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045ee:	18 38       	cp.w	r8,r12
800045f0:	cf a1       	brne	800045e4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800045f2:	5c 39       	neg	r9
800045f4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045f6:	48 e8       	lddpc	r8,8000462c <xnl_tx+0xd0>
800045f8:	70 0c       	ld.w	r12,r8[0x0]
800045fa:	f0 1f 00 0e 	mcall	80004630 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045fe:	c1 00       	breq	8000461e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004600:	fa c7 ff fc 	sub	r7,sp,-4
80004604:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004606:	e0 6a 01 00 	mov	r10,256
8000460a:	0c 9b       	mov	r11,r6
8000460c:	f0 1f 00 0a 	mcall	80004634 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004610:	48 a8       	lddpc	r8,80004638 <xnl_tx+0xdc>
80004612:	70 0c       	ld.w	r12,r8[0x0]
80004614:	30 09       	mov	r9,0
80004616:	12 9a       	mov	r10,r9
80004618:	1a 9b       	mov	r11,sp
8000461a:	f0 1f 00 09 	mcall	8000463c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000461e:	2f fd       	sub	sp,-4
80004620:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004624:	00 00       	add	r0,r0
80004626:	0b 48       	ld.w	r8,--r5
80004628:	00 00       	add	r0,r0
8000462a:	0b 4a       	ld.w	r10,--r5
8000462c:	00 00       	add	r0,r0
8000462e:	0a a4       	st.w	r5++,r4
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	2d c8       	sub	r8,-36
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	80 16       	ld.sh	r6,r0[0x2]
80004638:	00 00       	add	r0,r0
8000463a:	0b 58       	ld.sh	r8,--r5
8000463c:	80 00       	ld.sh	r0,r0[0x0]
8000463e:	6b 30       	ld.w	r0,r5[0x4c]

80004640 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004640:	eb cd 40 80 	pushm	r7,lr
80004644:	fa cd 01 00 	sub	sp,sp,256
80004648:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000464a:	e0 68 40 0e 	mov	r8,16398
8000464e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004650:	3f f8       	mov	r8,-1
80004652:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004654:	30 c8       	mov	r8,12
80004656:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004658:	98 38       	ld.sh	r8,r12[0x6]
8000465a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000465c:	98 58       	ld.sh	r8,r12[0xa]
8000465e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004660:	98 48       	ld.sh	r8,r12[0x8]
80004662:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004664:	98 68       	ld.sh	r8,r12[0xc]
80004666:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004668:	30 08       	mov	r8,0
8000466a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000466c:	1a 9c       	mov	r12,sp
8000466e:	f0 1f 00 0a 	mcall	80004694 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004672:	fa cd 00 cc 	sub	sp,sp,204
80004676:	e0 6a 00 ca 	mov	r10,202
8000467a:	ee cb ff f0 	sub	r11,r7,-16
8000467e:	1a 9c       	mov	r12,sp
80004680:	f0 1f 00 06 	mcall	80004698 <xnl_data_msg_func+0x58>
80004684:	48 68       	lddpc	r8,8000469c <xnl_data_msg_func+0x5c>
80004686:	70 08       	ld.w	r8,r8[0x0]
80004688:	5d 18       	icall	r8
8000468a:	fa cd ff 34 	sub	sp,sp,-204
}
8000468e:	2c 0d       	sub	sp,-256
80004690:	e3 cd 80 80 	ldm	sp++,r7,pc
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	45 5c       	lddsp	r12,sp[0x154]
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	80 16       	ld.sh	r6,r0[0x2]
8000469c:	00 00       	add	r0,r0
8000469e:	0b 64       	ld.uh	r4,--r5

800046a0 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800046a0:	d4 21       	pushm	r4-r7,lr
800046a2:	fa cd 01 00 	sub	sp,sp,256
800046a6:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800046a8:	4c 28       	lddpc	r8,800047b0 <xnl_device_auth_reply_func+0x110>
800046aa:	11 88       	ld.ub	r8,r8[0x0]
800046ac:	58 08       	cp.w	r8,0
800046ae:	e0 81 00 7f 	brne	800047ac <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800046b2:	4c 18       	lddpc	r8,800047b4 <xnl_device_auth_reply_func+0x114>
800046b4:	70 0c       	ld.w	r12,r8[0x0]
800046b6:	30 09       	mov	r9,0
800046b8:	12 9a       	mov	r10,r9
800046ba:	12 9b       	mov	r11,r9
800046bc:	f0 1f 00 3f 	mcall	800047b8 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800046c0:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800046c4:	4b b8       	lddpc	r8,800047b0 <xnl_device_auth_reply_func+0x110>
800046c6:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800046c8:	ef 39 00 12 	ld.ub	r9,r7[18]
800046cc:	ef 38 00 13 	ld.ub	r8,r7[19]
800046d0:	b1 68       	lsl	r8,0x10
800046d2:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800046d6:	ef 38 00 15 	ld.ub	r8,r7[21]
800046da:	f3 e8 10 08 	or	r8,r9,r8
800046de:	ef 39 00 14 	ld.ub	r9,r7[20]
800046e2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800046e6:	ef 3a 00 16 	ld.ub	r10,r7[22]
800046ea:	ef 38 00 17 	ld.ub	r8,r7[23]
800046ee:	b1 68       	lsl	r8,0x10
800046f0:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046f4:	ef 38 00 19 	ld.ub	r8,r7[25]
800046f8:	f5 e8 10 08 	or	r8,r10,r8
800046fc:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004700:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004704:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004706:	e0 64 79 b9 	mov	r4,31161
8000470a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000470e:	e0 65 45 07 	mov	r5,17671
80004712:	ea 15 8a bd 	orh	r5,0x8abd
80004716:	e0 66 f9 3d 	mov	r6,63805
8000471a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000471e:	e0 6e b8 cf 	mov	lr,47311
80004722:	ea 1e 36 83 	orh	lr,0x3683
80004726:	e0 67 aa 1c 	mov	r7,43548
8000472a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000472e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004730:	f4 08 00 0c 	add	r12,r10,r8
80004734:	f0 0b 15 04 	lsl	r11,r8,0x4
80004738:	0a 0b       	add	r11,r5
8000473a:	f9 eb 20 0b 	eor	r11,r12,r11
8000473e:	f0 0c 16 05 	lsr	r12,r8,0x5
80004742:	0c 0c       	add	r12,r6
80004744:	18 5b       	eor	r11,r12
80004746:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004748:	f2 0c 15 04 	lsl	r12,r9,0x4
8000474c:	1c 0c       	add	r12,lr
8000474e:	f2 0b 16 05 	lsr	r11,r9,0x5
80004752:	0e 0b       	add	r11,r7
80004754:	f9 eb 20 0b 	eor	r11,r12,r11
80004758:	f2 0a 00 0c 	add	r12,r9,r10
8000475c:	18 5b       	eor	r11,r12
8000475e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004760:	e0 6b 37 20 	mov	r11,14112
80004764:	ea 1b c6 ef 	orh	r11,0xc6ef
80004768:	16 3a       	cp.w	r10,r11
8000476a:	ce 21       	brne	8000472e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000476c:	e0 6a 40 1a 	mov	r10,16410
80004770:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004772:	3f fa       	mov	r10,-1
80004774:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004776:	30 6b       	mov	r11,6
80004778:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000477a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000477c:	48 db       	lddpc	r11,800047b0 <xnl_device_auth_reply_func+0x110>
8000477e:	96 1c       	ld.sh	r12,r11[0x2]
80004780:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004782:	96 2b       	ld.sh	r11,r11[0x4]
80004784:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004786:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004788:	30 ca       	mov	r10,12
8000478a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000478c:	30 0a       	mov	r10,0
8000478e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004792:	30 7a       	mov	r10,7
80004794:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004798:	30 2a       	mov	r10,2
8000479a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000479e:	fa ca ff ec 	sub	r10,sp,-20
800047a2:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800047a4:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047a6:	1a 9c       	mov	r12,sp
800047a8:	f0 1f 00 05 	mcall	800047bc <xnl_device_auth_reply_func+0x11c>
}
800047ac:	2c 0d       	sub	sp,-256
800047ae:	d8 22       	popm	r4-r7,pc
800047b0:	00 00       	add	r0,r0
800047b2:	0b 4a       	ld.w	r10,--r5
800047b4:	00 00       	add	r0,r0
800047b6:	0b 44       	ld.w	r4,--r5
800047b8:	80 00       	ld.sh	r0,r0[0x0]
800047ba:	6b 30       	ld.w	r0,r5[0x4c]
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	45 5c       	lddsp	r12,sp[0x154]

800047c0 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800047c0:	eb cd 40 80 	pushm	r7,lr
800047c4:	fa cd 01 00 	sub	sp,sp,256
800047c8:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800047ca:	49 28       	lddpc	r8,80004810 <xnl_master_status_brdcst_func+0x50>
800047cc:	11 88       	ld.ub	r8,r8[0x0]
800047ce:	58 08       	cp.w	r8,0
800047d0:	c1 c1       	brne	80004808 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800047d2:	49 18       	lddpc	r8,80004814 <xnl_master_status_brdcst_func+0x54>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	30 09       	mov	r9,0
800047d8:	12 9a       	mov	r10,r9
800047da:	12 9b       	mov	r11,r9
800047dc:	f0 1f 00 0f 	mcall	80004818 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800047e0:	8e 58       	ld.sh	r8,r7[0xa]
800047e2:	48 c9       	lddpc	r9,80004810 <xnl_master_status_brdcst_func+0x50>
800047e4:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047e6:	e0 68 40 0e 	mov	r8,16398
800047ea:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047ec:	3f f8       	mov	r8,-1
800047ee:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800047f0:	30 4a       	mov	r10,4
800047f2:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047f4:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047f6:	92 19       	ld.sh	r9,r9[0x2]
800047f8:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047fa:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047fc:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047fe:	30 08       	mov	r8,0
80004800:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004802:	1a 9c       	mov	r12,sp
80004804:	f0 1f 00 06 	mcall	8000481c <xnl_master_status_brdcst_func+0x5c>
}
80004808:	2c 0d       	sub	sp,-256
8000480a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000480e:	00 00       	add	r0,r0
80004810:	00 00       	add	r0,r0
80004812:	0b 4a       	ld.w	r10,--r5
80004814:	00 00       	add	r0,r0
80004816:	0b 44       	ld.w	r4,--r5
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	6b 30       	ld.w	r0,r5[0x4c]
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	45 5c       	lddsp	r12,sp[0x154]

80004820 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004820:	eb cd 40 80 	pushm	r7,lr
80004824:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004826:	49 28       	lddpc	r8,8000486c <xnl_device_conn_reply_func+0x4c>
80004828:	70 0c       	ld.w	r12,r8[0x0]
8000482a:	30 09       	mov	r9,0
8000482c:	12 9a       	mov	r10,r9
8000482e:	12 9b       	mov	r11,r9
80004830:	f0 1f 00 10 	mcall	80004870 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004834:	ef 18 00 10 	ld.uh	r8,r7[16]
80004838:	10 99       	mov	r9,r8
8000483a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000483e:	e0 49 01 00 	cp.w	r9,256
80004842:	c0 60       	breq	8000484e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004844:	0e 9c       	mov	r12,r7
80004846:	f0 1f 00 0c 	mcall	80004874 <xnl_device_conn_reply_func+0x54>
8000484a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000484e:	a9 68       	lsl	r8,0x8
80004850:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004854:	48 98       	lddpc	r8,80004878 <xnl_device_conn_reply_func+0x58>
80004856:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004858:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000485c:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000485e:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004862:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004864:	30 19       	mov	r9,1
80004866:	b0 89       	st.b	r8[0x0],r9
80004868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000486c:	00 00       	add	r0,r0
8000486e:	0b 44       	ld.w	r4,--r5
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	6b 30       	ld.w	r0,r5[0x4c]
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	47 c0       	lddsp	r0,sp[0x1f0]
80004878:	00 00       	add	r0,r0
8000487a:	0b 4a       	ld.w	r10,--r5

8000487c <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
8000487c:	d4 01       	pushm	lr
8000487e:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004882:	e0 68 40 0e 	mov	r8,16398
80004886:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004888:	3f f8       	mov	r8,-1
8000488a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000488c:	30 38       	mov	r8,3
8000488e:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004890:	30 08       	mov	r8,0
80004892:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004894:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004896:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004898:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000489a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000489c:	1a 9c       	mov	r12,sp
8000489e:	f0 1f 00 03 	mcall	800048a8 <xnl_send_device_master_query+0x2c>
}
800048a2:	2c 0d       	sub	sp,-256
800048a4:	d8 02       	popm	pc
800048a6:	00 00       	add	r0,r0
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	45 5c       	lddsp	r12,sp[0x154]

800048ac <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800048ac:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800048ae:	48 78       	lddpc	r8,800048c8 <RC522_SPI_SetSpeed+0x1c>
800048b0:	70 09       	ld.w	r9,r8[0x0]
800048b2:	72 ca       	ld.w	r10,r9[0x30]
800048b4:	5c 7c       	castu.h	r12
800048b6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800048ba:	f9 ea 10 0a 	or	r10,r12,r10
800048be:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800048c0:	70 0c       	ld.w	r12,r8[0x0]
800048c2:	f0 1f 00 03 	mcall	800048cc <RC522_SPI_SetSpeed+0x20>
		
	
}
800048c6:	d8 02       	popm	pc
800048c8:	00 00       	add	r0,r0
800048ca:	20 88       	sub	r8,8
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	60 20       	ld.w	r0,r0[0x8]

800048d0 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800048d0:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
800048d2:	e0 6c 04 00 	mov	r12,1024
800048d6:	f0 1f 00 02 	mcall	800048dc <RC522_SPI_SetSpeedLow+0xc>
	
}
800048da:	d8 02       	popm	pc
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	48 ac       	lddpc	r12,80004904 <RC522_ReadByte+0x24>

800048e0 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800048e0:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
800048e4:	48 b7       	lddpc	r7,80004910 <RC522_ReadByte+0x30>
800048e6:	30 0b       	mov	r11,0
800048e8:	6e 0c       	ld.w	r12,r7[0x0]
800048ea:	f0 1f 00 0b 	mcall	80004914 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800048ee:	e0 6b 00 ff 	mov	r11,255
800048f2:	6e 0c       	ld.w	r12,r7[0x0]
800048f4:	f0 1f 00 09 	mcall	80004918 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800048f8:	30 06       	mov	r6,0
800048fa:	0c 9b       	mov	r11,r6
800048fc:	6e 0c       	ld.w	r12,r7[0x0]
800048fe:	f0 1f 00 08 	mcall	8000491c <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004902:	0c 9b       	mov	r11,r6
80004904:	6e 0c       	ld.w	r12,r7[0x0]
80004906:	f0 1f 00 07 	mcall	80004920 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
8000490a:	0d 9c       	ld.ub	r12,r6[0x1]
8000490c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004910:	00 00       	add	r0,r0
80004912:	20 88       	sub	r8,8
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	61 8c       	ld.w	r12,r0[0x60]
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	60 26       	ld.w	r6,r0[0x8]
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	60 42       	ld.w	r2,r0[0x10]
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	61 4c       	ld.w	r12,r0[0x50]

80004924 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004924:	eb cd 40 c0 	pushm	r6-r7,lr
80004928:	20 1d       	sub	sp,4
8000492a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000492c:	48 c7       	lddpc	r7,8000495c <RC522_WriteByte+0x38>
8000492e:	30 0b       	mov	r11,0
80004930:	6e 0c       	ld.w	r12,r7[0x0]
80004932:	f0 1f 00 0c 	mcall	80004960 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004936:	1b 8b       	ld.ub	r11,sp[0x0]
80004938:	6e 0c       	ld.w	r12,r7[0x0]
8000493a:	f0 1f 00 0b 	mcall	80004964 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000493e:	1a 9b       	mov	r11,sp
80004940:	6e 0c       	ld.w	r12,r7[0x0]
80004942:	f0 1f 00 0a 	mcall	80004968 <RC522_WriteByte+0x44>
80004946:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004948:	30 0b       	mov	r11,0
8000494a:	6e 0c       	ld.w	r12,r7[0x0]
8000494c:	f0 1f 00 08 	mcall	8000496c <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004950:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004954:	2f fd       	sub	sp,-4
80004956:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000495a:	00 00       	add	r0,r0
8000495c:	00 00       	add	r0,r0
8000495e:	20 88       	sub	r8,8
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	61 8c       	ld.w	r12,r0[0x60]
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	60 26       	ld.w	r6,r0[0x8]
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	60 42       	ld.w	r2,r0[0x10]
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	61 4c       	ld.w	r12,r0[0x50]

80004970 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004970:	eb cd 40 c0 	pushm	r6-r7,lr
80004974:	18 96       	mov	r6,r12
80004976:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004978:	31 8c       	mov	r12,24
8000497a:	f0 1f 00 09 	mcall	8000499c <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000497e:	ec 0c 15 01 	lsl	r12,r6,0x1
80004982:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004986:	f0 1f 00 07 	mcall	800049a0 <WriteRawRC+0x30>
	RC522_WriteByte(value);
8000498a:	0e 9c       	mov	r12,r7
8000498c:	f0 1f 00 05 	mcall	800049a0 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004990:	31 8c       	mov	r12,24
80004992:	f0 1f 00 05 	mcall	800049a4 <WriteRawRC+0x34>

}
80004996:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000499a:	00 00       	add	r0,r0
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	5d 00       	ror	r0
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	49 24       	lddpc	r4,800049e8 <PcdReset+0x40>
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	5c e4       	tnbz	r4

800049a8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800049a8:	d4 01       	pushm	lr

	SET_RC522RST;
800049aa:	31 9c       	mov	r12,25
800049ac:	f0 1f 00 1b 	mcall	80004a18 <PcdReset+0x70>
	delay_ns(10);
800049b0:	30 ac       	mov	r12,10
800049b2:	f0 1f 00 1b 	mcall	80004a1c <PcdReset+0x74>

	CLR_RC522RST;
800049b6:	31 9c       	mov	r12,25
800049b8:	f0 1f 00 1a 	mcall	80004a20 <PcdReset+0x78>
	delay_ns(10);
800049bc:	30 ac       	mov	r12,10
800049be:	f0 1f 00 18 	mcall	80004a1c <PcdReset+0x74>

	SET_RC522RST;
800049c2:	31 9c       	mov	r12,25
800049c4:	f0 1f 00 15 	mcall	80004a18 <PcdReset+0x70>
	delay_ns(10);
800049c8:	30 ac       	mov	r12,10
800049ca:	f0 1f 00 15 	mcall	80004a1c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049ce:	30 fb       	mov	r11,15
800049d0:	30 1c       	mov	r12,1
800049d2:	f0 1f 00 15 	mcall	80004a24 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049d6:	30 fb       	mov	r11,15
800049d8:	30 1c       	mov	r12,1
800049da:	f0 1f 00 13 	mcall	80004a24 <PcdReset+0x7c>
	delay_ns(10);
800049de:	30 ac       	mov	r12,10
800049e0:	f0 1f 00 0f 	mcall	80004a1c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800049e4:	33 db       	mov	r11,61
800049e6:	31 1c       	mov	r12,17
800049e8:	f0 1f 00 0f 	mcall	80004a24 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800049ec:	31 eb       	mov	r11,30
800049ee:	32 dc       	mov	r12,45
800049f0:	f0 1f 00 0d 	mcall	80004a24 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800049f4:	30 0b       	mov	r11,0
800049f6:	32 cc       	mov	r12,44
800049f8:	f0 1f 00 0b 	mcall	80004a24 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800049fc:	e0 6b 00 8d 	mov	r11,141
80004a00:	32 ac       	mov	r12,42
80004a02:	f0 1f 00 09 	mcall	80004a24 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004a06:	33 eb       	mov	r11,62
80004a08:	32 bc       	mov	r12,43
80004a0a:	f0 1f 00 07 	mcall	80004a24 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004a0e:	34 0b       	mov	r11,64
80004a10:	31 5c       	mov	r12,21
80004a12:	f0 1f 00 05 	mcall	80004a24 <PcdReset+0x7c>
	
	return MI_OK;
}
80004a16:	d8 0a       	popm	pc,r12=0
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	5c e4       	tnbz	r4
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	52 70       	stdsp	sp[0x9c],r0
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	5d 00       	ror	r0
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	49 70       	lddpc	r0,80004a80 <SetBitMask+0x18>

80004a28 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004a28:	eb cd 40 80 	pushm	r7,lr
80004a2c:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004a2e:	31 8c       	mov	r12,24
80004a30:	f0 1f 00 0a 	mcall	80004a58 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004a34:	ee 08 15 01 	lsl	r8,r7,0x1
80004a38:	10 9c       	mov	r12,r8
80004a3a:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004a3e:	a7 bc       	sbr	r12,0x7
80004a40:	f0 1f 00 07 	mcall	80004a5c <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004a44:	f0 1f 00 07 	mcall	80004a60 <ReadRawRC+0x38>
80004a48:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004a4a:	31 8c       	mov	r12,24
80004a4c:	f0 1f 00 06 	mcall	80004a64 <ReadRawRC+0x3c>
	return ucResult;
}
80004a50:	0e 9c       	mov	r12,r7
80004a52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a56:	00 00       	add	r0,r0
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	5d 00       	ror	r0
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	49 24       	lddpc	r4,80004aa4 <PcdAntennaOn+0x18>
80004a60:	80 00       	ld.sh	r0,r0[0x0]
80004a62:	48 e0       	lddpc	r0,80004a98 <PcdAntennaOn+0xc>
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	5c e4       	tnbz	r4

80004a68 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a68:	eb cd 40 c0 	pushm	r6-r7,lr
80004a6c:	18 97       	mov	r7,r12
80004a6e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a70:	f0 1f 00 05 	mcall	80004a84 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a74:	f9 e6 10 0b 	or	r11,r12,r6
80004a78:	5c 5b       	castu.b	r11
80004a7a:	0e 9c       	mov	r12,r7
80004a7c:	f0 1f 00 03 	mcall	80004a88 <SetBitMask+0x20>
}
80004a80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	4a 28       	lddpc	r8,80004b0c <M500PcdConfigISOType+0x28>
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	49 70       	lddpc	r0,80004ae4 <M500PcdConfigISOType>

80004a8c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a8c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a8e:	31 4c       	mov	r12,20
80004a90:	f0 1f 00 05 	mcall	80004aa4 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a94:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a98:	c0 51       	brne	80004aa2 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a9a:	30 3b       	mov	r11,3
80004a9c:	31 4c       	mov	r12,20
80004a9e:	f0 1f 00 03 	mcall	80004aa8 <PcdAntennaOn+0x1c>
80004aa2:	d8 02       	popm	pc
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	4a 28       	lddpc	r8,80004b2c <M500PcdConfigISOType+0x48>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	4a 68       	lddpc	r8,80004b40 <M500PcdConfigISOType+0x5c>

80004aac <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004aac:	eb cd 40 c0 	pushm	r6-r7,lr
80004ab0:	18 97       	mov	r7,r12
80004ab2:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004ab4:	f0 1f 00 06 	mcall	80004acc <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004ab8:	5c d6       	com	r6
80004aba:	f9 e6 00 06 	and	r6,r12,r6
80004abe:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004ac2:	0e 9c       	mov	r12,r7
80004ac4:	f0 1f 00 03 	mcall	80004ad0 <ClearBitMask+0x24>
	
}
80004ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	4a 28       	lddpc	r8,80004b54 <rc522_init>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	49 70       	lddpc	r0,80004b2c <M500PcdConfigISOType+0x48>

80004ad4 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004ad4:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004ad6:	30 3b       	mov	r11,3
80004ad8:	31 4c       	mov	r12,20
80004ada:	f0 1f 00 02 	mcall	80004ae0 <PcdAntennaOff+0xc>
}
80004ade:	d8 02       	popm	pc
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	4a ac       	lddpc	r12,80004b88 <rc522_init+0x34>

80004ae4 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004ae4:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004ae6:	34 18       	mov	r8,65
80004ae8:	f0 0c 18 00 	cp.b	r12,r8
80004aec:	c0 20       	breq	80004af0 <M500PcdConfigISOType+0xc>
80004aee:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004af0:	30 8b       	mov	r11,8
80004af2:	16 9c       	mov	r12,r11
80004af4:	f0 1f 00 14 	mcall	80004b44 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004af8:	33 db       	mov	r11,61
80004afa:	31 1c       	mov	r12,17
80004afc:	f0 1f 00 13 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b00:	e0 6b 00 86 	mov	r11,134
80004b04:	31 7c       	mov	r12,23
80004b06:	f0 1f 00 11 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b0a:	37 fb       	mov	r11,127
80004b0c:	32 6c       	mov	r12,38
80004b0e:	f0 1f 00 0f 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b12:	31 eb       	mov	r11,30
80004b14:	32 dc       	mov	r12,45
80004b16:	f0 1f 00 0d 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b1a:	30 0b       	mov	r11,0
80004b1c:	32 cc       	mov	r12,44
80004b1e:	f0 1f 00 0b 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b22:	e0 6b 00 8d 	mov	r11,141
80004b26:	32 ac       	mov	r12,42
80004b28:	f0 1f 00 08 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b2c:	33 eb       	mov	r11,62
80004b2e:	32 bc       	mov	r12,43
80004b30:	f0 1f 00 06 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004b34:	e0 6c 03 e8 	mov	r12,1000
80004b38:	f0 1f 00 05 	mcall	80004b4c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004b3c:	f0 1f 00 05 	mcall	80004b50 <M500PcdConfigISOType+0x6c>
80004b40:	d8 0a       	popm	pc,r12=0
80004b42:	00 00       	add	r0,r0
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	4a ac       	lddpc	r12,80004bec <rc522_init+0x98>
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	49 70       	lddpc	r0,80004ba4 <rc522_init+0x50>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	52 70       	stdsp	sp[0x9c],r0
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	4a 8c       	lddpc	r12,80004bf0 <rc522_init+0x9c>

80004b54 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b54:	eb cd 40 c0 	pushm	r6-r7,lr
80004b58:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b5a:	4a 28       	lddpc	r8,80004be0 <rc522_init+0x8c>
80004b5c:	1a 96       	mov	r6,sp
80004b5e:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b62:	fa eb 00 00 	st.d	sp[0],r10
80004b66:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b6a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b6e:	30 4b       	mov	r11,4
80004b70:	49 dc       	lddpc	r12,80004be4 <rc522_init+0x90>
80004b72:	f0 1f 00 1e 	mcall	80004be8 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b76:	31 9c       	mov	r12,25
80004b78:	f0 1f 00 1d 	mcall	80004bec <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b7c:	31 9c       	mov	r12,25
80004b7e:	f0 1f 00 1d 	mcall	80004bf0 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004b82:	49 d7       	lddpc	r7,80004bf4 <rc522_init+0xa0>
80004b84:	fe 7c 24 00 	mov	r12,-56320
80004b88:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b8a:	1a 9b       	mov	r11,sp
80004b8c:	f0 1f 00 1b 	mcall	80004bf8 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b90:	30 09       	mov	r9,0
80004b92:	12 9a       	mov	r10,r9
80004b94:	12 9b       	mov	r11,r9
80004b96:	6e 0c       	ld.w	r12,r7[0x0]
80004b98:	f0 1f 00 19 	mcall	80004bfc <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004b9c:	6e 0c       	ld.w	r12,r7[0x0]
80004b9e:	f0 1f 00 19 	mcall	80004c00 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004ba2:	e0 6a 36 00 	mov	r10,13824
80004ba6:	ea 1a 01 6e 	orh	r10,0x16e
80004baa:	1a 9b       	mov	r11,sp
80004bac:	6e 0c       	ld.w	r12,r7[0x0]
80004bae:	f0 1f 00 16 	mcall	80004c04 <rc522_init+0xb0>
80004bb2:	c0 50       	breq	80004bbc <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004bb4:	30 29       	mov	r9,2
80004bb6:	49 58       	lddpc	r8,80004c08 <rc522_init+0xb4>
80004bb8:	b0 89       	st.b	r8[0x0],r9
80004bba:	c0 38       	rjmp	80004bc0 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004bbc:	f0 1f 00 14 	mcall	80004c0c <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004bc0:	f0 1f 00 14 	mcall	80004c10 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004bc4:	f0 1f 00 14 	mcall	80004c14 <rc522_init+0xc0>
	
	delay_ms(2); 
80004bc8:	30 2c       	mov	r12,2
80004bca:	f0 1f 00 14 	mcall	80004c18 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004bce:	f0 1f 00 14 	mcall	80004c1c <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004bd2:	34 1c       	mov	r12,65
80004bd4:	f0 1f 00 13 	mcall	80004c20 <rc522_init+0xcc>
	

80004bd8:	2f cd       	sub	sp,-16
80004bda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bde:	00 00       	add	r0,r0
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	e0 00       	*unknown*
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	df d8       	*unknown*
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	5c 9c       	brev	r12
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	5c cc       	swap.bh	r12
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	5c e4       	tnbz	r4
80004bf4:	00 00       	add	r0,r0
80004bf6:	20 88       	sub	r8,8
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	5f bc       	srhi	r12
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	5f f4       	sral	r4
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	60 20       	ld.w	r0,r0[0x8]
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	60 64       	ld.w	r4,r0[0x18]
80004c08:	00 00       	add	r0,r0
80004c0a:	0b 68       	ld.uh	r8,--r5
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	48 d0       	lddpc	r0,80004c40 <PcdComMF522+0x1c>
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	49 a8       	lddpc	r8,80004c78 <PcdComMF522+0x54>
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	4a d4       	lddpc	r4,80004cc8 <PcdComMF522+0xa4>
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	52 b0       	stdsp	sp[0xac],r0
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	4a 8c       	lddpc	r12,80004cbc <PcdComMF522+0x98>
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	4a e4       	lddpc	r4,80004cd8 <PcdComMF522+0xb4>

80004c24 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c24:	d4 31       	pushm	r0-r7,lr
80004c26:	20 1d       	sub	sp,4
80004c28:	18 92       	mov	r2,r12
80004c2a:	16 95       	mov	r5,r11
80004c2c:	14 96       	mov	r6,r10
80004c2e:	50 09       	stdsp	sp[0x0],r9
80004c30:	10 90       	mov	r0,r8
80004c32:	f8 c8 00 0c 	sub	r8,r12,12
80004c36:	5c 58       	castu.b	r8
80004c38:	30 29       	mov	r9,2
80004c3a:	f2 08 18 00 	cp.b	r8,r9
80004c3e:	e0 88 00 05 	brls	80004c48 <PcdComMF522+0x24>
80004c42:	30 03       	mov	r3,0
80004c44:	06 91       	mov	r1,r3
80004c46:	c0 78       	rjmp	80004c54 <PcdComMF522+0x30>
80004c48:	4c f9       	lddpc	r9,80004d84 <PcdComMF522+0x160>
80004c4a:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c4e:	4c f9       	lddpc	r9,80004d88 <PcdComMF522+0x164>
80004c50:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c54:	02 9b       	mov	r11,r1
80004c56:	a7 bb       	sbr	r11,0x7
80004c58:	30 2c       	mov	r12,2
80004c5a:	f0 1f 00 4d 	mcall	80004d8c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c5e:	e0 6b 00 80 	mov	r11,128
80004c62:	30 4c       	mov	r12,4
80004c64:	f0 1f 00 4b 	mcall	80004d90 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c68:	30 0b       	mov	r11,0
80004c6a:	30 1c       	mov	r12,1
80004c6c:	f0 1f 00 48 	mcall	80004d8c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c70:	e0 6b 00 80 	mov	r11,128
80004c74:	30 ac       	mov	r12,10
80004c76:	f0 1f 00 48 	mcall	80004d94 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c7a:	58 06       	cp.w	r6,0
80004c7c:	c0 c0       	breq	80004c94 <PcdComMF522+0x70>
80004c7e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c80:	30 94       	mov	r4,9
80004c82:	0f 3b       	ld.ub	r11,r7++
80004c84:	08 9c       	mov	r12,r4
80004c86:	f0 1f 00 42 	mcall	80004d8c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c8a:	0e 98       	mov	r8,r7
80004c8c:	0a 18       	sub	r8,r5
80004c8e:	ec 08 19 00 	cp.h	r8,r6
80004c92:	cf 83       	brcs	80004c82 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c94:	04 9b       	mov	r11,r2
80004c96:	30 1c       	mov	r12,1
80004c98:	f0 1f 00 3d 	mcall	80004d8c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c9c:	30 c8       	mov	r8,12
80004c9e:	f0 02 18 00 	cp.b	r2,r8
80004ca2:	c0 61       	brne	80004cae <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004ca4:	e0 6b 00 80 	mov	r11,128
80004ca8:	30 dc       	mov	r12,13
80004caa:	f0 1f 00 3b 	mcall	80004d94 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004cae:	30 4c       	mov	r12,4
80004cb0:	f0 1f 00 3a 	mcall	80004d98 <PcdComMF522+0x174>
80004cb4:	18 97       	mov	r7,r12
80004cb6:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004cba:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004cbc:	30 44       	mov	r4,4
80004cbe:	c0 88       	rjmp	80004cce <PcdComMF522+0xaa>
80004cc0:	08 9c       	mov	r12,r4
80004cc2:	f0 1f 00 36 	mcall	80004d98 <PcdComMF522+0x174>
80004cc6:	18 97       	mov	r7,r12
		i--;
80004cc8:	20 16       	sub	r6,1
80004cca:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ccc:	c0 a0       	breq	80004ce0 <PcdComMF522+0xbc>
80004cce:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004cd2:	c4 c1       	brne	80004d6a <PcdComMF522+0x146>
80004cd4:	ef e3 00 08 	and	r8,r7,r3
80004cd8:	ea 08 18 00 	cp.b	r8,r5
80004cdc:	cf 20       	breq	80004cc0 <PcdComMF522+0x9c>
80004cde:	c4 68       	rjmp	80004d6a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ce0:	e0 6b 00 80 	mov	r11,128
80004ce4:	30 dc       	mov	r12,13
80004ce6:	f0 1f 00 2b 	mcall	80004d90 <PcdComMF522+0x16c>
80004cea:	30 27       	mov	r7,2
80004cec:	c3 38       	rjmp	80004d52 <PcdComMF522+0x12e>
80004cee:	02 67       	and	r7,r1
80004cf0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004cf4:	30 c8       	mov	r8,12
80004cf6:	f0 02 18 00 	cp.b	r2,r8
80004cfa:	c2 c1       	brne	80004d52 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004cfc:	30 ac       	mov	r12,10
80004cfe:	f0 1f 00 27 	mcall	80004d98 <PcdComMF522+0x174>
80004d02:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004d04:	30 cc       	mov	r12,12
80004d06:	f0 1f 00 25 	mcall	80004d98 <PcdComMF522+0x174>
80004d0a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004d0e:	c0 70       	breq	80004d1c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004d10:	08 98       	mov	r8,r4
80004d12:	20 18       	sub	r8,1
80004d14:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d18:	a0 8c       	st.b	r0[0x0],r12
80004d1a:	c0 48       	rjmp	80004d22 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d1c:	e8 08 15 03 	lsl	r8,r4,0x3
80004d20:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d22:	58 04       	cp.w	r4,0
80004d24:	c0 61       	brne	80004d30 <PcdComMF522+0x10c>
80004d26:	30 14       	mov	r4,1
80004d28:	40 05       	lddsp	r5,sp[0x0]
80004d2a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d2c:	30 93       	mov	r3,9
80004d2e:	c0 98       	rjmp	80004d40 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d30:	31 28       	mov	r8,18
80004d32:	f0 04 18 00 	cp.b	r4,r8
80004d36:	f9 b4 0b 12 	movhi	r4,18
80004d3a:	58 04       	cp.w	r4,0
80004d3c:	cf 61       	brne	80004d28 <PcdComMF522+0x104>
80004d3e:	c0 a8       	rjmp	80004d52 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d40:	06 9c       	mov	r12,r3
80004d42:	f0 1f 00 16 	mcall	80004d98 <PcdComMF522+0x174>
80004d46:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d48:	ec 05 01 08 	sub	r8,r6,r5
80004d4c:	e8 08 19 00 	cp.h	r8,r4
80004d50:	cf 83       	brcs	80004d40 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d52:	e0 6b 00 80 	mov	r11,128
80004d56:	30 cc       	mov	r12,12
80004d58:	f0 1f 00 0f 	mcall	80004d94 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d5c:	30 0b       	mov	r11,0
80004d5e:	30 1c       	mov	r12,1
80004d60:	f0 1f 00 0b 	mcall	80004d8c <PcdComMF522+0x168>
	return status;
}
80004d64:	0e 9c       	mov	r12,r7
80004d66:	2f fd       	sub	sp,-4
80004d68:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d6a:	e0 6b 00 80 	mov	r11,128
80004d6e:	30 dc       	mov	r12,13
80004d70:	f0 1f 00 08 	mcall	80004d90 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d74:	30 6c       	mov	r12,6
80004d76:	f0 1f 00 09 	mcall	80004d98 <PcdComMF522+0x174>
80004d7a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d7e:	cb 80       	breq	80004cee <PcdComMF522+0xca>
80004d80:	30 27       	mov	r7,2
80004d82:	ce 8b       	rjmp	80004d52 <PcdComMF522+0x12e>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	df f8       	*unknown*
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	df fc       	*unknown*
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	49 70       	lddpc	r0,80004de8 <PcdAnticoll+0x4c>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	4a ac       	lddpc	r12,80004e38 <PcdRequest+0x18>
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	4a 68       	lddpc	r8,80004e2c <PcdRequest+0xc>
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4a 28       	lddpc	r8,80004e20 <PcdRequest>

80004d9c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d9c:	eb cd 40 c0 	pushm	r6-r7,lr
80004da0:	20 5d       	sub	sp,20
80004da2:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004da4:	30 8b       	mov	r11,8
80004da6:	16 9c       	mov	r12,r11
80004da8:	f0 1f 00 1a 	mcall	80004e10 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004dac:	30 0b       	mov	r11,0
80004dae:	30 dc       	mov	r12,13
80004db0:	f0 1f 00 19 	mcall	80004e14 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004db4:	e0 6b 00 80 	mov	r11,128
80004db8:	30 ec       	mov	r12,14
80004dba:	f0 1f 00 16 	mcall	80004e10 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dbe:	39 38       	mov	r8,-109
80004dc0:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004dc2:	32 08       	mov	r8,32
80004dc4:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004dc6:	1a 9b       	mov	r11,sp
80004dc8:	fa c8 ff ed 	sub	r8,sp,-19
80004dcc:	1a 99       	mov	r9,sp
80004dce:	30 2a       	mov	r10,2
80004dd0:	30 cc       	mov	r12,12
80004dd2:	f0 1f 00 12 	mcall	80004e18 <PcdAnticoll+0x7c>
80004dd6:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004dd8:	c1 21       	brne	80004dfc <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dda:	1b 89       	ld.ub	r9,sp[0x0]
80004ddc:	ac 89       	st.b	r6[0x0],r9
80004dde:	1b 98       	ld.ub	r8,sp[0x1]
80004de0:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004de2:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004de4:	1b a8       	ld.ub	r8,sp[0x2]
80004de6:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004de8:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dec:	1b b9       	ld.ub	r9,sp[0x3]
80004dee:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004df0:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004df2:	1b c9       	ld.ub	r9,sp[0x4]
80004df4:	f0 09 18 00 	cp.b	r9,r8
80004df8:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004dfc:	e0 6b 00 80 	mov	r11,128
80004e00:	30 ec       	mov	r12,14
80004e02:	f0 1f 00 07 	mcall	80004e1c <PcdAnticoll+0x80>
	return status;
}
80004e06:	0e 9c       	mov	r12,r7
80004e08:	2f bd       	sub	sp,-20
80004e0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e0e:	00 00       	add	r0,r0
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	4a ac       	lddpc	r12,80004eb8 <CalulateCRC+0x34>
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	49 70       	lddpc	r0,80004e70 <PcdRequest+0x50>
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	4c 24       	lddpc	r4,80004f20 <PcdSelect+0x10>
80004e1c:	80 00       	ld.sh	r0,r0[0x0]
80004e1e:	4a 68       	lddpc	r8,80004eb4 <CalulateCRC+0x30>

80004e20 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e20:	eb cd 40 c0 	pushm	r6-r7,lr
80004e24:	20 5d       	sub	sp,20
80004e26:	18 97       	mov	r7,r12
80004e28:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e2a:	30 8b       	mov	r11,8
80004e2c:	16 9c       	mov	r12,r11
80004e2e:	f0 1f 00 12 	mcall	80004e74 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e32:	30 7b       	mov	r11,7
80004e34:	30 dc       	mov	r12,13
80004e36:	f0 1f 00 11 	mcall	80004e78 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004e3a:	30 3b       	mov	r11,3
80004e3c:	31 4c       	mov	r12,20
80004e3e:	f0 1f 00 10 	mcall	80004e7c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004e42:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004e44:	1a 9b       	mov	r11,sp
80004e46:	fa c8 ff ed 	sub	r8,sp,-19
80004e4a:	1a 99       	mov	r9,sp
80004e4c:	30 1a       	mov	r10,1
80004e4e:	30 cc       	mov	r12,12
80004e50:	f0 1f 00 0c 	mcall	80004e80 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e54:	c0 c1       	brne	80004e6c <PcdRequest+0x4c>
80004e56:	31 08       	mov	r8,16
80004e58:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e5c:	f0 09 18 00 	cp.b	r9,r8
80004e60:	c0 61       	brne	80004e6c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e62:	1b 88       	ld.ub	r8,sp[0x0]
80004e64:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e66:	1b 98       	ld.ub	r8,sp[0x1]
80004e68:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e6a:	c0 28       	rjmp	80004e6e <PcdRequest+0x4e>
80004e6c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e6e:	2f bd       	sub	sp,-20
80004e70:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	4a ac       	lddpc	r12,80004f1c <PcdSelect+0xc>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	49 70       	lddpc	r0,80004ed4 <CalulateCRC+0x50>
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4a 68       	lddpc	r8,80004f14 <PcdSelect+0x4>
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4c 24       	lddpc	r4,80004f88 <rfid_auto_reader+0x4>

80004e84 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e84:	eb cd 40 f8 	pushm	r3-r7,lr
80004e88:	18 95       	mov	r5,r12
80004e8a:	16 96       	mov	r6,r11
80004e8c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e8e:	30 4b       	mov	r11,4
80004e90:	30 5c       	mov	r12,5
80004e92:	f0 1f 00 1c 	mcall	80004f00 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e96:	30 0b       	mov	r11,0
80004e98:	30 1c       	mov	r12,1
80004e9a:	f0 1f 00 1b 	mcall	80004f04 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e9e:	e0 6b 00 80 	mov	r11,128
80004ea2:	30 ac       	mov	r12,10
80004ea4:	f0 1f 00 19 	mcall	80004f08 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004ea8:	58 06       	cp.w	r6,0
80004eaa:	c0 c0       	breq	80004ec2 <CalulateCRC+0x3e>
80004eac:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004eae:	30 94       	mov	r4,9
80004eb0:	0f 3b       	ld.ub	r11,r7++
80004eb2:	08 9c       	mov	r12,r4
80004eb4:	f0 1f 00 14 	mcall	80004f04 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004eb8:	0e 98       	mov	r8,r7
80004eba:	0a 18       	sub	r8,r5
80004ebc:	ec 08 18 00 	cp.b	r8,r6
80004ec0:	cf 83       	brcs	80004eb0 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004ec2:	30 3b       	mov	r11,3
80004ec4:	30 1c       	mov	r12,1
80004ec6:	f0 1f 00 10 	mcall	80004f04 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004eca:	30 5c       	mov	r12,5
80004ecc:	f0 1f 00 10 	mcall	80004f0c <CalulateCRC+0x88>
80004ed0:	e0 67 00 fe 	mov	r7,254
80004ed4:	30 56       	mov	r6,5
80004ed6:	c0 78       	rjmp	80004ee4 <CalulateCRC+0x60>
80004ed8:	0c 9c       	mov	r12,r6
80004eda:	f0 1f 00 0d 	mcall	80004f0c <CalulateCRC+0x88>
		i--;
80004ede:	20 17       	sub	r7,1
80004ee0:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004ee2:	c0 40       	breq	80004eea <CalulateCRC+0x66>
80004ee4:	e2 1c 00 04 	andl	r12,0x4,COH
80004ee8:	cf 80       	breq	80004ed8 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004eea:	32 2c       	mov	r12,34
80004eec:	f0 1f 00 08 	mcall	80004f0c <CalulateCRC+0x88>
80004ef0:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ef2:	32 1c       	mov	r12,33
80004ef4:	f0 1f 00 06 	mcall	80004f0c <CalulateCRC+0x88>
80004ef8:	a6 9c       	st.b	r3[0x1],r12
}
80004efa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004efe:	00 00       	add	r0,r0
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4a ac       	lddpc	r12,80004fa8 <rfid_auto_reader+0x24>
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	49 70       	lddpc	r0,80004f60 <PcdSelect+0x50>
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	4a 68       	lddpc	r8,80004fa0 <rfid_auto_reader+0x1c>
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	4a 28       	lddpc	r8,80004f94 <rfid_auto_reader+0x10>

80004f10 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004f10:	eb cd 40 80 	pushm	r7,lr
80004f14:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f16:	39 38       	mov	r8,-109
80004f18:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f1a:	37 08       	mov	r8,112
80004f1c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f1e:	30 08       	mov	r8,0
80004f20:	ba e8       	st.b	sp[0x6],r8
80004f22:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f26:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f2a:	19 89       	ld.ub	r9,r12[0x0]
80004f2c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f2e:	19 3a       	ld.ub	r10,r12++
80004f30:	1b e9       	ld.ub	r9,sp[0x6]
80004f32:	f5 e9 20 09 	eor	r9,r10,r9
80004f36:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004f38:	16 38       	cp.w	r8,r11
80004f3a:	cf 81       	brne	80004f2a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004f3c:	1a 97       	mov	r7,sp
80004f3e:	fa ca ff f9 	sub	r10,sp,-7
80004f42:	30 7b       	mov	r11,7
80004f44:	1a 9c       	mov	r12,sp
80004f46:	f0 1f 00 0d 	mcall	80004f78 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004f4a:	30 8b       	mov	r11,8
80004f4c:	16 9c       	mov	r12,r11
80004f4e:	f0 1f 00 0c 	mcall	80004f7c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f52:	fa c8 ff ed 	sub	r8,sp,-19
80004f56:	1a 99       	mov	r9,sp
80004f58:	30 9a       	mov	r10,9
80004f5a:	1a 9b       	mov	r11,sp
80004f5c:	30 cc       	mov	r12,12
80004f5e:	f0 1f 00 09 	mcall	80004f80 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f62:	c0 71       	brne	80004f70 <PcdSelect+0x60>
80004f64:	31 88       	mov	r8,24
80004f66:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f6a:	f0 09 18 00 	cp.b	r9,r8
80004f6e:	c0 20       	breq	80004f72 <PcdSelect+0x62>
80004f70:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f72:	2f bd       	sub	sp,-20
80004f74:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4e 84       	lddpc	r4,80005118 <rfid_sendID_message+0x74>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4a ac       	lddpc	r12,80005024 <rfid_auto_reader+0xa0>
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4c 24       	lddpc	r4,80005088 <rfid_auto_reader+0x104>

80004f84 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f84:	eb cd 40 c0 	pushm	r6-r7,lr
80004f88:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f8a:	f0 1f 00 37 	mcall	80005064 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f8e:	4b 7b       	lddpc	r11,80005068 <rfid_auto_reader+0xe4>
80004f90:	35 2c       	mov	r12,82
80004f92:	f0 1f 00 37 	mcall	8000506c <rfid_auto_reader+0xe8>
80004f96:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f98:	c6 31       	brne	8000505e <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f9a:	4b 48       	lddpc	r8,80005068 <rfid_auto_reader+0xe4>
80004f9c:	11 88       	ld.ub	r8,r8[0x0]
80004f9e:	30 49       	mov	r9,4
80004fa0:	f2 08 18 00 	cp.b	r8,r9
80004fa4:	c0 b1       	brne	80004fba <rfid_auto_reader+0x36>
80004fa6:	4b 19       	lddpc	r9,80005068 <rfid_auto_reader+0xe4>
80004fa8:	13 9a       	ld.ub	r10,r9[0x1]
80004faa:	30 09       	mov	r9,0
80004fac:	f2 0a 18 00 	cp.b	r10,r9
80004fb0:	c0 51       	brne	80004fba <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004fb2:	4b 0c       	lddpc	r12,80005070 <rfid_auto_reader+0xec>
80004fb4:	f0 1f 00 30 	mcall	80005074 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004fb8:	c3 c8       	rjmp	80005030 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fba:	30 29       	mov	r9,2
80004fbc:	f2 08 18 00 	cp.b	r8,r9
80004fc0:	c0 b1       	brne	80004fd6 <rfid_auto_reader+0x52>
80004fc2:	4a a9       	lddpc	r9,80005068 <rfid_auto_reader+0xe4>
80004fc4:	13 9a       	ld.ub	r10,r9[0x1]
80004fc6:	30 09       	mov	r9,0
80004fc8:	f2 0a 18 00 	cp.b	r10,r9
80004fcc:	c0 51       	brne	80004fd6 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004fce:	4a bc       	lddpc	r12,80005078 <rfid_auto_reader+0xf4>
80004fd0:	f0 1f 00 29 	mcall	80005074 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fd4:	c2 e8       	rjmp	80005030 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fd6:	34 49       	mov	r9,68
80004fd8:	f2 08 18 00 	cp.b	r8,r9
80004fdc:	c0 b1       	brne	80004ff2 <rfid_auto_reader+0x6e>
80004fde:	4a 39       	lddpc	r9,80005068 <rfid_auto_reader+0xe4>
80004fe0:	13 9a       	ld.ub	r10,r9[0x1]
80004fe2:	30 09       	mov	r9,0
80004fe4:	f2 0a 18 00 	cp.b	r10,r9
80004fe8:	c0 51       	brne	80004ff2 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004fea:	4a 5c       	lddpc	r12,8000507c <rfid_auto_reader+0xf8>
80004fec:	f0 1f 00 22 	mcall	80005074 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ff0:	c2 08       	rjmp	80005030 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ff2:	30 89       	mov	r9,8
80004ff4:	f2 08 18 00 	cp.b	r8,r9
80004ff8:	c0 b1       	brne	8000500e <rfid_auto_reader+0x8a>
80004ffa:	49 c9       	lddpc	r9,80005068 <rfid_auto_reader+0xe4>
80004ffc:	13 9a       	ld.ub	r10,r9[0x1]
80004ffe:	30 09       	mov	r9,0
80005000:	f2 0a 18 00 	cp.b	r10,r9
80005004:	c0 51       	brne	8000500e <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005006:	49 fc       	lddpc	r12,80005080 <rfid_auto_reader+0xfc>
80005008:	f0 1f 00 1b 	mcall	80005074 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000500c:	c1 28       	rjmp	80005030 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000500e:	34 49       	mov	r9,68
80005010:	f2 08 18 00 	cp.b	r8,r9
80005014:	c0 b1       	brne	8000502a <rfid_auto_reader+0xa6>
80005016:	49 58       	lddpc	r8,80005068 <rfid_auto_reader+0xe4>
80005018:	11 99       	ld.ub	r9,r8[0x1]
8000501a:	30 38       	mov	r8,3
8000501c:	f0 09 18 00 	cp.b	r9,r8
80005020:	c0 51       	brne	8000502a <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80005022:	49 9c       	lddpc	r12,80005084 <rfid_auto_reader+0x100>
80005024:	f0 1f 00 14 	mcall	80005074 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005028:	c0 48       	rjmp	80005030 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
8000502a:	49 8c       	lddpc	r12,80005088 <rfid_auto_reader+0x104>
8000502c:	f0 1f 00 12 	mcall	80005074 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005030:	49 7c       	lddpc	r12,8000508c <rfid_auto_reader+0x108>
80005032:	f0 1f 00 18 	mcall	80005090 <rfid_auto_reader+0x10c>
80005036:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005038:	c0 60       	breq	80005044 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
8000503a:	37 8b       	mov	r11,120
8000503c:	30 1c       	mov	r12,1
8000503e:	f0 1f 00 16 	mcall	80005094 <rfid_auto_reader+0x110>
		return status;
80005042:	c0 e8       	rjmp	8000505e <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005044:	49 2c       	lddpc	r12,8000508c <rfid_auto_reader+0x108>
80005046:	f0 1f 00 15 	mcall	80005098 <rfid_auto_reader+0x114>
8000504a:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
8000504c:	c0 91       	brne	8000505e <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
8000504e:	30 4a       	mov	r10,4
80005050:	48 fb       	lddpc	r11,8000508c <rfid_auto_reader+0x108>
80005052:	0c 9c       	mov	r12,r6
80005054:	f0 1f 00 12 	mcall	8000509c <rfid_auto_reader+0x118>
		log("select okay\n");
80005058:	49 2c       	lddpc	r12,800050a0 <rfid_auto_reader+0x11c>
8000505a:	f0 1f 00 07 	mcall	80005074 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000505e:	0e 9c       	mov	r12,r7
80005060:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	49 a8       	lddpc	r8,800050cc <rfid_sendID_message+0x28>
80005068:	00 00       	add	r0,r0
8000506a:	54 10       	stdsp	sp[0x104],r0
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	4e 20       	lddpc	r0,800051f4 <rfid_sendID_message+0x150>
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	e0 10 80 00 	andl	r0,0x8000
80005076:	77 68       	ld.w	r8,r11[0x58]
80005078:	80 00       	ld.sh	r0,r0[0x0]
8000507a:	e0 1c 80 00 	andl	r12,0x8000
8000507e:	e0 28 80 00 	sub	r8,32768
80005082:	e0 38 80 00 	sub	r8,98304
80005086:	e0 40 80 00 	cp.w	r0,32768
8000508a:	e0 4c 00 00 	cp.w	r12,0
8000508e:	54 14       	stdsp	sp[0x104],r4
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	4d 9c       	lddpc	r12,800051f4 <rfid_sendID_message+0x150>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	40 d0       	lddsp	r0,sp[0x34]
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4f 10       	lddpc	r0,8000525c <local_start_pll0+0x3c>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	80 16       	ld.sh	r6,r0[0x2]
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	e0 58 eb cd 	cp.w	r8,125901

800050a4 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
800050a4:	eb cd 40 e0 	pushm	r5-r7,lr
800050a8:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800050aa:	fa cc ff 90 	sub	r12,sp,-112
800050ae:	30 08       	mov	r8,0
800050b0:	30 09       	mov	r9,0
800050b2:	f8 e9 00 00 	st.d	r12[0],r8
800050b6:	30 0a       	mov	r10,0
800050b8:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800050ba:	fa e9 00 20 	st.d	sp[32],r8
800050be:	fa e9 00 28 	st.d	sp[40],r8
800050c2:	fa e9 00 30 	st.d	sp[48],r8
800050c6:	fa e9 00 38 	st.d	sp[56],r8
800050ca:	fa e9 00 40 	st.d	sp[64],r8
800050ce:	fa e9 00 48 	st.d	sp[72],r8
800050d2:	fa e9 00 50 	st.d	sp[80],r8
800050d6:	fa e9 00 58 	st.d	sp[88],r8
800050da:	fa e9 00 60 	st.d	sp[96],r8
800050de:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
800050e2:	f0 1f 00 43 	mcall	800051ec <rfid_sendID_message+0x148>
800050e6:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800050e8:	c7 61       	brne	800051d4 <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800050ea:	fb 38 00 73 	ld.ub	r8,sp[115]
800050ee:	1a d8       	st.w	--sp,r8
800050f0:	fb 38 00 76 	ld.ub	r8,sp[118]
800050f4:	1a d8       	st.w	--sp,r8
800050f6:	fb 38 00 79 	ld.ub	r8,sp[121]
800050fa:	1a d8       	st.w	--sp,r8
800050fc:	fb 38 00 7c 	ld.ub	r8,sp[124]
80005100:	1a d8       	st.w	--sp,r8
80005102:	4b cc       	lddpc	r12,800051f0 <rfid_sendID_message+0x14c>
80005104:	f0 1f 00 3c 	mcall	800051f4 <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005108:	37 7b       	mov	r11,119
8000510a:	30 1c       	mov	r12,1
8000510c:	f0 1f 00 3b 	mcall	800051f8 <rfid_sendID_message+0x154>
80005110:	fa c9 ff 80 	sub	r9,sp,-128
80005114:	fa c8 ff f0 	sub	r8,sp,-16
80005118:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
8000511c:	fa c5 ff 7c 	sub	r5,sp,-132
80005120:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005122:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005124:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005126:	13 8b       	ld.ub	r11,r9[0x0]
80005128:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000512c:	fc 0c 18 00 	cp.b	r12,lr
80005130:	f7 bc 08 d0 	subls	r12,-48
80005134:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005138:	f7 bc 0b a9 	subhi	r12,-87
8000513c:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005140:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005142:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005146:	fc 0b 18 00 	cp.b	r11,lr
8000514a:	f7 bb 08 d0 	subls	r11,-48
8000514e:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005152:	f7 bb 0b a9 	subhi	r11,-87
80005156:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000515a:	b0 b6       	st.b	r8[0x3],r6
8000515c:	2f f9       	sub	r9,-1
8000515e:	2f c8       	sub	r8,-4
80005160:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005162:	0a 39       	cp.w	r9,r5
80005164:	ce 11       	brne	80005126 <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005166:	30 6a       	mov	r10,6
80005168:	4a 5b       	lddpc	r11,800051fc <rfid_sendID_message+0x158>
8000516a:	fa cc ff f0 	sub	r12,sp,-16
8000516e:	f0 1f 00 25 	mcall	80005200 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80005172:	4a 58       	lddpc	r8,80005204 <rfid_sendID_message+0x160>
80005174:	11 89       	ld.ub	r9,r8[0x0]
80005176:	39 f8       	mov	r8,-97
80005178:	f0 09 18 00 	cp.b	r9,r8
8000517c:	e0 88 00 05 	brls	80005186 <rfid_sendID_message+0xe2>
80005180:	38 09       	mov	r9,-128
80005182:	4a 18       	lddpc	r8,80005204 <rfid_sendID_message+0x160>
80005184:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005186:	4a 08       	lddpc	r8,80005204 <rfid_sendID_message+0x160>
80005188:	11 86       	ld.ub	r6,r8[0x0]
8000518a:	2f f6       	sub	r6,-1
8000518c:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000518e:	30 5a       	mov	r10,5
80005190:	49 eb       	lddpc	r11,80005208 <rfid_sendID_message+0x164>
80005192:	fa cc ff e5 	sub	r12,sp,-27
80005196:	f0 1f 00 1b 	mcall	80005200 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000519a:	31 e8       	mov	r8,30
8000519c:	fb 58 00 16 	st.h	sp[22],r8
800051a0:	fb 66 00 1a 	st.b	sp[26],r6
800051a4:	fe 78 e0 00 	mov	r8,-8192
800051a8:	fb 58 00 18 	st.h	sp[24],r8
800051ac:	fa c6 ff e0 	sub	r6,sp,-32
800051b0:	30 aa       	mov	r10,10
800051b2:	fa cb ff ea 	sub	r11,sp,-22
800051b6:	0c 9c       	mov	r12,r6
800051b8:	f0 1f 00 12 	mcall	80005200 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800051bc:	31 6a       	mov	r10,22
800051be:	1a 9b       	mov	r11,sp
800051c0:	fa cc ff d6 	sub	r12,sp,-42
800051c4:	f0 1f 00 0f 	mcall	80005200 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800051c8:	30 9a       	mov	r10,9
800051ca:	32 0b       	mov	r11,32
800051cc:	0c 9c       	mov	r12,r6
800051ce:	f0 1f 00 10 	mcall	8000520c <rfid_sendID_message+0x168>
800051d2:	c0 88       	rjmp	800051e2 <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800051d4:	37 8b       	mov	r11,120
800051d6:	30 1c       	mov	r12,1
800051d8:	f0 1f 00 08 	mcall	800051f8 <rfid_sendID_message+0x154>
		log("no card find...\n");
800051dc:	48 dc       	lddpc	r12,80005210 <rfid_sendID_message+0x16c>
800051de:	f0 1f 00 06 	mcall	800051f4 <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
800051e2:	0e 9c       	mov	r12,r7
800051e4:	2e 1d       	sub	sp,-124
800051e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051ea:	00 00       	add	r0,r0
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	4f 84       	lddpc	r4,800053cc <xg_flashc_init+0xc8>
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	e0 68 80 00 	mov	r8,32768
800051f6:	77 68       	ld.w	r8,r11[0x58]
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	40 d0       	lddsp	r0,sp[0x34]
800051fc:	00 00       	add	r0,r0
800051fe:	0e 00       	add	r0,r7
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	80 16       	ld.sh	r6,r0[0x2]
80005204:	00 00       	add	r0,r0
80005206:	05 30       	ld.ub	r0,r2++
80005208:	00 00       	add	r0,r0
8000520a:	05 28       	ld.uh	r8,r2++
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	3f 98       	mov	r8,-7
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	e0 84 d4 01 	brge	8001fa14 <_data_lma+0x10ec4>

80005214 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80005214:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005216:	f0 1f 00 02 	mcall	8000521c <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
8000521a:	d8 02       	popm	pc
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	4b 54       	lddpc	r4,800052f0 <local_start_timer+0x18>

80005220 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005220:	fe 78 0c 00 	mov	r8,-62464
80005224:	e0 69 03 07 	mov	r9,775
80005228:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
8000522a:	30 49       	mov	r9,4
8000522c:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000522e:	71 59       	ld.w	r9,r8[0x54]
80005230:	e2 19 00 80 	andl	r9,0x80,COH
80005234:	cf d0       	breq	8000522e <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005236:	fe 78 0c 00 	mov	r8,-62464
8000523a:	30 59       	mov	r9,5
8000523c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000523e:	e0 69 01 0d 	mov	r9,269
80005242:	ea 19 10 07 	orh	r9,0x1007
80005246:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005248:	71 59       	ld.w	r9,r8[0x54]
8000524a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000524e:	cf d0       	breq	80005248 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005250:	fe 78 0c 00 	mov	r8,-62464
80005254:	fc 19 00 80 	movh	r9,0x80
80005258:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000525a:	34 0a       	mov	r10,64
8000525c:	fe 69 14 00 	mov	r9,-125952
80005260:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80005262:	30 69       	mov	r9,6
80005264:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005266:	30 19       	mov	r9,1
80005268:	fe 68 10 00 	mov	r8,-126976
8000526c:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
8000526e:	5e fc       	retal	r12

80005270 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005270:	58 0c       	cp.w	r12,0
80005272:	5e 0c       	reteq	r12
80005274:	30 08       	mov	r8,0
	{
		nop();
80005276:	d7 03       	nop
		nop();
80005278:	d7 03       	nop
		nop();
8000527a:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000527c:	2f f8       	sub	r8,-1
8000527e:	10 3c       	cp.w	r12,r8
80005280:	fe 9b ff fb 	brhi	80005276 <delay_ns+0x6>
80005284:	5e fc       	retal	r12
80005286:	d7 03       	nop

80005288 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005288:	eb cd 40 e0 	pushm	r5-r7,lr
8000528c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000528e:	58 0c       	cp.w	r12,0
80005290:	c0 b0       	breq	800052a6 <delay_us+0x1e>
80005292:	30 07       	mov	r7,0
		delay_ns(1000);
80005294:	e0 65 03 e8 	mov	r5,1000
80005298:	0a 9c       	mov	r12,r5
8000529a:	f0 1f 00 05 	mcall	800052ac <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000529e:	2f f7       	sub	r7,-1
800052a0:	0e 36       	cp.w	r6,r7
800052a2:	fe 9b ff fb 	brhi	80005298 <delay_us+0x10>
800052a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052aa:	00 00       	add	r0,r0
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	52 70       	stdsp	sp[0x9c],r0

800052b0 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800052b0:	eb cd 40 e0 	pushm	r5-r7,lr
800052b4:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800052b6:	58 0c       	cp.w	r12,0
800052b8:	c0 b0       	breq	800052ce <delay_ms+0x1e>
800052ba:	30 07       	mov	r7,0
		delay_us(1000);
800052bc:	e0 65 03 e8 	mov	r5,1000
800052c0:	0a 9c       	mov	r12,r5
800052c2:	f0 1f 00 05 	mcall	800052d4 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800052c6:	2f f7       	sub	r7,-1
800052c8:	0e 36       	cp.w	r6,r7
800052ca:	fe 9b ff fb 	brhi	800052c0 <delay_ms+0x10>
800052ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052d2:	00 00       	add	r0,r0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	52 88       	stdsp	sp[0xa0],r8

800052d8 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800052d8:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800052da:	30 3b       	mov	r11,3
800052dc:	48 8c       	lddpc	r12,800052fc <local_start_timer+0x24>
800052de:	f0 1f 00 09 	mcall	80005300 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800052e2:	fe 78 38 00 	mov	r8,-51200
800052e6:	e0 69 91 0d 	mov	r9,37133
800052ea:	ea 19 00 52 	orh	r9,0x52
800052ee:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800052f0:	32 09       	mov	r9,32
800052f2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800052f4:	30 59       	mov	r9,5
800052f6:	91 09       	st.w	r8[0x0],r9
}
800052f8:	d8 02       	popm	pc
800052fa:	00 00       	add	r0,r0
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	e0 98 80 00 	brls	800352fe <_data_lma+0x267ae>
80005302:	5c 9c       	brev	r12

80005304 <xg_flashc_init>:
		
}

//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005304:	d4 31       	pushm	r0-r7,lr
80005306:	20 2d       	sub	sp,8
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005308:	f0 1f 00 9d 	mcall	8000557c <xg_flashc_init+0x278>
8000530c:	fe f8 02 74 	ld.w	r8,pc[628]
80005310:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005312:	70 08       	ld.w	r8,r8[0x0]
80005314:	58 08       	cp.w	r8,0
80005316:	c0 51       	brne	80005320 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005318:	fe fc 02 6c 	ld.w	r12,pc[620]
8000531c:	f0 1f 00 9b 	mcall	80005588 <xg_flashc_init+0x284>
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80005320:	30 4b       	mov	r11,4
80005322:	31 4c       	mov	r12,20
80005324:	f0 1f 00 9a 	mcall	8000558c <xg_flashc_init+0x288>
80005328:	fe f8 02 68 	ld.w	r8,pc[616]
8000532c:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
8000532e:	30 4b       	mov	r11,4
80005330:	31 4c       	mov	r12,20
80005332:	f0 1f 00 97 	mcall	8000558c <xg_flashc_init+0x288>
80005336:	fe f8 02 5e 	ld.w	r8,pc[606]
8000533a:	91 0c       	st.w	r8[0x0],r12
8000533c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000533e:	10 96       	mov	r6,r8
80005340:	fe f5 02 58 	ld.w	r5,pc[600]
80005344:	6c 0c       	ld.w	r12,r6[0x0]
80005346:	ea 07 00 0b 	add	r11,r5,r7
8000534a:	f0 1f 00 95 	mcall	8000559c <xg_flashc_init+0x298>
8000534e:	2e 07       	sub	r7,-32
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005350:	e0 47 02 80 	cp.w	r7,640
80005354:	cf 81       	brne	80005344 <xg_flashc_init+0x40>
	
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005356:	30 0a       	mov	r10,0
80005358:	30 0b       	mov	r11,0
8000535a:	fe f8 02 46 	ld.w	r8,pc[582]
8000535e:	b1 2a       	st.d	r8++,r10
80005360:	b1 2a       	st.d	r8++,r10
80005362:	b1 2a       	st.d	r8++,r10
80005364:	b1 2a       	st.d	r8++,r10
80005366:	b1 2a       	st.d	r8++,r10
80005368:	b1 2a       	st.d	r8++,r10
8000536a:	b1 2a       	st.d	r8++,r10
8000536c:	b1 2a       	st.d	r8++,r10
8000536e:	b1 2a       	st.d	r8++,r10
80005370:	f0 eb 00 00 	st.d	r8[0],r10
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
80005374:	fe f7 02 2c 	ld.w	r7,pc[556]
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					memset(str, 0x00, sizeof(str));	
80005378:	ee c5 ff f8 	sub	r5,r7,-8
8000537c:	ea c4 ff f8 	sub	r4,r5,-8
80005380:	e8 c3 ff f8 	sub	r3,r4,-8
80005384:	e6 c2 ff f8 	sub	r2,r3,-8
80005388:	e4 c1 ff f8 	sub	r1,r2,-8
8000538c:	e2 c0 ff f8 	sub	r0,r1,-8
80005390:	e0 ca ff f8 	sub	r10,r0,-8
80005394:	50 0a       	stdsp	sp[0x0],r10
80005396:	2f 8a       	sub	r10,-8
80005398:	50 1a       	stdsp	sp[0x4],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
8000539a:	30 19       	mov	r9,1
8000539c:	30 7a       	mov	r10,7
8000539e:	e0 6b b0 00 	mov	r11,45056
800053a2:	ea 1b 80 04 	orh	r11,0x8004
800053a6:	0e 9c       	mov	r12,r7
800053a8:	f0 1f 00 7f 	mcall	800055a4 <xg_flashc_init+0x2a0>
	flashc_memcpy((void *)LABEL_ADDRESS, (void *)LABEL_ADDRESS, LABEL_LENGTH,  false);//为了获取当前页号码
800053ac:	30 09       	mov	r9,0
800053ae:	30 7a       	mov	r10,7
800053b0:	e0 6b b0 00 	mov	r11,45056
800053b4:	ea 1b 80 04 	orh	r11,0x8004
800053b8:	16 9c       	mov	r12,r11
800053ba:	f0 1f 00 7b 	mcall	800055a4 <xg_flashc_init+0x2a0>
	current_page_number = flashc_get_page_number();
800053be:	f0 1f 00 7b 	mcall	800055a8 <xg_flashc_init+0x2a4>
800053c2:	4f b8       	lddpc	r8,800055ac <xg_flashc_init+0x2a8>
800053c4:	91 0c       	st.w	r8[0x0],r12
	if (flashc_is_lock_error() || flashc_is_programming_error())
800053c6:	f0 1f 00 7b 	mcall	800055b0 <xg_flashc_init+0x2ac>
800053ca:	e0 81 00 d6 	brne	80005576 <xg_flashc_init+0x272>
800053ce:	f0 1f 00 7a 	mcall	800055b4 <xg_flashc_init+0x2b0>
800053d2:	e0 81 00 d2 	brne	80005576 <xg_flashc_init+0x272>
	{
		return XG_FLASH_ACTION_FAIL;
	}
	else
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
800053d6:	30 7a       	mov	r10,7
800053d8:	0e 9b       	mov	r11,r7
800053da:	4f 8c       	lddpc	r12,800055b8 <xg_flashc_init+0x2b4>
800053dc:	f0 1f 00 78 	mcall	800055bc <xg_flashc_init+0x2b8>
800053e0:	c3 b0       	breq	80005456 <xg_flashc_init+0x152>
800053e2:	cc 08       	rjmp	80005562 <xg_flashc_init+0x25e>
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
800053e4:	6c 0c       	ld.w	r12,r6[0x0]
800053e6:	ee 0c 00 0c 	add	r12,r7,r12
800053ea:	8d 0c       	st.w	r6[0x0],r12
				flashc_erase_page(current_page_number, true);
800053ec:	0a 9b       	mov	r11,r5
800053ee:	f0 1f 00 75 	mcall	800055c0 <xg_flashc_init+0x2bc>
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
800053f2:	2f f7       	sub	r7,-1
800053f4:	59 97       	cp.w	r7,25
800053f6:	cf 71       	brne	800053e4 <xg_flashc_init+0xe0>
			{
				current_page_number+=i;
				flashc_erase_page(current_page_number, true);
			}
			//set label
			flashc_memcpy((void *)LABEL_ADDRESS, (void *)XGFlashLabel, LABEL_LENGTH,  true);
800053f8:	30 19       	mov	r9,1
800053fa:	30 7a       	mov	r10,7
800053fc:	4e fb       	lddpc	r11,800055b8 <xg_flashc_init+0x2b4>
800053fe:	e0 6c b0 00 	mov	r12,45056
80005402:	ea 1c 80 04 	orh	r12,0x8004
80005406:	f0 1f 00 68 	mcall	800055a4 <xg_flashc_init+0x2a0>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
8000540a:	4e 6b       	lddpc	r11,800055a0 <xg_flashc_init+0x29c>
8000540c:	30 06       	mov	r6,0
8000540e:	30 07       	mov	r7,0
80005410:	16 98       	mov	r8,r11
80005412:	b1 26       	st.d	r8++,r6
80005414:	b1 26       	st.d	r8++,r6
80005416:	b1 26       	st.d	r8++,r6
80005418:	b1 26       	st.d	r8++,r6
8000541a:	b1 26       	st.d	r8++,r6
8000541c:	b1 26       	st.d	r8++,r6
8000541e:	b1 26       	st.d	r8++,r6
80005420:	b1 26       	st.d	r8++,r6
80005422:	b1 26       	st.d	r8++,r6
80005424:	f0 e7 00 00 	st.d	r8[0],r6
			
			flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)str, MESSAGE_NUMBERS_LENGTH,  true);
80005428:	30 19       	mov	r9,1
8000542a:	30 2a       	mov	r10,2
8000542c:	e0 6c b0 07 	mov	r12,45063
80005430:	ea 1c 80 04 	orh	r12,0x8004
80005434:	f0 1f 00 5c 	mcall	800055a4 <xg_flashc_init+0x2a0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005438:	f0 1f 00 5e 	mcall	800055b0 <xg_flashc_init+0x2ac>
8000543c:	e0 81 00 9d 	brne	80005576 <xg_flashc_init+0x272>
80005440:	f0 1f 00 5d 	mcall	800055b4 <xg_flashc_init+0x2b0>
80005444:	e0 81 00 99 	brne	80005576 <xg_flashc_init+0x272>
			{
				return XG_FLASH_ACTION_FAIL;
			}
			current_message_index = 0;
80005448:	30 09       	mov	r9,0
8000544a:	4d f8       	lddpc	r8,800055c4 <xg_flashc_init+0x2c0>
8000544c:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
8000544e:	4d fc       	lddpc	r12,800055c8 <xg_flashc_init+0x2c4>
80005450:	f0 1f 00 4e 	mcall	80005588 <xg_flashc_init+0x284>
80005454:	c8 e8       	rjmp	80005570 <xg_flashc_init+0x26c>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005456:	1a d7       	st.w	--sp,r7
80005458:	4d dc       	lddpc	r12,800055cc <xg_flashc_init+0x2c8>
8000545a:	f0 1f 00 4c 	mcall	80005588 <xg_flashc_init+0x284>
			//Get the current voice index		
			flashc_memcpy((void *)&current_message_index, (void *)MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH,  false);
8000545e:	30 09       	mov	r9,0
80005460:	30 2a       	mov	r10,2
80005462:	e0 6b b0 07 	mov	r11,45063
80005466:	ea 1b 80 04 	orh	r11,0x8004
8000546a:	4d 7c       	lddpc	r12,800055c4 <xg_flashc_init+0x2c0>
8000546c:	f0 1f 00 4e 	mcall	800055a4 <xg_flashc_init+0x2a0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005470:	f0 1f 00 50 	mcall	800055b0 <xg_flashc_init+0x2ac>
80005474:	2f fd       	sub	sp,-4
80005476:	58 0c       	cp.w	r12,0
80005478:	e0 81 00 7f 	brne	80005576 <xg_flashc_init+0x272>
8000547c:	f0 1f 00 4e 	mcall	800055b4 <xg_flashc_init+0x2b0>
80005480:	e0 81 00 7b 	brne	80005576 <xg_flashc_init+0x272>
				return XG_FLASH_ACTION_FAIL;
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005484:	4d 08       	lddpc	r8,800055c4 <xg_flashc_init+0x2c0>
80005486:	90 09       	ld.sh	r9,r8[0x0]
80005488:	30 08       	mov	r8,0
8000548a:	f0 09 19 00 	cp.h	r9,r8
8000548e:	c6 e0       	breq	8000556a <xg_flashc_init+0x266>
					memset(str, 0x00, sizeof(str));	
80005490:	30 08       	mov	r8,0
80005492:	30 09       	mov	r9,0
80005494:	ee e9 00 00 	st.d	r7[0],r8
80005498:	ea e9 00 00 	st.d	r5[0],r8
8000549c:	e8 e9 00 00 	st.d	r4[0],r8
800054a0:	e6 e9 00 00 	st.d	r3[0],r8
800054a4:	e4 e9 00 00 	st.d	r2[0],r8
800054a8:	e2 e9 00 00 	st.d	r1[0],r8
800054ac:	e0 e9 00 00 	st.d	r0[0],r8
800054b0:	40 0a       	lddsp	r10,sp[0x0]
800054b2:	f4 e9 00 00 	st.d	r10[0],r8
800054b6:	40 1a       	lddsp	r10,sp[0x4]
800054b8:	b5 28       	st.d	r10++,r8
800054ba:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
					flashc_memcpy((void *)str, (void *)address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
800054be:	4c 28       	lddpc	r8,800055c4 <xg_flashc_init+0x2c0>
800054c0:	90 8b       	ld.uh	r11,r8[0x0]
800054c2:	20 1b       	sub	r11,1
800054c4:	30 09       	mov	r9,0
800054c6:	30 8a       	mov	r10,8
800054c8:	e0 68 b0 09 	mov	r8,45065
800054cc:	ea 18 80 04 	orh	r8,0x8004
800054d0:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
800054d4:	0e 9c       	mov	r12,r7
800054d6:	f0 1f 00 34 	mcall	800055a4 <xg_flashc_init+0x2a0>
					if (flashc_is_lock_error() || flashc_is_programming_error())
800054da:	f0 1f 00 36 	mcall	800055b0 <xg_flashc_init+0x2ac>
800054de:	c0 41       	brne	800054e6 <xg_flashc_init+0x1e2>
800054e0:	f0 1f 00 35 	mcall	800055b4 <xg_flashc_init+0x2b0>
800054e4:	c0 50       	breq	800054ee <xg_flashc_init+0x1ea>
					{
						log("\r\n----message storage is err!!!----\r\n");
800054e6:	4b bc       	lddpc	r12,800055d0 <xg_flashc_init+0x2cc>
800054e8:	f0 1f 00 28 	mcall	80005588 <xg_flashc_init+0x284>
800054ec:	c3 b8       	rjmp	80005562 <xg_flashc_init+0x25e>
						goto ERASE;
					}
					else
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
800054ee:	0f 89       	ld.ub	r9,r7[0x0]
800054f0:	0f 98       	ld.ub	r8,r7[0x1]
800054f2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800054f6:	4b 49       	lddpc	r9,800055c4 <xg_flashc_init+0x2c0>
800054f8:	92 09       	ld.sh	r9,r9[0x0]
800054fa:	f0 09 19 00 	cp.h	r9,r8
800054fe:	c2 f1       	brne	8000555c <xg_flashc_init+0x258>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005500:	0f e9       	ld.ub	r9,r7[0x6]
80005502:	0f f8       	ld.ub	r8,r7[0x7]
80005504:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005508:	0f aa       	ld.ub	r10,r7[0x2]
8000550a:	0f b8       	ld.ub	r8,r7[0x3]
8000550c:	b1 68       	lsl	r8,0x10
8000550e:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005512:	0f ca       	ld.ub	r10,r7[0x4]
80005514:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005518:	0f da       	ld.ub	r10,r7[0x5]
8000551a:	f5 e8 10 08 	or	r8,r10,r8
8000551e:	f2 08 00 08 	add	r8,r9,r8
80005522:	4a d6       	lddpc	r6,800055d4 <xg_flashc_init+0x2d0>
80005524:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005526:	1a d8       	st.w	--sp,r8
80005528:	4a cc       	lddpc	r12,800055d8 <xg_flashc_init+0x2d4>
8000552a:	f0 1f 00 18 	mcall	80005588 <xg_flashc_init+0x284>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
8000552e:	2f fd       	sub	sp,-4
80005530:	6c 08       	ld.w	r8,r6[0x0]
80005532:	e0 69 f0 00 	mov	r9,61440
80005536:	ea 19 80 05 	orh	r9,0x8005
8000553a:	12 38       	cp.w	r8,r9
8000553c:	e0 88 00 17 	brls	8000556a <xg_flashc_init+0x266>
										
								log("\r\n----message storage is full!!!----\r\n");
80005540:	4a 7c       	lddpc	r12,800055dc <xg_flashc_init+0x2d8>
80005542:	f0 1f 00 12 	mcall	80005588 <xg_flashc_init+0x284>
								//xgflash erase
								
								flashc_memset64((void *)LABEL_ADDRESS, (void *)0x00, LABEL_LENGTH,  true);
80005546:	30 18       	mov	r8,1
80005548:	30 79       	mov	r9,7
8000554a:	30 0a       	mov	r10,0
8000554c:	30 0b       	mov	r11,0
8000554e:	e0 6c b0 00 	mov	r12,45056
80005552:	ea 1c 80 04 	orh	r12,0x8004
80005556:	f0 1f 00 23 	mcall	800055e0 <xg_flashc_init+0x2dc>
8000555a:	c2 0b       	rjmp	8000539a <xg_flashc_init+0x96>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
8000555c:	49 dc       	lddpc	r12,800055d0 <xg_flashc_init+0x2cc>
8000555e:	f0 1f 00 0b 	mcall	80005588 <xg_flashc_init+0x284>
80005562:	30 07       	mov	r7,0
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
80005564:	49 26       	lddpc	r6,800055ac <xg_flashc_init+0x2a8>
				flashc_erase_page(current_page_number, true);
80005566:	30 15       	mov	r5,1
80005568:	c3 eb       	rjmp	800053e4 <xg_flashc_init+0xe0>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
8000556a:	49 fc       	lddpc	r12,800055e4 <xg_flashc_init+0x2e0>
8000556c:	f0 1f 00 07 	mcall	80005588 <xg_flashc_init+0x284>
			}
		}
				
		//memcpy(xg_message_count_ptr, &current_message_index, sizeof(current_message_index));
		list_init_success_flag = 1;
80005570:	30 19       	mov	r9,1
80005572:	49 e8       	lddpc	r8,800055e8 <xg_flashc_init+0x2e4>
80005574:	b0 89       	st.b	r8[0x0],r9
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
80005576:	2f ed       	sub	sp,-8
80005578:	d8 32       	popm	r0-r7,pc
8000557a:	00 00       	add	r0,r0
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	6c 30       	ld.w	r0,r6[0xc]
80005580:	00 00       	add	r0,r0
80005582:	0b 74       	ld.ub	r4,--r5
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	e0 b0 80 00 	rcall	80035586 <_data_lma+0x26a36>
8000558a:	77 68       	ld.w	r8,r11[0x58]
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	6c 88       	ld.w	r8,r6[0x20]
80005590:	00 00       	add	r0,r0
80005592:	0b 6c       	ld.uh	r12,--r5
80005594:	00 00       	add	r0,r0
80005596:	0b 7c       	ld.ub	r12,--r5
80005598:	00 00       	add	r0,r0
8000559a:	0e 06       	add	r6,r7
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	2c 1c       	sub	r12,-63
800055a0:	00 00       	add	r0,r0
800055a2:	0b 88       	ld.ub	r8,r5[0x0]
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	5b 4c       	cp.w	r12,-12
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	57 f4       	stdsp	sp[0x1fc],r4
800055ac:	00 00       	add	r0,r0
800055ae:	0b 80       	ld.ub	r0,r5[0x0]
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	57 d4       	stdsp	sp[0x1f4],r4
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	57 e4       	stdsp	sp[0x1f8],r4
800055b8:	00 00       	add	r0,r0
800055ba:	05 34       	ld.ub	r4,r2++
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	7f f0       	ld.w	r0,pc[0x7c]
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	58 7c       	cp.w	r12,7
800055c4:	00 00       	add	r0,r0
800055c6:	0b 84       	ld.ub	r4,r5[0x0]
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	e0 dc 80 00 	satsub.w	r12,r0,-32768
800055ce:	e1 08 80 00 	ld.sh	r8,r0[-32768]
800055d2:	e1 14 00 00 	ld.uh	r4,r0[0]
800055d6:	05 3c       	ld.ub	r12,r2++
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	e1 3c 80 00 	ld.ub	r12,r0[-32768]
800055de:	e1 60 80 00 	st.b	r0[-32768],r0
800055e2:	59 14       	cp.w	r4,17
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	e1 88       	*unknown*
800055e8:	00 00       	add	r0,r0
800055ea:	0b 70       	ld.ub	r0,--r5

800055ec <xgflash_message_save>:
	
}

static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
800055ec:	eb cd 40 e0 	pushm	r5-r7,lr
800055f0:	20 2d       	sub	sp,8
800055f2:	18 97       	mov	r7,r12
800055f4:	14 96       	mov	r6,r10

	if(!list_init_success_flag)return XG_ERROR;
800055f6:	4d 78       	lddpc	r8,80005750 <xgflash_message_save+0x164>
800055f8:	11 89       	ld.ub	r9,r8[0x0]
800055fa:	30 08       	mov	r8,0
800055fc:	f0 09 18 00 	cp.b	r9,r8
80005600:	c0 31       	brne	80005606 <xgflash_message_save+0x1a>
80005602:	3f fc       	mov	r12,-1
80005604:	ca 38       	rjmp	8000574a <xgflash_message_save+0x15e>
	U32 address = 0;
	static U32 bytes_remained = 0;
		
	current_bytes_remained+=data_len;//accumulate
80005606:	eb db c0 10 	bfextu	r5,r11,0x0,0x10
8000560a:	4d 38       	lddpc	r8,80005754 <xgflash_message_save+0x168>
8000560c:	70 09       	ld.w	r9,r8[0x0]
8000560e:	ea 09 00 09 	add	r9,r5,r9
80005612:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80005614:	58 0c       	cp.w	r12,0
80005616:	5f 0a       	sreq	r10
80005618:	e0 68 02 00 	mov	r8,512
8000561c:	f0 0b 19 00 	cp.h	r11,r8
80005620:	5f b8       	srhi	r8
80005622:	f5 e8 10 08 	or	r8,r10,r8
80005626:	e0 81 00 91 	brne	80005748 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
8000562a:	e0 49 f0 00 	cp.w	r9,61440
8000562e:	e0 8b 00 8d 	brhi	80005748 <xgflash_message_save+0x15c>
	{
		//current_bytes_remained = 0;
		return XG_INVALID_PARAM;
	}
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock
80005632:	4c a8       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
80005634:	70 0c       	ld.w	r12,r8[0x0]
80005636:	30 09       	mov	r9,0
80005638:	3f fa       	mov	r10,-1
8000563a:	12 9b       	mov	r11,r9
8000563c:	f0 1f 00 48 	mcall	8000575c <xgflash_message_save+0x170>
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
80005640:	4c 88       	lddpc	r8,80005760 <xgflash_message_save+0x174>
80005642:	70 0c       	ld.w	r12,r8[0x0]
80005644:	e0 68 f0 00 	mov	r8,61440
80005648:	ea 18 80 05 	orh	r8,0x8005
8000564c:	10 3c       	cp.w	r12,r8
8000564e:	e0 88 00 0e 	brls	8000566a <xgflash_message_save+0x7e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
80005652:	4c 5c       	lddpc	r12,80005764 <xgflash_message_save+0x178>
80005654:	f0 1f 00 45 	mcall	80005768 <xgflash_message_save+0x17c>
		xSemaphoreGive(xgflash_mutex );//unlock
80005658:	4c 08       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
8000565a:	70 0c       	ld.w	r12,r8[0x0]
8000565c:	30 09       	mov	r9,0
8000565e:	12 9a       	mov	r10,r9
80005660:	12 9b       	mov	r11,r9
80005662:	f0 1f 00 43 	mcall	8000576c <xgflash_message_save+0x180>
80005666:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80005668:	c7 18       	rjmp	8000574a <xgflash_message_save+0x15e>
	}
	
	flashc_memcpy((void *)current_save_message_offset, (void *)data_ptr, data_len,  true);
8000566a:	30 19       	mov	r9,1
8000566c:	0a 9a       	mov	r10,r5
8000566e:	0e 9b       	mov	r11,r7
80005670:	f0 1f 00 40 	mcall	80005770 <xgflash_message_save+0x184>
	if (flashc_is_lock_error() || flashc_is_programming_error())
80005674:	f0 1f 00 40 	mcall	80005774 <xgflash_message_save+0x188>
80005678:	c0 41       	brne	80005680 <xgflash_message_save+0x94>
8000567a:	f0 1f 00 40 	mcall	80005778 <xgflash_message_save+0x18c>
8000567e:	c0 a0       	breq	80005692 <xgflash_message_save+0xa6>
	{
		xSemaphoreGive(xgflash_mutex );//unlock
80005680:	4b 68       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
80005682:	70 0c       	ld.w	r12,r8[0x0]
80005684:	30 09       	mov	r9,0
80005686:	12 9a       	mov	r10,r9
80005688:	12 9b       	mov	r11,r9
8000568a:	f0 1f 00 39 	mcall	8000576c <xgflash_message_save+0x180>
8000568e:	30 6c       	mov	r12,6
		return XG_FLASH_ACTION_FAIL;
80005690:	c5 d8       	rjmp	8000574a <xgflash_message_save+0x15e>
	}
	current_save_message_offset+=data_len;
80005692:	4b 48       	lddpc	r8,80005760 <xgflash_message_save+0x174>
80005694:	70 09       	ld.w	r9,r8[0x0]
80005696:	12 05       	add	r5,r9
80005698:	91 05       	st.w	r8[0x0],r5
	//log("current_save_message_offset : %X\n", current_save_message_offset);
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
8000569a:	30 18       	mov	r8,1
8000569c:	f0 06 18 00 	cp.b	r6,r8
800056a0:	c4 b1       	brne	80005736 <xgflash_message_save+0x14a>
	{
		current_message_index++;
800056a2:	4b 79       	lddpc	r9,8000577c <xgflash_message_save+0x190>
800056a4:	92 08       	ld.sh	r8,r9[0x0]
800056a6:	2f f8       	sub	r8,-1
800056a8:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
800056aa:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
800056ac:	4a a9       	lddpc	r9,80005754 <xgflash_message_save+0x168>
800056ae:	72 09       	ld.w	r9,r9[0x0]
800056b0:	12 15       	sub	r5,r9
800056b2:	40 0a       	lddsp	r10,sp[0x0]
800056b4:	e0 1a 00 00 	andl	r10,0x0
800056b8:	f5 e5 13 0a 	or	r10,r10,r5>>0x10
800056bc:	50 0a       	stdsp	sp[0x0],r10
800056be:	ba 25       	st.h	sp[0x4],r5
		ptr.offset		= current_bytes_remained;
800056c0:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
800056c2:	5c 78       	castu.h	r8
800056c4:	f0 cc 00 01 	sub	r12,r8,1
800056c8:	e0 68 b0 09 	mov	r8,45065
800056cc:	ea 18 80 04 	orh	r8,0x8004
800056d0:	f0 0c 00 3c 	add	r12,r8,r12<<0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
800056d4:	fc 18 80 05 	movh	r8,0x8005
800056d8:	10 3c       	cp.w	r12,r8
800056da:	e0 88 00 0e 	brls	800056f6 <xgflash_message_save+0x10a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
800056de:	4a 9c       	lddpc	r12,80005780 <xgflash_message_save+0x194>
800056e0:	f0 1f 00 22 	mcall	80005768 <xgflash_message_save+0x17c>
			xSemaphoreGive(xgflash_mutex );//unlock
800056e4:	49 d8       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
800056e6:	70 0c       	ld.w	r12,r8[0x0]
800056e8:	30 09       	mov	r9,0
800056ea:	12 9a       	mov	r10,r9
800056ec:	12 9b       	mov	r11,r9
800056ee:	f0 1f 00 20 	mcall	8000576c <xgflash_message_save+0x180>
800056f2:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
800056f4:	c2 b8       	rjmp	8000574a <xgflash_message_save+0x15e>
		}
		//set a message info by current_message_index		
		flashc_memcpy((void *)address, (void *)&ptr, XG_MESSAGE_INFO_HEADER_LENGTH,  true);
800056f6:	30 19       	mov	r9,1
800056f8:	30 8a       	mov	r10,8
800056fa:	1a 9b       	mov	r11,sp
800056fc:	f0 1f 00 1d 	mcall	80005770 <xgflash_message_save+0x184>
		
		//set message numbers
		flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)&current_message_index, MESSAGE_NUMBERS_LENGTH,  true);
80005700:	30 19       	mov	r9,1
80005702:	30 2a       	mov	r10,2
80005704:	49 eb       	lddpc	r11,8000577c <xgflash_message_save+0x190>
80005706:	e0 6c b0 07 	mov	r12,45063
8000570a:	ea 1c 80 04 	orh	r12,0x8004
8000570e:	f0 1f 00 19 	mcall	80005770 <xgflash_message_save+0x184>

		if (flashc_is_lock_error() || flashc_is_programming_error())
80005712:	f0 1f 00 19 	mcall	80005774 <xgflash_message_save+0x188>
80005716:	c0 41       	brne	8000571e <xgflash_message_save+0x132>
80005718:	f0 1f 00 18 	mcall	80005778 <xgflash_message_save+0x18c>
8000571c:	c0 a0       	breq	80005730 <xgflash_message_save+0x144>
		{
			xSemaphoreGive(xgflash_mutex );//unlock
8000571e:	48 f8       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
80005720:	70 0c       	ld.w	r12,r8[0x0]
80005722:	30 09       	mov	r9,0
80005724:	12 9a       	mov	r10,r9
80005726:	12 9b       	mov	r11,r9
80005728:	f0 1f 00 11 	mcall	8000576c <xgflash_message_save+0x180>
8000572c:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
8000572e:	c0 e8       	rjmp	8000574a <xgflash_message_save+0x15e>
		}
		
		current_bytes_remained = 0;//reset 0
80005730:	30 09       	mov	r9,0
80005732:	48 98       	lddpc	r8,80005754 <xgflash_message_save+0x168>
80005734:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
80005736:	48 98       	lddpc	r8,80005758 <xgflash_message_save+0x16c>
80005738:	70 0c       	ld.w	r12,r8[0x0]
8000573a:	30 09       	mov	r9,0
8000573c:	12 9a       	mov	r10,r9
8000573e:	12 9b       	mov	r11,r9
80005740:	f0 1f 00 0b 	mcall	8000576c <xgflash_message_save+0x180>
80005744:	30 0c       	mov	r12,0
	return XG_OK;
80005746:	c0 28       	rjmp	8000574a <xgflash_message_save+0x15e>
80005748:	30 1c       	mov	r12,1

}
8000574a:	2f ed       	sub	sp,-8
8000574c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005750:	00 00       	add	r0,r0
80005752:	0b 70       	ld.ub	r0,--r5
80005754:	00 00       	add	r0,r0
80005756:	0b 78       	ld.ub	r8,--r5
80005758:	00 00       	add	r0,r0
8000575a:	0b 74       	ld.ub	r4,--r5
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	69 24       	ld.w	r4,r4[0x48]
80005760:	00 00       	add	r0,r0
80005762:	05 3c       	ld.ub	r12,r2++
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	e1 b4       	*unknown*
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	77 68       	ld.w	r8,r11[0x58]
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	6b 30       	ld.w	r0,r5[0x4c]
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	5b 4c       	cp.w	r12,-12
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	57 d4       	stdsp	sp[0x1f4],r4
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	57 e4       	stdsp	sp[0x1f8],r4
8000577c:	00 00       	add	r0,r0
8000577e:	0b 84       	ld.ub	r4,r5[0x0]
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	e1 e4 d4 01 	sthh.w	r1[0x100],r0:b,r4:t

80005784 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80005784:	d4 01       	pushm	lr
80005786:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80005788:	31 0a       	mov	r10,16
8000578a:	48 ab       	lddpc	r11,800057b0 <flashc_get_flash_size+0x2c>
8000578c:	1a 9c       	mov	r12,sp
8000578e:	f0 1f 00 0a 	mcall	800057b4 <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
80005792:	fe 68 14 00 	mov	r8,-125952
80005796:	70 28       	ld.w	r8,r8[0x8]
80005798:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
8000579c:	fa c9 ff f0 	sub	r9,sp,-16
800057a0:	f2 08 00 18 	add	r8,r9,r8<<0x1
800057a4:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
800057a8:	ab 6c       	lsl	r12,0xa
800057aa:	2f cd       	sub	sp,-16
800057ac:	d8 02       	popm	pc
800057ae:	00 00       	add	r0,r0
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	e2 0e       	*unknown*
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	80 16       	ld.sh	r6,r0[0x2]

800057b8 <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
800057b8:	fe 68 14 00 	mov	r8,-125952
800057bc:	70 2c       	ld.w	r12,r8[0x8]
}
800057be:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800057c2:	5e fc       	retal	r12

800057c4 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
800057c4:	d4 01       	pushm	lr
	while (!flashc_is_ready());
800057c6:	f0 1f 00 03 	mcall	800057d0 <flashc_default_wait_until_ready+0xc>
800057ca:	cf e0       	breq	800057c6 <flashc_default_wait_until_ready+0x2>
}
800057cc:	d8 02       	popm	pc
800057ce:	00 00       	add	r0,r0
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	57 b8       	stdsp	sp[0x1ec],r8

800057d4 <flashc_is_lock_error>:
//! by a function.
static unsigned int flashc_error_status = 0;


bool flashc_is_lock_error(void)
{
800057d4:	48 38       	lddpc	r8,800057e0 <flashc_is_lock_error+0xc>
800057d6:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
}
800057d8:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
800057dc:	5e fc       	retal	r12
800057de:	00 00       	add	r0,r0
800057e0:	00 00       	add	r0,r0
800057e2:	0b d8       	ld.ub	r8,r5[0x5]

800057e4 <flashc_is_programming_error>:


bool flashc_is_programming_error(void)
{
800057e4:	48 38       	lddpc	r8,800057f0 <flashc_is_programming_error+0xc>
800057e6:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_PROGE_MASK) != 0);
}
800057e8:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
800057ec:	5e fc       	retal	r12
800057ee:	00 00       	add	r0,r0
800057f0:	00 00       	add	r0,r0
800057f2:	0b d8       	ld.ub	r8,r5[0x5]

800057f4 <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
800057f4:	fe 68 14 00 	mov	r8,-125952
800057f8:	70 1c       	ld.w	r12,r8[0x4]
}
800057fa:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
800057fe:	5e fc       	retal	r12

80005800 <flashc_issue_command>:


void flashc_issue_command(unsigned int command, int page_number)
{
80005800:	eb cd 40 c0 	pushm	r6-r7,lr
80005804:	18 96       	mov	r6,r12
80005806:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80005808:	48 e8       	lddpc	r8,80005840 <flashc_issue_command+0x40>
8000580a:	70 08       	ld.w	r8,r8[0x0]
8000580c:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000580e:	fe 68 14 00 	mov	r8,-125952
80005812:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80005814:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
80005818:	58 07       	cp.w	r7,0
8000581a:	c0 35       	brlt	80005820 <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
8000581c:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80005820:	3a 59       	mov	r9,-91
80005822:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80005826:	fe 69 14 00 	mov	r9,-125952
8000582a:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
8000582c:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8000582e:	e2 19 00 0c 	andl	r9,0xc,COH
80005832:	48 58       	lddpc	r8,80005844 <flashc_issue_command+0x44>
80005834:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
80005836:	48 38       	lddpc	r8,80005840 <flashc_issue_command+0x40>
80005838:	70 08       	ld.w	r8,r8[0x0]
8000583a:	5d 18       	icall	r8
}
8000583c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005840:	00 00       	add	r0,r0
80005842:	05 40       	ld.w	r0,--r2
80005844:	00 00       	add	r0,r0
80005846:	0b d8       	ld.ub	r8,r5[0x5]

80005848 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80005848:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
8000584a:	3f fb       	mov	r11,-1
8000584c:	30 3c       	mov	r12,3
8000584e:	f0 1f 00 02 	mcall	80005854 <flashc_clear_page_buffer+0xc>
}
80005852:	d8 02       	popm	pc
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	58 00       	cp.w	r0,0

80005858 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80005858:	fe 68 14 00 	mov	r8,-125952
8000585c:	70 2c       	ld.w	r12,r8[0x8]
}
8000585e:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80005862:	5e fc       	retal	r12

80005864 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80005864:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80005866:	18 9b       	mov	r11,r12
80005868:	30 cc       	mov	r12,12
8000586a:	f0 1f 00 03 	mcall	80005874 <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
8000586e:	f0 1f 00 03 	mcall	80005878 <flashc_quick_page_read+0x14>
}
80005872:	d8 02       	popm	pc
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	58 00       	cp.w	r0,0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	58 58       	cp.w	r8,5

8000587c <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
8000587c:	eb cd 40 c0 	pushm	r6-r7,lr
80005880:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80005882:	18 9b       	mov	r11,r12
80005884:	30 2c       	mov	r12,2
80005886:	f0 1f 00 09 	mcall	800058a8 <flashc_erase_page+0x2c>
	if (check) {
8000588a:	58 07       	cp.w	r7,0
8000588c:	c0 31       	brne	80005892 <flashc_erase_page+0x16>
8000588e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
80005892:	48 77       	lddpc	r7,800058ac <flashc_erase_page+0x30>
80005894:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
80005896:	3f fc       	mov	r12,-1
80005898:	f0 1f 00 06 	mcall	800058b0 <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
8000589c:	6e 08       	ld.w	r8,r7[0x0]
8000589e:	f1 e6 10 06 	or	r6,r8,r6
800058a2:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
800058a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	58 00       	cp.w	r0,0
800058ac:	00 00       	add	r0,r0
800058ae:	0b d8       	ld.ub	r8,r5[0x5]
800058b0:	80 00       	ld.sh	r0,r0[0x0]
800058b2:	58 64       	cp.w	r4,6

800058b4 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
800058b4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
800058b6:	18 9b       	mov	r11,r12
800058b8:	30 1c       	mov	r12,1
800058ba:	f0 1f 00 02 	mcall	800058c0 <flashc_write_page+0xc>
}
800058be:	d8 02       	popm	pc
800058c0:	80 00       	ld.sh	r0,r0[0x0]
800058c2:	58 00       	cp.w	r0,0

800058c4 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
800058c4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
800058c6:	3f fb       	mov	r11,-1
800058c8:	30 fc       	mov	r12,15
800058ca:	f0 1f 00 03 	mcall	800058d4 <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
800058ce:	f0 1f 00 03 	mcall	800058d8 <flashc_quick_user_page_read+0x14>
}
800058d2:	d8 02       	popm	pc
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	58 00       	cp.w	r0,0
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	58 58       	cp.w	r8,5

800058dc <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
800058dc:	eb cd 40 80 	pushm	r7,lr
800058e0:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
800058e2:	3f fb       	mov	r11,-1
800058e4:	30 ec       	mov	r12,14
800058e6:	f0 1f 00 06 	mcall	800058fc <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
800058ea:	58 07       	cp.w	r7,0
800058ec:	c0 31       	brne	800058f2 <flashc_erase_user_page+0x16>
800058ee:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800058f2:	f0 1f 00 04 	mcall	80005900 <flashc_erase_user_page+0x24>
}
800058f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800058fa:	00 00       	add	r0,r0
800058fc:	80 00       	ld.sh	r0,r0[0x0]
800058fe:	58 00       	cp.w	r0,0
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	58 c4       	cp.w	r4,12

80005904 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80005904:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
80005906:	3f fb       	mov	r11,-1
80005908:	30 dc       	mov	r12,13
8000590a:	f0 1f 00 02 	mcall	80005910 <flashc_write_user_page+0xc>
}
8000590e:	d8 02       	popm	pc
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	58 00       	cp.w	r0,0

80005914 <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
80005914:	d4 31       	pushm	r0-r7,lr
80005916:	20 cd       	sub	sp,48
80005918:	50 6c       	stdsp	sp[0x18],r12
8000591a:	14 94       	mov	r4,r10
8000591c:	16 95       	mov	r5,r11
8000591e:	12 96       	mov	r6,r9
80005920:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
80005922:	30 08       	mov	r8,0
80005924:	30 09       	mov	r9,0
80005926:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000592a:	f0 1f 00 82 	mcall	80005b30 <flashc_memset64+0x21c>
8000592e:	fc 18 80 00 	movh	r8,0x8000
80005932:	f8 08 00 08 	add	r8,r12,r8
80005936:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
80005938:	40 6b       	lddsp	r11,sp[0x18]
8000593a:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000593c:	58 04       	cp.w	r4,0
8000593e:	5c 25       	cpc	r5
80005940:	c1 80       	breq	80005970 <flashc_memset64+0x5c>
80005942:	f6 c8 ff f9 	sub	r8,r11,-7
80005946:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
8000594a:	fa c9 ff d0 	sub	r9,sp,-48
8000594e:	10 09       	add	r9,r8
80005950:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
80005954:	e8 0c 16 08 	lsr	r12,r4,0x8
80005958:	ea 0a 16 08 	lsr	r10,r5,0x8
8000595c:	f9 e5 11 89 	or	r9,r12,r5<<0x18
80005960:	14 95       	mov	r5,r10
80005962:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80005964:	20 18       	sub	r8,1
80005966:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000596a:	58 04       	cp.w	r4,0
8000596c:	5c 25       	cpc	r5
8000596e:	ce e1       	brne	8000594a <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80005970:	f6 06 00 06 	add	r6,r11,r6
80005974:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80005976:	e0 6a ff ff 	mov	r10,65535
8000597a:	ea 1a 7f ff 	orh	r10,0x7fff
8000597e:	14 3b       	cp.w	r11,r10
80005980:	e0 8b 00 05 	brhi	8000598a <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
80005984:	fc 17 80 00 	movh	r7,0x8000
80005988:	c0 e8       	rjmp	800059a4 <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
8000598a:	40 29       	lddsp	r9,sp[0x8]
8000598c:	16 39       	cp.w	r9,r11
8000598e:	e0 8b 00 0b 	brhi	800059a4 <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80005992:	fc 18 80 80 	movh	r8,0x8080
80005996:	e0 6a ff ff 	mov	r10,65535
8000599a:	ea 1a 80 7f 	orh	r10,0x807f
8000599e:	14 3b       	cp.w	r11,r10
800059a0:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
800059a4:	40 09       	lddsp	r9,sp[0x0]
800059a6:	e0 68 02 00 	mov	r8,512
800059aa:	ea 18 80 80 	orh	r8,0x8080
800059ae:	10 39       	cp.w	r9,r8
800059b0:	e0 88 00 04 	brls	800059b8 <flashc_memset64+0xa4>
800059b4:	50 08       	stdsp	sp[0x0],r8
800059b6:	c0 c8       	rjmp	800059ce <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
800059b8:	40 0a       	lddsp	r10,sp[0x0]
800059ba:	fc 19 80 80 	movh	r9,0x8080
800059be:	12 3a       	cp.w	r10,r9
800059c0:	e0 8b 00 07 	brhi	800059ce <flashc_memset64+0xba>
800059c4:	40 28       	lddsp	r8,sp[0x8]
800059c6:	10 3a       	cp.w	r10,r8
800059c8:	f0 0a 17 b0 	movhi	r10,r8
800059cc:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
800059ce:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
800059d0:	10 9b       	mov	r11,r8
800059d2:	e0 1b ff f8 	andl	r11,0xfff8
800059d6:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800059d8:	fa e4 00 28 	ld.d	r4,sp[40]
800059dc:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
800059de:	4d 66       	lddpc	r6,80005b34 <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
800059e0:	10 9a       	mov	r10,r8
800059e2:	e0 1a fe 00 	andl	r10,0xfe00
800059e6:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
800059e8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800059ec:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
800059ee:	40 08       	lddsp	r8,sp[0x0]
800059f0:	40 59       	lddsp	r9,sp[0x14]
800059f2:	12 18       	sub	r8,r9
800059f4:	2f 88       	sub	r8,-8
800059f6:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800059f8:	c9 18       	rjmp	80005b1a <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800059fa:	f0 1f 00 50 	mcall	80005b38 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
800059fe:	6c 08       	ld.w	r8,r6[0x0]
80005a00:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
80005a02:	04 9c       	mov	r12,r2
80005a04:	e0 1c fe 00 	andl	r12,0xfe00
80005a08:	f8 ce fe 00 	sub	lr,r12,-512
80005a0c:	40 18       	lddsp	r8,sp[0x4]
80005a0e:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80005a12:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
80005a16:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
80005a1a:	c2 f0       	breq	80005a78 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80005a1c:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80005a1e:	18 90       	mov	r0,r12
80005a20:	04 91       	mov	r1,r2
80005a22:	e0 11 ff f8 	andl	r1,0xfff8
80005a26:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80005a28:	18 31       	cp.w	r1,r12
80005a2a:	e0 88 00 10 	brls	80005a4a <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
80005a2e:	f0 ea 00 00 	ld.d	r10,r8[0]
80005a32:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80005a34:	10 39       	cp.w	r9,r8
80005a36:	fe 9b ff fc 	brhi	80005a2e <flashc_memset64+0x11a>
80005a3a:	e0 08 11 ff 	rsub	r8,r0,-1
80005a3e:	02 08       	add	r8,r1
80005a40:	e0 18 ff f8 	andl	r8,0xfff8
80005a44:	2f 88       	sub	r8,-8
80005a46:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
80005a4a:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
80005a4e:	c1 50       	breq	80005a78 <flashc_memset64+0x164>
80005a50:	30 0a       	mov	r10,0
80005a52:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
80005a56:	17 8b       	ld.ub	r11,r11[0x0]
80005a58:	fa c7 ff e0 	sub	r7,sp,-32
80005a5c:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80005a60:	2f fa       	sub	r10,-1
80005a62:	04 3a       	cp.w	r10,r2
80005a64:	cf 71       	brne	80005a52 <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80005a66:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
80005a68:	40 1b       	lddsp	r11,sp[0x4]
80005a6a:	16 39       	cp.w	r9,r11
80005a6c:	c0 62       	brcc	80005a78 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
80005a6e:	fa e8 00 20 	ld.d	r8,sp[32]
80005a72:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
80005a74:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005a78:	0e 99       	mov	r9,r7
80005a7a:	0e 1e       	sub	lr,r7
80005a7c:	a3 5e       	asr	lr,0x3
80005a7e:	c0 80       	breq	80005a8e <flashc_memset64+0x17a>
80005a80:	0e 9a       	mov	r10,r7
80005a82:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
80005a84:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005a86:	20 18       	sub	r8,1
80005a88:	cf e1       	brne	80005a84 <flashc_memset64+0x170>
80005a8a:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80005a8e:	40 4a       	lddsp	r10,sp[0x10]
80005a90:	14 3c       	cp.w	r12,r10
80005a92:	c1 d3       	brcs	80005acc <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80005a94:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005a96:	40 59       	lddsp	r9,sp[0x14]
80005a98:	58 09       	cp.w	r9,0
80005a9a:	c1 00       	breq	80005aba <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80005a9c:	10 99       	mov	r9,r8
80005a9e:	fa c8 ff e0 	sub	r8,sp,-32
80005aa2:	40 5b       	lddsp	r11,sp[0x14]
80005aa4:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
80005aa6:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
80005aaa:	13 3a       	ld.ub	r10,r9++
80005aac:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80005aae:	16 38       	cp.w	r8,r11
80005ab0:	cf d1       	brne	80005aaa <flashc_memset64+0x196>
80005ab2:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80005ab4:	fa ea 00 20 	ld.d	r10,sp[32]
80005ab8:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005aba:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005abe:	c0 70       	breq	80005acc <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
80005ac0:	f0 ea 00 00 	ld.d	r10,r8[0]
80005ac4:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005ac6:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005aca:	cf b1       	brne	80005ac0 <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
80005acc:	0e 92       	mov	r2,r7
80005ace:	fc 1a 80 80 	movh	r10,0x8080
80005ad2:	14 37       	cp.w	r7,r10
80005ad4:	e0 8b 00 17 	brhi	80005b02 <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80005ad8:	40 39       	lddsp	r9,sp[0xc]
80005ada:	58 09       	cp.w	r9,0
80005adc:	c0 70       	breq	80005aea <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
80005ade:	30 0b       	mov	r11,0
80005ae0:	3f fc       	mov	r12,-1
80005ae2:	f0 1f 00 17 	mcall	80005b3c <flashc_memset64+0x228>
				error_status |= flashc_error_status;
80005ae6:	6c 08       	ld.w	r8,r6[0x0]
80005ae8:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
80005aea:	3f fc       	mov	r12,-1
80005aec:	f0 1f 00 15 	mcall	80005b40 <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
80005af0:	6c 08       	ld.w	r8,r6[0x0]
80005af2:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80005af4:	fc 18 80 80 	movh	r8,0x8080
80005af8:	40 2b       	lddsp	r11,sp[0x8]
80005afa:	04 3b       	cp.w	r11,r2
80005afc:	f0 07 17 80 	movls	r7,r8
80005b00:	c0 d8       	rjmp	80005b1a <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
80005b02:	40 3a       	lddsp	r10,sp[0xc]
80005b04:	58 0a       	cp.w	r10,0
80005b06:	c0 60       	breq	80005b12 <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
80005b08:	30 0c       	mov	r12,0
80005b0a:	f0 1f 00 0f 	mcall	80005b44 <flashc_memset64+0x230>
				error_status |= flashc_error_status;
80005b0e:	6c 08       	ld.w	r8,r6[0x0]
80005b10:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
80005b12:	f0 1f 00 0e 	mcall	80005b48 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
80005b16:	6c 08       	ld.w	r8,r6[0x0]
80005b18:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80005b1a:	0e 92       	mov	r2,r7
80005b1c:	40 09       	lddsp	r9,sp[0x0]
80005b1e:	12 37       	cp.w	r7,r9
80005b20:	fe 93 ff 6d 	brlo	800059fa <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
80005b24:	48 48       	lddpc	r8,80005b34 <flashc_memset64+0x220>
80005b26:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
80005b28:	40 6c       	lddsp	r12,sp[0x18]
80005b2a:	2f 4d       	sub	sp,-48
80005b2c:	d8 32       	popm	r0-r7,pc
80005b2e:	00 00       	add	r0,r0
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	57 84       	stdsp	sp[0x1e0],r4
80005b34:	00 00       	add	r0,r0
80005b36:	0b d8       	ld.ub	r8,r5[0x5]
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	58 48       	cp.w	r8,4
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	58 7c       	cp.w	r12,7
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	58 b4       	cp.w	r4,11
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	58 dc       	cp.w	r12,13
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	59 04       	cp.w	r4,16

80005b4c <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80005b4c:	d4 31       	pushm	r0-r7,lr
80005b4e:	20 7d       	sub	sp,28
80005b50:	50 1c       	stdsp	sp[0x4],r12
80005b52:	14 97       	mov	r7,r10
80005b54:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
80005b56:	e0 69 ff ff 	mov	r9,65535
80005b5a:	ea 19 80 7f 	orh	r9,0x807f
80005b5e:	12 3c       	cp.w	r12,r9
80005b60:	5f b8       	srhi	r8
80005b62:	50 28       	stdsp	sp[0x8],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80005b64:	58 0a       	cp.w	r10,0
80005b66:	c0 41       	brne	80005b6e <flashc_memcpy+0x22>
80005b68:	30 09       	mov	r9,0
80005b6a:	50 09       	stdsp	sp[0x0],r9
80005b6c:	c5 b8       	rjmp	80005c22 <flashc_memcpy+0xd6>
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
80005b6e:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
80005b70:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
80005b72:	0c 90       	mov	r0,r6
80005b74:	e0 10 fe 00 	andl	r0,0xfe00
80005b78:	30 08       	mov	r8,0
80005b7a:	50 08       	stdsp	sp[0x0],r8

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
80005b7c:	4a d1       	lddpc	r1,80005c30 <flashc_memcpy+0xe4>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80005b7e:	30 05       	mov	r5,0
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005b80:	fa c3 ff ec 	sub	r3,sp,-20
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005b84:	10 92       	mov	r2,r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
80005b86:	f0 1f 00 2c 	mcall	80005c34 <flashc_memcpy+0xe8>
		error_status |= flashc_error_status;
80005b8a:	62 08       	ld.w	r8,r1[0x0]
80005b8c:	40 09       	lddsp	r9,sp[0x0]
80005b8e:	10 49       	or	r9,r8
80005b90:	50 09       	stdsp	sp[0x0],r9
80005b92:	00 9b       	mov	r11,r0
80005b94:	e0 ce fe 00 	sub	lr,r0,-512
80005b98:	16 9c       	mov	r12,r11

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005b9a:	f6 e8 00 00 	ld.d	r8,r11[0]
80005b9e:	fa e9 00 14 	st.d	sp[20],r8
80005ba2:	04 98       	mov	r8,r2

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80005ba4:	58 07       	cp.w	r7,0
80005ba6:	5f 1a       	srne	r10
80005ba8:	f0 0b 00 09 	add	r9,r8,r11
80005bac:	12 36       	cp.w	r6,r9
80005bae:	5f 09       	sreq	r9
80005bb0:	f5 e9 00 09 	and	r9,r10,r9
80005bb4:	ea 09 18 00 	cp.b	r9,r5
80005bb8:	c0 60       	breq	80005bc4 <flashc_memcpy+0x78>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005bba:	09 39       	ld.ub	r9,r4++
80005bbc:	e6 08 0b 09 	st.b	r3[r8],r9
					dest_add++;
80005bc0:	2f f6       	sub	r6,-1
					nbytes--;
80005bc2:	20 17       	sub	r7,1
80005bc4:	2f f8       	sub	r8,-1
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80005bc6:	58 88       	cp.w	r8,8
80005bc8:	ce e1       	brne	80005ba4 <flashc_memcpy+0x58>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
80005bca:	fa e8 00 14 	ld.d	r8,sp[20]
80005bce:	f8 e9 00 00 	st.d	r12[0],r8
80005bd2:	2f 8b       	sub	r11,-8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80005bd4:	1c 3b       	cp.w	r11,lr
80005bd6:	ce 11       	brne	80005b98 <flashc_memcpy+0x4c>
80005bd8:	50 37       	stdsp	sp[0xc],r7
80005bda:	e0 c0 fe 00 	sub	r0,r0,-512
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
80005bde:	40 48       	lddsp	r8,sp[0x10]
80005be0:	58 08       	cp.w	r8,0
80005be2:	c1 00       	breq	80005c02 <flashc_memcpy+0xb6>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
80005be4:	40 29       	lddsp	r9,sp[0x8]
80005be6:	58 09       	cp.w	r9,0
80005be8:	c0 50       	breq	80005bf2 <flashc_memcpy+0xa6>
80005bea:	30 0c       	mov	r12,0
80005bec:	f0 1f 00 13 	mcall	80005c38 <flashc_memcpy+0xec>
80005bf0:	c0 58       	rjmp	80005bfa <flashc_memcpy+0xae>
80005bf2:	30 0b       	mov	r11,0
80005bf4:	3f fc       	mov	r12,-1
80005bf6:	f0 1f 00 12 	mcall	80005c3c <flashc_memcpy+0xf0>
			error_status |= flashc_error_status;
80005bfa:	62 08       	ld.w	r8,r1[0x0]
80005bfc:	40 09       	lddsp	r9,sp[0x0]
80005bfe:	10 49       	or	r9,r8
80005c00:	50 09       	stdsp	sp[0x0],r9
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
80005c02:	40 28       	lddsp	r8,sp[0x8]
80005c04:	58 08       	cp.w	r8,0
80005c06:	c0 40       	breq	80005c0e <flashc_memcpy+0xc2>
80005c08:	f0 1f 00 0e 	mcall	80005c40 <flashc_memcpy+0xf4>
80005c0c:	c0 48       	rjmp	80005c14 <flashc_memcpy+0xc8>
80005c0e:	3f fc       	mov	r12,-1
80005c10:	f0 1f 00 0d 	mcall	80005c44 <flashc_memcpy+0xf8>
		error_status |= flashc_error_status;
80005c14:	62 08       	ld.w	r8,r1[0x0]
80005c16:	40 09       	lddsp	r9,sp[0x0]
80005c18:	10 49       	or	r9,r8
80005c1a:	50 09       	stdsp	sp[0x0],r9

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80005c1c:	40 38       	lddsp	r8,sp[0xc]
80005c1e:	58 08       	cp.w	r8,0
80005c20:	cb 31       	brne	80005b86 <flashc_memcpy+0x3a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
80005c22:	48 48       	lddpc	r8,80005c30 <flashc_memcpy+0xe4>
80005c24:	40 09       	lddsp	r9,sp[0x0]
80005c26:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
80005c28:	40 1c       	lddsp	r12,sp[0x4]
80005c2a:	2f 9d       	sub	sp,-28
80005c2c:	d8 32       	popm	r0-r7,pc
80005c2e:	00 00       	add	r0,r0
80005c30:	00 00       	add	r0,r0
80005c32:	0b d8       	ld.ub	r8,r5[0x5]
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	58 48       	cp.w	r8,4
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	58 dc       	cp.w	r12,13
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	58 7c       	cp.w	r12,7
80005c40:	80 00       	ld.sh	r0,r0[0x0]
80005c42:	59 04       	cp.w	r4,16
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	58 b4       	cp.w	r4,11

80005c48 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005c48:	f8 08 16 05 	lsr	r8,r12,0x5
80005c4c:	a9 68       	lsl	r8,0x8
80005c4e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005c52:	58 1b       	cp.w	r11,1
80005c54:	c0 d0       	breq	80005c6e <gpio_enable_module_pin+0x26>
80005c56:	c0 63       	brcs	80005c62 <gpio_enable_module_pin+0x1a>
80005c58:	58 2b       	cp.w	r11,2
80005c5a:	c1 00       	breq	80005c7a <gpio_enable_module_pin+0x32>
80005c5c:	58 3b       	cp.w	r11,3
80005c5e:	c1 40       	breq	80005c86 <gpio_enable_module_pin+0x3e>
80005c60:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c62:	30 19       	mov	r9,1
80005c64:	f2 0c 09 49 	lsl	r9,r9,r12
80005c68:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c6a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c6c:	c1 28       	rjmp	80005c90 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c6e:	30 19       	mov	r9,1
80005c70:	f2 0c 09 49 	lsl	r9,r9,r12
80005c74:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c76:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c78:	c0 c8       	rjmp	80005c90 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c7a:	30 19       	mov	r9,1
80005c7c:	f2 0c 09 49 	lsl	r9,r9,r12
80005c80:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c82:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c84:	c0 68       	rjmp	80005c90 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c86:	30 19       	mov	r9,1
80005c88:	f2 0c 09 49 	lsl	r9,r9,r12
80005c8c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c8e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005c90:	30 19       	mov	r9,1
80005c92:	f2 0c 09 4c 	lsl	r12,r9,r12
80005c96:	91 2c       	st.w	r8[0x8],r12
80005c98:	5e fd       	retal	0
80005c9a:	d7 03       	nop

80005c9c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005c9c:	d4 21       	pushm	r4-r7,lr
80005c9e:	18 97       	mov	r7,r12
80005ca0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005ca2:	58 0b       	cp.w	r11,0
80005ca4:	c0 31       	brne	80005caa <gpio_enable_module+0xe>
80005ca6:	30 05       	mov	r5,0
80005ca8:	c0 d8       	rjmp	80005cc2 <gpio_enable_module+0x26>
80005caa:	30 06       	mov	r6,0
80005cac:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005cae:	6e 1b       	ld.w	r11,r7[0x4]
80005cb0:	6e 0c       	ld.w	r12,r7[0x0]
80005cb2:	f0 1f 00 06 	mcall	80005cc8 <gpio_enable_module+0x2c>
80005cb6:	18 45       	or	r5,r12
		gpiomap++;
80005cb8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005cba:	2f f6       	sub	r6,-1
80005cbc:	0c 34       	cp.w	r4,r6
80005cbe:	fe 9b ff f8 	brhi	80005cae <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005cc2:	0a 9c       	mov	r12,r5
80005cc4:	d8 22       	popm	r4-r7,pc
80005cc6:	00 00       	add	r0,r0
80005cc8:	80 00       	ld.sh	r0,r0[0x0]
80005cca:	5c 48       	abs	r8

80005ccc <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005ccc:	f8 08 16 05 	lsr	r8,r12,0x5
80005cd0:	a9 68       	lsl	r8,0x8
80005cd2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005cd6:	30 19       	mov	r9,1
80005cd8:	f2 0c 09 4c 	lsl	r12,r9,r12
80005cdc:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005ce0:	91 1c       	st.w	r8[0x4],r12
}
80005ce2:	5e fc       	retal	r12

80005ce4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005ce4:	f8 08 16 05 	lsr	r8,r12,0x5
80005ce8:	a9 68       	lsl	r8,0x8
80005cea:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005cee:	30 19       	mov	r9,1
80005cf0:	f2 0c 09 4c 	lsl	r12,r9,r12
80005cf4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005cf8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005cfc:	91 1c       	st.w	r8[0x4],r12
}
80005cfe:	5e fc       	retal	r12

80005d00 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005d00:	f8 08 16 05 	lsr	r8,r12,0x5
80005d04:	a9 68       	lsl	r8,0x8
80005d06:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005d0a:	30 19       	mov	r9,1
80005d0c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005d10:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005d14:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005d18:	91 1c       	st.w	r8[0x4],r12
}
80005d1a:	5e fc       	retal	r12

80005d1c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005d1c:	c0 08       	rjmp	80005d1c <_unhandled_interrupt>
80005d1e:	d7 03       	nop

80005d20 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005d20:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005d24:	49 99       	lddpc	r9,80005d88 <INTC_register_interrupt+0x68>
80005d26:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005d2a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005d2e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005d30:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005d34:	58 0a       	cp.w	r10,0
80005d36:	c0 91       	brne	80005d48 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d38:	49 59       	lddpc	r9,80005d8c <INTC_register_interrupt+0x6c>
80005d3a:	49 6a       	lddpc	r10,80005d90 <INTC_register_interrupt+0x70>
80005d3c:	12 1a       	sub	r10,r9
80005d3e:	fe 79 08 00 	mov	r9,-63488
80005d42:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d46:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005d48:	58 1a       	cp.w	r10,1
80005d4a:	c0 a1       	brne	80005d5e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005d4c:	49 09       	lddpc	r9,80005d8c <INTC_register_interrupt+0x6c>
80005d4e:	49 2a       	lddpc	r10,80005d94 <INTC_register_interrupt+0x74>
80005d50:	12 1a       	sub	r10,r9
80005d52:	bf aa       	sbr	r10,0x1e
80005d54:	fe 79 08 00 	mov	r9,-63488
80005d58:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d5c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005d5e:	58 2a       	cp.w	r10,2
80005d60:	c0 a1       	brne	80005d74 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005d62:	48 b9       	lddpc	r9,80005d8c <INTC_register_interrupt+0x6c>
80005d64:	48 da       	lddpc	r10,80005d98 <INTC_register_interrupt+0x78>
80005d66:	12 1a       	sub	r10,r9
80005d68:	bf ba       	sbr	r10,0x1f
80005d6a:	fe 79 08 00 	mov	r9,-63488
80005d6e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d72:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005d74:	48 69       	lddpc	r9,80005d8c <INTC_register_interrupt+0x6c>
80005d76:	48 aa       	lddpc	r10,80005d9c <INTC_register_interrupt+0x7c>
80005d78:	12 1a       	sub	r10,r9
80005d7a:	ea 1a c0 00 	orh	r10,0xc000
80005d7e:	fe 79 08 00 	mov	r9,-63488
80005d82:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d86:	5e fc       	retal	r12
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	e2 20 80 00 	sub	r0,163840
80005d8e:	d6 00       	acall	0x60
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	d7 04       	*unknown*
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	d7 12       	popm	r0-r3,r11-r12,lr
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	d7 20       	acall	0x72
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	d7 2e       	*unknown*

80005da0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005da0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005da2:	49 18       	lddpc	r8,80005de4 <INTC_init_interrupts+0x44>
80005da4:	e3 b8 00 01 	mtsr	0x4,r8
80005da8:	49 0e       	lddpc	lr,80005de8 <INTC_init_interrupts+0x48>
80005daa:	30 07       	mov	r7,0
80005dac:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005dae:	49 0c       	lddpc	r12,80005dec <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005db0:	49 05       	lddpc	r5,80005df0 <INTC_init_interrupts+0x50>
80005db2:	10 15       	sub	r5,r8
80005db4:	fe 76 08 00 	mov	r6,-63488
80005db8:	c1 08       	rjmp	80005dd8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005dba:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005dbc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dbe:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005dc0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005dc4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dc6:	10 3a       	cp.w	r10,r8
80005dc8:	fe 9b ff fc 	brhi	80005dc0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005dcc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005dd0:	2f f7       	sub	r7,-1
80005dd2:	2f 8e       	sub	lr,-8
80005dd4:	59 37       	cp.w	r7,19
80005dd6:	c0 50       	breq	80005de0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dd8:	7c 08       	ld.w	r8,lr[0x0]
80005dda:	58 08       	cp.w	r8,0
80005ddc:	ce f1       	brne	80005dba <INTC_init_interrupts+0x1a>
80005dde:	cf 7b       	rjmp	80005dcc <INTC_init_interrupts+0x2c>
80005de0:	d8 22       	popm	r4-r7,pc
80005de2:	00 00       	add	r0,r0
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	d6 00       	acall	0x60
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	e2 20 80 00 	sub	r0,163840
80005dee:	5d 1c       	icall	r12
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	d7 04       	*unknown*

80005df4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005df4:	fe 78 08 00 	mov	r8,-63488
80005df8:	e0 69 00 83 	mov	r9,131
80005dfc:	f2 0c 01 0c 	sub	r12,r9,r12
80005e00:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005e04:	f2 ca ff c0 	sub	r10,r9,-64
80005e08:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005e0c:	58 08       	cp.w	r8,0
80005e0e:	c0 21       	brne	80005e12 <_get_interrupt_handler+0x1e>
80005e10:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005e12:	f0 08 12 00 	clz	r8,r8
80005e16:	48 5a       	lddpc	r10,80005e28 <_get_interrupt_handler+0x34>
80005e18:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005e1c:	f0 08 11 1f 	rsub	r8,r8,31
80005e20:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005e22:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005e26:	5e fc       	retal	r12
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	e2 20 78 c8 	sub	r0,161992

80005e2c <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e2c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005e2e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005e32:	99 c8       	st.w	r12[0x30],r8
}
80005e34:	5e fc       	retal	r12
80005e36:	d7 03       	nop

80005e38 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005e38:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80005e3a:	30 1b       	mov	r11,1
80005e3c:	f0 1f 00 02 	mcall	80005e44 <pm_enable_osc32_crystal+0xc>
}
80005e40:	d8 02       	popm	pc
80005e42:	00 00       	add	r0,r0
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	5e 2c       	reths	r12

80005e48 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e48:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80005e4a:	30 19       	mov	r9,1
80005e4c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005e50:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005e54:	99 c8       	st.w	r12[0x30],r8
}
80005e56:	5e fc       	retal	r12

80005e58 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005e58:	79 58       	ld.w	r8,r12[0x54]
80005e5a:	e2 18 02 00 	andl	r8,0x200,COH
80005e5e:	cf d0       	breq	80005e58 <pm_wait_for_clk32_ready>
}
80005e60:	5e fc       	retal	r12
80005e62:	d7 03       	nop

80005e64 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005e64:	eb cd 40 80 	pushm	r7,lr
80005e68:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005e6a:	f0 1f 00 04 	mcall	80005e78 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005e6e:	0e 9c       	mov	r12,r7
80005e70:	f0 1f 00 03 	mcall	80005e7c <pm_enable_clk32+0x18>
}
80005e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	5e 48       	retge	r8
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	5e 58       	retlt	r8

80005e80 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005e80:	78 0c       	ld.w	r12,r12[0x0]
}
80005e82:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005e86:	5e fc       	retal	r12

80005e88 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005e88:	eb cd 40 c0 	pushm	r6-r7,lr
80005e8c:	18 97       	mov	r7,r12
80005e8e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005e90:	0e 9c       	mov	r12,r7
80005e92:	f0 1f 00 06 	mcall	80005ea8 <rtc_set_value+0x20>
80005e96:	cf d1       	brne	80005e90 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005e98:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005e9a:	0e 9c       	mov	r12,r7
80005e9c:	f0 1f 00 03 	mcall	80005ea8 <rtc_set_value+0x20>
80005ea0:	cf d1       	brne	80005e9a <rtc_set_value+0x12>
}
80005ea2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ea6:	00 00       	add	r0,r0
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	5e 80       	retls	r0

80005eac <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005eac:	eb cd 40 80 	pushm	r7,lr
80005eb0:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80005eb2:	0e 9c       	mov	r12,r7
80005eb4:	f0 1f 00 06 	mcall	80005ecc <rtc_enable+0x20>
80005eb8:	cf d1       	brne	80005eb2 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005eba:	6e 08       	ld.w	r8,r7[0x0]
80005ebc:	a1 a8       	sbr	r8,0x0
80005ebe:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005ec0:	0e 9c       	mov	r12,r7
80005ec2:	f0 1f 00 03 	mcall	80005ecc <rtc_enable+0x20>
80005ec6:	cf d1       	brne	80005ec0 <rtc_enable+0x14>
}
80005ec8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	5e 80       	retls	r0

80005ed0 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005ed0:	30 18       	mov	r8,1
80005ed2:	99 48       	st.w	r12[0x10],r8
}
80005ed4:	5e fc       	retal	r12
80005ed6:	d7 03       	nop

80005ed8 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005ed8:	eb cd 40 c0 	pushm	r6-r7,lr
80005edc:	18 97       	mov	r7,r12
80005ede:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005ee0:	0e 9c       	mov	r12,r7
80005ee2:	f0 1f 00 06 	mcall	80005ef8 <rtc_set_top_value+0x20>
80005ee6:	cf d1       	brne	80005ee0 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005ee8:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005eea:	0e 9c       	mov	r12,r7
80005eec:	f0 1f 00 03 	mcall	80005ef8 <rtc_set_top_value+0x20>
80005ef0:	cf d1       	brne	80005eea <rtc_set_top_value+0x12>
}
80005ef2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ef6:	00 00       	add	r0,r0
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	5e 80       	retls	r0

80005efc <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005efc:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005f00:	e6 18 00 01 	andh	r8,0x1,COH
80005f04:	c0 71       	brne	80005f12 <rtc_clear_interrupt+0x16>
80005f06:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005f08:	30 18       	mov	r8,1
80005f0a:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005f0c:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80005f0e:	d5 03       	csrf	0x10
80005f10:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005f12:	30 18       	mov	r8,1
80005f14:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005f16:	78 78       	ld.w	r8,r12[0x1c]
80005f18:	5e fc       	retal	r12
80005f1a:	d7 03       	nop

80005f1c <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005f1c:	eb cd 40 e0 	pushm	r5-r7,lr
80005f20:	18 97       	mov	r7,r12
80005f22:	16 96       	mov	r6,r11
80005f24:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80005f26:	30 18       	mov	r8,1
80005f28:	f0 0b 18 00 	cp.b	r11,r8
80005f2c:	5f b9       	srhi	r9
80005f2e:	30 f8       	mov	r8,15
80005f30:	f0 0a 18 00 	cp.b	r10,r8
80005f34:	5f b8       	srhi	r8
80005f36:	f3 e8 10 08 	or	r8,r9,r8
80005f3a:	c0 30       	breq	80005f40 <rtc_init+0x24>
80005f3c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80005f40:	30 18       	mov	r8,1
80005f42:	f0 0b 18 00 	cp.b	r11,r8
80005f46:	c0 a1       	brne	80005f5a <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80005f48:	fe 7c 0c 00 	mov	r12,-62464
80005f4c:	f0 1f 00 0f 	mcall	80005f88 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80005f50:	30 0b       	mov	r11,0
80005f52:	fe 7c 0c 00 	mov	r12,-62464
80005f56:	f0 1f 00 0e 	mcall	80005f8c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80005f5a:	0e 9c       	mov	r12,r7
80005f5c:	f0 1f 00 0d 	mcall	80005f90 <rtc_init+0x74>
80005f60:	cf d1       	brne	80005f5a <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80005f62:	a3 76       	lsl	r6,0x3
80005f64:	b1 a6       	sbr	r6,0x10
80005f66:	ed e5 10 85 	or	r5,r6,r5<<0x8
80005f6a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80005f6c:	0e 9c       	mov	r12,r7
80005f6e:	f0 1f 00 09 	mcall	80005f90 <rtc_init+0x74>
80005f72:	cf d1       	brne	80005f6c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80005f74:	30 0b       	mov	r11,0
80005f76:	0e 9c       	mov	r12,r7
80005f78:	f0 1f 00 07 	mcall	80005f94 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80005f7c:	3f fb       	mov	r11,-1
80005f7e:	0e 9c       	mov	r12,r7
80005f80:	f0 1f 00 06 	mcall	80005f98 <rtc_init+0x7c>
80005f84:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	5e 38       	retlo	r8
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	5e 64       	retmi	r4
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	5e 80       	retls	r0
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	5e 88       	retls	r8
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	5e d8       	retvc	r8

80005f9c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005f9c:	f8 c8 00 01 	sub	r8,r12,1
80005fa0:	f0 0b 00 0b 	add	r11,r8,r11
80005fa4:	f6 0c 0d 0a 	divu	r10,r11,r12
80005fa8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005faa:	f4 c8 00 01 	sub	r8,r10,1
80005fae:	e0 48 00 fe 	cp.w	r8,254
80005fb2:	e0 88 00 03 	brls	80005fb8 <getBaudDiv+0x1c>
80005fb6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005fb8:	5c 8c       	casts.h	r12
}
80005fba:	5e fc       	retal	r12

80005fbc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005fbc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005fc0:	30 18       	mov	r8,1
80005fc2:	f0 09 18 00 	cp.b	r9,r8
80005fc6:	e0 88 00 04 	brls	80005fce <spi_initMaster+0x12>
80005fca:	30 2c       	mov	r12,2
80005fcc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005fce:	e0 68 00 80 	mov	r8,128
80005fd2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005fd4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005fd6:	30 19       	mov	r9,1
80005fd8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005fdc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005fe0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005fe4:	30 09       	mov	r9,0
80005fe6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005fea:	30 fa       	mov	r10,15
80005fec:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005ff0:	99 18       	st.w	r12[0x4],r8
80005ff2:	5e f9       	retal	r9

80005ff4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005ff4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005ff6:	30 18       	mov	r8,1
80005ff8:	f0 0b 18 00 	cp.b	r11,r8
80005ffc:	5f be       	srhi	lr
80005ffe:	f0 0a 18 00 	cp.b	r10,r8
80006002:	5f b8       	srhi	r8
80006004:	fd e8 10 08 	or	r8,lr,r8
80006008:	c0 30       	breq	8000600e <spi_selectionMode+0x1a>
8000600a:	30 2c       	mov	r12,2
8000600c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000600e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006010:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006014:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006018:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000601c:	99 18       	st.w	r12[0x4],r8
8000601e:	d8 0a       	popm	pc,r12=0

80006020 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006020:	30 18       	mov	r8,1
80006022:	99 08       	st.w	r12[0x0],r8
}
80006024:	5e fc       	retal	r12

80006026 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006026:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000602a:	c0 58       	rjmp	80006034 <spi_write+0xe>
		if (!timeout--) {
8000602c:	58 08       	cp.w	r8,0
8000602e:	c0 21       	brne	80006032 <spi_write+0xc>
80006030:	5e ff       	retal	1
80006032:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006034:	78 49       	ld.w	r9,r12[0x10]
80006036:	e2 19 00 02 	andl	r9,0x2,COH
8000603a:	cf 90       	breq	8000602c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000603c:	5c 7b       	castu.h	r11
8000603e:	99 3b       	st.w	r12[0xc],r11
80006040:	5e fd       	retal	0

80006042 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80006042:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006046:	c0 58       	rjmp	80006050 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80006048:	58 08       	cp.w	r8,0
8000604a:	c0 21       	brne	8000604e <spi_read+0xc>
8000604c:	5e ff       	retal	1
8000604e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006050:	78 49       	ld.w	r9,r12[0x10]
80006052:	e2 19 02 01 	andl	r9,0x201,COH
80006056:	e0 49 02 01 	cp.w	r9,513
8000605a:	cf 71       	brne	80006048 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000605c:	78 28       	ld.w	r8,r12[0x8]
8000605e:	b6 08       	st.h	r11[0x0],r8
80006060:	5e fd       	retal	0
80006062:	d7 03       	nop

80006064 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006064:	eb cd 40 f8 	pushm	r3-r7,lr
80006068:	18 95       	mov	r5,r12
8000606a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000606c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006070:	30 38       	mov	r8,3
80006072:	f0 06 18 00 	cp.b	r6,r8
80006076:	e0 8b 00 5e 	brhi	80006132 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000607a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000607e:	30 18       	mov	r8,1
80006080:	f0 04 18 00 	cp.b	r4,r8
80006084:	e0 8b 00 57 	brhi	80006132 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006088:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000608c:	30 78       	mov	r8,7
8000608e:	f0 03 18 00 	cp.b	r3,r8
80006092:	e0 88 00 50 	brls	80006132 <spi_setupChipReg+0xce>
80006096:	31 08       	mov	r8,16
80006098:	f0 03 18 00 	cp.b	r3,r8
8000609c:	e0 8b 00 4b 	brhi	80006132 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800060a0:	14 9b       	mov	r11,r10
800060a2:	6e 1c       	ld.w	r12,r7[0x4]
800060a4:	f0 1f 00 26 	mcall	8000613c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800060a8:	c4 55       	brlt	80006132 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800060aa:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800060ac:	ec 09 16 01 	lsr	r9,r6,0x1
800060b0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800060b4:	ec 16 00 01 	eorl	r6,0x1
800060b8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800060bc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800060c0:	20 83       	sub	r3,8
800060c2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800060c6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800060ca:	ef 39 00 09 	ld.ub	r9,r7[9]
800060ce:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800060d2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800060d6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800060da:	0f 89       	ld.ub	r9,r7[0x0]
800060dc:	30 1a       	mov	r10,1
800060de:	f4 09 18 00 	cp.b	r9,r10
800060e2:	c0 d0       	breq	800060fc <spi_setupChipReg+0x98>
800060e4:	c0 a3       	brcs	800060f8 <spi_setupChipReg+0x94>
800060e6:	30 2a       	mov	r10,2
800060e8:	f4 09 18 00 	cp.b	r9,r10
800060ec:	c0 a0       	breq	80006100 <spi_setupChipReg+0x9c>
800060ee:	30 3a       	mov	r10,3
800060f0:	f4 09 18 00 	cp.b	r9,r10
800060f4:	c1 f1       	brne	80006132 <spi_setupChipReg+0xce>
800060f6:	c0 78       	rjmp	80006104 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800060f8:	8b c8       	st.w	r5[0x30],r8
		break;
800060fa:	c0 68       	rjmp	80006106 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800060fc:	8b d8       	st.w	r5[0x34],r8
		break;
800060fe:	c0 48       	rjmp	80006106 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80006100:	8b e8       	st.w	r5[0x38],r8
		break;
80006102:	c0 28       	rjmp	80006106 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006104:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006106:	48 f8       	lddpc	r8,80006140 <spi_setupChipReg+0xdc>
80006108:	70 08       	ld.w	r8,r8[0x0]
8000610a:	58 08       	cp.w	r8,0
8000610c:	c1 61       	brne	80006138 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000610e:	30 0b       	mov	r11,0
80006110:	30 1c       	mov	r12,1
80006112:	f0 1f 00 0d 	mcall	80006144 <spi_setupChipReg+0xe0>
80006116:	48 b8       	lddpc	r8,80006140 <spi_setupChipReg+0xdc>
80006118:	91 0c       	st.w	r8[0x0],r12
8000611a:	58 0c       	cp.w	r12,0
8000611c:	c0 a0       	breq	80006130 <spi_setupChipReg+0xcc>
8000611e:	30 09       	mov	r9,0
80006120:	12 9a       	mov	r10,r9
80006122:	12 9b       	mov	r11,r9
80006124:	f0 1f 00 09 	mcall	80006148 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006128:	48 68       	lddpc	r8,80006140 <spi_setupChipReg+0xdc>
8000612a:	70 08       	ld.w	r8,r8[0x0]
8000612c:	58 08       	cp.w	r8,0
8000612e:	c0 51       	brne	80006138 <spi_setupChipReg+0xd4>
80006130:	c0 08       	rjmp	80006130 <spi_setupChipReg+0xcc>
80006132:	30 2c       	mov	r12,2
80006134:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006138:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	5f 9c       	srgt	r12
80006140:	00 00       	add	r0,r0
80006142:	54 18       	stdsp	sp[0x104],r8
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	6c 88       	ld.w	r8,r6[0x20]
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	6b 30       	ld.w	r0,r5[0x4c]

8000614c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000614c:	d4 01       	pushm	lr
8000614e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006152:	c0 58       	rjmp	8000615c <spi_unselectChip+0x10>
		if (!timeout--) {
80006154:	58 08       	cp.w	r8,0
80006156:	c0 21       	brne	8000615a <spi_unselectChip+0xe>
80006158:	da 0a       	popm	pc,r12=1
8000615a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000615c:	78 49       	ld.w	r9,r12[0x10]
8000615e:	e2 19 02 00 	andl	r9,0x200,COH
80006162:	cf 90       	breq	80006154 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006164:	78 18       	ld.w	r8,r12[0x4]
80006166:	ea 18 00 0f 	orh	r8,0xf
8000616a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000616c:	fc 18 01 00 	movh	r8,0x100
80006170:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80006172:	30 09       	mov	r9,0
80006174:	12 9a       	mov	r10,r9
80006176:	12 9b       	mov	r11,r9
80006178:	48 38       	lddpc	r8,80006184 <spi_unselectChip+0x38>
8000617a:	70 0c       	ld.w	r12,r8[0x0]
8000617c:	f0 1f 00 03 	mcall	80006188 <spi_unselectChip+0x3c>
80006180:	d8 0a       	popm	pc,r12=0
80006182:	00 00       	add	r0,r0
80006184:	00 00       	add	r0,r0
80006186:	54 18       	stdsp	sp[0x104],r8
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	6b 30       	ld.w	r0,r5[0x4c]

8000618c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000618c:	eb cd 40 f8 	pushm	r3-r7,lr
80006190:	18 94       	mov	r4,r12
80006192:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006194:	49 a6       	lddpc	r6,800061fc <spi_selectChip+0x70>
80006196:	30 07       	mov	r7,0
80006198:	31 45       	mov	r5,20
8000619a:	0e 99       	mov	r9,r7
8000619c:	0a 9a       	mov	r10,r5
8000619e:	0e 9b       	mov	r11,r7
800061a0:	6c 0c       	ld.w	r12,r6[0x0]
800061a2:	f0 1f 00 18 	mcall	80006200 <spi_selectChip+0x74>
800061a6:	cf a0       	breq	8000619a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800061a8:	68 18       	ld.w	r8,r4[0x4]
800061aa:	ea 18 00 0f 	orh	r8,0xf
800061ae:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800061b0:	68 18       	ld.w	r8,r4[0x4]
800061b2:	e2 18 00 04 	andl	r8,0x4,COH
800061b6:	c1 10       	breq	800061d8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800061b8:	30 e8       	mov	r8,14
800061ba:	f0 03 18 00 	cp.b	r3,r8
800061be:	e0 8b 00 1c 	brhi	800061f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800061c2:	68 19       	ld.w	r9,r4[0x4]
800061c4:	e6 08 15 10 	lsl	r8,r3,0x10
800061c8:	ea 18 ff f0 	orh	r8,0xfff0
800061cc:	e8 18 ff ff 	orl	r8,0xffff
800061d0:	12 68       	and	r8,r9
800061d2:	89 18       	st.w	r4[0x4],r8
800061d4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800061d8:	30 38       	mov	r8,3
800061da:	f0 03 18 00 	cp.b	r3,r8
800061de:	e0 8b 00 0c 	brhi	800061f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800061e2:	68 19       	ld.w	r9,r4[0x4]
800061e4:	2f 03       	sub	r3,-16
800061e6:	30 18       	mov	r8,1
800061e8:	f0 03 09 48 	lsl	r8,r8,r3
800061ec:	5c d8       	com	r8
800061ee:	12 68       	and	r8,r9
800061f0:	89 18       	st.w	r4[0x4],r8
800061f2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800061f6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800061f8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800061fc:	00 00       	add	r0,r0
800061fe:	54 18       	stdsp	sp[0x104],r8
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	69 24       	ld.w	r4,r4[0x48]

80006204 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006204:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006206:	f6 08 15 04 	lsl	r8,r11,0x4
8000620a:	14 38       	cp.w	r8,r10
8000620c:	f9 b8 08 10 	movls	r8,16
80006210:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006214:	f0 0b 02 4b 	mul	r11,r8,r11
80006218:	f6 09 16 01 	lsr	r9,r11,0x1
8000621c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006220:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006224:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006228:	f2 cb 00 01 	sub	r11,r9,1
8000622c:	e0 4b ff fe 	cp.w	r11,65534
80006230:	e0 88 00 03 	brls	80006236 <usart_set_async_baudrate+0x32>
80006234:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006236:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006238:	e8 6e 00 00 	mov	lr,524288
8000623c:	59 08       	cp.w	r8,16
8000623e:	fc 08 17 10 	movne	r8,lr
80006242:	f9 b8 00 00 	moveq	r8,0
80006246:	e4 1b ff f7 	andh	r11,0xfff7
8000624a:	e0 1b fe cf 	andl	r11,0xfecf
8000624e:	16 48       	or	r8,r11
80006250:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006252:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006256:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000625a:	99 89       	st.w	r12[0x20],r9
8000625c:	d8 0a       	popm	pc,r12=0

8000625e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000625e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006260:	e2 18 00 02 	andl	r8,0x2,COH
80006264:	c0 31       	brne	8000626a <usart_write_char+0xc>
80006266:	30 2c       	mov	r12,2
80006268:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000626a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000626e:	99 7b       	st.w	r12[0x1c],r11
80006270:	5e fd       	retal	0
80006272:	d7 03       	nop

80006274 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006274:	eb cd 40 e0 	pushm	r5-r7,lr
80006278:	18 96       	mov	r6,r12
8000627a:	16 95       	mov	r5,r11
8000627c:	e0 67 27 0f 	mov	r7,9999
80006280:	c0 68       	rjmp	8000628c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006282:	58 07       	cp.w	r7,0
80006284:	c0 31       	brne	8000628a <usart_putchar+0x16>
80006286:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000628a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000628c:	0a 9b       	mov	r11,r5
8000628e:	0c 9c       	mov	r12,r6
80006290:	f0 1f 00 03 	mcall	8000629c <usart_putchar+0x28>
80006294:	cf 71       	brne	80006282 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006296:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000629a:	00 00       	add	r0,r0
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	62 5e       	ld.w	lr,r1[0x14]

800062a0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800062a0:	78 58       	ld.w	r8,r12[0x14]
800062a2:	e2 18 00 e0 	andl	r8,0xe0,COH
800062a6:	c0 30       	breq	800062ac <usart_read_char+0xc>
800062a8:	30 4c       	mov	r12,4
800062aa:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800062ac:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800062ae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800062b2:	c0 31       	brne	800062b8 <usart_read_char+0x18>
800062b4:	30 3c       	mov	r12,3
800062b6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800062b8:	78 68       	ld.w	r8,r12[0x18]
800062ba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800062be:	97 08       	st.w	r11[0x0],r8
800062c0:	5e fd       	retal	0
800062c2:	d7 03       	nop

800062c4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800062c4:	eb cd 40 c0 	pushm	r6-r7,lr
800062c8:	20 1d       	sub	sp,4
800062ca:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800062cc:	1a 97       	mov	r7,sp
800062ce:	1a 9b       	mov	r11,sp
800062d0:	0c 9c       	mov	r12,r6
800062d2:	f0 1f 00 07 	mcall	800062ec <usart_getchar+0x28>
800062d6:	58 3c       	cp.w	r12,3
800062d8:	cf b0       	breq	800062ce <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800062da:	58 4c       	cp.w	r12,4
800062dc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800062e0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800062e4:	2f fd       	sub	sp,-4
800062e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062ea:	00 00       	add	r0,r0
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	62 a0       	ld.w	r0,r1[0x28]

800062f0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800062f0:	eb cd 40 c0 	pushm	r6-r7,lr
800062f4:	18 96       	mov	r6,r12
800062f6:	16 97       	mov	r7,r11
  while (*string != '\0')
800062f8:	17 8b       	ld.ub	r11,r11[0x0]
800062fa:	58 0b       	cp.w	r11,0
800062fc:	c0 80       	breq	8000630c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800062fe:	2f f7       	sub	r7,-1
80006300:	0c 9c       	mov	r12,r6
80006302:	f0 1f 00 04 	mcall	80006310 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006306:	0f 8b       	ld.ub	r11,r7[0x0]
80006308:	58 0b       	cp.w	r11,0
8000630a:	cf a1       	brne	800062fe <usart_write_line+0xe>
8000630c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	62 74       	ld.w	r4,r1[0x1c]

80006314 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006314:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006318:	e6 18 00 01 	andh	r8,0x1,COH
8000631c:	c0 71       	brne	8000632a <usart_reset+0x16>
8000631e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006320:	3f f8       	mov	r8,-1
80006322:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006324:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006326:	d5 03       	csrf	0x10
80006328:	c0 48       	rjmp	80006330 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000632a:	3f f8       	mov	r8,-1
8000632c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000632e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006330:	30 08       	mov	r8,0
80006332:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006334:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006336:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006338:	ea 68 61 0c 	mov	r8,680204
8000633c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000633e:	5e fc       	retal	r12

80006340 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006340:	eb cd 40 e0 	pushm	r5-r7,lr
80006344:	18 96       	mov	r6,r12
80006346:	16 97       	mov	r7,r11
80006348:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000634a:	f0 1f 00 2f 	mcall	80006404 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000634e:	58 07       	cp.w	r7,0
80006350:	c5 80       	breq	80006400 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006352:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006354:	30 49       	mov	r9,4
80006356:	f2 08 18 00 	cp.b	r8,r9
8000635a:	e0 88 00 53 	brls	80006400 <usart_init_rs232+0xc0>
8000635e:	30 99       	mov	r9,9
80006360:	f2 08 18 00 	cp.b	r8,r9
80006364:	e0 8b 00 4e 	brhi	80006400 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006368:	0f d9       	ld.ub	r9,r7[0x5]
8000636a:	30 78       	mov	r8,7
8000636c:	f0 09 18 00 	cp.b	r9,r8
80006370:	e0 8b 00 48 	brhi	80006400 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006374:	8e 39       	ld.sh	r9,r7[0x6]
80006376:	e0 68 01 01 	mov	r8,257
8000637a:	f0 09 19 00 	cp.h	r9,r8
8000637e:	e0 8b 00 41 	brhi	80006400 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006382:	ef 39 00 08 	ld.ub	r9,r7[8]
80006386:	30 38       	mov	r8,3
80006388:	f0 09 18 00 	cp.b	r9,r8
8000638c:	e0 8b 00 3a 	brhi	80006400 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006390:	0a 9a       	mov	r10,r5
80006392:	6e 0b       	ld.w	r11,r7[0x0]
80006394:	0c 9c       	mov	r12,r6
80006396:	f0 1f 00 1d 	mcall	80006408 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000639a:	58 1c       	cp.w	r12,1
8000639c:	c3 20       	breq	80006400 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000639e:	0f c8       	ld.ub	r8,r7[0x4]
800063a0:	30 99       	mov	r9,9
800063a2:	f2 08 18 00 	cp.b	r8,r9
800063a6:	c0 51       	brne	800063b0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800063a8:	6c 18       	ld.w	r8,r6[0x4]
800063aa:	b1 b8       	sbr	r8,0x11
800063ac:	8d 18       	st.w	r6[0x4],r8
800063ae:	c0 68       	rjmp	800063ba <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800063b0:	6c 19       	ld.w	r9,r6[0x4]
800063b2:	20 58       	sub	r8,5
800063b4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800063b8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800063ba:	6c 19       	ld.w	r9,r6[0x4]
800063bc:	ef 3a 00 08 	ld.ub	r10,r7[8]
800063c0:	0f d8       	ld.ub	r8,r7[0x5]
800063c2:	a9 78       	lsl	r8,0x9
800063c4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800063c8:	12 48       	or	r8,r9
800063ca:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800063cc:	8e 38       	ld.sh	r8,r7[0x6]
800063ce:	30 29       	mov	r9,2
800063d0:	f2 08 19 00 	cp.h	r8,r9
800063d4:	e0 88 00 09 	brls	800063e6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800063d8:	6c 18       	ld.w	r8,r6[0x4]
800063da:	ad b8       	sbr	r8,0xd
800063dc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800063de:	8e b8       	ld.uh	r8,r7[0x6]
800063e0:	20 28       	sub	r8,2
800063e2:	8d a8       	st.w	r6[0x28],r8
800063e4:	c0 68       	rjmp	800063f0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800063e6:	6c 19       	ld.w	r9,r6[0x4]
800063e8:	5c 78       	castu.h	r8
800063ea:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800063ee:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800063f0:	6c 18       	ld.w	r8,r6[0x4]
800063f2:	e0 18 ff f0 	andl	r8,0xfff0
800063f6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800063f8:	35 08       	mov	r8,80
800063fa:	8d 08       	st.w	r6[0x0],r8
800063fc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006400:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	63 14       	ld.w	r4,r1[0x44]
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	62 04       	ld.w	r4,r1[0x0]

8000640c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000640c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006410:	fe c0 8e 10 	sub	r0,pc,-29168

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006414:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006418:	d5 53       	csrf	0x15
  cp      r0, r1
8000641a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
8000641c:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006420:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006422:	c0 62       	brcc	8000642e <idata_load_loop_end>
  cp      r0, r1
80006424:	48 92       	lddpc	r2,80006448 <udata_clear_loop_end+0x4>

80006426 <idata_load_loop>:
  brlo    idata_load_loop
80006426:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006428:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000642a:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000642c:	cf d3       	brcs	80006426 <idata_load_loop>

8000642e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000642e:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
80006432:	e0 61 54 28 	mov	r1,21544
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006436:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006438:	c0 62       	brcc	80006444 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000643a:	30 02       	mov	r2,0
8000643c:	30 03       	mov	r3,0

8000643e <udata_clear_loop>:
8000643e:	a1 22       	st.d	r0++,r2
80006440:	02 30       	cp.w	r0,r1
80006442:	cf e3       	brcs	8000643e <udata_clear_loop>

80006444 <udata_clear_loop_end>:
80006444:	fe cf e9 24 	sub	pc,pc,-5852
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	eb 50 f8 c8 	st.h	r5[-1848],r0

8000644c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
8000644c:	f8 c8 ff f8 	sub	r8,r12,-8
80006450:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006452:	3f f9       	mov	r9,-1
80006454:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006456:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006458:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000645a:	30 08       	mov	r8,0
8000645c:	99 08       	st.w	r12[0x0],r8
}
8000645e:	5e fc       	retal	r12

80006460 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006460:	30 08       	mov	r8,0
80006462:	99 48       	st.w	r12[0x10],r8
}
80006464:	5e fc       	retal	r12

80006466 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006466:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006468:	70 19       	ld.w	r9,r8[0x4]
8000646a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000646c:	78 19       	ld.w	r9,r12[0x4]
8000646e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006470:	70 19       	ld.w	r9,r8[0x4]
80006472:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006474:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006476:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006478:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000647a:	78 08       	ld.w	r8,r12[0x0]
8000647c:	2f f8       	sub	r8,-1
8000647e:	99 08       	st.w	r12[0x0],r8
}
80006480:	5e fc       	retal	r12

80006482 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006482:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006484:	5b fa       	cp.w	r10,-1
80006486:	c0 31       	brne	8000648c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006488:	78 48       	ld.w	r8,r12[0x10]
8000648a:	c0 c8       	rjmp	800064a2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000648c:	f8 c8 ff f8 	sub	r8,r12,-8
80006490:	70 19       	ld.w	r9,r8[0x4]
80006492:	72 09       	ld.w	r9,r9[0x0]
80006494:	12 3a       	cp.w	r10,r9
80006496:	c0 63       	brcs	800064a2 <vListInsert+0x20>
80006498:	70 18       	ld.w	r8,r8[0x4]
8000649a:	70 19       	ld.w	r9,r8[0x4]
8000649c:	72 09       	ld.w	r9,r9[0x0]
8000649e:	12 3a       	cp.w	r10,r9
800064a0:	cf c2       	brcc	80006498 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800064a2:	70 19       	ld.w	r9,r8[0x4]
800064a4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800064a6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800064a8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800064aa:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800064ac:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800064ae:	78 08       	ld.w	r8,r12[0x0]
800064b0:	2f f8       	sub	r8,-1
800064b2:	99 08       	st.w	r12[0x0],r8
}
800064b4:	5e fc       	retal	r12

800064b6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800064b6:	78 18       	ld.w	r8,r12[0x4]
800064b8:	78 29       	ld.w	r9,r12[0x8]
800064ba:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800064bc:	78 28       	ld.w	r8,r12[0x8]
800064be:	78 19       	ld.w	r9,r12[0x4]
800064c0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800064c2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800064c4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800064c6:	18 39       	cp.w	r9,r12
800064c8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800064cc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800064d0:	30 09       	mov	r9,0
800064d2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800064d4:	70 09       	ld.w	r9,r8[0x0]
800064d6:	20 19       	sub	r9,1
800064d8:	91 09       	st.w	r8[0x0],r9
}
800064da:	5e fc       	retal	r12

800064dc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800064dc:	e0 68 08 08 	mov	r8,2056
800064e0:	ea 18 08 08 	orh	r8,0x808
800064e4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800064e6:	e0 68 09 09 	mov	r8,2313
800064ea:	ea 18 09 09 	orh	r8,0x909
800064ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800064f0:	e0 68 0a 0a 	mov	r8,2570
800064f4:	ea 18 0a 0a 	orh	r8,0xa0a
800064f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800064fa:	e0 68 0b 0b 	mov	r8,2827
800064fe:	ea 18 0b 0b 	orh	r8,0xb0b
80006502:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006504:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006506:	e0 68 be ef 	mov	r8,48879
8000650a:	ea 18 de ad 	orh	r8,0xdead
8000650e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006510:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006512:	fc 18 00 40 	movh	r8,0x40
80006516:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006518:	e0 68 00 ff 	mov	r8,255
8000651c:	ea 18 ff 00 	orh	r8,0xff00
80006520:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006522:	e0 68 01 01 	mov	r8,257
80006526:	ea 18 01 01 	orh	r8,0x101
8000652a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000652c:	e0 68 02 02 	mov	r8,514
80006530:	ea 18 02 02 	orh	r8,0x202
80006534:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006536:	e0 68 03 03 	mov	r8,771
8000653a:	ea 18 03 03 	orh	r8,0x303
8000653e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006540:	e0 68 04 04 	mov	r8,1028
80006544:	ea 18 04 04 	orh	r8,0x404
80006548:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000654a:	e0 68 05 05 	mov	r8,1285
8000654e:	ea 18 05 05 	orh	r8,0x505
80006552:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006554:	e0 68 06 06 	mov	r8,1542
80006558:	ea 18 06 06 	orh	r8,0x606
8000655c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000655e:	e0 68 07 07 	mov	r8,1799
80006562:	ea 18 07 07 	orh	r8,0x707
80006566:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006568:	30 08       	mov	r8,0
8000656a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000656c:	5e fc       	retal	r12
8000656e:	d7 03       	nop

80006570 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006570:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006572:	48 38       	lddpc	r8,8000657c <vPortEnterCritical+0xc>
80006574:	70 09       	ld.w	r9,r8[0x0]
80006576:	2f f9       	sub	r9,-1
80006578:	91 09       	st.w	r8[0x0],r9
}
8000657a:	5e fc       	retal	r12
8000657c:	00 00       	add	r0,r0
8000657e:	05 44       	ld.w	r4,--r2

80006580 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006580:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006582:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006584:	30 0a       	mov	r10,0
80006586:	14 9b       	mov	r11,r10
80006588:	49 2c       	lddpc	r12,800065d0 <xPortStartScheduler+0x50>
8000658a:	f0 1f 00 13 	mcall	800065d4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000658e:	e0 68 5d c0 	mov	r8,24000
80006592:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006596:	30 08       	mov	r8,0
80006598:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000659c:	e0 68 0d 54 	mov	r8,3412
800065a0:	ea 18 00 00 	orh	r8,0x0
800065a4:	70 00       	ld.w	r0,r8[0x0]
800065a6:	60 0d       	ld.w	sp,r0[0x0]
800065a8:	1b 00       	ld.w	r0,sp++
800065aa:	e0 68 05 44 	mov	r8,1348
800065ae:	ea 18 00 00 	orh	r8,0x0
800065b2:	91 00       	st.w	r8[0x0],r0
800065b4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800065b8:	2f ed       	sub	sp,-8
800065ba:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800065be:	fa f0 ff e0 	ld.w	r0,sp[-32]
800065c2:	e3 b0 00 00 	mtsr	0x0,r0
800065c6:	fa f0 ff dc 	ld.w	r0,sp[-36]
800065ca:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800065ce:	d8 0a       	popm	pc,r12=0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	66 9c       	ld.w	r12,r3[0x24]
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5d 20       	mustr	r0

800065d8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800065d8:	20 6d       	sub	sp,24
800065da:	eb cd 00 ff 	pushm	r0-r7
800065de:	fa c7 ff c0 	sub	r7,sp,-64
800065e2:	ee f0 ff f8 	ld.w	r0,r7[-8]
800065e6:	ef 40 ff e0 	st.w	r7[-32],r0
800065ea:	ee f0 ff fc 	ld.w	r0,r7[-4]
800065ee:	ef 40 ff e4 	st.w	r7[-28],r0
800065f2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800065f6:	e0 68 05 44 	mov	r8,1348
800065fa:	ea 18 00 00 	orh	r8,0x0
800065fe:	70 00       	ld.w	r0,r8[0x0]
80006600:	1a d0       	st.w	--sp,r0
80006602:	f0 1f 00 1a 	mcall	80006668 <LABEL_RET_SCALL_263+0x14>
80006606:	e0 68 0d 54 	mov	r8,3412
8000660a:	ea 18 00 00 	orh	r8,0x0
8000660e:	70 00       	ld.w	r0,r8[0x0]
80006610:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006612:	f0 1f 00 17 	mcall	8000666c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006616:	e0 68 0d 54 	mov	r8,3412
8000661a:	ea 18 00 00 	orh	r8,0x0
8000661e:	70 00       	ld.w	r0,r8[0x0]
80006620:	60 0d       	ld.w	sp,r0[0x0]
80006622:	1b 00       	ld.w	r0,sp++
80006624:	e0 68 05 44 	mov	r8,1348
80006628:	ea 18 00 00 	orh	r8,0x0
8000662c:	91 00       	st.w	r8[0x0],r0
8000662e:	fa c7 ff d8 	sub	r7,sp,-40
80006632:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006636:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000663a:	e0 61 05 44 	mov	r1,1348
8000663e:	ea 11 00 00 	orh	r1,0x0
80006642:	62 02       	ld.w	r2,r1[0x0]
80006644:	58 02       	cp.w	r2,0
80006646:	c0 70       	breq	80006654 <LABEL_RET_SCALL_263>
80006648:	e4 c2 00 01 	sub	r2,r2,1
8000664c:	83 02       	st.w	r1[0x0],r2
8000664e:	58 02       	cp.w	r2,0
80006650:	c0 21       	brne	80006654 <LABEL_RET_SCALL_263>
80006652:	b1 c0       	cbr	r0,0x10

80006654 <LABEL_RET_SCALL_263>:
80006654:	ef 40 ff f8 	st.w	r7[-8],r0
80006658:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000665c:	ef 40 ff fc 	st.w	r7[-4],r0
80006660:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006664:	2f ad       	sub	sp,-24
80006666:	d6 13       	rets
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	65 70       	ld.w	r0,r2[0x5c]
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	6d 0c       	ld.w	r12,r6[0x40]

80006670 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006670:	e1 b8 00 43 	mfsr	r8,0x10c
80006674:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006678:	5e fc       	retal	r12
8000667a:	d7 03       	nop

8000667c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000667c:	48 78       	lddpc	r8,80006698 <vPortExitCritical+0x1c>
8000667e:	70 08       	ld.w	r8,r8[0x0]
80006680:	58 08       	cp.w	r8,0
80006682:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006684:	48 58       	lddpc	r8,80006698 <vPortExitCritical+0x1c>
80006686:	70 09       	ld.w	r9,r8[0x0]
80006688:	20 19       	sub	r9,1
8000668a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000668c:	70 08       	ld.w	r8,r8[0x0]
8000668e:	58 08       	cp.w	r8,0
80006690:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006692:	d5 03       	csrf	0x10
80006694:	5e fc       	retal	r12
80006696:	00 00       	add	r0,r0
80006698:	00 00       	add	r0,r0
8000669a:	05 44       	ld.w	r4,--r2

8000669c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000669c:	eb cd 00 ff 	pushm	r0-r7
800066a0:	e0 68 05 44 	mov	r8,1348
800066a4:	ea 18 00 00 	orh	r8,0x0
800066a8:	70 00       	ld.w	r0,r8[0x0]
800066aa:	1a d0       	st.w	--sp,r0
800066ac:	7a 90       	ld.w	r0,sp[0x24]
800066ae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800066b2:	58 10       	cp.w	r0,1
800066b4:	e0 8b 00 08 	brhi	800066c4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800066b8:	e0 68 0d 54 	mov	r8,3412
800066bc:	ea 18 00 00 	orh	r8,0x0
800066c0:	70 00       	ld.w	r0,r8[0x0]
800066c2:	81 0d       	st.w	r0[0x0],sp

800066c4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800066c4:	f0 1f 00 12 	mcall	8000670c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800066c8:	f0 1f 00 12 	mcall	80006710 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800066cc:	f0 1f 00 12 	mcall	80006714 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800066d0:	f0 1f 00 12 	mcall	80006718 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800066d4:	7a 90       	ld.w	r0,sp[0x24]
800066d6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800066da:	58 10       	cp.w	r0,1
800066dc:	e0 8b 00 0e 	brhi	800066f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800066e0:	f0 1f 00 0c 	mcall	80006710 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800066e4:	f0 1f 00 0e 	mcall	8000671c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800066e8:	f0 1f 00 0c 	mcall	80006718 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800066ec:	e0 68 0d 54 	mov	r8,3412
800066f0:	ea 18 00 00 	orh	r8,0x0
800066f4:	70 00       	ld.w	r0,r8[0x0]
800066f6:	60 0d       	ld.w	sp,r0[0x0]

800066f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800066f8:	1b 00       	ld.w	r0,sp++
800066fa:	e0 68 05 44 	mov	r8,1348
800066fe:	ea 18 00 00 	orh	r8,0x0
80006702:	91 00       	st.w	r8[0x0],r0
80006704:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006708:	d6 03       	rete
8000670a:	00 00       	add	r0,r0
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	66 70       	ld.w	r0,r3[0x1c]
80006710:	80 00       	ld.sh	r0,r0[0x0]
80006712:	65 70       	ld.w	r0,r2[0x5c]
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	6f 10       	ld.w	r0,r7[0x44]
80006718:	80 00       	ld.sh	r0,r0[0x0]
8000671a:	66 7c       	ld.w	r12,r3[0x1c]
8000671c:	80 00       	ld.sh	r0,r0[0x0]
8000671e:	6d 0c       	ld.w	r12,r6[0x40]

80006720 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006720:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006722:	f0 1f 00 02 	mcall	80006728 <__malloc_lock+0x8>
}
80006726:	d8 02       	popm	pc
80006728:	80 00       	ld.sh	r0,r0[0x0]
8000672a:	6c fc       	ld.w	r12,r6[0x3c]

8000672c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000672c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000672e:	f0 1f 00 02 	mcall	80006734 <__malloc_unlock+0x8>
}
80006732:	d8 02       	popm	pc
80006734:	80 00       	ld.sh	r0,r0[0x0]
80006736:	70 b8       	ld.w	r8,r8[0x2c]

80006738 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006738:	d4 21       	pushm	r4-r7,lr
8000673a:	16 95       	mov	r5,r11
8000673c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000673e:	58 0c       	cp.w	r12,0
80006740:	c0 30       	breq	80006746 <_read+0xe>
80006742:	3f f7       	mov	r7,-1
80006744:	c1 48       	rjmp	8000676c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006746:	58 0a       	cp.w	r10,0
80006748:	e0 89 00 04 	brgt	80006750 <_read+0x18>
8000674c:	30 07       	mov	r7,0
8000674e:	c0 f8       	rjmp	8000676c <_read+0x34>
80006750:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006752:	48 84       	lddpc	r4,80006770 <_read+0x38>
80006754:	68 0c       	ld.w	r12,r4[0x0]
80006756:	f0 1f 00 08 	mcall	80006774 <_read+0x3c>
    if (c < 0)
8000675a:	c0 95       	brlt	8000676c <_read+0x34>
      break;

    *ptr++ = c;
8000675c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006760:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006762:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006766:	58 08       	cp.w	r8,0
80006768:	fe 99 ff f6 	brgt	80006754 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000676c:	0e 9c       	mov	r12,r7
8000676e:	d8 22       	popm	r4-r7,pc
80006770:	00 00       	add	r0,r0
80006772:	54 1c       	stdsp	sp[0x104],r12
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	62 c4       	ld.w	r4,r1[0x30]

80006778 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006778:	d4 21       	pushm	r4-r7,lr
8000677a:	16 95       	mov	r5,r11
8000677c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000677e:	20 1c       	sub	r12,1
80006780:	58 2c       	cp.w	r12,2
80006782:	e0 8b 00 12 	brhi	800067a6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006786:	58 0a       	cp.w	r10,0
80006788:	c0 31       	brne	8000678e <_write+0x16>
8000678a:	30 07       	mov	r7,0
8000678c:	c0 e8       	rjmp	800067a8 <_write+0x30>
8000678e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006790:	48 74       	lddpc	r4,800067ac <_write+0x34>
80006792:	68 0c       	ld.w	r12,r4[0x0]
80006794:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006798:	f0 1f 00 06 	mcall	800067b0 <_write+0x38>
8000679c:	c0 55       	brlt	800067a6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000679e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800067a0:	0e 36       	cp.w	r6,r7
800067a2:	cf 81       	brne	80006792 <_write+0x1a>
800067a4:	c0 28       	rjmp	800067a8 <_write+0x30>
800067a6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800067a8:	0e 9c       	mov	r12,r7
800067aa:	d8 22       	popm	r4-r7,pc
800067ac:	00 00       	add	r0,r0
800067ae:	54 1c       	stdsp	sp[0x104],r12
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	62 74       	ld.w	r4,r1[0x1c]

800067b4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800067b4:	eb cd 40 80 	pushm	r7,lr
800067b8:	18 97       	mov	r7,r12
	if( pv )
800067ba:	58 0c       	cp.w	r12,0
800067bc:	c0 80       	breq	800067cc <vPortFree+0x18>
	{
		vTaskSuspendAll();
800067be:	f0 1f 00 05 	mcall	800067d0 <vPortFree+0x1c>
		{
			free( pv );
800067c2:	0e 9c       	mov	r12,r7
800067c4:	f0 1f 00 04 	mcall	800067d4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800067c8:	f0 1f 00 04 	mcall	800067d8 <vPortFree+0x24>
800067cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	6c fc       	ld.w	r12,r6[0x3c]
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	7b 98       	ld.w	r8,sp[0x64]
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	70 b8       	ld.w	r8,r8[0x2c]

800067dc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800067dc:	eb cd 40 80 	pushm	r7,lr
800067e0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800067e2:	f0 1f 00 06 	mcall	800067f8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800067e6:	0e 9c       	mov	r12,r7
800067e8:	f0 1f 00 05 	mcall	800067fc <pvPortMalloc+0x20>
800067ec:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800067ee:	f0 1f 00 05 	mcall	80006800 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800067f2:	0e 9c       	mov	r12,r7
800067f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	6c fc       	ld.w	r12,r6[0x3c]
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	7b a8       	ld.w	r8,sp[0x68]
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	70 b8       	ld.w	r8,r8[0x2c]

80006804 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006804:	d4 01       	pushm	lr
80006806:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006808:	78 09       	ld.w	r9,r12[0x0]
8000680a:	58 09       	cp.w	r9,0
8000680c:	c1 10       	breq	8000682e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000680e:	78 3a       	ld.w	r10,r12[0xc]
80006810:	79 09       	ld.w	r9,r12[0x40]
80006812:	f4 09 00 09 	add	r9,r10,r9
80006816:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006818:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000681a:	14 39       	cp.w	r9,r10
8000681c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006820:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006824:	79 0a       	ld.w	r10,r12[0x40]
80006826:	78 3b       	ld.w	r11,r12[0xc]
80006828:	10 9c       	mov	r12,r8
8000682a:	f0 1f 00 02 	mcall	80006830 <prvCopyDataFromQueue+0x2c>
8000682e:	d8 02       	popm	pc
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	80 16       	ld.sh	r6,r0[0x2]

80006834 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006834:	eb cd 40 c0 	pushm	r6-r7,lr
80006838:	18 97       	mov	r7,r12
8000683a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000683c:	78 e8       	ld.w	r8,r12[0x38]
8000683e:	58 08       	cp.w	r8,0
80006840:	c0 31       	brne	80006846 <xQueueReceiveFromISR+0x12>
80006842:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006846:	f0 1f 00 0e 	mcall	8000687c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000684a:	6e e8       	ld.w	r8,r7[0x38]
8000684c:	20 18       	sub	r8,1
8000684e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006850:	6f 18       	ld.w	r8,r7[0x44]
80006852:	5b f8       	cp.w	r8,-1
80006854:	c0 d1       	brne	8000686e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006856:	6e 48       	ld.w	r8,r7[0x10]
80006858:	58 08       	cp.w	r8,0
8000685a:	c0 f0       	breq	80006878 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000685c:	ee cc ff f0 	sub	r12,r7,-16
80006860:	f0 1f 00 08 	mcall	80006880 <xQueueReceiveFromISR+0x4c>
80006864:	c0 a0       	breq	80006878 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006866:	30 1c       	mov	r12,1
80006868:	8d 0c       	st.w	r6[0x0],r12
8000686a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000686e:	2f f8       	sub	r8,-1
80006870:	ef 48 00 44 	st.w	r7[68],r8
80006874:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006878:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000687c:	80 00       	ld.sh	r0,r0[0x0]
8000687e:	68 04       	ld.w	r4,r4[0x0]
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	6e 94       	ld.w	r4,r7[0x24]

80006884 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006884:	eb cd 40 c0 	pushm	r6-r7,lr
80006888:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000688a:	f0 1f 00 23 	mcall	80006914 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000688e:	6f 28       	ld.w	r8,r7[0x48]
80006890:	58 08       	cp.w	r8,0
80006892:	e0 8a 00 18 	brle	800068c2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006896:	6e 98       	ld.w	r8,r7[0x24]
80006898:	58 08       	cp.w	r8,0
8000689a:	c1 40       	breq	800068c2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000689c:	ee c6 ff dc 	sub	r6,r7,-36
800068a0:	c0 48       	rjmp	800068a8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800068a2:	6e 98       	ld.w	r8,r7[0x24]
800068a4:	58 08       	cp.w	r8,0
800068a6:	c0 e0       	breq	800068c2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800068a8:	0c 9c       	mov	r12,r6
800068aa:	f0 1f 00 1c 	mcall	80006918 <prvUnlockQueue+0x94>
800068ae:	c0 30       	breq	800068b4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800068b0:	f0 1f 00 1b 	mcall	8000691c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800068b4:	6f 28       	ld.w	r8,r7[0x48]
800068b6:	20 18       	sub	r8,1
800068b8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800068bc:	58 08       	cp.w	r8,0
800068be:	fe 99 ff f2 	brgt	800068a2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800068c2:	3f f8       	mov	r8,-1
800068c4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800068c8:	f0 1f 00 16 	mcall	80006920 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800068cc:	f0 1f 00 12 	mcall	80006914 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800068d0:	6f 18       	ld.w	r8,r7[0x44]
800068d2:	58 08       	cp.w	r8,0
800068d4:	e0 8a 00 18 	brle	80006904 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800068d8:	6e 48       	ld.w	r8,r7[0x10]
800068da:	58 08       	cp.w	r8,0
800068dc:	c1 40       	breq	80006904 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800068de:	ee c6 ff f0 	sub	r6,r7,-16
800068e2:	c0 48       	rjmp	800068ea <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800068e4:	6e 48       	ld.w	r8,r7[0x10]
800068e6:	58 08       	cp.w	r8,0
800068e8:	c0 e0       	breq	80006904 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800068ea:	0c 9c       	mov	r12,r6
800068ec:	f0 1f 00 0b 	mcall	80006918 <prvUnlockQueue+0x94>
800068f0:	c0 30       	breq	800068f6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800068f2:	f0 1f 00 0b 	mcall	8000691c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800068f6:	6f 18       	ld.w	r8,r7[0x44]
800068f8:	20 18       	sub	r8,1
800068fa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800068fe:	58 08       	cp.w	r8,0
80006900:	fe 99 ff f2 	brgt	800068e4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006904:	3f f8       	mov	r8,-1
80006906:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000690a:	f0 1f 00 06 	mcall	80006920 <prvUnlockQueue+0x9c>
}
8000690e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006912:	00 00       	add	r0,r0
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	65 70       	ld.w	r0,r2[0x5c]
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	6e 94       	ld.w	r4,r7[0x24]
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	6d a0       	ld.w	r0,r6[0x68]
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	66 7c       	ld.w	r12,r3[0x1c]

80006924 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006924:	d4 31       	pushm	r0-r7,lr
80006926:	20 5d       	sub	sp,20
80006928:	18 97       	mov	r7,r12
8000692a:	50 0b       	stdsp	sp[0x0],r11
8000692c:	50 2a       	stdsp	sp[0x8],r10
8000692e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006930:	f8 c2 ff dc 	sub	r2,r12,-36
80006934:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006936:	fa c4 ff f4 	sub	r4,sp,-12
8000693a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000693c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000693e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006942:	f0 1f 00 3e 	mcall	80006a38 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006946:	6e e8       	ld.w	r8,r7[0x38]
80006948:	58 08       	cp.w	r8,0
8000694a:	c2 a0       	breq	8000699e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000694c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000694e:	40 0b       	lddsp	r11,sp[0x0]
80006950:	0e 9c       	mov	r12,r7
80006952:	f0 1f 00 3b 	mcall	80006a3c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006956:	40 18       	lddsp	r8,sp[0x4]
80006958:	58 08       	cp.w	r8,0
8000695a:	c1 51       	brne	80006984 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000695c:	6e e8       	ld.w	r8,r7[0x38]
8000695e:	20 18       	sub	r8,1
80006960:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006962:	6e 08       	ld.w	r8,r7[0x0]
80006964:	58 08       	cp.w	r8,0
80006966:	c0 41       	brne	8000696e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006968:	f0 1f 00 36 	mcall	80006a40 <xQueueGenericReceive+0x11c>
8000696c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000696e:	6e 48       	ld.w	r8,r7[0x10]
80006970:	58 08       	cp.w	r8,0
80006972:	c1 20       	breq	80006996 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006974:	ee cc ff f0 	sub	r12,r7,-16
80006978:	f0 1f 00 33 	mcall	80006a44 <xQueueGenericReceive+0x120>
8000697c:	58 1c       	cp.w	r12,1
8000697e:	c0 c1       	brne	80006996 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006980:	d7 33       	scall
80006982:	c0 a8       	rjmp	80006996 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006984:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006986:	6e 98       	ld.w	r8,r7[0x24]
80006988:	58 08       	cp.w	r8,0
8000698a:	c0 60       	breq	80006996 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000698c:	04 9c       	mov	r12,r2
8000698e:	f0 1f 00 2e 	mcall	80006a44 <xQueueGenericReceive+0x120>
80006992:	c0 20       	breq	80006996 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006994:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006996:	f0 1f 00 2d 	mcall	80006a48 <xQueueGenericReceive+0x124>
8000699a:	30 1c       	mov	r12,1
				return pdPASS;
8000699c:	c4 c8       	rjmp	80006a34 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000699e:	40 28       	lddsp	r8,sp[0x8]
800069a0:	58 08       	cp.w	r8,0
800069a2:	c0 51       	brne	800069ac <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800069a4:	f0 1f 00 29 	mcall	80006a48 <xQueueGenericReceive+0x124>
800069a8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800069aa:	c4 58       	rjmp	80006a34 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800069ac:	58 05       	cp.w	r5,0
800069ae:	c0 51       	brne	800069b8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800069b0:	08 9c       	mov	r12,r4
800069b2:	f0 1f 00 27 	mcall	80006a4c <xQueueGenericReceive+0x128>
800069b6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800069b8:	f0 1f 00 24 	mcall	80006a48 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800069bc:	f0 1f 00 25 	mcall	80006a50 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800069c0:	f0 1f 00 1e 	mcall	80006a38 <xQueueGenericReceive+0x114>
800069c4:	6f 18       	ld.w	r8,r7[0x44]
800069c6:	5b f8       	cp.w	r8,-1
800069c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800069cc:	6f 28       	ld.w	r8,r7[0x48]
800069ce:	5b f8       	cp.w	r8,-1
800069d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800069d4:	f0 1f 00 1d 	mcall	80006a48 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800069d8:	06 9b       	mov	r11,r3
800069da:	08 9c       	mov	r12,r4
800069dc:	f0 1f 00 1e 	mcall	80006a54 <xQueueGenericReceive+0x130>
800069e0:	c2 41       	brne	80006a28 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800069e2:	f0 1f 00 16 	mcall	80006a38 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800069e6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800069e8:	f0 1f 00 18 	mcall	80006a48 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800069ec:	58 06       	cp.w	r6,0
800069ee:	c1 71       	brne	80006a1c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800069f0:	6e 08       	ld.w	r8,r7[0x0]
800069f2:	58 08       	cp.w	r8,0
800069f4:	c0 81       	brne	80006a04 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800069f6:	f0 1f 00 11 	mcall	80006a38 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800069fa:	6e 1c       	ld.w	r12,r7[0x4]
800069fc:	f0 1f 00 17 	mcall	80006a58 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006a00:	f0 1f 00 12 	mcall	80006a48 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006a04:	40 2b       	lddsp	r11,sp[0x8]
80006a06:	04 9c       	mov	r12,r2
80006a08:	f0 1f 00 15 	mcall	80006a5c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006a0c:	0e 9c       	mov	r12,r7
80006a0e:	f0 1f 00 15 	mcall	80006a60 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006a12:	f0 1f 00 15 	mcall	80006a64 <xQueueGenericReceive+0x140>
80006a16:	c9 61       	brne	80006942 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006a18:	d7 33       	scall
80006a1a:	c9 4b       	rjmp	80006942 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006a1c:	0e 9c       	mov	r12,r7
80006a1e:	f0 1f 00 11 	mcall	80006a60 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006a22:	f0 1f 00 11 	mcall	80006a64 <xQueueGenericReceive+0x140>
80006a26:	c8 eb       	rjmp	80006942 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006a28:	0e 9c       	mov	r12,r7
80006a2a:	f0 1f 00 0e 	mcall	80006a60 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006a2e:	f0 1f 00 0e 	mcall	80006a64 <xQueueGenericReceive+0x140>
80006a32:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006a34:	2f bd       	sub	sp,-20
80006a36:	d8 32       	popm	r0-r7,pc
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	65 70       	ld.w	r0,r2[0x5c]
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	68 04       	ld.w	r4,r4[0x0]
80006a40:	80 00       	ld.sh	r0,r0[0x0]
80006a42:	6d ac       	ld.w	r12,r6[0x68]
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	6e 94       	ld.w	r4,r7[0x24]
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	66 7c       	ld.w	r12,r3[0x1c]
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	6d 88       	ld.w	r8,r6[0x60]
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	6c fc       	ld.w	r12,r6[0x3c]
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	70 24       	ld.w	r4,r8[0x8]
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	6e 10       	ld.w	r0,r7[0x4]
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	72 c4       	ld.w	r4,r9[0x30]
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	68 84       	ld.w	r4,r4[0x20]
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	70 b8       	ld.w	r8,r8[0x2c]

80006a68 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006a68:	eb cd 40 80 	pushm	r7,lr
80006a6c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006a6e:	79 08       	ld.w	r8,r12[0x40]
80006a70:	58 08       	cp.w	r8,0
80006a72:	c0 a1       	brne	80006a86 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006a74:	78 08       	ld.w	r8,r12[0x0]
80006a76:	58 08       	cp.w	r8,0
80006a78:	c2 b1       	brne	80006ace <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006a7a:	78 1c       	ld.w	r12,r12[0x4]
80006a7c:	f0 1f 00 17 	mcall	80006ad8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006a80:	30 08       	mov	r8,0
80006a82:	8f 18       	st.w	r7[0x4],r8
80006a84:	c2 58       	rjmp	80006ace <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006a86:	58 0a       	cp.w	r10,0
80006a88:	c1 01       	brne	80006aa8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006a8a:	10 9a       	mov	r10,r8
80006a8c:	78 2c       	ld.w	r12,r12[0x8]
80006a8e:	f0 1f 00 14 	mcall	80006adc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006a92:	6e 29       	ld.w	r9,r7[0x8]
80006a94:	6f 08       	ld.w	r8,r7[0x40]
80006a96:	f2 08 00 08 	add	r8,r9,r8
80006a9a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006a9c:	6e 19       	ld.w	r9,r7[0x4]
80006a9e:	12 38       	cp.w	r8,r9
80006aa0:	c1 73       	brcs	80006ace <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006aa2:	6e 08       	ld.w	r8,r7[0x0]
80006aa4:	8f 28       	st.w	r7[0x8],r8
80006aa6:	c1 48       	rjmp	80006ace <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006aa8:	10 9a       	mov	r10,r8
80006aaa:	78 3c       	ld.w	r12,r12[0xc]
80006aac:	f0 1f 00 0c 	mcall	80006adc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006ab0:	6f 08       	ld.w	r8,r7[0x40]
80006ab2:	6e 39       	ld.w	r9,r7[0xc]
80006ab4:	f2 08 01 08 	sub	r8,r9,r8
80006ab8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006aba:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006abc:	12 38       	cp.w	r8,r9
80006abe:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006ac2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006ac6:	f3 d8 e3 19 	subcs	r9,r9,r8
80006aca:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006ace:	6e e8       	ld.w	r8,r7[0x38]
80006ad0:	2f f8       	sub	r8,-1
80006ad2:	8f e8       	st.w	r7[0x38],r8
}
80006ad4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	6d b8       	ld.w	r8,r6[0x6c]
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	80 16       	ld.sh	r6,r0[0x2]

80006ae0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006ae0:	eb cd 40 c0 	pushm	r6-r7,lr
80006ae4:	18 97       	mov	r7,r12
80006ae6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006ae8:	78 ec       	ld.w	r12,r12[0x38]
80006aea:	6e f8       	ld.w	r8,r7[0x3c]
80006aec:	10 3c       	cp.w	r12,r8
80006aee:	c0 33       	brcs	80006af4 <xQueueGenericSendFromISR+0x14>
80006af0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006af4:	12 9a       	mov	r10,r9
80006af6:	0e 9c       	mov	r12,r7
80006af8:	f0 1f 00 0c 	mcall	80006b28 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006afc:	6f 28       	ld.w	r8,r7[0x48]
80006afe:	5b f8       	cp.w	r8,-1
80006b00:	c0 d1       	brne	80006b1a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006b02:	6e 98       	ld.w	r8,r7[0x24]
80006b04:	58 08       	cp.w	r8,0
80006b06:	c0 f0       	breq	80006b24 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006b08:	ee cc ff dc 	sub	r12,r7,-36
80006b0c:	f0 1f 00 08 	mcall	80006b2c <xQueueGenericSendFromISR+0x4c>
80006b10:	c0 a0       	breq	80006b24 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006b12:	30 1c       	mov	r12,1
80006b14:	8d 0c       	st.w	r6[0x0],r12
80006b16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006b1a:	2f f8       	sub	r8,-1
80006b1c:	ef 48 00 48 	st.w	r7[72],r8
80006b20:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006b24:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	6a 68       	ld.w	r8,r5[0x18]
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	6e 94       	ld.w	r4,r7[0x24]

80006b30 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006b30:	d4 31       	pushm	r0-r7,lr
80006b32:	20 5d       	sub	sp,20
80006b34:	18 97       	mov	r7,r12
80006b36:	50 0b       	stdsp	sp[0x0],r11
80006b38:	50 2a       	stdsp	sp[0x8],r10
80006b3a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006b3c:	f8 c0 ff f0 	sub	r0,r12,-16
80006b40:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006b42:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006b46:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006b48:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006b4c:	f0 1f 00 2f 	mcall	80006c08 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006b50:	6e e9       	ld.w	r9,r7[0x38]
80006b52:	6e f8       	ld.w	r8,r7[0x3c]
80006b54:	10 39       	cp.w	r9,r8
80006b56:	c1 42       	brcc	80006b7e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006b58:	40 1a       	lddsp	r10,sp[0x4]
80006b5a:	40 0b       	lddsp	r11,sp[0x0]
80006b5c:	0e 9c       	mov	r12,r7
80006b5e:	f0 1f 00 2c 	mcall	80006c0c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006b62:	6e 98       	ld.w	r8,r7[0x24]
80006b64:	58 08       	cp.w	r8,0
80006b66:	c0 80       	breq	80006b76 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006b68:	ee cc ff dc 	sub	r12,r7,-36
80006b6c:	f0 1f 00 29 	mcall	80006c10 <xQueueGenericSend+0xe0>
80006b70:	58 1c       	cp.w	r12,1
80006b72:	c0 21       	brne	80006b76 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006b74:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006b76:	f0 1f 00 28 	mcall	80006c14 <xQueueGenericSend+0xe4>
80006b7a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006b7c:	c4 38       	rjmp	80006c02 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006b7e:	40 28       	lddsp	r8,sp[0x8]
80006b80:	58 08       	cp.w	r8,0
80006b82:	c0 51       	brne	80006b8c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006b84:	f0 1f 00 24 	mcall	80006c14 <xQueueGenericSend+0xe4>
80006b88:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006b8a:	c3 c8       	rjmp	80006c02 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006b8c:	58 04       	cp.w	r4,0
80006b8e:	c0 51       	brne	80006b98 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006b90:	06 9c       	mov	r12,r3
80006b92:	f0 1f 00 22 	mcall	80006c18 <xQueueGenericSend+0xe8>
80006b96:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006b98:	f0 1f 00 1f 	mcall	80006c14 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006b9c:	f0 1f 00 20 	mcall	80006c1c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006ba0:	f0 1f 00 1a 	mcall	80006c08 <xQueueGenericSend+0xd8>
80006ba4:	6f 18       	ld.w	r8,r7[0x44]
80006ba6:	5b f8       	cp.w	r8,-1
80006ba8:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006bac:	6f 28       	ld.w	r8,r7[0x48]
80006bae:	5b f8       	cp.w	r8,-1
80006bb0:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006bb4:	f0 1f 00 18 	mcall	80006c14 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006bb8:	04 9b       	mov	r11,r2
80006bba:	06 9c       	mov	r12,r3
80006bbc:	f0 1f 00 19 	mcall	80006c20 <xQueueGenericSend+0xf0>
80006bc0:	c1 b1       	brne	80006bf6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006bc2:	f0 1f 00 12 	mcall	80006c08 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006bc6:	6e e5       	ld.w	r5,r7[0x38]
80006bc8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006bca:	f0 1f 00 13 	mcall	80006c14 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006bce:	0c 35       	cp.w	r5,r6
80006bd0:	c0 d1       	brne	80006bea <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006bd2:	40 2b       	lddsp	r11,sp[0x8]
80006bd4:	00 9c       	mov	r12,r0
80006bd6:	f0 1f 00 14 	mcall	80006c24 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006bda:	0e 9c       	mov	r12,r7
80006bdc:	f0 1f 00 13 	mcall	80006c28 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006be0:	f0 1f 00 13 	mcall	80006c2c <xQueueGenericSend+0xfc>
80006be4:	cb 41       	brne	80006b4c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006be6:	d7 33       	scall
80006be8:	cb 2b       	rjmp	80006b4c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006bea:	0e 9c       	mov	r12,r7
80006bec:	f0 1f 00 0f 	mcall	80006c28 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006bf0:	f0 1f 00 0f 	mcall	80006c2c <xQueueGenericSend+0xfc>
80006bf4:	ca cb       	rjmp	80006b4c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006bf6:	0e 9c       	mov	r12,r7
80006bf8:	f0 1f 00 0c 	mcall	80006c28 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006bfc:	f0 1f 00 0c 	mcall	80006c2c <xQueueGenericSend+0xfc>
80006c00:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006c02:	2f bd       	sub	sp,-20
80006c04:	d8 32       	popm	r0-r7,pc
80006c06:	00 00       	add	r0,r0
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	65 70       	ld.w	r0,r2[0x5c]
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	6a 68       	ld.w	r8,r5[0x18]
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	6e 94       	ld.w	r4,r7[0x24]
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	66 7c       	ld.w	r12,r3[0x1c]
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	6d 88       	ld.w	r8,r6[0x60]
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	6c fc       	ld.w	r12,r6[0x3c]
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	70 24       	ld.w	r4,r8[0x8]
80006c24:	80 00       	ld.sh	r0,r0[0x0]
80006c26:	72 c4       	ld.w	r4,r9[0x30]
80006c28:	80 00       	ld.sh	r0,r0[0x0]
80006c2a:	68 84       	ld.w	r4,r4[0x20]
80006c2c:	80 00       	ld.sh	r0,r0[0x0]
80006c2e:	70 b8       	ld.w	r8,r8[0x2c]

80006c30 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006c30:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006c34:	34 cc       	mov	r12,76
80006c36:	f0 1f 00 12 	mcall	80006c7c <xQueueCreateMutex+0x4c>
80006c3a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006c3c:	c1 d0       	breq	80006c76 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006c3e:	30 06       	mov	r6,0
80006c40:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006c42:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006c44:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006c46:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006c48:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80006c4a:	30 18       	mov	r8,1
80006c4c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006c4e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006c52:	3f f8       	mov	r8,-1
80006c54:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006c58:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006c5c:	2f 0c       	sub	r12,-16
80006c5e:	f0 1f 00 09 	mcall	80006c80 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006c62:	ee cc ff dc 	sub	r12,r7,-36
80006c66:	f0 1f 00 07 	mcall	80006c80 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006c6a:	0c 99       	mov	r9,r6
80006c6c:	0c 9a       	mov	r10,r6
80006c6e:	0c 9b       	mov	r11,r6
80006c70:	0e 9c       	mov	r12,r7
80006c72:	f0 1f 00 05 	mcall	80006c84 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006c76:	0e 9c       	mov	r12,r7
80006c78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	67 dc       	ld.w	r12,r3[0x74]
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	64 4c       	ld.w	r12,r2[0x10]
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	6b 30       	ld.w	r0,r5[0x4c]

80006c88 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006c88:	d4 21       	pushm	r4-r7,lr
80006c8a:	18 97       	mov	r7,r12
80006c8c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006c8e:	58 0c       	cp.w	r12,0
80006c90:	c2 f0       	breq	80006cee <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006c92:	34 cc       	mov	r12,76
80006c94:	f0 1f 00 17 	mcall	80006cf0 <xQueueCreate+0x68>
80006c98:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006c9a:	c2 a0       	breq	80006cee <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006c9c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006ca0:	e8 cc ff ff 	sub	r12,r4,-1
80006ca4:	f0 1f 00 13 	mcall	80006cf0 <xQueueCreate+0x68>
80006ca8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006caa:	c1 e0       	breq	80006ce6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006cac:	f8 04 00 04 	add	r4,r12,r4
80006cb0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006cb2:	30 08       	mov	r8,0
80006cb4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006cb6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006cb8:	ee c8 00 01 	sub	r8,r7,1
80006cbc:	ad 38       	mul	r8,r6
80006cbe:	10 0c       	add	r12,r8
80006cc0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006cc2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006cc4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006cc8:	3f f8       	mov	r8,-1
80006cca:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006cce:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006cd2:	ea cc ff f0 	sub	r12,r5,-16
80006cd6:	f0 1f 00 08 	mcall	80006cf4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006cda:	ea cc ff dc 	sub	r12,r5,-36
80006cde:	f0 1f 00 06 	mcall	80006cf4 <xQueueCreate+0x6c>
80006ce2:	0a 9c       	mov	r12,r5
80006ce4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006ce6:	0a 9c       	mov	r12,r5
80006ce8:	f0 1f 00 04 	mcall	80006cf8 <xQueueCreate+0x70>
80006cec:	d8 2a       	popm	r4-r7,pc,r12=0
80006cee:	d8 2a       	popm	r4-r7,pc,r12=0
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	67 dc       	ld.w	r12,r3[0x74]
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	64 4c       	ld.w	r12,r2[0x10]
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	67 b4       	ld.w	r4,r3[0x6c]

80006cfc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006cfc:	48 38       	lddpc	r8,80006d08 <vTaskSuspendAll+0xc>
80006cfe:	70 09       	ld.w	r9,r8[0x0]
80006d00:	2f f9       	sub	r9,-1
80006d02:	91 09       	st.w	r8[0x0],r9
}
80006d04:	5e fc       	retal	r12
80006d06:	00 00       	add	r0,r0
80006d08:	00 00       	add	r0,r0
80006d0a:	0d 84       	ld.ub	r4,r6[0x0]

80006d0c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006d0c:	49 a8       	lddpc	r8,80006d74 <vTaskSwitchContext+0x68>
80006d0e:	70 08       	ld.w	r8,r8[0x0]
80006d10:	58 08       	cp.w	r8,0
80006d12:	c0 b1       	brne	80006d28 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006d14:	49 98       	lddpc	r8,80006d78 <vTaskSwitchContext+0x6c>
80006d16:	70 08       	ld.w	r8,r8[0x0]
80006d18:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006d1c:	49 89       	lddpc	r9,80006d7c <vTaskSwitchContext+0x70>
80006d1e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006d22:	58 08       	cp.w	r8,0
80006d24:	c0 60       	breq	80006d30 <vTaskSwitchContext+0x24>
80006d26:	c1 18       	rjmp	80006d48 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006d28:	30 19       	mov	r9,1
80006d2a:	49 68       	lddpc	r8,80006d80 <vTaskSwitchContext+0x74>
80006d2c:	91 09       	st.w	r8[0x0],r9
80006d2e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006d30:	49 28       	lddpc	r8,80006d78 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006d32:	49 3a       	lddpc	r10,80006d7c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006d34:	70 09       	ld.w	r9,r8[0x0]
80006d36:	20 19       	sub	r9,1
80006d38:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006d3a:	70 09       	ld.w	r9,r8[0x0]
80006d3c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d40:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006d44:	58 09       	cp.w	r9,0
80006d46:	cf 70       	breq	80006d34 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006d48:	48 c8       	lddpc	r8,80006d78 <vTaskSwitchContext+0x6c>
80006d4a:	70 08       	ld.w	r8,r8[0x0]
80006d4c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006d50:	48 b9       	lddpc	r9,80006d7c <vTaskSwitchContext+0x70>
80006d52:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006d56:	70 19       	ld.w	r9,r8[0x4]
80006d58:	72 19       	ld.w	r9,r9[0x4]
80006d5a:	91 19       	st.w	r8[0x4],r9
80006d5c:	f0 ca ff f8 	sub	r10,r8,-8
80006d60:	14 39       	cp.w	r9,r10
80006d62:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006d66:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006d6a:	70 18       	ld.w	r8,r8[0x4]
80006d6c:	70 39       	ld.w	r9,r8[0xc]
80006d6e:	48 68       	lddpc	r8,80006d84 <vTaskSwitchContext+0x78>
80006d70:	91 09       	st.w	r8[0x0],r9
80006d72:	5e fc       	retal	r12
80006d74:	00 00       	add	r0,r0
80006d76:	0d 84       	ld.ub	r4,r6[0x0]
80006d78:	00 00       	add	r0,r0
80006d7a:	0d bc       	ld.ub	r12,r6[0x3]
80006d7c:	00 00       	add	r0,r0
80006d7e:	0c a0       	st.w	r6++,r0
80006d80:	00 00       	add	r0,r0
80006d82:	0d a4       	ld.ub	r4,r6[0x2]
80006d84:	00 00       	add	r0,r0
80006d86:	0d 54       	ld.sh	r4,--r6

80006d88 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006d88:	48 48       	lddpc	r8,80006d98 <vTaskSetTimeOutState+0x10>
80006d8a:	70 08       	ld.w	r8,r8[0x0]
80006d8c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006d8e:	48 48       	lddpc	r8,80006d9c <vTaskSetTimeOutState+0x14>
80006d90:	70 08       	ld.w	r8,r8[0x0]
80006d92:	99 18       	st.w	r12[0x4],r8
}
80006d94:	5e fc       	retal	r12
80006d96:	00 00       	add	r0,r0
80006d98:	00 00       	add	r0,r0
80006d9a:	0c 98       	mov	r8,r6
80006d9c:	00 00       	add	r0,r0
80006d9e:	0d 80       	ld.ub	r0,r6[0x0]

80006da0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006da0:	30 19       	mov	r9,1
80006da2:	48 28       	lddpc	r8,80006da8 <vTaskMissedYield+0x8>
80006da4:	91 09       	st.w	r8[0x0],r9
}
80006da6:	5e fc       	retal	r12
80006da8:	00 00       	add	r0,r0
80006daa:	0d a4       	ld.ub	r4,r6[0x2]

80006dac <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006dac:	48 28       	lddpc	r8,80006db4 <xTaskGetCurrentTaskHandle+0x8>
80006dae:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006db0:	5e fc       	retal	r12
80006db2:	00 00       	add	r0,r0
80006db4:	00 00       	add	r0,r0
80006db6:	0d 54       	ld.sh	r4,--r6

80006db8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006db8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006dbc:	58 0c       	cp.w	r12,0
80006dbe:	c1 f0       	breq	80006dfc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006dc0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006dc2:	78 b9       	ld.w	r9,r12[0x2c]
80006dc4:	79 18       	ld.w	r8,r12[0x44]
80006dc6:	10 39       	cp.w	r9,r8
80006dc8:	c1 a0       	breq	80006dfc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006dca:	f8 c6 ff fc 	sub	r6,r12,-4
80006dce:	0c 9c       	mov	r12,r6
80006dd0:	f0 1f 00 0c 	mcall	80006e00 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006dd4:	6f 1c       	ld.w	r12,r7[0x44]
80006dd6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006dd8:	f8 08 11 08 	rsub	r8,r12,8
80006ddc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006dde:	48 a8       	lddpc	r8,80006e04 <vTaskPriorityDisinherit+0x4c>
80006de0:	70 08       	ld.w	r8,r8[0x0]
80006de2:	10 3c       	cp.w	r12,r8
80006de4:	e0 88 00 04 	brls	80006dec <vTaskPriorityDisinherit+0x34>
80006de8:	48 78       	lddpc	r8,80006e04 <vTaskPriorityDisinherit+0x4c>
80006dea:	91 0c       	st.w	r8[0x0],r12
80006dec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006df0:	0c 9b       	mov	r11,r6
80006df2:	48 68       	lddpc	r8,80006e08 <vTaskPriorityDisinherit+0x50>
80006df4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006df8:	f0 1f 00 05 	mcall	80006e0c <vTaskPriorityDisinherit+0x54>
80006dfc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e00:	80 00       	ld.sh	r0,r0[0x0]
80006e02:	64 b6       	ld.w	r6,r2[0x2c]
80006e04:	00 00       	add	r0,r0
80006e06:	0d bc       	ld.ub	r12,r6[0x3]
80006e08:	00 00       	add	r0,r0
80006e0a:	0c a0       	st.w	r6++,r0
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	64 66       	ld.w	r6,r2[0x18]

80006e10 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006e10:	eb cd 40 c0 	pushm	r6-r7,lr
80006e14:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006e16:	49 b8       	lddpc	r8,80006e80 <vTaskPriorityInherit+0x70>
80006e18:	70 08       	ld.w	r8,r8[0x0]
80006e1a:	78 b9       	ld.w	r9,r12[0x2c]
80006e1c:	70 b8       	ld.w	r8,r8[0x2c]
80006e1e:	10 39       	cp.w	r9,r8
80006e20:	c2 d2       	brcc	80006e7a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006e22:	49 88       	lddpc	r8,80006e80 <vTaskPriorityInherit+0x70>
80006e24:	70 08       	ld.w	r8,r8[0x0]
80006e26:	70 b8       	ld.w	r8,r8[0x2c]
80006e28:	f0 08 11 08 	rsub	r8,r8,8
80006e2c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006e2e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006e32:	49 59       	lddpc	r9,80006e84 <vTaskPriorityInherit+0x74>
80006e34:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006e38:	78 59       	ld.w	r9,r12[0x14]
80006e3a:	10 39       	cp.w	r9,r8
80006e3c:	c1 b1       	brne	80006e72 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006e3e:	f8 c6 ff fc 	sub	r6,r12,-4
80006e42:	0c 9c       	mov	r12,r6
80006e44:	f0 1f 00 11 	mcall	80006e88 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006e48:	48 e8       	lddpc	r8,80006e80 <vTaskPriorityInherit+0x70>
80006e4a:	70 08       	ld.w	r8,r8[0x0]
80006e4c:	70 bc       	ld.w	r12,r8[0x2c]
80006e4e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006e50:	48 f8       	lddpc	r8,80006e8c <vTaskPriorityInherit+0x7c>
80006e52:	70 08       	ld.w	r8,r8[0x0]
80006e54:	10 3c       	cp.w	r12,r8
80006e56:	e0 88 00 04 	brls	80006e5e <vTaskPriorityInherit+0x4e>
80006e5a:	48 d8       	lddpc	r8,80006e8c <vTaskPriorityInherit+0x7c>
80006e5c:	91 0c       	st.w	r8[0x0],r12
80006e5e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006e62:	0c 9b       	mov	r11,r6
80006e64:	48 88       	lddpc	r8,80006e84 <vTaskPriorityInherit+0x74>
80006e66:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006e6a:	f0 1f 00 0a 	mcall	80006e90 <vTaskPriorityInherit+0x80>
80006e6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006e72:	48 48       	lddpc	r8,80006e80 <vTaskPriorityInherit+0x70>
80006e74:	70 08       	ld.w	r8,r8[0x0]
80006e76:	70 b8       	ld.w	r8,r8[0x2c]
80006e78:	99 b8       	st.w	r12[0x2c],r8
80006e7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e7e:	00 00       	add	r0,r0
80006e80:	00 00       	add	r0,r0
80006e82:	0d 54       	ld.sh	r4,--r6
80006e84:	00 00       	add	r0,r0
80006e86:	0c a0       	st.w	r6++,r0
80006e88:	80 00       	ld.sh	r0,r0[0x0]
80006e8a:	64 b6       	ld.w	r6,r2[0x2c]
80006e8c:	00 00       	add	r0,r0
80006e8e:	0d bc       	ld.ub	r12,r6[0x3]
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	64 66       	ld.w	r6,r2[0x18]

80006e94 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006e94:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006e98:	78 38       	ld.w	r8,r12[0xc]
80006e9a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006e9c:	ee c6 ff e8 	sub	r6,r7,-24
80006ea0:	0c 9c       	mov	r12,r6
80006ea2:	f0 1f 00 15 	mcall	80006ef4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006ea6:	49 58       	lddpc	r8,80006ef8 <xTaskRemoveFromEventList+0x64>
80006ea8:	70 08       	ld.w	r8,r8[0x0]
80006eaa:	58 08       	cp.w	r8,0
80006eac:	c1 71       	brne	80006eda <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006eae:	ee c6 ff fc 	sub	r6,r7,-4
80006eb2:	0c 9c       	mov	r12,r6
80006eb4:	f0 1f 00 10 	mcall	80006ef4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006eb8:	6e bc       	ld.w	r12,r7[0x2c]
80006eba:	49 18       	lddpc	r8,80006efc <xTaskRemoveFromEventList+0x68>
80006ebc:	70 08       	ld.w	r8,r8[0x0]
80006ebe:	10 3c       	cp.w	r12,r8
80006ec0:	e0 88 00 04 	brls	80006ec8 <xTaskRemoveFromEventList+0x34>
80006ec4:	48 e8       	lddpc	r8,80006efc <xTaskRemoveFromEventList+0x68>
80006ec6:	91 0c       	st.w	r8[0x0],r12
80006ec8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ecc:	0c 9b       	mov	r11,r6
80006ece:	48 d8       	lddpc	r8,80006f00 <xTaskRemoveFromEventList+0x6c>
80006ed0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ed4:	f0 1f 00 0c 	mcall	80006f04 <xTaskRemoveFromEventList+0x70>
80006ed8:	c0 58       	rjmp	80006ee2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006eda:	0c 9b       	mov	r11,r6
80006edc:	48 bc       	lddpc	r12,80006f08 <xTaskRemoveFromEventList+0x74>
80006ede:	f0 1f 00 0a 	mcall	80006f04 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ee2:	48 b8       	lddpc	r8,80006f0c <xTaskRemoveFromEventList+0x78>
80006ee4:	70 08       	ld.w	r8,r8[0x0]
80006ee6:	6e b9       	ld.w	r9,r7[0x2c]
80006ee8:	70 b8       	ld.w	r8,r8[0x2c]
80006eea:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006eec:	5f 2c       	srhs	r12
80006eee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ef2:	00 00       	add	r0,r0
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	64 b6       	ld.w	r6,r2[0x2c]
80006ef8:	00 00       	add	r0,r0
80006efa:	0d 84       	ld.ub	r4,r6[0x0]
80006efc:	00 00       	add	r0,r0
80006efe:	0d bc       	ld.ub	r12,r6[0x3]
80006f00:	00 00       	add	r0,r0
80006f02:	0c a0       	st.w	r6++,r0
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	64 66       	ld.w	r6,r2[0x18]
80006f08:	00 00       	add	r0,r0
80006f0a:	0d 58       	ld.sh	r8,--r6
80006f0c:	00 00       	add	r0,r0
80006f0e:	0d 54       	ld.sh	r4,--r6

80006f10 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006f10:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006f14:	4b 98       	lddpc	r8,80006ff8 <vTaskIncrementTick+0xe8>
80006f16:	70 08       	ld.w	r8,r8[0x0]
80006f18:	58 08       	cp.w	r8,0
80006f1a:	c6 91       	brne	80006fec <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006f1c:	4b 88       	lddpc	r8,80006ffc <vTaskIncrementTick+0xec>
80006f1e:	70 09       	ld.w	r9,r8[0x0]
80006f20:	2f f9       	sub	r9,-1
80006f22:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006f24:	70 08       	ld.w	r8,r8[0x0]
80006f26:	58 08       	cp.w	r8,0
80006f28:	c1 a1       	brne	80006f5c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006f2a:	4b 68       	lddpc	r8,80007000 <vTaskIncrementTick+0xf0>
80006f2c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006f2e:	4b 69       	lddpc	r9,80007004 <vTaskIncrementTick+0xf4>
80006f30:	72 0b       	ld.w	r11,r9[0x0]
80006f32:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006f34:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006f36:	4b 59       	lddpc	r9,80007008 <vTaskIncrementTick+0xf8>
80006f38:	72 0a       	ld.w	r10,r9[0x0]
80006f3a:	2f fa       	sub	r10,-1
80006f3c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006f3e:	70 08       	ld.w	r8,r8[0x0]
80006f40:	70 08       	ld.w	r8,r8[0x0]
80006f42:	58 08       	cp.w	r8,0
80006f44:	c0 51       	brne	80006f4e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006f46:	3f f9       	mov	r9,-1
80006f48:	4b 18       	lddpc	r8,8000700c <vTaskIncrementTick+0xfc>
80006f4a:	91 09       	st.w	r8[0x0],r9
80006f4c:	c0 88       	rjmp	80006f5c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006f4e:	4a d8       	lddpc	r8,80007000 <vTaskIncrementTick+0xf0>
80006f50:	70 08       	ld.w	r8,r8[0x0]
80006f52:	70 38       	ld.w	r8,r8[0xc]
80006f54:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006f56:	70 19       	ld.w	r9,r8[0x4]
80006f58:	4a d8       	lddpc	r8,8000700c <vTaskIncrementTick+0xfc>
80006f5a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006f5c:	4a 88       	lddpc	r8,80006ffc <vTaskIncrementTick+0xec>
80006f5e:	70 09       	ld.w	r9,r8[0x0]
80006f60:	4a b8       	lddpc	r8,8000700c <vTaskIncrementTick+0xfc>
80006f62:	70 08       	ld.w	r8,r8[0x0]
80006f64:	10 39       	cp.w	r9,r8
80006f66:	c4 73       	brcs	80006ff4 <vTaskIncrementTick+0xe4>
80006f68:	4a 68       	lddpc	r8,80007000 <vTaskIncrementTick+0xf0>
80006f6a:	70 08       	ld.w	r8,r8[0x0]
80006f6c:	70 08       	ld.w	r8,r8[0x0]
80006f6e:	58 08       	cp.w	r8,0
80006f70:	c0 c0       	breq	80006f88 <vTaskIncrementTick+0x78>
80006f72:	4a 48       	lddpc	r8,80007000 <vTaskIncrementTick+0xf0>
80006f74:	70 08       	ld.w	r8,r8[0x0]
80006f76:	70 38       	ld.w	r8,r8[0xc]
80006f78:	70 37       	ld.w	r7,r8[0xc]
80006f7a:	6e 18       	ld.w	r8,r7[0x4]
80006f7c:	4a 09       	lddpc	r9,80006ffc <vTaskIncrementTick+0xec>
80006f7e:	72 09       	ld.w	r9,r9[0x0]
80006f80:	12 38       	cp.w	r8,r9
80006f82:	e0 88 00 14 	brls	80006faa <vTaskIncrementTick+0x9a>
80006f86:	c0 e8       	rjmp	80006fa2 <vTaskIncrementTick+0x92>
80006f88:	3f f9       	mov	r9,-1
80006f8a:	4a 18       	lddpc	r8,8000700c <vTaskIncrementTick+0xfc>
80006f8c:	91 09       	st.w	r8[0x0],r9
80006f8e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006f92:	6a 08       	ld.w	r8,r5[0x0]
80006f94:	70 38       	ld.w	r8,r8[0xc]
80006f96:	70 37       	ld.w	r7,r8[0xc]
80006f98:	6e 18       	ld.w	r8,r7[0x4]
80006f9a:	64 09       	ld.w	r9,r2[0x0]
80006f9c:	12 38       	cp.w	r8,r9
80006f9e:	e0 88 00 0a 	brls	80006fb2 <vTaskIncrementTick+0xa2>
80006fa2:	49 b9       	lddpc	r9,8000700c <vTaskIncrementTick+0xfc>
80006fa4:	93 08       	st.w	r9[0x0],r8
80006fa6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006faa:	49 a4       	lddpc	r4,80007010 <vTaskIncrementTick+0x100>
80006fac:	49 a3       	lddpc	r3,80007014 <vTaskIncrementTick+0x104>
80006fae:	49 55       	lddpc	r5,80007000 <vTaskIncrementTick+0xf0>
80006fb0:	49 32       	lddpc	r2,80006ffc <vTaskIncrementTick+0xec>
80006fb2:	ee c6 ff fc 	sub	r6,r7,-4
80006fb6:	0c 9c       	mov	r12,r6
80006fb8:	f0 1f 00 18 	mcall	80007018 <vTaskIncrementTick+0x108>
80006fbc:	6e a8       	ld.w	r8,r7[0x28]
80006fbe:	58 08       	cp.w	r8,0
80006fc0:	c0 50       	breq	80006fca <vTaskIncrementTick+0xba>
80006fc2:	ee cc ff e8 	sub	r12,r7,-24
80006fc6:	f0 1f 00 15 	mcall	80007018 <vTaskIncrementTick+0x108>
80006fca:	6e bc       	ld.w	r12,r7[0x2c]
80006fcc:	68 08       	ld.w	r8,r4[0x0]
80006fce:	10 3c       	cp.w	r12,r8
80006fd0:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006fd4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006fd8:	0c 9b       	mov	r11,r6
80006fda:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006fde:	f0 1f 00 10 	mcall	8000701c <vTaskIncrementTick+0x10c>
80006fe2:	6a 08       	ld.w	r8,r5[0x0]
80006fe4:	70 08       	ld.w	r8,r8[0x0]
80006fe6:	58 08       	cp.w	r8,0
80006fe8:	cd 51       	brne	80006f92 <vTaskIncrementTick+0x82>
80006fea:	cc fb       	rjmp	80006f88 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006fec:	48 d8       	lddpc	r8,80007020 <vTaskIncrementTick+0x110>
80006fee:	70 09       	ld.w	r9,r8[0x0]
80006ff0:	2f f9       	sub	r9,-1
80006ff2:	91 09       	st.w	r8[0x0],r9
80006ff4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006ff8:	00 00       	add	r0,r0
80006ffa:	0d 84       	ld.ub	r4,r6[0x0]
80006ffc:	00 00       	add	r0,r0
80006ffe:	0d 80       	ld.ub	r0,r6[0x0]
80007000:	00 00       	add	r0,r0
80007002:	0c 8c       	andn	r12,r6
80007004:	00 00       	add	r0,r0
80007006:	0c 9c       	mov	r12,r6
80007008:	00 00       	add	r0,r0
8000700a:	0c 98       	mov	r8,r6
8000700c:	00 00       	add	r0,r0
8000700e:	05 48       	ld.w	r8,--r2
80007010:	00 00       	add	r0,r0
80007012:	0d bc       	ld.ub	r12,r6[0x3]
80007014:	00 00       	add	r0,r0
80007016:	0c a0       	st.w	r6++,r0
80007018:	80 00       	ld.sh	r0,r0[0x0]
8000701a:	64 b6       	ld.w	r6,r2[0x2c]
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	64 66       	ld.w	r6,r2[0x18]
80007020:	00 00       	add	r0,r0
80007022:	0c 84       	andn	r4,r6

80007024 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007024:	eb cd 40 c0 	pushm	r6-r7,lr
80007028:	18 97       	mov	r7,r12
8000702a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000702c:	f0 1f 00 15 	mcall	80007080 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80007030:	6c 08       	ld.w	r8,r6[0x0]
80007032:	5b f8       	cp.w	r8,-1
80007034:	c0 31       	brne	8000703a <xTaskCheckForTimeOut+0x16>
80007036:	30 07       	mov	r7,0
80007038:	c1 f8       	rjmp	80007076 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000703a:	49 39       	lddpc	r9,80007084 <xTaskCheckForTimeOut+0x60>
8000703c:	72 09       	ld.w	r9,r9[0x0]
8000703e:	6e 0a       	ld.w	r10,r7[0x0]
80007040:	12 3a       	cp.w	r10,r9
80007042:	c0 70       	breq	80007050 <xTaskCheckForTimeOut+0x2c>
80007044:	49 19       	lddpc	r9,80007088 <xTaskCheckForTimeOut+0x64>
80007046:	72 09       	ld.w	r9,r9[0x0]
80007048:	6e 1a       	ld.w	r10,r7[0x4]
8000704a:	12 3a       	cp.w	r10,r9
8000704c:	e0 88 00 14 	brls	80007074 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80007050:	48 e9       	lddpc	r9,80007088 <xTaskCheckForTimeOut+0x64>
80007052:	72 0a       	ld.w	r10,r9[0x0]
80007054:	6e 19       	ld.w	r9,r7[0x4]
80007056:	12 1a       	sub	r10,r9
80007058:	14 38       	cp.w	r8,r10
8000705a:	e0 88 00 0d 	brls	80007074 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000705e:	48 ba       	lddpc	r10,80007088 <xTaskCheckForTimeOut+0x64>
80007060:	74 0a       	ld.w	r10,r10[0x0]
80007062:	14 19       	sub	r9,r10
80007064:	f2 08 00 08 	add	r8,r9,r8
80007068:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000706a:	0e 9c       	mov	r12,r7
8000706c:	f0 1f 00 08 	mcall	8000708c <xTaskCheckForTimeOut+0x68>
80007070:	30 07       	mov	r7,0
80007072:	c0 28       	rjmp	80007076 <xTaskCheckForTimeOut+0x52>
80007074:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80007076:	f0 1f 00 07 	mcall	80007090 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000707a:	0e 9c       	mov	r12,r7
8000707c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	65 70       	ld.w	r0,r2[0x5c]
80007084:	00 00       	add	r0,r0
80007086:	0c 98       	mov	r8,r6
80007088:	00 00       	add	r0,r0
8000708a:	0d 80       	ld.ub	r0,r6[0x0]
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	6d 88       	ld.w	r8,r6[0x60]
80007090:	80 00       	ld.sh	r0,r0[0x0]
80007092:	66 7c       	ld.w	r12,r3[0x1c]

80007094 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007094:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80007098:	f0 1f 00 05 	mcall	800070ac <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000709c:	48 58       	lddpc	r8,800070b0 <xTaskGetTickCount+0x1c>
8000709e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800070a0:	f0 1f 00 05 	mcall	800070b4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800070a4:	0e 9c       	mov	r12,r7
800070a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800070aa:	00 00       	add	r0,r0
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	65 70       	ld.w	r0,r2[0x5c]
800070b0:	00 00       	add	r0,r0
800070b2:	0d 80       	ld.ub	r0,r6[0x0]
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	66 7c       	ld.w	r12,r3[0x1c]

800070b8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800070b8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800070bc:	f0 1f 00 2c 	mcall	8000716c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800070c0:	4a c8       	lddpc	r8,80007170 <xTaskResumeAll+0xb8>
800070c2:	70 09       	ld.w	r9,r8[0x0]
800070c4:	20 19       	sub	r9,1
800070c6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800070c8:	70 08       	ld.w	r8,r8[0x0]
800070ca:	58 08       	cp.w	r8,0
800070cc:	c4 91       	brne	8000715e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800070ce:	4a a8       	lddpc	r8,80007174 <xTaskResumeAll+0xbc>
800070d0:	70 08       	ld.w	r8,r8[0x0]
800070d2:	58 08       	cp.w	r8,0
800070d4:	c4 50       	breq	8000715e <xTaskResumeAll+0xa6>
800070d6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800070d8:	4a 85       	lddpc	r5,80007178 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800070da:	4a 93       	lddpc	r3,8000717c <xTaskResumeAll+0xc4>
800070dc:	4a 92       	lddpc	r2,80007180 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800070de:	4a a1       	lddpc	r1,80007184 <xTaskResumeAll+0xcc>
800070e0:	c1 e8       	rjmp	8000711c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800070e2:	6a 38       	ld.w	r8,r5[0xc]
800070e4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800070e6:	ee cc ff e8 	sub	r12,r7,-24
800070ea:	f0 1f 00 28 	mcall	80007188 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800070ee:	ee c6 ff fc 	sub	r6,r7,-4
800070f2:	0c 9c       	mov	r12,r6
800070f4:	f0 1f 00 25 	mcall	80007188 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800070f8:	6e bc       	ld.w	r12,r7[0x2c]
800070fa:	66 08       	ld.w	r8,r3[0x0]
800070fc:	10 3c       	cp.w	r12,r8
800070fe:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007102:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007106:	0c 9b       	mov	r11,r6
80007108:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000710c:	f0 1f 00 20 	mcall	8000718c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007110:	62 08       	ld.w	r8,r1[0x0]
80007112:	6e b9       	ld.w	r9,r7[0x2c]
80007114:	70 b8       	ld.w	r8,r8[0x2c]
80007116:	10 39       	cp.w	r9,r8
80007118:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000711c:	6a 08       	ld.w	r8,r5[0x0]
8000711e:	58 08       	cp.w	r8,0
80007120:	ce 11       	brne	800070e2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007122:	49 c8       	lddpc	r8,80007190 <xTaskResumeAll+0xd8>
80007124:	70 08       	ld.w	r8,r8[0x0]
80007126:	58 08       	cp.w	r8,0
80007128:	c0 f0       	breq	80007146 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000712a:	49 a8       	lddpc	r8,80007190 <xTaskResumeAll+0xd8>
8000712c:	70 08       	ld.w	r8,r8[0x0]
8000712e:	58 08       	cp.w	r8,0
80007130:	c1 10       	breq	80007152 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80007132:	49 87       	lddpc	r7,80007190 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007134:	f0 1f 00 18 	mcall	80007194 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007138:	6e 08       	ld.w	r8,r7[0x0]
8000713a:	20 18       	sub	r8,1
8000713c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000713e:	6e 08       	ld.w	r8,r7[0x0]
80007140:	58 08       	cp.w	r8,0
80007142:	cf 91       	brne	80007134 <xTaskResumeAll+0x7c>
80007144:	c0 78       	rjmp	80007152 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80007146:	58 14       	cp.w	r4,1
80007148:	c0 50       	breq	80007152 <xTaskResumeAll+0x9a>
8000714a:	49 48       	lddpc	r8,80007198 <xTaskResumeAll+0xe0>
8000714c:	70 08       	ld.w	r8,r8[0x0]
8000714e:	58 18       	cp.w	r8,1
80007150:	c0 71       	brne	8000715e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80007152:	30 09       	mov	r9,0
80007154:	49 18       	lddpc	r8,80007198 <xTaskResumeAll+0xe0>
80007156:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007158:	d7 33       	scall
8000715a:	30 17       	mov	r7,1
8000715c:	c0 28       	rjmp	80007160 <xTaskResumeAll+0xa8>
8000715e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80007160:	f0 1f 00 0f 	mcall	8000719c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007164:	0e 9c       	mov	r12,r7
80007166:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000716a:	00 00       	add	r0,r0
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	65 70       	ld.w	r0,r2[0x5c]
80007170:	00 00       	add	r0,r0
80007172:	0d 84       	ld.ub	r4,r6[0x0]
80007174:	00 00       	add	r0,r0
80007176:	0d a0       	ld.ub	r0,r6[0x2]
80007178:	00 00       	add	r0,r0
8000717a:	0d 58       	ld.sh	r8,--r6
8000717c:	00 00       	add	r0,r0
8000717e:	0d bc       	ld.ub	r12,r6[0x3]
80007180:	00 00       	add	r0,r0
80007182:	0c a0       	st.w	r6++,r0
80007184:	00 00       	add	r0,r0
80007186:	0d 54       	ld.sh	r4,--r6
80007188:	80 00       	ld.sh	r0,r0[0x0]
8000718a:	64 b6       	ld.w	r6,r2[0x2c]
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	64 66       	ld.w	r6,r2[0x18]
80007190:	00 00       	add	r0,r0
80007192:	0c 84       	andn	r4,r6
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	6f 10       	ld.w	r0,r7[0x44]
80007198:	00 00       	add	r0,r0
8000719a:	0d a4       	ld.ub	r4,r6[0x2]
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	66 7c       	ld.w	r12,r3[0x1c]

800071a0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800071a0:	eb cd 40 80 	pushm	r7,lr
800071a4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800071a6:	49 08       	lddpc	r8,800071e4 <prvAddCurrentTaskToDelayedList+0x44>
800071a8:	70 08       	ld.w	r8,r8[0x0]
800071aa:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800071ac:	48 f8       	lddpc	r8,800071e8 <prvAddCurrentTaskToDelayedList+0x48>
800071ae:	70 08       	ld.w	r8,r8[0x0]
800071b0:	10 3c       	cp.w	r12,r8
800071b2:	c0 a2       	brcc	800071c6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800071b4:	48 c8       	lddpc	r8,800071e4 <prvAddCurrentTaskToDelayedList+0x44>
800071b6:	70 0b       	ld.w	r11,r8[0x0]
800071b8:	48 d8       	lddpc	r8,800071ec <prvAddCurrentTaskToDelayedList+0x4c>
800071ba:	70 0c       	ld.w	r12,r8[0x0]
800071bc:	2f cb       	sub	r11,-4
800071be:	f0 1f 00 0d 	mcall	800071f0 <prvAddCurrentTaskToDelayedList+0x50>
800071c2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800071c6:	48 88       	lddpc	r8,800071e4 <prvAddCurrentTaskToDelayedList+0x44>
800071c8:	70 0b       	ld.w	r11,r8[0x0]
800071ca:	48 b8       	lddpc	r8,800071f4 <prvAddCurrentTaskToDelayedList+0x54>
800071cc:	70 0c       	ld.w	r12,r8[0x0]
800071ce:	2f cb       	sub	r11,-4
800071d0:	f0 1f 00 08 	mcall	800071f0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800071d4:	48 98       	lddpc	r8,800071f8 <prvAddCurrentTaskToDelayedList+0x58>
800071d6:	70 08       	ld.w	r8,r8[0x0]
800071d8:	10 37       	cp.w	r7,r8
800071da:	c0 32       	brcc	800071e0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800071dc:	48 78       	lddpc	r8,800071f8 <prvAddCurrentTaskToDelayedList+0x58>
800071de:	91 07       	st.w	r8[0x0],r7
800071e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800071e4:	00 00       	add	r0,r0
800071e6:	0d 54       	ld.sh	r4,--r6
800071e8:	00 00       	add	r0,r0
800071ea:	0d 80       	ld.ub	r0,r6[0x0]
800071ec:	00 00       	add	r0,r0
800071ee:	0c 9c       	mov	r12,r6
800071f0:	80 00       	ld.sh	r0,r0[0x0]
800071f2:	64 82       	ld.w	r2,r2[0x20]
800071f4:	00 00       	add	r0,r0
800071f6:	0c 8c       	andn	r12,r6
800071f8:	00 00       	add	r0,r0
800071fa:	05 48       	ld.w	r8,--r2

800071fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800071fc:	eb cd 40 c0 	pushm	r6-r7,lr
80007200:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80007202:	58 0c       	cp.w	r12,0
80007204:	c1 10       	breq	80007226 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80007206:	f0 1f 00 0a 	mcall	8000722c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000720a:	48 a8       	lddpc	r8,80007230 <vTaskDelay+0x34>
8000720c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000720e:	48 a8       	lddpc	r8,80007234 <vTaskDelay+0x38>
80007210:	70 0c       	ld.w	r12,r8[0x0]
80007212:	2f cc       	sub	r12,-4
80007214:	f0 1f 00 09 	mcall	80007238 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007218:	ee 06 00 0c 	add	r12,r7,r6
8000721c:	f0 1f 00 08 	mcall	8000723c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007220:	f0 1f 00 08 	mcall	80007240 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007224:	c0 21       	brne	80007228 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80007226:	d7 33       	scall
80007228:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	6c fc       	ld.w	r12,r6[0x3c]
80007230:	00 00       	add	r0,r0
80007232:	0d 80       	ld.ub	r0,r6[0x0]
80007234:	00 00       	add	r0,r0
80007236:	0d 54       	ld.sh	r4,--r6
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	64 b6       	ld.w	r6,r2[0x2c]
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	71 a0       	ld.w	r0,r8[0x68]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	70 b8       	ld.w	r8,r8[0x2c]

80007244 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007244:	eb cd 40 c0 	pushm	r6-r7,lr
80007248:	18 96       	mov	r6,r12
8000724a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000724c:	f0 1f 00 18 	mcall	800072ac <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007250:	6c 08       	ld.w	r8,r6[0x0]
80007252:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007254:	49 79       	lddpc	r9,800072b0 <vTaskDelayUntil+0x6c>
80007256:	72 09       	ld.w	r9,r9[0x0]
80007258:	12 38       	cp.w	r8,r9
8000725a:	e0 88 00 0c 	brls	80007272 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000725e:	0e 38       	cp.w	r8,r7
80007260:	e0 88 00 22 	brls	800072a4 <vTaskDelayUntil+0x60>
80007264:	49 38       	lddpc	r8,800072b0 <vTaskDelayUntil+0x6c>
80007266:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007268:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000726a:	10 37       	cp.w	r7,r8
8000726c:	e0 88 00 14 	brls	80007294 <vTaskDelayUntil+0x50>
80007270:	c0 a8       	rjmp	80007284 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007272:	0e 38       	cp.w	r8,r7
80007274:	e0 8b 00 16 	brhi	800072a0 <vTaskDelayUntil+0x5c>
80007278:	48 e8       	lddpc	r8,800072b0 <vTaskDelayUntil+0x6c>
8000727a:	70 08       	ld.w	r8,r8[0x0]
8000727c:	10 37       	cp.w	r7,r8
8000727e:	e0 8b 00 11 	brhi	800072a0 <vTaskDelayUntil+0x5c>
80007282:	c1 18       	rjmp	800072a4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007284:	48 c8       	lddpc	r8,800072b4 <vTaskDelayUntil+0x70>
80007286:	70 0c       	ld.w	r12,r8[0x0]
80007288:	2f cc       	sub	r12,-4
8000728a:	f0 1f 00 0c 	mcall	800072b8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000728e:	0e 9c       	mov	r12,r7
80007290:	f0 1f 00 0b 	mcall	800072bc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007294:	f0 1f 00 0b 	mcall	800072c0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007298:	c0 81       	brne	800072a8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000729a:	d7 33       	scall
8000729c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800072a0:	8d 07       	st.w	r6[0x0],r7
800072a2:	cf 1b       	rjmp	80007284 <vTaskDelayUntil+0x40>
800072a4:	8d 07       	st.w	r6[0x0],r7
800072a6:	cf 7b       	rjmp	80007294 <vTaskDelayUntil+0x50>
800072a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6c fc       	ld.w	r12,r6[0x3c]
800072b0:	00 00       	add	r0,r0
800072b2:	0d 80       	ld.ub	r0,r6[0x0]
800072b4:	00 00       	add	r0,r0
800072b6:	0d 54       	ld.sh	r4,--r6
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	64 b6       	ld.w	r6,r2[0x2c]
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	71 a0       	ld.w	r0,r8[0x68]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	70 b8       	ld.w	r8,r8[0x2c]

800072c4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800072c4:	eb cd 40 c0 	pushm	r6-r7,lr
800072c8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800072ca:	48 e7       	lddpc	r7,80007300 <vTaskPlaceOnEventList+0x3c>
800072cc:	6e 0b       	ld.w	r11,r7[0x0]
800072ce:	2e 8b       	sub	r11,-24
800072d0:	f0 1f 00 0d 	mcall	80007304 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800072d4:	6e 0c       	ld.w	r12,r7[0x0]
800072d6:	2f cc       	sub	r12,-4
800072d8:	f0 1f 00 0c 	mcall	80007308 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800072dc:	5b f6       	cp.w	r6,-1
800072de:	c0 81       	brne	800072ee <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800072e0:	6e 0b       	ld.w	r11,r7[0x0]
800072e2:	2f cb       	sub	r11,-4
800072e4:	48 ac       	lddpc	r12,8000730c <vTaskPlaceOnEventList+0x48>
800072e6:	f0 1f 00 0b 	mcall	80007310 <vTaskPlaceOnEventList+0x4c>
800072ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800072ee:	48 a8       	lddpc	r8,80007314 <vTaskPlaceOnEventList+0x50>
800072f0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800072f2:	ec 0c 00 0c 	add	r12,r6,r12
800072f6:	f0 1f 00 09 	mcall	80007318 <vTaskPlaceOnEventList+0x54>
800072fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800072fe:	00 00       	add	r0,r0
80007300:	00 00       	add	r0,r0
80007302:	0d 54       	ld.sh	r4,--r6
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	64 82       	ld.w	r2,r2[0x20]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	64 b6       	ld.w	r6,r2[0x2c]
8000730c:	00 00       	add	r0,r0
8000730e:	0d a8       	ld.ub	r8,r6[0x2]
80007310:	80 00       	ld.sh	r0,r0[0x0]
80007312:	64 66       	ld.w	r6,r2[0x18]
80007314:	00 00       	add	r0,r0
80007316:	0d 80       	ld.ub	r0,r6[0x0]
80007318:	80 00       	ld.sh	r0,r0[0x0]
8000731a:	71 a0       	ld.w	r0,r8[0x68]

8000731c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000731c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007320:	49 67       	lddpc	r7,80007378 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007322:	49 74       	lddpc	r4,8000737c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007324:	49 73       	lddpc	r3,80007380 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007326:	49 85       	lddpc	r5,80007384 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007328:	6e 08       	ld.w	r8,r7[0x0]
8000732a:	58 08       	cp.w	r8,0
8000732c:	c1 e0       	breq	80007368 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000732e:	f0 1f 00 17 	mcall	80007388 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007332:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007334:	f0 1f 00 16 	mcall	8000738c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007338:	58 06       	cp.w	r6,0
8000733a:	c1 70       	breq	80007368 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000733c:	f0 1f 00 15 	mcall	80007390 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007340:	68 38       	ld.w	r8,r4[0xc]
80007342:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007344:	ec cc ff fc 	sub	r12,r6,-4
80007348:	f0 1f 00 13 	mcall	80007394 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000734c:	66 08       	ld.w	r8,r3[0x0]
8000734e:	20 18       	sub	r8,1
80007350:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007352:	6e 08       	ld.w	r8,r7[0x0]
80007354:	20 18       	sub	r8,1
80007356:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007358:	f0 1f 00 10 	mcall	80007398 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000735c:	6c cc       	ld.w	r12,r6[0x30]
8000735e:	f0 1f 00 10 	mcall	8000739c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007362:	0c 9c       	mov	r12,r6
80007364:	f0 1f 00 0e 	mcall	8000739c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007368:	6a 08       	ld.w	r8,r5[0x0]
8000736a:	58 18       	cp.w	r8,1
8000736c:	e0 88 00 03 	brls	80007372 <prvIdleTask+0x56>
			{
				taskYIELD();
80007370:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007372:	f0 1f 00 0c 	mcall	800073a0 <prvIdleTask+0x84>
		}
		#endif
	}
80007376:	cd 9b       	rjmp	80007328 <prvIdleTask+0xc>
80007378:	00 00       	add	r0,r0
8000737a:	0c 94       	mov	r4,r6
8000737c:	00 00       	add	r0,r0
8000737e:	0d 40       	ld.w	r0,--r6
80007380:	00 00       	add	r0,r0
80007382:	0d a0       	ld.ub	r0,r6[0x2]
80007384:	00 00       	add	r0,r0
80007386:	0c a0       	st.w	r6++,r0
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	6c fc       	ld.w	r12,r6[0x3c]
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	70 b8       	ld.w	r8,r8[0x2c]
80007390:	80 00       	ld.sh	r0,r0[0x0]
80007392:	65 70       	ld.w	r0,r2[0x5c]
80007394:	80 00       	ld.sh	r0,r0[0x0]
80007396:	64 b6       	ld.w	r6,r2[0x2c]
80007398:	80 00       	ld.sh	r0,r0[0x0]
8000739a:	66 7c       	ld.w	r12,r3[0x1c]
8000739c:	80 00       	ld.sh	r0,r0[0x0]
8000739e:	67 b4       	ld.w	r4,r3[0x6c]
800073a0:	80 00       	ld.sh	r0,r0[0x0]
800073a2:	20 2c       	sub	r12,2

800073a4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800073a4:	d4 31       	pushm	r0-r7,lr
800073a6:	20 1d       	sub	sp,4
800073a8:	fa c4 ff d8 	sub	r4,sp,-40
800073ac:	50 0c       	stdsp	sp[0x0],r12
800073ae:	16 91       	mov	r1,r11
800073b0:	14 97       	mov	r7,r10
800073b2:	12 90       	mov	r0,r9
800073b4:	10 93       	mov	r3,r8
800073b6:	68 02       	ld.w	r2,r4[0x0]
800073b8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800073ba:	34 8c       	mov	r12,72
800073bc:	f0 1f 00 5c 	mcall	8000752c <xTaskGenericCreate+0x188>
800073c0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800073c2:	c0 31       	brne	800073c8 <xTaskGenericCreate+0x24>
800073c4:	3f fc       	mov	r12,-1
800073c6:	ca f8       	rjmp	80007524 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800073c8:	58 06       	cp.w	r6,0
800073ca:	e0 81 00 af 	brne	80007528 <xTaskGenericCreate+0x184>
800073ce:	0e 9c       	mov	r12,r7
800073d0:	5c 7c       	castu.h	r12
800073d2:	a3 6c       	lsl	r12,0x2
800073d4:	f0 1f 00 56 	mcall	8000752c <xTaskGenericCreate+0x188>
800073d8:	18 96       	mov	r6,r12
800073da:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800073dc:	c0 61       	brne	800073e8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800073de:	0a 9c       	mov	r12,r5
800073e0:	f0 1f 00 54 	mcall	80007530 <xTaskGenericCreate+0x18c>
800073e4:	3f fc       	mov	r12,-1
800073e6:	c9 f8       	rjmp	80007524 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800073e8:	5c 77       	castu.h	r7
800073ea:	ee 0a 15 02 	lsl	r10,r7,0x2
800073ee:	e0 6b 00 a5 	mov	r11,165
800073f2:	0c 9c       	mov	r12,r6
800073f4:	f0 1f 00 50 	mcall	80007534 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800073f8:	ee c6 00 01 	sub	r6,r7,1
800073fc:	6a c8       	ld.w	r8,r5[0x30]
800073fe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007402:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007406:	31 0a       	mov	r10,16
80007408:	02 9b       	mov	r11,r1
8000740a:	ea cc ff cc 	sub	r12,r5,-52
8000740e:	f0 1f 00 4b 	mcall	80007538 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007412:	30 08       	mov	r8,0
80007414:	eb 68 00 43 	st.b	r5[67],r8
80007418:	58 73       	cp.w	r3,7
8000741a:	e6 07 17 80 	movls	r7,r3
8000741e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007422:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007424:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007428:	ea c4 ff fc 	sub	r4,r5,-4
8000742c:	08 9c       	mov	r12,r4
8000742e:	f0 1f 00 44 	mcall	8000753c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007432:	ea cc ff e8 	sub	r12,r5,-24
80007436:	f0 1f 00 42 	mcall	8000753c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000743a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000743c:	ee 07 11 08 	rsub	r7,r7,8
80007440:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007442:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007444:	00 9a       	mov	r10,r0
80007446:	40 0b       	lddsp	r11,sp[0x0]
80007448:	0c 9c       	mov	r12,r6
8000744a:	f0 1f 00 3e 	mcall	80007540 <xTaskGenericCreate+0x19c>
8000744e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007450:	58 02       	cp.w	r2,0
80007452:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007456:	f0 1f 00 3c 	mcall	80007544 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000745a:	4b c8       	lddpc	r8,80007548 <xTaskGenericCreate+0x1a4>
8000745c:	70 09       	ld.w	r9,r8[0x0]
8000745e:	2f f9       	sub	r9,-1
80007460:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007462:	4b b8       	lddpc	r8,8000754c <xTaskGenericCreate+0x1a8>
80007464:	70 08       	ld.w	r8,r8[0x0]
80007466:	58 08       	cp.w	r8,0
80007468:	c2 61       	brne	800074b4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000746a:	4b 98       	lddpc	r8,8000754c <xTaskGenericCreate+0x1a8>
8000746c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000746e:	4b 78       	lddpc	r8,80007548 <xTaskGenericCreate+0x1a4>
80007470:	70 08       	ld.w	r8,r8[0x0]
80007472:	58 18       	cp.w	r8,1
80007474:	c2 b1       	brne	800074ca <xTaskGenericCreate+0x126>
80007476:	4b 77       	lddpc	r7,80007550 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007478:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000747c:	0e 9c       	mov	r12,r7
8000747e:	f0 1f 00 36 	mcall	80007554 <xTaskGenericCreate+0x1b0>
80007482:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007484:	0c 37       	cp.w	r7,r6
80007486:	cf b1       	brne	8000747c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007488:	4b 47       	lddpc	r7,80007558 <xTaskGenericCreate+0x1b4>
8000748a:	0e 9c       	mov	r12,r7
8000748c:	f0 1f 00 32 	mcall	80007554 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007490:	4b 36       	lddpc	r6,8000755c <xTaskGenericCreate+0x1b8>
80007492:	0c 9c       	mov	r12,r6
80007494:	f0 1f 00 30 	mcall	80007554 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007498:	4b 2c       	lddpc	r12,80007560 <xTaskGenericCreate+0x1bc>
8000749a:	f0 1f 00 2f 	mcall	80007554 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000749e:	4b 2c       	lddpc	r12,80007564 <xTaskGenericCreate+0x1c0>
800074a0:	f0 1f 00 2d 	mcall	80007554 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800074a4:	4b 1c       	lddpc	r12,80007568 <xTaskGenericCreate+0x1c4>
800074a6:	f0 1f 00 2c 	mcall	80007554 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800074aa:	4b 18       	lddpc	r8,8000756c <xTaskGenericCreate+0x1c8>
800074ac:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800074ae:	4b 18       	lddpc	r8,80007570 <xTaskGenericCreate+0x1cc>
800074b0:	91 06       	st.w	r8[0x0],r6
800074b2:	c0 c8       	rjmp	800074ca <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800074b4:	4b 08       	lddpc	r8,80007574 <xTaskGenericCreate+0x1d0>
800074b6:	70 08       	ld.w	r8,r8[0x0]
800074b8:	58 08       	cp.w	r8,0
800074ba:	c0 81       	brne	800074ca <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800074bc:	4a 48       	lddpc	r8,8000754c <xTaskGenericCreate+0x1a8>
800074be:	70 08       	ld.w	r8,r8[0x0]
800074c0:	70 b8       	ld.w	r8,r8[0x2c]
800074c2:	10 33       	cp.w	r3,r8
800074c4:	c0 33       	brcs	800074ca <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800074c6:	4a 28       	lddpc	r8,8000754c <xTaskGenericCreate+0x1a8>
800074c8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800074ca:	6a b8       	ld.w	r8,r5[0x2c]
800074cc:	4a b9       	lddpc	r9,80007578 <xTaskGenericCreate+0x1d4>
800074ce:	72 09       	ld.w	r9,r9[0x0]
800074d0:	12 38       	cp.w	r8,r9
800074d2:	e0 88 00 04 	brls	800074da <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800074d6:	4a 99       	lddpc	r9,80007578 <xTaskGenericCreate+0x1d4>
800074d8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800074da:	4a 98       	lddpc	r8,8000757c <xTaskGenericCreate+0x1d8>
800074dc:	70 09       	ld.w	r9,r8[0x0]
800074de:	2f f9       	sub	r9,-1
800074e0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800074e2:	6a b8       	ld.w	r8,r5[0x2c]
800074e4:	4a 79       	lddpc	r9,80007580 <xTaskGenericCreate+0x1dc>
800074e6:	72 09       	ld.w	r9,r9[0x0]
800074e8:	12 38       	cp.w	r8,r9
800074ea:	e0 88 00 04 	brls	800074f2 <xTaskGenericCreate+0x14e>
800074ee:	4a 59       	lddpc	r9,80007580 <xTaskGenericCreate+0x1dc>
800074f0:	93 08       	st.w	r9[0x0],r8
800074f2:	6a bc       	ld.w	r12,r5[0x2c]
800074f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800074f8:	08 9b       	mov	r11,r4
800074fa:	49 68       	lddpc	r8,80007550 <xTaskGenericCreate+0x1ac>
800074fc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007500:	f0 1f 00 21 	mcall	80007584 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007504:	f0 1f 00 21 	mcall	80007588 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007508:	49 b8       	lddpc	r8,80007574 <xTaskGenericCreate+0x1d0>
8000750a:	70 08       	ld.w	r8,r8[0x0]
8000750c:	58 08       	cp.w	r8,0
8000750e:	c0 a0       	breq	80007522 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007510:	48 f8       	lddpc	r8,8000754c <xTaskGenericCreate+0x1a8>
80007512:	70 08       	ld.w	r8,r8[0x0]
80007514:	70 b8       	ld.w	r8,r8[0x2c]
80007516:	10 33       	cp.w	r3,r8
80007518:	e0 88 00 05 	brls	80007522 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
8000751c:	d7 33       	scall
8000751e:	30 1c       	mov	r12,1
80007520:	c0 28       	rjmp	80007524 <xTaskGenericCreate+0x180>
80007522:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007524:	2f fd       	sub	sp,-4
80007526:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007528:	99 c6       	st.w	r12[0x30],r6
8000752a:	c5 fb       	rjmp	800073e8 <xTaskGenericCreate+0x44>
8000752c:	80 00       	ld.sh	r0,r0[0x0]
8000752e:	67 dc       	ld.w	r12,r3[0x74]
80007530:	80 00       	ld.sh	r0,r0[0x0]
80007532:	67 b4       	ld.w	r4,r3[0x6c]
80007534:	80 00       	ld.sh	r0,r0[0x0]
80007536:	81 5e       	st.w	r0[0x14],lr
80007538:	80 00       	ld.sh	r0,r0[0x0]
8000753a:	84 88       	ld.uh	r8,r2[0x0]
8000753c:	80 00       	ld.sh	r0,r0[0x0]
8000753e:	64 60       	ld.w	r0,r2[0x18]
80007540:	80 00       	ld.sh	r0,r0[0x0]
80007542:	64 dc       	ld.w	r12,r2[0x34]
80007544:	80 00       	ld.sh	r0,r0[0x0]
80007546:	65 70       	ld.w	r0,r2[0x5c]
80007548:	00 00       	add	r0,r0
8000754a:	0d a0       	ld.ub	r0,r6[0x2]
8000754c:	00 00       	add	r0,r0
8000754e:	0d 54       	ld.sh	r4,--r6
80007550:	00 00       	add	r0,r0
80007552:	0c a0       	st.w	r6++,r0
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	64 4c       	ld.w	r12,r2[0x10]
80007558:	00 00       	add	r0,r0
8000755a:	0d 6c       	ld.uh	r12,--r6
8000755c:	00 00       	add	r0,r0
8000755e:	0d 88       	ld.ub	r8,r6[0x0]
80007560:	00 00       	add	r0,r0
80007562:	0d 58       	ld.sh	r8,--r6
80007564:	00 00       	add	r0,r0
80007566:	0d 40       	ld.w	r0,--r6
80007568:	00 00       	add	r0,r0
8000756a:	0d a8       	ld.ub	r8,r6[0x2]
8000756c:	00 00       	add	r0,r0
8000756e:	0c 8c       	andn	r12,r6
80007570:	00 00       	add	r0,r0
80007572:	0c 9c       	mov	r12,r6
80007574:	00 00       	add	r0,r0
80007576:	0c 90       	mov	r0,r6
80007578:	00 00       	add	r0,r0
8000757a:	0c 88       	andn	r8,r6
8000757c:	00 00       	add	r0,r0
8000757e:	0d 9c       	ld.ub	r12,r6[0x1]
80007580:	00 00       	add	r0,r0
80007582:	0d bc       	ld.ub	r12,r6[0x3]
80007584:	80 00       	ld.sh	r0,r0[0x0]
80007586:	64 66       	ld.w	r6,r2[0x18]
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	66 7c       	ld.w	r12,r3[0x1c]

8000758c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000758c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000758e:	30 09       	mov	r9,0
80007590:	1a d9       	st.w	--sp,r9
80007592:	1a d9       	st.w	--sp,r9
80007594:	1a d9       	st.w	--sp,r9
80007596:	12 98       	mov	r8,r9
80007598:	e0 6a 01 00 	mov	r10,256
8000759c:	48 9b       	lddpc	r11,800075c0 <vTaskStartScheduler+0x34>
8000759e:	48 ac       	lddpc	r12,800075c4 <vTaskStartScheduler+0x38>
800075a0:	f0 1f 00 0a 	mcall	800075c8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800075a4:	2f dd       	sub	sp,-12
800075a6:	58 1c       	cp.w	r12,1
800075a8:	c0 a1       	brne	800075bc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800075aa:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800075ac:	30 19       	mov	r9,1
800075ae:	48 88       	lddpc	r8,800075cc <vTaskStartScheduler+0x40>
800075b0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800075b2:	30 09       	mov	r9,0
800075b4:	48 78       	lddpc	r8,800075d0 <vTaskStartScheduler+0x44>
800075b6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800075b8:	f0 1f 00 07 	mcall	800075d4 <vTaskStartScheduler+0x48>
800075bc:	d8 02       	popm	pc
800075be:	00 00       	add	r0,r0
800075c0:	80 00       	ld.sh	r0,r0[0x0]
800075c2:	e2 b8       	*unknown*
800075c4:	80 00       	ld.sh	r0,r0[0x0]
800075c6:	73 1c       	ld.w	r12,r9[0x44]
800075c8:	80 00       	ld.sh	r0,r0[0x0]
800075ca:	73 a4       	ld.w	r4,r9[0x68]
800075cc:	00 00       	add	r0,r0
800075ce:	0c 90       	mov	r0,r6
800075d0:	00 00       	add	r0,r0
800075d2:	0d 80       	ld.ub	r0,r6[0x0]
800075d4:	80 00       	ld.sh	r0,r0[0x0]
800075d6:	65 80       	ld.w	r0,r2[0x60]

800075d8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800075d8:	16 cc       	st.b	r11++,r12
	return str;
}
800075da:	5e fb       	retal	r11

800075dc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800075dc:	eb cd 40 c0 	pushm	r6-r7,lr
800075e0:	20 3d       	sub	sp,12
800075e2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800075e4:	30 06       	mov	r6,0
800075e6:	30 07       	mov	r7,0
800075e8:	fa e7 00 00 	st.d	sp[0],r6
800075ec:	30 0c       	mov	r12,0
800075ee:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800075f0:	58 08       	cp.w	r8,0
800075f2:	c1 30       	breq	80007618 <PrintHex+0x3c>
800075f4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800075f6:	1a 9c       	mov	r12,sp
800075f8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800075fc:	58 9e       	cp.w	lr,9
800075fe:	e0 8a 00 04 	brle	80007606 <PrintHex+0x2a>
80007602:	2c 9e       	sub	lr,-55
80007604:	c0 48       	rjmp	8000760c <PrintHex+0x30>
80007606:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000760a:	2d 0e       	sub	lr,-48
8000760c:	f8 09 0b 0e 	st.b	r12[r9],lr
80007610:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007612:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007614:	cf 21       	brne	800075f8 <PrintHex+0x1c>
80007616:	c0 48       	rjmp	8000761e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007618:	33 08       	mov	r8,48
8000761a:	ba 88       	st.b	sp[0x0],r8
8000761c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000761e:	f6 09 01 08 	sub	r8,r11,r9
80007622:	58 08       	cp.w	r8,0
80007624:	e0 8a 00 13 	brle	8000764a <PrintHex+0x6e>
	{
		char num = len - cnt;
80007628:	12 1b       	sub	r11,r9
8000762a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000762e:	18 9e       	mov	lr,r12
80007630:	58 0c       	cp.w	r12,0
80007632:	e0 8a 00 0c 	brle	8000764a <PrintHex+0x6e>
80007636:	1a 9b       	mov	r11,sp
80007638:	12 0b       	add	r11,r9
8000763a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000763c:	33 07       	mov	r7,48
8000763e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007640:	2f f8       	sub	r8,-1
80007642:	1c 38       	cp.w	r8,lr
80007644:	cf d5       	brlt	8000763e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007646:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000764a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000764e:	f0 cb ff ff 	sub	r11,r8,-1
80007652:	58 0b       	cp.w	r11,0
80007654:	e0 8a 00 19 	brle	80007686 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007658:	fa cb ff f4 	sub	r11,sp,-12
8000765c:	f6 09 00 09 	add	r9,r11,r9
80007660:	37 8b       	mov	r11,120
80007662:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007666:	fa c9 ff f4 	sub	r9,sp,-12
8000766a:	10 09       	add	r9,r8
8000766c:	33 0b       	mov	r11,48
8000766e:	f3 6b ff f4 	st.b	r9[-12],r11
80007672:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007676:	fa ce 00 01 	sub	lr,sp,1
8000767a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000767c:	11 8b       	ld.ub	r11,r8[0x0]
8000767e:	12 cb       	st.b	r9++,r11
80007680:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007682:	1c 38       	cp.w	r8,lr
80007684:	cf c1       	brne	8000767c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007686:	14 9c       	mov	r12,r10
80007688:	2f dd       	sub	sp,-12
8000768a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000768e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000768e:	d4 21       	pushm	r4-r7,lr
80007690:	20 3d       	sub	sp,12
80007692:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007694:	30 06       	mov	r6,0
80007696:	30 07       	mov	r7,0
80007698:	fa e7 00 00 	st.d	sp[0],r6
8000769c:	30 0c       	mov	r12,0
8000769e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800076a0:	58 08       	cp.w	r8,0
800076a2:	c0 35       	brlt	800076a8 <PrintDec+0x1a>
800076a4:	14 97       	mov	r7,r10
800076a6:	c0 58       	rjmp	800076b0 <PrintDec+0x22>
	{
		*p++ = '-';
800076a8:	14 97       	mov	r7,r10
800076aa:	32 d9       	mov	r9,45
800076ac:	0e c9       	st.b	r7++,r9
		i = -i;
800076ae:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800076b0:	58 08       	cp.w	r8,0
800076b2:	c0 51       	brne	800076bc <PrintDec+0x2e>
800076b4:	33 08       	mov	r8,48
800076b6:	ba 88       	st.b	sp[0x0],r8
800076b8:	30 1e       	mov	lr,1
800076ba:	c2 f8       	rjmp	80007718 <PrintDec+0x8a>
	
	int ten = i%10;
800076bc:	e0 65 66 67 	mov	r5,26215
800076c0:	ea 15 66 66 	orh	r5,0x6666
800076c4:	f0 05 04 44 	muls.d	r4,r8,r5
800076c8:	ea 0c 14 02 	asr	r12,r5,0x2
800076cc:	f0 09 14 1f 	asr	r9,r8,0x1f
800076d0:	f8 09 01 09 	sub	r9,r12,r9
800076d4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800076d8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800076dc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800076de:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800076e0:	e0 66 66 67 	mov	r6,26215
800076e4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800076e8:	2d 09       	sub	r9,-48
800076ea:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800076ee:	2f fe       	sub	lr,-1
		i /= 10;
800076f0:	f0 06 04 44 	muls.d	r4,r8,r6
800076f4:	ea 09 14 02 	asr	r9,r5,0x2
800076f8:	bf 58       	asr	r8,0x1f
800076fa:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800076fe:	f0 06 04 44 	muls.d	r4,r8,r6
80007702:	ea 09 14 02 	asr	r9,r5,0x2
80007706:	f0 05 14 1f 	asr	r5,r8,0x1f
8000770a:	0a 19       	sub	r9,r5
8000770c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007710:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007714:	58 08       	cp.w	r8,0
80007716:	ce 91       	brne	800076e8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007718:	f6 0e 01 08 	sub	r8,r11,lr
8000771c:	58 08       	cp.w	r8,0
8000771e:	e0 89 00 06 	brgt	8000772a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007722:	58 0e       	cp.w	lr,0
80007724:	e0 89 00 14 	brgt	8000774c <PrintDec+0xbe>
80007728:	c1 d8       	rjmp	80007762 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000772a:	1c 1b       	sub	r11,lr
8000772c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000772e:	16 9c       	mov	r12,r11
80007730:	58 0b       	cp.w	r11,0
80007732:	fe 9a ff f8 	brle	80007722 <PrintDec+0x94>
80007736:	1a 99       	mov	r9,sp
80007738:	1c 09       	add	r9,lr
8000773a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000773c:	33 06       	mov	r6,48
8000773e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007740:	2f f8       	sub	r8,-1
80007742:	18 38       	cp.w	r8,r12
80007744:	cf d5       	brlt	8000773e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007746:	f6 0e 00 0e 	add	lr,r11,lr
8000774a:	ce cb       	rjmp	80007722 <PrintDec+0x94>
8000774c:	fa c8 ff f4 	sub	r8,sp,-12
80007750:	1c 08       	add	r8,lr
80007752:	20 d8       	sub	r8,13
80007754:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007758:	11 89       	ld.ub	r9,r8[0x0]
8000775a:	0e c9       	st.b	r7++,r9
8000775c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000775e:	16 38       	cp.w	r8,r11
80007760:	cf c1       	brne	80007758 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007762:	14 9c       	mov	r12,r10
80007764:	2f dd       	sub	sp,-12
80007766:	d8 22       	popm	r4-r7,pc

80007768 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007768:	d4 31       	pushm	r0-r7,lr
8000776a:	fa cd 02 08 	sub	sp,sp,520
8000776e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007770:	e0 6a 01 00 	mov	r10,256
80007774:	30 0b       	mov	r11,0
80007776:	fa cc fe f8 	sub	r12,sp,-264
8000777a:	f0 1f 00 4e 	mcall	800078b0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000777e:	fa c4 fd d4 	sub	r4,sp,-556
80007782:	30 0a       	mov	r10,0
80007784:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007786:	fa c3 ff fc 	sub	r3,sp,-4
8000778a:	e0 61 01 00 	mov	r1,256
8000778e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007790:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007792:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007796:	02 9a       	mov	r10,r1
80007798:	00 9b       	mov	r11,r0
8000779a:	06 9c       	mov	r12,r3
8000779c:	f0 1f 00 45 	mcall	800078b0 <log+0x148>
			
					if(*str == '%')
800077a0:	0f 88       	ld.ub	r8,r7[0x0]
800077a2:	e4 08 18 00 	cp.b	r8,r2
800077a6:	c5 71       	brne	80007854 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800077a8:	ee c8 ff ff 	sub	r8,r7,-1
800077ac:	11 89       	ld.ub	r9,r8[0x0]
800077ae:	4c 2a       	lddpc	r10,800078b4 <log+0x14c>
800077b0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800077b2:	23 09       	sub	r9,48
800077b4:	30 9a       	mov	r10,9
800077b6:	f4 09 18 00 	cp.b	r9,r10
800077ba:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800077be:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800077c2:	f7 b9 08 30 	subls	r9,48
800077c6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800077ca:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800077ce:	0f 88       	ld.ub	r8,r7[0x0]
800077d0:	22 58       	sub	r8,37
800077d2:	e0 48 00 53 	cp.w	r8,83
800077d6:	e0 8b 00 31 	brhi	80007838 <log+0xd0>
800077da:	4b 89       	lddpc	r9,800078b8 <log+0x150>
800077dc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800077e0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800077e4:	06 9a       	mov	r10,r3
800077e6:	40 0b       	lddsp	r11,sp[0x0]
800077e8:	5c 5b       	castu.b	r11
800077ea:	68 0c       	ld.w	r12,r4[0x0]
800077ec:	f0 1f 00 34 	mcall	800078bc <log+0x154>
							break;
800077f0:	c2 98       	rjmp	80007842 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800077f2:	4b 4c       	lddpc	r12,800078c0 <log+0x158>
800077f4:	f0 1f 00 34 	mcall	800078c4 <log+0x15c>
800077f8:	08 95       	mov	r5,r4
800077fa:	06 9c       	mov	r12,r3
							break;
800077fc:	c2 38       	rjmp	80007842 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800077fe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007802:	06 9a       	mov	r10,r3
80007804:	40 0b       	lddsp	r11,sp[0x0]
80007806:	5c 5b       	castu.b	r11
80007808:	68 0c       	ld.w	r12,r4[0x0]
8000780a:	f0 1f 00 30 	mcall	800078c8 <log+0x160>
8000780e:	06 9c       	mov	r12,r3
							break;
80007810:	c1 98       	rjmp	80007842 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007812:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007816:	06 9b       	mov	r11,r3
80007818:	09 bc       	ld.ub	r12,r4[0x3]
8000781a:	f0 1f 00 2d 	mcall	800078cc <log+0x164>
8000781e:	06 9c       	mov	r12,r3
							break;
80007820:	c1 18       	rjmp	80007842 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007822:	e8 c5 ff fc 	sub	r5,r4,-4
80007826:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007828:	c0 d8       	rjmp	80007842 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000782a:	06 9b       	mov	r11,r3
8000782c:	32 5c       	mov	r12,37
8000782e:	f0 1f 00 28 	mcall	800078cc <log+0x164>
80007832:	08 95       	mov	r5,r4
80007834:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007836:	c0 68       	rjmp	80007842 <log+0xda>
							
							default:
							log("I need relax.");
80007838:	4a 6c       	lddpc	r12,800078d0 <log+0x168>
8000783a:	f0 1f 00 23 	mcall	800078c4 <log+0x15c>
8000783e:	08 95       	mov	r5,r4
80007840:	06 9c       	mov	r12,r3
						}
						str++;
80007842:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007844:	1a dc       	st.w	--sp,r12
80007846:	1a d6       	st.w	--sp,r6
80007848:	4a 3b       	lddpc	r11,800078d4 <log+0x16c>
8000784a:	0c 9c       	mov	r12,r6
8000784c:	f0 1f 00 23 	mcall	800078d8 <log+0x170>
80007850:	2f ed       	sub	sp,-8
80007852:	c0 a8       	rjmp	80007866 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007854:	2f f7       	sub	r7,-1
80007856:	1a d8       	st.w	--sp,r8
80007858:	1a d6       	st.w	--sp,r6
8000785a:	4a 1b       	lddpc	r11,800078dc <log+0x174>
8000785c:	0c 9c       	mov	r12,r6
8000785e:	f0 1f 00 1f 	mcall	800078d8 <log+0x170>
80007862:	08 95       	mov	r5,r4
80007864:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007866:	0f 89       	ld.ub	r9,r7[0x0]
80007868:	30 08       	mov	r8,0
8000786a:	f0 09 18 00 	cp.b	r9,r8
8000786e:	c0 30       	breq	80007874 <log+0x10c>
80007870:	0a 94       	mov	r4,r5
80007872:	c9 2b       	rjmp	80007796 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007874:	fa c7 fe f8 	sub	r7,sp,-264
80007878:	1a d7       	st.w	--sp,r7
8000787a:	49 ab       	lddpc	r11,800078e0 <log+0x178>
8000787c:	0e 9c       	mov	r12,r7
8000787e:	f0 1f 00 17 	mcall	800078d8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007882:	5c 5c       	castu.b	r12
80007884:	f8 c6 ff ff 	sub	r6,r12,-1
80007888:	0c 9c       	mov	r12,r6
8000788a:	f0 1f 00 17 	mcall	800078e4 <log+0x17c>
8000788e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007890:	0c 9a       	mov	r10,r6
80007892:	0e 9b       	mov	r11,r7
80007894:	f0 1f 00 15 	mcall	800078e8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007898:	30 09       	mov	r9,0
8000789a:	30 5a       	mov	r10,5
8000789c:	fa cb fe f8 	sub	r11,sp,-264
800078a0:	49 38       	lddpc	r8,800078ec <log+0x184>
800078a2:	70 0c       	ld.w	r12,r8[0x0]
800078a4:	f0 1f 00 13 	mcall	800078f0 <log+0x188>
800078a8:	2f fd       	sub	sp,-4
	
	
}
800078aa:	fe 3d fd f8 	sub	sp,-520
800078ae:	d8 32       	popm	r0-r7,pc
800078b0:	80 00       	ld.sh	r0,r0[0x0]
800078b2:	81 5e       	st.w	r0[0x14],lr
800078b4:	00 00       	add	r0,r0
800078b6:	0d c0       	ld.ub	r0,r6[0x4]
800078b8:	80 00       	ld.sh	r0,r0[0x0]
800078ba:	e2 c0 80 00 	sub	r0,r1,-32768
800078be:	76 8e       	ld.w	lr,r11[0x20]
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	e5 6c 80 00 	st.b	r2[-32768],r12
800078c6:	77 68       	ld.w	r8,r11[0x58]
800078c8:	80 00       	ld.sh	r0,r0[0x0]
800078ca:	75 dc       	ld.w	r12,r10[0x74]
800078cc:	80 00       	ld.sh	r0,r0[0x0]
800078ce:	75 d8       	ld.w	r8,r10[0x74]
800078d0:	80 00       	ld.sh	r0,r0[0x0]
800078d2:	e5 7c 80 00 	stcond	r2[-32768],r12
800078d6:	e5 8c       	*unknown*
800078d8:	80 00       	ld.sh	r0,r0[0x0]
800078da:	84 4c       	ld.sh	r12,r2[0x8]
800078dc:	80 00       	ld.sh	r0,r0[0x0]
800078de:	e5 94       	*unknown*
800078e0:	80 00       	ld.sh	r0,r0[0x0]
800078e2:	e5 9c       	*unknown*
800078e4:	80 00       	ld.sh	r0,r0[0x0]
800078e6:	67 dc       	ld.w	r12,r3[0x74]
800078e8:	80 00       	ld.sh	r0,r0[0x0]
800078ea:	80 16       	ld.sh	r6,r0[0x2]
800078ec:	00 00       	add	r0,r0
800078ee:	54 20       	stdsp	sp[0x108],r0
800078f0:	80 00       	ld.sh	r0,r0[0x0]
800078f2:	6b 30       	ld.w	r0,r5[0x4c]

800078f4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800078f4:	d4 31       	pushm	r0-r7,lr
800078f6:	fa cd 02 0c 	sub	sp,sp,524
800078fa:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800078fc:	e0 6a 01 00 	mov	r10,256
80007900:	30 0b       	mov	r11,0
80007902:	fa cc fe f4 	sub	r12,sp,-268
80007906:	f0 1f 00 4c 	mcall	80007a34 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000790a:	fa c4 fd d0 	sub	r4,sp,-560
8000790e:	30 0a       	mov	r10,0
80007910:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007912:	fa c3 ff fc 	sub	r3,sp,-4
80007916:	e0 61 01 00 	mov	r1,256
8000791a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000791c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000791e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007922:	02 9a       	mov	r10,r1
80007924:	00 9b       	mov	r11,r0
80007926:	06 9c       	mov	r12,r3
80007928:	f0 1f 00 43 	mcall	80007a34 <logFromISR+0x140>
			
			if(*str == '%')
8000792c:	0f 88       	ld.ub	r8,r7[0x0]
8000792e:	e4 08 18 00 	cp.b	r8,r2
80007932:	c5 11       	brne	800079d4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007934:	ee c8 ff ff 	sub	r8,r7,-1
80007938:	11 89       	ld.ub	r9,r8[0x0]
8000793a:	4c 0a       	lddpc	r10,80007a38 <logFromISR+0x144>
8000793c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000793e:	23 09       	sub	r9,48
80007940:	30 9a       	mov	r10,9
80007942:	f4 09 18 00 	cp.b	r9,r10
80007946:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000794a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000794e:	f7 b9 08 30 	subls	r9,48
80007952:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007956:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000795a:	0f 88       	ld.ub	r8,r7[0x0]
8000795c:	22 58       	sub	r8,37
8000795e:	e0 48 00 53 	cp.w	r8,83
80007962:	e0 8b 00 2b 	brhi	800079b8 <logFromISR+0xc4>
80007966:	4b 69       	lddpc	r9,80007a3c <logFromISR+0x148>
80007968:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000796c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007970:	06 9a       	mov	r10,r3
80007972:	40 0b       	lddsp	r11,sp[0x0]
80007974:	5c 5b       	castu.b	r11
80007976:	68 0c       	ld.w	r12,r4[0x0]
80007978:	f0 1f 00 32 	mcall	80007a40 <logFromISR+0x14c>
					break;
8000797c:	c2 38       	rjmp	800079c2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000797e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007982:	06 9a       	mov	r10,r3
80007984:	40 0b       	lddsp	r11,sp[0x0]
80007986:	5c 5b       	castu.b	r11
80007988:	68 0c       	ld.w	r12,r4[0x0]
8000798a:	f0 1f 00 2f 	mcall	80007a44 <logFromISR+0x150>
8000798e:	06 9c       	mov	r12,r3
					break;
80007990:	c1 98       	rjmp	800079c2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007992:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007996:	06 9b       	mov	r11,r3
80007998:	09 bc       	ld.ub	r12,r4[0x3]
8000799a:	f0 1f 00 2c 	mcall	80007a48 <logFromISR+0x154>
8000799e:	06 9c       	mov	r12,r3
					break;
800079a0:	c1 18       	rjmp	800079c2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800079a2:	e8 c5 ff fc 	sub	r5,r4,-4
800079a6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800079a8:	c0 d8       	rjmp	800079c2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800079aa:	06 9b       	mov	r11,r3
800079ac:	32 5c       	mov	r12,37
800079ae:	f0 1f 00 27 	mcall	80007a48 <logFromISR+0x154>
800079b2:	08 95       	mov	r5,r4
800079b4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800079b6:	c0 68       	rjmp	800079c2 <logFromISR+0xce>
					default:
					log("I need relax.");
800079b8:	4a 5c       	lddpc	r12,80007a4c <logFromISR+0x158>
800079ba:	f0 1f 00 26 	mcall	80007a50 <logFromISR+0x15c>
800079be:	08 95       	mov	r5,r4
800079c0:	06 9c       	mov	r12,r3
				}
				str++;
800079c2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800079c4:	1a dc       	st.w	--sp,r12
800079c6:	1a d6       	st.w	--sp,r6
800079c8:	4a 3b       	lddpc	r11,80007a54 <logFromISR+0x160>
800079ca:	0c 9c       	mov	r12,r6
800079cc:	f0 1f 00 23 	mcall	80007a58 <logFromISR+0x164>
800079d0:	2f ed       	sub	sp,-8
800079d2:	c0 a8       	rjmp	800079e6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800079d4:	2f f7       	sub	r7,-1
800079d6:	1a d8       	st.w	--sp,r8
800079d8:	1a d6       	st.w	--sp,r6
800079da:	4a 1b       	lddpc	r11,80007a5c <logFromISR+0x168>
800079dc:	0c 9c       	mov	r12,r6
800079de:	f0 1f 00 1f 	mcall	80007a58 <logFromISR+0x164>
800079e2:	08 95       	mov	r5,r4
800079e4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800079e6:	0f 89       	ld.ub	r9,r7[0x0]
800079e8:	30 08       	mov	r8,0
800079ea:	f0 09 18 00 	cp.b	r9,r8
800079ee:	c0 30       	breq	800079f4 <logFromISR+0x100>
800079f0:	0a 94       	mov	r4,r5
800079f2:	c9 8b       	rjmp	80007922 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800079f4:	fa c7 fe f4 	sub	r7,sp,-268
800079f8:	1a d7       	st.w	--sp,r7
800079fa:	49 ab       	lddpc	r11,80007a60 <logFromISR+0x16c>
800079fc:	0e 9c       	mov	r12,r7
800079fe:	f0 1f 00 17 	mcall	80007a58 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007a02:	5c 5c       	castu.b	r12
80007a04:	f8 c6 ff ff 	sub	r6,r12,-1
80007a08:	0c 9c       	mov	r12,r6
80007a0a:	f0 1f 00 17 	mcall	80007a64 <logFromISR+0x170>
80007a0e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007a10:	0c 9a       	mov	r10,r6
80007a12:	0e 9b       	mov	r11,r7
80007a14:	f0 1f 00 15 	mcall	80007a68 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007a18:	30 09       	mov	r9,0
80007a1a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007a1c:	fa ca fe f8 	sub	r10,sp,-264
80007a20:	fa cb fe f4 	sub	r11,sp,-268
80007a24:	49 28       	lddpc	r8,80007a6c <logFromISR+0x178>
80007a26:	70 0c       	ld.w	r12,r8[0x0]
80007a28:	f0 1f 00 12 	mcall	80007a70 <logFromISR+0x17c>
80007a2c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007a2e:	fe 3d fd f4 	sub	sp,-524
80007a32:	d8 32       	popm	r0-r7,pc
80007a34:	80 00       	ld.sh	r0,r0[0x0]
80007a36:	81 5e       	st.w	r0[0x14],lr
80007a38:	00 00       	add	r0,r0
80007a3a:	0d c1       	ld.ub	r1,r6[0x4]
80007a3c:	80 00       	ld.sh	r0,r0[0x0]
80007a3e:	e4 10 80 00 	andh	r0,0x8000
80007a42:	76 8e       	ld.w	lr,r11[0x20]
80007a44:	80 00       	ld.sh	r0,r0[0x0]
80007a46:	75 dc       	ld.w	r12,r10[0x74]
80007a48:	80 00       	ld.sh	r0,r0[0x0]
80007a4a:	75 d8       	ld.w	r8,r10[0x74]
80007a4c:	80 00       	ld.sh	r0,r0[0x0]
80007a4e:	e5 7c 80 00 	stcond	r2[-32768],r12
80007a52:	77 68       	ld.w	r8,r11[0x58]
80007a54:	80 00       	ld.sh	r0,r0[0x0]
80007a56:	e5 8c       	*unknown*
80007a58:	80 00       	ld.sh	r0,r0[0x0]
80007a5a:	84 4c       	ld.sh	r12,r2[0x8]
80007a5c:	80 00       	ld.sh	r0,r0[0x0]
80007a5e:	e5 94       	*unknown*
80007a60:	80 00       	ld.sh	r0,r0[0x0]
80007a62:	e5 9c       	*unknown*
80007a64:	80 00       	ld.sh	r0,r0[0x0]
80007a66:	67 dc       	ld.w	r12,r3[0x74]
80007a68:	80 00       	ld.sh	r0,r0[0x0]
80007a6a:	80 16       	ld.sh	r6,r0[0x2]
80007a6c:	00 00       	add	r0,r0
80007a6e:	54 20       	stdsp	sp[0x108],r0
80007a70:	80 00       	ld.sh	r0,r0[0x0]
80007a72:	6a e0       	ld.w	r0,r5[0x38]

80007a74 <log_init>:
		
	return str;
}

void log_init(void)
{
80007a74:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007a76:	30 2b       	mov	r11,2
80007a78:	49 0c       	lddpc	r12,80007ab8 <log_init+0x44>
80007a7a:	f0 1f 00 11 	mcall	80007abc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007a7e:	e0 6a 36 00 	mov	r10,13824
80007a82:	ea 1a 01 6e 	orh	r10,0x16e
80007a86:	48 fb       	lddpc	r11,80007ac0 <log_init+0x4c>
80007a88:	fe 7c 18 00 	mov	r12,-59392
80007a8c:	f0 1f 00 0e 	mcall	80007ac4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007a90:	30 4b       	mov	r11,4
80007a92:	33 2c       	mov	r12,50
80007a94:	f0 1f 00 0d 	mcall	80007ac8 <log_init+0x54>
80007a98:	48 d8       	lddpc	r8,80007acc <log_init+0x58>
80007a9a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007a9c:	30 09       	mov	r9,0
80007a9e:	1a d9       	st.w	--sp,r9
80007aa0:	1a d9       	st.w	--sp,r9
80007aa2:	1a d9       	st.w	--sp,r9
80007aa4:	30 28       	mov	r8,2
80007aa6:	e0 6a 01 80 	mov	r10,384
80007aaa:	48 ab       	lddpc	r11,80007ad0 <log_init+0x5c>
80007aac:	48 ac       	lddpc	r12,80007ad4 <log_init+0x60>
80007aae:	f0 1f 00 0b 	mcall	80007ad8 <log_init+0x64>
80007ab2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007ab4:	d8 02       	popm	pc
80007ab6:	00 00       	add	r0,r0
80007ab8:	80 00       	ld.sh	r0,r0[0x0]
80007aba:	e5 a8 80 00 	cop	cp4,cr0,cr0,cr0,0x50
80007abe:	5c 9c       	brev	r12
80007ac0:	80 00       	ld.sh	r0,r0[0x0]
80007ac2:	e5 60 80 00 	st.b	r2[-32768],r0
80007ac6:	63 40       	ld.w	r0,r1[0x50]
80007ac8:	80 00       	ld.sh	r0,r0[0x0]
80007aca:	6c 88       	ld.w	r8,r6[0x20]
80007acc:	00 00       	add	r0,r0
80007ace:	54 20       	stdsp	sp[0x108],r0
80007ad0:	80 00       	ld.sh	r0,r0[0x0]
80007ad2:	e5 a4 80 00 	cop	cp4,cr0,cr0,cr0,0x48
80007ad6:	7a dc       	ld.w	r12,sp[0x34]
80007ad8:	80 00       	ld.sh	r0,r0[0x0]
80007ada:	73 a4       	ld.w	r4,r9[0x68]

80007adc <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80007adc:	eb cd 40 f8 	pushm	r3-r7,lr
80007ae0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007ae2:	48 c7       	lddpc	r7,80007b10 <task_log+0x34>
80007ae4:	30 05       	mov	r5,0
80007ae6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007ae8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007aec:	0a 99       	mov	r9,r5
80007aee:	08 9a       	mov	r10,r4
80007af0:	1a 9b       	mov	r11,sp
80007af2:	6e 0c       	ld.w	r12,r7[0x0]
80007af4:	f0 1f 00 08 	mcall	80007b14 <task_log+0x38>
80007af8:	58 1c       	cp.w	r12,1
80007afa:	cf 91       	brne	80007aec <task_log+0x10>
		{
			if( NULL != str)
80007afc:	40 0b       	lddsp	r11,sp[0x0]
80007afe:	58 0b       	cp.w	r11,0
80007b00:	cf 60       	breq	80007aec <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007b02:	06 9c       	mov	r12,r3
80007b04:	f0 1f 00 05 	mcall	80007b18 <task_log+0x3c>
				vPortFree(str);
80007b08:	40 0c       	lddsp	r12,sp[0x0]
80007b0a:	f0 1f 00 05 	mcall	80007b1c <task_log+0x40>
80007b0e:	ce fb       	rjmp	80007aec <task_log+0x10>
80007b10:	00 00       	add	r0,r0
80007b12:	54 20       	stdsp	sp[0x108],r0
80007b14:	80 00       	ld.sh	r0,r0[0x0]
80007b16:	69 24       	ld.w	r4,r4[0x48]
80007b18:	80 00       	ld.sh	r0,r0[0x0]
80007b1a:	62 f0       	ld.w	r0,r1[0x3c]
80007b1c:	80 00       	ld.sh	r0,r0[0x0]
80007b1e:	67 b4       	ld.w	r4,r3[0x6c]

80007b20 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007b20:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007b22:	fe 78 10 00 	mov	r8,-61440
80007b26:	30 19       	mov	r9,1
80007b28:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007b2c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007b30:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007b34:	d3 03       	ssrf	0x10
	local_start_pll0();
80007b36:	f0 1f 00 0d 	mcall	80007b68 <main+0x48>
		
	INTC_init_interrupts();
80007b3a:	f0 1f 00 0d 	mcall	80007b6c <main+0x4c>
		
	log_init();
80007b3e:	f0 1f 00 0d 	mcall	80007b70 <main+0x50>
	log("----start debug----");
80007b42:	48 dc       	lddpc	r12,80007b74 <main+0x54>
80007b44:	f0 1f 00 0d 	mcall	80007b78 <main+0x58>
	
	xg_flashc_init();
80007b48:	f0 1f 00 0d 	mcall	80007b7c <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007b4c:	f0 1f 00 0d 	mcall	80007b80 <main+0x60>
		
	app_init();
80007b50:	f0 1f 00 0d 	mcall	80007b84 <main+0x64>
		
	xcmp_init();
80007b54:	f0 1f 00 0d 	mcall	80007b88 <main+0x68>

	local_start_timer();
80007b58:	f0 1f 00 0d 	mcall	80007b8c <main+0x6c>
	
	xg_rtc_init();
80007b5c:	f0 1f 00 0d 	mcall	80007b90 <main+0x70>
		
	vTaskStartScheduler();
80007b60:	f0 1f 00 0d 	mcall	80007b94 <main+0x74>
	return 0;
	
}
80007b64:	d8 0a       	popm	pc,r12=0
80007b66:	00 00       	add	r0,r0
80007b68:	80 00       	ld.sh	r0,r0[0x0]
80007b6a:	52 20       	stdsp	sp[0x88],r0
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	5d a0       	*unknown*
80007b70:	80 00       	ld.sh	r0,r0[0x0]
80007b72:	7a 74       	ld.w	r4,sp[0x1c]
80007b74:	80 00       	ld.sh	r0,r0[0x0]
80007b76:	e5 b8       	*unknown*
80007b78:	80 00       	ld.sh	r0,r0[0x0]
80007b7a:	77 68       	ld.w	r8,r11[0x58]
80007b7c:	80 00       	ld.sh	r0,r0[0x0]
80007b7e:	53 04       	stdsp	sp[0xc0],r4
80007b80:	80 00       	ld.sh	r0,r0[0x0]
80007b82:	52 14       	stdsp	sp[0x84],r4
80007b84:	80 00       	ld.sh	r0,r0[0x0]
80007b86:	20 3c       	sub	r12,3
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	41 30       	lddsp	r0,sp[0x4c]
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	52 d8       	stdsp	sp[0xb4],r8
80007b90:	80 00       	ld.sh	r0,r0[0x0]
80007b92:	29 b8       	sub	r8,-101
80007b94:	80 00       	ld.sh	r0,r0[0x0]
80007b96:	75 8c       	ld.w	r12,r10[0x60]

80007b98 <free>:
80007b98:	d4 01       	pushm	lr
80007b9a:	e0 68 0a 4c 	mov	r8,2636
80007b9e:	18 9b       	mov	r11,r12
80007ba0:	70 0c       	ld.w	r12,r8[0x0]
80007ba2:	e0 a0 1e 73 	rcall	8000b888 <_free_r>
80007ba6:	d8 02       	popm	pc

80007ba8 <malloc>:
80007ba8:	d4 01       	pushm	lr
80007baa:	e0 68 0a 4c 	mov	r8,2636
80007bae:	18 9b       	mov	r11,r12
80007bb0:	70 0c       	ld.w	r12,r8[0x0]
80007bb2:	c0 3c       	rcall	80007bb8 <_malloc_r>
80007bb4:	d8 02       	popm	pc
80007bb6:	d7 03       	nop

80007bb8 <_malloc_r>:
80007bb8:	d4 31       	pushm	r0-r7,lr
80007bba:	f6 c8 ff f5 	sub	r8,r11,-11
80007bbe:	18 95       	mov	r5,r12
80007bc0:	10 97       	mov	r7,r8
80007bc2:	e0 17 ff f8 	andl	r7,0xfff8
80007bc6:	59 68       	cp.w	r8,22
80007bc8:	f9 b7 08 10 	movls	r7,16
80007bcc:	16 37       	cp.w	r7,r11
80007bce:	5f 38       	srlo	r8
80007bd0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007bd4:	c0 50       	breq	80007bde <_malloc_r+0x26>
80007bd6:	30 c8       	mov	r8,12
80007bd8:	99 38       	st.w	r12[0xc],r8
80007bda:	e0 8f 01 fa 	bral	80007fce <_malloc_r+0x416>
80007bde:	fe b0 f5 a1 	rcall	80006720 <__malloc_lock>
80007be2:	e0 47 01 f7 	cp.w	r7,503
80007be6:	e0 8b 00 1d 	brhi	80007c20 <_malloc_r+0x68>
80007bea:	ee 03 16 03 	lsr	r3,r7,0x3
80007bee:	e0 68 05 4c 	mov	r8,1356
80007bf2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007bf6:	70 36       	ld.w	r6,r8[0xc]
80007bf8:	10 36       	cp.w	r6,r8
80007bfa:	c0 61       	brne	80007c06 <_malloc_r+0x4e>
80007bfc:	ec c8 ff f8 	sub	r8,r6,-8
80007c00:	70 36       	ld.w	r6,r8[0xc]
80007c02:	10 36       	cp.w	r6,r8
80007c04:	c0 c0       	breq	80007c1c <_malloc_r+0x64>
80007c06:	6c 18       	ld.w	r8,r6[0x4]
80007c08:	e0 18 ff fc 	andl	r8,0xfffc
80007c0c:	6c 3a       	ld.w	r10,r6[0xc]
80007c0e:	ec 08 00 09 	add	r9,r6,r8
80007c12:	0a 9c       	mov	r12,r5
80007c14:	6c 28       	ld.w	r8,r6[0x8]
80007c16:	95 28       	st.w	r10[0x8],r8
80007c18:	91 3a       	st.w	r8[0xc],r10
80007c1a:	c4 78       	rjmp	80007ca8 <_malloc_r+0xf0>
80007c1c:	2f e3       	sub	r3,-2
80007c1e:	c4 d8       	rjmp	80007cb8 <_malloc_r+0x100>
80007c20:	ee 03 16 09 	lsr	r3,r7,0x9
80007c24:	c0 41       	brne	80007c2c <_malloc_r+0x74>
80007c26:	ee 03 16 03 	lsr	r3,r7,0x3
80007c2a:	c2 68       	rjmp	80007c76 <_malloc_r+0xbe>
80007c2c:	58 43       	cp.w	r3,4
80007c2e:	e0 8b 00 06 	brhi	80007c3a <_malloc_r+0x82>
80007c32:	ee 03 16 06 	lsr	r3,r7,0x6
80007c36:	2c 83       	sub	r3,-56
80007c38:	c1 f8       	rjmp	80007c76 <_malloc_r+0xbe>
80007c3a:	59 43       	cp.w	r3,20
80007c3c:	e0 8b 00 04 	brhi	80007c44 <_malloc_r+0x8c>
80007c40:	2a 53       	sub	r3,-91
80007c42:	c1 a8       	rjmp	80007c76 <_malloc_r+0xbe>
80007c44:	e0 43 00 54 	cp.w	r3,84
80007c48:	e0 8b 00 06 	brhi	80007c54 <_malloc_r+0x9c>
80007c4c:	ee 03 16 0c 	lsr	r3,r7,0xc
80007c50:	29 23       	sub	r3,-110
80007c52:	c1 28       	rjmp	80007c76 <_malloc_r+0xbe>
80007c54:	e0 43 01 54 	cp.w	r3,340
80007c58:	e0 8b 00 06 	brhi	80007c64 <_malloc_r+0xac>
80007c5c:	ee 03 16 0f 	lsr	r3,r7,0xf
80007c60:	28 93       	sub	r3,-119
80007c62:	c0 a8       	rjmp	80007c76 <_malloc_r+0xbe>
80007c64:	e0 43 05 54 	cp.w	r3,1364
80007c68:	e0 88 00 04 	brls	80007c70 <_malloc_r+0xb8>
80007c6c:	37 e3       	mov	r3,126
80007c6e:	c0 48       	rjmp	80007c76 <_malloc_r+0xbe>
80007c70:	ee 03 16 12 	lsr	r3,r7,0x12
80007c74:	28 43       	sub	r3,-124
80007c76:	e0 6a 05 4c 	mov	r10,1356
80007c7a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007c7e:	74 36       	ld.w	r6,r10[0xc]
80007c80:	c1 98       	rjmp	80007cb2 <_malloc_r+0xfa>
80007c82:	6c 19       	ld.w	r9,r6[0x4]
80007c84:	e0 19 ff fc 	andl	r9,0xfffc
80007c88:	f2 07 01 0b 	sub	r11,r9,r7
80007c8c:	58 fb       	cp.w	r11,15
80007c8e:	e0 8a 00 04 	brle	80007c96 <_malloc_r+0xde>
80007c92:	20 13       	sub	r3,1
80007c94:	c1 18       	rjmp	80007cb6 <_malloc_r+0xfe>
80007c96:	6c 38       	ld.w	r8,r6[0xc]
80007c98:	58 0b       	cp.w	r11,0
80007c9a:	c0 b5       	brlt	80007cb0 <_malloc_r+0xf8>
80007c9c:	6c 2a       	ld.w	r10,r6[0x8]
80007c9e:	ec 09 00 09 	add	r9,r6,r9
80007ca2:	0a 9c       	mov	r12,r5
80007ca4:	91 2a       	st.w	r8[0x8],r10
80007ca6:	95 38       	st.w	r10[0xc],r8
80007ca8:	72 18       	ld.w	r8,r9[0x4]
80007caa:	a1 a8       	sbr	r8,0x0
80007cac:	93 18       	st.w	r9[0x4],r8
80007cae:	cb c8       	rjmp	80007e26 <_malloc_r+0x26e>
80007cb0:	10 96       	mov	r6,r8
80007cb2:	14 36       	cp.w	r6,r10
80007cb4:	ce 71       	brne	80007c82 <_malloc_r+0xca>
80007cb6:	2f f3       	sub	r3,-1
80007cb8:	e0 6a 05 4c 	mov	r10,1356
80007cbc:	f4 cc ff f8 	sub	r12,r10,-8
80007cc0:	78 26       	ld.w	r6,r12[0x8]
80007cc2:	18 36       	cp.w	r6,r12
80007cc4:	c6 c0       	breq	80007d9c <_malloc_r+0x1e4>
80007cc6:	6c 19       	ld.w	r9,r6[0x4]
80007cc8:	e0 19 ff fc 	andl	r9,0xfffc
80007ccc:	f2 07 01 08 	sub	r8,r9,r7
80007cd0:	58 f8       	cp.w	r8,15
80007cd2:	e0 89 00 8f 	brgt	80007df0 <_malloc_r+0x238>
80007cd6:	99 3c       	st.w	r12[0xc],r12
80007cd8:	99 2c       	st.w	r12[0x8],r12
80007cda:	58 08       	cp.w	r8,0
80007cdc:	c0 55       	brlt	80007ce6 <_malloc_r+0x12e>
80007cde:	ec 09 00 09 	add	r9,r6,r9
80007ce2:	0a 9c       	mov	r12,r5
80007ce4:	ce 2b       	rjmp	80007ca8 <_malloc_r+0xf0>
80007ce6:	e0 49 01 ff 	cp.w	r9,511
80007cea:	e0 8b 00 13 	brhi	80007d10 <_malloc_r+0x158>
80007cee:	a3 99       	lsr	r9,0x3
80007cf0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007cf4:	70 2b       	ld.w	r11,r8[0x8]
80007cf6:	8d 38       	st.w	r6[0xc],r8
80007cf8:	8d 2b       	st.w	r6[0x8],r11
80007cfa:	97 36       	st.w	r11[0xc],r6
80007cfc:	91 26       	st.w	r8[0x8],r6
80007cfe:	a3 49       	asr	r9,0x2
80007d00:	74 18       	ld.w	r8,r10[0x4]
80007d02:	30 1b       	mov	r11,1
80007d04:	f6 09 09 49 	lsl	r9,r11,r9
80007d08:	f1 e9 10 09 	or	r9,r8,r9
80007d0c:	95 19       	st.w	r10[0x4],r9
80007d0e:	c4 78       	rjmp	80007d9c <_malloc_r+0x1e4>
80007d10:	f2 0a 16 09 	lsr	r10,r9,0x9
80007d14:	58 4a       	cp.w	r10,4
80007d16:	e0 8b 00 07 	brhi	80007d24 <_malloc_r+0x16c>
80007d1a:	f2 0a 16 06 	lsr	r10,r9,0x6
80007d1e:	2c 8a       	sub	r10,-56
80007d20:	c2 08       	rjmp	80007d60 <_malloc_r+0x1a8>
80007d22:	d7 03       	nop
80007d24:	59 4a       	cp.w	r10,20
80007d26:	e0 8b 00 04 	brhi	80007d2e <_malloc_r+0x176>
80007d2a:	2a 5a       	sub	r10,-91
80007d2c:	c1 a8       	rjmp	80007d60 <_malloc_r+0x1a8>
80007d2e:	e0 4a 00 54 	cp.w	r10,84
80007d32:	e0 8b 00 06 	brhi	80007d3e <_malloc_r+0x186>
80007d36:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007d3a:	29 2a       	sub	r10,-110
80007d3c:	c1 28       	rjmp	80007d60 <_malloc_r+0x1a8>
80007d3e:	e0 4a 01 54 	cp.w	r10,340
80007d42:	e0 8b 00 06 	brhi	80007d4e <_malloc_r+0x196>
80007d46:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007d4a:	28 9a       	sub	r10,-119
80007d4c:	c0 a8       	rjmp	80007d60 <_malloc_r+0x1a8>
80007d4e:	e0 4a 05 54 	cp.w	r10,1364
80007d52:	e0 88 00 04 	brls	80007d5a <_malloc_r+0x1a2>
80007d56:	37 ea       	mov	r10,126
80007d58:	c0 48       	rjmp	80007d60 <_malloc_r+0x1a8>
80007d5a:	f2 0a 16 12 	lsr	r10,r9,0x12
80007d5e:	28 4a       	sub	r10,-124
80007d60:	e0 6b 05 4c 	mov	r11,1356
80007d64:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007d68:	68 28       	ld.w	r8,r4[0x8]
80007d6a:	08 38       	cp.w	r8,r4
80007d6c:	c0 e1       	brne	80007d88 <_malloc_r+0x1d0>
80007d6e:	76 19       	ld.w	r9,r11[0x4]
80007d70:	a3 4a       	asr	r10,0x2
80007d72:	30 1e       	mov	lr,1
80007d74:	fc 0a 09 4a 	lsl	r10,lr,r10
80007d78:	f3 ea 10 0a 	or	r10,r9,r10
80007d7c:	10 99       	mov	r9,r8
80007d7e:	97 1a       	st.w	r11[0x4],r10
80007d80:	c0 a8       	rjmp	80007d94 <_malloc_r+0x1dc>
80007d82:	70 28       	ld.w	r8,r8[0x8]
80007d84:	08 38       	cp.w	r8,r4
80007d86:	c0 60       	breq	80007d92 <_malloc_r+0x1da>
80007d88:	70 1a       	ld.w	r10,r8[0x4]
80007d8a:	e0 1a ff fc 	andl	r10,0xfffc
80007d8e:	14 39       	cp.w	r9,r10
80007d90:	cf 93       	brcs	80007d82 <_malloc_r+0x1ca>
80007d92:	70 39       	ld.w	r9,r8[0xc]
80007d94:	8d 39       	st.w	r6[0xc],r9
80007d96:	8d 28       	st.w	r6[0x8],r8
80007d98:	91 36       	st.w	r8[0xc],r6
80007d9a:	93 26       	st.w	r9[0x8],r6
80007d9c:	e6 08 14 02 	asr	r8,r3,0x2
80007da0:	30 1b       	mov	r11,1
80007da2:	e0 64 05 4c 	mov	r4,1356
80007da6:	f6 08 09 4b 	lsl	r11,r11,r8
80007daa:	68 18       	ld.w	r8,r4[0x4]
80007dac:	10 3b       	cp.w	r11,r8
80007dae:	e0 8b 00 6b 	brhi	80007e84 <_malloc_r+0x2cc>
80007db2:	f7 e8 00 09 	and	r9,r11,r8
80007db6:	c0 b1       	brne	80007dcc <_malloc_r+0x214>
80007db8:	e0 13 ff fc 	andl	r3,0xfffc
80007dbc:	a1 7b       	lsl	r11,0x1
80007dbe:	2f c3       	sub	r3,-4
80007dc0:	c0 38       	rjmp	80007dc6 <_malloc_r+0x20e>
80007dc2:	2f c3       	sub	r3,-4
80007dc4:	a1 7b       	lsl	r11,0x1
80007dc6:	f7 e8 00 09 	and	r9,r11,r8
80007dca:	cf c0       	breq	80007dc2 <_malloc_r+0x20a>
80007dcc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007dd0:	06 92       	mov	r2,r3
80007dd2:	1c 91       	mov	r1,lr
80007dd4:	62 36       	ld.w	r6,r1[0xc]
80007dd6:	c2 e8       	rjmp	80007e32 <_malloc_r+0x27a>
80007dd8:	6c 1a       	ld.w	r10,r6[0x4]
80007dda:	e0 1a ff fc 	andl	r10,0xfffc
80007dde:	f4 07 01 08 	sub	r8,r10,r7
80007de2:	58 f8       	cp.w	r8,15
80007de4:	e0 8a 00 15 	brle	80007e0e <_malloc_r+0x256>
80007de8:	6c 3a       	ld.w	r10,r6[0xc]
80007dea:	6c 29       	ld.w	r9,r6[0x8]
80007dec:	95 29       	st.w	r10[0x8],r9
80007dee:	93 3a       	st.w	r9[0xc],r10
80007df0:	0e 99       	mov	r9,r7
80007df2:	ec 07 00 07 	add	r7,r6,r7
80007df6:	a1 a9       	sbr	r9,0x0
80007df8:	99 37       	st.w	r12[0xc],r7
80007dfa:	99 27       	st.w	r12[0x8],r7
80007dfc:	8d 19       	st.w	r6[0x4],r9
80007dfe:	ee 08 09 08 	st.w	r7[r8],r8
80007e02:	8f 2c       	st.w	r7[0x8],r12
80007e04:	8f 3c       	st.w	r7[0xc],r12
80007e06:	a1 a8       	sbr	r8,0x0
80007e08:	0a 9c       	mov	r12,r5
80007e0a:	8f 18       	st.w	r7[0x4],r8
80007e0c:	c0 d8       	rjmp	80007e26 <_malloc_r+0x26e>
80007e0e:	6c 39       	ld.w	r9,r6[0xc]
80007e10:	58 08       	cp.w	r8,0
80007e12:	c0 f5       	brlt	80007e30 <_malloc_r+0x278>
80007e14:	ec 0a 00 0a 	add	r10,r6,r10
80007e18:	74 18       	ld.w	r8,r10[0x4]
80007e1a:	a1 a8       	sbr	r8,0x0
80007e1c:	0a 9c       	mov	r12,r5
80007e1e:	95 18       	st.w	r10[0x4],r8
80007e20:	6c 28       	ld.w	r8,r6[0x8]
80007e22:	93 28       	st.w	r9[0x8],r8
80007e24:	91 39       	st.w	r8[0xc],r9
80007e26:	fe b0 f4 83 	rcall	8000672c <__malloc_unlock>
80007e2a:	ec cc ff f8 	sub	r12,r6,-8
80007e2e:	d8 32       	popm	r0-r7,pc
80007e30:	12 96       	mov	r6,r9
80007e32:	02 36       	cp.w	r6,r1
80007e34:	cd 21       	brne	80007dd8 <_malloc_r+0x220>
80007e36:	2f f2       	sub	r2,-1
80007e38:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007e3c:	c0 30       	breq	80007e42 <_malloc_r+0x28a>
80007e3e:	2f 81       	sub	r1,-8
80007e40:	cc ab       	rjmp	80007dd4 <_malloc_r+0x21c>
80007e42:	1c 98       	mov	r8,lr
80007e44:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007e48:	c0 81       	brne	80007e58 <_malloc_r+0x2a0>
80007e4a:	68 19       	ld.w	r9,r4[0x4]
80007e4c:	f6 08 11 ff 	rsub	r8,r11,-1
80007e50:	f3 e8 00 08 	and	r8,r9,r8
80007e54:	89 18       	st.w	r4[0x4],r8
80007e56:	c0 78       	rjmp	80007e64 <_malloc_r+0x2ac>
80007e58:	f0 c9 00 08 	sub	r9,r8,8
80007e5c:	20 13       	sub	r3,1
80007e5e:	70 08       	ld.w	r8,r8[0x0]
80007e60:	12 38       	cp.w	r8,r9
80007e62:	cf 10       	breq	80007e44 <_malloc_r+0x28c>
80007e64:	a1 7b       	lsl	r11,0x1
80007e66:	68 18       	ld.w	r8,r4[0x4]
80007e68:	10 3b       	cp.w	r11,r8
80007e6a:	e0 8b 00 0d 	brhi	80007e84 <_malloc_r+0x2cc>
80007e6e:	58 0b       	cp.w	r11,0
80007e70:	c0 a0       	breq	80007e84 <_malloc_r+0x2cc>
80007e72:	04 93       	mov	r3,r2
80007e74:	c0 38       	rjmp	80007e7a <_malloc_r+0x2c2>
80007e76:	2f c3       	sub	r3,-4
80007e78:	a1 7b       	lsl	r11,0x1
80007e7a:	f7 e8 00 09 	and	r9,r11,r8
80007e7e:	ca 71       	brne	80007dcc <_malloc_r+0x214>
80007e80:	cf bb       	rjmp	80007e76 <_malloc_r+0x2be>
80007e82:	d7 03       	nop
80007e84:	68 23       	ld.w	r3,r4[0x8]
80007e86:	66 12       	ld.w	r2,r3[0x4]
80007e88:	e0 12 ff fc 	andl	r2,0xfffc
80007e8c:	0e 32       	cp.w	r2,r7
80007e8e:	5f 39       	srlo	r9
80007e90:	e4 07 01 08 	sub	r8,r2,r7
80007e94:	58 f8       	cp.w	r8,15
80007e96:	5f aa       	srle	r10
80007e98:	f5 e9 10 09 	or	r9,r10,r9
80007e9c:	e0 80 00 9a 	breq	80007fd0 <_malloc_r+0x418>
80007ea0:	e0 68 0d cc 	mov	r8,3532
80007ea4:	70 01       	ld.w	r1,r8[0x0]
80007ea6:	e0 68 09 58 	mov	r8,2392
80007eaa:	2f 01       	sub	r1,-16
80007eac:	70 08       	ld.w	r8,r8[0x0]
80007eae:	0e 01       	add	r1,r7
80007eb0:	5b f8       	cp.w	r8,-1
80007eb2:	c0 40       	breq	80007eba <_malloc_r+0x302>
80007eb4:	28 11       	sub	r1,-127
80007eb6:	e0 11 ff 80 	andl	r1,0xff80
80007eba:	02 9b       	mov	r11,r1
80007ebc:	0a 9c       	mov	r12,r5
80007ebe:	e0 a0 02 b7 	rcall	8000842c <_sbrk_r>
80007ec2:	18 96       	mov	r6,r12
80007ec4:	5b fc       	cp.w	r12,-1
80007ec6:	c7 50       	breq	80007fb0 <_malloc_r+0x3f8>
80007ec8:	e6 02 00 08 	add	r8,r3,r2
80007ecc:	10 3c       	cp.w	r12,r8
80007ece:	c0 32       	brcc	80007ed4 <_malloc_r+0x31c>
80007ed0:	08 33       	cp.w	r3,r4
80007ed2:	c6 f1       	brne	80007fb0 <_malloc_r+0x3f8>
80007ed4:	e0 6a 0d d0 	mov	r10,3536
80007ed8:	74 09       	ld.w	r9,r10[0x0]
80007eda:	e2 09 00 09 	add	r9,r1,r9
80007ede:	95 09       	st.w	r10[0x0],r9
80007ee0:	10 36       	cp.w	r6,r8
80007ee2:	c0 a1       	brne	80007ef6 <_malloc_r+0x33e>
80007ee4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007ee8:	c0 71       	brne	80007ef6 <_malloc_r+0x33e>
80007eea:	e2 02 00 02 	add	r2,r1,r2
80007eee:	68 28       	ld.w	r8,r4[0x8]
80007ef0:	a1 a2       	sbr	r2,0x0
80007ef2:	91 12       	st.w	r8[0x4],r2
80007ef4:	c4 f8       	rjmp	80007f92 <_malloc_r+0x3da>
80007ef6:	e0 6a 09 58 	mov	r10,2392
80007efa:	74 0b       	ld.w	r11,r10[0x0]
80007efc:	5b fb       	cp.w	r11,-1
80007efe:	c0 31       	brne	80007f04 <_malloc_r+0x34c>
80007f00:	95 06       	st.w	r10[0x0],r6
80007f02:	c0 78       	rjmp	80007f10 <_malloc_r+0x358>
80007f04:	ec 09 00 09 	add	r9,r6,r9
80007f08:	e0 6a 0d d0 	mov	r10,3536
80007f0c:	10 19       	sub	r9,r8
80007f0e:	95 09       	st.w	r10[0x0],r9
80007f10:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007f14:	f0 09 11 08 	rsub	r9,r8,8
80007f18:	58 08       	cp.w	r8,0
80007f1a:	f2 08 17 10 	movne	r8,r9
80007f1e:	ed d8 e1 06 	addne	r6,r6,r8
80007f22:	28 08       	sub	r8,-128
80007f24:	ec 01 00 01 	add	r1,r6,r1
80007f28:	0a 9c       	mov	r12,r5
80007f2a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007f2e:	f0 01 01 01 	sub	r1,r8,r1
80007f32:	02 9b       	mov	r11,r1
80007f34:	e0 a0 02 7c 	rcall	8000842c <_sbrk_r>
80007f38:	e0 68 0d d0 	mov	r8,3536
80007f3c:	5b fc       	cp.w	r12,-1
80007f3e:	ec 0c 17 00 	moveq	r12,r6
80007f42:	f9 b1 00 00 	moveq	r1,0
80007f46:	70 09       	ld.w	r9,r8[0x0]
80007f48:	0c 1c       	sub	r12,r6
80007f4a:	89 26       	st.w	r4[0x8],r6
80007f4c:	02 0c       	add	r12,r1
80007f4e:	12 01       	add	r1,r9
80007f50:	a1 ac       	sbr	r12,0x0
80007f52:	91 01       	st.w	r8[0x0],r1
80007f54:	8d 1c       	st.w	r6[0x4],r12
80007f56:	08 33       	cp.w	r3,r4
80007f58:	c1 d0       	breq	80007f92 <_malloc_r+0x3da>
80007f5a:	58 f2       	cp.w	r2,15
80007f5c:	e0 8b 00 05 	brhi	80007f66 <_malloc_r+0x3ae>
80007f60:	30 18       	mov	r8,1
80007f62:	8d 18       	st.w	r6[0x4],r8
80007f64:	c2 68       	rjmp	80007fb0 <_malloc_r+0x3f8>
80007f66:	30 59       	mov	r9,5
80007f68:	20 c2       	sub	r2,12
80007f6a:	e0 12 ff f8 	andl	r2,0xfff8
80007f6e:	e6 02 00 08 	add	r8,r3,r2
80007f72:	91 29       	st.w	r8[0x8],r9
80007f74:	91 19       	st.w	r8[0x4],r9
80007f76:	66 18       	ld.w	r8,r3[0x4]
80007f78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f7c:	e5 e8 10 08 	or	r8,r2,r8
80007f80:	87 18       	st.w	r3[0x4],r8
80007f82:	58 f2       	cp.w	r2,15
80007f84:	e0 88 00 07 	brls	80007f92 <_malloc_r+0x3da>
80007f88:	e6 cb ff f8 	sub	r11,r3,-8
80007f8c:	0a 9c       	mov	r12,r5
80007f8e:	e0 a0 1c 7d 	rcall	8000b888 <_free_r>
80007f92:	e0 69 0d c8 	mov	r9,3528
80007f96:	72 0a       	ld.w	r10,r9[0x0]
80007f98:	e0 68 0d d0 	mov	r8,3536
80007f9c:	70 08       	ld.w	r8,r8[0x0]
80007f9e:	14 38       	cp.w	r8,r10
80007fa0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007fa4:	e0 69 0d c4 	mov	r9,3524
80007fa8:	72 0a       	ld.w	r10,r9[0x0]
80007faa:	14 38       	cp.w	r8,r10
80007fac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007fb0:	68 28       	ld.w	r8,r4[0x8]
80007fb2:	70 18       	ld.w	r8,r8[0x4]
80007fb4:	e0 18 ff fc 	andl	r8,0xfffc
80007fb8:	0e 38       	cp.w	r8,r7
80007fba:	5f 39       	srlo	r9
80007fbc:	0e 18       	sub	r8,r7
80007fbe:	58 f8       	cp.w	r8,15
80007fc0:	5f aa       	srle	r10
80007fc2:	f5 e9 10 09 	or	r9,r10,r9
80007fc6:	c0 50       	breq	80007fd0 <_malloc_r+0x418>
80007fc8:	0a 9c       	mov	r12,r5
80007fca:	fe b0 f3 b1 	rcall	8000672c <__malloc_unlock>
80007fce:	d8 3a       	popm	r0-r7,pc,r12=0
80007fd0:	68 26       	ld.w	r6,r4[0x8]
80007fd2:	a1 a8       	sbr	r8,0x0
80007fd4:	0e 99       	mov	r9,r7
80007fd6:	a1 a9       	sbr	r9,0x0
80007fd8:	8d 19       	st.w	r6[0x4],r9
80007fda:	ec 07 00 07 	add	r7,r6,r7
80007fde:	0a 9c       	mov	r12,r5
80007fe0:	89 27       	st.w	r4[0x8],r7
80007fe2:	8f 18       	st.w	r7[0x4],r8
80007fe4:	fe b0 f3 a4 	rcall	8000672c <__malloc_unlock>
80007fe8:	ec cc ff f8 	sub	r12,r6,-8
80007fec:	d8 32       	popm	r0-r7,pc
80007fee:	d7 03       	nop

80007ff0 <memcmp>:
80007ff0:	d4 01       	pushm	lr
80007ff2:	30 08       	mov	r8,0
80007ff4:	c0 d8       	rjmp	8000800e <memcmp+0x1e>
80007ff6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007ffa:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007ffe:	20 1a       	sub	r10,1
80008000:	2f f8       	sub	r8,-1
80008002:	f2 0e 18 00 	cp.b	lr,r9
80008006:	c0 40       	breq	8000800e <memcmp+0x1e>
80008008:	fc 09 01 0c 	sub	r12,lr,r9
8000800c:	d8 02       	popm	pc
8000800e:	58 0a       	cp.w	r10,0
80008010:	cf 31       	brne	80007ff6 <memcmp+0x6>
80008012:	14 9c       	mov	r12,r10
80008014:	d8 02       	popm	pc

80008016 <memcpy>:
80008016:	58 8a       	cp.w	r10,8
80008018:	c2 f5       	brlt	80008076 <memcpy+0x60>
8000801a:	f9 eb 10 09 	or	r9,r12,r11
8000801e:	e2 19 00 03 	andl	r9,0x3,COH
80008022:	e0 81 00 97 	brne	80008150 <memcpy+0x13a>
80008026:	e0 4a 00 20 	cp.w	r10,32
8000802a:	c3 b4       	brge	800080a0 <memcpy+0x8a>
8000802c:	f4 08 14 02 	asr	r8,r10,0x2
80008030:	f0 09 11 08 	rsub	r9,r8,8
80008034:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008038:	76 69       	ld.w	r9,r11[0x18]
8000803a:	99 69       	st.w	r12[0x18],r9
8000803c:	76 59       	ld.w	r9,r11[0x14]
8000803e:	99 59       	st.w	r12[0x14],r9
80008040:	76 49       	ld.w	r9,r11[0x10]
80008042:	99 49       	st.w	r12[0x10],r9
80008044:	76 39       	ld.w	r9,r11[0xc]
80008046:	99 39       	st.w	r12[0xc],r9
80008048:	76 29       	ld.w	r9,r11[0x8]
8000804a:	99 29       	st.w	r12[0x8],r9
8000804c:	76 19       	ld.w	r9,r11[0x4]
8000804e:	99 19       	st.w	r12[0x4],r9
80008050:	76 09       	ld.w	r9,r11[0x0]
80008052:	99 09       	st.w	r12[0x0],r9
80008054:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008058:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000805c:	e0 1a 00 03 	andl	r10,0x3
80008060:	f4 0a 11 04 	rsub	r10,r10,4
80008064:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008068:	17 a9       	ld.ub	r9,r11[0x2]
8000806a:	b0 a9       	st.b	r8[0x2],r9
8000806c:	17 99       	ld.ub	r9,r11[0x1]
8000806e:	b0 99       	st.b	r8[0x1],r9
80008070:	17 89       	ld.ub	r9,r11[0x0]
80008072:	b0 89       	st.b	r8[0x0],r9
80008074:	5e fc       	retal	r12
80008076:	f4 0a 11 09 	rsub	r10,r10,9
8000807a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000807e:	17 f9       	ld.ub	r9,r11[0x7]
80008080:	b8 f9       	st.b	r12[0x7],r9
80008082:	17 e9       	ld.ub	r9,r11[0x6]
80008084:	b8 e9       	st.b	r12[0x6],r9
80008086:	17 d9       	ld.ub	r9,r11[0x5]
80008088:	b8 d9       	st.b	r12[0x5],r9
8000808a:	17 c9       	ld.ub	r9,r11[0x4]
8000808c:	b8 c9       	st.b	r12[0x4],r9
8000808e:	17 b9       	ld.ub	r9,r11[0x3]
80008090:	b8 b9       	st.b	r12[0x3],r9
80008092:	17 a9       	ld.ub	r9,r11[0x2]
80008094:	b8 a9       	st.b	r12[0x2],r9
80008096:	17 99       	ld.ub	r9,r11[0x1]
80008098:	b8 99       	st.b	r12[0x1],r9
8000809a:	17 89       	ld.ub	r9,r11[0x0]
8000809c:	b8 89       	st.b	r12[0x0],r9
8000809e:	5e fc       	retal	r12
800080a0:	eb cd 40 c0 	pushm	r6-r7,lr
800080a4:	18 99       	mov	r9,r12
800080a6:	22 0a       	sub	r10,32
800080a8:	b7 07       	ld.d	r6,r11++
800080aa:	b3 26       	st.d	r9++,r6
800080ac:	b7 07       	ld.d	r6,r11++
800080ae:	b3 26       	st.d	r9++,r6
800080b0:	b7 07       	ld.d	r6,r11++
800080b2:	b3 26       	st.d	r9++,r6
800080b4:	b7 07       	ld.d	r6,r11++
800080b6:	b3 26       	st.d	r9++,r6
800080b8:	22 0a       	sub	r10,32
800080ba:	cf 74       	brge	800080a8 <memcpy+0x92>
800080bc:	2f 0a       	sub	r10,-16
800080be:	c0 65       	brlt	800080ca <memcpy+0xb4>
800080c0:	b7 07       	ld.d	r6,r11++
800080c2:	b3 26       	st.d	r9++,r6
800080c4:	b7 07       	ld.d	r6,r11++
800080c6:	b3 26       	st.d	r9++,r6
800080c8:	21 0a       	sub	r10,16
800080ca:	5c 3a       	neg	r10
800080cc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800080d0:	d7 03       	nop
800080d2:	d7 03       	nop
800080d4:	f7 36 00 0e 	ld.ub	r6,r11[14]
800080d8:	f3 66 00 0e 	st.b	r9[14],r6
800080dc:	f7 36 00 0d 	ld.ub	r6,r11[13]
800080e0:	f3 66 00 0d 	st.b	r9[13],r6
800080e4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800080e8:	f3 66 00 0c 	st.b	r9[12],r6
800080ec:	f7 36 00 0b 	ld.ub	r6,r11[11]
800080f0:	f3 66 00 0b 	st.b	r9[11],r6
800080f4:	f7 36 00 0a 	ld.ub	r6,r11[10]
800080f8:	f3 66 00 0a 	st.b	r9[10],r6
800080fc:	f7 36 00 09 	ld.ub	r6,r11[9]
80008100:	f3 66 00 09 	st.b	r9[9],r6
80008104:	f7 36 00 08 	ld.ub	r6,r11[8]
80008108:	f3 66 00 08 	st.b	r9[8],r6
8000810c:	f7 36 00 07 	ld.ub	r6,r11[7]
80008110:	f3 66 00 07 	st.b	r9[7],r6
80008114:	f7 36 00 06 	ld.ub	r6,r11[6]
80008118:	f3 66 00 06 	st.b	r9[6],r6
8000811c:	f7 36 00 05 	ld.ub	r6,r11[5]
80008120:	f3 66 00 05 	st.b	r9[5],r6
80008124:	f7 36 00 04 	ld.ub	r6,r11[4]
80008128:	f3 66 00 04 	st.b	r9[4],r6
8000812c:	f7 36 00 03 	ld.ub	r6,r11[3]
80008130:	f3 66 00 03 	st.b	r9[3],r6
80008134:	f7 36 00 02 	ld.ub	r6,r11[2]
80008138:	f3 66 00 02 	st.b	r9[2],r6
8000813c:	f7 36 00 01 	ld.ub	r6,r11[1]
80008140:	f3 66 00 01 	st.b	r9[1],r6
80008144:	f7 36 00 00 	ld.ub	r6,r11[0]
80008148:	f3 66 00 00 	st.b	r9[0],r6
8000814c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008150:	20 1a       	sub	r10,1
80008152:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008156:	f8 0a 0b 09 	st.b	r12[r10],r9
8000815a:	cf b1       	brne	80008150 <memcpy+0x13a>
8000815c:	5e fc       	retal	r12

8000815e <memset>:
8000815e:	18 98       	mov	r8,r12
80008160:	c0 38       	rjmp	80008166 <memset+0x8>
80008162:	10 cb       	st.b	r8++,r11
80008164:	20 1a       	sub	r10,1
80008166:	58 0a       	cp.w	r10,0
80008168:	cf d1       	brne	80008162 <memset+0x4>
8000816a:	5e fc       	retal	r12

8000816c <_realloc_r>:
8000816c:	d4 31       	pushm	r0-r7,lr
8000816e:	20 1d       	sub	sp,4
80008170:	16 94       	mov	r4,r11
80008172:	18 92       	mov	r2,r12
80008174:	14 9b       	mov	r11,r10
80008176:	58 04       	cp.w	r4,0
80008178:	c0 51       	brne	80008182 <_realloc_r+0x16>
8000817a:	fe b0 fd 1f 	rcall	80007bb8 <_malloc_r>
8000817e:	18 95       	mov	r5,r12
80008180:	c5 39       	rjmp	80008426 <_realloc_r+0x2ba>
80008182:	50 0a       	stdsp	sp[0x0],r10
80008184:	fe b0 f2 ce 	rcall	80006720 <__malloc_lock>
80008188:	40 0b       	lddsp	r11,sp[0x0]
8000818a:	f6 c8 ff f5 	sub	r8,r11,-11
8000818e:	e8 c1 00 08 	sub	r1,r4,8
80008192:	10 96       	mov	r6,r8
80008194:	62 1c       	ld.w	r12,r1[0x4]
80008196:	e0 16 ff f8 	andl	r6,0xfff8
8000819a:	59 68       	cp.w	r8,22
8000819c:	f9 b6 08 10 	movls	r6,16
800081a0:	16 36       	cp.w	r6,r11
800081a2:	5f 38       	srlo	r8
800081a4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800081a8:	c0 50       	breq	800081b2 <_realloc_r+0x46>
800081aa:	30 c8       	mov	r8,12
800081ac:	30 05       	mov	r5,0
800081ae:	85 38       	st.w	r2[0xc],r8
800081b0:	c3 b9       	rjmp	80008426 <_realloc_r+0x2ba>
800081b2:	18 90       	mov	r0,r12
800081b4:	e0 10 ff fc 	andl	r0,0xfffc
800081b8:	0c 30       	cp.w	r0,r6
800081ba:	e0 84 01 0b 	brge	800083d0 <_realloc_r+0x264>
800081be:	e0 68 05 4c 	mov	r8,1356
800081c2:	e2 00 00 09 	add	r9,r1,r0
800081c6:	70 25       	ld.w	r5,r8[0x8]
800081c8:	0a 39       	cp.w	r9,r5
800081ca:	c0 90       	breq	800081dc <_realloc_r+0x70>
800081cc:	72 1a       	ld.w	r10,r9[0x4]
800081ce:	a1 ca       	cbr	r10,0x0
800081d0:	f2 0a 00 0a 	add	r10,r9,r10
800081d4:	74 1a       	ld.w	r10,r10[0x4]
800081d6:	ed ba 00 00 	bld	r10,0x0
800081da:	c2 20       	breq	8000821e <_realloc_r+0xb2>
800081dc:	72 1a       	ld.w	r10,r9[0x4]
800081de:	e0 1a ff fc 	andl	r10,0xfffc
800081e2:	f4 00 00 03 	add	r3,r10,r0
800081e6:	0a 39       	cp.w	r9,r5
800081e8:	c1 31       	brne	8000820e <_realloc_r+0xa2>
800081ea:	ec c7 ff f0 	sub	r7,r6,-16
800081ee:	0e 33       	cp.w	r3,r7
800081f0:	c1 95       	brlt	80008222 <_realloc_r+0xb6>
800081f2:	e2 06 00 09 	add	r9,r1,r6
800081f6:	0c 13       	sub	r3,r6
800081f8:	a1 a3       	sbr	r3,0x0
800081fa:	93 13       	st.w	r9[0x4],r3
800081fc:	91 29       	st.w	r8[0x8],r9
800081fe:	04 9c       	mov	r12,r2
80008200:	62 18       	ld.w	r8,r1[0x4]
80008202:	08 95       	mov	r5,r4
80008204:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008208:	10 46       	or	r6,r8
8000820a:	83 16       	st.w	r1[0x4],r6
8000820c:	c0 b9       	rjmp	80008422 <_realloc_r+0x2b6>
8000820e:	0c 33       	cp.w	r3,r6
80008210:	c0 95       	brlt	80008222 <_realloc_r+0xb6>
80008212:	72 28       	ld.w	r8,r9[0x8]
80008214:	02 97       	mov	r7,r1
80008216:	72 39       	ld.w	r9,r9[0xc]
80008218:	93 28       	st.w	r9[0x8],r8
8000821a:	91 39       	st.w	r8[0xc],r9
8000821c:	cd c8       	rjmp	800083d4 <_realloc_r+0x268>
8000821e:	30 0a       	mov	r10,0
80008220:	14 99       	mov	r9,r10
80008222:	ed bc 00 00 	bld	r12,0x0
80008226:	e0 80 00 95 	breq	80008350 <_realloc_r+0x1e4>
8000822a:	62 07       	ld.w	r7,r1[0x0]
8000822c:	e2 07 01 07 	sub	r7,r1,r7
80008230:	6e 1c       	ld.w	r12,r7[0x4]
80008232:	e0 1c ff fc 	andl	r12,0xfffc
80008236:	58 09       	cp.w	r9,0
80008238:	c5 60       	breq	800082e4 <_realloc_r+0x178>
8000823a:	f8 00 00 03 	add	r3,r12,r0
8000823e:	0a 39       	cp.w	r9,r5
80008240:	c4 81       	brne	800082d0 <_realloc_r+0x164>
80008242:	14 03       	add	r3,r10
80008244:	ec c9 ff f0 	sub	r9,r6,-16
80008248:	12 33       	cp.w	r3,r9
8000824a:	c4 d5       	brlt	800082e4 <_realloc_r+0x178>
8000824c:	6e 3a       	ld.w	r10,r7[0xc]
8000824e:	6e 29       	ld.w	r9,r7[0x8]
80008250:	95 29       	st.w	r10[0x8],r9
80008252:	93 3a       	st.w	r9[0xc],r10
80008254:	ee c5 ff f8 	sub	r5,r7,-8
80008258:	e0 ca 00 04 	sub	r10,r0,4
8000825c:	e0 4a 00 24 	cp.w	r10,36
80008260:	e0 8b 00 25 	brhi	800082aa <_realloc_r+0x13e>
80008264:	0a 99       	mov	r9,r5
80008266:	59 3a       	cp.w	r10,19
80008268:	e0 88 00 1a 	brls	8000829c <_realloc_r+0x130>
8000826c:	09 09       	ld.w	r9,r4++
8000826e:	8b 09       	st.w	r5[0x0],r9
80008270:	09 09       	ld.w	r9,r4++
80008272:	8f 39       	st.w	r7[0xc],r9
80008274:	ee c9 ff f0 	sub	r9,r7,-16
80008278:	59 ba       	cp.w	r10,27
8000827a:	e0 88 00 11 	brls	8000829c <_realloc_r+0x130>
8000827e:	09 0b       	ld.w	r11,r4++
80008280:	93 0b       	st.w	r9[0x0],r11
80008282:	09 09       	ld.w	r9,r4++
80008284:	8f 59       	st.w	r7[0x14],r9
80008286:	ee c9 ff e8 	sub	r9,r7,-24
8000828a:	e0 4a 00 24 	cp.w	r10,36
8000828e:	c0 71       	brne	8000829c <_realloc_r+0x130>
80008290:	09 0a       	ld.w	r10,r4++
80008292:	93 0a       	st.w	r9[0x0],r10
80008294:	ee c9 ff e0 	sub	r9,r7,-32
80008298:	09 0a       	ld.w	r10,r4++
8000829a:	8f 7a       	st.w	r7[0x1c],r10
8000829c:	09 0a       	ld.w	r10,r4++
8000829e:	12 aa       	st.w	r9++,r10
800082a0:	68 0a       	ld.w	r10,r4[0x0]
800082a2:	93 0a       	st.w	r9[0x0],r10
800082a4:	68 1a       	ld.w	r10,r4[0x4]
800082a6:	93 1a       	st.w	r9[0x4],r10
800082a8:	c0 78       	rjmp	800082b6 <_realloc_r+0x14a>
800082aa:	50 08       	stdsp	sp[0x0],r8
800082ac:	08 9b       	mov	r11,r4
800082ae:	0a 9c       	mov	r12,r5
800082b0:	e0 a0 1d 8f 	rcall	8000bdce <memmove>
800082b4:	40 08       	lddsp	r8,sp[0x0]
800082b6:	ee 06 00 09 	add	r9,r7,r6
800082ba:	0c 13       	sub	r3,r6
800082bc:	a1 a3       	sbr	r3,0x0
800082be:	93 13       	st.w	r9[0x4],r3
800082c0:	91 29       	st.w	r8[0x8],r9
800082c2:	04 9c       	mov	r12,r2
800082c4:	6e 18       	ld.w	r8,r7[0x4]
800082c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800082ca:	10 46       	or	r6,r8
800082cc:	8f 16       	st.w	r7[0x4],r6
800082ce:	ca a8       	rjmp	80008422 <_realloc_r+0x2b6>
800082d0:	14 03       	add	r3,r10
800082d2:	0c 33       	cp.w	r3,r6
800082d4:	c0 85       	brlt	800082e4 <_realloc_r+0x178>
800082d6:	72 28       	ld.w	r8,r9[0x8]
800082d8:	72 39       	ld.w	r9,r9[0xc]
800082da:	93 28       	st.w	r9[0x8],r8
800082dc:	91 39       	st.w	r8[0xc],r9
800082de:	6e 28       	ld.w	r8,r7[0x8]
800082e0:	6e 39       	ld.w	r9,r7[0xc]
800082e2:	c0 78       	rjmp	800082f0 <_realloc_r+0x184>
800082e4:	f8 00 00 03 	add	r3,r12,r0
800082e8:	0c 33       	cp.w	r3,r6
800082ea:	c3 35       	brlt	80008350 <_realloc_r+0x1e4>
800082ec:	6e 39       	ld.w	r9,r7[0xc]
800082ee:	6e 28       	ld.w	r8,r7[0x8]
800082f0:	93 28       	st.w	r9[0x8],r8
800082f2:	91 39       	st.w	r8[0xc],r9
800082f4:	e0 ca 00 04 	sub	r10,r0,4
800082f8:	ee cc ff f8 	sub	r12,r7,-8
800082fc:	e0 4a 00 24 	cp.w	r10,36
80008300:	e0 8b 00 24 	brhi	80008348 <_realloc_r+0x1dc>
80008304:	59 3a       	cp.w	r10,19
80008306:	e0 88 00 1a 	brls	8000833a <_realloc_r+0x1ce>
8000830a:	09 08       	ld.w	r8,r4++
8000830c:	99 08       	st.w	r12[0x0],r8
8000830e:	09 08       	ld.w	r8,r4++
80008310:	8f 38       	st.w	r7[0xc],r8
80008312:	ee cc ff f0 	sub	r12,r7,-16
80008316:	59 ba       	cp.w	r10,27
80008318:	e0 88 00 11 	brls	8000833a <_realloc_r+0x1ce>
8000831c:	09 08       	ld.w	r8,r4++
8000831e:	99 08       	st.w	r12[0x0],r8
80008320:	09 08       	ld.w	r8,r4++
80008322:	8f 58       	st.w	r7[0x14],r8
80008324:	ee cc ff e8 	sub	r12,r7,-24
80008328:	e0 4a 00 24 	cp.w	r10,36
8000832c:	c0 71       	brne	8000833a <_realloc_r+0x1ce>
8000832e:	09 08       	ld.w	r8,r4++
80008330:	99 08       	st.w	r12[0x0],r8
80008332:	ee cc ff e0 	sub	r12,r7,-32
80008336:	09 08       	ld.w	r8,r4++
80008338:	8f 78       	st.w	r7[0x1c],r8
8000833a:	09 08       	ld.w	r8,r4++
8000833c:	18 a8       	st.w	r12++,r8
8000833e:	68 08       	ld.w	r8,r4[0x0]
80008340:	99 08       	st.w	r12[0x0],r8
80008342:	68 18       	ld.w	r8,r4[0x4]
80008344:	99 18       	st.w	r12[0x4],r8
80008346:	c4 78       	rjmp	800083d4 <_realloc_r+0x268>
80008348:	08 9b       	mov	r11,r4
8000834a:	e0 a0 1d 42 	rcall	8000bdce <memmove>
8000834e:	c4 38       	rjmp	800083d4 <_realloc_r+0x268>
80008350:	04 9c       	mov	r12,r2
80008352:	fe b0 fc 33 	rcall	80007bb8 <_malloc_r>
80008356:	18 95       	mov	r5,r12
80008358:	c3 a0       	breq	800083cc <_realloc_r+0x260>
8000835a:	62 18       	ld.w	r8,r1[0x4]
8000835c:	f8 c9 00 08 	sub	r9,r12,8
80008360:	a1 c8       	cbr	r8,0x0
80008362:	e2 08 00 08 	add	r8,r1,r8
80008366:	10 39       	cp.w	r9,r8
80008368:	c0 71       	brne	80008376 <_realloc_r+0x20a>
8000836a:	72 13       	ld.w	r3,r9[0x4]
8000836c:	02 97       	mov	r7,r1
8000836e:	e0 13 ff fc 	andl	r3,0xfffc
80008372:	00 03       	add	r3,r0
80008374:	c3 08       	rjmp	800083d4 <_realloc_r+0x268>
80008376:	e0 ca 00 04 	sub	r10,r0,4
8000837a:	e0 4a 00 24 	cp.w	r10,36
8000837e:	e0 8b 00 20 	brhi	800083be <_realloc_r+0x252>
80008382:	08 99       	mov	r9,r4
80008384:	18 98       	mov	r8,r12
80008386:	59 3a       	cp.w	r10,19
80008388:	e0 88 00 14 	brls	800083b0 <_realloc_r+0x244>
8000838c:	13 0b       	ld.w	r11,r9++
8000838e:	10 ab       	st.w	r8++,r11
80008390:	13 0b       	ld.w	r11,r9++
80008392:	10 ab       	st.w	r8++,r11
80008394:	59 ba       	cp.w	r10,27
80008396:	e0 88 00 0d 	brls	800083b0 <_realloc_r+0x244>
8000839a:	13 0b       	ld.w	r11,r9++
8000839c:	10 ab       	st.w	r8++,r11
8000839e:	13 0b       	ld.w	r11,r9++
800083a0:	10 ab       	st.w	r8++,r11
800083a2:	e0 4a 00 24 	cp.w	r10,36
800083a6:	c0 51       	brne	800083b0 <_realloc_r+0x244>
800083a8:	13 0a       	ld.w	r10,r9++
800083aa:	10 aa       	st.w	r8++,r10
800083ac:	13 0a       	ld.w	r10,r9++
800083ae:	10 aa       	st.w	r8++,r10
800083b0:	13 0a       	ld.w	r10,r9++
800083b2:	10 aa       	st.w	r8++,r10
800083b4:	72 0a       	ld.w	r10,r9[0x0]
800083b6:	91 0a       	st.w	r8[0x0],r10
800083b8:	72 19       	ld.w	r9,r9[0x4]
800083ba:	91 19       	st.w	r8[0x4],r9
800083bc:	c0 48       	rjmp	800083c4 <_realloc_r+0x258>
800083be:	08 9b       	mov	r11,r4
800083c0:	e0 a0 1d 07 	rcall	8000bdce <memmove>
800083c4:	08 9b       	mov	r11,r4
800083c6:	04 9c       	mov	r12,r2
800083c8:	e0 a0 1a 60 	rcall	8000b888 <_free_r>
800083cc:	04 9c       	mov	r12,r2
800083ce:	c2 a8       	rjmp	80008422 <_realloc_r+0x2b6>
800083d0:	00 93       	mov	r3,r0
800083d2:	02 97       	mov	r7,r1
800083d4:	e6 06 01 09 	sub	r9,r3,r6
800083d8:	6e 18       	ld.w	r8,r7[0x4]
800083da:	58 f9       	cp.w	r9,15
800083dc:	e0 88 00 16 	brls	80008408 <_realloc_r+0x29c>
800083e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800083e4:	ed e8 10 08 	or	r8,r6,r8
800083e8:	8f 18       	st.w	r7[0x4],r8
800083ea:	12 98       	mov	r8,r9
800083ec:	a1 a8       	sbr	r8,0x0
800083ee:	ee 06 00 0b 	add	r11,r7,r6
800083f2:	f6 09 00 09 	add	r9,r11,r9
800083f6:	97 18       	st.w	r11[0x4],r8
800083f8:	72 18       	ld.w	r8,r9[0x4]
800083fa:	a1 a8       	sbr	r8,0x0
800083fc:	2f 8b       	sub	r11,-8
800083fe:	93 18       	st.w	r9[0x4],r8
80008400:	04 9c       	mov	r12,r2
80008402:	e0 a0 1a 43 	rcall	8000b888 <_free_r>
80008406:	c0 b8       	rjmp	8000841c <_realloc_r+0x2b0>
80008408:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000840c:	e7 e8 10 08 	or	r8,r3,r8
80008410:	8f 18       	st.w	r7[0x4],r8
80008412:	ee 03 00 03 	add	r3,r7,r3
80008416:	66 18       	ld.w	r8,r3[0x4]
80008418:	a1 a8       	sbr	r8,0x0
8000841a:	87 18       	st.w	r3[0x4],r8
8000841c:	04 9c       	mov	r12,r2
8000841e:	ee c5 ff f8 	sub	r5,r7,-8
80008422:	fe b0 f1 85 	rcall	8000672c <__malloc_unlock>
80008426:	0a 9c       	mov	r12,r5
80008428:	2f fd       	sub	sp,-4
8000842a:	d8 32       	popm	r0-r7,pc

8000842c <_sbrk_r>:
8000842c:	d4 21       	pushm	r4-r7,lr
8000842e:	30 08       	mov	r8,0
80008430:	18 97       	mov	r7,r12
80008432:	e0 66 54 24 	mov	r6,21540
80008436:	16 9c       	mov	r12,r11
80008438:	8d 08       	st.w	r6[0x0],r8
8000843a:	c8 5c       	rcall	80008544 <_sbrk>
8000843c:	5b fc       	cp.w	r12,-1
8000843e:	c0 51       	brne	80008448 <_sbrk_r+0x1c>
80008440:	6c 08       	ld.w	r8,r6[0x0]
80008442:	58 08       	cp.w	r8,0
80008444:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008448:	d8 22       	popm	r4-r7,pc
8000844a:	d7 03       	nop

8000844c <sprintf>:
8000844c:	d4 01       	pushm	lr
8000844e:	21 7d       	sub	sp,92
80008450:	e0 68 ff ff 	mov	r8,65535
80008454:	ea 18 7f ff 	orh	r8,0x7fff
80008458:	50 58       	stdsp	sp[0x14],r8
8000845a:	50 28       	stdsp	sp[0x8],r8
8000845c:	e0 68 02 08 	mov	r8,520
80008460:	ba 68       	st.h	sp[0xc],r8
80008462:	3f f8       	mov	r8,-1
80008464:	ba 78       	st.h	sp[0xe],r8
80008466:	e0 68 0a 4c 	mov	r8,2636
8000846a:	50 4c       	stdsp	sp[0x10],r12
8000846c:	16 9a       	mov	r10,r11
8000846e:	50 0c       	stdsp	sp[0x0],r12
80008470:	fa c9 ff a0 	sub	r9,sp,-96
80008474:	70 0c       	ld.w	r12,r8[0x0]
80008476:	1a 9b       	mov	r11,sp
80008478:	e0 a0 02 1a 	rcall	800088ac <_vfprintf_r>
8000847c:	30 09       	mov	r9,0
8000847e:	40 08       	lddsp	r8,sp[0x0]
80008480:	b0 89       	st.b	r8[0x0],r9
80008482:	2e 9d       	sub	sp,-92
80008484:	d8 02       	popm	pc
80008486:	d7 03       	nop

80008488 <strncpy>:
80008488:	30 08       	mov	r8,0
8000848a:	10 3a       	cp.w	r10,r8
8000848c:	5e 0c       	reteq	r12
8000848e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008492:	f8 08 0b 09 	st.b	r12[r8],r9
80008496:	2f f8       	sub	r8,-1
80008498:	58 09       	cp.w	r9,0
8000849a:	cf 81       	brne	8000848a <strncpy+0x2>
8000849c:	10 3a       	cp.w	r10,r8
8000849e:	5e 0c       	reteq	r12
800084a0:	f8 08 0b 09 	st.b	r12[r8],r9
800084a4:	2f f8       	sub	r8,-1
800084a6:	cf bb       	rjmp	8000849c <strncpy+0x14>

800084a8 <_close>:
800084a8:	30 28       	mov	r8,2
800084aa:	d6 73       	breakpoint
800084ac:	3f fc       	mov	r12,-1
800084ae:	35 8b       	mov	r11,88
800084b0:	58 0c       	cp.w	r12,0
800084b2:	5e 4c       	retge	r12
800084b4:	e0 6a 54 24 	mov	r10,21540
800084b8:	95 0b       	st.w	r10[0x0],r11
800084ba:	5e fc       	retal	r12

800084bc <_lseek>:
800084bc:	30 58       	mov	r8,5
800084be:	d6 73       	breakpoint
800084c0:	3f fc       	mov	r12,-1
800084c2:	35 8b       	mov	r11,88
800084c4:	58 0c       	cp.w	r12,0
800084c6:	5e 4c       	retge	r12
800084c8:	e0 6a 54 24 	mov	r10,21540
800084cc:	95 0b       	st.w	r10[0x0],r11
800084ce:	5e fc       	retal	r12

800084d0 <isatty>:
800084d0:	30 b8       	mov	r8,11
800084d2:	d6 73       	breakpoint
800084d4:	3f fc       	mov	r12,-1
800084d6:	35 8b       	mov	r11,88
800084d8:	58 0c       	cp.w	r12,0
800084da:	5e 4c       	retge	r12
800084dc:	e0 6a 54 24 	mov	r10,21540
800084e0:	95 0b       	st.w	r10[0x0],r11
800084e2:	5e fc       	retal	r12

800084e4 <_fstat_host>:
800084e4:	30 98       	mov	r8,9
800084e6:	d6 73       	breakpoint
800084e8:	3f fc       	mov	r12,-1
800084ea:	35 8b       	mov	r11,88
800084ec:	58 0c       	cp.w	r12,0
800084ee:	5e 4c       	retge	r12
800084f0:	e0 6a 54 24 	mov	r10,21540
800084f4:	95 0b       	st.w	r10[0x0],r11
800084f6:	5e fc       	retal	r12

800084f8 <_fstat>:
800084f8:	d4 21       	pushm	r4-r7,lr
800084fa:	21 0d       	sub	sp,64
800084fc:	16 97       	mov	r7,r11
800084fe:	1a 9b       	mov	r11,sp
80008500:	cf 2f       	rcall	800084e4 <_fstat_host>
80008502:	c0 34       	brge	80008508 <_fstat+0x10>
80008504:	3f fc       	mov	r12,-1
80008506:	c1 c8       	rjmp	8000853e <_fstat+0x46>
80008508:	40 08       	lddsp	r8,sp[0x0]
8000850a:	ae 08       	st.h	r7[0x0],r8
8000850c:	40 18       	lddsp	r8,sp[0x4]
8000850e:	ae 18       	st.h	r7[0x2],r8
80008510:	40 28       	lddsp	r8,sp[0x8]
80008512:	8f 18       	st.w	r7[0x4],r8
80008514:	40 38       	lddsp	r8,sp[0xc]
80008516:	ae 48       	st.h	r7[0x8],r8
80008518:	40 48       	lddsp	r8,sp[0x10]
8000851a:	ae 58       	st.h	r7[0xa],r8
8000851c:	40 58       	lddsp	r8,sp[0x14]
8000851e:	ae 68       	st.h	r7[0xc],r8
80008520:	40 68       	lddsp	r8,sp[0x18]
80008522:	ae 78       	st.h	r7[0xe],r8
80008524:	40 88       	lddsp	r8,sp[0x20]
80008526:	8f 48       	st.w	r7[0x10],r8
80008528:	40 a8       	lddsp	r8,sp[0x28]
8000852a:	8f b8       	st.w	r7[0x2c],r8
8000852c:	40 c8       	lddsp	r8,sp[0x30]
8000852e:	8f c8       	st.w	r7[0x30],r8
80008530:	40 d8       	lddsp	r8,sp[0x34]
80008532:	8f 58       	st.w	r7[0x14],r8
80008534:	40 e8       	lddsp	r8,sp[0x38]
80008536:	30 0c       	mov	r12,0
80008538:	8f 78       	st.w	r7[0x1c],r8
8000853a:	40 f8       	lddsp	r8,sp[0x3c]
8000853c:	8f 98       	st.w	r7[0x24],r8
8000853e:	2f 0d       	sub	sp,-64
80008540:	d8 22       	popm	r4-r7,pc
80008542:	d7 03       	nop

80008544 <_sbrk>:
80008544:	d4 01       	pushm	lr
80008546:	e0 68 0d f8 	mov	r8,3576
8000854a:	70 09       	ld.w	r9,r8[0x0]
8000854c:	58 09       	cp.w	r9,0
8000854e:	c0 41       	brne	80008556 <_sbrk+0x12>
80008550:	e0 69 54 28 	mov	r9,21544
80008554:	91 09       	st.w	r8[0x0],r9
80008556:	e0 69 0d f8 	mov	r9,3576
8000855a:	e0 7a 70 00 	mov	r10,94208
8000855e:	72 08       	ld.w	r8,r9[0x0]
80008560:	f0 0c 00 0c 	add	r12,r8,r12
80008564:	14 3c       	cp.w	r12,r10
80008566:	e0 8b 00 04 	brhi	8000856e <_sbrk+0x2a>
8000856a:	93 0c       	st.w	r9[0x0],r12
8000856c:	c0 68       	rjmp	80008578 <_sbrk+0x34>
8000856e:	e0 a0 18 15 	rcall	8000b598 <__errno>
80008572:	30 c8       	mov	r8,12
80008574:	99 08       	st.w	r12[0x0],r8
80008576:	3f f8       	mov	r8,-1
80008578:	10 9c       	mov	r12,r8
8000857a:	d8 02       	popm	pc

8000857c <get_arg>:
8000857c:	d4 31       	pushm	r0-r7,lr
8000857e:	20 8d       	sub	sp,32
80008580:	fa c4 ff bc 	sub	r4,sp,-68
80008584:	50 4b       	stdsp	sp[0x10],r11
80008586:	68 2e       	ld.w	lr,r4[0x8]
80008588:	50 58       	stdsp	sp[0x14],r8
8000858a:	12 96       	mov	r6,r9
8000858c:	7c 0b       	ld.w	r11,lr[0x0]
8000858e:	70 05       	ld.w	r5,r8[0x0]
80008590:	50 6e       	stdsp	sp[0x18],lr
80008592:	58 0b       	cp.w	r11,0
80008594:	f4 0b 17 00 	moveq	r11,r10
80008598:	68 03       	ld.w	r3,r4[0x0]
8000859a:	68 11       	ld.w	r1,r4[0x4]
8000859c:	40 49       	lddsp	r9,sp[0x10]
8000859e:	30 08       	mov	r8,0
800085a0:	c2 89       	rjmp	800087f0 <get_arg+0x274>
800085a2:	2f fb       	sub	r11,-1
800085a4:	32 5c       	mov	r12,37
800085a6:	17 8a       	ld.ub	r10,r11[0x0]
800085a8:	f8 0a 18 00 	cp.b	r10,r12
800085ac:	5f 1e       	srne	lr
800085ae:	f0 0a 18 00 	cp.b	r10,r8
800085b2:	5f 1c       	srne	r12
800085b4:	fd ec 00 0c 	and	r12,lr,r12
800085b8:	f0 0c 18 00 	cp.b	r12,r8
800085bc:	cf 31       	brne	800085a2 <get_arg+0x26>
800085be:	58 0a       	cp.w	r10,0
800085c0:	e0 80 01 25 	breq	8000880a <get_arg+0x28e>
800085c4:	30 0c       	mov	r12,0
800085c6:	3f fa       	mov	r10,-1
800085c8:	18 90       	mov	r0,r12
800085ca:	50 3a       	stdsp	sp[0xc],r10
800085cc:	18 94       	mov	r4,r12
800085ce:	18 92       	mov	r2,r12
800085d0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800085d4:	16 97       	mov	r7,r11
800085d6:	50 7c       	stdsp	sp[0x1c],r12
800085d8:	fe cc 9d 38 	sub	r12,pc,-25288
800085dc:	0f 3a       	ld.ub	r10,r7++
800085de:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800085e2:	40 7c       	lddsp	r12,sp[0x1c]
800085e4:	1c 0c       	add	r12,lr
800085e6:	fe ce 9e 0e 	sub	lr,pc,-25074
800085ea:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800085ee:	20 1e       	sub	lr,1
800085f0:	50 0e       	stdsp	sp[0x0],lr
800085f2:	fe ce 9e 86 	sub	lr,pc,-24954
800085f6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800085fa:	50 7c       	stdsp	sp[0x1c],r12
800085fc:	40 0c       	lddsp	r12,sp[0x0]
800085fe:	58 7c       	cp.w	r12,7
80008600:	e0 8b 00 f1 	brhi	800087e2 <get_arg+0x266>
80008604:	fe ce a0 38 	sub	lr,pc,-24520
80008608:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000860c:	36 8b       	mov	r11,104
8000860e:	f6 0a 18 00 	cp.b	r10,r11
80008612:	e0 80 00 e8 	breq	800087e2 <get_arg+0x266>
80008616:	37 1b       	mov	r11,113
80008618:	f6 0a 18 00 	cp.b	r10,r11
8000861c:	c0 70       	breq	8000862a <get_arg+0xae>
8000861e:	34 cb       	mov	r11,76
80008620:	f6 0a 18 00 	cp.b	r10,r11
80008624:	c0 51       	brne	8000862e <get_arg+0xb2>
80008626:	a3 b4       	sbr	r4,0x3
80008628:	cd d8       	rjmp	800087e2 <get_arg+0x266>
8000862a:	a5 b4       	sbr	r4,0x5
8000862c:	cd b8       	rjmp	800087e2 <get_arg+0x266>
8000862e:	08 9a       	mov	r10,r4
80008630:	0e 9b       	mov	r11,r7
80008632:	a5 aa       	sbr	r10,0x4
80008634:	17 3c       	ld.ub	r12,r11++
80008636:	a5 b4       	sbr	r4,0x5
80008638:	36 ce       	mov	lr,108
8000863a:	fc 0c 18 00 	cp.b	r12,lr
8000863e:	e0 80 00 d3 	breq	800087e4 <get_arg+0x268>
80008642:	14 94       	mov	r4,r10
80008644:	cc f8       	rjmp	800087e2 <get_arg+0x266>
80008646:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000864a:	36 7c       	mov	r12,103
8000864c:	f8 0a 18 00 	cp.b	r10,r12
80008650:	e0 8b 00 27 	brhi	8000869e <get_arg+0x122>
80008654:	36 5b       	mov	r11,101
80008656:	f6 0a 18 00 	cp.b	r10,r11
8000865a:	c4 82       	brcc	800086ea <get_arg+0x16e>
8000865c:	34 fb       	mov	r11,79
8000865e:	f6 0a 18 00 	cp.b	r10,r11
80008662:	c4 80       	breq	800086f2 <get_arg+0x176>
80008664:	e0 8b 00 0c 	brhi	8000867c <get_arg+0x100>
80008668:	34 5b       	mov	r11,69
8000866a:	f6 0a 18 00 	cp.b	r10,r11
8000866e:	c3 e0       	breq	800086ea <get_arg+0x16e>
80008670:	34 7b       	mov	r11,71
80008672:	f6 0a 18 00 	cp.b	r10,r11
80008676:	c3 a0       	breq	800086ea <get_arg+0x16e>
80008678:	34 4b       	mov	r11,68
8000867a:	c0 88       	rjmp	8000868a <get_arg+0x10e>
8000867c:	35 8b       	mov	r11,88
8000867e:	f6 0a 18 00 	cp.b	r10,r11
80008682:	c2 c0       	breq	800086da <get_arg+0x15e>
80008684:	e0 8b 00 07 	brhi	80008692 <get_arg+0x116>
80008688:	35 5b       	mov	r11,85
8000868a:	f6 0a 18 00 	cp.b	r10,r11
8000868e:	c3 51       	brne	800086f8 <get_arg+0x17c>
80008690:	c3 18       	rjmp	800086f2 <get_arg+0x176>
80008692:	36 3b       	mov	r11,99
80008694:	f6 0a 18 00 	cp.b	r10,r11
80008698:	c2 f0       	breq	800086f6 <get_arg+0x17a>
8000869a:	36 4b       	mov	r11,100
8000869c:	c0 e8       	rjmp	800086b8 <get_arg+0x13c>
8000869e:	37 0b       	mov	r11,112
800086a0:	f6 0a 18 00 	cp.b	r10,r11
800086a4:	c2 50       	breq	800086ee <get_arg+0x172>
800086a6:	e0 8b 00 0d 	brhi	800086c0 <get_arg+0x144>
800086aa:	36 eb       	mov	r11,110
800086ac:	f6 0a 18 00 	cp.b	r10,r11
800086b0:	c1 f0       	breq	800086ee <get_arg+0x172>
800086b2:	e0 8b 00 14 	brhi	800086da <get_arg+0x15e>
800086b6:	36 9b       	mov	r11,105
800086b8:	f6 0a 18 00 	cp.b	r10,r11
800086bc:	c1 e1       	brne	800086f8 <get_arg+0x17c>
800086be:	c0 e8       	rjmp	800086da <get_arg+0x15e>
800086c0:	37 5b       	mov	r11,117
800086c2:	f6 0a 18 00 	cp.b	r10,r11
800086c6:	c0 a0       	breq	800086da <get_arg+0x15e>
800086c8:	37 8b       	mov	r11,120
800086ca:	f6 0a 18 00 	cp.b	r10,r11
800086ce:	c0 60       	breq	800086da <get_arg+0x15e>
800086d0:	37 3b       	mov	r11,115
800086d2:	f6 0a 18 00 	cp.b	r10,r11
800086d6:	c1 11       	brne	800086f8 <get_arg+0x17c>
800086d8:	c0 b8       	rjmp	800086ee <get_arg+0x172>
800086da:	ed b4 00 04 	bld	r4,0x4
800086de:	c0 a0       	breq	800086f2 <get_arg+0x176>
800086e0:	ed b4 00 05 	bld	r4,0x5
800086e4:	c0 91       	brne	800086f6 <get_arg+0x17a>
800086e6:	30 20       	mov	r0,2
800086e8:	c0 88       	rjmp	800086f8 <get_arg+0x17c>
800086ea:	30 40       	mov	r0,4
800086ec:	c0 68       	rjmp	800086f8 <get_arg+0x17c>
800086ee:	30 30       	mov	r0,3
800086f0:	c0 48       	rjmp	800086f8 <get_arg+0x17c>
800086f2:	30 10       	mov	r0,1
800086f4:	c0 28       	rjmp	800086f8 <get_arg+0x17c>
800086f6:	30 00       	mov	r0,0
800086f8:	40 3b       	lddsp	r11,sp[0xc]
800086fa:	5b fb       	cp.w	r11,-1
800086fc:	c0 40       	breq	80008704 <get_arg+0x188>
800086fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008702:	c7 08       	rjmp	800087e2 <get_arg+0x266>
80008704:	58 60       	cp.w	r0,6
80008706:	e0 8b 00 6e 	brhi	800087e2 <get_arg+0x266>
8000870a:	6c 0a       	ld.w	r10,r6[0x0]
8000870c:	ea cc ff ff 	sub	r12,r5,-1
80008710:	fe ce a1 24 	sub	lr,pc,-24284
80008714:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008718:	f4 cb ff f8 	sub	r11,r10,-8
8000871c:	8d 0b       	st.w	r6[0x0],r11
8000871e:	f4 ea 00 00 	ld.d	r10,r10[0]
80008722:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008726:	c0 f8       	rjmp	80008744 <get_arg+0x1c8>
80008728:	f4 cb ff fc 	sub	r11,r10,-4
8000872c:	8d 0b       	st.w	r6[0x0],r11
8000872e:	74 0a       	ld.w	r10,r10[0x0]
80008730:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008734:	c0 88       	rjmp	80008744 <get_arg+0x1c8>
80008736:	f4 cb ff f8 	sub	r11,r10,-8
8000873a:	8d 0b       	st.w	r6[0x0],r11
8000873c:	f4 ea 00 00 	ld.d	r10,r10[0]
80008740:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008744:	0e 9b       	mov	r11,r7
80008746:	18 95       	mov	r5,r12
80008748:	c4 e8       	rjmp	800087e4 <get_arg+0x268>
8000874a:	62 0a       	ld.w	r10,r1[0x0]
8000874c:	5b fa       	cp.w	r10,-1
8000874e:	c0 b1       	brne	80008764 <get_arg+0x1e8>
80008750:	50 19       	stdsp	sp[0x4],r9
80008752:	50 28       	stdsp	sp[0x8],r8
80008754:	e0 6a 00 80 	mov	r10,128
80008758:	30 0b       	mov	r11,0
8000875a:	02 9c       	mov	r12,r1
8000875c:	fe b0 fd 01 	rcall	8000815e <memset>
80008760:	40 28       	lddsp	r8,sp[0x8]
80008762:	40 19       	lddsp	r9,sp[0x4]
80008764:	e4 cc 00 01 	sub	r12,r2,1
80008768:	0e 9b       	mov	r11,r7
8000876a:	50 3c       	stdsp	sp[0xc],r12
8000876c:	f2 0c 0c 49 	max	r9,r9,r12
80008770:	c3 a8       	rjmp	800087e4 <get_arg+0x268>
80008772:	62 0a       	ld.w	r10,r1[0x0]
80008774:	5b fa       	cp.w	r10,-1
80008776:	c0 b1       	brne	8000878c <get_arg+0x210>
80008778:	50 19       	stdsp	sp[0x4],r9
8000877a:	50 28       	stdsp	sp[0x8],r8
8000877c:	e0 6a 00 80 	mov	r10,128
80008780:	30 0b       	mov	r11,0
80008782:	02 9c       	mov	r12,r1
80008784:	fe b0 fc ed 	rcall	8000815e <memset>
80008788:	40 28       	lddsp	r8,sp[0x8]
8000878a:	40 19       	lddsp	r9,sp[0x4]
8000878c:	20 12       	sub	r2,1
8000878e:	30 0a       	mov	r10,0
80008790:	0e 9b       	mov	r11,r7
80008792:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008796:	f2 02 0c 49 	max	r9,r9,r2
8000879a:	c2 58       	rjmp	800087e4 <get_arg+0x268>
8000879c:	16 97       	mov	r7,r11
8000879e:	6c 0a       	ld.w	r10,r6[0x0]
800087a0:	f4 cb ff fc 	sub	r11,r10,-4
800087a4:	8d 0b       	st.w	r6[0x0],r11
800087a6:	74 0a       	ld.w	r10,r10[0x0]
800087a8:	0e 9b       	mov	r11,r7
800087aa:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800087ae:	2f f5       	sub	r5,-1
800087b0:	c1 a8       	rjmp	800087e4 <get_arg+0x268>
800087b2:	f4 c2 00 30 	sub	r2,r10,48
800087b6:	c0 68       	rjmp	800087c2 <get_arg+0x246>
800087b8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800087bc:	2f f7       	sub	r7,-1
800087be:	f4 02 00 12 	add	r2,r10,r2<<0x1
800087c2:	0f 8a       	ld.ub	r10,r7[0x0]
800087c4:	58 0a       	cp.w	r10,0
800087c6:	c0 e0       	breq	800087e2 <get_arg+0x266>
800087c8:	23 0a       	sub	r10,48
800087ca:	58 9a       	cp.w	r10,9
800087cc:	fe 98 ff f6 	brls	800087b8 <get_arg+0x23c>
800087d0:	c0 98       	rjmp	800087e2 <get_arg+0x266>
800087d2:	2f f7       	sub	r7,-1
800087d4:	0f 8a       	ld.ub	r10,r7[0x0]
800087d6:	58 0a       	cp.w	r10,0
800087d8:	c0 50       	breq	800087e2 <get_arg+0x266>
800087da:	23 0a       	sub	r10,48
800087dc:	58 9a       	cp.w	r10,9
800087de:	fe 98 ff fa 	brls	800087d2 <get_arg+0x256>
800087e2:	0e 9b       	mov	r11,r7
800087e4:	40 7c       	lddsp	r12,sp[0x1c]
800087e6:	30 ba       	mov	r10,11
800087e8:	f4 0c 18 00 	cp.b	r12,r10
800087ec:	fe 91 fe f2 	brne	800085d0 <get_arg+0x54>
800087f0:	40 42       	lddsp	r2,sp[0x10]
800087f2:	17 8c       	ld.ub	r12,r11[0x0]
800087f4:	0a 32       	cp.w	r2,r5
800087f6:	5f 4a       	srge	r10
800087f8:	f0 0c 18 00 	cp.b	r12,r8
800087fc:	5f 1c       	srne	r12
800087fe:	f9 ea 00 0a 	and	r10,r12,r10
80008802:	f0 0a 18 00 	cp.b	r10,r8
80008806:	fe 91 fe cf 	brne	800085a4 <get_arg+0x28>
8000880a:	30 08       	mov	r8,0
8000880c:	40 4e       	lddsp	lr,sp[0x10]
8000880e:	17 8a       	ld.ub	r10,r11[0x0]
80008810:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008814:	f0 0a 18 00 	cp.b	r10,r8
80008818:	fc 09 17 10 	movne	r9,lr
8000881c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008820:	06 9e       	mov	lr,r3
80008822:	c2 a8       	rjmp	80008876 <get_arg+0x2fa>
80008824:	62 0a       	ld.w	r10,r1[0x0]
80008826:	58 3a       	cp.w	r10,3
80008828:	c1 e0       	breq	80008864 <get_arg+0x2e8>
8000882a:	e0 89 00 07 	brgt	80008838 <get_arg+0x2bc>
8000882e:	58 1a       	cp.w	r10,1
80008830:	c1 a0       	breq	80008864 <get_arg+0x2e8>
80008832:	58 2a       	cp.w	r10,2
80008834:	c1 81       	brne	80008864 <get_arg+0x2e8>
80008836:	c0 58       	rjmp	80008840 <get_arg+0x2c4>
80008838:	58 5a       	cp.w	r10,5
8000883a:	c0 c0       	breq	80008852 <get_arg+0x2d6>
8000883c:	c0 b5       	brlt	80008852 <get_arg+0x2d6>
8000883e:	c1 38       	rjmp	80008864 <get_arg+0x2e8>
80008840:	6c 0a       	ld.w	r10,r6[0x0]
80008842:	f4 cc ff f8 	sub	r12,r10,-8
80008846:	8d 0c       	st.w	r6[0x0],r12
80008848:	f4 e2 00 00 	ld.d	r2,r10[0]
8000884c:	f0 e3 00 00 	st.d	r8[0],r2
80008850:	c1 08       	rjmp	80008870 <get_arg+0x2f4>
80008852:	6c 0a       	ld.w	r10,r6[0x0]
80008854:	f4 cc ff f8 	sub	r12,r10,-8
80008858:	8d 0c       	st.w	r6[0x0],r12
8000885a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000885e:	f0 e3 00 00 	st.d	r8[0],r2
80008862:	c0 78       	rjmp	80008870 <get_arg+0x2f4>
80008864:	6c 0a       	ld.w	r10,r6[0x0]
80008866:	f4 cc ff fc 	sub	r12,r10,-4
8000886a:	8d 0c       	st.w	r6[0x0],r12
8000886c:	74 0a       	ld.w	r10,r10[0x0]
8000886e:	91 0a       	st.w	r8[0x0],r10
80008870:	2f f5       	sub	r5,-1
80008872:	2f 88       	sub	r8,-8
80008874:	2f c1       	sub	r1,-4
80008876:	12 35       	cp.w	r5,r9
80008878:	fe 9a ff d6 	brle	80008824 <get_arg+0x2a8>
8000887c:	1c 93       	mov	r3,lr
8000887e:	40 52       	lddsp	r2,sp[0x14]
80008880:	40 6e       	lddsp	lr,sp[0x18]
80008882:	85 05       	st.w	r2[0x0],r5
80008884:	9d 0b       	st.w	lr[0x0],r11
80008886:	40 4b       	lddsp	r11,sp[0x10]
80008888:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000888c:	2f 8d       	sub	sp,-32
8000888e:	d8 32       	popm	r0-r7,pc

80008890 <__sprint_r>:
80008890:	d4 21       	pushm	r4-r7,lr
80008892:	14 97       	mov	r7,r10
80008894:	74 28       	ld.w	r8,r10[0x8]
80008896:	58 08       	cp.w	r8,0
80008898:	c0 41       	brne	800088a0 <__sprint_r+0x10>
8000889a:	95 18       	st.w	r10[0x4],r8
8000889c:	10 9c       	mov	r12,r8
8000889e:	d8 22       	popm	r4-r7,pc
800088a0:	e0 a0 18 ba 	rcall	8000ba14 <__sfvwrite_r>
800088a4:	30 08       	mov	r8,0
800088a6:	8f 18       	st.w	r7[0x4],r8
800088a8:	8f 28       	st.w	r7[0x8],r8
800088aa:	d8 22       	popm	r4-r7,pc

800088ac <_vfprintf_r>:
800088ac:	d4 31       	pushm	r0-r7,lr
800088ae:	fa cd 06 bc 	sub	sp,sp,1724
800088b2:	51 09       	stdsp	sp[0x40],r9
800088b4:	16 91       	mov	r1,r11
800088b6:	14 97       	mov	r7,r10
800088b8:	18 95       	mov	r5,r12
800088ba:	e0 a0 1a 1d 	rcall	8000bcf4 <_localeconv_r>
800088be:	78 0c       	ld.w	r12,r12[0x0]
800088c0:	50 cc       	stdsp	sp[0x30],r12
800088c2:	58 05       	cp.w	r5,0
800088c4:	c0 70       	breq	800088d2 <_vfprintf_r+0x26>
800088c6:	6a 68       	ld.w	r8,r5[0x18]
800088c8:	58 08       	cp.w	r8,0
800088ca:	c0 41       	brne	800088d2 <_vfprintf_r+0x26>
800088cc:	0a 9c       	mov	r12,r5
800088ce:	e0 a0 17 43 	rcall	8000b754 <__sinit>
800088d2:	fe c8 9f 22 	sub	r8,pc,-24798
800088d6:	10 31       	cp.w	r1,r8
800088d8:	c0 31       	brne	800088de <_vfprintf_r+0x32>
800088da:	6a 01       	ld.w	r1,r5[0x0]
800088dc:	c0 c8       	rjmp	800088f4 <_vfprintf_r+0x48>
800088de:	fe c8 9f 0e 	sub	r8,pc,-24818
800088e2:	10 31       	cp.w	r1,r8
800088e4:	c0 31       	brne	800088ea <_vfprintf_r+0x3e>
800088e6:	6a 11       	ld.w	r1,r5[0x4]
800088e8:	c0 68       	rjmp	800088f4 <_vfprintf_r+0x48>
800088ea:	fe c8 9e fa 	sub	r8,pc,-24838
800088ee:	10 31       	cp.w	r1,r8
800088f0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800088f4:	82 68       	ld.sh	r8,r1[0xc]
800088f6:	ed b8 00 03 	bld	r8,0x3
800088fa:	c0 41       	brne	80008902 <_vfprintf_r+0x56>
800088fc:	62 48       	ld.w	r8,r1[0x10]
800088fe:	58 08       	cp.w	r8,0
80008900:	c0 71       	brne	8000890e <_vfprintf_r+0x62>
80008902:	02 9b       	mov	r11,r1
80008904:	0a 9c       	mov	r12,r5
80008906:	e0 a0 0f 5d 	rcall	8000a7c0 <__swsetup_r>
8000890a:	e0 81 0f 54 	brne	8000a7b2 <_vfprintf_r+0x1f06>
8000890e:	82 68       	ld.sh	r8,r1[0xc]
80008910:	10 99       	mov	r9,r8
80008912:	e2 19 00 1a 	andl	r9,0x1a,COH
80008916:	58 a9       	cp.w	r9,10
80008918:	c3 c1       	brne	80008990 <_vfprintf_r+0xe4>
8000891a:	82 79       	ld.sh	r9,r1[0xe]
8000891c:	30 0a       	mov	r10,0
8000891e:	f4 09 19 00 	cp.h	r9,r10
80008922:	c3 75       	brlt	80008990 <_vfprintf_r+0xe4>
80008924:	a1 d8       	cbr	r8,0x1
80008926:	fb 58 05 d0 	st.h	sp[1488],r8
8000892a:	62 88       	ld.w	r8,r1[0x20]
8000892c:	fb 48 05 e4 	st.w	sp[1508],r8
80008930:	62 a8       	ld.w	r8,r1[0x28]
80008932:	fb 48 05 ec 	st.w	sp[1516],r8
80008936:	fa c8 ff bc 	sub	r8,sp,-68
8000893a:	fb 48 05 d4 	st.w	sp[1492],r8
8000893e:	fb 48 05 c4 	st.w	sp[1476],r8
80008942:	e0 68 04 00 	mov	r8,1024
80008946:	fb 48 05 d8 	st.w	sp[1496],r8
8000894a:	fb 48 05 cc 	st.w	sp[1484],r8
8000894e:	30 08       	mov	r8,0
80008950:	fb 59 05 d2 	st.h	sp[1490],r9
80008954:	0e 9a       	mov	r10,r7
80008956:	41 09       	lddsp	r9,sp[0x40]
80008958:	fa c7 fa 3c 	sub	r7,sp,-1476
8000895c:	fb 48 05 dc 	st.w	sp[1500],r8
80008960:	0a 9c       	mov	r12,r5
80008962:	0e 9b       	mov	r11,r7
80008964:	ca 4f       	rcall	800088ac <_vfprintf_r>
80008966:	50 bc       	stdsp	sp[0x2c],r12
80008968:	c0 95       	brlt	8000897a <_vfprintf_r+0xce>
8000896a:	0e 9b       	mov	r11,r7
8000896c:	0a 9c       	mov	r12,r5
8000896e:	e0 a0 16 1b 	rcall	8000b5a4 <_fflush_r>
80008972:	40 be       	lddsp	lr,sp[0x2c]
80008974:	f9 be 01 ff 	movne	lr,-1
80008978:	50 be       	stdsp	sp[0x2c],lr
8000897a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000897e:	ed b8 00 06 	bld	r8,0x6
80008982:	e0 81 0f 1a 	brne	8000a7b6 <_vfprintf_r+0x1f0a>
80008986:	82 68       	ld.sh	r8,r1[0xc]
80008988:	a7 a8       	sbr	r8,0x6
8000898a:	a2 68       	st.h	r1[0xc],r8
8000898c:	e0 8f 0f 15 	bral	8000a7b6 <_vfprintf_r+0x1f0a>
80008990:	30 08       	mov	r8,0
80008992:	fb 48 06 b4 	st.w	sp[1716],r8
80008996:	fb 48 06 90 	st.w	sp[1680],r8
8000899a:	fb 48 06 8c 	st.w	sp[1676],r8
8000899e:	fb 48 06 b0 	st.w	sp[1712],r8
800089a2:	30 08       	mov	r8,0
800089a4:	30 09       	mov	r9,0
800089a6:	50 a7       	stdsp	sp[0x28],r7
800089a8:	50 78       	stdsp	sp[0x1c],r8
800089aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800089ae:	3f f8       	mov	r8,-1
800089b0:	50 59       	stdsp	sp[0x14],r9
800089b2:	fb 43 06 88 	st.w	sp[1672],r3
800089b6:	fb 48 05 44 	st.w	sp[1348],r8
800089ba:	12 9c       	mov	r12,r9
800089bc:	50 69       	stdsp	sp[0x18],r9
800089be:	50 d9       	stdsp	sp[0x34],r9
800089c0:	50 e9       	stdsp	sp[0x38],r9
800089c2:	50 b9       	stdsp	sp[0x2c],r9
800089c4:	12 97       	mov	r7,r9
800089c6:	0a 94       	mov	r4,r5
800089c8:	40 a2       	lddsp	r2,sp[0x28]
800089ca:	32 5a       	mov	r10,37
800089cc:	30 08       	mov	r8,0
800089ce:	c0 28       	rjmp	800089d2 <_vfprintf_r+0x126>
800089d0:	2f f2       	sub	r2,-1
800089d2:	05 89       	ld.ub	r9,r2[0x0]
800089d4:	f0 09 18 00 	cp.b	r9,r8
800089d8:	5f 1b       	srne	r11
800089da:	f4 09 18 00 	cp.b	r9,r10
800089de:	5f 19       	srne	r9
800089e0:	f3 eb 00 0b 	and	r11,r9,r11
800089e4:	f0 0b 18 00 	cp.b	r11,r8
800089e8:	cf 41       	brne	800089d0 <_vfprintf_r+0x124>
800089ea:	40 ab       	lddsp	r11,sp[0x28]
800089ec:	e4 0b 01 06 	sub	r6,r2,r11
800089f0:	c1 e0       	breq	80008a2c <_vfprintf_r+0x180>
800089f2:	fa f8 06 90 	ld.w	r8,sp[1680]
800089f6:	0c 08       	add	r8,r6
800089f8:	87 0b       	st.w	r3[0x0],r11
800089fa:	fb 48 06 90 	st.w	sp[1680],r8
800089fe:	87 16       	st.w	r3[0x4],r6
80008a00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a04:	2f f8       	sub	r8,-1
80008a06:	fb 48 06 8c 	st.w	sp[1676],r8
80008a0a:	58 78       	cp.w	r8,7
80008a0c:	e0 89 00 04 	brgt	80008a14 <_vfprintf_r+0x168>
80008a10:	2f 83       	sub	r3,-8
80008a12:	c0 a8       	rjmp	80008a26 <_vfprintf_r+0x17a>
80008a14:	fa ca f9 78 	sub	r10,sp,-1672
80008a18:	02 9b       	mov	r11,r1
80008a1a:	08 9c       	mov	r12,r4
80008a1c:	c3 af       	rcall	80008890 <__sprint_r>
80008a1e:	e0 81 0e c6 	brne	8000a7aa <_vfprintf_r+0x1efe>
80008a22:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a26:	40 ba       	lddsp	r10,sp[0x2c]
80008a28:	0c 0a       	add	r10,r6
80008a2a:	50 ba       	stdsp	sp[0x2c],r10
80008a2c:	05 89       	ld.ub	r9,r2[0x0]
80008a2e:	30 08       	mov	r8,0
80008a30:	f0 09 18 00 	cp.b	r9,r8
80008a34:	e0 80 0e aa 	breq	8000a788 <_vfprintf_r+0x1edc>
80008a38:	30 09       	mov	r9,0
80008a3a:	fb 68 06 bb 	st.b	sp[1723],r8
80008a3e:	0e 96       	mov	r6,r7
80008a40:	e4 c8 ff ff 	sub	r8,r2,-1
80008a44:	3f fe       	mov	lr,-1
80008a46:	50 93       	stdsp	sp[0x24],r3
80008a48:	50 41       	stdsp	sp[0x10],r1
80008a4a:	0e 93       	mov	r3,r7
80008a4c:	04 91       	mov	r1,r2
80008a4e:	50 89       	stdsp	sp[0x20],r9
80008a50:	50 a8       	stdsp	sp[0x28],r8
80008a52:	50 2e       	stdsp	sp[0x8],lr
80008a54:	50 39       	stdsp	sp[0xc],r9
80008a56:	12 95       	mov	r5,r9
80008a58:	12 90       	mov	r0,r9
80008a5a:	10 97       	mov	r7,r8
80008a5c:	08 92       	mov	r2,r4
80008a5e:	c0 78       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008a60:	3f fc       	mov	r12,-1
80008a62:	08 97       	mov	r7,r4
80008a64:	50 2c       	stdsp	sp[0x8],r12
80008a66:	c0 38       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008a68:	30 0b       	mov	r11,0
80008a6a:	50 3b       	stdsp	sp[0xc],r11
80008a6c:	0f 38       	ld.ub	r8,r7++
80008a6e:	c0 28       	rjmp	80008a72 <_vfprintf_r+0x1c6>
80008a70:	12 90       	mov	r0,r9
80008a72:	f0 c9 00 20 	sub	r9,r8,32
80008a76:	e0 49 00 58 	cp.w	r9,88
80008a7a:	e0 8b 0a 30 	brhi	80009eda <_vfprintf_r+0x162e>
80008a7e:	fe ca a4 76 	sub	r10,pc,-23434
80008a82:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008a86:	50 a7       	stdsp	sp[0x28],r7
80008a88:	50 80       	stdsp	sp[0x20],r0
80008a8a:	0c 97       	mov	r7,r6
80008a8c:	04 94       	mov	r4,r2
80008a8e:	06 96       	mov	r6,r3
80008a90:	02 92       	mov	r2,r1
80008a92:	fe c9 a2 4e 	sub	r9,pc,-23986
80008a96:	40 93       	lddsp	r3,sp[0x24]
80008a98:	10 90       	mov	r0,r8
80008a9a:	40 41       	lddsp	r1,sp[0x10]
80008a9c:	50 d9       	stdsp	sp[0x34],r9
80008a9e:	e0 8f 08 8e 	bral	80009bba <_vfprintf_r+0x130e>
80008aa2:	30 08       	mov	r8,0
80008aa4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008aa8:	f0 09 18 00 	cp.b	r9,r8
80008aac:	ce 01       	brne	80008a6c <_vfprintf_r+0x1c0>
80008aae:	32 08       	mov	r8,32
80008ab0:	c6 e8       	rjmp	80008b8c <_vfprintf_r+0x2e0>
80008ab2:	a1 a5       	sbr	r5,0x0
80008ab4:	cd cb       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008ab6:	0f 89       	ld.ub	r9,r7[0x0]
80008ab8:	f2 c8 00 30 	sub	r8,r9,48
80008abc:	58 98       	cp.w	r8,9
80008abe:	e0 8b 00 1d 	brhi	80008af8 <_vfprintf_r+0x24c>
80008ac2:	ee c8 ff ff 	sub	r8,r7,-1
80008ac6:	30 0b       	mov	r11,0
80008ac8:	23 09       	sub	r9,48
80008aca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008ace:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008ad2:	11 39       	ld.ub	r9,r8++
80008ad4:	f2 ca 00 30 	sub	r10,r9,48
80008ad8:	58 9a       	cp.w	r10,9
80008ada:	fe 98 ff f7 	brls	80008ac8 <_vfprintf_r+0x21c>
80008ade:	e0 49 00 24 	cp.w	r9,36
80008ae2:	cc 31       	brne	80008a68 <_vfprintf_r+0x1bc>
80008ae4:	e0 4b 00 20 	cp.w	r11,32
80008ae8:	e0 89 0e 60 	brgt	8000a7a8 <_vfprintf_r+0x1efc>
80008aec:	20 1b       	sub	r11,1
80008aee:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008af2:	12 3b       	cp.w	r11,r9
80008af4:	c0 95       	brlt	80008b06 <_vfprintf_r+0x25a>
80008af6:	c1 08       	rjmp	80008b16 <_vfprintf_r+0x26a>
80008af8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008afc:	ec ca ff ff 	sub	r10,r6,-1
80008b00:	12 36       	cp.w	r6,r9
80008b02:	c1 f5       	brlt	80008b40 <_vfprintf_r+0x294>
80008b04:	c2 68       	rjmp	80008b50 <_vfprintf_r+0x2a4>
80008b06:	fa ce f9 44 	sub	lr,sp,-1724
80008b0a:	10 97       	mov	r7,r8
80008b0c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008b10:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008b14:	c3 58       	rjmp	80008b7e <_vfprintf_r+0x2d2>
80008b16:	10 97       	mov	r7,r8
80008b18:	fa c8 f9 50 	sub	r8,sp,-1712
80008b1c:	1a d8       	st.w	--sp,r8
80008b1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b22:	1a d8       	st.w	--sp,r8
80008b24:	fa c8 fb b4 	sub	r8,sp,-1100
80008b28:	02 9a       	mov	r10,r1
80008b2a:	1a d8       	st.w	--sp,r8
80008b2c:	04 9c       	mov	r12,r2
80008b2e:	fa c8 f9 40 	sub	r8,sp,-1728
80008b32:	fa c9 ff b4 	sub	r9,sp,-76
80008b36:	fe b0 fd 23 	rcall	8000857c <get_arg>
80008b3a:	2f dd       	sub	sp,-12
80008b3c:	78 00       	ld.w	r0,r12[0x0]
80008b3e:	c2 08       	rjmp	80008b7e <_vfprintf_r+0x2d2>
80008b40:	fa cc f9 44 	sub	r12,sp,-1724
80008b44:	14 96       	mov	r6,r10
80008b46:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008b4a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008b4e:	c1 88       	rjmp	80008b7e <_vfprintf_r+0x2d2>
80008b50:	41 08       	lddsp	r8,sp[0x40]
80008b52:	59 f9       	cp.w	r9,31
80008b54:	e0 89 00 11 	brgt	80008b76 <_vfprintf_r+0x2ca>
80008b58:	f0 cb ff fc 	sub	r11,r8,-4
80008b5c:	51 0b       	stdsp	sp[0x40],r11
80008b5e:	70 00       	ld.w	r0,r8[0x0]
80008b60:	fa cb f9 44 	sub	r11,sp,-1724
80008b64:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008b68:	f1 40 fd 88 	st.w	r8[-632],r0
80008b6c:	2f f9       	sub	r9,-1
80008b6e:	14 96       	mov	r6,r10
80008b70:	fb 49 06 b4 	st.w	sp[1716],r9
80008b74:	c0 58       	rjmp	80008b7e <_vfprintf_r+0x2d2>
80008b76:	70 00       	ld.w	r0,r8[0x0]
80008b78:	14 96       	mov	r6,r10
80008b7a:	2f c8       	sub	r8,-4
80008b7c:	51 08       	stdsp	sp[0x40],r8
80008b7e:	58 00       	cp.w	r0,0
80008b80:	fe 94 ff 76 	brge	80008a6c <_vfprintf_r+0x1c0>
80008b84:	5c 30       	neg	r0
80008b86:	a3 a5       	sbr	r5,0x2
80008b88:	c7 2b       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008b8a:	32 b8       	mov	r8,43
80008b8c:	fb 68 06 bb 	st.b	sp[1723],r8
80008b90:	c6 eb       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008b92:	0f 38       	ld.ub	r8,r7++
80008b94:	e0 48 00 2a 	cp.w	r8,42
80008b98:	c0 30       	breq	80008b9e <_vfprintf_r+0x2f2>
80008b9a:	30 09       	mov	r9,0
80008b9c:	c7 98       	rjmp	80008c8e <_vfprintf_r+0x3e2>
80008b9e:	0f 88       	ld.ub	r8,r7[0x0]
80008ba0:	f0 c9 00 30 	sub	r9,r8,48
80008ba4:	58 99       	cp.w	r9,9
80008ba6:	e0 8b 00 1f 	brhi	80008be4 <_vfprintf_r+0x338>
80008baa:	ee c4 ff ff 	sub	r4,r7,-1
80008bae:	30 0b       	mov	r11,0
80008bb0:	23 08       	sub	r8,48
80008bb2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008bb6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008bba:	09 38       	ld.ub	r8,r4++
80008bbc:	f0 c9 00 30 	sub	r9,r8,48
80008bc0:	58 99       	cp.w	r9,9
80008bc2:	fe 98 ff f7 	brls	80008bb0 <_vfprintf_r+0x304>
80008bc6:	e0 48 00 24 	cp.w	r8,36
80008bca:	fe 91 ff 4f 	brne	80008a68 <_vfprintf_r+0x1bc>
80008bce:	e0 4b 00 20 	cp.w	r11,32
80008bd2:	e0 89 0d eb 	brgt	8000a7a8 <_vfprintf_r+0x1efc>
80008bd6:	20 1b       	sub	r11,1
80008bd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bdc:	10 3b       	cp.w	r11,r8
80008bde:	c0 a5       	brlt	80008bf2 <_vfprintf_r+0x346>
80008be0:	c1 18       	rjmp	80008c02 <_vfprintf_r+0x356>
80008be2:	d7 03       	nop
80008be4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008be8:	ec c9 ff ff 	sub	r9,r6,-1
80008bec:	14 36       	cp.w	r6,r10
80008bee:	c1 f5       	brlt	80008c2c <_vfprintf_r+0x380>
80008bf0:	c2 88       	rjmp	80008c40 <_vfprintf_r+0x394>
80008bf2:	fa ca f9 44 	sub	r10,sp,-1724
80008bf6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008bfa:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008bfe:	50 2b       	stdsp	sp[0x8],r11
80008c00:	c3 c8       	rjmp	80008c78 <_vfprintf_r+0x3cc>
80008c02:	fa c8 f9 50 	sub	r8,sp,-1712
80008c06:	1a d8       	st.w	--sp,r8
80008c08:	fa c8 fa b8 	sub	r8,sp,-1352
80008c0c:	1a d8       	st.w	--sp,r8
80008c0e:	fa c8 fb b4 	sub	r8,sp,-1100
80008c12:	02 9a       	mov	r10,r1
80008c14:	1a d8       	st.w	--sp,r8
80008c16:	04 9c       	mov	r12,r2
80008c18:	fa c8 f9 40 	sub	r8,sp,-1728
80008c1c:	fa c9 ff b4 	sub	r9,sp,-76
80008c20:	fe b0 fc ae 	rcall	8000857c <get_arg>
80008c24:	2f dd       	sub	sp,-12
80008c26:	78 0c       	ld.w	r12,r12[0x0]
80008c28:	50 2c       	stdsp	sp[0x8],r12
80008c2a:	c2 78       	rjmp	80008c78 <_vfprintf_r+0x3cc>
80008c2c:	12 96       	mov	r6,r9
80008c2e:	0e 94       	mov	r4,r7
80008c30:	fa c9 f9 44 	sub	r9,sp,-1724
80008c34:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008c38:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008c3c:	50 28       	stdsp	sp[0x8],r8
80008c3e:	c1 d8       	rjmp	80008c78 <_vfprintf_r+0x3cc>
80008c40:	41 08       	lddsp	r8,sp[0x40]
80008c42:	59 fa       	cp.w	r10,31
80008c44:	e0 89 00 14 	brgt	80008c6c <_vfprintf_r+0x3c0>
80008c48:	f0 cb ff fc 	sub	r11,r8,-4
80008c4c:	70 08       	ld.w	r8,r8[0x0]
80008c4e:	51 0b       	stdsp	sp[0x40],r11
80008c50:	50 28       	stdsp	sp[0x8],r8
80008c52:	fa c6 f9 44 	sub	r6,sp,-1724
80008c56:	40 2e       	lddsp	lr,sp[0x8]
80008c58:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008c5c:	f1 4e fd 88 	st.w	r8[-632],lr
80008c60:	2f fa       	sub	r10,-1
80008c62:	0e 94       	mov	r4,r7
80008c64:	fb 4a 06 b4 	st.w	sp[1716],r10
80008c68:	12 96       	mov	r6,r9
80008c6a:	c0 78       	rjmp	80008c78 <_vfprintf_r+0x3cc>
80008c6c:	70 0c       	ld.w	r12,r8[0x0]
80008c6e:	0e 94       	mov	r4,r7
80008c70:	2f c8       	sub	r8,-4
80008c72:	50 2c       	stdsp	sp[0x8],r12
80008c74:	12 96       	mov	r6,r9
80008c76:	51 08       	stdsp	sp[0x40],r8
80008c78:	40 2b       	lddsp	r11,sp[0x8]
80008c7a:	58 0b       	cp.w	r11,0
80008c7c:	fe 95 fe f2 	brlt	80008a60 <_vfprintf_r+0x1b4>
80008c80:	08 97       	mov	r7,r4
80008c82:	cf 5a       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008c84:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008c88:	0f 38       	ld.ub	r8,r7++
80008c8a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008c8e:	f0 ca 00 30 	sub	r10,r8,48
80008c92:	58 9a       	cp.w	r10,9
80008c94:	fe 98 ff f8 	brls	80008c84 <_vfprintf_r+0x3d8>
80008c98:	3f fa       	mov	r10,-1
80008c9a:	f2 0a 0c 49 	max	r9,r9,r10
80008c9e:	50 29       	stdsp	sp[0x8],r9
80008ca0:	ce 9a       	rjmp	80008a72 <_vfprintf_r+0x1c6>
80008ca2:	a7 b5       	sbr	r5,0x7
80008ca4:	ce 4a       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008ca6:	30 09       	mov	r9,0
80008ca8:	23 08       	sub	r8,48
80008caa:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008cae:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008cb2:	0f 38       	ld.ub	r8,r7++
80008cb4:	f0 ca 00 30 	sub	r10,r8,48
80008cb8:	58 9a       	cp.w	r10,9
80008cba:	fe 98 ff f7 	brls	80008ca8 <_vfprintf_r+0x3fc>
80008cbe:	e0 48 00 24 	cp.w	r8,36
80008cc2:	fe 91 fe d7 	brne	80008a70 <_vfprintf_r+0x1c4>
80008cc6:	e0 49 00 20 	cp.w	r9,32
80008cca:	e0 89 0d 6f 	brgt	8000a7a8 <_vfprintf_r+0x1efc>
80008cce:	f2 c3 00 01 	sub	r3,r9,1
80008cd2:	30 19       	mov	r9,1
80008cd4:	50 39       	stdsp	sp[0xc],r9
80008cd6:	cc ba       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008cd8:	a3 b5       	sbr	r5,0x3
80008cda:	cc 9a       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008cdc:	a7 a5       	sbr	r5,0x6
80008cde:	cc 7a       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008ce0:	0a 98       	mov	r8,r5
80008ce2:	a5 b5       	sbr	r5,0x5
80008ce4:	a5 a8       	sbr	r8,0x4
80008ce6:	0f 89       	ld.ub	r9,r7[0x0]
80008ce8:	36 ce       	mov	lr,108
80008cea:	fc 09 18 00 	cp.b	r9,lr
80008cee:	f7 b7 00 ff 	subeq	r7,-1
80008cf2:	f0 05 17 10 	movne	r5,r8
80008cf6:	cb ba       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008cf8:	a5 b5       	sbr	r5,0x5
80008cfa:	cb 9a       	rjmp	80008a6c <_vfprintf_r+0x1c0>
80008cfc:	50 a7       	stdsp	sp[0x28],r7
80008cfe:	50 80       	stdsp	sp[0x20],r0
80008d00:	0c 97       	mov	r7,r6
80008d02:	10 90       	mov	r0,r8
80008d04:	06 96       	mov	r6,r3
80008d06:	04 94       	mov	r4,r2
80008d08:	40 93       	lddsp	r3,sp[0x24]
80008d0a:	02 92       	mov	r2,r1
80008d0c:	0e 99       	mov	r9,r7
80008d0e:	40 41       	lddsp	r1,sp[0x10]
80008d10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d14:	40 3c       	lddsp	r12,sp[0xc]
80008d16:	58 0c       	cp.w	r12,0
80008d18:	c1 d0       	breq	80008d52 <_vfprintf_r+0x4a6>
80008d1a:	10 36       	cp.w	r6,r8
80008d1c:	c0 64       	brge	80008d28 <_vfprintf_r+0x47c>
80008d1e:	fa cb f9 44 	sub	r11,sp,-1724
80008d22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d26:	c1 d8       	rjmp	80008d60 <_vfprintf_r+0x4b4>
80008d28:	fa c8 f9 50 	sub	r8,sp,-1712
80008d2c:	1a d8       	st.w	--sp,r8
80008d2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d32:	1a d8       	st.w	--sp,r8
80008d34:	fa c8 fb b4 	sub	r8,sp,-1100
80008d38:	1a d8       	st.w	--sp,r8
80008d3a:	fa c8 f9 40 	sub	r8,sp,-1728
80008d3e:	fa c9 ff b4 	sub	r9,sp,-76
80008d42:	04 9a       	mov	r10,r2
80008d44:	0c 9b       	mov	r11,r6
80008d46:	08 9c       	mov	r12,r4
80008d48:	fe b0 fc 1a 	rcall	8000857c <get_arg>
80008d4c:	2f dd       	sub	sp,-12
80008d4e:	19 b8       	ld.ub	r8,r12[0x3]
80008d50:	c2 28       	rjmp	80008d94 <_vfprintf_r+0x4e8>
80008d52:	2f f7       	sub	r7,-1
80008d54:	10 39       	cp.w	r9,r8
80008d56:	c0 84       	brge	80008d66 <_vfprintf_r+0x4ba>
80008d58:	fa ca f9 44 	sub	r10,sp,-1724
80008d5c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d60:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008d64:	c1 88       	rjmp	80008d94 <_vfprintf_r+0x4e8>
80008d66:	41 09       	lddsp	r9,sp[0x40]
80008d68:	59 f8       	cp.w	r8,31
80008d6a:	e0 89 00 12 	brgt	80008d8e <_vfprintf_r+0x4e2>
80008d6e:	f2 ca ff fc 	sub	r10,r9,-4
80008d72:	51 0a       	stdsp	sp[0x40],r10
80008d74:	72 09       	ld.w	r9,r9[0x0]
80008d76:	fa c6 f9 44 	sub	r6,sp,-1724
80008d7a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008d7e:	2f f8       	sub	r8,-1
80008d80:	f5 49 fd 88 	st.w	r10[-632],r9
80008d84:	fb 48 06 b4 	st.w	sp[1716],r8
80008d88:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008d8c:	c0 48       	rjmp	80008d94 <_vfprintf_r+0x4e8>
80008d8e:	13 b8       	ld.ub	r8,r9[0x3]
80008d90:	2f c9       	sub	r9,-4
80008d92:	51 09       	stdsp	sp[0x40],r9
80008d94:	fb 68 06 60 	st.b	sp[1632],r8
80008d98:	30 0e       	mov	lr,0
80008d9a:	30 08       	mov	r8,0
80008d9c:	30 12       	mov	r2,1
80008d9e:	fb 68 06 bb 	st.b	sp[1723],r8
80008da2:	50 2e       	stdsp	sp[0x8],lr
80008da4:	e0 8f 08 ad 	bral	80009efe <_vfprintf_r+0x1652>
80008da8:	50 a7       	stdsp	sp[0x28],r7
80008daa:	50 80       	stdsp	sp[0x20],r0
80008dac:	0c 97       	mov	r7,r6
80008dae:	04 94       	mov	r4,r2
80008db0:	06 96       	mov	r6,r3
80008db2:	02 92       	mov	r2,r1
80008db4:	40 93       	lddsp	r3,sp[0x24]
80008db6:	10 90       	mov	r0,r8
80008db8:	40 41       	lddsp	r1,sp[0x10]
80008dba:	a5 a5       	sbr	r5,0x4
80008dbc:	c0 a8       	rjmp	80008dd0 <_vfprintf_r+0x524>
80008dbe:	50 a7       	stdsp	sp[0x28],r7
80008dc0:	50 80       	stdsp	sp[0x20],r0
80008dc2:	0c 97       	mov	r7,r6
80008dc4:	04 94       	mov	r4,r2
80008dc6:	06 96       	mov	r6,r3
80008dc8:	02 92       	mov	r2,r1
80008dca:	40 93       	lddsp	r3,sp[0x24]
80008dcc:	10 90       	mov	r0,r8
80008dce:	40 41       	lddsp	r1,sp[0x10]
80008dd0:	ed b5 00 05 	bld	r5,0x5
80008dd4:	c5 11       	brne	80008e76 <_vfprintf_r+0x5ca>
80008dd6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dda:	40 3c       	lddsp	r12,sp[0xc]
80008ddc:	58 0c       	cp.w	r12,0
80008dde:	c1 e0       	breq	80008e1a <_vfprintf_r+0x56e>
80008de0:	10 36       	cp.w	r6,r8
80008de2:	c0 64       	brge	80008dee <_vfprintf_r+0x542>
80008de4:	fa cb f9 44 	sub	r11,sp,-1724
80008de8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dec:	c2 08       	rjmp	80008e2c <_vfprintf_r+0x580>
80008dee:	fa c8 f9 50 	sub	r8,sp,-1712
80008df2:	1a d8       	st.w	--sp,r8
80008df4:	fa c8 fa b8 	sub	r8,sp,-1352
80008df8:	0c 9b       	mov	r11,r6
80008dfa:	1a d8       	st.w	--sp,r8
80008dfc:	fa c8 fb b4 	sub	r8,sp,-1100
80008e00:	1a d8       	st.w	--sp,r8
80008e02:	fa c9 ff b4 	sub	r9,sp,-76
80008e06:	fa c8 f9 40 	sub	r8,sp,-1728
80008e0a:	04 9a       	mov	r10,r2
80008e0c:	08 9c       	mov	r12,r4
80008e0e:	fe b0 fb b7 	rcall	8000857c <get_arg>
80008e12:	2f dd       	sub	sp,-12
80008e14:	78 1b       	ld.w	r11,r12[0x4]
80008e16:	78 09       	ld.w	r9,r12[0x0]
80008e18:	c2 b8       	rjmp	80008e6e <_vfprintf_r+0x5c2>
80008e1a:	ee ca ff ff 	sub	r10,r7,-1
80008e1e:	10 37       	cp.w	r7,r8
80008e20:	c0 b4       	brge	80008e36 <_vfprintf_r+0x58a>
80008e22:	fa c9 f9 44 	sub	r9,sp,-1724
80008e26:	14 97       	mov	r7,r10
80008e28:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e2c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008e30:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008e34:	c1 d8       	rjmp	80008e6e <_vfprintf_r+0x5c2>
80008e36:	41 09       	lddsp	r9,sp[0x40]
80008e38:	59 f8       	cp.w	r8,31
80008e3a:	e0 89 00 14 	brgt	80008e62 <_vfprintf_r+0x5b6>
80008e3e:	f2 cb ff f8 	sub	r11,r9,-8
80008e42:	51 0b       	stdsp	sp[0x40],r11
80008e44:	fa c6 f9 44 	sub	r6,sp,-1724
80008e48:	72 1b       	ld.w	r11,r9[0x4]
80008e4a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008e4e:	72 09       	ld.w	r9,r9[0x0]
80008e50:	f9 4b fd 8c 	st.w	r12[-628],r11
80008e54:	f9 49 fd 88 	st.w	r12[-632],r9
80008e58:	2f f8       	sub	r8,-1
80008e5a:	14 97       	mov	r7,r10
80008e5c:	fb 48 06 b4 	st.w	sp[1716],r8
80008e60:	c0 78       	rjmp	80008e6e <_vfprintf_r+0x5c2>
80008e62:	f2 c8 ff f8 	sub	r8,r9,-8
80008e66:	72 1b       	ld.w	r11,r9[0x4]
80008e68:	14 97       	mov	r7,r10
80008e6a:	51 08       	stdsp	sp[0x40],r8
80008e6c:	72 09       	ld.w	r9,r9[0x0]
80008e6e:	16 98       	mov	r8,r11
80008e70:	fa e9 00 00 	st.d	sp[0],r8
80008e74:	ca e8       	rjmp	80008fd0 <_vfprintf_r+0x724>
80008e76:	ed b5 00 04 	bld	r5,0x4
80008e7a:	c1 71       	brne	80008ea8 <_vfprintf_r+0x5fc>
80008e7c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e80:	40 3e       	lddsp	lr,sp[0xc]
80008e82:	58 0e       	cp.w	lr,0
80008e84:	c0 80       	breq	80008e94 <_vfprintf_r+0x5e8>
80008e86:	10 36       	cp.w	r6,r8
80008e88:	c6 94       	brge	80008f5a <_vfprintf_r+0x6ae>
80008e8a:	fa cc f9 44 	sub	r12,sp,-1724
80008e8e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008e92:	c8 28       	rjmp	80008f96 <_vfprintf_r+0x6ea>
80008e94:	ee ca ff ff 	sub	r10,r7,-1
80008e98:	10 37       	cp.w	r7,r8
80008e9a:	e0 84 00 81 	brge	80008f9c <_vfprintf_r+0x6f0>
80008e9e:	fa cb f9 44 	sub	r11,sp,-1724
80008ea2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ea6:	c7 78       	rjmp	80008f94 <_vfprintf_r+0x6e8>
80008ea8:	ed b5 00 06 	bld	r5,0x6
80008eac:	c4 b1       	brne	80008f42 <_vfprintf_r+0x696>
80008eae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eb2:	40 3c       	lddsp	r12,sp[0xc]
80008eb4:	58 0c       	cp.w	r12,0
80008eb6:	c1 d0       	breq	80008ef0 <_vfprintf_r+0x644>
80008eb8:	10 36       	cp.w	r6,r8
80008eba:	c0 64       	brge	80008ec6 <_vfprintf_r+0x61a>
80008ebc:	fa cb f9 44 	sub	r11,sp,-1724
80008ec0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ec4:	c1 f8       	rjmp	80008f02 <_vfprintf_r+0x656>
80008ec6:	fa c8 f9 50 	sub	r8,sp,-1712
80008eca:	1a d8       	st.w	--sp,r8
80008ecc:	fa c8 fa b8 	sub	r8,sp,-1352
80008ed0:	1a d8       	st.w	--sp,r8
80008ed2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ed6:	1a d8       	st.w	--sp,r8
80008ed8:	fa c8 f9 40 	sub	r8,sp,-1728
80008edc:	fa c9 ff b4 	sub	r9,sp,-76
80008ee0:	04 9a       	mov	r10,r2
80008ee2:	0c 9b       	mov	r11,r6
80008ee4:	08 9c       	mov	r12,r4
80008ee6:	fe b0 fb 4b 	rcall	8000857c <get_arg>
80008eea:	2f dd       	sub	sp,-12
80008eec:	98 18       	ld.sh	r8,r12[0x2]
80008eee:	c2 68       	rjmp	80008f3a <_vfprintf_r+0x68e>
80008ef0:	ee ca ff ff 	sub	r10,r7,-1
80008ef4:	10 37       	cp.w	r7,r8
80008ef6:	c0 94       	brge	80008f08 <_vfprintf_r+0x65c>
80008ef8:	fa c9 f9 44 	sub	r9,sp,-1724
80008efc:	14 97       	mov	r7,r10
80008efe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f02:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f06:	c1 a8       	rjmp	80008f3a <_vfprintf_r+0x68e>
80008f08:	41 09       	lddsp	r9,sp[0x40]
80008f0a:	59 f8       	cp.w	r8,31
80008f0c:	e0 89 00 13 	brgt	80008f32 <_vfprintf_r+0x686>
80008f10:	f2 cb ff fc 	sub	r11,r9,-4
80008f14:	51 0b       	stdsp	sp[0x40],r11
80008f16:	72 09       	ld.w	r9,r9[0x0]
80008f18:	fa c6 f9 44 	sub	r6,sp,-1724
80008f1c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f20:	2f f8       	sub	r8,-1
80008f22:	f7 49 fd 88 	st.w	r11[-632],r9
80008f26:	fb 48 06 b4 	st.w	sp[1716],r8
80008f2a:	14 97       	mov	r7,r10
80008f2c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f30:	c0 58       	rjmp	80008f3a <_vfprintf_r+0x68e>
80008f32:	92 18       	ld.sh	r8,r9[0x2]
80008f34:	14 97       	mov	r7,r10
80008f36:	2f c9       	sub	r9,-4
80008f38:	51 09       	stdsp	sp[0x40],r9
80008f3a:	50 18       	stdsp	sp[0x4],r8
80008f3c:	bf 58       	asr	r8,0x1f
80008f3e:	50 08       	stdsp	sp[0x0],r8
80008f40:	c4 88       	rjmp	80008fd0 <_vfprintf_r+0x724>
80008f42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f46:	40 3c       	lddsp	r12,sp[0xc]
80008f48:	58 0c       	cp.w	r12,0
80008f4a:	c1 d0       	breq	80008f84 <_vfprintf_r+0x6d8>
80008f4c:	10 36       	cp.w	r6,r8
80008f4e:	c0 64       	brge	80008f5a <_vfprintf_r+0x6ae>
80008f50:	fa cb f9 44 	sub	r11,sp,-1724
80008f54:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f58:	c1 f8       	rjmp	80008f96 <_vfprintf_r+0x6ea>
80008f5a:	fa c8 f9 50 	sub	r8,sp,-1712
80008f5e:	1a d8       	st.w	--sp,r8
80008f60:	fa c8 fa b8 	sub	r8,sp,-1352
80008f64:	0c 9b       	mov	r11,r6
80008f66:	1a d8       	st.w	--sp,r8
80008f68:	fa c8 fb b4 	sub	r8,sp,-1100
80008f6c:	04 9a       	mov	r10,r2
80008f6e:	1a d8       	st.w	--sp,r8
80008f70:	08 9c       	mov	r12,r4
80008f72:	fa c8 f9 40 	sub	r8,sp,-1728
80008f76:	fa c9 ff b4 	sub	r9,sp,-76
80008f7a:	fe b0 fb 01 	rcall	8000857c <get_arg>
80008f7e:	2f dd       	sub	sp,-12
80008f80:	78 0b       	ld.w	r11,r12[0x0]
80008f82:	c2 48       	rjmp	80008fca <_vfprintf_r+0x71e>
80008f84:	ee ca ff ff 	sub	r10,r7,-1
80008f88:	10 37       	cp.w	r7,r8
80008f8a:	c0 94       	brge	80008f9c <_vfprintf_r+0x6f0>
80008f8c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f90:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f94:	14 97       	mov	r7,r10
80008f96:	ec fb fd 88 	ld.w	r11,r6[-632]
80008f9a:	c1 88       	rjmp	80008fca <_vfprintf_r+0x71e>
80008f9c:	41 09       	lddsp	r9,sp[0x40]
80008f9e:	59 f8       	cp.w	r8,31
80008fa0:	e0 89 00 11 	brgt	80008fc2 <_vfprintf_r+0x716>
80008fa4:	f2 cb ff fc 	sub	r11,r9,-4
80008fa8:	51 0b       	stdsp	sp[0x40],r11
80008faa:	fa c6 f9 44 	sub	r6,sp,-1724
80008fae:	72 0b       	ld.w	r11,r9[0x0]
80008fb0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fb4:	f3 4b fd 88 	st.w	r9[-632],r11
80008fb8:	2f f8       	sub	r8,-1
80008fba:	14 97       	mov	r7,r10
80008fbc:	fb 48 06 b4 	st.w	sp[1716],r8
80008fc0:	c0 58       	rjmp	80008fca <_vfprintf_r+0x71e>
80008fc2:	72 0b       	ld.w	r11,r9[0x0]
80008fc4:	14 97       	mov	r7,r10
80008fc6:	2f c9       	sub	r9,-4
80008fc8:	51 09       	stdsp	sp[0x40],r9
80008fca:	50 1b       	stdsp	sp[0x4],r11
80008fcc:	bf 5b       	asr	r11,0x1f
80008fce:	50 0b       	stdsp	sp[0x0],r11
80008fd0:	fa ea 00 00 	ld.d	r10,sp[0]
80008fd4:	58 0a       	cp.w	r10,0
80008fd6:	5c 2b       	cpc	r11
80008fd8:	c0 e4       	brge	80008ff4 <_vfprintf_r+0x748>
80008fda:	30 08       	mov	r8,0
80008fdc:	fa ea 00 00 	ld.d	r10,sp[0]
80008fe0:	30 09       	mov	r9,0
80008fe2:	f0 0a 01 0a 	sub	r10,r8,r10
80008fe6:	f2 0b 01 4b 	sbc	r11,r9,r11
80008fea:	32 d8       	mov	r8,45
80008fec:	fa eb 00 00 	st.d	sp[0],r10
80008ff0:	fb 68 06 bb 	st.b	sp[1723],r8
80008ff4:	30 18       	mov	r8,1
80008ff6:	e0 8f 06 fa 	bral	80009dea <_vfprintf_r+0x153e>
80008ffa:	50 a7       	stdsp	sp[0x28],r7
80008ffc:	50 80       	stdsp	sp[0x20],r0
80008ffe:	0c 97       	mov	r7,r6
80009000:	04 94       	mov	r4,r2
80009002:	06 96       	mov	r6,r3
80009004:	02 92       	mov	r2,r1
80009006:	40 93       	lddsp	r3,sp[0x24]
80009008:	10 90       	mov	r0,r8
8000900a:	40 41       	lddsp	r1,sp[0x10]
8000900c:	0e 99       	mov	r9,r7
8000900e:	ed b5 00 03 	bld	r5,0x3
80009012:	c4 11       	brne	80009094 <_vfprintf_r+0x7e8>
80009014:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009018:	40 3a       	lddsp	r10,sp[0xc]
8000901a:	58 0a       	cp.w	r10,0
8000901c:	c1 90       	breq	8000904e <_vfprintf_r+0x7a2>
8000901e:	10 36       	cp.w	r6,r8
80009020:	c6 45       	brlt	800090e8 <_vfprintf_r+0x83c>
80009022:	fa c8 f9 50 	sub	r8,sp,-1712
80009026:	1a d8       	st.w	--sp,r8
80009028:	fa c8 fa b8 	sub	r8,sp,-1352
8000902c:	1a d8       	st.w	--sp,r8
8000902e:	fa c8 fb b4 	sub	r8,sp,-1100
80009032:	0c 9b       	mov	r11,r6
80009034:	1a d8       	st.w	--sp,r8
80009036:	04 9a       	mov	r10,r2
80009038:	fa c8 f9 40 	sub	r8,sp,-1728
8000903c:	fa c9 ff b4 	sub	r9,sp,-76
80009040:	08 9c       	mov	r12,r4
80009042:	fe b0 fa 9d 	rcall	8000857c <get_arg>
80009046:	2f dd       	sub	sp,-12
80009048:	78 16       	ld.w	r6,r12[0x4]
8000904a:	50 76       	stdsp	sp[0x1c],r6
8000904c:	c4 88       	rjmp	800090dc <_vfprintf_r+0x830>
8000904e:	2f f7       	sub	r7,-1
80009050:	10 39       	cp.w	r9,r8
80009052:	c0 c4       	brge	8000906a <_vfprintf_r+0x7be>
80009054:	fa ce f9 44 	sub	lr,sp,-1724
80009058:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000905c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80009060:	50 7c       	stdsp	sp[0x1c],r12
80009062:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009066:	50 56       	stdsp	sp[0x14],r6
80009068:	c6 68       	rjmp	80009134 <_vfprintf_r+0x888>
8000906a:	41 09       	lddsp	r9,sp[0x40]
8000906c:	59 f8       	cp.w	r8,31
8000906e:	e0 89 00 10 	brgt	8000908e <_vfprintf_r+0x7e2>
80009072:	f2 ca ff f8 	sub	r10,r9,-8
80009076:	72 1b       	ld.w	r11,r9[0x4]
80009078:	51 0a       	stdsp	sp[0x40],r10
8000907a:	72 09       	ld.w	r9,r9[0x0]
8000907c:	fa ca f9 44 	sub	r10,sp,-1724
80009080:	50 7b       	stdsp	sp[0x1c],r11
80009082:	50 59       	stdsp	sp[0x14],r9
80009084:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009088:	40 5b       	lddsp	r11,sp[0x14]
8000908a:	40 7a       	lddsp	r10,sp[0x1c]
8000908c:	c4 78       	rjmp	8000911a <_vfprintf_r+0x86e>
8000908e:	72 18       	ld.w	r8,r9[0x4]
80009090:	50 78       	stdsp	sp[0x1c],r8
80009092:	c4 c8       	rjmp	8000912a <_vfprintf_r+0x87e>
80009094:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009098:	40 3e       	lddsp	lr,sp[0xc]
8000909a:	58 0e       	cp.w	lr,0
8000909c:	c2 30       	breq	800090e2 <_vfprintf_r+0x836>
8000909e:	10 36       	cp.w	r6,r8
800090a0:	c0 94       	brge	800090b2 <_vfprintf_r+0x806>
800090a2:	fa cc f9 44 	sub	r12,sp,-1724
800090a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090aa:	ec fb fd 8c 	ld.w	r11,r6[-628]
800090ae:	50 7b       	stdsp	sp[0x1c],r11
800090b0:	cd 9b       	rjmp	80009062 <_vfprintf_r+0x7b6>
800090b2:	fa c8 f9 50 	sub	r8,sp,-1712
800090b6:	1a d8       	st.w	--sp,r8
800090b8:	fa c8 fa b8 	sub	r8,sp,-1352
800090bc:	04 9a       	mov	r10,r2
800090be:	1a d8       	st.w	--sp,r8
800090c0:	fa c8 fb b4 	sub	r8,sp,-1100
800090c4:	0c 9b       	mov	r11,r6
800090c6:	1a d8       	st.w	--sp,r8
800090c8:	08 9c       	mov	r12,r4
800090ca:	fa c8 f9 40 	sub	r8,sp,-1728
800090ce:	fa c9 ff b4 	sub	r9,sp,-76
800090d2:	fe b0 fa 55 	rcall	8000857c <get_arg>
800090d6:	2f dd       	sub	sp,-12
800090d8:	78 1a       	ld.w	r10,r12[0x4]
800090da:	50 7a       	stdsp	sp[0x1c],r10
800090dc:	78 0c       	ld.w	r12,r12[0x0]
800090de:	50 5c       	stdsp	sp[0x14],r12
800090e0:	c2 a8       	rjmp	80009134 <_vfprintf_r+0x888>
800090e2:	2f f7       	sub	r7,-1
800090e4:	10 39       	cp.w	r9,r8
800090e6:	c0 94       	brge	800090f8 <_vfprintf_r+0x84c>
800090e8:	fa c9 f9 44 	sub	r9,sp,-1724
800090ec:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090f0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800090f4:	50 78       	stdsp	sp[0x1c],r8
800090f6:	cb 6b       	rjmp	80009062 <_vfprintf_r+0x7b6>
800090f8:	41 09       	lddsp	r9,sp[0x40]
800090fa:	59 f8       	cp.w	r8,31
800090fc:	e0 89 00 15 	brgt	80009126 <_vfprintf_r+0x87a>
80009100:	f2 ca ff f8 	sub	r10,r9,-8
80009104:	72 16       	ld.w	r6,r9[0x4]
80009106:	72 09       	ld.w	r9,r9[0x0]
80009108:	51 0a       	stdsp	sp[0x40],r10
8000910a:	50 59       	stdsp	sp[0x14],r9
8000910c:	fa ce f9 44 	sub	lr,sp,-1724
80009110:	50 76       	stdsp	sp[0x1c],r6
80009112:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009116:	40 5b       	lddsp	r11,sp[0x14]
80009118:	0c 9a       	mov	r10,r6
8000911a:	f2 eb fd 88 	st.d	r9[-632],r10
8000911e:	2f f8       	sub	r8,-1
80009120:	fb 48 06 b4 	st.w	sp[1716],r8
80009124:	c0 88       	rjmp	80009134 <_vfprintf_r+0x888>
80009126:	72 1c       	ld.w	r12,r9[0x4]
80009128:	50 7c       	stdsp	sp[0x1c],r12
8000912a:	f2 c8 ff f8 	sub	r8,r9,-8
8000912e:	51 08       	stdsp	sp[0x40],r8
80009130:	72 09       	ld.w	r9,r9[0x0]
80009132:	50 59       	stdsp	sp[0x14],r9
80009134:	40 5b       	lddsp	r11,sp[0x14]
80009136:	40 7a       	lddsp	r10,sp[0x1c]
80009138:	e0 a0 19 54 	rcall	8000c3e0 <__isinfd>
8000913c:	18 96       	mov	r6,r12
8000913e:	c1 70       	breq	8000916c <_vfprintf_r+0x8c0>
80009140:	30 08       	mov	r8,0
80009142:	30 09       	mov	r9,0
80009144:	40 5b       	lddsp	r11,sp[0x14]
80009146:	40 7a       	lddsp	r10,sp[0x1c]
80009148:	e0 a0 1d b4 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000914c:	c0 40       	breq	80009154 <_vfprintf_r+0x8a8>
8000914e:	32 d8       	mov	r8,45
80009150:	fb 68 06 bb 	st.b	sp[1723],r8
80009154:	fe c8 a8 fc 	sub	r8,pc,-22276
80009158:	fe c6 a8 fc 	sub	r6,pc,-22276
8000915c:	a7 d5       	cbr	r5,0x7
8000915e:	e0 40 00 47 	cp.w	r0,71
80009162:	f0 06 17 a0 	movle	r6,r8
80009166:	30 32       	mov	r2,3
80009168:	e0 8f 06 ce 	bral	80009f04 <_vfprintf_r+0x1658>
8000916c:	40 5b       	lddsp	r11,sp[0x14]
8000916e:	40 7a       	lddsp	r10,sp[0x1c]
80009170:	e0 a0 19 4d 	rcall	8000c40a <__isnand>
80009174:	c0 e0       	breq	80009190 <_vfprintf_r+0x8e4>
80009176:	50 26       	stdsp	sp[0x8],r6
80009178:	fe c8 a9 18 	sub	r8,pc,-22248
8000917c:	fe c6 a9 18 	sub	r6,pc,-22248
80009180:	a7 d5       	cbr	r5,0x7
80009182:	e0 40 00 47 	cp.w	r0,71
80009186:	f0 06 17 a0 	movle	r6,r8
8000918a:	30 32       	mov	r2,3
8000918c:	e0 8f 06 c2 	bral	80009f10 <_vfprintf_r+0x1664>
80009190:	40 2a       	lddsp	r10,sp[0x8]
80009192:	5b fa       	cp.w	r10,-1
80009194:	c0 41       	brne	8000919c <_vfprintf_r+0x8f0>
80009196:	30 69       	mov	r9,6
80009198:	50 29       	stdsp	sp[0x8],r9
8000919a:	c1 18       	rjmp	800091bc <_vfprintf_r+0x910>
8000919c:	e0 40 00 47 	cp.w	r0,71
800091a0:	5f 09       	sreq	r9
800091a2:	e0 40 00 67 	cp.w	r0,103
800091a6:	5f 08       	sreq	r8
800091a8:	f3 e8 10 08 	or	r8,r9,r8
800091ac:	f8 08 18 00 	cp.b	r8,r12
800091b0:	c0 60       	breq	800091bc <_vfprintf_r+0x910>
800091b2:	40 28       	lddsp	r8,sp[0x8]
800091b4:	58 08       	cp.w	r8,0
800091b6:	f9 b8 00 01 	moveq	r8,1
800091ba:	50 28       	stdsp	sp[0x8],r8
800091bc:	40 78       	lddsp	r8,sp[0x1c]
800091be:	40 59       	lddsp	r9,sp[0x14]
800091c0:	fa e9 06 94 	st.d	sp[1684],r8
800091c4:	a9 a5       	sbr	r5,0x8
800091c6:	fa f8 06 94 	ld.w	r8,sp[1684]
800091ca:	58 08       	cp.w	r8,0
800091cc:	c0 65       	brlt	800091d8 <_vfprintf_r+0x92c>
800091ce:	40 5e       	lddsp	lr,sp[0x14]
800091d0:	30 0c       	mov	r12,0
800091d2:	50 6e       	stdsp	sp[0x18],lr
800091d4:	50 9c       	stdsp	sp[0x24],r12
800091d6:	c0 78       	rjmp	800091e4 <_vfprintf_r+0x938>
800091d8:	40 5b       	lddsp	r11,sp[0x14]
800091da:	32 da       	mov	r10,45
800091dc:	ee 1b 80 00 	eorh	r11,0x8000
800091e0:	50 9a       	stdsp	sp[0x24],r10
800091e2:	50 6b       	stdsp	sp[0x18],r11
800091e4:	e0 40 00 46 	cp.w	r0,70
800091e8:	5f 09       	sreq	r9
800091ea:	e0 40 00 66 	cp.w	r0,102
800091ee:	5f 08       	sreq	r8
800091f0:	f3 e8 10 08 	or	r8,r9,r8
800091f4:	50 48       	stdsp	sp[0x10],r8
800091f6:	c0 40       	breq	800091fe <_vfprintf_r+0x952>
800091f8:	40 22       	lddsp	r2,sp[0x8]
800091fa:	30 39       	mov	r9,3
800091fc:	c1 08       	rjmp	8000921c <_vfprintf_r+0x970>
800091fe:	e0 40 00 45 	cp.w	r0,69
80009202:	5f 09       	sreq	r9
80009204:	e0 40 00 65 	cp.w	r0,101
80009208:	5f 08       	sreq	r8
8000920a:	40 22       	lddsp	r2,sp[0x8]
8000920c:	10 49       	or	r9,r8
8000920e:	2f f2       	sub	r2,-1
80009210:	40 46       	lddsp	r6,sp[0x10]
80009212:	ec 09 18 00 	cp.b	r9,r6
80009216:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000921a:	30 29       	mov	r9,2
8000921c:	fa c8 f9 5c 	sub	r8,sp,-1700
80009220:	1a d8       	st.w	--sp,r8
80009222:	fa c8 f9 54 	sub	r8,sp,-1708
80009226:	1a d8       	st.w	--sp,r8
80009228:	fa c8 f9 4c 	sub	r8,sp,-1716
8000922c:	08 9c       	mov	r12,r4
8000922e:	1a d8       	st.w	--sp,r8
80009230:	04 98       	mov	r8,r2
80009232:	40 9b       	lddsp	r11,sp[0x24]
80009234:	40 aa       	lddsp	r10,sp[0x28]
80009236:	e0 a0 0b c3 	rcall	8000a9bc <_dtoa_r>
8000923a:	e0 40 00 47 	cp.w	r0,71
8000923e:	5f 19       	srne	r9
80009240:	e0 40 00 67 	cp.w	r0,103
80009244:	5f 18       	srne	r8
80009246:	18 96       	mov	r6,r12
80009248:	2f dd       	sub	sp,-12
8000924a:	f3 e8 00 08 	and	r8,r9,r8
8000924e:	c0 41       	brne	80009256 <_vfprintf_r+0x9aa>
80009250:	ed b5 00 00 	bld	r5,0x0
80009254:	c3 01       	brne	800092b4 <_vfprintf_r+0xa08>
80009256:	ec 02 00 0e 	add	lr,r6,r2
8000925a:	50 3e       	stdsp	sp[0xc],lr
8000925c:	40 4c       	lddsp	r12,sp[0x10]
8000925e:	58 0c       	cp.w	r12,0
80009260:	c1 50       	breq	8000928a <_vfprintf_r+0x9de>
80009262:	0d 89       	ld.ub	r9,r6[0x0]
80009264:	33 08       	mov	r8,48
80009266:	f0 09 18 00 	cp.b	r9,r8
8000926a:	c0 b1       	brne	80009280 <_vfprintf_r+0x9d4>
8000926c:	30 08       	mov	r8,0
8000926e:	30 09       	mov	r9,0
80009270:	40 6b       	lddsp	r11,sp[0x18]
80009272:	40 7a       	lddsp	r10,sp[0x1c]
80009274:	e0 a0 1c d7 	rcall	8000cc22 <__avr32_f64_cmp_eq>
80009278:	fb b2 00 01 	rsubeq	r2,1
8000927c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009280:	40 3b       	lddsp	r11,sp[0xc]
80009282:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009286:	10 0b       	add	r11,r8
80009288:	50 3b       	stdsp	sp[0xc],r11
8000928a:	40 6b       	lddsp	r11,sp[0x18]
8000928c:	30 08       	mov	r8,0
8000928e:	30 09       	mov	r9,0
80009290:	40 7a       	lddsp	r10,sp[0x1c]
80009292:	e0 a0 1c c8 	rcall	8000cc22 <__avr32_f64_cmp_eq>
80009296:	c0 90       	breq	800092a8 <_vfprintf_r+0x9fc>
80009298:	40 3a       	lddsp	r10,sp[0xc]
8000929a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000929e:	c0 58       	rjmp	800092a8 <_vfprintf_r+0x9fc>
800092a0:	10 c9       	st.b	r8++,r9
800092a2:	fb 48 06 a4 	st.w	sp[1700],r8
800092a6:	c0 28       	rjmp	800092aa <_vfprintf_r+0x9fe>
800092a8:	33 09       	mov	r9,48
800092aa:	fa f8 06 a4 	ld.w	r8,sp[1700]
800092ae:	40 3e       	lddsp	lr,sp[0xc]
800092b0:	1c 38       	cp.w	r8,lr
800092b2:	cf 73       	brcs	800092a0 <_vfprintf_r+0x9f4>
800092b4:	e0 40 00 47 	cp.w	r0,71
800092b8:	5f 09       	sreq	r9
800092ba:	e0 40 00 67 	cp.w	r0,103
800092be:	5f 08       	sreq	r8
800092c0:	f3 e8 10 08 	or	r8,r9,r8
800092c4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800092c8:	0c 19       	sub	r9,r6
800092ca:	50 69       	stdsp	sp[0x18],r9
800092cc:	58 08       	cp.w	r8,0
800092ce:	c0 b0       	breq	800092e4 <_vfprintf_r+0xa38>
800092d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092d4:	5b d8       	cp.w	r8,-3
800092d6:	c0 55       	brlt	800092e0 <_vfprintf_r+0xa34>
800092d8:	40 2c       	lddsp	r12,sp[0x8]
800092da:	18 38       	cp.w	r8,r12
800092dc:	e0 8a 00 6a 	brle	800093b0 <_vfprintf_r+0xb04>
800092e0:	20 20       	sub	r0,2
800092e2:	c0 58       	rjmp	800092ec <_vfprintf_r+0xa40>
800092e4:	e0 40 00 65 	cp.w	r0,101
800092e8:	e0 89 00 46 	brgt	80009374 <_vfprintf_r+0xac8>
800092ec:	fa fb 06 ac 	ld.w	r11,sp[1708]
800092f0:	fb 60 06 9c 	st.b	sp[1692],r0
800092f4:	20 1b       	sub	r11,1
800092f6:	fb 4b 06 ac 	st.w	sp[1708],r11
800092fa:	c0 47       	brpl	80009302 <_vfprintf_r+0xa56>
800092fc:	5c 3b       	neg	r11
800092fe:	32 d8       	mov	r8,45
80009300:	c0 28       	rjmp	80009304 <_vfprintf_r+0xa58>
80009302:	32 b8       	mov	r8,43
80009304:	fb 68 06 9d 	st.b	sp[1693],r8
80009308:	58 9b       	cp.w	r11,9
8000930a:	e0 8a 00 1d 	brle	80009344 <_vfprintf_r+0xa98>
8000930e:	fa c9 fa 35 	sub	r9,sp,-1483
80009312:	30 aa       	mov	r10,10
80009314:	12 98       	mov	r8,r9
80009316:	0e 9c       	mov	r12,r7
80009318:	0c 92       	mov	r2,r6
8000931a:	f6 0a 0c 06 	divs	r6,r11,r10
8000931e:	0e 9b       	mov	r11,r7
80009320:	2d 0b       	sub	r11,-48
80009322:	10 fb       	st.b	--r8,r11
80009324:	0c 9b       	mov	r11,r6
80009326:	58 96       	cp.w	r6,9
80009328:	fe 99 ff f9 	brgt	8000931a <_vfprintf_r+0xa6e>
8000932c:	2d 0b       	sub	r11,-48
8000932e:	18 97       	mov	r7,r12
80009330:	04 96       	mov	r6,r2
80009332:	10 fb       	st.b	--r8,r11
80009334:	fa ca f9 62 	sub	r10,sp,-1694
80009338:	c0 38       	rjmp	8000933e <_vfprintf_r+0xa92>
8000933a:	11 3b       	ld.ub	r11,r8++
8000933c:	14 cb       	st.b	r10++,r11
8000933e:	12 38       	cp.w	r8,r9
80009340:	cf d3       	brcs	8000933a <_vfprintf_r+0xa8e>
80009342:	c0 98       	rjmp	80009354 <_vfprintf_r+0xaa8>
80009344:	2d 0b       	sub	r11,-48
80009346:	33 08       	mov	r8,48
80009348:	fb 6b 06 9f 	st.b	sp[1695],r11
8000934c:	fb 68 06 9e 	st.b	sp[1694],r8
80009350:	fa ca f9 60 	sub	r10,sp,-1696
80009354:	fa c8 f9 64 	sub	r8,sp,-1692
80009358:	f4 08 01 08 	sub	r8,r10,r8
8000935c:	50 e8       	stdsp	sp[0x38],r8
8000935e:	10 92       	mov	r2,r8
80009360:	40 6b       	lddsp	r11,sp[0x18]
80009362:	16 02       	add	r2,r11
80009364:	58 1b       	cp.w	r11,1
80009366:	e0 89 00 05 	brgt	80009370 <_vfprintf_r+0xac4>
8000936a:	ed b5 00 00 	bld	r5,0x0
8000936e:	c3 51       	brne	800093d8 <_vfprintf_r+0xb2c>
80009370:	2f f2       	sub	r2,-1
80009372:	c3 38       	rjmp	800093d8 <_vfprintf_r+0xb2c>
80009374:	e0 40 00 66 	cp.w	r0,102
80009378:	c1 c1       	brne	800093b0 <_vfprintf_r+0xb04>
8000937a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000937e:	58 02       	cp.w	r2,0
80009380:	e0 8a 00 0c 	brle	80009398 <_vfprintf_r+0xaec>
80009384:	40 2a       	lddsp	r10,sp[0x8]
80009386:	58 0a       	cp.w	r10,0
80009388:	c0 41       	brne	80009390 <_vfprintf_r+0xae4>
8000938a:	ed b5 00 00 	bld	r5,0x0
8000938e:	c2 51       	brne	800093d8 <_vfprintf_r+0xb2c>
80009390:	2f f2       	sub	r2,-1
80009392:	40 29       	lddsp	r9,sp[0x8]
80009394:	12 02       	add	r2,r9
80009396:	c0 b8       	rjmp	800093ac <_vfprintf_r+0xb00>
80009398:	40 28       	lddsp	r8,sp[0x8]
8000939a:	58 08       	cp.w	r8,0
8000939c:	c0 61       	brne	800093a8 <_vfprintf_r+0xafc>
8000939e:	ed b5 00 00 	bld	r5,0x0
800093a2:	c0 30       	breq	800093a8 <_vfprintf_r+0xafc>
800093a4:	30 12       	mov	r2,1
800093a6:	c1 98       	rjmp	800093d8 <_vfprintf_r+0xb2c>
800093a8:	40 22       	lddsp	r2,sp[0x8]
800093aa:	2f e2       	sub	r2,-2
800093ac:	36 60       	mov	r0,102
800093ae:	c1 58       	rjmp	800093d8 <_vfprintf_r+0xb2c>
800093b0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800093b4:	40 6e       	lddsp	lr,sp[0x18]
800093b6:	1c 32       	cp.w	r2,lr
800093b8:	c0 65       	brlt	800093c4 <_vfprintf_r+0xb18>
800093ba:	ed b5 00 00 	bld	r5,0x0
800093be:	f7 b2 00 ff 	subeq	r2,-1
800093c2:	c0 a8       	rjmp	800093d6 <_vfprintf_r+0xb2a>
800093c4:	e4 08 11 02 	rsub	r8,r2,2
800093c8:	40 6c       	lddsp	r12,sp[0x18]
800093ca:	58 02       	cp.w	r2,0
800093cc:	f0 02 17 a0 	movle	r2,r8
800093d0:	f9 b2 09 01 	movgt	r2,1
800093d4:	18 02       	add	r2,r12
800093d6:	36 70       	mov	r0,103
800093d8:	40 9b       	lddsp	r11,sp[0x24]
800093da:	58 0b       	cp.w	r11,0
800093dc:	e0 80 05 94 	breq	80009f04 <_vfprintf_r+0x1658>
800093e0:	32 d8       	mov	r8,45
800093e2:	fb 68 06 bb 	st.b	sp[1723],r8
800093e6:	e0 8f 05 93 	bral	80009f0c <_vfprintf_r+0x1660>
800093ea:	50 a7       	stdsp	sp[0x28],r7
800093ec:	04 94       	mov	r4,r2
800093ee:	0c 97       	mov	r7,r6
800093f0:	02 92       	mov	r2,r1
800093f2:	06 96       	mov	r6,r3
800093f4:	40 41       	lddsp	r1,sp[0x10]
800093f6:	40 93       	lddsp	r3,sp[0x24]
800093f8:	0e 99       	mov	r9,r7
800093fa:	ed b5 00 05 	bld	r5,0x5
800093fe:	c4 81       	brne	8000948e <_vfprintf_r+0xbe2>
80009400:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009404:	40 3e       	lddsp	lr,sp[0xc]
80009406:	58 0e       	cp.w	lr,0
80009408:	c1 d0       	breq	80009442 <_vfprintf_r+0xb96>
8000940a:	10 36       	cp.w	r6,r8
8000940c:	c0 64       	brge	80009418 <_vfprintf_r+0xb6c>
8000940e:	fa cc f9 44 	sub	r12,sp,-1724
80009412:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009416:	c1 d8       	rjmp	80009450 <_vfprintf_r+0xba4>
80009418:	fa c8 f9 50 	sub	r8,sp,-1712
8000941c:	1a d8       	st.w	--sp,r8
8000941e:	fa c8 fa b8 	sub	r8,sp,-1352
80009422:	04 9a       	mov	r10,r2
80009424:	1a d8       	st.w	--sp,r8
80009426:	fa c8 fb b4 	sub	r8,sp,-1100
8000942a:	0c 9b       	mov	r11,r6
8000942c:	1a d8       	st.w	--sp,r8
8000942e:	08 9c       	mov	r12,r4
80009430:	fa c8 f9 40 	sub	r8,sp,-1728
80009434:	fa c9 ff b4 	sub	r9,sp,-76
80009438:	fe b0 f8 a2 	rcall	8000857c <get_arg>
8000943c:	2f dd       	sub	sp,-12
8000943e:	78 0a       	ld.w	r10,r12[0x0]
80009440:	c2 08       	rjmp	80009480 <_vfprintf_r+0xbd4>
80009442:	2f f7       	sub	r7,-1
80009444:	10 39       	cp.w	r9,r8
80009446:	c0 84       	brge	80009456 <_vfprintf_r+0xbaa>
80009448:	fa cb f9 44 	sub	r11,sp,-1724
8000944c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009450:	ec fa fd 88 	ld.w	r10,r6[-632]
80009454:	c1 68       	rjmp	80009480 <_vfprintf_r+0xbd4>
80009456:	41 09       	lddsp	r9,sp[0x40]
80009458:	59 f8       	cp.w	r8,31
8000945a:	e0 89 00 10 	brgt	8000947a <_vfprintf_r+0xbce>
8000945e:	f2 ca ff fc 	sub	r10,r9,-4
80009462:	51 0a       	stdsp	sp[0x40],r10
80009464:	fa c6 f9 44 	sub	r6,sp,-1724
80009468:	72 0a       	ld.w	r10,r9[0x0]
8000946a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000946e:	f3 4a fd 88 	st.w	r9[-632],r10
80009472:	2f f8       	sub	r8,-1
80009474:	fb 48 06 b4 	st.w	sp[1716],r8
80009478:	c0 48       	rjmp	80009480 <_vfprintf_r+0xbd4>
8000947a:	72 0a       	ld.w	r10,r9[0x0]
8000947c:	2f c9       	sub	r9,-4
8000947e:	51 09       	stdsp	sp[0x40],r9
80009480:	40 be       	lddsp	lr,sp[0x2c]
80009482:	1c 98       	mov	r8,lr
80009484:	95 1e       	st.w	r10[0x4],lr
80009486:	bf 58       	asr	r8,0x1f
80009488:	95 08       	st.w	r10[0x0],r8
8000948a:	fe 9f fa 9f 	bral	800089c8 <_vfprintf_r+0x11c>
8000948e:	ed b5 00 04 	bld	r5,0x4
80009492:	c4 80       	breq	80009522 <_vfprintf_r+0xc76>
80009494:	e2 15 00 40 	andl	r5,0x40,COH
80009498:	c4 50       	breq	80009522 <_vfprintf_r+0xc76>
8000949a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000949e:	40 3c       	lddsp	r12,sp[0xc]
800094a0:	58 0c       	cp.w	r12,0
800094a2:	c1 d0       	breq	800094dc <_vfprintf_r+0xc30>
800094a4:	10 36       	cp.w	r6,r8
800094a6:	c0 64       	brge	800094b2 <_vfprintf_r+0xc06>
800094a8:	fa cb f9 44 	sub	r11,sp,-1724
800094ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094b0:	c1 d8       	rjmp	800094ea <_vfprintf_r+0xc3e>
800094b2:	fa c8 f9 50 	sub	r8,sp,-1712
800094b6:	1a d8       	st.w	--sp,r8
800094b8:	fa c8 fa b8 	sub	r8,sp,-1352
800094bc:	04 9a       	mov	r10,r2
800094be:	1a d8       	st.w	--sp,r8
800094c0:	fa c8 fb b4 	sub	r8,sp,-1100
800094c4:	0c 9b       	mov	r11,r6
800094c6:	1a d8       	st.w	--sp,r8
800094c8:	08 9c       	mov	r12,r4
800094ca:	fa c8 f9 40 	sub	r8,sp,-1728
800094ce:	fa c9 ff b4 	sub	r9,sp,-76
800094d2:	fe b0 f8 55 	rcall	8000857c <get_arg>
800094d6:	2f dd       	sub	sp,-12
800094d8:	78 0a       	ld.w	r10,r12[0x0]
800094da:	c2 08       	rjmp	8000951a <_vfprintf_r+0xc6e>
800094dc:	2f f7       	sub	r7,-1
800094de:	10 39       	cp.w	r9,r8
800094e0:	c0 84       	brge	800094f0 <_vfprintf_r+0xc44>
800094e2:	fa ca f9 44 	sub	r10,sp,-1724
800094e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800094ea:	ec fa fd 88 	ld.w	r10,r6[-632]
800094ee:	c1 68       	rjmp	8000951a <_vfprintf_r+0xc6e>
800094f0:	41 09       	lddsp	r9,sp[0x40]
800094f2:	59 f8       	cp.w	r8,31
800094f4:	e0 89 00 10 	brgt	80009514 <_vfprintf_r+0xc68>
800094f8:	f2 ca ff fc 	sub	r10,r9,-4
800094fc:	51 0a       	stdsp	sp[0x40],r10
800094fe:	fa c6 f9 44 	sub	r6,sp,-1724
80009502:	72 0a       	ld.w	r10,r9[0x0]
80009504:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009508:	f3 4a fd 88 	st.w	r9[-632],r10
8000950c:	2f f8       	sub	r8,-1
8000950e:	fb 48 06 b4 	st.w	sp[1716],r8
80009512:	c0 48       	rjmp	8000951a <_vfprintf_r+0xc6e>
80009514:	72 0a       	ld.w	r10,r9[0x0]
80009516:	2f c9       	sub	r9,-4
80009518:	51 09       	stdsp	sp[0x40],r9
8000951a:	40 be       	lddsp	lr,sp[0x2c]
8000951c:	b4 0e       	st.h	r10[0x0],lr
8000951e:	fe 9f fa 55 	bral	800089c8 <_vfprintf_r+0x11c>
80009522:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009526:	40 3c       	lddsp	r12,sp[0xc]
80009528:	58 0c       	cp.w	r12,0
8000952a:	c1 d0       	breq	80009564 <_vfprintf_r+0xcb8>
8000952c:	10 36       	cp.w	r6,r8
8000952e:	c0 64       	brge	8000953a <_vfprintf_r+0xc8e>
80009530:	fa cb f9 44 	sub	r11,sp,-1724
80009534:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009538:	c1 d8       	rjmp	80009572 <_vfprintf_r+0xcc6>
8000953a:	fa c8 f9 50 	sub	r8,sp,-1712
8000953e:	1a d8       	st.w	--sp,r8
80009540:	fa c8 fa b8 	sub	r8,sp,-1352
80009544:	04 9a       	mov	r10,r2
80009546:	1a d8       	st.w	--sp,r8
80009548:	fa c8 fb b4 	sub	r8,sp,-1100
8000954c:	0c 9b       	mov	r11,r6
8000954e:	1a d8       	st.w	--sp,r8
80009550:	08 9c       	mov	r12,r4
80009552:	fa c8 f9 40 	sub	r8,sp,-1728
80009556:	fa c9 ff b4 	sub	r9,sp,-76
8000955a:	fe b0 f8 11 	rcall	8000857c <get_arg>
8000955e:	2f dd       	sub	sp,-12
80009560:	78 0a       	ld.w	r10,r12[0x0]
80009562:	c2 08       	rjmp	800095a2 <_vfprintf_r+0xcf6>
80009564:	2f f7       	sub	r7,-1
80009566:	10 39       	cp.w	r9,r8
80009568:	c0 84       	brge	80009578 <_vfprintf_r+0xccc>
8000956a:	fa ca f9 44 	sub	r10,sp,-1724
8000956e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009572:	ec fa fd 88 	ld.w	r10,r6[-632]
80009576:	c1 68       	rjmp	800095a2 <_vfprintf_r+0xcf6>
80009578:	41 09       	lddsp	r9,sp[0x40]
8000957a:	59 f8       	cp.w	r8,31
8000957c:	e0 89 00 10 	brgt	8000959c <_vfprintf_r+0xcf0>
80009580:	f2 ca ff fc 	sub	r10,r9,-4
80009584:	51 0a       	stdsp	sp[0x40],r10
80009586:	fa c6 f9 44 	sub	r6,sp,-1724
8000958a:	72 0a       	ld.w	r10,r9[0x0]
8000958c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009590:	f3 4a fd 88 	st.w	r9[-632],r10
80009594:	2f f8       	sub	r8,-1
80009596:	fb 48 06 b4 	st.w	sp[1716],r8
8000959a:	c0 48       	rjmp	800095a2 <_vfprintf_r+0xcf6>
8000959c:	72 0a       	ld.w	r10,r9[0x0]
8000959e:	2f c9       	sub	r9,-4
800095a0:	51 09       	stdsp	sp[0x40],r9
800095a2:	40 be       	lddsp	lr,sp[0x2c]
800095a4:	95 0e       	st.w	r10[0x0],lr
800095a6:	fe 9f fa 11 	bral	800089c8 <_vfprintf_r+0x11c>
800095aa:	50 a7       	stdsp	sp[0x28],r7
800095ac:	50 80       	stdsp	sp[0x20],r0
800095ae:	0c 97       	mov	r7,r6
800095b0:	04 94       	mov	r4,r2
800095b2:	06 96       	mov	r6,r3
800095b4:	02 92       	mov	r2,r1
800095b6:	40 93       	lddsp	r3,sp[0x24]
800095b8:	10 90       	mov	r0,r8
800095ba:	40 41       	lddsp	r1,sp[0x10]
800095bc:	a5 a5       	sbr	r5,0x4
800095be:	c0 a8       	rjmp	800095d2 <_vfprintf_r+0xd26>
800095c0:	50 a7       	stdsp	sp[0x28],r7
800095c2:	50 80       	stdsp	sp[0x20],r0
800095c4:	0c 97       	mov	r7,r6
800095c6:	04 94       	mov	r4,r2
800095c8:	06 96       	mov	r6,r3
800095ca:	02 92       	mov	r2,r1
800095cc:	40 93       	lddsp	r3,sp[0x24]
800095ce:	10 90       	mov	r0,r8
800095d0:	40 41       	lddsp	r1,sp[0x10]
800095d2:	ed b5 00 05 	bld	r5,0x5
800095d6:	c5 d1       	brne	80009690 <_vfprintf_r+0xde4>
800095d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095dc:	40 3c       	lddsp	r12,sp[0xc]
800095de:	58 0c       	cp.w	r12,0
800095e0:	c2 60       	breq	8000962c <_vfprintf_r+0xd80>
800095e2:	10 36       	cp.w	r6,r8
800095e4:	c0 a4       	brge	800095f8 <_vfprintf_r+0xd4c>
800095e6:	fa cb f9 44 	sub	r11,sp,-1724
800095ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095ee:	ec e8 fd 88 	ld.d	r8,r6[-632]
800095f2:	fa e9 00 00 	st.d	sp[0],r8
800095f6:	c1 88       	rjmp	80009626 <_vfprintf_r+0xd7a>
800095f8:	fa c8 f9 50 	sub	r8,sp,-1712
800095fc:	1a d8       	st.w	--sp,r8
800095fe:	fa c8 fa b8 	sub	r8,sp,-1352
80009602:	04 9a       	mov	r10,r2
80009604:	1a d8       	st.w	--sp,r8
80009606:	0c 9b       	mov	r11,r6
80009608:	fa c8 fb b4 	sub	r8,sp,-1100
8000960c:	08 9c       	mov	r12,r4
8000960e:	1a d8       	st.w	--sp,r8
80009610:	fa c8 f9 40 	sub	r8,sp,-1728
80009614:	fa c9 ff b4 	sub	r9,sp,-76
80009618:	fe b0 f7 b2 	rcall	8000857c <get_arg>
8000961c:	2f dd       	sub	sp,-12
8000961e:	f8 ea 00 00 	ld.d	r10,r12[0]
80009622:	fa eb 00 00 	st.d	sp[0],r10
80009626:	30 08       	mov	r8,0
80009628:	e0 8f 03 de 	bral	80009de4 <_vfprintf_r+0x1538>
8000962c:	ee ca ff ff 	sub	r10,r7,-1
80009630:	10 37       	cp.w	r7,r8
80009632:	c0 b4       	brge	80009648 <_vfprintf_r+0xd9c>
80009634:	fa c9 f9 44 	sub	r9,sp,-1724
80009638:	14 97       	mov	r7,r10
8000963a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000963e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009642:	fa eb 00 00 	st.d	sp[0],r10
80009646:	c1 88       	rjmp	80009676 <_vfprintf_r+0xdca>
80009648:	41 09       	lddsp	r9,sp[0x40]
8000964a:	59 f8       	cp.w	r8,31
8000964c:	e0 89 00 18 	brgt	8000967c <_vfprintf_r+0xdd0>
80009650:	f2 e6 00 00 	ld.d	r6,r9[0]
80009654:	f2 cb ff f8 	sub	r11,r9,-8
80009658:	fa e7 00 00 	st.d	sp[0],r6
8000965c:	51 0b       	stdsp	sp[0x40],r11
8000965e:	fa c6 f9 44 	sub	r6,sp,-1724
80009662:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009666:	fa e6 00 00 	ld.d	r6,sp[0]
8000966a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000966e:	2f f8       	sub	r8,-1
80009670:	14 97       	mov	r7,r10
80009672:	fb 48 06 b4 	st.w	sp[1716],r8
80009676:	40 38       	lddsp	r8,sp[0xc]
80009678:	e0 8f 03 b6 	bral	80009de4 <_vfprintf_r+0x1538>
8000967c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009680:	40 38       	lddsp	r8,sp[0xc]
80009682:	fa e7 00 00 	st.d	sp[0],r6
80009686:	2f 89       	sub	r9,-8
80009688:	14 97       	mov	r7,r10
8000968a:	51 09       	stdsp	sp[0x40],r9
8000968c:	e0 8f 03 ac 	bral	80009de4 <_vfprintf_r+0x1538>
80009690:	ed b5 00 04 	bld	r5,0x4
80009694:	c1 61       	brne	800096c0 <_vfprintf_r+0xe14>
80009696:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000969a:	40 3e       	lddsp	lr,sp[0xc]
8000969c:	58 0e       	cp.w	lr,0
8000969e:	c0 80       	breq	800096ae <_vfprintf_r+0xe02>
800096a0:	10 36       	cp.w	r6,r8
800096a2:	c6 74       	brge	80009770 <_vfprintf_r+0xec4>
800096a4:	fa cc f9 44 	sub	r12,sp,-1724
800096a8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800096ac:	c8 08       	rjmp	800097ac <_vfprintf_r+0xf00>
800096ae:	ee ca ff ff 	sub	r10,r7,-1
800096b2:	10 37       	cp.w	r7,r8
800096b4:	c7 f4       	brge	800097b2 <_vfprintf_r+0xf06>
800096b6:	fa cb f9 44 	sub	r11,sp,-1724
800096ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096be:	c7 68       	rjmp	800097aa <_vfprintf_r+0xefe>
800096c0:	ed b5 00 06 	bld	r5,0x6
800096c4:	c4 a1       	brne	80009758 <_vfprintf_r+0xeac>
800096c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096ca:	40 3c       	lddsp	r12,sp[0xc]
800096cc:	58 0c       	cp.w	r12,0
800096ce:	c1 d0       	breq	80009708 <_vfprintf_r+0xe5c>
800096d0:	10 36       	cp.w	r6,r8
800096d2:	c0 64       	brge	800096de <_vfprintf_r+0xe32>
800096d4:	fa cb f9 44 	sub	r11,sp,-1724
800096d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096dc:	c1 f8       	rjmp	8000971a <_vfprintf_r+0xe6e>
800096de:	fa c8 f9 50 	sub	r8,sp,-1712
800096e2:	1a d8       	st.w	--sp,r8
800096e4:	fa c8 fa b8 	sub	r8,sp,-1352
800096e8:	1a d8       	st.w	--sp,r8
800096ea:	fa c8 fb b4 	sub	r8,sp,-1100
800096ee:	1a d8       	st.w	--sp,r8
800096f0:	fa c8 f9 40 	sub	r8,sp,-1728
800096f4:	fa c9 ff b4 	sub	r9,sp,-76
800096f8:	04 9a       	mov	r10,r2
800096fa:	0c 9b       	mov	r11,r6
800096fc:	08 9c       	mov	r12,r4
800096fe:	fe b0 f7 3f 	rcall	8000857c <get_arg>
80009702:	2f dd       	sub	sp,-12
80009704:	98 18       	ld.sh	r8,r12[0x2]
80009706:	c2 68       	rjmp	80009752 <_vfprintf_r+0xea6>
80009708:	ee ca ff ff 	sub	r10,r7,-1
8000970c:	10 37       	cp.w	r7,r8
8000970e:	c0 94       	brge	80009720 <_vfprintf_r+0xe74>
80009710:	fa c9 f9 44 	sub	r9,sp,-1724
80009714:	14 97       	mov	r7,r10
80009716:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000971a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000971e:	c1 a8       	rjmp	80009752 <_vfprintf_r+0xea6>
80009720:	41 09       	lddsp	r9,sp[0x40]
80009722:	59 f8       	cp.w	r8,31
80009724:	e0 89 00 13 	brgt	8000974a <_vfprintf_r+0xe9e>
80009728:	f2 cb ff fc 	sub	r11,r9,-4
8000972c:	51 0b       	stdsp	sp[0x40],r11
8000972e:	72 09       	ld.w	r9,r9[0x0]
80009730:	fa c6 f9 44 	sub	r6,sp,-1724
80009734:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009738:	2f f8       	sub	r8,-1
8000973a:	f7 49 fd 88 	st.w	r11[-632],r9
8000973e:	fb 48 06 b4 	st.w	sp[1716],r8
80009742:	14 97       	mov	r7,r10
80009744:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009748:	c0 58       	rjmp	80009752 <_vfprintf_r+0xea6>
8000974a:	92 18       	ld.sh	r8,r9[0x2]
8000974c:	14 97       	mov	r7,r10
8000974e:	2f c9       	sub	r9,-4
80009750:	51 09       	stdsp	sp[0x40],r9
80009752:	5c 78       	castu.h	r8
80009754:	50 18       	stdsp	sp[0x4],r8
80009756:	c4 68       	rjmp	800097e2 <_vfprintf_r+0xf36>
80009758:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000975c:	40 3c       	lddsp	r12,sp[0xc]
8000975e:	58 0c       	cp.w	r12,0
80009760:	c1 d0       	breq	8000979a <_vfprintf_r+0xeee>
80009762:	10 36       	cp.w	r6,r8
80009764:	c0 64       	brge	80009770 <_vfprintf_r+0xec4>
80009766:	fa cb f9 44 	sub	r11,sp,-1724
8000976a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000976e:	c1 f8       	rjmp	800097ac <_vfprintf_r+0xf00>
80009770:	fa c8 f9 50 	sub	r8,sp,-1712
80009774:	1a d8       	st.w	--sp,r8
80009776:	fa c8 fa b8 	sub	r8,sp,-1352
8000977a:	0c 9b       	mov	r11,r6
8000977c:	1a d8       	st.w	--sp,r8
8000977e:	fa c8 fb b4 	sub	r8,sp,-1100
80009782:	04 9a       	mov	r10,r2
80009784:	1a d8       	st.w	--sp,r8
80009786:	08 9c       	mov	r12,r4
80009788:	fa c8 f9 40 	sub	r8,sp,-1728
8000978c:	fa c9 ff b4 	sub	r9,sp,-76
80009790:	fe b0 f6 f6 	rcall	8000857c <get_arg>
80009794:	2f dd       	sub	sp,-12
80009796:	78 0b       	ld.w	r11,r12[0x0]
80009798:	c2 48       	rjmp	800097e0 <_vfprintf_r+0xf34>
8000979a:	ee ca ff ff 	sub	r10,r7,-1
8000979e:	10 37       	cp.w	r7,r8
800097a0:	c0 94       	brge	800097b2 <_vfprintf_r+0xf06>
800097a2:	fa c9 f9 44 	sub	r9,sp,-1724
800097a6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800097aa:	14 97       	mov	r7,r10
800097ac:	ec fb fd 88 	ld.w	r11,r6[-632]
800097b0:	c1 88       	rjmp	800097e0 <_vfprintf_r+0xf34>
800097b2:	41 09       	lddsp	r9,sp[0x40]
800097b4:	59 f8       	cp.w	r8,31
800097b6:	e0 89 00 11 	brgt	800097d8 <_vfprintf_r+0xf2c>
800097ba:	f2 cb ff fc 	sub	r11,r9,-4
800097be:	51 0b       	stdsp	sp[0x40],r11
800097c0:	fa c6 f9 44 	sub	r6,sp,-1724
800097c4:	72 0b       	ld.w	r11,r9[0x0]
800097c6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800097ca:	f3 4b fd 88 	st.w	r9[-632],r11
800097ce:	2f f8       	sub	r8,-1
800097d0:	14 97       	mov	r7,r10
800097d2:	fb 48 06 b4 	st.w	sp[1716],r8
800097d6:	c0 58       	rjmp	800097e0 <_vfprintf_r+0xf34>
800097d8:	72 0b       	ld.w	r11,r9[0x0]
800097da:	14 97       	mov	r7,r10
800097dc:	2f c9       	sub	r9,-4
800097de:	51 09       	stdsp	sp[0x40],r9
800097e0:	50 1b       	stdsp	sp[0x4],r11
800097e2:	30 0e       	mov	lr,0
800097e4:	50 0e       	stdsp	sp[0x0],lr
800097e6:	1c 98       	mov	r8,lr
800097e8:	e0 8f 02 fe 	bral	80009de4 <_vfprintf_r+0x1538>
800097ec:	50 a7       	stdsp	sp[0x28],r7
800097ee:	50 80       	stdsp	sp[0x20],r0
800097f0:	0c 97       	mov	r7,r6
800097f2:	04 94       	mov	r4,r2
800097f4:	06 96       	mov	r6,r3
800097f6:	02 92       	mov	r2,r1
800097f8:	40 93       	lddsp	r3,sp[0x24]
800097fa:	40 41       	lddsp	r1,sp[0x10]
800097fc:	0e 99       	mov	r9,r7
800097fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009802:	40 3c       	lddsp	r12,sp[0xc]
80009804:	58 0c       	cp.w	r12,0
80009806:	c1 d0       	breq	80009840 <_vfprintf_r+0xf94>
80009808:	10 36       	cp.w	r6,r8
8000980a:	c0 64       	brge	80009816 <_vfprintf_r+0xf6a>
8000980c:	fa cb f9 44 	sub	r11,sp,-1724
80009810:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009814:	c1 d8       	rjmp	8000984e <_vfprintf_r+0xfa2>
80009816:	fa c8 f9 50 	sub	r8,sp,-1712
8000981a:	1a d8       	st.w	--sp,r8
8000981c:	fa c8 fa b8 	sub	r8,sp,-1352
80009820:	1a d8       	st.w	--sp,r8
80009822:	fa c8 fb b4 	sub	r8,sp,-1100
80009826:	1a d8       	st.w	--sp,r8
80009828:	fa c9 ff b4 	sub	r9,sp,-76
8000982c:	fa c8 f9 40 	sub	r8,sp,-1728
80009830:	04 9a       	mov	r10,r2
80009832:	0c 9b       	mov	r11,r6
80009834:	08 9c       	mov	r12,r4
80009836:	fe b0 f6 a3 	rcall	8000857c <get_arg>
8000983a:	2f dd       	sub	sp,-12
8000983c:	78 09       	ld.w	r9,r12[0x0]
8000983e:	c2 18       	rjmp	80009880 <_vfprintf_r+0xfd4>
80009840:	2f f7       	sub	r7,-1
80009842:	10 39       	cp.w	r9,r8
80009844:	c0 84       	brge	80009854 <_vfprintf_r+0xfa8>
80009846:	fa ca f9 44 	sub	r10,sp,-1724
8000984a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000984e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009852:	c1 78       	rjmp	80009880 <_vfprintf_r+0xfd4>
80009854:	41 09       	lddsp	r9,sp[0x40]
80009856:	59 f8       	cp.w	r8,31
80009858:	e0 89 00 10 	brgt	80009878 <_vfprintf_r+0xfcc>
8000985c:	f2 ca ff fc 	sub	r10,r9,-4
80009860:	51 0a       	stdsp	sp[0x40],r10
80009862:	fa c6 f9 44 	sub	r6,sp,-1724
80009866:	72 09       	ld.w	r9,r9[0x0]
80009868:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000986c:	f5 49 fd 88 	st.w	r10[-632],r9
80009870:	2f f8       	sub	r8,-1
80009872:	fb 48 06 b4 	st.w	sp[1716],r8
80009876:	c0 58       	rjmp	80009880 <_vfprintf_r+0xfd4>
80009878:	f2 c8 ff fc 	sub	r8,r9,-4
8000987c:	51 08       	stdsp	sp[0x40],r8
8000987e:	72 09       	ld.w	r9,r9[0x0]
80009880:	33 08       	mov	r8,48
80009882:	fb 68 06 b8 	st.b	sp[1720],r8
80009886:	37 88       	mov	r8,120
80009888:	30 0e       	mov	lr,0
8000988a:	fb 68 06 b9 	st.b	sp[1721],r8
8000988e:	fe cc b0 26 	sub	r12,pc,-20442
80009892:	50 19       	stdsp	sp[0x4],r9
80009894:	a1 b5       	sbr	r5,0x1
80009896:	50 0e       	stdsp	sp[0x0],lr
80009898:	50 dc       	stdsp	sp[0x34],r12
8000989a:	30 28       	mov	r8,2
8000989c:	37 80       	mov	r0,120
8000989e:	e0 8f 02 a3 	bral	80009de4 <_vfprintf_r+0x1538>
800098a2:	50 a7       	stdsp	sp[0x28],r7
800098a4:	50 80       	stdsp	sp[0x20],r0
800098a6:	10 90       	mov	r0,r8
800098a8:	30 08       	mov	r8,0
800098aa:	fb 68 06 bb 	st.b	sp[1723],r8
800098ae:	0c 97       	mov	r7,r6
800098b0:	04 94       	mov	r4,r2
800098b2:	06 96       	mov	r6,r3
800098b4:	02 92       	mov	r2,r1
800098b6:	40 93       	lddsp	r3,sp[0x24]
800098b8:	40 41       	lddsp	r1,sp[0x10]
800098ba:	0e 99       	mov	r9,r7
800098bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800098c0:	40 3b       	lddsp	r11,sp[0xc]
800098c2:	58 0b       	cp.w	r11,0
800098c4:	c1 d0       	breq	800098fe <_vfprintf_r+0x1052>
800098c6:	10 36       	cp.w	r6,r8
800098c8:	c0 64       	brge	800098d4 <_vfprintf_r+0x1028>
800098ca:	fa ca f9 44 	sub	r10,sp,-1724
800098ce:	f4 06 00 36 	add	r6,r10,r6<<0x3
800098d2:	c1 d8       	rjmp	8000990c <_vfprintf_r+0x1060>
800098d4:	fa c8 f9 50 	sub	r8,sp,-1712
800098d8:	1a d8       	st.w	--sp,r8
800098da:	fa c8 fa b8 	sub	r8,sp,-1352
800098de:	1a d8       	st.w	--sp,r8
800098e0:	fa c8 fb b4 	sub	r8,sp,-1100
800098e4:	0c 9b       	mov	r11,r6
800098e6:	1a d8       	st.w	--sp,r8
800098e8:	04 9a       	mov	r10,r2
800098ea:	fa c8 f9 40 	sub	r8,sp,-1728
800098ee:	fa c9 ff b4 	sub	r9,sp,-76
800098f2:	08 9c       	mov	r12,r4
800098f4:	fe b0 f6 44 	rcall	8000857c <get_arg>
800098f8:	2f dd       	sub	sp,-12
800098fa:	78 06       	ld.w	r6,r12[0x0]
800098fc:	c2 08       	rjmp	8000993c <_vfprintf_r+0x1090>
800098fe:	2f f7       	sub	r7,-1
80009900:	10 39       	cp.w	r9,r8
80009902:	c0 84       	brge	80009912 <_vfprintf_r+0x1066>
80009904:	fa c9 f9 44 	sub	r9,sp,-1724
80009908:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000990c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009910:	c1 68       	rjmp	8000993c <_vfprintf_r+0x1090>
80009912:	41 09       	lddsp	r9,sp[0x40]
80009914:	59 f8       	cp.w	r8,31
80009916:	e0 89 00 10 	brgt	80009936 <_vfprintf_r+0x108a>
8000991a:	f2 ca ff fc 	sub	r10,r9,-4
8000991e:	51 0a       	stdsp	sp[0x40],r10
80009920:	72 06       	ld.w	r6,r9[0x0]
80009922:	fa ce f9 44 	sub	lr,sp,-1724
80009926:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000992a:	f3 46 fd 88 	st.w	r9[-632],r6
8000992e:	2f f8       	sub	r8,-1
80009930:	fb 48 06 b4 	st.w	sp[1716],r8
80009934:	c0 48       	rjmp	8000993c <_vfprintf_r+0x1090>
80009936:	72 06       	ld.w	r6,r9[0x0]
80009938:	2f c9       	sub	r9,-4
8000993a:	51 09       	stdsp	sp[0x40],r9
8000993c:	40 2c       	lddsp	r12,sp[0x8]
8000993e:	58 0c       	cp.w	r12,0
80009940:	c1 05       	brlt	80009960 <_vfprintf_r+0x10b4>
80009942:	18 9a       	mov	r10,r12
80009944:	30 0b       	mov	r11,0
80009946:	0c 9c       	mov	r12,r6
80009948:	e0 a0 12 38 	rcall	8000bdb8 <memchr>
8000994c:	e0 80 02 df 	breq	80009f0a <_vfprintf_r+0x165e>
80009950:	f8 06 01 02 	sub	r2,r12,r6
80009954:	40 2b       	lddsp	r11,sp[0x8]
80009956:	16 32       	cp.w	r2,r11
80009958:	e0 89 02 d9 	brgt	80009f0a <_vfprintf_r+0x165e>
8000995c:	e0 8f 02 d4 	bral	80009f04 <_vfprintf_r+0x1658>
80009960:	30 0a       	mov	r10,0
80009962:	0c 9c       	mov	r12,r6
80009964:	50 2a       	stdsp	sp[0x8],r10
80009966:	e0 a0 15 99 	rcall	8000c498 <strlen>
8000996a:	18 92       	mov	r2,r12
8000996c:	e0 8f 02 d2 	bral	80009f10 <_vfprintf_r+0x1664>
80009970:	50 a7       	stdsp	sp[0x28],r7
80009972:	50 80       	stdsp	sp[0x20],r0
80009974:	0c 97       	mov	r7,r6
80009976:	04 94       	mov	r4,r2
80009978:	06 96       	mov	r6,r3
8000997a:	02 92       	mov	r2,r1
8000997c:	40 93       	lddsp	r3,sp[0x24]
8000997e:	10 90       	mov	r0,r8
80009980:	40 41       	lddsp	r1,sp[0x10]
80009982:	a5 a5       	sbr	r5,0x4
80009984:	c0 a8       	rjmp	80009998 <_vfprintf_r+0x10ec>
80009986:	50 a7       	stdsp	sp[0x28],r7
80009988:	50 80       	stdsp	sp[0x20],r0
8000998a:	0c 97       	mov	r7,r6
8000998c:	04 94       	mov	r4,r2
8000998e:	06 96       	mov	r6,r3
80009990:	02 92       	mov	r2,r1
80009992:	40 93       	lddsp	r3,sp[0x24]
80009994:	10 90       	mov	r0,r8
80009996:	40 41       	lddsp	r1,sp[0x10]
80009998:	ed b5 00 05 	bld	r5,0x5
8000999c:	c5 61       	brne	80009a48 <_vfprintf_r+0x119c>
8000999e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800099a2:	40 39       	lddsp	r9,sp[0xc]
800099a4:	58 09       	cp.w	r9,0
800099a6:	c2 10       	breq	800099e8 <_vfprintf_r+0x113c>
800099a8:	10 36       	cp.w	r6,r8
800099aa:	c0 74       	brge	800099b8 <_vfprintf_r+0x110c>
800099ac:	fa c8 f9 44 	sub	r8,sp,-1724
800099b0:	f0 06 00 36 	add	r6,r8,r6<<0x3
800099b4:	c2 38       	rjmp	800099fa <_vfprintf_r+0x114e>
800099b6:	d7 03       	nop
800099b8:	fa c8 f9 50 	sub	r8,sp,-1712
800099bc:	1a d8       	st.w	--sp,r8
800099be:	fa c8 fa b8 	sub	r8,sp,-1352
800099c2:	1a d8       	st.w	--sp,r8
800099c4:	fa c8 fb b4 	sub	r8,sp,-1100
800099c8:	1a d8       	st.w	--sp,r8
800099ca:	fa c8 f9 40 	sub	r8,sp,-1728
800099ce:	fa c9 ff b4 	sub	r9,sp,-76
800099d2:	04 9a       	mov	r10,r2
800099d4:	0c 9b       	mov	r11,r6
800099d6:	08 9c       	mov	r12,r4
800099d8:	fe b0 f5 d2 	rcall	8000857c <get_arg>
800099dc:	2f dd       	sub	sp,-12
800099de:	f8 e8 00 00 	ld.d	r8,r12[0]
800099e2:	fa e9 00 00 	st.d	sp[0],r8
800099e6:	c2 e8       	rjmp	80009a42 <_vfprintf_r+0x1196>
800099e8:	ee ca ff ff 	sub	r10,r7,-1
800099ec:	10 37       	cp.w	r7,r8
800099ee:	c0 b4       	brge	80009a04 <_vfprintf_r+0x1158>
800099f0:	fa c8 f9 44 	sub	r8,sp,-1724
800099f4:	14 97       	mov	r7,r10
800099f6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800099fa:	ec ea fd 88 	ld.d	r10,r6[-632]
800099fe:	fa eb 00 00 	st.d	sp[0],r10
80009a02:	c2 08       	rjmp	80009a42 <_vfprintf_r+0x1196>
80009a04:	41 09       	lddsp	r9,sp[0x40]
80009a06:	59 f8       	cp.w	r8,31
80009a08:	e0 89 00 16 	brgt	80009a34 <_vfprintf_r+0x1188>
80009a0c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009a10:	f2 cb ff f8 	sub	r11,r9,-8
80009a14:	fa e7 00 00 	st.d	sp[0],r6
80009a18:	51 0b       	stdsp	sp[0x40],r11
80009a1a:	fa c6 f9 44 	sub	r6,sp,-1724
80009a1e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009a22:	fa e6 00 00 	ld.d	r6,sp[0]
80009a26:	f2 e7 fd 88 	st.d	r9[-632],r6
80009a2a:	2f f8       	sub	r8,-1
80009a2c:	14 97       	mov	r7,r10
80009a2e:	fb 48 06 b4 	st.w	sp[1716],r8
80009a32:	c0 88       	rjmp	80009a42 <_vfprintf_r+0x1196>
80009a34:	f2 e6 00 00 	ld.d	r6,r9[0]
80009a38:	2f 89       	sub	r9,-8
80009a3a:	fa e7 00 00 	st.d	sp[0],r6
80009a3e:	51 09       	stdsp	sp[0x40],r9
80009a40:	14 97       	mov	r7,r10
80009a42:	30 18       	mov	r8,1
80009a44:	e0 8f 01 d0 	bral	80009de4 <_vfprintf_r+0x1538>
80009a48:	ed b5 00 04 	bld	r5,0x4
80009a4c:	c1 61       	brne	80009a78 <_vfprintf_r+0x11cc>
80009a4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a52:	40 3e       	lddsp	lr,sp[0xc]
80009a54:	58 0e       	cp.w	lr,0
80009a56:	c0 80       	breq	80009a66 <_vfprintf_r+0x11ba>
80009a58:	10 36       	cp.w	r6,r8
80009a5a:	c6 74       	brge	80009b28 <_vfprintf_r+0x127c>
80009a5c:	fa cc f9 44 	sub	r12,sp,-1724
80009a60:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009a64:	c8 08       	rjmp	80009b64 <_vfprintf_r+0x12b8>
80009a66:	ee ca ff ff 	sub	r10,r7,-1
80009a6a:	10 37       	cp.w	r7,r8
80009a6c:	c7 f4       	brge	80009b6a <_vfprintf_r+0x12be>
80009a6e:	fa cb f9 44 	sub	r11,sp,-1724
80009a72:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009a76:	c7 68       	rjmp	80009b62 <_vfprintf_r+0x12b6>
80009a78:	ed b5 00 06 	bld	r5,0x6
80009a7c:	c4 a1       	brne	80009b10 <_vfprintf_r+0x1264>
80009a7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a82:	40 3c       	lddsp	r12,sp[0xc]
80009a84:	58 0c       	cp.w	r12,0
80009a86:	c1 d0       	breq	80009ac0 <_vfprintf_r+0x1214>
80009a88:	10 36       	cp.w	r6,r8
80009a8a:	c0 64       	brge	80009a96 <_vfprintf_r+0x11ea>
80009a8c:	fa cb f9 44 	sub	r11,sp,-1724
80009a90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009a94:	c1 f8       	rjmp	80009ad2 <_vfprintf_r+0x1226>
80009a96:	fa c8 f9 50 	sub	r8,sp,-1712
80009a9a:	1a d8       	st.w	--sp,r8
80009a9c:	fa c8 fa b8 	sub	r8,sp,-1352
80009aa0:	1a d8       	st.w	--sp,r8
80009aa2:	fa c8 fb b4 	sub	r8,sp,-1100
80009aa6:	1a d8       	st.w	--sp,r8
80009aa8:	fa c8 f9 40 	sub	r8,sp,-1728
80009aac:	fa c9 ff b4 	sub	r9,sp,-76
80009ab0:	04 9a       	mov	r10,r2
80009ab2:	0c 9b       	mov	r11,r6
80009ab4:	08 9c       	mov	r12,r4
80009ab6:	fe b0 f5 63 	rcall	8000857c <get_arg>
80009aba:	2f dd       	sub	sp,-12
80009abc:	98 18       	ld.sh	r8,r12[0x2]
80009abe:	c2 68       	rjmp	80009b0a <_vfprintf_r+0x125e>
80009ac0:	ee ca ff ff 	sub	r10,r7,-1
80009ac4:	10 37       	cp.w	r7,r8
80009ac6:	c0 94       	brge	80009ad8 <_vfprintf_r+0x122c>
80009ac8:	fa c9 f9 44 	sub	r9,sp,-1724
80009acc:	14 97       	mov	r7,r10
80009ace:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009ad2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009ad6:	c1 a8       	rjmp	80009b0a <_vfprintf_r+0x125e>
80009ad8:	41 09       	lddsp	r9,sp[0x40]
80009ada:	59 f8       	cp.w	r8,31
80009adc:	e0 89 00 13 	brgt	80009b02 <_vfprintf_r+0x1256>
80009ae0:	f2 cb ff fc 	sub	r11,r9,-4
80009ae4:	51 0b       	stdsp	sp[0x40],r11
80009ae6:	72 09       	ld.w	r9,r9[0x0]
80009ae8:	fa c6 f9 44 	sub	r6,sp,-1724
80009aec:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009af0:	2f f8       	sub	r8,-1
80009af2:	f7 49 fd 88 	st.w	r11[-632],r9
80009af6:	fb 48 06 b4 	st.w	sp[1716],r8
80009afa:	14 97       	mov	r7,r10
80009afc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009b00:	c0 58       	rjmp	80009b0a <_vfprintf_r+0x125e>
80009b02:	92 18       	ld.sh	r8,r9[0x2]
80009b04:	14 97       	mov	r7,r10
80009b06:	2f c9       	sub	r9,-4
80009b08:	51 09       	stdsp	sp[0x40],r9
80009b0a:	5c 78       	castu.h	r8
80009b0c:	50 18       	stdsp	sp[0x4],r8
80009b0e:	c4 68       	rjmp	80009b9a <_vfprintf_r+0x12ee>
80009b10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b14:	40 3c       	lddsp	r12,sp[0xc]
80009b16:	58 0c       	cp.w	r12,0
80009b18:	c1 d0       	breq	80009b52 <_vfprintf_r+0x12a6>
80009b1a:	10 36       	cp.w	r6,r8
80009b1c:	c0 64       	brge	80009b28 <_vfprintf_r+0x127c>
80009b1e:	fa cb f9 44 	sub	r11,sp,-1724
80009b22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b26:	c1 f8       	rjmp	80009b64 <_vfprintf_r+0x12b8>
80009b28:	fa c8 f9 50 	sub	r8,sp,-1712
80009b2c:	1a d8       	st.w	--sp,r8
80009b2e:	fa c8 fa b8 	sub	r8,sp,-1352
80009b32:	0c 9b       	mov	r11,r6
80009b34:	1a d8       	st.w	--sp,r8
80009b36:	fa c8 fb b4 	sub	r8,sp,-1100
80009b3a:	04 9a       	mov	r10,r2
80009b3c:	1a d8       	st.w	--sp,r8
80009b3e:	08 9c       	mov	r12,r4
80009b40:	fa c8 f9 40 	sub	r8,sp,-1728
80009b44:	fa c9 ff b4 	sub	r9,sp,-76
80009b48:	fe b0 f5 1a 	rcall	8000857c <get_arg>
80009b4c:	2f dd       	sub	sp,-12
80009b4e:	78 0b       	ld.w	r11,r12[0x0]
80009b50:	c2 48       	rjmp	80009b98 <_vfprintf_r+0x12ec>
80009b52:	ee ca ff ff 	sub	r10,r7,-1
80009b56:	10 37       	cp.w	r7,r8
80009b58:	c0 94       	brge	80009b6a <_vfprintf_r+0x12be>
80009b5a:	fa c9 f9 44 	sub	r9,sp,-1724
80009b5e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009b62:	14 97       	mov	r7,r10
80009b64:	ec fb fd 88 	ld.w	r11,r6[-632]
80009b68:	c1 88       	rjmp	80009b98 <_vfprintf_r+0x12ec>
80009b6a:	41 09       	lddsp	r9,sp[0x40]
80009b6c:	59 f8       	cp.w	r8,31
80009b6e:	e0 89 00 11 	brgt	80009b90 <_vfprintf_r+0x12e4>
80009b72:	f2 cb ff fc 	sub	r11,r9,-4
80009b76:	51 0b       	stdsp	sp[0x40],r11
80009b78:	fa c6 f9 44 	sub	r6,sp,-1724
80009b7c:	72 0b       	ld.w	r11,r9[0x0]
80009b7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009b82:	f3 4b fd 88 	st.w	r9[-632],r11
80009b86:	2f f8       	sub	r8,-1
80009b88:	14 97       	mov	r7,r10
80009b8a:	fb 48 06 b4 	st.w	sp[1716],r8
80009b8e:	c0 58       	rjmp	80009b98 <_vfprintf_r+0x12ec>
80009b90:	72 0b       	ld.w	r11,r9[0x0]
80009b92:	14 97       	mov	r7,r10
80009b94:	2f c9       	sub	r9,-4
80009b96:	51 09       	stdsp	sp[0x40],r9
80009b98:	50 1b       	stdsp	sp[0x4],r11
80009b9a:	30 0e       	mov	lr,0
80009b9c:	30 18       	mov	r8,1
80009b9e:	50 0e       	stdsp	sp[0x0],lr
80009ba0:	c2 29       	rjmp	80009de4 <_vfprintf_r+0x1538>
80009ba2:	50 a7       	stdsp	sp[0x28],r7
80009ba4:	50 80       	stdsp	sp[0x20],r0
80009ba6:	0c 97       	mov	r7,r6
80009ba8:	04 94       	mov	r4,r2
80009baa:	06 96       	mov	r6,r3
80009bac:	02 92       	mov	r2,r1
80009bae:	fe cc b3 46 	sub	r12,pc,-19642
80009bb2:	40 93       	lddsp	r3,sp[0x24]
80009bb4:	10 90       	mov	r0,r8
80009bb6:	40 41       	lddsp	r1,sp[0x10]
80009bb8:	50 dc       	stdsp	sp[0x34],r12
80009bba:	ed b5 00 05 	bld	r5,0x5
80009bbe:	c5 51       	brne	80009c68 <_vfprintf_r+0x13bc>
80009bc0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bc4:	40 3b       	lddsp	r11,sp[0xc]
80009bc6:	58 0b       	cp.w	r11,0
80009bc8:	c2 20       	breq	80009c0c <_vfprintf_r+0x1360>
80009bca:	10 36       	cp.w	r6,r8
80009bcc:	c0 a4       	brge	80009be0 <_vfprintf_r+0x1334>
80009bce:	fa ca f9 44 	sub	r10,sp,-1724
80009bd2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009bd6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009bda:	fa e9 00 00 	st.d	sp[0],r8
80009bde:	cf 28       	rjmp	80009dc2 <_vfprintf_r+0x1516>
80009be0:	fa c8 f9 50 	sub	r8,sp,-1712
80009be4:	1a d8       	st.w	--sp,r8
80009be6:	fa c8 fa b8 	sub	r8,sp,-1352
80009bea:	04 9a       	mov	r10,r2
80009bec:	1a d8       	st.w	--sp,r8
80009bee:	0c 9b       	mov	r11,r6
80009bf0:	fa c8 fb b4 	sub	r8,sp,-1100
80009bf4:	08 9c       	mov	r12,r4
80009bf6:	1a d8       	st.w	--sp,r8
80009bf8:	fa c8 f9 40 	sub	r8,sp,-1728
80009bfc:	fa c9 ff b4 	sub	r9,sp,-76
80009c00:	fe b0 f4 be 	rcall	8000857c <get_arg>
80009c04:	2f dd       	sub	sp,-12
80009c06:	f8 ea 00 00 	ld.d	r10,r12[0]
80009c0a:	c0 c8       	rjmp	80009c22 <_vfprintf_r+0x1376>
80009c0c:	ee ca ff ff 	sub	r10,r7,-1
80009c10:	10 37       	cp.w	r7,r8
80009c12:	c0 b4       	brge	80009c28 <_vfprintf_r+0x137c>
80009c14:	fa c9 f9 44 	sub	r9,sp,-1724
80009c18:	14 97       	mov	r7,r10
80009c1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009c22:	fa eb 00 00 	st.d	sp[0],r10
80009c26:	cc e8       	rjmp	80009dc2 <_vfprintf_r+0x1516>
80009c28:	41 09       	lddsp	r9,sp[0x40]
80009c2a:	59 f8       	cp.w	r8,31
80009c2c:	e0 89 00 16 	brgt	80009c58 <_vfprintf_r+0x13ac>
80009c30:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c34:	f2 cb ff f8 	sub	r11,r9,-8
80009c38:	fa e7 00 00 	st.d	sp[0],r6
80009c3c:	51 0b       	stdsp	sp[0x40],r11
80009c3e:	fa c6 f9 44 	sub	r6,sp,-1724
80009c42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c46:	fa e6 00 00 	ld.d	r6,sp[0]
80009c4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80009c4e:	2f f8       	sub	r8,-1
80009c50:	14 97       	mov	r7,r10
80009c52:	fb 48 06 b4 	st.w	sp[1716],r8
80009c56:	cb 68       	rjmp	80009dc2 <_vfprintf_r+0x1516>
80009c58:	f2 e6 00 00 	ld.d	r6,r9[0]
80009c5c:	2f 89       	sub	r9,-8
80009c5e:	fa e7 00 00 	st.d	sp[0],r6
80009c62:	51 09       	stdsp	sp[0x40],r9
80009c64:	14 97       	mov	r7,r10
80009c66:	ca e8       	rjmp	80009dc2 <_vfprintf_r+0x1516>
80009c68:	ed b5 00 04 	bld	r5,0x4
80009c6c:	c1 71       	brne	80009c9a <_vfprintf_r+0x13ee>
80009c6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c72:	40 3e       	lddsp	lr,sp[0xc]
80009c74:	58 0e       	cp.w	lr,0
80009c76:	c0 80       	breq	80009c86 <_vfprintf_r+0x13da>
80009c78:	10 36       	cp.w	r6,r8
80009c7a:	c6 94       	brge	80009d4c <_vfprintf_r+0x14a0>
80009c7c:	fa cc f9 44 	sub	r12,sp,-1724
80009c80:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009c84:	c8 28       	rjmp	80009d88 <_vfprintf_r+0x14dc>
80009c86:	ee ca ff ff 	sub	r10,r7,-1
80009c8a:	10 37       	cp.w	r7,r8
80009c8c:	e0 84 00 81 	brge	80009d8e <_vfprintf_r+0x14e2>
80009c90:	fa cb f9 44 	sub	r11,sp,-1724
80009c94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c98:	c7 78       	rjmp	80009d86 <_vfprintf_r+0x14da>
80009c9a:	ed b5 00 06 	bld	r5,0x6
80009c9e:	c4 b1       	brne	80009d34 <_vfprintf_r+0x1488>
80009ca0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ca4:	40 3c       	lddsp	r12,sp[0xc]
80009ca6:	58 0c       	cp.w	r12,0
80009ca8:	c1 d0       	breq	80009ce2 <_vfprintf_r+0x1436>
80009caa:	10 36       	cp.w	r6,r8
80009cac:	c0 64       	brge	80009cb8 <_vfprintf_r+0x140c>
80009cae:	fa cb f9 44 	sub	r11,sp,-1724
80009cb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cb6:	c1 f8       	rjmp	80009cf4 <_vfprintf_r+0x1448>
80009cb8:	fa c8 f9 50 	sub	r8,sp,-1712
80009cbc:	1a d8       	st.w	--sp,r8
80009cbe:	fa c8 fa b8 	sub	r8,sp,-1352
80009cc2:	1a d8       	st.w	--sp,r8
80009cc4:	fa c8 fb b4 	sub	r8,sp,-1100
80009cc8:	1a d8       	st.w	--sp,r8
80009cca:	fa c8 f9 40 	sub	r8,sp,-1728
80009cce:	fa c9 ff b4 	sub	r9,sp,-76
80009cd2:	04 9a       	mov	r10,r2
80009cd4:	0c 9b       	mov	r11,r6
80009cd6:	08 9c       	mov	r12,r4
80009cd8:	fe b0 f4 52 	rcall	8000857c <get_arg>
80009cdc:	2f dd       	sub	sp,-12
80009cde:	98 18       	ld.sh	r8,r12[0x2]
80009ce0:	c2 78       	rjmp	80009d2e <_vfprintf_r+0x1482>
80009ce2:	ee ca ff ff 	sub	r10,r7,-1
80009ce6:	10 37       	cp.w	r7,r8
80009ce8:	c0 a4       	brge	80009cfc <_vfprintf_r+0x1450>
80009cea:	fa c9 f9 44 	sub	r9,sp,-1724
80009cee:	14 97       	mov	r7,r10
80009cf0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009cf4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009cf8:	c1 b8       	rjmp	80009d2e <_vfprintf_r+0x1482>
80009cfa:	d7 03       	nop
80009cfc:	41 09       	lddsp	r9,sp[0x40]
80009cfe:	59 f8       	cp.w	r8,31
80009d00:	e0 89 00 13 	brgt	80009d26 <_vfprintf_r+0x147a>
80009d04:	f2 cb ff fc 	sub	r11,r9,-4
80009d08:	51 0b       	stdsp	sp[0x40],r11
80009d0a:	72 09       	ld.w	r9,r9[0x0]
80009d0c:	fa c6 f9 44 	sub	r6,sp,-1724
80009d10:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009d14:	2f f8       	sub	r8,-1
80009d16:	f7 49 fd 88 	st.w	r11[-632],r9
80009d1a:	fb 48 06 b4 	st.w	sp[1716],r8
80009d1e:	14 97       	mov	r7,r10
80009d20:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009d24:	c0 58       	rjmp	80009d2e <_vfprintf_r+0x1482>
80009d26:	92 18       	ld.sh	r8,r9[0x2]
80009d28:	14 97       	mov	r7,r10
80009d2a:	2f c9       	sub	r9,-4
80009d2c:	51 09       	stdsp	sp[0x40],r9
80009d2e:	5c 78       	castu.h	r8
80009d30:	50 18       	stdsp	sp[0x4],r8
80009d32:	c4 68       	rjmp	80009dbe <_vfprintf_r+0x1512>
80009d34:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d38:	40 3c       	lddsp	r12,sp[0xc]
80009d3a:	58 0c       	cp.w	r12,0
80009d3c:	c1 d0       	breq	80009d76 <_vfprintf_r+0x14ca>
80009d3e:	10 36       	cp.w	r6,r8
80009d40:	c0 64       	brge	80009d4c <_vfprintf_r+0x14a0>
80009d42:	fa cb f9 44 	sub	r11,sp,-1724
80009d46:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d4a:	c1 f8       	rjmp	80009d88 <_vfprintf_r+0x14dc>
80009d4c:	fa c8 f9 50 	sub	r8,sp,-1712
80009d50:	1a d8       	st.w	--sp,r8
80009d52:	fa c8 fa b8 	sub	r8,sp,-1352
80009d56:	0c 9b       	mov	r11,r6
80009d58:	1a d8       	st.w	--sp,r8
80009d5a:	fa c8 fb b4 	sub	r8,sp,-1100
80009d5e:	04 9a       	mov	r10,r2
80009d60:	1a d8       	st.w	--sp,r8
80009d62:	08 9c       	mov	r12,r4
80009d64:	fa c8 f9 40 	sub	r8,sp,-1728
80009d68:	fa c9 ff b4 	sub	r9,sp,-76
80009d6c:	fe b0 f4 08 	rcall	8000857c <get_arg>
80009d70:	2f dd       	sub	sp,-12
80009d72:	78 0b       	ld.w	r11,r12[0x0]
80009d74:	c2 48       	rjmp	80009dbc <_vfprintf_r+0x1510>
80009d76:	ee ca ff ff 	sub	r10,r7,-1
80009d7a:	10 37       	cp.w	r7,r8
80009d7c:	c0 94       	brge	80009d8e <_vfprintf_r+0x14e2>
80009d7e:	fa c9 f9 44 	sub	r9,sp,-1724
80009d82:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d86:	14 97       	mov	r7,r10
80009d88:	ec fb fd 88 	ld.w	r11,r6[-632]
80009d8c:	c1 88       	rjmp	80009dbc <_vfprintf_r+0x1510>
80009d8e:	41 09       	lddsp	r9,sp[0x40]
80009d90:	59 f8       	cp.w	r8,31
80009d92:	e0 89 00 11 	brgt	80009db4 <_vfprintf_r+0x1508>
80009d96:	f2 cb ff fc 	sub	r11,r9,-4
80009d9a:	51 0b       	stdsp	sp[0x40],r11
80009d9c:	fa c6 f9 44 	sub	r6,sp,-1724
80009da0:	72 0b       	ld.w	r11,r9[0x0]
80009da2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009da6:	f3 4b fd 88 	st.w	r9[-632],r11
80009daa:	2f f8       	sub	r8,-1
80009dac:	14 97       	mov	r7,r10
80009dae:	fb 48 06 b4 	st.w	sp[1716],r8
80009db2:	c0 58       	rjmp	80009dbc <_vfprintf_r+0x1510>
80009db4:	72 0b       	ld.w	r11,r9[0x0]
80009db6:	14 97       	mov	r7,r10
80009db8:	2f c9       	sub	r9,-4
80009dba:	51 09       	stdsp	sp[0x40],r9
80009dbc:	50 1b       	stdsp	sp[0x4],r11
80009dbe:	30 0e       	mov	lr,0
80009dc0:	50 0e       	stdsp	sp[0x0],lr
80009dc2:	40 08       	lddsp	r8,sp[0x0]
80009dc4:	40 1c       	lddsp	r12,sp[0x4]
80009dc6:	18 48       	or	r8,r12
80009dc8:	5f 19       	srne	r9
80009dca:	0a 98       	mov	r8,r5
80009dcc:	eb e9 00 09 	and	r9,r5,r9
80009dd0:	a1 b8       	sbr	r8,0x1
80009dd2:	58 09       	cp.w	r9,0
80009dd4:	c0 70       	breq	80009de2 <_vfprintf_r+0x1536>
80009dd6:	10 95       	mov	r5,r8
80009dd8:	fb 60 06 b9 	st.b	sp[1721],r0
80009ddc:	33 08       	mov	r8,48
80009dde:	fb 68 06 b8 	st.b	sp[1720],r8
80009de2:	30 28       	mov	r8,2
80009de4:	30 09       	mov	r9,0
80009de6:	fb 69 06 bb 	st.b	sp[1723],r9
80009dea:	0a 99       	mov	r9,r5
80009dec:	a7 d9       	cbr	r9,0x7
80009dee:	40 2b       	lddsp	r11,sp[0x8]
80009df0:	40 16       	lddsp	r6,sp[0x4]
80009df2:	58 0b       	cp.w	r11,0
80009df4:	5f 1a       	srne	r10
80009df6:	f2 05 17 40 	movge	r5,r9
80009dfa:	fa c2 f9 78 	sub	r2,sp,-1672
80009dfe:	40 09       	lddsp	r9,sp[0x0]
80009e00:	0c 49       	or	r9,r6
80009e02:	5f 19       	srne	r9
80009e04:	f5 e9 10 09 	or	r9,r10,r9
80009e08:	c5 c0       	breq	80009ec0 <_vfprintf_r+0x1614>
80009e0a:	30 19       	mov	r9,1
80009e0c:	f2 08 18 00 	cp.b	r8,r9
80009e10:	c0 60       	breq	80009e1c <_vfprintf_r+0x1570>
80009e12:	30 29       	mov	r9,2
80009e14:	f2 08 18 00 	cp.b	r8,r9
80009e18:	c0 41       	brne	80009e20 <_vfprintf_r+0x1574>
80009e1a:	c3 c8       	rjmp	80009e92 <_vfprintf_r+0x15e6>
80009e1c:	04 96       	mov	r6,r2
80009e1e:	c3 08       	rjmp	80009e7e <_vfprintf_r+0x15d2>
80009e20:	04 96       	mov	r6,r2
80009e22:	fa e8 00 00 	ld.d	r8,sp[0]
80009e26:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009e2a:	2d 0a       	sub	r10,-48
80009e2c:	0c fa       	st.b	--r6,r10
80009e2e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009e32:	f2 0c 16 03 	lsr	r12,r9,0x3
80009e36:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009e3a:	18 99       	mov	r9,r12
80009e3c:	16 98       	mov	r8,r11
80009e3e:	58 08       	cp.w	r8,0
80009e40:	5c 29       	cpc	r9
80009e42:	cf 21       	brne	80009e26 <_vfprintf_r+0x157a>
80009e44:	fa e9 00 00 	st.d	sp[0],r8
80009e48:	ed b5 00 00 	bld	r5,0x0
80009e4c:	c4 51       	brne	80009ed6 <_vfprintf_r+0x162a>
80009e4e:	33 09       	mov	r9,48
80009e50:	f2 0a 18 00 	cp.b	r10,r9
80009e54:	c4 10       	breq	80009ed6 <_vfprintf_r+0x162a>
80009e56:	0c f9       	st.b	--r6,r9
80009e58:	c3 f8       	rjmp	80009ed6 <_vfprintf_r+0x162a>
80009e5a:	fa ea 00 00 	ld.d	r10,sp[0]
80009e5e:	30 a8       	mov	r8,10
80009e60:	30 09       	mov	r9,0
80009e62:	e0 a0 1a 19 	rcall	8000d294 <__avr32_umod64>
80009e66:	30 a8       	mov	r8,10
80009e68:	2d 0a       	sub	r10,-48
80009e6a:	30 09       	mov	r9,0
80009e6c:	ac 8a       	st.b	r6[0x0],r10
80009e6e:	fa ea 00 00 	ld.d	r10,sp[0]
80009e72:	e0 a0 18 df 	rcall	8000d030 <__avr32_udiv64>
80009e76:	16 99       	mov	r9,r11
80009e78:	14 98       	mov	r8,r10
80009e7a:	fa e9 00 00 	st.d	sp[0],r8
80009e7e:	20 16       	sub	r6,1
80009e80:	fa ea 00 00 	ld.d	r10,sp[0]
80009e84:	58 9a       	cp.w	r10,9
80009e86:	5c 2b       	cpc	r11
80009e88:	fe 9b ff e9 	brhi	80009e5a <_vfprintf_r+0x15ae>
80009e8c:	1b f8       	ld.ub	r8,sp[0x7]
80009e8e:	2d 08       	sub	r8,-48
80009e90:	c2 08       	rjmp	80009ed0 <_vfprintf_r+0x1624>
80009e92:	04 96       	mov	r6,r2
80009e94:	fa e8 00 00 	ld.d	r8,sp[0]
80009e98:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009e9c:	40 de       	lddsp	lr,sp[0x34]
80009e9e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009ea2:	0c fa       	st.b	--r6,r10
80009ea4:	f2 0b 16 04 	lsr	r11,r9,0x4
80009ea8:	f0 0a 16 04 	lsr	r10,r8,0x4
80009eac:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009eb0:	16 99       	mov	r9,r11
80009eb2:	14 98       	mov	r8,r10
80009eb4:	58 08       	cp.w	r8,0
80009eb6:	5c 29       	cpc	r9
80009eb8:	cf 01       	brne	80009e98 <_vfprintf_r+0x15ec>
80009eba:	fa e9 00 00 	st.d	sp[0],r8
80009ebe:	c0 c8       	rjmp	80009ed6 <_vfprintf_r+0x162a>
80009ec0:	58 08       	cp.w	r8,0
80009ec2:	c0 91       	brne	80009ed4 <_vfprintf_r+0x1628>
80009ec4:	ed b5 00 00 	bld	r5,0x0
80009ec8:	c0 61       	brne	80009ed4 <_vfprintf_r+0x1628>
80009eca:	fa c6 f9 79 	sub	r6,sp,-1671
80009ece:	33 08       	mov	r8,48
80009ed0:	ac 88       	st.b	r6[0x0],r8
80009ed2:	c0 28       	rjmp	80009ed6 <_vfprintf_r+0x162a>
80009ed4:	04 96       	mov	r6,r2
80009ed6:	0c 12       	sub	r2,r6
80009ed8:	c1 c8       	rjmp	80009f10 <_vfprintf_r+0x1664>
80009eda:	50 a7       	stdsp	sp[0x28],r7
80009edc:	50 80       	stdsp	sp[0x20],r0
80009ede:	40 93       	lddsp	r3,sp[0x24]
80009ee0:	0c 97       	mov	r7,r6
80009ee2:	10 90       	mov	r0,r8
80009ee4:	04 94       	mov	r4,r2
80009ee6:	40 41       	lddsp	r1,sp[0x10]
80009ee8:	58 08       	cp.w	r8,0
80009eea:	e0 80 04 4f 	breq	8000a788 <_vfprintf_r+0x1edc>
80009eee:	fb 68 06 60 	st.b	sp[1632],r8
80009ef2:	30 0c       	mov	r12,0
80009ef4:	30 08       	mov	r8,0
80009ef6:	30 12       	mov	r2,1
80009ef8:	fb 68 06 bb 	st.b	sp[1723],r8
80009efc:	50 2c       	stdsp	sp[0x8],r12
80009efe:	fa c6 f9 a0 	sub	r6,sp,-1632
80009f02:	c0 78       	rjmp	80009f10 <_vfprintf_r+0x1664>
80009f04:	30 0b       	mov	r11,0
80009f06:	50 2b       	stdsp	sp[0x8],r11
80009f08:	c0 48       	rjmp	80009f10 <_vfprintf_r+0x1664>
80009f0a:	40 22       	lddsp	r2,sp[0x8]
80009f0c:	30 0a       	mov	r10,0
80009f0e:	50 2a       	stdsp	sp[0x8],r10
80009f10:	40 29       	lddsp	r9,sp[0x8]
80009f12:	e4 09 0c 49 	max	r9,r2,r9
80009f16:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009f1a:	50 39       	stdsp	sp[0xc],r9
80009f1c:	0a 9e       	mov	lr,r5
80009f1e:	30 09       	mov	r9,0
80009f20:	e2 1e 00 02 	andl	lr,0x2,COH
80009f24:	f2 08 18 00 	cp.b	r8,r9
80009f28:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009f2c:	f7 b8 01 ff 	subne	r8,-1
80009f30:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009f34:	0a 9b       	mov	r11,r5
80009f36:	58 0e       	cp.w	lr,0
80009f38:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009f3c:	f7 bc 01 fe 	subne	r12,-2
80009f40:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009f44:	e2 1b 00 84 	andl	r11,0x84,COH
80009f48:	50 fe       	stdsp	sp[0x3c],lr
80009f4a:	50 9b       	stdsp	sp[0x24],r11
80009f4c:	c4 71       	brne	80009fda <_vfprintf_r+0x172e>
80009f4e:	40 8a       	lddsp	r10,sp[0x20]
80009f50:	40 39       	lddsp	r9,sp[0xc]
80009f52:	12 1a       	sub	r10,r9
80009f54:	50 4a       	stdsp	sp[0x10],r10
80009f56:	58 0a       	cp.w	r10,0
80009f58:	e0 89 00 20 	brgt	80009f98 <_vfprintf_r+0x16ec>
80009f5c:	c3 f8       	rjmp	80009fda <_vfprintf_r+0x172e>
80009f5e:	2f 09       	sub	r9,-16
80009f60:	2f f8       	sub	r8,-1
80009f62:	fe ce b6 e2 	sub	lr,pc,-18718
80009f66:	31 0c       	mov	r12,16
80009f68:	fb 49 06 90 	st.w	sp[1680],r9
80009f6c:	87 0e       	st.w	r3[0x0],lr
80009f6e:	87 1c       	st.w	r3[0x4],r12
80009f70:	fb 48 06 8c 	st.w	sp[1676],r8
80009f74:	58 78       	cp.w	r8,7
80009f76:	e0 89 00 04 	brgt	80009f7e <_vfprintf_r+0x16d2>
80009f7a:	2f 83       	sub	r3,-8
80009f7c:	c0 b8       	rjmp	80009f92 <_vfprintf_r+0x16e6>
80009f7e:	fa ca f9 78 	sub	r10,sp,-1672
80009f82:	02 9b       	mov	r11,r1
80009f84:	08 9c       	mov	r12,r4
80009f86:	fe b0 f4 85 	rcall	80008890 <__sprint_r>
80009f8a:	e0 81 04 10 	brne	8000a7aa <_vfprintf_r+0x1efe>
80009f8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f92:	40 4b       	lddsp	r11,sp[0x10]
80009f94:	21 0b       	sub	r11,16
80009f96:	50 4b       	stdsp	sp[0x10],r11
80009f98:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fa0:	fe ca b7 20 	sub	r10,pc,-18656
80009fa4:	40 4e       	lddsp	lr,sp[0x10]
80009fa6:	59 0e       	cp.w	lr,16
80009fa8:	fe 99 ff db 	brgt	80009f5e <_vfprintf_r+0x16b2>
80009fac:	1c 09       	add	r9,lr
80009fae:	2f f8       	sub	r8,-1
80009fb0:	87 0a       	st.w	r3[0x0],r10
80009fb2:	fb 49 06 90 	st.w	sp[1680],r9
80009fb6:	87 1e       	st.w	r3[0x4],lr
80009fb8:	fb 48 06 8c 	st.w	sp[1676],r8
80009fbc:	58 78       	cp.w	r8,7
80009fbe:	e0 89 00 04 	brgt	80009fc6 <_vfprintf_r+0x171a>
80009fc2:	2f 83       	sub	r3,-8
80009fc4:	c0 b8       	rjmp	80009fda <_vfprintf_r+0x172e>
80009fc6:	fa ca f9 78 	sub	r10,sp,-1672
80009fca:	02 9b       	mov	r11,r1
80009fcc:	08 9c       	mov	r12,r4
80009fce:	fe b0 f4 61 	rcall	80008890 <__sprint_r>
80009fd2:	e0 81 03 ec 	brne	8000a7aa <_vfprintf_r+0x1efe>
80009fd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fda:	30 09       	mov	r9,0
80009fdc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009fe0:	f2 08 18 00 	cp.b	r8,r9
80009fe4:	c1 f0       	breq	8000a022 <_vfprintf_r+0x1776>
80009fe6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fea:	fa c9 f9 45 	sub	r9,sp,-1723
80009fee:	2f f8       	sub	r8,-1
80009ff0:	87 09       	st.w	r3[0x0],r9
80009ff2:	fb 48 06 90 	st.w	sp[1680],r8
80009ff6:	30 19       	mov	r9,1
80009ff8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ffc:	87 19       	st.w	r3[0x4],r9
80009ffe:	2f f8       	sub	r8,-1
8000a000:	fb 48 06 8c 	st.w	sp[1676],r8
8000a004:	58 78       	cp.w	r8,7
8000a006:	e0 89 00 04 	brgt	8000a00e <_vfprintf_r+0x1762>
8000a00a:	2f 83       	sub	r3,-8
8000a00c:	c0 b8       	rjmp	8000a022 <_vfprintf_r+0x1776>
8000a00e:	fa ca f9 78 	sub	r10,sp,-1672
8000a012:	02 9b       	mov	r11,r1
8000a014:	08 9c       	mov	r12,r4
8000a016:	fe b0 f4 3d 	rcall	80008890 <__sprint_r>
8000a01a:	e0 81 03 c8 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a01e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a022:	40 fc       	lddsp	r12,sp[0x3c]
8000a024:	58 0c       	cp.w	r12,0
8000a026:	c1 f0       	breq	8000a064 <_vfprintf_r+0x17b8>
8000a028:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a02c:	fa c9 f9 48 	sub	r9,sp,-1720
8000a030:	2f e8       	sub	r8,-2
8000a032:	87 09       	st.w	r3[0x0],r9
8000a034:	fb 48 06 90 	st.w	sp[1680],r8
8000a038:	30 29       	mov	r9,2
8000a03a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a03e:	87 19       	st.w	r3[0x4],r9
8000a040:	2f f8       	sub	r8,-1
8000a042:	fb 48 06 8c 	st.w	sp[1676],r8
8000a046:	58 78       	cp.w	r8,7
8000a048:	e0 89 00 04 	brgt	8000a050 <_vfprintf_r+0x17a4>
8000a04c:	2f 83       	sub	r3,-8
8000a04e:	c0 b8       	rjmp	8000a064 <_vfprintf_r+0x17b8>
8000a050:	fa ca f9 78 	sub	r10,sp,-1672
8000a054:	02 9b       	mov	r11,r1
8000a056:	08 9c       	mov	r12,r4
8000a058:	fe b0 f4 1c 	rcall	80008890 <__sprint_r>
8000a05c:	e0 81 03 a7 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a060:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a064:	40 9b       	lddsp	r11,sp[0x24]
8000a066:	e0 4b 00 80 	cp.w	r11,128
8000a06a:	c4 71       	brne	8000a0f8 <_vfprintf_r+0x184c>
8000a06c:	40 8a       	lddsp	r10,sp[0x20]
8000a06e:	40 39       	lddsp	r9,sp[0xc]
8000a070:	12 1a       	sub	r10,r9
8000a072:	50 4a       	stdsp	sp[0x10],r10
8000a074:	58 0a       	cp.w	r10,0
8000a076:	e0 89 00 20 	brgt	8000a0b6 <_vfprintf_r+0x180a>
8000a07a:	c3 f8       	rjmp	8000a0f8 <_vfprintf_r+0x184c>
8000a07c:	2f 09       	sub	r9,-16
8000a07e:	2f f8       	sub	r8,-1
8000a080:	fe ce b7 f0 	sub	lr,pc,-18448
8000a084:	31 0c       	mov	r12,16
8000a086:	fb 49 06 90 	st.w	sp[1680],r9
8000a08a:	87 0e       	st.w	r3[0x0],lr
8000a08c:	87 1c       	st.w	r3[0x4],r12
8000a08e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a092:	58 78       	cp.w	r8,7
8000a094:	e0 89 00 04 	brgt	8000a09c <_vfprintf_r+0x17f0>
8000a098:	2f 83       	sub	r3,-8
8000a09a:	c0 b8       	rjmp	8000a0b0 <_vfprintf_r+0x1804>
8000a09c:	fa ca f9 78 	sub	r10,sp,-1672
8000a0a0:	02 9b       	mov	r11,r1
8000a0a2:	08 9c       	mov	r12,r4
8000a0a4:	fe b0 f3 f6 	rcall	80008890 <__sprint_r>
8000a0a8:	e0 81 03 81 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a0ac:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0b0:	40 4b       	lddsp	r11,sp[0x10]
8000a0b2:	21 0b       	sub	r11,16
8000a0b4:	50 4b       	stdsp	sp[0x10],r11
8000a0b6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a0ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0be:	fe ca b8 2e 	sub	r10,pc,-18386
8000a0c2:	40 4e       	lddsp	lr,sp[0x10]
8000a0c4:	59 0e       	cp.w	lr,16
8000a0c6:	fe 99 ff db 	brgt	8000a07c <_vfprintf_r+0x17d0>
8000a0ca:	1c 09       	add	r9,lr
8000a0cc:	2f f8       	sub	r8,-1
8000a0ce:	87 0a       	st.w	r3[0x0],r10
8000a0d0:	fb 49 06 90 	st.w	sp[1680],r9
8000a0d4:	87 1e       	st.w	r3[0x4],lr
8000a0d6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0da:	58 78       	cp.w	r8,7
8000a0dc:	e0 89 00 04 	brgt	8000a0e4 <_vfprintf_r+0x1838>
8000a0e0:	2f 83       	sub	r3,-8
8000a0e2:	c0 b8       	rjmp	8000a0f8 <_vfprintf_r+0x184c>
8000a0e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a0e8:	02 9b       	mov	r11,r1
8000a0ea:	08 9c       	mov	r12,r4
8000a0ec:	fe b0 f3 d2 	rcall	80008890 <__sprint_r>
8000a0f0:	e0 81 03 5d 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a0f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0f8:	40 2c       	lddsp	r12,sp[0x8]
8000a0fa:	04 1c       	sub	r12,r2
8000a0fc:	50 2c       	stdsp	sp[0x8],r12
8000a0fe:	58 0c       	cp.w	r12,0
8000a100:	e0 89 00 20 	brgt	8000a140 <_vfprintf_r+0x1894>
8000a104:	c3 f8       	rjmp	8000a182 <_vfprintf_r+0x18d6>
8000a106:	2f 09       	sub	r9,-16
8000a108:	2f f8       	sub	r8,-1
8000a10a:	fe cb b8 7a 	sub	r11,pc,-18310
8000a10e:	31 0a       	mov	r10,16
8000a110:	fb 49 06 90 	st.w	sp[1680],r9
8000a114:	87 0b       	st.w	r3[0x0],r11
8000a116:	87 1a       	st.w	r3[0x4],r10
8000a118:	fb 48 06 8c 	st.w	sp[1676],r8
8000a11c:	58 78       	cp.w	r8,7
8000a11e:	e0 89 00 04 	brgt	8000a126 <_vfprintf_r+0x187a>
8000a122:	2f 83       	sub	r3,-8
8000a124:	c0 b8       	rjmp	8000a13a <_vfprintf_r+0x188e>
8000a126:	fa ca f9 78 	sub	r10,sp,-1672
8000a12a:	02 9b       	mov	r11,r1
8000a12c:	08 9c       	mov	r12,r4
8000a12e:	fe b0 f3 b1 	rcall	80008890 <__sprint_r>
8000a132:	e0 81 03 3c 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a136:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a13a:	40 29       	lddsp	r9,sp[0x8]
8000a13c:	21 09       	sub	r9,16
8000a13e:	50 29       	stdsp	sp[0x8],r9
8000a140:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a144:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a148:	fe ca b8 b8 	sub	r10,pc,-18248
8000a14c:	40 2e       	lddsp	lr,sp[0x8]
8000a14e:	59 0e       	cp.w	lr,16
8000a150:	fe 99 ff db 	brgt	8000a106 <_vfprintf_r+0x185a>
8000a154:	1c 09       	add	r9,lr
8000a156:	2f f8       	sub	r8,-1
8000a158:	87 0a       	st.w	r3[0x0],r10
8000a15a:	fb 49 06 90 	st.w	sp[1680],r9
8000a15e:	87 1e       	st.w	r3[0x4],lr
8000a160:	fb 48 06 8c 	st.w	sp[1676],r8
8000a164:	58 78       	cp.w	r8,7
8000a166:	e0 89 00 04 	brgt	8000a16e <_vfprintf_r+0x18c2>
8000a16a:	2f 83       	sub	r3,-8
8000a16c:	c0 b8       	rjmp	8000a182 <_vfprintf_r+0x18d6>
8000a16e:	fa ca f9 78 	sub	r10,sp,-1672
8000a172:	02 9b       	mov	r11,r1
8000a174:	08 9c       	mov	r12,r4
8000a176:	fe b0 f3 8d 	rcall	80008890 <__sprint_r>
8000a17a:	e0 81 03 18 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a17e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a182:	ed b5 00 08 	bld	r5,0x8
8000a186:	c0 b0       	breq	8000a19c <_vfprintf_r+0x18f0>
8000a188:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a18c:	87 12       	st.w	r3[0x4],r2
8000a18e:	87 06       	st.w	r3[0x0],r6
8000a190:	f0 02 00 02 	add	r2,r8,r2
8000a194:	fb 42 06 90 	st.w	sp[1680],r2
8000a198:	e0 8f 01 d4 	bral	8000a540 <_vfprintf_r+0x1c94>
8000a19c:	e0 40 00 65 	cp.w	r0,101
8000a1a0:	e0 8a 01 d6 	brle	8000a54c <_vfprintf_r+0x1ca0>
8000a1a4:	30 08       	mov	r8,0
8000a1a6:	30 09       	mov	r9,0
8000a1a8:	40 5b       	lddsp	r11,sp[0x14]
8000a1aa:	40 7a       	lddsp	r10,sp[0x1c]
8000a1ac:	e0 a0 15 3b 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000a1b0:	c7 90       	breq	8000a2a2 <_vfprintf_r+0x19f6>
8000a1b2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a1b6:	fe c9 b9 3a 	sub	r9,pc,-18118
8000a1ba:	2f f8       	sub	r8,-1
8000a1bc:	87 09       	st.w	r3[0x0],r9
8000a1be:	fb 48 06 90 	st.w	sp[1680],r8
8000a1c2:	30 19       	mov	r9,1
8000a1c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1c8:	87 19       	st.w	r3[0x4],r9
8000a1ca:	2f f8       	sub	r8,-1
8000a1cc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1d0:	58 78       	cp.w	r8,7
8000a1d2:	e0 89 00 05 	brgt	8000a1dc <_vfprintf_r+0x1930>
8000a1d6:	2f 83       	sub	r3,-8
8000a1d8:	c0 c8       	rjmp	8000a1f0 <_vfprintf_r+0x1944>
8000a1da:	d7 03       	nop
8000a1dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a1e0:	02 9b       	mov	r11,r1
8000a1e2:	08 9c       	mov	r12,r4
8000a1e4:	fe b0 f3 56 	rcall	80008890 <__sprint_r>
8000a1e8:	e0 81 02 e1 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a1ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1f0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a1f4:	40 6c       	lddsp	r12,sp[0x18]
8000a1f6:	18 38       	cp.w	r8,r12
8000a1f8:	c0 55       	brlt	8000a202 <_vfprintf_r+0x1956>
8000a1fa:	ed b5 00 00 	bld	r5,0x0
8000a1fe:	e0 81 02 6b 	brne	8000a6d4 <_vfprintf_r+0x1e28>
8000a202:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a206:	2f f8       	sub	r8,-1
8000a208:	40 cb       	lddsp	r11,sp[0x30]
8000a20a:	fb 48 06 90 	st.w	sp[1680],r8
8000a20e:	30 19       	mov	r9,1
8000a210:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a214:	87 0b       	st.w	r3[0x0],r11
8000a216:	2f f8       	sub	r8,-1
8000a218:	87 19       	st.w	r3[0x4],r9
8000a21a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a21e:	58 78       	cp.w	r8,7
8000a220:	e0 89 00 04 	brgt	8000a228 <_vfprintf_r+0x197c>
8000a224:	2f 83       	sub	r3,-8
8000a226:	c0 b8       	rjmp	8000a23c <_vfprintf_r+0x1990>
8000a228:	fa ca f9 78 	sub	r10,sp,-1672
8000a22c:	02 9b       	mov	r11,r1
8000a22e:	08 9c       	mov	r12,r4
8000a230:	fe b0 f3 30 	rcall	80008890 <__sprint_r>
8000a234:	e0 81 02 bb 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a238:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a23c:	40 66       	lddsp	r6,sp[0x18]
8000a23e:	20 16       	sub	r6,1
8000a240:	58 06       	cp.w	r6,0
8000a242:	e0 89 00 1d 	brgt	8000a27c <_vfprintf_r+0x19d0>
8000a246:	e0 8f 02 47 	bral	8000a6d4 <_vfprintf_r+0x1e28>
8000a24a:	2f 09       	sub	r9,-16
8000a24c:	2f f8       	sub	r8,-1
8000a24e:	fb 49 06 90 	st.w	sp[1680],r9
8000a252:	87 02       	st.w	r3[0x0],r2
8000a254:	87 10       	st.w	r3[0x4],r0
8000a256:	fb 48 06 8c 	st.w	sp[1676],r8
8000a25a:	58 78       	cp.w	r8,7
8000a25c:	e0 89 00 04 	brgt	8000a264 <_vfprintf_r+0x19b8>
8000a260:	2f 83       	sub	r3,-8
8000a262:	c0 b8       	rjmp	8000a278 <_vfprintf_r+0x19cc>
8000a264:	fa ca f9 78 	sub	r10,sp,-1672
8000a268:	02 9b       	mov	r11,r1
8000a26a:	08 9c       	mov	r12,r4
8000a26c:	fe b0 f3 12 	rcall	80008890 <__sprint_r>
8000a270:	e0 81 02 9d 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a274:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a278:	21 06       	sub	r6,16
8000a27a:	c0 48       	rjmp	8000a282 <_vfprintf_r+0x19d6>
8000a27c:	fe c2 b9 ec 	sub	r2,pc,-17940
8000a280:	31 00       	mov	r0,16
8000a282:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a286:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a28a:	fe ca b9 fa 	sub	r10,pc,-17926
8000a28e:	59 06       	cp.w	r6,16
8000a290:	fe 99 ff dd 	brgt	8000a24a <_vfprintf_r+0x199e>
8000a294:	0c 09       	add	r9,r6
8000a296:	87 0a       	st.w	r3[0x0],r10
8000a298:	fb 49 06 90 	st.w	sp[1680],r9
8000a29c:	2f f8       	sub	r8,-1
8000a29e:	87 16       	st.w	r3[0x4],r6
8000a2a0:	c5 39       	rjmp	8000a546 <_vfprintf_r+0x1c9a>
8000a2a2:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a2a6:	58 0a       	cp.w	r10,0
8000a2a8:	e0 89 00 92 	brgt	8000a3cc <_vfprintf_r+0x1b20>
8000a2ac:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2b0:	fe c9 ba 34 	sub	r9,pc,-17868
8000a2b4:	2f f8       	sub	r8,-1
8000a2b6:	87 09       	st.w	r3[0x0],r9
8000a2b8:	fb 48 06 90 	st.w	sp[1680],r8
8000a2bc:	30 19       	mov	r9,1
8000a2be:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a2c2:	87 19       	st.w	r3[0x4],r9
8000a2c4:	2f f8       	sub	r8,-1
8000a2c6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2ca:	58 78       	cp.w	r8,7
8000a2cc:	e0 89 00 04 	brgt	8000a2d4 <_vfprintf_r+0x1a28>
8000a2d0:	2f 83       	sub	r3,-8
8000a2d2:	c0 b8       	rjmp	8000a2e8 <_vfprintf_r+0x1a3c>
8000a2d4:	fa ca f9 78 	sub	r10,sp,-1672
8000a2d8:	02 9b       	mov	r11,r1
8000a2da:	08 9c       	mov	r12,r4
8000a2dc:	fe b0 f2 da 	rcall	80008890 <__sprint_r>
8000a2e0:	e0 81 02 65 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a2e4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2e8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a2ec:	58 08       	cp.w	r8,0
8000a2ee:	c0 81       	brne	8000a2fe <_vfprintf_r+0x1a52>
8000a2f0:	40 6a       	lddsp	r10,sp[0x18]
8000a2f2:	58 0a       	cp.w	r10,0
8000a2f4:	c0 51       	brne	8000a2fe <_vfprintf_r+0x1a52>
8000a2f6:	ed b5 00 00 	bld	r5,0x0
8000a2fa:	e0 81 01 ed 	brne	8000a6d4 <_vfprintf_r+0x1e28>
8000a2fe:	40 c9       	lddsp	r9,sp[0x30]
8000a300:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a304:	2f f8       	sub	r8,-1
8000a306:	87 09       	st.w	r3[0x0],r9
8000a308:	fb 48 06 90 	st.w	sp[1680],r8
8000a30c:	30 19       	mov	r9,1
8000a30e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a312:	87 19       	st.w	r3[0x4],r9
8000a314:	2f f8       	sub	r8,-1
8000a316:	fb 48 06 8c 	st.w	sp[1676],r8
8000a31a:	58 78       	cp.w	r8,7
8000a31c:	e0 89 00 04 	brgt	8000a324 <_vfprintf_r+0x1a78>
8000a320:	2f 83       	sub	r3,-8
8000a322:	c0 b8       	rjmp	8000a338 <_vfprintf_r+0x1a8c>
8000a324:	fa ca f9 78 	sub	r10,sp,-1672
8000a328:	02 9b       	mov	r11,r1
8000a32a:	08 9c       	mov	r12,r4
8000a32c:	fe b0 f2 b2 	rcall	80008890 <__sprint_r>
8000a330:	e0 81 02 3d 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a334:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a338:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a33c:	5c 32       	neg	r2
8000a33e:	58 02       	cp.w	r2,0
8000a340:	e0 89 00 1d 	brgt	8000a37a <_vfprintf_r+0x1ace>
8000a344:	c3 d8       	rjmp	8000a3be <_vfprintf_r+0x1b12>
8000a346:	2f 09       	sub	r9,-16
8000a348:	2f f8       	sub	r8,-1
8000a34a:	31 0e       	mov	lr,16
8000a34c:	fb 49 06 90 	st.w	sp[1680],r9
8000a350:	87 00       	st.w	r3[0x0],r0
8000a352:	87 1e       	st.w	r3[0x4],lr
8000a354:	fb 48 06 8c 	st.w	sp[1676],r8
8000a358:	58 78       	cp.w	r8,7
8000a35a:	e0 89 00 04 	brgt	8000a362 <_vfprintf_r+0x1ab6>
8000a35e:	2f 83       	sub	r3,-8
8000a360:	c0 b8       	rjmp	8000a376 <_vfprintf_r+0x1aca>
8000a362:	fa ca f9 78 	sub	r10,sp,-1672
8000a366:	02 9b       	mov	r11,r1
8000a368:	08 9c       	mov	r12,r4
8000a36a:	fe b0 f2 93 	rcall	80008890 <__sprint_r>
8000a36e:	e0 81 02 1e 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a372:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a376:	21 02       	sub	r2,16
8000a378:	c0 38       	rjmp	8000a37e <_vfprintf_r+0x1ad2>
8000a37a:	fe c0 ba ea 	sub	r0,pc,-17686
8000a37e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a382:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a386:	fe ca ba f6 	sub	r10,pc,-17674
8000a38a:	59 02       	cp.w	r2,16
8000a38c:	fe 99 ff dd 	brgt	8000a346 <_vfprintf_r+0x1a9a>
8000a390:	04 09       	add	r9,r2
8000a392:	2f f8       	sub	r8,-1
8000a394:	87 0a       	st.w	r3[0x0],r10
8000a396:	fb 49 06 90 	st.w	sp[1680],r9
8000a39a:	87 12       	st.w	r3[0x4],r2
8000a39c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3a0:	58 78       	cp.w	r8,7
8000a3a2:	e0 89 00 04 	brgt	8000a3aa <_vfprintf_r+0x1afe>
8000a3a6:	2f 83       	sub	r3,-8
8000a3a8:	c0 b8       	rjmp	8000a3be <_vfprintf_r+0x1b12>
8000a3aa:	fa ca f9 78 	sub	r10,sp,-1672
8000a3ae:	02 9b       	mov	r11,r1
8000a3b0:	08 9c       	mov	r12,r4
8000a3b2:	fe b0 f2 6f 	rcall	80008890 <__sprint_r>
8000a3b6:	e0 81 01 fa 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a3ba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3be:	40 6c       	lddsp	r12,sp[0x18]
8000a3c0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3c4:	87 06       	st.w	r3[0x0],r6
8000a3c6:	87 1c       	st.w	r3[0x4],r12
8000a3c8:	18 08       	add	r8,r12
8000a3ca:	cb 98       	rjmp	8000a53c <_vfprintf_r+0x1c90>
8000a3cc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a3d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3d4:	40 6b       	lddsp	r11,sp[0x18]
8000a3d6:	16 3a       	cp.w	r10,r11
8000a3d8:	c6 f5       	brlt	8000a4b6 <_vfprintf_r+0x1c0a>
8000a3da:	16 09       	add	r9,r11
8000a3dc:	2f f8       	sub	r8,-1
8000a3de:	87 06       	st.w	r3[0x0],r6
8000a3e0:	fb 49 06 90 	st.w	sp[1680],r9
8000a3e4:	87 1b       	st.w	r3[0x4],r11
8000a3e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3ea:	58 78       	cp.w	r8,7
8000a3ec:	e0 89 00 04 	brgt	8000a3f4 <_vfprintf_r+0x1b48>
8000a3f0:	2f 83       	sub	r3,-8
8000a3f2:	c0 b8       	rjmp	8000a408 <_vfprintf_r+0x1b5c>
8000a3f4:	fa ca f9 78 	sub	r10,sp,-1672
8000a3f8:	02 9b       	mov	r11,r1
8000a3fa:	08 9c       	mov	r12,r4
8000a3fc:	fe b0 f2 4a 	rcall	80008890 <__sprint_r>
8000a400:	e0 81 01 d5 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a404:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a408:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a40c:	40 6a       	lddsp	r10,sp[0x18]
8000a40e:	14 16       	sub	r6,r10
8000a410:	58 06       	cp.w	r6,0
8000a412:	e0 89 00 1c 	brgt	8000a44a <_vfprintf_r+0x1b9e>
8000a416:	c3 d8       	rjmp	8000a490 <_vfprintf_r+0x1be4>
8000a418:	2f 09       	sub	r9,-16
8000a41a:	2f f8       	sub	r8,-1
8000a41c:	fb 49 06 90 	st.w	sp[1680],r9
8000a420:	87 02       	st.w	r3[0x0],r2
8000a422:	87 10       	st.w	r3[0x4],r0
8000a424:	fb 48 06 8c 	st.w	sp[1676],r8
8000a428:	58 78       	cp.w	r8,7
8000a42a:	e0 89 00 04 	brgt	8000a432 <_vfprintf_r+0x1b86>
8000a42e:	2f 83       	sub	r3,-8
8000a430:	c0 b8       	rjmp	8000a446 <_vfprintf_r+0x1b9a>
8000a432:	fa ca f9 78 	sub	r10,sp,-1672
8000a436:	02 9b       	mov	r11,r1
8000a438:	08 9c       	mov	r12,r4
8000a43a:	fe b0 f2 2b 	rcall	80008890 <__sprint_r>
8000a43e:	e0 81 01 b6 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a442:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a446:	21 06       	sub	r6,16
8000a448:	c0 48       	rjmp	8000a450 <_vfprintf_r+0x1ba4>
8000a44a:	fe c2 bb ba 	sub	r2,pc,-17478
8000a44e:	31 00       	mov	r0,16
8000a450:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a454:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a458:	fe ca bb c8 	sub	r10,pc,-17464
8000a45c:	59 06       	cp.w	r6,16
8000a45e:	fe 99 ff dd 	brgt	8000a418 <_vfprintf_r+0x1b6c>
8000a462:	0c 09       	add	r9,r6
8000a464:	2f f8       	sub	r8,-1
8000a466:	87 0a       	st.w	r3[0x0],r10
8000a468:	fb 49 06 90 	st.w	sp[1680],r9
8000a46c:	87 16       	st.w	r3[0x4],r6
8000a46e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a472:	58 78       	cp.w	r8,7
8000a474:	e0 89 00 04 	brgt	8000a47c <_vfprintf_r+0x1bd0>
8000a478:	2f 83       	sub	r3,-8
8000a47a:	c0 b8       	rjmp	8000a490 <_vfprintf_r+0x1be4>
8000a47c:	fa ca f9 78 	sub	r10,sp,-1672
8000a480:	02 9b       	mov	r11,r1
8000a482:	08 9c       	mov	r12,r4
8000a484:	fe b0 f2 06 	rcall	80008890 <__sprint_r>
8000a488:	e0 81 01 91 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a48c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a490:	ed b5 00 00 	bld	r5,0x0
8000a494:	e0 81 01 20 	brne	8000a6d4 <_vfprintf_r+0x1e28>
8000a498:	40 c9       	lddsp	r9,sp[0x30]
8000a49a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a49e:	2f f8       	sub	r8,-1
8000a4a0:	87 09       	st.w	r3[0x0],r9
8000a4a2:	fb 48 06 90 	st.w	sp[1680],r8
8000a4a6:	30 19       	mov	r9,1
8000a4a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4ac:	87 19       	st.w	r3[0x4],r9
8000a4ae:	2f f8       	sub	r8,-1
8000a4b0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4b4:	c0 29       	rjmp	8000a6b8 <_vfprintf_r+0x1e0c>
8000a4b6:	14 09       	add	r9,r10
8000a4b8:	2f f8       	sub	r8,-1
8000a4ba:	fb 49 06 90 	st.w	sp[1680],r9
8000a4be:	87 06       	st.w	r3[0x0],r6
8000a4c0:	87 1a       	st.w	r3[0x4],r10
8000a4c2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4c6:	58 78       	cp.w	r8,7
8000a4c8:	e0 89 00 04 	brgt	8000a4d0 <_vfprintf_r+0x1c24>
8000a4cc:	2f 83       	sub	r3,-8
8000a4ce:	c0 b8       	rjmp	8000a4e4 <_vfprintf_r+0x1c38>
8000a4d0:	fa ca f9 78 	sub	r10,sp,-1672
8000a4d4:	02 9b       	mov	r11,r1
8000a4d6:	08 9c       	mov	r12,r4
8000a4d8:	fe b0 f1 dc 	rcall	80008890 <__sprint_r>
8000a4dc:	e0 81 01 67 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a4e0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4e4:	40 c8       	lddsp	r8,sp[0x30]
8000a4e6:	87 08       	st.w	r3[0x0],r8
8000a4e8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a4ec:	2f f8       	sub	r8,-1
8000a4ee:	30 19       	mov	r9,1
8000a4f0:	fb 48 06 90 	st.w	sp[1680],r8
8000a4f4:	87 19       	st.w	r3[0x4],r9
8000a4f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4fa:	2f f8       	sub	r8,-1
8000a4fc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a500:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a504:	58 78       	cp.w	r8,7
8000a506:	e0 89 00 04 	brgt	8000a50e <_vfprintf_r+0x1c62>
8000a50a:	2f 83       	sub	r3,-8
8000a50c:	c0 b8       	rjmp	8000a522 <_vfprintf_r+0x1c76>
8000a50e:	fa ca f9 78 	sub	r10,sp,-1672
8000a512:	02 9b       	mov	r11,r1
8000a514:	08 9c       	mov	r12,r4
8000a516:	fe b0 f1 bd 	rcall	80008890 <__sprint_r>
8000a51a:	e0 81 01 48 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a51e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a522:	04 06       	add	r6,r2
8000a524:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a528:	87 06       	st.w	r3[0x0],r6
8000a52a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a52e:	40 66       	lddsp	r6,sp[0x18]
8000a530:	40 6e       	lddsp	lr,sp[0x18]
8000a532:	10 16       	sub	r6,r8
8000a534:	f2 08 01 08 	sub	r8,r9,r8
8000a538:	87 16       	st.w	r3[0x4],r6
8000a53a:	1c 08       	add	r8,lr
8000a53c:	fb 48 06 90 	st.w	sp[1680],r8
8000a540:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a544:	2f f8       	sub	r8,-1
8000a546:	fb 48 06 8c 	st.w	sp[1676],r8
8000a54a:	cb 78       	rjmp	8000a6b8 <_vfprintf_r+0x1e0c>
8000a54c:	40 6c       	lddsp	r12,sp[0x18]
8000a54e:	58 1c       	cp.w	r12,1
8000a550:	e0 89 00 06 	brgt	8000a55c <_vfprintf_r+0x1cb0>
8000a554:	ed b5 00 00 	bld	r5,0x0
8000a558:	e0 81 00 85 	brne	8000a662 <_vfprintf_r+0x1db6>
8000a55c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a560:	2f f8       	sub	r8,-1
8000a562:	30 19       	mov	r9,1
8000a564:	fb 48 06 90 	st.w	sp[1680],r8
8000a568:	87 06       	st.w	r3[0x0],r6
8000a56a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a56e:	87 19       	st.w	r3[0x4],r9
8000a570:	2f f8       	sub	r8,-1
8000a572:	fb 48 06 8c 	st.w	sp[1676],r8
8000a576:	58 78       	cp.w	r8,7
8000a578:	e0 89 00 04 	brgt	8000a580 <_vfprintf_r+0x1cd4>
8000a57c:	2f 83       	sub	r3,-8
8000a57e:	c0 b8       	rjmp	8000a594 <_vfprintf_r+0x1ce8>
8000a580:	fa ca f9 78 	sub	r10,sp,-1672
8000a584:	02 9b       	mov	r11,r1
8000a586:	08 9c       	mov	r12,r4
8000a588:	fe b0 f1 84 	rcall	80008890 <__sprint_r>
8000a58c:	e0 81 01 0f 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a590:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a594:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a598:	2f f8       	sub	r8,-1
8000a59a:	40 cb       	lddsp	r11,sp[0x30]
8000a59c:	fb 48 06 90 	st.w	sp[1680],r8
8000a5a0:	30 19       	mov	r9,1
8000a5a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5a6:	87 0b       	st.w	r3[0x0],r11
8000a5a8:	2f f8       	sub	r8,-1
8000a5aa:	87 19       	st.w	r3[0x4],r9
8000a5ac:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5b0:	58 78       	cp.w	r8,7
8000a5b2:	e0 89 00 05 	brgt	8000a5bc <_vfprintf_r+0x1d10>
8000a5b6:	2f 83       	sub	r3,-8
8000a5b8:	c0 c8       	rjmp	8000a5d0 <_vfprintf_r+0x1d24>
8000a5ba:	d7 03       	nop
8000a5bc:	fa ca f9 78 	sub	r10,sp,-1672
8000a5c0:	02 9b       	mov	r11,r1
8000a5c2:	08 9c       	mov	r12,r4
8000a5c4:	fe b0 f1 66 	rcall	80008890 <__sprint_r>
8000a5c8:	e0 81 00 f1 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a5cc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5d0:	30 08       	mov	r8,0
8000a5d2:	30 09       	mov	r9,0
8000a5d4:	40 5b       	lddsp	r11,sp[0x14]
8000a5d6:	40 7a       	lddsp	r10,sp[0x1c]
8000a5d8:	e0 a0 13 25 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000a5dc:	40 68       	lddsp	r8,sp[0x18]
8000a5de:	20 18       	sub	r8,1
8000a5e0:	58 0c       	cp.w	r12,0
8000a5e2:	c0 d1       	brne	8000a5fc <_vfprintf_r+0x1d50>
8000a5e4:	2f f6       	sub	r6,-1
8000a5e6:	87 18       	st.w	r3[0x4],r8
8000a5e8:	87 06       	st.w	r3[0x0],r6
8000a5ea:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a5ee:	10 06       	add	r6,r8
8000a5f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5f4:	fb 46 06 90 	st.w	sp[1680],r6
8000a5f8:	2f f8       	sub	r8,-1
8000a5fa:	c3 18       	rjmp	8000a65c <_vfprintf_r+0x1db0>
8000a5fc:	10 96       	mov	r6,r8
8000a5fe:	58 08       	cp.w	r8,0
8000a600:	e0 89 00 1c 	brgt	8000a638 <_vfprintf_r+0x1d8c>
8000a604:	c4 b8       	rjmp	8000a69a <_vfprintf_r+0x1dee>
8000a606:	2f 09       	sub	r9,-16
8000a608:	2f f8       	sub	r8,-1
8000a60a:	fb 49 06 90 	st.w	sp[1680],r9
8000a60e:	87 02       	st.w	r3[0x0],r2
8000a610:	87 10       	st.w	r3[0x4],r0
8000a612:	fb 48 06 8c 	st.w	sp[1676],r8
8000a616:	58 78       	cp.w	r8,7
8000a618:	e0 89 00 04 	brgt	8000a620 <_vfprintf_r+0x1d74>
8000a61c:	2f 83       	sub	r3,-8
8000a61e:	c0 b8       	rjmp	8000a634 <_vfprintf_r+0x1d88>
8000a620:	fa ca f9 78 	sub	r10,sp,-1672
8000a624:	02 9b       	mov	r11,r1
8000a626:	08 9c       	mov	r12,r4
8000a628:	fe b0 f1 34 	rcall	80008890 <__sprint_r>
8000a62c:	e0 81 00 bf 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a630:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a634:	21 06       	sub	r6,16
8000a636:	c0 48       	rjmp	8000a63e <_vfprintf_r+0x1d92>
8000a638:	fe c2 bd a8 	sub	r2,pc,-16984
8000a63c:	31 00       	mov	r0,16
8000a63e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a642:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a646:	fe ca bd b6 	sub	r10,pc,-16970
8000a64a:	59 06       	cp.w	r6,16
8000a64c:	fe 99 ff dd 	brgt	8000a606 <_vfprintf_r+0x1d5a>
8000a650:	0c 09       	add	r9,r6
8000a652:	87 0a       	st.w	r3[0x0],r10
8000a654:	fb 49 06 90 	st.w	sp[1680],r9
8000a658:	2f f8       	sub	r8,-1
8000a65a:	87 16       	st.w	r3[0x4],r6
8000a65c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a660:	c0 e8       	rjmp	8000a67c <_vfprintf_r+0x1dd0>
8000a662:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a666:	2f f8       	sub	r8,-1
8000a668:	30 19       	mov	r9,1
8000a66a:	fb 48 06 90 	st.w	sp[1680],r8
8000a66e:	87 06       	st.w	r3[0x0],r6
8000a670:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a674:	87 19       	st.w	r3[0x4],r9
8000a676:	2f f8       	sub	r8,-1
8000a678:	fb 48 06 8c 	st.w	sp[1676],r8
8000a67c:	58 78       	cp.w	r8,7
8000a67e:	e0 89 00 04 	brgt	8000a686 <_vfprintf_r+0x1dda>
8000a682:	2f 83       	sub	r3,-8
8000a684:	c0 b8       	rjmp	8000a69a <_vfprintf_r+0x1dee>
8000a686:	fa ca f9 78 	sub	r10,sp,-1672
8000a68a:	02 9b       	mov	r11,r1
8000a68c:	08 9c       	mov	r12,r4
8000a68e:	fe b0 f1 01 	rcall	80008890 <__sprint_r>
8000a692:	e0 81 00 8c 	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a696:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a69a:	40 ea       	lddsp	r10,sp[0x38]
8000a69c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a6a0:	14 08       	add	r8,r10
8000a6a2:	fa c9 f9 64 	sub	r9,sp,-1692
8000a6a6:	fb 48 06 90 	st.w	sp[1680],r8
8000a6aa:	87 1a       	st.w	r3[0x4],r10
8000a6ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6b0:	87 09       	st.w	r3[0x0],r9
8000a6b2:	2f f8       	sub	r8,-1
8000a6b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6b8:	58 78       	cp.w	r8,7
8000a6ba:	e0 89 00 04 	brgt	8000a6c2 <_vfprintf_r+0x1e16>
8000a6be:	2f 83       	sub	r3,-8
8000a6c0:	c0 a8       	rjmp	8000a6d4 <_vfprintf_r+0x1e28>
8000a6c2:	fa ca f9 78 	sub	r10,sp,-1672
8000a6c6:	02 9b       	mov	r11,r1
8000a6c8:	08 9c       	mov	r12,r4
8000a6ca:	fe b0 f0 e3 	rcall	80008890 <__sprint_r>
8000a6ce:	c6 e1       	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a6d0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6d4:	e2 15 00 04 	andl	r5,0x4,COH
8000a6d8:	c3 f0       	breq	8000a756 <_vfprintf_r+0x1eaa>
8000a6da:	40 86       	lddsp	r6,sp[0x20]
8000a6dc:	40 39       	lddsp	r9,sp[0xc]
8000a6de:	12 16       	sub	r6,r9
8000a6e0:	58 06       	cp.w	r6,0
8000a6e2:	e0 89 00 1a 	brgt	8000a716 <_vfprintf_r+0x1e6a>
8000a6e6:	c3 88       	rjmp	8000a756 <_vfprintf_r+0x1eaa>
8000a6e8:	2f 09       	sub	r9,-16
8000a6ea:	2f f8       	sub	r8,-1
8000a6ec:	fb 49 06 90 	st.w	sp[1680],r9
8000a6f0:	87 05       	st.w	r3[0x0],r5
8000a6f2:	87 12       	st.w	r3[0x4],r2
8000a6f4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6f8:	58 78       	cp.w	r8,7
8000a6fa:	e0 89 00 04 	brgt	8000a702 <_vfprintf_r+0x1e56>
8000a6fe:	2f 83       	sub	r3,-8
8000a700:	c0 98       	rjmp	8000a712 <_vfprintf_r+0x1e66>
8000a702:	00 9a       	mov	r10,r0
8000a704:	02 9b       	mov	r11,r1
8000a706:	08 9c       	mov	r12,r4
8000a708:	fe b0 f0 c4 	rcall	80008890 <__sprint_r>
8000a70c:	c4 f1       	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a70e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a712:	21 06       	sub	r6,16
8000a714:	c0 68       	rjmp	8000a720 <_vfprintf_r+0x1e74>
8000a716:	fe c5 be 96 	sub	r5,pc,-16746
8000a71a:	31 02       	mov	r2,16
8000a71c:	fa c0 f9 78 	sub	r0,sp,-1672
8000a720:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a724:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a728:	fe ca be a8 	sub	r10,pc,-16728
8000a72c:	59 06       	cp.w	r6,16
8000a72e:	fe 99 ff dd 	brgt	8000a6e8 <_vfprintf_r+0x1e3c>
8000a732:	0c 09       	add	r9,r6
8000a734:	2f f8       	sub	r8,-1
8000a736:	87 0a       	st.w	r3[0x0],r10
8000a738:	87 16       	st.w	r3[0x4],r6
8000a73a:	fb 49 06 90 	st.w	sp[1680],r9
8000a73e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a742:	58 78       	cp.w	r8,7
8000a744:	e0 8a 00 09 	brle	8000a756 <_vfprintf_r+0x1eaa>
8000a748:	fa ca f9 78 	sub	r10,sp,-1672
8000a74c:	02 9b       	mov	r11,r1
8000a74e:	08 9c       	mov	r12,r4
8000a750:	fe b0 f0 a0 	rcall	80008890 <__sprint_r>
8000a754:	c2 b1       	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a756:	40 bc       	lddsp	r12,sp[0x2c]
8000a758:	40 36       	lddsp	r6,sp[0xc]
8000a75a:	40 8e       	lddsp	lr,sp[0x20]
8000a75c:	ec 0e 0c 48 	max	r8,r6,lr
8000a760:	10 0c       	add	r12,r8
8000a762:	50 bc       	stdsp	sp[0x2c],r12
8000a764:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a768:	58 08       	cp.w	r8,0
8000a76a:	c0 80       	breq	8000a77a <_vfprintf_r+0x1ece>
8000a76c:	fa ca f9 78 	sub	r10,sp,-1672
8000a770:	02 9b       	mov	r11,r1
8000a772:	08 9c       	mov	r12,r4
8000a774:	fe b0 f0 8e 	rcall	80008890 <__sprint_r>
8000a778:	c1 91       	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a77a:	30 0b       	mov	r11,0
8000a77c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a780:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a784:	fe 9f f1 22 	bral	800089c8 <_vfprintf_r+0x11c>
8000a788:	08 95       	mov	r5,r4
8000a78a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a78e:	58 08       	cp.w	r8,0
8000a790:	c0 80       	breq	8000a7a0 <_vfprintf_r+0x1ef4>
8000a792:	08 9c       	mov	r12,r4
8000a794:	fa ca f9 78 	sub	r10,sp,-1672
8000a798:	02 9b       	mov	r11,r1
8000a79a:	fe b0 f0 7b 	rcall	80008890 <__sprint_r>
8000a79e:	c0 61       	brne	8000a7aa <_vfprintf_r+0x1efe>
8000a7a0:	30 08       	mov	r8,0
8000a7a2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7a6:	c0 28       	rjmp	8000a7aa <_vfprintf_r+0x1efe>
8000a7a8:	40 41       	lddsp	r1,sp[0x10]
8000a7aa:	82 68       	ld.sh	r8,r1[0xc]
8000a7ac:	ed b8 00 06 	bld	r8,0x6
8000a7b0:	c0 31       	brne	8000a7b6 <_vfprintf_r+0x1f0a>
8000a7b2:	3f fa       	mov	r10,-1
8000a7b4:	50 ba       	stdsp	sp[0x2c],r10
8000a7b6:	40 bc       	lddsp	r12,sp[0x2c]
8000a7b8:	fe 3d f9 44 	sub	sp,-1724
8000a7bc:	d8 32       	popm	r0-r7,pc
8000a7be:	d7 03       	nop

8000a7c0 <__swsetup_r>:
8000a7c0:	d4 21       	pushm	r4-r7,lr
8000a7c2:	e0 68 0a 4c 	mov	r8,2636
8000a7c6:	18 96       	mov	r6,r12
8000a7c8:	16 97       	mov	r7,r11
8000a7ca:	70 0c       	ld.w	r12,r8[0x0]
8000a7cc:	58 0c       	cp.w	r12,0
8000a7ce:	c0 60       	breq	8000a7da <__swsetup_r+0x1a>
8000a7d0:	78 68       	ld.w	r8,r12[0x18]
8000a7d2:	58 08       	cp.w	r8,0
8000a7d4:	c0 31       	brne	8000a7da <__swsetup_r+0x1a>
8000a7d6:	e0 a0 07 bf 	rcall	8000b754 <__sinit>
8000a7da:	fe c8 be 2a 	sub	r8,pc,-16854
8000a7de:	10 37       	cp.w	r7,r8
8000a7e0:	c0 61       	brne	8000a7ec <__swsetup_r+0x2c>
8000a7e2:	e0 68 0a 4c 	mov	r8,2636
8000a7e6:	70 08       	ld.w	r8,r8[0x0]
8000a7e8:	70 07       	ld.w	r7,r8[0x0]
8000a7ea:	c1 28       	rjmp	8000a80e <__swsetup_r+0x4e>
8000a7ec:	fe c8 be 1c 	sub	r8,pc,-16868
8000a7f0:	10 37       	cp.w	r7,r8
8000a7f2:	c0 61       	brne	8000a7fe <__swsetup_r+0x3e>
8000a7f4:	e0 68 0a 4c 	mov	r8,2636
8000a7f8:	70 08       	ld.w	r8,r8[0x0]
8000a7fa:	70 17       	ld.w	r7,r8[0x4]
8000a7fc:	c0 98       	rjmp	8000a80e <__swsetup_r+0x4e>
8000a7fe:	fe c8 be 0e 	sub	r8,pc,-16882
8000a802:	10 37       	cp.w	r7,r8
8000a804:	c0 51       	brne	8000a80e <__swsetup_r+0x4e>
8000a806:	e0 68 0a 4c 	mov	r8,2636
8000a80a:	70 08       	ld.w	r8,r8[0x0]
8000a80c:	70 27       	ld.w	r7,r8[0x8]
8000a80e:	8e 68       	ld.sh	r8,r7[0xc]
8000a810:	ed b8 00 03 	bld	r8,0x3
8000a814:	c1 e0       	breq	8000a850 <__swsetup_r+0x90>
8000a816:	ed b8 00 04 	bld	r8,0x4
8000a81a:	c3 e1       	brne	8000a896 <__swsetup_r+0xd6>
8000a81c:	ed b8 00 02 	bld	r8,0x2
8000a820:	c1 51       	brne	8000a84a <__swsetup_r+0x8a>
8000a822:	6e db       	ld.w	r11,r7[0x34]
8000a824:	58 0b       	cp.w	r11,0
8000a826:	c0 a0       	breq	8000a83a <__swsetup_r+0x7a>
8000a828:	ee c8 ff bc 	sub	r8,r7,-68
8000a82c:	10 3b       	cp.w	r11,r8
8000a82e:	c0 40       	breq	8000a836 <__swsetup_r+0x76>
8000a830:	0c 9c       	mov	r12,r6
8000a832:	e0 a0 08 2b 	rcall	8000b888 <_free_r>
8000a836:	30 08       	mov	r8,0
8000a838:	8f d8       	st.w	r7[0x34],r8
8000a83a:	8e 68       	ld.sh	r8,r7[0xc]
8000a83c:	e0 18 ff db 	andl	r8,0xffdb
8000a840:	ae 68       	st.h	r7[0xc],r8
8000a842:	30 08       	mov	r8,0
8000a844:	8f 18       	st.w	r7[0x4],r8
8000a846:	6e 48       	ld.w	r8,r7[0x10]
8000a848:	8f 08       	st.w	r7[0x0],r8
8000a84a:	8e 68       	ld.sh	r8,r7[0xc]
8000a84c:	a3 b8       	sbr	r8,0x3
8000a84e:	ae 68       	st.h	r7[0xc],r8
8000a850:	6e 48       	ld.w	r8,r7[0x10]
8000a852:	58 08       	cp.w	r8,0
8000a854:	c0 b1       	brne	8000a86a <__swsetup_r+0xaa>
8000a856:	8e 68       	ld.sh	r8,r7[0xc]
8000a858:	e2 18 02 80 	andl	r8,0x280,COH
8000a85c:	e0 48 02 00 	cp.w	r8,512
8000a860:	c0 50       	breq	8000a86a <__swsetup_r+0xaa>
8000a862:	0c 9c       	mov	r12,r6
8000a864:	0e 9b       	mov	r11,r7
8000a866:	e0 a0 0a 4b 	rcall	8000bcfc <__smakebuf_r>
8000a86a:	8e 69       	ld.sh	r9,r7[0xc]
8000a86c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a870:	c0 70       	breq	8000a87e <__swsetup_r+0xbe>
8000a872:	30 08       	mov	r8,0
8000a874:	8f 28       	st.w	r7[0x8],r8
8000a876:	6e 58       	ld.w	r8,r7[0x14]
8000a878:	5c 38       	neg	r8
8000a87a:	8f 68       	st.w	r7[0x18],r8
8000a87c:	c0 68       	rjmp	8000a888 <__swsetup_r+0xc8>
8000a87e:	ed b9 00 01 	bld	r9,0x1
8000a882:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a886:	8f 28       	st.w	r7[0x8],r8
8000a888:	6e 48       	ld.w	r8,r7[0x10]
8000a88a:	58 08       	cp.w	r8,0
8000a88c:	c0 61       	brne	8000a898 <__swsetup_r+0xd8>
8000a88e:	8e 68       	ld.sh	r8,r7[0xc]
8000a890:	ed b8 00 07 	bld	r8,0x7
8000a894:	c0 21       	brne	8000a898 <__swsetup_r+0xd8>
8000a896:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a898:	d8 2a       	popm	r4-r7,pc,r12=0
8000a89a:	d7 03       	nop

8000a89c <quorem>:
8000a89c:	d4 31       	pushm	r0-r7,lr
8000a89e:	20 2d       	sub	sp,8
8000a8a0:	18 97       	mov	r7,r12
8000a8a2:	78 48       	ld.w	r8,r12[0x10]
8000a8a4:	76 46       	ld.w	r6,r11[0x10]
8000a8a6:	0c 38       	cp.w	r8,r6
8000a8a8:	c0 34       	brge	8000a8ae <quorem+0x12>
8000a8aa:	30 0c       	mov	r12,0
8000a8ac:	c8 58       	rjmp	8000a9b6 <quorem+0x11a>
8000a8ae:	ec c2 ff fc 	sub	r2,r6,-4
8000a8b2:	f6 c3 ff ec 	sub	r3,r11,-20
8000a8b6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a8ba:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a8be:	2f f9       	sub	r9,-1
8000a8c0:	20 16       	sub	r6,1
8000a8c2:	f8 09 0d 08 	divu	r8,r12,r9
8000a8c6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a8ca:	ee c4 ff ec 	sub	r4,r7,-20
8000a8ce:	10 95       	mov	r5,r8
8000a8d0:	58 08       	cp.w	r8,0
8000a8d2:	c4 10       	breq	8000a954 <quorem+0xb8>
8000a8d4:	30 09       	mov	r9,0
8000a8d6:	06 9a       	mov	r10,r3
8000a8d8:	08 98       	mov	r8,r4
8000a8da:	12 91       	mov	r1,r9
8000a8dc:	50 0b       	stdsp	sp[0x0],r11
8000a8de:	70 0e       	ld.w	lr,r8[0x0]
8000a8e0:	b1 8e       	lsr	lr,0x10
8000a8e2:	50 1e       	stdsp	sp[0x4],lr
8000a8e4:	15 0e       	ld.w	lr,r10++
8000a8e6:	fc 00 16 10 	lsr	r0,lr,0x10
8000a8ea:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a8ee:	ea 0e 03 41 	mac	r1,r5,lr
8000a8f2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a8f6:	b1 81       	lsr	r1,0x10
8000a8f8:	40 1b       	lddsp	r11,sp[0x4]
8000a8fa:	ea 00 02 40 	mul	r0,r5,r0
8000a8fe:	e2 00 00 00 	add	r0,r1,r0
8000a902:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a906:	02 1b       	sub	r11,r1
8000a908:	50 1b       	stdsp	sp[0x4],r11
8000a90a:	70 0b       	ld.w	r11,r8[0x0]
8000a90c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a910:	02 09       	add	r9,r1
8000a912:	f2 0e 01 0e 	sub	lr,r9,lr
8000a916:	b0 1e       	st.h	r8[0x2],lr
8000a918:	fc 09 14 10 	asr	r9,lr,0x10
8000a91c:	40 1e       	lddsp	lr,sp[0x4]
8000a91e:	fc 09 00 09 	add	r9,lr,r9
8000a922:	b0 09       	st.h	r8[0x0],r9
8000a924:	e0 01 16 10 	lsr	r1,r0,0x10
8000a928:	2f c8       	sub	r8,-4
8000a92a:	b1 49       	asr	r9,0x10
8000a92c:	04 3a       	cp.w	r10,r2
8000a92e:	fe 98 ff d8 	brls	8000a8de <quorem+0x42>
8000a932:	40 0b       	lddsp	r11,sp[0x0]
8000a934:	58 0c       	cp.w	r12,0
8000a936:	c0 f1       	brne	8000a954 <quorem+0xb8>
8000a938:	ec c8 ff fb 	sub	r8,r6,-5
8000a93c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a940:	c0 28       	rjmp	8000a944 <quorem+0xa8>
8000a942:	20 16       	sub	r6,1
8000a944:	20 48       	sub	r8,4
8000a946:	08 38       	cp.w	r8,r4
8000a948:	e0 88 00 05 	brls	8000a952 <quorem+0xb6>
8000a94c:	70 09       	ld.w	r9,r8[0x0]
8000a94e:	58 09       	cp.w	r9,0
8000a950:	cf 90       	breq	8000a942 <quorem+0xa6>
8000a952:	8f 46       	st.w	r7[0x10],r6
8000a954:	0e 9c       	mov	r12,r7
8000a956:	e0 a0 0a d2 	rcall	8000befa <__mcmp>
8000a95a:	c2 d5       	brlt	8000a9b4 <quorem+0x118>
8000a95c:	2f f5       	sub	r5,-1
8000a95e:	08 98       	mov	r8,r4
8000a960:	30 09       	mov	r9,0
8000a962:	07 0b       	ld.w	r11,r3++
8000a964:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a968:	70 0c       	ld.w	r12,r8[0x0]
8000a96a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a96e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a972:	14 1e       	sub	lr,r10
8000a974:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a978:	16 1a       	sub	r10,r11
8000a97a:	12 0a       	add	r10,r9
8000a97c:	b0 1a       	st.h	r8[0x2],r10
8000a97e:	b1 4a       	asr	r10,0x10
8000a980:	fc 0a 00 09 	add	r9,lr,r10
8000a984:	b0 09       	st.h	r8[0x0],r9
8000a986:	2f c8       	sub	r8,-4
8000a988:	b1 49       	asr	r9,0x10
8000a98a:	04 33       	cp.w	r3,r2
8000a98c:	fe 98 ff eb 	brls	8000a962 <quorem+0xc6>
8000a990:	ec c8 ff fb 	sub	r8,r6,-5
8000a994:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a998:	58 09       	cp.w	r9,0
8000a99a:	c0 d1       	brne	8000a9b4 <quorem+0x118>
8000a99c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a9a0:	c0 28       	rjmp	8000a9a4 <quorem+0x108>
8000a9a2:	20 16       	sub	r6,1
8000a9a4:	20 48       	sub	r8,4
8000a9a6:	08 38       	cp.w	r8,r4
8000a9a8:	e0 88 00 05 	brls	8000a9b2 <quorem+0x116>
8000a9ac:	70 09       	ld.w	r9,r8[0x0]
8000a9ae:	58 09       	cp.w	r9,0
8000a9b0:	cf 90       	breq	8000a9a2 <quorem+0x106>
8000a9b2:	8f 46       	st.w	r7[0x10],r6
8000a9b4:	0a 9c       	mov	r12,r5
8000a9b6:	2f ed       	sub	sp,-8
8000a9b8:	d8 32       	popm	r0-r7,pc
8000a9ba:	d7 03       	nop

8000a9bc <_dtoa_r>:
8000a9bc:	d4 31       	pushm	r0-r7,lr
8000a9be:	21 ad       	sub	sp,104
8000a9c0:	fa c4 ff 74 	sub	r4,sp,-140
8000a9c4:	18 97       	mov	r7,r12
8000a9c6:	16 95       	mov	r5,r11
8000a9c8:	68 2c       	ld.w	r12,r4[0x8]
8000a9ca:	50 c9       	stdsp	sp[0x30],r9
8000a9cc:	68 16       	ld.w	r6,r4[0x4]
8000a9ce:	68 09       	ld.w	r9,r4[0x0]
8000a9d0:	50 e8       	stdsp	sp[0x38],r8
8000a9d2:	14 94       	mov	r4,r10
8000a9d4:	51 2c       	stdsp	sp[0x48],r12
8000a9d6:	fa e5 00 08 	st.d	sp[8],r4
8000a9da:	51 59       	stdsp	sp[0x54],r9
8000a9dc:	6e 95       	ld.w	r5,r7[0x24]
8000a9de:	58 05       	cp.w	r5,0
8000a9e0:	c0 91       	brne	8000a9f2 <_dtoa_r+0x36>
8000a9e2:	31 0c       	mov	r12,16
8000a9e4:	fe b0 e8 e2 	rcall	80007ba8 <malloc>
8000a9e8:	99 35       	st.w	r12[0xc],r5
8000a9ea:	8f 9c       	st.w	r7[0x24],r12
8000a9ec:	99 15       	st.w	r12[0x4],r5
8000a9ee:	99 25       	st.w	r12[0x8],r5
8000a9f0:	99 05       	st.w	r12[0x0],r5
8000a9f2:	6e 99       	ld.w	r9,r7[0x24]
8000a9f4:	72 08       	ld.w	r8,r9[0x0]
8000a9f6:	58 08       	cp.w	r8,0
8000a9f8:	c0 f0       	breq	8000aa16 <_dtoa_r+0x5a>
8000a9fa:	72 1a       	ld.w	r10,r9[0x4]
8000a9fc:	91 1a       	st.w	r8[0x4],r10
8000a9fe:	30 1a       	mov	r10,1
8000aa00:	72 19       	ld.w	r9,r9[0x4]
8000aa02:	f4 09 09 49 	lsl	r9,r10,r9
8000aa06:	10 9b       	mov	r11,r8
8000aa08:	91 29       	st.w	r8[0x8],r9
8000aa0a:	0e 9c       	mov	r12,r7
8000aa0c:	e0 a0 0a 90 	rcall	8000bf2c <_Bfree>
8000aa10:	6e 98       	ld.w	r8,r7[0x24]
8000aa12:	30 09       	mov	r9,0
8000aa14:	91 09       	st.w	r8[0x0],r9
8000aa16:	40 28       	lddsp	r8,sp[0x8]
8000aa18:	10 94       	mov	r4,r8
8000aa1a:	58 08       	cp.w	r8,0
8000aa1c:	c0 64       	brge	8000aa28 <_dtoa_r+0x6c>
8000aa1e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000aa22:	50 28       	stdsp	sp[0x8],r8
8000aa24:	30 18       	mov	r8,1
8000aa26:	c0 28       	rjmp	8000aa2a <_dtoa_r+0x6e>
8000aa28:	30 08       	mov	r8,0
8000aa2a:	8d 08       	st.w	r6[0x0],r8
8000aa2c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000aa30:	40 26       	lddsp	r6,sp[0x8]
8000aa32:	0c 98       	mov	r8,r6
8000aa34:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa38:	18 38       	cp.w	r8,r12
8000aa3a:	c2 01       	brne	8000aa7a <_dtoa_r+0xbe>
8000aa3c:	e0 68 27 0f 	mov	r8,9999
8000aa40:	41 5b       	lddsp	r11,sp[0x54]
8000aa42:	97 08       	st.w	r11[0x0],r8
8000aa44:	40 3a       	lddsp	r10,sp[0xc]
8000aa46:	58 0a       	cp.w	r10,0
8000aa48:	c0 71       	brne	8000aa56 <_dtoa_r+0x9a>
8000aa4a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000aa4e:	c0 41       	brne	8000aa56 <_dtoa_r+0x9a>
8000aa50:	fe cc c0 b0 	sub	r12,pc,-16208
8000aa54:	c0 38       	rjmp	8000aa5a <_dtoa_r+0x9e>
8000aa56:	fe cc c0 aa 	sub	r12,pc,-16214
8000aa5a:	41 29       	lddsp	r9,sp[0x48]
8000aa5c:	58 09       	cp.w	r9,0
8000aa5e:	e0 80 05 9a 	breq	8000b592 <_dtoa_r+0xbd6>
8000aa62:	f8 c8 ff fd 	sub	r8,r12,-3
8000aa66:	f8 c9 ff f8 	sub	r9,r12,-8
8000aa6a:	11 8b       	ld.ub	r11,r8[0x0]
8000aa6c:	30 0a       	mov	r10,0
8000aa6e:	41 25       	lddsp	r5,sp[0x48]
8000aa70:	f4 0b 18 00 	cp.b	r11,r10
8000aa74:	f2 08 17 10 	movne	r8,r9
8000aa78:	c1 68       	rjmp	8000aaa4 <_dtoa_r+0xe8>
8000aa7a:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa7e:	30 08       	mov	r8,0
8000aa80:	fa eb 00 3c 	st.d	sp[60],r10
8000aa84:	30 09       	mov	r9,0
8000aa86:	e0 a0 10 ce 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000aa8a:	c1 00       	breq	8000aaaa <_dtoa_r+0xee>
8000aa8c:	30 18       	mov	r8,1
8000aa8e:	41 5a       	lddsp	r10,sp[0x54]
8000aa90:	95 08       	st.w	r10[0x0],r8
8000aa92:	fe cc c2 16 	sub	r12,pc,-15850
8000aa96:	41 29       	lddsp	r9,sp[0x48]
8000aa98:	f8 08 00 08 	add	r8,r12,r8
8000aa9c:	58 09       	cp.w	r9,0
8000aa9e:	e0 80 05 7a 	breq	8000b592 <_dtoa_r+0xbd6>
8000aaa2:	12 95       	mov	r5,r9
8000aaa4:	8b 08       	st.w	r5[0x0],r8
8000aaa6:	e0 8f 05 76 	bral	8000b592 <_dtoa_r+0xbd6>
8000aaaa:	fa c8 ff 9c 	sub	r8,sp,-100
8000aaae:	fa c9 ff a0 	sub	r9,sp,-96
8000aab2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aab6:	0e 9c       	mov	r12,r7
8000aab8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000aabc:	e0 a0 0a 8a 	rcall	8000bfd0 <__d2b>
8000aac0:	18 93       	mov	r3,r12
8000aac2:	58 05       	cp.w	r5,0
8000aac4:	c0 d0       	breq	8000aade <_dtoa_r+0x122>
8000aac6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aaca:	30 04       	mov	r4,0
8000aacc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000aad0:	ea c5 03 ff 	sub	r5,r5,1023
8000aad4:	10 9b       	mov	r11,r8
8000aad6:	51 74       	stdsp	sp[0x5c],r4
8000aad8:	ea 1b 3f f0 	orh	r11,0x3ff0
8000aadc:	c2 58       	rjmp	8000ab26 <_dtoa_r+0x16a>
8000aade:	41 88       	lddsp	r8,sp[0x60]
8000aae0:	41 9c       	lddsp	r12,sp[0x64]
8000aae2:	10 0c       	add	r12,r8
8000aae4:	f8 c5 fb ce 	sub	r5,r12,-1074
8000aae8:	e0 45 00 20 	cp.w	r5,32
8000aaec:	e0 8a 00 0e 	brle	8000ab08 <_dtoa_r+0x14c>
8000aaf0:	f8 cc fb ee 	sub	r12,r12,-1042
8000aaf4:	40 3b       	lddsp	r11,sp[0xc]
8000aaf6:	ea 08 11 40 	rsub	r8,r5,64
8000aafa:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000aafe:	ec 08 09 46 	lsl	r6,r6,r8
8000ab02:	0c 4c       	or	r12,r6
8000ab04:	c0 78       	rjmp	8000ab12 <_dtoa_r+0x156>
8000ab06:	d7 03       	nop
8000ab08:	ea 0c 11 20 	rsub	r12,r5,32
8000ab0c:	40 3a       	lddsp	r10,sp[0xc]
8000ab0e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000ab12:	e0 a0 10 14 	rcall	8000cb3a <__avr32_u32_to_f64>
8000ab16:	fc 18 fe 10 	movh	r8,0xfe10
8000ab1a:	30 19       	mov	r9,1
8000ab1c:	ea c5 04 33 	sub	r5,r5,1075
8000ab20:	f0 0b 00 0b 	add	r11,r8,r11
8000ab24:	51 79       	stdsp	sp[0x5c],r9
8000ab26:	30 08       	mov	r8,0
8000ab28:	fc 19 3f f8 	movh	r9,0x3ff8
8000ab2c:	e0 a0 0e 9c 	rcall	8000c864 <__avr32_f64_sub>
8000ab30:	e0 68 43 61 	mov	r8,17249
8000ab34:	ea 18 63 6f 	orh	r8,0x636f
8000ab38:	e0 69 87 a7 	mov	r9,34727
8000ab3c:	ea 19 3f d2 	orh	r9,0x3fd2
8000ab40:	e0 a0 0d a6 	rcall	8000c68c <__avr32_f64_mul>
8000ab44:	e0 68 c8 b3 	mov	r8,51379
8000ab48:	ea 18 8b 60 	orh	r8,0x8b60
8000ab4c:	e0 69 8a 28 	mov	r9,35368
8000ab50:	ea 19 3f c6 	orh	r9,0x3fc6
8000ab54:	e0 a0 0f 56 	rcall	8000ca00 <__avr32_f64_add>
8000ab58:	0a 9c       	mov	r12,r5
8000ab5a:	14 90       	mov	r0,r10
8000ab5c:	16 91       	mov	r1,r11
8000ab5e:	e0 a0 0f f2 	rcall	8000cb42 <__avr32_s32_to_f64>
8000ab62:	e0 68 79 fb 	mov	r8,31227
8000ab66:	ea 18 50 9f 	orh	r8,0x509f
8000ab6a:	e0 69 44 13 	mov	r9,17427
8000ab6e:	ea 19 3f d3 	orh	r9,0x3fd3
8000ab72:	e0 a0 0d 8d 	rcall	8000c68c <__avr32_f64_mul>
8000ab76:	14 98       	mov	r8,r10
8000ab78:	16 99       	mov	r9,r11
8000ab7a:	00 9a       	mov	r10,r0
8000ab7c:	02 9b       	mov	r11,r1
8000ab7e:	e0 a0 0f 41 	rcall	8000ca00 <__avr32_f64_add>
8000ab82:	14 90       	mov	r0,r10
8000ab84:	16 91       	mov	r1,r11
8000ab86:	e0 a0 0f c7 	rcall	8000cb14 <__avr32_f64_to_s32>
8000ab8a:	30 08       	mov	r8,0
8000ab8c:	18 96       	mov	r6,r12
8000ab8e:	30 09       	mov	r9,0
8000ab90:	00 9a       	mov	r10,r0
8000ab92:	02 9b       	mov	r11,r1
8000ab94:	e0 a0 10 8e 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000ab98:	c0 c0       	breq	8000abb0 <_dtoa_r+0x1f4>
8000ab9a:	0c 9c       	mov	r12,r6
8000ab9c:	e0 a0 0f d3 	rcall	8000cb42 <__avr32_s32_to_f64>
8000aba0:	14 98       	mov	r8,r10
8000aba2:	16 99       	mov	r9,r11
8000aba4:	00 9a       	mov	r10,r0
8000aba6:	02 9b       	mov	r11,r1
8000aba8:	e0 a0 10 3d 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000abac:	f7 b6 00 01 	subeq	r6,1
8000abb0:	59 66       	cp.w	r6,22
8000abb2:	e0 88 00 05 	brls	8000abbc <_dtoa_r+0x200>
8000abb6:	30 18       	mov	r8,1
8000abb8:	51 48       	stdsp	sp[0x50],r8
8000abba:	c1 38       	rjmp	8000abe0 <_dtoa_r+0x224>
8000abbc:	fe c8 c1 5c 	sub	r8,pc,-16036
8000abc0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000abc4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000abc8:	e0 a0 10 74 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000abcc:	f9 b4 00 00 	moveq	r4,0
8000abd0:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000abd4:	f7 b6 01 01 	subne	r6,1
8000abd8:	f9 bc 01 00 	movne	r12,0
8000abdc:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000abe0:	41 90       	lddsp	r0,sp[0x64]
8000abe2:	20 10       	sub	r0,1
8000abe4:	0a 10       	sub	r0,r5
8000abe6:	c0 46       	brmi	8000abee <_dtoa_r+0x232>
8000abe8:	50 40       	stdsp	sp[0x10],r0
8000abea:	30 00       	mov	r0,0
8000abec:	c0 48       	rjmp	8000abf4 <_dtoa_r+0x238>
8000abee:	30 0b       	mov	r11,0
8000abf0:	5c 30       	neg	r0
8000abf2:	50 4b       	stdsp	sp[0x10],r11
8000abf4:	ec 02 11 00 	rsub	r2,r6,0
8000abf8:	58 06       	cp.w	r6,0
8000abfa:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000abfe:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ac02:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000ac06:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000ac0a:	f9 b2 04 00 	movge	r2,0
8000ac0e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ac12:	f9 b9 05 00 	movlt	r9,0
8000ac16:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000ac1a:	40 c8       	lddsp	r8,sp[0x30]
8000ac1c:	58 98       	cp.w	r8,9
8000ac1e:	e0 8b 00 20 	brhi	8000ac5e <_dtoa_r+0x2a2>
8000ac22:	58 58       	cp.w	r8,5
8000ac24:	f9 b4 0a 01 	movle	r4,1
8000ac28:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000ac2c:	f7 b5 09 04 	subgt	r5,4
8000ac30:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000ac34:	f9 b4 09 00 	movgt	r4,0
8000ac38:	40 cc       	lddsp	r12,sp[0x30]
8000ac3a:	58 3c       	cp.w	r12,3
8000ac3c:	c2 d0       	breq	8000ac96 <_dtoa_r+0x2da>
8000ac3e:	e0 89 00 05 	brgt	8000ac48 <_dtoa_r+0x28c>
8000ac42:	58 2c       	cp.w	r12,2
8000ac44:	c1 01       	brne	8000ac64 <_dtoa_r+0x2a8>
8000ac46:	c1 88       	rjmp	8000ac76 <_dtoa_r+0x2ba>
8000ac48:	40 cb       	lddsp	r11,sp[0x30]
8000ac4a:	58 4b       	cp.w	r11,4
8000ac4c:	c0 60       	breq	8000ac58 <_dtoa_r+0x29c>
8000ac4e:	58 5b       	cp.w	r11,5
8000ac50:	c0 a1       	brne	8000ac64 <_dtoa_r+0x2a8>
8000ac52:	30 1a       	mov	r10,1
8000ac54:	50 da       	stdsp	sp[0x34],r10
8000ac56:	c2 28       	rjmp	8000ac9a <_dtoa_r+0x2de>
8000ac58:	30 19       	mov	r9,1
8000ac5a:	50 d9       	stdsp	sp[0x34],r9
8000ac5c:	c0 f8       	rjmp	8000ac7a <_dtoa_r+0x2be>
8000ac5e:	30 08       	mov	r8,0
8000ac60:	30 14       	mov	r4,1
8000ac62:	50 c8       	stdsp	sp[0x30],r8
8000ac64:	3f f5       	mov	r5,-1
8000ac66:	30 1c       	mov	r12,1
8000ac68:	30 0b       	mov	r11,0
8000ac6a:	50 95       	stdsp	sp[0x24],r5
8000ac6c:	50 dc       	stdsp	sp[0x34],r12
8000ac6e:	0a 91       	mov	r1,r5
8000ac70:	31 28       	mov	r8,18
8000ac72:	50 eb       	stdsp	sp[0x38],r11
8000ac74:	c2 08       	rjmp	8000acb4 <_dtoa_r+0x2f8>
8000ac76:	30 0a       	mov	r10,0
8000ac78:	50 da       	stdsp	sp[0x34],r10
8000ac7a:	40 e9       	lddsp	r9,sp[0x38]
8000ac7c:	58 09       	cp.w	r9,0
8000ac7e:	e0 89 00 07 	brgt	8000ac8c <_dtoa_r+0x2d0>
8000ac82:	30 18       	mov	r8,1
8000ac84:	50 98       	stdsp	sp[0x24],r8
8000ac86:	10 91       	mov	r1,r8
8000ac88:	50 e8       	stdsp	sp[0x38],r8
8000ac8a:	c1 58       	rjmp	8000acb4 <_dtoa_r+0x2f8>
8000ac8c:	40 e5       	lddsp	r5,sp[0x38]
8000ac8e:	50 95       	stdsp	sp[0x24],r5
8000ac90:	0a 91       	mov	r1,r5
8000ac92:	0a 98       	mov	r8,r5
8000ac94:	c1 08       	rjmp	8000acb4 <_dtoa_r+0x2f8>
8000ac96:	30 0c       	mov	r12,0
8000ac98:	50 dc       	stdsp	sp[0x34],r12
8000ac9a:	40 eb       	lddsp	r11,sp[0x38]
8000ac9c:	ec 0b 00 0b 	add	r11,r6,r11
8000aca0:	50 9b       	stdsp	sp[0x24],r11
8000aca2:	16 98       	mov	r8,r11
8000aca4:	2f f8       	sub	r8,-1
8000aca6:	58 08       	cp.w	r8,0
8000aca8:	e0 89 00 05 	brgt	8000acb2 <_dtoa_r+0x2f6>
8000acac:	10 91       	mov	r1,r8
8000acae:	30 18       	mov	r8,1
8000acb0:	c0 28       	rjmp	8000acb4 <_dtoa_r+0x2f8>
8000acb2:	10 91       	mov	r1,r8
8000acb4:	30 09       	mov	r9,0
8000acb6:	6e 9a       	ld.w	r10,r7[0x24]
8000acb8:	95 19       	st.w	r10[0x4],r9
8000acba:	30 49       	mov	r9,4
8000acbc:	c0 68       	rjmp	8000acc8 <_dtoa_r+0x30c>
8000acbe:	d7 03       	nop
8000acc0:	6a 1a       	ld.w	r10,r5[0x4]
8000acc2:	a1 79       	lsl	r9,0x1
8000acc4:	2f fa       	sub	r10,-1
8000acc6:	8b 1a       	st.w	r5[0x4],r10
8000acc8:	6e 95       	ld.w	r5,r7[0x24]
8000acca:	f2 ca ff ec 	sub	r10,r9,-20
8000acce:	10 3a       	cp.w	r10,r8
8000acd0:	fe 98 ff f8 	brls	8000acc0 <_dtoa_r+0x304>
8000acd4:	6a 1b       	ld.w	r11,r5[0x4]
8000acd6:	0e 9c       	mov	r12,r7
8000acd8:	e0 a0 09 44 	rcall	8000bf60 <_Balloc>
8000acdc:	58 e1       	cp.w	r1,14
8000acde:	5f 88       	srls	r8
8000ace0:	8b 0c       	st.w	r5[0x0],r12
8000ace2:	f1 e4 00 04 	and	r4,r8,r4
8000ace6:	6e 98       	ld.w	r8,r7[0x24]
8000ace8:	70 08       	ld.w	r8,r8[0x0]
8000acea:	50 88       	stdsp	sp[0x20],r8
8000acec:	e0 80 01 82 	breq	8000aff0 <_dtoa_r+0x634>
8000acf0:	58 06       	cp.w	r6,0
8000acf2:	e0 8a 00 43 	brle	8000ad78 <_dtoa_r+0x3bc>
8000acf6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000acfa:	fe c8 c2 9a 	sub	r8,pc,-15718
8000acfe:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000ad02:	fa e5 00 18 	st.d	sp[24],r4
8000ad06:	ec 04 14 04 	asr	r4,r6,0x4
8000ad0a:	ed b4 00 04 	bld	r4,0x4
8000ad0e:	c0 30       	breq	8000ad14 <_dtoa_r+0x358>
8000ad10:	30 25       	mov	r5,2
8000ad12:	c1 08       	rjmp	8000ad32 <_dtoa_r+0x376>
8000ad14:	fe c8 c1 ec 	sub	r8,pc,-15892
8000ad18:	f0 e8 00 20 	ld.d	r8,r8[32]
8000ad1c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ad20:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000ad24:	e0 a0 0f fa 	rcall	8000cd18 <__avr32_f64_div>
8000ad28:	30 35       	mov	r5,3
8000ad2a:	14 98       	mov	r8,r10
8000ad2c:	16 99       	mov	r9,r11
8000ad2e:	fa e9 00 08 	st.d	sp[8],r8
8000ad32:	fe cc c2 0a 	sub	r12,pc,-15862
8000ad36:	50 a3       	stdsp	sp[0x28],r3
8000ad38:	0c 93       	mov	r3,r6
8000ad3a:	18 96       	mov	r6,r12
8000ad3c:	c0 f8       	rjmp	8000ad5a <_dtoa_r+0x39e>
8000ad3e:	fa ea 00 18 	ld.d	r10,sp[24]
8000ad42:	ed b4 00 00 	bld	r4,0x0
8000ad46:	c0 81       	brne	8000ad56 <_dtoa_r+0x39a>
8000ad48:	ec e8 00 00 	ld.d	r8,r6[0]
8000ad4c:	2f f5       	sub	r5,-1
8000ad4e:	e0 a0 0c 9f 	rcall	8000c68c <__avr32_f64_mul>
8000ad52:	fa eb 00 18 	st.d	sp[24],r10
8000ad56:	a1 54       	asr	r4,0x1
8000ad58:	2f 86       	sub	r6,-8
8000ad5a:	58 04       	cp.w	r4,0
8000ad5c:	cf 11       	brne	8000ad3e <_dtoa_r+0x382>
8000ad5e:	fa e8 00 18 	ld.d	r8,sp[24]
8000ad62:	fa ea 00 08 	ld.d	r10,sp[8]
8000ad66:	06 96       	mov	r6,r3
8000ad68:	e0 a0 0f d8 	rcall	8000cd18 <__avr32_f64_div>
8000ad6c:	40 a3       	lddsp	r3,sp[0x28]
8000ad6e:	14 98       	mov	r8,r10
8000ad70:	16 99       	mov	r9,r11
8000ad72:	fa e9 00 08 	st.d	sp[8],r8
8000ad76:	c2 f8       	rjmp	8000add4 <_dtoa_r+0x418>
8000ad78:	ec 08 11 00 	rsub	r8,r6,0
8000ad7c:	c0 31       	brne	8000ad82 <_dtoa_r+0x3c6>
8000ad7e:	30 25       	mov	r5,2
8000ad80:	c2 a8       	rjmp	8000add4 <_dtoa_r+0x418>
8000ad82:	fe cc c2 5a 	sub	r12,pc,-15782
8000ad86:	f0 04 14 04 	asr	r4,r8,0x4
8000ad8a:	50 1c       	stdsp	sp[0x4],r12
8000ad8c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ad90:	fe c9 c3 30 	sub	r9,pc,-15568
8000ad94:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ad98:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000ad9c:	e0 a0 0c 78 	rcall	8000c68c <__avr32_f64_mul>
8000ada0:	40 1c       	lddsp	r12,sp[0x4]
8000ada2:	50 63       	stdsp	sp[0x18],r3
8000ada4:	30 25       	mov	r5,2
8000ada6:	0c 93       	mov	r3,r6
8000ada8:	fa eb 00 08 	st.d	sp[8],r10
8000adac:	18 96       	mov	r6,r12
8000adae:	c0 f8       	rjmp	8000adcc <_dtoa_r+0x410>
8000adb0:	fa ea 00 08 	ld.d	r10,sp[8]
8000adb4:	ed b4 00 00 	bld	r4,0x0
8000adb8:	c0 81       	brne	8000adc8 <_dtoa_r+0x40c>
8000adba:	ec e8 00 00 	ld.d	r8,r6[0]
8000adbe:	2f f5       	sub	r5,-1
8000adc0:	e0 a0 0c 66 	rcall	8000c68c <__avr32_f64_mul>
8000adc4:	fa eb 00 08 	st.d	sp[8],r10
8000adc8:	a1 54       	asr	r4,0x1
8000adca:	2f 86       	sub	r6,-8
8000adcc:	58 04       	cp.w	r4,0
8000adce:	cf 11       	brne	8000adb0 <_dtoa_r+0x3f4>
8000add0:	06 96       	mov	r6,r3
8000add2:	40 63       	lddsp	r3,sp[0x18]
8000add4:	41 4a       	lddsp	r10,sp[0x50]
8000add6:	58 0a       	cp.w	r10,0
8000add8:	c2 a0       	breq	8000ae2c <_dtoa_r+0x470>
8000adda:	fa e8 00 08 	ld.d	r8,sp[8]
8000adde:	58 01       	cp.w	r1,0
8000ade0:	5f 94       	srgt	r4
8000ade2:	fa e9 00 18 	st.d	sp[24],r8
8000ade6:	30 08       	mov	r8,0
8000ade8:	fc 19 3f f0 	movh	r9,0x3ff0
8000adec:	fa ea 00 18 	ld.d	r10,sp[24]
8000adf0:	e0 a0 0f 60 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000adf4:	f9 bc 00 00 	moveq	r12,0
8000adf8:	f9 bc 01 01 	movne	r12,1
8000adfc:	e9 ec 00 0c 	and	r12,r4,r12
8000ae00:	c1 60       	breq	8000ae2c <_dtoa_r+0x470>
8000ae02:	40 98       	lddsp	r8,sp[0x24]
8000ae04:	58 08       	cp.w	r8,0
8000ae06:	e0 8a 00 f1 	brle	8000afe8 <_dtoa_r+0x62c>
8000ae0a:	30 08       	mov	r8,0
8000ae0c:	fc 19 40 24 	movh	r9,0x4024
8000ae10:	ec c4 00 01 	sub	r4,r6,1
8000ae14:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae18:	2f f5       	sub	r5,-1
8000ae1a:	50 64       	stdsp	sp[0x18],r4
8000ae1c:	e0 a0 0c 38 	rcall	8000c68c <__avr32_f64_mul>
8000ae20:	40 94       	lddsp	r4,sp[0x24]
8000ae22:	14 98       	mov	r8,r10
8000ae24:	16 99       	mov	r9,r11
8000ae26:	fa e9 00 08 	st.d	sp[8],r8
8000ae2a:	c0 38       	rjmp	8000ae30 <_dtoa_r+0x474>
8000ae2c:	50 66       	stdsp	sp[0x18],r6
8000ae2e:	02 94       	mov	r4,r1
8000ae30:	0a 9c       	mov	r12,r5
8000ae32:	e0 a0 0e 88 	rcall	8000cb42 <__avr32_s32_to_f64>
8000ae36:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae3a:	e0 a0 0c 29 	rcall	8000c68c <__avr32_f64_mul>
8000ae3e:	30 08       	mov	r8,0
8000ae40:	fc 19 40 1c 	movh	r9,0x401c
8000ae44:	e0 a0 0d de 	rcall	8000ca00 <__avr32_f64_add>
8000ae48:	14 98       	mov	r8,r10
8000ae4a:	16 99       	mov	r9,r11
8000ae4c:	fa e9 00 28 	st.d	sp[40],r8
8000ae50:	fc 18 fc c0 	movh	r8,0xfcc0
8000ae54:	40 a5       	lddsp	r5,sp[0x28]
8000ae56:	10 05       	add	r5,r8
8000ae58:	50 a5       	stdsp	sp[0x28],r5
8000ae5a:	58 04       	cp.w	r4,0
8000ae5c:	c2 11       	brne	8000ae9e <_dtoa_r+0x4e2>
8000ae5e:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae62:	30 08       	mov	r8,0
8000ae64:	fc 19 40 14 	movh	r9,0x4014
8000ae68:	e0 a0 0c fe 	rcall	8000c864 <__avr32_f64_sub>
8000ae6c:	40 bc       	lddsp	r12,sp[0x2c]
8000ae6e:	fa eb 00 08 	st.d	sp[8],r10
8000ae72:	14 98       	mov	r8,r10
8000ae74:	16 99       	mov	r9,r11
8000ae76:	18 9a       	mov	r10,r12
8000ae78:	0a 9b       	mov	r11,r5
8000ae7a:	e0 a0 0f 1b 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000ae7e:	e0 81 02 54 	brne	8000b326 <_dtoa_r+0x96a>
8000ae82:	0a 98       	mov	r8,r5
8000ae84:	40 b9       	lddsp	r9,sp[0x2c]
8000ae86:	ee 18 80 00 	eorh	r8,0x8000
8000ae8a:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae8e:	10 95       	mov	r5,r8
8000ae90:	12 98       	mov	r8,r9
8000ae92:	0a 99       	mov	r9,r5
8000ae94:	e0 a0 0f 0e 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000ae98:	e0 81 02 3e 	brne	8000b314 <_dtoa_r+0x958>
8000ae9c:	ca 68       	rjmp	8000afe8 <_dtoa_r+0x62c>
8000ae9e:	fe c9 c4 3e 	sub	r9,pc,-15298
8000aea2:	e8 c8 00 01 	sub	r8,r4,1
8000aea6:	40 d5       	lddsp	r5,sp[0x34]
8000aea8:	58 05       	cp.w	r5,0
8000aeaa:	c4 f0       	breq	8000af48 <_dtoa_r+0x58c>
8000aeac:	30 0c       	mov	r12,0
8000aeae:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000aeb2:	51 3c       	stdsp	sp[0x4c],r12
8000aeb4:	30 0a       	mov	r10,0
8000aeb6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000aeba:	e0 a0 0f 2f 	rcall	8000cd18 <__avr32_f64_div>
8000aebe:	fa e8 00 28 	ld.d	r8,sp[40]
8000aec2:	40 85       	lddsp	r5,sp[0x20]
8000aec4:	e0 a0 0c d0 	rcall	8000c864 <__avr32_f64_sub>
8000aec8:	fa eb 00 28 	st.d	sp[40],r10
8000aecc:	fa ea 00 08 	ld.d	r10,sp[8]
8000aed0:	e0 a0 0e 22 	rcall	8000cb14 <__avr32_f64_to_s32>
8000aed4:	51 6c       	stdsp	sp[0x58],r12
8000aed6:	e0 a0 0e 36 	rcall	8000cb42 <__avr32_s32_to_f64>
8000aeda:	14 98       	mov	r8,r10
8000aedc:	16 99       	mov	r9,r11
8000aede:	fa ea 00 08 	ld.d	r10,sp[8]
8000aee2:	e0 a0 0c c1 	rcall	8000c864 <__avr32_f64_sub>
8000aee6:	fa eb 00 08 	st.d	sp[8],r10
8000aeea:	41 68       	lddsp	r8,sp[0x58]
8000aeec:	2d 08       	sub	r8,-48
8000aeee:	0a c8       	st.b	r5++,r8
8000aef0:	41 39       	lddsp	r9,sp[0x4c]
8000aef2:	2f f9       	sub	r9,-1
8000aef4:	51 39       	stdsp	sp[0x4c],r9
8000aef6:	fa e8 00 28 	ld.d	r8,sp[40]
8000aefa:	e0 a0 0e db 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000aefe:	e0 81 03 39 	brne	8000b570 <_dtoa_r+0xbb4>
8000af02:	fa e8 00 08 	ld.d	r8,sp[8]
8000af06:	30 0a       	mov	r10,0
8000af08:	fc 1b 3f f0 	movh	r11,0x3ff0
8000af0c:	e0 a0 0c ac 	rcall	8000c864 <__avr32_f64_sub>
8000af10:	fa e8 00 28 	ld.d	r8,sp[40]
8000af14:	e0 a0 0e ce 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000af18:	fa ea 00 28 	ld.d	r10,sp[40]
8000af1c:	30 08       	mov	r8,0
8000af1e:	fc 19 40 24 	movh	r9,0x4024
8000af22:	e0 81 00 da 	brne	8000b0d6 <_dtoa_r+0x71a>
8000af26:	41 3c       	lddsp	r12,sp[0x4c]
8000af28:	08 3c       	cp.w	r12,r4
8000af2a:	c5 f4       	brge	8000afe8 <_dtoa_r+0x62c>
8000af2c:	e0 a0 0b b0 	rcall	8000c68c <__avr32_f64_mul>
8000af30:	30 08       	mov	r8,0
8000af32:	fa eb 00 28 	st.d	sp[40],r10
8000af36:	fc 19 40 24 	movh	r9,0x4024
8000af3a:	fa ea 00 08 	ld.d	r10,sp[8]
8000af3e:	e0 a0 0b a7 	rcall	8000c68c <__avr32_f64_mul>
8000af42:	fa eb 00 08 	st.d	sp[8],r10
8000af46:	cc 3b       	rjmp	8000aecc <_dtoa_r+0x510>
8000af48:	40 85       	lddsp	r5,sp[0x20]
8000af4a:	08 05       	add	r5,r4
8000af4c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000af50:	51 35       	stdsp	sp[0x4c],r5
8000af52:	fa e8 00 28 	ld.d	r8,sp[40]
8000af56:	40 85       	lddsp	r5,sp[0x20]
8000af58:	e0 a0 0b 9a 	rcall	8000c68c <__avr32_f64_mul>
8000af5c:	fa eb 00 28 	st.d	sp[40],r10
8000af60:	fa ea 00 08 	ld.d	r10,sp[8]
8000af64:	e0 a0 0d d8 	rcall	8000cb14 <__avr32_f64_to_s32>
8000af68:	51 6c       	stdsp	sp[0x58],r12
8000af6a:	e0 a0 0d ec 	rcall	8000cb42 <__avr32_s32_to_f64>
8000af6e:	14 98       	mov	r8,r10
8000af70:	16 99       	mov	r9,r11
8000af72:	fa ea 00 08 	ld.d	r10,sp[8]
8000af76:	e0 a0 0c 77 	rcall	8000c864 <__avr32_f64_sub>
8000af7a:	fa eb 00 08 	st.d	sp[8],r10
8000af7e:	41 68       	lddsp	r8,sp[0x58]
8000af80:	2d 08       	sub	r8,-48
8000af82:	0a c8       	st.b	r5++,r8
8000af84:	41 3c       	lddsp	r12,sp[0x4c]
8000af86:	18 35       	cp.w	r5,r12
8000af88:	c2 81       	brne	8000afd8 <_dtoa_r+0x61c>
8000af8a:	30 08       	mov	r8,0
8000af8c:	fc 19 3f e0 	movh	r9,0x3fe0
8000af90:	fa ea 00 28 	ld.d	r10,sp[40]
8000af94:	e0 a0 0d 36 	rcall	8000ca00 <__avr32_f64_add>
8000af98:	40 85       	lddsp	r5,sp[0x20]
8000af9a:	fa e8 00 08 	ld.d	r8,sp[8]
8000af9e:	08 05       	add	r5,r4
8000afa0:	e0 a0 0e 88 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000afa4:	e0 81 00 99 	brne	8000b0d6 <_dtoa_r+0x71a>
8000afa8:	fa e8 00 28 	ld.d	r8,sp[40]
8000afac:	30 0a       	mov	r10,0
8000afae:	fc 1b 3f e0 	movh	r11,0x3fe0
8000afb2:	e0 a0 0c 59 	rcall	8000c864 <__avr32_f64_sub>
8000afb6:	14 98       	mov	r8,r10
8000afb8:	16 99       	mov	r9,r11
8000afba:	fa ea 00 08 	ld.d	r10,sp[8]
8000afbe:	e0 a0 0e 79 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000afc2:	c1 30       	breq	8000afe8 <_dtoa_r+0x62c>
8000afc4:	33 09       	mov	r9,48
8000afc6:	0a 98       	mov	r8,r5
8000afc8:	11 7a       	ld.ub	r10,--r8
8000afca:	f2 0a 18 00 	cp.b	r10,r9
8000afce:	e0 81 02 d1 	brne	8000b570 <_dtoa_r+0xbb4>
8000afd2:	10 95       	mov	r5,r8
8000afd4:	cf 9b       	rjmp	8000afc6 <_dtoa_r+0x60a>
8000afd6:	d7 03       	nop
8000afd8:	30 08       	mov	r8,0
8000afda:	fc 19 40 24 	movh	r9,0x4024
8000afde:	e0 a0 0b 57 	rcall	8000c68c <__avr32_f64_mul>
8000afe2:	fa eb 00 08 	st.d	sp[8],r10
8000afe6:	cb db       	rjmp	8000af60 <_dtoa_r+0x5a4>
8000afe8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000afec:	fa eb 00 08 	st.d	sp[8],r10
8000aff0:	58 e6       	cp.w	r6,14
8000aff2:	5f ab       	srle	r11
8000aff4:	41 8a       	lddsp	r10,sp[0x60]
8000aff6:	30 08       	mov	r8,0
8000aff8:	f4 09 11 ff 	rsub	r9,r10,-1
8000affc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b000:	f0 09 18 00 	cp.b	r9,r8
8000b004:	e0 80 00 82 	breq	8000b108 <_dtoa_r+0x74c>
8000b008:	40 ea       	lddsp	r10,sp[0x38]
8000b00a:	58 01       	cp.w	r1,0
8000b00c:	5f a9       	srle	r9
8000b00e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b012:	fe ca c5 b2 	sub	r10,pc,-14926
8000b016:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b01a:	fa e5 00 10 	st.d	sp[16],r4
8000b01e:	f0 09 18 00 	cp.b	r9,r8
8000b022:	c1 40       	breq	8000b04a <_dtoa_r+0x68e>
8000b024:	58 01       	cp.w	r1,0
8000b026:	e0 81 01 77 	brne	8000b314 <_dtoa_r+0x958>
8000b02a:	30 08       	mov	r8,0
8000b02c:	fc 19 40 14 	movh	r9,0x4014
8000b030:	08 9a       	mov	r10,r4
8000b032:	0a 9b       	mov	r11,r5
8000b034:	e0 a0 0b 2c 	rcall	8000c68c <__avr32_f64_mul>
8000b038:	fa e8 00 08 	ld.d	r8,sp[8]
8000b03c:	e0 a0 0e 06 	rcall	8000cc48 <__avr32_f64_cmp_ge>
8000b040:	e0 81 01 6a 	brne	8000b314 <_dtoa_r+0x958>
8000b044:	02 92       	mov	r2,r1
8000b046:	e0 8f 01 72 	bral	8000b32a <_dtoa_r+0x96e>
8000b04a:	40 85       	lddsp	r5,sp[0x20]
8000b04c:	30 14       	mov	r4,1
8000b04e:	fa e8 00 10 	ld.d	r8,sp[16]
8000b052:	fa ea 00 08 	ld.d	r10,sp[8]
8000b056:	e0 a0 0e 61 	rcall	8000cd18 <__avr32_f64_div>
8000b05a:	e0 a0 0d 5d 	rcall	8000cb14 <__avr32_f64_to_s32>
8000b05e:	18 92       	mov	r2,r12
8000b060:	e0 a0 0d 71 	rcall	8000cb42 <__avr32_s32_to_f64>
8000b064:	fa e8 00 10 	ld.d	r8,sp[16]
8000b068:	e0 a0 0b 12 	rcall	8000c68c <__avr32_f64_mul>
8000b06c:	14 98       	mov	r8,r10
8000b06e:	16 99       	mov	r9,r11
8000b070:	fa ea 00 08 	ld.d	r10,sp[8]
8000b074:	e0 a0 0b f8 	rcall	8000c864 <__avr32_f64_sub>
8000b078:	fa eb 00 08 	st.d	sp[8],r10
8000b07c:	e4 c8 ff d0 	sub	r8,r2,-48
8000b080:	0a c8       	st.b	r5++,r8
8000b082:	fc 19 40 24 	movh	r9,0x4024
8000b086:	30 08       	mov	r8,0
8000b088:	02 34       	cp.w	r4,r1
8000b08a:	c3 31       	brne	8000b0f0 <_dtoa_r+0x734>
8000b08c:	fa e8 00 08 	ld.d	r8,sp[8]
8000b090:	e0 a0 0c b8 	rcall	8000ca00 <__avr32_f64_add>
8000b094:	16 91       	mov	r1,r11
8000b096:	14 90       	mov	r0,r10
8000b098:	14 98       	mov	r8,r10
8000b09a:	02 99       	mov	r9,r1
8000b09c:	fa ea 00 10 	ld.d	r10,sp[16]
8000b0a0:	e0 a0 0e 08 	rcall	8000ccb0 <__avr32_f64_cmp_lt>
8000b0a4:	c1 a1       	brne	8000b0d8 <_dtoa_r+0x71c>
8000b0a6:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0aa:	00 9a       	mov	r10,r0
8000b0ac:	02 9b       	mov	r11,r1
8000b0ae:	e0 a0 0d ba 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000b0b2:	e0 80 02 5e 	breq	8000b56e <_dtoa_r+0xbb2>
8000b0b6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b0ba:	c0 f1       	brne	8000b0d8 <_dtoa_r+0x71c>
8000b0bc:	e0 8f 02 59 	bral	8000b56e <_dtoa_r+0xbb2>
8000b0c0:	40 8a       	lddsp	r10,sp[0x20]
8000b0c2:	14 38       	cp.w	r8,r10
8000b0c4:	c0 30       	breq	8000b0ca <_dtoa_r+0x70e>
8000b0c6:	10 95       	mov	r5,r8
8000b0c8:	c0 98       	rjmp	8000b0da <_dtoa_r+0x71e>
8000b0ca:	33 08       	mov	r8,48
8000b0cc:	40 89       	lddsp	r9,sp[0x20]
8000b0ce:	2f f6       	sub	r6,-1
8000b0d0:	b2 88       	st.b	r9[0x0],r8
8000b0d2:	40 88       	lddsp	r8,sp[0x20]
8000b0d4:	c0 88       	rjmp	8000b0e4 <_dtoa_r+0x728>
8000b0d6:	40 66       	lddsp	r6,sp[0x18]
8000b0d8:	33 99       	mov	r9,57
8000b0da:	0a 98       	mov	r8,r5
8000b0dc:	11 7a       	ld.ub	r10,--r8
8000b0de:	f2 0a 18 00 	cp.b	r10,r9
8000b0e2:	ce f0       	breq	8000b0c0 <_dtoa_r+0x704>
8000b0e4:	50 66       	stdsp	sp[0x18],r6
8000b0e6:	11 89       	ld.ub	r9,r8[0x0]
8000b0e8:	2f f9       	sub	r9,-1
8000b0ea:	b0 89       	st.b	r8[0x0],r9
8000b0ec:	e0 8f 02 42 	bral	8000b570 <_dtoa_r+0xbb4>
8000b0f0:	e0 a0 0a ce 	rcall	8000c68c <__avr32_f64_mul>
8000b0f4:	2f f4       	sub	r4,-1
8000b0f6:	fa eb 00 08 	st.d	sp[8],r10
8000b0fa:	30 08       	mov	r8,0
8000b0fc:	30 09       	mov	r9,0
8000b0fe:	e0 a0 0d 92 	rcall	8000cc22 <__avr32_f64_cmp_eq>
8000b102:	ca 60       	breq	8000b04e <_dtoa_r+0x692>
8000b104:	e0 8f 02 35 	bral	8000b56e <_dtoa_r+0xbb2>
8000b108:	40 d8       	lddsp	r8,sp[0x34]
8000b10a:	58 08       	cp.w	r8,0
8000b10c:	c0 51       	brne	8000b116 <_dtoa_r+0x75a>
8000b10e:	04 98       	mov	r8,r2
8000b110:	00 95       	mov	r5,r0
8000b112:	40 d4       	lddsp	r4,sp[0x34]
8000b114:	c3 78       	rjmp	8000b182 <_dtoa_r+0x7c6>
8000b116:	40 c5       	lddsp	r5,sp[0x30]
8000b118:	58 15       	cp.w	r5,1
8000b11a:	e0 89 00 0f 	brgt	8000b138 <_dtoa_r+0x77c>
8000b11e:	41 74       	lddsp	r4,sp[0x5c]
8000b120:	58 04       	cp.w	r4,0
8000b122:	c0 40       	breq	8000b12a <_dtoa_r+0x76e>
8000b124:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b128:	c0 48       	rjmp	8000b130 <_dtoa_r+0x774>
8000b12a:	41 99       	lddsp	r9,sp[0x64]
8000b12c:	f2 09 11 36 	rsub	r9,r9,54
8000b130:	04 98       	mov	r8,r2
8000b132:	00 95       	mov	r5,r0
8000b134:	c1 c8       	rjmp	8000b16c <_dtoa_r+0x7b0>
8000b136:	d7 03       	nop
8000b138:	e2 c8 00 01 	sub	r8,r1,1
8000b13c:	58 01       	cp.w	r1,0
8000b13e:	e0 05 17 40 	movge	r5,r0
8000b142:	e2 09 17 40 	movge	r9,r1
8000b146:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b14a:	f9 b9 05 00 	movlt	r9,0
8000b14e:	10 32       	cp.w	r2,r8
8000b150:	e5 d8 e4 18 	subge	r8,r2,r8
8000b154:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b158:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b15c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b160:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b164:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b168:	f9 b8 05 00 	movlt	r8,0
8000b16c:	40 4b       	lddsp	r11,sp[0x10]
8000b16e:	12 0b       	add	r11,r9
8000b170:	50 08       	stdsp	sp[0x0],r8
8000b172:	50 4b       	stdsp	sp[0x10],r11
8000b174:	12 00       	add	r0,r9
8000b176:	30 1b       	mov	r11,1
8000b178:	0e 9c       	mov	r12,r7
8000b17a:	e0 a0 08 a7 	rcall	8000c2c8 <__i2b>
8000b17e:	40 08       	lddsp	r8,sp[0x0]
8000b180:	18 94       	mov	r4,r12
8000b182:	40 4a       	lddsp	r10,sp[0x10]
8000b184:	58 05       	cp.w	r5,0
8000b186:	5f 99       	srgt	r9
8000b188:	58 0a       	cp.w	r10,0
8000b18a:	5f 9a       	srgt	r10
8000b18c:	f5 e9 00 09 	and	r9,r10,r9
8000b190:	c0 80       	breq	8000b1a0 <_dtoa_r+0x7e4>
8000b192:	40 4c       	lddsp	r12,sp[0x10]
8000b194:	f8 05 0d 49 	min	r9,r12,r5
8000b198:	12 1c       	sub	r12,r9
8000b19a:	12 10       	sub	r0,r9
8000b19c:	50 4c       	stdsp	sp[0x10],r12
8000b19e:	12 15       	sub	r5,r9
8000b1a0:	58 02       	cp.w	r2,0
8000b1a2:	e0 8a 00 27 	brle	8000b1f0 <_dtoa_r+0x834>
8000b1a6:	40 db       	lddsp	r11,sp[0x34]
8000b1a8:	58 0b       	cp.w	r11,0
8000b1aa:	c1 d0       	breq	8000b1e4 <_dtoa_r+0x828>
8000b1ac:	58 08       	cp.w	r8,0
8000b1ae:	e0 8a 00 17 	brle	8000b1dc <_dtoa_r+0x820>
8000b1b2:	10 9a       	mov	r10,r8
8000b1b4:	50 08       	stdsp	sp[0x0],r8
8000b1b6:	08 9b       	mov	r11,r4
8000b1b8:	0e 9c       	mov	r12,r7
8000b1ba:	e0 a0 08 cd 	rcall	8000c354 <__pow5mult>
8000b1be:	06 9a       	mov	r10,r3
8000b1c0:	18 9b       	mov	r11,r12
8000b1c2:	18 94       	mov	r4,r12
8000b1c4:	0e 9c       	mov	r12,r7
8000b1c6:	e0 a0 08 01 	rcall	8000c1c8 <__multiply>
8000b1ca:	18 99       	mov	r9,r12
8000b1cc:	06 9b       	mov	r11,r3
8000b1ce:	50 19       	stdsp	sp[0x4],r9
8000b1d0:	0e 9c       	mov	r12,r7
8000b1d2:	e0 a0 06 ad 	rcall	8000bf2c <_Bfree>
8000b1d6:	40 19       	lddsp	r9,sp[0x4]
8000b1d8:	40 08       	lddsp	r8,sp[0x0]
8000b1da:	12 93       	mov	r3,r9
8000b1dc:	e4 08 01 0a 	sub	r10,r2,r8
8000b1e0:	c0 80       	breq	8000b1f0 <_dtoa_r+0x834>
8000b1e2:	c0 28       	rjmp	8000b1e6 <_dtoa_r+0x82a>
8000b1e4:	04 9a       	mov	r10,r2
8000b1e6:	06 9b       	mov	r11,r3
8000b1e8:	0e 9c       	mov	r12,r7
8000b1ea:	e0 a0 08 b5 	rcall	8000c354 <__pow5mult>
8000b1ee:	18 93       	mov	r3,r12
8000b1f0:	30 1b       	mov	r11,1
8000b1f2:	0e 9c       	mov	r12,r7
8000b1f4:	e0 a0 08 6a 	rcall	8000c2c8 <__i2b>
8000b1f8:	41 1a       	lddsp	r10,sp[0x44]
8000b1fa:	18 92       	mov	r2,r12
8000b1fc:	58 0a       	cp.w	r10,0
8000b1fe:	e0 8a 00 07 	brle	8000b20c <_dtoa_r+0x850>
8000b202:	18 9b       	mov	r11,r12
8000b204:	0e 9c       	mov	r12,r7
8000b206:	e0 a0 08 a7 	rcall	8000c354 <__pow5mult>
8000b20a:	18 92       	mov	r2,r12
8000b20c:	40 c9       	lddsp	r9,sp[0x30]
8000b20e:	58 19       	cp.w	r9,1
8000b210:	e0 89 00 14 	brgt	8000b238 <_dtoa_r+0x87c>
8000b214:	40 38       	lddsp	r8,sp[0xc]
8000b216:	58 08       	cp.w	r8,0
8000b218:	c1 01       	brne	8000b238 <_dtoa_r+0x87c>
8000b21a:	40 29       	lddsp	r9,sp[0x8]
8000b21c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b220:	c0 c1       	brne	8000b238 <_dtoa_r+0x87c>
8000b222:	12 98       	mov	r8,r9
8000b224:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b228:	c0 80       	breq	8000b238 <_dtoa_r+0x87c>
8000b22a:	40 4c       	lddsp	r12,sp[0x10]
8000b22c:	30 1b       	mov	r11,1
8000b22e:	2f fc       	sub	r12,-1
8000b230:	2f f0       	sub	r0,-1
8000b232:	50 4c       	stdsp	sp[0x10],r12
8000b234:	50 6b       	stdsp	sp[0x18],r11
8000b236:	c0 38       	rjmp	8000b23c <_dtoa_r+0x880>
8000b238:	30 0a       	mov	r10,0
8000b23a:	50 6a       	stdsp	sp[0x18],r10
8000b23c:	41 19       	lddsp	r9,sp[0x44]
8000b23e:	58 09       	cp.w	r9,0
8000b240:	c0 31       	brne	8000b246 <_dtoa_r+0x88a>
8000b242:	30 1c       	mov	r12,1
8000b244:	c0 98       	rjmp	8000b256 <_dtoa_r+0x89a>
8000b246:	64 48       	ld.w	r8,r2[0x10]
8000b248:	2f c8       	sub	r8,-4
8000b24a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b24e:	e0 a0 05 df 	rcall	8000be0c <__hi0bits>
8000b252:	f8 0c 11 20 	rsub	r12,r12,32
8000b256:	40 4b       	lddsp	r11,sp[0x10]
8000b258:	f8 0b 00 08 	add	r8,r12,r11
8000b25c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b260:	c0 c0       	breq	8000b278 <_dtoa_r+0x8bc>
8000b262:	f0 08 11 20 	rsub	r8,r8,32
8000b266:	58 48       	cp.w	r8,4
8000b268:	e0 8a 00 06 	brle	8000b274 <_dtoa_r+0x8b8>
8000b26c:	20 48       	sub	r8,4
8000b26e:	10 0b       	add	r11,r8
8000b270:	50 4b       	stdsp	sp[0x10],r11
8000b272:	c0 78       	rjmp	8000b280 <_dtoa_r+0x8c4>
8000b274:	58 48       	cp.w	r8,4
8000b276:	c0 70       	breq	8000b284 <_dtoa_r+0x8c8>
8000b278:	40 4a       	lddsp	r10,sp[0x10]
8000b27a:	2e 48       	sub	r8,-28
8000b27c:	10 0a       	add	r10,r8
8000b27e:	50 4a       	stdsp	sp[0x10],r10
8000b280:	10 00       	add	r0,r8
8000b282:	10 05       	add	r5,r8
8000b284:	58 00       	cp.w	r0,0
8000b286:	e0 8a 00 08 	brle	8000b296 <_dtoa_r+0x8da>
8000b28a:	06 9b       	mov	r11,r3
8000b28c:	00 9a       	mov	r10,r0
8000b28e:	0e 9c       	mov	r12,r7
8000b290:	e0 a0 07 58 	rcall	8000c140 <__lshift>
8000b294:	18 93       	mov	r3,r12
8000b296:	40 49       	lddsp	r9,sp[0x10]
8000b298:	58 09       	cp.w	r9,0
8000b29a:	e0 8a 00 08 	brle	8000b2aa <_dtoa_r+0x8ee>
8000b29e:	04 9b       	mov	r11,r2
8000b2a0:	12 9a       	mov	r10,r9
8000b2a2:	0e 9c       	mov	r12,r7
8000b2a4:	e0 a0 07 4e 	rcall	8000c140 <__lshift>
8000b2a8:	18 92       	mov	r2,r12
8000b2aa:	41 48       	lddsp	r8,sp[0x50]
8000b2ac:	58 08       	cp.w	r8,0
8000b2ae:	c1 b0       	breq	8000b2e4 <_dtoa_r+0x928>
8000b2b0:	04 9b       	mov	r11,r2
8000b2b2:	06 9c       	mov	r12,r3
8000b2b4:	e0 a0 06 23 	rcall	8000befa <__mcmp>
8000b2b8:	c1 64       	brge	8000b2e4 <_dtoa_r+0x928>
8000b2ba:	06 9b       	mov	r11,r3
8000b2bc:	30 09       	mov	r9,0
8000b2be:	30 aa       	mov	r10,10
8000b2c0:	0e 9c       	mov	r12,r7
8000b2c2:	e0 a0 08 0b 	rcall	8000c2d8 <__multadd>
8000b2c6:	20 16       	sub	r6,1
8000b2c8:	18 93       	mov	r3,r12
8000b2ca:	40 dc       	lddsp	r12,sp[0x34]
8000b2cc:	58 0c       	cp.w	r12,0
8000b2ce:	c0 31       	brne	8000b2d4 <_dtoa_r+0x918>
8000b2d0:	40 91       	lddsp	r1,sp[0x24]
8000b2d2:	c0 98       	rjmp	8000b2e4 <_dtoa_r+0x928>
8000b2d4:	08 9b       	mov	r11,r4
8000b2d6:	40 91       	lddsp	r1,sp[0x24]
8000b2d8:	30 09       	mov	r9,0
8000b2da:	30 aa       	mov	r10,10
8000b2dc:	0e 9c       	mov	r12,r7
8000b2de:	e0 a0 07 fd 	rcall	8000c2d8 <__multadd>
8000b2e2:	18 94       	mov	r4,r12
8000b2e4:	58 01       	cp.w	r1,0
8000b2e6:	5f a9       	srle	r9
8000b2e8:	40 cb       	lddsp	r11,sp[0x30]
8000b2ea:	58 2b       	cp.w	r11,2
8000b2ec:	5f 98       	srgt	r8
8000b2ee:	f3 e8 00 08 	and	r8,r9,r8
8000b2f2:	c2 50       	breq	8000b33c <_dtoa_r+0x980>
8000b2f4:	58 01       	cp.w	r1,0
8000b2f6:	c1 11       	brne	8000b318 <_dtoa_r+0x95c>
8000b2f8:	04 9b       	mov	r11,r2
8000b2fa:	02 99       	mov	r9,r1
8000b2fc:	30 5a       	mov	r10,5
8000b2fe:	0e 9c       	mov	r12,r7
8000b300:	e0 a0 07 ec 	rcall	8000c2d8 <__multadd>
8000b304:	18 92       	mov	r2,r12
8000b306:	18 9b       	mov	r11,r12
8000b308:	06 9c       	mov	r12,r3
8000b30a:	e0 a0 05 f8 	rcall	8000befa <__mcmp>
8000b30e:	e0 89 00 0f 	brgt	8000b32c <_dtoa_r+0x970>
8000b312:	c0 38       	rjmp	8000b318 <_dtoa_r+0x95c>
8000b314:	30 02       	mov	r2,0
8000b316:	04 94       	mov	r4,r2
8000b318:	40 ea       	lddsp	r10,sp[0x38]
8000b31a:	30 09       	mov	r9,0
8000b31c:	5c da       	com	r10
8000b31e:	40 85       	lddsp	r5,sp[0x20]
8000b320:	50 6a       	stdsp	sp[0x18],r10
8000b322:	50 49       	stdsp	sp[0x10],r9
8000b324:	c0 f9       	rjmp	8000b542 <_dtoa_r+0xb86>
8000b326:	08 92       	mov	r2,r4
8000b328:	40 66       	lddsp	r6,sp[0x18]
8000b32a:	04 94       	mov	r4,r2
8000b32c:	2f f6       	sub	r6,-1
8000b32e:	50 66       	stdsp	sp[0x18],r6
8000b330:	33 18       	mov	r8,49
8000b332:	40 85       	lddsp	r5,sp[0x20]
8000b334:	0a c8       	st.b	r5++,r8
8000b336:	30 08       	mov	r8,0
8000b338:	50 48       	stdsp	sp[0x10],r8
8000b33a:	c0 49       	rjmp	8000b542 <_dtoa_r+0xb86>
8000b33c:	40 dc       	lddsp	r12,sp[0x34]
8000b33e:	58 0c       	cp.w	r12,0
8000b340:	e0 80 00 b5 	breq	8000b4aa <_dtoa_r+0xaee>
8000b344:	58 05       	cp.w	r5,0
8000b346:	e0 8a 00 08 	brle	8000b356 <_dtoa_r+0x99a>
8000b34a:	08 9b       	mov	r11,r4
8000b34c:	0a 9a       	mov	r10,r5
8000b34e:	0e 9c       	mov	r12,r7
8000b350:	e0 a0 06 f8 	rcall	8000c140 <__lshift>
8000b354:	18 94       	mov	r4,r12
8000b356:	40 6b       	lddsp	r11,sp[0x18]
8000b358:	58 0b       	cp.w	r11,0
8000b35a:	c0 31       	brne	8000b360 <_dtoa_r+0x9a4>
8000b35c:	08 9c       	mov	r12,r4
8000b35e:	c1 38       	rjmp	8000b384 <_dtoa_r+0x9c8>
8000b360:	68 1b       	ld.w	r11,r4[0x4]
8000b362:	0e 9c       	mov	r12,r7
8000b364:	e0 a0 05 fe 	rcall	8000bf60 <_Balloc>
8000b368:	68 4a       	ld.w	r10,r4[0x10]
8000b36a:	18 95       	mov	r5,r12
8000b36c:	e8 cb ff f4 	sub	r11,r4,-12
8000b370:	2f ea       	sub	r10,-2
8000b372:	2f 4c       	sub	r12,-12
8000b374:	a3 6a       	lsl	r10,0x2
8000b376:	fe b0 e6 50 	rcall	80008016 <memcpy>
8000b37a:	0a 9b       	mov	r11,r5
8000b37c:	30 1a       	mov	r10,1
8000b37e:	0e 9c       	mov	r12,r7
8000b380:	e0 a0 06 e0 	rcall	8000c140 <__lshift>
8000b384:	50 44       	stdsp	sp[0x10],r4
8000b386:	40 3a       	lddsp	r10,sp[0xc]
8000b388:	30 19       	mov	r9,1
8000b38a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b38e:	18 94       	mov	r4,r12
8000b390:	50 da       	stdsp	sp[0x34],r10
8000b392:	40 85       	lddsp	r5,sp[0x20]
8000b394:	50 99       	stdsp	sp[0x24],r9
8000b396:	50 26       	stdsp	sp[0x8],r6
8000b398:	50 e1       	stdsp	sp[0x38],r1
8000b39a:	04 9b       	mov	r11,r2
8000b39c:	06 9c       	mov	r12,r3
8000b39e:	fe b0 fa 7f 	rcall	8000a89c <quorem>
8000b3a2:	40 4b       	lddsp	r11,sp[0x10]
8000b3a4:	f8 c0 ff d0 	sub	r0,r12,-48
8000b3a8:	06 9c       	mov	r12,r3
8000b3aa:	e0 a0 05 a8 	rcall	8000befa <__mcmp>
8000b3ae:	08 9a       	mov	r10,r4
8000b3b0:	50 6c       	stdsp	sp[0x18],r12
8000b3b2:	04 9b       	mov	r11,r2
8000b3b4:	0e 9c       	mov	r12,r7
8000b3b6:	e0 a0 06 5d 	rcall	8000c070 <__mdiff>
8000b3ba:	18 91       	mov	r1,r12
8000b3bc:	78 38       	ld.w	r8,r12[0xc]
8000b3be:	58 08       	cp.w	r8,0
8000b3c0:	c0 30       	breq	8000b3c6 <_dtoa_r+0xa0a>
8000b3c2:	30 16       	mov	r6,1
8000b3c4:	c0 68       	rjmp	8000b3d0 <_dtoa_r+0xa14>
8000b3c6:	18 9b       	mov	r11,r12
8000b3c8:	06 9c       	mov	r12,r3
8000b3ca:	e0 a0 05 98 	rcall	8000befa <__mcmp>
8000b3ce:	18 96       	mov	r6,r12
8000b3d0:	0e 9c       	mov	r12,r7
8000b3d2:	02 9b       	mov	r11,r1
8000b3d4:	e0 a0 05 ac 	rcall	8000bf2c <_Bfree>
8000b3d8:	40 cc       	lddsp	r12,sp[0x30]
8000b3da:	ed ec 10 08 	or	r8,r6,r12
8000b3de:	c0 d1       	brne	8000b3f8 <_dtoa_r+0xa3c>
8000b3e0:	40 db       	lddsp	r11,sp[0x34]
8000b3e2:	58 0b       	cp.w	r11,0
8000b3e4:	c0 a1       	brne	8000b3f8 <_dtoa_r+0xa3c>
8000b3e6:	40 26       	lddsp	r6,sp[0x8]
8000b3e8:	e0 40 00 39 	cp.w	r0,57
8000b3ec:	c3 00       	breq	8000b44c <_dtoa_r+0xa90>
8000b3ee:	40 6a       	lddsp	r10,sp[0x18]
8000b3f0:	58 0a       	cp.w	r10,0
8000b3f2:	e0 89 00 24 	brgt	8000b43a <_dtoa_r+0xa7e>
8000b3f6:	c2 f8       	rjmp	8000b454 <_dtoa_r+0xa98>
8000b3f8:	40 69       	lddsp	r9,sp[0x18]
8000b3fa:	58 09       	cp.w	r9,0
8000b3fc:	c0 85       	brlt	8000b40c <_dtoa_r+0xa50>
8000b3fe:	12 98       	mov	r8,r9
8000b400:	40 cc       	lddsp	r12,sp[0x30]
8000b402:	18 48       	or	r8,r12
8000b404:	c1 d1       	brne	8000b43e <_dtoa_r+0xa82>
8000b406:	40 db       	lddsp	r11,sp[0x34]
8000b408:	58 0b       	cp.w	r11,0
8000b40a:	c1 a1       	brne	8000b43e <_dtoa_r+0xa82>
8000b40c:	0c 99       	mov	r9,r6
8000b40e:	40 26       	lddsp	r6,sp[0x8]
8000b410:	58 09       	cp.w	r9,0
8000b412:	e0 8a 00 21 	brle	8000b454 <_dtoa_r+0xa98>
8000b416:	06 9b       	mov	r11,r3
8000b418:	30 1a       	mov	r10,1
8000b41a:	0e 9c       	mov	r12,r7
8000b41c:	e0 a0 06 92 	rcall	8000c140 <__lshift>
8000b420:	04 9b       	mov	r11,r2
8000b422:	18 93       	mov	r3,r12
8000b424:	e0 a0 05 6b 	rcall	8000befa <__mcmp>
8000b428:	e0 89 00 06 	brgt	8000b434 <_dtoa_r+0xa78>
8000b42c:	c1 41       	brne	8000b454 <_dtoa_r+0xa98>
8000b42e:	ed b0 00 00 	bld	r0,0x0
8000b432:	c1 11       	brne	8000b454 <_dtoa_r+0xa98>
8000b434:	e0 40 00 39 	cp.w	r0,57
8000b438:	c0 a0       	breq	8000b44c <_dtoa_r+0xa90>
8000b43a:	2f f0       	sub	r0,-1
8000b43c:	c0 c8       	rjmp	8000b454 <_dtoa_r+0xa98>
8000b43e:	58 06       	cp.w	r6,0
8000b440:	e0 8a 00 0c 	brle	8000b458 <_dtoa_r+0xa9c>
8000b444:	40 26       	lddsp	r6,sp[0x8]
8000b446:	e0 40 00 39 	cp.w	r0,57
8000b44a:	c0 41       	brne	8000b452 <_dtoa_r+0xa96>
8000b44c:	33 98       	mov	r8,57
8000b44e:	0a c8       	st.b	r5++,r8
8000b450:	c6 78       	rjmp	8000b51e <_dtoa_r+0xb62>
8000b452:	2f f0       	sub	r0,-1
8000b454:	0a c0       	st.b	r5++,r0
8000b456:	c7 58       	rjmp	8000b540 <_dtoa_r+0xb84>
8000b458:	0a c0       	st.b	r5++,r0
8000b45a:	40 9a       	lddsp	r10,sp[0x24]
8000b45c:	40 e9       	lddsp	r9,sp[0x38]
8000b45e:	12 3a       	cp.w	r10,r9
8000b460:	c4 30       	breq	8000b4e6 <_dtoa_r+0xb2a>
8000b462:	06 9b       	mov	r11,r3
8000b464:	30 09       	mov	r9,0
8000b466:	30 aa       	mov	r10,10
8000b468:	0e 9c       	mov	r12,r7
8000b46a:	e0 a0 07 37 	rcall	8000c2d8 <__multadd>
8000b46e:	40 48       	lddsp	r8,sp[0x10]
8000b470:	18 93       	mov	r3,r12
8000b472:	08 38       	cp.w	r8,r4
8000b474:	c0 91       	brne	8000b486 <_dtoa_r+0xaca>
8000b476:	10 9b       	mov	r11,r8
8000b478:	30 09       	mov	r9,0
8000b47a:	30 aa       	mov	r10,10
8000b47c:	0e 9c       	mov	r12,r7
8000b47e:	e0 a0 07 2d 	rcall	8000c2d8 <__multadd>
8000b482:	50 4c       	stdsp	sp[0x10],r12
8000b484:	c0 e8       	rjmp	8000b4a0 <_dtoa_r+0xae4>
8000b486:	40 4b       	lddsp	r11,sp[0x10]
8000b488:	30 09       	mov	r9,0
8000b48a:	30 aa       	mov	r10,10
8000b48c:	0e 9c       	mov	r12,r7
8000b48e:	e0 a0 07 25 	rcall	8000c2d8 <__multadd>
8000b492:	08 9b       	mov	r11,r4
8000b494:	50 4c       	stdsp	sp[0x10],r12
8000b496:	30 09       	mov	r9,0
8000b498:	30 aa       	mov	r10,10
8000b49a:	0e 9c       	mov	r12,r7
8000b49c:	e0 a0 07 1e 	rcall	8000c2d8 <__multadd>
8000b4a0:	18 94       	mov	r4,r12
8000b4a2:	40 9c       	lddsp	r12,sp[0x24]
8000b4a4:	2f fc       	sub	r12,-1
8000b4a6:	50 9c       	stdsp	sp[0x24],r12
8000b4a8:	c7 9b       	rjmp	8000b39a <_dtoa_r+0x9de>
8000b4aa:	30 18       	mov	r8,1
8000b4ac:	06 90       	mov	r0,r3
8000b4ae:	40 85       	lddsp	r5,sp[0x20]
8000b4b0:	08 93       	mov	r3,r4
8000b4b2:	0c 94       	mov	r4,r6
8000b4b4:	10 96       	mov	r6,r8
8000b4b6:	04 9b       	mov	r11,r2
8000b4b8:	00 9c       	mov	r12,r0
8000b4ba:	fe b0 f9 f1 	rcall	8000a89c <quorem>
8000b4be:	2d 0c       	sub	r12,-48
8000b4c0:	0a cc       	st.b	r5++,r12
8000b4c2:	02 36       	cp.w	r6,r1
8000b4c4:	c0 a4       	brge	8000b4d8 <_dtoa_r+0xb1c>
8000b4c6:	00 9b       	mov	r11,r0
8000b4c8:	30 09       	mov	r9,0
8000b4ca:	30 aa       	mov	r10,10
8000b4cc:	0e 9c       	mov	r12,r7
8000b4ce:	2f f6       	sub	r6,-1
8000b4d0:	e0 a0 07 04 	rcall	8000c2d8 <__multadd>
8000b4d4:	18 90       	mov	r0,r12
8000b4d6:	cf 0b       	rjmp	8000b4b6 <_dtoa_r+0xafa>
8000b4d8:	08 96       	mov	r6,r4
8000b4da:	30 0b       	mov	r11,0
8000b4dc:	06 94       	mov	r4,r3
8000b4de:	50 4b       	stdsp	sp[0x10],r11
8000b4e0:	00 93       	mov	r3,r0
8000b4e2:	18 90       	mov	r0,r12
8000b4e4:	c0 28       	rjmp	8000b4e8 <_dtoa_r+0xb2c>
8000b4e6:	40 26       	lddsp	r6,sp[0x8]
8000b4e8:	06 9b       	mov	r11,r3
8000b4ea:	30 1a       	mov	r10,1
8000b4ec:	0e 9c       	mov	r12,r7
8000b4ee:	e0 a0 06 29 	rcall	8000c140 <__lshift>
8000b4f2:	04 9b       	mov	r11,r2
8000b4f4:	18 93       	mov	r3,r12
8000b4f6:	e0 a0 05 02 	rcall	8000befa <__mcmp>
8000b4fa:	e0 89 00 12 	brgt	8000b51e <_dtoa_r+0xb62>
8000b4fe:	c1 b1       	brne	8000b534 <_dtoa_r+0xb78>
8000b500:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b504:	c0 d1       	brne	8000b51e <_dtoa_r+0xb62>
8000b506:	c1 78       	rjmp	8000b534 <_dtoa_r+0xb78>
8000b508:	40 89       	lddsp	r9,sp[0x20]
8000b50a:	12 38       	cp.w	r8,r9
8000b50c:	c0 30       	breq	8000b512 <_dtoa_r+0xb56>
8000b50e:	10 95       	mov	r5,r8
8000b510:	c0 88       	rjmp	8000b520 <_dtoa_r+0xb64>
8000b512:	2f f6       	sub	r6,-1
8000b514:	50 66       	stdsp	sp[0x18],r6
8000b516:	33 18       	mov	r8,49
8000b518:	40 8c       	lddsp	r12,sp[0x20]
8000b51a:	b8 88       	st.b	r12[0x0],r8
8000b51c:	c1 38       	rjmp	8000b542 <_dtoa_r+0xb86>
8000b51e:	33 9a       	mov	r10,57
8000b520:	0a 98       	mov	r8,r5
8000b522:	11 79       	ld.ub	r9,--r8
8000b524:	f4 09 18 00 	cp.b	r9,r10
8000b528:	cf 00       	breq	8000b508 <_dtoa_r+0xb4c>
8000b52a:	2f f9       	sub	r9,-1
8000b52c:	b0 89       	st.b	r8[0x0],r9
8000b52e:	c0 98       	rjmp	8000b540 <_dtoa_r+0xb84>
8000b530:	10 95       	mov	r5,r8
8000b532:	c0 28       	rjmp	8000b536 <_dtoa_r+0xb7a>
8000b534:	33 09       	mov	r9,48
8000b536:	0a 98       	mov	r8,r5
8000b538:	11 7a       	ld.ub	r10,--r8
8000b53a:	f2 0a 18 00 	cp.b	r10,r9
8000b53e:	cf 90       	breq	8000b530 <_dtoa_r+0xb74>
8000b540:	50 66       	stdsp	sp[0x18],r6
8000b542:	04 9b       	mov	r11,r2
8000b544:	0e 9c       	mov	r12,r7
8000b546:	e0 a0 04 f3 	rcall	8000bf2c <_Bfree>
8000b54a:	58 04       	cp.w	r4,0
8000b54c:	c1 20       	breq	8000b570 <_dtoa_r+0xbb4>
8000b54e:	40 4b       	lddsp	r11,sp[0x10]
8000b550:	08 3b       	cp.w	r11,r4
8000b552:	5f 19       	srne	r9
8000b554:	58 0b       	cp.w	r11,0
8000b556:	5f 18       	srne	r8
8000b558:	f3 e8 00 08 	and	r8,r9,r8
8000b55c:	c0 40       	breq	8000b564 <_dtoa_r+0xba8>
8000b55e:	0e 9c       	mov	r12,r7
8000b560:	e0 a0 04 e6 	rcall	8000bf2c <_Bfree>
8000b564:	08 9b       	mov	r11,r4
8000b566:	0e 9c       	mov	r12,r7
8000b568:	e0 a0 04 e2 	rcall	8000bf2c <_Bfree>
8000b56c:	c0 28       	rjmp	8000b570 <_dtoa_r+0xbb4>
8000b56e:	50 66       	stdsp	sp[0x18],r6
8000b570:	0e 9c       	mov	r12,r7
8000b572:	06 9b       	mov	r11,r3
8000b574:	e0 a0 04 dc 	rcall	8000bf2c <_Bfree>
8000b578:	30 08       	mov	r8,0
8000b57a:	aa 88       	st.b	r5[0x0],r8
8000b57c:	40 68       	lddsp	r8,sp[0x18]
8000b57e:	41 5a       	lddsp	r10,sp[0x54]
8000b580:	2f f8       	sub	r8,-1
8000b582:	41 29       	lddsp	r9,sp[0x48]
8000b584:	95 08       	st.w	r10[0x0],r8
8000b586:	40 8c       	lddsp	r12,sp[0x20]
8000b588:	58 09       	cp.w	r9,0
8000b58a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b58e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b592:	2e 6d       	sub	sp,-104
8000b594:	d8 32       	popm	r0-r7,pc
8000b596:	d7 03       	nop

8000b598 <__errno>:
8000b598:	e0 68 0a 4c 	mov	r8,2636
8000b59c:	70 0c       	ld.w	r12,r8[0x0]
8000b59e:	2f 4c       	sub	r12,-12
8000b5a0:	5e fc       	retal	r12
8000b5a2:	d7 03       	nop

8000b5a4 <_fflush_r>:
8000b5a4:	d4 21       	pushm	r4-r7,lr
8000b5a6:	16 97       	mov	r7,r11
8000b5a8:	18 96       	mov	r6,r12
8000b5aa:	76 48       	ld.w	r8,r11[0x10]
8000b5ac:	58 08       	cp.w	r8,0
8000b5ae:	c7 f0       	breq	8000b6ac <_fflush_r+0x108>
8000b5b0:	58 0c       	cp.w	r12,0
8000b5b2:	c0 50       	breq	8000b5bc <_fflush_r+0x18>
8000b5b4:	78 68       	ld.w	r8,r12[0x18]
8000b5b6:	58 08       	cp.w	r8,0
8000b5b8:	c0 21       	brne	8000b5bc <_fflush_r+0x18>
8000b5ba:	cc dc       	rcall	8000b754 <__sinit>
8000b5bc:	fe c8 cc 0c 	sub	r8,pc,-13300
8000b5c0:	10 37       	cp.w	r7,r8
8000b5c2:	c0 31       	brne	8000b5c8 <_fflush_r+0x24>
8000b5c4:	6c 07       	ld.w	r7,r6[0x0]
8000b5c6:	c0 c8       	rjmp	8000b5de <_fflush_r+0x3a>
8000b5c8:	fe c8 cb f8 	sub	r8,pc,-13320
8000b5cc:	10 37       	cp.w	r7,r8
8000b5ce:	c0 31       	brne	8000b5d4 <_fflush_r+0x30>
8000b5d0:	6c 17       	ld.w	r7,r6[0x4]
8000b5d2:	c0 68       	rjmp	8000b5de <_fflush_r+0x3a>
8000b5d4:	fe c8 cb e4 	sub	r8,pc,-13340
8000b5d8:	10 37       	cp.w	r7,r8
8000b5da:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b5de:	8e 6a       	ld.sh	r10,r7[0xc]
8000b5e0:	14 98       	mov	r8,r10
8000b5e2:	ed ba 00 03 	bld	r10,0x3
8000b5e6:	c4 20       	breq	8000b66a <_fflush_r+0xc6>
8000b5e8:	ab ba       	sbr	r10,0xb
8000b5ea:	ae 6a       	st.h	r7[0xc],r10
8000b5ec:	6e 18       	ld.w	r8,r7[0x4]
8000b5ee:	58 08       	cp.w	r8,0
8000b5f0:	e0 89 00 06 	brgt	8000b5fc <_fflush_r+0x58>
8000b5f4:	6f 08       	ld.w	r8,r7[0x40]
8000b5f6:	58 08       	cp.w	r8,0
8000b5f8:	e0 8a 00 5a 	brle	8000b6ac <_fflush_r+0x108>
8000b5fc:	6e b8       	ld.w	r8,r7[0x2c]
8000b5fe:	58 08       	cp.w	r8,0
8000b600:	c5 60       	breq	8000b6ac <_fflush_r+0x108>
8000b602:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b606:	c0 30       	breq	8000b60c <_fflush_r+0x68>
8000b608:	6f 55       	ld.w	r5,r7[0x54]
8000b60a:	c0 f8       	rjmp	8000b628 <_fflush_r+0x84>
8000b60c:	30 19       	mov	r9,1
8000b60e:	6e 8b       	ld.w	r11,r7[0x20]
8000b610:	0c 9c       	mov	r12,r6
8000b612:	5d 18       	icall	r8
8000b614:	18 95       	mov	r5,r12
8000b616:	5b fc       	cp.w	r12,-1
8000b618:	c0 81       	brne	8000b628 <_fflush_r+0x84>
8000b61a:	6c 38       	ld.w	r8,r6[0xc]
8000b61c:	59 d8       	cp.w	r8,29
8000b61e:	c4 70       	breq	8000b6ac <_fflush_r+0x108>
8000b620:	8e 68       	ld.sh	r8,r7[0xc]
8000b622:	a7 a8       	sbr	r8,0x6
8000b624:	ae 68       	st.h	r7[0xc],r8
8000b626:	d8 22       	popm	r4-r7,pc
8000b628:	8e 68       	ld.sh	r8,r7[0xc]
8000b62a:	ed b8 00 02 	bld	r8,0x2
8000b62e:	c0 91       	brne	8000b640 <_fflush_r+0x9c>
8000b630:	6e 18       	ld.w	r8,r7[0x4]
8000b632:	10 15       	sub	r5,r8
8000b634:	6e d8       	ld.w	r8,r7[0x34]
8000b636:	58 08       	cp.w	r8,0
8000b638:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b63c:	eb d8 e1 15 	subne	r5,r5,r8
8000b640:	6e b8       	ld.w	r8,r7[0x2c]
8000b642:	0c 9c       	mov	r12,r6
8000b644:	30 09       	mov	r9,0
8000b646:	0a 9a       	mov	r10,r5
8000b648:	6e 8b       	ld.w	r11,r7[0x20]
8000b64a:	5d 18       	icall	r8
8000b64c:	8e 68       	ld.sh	r8,r7[0xc]
8000b64e:	0a 3c       	cp.w	r12,r5
8000b650:	c2 61       	brne	8000b69c <_fflush_r+0xf8>
8000b652:	ab d8       	cbr	r8,0xb
8000b654:	30 0c       	mov	r12,0
8000b656:	6e 49       	ld.w	r9,r7[0x10]
8000b658:	ae 68       	st.h	r7[0xc],r8
8000b65a:	8f 1c       	st.w	r7[0x4],r12
8000b65c:	8f 09       	st.w	r7[0x0],r9
8000b65e:	ed b8 00 0c 	bld	r8,0xc
8000b662:	c2 51       	brne	8000b6ac <_fflush_r+0x108>
8000b664:	ef 45 00 54 	st.w	r7[84],r5
8000b668:	d8 22       	popm	r4-r7,pc
8000b66a:	6e 45       	ld.w	r5,r7[0x10]
8000b66c:	58 05       	cp.w	r5,0
8000b66e:	c1 f0       	breq	8000b6ac <_fflush_r+0x108>
8000b670:	6e 04       	ld.w	r4,r7[0x0]
8000b672:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b676:	8f 05       	st.w	r7[0x0],r5
8000b678:	f9 b8 01 00 	movne	r8,0
8000b67c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b680:	0a 14       	sub	r4,r5
8000b682:	8f 28       	st.w	r7[0x8],r8
8000b684:	c1 18       	rjmp	8000b6a6 <_fflush_r+0x102>
8000b686:	08 99       	mov	r9,r4
8000b688:	0a 9a       	mov	r10,r5
8000b68a:	6e a8       	ld.w	r8,r7[0x28]
8000b68c:	6e 8b       	ld.w	r11,r7[0x20]
8000b68e:	0c 9c       	mov	r12,r6
8000b690:	5d 18       	icall	r8
8000b692:	18 14       	sub	r4,r12
8000b694:	58 0c       	cp.w	r12,0
8000b696:	e0 89 00 07 	brgt	8000b6a4 <_fflush_r+0x100>
8000b69a:	8e 68       	ld.sh	r8,r7[0xc]
8000b69c:	a7 a8       	sbr	r8,0x6
8000b69e:	3f fc       	mov	r12,-1
8000b6a0:	ae 68       	st.h	r7[0xc],r8
8000b6a2:	d8 22       	popm	r4-r7,pc
8000b6a4:	18 05       	add	r5,r12
8000b6a6:	58 04       	cp.w	r4,0
8000b6a8:	fe 99 ff ef 	brgt	8000b686 <_fflush_r+0xe2>
8000b6ac:	d8 2a       	popm	r4-r7,pc,r12=0
8000b6ae:	d7 03       	nop

8000b6b0 <__sfp_lock_acquire>:
8000b6b0:	5e fc       	retal	r12

8000b6b2 <__sfp_lock_release>:
8000b6b2:	5e fc       	retal	r12

8000b6b4 <_cleanup_r>:
8000b6b4:	d4 01       	pushm	lr
8000b6b6:	fe cb f0 ae 	sub	r11,pc,-3922
8000b6ba:	e0 a0 02 f7 	rcall	8000bca8 <_fwalk>
8000b6be:	d8 02       	popm	pc

8000b6c0 <__sfmoreglue>:
8000b6c0:	d4 21       	pushm	r4-r7,lr
8000b6c2:	16 95       	mov	r5,r11
8000b6c4:	f6 06 10 5c 	mul	r6,r11,92
8000b6c8:	ec cb ff f4 	sub	r11,r6,-12
8000b6cc:	fe b0 e2 76 	rcall	80007bb8 <_malloc_r>
8000b6d0:	18 97       	mov	r7,r12
8000b6d2:	c0 90       	breq	8000b6e4 <__sfmoreglue+0x24>
8000b6d4:	99 15       	st.w	r12[0x4],r5
8000b6d6:	30 0b       	mov	r11,0
8000b6d8:	2f 4c       	sub	r12,-12
8000b6da:	0c 9a       	mov	r10,r6
8000b6dc:	8f 2c       	st.w	r7[0x8],r12
8000b6de:	8f 0b       	st.w	r7[0x0],r11
8000b6e0:	fe b0 e5 3f 	rcall	8000815e <memset>
8000b6e4:	0e 9c       	mov	r12,r7
8000b6e6:	d8 22       	popm	r4-r7,pc

8000b6e8 <__sfp>:
8000b6e8:	d4 21       	pushm	r4-r7,lr
8000b6ea:	fe c8 cc d6 	sub	r8,pc,-13098
8000b6ee:	18 96       	mov	r6,r12
8000b6f0:	70 07       	ld.w	r7,r8[0x0]
8000b6f2:	6e 68       	ld.w	r8,r7[0x18]
8000b6f4:	58 08       	cp.w	r8,0
8000b6f6:	c0 31       	brne	8000b6fc <__sfp+0x14>
8000b6f8:	0e 9c       	mov	r12,r7
8000b6fa:	c2 dc       	rcall	8000b754 <__sinit>
8000b6fc:	ee c7 ff 28 	sub	r7,r7,-216
8000b700:	30 05       	mov	r5,0
8000b702:	6e 2c       	ld.w	r12,r7[0x8]
8000b704:	6e 18       	ld.w	r8,r7[0x4]
8000b706:	c0 68       	rjmp	8000b712 <__sfp+0x2a>
8000b708:	98 69       	ld.sh	r9,r12[0xc]
8000b70a:	ea 09 19 00 	cp.h	r9,r5
8000b70e:	c1 10       	breq	8000b730 <__sfp+0x48>
8000b710:	2a 4c       	sub	r12,-92
8000b712:	20 18       	sub	r8,1
8000b714:	cf a7       	brpl	8000b708 <__sfp+0x20>
8000b716:	6e 08       	ld.w	r8,r7[0x0]
8000b718:	58 08       	cp.w	r8,0
8000b71a:	c0 61       	brne	8000b726 <__sfp+0x3e>
8000b71c:	30 4b       	mov	r11,4
8000b71e:	0c 9c       	mov	r12,r6
8000b720:	cd 0f       	rcall	8000b6c0 <__sfmoreglue>
8000b722:	8f 0c       	st.w	r7[0x0],r12
8000b724:	c0 30       	breq	8000b72a <__sfp+0x42>
8000b726:	6e 07       	ld.w	r7,r7[0x0]
8000b728:	ce db       	rjmp	8000b702 <__sfp+0x1a>
8000b72a:	30 c8       	mov	r8,12
8000b72c:	8d 38       	st.w	r6[0xc],r8
8000b72e:	d8 22       	popm	r4-r7,pc
8000b730:	30 08       	mov	r8,0
8000b732:	f9 48 00 4c 	st.w	r12[76],r8
8000b736:	99 08       	st.w	r12[0x0],r8
8000b738:	99 28       	st.w	r12[0x8],r8
8000b73a:	99 18       	st.w	r12[0x4],r8
8000b73c:	99 48       	st.w	r12[0x10],r8
8000b73e:	99 58       	st.w	r12[0x14],r8
8000b740:	99 68       	st.w	r12[0x18],r8
8000b742:	99 d8       	st.w	r12[0x34],r8
8000b744:	99 e8       	st.w	r12[0x38],r8
8000b746:	f9 48 00 48 	st.w	r12[72],r8
8000b74a:	3f f8       	mov	r8,-1
8000b74c:	b8 78       	st.h	r12[0xe],r8
8000b74e:	30 18       	mov	r8,1
8000b750:	b8 68       	st.h	r12[0xc],r8
8000b752:	d8 22       	popm	r4-r7,pc

8000b754 <__sinit>:
8000b754:	d4 21       	pushm	r4-r7,lr
8000b756:	18 96       	mov	r6,r12
8000b758:	78 67       	ld.w	r7,r12[0x18]
8000b75a:	58 07       	cp.w	r7,0
8000b75c:	c4 91       	brne	8000b7ee <__sinit+0x9a>
8000b75e:	fe c8 00 aa 	sub	r8,pc,170
8000b762:	30 15       	mov	r5,1
8000b764:	99 a8       	st.w	r12[0x28],r8
8000b766:	f9 47 00 d8 	st.w	r12[216],r7
8000b76a:	f9 47 00 dc 	st.w	r12[220],r7
8000b76e:	f9 47 00 e0 	st.w	r12[224],r7
8000b772:	99 65       	st.w	r12[0x18],r5
8000b774:	cb af       	rcall	8000b6e8 <__sfp>
8000b776:	8d 0c       	st.w	r6[0x0],r12
8000b778:	0c 9c       	mov	r12,r6
8000b77a:	cb 7f       	rcall	8000b6e8 <__sfp>
8000b77c:	8d 1c       	st.w	r6[0x4],r12
8000b77e:	0c 9c       	mov	r12,r6
8000b780:	cb 4f       	rcall	8000b6e8 <__sfp>
8000b782:	6c 09       	ld.w	r9,r6[0x0]
8000b784:	30 48       	mov	r8,4
8000b786:	93 07       	st.w	r9[0x0],r7
8000b788:	b2 68       	st.h	r9[0xc],r8
8000b78a:	93 17       	st.w	r9[0x4],r7
8000b78c:	93 27       	st.w	r9[0x8],r7
8000b78e:	6c 18       	ld.w	r8,r6[0x4]
8000b790:	b2 77       	st.h	r9[0xe],r7
8000b792:	93 47       	st.w	r9[0x10],r7
8000b794:	93 57       	st.w	r9[0x14],r7
8000b796:	93 67       	st.w	r9[0x18],r7
8000b798:	93 89       	st.w	r9[0x20],r9
8000b79a:	91 07       	st.w	r8[0x0],r7
8000b79c:	91 17       	st.w	r8[0x4],r7
8000b79e:	91 27       	st.w	r8[0x8],r7
8000b7a0:	fe ce f3 24 	sub	lr,pc,-3292
8000b7a4:	fe cb f3 54 	sub	r11,pc,-3244
8000b7a8:	93 9e       	st.w	r9[0x24],lr
8000b7aa:	93 ab       	st.w	r9[0x28],r11
8000b7ac:	fe ca f3 7c 	sub	r10,pc,-3204
8000b7b0:	fe c4 f3 88 	sub	r4,pc,-3192
8000b7b4:	93 ba       	st.w	r9[0x2c],r10
8000b7b6:	93 c4       	st.w	r9[0x30],r4
8000b7b8:	30 99       	mov	r9,9
8000b7ba:	b0 69       	st.h	r8[0xc],r9
8000b7bc:	b0 75       	st.h	r8[0xe],r5
8000b7be:	91 c4       	st.w	r8[0x30],r4
8000b7c0:	91 47       	st.w	r8[0x10],r7
8000b7c2:	91 57       	st.w	r8[0x14],r7
8000b7c4:	91 67       	st.w	r8[0x18],r7
8000b7c6:	91 88       	st.w	r8[0x20],r8
8000b7c8:	91 9e       	st.w	r8[0x24],lr
8000b7ca:	91 ab       	st.w	r8[0x28],r11
8000b7cc:	91 ba       	st.w	r8[0x2c],r10
8000b7ce:	8d 2c       	st.w	r6[0x8],r12
8000b7d0:	31 28       	mov	r8,18
8000b7d2:	99 07       	st.w	r12[0x0],r7
8000b7d4:	b8 68       	st.h	r12[0xc],r8
8000b7d6:	99 17       	st.w	r12[0x4],r7
8000b7d8:	99 27       	st.w	r12[0x8],r7
8000b7da:	30 28       	mov	r8,2
8000b7dc:	b8 78       	st.h	r12[0xe],r8
8000b7de:	99 c4       	st.w	r12[0x30],r4
8000b7e0:	99 67       	st.w	r12[0x18],r7
8000b7e2:	99 9e       	st.w	r12[0x24],lr
8000b7e4:	99 ab       	st.w	r12[0x28],r11
8000b7e6:	99 ba       	st.w	r12[0x2c],r10
8000b7e8:	99 47       	st.w	r12[0x10],r7
8000b7ea:	99 57       	st.w	r12[0x14],r7
8000b7ec:	99 8c       	st.w	r12[0x20],r12
8000b7ee:	d8 22       	popm	r4-r7,pc

8000b7f0 <_malloc_trim_r>:
8000b7f0:	d4 21       	pushm	r4-r7,lr
8000b7f2:	16 95       	mov	r5,r11
8000b7f4:	18 97       	mov	r7,r12
8000b7f6:	fe b0 d7 95 	rcall	80006720 <__malloc_lock>
8000b7fa:	e0 64 05 4c 	mov	r4,1356
8000b7fe:	68 28       	ld.w	r8,r4[0x8]
8000b800:	70 16       	ld.w	r6,r8[0x4]
8000b802:	e0 16 ff fc 	andl	r6,0xfffc
8000b806:	ec c8 ff 91 	sub	r8,r6,-111
8000b80a:	f0 05 01 05 	sub	r5,r8,r5
8000b80e:	e0 15 ff 80 	andl	r5,0xff80
8000b812:	ea c5 00 80 	sub	r5,r5,128
8000b816:	e0 45 00 7f 	cp.w	r5,127
8000b81a:	e0 8a 00 25 	brle	8000b864 <_malloc_trim_r+0x74>
8000b81e:	30 0b       	mov	r11,0
8000b820:	0e 9c       	mov	r12,r7
8000b822:	fe b0 e6 05 	rcall	8000842c <_sbrk_r>
8000b826:	68 28       	ld.w	r8,r4[0x8]
8000b828:	0c 08       	add	r8,r6
8000b82a:	10 3c       	cp.w	r12,r8
8000b82c:	c1 c1       	brne	8000b864 <_malloc_trim_r+0x74>
8000b82e:	ea 0b 11 00 	rsub	r11,r5,0
8000b832:	0e 9c       	mov	r12,r7
8000b834:	fe b0 e5 fc 	rcall	8000842c <_sbrk_r>
8000b838:	5b fc       	cp.w	r12,-1
8000b83a:	c1 91       	brne	8000b86c <_malloc_trim_r+0x7c>
8000b83c:	30 0b       	mov	r11,0
8000b83e:	0e 9c       	mov	r12,r7
8000b840:	fe b0 e5 f6 	rcall	8000842c <_sbrk_r>
8000b844:	68 28       	ld.w	r8,r4[0x8]
8000b846:	f8 08 01 09 	sub	r9,r12,r8
8000b84a:	58 f9       	cp.w	r9,15
8000b84c:	e0 8a 00 0c 	brle	8000b864 <_malloc_trim_r+0x74>
8000b850:	a1 a9       	sbr	r9,0x0
8000b852:	91 19       	st.w	r8[0x4],r9
8000b854:	e0 68 09 58 	mov	r8,2392
8000b858:	70 09       	ld.w	r9,r8[0x0]
8000b85a:	e0 68 0d d0 	mov	r8,3536
8000b85e:	f8 09 01 09 	sub	r9,r12,r9
8000b862:	91 09       	st.w	r8[0x0],r9
8000b864:	0e 9c       	mov	r12,r7
8000b866:	fe b0 d7 63 	rcall	8000672c <__malloc_unlock>
8000b86a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b86c:	68 28       	ld.w	r8,r4[0x8]
8000b86e:	0a 16       	sub	r6,r5
8000b870:	a1 a6       	sbr	r6,0x0
8000b872:	91 16       	st.w	r8[0x4],r6
8000b874:	e0 68 0d d0 	mov	r8,3536
8000b878:	70 09       	ld.w	r9,r8[0x0]
8000b87a:	0a 19       	sub	r9,r5
8000b87c:	0e 9c       	mov	r12,r7
8000b87e:	91 09       	st.w	r8[0x0],r9
8000b880:	fe b0 d7 56 	rcall	8000672c <__malloc_unlock>
8000b884:	da 2a       	popm	r4-r7,pc,r12=1
8000b886:	d7 03       	nop

8000b888 <_free_r>:
8000b888:	d4 21       	pushm	r4-r7,lr
8000b88a:	16 96       	mov	r6,r11
8000b88c:	18 97       	mov	r7,r12
8000b88e:	58 0b       	cp.w	r11,0
8000b890:	e0 80 00 c0 	breq	8000ba10 <_free_r+0x188>
8000b894:	fe b0 d7 46 	rcall	80006720 <__malloc_lock>
8000b898:	20 86       	sub	r6,8
8000b89a:	e0 6a 05 4c 	mov	r10,1356
8000b89e:	6c 18       	ld.w	r8,r6[0x4]
8000b8a0:	74 2e       	ld.w	lr,r10[0x8]
8000b8a2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b8a6:	a1 c8       	cbr	r8,0x0
8000b8a8:	ec 08 00 09 	add	r9,r6,r8
8000b8ac:	72 1b       	ld.w	r11,r9[0x4]
8000b8ae:	e0 1b ff fc 	andl	r11,0xfffc
8000b8b2:	1c 39       	cp.w	r9,lr
8000b8b4:	c1 e1       	brne	8000b8f0 <_free_r+0x68>
8000b8b6:	f6 08 00 08 	add	r8,r11,r8
8000b8ba:	58 0c       	cp.w	r12,0
8000b8bc:	c0 81       	brne	8000b8cc <_free_r+0x44>
8000b8be:	6c 09       	ld.w	r9,r6[0x0]
8000b8c0:	12 16       	sub	r6,r9
8000b8c2:	12 08       	add	r8,r9
8000b8c4:	6c 3b       	ld.w	r11,r6[0xc]
8000b8c6:	6c 29       	ld.w	r9,r6[0x8]
8000b8c8:	97 29       	st.w	r11[0x8],r9
8000b8ca:	93 3b       	st.w	r9[0xc],r11
8000b8cc:	10 99       	mov	r9,r8
8000b8ce:	95 26       	st.w	r10[0x8],r6
8000b8d0:	a1 a9       	sbr	r9,0x0
8000b8d2:	8d 19       	st.w	r6[0x4],r9
8000b8d4:	e0 69 09 54 	mov	r9,2388
8000b8d8:	72 09       	ld.w	r9,r9[0x0]
8000b8da:	12 38       	cp.w	r8,r9
8000b8dc:	c0 63       	brcs	8000b8e8 <_free_r+0x60>
8000b8de:	e0 68 0d cc 	mov	r8,3532
8000b8e2:	0e 9c       	mov	r12,r7
8000b8e4:	70 0b       	ld.w	r11,r8[0x0]
8000b8e6:	c8 5f       	rcall	8000b7f0 <_malloc_trim_r>
8000b8e8:	0e 9c       	mov	r12,r7
8000b8ea:	fe b0 d7 21 	rcall	8000672c <__malloc_unlock>
8000b8ee:	d8 22       	popm	r4-r7,pc
8000b8f0:	93 1b       	st.w	r9[0x4],r11
8000b8f2:	58 0c       	cp.w	r12,0
8000b8f4:	c0 30       	breq	8000b8fa <_free_r+0x72>
8000b8f6:	30 0c       	mov	r12,0
8000b8f8:	c1 08       	rjmp	8000b918 <_free_r+0x90>
8000b8fa:	6c 0e       	ld.w	lr,r6[0x0]
8000b8fc:	f4 c5 ff f8 	sub	r5,r10,-8
8000b900:	1c 16       	sub	r6,lr
8000b902:	1c 08       	add	r8,lr
8000b904:	6c 2e       	ld.w	lr,r6[0x8]
8000b906:	0a 3e       	cp.w	lr,r5
8000b908:	f9 bc 00 01 	moveq	r12,1
8000b90c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b910:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b914:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b918:	f2 0b 00 0e 	add	lr,r9,r11
8000b91c:	7c 1e       	ld.w	lr,lr[0x4]
8000b91e:	ed be 00 00 	bld	lr,0x0
8000b922:	c1 40       	breq	8000b94a <_free_r+0xc2>
8000b924:	16 08       	add	r8,r11
8000b926:	58 0c       	cp.w	r12,0
8000b928:	c0 d1       	brne	8000b942 <_free_r+0xba>
8000b92a:	e0 6e 05 4c 	mov	lr,1356
8000b92e:	72 2b       	ld.w	r11,r9[0x8]
8000b930:	2f 8e       	sub	lr,-8
8000b932:	1c 3b       	cp.w	r11,lr
8000b934:	c0 71       	brne	8000b942 <_free_r+0xba>
8000b936:	97 36       	st.w	r11[0xc],r6
8000b938:	97 26       	st.w	r11[0x8],r6
8000b93a:	8d 2b       	st.w	r6[0x8],r11
8000b93c:	8d 3b       	st.w	r6[0xc],r11
8000b93e:	30 1c       	mov	r12,1
8000b940:	c0 58       	rjmp	8000b94a <_free_r+0xc2>
8000b942:	72 2b       	ld.w	r11,r9[0x8]
8000b944:	72 39       	ld.w	r9,r9[0xc]
8000b946:	93 2b       	st.w	r9[0x8],r11
8000b948:	97 39       	st.w	r11[0xc],r9
8000b94a:	10 99       	mov	r9,r8
8000b94c:	ec 08 09 08 	st.w	r6[r8],r8
8000b950:	a1 a9       	sbr	r9,0x0
8000b952:	8d 19       	st.w	r6[0x4],r9
8000b954:	58 0c       	cp.w	r12,0
8000b956:	c5 a1       	brne	8000ba0a <_free_r+0x182>
8000b958:	e0 48 01 ff 	cp.w	r8,511
8000b95c:	e0 8b 00 13 	brhi	8000b982 <_free_r+0xfa>
8000b960:	a3 98       	lsr	r8,0x3
8000b962:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b966:	72 2b       	ld.w	r11,r9[0x8]
8000b968:	8d 39       	st.w	r6[0xc],r9
8000b96a:	8d 2b       	st.w	r6[0x8],r11
8000b96c:	97 36       	st.w	r11[0xc],r6
8000b96e:	93 26       	st.w	r9[0x8],r6
8000b970:	a3 48       	asr	r8,0x2
8000b972:	74 19       	ld.w	r9,r10[0x4]
8000b974:	30 1b       	mov	r11,1
8000b976:	f6 08 09 48 	lsl	r8,r11,r8
8000b97a:	f3 e8 10 08 	or	r8,r9,r8
8000b97e:	95 18       	st.w	r10[0x4],r8
8000b980:	c4 58       	rjmp	8000ba0a <_free_r+0x182>
8000b982:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b986:	58 4b       	cp.w	r11,4
8000b988:	e0 8b 00 06 	brhi	8000b994 <_free_r+0x10c>
8000b98c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b990:	2c 8b       	sub	r11,-56
8000b992:	c2 08       	rjmp	8000b9d2 <_free_r+0x14a>
8000b994:	59 4b       	cp.w	r11,20
8000b996:	e0 8b 00 04 	brhi	8000b99e <_free_r+0x116>
8000b99a:	2a 5b       	sub	r11,-91
8000b99c:	c1 b8       	rjmp	8000b9d2 <_free_r+0x14a>
8000b99e:	e0 4b 00 54 	cp.w	r11,84
8000b9a2:	e0 8b 00 06 	brhi	8000b9ae <_free_r+0x126>
8000b9a6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b9aa:	29 2b       	sub	r11,-110
8000b9ac:	c1 38       	rjmp	8000b9d2 <_free_r+0x14a>
8000b9ae:	e0 4b 01 54 	cp.w	r11,340
8000b9b2:	e0 8b 00 06 	brhi	8000b9be <_free_r+0x136>
8000b9b6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b9ba:	28 9b       	sub	r11,-119
8000b9bc:	c0 b8       	rjmp	8000b9d2 <_free_r+0x14a>
8000b9be:	e0 4b 05 54 	cp.w	r11,1364
8000b9c2:	e0 88 00 05 	brls	8000b9cc <_free_r+0x144>
8000b9c6:	37 eb       	mov	r11,126
8000b9c8:	c0 58       	rjmp	8000b9d2 <_free_r+0x14a>
8000b9ca:	d7 03       	nop
8000b9cc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b9d0:	28 4b       	sub	r11,-124
8000b9d2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b9d6:	78 29       	ld.w	r9,r12[0x8]
8000b9d8:	18 39       	cp.w	r9,r12
8000b9da:	c0 e1       	brne	8000b9f6 <_free_r+0x16e>
8000b9dc:	74 18       	ld.w	r8,r10[0x4]
8000b9de:	a3 4b       	asr	r11,0x2
8000b9e0:	30 1c       	mov	r12,1
8000b9e2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b9e6:	f1 eb 10 0b 	or	r11,r8,r11
8000b9ea:	12 98       	mov	r8,r9
8000b9ec:	95 1b       	st.w	r10[0x4],r11
8000b9ee:	c0 a8       	rjmp	8000ba02 <_free_r+0x17a>
8000b9f0:	72 29       	ld.w	r9,r9[0x8]
8000b9f2:	18 39       	cp.w	r9,r12
8000b9f4:	c0 60       	breq	8000ba00 <_free_r+0x178>
8000b9f6:	72 1a       	ld.w	r10,r9[0x4]
8000b9f8:	e0 1a ff fc 	andl	r10,0xfffc
8000b9fc:	14 38       	cp.w	r8,r10
8000b9fe:	cf 93       	brcs	8000b9f0 <_free_r+0x168>
8000ba00:	72 38       	ld.w	r8,r9[0xc]
8000ba02:	8d 38       	st.w	r6[0xc],r8
8000ba04:	8d 29       	st.w	r6[0x8],r9
8000ba06:	93 36       	st.w	r9[0xc],r6
8000ba08:	91 26       	st.w	r8[0x8],r6
8000ba0a:	0e 9c       	mov	r12,r7
8000ba0c:	fe b0 d6 90 	rcall	8000672c <__malloc_unlock>
8000ba10:	d8 22       	popm	r4-r7,pc
8000ba12:	d7 03       	nop

8000ba14 <__sfvwrite_r>:
8000ba14:	d4 31       	pushm	r0-r7,lr
8000ba16:	20 3d       	sub	sp,12
8000ba18:	14 94       	mov	r4,r10
8000ba1a:	18 95       	mov	r5,r12
8000ba1c:	16 97       	mov	r7,r11
8000ba1e:	74 28       	ld.w	r8,r10[0x8]
8000ba20:	58 08       	cp.w	r8,0
8000ba22:	e0 80 01 40 	breq	8000bca2 <__sfvwrite_r+0x28e>
8000ba26:	96 68       	ld.sh	r8,r11[0xc]
8000ba28:	ed b8 00 03 	bld	r8,0x3
8000ba2c:	c0 41       	brne	8000ba34 <__sfvwrite_r+0x20>
8000ba2e:	76 48       	ld.w	r8,r11[0x10]
8000ba30:	58 08       	cp.w	r8,0
8000ba32:	c0 c1       	brne	8000ba4a <__sfvwrite_r+0x36>
8000ba34:	0e 9b       	mov	r11,r7
8000ba36:	0a 9c       	mov	r12,r5
8000ba38:	fe b0 f6 c4 	rcall	8000a7c0 <__swsetup_r>
8000ba3c:	c0 70       	breq	8000ba4a <__sfvwrite_r+0x36>
8000ba3e:	8e 68       	ld.sh	r8,r7[0xc]
8000ba40:	a7 a8       	sbr	r8,0x6
8000ba42:	ae 68       	st.h	r7[0xc],r8
8000ba44:	30 98       	mov	r8,9
8000ba46:	8b 38       	st.w	r5[0xc],r8
8000ba48:	c2 b9       	rjmp	8000bc9e <__sfvwrite_r+0x28a>
8000ba4a:	8e 63       	ld.sh	r3,r7[0xc]
8000ba4c:	68 00       	ld.w	r0,r4[0x0]
8000ba4e:	06 96       	mov	r6,r3
8000ba50:	e2 16 00 02 	andl	r6,0x2,COH
8000ba54:	c2 10       	breq	8000ba96 <__sfvwrite_r+0x82>
8000ba56:	30 03       	mov	r3,0
8000ba58:	e0 62 04 00 	mov	r2,1024
8000ba5c:	06 96       	mov	r6,r3
8000ba5e:	c0 48       	rjmp	8000ba66 <__sfvwrite_r+0x52>
8000ba60:	60 03       	ld.w	r3,r0[0x0]
8000ba62:	60 16       	ld.w	r6,r0[0x4]
8000ba64:	2f 80       	sub	r0,-8
8000ba66:	58 06       	cp.w	r6,0
8000ba68:	cf c0       	breq	8000ba60 <__sfvwrite_r+0x4c>
8000ba6a:	e0 46 04 00 	cp.w	r6,1024
8000ba6e:	ec 09 17 80 	movls	r9,r6
8000ba72:	e4 09 17 b0 	movhi	r9,r2
8000ba76:	06 9a       	mov	r10,r3
8000ba78:	6e a8       	ld.w	r8,r7[0x28]
8000ba7a:	6e 8b       	ld.w	r11,r7[0x20]
8000ba7c:	0a 9c       	mov	r12,r5
8000ba7e:	5d 18       	icall	r8
8000ba80:	18 16       	sub	r6,r12
8000ba82:	58 0c       	cp.w	r12,0
8000ba84:	e0 8a 01 0a 	brle	8000bc98 <__sfvwrite_r+0x284>
8000ba88:	68 28       	ld.w	r8,r4[0x8]
8000ba8a:	18 18       	sub	r8,r12
8000ba8c:	89 28       	st.w	r4[0x8],r8
8000ba8e:	e0 80 01 0a 	breq	8000bca2 <__sfvwrite_r+0x28e>
8000ba92:	18 03       	add	r3,r12
8000ba94:	ce 9b       	rjmp	8000ba66 <__sfvwrite_r+0x52>
8000ba96:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ba9a:	c0 70       	breq	8000baa8 <__sfvwrite_r+0x94>
8000ba9c:	50 06       	stdsp	sp[0x0],r6
8000ba9e:	0c 93       	mov	r3,r6
8000baa0:	0c 91       	mov	r1,r6
8000baa2:	50 15       	stdsp	sp[0x4],r5
8000baa4:	08 92       	mov	r2,r4
8000baa6:	c9 c8       	rjmp	8000bbde <__sfvwrite_r+0x1ca>
8000baa8:	06 96       	mov	r6,r3
8000baaa:	08 91       	mov	r1,r4
8000baac:	c0 48       	rjmp	8000bab4 <__sfvwrite_r+0xa0>
8000baae:	60 03       	ld.w	r3,r0[0x0]
8000bab0:	60 16       	ld.w	r6,r0[0x4]
8000bab2:	2f 80       	sub	r0,-8
8000bab4:	58 06       	cp.w	r6,0
8000bab6:	cf c0       	breq	8000baae <__sfvwrite_r+0x9a>
8000bab8:	8e 68       	ld.sh	r8,r7[0xc]
8000baba:	6e 24       	ld.w	r4,r7[0x8]
8000babc:	10 99       	mov	r9,r8
8000babe:	e2 19 02 00 	andl	r9,0x200,COH
8000bac2:	c5 50       	breq	8000bb6c <__sfvwrite_r+0x158>
8000bac4:	08 36       	cp.w	r6,r4
8000bac6:	c4 43       	brcs	8000bb4e <__sfvwrite_r+0x13a>
8000bac8:	10 99       	mov	r9,r8
8000baca:	e2 19 04 80 	andl	r9,0x480,COH
8000bace:	c4 00       	breq	8000bb4e <__sfvwrite_r+0x13a>
8000bad0:	6e 4b       	ld.w	r11,r7[0x10]
8000bad2:	6e 09       	ld.w	r9,r7[0x0]
8000bad4:	16 19       	sub	r9,r11
8000bad6:	50 09       	stdsp	sp[0x0],r9
8000bad8:	6e 59       	ld.w	r9,r7[0x14]
8000bada:	10 9c       	mov	r12,r8
8000badc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000bae0:	30 28       	mov	r8,2
8000bae2:	f4 08 0c 08 	divs	r8,r10,r8
8000bae6:	fa e9 00 04 	st.d	sp[4],r8
8000baea:	10 94       	mov	r4,r8
8000baec:	40 09       	lddsp	r9,sp[0x0]
8000baee:	e2 1c 04 00 	andl	r12,0x400,COH
8000baf2:	2f f9       	sub	r9,-1
8000baf4:	0c 09       	add	r9,r6
8000baf6:	12 38       	cp.w	r8,r9
8000baf8:	f2 04 17 30 	movlo	r4,r9
8000bafc:	58 0c       	cp.w	r12,0
8000bafe:	c1 10       	breq	8000bb20 <__sfvwrite_r+0x10c>
8000bb00:	08 9b       	mov	r11,r4
8000bb02:	0a 9c       	mov	r12,r5
8000bb04:	fe b0 e0 5a 	rcall	80007bb8 <_malloc_r>
8000bb08:	18 92       	mov	r2,r12
8000bb0a:	c1 40       	breq	8000bb32 <__sfvwrite_r+0x11e>
8000bb0c:	40 0a       	lddsp	r10,sp[0x0]
8000bb0e:	6e 4b       	ld.w	r11,r7[0x10]
8000bb10:	fe b0 e2 83 	rcall	80008016 <memcpy>
8000bb14:	8e 68       	ld.sh	r8,r7[0xc]
8000bb16:	e0 18 fb 7f 	andl	r8,0xfb7f
8000bb1a:	a7 b8       	sbr	r8,0x7
8000bb1c:	ae 68       	st.h	r7[0xc],r8
8000bb1e:	c0 d8       	rjmp	8000bb38 <__sfvwrite_r+0x124>
8000bb20:	08 9a       	mov	r10,r4
8000bb22:	0a 9c       	mov	r12,r5
8000bb24:	fe b0 e3 24 	rcall	8000816c <_realloc_r>
8000bb28:	18 92       	mov	r2,r12
8000bb2a:	c0 71       	brne	8000bb38 <__sfvwrite_r+0x124>
8000bb2c:	6e 4b       	ld.w	r11,r7[0x10]
8000bb2e:	0a 9c       	mov	r12,r5
8000bb30:	ca ce       	rcall	8000b888 <_free_r>
8000bb32:	30 c8       	mov	r8,12
8000bb34:	8b 38       	st.w	r5[0xc],r8
8000bb36:	cb 18       	rjmp	8000bc98 <__sfvwrite_r+0x284>
8000bb38:	40 0a       	lddsp	r10,sp[0x0]
8000bb3a:	40 09       	lddsp	r9,sp[0x0]
8000bb3c:	e8 0a 01 0a 	sub	r10,r4,r10
8000bb40:	e4 09 00 08 	add	r8,r2,r9
8000bb44:	8f 54       	st.w	r7[0x14],r4
8000bb46:	8f 2a       	st.w	r7[0x8],r10
8000bb48:	8f 08       	st.w	r7[0x0],r8
8000bb4a:	8f 42       	st.w	r7[0x10],r2
8000bb4c:	0c 94       	mov	r4,r6
8000bb4e:	08 36       	cp.w	r6,r4
8000bb50:	ec 04 17 30 	movlo	r4,r6
8000bb54:	06 9b       	mov	r11,r3
8000bb56:	08 9a       	mov	r10,r4
8000bb58:	6e 0c       	ld.w	r12,r7[0x0]
8000bb5a:	c3 ad       	rcall	8000bdce <memmove>
8000bb5c:	6e 08       	ld.w	r8,r7[0x0]
8000bb5e:	08 08       	add	r8,r4
8000bb60:	8f 08       	st.w	r7[0x0],r8
8000bb62:	6e 28       	ld.w	r8,r7[0x8]
8000bb64:	08 18       	sub	r8,r4
8000bb66:	0c 94       	mov	r4,r6
8000bb68:	8f 28       	st.w	r7[0x8],r8
8000bb6a:	c2 e8       	rjmp	8000bbc6 <__sfvwrite_r+0x1b2>
8000bb6c:	08 36       	cp.w	r6,r4
8000bb6e:	5f ba       	srhi	r10
8000bb70:	6e 0c       	ld.w	r12,r7[0x0]
8000bb72:	6e 48       	ld.w	r8,r7[0x10]
8000bb74:	10 3c       	cp.w	r12,r8
8000bb76:	5f b8       	srhi	r8
8000bb78:	f5 e8 00 08 	and	r8,r10,r8
8000bb7c:	f2 08 18 00 	cp.b	r8,r9
8000bb80:	c0 d0       	breq	8000bb9a <__sfvwrite_r+0x186>
8000bb82:	06 9b       	mov	r11,r3
8000bb84:	08 9a       	mov	r10,r4
8000bb86:	c2 4d       	rcall	8000bdce <memmove>
8000bb88:	6e 08       	ld.w	r8,r7[0x0]
8000bb8a:	08 08       	add	r8,r4
8000bb8c:	0e 9b       	mov	r11,r7
8000bb8e:	8f 08       	st.w	r7[0x0],r8
8000bb90:	0a 9c       	mov	r12,r5
8000bb92:	fe b0 fd 09 	rcall	8000b5a4 <_fflush_r>
8000bb96:	c1 80       	breq	8000bbc6 <__sfvwrite_r+0x1b2>
8000bb98:	c8 08       	rjmp	8000bc98 <__sfvwrite_r+0x284>
8000bb9a:	6e 59       	ld.w	r9,r7[0x14]
8000bb9c:	12 36       	cp.w	r6,r9
8000bb9e:	c0 a3       	brcs	8000bbb2 <__sfvwrite_r+0x19e>
8000bba0:	6e a8       	ld.w	r8,r7[0x28]
8000bba2:	06 9a       	mov	r10,r3
8000bba4:	6e 8b       	ld.w	r11,r7[0x20]
8000bba6:	0a 9c       	mov	r12,r5
8000bba8:	5d 18       	icall	r8
8000bbaa:	18 94       	mov	r4,r12
8000bbac:	e0 89 00 0d 	brgt	8000bbc6 <__sfvwrite_r+0x1b2>
8000bbb0:	c7 48       	rjmp	8000bc98 <__sfvwrite_r+0x284>
8000bbb2:	0c 9a       	mov	r10,r6
8000bbb4:	06 9b       	mov	r11,r3
8000bbb6:	c0 cd       	rcall	8000bdce <memmove>
8000bbb8:	6e 08       	ld.w	r8,r7[0x0]
8000bbba:	0c 08       	add	r8,r6
8000bbbc:	0c 94       	mov	r4,r6
8000bbbe:	8f 08       	st.w	r7[0x0],r8
8000bbc0:	6e 28       	ld.w	r8,r7[0x8]
8000bbc2:	0c 18       	sub	r8,r6
8000bbc4:	8f 28       	st.w	r7[0x8],r8
8000bbc6:	62 28       	ld.w	r8,r1[0x8]
8000bbc8:	08 18       	sub	r8,r4
8000bbca:	83 28       	st.w	r1[0x8],r8
8000bbcc:	c6 b0       	breq	8000bca2 <__sfvwrite_r+0x28e>
8000bbce:	08 16       	sub	r6,r4
8000bbd0:	08 03       	add	r3,r4
8000bbd2:	c7 1b       	rjmp	8000bab4 <__sfvwrite_r+0xa0>
8000bbd4:	60 03       	ld.w	r3,r0[0x0]
8000bbd6:	60 11       	ld.w	r1,r0[0x4]
8000bbd8:	30 08       	mov	r8,0
8000bbda:	2f 80       	sub	r0,-8
8000bbdc:	50 08       	stdsp	sp[0x0],r8
8000bbde:	58 01       	cp.w	r1,0
8000bbe0:	cf a0       	breq	8000bbd4 <__sfvwrite_r+0x1c0>
8000bbe2:	40 0a       	lddsp	r10,sp[0x0]
8000bbe4:	58 0a       	cp.w	r10,0
8000bbe6:	c1 41       	brne	8000bc0e <__sfvwrite_r+0x1fa>
8000bbe8:	e2 c6 ff ff 	sub	r6,r1,-1
8000bbec:	02 9a       	mov	r10,r1
8000bbee:	30 ab       	mov	r11,10
8000bbf0:	06 9c       	mov	r12,r3
8000bbf2:	ce 3c       	rcall	8000bdb8 <memchr>
8000bbf4:	f8 c8 ff ff 	sub	r8,r12,-1
8000bbf8:	58 0c       	cp.w	r12,0
8000bbfa:	f1 d3 e1 16 	subne	r6,r8,r3
8000bbfe:	f9 b9 01 01 	movne	r9,1
8000bc02:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bc06:	f9 b8 00 01 	moveq	r8,1
8000bc0a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bc0e:	02 36       	cp.w	r6,r1
8000bc10:	ec 04 17 80 	movls	r4,r6
8000bc14:	e2 04 17 b0 	movhi	r4,r1
8000bc18:	6e 59       	ld.w	r9,r7[0x14]
8000bc1a:	6e 25       	ld.w	r5,r7[0x8]
8000bc1c:	f2 05 00 05 	add	r5,r9,r5
8000bc20:	0a 34       	cp.w	r4,r5
8000bc22:	5f 9a       	srgt	r10
8000bc24:	6e 0c       	ld.w	r12,r7[0x0]
8000bc26:	6e 48       	ld.w	r8,r7[0x10]
8000bc28:	10 3c       	cp.w	r12,r8
8000bc2a:	5f b8       	srhi	r8
8000bc2c:	f5 e8 00 08 	and	r8,r10,r8
8000bc30:	30 0a       	mov	r10,0
8000bc32:	f4 08 18 00 	cp.b	r8,r10
8000bc36:	c0 d0       	breq	8000bc50 <__sfvwrite_r+0x23c>
8000bc38:	06 9b       	mov	r11,r3
8000bc3a:	0a 9a       	mov	r10,r5
8000bc3c:	cc 9c       	rcall	8000bdce <memmove>
8000bc3e:	6e 08       	ld.w	r8,r7[0x0]
8000bc40:	0a 08       	add	r8,r5
8000bc42:	0e 9b       	mov	r11,r7
8000bc44:	8f 08       	st.w	r7[0x0],r8
8000bc46:	40 1c       	lddsp	r12,sp[0x4]
8000bc48:	fe b0 fc ae 	rcall	8000b5a4 <_fflush_r>
8000bc4c:	c1 70       	breq	8000bc7a <__sfvwrite_r+0x266>
8000bc4e:	c2 58       	rjmp	8000bc98 <__sfvwrite_r+0x284>
8000bc50:	12 34       	cp.w	r4,r9
8000bc52:	c0 a5       	brlt	8000bc66 <__sfvwrite_r+0x252>
8000bc54:	6e a8       	ld.w	r8,r7[0x28]
8000bc56:	06 9a       	mov	r10,r3
8000bc58:	6e 8b       	ld.w	r11,r7[0x20]
8000bc5a:	40 1c       	lddsp	r12,sp[0x4]
8000bc5c:	5d 18       	icall	r8
8000bc5e:	18 95       	mov	r5,r12
8000bc60:	e0 89 00 0d 	brgt	8000bc7a <__sfvwrite_r+0x266>
8000bc64:	c1 a8       	rjmp	8000bc98 <__sfvwrite_r+0x284>
8000bc66:	08 9a       	mov	r10,r4
8000bc68:	06 9b       	mov	r11,r3
8000bc6a:	cb 2c       	rcall	8000bdce <memmove>
8000bc6c:	6e 08       	ld.w	r8,r7[0x0]
8000bc6e:	08 08       	add	r8,r4
8000bc70:	08 95       	mov	r5,r4
8000bc72:	8f 08       	st.w	r7[0x0],r8
8000bc74:	6e 28       	ld.w	r8,r7[0x8]
8000bc76:	08 18       	sub	r8,r4
8000bc78:	8f 28       	st.w	r7[0x8],r8
8000bc7a:	0a 16       	sub	r6,r5
8000bc7c:	c0 71       	brne	8000bc8a <__sfvwrite_r+0x276>
8000bc7e:	0e 9b       	mov	r11,r7
8000bc80:	40 1c       	lddsp	r12,sp[0x4]
8000bc82:	fe b0 fc 91 	rcall	8000b5a4 <_fflush_r>
8000bc86:	c0 91       	brne	8000bc98 <__sfvwrite_r+0x284>
8000bc88:	50 06       	stdsp	sp[0x0],r6
8000bc8a:	64 28       	ld.w	r8,r2[0x8]
8000bc8c:	0a 18       	sub	r8,r5
8000bc8e:	85 28       	st.w	r2[0x8],r8
8000bc90:	c0 90       	breq	8000bca2 <__sfvwrite_r+0x28e>
8000bc92:	0a 11       	sub	r1,r5
8000bc94:	0a 03       	add	r3,r5
8000bc96:	ca 4b       	rjmp	8000bbde <__sfvwrite_r+0x1ca>
8000bc98:	8e 68       	ld.sh	r8,r7[0xc]
8000bc9a:	a7 a8       	sbr	r8,0x6
8000bc9c:	ae 68       	st.h	r7[0xc],r8
8000bc9e:	3f fc       	mov	r12,-1
8000bca0:	c0 28       	rjmp	8000bca4 <__sfvwrite_r+0x290>
8000bca2:	30 0c       	mov	r12,0
8000bca4:	2f dd       	sub	sp,-12
8000bca6:	d8 32       	popm	r0-r7,pc

8000bca8 <_fwalk>:
8000bca8:	d4 31       	pushm	r0-r7,lr
8000bcaa:	30 05       	mov	r5,0
8000bcac:	16 91       	mov	r1,r11
8000bcae:	f8 c7 ff 28 	sub	r7,r12,-216
8000bcb2:	0a 92       	mov	r2,r5
8000bcb4:	fe b0 fc fe 	rcall	8000b6b0 <__sfp_lock_acquire>
8000bcb8:	3f f3       	mov	r3,-1
8000bcba:	c1 68       	rjmp	8000bce6 <_fwalk+0x3e>
8000bcbc:	6e 26       	ld.w	r6,r7[0x8]
8000bcbe:	6e 14       	ld.w	r4,r7[0x4]
8000bcc0:	2f 46       	sub	r6,-12
8000bcc2:	c0 c8       	rjmp	8000bcda <_fwalk+0x32>
8000bcc4:	8c 08       	ld.sh	r8,r6[0x0]
8000bcc6:	e4 08 19 00 	cp.h	r8,r2
8000bcca:	c0 70       	breq	8000bcd8 <_fwalk+0x30>
8000bccc:	8c 18       	ld.sh	r8,r6[0x2]
8000bcce:	e6 08 19 00 	cp.h	r8,r3
8000bcd2:	c0 30       	breq	8000bcd8 <_fwalk+0x30>
8000bcd4:	5d 11       	icall	r1
8000bcd6:	18 45       	or	r5,r12
8000bcd8:	2a 46       	sub	r6,-92
8000bcda:	20 14       	sub	r4,1
8000bcdc:	ec cc 00 0c 	sub	r12,r6,12
8000bce0:	58 04       	cp.w	r4,0
8000bce2:	cf 14       	brge	8000bcc4 <_fwalk+0x1c>
8000bce4:	6e 07       	ld.w	r7,r7[0x0]
8000bce6:	58 07       	cp.w	r7,0
8000bce8:	ce a1       	brne	8000bcbc <_fwalk+0x14>
8000bcea:	fe b0 fc e4 	rcall	8000b6b2 <__sfp_lock_release>
8000bcee:	0a 9c       	mov	r12,r5
8000bcf0:	d8 32       	popm	r0-r7,pc
8000bcf2:	d7 03       	nop

8000bcf4 <_localeconv_r>:
8000bcf4:	fe cc d2 dc 	sub	r12,pc,-11556
8000bcf8:	5e fc       	retal	r12
8000bcfa:	d7 03       	nop

8000bcfc <__smakebuf_r>:
8000bcfc:	d4 21       	pushm	r4-r7,lr
8000bcfe:	20 fd       	sub	sp,60
8000bd00:	96 68       	ld.sh	r8,r11[0xc]
8000bd02:	16 97       	mov	r7,r11
8000bd04:	18 96       	mov	r6,r12
8000bd06:	e2 18 00 02 	andl	r8,0x2,COH
8000bd0a:	c3 d1       	brne	8000bd84 <__smakebuf_r+0x88>
8000bd0c:	96 7b       	ld.sh	r11,r11[0xe]
8000bd0e:	f0 0b 19 00 	cp.h	r11,r8
8000bd12:	c0 55       	brlt	8000bd1c <__smakebuf_r+0x20>
8000bd14:	1a 9a       	mov	r10,sp
8000bd16:	e0 a0 04 81 	rcall	8000c618 <_fstat_r>
8000bd1a:	c0 f4       	brge	8000bd38 <__smakebuf_r+0x3c>
8000bd1c:	8e 65       	ld.sh	r5,r7[0xc]
8000bd1e:	0a 98       	mov	r8,r5
8000bd20:	ab b8       	sbr	r8,0xb
8000bd22:	e2 15 00 80 	andl	r5,0x80,COH
8000bd26:	ae 68       	st.h	r7[0xc],r8
8000bd28:	30 04       	mov	r4,0
8000bd2a:	e0 68 04 00 	mov	r8,1024
8000bd2e:	f9 b5 01 40 	movne	r5,64
8000bd32:	f0 05 17 00 	moveq	r5,r8
8000bd36:	c1 c8       	rjmp	8000bd6e <__smakebuf_r+0x72>
8000bd38:	40 18       	lddsp	r8,sp[0x4]
8000bd3a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000bd3e:	e0 48 20 00 	cp.w	r8,8192
8000bd42:	5f 04       	sreq	r4
8000bd44:	e0 48 80 00 	cp.w	r8,32768
8000bd48:	c0 e1       	brne	8000bd64 <__smakebuf_r+0x68>
8000bd4a:	6e b9       	ld.w	r9,r7[0x2c]
8000bd4c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000bd50:	10 39       	cp.w	r9,r8
8000bd52:	c0 91       	brne	8000bd64 <__smakebuf_r+0x68>
8000bd54:	8e 68       	ld.sh	r8,r7[0xc]
8000bd56:	e0 65 04 00 	mov	r5,1024
8000bd5a:	ab a8       	sbr	r8,0xa
8000bd5c:	ef 45 00 50 	st.w	r7[80],r5
8000bd60:	ae 68       	st.h	r7[0xc],r8
8000bd62:	c0 68       	rjmp	8000bd6e <__smakebuf_r+0x72>
8000bd64:	8e 68       	ld.sh	r8,r7[0xc]
8000bd66:	e0 65 04 00 	mov	r5,1024
8000bd6a:	ab b8       	sbr	r8,0xb
8000bd6c:	ae 68       	st.h	r7[0xc],r8
8000bd6e:	0a 9b       	mov	r11,r5
8000bd70:	0c 9c       	mov	r12,r6
8000bd72:	fe b0 df 23 	rcall	80007bb8 <_malloc_r>
8000bd76:	8e 68       	ld.sh	r8,r7[0xc]
8000bd78:	c0 d1       	brne	8000bd92 <__smakebuf_r+0x96>
8000bd7a:	ed b8 00 09 	bld	r8,0x9
8000bd7e:	c1 b0       	breq	8000bdb4 <__smakebuf_r+0xb8>
8000bd80:	a1 b8       	sbr	r8,0x1
8000bd82:	ae 68       	st.h	r7[0xc],r8
8000bd84:	ee c8 ff b9 	sub	r8,r7,-71
8000bd88:	8f 48       	st.w	r7[0x10],r8
8000bd8a:	8f 08       	st.w	r7[0x0],r8
8000bd8c:	30 18       	mov	r8,1
8000bd8e:	8f 58       	st.w	r7[0x14],r8
8000bd90:	c1 28       	rjmp	8000bdb4 <__smakebuf_r+0xb8>
8000bd92:	a7 b8       	sbr	r8,0x7
8000bd94:	8f 4c       	st.w	r7[0x10],r12
8000bd96:	ae 68       	st.h	r7[0xc],r8
8000bd98:	8f 55       	st.w	r7[0x14],r5
8000bd9a:	fe c8 06 e6 	sub	r8,pc,1766
8000bd9e:	8f 0c       	st.w	r7[0x0],r12
8000bda0:	8d a8       	st.w	r6[0x28],r8
8000bda2:	58 04       	cp.w	r4,0
8000bda4:	c0 80       	breq	8000bdb4 <__smakebuf_r+0xb8>
8000bda6:	8e 7c       	ld.sh	r12,r7[0xe]
8000bda8:	fe b0 e3 94 	rcall	800084d0 <isatty>
8000bdac:	c0 40       	breq	8000bdb4 <__smakebuf_r+0xb8>
8000bdae:	8e 68       	ld.sh	r8,r7[0xc]
8000bdb0:	a1 a8       	sbr	r8,0x0
8000bdb2:	ae 68       	st.h	r7[0xc],r8
8000bdb4:	2f 1d       	sub	sp,-60
8000bdb6:	d8 22       	popm	r4-r7,pc

8000bdb8 <memchr>:
8000bdb8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000bdbc:	c0 68       	rjmp	8000bdc8 <memchr+0x10>
8000bdbe:	20 1a       	sub	r10,1
8000bdc0:	19 88       	ld.ub	r8,r12[0x0]
8000bdc2:	16 38       	cp.w	r8,r11
8000bdc4:	5e 0c       	reteq	r12
8000bdc6:	2f fc       	sub	r12,-1
8000bdc8:	58 0a       	cp.w	r10,0
8000bdca:	cf a1       	brne	8000bdbe <memchr+0x6>
8000bdcc:	5e fa       	retal	r10

8000bdce <memmove>:
8000bdce:	d4 01       	pushm	lr
8000bdd0:	18 3b       	cp.w	r11,r12
8000bdd2:	c1 92       	brcc	8000be04 <memmove+0x36>
8000bdd4:	f6 0a 00 09 	add	r9,r11,r10
8000bdd8:	12 3c       	cp.w	r12,r9
8000bdda:	c1 52       	brcc	8000be04 <memmove+0x36>
8000bddc:	f8 0a 00 0b 	add	r11,r12,r10
8000bde0:	30 08       	mov	r8,0
8000bde2:	c0 68       	rjmp	8000bdee <memmove+0x20>
8000bde4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000bde8:	20 1a       	sub	r10,1
8000bdea:	f6 08 0b 0e 	st.b	r11[r8],lr
8000bdee:	20 18       	sub	r8,1
8000bdf0:	58 0a       	cp.w	r10,0
8000bdf2:	cf 91       	brne	8000bde4 <memmove+0x16>
8000bdf4:	d8 02       	popm	pc
8000bdf6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000bdfa:	20 1a       	sub	r10,1
8000bdfc:	f8 08 0b 09 	st.b	r12[r8],r9
8000be00:	2f f8       	sub	r8,-1
8000be02:	c0 28       	rjmp	8000be06 <memmove+0x38>
8000be04:	30 08       	mov	r8,0
8000be06:	58 0a       	cp.w	r10,0
8000be08:	cf 71       	brne	8000bdf6 <memmove+0x28>
8000be0a:	d8 02       	popm	pc

8000be0c <__hi0bits>:
8000be0c:	18 98       	mov	r8,r12
8000be0e:	e0 1c 00 00 	andl	r12,0x0
8000be12:	f0 09 15 10 	lsl	r9,r8,0x10
8000be16:	58 0c       	cp.w	r12,0
8000be18:	f2 08 17 00 	moveq	r8,r9
8000be1c:	f9 bc 00 10 	moveq	r12,16
8000be20:	f9 bc 01 00 	movne	r12,0
8000be24:	10 9a       	mov	r10,r8
8000be26:	f0 09 15 08 	lsl	r9,r8,0x8
8000be2a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000be2e:	f7 bc 00 f8 	subeq	r12,-8
8000be32:	f2 08 17 00 	moveq	r8,r9
8000be36:	10 9a       	mov	r10,r8
8000be38:	f0 09 15 04 	lsl	r9,r8,0x4
8000be3c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000be40:	f7 bc 00 fc 	subeq	r12,-4
8000be44:	f2 08 17 00 	moveq	r8,r9
8000be48:	10 9a       	mov	r10,r8
8000be4a:	f0 09 15 02 	lsl	r9,r8,0x2
8000be4e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000be52:	f7 bc 00 fe 	subeq	r12,-2
8000be56:	f2 08 17 00 	moveq	r8,r9
8000be5a:	58 08       	cp.w	r8,0
8000be5c:	5e 5c       	retlt	r12
8000be5e:	ed b8 00 1e 	bld	r8,0x1e
8000be62:	f9 bc 01 20 	movne	r12,32
8000be66:	f7 bc 00 ff 	subeq	r12,-1
8000be6a:	5e fc       	retal	r12

8000be6c <__lo0bits>:
8000be6c:	18 99       	mov	r9,r12
8000be6e:	78 08       	ld.w	r8,r12[0x0]
8000be70:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000be74:	c1 50       	breq	8000be9e <__lo0bits+0x32>
8000be76:	ed b8 00 00 	bld	r8,0x0
8000be7a:	c0 21       	brne	8000be7e <__lo0bits+0x12>
8000be7c:	5e fd       	retal	0
8000be7e:	10 9b       	mov	r11,r8
8000be80:	f0 0a 16 01 	lsr	r10,r8,0x1
8000be84:	e2 1b 00 02 	andl	r11,0x2,COH
8000be88:	a3 88       	lsr	r8,0x2
8000be8a:	58 0b       	cp.w	r11,0
8000be8c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000be90:	f9 bc 01 01 	movne	r12,1
8000be94:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000be98:	f9 bc 00 02 	moveq	r12,2
8000be9c:	5e fc       	retal	r12
8000be9e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bea2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bea6:	58 0a       	cp.w	r10,0
8000bea8:	f6 08 17 00 	moveq	r8,r11
8000beac:	f9 bc 00 10 	moveq	r12,16
8000beb0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000beb4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000beb8:	58 0b       	cp.w	r11,0
8000beba:	f7 bc 00 f8 	subeq	r12,-8
8000bebe:	f4 08 17 00 	moveq	r8,r10
8000bec2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bec6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000beca:	58 0b       	cp.w	r11,0
8000becc:	f7 bc 00 fc 	subeq	r12,-4
8000bed0:	f4 08 17 00 	moveq	r8,r10
8000bed4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bed8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bedc:	58 0b       	cp.w	r11,0
8000bede:	f7 bc 00 fe 	subeq	r12,-2
8000bee2:	f4 08 17 00 	moveq	r8,r10
8000bee6:	ed b8 00 00 	bld	r8,0x0
8000beea:	c0 60       	breq	8000bef6 <__lo0bits+0x8a>
8000beec:	a1 98       	lsr	r8,0x1
8000beee:	c0 31       	brne	8000bef4 <__lo0bits+0x88>
8000bef0:	32 0c       	mov	r12,32
8000bef2:	5e fc       	retal	r12
8000bef4:	2f fc       	sub	r12,-1
8000bef6:	93 08       	st.w	r9[0x0],r8
8000bef8:	5e fc       	retal	r12

8000befa <__mcmp>:
8000befa:	d4 01       	pushm	lr
8000befc:	18 98       	mov	r8,r12
8000befe:	76 49       	ld.w	r9,r11[0x10]
8000bf00:	78 4c       	ld.w	r12,r12[0x10]
8000bf02:	12 1c       	sub	r12,r9
8000bf04:	c1 31       	brne	8000bf2a <__mcmp+0x30>
8000bf06:	2f b9       	sub	r9,-5
8000bf08:	a3 69       	lsl	r9,0x2
8000bf0a:	12 0b       	add	r11,r9
8000bf0c:	f0 09 00 09 	add	r9,r8,r9
8000bf10:	2e c8       	sub	r8,-20
8000bf12:	13 4e       	ld.w	lr,--r9
8000bf14:	17 4a       	ld.w	r10,--r11
8000bf16:	14 3e       	cp.w	lr,r10
8000bf18:	c0 60       	breq	8000bf24 <__mcmp+0x2a>
8000bf1a:	f9 bc 03 ff 	movlo	r12,-1
8000bf1e:	f9 bc 02 01 	movhs	r12,1
8000bf22:	d8 02       	popm	pc
8000bf24:	10 39       	cp.w	r9,r8
8000bf26:	fe 9b ff f6 	brhi	8000bf12 <__mcmp+0x18>
8000bf2a:	d8 02       	popm	pc

8000bf2c <_Bfree>:
8000bf2c:	d4 21       	pushm	r4-r7,lr
8000bf2e:	18 97       	mov	r7,r12
8000bf30:	16 95       	mov	r5,r11
8000bf32:	78 96       	ld.w	r6,r12[0x24]
8000bf34:	58 06       	cp.w	r6,0
8000bf36:	c0 91       	brne	8000bf48 <_Bfree+0x1c>
8000bf38:	31 0c       	mov	r12,16
8000bf3a:	fe b0 de 37 	rcall	80007ba8 <malloc>
8000bf3e:	99 36       	st.w	r12[0xc],r6
8000bf40:	8f 9c       	st.w	r7[0x24],r12
8000bf42:	99 16       	st.w	r12[0x4],r6
8000bf44:	99 26       	st.w	r12[0x8],r6
8000bf46:	99 06       	st.w	r12[0x0],r6
8000bf48:	58 05       	cp.w	r5,0
8000bf4a:	c0 90       	breq	8000bf5c <_Bfree+0x30>
8000bf4c:	6a 19       	ld.w	r9,r5[0x4]
8000bf4e:	6e 98       	ld.w	r8,r7[0x24]
8000bf50:	70 38       	ld.w	r8,r8[0xc]
8000bf52:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000bf56:	8b 0a       	st.w	r5[0x0],r10
8000bf58:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000bf5c:	d8 22       	popm	r4-r7,pc
8000bf5e:	d7 03       	nop

8000bf60 <_Balloc>:
8000bf60:	d4 21       	pushm	r4-r7,lr
8000bf62:	18 97       	mov	r7,r12
8000bf64:	16 96       	mov	r6,r11
8000bf66:	78 95       	ld.w	r5,r12[0x24]
8000bf68:	58 05       	cp.w	r5,0
8000bf6a:	c0 91       	brne	8000bf7c <_Balloc+0x1c>
8000bf6c:	31 0c       	mov	r12,16
8000bf6e:	fe b0 de 1d 	rcall	80007ba8 <malloc>
8000bf72:	99 35       	st.w	r12[0xc],r5
8000bf74:	8f 9c       	st.w	r7[0x24],r12
8000bf76:	99 15       	st.w	r12[0x4],r5
8000bf78:	99 25       	st.w	r12[0x8],r5
8000bf7a:	99 05       	st.w	r12[0x0],r5
8000bf7c:	6e 95       	ld.w	r5,r7[0x24]
8000bf7e:	6a 38       	ld.w	r8,r5[0xc]
8000bf80:	58 08       	cp.w	r8,0
8000bf82:	c0 b1       	brne	8000bf98 <_Balloc+0x38>
8000bf84:	31 0a       	mov	r10,16
8000bf86:	30 4b       	mov	r11,4
8000bf88:	0e 9c       	mov	r12,r7
8000bf8a:	e0 a0 02 a7 	rcall	8000c4d8 <_calloc_r>
8000bf8e:	8b 3c       	st.w	r5[0xc],r12
8000bf90:	6e 98       	ld.w	r8,r7[0x24]
8000bf92:	70 3c       	ld.w	r12,r8[0xc]
8000bf94:	58 0c       	cp.w	r12,0
8000bf96:	c1 b0       	breq	8000bfcc <_Balloc+0x6c>
8000bf98:	6e 98       	ld.w	r8,r7[0x24]
8000bf9a:	70 38       	ld.w	r8,r8[0xc]
8000bf9c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000bfa0:	70 0c       	ld.w	r12,r8[0x0]
8000bfa2:	58 0c       	cp.w	r12,0
8000bfa4:	c0 40       	breq	8000bfac <_Balloc+0x4c>
8000bfa6:	78 09       	ld.w	r9,r12[0x0]
8000bfa8:	91 09       	st.w	r8[0x0],r9
8000bfaa:	c0 e8       	rjmp	8000bfc6 <_Balloc+0x66>
8000bfac:	0e 9c       	mov	r12,r7
8000bfae:	30 17       	mov	r7,1
8000bfb0:	0e 9b       	mov	r11,r7
8000bfb2:	ee 06 09 47 	lsl	r7,r7,r6
8000bfb6:	ee ca ff fb 	sub	r10,r7,-5
8000bfba:	a3 6a       	lsl	r10,0x2
8000bfbc:	e0 a0 02 8e 	rcall	8000c4d8 <_calloc_r>
8000bfc0:	c0 60       	breq	8000bfcc <_Balloc+0x6c>
8000bfc2:	99 16       	st.w	r12[0x4],r6
8000bfc4:	99 27       	st.w	r12[0x8],r7
8000bfc6:	30 08       	mov	r8,0
8000bfc8:	99 38       	st.w	r12[0xc],r8
8000bfca:	99 48       	st.w	r12[0x10],r8
8000bfcc:	d8 22       	popm	r4-r7,pc
8000bfce:	d7 03       	nop

8000bfd0 <__d2b>:
8000bfd0:	d4 31       	pushm	r0-r7,lr
8000bfd2:	20 2d       	sub	sp,8
8000bfd4:	16 93       	mov	r3,r11
8000bfd6:	12 96       	mov	r6,r9
8000bfd8:	10 95       	mov	r5,r8
8000bfda:	14 92       	mov	r2,r10
8000bfdc:	30 1b       	mov	r11,1
8000bfde:	cc 1f       	rcall	8000bf60 <_Balloc>
8000bfe0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000bfe4:	50 09       	stdsp	sp[0x0],r9
8000bfe6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000bfea:	b5 a9       	sbr	r9,0x14
8000bfec:	f0 01 16 14 	lsr	r1,r8,0x14
8000bff0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bff4:	18 94       	mov	r4,r12
8000bff6:	58 02       	cp.w	r2,0
8000bff8:	c1 d0       	breq	8000c032 <__d2b+0x62>
8000bffa:	fa cc ff f8 	sub	r12,sp,-8
8000bffe:	18 d2       	st.w	--r12,r2
8000c000:	c3 6f       	rcall	8000be6c <__lo0bits>
8000c002:	40 18       	lddsp	r8,sp[0x4]
8000c004:	c0 d0       	breq	8000c01e <__d2b+0x4e>
8000c006:	40 09       	lddsp	r9,sp[0x0]
8000c008:	f8 0a 11 20 	rsub	r10,r12,32
8000c00c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c010:	f5 e8 10 08 	or	r8,r10,r8
8000c014:	89 58       	st.w	r4[0x14],r8
8000c016:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c01a:	50 09       	stdsp	sp[0x0],r9
8000c01c:	c0 28       	rjmp	8000c020 <__d2b+0x50>
8000c01e:	89 58       	st.w	r4[0x14],r8
8000c020:	40 08       	lddsp	r8,sp[0x0]
8000c022:	58 08       	cp.w	r8,0
8000c024:	f9 b3 01 02 	movne	r3,2
8000c028:	f9 b3 00 01 	moveq	r3,1
8000c02c:	89 68       	st.w	r4[0x18],r8
8000c02e:	89 43       	st.w	r4[0x10],r3
8000c030:	c0 88       	rjmp	8000c040 <__d2b+0x70>
8000c032:	1a 9c       	mov	r12,sp
8000c034:	c1 cf       	rcall	8000be6c <__lo0bits>
8000c036:	30 13       	mov	r3,1
8000c038:	40 08       	lddsp	r8,sp[0x0]
8000c03a:	2e 0c       	sub	r12,-32
8000c03c:	89 43       	st.w	r4[0x10],r3
8000c03e:	89 58       	st.w	r4[0x14],r8
8000c040:	58 01       	cp.w	r1,0
8000c042:	c0 90       	breq	8000c054 <__d2b+0x84>
8000c044:	e2 c1 04 33 	sub	r1,r1,1075
8000c048:	18 01       	add	r1,r12
8000c04a:	8d 01       	st.w	r6[0x0],r1
8000c04c:	f8 0c 11 35 	rsub	r12,r12,53
8000c050:	8b 0c       	st.w	r5[0x0],r12
8000c052:	c0 c8       	rjmp	8000c06a <__d2b+0x9a>
8000c054:	e6 c8 ff fc 	sub	r8,r3,-4
8000c058:	f8 cc 04 32 	sub	r12,r12,1074
8000c05c:	a5 73       	lsl	r3,0x5
8000c05e:	8d 0c       	st.w	r6[0x0],r12
8000c060:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c064:	cd 4e       	rcall	8000be0c <__hi0bits>
8000c066:	18 13       	sub	r3,r12
8000c068:	8b 03       	st.w	r5[0x0],r3
8000c06a:	08 9c       	mov	r12,r4
8000c06c:	2f ed       	sub	sp,-8
8000c06e:	d8 32       	popm	r0-r7,pc

8000c070 <__mdiff>:
8000c070:	d4 31       	pushm	r0-r7,lr
8000c072:	74 48       	ld.w	r8,r10[0x10]
8000c074:	76 45       	ld.w	r5,r11[0x10]
8000c076:	16 97       	mov	r7,r11
8000c078:	14 96       	mov	r6,r10
8000c07a:	10 15       	sub	r5,r8
8000c07c:	c1 31       	brne	8000c0a2 <__mdiff+0x32>
8000c07e:	2f b8       	sub	r8,-5
8000c080:	ee ce ff ec 	sub	lr,r7,-20
8000c084:	a3 68       	lsl	r8,0x2
8000c086:	f4 08 00 0b 	add	r11,r10,r8
8000c08a:	ee 08 00 08 	add	r8,r7,r8
8000c08e:	11 4a       	ld.w	r10,--r8
8000c090:	17 49       	ld.w	r9,--r11
8000c092:	12 3a       	cp.w	r10,r9
8000c094:	c0 30       	breq	8000c09a <__mdiff+0x2a>
8000c096:	c0 e2       	brcc	8000c0b2 <__mdiff+0x42>
8000c098:	c0 78       	rjmp	8000c0a6 <__mdiff+0x36>
8000c09a:	1c 38       	cp.w	r8,lr
8000c09c:	fe 9b ff f9 	brhi	8000c08e <__mdiff+0x1e>
8000c0a0:	c4 98       	rjmp	8000c132 <__mdiff+0xc2>
8000c0a2:	58 05       	cp.w	r5,0
8000c0a4:	c0 64       	brge	8000c0b0 <__mdiff+0x40>
8000c0a6:	0e 98       	mov	r8,r7
8000c0a8:	30 15       	mov	r5,1
8000c0aa:	0c 97       	mov	r7,r6
8000c0ac:	10 96       	mov	r6,r8
8000c0ae:	c0 28       	rjmp	8000c0b2 <__mdiff+0x42>
8000c0b0:	30 05       	mov	r5,0
8000c0b2:	6e 1b       	ld.w	r11,r7[0x4]
8000c0b4:	c5 6f       	rcall	8000bf60 <_Balloc>
8000c0b6:	6e 49       	ld.w	r9,r7[0x10]
8000c0b8:	6c 44       	ld.w	r4,r6[0x10]
8000c0ba:	99 35       	st.w	r12[0xc],r5
8000c0bc:	2f b4       	sub	r4,-5
8000c0be:	f2 c5 ff fb 	sub	r5,r9,-5
8000c0c2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c0c6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c0ca:	2e c6       	sub	r6,-20
8000c0cc:	2e c7       	sub	r7,-20
8000c0ce:	f8 c8 ff ec 	sub	r8,r12,-20
8000c0d2:	30 0a       	mov	r10,0
8000c0d4:	0f 0e       	ld.w	lr,r7++
8000c0d6:	0d 0b       	ld.w	r11,r6++
8000c0d8:	fc 02 16 10 	lsr	r2,lr,0x10
8000c0dc:	f6 03 16 10 	lsr	r3,r11,0x10
8000c0e0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c0e4:	e4 03 01 03 	sub	r3,r2,r3
8000c0e8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c0ec:	fc 0b 01 0b 	sub	r11,lr,r11
8000c0f0:	f6 0a 00 0a 	add	r10,r11,r10
8000c0f4:	b0 1a       	st.h	r8[0x2],r10
8000c0f6:	b1 4a       	asr	r10,0x10
8000c0f8:	e6 0a 00 0a 	add	r10,r3,r10
8000c0fc:	b0 0a       	st.h	r8[0x0],r10
8000c0fe:	2f c8       	sub	r8,-4
8000c100:	b1 4a       	asr	r10,0x10
8000c102:	08 36       	cp.w	r6,r4
8000c104:	ce 83       	brcs	8000c0d4 <__mdiff+0x64>
8000c106:	c0 d8       	rjmp	8000c120 <__mdiff+0xb0>
8000c108:	0f 0b       	ld.w	r11,r7++
8000c10a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c10e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c112:	16 0a       	add	r10,r11
8000c114:	b0 1a       	st.h	r8[0x2],r10
8000c116:	b1 4a       	asr	r10,0x10
8000c118:	1c 0a       	add	r10,lr
8000c11a:	b0 0a       	st.h	r8[0x0],r10
8000c11c:	2f c8       	sub	r8,-4
8000c11e:	b1 4a       	asr	r10,0x10
8000c120:	0a 37       	cp.w	r7,r5
8000c122:	cf 33       	brcs	8000c108 <__mdiff+0x98>
8000c124:	c0 28       	rjmp	8000c128 <__mdiff+0xb8>
8000c126:	20 19       	sub	r9,1
8000c128:	11 4a       	ld.w	r10,--r8
8000c12a:	58 0a       	cp.w	r10,0
8000c12c:	cf d0       	breq	8000c126 <__mdiff+0xb6>
8000c12e:	99 49       	st.w	r12[0x10],r9
8000c130:	d8 32       	popm	r0-r7,pc
8000c132:	30 0b       	mov	r11,0
8000c134:	c1 6f       	rcall	8000bf60 <_Balloc>
8000c136:	30 18       	mov	r8,1
8000c138:	99 48       	st.w	r12[0x10],r8
8000c13a:	30 08       	mov	r8,0
8000c13c:	99 58       	st.w	r12[0x14],r8
8000c13e:	d8 32       	popm	r0-r7,pc

8000c140 <__lshift>:
8000c140:	d4 31       	pushm	r0-r7,lr
8000c142:	16 97       	mov	r7,r11
8000c144:	76 46       	ld.w	r6,r11[0x10]
8000c146:	f4 02 14 05 	asr	r2,r10,0x5
8000c14a:	2f f6       	sub	r6,-1
8000c14c:	14 93       	mov	r3,r10
8000c14e:	18 94       	mov	r4,r12
8000c150:	04 06       	add	r6,r2
8000c152:	76 1b       	ld.w	r11,r11[0x4]
8000c154:	6e 28       	ld.w	r8,r7[0x8]
8000c156:	c0 38       	rjmp	8000c15c <__lshift+0x1c>
8000c158:	2f fb       	sub	r11,-1
8000c15a:	a1 78       	lsl	r8,0x1
8000c15c:	10 36       	cp.w	r6,r8
8000c15e:	fe 99 ff fd 	brgt	8000c158 <__lshift+0x18>
8000c162:	08 9c       	mov	r12,r4
8000c164:	cf ee       	rcall	8000bf60 <_Balloc>
8000c166:	30 09       	mov	r9,0
8000c168:	18 95       	mov	r5,r12
8000c16a:	f8 c8 ff ec 	sub	r8,r12,-20
8000c16e:	12 9a       	mov	r10,r9
8000c170:	c0 38       	rjmp	8000c176 <__lshift+0x36>
8000c172:	10 aa       	st.w	r8++,r10
8000c174:	2f f9       	sub	r9,-1
8000c176:	04 39       	cp.w	r9,r2
8000c178:	cf d5       	brlt	8000c172 <__lshift+0x32>
8000c17a:	6e 4b       	ld.w	r11,r7[0x10]
8000c17c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c180:	2f bb       	sub	r11,-5
8000c182:	ee c9 ff ec 	sub	r9,r7,-20
8000c186:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c18a:	58 03       	cp.w	r3,0
8000c18c:	c1 30       	breq	8000c1b2 <__lshift+0x72>
8000c18e:	e6 0c 11 20 	rsub	r12,r3,32
8000c192:	30 0a       	mov	r10,0
8000c194:	72 02       	ld.w	r2,r9[0x0]
8000c196:	e4 03 09 42 	lsl	r2,r2,r3
8000c19a:	04 4a       	or	r10,r2
8000c19c:	10 aa       	st.w	r8++,r10
8000c19e:	13 0a       	ld.w	r10,r9++
8000c1a0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c1a4:	16 39       	cp.w	r9,r11
8000c1a6:	cf 73       	brcs	8000c194 <__lshift+0x54>
8000c1a8:	91 0a       	st.w	r8[0x0],r10
8000c1aa:	58 0a       	cp.w	r10,0
8000c1ac:	c0 70       	breq	8000c1ba <__lshift+0x7a>
8000c1ae:	2f f6       	sub	r6,-1
8000c1b0:	c0 58       	rjmp	8000c1ba <__lshift+0x7a>
8000c1b2:	13 0a       	ld.w	r10,r9++
8000c1b4:	10 aa       	st.w	r8++,r10
8000c1b6:	16 39       	cp.w	r9,r11
8000c1b8:	cf d3       	brcs	8000c1b2 <__lshift+0x72>
8000c1ba:	08 9c       	mov	r12,r4
8000c1bc:	20 16       	sub	r6,1
8000c1be:	0e 9b       	mov	r11,r7
8000c1c0:	8b 46       	st.w	r5[0x10],r6
8000c1c2:	cb 5e       	rcall	8000bf2c <_Bfree>
8000c1c4:	0a 9c       	mov	r12,r5
8000c1c6:	d8 32       	popm	r0-r7,pc

8000c1c8 <__multiply>:
8000c1c8:	d4 31       	pushm	r0-r7,lr
8000c1ca:	20 2d       	sub	sp,8
8000c1cc:	76 49       	ld.w	r9,r11[0x10]
8000c1ce:	74 48       	ld.w	r8,r10[0x10]
8000c1d0:	16 96       	mov	r6,r11
8000c1d2:	14 95       	mov	r5,r10
8000c1d4:	10 39       	cp.w	r9,r8
8000c1d6:	ec 08 17 50 	movlt	r8,r6
8000c1da:	ea 06 17 50 	movlt	r6,r5
8000c1de:	f0 05 17 50 	movlt	r5,r8
8000c1e2:	6c 28       	ld.w	r8,r6[0x8]
8000c1e4:	76 43       	ld.w	r3,r11[0x10]
8000c1e6:	74 42       	ld.w	r2,r10[0x10]
8000c1e8:	76 1b       	ld.w	r11,r11[0x4]
8000c1ea:	e4 03 00 07 	add	r7,r2,r3
8000c1ee:	10 37       	cp.w	r7,r8
8000c1f0:	f7 bb 09 ff 	subgt	r11,-1
8000c1f4:	cb 6e       	rcall	8000bf60 <_Balloc>
8000c1f6:	ee c4 ff fb 	sub	r4,r7,-5
8000c1fa:	f8 c9 ff ec 	sub	r9,r12,-20
8000c1fe:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c202:	30 0a       	mov	r10,0
8000c204:	12 98       	mov	r8,r9
8000c206:	c0 28       	rjmp	8000c20a <__multiply+0x42>
8000c208:	10 aa       	st.w	r8++,r10
8000c20a:	08 38       	cp.w	r8,r4
8000c20c:	cf e3       	brcs	8000c208 <__multiply+0x40>
8000c20e:	2f b3       	sub	r3,-5
8000c210:	2f b2       	sub	r2,-5
8000c212:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c216:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c21a:	ec cb ff ec 	sub	r11,r6,-20
8000c21e:	50 12       	stdsp	sp[0x4],r2
8000c220:	ea ca ff ec 	sub	r10,r5,-20
8000c224:	c4 48       	rjmp	8000c2ac <__multiply+0xe4>
8000c226:	94 95       	ld.uh	r5,r10[0x2]
8000c228:	58 05       	cp.w	r5,0
8000c22a:	c2 00       	breq	8000c26a <__multiply+0xa2>
8000c22c:	12 98       	mov	r8,r9
8000c22e:	16 96       	mov	r6,r11
8000c230:	30 0e       	mov	lr,0
8000c232:	50 09       	stdsp	sp[0x0],r9
8000c234:	0d 02       	ld.w	r2,r6++
8000c236:	e4 00 16 10 	lsr	r0,r2,0x10
8000c23a:	70 01       	ld.w	r1,r8[0x0]
8000c23c:	70 09       	ld.w	r9,r8[0x0]
8000c23e:	b1 81       	lsr	r1,0x10
8000c240:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c244:	e0 05 03 41 	mac	r1,r0,r5
8000c248:	ab 32       	mul	r2,r5
8000c24a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c24e:	00 02       	add	r2,r0
8000c250:	e4 0e 00 0e 	add	lr,r2,lr
8000c254:	b0 1e       	st.h	r8[0x2],lr
8000c256:	b1 8e       	lsr	lr,0x10
8000c258:	1c 01       	add	r1,lr
8000c25a:	b0 01       	st.h	r8[0x0],r1
8000c25c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c260:	2f c8       	sub	r8,-4
8000c262:	06 36       	cp.w	r6,r3
8000c264:	ce 83       	brcs	8000c234 <__multiply+0x6c>
8000c266:	40 09       	lddsp	r9,sp[0x0]
8000c268:	91 0e       	st.w	r8[0x0],lr
8000c26a:	94 86       	ld.uh	r6,r10[0x0]
8000c26c:	58 06       	cp.w	r6,0
8000c26e:	c1 d0       	breq	8000c2a8 <__multiply+0xe0>
8000c270:	72 02       	ld.w	r2,r9[0x0]
8000c272:	12 98       	mov	r8,r9
8000c274:	16 9e       	mov	lr,r11
8000c276:	30 05       	mov	r5,0
8000c278:	b0 12       	st.h	r8[0x2],r2
8000c27a:	1d 01       	ld.w	r1,lr++
8000c27c:	90 82       	ld.uh	r2,r8[0x0]
8000c27e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c282:	ad 30       	mul	r0,r6
8000c284:	e0 02 00 02 	add	r2,r0,r2
8000c288:	e4 05 00 05 	add	r5,r2,r5
8000c28c:	b0 05       	st.h	r8[0x0],r5
8000c28e:	b1 85       	lsr	r5,0x10
8000c290:	b1 81       	lsr	r1,0x10
8000c292:	2f c8       	sub	r8,-4
8000c294:	ad 31       	mul	r1,r6
8000c296:	90 92       	ld.uh	r2,r8[0x2]
8000c298:	e2 02 00 02 	add	r2,r1,r2
8000c29c:	0a 02       	add	r2,r5
8000c29e:	e4 05 16 10 	lsr	r5,r2,0x10
8000c2a2:	06 3e       	cp.w	lr,r3
8000c2a4:	ce a3       	brcs	8000c278 <__multiply+0xb0>
8000c2a6:	91 02       	st.w	r8[0x0],r2
8000c2a8:	2f ca       	sub	r10,-4
8000c2aa:	2f c9       	sub	r9,-4
8000c2ac:	40 18       	lddsp	r8,sp[0x4]
8000c2ae:	10 3a       	cp.w	r10,r8
8000c2b0:	cb b3       	brcs	8000c226 <__multiply+0x5e>
8000c2b2:	c0 28       	rjmp	8000c2b6 <__multiply+0xee>
8000c2b4:	20 17       	sub	r7,1
8000c2b6:	58 07       	cp.w	r7,0
8000c2b8:	e0 8a 00 05 	brle	8000c2c2 <__multiply+0xfa>
8000c2bc:	09 48       	ld.w	r8,--r4
8000c2be:	58 08       	cp.w	r8,0
8000c2c0:	cf a0       	breq	8000c2b4 <__multiply+0xec>
8000c2c2:	99 47       	st.w	r12[0x10],r7
8000c2c4:	2f ed       	sub	sp,-8
8000c2c6:	d8 32       	popm	r0-r7,pc

8000c2c8 <__i2b>:
8000c2c8:	d4 21       	pushm	r4-r7,lr
8000c2ca:	16 97       	mov	r7,r11
8000c2cc:	30 1b       	mov	r11,1
8000c2ce:	c4 9e       	rcall	8000bf60 <_Balloc>
8000c2d0:	30 19       	mov	r9,1
8000c2d2:	99 57       	st.w	r12[0x14],r7
8000c2d4:	99 49       	st.w	r12[0x10],r9
8000c2d6:	d8 22       	popm	r4-r7,pc

8000c2d8 <__multadd>:
8000c2d8:	d4 31       	pushm	r0-r7,lr
8000c2da:	30 08       	mov	r8,0
8000c2dc:	12 95       	mov	r5,r9
8000c2de:	16 97       	mov	r7,r11
8000c2e0:	18 96       	mov	r6,r12
8000c2e2:	76 44       	ld.w	r4,r11[0x10]
8000c2e4:	f6 c9 ff ec 	sub	r9,r11,-20
8000c2e8:	72 0b       	ld.w	r11,r9[0x0]
8000c2ea:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c2ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c2f2:	f4 0c 02 4c 	mul	r12,r10,r12
8000c2f6:	f4 0b 03 45 	mac	r5,r10,r11
8000c2fa:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c2fe:	b1 85       	lsr	r5,0x10
8000c300:	18 05       	add	r5,r12
8000c302:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c306:	f8 0b 00 0b 	add	r11,r12,r11
8000c30a:	12 ab       	st.w	r9++,r11
8000c30c:	2f f8       	sub	r8,-1
8000c30e:	b1 85       	lsr	r5,0x10
8000c310:	08 38       	cp.w	r8,r4
8000c312:	ce b5       	brlt	8000c2e8 <__multadd+0x10>
8000c314:	58 05       	cp.w	r5,0
8000c316:	c1 c0       	breq	8000c34e <__multadd+0x76>
8000c318:	6e 28       	ld.w	r8,r7[0x8]
8000c31a:	10 34       	cp.w	r4,r8
8000c31c:	c1 35       	brlt	8000c342 <__multadd+0x6a>
8000c31e:	6e 1b       	ld.w	r11,r7[0x4]
8000c320:	0c 9c       	mov	r12,r6
8000c322:	2f fb       	sub	r11,-1
8000c324:	c1 ee       	rcall	8000bf60 <_Balloc>
8000c326:	6e 4a       	ld.w	r10,r7[0x10]
8000c328:	ee cb ff f4 	sub	r11,r7,-12
8000c32c:	18 93       	mov	r3,r12
8000c32e:	2f ea       	sub	r10,-2
8000c330:	2f 4c       	sub	r12,-12
8000c332:	a3 6a       	lsl	r10,0x2
8000c334:	fe b0 de 71 	rcall	80008016 <memcpy>
8000c338:	0e 9b       	mov	r11,r7
8000c33a:	0c 9c       	mov	r12,r6
8000c33c:	fe b0 fd f8 	rcall	8000bf2c <_Bfree>
8000c340:	06 97       	mov	r7,r3
8000c342:	e8 c8 ff ff 	sub	r8,r4,-1
8000c346:	2f b4       	sub	r4,-5
8000c348:	8f 48       	st.w	r7[0x10],r8
8000c34a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c34e:	0e 9c       	mov	r12,r7
8000c350:	d8 32       	popm	r0-r7,pc
8000c352:	d7 03       	nop

8000c354 <__pow5mult>:
8000c354:	d4 31       	pushm	r0-r7,lr
8000c356:	14 96       	mov	r6,r10
8000c358:	18 97       	mov	r7,r12
8000c35a:	16 94       	mov	r4,r11
8000c35c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c360:	c0 90       	breq	8000c372 <__pow5mult+0x1e>
8000c362:	20 18       	sub	r8,1
8000c364:	fe c9 d9 10 	sub	r9,pc,-9968
8000c368:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c36c:	30 09       	mov	r9,0
8000c36e:	cb 5f       	rcall	8000c2d8 <__multadd>
8000c370:	18 94       	mov	r4,r12
8000c372:	a3 46       	asr	r6,0x2
8000c374:	c3 40       	breq	8000c3dc <__pow5mult+0x88>
8000c376:	6e 95       	ld.w	r5,r7[0x24]
8000c378:	58 05       	cp.w	r5,0
8000c37a:	c0 91       	brne	8000c38c <__pow5mult+0x38>
8000c37c:	31 0c       	mov	r12,16
8000c37e:	fe b0 dc 15 	rcall	80007ba8 <malloc>
8000c382:	99 35       	st.w	r12[0xc],r5
8000c384:	8f 9c       	st.w	r7[0x24],r12
8000c386:	99 15       	st.w	r12[0x4],r5
8000c388:	99 25       	st.w	r12[0x8],r5
8000c38a:	99 05       	st.w	r12[0x0],r5
8000c38c:	6e 93       	ld.w	r3,r7[0x24]
8000c38e:	66 25       	ld.w	r5,r3[0x8]
8000c390:	58 05       	cp.w	r5,0
8000c392:	c0 c1       	brne	8000c3aa <__pow5mult+0x56>
8000c394:	e0 6b 02 71 	mov	r11,625
8000c398:	0e 9c       	mov	r12,r7
8000c39a:	c9 7f       	rcall	8000c2c8 <__i2b>
8000c39c:	87 2c       	st.w	r3[0x8],r12
8000c39e:	30 08       	mov	r8,0
8000c3a0:	18 95       	mov	r5,r12
8000c3a2:	99 08       	st.w	r12[0x0],r8
8000c3a4:	c0 38       	rjmp	8000c3aa <__pow5mult+0x56>
8000c3a6:	06 9c       	mov	r12,r3
8000c3a8:	18 95       	mov	r5,r12
8000c3aa:	ed b6 00 00 	bld	r6,0x0
8000c3ae:	c0 b1       	brne	8000c3c4 <__pow5mult+0x70>
8000c3b0:	08 9b       	mov	r11,r4
8000c3b2:	0a 9a       	mov	r10,r5
8000c3b4:	0e 9c       	mov	r12,r7
8000c3b6:	c0 9f       	rcall	8000c1c8 <__multiply>
8000c3b8:	08 9b       	mov	r11,r4
8000c3ba:	18 93       	mov	r3,r12
8000c3bc:	0e 9c       	mov	r12,r7
8000c3be:	06 94       	mov	r4,r3
8000c3c0:	fe b0 fd b6 	rcall	8000bf2c <_Bfree>
8000c3c4:	a1 56       	asr	r6,0x1
8000c3c6:	c0 b0       	breq	8000c3dc <__pow5mult+0x88>
8000c3c8:	6a 03       	ld.w	r3,r5[0x0]
8000c3ca:	58 03       	cp.w	r3,0
8000c3cc:	ce d1       	brne	8000c3a6 <__pow5mult+0x52>
8000c3ce:	0a 9a       	mov	r10,r5
8000c3d0:	0a 9b       	mov	r11,r5
8000c3d2:	0e 9c       	mov	r12,r7
8000c3d4:	cf ae       	rcall	8000c1c8 <__multiply>
8000c3d6:	8b 0c       	st.w	r5[0x0],r12
8000c3d8:	99 03       	st.w	r12[0x0],r3
8000c3da:	ce 7b       	rjmp	8000c3a8 <__pow5mult+0x54>
8000c3dc:	08 9c       	mov	r12,r4
8000c3de:	d8 32       	popm	r0-r7,pc

8000c3e0 <__isinfd>:
8000c3e0:	14 98       	mov	r8,r10
8000c3e2:	fc 19 7f f0 	movh	r9,0x7ff0
8000c3e6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c3ea:	f0 0b 11 00 	rsub	r11,r8,0
8000c3ee:	f7 e8 10 08 	or	r8,r11,r8
8000c3f2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c3f6:	f2 08 01 08 	sub	r8,r9,r8
8000c3fa:	f0 0c 11 00 	rsub	r12,r8,0
8000c3fe:	f9 e8 10 08 	or	r8,r12,r8
8000c402:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c406:	2f fc       	sub	r12,-1
8000c408:	5e fc       	retal	r12

8000c40a <__isnand>:
8000c40a:	14 98       	mov	r8,r10
8000c40c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c410:	f0 0c 11 00 	rsub	r12,r8,0
8000c414:	10 4c       	or	r12,r8
8000c416:	fc 18 7f f0 	movh	r8,0x7ff0
8000c41a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c41e:	f0 0c 01 0c 	sub	r12,r8,r12
8000c422:	bf 9c       	lsr	r12,0x1f
8000c424:	5e fc       	retal	r12
8000c426:	d7 03       	nop

8000c428 <__sclose>:
8000c428:	d4 01       	pushm	lr
8000c42a:	96 7b       	ld.sh	r11,r11[0xe]
8000c42c:	c8 2c       	rcall	8000c530 <_close_r>
8000c42e:	d8 02       	popm	pc

8000c430 <__sseek>:
8000c430:	d4 21       	pushm	r4-r7,lr
8000c432:	16 97       	mov	r7,r11
8000c434:	96 7b       	ld.sh	r11,r11[0xe]
8000c436:	c0 3d       	rcall	8000c63c <_lseek_r>
8000c438:	8e 68       	ld.sh	r8,r7[0xc]
8000c43a:	10 99       	mov	r9,r8
8000c43c:	ad c8       	cbr	r8,0xc
8000c43e:	ad a9       	sbr	r9,0xc
8000c440:	5b fc       	cp.w	r12,-1
8000c442:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c446:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c44a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c44e:	d8 22       	popm	r4-r7,pc

8000c450 <__swrite>:
8000c450:	d4 21       	pushm	r4-r7,lr
8000c452:	96 68       	ld.sh	r8,r11[0xc]
8000c454:	16 97       	mov	r7,r11
8000c456:	14 95       	mov	r5,r10
8000c458:	12 94       	mov	r4,r9
8000c45a:	e2 18 01 00 	andl	r8,0x100,COH
8000c45e:	18 96       	mov	r6,r12
8000c460:	c0 50       	breq	8000c46a <__swrite+0x1a>
8000c462:	30 29       	mov	r9,2
8000c464:	30 0a       	mov	r10,0
8000c466:	96 7b       	ld.sh	r11,r11[0xe]
8000c468:	ce ac       	rcall	8000c63c <_lseek_r>
8000c46a:	8e 68       	ld.sh	r8,r7[0xc]
8000c46c:	ad c8       	cbr	r8,0xc
8000c46e:	08 99       	mov	r9,r4
8000c470:	0a 9a       	mov	r10,r5
8000c472:	8e 7b       	ld.sh	r11,r7[0xe]
8000c474:	0c 9c       	mov	r12,r6
8000c476:	ae 68       	st.h	r7[0xc],r8
8000c478:	c1 cc       	rcall	8000c4b0 <_write_r>
8000c47a:	d8 22       	popm	r4-r7,pc

8000c47c <__sread>:
8000c47c:	d4 21       	pushm	r4-r7,lr
8000c47e:	16 97       	mov	r7,r11
8000c480:	96 7b       	ld.sh	r11,r11[0xe]
8000c482:	cf 1c       	rcall	8000c664 <_read_r>
8000c484:	c0 65       	brlt	8000c490 <__sread+0x14>
8000c486:	6f 58       	ld.w	r8,r7[0x54]
8000c488:	18 08       	add	r8,r12
8000c48a:	ef 48 00 54 	st.w	r7[84],r8
8000c48e:	d8 22       	popm	r4-r7,pc
8000c490:	8e 68       	ld.sh	r8,r7[0xc]
8000c492:	ad c8       	cbr	r8,0xc
8000c494:	ae 68       	st.h	r7[0xc],r8
8000c496:	d8 22       	popm	r4-r7,pc

8000c498 <strlen>:
8000c498:	30 09       	mov	r9,0
8000c49a:	18 98       	mov	r8,r12
8000c49c:	c0 28       	rjmp	8000c4a0 <strlen+0x8>
8000c49e:	2f f8       	sub	r8,-1
8000c4a0:	11 8a       	ld.ub	r10,r8[0x0]
8000c4a2:	f2 0a 18 00 	cp.b	r10,r9
8000c4a6:	cf c1       	brne	8000c49e <strlen+0x6>
8000c4a8:	f0 0c 01 0c 	sub	r12,r8,r12
8000c4ac:	5e fc       	retal	r12
8000c4ae:	d7 03       	nop

8000c4b0 <_write_r>:
8000c4b0:	d4 21       	pushm	r4-r7,lr
8000c4b2:	16 98       	mov	r8,r11
8000c4b4:	18 97       	mov	r7,r12
8000c4b6:	10 9c       	mov	r12,r8
8000c4b8:	30 08       	mov	r8,0
8000c4ba:	14 9b       	mov	r11,r10
8000c4bc:	e0 66 54 24 	mov	r6,21540
8000c4c0:	12 9a       	mov	r10,r9
8000c4c2:	8d 08       	st.w	r6[0x0],r8
8000c4c4:	fe b0 d1 5a 	rcall	80006778 <_write>
8000c4c8:	5b fc       	cp.w	r12,-1
8000c4ca:	c0 51       	brne	8000c4d4 <_write_r+0x24>
8000c4cc:	6c 08       	ld.w	r8,r6[0x0]
8000c4ce:	58 08       	cp.w	r8,0
8000c4d0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c4d4:	d8 22       	popm	r4-r7,pc
8000c4d6:	d7 03       	nop

8000c4d8 <_calloc_r>:
8000c4d8:	d4 21       	pushm	r4-r7,lr
8000c4da:	f4 0b 02 4b 	mul	r11,r10,r11
8000c4de:	fe b0 db 6d 	rcall	80007bb8 <_malloc_r>
8000c4e2:	18 97       	mov	r7,r12
8000c4e4:	c2 30       	breq	8000c52a <_calloc_r+0x52>
8000c4e6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c4ea:	e0 1a ff fc 	andl	r10,0xfffc
8000c4ee:	20 4a       	sub	r10,4
8000c4f0:	e0 4a 00 24 	cp.w	r10,36
8000c4f4:	e0 8b 00 18 	brhi	8000c524 <_calloc_r+0x4c>
8000c4f8:	18 98       	mov	r8,r12
8000c4fa:	59 3a       	cp.w	r10,19
8000c4fc:	e0 88 00 0f 	brls	8000c51a <_calloc_r+0x42>
8000c500:	30 09       	mov	r9,0
8000c502:	10 a9       	st.w	r8++,r9
8000c504:	10 a9       	st.w	r8++,r9
8000c506:	59 ba       	cp.w	r10,27
8000c508:	e0 88 00 09 	brls	8000c51a <_calloc_r+0x42>
8000c50c:	10 a9       	st.w	r8++,r9
8000c50e:	10 a9       	st.w	r8++,r9
8000c510:	e0 4a 00 24 	cp.w	r10,36
8000c514:	c0 31       	brne	8000c51a <_calloc_r+0x42>
8000c516:	10 a9       	st.w	r8++,r9
8000c518:	10 a9       	st.w	r8++,r9
8000c51a:	30 09       	mov	r9,0
8000c51c:	10 a9       	st.w	r8++,r9
8000c51e:	91 19       	st.w	r8[0x4],r9
8000c520:	91 09       	st.w	r8[0x0],r9
8000c522:	c0 48       	rjmp	8000c52a <_calloc_r+0x52>
8000c524:	30 0b       	mov	r11,0
8000c526:	fe b0 de 1c 	rcall	8000815e <memset>
8000c52a:	0e 9c       	mov	r12,r7
8000c52c:	d8 22       	popm	r4-r7,pc
8000c52e:	d7 03       	nop

8000c530 <_close_r>:
8000c530:	d4 21       	pushm	r4-r7,lr
8000c532:	30 08       	mov	r8,0
8000c534:	18 97       	mov	r7,r12
8000c536:	e0 66 54 24 	mov	r6,21540
8000c53a:	16 9c       	mov	r12,r11
8000c53c:	8d 08       	st.w	r6[0x0],r8
8000c53e:	fe b0 df b5 	rcall	800084a8 <_close>
8000c542:	5b fc       	cp.w	r12,-1
8000c544:	c0 51       	brne	8000c54e <_close_r+0x1e>
8000c546:	6c 08       	ld.w	r8,r6[0x0]
8000c548:	58 08       	cp.w	r8,0
8000c54a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c54e:	d8 22       	popm	r4-r7,pc

8000c550 <_fclose_r>:
8000c550:	d4 21       	pushm	r4-r7,lr
8000c552:	18 96       	mov	r6,r12
8000c554:	16 97       	mov	r7,r11
8000c556:	58 0b       	cp.w	r11,0
8000c558:	c0 31       	brne	8000c55e <_fclose_r+0xe>
8000c55a:	16 95       	mov	r5,r11
8000c55c:	c5 38       	rjmp	8000c602 <_fclose_r+0xb2>
8000c55e:	fe b0 f8 a9 	rcall	8000b6b0 <__sfp_lock_acquire>
8000c562:	58 06       	cp.w	r6,0
8000c564:	c0 70       	breq	8000c572 <_fclose_r+0x22>
8000c566:	6c 68       	ld.w	r8,r6[0x18]
8000c568:	58 08       	cp.w	r8,0
8000c56a:	c0 41       	brne	8000c572 <_fclose_r+0x22>
8000c56c:	0c 9c       	mov	r12,r6
8000c56e:	fe b0 f8 f3 	rcall	8000b754 <__sinit>
8000c572:	fe c8 db c2 	sub	r8,pc,-9278
8000c576:	10 37       	cp.w	r7,r8
8000c578:	c0 31       	brne	8000c57e <_fclose_r+0x2e>
8000c57a:	6c 07       	ld.w	r7,r6[0x0]
8000c57c:	c0 c8       	rjmp	8000c594 <_fclose_r+0x44>
8000c57e:	fe c8 db ae 	sub	r8,pc,-9298
8000c582:	10 37       	cp.w	r7,r8
8000c584:	c0 31       	brne	8000c58a <_fclose_r+0x3a>
8000c586:	6c 17       	ld.w	r7,r6[0x4]
8000c588:	c0 68       	rjmp	8000c594 <_fclose_r+0x44>
8000c58a:	fe c8 db 9a 	sub	r8,pc,-9318
8000c58e:	10 37       	cp.w	r7,r8
8000c590:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c594:	8e 69       	ld.sh	r9,r7[0xc]
8000c596:	30 08       	mov	r8,0
8000c598:	f0 09 19 00 	cp.h	r9,r8
8000c59c:	c0 51       	brne	8000c5a6 <_fclose_r+0x56>
8000c59e:	fe b0 f8 8a 	rcall	8000b6b2 <__sfp_lock_release>
8000c5a2:	30 05       	mov	r5,0
8000c5a4:	c2 f8       	rjmp	8000c602 <_fclose_r+0xb2>
8000c5a6:	0e 9b       	mov	r11,r7
8000c5a8:	0c 9c       	mov	r12,r6
8000c5aa:	fe b0 f7 fd 	rcall	8000b5a4 <_fflush_r>
8000c5ae:	6e c8       	ld.w	r8,r7[0x30]
8000c5b0:	18 95       	mov	r5,r12
8000c5b2:	58 08       	cp.w	r8,0
8000c5b4:	c0 60       	breq	8000c5c0 <_fclose_r+0x70>
8000c5b6:	6e 8b       	ld.w	r11,r7[0x20]
8000c5b8:	0c 9c       	mov	r12,r6
8000c5ba:	5d 18       	icall	r8
8000c5bc:	f9 b5 05 ff 	movlt	r5,-1
8000c5c0:	8e 68       	ld.sh	r8,r7[0xc]
8000c5c2:	ed b8 00 07 	bld	r8,0x7
8000c5c6:	c0 51       	brne	8000c5d0 <_fclose_r+0x80>
8000c5c8:	6e 4b       	ld.w	r11,r7[0x10]
8000c5ca:	0c 9c       	mov	r12,r6
8000c5cc:	fe b0 f9 5e 	rcall	8000b888 <_free_r>
8000c5d0:	6e db       	ld.w	r11,r7[0x34]
8000c5d2:	58 0b       	cp.w	r11,0
8000c5d4:	c0 a0       	breq	8000c5e8 <_fclose_r+0x98>
8000c5d6:	ee c8 ff bc 	sub	r8,r7,-68
8000c5da:	10 3b       	cp.w	r11,r8
8000c5dc:	c0 40       	breq	8000c5e4 <_fclose_r+0x94>
8000c5de:	0c 9c       	mov	r12,r6
8000c5e0:	fe b0 f9 54 	rcall	8000b888 <_free_r>
8000c5e4:	30 08       	mov	r8,0
8000c5e6:	8f d8       	st.w	r7[0x34],r8
8000c5e8:	6f 2b       	ld.w	r11,r7[0x48]
8000c5ea:	58 0b       	cp.w	r11,0
8000c5ec:	c0 70       	breq	8000c5fa <_fclose_r+0xaa>
8000c5ee:	0c 9c       	mov	r12,r6
8000c5f0:	fe b0 f9 4c 	rcall	8000b888 <_free_r>
8000c5f4:	30 08       	mov	r8,0
8000c5f6:	ef 48 00 48 	st.w	r7[72],r8
8000c5fa:	30 08       	mov	r8,0
8000c5fc:	ae 68       	st.h	r7[0xc],r8
8000c5fe:	fe b0 f8 5a 	rcall	8000b6b2 <__sfp_lock_release>
8000c602:	0a 9c       	mov	r12,r5
8000c604:	d8 22       	popm	r4-r7,pc
8000c606:	d7 03       	nop

8000c608 <fclose>:
8000c608:	d4 01       	pushm	lr
8000c60a:	e0 68 0a 4c 	mov	r8,2636
8000c60e:	18 9b       	mov	r11,r12
8000c610:	70 0c       	ld.w	r12,r8[0x0]
8000c612:	c9 ff       	rcall	8000c550 <_fclose_r>
8000c614:	d8 02       	popm	pc
8000c616:	d7 03       	nop

8000c618 <_fstat_r>:
8000c618:	d4 21       	pushm	r4-r7,lr
8000c61a:	16 98       	mov	r8,r11
8000c61c:	18 97       	mov	r7,r12
8000c61e:	10 9c       	mov	r12,r8
8000c620:	30 08       	mov	r8,0
8000c622:	e0 66 54 24 	mov	r6,21540
8000c626:	14 9b       	mov	r11,r10
8000c628:	8d 08       	st.w	r6[0x0],r8
8000c62a:	fe b0 df 67 	rcall	800084f8 <_fstat>
8000c62e:	5b fc       	cp.w	r12,-1
8000c630:	c0 51       	brne	8000c63a <_fstat_r+0x22>
8000c632:	6c 08       	ld.w	r8,r6[0x0]
8000c634:	58 08       	cp.w	r8,0
8000c636:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c63a:	d8 22       	popm	r4-r7,pc

8000c63c <_lseek_r>:
8000c63c:	d4 21       	pushm	r4-r7,lr
8000c63e:	16 98       	mov	r8,r11
8000c640:	18 97       	mov	r7,r12
8000c642:	10 9c       	mov	r12,r8
8000c644:	30 08       	mov	r8,0
8000c646:	14 9b       	mov	r11,r10
8000c648:	e0 66 54 24 	mov	r6,21540
8000c64c:	12 9a       	mov	r10,r9
8000c64e:	8d 08       	st.w	r6[0x0],r8
8000c650:	fe b0 df 36 	rcall	800084bc <_lseek>
8000c654:	5b fc       	cp.w	r12,-1
8000c656:	c0 51       	brne	8000c660 <_lseek_r+0x24>
8000c658:	6c 08       	ld.w	r8,r6[0x0]
8000c65a:	58 08       	cp.w	r8,0
8000c65c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c660:	d8 22       	popm	r4-r7,pc
8000c662:	d7 03       	nop

8000c664 <_read_r>:
8000c664:	d4 21       	pushm	r4-r7,lr
8000c666:	16 98       	mov	r8,r11
8000c668:	18 97       	mov	r7,r12
8000c66a:	10 9c       	mov	r12,r8
8000c66c:	30 08       	mov	r8,0
8000c66e:	14 9b       	mov	r11,r10
8000c670:	e0 66 54 24 	mov	r6,21540
8000c674:	12 9a       	mov	r10,r9
8000c676:	8d 08       	st.w	r6[0x0],r8
8000c678:	fe b0 d0 60 	rcall	80006738 <_read>
8000c67c:	5b fc       	cp.w	r12,-1
8000c67e:	c0 51       	brne	8000c688 <_read_r+0x24>
8000c680:	6c 08       	ld.w	r8,r6[0x0]
8000c682:	58 08       	cp.w	r8,0
8000c684:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c688:	d8 22       	popm	r4-r7,pc
8000c68a:	d7 03       	nop

8000c68c <__avr32_f64_mul>:
8000c68c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c690:	e0 80 00 dc 	breq	8000c848 <__avr32_f64_mul_op1_zero>
8000c694:	d4 21       	pushm	r4-r7,lr
8000c696:	f7 e9 20 0e 	eor	lr,r11,r9
8000c69a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c69e:	30 15       	mov	r5,1
8000c6a0:	c4 30       	breq	8000c726 <__avr32_f64_mul_op1_subnormal>
8000c6a2:	ab 6b       	lsl	r11,0xa
8000c6a4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c6a8:	ab 6a       	lsl	r10,0xa
8000c6aa:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c6ae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c6b2:	c5 c0       	breq	8000c76a <__avr32_f64_mul_op2_subnormal>
8000c6b4:	a1 78       	lsl	r8,0x1
8000c6b6:	5c f9       	rol	r9
8000c6b8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c6bc:	e0 47 07 ff 	cp.w	r7,2047
8000c6c0:	c7 70       	breq	8000c7ae <__avr32_f64_mul_op_nan_or_inf>
8000c6c2:	e0 46 07 ff 	cp.w	r6,2047
8000c6c6:	c7 40       	breq	8000c7ae <__avr32_f64_mul_op_nan_or_inf>
8000c6c8:	ee 06 00 0c 	add	r12,r7,r6
8000c6cc:	e0 2c 03 fe 	sub	r12,1022
8000c6d0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c6d4:	f4 09 07 44 	macu.d	r4,r10,r9
8000c6d8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c6dc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c6e0:	08 07       	add	r7,r4
8000c6e2:	f4 05 00 4a 	adc	r10,r10,r5
8000c6e6:	5c 0b       	acr	r11
8000c6e8:	ed bb 00 14 	bld	r11,0x14
8000c6ec:	c0 50       	breq	8000c6f6 <__avr32_f64_mul+0x6a>
8000c6ee:	a1 77       	lsl	r7,0x1
8000c6f0:	5c fa       	rol	r10
8000c6f2:	5c fb       	rol	r11
8000c6f4:	20 1c       	sub	r12,1
8000c6f6:	58 0c       	cp.w	r12,0
8000c6f8:	e0 8a 00 6f 	brle	8000c7d6 <__avr32_f64_mul_res_subnormal>
8000c6fc:	e0 4c 07 ff 	cp.w	r12,2047
8000c700:	e0 84 00 9c 	brge	8000c838 <__avr32_f64_mul_res_inf>
8000c704:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c708:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c70c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c710:	ee 17 80 00 	eorh	r7,0x8000
8000c714:	f1 b7 04 20 	satu	r7,0x1
8000c718:	0e 0a       	add	r10,r7
8000c71a:	5c 0b       	acr	r11
8000c71c:	ed be 00 1f 	bld	lr,0x1f
8000c720:	ef bb 00 1f 	bst	r11,0x1f
8000c724:	d8 22       	popm	r4-r7,pc

8000c726 <__avr32_f64_mul_op1_subnormal>:
8000c726:	e4 1b 00 0f 	andh	r11,0xf
8000c72a:	f4 0c 12 00 	clz	r12,r10
8000c72e:	f6 06 12 00 	clz	r6,r11
8000c732:	f7 bc 03 e1 	sublo	r12,-31
8000c736:	f8 06 17 30 	movlo	r6,r12
8000c73a:	f7 b6 02 01 	subhs	r6,1
8000c73e:	e0 46 00 20 	cp.w	r6,32
8000c742:	c0 d4       	brge	8000c75c <__avr32_f64_mul_op1_subnormal+0x36>
8000c744:	ec 0c 11 20 	rsub	r12,r6,32
8000c748:	f6 06 09 4b 	lsl	r11,r11,r6
8000c74c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c750:	18 4b       	or	r11,r12
8000c752:	f4 06 09 4a 	lsl	r10,r10,r6
8000c756:	20 b6       	sub	r6,11
8000c758:	0c 17       	sub	r7,r6
8000c75a:	ca ab       	rjmp	8000c6ae <__avr32_f64_mul+0x22>
8000c75c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c760:	c6 40       	breq	8000c828 <__avr32_f64_mul_res_zero>
8000c762:	30 0a       	mov	r10,0
8000c764:	20 b6       	sub	r6,11
8000c766:	0c 17       	sub	r7,r6
8000c768:	ca 3b       	rjmp	8000c6ae <__avr32_f64_mul+0x22>

8000c76a <__avr32_f64_mul_op2_subnormal>:
8000c76a:	e4 19 00 0f 	andh	r9,0xf
8000c76e:	f0 0c 12 00 	clz	r12,r8
8000c772:	f2 05 12 00 	clz	r5,r9
8000c776:	f7 bc 03 ea 	sublo	r12,-22
8000c77a:	f8 05 17 30 	movlo	r5,r12
8000c77e:	f7 b5 02 0a 	subhs	r5,10
8000c782:	e0 45 00 20 	cp.w	r5,32
8000c786:	c0 d4       	brge	8000c7a0 <__avr32_f64_mul_op2_subnormal+0x36>
8000c788:	ea 0c 11 20 	rsub	r12,r5,32
8000c78c:	f2 05 09 49 	lsl	r9,r9,r5
8000c790:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c794:	18 49       	or	r9,r12
8000c796:	f0 05 09 48 	lsl	r8,r8,r5
8000c79a:	20 25       	sub	r5,2
8000c79c:	0a 16       	sub	r6,r5
8000c79e:	c8 fb       	rjmp	8000c6bc <__avr32_f64_mul+0x30>
8000c7a0:	f0 05 09 49 	lsl	r9,r8,r5
8000c7a4:	c4 20       	breq	8000c828 <__avr32_f64_mul_res_zero>
8000c7a6:	30 08       	mov	r8,0
8000c7a8:	20 25       	sub	r5,2
8000c7aa:	0a 16       	sub	r6,r5
8000c7ac:	c8 8b       	rjmp	8000c6bc <__avr32_f64_mul+0x30>

8000c7ae <__avr32_f64_mul_op_nan_or_inf>:
8000c7ae:	e4 19 00 0f 	andh	r9,0xf
8000c7b2:	e4 1b 00 0f 	andh	r11,0xf
8000c7b6:	14 4b       	or	r11,r10
8000c7b8:	10 49       	or	r9,r8
8000c7ba:	e0 47 07 ff 	cp.w	r7,2047
8000c7be:	c0 91       	brne	8000c7d0 <__avr32_f64_mul_op1_not_naninf>
8000c7c0:	58 0b       	cp.w	r11,0
8000c7c2:	c3 81       	brne	8000c832 <__avr32_f64_mul_res_nan>
8000c7c4:	e0 46 07 ff 	cp.w	r6,2047
8000c7c8:	c3 81       	brne	8000c838 <__avr32_f64_mul_res_inf>
8000c7ca:	58 09       	cp.w	r9,0
8000c7cc:	c3 60       	breq	8000c838 <__avr32_f64_mul_res_inf>
8000c7ce:	c3 28       	rjmp	8000c832 <__avr32_f64_mul_res_nan>

8000c7d0 <__avr32_f64_mul_op1_not_naninf>:
8000c7d0:	58 09       	cp.w	r9,0
8000c7d2:	c3 30       	breq	8000c838 <__avr32_f64_mul_res_inf>
8000c7d4:	c2 f8       	rjmp	8000c832 <__avr32_f64_mul_res_nan>

8000c7d6 <__avr32_f64_mul_res_subnormal>:
8000c7d6:	5c 3c       	neg	r12
8000c7d8:	2f fc       	sub	r12,-1
8000c7da:	f1 bc 04 c0 	satu	r12,0x6
8000c7de:	e0 4c 00 20 	cp.w	r12,32
8000c7e2:	c1 14       	brge	8000c804 <__avr32_f64_mul_res_subnormal+0x2e>
8000c7e4:	f8 08 11 20 	rsub	r8,r12,32
8000c7e8:	0e 46       	or	r6,r7
8000c7ea:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c7ee:	f4 08 09 49 	lsl	r9,r10,r8
8000c7f2:	12 47       	or	r7,r9
8000c7f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c7f8:	f6 08 09 49 	lsl	r9,r11,r8
8000c7fc:	12 4a       	or	r10,r9
8000c7fe:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c802:	c8 3b       	rjmp	8000c708 <__avr32_f64_mul+0x7c>
8000c804:	f8 08 11 20 	rsub	r8,r12,32
8000c808:	f9 b9 00 00 	moveq	r9,0
8000c80c:	c0 30       	breq	8000c812 <__avr32_f64_mul_res_subnormal+0x3c>
8000c80e:	f6 08 09 49 	lsl	r9,r11,r8
8000c812:	0e 46       	or	r6,r7
8000c814:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c818:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c81c:	f3 ea 10 07 	or	r7,r9,r10
8000c820:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c824:	30 0b       	mov	r11,0
8000c826:	c7 1b       	rjmp	8000c708 <__avr32_f64_mul+0x7c>

8000c828 <__avr32_f64_mul_res_zero>:
8000c828:	1c 9b       	mov	r11,lr
8000c82a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c82e:	30 0a       	mov	r10,0
8000c830:	d8 22       	popm	r4-r7,pc

8000c832 <__avr32_f64_mul_res_nan>:
8000c832:	3f fb       	mov	r11,-1
8000c834:	3f fa       	mov	r10,-1
8000c836:	d8 22       	popm	r4-r7,pc

8000c838 <__avr32_f64_mul_res_inf>:
8000c838:	f0 6b 00 00 	mov	r11,-1048576
8000c83c:	ed be 00 1f 	bld	lr,0x1f
8000c840:	ef bb 00 1f 	bst	r11,0x1f
8000c844:	30 0a       	mov	r10,0
8000c846:	d8 22       	popm	r4-r7,pc

8000c848 <__avr32_f64_mul_op1_zero>:
8000c848:	f7 e9 20 0b 	eor	r11,r11,r9
8000c84c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c850:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c854:	e0 4c 07 ff 	cp.w	r12,2047
8000c858:	5e 1c       	retne	r12
8000c85a:	3f fa       	mov	r10,-1
8000c85c:	3f fb       	mov	r11,-1
8000c85e:	5e fc       	retal	r12

8000c860 <__avr32_f64_sub_from_add>:
8000c860:	ee 19 80 00 	eorh	r9,0x8000

8000c864 <__avr32_f64_sub>:
8000c864:	f7 e9 20 0c 	eor	r12,r11,r9
8000c868:	e0 86 00 ca 	brmi	8000c9fc <__avr32_f64_add_from_sub>
8000c86c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c870:	16 9c       	mov	r12,r11
8000c872:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c876:	bf db       	cbr	r11,0x1f
8000c878:	bf d9       	cbr	r9,0x1f
8000c87a:	10 3a       	cp.w	r10,r8
8000c87c:	f2 0b 13 00 	cpc	r11,r9
8000c880:	c0 92       	brcc	8000c892 <__avr32_f64_sub+0x2e>
8000c882:	16 97       	mov	r7,r11
8000c884:	12 9b       	mov	r11,r9
8000c886:	0e 99       	mov	r9,r7
8000c888:	14 97       	mov	r7,r10
8000c88a:	10 9a       	mov	r10,r8
8000c88c:	0e 98       	mov	r8,r7
8000c88e:	ee 1c 80 00 	eorh	r12,0x8000
8000c892:	f6 07 16 14 	lsr	r7,r11,0x14
8000c896:	ab 7b       	lsl	r11,0xb
8000c898:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c89c:	ab 7a       	lsl	r10,0xb
8000c89e:	bf bb       	sbr	r11,0x1f
8000c8a0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c8a4:	c4 40       	breq	8000c92c <__avr32_f64_sub_opL_subnormal>
8000c8a6:	ab 79       	lsl	r9,0xb
8000c8a8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c8ac:	ab 78       	lsl	r8,0xb
8000c8ae:	bf b9       	sbr	r9,0x1f

8000c8b0 <__avr32_f64_sub_opL_subnormal_done>:
8000c8b0:	e0 47 07 ff 	cp.w	r7,2047
8000c8b4:	c4 f0       	breq	8000c952 <__avr32_f64_sub_opH_nan_or_inf>
8000c8b6:	0e 26       	rsub	r6,r7
8000c8b8:	c1 20       	breq	8000c8dc <__avr32_f64_sub_shift_done>
8000c8ba:	ec 05 11 20 	rsub	r5,r6,32
8000c8be:	e0 46 00 20 	cp.w	r6,32
8000c8c2:	c7 c2       	brcc	8000c9ba <__avr32_f64_sub_longshift>
8000c8c4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c8c8:	f2 05 09 45 	lsl	r5,r9,r5
8000c8cc:	f0 06 0a 48 	lsr	r8,r8,r6
8000c8d0:	f2 06 0a 49 	lsr	r9,r9,r6
8000c8d4:	0a 48       	or	r8,r5
8000c8d6:	58 0e       	cp.w	lr,0
8000c8d8:	5f 1e       	srne	lr
8000c8da:	1c 48       	or	r8,lr

8000c8dc <__avr32_f64_sub_shift_done>:
8000c8dc:	10 1a       	sub	r10,r8
8000c8de:	f6 09 01 4b 	sbc	r11,r11,r9
8000c8e2:	f6 06 12 00 	clz	r6,r11
8000c8e6:	c0 e0       	breq	8000c902 <__avr32_f64_sub_longnormalize_done>
8000c8e8:	c7 83       	brcs	8000c9d8 <__avr32_f64_sub_longnormalize>
8000c8ea:	ec 0e 11 20 	rsub	lr,r6,32
8000c8ee:	f6 06 09 4b 	lsl	r11,r11,r6
8000c8f2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c8f6:	1c 4b       	or	r11,lr
8000c8f8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c8fc:	0c 17       	sub	r7,r6
8000c8fe:	e0 8a 00 39 	brle	8000c970 <__avr32_f64_sub_subnormal_result>

8000c902 <__avr32_f64_sub_longnormalize_done>:
8000c902:	f4 09 15 15 	lsl	r9,r10,0x15
8000c906:	ab 9a       	lsr	r10,0xb
8000c908:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c90c:	ab 9b       	lsr	r11,0xb
8000c90e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c912:	18 4b       	or	r11,r12

8000c914 <__avr32_f64_sub_round>:
8000c914:	fc 17 80 00 	movh	r7,0x8000
8000c918:	ed ba 00 00 	bld	r10,0x0
8000c91c:	f7 b7 01 ff 	subne	r7,-1
8000c920:	0e 39       	cp.w	r9,r7
8000c922:	5f 29       	srhs	r9
8000c924:	12 0a       	add	r10,r9
8000c926:	5c 0b       	acr	r11
8000c928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c92c <__avr32_f64_sub_opL_subnormal>:
8000c92c:	ab 79       	lsl	r9,0xb
8000c92e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c932:	ab 78       	lsl	r8,0xb
8000c934:	f3 e8 10 0e 	or	lr,r9,r8
8000c938:	f9 b6 01 01 	movne	r6,1
8000c93c:	ee 0e 11 00 	rsub	lr,r7,0
8000c940:	f9 b7 00 01 	moveq	r7,1
8000c944:	ef bb 00 1f 	bst	r11,0x1f
8000c948:	f7 ea 10 0e 	or	lr,r11,r10
8000c94c:	f9 b7 00 00 	moveq	r7,0
8000c950:	cb 0b       	rjmp	8000c8b0 <__avr32_f64_sub_opL_subnormal_done>

8000c952 <__avr32_f64_sub_opH_nan_or_inf>:
8000c952:	bf db       	cbr	r11,0x1f
8000c954:	f7 ea 10 0e 	or	lr,r11,r10
8000c958:	c0 81       	brne	8000c968 <__avr32_f64_sub_return_nan>
8000c95a:	e0 46 07 ff 	cp.w	r6,2047
8000c95e:	c0 50       	breq	8000c968 <__avr32_f64_sub_return_nan>
8000c960:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c964:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c968 <__avr32_f64_sub_return_nan>:
8000c968:	3f fa       	mov	r10,-1
8000c96a:	3f fb       	mov	r11,-1
8000c96c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c970 <__avr32_f64_sub_subnormal_result>:
8000c970:	5c 37       	neg	r7
8000c972:	2f f7       	sub	r7,-1
8000c974:	f1 b7 04 c0 	satu	r7,0x6
8000c978:	e0 47 00 20 	cp.w	r7,32
8000c97c:	c1 14       	brge	8000c99e <__avr32_f64_sub_subnormal_result+0x2e>
8000c97e:	ee 08 11 20 	rsub	r8,r7,32
8000c982:	f4 08 09 49 	lsl	r9,r10,r8
8000c986:	5f 16       	srne	r6
8000c988:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c98c:	0c 4a       	or	r10,r6
8000c98e:	f6 08 09 49 	lsl	r9,r11,r8
8000c992:	f5 e9 10 0a 	or	r10,r10,r9
8000c996:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c99a:	30 07       	mov	r7,0
8000c99c:	cb 3b       	rjmp	8000c902 <__avr32_f64_sub_longnormalize_done>
8000c99e:	ee 08 11 40 	rsub	r8,r7,64
8000c9a2:	f6 08 09 49 	lsl	r9,r11,r8
8000c9a6:	14 49       	or	r9,r10
8000c9a8:	5f 16       	srne	r6
8000c9aa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c9ae:	0c 4a       	or	r10,r6
8000c9b0:	30 0b       	mov	r11,0
8000c9b2:	30 07       	mov	r7,0
8000c9b4:	ca 7b       	rjmp	8000c902 <__avr32_f64_sub_longnormalize_done>
8000c9b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c9ba <__avr32_f64_sub_longshift>:
8000c9ba:	f1 b6 04 c0 	satu	r6,0x6
8000c9be:	f0 0e 17 00 	moveq	lr,r8
8000c9c2:	c0 40       	breq	8000c9ca <__avr32_f64_sub_longshift+0x10>
8000c9c4:	f2 05 09 4e 	lsl	lr,r9,r5
8000c9c8:	10 4e       	or	lr,r8
8000c9ca:	f2 06 0a 48 	lsr	r8,r9,r6
8000c9ce:	30 09       	mov	r9,0
8000c9d0:	58 0e       	cp.w	lr,0
8000c9d2:	5f 1e       	srne	lr
8000c9d4:	1c 48       	or	r8,lr
8000c9d6:	c8 3b       	rjmp	8000c8dc <__avr32_f64_sub_shift_done>

8000c9d8 <__avr32_f64_sub_longnormalize>:
8000c9d8:	f4 06 12 00 	clz	r6,r10
8000c9dc:	f9 b7 03 00 	movlo	r7,0
8000c9e0:	f9 b6 03 00 	movlo	r6,0
8000c9e4:	f9 bc 03 00 	movlo	r12,0
8000c9e8:	f7 b6 02 e0 	subhs	r6,-32
8000c9ec:	f4 06 09 4b 	lsl	r11,r10,r6
8000c9f0:	30 0a       	mov	r10,0
8000c9f2:	0c 17       	sub	r7,r6
8000c9f4:	fe 9a ff be 	brle	8000c970 <__avr32_f64_sub_subnormal_result>
8000c9f8:	c8 5b       	rjmp	8000c902 <__avr32_f64_sub_longnormalize_done>
8000c9fa:	d7 03       	nop

8000c9fc <__avr32_f64_add_from_sub>:
8000c9fc:	ee 19 80 00 	eorh	r9,0x8000

8000ca00 <__avr32_f64_add>:
8000ca00:	f7 e9 20 0c 	eor	r12,r11,r9
8000ca04:	fe 96 ff 2e 	brmi	8000c860 <__avr32_f64_sub_from_add>
8000ca08:	eb cd 40 e0 	pushm	r5-r7,lr
8000ca0c:	16 9c       	mov	r12,r11
8000ca0e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ca12:	bf db       	cbr	r11,0x1f
8000ca14:	bf d9       	cbr	r9,0x1f
8000ca16:	12 3b       	cp.w	r11,r9
8000ca18:	c0 72       	brcc	8000ca26 <__avr32_f64_add+0x26>
8000ca1a:	16 97       	mov	r7,r11
8000ca1c:	12 9b       	mov	r11,r9
8000ca1e:	0e 99       	mov	r9,r7
8000ca20:	14 97       	mov	r7,r10
8000ca22:	10 9a       	mov	r10,r8
8000ca24:	0e 98       	mov	r8,r7
8000ca26:	30 0e       	mov	lr,0
8000ca28:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ca2c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ca30:	b5 ab       	sbr	r11,0x14
8000ca32:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ca36:	c6 20       	breq	8000cafa <__avr32_f64_add_op2_subnormal>
8000ca38:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ca3c:	b5 a9       	sbr	r9,0x14
8000ca3e:	e0 47 07 ff 	cp.w	r7,2047
8000ca42:	c2 80       	breq	8000ca92 <__avr32_f64_add_opH_nan_or_inf>
8000ca44:	0e 26       	rsub	r6,r7
8000ca46:	c1 20       	breq	8000ca6a <__avr32_f64_add_shift_done>
8000ca48:	e0 46 00 36 	cp.w	r6,54
8000ca4c:	c1 52       	brcc	8000ca76 <__avr32_f64_add_res_of_done>
8000ca4e:	ec 05 11 20 	rsub	r5,r6,32
8000ca52:	e0 46 00 20 	cp.w	r6,32
8000ca56:	c3 52       	brcc	8000cac0 <__avr32_f64_add_longshift>
8000ca58:	f0 05 09 4e 	lsl	lr,r8,r5
8000ca5c:	f2 05 09 45 	lsl	r5,r9,r5
8000ca60:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca64:	f2 06 0a 49 	lsr	r9,r9,r6
8000ca68:	0a 48       	or	r8,r5

8000ca6a <__avr32_f64_add_shift_done>:
8000ca6a:	10 0a       	add	r10,r8
8000ca6c:	f6 09 00 4b 	adc	r11,r11,r9
8000ca70:	ed bb 00 15 	bld	r11,0x15
8000ca74:	c3 40       	breq	8000cadc <__avr32_f64_add_res_of>

8000ca76 <__avr32_f64_add_res_of_done>:
8000ca76:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ca7a:	18 4b       	or	r11,r12

8000ca7c <__avr32_f64_add_round>:
8000ca7c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ca80:	18 4e       	or	lr,r12
8000ca82:	ee 1e 80 00 	eorh	lr,0x8000
8000ca86:	f1 be 04 20 	satu	lr,0x1
8000ca8a:	1c 0a       	add	r10,lr
8000ca8c:	5c 0b       	acr	r11
8000ca8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca92 <__avr32_f64_add_opH_nan_or_inf>:
8000ca92:	b5 cb       	cbr	r11,0x14
8000ca94:	f7 ea 10 0e 	or	lr,r11,r10
8000ca98:	c1 01       	brne	8000cab8 <__avr32_f64_add_return_nan>
8000ca9a:	e0 46 07 ff 	cp.w	r6,2047
8000ca9e:	c0 30       	breq	8000caa4 <__avr32_f64_add_opL_nan_or_inf>
8000caa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000caa4 <__avr32_f64_add_opL_nan_or_inf>:
8000caa4:	b5 c9       	cbr	r9,0x14
8000caa6:	f3 e8 10 0e 	or	lr,r9,r8
8000caaa:	c0 71       	brne	8000cab8 <__avr32_f64_add_return_nan>
8000caac:	30 0a       	mov	r10,0
8000caae:	fc 1b 7f f0 	movh	r11,0x7ff0
8000cab2:	18 4b       	or	r11,r12
8000cab4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cab8 <__avr32_f64_add_return_nan>:
8000cab8:	3f fa       	mov	r10,-1
8000caba:	3f fb       	mov	r11,-1
8000cabc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cac0 <__avr32_f64_add_longshift>:
8000cac0:	f1 b6 04 c0 	satu	r6,0x6
8000cac4:	f0 0e 17 00 	moveq	lr,r8
8000cac8:	c0 60       	breq	8000cad4 <__avr32_f64_add_longshift+0x14>
8000caca:	f2 05 09 4e 	lsl	lr,r9,r5
8000cace:	58 08       	cp.w	r8,0
8000cad0:	5f 18       	srne	r8
8000cad2:	10 4e       	or	lr,r8
8000cad4:	f2 06 0a 48 	lsr	r8,r9,r6
8000cad8:	30 09       	mov	r9,0
8000cada:	cc 8b       	rjmp	8000ca6a <__avr32_f64_add_shift_done>

8000cadc <__avr32_f64_add_res_of>:
8000cadc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000cae0:	a1 9b       	lsr	r11,0x1
8000cae2:	5d 0a       	ror	r10
8000cae4:	5d 0e       	ror	lr
8000cae6:	2f f7       	sub	r7,-1
8000cae8:	e0 47 07 ff 	cp.w	r7,2047
8000caec:	f9 ba 00 00 	moveq	r10,0
8000caf0:	f9 bb 00 00 	moveq	r11,0
8000caf4:	f9 be 00 00 	moveq	lr,0
8000caf8:	cb fb       	rjmp	8000ca76 <__avr32_f64_add_res_of_done>

8000cafa <__avr32_f64_add_op2_subnormal>:
8000cafa:	30 16       	mov	r6,1
8000cafc:	58 07       	cp.w	r7,0
8000cafe:	ca 01       	brne	8000ca3e <__avr32_f64_add+0x3e>
8000cb00:	b5 cb       	cbr	r11,0x14
8000cb02:	10 0a       	add	r10,r8
8000cb04:	f6 09 00 4b 	adc	r11,r11,r9
8000cb08:	18 4b       	or	r11,r12
8000cb0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000cb0e:	d7 03       	nop

8000cb10 <__avr32_f64_to_u32>:
8000cb10:	58 0b       	cp.w	r11,0
8000cb12:	5e 6d       	retmi	0

8000cb14 <__avr32_f64_to_s32>:
8000cb14:	f6 0c 15 01 	lsl	r12,r11,0x1
8000cb18:	b5 9c       	lsr	r12,0x15
8000cb1a:	e0 2c 03 ff 	sub	r12,1023
8000cb1e:	5e 3d       	retlo	0
8000cb20:	f8 0c 11 1f 	rsub	r12,r12,31
8000cb24:	16 99       	mov	r9,r11
8000cb26:	ab 7b       	lsl	r11,0xb
8000cb28:	bf bb       	sbr	r11,0x1f
8000cb2a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000cb2e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cb32:	a1 79       	lsl	r9,0x1
8000cb34:	5e 2b       	reths	r11
8000cb36:	5c 3b       	neg	r11
8000cb38:	5e fb       	retal	r11

8000cb3a <__avr32_u32_to_f64>:
8000cb3a:	f8 cb 00 00 	sub	r11,r12,0
8000cb3e:	30 0c       	mov	r12,0
8000cb40:	c0 38       	rjmp	8000cb46 <__avr32_s32_to_f64+0x4>

8000cb42 <__avr32_s32_to_f64>:
8000cb42:	18 9b       	mov	r11,r12
8000cb44:	5c 4b       	abs	r11
8000cb46:	30 0a       	mov	r10,0
8000cb48:	5e 0b       	reteq	r11
8000cb4a:	d4 01       	pushm	lr
8000cb4c:	e0 69 04 1e 	mov	r9,1054
8000cb50:	f6 08 12 00 	clz	r8,r11
8000cb54:	c1 70       	breq	8000cb82 <__avr32_s32_to_f64+0x40>
8000cb56:	c0 c3       	brcs	8000cb6e <__avr32_s32_to_f64+0x2c>
8000cb58:	f0 0e 11 20 	rsub	lr,r8,32
8000cb5c:	f6 08 09 4b 	lsl	r11,r11,r8
8000cb60:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000cb64:	1c 4b       	or	r11,lr
8000cb66:	f4 08 09 4a 	lsl	r10,r10,r8
8000cb6a:	10 19       	sub	r9,r8
8000cb6c:	c0 b8       	rjmp	8000cb82 <__avr32_s32_to_f64+0x40>
8000cb6e:	f4 08 12 00 	clz	r8,r10
8000cb72:	f9 b8 03 00 	movlo	r8,0
8000cb76:	f7 b8 02 e0 	subhs	r8,-32
8000cb7a:	f4 08 09 4b 	lsl	r11,r10,r8
8000cb7e:	30 0a       	mov	r10,0
8000cb80:	10 19       	sub	r9,r8
8000cb82:	58 09       	cp.w	r9,0
8000cb84:	e0 89 00 30 	brgt	8000cbe4 <__avr32_s32_to_f64+0xa2>
8000cb88:	5c 39       	neg	r9
8000cb8a:	2f f9       	sub	r9,-1
8000cb8c:	e0 49 00 36 	cp.w	r9,54
8000cb90:	c0 43       	brcs	8000cb98 <__avr32_s32_to_f64+0x56>
8000cb92:	30 0b       	mov	r11,0
8000cb94:	30 0a       	mov	r10,0
8000cb96:	c2 68       	rjmp	8000cbe2 <__avr32_s32_to_f64+0xa0>
8000cb98:	2f 69       	sub	r9,-10
8000cb9a:	f2 08 11 20 	rsub	r8,r9,32
8000cb9e:	e0 49 00 20 	cp.w	r9,32
8000cba2:	c0 b2       	brcc	8000cbb8 <__avr32_s32_to_f64+0x76>
8000cba4:	f4 08 09 4e 	lsl	lr,r10,r8
8000cba8:	f6 08 09 48 	lsl	r8,r11,r8
8000cbac:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cbb0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000cbb4:	10 4b       	or	r11,r8
8000cbb6:	c0 88       	rjmp	8000cbc6 <__avr32_s32_to_f64+0x84>
8000cbb8:	f6 08 09 4e 	lsl	lr,r11,r8
8000cbbc:	14 4e       	or	lr,r10
8000cbbe:	16 9a       	mov	r10,r11
8000cbc0:	30 0b       	mov	r11,0
8000cbc2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cbc6:	ed ba 00 00 	bld	r10,0x0
8000cbca:	c0 92       	brcc	8000cbdc <__avr32_s32_to_f64+0x9a>
8000cbcc:	1c 7e       	tst	lr,lr
8000cbce:	c0 41       	brne	8000cbd6 <__avr32_s32_to_f64+0x94>
8000cbd0:	ed ba 00 01 	bld	r10,0x1
8000cbd4:	c0 42       	brcc	8000cbdc <__avr32_s32_to_f64+0x9a>
8000cbd6:	2f fa       	sub	r10,-1
8000cbd8:	f7 bb 02 ff 	subhs	r11,-1
8000cbdc:	5c fc       	rol	r12
8000cbde:	5d 0b       	ror	r11
8000cbe0:	5d 0a       	ror	r10
8000cbe2:	d8 02       	popm	pc
8000cbe4:	e0 68 03 ff 	mov	r8,1023
8000cbe8:	ed ba 00 0b 	bld	r10,0xb
8000cbec:	f7 b8 00 ff 	subeq	r8,-1
8000cbf0:	10 0a       	add	r10,r8
8000cbf2:	5c 0b       	acr	r11
8000cbf4:	f7 b9 03 fe 	sublo	r9,-2
8000cbf8:	e0 49 07 ff 	cp.w	r9,2047
8000cbfc:	c0 55       	brlt	8000cc06 <__avr32_s32_to_f64+0xc4>
8000cbfe:	30 0a       	mov	r10,0
8000cc00:	fc 1b ff e0 	movh	r11,0xffe0
8000cc04:	c0 c8       	rjmp	8000cc1c <__floatsidf_return_op1>
8000cc06:	ed bb 00 1f 	bld	r11,0x1f
8000cc0a:	f7 b9 01 01 	subne	r9,1
8000cc0e:	ab 9a       	lsr	r10,0xb
8000cc10:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000cc14:	a1 7b       	lsl	r11,0x1
8000cc16:	ab 9b       	lsr	r11,0xb
8000cc18:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000cc1c <__floatsidf_return_op1>:
8000cc1c:	a1 7c       	lsl	r12,0x1
8000cc1e:	5d 0b       	ror	r11
8000cc20:	d8 02       	popm	pc

8000cc22 <__avr32_f64_cmp_eq>:
8000cc22:	10 3a       	cp.w	r10,r8
8000cc24:	f2 0b 13 00 	cpc	r11,r9
8000cc28:	c0 80       	breq	8000cc38 <__avr32_f64_cmp_eq+0x16>
8000cc2a:	a1 7b       	lsl	r11,0x1
8000cc2c:	a1 79       	lsl	r9,0x1
8000cc2e:	14 4b       	or	r11,r10
8000cc30:	12 4b       	or	r11,r9
8000cc32:	10 4b       	or	r11,r8
8000cc34:	5e 0f       	reteq	1
8000cc36:	5e fd       	retal	0
8000cc38:	a1 7b       	lsl	r11,0x1
8000cc3a:	fc 1c ff e0 	movh	r12,0xffe0
8000cc3e:	58 0a       	cp.w	r10,0
8000cc40:	f8 0b 13 00 	cpc	r11,r12
8000cc44:	5e 8f       	retls	1
8000cc46:	5e fd       	retal	0

8000cc48 <__avr32_f64_cmp_ge>:
8000cc48:	1a de       	st.w	--sp,lr
8000cc4a:	1a d7       	st.w	--sp,r7
8000cc4c:	a1 7b       	lsl	r11,0x1
8000cc4e:	5f 3c       	srlo	r12
8000cc50:	a1 79       	lsl	r9,0x1
8000cc52:	5f 37       	srlo	r7
8000cc54:	5c fc       	rol	r12
8000cc56:	fc 1e ff e0 	movh	lr,0xffe0
8000cc5a:	58 0a       	cp.w	r10,0
8000cc5c:	fc 0b 13 00 	cpc	r11,lr
8000cc60:	e0 8b 00 1d 	brhi	8000cc9a <__avr32_f64_cmp_ge+0x52>
8000cc64:	58 08       	cp.w	r8,0
8000cc66:	fc 09 13 00 	cpc	r9,lr
8000cc6a:	e0 8b 00 18 	brhi	8000cc9a <__avr32_f64_cmp_ge+0x52>
8000cc6e:	58 0b       	cp.w	r11,0
8000cc70:	f5 ba 00 00 	subfeq	r10,0
8000cc74:	c1 50       	breq	8000cc9e <__avr32_f64_cmp_ge+0x56>
8000cc76:	1b 07       	ld.w	r7,sp++
8000cc78:	1b 0e       	ld.w	lr,sp++
8000cc7a:	58 3c       	cp.w	r12,3
8000cc7c:	c0 a0       	breq	8000cc90 <__avr32_f64_cmp_ge+0x48>
8000cc7e:	58 1c       	cp.w	r12,1
8000cc80:	c0 33       	brcs	8000cc86 <__avr32_f64_cmp_ge+0x3e>
8000cc82:	5e 0f       	reteq	1
8000cc84:	5e 1d       	retne	0
8000cc86:	10 3a       	cp.w	r10,r8
8000cc88:	f2 0b 13 00 	cpc	r11,r9
8000cc8c:	5e 2f       	reths	1
8000cc8e:	5e 3d       	retlo	0
8000cc90:	14 38       	cp.w	r8,r10
8000cc92:	f6 09 13 00 	cpc	r9,r11
8000cc96:	5e 2f       	reths	1
8000cc98:	5e 3d       	retlo	0
8000cc9a:	1b 07       	ld.w	r7,sp++
8000cc9c:	d8 0a       	popm	pc,r12=0
8000cc9e:	58 17       	cp.w	r7,1
8000cca0:	5f 0c       	sreq	r12
8000cca2:	58 09       	cp.w	r9,0
8000cca4:	f5 b8 00 00 	subfeq	r8,0
8000cca8:	1b 07       	ld.w	r7,sp++
8000ccaa:	1b 0e       	ld.w	lr,sp++
8000ccac:	5e 0f       	reteq	1
8000ccae:	5e fc       	retal	r12

8000ccb0 <__avr32_f64_cmp_lt>:
8000ccb0:	1a de       	st.w	--sp,lr
8000ccb2:	1a d7       	st.w	--sp,r7
8000ccb4:	a1 7b       	lsl	r11,0x1
8000ccb6:	5f 3c       	srlo	r12
8000ccb8:	a1 79       	lsl	r9,0x1
8000ccba:	5f 37       	srlo	r7
8000ccbc:	5c fc       	rol	r12
8000ccbe:	fc 1e ff e0 	movh	lr,0xffe0
8000ccc2:	58 0a       	cp.w	r10,0
8000ccc4:	fc 0b 13 00 	cpc	r11,lr
8000ccc8:	e0 8b 00 1d 	brhi	8000cd02 <__avr32_f64_cmp_lt+0x52>
8000cccc:	58 08       	cp.w	r8,0
8000ccce:	fc 09 13 00 	cpc	r9,lr
8000ccd2:	e0 8b 00 18 	brhi	8000cd02 <__avr32_f64_cmp_lt+0x52>
8000ccd6:	58 0b       	cp.w	r11,0
8000ccd8:	f5 ba 00 00 	subfeq	r10,0
8000ccdc:	c1 50       	breq	8000cd06 <__avr32_f64_cmp_lt+0x56>
8000ccde:	1b 07       	ld.w	r7,sp++
8000cce0:	1b 0e       	ld.w	lr,sp++
8000cce2:	58 3c       	cp.w	r12,3
8000cce4:	c0 a0       	breq	8000ccf8 <__avr32_f64_cmp_lt+0x48>
8000cce6:	58 1c       	cp.w	r12,1
8000cce8:	c0 33       	brcs	8000ccee <__avr32_f64_cmp_lt+0x3e>
8000ccea:	5e 0d       	reteq	0
8000ccec:	5e 1f       	retne	1
8000ccee:	10 3a       	cp.w	r10,r8
8000ccf0:	f2 0b 13 00 	cpc	r11,r9
8000ccf4:	5e 2d       	reths	0
8000ccf6:	5e 3f       	retlo	1
8000ccf8:	14 38       	cp.w	r8,r10
8000ccfa:	f6 09 13 00 	cpc	r9,r11
8000ccfe:	5e 2d       	reths	0
8000cd00:	5e 3f       	retlo	1
8000cd02:	1b 07       	ld.w	r7,sp++
8000cd04:	d8 0a       	popm	pc,r12=0
8000cd06:	58 17       	cp.w	r7,1
8000cd08:	5f 1c       	srne	r12
8000cd0a:	58 09       	cp.w	r9,0
8000cd0c:	f5 b8 00 00 	subfeq	r8,0
8000cd10:	1b 07       	ld.w	r7,sp++
8000cd12:	1b 0e       	ld.w	lr,sp++
8000cd14:	5e 0d       	reteq	0
8000cd16:	5e fc       	retal	r12

8000cd18 <__avr32_f64_div>:
8000cd18:	eb cd 40 ff 	pushm	r0-r7,lr
8000cd1c:	f7 e9 20 0e 	eor	lr,r11,r9
8000cd20:	f6 07 16 14 	lsr	r7,r11,0x14
8000cd24:	a9 7b       	lsl	r11,0x9
8000cd26:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000cd2a:	a9 7a       	lsl	r10,0x9
8000cd2c:	bd bb       	sbr	r11,0x1d
8000cd2e:	e4 1b 3f ff 	andh	r11,0x3fff
8000cd32:	ab d7       	cbr	r7,0xb
8000cd34:	e0 80 00 cc 	breq	8000cecc <__avr32_f64_div_round_subnormal+0x54>
8000cd38:	e0 47 07 ff 	cp.w	r7,2047
8000cd3c:	e0 84 00 b5 	brge	8000cea6 <__avr32_f64_div_round_subnormal+0x2e>
8000cd40:	f2 06 16 14 	lsr	r6,r9,0x14
8000cd44:	a9 79       	lsl	r9,0x9
8000cd46:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000cd4a:	a9 78       	lsl	r8,0x9
8000cd4c:	bd b9       	sbr	r9,0x1d
8000cd4e:	e4 19 3f ff 	andh	r9,0x3fff
8000cd52:	ab d6       	cbr	r6,0xb
8000cd54:	e0 80 00 e2 	breq	8000cf18 <__avr32_f64_div_round_subnormal+0xa0>
8000cd58:	e0 46 07 ff 	cp.w	r6,2047
8000cd5c:	e0 84 00 b2 	brge	8000cec0 <__avr32_f64_div_round_subnormal+0x48>
8000cd60:	0c 17       	sub	r7,r6
8000cd62:	fe 37 fc 01 	sub	r7,-1023
8000cd66:	fc 1c 80 00 	movh	r12,0x8000
8000cd6a:	f8 03 16 01 	lsr	r3,r12,0x1
8000cd6e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000cd72:	5c d4       	com	r4
8000cd74:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000cd78:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cd7c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000cd80:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cd84:	ea 03 15 02 	lsl	r3,r5,0x2
8000cd88:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cd8c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000cd90:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cd94:	ea 03 15 02 	lsl	r3,r5,0x2
8000cd98:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cd9c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000cda0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cda4:	ea 03 15 02 	lsl	r3,r5,0x2
8000cda8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000cdac:	e4 09 07 40 	macu.d	r0,r2,r9
8000cdb0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cdb4:	02 04       	add	r4,r1
8000cdb6:	5c 05       	acr	r5
8000cdb8:	a3 65       	lsl	r5,0x2
8000cdba:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000cdbe:	a3 64       	lsl	r4,0x2
8000cdc0:	5c 34       	neg	r4
8000cdc2:	f8 05 01 45 	sbc	r5,r12,r5
8000cdc6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000cdca:	e4 05 07 40 	macu.d	r0,r2,r5
8000cdce:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cdd2:	02 04       	add	r4,r1
8000cdd4:	5c 05       	acr	r5
8000cdd6:	ea 03 15 02 	lsl	r3,r5,0x2
8000cdda:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000cdde:	e8 02 15 02 	lsl	r2,r4,0x2
8000cde2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000cde6:	e4 09 07 40 	macu.d	r0,r2,r9
8000cdea:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cdee:	02 04       	add	r4,r1
8000cdf0:	5c 05       	acr	r5
8000cdf2:	a3 65       	lsl	r5,0x2
8000cdf4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000cdf8:	a3 64       	lsl	r4,0x2
8000cdfa:	5c 34       	neg	r4
8000cdfc:	f8 05 01 45 	sbc	r5,r12,r5
8000ce00:	e6 04 06 40 	mulu.d	r0,r3,r4
8000ce04:	e4 05 07 40 	macu.d	r0,r2,r5
8000ce08:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce0c:	02 04       	add	r4,r1
8000ce0e:	5c 05       	acr	r5
8000ce10:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce14:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000ce18:	e8 02 15 02 	lsl	r2,r4,0x2
8000ce1c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000ce20:	e4 0b 07 40 	macu.d	r0,r2,r11
8000ce24:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000ce28:	02 02       	add	r2,r1
8000ce2a:	5c 03       	acr	r3
8000ce2c:	ed b3 00 1c 	bld	r3,0x1c
8000ce30:	c0 90       	breq	8000ce42 <__avr32_f64_div+0x12a>
8000ce32:	a1 72       	lsl	r2,0x1
8000ce34:	5c f3       	rol	r3
8000ce36:	20 17       	sub	r7,1
8000ce38:	a3 9a       	lsr	r10,0x3
8000ce3a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000ce3e:	a3 9b       	lsr	r11,0x3
8000ce40:	c0 58       	rjmp	8000ce4a <__avr32_f64_div+0x132>
8000ce42:	a5 8a       	lsr	r10,0x4
8000ce44:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000ce48:	a5 8b       	lsr	r11,0x4
8000ce4a:	58 07       	cp.w	r7,0
8000ce4c:	e0 8a 00 8b 	brle	8000cf62 <__avr32_f64_div_res_subnormal>
8000ce50:	e0 12 ff 00 	andl	r2,0xff00
8000ce54:	e8 12 00 80 	orl	r2,0x80
8000ce58:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ce5c:	e4 09 07 40 	macu.d	r0,r2,r9
8000ce60:	e4 08 06 44 	mulu.d	r4,r2,r8
8000ce64:	e6 09 06 48 	mulu.d	r8,r3,r9
8000ce68:	00 05       	add	r5,r0
8000ce6a:	f0 01 00 48 	adc	r8,r8,r1
8000ce6e:	5c 09       	acr	r9
8000ce70:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000ce74:	58 04       	cp.w	r4,0
8000ce76:	5c 25       	cpc	r5

8000ce78 <__avr32_f64_div_round_subnormal>:
8000ce78:	f4 08 13 00 	cpc	r8,r10
8000ce7c:	f6 09 13 00 	cpc	r9,r11
8000ce80:	5f 36       	srlo	r6
8000ce82:	f8 06 17 00 	moveq	r6,r12
8000ce86:	e4 0a 16 08 	lsr	r10,r2,0x8
8000ce8a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000ce8e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000ce92:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ce96:	ed be 00 1f 	bld	lr,0x1f
8000ce9a:	ef bb 00 1f 	bst	r11,0x1f
8000ce9e:	0c 0a       	add	r10,r6
8000cea0:	5c 0b       	acr	r11
8000cea2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cea6:	e4 1b 00 0f 	andh	r11,0xf
8000ceaa:	14 4b       	or	r11,r10
8000ceac:	e0 81 00 a7 	brne	8000cffa <__avr32_f64_div_res_subnormal+0x98>
8000ceb0:	f2 06 16 14 	lsr	r6,r9,0x14
8000ceb4:	ab d6       	cbr	r6,0xb
8000ceb6:	e0 46 07 ff 	cp.w	r6,2047
8000ceba:	e0 81 00 a4 	brne	8000d002 <__avr32_f64_div_res_subnormal+0xa0>
8000cebe:	c9 e8       	rjmp	8000cffa <__avr32_f64_div_res_subnormal+0x98>
8000cec0:	e4 19 00 0f 	andh	r9,0xf
8000cec4:	10 49       	or	r9,r8
8000cec6:	e0 81 00 9a 	brne	8000cffa <__avr32_f64_div_res_subnormal+0x98>
8000ceca:	c9 28       	rjmp	8000cfee <__avr32_f64_div_res_subnormal+0x8c>
8000cecc:	a3 7b       	lsl	r11,0x3
8000cece:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000ced2:	a3 7a       	lsl	r10,0x3
8000ced4:	f5 eb 10 04 	or	r4,r10,r11
8000ced8:	e0 80 00 a0 	breq	8000d018 <__avr32_f64_div_op1_zero>
8000cedc:	f6 04 12 00 	clz	r4,r11
8000cee0:	c1 70       	breq	8000cf0e <__avr32_f64_div_round_subnormal+0x96>
8000cee2:	c0 c3       	brcs	8000cefa <__avr32_f64_div_round_subnormal+0x82>
8000cee4:	e8 05 11 20 	rsub	r5,r4,32
8000cee8:	f6 04 09 4b 	lsl	r11,r11,r4
8000ceec:	f4 05 0a 45 	lsr	r5,r10,r5
8000cef0:	0a 4b       	or	r11,r5
8000cef2:	f4 04 09 4a 	lsl	r10,r10,r4
8000cef6:	08 17       	sub	r7,r4
8000cef8:	c0 b8       	rjmp	8000cf0e <__avr32_f64_div_round_subnormal+0x96>
8000cefa:	f4 04 12 00 	clz	r4,r10
8000cefe:	f9 b4 03 00 	movlo	r4,0
8000cf02:	f7 b4 02 e0 	subhs	r4,-32
8000cf06:	f4 04 09 4b 	lsl	r11,r10,r4
8000cf0a:	30 0a       	mov	r10,0
8000cf0c:	08 17       	sub	r7,r4
8000cf0e:	a3 8a       	lsr	r10,0x2
8000cf10:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000cf14:	a3 8b       	lsr	r11,0x2
8000cf16:	c1 1b       	rjmp	8000cd38 <__avr32_f64_div+0x20>
8000cf18:	a3 79       	lsl	r9,0x3
8000cf1a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000cf1e:	a3 78       	lsl	r8,0x3
8000cf20:	f3 e8 10 04 	or	r4,r9,r8
8000cf24:	c6 f0       	breq	8000d002 <__avr32_f64_div_res_subnormal+0xa0>
8000cf26:	f2 04 12 00 	clz	r4,r9
8000cf2a:	c1 70       	breq	8000cf58 <__avr32_f64_div_round_subnormal+0xe0>
8000cf2c:	c0 c3       	brcs	8000cf44 <__avr32_f64_div_round_subnormal+0xcc>
8000cf2e:	e8 05 11 20 	rsub	r5,r4,32
8000cf32:	f2 04 09 49 	lsl	r9,r9,r4
8000cf36:	f0 05 0a 45 	lsr	r5,r8,r5
8000cf3a:	0a 49       	or	r9,r5
8000cf3c:	f0 04 09 48 	lsl	r8,r8,r4
8000cf40:	08 16       	sub	r6,r4
8000cf42:	c0 b8       	rjmp	8000cf58 <__avr32_f64_div_round_subnormal+0xe0>
8000cf44:	f0 04 12 00 	clz	r4,r8
8000cf48:	f9 b4 03 00 	movlo	r4,0
8000cf4c:	f7 b4 02 e0 	subhs	r4,-32
8000cf50:	f0 04 09 49 	lsl	r9,r8,r4
8000cf54:	30 08       	mov	r8,0
8000cf56:	08 16       	sub	r6,r4
8000cf58:	a3 88       	lsr	r8,0x2
8000cf5a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000cf5e:	a3 89       	lsr	r9,0x2
8000cf60:	cf ca       	rjmp	8000cd58 <__avr32_f64_div+0x40>

8000cf62 <__avr32_f64_div_res_subnormal>:
8000cf62:	5c 37       	neg	r7
8000cf64:	2f f7       	sub	r7,-1
8000cf66:	f1 b7 04 c0 	satu	r7,0x6
8000cf6a:	e0 47 00 20 	cp.w	r7,32
8000cf6e:	c1 54       	brge	8000cf98 <__avr32_f64_div_res_subnormal+0x36>
8000cf70:	ee 06 11 20 	rsub	r6,r7,32
8000cf74:	e4 07 0a 42 	lsr	r2,r2,r7
8000cf78:	e6 06 09 4c 	lsl	r12,r3,r6
8000cf7c:	18 42       	or	r2,r12
8000cf7e:	e6 07 0a 43 	lsr	r3,r3,r7
8000cf82:	f4 06 09 41 	lsl	r1,r10,r6
8000cf86:	f4 07 0a 4a 	lsr	r10,r10,r7
8000cf8a:	f6 06 09 4c 	lsl	r12,r11,r6
8000cf8e:	18 4a       	or	r10,r12
8000cf90:	f6 07 0a 4b 	lsr	r11,r11,r7
8000cf94:	30 00       	mov	r0,0
8000cf96:	c1 58       	rjmp	8000cfc0 <__avr32_f64_div_res_subnormal+0x5e>
8000cf98:	ee 06 11 20 	rsub	r6,r7,32
8000cf9c:	f9 b0 00 00 	moveq	r0,0
8000cfa0:	f9 bc 00 00 	moveq	r12,0
8000cfa4:	c0 50       	breq	8000cfae <__avr32_f64_div_res_subnormal+0x4c>
8000cfa6:	f4 06 09 40 	lsl	r0,r10,r6
8000cfaa:	f6 06 09 4c 	lsl	r12,r11,r6
8000cfae:	e6 07 0a 42 	lsr	r2,r3,r7
8000cfb2:	30 03       	mov	r3,0
8000cfb4:	f4 07 0a 41 	lsr	r1,r10,r7
8000cfb8:	18 41       	or	r1,r12
8000cfba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000cfbe:	30 0b       	mov	r11,0
8000cfc0:	e0 12 ff 00 	andl	r2,0xff00
8000cfc4:	e8 12 00 80 	orl	r2,0x80
8000cfc8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000cfcc:	e4 09 07 46 	macu.d	r6,r2,r9
8000cfd0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cfd4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cfd8:	0c 05       	add	r5,r6
8000cfda:	f0 07 00 48 	adc	r8,r8,r7
8000cfde:	5c 09       	acr	r9
8000cfe0:	30 07       	mov	r7,0
8000cfe2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000cfe6:	00 34       	cp.w	r4,r0
8000cfe8:	e2 05 13 00 	cpc	r5,r1
8000cfec:	c4 6b       	rjmp	8000ce78 <__avr32_f64_div_round_subnormal>
8000cfee:	1c 9b       	mov	r11,lr
8000cff0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cff4:	30 0a       	mov	r10,0
8000cff6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cffa:	3f fb       	mov	r11,-1
8000cffc:	30 0a       	mov	r10,0
8000cffe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d002:	f5 eb 10 04 	or	r4,r10,r11
8000d006:	c0 90       	breq	8000d018 <__avr32_f64_div_op1_zero>
8000d008:	1c 9b       	mov	r11,lr
8000d00a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d00e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d012:	30 0a       	mov	r10,0
8000d014:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d018 <__avr32_f64_div_op1_zero>:
8000d018:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d01c:	ce f0       	breq	8000cffa <__avr32_f64_div_res_subnormal+0x98>
8000d01e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d022:	e0 44 07 ff 	cp.w	r4,2047
8000d026:	ce 41       	brne	8000cfee <__avr32_f64_div_res_subnormal+0x8c>
8000d028:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d02c:	ce 10       	breq	8000cfee <__avr32_f64_div_res_subnormal+0x8c>
8000d02e:	ce 6b       	rjmp	8000cffa <__avr32_f64_div_res_subnormal+0x98>

8000d030 <__avr32_udiv64>:
8000d030:	d4 31       	pushm	r0-r7,lr
8000d032:	1a 97       	mov	r7,sp
8000d034:	20 3d       	sub	sp,12
8000d036:	10 9c       	mov	r12,r8
8000d038:	12 9e       	mov	lr,r9
8000d03a:	14 93       	mov	r3,r10
8000d03c:	58 09       	cp.w	r9,0
8000d03e:	e0 81 00 bd 	brne	8000d1b8 <__avr32_udiv64+0x188>
8000d042:	16 38       	cp.w	r8,r11
8000d044:	e0 88 00 40 	brls	8000d0c4 <__avr32_udiv64+0x94>
8000d048:	f0 08 12 00 	clz	r8,r8
8000d04c:	c0 d0       	breq	8000d066 <__avr32_udiv64+0x36>
8000d04e:	f6 08 09 4b 	lsl	r11,r11,r8
8000d052:	f0 09 11 20 	rsub	r9,r8,32
8000d056:	f8 08 09 4c 	lsl	r12,r12,r8
8000d05a:	f4 09 0a 49 	lsr	r9,r10,r9
8000d05e:	f4 08 09 43 	lsl	r3,r10,r8
8000d062:	f3 eb 10 0b 	or	r11,r9,r11
8000d066:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d06a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d06e:	f6 0e 0d 00 	divu	r0,r11,lr
8000d072:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d076:	00 99       	mov	r9,r0
8000d078:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d07c:	e0 0a 02 48 	mul	r8,r0,r10
8000d080:	10 3b       	cp.w	r11,r8
8000d082:	c0 a2       	brcc	8000d096 <__avr32_udiv64+0x66>
8000d084:	20 19       	sub	r9,1
8000d086:	18 0b       	add	r11,r12
8000d088:	18 3b       	cp.w	r11,r12
8000d08a:	c0 63       	brcs	8000d096 <__avr32_udiv64+0x66>
8000d08c:	10 3b       	cp.w	r11,r8
8000d08e:	f7 b9 03 01 	sublo	r9,1
8000d092:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d096:	f6 08 01 01 	sub	r1,r11,r8
8000d09a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d09e:	e2 0e 0d 00 	divu	r0,r1,lr
8000d0a2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d0a6:	00 98       	mov	r8,r0
8000d0a8:	e0 0a 02 4a 	mul	r10,r0,r10
8000d0ac:	14 33       	cp.w	r3,r10
8000d0ae:	c0 82       	brcc	8000d0be <__avr32_udiv64+0x8e>
8000d0b0:	20 18       	sub	r8,1
8000d0b2:	18 03       	add	r3,r12
8000d0b4:	18 33       	cp.w	r3,r12
8000d0b6:	c0 43       	brcs	8000d0be <__avr32_udiv64+0x8e>
8000d0b8:	14 33       	cp.w	r3,r10
8000d0ba:	f7 b8 03 01 	sublo	r8,1
8000d0be:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d0c2:	cd f8       	rjmp	8000d280 <__avr32_udiv64+0x250>
8000d0c4:	58 08       	cp.w	r8,0
8000d0c6:	c0 51       	brne	8000d0d0 <__avr32_udiv64+0xa0>
8000d0c8:	30 19       	mov	r9,1
8000d0ca:	f2 08 0d 08 	divu	r8,r9,r8
8000d0ce:	10 9c       	mov	r12,r8
8000d0d0:	f8 06 12 00 	clz	r6,r12
8000d0d4:	c0 41       	brne	8000d0dc <__avr32_udiv64+0xac>
8000d0d6:	18 1b       	sub	r11,r12
8000d0d8:	30 19       	mov	r9,1
8000d0da:	c4 08       	rjmp	8000d15a <__avr32_udiv64+0x12a>
8000d0dc:	ec 01 11 20 	rsub	r1,r6,32
8000d0e0:	f4 01 0a 49 	lsr	r9,r10,r1
8000d0e4:	f8 06 09 4c 	lsl	r12,r12,r6
8000d0e8:	f6 06 09 48 	lsl	r8,r11,r6
8000d0ec:	f6 01 0a 41 	lsr	r1,r11,r1
8000d0f0:	f3 e8 10 08 	or	r8,r9,r8
8000d0f4:	f8 03 16 10 	lsr	r3,r12,0x10
8000d0f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d0fc:	e2 03 0d 00 	divu	r0,r1,r3
8000d100:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d104:	00 9e       	mov	lr,r0
8000d106:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d10a:	e0 05 02 49 	mul	r9,r0,r5
8000d10e:	12 3b       	cp.w	r11,r9
8000d110:	c0 a2       	brcc	8000d124 <__avr32_udiv64+0xf4>
8000d112:	20 1e       	sub	lr,1
8000d114:	18 0b       	add	r11,r12
8000d116:	18 3b       	cp.w	r11,r12
8000d118:	c0 63       	brcs	8000d124 <__avr32_udiv64+0xf4>
8000d11a:	12 3b       	cp.w	r11,r9
8000d11c:	f7 be 03 01 	sublo	lr,1
8000d120:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d124:	12 1b       	sub	r11,r9
8000d126:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d12a:	f6 03 0d 02 	divu	r2,r11,r3
8000d12e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d132:	04 99       	mov	r9,r2
8000d134:	e4 05 02 4b 	mul	r11,r2,r5
8000d138:	16 38       	cp.w	r8,r11
8000d13a:	c0 a2       	brcc	8000d14e <__avr32_udiv64+0x11e>
8000d13c:	20 19       	sub	r9,1
8000d13e:	18 08       	add	r8,r12
8000d140:	18 38       	cp.w	r8,r12
8000d142:	c0 63       	brcs	8000d14e <__avr32_udiv64+0x11e>
8000d144:	16 38       	cp.w	r8,r11
8000d146:	f7 b9 03 01 	sublo	r9,1
8000d14a:	f1 dc e3 08 	addcs	r8,r8,r12
8000d14e:	f4 06 09 43 	lsl	r3,r10,r6
8000d152:	f0 0b 01 0b 	sub	r11,r8,r11
8000d156:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d15a:	f8 06 16 10 	lsr	r6,r12,0x10
8000d15e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d162:	f6 06 0d 00 	divu	r0,r11,r6
8000d166:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d16a:	00 9a       	mov	r10,r0
8000d16c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d170:	e0 0e 02 48 	mul	r8,r0,lr
8000d174:	10 3b       	cp.w	r11,r8
8000d176:	c0 a2       	brcc	8000d18a <__avr32_udiv64+0x15a>
8000d178:	20 1a       	sub	r10,1
8000d17a:	18 0b       	add	r11,r12
8000d17c:	18 3b       	cp.w	r11,r12
8000d17e:	c0 63       	brcs	8000d18a <__avr32_udiv64+0x15a>
8000d180:	10 3b       	cp.w	r11,r8
8000d182:	f7 ba 03 01 	sublo	r10,1
8000d186:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d18a:	f6 08 01 01 	sub	r1,r11,r8
8000d18e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d192:	e2 06 0d 00 	divu	r0,r1,r6
8000d196:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d19a:	00 98       	mov	r8,r0
8000d19c:	e0 0e 02 4b 	mul	r11,r0,lr
8000d1a0:	16 33       	cp.w	r3,r11
8000d1a2:	c0 82       	brcc	8000d1b2 <__avr32_udiv64+0x182>
8000d1a4:	20 18       	sub	r8,1
8000d1a6:	18 03       	add	r3,r12
8000d1a8:	18 33       	cp.w	r3,r12
8000d1aa:	c0 43       	brcs	8000d1b2 <__avr32_udiv64+0x182>
8000d1ac:	16 33       	cp.w	r3,r11
8000d1ae:	f7 b8 03 01 	sublo	r8,1
8000d1b2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d1b6:	c6 98       	rjmp	8000d288 <__avr32_udiv64+0x258>
8000d1b8:	16 39       	cp.w	r9,r11
8000d1ba:	e0 8b 00 65 	brhi	8000d284 <__avr32_udiv64+0x254>
8000d1be:	f2 09 12 00 	clz	r9,r9
8000d1c2:	c0 b1       	brne	8000d1d8 <__avr32_udiv64+0x1a8>
8000d1c4:	10 3a       	cp.w	r10,r8
8000d1c6:	5f 2a       	srhs	r10
8000d1c8:	1c 3b       	cp.w	r11,lr
8000d1ca:	5f b8       	srhi	r8
8000d1cc:	10 4a       	or	r10,r8
8000d1ce:	f2 0a 18 00 	cp.b	r10,r9
8000d1d2:	c5 90       	breq	8000d284 <__avr32_udiv64+0x254>
8000d1d4:	30 18       	mov	r8,1
8000d1d6:	c5 98       	rjmp	8000d288 <__avr32_udiv64+0x258>
8000d1d8:	f0 09 09 46 	lsl	r6,r8,r9
8000d1dc:	f2 03 11 20 	rsub	r3,r9,32
8000d1e0:	fc 09 09 4e 	lsl	lr,lr,r9
8000d1e4:	f0 03 0a 48 	lsr	r8,r8,r3
8000d1e8:	f6 09 09 4c 	lsl	r12,r11,r9
8000d1ec:	f4 03 0a 42 	lsr	r2,r10,r3
8000d1f0:	ef 46 ff f4 	st.w	r7[-12],r6
8000d1f4:	f6 03 0a 43 	lsr	r3,r11,r3
8000d1f8:	18 42       	or	r2,r12
8000d1fa:	f1 ee 10 0c 	or	r12,r8,lr
8000d1fe:	f8 01 16 10 	lsr	r1,r12,0x10
8000d202:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d206:	e6 01 0d 04 	divu	r4,r3,r1
8000d20a:	e4 03 16 10 	lsr	r3,r2,0x10
8000d20e:	08 9e       	mov	lr,r4
8000d210:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d214:	e8 06 02 48 	mul	r8,r4,r6
8000d218:	10 33       	cp.w	r3,r8
8000d21a:	c0 a2       	brcc	8000d22e <__avr32_udiv64+0x1fe>
8000d21c:	20 1e       	sub	lr,1
8000d21e:	18 03       	add	r3,r12
8000d220:	18 33       	cp.w	r3,r12
8000d222:	c0 63       	brcs	8000d22e <__avr32_udiv64+0x1fe>
8000d224:	10 33       	cp.w	r3,r8
8000d226:	f7 be 03 01 	sublo	lr,1
8000d22a:	e7 dc e3 03 	addcs	r3,r3,r12
8000d22e:	10 13       	sub	r3,r8
8000d230:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d234:	e6 01 0d 00 	divu	r0,r3,r1
8000d238:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d23c:	00 98       	mov	r8,r0
8000d23e:	e0 06 02 46 	mul	r6,r0,r6
8000d242:	0c 3b       	cp.w	r11,r6
8000d244:	c0 a2       	brcc	8000d258 <__avr32_udiv64+0x228>
8000d246:	20 18       	sub	r8,1
8000d248:	18 0b       	add	r11,r12
8000d24a:	18 3b       	cp.w	r11,r12
8000d24c:	c0 63       	brcs	8000d258 <__avr32_udiv64+0x228>
8000d24e:	0c 3b       	cp.w	r11,r6
8000d250:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d254:	f7 b8 03 01 	sublo	r8,1
8000d258:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d25c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d260:	0c 1b       	sub	r11,r6
8000d262:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d266:	06 95       	mov	r5,r3
8000d268:	16 35       	cp.w	r5,r11
8000d26a:	e0 8b 00 0a 	brhi	8000d27e <__avr32_udiv64+0x24e>
8000d26e:	5f 0b       	sreq	r11
8000d270:	f4 09 09 49 	lsl	r9,r10,r9
8000d274:	12 32       	cp.w	r2,r9
8000d276:	5f b9       	srhi	r9
8000d278:	f7 e9 00 09 	and	r9,r11,r9
8000d27c:	c0 60       	breq	8000d288 <__avr32_udiv64+0x258>
8000d27e:	20 18       	sub	r8,1
8000d280:	30 09       	mov	r9,0
8000d282:	c0 38       	rjmp	8000d288 <__avr32_udiv64+0x258>
8000d284:	30 09       	mov	r9,0
8000d286:	12 98       	mov	r8,r9
8000d288:	10 9a       	mov	r10,r8
8000d28a:	12 93       	mov	r3,r9
8000d28c:	10 92       	mov	r2,r8
8000d28e:	12 9b       	mov	r11,r9
8000d290:	2f dd       	sub	sp,-12
8000d292:	d8 32       	popm	r0-r7,pc

8000d294 <__avr32_umod64>:
8000d294:	d4 31       	pushm	r0-r7,lr
8000d296:	1a 97       	mov	r7,sp
8000d298:	20 3d       	sub	sp,12
8000d29a:	10 9c       	mov	r12,r8
8000d29c:	12 95       	mov	r5,r9
8000d29e:	14 9e       	mov	lr,r10
8000d2a0:	16 91       	mov	r1,r11
8000d2a2:	16 96       	mov	r6,r11
8000d2a4:	58 09       	cp.w	r9,0
8000d2a6:	e0 81 00 81 	brne	8000d3a8 <__avr32_umod64+0x114>
8000d2aa:	16 38       	cp.w	r8,r11
8000d2ac:	e0 88 00 12 	brls	8000d2d0 <__avr32_umod64+0x3c>
8000d2b0:	f0 08 12 00 	clz	r8,r8
8000d2b4:	c4 e0       	breq	8000d350 <__avr32_umod64+0xbc>
8000d2b6:	f6 08 09 46 	lsl	r6,r11,r8
8000d2ba:	f8 08 09 4c 	lsl	r12,r12,r8
8000d2be:	f0 0b 11 20 	rsub	r11,r8,32
8000d2c2:	f4 08 09 4e 	lsl	lr,r10,r8
8000d2c6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d2ca:	f7 e6 10 06 	or	r6,r11,r6
8000d2ce:	c4 18       	rjmp	8000d350 <__avr32_umod64+0xbc>
8000d2d0:	58 08       	cp.w	r8,0
8000d2d2:	c0 51       	brne	8000d2dc <__avr32_umod64+0x48>
8000d2d4:	30 19       	mov	r9,1
8000d2d6:	f2 08 0d 08 	divu	r8,r9,r8
8000d2da:	10 9c       	mov	r12,r8
8000d2dc:	f8 08 12 00 	clz	r8,r12
8000d2e0:	c0 31       	brne	8000d2e6 <__avr32_umod64+0x52>
8000d2e2:	18 16       	sub	r6,r12
8000d2e4:	c3 68       	rjmp	8000d350 <__avr32_umod64+0xbc>
8000d2e6:	f0 03 11 20 	rsub	r3,r8,32
8000d2ea:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d2ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000d2f2:	ec 08 09 49 	lsl	r9,r6,r8
8000d2f6:	ec 03 0a 43 	lsr	r3,r6,r3
8000d2fa:	f7 e9 10 09 	or	r9,r11,r9
8000d2fe:	f8 05 16 10 	lsr	r5,r12,0x10
8000d302:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d306:	e6 05 0d 02 	divu	r2,r3,r5
8000d30a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d30e:	ec 02 02 4b 	mul	r11,r6,r2
8000d312:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d316:	16 3e       	cp.w	lr,r11
8000d318:	c0 72       	brcc	8000d326 <__avr32_umod64+0x92>
8000d31a:	18 0e       	add	lr,r12
8000d31c:	18 3e       	cp.w	lr,r12
8000d31e:	c0 43       	brcs	8000d326 <__avr32_umod64+0x92>
8000d320:	16 3e       	cp.w	lr,r11
8000d322:	fd dc e3 0e 	addcs	lr,lr,r12
8000d326:	fc 0b 01 03 	sub	r3,lr,r11
8000d32a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d32e:	e6 05 0d 02 	divu	r2,r3,r5
8000d332:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d336:	a5 36       	mul	r6,r2
8000d338:	0c 39       	cp.w	r9,r6
8000d33a:	c0 72       	brcc	8000d348 <__avr32_umod64+0xb4>
8000d33c:	18 09       	add	r9,r12
8000d33e:	18 39       	cp.w	r9,r12
8000d340:	c0 43       	brcs	8000d348 <__avr32_umod64+0xb4>
8000d342:	0c 39       	cp.w	r9,r6
8000d344:	f3 dc e3 09 	addcs	r9,r9,r12
8000d348:	f2 06 01 06 	sub	r6,r9,r6
8000d34c:	f4 08 09 4e 	lsl	lr,r10,r8
8000d350:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d354:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d358:	ec 0a 0d 02 	divu	r2,r6,r10
8000d35c:	fc 09 16 10 	lsr	r9,lr,0x10
8000d360:	ea 02 02 4b 	mul	r11,r5,r2
8000d364:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d368:	16 39       	cp.w	r9,r11
8000d36a:	c0 72       	brcc	8000d378 <__avr32_umod64+0xe4>
8000d36c:	18 09       	add	r9,r12
8000d36e:	18 39       	cp.w	r9,r12
8000d370:	c0 43       	brcs	8000d378 <__avr32_umod64+0xe4>
8000d372:	16 39       	cp.w	r9,r11
8000d374:	f3 dc e3 09 	addcs	r9,r9,r12
8000d378:	f2 0b 01 0b 	sub	r11,r9,r11
8000d37c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d380:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d384:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000d388:	ea 0a 02 4a 	mul	r10,r5,r10
8000d38c:	14 3e       	cp.w	lr,r10
8000d38e:	c0 72       	brcc	8000d39c <__avr32_umod64+0x108>
8000d390:	18 0e       	add	lr,r12
8000d392:	18 3e       	cp.w	lr,r12
8000d394:	c0 43       	brcs	8000d39c <__avr32_umod64+0x108>
8000d396:	14 3e       	cp.w	lr,r10
8000d398:	fd dc e3 0e 	addcs	lr,lr,r12
8000d39c:	fc 0a 01 0a 	sub	r10,lr,r10
8000d3a0:	30 0b       	mov	r11,0
8000d3a2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000d3a6:	c7 b8       	rjmp	8000d49c <__avr32_umod64+0x208>
8000d3a8:	16 39       	cp.w	r9,r11
8000d3aa:	e0 8b 00 79 	brhi	8000d49c <__avr32_umod64+0x208>
8000d3ae:	f2 09 12 00 	clz	r9,r9
8000d3b2:	c1 21       	brne	8000d3d6 <__avr32_umod64+0x142>
8000d3b4:	10 3a       	cp.w	r10,r8
8000d3b6:	5f 2b       	srhs	r11
8000d3b8:	0a 31       	cp.w	r1,r5
8000d3ba:	5f ba       	srhi	r10
8000d3bc:	f7 ea 10 0a 	or	r10,r11,r10
8000d3c0:	f2 0a 18 00 	cp.b	r10,r9
8000d3c4:	c0 60       	breq	8000d3d0 <__avr32_umod64+0x13c>
8000d3c6:	fc 08 01 0c 	sub	r12,lr,r8
8000d3ca:	e2 05 01 46 	sbc	r6,r1,r5
8000d3ce:	18 9e       	mov	lr,r12
8000d3d0:	0c 9b       	mov	r11,r6
8000d3d2:	1c 9a       	mov	r10,lr
8000d3d4:	c6 48       	rjmp	8000d49c <__avr32_umod64+0x208>
8000d3d6:	ea 09 09 4c 	lsl	r12,r5,r9
8000d3da:	f2 06 11 20 	rsub	r6,r9,32
8000d3de:	f6 09 09 4b 	lsl	r11,r11,r9
8000d3e2:	f0 09 09 42 	lsl	r2,r8,r9
8000d3e6:	ef 46 ff f4 	st.w	r7[-12],r6
8000d3ea:	f0 06 0a 48 	lsr	r8,r8,r6
8000d3ee:	18 48       	or	r8,r12
8000d3f0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000d3f4:	f4 09 09 43 	lsl	r3,r10,r9
8000d3f8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000d3fc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000d400:	16 4a       	or	r10,r11
8000d402:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d406:	f8 0b 0d 04 	divu	r4,r12,r11
8000d40a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000d40e:	08 91       	mov	r1,r4
8000d410:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000d414:	e8 0e 02 46 	mul	r6,r4,lr
8000d418:	0c 3c       	cp.w	r12,r6
8000d41a:	c0 a2       	brcc	8000d42e <__avr32_umod64+0x19a>
8000d41c:	20 11       	sub	r1,1
8000d41e:	10 0c       	add	r12,r8
8000d420:	10 3c       	cp.w	r12,r8
8000d422:	c0 63       	brcs	8000d42e <__avr32_umod64+0x19a>
8000d424:	0c 3c       	cp.w	r12,r6
8000d426:	f7 b1 03 01 	sublo	r1,1
8000d42a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000d42e:	0c 1c       	sub	r12,r6
8000d430:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000d434:	f8 0b 0d 04 	divu	r4,r12,r11
8000d438:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000d43c:	08 96       	mov	r6,r4
8000d43e:	e8 0e 02 4e 	mul	lr,r4,lr
8000d442:	1c 3b       	cp.w	r11,lr
8000d444:	c0 a2       	brcc	8000d458 <__avr32_umod64+0x1c4>
8000d446:	20 16       	sub	r6,1
8000d448:	10 0b       	add	r11,r8
8000d44a:	10 3b       	cp.w	r11,r8
8000d44c:	c0 63       	brcs	8000d458 <__avr32_umod64+0x1c4>
8000d44e:	1c 3b       	cp.w	r11,lr
8000d450:	f7 b6 03 01 	sublo	r6,1
8000d454:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000d458:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000d45c:	1c 1b       	sub	r11,lr
8000d45e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000d462:	00 9e       	mov	lr,r0
8000d464:	02 9c       	mov	r12,r1
8000d466:	16 3c       	cp.w	r12,r11
8000d468:	e0 8b 00 08 	brhi	8000d478 <__avr32_umod64+0x1e4>
8000d46c:	5f 06       	sreq	r6
8000d46e:	06 30       	cp.w	r0,r3
8000d470:	5f ba       	srhi	r10
8000d472:	ed ea 00 0a 	and	r10,r6,r10
8000d476:	c0 60       	breq	8000d482 <__avr32_umod64+0x1ee>
8000d478:	fc 02 01 04 	sub	r4,lr,r2
8000d47c:	f8 08 01 4c 	sbc	r12,r12,r8
8000d480:	08 9e       	mov	lr,r4
8000d482:	e6 0e 01 0a 	sub	r10,r3,lr
8000d486:	f6 0c 01 4c 	sbc	r12,r11,r12
8000d48a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000d48e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000d492:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d496:	f8 01 09 4c 	lsl	r12,r12,r1
8000d49a:	18 4a       	or	r10,r12
8000d49c:	2f dd       	sub	sp,-12
8000d49e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d600:	c0 08       	rjmp	8000d600 <_evba>
	...

8000d604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d604:	c0 08       	rjmp	8000d604 <_handle_TLB_Multiple_Hit>
	...

8000d608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d608:	c0 08       	rjmp	8000d608 <_handle_Bus_Error_Data_Fetch>
	...

8000d60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d60c:	c0 08       	rjmp	8000d60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d610:	c0 08       	rjmp	8000d610 <_handle_NMI>
	...

8000d614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d614:	c0 08       	rjmp	8000d614 <_handle_Instruction_Address>
	...

8000d618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d618:	c0 08       	rjmp	8000d618 <_handle_ITLB_Protection>
	...

8000d61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d61c:	c0 08       	rjmp	8000d61c <_handle_Breakpoint>
	...

8000d620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d620:	c0 08       	rjmp	8000d620 <_handle_Illegal_Opcode>
	...

8000d624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d624:	c0 08       	rjmp	8000d624 <_handle_Unimplemented_Instruction>
	...

8000d628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d628:	c0 08       	rjmp	8000d628 <_handle_Privilege_Violation>
	...

8000d62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d62c:	c0 08       	rjmp	8000d62c <_handle_Floating_Point>
	...

8000d630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d630:	c0 08       	rjmp	8000d630 <_handle_Coprocessor_Absent>
	...

8000d634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d634:	c0 08       	rjmp	8000d634 <_handle_Data_Address_Read>
	...

8000d638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d638:	c0 08       	rjmp	8000d638 <_handle_Data_Address_Write>
	...

8000d63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d63c:	c0 08       	rjmp	8000d63c <_handle_DTLB_Protection_Read>
	...

8000d640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d640:	c0 08       	rjmp	8000d640 <_handle_DTLB_Protection_Write>
	...

8000d644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d644:	c0 08       	rjmp	8000d644 <_handle_DTLB_Modified>
	...

8000d650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d650:	c0 08       	rjmp	8000d650 <_handle_ITLB_Miss>
	...

8000d660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d660:	c0 08       	rjmp	8000d660 <_handle_DTLB_Miss_Read>
	...

8000d670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d670:	c0 08       	rjmp	8000d670 <_handle_DTLB_Miss_Write>
	...

8000d700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d700:	fe cf 71 28 	sub	pc,pc,28968

8000d704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d704:	30 0c       	mov	r12,0
8000d706:	fe b0 c3 77 	rcall	80005df4 <_get_interrupt_handler>
8000d70a:	58 0c       	cp.w	r12,0
8000d70c:	f8 0f 17 10 	movne	pc,r12
8000d710:	d6 03       	rete

8000d712 <_int1>:
8000d712:	30 1c       	mov	r12,1
8000d714:	fe b0 c3 70 	rcall	80005df4 <_get_interrupt_handler>
8000d718:	58 0c       	cp.w	r12,0
8000d71a:	f8 0f 17 10 	movne	pc,r12
8000d71e:	d6 03       	rete

8000d720 <_int2>:
8000d720:	30 2c       	mov	r12,2
8000d722:	fe b0 c3 69 	rcall	80005df4 <_get_interrupt_handler>
8000d726:	58 0c       	cp.w	r12,0
8000d728:	f8 0f 17 10 	movne	pc,r12
8000d72c:	d6 03       	rete

8000d72e <_int3>:
8000d72e:	30 3c       	mov	r12,3
8000d730:	fe b0 c3 62 	rcall	80005df4 <_get_interrupt_handler>
8000d734:	58 0c       	cp.w	r12,0
8000d736:	f8 0f 17 10 	movne	pc,r12
8000d73a:	d6 03       	rete

8000d73c <ipr_val>:
8000d73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7fc:	d7 03 d7 03                                         ....
