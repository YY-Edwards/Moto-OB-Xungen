
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009d54  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001108  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a2c  00000004  8000d108  0000d804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000036c8  00000a30  8000db34  0000e230  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000e230  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001048  00000000  00000000  0000e260  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00002304  00000000  00000000  0000f2a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000262b4  00000000  00000000  000115ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00006295  00000000  00000000  00037860  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00013afb  00000000  00000000  0003daf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002ac8  00000000  00000000  000515f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000698f  00000000  00000000  000540b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000c31c  00000000  00000000  0005aa47  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macinfo 01296bd6  00000000  00000000  00066d63  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001140  00000000  00000000  012fd940  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d2 7c 	sub	pc,pc,-11652

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 70       	ld.ub	r0,--r6

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 48       	or	r8,r5

8000203c <app_init>:
														
		
};

void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	40 84       	lddsp	r4,sp[0x20]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 2c       	sub	r12,-126
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 cc       	sub	r12,-116
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c0 00       	breq	80002082 <app_init+0x46>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	5c 7c       	castu.h	r12
8000208c:	00 00       	add	r0,r0
8000208e:	0a 40       	or	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
8000209c:	49 74       	lddpc	r4,800020f8 <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000209e:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a0:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a2:	30 22       	mov	r2,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a4:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 97       	mov	r7,r8
800020a8:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c1 71       	brne	800020e2 <app_cfg+0x52>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800020b6:	f0 1f 00 12 	mcall	800020fc <app_cfg+0x6c>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 31       	brne	800020c4 <app_cfg+0x34>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c0:	89 03       	st.w	r4[0x0],r3
800020c2:	c1 08       	rjmp	800020e2 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c4:	58 18       	cp.w	r8,1
800020c6:	c0 31       	brne	800020cc <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020c8:	89 02       	st.w	r4[0x0],r2
800020ca:	c0 c8       	rjmp	800020e2 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020cc:	58 28       	cp.w	r8,2
800020ce:	c0 31       	brne	800020d4 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d0:	89 01       	st.w	r4[0x0],r1
800020d2:	c0 88       	rjmp	800020e2 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d4:	58 38       	cp.w	r8,3
800020d6:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020da:	f7 b8 01 ff 	subne	r8,-1
800020de:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e2:	0a 9b       	mov	r11,r5
800020e4:	0e 9c       	mov	r12,r7
800020e6:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020ea:	ce 1b       	rjmp	800020ac <app_cfg+0x1c>
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	59 b4       	cp.w	r4,27
800020f0:	00 00       	add	r0,r0
800020f2:	0a 38       	cp.w	r8,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d 70       	ld.ub	r0,--r6
800020f8:	00 00       	add	r0,r0
800020fa:	0a 34       	cp.w	r4,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	41 84       	lddsp	r4,sp[0x60]
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	5b 1c       	cp.w	r12,-15

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	c0 08       	rjmp	80002112 <app_payload_tx_proc+0xe>
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	60 40       	ld.w	r0,r0[0x10]

80002118 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002118:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211a:	48 3c       	lddpc	r12,80002124 <FD_brdcst_func+0xc>
8000211c:	f0 1f 00 03 	mcall	80002128 <FD_brdcst_func+0x10>
	
}
80002120:	d8 02       	popm	pc
80002122:	00 00       	add	r0,r0
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	c0 0c       	rcall	80002126 <FD_brdcst_func+0xe>
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	60 40       	ld.w	r0,r0[0x10]

8000212c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000212c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000212e:	48 3c       	lddpc	r12,80002138 <FD_reply_func+0xc>
80002130:	f0 1f 00 03 	mcall	8000213c <FD_reply_func+0x10>
	
	
}
80002134:	d8 02       	popm	pc
80002136:	00 00       	add	r0,r0
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	c0 2c       	rcall	8000213e <FD_reply_func+0x12>
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	60 40       	ld.w	r0,r0[0x10]

80002140 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002140:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002142:	48 3c       	lddpc	r12,8000214c <FD_request_func+0xc>
80002144:	f0 1f 00 03 	mcall	80002150 <FD_request_func+0x10>
	
	
}
80002148:	d8 02       	popm	pc
8000214a:	00 00       	add	r0,r0
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	c0 48       	rjmp	80002156 <EnOB_brdcst_func+0x2>
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	60 40       	ld.w	r0,r0[0x10]

80002154 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002154:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002156:	48 3c       	lddpc	r12,80002160 <EnOB_brdcst_func+0xc>
80002158:	f0 1f 00 03 	mcall	80002164 <EnOB_brdcst_func+0x10>
}
8000215c:	d8 02       	popm	pc
8000215e:	00 00       	add	r0,r0
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	c0 64       	brge	8000216e <EnOB_reply_func+0x6>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	60 40       	ld.w	r0,r0[0x10]

80002168 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	30 08       	mov	r8,0
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c1 91       	brne	800021a8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002178:	19 b8       	ld.ub	r8,r12[0x3]
8000217a:	30 19       	mov	r9,1
8000217c:	f2 08 18 00 	cp.b	r8,r9
80002180:	c0 61       	brne	8000218c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002182:	49 0c       	lddpc	r12,800021c0 <EnOB_reply_func+0x58>
80002184:	f0 1f 00 10 	mcall	800021c4 <EnOB_reply_func+0x5c>
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000218c:	58 08       	cp.w	r8,0
8000218e:	c0 61       	brne	8000219a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002190:	48 ec       	lddpc	r12,800021c8 <EnOB_reply_func+0x60>
80002192:	f0 1f 00 0d 	mcall	800021c4 <EnOB_reply_func+0x5c>
80002196:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219a:	1a d8       	st.w	--sp,r8
8000219c:	48 cc       	lddpc	r12,800021cc <EnOB_reply_func+0x64>
8000219e:	f0 1f 00 0a 	mcall	800021c4 <EnOB_reply_func+0x5c>
800021a2:	2f fd       	sub	sp,-4
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <EnOB_reply_func+0x68>
800021aa:	f0 1f 00 07 	mcall	800021c4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ae:	0f a8       	ld.ub	r8,r7[0x2]
800021b0:	1a d8       	st.w	--sp,r8
800021b2:	48 9c       	lddpc	r12,800021d4 <EnOB_reply_func+0x6c>
800021b4:	f0 1f 00 04 	mcall	800021c4 <EnOB_reply_func+0x5c>
800021b8:	2f fd       	sub	sp,-4
800021ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800021be:	00 00       	add	r0,r0
800021c0:	80 00       	ld.sh	r0,r0[0x0]
800021c2:	c0 7c       	rcall	800021d0 <EnOB_reply_func+0x68>
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	60 40       	ld.w	r0,r0[0x10]
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	c0 94       	brge	800021dc <SingleDetection_brdcst_func+0x4>
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	c0 a8       	rjmp	800021e2 <SingleDetection_brdcst_func+0xa>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c0 c0       	breq	800021ea <SingleDetection_brdcst_func+0x12>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	c0 dc       	rcall	800021f0 <SingleDetection_brdcst_func+0x18>

800021d8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021d8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021da:	19 a9       	ld.ub	r9,r12[0x2]
800021dc:	31 18       	mov	r8,17
800021de:	f0 09 18 00 	cp.b	r9,r8
800021e2:	c0 41       	brne	800021ea <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021e4:	48 2c       	lddpc	r12,800021ec <SingleDetection_brdcst_func+0x14>
800021e6:	f0 1f 00 03 	mcall	800021f0 <SingleDetection_brdcst_func+0x18>
800021ea:	d8 02       	popm	pc
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c0 f4       	brge	8000220c <ButtonConfig_brdcst_func+0x18>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	60 40       	ld.w	r0,r0[0x10]

800021f4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021f6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021fa:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021fc:	4a bc       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xb4>
800021fe:	f0 1f 00 2c 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002202:	0f 88       	ld.ub	r8,r7[0x0]
80002204:	1a d8       	st.w	--sp,r8
80002206:	4a bc       	lddpc	r12,800022b0 <ButtonConfig_brdcst_func+0xbc>
80002208:	f0 1f 00 29 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000220c:	1a d5       	st.w	--sp,r5
8000220e:	4a ac       	lddpc	r12,800022b4 <ButtonConfig_brdcst_func+0xc0>
80002210:	f0 1f 00 27 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002214:	0f a8       	ld.ub	r8,r7[0x2]
80002216:	1a d8       	st.w	--sp,r8
80002218:	4a 8c       	lddpc	r12,800022b8 <ButtonConfig_brdcst_func+0xc4>
8000221a:	f0 1f 00 25 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000221e:	2f dd       	sub	sp,-12
80002220:	58 05       	cp.w	r5,0
80002222:	c4 10       	breq	800022a4 <ButtonConfig_brdcst_func+0xb0>
80002224:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002226:	4a 64       	lddpc	r4,800022bc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002228:	4a 63       	lddpc	r3,800022c0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000222a:	4a 72       	lddpc	r2,800022c4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000222c:	4a 71       	lddpc	r1,800022c8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000222e:	4a 80       	lddpc	r0,800022cc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002230:	0f b9       	ld.ub	r9,r7[0x3]
80002232:	0f c8       	ld.ub	r8,r7[0x4]
80002234:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002238:	1a d8       	st.w	--sp,r8
8000223a:	1a d6       	st.w	--sp,r6
8000223c:	08 9c       	mov	r12,r4
8000223e:	f0 1f 00 1c 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002242:	0f d9       	ld.ub	r9,r7[0x5]
80002244:	0f e8       	ld.ub	r8,r7[0x6]
80002246:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	1a d6       	st.w	--sp,r6
8000224e:	06 9c       	mov	r12,r3
80002250:	f0 1f 00 17 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002254:	0f f9       	ld.ub	r9,r7[0x7]
80002256:	ef 38 00 08 	ld.ub	r8,r7[8]
8000225a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000225e:	1a d8       	st.w	--sp,r8
80002260:	1a d6       	st.w	--sp,r6
80002262:	04 9c       	mov	r12,r2
80002264:	f0 1f 00 12 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002268:	ef 39 00 09 	ld.ub	r9,r7[9]
8000226c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002270:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002274:	1a d8       	st.w	--sp,r8
80002276:	1a d6       	st.w	--sp,r6
80002278:	02 9c       	mov	r12,r1
8000227a:	f0 1f 00 0d 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000227e:	2f 8d       	sub	sp,-32
80002280:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002284:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002288:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000228c:	1a d8       	st.w	--sp,r8
8000228e:	1a d6       	st.w	--sp,r6
80002290:	00 9c       	mov	r12,r0
80002292:	f0 1f 00 07 	mcall	800022ac <ButtonConfig_brdcst_func+0xb8>
80002296:	2f f6       	sub	r6,-1
80002298:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000229a:	2f ed       	sub	sp,-8
8000229c:	ec 05 18 00 	cp.b	r5,r6
800022a0:	fe 9b ff c8 	brhi	80002230 <ButtonConfig_brdcst_func+0x3c>
800022a4:	d8 32       	popm	r0-r7,pc
800022a6:	00 00       	add	r0,r0
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	c1 08       	rjmp	800022ca <ButtonConfig_brdcst_func+0xd6>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	60 40       	ld.w	r0,r0[0x10]
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	c1 28       	rjmp	800022d6 <Phyuserinput_brdcst_func+0x6>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	c1 3c       	rcall	800022dc <Phyuserinput_brdcst_func+0xc>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c1 54       	brge	800022e4 <Phyuserinput_brdcst_func+0x14>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	c1 74       	brge	800022ec <Phyuserinput_brdcst_func+0x1c>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c1 9c       	rcall	800022f4 <Phyuserinput_brdcst_func+0x24>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c1 c4       	brge	800022fe <Phyuserinput_brdcst_func+0x2e>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c1 e8       	rjmp	80002306 <Phyuserinput_brdcst_func+0x36>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c2 10       	breq	80002310 <Phyuserinput_brdcst_func+0x40>

800022d0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022d0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022d4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022d6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022d8:	19 c7       	ld.ub	r7,r12[0x4]
800022da:	19 d8       	ld.ub	r8,r12[0x5]
800022dc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022e0:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022e2:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
800022e4:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
800022e8:	49 0c       	lddpc	r12,80002328 <Phyuserinput_brdcst_func+0x58>
800022ea:	f0 1f 00 11 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022ee:	1a d6       	st.w	--sp,r6
800022f0:	49 0c       	lddpc	r12,80002330 <Phyuserinput_brdcst_func+0x60>
800022f2:	f0 1f 00 0f 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022f6:	1a d5       	st.w	--sp,r5
800022f8:	48 fc       	lddpc	r12,80002334 <Phyuserinput_brdcst_func+0x64>
800022fa:	f0 1f 00 0d 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022fe:	5c 77       	castu.h	r7
80002300:	1a d7       	st.w	--sp,r7
80002302:	48 ec       	lddpc	r12,80002338 <Phyuserinput_brdcst_func+0x68>
80002304:	f0 1f 00 0a 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002308:	1a d4       	st.w	--sp,r4
8000230a:	48 dc       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x6c>
8000230c:	f0 1f 00 08 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002310:	1a d3       	st.w	--sp,r3
80002312:	48 cc       	lddpc	r12,80002340 <Phyuserinput_brdcst_func+0x70>
80002314:	f0 1f 00 06 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002318:	1a d2       	st.w	--sp,r2
8000231a:	48 bc       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x74>
8000231c:	f0 1f 00 04 	mcall	8000232c <Phyuserinput_brdcst_func+0x5c>
80002320:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002322:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002326:	00 00       	add	r0,r0
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	c2 34       	brge	80002370 <ButtonConfig_reply_func+0x28>
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	60 40       	ld.w	r0,r0[0x10]
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	c2 58       	rjmp	8000237c <ButtonConfig_reply_func+0x34>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	c2 70       	breq	80002384 <ButtonConfig_reply_func+0x3c>
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	c2 84       	brge	8000238a <ButtonConfig_reply_func+0x42>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	c2 98       	rjmp	80002390 <DataSession_brdcst_func+0x4>
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	c2 ac       	rcall	80002396 <DataSession_brdcst_func+0xa>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c2 cc       	rcall	8000239e <DataSession_brdcst_func+0x12>

80002348 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002348:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000234c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002350:	0f 89       	ld.ub	r9,r7[0x0]
80002352:	30 08       	mov	r8,0
80002354:	f0 09 18 00 	cp.b	r9,r8
80002358:	c0 c1       	brne	80002370 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000235a:	48 9c       	lddpc	r12,8000237c <ButtonConfig_reply_func+0x34>
8000235c:	f0 1f 00 09 	mcall	80002380 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002360:	0f 98       	ld.ub	r8,r7[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <ButtonConfig_reply_func+0x3c>
80002366:	f0 1f 00 07 	mcall	80002380 <ButtonConfig_reply_func+0x38>
8000236a:	2f fd       	sub	sp,-4
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002370:	48 6c       	lddpc	r12,80002388 <ButtonConfig_reply_func+0x40>
80002372:	f0 1f 00 04 	mcall	80002380 <ButtonConfig_reply_func+0x38>
80002376:	e3 cd 80 80 	ldm	sp++,r7,pc
8000237a:	00 00       	add	r0,r0
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	c2 ec       	rcall	800023da <DataSession_brdcst_func+0x4e>
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	60 40       	ld.w	r0,r0[0x10]
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	c1 28       	rjmp	800023aa <DataSession_brdcst_func+0x1e>
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	c3 04       	brge	800023ea <DataSession_brdcst_func+0x5e>

8000238c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000238c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000238e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002392:	0d 88       	ld.ub	r8,r6[0x0]
80002394:	32 49       	mov	r9,36
80002396:	f2 08 18 00 	cp.b	r8,r9
8000239a:	c2 91       	brne	800023ec <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000239c:	49 7c       	lddpc	r12,800023f8 <DataSession_brdcst_func+0x6c>
8000239e:	f0 1f 00 18 	mcall	800023fc <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023a2:	0d a5       	ld.ub	r5,r6[0x2]
800023a4:	0d b8       	ld.ub	r8,r6[0x3]
800023a6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023aa:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023ac:	0d 98       	ld.ub	r8,r6[0x1]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 4c       	lddpc	r12,80002400 <DataSession_brdcst_func+0x74>
800023b2:	f0 1f 00 13 	mcall	800023fc <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023b6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023ba:	1a d8       	st.w	--sp,r8
800023bc:	49 2c       	lddpc	r12,80002404 <DataSession_brdcst_func+0x78>
800023be:	f0 1f 00 10 	mcall	800023fc <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023c2:	2f ed       	sub	sp,-8
800023c4:	58 05       	cp.w	r5,0
800023c6:	c1 80       	breq	800023f6 <DataSession_brdcst_func+0x6a>
800023c8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023ca:	49 04       	lddpc	r4,80002408 <DataSession_brdcst_func+0x7c>
800023cc:	ec 07 00 08 	add	r8,r6,r7
800023d0:	11 c8       	ld.ub	r8,r8[0x4]
800023d2:	1a d8       	st.w	--sp,r8
800023d4:	1a d7       	st.w	--sp,r7
800023d6:	08 9c       	mov	r12,r4
800023d8:	f0 1f 00 09 	mcall	800023fc <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023dc:	2f f7       	sub	r7,-1
800023de:	5c 57       	castu.b	r7
800023e0:	2f ed       	sub	sp,-8
800023e2:	ee 05 19 00 	cp.h	r5,r7
800023e6:	fe 9b ff f3 	brhi	800023cc <DataSession_brdcst_func+0x40>
800023ea:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023ec:	1a d8       	st.w	--sp,r8
800023ee:	48 8c       	lddpc	r12,8000240c <DataSession_brdcst_func+0x80>
800023f0:	f0 1f 00 03 	mcall	800023fc <DataSession_brdcst_func+0x70>
800023f4:	2f fd       	sub	sp,-4
800023f6:	d8 22       	popm	r4-r7,pc
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	c3 20       	breq	8000245e <DataSession_reply_func+0x4e>
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	60 40       	ld.w	r0,r0[0x10]
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	c3 34       	brge	80002468 <CallControl_brdcst_func>
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	c3 4c       	rcall	8000246e <CallControl_brdcst_func+0x6>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	c3 68       	rjmp	80002476 <CallControl_brdcst_func+0xe>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	c3 80       	breq	8000247e <CallControl_brdcst_func+0x16>

80002410 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002410:	eb cd 40 80 	pushm	r7,lr
80002414:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002416:	19 a8       	ld.ub	r8,r12[0x2]
80002418:	58 08       	cp.w	r8,0
8000241a:	c0 61       	brne	80002426 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
8000241c:	48 dc       	lddpc	r12,80002450 <DataSession_reply_func+0x40>
8000241e:	f0 1f 00 0e 	mcall	80002454 <DataSession_reply_func+0x44>
80002422:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 cc       	lddpc	r12,80002458 <DataSession_reply_func+0x48>
8000242a:	f0 1f 00 0b 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000242e:	48 cc       	lddpc	r12,8000245c <DataSession_reply_func+0x4c>
80002430:	f0 1f 00 09 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002434:	0f b8       	ld.ub	r8,r7[0x3]
80002436:	1a d8       	st.w	--sp,r8
80002438:	48 ac       	lddpc	r12,80002460 <DataSession_reply_func+0x50>
8000243a:	f0 1f 00 07 	mcall	80002454 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000243e:	0f c8       	ld.ub	r8,r7[0x4]
80002440:	1a d8       	st.w	--sp,r8
80002442:	48 9c       	lddpc	r12,80002464 <DataSession_reply_func+0x54>
80002444:	f0 1f 00 04 	mcall	80002454 <DataSession_reply_func+0x44>
80002448:	2f dd       	sub	sp,-12
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000244e:	00 00       	add	r0,r0
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	c3 94       	brge	800024c4 <TransmitControl_brdcst_func+0x18>
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	60 40       	ld.w	r0,r0[0x10]
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	c3 a8       	rjmp	800024ce <TransmitControl_brdcst_func+0x22>
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	c3 bc       	rcall	800024d4 <TransmitControl_brdcst_func+0x28>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c3 d0       	breq	800024dc <TransmitControl_brdcst_func+0x30>
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	c3 e0       	breq	800024e2 <TransmitControl_brdcst_func+0x36>

80002468 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002468:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000246c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002470:	0f 98       	ld.ub	r8,r7[0x1]
80002472:	1a d8       	st.w	--sp,r8
80002474:	48 bc       	lddpc	r12,800024a0 <CallControl_brdcst_func+0x38>
80002476:	f0 1f 00 0c 	mcall	800024a4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000247a:	2f fd       	sub	sp,-4
8000247c:	0f 99       	ld.ub	r9,r7[0x1]
8000247e:	30 38       	mov	r8,3
80002480:	f0 09 18 00 	cp.b	r9,r8
80002484:	c0 41       	brne	8000248c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002486:	30 09       	mov	r9,0
80002488:	48 88       	lddpc	r8,800024a8 <CallControl_brdcst_func+0x40>
8000248a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000248c:	0f 99       	ld.ub	r9,r7[0x1]
8000248e:	30 48       	mov	r8,4
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c0 41       	brne	8000249c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002496:	30 19       	mov	r9,1
80002498:	48 48       	lddpc	r8,800024a8 <CallControl_brdcst_func+0x40>
8000249a:	b0 89       	st.b	r8[0x0],r9
8000249c:	e3 cd 80 80 	ldm	sp++,r7,pc
800024a0:	80 00       	ld.sh	r0,r0[0x0]
800024a2:	c3 f0       	breq	80002520 <TransmitControl_reply_func+0x2c>
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	60 40       	ld.w	r0,r0[0x10]
800024a8:	00 00       	add	r0,r0
800024aa:	0a 3e       	cp.w	lr,r5

800024ac <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024ac:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024b0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 08       	mov	r8,0
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 71       	brne	800024ca <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024be:	48 ac       	lddpc	r12,800024e4 <TransmitControl_brdcst_func+0x38>
800024c0:	f0 1f 00 0a 	mcall	800024e8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024c4:	30 09       	mov	r9,0
800024c6:	48 a8       	lddpc	r8,800024ec <TransmitControl_brdcst_func+0x40>
800024c8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ca:	0f 99       	ld.ub	r9,r7[0x1]
800024cc:	30 18       	mov	r8,1
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 71       	brne	800024e0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024d4:	48 7c       	lddpc	r12,800024f0 <TransmitControl_brdcst_func+0x44>
800024d6:	f0 1f 00 05 	mcall	800024e8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024da:	30 19       	mov	r9,1
800024dc:	48 48       	lddpc	r8,800024ec <TransmitControl_brdcst_func+0x40>
800024de:	b0 89       	st.b	r8[0x0],r9
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	c4 08       	rjmp	80002566 <AudioRoutingControl_reply_func+0x12>
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	60 40       	ld.w	r0,r0[0x10]
800024ec:	00 00       	add	r0,r0
800024ee:	0a 3d       	cp.w	sp,r5
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	c4 20       	breq	80002576 <AudioRoutingControl_reply_func+0x22>

800024f4 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024fc:	0f 89       	ld.ub	r9,r7[0x0]
800024fe:	30 08       	mov	r8,0
80002500:	f0 09 18 00 	cp.b	r9,r8
80002504:	c1 61       	brne	80002530 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002506:	48 ec       	lddpc	r12,8000253c <TransmitControl_reply_func+0x48>
80002508:	f0 1f 00 0e 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000250c:	0f 98       	ld.ub	r8,r7[0x1]
8000250e:	1a d8       	st.w	--sp,r8
80002510:	48 dc       	lddpc	r12,80002544 <TransmitControl_reply_func+0x50>
80002512:	f0 1f 00 0c 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002516:	0f a8       	ld.ub	r8,r7[0x2]
80002518:	1a d8       	st.w	--sp,r8
8000251a:	48 cc       	lddpc	r12,80002548 <TransmitControl_reply_func+0x54>
8000251c:	f0 1f 00 09 	mcall	80002540 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002520:	0f b8       	ld.ub	r8,r7[0x3]
80002522:	1a d8       	st.w	--sp,r8
80002524:	48 ac       	lddpc	r12,8000254c <TransmitControl_reply_func+0x58>
80002526:	f0 1f 00 07 	mcall	80002540 <TransmitControl_reply_func+0x4c>
8000252a:	2f dd       	sub	sp,-12
8000252c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002530:	48 8c       	lddpc	r12,80002550 <TransmitControl_reply_func+0x5c>
80002532:	f0 1f 00 04 	mcall	80002540 <TransmitControl_reply_func+0x4c>
80002536:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253a:	00 00       	add	r0,r0
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	c4 34       	brge	800025c4 <Volume_reply_func+0x40>
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	60 40       	ld.w	r0,r0[0x10]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	c4 50       	breq	800025d0 <Volume_reply_func+0x4c>
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	c4 64       	brge	800025d6 <Volume_reply_func+0x52>
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	c4 80       	breq	800025de <Volume_reply_func+0x5a>
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	c4 90       	breq	800025e4 <Volume_reply_func+0x60>

80002554 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002556:	19 a9       	ld.ub	r9,r12[0x2]
80002558:	30 08       	mov	r8,0
8000255a:	f0 09 18 00 	cp.b	r9,r8
8000255e:	c0 71       	brne	8000256c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002560:	48 5c       	lddpc	r12,80002574 <AudioRoutingControl_reply_func+0x20>
80002562:	f0 1f 00 06 	mcall	80002578 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002566:	f0 1f 00 06 	mcall	8000257c <AudioRoutingControl_reply_func+0x28>
8000256a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000256c:	48 5c       	lddpc	r12,80002580 <AudioRoutingControl_reply_func+0x2c>
8000256e:	f0 1f 00 03 	mcall	80002578 <AudioRoutingControl_reply_func+0x24>
80002572:	d8 02       	popm	pc
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c4 a8       	rjmp	8000260a <spk_brdcst_func+0x22>
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	60 40       	ld.w	r0,r0[0x10]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	41 84       	lddsp	r4,sp[0x60]
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	c4 b8       	rjmp	80002618 <spk_brdcst_func+0x30>

80002584 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002584:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002588:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000258c:	0f 89       	ld.ub	r9,r7[0x0]
8000258e:	30 08       	mov	r8,0
80002590:	f0 09 18 00 	cp.b	r9,r8
80002594:	c1 b1       	brne	800025ca <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002596:	0f b8       	ld.ub	r8,r7[0x3]
80002598:	31 09       	mov	r9,16
8000259a:	f2 08 18 00 	cp.b	r8,r9
8000259e:	c0 f1       	brne	800025bc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025a0:	48 dc       	lddpc	r12,800025d4 <Volume_reply_func+0x50>
800025a2:	f0 1f 00 0e 	mcall	800025d8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025a6:	0f 99       	ld.ub	r9,r7[0x1]
800025a8:	0f a8       	ld.ub	r8,r7[0x2]
800025aa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ae:	1a d8       	st.w	--sp,r8
800025b0:	48 bc       	lddpc	r12,800025dc <Volume_reply_func+0x58>
800025b2:	f0 1f 00 0a 	mcall	800025d8 <Volume_reply_func+0x54>
800025b6:	2f fd       	sub	sp,-4
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025bc:	1a d8       	st.w	--sp,r8
800025be:	48 9c       	lddpc	r12,800025e0 <Volume_reply_func+0x5c>
800025c0:	f0 1f 00 06 	mcall	800025d8 <Volume_reply_func+0x54>
800025c4:	2f fd       	sub	sp,-4
800025c6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ca:	48 7c       	lddpc	r12,800025e4 <Volume_reply_func+0x60>
800025cc:	f0 1f 00 03 	mcall	800025d8 <Volume_reply_func+0x54>
800025d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	c4 cc       	rcall	8000266e <mic_brdcst_func+0x6>
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	60 40       	ld.w	r0,r0[0x10]
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	c4 e0       	breq	8000267a <mic_brdcst_func+0x12>
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c4 fc       	rcall	80002680 <mic_brdcst_func+0x18>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	c5 14       	brge	80002688 <mic_brdcst_func+0x20>

800025e8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ea:	19 d9       	ld.ub	r9,r12[0x5]
800025ec:	30 08       	mov	r8,0
800025ee:	f0 09 18 00 	cp.b	r9,r8
800025f2:	c0 81       	brne	80002602 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025f4:	10 99       	mov	r9,r8
800025f6:	48 78       	lddpc	r8,80002610 <spk_brdcst_func+0x28>
800025f8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025fa:	48 7c       	lddpc	r12,80002614 <spk_brdcst_func+0x2c>
800025fc:	f0 1f 00 07 	mcall	80002618 <spk_brdcst_func+0x30>
80002600:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002602:	30 19       	mov	r9,1
80002604:	48 38       	lddpc	r8,80002610 <spk_brdcst_func+0x28>
80002606:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002608:	48 5c       	lddpc	r12,8000261c <spk_brdcst_func+0x34>
8000260a:	f0 1f 00 04 	mcall	80002618 <spk_brdcst_func+0x30>
8000260e:	d8 02       	popm	pc
80002610:	00 00       	add	r0,r0
80002612:	0a 30       	cp.w	r0,r5
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	c5 2c       	rcall	800026ba <mic_brdcst_func+0x52>
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	60 40       	ld.w	r0,r0[0x10]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	c5 3c       	rcall	800026c4 <mic_reply_func+0x4>

80002620 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002620:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002622:	19 a9       	ld.ub	r9,r12[0x2]
80002624:	30 08       	mov	r8,0
80002626:	f0 09 18 00 	cp.b	r9,r8
8000262a:	c0 f1       	brne	80002648 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000262c:	19 e9       	ld.ub	r9,r12[0x6]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 40       	breq	8000263a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002634:	30 19       	mov	r9,1
80002636:	48 98       	lddpc	r8,80002658 <spk_reply_func+0x38>
80002638:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263a:	19 e8       	ld.ub	r8,r12[0x6]
8000263c:	1a d8       	st.w	--sp,r8
8000263e:	48 8c       	lddpc	r12,8000265c <spk_reply_func+0x3c>
80002640:	f0 1f 00 08 	mcall	80002660 <spk_reply_func+0x40>
80002644:	2f fd       	sub	sp,-4
80002646:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002648:	30 09       	mov	r9,0
8000264a:	48 48       	lddpc	r8,80002658 <spk_reply_func+0x38>
8000264c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000264e:	48 6c       	lddpc	r12,80002664 <spk_reply_func+0x44>
80002650:	f0 1f 00 04 	mcall	80002660 <spk_reply_func+0x40>
80002654:	d8 02       	popm	pc
80002656:	00 00       	add	r0,r0
80002658:	00 00       	add	r0,r0
8000265a:	0a 30       	cp.w	r0,r5
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	c5 48       	rjmp	80002706 <mic_reply_func+0x46>
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	60 40       	ld.w	r0,r0[0x10]
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	c5 58       	rjmp	80002710 <mic_reply_func+0x50>

80002668 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002668:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000266c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002670:	0f a9       	ld.ub	r9,r7[0x2]
80002672:	30 08       	mov	r8,0
80002674:	f0 09 18 00 	cp.b	r9,r8
80002678:	c0 71       	brne	80002686 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000267a:	48 dc       	lddpc	r12,800026ac <mic_brdcst_func+0x44>
8000267c:	f0 1f 00 0d 	mcall	800026b0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002680:	30 09       	mov	r9,0
80002682:	48 d8       	lddpc	r8,800026b4 <mic_brdcst_func+0x4c>
80002684:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002686:	0f a9       	ld.ub	r9,r7[0x2]
80002688:	31 18       	mov	r8,17
8000268a:	f0 09 18 00 	cp.b	r9,r8
8000268e:	c0 d1       	brne	800026a8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002690:	48 ac       	lddpc	r12,800026b8 <mic_brdcst_func+0x50>
80002692:	f0 1f 00 08 	mcall	800026b0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002696:	48 89       	lddpc	r9,800026b4 <mic_brdcst_func+0x4c>
80002698:	30 18       	mov	r8,1
8000269a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000269c:	13 89       	ld.ub	r9,r9[0x0]
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c0 31       	brne	800026a8 <mic_brdcst_func+0x40>
800026a4:	48 68       	lddpc	r8,800026bc <mic_brdcst_func+0x54>
800026a6:	11 88       	ld.ub	r8,r8[0x0]
800026a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	c5 64       	brge	8000275a <dcm_brdcst_func+0x6>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	60 40       	ld.w	r0,r0[0x10]
800026b4:	00 00       	add	r0,r0
800026b6:	0a 46       	or	r6,r5
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	c5 78       	rjmp	80002768 <dcm_brdcst_func+0x14>
800026bc:	00 00       	add	r0,r0
800026be:	0a 3e       	cp.w	lr,r5

800026c0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026c4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026c8:	49 ac       	lddpc	r12,80002730 <mic_reply_func+0x70>
800026ca:	f0 1f 00 1b 	mcall	80002734 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ce:	0f 89       	ld.ub	r9,r7[0x0]
800026d0:	30 08       	mov	r8,0
800026d2:	f0 09 18 00 	cp.b	r9,r8
800026d6:	c2 71       	brne	80002724 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026d8:	0f 98       	ld.ub	r8,r7[0x1]
800026da:	30 29       	mov	r9,2
800026dc:	f2 08 18 00 	cp.b	r8,r9
800026e0:	c1 b1       	brne	80002716 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026e2:	49 6c       	lddpc	r12,80002738 <mic_reply_func+0x78>
800026e4:	f0 1f 00 14 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026e8:	0f a8       	ld.ub	r8,r7[0x2]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	49 4c       	lddpc	r12,8000273c <mic_reply_func+0x7c>
800026ee:	f0 1f 00 12 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026f2:	0f b8       	ld.ub	r8,r7[0x3]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	49 3c       	lddpc	r12,80002740 <mic_reply_func+0x80>
800026f8:	f0 1f 00 0f 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026fc:	0f c8       	ld.ub	r8,r7[0x4]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	49 1c       	lddpc	r12,80002744 <mic_reply_func+0x84>
80002702:	f0 1f 00 0d 	mcall	80002734 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002706:	0f d8       	ld.ub	r8,r7[0x5]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	49 0c       	lddpc	r12,80002748 <mic_reply_func+0x88>
8000270c:	f0 1f 00 0a 	mcall	80002734 <mic_reply_func+0x74>
80002710:	2f cd       	sub	sp,-16
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002716:	1a d8       	st.w	--sp,r8
80002718:	48 dc       	lddpc	r12,8000274c <mic_reply_func+0x8c>
8000271a:	f0 1f 00 07 	mcall	80002734 <mic_reply_func+0x74>
8000271e:	2f fd       	sub	sp,-4
80002720:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002724:	48 bc       	lddpc	r12,80002750 <mic_reply_func+0x90>
80002726:	f0 1f 00 04 	mcall	80002734 <mic_reply_func+0x74>
8000272a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272e:	00 00       	add	r0,r0
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	c5 8c       	rcall	800027e2 <dcm_reply_func+0x46>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	60 40       	ld.w	r0,r0[0x10]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c5 9c       	rcall	800027ec <dcm_reply_func+0x50>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	c5 b0       	breq	800027f4 <dcm_reply_func+0x58>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	c5 c4       	brge	800027fa <dcm_reply_func+0x5e>
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	c5 e0       	breq	80002802 <dcm_reply_func+0x66>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	c5 f8       	rjmp	80002808 <ToneControl_reply_func+0x4>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c6 10       	breq	80002810 <ToneControl_reply_func+0xc>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	c6 28       	rjmp	80002816 <ToneControl_reply_func+0x12>

80002754 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002754:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002758:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000275c:	48 bc       	lddpc	r12,80002788 <dcm_brdcst_func+0x34>
8000275e:	f0 1f 00 0c 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002762:	0f 88       	ld.ub	r8,r7[0x0]
80002764:	1a d8       	st.w	--sp,r8
80002766:	48 bc       	lddpc	r12,80002790 <dcm_brdcst_func+0x3c>
80002768:	f0 1f 00 09 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000276c:	0f a8       	ld.ub	r8,r7[0x2]
8000276e:	1a d8       	st.w	--sp,r8
80002770:	48 9c       	lddpc	r12,80002794 <dcm_brdcst_func+0x40>
80002772:	f0 1f 00 07 	mcall	8000278c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002776:	0f 98       	ld.ub	r8,r7[0x1]
80002778:	1a d8       	st.w	--sp,r8
8000277a:	48 8c       	lddpc	r12,80002798 <dcm_brdcst_func+0x44>
8000277c:	f0 1f 00 04 	mcall	8000278c <dcm_brdcst_func+0x38>
80002780:	2f dd       	sub	sp,-12
	
	
}
80002782:	e3 cd 80 80 	ldm	sp++,r7,pc
80002786:	00 00       	add	r0,r0
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	c6 38       	rjmp	80002850 <app_payload_rx_proc+0x24>
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	60 40       	ld.w	r0,r0[0x10]
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c6 4c       	rcall	8000285a <app_payload_rx_proc+0x2e>
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	c6 60       	breq	80002862 <app_payload_rx_proc+0x36>
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	c6 78       	rjmp	80002868 <app_payload_rx_proc+0x3c>

8000279c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	eb cd 40 80 	pushm	r7,lr
800027a0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027a2:	19 a9       	ld.ub	r9,r12[0x2]
800027a4:	30 08       	mov	r8,0
800027a6:	f0 09 18 00 	cp.b	r9,r8
800027aa:	c1 b1       	brne	800027e0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027ac:	19 b8       	ld.ub	r8,r12[0x3]
800027ae:	30 19       	mov	r9,1
800027b0:	f2 08 18 00 	cp.b	r8,r9
800027b4:	c0 51       	brne	800027be <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027b6:	48 ec       	lddpc	r12,800027ec <dcm_reply_func+0x50>
800027b8:	f0 1f 00 0e 	mcall	800027f0 <dcm_reply_func+0x54>
800027bc:	c0 a8       	rjmp	800027d0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027be:	58 08       	cp.w	r8,0
800027c0:	c0 51       	brne	800027ca <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027c2:	48 dc       	lddpc	r12,800027f4 <dcm_reply_func+0x58>
800027c4:	f0 1f 00 0b 	mcall	800027f0 <dcm_reply_func+0x54>
800027c8:	c0 48       	rjmp	800027d0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ca:	48 cc       	lddpc	r12,800027f8 <dcm_reply_func+0x5c>
800027cc:	f0 1f 00 09 	mcall	800027f0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027d0:	0f d8       	ld.ub	r8,r7[0x5]
800027d2:	1a d8       	st.w	--sp,r8
800027d4:	48 ac       	lddpc	r12,800027fc <dcm_reply_func+0x60>
800027d6:	f0 1f 00 07 	mcall	800027f0 <dcm_reply_func+0x54>
800027da:	2f fd       	sub	sp,-4
800027dc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027e0:	48 8c       	lddpc	r12,80002800 <dcm_reply_func+0x64>
800027e2:	f0 1f 00 04 	mcall	800027f0 <dcm_reply_func+0x54>
800027e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ea:	00 00       	add	r0,r0
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	c6 94       	brge	800028c0 <CalculateBurst+0x10>
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	60 40       	ld.w	r0,r0[0x10]
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	c6 a8       	rjmp	800028ca <CalculateBurst+0x1a>
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	c6 bc       	rcall	800028d0 <payload_init+0x4>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	c6 d0       	breq	800028d8 <payload_init+0xc>
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	c6 dc       	rcall	800028dc <payload_init+0x10>

80002804 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002804:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002806:	19 a9       	ld.ub	r9,r12[0x2]
80002808:	30 08       	mov	r8,0
8000280a:	f0 09 18 00 	cp.b	r9,r8
8000280e:	c0 51       	brne	80002818 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002810:	48 4c       	lddpc	r12,80002820 <ToneControl_reply_func+0x1c>
80002812:	f0 1f 00 05 	mcall	80002824 <ToneControl_reply_func+0x20>
80002816:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002818:	48 4c       	lddpc	r12,80002828 <ToneControl_reply_func+0x24>
8000281a:	f0 1f 00 03 	mcall	80002824 <ToneControl_reply_func+0x20>
8000281e:	d8 02       	popm	pc
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	c6 e8       	rjmp	800028fe <payload_init+0x32>
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	60 40       	ld.w	r0,r0[0x10]
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	c6 f0       	breq	80002908 <payload_rx_process+0x4>

8000282c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000282c:	eb cd 40 80 	pushm	r7,lr
80002830:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002832:	48 c9       	lddpc	r9,80002860 <app_payload_rx_proc+0x34>
80002834:	13 88       	ld.ub	r8,r9[0x0]
80002836:	2f f8       	sub	r8,-1
80002838:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000283a:	30 39       	mov	r9,3
8000283c:	f2 08 18 00 	cp.b	r8,r9
80002840:	c0 71       	brne	8000284e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002842:	30 09       	mov	r9,0
80002844:	48 78       	lddpc	r8,80002860 <app_payload_rx_proc+0x34>
80002846:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002848:	48 7c       	lddpc	r12,80002864 <app_payload_rx_proc+0x38>
8000284a:	f0 1f 00 08 	mcall	80002868 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000284e:	48 88       	lddpc	r8,8000286c <app_payload_rx_proc+0x40>
80002850:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002852:	48 88       	lddpc	r8,80002870 <app_payload_rx_proc+0x44>
80002854:	70 0c       	ld.w	r12,r8[0x0]
80002856:	0e 9b       	mov	r11,r7
80002858:	f0 1f 00 07 	mcall	80002874 <app_payload_rx_proc+0x48>

}
8000285c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002860:	00 00       	add	r0,r0
80002862:	0a 44       	or	r4,r5
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	c6 fc       	rcall	80002944 <payload_rx_process+0x40>
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	60 40       	ld.w	r0,r0[0x10]
8000286c:	00 00       	add	r0,r0
8000286e:	0a 3c       	cp.w	r12,r5
80002870:	00 00       	add	r0,r0
80002872:	0a 94       	mov	r4,r5
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	29 a4       	sub	r4,-102

80002878 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002878:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000287a:	19 e8       	ld.ub	r8,r12[0x6]
8000287c:	30 19       	mov	r9,1
8000287e:	f2 08 18 00 	cp.b	r8,r9
80002882:	c0 61       	brne	8000288e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002884:	48 98       	lddpc	r8,800028a8 <DeviceInitializationStatus_brdcst_func+0x30>
80002886:	70 09       	ld.w	r9,r8[0x0]
80002888:	a1 a9       	sbr	r9,0x0
8000288a:	91 09       	st.w	r8[0x0],r9
8000288c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000288e:	30 29       	mov	r9,2
80002890:	f2 08 18 00 	cp.b	r8,r9
80002894:	c0 80       	breq	800028a4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002896:	48 58       	lddpc	r8,800028a8 <DeviceInitializationStatus_brdcst_func+0x30>
80002898:	70 09       	ld.w	r9,r8[0x0]
8000289a:	e0 19 ff fc 	andl	r9,0xfffc
8000289e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028a0:	f0 1f 00 03 	mcall	800028ac <DeviceInitializationStatus_brdcst_func+0x34>
800028a4:	d8 02       	popm	pc
800028a6:	00 00       	add	r0,r0
800028a8:	00 00       	add	r0,r0
800028aa:	0d 70       	ld.ub	r0,--r6
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	40 d8       	lddsp	r8,sp[0x34]

800028b0 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028b0:	20 1c       	sub	r12,1
800028b2:	5c 5c       	castu.b	r12
800028b4:	31 18       	mov	r8,17
800028b6:	f0 0c 18 00 	cp.b	r12,r8
800028ba:	e0 88 00 03 	brls	800028c0 <CalculateBurst+0x10>
800028be:	5e fd       	retal	0
800028c0:	48 28       	lddpc	r8,800028c8 <CalculateBurst+0x18>
800028c2:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028c6:	5e fc       	retal	r12
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	c7 10       	breq	800029ac <set_idle_store+0x8>

800028cc <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028cc:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ce:	48 98       	lddpc	r8,800028f0 <payload_init+0x24>
800028d0:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028d2:	48 98       	lddpc	r8,800028f4 <payload_init+0x28>
800028d4:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028d6:	30 09       	mov	r9,0
800028d8:	1a d9       	st.w	--sp,r9
800028da:	1a d9       	st.w	--sp,r9
800028dc:	1a d9       	st.w	--sp,r9
800028de:	30 28       	mov	r8,2
800028e0:	e0 6a 04 00 	mov	r10,1024
800028e4:	48 5b       	lddpc	r11,800028f8 <payload_init+0x2c>
800028e6:	48 6c       	lddpc	r12,800028fc <payload_init+0x30>
800028e8:	f0 1f 00 06 	mcall	80002900 <payload_init+0x34>
800028ec:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800028ee:	d8 02       	popm	pc
800028f0:	00 00       	add	r0,r0
800028f2:	0a 4c       	or	r12,r5
800028f4:	00 00       	add	r0,r0
800028f6:	0a 50       	eor	r0,r5
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	c7 58       	rjmp	800029e4 <phy_tx+0x20>
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	29 04       	sub	r4,-112
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	5c 7c       	castu.h	r12

80002904 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002904:	eb cd 40 f8 	pushm	r3-r7,lr
80002908:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000290a:	48 e8       	lddpc	r8,80002940 <payload_rx_process+0x3c>
8000290c:	70 08       	ld.w	r8,r8[0x0]
8000290e:	58 08       	cp.w	r8,0
80002910:	c0 71       	brne	8000291e <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002912:	30 4b       	mov	r11,4
80002914:	30 5c       	mov	r12,5
80002916:	f0 1f 00 0c 	mcall	80002944 <payload_rx_process+0x40>
8000291a:	48 a8       	lddpc	r8,80002940 <payload_rx_process+0x3c>
8000291c:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000291e:	48 96       	lddpc	r6,80002940 <payload_rx_process+0x3c>
80002920:	30 05       	mov	r5,0
80002922:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002924:	48 93       	lddpc	r3,80002948 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002926:	6c 0c       	ld.w	r12,r6[0x0]
80002928:	0a 99       	mov	r9,r5
8000292a:	08 9a       	mov	r10,r4
8000292c:	1a 9b       	mov	r11,sp
8000292e:	f0 1f 00 08 	mcall	8000294c <payload_rx_process+0x48>
80002932:	58 1c       	cp.w	r12,1
80002934:	cf 91       	brne	80002926 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002936:	66 08       	ld.w	r8,r3[0x0]
80002938:	40 0c       	lddsp	r12,sp[0x0]
8000293a:	5d 18       	icall	r8
8000293c:	cf 5b       	rjmp	80002926 <payload_rx_process+0x22>
8000293e:	00 00       	add	r0,r0
80002940:	00 00       	add	r0,r0
80002942:	0a 64       	and	r4,r5
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	55 a8       	stdsp	sp[0x168],r8
80002948:	00 00       	add	r0,r0
8000294a:	0a 4c       	or	r12,r5
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	52 9c       	stdsp	sp[0xa4],r12

80002950 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002950:	d4 01       	pushm	lr
80002952:	20 2d       	sub	sp,8
80002954:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002956:	30 09       	mov	r9,0
80002958:	fa ca ff f8 	sub	r10,sp,-8
8000295c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000295e:	1a 9b       	mov	r11,sp
80002960:	f0 1f 00 02 	mcall	80002968 <set_idle_store_isr+0x18>
}
80002964:	2f ed       	sub	sp,-8
80002966:	d8 02       	popm	pc
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	54 58       	stdsp	sp[0x114],r8

8000296c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
8000296c:	d4 01       	pushm	lr
8000296e:	20 2d       	sub	sp,8
80002970:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002972:	58 0c       	cp.w	r12,0
80002974:	c1 10       	breq	80002996 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002976:	30 08       	mov	r8,0
80002978:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000297a:	98 88       	ld.uh	r8,r12[0x0]
8000297c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002980:	e0 48 40 00 	cp.w	r8,16384
80002984:	c0 91       	brne	80002996 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002986:	48 68       	lddpc	r8,8000299c <phy_rx+0x30>
80002988:	70 0c       	ld.w	r12,r8[0x0]
8000298a:	30 09       	mov	r9,0
8000298c:	fa ca ff fc 	sub	r10,sp,-4
80002990:	1a 9b       	mov	r11,sp
80002992:	f0 1f 00 04 	mcall	800029a0 <phy_rx+0x34>
		}	

    }
		
 
}
80002996:	2f ed       	sub	sp,-8
80002998:	d8 02       	popm	pc
8000299a:	00 00       	add	r0,r0
8000299c:	00 00       	add	r0,r0
8000299e:	0a a8       	st.w	r5++,r8
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	54 58       	stdsp	sp[0x114],r8

800029a4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029a4:	eb cd 40 80 	pushm	r7,lr
800029a8:	20 1d       	sub	sp,4
800029aa:	fa c7 ff fc 	sub	r7,sp,-4
800029ae:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029b0:	30 09       	mov	r9,0
800029b2:	12 9a       	mov	r10,r9
800029b4:	1a 9b       	mov	r11,sp
800029b6:	f0 1f 00 03 	mcall	800029c0 <set_idle_store+0x1c>
}
800029ba:	2f fd       	sub	sp,-4
800029bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	54 a8       	stdsp	sp[0x128],r8

800029c4 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029c4:	d4 01       	pushm	lr
800029c6:	20 1d       	sub	sp,4
800029c8:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029ca:	98 88       	ld.uh	r8,r12[0x0]
800029cc:	e2 18 f0 00 	andl	r8,0xf000,COH
800029d0:	e0 48 40 00 	cp.w	r8,16384
800029d4:	c0 d1       	brne	800029ee <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029d6:	49 08       	lddpc	r8,80002a14 <phy_tx+0x50>
800029d8:	70 08       	ld.w	r8,r8[0x0]
800029da:	58 08       	cp.w	r8,0
800029dc:	c1 a0       	breq	80002a10 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029de:	48 e8       	lddpc	r8,80002a14 <phy_tx+0x50>
800029e0:	70 0c       	ld.w	r12,r8[0x0]
800029e2:	30 09       	mov	r9,0
800029e4:	12 9a       	mov	r10,r9
800029e6:	1a 9b       	mov	r11,sp
800029e8:	f0 1f 00 0c 	mcall	80002a18 <phy_tx+0x54>
800029ec:	c1 28       	rjmp	80002a10 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800029ee:	e0 48 10 00 	cp.w	r8,4096
800029f2:	5f 0a       	sreq	r10
800029f4:	e0 48 20 00 	cp.w	r8,8192
800029f8:	5f 09       	sreq	r9
800029fa:	f5 e9 10 09 	or	r9,r10,r9
800029fe:	c0 71       	brne	80002a0c <phy_tx+0x48>
80002a00:	e0 48 50 00 	cp.w	r8,20480
80002a04:	c0 40       	breq	80002a0c <phy_tx+0x48>
80002a06:	e0 48 60 00 	cp.w	r8,24576
80002a0a:	c0 31       	brne	80002a10 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a0c:	48 48       	lddpc	r8,80002a1c <phy_tx+0x58>
80002a0e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a10:	2f fd       	sub	sp,-4
80002a12:	d8 02       	popm	pc
80002a14:	00 00       	add	r0,r0
80002a16:	0a bc       	st.h	r5++,r12
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	54 a8       	stdsp	sp[0x128],r8
80002a1c:	00 00       	add	r0,r0
80002a1e:	0a 9c       	mov	r12,r5

80002a20 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a20:	d4 01       	pushm	lr
80002a22:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a24:	30 08       	mov	r8,0
80002a26:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a28:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a2a:	1a 9a       	mov	r10,sp
80002a2c:	fa cb ff fc 	sub	r11,sp,-4
80002a30:	f0 1f 00 05 	mcall	80002a44 <get_idle_store_isr+0x24>
80002a34:	58 1c       	cp.w	r12,1
80002a36:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a3a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a3e:	2f ed       	sub	sp,-8
80002a40:	d8 02       	popm	pc
80002a42:	00 00       	add	r0,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	51 ac       	stdsp	sp[0x68],r12

80002a48 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a48:	eb cd 40 c0 	pushm	r6-r7,lr
80002a4c:	20 1d       	sub	sp,4
80002a4e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a50:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a54:	70 08       	ld.w	r8,r8[0x0]
80002a56:	58 08       	cp.w	r8,0
80002a58:	c7 40       	breq	80002b40 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a5a:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a5c:	30 08       	mov	r8,0
80002a5e:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a60:	fe f8 04 64 	ld.w	r8,pc[1124]
80002a64:	70 08       	ld.w	r8,r8[0x0]
80002a66:	58 18       	cp.w	r8,1
80002a68:	c2 90       	breq	80002aba <phy_tx_func+0x72>
80002a6a:	c0 43       	brcs	80002a72 <phy_tx_func+0x2a>
80002a6c:	58 28       	cp.w	r8,2
80002a6e:	c6 91       	brne	80002b40 <phy_tx_func+0xf8>
80002a70:	c6 18       	rjmp	80002b32 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a72:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002a76:	70 0c       	ld.w	r12,r8[0x0]
80002a78:	1a 9a       	mov	r10,sp
80002a7a:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002a7e:	f0 1f 01 14 	mcall	80002ecc <phy_tx_func+0x484>
80002a82:	58 1c       	cp.w	r12,1
80002a84:	c1 51       	brne	80002aae <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a86:	fe f8 04 42 	ld.w	r8,pc[1090]
80002a8a:	70 08       	ld.w	r8,r8[0x0]
80002a8c:	11 9a       	ld.ub	r10,r8[0x1]
80002a8e:	fe f9 04 42 	ld.w	r9,pc[1090]
80002a92:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002a94:	90 88       	ld.uh	r8,r8[0x0]
80002a96:	ea 18 ab cd 	orh	r8,0xabcd
80002a9a:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002a9c:	30 19       	mov	r9,1
80002a9e:	fe f8 04 36 	ld.w	r8,pc[1078]
80002aa2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002aa4:	30 19       	mov	r9,1
80002aa6:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002aaa:	91 09       	st.w	r8[0x0],r9
80002aac:	c4 a8       	rjmp	80002b40 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aae:	e0 68 5a 5a 	mov	r8,23130
80002ab2:	ea 18 ab cd 	orh	r8,0xabcd
80002ab6:	8f 18       	st.w	r7[0x4],r8
80002ab8:	c4 48       	rjmp	80002b40 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aba:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002abe:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ac0:	fe fa 04 08 	ld.w	r10,pc[1032]
80002ac4:	74 0a       	ld.w	r10,r10[0x0]
80002ac6:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002aca:	b1 6a       	lsl	r10,0x10
80002acc:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ace:	2f f8       	sub	r8,-1
80002ad0:	5c 58       	castu.b	r8
80002ad2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ad4:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002ad8:	94 09       	ld.sh	r9,r10[0x0]
80002ada:	20 29       	sub	r9,2
80002adc:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002ade:	30 0a       	mov	r10,0
80002ae0:	f4 09 19 00 	cp.h	r9,r10
80002ae4:	e0 89 00 0b 	brgt	80002afa <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002ae8:	78 18       	ld.w	r8,r12[0x4]
80002aea:	e8 18 00 ba 	orl	r8,0xba
80002aee:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002af0:	30 09       	mov	r9,0
80002af2:	fe f8 03 d2 	ld.w	r8,pc[978]
80002af6:	91 09       	st.w	r8[0x0],r9
80002af8:	c2 48       	rjmp	80002b40 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002afa:	fe f9 03 ce 	ld.w	r9,pc[974]
80002afe:	72 09       	ld.w	r9,r9[0x0]
80002b00:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b04:	78 1a       	ld.w	r10,r12[0x4]
80002b06:	f5 e9 10 09 	or	r9,r10,r9
80002b0a:	99 19       	st.w	r12[0x4],r9
80002b0c:	2f f8       	sub	r8,-1
80002b0e:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b12:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b14:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b18:	92 08       	ld.sh	r8,r9[0x0]
80002b1a:	20 28       	sub	r8,2
80002b1c:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b1e:	30 09       	mov	r9,0
80002b20:	f2 08 19 00 	cp.h	r8,r9
80002b24:	e0 89 00 0e 	brgt	80002b40 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b28:	30 29       	mov	r9,2
80002b2a:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b2e:	91 09       	st.w	r8[0x0],r9
80002b30:	c0 88       	rjmp	80002b40 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b32:	fc 18 00 ba 	movh	r8,0xba
80002b36:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b38:	30 09       	mov	r9,0
80002b3a:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b3e:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b40:	fe f8 03 98 	ld.w	r8,pc[920]
80002b44:	11 89       	ld.ub	r9,r8[0x0]
80002b46:	30 18       	mov	r8,1
80002b48:	f0 09 18 00 	cp.b	r9,r8
80002b4c:	e0 81 01 af 	brne	80002eaa <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b50:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b54:	70 08       	ld.w	r8,r8[0x0]
80002b56:	e0 48 05 b0 	cp.w	r8,1456
80002b5a:	f9 b8 02 00 	movhs	r8,0
80002b5e:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b62:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b64:	fe f8 03 7c 	ld.w	r8,pc[892]
80002b68:	70 08       	ld.w	r8,r8[0x0]
80002b6a:	58 68       	cp.w	r8,6
80002b6c:	e0 8b 01 95 	brhi	80002e96 <phy_tx_func+0x44e>
80002b70:	fe f9 03 74 	ld.w	r9,pc[884]
80002b74:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b78:	fe f8 03 70 	ld.w	r8,pc[880]
80002b7c:	70 08       	ld.w	r8,r8[0x0]
80002b7e:	58 08       	cp.w	r8,0
80002b80:	c0 b0       	breq	80002b96 <phy_tx_func+0x14e>
80002b82:	fe f8 03 66 	ld.w	r8,pc[870]
80002b86:	70 08       	ld.w	r8,r8[0x0]
80002b88:	58 a8       	cp.w	r8,10
80002b8a:	c0 60       	breq	80002b96 <phy_tx_func+0x14e>
80002b8c:	fe f8 03 5c 	ld.w	r8,pc[860]
80002b90:	70 08       	ld.w	r8,r8[0x0]
80002b92:	58 18       	cp.w	r8,1
80002b94:	c0 a1       	brne	80002ba8 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002b96:	e0 68 5a 5a 	mov	r8,23130
80002b9a:	ea 18 ab cd 	orh	r8,0xabcd
80002b9e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ba0:	30 08       	mov	r8,0
80002ba2:	8f 38       	st.w	r7[0xc],r8
80002ba4:	e0 8f 01 8a 	bral	80002eb8 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002ba8:	fe f8 03 40 	ld.w	r8,pc[832]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 38       	cp.w	r8,3
80002bb0:	c0 91       	brne	80002bc2 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bb2:	fe f8 03 3a 	ld.w	r8,pc[826]
80002bb6:	70 09       	ld.w	r9,r8[0x0]
80002bb8:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bba:	70 18       	ld.w	r8,r8[0x4]
80002bbc:	8f 38       	st.w	r7[0xc],r8
80002bbe:	e0 8f 01 7d 	bral	80002eb8 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bc2:	fe f8 03 26 	ld.w	r8,pc[806]
80002bc6:	70 08       	ld.w	r8,r8[0x0]
80002bc8:	58 28       	cp.w	r8,2
80002bca:	c1 31       	brne	80002bf0 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002bcc:	e0 68 c0 32 	mov	r8,49202
80002bd0:	ea 18 ab cd 	orh	r8,0xabcd
80002bd4:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002bd6:	fe 78 84 7f 	mov	r8,-31617
80002bda:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002bdc:	fe f8 03 14 	ld.w	r8,pc[788]
80002be0:	90 08       	ld.sh	r8,r8[0x0]
80002be2:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002be4:	30 39       	mov	r9,3
80002be6:	fe f8 02 fa 	ld.w	r8,pc[762]
80002bea:	91 09       	st.w	r8[0x0],r9
80002bec:	e0 8f 01 66 	bral	80002eb8 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002bf0:	e0 68 c0 0e 	mov	r8,49166
80002bf4:	ea 18 ab cd 	orh	r8,0xabcd
80002bf8:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002bfa:	fe f8 02 fa 	ld.w	r8,pc[762]
80002bfe:	90 09       	ld.sh	r9,r8[0x0]
80002c00:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c02:	90 18       	ld.sh	r8,r8[0x2]
80002c04:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c06:	30 19       	mov	r9,1
80002c08:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c0c:	91 09       	st.w	r8[0x0],r9
80002c0e:	e0 8f 01 55 	bral	80002eb8 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c12:	fe 78 88 f2 	mov	r8,-30478
80002c16:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c18:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c1c:	70 08       	ld.w	r8,r8[0x0]
80002c1e:	58 48       	cp.w	r8,4
80002c20:	c0 60       	breq	80002c2c <phy_tx_func+0x1e4>
80002c22:	c4 53       	brcs	80002cac <phy_tx_func+0x264>
80002c24:	58 98       	cp.w	r8,9
80002c26:	e0 8b 00 43 	brhi	80002cac <phy_tx_func+0x264>
80002c2a:	c2 98       	rjmp	80002c7c <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c2c:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c30:	11 89       	ld.ub	r9,r8[0x0]
80002c32:	30 18       	mov	r8,1
80002c34:	f0 09 18 00 	cp.b	r9,r8
80002c38:	c0 a1       	brne	80002c4c <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c3a:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c3e:	90 09       	ld.sh	r9,r8[0x0]
80002c40:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c42:	90 19       	ld.sh	r9,r8[0x2]
80002c44:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c46:	90 28       	ld.sh	r8,r8[0x4]
80002c48:	ae 78       	st.h	r7[0xe],r8
80002c4a:	c1 48       	rjmp	80002c72 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c4c:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c50:	92 0b       	ld.sh	r11,r9[0x0]
80002c52:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c56:	90 0a       	ld.sh	r10,r8[0x0]
80002c58:	f7 ea 20 0a 	eor	r10,r11,r10
80002c5c:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c5e:	92 1b       	ld.sh	r11,r9[0x2]
80002c60:	90 1a       	ld.sh	r10,r8[0x2]
80002c62:	f7 ea 20 0a 	eor	r10,r11,r10
80002c66:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c68:	92 29       	ld.sh	r9,r9[0x4]
80002c6a:	90 28       	ld.sh	r8,r8[0x4]
80002c6c:	f3 e8 20 08 	eor	r8,r9,r8
80002c70:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c72:	30 29       	mov	r9,2
80002c74:	fe f8 02 6c 	ld.w	r8,pc[620]
80002c78:	91 09       	st.w	r8[0x0],r9
80002c7a:	c1 f9       	rjmp	80002eb8 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c7c:	fe f9 02 84 	ld.w	r9,pc[644]
80002c80:	92 0b       	ld.sh	r11,r9[0x0]
80002c82:	fe f8 02 7a 	ld.w	r8,pc[634]
80002c86:	90 0a       	ld.sh	r10,r8[0x0]
80002c88:	f7 ea 20 0a 	eor	r10,r11,r10
80002c8c:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c8e:	92 1b       	ld.sh	r11,r9[0x2]
80002c90:	90 1a       	ld.sh	r10,r8[0x2]
80002c92:	f7 ea 20 0a 	eor	r10,r11,r10
80002c96:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c98:	92 29       	ld.sh	r9,r9[0x4]
80002c9a:	90 28       	ld.sh	r8,r8[0x4]
80002c9c:	f3 e8 20 08 	eor	r8,r9,r8
80002ca0:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002ca2:	30 29       	mov	r9,2
80002ca4:	fe f8 02 3c 	ld.w	r8,pc[572]
80002ca8:	91 09       	st.w	r8[0x0],r9
80002caa:	c0 79       	rjmp	80002eb8 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cac:	e0 68 5a 5a 	mov	r8,23130
80002cb0:	ea 18 ab cd 	orh	r8,0xabcd
80002cb4:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cb6:	30 08       	mov	r8,0
80002cb8:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cba:	fe f9 02 26 	ld.w	r9,pc[550]
80002cbe:	93 08       	st.w	r9[0x0],r8
80002cc0:	cf c8       	rjmp	80002eb8 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cc2:	fe f8 02 3e 	ld.w	r8,pc[574]
80002cc6:	90 38       	ld.sh	r8,r8[0x6]
80002cc8:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002cca:	e0 68 00 ba 	mov	r8,186
80002cce:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cd0:	30 08       	mov	r8,0
80002cd2:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002cd4:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002cd6:	30 09       	mov	r9,0
80002cd8:	fe f8 02 08 	ld.w	r8,pc[520]
80002cdc:	91 09       	st.w	r8[0x0],r9
80002cde:	ce d8       	rjmp	80002eb8 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002ce0:	fe f8 02 10 	ld.w	r8,pc[528]
80002ce4:	90 18       	ld.sh	r8,r8[0x2]
80002ce6:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002ce8:	fe f8 02 0c 	ld.w	r8,pc[524]
80002cec:	90 08       	ld.sh	r8,r8[0x0]
80002cee:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002cf0:	4f e8       	lddpc	r8,80002ee8 <phy_tx_func+0x4a0>
80002cf2:	70 08       	ld.w	r8,r8[0x0]
80002cf4:	58 48       	cp.w	r8,4
80002cf6:	c0 d1       	brne	80002d10 <phy_tx_func+0x2c8>
80002cf8:	fe f8 02 00 	ld.w	r8,pc[512]
80002cfc:	11 89       	ld.ub	r9,r8[0x0]
80002cfe:	30 18       	mov	r8,1
80002d00:	f0 09 18 00 	cp.b	r9,r8
80002d04:	c0 61       	brne	80002d10 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d06:	4f c8       	lddpc	r8,80002ef4 <phy_tx_func+0x4ac>
80002d08:	90 18       	ld.sh	r8,r8[0x2]
80002d0a:	a9 a8       	sbr	r8,0x8
80002d0c:	ae 68       	st.h	r7[0xc],r8
80002d0e:	c0 48       	rjmp	80002d16 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d10:	4f 98       	lddpc	r8,80002ef4 <phy_tx_func+0x4ac>
80002d12:	90 18       	ld.sh	r8,r8[0x2]
80002d14:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d16:	fe 78 9a 13 	mov	r8,-26093
80002d1a:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d1c:	30 49       	mov	r9,4
80002d1e:	4f 18       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002d20:	91 09       	st.w	r8[0x0],r9
80002d22:	cc b8       	rjmp	80002eb8 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d24:	4f 88       	lddpc	r8,80002f04 <phy_tx_func+0x4bc>
80002d26:	70 0a       	ld.w	r10,r8[0x0]
80002d28:	4f 89       	lddpc	r9,80002f08 <phy_tx_func+0x4c0>
80002d2a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d2e:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d30:	70 0a       	ld.w	r10,r8[0x0]
80002d32:	2f fa       	sub	r10,-1
80002d34:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d38:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d3a:	70 0a       	ld.w	r10,r8[0x0]
80002d3c:	2f ea       	sub	r10,-2
80002d3e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d42:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d44:	70 0a       	ld.w	r10,r8[0x0]
80002d46:	2f da       	sub	r10,-3
80002d48:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d4c:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d4e:	70 09       	ld.w	r9,r8[0x0]
80002d50:	2f c9       	sub	r9,-4
80002d52:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d54:	58 c9       	cp.w	r9,12
80002d56:	c0 51       	brne	80002d60 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d58:	30 59       	mov	r9,5
80002d5a:	4e 28       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002d5c:	91 09       	st.w	r8[0x0],r9
80002d5e:	ca d8       	rjmp	80002eb8 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d60:	30 49       	mov	r9,4
80002d62:	4e 08       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002d64:	91 09       	st.w	r8[0x0],r9
80002d66:	ca 98       	rjmp	80002eb8 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d68:	4e 78       	lddpc	r8,80002f04 <phy_tx_func+0x4bc>
80002d6a:	70 0a       	ld.w	r10,r8[0x0]
80002d6c:	4e 79       	lddpc	r9,80002f08 <phy_tx_func+0x4c0>
80002d6e:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d72:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002d74:	30 09       	mov	r9,0
80002d76:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002d78:	fe 78 80 03 	mov	r8,-32765
80002d7c:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002d7e:	fe 78 88 f3 	mov	r8,-30477
80002d82:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002d84:	4d 98       	lddpc	r8,80002ee8 <phy_tx_func+0x4a0>
80002d86:	70 08       	ld.w	r8,r8[0x0]
80002d88:	58 48       	cp.w	r8,4
80002d8a:	c0 60       	breq	80002d96 <phy_tx_func+0x34e>
80002d8c:	c2 83       	brcs	80002ddc <phy_tx_func+0x394>
80002d8e:	58 98       	cp.w	r8,9
80002d90:	e0 8b 00 26 	brhi	80002ddc <phy_tx_func+0x394>
80002d94:	c1 98       	rjmp	80002dc6 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002d96:	4d 98       	lddpc	r8,80002ef8 <phy_tx_func+0x4b0>
80002d98:	11 89       	ld.ub	r9,r8[0x0]
80002d9a:	30 18       	mov	r8,1
80002d9c:	f0 09 18 00 	cp.b	r9,r8
80002da0:	c0 81       	brne	80002db0 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002da2:	4d 88       	lddpc	r8,80002f00 <phy_tx_func+0x4b8>
80002da4:	90 0a       	ld.sh	r10,r8[0x0]
80002da6:	4d a9       	lddpc	r9,80002f0c <phy_tx_func+0x4c4>
80002da8:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002daa:	90 08       	ld.sh	r8,r8[0x0]
80002dac:	ae 78       	st.h	r7[0xe],r8
80002dae:	c0 88       	rjmp	80002dbe <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002db0:	4d 78       	lddpc	r8,80002f0c <phy_tx_func+0x4c4>
80002db2:	90 08       	ld.sh	r8,r8[0x0]
80002db4:	4d 39       	lddpc	r9,80002f00 <phy_tx_func+0x4b8>
80002db6:	92 09       	ld.sh	r9,r9[0x0]
80002db8:	f3 e8 20 08 	eor	r8,r9,r8
80002dbc:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dbe:	30 69       	mov	r9,6
80002dc0:	4c 88       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002dc2:	91 09       	st.w	r8[0x0],r9
80002dc4:	c7 a8       	rjmp	80002eb8 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002dc6:	4d 28       	lddpc	r8,80002f0c <phy_tx_func+0x4c4>
80002dc8:	90 08       	ld.sh	r8,r8[0x0]
80002dca:	4c e9       	lddpc	r9,80002f00 <phy_tx_func+0x4b8>
80002dcc:	92 09       	ld.sh	r9,r9[0x0]
80002dce:	f3 e8 20 08 	eor	r8,r9,r8
80002dd2:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dd4:	30 69       	mov	r9,6
80002dd6:	4c 38       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002dd8:	91 09       	st.w	r8[0x0],r9
80002dda:	c6 f8       	rjmp	80002eb8 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ddc:	e0 68 5a 5a 	mov	r8,23130
80002de0:	ea 18 ab cd 	orh	r8,0xabcd
80002de4:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002de6:	30 08       	mov	r8,0
80002de8:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002dea:	4b e9       	lddpc	r9,80002ee0 <phy_tx_func+0x498>
80002dec:	93 08       	st.w	r9[0x0],r8
80002dee:	c6 58       	rjmp	80002eb8 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002df0:	4b e8       	lddpc	r8,80002ee8 <phy_tx_func+0x4a0>
80002df2:	70 08       	ld.w	r8,r8[0x0]
80002df4:	58 48       	cp.w	r8,4
80002df6:	c0 60       	breq	80002e02 <phy_tx_func+0x3ba>
80002df8:	c4 53       	brcs	80002e82 <phy_tx_func+0x43a>
80002dfa:	58 98       	cp.w	r8,9
80002dfc:	e0 8b 00 43 	brhi	80002e82 <phy_tx_func+0x43a>
80002e00:	c2 d8       	rjmp	80002e5a <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e02:	4b e8       	lddpc	r8,80002ef8 <phy_tx_func+0x4b0>
80002e04:	11 89       	ld.ub	r9,r8[0x0]
80002e06:	30 18       	mov	r8,1
80002e08:	f0 09 18 00 	cp.b	r9,r8
80002e0c:	c1 31       	brne	80002e32 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e0e:	4b d8       	lddpc	r8,80002f00 <phy_tx_func+0x4b8>
80002e10:	90 1a       	ld.sh	r10,r8[0x2]
80002e12:	4b f9       	lddpc	r9,80002f0c <phy_tx_func+0x4c4>
80002e14:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e16:	90 2a       	ld.sh	r10,r8[0x4]
80002e18:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e1a:	90 3a       	ld.sh	r10,r8[0x6]
80002e1c:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e1e:	90 19       	ld.sh	r9,r8[0x2]
80002e20:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e22:	90 29       	ld.sh	r9,r8[0x4]
80002e24:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e26:	90 38       	ld.sh	r8,r8[0x6]
80002e28:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e2a:	e0 68 00 ba 	mov	r8,186
80002e2e:	ae 78       	st.h	r7[0xe],r8
80002e30:	c1 18       	rjmp	80002e52 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e32:	4b 48       	lddpc	r8,80002f00 <phy_tx_func+0x4b8>
80002e34:	90 1a       	ld.sh	r10,r8[0x2]
80002e36:	4b 69       	lddpc	r9,80002f0c <phy_tx_func+0x4c4>
80002e38:	92 1b       	ld.sh	r11,r9[0x2]
80002e3a:	f7 ea 20 0a 	eor	r10,r11,r10
80002e3e:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e40:	90 2a       	ld.sh	r10,r8[0x4]
80002e42:	92 29       	ld.sh	r9,r9[0x4]
80002e44:	14 59       	eor	r9,r10
80002e46:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e48:	90 38       	ld.sh	r8,r8[0x6]
80002e4a:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e4c:	e0 68 00 ba 	mov	r8,186
80002e50:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e52:	30 09       	mov	r9,0
80002e54:	4a 38       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002e56:	91 09       	st.w	r8[0x0],r9
80002e58:	c3 08       	rjmp	80002eb8 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e5a:	4a a8       	lddpc	r8,80002f00 <phy_tx_func+0x4b8>
80002e5c:	90 1a       	ld.sh	r10,r8[0x2]
80002e5e:	4a c9       	lddpc	r9,80002f0c <phy_tx_func+0x4c4>
80002e60:	92 1b       	ld.sh	r11,r9[0x2]
80002e62:	f7 ea 20 0a 	eor	r10,r11,r10
80002e66:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e68:	90 2a       	ld.sh	r10,r8[0x4]
80002e6a:	92 29       	ld.sh	r9,r9[0x4]
80002e6c:	14 59       	eor	r9,r10
80002e6e:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e70:	90 38       	ld.sh	r8,r8[0x6]
80002e72:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002e74:	e0 68 00 ba 	mov	r8,186
80002e78:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e7a:	30 09       	mov	r9,0
80002e7c:	49 98       	lddpc	r8,80002ee0 <phy_tx_func+0x498>
80002e7e:	91 09       	st.w	r8[0x0],r9
80002e80:	c1 c8       	rjmp	80002eb8 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e82:	e0 68 5a 5a 	mov	r8,23130
80002e86:	ea 18 ab cd 	orh	r8,0xabcd
80002e8a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e8c:	30 08       	mov	r8,0
80002e8e:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002e90:	49 49       	lddpc	r9,80002ee0 <phy_tx_func+0x498>
80002e92:	93 08       	st.w	r9[0x0],r8
80002e94:	c1 28       	rjmp	80002eb8 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e96:	e0 68 5a 5a 	mov	r8,23130
80002e9a:	ea 18 ab cd 	orh	r8,0xabcd
80002e9e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ea0:	30 08       	mov	r8,0
80002ea2:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ea4:	48 f9       	lddpc	r9,80002ee0 <phy_tx_func+0x498>
80002ea6:	93 08       	st.w	r9[0x0],r8
80002ea8:	c0 88       	rjmp	80002eb8 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eaa:	e0 68 5a 5a 	mov	r8,23130
80002eae:	ea 18 ab cd 	orh	r8,0xabcd
80002eb2:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002eb4:	30 08       	mov	r8,0
80002eb6:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002eb8:	2f fd       	sub	sp,-4
80002eba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ebe:	00 00       	add	r0,r0
80002ec0:	00 00       	add	r0,r0
80002ec2:	0a bc       	st.h	r5++,r12
80002ec4:	00 00       	add	r0,r0
80002ec6:	0a 78       	tst	r8,r5
80002ec8:	00 00       	add	r0,r0
80002eca:	0a d0       	st.w	--r5,r0
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	51 ac       	stdsp	sp[0x68],r12
80002ed0:	00 00       	add	r0,r0
80002ed2:	0a a2       	st.w	r5++,r2
80002ed4:	00 00       	add	r0,r0
80002ed6:	0a 58       	eor	r8,r5
80002ed8:	00 00       	add	r0,r0
80002eda:	0a 3f       	cp.w	pc,r5
80002edc:	00 00       	add	r0,r0
80002ede:	0a cc       	st.b	r5++,r12
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a 68       	and	r8,r5
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	c7 64       	brge	80002fd2 <phy_rx_func+0x12>
80002ee8:	00 00       	add	r0,r0
80002eea:	0a c0       	st.b	r5++,r0
80002eec:	00 00       	add	r0,r0
80002eee:	0a 80       	andn	r0,r5
80002ef0:	00 00       	add	r0,r0
80002ef2:	0d 7c       	ld.ub	r12,--r6
80002ef4:	00 00       	add	r0,r0
80002ef6:	0e 78       	tst	r8,r7
80002ef8:	00 00       	add	r0,r0
80002efa:	0a 45       	or	r5,r5
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	c7 06       	brmi	80002fde <phy_rx_func+0x1e>
80002f00:	00 00       	add	r0,r0
80002f02:	0d 74       	ld.ub	r4,--r6
80002f04:	00 00       	add	r0,r0
80002f06:	0a c4       	st.b	r5++,r4
80002f08:	00 00       	add	r0,r0
80002f0a:	0e 7c       	tst	r12,r7
80002f0c:	00 00       	add	r0,r0
80002f0e:	0d 80       	ld.ub	r0,r6[0x0]

80002f10 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f10:	d4 01       	pushm	lr
80002f12:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f14:	30 0a       	mov	r10,0
80002f16:	fa cb ff fc 	sub	r11,sp,-4
80002f1a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f1c:	14 99       	mov	r9,r10
80002f1e:	1a 9b       	mov	r11,sp
80002f20:	f0 1f 00 05 	mcall	80002f34 <get_idle_store+0x24>
80002f24:	58 1c       	cp.w	r12,1
80002f26:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f2a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f2e:	2f fd       	sub	sp,-4
80002f30:	d8 02       	popm	pc
80002f32:	00 00       	add	r0,r0
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	52 9c       	stdsp	sp[0xa4],r12

80002f38 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f38:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f3a:	48 5b       	lddpc	r11,80002f4c <phy_init+0x14>
80002f3c:	48 5c       	lddpc	r12,80002f50 <phy_init+0x18>
80002f3e:	f0 1f 00 06 	mcall	80002f54 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002f42:	f0 1f 00 06 	mcall	80002f58 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002f46:	f0 1f 00 06 	mcall	80002f5c <phy_init+0x24>
	
}
80002f4a:	d8 02       	popm	pc
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2a 48       	sub	r8,-92
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	2f c0       	sub	r0,-4
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	40 08       	lddsp	r8,sp[0x0]
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	40 1c       	lddsp	r12,sp[0x4]
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	49 30       	lddpc	r0,80002fa8 <payload_rx+0x48>

80002f60 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002f60:	d4 01       	pushm	lr
80002f62:	20 2d       	sub	sp,8
80002f64:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f66:	30 08       	mov	r8,0
80002f68:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002f6a:	48 f8       	lddpc	r8,80002fa4 <payload_rx+0x44>
80002f6c:	70 08       	ld.w	r8,r8[0x0]
80002f6e:	58 08       	cp.w	r8,0
80002f70:	c0 71       	brne	80002f7e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002f72:	30 4b       	mov	r11,4
80002f74:	30 5c       	mov	r12,5
80002f76:	f0 1f 00 0d 	mcall	80002fa8 <payload_rx+0x48>
80002f7a:	48 b8       	lddpc	r8,80002fa4 <payload_rx+0x44>
80002f7c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002f7e:	48 a8       	lddpc	r8,80002fa4 <payload_rx+0x44>
80002f80:	70 0c       	ld.w	r12,r8[0x0]
80002f82:	30 09       	mov	r9,0
80002f84:	fa ca ff fc 	sub	r10,sp,-4
80002f88:	1a 9b       	mov	r11,sp
80002f8a:	f0 1f 00 09 	mcall	80002fac <payload_rx+0x4c>
80002f8e:	c0 91       	brne	80002fa0 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002f90:	48 88       	lddpc	r8,80002fb0 <payload_rx+0x50>
80002f92:	70 0c       	ld.w	r12,r8[0x0]
80002f94:	40 0b       	lddsp	r11,sp[0x0]
80002f96:	f0 1f 00 08 	mcall	80002fb4 <payload_rx+0x54>
		logFromISR("mm");
80002f9a:	48 8c       	lddpc	r12,80002fb8 <payload_rx+0x58>
80002f9c:	f0 1f 00 08 	mcall	80002fbc <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002fa0:	2f ed       	sub	sp,-8
80002fa2:	d8 02       	popm	pc
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a 64       	and	r4,r5
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	55 a8       	stdsp	sp[0x168],r8
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	54 58       	stdsp	sp[0x114],r8
80002fb0:	00 00       	add	r0,r0
80002fb2:	0a 94       	mov	r4,r5
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	29 50       	sub	r0,-107
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	c7 80       	breq	800030aa <phy_rx_func+0xea>
80002fbc:	80 00       	ld.sh	r0,r0[0x0]
80002fbe:	61 cc       	ld.w	r12,r0[0x70]

80002fc0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002fc0:	eb cd 40 e0 	pushm	r5-r7,lr
80002fc4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002fc6:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002fca:	70 08       	ld.w	r8,r8[0x0]
80002fcc:	58 08       	cp.w	r8,0
80002fce:	e0 80 01 08 	breq	800031de <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002fd2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002fd4:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002fd8:	70 09       	ld.w	r9,r8[0x0]
80002fda:	2f f9       	sub	r9,-1
80002fdc:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002fde:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002fe2:	70 08       	ld.w	r8,r8[0x0]
80002fe4:	58 18       	cp.w	r8,1
80002fe6:	e0 80 00 85 	breq	800030f0 <phy_rx_func+0x130>
80002fea:	c0 73       	brcs	80002ff8 <phy_rx_func+0x38>
80002fec:	58 28       	cp.w	r8,2
80002fee:	c5 c0       	breq	800030a6 <phy_rx_func+0xe6>
80002ff0:	58 38       	cp.w	r8,3
80002ff2:	e0 81 00 f6 	brne	800031de <phy_rx_func+0x21e>
80002ff6:	cd 58       	rjmp	800031a0 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002ff8:	e0 6a 5a 5a 	mov	r10,23130
80002ffc:	ea 1a ab cd 	orh	r10,0xabcd
80003000:	14 36       	cp.w	r6,r10
80003002:	e0 80 00 ee 	breq	800031de <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003006:	ec 08 16 10 	lsr	r8,r6,0x10
8000300a:	e0 48 ab cd 	cp.w	r8,43981
8000300e:	e0 81 00 e8 	brne	800031de <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003012:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003016:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000301a:	20 28       	sub	r8,2
8000301c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003020:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003022:	30 09       	mov	r9,0
80003024:	f2 08 19 00 	cp.h	r8,r9
80003028:	e0 8a 00 db 	brle	800031de <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
8000302c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003030:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003032:	fe f8 0e 22 	ld.w	r8,pc[3618]
80003036:	70 0c       	ld.w	r12,r8[0x0]
80003038:	f0 1f 03 88 	mcall	80003e58 <phy_rx_func+0xe98>
8000303c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003040:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003042:	58 0c       	cp.w	r12,0
80003044:	e0 80 00 cd 	breq	800031de <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003048:	fe f8 0e 08 	ld.w	r8,pc[3592]
8000304c:	90 09       	ld.sh	r9,r8[0x0]
8000304e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003052:	2f f9       	sub	r9,-1
80003054:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003056:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000305a:	74 0a       	ld.w	r10,r10[0x0]
8000305c:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003060:	76 0b       	ld.w	r11,r11[0x0]
80003062:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003066:	2f f9       	sub	r9,-1
80003068:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000306a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000306e:	e0 46 01 00 	cp.w	r6,256
80003072:	c0 c0       	breq	8000308a <phy_rx_func+0xca>
80003074:	e0 8b 00 05 	brhi	8000307e <phy_rx_func+0xbe>
80003078:	58 06       	cp.w	r6,0
8000307a:	c0 80       	breq	8000308a <phy_rx_func+0xca>
8000307c:	c0 c8       	rjmp	80003094 <phy_rx_func+0xd4>
8000307e:	e0 46 02 00 	cp.w	r6,512
80003082:	c0 40       	breq	8000308a <phy_rx_func+0xca>
80003084:	e0 46 03 00 	cp.w	r6,768
80003088:	c0 61       	brne	80003094 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000308a:	30 29       	mov	r9,2
8000308c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003090:	91 09       	st.w	r8[0x0],r9
80003092:	ca 68       	rjmp	800031de <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003094:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003098:	70 0c       	ld.w	r12,r8[0x0]
8000309a:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000309e:	70 0b       	ld.w	r11,r8[0x0]
800030a0:	f0 1f 03 70 	mcall	80003e60 <phy_rx_func+0xea0>
800030a4:	c9 d8       	rjmp	800031de <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800030a6:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800030aa:	b1 86       	lsr	r6,0x10
800030ac:	14 06       	add	r6,r10
800030ae:	fe f8 0d b6 	ld.w	r8,pc[3510]
800030b2:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800030b4:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800030b8:	90 09       	ld.sh	r9,r8[0x0]
800030ba:	fe fb 0d a2 	ld.w	r11,pc[3490]
800030be:	76 0b       	ld.w	r11,r11[0x0]
800030c0:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800030c4:	2f f9       	sub	r9,-1
800030c6:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800030c8:	fe f9 0d 84 	ld.w	r9,pc[3460]
800030cc:	92 08       	ld.sh	r8,r9[0x0]
800030ce:	20 28       	sub	r8,2
800030d0:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800030d2:	30 09       	mov	r9,0
800030d4:	f2 08 19 00 	cp.h	r8,r9
800030d8:	e0 8a 00 07 	brle	800030e6 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800030dc:	30 19       	mov	r9,1
800030de:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800030e2:	91 09       	st.w	r8[0x0],r9
800030e4:	c7 d8       	rjmp	800031de <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800030e6:	30 39       	mov	r9,3
800030e8:	fe f8 0d 60 	ld.w	r8,pc[3424]
800030ec:	91 09       	st.w	r8[0x0],r9
800030ee:	c7 88       	rjmp	800031de <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800030f0:	ec 0a 14 10 	asr	r10,r6,0x10
800030f4:	fe f8 0d 70 	ld.w	r8,pc[3440]
800030f8:	90 09       	ld.sh	r9,r8[0x0]
800030fa:	14 09       	add	r9,r10
800030fc:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030fe:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003102:	92 08       	ld.sh	r8,r9[0x0]
80003104:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003108:	76 0b       	ld.w	r11,r11[0x0]
8000310a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000310e:	2f f8       	sub	r8,-1
80003110:	5c 88       	casts.h	r8
80003112:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003114:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003118:	94 09       	ld.sh	r9,r10[0x0]
8000311a:	20 29       	sub	r9,2
8000311c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000311e:	30 0a       	mov	r10,0
80003120:	f4 09 19 00 	cp.h	r9,r10
80003124:	e0 89 00 20 	brgt	80003164 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003128:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000312c:	e0 46 00 ba 	cp.w	r6,186
80003130:	c0 d1       	brne	8000314a <phy_rx_func+0x18a>
80003132:	fe f8 0d 32 	ld.w	r8,pc[3378]
80003136:	90 09       	ld.sh	r9,r8[0x0]
80003138:	f4 09 19 00 	cp.h	r9,r10
8000313c:	c0 71       	brne	8000314a <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000313e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003142:	70 0c       	ld.w	r12,r8[0x0]
80003144:	f0 1f 03 49 	mcall	80003e68 <phy_rx_func+0xea8>
80003148:	c0 98       	rjmp	8000315a <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000314a:	fe f8 0d 0a 	ld.w	r8,pc[3338]
8000314e:	70 0c       	ld.w	r12,r8[0x0]
80003150:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003154:	70 0b       	ld.w	r11,r8[0x0]
80003156:	f0 1f 03 43 	mcall	80003e60 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000315a:	30 09       	mov	r9,0
8000315c:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003160:	91 09       	st.w	r8[0x0],r9
80003162:	c3 e8       	rjmp	800031de <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003164:	5c 86       	casts.h	r6
80003166:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000316a:	92 0a       	ld.sh	r10,r9[0x0]
8000316c:	0c 0a       	add	r10,r6
8000316e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003170:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003174:	72 09       	ld.w	r9,r9[0x0]
80003176:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000317a:	2f f8       	sub	r8,-1
8000317c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003180:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003182:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003186:	92 08       	ld.sh	r8,r9[0x0]
80003188:	20 28       	sub	r8,2
8000318a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000318c:	30 09       	mov	r9,0
8000318e:	f2 08 19 00 	cp.h	r8,r9
80003192:	e0 89 00 26 	brgt	800031de <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003196:	30 39       	mov	r9,3
80003198:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000319c:	91 09       	st.w	r8[0x0],r9
8000319e:	c2 08       	rjmp	800031de <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800031a0:	e6 16 00 ff 	andh	r6,0xff,COH
800031a4:	fc 19 00 ba 	movh	r9,0xba
800031a8:	12 36       	cp.w	r6,r9
800031aa:	c0 e1       	brne	800031c6 <phy_rx_func+0x206>
800031ac:	fe f8 0c b8 	ld.w	r8,pc[3256]
800031b0:	90 09       	ld.sh	r9,r8[0x0]
800031b2:	30 08       	mov	r8,0
800031b4:	f0 09 19 00 	cp.h	r9,r8
800031b8:	c0 71       	brne	800031c6 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800031ba:	fe f8 0c a2 	ld.w	r8,pc[3234]
800031be:	70 0c       	ld.w	r12,r8[0x0]
800031c0:	f0 1f 03 2a 	mcall	80003e68 <phy_rx_func+0xea8>
800031c4:	c0 98       	rjmp	800031d6 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800031c6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800031ca:	70 0c       	ld.w	r12,r8[0x0]
800031cc:	fe f8 0c 90 	ld.w	r8,pc[3216]
800031d0:	70 0b       	ld.w	r11,r8[0x0]
800031d2:	f0 1f 03 24 	mcall	80003e60 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800031d6:	30 09       	mov	r9,0
800031d8:	fe f8 0c 70 	ld.w	r8,pc[3184]
800031dc:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800031de:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800031e2:	11 89       	ld.ub	r9,r8[0x0]
800031e4:	30 08       	mov	r8,0
800031e6:	f0 09 18 00 	cp.b	r9,r8
800031ea:	c1 31       	brne	80003210 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800031ec:	fe f6 0c 84 	ld.w	r6,pc[3204]
800031f0:	6c 0c       	ld.w	r12,r6[0x0]
800031f2:	f0 1f 03 1a 	mcall	80003e58 <phy_rx_func+0xe98>
800031f6:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800031fa:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800031fc:	6c 0c       	ld.w	r12,r6[0x0]
800031fe:	f0 1f 03 17 	mcall	80003e58 <phy_rx_func+0xe98>
80003202:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003206:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003208:	30 19       	mov	r9,1
8000320a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000320e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003210:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003214:	70 08       	ld.w	r8,r8[0x0]
80003216:	58 28       	cp.w	r8,2
80003218:	e0 80 01 98 	breq	80003548 <phy_rx_func+0x588>
8000321c:	e0 8b 00 06 	brhi	80003228 <phy_rx_func+0x268>
80003220:	58 08       	cp.w	r8,0
80003222:	c0 b0       	breq	80003238 <phy_rx_func+0x278>
80003224:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003228:	58 38       	cp.w	r8,3
8000322a:	e0 80 05 c5 	breq	80003db4 <phy_rx_func+0xdf4>
8000322e:	58 48       	cp.w	r8,4
80003230:	e0 81 06 05 	brne	80003e3a <phy_rx_func+0xe7a>
80003234:	e0 8f 02 4b 	bral	800036ca <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003238:	6e 28       	ld.w	r8,r7[0x8]
8000323a:	e0 6a 5a 5a 	mov	r10,23130
8000323e:	ea 1a ab cd 	orh	r10,0xabcd
80003242:	14 38       	cp.w	r8,r10
80003244:	c0 71       	brne	80003252 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003246:	30 09       	mov	r9,0
80003248:	fe f8 0c 38 	ld.w	r8,pc[3128]
8000324c:	91 09       	st.w	r8[0x0],r9
8000324e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003252:	10 99       	mov	r9,r8
80003254:	e0 19 00 00 	andl	r9,0x0
80003258:	fc 1a ab cd 	movh	r10,0xabcd
8000325c:	14 39       	cp.w	r9,r10
8000325e:	e0 81 05 ee 	brne	80003e3a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003262:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003266:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000326a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000326c:	6e 29       	ld.w	r9,r7[0x8]
8000326e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003272:	e0 49 c0 00 	cp.w	r9,49152
80003276:	e0 81 00 ce 	brne	80003412 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000327a:	30 1a       	mov	r10,1
8000327c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003280:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003282:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003286:	72 09       	ld.w	r9,r9[0x0]
80003288:	58 09       	cp.w	r9,0
8000328a:	c0 71       	brne	80003298 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000328c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003290:	f0 1f 03 00 	mcall	80003e90 <phy_rx_func+0xed0>
80003294:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003298:	ef 3a 00 0d 	ld.ub	r10,r7[13]
8000329c:	fe f9 0b f8 	ld.w	r9,pc[3064]
800032a0:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800032a2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800032a6:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800032aa:	fe fa 0b ee 	ld.w	r10,pc[3054]
800032ae:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800032b0:	13 89       	ld.ub	r9,r9[0x0]
800032b2:	37 fa       	mov	r10,127
800032b4:	f4 09 18 00 	cp.b	r9,r10
800032b8:	c6 d0       	breq	80003392 <phy_rx_func+0x3d2>
800032ba:	e0 8b 00 0c 	brhi	800032d2 <phy_rx_func+0x312>
800032be:	31 2a       	mov	r10,18
800032c0:	f4 09 18 00 	cp.b	r9,r10
800032c4:	c4 20       	breq	80003348 <phy_rx_func+0x388>
800032c6:	31 3a       	mov	r10,19
800032c8:	f4 09 18 00 	cp.b	r9,r10
800032cc:	e0 81 00 83 	brne	800033d2 <phy_rx_func+0x412>
800032d0:	c5 b8       	rjmp	80003386 <phy_rx_func+0x3c6>
800032d2:	2f 09       	sub	r9,-16
800032d4:	30 1a       	mov	r10,1
800032d6:	f4 09 18 00 	cp.b	r9,r10
800032da:	e0 8b 00 7c 	brhi	800033d2 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800032de:	ef 38 00 0e 	ld.ub	r8,r7[14]
800032e2:	e2 18 00 f0 	andl	r8,0xf0,COH
800032e6:	59 08       	cp.w	r8,16
800032e8:	c0 71       	brne	800032f6 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800032ea:	30 19       	mov	r9,1
800032ec:	fe f8 0b 94 	ld.w	r8,pc[2964]
800032f0:	91 09       	st.w	r8[0x0],r9
800032f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800032f6:	e0 48 00 20 	cp.w	r8,32
800032fa:	c2 11       	brne	8000333c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800032fc:	30 a9       	mov	r9,10
800032fe:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003302:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003304:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003308:	6c 08       	ld.w	r8,r6[0x0]
8000330a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000330e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003312:	2f f8       	sub	r8,-1
80003314:	6e 0c       	ld.w	r12,r7[0x0]
80003316:	f4 ca fe 00 	sub	r10,r10,-512
8000331a:	30 0b       	mov	r11,0
8000331c:	10 0c       	add	r12,r8
8000331e:	f0 1f 02 e1 	mcall	80003ea0 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003322:	30 08       	mov	r8,0
80003324:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003326:	6e 0c       	ld.w	r12,r7[0x0]
80003328:	f0 1f 02 df 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000332c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003330:	70 0c       	ld.w	r12,r8[0x0]
80003332:	f0 1f 02 ca 	mcall	80003e58 <phy_rx_func+0xe98>
80003336:	8f 0c       	st.w	r7[0x0],r12
80003338:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000333c:	30 09       	mov	r9,0
8000333e:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003342:	91 09       	st.w	r8[0x0],r9
80003344:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003348:	20 48       	sub	r8,4
8000334a:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000334e:	93 08       	st.w	r9[0x0],r8
80003350:	58 08       	cp.w	r8,0
80003352:	e0 80 05 74 	breq	80003e3a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003356:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000335a:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000335e:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003362:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003364:	8e 69       	ld.sh	r9,r7[0xc]
80003366:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000336a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000336c:	8e 79       	ld.sh	r9,r7[0xe]
8000336e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003370:	f0 1f 02 d0 	mcall	80003eb0 <phy_rx_func+0xef0>
80003374:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003378:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000337a:	30 49       	mov	r9,4
8000337c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003380:	91 09       	st.w	r8[0x0],r9
80003382:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003386:	30 09       	mov	r9,0
80003388:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000338c:	91 09       	st.w	r8[0x0],r9
8000338e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003392:	20 48       	sub	r8,4
80003394:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003398:	93 08       	st.w	r9[0x0],r8
8000339a:	58 08       	cp.w	r8,0
8000339c:	e0 80 05 4f 	breq	80003e3a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800033a0:	fe f8 0b 14 	ld.w	r8,pc[2836]
800033a4:	70 09       	ld.w	r9,r8[0x0]
800033a6:	8e 7b       	ld.sh	r11,r7[0xe]
800033a8:	fe fa 0b 10 	ld.w	r10,pc[2832]
800033ac:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800033b0:	2f f9       	sub	r9,-1
800033b2:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800033b4:	fe f8 0a e4 	ld.w	r8,pc[2788]
800033b8:	70 09       	ld.w	r9,r8[0x0]
800033ba:	20 29       	sub	r9,2
800033bc:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800033be:	30 29       	mov	r9,2
800033c0:	fe f8 0a c0 	ld.w	r8,pc[2752]
800033c4:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800033c6:	30 39       	mov	r9,3
800033c8:	fe f8 0a b4 	ld.w	r8,pc[2740]
800033cc:	91 09       	st.w	r8[0x0],r9
800033ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800033d2:	30 3a       	mov	r10,3
800033d4:	fe f9 0a ac 	ld.w	r9,pc[2732]
800033d8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800033da:	6e 2a       	ld.w	r10,r7[0x8]
800033dc:	fe f9 0a e0 	ld.w	r9,pc[2784]
800033e0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800033e2:	6e 3a       	ld.w	r10,r7[0xc]
800033e4:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800033e6:	59 48       	cp.w	r8,20
800033e8:	c0 61       	brne	800033f4 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800033ea:	31 89       	mov	r9,24
800033ec:	fe f8 0a 98 	ld.w	r8,pc[2712]
800033f0:	91 09       	st.w	r8[0x0],r9
800033f2:	c0 a8       	rjmp	80003406 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800033f4:	fe f8 0a 90 	ld.w	r8,pc[2704]
800033f8:	70 08       	ld.w	r8,r8[0x0]
800033fa:	59 08       	cp.w	r8,16
800033fc:	c0 51       	brne	80003406 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800033fe:	31 09       	mov	r9,16
80003400:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003404:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003406:	30 49       	mov	r9,4
80003408:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000340c:	91 09       	st.w	r8[0x0],r9
8000340e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003412:	e0 49 10 00 	cp.w	r9,4096
80003416:	5f 1a       	srne	r10
80003418:	e0 49 20 00 	cp.w	r9,8192
8000341c:	5f 19       	srne	r9
8000341e:	f5 e9 00 09 	and	r9,r10,r9
80003422:	e0 81 05 0c 	brne	80003e3a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003426:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000342a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000342c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003430:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003432:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003436:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003438:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000343c:	72 09       	ld.w	r9,r9[0x0]
8000343e:	58 09       	cp.w	r9,0
80003440:	c0 71       	brne	8000344e <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003442:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003446:	f0 1f 02 93 	mcall	80003e90 <phy_rx_func+0xed0>
8000344a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000344e:	6e 2a       	ld.w	r10,r7[0x8]
80003450:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003454:	58 1a       	cp.w	r10,1
80003456:	e0 8b 00 4d 	brhi	800034f0 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000345a:	20 48       	sub	r8,4
8000345c:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003460:	93 08       	st.w	r9[0x0],r8
80003462:	58 08       	cp.w	r8,0
80003464:	e0 80 04 eb 	breq	80003e3a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003468:	8e 68       	ld.sh	r8,r7[0xc]
8000346a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000346e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003472:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003474:	30 09       	mov	r9,0
80003476:	f2 08 19 00 	cp.h	r8,r9
8000347a:	c0 70       	breq	80003488 <phy_rx_func+0x4c8>
8000347c:	30 19       	mov	r9,1
8000347e:	f2 08 19 00 	cp.h	r8,r9
80003482:	e0 81 04 dc 	brne	80003e3a <phy_rx_func+0xe7a>
80003486:	c2 68       	rjmp	800034d2 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003488:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000348c:	70 0a       	ld.w	r10,r8[0x0]
8000348e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003492:	72 09       	ld.w	r9,r9[0x0]
80003494:	8e 7b       	ld.sh	r11,r7[0xe]
80003496:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000349a:	70 09       	ld.w	r9,r8[0x0]
8000349c:	2f f9       	sub	r9,-1
8000349e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034a0:	e0 49 00 ff 	cp.w	r9,255
800034a4:	e0 88 00 11 	brls	800034c6 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800034a8:	30 09       	mov	r9,0
800034aa:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800034ac:	fe f7 09 c8 	ld.w	r7,pc[2504]
800034b0:	6e 0c       	ld.w	r12,r7[0x0]
800034b2:	f0 1f 02 7d 	mcall	80003ea4 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800034b6:	fe f8 09 ba 	ld.w	r8,pc[2490]
800034ba:	70 0c       	ld.w	r12,r8[0x0]
800034bc:	f0 1f 02 67 	mcall	80003e58 <phy_rx_func+0xe98>
800034c0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800034c2:	e0 80 04 bc 	breq	80003e3a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800034c6:	30 29       	mov	r9,2
800034c8:	fe f8 09 b4 	ld.w	r8,pc[2484]
800034cc:	91 09       	st.w	r8[0x0],r9
800034ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800034d2:	8e 79       	ld.sh	r9,r7[0xe]
800034d4:	30 38       	mov	r8,3
800034d6:	f0 09 19 00 	cp.h	r9,r8
800034da:	c0 51       	brne	800034e4 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800034dc:	30 19       	mov	r9,1
800034de:	fe f8 09 f2 	ld.w	r8,pc[2546]
800034e2:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800034e4:	30 29       	mov	r9,2
800034e6:	fe f8 09 96 	ld.w	r8,pc[2454]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800034f0:	58 18       	cp.w	r8,1
800034f2:	e0 88 04 a4 	brls	80003e3a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800034f6:	fe f8 09 d6 	ld.w	r8,pc[2518]
800034fa:	70 0a       	ld.w	r10,r8[0x0]
800034fc:	6e 3b       	ld.w	r11,r7[0xc]
800034fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003502:	70 09       	ld.w	r9,r8[0x0]
80003504:	2f f9       	sub	r9,-1
80003506:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003508:	e0 49 00 ff 	cp.w	r9,255
8000350c:	e0 88 00 11 	brls	8000352e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003510:	30 09       	mov	r9,0
80003512:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003514:	fe f7 09 60 	ld.w	r7,pc[2400]
80003518:	6e 0c       	ld.w	r12,r7[0x0]
8000351a:	f0 1f 02 63 	mcall	80003ea4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000351e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003522:	70 0c       	ld.w	r12,r8[0x0]
80003524:	f0 1f 02 4d 	mcall	80003e58 <phy_rx_func+0xe98>
80003528:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000352a:	e0 80 04 88 	breq	80003e3a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000352e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003532:	72 08       	ld.w	r8,r9[0x0]
80003534:	20 28       	sub	r8,2
80003536:	93 08       	st.w	r9[0x0],r8
80003538:	e0 80 04 81 	breq	80003e3a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000353c:	30 29       	mov	r9,2
8000353e:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003542:	91 09       	st.w	r8[0x0],r9
80003544:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003548:	fe f8 09 84 	ld.w	r8,pc[2436]
8000354c:	70 0a       	ld.w	r10,r8[0x0]
8000354e:	fe f9 09 26 	ld.w	r9,pc[2342]
80003552:	72 09       	ld.w	r9,r9[0x0]
80003554:	8e 4b       	ld.sh	r11,r7[0x8]
80003556:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000355a:	70 09       	ld.w	r9,r8[0x0]
8000355c:	2f f9       	sub	r9,-1
8000355e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003560:	e0 49 00 ff 	cp.w	r9,255
80003564:	e0 88 00 16 	brls	80003590 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003568:	30 09       	mov	r9,0
8000356a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000356c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003570:	6c 0c       	ld.w	r12,r6[0x0]
80003572:	f0 1f 02 4d 	mcall	80003ea4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003576:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000357a:	70 0c       	ld.w	r12,r8[0x0]
8000357c:	f0 1f 02 37 	mcall	80003e58 <phy_rx_func+0xe98>
80003580:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003582:	c0 71       	brne	80003590 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003584:	30 09       	mov	r9,0
80003586:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000358a:	91 09       	st.w	r8[0x0],r9
8000358c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003590:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003594:	72 08       	ld.w	r8,r9[0x0]
80003596:	20 28       	sub	r8,2
80003598:	93 08       	st.w	r9[0x0],r8
8000359a:	c0 71       	brne	800035a8 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
8000359c:	30 09       	mov	r9,0
8000359e:	fe f8 08 de 	ld.w	r8,pc[2270]
800035a2:	91 09       	st.w	r8[0x0],r9
800035a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800035a8:	fe f8 09 24 	ld.w	r8,pc[2340]
800035ac:	70 0a       	ld.w	r10,r8[0x0]
800035ae:	fe f9 08 c6 	ld.w	r9,pc[2246]
800035b2:	72 09       	ld.w	r9,r9[0x0]
800035b4:	8e 5b       	ld.sh	r11,r7[0xa]
800035b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035ba:	70 09       	ld.w	r9,r8[0x0]
800035bc:	2f f9       	sub	r9,-1
800035be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035c0:	e0 49 00 ff 	cp.w	r9,255
800035c4:	e0 88 00 16 	brls	800035f0 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800035c8:	30 09       	mov	r9,0
800035ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035cc:	fe f6 08 a8 	ld.w	r6,pc[2216]
800035d0:	6c 0c       	ld.w	r12,r6[0x0]
800035d2:	f0 1f 02 35 	mcall	80003ea4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035d6:	fe f8 08 9a 	ld.w	r8,pc[2202]
800035da:	70 0c       	ld.w	r12,r8[0x0]
800035dc:	f0 1f 02 1f 	mcall	80003e58 <phy_rx_func+0xe98>
800035e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800035e2:	c0 71       	brne	800035f0 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800035e4:	30 09       	mov	r9,0
800035e6:	fe f8 08 96 	ld.w	r8,pc[2198]
800035ea:	91 09       	st.w	r8[0x0],r9
800035ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800035f0:	fe f9 08 94 	ld.w	r9,pc[2196]
800035f4:	72 08       	ld.w	r8,r9[0x0]
800035f6:	20 28       	sub	r8,2
800035f8:	93 08       	st.w	r9[0x0],r8
800035fa:	c0 71       	brne	80003608 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800035fc:	30 09       	mov	r9,0
800035fe:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003602:	91 09       	st.w	r8[0x0],r9
80003604:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003608:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000360c:	70 0a       	ld.w	r10,r8[0x0]
8000360e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003612:	72 09       	ld.w	r9,r9[0x0]
80003614:	8e 6b       	ld.sh	r11,r7[0xc]
80003616:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000361a:	70 09       	ld.w	r9,r8[0x0]
8000361c:	2f f9       	sub	r9,-1
8000361e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003620:	e0 49 00 ff 	cp.w	r9,255
80003624:	e0 88 00 16 	brls	80003650 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003628:	30 09       	mov	r9,0
8000362a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000362c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003630:	6c 0c       	ld.w	r12,r6[0x0]
80003632:	f0 1f 02 1d 	mcall	80003ea4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003636:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000363a:	70 0c       	ld.w	r12,r8[0x0]
8000363c:	f0 1f 02 07 	mcall	80003e58 <phy_rx_func+0xe98>
80003640:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003642:	c0 71       	brne	80003650 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003644:	30 09       	mov	r9,0
80003646:	fe f8 08 36 	ld.w	r8,pc[2102]
8000364a:	91 09       	st.w	r8[0x0],r9
8000364c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003650:	fe f9 08 34 	ld.w	r9,pc[2100]
80003654:	72 08       	ld.w	r8,r9[0x0]
80003656:	20 28       	sub	r8,2
80003658:	93 08       	st.w	r9[0x0],r8
8000365a:	c0 71       	brne	80003668 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
8000365c:	30 09       	mov	r9,0
8000365e:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003662:	91 09       	st.w	r8[0x0],r9
80003664:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003668:	fe f8 08 64 	ld.w	r8,pc[2148]
8000366c:	70 0a       	ld.w	r10,r8[0x0]
8000366e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003672:	72 09       	ld.w	r9,r9[0x0]
80003674:	8e 7b       	ld.sh	r11,r7[0xe]
80003676:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000367a:	70 09       	ld.w	r9,r8[0x0]
8000367c:	2f f9       	sub	r9,-1
8000367e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003680:	e0 49 00 ff 	cp.w	r9,255
80003684:	e0 88 00 16 	brls	800036b0 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003688:	30 09       	mov	r9,0
8000368a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000368c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003690:	6e 0c       	ld.w	r12,r7[0x0]
80003692:	f0 1f 02 05 	mcall	80003ea4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003696:	fe f8 07 da 	ld.w	r8,pc[2010]
8000369a:	70 0c       	ld.w	r12,r8[0x0]
8000369c:	f0 1f 01 ef 	mcall	80003e58 <phy_rx_func+0xe98>
800036a0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800036a2:	c0 71       	brne	800036b0 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800036a4:	30 09       	mov	r9,0
800036a6:	fe f8 07 d6 	ld.w	r8,pc[2006]
800036aa:	91 09       	st.w	r8[0x0],r9
800036ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036b0:	fe f9 07 d4 	ld.w	r9,pc[2004]
800036b4:	72 08       	ld.w	r8,r9[0x0]
800036b6:	20 28       	sub	r8,2
800036b8:	93 08       	st.w	r9[0x0],r8
800036ba:	e0 81 03 c0 	brne	80003e3a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800036be:	30 09       	mov	r9,0
800036c0:	fe f8 07 bc 	ld.w	r8,pc[1980]
800036c4:	91 09       	st.w	r8[0x0],r9
800036c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800036ca:	fe f8 07 ca 	ld.w	r8,pc[1994]
800036ce:	11 89       	ld.ub	r9,r8[0x0]
800036d0:	31 28       	mov	r8,18
800036d2:	f0 09 18 00 	cp.b	r9,r8
800036d6:	e0 81 01 4c 	brne	8000396e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800036da:	ef 39 00 09 	ld.ub	r9,r7[9]
800036de:	fe f8 07 b6 	ld.w	r8,pc[1974]
800036e2:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800036e4:	11 89       	ld.ub	r9,r8[0x0]
800036e6:	3f 28       	mov	r8,-14
800036e8:	f0 09 18 00 	cp.b	r9,r8
800036ec:	e0 81 01 3b 	brne	80003962 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800036f0:	30 19       	mov	r9,1
800036f2:	fe f8 07 ce 	ld.w	r8,pc[1998]
800036f6:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800036f8:	6e 29       	ld.w	r9,r7[0x8]
800036fa:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800036fe:	fe f8 07 86 	ld.w	r8,pc[1926]
80003702:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003704:	8e 59       	ld.sh	r9,r7[0xa]
80003706:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000370a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000370c:	8e 69       	ld.sh	r9,r7[0xc]
8000370e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003710:	8e 79       	ld.sh	r9,r7[0xe]
80003712:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003714:	fe f8 07 88 	ld.w	r8,pc[1928]
80003718:	fe f9 07 60 	ld.w	r9,pc[1888]
8000371c:	72 0a       	ld.w	r10,r9[0x0]
8000371e:	70 09       	ld.w	r9,r8[0x0]
80003720:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003724:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003728:	70 09       	ld.w	r9,r8[0x0]
8000372a:	2f f9       	sub	r9,-1
8000372c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000372e:	e0 49 01 ff 	cp.w	r9,511
80003732:	e0 88 00 16 	brls	8000375e <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003736:	30 09       	mov	r9,0
80003738:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000373a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000373e:	6c 0c       	ld.w	r12,r6[0x0]
80003740:	f0 1f 01 d9 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003744:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003748:	70 0c       	ld.w	r12,r8[0x0]
8000374a:	f0 1f 01 c4 	mcall	80003e58 <phy_rx_func+0xe98>
8000374e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003750:	c0 71       	brne	8000375e <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003752:	30 09       	mov	r9,0
80003754:	fe f8 07 28 	ld.w	r8,pc[1832]
80003758:	91 09       	st.w	r8[0x0],r9
8000375a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000375e:	fe f9 07 26 	ld.w	r9,pc[1830]
80003762:	72 08       	ld.w	r8,r9[0x0]
80003764:	20 18       	sub	r8,1
80003766:	93 08       	st.w	r9[0x0],r8
80003768:	c0 71       	brne	80003776 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003776:	fe f8 07 26 	ld.w	r8,pc[1830]
8000377a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000377e:	72 0a       	ld.w	r10,r9[0x0]
80003780:	70 09       	ld.w	r9,r8[0x0]
80003782:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003786:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	2f f9       	sub	r9,-1
8000378e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003790:	e0 49 01 ff 	cp.w	r9,511
80003794:	e0 88 00 16 	brls	800037c0 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003798:	30 09       	mov	r9,0
8000379a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000379c:	fe f6 06 dc 	ld.w	r6,pc[1756]
800037a0:	6c 0c       	ld.w	r12,r6[0x0]
800037a2:	f0 1f 01 c1 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037a6:	fe f8 06 ca 	ld.w	r8,pc[1738]
800037aa:	70 0c       	ld.w	r12,r8[0x0]
800037ac:	f0 1f 01 ab 	mcall	80003e58 <phy_rx_func+0xe98>
800037b0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037b2:	c0 71       	brne	800037c0 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800037b4:	30 09       	mov	r9,0
800037b6:	fe f8 06 c6 	ld.w	r8,pc[1734]
800037ba:	91 09       	st.w	r8[0x0],r9
800037bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037c0:	fe f9 06 c4 	ld.w	r9,pc[1732]
800037c4:	72 08       	ld.w	r8,r9[0x0]
800037c6:	20 18       	sub	r8,1
800037c8:	93 08       	st.w	r9[0x0],r8
800037ca:	c0 71       	brne	800037d8 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800037cc:	30 09       	mov	r9,0
800037ce:	fe f8 06 ae 	ld.w	r8,pc[1710]
800037d2:	91 09       	st.w	r8[0x0],r9
800037d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800037d8:	fe f8 06 c4 	ld.w	r8,pc[1732]
800037dc:	fe f9 06 9c 	ld.w	r9,pc[1692]
800037e0:	72 0a       	ld.w	r10,r9[0x0]
800037e2:	70 09       	ld.w	r9,r8[0x0]
800037e4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800037e8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037ec:	70 09       	ld.w	r9,r8[0x0]
800037ee:	2f f9       	sub	r9,-1
800037f0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037f2:	e0 49 01 ff 	cp.w	r9,511
800037f6:	e0 88 00 16 	brls	80003822 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800037fa:	30 09       	mov	r9,0
800037fc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037fe:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003802:	6c 0c       	ld.w	r12,r6[0x0]
80003804:	f0 1f 01 a8 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003808:	fe f8 06 68 	ld.w	r8,pc[1640]
8000380c:	70 0c       	ld.w	r12,r8[0x0]
8000380e:	f0 1f 01 93 	mcall	80003e58 <phy_rx_func+0xe98>
80003812:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003814:	c0 71       	brne	80003822 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003816:	30 09       	mov	r9,0
80003818:	fe f8 06 64 	ld.w	r8,pc[1636]
8000381c:	91 09       	st.w	r8[0x0],r9
8000381e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003822:	fe f9 06 62 	ld.w	r9,pc[1634]
80003826:	72 08       	ld.w	r8,r9[0x0]
80003828:	20 18       	sub	r8,1
8000382a:	93 08       	st.w	r9[0x0],r8
8000382c:	c0 71       	brne	8000383a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000382e:	30 09       	mov	r9,0
80003830:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003834:	91 09       	st.w	r8[0x0],r9
80003836:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000383a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000383e:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003842:	72 0a       	ld.w	r10,r9[0x0]
80003844:	70 09       	ld.w	r9,r8[0x0]
80003846:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000384a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000384e:	70 09       	ld.w	r9,r8[0x0]
80003850:	2f f9       	sub	r9,-1
80003852:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003854:	e0 49 01 ff 	cp.w	r9,511
80003858:	e0 88 00 16 	brls	80003884 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000385c:	30 09       	mov	r9,0
8000385e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003860:	fe f6 06 18 	ld.w	r6,pc[1560]
80003864:	6c 0c       	ld.w	r12,r6[0x0]
80003866:	f0 1f 01 90 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000386a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000386e:	70 0c       	ld.w	r12,r8[0x0]
80003870:	f0 1f 01 7a 	mcall	80003e58 <phy_rx_func+0xe98>
80003874:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003876:	c0 71       	brne	80003884 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003878:	30 09       	mov	r9,0
8000387a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000387e:	91 09       	st.w	r8[0x0],r9
80003880:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003884:	fe f9 06 00 	ld.w	r9,pc[1536]
80003888:	72 08       	ld.w	r8,r9[0x0]
8000388a:	20 18       	sub	r8,1
8000388c:	93 08       	st.w	r9[0x0],r8
8000388e:	c0 71       	brne	8000389c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003890:	30 09       	mov	r9,0
80003892:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003896:	91 09       	st.w	r8[0x0],r9
80003898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000389c:	fe f8 06 00 	ld.w	r8,pc[1536]
800038a0:	fe f9 05 d8 	ld.w	r9,pc[1496]
800038a4:	72 0a       	ld.w	r10,r9[0x0]
800038a6:	70 09       	ld.w	r9,r8[0x0]
800038a8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800038ac:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038b0:	70 09       	ld.w	r9,r8[0x0]
800038b2:	2f f9       	sub	r9,-1
800038b4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038b6:	e0 49 01 ff 	cp.w	r9,511
800038ba:	e0 88 00 16 	brls	800038e6 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800038be:	30 09       	mov	r9,0
800038c0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038c2:	fe f6 05 b6 	ld.w	r6,pc[1462]
800038c6:	6c 0c       	ld.w	r12,r6[0x0]
800038c8:	f0 1f 01 77 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038cc:	fe f8 05 a4 	ld.w	r8,pc[1444]
800038d0:	70 0c       	ld.w	r12,r8[0x0]
800038d2:	f0 1f 01 62 	mcall	80003e58 <phy_rx_func+0xe98>
800038d6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038d8:	c0 71       	brne	800038e6 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800038da:	30 09       	mov	r9,0
800038dc:	fe f8 05 a0 	ld.w	r8,pc[1440]
800038e0:	91 09       	st.w	r8[0x0],r9
800038e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038e6:	fe f9 05 9e 	ld.w	r9,pc[1438]
800038ea:	72 08       	ld.w	r8,r9[0x0]
800038ec:	20 18       	sub	r8,1
800038ee:	93 08       	st.w	r9[0x0],r8
800038f0:	c0 71       	brne	800038fe <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800038f2:	30 09       	mov	r9,0
800038f4:	fe f8 05 88 	ld.w	r8,pc[1416]
800038f8:	91 09       	st.w	r8[0x0],r9
800038fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800038fe:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003902:	fe f9 05 76 	ld.w	r9,pc[1398]
80003906:	72 0a       	ld.w	r10,r9[0x0]
80003908:	70 09       	ld.w	r9,r8[0x0]
8000390a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000390e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003912:	70 09       	ld.w	r9,r8[0x0]
80003914:	2f f9       	sub	r9,-1
80003916:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003918:	e0 49 01 ff 	cp.w	r9,511
8000391c:	e0 88 00 16 	brls	80003948 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003920:	30 09       	mov	r9,0
80003922:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003924:	fe f7 05 54 	ld.w	r7,pc[1364]
80003928:	6e 0c       	ld.w	r12,r7[0x0]
8000392a:	f0 1f 01 5f 	mcall	80003ea4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000392e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003932:	70 0c       	ld.w	r12,r8[0x0]
80003934:	f0 1f 01 49 	mcall	80003e58 <phy_rx_func+0xe98>
80003938:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000393a:	c0 71       	brne	80003948 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000393c:	30 09       	mov	r9,0
8000393e:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003942:	91 09       	st.w	r8[0x0],r9
80003944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003948:	fe f9 05 3c 	ld.w	r9,pc[1340]
8000394c:	72 08       	ld.w	r8,r9[0x0]
8000394e:	20 18       	sub	r8,1
80003950:	93 08       	st.w	r9[0x0],r8
80003952:	e0 81 02 74 	brne	80003e3a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003956:	30 09       	mov	r9,0
80003958:	fe f8 05 24 	ld.w	r8,pc[1316]
8000395c:	91 09       	st.w	r8[0x0],r9
8000395e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003962:	30 09       	mov	r9,0
80003964:	fe f8 05 18 	ld.w	r8,pc[1304]
80003968:	91 09       	st.w	r8[0x0],r9
8000396a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000396e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003972:	11 89       	ld.ub	r9,r8[0x0]
80003974:	3f 28       	mov	r8,-14
80003976:	f0 09 18 00 	cp.b	r9,r8
8000397a:	c4 31       	brne	80003a00 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000397c:	8e 49       	ld.sh	r9,r7[0x8]
8000397e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003982:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003984:	fe f8 05 18 	ld.w	r8,pc[1304]
80003988:	fe f9 04 f0 	ld.w	r9,pc[1264]
8000398c:	72 0a       	ld.w	r10,r9[0x0]
8000398e:	70 09       	ld.w	r9,r8[0x0]
80003990:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003994:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	2f f9       	sub	r9,-1
8000399c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399e:	e0 49 01 ff 	cp.w	r9,511
800039a2:	e0 88 00 16 	brls	800039ce <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039a6:	30 09       	mov	r9,0
800039a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039aa:	fe f7 04 ce 	ld.w	r7,pc[1230]
800039ae:	6e 0c       	ld.w	r12,r7[0x0]
800039b0:	f0 1f 01 3d 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039b4:	fe f8 04 bc 	ld.w	r8,pc[1212]
800039b8:	70 0c       	ld.w	r12,r8[0x0]
800039ba:	f0 1f 01 28 	mcall	80003e58 <phy_rx_func+0xe98>
800039be:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039c0:	c0 71       	brne	800039ce <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800039c2:	30 09       	mov	r9,0
800039c4:	fe f8 04 b8 	ld.w	r8,pc[1208]
800039c8:	91 09       	st.w	r8[0x0],r9
800039ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039ce:	fe f9 04 b6 	ld.w	r9,pc[1206]
800039d2:	72 08       	ld.w	r8,r9[0x0]
800039d4:	20 18       	sub	r8,1
800039d6:	93 08       	st.w	r9[0x0],r8
800039d8:	c0 71       	brne	800039e6 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	fe f8 04 a0 	ld.w	r8,pc[1184]
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800039e6:	20 18       	sub	r8,1
800039e8:	fe f9 04 9c 	ld.w	r9,pc[1180]
800039ec:	93 08       	st.w	r9[0x0],r8
800039ee:	58 08       	cp.w	r8,0
800039f0:	e0 81 02 25 	brne	80003e3a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800039f4:	30 09       	mov	r9,0
800039f6:	fe f8 04 86 	ld.w	r8,pc[1158]
800039fa:	91 09       	st.w	r8[0x0],r9
800039fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003a00:	fe f8 04 94 	ld.w	r8,pc[1172]
80003a04:	11 89       	ld.ub	r9,r8[0x0]
80003a06:	3f 38       	mov	r8,-13
80003a08:	f0 09 18 00 	cp.b	r9,r8
80003a0c:	e0 81 01 0c 	brne	80003c24 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003a10:	8e 49       	ld.sh	r9,r7[0x8]
80003a12:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003a16:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003a18:	8e 59       	ld.sh	r9,r7[0xa]
80003a1a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003a1c:	8e 69       	ld.sh	r9,r7[0xc]
80003a1e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003a20:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003a24:	fe f9 04 54 	ld.w	r9,pc[1108]
80003a28:	72 0a       	ld.w	r10,r9[0x0]
80003a2a:	70 09       	ld.w	r9,r8[0x0]
80003a2c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a30:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a34:	70 09       	ld.w	r9,r8[0x0]
80003a36:	2f f9       	sub	r9,-1
80003a38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3a:	e0 49 01 ff 	cp.w	r9,511
80003a3e:	e0 88 00 16 	brls	80003a6a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a42:	30 09       	mov	r9,0
80003a44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a46:	fe f6 04 32 	ld.w	r6,pc[1074]
80003a4a:	6c 0c       	ld.w	r12,r6[0x0]
80003a4c:	f0 1f 01 16 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	fe f8 04 20 	ld.w	r8,pc[1056]
80003a54:	70 0c       	ld.w	r12,r8[0x0]
80003a56:	f0 1f 01 01 	mcall	80003e58 <phy_rx_func+0xe98>
80003a5a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a5c:	c0 71       	brne	80003a6a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003a5e:	30 09       	mov	r9,0
80003a60:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003a64:	91 09       	st.w	r8[0x0],r9
80003a66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a6a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003a6e:	72 08       	ld.w	r8,r9[0x0]
80003a70:	20 18       	sub	r8,1
80003a72:	93 08       	st.w	r9[0x0],r8
80003a74:	c0 71       	brne	80003a82 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003a76:	30 09       	mov	r9,0
80003a78:	fe f8 04 04 	ld.w	r8,pc[1028]
80003a7c:	91 09       	st.w	r8[0x0],r9
80003a7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003a82:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003a86:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003a8a:	72 0a       	ld.w	r10,r9[0x0]
80003a8c:	70 09       	ld.w	r9,r8[0x0]
80003a8e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003a92:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a96:	70 09       	ld.w	r9,r8[0x0]
80003a98:	2f f9       	sub	r9,-1
80003a9a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a9c:	e0 49 01 ff 	cp.w	r9,511
80003aa0:	e0 88 00 16 	brls	80003acc <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003aa4:	30 09       	mov	r9,0
80003aa6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003aa8:	fe f6 03 d0 	ld.w	r6,pc[976]
80003aac:	6c 0c       	ld.w	r12,r6[0x0]
80003aae:	f0 1f 00 fe 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ab2:	fe f8 03 be 	ld.w	r8,pc[958]
80003ab6:	70 0c       	ld.w	r12,r8[0x0]
80003ab8:	f0 1f 00 e8 	mcall	80003e58 <phy_rx_func+0xe98>
80003abc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003abe:	c0 71       	brne	80003acc <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003ac0:	30 09       	mov	r9,0
80003ac2:	fe f8 03 ba 	ld.w	r8,pc[954]
80003ac6:	91 09       	st.w	r8[0x0],r9
80003ac8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003acc:	fe f9 03 b8 	ld.w	r9,pc[952]
80003ad0:	72 08       	ld.w	r8,r9[0x0]
80003ad2:	20 18       	sub	r8,1
80003ad4:	93 08       	st.w	r9[0x0],r8
80003ad6:	c0 71       	brne	80003ae4 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003ad8:	30 09       	mov	r9,0
80003ada:	fe f8 03 a2 	ld.w	r8,pc[930]
80003ade:	91 09       	st.w	r8[0x0],r9
80003ae0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003ae4:	fe f8 03 b8 	ld.w	r8,pc[952]
80003ae8:	fe f9 03 90 	ld.w	r9,pc[912]
80003aec:	72 0a       	ld.w	r10,r9[0x0]
80003aee:	70 09       	ld.w	r9,r8[0x0]
80003af0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003af4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003af8:	70 09       	ld.w	r9,r8[0x0]
80003afa:	2f f9       	sub	r9,-1
80003afc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003afe:	e0 49 01 ff 	cp.w	r9,511
80003b02:	e0 88 00 16 	brls	80003b2e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b06:	30 09       	mov	r9,0
80003b08:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b0a:	fe f6 03 6e 	ld.w	r6,pc[878]
80003b0e:	6c 0c       	ld.w	r12,r6[0x0]
80003b10:	f0 1f 00 e5 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b14:	fe f8 03 5c 	ld.w	r8,pc[860]
80003b18:	70 0c       	ld.w	r12,r8[0x0]
80003b1a:	f0 1f 00 d0 	mcall	80003e58 <phy_rx_func+0xe98>
80003b1e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b20:	c0 71       	brne	80003b2e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003b22:	30 09       	mov	r9,0
80003b24:	fe f8 03 58 	ld.w	r8,pc[856]
80003b28:	91 09       	st.w	r8[0x0],r9
80003b2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b2e:	fe f9 03 56 	ld.w	r9,pc[854]
80003b32:	72 08       	ld.w	r8,r9[0x0]
80003b34:	20 18       	sub	r8,1
80003b36:	93 08       	st.w	r9[0x0],r8
80003b38:	c0 71       	brne	80003b46 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003b3a:	30 09       	mov	r9,0
80003b3c:	fe f8 03 40 	ld.w	r8,pc[832]
80003b40:	91 09       	st.w	r8[0x0],r9
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003b46:	fe f8 03 56 	ld.w	r8,pc[854]
80003b4a:	fe f9 03 2e 	ld.w	r9,pc[814]
80003b4e:	72 0a       	ld.w	r10,r9[0x0]
80003b50:	70 09       	ld.w	r9,r8[0x0]
80003b52:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b56:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b5a:	70 09       	ld.w	r9,r8[0x0]
80003b5c:	2f f9       	sub	r9,-1
80003b5e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b60:	e0 49 01 ff 	cp.w	r9,511
80003b64:	e0 88 00 16 	brls	80003b90 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b68:	30 09       	mov	r9,0
80003b6a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b6c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003b70:	6c 0c       	ld.w	r12,r6[0x0]
80003b72:	f0 1f 00 cd 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b76:	fe f8 02 fa 	ld.w	r8,pc[762]
80003b7a:	70 0c       	ld.w	r12,r8[0x0]
80003b7c:	f0 1f 00 b7 	mcall	80003e58 <phy_rx_func+0xe98>
80003b80:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b82:	c0 71       	brne	80003b90 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003b84:	30 09       	mov	r9,0
80003b86:	fe f8 02 f6 	ld.w	r8,pc[758]
80003b8a:	91 09       	st.w	r8[0x0],r9
80003b8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b90:	fe f9 02 f4 	ld.w	r9,pc[756]
80003b94:	72 08       	ld.w	r8,r9[0x0]
80003b96:	20 18       	sub	r8,1
80003b98:	93 08       	st.w	r9[0x0],r8
80003b9a:	c0 71       	brne	80003ba8 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 02 de 	ld.w	r8,pc[734]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003ba8:	fe f8 02 f4 	ld.w	r8,pc[756]
80003bac:	fe f9 02 cc 	ld.w	r9,pc[716]
80003bb0:	72 0a       	ld.w	r10,r9[0x0]
80003bb2:	70 09       	ld.w	r9,r8[0x0]
80003bb4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003bb8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bbc:	70 09       	ld.w	r9,r8[0x0]
80003bbe:	2f f9       	sub	r9,-1
80003bc0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc2:	e0 49 01 ff 	cp.w	r9,511
80003bc6:	e0 88 00 16 	brls	80003bf2 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003bca:	30 09       	mov	r9,0
80003bcc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003bce:	fe f7 02 aa 	ld.w	r7,pc[682]
80003bd2:	6e 0c       	ld.w	r12,r7[0x0]
80003bd4:	f0 1f 00 b4 	mcall	80003ea4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bd8:	fe f8 02 98 	ld.w	r8,pc[664]
80003bdc:	70 0c       	ld.w	r12,r8[0x0]
80003bde:	f0 1f 00 9f 	mcall	80003e58 <phy_rx_func+0xe98>
80003be2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003be4:	c0 71       	brne	80003bf2 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003be6:	30 09       	mov	r9,0
80003be8:	fe f8 02 94 	ld.w	r8,pc[660]
80003bec:	91 09       	st.w	r8[0x0],r9
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bf2:	fe f9 02 92 	ld.w	r9,pc[658]
80003bf6:	72 08       	ld.w	r8,r9[0x0]
80003bf8:	20 18       	sub	r8,1
80003bfa:	93 08       	st.w	r9[0x0],r8
80003bfc:	c0 71       	brne	80003c0a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003bfe:	30 09       	mov	r9,0
80003c00:	fe f8 02 7c 	ld.w	r8,pc[636]
80003c04:	91 09       	st.w	r8[0x0],r9
80003c06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003c0a:	20 18       	sub	r8,1
80003c0c:	fe f9 02 78 	ld.w	r9,pc[632]
80003c10:	93 08       	st.w	r9[0x0],r8
80003c12:	58 08       	cp.w	r8,0
80003c14:	e0 81 01 13 	brne	80003e3a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003c18:	30 09       	mov	r9,0
80003c1a:	fe f8 02 62 	ld.w	r8,pc[610]
80003c1e:	91 09       	st.w	r8[0x0],r9
80003c20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003c24:	fe f8 02 70 	ld.w	r8,pc[624]
80003c28:	11 89       	ld.ub	r9,r8[0x0]
80003c2a:	30 48       	mov	r8,4
80003c2c:	f0 09 18 00 	cp.b	r9,r8
80003c30:	c0 80       	breq	80003c40 <phy_rx_func+0xc80>
80003c32:	fe f8 02 62 	ld.w	r8,pc[610]
80003c36:	11 89       	ld.ub	r9,r8[0x0]
80003c38:	30 38       	mov	r8,3
80003c3a:	f0 09 18 00 	cp.b	r9,r8
80003c3e:	c1 41       	brne	80003c66 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003c40:	6e 29       	ld.w	r9,r7[0x8]
80003c42:	fe f8 02 7a 	ld.w	r8,pc[634]
80003c46:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003c48:	6e 39       	ld.w	r9,r7[0xc]
80003c4a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003c4c:	fe f9 02 38 	ld.w	r9,pc[568]
80003c50:	72 08       	ld.w	r8,r9[0x0]
80003c52:	20 88       	sub	r8,8
80003c54:	93 08       	st.w	r9[0x0],r8
80003c56:	e0 81 00 f2 	brne	80003e3a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003c5a:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003c5c:	fe f9 02 20 	ld.w	r9,pc[544]
80003c60:	93 08       	st.w	r9[0x0],r8
80003c62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003c66:	fe f8 02 2e 	ld.w	r8,pc[558]
80003c6a:	11 89       	ld.ub	r9,r8[0x0]
80003c6c:	31 38       	mov	r8,19
80003c6e:	f0 09 18 00 	cp.b	r9,r8
80003c72:	e0 81 00 9c 	brne	80003daa <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003c76:	fe f8 02 62 	ld.w	r8,pc[610]
80003c7a:	11 88       	ld.ub	r8,r8[0x0]
80003c7c:	30 c9       	mov	r9,12
80003c7e:	f2 08 18 00 	cp.b	r8,r9
80003c82:	e0 81 00 7b 	brne	80003d78 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003c86:	8e 49       	ld.sh	r9,r7[0x8]
80003c88:	fe f8 02 54 	ld.w	r8,pc[596]
80003c8c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003c90:	30 09       	mov	r9,0
80003c92:	fe f8 02 46 	ld.w	r8,pc[582]
80003c96:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c98:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003c9c:	3f 38       	mov	r8,-13
80003c9e:	f0 09 18 00 	cp.b	r9,r8
80003ca2:	c6 61       	brne	80003d6e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ca4:	10 99       	mov	r9,r8
80003ca6:	4f c8       	lddpc	r8,80003e94 <phy_rx_func+0xed4>
80003ca8:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003caa:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003cae:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003cb2:	4f 58       	lddpc	r8,80003e84 <phy_rx_func+0xec4>
80003cb4:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003cb6:	30 19       	mov	r9,1
80003cb8:	fe f8 02 0c 	ld.w	r8,pc[524]
80003cbc:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003cbe:	8e 79       	ld.sh	r9,r7[0xe]
80003cc0:	fe f8 02 14 	ld.w	r8,pc[532]
80003cc4:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003cc6:	4f 68       	lddpc	r8,80003e9c <phy_rx_func+0xedc>
80003cc8:	4e c9       	lddpc	r9,80003e78 <phy_rx_func+0xeb8>
80003cca:	72 0a       	ld.w	r10,r9[0x0]
80003ccc:	70 09       	ld.w	r9,r8[0x0]
80003cce:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003cd2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003cd6:	70 09       	ld.w	r9,r8[0x0]
80003cd8:	2f f9       	sub	r9,-1
80003cda:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cdc:	e0 49 01 ff 	cp.w	r9,511
80003ce0:	e0 88 00 13 	brls	80003d06 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ce4:	30 09       	mov	r9,0
80003ce6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ce8:	4e 46       	lddpc	r6,80003e78 <phy_rx_func+0xeb8>
80003cea:	6c 0c       	ld.w	r12,r6[0x0]
80003cec:	f0 1f 00 6e 	mcall	80003ea4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003cf0:	4e 08       	lddpc	r8,80003e70 <phy_rx_func+0xeb0>
80003cf2:	70 0c       	ld.w	r12,r8[0x0]
80003cf4:	f0 1f 00 59 	mcall	80003e58 <phy_rx_func+0xe98>
80003cf8:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003cfa:	c0 61       	brne	80003d06 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003cfc:	30 09       	mov	r9,0
80003cfe:	4e 08       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003d00:	91 09       	st.w	r8[0x0],r9
80003d02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d06:	4e 09       	lddpc	r9,80003e84 <phy_rx_func+0xec4>
80003d08:	72 08       	ld.w	r8,r9[0x0]
80003d0a:	20 18       	sub	r8,1
80003d0c:	93 08       	st.w	r9[0x0],r8
80003d0e:	c0 61       	brne	80003d1a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003d10:	30 09       	mov	r9,0
80003d12:	4d b8       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003d14:	91 09       	st.w	r8[0x0],r9
80003d16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003d1a:	4e 18       	lddpc	r8,80003e9c <phy_rx_func+0xedc>
80003d1c:	4d 79       	lddpc	r9,80003e78 <phy_rx_func+0xeb8>
80003d1e:	72 0a       	ld.w	r10,r9[0x0]
80003d20:	70 09       	ld.w	r9,r8[0x0]
80003d22:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d26:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d2a:	70 09       	ld.w	r9,r8[0x0]
80003d2c:	2f f9       	sub	r9,-1
80003d2e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d30:	e0 49 01 ff 	cp.w	r9,511
80003d34:	e0 88 00 13 	brls	80003d5a <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d38:	30 09       	mov	r9,0
80003d3a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d3c:	4c f7       	lddpc	r7,80003e78 <phy_rx_func+0xeb8>
80003d3e:	6e 0c       	ld.w	r12,r7[0x0]
80003d40:	f0 1f 00 59 	mcall	80003ea4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d44:	4c b8       	lddpc	r8,80003e70 <phy_rx_func+0xeb0>
80003d46:	70 0c       	ld.w	r12,r8[0x0]
80003d48:	f0 1f 00 44 	mcall	80003e58 <phy_rx_func+0xe98>
80003d4c:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d4e:	c0 61       	brne	80003d5a <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003d50:	30 09       	mov	r9,0
80003d52:	4c b8       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003d54:	91 09       	st.w	r8[0x0],r9
80003d56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003d5a:	4c b9       	lddpc	r9,80003e84 <phy_rx_func+0xec4>
80003d5c:	72 08       	ld.w	r8,r9[0x0]
80003d5e:	20 18       	sub	r8,1
80003d60:	93 08       	st.w	r9[0x0],r8
80003d62:	c6 c1       	brne	80003e3a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003d64:	30 09       	mov	r9,0
80003d66:	4c 68       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003d68:	91 09       	st.w	r8[0x0],r9
80003d6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003d6e:	30 09       	mov	r9,0
80003d70:	4c 38       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003d72:	91 09       	st.w	r8[0x0],r9
80003d74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003d78:	8e 4a       	ld.sh	r10,r7[0x8]
80003d7a:	4d 99       	lddpc	r9,80003edc <phy_rx_func+0xf1c>
80003d7c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003d80:	4d 6a       	lddpc	r10,80003ed8 <phy_rx_func+0xf18>
80003d82:	15 88       	ld.ub	r8,r10[0x0]
80003d84:	f0 cb ff ff 	sub	r11,r8,-1
80003d88:	8e 5c       	ld.sh	r12,r7[0xa]
80003d8a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003d8e:	f0 cb ff fe 	sub	r11,r8,-2
80003d92:	8e 6c       	ld.sh	r12,r7[0xc]
80003d94:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003d98:	f0 cb ff fd 	sub	r11,r8,-3
80003d9c:	8e 7c       	ld.sh	r12,r7[0xe]
80003d9e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003da2:	2f c8       	sub	r8,-4
80003da4:	b4 88       	st.b	r10[0x0],r8
80003da6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003daa:	30 09       	mov	r9,0
80003dac:	4b 48       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003dae:	91 09       	st.w	r8[0x0],r9
80003db0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003db4:	4c 08       	lddpc	r8,80003eb4 <phy_rx_func+0xef4>
80003db6:	70 09       	ld.w	r9,r8[0x0]
80003db8:	8e 4b       	ld.sh	r11,r7[0x8]
80003dba:	4c 0a       	lddpc	r10,80003eb8 <phy_rx_func+0xef8>
80003dbc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003dc0:	2f f9       	sub	r9,-1
80003dc2:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003dc4:	4b 58       	lddpc	r8,80003e98 <phy_rx_func+0xed8>
80003dc6:	70 09       	ld.w	r9,r8[0x0]
80003dc8:	20 29       	sub	r9,2
80003dca:	91 09       	st.w	r8[0x0],r9
80003dcc:	70 08       	ld.w	r8,r8[0x0]
80003dce:	58 08       	cp.w	r8,0
80003dd0:	c2 f1       	brne	80003e2e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003dd2:	30 09       	mov	r9,0
80003dd4:	4b 88       	lddpc	r8,80003eb4 <phy_rx_func+0xef4>
80003dd6:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003dd8:	8e 59       	ld.sh	r9,r7[0xa]
80003dda:	fe 78 82 12 	mov	r8,-32238
80003dde:	f0 09 19 00 	cp.h	r9,r8
80003de2:	c2 11       	brne	80003e24 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003de4:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003de8:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003dec:	4a f8       	lddpc	r8,80003ea8 <phy_rx_func+0xee8>
80003dee:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003df0:	8e 59       	ld.sh	r9,r7[0xa]
80003df2:	4a f8       	lddpc	r8,80003eac <phy_rx_func+0xeec>
80003df4:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003df6:	8e 69       	ld.sh	r9,r7[0xc]
80003df8:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003dfa:	f0 1f 00 2e 	mcall	80003eb0 <phy_rx_func+0xef0>
80003dfe:	4a 18       	lddpc	r8,80003e80 <phy_rx_func+0xec0>
80003e00:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e02:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003e06:	31 38       	mov	r8,19
80003e08:	f0 09 18 00 	cp.b	r9,r8
80003e0c:	c0 71       	brne	80003e1a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003e0e:	10 99       	mov	r9,r8
80003e10:	4a 18       	lddpc	r8,80003e94 <phy_rx_func+0xed4>
80003e12:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003e14:	30 09       	mov	r9,0
80003e16:	49 c8       	lddpc	r8,80003e84 <phy_rx_func+0xec4>
80003e18:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003e1a:	30 49       	mov	r9,4
80003e1c:	49 88       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003e1e:	91 09       	st.w	r8[0x0],r9
80003e20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003e24:	30 09       	mov	r9,0
80003e26:	49 68       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003e28:	91 09       	st.w	r8[0x0],r9
80003e2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003e2e:	4a dc       	lddpc	r12,80003ee0 <phy_rx_func+0xf20>
80003e30:	f0 1f 00 18 	mcall	80003e90 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003e34:	30 09       	mov	r9,0
80003e36:	49 28       	lddpc	r8,80003e7c <phy_rx_func+0xebc>
80003e38:	91 09       	st.w	r8[0x0],r9
80003e3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e3e:	00 00       	add	r0,r0
80003e40:	00 00       	add	r0,r0
80003e42:	0a a8       	st.w	r5++,r8
80003e44:	00 00       	add	r0,r0
80003e46:	0a b4       	st.h	r5++,r4
80003e48:	00 00       	add	r0,r0
80003e4a:	0a 98       	mov	r8,r5
80003e4c:	00 00       	add	r0,r0
80003e4e:	0a 70       	tst	r0,r5
80003e50:	00 00       	add	r0,r0
80003e52:	0a 60       	and	r0,r5
80003e54:	00 00       	add	r0,r0
80003e56:	0a 8c       	andn	r12,r5
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	2a 20       	sub	r0,-94
80003e5c:	00 00       	add	r0,r0
80003e5e:	0a b8       	st.h	r5++,r8
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	29 50       	sub	r0,-107
80003e64:	00 00       	add	r0,r0
80003e66:	0a a0       	st.w	r5++,r0
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	29 6c       	sub	r12,-106
80003e6c:	00 00       	add	r0,r0
80003e6e:	0a 7d       	tst	sp,r5
80003e70:	00 00       	add	r0,r0
80003e72:	0a 94       	mov	r4,r5
80003e74:	00 00       	add	r0,r0
80003e76:	0a ac       	st.w	r5++,r12
80003e78:	00 00       	add	r0,r0
80003e7a:	0a c8       	st.b	r5++,r8
80003e7c:	00 00       	add	r0,r0
80003e7e:	0a 88       	andn	r8,r5
80003e80:	00 00       	add	r0,r0
80003e82:	0a c0       	st.b	r5++,r0
80003e84:	00 00       	add	r0,r0
80003e86:	0a 6c       	and	r12,r5
80003e88:	00 00       	add	r0,r0
80003e8a:	0a 3f       	cp.w	pc,r5
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	c7 84       	brge	80003f7e <local_start_SSC+0x26>
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	61 cc       	ld.w	r12,r0[0x70]
80003e94:	00 00       	add	r0,r0
80003e96:	0a 7c       	tst	r12,r5
80003e98:	00 00       	add	r0,r0
80003e9a:	0a 5c       	eor	r12,r5
80003e9c:	00 00       	add	r0,r0
80003e9e:	0a 74       	tst	r4,r5
80003ea0:	80 00       	ld.sh	r0,r0[0x0]
80003ea2:	6a 14       	ld.w	r4,r5[0x4]
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	2f 60       	sub	r0,-10
80003ea8:	00 00       	add	r0,r0
80003eaa:	0a 45       	or	r5,r5
80003eac:	00 00       	add	r0,r0
80003eae:	0e 78       	tst	r8,r7
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	28 b0       	sub	r0,-117
80003eb4:	00 00       	add	r0,r0
80003eb6:	0a a4       	st.w	r5++,r4
80003eb8:	00 00       	add	r0,r0
80003eba:	0d 7c       	ld.ub	r12,--r6
80003ebc:	00 00       	add	r0,r0
80003ebe:	0a 80       	andn	r0,r5
80003ec0:	00 00       	add	r0,r0
80003ec2:	0a 3c       	cp.w	r12,r5
80003ec4:	00 00       	add	r0,r0
80003ec6:	0a 31       	cp.w	r1,r5
80003ec8:	00 00       	add	r0,r0
80003eca:	0a 54       	eor	r4,r5
80003ecc:	00 00       	add	r0,r0
80003ece:	0a 90       	mov	r0,r5
80003ed0:	00 00       	add	r0,r0
80003ed2:	0a 47       	or	r7,r5
80003ed4:	00 00       	add	r0,r0
80003ed6:	0d 74       	ld.ub	r4,--r6
80003ed8:	00 00       	add	r0,r0
80003eda:	0a b0       	st.h	r5++,r0
80003edc:	00 00       	add	r0,r0
80003ede:	0e 7c       	tst	r12,r7
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	c7 9c       	rcall	80003fd4 <local_start_PDC+0x38>

80003ee4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003ee4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003ee6:	49 88       	lddpc	r8,80003f44 <pdca_int_handler+0x60>
80003ee8:	11 89       	ld.ub	r9,r8[0x0]
80003eea:	ec 19 00 01 	eorl	r9,0x1
80003eee:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003ef0:	11 89       	ld.ub	r9,r8[0x0]
80003ef2:	a5 69       	lsl	r9,0x4
80003ef4:	2f c9       	sub	r9,-4
80003ef6:	49 5a       	lddpc	r10,80003f48 <pdca_int_handler+0x64>
80003ef8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003efa:	fe 7a 00 40 	mov	r10,-65472
80003efe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f00:	30 39       	mov	r9,3
80003f02:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003f04:	11 8a       	ld.ub	r10,r8[0x0]
80003f06:	a5 6a       	lsl	r10,0x4
80003f08:	2f ca       	sub	r10,-4
80003f0a:	49 18       	lddpc	r8,80003f4c <pdca_int_handler+0x68>
80003f0c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003f0e:	fe 78 00 00 	mov	r8,-65536
80003f12:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003f14:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003f16:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003f18:	48 e8       	lddpc	r8,80003f50 <pdca_int_handler+0x6c>
80003f1a:	70 08       	ld.w	r8,r8[0x0]
80003f1c:	58 08       	cp.w	r8,0
80003f1e:	c0 70       	breq	80003f2c <pdca_int_handler+0x48>
80003f20:	48 99       	lddpc	r9,80003f44 <pdca_int_handler+0x60>
80003f22:	13 89       	ld.ub	r9,r9[0x0]
80003f24:	a5 69       	lsl	r9,0x4
80003f26:	48 ac       	lddpc	r12,80003f4c <pdca_int_handler+0x68>
80003f28:	12 0c       	add	r12,r9
80003f2a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003f2c:	48 a8       	lddpc	r8,80003f54 <pdca_int_handler+0x70>
80003f2e:	70 08       	ld.w	r8,r8[0x0]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 70       	breq	80003f40 <pdca_int_handler+0x5c>
80003f34:	48 49       	lddpc	r9,80003f44 <pdca_int_handler+0x60>
80003f36:	13 89       	ld.ub	r9,r9[0x0]
80003f38:	a5 69       	lsl	r9,0x4
80003f3a:	48 4c       	lddpc	r12,80003f48 <pdca_int_handler+0x64>
80003f3c:	12 0c       	add	r12,r9
80003f3e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003f40:	d4 02       	popm	lr
80003f42:	d6 03       	rete
80003f44:	00 00       	add	r0,r0
80003f46:	40 9c       	lddsp	r12,sp[0x24]
80003f48:	00 00       	add	r0,r0
80003f4a:	40 c4       	lddsp	r4,sp[0x30]
80003f4c:	00 00       	add	r0,r0
80003f4e:	40 a4       	lddsp	r4,sp[0x28]
80003f50:	00 00       	add	r0,r0
80003f52:	0a d4       	st.w	--r5,r4
80003f54:	00 00       	add	r0,r0
80003f56:	0a d8       	st.w	--r5,r8

80003f58 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003f58:	fe 78 10 00 	mov	r8,-61440
80003f5c:	e0 69 0d c0 	mov	r9,3520
80003f60:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003f64:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003f68:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003f6c:	fe 78 34 00 	mov	r8,-52224
80003f70:	e0 69 80 00 	mov	r9,32768
80003f74:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003f76:	30 09       	mov	r9,0
80003f78:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003f7a:	e0 69 04 21 	mov	r9,1057
80003f7e:	ea 19 3f 20 	orh	r9,0x3f20
80003f82:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003f84:	e0 69 02 9f 	mov	r9,671
80003f88:	ea 19 01 00 	orh	r9,0x100
80003f8c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003f8e:	e0 6a 04 02 	mov	r10,1026
80003f92:	ea 1a 3f 20 	orh	r10,0x3f20
80003f96:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003f98:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003f9a:	5e fc       	retal	r12

80003f9c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003f9c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003f9e:	30 19       	mov	r9,1
80003fa0:	49 78       	lddpc	r8,80003ffc <local_start_PDC+0x60>
80003fa2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003fa4:	fe 78 00 00 	mov	r8,-65536
80003fa8:	30 7b       	mov	r11,7
80003faa:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003fac:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003fae:	49 59       	lddpc	r9,80004000 <local_start_PDC+0x64>
80003fb0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003fb4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003fb6:	30 3a       	mov	r10,3
80003fb8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003fba:	30 1c       	mov	r12,1
80003fbc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003fbe:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003fc0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003fc2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003fc4:	30 2c       	mov	r12,2
80003fc6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003fc8:	48 f9       	lddpc	r9,80004004 <local_start_PDC+0x68>
80003fca:	e0 68 5a 5a 	mov	r8,23130
80003fce:	ea 18 ab cd 	orh	r8,0xabcd
80003fd2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003fd4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003fd6:	30 0e       	mov	lr,0
80003fd8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003fda:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003fdc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003fde:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003fe0:	fe 78 00 40 	mov	r8,-65472
80003fe4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003fe6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003fe8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003fec:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003fee:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003ff0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003ff2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003ff4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003ff6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ff8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003ffa:	d8 02       	popm	pc
80003ffc:	00 00       	add	r0,r0
80003ffe:	40 9c       	lddsp	r12,sp[0x24]
80004000:	00 00       	add	r0,r0
80004002:	40 a4       	lddsp	r4,sp[0x28]
80004004:	00 00       	add	r0,r0
80004006:	40 c4       	lddsp	r4,sp[0x30]

80004008 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004008:	48 38       	lddpc	r8,80004014 <register_rx_tx_func+0xc>
8000400a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000400c:	48 38       	lddpc	r8,80004018 <register_rx_tx_func+0x10>
8000400e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004010:	5e fc       	retal	r12
80004012:	00 00       	add	r0,r0
80004014:	00 00       	add	r0,r0
80004016:	0a d4       	st.w	--r5,r4
80004018:	00 00       	add	r0,r0
8000401a:	0a d8       	st.w	--r5,r8

8000401c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000401c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000401e:	fe 78 10 00 	mov	r8,-61440
80004022:	30 29       	mov	r9,2
80004024:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004028:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000402c:	10 99       	mov	r9,r8
8000402e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004032:	e2 18 00 02 	andl	r8,0x2,COH
80004036:	cf c0       	breq	8000402e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004038:	fe 79 10 00 	mov	r9,-61440
8000403c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004040:	e2 18 00 02 	andl	r8,0x2,COH
80004044:	cf c1       	brne	8000403c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004046:	30 3a       	mov	r10,3
80004048:	36 0b       	mov	r11,96
8000404a:	48 bc       	lddpc	r12,80004074 <ssc_init+0x58>
8000404c:	f0 1f 00 0b 	mcall	80004078 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004050:	f0 1f 00 0b 	mcall	8000407c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004054:	f0 1f 00 0b 	mcall	80004080 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004058:	fe 79 00 00 	mov	r9,-65536
8000405c:	30 18       	mov	r8,1
8000405e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004060:	fe 7a 00 40 	mov	r10,-65472
80004064:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004066:	e0 6b 01 01 	mov	r11,257
8000406a:	fe 7a 34 00 	mov	r10,-52224
8000406e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004070:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004072:	d8 02       	popm	pc
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	3e e4       	mov	r4,-18
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	4a 70       	lddpc	r0,80004114 <xcmp_DeviceInitializationStatus_request+0x3c>
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	3f 58       	mov	r8,-11
80004080:	80 00       	ld.sh	r0,r0[0x0]
80004082:	3f 9c       	mov	r12,-7

80004084 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004084:	48 28       	lddpc	r8,8000408c <xcmp_register_app_list+0x8>
80004086:	91 0c       	st.w	r8[0x0],r12
}
80004088:	5e fc       	retal	r12
8000408a:	00 00       	add	r0,r0
8000408c:	00 00       	add	r0,r0
8000408e:	40 e4       	lddsp	r4,sp[0x38]

80004090 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004090:	eb cd 40 80 	pushm	r7,lr
80004094:	fa cd 01 00 	sub	sp,sp,256
80004098:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000409a:	16 98       	mov	r8,r11
8000409c:	2f 08       	sub	r8,-16
8000409e:	af a8       	sbr	r8,0xe
800040a0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800040a2:	3f f8       	mov	r8,-1
800040a4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800040a6:	30 b9       	mov	r9,11
800040a8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800040aa:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800040ac:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800040ae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800040b0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800040b2:	f6 ca ff fe 	sub	r10,r11,-2
800040b6:	18 9b       	mov	r11,r12
800040b8:	fa cc ff f0 	sub	r12,sp,-16
800040bc:	f0 1f 00 05 	mcall	800040d0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800040c0:	2f e7       	sub	r7,-2
800040c2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800040c4:	1a 9c       	mov	r12,sp
800040c6:	f0 1f 00 04 	mcall	800040d4 <xcmp_tx+0x44>
}
800040ca:	2c 0d       	sub	sp,-256
800040cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	68 cc       	ld.w	r12,r4[0x30]
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	46 10       	lddsp	r0,sp[0x184]

800040d8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800040d8:	d4 01       	pushm	lr
800040da:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800040de:	fe 78 b4 00 	mov	r8,-19456
800040e2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800040e4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800040e8:	30 89       	mov	r9,8
800040ea:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800040ec:	30 19       	mov	r9,1
800040ee:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800040f0:	30 09       	mov	r9,0
800040f2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800040f4:	30 5a       	mov	r10,5
800040f6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800040f8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800040fa:	30 7a       	mov	r10,7
800040fc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800040fe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004100:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004102:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004106:	30 9b       	mov	r11,9
80004108:	fa cc ff fe 	sub	r12,sp,-2
8000410c:	f0 1f 00 02 	mcall	80004114 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004110:	2c dd       	sub	sp,-204
80004112:	d8 02       	popm	pc
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	40 90       	lddsp	r0,sp[0x24]

80004118 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004118:	d4 01       	pushm	lr
8000411a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000411e:	fe 78 80 00 	mov	r8,-32768
80004122:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004124:	30 38       	mov	r8,3
80004126:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004128:	30 1b       	mov	r11,1
8000412a:	fa cc ff fe 	sub	r12,sp,-2
8000412e:	f0 1f 00 03 	mcall	80004138 <xcmp_opcode_not_supported+0x20>
}
80004132:	2c dd       	sub	sp,-204
80004134:	d8 02       	popm	pc
80004136:	00 00       	add	r0,r0
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	40 90       	lddsp	r0,sp[0x24]

8000413c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
8000413c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000413e:	96 88       	ld.uh	r8,r11[0x0]
80004140:	e2 18 f0 00 	andl	r8,0xf000,COH
80004144:	e0 48 80 00 	cp.w	r8,32768
80004148:	c0 f0       	breq	80004166 <xcmp_exec_func+0x2a>
8000414a:	e0 48 b0 00 	cp.w	r8,45056
8000414e:	c1 20       	breq	80004172 <xcmp_exec_func+0x36>
80004150:	58 08       	cp.w	r8,0
80004152:	c1 51       	brne	8000417c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004154:	78 08       	ld.w	r8,r12[0x0]
80004156:	58 08       	cp.w	r8,0
80004158:	c0 40       	breq	80004160 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000415a:	16 9c       	mov	r12,r11
8000415c:	5d 18       	icall	r8
8000415e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004160:	f0 1f 00 08 	mcall	80004180 <xcmp_exec_func+0x44>
80004164:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004166:	78 18       	ld.w	r8,r12[0x4]
80004168:	58 08       	cp.w	r8,0
8000416a:	c0 90       	breq	8000417c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000416c:	16 9c       	mov	r12,r11
8000416e:	5d 18       	icall	r8
80004170:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004172:	78 28       	ld.w	r8,r12[0x8]
80004174:	58 08       	cp.w	r8,0
80004176:	c0 30       	breq	8000417c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004178:	16 9c       	mov	r12,r11
8000417a:	5d 18       	icall	r8
8000417c:	d8 02       	popm	pc
8000417e:	00 00       	add	r0,r0
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	41 18       	lddsp	r8,sp[0x44]

80004184 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004184:	d4 01       	pushm	lr
80004186:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000418a:	e0 68 04 09 	mov	r8,1033
8000418e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004190:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004194:	30 19       	mov	r9,1
80004196:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004198:	30 09       	mov	r9,0
8000419a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000419c:	30 ca       	mov	r10,12
8000419e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800041a0:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800041a2:	fb 69 00 08 	st.b	sp[8],r9
800041a6:	fa c8 ff f7 	sub	r8,sp,-9
800041aa:	b0 89       	st.b	r8[0x0],r9
800041ac:	fa c8 ff f6 	sub	r8,sp,-10
800041b0:	b0 89       	st.b	r8[0x0],r9
800041b2:	fa c8 ff f5 	sub	r8,sp,-11
800041b6:	b0 89       	st.b	r8[0x0],r9
800041b8:	fa c8 ff f4 	sub	r8,sp,-12
800041bc:	b0 89       	st.b	r8[0x0],r9
800041be:	fa c8 ff f3 	sub	r8,sp,-13
800041c2:	b0 89       	st.b	r8[0x0],r9
800041c4:	fa c8 ff f2 	sub	r8,sp,-14
800041c8:	b0 89       	st.b	r8[0x0],r9
800041ca:	fa c8 ff f1 	sub	r8,sp,-15
800041ce:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800041d0:	30 cb       	mov	r11,12
800041d2:	fa cc ff fe 	sub	r12,sp,-2
800041d6:	f0 1f 00 03 	mcall	800041e0 <xcmp_IdleTestTone+0x5c>
}
800041da:	2c dd       	sub	sp,-204
800041dc:	d8 02       	popm	pc
800041de:	00 00       	add	r0,r0
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	40 90       	lddsp	r0,sp[0x24]

800041e4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800041e4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800041e6:	48 dc       	lddpc	r12,80004218 <xcmp_init+0x34>
800041e8:	f0 1f 00 0d 	mcall	8000421c <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800041ec:	30 4b       	mov	r11,4
800041ee:	31 4c       	mov	r12,20
800041f0:	f0 1f 00 0c 	mcall	80004220 <xcmp_init+0x3c>
800041f4:	48 c8       	lddpc	r8,80004224 <xcmp_init+0x40>
800041f6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800041f8:	30 09       	mov	r9,0
800041fa:	1a d9       	st.w	--sp,r9
800041fc:	1a d9       	st.w	--sp,r9
800041fe:	1a d9       	st.w	--sp,r9
80004200:	30 38       	mov	r8,3
80004202:	e0 6a 01 80 	mov	r10,384
80004206:	48 9b       	lddpc	r11,80004228 <xcmp_init+0x44>
80004208:	48 9c       	lddpc	r12,8000422c <xcmp_init+0x48>
8000420a:	f0 1f 00 0a 	mcall	80004230 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
8000420e:	f0 1f 00 0a 	mcall	80004234 <xcmp_init+0x50>
80004212:	2f dd       	sub	sp,-12
	
}
80004214:	d8 02       	popm	pc
80004216:	00 00       	add	r0,r0
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	43 34       	lddsp	r4,sp[0xcc]
8000421c:	80 00       	ld.sh	r0,r0[0x0]
8000421e:	43 80       	lddsp	r0,sp[0xe0]
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	55 a8       	stdsp	sp[0x168],r8
80004224:	00 00       	add	r0,r0
80004226:	0a e8       	st.h	--r5,r8
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	c7 c8       	rjmp	80004322 <xcmp_rx_process+0xea>
8000422c:	80 00       	ld.sh	r0,r0[0x0]
8000422e:	42 38       	lddsp	r8,sp[0x8c]
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	5c 7c       	castu.h	r12
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	43 b8       	lddsp	r8,sp[0xec]

80004238 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004238:	d4 31       	pushm	r0-r7,lr
8000423a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000423c:	4b 16       	lddpc	r6,80004300 <xcmp_rx_process+0xc8>
8000423e:	30 05       	mov	r5,0
80004240:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004242:	4b 13       	lddpc	r3,80004304 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004244:	4b 12       	lddpc	r2,80004308 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004246:	4b 21       	lddpc	r1,8000430c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004248:	4b 20       	lddpc	r0,80004310 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000424a:	6c 0c       	ld.w	r12,r6[0x0]
8000424c:	0a 99       	mov	r9,r5
8000424e:	08 9a       	mov	r10,r4
80004250:	1a 9b       	mov	r11,sp
80004252:	f0 1f 00 31 	mcall	80004314 <xcmp_rx_process+0xdc>
80004256:	58 1c       	cp.w	r12,1
80004258:	cf 91       	brne	8000424a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000425a:	40 0b       	lddsp	r11,sp[0x0]
8000425c:	58 0b       	cp.w	r11,0
8000425e:	cf 60       	breq	8000424a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004260:	96 0a       	ld.sh	r10,r11[0x0]
80004262:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004266:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000426a:	59 c8       	cp.w	r8,28
8000426c:	c1 e0       	breq	800042a8 <xcmp_rx_process+0x70>
8000426e:	e0 89 00 07 	brgt	8000427c <xcmp_rx_process+0x44>
80004272:	58 e8       	cp.w	r8,14
80004274:	c0 e0       	breq	80004290 <xcmp_rx_process+0x58>
80004276:	58 f8       	cp.w	r8,15
80004278:	c2 41       	brne	800042c0 <xcmp_rx_process+0x88>
8000427a:	c0 f8       	rjmp	80004298 <xcmp_rx_process+0x60>
8000427c:	e0 48 01 09 	cp.w	r8,265
80004280:	c1 80       	breq	800042b0 <xcmp_rx_process+0x78>
80004282:	e0 48 01 0a 	cp.w	r8,266
80004286:	c1 90       	breq	800042b8 <xcmp_rx_process+0x80>
80004288:	e0 48 00 2c 	cp.w	r8,44
8000428c:	c1 a1       	brne	800042c0 <xcmp_rx_process+0x88>
8000428e:	c0 98       	rjmp	800042a0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004290:	4a 2c       	lddpc	r12,80004318 <xcmp_rx_process+0xe0>
80004292:	f0 1f 00 23 	mcall	8000431c <xcmp_rx_process+0xe4>
					break;
80004296:	c2 f8       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004298:	4a 2c       	lddpc	r12,80004320 <xcmp_rx_process+0xe8>
8000429a:	f0 1f 00 21 	mcall	8000431c <xcmp_rx_process+0xe4>
					break;
8000429e:	c2 b8       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800042a0:	4a 1c       	lddpc	r12,80004324 <xcmp_rx_process+0xec>
800042a2:	f0 1f 00 1f 	mcall	8000431c <xcmp_rx_process+0xe4>
					break;
800042a6:	c2 78       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800042a8:	04 9c       	mov	r12,r2
800042aa:	f0 1f 00 1d 	mcall	8000431c <xcmp_rx_process+0xe4>
						, ptr);
					break;
800042ae:	c2 38       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800042b0:	02 9c       	mov	r12,r1
800042b2:	f0 1f 00 1b 	mcall	8000431c <xcmp_rx_process+0xe4>
					break;
800042b6:	c1 f8       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800042b8:	00 9c       	mov	r12,r0
800042ba:	f0 1f 00 19 	mcall	8000431c <xcmp_rx_process+0xe4>
					break;
800042be:	c1 b8       	rjmp	800042f4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800042c0:	12 98       	mov	r8,r9
800042c2:	e2 18 04 00 	andl	r8,0x400,COH
800042c6:	c0 70       	breq	800042d4 <xcmp_rx_process+0x9c>
800042c8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800042cc:	e0 48 00 68 	cp.w	r8,104
800042d0:	e0 8a 00 08 	brle	800042e0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800042d4:	e2 19 f0 00 	andl	r9,0xf000,COH
800042d8:	c0 e1       	brne	800042f4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800042da:	f0 1f 00 14 	mcall	80004328 <xcmp_rx_process+0xf0>
800042de:	c0 b8       	rjmp	800042f4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800042e0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800042e4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800042e8:	49 19       	lddpc	r9,8000432c <xcmp_rx_process+0xf4>
800042ea:	72 08       	ld.w	r8,r9[0x0]
800042ec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800042f0:	f0 1f 00 0b 	mcall	8000431c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800042f4:	66 0c       	ld.w	r12,r3[0x0]
800042f6:	40 0b       	lddsp	r11,sp[0x0]
800042f8:	f0 1f 00 0e 	mcall	80004330 <xcmp_rx_process+0xf8>
800042fc:	ca 7b       	rjmp	8000424a <xcmp_rx_process+0x12>
800042fe:	00 00       	add	r0,r0
80004300:	00 00       	add	r0,r0
80004302:	0a e8       	st.h	--r5,r8
80004304:	00 00       	add	r0,r0
80004306:	0a 8c       	andn	r12,r5
80004308:	00 00       	add	r0,r0
8000430a:	0a f8       	st.b	--r5,r8
8000430c:	00 00       	add	r0,r0
8000430e:	0a ec       	st.h	--r5,r12
80004310:	00 00       	add	r0,r0
80004312:	0b 04       	ld.w	r4,r5++
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	52 9c       	stdsp	sp[0xa4],r12
80004318:	00 00       	add	r0,r0
8000431a:	0b 1c       	ld.sh	r12,r5++
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	41 3c       	lddsp	r12,sp[0x4c]
80004320:	00 00       	add	r0,r0
80004322:	0a dc       	st.w	--r5,r12
80004324:	00 00       	add	r0,r0
80004326:	0b 10       	ld.sh	r0,r5++
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	41 18       	lddsp	r8,sp[0x44]
8000432c:	00 00       	add	r0,r0
8000432e:	40 e4       	lddsp	r4,sp[0x38]
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	29 a4       	sub	r4,-102

80004334 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004334:	eb cd 40 90 	pushm	r4,r7,lr
80004338:	20 1d       	sub	sp,4
8000433a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000433e:	48 c8       	lddpc	r8,8000436c <xcmp_rx+0x38>
80004340:	70 0c       	ld.w	r12,r8[0x0]
80004342:	f0 1f 00 0c 	mcall	80004370 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004346:	c1 00       	breq	80004366 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004348:	fa c7 ff fc 	sub	r7,sp,-4
8000434c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000434e:	e0 6a 00 ca 	mov	r10,202
80004352:	08 9b       	mov	r11,r4
80004354:	f0 1f 00 08 	mcall	80004374 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004358:	48 88       	lddpc	r8,80004378 <xcmp_rx+0x44>
8000435a:	70 0c       	ld.w	r12,r8[0x0]
8000435c:	30 09       	mov	r9,0
8000435e:	12 9a       	mov	r10,r9
80004360:	1a 9b       	mov	r11,sp
80004362:	f0 1f 00 07 	mcall	8000437c <xcmp_rx+0x48>
	}	
}
80004366:	2f fd       	sub	sp,-4
80004368:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000436c:	00 00       	add	r0,r0
8000436e:	0a 8c       	andn	r12,r5
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	2f 10       	sub	r0,-15
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	68 cc       	ld.w	r12,r4[0x30]
80004378:	00 00       	add	r0,r0
8000437a:	0a e8       	st.h	--r5,r8
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	54 a8       	stdsp	sp[0x128],r8

80004380 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004380:	48 28       	lddpc	r8,80004388 <xnl_register_xcmp_func+0x8>
80004382:	91 0c       	st.w	r8[0x0],r12
}
80004384:	5e fc       	retal	r12
80004386:	00 00       	add	r0,r0
80004388:	00 00       	add	r0,r0
8000438a:	0b 4c       	ld.w	r12,--r5

8000438c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000438c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000438e:	48 88       	lddpc	r8,800043ac <xnl_get_msg_ack_func+0x20>
80004390:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004392:	98 49       	ld.sh	r9,r12[0x8]
80004394:	f0 09 19 00 	cp.h	r9,r8
80004398:	c0 81       	brne	800043a8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000439a:	48 68       	lddpc	r8,800043b0 <xnl_get_msg_ack_func+0x24>
8000439c:	70 0c       	ld.w	r12,r8[0x0]
8000439e:	30 09       	mov	r9,0
800043a0:	12 9a       	mov	r10,r9
800043a2:	12 9b       	mov	r11,r9
800043a4:	f0 1f 00 04 	mcall	800043b4 <xnl_get_msg_ack_func+0x28>
800043a8:	d8 02       	popm	pc
800043aa:	00 00       	add	r0,r0
800043ac:	00 00       	add	r0,r0
800043ae:	0b 2c       	ld.uh	r12,r5++
800043b0:	00 00       	add	r0,r0
800043b2:	0b 28       	ld.uh	r8,r5++
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	54 a8       	stdsp	sp[0x128],r8

800043b8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800043b8:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800043bc:	30 09       	mov	r9,0
800043be:	4b 78       	lddpc	r8,80004498 <xnl_init+0xe0>
800043c0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800043c2:	30 0b       	mov	r11,0
800043c4:	30 1c       	mov	r12,1
800043c6:	f0 1f 00 36 	mcall	8000449c <xnl_init+0xe4>
800043ca:	4b 68       	lddpc	r8,800044a0 <xnl_init+0xe8>
800043cc:	91 0c       	st.w	r8[0x0],r12
800043ce:	70 08       	ld.w	r8,r8[0x0]
800043d0:	58 08       	cp.w	r8,0
800043d2:	c0 80       	breq	800043e2 <xnl_init+0x2a>
800043d4:	4b 38       	lddpc	r8,800044a0 <xnl_init+0xe8>
800043d6:	70 0c       	ld.w	r12,r8[0x0]
800043d8:	30 09       	mov	r9,0
800043da:	12 9a       	mov	r10,r9
800043dc:	12 9b       	mov	r11,r9
800043de:	f0 1f 00 32 	mcall	800044a4 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800043e2:	30 4b       	mov	r11,4
800043e4:	31 4c       	mov	r12,20
800043e6:	f0 1f 00 2e 	mcall	8000449c <xnl_init+0xe4>
800043ea:	4b 08       	lddpc	r8,800044a8 <xnl_init+0xf0>
800043ec:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800043ee:	30 4b       	mov	r11,4
800043f0:	31 ec       	mov	r12,30
800043f2:	f0 1f 00 2b 	mcall	8000449c <xnl_init+0xe4>
800043f6:	4a e8       	lddpc	r8,800044ac <xnl_init+0xf4>
800043f8:	91 0c       	st.w	r8[0x0],r12
800043fa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800043fc:	10 96       	mov	r6,r8
800043fe:	4a d5       	lddpc	r5,800044b0 <xnl_init+0xf8>
80004400:	6c 0c       	ld.w	r12,r6[0x0]
80004402:	ea 07 00 0b 	add	r11,r5,r7
80004406:	f0 1f 00 2c 	mcall	800044b4 <xnl_init+0xfc>
8000440a:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000440e:	e0 47 1e 00 	cp.w	r7,7680
80004412:	cf 71       	brne	80004400 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004414:	30 4b       	mov	r11,4
80004416:	31 4c       	mov	r12,20
80004418:	f0 1f 00 21 	mcall	8000449c <xnl_init+0xe4>
8000441c:	4a 78       	lddpc	r8,800044b8 <xnl_init+0x100>
8000441e:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004420:	30 4b       	mov	r11,4
80004422:	30 ac       	mov	r12,10
80004424:	f0 1f 00 1e 	mcall	8000449c <xnl_init+0xe4>
80004428:	4a 58       	lddpc	r8,800044bc <xnl_init+0x104>
8000442a:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000442c:	30 4b       	mov	r11,4
8000442e:	30 ac       	mov	r12,10
80004430:	f0 1f 00 1b 	mcall	8000449c <xnl_init+0xe4>
80004434:	4a 38       	lddpc	r8,800044c0 <xnl_init+0x108>
80004436:	91 0c       	st.w	r8[0x0],r12
80004438:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000443a:	10 96       	mov	r6,r8
8000443c:	4a 25       	lddpc	r5,800044c4 <xnl_init+0x10c>
8000443e:	6c 0c       	ld.w	r12,r6[0x0]
80004440:	ea 07 00 0b 	add	r11,r5,r7
80004444:	f0 1f 00 1c 	mcall	800044b4 <xnl_init+0xfc>
80004448:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000444c:	e0 47 14 00 	cp.w	r7,5120
80004450:	cf 71       	brne	8000443e <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004452:	30 4b       	mov	r11,4
80004454:	30 5c       	mov	r12,5
80004456:	f0 1f 00 12 	mcall	8000449c <xnl_init+0xe4>
8000445a:	49 c8       	lddpc	r8,800044c8 <xnl_init+0x110>
8000445c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000445e:	30 07       	mov	r7,0
80004460:	1a d7       	st.w	--sp,r7
80004462:	1a d7       	st.w	--sp,r7
80004464:	1a d7       	st.w	--sp,r7
80004466:	30 38       	mov	r8,3
80004468:	0e 99       	mov	r9,r7
8000446a:	e0 6a 02 00 	mov	r10,512
8000446e:	49 8b       	lddpc	r11,800044cc <xnl_init+0x114>
80004470:	49 8c       	lddpc	r12,800044d0 <xnl_init+0x118>
80004472:	f0 1f 00 19 	mcall	800044d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004476:	1a d7       	st.w	--sp,r7
80004478:	1a d7       	st.w	--sp,r7
8000447a:	1a d7       	st.w	--sp,r7
8000447c:	30 38       	mov	r8,3
8000447e:	0e 99       	mov	r9,r7
80004480:	e0 6a 03 20 	mov	r10,800
80004484:	49 5b       	lddpc	r11,800044d8 <xnl_init+0x120>
80004486:	49 6c       	lddpc	r12,800044dc <xnl_init+0x124>
80004488:	f0 1f 00 13 	mcall	800044d4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000448c:	f0 1f 00 15 	mcall	800044e0 <xnl_init+0x128>
80004490:	2f ad       	sub	sp,-24
}
80004492:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004496:	00 00       	add	r0,r0
80004498:	00 00       	add	r0,r0
8000449a:	0b 2c       	ld.uh	r12,r5++
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	55 a8       	stdsp	sp[0x168],r8
800044a0:	00 00       	add	r0,r0
800044a2:	0b 28       	ld.uh	r8,r5++
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	54 a8       	stdsp	sp[0x128],r8
800044a8:	00 00       	add	r0,r0
800044aa:	0b 38       	ld.ub	r8,r5++
800044ac:	00 00       	add	r0,r0
800044ae:	0a 8c       	andn	r12,r5
800044b0:	00 00       	add	r0,r0
800044b2:	22 96       	sub	r6,41
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	29 a4       	sub	r4,-102
800044b8:	00 00       	add	r0,r0
800044ba:	0a bc       	st.h	r5++,r12
800044bc:	00 00       	add	r0,r0
800044be:	0a a8       	st.w	r5++,r8
800044c0:	00 00       	add	r0,r0
800044c2:	0a 94       	mov	r4,r5
800044c4:	00 00       	add	r0,r0
800044c6:	0e 96       	mov	r6,r7
800044c8:	00 00       	add	r0,r0
800044ca:	0a 64       	and	r4,r5
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	c7 d0       	breq	800045c8 <xnl_tx_process+0x84>
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	44 e4       	lddsp	r4,sp[0x138]
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	5c 7c       	castu.h	r12
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	c0 00       	breq	800044da <xnl_init+0x122>
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	45 44       	lddsp	r4,sp[0x150]
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	2f 38       	sub	r8,-13

800044e4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800044e4:	eb cd 40 fe 	pushm	r1-r7,lr
800044e8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044ea:	49 26       	lddpc	r6,80004530 <xnl_rx_process+0x4c>
800044ec:	30 05       	mov	r5,0
800044ee:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044f0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044f2:	49 11       	lddpc	r1,80004534 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044f4:	49 12       	lddpc	r2,80004538 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044f6:	6c 0c       	ld.w	r12,r6[0x0]
800044f8:	0a 99       	mov	r9,r5
800044fa:	08 9a       	mov	r10,r4
800044fc:	1a 9b       	mov	r11,sp
800044fe:	f0 1f 00 10 	mcall	8000453c <xnl_rx_process+0x58>
80004502:	58 1c       	cp.w	r12,1
80004504:	cf 91       	brne	800044f6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004506:	40 0c       	lddsp	r12,sp[0x0]
80004508:	58 0c       	cp.w	r12,0
8000450a:	cf 60       	breq	800044f6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000450c:	98 28       	ld.sh	r8,r12[0x4]
8000450e:	e6 08 19 00 	cp.h	r8,r3
80004512:	e0 8b 00 0a 	brhi	80004526 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004516:	5c 78       	castu.h	r8
80004518:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000451c:	58 09       	cp.w	r9,0
8000451e:	c0 40       	breq	80004526 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004520:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004524:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004526:	62 0c       	ld.w	r12,r1[0x0]
80004528:	40 0b       	lddsp	r11,sp[0x0]
8000452a:	f0 1f 00 06 	mcall	80004540 <xnl_rx_process+0x5c>
8000452e:	ce 4b       	rjmp	800044f6 <xnl_rx_process+0x12>
80004530:	00 00       	add	r0,r0
80004532:	0a a8       	st.w	r5++,r8
80004534:	00 00       	add	r0,r0
80004536:	0a 8c       	andn	r12,r5
80004538:	00 00       	add	r0,r0
8000453a:	04 f0       	st.b	--r2,r0
8000453c:	80 00       	ld.sh	r0,r0[0x0]
8000453e:	52 9c       	stdsp	sp[0xa4],r12
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	29 a4       	sub	r4,-102

80004544 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004544:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004546:	4a a6       	lddpc	r6,800045ec <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004548:	4a a2       	lddpc	r2,800045f0 <xnl_tx_process+0xac>
8000454a:	4a b4       	lddpc	r4,800045f4 <xnl_tx_process+0xb0>
8000454c:	30 07       	mov	r7,0
8000454e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004550:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004552:	4a a5       	lddpc	r5,800045f8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004554:	4a a3       	lddpc	r3,800045fc <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004556:	6c 08       	ld.w	r8,r6[0x0]
80004558:	58 08       	cp.w	r8,0
8000455a:	c0 40       	breq	80004562 <xnl_tx_process+0x1e>
8000455c:	58 18       	cp.w	r8,1
8000455e:	cf d1       	brne	80004558 <xnl_tx_process+0x14>
80004560:	c2 48       	rjmp	800045a8 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004562:	64 0c       	ld.w	r12,r2[0x0]
80004564:	0e 99       	mov	r9,r7
80004566:	02 9a       	mov	r10,r1
80004568:	08 9b       	mov	r11,r4
8000456a:	f0 1f 00 26 	mcall	80004600 <xnl_tx_process+0xbc>
8000456e:	58 1c       	cp.w	r12,1
80004570:	cf 31       	brne	80004556 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004572:	68 0b       	ld.w	r11,r4[0x0]
80004574:	58 0b       	cp.w	r11,0
80004576:	cf 00       	breq	80004556 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004578:	96 28       	ld.sh	r8,r11[0x4]
8000457a:	e0 08 19 00 	cp.h	r8,r0
8000457e:	c0 71       	brne	8000458c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004580:	4a 18       	lddpc	r8,80004604 <xnl_tx_process+0xc0>
80004582:	70 08       	ld.w	r8,r8[0x0]
80004584:	10 9c       	mov	r12,r8
80004586:	f0 1f 00 21 	mcall	80004608 <xnl_tx_process+0xc4>
						break;
8000458a:	ce 6b       	rjmp	80004556 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000458c:	16 9c       	mov	r12,r11
8000458e:	f0 1f 00 20 	mcall	8000460c <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004592:	30 18       	mov	r8,1
80004594:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004596:	66 0c       	ld.w	r12,r3[0x0]
80004598:	0e 99       	mov	r9,r7
8000459a:	0e 9a       	mov	r10,r7
8000459c:	0e 9b       	mov	r11,r7
8000459e:	f0 1f 00 19 	mcall	80004600 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800045a2:	30 18       	mov	r8,1
800045a4:	8d 08       	st.w	r6[0x0],r8
800045a6:	cd 8b       	rjmp	80004556 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800045a8:	66 0c       	ld.w	r12,r3[0x0]
800045aa:	0e 99       	mov	r9,r7
800045ac:	36 4a       	mov	r10,100
800045ae:	0e 9b       	mov	r11,r7
800045b0:	f0 1f 00 14 	mcall	80004600 <xnl_tx_process+0xbc>
800045b4:	58 1c       	cp.w	r12,1
800045b6:	c0 81       	brne	800045c6 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800045b8:	49 38       	lddpc	r8,80004604 <xnl_tx_process+0xc0>
800045ba:	70 0c       	ld.w	r12,r8[0x0]
800045bc:	68 0b       	ld.w	r11,r4[0x0]
800045be:	f0 1f 00 13 	mcall	80004608 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800045c2:	8d 07       	st.w	r6[0x0],r7
800045c4:	cc 9b       	rjmp	80004556 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800045c6:	6a 08       	ld.w	r8,r5[0x0]
800045c8:	58 38       	cp.w	r8,3
800045ca:	e0 89 00 09 	brgt	800045dc <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800045ce:	68 0c       	ld.w	r12,r4[0x0]
800045d0:	f0 1f 00 0f 	mcall	8000460c <xnl_tx_process+0xc8>
						xnl_send_times++;
800045d4:	6a 08       	ld.w	r8,r5[0x0]
800045d6:	2f f8       	sub	r8,-1
800045d8:	8b 08       	st.w	r5[0x0],r8
800045da:	cb eb       	rjmp	80004556 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800045dc:	48 a8       	lddpc	r8,80004604 <xnl_tx_process+0xc0>
800045de:	70 0c       	ld.w	r12,r8[0x0]
800045e0:	68 0b       	ld.w	r11,r4[0x0]
800045e2:	f0 1f 00 0a 	mcall	80004608 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800045e6:	8d 07       	st.w	r6[0x0],r7
800045e8:	cb 7b       	rjmp	80004556 <xnl_tx_process+0x12>
800045ea:	00 00       	add	r0,r0
800045ec:	00 00       	add	r0,r0
800045ee:	0b 48       	ld.w	r8,--r5
800045f0:	00 00       	add	r0,r0
800045f2:	0b 38       	ld.ub	r8,r5++
800045f4:	00 00       	add	r0,r0
800045f6:	0b 40       	ld.w	r0,--r5
800045f8:	00 00       	add	r0,r0
800045fa:	0b 3c       	ld.ub	r12,r5++
800045fc:	00 00       	add	r0,r0
800045fe:	0b 28       	ld.uh	r8,r5++
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	52 9c       	stdsp	sp[0xa4],r12
80004604:	00 00       	add	r0,r0
80004606:	0a 8c       	andn	r12,r5
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	29 a4       	sub	r4,-102
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	29 c4       	sub	r4,-100

80004610 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004610:	eb cd 40 c0 	pushm	r6-r7,lr
80004614:	20 1d       	sub	sp,4
80004616:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004618:	98 39       	ld.sh	r9,r12[0x6]
8000461a:	3f f8       	mov	r8,-1
8000461c:	f0 09 19 00 	cp.h	r9,r8
80004620:	c0 a1       	brne	80004634 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004622:	4a e9       	lddpc	r9,800046d8 <xnl_tx+0xc8>
80004624:	13 88       	ld.ub	r8,r9[0x0]
80004626:	2f f8       	sub	r8,-1
80004628:	5c 58       	castu.b	r8
8000462a:	b2 88       	st.b	r9[0x0],r8
8000462c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004630:	a9 a8       	sbr	r8,0x8
80004632:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004634:	8c 49       	ld.sh	r9,r6[0x8]
80004636:	3f f8       	mov	r8,-1
80004638:	f0 09 19 00 	cp.h	r9,r8
8000463c:	c0 41       	brne	80004644 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000463e:	4a 88       	lddpc	r8,800046dc <xnl_tx+0xcc>
80004640:	90 18       	ld.sh	r8,r8[0x2]
80004642:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004644:	8c 59       	ld.sh	r9,r6[0xa]
80004646:	3f f8       	mov	r8,-1
80004648:	f0 09 19 00 	cp.h	r9,r8
8000464c:	c0 41       	brne	80004654 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000464e:	4a 48       	lddpc	r8,800046dc <xnl_tx+0xcc>
80004650:	90 28       	ld.sh	r8,r8[0x4]
80004652:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004654:	8c 69       	ld.sh	r9,r6[0xc]
80004656:	3f f8       	mov	r8,-1
80004658:	f0 09 19 00 	cp.h	r9,r8
8000465c:	c0 e1       	brne	80004678 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000465e:	4a 08       	lddpc	r8,800046dc <xnl_tx+0xcc>
80004660:	90 49       	ld.sh	r9,r8[0x8]
80004662:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004664:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004666:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004668:	90 49       	ld.sh	r9,r8[0x8]
8000466a:	e0 19 ff 00 	andl	r9,0xff00
8000466e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004672:	f3 e8 10 08 	or	r8,r9,r8
80004676:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004678:	0d 98       	ld.ub	r8,r6[0x1]
8000467a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000467c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004680:	10 0c       	add	r12,r8
80004682:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004684:	58 0c       	cp.w	r12,0
80004686:	e0 89 00 04 	brgt	8000468e <xnl_tx+0x7e>
8000468a:	30 09       	mov	r9,0
8000468c:	c0 d8       	rjmp	800046a6 <xnl_tx+0x96>
8000468e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004692:	2f ec       	sub	r12,-2
80004694:	30 09       	mov	r9,0
80004696:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004698:	15 1b       	ld.sh	r11,r10++
8000469a:	f6 09 00 09 	add	r9,r11,r9
8000469e:	5c 89       	casts.h	r9
		indextohWord     += 1;
800046a0:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800046a2:	18 38       	cp.w	r8,r12
800046a4:	cf a1       	brne	80004698 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800046a6:	5c 39       	neg	r9
800046a8:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046aa:	48 e8       	lddpc	r8,800046e0 <xnl_tx+0xd0>
800046ac:	70 0c       	ld.w	r12,r8[0x0]
800046ae:	f0 1f 00 0e 	mcall	800046e4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800046b2:	c1 00       	breq	800046d2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800046b4:	fa c7 ff fc 	sub	r7,sp,-4
800046b8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800046ba:	e0 6a 01 00 	mov	r10,256
800046be:	0c 9b       	mov	r11,r6
800046c0:	f0 1f 00 0a 	mcall	800046e8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800046c4:	48 a8       	lddpc	r8,800046ec <xnl_tx+0xdc>
800046c6:	70 0c       	ld.w	r12,r8[0x0]
800046c8:	30 09       	mov	r9,0
800046ca:	12 9a       	mov	r10,r9
800046cc:	1a 9b       	mov	r11,sp
800046ce:	f0 1f 00 09 	mcall	800046f0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800046d2:	2f fd       	sub	sp,-4
800046d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046d8:	00 00       	add	r0,r0
800046da:	0b 44       	ld.w	r4,--r5
800046dc:	00 00       	add	r0,r0
800046de:	0b 2c       	ld.uh	r12,r5++
800046e0:	00 00       	add	r0,r0
800046e2:	0a 8c       	andn	r12,r5
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	2f 10       	sub	r0,-15
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	68 cc       	ld.w	r12,r4[0x30]
800046ec:	00 00       	add	r0,r0
800046ee:	0b 38       	ld.ub	r8,r5++
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	54 a8       	stdsp	sp[0x128],r8

800046f4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800046f4:	eb cd 40 80 	pushm	r7,lr
800046f8:	fa cd 01 00 	sub	sp,sp,256
800046fc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046fe:	e0 68 40 0e 	mov	r8,16398
80004702:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004704:	3f f8       	mov	r8,-1
80004706:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004708:	30 c8       	mov	r8,12
8000470a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000470c:	98 38       	ld.sh	r8,r12[0x6]
8000470e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004710:	98 58       	ld.sh	r8,r12[0xa]
80004712:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004714:	98 48       	ld.sh	r8,r12[0x8]
80004716:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004718:	98 68       	ld.sh	r8,r12[0xc]
8000471a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000471c:	30 08       	mov	r8,0
8000471e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004720:	1a 9c       	mov	r12,sp
80004722:	f0 1f 00 0a 	mcall	80004748 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004726:	fa cd 00 cc 	sub	sp,sp,204
8000472a:	e0 6a 00 ca 	mov	r10,202
8000472e:	ee cb ff f0 	sub	r11,r7,-16
80004732:	1a 9c       	mov	r12,sp
80004734:	f0 1f 00 06 	mcall	8000474c <xnl_data_msg_func+0x58>
80004738:	48 68       	lddpc	r8,80004750 <xnl_data_msg_func+0x5c>
8000473a:	70 08       	ld.w	r8,r8[0x0]
8000473c:	5d 18       	icall	r8
8000473e:	fa cd ff 34 	sub	sp,sp,-204
}
80004742:	2c 0d       	sub	sp,-256
80004744:	e3 cd 80 80 	ldm	sp++,r7,pc
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	46 10       	lddsp	r0,sp[0x184]
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	68 cc       	ld.w	r12,r4[0x30]
80004750:	00 00       	add	r0,r0
80004752:	0b 4c       	ld.w	r12,--r5

80004754 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004754:	d4 21       	pushm	r4-r7,lr
80004756:	fa cd 01 00 	sub	sp,sp,256
8000475a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000475c:	4c 28       	lddpc	r8,80004864 <xnl_device_auth_reply_func+0x110>
8000475e:	11 88       	ld.ub	r8,r8[0x0]
80004760:	58 08       	cp.w	r8,0
80004762:	c7 e1       	brne	8000485e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004764:	4c 18       	lddpc	r8,80004868 <xnl_device_auth_reply_func+0x114>
80004766:	70 0c       	ld.w	r12,r8[0x0]
80004768:	30 09       	mov	r9,0
8000476a:	12 9a       	mov	r10,r9
8000476c:	12 9b       	mov	r11,r9
8000476e:	f0 1f 00 40 	mcall	8000486c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004772:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004776:	4b c8       	lddpc	r8,80004864 <xnl_device_auth_reply_func+0x110>
80004778:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000477a:	ef 39 00 12 	ld.ub	r9,r7[18]
8000477e:	ef 38 00 13 	ld.ub	r8,r7[19]
80004782:	b1 68       	lsl	r8,0x10
80004784:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004788:	ef 38 00 15 	ld.ub	r8,r7[21]
8000478c:	f3 e8 10 08 	or	r8,r9,r8
80004790:	ef 39 00 14 	ld.ub	r9,r7[20]
80004794:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004798:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000479c:	ef 38 00 17 	ld.ub	r8,r7[23]
800047a0:	b1 68       	lsl	r8,0x10
800047a2:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800047a6:	ef 38 00 19 	ld.ub	r8,r7[25]
800047aa:	f5 e8 10 08 	or	r8,r10,r8
800047ae:	ef 3a 00 18 	ld.ub	r10,r7[24]
800047b2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800047b6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047b8:	e0 64 79 b9 	mov	r4,31161
800047bc:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800047c0:	e0 65 45 07 	mov	r5,17671
800047c4:	ea 15 8a bd 	orh	r5,0x8abd
800047c8:	e0 66 f9 3d 	mov	r6,63805
800047cc:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800047d0:	e0 6e b8 cf 	mov	lr,47311
800047d4:	ea 1e 36 83 	orh	lr,0x3683
800047d8:	e0 67 aa 1c 	mov	r7,43548
800047dc:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800047e0:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800047e2:	f4 08 00 0c 	add	r12,r10,r8
800047e6:	f0 0b 15 04 	lsl	r11,r8,0x4
800047ea:	0a 0b       	add	r11,r5
800047ec:	f9 eb 20 0b 	eor	r11,r12,r11
800047f0:	f0 0c 16 05 	lsr	r12,r8,0x5
800047f4:	0c 0c       	add	r12,r6
800047f6:	18 5b       	eor	r11,r12
800047f8:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800047fa:	f2 0c 15 04 	lsl	r12,r9,0x4
800047fe:	1c 0c       	add	r12,lr
80004800:	f2 0b 16 05 	lsr	r11,r9,0x5
80004804:	0e 0b       	add	r11,r7
80004806:	f9 eb 20 0b 	eor	r11,r12,r11
8000480a:	f2 0a 00 0c 	add	r12,r9,r10
8000480e:	18 5b       	eor	r11,r12
80004810:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004812:	e0 6b 37 20 	mov	r11,14112
80004816:	ea 1b c6 ef 	orh	r11,0xc6ef
8000481a:	16 3a       	cp.w	r10,r11
8000481c:	ce 21       	brne	800047e0 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000481e:	e0 6a 40 1a 	mov	r10,16410
80004822:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004824:	3f fa       	mov	r10,-1
80004826:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004828:	30 6b       	mov	r11,6
8000482a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000482c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000482e:	48 eb       	lddpc	r11,80004864 <xnl_device_auth_reply_func+0x110>
80004830:	96 1c       	ld.sh	r12,r11[0x2]
80004832:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004834:	96 2b       	ld.sh	r11,r11[0x4]
80004836:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004838:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000483a:	30 ca       	mov	r10,12
8000483c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000483e:	30 0a       	mov	r10,0
80004840:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004844:	30 7a       	mov	r10,7
80004846:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000484a:	30 2a       	mov	r10,2
8000484c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004850:	fa ca ff ec 	sub	r10,sp,-20
80004854:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004856:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004858:	1a 9c       	mov	r12,sp
8000485a:	f0 1f 00 06 	mcall	80004870 <xnl_device_auth_reply_func+0x11c>
}
8000485e:	2c 0d       	sub	sp,-256
80004860:	d8 22       	popm	r4-r7,pc
80004862:	00 00       	add	r0,r0
80004864:	00 00       	add	r0,r0
80004866:	0b 2c       	ld.uh	r12,r5++
80004868:	00 00       	add	r0,r0
8000486a:	0b 28       	ld.uh	r8,r5++
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	54 a8       	stdsp	sp[0x128],r8
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	46 10       	lddsp	r0,sp[0x184]

80004874 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004874:	eb cd 40 80 	pushm	r7,lr
80004878:	fa cd 01 00 	sub	sp,sp,256
8000487c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000487e:	49 28       	lddpc	r8,800048c4 <xnl_master_status_brdcst_func+0x50>
80004880:	11 88       	ld.ub	r8,r8[0x0]
80004882:	58 08       	cp.w	r8,0
80004884:	c1 c1       	brne	800048bc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004886:	49 18       	lddpc	r8,800048c8 <xnl_master_status_brdcst_func+0x54>
80004888:	70 0c       	ld.w	r12,r8[0x0]
8000488a:	30 09       	mov	r9,0
8000488c:	12 9a       	mov	r10,r9
8000488e:	12 9b       	mov	r11,r9
80004890:	f0 1f 00 0f 	mcall	800048cc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004894:	8e 58       	ld.sh	r8,r7[0xa]
80004896:	48 c9       	lddpc	r9,800048c4 <xnl_master_status_brdcst_func+0x50>
80004898:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000489a:	e0 68 40 0e 	mov	r8,16398
8000489e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048a0:	3f f8       	mov	r8,-1
800048a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800048a4:	30 4a       	mov	r10,4
800048a6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048a8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048aa:	92 19       	ld.sh	r9,r9[0x2]
800048ac:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800048ae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048b0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800048b2:	30 08       	mov	r8,0
800048b4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800048b6:	1a 9c       	mov	r12,sp
800048b8:	f0 1f 00 06 	mcall	800048d0 <xnl_master_status_brdcst_func+0x5c>
}
800048bc:	2c 0d       	sub	sp,-256
800048be:	e3 cd 80 80 	ldm	sp++,r7,pc
800048c2:	00 00       	add	r0,r0
800048c4:	00 00       	add	r0,r0
800048c6:	0b 2c       	ld.uh	r12,r5++
800048c8:	00 00       	add	r0,r0
800048ca:	0b 28       	ld.uh	r8,r5++
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	54 a8       	stdsp	sp[0x128],r8
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	46 10       	lddsp	r0,sp[0x184]

800048d4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800048d4:	eb cd 40 80 	pushm	r7,lr
800048d8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800048da:	49 28       	lddpc	r8,80004920 <xnl_device_conn_reply_func+0x4c>
800048dc:	70 0c       	ld.w	r12,r8[0x0]
800048de:	30 09       	mov	r9,0
800048e0:	12 9a       	mov	r10,r9
800048e2:	12 9b       	mov	r11,r9
800048e4:	f0 1f 00 10 	mcall	80004924 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800048e8:	ef 18 00 10 	ld.uh	r8,r7[16]
800048ec:	10 99       	mov	r9,r8
800048ee:	e2 19 ff 00 	andl	r9,0xff00,COH
800048f2:	e0 49 01 00 	cp.w	r9,256
800048f6:	c0 60       	breq	80004902 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800048f8:	0e 9c       	mov	r12,r7
800048fa:	f0 1f 00 0c 	mcall	80004928 <xnl_device_conn_reply_func+0x54>
800048fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004902:	a9 68       	lsl	r8,0x8
80004904:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004908:	48 98       	lddpc	r8,8000492c <xnl_device_conn_reply_func+0x58>
8000490a:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000490c:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004910:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004912:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004916:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004918:	30 19       	mov	r9,1
8000491a:	b0 89       	st.b	r8[0x0],r9
8000491c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004920:	00 00       	add	r0,r0
80004922:	0b 28       	ld.uh	r8,r5++
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	54 a8       	stdsp	sp[0x128],r8
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	48 74       	lddpc	r4,80004944 <xnl_send_device_master_query+0x14>
8000492c:	00 00       	add	r0,r0
8000492e:	0b 2c       	ld.uh	r12,r5++

80004930 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004930:	d4 01       	pushm	lr
80004932:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004936:	e0 68 40 0e 	mov	r8,16398
8000493a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000493c:	3f f8       	mov	r8,-1
8000493e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004940:	30 38       	mov	r8,3
80004942:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004944:	30 08       	mov	r8,0
80004946:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004948:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000494a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000494c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000494e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004950:	1a 9c       	mov	r12,sp
80004952:	f0 1f 00 03 	mcall	8000495c <xnl_send_device_master_query+0x2c>
}
80004956:	2c 0d       	sub	sp,-256
80004958:	d8 02       	popm	pc
8000495a:	00 00       	add	r0,r0
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	46 10       	lddsp	r0,sp[0x184]

80004960 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004960:	fe 78 0c 00 	mov	r8,-62464
80004964:	e0 69 03 07 	mov	r9,775
80004968:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
8000496a:	30 49       	mov	r9,4
8000496c:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000496e:	71 59       	ld.w	r9,r8[0x54]
80004970:	e2 19 00 80 	andl	r9,0x80,COH
80004974:	cf d0       	breq	8000496e <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004976:	fe 78 0c 00 	mov	r8,-62464
8000497a:	30 59       	mov	r9,5
8000497c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000497e:	e0 69 01 0d 	mov	r9,269
80004982:	ea 19 10 07 	orh	r9,0x1007
80004986:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004988:	71 59       	ld.w	r9,r8[0x54]
8000498a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000498e:	cf d0       	breq	80004988 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004990:	fe 78 0c 00 	mov	r8,-62464
80004994:	fc 19 00 80 	movh	r9,0x80
80004998:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
8000499a:	34 0a       	mov	r10,64
8000499c:	fe 69 14 00 	mov	r9,-125952
800049a0:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800049a2:	30 69       	mov	r9,6
800049a4:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800049a6:	30 19       	mov	r9,1
800049a8:	fe 68 10 00 	mov	r8,-126976
800049ac:	91 19       	st.w	r8[0x4],r9
}
800049ae:	5e fc       	retal	r12

800049b0 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800049b0:	fe 78 10 00 	mov	r8,-61440
800049b4:	fc 19 00 10 	movh	r9,0x10
800049b8:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800049ba:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800049bc:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800049be:	30 39       	mov	r9,3
800049c0:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800049c4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800049c8:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800049cc:	fe 78 38 00 	mov	r8,-51200
800049d0:	30 49       	mov	r9,4
800049d2:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800049d6:	e0 69 91 0d 	mov	r9,37133
800049da:	ea 19 00 52 	orh	r9,0x52
800049de:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800049e0:	32 09       	mov	r9,32
800049e2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800049e4:	30 59       	mov	r9,5
800049e6:	91 09       	st.w	r8[0x0],r9
}
800049e8:	5e fc       	retal	r12

800049ea <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800049ea:	f8 08 16 05 	lsr	r8,r12,0x5
800049ee:	a9 68       	lsl	r8,0x8
800049f0:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800049f4:	58 1b       	cp.w	r11,1
800049f6:	c0 d0       	breq	80004a10 <gpio_enable_module_pin+0x26>
800049f8:	c0 63       	brcs	80004a04 <gpio_enable_module_pin+0x1a>
800049fa:	58 2b       	cp.w	r11,2
800049fc:	c1 00       	breq	80004a1c <gpio_enable_module_pin+0x32>
800049fe:	58 3b       	cp.w	r11,3
80004a00:	c1 40       	breq	80004a28 <gpio_enable_module_pin+0x3e>
80004a02:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004a04:	30 19       	mov	r9,1
80004a06:	f2 0c 09 49 	lsl	r9,r9,r12
80004a0a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004a0c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a0e:	c1 28       	rjmp	80004a32 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004a10:	30 19       	mov	r9,1
80004a12:	f2 0c 09 49 	lsl	r9,r9,r12
80004a16:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004a18:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a1a:	c0 c8       	rjmp	80004a32 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004a1c:	30 19       	mov	r9,1
80004a1e:	f2 0c 09 49 	lsl	r9,r9,r12
80004a22:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004a24:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004a26:	c0 68       	rjmp	80004a32 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004a28:	30 19       	mov	r9,1
80004a2a:	f2 0c 09 49 	lsl	r9,r9,r12
80004a2e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004a30:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004a32:	30 19       	mov	r9,1
80004a34:	f2 0c 09 4c 	lsl	r12,r9,r12
80004a38:	91 2c       	st.w	r8[0x8],r12
80004a3a:	5e fd       	retal	0

80004a3c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004a3c:	d4 21       	pushm	r4-r7,lr
80004a3e:	18 97       	mov	r7,r12
80004a40:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004a42:	58 0b       	cp.w	r11,0
80004a44:	c0 31       	brne	80004a4a <gpio_enable_module+0xe>
80004a46:	30 05       	mov	r5,0
80004a48:	c0 d8       	rjmp	80004a62 <gpio_enable_module+0x26>
80004a4a:	30 06       	mov	r6,0
80004a4c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004a4e:	6e 1b       	ld.w	r11,r7[0x4]
80004a50:	6e 0c       	ld.w	r12,r7[0x0]
80004a52:	f0 1f 00 06 	mcall	80004a68 <gpio_enable_module+0x2c>
80004a56:	18 45       	or	r5,r12
		gpiomap++;
80004a58:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004a5a:	2f f6       	sub	r6,-1
80004a5c:	0c 34       	cp.w	r4,r6
80004a5e:	fe 9b ff f8 	brhi	80004a4e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004a62:	0a 9c       	mov	r12,r5
80004a64:	d8 22       	popm	r4-r7,pc
80004a66:	00 00       	add	r0,r0
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	49 ea       	lddpc	r10,80004ae0 <INTC_register_interrupt+0x70>

80004a6c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004a6c:	c0 08       	rjmp	80004a6c <_unhandled_interrupt>
80004a6e:	d7 03       	nop

80004a70 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004a70:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004a74:	49 99       	lddpc	r9,80004ad8 <INTC_register_interrupt+0x68>
80004a76:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004a7a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004a7e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004a80:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004a84:	58 0a       	cp.w	r10,0
80004a86:	c0 91       	brne	80004a98 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004a88:	49 59       	lddpc	r9,80004adc <INTC_register_interrupt+0x6c>
80004a8a:	49 6a       	lddpc	r10,80004ae0 <INTC_register_interrupt+0x70>
80004a8c:	12 1a       	sub	r10,r9
80004a8e:	fe 79 08 00 	mov	r9,-63488
80004a92:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004a96:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004a98:	58 1a       	cp.w	r10,1
80004a9a:	c0 a1       	brne	80004aae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004a9c:	49 09       	lddpc	r9,80004adc <INTC_register_interrupt+0x6c>
80004a9e:	49 2a       	lddpc	r10,80004ae4 <INTC_register_interrupt+0x74>
80004aa0:	12 1a       	sub	r10,r9
80004aa2:	bf aa       	sbr	r10,0x1e
80004aa4:	fe 79 08 00 	mov	r9,-63488
80004aa8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004aac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004aae:	58 2a       	cp.w	r10,2
80004ab0:	c0 a1       	brne	80004ac4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004ab2:	48 b9       	lddpc	r9,80004adc <INTC_register_interrupt+0x6c>
80004ab4:	48 da       	lddpc	r10,80004ae8 <INTC_register_interrupt+0x78>
80004ab6:	12 1a       	sub	r10,r9
80004ab8:	bf ba       	sbr	r10,0x1f
80004aba:	fe 79 08 00 	mov	r9,-63488
80004abe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ac2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004ac4:	48 69       	lddpc	r9,80004adc <INTC_register_interrupt+0x6c>
80004ac6:	48 aa       	lddpc	r10,80004aec <INTC_register_interrupt+0x7c>
80004ac8:	12 1a       	sub	r10,r9
80004aca:	ea 1a c0 00 	orh	r10,0xc000
80004ace:	fe 79 08 00 	mov	r9,-63488
80004ad2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ad6:	5e fc       	retal	r12
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	c7 d8       	rjmp	80004bd4 <usart_set_async_baudrate+0x58>
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	be 00       	st.h	pc[0x0],r0
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	bf 04       	ld.d	r4,pc
80004ae4:	80 00       	ld.sh	r0,r0[0x0]
80004ae6:	bf 12       	ld.d	r2,--pc
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	bf 20       	st.d	pc++,r0
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	bf 2e       	st.d	pc++,lr

80004af0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004af0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004af2:	49 18       	lddpc	r8,80004b34 <INTC_init_interrupts+0x44>
80004af4:	e3 b8 00 01 	mtsr	0x4,r8
80004af8:	49 0e       	lddpc	lr,80004b38 <INTC_init_interrupts+0x48>
80004afa:	30 07       	mov	r7,0
80004afc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004afe:	49 0c       	lddpc	r12,80004b3c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b00:	49 05       	lddpc	r5,80004b40 <INTC_init_interrupts+0x50>
80004b02:	10 15       	sub	r5,r8
80004b04:	fe 76 08 00 	mov	r6,-63488
80004b08:	c1 08       	rjmp	80004b28 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004b0a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004b0c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b0e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004b10:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004b14:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b16:	10 3a       	cp.w	r10,r8
80004b18:	fe 9b ff fc 	brhi	80004b10 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b1c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004b20:	2f f7       	sub	r7,-1
80004b22:	2f 8e       	sub	lr,-8
80004b24:	59 37       	cp.w	r7,19
80004b26:	c0 50       	breq	80004b30 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004b28:	7c 08       	ld.w	r8,lr[0x0]
80004b2a:	58 08       	cp.w	r8,0
80004b2c:	ce f1       	brne	80004b0a <INTC_init_interrupts+0x1a>
80004b2e:	cf 7b       	rjmp	80004b1c <INTC_init_interrupts+0x2c>
80004b30:	d8 22       	popm	r4-r7,pc
80004b32:	00 00       	add	r0,r0
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	be 00       	st.h	pc[0x0],r0
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	c7 d8       	rjmp	80004c34 <usart_read_char+0x1c>
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	4a 6c       	lddpc	r12,80004bd4 <usart_set_async_baudrate+0x58>
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	bf 04       	ld.d	r4,pc

80004b44 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004b44:	fe 78 08 00 	mov	r8,-63488
80004b48:	e0 69 00 83 	mov	r9,131
80004b4c:	f2 0c 01 0c 	sub	r12,r9,r12
80004b50:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004b54:	f2 ca ff c0 	sub	r10,r9,-64
80004b58:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004b5c:	58 08       	cp.w	r8,0
80004b5e:	c0 21       	brne	80004b62 <_get_interrupt_handler+0x1e>
80004b60:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004b62:	f0 08 12 00 	clz	r8,r8
80004b66:	48 5a       	lddpc	r10,80004b78 <_get_interrupt_handler+0x34>
80004b68:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004b6c:	f0 08 11 1f 	rsub	r8,r8,31
80004b70:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004b72:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004b76:	5e fc       	retal	r12
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	c7 d8       	rjmp	80004c74 <usart_write_line+0xc>

80004b7c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004b7c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004b7e:	f6 08 15 04 	lsl	r8,r11,0x4
80004b82:	14 38       	cp.w	r8,r10
80004b84:	f9 b8 08 10 	movls	r8,16
80004b88:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004b8c:	f0 0b 02 4b 	mul	r11,r8,r11
80004b90:	f6 09 16 01 	lsr	r9,r11,0x1
80004b94:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004b98:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004b9c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004ba0:	f2 cb 00 01 	sub	r11,r9,1
80004ba4:	e0 4b ff fe 	cp.w	r11,65534
80004ba8:	e0 88 00 03 	brls	80004bae <usart_set_async_baudrate+0x32>
80004bac:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004bae:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004bb0:	e8 6e 00 00 	mov	lr,524288
80004bb4:	59 08       	cp.w	r8,16
80004bb6:	fc 08 17 10 	movne	r8,lr
80004bba:	f9 b8 00 00 	moveq	r8,0
80004bbe:	e4 1b ff f7 	andh	r11,0xfff7
80004bc2:	e0 1b fe cf 	andl	r11,0xfecf
80004bc6:	16 48       	or	r8,r11
80004bc8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004bca:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004bce:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004bd2:	99 89       	st.w	r12[0x20],r9
80004bd4:	d8 0a       	popm	pc,r12=0

80004bd6 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004bd6:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004bd8:	e2 18 00 02 	andl	r8,0x2,COH
80004bdc:	c0 31       	brne	80004be2 <usart_write_char+0xc>
80004bde:	30 2c       	mov	r12,2
80004be0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004be2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004be6:	99 7b       	st.w	r12[0x1c],r11
80004be8:	5e fd       	retal	0
80004bea:	d7 03       	nop

80004bec <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004bec:	eb cd 40 e0 	pushm	r5-r7,lr
80004bf0:	18 96       	mov	r6,r12
80004bf2:	16 95       	mov	r5,r11
80004bf4:	e0 67 27 0f 	mov	r7,9999
80004bf8:	c0 68       	rjmp	80004c04 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004bfa:	58 07       	cp.w	r7,0
80004bfc:	c0 31       	brne	80004c02 <usart_putchar+0x16>
80004bfe:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004c02:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004c04:	0a 9b       	mov	r11,r5
80004c06:	0c 9c       	mov	r12,r6
80004c08:	f0 1f 00 03 	mcall	80004c14 <usart_putchar+0x28>
80004c0c:	cf 71       	brne	80004bfa <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004c0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c12:	00 00       	add	r0,r0
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	4b d6       	lddpc	r6,80004d08 <usart_init_rs232+0x50>

80004c18 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004c18:	78 58       	ld.w	r8,r12[0x14]
80004c1a:	e2 18 00 e0 	andl	r8,0xe0,COH
80004c1e:	c0 30       	breq	80004c24 <usart_read_char+0xc>
80004c20:	30 4c       	mov	r12,4
80004c22:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004c24:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004c26:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c2a:	c0 31       	brne	80004c30 <usart_read_char+0x18>
80004c2c:	30 3c       	mov	r12,3
80004c2e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004c30:	78 68       	ld.w	r8,r12[0x18]
80004c32:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004c36:	97 08       	st.w	r11[0x0],r8
80004c38:	5e fd       	retal	0
80004c3a:	d7 03       	nop

80004c3c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004c3c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c40:	20 1d       	sub	sp,4
80004c42:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004c44:	1a 97       	mov	r7,sp
80004c46:	1a 9b       	mov	r11,sp
80004c48:	0c 9c       	mov	r12,r6
80004c4a:	f0 1f 00 07 	mcall	80004c64 <usart_getchar+0x28>
80004c4e:	58 3c       	cp.w	r12,3
80004c50:	cf b0       	breq	80004c46 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004c52:	58 4c       	cp.w	r12,4
80004c54:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004c58:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004c5c:	2f fd       	sub	sp,-4
80004c5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c62:	00 00       	add	r0,r0
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	4c 18       	lddpc	r8,80004d68 <usart_init_rs232+0xb0>

80004c68 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004c68:	eb cd 40 c0 	pushm	r6-r7,lr
80004c6c:	18 96       	mov	r6,r12
80004c6e:	16 97       	mov	r7,r11
  while (*string != '\0')
80004c70:	17 8b       	ld.ub	r11,r11[0x0]
80004c72:	58 0b       	cp.w	r11,0
80004c74:	c0 80       	breq	80004c84 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004c76:	2f f7       	sub	r7,-1
80004c78:	0c 9c       	mov	r12,r6
80004c7a:	f0 1f 00 04 	mcall	80004c88 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004c7e:	0f 8b       	ld.ub	r11,r7[0x0]
80004c80:	58 0b       	cp.w	r11,0
80004c82:	cf a1       	brne	80004c76 <usart_write_line+0xe>
80004c84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	4b ec       	lddpc	r12,80004d80 <usart_init_rs232+0xc8>

80004c8c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004c8c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004c90:	e6 18 00 01 	andh	r8,0x1,COH
80004c94:	c0 71       	brne	80004ca2 <usart_reset+0x16>
80004c96:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004c98:	3f f8       	mov	r8,-1
80004c9a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004c9c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004c9e:	d5 03       	csrf	0x10
80004ca0:	c0 48       	rjmp	80004ca8 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004ca2:	3f f8       	mov	r8,-1
80004ca4:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ca6:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004ca8:	30 08       	mov	r8,0
80004caa:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004cac:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004cae:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004cb0:	ea 68 61 0c 	mov	r8,680204
80004cb4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004cb6:	5e fc       	retal	r12

80004cb8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004cb8:	eb cd 40 e0 	pushm	r5-r7,lr
80004cbc:	18 96       	mov	r6,r12
80004cbe:	16 97       	mov	r7,r11
80004cc0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004cc2:	f0 1f 00 2f 	mcall	80004d7c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004cc6:	58 07       	cp.w	r7,0
80004cc8:	c5 80       	breq	80004d78 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004cca:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ccc:	30 49       	mov	r9,4
80004cce:	f2 08 18 00 	cp.b	r8,r9
80004cd2:	e0 88 00 53 	brls	80004d78 <usart_init_rs232+0xc0>
80004cd6:	30 99       	mov	r9,9
80004cd8:	f2 08 18 00 	cp.b	r8,r9
80004cdc:	e0 8b 00 4e 	brhi	80004d78 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004ce0:	0f d9       	ld.ub	r9,r7[0x5]
80004ce2:	30 78       	mov	r8,7
80004ce4:	f0 09 18 00 	cp.b	r9,r8
80004ce8:	e0 8b 00 48 	brhi	80004d78 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004cec:	8e 39       	ld.sh	r9,r7[0x6]
80004cee:	e0 68 01 01 	mov	r8,257
80004cf2:	f0 09 19 00 	cp.h	r9,r8
80004cf6:	e0 8b 00 41 	brhi	80004d78 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004cfa:	ef 39 00 08 	ld.ub	r9,r7[8]
80004cfe:	30 38       	mov	r8,3
80004d00:	f0 09 18 00 	cp.b	r9,r8
80004d04:	e0 8b 00 3a 	brhi	80004d78 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004d08:	0a 9a       	mov	r10,r5
80004d0a:	6e 0b       	ld.w	r11,r7[0x0]
80004d0c:	0c 9c       	mov	r12,r6
80004d0e:	f0 1f 00 1d 	mcall	80004d80 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004d12:	58 1c       	cp.w	r12,1
80004d14:	c3 20       	breq	80004d78 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004d16:	0f c8       	ld.ub	r8,r7[0x4]
80004d18:	30 99       	mov	r9,9
80004d1a:	f2 08 18 00 	cp.b	r8,r9
80004d1e:	c0 51       	brne	80004d28 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004d20:	6c 18       	ld.w	r8,r6[0x4]
80004d22:	b1 b8       	sbr	r8,0x11
80004d24:	8d 18       	st.w	r6[0x4],r8
80004d26:	c0 68       	rjmp	80004d32 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004d28:	6c 19       	ld.w	r9,r6[0x4]
80004d2a:	20 58       	sub	r8,5
80004d2c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004d30:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004d32:	6c 19       	ld.w	r9,r6[0x4]
80004d34:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004d38:	0f d8       	ld.ub	r8,r7[0x5]
80004d3a:	a9 78       	lsl	r8,0x9
80004d3c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004d40:	12 48       	or	r8,r9
80004d42:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004d44:	8e 38       	ld.sh	r8,r7[0x6]
80004d46:	30 29       	mov	r9,2
80004d48:	f2 08 19 00 	cp.h	r8,r9
80004d4c:	e0 88 00 09 	brls	80004d5e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004d50:	6c 18       	ld.w	r8,r6[0x4]
80004d52:	ad b8       	sbr	r8,0xd
80004d54:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004d56:	8e b8       	ld.uh	r8,r7[0x6]
80004d58:	20 28       	sub	r8,2
80004d5a:	8d a8       	st.w	r6[0x28],r8
80004d5c:	c0 68       	rjmp	80004d68 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004d5e:	6c 19       	ld.w	r9,r6[0x4]
80004d60:	5c 78       	castu.h	r8
80004d62:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004d66:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004d68:	6c 18       	ld.w	r8,r6[0x4]
80004d6a:	e0 18 ff f0 	andl	r8,0xfff0
80004d6e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004d70:	35 08       	mov	r8,80
80004d72:	8d 08       	st.w	r6[0x0],r8
80004d74:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004d78:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	4c 8c       	lddpc	r12,80004e9c <pxPortInitialiseStack+0x48>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4b 7c       	lddpc	r12,80004e5c <pxPortInitialiseStack+0x8>

80004d84 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004d84:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004d88:	fe c0 8f 88 	sub	r0,pc,-28792

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004d8c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004d90:	d5 53       	csrf	0x15
  cp      r0, r1
80004d92:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004d94:	e0 61 0a 30 	mov	r1,2608
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004d98:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004d9a:	c0 62       	brcc	80004da6 <idata_load_loop_end>
  cp      r0, r1
80004d9c:	48 92       	lddpc	r2,80004dc0 <udata_clear_loop_end+0x4>

80004d9e <idata_load_loop>:
  brlo    idata_load_loop
80004d9e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004da0:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004da2:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004da4:	cf d3       	brcs	80004d9e <idata_load_loop>

80004da6 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004da6:	e0 60 0a 30 	mov	r0,2608
  mov     r2, 0
  mov     r3, 0
80004daa:	e0 61 40 f8 	mov	r1,16632
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004dae:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004db0:	c0 62       	brcc	80004dbc <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004db2:	30 02       	mov	r2,0
80004db4:	30 03       	mov	r3,0

80004db6 <udata_clear_loop>:
80004db6:	a1 22       	st.d	r0++,r2
80004db8:	02 30       	cp.w	r0,r1
80004dba:	cf e3       	brcs	80004db6 <udata_clear_loop>

80004dbc <udata_clear_loop_end>:
80004dbc:	fe cf e9 c4 	sub	pc,pc,-5692
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	d1 08       	*unknown*

80004dc4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004dc4:	f8 c8 ff f8 	sub	r8,r12,-8
80004dc8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004dca:	3f f9       	mov	r9,-1
80004dcc:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004dce:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004dd0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004dd2:	30 08       	mov	r8,0
80004dd4:	99 08       	st.w	r12[0x0],r8
}
80004dd6:	5e fc       	retal	r12

80004dd8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004dd8:	30 08       	mov	r8,0
80004dda:	99 48       	st.w	r12[0x10],r8
}
80004ddc:	5e fc       	retal	r12

80004dde <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004dde:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004de0:	70 19       	ld.w	r9,r8[0x4]
80004de2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004de4:	78 19       	ld.w	r9,r12[0x4]
80004de6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004de8:	70 19       	ld.w	r9,r8[0x4]
80004dea:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004dec:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004dee:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004df0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004df2:	78 08       	ld.w	r8,r12[0x0]
80004df4:	2f f8       	sub	r8,-1
80004df6:	99 08       	st.w	r12[0x0],r8
}
80004df8:	5e fc       	retal	r12

80004dfa <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004dfa:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004dfc:	5b fa       	cp.w	r10,-1
80004dfe:	c0 31       	brne	80004e04 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004e00:	78 48       	ld.w	r8,r12[0x10]
80004e02:	c0 c8       	rjmp	80004e1a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004e04:	f8 c8 ff f8 	sub	r8,r12,-8
80004e08:	70 19       	ld.w	r9,r8[0x4]
80004e0a:	72 09       	ld.w	r9,r9[0x0]
80004e0c:	12 3a       	cp.w	r10,r9
80004e0e:	c0 63       	brcs	80004e1a <vListInsert+0x20>
80004e10:	70 18       	ld.w	r8,r8[0x4]
80004e12:	70 19       	ld.w	r9,r8[0x4]
80004e14:	72 09       	ld.w	r9,r9[0x0]
80004e16:	12 3a       	cp.w	r10,r9
80004e18:	cf c2       	brcc	80004e10 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004e1a:	70 19       	ld.w	r9,r8[0x4]
80004e1c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004e1e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004e20:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004e22:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004e24:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004e26:	78 08       	ld.w	r8,r12[0x0]
80004e28:	2f f8       	sub	r8,-1
80004e2a:	99 08       	st.w	r12[0x0],r8
}
80004e2c:	5e fc       	retal	r12

80004e2e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004e2e:	78 18       	ld.w	r8,r12[0x4]
80004e30:	78 29       	ld.w	r9,r12[0x8]
80004e32:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004e34:	78 28       	ld.w	r8,r12[0x8]
80004e36:	78 19       	ld.w	r9,r12[0x4]
80004e38:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004e3a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004e3c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004e3e:	18 39       	cp.w	r9,r12
80004e40:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004e44:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004e48:	30 09       	mov	r9,0
80004e4a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004e4c:	70 09       	ld.w	r9,r8[0x0]
80004e4e:	20 19       	sub	r9,1
80004e50:	91 09       	st.w	r8[0x0],r9
}
80004e52:	5e fc       	retal	r12

80004e54 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004e54:	e0 68 08 08 	mov	r8,2056
80004e58:	ea 18 08 08 	orh	r8,0x808
80004e5c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004e5e:	e0 68 09 09 	mov	r8,2313
80004e62:	ea 18 09 09 	orh	r8,0x909
80004e66:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004e68:	e0 68 0a 0a 	mov	r8,2570
80004e6c:	ea 18 0a 0a 	orh	r8,0xa0a
80004e70:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004e72:	e0 68 0b 0b 	mov	r8,2827
80004e76:	ea 18 0b 0b 	orh	r8,0xb0b
80004e7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004e7c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004e7e:	e0 68 be ef 	mov	r8,48879
80004e82:	ea 18 de ad 	orh	r8,0xdead
80004e86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004e88:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004e8a:	fc 18 00 40 	movh	r8,0x40
80004e8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004e90:	e0 68 00 ff 	mov	r8,255
80004e94:	ea 18 ff 00 	orh	r8,0xff00
80004e98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004e9a:	e0 68 01 01 	mov	r8,257
80004e9e:	ea 18 01 01 	orh	r8,0x101
80004ea2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004ea4:	e0 68 02 02 	mov	r8,514
80004ea8:	ea 18 02 02 	orh	r8,0x202
80004eac:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004eae:	e0 68 03 03 	mov	r8,771
80004eb2:	ea 18 03 03 	orh	r8,0x303
80004eb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004eb8:	e0 68 04 04 	mov	r8,1028
80004ebc:	ea 18 04 04 	orh	r8,0x404
80004ec0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004ec2:	e0 68 05 05 	mov	r8,1285
80004ec6:	ea 18 05 05 	orh	r8,0x505
80004eca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004ecc:	e0 68 06 06 	mov	r8,1542
80004ed0:	ea 18 06 06 	orh	r8,0x606
80004ed4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004ed6:	e0 68 07 07 	mov	r8,1799
80004eda:	ea 18 07 07 	orh	r8,0x707
80004ede:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004ee0:	30 08       	mov	r8,0
80004ee2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004ee4:	5e fc       	retal	r12
80004ee6:	d7 03       	nop

80004ee8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004ee8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004eea:	48 38       	lddpc	r8,80004ef4 <vPortEnterCritical+0xc>
80004eec:	70 09       	ld.w	r9,r8[0x0]
80004eee:	2f f9       	sub	r9,-1
80004ef0:	91 09       	st.w	r8[0x0],r9
}
80004ef2:	5e fc       	retal	r12
80004ef4:	00 00       	add	r0,r0
80004ef6:	05 24       	ld.uh	r4,r2++

80004ef8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004ef8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004efa:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004efc:	30 0a       	mov	r10,0
80004efe:	14 9b       	mov	r11,r10
80004f00:	49 2c       	lddpc	r12,80004f48 <xPortStartScheduler+0x50>
80004f02:	f0 1f 00 13 	mcall	80004f4c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004f06:	e0 68 5d c0 	mov	r8,24000
80004f0a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004f0e:	30 08       	mov	r8,0
80004f10:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004f14:	e0 68 0c c8 	mov	r8,3272
80004f18:	ea 18 00 00 	orh	r8,0x0
80004f1c:	70 00       	ld.w	r0,r8[0x0]
80004f1e:	60 0d       	ld.w	sp,r0[0x0]
80004f20:	1b 00       	ld.w	r0,sp++
80004f22:	e0 68 05 24 	mov	r8,1316
80004f26:	ea 18 00 00 	orh	r8,0x0
80004f2a:	91 00       	st.w	r8[0x0],r0
80004f2c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f30:	2f ed       	sub	sp,-8
80004f32:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004f36:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004f3a:	e3 b0 00 00 	mtsr	0x0,r0
80004f3e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004f42:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004f46:	d8 0a       	popm	pc,r12=0
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	50 14       	stdsp	sp[0x4],r4
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	4a 70       	lddpc	r0,80004fe8 <prvClearCcInt>

80004f50 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004f50:	20 6d       	sub	sp,24
80004f52:	eb cd 00 ff 	pushm	r0-r7
80004f56:	fa c7 ff c0 	sub	r7,sp,-64
80004f5a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004f5e:	ef 40 ff e0 	st.w	r7[-32],r0
80004f62:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004f66:	ef 40 ff e4 	st.w	r7[-28],r0
80004f6a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004f6e:	e0 68 05 24 	mov	r8,1316
80004f72:	ea 18 00 00 	orh	r8,0x0
80004f76:	70 00       	ld.w	r0,r8[0x0]
80004f78:	1a d0       	st.w	--sp,r0
80004f7a:	f0 1f 00 1a 	mcall	80004fe0 <LABEL_RET_SCALL_263+0x14>
80004f7e:	e0 68 0c c8 	mov	r8,3272
80004f82:	ea 18 00 00 	orh	r8,0x0
80004f86:	70 00       	ld.w	r0,r8[0x0]
80004f88:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f8a:	f0 1f 00 17 	mcall	80004fe4 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f8e:	e0 68 0c c8 	mov	r8,3272
80004f92:	ea 18 00 00 	orh	r8,0x0
80004f96:	70 00       	ld.w	r0,r8[0x0]
80004f98:	60 0d       	ld.w	sp,r0[0x0]
80004f9a:	1b 00       	ld.w	r0,sp++
80004f9c:	e0 68 05 24 	mov	r8,1316
80004fa0:	ea 18 00 00 	orh	r8,0x0
80004fa4:	91 00       	st.w	r8[0x0],r0
80004fa6:	fa c7 ff d8 	sub	r7,sp,-40
80004faa:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004fae:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004fb2:	e0 61 05 24 	mov	r1,1316
80004fb6:	ea 11 00 00 	orh	r1,0x0
80004fba:	62 02       	ld.w	r2,r1[0x0]
80004fbc:	58 02       	cp.w	r2,0
80004fbe:	c0 70       	breq	80004fcc <LABEL_RET_SCALL_263>
80004fc0:	e4 c2 00 01 	sub	r2,r2,1
80004fc4:	83 02       	st.w	r1[0x0],r2
80004fc6:	58 02       	cp.w	r2,0
80004fc8:	c0 21       	brne	80004fcc <LABEL_RET_SCALL_263>
80004fca:	b1 c0       	cbr	r0,0x10

80004fcc <LABEL_RET_SCALL_263>:
80004fcc:	ef 40 ff f8 	st.w	r7[-8],r0
80004fd0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004fd4:	ef 40 ff fc 	st.w	r7[-4],r0
80004fd8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004fdc:	2f ad       	sub	sp,-24
80004fde:	d6 13       	rets
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	4e e8       	lddpc	r8,80005198 <prvCopyDataFromQueue+0x1c>
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	56 2c       	stdsp	sp[0x188],r12

80004fe8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004fe8:	e1 b8 00 43 	mfsr	r8,0x10c
80004fec:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004ff0:	5e fc       	retal	r12
80004ff2:	d7 03       	nop

80004ff4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004ff4:	48 78       	lddpc	r8,80005010 <vPortExitCritical+0x1c>
80004ff6:	70 08       	ld.w	r8,r8[0x0]
80004ff8:	58 08       	cp.w	r8,0
80004ffa:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004ffc:	48 58       	lddpc	r8,80005010 <vPortExitCritical+0x1c>
80004ffe:	70 09       	ld.w	r9,r8[0x0]
80005000:	20 19       	sub	r9,1
80005002:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005004:	70 08       	ld.w	r8,r8[0x0]
80005006:	58 08       	cp.w	r8,0
80005008:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000500a:	d5 03       	csrf	0x10
8000500c:	5e fc       	retal	r12
8000500e:	00 00       	add	r0,r0
80005010:	00 00       	add	r0,r0
80005012:	05 24       	ld.uh	r4,r2++

80005014 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005014:	eb cd 00 ff 	pushm	r0-r7
80005018:	e0 68 05 24 	mov	r8,1316
8000501c:	ea 18 00 00 	orh	r8,0x0
80005020:	70 00       	ld.w	r0,r8[0x0]
80005022:	1a d0       	st.w	--sp,r0
80005024:	7a 90       	ld.w	r0,sp[0x24]
80005026:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000502a:	58 10       	cp.w	r0,1
8000502c:	e0 8b 00 08 	brhi	8000503c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005030:	e0 68 0c c8 	mov	r8,3272
80005034:	ea 18 00 00 	orh	r8,0x0
80005038:	70 00       	ld.w	r0,r8[0x0]
8000503a:	81 0d       	st.w	r0[0x0],sp

8000503c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000503c:	f0 1f 00 12 	mcall	80005084 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005040:	f0 1f 00 12 	mcall	80005088 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005044:	f0 1f 00 12 	mcall	8000508c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005048:	f0 1f 00 12 	mcall	80005090 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000504c:	7a 90       	ld.w	r0,sp[0x24]
8000504e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005052:	58 10       	cp.w	r0,1
80005054:	e0 8b 00 0e 	brhi	80005070 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005058:	f0 1f 00 0c 	mcall	80005088 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000505c:	f0 1f 00 0e 	mcall	80005094 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005060:	f0 1f 00 0c 	mcall	80005090 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005064:	e0 68 0c c8 	mov	r8,3272
80005068:	ea 18 00 00 	orh	r8,0x0
8000506c:	70 00       	ld.w	r0,r8[0x0]
8000506e:	60 0d       	ld.w	sp,r0[0x0]

80005070 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005070:	1b 00       	ld.w	r0,sp++
80005072:	e0 68 05 24 	mov	r8,1316
80005076:	ea 18 00 00 	orh	r8,0x0
8000507a:	91 00       	st.w	r8[0x0],r0
8000507c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005080:	d6 03       	rete
80005082:	00 00       	add	r0,r0
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4f e8       	lddpc	r8,8000527c <prvUnlockQueue+0x80>
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	4e e8       	lddpc	r8,80005240 <prvUnlockQueue+0x44>
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	58 30       	cp.w	r0,3
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	4f f4       	lddpc	r4,8000528c <prvUnlockQueue+0x90>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	56 2c       	stdsp	sp[0x188],r12

80005098 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005098:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000509a:	f0 1f 00 02 	mcall	800050a0 <__malloc_lock+0x8>
}
8000509e:	d8 02       	popm	pc
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	56 1c       	stdsp	sp[0x184],r12

800050a4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800050a4:	d4 01       	pushm	lr
	xTaskResumeAll();
800050a6:	f0 1f 00 02 	mcall	800050ac <__malloc_unlock+0x8>
}
800050aa:	d8 02       	popm	pc
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	59 d8       	cp.w	r8,29

800050b0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800050b0:	d4 21       	pushm	r4-r7,lr
800050b2:	16 95       	mov	r5,r11
800050b4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800050b6:	58 0c       	cp.w	r12,0
800050b8:	c0 30       	breq	800050be <_read+0xe>
800050ba:	3f f7       	mov	r7,-1
800050bc:	c1 48       	rjmp	800050e4 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800050be:	58 0a       	cp.w	r10,0
800050c0:	e0 89 00 04 	brgt	800050c8 <_read+0x18>
800050c4:	30 07       	mov	r7,0
800050c6:	c0 f8       	rjmp	800050e4 <_read+0x34>
800050c8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800050ca:	48 84       	lddpc	r4,800050e8 <_read+0x38>
800050cc:	68 0c       	ld.w	r12,r4[0x0]
800050ce:	f0 1f 00 08 	mcall	800050ec <_read+0x3c>
    if (c < 0)
800050d2:	c0 95       	brlt	800050e4 <_read+0x34>
      break;

    *ptr++ = c;
800050d4:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800050d8:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800050da:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800050de:	58 08       	cp.w	r8,0
800050e0:	fe 99 ff f6 	brgt	800050cc <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800050e4:	0e 9c       	mov	r12,r7
800050e6:	d8 22       	popm	r4-r7,pc
800050e8:	00 00       	add	r0,r0
800050ea:	40 e8       	lddsp	r8,sp[0x38]
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4c 3c       	lddpc	r12,800051f8 <xQueueReceiveFromISR+0x4c>

800050f0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800050f0:	d4 21       	pushm	r4-r7,lr
800050f2:	16 95       	mov	r5,r11
800050f4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800050f6:	20 1c       	sub	r12,1
800050f8:	58 2c       	cp.w	r12,2
800050fa:	e0 8b 00 12 	brhi	8000511e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800050fe:	58 0a       	cp.w	r10,0
80005100:	c0 31       	brne	80005106 <_write+0x16>
80005102:	30 07       	mov	r7,0
80005104:	c0 e8       	rjmp	80005120 <_write+0x30>
80005106:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005108:	48 74       	lddpc	r4,80005124 <_write+0x34>
8000510a:	68 0c       	ld.w	r12,r4[0x0]
8000510c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005110:	f0 1f 00 06 	mcall	80005128 <_write+0x38>
80005114:	c0 55       	brlt	8000511e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005116:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005118:	0e 36       	cp.w	r6,r7
8000511a:	cf 81       	brne	8000510a <_write+0x1a>
8000511c:	c0 28       	rjmp	80005120 <_write+0x30>
8000511e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005120:	0e 9c       	mov	r12,r7
80005122:	d8 22       	popm	r4-r7,pc
80005124:	00 00       	add	r0,r0
80005126:	40 e8       	lddsp	r8,sp[0x38]
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	4b ec       	lddpc	r12,80005220 <prvUnlockQueue+0x24>

8000512c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000512c:	eb cd 40 80 	pushm	r7,lr
80005130:	18 97       	mov	r7,r12
	if( pv )
80005132:	58 0c       	cp.w	r12,0
80005134:	c0 80       	breq	80005144 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005136:	f0 1f 00 05 	mcall	80005148 <vPortFree+0x1c>
		{
			free( pv );
8000513a:	0e 9c       	mov	r12,r7
8000513c:	f0 1f 00 04 	mcall	8000514c <vPortFree+0x20>
		}
		xTaskResumeAll();
80005140:	f0 1f 00 04 	mcall	80005150 <vPortFree+0x24>
80005144:	e3 cd 80 80 	ldm	sp++,r7,pc
80005148:	80 00       	ld.sh	r0,r0[0x0]
8000514a:	56 1c       	stdsp	sp[0x184],r12
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	64 74       	ld.w	r4,r2[0x1c]
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	59 d8       	cp.w	r8,29

80005154 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005154:	eb cd 40 80 	pushm	r7,lr
80005158:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000515a:	f0 1f 00 06 	mcall	80005170 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000515e:	0e 9c       	mov	r12,r7
80005160:	f0 1f 00 05 	mcall	80005174 <pvPortMalloc+0x20>
80005164:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005166:	f0 1f 00 05 	mcall	80005178 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000516a:	0e 9c       	mov	r12,r7
8000516c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	56 1c       	stdsp	sp[0x184],r12
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	64 84       	ld.w	r4,r2[0x20]
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	59 d8       	cp.w	r8,29

8000517c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000517c:	d4 01       	pushm	lr
8000517e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005180:	78 09       	ld.w	r9,r12[0x0]
80005182:	58 09       	cp.w	r9,0
80005184:	c1 10       	breq	800051a6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005186:	78 3a       	ld.w	r10,r12[0xc]
80005188:	79 09       	ld.w	r9,r12[0x40]
8000518a:	f4 09 00 09 	add	r9,r10,r9
8000518e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005190:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005192:	14 39       	cp.w	r9,r10
80005194:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005198:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000519c:	79 0a       	ld.w	r10,r12[0x40]
8000519e:	78 3b       	ld.w	r11,r12[0xc]
800051a0:	10 9c       	mov	r12,r8
800051a2:	f0 1f 00 02 	mcall	800051a8 <prvCopyDataFromQueue+0x2c>
800051a6:	d8 02       	popm	pc
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	68 cc       	ld.w	r12,r4[0x30]

800051ac <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800051ac:	eb cd 40 c0 	pushm	r6-r7,lr
800051b0:	18 97       	mov	r7,r12
800051b2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800051b4:	78 e8       	ld.w	r8,r12[0x38]
800051b6:	58 08       	cp.w	r8,0
800051b8:	c0 31       	brne	800051be <xQueueReceiveFromISR+0x12>
800051ba:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800051be:	f0 1f 00 0e 	mcall	800051f4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800051c2:	6e e8       	ld.w	r8,r7[0x38]
800051c4:	20 18       	sub	r8,1
800051c6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800051c8:	6f 18       	ld.w	r8,r7[0x44]
800051ca:	5b f8       	cp.w	r8,-1
800051cc:	c0 d1       	brne	800051e6 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800051ce:	6e 48       	ld.w	r8,r7[0x10]
800051d0:	58 08       	cp.w	r8,0
800051d2:	c0 f0       	breq	800051f0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800051d4:	ee cc ff f0 	sub	r12,r7,-16
800051d8:	f0 1f 00 08 	mcall	800051f8 <xQueueReceiveFromISR+0x4c>
800051dc:	c0 a0       	breq	800051f0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800051de:	30 1c       	mov	r12,1
800051e0:	8d 0c       	st.w	r6[0x0],r12
800051e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800051e6:	2f f8       	sub	r8,-1
800051e8:	ef 48 00 44 	st.w	r7[68],r8
800051ec:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051f0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	51 7c       	stdsp	sp[0x5c],r12
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	57 b4       	stdsp	sp[0x1ec],r4

800051fc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800051fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005200:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005202:	f0 1f 00 23 	mcall	8000528c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005206:	6f 28       	ld.w	r8,r7[0x48]
80005208:	58 08       	cp.w	r8,0
8000520a:	e0 8a 00 18 	brle	8000523a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000520e:	6e 98       	ld.w	r8,r7[0x24]
80005210:	58 08       	cp.w	r8,0
80005212:	c1 40       	breq	8000523a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005214:	ee c6 ff dc 	sub	r6,r7,-36
80005218:	c0 48       	rjmp	80005220 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000521a:	6e 98       	ld.w	r8,r7[0x24]
8000521c:	58 08       	cp.w	r8,0
8000521e:	c0 e0       	breq	8000523a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005220:	0c 9c       	mov	r12,r6
80005222:	f0 1f 00 1c 	mcall	80005290 <prvUnlockQueue+0x94>
80005226:	c0 30       	breq	8000522c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005228:	f0 1f 00 1b 	mcall	80005294 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000522c:	6f 28       	ld.w	r8,r7[0x48]
8000522e:	20 18       	sub	r8,1
80005230:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005234:	58 08       	cp.w	r8,0
80005236:	fe 99 ff f2 	brgt	8000521a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000523a:	3f f8       	mov	r8,-1
8000523c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005240:	f0 1f 00 16 	mcall	80005298 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005244:	f0 1f 00 12 	mcall	8000528c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005248:	6f 18       	ld.w	r8,r7[0x44]
8000524a:	58 08       	cp.w	r8,0
8000524c:	e0 8a 00 18 	brle	8000527c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005250:	6e 48       	ld.w	r8,r7[0x10]
80005252:	58 08       	cp.w	r8,0
80005254:	c1 40       	breq	8000527c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005256:	ee c6 ff f0 	sub	r6,r7,-16
8000525a:	c0 48       	rjmp	80005262 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000525c:	6e 48       	ld.w	r8,r7[0x10]
8000525e:	58 08       	cp.w	r8,0
80005260:	c0 e0       	breq	8000527c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005262:	0c 9c       	mov	r12,r6
80005264:	f0 1f 00 0b 	mcall	80005290 <prvUnlockQueue+0x94>
80005268:	c0 30       	breq	8000526e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000526a:	f0 1f 00 0b 	mcall	80005294 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000526e:	6f 18       	ld.w	r8,r7[0x44]
80005270:	20 18       	sub	r8,1
80005272:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005276:	58 08       	cp.w	r8,0
80005278:	fe 99 ff f2 	brgt	8000525c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000527c:	3f f8       	mov	r8,-1
8000527e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005282:	f0 1f 00 06 	mcall	80005298 <prvUnlockQueue+0x9c>
}
80005286:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000528a:	00 00       	add	r0,r0
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	4e e8       	lddpc	r8,80005444 <prvCopyDataToQueue+0x64>
80005290:	80 00       	ld.sh	r0,r0[0x0]
80005292:	57 b4       	stdsp	sp[0x1ec],r4
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	56 c0       	stdsp	sp[0x1b0],r0
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	4f f4       	lddpc	r4,80005494 <xQueueGenericSendFromISR+0x3c>

8000529c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000529c:	d4 31       	pushm	r0-r7,lr
8000529e:	20 5d       	sub	sp,20
800052a0:	18 97       	mov	r7,r12
800052a2:	50 0b       	stdsp	sp[0x0],r11
800052a4:	50 2a       	stdsp	sp[0x8],r10
800052a6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800052a8:	f8 c2 ff dc 	sub	r2,r12,-36
800052ac:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800052ae:	fa c4 ff f4 	sub	r4,sp,-12
800052b2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800052b4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800052b6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800052ba:	f0 1f 00 3e 	mcall	800053b0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800052be:	6e e8       	ld.w	r8,r7[0x38]
800052c0:	58 08       	cp.w	r8,0
800052c2:	c2 a0       	breq	80005316 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800052c4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800052c6:	40 0b       	lddsp	r11,sp[0x0]
800052c8:	0e 9c       	mov	r12,r7
800052ca:	f0 1f 00 3b 	mcall	800053b4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800052ce:	40 18       	lddsp	r8,sp[0x4]
800052d0:	58 08       	cp.w	r8,0
800052d2:	c1 51       	brne	800052fc <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800052d4:	6e e8       	ld.w	r8,r7[0x38]
800052d6:	20 18       	sub	r8,1
800052d8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800052da:	6e 08       	ld.w	r8,r7[0x0]
800052dc:	58 08       	cp.w	r8,0
800052de:	c0 41       	brne	800052e6 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800052e0:	f0 1f 00 36 	mcall	800053b8 <xQueueGenericReceive+0x11c>
800052e4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052e6:	6e 48       	ld.w	r8,r7[0x10]
800052e8:	58 08       	cp.w	r8,0
800052ea:	c1 20       	breq	8000530e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800052ec:	ee cc ff f0 	sub	r12,r7,-16
800052f0:	f0 1f 00 33 	mcall	800053bc <xQueueGenericReceive+0x120>
800052f4:	58 1c       	cp.w	r12,1
800052f6:	c0 c1       	brne	8000530e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800052f8:	d7 33       	scall
800052fa:	c0 a8       	rjmp	8000530e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800052fc:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800052fe:	6e 98       	ld.w	r8,r7[0x24]
80005300:	58 08       	cp.w	r8,0
80005302:	c0 60       	breq	8000530e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005304:	04 9c       	mov	r12,r2
80005306:	f0 1f 00 2e 	mcall	800053bc <xQueueGenericReceive+0x120>
8000530a:	c0 20       	breq	8000530e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000530c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000530e:	f0 1f 00 2d 	mcall	800053c0 <xQueueGenericReceive+0x124>
80005312:	30 1c       	mov	r12,1
				return pdPASS;
80005314:	c4 c8       	rjmp	800053ac <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005316:	40 28       	lddsp	r8,sp[0x8]
80005318:	58 08       	cp.w	r8,0
8000531a:	c0 51       	brne	80005324 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000531c:	f0 1f 00 29 	mcall	800053c0 <xQueueGenericReceive+0x124>
80005320:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005322:	c4 58       	rjmp	800053ac <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005324:	58 05       	cp.w	r5,0
80005326:	c0 51       	brne	80005330 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005328:	08 9c       	mov	r12,r4
8000532a:	f0 1f 00 27 	mcall	800053c4 <xQueueGenericReceive+0x128>
8000532e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005330:	f0 1f 00 24 	mcall	800053c0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005334:	f0 1f 00 25 	mcall	800053c8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005338:	f0 1f 00 1e 	mcall	800053b0 <xQueueGenericReceive+0x114>
8000533c:	6f 18       	ld.w	r8,r7[0x44]
8000533e:	5b f8       	cp.w	r8,-1
80005340:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005344:	6f 28       	ld.w	r8,r7[0x48]
80005346:	5b f8       	cp.w	r8,-1
80005348:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000534c:	f0 1f 00 1d 	mcall	800053c0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005350:	06 9b       	mov	r11,r3
80005352:	08 9c       	mov	r12,r4
80005354:	f0 1f 00 1e 	mcall	800053cc <xQueueGenericReceive+0x130>
80005358:	c2 41       	brne	800053a0 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000535a:	f0 1f 00 16 	mcall	800053b0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000535e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005360:	f0 1f 00 18 	mcall	800053c0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005364:	58 06       	cp.w	r6,0
80005366:	c1 71       	brne	80005394 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005368:	6e 08       	ld.w	r8,r7[0x0]
8000536a:	58 08       	cp.w	r8,0
8000536c:	c0 81       	brne	8000537c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000536e:	f0 1f 00 11 	mcall	800053b0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005372:	6e 1c       	ld.w	r12,r7[0x4]
80005374:	f0 1f 00 17 	mcall	800053d0 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005378:	f0 1f 00 12 	mcall	800053c0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000537c:	40 2b       	lddsp	r11,sp[0x8]
8000537e:	04 9c       	mov	r12,r2
80005380:	f0 1f 00 15 	mcall	800053d4 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005384:	0e 9c       	mov	r12,r7
80005386:	f0 1f 00 15 	mcall	800053d8 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000538a:	f0 1f 00 15 	mcall	800053dc <xQueueGenericReceive+0x140>
8000538e:	c9 61       	brne	800052ba <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005390:	d7 33       	scall
80005392:	c9 4b       	rjmp	800052ba <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005394:	0e 9c       	mov	r12,r7
80005396:	f0 1f 00 11 	mcall	800053d8 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000539a:	f0 1f 00 11 	mcall	800053dc <xQueueGenericReceive+0x140>
8000539e:	c8 eb       	rjmp	800052ba <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800053a0:	0e 9c       	mov	r12,r7
800053a2:	f0 1f 00 0e 	mcall	800053d8 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800053a6:	f0 1f 00 0e 	mcall	800053dc <xQueueGenericReceive+0x140>
800053aa:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800053ac:	2f bd       	sub	sp,-20
800053ae:	d8 32       	popm	r0-r7,pc
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	4e e8       	lddpc	r8,80005568 <xQueueGenericSend+0xc0>
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	51 7c       	stdsp	sp[0x5c],r12
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	56 cc       	stdsp	sp[0x1b0],r12
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	57 b4       	stdsp	sp[0x1ec],r4
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	4f f4       	lddpc	r4,800055bc <xQueueCreate+0x14>
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	56 a8       	stdsp	sp[0x1a8],r8
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	56 1c       	stdsp	sp[0x184],r12
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	59 44       	cp.w	r4,20
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	57 30       	stdsp	sp[0x1cc],r0
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	5b 9c       	cp.w	r12,-7
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	51 fc       	stdsp	sp[0x7c],r12
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	59 d8       	cp.w	r8,29

800053e0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800053e0:	eb cd 40 80 	pushm	r7,lr
800053e4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800053e6:	79 08       	ld.w	r8,r12[0x40]
800053e8:	58 08       	cp.w	r8,0
800053ea:	c0 a1       	brne	800053fe <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800053ec:	78 08       	ld.w	r8,r12[0x0]
800053ee:	58 08       	cp.w	r8,0
800053f0:	c2 b1       	brne	80005446 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800053f2:	78 1c       	ld.w	r12,r12[0x4]
800053f4:	f0 1f 00 17 	mcall	80005450 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800053f8:	30 08       	mov	r8,0
800053fa:	8f 18       	st.w	r7[0x4],r8
800053fc:	c2 58       	rjmp	80005446 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800053fe:	58 0a       	cp.w	r10,0
80005400:	c1 01       	brne	80005420 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005402:	10 9a       	mov	r10,r8
80005404:	78 2c       	ld.w	r12,r12[0x8]
80005406:	f0 1f 00 14 	mcall	80005454 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000540a:	6e 29       	ld.w	r9,r7[0x8]
8000540c:	6f 08       	ld.w	r8,r7[0x40]
8000540e:	f2 08 00 08 	add	r8,r9,r8
80005412:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005414:	6e 19       	ld.w	r9,r7[0x4]
80005416:	12 38       	cp.w	r8,r9
80005418:	c1 73       	brcs	80005446 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000541a:	6e 08       	ld.w	r8,r7[0x0]
8000541c:	8f 28       	st.w	r7[0x8],r8
8000541e:	c1 48       	rjmp	80005446 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005420:	10 9a       	mov	r10,r8
80005422:	78 3c       	ld.w	r12,r12[0xc]
80005424:	f0 1f 00 0c 	mcall	80005454 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005428:	6f 08       	ld.w	r8,r7[0x40]
8000542a:	6e 39       	ld.w	r9,r7[0xc]
8000542c:	f2 08 01 08 	sub	r8,r9,r8
80005430:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005432:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005434:	12 38       	cp.w	r8,r9
80005436:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000543a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000543e:	f3 d8 e3 19 	subcs	r9,r9,r8
80005442:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005446:	6e e8       	ld.w	r8,r7[0x38]
80005448:	2f f8       	sub	r8,-1
8000544a:	8f e8       	st.w	r7[0x38],r8
}
8000544c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	56 d8       	stdsp	sp[0x1b4],r8
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	68 cc       	ld.w	r12,r4[0x30]

80005458 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005458:	eb cd 40 c0 	pushm	r6-r7,lr
8000545c:	18 97       	mov	r7,r12
8000545e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005460:	78 ec       	ld.w	r12,r12[0x38]
80005462:	6e f8       	ld.w	r8,r7[0x3c]
80005464:	10 3c       	cp.w	r12,r8
80005466:	c0 33       	brcs	8000546c <xQueueGenericSendFromISR+0x14>
80005468:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000546c:	12 9a       	mov	r10,r9
8000546e:	0e 9c       	mov	r12,r7
80005470:	f0 1f 00 0c 	mcall	800054a0 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005474:	6f 28       	ld.w	r8,r7[0x48]
80005476:	5b f8       	cp.w	r8,-1
80005478:	c0 d1       	brne	80005492 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000547a:	6e 98       	ld.w	r8,r7[0x24]
8000547c:	58 08       	cp.w	r8,0
8000547e:	c0 f0       	breq	8000549c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005480:	ee cc ff dc 	sub	r12,r7,-36
80005484:	f0 1f 00 08 	mcall	800054a4 <xQueueGenericSendFromISR+0x4c>
80005488:	c0 a0       	breq	8000549c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000548a:	30 1c       	mov	r12,1
8000548c:	8d 0c       	st.w	r6[0x0],r12
8000548e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005492:	2f f8       	sub	r8,-1
80005494:	ef 48 00 48 	st.w	r7[72],r8
80005498:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000549c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	53 e0       	stdsp	sp[0xf8],r0
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	57 b4       	stdsp	sp[0x1ec],r4

800054a8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800054a8:	d4 31       	pushm	r0-r7,lr
800054aa:	20 5d       	sub	sp,20
800054ac:	18 97       	mov	r7,r12
800054ae:	50 0b       	stdsp	sp[0x0],r11
800054b0:	50 2a       	stdsp	sp[0x8],r10
800054b2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800054b4:	f8 c0 ff f0 	sub	r0,r12,-16
800054b8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054ba:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800054be:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054c0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800054c4:	f0 1f 00 2f 	mcall	80005580 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800054c8:	6e e9       	ld.w	r9,r7[0x38]
800054ca:	6e f8       	ld.w	r8,r7[0x3c]
800054cc:	10 39       	cp.w	r9,r8
800054ce:	c1 42       	brcc	800054f6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800054d0:	40 1a       	lddsp	r10,sp[0x4]
800054d2:	40 0b       	lddsp	r11,sp[0x0]
800054d4:	0e 9c       	mov	r12,r7
800054d6:	f0 1f 00 2c 	mcall	80005584 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054da:	6e 98       	ld.w	r8,r7[0x24]
800054dc:	58 08       	cp.w	r8,0
800054de:	c0 80       	breq	800054ee <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800054e0:	ee cc ff dc 	sub	r12,r7,-36
800054e4:	f0 1f 00 29 	mcall	80005588 <xQueueGenericSend+0xe0>
800054e8:	58 1c       	cp.w	r12,1
800054ea:	c0 21       	brne	800054ee <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800054ec:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800054ee:	f0 1f 00 28 	mcall	8000558c <xQueueGenericSend+0xe4>
800054f2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800054f4:	c4 38       	rjmp	8000557a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800054f6:	40 28       	lddsp	r8,sp[0x8]
800054f8:	58 08       	cp.w	r8,0
800054fa:	c0 51       	brne	80005504 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800054fc:	f0 1f 00 24 	mcall	8000558c <xQueueGenericSend+0xe4>
80005500:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005502:	c3 c8       	rjmp	8000557a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005504:	58 04       	cp.w	r4,0
80005506:	c0 51       	brne	80005510 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005508:	06 9c       	mov	r12,r3
8000550a:	f0 1f 00 22 	mcall	80005590 <xQueueGenericSend+0xe8>
8000550e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005510:	f0 1f 00 1f 	mcall	8000558c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005514:	f0 1f 00 20 	mcall	80005594 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005518:	f0 1f 00 1a 	mcall	80005580 <xQueueGenericSend+0xd8>
8000551c:	6f 18       	ld.w	r8,r7[0x44]
8000551e:	5b f8       	cp.w	r8,-1
80005520:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005524:	6f 28       	ld.w	r8,r7[0x48]
80005526:	5b f8       	cp.w	r8,-1
80005528:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000552c:	f0 1f 00 18 	mcall	8000558c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005530:	04 9b       	mov	r11,r2
80005532:	06 9c       	mov	r12,r3
80005534:	f0 1f 00 19 	mcall	80005598 <xQueueGenericSend+0xf0>
80005538:	c1 b1       	brne	8000556e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000553a:	f0 1f 00 12 	mcall	80005580 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000553e:	6e e5       	ld.w	r5,r7[0x38]
80005540:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005542:	f0 1f 00 13 	mcall	8000558c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005546:	0c 35       	cp.w	r5,r6
80005548:	c0 d1       	brne	80005562 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000554a:	40 2b       	lddsp	r11,sp[0x8]
8000554c:	00 9c       	mov	r12,r0
8000554e:	f0 1f 00 14 	mcall	8000559c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005552:	0e 9c       	mov	r12,r7
80005554:	f0 1f 00 13 	mcall	800055a0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005558:	f0 1f 00 13 	mcall	800055a4 <xQueueGenericSend+0xfc>
8000555c:	cb 41       	brne	800054c4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000555e:	d7 33       	scall
80005560:	cb 2b       	rjmp	800054c4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005562:	0e 9c       	mov	r12,r7
80005564:	f0 1f 00 0f 	mcall	800055a0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005568:	f0 1f 00 0f 	mcall	800055a4 <xQueueGenericSend+0xfc>
8000556c:	ca cb       	rjmp	800054c4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000556e:	0e 9c       	mov	r12,r7
80005570:	f0 1f 00 0c 	mcall	800055a0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005574:	f0 1f 00 0c 	mcall	800055a4 <xQueueGenericSend+0xfc>
80005578:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000557a:	2f bd       	sub	sp,-20
8000557c:	d8 32       	popm	r0-r7,pc
8000557e:	00 00       	add	r0,r0
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	4e e8       	lddpc	r8,80005738 <vTaskPriorityInherit+0x8>
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	53 e0       	stdsp	sp[0xf8],r0
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	57 b4       	stdsp	sp[0x1ec],r4
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	4f f4       	lddpc	r4,80005788 <vTaskPriorityInherit+0x58>
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	56 a8       	stdsp	sp[0x1a8],r8
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	56 1c       	stdsp	sp[0x184],r12
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	59 44       	cp.w	r4,20
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	5b 9c       	cp.w	r12,-7
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	51 fc       	stdsp	sp[0x7c],r12
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	59 d8       	cp.w	r8,29

800055a8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800055a8:	d4 21       	pushm	r4-r7,lr
800055aa:	18 97       	mov	r7,r12
800055ac:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800055ae:	58 0c       	cp.w	r12,0
800055b0:	c2 f0       	breq	8000560e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800055b2:	34 cc       	mov	r12,76
800055b4:	f0 1f 00 17 	mcall	80005610 <xQueueCreate+0x68>
800055b8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800055ba:	c2 a0       	breq	8000560e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800055bc:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800055c0:	e8 cc ff ff 	sub	r12,r4,-1
800055c4:	f0 1f 00 13 	mcall	80005610 <xQueueCreate+0x68>
800055c8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800055ca:	c1 e0       	breq	80005606 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800055cc:	f8 04 00 04 	add	r4,r12,r4
800055d0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800055d2:	30 08       	mov	r8,0
800055d4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800055d6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800055d8:	ee c8 00 01 	sub	r8,r7,1
800055dc:	ad 38       	mul	r8,r6
800055de:	10 0c       	add	r12,r8
800055e0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800055e2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800055e4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800055e8:	3f f8       	mov	r8,-1
800055ea:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800055ee:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800055f2:	ea cc ff f0 	sub	r12,r5,-16
800055f6:	f0 1f 00 08 	mcall	80005614 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800055fa:	ea cc ff dc 	sub	r12,r5,-36
800055fe:	f0 1f 00 06 	mcall	80005614 <xQueueCreate+0x6c>
80005602:	0a 9c       	mov	r12,r5
80005604:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005606:	0a 9c       	mov	r12,r5
80005608:	f0 1f 00 04 	mcall	80005618 <xQueueCreate+0x70>
8000560c:	d8 2a       	popm	r4-r7,pc,r12=0
8000560e:	d8 2a       	popm	r4-r7,pc,r12=0
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	51 54       	stdsp	sp[0x54],r4
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	4d c4       	lddpc	r4,80005784 <vTaskPriorityInherit+0x54>
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	51 2c       	stdsp	sp[0x48],r12

8000561c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000561c:	48 38       	lddpc	r8,80005628 <vTaskSuspendAll+0xc>
8000561e:	70 09       	ld.w	r9,r8[0x0]
80005620:	2f f9       	sub	r9,-1
80005622:	91 09       	st.w	r8[0x0],r9
}
80005624:	5e fc       	retal	r12
80005626:	00 00       	add	r0,r0
80005628:	00 00       	add	r0,r0
8000562a:	0c f8       	st.b	--r6,r8

8000562c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000562c:	49 a8       	lddpc	r8,80005694 <vTaskSwitchContext+0x68>
8000562e:	70 08       	ld.w	r8,r8[0x0]
80005630:	58 08       	cp.w	r8,0
80005632:	c0 b1       	brne	80005648 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005634:	49 98       	lddpc	r8,80005698 <vTaskSwitchContext+0x6c>
80005636:	70 08       	ld.w	r8,r8[0x0]
80005638:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000563c:	49 89       	lddpc	r9,8000569c <vTaskSwitchContext+0x70>
8000563e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005642:	58 08       	cp.w	r8,0
80005644:	c0 60       	breq	80005650 <vTaskSwitchContext+0x24>
80005646:	c1 18       	rjmp	80005668 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005648:	30 19       	mov	r9,1
8000564a:	49 68       	lddpc	r8,800056a0 <vTaskSwitchContext+0x74>
8000564c:	91 09       	st.w	r8[0x0],r9
8000564e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005650:	49 28       	lddpc	r8,80005698 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005652:	49 3a       	lddpc	r10,8000569c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005654:	70 09       	ld.w	r9,r8[0x0]
80005656:	20 19       	sub	r9,1
80005658:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000565a:	70 09       	ld.w	r9,r8[0x0]
8000565c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005660:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005664:	58 09       	cp.w	r9,0
80005666:	cf 70       	breq	80005654 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005668:	48 c8       	lddpc	r8,80005698 <vTaskSwitchContext+0x6c>
8000566a:	70 08       	ld.w	r8,r8[0x0]
8000566c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005670:	48 b9       	lddpc	r9,8000569c <vTaskSwitchContext+0x70>
80005672:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005676:	70 19       	ld.w	r9,r8[0x4]
80005678:	72 19       	ld.w	r9,r9[0x4]
8000567a:	91 19       	st.w	r8[0x4],r9
8000567c:	f0 ca ff f8 	sub	r10,r8,-8
80005680:	14 39       	cp.w	r9,r10
80005682:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005686:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000568a:	70 18       	ld.w	r8,r8[0x4]
8000568c:	70 39       	ld.w	r9,r8[0xc]
8000568e:	48 68       	lddpc	r8,800056a4 <vTaskSwitchContext+0x78>
80005690:	91 09       	st.w	r8[0x0],r9
80005692:	5e fc       	retal	r12
80005694:	00 00       	add	r0,r0
80005696:	0c f8       	st.b	--r6,r8
80005698:	00 00       	add	r0,r0
8000569a:	0d 30       	ld.ub	r0,r6++
8000569c:	00 00       	add	r0,r0
8000569e:	0c 14       	sub	r4,r6
800056a0:	00 00       	add	r0,r0
800056a2:	0d 18       	ld.sh	r8,r6++
800056a4:	00 00       	add	r0,r0
800056a6:	0c c8       	st.b	r6++,r8

800056a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800056a8:	48 48       	lddpc	r8,800056b8 <vTaskSetTimeOutState+0x10>
800056aa:	70 08       	ld.w	r8,r8[0x0]
800056ac:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800056ae:	48 48       	lddpc	r8,800056bc <vTaskSetTimeOutState+0x14>
800056b0:	70 08       	ld.w	r8,r8[0x0]
800056b2:	99 18       	st.w	r12[0x4],r8
}
800056b4:	5e fc       	retal	r12
800056b6:	00 00       	add	r0,r0
800056b8:	00 00       	add	r0,r0
800056ba:	0c 0c       	add	r12,r6
800056bc:	00 00       	add	r0,r0
800056be:	0c f4       	st.b	--r6,r4

800056c0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800056c0:	30 19       	mov	r9,1
800056c2:	48 28       	lddpc	r8,800056c8 <vTaskMissedYield+0x8>
800056c4:	91 09       	st.w	r8[0x0],r9
}
800056c6:	5e fc       	retal	r12
800056c8:	00 00       	add	r0,r0
800056ca:	0d 18       	ld.sh	r8,r6++

800056cc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800056cc:	48 28       	lddpc	r8,800056d4 <xTaskGetCurrentTaskHandle+0x8>
800056ce:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800056d0:	5e fc       	retal	r12
800056d2:	00 00       	add	r0,r0
800056d4:	00 00       	add	r0,r0
800056d6:	0c c8       	st.b	r6++,r8

800056d8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800056d8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800056dc:	58 0c       	cp.w	r12,0
800056de:	c1 f0       	breq	8000571c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800056e0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800056e2:	78 b9       	ld.w	r9,r12[0x2c]
800056e4:	79 18       	ld.w	r8,r12[0x44]
800056e6:	10 39       	cp.w	r9,r8
800056e8:	c1 a0       	breq	8000571c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800056ea:	f8 c6 ff fc 	sub	r6,r12,-4
800056ee:	0c 9c       	mov	r12,r6
800056f0:	f0 1f 00 0c 	mcall	80005720 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800056f4:	6f 1c       	ld.w	r12,r7[0x44]
800056f6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800056f8:	f8 08 11 08 	rsub	r8,r12,8
800056fc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800056fe:	48 a8       	lddpc	r8,80005724 <vTaskPriorityDisinherit+0x4c>
80005700:	70 08       	ld.w	r8,r8[0x0]
80005702:	10 3c       	cp.w	r12,r8
80005704:	e0 88 00 04 	brls	8000570c <vTaskPriorityDisinherit+0x34>
80005708:	48 78       	lddpc	r8,80005724 <vTaskPriorityDisinherit+0x4c>
8000570a:	91 0c       	st.w	r8[0x0],r12
8000570c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005710:	0c 9b       	mov	r11,r6
80005712:	48 68       	lddpc	r8,80005728 <vTaskPriorityDisinherit+0x50>
80005714:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005718:	f0 1f 00 05 	mcall	8000572c <vTaskPriorityDisinherit+0x54>
8000571c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	4e 2e       	lddpc	lr,800058a8 <vTaskIncrementTick+0x78>
80005724:	00 00       	add	r0,r0
80005726:	0d 30       	ld.ub	r0,r6++
80005728:	00 00       	add	r0,r0
8000572a:	0c 14       	sub	r4,r6
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	4d de       	lddpc	lr,800058a0 <vTaskIncrementTick+0x70>

80005730 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005730:	eb cd 40 c0 	pushm	r6-r7,lr
80005734:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005736:	49 b8       	lddpc	r8,800057a0 <vTaskPriorityInherit+0x70>
80005738:	70 08       	ld.w	r8,r8[0x0]
8000573a:	78 b9       	ld.w	r9,r12[0x2c]
8000573c:	70 b8       	ld.w	r8,r8[0x2c]
8000573e:	10 39       	cp.w	r9,r8
80005740:	c2 d2       	brcc	8000579a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005742:	49 88       	lddpc	r8,800057a0 <vTaskPriorityInherit+0x70>
80005744:	70 08       	ld.w	r8,r8[0x0]
80005746:	70 b8       	ld.w	r8,r8[0x2c]
80005748:	f0 08 11 08 	rsub	r8,r8,8
8000574c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000574e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005752:	49 59       	lddpc	r9,800057a4 <vTaskPriorityInherit+0x74>
80005754:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005758:	78 59       	ld.w	r9,r12[0x14]
8000575a:	10 39       	cp.w	r9,r8
8000575c:	c1 b1       	brne	80005792 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000575e:	f8 c6 ff fc 	sub	r6,r12,-4
80005762:	0c 9c       	mov	r12,r6
80005764:	f0 1f 00 11 	mcall	800057a8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005768:	48 e8       	lddpc	r8,800057a0 <vTaskPriorityInherit+0x70>
8000576a:	70 08       	ld.w	r8,r8[0x0]
8000576c:	70 bc       	ld.w	r12,r8[0x2c]
8000576e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005770:	48 f8       	lddpc	r8,800057ac <vTaskPriorityInherit+0x7c>
80005772:	70 08       	ld.w	r8,r8[0x0]
80005774:	10 3c       	cp.w	r12,r8
80005776:	e0 88 00 04 	brls	8000577e <vTaskPriorityInherit+0x4e>
8000577a:	48 d8       	lddpc	r8,800057ac <vTaskPriorityInherit+0x7c>
8000577c:	91 0c       	st.w	r8[0x0],r12
8000577e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005782:	0c 9b       	mov	r11,r6
80005784:	48 88       	lddpc	r8,800057a4 <vTaskPriorityInherit+0x74>
80005786:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000578a:	f0 1f 00 0a 	mcall	800057b0 <vTaskPriorityInherit+0x80>
8000578e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005792:	48 48       	lddpc	r8,800057a0 <vTaskPriorityInherit+0x70>
80005794:	70 08       	ld.w	r8,r8[0x0]
80005796:	70 b8       	ld.w	r8,r8[0x2c]
80005798:	99 b8       	st.w	r12[0x2c],r8
8000579a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000579e:	00 00       	add	r0,r0
800057a0:	00 00       	add	r0,r0
800057a2:	0c c8       	st.b	r6++,r8
800057a4:	00 00       	add	r0,r0
800057a6:	0c 14       	sub	r4,r6
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	4e 2e       	lddpc	lr,80005930 <vTaskIncrementTick+0x100>
800057ac:	00 00       	add	r0,r0
800057ae:	0d 30       	ld.ub	r0,r6++
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	4d de       	lddpc	lr,80005924 <vTaskIncrementTick+0xf4>

800057b4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800057b4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800057b8:	78 38       	ld.w	r8,r12[0xc]
800057ba:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800057bc:	ee c6 ff e8 	sub	r6,r7,-24
800057c0:	0c 9c       	mov	r12,r6
800057c2:	f0 1f 00 15 	mcall	80005814 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800057c6:	49 58       	lddpc	r8,80005818 <xTaskRemoveFromEventList+0x64>
800057c8:	70 08       	ld.w	r8,r8[0x0]
800057ca:	58 08       	cp.w	r8,0
800057cc:	c1 71       	brne	800057fa <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800057ce:	ee c6 ff fc 	sub	r6,r7,-4
800057d2:	0c 9c       	mov	r12,r6
800057d4:	f0 1f 00 10 	mcall	80005814 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800057d8:	6e bc       	ld.w	r12,r7[0x2c]
800057da:	49 18       	lddpc	r8,8000581c <xTaskRemoveFromEventList+0x68>
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	10 3c       	cp.w	r12,r8
800057e0:	e0 88 00 04 	brls	800057e8 <xTaskRemoveFromEventList+0x34>
800057e4:	48 e8       	lddpc	r8,8000581c <xTaskRemoveFromEventList+0x68>
800057e6:	91 0c       	st.w	r8[0x0],r12
800057e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800057ec:	0c 9b       	mov	r11,r6
800057ee:	48 d8       	lddpc	r8,80005820 <xTaskRemoveFromEventList+0x6c>
800057f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800057f4:	f0 1f 00 0c 	mcall	80005824 <xTaskRemoveFromEventList+0x70>
800057f8:	c0 58       	rjmp	80005802 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800057fa:	0c 9b       	mov	r11,r6
800057fc:	48 bc       	lddpc	r12,80005828 <xTaskRemoveFromEventList+0x74>
800057fe:	f0 1f 00 0a 	mcall	80005824 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005802:	48 b8       	lddpc	r8,8000582c <xTaskRemoveFromEventList+0x78>
80005804:	70 08       	ld.w	r8,r8[0x0]
80005806:	6e b9       	ld.w	r9,r7[0x2c]
80005808:	70 b8       	ld.w	r8,r8[0x2c]
8000580a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000580c:	5f 2c       	srhs	r12
8000580e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005812:	00 00       	add	r0,r0
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	4e 2e       	lddpc	lr,8000599c <xTaskCheckForTimeOut+0x58>
80005818:	00 00       	add	r0,r0
8000581a:	0c f8       	st.b	--r6,r8
8000581c:	00 00       	add	r0,r0
8000581e:	0d 30       	ld.ub	r0,r6++
80005820:	00 00       	add	r0,r0
80005822:	0c 14       	sub	r4,r6
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	4d de       	lddpc	lr,80005998 <xTaskCheckForTimeOut+0x54>
80005828:	00 00       	add	r0,r0
8000582a:	0c cc       	st.b	r6++,r12
8000582c:	00 00       	add	r0,r0
8000582e:	0c c8       	st.b	r6++,r8

80005830 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005830:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005834:	4b 98       	lddpc	r8,80005918 <vTaskIncrementTick+0xe8>
80005836:	70 08       	ld.w	r8,r8[0x0]
80005838:	58 08       	cp.w	r8,0
8000583a:	c6 91       	brne	8000590c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000583c:	4b 88       	lddpc	r8,8000591c <vTaskIncrementTick+0xec>
8000583e:	70 09       	ld.w	r9,r8[0x0]
80005840:	2f f9       	sub	r9,-1
80005842:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005844:	70 08       	ld.w	r8,r8[0x0]
80005846:	58 08       	cp.w	r8,0
80005848:	c1 a1       	brne	8000587c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000584a:	4b 68       	lddpc	r8,80005920 <vTaskIncrementTick+0xf0>
8000584c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000584e:	4b 69       	lddpc	r9,80005924 <vTaskIncrementTick+0xf4>
80005850:	72 0b       	ld.w	r11,r9[0x0]
80005852:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005854:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005856:	4b 59       	lddpc	r9,80005928 <vTaskIncrementTick+0xf8>
80005858:	72 0a       	ld.w	r10,r9[0x0]
8000585a:	2f fa       	sub	r10,-1
8000585c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000585e:	70 08       	ld.w	r8,r8[0x0]
80005860:	70 08       	ld.w	r8,r8[0x0]
80005862:	58 08       	cp.w	r8,0
80005864:	c0 51       	brne	8000586e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005866:	3f f9       	mov	r9,-1
80005868:	4b 18       	lddpc	r8,8000592c <vTaskIncrementTick+0xfc>
8000586a:	91 09       	st.w	r8[0x0],r9
8000586c:	c0 88       	rjmp	8000587c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000586e:	4a d8       	lddpc	r8,80005920 <vTaskIncrementTick+0xf0>
80005870:	70 08       	ld.w	r8,r8[0x0]
80005872:	70 38       	ld.w	r8,r8[0xc]
80005874:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005876:	70 19       	ld.w	r9,r8[0x4]
80005878:	4a d8       	lddpc	r8,8000592c <vTaskIncrementTick+0xfc>
8000587a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000587c:	4a 88       	lddpc	r8,8000591c <vTaskIncrementTick+0xec>
8000587e:	70 09       	ld.w	r9,r8[0x0]
80005880:	4a b8       	lddpc	r8,8000592c <vTaskIncrementTick+0xfc>
80005882:	70 08       	ld.w	r8,r8[0x0]
80005884:	10 39       	cp.w	r9,r8
80005886:	c4 73       	brcs	80005914 <vTaskIncrementTick+0xe4>
80005888:	4a 68       	lddpc	r8,80005920 <vTaskIncrementTick+0xf0>
8000588a:	70 08       	ld.w	r8,r8[0x0]
8000588c:	70 08       	ld.w	r8,r8[0x0]
8000588e:	58 08       	cp.w	r8,0
80005890:	c0 c0       	breq	800058a8 <vTaskIncrementTick+0x78>
80005892:	4a 48       	lddpc	r8,80005920 <vTaskIncrementTick+0xf0>
80005894:	70 08       	ld.w	r8,r8[0x0]
80005896:	70 38       	ld.w	r8,r8[0xc]
80005898:	70 37       	ld.w	r7,r8[0xc]
8000589a:	6e 18       	ld.w	r8,r7[0x4]
8000589c:	4a 09       	lddpc	r9,8000591c <vTaskIncrementTick+0xec>
8000589e:	72 09       	ld.w	r9,r9[0x0]
800058a0:	12 38       	cp.w	r8,r9
800058a2:	e0 88 00 14 	brls	800058ca <vTaskIncrementTick+0x9a>
800058a6:	c0 e8       	rjmp	800058c2 <vTaskIncrementTick+0x92>
800058a8:	3f f9       	mov	r9,-1
800058aa:	4a 18       	lddpc	r8,8000592c <vTaskIncrementTick+0xfc>
800058ac:	91 09       	st.w	r8[0x0],r9
800058ae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800058b2:	6a 08       	ld.w	r8,r5[0x0]
800058b4:	70 38       	ld.w	r8,r8[0xc]
800058b6:	70 37       	ld.w	r7,r8[0xc]
800058b8:	6e 18       	ld.w	r8,r7[0x4]
800058ba:	64 09       	ld.w	r9,r2[0x0]
800058bc:	12 38       	cp.w	r8,r9
800058be:	e0 88 00 0a 	brls	800058d2 <vTaskIncrementTick+0xa2>
800058c2:	49 b9       	lddpc	r9,8000592c <vTaskIncrementTick+0xfc>
800058c4:	93 08       	st.w	r9[0x0],r8
800058c6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800058ca:	49 a4       	lddpc	r4,80005930 <vTaskIncrementTick+0x100>
800058cc:	49 a3       	lddpc	r3,80005934 <vTaskIncrementTick+0x104>
800058ce:	49 55       	lddpc	r5,80005920 <vTaskIncrementTick+0xf0>
800058d0:	49 32       	lddpc	r2,8000591c <vTaskIncrementTick+0xec>
800058d2:	ee c6 ff fc 	sub	r6,r7,-4
800058d6:	0c 9c       	mov	r12,r6
800058d8:	f0 1f 00 18 	mcall	80005938 <vTaskIncrementTick+0x108>
800058dc:	6e a8       	ld.w	r8,r7[0x28]
800058de:	58 08       	cp.w	r8,0
800058e0:	c0 50       	breq	800058ea <vTaskIncrementTick+0xba>
800058e2:	ee cc ff e8 	sub	r12,r7,-24
800058e6:	f0 1f 00 15 	mcall	80005938 <vTaskIncrementTick+0x108>
800058ea:	6e bc       	ld.w	r12,r7[0x2c]
800058ec:	68 08       	ld.w	r8,r4[0x0]
800058ee:	10 3c       	cp.w	r12,r8
800058f0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800058f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058f8:	0c 9b       	mov	r11,r6
800058fa:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800058fe:	f0 1f 00 10 	mcall	8000593c <vTaskIncrementTick+0x10c>
80005902:	6a 08       	ld.w	r8,r5[0x0]
80005904:	70 08       	ld.w	r8,r8[0x0]
80005906:	58 08       	cp.w	r8,0
80005908:	cd 51       	brne	800058b2 <vTaskIncrementTick+0x82>
8000590a:	cc fb       	rjmp	800058a8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000590c:	48 d8       	lddpc	r8,80005940 <vTaskIncrementTick+0x110>
8000590e:	70 09       	ld.w	r9,r8[0x0]
80005910:	2f f9       	sub	r9,-1
80005912:	91 09       	st.w	r8[0x0],r9
80005914:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005918:	00 00       	add	r0,r0
8000591a:	0c f8       	st.b	--r6,r8
8000591c:	00 00       	add	r0,r0
8000591e:	0c f4       	st.b	--r6,r4
80005920:	00 00       	add	r0,r0
80005922:	0c 00       	add	r0,r6
80005924:	00 00       	add	r0,r0
80005926:	0c 10       	sub	r0,r6
80005928:	00 00       	add	r0,r0
8000592a:	0c 0c       	add	r12,r6
8000592c:	00 00       	add	r0,r0
8000592e:	05 28       	ld.uh	r8,r2++
80005930:	00 00       	add	r0,r0
80005932:	0d 30       	ld.ub	r0,r6++
80005934:	00 00       	add	r0,r0
80005936:	0c 14       	sub	r4,r6
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	4e 2e       	lddpc	lr,80005ac0 <prvAddCurrentTaskToDelayedList>
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	4d de       	lddpc	lr,80005ab0 <xTaskResumeAll+0xd8>
80005940:	00 00       	add	r0,r0
80005942:	0b f8       	ld.ub	r8,r5[0x7]

80005944 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005944:	eb cd 40 c0 	pushm	r6-r7,lr
80005948:	18 97       	mov	r7,r12
8000594a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000594c:	f0 1f 00 15 	mcall	800059a0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005950:	6c 08       	ld.w	r8,r6[0x0]
80005952:	5b f8       	cp.w	r8,-1
80005954:	c0 31       	brne	8000595a <xTaskCheckForTimeOut+0x16>
80005956:	30 07       	mov	r7,0
80005958:	c1 f8       	rjmp	80005996 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000595a:	49 39       	lddpc	r9,800059a4 <xTaskCheckForTimeOut+0x60>
8000595c:	72 09       	ld.w	r9,r9[0x0]
8000595e:	6e 0a       	ld.w	r10,r7[0x0]
80005960:	12 3a       	cp.w	r10,r9
80005962:	c0 70       	breq	80005970 <xTaskCheckForTimeOut+0x2c>
80005964:	49 19       	lddpc	r9,800059a8 <xTaskCheckForTimeOut+0x64>
80005966:	72 09       	ld.w	r9,r9[0x0]
80005968:	6e 1a       	ld.w	r10,r7[0x4]
8000596a:	12 3a       	cp.w	r10,r9
8000596c:	e0 88 00 14 	brls	80005994 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005970:	48 e9       	lddpc	r9,800059a8 <xTaskCheckForTimeOut+0x64>
80005972:	72 0a       	ld.w	r10,r9[0x0]
80005974:	6e 19       	ld.w	r9,r7[0x4]
80005976:	12 1a       	sub	r10,r9
80005978:	14 38       	cp.w	r8,r10
8000597a:	e0 88 00 0d 	brls	80005994 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000597e:	48 ba       	lddpc	r10,800059a8 <xTaskCheckForTimeOut+0x64>
80005980:	74 0a       	ld.w	r10,r10[0x0]
80005982:	14 19       	sub	r9,r10
80005984:	f2 08 00 08 	add	r8,r9,r8
80005988:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000598a:	0e 9c       	mov	r12,r7
8000598c:	f0 1f 00 08 	mcall	800059ac <xTaskCheckForTimeOut+0x68>
80005990:	30 07       	mov	r7,0
80005992:	c0 28       	rjmp	80005996 <xTaskCheckForTimeOut+0x52>
80005994:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005996:	f0 1f 00 07 	mcall	800059b0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000599a:	0e 9c       	mov	r12,r7
8000599c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	4e e8       	lddpc	r8,80005b58 <vTaskDelayUntil+0x3c>
800059a4:	00 00       	add	r0,r0
800059a6:	0c 0c       	add	r12,r6
800059a8:	00 00       	add	r0,r0
800059aa:	0c f4       	st.b	--r6,r4
800059ac:	80 00       	ld.sh	r0,r0[0x0]
800059ae:	56 a8       	stdsp	sp[0x1a8],r8
800059b0:	80 00       	ld.sh	r0,r0[0x0]
800059b2:	4f f4       	lddpc	r4,80005bac <vTaskPlaceOnEventList+0x10>

800059b4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800059b4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800059b8:	f0 1f 00 05 	mcall	800059cc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800059bc:	48 58       	lddpc	r8,800059d0 <xTaskGetTickCount+0x1c>
800059be:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800059c0:	f0 1f 00 05 	mcall	800059d4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800059c4:	0e 9c       	mov	r12,r7
800059c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800059ca:	00 00       	add	r0,r0
800059cc:	80 00       	ld.sh	r0,r0[0x0]
800059ce:	4e e8       	lddpc	r8,80005b84 <vTaskDelayUntil+0x68>
800059d0:	00 00       	add	r0,r0
800059d2:	0c f4       	st.b	--r6,r4
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	4f f4       	lddpc	r4,80005bd0 <vTaskPlaceOnEventList+0x34>

800059d8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800059d8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800059dc:	f0 1f 00 2c 	mcall	80005a8c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800059e0:	4a c8       	lddpc	r8,80005a90 <xTaskResumeAll+0xb8>
800059e2:	70 09       	ld.w	r9,r8[0x0]
800059e4:	20 19       	sub	r9,1
800059e6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059e8:	70 08       	ld.w	r8,r8[0x0]
800059ea:	58 08       	cp.w	r8,0
800059ec:	c4 91       	brne	80005a7e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800059ee:	4a a8       	lddpc	r8,80005a94 <xTaskResumeAll+0xbc>
800059f0:	70 08       	ld.w	r8,r8[0x0]
800059f2:	58 08       	cp.w	r8,0
800059f4:	c4 50       	breq	80005a7e <xTaskResumeAll+0xa6>
800059f6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800059f8:	4a 85       	lddpc	r5,80005a98 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800059fa:	4a 93       	lddpc	r3,80005a9c <xTaskResumeAll+0xc4>
800059fc:	4a 92       	lddpc	r2,80005aa0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059fe:	4a a1       	lddpc	r1,80005aa4 <xTaskResumeAll+0xcc>
80005a00:	c1 e8       	rjmp	80005a3c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005a02:	6a 38       	ld.w	r8,r5[0xc]
80005a04:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005a06:	ee cc ff e8 	sub	r12,r7,-24
80005a0a:	f0 1f 00 28 	mcall	80005aa8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005a0e:	ee c6 ff fc 	sub	r6,r7,-4
80005a12:	0c 9c       	mov	r12,r6
80005a14:	f0 1f 00 25 	mcall	80005aa8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005a18:	6e bc       	ld.w	r12,r7[0x2c]
80005a1a:	66 08       	ld.w	r8,r3[0x0]
80005a1c:	10 3c       	cp.w	r12,r8
80005a1e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005a22:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a26:	0c 9b       	mov	r11,r6
80005a28:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005a2c:	f0 1f 00 20 	mcall	80005aac <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a30:	62 08       	ld.w	r8,r1[0x0]
80005a32:	6e b9       	ld.w	r9,r7[0x2c]
80005a34:	70 b8       	ld.w	r8,r8[0x2c]
80005a36:	10 39       	cp.w	r9,r8
80005a38:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005a3c:	6a 08       	ld.w	r8,r5[0x0]
80005a3e:	58 08       	cp.w	r8,0
80005a40:	ce 11       	brne	80005a02 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a42:	49 c8       	lddpc	r8,80005ab0 <xTaskResumeAll+0xd8>
80005a44:	70 08       	ld.w	r8,r8[0x0]
80005a46:	58 08       	cp.w	r8,0
80005a48:	c0 f0       	breq	80005a66 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a4a:	49 a8       	lddpc	r8,80005ab0 <xTaskResumeAll+0xd8>
80005a4c:	70 08       	ld.w	r8,r8[0x0]
80005a4e:	58 08       	cp.w	r8,0
80005a50:	c1 10       	breq	80005a72 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005a52:	49 87       	lddpc	r7,80005ab0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005a54:	f0 1f 00 18 	mcall	80005ab4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005a58:	6e 08       	ld.w	r8,r7[0x0]
80005a5a:	20 18       	sub	r8,1
80005a5c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005a5e:	6e 08       	ld.w	r8,r7[0x0]
80005a60:	58 08       	cp.w	r8,0
80005a62:	cf 91       	brne	80005a54 <xTaskResumeAll+0x7c>
80005a64:	c0 78       	rjmp	80005a72 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005a66:	58 14       	cp.w	r4,1
80005a68:	c0 50       	breq	80005a72 <xTaskResumeAll+0x9a>
80005a6a:	49 48       	lddpc	r8,80005ab8 <xTaskResumeAll+0xe0>
80005a6c:	70 08       	ld.w	r8,r8[0x0]
80005a6e:	58 18       	cp.w	r8,1
80005a70:	c0 71       	brne	80005a7e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005a72:	30 09       	mov	r9,0
80005a74:	49 18       	lddpc	r8,80005ab8 <xTaskResumeAll+0xe0>
80005a76:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005a78:	d7 33       	scall
80005a7a:	30 17       	mov	r7,1
80005a7c:	c0 28       	rjmp	80005a80 <xTaskResumeAll+0xa8>
80005a7e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005a80:	f0 1f 00 0f 	mcall	80005abc <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005a84:	0e 9c       	mov	r12,r7
80005a86:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005a8a:	00 00       	add	r0,r0
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	4e e8       	lddpc	r8,80005c44 <prvIdleTask+0x50>
80005a90:	00 00       	add	r0,r0
80005a92:	0c f8       	st.b	--r6,r8
80005a94:	00 00       	add	r0,r0
80005a96:	0d 14       	ld.sh	r4,r6++
80005a98:	00 00       	add	r0,r0
80005a9a:	0c cc       	st.b	r6++,r12
80005a9c:	00 00       	add	r0,r0
80005a9e:	0d 30       	ld.ub	r0,r6++
80005aa0:	00 00       	add	r0,r0
80005aa2:	0c 14       	sub	r4,r6
80005aa4:	00 00       	add	r0,r0
80005aa6:	0c c8       	st.b	r6++,r8
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	4e 2e       	lddpc	lr,80005c30 <prvIdleTask+0x3c>
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	4d de       	lddpc	lr,80005c20 <prvIdleTask+0x2c>
80005ab0:	00 00       	add	r0,r0
80005ab2:	0b f8       	ld.ub	r8,r5[0x7]
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	58 30       	cp.w	r0,3
80005ab8:	00 00       	add	r0,r0
80005aba:	0d 18       	ld.sh	r8,r6++
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	4f f4       	lddpc	r4,80005cb8 <xTaskGenericCreate+0x3c>

80005ac0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005ac0:	eb cd 40 80 	pushm	r7,lr
80005ac4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005ac6:	49 08       	lddpc	r8,80005b04 <prvAddCurrentTaskToDelayedList+0x44>
80005ac8:	70 08       	ld.w	r8,r8[0x0]
80005aca:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005acc:	48 f8       	lddpc	r8,80005b08 <prvAddCurrentTaskToDelayedList+0x48>
80005ace:	70 08       	ld.w	r8,r8[0x0]
80005ad0:	10 3c       	cp.w	r12,r8
80005ad2:	c0 a2       	brcc	80005ae6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ad4:	48 c8       	lddpc	r8,80005b04 <prvAddCurrentTaskToDelayedList+0x44>
80005ad6:	70 0b       	ld.w	r11,r8[0x0]
80005ad8:	48 d8       	lddpc	r8,80005b0c <prvAddCurrentTaskToDelayedList+0x4c>
80005ada:	70 0c       	ld.w	r12,r8[0x0]
80005adc:	2f cb       	sub	r11,-4
80005ade:	f0 1f 00 0d 	mcall	80005b10 <prvAddCurrentTaskToDelayedList+0x50>
80005ae2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ae6:	48 88       	lddpc	r8,80005b04 <prvAddCurrentTaskToDelayedList+0x44>
80005ae8:	70 0b       	ld.w	r11,r8[0x0]
80005aea:	48 b8       	lddpc	r8,80005b14 <prvAddCurrentTaskToDelayedList+0x54>
80005aec:	70 0c       	ld.w	r12,r8[0x0]
80005aee:	2f cb       	sub	r11,-4
80005af0:	f0 1f 00 08 	mcall	80005b10 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005af4:	48 98       	lddpc	r8,80005b18 <prvAddCurrentTaskToDelayedList+0x58>
80005af6:	70 08       	ld.w	r8,r8[0x0]
80005af8:	10 37       	cp.w	r7,r8
80005afa:	c0 32       	brcc	80005b00 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005afc:	48 78       	lddpc	r8,80005b18 <prvAddCurrentTaskToDelayedList+0x58>
80005afe:	91 07       	st.w	r8[0x0],r7
80005b00:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b04:	00 00       	add	r0,r0
80005b06:	0c c8       	st.b	r6++,r8
80005b08:	00 00       	add	r0,r0
80005b0a:	0c f4       	st.b	--r6,r4
80005b0c:	00 00       	add	r0,r0
80005b0e:	0c 10       	sub	r0,r6
80005b10:	80 00       	ld.sh	r0,r0[0x0]
80005b12:	4d fa       	lddpc	r10,80005c8c <xTaskGenericCreate+0x10>
80005b14:	00 00       	add	r0,r0
80005b16:	0c 00       	add	r0,r6
80005b18:	00 00       	add	r0,r0
80005b1a:	05 28       	ld.uh	r8,r2++

80005b1c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005b1c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b20:	18 96       	mov	r6,r12
80005b22:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005b24:	f0 1f 00 18 	mcall	80005b84 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005b28:	6c 08       	ld.w	r8,r6[0x0]
80005b2a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005b2c:	49 79       	lddpc	r9,80005b88 <vTaskDelayUntil+0x6c>
80005b2e:	72 09       	ld.w	r9,r9[0x0]
80005b30:	12 38       	cp.w	r8,r9
80005b32:	e0 88 00 0c 	brls	80005b4a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005b36:	0e 38       	cp.w	r8,r7
80005b38:	e0 88 00 22 	brls	80005b7c <vTaskDelayUntil+0x60>
80005b3c:	49 38       	lddpc	r8,80005b88 <vTaskDelayUntil+0x6c>
80005b3e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b40:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005b42:	10 37       	cp.w	r7,r8
80005b44:	e0 88 00 14 	brls	80005b6c <vTaskDelayUntil+0x50>
80005b48:	c0 a8       	rjmp	80005b5c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005b4a:	0e 38       	cp.w	r8,r7
80005b4c:	e0 8b 00 16 	brhi	80005b78 <vTaskDelayUntil+0x5c>
80005b50:	48 e8       	lddpc	r8,80005b88 <vTaskDelayUntil+0x6c>
80005b52:	70 08       	ld.w	r8,r8[0x0]
80005b54:	10 37       	cp.w	r7,r8
80005b56:	e0 8b 00 11 	brhi	80005b78 <vTaskDelayUntil+0x5c>
80005b5a:	c1 18       	rjmp	80005b7c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b5c:	48 c8       	lddpc	r8,80005b8c <vTaskDelayUntil+0x70>
80005b5e:	70 0c       	ld.w	r12,r8[0x0]
80005b60:	2f cc       	sub	r12,-4
80005b62:	f0 1f 00 0c 	mcall	80005b90 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005b66:	0e 9c       	mov	r12,r7
80005b68:	f0 1f 00 0b 	mcall	80005b94 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005b6c:	f0 1f 00 0b 	mcall	80005b98 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005b70:	c0 81       	brne	80005b80 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005b72:	d7 33       	scall
80005b74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b78:	8d 07       	st.w	r6[0x0],r7
80005b7a:	cf 1b       	rjmp	80005b5c <vTaskDelayUntil+0x40>
80005b7c:	8d 07       	st.w	r6[0x0],r7
80005b7e:	cf 7b       	rjmp	80005b6c <vTaskDelayUntil+0x50>
80005b80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b84:	80 00       	ld.sh	r0,r0[0x0]
80005b86:	56 1c       	stdsp	sp[0x184],r12
80005b88:	00 00       	add	r0,r0
80005b8a:	0c f4       	st.b	--r6,r4
80005b8c:	00 00       	add	r0,r0
80005b8e:	0c c8       	st.b	r6++,r8
80005b90:	80 00       	ld.sh	r0,r0[0x0]
80005b92:	4e 2e       	lddpc	lr,80005d18 <xTaskGenericCreate+0x9c>
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	5a c0       	cp.w	r0,-20
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	59 d8       	cp.w	r8,29

80005b9c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005b9c:	eb cd 40 c0 	pushm	r6-r7,lr
80005ba0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005ba2:	48 e7       	lddpc	r7,80005bd8 <vTaskPlaceOnEventList+0x3c>
80005ba4:	6e 0b       	ld.w	r11,r7[0x0]
80005ba6:	2e 8b       	sub	r11,-24
80005ba8:	f0 1f 00 0d 	mcall	80005bdc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005bac:	6e 0c       	ld.w	r12,r7[0x0]
80005bae:	2f cc       	sub	r12,-4
80005bb0:	f0 1f 00 0c 	mcall	80005be0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005bb4:	5b f6       	cp.w	r6,-1
80005bb6:	c0 81       	brne	80005bc6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005bb8:	6e 0b       	ld.w	r11,r7[0x0]
80005bba:	2f cb       	sub	r11,-4
80005bbc:	48 ac       	lddpc	r12,80005be4 <vTaskPlaceOnEventList+0x48>
80005bbe:	f0 1f 00 0b 	mcall	80005be8 <vTaskPlaceOnEventList+0x4c>
80005bc2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005bc6:	48 a8       	lddpc	r8,80005bec <vTaskPlaceOnEventList+0x50>
80005bc8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005bca:	ec 0c 00 0c 	add	r12,r6,r12
80005bce:	f0 1f 00 09 	mcall	80005bf0 <vTaskPlaceOnEventList+0x54>
80005bd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bd6:	00 00       	add	r0,r0
80005bd8:	00 00       	add	r0,r0
80005bda:	0c c8       	st.b	r6++,r8
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	4d fa       	lddpc	r10,80005d58 <xTaskGenericCreate+0xdc>
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	4e 2e       	lddpc	lr,80005d68 <xTaskGenericCreate+0xec>
80005be4:	00 00       	add	r0,r0
80005be6:	0d 1c       	ld.sh	r12,r6++
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	4d de       	lddpc	lr,80005d5c <xTaskGenericCreate+0xe0>
80005bec:	00 00       	add	r0,r0
80005bee:	0c f4       	st.b	--r6,r4
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	5a c0       	cp.w	r0,-20

80005bf4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005bf4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005bf8:	49 67       	lddpc	r7,80005c50 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005bfa:	49 74       	lddpc	r4,80005c54 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005bfc:	49 73       	lddpc	r3,80005c58 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005bfe:	49 85       	lddpc	r5,80005c5c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005c00:	6e 08       	ld.w	r8,r7[0x0]
80005c02:	58 08       	cp.w	r8,0
80005c04:	c1 e0       	breq	80005c40 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005c06:	f0 1f 00 17 	mcall	80005c60 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005c0a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005c0c:	f0 1f 00 16 	mcall	80005c64 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005c10:	58 06       	cp.w	r6,0
80005c12:	c1 70       	breq	80005c40 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005c14:	f0 1f 00 15 	mcall	80005c68 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005c18:	68 38       	ld.w	r8,r4[0xc]
80005c1a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c1c:	ec cc ff fc 	sub	r12,r6,-4
80005c20:	f0 1f 00 13 	mcall	80005c6c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005c24:	66 08       	ld.w	r8,r3[0x0]
80005c26:	20 18       	sub	r8,1
80005c28:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005c2a:	6e 08       	ld.w	r8,r7[0x0]
80005c2c:	20 18       	sub	r8,1
80005c2e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005c30:	f0 1f 00 10 	mcall	80005c70 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005c34:	6c cc       	ld.w	r12,r6[0x30]
80005c36:	f0 1f 00 10 	mcall	80005c74 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005c3a:	0c 9c       	mov	r12,r6
80005c3c:	f0 1f 00 0e 	mcall	80005c74 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005c40:	6a 08       	ld.w	r8,r5[0x0]
80005c42:	58 18       	cp.w	r8,1
80005c44:	e0 88 00 03 	brls	80005c4a <prvIdleTask+0x56>
			{
				taskYIELD();
80005c48:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005c4a:	f0 1f 00 0c 	mcall	80005c78 <prvIdleTask+0x84>
		}
		#endif
	}
80005c4e:	cd 9b       	rjmp	80005c00 <prvIdleTask+0xc>
80005c50:	00 00       	add	r0,r0
80005c52:	0c 08       	add	r8,r6
80005c54:	00 00       	add	r0,r0
80005c56:	0c b4       	st.h	r6++,r4
80005c58:	00 00       	add	r0,r0
80005c5a:	0d 14       	ld.sh	r4,r6++
80005c5c:	00 00       	add	r0,r0
80005c5e:	0c 14       	sub	r4,r6
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	56 1c       	stdsp	sp[0x184],r12
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	59 d8       	cp.w	r8,29
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	4e e8       	lddpc	r8,80005e20 <xTaskGenericCreate+0x1a4>
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	4e 2e       	lddpc	lr,80005df4 <xTaskGenericCreate+0x178>
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	4f f4       	lddpc	r4,80005e6c <vTaskStartScheduler+0x8>
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	51 2c       	stdsp	sp[0x48],r12
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	20 2c       	sub	r12,2

80005c7c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005c7c:	d4 31       	pushm	r0-r7,lr
80005c7e:	20 1d       	sub	sp,4
80005c80:	fa c4 ff d8 	sub	r4,sp,-40
80005c84:	50 0c       	stdsp	sp[0x0],r12
80005c86:	16 91       	mov	r1,r11
80005c88:	14 97       	mov	r7,r10
80005c8a:	12 90       	mov	r0,r9
80005c8c:	10 93       	mov	r3,r8
80005c8e:	68 02       	ld.w	r2,r4[0x0]
80005c90:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005c92:	34 8c       	mov	r12,72
80005c94:	f0 1f 00 5c 	mcall	80005e04 <xTaskGenericCreate+0x188>
80005c98:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005c9a:	c0 31       	brne	80005ca0 <xTaskGenericCreate+0x24>
80005c9c:	3f fc       	mov	r12,-1
80005c9e:	ca f8       	rjmp	80005dfc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ca0:	58 06       	cp.w	r6,0
80005ca2:	e0 81 00 af 	brne	80005e00 <xTaskGenericCreate+0x184>
80005ca6:	0e 9c       	mov	r12,r7
80005ca8:	5c 7c       	castu.h	r12
80005caa:	a3 6c       	lsl	r12,0x2
80005cac:	f0 1f 00 56 	mcall	80005e04 <xTaskGenericCreate+0x188>
80005cb0:	18 96       	mov	r6,r12
80005cb2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005cb4:	c0 61       	brne	80005cc0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005cb6:	0a 9c       	mov	r12,r5
80005cb8:	f0 1f 00 54 	mcall	80005e08 <xTaskGenericCreate+0x18c>
80005cbc:	3f fc       	mov	r12,-1
80005cbe:	c9 f8       	rjmp	80005dfc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005cc0:	5c 77       	castu.h	r7
80005cc2:	ee 0a 15 02 	lsl	r10,r7,0x2
80005cc6:	e0 6b 00 a5 	mov	r11,165
80005cca:	0c 9c       	mov	r12,r6
80005ccc:	f0 1f 00 50 	mcall	80005e0c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005cd0:	ee c6 00 01 	sub	r6,r7,1
80005cd4:	6a c8       	ld.w	r8,r5[0x30]
80005cd6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005cda:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005cde:	31 0a       	mov	r10,16
80005ce0:	02 9b       	mov	r11,r1
80005ce2:	ea cc ff cc 	sub	r12,r5,-52
80005ce6:	f0 1f 00 4b 	mcall	80005e10 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005cea:	30 08       	mov	r8,0
80005cec:	eb 68 00 43 	st.b	r5[67],r8
80005cf0:	58 73       	cp.w	r3,7
80005cf2:	e6 07 17 80 	movls	r7,r3
80005cf6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005cfa:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005cfc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005d00:	ea c4 ff fc 	sub	r4,r5,-4
80005d04:	08 9c       	mov	r12,r4
80005d06:	f0 1f 00 44 	mcall	80005e14 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005d0a:	ea cc ff e8 	sub	r12,r5,-24
80005d0e:	f0 1f 00 42 	mcall	80005e14 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005d12:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005d14:	ee 07 11 08 	rsub	r7,r7,8
80005d18:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005d1a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005d1c:	00 9a       	mov	r10,r0
80005d1e:	40 0b       	lddsp	r11,sp[0x0]
80005d20:	0c 9c       	mov	r12,r6
80005d22:	f0 1f 00 3e 	mcall	80005e18 <xTaskGenericCreate+0x19c>
80005d26:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005d28:	58 02       	cp.w	r2,0
80005d2a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005d2e:	f0 1f 00 3c 	mcall	80005e1c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005d32:	4b c8       	lddpc	r8,80005e20 <xTaskGenericCreate+0x1a4>
80005d34:	70 09       	ld.w	r9,r8[0x0]
80005d36:	2f f9       	sub	r9,-1
80005d38:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005d3a:	4b b8       	lddpc	r8,80005e24 <xTaskGenericCreate+0x1a8>
80005d3c:	70 08       	ld.w	r8,r8[0x0]
80005d3e:	58 08       	cp.w	r8,0
80005d40:	c2 61       	brne	80005d8c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005d42:	4b 98       	lddpc	r8,80005e24 <xTaskGenericCreate+0x1a8>
80005d44:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005d46:	4b 78       	lddpc	r8,80005e20 <xTaskGenericCreate+0x1a4>
80005d48:	70 08       	ld.w	r8,r8[0x0]
80005d4a:	58 18       	cp.w	r8,1
80005d4c:	c2 b1       	brne	80005da2 <xTaskGenericCreate+0x126>
80005d4e:	4b 77       	lddpc	r7,80005e28 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005d50:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005d54:	0e 9c       	mov	r12,r7
80005d56:	f0 1f 00 36 	mcall	80005e2c <xTaskGenericCreate+0x1b0>
80005d5a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005d5c:	0c 37       	cp.w	r7,r6
80005d5e:	cf b1       	brne	80005d54 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005d60:	4b 47       	lddpc	r7,80005e30 <xTaskGenericCreate+0x1b4>
80005d62:	0e 9c       	mov	r12,r7
80005d64:	f0 1f 00 32 	mcall	80005e2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005d68:	4b 36       	lddpc	r6,80005e34 <xTaskGenericCreate+0x1b8>
80005d6a:	0c 9c       	mov	r12,r6
80005d6c:	f0 1f 00 30 	mcall	80005e2c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005d70:	4b 2c       	lddpc	r12,80005e38 <xTaskGenericCreate+0x1bc>
80005d72:	f0 1f 00 2f 	mcall	80005e2c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005d76:	4b 2c       	lddpc	r12,80005e3c <xTaskGenericCreate+0x1c0>
80005d78:	f0 1f 00 2d 	mcall	80005e2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005d7c:	4b 1c       	lddpc	r12,80005e40 <xTaskGenericCreate+0x1c4>
80005d7e:	f0 1f 00 2c 	mcall	80005e2c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005d82:	4b 18       	lddpc	r8,80005e44 <xTaskGenericCreate+0x1c8>
80005d84:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005d86:	4b 18       	lddpc	r8,80005e48 <xTaskGenericCreate+0x1cc>
80005d88:	91 06       	st.w	r8[0x0],r6
80005d8a:	c0 c8       	rjmp	80005da2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005d8c:	4b 08       	lddpc	r8,80005e4c <xTaskGenericCreate+0x1d0>
80005d8e:	70 08       	ld.w	r8,r8[0x0]
80005d90:	58 08       	cp.w	r8,0
80005d92:	c0 81       	brne	80005da2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005d94:	4a 48       	lddpc	r8,80005e24 <xTaskGenericCreate+0x1a8>
80005d96:	70 08       	ld.w	r8,r8[0x0]
80005d98:	70 b8       	ld.w	r8,r8[0x2c]
80005d9a:	10 33       	cp.w	r3,r8
80005d9c:	c0 33       	brcs	80005da2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005d9e:	4a 28       	lddpc	r8,80005e24 <xTaskGenericCreate+0x1a8>
80005da0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005da2:	6a b8       	ld.w	r8,r5[0x2c]
80005da4:	4a b9       	lddpc	r9,80005e50 <xTaskGenericCreate+0x1d4>
80005da6:	72 09       	ld.w	r9,r9[0x0]
80005da8:	12 38       	cp.w	r8,r9
80005daa:	e0 88 00 04 	brls	80005db2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005dae:	4a 99       	lddpc	r9,80005e50 <xTaskGenericCreate+0x1d4>
80005db0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005db2:	4a 98       	lddpc	r8,80005e54 <xTaskGenericCreate+0x1d8>
80005db4:	70 09       	ld.w	r9,r8[0x0]
80005db6:	2f f9       	sub	r9,-1
80005db8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005dba:	6a b8       	ld.w	r8,r5[0x2c]
80005dbc:	4a 79       	lddpc	r9,80005e58 <xTaskGenericCreate+0x1dc>
80005dbe:	72 09       	ld.w	r9,r9[0x0]
80005dc0:	12 38       	cp.w	r8,r9
80005dc2:	e0 88 00 04 	brls	80005dca <xTaskGenericCreate+0x14e>
80005dc6:	4a 59       	lddpc	r9,80005e58 <xTaskGenericCreate+0x1dc>
80005dc8:	93 08       	st.w	r9[0x0],r8
80005dca:	6a bc       	ld.w	r12,r5[0x2c]
80005dcc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005dd0:	08 9b       	mov	r11,r4
80005dd2:	49 68       	lddpc	r8,80005e28 <xTaskGenericCreate+0x1ac>
80005dd4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005dd8:	f0 1f 00 21 	mcall	80005e5c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005ddc:	f0 1f 00 21 	mcall	80005e60 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005de0:	49 b8       	lddpc	r8,80005e4c <xTaskGenericCreate+0x1d0>
80005de2:	70 08       	ld.w	r8,r8[0x0]
80005de4:	58 08       	cp.w	r8,0
80005de6:	c0 a0       	breq	80005dfa <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005de8:	48 f8       	lddpc	r8,80005e24 <xTaskGenericCreate+0x1a8>
80005dea:	70 08       	ld.w	r8,r8[0x0]
80005dec:	70 b8       	ld.w	r8,r8[0x2c]
80005dee:	10 33       	cp.w	r3,r8
80005df0:	e0 88 00 05 	brls	80005dfa <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005df4:	d7 33       	scall
80005df6:	30 1c       	mov	r12,1
80005df8:	c0 28       	rjmp	80005dfc <xTaskGenericCreate+0x180>
80005dfa:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005dfc:	2f fd       	sub	sp,-4
80005dfe:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005e00:	99 c6       	st.w	r12[0x30],r6
80005e02:	c5 fb       	rjmp	80005cc0 <xTaskGenericCreate+0x44>
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	51 54       	stdsp	sp[0x54],r4
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	51 2c       	stdsp	sp[0x48],r12
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	6a 14       	ld.w	r4,r5[0x4]
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	6d 40       	ld.w	r0,r6[0x50]
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	4d d8       	lddpc	r8,80005f88 <PrintDec+0x22>
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	4e 54       	lddpc	r4,80005fac <PrintDec+0x46>
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	4e e8       	lddpc	r8,80005fd4 <PrintDec+0x6e>
80005e20:	00 00       	add	r0,r0
80005e22:	0d 14       	ld.sh	r4,r6++
80005e24:	00 00       	add	r0,r0
80005e26:	0c c8       	st.b	r6++,r8
80005e28:	00 00       	add	r0,r0
80005e2a:	0c 14       	sub	r4,r6
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	4d c4       	lddpc	r4,80005f9c <PrintDec+0x36>
80005e30:	00 00       	add	r0,r0
80005e32:	0c e0       	st.h	--r6,r0
80005e34:	00 00       	add	r0,r0
80005e36:	0c fc       	st.b	--r6,r12
80005e38:	00 00       	add	r0,r0
80005e3a:	0c cc       	st.b	r6++,r12
80005e3c:	00 00       	add	r0,r0
80005e3e:	0c b4       	st.h	r6++,r4
80005e40:	00 00       	add	r0,r0
80005e42:	0d 1c       	ld.sh	r12,r6++
80005e44:	00 00       	add	r0,r0
80005e46:	0c 00       	add	r0,r6
80005e48:	00 00       	add	r0,r0
80005e4a:	0c 10       	sub	r0,r6
80005e4c:	00 00       	add	r0,r0
80005e4e:	0c 04       	add	r4,r6
80005e50:	00 00       	add	r0,r0
80005e52:	0b fc       	ld.ub	r12,r5[0x7]
80005e54:	00 00       	add	r0,r0
80005e56:	0d 10       	ld.sh	r0,r6++
80005e58:	00 00       	add	r0,r0
80005e5a:	0d 30       	ld.ub	r0,r6++
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	4d de       	lddpc	lr,80005fd0 <PrintDec+0x6a>
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	4f f4       	lddpc	r4,8000605c <log+0x1c>

80005e64 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005e64:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005e66:	30 09       	mov	r9,0
80005e68:	1a d9       	st.w	--sp,r9
80005e6a:	1a d9       	st.w	--sp,r9
80005e6c:	1a d9       	st.w	--sp,r9
80005e6e:	12 98       	mov	r8,r9
80005e70:	e0 6a 01 00 	mov	r10,256
80005e74:	48 9b       	lddpc	r11,80005e98 <vTaskStartScheduler+0x34>
80005e76:	48 ac       	lddpc	r12,80005e9c <vTaskStartScheduler+0x38>
80005e78:	f0 1f 00 0a 	mcall	80005ea0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005e7c:	2f dd       	sub	sp,-12
80005e7e:	58 1c       	cp.w	r12,1
80005e80:	c0 a1       	brne	80005e94 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005e82:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005e84:	30 19       	mov	r9,1
80005e86:	48 88       	lddpc	r8,80005ea4 <vTaskStartScheduler+0x40>
80005e88:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005e8a:	30 09       	mov	r9,0
80005e8c:	48 78       	lddpc	r8,80005ea8 <vTaskStartScheduler+0x44>
80005e8e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005e90:	f0 1f 00 07 	mcall	80005eac <vTaskStartScheduler+0x48>
80005e94:	d8 02       	popm	pc
80005e96:	00 00       	add	r0,r0
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	c8 70       	breq	80005da8 <xTaskGenericCreate+0x12c>
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	5b f4       	cp.w	r4,-1
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	5c 7c       	castu.h	r12
80005ea4:	00 00       	add	r0,r0
80005ea6:	0c 04       	add	r4,r6
80005ea8:	00 00       	add	r0,r0
80005eaa:	0c f4       	st.b	--r6,r4
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	4e f8       	lddpc	r8,80006068 <log+0x28>

80005eb0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005eb0:	16 cc       	st.b	r11++,r12
	return str;
}
80005eb2:	5e fb       	retal	r11

80005eb4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005eb4:	eb cd 40 c0 	pushm	r6-r7,lr
80005eb8:	20 3d       	sub	sp,12
80005eba:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005ebc:	30 06       	mov	r6,0
80005ebe:	30 07       	mov	r7,0
80005ec0:	fa e7 00 00 	st.d	sp[0],r6
80005ec4:	30 0c       	mov	r12,0
80005ec6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005ec8:	58 08       	cp.w	r8,0
80005eca:	c1 30       	breq	80005ef0 <PrintHex+0x3c>
80005ecc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005ece:	1a 9c       	mov	r12,sp
80005ed0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005ed4:	58 9e       	cp.w	lr,9
80005ed6:	e0 8a 00 04 	brle	80005ede <PrintHex+0x2a>
80005eda:	2c 9e       	sub	lr,-55
80005edc:	c0 48       	rjmp	80005ee4 <PrintHex+0x30>
80005ede:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005ee2:	2d 0e       	sub	lr,-48
80005ee4:	f8 09 0b 0e 	st.b	r12[r9],lr
80005ee8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005eea:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005eec:	cf 21       	brne	80005ed0 <PrintHex+0x1c>
80005eee:	c0 48       	rjmp	80005ef6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005ef0:	33 08       	mov	r8,48
80005ef2:	ba 88       	st.b	sp[0x0],r8
80005ef4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005ef6:	f6 09 01 08 	sub	r8,r11,r9
80005efa:	58 08       	cp.w	r8,0
80005efc:	e0 8a 00 13 	brle	80005f22 <PrintHex+0x6e>
	{
		char num = len - cnt;
80005f00:	12 1b       	sub	r11,r9
80005f02:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005f06:	18 9e       	mov	lr,r12
80005f08:	58 0c       	cp.w	r12,0
80005f0a:	e0 8a 00 0c 	brle	80005f22 <PrintHex+0x6e>
80005f0e:	1a 9b       	mov	r11,sp
80005f10:	12 0b       	add	r11,r9
80005f12:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005f14:	33 07       	mov	r7,48
80005f16:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005f18:	2f f8       	sub	r8,-1
80005f1a:	1c 38       	cp.w	r8,lr
80005f1c:	cf d5       	brlt	80005f16 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005f1e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005f22:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005f26:	f0 cb ff ff 	sub	r11,r8,-1
80005f2a:	58 0b       	cp.w	r11,0
80005f2c:	e0 8a 00 19 	brle	80005f5e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005f30:	fa cb ff f4 	sub	r11,sp,-12
80005f34:	f6 09 00 09 	add	r9,r11,r9
80005f38:	37 8b       	mov	r11,120
80005f3a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005f3e:	fa c9 ff f4 	sub	r9,sp,-12
80005f42:	10 09       	add	r9,r8
80005f44:	33 0b       	mov	r11,48
80005f46:	f3 6b ff f4 	st.b	r9[-12],r11
80005f4a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005f4e:	fa ce 00 01 	sub	lr,sp,1
80005f52:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005f54:	11 8b       	ld.ub	r11,r8[0x0]
80005f56:	12 cb       	st.b	r9++,r11
80005f58:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005f5a:	1c 38       	cp.w	r8,lr
80005f5c:	cf c1       	brne	80005f54 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005f5e:	14 9c       	mov	r12,r10
80005f60:	2f dd       	sub	sp,-12
80005f62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005f66 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005f66:	d4 21       	pushm	r4-r7,lr
80005f68:	20 3d       	sub	sp,12
80005f6a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005f6c:	30 06       	mov	r6,0
80005f6e:	30 07       	mov	r7,0
80005f70:	fa e7 00 00 	st.d	sp[0],r6
80005f74:	30 0c       	mov	r12,0
80005f76:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005f78:	58 08       	cp.w	r8,0
80005f7a:	c0 35       	brlt	80005f80 <PrintDec+0x1a>
80005f7c:	14 97       	mov	r7,r10
80005f7e:	c0 58       	rjmp	80005f88 <PrintDec+0x22>
	{
		*p++ = '-';
80005f80:	14 97       	mov	r7,r10
80005f82:	32 d9       	mov	r9,45
80005f84:	0e c9       	st.b	r7++,r9
		i = -i;
80005f86:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005f88:	58 08       	cp.w	r8,0
80005f8a:	c0 51       	brne	80005f94 <PrintDec+0x2e>
80005f8c:	33 08       	mov	r8,48
80005f8e:	ba 88       	st.b	sp[0x0],r8
80005f90:	30 1e       	mov	lr,1
80005f92:	c2 f8       	rjmp	80005ff0 <PrintDec+0x8a>
	
	int ten = i%10;
80005f94:	e0 65 66 67 	mov	r5,26215
80005f98:	ea 15 66 66 	orh	r5,0x6666
80005f9c:	f0 05 04 44 	muls.d	r4,r8,r5
80005fa0:	ea 0c 14 02 	asr	r12,r5,0x2
80005fa4:	f0 09 14 1f 	asr	r9,r8,0x1f
80005fa8:	f8 09 01 09 	sub	r9,r12,r9
80005fac:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fb0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005fb4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005fb6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005fb8:	e0 66 66 67 	mov	r6,26215
80005fbc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005fc0:	2d 09       	sub	r9,-48
80005fc2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005fc6:	2f fe       	sub	lr,-1
		i /= 10;
80005fc8:	f0 06 04 44 	muls.d	r4,r8,r6
80005fcc:	ea 09 14 02 	asr	r9,r5,0x2
80005fd0:	bf 58       	asr	r8,0x1f
80005fd2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005fd6:	f0 06 04 44 	muls.d	r4,r8,r6
80005fda:	ea 09 14 02 	asr	r9,r5,0x2
80005fde:	f0 05 14 1f 	asr	r5,r8,0x1f
80005fe2:	0a 19       	sub	r9,r5
80005fe4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fe8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005fec:	58 08       	cp.w	r8,0
80005fee:	ce 91       	brne	80005fc0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005ff0:	f6 0e 01 08 	sub	r8,r11,lr
80005ff4:	58 08       	cp.w	r8,0
80005ff6:	e0 89 00 06 	brgt	80006002 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005ffa:	58 0e       	cp.w	lr,0
80005ffc:	e0 89 00 14 	brgt	80006024 <PrintDec+0xbe>
80006000:	c1 d8       	rjmp	8000603a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006002:	1c 1b       	sub	r11,lr
80006004:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006006:	16 9c       	mov	r12,r11
80006008:	58 0b       	cp.w	r11,0
8000600a:	fe 9a ff f8 	brle	80005ffa <PrintDec+0x94>
8000600e:	1a 99       	mov	r9,sp
80006010:	1c 09       	add	r9,lr
80006012:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006014:	33 06       	mov	r6,48
80006016:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006018:	2f f8       	sub	r8,-1
8000601a:	18 38       	cp.w	r8,r12
8000601c:	cf d5       	brlt	80006016 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000601e:	f6 0e 00 0e 	add	lr,r11,lr
80006022:	ce cb       	rjmp	80005ffa <PrintDec+0x94>
80006024:	fa c8 ff f4 	sub	r8,sp,-12
80006028:	1c 08       	add	r8,lr
8000602a:	20 d8       	sub	r8,13
8000602c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006030:	11 89       	ld.ub	r9,r8[0x0]
80006032:	0e c9       	st.b	r7++,r9
80006034:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006036:	16 38       	cp.w	r8,r11
80006038:	cf c1       	brne	80006030 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000603a:	14 9c       	mov	r12,r10
8000603c:	2f dd       	sub	sp,-12
8000603e:	d8 22       	popm	r4-r7,pc

80006040 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006040:	d4 31       	pushm	r0-r7,lr
80006042:	fa cd 02 08 	sub	sp,sp,520
80006046:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006048:	e0 6a 01 00 	mov	r10,256
8000604c:	30 0b       	mov	r11,0
8000604e:	fa cc fe f8 	sub	r12,sp,-264
80006052:	f0 1f 00 4e 	mcall	80006188 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006056:	fa c4 fd d4 	sub	r4,sp,-556
8000605a:	30 0a       	mov	r10,0
8000605c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000605e:	fa c3 ff fc 	sub	r3,sp,-4
80006062:	e0 61 01 00 	mov	r1,256
80006066:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006068:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000606a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000606e:	02 9a       	mov	r10,r1
80006070:	00 9b       	mov	r11,r0
80006072:	06 9c       	mov	r12,r3
80006074:	f0 1f 00 45 	mcall	80006188 <log+0x148>
			
					if(*str == '%')
80006078:	0f 88       	ld.ub	r8,r7[0x0]
8000607a:	e4 08 18 00 	cp.b	r8,r2
8000607e:	c5 71       	brne	8000612c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006080:	ee c8 ff ff 	sub	r8,r7,-1
80006084:	11 89       	ld.ub	r9,r8[0x0]
80006086:	4c 2a       	lddpc	r10,8000618c <log+0x14c>
80006088:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000608a:	23 09       	sub	r9,48
8000608c:	30 9a       	mov	r10,9
8000608e:	f4 09 18 00 	cp.b	r9,r10
80006092:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006096:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000609a:	f7 b9 08 30 	subls	r9,48
8000609e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800060a2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800060a6:	0f 88       	ld.ub	r8,r7[0x0]
800060a8:	22 58       	sub	r8,37
800060aa:	e0 48 00 53 	cp.w	r8,83
800060ae:	e0 8b 00 31 	brhi	80006110 <log+0xd0>
800060b2:	4b 89       	lddpc	r9,80006190 <log+0x150>
800060b4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800060b8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800060bc:	06 9a       	mov	r10,r3
800060be:	40 0b       	lddsp	r11,sp[0x0]
800060c0:	5c 5b       	castu.b	r11
800060c2:	68 0c       	ld.w	r12,r4[0x0]
800060c4:	f0 1f 00 34 	mcall	80006194 <log+0x154>
							break;
800060c8:	c2 98       	rjmp	8000611a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800060ca:	4b 4c       	lddpc	r12,80006198 <log+0x158>
800060cc:	f0 1f 00 34 	mcall	8000619c <log+0x15c>
800060d0:	08 95       	mov	r5,r4
800060d2:	06 9c       	mov	r12,r3
							break;
800060d4:	c2 38       	rjmp	8000611a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800060d6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800060da:	06 9a       	mov	r10,r3
800060dc:	40 0b       	lddsp	r11,sp[0x0]
800060de:	5c 5b       	castu.b	r11
800060e0:	68 0c       	ld.w	r12,r4[0x0]
800060e2:	f0 1f 00 30 	mcall	800061a0 <log+0x160>
800060e6:	06 9c       	mov	r12,r3
							break;
800060e8:	c1 98       	rjmp	8000611a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800060ea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800060ee:	06 9b       	mov	r11,r3
800060f0:	09 bc       	ld.ub	r12,r4[0x3]
800060f2:	f0 1f 00 2d 	mcall	800061a4 <log+0x164>
800060f6:	06 9c       	mov	r12,r3
							break;
800060f8:	c1 18       	rjmp	8000611a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800060fa:	e8 c5 ff fc 	sub	r5,r4,-4
800060fe:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006100:	c0 d8       	rjmp	8000611a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006102:	06 9b       	mov	r11,r3
80006104:	32 5c       	mov	r12,37
80006106:	f0 1f 00 28 	mcall	800061a4 <log+0x164>
8000610a:	08 95       	mov	r5,r4
8000610c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000610e:	c0 68       	rjmp	8000611a <log+0xda>
							
							default:
							log("I need relax.");
80006110:	4a 6c       	lddpc	r12,800061a8 <log+0x168>
80006112:	f0 1f 00 23 	mcall	8000619c <log+0x15c>
80006116:	08 95       	mov	r5,r4
80006118:	06 9c       	mov	r12,r3
						}
						str++;
8000611a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000611c:	1a dc       	st.w	--sp,r12
8000611e:	1a d6       	st.w	--sp,r6
80006120:	4a 3b       	lddpc	r11,800061ac <log+0x16c>
80006122:	0c 9c       	mov	r12,r6
80006124:	f0 1f 00 23 	mcall	800061b0 <log+0x170>
80006128:	2f ed       	sub	sp,-8
8000612a:	c0 a8       	rjmp	8000613e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000612c:	2f f7       	sub	r7,-1
8000612e:	1a d8       	st.w	--sp,r8
80006130:	1a d6       	st.w	--sp,r6
80006132:	4a 1b       	lddpc	r11,800061b4 <log+0x174>
80006134:	0c 9c       	mov	r12,r6
80006136:	f0 1f 00 1f 	mcall	800061b0 <log+0x170>
8000613a:	08 95       	mov	r5,r4
8000613c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000613e:	0f 89       	ld.ub	r9,r7[0x0]
80006140:	30 08       	mov	r8,0
80006142:	f0 09 18 00 	cp.b	r9,r8
80006146:	c0 30       	breq	8000614c <log+0x10c>
80006148:	0a 94       	mov	r4,r5
8000614a:	c9 2b       	rjmp	8000606e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000614c:	fa c7 fe f8 	sub	r7,sp,-264
80006150:	1a d7       	st.w	--sp,r7
80006152:	49 ab       	lddpc	r11,800061b8 <log+0x178>
80006154:	0e 9c       	mov	r12,r7
80006156:	f0 1f 00 17 	mcall	800061b0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000615a:	5c 5c       	castu.b	r12
8000615c:	f8 c6 ff ff 	sub	r6,r12,-1
80006160:	0c 9c       	mov	r12,r6
80006162:	f0 1f 00 17 	mcall	800061bc <log+0x17c>
80006166:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006168:	0c 9a       	mov	r10,r6
8000616a:	0e 9b       	mov	r11,r7
8000616c:	f0 1f 00 15 	mcall	800061c0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006170:	30 09       	mov	r9,0
80006172:	30 5a       	mov	r10,5
80006174:	fa cb fe f8 	sub	r11,sp,-264
80006178:	49 38       	lddpc	r8,800061c4 <log+0x184>
8000617a:	70 0c       	ld.w	r12,r8[0x0]
8000617c:	f0 1f 00 13 	mcall	800061c8 <log+0x188>
80006180:	2f fd       	sub	sp,-4
	
	
}
80006182:	fe 3d fd f8 	sub	sp,-520
80006186:	d8 32       	popm	r0-r7,pc
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	6a 14       	ld.w	r4,r5[0x4]
8000618c:	00 00       	add	r0,r0
8000618e:	0d 34       	ld.ub	r4,r6++
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	c8 78       	rjmp	800062a0 <logFromISR+0xd4>
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	5f 66       	srmi	r6
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	cb 24       	brge	800060fe <log+0xbe>
8000619c:	80 00       	ld.sh	r0,r0[0x0]
8000619e:	60 40       	ld.w	r0,r0[0x10]
800061a0:	80 00       	ld.sh	r0,r0[0x0]
800061a2:	5e b4       	rethi	r4
800061a4:	80 00       	ld.sh	r0,r0[0x0]
800061a6:	5e b0       	rethi	r0
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	cb 34       	brge	80006110 <log+0xd0>
800061ac:	80 00       	ld.sh	r0,r0[0x0]
800061ae:	cb 44       	brge	80006116 <log+0xd6>
800061b0:	80 00       	ld.sh	r0,r0[0x0]
800061b2:	6d 04       	ld.w	r4,r6[0x40]
800061b4:	80 00       	ld.sh	r0,r0[0x0]
800061b6:	cb 4c       	rcall	8000631e <logFromISR+0x152>
800061b8:	80 00       	ld.sh	r0,r0[0x0]
800061ba:	cb 54       	brge	80006124 <log+0xe4>
800061bc:	80 00       	ld.sh	r0,r0[0x0]
800061be:	51 54       	stdsp	sp[0x54],r4
800061c0:	80 00       	ld.sh	r0,r0[0x0]
800061c2:	68 cc       	ld.w	r12,r4[0x30]
800061c4:	00 00       	add	r0,r0
800061c6:	40 ec       	lddsp	r12,sp[0x38]
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	54 a8       	stdsp	sp[0x128],r8

800061cc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800061cc:	d4 31       	pushm	r0-r7,lr
800061ce:	fa cd 02 0c 	sub	sp,sp,524
800061d2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800061d4:	e0 6a 01 00 	mov	r10,256
800061d8:	30 0b       	mov	r11,0
800061da:	fa cc fe f4 	sub	r12,sp,-268
800061de:	f0 1f 00 4c 	mcall	8000630c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800061e2:	fa c4 fd d0 	sub	r4,sp,-560
800061e6:	30 0a       	mov	r10,0
800061e8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061ea:	fa c3 ff fc 	sub	r3,sp,-4
800061ee:	e0 61 01 00 	mov	r1,256
800061f2:	14 90       	mov	r0,r10
			
			if(*str == '%')
800061f4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800061f6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800061fa:	02 9a       	mov	r10,r1
800061fc:	00 9b       	mov	r11,r0
800061fe:	06 9c       	mov	r12,r3
80006200:	f0 1f 00 43 	mcall	8000630c <logFromISR+0x140>
			
			if(*str == '%')
80006204:	0f 88       	ld.ub	r8,r7[0x0]
80006206:	e4 08 18 00 	cp.b	r8,r2
8000620a:	c5 11       	brne	800062ac <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000620c:	ee c8 ff ff 	sub	r8,r7,-1
80006210:	11 89       	ld.ub	r9,r8[0x0]
80006212:	4c 0a       	lddpc	r10,80006310 <logFromISR+0x144>
80006214:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006216:	23 09       	sub	r9,48
80006218:	30 9a       	mov	r10,9
8000621a:	f4 09 18 00 	cp.b	r9,r10
8000621e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006222:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006226:	f7 b9 08 30 	subls	r9,48
8000622a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000622e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006232:	0f 88       	ld.ub	r8,r7[0x0]
80006234:	22 58       	sub	r8,37
80006236:	e0 48 00 53 	cp.w	r8,83
8000623a:	e0 8b 00 2b 	brhi	80006290 <logFromISR+0xc4>
8000623e:	4b 69       	lddpc	r9,80006314 <logFromISR+0x148>
80006240:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006244:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006248:	06 9a       	mov	r10,r3
8000624a:	40 0b       	lddsp	r11,sp[0x0]
8000624c:	5c 5b       	castu.b	r11
8000624e:	68 0c       	ld.w	r12,r4[0x0]
80006250:	f0 1f 00 32 	mcall	80006318 <logFromISR+0x14c>
					break;
80006254:	c2 38       	rjmp	8000629a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006256:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000625a:	06 9a       	mov	r10,r3
8000625c:	40 0b       	lddsp	r11,sp[0x0]
8000625e:	5c 5b       	castu.b	r11
80006260:	68 0c       	ld.w	r12,r4[0x0]
80006262:	f0 1f 00 2f 	mcall	8000631c <logFromISR+0x150>
80006266:	06 9c       	mov	r12,r3
					break;
80006268:	c1 98       	rjmp	8000629a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000626a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000626e:	06 9b       	mov	r11,r3
80006270:	09 bc       	ld.ub	r12,r4[0x3]
80006272:	f0 1f 00 2c 	mcall	80006320 <logFromISR+0x154>
80006276:	06 9c       	mov	r12,r3
					break;
80006278:	c1 18       	rjmp	8000629a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000627a:	e8 c5 ff fc 	sub	r5,r4,-4
8000627e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006280:	c0 d8       	rjmp	8000629a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006282:	06 9b       	mov	r11,r3
80006284:	32 5c       	mov	r12,37
80006286:	f0 1f 00 27 	mcall	80006320 <logFromISR+0x154>
8000628a:	08 95       	mov	r5,r4
8000628c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000628e:	c0 68       	rjmp	8000629a <logFromISR+0xce>
					default:
					log("I need relax.");
80006290:	4a 5c       	lddpc	r12,80006324 <logFromISR+0x158>
80006292:	f0 1f 00 26 	mcall	80006328 <logFromISR+0x15c>
80006296:	08 95       	mov	r5,r4
80006298:	06 9c       	mov	r12,r3
				}
				str++;
8000629a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000629c:	1a dc       	st.w	--sp,r12
8000629e:	1a d6       	st.w	--sp,r6
800062a0:	4a 3b       	lddpc	r11,8000632c <logFromISR+0x160>
800062a2:	0c 9c       	mov	r12,r6
800062a4:	f0 1f 00 23 	mcall	80006330 <logFromISR+0x164>
800062a8:	2f ed       	sub	sp,-8
800062aa:	c0 a8       	rjmp	800062be <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800062ac:	2f f7       	sub	r7,-1
800062ae:	1a d8       	st.w	--sp,r8
800062b0:	1a d6       	st.w	--sp,r6
800062b2:	4a 1b       	lddpc	r11,80006334 <logFromISR+0x168>
800062b4:	0c 9c       	mov	r12,r6
800062b6:	f0 1f 00 1f 	mcall	80006330 <logFromISR+0x164>
800062ba:	08 95       	mov	r5,r4
800062bc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800062be:	0f 89       	ld.ub	r9,r7[0x0]
800062c0:	30 08       	mov	r8,0
800062c2:	f0 09 18 00 	cp.b	r9,r8
800062c6:	c0 30       	breq	800062cc <logFromISR+0x100>
800062c8:	0a 94       	mov	r4,r5
800062ca:	c9 8b       	rjmp	800061fa <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800062cc:	fa c7 fe f4 	sub	r7,sp,-268
800062d0:	1a d7       	st.w	--sp,r7
800062d2:	49 ab       	lddpc	r11,80006338 <logFromISR+0x16c>
800062d4:	0e 9c       	mov	r12,r7
800062d6:	f0 1f 00 17 	mcall	80006330 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800062da:	5c 5c       	castu.b	r12
800062dc:	f8 c6 ff ff 	sub	r6,r12,-1
800062e0:	0c 9c       	mov	r12,r6
800062e2:	f0 1f 00 17 	mcall	8000633c <logFromISR+0x170>
800062e6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800062e8:	0c 9a       	mov	r10,r6
800062ea:	0e 9b       	mov	r11,r7
800062ec:	f0 1f 00 15 	mcall	80006340 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800062f0:	30 09       	mov	r9,0
800062f2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800062f4:	fa ca fe f8 	sub	r10,sp,-264
800062f8:	fa cb fe f4 	sub	r11,sp,-268
800062fc:	49 28       	lddpc	r8,80006344 <logFromISR+0x178>
800062fe:	70 0c       	ld.w	r12,r8[0x0]
80006300:	f0 1f 00 12 	mcall	80006348 <logFromISR+0x17c>
80006304:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006306:	fe 3d fd f4 	sub	sp,-524
8000630a:	d8 32       	popm	r0-r7,pc
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	6a 14       	ld.w	r4,r5[0x4]
80006310:	00 00       	add	r0,r0
80006312:	0d 35       	ld.ub	r5,r6++
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	c9 c8       	rjmp	8000644e <main+0x56>
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	5f 66       	srmi	r6
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	5e b4       	rethi	r4
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	5e b0       	rethi	r0
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	cb 34       	brge	8000628c <logFromISR+0xc0>
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	60 40       	ld.w	r0,r0[0x10]
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	cb 44       	brge	80006296 <logFromISR+0xca>
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	6d 04       	ld.w	r4,r6[0x40]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	cb 4c       	rcall	8000649e <_malloc_r+0xa>
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	cb 54       	brge	800062a4 <logFromISR+0xd8>
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	51 54       	stdsp	sp[0x54],r4
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	68 cc       	ld.w	r12,r4[0x30]
80006344:	00 00       	add	r0,r0
80006346:	40 ec       	lddsp	r12,sp[0x38]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	54 58       	stdsp	sp[0x114],r8

8000634c <log_init>:
		
	return str;
}

void log_init(void)
{
8000634c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000634e:	30 2b       	mov	r11,2
80006350:	49 0c       	lddpc	r12,80006390 <log_init+0x44>
80006352:	f0 1f 00 11 	mcall	80006394 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006356:	e0 6a 36 00 	mov	r10,13824
8000635a:	ea 1a 01 6e 	orh	r10,0x16e
8000635e:	48 fb       	lddpc	r11,80006398 <log_init+0x4c>
80006360:	fe 7c 18 00 	mov	r12,-59392
80006364:	f0 1f 00 0e 	mcall	8000639c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006368:	30 4b       	mov	r11,4
8000636a:	33 2c       	mov	r12,50
8000636c:	f0 1f 00 0d 	mcall	800063a0 <log_init+0x54>
80006370:	48 d8       	lddpc	r8,800063a4 <log_init+0x58>
80006372:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006374:	30 09       	mov	r9,0
80006376:	1a d9       	st.w	--sp,r9
80006378:	1a d9       	st.w	--sp,r9
8000637a:	1a d9       	st.w	--sp,r9
8000637c:	30 28       	mov	r8,2
8000637e:	e0 6a 01 80 	mov	r10,384
80006382:	48 ab       	lddpc	r11,800063a8 <log_init+0x5c>
80006384:	48 ac       	lddpc	r12,800063ac <log_init+0x60>
80006386:	f0 1f 00 0b 	mcall	800063b0 <log_init+0x64>
8000638a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000638c:	d8 02       	popm	pc
8000638e:	00 00       	add	r0,r0
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	cb 60       	breq	800062fe <logFromISR+0x132>
80006394:	80 00       	ld.sh	r0,r0[0x0]
80006396:	4a 3c       	lddpc	r12,80006420 <main+0x28>
80006398:	80 00       	ld.sh	r0,r0[0x0]
8000639a:	cb 18       	rjmp	800064fc <_malloc_r+0x68>
8000639c:	80 00       	ld.sh	r0,r0[0x0]
8000639e:	4c b8       	lddpc	r8,800064c8 <_malloc_r+0x34>
800063a0:	80 00       	ld.sh	r0,r0[0x0]
800063a2:	55 a8       	stdsp	sp[0x168],r8
800063a4:	00 00       	add	r0,r0
800063a6:	40 ec       	lddsp	r12,sp[0x38]
800063a8:	80 00       	ld.sh	r0,r0[0x0]
800063aa:	cb 5c       	rcall	80006514 <_malloc_r+0x80>
800063ac:	80 00       	ld.sh	r0,r0[0x0]
800063ae:	63 b4       	ld.w	r4,r1[0x6c]
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	5c 7c       	castu.h	r12

800063b4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800063b4:	eb cd 40 f8 	pushm	r3-r7,lr
800063b8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800063ba:	48 c7       	lddpc	r7,800063e8 <task_log+0x34>
800063bc:	30 05       	mov	r5,0
800063be:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800063c0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800063c4:	0a 99       	mov	r9,r5
800063c6:	08 9a       	mov	r10,r4
800063c8:	1a 9b       	mov	r11,sp
800063ca:	6e 0c       	ld.w	r12,r7[0x0]
800063cc:	f0 1f 00 08 	mcall	800063ec <task_log+0x38>
800063d0:	58 1c       	cp.w	r12,1
800063d2:	cf 91       	brne	800063c4 <task_log+0x10>
		{
			if( NULL != str)
800063d4:	40 0b       	lddsp	r11,sp[0x0]
800063d6:	58 0b       	cp.w	r11,0
800063d8:	cf 60       	breq	800063c4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800063da:	06 9c       	mov	r12,r3
800063dc:	f0 1f 00 05 	mcall	800063f0 <task_log+0x3c>
				vPortFree(str);
800063e0:	40 0c       	lddsp	r12,sp[0x0]
800063e2:	f0 1f 00 05 	mcall	800063f4 <task_log+0x40>
800063e6:	ce fb       	rjmp	800063c4 <task_log+0x10>
800063e8:	00 00       	add	r0,r0
800063ea:	40 ec       	lddsp	r12,sp[0x38]
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	52 9c       	stdsp	sp[0xa4],r12
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	4c 68       	lddpc	r8,80006508 <_malloc_r+0x74>
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	51 2c       	stdsp	sp[0x48],r12

800063f8 <main>:
#include "voice.h"
#include "app.h"


int main (void)
{
800063f8:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800063fa:	fe 78 10 00 	mov	r8,-61440
800063fe:	30 19       	mov	r9,1
80006400:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006404:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006408:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000640c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000640e:	f0 1f 00 11 	mcall	80006450 <main+0x58>
		
	INTC_init_interrupts();
80006412:	f0 1f 00 11 	mcall	80006454 <main+0x5c>
		
	log_init();
80006416:	f0 1f 00 11 	mcall	80006458 <main+0x60>
	log("----start debug----");
8000641a:	49 1c       	lddpc	r12,8000645c <main+0x64>
8000641c:	f0 1f 00 11 	mcall	80006460 <main+0x68>
		
	//voc_init();

	//tc_init();
		
	app_init();
80006420:	f0 1f 00 11 	mcall	80006464 <main+0x6c>
		
	xcmp_init();
80006424:	f0 1f 00 11 	mcall	80006468 <main+0x70>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006428:	fe 79 10 00 	mov	r9,-61440
8000642c:	f2 f8 01 60 	ld.w	r8,r9[352]
80006430:	e2 18 00 02 	andl	r8,0x2,COH
80006434:	cf c0       	breq	8000642c <main+0x34>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006436:	fe 79 10 00 	mov	r9,-61440
8000643a:	f2 f8 01 60 	ld.w	r8,r9[352]
8000643e:	e2 18 00 02 	andl	r8,0x2,COH
80006442:	cf c1       	brne	8000643a <main+0x42>
	local_start_timer();
80006444:	f0 1f 00 0a 	mcall	8000646c <main+0x74>
		
	Enable_global_interrupt();
80006448:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
8000644a:	f0 1f 00 0a 	mcall	80006470 <main+0x78>
	return 0;
	
}
8000644e:	d8 0a       	popm	pc,r12=0
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	49 60       	lddpc	r0,800064a8 <_malloc_r+0x14>
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	4a f0       	lddpc	r0,80006510 <_malloc_r+0x7c>
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	63 4c       	ld.w	r12,r1[0x50]
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	cb 70       	breq	800063cc <task_log+0x18>
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	60 40       	ld.w	r0,r0[0x10]
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	20 3c       	sub	r12,3
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	41 e4       	lddsp	r4,sp[0x78]
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	49 b0       	lddpc	r0,800064d8 <_malloc_r+0x44>
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	5e 64       	retmi	r4

80006474 <free>:
80006474:	d4 01       	pushm	lr
80006476:	e0 68 0a 2c 	mov	r8,2604
8000647a:	18 9b       	mov	r11,r12
8000647c:	70 0c       	ld.w	r12,r8[0x0]
8000647e:	e0 a0 1e 61 	rcall	8000a140 <_free_r>
80006482:	d8 02       	popm	pc

80006484 <malloc>:
80006484:	d4 01       	pushm	lr
80006486:	e0 68 0a 2c 	mov	r8,2604
8000648a:	18 9b       	mov	r11,r12
8000648c:	70 0c       	ld.w	r12,r8[0x0]
8000648e:	c0 3c       	rcall	80006494 <_malloc_r>
80006490:	d8 02       	popm	pc
80006492:	d7 03       	nop

80006494 <_malloc_r>:
80006494:	d4 31       	pushm	r0-r7,lr
80006496:	f6 c8 ff f5 	sub	r8,r11,-11
8000649a:	18 95       	mov	r5,r12
8000649c:	10 97       	mov	r7,r8
8000649e:	e0 17 ff f8 	andl	r7,0xfff8
800064a2:	59 68       	cp.w	r8,22
800064a4:	f9 b7 08 10 	movls	r7,16
800064a8:	16 37       	cp.w	r7,r11
800064aa:	5f 38       	srlo	r8
800064ac:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800064b0:	c0 50       	breq	800064ba <_malloc_r+0x26>
800064b2:	30 c8       	mov	r8,12
800064b4:	99 38       	st.w	r12[0xc],r8
800064b6:	e0 8f 01 fa 	bral	800068aa <_malloc_r+0x416>
800064ba:	fe b0 f5 ef 	rcall	80005098 <__malloc_lock>
800064be:	e0 47 01 f7 	cp.w	r7,503
800064c2:	e0 8b 00 1d 	brhi	800064fc <_malloc_r+0x68>
800064c6:	ee 03 16 03 	lsr	r3,r7,0x3
800064ca:	e0 68 05 2c 	mov	r8,1324
800064ce:	f0 03 00 38 	add	r8,r8,r3<<0x3
800064d2:	70 36       	ld.w	r6,r8[0xc]
800064d4:	10 36       	cp.w	r6,r8
800064d6:	c0 61       	brne	800064e2 <_malloc_r+0x4e>
800064d8:	ec c8 ff f8 	sub	r8,r6,-8
800064dc:	70 36       	ld.w	r6,r8[0xc]
800064de:	10 36       	cp.w	r6,r8
800064e0:	c0 c0       	breq	800064f8 <_malloc_r+0x64>
800064e2:	6c 18       	ld.w	r8,r6[0x4]
800064e4:	e0 18 ff fc 	andl	r8,0xfffc
800064e8:	6c 3a       	ld.w	r10,r6[0xc]
800064ea:	ec 08 00 09 	add	r9,r6,r8
800064ee:	0a 9c       	mov	r12,r5
800064f0:	6c 28       	ld.w	r8,r6[0x8]
800064f2:	95 28       	st.w	r10[0x8],r8
800064f4:	91 3a       	st.w	r8[0xc],r10
800064f6:	c4 78       	rjmp	80006584 <_malloc_r+0xf0>
800064f8:	2f e3       	sub	r3,-2
800064fa:	c4 d8       	rjmp	80006594 <_malloc_r+0x100>
800064fc:	ee 03 16 09 	lsr	r3,r7,0x9
80006500:	c0 41       	brne	80006508 <_malloc_r+0x74>
80006502:	ee 03 16 03 	lsr	r3,r7,0x3
80006506:	c2 68       	rjmp	80006552 <_malloc_r+0xbe>
80006508:	58 43       	cp.w	r3,4
8000650a:	e0 8b 00 06 	brhi	80006516 <_malloc_r+0x82>
8000650e:	ee 03 16 06 	lsr	r3,r7,0x6
80006512:	2c 83       	sub	r3,-56
80006514:	c1 f8       	rjmp	80006552 <_malloc_r+0xbe>
80006516:	59 43       	cp.w	r3,20
80006518:	e0 8b 00 04 	brhi	80006520 <_malloc_r+0x8c>
8000651c:	2a 53       	sub	r3,-91
8000651e:	c1 a8       	rjmp	80006552 <_malloc_r+0xbe>
80006520:	e0 43 00 54 	cp.w	r3,84
80006524:	e0 8b 00 06 	brhi	80006530 <_malloc_r+0x9c>
80006528:	ee 03 16 0c 	lsr	r3,r7,0xc
8000652c:	29 23       	sub	r3,-110
8000652e:	c1 28       	rjmp	80006552 <_malloc_r+0xbe>
80006530:	e0 43 01 54 	cp.w	r3,340
80006534:	e0 8b 00 06 	brhi	80006540 <_malloc_r+0xac>
80006538:	ee 03 16 0f 	lsr	r3,r7,0xf
8000653c:	28 93       	sub	r3,-119
8000653e:	c0 a8       	rjmp	80006552 <_malloc_r+0xbe>
80006540:	e0 43 05 54 	cp.w	r3,1364
80006544:	e0 88 00 04 	brls	8000654c <_malloc_r+0xb8>
80006548:	37 e3       	mov	r3,126
8000654a:	c0 48       	rjmp	80006552 <_malloc_r+0xbe>
8000654c:	ee 03 16 12 	lsr	r3,r7,0x12
80006550:	28 43       	sub	r3,-124
80006552:	e0 6a 05 2c 	mov	r10,1324
80006556:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000655a:	74 36       	ld.w	r6,r10[0xc]
8000655c:	c1 98       	rjmp	8000658e <_malloc_r+0xfa>
8000655e:	6c 19       	ld.w	r9,r6[0x4]
80006560:	e0 19 ff fc 	andl	r9,0xfffc
80006564:	f2 07 01 0b 	sub	r11,r9,r7
80006568:	58 fb       	cp.w	r11,15
8000656a:	e0 8a 00 04 	brle	80006572 <_malloc_r+0xde>
8000656e:	20 13       	sub	r3,1
80006570:	c1 18       	rjmp	80006592 <_malloc_r+0xfe>
80006572:	6c 38       	ld.w	r8,r6[0xc]
80006574:	58 0b       	cp.w	r11,0
80006576:	c0 b5       	brlt	8000658c <_malloc_r+0xf8>
80006578:	6c 2a       	ld.w	r10,r6[0x8]
8000657a:	ec 09 00 09 	add	r9,r6,r9
8000657e:	0a 9c       	mov	r12,r5
80006580:	91 2a       	st.w	r8[0x8],r10
80006582:	95 38       	st.w	r10[0xc],r8
80006584:	72 18       	ld.w	r8,r9[0x4]
80006586:	a1 a8       	sbr	r8,0x0
80006588:	93 18       	st.w	r9[0x4],r8
8000658a:	cb c8       	rjmp	80006702 <_malloc_r+0x26e>
8000658c:	10 96       	mov	r6,r8
8000658e:	14 36       	cp.w	r6,r10
80006590:	ce 71       	brne	8000655e <_malloc_r+0xca>
80006592:	2f f3       	sub	r3,-1
80006594:	e0 6a 05 2c 	mov	r10,1324
80006598:	f4 cc ff f8 	sub	r12,r10,-8
8000659c:	78 26       	ld.w	r6,r12[0x8]
8000659e:	18 36       	cp.w	r6,r12
800065a0:	c6 c0       	breq	80006678 <_malloc_r+0x1e4>
800065a2:	6c 19       	ld.w	r9,r6[0x4]
800065a4:	e0 19 ff fc 	andl	r9,0xfffc
800065a8:	f2 07 01 08 	sub	r8,r9,r7
800065ac:	58 f8       	cp.w	r8,15
800065ae:	e0 89 00 8f 	brgt	800066cc <_malloc_r+0x238>
800065b2:	99 3c       	st.w	r12[0xc],r12
800065b4:	99 2c       	st.w	r12[0x8],r12
800065b6:	58 08       	cp.w	r8,0
800065b8:	c0 55       	brlt	800065c2 <_malloc_r+0x12e>
800065ba:	ec 09 00 09 	add	r9,r6,r9
800065be:	0a 9c       	mov	r12,r5
800065c0:	ce 2b       	rjmp	80006584 <_malloc_r+0xf0>
800065c2:	e0 49 01 ff 	cp.w	r9,511
800065c6:	e0 8b 00 13 	brhi	800065ec <_malloc_r+0x158>
800065ca:	a3 99       	lsr	r9,0x3
800065cc:	f4 09 00 38 	add	r8,r10,r9<<0x3
800065d0:	70 2b       	ld.w	r11,r8[0x8]
800065d2:	8d 38       	st.w	r6[0xc],r8
800065d4:	8d 2b       	st.w	r6[0x8],r11
800065d6:	97 36       	st.w	r11[0xc],r6
800065d8:	91 26       	st.w	r8[0x8],r6
800065da:	a3 49       	asr	r9,0x2
800065dc:	74 18       	ld.w	r8,r10[0x4]
800065de:	30 1b       	mov	r11,1
800065e0:	f6 09 09 49 	lsl	r9,r11,r9
800065e4:	f1 e9 10 09 	or	r9,r8,r9
800065e8:	95 19       	st.w	r10[0x4],r9
800065ea:	c4 78       	rjmp	80006678 <_malloc_r+0x1e4>
800065ec:	f2 0a 16 09 	lsr	r10,r9,0x9
800065f0:	58 4a       	cp.w	r10,4
800065f2:	e0 8b 00 07 	brhi	80006600 <_malloc_r+0x16c>
800065f6:	f2 0a 16 06 	lsr	r10,r9,0x6
800065fa:	2c 8a       	sub	r10,-56
800065fc:	c2 08       	rjmp	8000663c <_malloc_r+0x1a8>
800065fe:	d7 03       	nop
80006600:	59 4a       	cp.w	r10,20
80006602:	e0 8b 00 04 	brhi	8000660a <_malloc_r+0x176>
80006606:	2a 5a       	sub	r10,-91
80006608:	c1 a8       	rjmp	8000663c <_malloc_r+0x1a8>
8000660a:	e0 4a 00 54 	cp.w	r10,84
8000660e:	e0 8b 00 06 	brhi	8000661a <_malloc_r+0x186>
80006612:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006616:	29 2a       	sub	r10,-110
80006618:	c1 28       	rjmp	8000663c <_malloc_r+0x1a8>
8000661a:	e0 4a 01 54 	cp.w	r10,340
8000661e:	e0 8b 00 06 	brhi	8000662a <_malloc_r+0x196>
80006622:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006626:	28 9a       	sub	r10,-119
80006628:	c0 a8       	rjmp	8000663c <_malloc_r+0x1a8>
8000662a:	e0 4a 05 54 	cp.w	r10,1364
8000662e:	e0 88 00 04 	brls	80006636 <_malloc_r+0x1a2>
80006632:	37 ea       	mov	r10,126
80006634:	c0 48       	rjmp	8000663c <_malloc_r+0x1a8>
80006636:	f2 0a 16 12 	lsr	r10,r9,0x12
8000663a:	28 4a       	sub	r10,-124
8000663c:	e0 6b 05 2c 	mov	r11,1324
80006640:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006644:	68 28       	ld.w	r8,r4[0x8]
80006646:	08 38       	cp.w	r8,r4
80006648:	c0 e1       	brne	80006664 <_malloc_r+0x1d0>
8000664a:	76 19       	ld.w	r9,r11[0x4]
8000664c:	a3 4a       	asr	r10,0x2
8000664e:	30 1e       	mov	lr,1
80006650:	fc 0a 09 4a 	lsl	r10,lr,r10
80006654:	f3 ea 10 0a 	or	r10,r9,r10
80006658:	10 99       	mov	r9,r8
8000665a:	97 1a       	st.w	r11[0x4],r10
8000665c:	c0 a8       	rjmp	80006670 <_malloc_r+0x1dc>
8000665e:	70 28       	ld.w	r8,r8[0x8]
80006660:	08 38       	cp.w	r8,r4
80006662:	c0 60       	breq	8000666e <_malloc_r+0x1da>
80006664:	70 1a       	ld.w	r10,r8[0x4]
80006666:	e0 1a ff fc 	andl	r10,0xfffc
8000666a:	14 39       	cp.w	r9,r10
8000666c:	cf 93       	brcs	8000665e <_malloc_r+0x1ca>
8000666e:	70 39       	ld.w	r9,r8[0xc]
80006670:	8d 39       	st.w	r6[0xc],r9
80006672:	8d 28       	st.w	r6[0x8],r8
80006674:	91 36       	st.w	r8[0xc],r6
80006676:	93 26       	st.w	r9[0x8],r6
80006678:	e6 08 14 02 	asr	r8,r3,0x2
8000667c:	30 1b       	mov	r11,1
8000667e:	e0 64 05 2c 	mov	r4,1324
80006682:	f6 08 09 4b 	lsl	r11,r11,r8
80006686:	68 18       	ld.w	r8,r4[0x4]
80006688:	10 3b       	cp.w	r11,r8
8000668a:	e0 8b 00 6b 	brhi	80006760 <_malloc_r+0x2cc>
8000668e:	f7 e8 00 09 	and	r9,r11,r8
80006692:	c0 b1       	brne	800066a8 <_malloc_r+0x214>
80006694:	e0 13 ff fc 	andl	r3,0xfffc
80006698:	a1 7b       	lsl	r11,0x1
8000669a:	2f c3       	sub	r3,-4
8000669c:	c0 38       	rjmp	800066a2 <_malloc_r+0x20e>
8000669e:	2f c3       	sub	r3,-4
800066a0:	a1 7b       	lsl	r11,0x1
800066a2:	f7 e8 00 09 	and	r9,r11,r8
800066a6:	cf c0       	breq	8000669e <_malloc_r+0x20a>
800066a8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800066ac:	06 92       	mov	r2,r3
800066ae:	1c 91       	mov	r1,lr
800066b0:	62 36       	ld.w	r6,r1[0xc]
800066b2:	c2 e8       	rjmp	8000670e <_malloc_r+0x27a>
800066b4:	6c 1a       	ld.w	r10,r6[0x4]
800066b6:	e0 1a ff fc 	andl	r10,0xfffc
800066ba:	f4 07 01 08 	sub	r8,r10,r7
800066be:	58 f8       	cp.w	r8,15
800066c0:	e0 8a 00 15 	brle	800066ea <_malloc_r+0x256>
800066c4:	6c 3a       	ld.w	r10,r6[0xc]
800066c6:	6c 29       	ld.w	r9,r6[0x8]
800066c8:	95 29       	st.w	r10[0x8],r9
800066ca:	93 3a       	st.w	r9[0xc],r10
800066cc:	0e 99       	mov	r9,r7
800066ce:	ec 07 00 07 	add	r7,r6,r7
800066d2:	a1 a9       	sbr	r9,0x0
800066d4:	99 37       	st.w	r12[0xc],r7
800066d6:	99 27       	st.w	r12[0x8],r7
800066d8:	8d 19       	st.w	r6[0x4],r9
800066da:	ee 08 09 08 	st.w	r7[r8],r8
800066de:	8f 2c       	st.w	r7[0x8],r12
800066e0:	8f 3c       	st.w	r7[0xc],r12
800066e2:	a1 a8       	sbr	r8,0x0
800066e4:	0a 9c       	mov	r12,r5
800066e6:	8f 18       	st.w	r7[0x4],r8
800066e8:	c0 d8       	rjmp	80006702 <_malloc_r+0x26e>
800066ea:	6c 39       	ld.w	r9,r6[0xc]
800066ec:	58 08       	cp.w	r8,0
800066ee:	c0 f5       	brlt	8000670c <_malloc_r+0x278>
800066f0:	ec 0a 00 0a 	add	r10,r6,r10
800066f4:	74 18       	ld.w	r8,r10[0x4]
800066f6:	a1 a8       	sbr	r8,0x0
800066f8:	0a 9c       	mov	r12,r5
800066fa:	95 18       	st.w	r10[0x4],r8
800066fc:	6c 28       	ld.w	r8,r6[0x8]
800066fe:	93 28       	st.w	r9[0x8],r8
80006700:	91 39       	st.w	r8[0xc],r9
80006702:	fe b0 f4 d1 	rcall	800050a4 <__malloc_unlock>
80006706:	ec cc ff f8 	sub	r12,r6,-8
8000670a:	d8 32       	popm	r0-r7,pc
8000670c:	12 96       	mov	r6,r9
8000670e:	02 36       	cp.w	r6,r1
80006710:	cd 21       	brne	800066b4 <_malloc_r+0x220>
80006712:	2f f2       	sub	r2,-1
80006714:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006718:	c0 30       	breq	8000671e <_malloc_r+0x28a>
8000671a:	2f 81       	sub	r1,-8
8000671c:	cc ab       	rjmp	800066b0 <_malloc_r+0x21c>
8000671e:	1c 98       	mov	r8,lr
80006720:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006724:	c0 81       	brne	80006734 <_malloc_r+0x2a0>
80006726:	68 19       	ld.w	r9,r4[0x4]
80006728:	f6 08 11 ff 	rsub	r8,r11,-1
8000672c:	f3 e8 00 08 	and	r8,r9,r8
80006730:	89 18       	st.w	r4[0x4],r8
80006732:	c0 78       	rjmp	80006740 <_malloc_r+0x2ac>
80006734:	f0 c9 00 08 	sub	r9,r8,8
80006738:	20 13       	sub	r3,1
8000673a:	70 08       	ld.w	r8,r8[0x0]
8000673c:	12 38       	cp.w	r8,r9
8000673e:	cf 10       	breq	80006720 <_malloc_r+0x28c>
80006740:	a1 7b       	lsl	r11,0x1
80006742:	68 18       	ld.w	r8,r4[0x4]
80006744:	10 3b       	cp.w	r11,r8
80006746:	e0 8b 00 0d 	brhi	80006760 <_malloc_r+0x2cc>
8000674a:	58 0b       	cp.w	r11,0
8000674c:	c0 a0       	breq	80006760 <_malloc_r+0x2cc>
8000674e:	04 93       	mov	r3,r2
80006750:	c0 38       	rjmp	80006756 <_malloc_r+0x2c2>
80006752:	2f c3       	sub	r3,-4
80006754:	a1 7b       	lsl	r11,0x1
80006756:	f7 e8 00 09 	and	r9,r11,r8
8000675a:	ca 71       	brne	800066a8 <_malloc_r+0x214>
8000675c:	cf bb       	rjmp	80006752 <_malloc_r+0x2be>
8000675e:	d7 03       	nop
80006760:	68 23       	ld.w	r3,r4[0x8]
80006762:	66 12       	ld.w	r2,r3[0x4]
80006764:	e0 12 ff fc 	andl	r2,0xfffc
80006768:	0e 32       	cp.w	r2,r7
8000676a:	5f 39       	srlo	r9
8000676c:	e4 07 01 08 	sub	r8,r2,r7
80006770:	58 f8       	cp.w	r8,15
80006772:	5f aa       	srle	r10
80006774:	f5 e9 10 09 	or	r9,r10,r9
80006778:	e0 80 00 9a 	breq	800068ac <_malloc_r+0x418>
8000677c:	e0 68 0d 40 	mov	r8,3392
80006780:	70 01       	ld.w	r1,r8[0x0]
80006782:	e0 68 09 38 	mov	r8,2360
80006786:	2f 01       	sub	r1,-16
80006788:	70 08       	ld.w	r8,r8[0x0]
8000678a:	0e 01       	add	r1,r7
8000678c:	5b f8       	cp.w	r8,-1
8000678e:	c0 40       	breq	80006796 <_malloc_r+0x302>
80006790:	28 11       	sub	r1,-127
80006792:	e0 11 ff 80 	andl	r1,0xff80
80006796:	02 9b       	mov	r11,r1
80006798:	0a 9c       	mov	r12,r5
8000679a:	e0 a0 02 a5 	rcall	80006ce4 <_sbrk_r>
8000679e:	18 96       	mov	r6,r12
800067a0:	5b fc       	cp.w	r12,-1
800067a2:	c7 50       	breq	8000688c <_malloc_r+0x3f8>
800067a4:	e6 02 00 08 	add	r8,r3,r2
800067a8:	10 3c       	cp.w	r12,r8
800067aa:	c0 32       	brcc	800067b0 <_malloc_r+0x31c>
800067ac:	08 33       	cp.w	r3,r4
800067ae:	c6 f1       	brne	8000688c <_malloc_r+0x3f8>
800067b0:	e0 6a 0d 44 	mov	r10,3396
800067b4:	74 09       	ld.w	r9,r10[0x0]
800067b6:	e2 09 00 09 	add	r9,r1,r9
800067ba:	95 09       	st.w	r10[0x0],r9
800067bc:	10 36       	cp.w	r6,r8
800067be:	c0 a1       	brne	800067d2 <_malloc_r+0x33e>
800067c0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800067c4:	c0 71       	brne	800067d2 <_malloc_r+0x33e>
800067c6:	e2 02 00 02 	add	r2,r1,r2
800067ca:	68 28       	ld.w	r8,r4[0x8]
800067cc:	a1 a2       	sbr	r2,0x0
800067ce:	91 12       	st.w	r8[0x4],r2
800067d0:	c4 f8       	rjmp	8000686e <_malloc_r+0x3da>
800067d2:	e0 6a 09 38 	mov	r10,2360
800067d6:	74 0b       	ld.w	r11,r10[0x0]
800067d8:	5b fb       	cp.w	r11,-1
800067da:	c0 31       	brne	800067e0 <_malloc_r+0x34c>
800067dc:	95 06       	st.w	r10[0x0],r6
800067de:	c0 78       	rjmp	800067ec <_malloc_r+0x358>
800067e0:	ec 09 00 09 	add	r9,r6,r9
800067e4:	e0 6a 0d 44 	mov	r10,3396
800067e8:	10 19       	sub	r9,r8
800067ea:	95 09       	st.w	r10[0x0],r9
800067ec:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800067f0:	f0 09 11 08 	rsub	r9,r8,8
800067f4:	58 08       	cp.w	r8,0
800067f6:	f2 08 17 10 	movne	r8,r9
800067fa:	ed d8 e1 06 	addne	r6,r6,r8
800067fe:	28 08       	sub	r8,-128
80006800:	ec 01 00 01 	add	r1,r6,r1
80006804:	0a 9c       	mov	r12,r5
80006806:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000680a:	f0 01 01 01 	sub	r1,r8,r1
8000680e:	02 9b       	mov	r11,r1
80006810:	e0 a0 02 6a 	rcall	80006ce4 <_sbrk_r>
80006814:	e0 68 0d 44 	mov	r8,3396
80006818:	5b fc       	cp.w	r12,-1
8000681a:	ec 0c 17 00 	moveq	r12,r6
8000681e:	f9 b1 00 00 	moveq	r1,0
80006822:	70 09       	ld.w	r9,r8[0x0]
80006824:	0c 1c       	sub	r12,r6
80006826:	89 26       	st.w	r4[0x8],r6
80006828:	02 0c       	add	r12,r1
8000682a:	12 01       	add	r1,r9
8000682c:	a1 ac       	sbr	r12,0x0
8000682e:	91 01       	st.w	r8[0x0],r1
80006830:	8d 1c       	st.w	r6[0x4],r12
80006832:	08 33       	cp.w	r3,r4
80006834:	c1 d0       	breq	8000686e <_malloc_r+0x3da>
80006836:	58 f2       	cp.w	r2,15
80006838:	e0 8b 00 05 	brhi	80006842 <_malloc_r+0x3ae>
8000683c:	30 18       	mov	r8,1
8000683e:	8d 18       	st.w	r6[0x4],r8
80006840:	c2 68       	rjmp	8000688c <_malloc_r+0x3f8>
80006842:	30 59       	mov	r9,5
80006844:	20 c2       	sub	r2,12
80006846:	e0 12 ff f8 	andl	r2,0xfff8
8000684a:	e6 02 00 08 	add	r8,r3,r2
8000684e:	91 29       	st.w	r8[0x8],r9
80006850:	91 19       	st.w	r8[0x4],r9
80006852:	66 18       	ld.w	r8,r3[0x4]
80006854:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006858:	e5 e8 10 08 	or	r8,r2,r8
8000685c:	87 18       	st.w	r3[0x4],r8
8000685e:	58 f2       	cp.w	r2,15
80006860:	e0 88 00 07 	brls	8000686e <_malloc_r+0x3da>
80006864:	e6 cb ff f8 	sub	r11,r3,-8
80006868:	0a 9c       	mov	r12,r5
8000686a:	e0 a0 1c 6b 	rcall	8000a140 <_free_r>
8000686e:	e0 69 0d 3c 	mov	r9,3388
80006872:	72 0a       	ld.w	r10,r9[0x0]
80006874:	e0 68 0d 44 	mov	r8,3396
80006878:	70 08       	ld.w	r8,r8[0x0]
8000687a:	14 38       	cp.w	r8,r10
8000687c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006880:	e0 69 0d 38 	mov	r9,3384
80006884:	72 0a       	ld.w	r10,r9[0x0]
80006886:	14 38       	cp.w	r8,r10
80006888:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000688c:	68 28       	ld.w	r8,r4[0x8]
8000688e:	70 18       	ld.w	r8,r8[0x4]
80006890:	e0 18 ff fc 	andl	r8,0xfffc
80006894:	0e 38       	cp.w	r8,r7
80006896:	5f 39       	srlo	r9
80006898:	0e 18       	sub	r8,r7
8000689a:	58 f8       	cp.w	r8,15
8000689c:	5f aa       	srle	r10
8000689e:	f5 e9 10 09 	or	r9,r10,r9
800068a2:	c0 50       	breq	800068ac <_malloc_r+0x418>
800068a4:	0a 9c       	mov	r12,r5
800068a6:	fe b0 f3 ff 	rcall	800050a4 <__malloc_unlock>
800068aa:	d8 3a       	popm	r0-r7,pc,r12=0
800068ac:	68 26       	ld.w	r6,r4[0x8]
800068ae:	a1 a8       	sbr	r8,0x0
800068b0:	0e 99       	mov	r9,r7
800068b2:	a1 a9       	sbr	r9,0x0
800068b4:	8d 19       	st.w	r6[0x4],r9
800068b6:	ec 07 00 07 	add	r7,r6,r7
800068ba:	0a 9c       	mov	r12,r5
800068bc:	89 27       	st.w	r4[0x8],r7
800068be:	8f 18       	st.w	r7[0x4],r8
800068c0:	fe b0 f3 f2 	rcall	800050a4 <__malloc_unlock>
800068c4:	ec cc ff f8 	sub	r12,r6,-8
800068c8:	d8 32       	popm	r0-r7,pc
800068ca:	d7 03       	nop

800068cc <memcpy>:
800068cc:	58 8a       	cp.w	r10,8
800068ce:	c2 f5       	brlt	8000692c <memcpy+0x60>
800068d0:	f9 eb 10 09 	or	r9,r12,r11
800068d4:	e2 19 00 03 	andl	r9,0x3,COH
800068d8:	e0 81 00 97 	brne	80006a06 <memcpy+0x13a>
800068dc:	e0 4a 00 20 	cp.w	r10,32
800068e0:	c3 b4       	brge	80006956 <memcpy+0x8a>
800068e2:	f4 08 14 02 	asr	r8,r10,0x2
800068e6:	f0 09 11 08 	rsub	r9,r8,8
800068ea:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800068ee:	76 69       	ld.w	r9,r11[0x18]
800068f0:	99 69       	st.w	r12[0x18],r9
800068f2:	76 59       	ld.w	r9,r11[0x14]
800068f4:	99 59       	st.w	r12[0x14],r9
800068f6:	76 49       	ld.w	r9,r11[0x10]
800068f8:	99 49       	st.w	r12[0x10],r9
800068fa:	76 39       	ld.w	r9,r11[0xc]
800068fc:	99 39       	st.w	r12[0xc],r9
800068fe:	76 29       	ld.w	r9,r11[0x8]
80006900:	99 29       	st.w	r12[0x8],r9
80006902:	76 19       	ld.w	r9,r11[0x4]
80006904:	99 19       	st.w	r12[0x4],r9
80006906:	76 09       	ld.w	r9,r11[0x0]
80006908:	99 09       	st.w	r12[0x0],r9
8000690a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000690e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006912:	e0 1a 00 03 	andl	r10,0x3
80006916:	f4 0a 11 04 	rsub	r10,r10,4
8000691a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000691e:	17 a9       	ld.ub	r9,r11[0x2]
80006920:	b0 a9       	st.b	r8[0x2],r9
80006922:	17 99       	ld.ub	r9,r11[0x1]
80006924:	b0 99       	st.b	r8[0x1],r9
80006926:	17 89       	ld.ub	r9,r11[0x0]
80006928:	b0 89       	st.b	r8[0x0],r9
8000692a:	5e fc       	retal	r12
8000692c:	f4 0a 11 09 	rsub	r10,r10,9
80006930:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006934:	17 f9       	ld.ub	r9,r11[0x7]
80006936:	b8 f9       	st.b	r12[0x7],r9
80006938:	17 e9       	ld.ub	r9,r11[0x6]
8000693a:	b8 e9       	st.b	r12[0x6],r9
8000693c:	17 d9       	ld.ub	r9,r11[0x5]
8000693e:	b8 d9       	st.b	r12[0x5],r9
80006940:	17 c9       	ld.ub	r9,r11[0x4]
80006942:	b8 c9       	st.b	r12[0x4],r9
80006944:	17 b9       	ld.ub	r9,r11[0x3]
80006946:	b8 b9       	st.b	r12[0x3],r9
80006948:	17 a9       	ld.ub	r9,r11[0x2]
8000694a:	b8 a9       	st.b	r12[0x2],r9
8000694c:	17 99       	ld.ub	r9,r11[0x1]
8000694e:	b8 99       	st.b	r12[0x1],r9
80006950:	17 89       	ld.ub	r9,r11[0x0]
80006952:	b8 89       	st.b	r12[0x0],r9
80006954:	5e fc       	retal	r12
80006956:	eb cd 40 c0 	pushm	r6-r7,lr
8000695a:	18 99       	mov	r9,r12
8000695c:	22 0a       	sub	r10,32
8000695e:	b7 07       	ld.d	r6,r11++
80006960:	b3 26       	st.d	r9++,r6
80006962:	b7 07       	ld.d	r6,r11++
80006964:	b3 26       	st.d	r9++,r6
80006966:	b7 07       	ld.d	r6,r11++
80006968:	b3 26       	st.d	r9++,r6
8000696a:	b7 07       	ld.d	r6,r11++
8000696c:	b3 26       	st.d	r9++,r6
8000696e:	22 0a       	sub	r10,32
80006970:	cf 74       	brge	8000695e <memcpy+0x92>
80006972:	2f 0a       	sub	r10,-16
80006974:	c0 65       	brlt	80006980 <memcpy+0xb4>
80006976:	b7 07       	ld.d	r6,r11++
80006978:	b3 26       	st.d	r9++,r6
8000697a:	b7 07       	ld.d	r6,r11++
8000697c:	b3 26       	st.d	r9++,r6
8000697e:	21 0a       	sub	r10,16
80006980:	5c 3a       	neg	r10
80006982:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006986:	d7 03       	nop
80006988:	d7 03       	nop
8000698a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000698e:	f3 66 00 0e 	st.b	r9[14],r6
80006992:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006996:	f3 66 00 0d 	st.b	r9[13],r6
8000699a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000699e:	f3 66 00 0c 	st.b	r9[12],r6
800069a2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800069a6:	f3 66 00 0b 	st.b	r9[11],r6
800069aa:	f7 36 00 0a 	ld.ub	r6,r11[10]
800069ae:	f3 66 00 0a 	st.b	r9[10],r6
800069b2:	f7 36 00 09 	ld.ub	r6,r11[9]
800069b6:	f3 66 00 09 	st.b	r9[9],r6
800069ba:	f7 36 00 08 	ld.ub	r6,r11[8]
800069be:	f3 66 00 08 	st.b	r9[8],r6
800069c2:	f7 36 00 07 	ld.ub	r6,r11[7]
800069c6:	f3 66 00 07 	st.b	r9[7],r6
800069ca:	f7 36 00 06 	ld.ub	r6,r11[6]
800069ce:	f3 66 00 06 	st.b	r9[6],r6
800069d2:	f7 36 00 05 	ld.ub	r6,r11[5]
800069d6:	f3 66 00 05 	st.b	r9[5],r6
800069da:	f7 36 00 04 	ld.ub	r6,r11[4]
800069de:	f3 66 00 04 	st.b	r9[4],r6
800069e2:	f7 36 00 03 	ld.ub	r6,r11[3]
800069e6:	f3 66 00 03 	st.b	r9[3],r6
800069ea:	f7 36 00 02 	ld.ub	r6,r11[2]
800069ee:	f3 66 00 02 	st.b	r9[2],r6
800069f2:	f7 36 00 01 	ld.ub	r6,r11[1]
800069f6:	f3 66 00 01 	st.b	r9[1],r6
800069fa:	f7 36 00 00 	ld.ub	r6,r11[0]
800069fe:	f3 66 00 00 	st.b	r9[0],r6
80006a02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a06:	20 1a       	sub	r10,1
80006a08:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a0c:	f8 0a 0b 09 	st.b	r12[r10],r9
80006a10:	cf b1       	brne	80006a06 <memcpy+0x13a>
80006a12:	5e fc       	retal	r12

80006a14 <memset>:
80006a14:	18 98       	mov	r8,r12
80006a16:	c0 38       	rjmp	80006a1c <memset+0x8>
80006a18:	10 cb       	st.b	r8++,r11
80006a1a:	20 1a       	sub	r10,1
80006a1c:	58 0a       	cp.w	r10,0
80006a1e:	cf d1       	brne	80006a18 <memset+0x4>
80006a20:	5e fc       	retal	r12
80006a22:	d7 03       	nop

80006a24 <_realloc_r>:
80006a24:	d4 31       	pushm	r0-r7,lr
80006a26:	20 1d       	sub	sp,4
80006a28:	16 94       	mov	r4,r11
80006a2a:	18 92       	mov	r2,r12
80006a2c:	14 9b       	mov	r11,r10
80006a2e:	58 04       	cp.w	r4,0
80006a30:	c0 51       	brne	80006a3a <_realloc_r+0x16>
80006a32:	fe b0 fd 31 	rcall	80006494 <_malloc_r>
80006a36:	18 95       	mov	r5,r12
80006a38:	c5 39       	rjmp	80006cde <_realloc_r+0x2ba>
80006a3a:	50 0a       	stdsp	sp[0x0],r10
80006a3c:	fe b0 f3 2e 	rcall	80005098 <__malloc_lock>
80006a40:	40 0b       	lddsp	r11,sp[0x0]
80006a42:	f6 c8 ff f5 	sub	r8,r11,-11
80006a46:	e8 c1 00 08 	sub	r1,r4,8
80006a4a:	10 96       	mov	r6,r8
80006a4c:	62 1c       	ld.w	r12,r1[0x4]
80006a4e:	e0 16 ff f8 	andl	r6,0xfff8
80006a52:	59 68       	cp.w	r8,22
80006a54:	f9 b6 08 10 	movls	r6,16
80006a58:	16 36       	cp.w	r6,r11
80006a5a:	5f 38       	srlo	r8
80006a5c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006a60:	c0 50       	breq	80006a6a <_realloc_r+0x46>
80006a62:	30 c8       	mov	r8,12
80006a64:	30 05       	mov	r5,0
80006a66:	85 38       	st.w	r2[0xc],r8
80006a68:	c3 b9       	rjmp	80006cde <_realloc_r+0x2ba>
80006a6a:	18 90       	mov	r0,r12
80006a6c:	e0 10 ff fc 	andl	r0,0xfffc
80006a70:	0c 30       	cp.w	r0,r6
80006a72:	e0 84 01 0b 	brge	80006c88 <_realloc_r+0x264>
80006a76:	e0 68 05 2c 	mov	r8,1324
80006a7a:	e2 00 00 09 	add	r9,r1,r0
80006a7e:	70 25       	ld.w	r5,r8[0x8]
80006a80:	0a 39       	cp.w	r9,r5
80006a82:	c0 90       	breq	80006a94 <_realloc_r+0x70>
80006a84:	72 1a       	ld.w	r10,r9[0x4]
80006a86:	a1 ca       	cbr	r10,0x0
80006a88:	f2 0a 00 0a 	add	r10,r9,r10
80006a8c:	74 1a       	ld.w	r10,r10[0x4]
80006a8e:	ed ba 00 00 	bld	r10,0x0
80006a92:	c2 20       	breq	80006ad6 <_realloc_r+0xb2>
80006a94:	72 1a       	ld.w	r10,r9[0x4]
80006a96:	e0 1a ff fc 	andl	r10,0xfffc
80006a9a:	f4 00 00 03 	add	r3,r10,r0
80006a9e:	0a 39       	cp.w	r9,r5
80006aa0:	c1 31       	brne	80006ac6 <_realloc_r+0xa2>
80006aa2:	ec c7 ff f0 	sub	r7,r6,-16
80006aa6:	0e 33       	cp.w	r3,r7
80006aa8:	c1 95       	brlt	80006ada <_realloc_r+0xb6>
80006aaa:	e2 06 00 09 	add	r9,r1,r6
80006aae:	0c 13       	sub	r3,r6
80006ab0:	a1 a3       	sbr	r3,0x0
80006ab2:	93 13       	st.w	r9[0x4],r3
80006ab4:	91 29       	st.w	r8[0x8],r9
80006ab6:	04 9c       	mov	r12,r2
80006ab8:	62 18       	ld.w	r8,r1[0x4]
80006aba:	08 95       	mov	r5,r4
80006abc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ac0:	10 46       	or	r6,r8
80006ac2:	83 16       	st.w	r1[0x4],r6
80006ac4:	c0 b9       	rjmp	80006cda <_realloc_r+0x2b6>
80006ac6:	0c 33       	cp.w	r3,r6
80006ac8:	c0 95       	brlt	80006ada <_realloc_r+0xb6>
80006aca:	72 28       	ld.w	r8,r9[0x8]
80006acc:	02 97       	mov	r7,r1
80006ace:	72 39       	ld.w	r9,r9[0xc]
80006ad0:	93 28       	st.w	r9[0x8],r8
80006ad2:	91 39       	st.w	r8[0xc],r9
80006ad4:	cd c8       	rjmp	80006c8c <_realloc_r+0x268>
80006ad6:	30 0a       	mov	r10,0
80006ad8:	14 99       	mov	r9,r10
80006ada:	ed bc 00 00 	bld	r12,0x0
80006ade:	e0 80 00 95 	breq	80006c08 <_realloc_r+0x1e4>
80006ae2:	62 07       	ld.w	r7,r1[0x0]
80006ae4:	e2 07 01 07 	sub	r7,r1,r7
80006ae8:	6e 1c       	ld.w	r12,r7[0x4]
80006aea:	e0 1c ff fc 	andl	r12,0xfffc
80006aee:	58 09       	cp.w	r9,0
80006af0:	c5 60       	breq	80006b9c <_realloc_r+0x178>
80006af2:	f8 00 00 03 	add	r3,r12,r0
80006af6:	0a 39       	cp.w	r9,r5
80006af8:	c4 81       	brne	80006b88 <_realloc_r+0x164>
80006afa:	14 03       	add	r3,r10
80006afc:	ec c9 ff f0 	sub	r9,r6,-16
80006b00:	12 33       	cp.w	r3,r9
80006b02:	c4 d5       	brlt	80006b9c <_realloc_r+0x178>
80006b04:	6e 3a       	ld.w	r10,r7[0xc]
80006b06:	6e 29       	ld.w	r9,r7[0x8]
80006b08:	95 29       	st.w	r10[0x8],r9
80006b0a:	93 3a       	st.w	r9[0xc],r10
80006b0c:	ee c5 ff f8 	sub	r5,r7,-8
80006b10:	e0 ca 00 04 	sub	r10,r0,4
80006b14:	e0 4a 00 24 	cp.w	r10,36
80006b18:	e0 8b 00 25 	brhi	80006b62 <_realloc_r+0x13e>
80006b1c:	0a 99       	mov	r9,r5
80006b1e:	59 3a       	cp.w	r10,19
80006b20:	e0 88 00 1a 	brls	80006b54 <_realloc_r+0x130>
80006b24:	09 09       	ld.w	r9,r4++
80006b26:	8b 09       	st.w	r5[0x0],r9
80006b28:	09 09       	ld.w	r9,r4++
80006b2a:	8f 39       	st.w	r7[0xc],r9
80006b2c:	ee c9 ff f0 	sub	r9,r7,-16
80006b30:	59 ba       	cp.w	r10,27
80006b32:	e0 88 00 11 	brls	80006b54 <_realloc_r+0x130>
80006b36:	09 0b       	ld.w	r11,r4++
80006b38:	93 0b       	st.w	r9[0x0],r11
80006b3a:	09 09       	ld.w	r9,r4++
80006b3c:	8f 59       	st.w	r7[0x14],r9
80006b3e:	ee c9 ff e8 	sub	r9,r7,-24
80006b42:	e0 4a 00 24 	cp.w	r10,36
80006b46:	c0 71       	brne	80006b54 <_realloc_r+0x130>
80006b48:	09 0a       	ld.w	r10,r4++
80006b4a:	93 0a       	st.w	r9[0x0],r10
80006b4c:	ee c9 ff e0 	sub	r9,r7,-32
80006b50:	09 0a       	ld.w	r10,r4++
80006b52:	8f 7a       	st.w	r7[0x1c],r10
80006b54:	09 0a       	ld.w	r10,r4++
80006b56:	12 aa       	st.w	r9++,r10
80006b58:	68 0a       	ld.w	r10,r4[0x0]
80006b5a:	93 0a       	st.w	r9[0x0],r10
80006b5c:	68 1a       	ld.w	r10,r4[0x4]
80006b5e:	93 1a       	st.w	r9[0x4],r10
80006b60:	c0 78       	rjmp	80006b6e <_realloc_r+0x14a>
80006b62:	50 08       	stdsp	sp[0x0],r8
80006b64:	08 9b       	mov	r11,r4
80006b66:	0a 9c       	mov	r12,r5
80006b68:	e0 a0 1d 8f 	rcall	8000a686 <memmove>
80006b6c:	40 08       	lddsp	r8,sp[0x0]
80006b6e:	ee 06 00 09 	add	r9,r7,r6
80006b72:	0c 13       	sub	r3,r6
80006b74:	a1 a3       	sbr	r3,0x0
80006b76:	93 13       	st.w	r9[0x4],r3
80006b78:	91 29       	st.w	r8[0x8],r9
80006b7a:	04 9c       	mov	r12,r2
80006b7c:	6e 18       	ld.w	r8,r7[0x4]
80006b7e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b82:	10 46       	or	r6,r8
80006b84:	8f 16       	st.w	r7[0x4],r6
80006b86:	ca a8       	rjmp	80006cda <_realloc_r+0x2b6>
80006b88:	14 03       	add	r3,r10
80006b8a:	0c 33       	cp.w	r3,r6
80006b8c:	c0 85       	brlt	80006b9c <_realloc_r+0x178>
80006b8e:	72 28       	ld.w	r8,r9[0x8]
80006b90:	72 39       	ld.w	r9,r9[0xc]
80006b92:	93 28       	st.w	r9[0x8],r8
80006b94:	91 39       	st.w	r8[0xc],r9
80006b96:	6e 28       	ld.w	r8,r7[0x8]
80006b98:	6e 39       	ld.w	r9,r7[0xc]
80006b9a:	c0 78       	rjmp	80006ba8 <_realloc_r+0x184>
80006b9c:	f8 00 00 03 	add	r3,r12,r0
80006ba0:	0c 33       	cp.w	r3,r6
80006ba2:	c3 35       	brlt	80006c08 <_realloc_r+0x1e4>
80006ba4:	6e 39       	ld.w	r9,r7[0xc]
80006ba6:	6e 28       	ld.w	r8,r7[0x8]
80006ba8:	93 28       	st.w	r9[0x8],r8
80006baa:	91 39       	st.w	r8[0xc],r9
80006bac:	e0 ca 00 04 	sub	r10,r0,4
80006bb0:	ee cc ff f8 	sub	r12,r7,-8
80006bb4:	e0 4a 00 24 	cp.w	r10,36
80006bb8:	e0 8b 00 24 	brhi	80006c00 <_realloc_r+0x1dc>
80006bbc:	59 3a       	cp.w	r10,19
80006bbe:	e0 88 00 1a 	brls	80006bf2 <_realloc_r+0x1ce>
80006bc2:	09 08       	ld.w	r8,r4++
80006bc4:	99 08       	st.w	r12[0x0],r8
80006bc6:	09 08       	ld.w	r8,r4++
80006bc8:	8f 38       	st.w	r7[0xc],r8
80006bca:	ee cc ff f0 	sub	r12,r7,-16
80006bce:	59 ba       	cp.w	r10,27
80006bd0:	e0 88 00 11 	brls	80006bf2 <_realloc_r+0x1ce>
80006bd4:	09 08       	ld.w	r8,r4++
80006bd6:	99 08       	st.w	r12[0x0],r8
80006bd8:	09 08       	ld.w	r8,r4++
80006bda:	8f 58       	st.w	r7[0x14],r8
80006bdc:	ee cc ff e8 	sub	r12,r7,-24
80006be0:	e0 4a 00 24 	cp.w	r10,36
80006be4:	c0 71       	brne	80006bf2 <_realloc_r+0x1ce>
80006be6:	09 08       	ld.w	r8,r4++
80006be8:	99 08       	st.w	r12[0x0],r8
80006bea:	ee cc ff e0 	sub	r12,r7,-32
80006bee:	09 08       	ld.w	r8,r4++
80006bf0:	8f 78       	st.w	r7[0x1c],r8
80006bf2:	09 08       	ld.w	r8,r4++
80006bf4:	18 a8       	st.w	r12++,r8
80006bf6:	68 08       	ld.w	r8,r4[0x0]
80006bf8:	99 08       	st.w	r12[0x0],r8
80006bfa:	68 18       	ld.w	r8,r4[0x4]
80006bfc:	99 18       	st.w	r12[0x4],r8
80006bfe:	c4 78       	rjmp	80006c8c <_realloc_r+0x268>
80006c00:	08 9b       	mov	r11,r4
80006c02:	e0 a0 1d 42 	rcall	8000a686 <memmove>
80006c06:	c4 38       	rjmp	80006c8c <_realloc_r+0x268>
80006c08:	04 9c       	mov	r12,r2
80006c0a:	fe b0 fc 45 	rcall	80006494 <_malloc_r>
80006c0e:	18 95       	mov	r5,r12
80006c10:	c3 a0       	breq	80006c84 <_realloc_r+0x260>
80006c12:	62 18       	ld.w	r8,r1[0x4]
80006c14:	f8 c9 00 08 	sub	r9,r12,8
80006c18:	a1 c8       	cbr	r8,0x0
80006c1a:	e2 08 00 08 	add	r8,r1,r8
80006c1e:	10 39       	cp.w	r9,r8
80006c20:	c0 71       	brne	80006c2e <_realloc_r+0x20a>
80006c22:	72 13       	ld.w	r3,r9[0x4]
80006c24:	02 97       	mov	r7,r1
80006c26:	e0 13 ff fc 	andl	r3,0xfffc
80006c2a:	00 03       	add	r3,r0
80006c2c:	c3 08       	rjmp	80006c8c <_realloc_r+0x268>
80006c2e:	e0 ca 00 04 	sub	r10,r0,4
80006c32:	e0 4a 00 24 	cp.w	r10,36
80006c36:	e0 8b 00 20 	brhi	80006c76 <_realloc_r+0x252>
80006c3a:	08 99       	mov	r9,r4
80006c3c:	18 98       	mov	r8,r12
80006c3e:	59 3a       	cp.w	r10,19
80006c40:	e0 88 00 14 	brls	80006c68 <_realloc_r+0x244>
80006c44:	13 0b       	ld.w	r11,r9++
80006c46:	10 ab       	st.w	r8++,r11
80006c48:	13 0b       	ld.w	r11,r9++
80006c4a:	10 ab       	st.w	r8++,r11
80006c4c:	59 ba       	cp.w	r10,27
80006c4e:	e0 88 00 0d 	brls	80006c68 <_realloc_r+0x244>
80006c52:	13 0b       	ld.w	r11,r9++
80006c54:	10 ab       	st.w	r8++,r11
80006c56:	13 0b       	ld.w	r11,r9++
80006c58:	10 ab       	st.w	r8++,r11
80006c5a:	e0 4a 00 24 	cp.w	r10,36
80006c5e:	c0 51       	brne	80006c68 <_realloc_r+0x244>
80006c60:	13 0a       	ld.w	r10,r9++
80006c62:	10 aa       	st.w	r8++,r10
80006c64:	13 0a       	ld.w	r10,r9++
80006c66:	10 aa       	st.w	r8++,r10
80006c68:	13 0a       	ld.w	r10,r9++
80006c6a:	10 aa       	st.w	r8++,r10
80006c6c:	72 0a       	ld.w	r10,r9[0x0]
80006c6e:	91 0a       	st.w	r8[0x0],r10
80006c70:	72 19       	ld.w	r9,r9[0x4]
80006c72:	91 19       	st.w	r8[0x4],r9
80006c74:	c0 48       	rjmp	80006c7c <_realloc_r+0x258>
80006c76:	08 9b       	mov	r11,r4
80006c78:	e0 a0 1d 07 	rcall	8000a686 <memmove>
80006c7c:	08 9b       	mov	r11,r4
80006c7e:	04 9c       	mov	r12,r2
80006c80:	e0 a0 1a 60 	rcall	8000a140 <_free_r>
80006c84:	04 9c       	mov	r12,r2
80006c86:	c2 a8       	rjmp	80006cda <_realloc_r+0x2b6>
80006c88:	00 93       	mov	r3,r0
80006c8a:	02 97       	mov	r7,r1
80006c8c:	e6 06 01 09 	sub	r9,r3,r6
80006c90:	6e 18       	ld.w	r8,r7[0x4]
80006c92:	58 f9       	cp.w	r9,15
80006c94:	e0 88 00 16 	brls	80006cc0 <_realloc_r+0x29c>
80006c98:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006c9c:	ed e8 10 08 	or	r8,r6,r8
80006ca0:	8f 18       	st.w	r7[0x4],r8
80006ca2:	12 98       	mov	r8,r9
80006ca4:	a1 a8       	sbr	r8,0x0
80006ca6:	ee 06 00 0b 	add	r11,r7,r6
80006caa:	f6 09 00 09 	add	r9,r11,r9
80006cae:	97 18       	st.w	r11[0x4],r8
80006cb0:	72 18       	ld.w	r8,r9[0x4]
80006cb2:	a1 a8       	sbr	r8,0x0
80006cb4:	2f 8b       	sub	r11,-8
80006cb6:	93 18       	st.w	r9[0x4],r8
80006cb8:	04 9c       	mov	r12,r2
80006cba:	e0 a0 1a 43 	rcall	8000a140 <_free_r>
80006cbe:	c0 b8       	rjmp	80006cd4 <_realloc_r+0x2b0>
80006cc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006cc4:	e7 e8 10 08 	or	r8,r3,r8
80006cc8:	8f 18       	st.w	r7[0x4],r8
80006cca:	ee 03 00 03 	add	r3,r7,r3
80006cce:	66 18       	ld.w	r8,r3[0x4]
80006cd0:	a1 a8       	sbr	r8,0x0
80006cd2:	87 18       	st.w	r3[0x4],r8
80006cd4:	04 9c       	mov	r12,r2
80006cd6:	ee c5 ff f8 	sub	r5,r7,-8
80006cda:	fe b0 f1 e5 	rcall	800050a4 <__malloc_unlock>
80006cde:	0a 9c       	mov	r12,r5
80006ce0:	2f fd       	sub	sp,-4
80006ce2:	d8 32       	popm	r0-r7,pc

80006ce4 <_sbrk_r>:
80006ce4:	d4 21       	pushm	r4-r7,lr
80006ce6:	30 08       	mov	r8,0
80006ce8:	18 97       	mov	r7,r12
80006cea:	e0 66 40 f0 	mov	r6,16624
80006cee:	16 9c       	mov	r12,r11
80006cf0:	8d 08       	st.w	r6[0x0],r8
80006cf2:	c8 5c       	rcall	80006dfc <_sbrk>
80006cf4:	5b fc       	cp.w	r12,-1
80006cf6:	c0 51       	brne	80006d00 <_sbrk_r+0x1c>
80006cf8:	6c 08       	ld.w	r8,r6[0x0]
80006cfa:	58 08       	cp.w	r8,0
80006cfc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006d00:	d8 22       	popm	r4-r7,pc
80006d02:	d7 03       	nop

80006d04 <sprintf>:
80006d04:	d4 01       	pushm	lr
80006d06:	21 7d       	sub	sp,92
80006d08:	e0 68 ff ff 	mov	r8,65535
80006d0c:	ea 18 7f ff 	orh	r8,0x7fff
80006d10:	50 58       	stdsp	sp[0x14],r8
80006d12:	50 28       	stdsp	sp[0x8],r8
80006d14:	e0 68 02 08 	mov	r8,520
80006d18:	ba 68       	st.h	sp[0xc],r8
80006d1a:	3f f8       	mov	r8,-1
80006d1c:	ba 78       	st.h	sp[0xe],r8
80006d1e:	e0 68 0a 2c 	mov	r8,2604
80006d22:	50 4c       	stdsp	sp[0x10],r12
80006d24:	16 9a       	mov	r10,r11
80006d26:	50 0c       	stdsp	sp[0x0],r12
80006d28:	fa c9 ff a0 	sub	r9,sp,-96
80006d2c:	70 0c       	ld.w	r12,r8[0x0]
80006d2e:	1a 9b       	mov	r11,sp
80006d30:	e0 a0 02 1a 	rcall	80007164 <_vfprintf_r>
80006d34:	30 09       	mov	r9,0
80006d36:	40 08       	lddsp	r8,sp[0x0]
80006d38:	b0 89       	st.b	r8[0x0],r9
80006d3a:	2e 9d       	sub	sp,-92
80006d3c:	d8 02       	popm	pc
80006d3e:	d7 03       	nop

80006d40 <strncpy>:
80006d40:	30 08       	mov	r8,0
80006d42:	10 3a       	cp.w	r10,r8
80006d44:	5e 0c       	reteq	r12
80006d46:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006d4a:	f8 08 0b 09 	st.b	r12[r8],r9
80006d4e:	2f f8       	sub	r8,-1
80006d50:	58 09       	cp.w	r9,0
80006d52:	cf 81       	brne	80006d42 <strncpy+0x2>
80006d54:	10 3a       	cp.w	r10,r8
80006d56:	5e 0c       	reteq	r12
80006d58:	f8 08 0b 09 	st.b	r12[r8],r9
80006d5c:	2f f8       	sub	r8,-1
80006d5e:	cf bb       	rjmp	80006d54 <strncpy+0x14>

80006d60 <_close>:
80006d60:	30 28       	mov	r8,2
80006d62:	d6 73       	breakpoint
80006d64:	3f fc       	mov	r12,-1
80006d66:	35 8b       	mov	r11,88
80006d68:	58 0c       	cp.w	r12,0
80006d6a:	5e 4c       	retge	r12
80006d6c:	e0 6a 40 f0 	mov	r10,16624
80006d70:	95 0b       	st.w	r10[0x0],r11
80006d72:	5e fc       	retal	r12

80006d74 <_lseek>:
80006d74:	30 58       	mov	r8,5
80006d76:	d6 73       	breakpoint
80006d78:	3f fc       	mov	r12,-1
80006d7a:	35 8b       	mov	r11,88
80006d7c:	58 0c       	cp.w	r12,0
80006d7e:	5e 4c       	retge	r12
80006d80:	e0 6a 40 f0 	mov	r10,16624
80006d84:	95 0b       	st.w	r10[0x0],r11
80006d86:	5e fc       	retal	r12

80006d88 <isatty>:
80006d88:	30 b8       	mov	r8,11
80006d8a:	d6 73       	breakpoint
80006d8c:	3f fc       	mov	r12,-1
80006d8e:	35 8b       	mov	r11,88
80006d90:	58 0c       	cp.w	r12,0
80006d92:	5e 4c       	retge	r12
80006d94:	e0 6a 40 f0 	mov	r10,16624
80006d98:	95 0b       	st.w	r10[0x0],r11
80006d9a:	5e fc       	retal	r12

80006d9c <_fstat_host>:
80006d9c:	30 98       	mov	r8,9
80006d9e:	d6 73       	breakpoint
80006da0:	3f fc       	mov	r12,-1
80006da2:	35 8b       	mov	r11,88
80006da4:	58 0c       	cp.w	r12,0
80006da6:	5e 4c       	retge	r12
80006da8:	e0 6a 40 f0 	mov	r10,16624
80006dac:	95 0b       	st.w	r10[0x0],r11
80006dae:	5e fc       	retal	r12

80006db0 <_fstat>:
80006db0:	d4 21       	pushm	r4-r7,lr
80006db2:	21 0d       	sub	sp,64
80006db4:	16 97       	mov	r7,r11
80006db6:	1a 9b       	mov	r11,sp
80006db8:	cf 2f       	rcall	80006d9c <_fstat_host>
80006dba:	c0 34       	brge	80006dc0 <_fstat+0x10>
80006dbc:	3f fc       	mov	r12,-1
80006dbe:	c1 c8       	rjmp	80006df6 <_fstat+0x46>
80006dc0:	40 08       	lddsp	r8,sp[0x0]
80006dc2:	ae 08       	st.h	r7[0x0],r8
80006dc4:	40 18       	lddsp	r8,sp[0x4]
80006dc6:	ae 18       	st.h	r7[0x2],r8
80006dc8:	40 28       	lddsp	r8,sp[0x8]
80006dca:	8f 18       	st.w	r7[0x4],r8
80006dcc:	40 38       	lddsp	r8,sp[0xc]
80006dce:	ae 48       	st.h	r7[0x8],r8
80006dd0:	40 48       	lddsp	r8,sp[0x10]
80006dd2:	ae 58       	st.h	r7[0xa],r8
80006dd4:	40 58       	lddsp	r8,sp[0x14]
80006dd6:	ae 68       	st.h	r7[0xc],r8
80006dd8:	40 68       	lddsp	r8,sp[0x18]
80006dda:	ae 78       	st.h	r7[0xe],r8
80006ddc:	40 88       	lddsp	r8,sp[0x20]
80006dde:	8f 48       	st.w	r7[0x10],r8
80006de0:	40 a8       	lddsp	r8,sp[0x28]
80006de2:	8f b8       	st.w	r7[0x2c],r8
80006de4:	40 c8       	lddsp	r8,sp[0x30]
80006de6:	8f c8       	st.w	r7[0x30],r8
80006de8:	40 d8       	lddsp	r8,sp[0x34]
80006dea:	8f 58       	st.w	r7[0x14],r8
80006dec:	40 e8       	lddsp	r8,sp[0x38]
80006dee:	30 0c       	mov	r12,0
80006df0:	8f 78       	st.w	r7[0x1c],r8
80006df2:	40 f8       	lddsp	r8,sp[0x3c]
80006df4:	8f 98       	st.w	r7[0x24],r8
80006df6:	2f 0d       	sub	sp,-64
80006df8:	d8 22       	popm	r4-r7,pc
80006dfa:	d7 03       	nop

80006dfc <_sbrk>:
80006dfc:	d4 01       	pushm	lr
80006dfe:	e0 68 0d 6c 	mov	r8,3436
80006e02:	70 09       	ld.w	r9,r8[0x0]
80006e04:	58 09       	cp.w	r9,0
80006e06:	c0 41       	brne	80006e0e <_sbrk+0x12>
80006e08:	e0 69 40 f8 	mov	r9,16632
80006e0c:	91 09       	st.w	r8[0x0],r9
80006e0e:	e0 69 0d 6c 	mov	r9,3436
80006e12:	e0 7a 70 00 	mov	r10,94208
80006e16:	72 08       	ld.w	r8,r9[0x0]
80006e18:	f0 0c 00 0c 	add	r12,r8,r12
80006e1c:	14 3c       	cp.w	r12,r10
80006e1e:	e0 8b 00 04 	brhi	80006e26 <_sbrk+0x2a>
80006e22:	93 0c       	st.w	r9[0x0],r12
80006e24:	c0 68       	rjmp	80006e30 <_sbrk+0x34>
80006e26:	e0 a0 18 15 	rcall	80009e50 <__errno>
80006e2a:	30 c8       	mov	r8,12
80006e2c:	99 08       	st.w	r12[0x0],r8
80006e2e:	3f f8       	mov	r8,-1
80006e30:	10 9c       	mov	r12,r8
80006e32:	d8 02       	popm	pc

80006e34 <get_arg>:
80006e34:	d4 31       	pushm	r0-r7,lr
80006e36:	20 8d       	sub	sp,32
80006e38:	fa c4 ff bc 	sub	r4,sp,-68
80006e3c:	50 4b       	stdsp	sp[0x10],r11
80006e3e:	68 2e       	ld.w	lr,r4[0x8]
80006e40:	50 58       	stdsp	sp[0x14],r8
80006e42:	12 96       	mov	r6,r9
80006e44:	7c 0b       	ld.w	r11,lr[0x0]
80006e46:	70 05       	ld.w	r5,r8[0x0]
80006e48:	50 6e       	stdsp	sp[0x18],lr
80006e4a:	58 0b       	cp.w	r11,0
80006e4c:	f4 0b 17 00 	moveq	r11,r10
80006e50:	68 03       	ld.w	r3,r4[0x0]
80006e52:	68 11       	ld.w	r1,r4[0x4]
80006e54:	40 49       	lddsp	r9,sp[0x10]
80006e56:	30 08       	mov	r8,0
80006e58:	c2 89       	rjmp	800070a8 <get_arg+0x274>
80006e5a:	2f fb       	sub	r11,-1
80006e5c:	32 5c       	mov	r12,37
80006e5e:	17 8a       	ld.ub	r10,r11[0x0]
80006e60:	f8 0a 18 00 	cp.b	r10,r12
80006e64:	5f 1e       	srne	lr
80006e66:	f0 0a 18 00 	cp.b	r10,r8
80006e6a:	5f 1c       	srne	r12
80006e6c:	fd ec 00 0c 	and	r12,lr,r12
80006e70:	f0 0c 18 00 	cp.b	r12,r8
80006e74:	cf 31       	brne	80006e5a <get_arg+0x26>
80006e76:	58 0a       	cp.w	r10,0
80006e78:	e0 80 01 25 	breq	800070c2 <get_arg+0x28e>
80006e7c:	30 0c       	mov	r12,0
80006e7e:	3f fa       	mov	r10,-1
80006e80:	18 90       	mov	r0,r12
80006e82:	50 3a       	stdsp	sp[0xc],r10
80006e84:	18 94       	mov	r4,r12
80006e86:	18 92       	mov	r2,r12
80006e88:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006e8c:	16 97       	mov	r7,r11
80006e8e:	50 7c       	stdsp	sp[0x1c],r12
80006e90:	fe cc a0 38 	sub	r12,pc,-24520
80006e94:	0f 3a       	ld.ub	r10,r7++
80006e96:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006e9a:	40 7c       	lddsp	r12,sp[0x1c]
80006e9c:	1c 0c       	add	r12,lr
80006e9e:	fe ce a1 0e 	sub	lr,pc,-24306
80006ea2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006ea6:	20 1e       	sub	lr,1
80006ea8:	50 0e       	stdsp	sp[0x0],lr
80006eaa:	fe ce a1 86 	sub	lr,pc,-24186
80006eae:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006eb2:	50 7c       	stdsp	sp[0x1c],r12
80006eb4:	40 0c       	lddsp	r12,sp[0x0]
80006eb6:	58 7c       	cp.w	r12,7
80006eb8:	e0 8b 00 f1 	brhi	8000709a <get_arg+0x266>
80006ebc:	fe ce a3 38 	sub	lr,pc,-23752
80006ec0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006ec4:	36 8b       	mov	r11,104
80006ec6:	f6 0a 18 00 	cp.b	r10,r11
80006eca:	e0 80 00 e8 	breq	8000709a <get_arg+0x266>
80006ece:	37 1b       	mov	r11,113
80006ed0:	f6 0a 18 00 	cp.b	r10,r11
80006ed4:	c0 70       	breq	80006ee2 <get_arg+0xae>
80006ed6:	34 cb       	mov	r11,76
80006ed8:	f6 0a 18 00 	cp.b	r10,r11
80006edc:	c0 51       	brne	80006ee6 <get_arg+0xb2>
80006ede:	a3 b4       	sbr	r4,0x3
80006ee0:	cd d8       	rjmp	8000709a <get_arg+0x266>
80006ee2:	a5 b4       	sbr	r4,0x5
80006ee4:	cd b8       	rjmp	8000709a <get_arg+0x266>
80006ee6:	08 9a       	mov	r10,r4
80006ee8:	0e 9b       	mov	r11,r7
80006eea:	a5 aa       	sbr	r10,0x4
80006eec:	17 3c       	ld.ub	r12,r11++
80006eee:	a5 b4       	sbr	r4,0x5
80006ef0:	36 ce       	mov	lr,108
80006ef2:	fc 0c 18 00 	cp.b	r12,lr
80006ef6:	e0 80 00 d3 	breq	8000709c <get_arg+0x268>
80006efa:	14 94       	mov	r4,r10
80006efc:	cc f8       	rjmp	8000709a <get_arg+0x266>
80006efe:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006f02:	36 7c       	mov	r12,103
80006f04:	f8 0a 18 00 	cp.b	r10,r12
80006f08:	e0 8b 00 27 	brhi	80006f56 <get_arg+0x122>
80006f0c:	36 5b       	mov	r11,101
80006f0e:	f6 0a 18 00 	cp.b	r10,r11
80006f12:	c4 82       	brcc	80006fa2 <get_arg+0x16e>
80006f14:	34 fb       	mov	r11,79
80006f16:	f6 0a 18 00 	cp.b	r10,r11
80006f1a:	c4 80       	breq	80006faa <get_arg+0x176>
80006f1c:	e0 8b 00 0c 	brhi	80006f34 <get_arg+0x100>
80006f20:	34 5b       	mov	r11,69
80006f22:	f6 0a 18 00 	cp.b	r10,r11
80006f26:	c3 e0       	breq	80006fa2 <get_arg+0x16e>
80006f28:	34 7b       	mov	r11,71
80006f2a:	f6 0a 18 00 	cp.b	r10,r11
80006f2e:	c3 a0       	breq	80006fa2 <get_arg+0x16e>
80006f30:	34 4b       	mov	r11,68
80006f32:	c0 88       	rjmp	80006f42 <get_arg+0x10e>
80006f34:	35 8b       	mov	r11,88
80006f36:	f6 0a 18 00 	cp.b	r10,r11
80006f3a:	c2 c0       	breq	80006f92 <get_arg+0x15e>
80006f3c:	e0 8b 00 07 	brhi	80006f4a <get_arg+0x116>
80006f40:	35 5b       	mov	r11,85
80006f42:	f6 0a 18 00 	cp.b	r10,r11
80006f46:	c3 51       	brne	80006fb0 <get_arg+0x17c>
80006f48:	c3 18       	rjmp	80006faa <get_arg+0x176>
80006f4a:	36 3b       	mov	r11,99
80006f4c:	f6 0a 18 00 	cp.b	r10,r11
80006f50:	c2 f0       	breq	80006fae <get_arg+0x17a>
80006f52:	36 4b       	mov	r11,100
80006f54:	c0 e8       	rjmp	80006f70 <get_arg+0x13c>
80006f56:	37 0b       	mov	r11,112
80006f58:	f6 0a 18 00 	cp.b	r10,r11
80006f5c:	c2 50       	breq	80006fa6 <get_arg+0x172>
80006f5e:	e0 8b 00 0d 	brhi	80006f78 <get_arg+0x144>
80006f62:	36 eb       	mov	r11,110
80006f64:	f6 0a 18 00 	cp.b	r10,r11
80006f68:	c1 f0       	breq	80006fa6 <get_arg+0x172>
80006f6a:	e0 8b 00 14 	brhi	80006f92 <get_arg+0x15e>
80006f6e:	36 9b       	mov	r11,105
80006f70:	f6 0a 18 00 	cp.b	r10,r11
80006f74:	c1 e1       	brne	80006fb0 <get_arg+0x17c>
80006f76:	c0 e8       	rjmp	80006f92 <get_arg+0x15e>
80006f78:	37 5b       	mov	r11,117
80006f7a:	f6 0a 18 00 	cp.b	r10,r11
80006f7e:	c0 a0       	breq	80006f92 <get_arg+0x15e>
80006f80:	37 8b       	mov	r11,120
80006f82:	f6 0a 18 00 	cp.b	r10,r11
80006f86:	c0 60       	breq	80006f92 <get_arg+0x15e>
80006f88:	37 3b       	mov	r11,115
80006f8a:	f6 0a 18 00 	cp.b	r10,r11
80006f8e:	c1 11       	brne	80006fb0 <get_arg+0x17c>
80006f90:	c0 b8       	rjmp	80006fa6 <get_arg+0x172>
80006f92:	ed b4 00 04 	bld	r4,0x4
80006f96:	c0 a0       	breq	80006faa <get_arg+0x176>
80006f98:	ed b4 00 05 	bld	r4,0x5
80006f9c:	c0 91       	brne	80006fae <get_arg+0x17a>
80006f9e:	30 20       	mov	r0,2
80006fa0:	c0 88       	rjmp	80006fb0 <get_arg+0x17c>
80006fa2:	30 40       	mov	r0,4
80006fa4:	c0 68       	rjmp	80006fb0 <get_arg+0x17c>
80006fa6:	30 30       	mov	r0,3
80006fa8:	c0 48       	rjmp	80006fb0 <get_arg+0x17c>
80006faa:	30 10       	mov	r0,1
80006fac:	c0 28       	rjmp	80006fb0 <get_arg+0x17c>
80006fae:	30 00       	mov	r0,0
80006fb0:	40 3b       	lddsp	r11,sp[0xc]
80006fb2:	5b fb       	cp.w	r11,-1
80006fb4:	c0 40       	breq	80006fbc <get_arg+0x188>
80006fb6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006fba:	c7 08       	rjmp	8000709a <get_arg+0x266>
80006fbc:	58 60       	cp.w	r0,6
80006fbe:	e0 8b 00 6e 	brhi	8000709a <get_arg+0x266>
80006fc2:	6c 0a       	ld.w	r10,r6[0x0]
80006fc4:	ea cc ff ff 	sub	r12,r5,-1
80006fc8:	fe ce a4 24 	sub	lr,pc,-23516
80006fcc:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006fd0:	f4 cb ff f8 	sub	r11,r10,-8
80006fd4:	8d 0b       	st.w	r6[0x0],r11
80006fd6:	f4 ea 00 00 	ld.d	r10,r10[0]
80006fda:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006fde:	c0 f8       	rjmp	80006ffc <get_arg+0x1c8>
80006fe0:	f4 cb ff fc 	sub	r11,r10,-4
80006fe4:	8d 0b       	st.w	r6[0x0],r11
80006fe6:	74 0a       	ld.w	r10,r10[0x0]
80006fe8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006fec:	c0 88       	rjmp	80006ffc <get_arg+0x1c8>
80006fee:	f4 cb ff f8 	sub	r11,r10,-8
80006ff2:	8d 0b       	st.w	r6[0x0],r11
80006ff4:	f4 ea 00 00 	ld.d	r10,r10[0]
80006ff8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006ffc:	0e 9b       	mov	r11,r7
80006ffe:	18 95       	mov	r5,r12
80007000:	c4 e8       	rjmp	8000709c <get_arg+0x268>
80007002:	62 0a       	ld.w	r10,r1[0x0]
80007004:	5b fa       	cp.w	r10,-1
80007006:	c0 b1       	brne	8000701c <get_arg+0x1e8>
80007008:	50 19       	stdsp	sp[0x4],r9
8000700a:	50 28       	stdsp	sp[0x8],r8
8000700c:	e0 6a 00 80 	mov	r10,128
80007010:	30 0b       	mov	r11,0
80007012:	02 9c       	mov	r12,r1
80007014:	fe b0 fd 00 	rcall	80006a14 <memset>
80007018:	40 28       	lddsp	r8,sp[0x8]
8000701a:	40 19       	lddsp	r9,sp[0x4]
8000701c:	e4 cc 00 01 	sub	r12,r2,1
80007020:	0e 9b       	mov	r11,r7
80007022:	50 3c       	stdsp	sp[0xc],r12
80007024:	f2 0c 0c 49 	max	r9,r9,r12
80007028:	c3 a8       	rjmp	8000709c <get_arg+0x268>
8000702a:	62 0a       	ld.w	r10,r1[0x0]
8000702c:	5b fa       	cp.w	r10,-1
8000702e:	c0 b1       	brne	80007044 <get_arg+0x210>
80007030:	50 19       	stdsp	sp[0x4],r9
80007032:	50 28       	stdsp	sp[0x8],r8
80007034:	e0 6a 00 80 	mov	r10,128
80007038:	30 0b       	mov	r11,0
8000703a:	02 9c       	mov	r12,r1
8000703c:	fe b0 fc ec 	rcall	80006a14 <memset>
80007040:	40 28       	lddsp	r8,sp[0x8]
80007042:	40 19       	lddsp	r9,sp[0x4]
80007044:	20 12       	sub	r2,1
80007046:	30 0a       	mov	r10,0
80007048:	0e 9b       	mov	r11,r7
8000704a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000704e:	f2 02 0c 49 	max	r9,r9,r2
80007052:	c2 58       	rjmp	8000709c <get_arg+0x268>
80007054:	16 97       	mov	r7,r11
80007056:	6c 0a       	ld.w	r10,r6[0x0]
80007058:	f4 cb ff fc 	sub	r11,r10,-4
8000705c:	8d 0b       	st.w	r6[0x0],r11
8000705e:	74 0a       	ld.w	r10,r10[0x0]
80007060:	0e 9b       	mov	r11,r7
80007062:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007066:	2f f5       	sub	r5,-1
80007068:	c1 a8       	rjmp	8000709c <get_arg+0x268>
8000706a:	f4 c2 00 30 	sub	r2,r10,48
8000706e:	c0 68       	rjmp	8000707a <get_arg+0x246>
80007070:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007074:	2f f7       	sub	r7,-1
80007076:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000707a:	0f 8a       	ld.ub	r10,r7[0x0]
8000707c:	58 0a       	cp.w	r10,0
8000707e:	c0 e0       	breq	8000709a <get_arg+0x266>
80007080:	23 0a       	sub	r10,48
80007082:	58 9a       	cp.w	r10,9
80007084:	fe 98 ff f6 	brls	80007070 <get_arg+0x23c>
80007088:	c0 98       	rjmp	8000709a <get_arg+0x266>
8000708a:	2f f7       	sub	r7,-1
8000708c:	0f 8a       	ld.ub	r10,r7[0x0]
8000708e:	58 0a       	cp.w	r10,0
80007090:	c0 50       	breq	8000709a <get_arg+0x266>
80007092:	23 0a       	sub	r10,48
80007094:	58 9a       	cp.w	r10,9
80007096:	fe 98 ff fa 	brls	8000708a <get_arg+0x256>
8000709a:	0e 9b       	mov	r11,r7
8000709c:	40 7c       	lddsp	r12,sp[0x1c]
8000709e:	30 ba       	mov	r10,11
800070a0:	f4 0c 18 00 	cp.b	r12,r10
800070a4:	fe 91 fe f2 	brne	80006e88 <get_arg+0x54>
800070a8:	40 42       	lddsp	r2,sp[0x10]
800070aa:	17 8c       	ld.ub	r12,r11[0x0]
800070ac:	0a 32       	cp.w	r2,r5
800070ae:	5f 4a       	srge	r10
800070b0:	f0 0c 18 00 	cp.b	r12,r8
800070b4:	5f 1c       	srne	r12
800070b6:	f9 ea 00 0a 	and	r10,r12,r10
800070ba:	f0 0a 18 00 	cp.b	r10,r8
800070be:	fe 91 fe cf 	brne	80006e5c <get_arg+0x28>
800070c2:	30 08       	mov	r8,0
800070c4:	40 4e       	lddsp	lr,sp[0x10]
800070c6:	17 8a       	ld.ub	r10,r11[0x0]
800070c8:	e2 05 00 21 	add	r1,r1,r5<<0x2
800070cc:	f0 0a 18 00 	cp.b	r10,r8
800070d0:	fc 09 17 10 	movne	r9,lr
800070d4:	e6 05 00 38 	add	r8,r3,r5<<0x3
800070d8:	06 9e       	mov	lr,r3
800070da:	c2 a8       	rjmp	8000712e <get_arg+0x2fa>
800070dc:	62 0a       	ld.w	r10,r1[0x0]
800070de:	58 3a       	cp.w	r10,3
800070e0:	c1 e0       	breq	8000711c <get_arg+0x2e8>
800070e2:	e0 89 00 07 	brgt	800070f0 <get_arg+0x2bc>
800070e6:	58 1a       	cp.w	r10,1
800070e8:	c1 a0       	breq	8000711c <get_arg+0x2e8>
800070ea:	58 2a       	cp.w	r10,2
800070ec:	c1 81       	brne	8000711c <get_arg+0x2e8>
800070ee:	c0 58       	rjmp	800070f8 <get_arg+0x2c4>
800070f0:	58 5a       	cp.w	r10,5
800070f2:	c0 c0       	breq	8000710a <get_arg+0x2d6>
800070f4:	c0 b5       	brlt	8000710a <get_arg+0x2d6>
800070f6:	c1 38       	rjmp	8000711c <get_arg+0x2e8>
800070f8:	6c 0a       	ld.w	r10,r6[0x0]
800070fa:	f4 cc ff f8 	sub	r12,r10,-8
800070fe:	8d 0c       	st.w	r6[0x0],r12
80007100:	f4 e2 00 00 	ld.d	r2,r10[0]
80007104:	f0 e3 00 00 	st.d	r8[0],r2
80007108:	c1 08       	rjmp	80007128 <get_arg+0x2f4>
8000710a:	6c 0a       	ld.w	r10,r6[0x0]
8000710c:	f4 cc ff f8 	sub	r12,r10,-8
80007110:	8d 0c       	st.w	r6[0x0],r12
80007112:	f4 e2 00 00 	ld.d	r2,r10[0]
80007116:	f0 e3 00 00 	st.d	r8[0],r2
8000711a:	c0 78       	rjmp	80007128 <get_arg+0x2f4>
8000711c:	6c 0a       	ld.w	r10,r6[0x0]
8000711e:	f4 cc ff fc 	sub	r12,r10,-4
80007122:	8d 0c       	st.w	r6[0x0],r12
80007124:	74 0a       	ld.w	r10,r10[0x0]
80007126:	91 0a       	st.w	r8[0x0],r10
80007128:	2f f5       	sub	r5,-1
8000712a:	2f 88       	sub	r8,-8
8000712c:	2f c1       	sub	r1,-4
8000712e:	12 35       	cp.w	r5,r9
80007130:	fe 9a ff d6 	brle	800070dc <get_arg+0x2a8>
80007134:	1c 93       	mov	r3,lr
80007136:	40 52       	lddsp	r2,sp[0x14]
80007138:	40 6e       	lddsp	lr,sp[0x18]
8000713a:	85 05       	st.w	r2[0x0],r5
8000713c:	9d 0b       	st.w	lr[0x0],r11
8000713e:	40 4b       	lddsp	r11,sp[0x10]
80007140:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007144:	2f 8d       	sub	sp,-32
80007146:	d8 32       	popm	r0-r7,pc

80007148 <__sprint_r>:
80007148:	d4 21       	pushm	r4-r7,lr
8000714a:	14 97       	mov	r7,r10
8000714c:	74 28       	ld.w	r8,r10[0x8]
8000714e:	58 08       	cp.w	r8,0
80007150:	c0 41       	brne	80007158 <__sprint_r+0x10>
80007152:	95 18       	st.w	r10[0x4],r8
80007154:	10 9c       	mov	r12,r8
80007156:	d8 22       	popm	r4-r7,pc
80007158:	e0 a0 18 ba 	rcall	8000a2cc <__sfvwrite_r>
8000715c:	30 08       	mov	r8,0
8000715e:	8f 18       	st.w	r7[0x4],r8
80007160:	8f 28       	st.w	r7[0x8],r8
80007162:	d8 22       	popm	r4-r7,pc

80007164 <_vfprintf_r>:
80007164:	d4 31       	pushm	r0-r7,lr
80007166:	fa cd 06 bc 	sub	sp,sp,1724
8000716a:	51 09       	stdsp	sp[0x40],r9
8000716c:	16 91       	mov	r1,r11
8000716e:	14 97       	mov	r7,r10
80007170:	18 95       	mov	r5,r12
80007172:	e0 a0 1a 1d 	rcall	8000a5ac <_localeconv_r>
80007176:	78 0c       	ld.w	r12,r12[0x0]
80007178:	50 cc       	stdsp	sp[0x30],r12
8000717a:	58 05       	cp.w	r5,0
8000717c:	c0 70       	breq	8000718a <_vfprintf_r+0x26>
8000717e:	6a 68       	ld.w	r8,r5[0x18]
80007180:	58 08       	cp.w	r8,0
80007182:	c0 41       	brne	8000718a <_vfprintf_r+0x26>
80007184:	0a 9c       	mov	r12,r5
80007186:	e0 a0 17 43 	rcall	8000a00c <__sinit>
8000718a:	fe c8 a2 22 	sub	r8,pc,-24030
8000718e:	10 31       	cp.w	r1,r8
80007190:	c0 31       	brne	80007196 <_vfprintf_r+0x32>
80007192:	6a 01       	ld.w	r1,r5[0x0]
80007194:	c0 c8       	rjmp	800071ac <_vfprintf_r+0x48>
80007196:	fe c8 a2 0e 	sub	r8,pc,-24050
8000719a:	10 31       	cp.w	r1,r8
8000719c:	c0 31       	brne	800071a2 <_vfprintf_r+0x3e>
8000719e:	6a 11       	ld.w	r1,r5[0x4]
800071a0:	c0 68       	rjmp	800071ac <_vfprintf_r+0x48>
800071a2:	fe c8 a1 fa 	sub	r8,pc,-24070
800071a6:	10 31       	cp.w	r1,r8
800071a8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800071ac:	82 68       	ld.sh	r8,r1[0xc]
800071ae:	ed b8 00 03 	bld	r8,0x3
800071b2:	c0 41       	brne	800071ba <_vfprintf_r+0x56>
800071b4:	62 48       	ld.w	r8,r1[0x10]
800071b6:	58 08       	cp.w	r8,0
800071b8:	c0 71       	brne	800071c6 <_vfprintf_r+0x62>
800071ba:	02 9b       	mov	r11,r1
800071bc:	0a 9c       	mov	r12,r5
800071be:	e0 a0 0f 5d 	rcall	80009078 <__swsetup_r>
800071c2:	e0 81 0f 54 	brne	8000906a <_vfprintf_r+0x1f06>
800071c6:	82 68       	ld.sh	r8,r1[0xc]
800071c8:	10 99       	mov	r9,r8
800071ca:	e2 19 00 1a 	andl	r9,0x1a,COH
800071ce:	58 a9       	cp.w	r9,10
800071d0:	c3 c1       	brne	80007248 <_vfprintf_r+0xe4>
800071d2:	82 79       	ld.sh	r9,r1[0xe]
800071d4:	30 0a       	mov	r10,0
800071d6:	f4 09 19 00 	cp.h	r9,r10
800071da:	c3 75       	brlt	80007248 <_vfprintf_r+0xe4>
800071dc:	a1 d8       	cbr	r8,0x1
800071de:	fb 58 05 d0 	st.h	sp[1488],r8
800071e2:	62 88       	ld.w	r8,r1[0x20]
800071e4:	fb 48 05 e4 	st.w	sp[1508],r8
800071e8:	62 a8       	ld.w	r8,r1[0x28]
800071ea:	fb 48 05 ec 	st.w	sp[1516],r8
800071ee:	fa c8 ff bc 	sub	r8,sp,-68
800071f2:	fb 48 05 d4 	st.w	sp[1492],r8
800071f6:	fb 48 05 c4 	st.w	sp[1476],r8
800071fa:	e0 68 04 00 	mov	r8,1024
800071fe:	fb 48 05 d8 	st.w	sp[1496],r8
80007202:	fb 48 05 cc 	st.w	sp[1484],r8
80007206:	30 08       	mov	r8,0
80007208:	fb 59 05 d2 	st.h	sp[1490],r9
8000720c:	0e 9a       	mov	r10,r7
8000720e:	41 09       	lddsp	r9,sp[0x40]
80007210:	fa c7 fa 3c 	sub	r7,sp,-1476
80007214:	fb 48 05 dc 	st.w	sp[1500],r8
80007218:	0a 9c       	mov	r12,r5
8000721a:	0e 9b       	mov	r11,r7
8000721c:	ca 4f       	rcall	80007164 <_vfprintf_r>
8000721e:	50 bc       	stdsp	sp[0x2c],r12
80007220:	c0 95       	brlt	80007232 <_vfprintf_r+0xce>
80007222:	0e 9b       	mov	r11,r7
80007224:	0a 9c       	mov	r12,r5
80007226:	e0 a0 16 1b 	rcall	80009e5c <_fflush_r>
8000722a:	40 be       	lddsp	lr,sp[0x2c]
8000722c:	f9 be 01 ff 	movne	lr,-1
80007230:	50 be       	stdsp	sp[0x2c],lr
80007232:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007236:	ed b8 00 06 	bld	r8,0x6
8000723a:	e0 81 0f 1a 	brne	8000906e <_vfprintf_r+0x1f0a>
8000723e:	82 68       	ld.sh	r8,r1[0xc]
80007240:	a7 a8       	sbr	r8,0x6
80007242:	a2 68       	st.h	r1[0xc],r8
80007244:	e0 8f 0f 15 	bral	8000906e <_vfprintf_r+0x1f0a>
80007248:	30 08       	mov	r8,0
8000724a:	fb 48 06 b4 	st.w	sp[1716],r8
8000724e:	fb 48 06 90 	st.w	sp[1680],r8
80007252:	fb 48 06 8c 	st.w	sp[1676],r8
80007256:	fb 48 06 b0 	st.w	sp[1712],r8
8000725a:	30 08       	mov	r8,0
8000725c:	30 09       	mov	r9,0
8000725e:	50 a7       	stdsp	sp[0x28],r7
80007260:	50 78       	stdsp	sp[0x1c],r8
80007262:	fa c3 f9 e0 	sub	r3,sp,-1568
80007266:	3f f8       	mov	r8,-1
80007268:	50 59       	stdsp	sp[0x14],r9
8000726a:	fb 43 06 88 	st.w	sp[1672],r3
8000726e:	fb 48 05 44 	st.w	sp[1348],r8
80007272:	12 9c       	mov	r12,r9
80007274:	50 69       	stdsp	sp[0x18],r9
80007276:	50 d9       	stdsp	sp[0x34],r9
80007278:	50 e9       	stdsp	sp[0x38],r9
8000727a:	50 b9       	stdsp	sp[0x2c],r9
8000727c:	12 97       	mov	r7,r9
8000727e:	0a 94       	mov	r4,r5
80007280:	40 a2       	lddsp	r2,sp[0x28]
80007282:	32 5a       	mov	r10,37
80007284:	30 08       	mov	r8,0
80007286:	c0 28       	rjmp	8000728a <_vfprintf_r+0x126>
80007288:	2f f2       	sub	r2,-1
8000728a:	05 89       	ld.ub	r9,r2[0x0]
8000728c:	f0 09 18 00 	cp.b	r9,r8
80007290:	5f 1b       	srne	r11
80007292:	f4 09 18 00 	cp.b	r9,r10
80007296:	5f 19       	srne	r9
80007298:	f3 eb 00 0b 	and	r11,r9,r11
8000729c:	f0 0b 18 00 	cp.b	r11,r8
800072a0:	cf 41       	brne	80007288 <_vfprintf_r+0x124>
800072a2:	40 ab       	lddsp	r11,sp[0x28]
800072a4:	e4 0b 01 06 	sub	r6,r2,r11
800072a8:	c1 e0       	breq	800072e4 <_vfprintf_r+0x180>
800072aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800072ae:	0c 08       	add	r8,r6
800072b0:	87 0b       	st.w	r3[0x0],r11
800072b2:	fb 48 06 90 	st.w	sp[1680],r8
800072b6:	87 16       	st.w	r3[0x4],r6
800072b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800072bc:	2f f8       	sub	r8,-1
800072be:	fb 48 06 8c 	st.w	sp[1676],r8
800072c2:	58 78       	cp.w	r8,7
800072c4:	e0 89 00 04 	brgt	800072cc <_vfprintf_r+0x168>
800072c8:	2f 83       	sub	r3,-8
800072ca:	c0 a8       	rjmp	800072de <_vfprintf_r+0x17a>
800072cc:	fa ca f9 78 	sub	r10,sp,-1672
800072d0:	02 9b       	mov	r11,r1
800072d2:	08 9c       	mov	r12,r4
800072d4:	c3 af       	rcall	80007148 <__sprint_r>
800072d6:	e0 81 0e c6 	brne	80009062 <_vfprintf_r+0x1efe>
800072da:	fa c3 f9 e0 	sub	r3,sp,-1568
800072de:	40 ba       	lddsp	r10,sp[0x2c]
800072e0:	0c 0a       	add	r10,r6
800072e2:	50 ba       	stdsp	sp[0x2c],r10
800072e4:	05 89       	ld.ub	r9,r2[0x0]
800072e6:	30 08       	mov	r8,0
800072e8:	f0 09 18 00 	cp.b	r9,r8
800072ec:	e0 80 0e aa 	breq	80009040 <_vfprintf_r+0x1edc>
800072f0:	30 09       	mov	r9,0
800072f2:	fb 68 06 bb 	st.b	sp[1723],r8
800072f6:	0e 96       	mov	r6,r7
800072f8:	e4 c8 ff ff 	sub	r8,r2,-1
800072fc:	3f fe       	mov	lr,-1
800072fe:	50 93       	stdsp	sp[0x24],r3
80007300:	50 41       	stdsp	sp[0x10],r1
80007302:	0e 93       	mov	r3,r7
80007304:	04 91       	mov	r1,r2
80007306:	50 89       	stdsp	sp[0x20],r9
80007308:	50 a8       	stdsp	sp[0x28],r8
8000730a:	50 2e       	stdsp	sp[0x8],lr
8000730c:	50 39       	stdsp	sp[0xc],r9
8000730e:	12 95       	mov	r5,r9
80007310:	12 90       	mov	r0,r9
80007312:	10 97       	mov	r7,r8
80007314:	08 92       	mov	r2,r4
80007316:	c0 78       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007318:	3f fc       	mov	r12,-1
8000731a:	08 97       	mov	r7,r4
8000731c:	50 2c       	stdsp	sp[0x8],r12
8000731e:	c0 38       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007320:	30 0b       	mov	r11,0
80007322:	50 3b       	stdsp	sp[0xc],r11
80007324:	0f 38       	ld.ub	r8,r7++
80007326:	c0 28       	rjmp	8000732a <_vfprintf_r+0x1c6>
80007328:	12 90       	mov	r0,r9
8000732a:	f0 c9 00 20 	sub	r9,r8,32
8000732e:	e0 49 00 58 	cp.w	r9,88
80007332:	e0 8b 0a 30 	brhi	80008792 <_vfprintf_r+0x162e>
80007336:	fe ca a7 76 	sub	r10,pc,-22666
8000733a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000733e:	50 a7       	stdsp	sp[0x28],r7
80007340:	50 80       	stdsp	sp[0x20],r0
80007342:	0c 97       	mov	r7,r6
80007344:	04 94       	mov	r4,r2
80007346:	06 96       	mov	r6,r3
80007348:	02 92       	mov	r2,r1
8000734a:	fe c9 a5 4e 	sub	r9,pc,-23218
8000734e:	40 93       	lddsp	r3,sp[0x24]
80007350:	10 90       	mov	r0,r8
80007352:	40 41       	lddsp	r1,sp[0x10]
80007354:	50 d9       	stdsp	sp[0x34],r9
80007356:	e0 8f 08 8e 	bral	80008472 <_vfprintf_r+0x130e>
8000735a:	30 08       	mov	r8,0
8000735c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007360:	f0 09 18 00 	cp.b	r9,r8
80007364:	ce 01       	brne	80007324 <_vfprintf_r+0x1c0>
80007366:	32 08       	mov	r8,32
80007368:	c6 e8       	rjmp	80007444 <_vfprintf_r+0x2e0>
8000736a:	a1 a5       	sbr	r5,0x0
8000736c:	cd cb       	rjmp	80007324 <_vfprintf_r+0x1c0>
8000736e:	0f 89       	ld.ub	r9,r7[0x0]
80007370:	f2 c8 00 30 	sub	r8,r9,48
80007374:	58 98       	cp.w	r8,9
80007376:	e0 8b 00 1d 	brhi	800073b0 <_vfprintf_r+0x24c>
8000737a:	ee c8 ff ff 	sub	r8,r7,-1
8000737e:	30 0b       	mov	r11,0
80007380:	23 09       	sub	r9,48
80007382:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007386:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000738a:	11 39       	ld.ub	r9,r8++
8000738c:	f2 ca 00 30 	sub	r10,r9,48
80007390:	58 9a       	cp.w	r10,9
80007392:	fe 98 ff f7 	brls	80007380 <_vfprintf_r+0x21c>
80007396:	e0 49 00 24 	cp.w	r9,36
8000739a:	cc 31       	brne	80007320 <_vfprintf_r+0x1bc>
8000739c:	e0 4b 00 20 	cp.w	r11,32
800073a0:	e0 89 0e 60 	brgt	80009060 <_vfprintf_r+0x1efc>
800073a4:	20 1b       	sub	r11,1
800073a6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800073aa:	12 3b       	cp.w	r11,r9
800073ac:	c0 95       	brlt	800073be <_vfprintf_r+0x25a>
800073ae:	c1 08       	rjmp	800073ce <_vfprintf_r+0x26a>
800073b0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800073b4:	ec ca ff ff 	sub	r10,r6,-1
800073b8:	12 36       	cp.w	r6,r9
800073ba:	c1 f5       	brlt	800073f8 <_vfprintf_r+0x294>
800073bc:	c2 68       	rjmp	80007408 <_vfprintf_r+0x2a4>
800073be:	fa ce f9 44 	sub	lr,sp,-1724
800073c2:	10 97       	mov	r7,r8
800073c4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800073c8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800073cc:	c3 58       	rjmp	80007436 <_vfprintf_r+0x2d2>
800073ce:	10 97       	mov	r7,r8
800073d0:	fa c8 f9 50 	sub	r8,sp,-1712
800073d4:	1a d8       	st.w	--sp,r8
800073d6:	fa c8 fa b8 	sub	r8,sp,-1352
800073da:	1a d8       	st.w	--sp,r8
800073dc:	fa c8 fb b4 	sub	r8,sp,-1100
800073e0:	02 9a       	mov	r10,r1
800073e2:	1a d8       	st.w	--sp,r8
800073e4:	04 9c       	mov	r12,r2
800073e6:	fa c8 f9 40 	sub	r8,sp,-1728
800073ea:	fa c9 ff b4 	sub	r9,sp,-76
800073ee:	fe b0 fd 23 	rcall	80006e34 <get_arg>
800073f2:	2f dd       	sub	sp,-12
800073f4:	78 00       	ld.w	r0,r12[0x0]
800073f6:	c2 08       	rjmp	80007436 <_vfprintf_r+0x2d2>
800073f8:	fa cc f9 44 	sub	r12,sp,-1724
800073fc:	14 96       	mov	r6,r10
800073fe:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007402:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007406:	c1 88       	rjmp	80007436 <_vfprintf_r+0x2d2>
80007408:	41 08       	lddsp	r8,sp[0x40]
8000740a:	59 f9       	cp.w	r9,31
8000740c:	e0 89 00 11 	brgt	8000742e <_vfprintf_r+0x2ca>
80007410:	f0 cb ff fc 	sub	r11,r8,-4
80007414:	51 0b       	stdsp	sp[0x40],r11
80007416:	70 00       	ld.w	r0,r8[0x0]
80007418:	fa cb f9 44 	sub	r11,sp,-1724
8000741c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007420:	f1 40 fd 88 	st.w	r8[-632],r0
80007424:	2f f9       	sub	r9,-1
80007426:	14 96       	mov	r6,r10
80007428:	fb 49 06 b4 	st.w	sp[1716],r9
8000742c:	c0 58       	rjmp	80007436 <_vfprintf_r+0x2d2>
8000742e:	70 00       	ld.w	r0,r8[0x0]
80007430:	14 96       	mov	r6,r10
80007432:	2f c8       	sub	r8,-4
80007434:	51 08       	stdsp	sp[0x40],r8
80007436:	58 00       	cp.w	r0,0
80007438:	fe 94 ff 76 	brge	80007324 <_vfprintf_r+0x1c0>
8000743c:	5c 30       	neg	r0
8000743e:	a3 a5       	sbr	r5,0x2
80007440:	c7 2b       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007442:	32 b8       	mov	r8,43
80007444:	fb 68 06 bb 	st.b	sp[1723],r8
80007448:	c6 eb       	rjmp	80007324 <_vfprintf_r+0x1c0>
8000744a:	0f 38       	ld.ub	r8,r7++
8000744c:	e0 48 00 2a 	cp.w	r8,42
80007450:	c0 30       	breq	80007456 <_vfprintf_r+0x2f2>
80007452:	30 09       	mov	r9,0
80007454:	c7 98       	rjmp	80007546 <_vfprintf_r+0x3e2>
80007456:	0f 88       	ld.ub	r8,r7[0x0]
80007458:	f0 c9 00 30 	sub	r9,r8,48
8000745c:	58 99       	cp.w	r9,9
8000745e:	e0 8b 00 1f 	brhi	8000749c <_vfprintf_r+0x338>
80007462:	ee c4 ff ff 	sub	r4,r7,-1
80007466:	30 0b       	mov	r11,0
80007468:	23 08       	sub	r8,48
8000746a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000746e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007472:	09 38       	ld.ub	r8,r4++
80007474:	f0 c9 00 30 	sub	r9,r8,48
80007478:	58 99       	cp.w	r9,9
8000747a:	fe 98 ff f7 	brls	80007468 <_vfprintf_r+0x304>
8000747e:	e0 48 00 24 	cp.w	r8,36
80007482:	fe 91 ff 4f 	brne	80007320 <_vfprintf_r+0x1bc>
80007486:	e0 4b 00 20 	cp.w	r11,32
8000748a:	e0 89 0d eb 	brgt	80009060 <_vfprintf_r+0x1efc>
8000748e:	20 1b       	sub	r11,1
80007490:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007494:	10 3b       	cp.w	r11,r8
80007496:	c0 a5       	brlt	800074aa <_vfprintf_r+0x346>
80007498:	c1 18       	rjmp	800074ba <_vfprintf_r+0x356>
8000749a:	d7 03       	nop
8000749c:	fa fa 06 b4 	ld.w	r10,sp[1716]
800074a0:	ec c9 ff ff 	sub	r9,r6,-1
800074a4:	14 36       	cp.w	r6,r10
800074a6:	c1 f5       	brlt	800074e4 <_vfprintf_r+0x380>
800074a8:	c2 88       	rjmp	800074f8 <_vfprintf_r+0x394>
800074aa:	fa ca f9 44 	sub	r10,sp,-1724
800074ae:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800074b2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800074b6:	50 2b       	stdsp	sp[0x8],r11
800074b8:	c3 c8       	rjmp	80007530 <_vfprintf_r+0x3cc>
800074ba:	fa c8 f9 50 	sub	r8,sp,-1712
800074be:	1a d8       	st.w	--sp,r8
800074c0:	fa c8 fa b8 	sub	r8,sp,-1352
800074c4:	1a d8       	st.w	--sp,r8
800074c6:	fa c8 fb b4 	sub	r8,sp,-1100
800074ca:	02 9a       	mov	r10,r1
800074cc:	1a d8       	st.w	--sp,r8
800074ce:	04 9c       	mov	r12,r2
800074d0:	fa c8 f9 40 	sub	r8,sp,-1728
800074d4:	fa c9 ff b4 	sub	r9,sp,-76
800074d8:	fe b0 fc ae 	rcall	80006e34 <get_arg>
800074dc:	2f dd       	sub	sp,-12
800074de:	78 0c       	ld.w	r12,r12[0x0]
800074e0:	50 2c       	stdsp	sp[0x8],r12
800074e2:	c2 78       	rjmp	80007530 <_vfprintf_r+0x3cc>
800074e4:	12 96       	mov	r6,r9
800074e6:	0e 94       	mov	r4,r7
800074e8:	fa c9 f9 44 	sub	r9,sp,-1724
800074ec:	f2 03 00 38 	add	r8,r9,r3<<0x3
800074f0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800074f4:	50 28       	stdsp	sp[0x8],r8
800074f6:	c1 d8       	rjmp	80007530 <_vfprintf_r+0x3cc>
800074f8:	41 08       	lddsp	r8,sp[0x40]
800074fa:	59 fa       	cp.w	r10,31
800074fc:	e0 89 00 14 	brgt	80007524 <_vfprintf_r+0x3c0>
80007500:	f0 cb ff fc 	sub	r11,r8,-4
80007504:	70 08       	ld.w	r8,r8[0x0]
80007506:	51 0b       	stdsp	sp[0x40],r11
80007508:	50 28       	stdsp	sp[0x8],r8
8000750a:	fa c6 f9 44 	sub	r6,sp,-1724
8000750e:	40 2e       	lddsp	lr,sp[0x8]
80007510:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007514:	f1 4e fd 88 	st.w	r8[-632],lr
80007518:	2f fa       	sub	r10,-1
8000751a:	0e 94       	mov	r4,r7
8000751c:	fb 4a 06 b4 	st.w	sp[1716],r10
80007520:	12 96       	mov	r6,r9
80007522:	c0 78       	rjmp	80007530 <_vfprintf_r+0x3cc>
80007524:	70 0c       	ld.w	r12,r8[0x0]
80007526:	0e 94       	mov	r4,r7
80007528:	2f c8       	sub	r8,-4
8000752a:	50 2c       	stdsp	sp[0x8],r12
8000752c:	12 96       	mov	r6,r9
8000752e:	51 08       	stdsp	sp[0x40],r8
80007530:	40 2b       	lddsp	r11,sp[0x8]
80007532:	58 0b       	cp.w	r11,0
80007534:	fe 95 fe f2 	brlt	80007318 <_vfprintf_r+0x1b4>
80007538:	08 97       	mov	r7,r4
8000753a:	cf 5a       	rjmp	80007324 <_vfprintf_r+0x1c0>
8000753c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007540:	0f 38       	ld.ub	r8,r7++
80007542:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007546:	f0 ca 00 30 	sub	r10,r8,48
8000754a:	58 9a       	cp.w	r10,9
8000754c:	fe 98 ff f8 	brls	8000753c <_vfprintf_r+0x3d8>
80007550:	3f fa       	mov	r10,-1
80007552:	f2 0a 0c 49 	max	r9,r9,r10
80007556:	50 29       	stdsp	sp[0x8],r9
80007558:	ce 9a       	rjmp	8000732a <_vfprintf_r+0x1c6>
8000755a:	a7 b5       	sbr	r5,0x7
8000755c:	ce 4a       	rjmp	80007324 <_vfprintf_r+0x1c0>
8000755e:	30 09       	mov	r9,0
80007560:	23 08       	sub	r8,48
80007562:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007566:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000756a:	0f 38       	ld.ub	r8,r7++
8000756c:	f0 ca 00 30 	sub	r10,r8,48
80007570:	58 9a       	cp.w	r10,9
80007572:	fe 98 ff f7 	brls	80007560 <_vfprintf_r+0x3fc>
80007576:	e0 48 00 24 	cp.w	r8,36
8000757a:	fe 91 fe d7 	brne	80007328 <_vfprintf_r+0x1c4>
8000757e:	e0 49 00 20 	cp.w	r9,32
80007582:	e0 89 0d 6f 	brgt	80009060 <_vfprintf_r+0x1efc>
80007586:	f2 c3 00 01 	sub	r3,r9,1
8000758a:	30 19       	mov	r9,1
8000758c:	50 39       	stdsp	sp[0xc],r9
8000758e:	cc ba       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007590:	a3 b5       	sbr	r5,0x3
80007592:	cc 9a       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007594:	a7 a5       	sbr	r5,0x6
80007596:	cc 7a       	rjmp	80007324 <_vfprintf_r+0x1c0>
80007598:	0a 98       	mov	r8,r5
8000759a:	a5 b5       	sbr	r5,0x5
8000759c:	a5 a8       	sbr	r8,0x4
8000759e:	0f 89       	ld.ub	r9,r7[0x0]
800075a0:	36 ce       	mov	lr,108
800075a2:	fc 09 18 00 	cp.b	r9,lr
800075a6:	f7 b7 00 ff 	subeq	r7,-1
800075aa:	f0 05 17 10 	movne	r5,r8
800075ae:	cb ba       	rjmp	80007324 <_vfprintf_r+0x1c0>
800075b0:	a5 b5       	sbr	r5,0x5
800075b2:	cb 9a       	rjmp	80007324 <_vfprintf_r+0x1c0>
800075b4:	50 a7       	stdsp	sp[0x28],r7
800075b6:	50 80       	stdsp	sp[0x20],r0
800075b8:	0c 97       	mov	r7,r6
800075ba:	10 90       	mov	r0,r8
800075bc:	06 96       	mov	r6,r3
800075be:	04 94       	mov	r4,r2
800075c0:	40 93       	lddsp	r3,sp[0x24]
800075c2:	02 92       	mov	r2,r1
800075c4:	0e 99       	mov	r9,r7
800075c6:	40 41       	lddsp	r1,sp[0x10]
800075c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800075cc:	40 3c       	lddsp	r12,sp[0xc]
800075ce:	58 0c       	cp.w	r12,0
800075d0:	c1 d0       	breq	8000760a <_vfprintf_r+0x4a6>
800075d2:	10 36       	cp.w	r6,r8
800075d4:	c0 64       	brge	800075e0 <_vfprintf_r+0x47c>
800075d6:	fa cb f9 44 	sub	r11,sp,-1724
800075da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800075de:	c1 d8       	rjmp	80007618 <_vfprintf_r+0x4b4>
800075e0:	fa c8 f9 50 	sub	r8,sp,-1712
800075e4:	1a d8       	st.w	--sp,r8
800075e6:	fa c8 fa b8 	sub	r8,sp,-1352
800075ea:	1a d8       	st.w	--sp,r8
800075ec:	fa c8 fb b4 	sub	r8,sp,-1100
800075f0:	1a d8       	st.w	--sp,r8
800075f2:	fa c8 f9 40 	sub	r8,sp,-1728
800075f6:	fa c9 ff b4 	sub	r9,sp,-76
800075fa:	04 9a       	mov	r10,r2
800075fc:	0c 9b       	mov	r11,r6
800075fe:	08 9c       	mov	r12,r4
80007600:	fe b0 fc 1a 	rcall	80006e34 <get_arg>
80007604:	2f dd       	sub	sp,-12
80007606:	19 b8       	ld.ub	r8,r12[0x3]
80007608:	c2 28       	rjmp	8000764c <_vfprintf_r+0x4e8>
8000760a:	2f f7       	sub	r7,-1
8000760c:	10 39       	cp.w	r9,r8
8000760e:	c0 84       	brge	8000761e <_vfprintf_r+0x4ba>
80007610:	fa ca f9 44 	sub	r10,sp,-1724
80007614:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007618:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000761c:	c1 88       	rjmp	8000764c <_vfprintf_r+0x4e8>
8000761e:	41 09       	lddsp	r9,sp[0x40]
80007620:	59 f8       	cp.w	r8,31
80007622:	e0 89 00 12 	brgt	80007646 <_vfprintf_r+0x4e2>
80007626:	f2 ca ff fc 	sub	r10,r9,-4
8000762a:	51 0a       	stdsp	sp[0x40],r10
8000762c:	72 09       	ld.w	r9,r9[0x0]
8000762e:	fa c6 f9 44 	sub	r6,sp,-1724
80007632:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007636:	2f f8       	sub	r8,-1
80007638:	f5 49 fd 88 	st.w	r10[-632],r9
8000763c:	fb 48 06 b4 	st.w	sp[1716],r8
80007640:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007644:	c0 48       	rjmp	8000764c <_vfprintf_r+0x4e8>
80007646:	13 b8       	ld.ub	r8,r9[0x3]
80007648:	2f c9       	sub	r9,-4
8000764a:	51 09       	stdsp	sp[0x40],r9
8000764c:	fb 68 06 60 	st.b	sp[1632],r8
80007650:	30 0e       	mov	lr,0
80007652:	30 08       	mov	r8,0
80007654:	30 12       	mov	r2,1
80007656:	fb 68 06 bb 	st.b	sp[1723],r8
8000765a:	50 2e       	stdsp	sp[0x8],lr
8000765c:	e0 8f 08 ad 	bral	800087b6 <_vfprintf_r+0x1652>
80007660:	50 a7       	stdsp	sp[0x28],r7
80007662:	50 80       	stdsp	sp[0x20],r0
80007664:	0c 97       	mov	r7,r6
80007666:	04 94       	mov	r4,r2
80007668:	06 96       	mov	r6,r3
8000766a:	02 92       	mov	r2,r1
8000766c:	40 93       	lddsp	r3,sp[0x24]
8000766e:	10 90       	mov	r0,r8
80007670:	40 41       	lddsp	r1,sp[0x10]
80007672:	a5 a5       	sbr	r5,0x4
80007674:	c0 a8       	rjmp	80007688 <_vfprintf_r+0x524>
80007676:	50 a7       	stdsp	sp[0x28],r7
80007678:	50 80       	stdsp	sp[0x20],r0
8000767a:	0c 97       	mov	r7,r6
8000767c:	04 94       	mov	r4,r2
8000767e:	06 96       	mov	r6,r3
80007680:	02 92       	mov	r2,r1
80007682:	40 93       	lddsp	r3,sp[0x24]
80007684:	10 90       	mov	r0,r8
80007686:	40 41       	lddsp	r1,sp[0x10]
80007688:	ed b5 00 05 	bld	r5,0x5
8000768c:	c5 11       	brne	8000772e <_vfprintf_r+0x5ca>
8000768e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007692:	40 3c       	lddsp	r12,sp[0xc]
80007694:	58 0c       	cp.w	r12,0
80007696:	c1 e0       	breq	800076d2 <_vfprintf_r+0x56e>
80007698:	10 36       	cp.w	r6,r8
8000769a:	c0 64       	brge	800076a6 <_vfprintf_r+0x542>
8000769c:	fa cb f9 44 	sub	r11,sp,-1724
800076a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076a4:	c2 08       	rjmp	800076e4 <_vfprintf_r+0x580>
800076a6:	fa c8 f9 50 	sub	r8,sp,-1712
800076aa:	1a d8       	st.w	--sp,r8
800076ac:	fa c8 fa b8 	sub	r8,sp,-1352
800076b0:	0c 9b       	mov	r11,r6
800076b2:	1a d8       	st.w	--sp,r8
800076b4:	fa c8 fb b4 	sub	r8,sp,-1100
800076b8:	1a d8       	st.w	--sp,r8
800076ba:	fa c9 ff b4 	sub	r9,sp,-76
800076be:	fa c8 f9 40 	sub	r8,sp,-1728
800076c2:	04 9a       	mov	r10,r2
800076c4:	08 9c       	mov	r12,r4
800076c6:	fe b0 fb b7 	rcall	80006e34 <get_arg>
800076ca:	2f dd       	sub	sp,-12
800076cc:	78 1b       	ld.w	r11,r12[0x4]
800076ce:	78 09       	ld.w	r9,r12[0x0]
800076d0:	c2 b8       	rjmp	80007726 <_vfprintf_r+0x5c2>
800076d2:	ee ca ff ff 	sub	r10,r7,-1
800076d6:	10 37       	cp.w	r7,r8
800076d8:	c0 b4       	brge	800076ee <_vfprintf_r+0x58a>
800076da:	fa c9 f9 44 	sub	r9,sp,-1724
800076de:	14 97       	mov	r7,r10
800076e0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800076e4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800076e8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800076ec:	c1 d8       	rjmp	80007726 <_vfprintf_r+0x5c2>
800076ee:	41 09       	lddsp	r9,sp[0x40]
800076f0:	59 f8       	cp.w	r8,31
800076f2:	e0 89 00 14 	brgt	8000771a <_vfprintf_r+0x5b6>
800076f6:	f2 cb ff f8 	sub	r11,r9,-8
800076fa:	51 0b       	stdsp	sp[0x40],r11
800076fc:	fa c6 f9 44 	sub	r6,sp,-1724
80007700:	72 1b       	ld.w	r11,r9[0x4]
80007702:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007706:	72 09       	ld.w	r9,r9[0x0]
80007708:	f9 4b fd 8c 	st.w	r12[-628],r11
8000770c:	f9 49 fd 88 	st.w	r12[-632],r9
80007710:	2f f8       	sub	r8,-1
80007712:	14 97       	mov	r7,r10
80007714:	fb 48 06 b4 	st.w	sp[1716],r8
80007718:	c0 78       	rjmp	80007726 <_vfprintf_r+0x5c2>
8000771a:	f2 c8 ff f8 	sub	r8,r9,-8
8000771e:	72 1b       	ld.w	r11,r9[0x4]
80007720:	14 97       	mov	r7,r10
80007722:	51 08       	stdsp	sp[0x40],r8
80007724:	72 09       	ld.w	r9,r9[0x0]
80007726:	16 98       	mov	r8,r11
80007728:	fa e9 00 00 	st.d	sp[0],r8
8000772c:	ca e8       	rjmp	80007888 <_vfprintf_r+0x724>
8000772e:	ed b5 00 04 	bld	r5,0x4
80007732:	c1 71       	brne	80007760 <_vfprintf_r+0x5fc>
80007734:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007738:	40 3e       	lddsp	lr,sp[0xc]
8000773a:	58 0e       	cp.w	lr,0
8000773c:	c0 80       	breq	8000774c <_vfprintf_r+0x5e8>
8000773e:	10 36       	cp.w	r6,r8
80007740:	c6 94       	brge	80007812 <_vfprintf_r+0x6ae>
80007742:	fa cc f9 44 	sub	r12,sp,-1724
80007746:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000774a:	c8 28       	rjmp	8000784e <_vfprintf_r+0x6ea>
8000774c:	ee ca ff ff 	sub	r10,r7,-1
80007750:	10 37       	cp.w	r7,r8
80007752:	e0 84 00 81 	brge	80007854 <_vfprintf_r+0x6f0>
80007756:	fa cb f9 44 	sub	r11,sp,-1724
8000775a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000775e:	c7 78       	rjmp	8000784c <_vfprintf_r+0x6e8>
80007760:	ed b5 00 06 	bld	r5,0x6
80007764:	c4 b1       	brne	800077fa <_vfprintf_r+0x696>
80007766:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000776a:	40 3c       	lddsp	r12,sp[0xc]
8000776c:	58 0c       	cp.w	r12,0
8000776e:	c1 d0       	breq	800077a8 <_vfprintf_r+0x644>
80007770:	10 36       	cp.w	r6,r8
80007772:	c0 64       	brge	8000777e <_vfprintf_r+0x61a>
80007774:	fa cb f9 44 	sub	r11,sp,-1724
80007778:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000777c:	c1 f8       	rjmp	800077ba <_vfprintf_r+0x656>
8000777e:	fa c8 f9 50 	sub	r8,sp,-1712
80007782:	1a d8       	st.w	--sp,r8
80007784:	fa c8 fa b8 	sub	r8,sp,-1352
80007788:	1a d8       	st.w	--sp,r8
8000778a:	fa c8 fb b4 	sub	r8,sp,-1100
8000778e:	1a d8       	st.w	--sp,r8
80007790:	fa c8 f9 40 	sub	r8,sp,-1728
80007794:	fa c9 ff b4 	sub	r9,sp,-76
80007798:	04 9a       	mov	r10,r2
8000779a:	0c 9b       	mov	r11,r6
8000779c:	08 9c       	mov	r12,r4
8000779e:	fe b0 fb 4b 	rcall	80006e34 <get_arg>
800077a2:	2f dd       	sub	sp,-12
800077a4:	98 18       	ld.sh	r8,r12[0x2]
800077a6:	c2 68       	rjmp	800077f2 <_vfprintf_r+0x68e>
800077a8:	ee ca ff ff 	sub	r10,r7,-1
800077ac:	10 37       	cp.w	r7,r8
800077ae:	c0 94       	brge	800077c0 <_vfprintf_r+0x65c>
800077b0:	fa c9 f9 44 	sub	r9,sp,-1724
800077b4:	14 97       	mov	r7,r10
800077b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800077ba:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800077be:	c1 a8       	rjmp	800077f2 <_vfprintf_r+0x68e>
800077c0:	41 09       	lddsp	r9,sp[0x40]
800077c2:	59 f8       	cp.w	r8,31
800077c4:	e0 89 00 13 	brgt	800077ea <_vfprintf_r+0x686>
800077c8:	f2 cb ff fc 	sub	r11,r9,-4
800077cc:	51 0b       	stdsp	sp[0x40],r11
800077ce:	72 09       	ld.w	r9,r9[0x0]
800077d0:	fa c6 f9 44 	sub	r6,sp,-1724
800077d4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800077d8:	2f f8       	sub	r8,-1
800077da:	f7 49 fd 88 	st.w	r11[-632],r9
800077de:	fb 48 06 b4 	st.w	sp[1716],r8
800077e2:	14 97       	mov	r7,r10
800077e4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800077e8:	c0 58       	rjmp	800077f2 <_vfprintf_r+0x68e>
800077ea:	92 18       	ld.sh	r8,r9[0x2]
800077ec:	14 97       	mov	r7,r10
800077ee:	2f c9       	sub	r9,-4
800077f0:	51 09       	stdsp	sp[0x40],r9
800077f2:	50 18       	stdsp	sp[0x4],r8
800077f4:	bf 58       	asr	r8,0x1f
800077f6:	50 08       	stdsp	sp[0x0],r8
800077f8:	c4 88       	rjmp	80007888 <_vfprintf_r+0x724>
800077fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077fe:	40 3c       	lddsp	r12,sp[0xc]
80007800:	58 0c       	cp.w	r12,0
80007802:	c1 d0       	breq	8000783c <_vfprintf_r+0x6d8>
80007804:	10 36       	cp.w	r6,r8
80007806:	c0 64       	brge	80007812 <_vfprintf_r+0x6ae>
80007808:	fa cb f9 44 	sub	r11,sp,-1724
8000780c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007810:	c1 f8       	rjmp	8000784e <_vfprintf_r+0x6ea>
80007812:	fa c8 f9 50 	sub	r8,sp,-1712
80007816:	1a d8       	st.w	--sp,r8
80007818:	fa c8 fa b8 	sub	r8,sp,-1352
8000781c:	0c 9b       	mov	r11,r6
8000781e:	1a d8       	st.w	--sp,r8
80007820:	fa c8 fb b4 	sub	r8,sp,-1100
80007824:	04 9a       	mov	r10,r2
80007826:	1a d8       	st.w	--sp,r8
80007828:	08 9c       	mov	r12,r4
8000782a:	fa c8 f9 40 	sub	r8,sp,-1728
8000782e:	fa c9 ff b4 	sub	r9,sp,-76
80007832:	fe b0 fb 01 	rcall	80006e34 <get_arg>
80007836:	2f dd       	sub	sp,-12
80007838:	78 0b       	ld.w	r11,r12[0x0]
8000783a:	c2 48       	rjmp	80007882 <_vfprintf_r+0x71e>
8000783c:	ee ca ff ff 	sub	r10,r7,-1
80007840:	10 37       	cp.w	r7,r8
80007842:	c0 94       	brge	80007854 <_vfprintf_r+0x6f0>
80007844:	fa c9 f9 44 	sub	r9,sp,-1724
80007848:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000784c:	14 97       	mov	r7,r10
8000784e:	ec fb fd 88 	ld.w	r11,r6[-632]
80007852:	c1 88       	rjmp	80007882 <_vfprintf_r+0x71e>
80007854:	41 09       	lddsp	r9,sp[0x40]
80007856:	59 f8       	cp.w	r8,31
80007858:	e0 89 00 11 	brgt	8000787a <_vfprintf_r+0x716>
8000785c:	f2 cb ff fc 	sub	r11,r9,-4
80007860:	51 0b       	stdsp	sp[0x40],r11
80007862:	fa c6 f9 44 	sub	r6,sp,-1724
80007866:	72 0b       	ld.w	r11,r9[0x0]
80007868:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000786c:	f3 4b fd 88 	st.w	r9[-632],r11
80007870:	2f f8       	sub	r8,-1
80007872:	14 97       	mov	r7,r10
80007874:	fb 48 06 b4 	st.w	sp[1716],r8
80007878:	c0 58       	rjmp	80007882 <_vfprintf_r+0x71e>
8000787a:	72 0b       	ld.w	r11,r9[0x0]
8000787c:	14 97       	mov	r7,r10
8000787e:	2f c9       	sub	r9,-4
80007880:	51 09       	stdsp	sp[0x40],r9
80007882:	50 1b       	stdsp	sp[0x4],r11
80007884:	bf 5b       	asr	r11,0x1f
80007886:	50 0b       	stdsp	sp[0x0],r11
80007888:	fa ea 00 00 	ld.d	r10,sp[0]
8000788c:	58 0a       	cp.w	r10,0
8000788e:	5c 2b       	cpc	r11
80007890:	c0 e4       	brge	800078ac <_vfprintf_r+0x748>
80007892:	30 08       	mov	r8,0
80007894:	fa ea 00 00 	ld.d	r10,sp[0]
80007898:	30 09       	mov	r9,0
8000789a:	f0 0a 01 0a 	sub	r10,r8,r10
8000789e:	f2 0b 01 4b 	sbc	r11,r9,r11
800078a2:	32 d8       	mov	r8,45
800078a4:	fa eb 00 00 	st.d	sp[0],r10
800078a8:	fb 68 06 bb 	st.b	sp[1723],r8
800078ac:	30 18       	mov	r8,1
800078ae:	e0 8f 06 fa 	bral	800086a2 <_vfprintf_r+0x153e>
800078b2:	50 a7       	stdsp	sp[0x28],r7
800078b4:	50 80       	stdsp	sp[0x20],r0
800078b6:	0c 97       	mov	r7,r6
800078b8:	04 94       	mov	r4,r2
800078ba:	06 96       	mov	r6,r3
800078bc:	02 92       	mov	r2,r1
800078be:	40 93       	lddsp	r3,sp[0x24]
800078c0:	10 90       	mov	r0,r8
800078c2:	40 41       	lddsp	r1,sp[0x10]
800078c4:	0e 99       	mov	r9,r7
800078c6:	ed b5 00 03 	bld	r5,0x3
800078ca:	c4 11       	brne	8000794c <_vfprintf_r+0x7e8>
800078cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078d0:	40 3a       	lddsp	r10,sp[0xc]
800078d2:	58 0a       	cp.w	r10,0
800078d4:	c1 90       	breq	80007906 <_vfprintf_r+0x7a2>
800078d6:	10 36       	cp.w	r6,r8
800078d8:	c6 45       	brlt	800079a0 <_vfprintf_r+0x83c>
800078da:	fa c8 f9 50 	sub	r8,sp,-1712
800078de:	1a d8       	st.w	--sp,r8
800078e0:	fa c8 fa b8 	sub	r8,sp,-1352
800078e4:	1a d8       	st.w	--sp,r8
800078e6:	fa c8 fb b4 	sub	r8,sp,-1100
800078ea:	0c 9b       	mov	r11,r6
800078ec:	1a d8       	st.w	--sp,r8
800078ee:	04 9a       	mov	r10,r2
800078f0:	fa c8 f9 40 	sub	r8,sp,-1728
800078f4:	fa c9 ff b4 	sub	r9,sp,-76
800078f8:	08 9c       	mov	r12,r4
800078fa:	fe b0 fa 9d 	rcall	80006e34 <get_arg>
800078fe:	2f dd       	sub	sp,-12
80007900:	78 16       	ld.w	r6,r12[0x4]
80007902:	50 76       	stdsp	sp[0x1c],r6
80007904:	c4 88       	rjmp	80007994 <_vfprintf_r+0x830>
80007906:	2f f7       	sub	r7,-1
80007908:	10 39       	cp.w	r9,r8
8000790a:	c0 c4       	brge	80007922 <_vfprintf_r+0x7be>
8000790c:	fa ce f9 44 	sub	lr,sp,-1724
80007910:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007914:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007918:	50 7c       	stdsp	sp[0x1c],r12
8000791a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000791e:	50 56       	stdsp	sp[0x14],r6
80007920:	c6 68       	rjmp	800079ec <_vfprintf_r+0x888>
80007922:	41 09       	lddsp	r9,sp[0x40]
80007924:	59 f8       	cp.w	r8,31
80007926:	e0 89 00 10 	brgt	80007946 <_vfprintf_r+0x7e2>
8000792a:	f2 ca ff f8 	sub	r10,r9,-8
8000792e:	72 1b       	ld.w	r11,r9[0x4]
80007930:	51 0a       	stdsp	sp[0x40],r10
80007932:	72 09       	ld.w	r9,r9[0x0]
80007934:	fa ca f9 44 	sub	r10,sp,-1724
80007938:	50 7b       	stdsp	sp[0x1c],r11
8000793a:	50 59       	stdsp	sp[0x14],r9
8000793c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007940:	40 5b       	lddsp	r11,sp[0x14]
80007942:	40 7a       	lddsp	r10,sp[0x1c]
80007944:	c4 78       	rjmp	800079d2 <_vfprintf_r+0x86e>
80007946:	72 18       	ld.w	r8,r9[0x4]
80007948:	50 78       	stdsp	sp[0x1c],r8
8000794a:	c4 c8       	rjmp	800079e2 <_vfprintf_r+0x87e>
8000794c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007950:	40 3e       	lddsp	lr,sp[0xc]
80007952:	58 0e       	cp.w	lr,0
80007954:	c2 30       	breq	8000799a <_vfprintf_r+0x836>
80007956:	10 36       	cp.w	r6,r8
80007958:	c0 94       	brge	8000796a <_vfprintf_r+0x806>
8000795a:	fa cc f9 44 	sub	r12,sp,-1724
8000795e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007962:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007966:	50 7b       	stdsp	sp[0x1c],r11
80007968:	cd 9b       	rjmp	8000791a <_vfprintf_r+0x7b6>
8000796a:	fa c8 f9 50 	sub	r8,sp,-1712
8000796e:	1a d8       	st.w	--sp,r8
80007970:	fa c8 fa b8 	sub	r8,sp,-1352
80007974:	04 9a       	mov	r10,r2
80007976:	1a d8       	st.w	--sp,r8
80007978:	fa c8 fb b4 	sub	r8,sp,-1100
8000797c:	0c 9b       	mov	r11,r6
8000797e:	1a d8       	st.w	--sp,r8
80007980:	08 9c       	mov	r12,r4
80007982:	fa c8 f9 40 	sub	r8,sp,-1728
80007986:	fa c9 ff b4 	sub	r9,sp,-76
8000798a:	fe b0 fa 55 	rcall	80006e34 <get_arg>
8000798e:	2f dd       	sub	sp,-12
80007990:	78 1a       	ld.w	r10,r12[0x4]
80007992:	50 7a       	stdsp	sp[0x1c],r10
80007994:	78 0c       	ld.w	r12,r12[0x0]
80007996:	50 5c       	stdsp	sp[0x14],r12
80007998:	c2 a8       	rjmp	800079ec <_vfprintf_r+0x888>
8000799a:	2f f7       	sub	r7,-1
8000799c:	10 39       	cp.w	r9,r8
8000799e:	c0 94       	brge	800079b0 <_vfprintf_r+0x84c>
800079a0:	fa c9 f9 44 	sub	r9,sp,-1724
800079a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800079a8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800079ac:	50 78       	stdsp	sp[0x1c],r8
800079ae:	cb 6b       	rjmp	8000791a <_vfprintf_r+0x7b6>
800079b0:	41 09       	lddsp	r9,sp[0x40]
800079b2:	59 f8       	cp.w	r8,31
800079b4:	e0 89 00 15 	brgt	800079de <_vfprintf_r+0x87a>
800079b8:	f2 ca ff f8 	sub	r10,r9,-8
800079bc:	72 16       	ld.w	r6,r9[0x4]
800079be:	72 09       	ld.w	r9,r9[0x0]
800079c0:	51 0a       	stdsp	sp[0x40],r10
800079c2:	50 59       	stdsp	sp[0x14],r9
800079c4:	fa ce f9 44 	sub	lr,sp,-1724
800079c8:	50 76       	stdsp	sp[0x1c],r6
800079ca:	fc 08 00 39 	add	r9,lr,r8<<0x3
800079ce:	40 5b       	lddsp	r11,sp[0x14]
800079d0:	0c 9a       	mov	r10,r6
800079d2:	f2 eb fd 88 	st.d	r9[-632],r10
800079d6:	2f f8       	sub	r8,-1
800079d8:	fb 48 06 b4 	st.w	sp[1716],r8
800079dc:	c0 88       	rjmp	800079ec <_vfprintf_r+0x888>
800079de:	72 1c       	ld.w	r12,r9[0x4]
800079e0:	50 7c       	stdsp	sp[0x1c],r12
800079e2:	f2 c8 ff f8 	sub	r8,r9,-8
800079e6:	51 08       	stdsp	sp[0x40],r8
800079e8:	72 09       	ld.w	r9,r9[0x0]
800079ea:	50 59       	stdsp	sp[0x14],r9
800079ec:	40 5b       	lddsp	r11,sp[0x14]
800079ee:	40 7a       	lddsp	r10,sp[0x1c]
800079f0:	e0 a0 19 54 	rcall	8000ac98 <__isinfd>
800079f4:	18 96       	mov	r6,r12
800079f6:	c1 70       	breq	80007a24 <_vfprintf_r+0x8c0>
800079f8:	30 08       	mov	r8,0
800079fa:	30 09       	mov	r9,0
800079fc:	40 5b       	lddsp	r11,sp[0x14]
800079fe:	40 7a       	lddsp	r10,sp[0x1c]
80007a00:	e0 a0 1d b4 	rcall	8000b568 <__avr32_f64_cmp_lt>
80007a04:	c0 40       	breq	80007a0c <_vfprintf_r+0x8a8>
80007a06:	32 d8       	mov	r8,45
80007a08:	fb 68 06 bb 	st.b	sp[1723],r8
80007a0c:	fe c8 ab fc 	sub	r8,pc,-21508
80007a10:	fe c6 ab fc 	sub	r6,pc,-21508
80007a14:	a7 d5       	cbr	r5,0x7
80007a16:	e0 40 00 47 	cp.w	r0,71
80007a1a:	f0 06 17 a0 	movle	r6,r8
80007a1e:	30 32       	mov	r2,3
80007a20:	e0 8f 06 ce 	bral	800087bc <_vfprintf_r+0x1658>
80007a24:	40 5b       	lddsp	r11,sp[0x14]
80007a26:	40 7a       	lddsp	r10,sp[0x1c]
80007a28:	e0 a0 19 4d 	rcall	8000acc2 <__isnand>
80007a2c:	c0 e0       	breq	80007a48 <_vfprintf_r+0x8e4>
80007a2e:	50 26       	stdsp	sp[0x8],r6
80007a30:	fe c8 ac 18 	sub	r8,pc,-21480
80007a34:	fe c6 ac 18 	sub	r6,pc,-21480
80007a38:	a7 d5       	cbr	r5,0x7
80007a3a:	e0 40 00 47 	cp.w	r0,71
80007a3e:	f0 06 17 a0 	movle	r6,r8
80007a42:	30 32       	mov	r2,3
80007a44:	e0 8f 06 c2 	bral	800087c8 <_vfprintf_r+0x1664>
80007a48:	40 2a       	lddsp	r10,sp[0x8]
80007a4a:	5b fa       	cp.w	r10,-1
80007a4c:	c0 41       	brne	80007a54 <_vfprintf_r+0x8f0>
80007a4e:	30 69       	mov	r9,6
80007a50:	50 29       	stdsp	sp[0x8],r9
80007a52:	c1 18       	rjmp	80007a74 <_vfprintf_r+0x910>
80007a54:	e0 40 00 47 	cp.w	r0,71
80007a58:	5f 09       	sreq	r9
80007a5a:	e0 40 00 67 	cp.w	r0,103
80007a5e:	5f 08       	sreq	r8
80007a60:	f3 e8 10 08 	or	r8,r9,r8
80007a64:	f8 08 18 00 	cp.b	r8,r12
80007a68:	c0 60       	breq	80007a74 <_vfprintf_r+0x910>
80007a6a:	40 28       	lddsp	r8,sp[0x8]
80007a6c:	58 08       	cp.w	r8,0
80007a6e:	f9 b8 00 01 	moveq	r8,1
80007a72:	50 28       	stdsp	sp[0x8],r8
80007a74:	40 78       	lddsp	r8,sp[0x1c]
80007a76:	40 59       	lddsp	r9,sp[0x14]
80007a78:	fa e9 06 94 	st.d	sp[1684],r8
80007a7c:	a9 a5       	sbr	r5,0x8
80007a7e:	fa f8 06 94 	ld.w	r8,sp[1684]
80007a82:	58 08       	cp.w	r8,0
80007a84:	c0 65       	brlt	80007a90 <_vfprintf_r+0x92c>
80007a86:	40 5e       	lddsp	lr,sp[0x14]
80007a88:	30 0c       	mov	r12,0
80007a8a:	50 6e       	stdsp	sp[0x18],lr
80007a8c:	50 9c       	stdsp	sp[0x24],r12
80007a8e:	c0 78       	rjmp	80007a9c <_vfprintf_r+0x938>
80007a90:	40 5b       	lddsp	r11,sp[0x14]
80007a92:	32 da       	mov	r10,45
80007a94:	ee 1b 80 00 	eorh	r11,0x8000
80007a98:	50 9a       	stdsp	sp[0x24],r10
80007a9a:	50 6b       	stdsp	sp[0x18],r11
80007a9c:	e0 40 00 46 	cp.w	r0,70
80007aa0:	5f 09       	sreq	r9
80007aa2:	e0 40 00 66 	cp.w	r0,102
80007aa6:	5f 08       	sreq	r8
80007aa8:	f3 e8 10 08 	or	r8,r9,r8
80007aac:	50 48       	stdsp	sp[0x10],r8
80007aae:	c0 40       	breq	80007ab6 <_vfprintf_r+0x952>
80007ab0:	40 22       	lddsp	r2,sp[0x8]
80007ab2:	30 39       	mov	r9,3
80007ab4:	c1 08       	rjmp	80007ad4 <_vfprintf_r+0x970>
80007ab6:	e0 40 00 45 	cp.w	r0,69
80007aba:	5f 09       	sreq	r9
80007abc:	e0 40 00 65 	cp.w	r0,101
80007ac0:	5f 08       	sreq	r8
80007ac2:	40 22       	lddsp	r2,sp[0x8]
80007ac4:	10 49       	or	r9,r8
80007ac6:	2f f2       	sub	r2,-1
80007ac8:	40 46       	lddsp	r6,sp[0x10]
80007aca:	ec 09 18 00 	cp.b	r9,r6
80007ace:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007ad2:	30 29       	mov	r9,2
80007ad4:	fa c8 f9 5c 	sub	r8,sp,-1700
80007ad8:	1a d8       	st.w	--sp,r8
80007ada:	fa c8 f9 54 	sub	r8,sp,-1708
80007ade:	1a d8       	st.w	--sp,r8
80007ae0:	fa c8 f9 4c 	sub	r8,sp,-1716
80007ae4:	08 9c       	mov	r12,r4
80007ae6:	1a d8       	st.w	--sp,r8
80007ae8:	04 98       	mov	r8,r2
80007aea:	40 9b       	lddsp	r11,sp[0x24]
80007aec:	40 aa       	lddsp	r10,sp[0x28]
80007aee:	e0 a0 0b c3 	rcall	80009274 <_dtoa_r>
80007af2:	e0 40 00 47 	cp.w	r0,71
80007af6:	5f 19       	srne	r9
80007af8:	e0 40 00 67 	cp.w	r0,103
80007afc:	5f 18       	srne	r8
80007afe:	18 96       	mov	r6,r12
80007b00:	2f dd       	sub	sp,-12
80007b02:	f3 e8 00 08 	and	r8,r9,r8
80007b06:	c0 41       	brne	80007b0e <_vfprintf_r+0x9aa>
80007b08:	ed b5 00 00 	bld	r5,0x0
80007b0c:	c3 01       	brne	80007b6c <_vfprintf_r+0xa08>
80007b0e:	ec 02 00 0e 	add	lr,r6,r2
80007b12:	50 3e       	stdsp	sp[0xc],lr
80007b14:	40 4c       	lddsp	r12,sp[0x10]
80007b16:	58 0c       	cp.w	r12,0
80007b18:	c1 50       	breq	80007b42 <_vfprintf_r+0x9de>
80007b1a:	0d 89       	ld.ub	r9,r6[0x0]
80007b1c:	33 08       	mov	r8,48
80007b1e:	f0 09 18 00 	cp.b	r9,r8
80007b22:	c0 b1       	brne	80007b38 <_vfprintf_r+0x9d4>
80007b24:	30 08       	mov	r8,0
80007b26:	30 09       	mov	r9,0
80007b28:	40 6b       	lddsp	r11,sp[0x18]
80007b2a:	40 7a       	lddsp	r10,sp[0x1c]
80007b2c:	e0 a0 1c d7 	rcall	8000b4da <__avr32_f64_cmp_eq>
80007b30:	fb b2 00 01 	rsubeq	r2,1
80007b34:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007b38:	40 3b       	lddsp	r11,sp[0xc]
80007b3a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007b3e:	10 0b       	add	r11,r8
80007b40:	50 3b       	stdsp	sp[0xc],r11
80007b42:	40 6b       	lddsp	r11,sp[0x18]
80007b44:	30 08       	mov	r8,0
80007b46:	30 09       	mov	r9,0
80007b48:	40 7a       	lddsp	r10,sp[0x1c]
80007b4a:	e0 a0 1c c8 	rcall	8000b4da <__avr32_f64_cmp_eq>
80007b4e:	c0 90       	breq	80007b60 <_vfprintf_r+0x9fc>
80007b50:	40 3a       	lddsp	r10,sp[0xc]
80007b52:	fb 4a 06 a4 	st.w	sp[1700],r10
80007b56:	c0 58       	rjmp	80007b60 <_vfprintf_r+0x9fc>
80007b58:	10 c9       	st.b	r8++,r9
80007b5a:	fb 48 06 a4 	st.w	sp[1700],r8
80007b5e:	c0 28       	rjmp	80007b62 <_vfprintf_r+0x9fe>
80007b60:	33 09       	mov	r9,48
80007b62:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007b66:	40 3e       	lddsp	lr,sp[0xc]
80007b68:	1c 38       	cp.w	r8,lr
80007b6a:	cf 73       	brcs	80007b58 <_vfprintf_r+0x9f4>
80007b6c:	e0 40 00 47 	cp.w	r0,71
80007b70:	5f 09       	sreq	r9
80007b72:	e0 40 00 67 	cp.w	r0,103
80007b76:	5f 08       	sreq	r8
80007b78:	f3 e8 10 08 	or	r8,r9,r8
80007b7c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007b80:	0c 19       	sub	r9,r6
80007b82:	50 69       	stdsp	sp[0x18],r9
80007b84:	58 08       	cp.w	r8,0
80007b86:	c0 b0       	breq	80007b9c <_vfprintf_r+0xa38>
80007b88:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007b8c:	5b d8       	cp.w	r8,-3
80007b8e:	c0 55       	brlt	80007b98 <_vfprintf_r+0xa34>
80007b90:	40 2c       	lddsp	r12,sp[0x8]
80007b92:	18 38       	cp.w	r8,r12
80007b94:	e0 8a 00 6a 	brle	80007c68 <_vfprintf_r+0xb04>
80007b98:	20 20       	sub	r0,2
80007b9a:	c0 58       	rjmp	80007ba4 <_vfprintf_r+0xa40>
80007b9c:	e0 40 00 65 	cp.w	r0,101
80007ba0:	e0 89 00 46 	brgt	80007c2c <_vfprintf_r+0xac8>
80007ba4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007ba8:	fb 60 06 9c 	st.b	sp[1692],r0
80007bac:	20 1b       	sub	r11,1
80007bae:	fb 4b 06 ac 	st.w	sp[1708],r11
80007bb2:	c0 47       	brpl	80007bba <_vfprintf_r+0xa56>
80007bb4:	5c 3b       	neg	r11
80007bb6:	32 d8       	mov	r8,45
80007bb8:	c0 28       	rjmp	80007bbc <_vfprintf_r+0xa58>
80007bba:	32 b8       	mov	r8,43
80007bbc:	fb 68 06 9d 	st.b	sp[1693],r8
80007bc0:	58 9b       	cp.w	r11,9
80007bc2:	e0 8a 00 1d 	brle	80007bfc <_vfprintf_r+0xa98>
80007bc6:	fa c9 fa 35 	sub	r9,sp,-1483
80007bca:	30 aa       	mov	r10,10
80007bcc:	12 98       	mov	r8,r9
80007bce:	0e 9c       	mov	r12,r7
80007bd0:	0c 92       	mov	r2,r6
80007bd2:	f6 0a 0c 06 	divs	r6,r11,r10
80007bd6:	0e 9b       	mov	r11,r7
80007bd8:	2d 0b       	sub	r11,-48
80007bda:	10 fb       	st.b	--r8,r11
80007bdc:	0c 9b       	mov	r11,r6
80007bde:	58 96       	cp.w	r6,9
80007be0:	fe 99 ff f9 	brgt	80007bd2 <_vfprintf_r+0xa6e>
80007be4:	2d 0b       	sub	r11,-48
80007be6:	18 97       	mov	r7,r12
80007be8:	04 96       	mov	r6,r2
80007bea:	10 fb       	st.b	--r8,r11
80007bec:	fa ca f9 62 	sub	r10,sp,-1694
80007bf0:	c0 38       	rjmp	80007bf6 <_vfprintf_r+0xa92>
80007bf2:	11 3b       	ld.ub	r11,r8++
80007bf4:	14 cb       	st.b	r10++,r11
80007bf6:	12 38       	cp.w	r8,r9
80007bf8:	cf d3       	brcs	80007bf2 <_vfprintf_r+0xa8e>
80007bfa:	c0 98       	rjmp	80007c0c <_vfprintf_r+0xaa8>
80007bfc:	2d 0b       	sub	r11,-48
80007bfe:	33 08       	mov	r8,48
80007c00:	fb 6b 06 9f 	st.b	sp[1695],r11
80007c04:	fb 68 06 9e 	st.b	sp[1694],r8
80007c08:	fa ca f9 60 	sub	r10,sp,-1696
80007c0c:	fa c8 f9 64 	sub	r8,sp,-1692
80007c10:	f4 08 01 08 	sub	r8,r10,r8
80007c14:	50 e8       	stdsp	sp[0x38],r8
80007c16:	10 92       	mov	r2,r8
80007c18:	40 6b       	lddsp	r11,sp[0x18]
80007c1a:	16 02       	add	r2,r11
80007c1c:	58 1b       	cp.w	r11,1
80007c1e:	e0 89 00 05 	brgt	80007c28 <_vfprintf_r+0xac4>
80007c22:	ed b5 00 00 	bld	r5,0x0
80007c26:	c3 51       	brne	80007c90 <_vfprintf_r+0xb2c>
80007c28:	2f f2       	sub	r2,-1
80007c2a:	c3 38       	rjmp	80007c90 <_vfprintf_r+0xb2c>
80007c2c:	e0 40 00 66 	cp.w	r0,102
80007c30:	c1 c1       	brne	80007c68 <_vfprintf_r+0xb04>
80007c32:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007c36:	58 02       	cp.w	r2,0
80007c38:	e0 8a 00 0c 	brle	80007c50 <_vfprintf_r+0xaec>
80007c3c:	40 2a       	lddsp	r10,sp[0x8]
80007c3e:	58 0a       	cp.w	r10,0
80007c40:	c0 41       	brne	80007c48 <_vfprintf_r+0xae4>
80007c42:	ed b5 00 00 	bld	r5,0x0
80007c46:	c2 51       	brne	80007c90 <_vfprintf_r+0xb2c>
80007c48:	2f f2       	sub	r2,-1
80007c4a:	40 29       	lddsp	r9,sp[0x8]
80007c4c:	12 02       	add	r2,r9
80007c4e:	c0 b8       	rjmp	80007c64 <_vfprintf_r+0xb00>
80007c50:	40 28       	lddsp	r8,sp[0x8]
80007c52:	58 08       	cp.w	r8,0
80007c54:	c0 61       	brne	80007c60 <_vfprintf_r+0xafc>
80007c56:	ed b5 00 00 	bld	r5,0x0
80007c5a:	c0 30       	breq	80007c60 <_vfprintf_r+0xafc>
80007c5c:	30 12       	mov	r2,1
80007c5e:	c1 98       	rjmp	80007c90 <_vfprintf_r+0xb2c>
80007c60:	40 22       	lddsp	r2,sp[0x8]
80007c62:	2f e2       	sub	r2,-2
80007c64:	36 60       	mov	r0,102
80007c66:	c1 58       	rjmp	80007c90 <_vfprintf_r+0xb2c>
80007c68:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007c6c:	40 6e       	lddsp	lr,sp[0x18]
80007c6e:	1c 32       	cp.w	r2,lr
80007c70:	c0 65       	brlt	80007c7c <_vfprintf_r+0xb18>
80007c72:	ed b5 00 00 	bld	r5,0x0
80007c76:	f7 b2 00 ff 	subeq	r2,-1
80007c7a:	c0 a8       	rjmp	80007c8e <_vfprintf_r+0xb2a>
80007c7c:	e4 08 11 02 	rsub	r8,r2,2
80007c80:	40 6c       	lddsp	r12,sp[0x18]
80007c82:	58 02       	cp.w	r2,0
80007c84:	f0 02 17 a0 	movle	r2,r8
80007c88:	f9 b2 09 01 	movgt	r2,1
80007c8c:	18 02       	add	r2,r12
80007c8e:	36 70       	mov	r0,103
80007c90:	40 9b       	lddsp	r11,sp[0x24]
80007c92:	58 0b       	cp.w	r11,0
80007c94:	e0 80 05 94 	breq	800087bc <_vfprintf_r+0x1658>
80007c98:	32 d8       	mov	r8,45
80007c9a:	fb 68 06 bb 	st.b	sp[1723],r8
80007c9e:	e0 8f 05 93 	bral	800087c4 <_vfprintf_r+0x1660>
80007ca2:	50 a7       	stdsp	sp[0x28],r7
80007ca4:	04 94       	mov	r4,r2
80007ca6:	0c 97       	mov	r7,r6
80007ca8:	02 92       	mov	r2,r1
80007caa:	06 96       	mov	r6,r3
80007cac:	40 41       	lddsp	r1,sp[0x10]
80007cae:	40 93       	lddsp	r3,sp[0x24]
80007cb0:	0e 99       	mov	r9,r7
80007cb2:	ed b5 00 05 	bld	r5,0x5
80007cb6:	c4 81       	brne	80007d46 <_vfprintf_r+0xbe2>
80007cb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cbc:	40 3e       	lddsp	lr,sp[0xc]
80007cbe:	58 0e       	cp.w	lr,0
80007cc0:	c1 d0       	breq	80007cfa <_vfprintf_r+0xb96>
80007cc2:	10 36       	cp.w	r6,r8
80007cc4:	c0 64       	brge	80007cd0 <_vfprintf_r+0xb6c>
80007cc6:	fa cc f9 44 	sub	r12,sp,-1724
80007cca:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007cce:	c1 d8       	rjmp	80007d08 <_vfprintf_r+0xba4>
80007cd0:	fa c8 f9 50 	sub	r8,sp,-1712
80007cd4:	1a d8       	st.w	--sp,r8
80007cd6:	fa c8 fa b8 	sub	r8,sp,-1352
80007cda:	04 9a       	mov	r10,r2
80007cdc:	1a d8       	st.w	--sp,r8
80007cde:	fa c8 fb b4 	sub	r8,sp,-1100
80007ce2:	0c 9b       	mov	r11,r6
80007ce4:	1a d8       	st.w	--sp,r8
80007ce6:	08 9c       	mov	r12,r4
80007ce8:	fa c8 f9 40 	sub	r8,sp,-1728
80007cec:	fa c9 ff b4 	sub	r9,sp,-76
80007cf0:	fe b0 f8 a2 	rcall	80006e34 <get_arg>
80007cf4:	2f dd       	sub	sp,-12
80007cf6:	78 0a       	ld.w	r10,r12[0x0]
80007cf8:	c2 08       	rjmp	80007d38 <_vfprintf_r+0xbd4>
80007cfa:	2f f7       	sub	r7,-1
80007cfc:	10 39       	cp.w	r9,r8
80007cfe:	c0 84       	brge	80007d0e <_vfprintf_r+0xbaa>
80007d00:	fa cb f9 44 	sub	r11,sp,-1724
80007d04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d08:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d0c:	c1 68       	rjmp	80007d38 <_vfprintf_r+0xbd4>
80007d0e:	41 09       	lddsp	r9,sp[0x40]
80007d10:	59 f8       	cp.w	r8,31
80007d12:	e0 89 00 10 	brgt	80007d32 <_vfprintf_r+0xbce>
80007d16:	f2 ca ff fc 	sub	r10,r9,-4
80007d1a:	51 0a       	stdsp	sp[0x40],r10
80007d1c:	fa c6 f9 44 	sub	r6,sp,-1724
80007d20:	72 0a       	ld.w	r10,r9[0x0]
80007d22:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d26:	f3 4a fd 88 	st.w	r9[-632],r10
80007d2a:	2f f8       	sub	r8,-1
80007d2c:	fb 48 06 b4 	st.w	sp[1716],r8
80007d30:	c0 48       	rjmp	80007d38 <_vfprintf_r+0xbd4>
80007d32:	72 0a       	ld.w	r10,r9[0x0]
80007d34:	2f c9       	sub	r9,-4
80007d36:	51 09       	stdsp	sp[0x40],r9
80007d38:	40 be       	lddsp	lr,sp[0x2c]
80007d3a:	1c 98       	mov	r8,lr
80007d3c:	95 1e       	st.w	r10[0x4],lr
80007d3e:	bf 58       	asr	r8,0x1f
80007d40:	95 08       	st.w	r10[0x0],r8
80007d42:	fe 9f fa 9f 	bral	80007280 <_vfprintf_r+0x11c>
80007d46:	ed b5 00 04 	bld	r5,0x4
80007d4a:	c4 80       	breq	80007dda <_vfprintf_r+0xc76>
80007d4c:	e2 15 00 40 	andl	r5,0x40,COH
80007d50:	c4 50       	breq	80007dda <_vfprintf_r+0xc76>
80007d52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d56:	40 3c       	lddsp	r12,sp[0xc]
80007d58:	58 0c       	cp.w	r12,0
80007d5a:	c1 d0       	breq	80007d94 <_vfprintf_r+0xc30>
80007d5c:	10 36       	cp.w	r6,r8
80007d5e:	c0 64       	brge	80007d6a <_vfprintf_r+0xc06>
80007d60:	fa cb f9 44 	sub	r11,sp,-1724
80007d64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d68:	c1 d8       	rjmp	80007da2 <_vfprintf_r+0xc3e>
80007d6a:	fa c8 f9 50 	sub	r8,sp,-1712
80007d6e:	1a d8       	st.w	--sp,r8
80007d70:	fa c8 fa b8 	sub	r8,sp,-1352
80007d74:	04 9a       	mov	r10,r2
80007d76:	1a d8       	st.w	--sp,r8
80007d78:	fa c8 fb b4 	sub	r8,sp,-1100
80007d7c:	0c 9b       	mov	r11,r6
80007d7e:	1a d8       	st.w	--sp,r8
80007d80:	08 9c       	mov	r12,r4
80007d82:	fa c8 f9 40 	sub	r8,sp,-1728
80007d86:	fa c9 ff b4 	sub	r9,sp,-76
80007d8a:	fe b0 f8 55 	rcall	80006e34 <get_arg>
80007d8e:	2f dd       	sub	sp,-12
80007d90:	78 0a       	ld.w	r10,r12[0x0]
80007d92:	c2 08       	rjmp	80007dd2 <_vfprintf_r+0xc6e>
80007d94:	2f f7       	sub	r7,-1
80007d96:	10 39       	cp.w	r9,r8
80007d98:	c0 84       	brge	80007da8 <_vfprintf_r+0xc44>
80007d9a:	fa ca f9 44 	sub	r10,sp,-1724
80007d9e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007da2:	ec fa fd 88 	ld.w	r10,r6[-632]
80007da6:	c1 68       	rjmp	80007dd2 <_vfprintf_r+0xc6e>
80007da8:	41 09       	lddsp	r9,sp[0x40]
80007daa:	59 f8       	cp.w	r8,31
80007dac:	e0 89 00 10 	brgt	80007dcc <_vfprintf_r+0xc68>
80007db0:	f2 ca ff fc 	sub	r10,r9,-4
80007db4:	51 0a       	stdsp	sp[0x40],r10
80007db6:	fa c6 f9 44 	sub	r6,sp,-1724
80007dba:	72 0a       	ld.w	r10,r9[0x0]
80007dbc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007dc0:	f3 4a fd 88 	st.w	r9[-632],r10
80007dc4:	2f f8       	sub	r8,-1
80007dc6:	fb 48 06 b4 	st.w	sp[1716],r8
80007dca:	c0 48       	rjmp	80007dd2 <_vfprintf_r+0xc6e>
80007dcc:	72 0a       	ld.w	r10,r9[0x0]
80007dce:	2f c9       	sub	r9,-4
80007dd0:	51 09       	stdsp	sp[0x40],r9
80007dd2:	40 be       	lddsp	lr,sp[0x2c]
80007dd4:	b4 0e       	st.h	r10[0x0],lr
80007dd6:	fe 9f fa 55 	bral	80007280 <_vfprintf_r+0x11c>
80007dda:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dde:	40 3c       	lddsp	r12,sp[0xc]
80007de0:	58 0c       	cp.w	r12,0
80007de2:	c1 d0       	breq	80007e1c <_vfprintf_r+0xcb8>
80007de4:	10 36       	cp.w	r6,r8
80007de6:	c0 64       	brge	80007df2 <_vfprintf_r+0xc8e>
80007de8:	fa cb f9 44 	sub	r11,sp,-1724
80007dec:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007df0:	c1 d8       	rjmp	80007e2a <_vfprintf_r+0xcc6>
80007df2:	fa c8 f9 50 	sub	r8,sp,-1712
80007df6:	1a d8       	st.w	--sp,r8
80007df8:	fa c8 fa b8 	sub	r8,sp,-1352
80007dfc:	04 9a       	mov	r10,r2
80007dfe:	1a d8       	st.w	--sp,r8
80007e00:	fa c8 fb b4 	sub	r8,sp,-1100
80007e04:	0c 9b       	mov	r11,r6
80007e06:	1a d8       	st.w	--sp,r8
80007e08:	08 9c       	mov	r12,r4
80007e0a:	fa c8 f9 40 	sub	r8,sp,-1728
80007e0e:	fa c9 ff b4 	sub	r9,sp,-76
80007e12:	fe b0 f8 11 	rcall	80006e34 <get_arg>
80007e16:	2f dd       	sub	sp,-12
80007e18:	78 0a       	ld.w	r10,r12[0x0]
80007e1a:	c2 08       	rjmp	80007e5a <_vfprintf_r+0xcf6>
80007e1c:	2f f7       	sub	r7,-1
80007e1e:	10 39       	cp.w	r9,r8
80007e20:	c0 84       	brge	80007e30 <_vfprintf_r+0xccc>
80007e22:	fa ca f9 44 	sub	r10,sp,-1724
80007e26:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e2a:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e2e:	c1 68       	rjmp	80007e5a <_vfprintf_r+0xcf6>
80007e30:	41 09       	lddsp	r9,sp[0x40]
80007e32:	59 f8       	cp.w	r8,31
80007e34:	e0 89 00 10 	brgt	80007e54 <_vfprintf_r+0xcf0>
80007e38:	f2 ca ff fc 	sub	r10,r9,-4
80007e3c:	51 0a       	stdsp	sp[0x40],r10
80007e3e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e42:	72 0a       	ld.w	r10,r9[0x0]
80007e44:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e48:	f3 4a fd 88 	st.w	r9[-632],r10
80007e4c:	2f f8       	sub	r8,-1
80007e4e:	fb 48 06 b4 	st.w	sp[1716],r8
80007e52:	c0 48       	rjmp	80007e5a <_vfprintf_r+0xcf6>
80007e54:	72 0a       	ld.w	r10,r9[0x0]
80007e56:	2f c9       	sub	r9,-4
80007e58:	51 09       	stdsp	sp[0x40],r9
80007e5a:	40 be       	lddsp	lr,sp[0x2c]
80007e5c:	95 0e       	st.w	r10[0x0],lr
80007e5e:	fe 9f fa 11 	bral	80007280 <_vfprintf_r+0x11c>
80007e62:	50 a7       	stdsp	sp[0x28],r7
80007e64:	50 80       	stdsp	sp[0x20],r0
80007e66:	0c 97       	mov	r7,r6
80007e68:	04 94       	mov	r4,r2
80007e6a:	06 96       	mov	r6,r3
80007e6c:	02 92       	mov	r2,r1
80007e6e:	40 93       	lddsp	r3,sp[0x24]
80007e70:	10 90       	mov	r0,r8
80007e72:	40 41       	lddsp	r1,sp[0x10]
80007e74:	a5 a5       	sbr	r5,0x4
80007e76:	c0 a8       	rjmp	80007e8a <_vfprintf_r+0xd26>
80007e78:	50 a7       	stdsp	sp[0x28],r7
80007e7a:	50 80       	stdsp	sp[0x20],r0
80007e7c:	0c 97       	mov	r7,r6
80007e7e:	04 94       	mov	r4,r2
80007e80:	06 96       	mov	r6,r3
80007e82:	02 92       	mov	r2,r1
80007e84:	40 93       	lddsp	r3,sp[0x24]
80007e86:	10 90       	mov	r0,r8
80007e88:	40 41       	lddsp	r1,sp[0x10]
80007e8a:	ed b5 00 05 	bld	r5,0x5
80007e8e:	c5 d1       	brne	80007f48 <_vfprintf_r+0xde4>
80007e90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e94:	40 3c       	lddsp	r12,sp[0xc]
80007e96:	58 0c       	cp.w	r12,0
80007e98:	c2 60       	breq	80007ee4 <_vfprintf_r+0xd80>
80007e9a:	10 36       	cp.w	r6,r8
80007e9c:	c0 a4       	brge	80007eb0 <_vfprintf_r+0xd4c>
80007e9e:	fa cb f9 44 	sub	r11,sp,-1724
80007ea2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ea6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007eaa:	fa e9 00 00 	st.d	sp[0],r8
80007eae:	c1 88       	rjmp	80007ede <_vfprintf_r+0xd7a>
80007eb0:	fa c8 f9 50 	sub	r8,sp,-1712
80007eb4:	1a d8       	st.w	--sp,r8
80007eb6:	fa c8 fa b8 	sub	r8,sp,-1352
80007eba:	04 9a       	mov	r10,r2
80007ebc:	1a d8       	st.w	--sp,r8
80007ebe:	0c 9b       	mov	r11,r6
80007ec0:	fa c8 fb b4 	sub	r8,sp,-1100
80007ec4:	08 9c       	mov	r12,r4
80007ec6:	1a d8       	st.w	--sp,r8
80007ec8:	fa c8 f9 40 	sub	r8,sp,-1728
80007ecc:	fa c9 ff b4 	sub	r9,sp,-76
80007ed0:	fe b0 f7 b2 	rcall	80006e34 <get_arg>
80007ed4:	2f dd       	sub	sp,-12
80007ed6:	f8 ea 00 00 	ld.d	r10,r12[0]
80007eda:	fa eb 00 00 	st.d	sp[0],r10
80007ede:	30 08       	mov	r8,0
80007ee0:	e0 8f 03 de 	bral	8000869c <_vfprintf_r+0x1538>
80007ee4:	ee ca ff ff 	sub	r10,r7,-1
80007ee8:	10 37       	cp.w	r7,r8
80007eea:	c0 b4       	brge	80007f00 <_vfprintf_r+0xd9c>
80007eec:	fa c9 f9 44 	sub	r9,sp,-1724
80007ef0:	14 97       	mov	r7,r10
80007ef2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ef6:	ec ea fd 88 	ld.d	r10,r6[-632]
80007efa:	fa eb 00 00 	st.d	sp[0],r10
80007efe:	c1 88       	rjmp	80007f2e <_vfprintf_r+0xdca>
80007f00:	41 09       	lddsp	r9,sp[0x40]
80007f02:	59 f8       	cp.w	r8,31
80007f04:	e0 89 00 18 	brgt	80007f34 <_vfprintf_r+0xdd0>
80007f08:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f0c:	f2 cb ff f8 	sub	r11,r9,-8
80007f10:	fa e7 00 00 	st.d	sp[0],r6
80007f14:	51 0b       	stdsp	sp[0x40],r11
80007f16:	fa c6 f9 44 	sub	r6,sp,-1724
80007f1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f1e:	fa e6 00 00 	ld.d	r6,sp[0]
80007f22:	f2 e7 fd 88 	st.d	r9[-632],r6
80007f26:	2f f8       	sub	r8,-1
80007f28:	14 97       	mov	r7,r10
80007f2a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f2e:	40 38       	lddsp	r8,sp[0xc]
80007f30:	e0 8f 03 b6 	bral	8000869c <_vfprintf_r+0x1538>
80007f34:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f38:	40 38       	lddsp	r8,sp[0xc]
80007f3a:	fa e7 00 00 	st.d	sp[0],r6
80007f3e:	2f 89       	sub	r9,-8
80007f40:	14 97       	mov	r7,r10
80007f42:	51 09       	stdsp	sp[0x40],r9
80007f44:	e0 8f 03 ac 	bral	8000869c <_vfprintf_r+0x1538>
80007f48:	ed b5 00 04 	bld	r5,0x4
80007f4c:	c1 61       	brne	80007f78 <_vfprintf_r+0xe14>
80007f4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f52:	40 3e       	lddsp	lr,sp[0xc]
80007f54:	58 0e       	cp.w	lr,0
80007f56:	c0 80       	breq	80007f66 <_vfprintf_r+0xe02>
80007f58:	10 36       	cp.w	r6,r8
80007f5a:	c6 74       	brge	80008028 <_vfprintf_r+0xec4>
80007f5c:	fa cc f9 44 	sub	r12,sp,-1724
80007f60:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f64:	c8 08       	rjmp	80008064 <_vfprintf_r+0xf00>
80007f66:	ee ca ff ff 	sub	r10,r7,-1
80007f6a:	10 37       	cp.w	r7,r8
80007f6c:	c7 f4       	brge	8000806a <_vfprintf_r+0xf06>
80007f6e:	fa cb f9 44 	sub	r11,sp,-1724
80007f72:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f76:	c7 68       	rjmp	80008062 <_vfprintf_r+0xefe>
80007f78:	ed b5 00 06 	bld	r5,0x6
80007f7c:	c4 a1       	brne	80008010 <_vfprintf_r+0xeac>
80007f7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f82:	40 3c       	lddsp	r12,sp[0xc]
80007f84:	58 0c       	cp.w	r12,0
80007f86:	c1 d0       	breq	80007fc0 <_vfprintf_r+0xe5c>
80007f88:	10 36       	cp.w	r6,r8
80007f8a:	c0 64       	brge	80007f96 <_vfprintf_r+0xe32>
80007f8c:	fa cb f9 44 	sub	r11,sp,-1724
80007f90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f94:	c1 f8       	rjmp	80007fd2 <_vfprintf_r+0xe6e>
80007f96:	fa c8 f9 50 	sub	r8,sp,-1712
80007f9a:	1a d8       	st.w	--sp,r8
80007f9c:	fa c8 fa b8 	sub	r8,sp,-1352
80007fa0:	1a d8       	st.w	--sp,r8
80007fa2:	fa c8 fb b4 	sub	r8,sp,-1100
80007fa6:	1a d8       	st.w	--sp,r8
80007fa8:	fa c8 f9 40 	sub	r8,sp,-1728
80007fac:	fa c9 ff b4 	sub	r9,sp,-76
80007fb0:	04 9a       	mov	r10,r2
80007fb2:	0c 9b       	mov	r11,r6
80007fb4:	08 9c       	mov	r12,r4
80007fb6:	fe b0 f7 3f 	rcall	80006e34 <get_arg>
80007fba:	2f dd       	sub	sp,-12
80007fbc:	98 18       	ld.sh	r8,r12[0x2]
80007fbe:	c2 68       	rjmp	8000800a <_vfprintf_r+0xea6>
80007fc0:	ee ca ff ff 	sub	r10,r7,-1
80007fc4:	10 37       	cp.w	r7,r8
80007fc6:	c0 94       	brge	80007fd8 <_vfprintf_r+0xe74>
80007fc8:	fa c9 f9 44 	sub	r9,sp,-1724
80007fcc:	14 97       	mov	r7,r10
80007fce:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fd2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007fd6:	c1 a8       	rjmp	8000800a <_vfprintf_r+0xea6>
80007fd8:	41 09       	lddsp	r9,sp[0x40]
80007fda:	59 f8       	cp.w	r8,31
80007fdc:	e0 89 00 13 	brgt	80008002 <_vfprintf_r+0xe9e>
80007fe0:	f2 cb ff fc 	sub	r11,r9,-4
80007fe4:	51 0b       	stdsp	sp[0x40],r11
80007fe6:	72 09       	ld.w	r9,r9[0x0]
80007fe8:	fa c6 f9 44 	sub	r6,sp,-1724
80007fec:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007ff0:	2f f8       	sub	r8,-1
80007ff2:	f7 49 fd 88 	st.w	r11[-632],r9
80007ff6:	fb 48 06 b4 	st.w	sp[1716],r8
80007ffa:	14 97       	mov	r7,r10
80007ffc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008000:	c0 58       	rjmp	8000800a <_vfprintf_r+0xea6>
80008002:	92 18       	ld.sh	r8,r9[0x2]
80008004:	14 97       	mov	r7,r10
80008006:	2f c9       	sub	r9,-4
80008008:	51 09       	stdsp	sp[0x40],r9
8000800a:	5c 78       	castu.h	r8
8000800c:	50 18       	stdsp	sp[0x4],r8
8000800e:	c4 68       	rjmp	8000809a <_vfprintf_r+0xf36>
80008010:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008014:	40 3c       	lddsp	r12,sp[0xc]
80008016:	58 0c       	cp.w	r12,0
80008018:	c1 d0       	breq	80008052 <_vfprintf_r+0xeee>
8000801a:	10 36       	cp.w	r6,r8
8000801c:	c0 64       	brge	80008028 <_vfprintf_r+0xec4>
8000801e:	fa cb f9 44 	sub	r11,sp,-1724
80008022:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008026:	c1 f8       	rjmp	80008064 <_vfprintf_r+0xf00>
80008028:	fa c8 f9 50 	sub	r8,sp,-1712
8000802c:	1a d8       	st.w	--sp,r8
8000802e:	fa c8 fa b8 	sub	r8,sp,-1352
80008032:	0c 9b       	mov	r11,r6
80008034:	1a d8       	st.w	--sp,r8
80008036:	fa c8 fb b4 	sub	r8,sp,-1100
8000803a:	04 9a       	mov	r10,r2
8000803c:	1a d8       	st.w	--sp,r8
8000803e:	08 9c       	mov	r12,r4
80008040:	fa c8 f9 40 	sub	r8,sp,-1728
80008044:	fa c9 ff b4 	sub	r9,sp,-76
80008048:	fe b0 f6 f6 	rcall	80006e34 <get_arg>
8000804c:	2f dd       	sub	sp,-12
8000804e:	78 0b       	ld.w	r11,r12[0x0]
80008050:	c2 48       	rjmp	80008098 <_vfprintf_r+0xf34>
80008052:	ee ca ff ff 	sub	r10,r7,-1
80008056:	10 37       	cp.w	r7,r8
80008058:	c0 94       	brge	8000806a <_vfprintf_r+0xf06>
8000805a:	fa c9 f9 44 	sub	r9,sp,-1724
8000805e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008062:	14 97       	mov	r7,r10
80008064:	ec fb fd 88 	ld.w	r11,r6[-632]
80008068:	c1 88       	rjmp	80008098 <_vfprintf_r+0xf34>
8000806a:	41 09       	lddsp	r9,sp[0x40]
8000806c:	59 f8       	cp.w	r8,31
8000806e:	e0 89 00 11 	brgt	80008090 <_vfprintf_r+0xf2c>
80008072:	f2 cb ff fc 	sub	r11,r9,-4
80008076:	51 0b       	stdsp	sp[0x40],r11
80008078:	fa c6 f9 44 	sub	r6,sp,-1724
8000807c:	72 0b       	ld.w	r11,r9[0x0]
8000807e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008082:	f3 4b fd 88 	st.w	r9[-632],r11
80008086:	2f f8       	sub	r8,-1
80008088:	14 97       	mov	r7,r10
8000808a:	fb 48 06 b4 	st.w	sp[1716],r8
8000808e:	c0 58       	rjmp	80008098 <_vfprintf_r+0xf34>
80008090:	72 0b       	ld.w	r11,r9[0x0]
80008092:	14 97       	mov	r7,r10
80008094:	2f c9       	sub	r9,-4
80008096:	51 09       	stdsp	sp[0x40],r9
80008098:	50 1b       	stdsp	sp[0x4],r11
8000809a:	30 0e       	mov	lr,0
8000809c:	50 0e       	stdsp	sp[0x0],lr
8000809e:	1c 98       	mov	r8,lr
800080a0:	e0 8f 02 fe 	bral	8000869c <_vfprintf_r+0x1538>
800080a4:	50 a7       	stdsp	sp[0x28],r7
800080a6:	50 80       	stdsp	sp[0x20],r0
800080a8:	0c 97       	mov	r7,r6
800080aa:	04 94       	mov	r4,r2
800080ac:	06 96       	mov	r6,r3
800080ae:	02 92       	mov	r2,r1
800080b0:	40 93       	lddsp	r3,sp[0x24]
800080b2:	40 41       	lddsp	r1,sp[0x10]
800080b4:	0e 99       	mov	r9,r7
800080b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080ba:	40 3c       	lddsp	r12,sp[0xc]
800080bc:	58 0c       	cp.w	r12,0
800080be:	c1 d0       	breq	800080f8 <_vfprintf_r+0xf94>
800080c0:	10 36       	cp.w	r6,r8
800080c2:	c0 64       	brge	800080ce <_vfprintf_r+0xf6a>
800080c4:	fa cb f9 44 	sub	r11,sp,-1724
800080c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080cc:	c1 d8       	rjmp	80008106 <_vfprintf_r+0xfa2>
800080ce:	fa c8 f9 50 	sub	r8,sp,-1712
800080d2:	1a d8       	st.w	--sp,r8
800080d4:	fa c8 fa b8 	sub	r8,sp,-1352
800080d8:	1a d8       	st.w	--sp,r8
800080da:	fa c8 fb b4 	sub	r8,sp,-1100
800080de:	1a d8       	st.w	--sp,r8
800080e0:	fa c9 ff b4 	sub	r9,sp,-76
800080e4:	fa c8 f9 40 	sub	r8,sp,-1728
800080e8:	04 9a       	mov	r10,r2
800080ea:	0c 9b       	mov	r11,r6
800080ec:	08 9c       	mov	r12,r4
800080ee:	fe b0 f6 a3 	rcall	80006e34 <get_arg>
800080f2:	2f dd       	sub	sp,-12
800080f4:	78 09       	ld.w	r9,r12[0x0]
800080f6:	c2 18       	rjmp	80008138 <_vfprintf_r+0xfd4>
800080f8:	2f f7       	sub	r7,-1
800080fa:	10 39       	cp.w	r9,r8
800080fc:	c0 84       	brge	8000810c <_vfprintf_r+0xfa8>
800080fe:	fa ca f9 44 	sub	r10,sp,-1724
80008102:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008106:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000810a:	c1 78       	rjmp	80008138 <_vfprintf_r+0xfd4>
8000810c:	41 09       	lddsp	r9,sp[0x40]
8000810e:	59 f8       	cp.w	r8,31
80008110:	e0 89 00 10 	brgt	80008130 <_vfprintf_r+0xfcc>
80008114:	f2 ca ff fc 	sub	r10,r9,-4
80008118:	51 0a       	stdsp	sp[0x40],r10
8000811a:	fa c6 f9 44 	sub	r6,sp,-1724
8000811e:	72 09       	ld.w	r9,r9[0x0]
80008120:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008124:	f5 49 fd 88 	st.w	r10[-632],r9
80008128:	2f f8       	sub	r8,-1
8000812a:	fb 48 06 b4 	st.w	sp[1716],r8
8000812e:	c0 58       	rjmp	80008138 <_vfprintf_r+0xfd4>
80008130:	f2 c8 ff fc 	sub	r8,r9,-4
80008134:	51 08       	stdsp	sp[0x40],r8
80008136:	72 09       	ld.w	r9,r9[0x0]
80008138:	33 08       	mov	r8,48
8000813a:	fb 68 06 b8 	st.b	sp[1720],r8
8000813e:	37 88       	mov	r8,120
80008140:	30 0e       	mov	lr,0
80008142:	fb 68 06 b9 	st.b	sp[1721],r8
80008146:	fe cc b3 26 	sub	r12,pc,-19674
8000814a:	50 19       	stdsp	sp[0x4],r9
8000814c:	a1 b5       	sbr	r5,0x1
8000814e:	50 0e       	stdsp	sp[0x0],lr
80008150:	50 dc       	stdsp	sp[0x34],r12
80008152:	30 28       	mov	r8,2
80008154:	37 80       	mov	r0,120
80008156:	e0 8f 02 a3 	bral	8000869c <_vfprintf_r+0x1538>
8000815a:	50 a7       	stdsp	sp[0x28],r7
8000815c:	50 80       	stdsp	sp[0x20],r0
8000815e:	10 90       	mov	r0,r8
80008160:	30 08       	mov	r8,0
80008162:	fb 68 06 bb 	st.b	sp[1723],r8
80008166:	0c 97       	mov	r7,r6
80008168:	04 94       	mov	r4,r2
8000816a:	06 96       	mov	r6,r3
8000816c:	02 92       	mov	r2,r1
8000816e:	40 93       	lddsp	r3,sp[0x24]
80008170:	40 41       	lddsp	r1,sp[0x10]
80008172:	0e 99       	mov	r9,r7
80008174:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008178:	40 3b       	lddsp	r11,sp[0xc]
8000817a:	58 0b       	cp.w	r11,0
8000817c:	c1 d0       	breq	800081b6 <_vfprintf_r+0x1052>
8000817e:	10 36       	cp.w	r6,r8
80008180:	c0 64       	brge	8000818c <_vfprintf_r+0x1028>
80008182:	fa ca f9 44 	sub	r10,sp,-1724
80008186:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000818a:	c1 d8       	rjmp	800081c4 <_vfprintf_r+0x1060>
8000818c:	fa c8 f9 50 	sub	r8,sp,-1712
80008190:	1a d8       	st.w	--sp,r8
80008192:	fa c8 fa b8 	sub	r8,sp,-1352
80008196:	1a d8       	st.w	--sp,r8
80008198:	fa c8 fb b4 	sub	r8,sp,-1100
8000819c:	0c 9b       	mov	r11,r6
8000819e:	1a d8       	st.w	--sp,r8
800081a0:	04 9a       	mov	r10,r2
800081a2:	fa c8 f9 40 	sub	r8,sp,-1728
800081a6:	fa c9 ff b4 	sub	r9,sp,-76
800081aa:	08 9c       	mov	r12,r4
800081ac:	fe b0 f6 44 	rcall	80006e34 <get_arg>
800081b0:	2f dd       	sub	sp,-12
800081b2:	78 06       	ld.w	r6,r12[0x0]
800081b4:	c2 08       	rjmp	800081f4 <_vfprintf_r+0x1090>
800081b6:	2f f7       	sub	r7,-1
800081b8:	10 39       	cp.w	r9,r8
800081ba:	c0 84       	brge	800081ca <_vfprintf_r+0x1066>
800081bc:	fa c9 f9 44 	sub	r9,sp,-1724
800081c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081c4:	ec f6 fd 88 	ld.w	r6,r6[-632]
800081c8:	c1 68       	rjmp	800081f4 <_vfprintf_r+0x1090>
800081ca:	41 09       	lddsp	r9,sp[0x40]
800081cc:	59 f8       	cp.w	r8,31
800081ce:	e0 89 00 10 	brgt	800081ee <_vfprintf_r+0x108a>
800081d2:	f2 ca ff fc 	sub	r10,r9,-4
800081d6:	51 0a       	stdsp	sp[0x40],r10
800081d8:	72 06       	ld.w	r6,r9[0x0]
800081da:	fa ce f9 44 	sub	lr,sp,-1724
800081de:	fc 08 00 39 	add	r9,lr,r8<<0x3
800081e2:	f3 46 fd 88 	st.w	r9[-632],r6
800081e6:	2f f8       	sub	r8,-1
800081e8:	fb 48 06 b4 	st.w	sp[1716],r8
800081ec:	c0 48       	rjmp	800081f4 <_vfprintf_r+0x1090>
800081ee:	72 06       	ld.w	r6,r9[0x0]
800081f0:	2f c9       	sub	r9,-4
800081f2:	51 09       	stdsp	sp[0x40],r9
800081f4:	40 2c       	lddsp	r12,sp[0x8]
800081f6:	58 0c       	cp.w	r12,0
800081f8:	c1 05       	brlt	80008218 <_vfprintf_r+0x10b4>
800081fa:	18 9a       	mov	r10,r12
800081fc:	30 0b       	mov	r11,0
800081fe:	0c 9c       	mov	r12,r6
80008200:	e0 a0 12 38 	rcall	8000a670 <memchr>
80008204:	e0 80 02 df 	breq	800087c2 <_vfprintf_r+0x165e>
80008208:	f8 06 01 02 	sub	r2,r12,r6
8000820c:	40 2b       	lddsp	r11,sp[0x8]
8000820e:	16 32       	cp.w	r2,r11
80008210:	e0 89 02 d9 	brgt	800087c2 <_vfprintf_r+0x165e>
80008214:	e0 8f 02 d4 	bral	800087bc <_vfprintf_r+0x1658>
80008218:	30 0a       	mov	r10,0
8000821a:	0c 9c       	mov	r12,r6
8000821c:	50 2a       	stdsp	sp[0x8],r10
8000821e:	e0 a0 15 99 	rcall	8000ad50 <strlen>
80008222:	18 92       	mov	r2,r12
80008224:	e0 8f 02 d2 	bral	800087c8 <_vfprintf_r+0x1664>
80008228:	50 a7       	stdsp	sp[0x28],r7
8000822a:	50 80       	stdsp	sp[0x20],r0
8000822c:	0c 97       	mov	r7,r6
8000822e:	04 94       	mov	r4,r2
80008230:	06 96       	mov	r6,r3
80008232:	02 92       	mov	r2,r1
80008234:	40 93       	lddsp	r3,sp[0x24]
80008236:	10 90       	mov	r0,r8
80008238:	40 41       	lddsp	r1,sp[0x10]
8000823a:	a5 a5       	sbr	r5,0x4
8000823c:	c0 a8       	rjmp	80008250 <_vfprintf_r+0x10ec>
8000823e:	50 a7       	stdsp	sp[0x28],r7
80008240:	50 80       	stdsp	sp[0x20],r0
80008242:	0c 97       	mov	r7,r6
80008244:	04 94       	mov	r4,r2
80008246:	06 96       	mov	r6,r3
80008248:	02 92       	mov	r2,r1
8000824a:	40 93       	lddsp	r3,sp[0x24]
8000824c:	10 90       	mov	r0,r8
8000824e:	40 41       	lddsp	r1,sp[0x10]
80008250:	ed b5 00 05 	bld	r5,0x5
80008254:	c5 61       	brne	80008300 <_vfprintf_r+0x119c>
80008256:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000825a:	40 39       	lddsp	r9,sp[0xc]
8000825c:	58 09       	cp.w	r9,0
8000825e:	c2 10       	breq	800082a0 <_vfprintf_r+0x113c>
80008260:	10 36       	cp.w	r6,r8
80008262:	c0 74       	brge	80008270 <_vfprintf_r+0x110c>
80008264:	fa c8 f9 44 	sub	r8,sp,-1724
80008268:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000826c:	c2 38       	rjmp	800082b2 <_vfprintf_r+0x114e>
8000826e:	d7 03       	nop
80008270:	fa c8 f9 50 	sub	r8,sp,-1712
80008274:	1a d8       	st.w	--sp,r8
80008276:	fa c8 fa b8 	sub	r8,sp,-1352
8000827a:	1a d8       	st.w	--sp,r8
8000827c:	fa c8 fb b4 	sub	r8,sp,-1100
80008280:	1a d8       	st.w	--sp,r8
80008282:	fa c8 f9 40 	sub	r8,sp,-1728
80008286:	fa c9 ff b4 	sub	r9,sp,-76
8000828a:	04 9a       	mov	r10,r2
8000828c:	0c 9b       	mov	r11,r6
8000828e:	08 9c       	mov	r12,r4
80008290:	fe b0 f5 d2 	rcall	80006e34 <get_arg>
80008294:	2f dd       	sub	sp,-12
80008296:	f8 e8 00 00 	ld.d	r8,r12[0]
8000829a:	fa e9 00 00 	st.d	sp[0],r8
8000829e:	c2 e8       	rjmp	800082fa <_vfprintf_r+0x1196>
800082a0:	ee ca ff ff 	sub	r10,r7,-1
800082a4:	10 37       	cp.w	r7,r8
800082a6:	c0 b4       	brge	800082bc <_vfprintf_r+0x1158>
800082a8:	fa c8 f9 44 	sub	r8,sp,-1724
800082ac:	14 97       	mov	r7,r10
800082ae:	f0 06 00 36 	add	r6,r8,r6<<0x3
800082b2:	ec ea fd 88 	ld.d	r10,r6[-632]
800082b6:	fa eb 00 00 	st.d	sp[0],r10
800082ba:	c2 08       	rjmp	800082fa <_vfprintf_r+0x1196>
800082bc:	41 09       	lddsp	r9,sp[0x40]
800082be:	59 f8       	cp.w	r8,31
800082c0:	e0 89 00 16 	brgt	800082ec <_vfprintf_r+0x1188>
800082c4:	f2 e6 00 00 	ld.d	r6,r9[0]
800082c8:	f2 cb ff f8 	sub	r11,r9,-8
800082cc:	fa e7 00 00 	st.d	sp[0],r6
800082d0:	51 0b       	stdsp	sp[0x40],r11
800082d2:	fa c6 f9 44 	sub	r6,sp,-1724
800082d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082da:	fa e6 00 00 	ld.d	r6,sp[0]
800082de:	f2 e7 fd 88 	st.d	r9[-632],r6
800082e2:	2f f8       	sub	r8,-1
800082e4:	14 97       	mov	r7,r10
800082e6:	fb 48 06 b4 	st.w	sp[1716],r8
800082ea:	c0 88       	rjmp	800082fa <_vfprintf_r+0x1196>
800082ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800082f0:	2f 89       	sub	r9,-8
800082f2:	fa e7 00 00 	st.d	sp[0],r6
800082f6:	51 09       	stdsp	sp[0x40],r9
800082f8:	14 97       	mov	r7,r10
800082fa:	30 18       	mov	r8,1
800082fc:	e0 8f 01 d0 	bral	8000869c <_vfprintf_r+0x1538>
80008300:	ed b5 00 04 	bld	r5,0x4
80008304:	c1 61       	brne	80008330 <_vfprintf_r+0x11cc>
80008306:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000830a:	40 3e       	lddsp	lr,sp[0xc]
8000830c:	58 0e       	cp.w	lr,0
8000830e:	c0 80       	breq	8000831e <_vfprintf_r+0x11ba>
80008310:	10 36       	cp.w	r6,r8
80008312:	c6 74       	brge	800083e0 <_vfprintf_r+0x127c>
80008314:	fa cc f9 44 	sub	r12,sp,-1724
80008318:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000831c:	c8 08       	rjmp	8000841c <_vfprintf_r+0x12b8>
8000831e:	ee ca ff ff 	sub	r10,r7,-1
80008322:	10 37       	cp.w	r7,r8
80008324:	c7 f4       	brge	80008422 <_vfprintf_r+0x12be>
80008326:	fa cb f9 44 	sub	r11,sp,-1724
8000832a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000832e:	c7 68       	rjmp	8000841a <_vfprintf_r+0x12b6>
80008330:	ed b5 00 06 	bld	r5,0x6
80008334:	c4 a1       	brne	800083c8 <_vfprintf_r+0x1264>
80008336:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000833a:	40 3c       	lddsp	r12,sp[0xc]
8000833c:	58 0c       	cp.w	r12,0
8000833e:	c1 d0       	breq	80008378 <_vfprintf_r+0x1214>
80008340:	10 36       	cp.w	r6,r8
80008342:	c0 64       	brge	8000834e <_vfprintf_r+0x11ea>
80008344:	fa cb f9 44 	sub	r11,sp,-1724
80008348:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000834c:	c1 f8       	rjmp	8000838a <_vfprintf_r+0x1226>
8000834e:	fa c8 f9 50 	sub	r8,sp,-1712
80008352:	1a d8       	st.w	--sp,r8
80008354:	fa c8 fa b8 	sub	r8,sp,-1352
80008358:	1a d8       	st.w	--sp,r8
8000835a:	fa c8 fb b4 	sub	r8,sp,-1100
8000835e:	1a d8       	st.w	--sp,r8
80008360:	fa c8 f9 40 	sub	r8,sp,-1728
80008364:	fa c9 ff b4 	sub	r9,sp,-76
80008368:	04 9a       	mov	r10,r2
8000836a:	0c 9b       	mov	r11,r6
8000836c:	08 9c       	mov	r12,r4
8000836e:	fe b0 f5 63 	rcall	80006e34 <get_arg>
80008372:	2f dd       	sub	sp,-12
80008374:	98 18       	ld.sh	r8,r12[0x2]
80008376:	c2 68       	rjmp	800083c2 <_vfprintf_r+0x125e>
80008378:	ee ca ff ff 	sub	r10,r7,-1
8000837c:	10 37       	cp.w	r7,r8
8000837e:	c0 94       	brge	80008390 <_vfprintf_r+0x122c>
80008380:	fa c9 f9 44 	sub	r9,sp,-1724
80008384:	14 97       	mov	r7,r10
80008386:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000838a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000838e:	c1 a8       	rjmp	800083c2 <_vfprintf_r+0x125e>
80008390:	41 09       	lddsp	r9,sp[0x40]
80008392:	59 f8       	cp.w	r8,31
80008394:	e0 89 00 13 	brgt	800083ba <_vfprintf_r+0x1256>
80008398:	f2 cb ff fc 	sub	r11,r9,-4
8000839c:	51 0b       	stdsp	sp[0x40],r11
8000839e:	72 09       	ld.w	r9,r9[0x0]
800083a0:	fa c6 f9 44 	sub	r6,sp,-1724
800083a4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800083a8:	2f f8       	sub	r8,-1
800083aa:	f7 49 fd 88 	st.w	r11[-632],r9
800083ae:	fb 48 06 b4 	st.w	sp[1716],r8
800083b2:	14 97       	mov	r7,r10
800083b4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800083b8:	c0 58       	rjmp	800083c2 <_vfprintf_r+0x125e>
800083ba:	92 18       	ld.sh	r8,r9[0x2]
800083bc:	14 97       	mov	r7,r10
800083be:	2f c9       	sub	r9,-4
800083c0:	51 09       	stdsp	sp[0x40],r9
800083c2:	5c 78       	castu.h	r8
800083c4:	50 18       	stdsp	sp[0x4],r8
800083c6:	c4 68       	rjmp	80008452 <_vfprintf_r+0x12ee>
800083c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083cc:	40 3c       	lddsp	r12,sp[0xc]
800083ce:	58 0c       	cp.w	r12,0
800083d0:	c1 d0       	breq	8000840a <_vfprintf_r+0x12a6>
800083d2:	10 36       	cp.w	r6,r8
800083d4:	c0 64       	brge	800083e0 <_vfprintf_r+0x127c>
800083d6:	fa cb f9 44 	sub	r11,sp,-1724
800083da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083de:	c1 f8       	rjmp	8000841c <_vfprintf_r+0x12b8>
800083e0:	fa c8 f9 50 	sub	r8,sp,-1712
800083e4:	1a d8       	st.w	--sp,r8
800083e6:	fa c8 fa b8 	sub	r8,sp,-1352
800083ea:	0c 9b       	mov	r11,r6
800083ec:	1a d8       	st.w	--sp,r8
800083ee:	fa c8 fb b4 	sub	r8,sp,-1100
800083f2:	04 9a       	mov	r10,r2
800083f4:	1a d8       	st.w	--sp,r8
800083f6:	08 9c       	mov	r12,r4
800083f8:	fa c8 f9 40 	sub	r8,sp,-1728
800083fc:	fa c9 ff b4 	sub	r9,sp,-76
80008400:	fe b0 f5 1a 	rcall	80006e34 <get_arg>
80008404:	2f dd       	sub	sp,-12
80008406:	78 0b       	ld.w	r11,r12[0x0]
80008408:	c2 48       	rjmp	80008450 <_vfprintf_r+0x12ec>
8000840a:	ee ca ff ff 	sub	r10,r7,-1
8000840e:	10 37       	cp.w	r7,r8
80008410:	c0 94       	brge	80008422 <_vfprintf_r+0x12be>
80008412:	fa c9 f9 44 	sub	r9,sp,-1724
80008416:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000841a:	14 97       	mov	r7,r10
8000841c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008420:	c1 88       	rjmp	80008450 <_vfprintf_r+0x12ec>
80008422:	41 09       	lddsp	r9,sp[0x40]
80008424:	59 f8       	cp.w	r8,31
80008426:	e0 89 00 11 	brgt	80008448 <_vfprintf_r+0x12e4>
8000842a:	f2 cb ff fc 	sub	r11,r9,-4
8000842e:	51 0b       	stdsp	sp[0x40],r11
80008430:	fa c6 f9 44 	sub	r6,sp,-1724
80008434:	72 0b       	ld.w	r11,r9[0x0]
80008436:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000843a:	f3 4b fd 88 	st.w	r9[-632],r11
8000843e:	2f f8       	sub	r8,-1
80008440:	14 97       	mov	r7,r10
80008442:	fb 48 06 b4 	st.w	sp[1716],r8
80008446:	c0 58       	rjmp	80008450 <_vfprintf_r+0x12ec>
80008448:	72 0b       	ld.w	r11,r9[0x0]
8000844a:	14 97       	mov	r7,r10
8000844c:	2f c9       	sub	r9,-4
8000844e:	51 09       	stdsp	sp[0x40],r9
80008450:	50 1b       	stdsp	sp[0x4],r11
80008452:	30 0e       	mov	lr,0
80008454:	30 18       	mov	r8,1
80008456:	50 0e       	stdsp	sp[0x0],lr
80008458:	c2 29       	rjmp	8000869c <_vfprintf_r+0x1538>
8000845a:	50 a7       	stdsp	sp[0x28],r7
8000845c:	50 80       	stdsp	sp[0x20],r0
8000845e:	0c 97       	mov	r7,r6
80008460:	04 94       	mov	r4,r2
80008462:	06 96       	mov	r6,r3
80008464:	02 92       	mov	r2,r1
80008466:	fe cc b6 46 	sub	r12,pc,-18874
8000846a:	40 93       	lddsp	r3,sp[0x24]
8000846c:	10 90       	mov	r0,r8
8000846e:	40 41       	lddsp	r1,sp[0x10]
80008470:	50 dc       	stdsp	sp[0x34],r12
80008472:	ed b5 00 05 	bld	r5,0x5
80008476:	c5 51       	brne	80008520 <_vfprintf_r+0x13bc>
80008478:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000847c:	40 3b       	lddsp	r11,sp[0xc]
8000847e:	58 0b       	cp.w	r11,0
80008480:	c2 20       	breq	800084c4 <_vfprintf_r+0x1360>
80008482:	10 36       	cp.w	r6,r8
80008484:	c0 a4       	brge	80008498 <_vfprintf_r+0x1334>
80008486:	fa ca f9 44 	sub	r10,sp,-1724
8000848a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000848e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008492:	fa e9 00 00 	st.d	sp[0],r8
80008496:	cf 28       	rjmp	8000867a <_vfprintf_r+0x1516>
80008498:	fa c8 f9 50 	sub	r8,sp,-1712
8000849c:	1a d8       	st.w	--sp,r8
8000849e:	fa c8 fa b8 	sub	r8,sp,-1352
800084a2:	04 9a       	mov	r10,r2
800084a4:	1a d8       	st.w	--sp,r8
800084a6:	0c 9b       	mov	r11,r6
800084a8:	fa c8 fb b4 	sub	r8,sp,-1100
800084ac:	08 9c       	mov	r12,r4
800084ae:	1a d8       	st.w	--sp,r8
800084b0:	fa c8 f9 40 	sub	r8,sp,-1728
800084b4:	fa c9 ff b4 	sub	r9,sp,-76
800084b8:	fe b0 f4 be 	rcall	80006e34 <get_arg>
800084bc:	2f dd       	sub	sp,-12
800084be:	f8 ea 00 00 	ld.d	r10,r12[0]
800084c2:	c0 c8       	rjmp	800084da <_vfprintf_r+0x1376>
800084c4:	ee ca ff ff 	sub	r10,r7,-1
800084c8:	10 37       	cp.w	r7,r8
800084ca:	c0 b4       	brge	800084e0 <_vfprintf_r+0x137c>
800084cc:	fa c9 f9 44 	sub	r9,sp,-1724
800084d0:	14 97       	mov	r7,r10
800084d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084d6:	ec ea fd 88 	ld.d	r10,r6[-632]
800084da:	fa eb 00 00 	st.d	sp[0],r10
800084de:	cc e8       	rjmp	8000867a <_vfprintf_r+0x1516>
800084e0:	41 09       	lddsp	r9,sp[0x40]
800084e2:	59 f8       	cp.w	r8,31
800084e4:	e0 89 00 16 	brgt	80008510 <_vfprintf_r+0x13ac>
800084e8:	f2 e6 00 00 	ld.d	r6,r9[0]
800084ec:	f2 cb ff f8 	sub	r11,r9,-8
800084f0:	fa e7 00 00 	st.d	sp[0],r6
800084f4:	51 0b       	stdsp	sp[0x40],r11
800084f6:	fa c6 f9 44 	sub	r6,sp,-1724
800084fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084fe:	fa e6 00 00 	ld.d	r6,sp[0]
80008502:	f2 e7 fd 88 	st.d	r9[-632],r6
80008506:	2f f8       	sub	r8,-1
80008508:	14 97       	mov	r7,r10
8000850a:	fb 48 06 b4 	st.w	sp[1716],r8
8000850e:	cb 68       	rjmp	8000867a <_vfprintf_r+0x1516>
80008510:	f2 e6 00 00 	ld.d	r6,r9[0]
80008514:	2f 89       	sub	r9,-8
80008516:	fa e7 00 00 	st.d	sp[0],r6
8000851a:	51 09       	stdsp	sp[0x40],r9
8000851c:	14 97       	mov	r7,r10
8000851e:	ca e8       	rjmp	8000867a <_vfprintf_r+0x1516>
80008520:	ed b5 00 04 	bld	r5,0x4
80008524:	c1 71       	brne	80008552 <_vfprintf_r+0x13ee>
80008526:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000852a:	40 3e       	lddsp	lr,sp[0xc]
8000852c:	58 0e       	cp.w	lr,0
8000852e:	c0 80       	breq	8000853e <_vfprintf_r+0x13da>
80008530:	10 36       	cp.w	r6,r8
80008532:	c6 94       	brge	80008604 <_vfprintf_r+0x14a0>
80008534:	fa cc f9 44 	sub	r12,sp,-1724
80008538:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000853c:	c8 28       	rjmp	80008640 <_vfprintf_r+0x14dc>
8000853e:	ee ca ff ff 	sub	r10,r7,-1
80008542:	10 37       	cp.w	r7,r8
80008544:	e0 84 00 81 	brge	80008646 <_vfprintf_r+0x14e2>
80008548:	fa cb f9 44 	sub	r11,sp,-1724
8000854c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008550:	c7 78       	rjmp	8000863e <_vfprintf_r+0x14da>
80008552:	ed b5 00 06 	bld	r5,0x6
80008556:	c4 b1       	brne	800085ec <_vfprintf_r+0x1488>
80008558:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000855c:	40 3c       	lddsp	r12,sp[0xc]
8000855e:	58 0c       	cp.w	r12,0
80008560:	c1 d0       	breq	8000859a <_vfprintf_r+0x1436>
80008562:	10 36       	cp.w	r6,r8
80008564:	c0 64       	brge	80008570 <_vfprintf_r+0x140c>
80008566:	fa cb f9 44 	sub	r11,sp,-1724
8000856a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000856e:	c1 f8       	rjmp	800085ac <_vfprintf_r+0x1448>
80008570:	fa c8 f9 50 	sub	r8,sp,-1712
80008574:	1a d8       	st.w	--sp,r8
80008576:	fa c8 fa b8 	sub	r8,sp,-1352
8000857a:	1a d8       	st.w	--sp,r8
8000857c:	fa c8 fb b4 	sub	r8,sp,-1100
80008580:	1a d8       	st.w	--sp,r8
80008582:	fa c8 f9 40 	sub	r8,sp,-1728
80008586:	fa c9 ff b4 	sub	r9,sp,-76
8000858a:	04 9a       	mov	r10,r2
8000858c:	0c 9b       	mov	r11,r6
8000858e:	08 9c       	mov	r12,r4
80008590:	fe b0 f4 52 	rcall	80006e34 <get_arg>
80008594:	2f dd       	sub	sp,-12
80008596:	98 18       	ld.sh	r8,r12[0x2]
80008598:	c2 78       	rjmp	800085e6 <_vfprintf_r+0x1482>
8000859a:	ee ca ff ff 	sub	r10,r7,-1
8000859e:	10 37       	cp.w	r7,r8
800085a0:	c0 a4       	brge	800085b4 <_vfprintf_r+0x1450>
800085a2:	fa c9 f9 44 	sub	r9,sp,-1724
800085a6:	14 97       	mov	r7,r10
800085a8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085ac:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800085b0:	c1 b8       	rjmp	800085e6 <_vfprintf_r+0x1482>
800085b2:	d7 03       	nop
800085b4:	41 09       	lddsp	r9,sp[0x40]
800085b6:	59 f8       	cp.w	r8,31
800085b8:	e0 89 00 13 	brgt	800085de <_vfprintf_r+0x147a>
800085bc:	f2 cb ff fc 	sub	r11,r9,-4
800085c0:	51 0b       	stdsp	sp[0x40],r11
800085c2:	72 09       	ld.w	r9,r9[0x0]
800085c4:	fa c6 f9 44 	sub	r6,sp,-1724
800085c8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800085cc:	2f f8       	sub	r8,-1
800085ce:	f7 49 fd 88 	st.w	r11[-632],r9
800085d2:	fb 48 06 b4 	st.w	sp[1716],r8
800085d6:	14 97       	mov	r7,r10
800085d8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800085dc:	c0 58       	rjmp	800085e6 <_vfprintf_r+0x1482>
800085de:	92 18       	ld.sh	r8,r9[0x2]
800085e0:	14 97       	mov	r7,r10
800085e2:	2f c9       	sub	r9,-4
800085e4:	51 09       	stdsp	sp[0x40],r9
800085e6:	5c 78       	castu.h	r8
800085e8:	50 18       	stdsp	sp[0x4],r8
800085ea:	c4 68       	rjmp	80008676 <_vfprintf_r+0x1512>
800085ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085f0:	40 3c       	lddsp	r12,sp[0xc]
800085f2:	58 0c       	cp.w	r12,0
800085f4:	c1 d0       	breq	8000862e <_vfprintf_r+0x14ca>
800085f6:	10 36       	cp.w	r6,r8
800085f8:	c0 64       	brge	80008604 <_vfprintf_r+0x14a0>
800085fa:	fa cb f9 44 	sub	r11,sp,-1724
800085fe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008602:	c1 f8       	rjmp	80008640 <_vfprintf_r+0x14dc>
80008604:	fa c8 f9 50 	sub	r8,sp,-1712
80008608:	1a d8       	st.w	--sp,r8
8000860a:	fa c8 fa b8 	sub	r8,sp,-1352
8000860e:	0c 9b       	mov	r11,r6
80008610:	1a d8       	st.w	--sp,r8
80008612:	fa c8 fb b4 	sub	r8,sp,-1100
80008616:	04 9a       	mov	r10,r2
80008618:	1a d8       	st.w	--sp,r8
8000861a:	08 9c       	mov	r12,r4
8000861c:	fa c8 f9 40 	sub	r8,sp,-1728
80008620:	fa c9 ff b4 	sub	r9,sp,-76
80008624:	fe b0 f4 08 	rcall	80006e34 <get_arg>
80008628:	2f dd       	sub	sp,-12
8000862a:	78 0b       	ld.w	r11,r12[0x0]
8000862c:	c2 48       	rjmp	80008674 <_vfprintf_r+0x1510>
8000862e:	ee ca ff ff 	sub	r10,r7,-1
80008632:	10 37       	cp.w	r7,r8
80008634:	c0 94       	brge	80008646 <_vfprintf_r+0x14e2>
80008636:	fa c9 f9 44 	sub	r9,sp,-1724
8000863a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000863e:	14 97       	mov	r7,r10
80008640:	ec fb fd 88 	ld.w	r11,r6[-632]
80008644:	c1 88       	rjmp	80008674 <_vfprintf_r+0x1510>
80008646:	41 09       	lddsp	r9,sp[0x40]
80008648:	59 f8       	cp.w	r8,31
8000864a:	e0 89 00 11 	brgt	8000866c <_vfprintf_r+0x1508>
8000864e:	f2 cb ff fc 	sub	r11,r9,-4
80008652:	51 0b       	stdsp	sp[0x40],r11
80008654:	fa c6 f9 44 	sub	r6,sp,-1724
80008658:	72 0b       	ld.w	r11,r9[0x0]
8000865a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000865e:	f3 4b fd 88 	st.w	r9[-632],r11
80008662:	2f f8       	sub	r8,-1
80008664:	14 97       	mov	r7,r10
80008666:	fb 48 06 b4 	st.w	sp[1716],r8
8000866a:	c0 58       	rjmp	80008674 <_vfprintf_r+0x1510>
8000866c:	72 0b       	ld.w	r11,r9[0x0]
8000866e:	14 97       	mov	r7,r10
80008670:	2f c9       	sub	r9,-4
80008672:	51 09       	stdsp	sp[0x40],r9
80008674:	50 1b       	stdsp	sp[0x4],r11
80008676:	30 0e       	mov	lr,0
80008678:	50 0e       	stdsp	sp[0x0],lr
8000867a:	40 08       	lddsp	r8,sp[0x0]
8000867c:	40 1c       	lddsp	r12,sp[0x4]
8000867e:	18 48       	or	r8,r12
80008680:	5f 19       	srne	r9
80008682:	0a 98       	mov	r8,r5
80008684:	eb e9 00 09 	and	r9,r5,r9
80008688:	a1 b8       	sbr	r8,0x1
8000868a:	58 09       	cp.w	r9,0
8000868c:	c0 70       	breq	8000869a <_vfprintf_r+0x1536>
8000868e:	10 95       	mov	r5,r8
80008690:	fb 60 06 b9 	st.b	sp[1721],r0
80008694:	33 08       	mov	r8,48
80008696:	fb 68 06 b8 	st.b	sp[1720],r8
8000869a:	30 28       	mov	r8,2
8000869c:	30 09       	mov	r9,0
8000869e:	fb 69 06 bb 	st.b	sp[1723],r9
800086a2:	0a 99       	mov	r9,r5
800086a4:	a7 d9       	cbr	r9,0x7
800086a6:	40 2b       	lddsp	r11,sp[0x8]
800086a8:	40 16       	lddsp	r6,sp[0x4]
800086aa:	58 0b       	cp.w	r11,0
800086ac:	5f 1a       	srne	r10
800086ae:	f2 05 17 40 	movge	r5,r9
800086b2:	fa c2 f9 78 	sub	r2,sp,-1672
800086b6:	40 09       	lddsp	r9,sp[0x0]
800086b8:	0c 49       	or	r9,r6
800086ba:	5f 19       	srne	r9
800086bc:	f5 e9 10 09 	or	r9,r10,r9
800086c0:	c5 c0       	breq	80008778 <_vfprintf_r+0x1614>
800086c2:	30 19       	mov	r9,1
800086c4:	f2 08 18 00 	cp.b	r8,r9
800086c8:	c0 60       	breq	800086d4 <_vfprintf_r+0x1570>
800086ca:	30 29       	mov	r9,2
800086cc:	f2 08 18 00 	cp.b	r8,r9
800086d0:	c0 41       	brne	800086d8 <_vfprintf_r+0x1574>
800086d2:	c3 c8       	rjmp	8000874a <_vfprintf_r+0x15e6>
800086d4:	04 96       	mov	r6,r2
800086d6:	c3 08       	rjmp	80008736 <_vfprintf_r+0x15d2>
800086d8:	04 96       	mov	r6,r2
800086da:	fa e8 00 00 	ld.d	r8,sp[0]
800086de:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800086e2:	2d 0a       	sub	r10,-48
800086e4:	0c fa       	st.b	--r6,r10
800086e6:	f0 0b 16 03 	lsr	r11,r8,0x3
800086ea:	f2 0c 16 03 	lsr	r12,r9,0x3
800086ee:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800086f2:	18 99       	mov	r9,r12
800086f4:	16 98       	mov	r8,r11
800086f6:	58 08       	cp.w	r8,0
800086f8:	5c 29       	cpc	r9
800086fa:	cf 21       	brne	800086de <_vfprintf_r+0x157a>
800086fc:	fa e9 00 00 	st.d	sp[0],r8
80008700:	ed b5 00 00 	bld	r5,0x0
80008704:	c4 51       	brne	8000878e <_vfprintf_r+0x162a>
80008706:	33 09       	mov	r9,48
80008708:	f2 0a 18 00 	cp.b	r10,r9
8000870c:	c4 10       	breq	8000878e <_vfprintf_r+0x162a>
8000870e:	0c f9       	st.b	--r6,r9
80008710:	c3 f8       	rjmp	8000878e <_vfprintf_r+0x162a>
80008712:	fa ea 00 00 	ld.d	r10,sp[0]
80008716:	30 a8       	mov	r8,10
80008718:	30 09       	mov	r9,0
8000871a:	e0 a0 1a 19 	rcall	8000bb4c <__avr32_umod64>
8000871e:	30 a8       	mov	r8,10
80008720:	2d 0a       	sub	r10,-48
80008722:	30 09       	mov	r9,0
80008724:	ac 8a       	st.b	r6[0x0],r10
80008726:	fa ea 00 00 	ld.d	r10,sp[0]
8000872a:	e0 a0 18 df 	rcall	8000b8e8 <__avr32_udiv64>
8000872e:	16 99       	mov	r9,r11
80008730:	14 98       	mov	r8,r10
80008732:	fa e9 00 00 	st.d	sp[0],r8
80008736:	20 16       	sub	r6,1
80008738:	fa ea 00 00 	ld.d	r10,sp[0]
8000873c:	58 9a       	cp.w	r10,9
8000873e:	5c 2b       	cpc	r11
80008740:	fe 9b ff e9 	brhi	80008712 <_vfprintf_r+0x15ae>
80008744:	1b f8       	ld.ub	r8,sp[0x7]
80008746:	2d 08       	sub	r8,-48
80008748:	c2 08       	rjmp	80008788 <_vfprintf_r+0x1624>
8000874a:	04 96       	mov	r6,r2
8000874c:	fa e8 00 00 	ld.d	r8,sp[0]
80008750:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008754:	40 de       	lddsp	lr,sp[0x34]
80008756:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000875a:	0c fa       	st.b	--r6,r10
8000875c:	f2 0b 16 04 	lsr	r11,r9,0x4
80008760:	f0 0a 16 04 	lsr	r10,r8,0x4
80008764:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008768:	16 99       	mov	r9,r11
8000876a:	14 98       	mov	r8,r10
8000876c:	58 08       	cp.w	r8,0
8000876e:	5c 29       	cpc	r9
80008770:	cf 01       	brne	80008750 <_vfprintf_r+0x15ec>
80008772:	fa e9 00 00 	st.d	sp[0],r8
80008776:	c0 c8       	rjmp	8000878e <_vfprintf_r+0x162a>
80008778:	58 08       	cp.w	r8,0
8000877a:	c0 91       	brne	8000878c <_vfprintf_r+0x1628>
8000877c:	ed b5 00 00 	bld	r5,0x0
80008780:	c0 61       	brne	8000878c <_vfprintf_r+0x1628>
80008782:	fa c6 f9 79 	sub	r6,sp,-1671
80008786:	33 08       	mov	r8,48
80008788:	ac 88       	st.b	r6[0x0],r8
8000878a:	c0 28       	rjmp	8000878e <_vfprintf_r+0x162a>
8000878c:	04 96       	mov	r6,r2
8000878e:	0c 12       	sub	r2,r6
80008790:	c1 c8       	rjmp	800087c8 <_vfprintf_r+0x1664>
80008792:	50 a7       	stdsp	sp[0x28],r7
80008794:	50 80       	stdsp	sp[0x20],r0
80008796:	40 93       	lddsp	r3,sp[0x24]
80008798:	0c 97       	mov	r7,r6
8000879a:	10 90       	mov	r0,r8
8000879c:	04 94       	mov	r4,r2
8000879e:	40 41       	lddsp	r1,sp[0x10]
800087a0:	58 08       	cp.w	r8,0
800087a2:	e0 80 04 4f 	breq	80009040 <_vfprintf_r+0x1edc>
800087a6:	fb 68 06 60 	st.b	sp[1632],r8
800087aa:	30 0c       	mov	r12,0
800087ac:	30 08       	mov	r8,0
800087ae:	30 12       	mov	r2,1
800087b0:	fb 68 06 bb 	st.b	sp[1723],r8
800087b4:	50 2c       	stdsp	sp[0x8],r12
800087b6:	fa c6 f9 a0 	sub	r6,sp,-1632
800087ba:	c0 78       	rjmp	800087c8 <_vfprintf_r+0x1664>
800087bc:	30 0b       	mov	r11,0
800087be:	50 2b       	stdsp	sp[0x8],r11
800087c0:	c0 48       	rjmp	800087c8 <_vfprintf_r+0x1664>
800087c2:	40 22       	lddsp	r2,sp[0x8]
800087c4:	30 0a       	mov	r10,0
800087c6:	50 2a       	stdsp	sp[0x8],r10
800087c8:	40 29       	lddsp	r9,sp[0x8]
800087ca:	e4 09 0c 49 	max	r9,r2,r9
800087ce:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800087d2:	50 39       	stdsp	sp[0xc],r9
800087d4:	0a 9e       	mov	lr,r5
800087d6:	30 09       	mov	r9,0
800087d8:	e2 1e 00 02 	andl	lr,0x2,COH
800087dc:	f2 08 18 00 	cp.b	r8,r9
800087e0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800087e4:	f7 b8 01 ff 	subne	r8,-1
800087e8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800087ec:	0a 9b       	mov	r11,r5
800087ee:	58 0e       	cp.w	lr,0
800087f0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800087f4:	f7 bc 01 fe 	subne	r12,-2
800087f8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800087fc:	e2 1b 00 84 	andl	r11,0x84,COH
80008800:	50 fe       	stdsp	sp[0x3c],lr
80008802:	50 9b       	stdsp	sp[0x24],r11
80008804:	c4 71       	brne	80008892 <_vfprintf_r+0x172e>
80008806:	40 8a       	lddsp	r10,sp[0x20]
80008808:	40 39       	lddsp	r9,sp[0xc]
8000880a:	12 1a       	sub	r10,r9
8000880c:	50 4a       	stdsp	sp[0x10],r10
8000880e:	58 0a       	cp.w	r10,0
80008810:	e0 89 00 20 	brgt	80008850 <_vfprintf_r+0x16ec>
80008814:	c3 f8       	rjmp	80008892 <_vfprintf_r+0x172e>
80008816:	2f 09       	sub	r9,-16
80008818:	2f f8       	sub	r8,-1
8000881a:	fe ce b9 e2 	sub	lr,pc,-17950
8000881e:	31 0c       	mov	r12,16
80008820:	fb 49 06 90 	st.w	sp[1680],r9
80008824:	87 0e       	st.w	r3[0x0],lr
80008826:	87 1c       	st.w	r3[0x4],r12
80008828:	fb 48 06 8c 	st.w	sp[1676],r8
8000882c:	58 78       	cp.w	r8,7
8000882e:	e0 89 00 04 	brgt	80008836 <_vfprintf_r+0x16d2>
80008832:	2f 83       	sub	r3,-8
80008834:	c0 b8       	rjmp	8000884a <_vfprintf_r+0x16e6>
80008836:	fa ca f9 78 	sub	r10,sp,-1672
8000883a:	02 9b       	mov	r11,r1
8000883c:	08 9c       	mov	r12,r4
8000883e:	fe b0 f4 85 	rcall	80007148 <__sprint_r>
80008842:	e0 81 04 10 	brne	80009062 <_vfprintf_r+0x1efe>
80008846:	fa c3 f9 e0 	sub	r3,sp,-1568
8000884a:	40 4b       	lddsp	r11,sp[0x10]
8000884c:	21 0b       	sub	r11,16
8000884e:	50 4b       	stdsp	sp[0x10],r11
80008850:	fa f9 06 90 	ld.w	r9,sp[1680]
80008854:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008858:	fe ca ba 20 	sub	r10,pc,-17888
8000885c:	40 4e       	lddsp	lr,sp[0x10]
8000885e:	59 0e       	cp.w	lr,16
80008860:	fe 99 ff db 	brgt	80008816 <_vfprintf_r+0x16b2>
80008864:	1c 09       	add	r9,lr
80008866:	2f f8       	sub	r8,-1
80008868:	87 0a       	st.w	r3[0x0],r10
8000886a:	fb 49 06 90 	st.w	sp[1680],r9
8000886e:	87 1e       	st.w	r3[0x4],lr
80008870:	fb 48 06 8c 	st.w	sp[1676],r8
80008874:	58 78       	cp.w	r8,7
80008876:	e0 89 00 04 	brgt	8000887e <_vfprintf_r+0x171a>
8000887a:	2f 83       	sub	r3,-8
8000887c:	c0 b8       	rjmp	80008892 <_vfprintf_r+0x172e>
8000887e:	fa ca f9 78 	sub	r10,sp,-1672
80008882:	02 9b       	mov	r11,r1
80008884:	08 9c       	mov	r12,r4
80008886:	fe b0 f4 61 	rcall	80007148 <__sprint_r>
8000888a:	e0 81 03 ec 	brne	80009062 <_vfprintf_r+0x1efe>
8000888e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008892:	30 09       	mov	r9,0
80008894:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008898:	f2 08 18 00 	cp.b	r8,r9
8000889c:	c1 f0       	breq	800088da <_vfprintf_r+0x1776>
8000889e:	fa f8 06 90 	ld.w	r8,sp[1680]
800088a2:	fa c9 f9 45 	sub	r9,sp,-1723
800088a6:	2f f8       	sub	r8,-1
800088a8:	87 09       	st.w	r3[0x0],r9
800088aa:	fb 48 06 90 	st.w	sp[1680],r8
800088ae:	30 19       	mov	r9,1
800088b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088b4:	87 19       	st.w	r3[0x4],r9
800088b6:	2f f8       	sub	r8,-1
800088b8:	fb 48 06 8c 	st.w	sp[1676],r8
800088bc:	58 78       	cp.w	r8,7
800088be:	e0 89 00 04 	brgt	800088c6 <_vfprintf_r+0x1762>
800088c2:	2f 83       	sub	r3,-8
800088c4:	c0 b8       	rjmp	800088da <_vfprintf_r+0x1776>
800088c6:	fa ca f9 78 	sub	r10,sp,-1672
800088ca:	02 9b       	mov	r11,r1
800088cc:	08 9c       	mov	r12,r4
800088ce:	fe b0 f4 3d 	rcall	80007148 <__sprint_r>
800088d2:	e0 81 03 c8 	brne	80009062 <_vfprintf_r+0x1efe>
800088d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800088da:	40 fc       	lddsp	r12,sp[0x3c]
800088dc:	58 0c       	cp.w	r12,0
800088de:	c1 f0       	breq	8000891c <_vfprintf_r+0x17b8>
800088e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800088e4:	fa c9 f9 48 	sub	r9,sp,-1720
800088e8:	2f e8       	sub	r8,-2
800088ea:	87 09       	st.w	r3[0x0],r9
800088ec:	fb 48 06 90 	st.w	sp[1680],r8
800088f0:	30 29       	mov	r9,2
800088f2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088f6:	87 19       	st.w	r3[0x4],r9
800088f8:	2f f8       	sub	r8,-1
800088fa:	fb 48 06 8c 	st.w	sp[1676],r8
800088fe:	58 78       	cp.w	r8,7
80008900:	e0 89 00 04 	brgt	80008908 <_vfprintf_r+0x17a4>
80008904:	2f 83       	sub	r3,-8
80008906:	c0 b8       	rjmp	8000891c <_vfprintf_r+0x17b8>
80008908:	fa ca f9 78 	sub	r10,sp,-1672
8000890c:	02 9b       	mov	r11,r1
8000890e:	08 9c       	mov	r12,r4
80008910:	fe b0 f4 1c 	rcall	80007148 <__sprint_r>
80008914:	e0 81 03 a7 	brne	80009062 <_vfprintf_r+0x1efe>
80008918:	fa c3 f9 e0 	sub	r3,sp,-1568
8000891c:	40 9b       	lddsp	r11,sp[0x24]
8000891e:	e0 4b 00 80 	cp.w	r11,128
80008922:	c4 71       	brne	800089b0 <_vfprintf_r+0x184c>
80008924:	40 8a       	lddsp	r10,sp[0x20]
80008926:	40 39       	lddsp	r9,sp[0xc]
80008928:	12 1a       	sub	r10,r9
8000892a:	50 4a       	stdsp	sp[0x10],r10
8000892c:	58 0a       	cp.w	r10,0
8000892e:	e0 89 00 20 	brgt	8000896e <_vfprintf_r+0x180a>
80008932:	c3 f8       	rjmp	800089b0 <_vfprintf_r+0x184c>
80008934:	2f 09       	sub	r9,-16
80008936:	2f f8       	sub	r8,-1
80008938:	fe ce ba f0 	sub	lr,pc,-17680
8000893c:	31 0c       	mov	r12,16
8000893e:	fb 49 06 90 	st.w	sp[1680],r9
80008942:	87 0e       	st.w	r3[0x0],lr
80008944:	87 1c       	st.w	r3[0x4],r12
80008946:	fb 48 06 8c 	st.w	sp[1676],r8
8000894a:	58 78       	cp.w	r8,7
8000894c:	e0 89 00 04 	brgt	80008954 <_vfprintf_r+0x17f0>
80008950:	2f 83       	sub	r3,-8
80008952:	c0 b8       	rjmp	80008968 <_vfprintf_r+0x1804>
80008954:	fa ca f9 78 	sub	r10,sp,-1672
80008958:	02 9b       	mov	r11,r1
8000895a:	08 9c       	mov	r12,r4
8000895c:	fe b0 f3 f6 	rcall	80007148 <__sprint_r>
80008960:	e0 81 03 81 	brne	80009062 <_vfprintf_r+0x1efe>
80008964:	fa c3 f9 e0 	sub	r3,sp,-1568
80008968:	40 4b       	lddsp	r11,sp[0x10]
8000896a:	21 0b       	sub	r11,16
8000896c:	50 4b       	stdsp	sp[0x10],r11
8000896e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008972:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008976:	fe ca bb 2e 	sub	r10,pc,-17618
8000897a:	40 4e       	lddsp	lr,sp[0x10]
8000897c:	59 0e       	cp.w	lr,16
8000897e:	fe 99 ff db 	brgt	80008934 <_vfprintf_r+0x17d0>
80008982:	1c 09       	add	r9,lr
80008984:	2f f8       	sub	r8,-1
80008986:	87 0a       	st.w	r3[0x0],r10
80008988:	fb 49 06 90 	st.w	sp[1680],r9
8000898c:	87 1e       	st.w	r3[0x4],lr
8000898e:	fb 48 06 8c 	st.w	sp[1676],r8
80008992:	58 78       	cp.w	r8,7
80008994:	e0 89 00 04 	brgt	8000899c <_vfprintf_r+0x1838>
80008998:	2f 83       	sub	r3,-8
8000899a:	c0 b8       	rjmp	800089b0 <_vfprintf_r+0x184c>
8000899c:	fa ca f9 78 	sub	r10,sp,-1672
800089a0:	02 9b       	mov	r11,r1
800089a2:	08 9c       	mov	r12,r4
800089a4:	fe b0 f3 d2 	rcall	80007148 <__sprint_r>
800089a8:	e0 81 03 5d 	brne	80009062 <_vfprintf_r+0x1efe>
800089ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800089b0:	40 2c       	lddsp	r12,sp[0x8]
800089b2:	04 1c       	sub	r12,r2
800089b4:	50 2c       	stdsp	sp[0x8],r12
800089b6:	58 0c       	cp.w	r12,0
800089b8:	e0 89 00 20 	brgt	800089f8 <_vfprintf_r+0x1894>
800089bc:	c3 f8       	rjmp	80008a3a <_vfprintf_r+0x18d6>
800089be:	2f 09       	sub	r9,-16
800089c0:	2f f8       	sub	r8,-1
800089c2:	fe cb bb 7a 	sub	r11,pc,-17542
800089c6:	31 0a       	mov	r10,16
800089c8:	fb 49 06 90 	st.w	sp[1680],r9
800089cc:	87 0b       	st.w	r3[0x0],r11
800089ce:	87 1a       	st.w	r3[0x4],r10
800089d0:	fb 48 06 8c 	st.w	sp[1676],r8
800089d4:	58 78       	cp.w	r8,7
800089d6:	e0 89 00 04 	brgt	800089de <_vfprintf_r+0x187a>
800089da:	2f 83       	sub	r3,-8
800089dc:	c0 b8       	rjmp	800089f2 <_vfprintf_r+0x188e>
800089de:	fa ca f9 78 	sub	r10,sp,-1672
800089e2:	02 9b       	mov	r11,r1
800089e4:	08 9c       	mov	r12,r4
800089e6:	fe b0 f3 b1 	rcall	80007148 <__sprint_r>
800089ea:	e0 81 03 3c 	brne	80009062 <_vfprintf_r+0x1efe>
800089ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800089f2:	40 29       	lddsp	r9,sp[0x8]
800089f4:	21 09       	sub	r9,16
800089f6:	50 29       	stdsp	sp[0x8],r9
800089f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800089fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a00:	fe ca bb b8 	sub	r10,pc,-17480
80008a04:	40 2e       	lddsp	lr,sp[0x8]
80008a06:	59 0e       	cp.w	lr,16
80008a08:	fe 99 ff db 	brgt	800089be <_vfprintf_r+0x185a>
80008a0c:	1c 09       	add	r9,lr
80008a0e:	2f f8       	sub	r8,-1
80008a10:	87 0a       	st.w	r3[0x0],r10
80008a12:	fb 49 06 90 	st.w	sp[1680],r9
80008a16:	87 1e       	st.w	r3[0x4],lr
80008a18:	fb 48 06 8c 	st.w	sp[1676],r8
80008a1c:	58 78       	cp.w	r8,7
80008a1e:	e0 89 00 04 	brgt	80008a26 <_vfprintf_r+0x18c2>
80008a22:	2f 83       	sub	r3,-8
80008a24:	c0 b8       	rjmp	80008a3a <_vfprintf_r+0x18d6>
80008a26:	fa ca f9 78 	sub	r10,sp,-1672
80008a2a:	02 9b       	mov	r11,r1
80008a2c:	08 9c       	mov	r12,r4
80008a2e:	fe b0 f3 8d 	rcall	80007148 <__sprint_r>
80008a32:	e0 81 03 18 	brne	80009062 <_vfprintf_r+0x1efe>
80008a36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a3a:	ed b5 00 08 	bld	r5,0x8
80008a3e:	c0 b0       	breq	80008a54 <_vfprintf_r+0x18f0>
80008a40:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a44:	87 12       	st.w	r3[0x4],r2
80008a46:	87 06       	st.w	r3[0x0],r6
80008a48:	f0 02 00 02 	add	r2,r8,r2
80008a4c:	fb 42 06 90 	st.w	sp[1680],r2
80008a50:	e0 8f 01 d4 	bral	80008df8 <_vfprintf_r+0x1c94>
80008a54:	e0 40 00 65 	cp.w	r0,101
80008a58:	e0 8a 01 d6 	brle	80008e04 <_vfprintf_r+0x1ca0>
80008a5c:	30 08       	mov	r8,0
80008a5e:	30 09       	mov	r9,0
80008a60:	40 5b       	lddsp	r11,sp[0x14]
80008a62:	40 7a       	lddsp	r10,sp[0x1c]
80008a64:	e0 a0 15 3b 	rcall	8000b4da <__avr32_f64_cmp_eq>
80008a68:	c7 90       	breq	80008b5a <_vfprintf_r+0x19f6>
80008a6a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a6e:	fe c9 bc 3a 	sub	r9,pc,-17350
80008a72:	2f f8       	sub	r8,-1
80008a74:	87 09       	st.w	r3[0x0],r9
80008a76:	fb 48 06 90 	st.w	sp[1680],r8
80008a7a:	30 19       	mov	r9,1
80008a7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a80:	87 19       	st.w	r3[0x4],r9
80008a82:	2f f8       	sub	r8,-1
80008a84:	fb 48 06 8c 	st.w	sp[1676],r8
80008a88:	58 78       	cp.w	r8,7
80008a8a:	e0 89 00 05 	brgt	80008a94 <_vfprintf_r+0x1930>
80008a8e:	2f 83       	sub	r3,-8
80008a90:	c0 c8       	rjmp	80008aa8 <_vfprintf_r+0x1944>
80008a92:	d7 03       	nop
80008a94:	fa ca f9 78 	sub	r10,sp,-1672
80008a98:	02 9b       	mov	r11,r1
80008a9a:	08 9c       	mov	r12,r4
80008a9c:	fe b0 f3 56 	rcall	80007148 <__sprint_r>
80008aa0:	e0 81 02 e1 	brne	80009062 <_vfprintf_r+0x1efe>
80008aa4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008aa8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008aac:	40 6c       	lddsp	r12,sp[0x18]
80008aae:	18 38       	cp.w	r8,r12
80008ab0:	c0 55       	brlt	80008aba <_vfprintf_r+0x1956>
80008ab2:	ed b5 00 00 	bld	r5,0x0
80008ab6:	e0 81 02 6b 	brne	80008f8c <_vfprintf_r+0x1e28>
80008aba:	fa f8 06 90 	ld.w	r8,sp[1680]
80008abe:	2f f8       	sub	r8,-1
80008ac0:	40 cb       	lddsp	r11,sp[0x30]
80008ac2:	fb 48 06 90 	st.w	sp[1680],r8
80008ac6:	30 19       	mov	r9,1
80008ac8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008acc:	87 0b       	st.w	r3[0x0],r11
80008ace:	2f f8       	sub	r8,-1
80008ad0:	87 19       	st.w	r3[0x4],r9
80008ad2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ad6:	58 78       	cp.w	r8,7
80008ad8:	e0 89 00 04 	brgt	80008ae0 <_vfprintf_r+0x197c>
80008adc:	2f 83       	sub	r3,-8
80008ade:	c0 b8       	rjmp	80008af4 <_vfprintf_r+0x1990>
80008ae0:	fa ca f9 78 	sub	r10,sp,-1672
80008ae4:	02 9b       	mov	r11,r1
80008ae6:	08 9c       	mov	r12,r4
80008ae8:	fe b0 f3 30 	rcall	80007148 <__sprint_r>
80008aec:	e0 81 02 bb 	brne	80009062 <_vfprintf_r+0x1efe>
80008af0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008af4:	40 66       	lddsp	r6,sp[0x18]
80008af6:	20 16       	sub	r6,1
80008af8:	58 06       	cp.w	r6,0
80008afa:	e0 89 00 1d 	brgt	80008b34 <_vfprintf_r+0x19d0>
80008afe:	e0 8f 02 47 	bral	80008f8c <_vfprintf_r+0x1e28>
80008b02:	2f 09       	sub	r9,-16
80008b04:	2f f8       	sub	r8,-1
80008b06:	fb 49 06 90 	st.w	sp[1680],r9
80008b0a:	87 02       	st.w	r3[0x0],r2
80008b0c:	87 10       	st.w	r3[0x4],r0
80008b0e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b12:	58 78       	cp.w	r8,7
80008b14:	e0 89 00 04 	brgt	80008b1c <_vfprintf_r+0x19b8>
80008b18:	2f 83       	sub	r3,-8
80008b1a:	c0 b8       	rjmp	80008b30 <_vfprintf_r+0x19cc>
80008b1c:	fa ca f9 78 	sub	r10,sp,-1672
80008b20:	02 9b       	mov	r11,r1
80008b22:	08 9c       	mov	r12,r4
80008b24:	fe b0 f3 12 	rcall	80007148 <__sprint_r>
80008b28:	e0 81 02 9d 	brne	80009062 <_vfprintf_r+0x1efe>
80008b2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b30:	21 06       	sub	r6,16
80008b32:	c0 48       	rjmp	80008b3a <_vfprintf_r+0x19d6>
80008b34:	fe c2 bc ec 	sub	r2,pc,-17172
80008b38:	31 00       	mov	r0,16
80008b3a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b42:	fe ca bc fa 	sub	r10,pc,-17158
80008b46:	59 06       	cp.w	r6,16
80008b48:	fe 99 ff dd 	brgt	80008b02 <_vfprintf_r+0x199e>
80008b4c:	0c 09       	add	r9,r6
80008b4e:	87 0a       	st.w	r3[0x0],r10
80008b50:	fb 49 06 90 	st.w	sp[1680],r9
80008b54:	2f f8       	sub	r8,-1
80008b56:	87 16       	st.w	r3[0x4],r6
80008b58:	c5 39       	rjmp	80008dfe <_vfprintf_r+0x1c9a>
80008b5a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008b5e:	58 0a       	cp.w	r10,0
80008b60:	e0 89 00 92 	brgt	80008c84 <_vfprintf_r+0x1b20>
80008b64:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b68:	fe c9 bd 34 	sub	r9,pc,-17100
80008b6c:	2f f8       	sub	r8,-1
80008b6e:	87 09       	st.w	r3[0x0],r9
80008b70:	fb 48 06 90 	st.w	sp[1680],r8
80008b74:	30 19       	mov	r9,1
80008b76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b7a:	87 19       	st.w	r3[0x4],r9
80008b7c:	2f f8       	sub	r8,-1
80008b7e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b82:	58 78       	cp.w	r8,7
80008b84:	e0 89 00 04 	brgt	80008b8c <_vfprintf_r+0x1a28>
80008b88:	2f 83       	sub	r3,-8
80008b8a:	c0 b8       	rjmp	80008ba0 <_vfprintf_r+0x1a3c>
80008b8c:	fa ca f9 78 	sub	r10,sp,-1672
80008b90:	02 9b       	mov	r11,r1
80008b92:	08 9c       	mov	r12,r4
80008b94:	fe b0 f2 da 	rcall	80007148 <__sprint_r>
80008b98:	e0 81 02 65 	brne	80009062 <_vfprintf_r+0x1efe>
80008b9c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ba0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ba4:	58 08       	cp.w	r8,0
80008ba6:	c0 81       	brne	80008bb6 <_vfprintf_r+0x1a52>
80008ba8:	40 6a       	lddsp	r10,sp[0x18]
80008baa:	58 0a       	cp.w	r10,0
80008bac:	c0 51       	brne	80008bb6 <_vfprintf_r+0x1a52>
80008bae:	ed b5 00 00 	bld	r5,0x0
80008bb2:	e0 81 01 ed 	brne	80008f8c <_vfprintf_r+0x1e28>
80008bb6:	40 c9       	lddsp	r9,sp[0x30]
80008bb8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bbc:	2f f8       	sub	r8,-1
80008bbe:	87 09       	st.w	r3[0x0],r9
80008bc0:	fb 48 06 90 	st.w	sp[1680],r8
80008bc4:	30 19       	mov	r9,1
80008bc6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bca:	87 19       	st.w	r3[0x4],r9
80008bcc:	2f f8       	sub	r8,-1
80008bce:	fb 48 06 8c 	st.w	sp[1676],r8
80008bd2:	58 78       	cp.w	r8,7
80008bd4:	e0 89 00 04 	brgt	80008bdc <_vfprintf_r+0x1a78>
80008bd8:	2f 83       	sub	r3,-8
80008bda:	c0 b8       	rjmp	80008bf0 <_vfprintf_r+0x1a8c>
80008bdc:	fa ca f9 78 	sub	r10,sp,-1672
80008be0:	02 9b       	mov	r11,r1
80008be2:	08 9c       	mov	r12,r4
80008be4:	fe b0 f2 b2 	rcall	80007148 <__sprint_r>
80008be8:	e0 81 02 3d 	brne	80009062 <_vfprintf_r+0x1efe>
80008bec:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bf0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bf4:	5c 32       	neg	r2
80008bf6:	58 02       	cp.w	r2,0
80008bf8:	e0 89 00 1d 	brgt	80008c32 <_vfprintf_r+0x1ace>
80008bfc:	c3 d8       	rjmp	80008c76 <_vfprintf_r+0x1b12>
80008bfe:	2f 09       	sub	r9,-16
80008c00:	2f f8       	sub	r8,-1
80008c02:	31 0e       	mov	lr,16
80008c04:	fb 49 06 90 	st.w	sp[1680],r9
80008c08:	87 00       	st.w	r3[0x0],r0
80008c0a:	87 1e       	st.w	r3[0x4],lr
80008c0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008c10:	58 78       	cp.w	r8,7
80008c12:	e0 89 00 04 	brgt	80008c1a <_vfprintf_r+0x1ab6>
80008c16:	2f 83       	sub	r3,-8
80008c18:	c0 b8       	rjmp	80008c2e <_vfprintf_r+0x1aca>
80008c1a:	fa ca f9 78 	sub	r10,sp,-1672
80008c1e:	02 9b       	mov	r11,r1
80008c20:	08 9c       	mov	r12,r4
80008c22:	fe b0 f2 93 	rcall	80007148 <__sprint_r>
80008c26:	e0 81 02 1e 	brne	80009062 <_vfprintf_r+0x1efe>
80008c2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c2e:	21 02       	sub	r2,16
80008c30:	c0 38       	rjmp	80008c36 <_vfprintf_r+0x1ad2>
80008c32:	fe c0 bd ea 	sub	r0,pc,-16918
80008c36:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c3e:	fe ca bd f6 	sub	r10,pc,-16906
80008c42:	59 02       	cp.w	r2,16
80008c44:	fe 99 ff dd 	brgt	80008bfe <_vfprintf_r+0x1a9a>
80008c48:	04 09       	add	r9,r2
80008c4a:	2f f8       	sub	r8,-1
80008c4c:	87 0a       	st.w	r3[0x0],r10
80008c4e:	fb 49 06 90 	st.w	sp[1680],r9
80008c52:	87 12       	st.w	r3[0x4],r2
80008c54:	fb 48 06 8c 	st.w	sp[1676],r8
80008c58:	58 78       	cp.w	r8,7
80008c5a:	e0 89 00 04 	brgt	80008c62 <_vfprintf_r+0x1afe>
80008c5e:	2f 83       	sub	r3,-8
80008c60:	c0 b8       	rjmp	80008c76 <_vfprintf_r+0x1b12>
80008c62:	fa ca f9 78 	sub	r10,sp,-1672
80008c66:	02 9b       	mov	r11,r1
80008c68:	08 9c       	mov	r12,r4
80008c6a:	fe b0 f2 6f 	rcall	80007148 <__sprint_r>
80008c6e:	e0 81 01 fa 	brne	80009062 <_vfprintf_r+0x1efe>
80008c72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c76:	40 6c       	lddsp	r12,sp[0x18]
80008c78:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c7c:	87 06       	st.w	r3[0x0],r6
80008c7e:	87 1c       	st.w	r3[0x4],r12
80008c80:	18 08       	add	r8,r12
80008c82:	cb 98       	rjmp	80008df4 <_vfprintf_r+0x1c90>
80008c84:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c8c:	40 6b       	lddsp	r11,sp[0x18]
80008c8e:	16 3a       	cp.w	r10,r11
80008c90:	c6 f5       	brlt	80008d6e <_vfprintf_r+0x1c0a>
80008c92:	16 09       	add	r9,r11
80008c94:	2f f8       	sub	r8,-1
80008c96:	87 06       	st.w	r3[0x0],r6
80008c98:	fb 49 06 90 	st.w	sp[1680],r9
80008c9c:	87 1b       	st.w	r3[0x4],r11
80008c9e:	fb 48 06 8c 	st.w	sp[1676],r8
80008ca2:	58 78       	cp.w	r8,7
80008ca4:	e0 89 00 04 	brgt	80008cac <_vfprintf_r+0x1b48>
80008ca8:	2f 83       	sub	r3,-8
80008caa:	c0 b8       	rjmp	80008cc0 <_vfprintf_r+0x1b5c>
80008cac:	fa ca f9 78 	sub	r10,sp,-1672
80008cb0:	02 9b       	mov	r11,r1
80008cb2:	08 9c       	mov	r12,r4
80008cb4:	fe b0 f2 4a 	rcall	80007148 <__sprint_r>
80008cb8:	e0 81 01 d5 	brne	80009062 <_vfprintf_r+0x1efe>
80008cbc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cc0:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008cc4:	40 6a       	lddsp	r10,sp[0x18]
80008cc6:	14 16       	sub	r6,r10
80008cc8:	58 06       	cp.w	r6,0
80008cca:	e0 89 00 1c 	brgt	80008d02 <_vfprintf_r+0x1b9e>
80008cce:	c3 d8       	rjmp	80008d48 <_vfprintf_r+0x1be4>
80008cd0:	2f 09       	sub	r9,-16
80008cd2:	2f f8       	sub	r8,-1
80008cd4:	fb 49 06 90 	st.w	sp[1680],r9
80008cd8:	87 02       	st.w	r3[0x0],r2
80008cda:	87 10       	st.w	r3[0x4],r0
80008cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80008ce0:	58 78       	cp.w	r8,7
80008ce2:	e0 89 00 04 	brgt	80008cea <_vfprintf_r+0x1b86>
80008ce6:	2f 83       	sub	r3,-8
80008ce8:	c0 b8       	rjmp	80008cfe <_vfprintf_r+0x1b9a>
80008cea:	fa ca f9 78 	sub	r10,sp,-1672
80008cee:	02 9b       	mov	r11,r1
80008cf0:	08 9c       	mov	r12,r4
80008cf2:	fe b0 f2 2b 	rcall	80007148 <__sprint_r>
80008cf6:	e0 81 01 b6 	brne	80009062 <_vfprintf_r+0x1efe>
80008cfa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cfe:	21 06       	sub	r6,16
80008d00:	c0 48       	rjmp	80008d08 <_vfprintf_r+0x1ba4>
80008d02:	fe c2 be ba 	sub	r2,pc,-16710
80008d06:	31 00       	mov	r0,16
80008d08:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d10:	fe ca be c8 	sub	r10,pc,-16696
80008d14:	59 06       	cp.w	r6,16
80008d16:	fe 99 ff dd 	brgt	80008cd0 <_vfprintf_r+0x1b6c>
80008d1a:	0c 09       	add	r9,r6
80008d1c:	2f f8       	sub	r8,-1
80008d1e:	87 0a       	st.w	r3[0x0],r10
80008d20:	fb 49 06 90 	st.w	sp[1680],r9
80008d24:	87 16       	st.w	r3[0x4],r6
80008d26:	fb 48 06 8c 	st.w	sp[1676],r8
80008d2a:	58 78       	cp.w	r8,7
80008d2c:	e0 89 00 04 	brgt	80008d34 <_vfprintf_r+0x1bd0>
80008d30:	2f 83       	sub	r3,-8
80008d32:	c0 b8       	rjmp	80008d48 <_vfprintf_r+0x1be4>
80008d34:	fa ca f9 78 	sub	r10,sp,-1672
80008d38:	02 9b       	mov	r11,r1
80008d3a:	08 9c       	mov	r12,r4
80008d3c:	fe b0 f2 06 	rcall	80007148 <__sprint_r>
80008d40:	e0 81 01 91 	brne	80009062 <_vfprintf_r+0x1efe>
80008d44:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d48:	ed b5 00 00 	bld	r5,0x0
80008d4c:	e0 81 01 20 	brne	80008f8c <_vfprintf_r+0x1e28>
80008d50:	40 c9       	lddsp	r9,sp[0x30]
80008d52:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d56:	2f f8       	sub	r8,-1
80008d58:	87 09       	st.w	r3[0x0],r9
80008d5a:	fb 48 06 90 	st.w	sp[1680],r8
80008d5e:	30 19       	mov	r9,1
80008d60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d64:	87 19       	st.w	r3[0x4],r9
80008d66:	2f f8       	sub	r8,-1
80008d68:	fb 48 06 8c 	st.w	sp[1676],r8
80008d6c:	c0 29       	rjmp	80008f70 <_vfprintf_r+0x1e0c>
80008d6e:	14 09       	add	r9,r10
80008d70:	2f f8       	sub	r8,-1
80008d72:	fb 49 06 90 	st.w	sp[1680],r9
80008d76:	87 06       	st.w	r3[0x0],r6
80008d78:	87 1a       	st.w	r3[0x4],r10
80008d7a:	fb 48 06 8c 	st.w	sp[1676],r8
80008d7e:	58 78       	cp.w	r8,7
80008d80:	e0 89 00 04 	brgt	80008d88 <_vfprintf_r+0x1c24>
80008d84:	2f 83       	sub	r3,-8
80008d86:	c0 b8       	rjmp	80008d9c <_vfprintf_r+0x1c38>
80008d88:	fa ca f9 78 	sub	r10,sp,-1672
80008d8c:	02 9b       	mov	r11,r1
80008d8e:	08 9c       	mov	r12,r4
80008d90:	fe b0 f1 dc 	rcall	80007148 <__sprint_r>
80008d94:	e0 81 01 67 	brne	80009062 <_vfprintf_r+0x1efe>
80008d98:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d9c:	40 c8       	lddsp	r8,sp[0x30]
80008d9e:	87 08       	st.w	r3[0x0],r8
80008da0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008da4:	2f f8       	sub	r8,-1
80008da6:	30 19       	mov	r9,1
80008da8:	fb 48 06 90 	st.w	sp[1680],r8
80008dac:	87 19       	st.w	r3[0x4],r9
80008dae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db2:	2f f8       	sub	r8,-1
80008db4:	fb 48 06 8c 	st.w	sp[1676],r8
80008db8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008dbc:	58 78       	cp.w	r8,7
80008dbe:	e0 89 00 04 	brgt	80008dc6 <_vfprintf_r+0x1c62>
80008dc2:	2f 83       	sub	r3,-8
80008dc4:	c0 b8       	rjmp	80008dda <_vfprintf_r+0x1c76>
80008dc6:	fa ca f9 78 	sub	r10,sp,-1672
80008dca:	02 9b       	mov	r11,r1
80008dcc:	08 9c       	mov	r12,r4
80008dce:	fe b0 f1 bd 	rcall	80007148 <__sprint_r>
80008dd2:	e0 81 01 48 	brne	80009062 <_vfprintf_r+0x1efe>
80008dd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dda:	04 06       	add	r6,r2
80008ddc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008de0:	87 06       	st.w	r3[0x0],r6
80008de2:	fa f9 06 90 	ld.w	r9,sp[1680]
80008de6:	40 66       	lddsp	r6,sp[0x18]
80008de8:	40 6e       	lddsp	lr,sp[0x18]
80008dea:	10 16       	sub	r6,r8
80008dec:	f2 08 01 08 	sub	r8,r9,r8
80008df0:	87 16       	st.w	r3[0x4],r6
80008df2:	1c 08       	add	r8,lr
80008df4:	fb 48 06 90 	st.w	sp[1680],r8
80008df8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dfc:	2f f8       	sub	r8,-1
80008dfe:	fb 48 06 8c 	st.w	sp[1676],r8
80008e02:	cb 78       	rjmp	80008f70 <_vfprintf_r+0x1e0c>
80008e04:	40 6c       	lddsp	r12,sp[0x18]
80008e06:	58 1c       	cp.w	r12,1
80008e08:	e0 89 00 06 	brgt	80008e14 <_vfprintf_r+0x1cb0>
80008e0c:	ed b5 00 00 	bld	r5,0x0
80008e10:	e0 81 00 85 	brne	80008f1a <_vfprintf_r+0x1db6>
80008e14:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e18:	2f f8       	sub	r8,-1
80008e1a:	30 19       	mov	r9,1
80008e1c:	fb 48 06 90 	st.w	sp[1680],r8
80008e20:	87 06       	st.w	r3[0x0],r6
80008e22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e26:	87 19       	st.w	r3[0x4],r9
80008e28:	2f f8       	sub	r8,-1
80008e2a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e2e:	58 78       	cp.w	r8,7
80008e30:	e0 89 00 04 	brgt	80008e38 <_vfprintf_r+0x1cd4>
80008e34:	2f 83       	sub	r3,-8
80008e36:	c0 b8       	rjmp	80008e4c <_vfprintf_r+0x1ce8>
80008e38:	fa ca f9 78 	sub	r10,sp,-1672
80008e3c:	02 9b       	mov	r11,r1
80008e3e:	08 9c       	mov	r12,r4
80008e40:	fe b0 f1 84 	rcall	80007148 <__sprint_r>
80008e44:	e0 81 01 0f 	brne	80009062 <_vfprintf_r+0x1efe>
80008e48:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e4c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e50:	2f f8       	sub	r8,-1
80008e52:	40 cb       	lddsp	r11,sp[0x30]
80008e54:	fb 48 06 90 	st.w	sp[1680],r8
80008e58:	30 19       	mov	r9,1
80008e5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e5e:	87 0b       	st.w	r3[0x0],r11
80008e60:	2f f8       	sub	r8,-1
80008e62:	87 19       	st.w	r3[0x4],r9
80008e64:	fb 48 06 8c 	st.w	sp[1676],r8
80008e68:	58 78       	cp.w	r8,7
80008e6a:	e0 89 00 05 	brgt	80008e74 <_vfprintf_r+0x1d10>
80008e6e:	2f 83       	sub	r3,-8
80008e70:	c0 c8       	rjmp	80008e88 <_vfprintf_r+0x1d24>
80008e72:	d7 03       	nop
80008e74:	fa ca f9 78 	sub	r10,sp,-1672
80008e78:	02 9b       	mov	r11,r1
80008e7a:	08 9c       	mov	r12,r4
80008e7c:	fe b0 f1 66 	rcall	80007148 <__sprint_r>
80008e80:	e0 81 00 f1 	brne	80009062 <_vfprintf_r+0x1efe>
80008e84:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e88:	30 08       	mov	r8,0
80008e8a:	30 09       	mov	r9,0
80008e8c:	40 5b       	lddsp	r11,sp[0x14]
80008e8e:	40 7a       	lddsp	r10,sp[0x1c]
80008e90:	e0 a0 13 25 	rcall	8000b4da <__avr32_f64_cmp_eq>
80008e94:	40 68       	lddsp	r8,sp[0x18]
80008e96:	20 18       	sub	r8,1
80008e98:	58 0c       	cp.w	r12,0
80008e9a:	c0 d1       	brne	80008eb4 <_vfprintf_r+0x1d50>
80008e9c:	2f f6       	sub	r6,-1
80008e9e:	87 18       	st.w	r3[0x4],r8
80008ea0:	87 06       	st.w	r3[0x0],r6
80008ea2:	fa f6 06 90 	ld.w	r6,sp[1680]
80008ea6:	10 06       	add	r6,r8
80008ea8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eac:	fb 46 06 90 	st.w	sp[1680],r6
80008eb0:	2f f8       	sub	r8,-1
80008eb2:	c3 18       	rjmp	80008f14 <_vfprintf_r+0x1db0>
80008eb4:	10 96       	mov	r6,r8
80008eb6:	58 08       	cp.w	r8,0
80008eb8:	e0 89 00 1c 	brgt	80008ef0 <_vfprintf_r+0x1d8c>
80008ebc:	c4 b8       	rjmp	80008f52 <_vfprintf_r+0x1dee>
80008ebe:	2f 09       	sub	r9,-16
80008ec0:	2f f8       	sub	r8,-1
80008ec2:	fb 49 06 90 	st.w	sp[1680],r9
80008ec6:	87 02       	st.w	r3[0x0],r2
80008ec8:	87 10       	st.w	r3[0x4],r0
80008eca:	fb 48 06 8c 	st.w	sp[1676],r8
80008ece:	58 78       	cp.w	r8,7
80008ed0:	e0 89 00 04 	brgt	80008ed8 <_vfprintf_r+0x1d74>
80008ed4:	2f 83       	sub	r3,-8
80008ed6:	c0 b8       	rjmp	80008eec <_vfprintf_r+0x1d88>
80008ed8:	fa ca f9 78 	sub	r10,sp,-1672
80008edc:	02 9b       	mov	r11,r1
80008ede:	08 9c       	mov	r12,r4
80008ee0:	fe b0 f1 34 	rcall	80007148 <__sprint_r>
80008ee4:	e0 81 00 bf 	brne	80009062 <_vfprintf_r+0x1efe>
80008ee8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eec:	21 06       	sub	r6,16
80008eee:	c0 48       	rjmp	80008ef6 <_vfprintf_r+0x1d92>
80008ef0:	fe c2 c0 a8 	sub	r2,pc,-16216
80008ef4:	31 00       	mov	r0,16
80008ef6:	fa f9 06 90 	ld.w	r9,sp[1680]
80008efa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008efe:	fe ca c0 b6 	sub	r10,pc,-16202
80008f02:	59 06       	cp.w	r6,16
80008f04:	fe 99 ff dd 	brgt	80008ebe <_vfprintf_r+0x1d5a>
80008f08:	0c 09       	add	r9,r6
80008f0a:	87 0a       	st.w	r3[0x0],r10
80008f0c:	fb 49 06 90 	st.w	sp[1680],r9
80008f10:	2f f8       	sub	r8,-1
80008f12:	87 16       	st.w	r3[0x4],r6
80008f14:	fb 48 06 8c 	st.w	sp[1676],r8
80008f18:	c0 e8       	rjmp	80008f34 <_vfprintf_r+0x1dd0>
80008f1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f1e:	2f f8       	sub	r8,-1
80008f20:	30 19       	mov	r9,1
80008f22:	fb 48 06 90 	st.w	sp[1680],r8
80008f26:	87 06       	st.w	r3[0x0],r6
80008f28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f2c:	87 19       	st.w	r3[0x4],r9
80008f2e:	2f f8       	sub	r8,-1
80008f30:	fb 48 06 8c 	st.w	sp[1676],r8
80008f34:	58 78       	cp.w	r8,7
80008f36:	e0 89 00 04 	brgt	80008f3e <_vfprintf_r+0x1dda>
80008f3a:	2f 83       	sub	r3,-8
80008f3c:	c0 b8       	rjmp	80008f52 <_vfprintf_r+0x1dee>
80008f3e:	fa ca f9 78 	sub	r10,sp,-1672
80008f42:	02 9b       	mov	r11,r1
80008f44:	08 9c       	mov	r12,r4
80008f46:	fe b0 f1 01 	rcall	80007148 <__sprint_r>
80008f4a:	e0 81 00 8c 	brne	80009062 <_vfprintf_r+0x1efe>
80008f4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f52:	40 ea       	lddsp	r10,sp[0x38]
80008f54:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f58:	14 08       	add	r8,r10
80008f5a:	fa c9 f9 64 	sub	r9,sp,-1692
80008f5e:	fb 48 06 90 	st.w	sp[1680],r8
80008f62:	87 1a       	st.w	r3[0x4],r10
80008f64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f68:	87 09       	st.w	r3[0x0],r9
80008f6a:	2f f8       	sub	r8,-1
80008f6c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f70:	58 78       	cp.w	r8,7
80008f72:	e0 89 00 04 	brgt	80008f7a <_vfprintf_r+0x1e16>
80008f76:	2f 83       	sub	r3,-8
80008f78:	c0 a8       	rjmp	80008f8c <_vfprintf_r+0x1e28>
80008f7a:	fa ca f9 78 	sub	r10,sp,-1672
80008f7e:	02 9b       	mov	r11,r1
80008f80:	08 9c       	mov	r12,r4
80008f82:	fe b0 f0 e3 	rcall	80007148 <__sprint_r>
80008f86:	c6 e1       	brne	80009062 <_vfprintf_r+0x1efe>
80008f88:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f8c:	e2 15 00 04 	andl	r5,0x4,COH
80008f90:	c3 f0       	breq	8000900e <_vfprintf_r+0x1eaa>
80008f92:	40 86       	lddsp	r6,sp[0x20]
80008f94:	40 39       	lddsp	r9,sp[0xc]
80008f96:	12 16       	sub	r6,r9
80008f98:	58 06       	cp.w	r6,0
80008f9a:	e0 89 00 1a 	brgt	80008fce <_vfprintf_r+0x1e6a>
80008f9e:	c3 88       	rjmp	8000900e <_vfprintf_r+0x1eaa>
80008fa0:	2f 09       	sub	r9,-16
80008fa2:	2f f8       	sub	r8,-1
80008fa4:	fb 49 06 90 	st.w	sp[1680],r9
80008fa8:	87 05       	st.w	r3[0x0],r5
80008faa:	87 12       	st.w	r3[0x4],r2
80008fac:	fb 48 06 8c 	st.w	sp[1676],r8
80008fb0:	58 78       	cp.w	r8,7
80008fb2:	e0 89 00 04 	brgt	80008fba <_vfprintf_r+0x1e56>
80008fb6:	2f 83       	sub	r3,-8
80008fb8:	c0 98       	rjmp	80008fca <_vfprintf_r+0x1e66>
80008fba:	00 9a       	mov	r10,r0
80008fbc:	02 9b       	mov	r11,r1
80008fbe:	08 9c       	mov	r12,r4
80008fc0:	fe b0 f0 c4 	rcall	80007148 <__sprint_r>
80008fc4:	c4 f1       	brne	80009062 <_vfprintf_r+0x1efe>
80008fc6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fca:	21 06       	sub	r6,16
80008fcc:	c0 68       	rjmp	80008fd8 <_vfprintf_r+0x1e74>
80008fce:	fe c5 c1 96 	sub	r5,pc,-15978
80008fd2:	31 02       	mov	r2,16
80008fd4:	fa c0 f9 78 	sub	r0,sp,-1672
80008fd8:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fdc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fe0:	fe ca c1 a8 	sub	r10,pc,-15960
80008fe4:	59 06       	cp.w	r6,16
80008fe6:	fe 99 ff dd 	brgt	80008fa0 <_vfprintf_r+0x1e3c>
80008fea:	0c 09       	add	r9,r6
80008fec:	2f f8       	sub	r8,-1
80008fee:	87 0a       	st.w	r3[0x0],r10
80008ff0:	87 16       	st.w	r3[0x4],r6
80008ff2:	fb 49 06 90 	st.w	sp[1680],r9
80008ff6:	fb 48 06 8c 	st.w	sp[1676],r8
80008ffa:	58 78       	cp.w	r8,7
80008ffc:	e0 8a 00 09 	brle	8000900e <_vfprintf_r+0x1eaa>
80009000:	fa ca f9 78 	sub	r10,sp,-1672
80009004:	02 9b       	mov	r11,r1
80009006:	08 9c       	mov	r12,r4
80009008:	fe b0 f0 a0 	rcall	80007148 <__sprint_r>
8000900c:	c2 b1       	brne	80009062 <_vfprintf_r+0x1efe>
8000900e:	40 bc       	lddsp	r12,sp[0x2c]
80009010:	40 36       	lddsp	r6,sp[0xc]
80009012:	40 8e       	lddsp	lr,sp[0x20]
80009014:	ec 0e 0c 48 	max	r8,r6,lr
80009018:	10 0c       	add	r12,r8
8000901a:	50 bc       	stdsp	sp[0x2c],r12
8000901c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009020:	58 08       	cp.w	r8,0
80009022:	c0 80       	breq	80009032 <_vfprintf_r+0x1ece>
80009024:	fa ca f9 78 	sub	r10,sp,-1672
80009028:	02 9b       	mov	r11,r1
8000902a:	08 9c       	mov	r12,r4
8000902c:	fe b0 f0 8e 	rcall	80007148 <__sprint_r>
80009030:	c1 91       	brne	80009062 <_vfprintf_r+0x1efe>
80009032:	30 0b       	mov	r11,0
80009034:	fa c3 f9 e0 	sub	r3,sp,-1568
80009038:	fb 4b 06 8c 	st.w	sp[1676],r11
8000903c:	fe 9f f1 22 	bral	80007280 <_vfprintf_r+0x11c>
80009040:	08 95       	mov	r5,r4
80009042:	fa f8 06 90 	ld.w	r8,sp[1680]
80009046:	58 08       	cp.w	r8,0
80009048:	c0 80       	breq	80009058 <_vfprintf_r+0x1ef4>
8000904a:	08 9c       	mov	r12,r4
8000904c:	fa ca f9 78 	sub	r10,sp,-1672
80009050:	02 9b       	mov	r11,r1
80009052:	fe b0 f0 7b 	rcall	80007148 <__sprint_r>
80009056:	c0 61       	brne	80009062 <_vfprintf_r+0x1efe>
80009058:	30 08       	mov	r8,0
8000905a:	fb 48 06 8c 	st.w	sp[1676],r8
8000905e:	c0 28       	rjmp	80009062 <_vfprintf_r+0x1efe>
80009060:	40 41       	lddsp	r1,sp[0x10]
80009062:	82 68       	ld.sh	r8,r1[0xc]
80009064:	ed b8 00 06 	bld	r8,0x6
80009068:	c0 31       	brne	8000906e <_vfprintf_r+0x1f0a>
8000906a:	3f fa       	mov	r10,-1
8000906c:	50 ba       	stdsp	sp[0x2c],r10
8000906e:	40 bc       	lddsp	r12,sp[0x2c]
80009070:	fe 3d f9 44 	sub	sp,-1724
80009074:	d8 32       	popm	r0-r7,pc
80009076:	d7 03       	nop

80009078 <__swsetup_r>:
80009078:	d4 21       	pushm	r4-r7,lr
8000907a:	e0 68 0a 2c 	mov	r8,2604
8000907e:	18 96       	mov	r6,r12
80009080:	16 97       	mov	r7,r11
80009082:	70 0c       	ld.w	r12,r8[0x0]
80009084:	58 0c       	cp.w	r12,0
80009086:	c0 60       	breq	80009092 <__swsetup_r+0x1a>
80009088:	78 68       	ld.w	r8,r12[0x18]
8000908a:	58 08       	cp.w	r8,0
8000908c:	c0 31       	brne	80009092 <__swsetup_r+0x1a>
8000908e:	e0 a0 07 bf 	rcall	8000a00c <__sinit>
80009092:	fe c8 c1 2a 	sub	r8,pc,-16086
80009096:	10 37       	cp.w	r7,r8
80009098:	c0 61       	brne	800090a4 <__swsetup_r+0x2c>
8000909a:	e0 68 0a 2c 	mov	r8,2604
8000909e:	70 08       	ld.w	r8,r8[0x0]
800090a0:	70 07       	ld.w	r7,r8[0x0]
800090a2:	c1 28       	rjmp	800090c6 <__swsetup_r+0x4e>
800090a4:	fe c8 c1 1c 	sub	r8,pc,-16100
800090a8:	10 37       	cp.w	r7,r8
800090aa:	c0 61       	brne	800090b6 <__swsetup_r+0x3e>
800090ac:	e0 68 0a 2c 	mov	r8,2604
800090b0:	70 08       	ld.w	r8,r8[0x0]
800090b2:	70 17       	ld.w	r7,r8[0x4]
800090b4:	c0 98       	rjmp	800090c6 <__swsetup_r+0x4e>
800090b6:	fe c8 c1 0e 	sub	r8,pc,-16114
800090ba:	10 37       	cp.w	r7,r8
800090bc:	c0 51       	brne	800090c6 <__swsetup_r+0x4e>
800090be:	e0 68 0a 2c 	mov	r8,2604
800090c2:	70 08       	ld.w	r8,r8[0x0]
800090c4:	70 27       	ld.w	r7,r8[0x8]
800090c6:	8e 68       	ld.sh	r8,r7[0xc]
800090c8:	ed b8 00 03 	bld	r8,0x3
800090cc:	c1 e0       	breq	80009108 <__swsetup_r+0x90>
800090ce:	ed b8 00 04 	bld	r8,0x4
800090d2:	c3 e1       	brne	8000914e <__swsetup_r+0xd6>
800090d4:	ed b8 00 02 	bld	r8,0x2
800090d8:	c1 51       	brne	80009102 <__swsetup_r+0x8a>
800090da:	6e db       	ld.w	r11,r7[0x34]
800090dc:	58 0b       	cp.w	r11,0
800090de:	c0 a0       	breq	800090f2 <__swsetup_r+0x7a>
800090e0:	ee c8 ff bc 	sub	r8,r7,-68
800090e4:	10 3b       	cp.w	r11,r8
800090e6:	c0 40       	breq	800090ee <__swsetup_r+0x76>
800090e8:	0c 9c       	mov	r12,r6
800090ea:	e0 a0 08 2b 	rcall	8000a140 <_free_r>
800090ee:	30 08       	mov	r8,0
800090f0:	8f d8       	st.w	r7[0x34],r8
800090f2:	8e 68       	ld.sh	r8,r7[0xc]
800090f4:	e0 18 ff db 	andl	r8,0xffdb
800090f8:	ae 68       	st.h	r7[0xc],r8
800090fa:	30 08       	mov	r8,0
800090fc:	8f 18       	st.w	r7[0x4],r8
800090fe:	6e 48       	ld.w	r8,r7[0x10]
80009100:	8f 08       	st.w	r7[0x0],r8
80009102:	8e 68       	ld.sh	r8,r7[0xc]
80009104:	a3 b8       	sbr	r8,0x3
80009106:	ae 68       	st.h	r7[0xc],r8
80009108:	6e 48       	ld.w	r8,r7[0x10]
8000910a:	58 08       	cp.w	r8,0
8000910c:	c0 b1       	brne	80009122 <__swsetup_r+0xaa>
8000910e:	8e 68       	ld.sh	r8,r7[0xc]
80009110:	e2 18 02 80 	andl	r8,0x280,COH
80009114:	e0 48 02 00 	cp.w	r8,512
80009118:	c0 50       	breq	80009122 <__swsetup_r+0xaa>
8000911a:	0c 9c       	mov	r12,r6
8000911c:	0e 9b       	mov	r11,r7
8000911e:	e0 a0 0a 4b 	rcall	8000a5b4 <__smakebuf_r>
80009122:	8e 69       	ld.sh	r9,r7[0xc]
80009124:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009128:	c0 70       	breq	80009136 <__swsetup_r+0xbe>
8000912a:	30 08       	mov	r8,0
8000912c:	8f 28       	st.w	r7[0x8],r8
8000912e:	6e 58       	ld.w	r8,r7[0x14]
80009130:	5c 38       	neg	r8
80009132:	8f 68       	st.w	r7[0x18],r8
80009134:	c0 68       	rjmp	80009140 <__swsetup_r+0xc8>
80009136:	ed b9 00 01 	bld	r9,0x1
8000913a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000913e:	8f 28       	st.w	r7[0x8],r8
80009140:	6e 48       	ld.w	r8,r7[0x10]
80009142:	58 08       	cp.w	r8,0
80009144:	c0 61       	brne	80009150 <__swsetup_r+0xd8>
80009146:	8e 68       	ld.sh	r8,r7[0xc]
80009148:	ed b8 00 07 	bld	r8,0x7
8000914c:	c0 21       	brne	80009150 <__swsetup_r+0xd8>
8000914e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009150:	d8 2a       	popm	r4-r7,pc,r12=0
80009152:	d7 03       	nop

80009154 <quorem>:
80009154:	d4 31       	pushm	r0-r7,lr
80009156:	20 2d       	sub	sp,8
80009158:	18 97       	mov	r7,r12
8000915a:	78 48       	ld.w	r8,r12[0x10]
8000915c:	76 46       	ld.w	r6,r11[0x10]
8000915e:	0c 38       	cp.w	r8,r6
80009160:	c0 34       	brge	80009166 <quorem+0x12>
80009162:	30 0c       	mov	r12,0
80009164:	c8 58       	rjmp	8000926e <quorem+0x11a>
80009166:	ec c2 ff fc 	sub	r2,r6,-4
8000916a:	f6 c3 ff ec 	sub	r3,r11,-20
8000916e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009172:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009176:	2f f9       	sub	r9,-1
80009178:	20 16       	sub	r6,1
8000917a:	f8 09 0d 08 	divu	r8,r12,r9
8000917e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009182:	ee c4 ff ec 	sub	r4,r7,-20
80009186:	10 95       	mov	r5,r8
80009188:	58 08       	cp.w	r8,0
8000918a:	c4 10       	breq	8000920c <quorem+0xb8>
8000918c:	30 09       	mov	r9,0
8000918e:	06 9a       	mov	r10,r3
80009190:	08 98       	mov	r8,r4
80009192:	12 91       	mov	r1,r9
80009194:	50 0b       	stdsp	sp[0x0],r11
80009196:	70 0e       	ld.w	lr,r8[0x0]
80009198:	b1 8e       	lsr	lr,0x10
8000919a:	50 1e       	stdsp	sp[0x4],lr
8000919c:	15 0e       	ld.w	lr,r10++
8000919e:	fc 00 16 10 	lsr	r0,lr,0x10
800091a2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800091a6:	ea 0e 03 41 	mac	r1,r5,lr
800091aa:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800091ae:	b1 81       	lsr	r1,0x10
800091b0:	40 1b       	lddsp	r11,sp[0x4]
800091b2:	ea 00 02 40 	mul	r0,r5,r0
800091b6:	e2 00 00 00 	add	r0,r1,r0
800091ba:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800091be:	02 1b       	sub	r11,r1
800091c0:	50 1b       	stdsp	sp[0x4],r11
800091c2:	70 0b       	ld.w	r11,r8[0x0]
800091c4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800091c8:	02 09       	add	r9,r1
800091ca:	f2 0e 01 0e 	sub	lr,r9,lr
800091ce:	b0 1e       	st.h	r8[0x2],lr
800091d0:	fc 09 14 10 	asr	r9,lr,0x10
800091d4:	40 1e       	lddsp	lr,sp[0x4]
800091d6:	fc 09 00 09 	add	r9,lr,r9
800091da:	b0 09       	st.h	r8[0x0],r9
800091dc:	e0 01 16 10 	lsr	r1,r0,0x10
800091e0:	2f c8       	sub	r8,-4
800091e2:	b1 49       	asr	r9,0x10
800091e4:	04 3a       	cp.w	r10,r2
800091e6:	fe 98 ff d8 	brls	80009196 <quorem+0x42>
800091ea:	40 0b       	lddsp	r11,sp[0x0]
800091ec:	58 0c       	cp.w	r12,0
800091ee:	c0 f1       	brne	8000920c <quorem+0xb8>
800091f0:	ec c8 ff fb 	sub	r8,r6,-5
800091f4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800091f8:	c0 28       	rjmp	800091fc <quorem+0xa8>
800091fa:	20 16       	sub	r6,1
800091fc:	20 48       	sub	r8,4
800091fe:	08 38       	cp.w	r8,r4
80009200:	e0 88 00 05 	brls	8000920a <quorem+0xb6>
80009204:	70 09       	ld.w	r9,r8[0x0]
80009206:	58 09       	cp.w	r9,0
80009208:	cf 90       	breq	800091fa <quorem+0xa6>
8000920a:	8f 46       	st.w	r7[0x10],r6
8000920c:	0e 9c       	mov	r12,r7
8000920e:	e0 a0 0a d2 	rcall	8000a7b2 <__mcmp>
80009212:	c2 d5       	brlt	8000926c <quorem+0x118>
80009214:	2f f5       	sub	r5,-1
80009216:	08 98       	mov	r8,r4
80009218:	30 09       	mov	r9,0
8000921a:	07 0b       	ld.w	r11,r3++
8000921c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009220:	70 0c       	ld.w	r12,r8[0x0]
80009222:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009226:	f8 0e 16 10 	lsr	lr,r12,0x10
8000922a:	14 1e       	sub	lr,r10
8000922c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009230:	16 1a       	sub	r10,r11
80009232:	12 0a       	add	r10,r9
80009234:	b0 1a       	st.h	r8[0x2],r10
80009236:	b1 4a       	asr	r10,0x10
80009238:	fc 0a 00 09 	add	r9,lr,r10
8000923c:	b0 09       	st.h	r8[0x0],r9
8000923e:	2f c8       	sub	r8,-4
80009240:	b1 49       	asr	r9,0x10
80009242:	04 33       	cp.w	r3,r2
80009244:	fe 98 ff eb 	brls	8000921a <quorem+0xc6>
80009248:	ec c8 ff fb 	sub	r8,r6,-5
8000924c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009250:	58 09       	cp.w	r9,0
80009252:	c0 d1       	brne	8000926c <quorem+0x118>
80009254:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009258:	c0 28       	rjmp	8000925c <quorem+0x108>
8000925a:	20 16       	sub	r6,1
8000925c:	20 48       	sub	r8,4
8000925e:	08 38       	cp.w	r8,r4
80009260:	e0 88 00 05 	brls	8000926a <quorem+0x116>
80009264:	70 09       	ld.w	r9,r8[0x0]
80009266:	58 09       	cp.w	r9,0
80009268:	cf 90       	breq	8000925a <quorem+0x106>
8000926a:	8f 46       	st.w	r7[0x10],r6
8000926c:	0a 9c       	mov	r12,r5
8000926e:	2f ed       	sub	sp,-8
80009270:	d8 32       	popm	r0-r7,pc
80009272:	d7 03       	nop

80009274 <_dtoa_r>:
80009274:	d4 31       	pushm	r0-r7,lr
80009276:	21 ad       	sub	sp,104
80009278:	fa c4 ff 74 	sub	r4,sp,-140
8000927c:	18 97       	mov	r7,r12
8000927e:	16 95       	mov	r5,r11
80009280:	68 2c       	ld.w	r12,r4[0x8]
80009282:	50 c9       	stdsp	sp[0x30],r9
80009284:	68 16       	ld.w	r6,r4[0x4]
80009286:	68 09       	ld.w	r9,r4[0x0]
80009288:	50 e8       	stdsp	sp[0x38],r8
8000928a:	14 94       	mov	r4,r10
8000928c:	51 2c       	stdsp	sp[0x48],r12
8000928e:	fa e5 00 08 	st.d	sp[8],r4
80009292:	51 59       	stdsp	sp[0x54],r9
80009294:	6e 95       	ld.w	r5,r7[0x24]
80009296:	58 05       	cp.w	r5,0
80009298:	c0 91       	brne	800092aa <_dtoa_r+0x36>
8000929a:	31 0c       	mov	r12,16
8000929c:	fe b0 e8 f4 	rcall	80006484 <malloc>
800092a0:	99 35       	st.w	r12[0xc],r5
800092a2:	8f 9c       	st.w	r7[0x24],r12
800092a4:	99 15       	st.w	r12[0x4],r5
800092a6:	99 25       	st.w	r12[0x8],r5
800092a8:	99 05       	st.w	r12[0x0],r5
800092aa:	6e 99       	ld.w	r9,r7[0x24]
800092ac:	72 08       	ld.w	r8,r9[0x0]
800092ae:	58 08       	cp.w	r8,0
800092b0:	c0 f0       	breq	800092ce <_dtoa_r+0x5a>
800092b2:	72 1a       	ld.w	r10,r9[0x4]
800092b4:	91 1a       	st.w	r8[0x4],r10
800092b6:	30 1a       	mov	r10,1
800092b8:	72 19       	ld.w	r9,r9[0x4]
800092ba:	f4 09 09 49 	lsl	r9,r10,r9
800092be:	10 9b       	mov	r11,r8
800092c0:	91 29       	st.w	r8[0x8],r9
800092c2:	0e 9c       	mov	r12,r7
800092c4:	e0 a0 0a 90 	rcall	8000a7e4 <_Bfree>
800092c8:	6e 98       	ld.w	r8,r7[0x24]
800092ca:	30 09       	mov	r9,0
800092cc:	91 09       	st.w	r8[0x0],r9
800092ce:	40 28       	lddsp	r8,sp[0x8]
800092d0:	10 94       	mov	r4,r8
800092d2:	58 08       	cp.w	r8,0
800092d4:	c0 64       	brge	800092e0 <_dtoa_r+0x6c>
800092d6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800092da:	50 28       	stdsp	sp[0x8],r8
800092dc:	30 18       	mov	r8,1
800092de:	c0 28       	rjmp	800092e2 <_dtoa_r+0x6e>
800092e0:	30 08       	mov	r8,0
800092e2:	8d 08       	st.w	r6[0x0],r8
800092e4:	fc 1c 7f f0 	movh	r12,0x7ff0
800092e8:	40 26       	lddsp	r6,sp[0x8]
800092ea:	0c 98       	mov	r8,r6
800092ec:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800092f0:	18 38       	cp.w	r8,r12
800092f2:	c2 01       	brne	80009332 <_dtoa_r+0xbe>
800092f4:	e0 68 27 0f 	mov	r8,9999
800092f8:	41 5b       	lddsp	r11,sp[0x54]
800092fa:	97 08       	st.w	r11[0x0],r8
800092fc:	40 3a       	lddsp	r10,sp[0xc]
800092fe:	58 0a       	cp.w	r10,0
80009300:	c0 71       	brne	8000930e <_dtoa_r+0x9a>
80009302:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009306:	c0 41       	brne	8000930e <_dtoa_r+0x9a>
80009308:	fe cc c3 b0 	sub	r12,pc,-15440
8000930c:	c0 38       	rjmp	80009312 <_dtoa_r+0x9e>
8000930e:	fe cc c3 aa 	sub	r12,pc,-15446
80009312:	41 29       	lddsp	r9,sp[0x48]
80009314:	58 09       	cp.w	r9,0
80009316:	e0 80 05 9a 	breq	80009e4a <_dtoa_r+0xbd6>
8000931a:	f8 c8 ff fd 	sub	r8,r12,-3
8000931e:	f8 c9 ff f8 	sub	r9,r12,-8
80009322:	11 8b       	ld.ub	r11,r8[0x0]
80009324:	30 0a       	mov	r10,0
80009326:	41 25       	lddsp	r5,sp[0x48]
80009328:	f4 0b 18 00 	cp.b	r11,r10
8000932c:	f2 08 17 10 	movne	r8,r9
80009330:	c1 68       	rjmp	8000935c <_dtoa_r+0xe8>
80009332:	fa ea 00 08 	ld.d	r10,sp[8]
80009336:	30 08       	mov	r8,0
80009338:	fa eb 00 3c 	st.d	sp[60],r10
8000933c:	30 09       	mov	r9,0
8000933e:	e0 a0 10 ce 	rcall	8000b4da <__avr32_f64_cmp_eq>
80009342:	c1 00       	breq	80009362 <_dtoa_r+0xee>
80009344:	30 18       	mov	r8,1
80009346:	41 5a       	lddsp	r10,sp[0x54]
80009348:	95 08       	st.w	r10[0x0],r8
8000934a:	fe cc c5 16 	sub	r12,pc,-15082
8000934e:	41 29       	lddsp	r9,sp[0x48]
80009350:	f8 08 00 08 	add	r8,r12,r8
80009354:	58 09       	cp.w	r9,0
80009356:	e0 80 05 7a 	breq	80009e4a <_dtoa_r+0xbd6>
8000935a:	12 95       	mov	r5,r9
8000935c:	8b 08       	st.w	r5[0x0],r8
8000935e:	e0 8f 05 76 	bral	80009e4a <_dtoa_r+0xbd6>
80009362:	fa c8 ff 9c 	sub	r8,sp,-100
80009366:	fa c9 ff a0 	sub	r9,sp,-96
8000936a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000936e:	0e 9c       	mov	r12,r7
80009370:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009374:	e0 a0 0a 8a 	rcall	8000a888 <__d2b>
80009378:	18 93       	mov	r3,r12
8000937a:	58 05       	cp.w	r5,0
8000937c:	c0 d0       	breq	80009396 <_dtoa_r+0x122>
8000937e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009382:	30 04       	mov	r4,0
80009384:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009388:	ea c5 03 ff 	sub	r5,r5,1023
8000938c:	10 9b       	mov	r11,r8
8000938e:	51 74       	stdsp	sp[0x5c],r4
80009390:	ea 1b 3f f0 	orh	r11,0x3ff0
80009394:	c2 58       	rjmp	800093de <_dtoa_r+0x16a>
80009396:	41 88       	lddsp	r8,sp[0x60]
80009398:	41 9c       	lddsp	r12,sp[0x64]
8000939a:	10 0c       	add	r12,r8
8000939c:	f8 c5 fb ce 	sub	r5,r12,-1074
800093a0:	e0 45 00 20 	cp.w	r5,32
800093a4:	e0 8a 00 0e 	brle	800093c0 <_dtoa_r+0x14c>
800093a8:	f8 cc fb ee 	sub	r12,r12,-1042
800093ac:	40 3b       	lddsp	r11,sp[0xc]
800093ae:	ea 08 11 40 	rsub	r8,r5,64
800093b2:	f6 0c 0a 4c 	lsr	r12,r11,r12
800093b6:	ec 08 09 46 	lsl	r6,r6,r8
800093ba:	0c 4c       	or	r12,r6
800093bc:	c0 78       	rjmp	800093ca <_dtoa_r+0x156>
800093be:	d7 03       	nop
800093c0:	ea 0c 11 20 	rsub	r12,r5,32
800093c4:	40 3a       	lddsp	r10,sp[0xc]
800093c6:	f4 0c 09 4c 	lsl	r12,r10,r12
800093ca:	e0 a0 10 14 	rcall	8000b3f2 <__avr32_u32_to_f64>
800093ce:	fc 18 fe 10 	movh	r8,0xfe10
800093d2:	30 19       	mov	r9,1
800093d4:	ea c5 04 33 	sub	r5,r5,1075
800093d8:	f0 0b 00 0b 	add	r11,r8,r11
800093dc:	51 79       	stdsp	sp[0x5c],r9
800093de:	30 08       	mov	r8,0
800093e0:	fc 19 3f f8 	movh	r9,0x3ff8
800093e4:	e0 a0 0e 9c 	rcall	8000b11c <__avr32_f64_sub>
800093e8:	e0 68 43 61 	mov	r8,17249
800093ec:	ea 18 63 6f 	orh	r8,0x636f
800093f0:	e0 69 87 a7 	mov	r9,34727
800093f4:	ea 19 3f d2 	orh	r9,0x3fd2
800093f8:	e0 a0 0d a6 	rcall	8000af44 <__avr32_f64_mul>
800093fc:	e0 68 c8 b3 	mov	r8,51379
80009400:	ea 18 8b 60 	orh	r8,0x8b60
80009404:	e0 69 8a 28 	mov	r9,35368
80009408:	ea 19 3f c6 	orh	r9,0x3fc6
8000940c:	e0 a0 0f 56 	rcall	8000b2b8 <__avr32_f64_add>
80009410:	0a 9c       	mov	r12,r5
80009412:	14 90       	mov	r0,r10
80009414:	16 91       	mov	r1,r11
80009416:	e0 a0 0f f2 	rcall	8000b3fa <__avr32_s32_to_f64>
8000941a:	e0 68 79 fb 	mov	r8,31227
8000941e:	ea 18 50 9f 	orh	r8,0x509f
80009422:	e0 69 44 13 	mov	r9,17427
80009426:	ea 19 3f d3 	orh	r9,0x3fd3
8000942a:	e0 a0 0d 8d 	rcall	8000af44 <__avr32_f64_mul>
8000942e:	14 98       	mov	r8,r10
80009430:	16 99       	mov	r9,r11
80009432:	00 9a       	mov	r10,r0
80009434:	02 9b       	mov	r11,r1
80009436:	e0 a0 0f 41 	rcall	8000b2b8 <__avr32_f64_add>
8000943a:	14 90       	mov	r0,r10
8000943c:	16 91       	mov	r1,r11
8000943e:	e0 a0 0f c7 	rcall	8000b3cc <__avr32_f64_to_s32>
80009442:	30 08       	mov	r8,0
80009444:	18 96       	mov	r6,r12
80009446:	30 09       	mov	r9,0
80009448:	00 9a       	mov	r10,r0
8000944a:	02 9b       	mov	r11,r1
8000944c:	e0 a0 10 8e 	rcall	8000b568 <__avr32_f64_cmp_lt>
80009450:	c0 c0       	breq	80009468 <_dtoa_r+0x1f4>
80009452:	0c 9c       	mov	r12,r6
80009454:	e0 a0 0f d3 	rcall	8000b3fa <__avr32_s32_to_f64>
80009458:	14 98       	mov	r8,r10
8000945a:	16 99       	mov	r9,r11
8000945c:	00 9a       	mov	r10,r0
8000945e:	02 9b       	mov	r11,r1
80009460:	e0 a0 10 3d 	rcall	8000b4da <__avr32_f64_cmp_eq>
80009464:	f7 b6 00 01 	subeq	r6,1
80009468:	59 66       	cp.w	r6,22
8000946a:	e0 88 00 05 	brls	80009474 <_dtoa_r+0x200>
8000946e:	30 18       	mov	r8,1
80009470:	51 48       	stdsp	sp[0x50],r8
80009472:	c1 38       	rjmp	80009498 <_dtoa_r+0x224>
80009474:	fe c8 c4 5c 	sub	r8,pc,-15268
80009478:	fa ea 00 3c 	ld.d	r10,sp[60]
8000947c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009480:	e0 a0 10 74 	rcall	8000b568 <__avr32_f64_cmp_lt>
80009484:	f9 b4 00 00 	moveq	r4,0
80009488:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000948c:	f7 b6 01 01 	subne	r6,1
80009490:	f9 bc 01 00 	movne	r12,0
80009494:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009498:	41 90       	lddsp	r0,sp[0x64]
8000949a:	20 10       	sub	r0,1
8000949c:	0a 10       	sub	r0,r5
8000949e:	c0 46       	brmi	800094a6 <_dtoa_r+0x232>
800094a0:	50 40       	stdsp	sp[0x10],r0
800094a2:	30 00       	mov	r0,0
800094a4:	c0 48       	rjmp	800094ac <_dtoa_r+0x238>
800094a6:	30 0b       	mov	r11,0
800094a8:	5c 30       	neg	r0
800094aa:	50 4b       	stdsp	sp[0x10],r11
800094ac:	ec 02 11 00 	rsub	r2,r6,0
800094b0:	58 06       	cp.w	r6,0
800094b2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800094b6:	f5 d6 e4 0a 	addge	r10,r10,r6
800094ba:	fb fa 4a 04 	st.wge	sp[0x10],r10
800094be:	fb f6 4a 11 	st.wge	sp[0x44],r6
800094c2:	f9 b2 04 00 	movge	r2,0
800094c6:	e1 d6 e5 10 	sublt	r0,r0,r6
800094ca:	f9 b9 05 00 	movlt	r9,0
800094ce:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800094d2:	40 c8       	lddsp	r8,sp[0x30]
800094d4:	58 98       	cp.w	r8,9
800094d6:	e0 8b 00 20 	brhi	80009516 <_dtoa_r+0x2a2>
800094da:	58 58       	cp.w	r8,5
800094dc:	f9 b4 0a 01 	movle	r4,1
800094e0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800094e4:	f7 b5 09 04 	subgt	r5,4
800094e8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800094ec:	f9 b4 09 00 	movgt	r4,0
800094f0:	40 cc       	lddsp	r12,sp[0x30]
800094f2:	58 3c       	cp.w	r12,3
800094f4:	c2 d0       	breq	8000954e <_dtoa_r+0x2da>
800094f6:	e0 89 00 05 	brgt	80009500 <_dtoa_r+0x28c>
800094fa:	58 2c       	cp.w	r12,2
800094fc:	c1 01       	brne	8000951c <_dtoa_r+0x2a8>
800094fe:	c1 88       	rjmp	8000952e <_dtoa_r+0x2ba>
80009500:	40 cb       	lddsp	r11,sp[0x30]
80009502:	58 4b       	cp.w	r11,4
80009504:	c0 60       	breq	80009510 <_dtoa_r+0x29c>
80009506:	58 5b       	cp.w	r11,5
80009508:	c0 a1       	brne	8000951c <_dtoa_r+0x2a8>
8000950a:	30 1a       	mov	r10,1
8000950c:	50 da       	stdsp	sp[0x34],r10
8000950e:	c2 28       	rjmp	80009552 <_dtoa_r+0x2de>
80009510:	30 19       	mov	r9,1
80009512:	50 d9       	stdsp	sp[0x34],r9
80009514:	c0 f8       	rjmp	80009532 <_dtoa_r+0x2be>
80009516:	30 08       	mov	r8,0
80009518:	30 14       	mov	r4,1
8000951a:	50 c8       	stdsp	sp[0x30],r8
8000951c:	3f f5       	mov	r5,-1
8000951e:	30 1c       	mov	r12,1
80009520:	30 0b       	mov	r11,0
80009522:	50 95       	stdsp	sp[0x24],r5
80009524:	50 dc       	stdsp	sp[0x34],r12
80009526:	0a 91       	mov	r1,r5
80009528:	31 28       	mov	r8,18
8000952a:	50 eb       	stdsp	sp[0x38],r11
8000952c:	c2 08       	rjmp	8000956c <_dtoa_r+0x2f8>
8000952e:	30 0a       	mov	r10,0
80009530:	50 da       	stdsp	sp[0x34],r10
80009532:	40 e9       	lddsp	r9,sp[0x38]
80009534:	58 09       	cp.w	r9,0
80009536:	e0 89 00 07 	brgt	80009544 <_dtoa_r+0x2d0>
8000953a:	30 18       	mov	r8,1
8000953c:	50 98       	stdsp	sp[0x24],r8
8000953e:	10 91       	mov	r1,r8
80009540:	50 e8       	stdsp	sp[0x38],r8
80009542:	c1 58       	rjmp	8000956c <_dtoa_r+0x2f8>
80009544:	40 e5       	lddsp	r5,sp[0x38]
80009546:	50 95       	stdsp	sp[0x24],r5
80009548:	0a 91       	mov	r1,r5
8000954a:	0a 98       	mov	r8,r5
8000954c:	c1 08       	rjmp	8000956c <_dtoa_r+0x2f8>
8000954e:	30 0c       	mov	r12,0
80009550:	50 dc       	stdsp	sp[0x34],r12
80009552:	40 eb       	lddsp	r11,sp[0x38]
80009554:	ec 0b 00 0b 	add	r11,r6,r11
80009558:	50 9b       	stdsp	sp[0x24],r11
8000955a:	16 98       	mov	r8,r11
8000955c:	2f f8       	sub	r8,-1
8000955e:	58 08       	cp.w	r8,0
80009560:	e0 89 00 05 	brgt	8000956a <_dtoa_r+0x2f6>
80009564:	10 91       	mov	r1,r8
80009566:	30 18       	mov	r8,1
80009568:	c0 28       	rjmp	8000956c <_dtoa_r+0x2f8>
8000956a:	10 91       	mov	r1,r8
8000956c:	30 09       	mov	r9,0
8000956e:	6e 9a       	ld.w	r10,r7[0x24]
80009570:	95 19       	st.w	r10[0x4],r9
80009572:	30 49       	mov	r9,4
80009574:	c0 68       	rjmp	80009580 <_dtoa_r+0x30c>
80009576:	d7 03       	nop
80009578:	6a 1a       	ld.w	r10,r5[0x4]
8000957a:	a1 79       	lsl	r9,0x1
8000957c:	2f fa       	sub	r10,-1
8000957e:	8b 1a       	st.w	r5[0x4],r10
80009580:	6e 95       	ld.w	r5,r7[0x24]
80009582:	f2 ca ff ec 	sub	r10,r9,-20
80009586:	10 3a       	cp.w	r10,r8
80009588:	fe 98 ff f8 	brls	80009578 <_dtoa_r+0x304>
8000958c:	6a 1b       	ld.w	r11,r5[0x4]
8000958e:	0e 9c       	mov	r12,r7
80009590:	e0 a0 09 44 	rcall	8000a818 <_Balloc>
80009594:	58 e1       	cp.w	r1,14
80009596:	5f 88       	srls	r8
80009598:	8b 0c       	st.w	r5[0x0],r12
8000959a:	f1 e4 00 04 	and	r4,r8,r4
8000959e:	6e 98       	ld.w	r8,r7[0x24]
800095a0:	70 08       	ld.w	r8,r8[0x0]
800095a2:	50 88       	stdsp	sp[0x20],r8
800095a4:	e0 80 01 82 	breq	800098a8 <_dtoa_r+0x634>
800095a8:	58 06       	cp.w	r6,0
800095aa:	e0 8a 00 43 	brle	80009630 <_dtoa_r+0x3bc>
800095ae:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800095b2:	fe c8 c5 9a 	sub	r8,pc,-14950
800095b6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800095ba:	fa e5 00 18 	st.d	sp[24],r4
800095be:	ec 04 14 04 	asr	r4,r6,0x4
800095c2:	ed b4 00 04 	bld	r4,0x4
800095c6:	c0 30       	breq	800095cc <_dtoa_r+0x358>
800095c8:	30 25       	mov	r5,2
800095ca:	c1 08       	rjmp	800095ea <_dtoa_r+0x376>
800095cc:	fe c8 c4 ec 	sub	r8,pc,-15124
800095d0:	f0 e8 00 20 	ld.d	r8,r8[32]
800095d4:	fa ea 00 3c 	ld.d	r10,sp[60]
800095d8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800095dc:	e0 a0 0f fa 	rcall	8000b5d0 <__avr32_f64_div>
800095e0:	30 35       	mov	r5,3
800095e2:	14 98       	mov	r8,r10
800095e4:	16 99       	mov	r9,r11
800095e6:	fa e9 00 08 	st.d	sp[8],r8
800095ea:	fe cc c5 0a 	sub	r12,pc,-15094
800095ee:	50 a3       	stdsp	sp[0x28],r3
800095f0:	0c 93       	mov	r3,r6
800095f2:	18 96       	mov	r6,r12
800095f4:	c0 f8       	rjmp	80009612 <_dtoa_r+0x39e>
800095f6:	fa ea 00 18 	ld.d	r10,sp[24]
800095fa:	ed b4 00 00 	bld	r4,0x0
800095fe:	c0 81       	brne	8000960e <_dtoa_r+0x39a>
80009600:	ec e8 00 00 	ld.d	r8,r6[0]
80009604:	2f f5       	sub	r5,-1
80009606:	e0 a0 0c 9f 	rcall	8000af44 <__avr32_f64_mul>
8000960a:	fa eb 00 18 	st.d	sp[24],r10
8000960e:	a1 54       	asr	r4,0x1
80009610:	2f 86       	sub	r6,-8
80009612:	58 04       	cp.w	r4,0
80009614:	cf 11       	brne	800095f6 <_dtoa_r+0x382>
80009616:	fa e8 00 18 	ld.d	r8,sp[24]
8000961a:	fa ea 00 08 	ld.d	r10,sp[8]
8000961e:	06 96       	mov	r6,r3
80009620:	e0 a0 0f d8 	rcall	8000b5d0 <__avr32_f64_div>
80009624:	40 a3       	lddsp	r3,sp[0x28]
80009626:	14 98       	mov	r8,r10
80009628:	16 99       	mov	r9,r11
8000962a:	fa e9 00 08 	st.d	sp[8],r8
8000962e:	c2 f8       	rjmp	8000968c <_dtoa_r+0x418>
80009630:	ec 08 11 00 	rsub	r8,r6,0
80009634:	c0 31       	brne	8000963a <_dtoa_r+0x3c6>
80009636:	30 25       	mov	r5,2
80009638:	c2 a8       	rjmp	8000968c <_dtoa_r+0x418>
8000963a:	fe cc c5 5a 	sub	r12,pc,-15014
8000963e:	f0 04 14 04 	asr	r4,r8,0x4
80009642:	50 1c       	stdsp	sp[0x4],r12
80009644:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009648:	fe c9 c6 30 	sub	r9,pc,-14800
8000964c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009650:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009654:	e0 a0 0c 78 	rcall	8000af44 <__avr32_f64_mul>
80009658:	40 1c       	lddsp	r12,sp[0x4]
8000965a:	50 63       	stdsp	sp[0x18],r3
8000965c:	30 25       	mov	r5,2
8000965e:	0c 93       	mov	r3,r6
80009660:	fa eb 00 08 	st.d	sp[8],r10
80009664:	18 96       	mov	r6,r12
80009666:	c0 f8       	rjmp	80009684 <_dtoa_r+0x410>
80009668:	fa ea 00 08 	ld.d	r10,sp[8]
8000966c:	ed b4 00 00 	bld	r4,0x0
80009670:	c0 81       	brne	80009680 <_dtoa_r+0x40c>
80009672:	ec e8 00 00 	ld.d	r8,r6[0]
80009676:	2f f5       	sub	r5,-1
80009678:	e0 a0 0c 66 	rcall	8000af44 <__avr32_f64_mul>
8000967c:	fa eb 00 08 	st.d	sp[8],r10
80009680:	a1 54       	asr	r4,0x1
80009682:	2f 86       	sub	r6,-8
80009684:	58 04       	cp.w	r4,0
80009686:	cf 11       	brne	80009668 <_dtoa_r+0x3f4>
80009688:	06 96       	mov	r6,r3
8000968a:	40 63       	lddsp	r3,sp[0x18]
8000968c:	41 4a       	lddsp	r10,sp[0x50]
8000968e:	58 0a       	cp.w	r10,0
80009690:	c2 a0       	breq	800096e4 <_dtoa_r+0x470>
80009692:	fa e8 00 08 	ld.d	r8,sp[8]
80009696:	58 01       	cp.w	r1,0
80009698:	5f 94       	srgt	r4
8000969a:	fa e9 00 18 	st.d	sp[24],r8
8000969e:	30 08       	mov	r8,0
800096a0:	fc 19 3f f0 	movh	r9,0x3ff0
800096a4:	fa ea 00 18 	ld.d	r10,sp[24]
800096a8:	e0 a0 0f 60 	rcall	8000b568 <__avr32_f64_cmp_lt>
800096ac:	f9 bc 00 00 	moveq	r12,0
800096b0:	f9 bc 01 01 	movne	r12,1
800096b4:	e9 ec 00 0c 	and	r12,r4,r12
800096b8:	c1 60       	breq	800096e4 <_dtoa_r+0x470>
800096ba:	40 98       	lddsp	r8,sp[0x24]
800096bc:	58 08       	cp.w	r8,0
800096be:	e0 8a 00 f1 	brle	800098a0 <_dtoa_r+0x62c>
800096c2:	30 08       	mov	r8,0
800096c4:	fc 19 40 24 	movh	r9,0x4024
800096c8:	ec c4 00 01 	sub	r4,r6,1
800096cc:	fa ea 00 18 	ld.d	r10,sp[24]
800096d0:	2f f5       	sub	r5,-1
800096d2:	50 64       	stdsp	sp[0x18],r4
800096d4:	e0 a0 0c 38 	rcall	8000af44 <__avr32_f64_mul>
800096d8:	40 94       	lddsp	r4,sp[0x24]
800096da:	14 98       	mov	r8,r10
800096dc:	16 99       	mov	r9,r11
800096de:	fa e9 00 08 	st.d	sp[8],r8
800096e2:	c0 38       	rjmp	800096e8 <_dtoa_r+0x474>
800096e4:	50 66       	stdsp	sp[0x18],r6
800096e6:	02 94       	mov	r4,r1
800096e8:	0a 9c       	mov	r12,r5
800096ea:	e0 a0 0e 88 	rcall	8000b3fa <__avr32_s32_to_f64>
800096ee:	fa e8 00 08 	ld.d	r8,sp[8]
800096f2:	e0 a0 0c 29 	rcall	8000af44 <__avr32_f64_mul>
800096f6:	30 08       	mov	r8,0
800096f8:	fc 19 40 1c 	movh	r9,0x401c
800096fc:	e0 a0 0d de 	rcall	8000b2b8 <__avr32_f64_add>
80009700:	14 98       	mov	r8,r10
80009702:	16 99       	mov	r9,r11
80009704:	fa e9 00 28 	st.d	sp[40],r8
80009708:	fc 18 fc c0 	movh	r8,0xfcc0
8000970c:	40 a5       	lddsp	r5,sp[0x28]
8000970e:	10 05       	add	r5,r8
80009710:	50 a5       	stdsp	sp[0x28],r5
80009712:	58 04       	cp.w	r4,0
80009714:	c2 11       	brne	80009756 <_dtoa_r+0x4e2>
80009716:	fa ea 00 08 	ld.d	r10,sp[8]
8000971a:	30 08       	mov	r8,0
8000971c:	fc 19 40 14 	movh	r9,0x4014
80009720:	e0 a0 0c fe 	rcall	8000b11c <__avr32_f64_sub>
80009724:	40 bc       	lddsp	r12,sp[0x2c]
80009726:	fa eb 00 08 	st.d	sp[8],r10
8000972a:	14 98       	mov	r8,r10
8000972c:	16 99       	mov	r9,r11
8000972e:	18 9a       	mov	r10,r12
80009730:	0a 9b       	mov	r11,r5
80009732:	e0 a0 0f 1b 	rcall	8000b568 <__avr32_f64_cmp_lt>
80009736:	e0 81 02 54 	brne	80009bde <_dtoa_r+0x96a>
8000973a:	0a 98       	mov	r8,r5
8000973c:	40 b9       	lddsp	r9,sp[0x2c]
8000973e:	ee 18 80 00 	eorh	r8,0x8000
80009742:	fa ea 00 08 	ld.d	r10,sp[8]
80009746:	10 95       	mov	r5,r8
80009748:	12 98       	mov	r8,r9
8000974a:	0a 99       	mov	r9,r5
8000974c:	e0 a0 0f 0e 	rcall	8000b568 <__avr32_f64_cmp_lt>
80009750:	e0 81 02 3e 	brne	80009bcc <_dtoa_r+0x958>
80009754:	ca 68       	rjmp	800098a0 <_dtoa_r+0x62c>
80009756:	fe c9 c7 3e 	sub	r9,pc,-14530
8000975a:	e8 c8 00 01 	sub	r8,r4,1
8000975e:	40 d5       	lddsp	r5,sp[0x34]
80009760:	58 05       	cp.w	r5,0
80009762:	c4 f0       	breq	80009800 <_dtoa_r+0x58c>
80009764:	30 0c       	mov	r12,0
80009766:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000976a:	51 3c       	stdsp	sp[0x4c],r12
8000976c:	30 0a       	mov	r10,0
8000976e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009772:	e0 a0 0f 2f 	rcall	8000b5d0 <__avr32_f64_div>
80009776:	fa e8 00 28 	ld.d	r8,sp[40]
8000977a:	40 85       	lddsp	r5,sp[0x20]
8000977c:	e0 a0 0c d0 	rcall	8000b11c <__avr32_f64_sub>
80009780:	fa eb 00 28 	st.d	sp[40],r10
80009784:	fa ea 00 08 	ld.d	r10,sp[8]
80009788:	e0 a0 0e 22 	rcall	8000b3cc <__avr32_f64_to_s32>
8000978c:	51 6c       	stdsp	sp[0x58],r12
8000978e:	e0 a0 0e 36 	rcall	8000b3fa <__avr32_s32_to_f64>
80009792:	14 98       	mov	r8,r10
80009794:	16 99       	mov	r9,r11
80009796:	fa ea 00 08 	ld.d	r10,sp[8]
8000979a:	e0 a0 0c c1 	rcall	8000b11c <__avr32_f64_sub>
8000979e:	fa eb 00 08 	st.d	sp[8],r10
800097a2:	41 68       	lddsp	r8,sp[0x58]
800097a4:	2d 08       	sub	r8,-48
800097a6:	0a c8       	st.b	r5++,r8
800097a8:	41 39       	lddsp	r9,sp[0x4c]
800097aa:	2f f9       	sub	r9,-1
800097ac:	51 39       	stdsp	sp[0x4c],r9
800097ae:	fa e8 00 28 	ld.d	r8,sp[40]
800097b2:	e0 a0 0e db 	rcall	8000b568 <__avr32_f64_cmp_lt>
800097b6:	e0 81 03 39 	brne	80009e28 <_dtoa_r+0xbb4>
800097ba:	fa e8 00 08 	ld.d	r8,sp[8]
800097be:	30 0a       	mov	r10,0
800097c0:	fc 1b 3f f0 	movh	r11,0x3ff0
800097c4:	e0 a0 0c ac 	rcall	8000b11c <__avr32_f64_sub>
800097c8:	fa e8 00 28 	ld.d	r8,sp[40]
800097cc:	e0 a0 0e ce 	rcall	8000b568 <__avr32_f64_cmp_lt>
800097d0:	fa ea 00 28 	ld.d	r10,sp[40]
800097d4:	30 08       	mov	r8,0
800097d6:	fc 19 40 24 	movh	r9,0x4024
800097da:	e0 81 00 da 	brne	8000998e <_dtoa_r+0x71a>
800097de:	41 3c       	lddsp	r12,sp[0x4c]
800097e0:	08 3c       	cp.w	r12,r4
800097e2:	c5 f4       	brge	800098a0 <_dtoa_r+0x62c>
800097e4:	e0 a0 0b b0 	rcall	8000af44 <__avr32_f64_mul>
800097e8:	30 08       	mov	r8,0
800097ea:	fa eb 00 28 	st.d	sp[40],r10
800097ee:	fc 19 40 24 	movh	r9,0x4024
800097f2:	fa ea 00 08 	ld.d	r10,sp[8]
800097f6:	e0 a0 0b a7 	rcall	8000af44 <__avr32_f64_mul>
800097fa:	fa eb 00 08 	st.d	sp[8],r10
800097fe:	cc 3b       	rjmp	80009784 <_dtoa_r+0x510>
80009800:	40 85       	lddsp	r5,sp[0x20]
80009802:	08 05       	add	r5,r4
80009804:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009808:	51 35       	stdsp	sp[0x4c],r5
8000980a:	fa e8 00 28 	ld.d	r8,sp[40]
8000980e:	40 85       	lddsp	r5,sp[0x20]
80009810:	e0 a0 0b 9a 	rcall	8000af44 <__avr32_f64_mul>
80009814:	fa eb 00 28 	st.d	sp[40],r10
80009818:	fa ea 00 08 	ld.d	r10,sp[8]
8000981c:	e0 a0 0d d8 	rcall	8000b3cc <__avr32_f64_to_s32>
80009820:	51 6c       	stdsp	sp[0x58],r12
80009822:	e0 a0 0d ec 	rcall	8000b3fa <__avr32_s32_to_f64>
80009826:	14 98       	mov	r8,r10
80009828:	16 99       	mov	r9,r11
8000982a:	fa ea 00 08 	ld.d	r10,sp[8]
8000982e:	e0 a0 0c 77 	rcall	8000b11c <__avr32_f64_sub>
80009832:	fa eb 00 08 	st.d	sp[8],r10
80009836:	41 68       	lddsp	r8,sp[0x58]
80009838:	2d 08       	sub	r8,-48
8000983a:	0a c8       	st.b	r5++,r8
8000983c:	41 3c       	lddsp	r12,sp[0x4c]
8000983e:	18 35       	cp.w	r5,r12
80009840:	c2 81       	brne	80009890 <_dtoa_r+0x61c>
80009842:	30 08       	mov	r8,0
80009844:	fc 19 3f e0 	movh	r9,0x3fe0
80009848:	fa ea 00 28 	ld.d	r10,sp[40]
8000984c:	e0 a0 0d 36 	rcall	8000b2b8 <__avr32_f64_add>
80009850:	40 85       	lddsp	r5,sp[0x20]
80009852:	fa e8 00 08 	ld.d	r8,sp[8]
80009856:	08 05       	add	r5,r4
80009858:	e0 a0 0e 88 	rcall	8000b568 <__avr32_f64_cmp_lt>
8000985c:	e0 81 00 99 	brne	8000998e <_dtoa_r+0x71a>
80009860:	fa e8 00 28 	ld.d	r8,sp[40]
80009864:	30 0a       	mov	r10,0
80009866:	fc 1b 3f e0 	movh	r11,0x3fe0
8000986a:	e0 a0 0c 59 	rcall	8000b11c <__avr32_f64_sub>
8000986e:	14 98       	mov	r8,r10
80009870:	16 99       	mov	r9,r11
80009872:	fa ea 00 08 	ld.d	r10,sp[8]
80009876:	e0 a0 0e 79 	rcall	8000b568 <__avr32_f64_cmp_lt>
8000987a:	c1 30       	breq	800098a0 <_dtoa_r+0x62c>
8000987c:	33 09       	mov	r9,48
8000987e:	0a 98       	mov	r8,r5
80009880:	11 7a       	ld.ub	r10,--r8
80009882:	f2 0a 18 00 	cp.b	r10,r9
80009886:	e0 81 02 d1 	brne	80009e28 <_dtoa_r+0xbb4>
8000988a:	10 95       	mov	r5,r8
8000988c:	cf 9b       	rjmp	8000987e <_dtoa_r+0x60a>
8000988e:	d7 03       	nop
80009890:	30 08       	mov	r8,0
80009892:	fc 19 40 24 	movh	r9,0x4024
80009896:	e0 a0 0b 57 	rcall	8000af44 <__avr32_f64_mul>
8000989a:	fa eb 00 08 	st.d	sp[8],r10
8000989e:	cb db       	rjmp	80009818 <_dtoa_r+0x5a4>
800098a0:	fa ea 00 3c 	ld.d	r10,sp[60]
800098a4:	fa eb 00 08 	st.d	sp[8],r10
800098a8:	58 e6       	cp.w	r6,14
800098aa:	5f ab       	srle	r11
800098ac:	41 8a       	lddsp	r10,sp[0x60]
800098ae:	30 08       	mov	r8,0
800098b0:	f4 09 11 ff 	rsub	r9,r10,-1
800098b4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800098b8:	f0 09 18 00 	cp.b	r9,r8
800098bc:	e0 80 00 82 	breq	800099c0 <_dtoa_r+0x74c>
800098c0:	40 ea       	lddsp	r10,sp[0x38]
800098c2:	58 01       	cp.w	r1,0
800098c4:	5f a9       	srle	r9
800098c6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800098ca:	fe ca c8 b2 	sub	r10,pc,-14158
800098ce:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800098d2:	fa e5 00 10 	st.d	sp[16],r4
800098d6:	f0 09 18 00 	cp.b	r9,r8
800098da:	c1 40       	breq	80009902 <_dtoa_r+0x68e>
800098dc:	58 01       	cp.w	r1,0
800098de:	e0 81 01 77 	brne	80009bcc <_dtoa_r+0x958>
800098e2:	30 08       	mov	r8,0
800098e4:	fc 19 40 14 	movh	r9,0x4014
800098e8:	08 9a       	mov	r10,r4
800098ea:	0a 9b       	mov	r11,r5
800098ec:	e0 a0 0b 2c 	rcall	8000af44 <__avr32_f64_mul>
800098f0:	fa e8 00 08 	ld.d	r8,sp[8]
800098f4:	e0 a0 0e 06 	rcall	8000b500 <__avr32_f64_cmp_ge>
800098f8:	e0 81 01 6a 	brne	80009bcc <_dtoa_r+0x958>
800098fc:	02 92       	mov	r2,r1
800098fe:	e0 8f 01 72 	bral	80009be2 <_dtoa_r+0x96e>
80009902:	40 85       	lddsp	r5,sp[0x20]
80009904:	30 14       	mov	r4,1
80009906:	fa e8 00 10 	ld.d	r8,sp[16]
8000990a:	fa ea 00 08 	ld.d	r10,sp[8]
8000990e:	e0 a0 0e 61 	rcall	8000b5d0 <__avr32_f64_div>
80009912:	e0 a0 0d 5d 	rcall	8000b3cc <__avr32_f64_to_s32>
80009916:	18 92       	mov	r2,r12
80009918:	e0 a0 0d 71 	rcall	8000b3fa <__avr32_s32_to_f64>
8000991c:	fa e8 00 10 	ld.d	r8,sp[16]
80009920:	e0 a0 0b 12 	rcall	8000af44 <__avr32_f64_mul>
80009924:	14 98       	mov	r8,r10
80009926:	16 99       	mov	r9,r11
80009928:	fa ea 00 08 	ld.d	r10,sp[8]
8000992c:	e0 a0 0b f8 	rcall	8000b11c <__avr32_f64_sub>
80009930:	fa eb 00 08 	st.d	sp[8],r10
80009934:	e4 c8 ff d0 	sub	r8,r2,-48
80009938:	0a c8       	st.b	r5++,r8
8000993a:	fc 19 40 24 	movh	r9,0x4024
8000993e:	30 08       	mov	r8,0
80009940:	02 34       	cp.w	r4,r1
80009942:	c3 31       	brne	800099a8 <_dtoa_r+0x734>
80009944:	fa e8 00 08 	ld.d	r8,sp[8]
80009948:	e0 a0 0c b8 	rcall	8000b2b8 <__avr32_f64_add>
8000994c:	16 91       	mov	r1,r11
8000994e:	14 90       	mov	r0,r10
80009950:	14 98       	mov	r8,r10
80009952:	02 99       	mov	r9,r1
80009954:	fa ea 00 10 	ld.d	r10,sp[16]
80009958:	e0 a0 0e 08 	rcall	8000b568 <__avr32_f64_cmp_lt>
8000995c:	c1 a1       	brne	80009990 <_dtoa_r+0x71c>
8000995e:	fa e8 00 10 	ld.d	r8,sp[16]
80009962:	00 9a       	mov	r10,r0
80009964:	02 9b       	mov	r11,r1
80009966:	e0 a0 0d ba 	rcall	8000b4da <__avr32_f64_cmp_eq>
8000996a:	e0 80 02 5e 	breq	80009e26 <_dtoa_r+0xbb2>
8000996e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009972:	c0 f1       	brne	80009990 <_dtoa_r+0x71c>
80009974:	e0 8f 02 59 	bral	80009e26 <_dtoa_r+0xbb2>
80009978:	40 8a       	lddsp	r10,sp[0x20]
8000997a:	14 38       	cp.w	r8,r10
8000997c:	c0 30       	breq	80009982 <_dtoa_r+0x70e>
8000997e:	10 95       	mov	r5,r8
80009980:	c0 98       	rjmp	80009992 <_dtoa_r+0x71e>
80009982:	33 08       	mov	r8,48
80009984:	40 89       	lddsp	r9,sp[0x20]
80009986:	2f f6       	sub	r6,-1
80009988:	b2 88       	st.b	r9[0x0],r8
8000998a:	40 88       	lddsp	r8,sp[0x20]
8000998c:	c0 88       	rjmp	8000999c <_dtoa_r+0x728>
8000998e:	40 66       	lddsp	r6,sp[0x18]
80009990:	33 99       	mov	r9,57
80009992:	0a 98       	mov	r8,r5
80009994:	11 7a       	ld.ub	r10,--r8
80009996:	f2 0a 18 00 	cp.b	r10,r9
8000999a:	ce f0       	breq	80009978 <_dtoa_r+0x704>
8000999c:	50 66       	stdsp	sp[0x18],r6
8000999e:	11 89       	ld.ub	r9,r8[0x0]
800099a0:	2f f9       	sub	r9,-1
800099a2:	b0 89       	st.b	r8[0x0],r9
800099a4:	e0 8f 02 42 	bral	80009e28 <_dtoa_r+0xbb4>
800099a8:	e0 a0 0a ce 	rcall	8000af44 <__avr32_f64_mul>
800099ac:	2f f4       	sub	r4,-1
800099ae:	fa eb 00 08 	st.d	sp[8],r10
800099b2:	30 08       	mov	r8,0
800099b4:	30 09       	mov	r9,0
800099b6:	e0 a0 0d 92 	rcall	8000b4da <__avr32_f64_cmp_eq>
800099ba:	ca 60       	breq	80009906 <_dtoa_r+0x692>
800099bc:	e0 8f 02 35 	bral	80009e26 <_dtoa_r+0xbb2>
800099c0:	40 d8       	lddsp	r8,sp[0x34]
800099c2:	58 08       	cp.w	r8,0
800099c4:	c0 51       	brne	800099ce <_dtoa_r+0x75a>
800099c6:	04 98       	mov	r8,r2
800099c8:	00 95       	mov	r5,r0
800099ca:	40 d4       	lddsp	r4,sp[0x34]
800099cc:	c3 78       	rjmp	80009a3a <_dtoa_r+0x7c6>
800099ce:	40 c5       	lddsp	r5,sp[0x30]
800099d0:	58 15       	cp.w	r5,1
800099d2:	e0 89 00 0f 	brgt	800099f0 <_dtoa_r+0x77c>
800099d6:	41 74       	lddsp	r4,sp[0x5c]
800099d8:	58 04       	cp.w	r4,0
800099da:	c0 40       	breq	800099e2 <_dtoa_r+0x76e>
800099dc:	f4 c9 fb cd 	sub	r9,r10,-1075
800099e0:	c0 48       	rjmp	800099e8 <_dtoa_r+0x774>
800099e2:	41 99       	lddsp	r9,sp[0x64]
800099e4:	f2 09 11 36 	rsub	r9,r9,54
800099e8:	04 98       	mov	r8,r2
800099ea:	00 95       	mov	r5,r0
800099ec:	c1 c8       	rjmp	80009a24 <_dtoa_r+0x7b0>
800099ee:	d7 03       	nop
800099f0:	e2 c8 00 01 	sub	r8,r1,1
800099f4:	58 01       	cp.w	r1,0
800099f6:	e0 05 17 40 	movge	r5,r0
800099fa:	e2 09 17 40 	movge	r9,r1
800099fe:	e1 d1 e5 15 	sublt	r5,r0,r1
80009a02:	f9 b9 05 00 	movlt	r9,0
80009a06:	10 32       	cp.w	r2,r8
80009a08:	e5 d8 e4 18 	subge	r8,r2,r8
80009a0c:	f1 d2 e5 18 	sublt	r8,r8,r2
80009a10:	e5 d8 e5 02 	addlt	r2,r2,r8
80009a14:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009a18:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009a1c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009a20:	f9 b8 05 00 	movlt	r8,0
80009a24:	40 4b       	lddsp	r11,sp[0x10]
80009a26:	12 0b       	add	r11,r9
80009a28:	50 08       	stdsp	sp[0x0],r8
80009a2a:	50 4b       	stdsp	sp[0x10],r11
80009a2c:	12 00       	add	r0,r9
80009a2e:	30 1b       	mov	r11,1
80009a30:	0e 9c       	mov	r12,r7
80009a32:	e0 a0 08 a7 	rcall	8000ab80 <__i2b>
80009a36:	40 08       	lddsp	r8,sp[0x0]
80009a38:	18 94       	mov	r4,r12
80009a3a:	40 4a       	lddsp	r10,sp[0x10]
80009a3c:	58 05       	cp.w	r5,0
80009a3e:	5f 99       	srgt	r9
80009a40:	58 0a       	cp.w	r10,0
80009a42:	5f 9a       	srgt	r10
80009a44:	f5 e9 00 09 	and	r9,r10,r9
80009a48:	c0 80       	breq	80009a58 <_dtoa_r+0x7e4>
80009a4a:	40 4c       	lddsp	r12,sp[0x10]
80009a4c:	f8 05 0d 49 	min	r9,r12,r5
80009a50:	12 1c       	sub	r12,r9
80009a52:	12 10       	sub	r0,r9
80009a54:	50 4c       	stdsp	sp[0x10],r12
80009a56:	12 15       	sub	r5,r9
80009a58:	58 02       	cp.w	r2,0
80009a5a:	e0 8a 00 27 	brle	80009aa8 <_dtoa_r+0x834>
80009a5e:	40 db       	lddsp	r11,sp[0x34]
80009a60:	58 0b       	cp.w	r11,0
80009a62:	c1 d0       	breq	80009a9c <_dtoa_r+0x828>
80009a64:	58 08       	cp.w	r8,0
80009a66:	e0 8a 00 17 	brle	80009a94 <_dtoa_r+0x820>
80009a6a:	10 9a       	mov	r10,r8
80009a6c:	50 08       	stdsp	sp[0x0],r8
80009a6e:	08 9b       	mov	r11,r4
80009a70:	0e 9c       	mov	r12,r7
80009a72:	e0 a0 08 cd 	rcall	8000ac0c <__pow5mult>
80009a76:	06 9a       	mov	r10,r3
80009a78:	18 9b       	mov	r11,r12
80009a7a:	18 94       	mov	r4,r12
80009a7c:	0e 9c       	mov	r12,r7
80009a7e:	e0 a0 08 01 	rcall	8000aa80 <__multiply>
80009a82:	18 99       	mov	r9,r12
80009a84:	06 9b       	mov	r11,r3
80009a86:	50 19       	stdsp	sp[0x4],r9
80009a88:	0e 9c       	mov	r12,r7
80009a8a:	e0 a0 06 ad 	rcall	8000a7e4 <_Bfree>
80009a8e:	40 19       	lddsp	r9,sp[0x4]
80009a90:	40 08       	lddsp	r8,sp[0x0]
80009a92:	12 93       	mov	r3,r9
80009a94:	e4 08 01 0a 	sub	r10,r2,r8
80009a98:	c0 80       	breq	80009aa8 <_dtoa_r+0x834>
80009a9a:	c0 28       	rjmp	80009a9e <_dtoa_r+0x82a>
80009a9c:	04 9a       	mov	r10,r2
80009a9e:	06 9b       	mov	r11,r3
80009aa0:	0e 9c       	mov	r12,r7
80009aa2:	e0 a0 08 b5 	rcall	8000ac0c <__pow5mult>
80009aa6:	18 93       	mov	r3,r12
80009aa8:	30 1b       	mov	r11,1
80009aaa:	0e 9c       	mov	r12,r7
80009aac:	e0 a0 08 6a 	rcall	8000ab80 <__i2b>
80009ab0:	41 1a       	lddsp	r10,sp[0x44]
80009ab2:	18 92       	mov	r2,r12
80009ab4:	58 0a       	cp.w	r10,0
80009ab6:	e0 8a 00 07 	brle	80009ac4 <_dtoa_r+0x850>
80009aba:	18 9b       	mov	r11,r12
80009abc:	0e 9c       	mov	r12,r7
80009abe:	e0 a0 08 a7 	rcall	8000ac0c <__pow5mult>
80009ac2:	18 92       	mov	r2,r12
80009ac4:	40 c9       	lddsp	r9,sp[0x30]
80009ac6:	58 19       	cp.w	r9,1
80009ac8:	e0 89 00 14 	brgt	80009af0 <_dtoa_r+0x87c>
80009acc:	40 38       	lddsp	r8,sp[0xc]
80009ace:	58 08       	cp.w	r8,0
80009ad0:	c1 01       	brne	80009af0 <_dtoa_r+0x87c>
80009ad2:	40 29       	lddsp	r9,sp[0x8]
80009ad4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009ad8:	c0 c1       	brne	80009af0 <_dtoa_r+0x87c>
80009ada:	12 98       	mov	r8,r9
80009adc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009ae0:	c0 80       	breq	80009af0 <_dtoa_r+0x87c>
80009ae2:	40 4c       	lddsp	r12,sp[0x10]
80009ae4:	30 1b       	mov	r11,1
80009ae6:	2f fc       	sub	r12,-1
80009ae8:	2f f0       	sub	r0,-1
80009aea:	50 4c       	stdsp	sp[0x10],r12
80009aec:	50 6b       	stdsp	sp[0x18],r11
80009aee:	c0 38       	rjmp	80009af4 <_dtoa_r+0x880>
80009af0:	30 0a       	mov	r10,0
80009af2:	50 6a       	stdsp	sp[0x18],r10
80009af4:	41 19       	lddsp	r9,sp[0x44]
80009af6:	58 09       	cp.w	r9,0
80009af8:	c0 31       	brne	80009afe <_dtoa_r+0x88a>
80009afa:	30 1c       	mov	r12,1
80009afc:	c0 98       	rjmp	80009b0e <_dtoa_r+0x89a>
80009afe:	64 48       	ld.w	r8,r2[0x10]
80009b00:	2f c8       	sub	r8,-4
80009b02:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009b06:	e0 a0 05 df 	rcall	8000a6c4 <__hi0bits>
80009b0a:	f8 0c 11 20 	rsub	r12,r12,32
80009b0e:	40 4b       	lddsp	r11,sp[0x10]
80009b10:	f8 0b 00 08 	add	r8,r12,r11
80009b14:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009b18:	c0 c0       	breq	80009b30 <_dtoa_r+0x8bc>
80009b1a:	f0 08 11 20 	rsub	r8,r8,32
80009b1e:	58 48       	cp.w	r8,4
80009b20:	e0 8a 00 06 	brle	80009b2c <_dtoa_r+0x8b8>
80009b24:	20 48       	sub	r8,4
80009b26:	10 0b       	add	r11,r8
80009b28:	50 4b       	stdsp	sp[0x10],r11
80009b2a:	c0 78       	rjmp	80009b38 <_dtoa_r+0x8c4>
80009b2c:	58 48       	cp.w	r8,4
80009b2e:	c0 70       	breq	80009b3c <_dtoa_r+0x8c8>
80009b30:	40 4a       	lddsp	r10,sp[0x10]
80009b32:	2e 48       	sub	r8,-28
80009b34:	10 0a       	add	r10,r8
80009b36:	50 4a       	stdsp	sp[0x10],r10
80009b38:	10 00       	add	r0,r8
80009b3a:	10 05       	add	r5,r8
80009b3c:	58 00       	cp.w	r0,0
80009b3e:	e0 8a 00 08 	brle	80009b4e <_dtoa_r+0x8da>
80009b42:	06 9b       	mov	r11,r3
80009b44:	00 9a       	mov	r10,r0
80009b46:	0e 9c       	mov	r12,r7
80009b48:	e0 a0 07 58 	rcall	8000a9f8 <__lshift>
80009b4c:	18 93       	mov	r3,r12
80009b4e:	40 49       	lddsp	r9,sp[0x10]
80009b50:	58 09       	cp.w	r9,0
80009b52:	e0 8a 00 08 	brle	80009b62 <_dtoa_r+0x8ee>
80009b56:	04 9b       	mov	r11,r2
80009b58:	12 9a       	mov	r10,r9
80009b5a:	0e 9c       	mov	r12,r7
80009b5c:	e0 a0 07 4e 	rcall	8000a9f8 <__lshift>
80009b60:	18 92       	mov	r2,r12
80009b62:	41 48       	lddsp	r8,sp[0x50]
80009b64:	58 08       	cp.w	r8,0
80009b66:	c1 b0       	breq	80009b9c <_dtoa_r+0x928>
80009b68:	04 9b       	mov	r11,r2
80009b6a:	06 9c       	mov	r12,r3
80009b6c:	e0 a0 06 23 	rcall	8000a7b2 <__mcmp>
80009b70:	c1 64       	brge	80009b9c <_dtoa_r+0x928>
80009b72:	06 9b       	mov	r11,r3
80009b74:	30 09       	mov	r9,0
80009b76:	30 aa       	mov	r10,10
80009b78:	0e 9c       	mov	r12,r7
80009b7a:	e0 a0 08 0b 	rcall	8000ab90 <__multadd>
80009b7e:	20 16       	sub	r6,1
80009b80:	18 93       	mov	r3,r12
80009b82:	40 dc       	lddsp	r12,sp[0x34]
80009b84:	58 0c       	cp.w	r12,0
80009b86:	c0 31       	brne	80009b8c <_dtoa_r+0x918>
80009b88:	40 91       	lddsp	r1,sp[0x24]
80009b8a:	c0 98       	rjmp	80009b9c <_dtoa_r+0x928>
80009b8c:	08 9b       	mov	r11,r4
80009b8e:	40 91       	lddsp	r1,sp[0x24]
80009b90:	30 09       	mov	r9,0
80009b92:	30 aa       	mov	r10,10
80009b94:	0e 9c       	mov	r12,r7
80009b96:	e0 a0 07 fd 	rcall	8000ab90 <__multadd>
80009b9a:	18 94       	mov	r4,r12
80009b9c:	58 01       	cp.w	r1,0
80009b9e:	5f a9       	srle	r9
80009ba0:	40 cb       	lddsp	r11,sp[0x30]
80009ba2:	58 2b       	cp.w	r11,2
80009ba4:	5f 98       	srgt	r8
80009ba6:	f3 e8 00 08 	and	r8,r9,r8
80009baa:	c2 50       	breq	80009bf4 <_dtoa_r+0x980>
80009bac:	58 01       	cp.w	r1,0
80009bae:	c1 11       	brne	80009bd0 <_dtoa_r+0x95c>
80009bb0:	04 9b       	mov	r11,r2
80009bb2:	02 99       	mov	r9,r1
80009bb4:	30 5a       	mov	r10,5
80009bb6:	0e 9c       	mov	r12,r7
80009bb8:	e0 a0 07 ec 	rcall	8000ab90 <__multadd>
80009bbc:	18 92       	mov	r2,r12
80009bbe:	18 9b       	mov	r11,r12
80009bc0:	06 9c       	mov	r12,r3
80009bc2:	e0 a0 05 f8 	rcall	8000a7b2 <__mcmp>
80009bc6:	e0 89 00 0f 	brgt	80009be4 <_dtoa_r+0x970>
80009bca:	c0 38       	rjmp	80009bd0 <_dtoa_r+0x95c>
80009bcc:	30 02       	mov	r2,0
80009bce:	04 94       	mov	r4,r2
80009bd0:	40 ea       	lddsp	r10,sp[0x38]
80009bd2:	30 09       	mov	r9,0
80009bd4:	5c da       	com	r10
80009bd6:	40 85       	lddsp	r5,sp[0x20]
80009bd8:	50 6a       	stdsp	sp[0x18],r10
80009bda:	50 49       	stdsp	sp[0x10],r9
80009bdc:	c0 f9       	rjmp	80009dfa <_dtoa_r+0xb86>
80009bde:	08 92       	mov	r2,r4
80009be0:	40 66       	lddsp	r6,sp[0x18]
80009be2:	04 94       	mov	r4,r2
80009be4:	2f f6       	sub	r6,-1
80009be6:	50 66       	stdsp	sp[0x18],r6
80009be8:	33 18       	mov	r8,49
80009bea:	40 85       	lddsp	r5,sp[0x20]
80009bec:	0a c8       	st.b	r5++,r8
80009bee:	30 08       	mov	r8,0
80009bf0:	50 48       	stdsp	sp[0x10],r8
80009bf2:	c0 49       	rjmp	80009dfa <_dtoa_r+0xb86>
80009bf4:	40 dc       	lddsp	r12,sp[0x34]
80009bf6:	58 0c       	cp.w	r12,0
80009bf8:	e0 80 00 b5 	breq	80009d62 <_dtoa_r+0xaee>
80009bfc:	58 05       	cp.w	r5,0
80009bfe:	e0 8a 00 08 	brle	80009c0e <_dtoa_r+0x99a>
80009c02:	08 9b       	mov	r11,r4
80009c04:	0a 9a       	mov	r10,r5
80009c06:	0e 9c       	mov	r12,r7
80009c08:	e0 a0 06 f8 	rcall	8000a9f8 <__lshift>
80009c0c:	18 94       	mov	r4,r12
80009c0e:	40 6b       	lddsp	r11,sp[0x18]
80009c10:	58 0b       	cp.w	r11,0
80009c12:	c0 31       	brne	80009c18 <_dtoa_r+0x9a4>
80009c14:	08 9c       	mov	r12,r4
80009c16:	c1 38       	rjmp	80009c3c <_dtoa_r+0x9c8>
80009c18:	68 1b       	ld.w	r11,r4[0x4]
80009c1a:	0e 9c       	mov	r12,r7
80009c1c:	e0 a0 05 fe 	rcall	8000a818 <_Balloc>
80009c20:	68 4a       	ld.w	r10,r4[0x10]
80009c22:	18 95       	mov	r5,r12
80009c24:	e8 cb ff f4 	sub	r11,r4,-12
80009c28:	2f ea       	sub	r10,-2
80009c2a:	2f 4c       	sub	r12,-12
80009c2c:	a3 6a       	lsl	r10,0x2
80009c2e:	fe b0 e6 4f 	rcall	800068cc <memcpy>
80009c32:	0a 9b       	mov	r11,r5
80009c34:	30 1a       	mov	r10,1
80009c36:	0e 9c       	mov	r12,r7
80009c38:	e0 a0 06 e0 	rcall	8000a9f8 <__lshift>
80009c3c:	50 44       	stdsp	sp[0x10],r4
80009c3e:	40 3a       	lddsp	r10,sp[0xc]
80009c40:	30 19       	mov	r9,1
80009c42:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009c46:	18 94       	mov	r4,r12
80009c48:	50 da       	stdsp	sp[0x34],r10
80009c4a:	40 85       	lddsp	r5,sp[0x20]
80009c4c:	50 99       	stdsp	sp[0x24],r9
80009c4e:	50 26       	stdsp	sp[0x8],r6
80009c50:	50 e1       	stdsp	sp[0x38],r1
80009c52:	04 9b       	mov	r11,r2
80009c54:	06 9c       	mov	r12,r3
80009c56:	fe b0 fa 7f 	rcall	80009154 <quorem>
80009c5a:	40 4b       	lddsp	r11,sp[0x10]
80009c5c:	f8 c0 ff d0 	sub	r0,r12,-48
80009c60:	06 9c       	mov	r12,r3
80009c62:	e0 a0 05 a8 	rcall	8000a7b2 <__mcmp>
80009c66:	08 9a       	mov	r10,r4
80009c68:	50 6c       	stdsp	sp[0x18],r12
80009c6a:	04 9b       	mov	r11,r2
80009c6c:	0e 9c       	mov	r12,r7
80009c6e:	e0 a0 06 5d 	rcall	8000a928 <__mdiff>
80009c72:	18 91       	mov	r1,r12
80009c74:	78 38       	ld.w	r8,r12[0xc]
80009c76:	58 08       	cp.w	r8,0
80009c78:	c0 30       	breq	80009c7e <_dtoa_r+0xa0a>
80009c7a:	30 16       	mov	r6,1
80009c7c:	c0 68       	rjmp	80009c88 <_dtoa_r+0xa14>
80009c7e:	18 9b       	mov	r11,r12
80009c80:	06 9c       	mov	r12,r3
80009c82:	e0 a0 05 98 	rcall	8000a7b2 <__mcmp>
80009c86:	18 96       	mov	r6,r12
80009c88:	0e 9c       	mov	r12,r7
80009c8a:	02 9b       	mov	r11,r1
80009c8c:	e0 a0 05 ac 	rcall	8000a7e4 <_Bfree>
80009c90:	40 cc       	lddsp	r12,sp[0x30]
80009c92:	ed ec 10 08 	or	r8,r6,r12
80009c96:	c0 d1       	brne	80009cb0 <_dtoa_r+0xa3c>
80009c98:	40 db       	lddsp	r11,sp[0x34]
80009c9a:	58 0b       	cp.w	r11,0
80009c9c:	c0 a1       	brne	80009cb0 <_dtoa_r+0xa3c>
80009c9e:	40 26       	lddsp	r6,sp[0x8]
80009ca0:	e0 40 00 39 	cp.w	r0,57
80009ca4:	c3 00       	breq	80009d04 <_dtoa_r+0xa90>
80009ca6:	40 6a       	lddsp	r10,sp[0x18]
80009ca8:	58 0a       	cp.w	r10,0
80009caa:	e0 89 00 24 	brgt	80009cf2 <_dtoa_r+0xa7e>
80009cae:	c2 f8       	rjmp	80009d0c <_dtoa_r+0xa98>
80009cb0:	40 69       	lddsp	r9,sp[0x18]
80009cb2:	58 09       	cp.w	r9,0
80009cb4:	c0 85       	brlt	80009cc4 <_dtoa_r+0xa50>
80009cb6:	12 98       	mov	r8,r9
80009cb8:	40 cc       	lddsp	r12,sp[0x30]
80009cba:	18 48       	or	r8,r12
80009cbc:	c1 d1       	brne	80009cf6 <_dtoa_r+0xa82>
80009cbe:	40 db       	lddsp	r11,sp[0x34]
80009cc0:	58 0b       	cp.w	r11,0
80009cc2:	c1 a1       	brne	80009cf6 <_dtoa_r+0xa82>
80009cc4:	0c 99       	mov	r9,r6
80009cc6:	40 26       	lddsp	r6,sp[0x8]
80009cc8:	58 09       	cp.w	r9,0
80009cca:	e0 8a 00 21 	brle	80009d0c <_dtoa_r+0xa98>
80009cce:	06 9b       	mov	r11,r3
80009cd0:	30 1a       	mov	r10,1
80009cd2:	0e 9c       	mov	r12,r7
80009cd4:	e0 a0 06 92 	rcall	8000a9f8 <__lshift>
80009cd8:	04 9b       	mov	r11,r2
80009cda:	18 93       	mov	r3,r12
80009cdc:	e0 a0 05 6b 	rcall	8000a7b2 <__mcmp>
80009ce0:	e0 89 00 06 	brgt	80009cec <_dtoa_r+0xa78>
80009ce4:	c1 41       	brne	80009d0c <_dtoa_r+0xa98>
80009ce6:	ed b0 00 00 	bld	r0,0x0
80009cea:	c1 11       	brne	80009d0c <_dtoa_r+0xa98>
80009cec:	e0 40 00 39 	cp.w	r0,57
80009cf0:	c0 a0       	breq	80009d04 <_dtoa_r+0xa90>
80009cf2:	2f f0       	sub	r0,-1
80009cf4:	c0 c8       	rjmp	80009d0c <_dtoa_r+0xa98>
80009cf6:	58 06       	cp.w	r6,0
80009cf8:	e0 8a 00 0c 	brle	80009d10 <_dtoa_r+0xa9c>
80009cfc:	40 26       	lddsp	r6,sp[0x8]
80009cfe:	e0 40 00 39 	cp.w	r0,57
80009d02:	c0 41       	brne	80009d0a <_dtoa_r+0xa96>
80009d04:	33 98       	mov	r8,57
80009d06:	0a c8       	st.b	r5++,r8
80009d08:	c6 78       	rjmp	80009dd6 <_dtoa_r+0xb62>
80009d0a:	2f f0       	sub	r0,-1
80009d0c:	0a c0       	st.b	r5++,r0
80009d0e:	c7 58       	rjmp	80009df8 <_dtoa_r+0xb84>
80009d10:	0a c0       	st.b	r5++,r0
80009d12:	40 9a       	lddsp	r10,sp[0x24]
80009d14:	40 e9       	lddsp	r9,sp[0x38]
80009d16:	12 3a       	cp.w	r10,r9
80009d18:	c4 30       	breq	80009d9e <_dtoa_r+0xb2a>
80009d1a:	06 9b       	mov	r11,r3
80009d1c:	30 09       	mov	r9,0
80009d1e:	30 aa       	mov	r10,10
80009d20:	0e 9c       	mov	r12,r7
80009d22:	e0 a0 07 37 	rcall	8000ab90 <__multadd>
80009d26:	40 48       	lddsp	r8,sp[0x10]
80009d28:	18 93       	mov	r3,r12
80009d2a:	08 38       	cp.w	r8,r4
80009d2c:	c0 91       	brne	80009d3e <_dtoa_r+0xaca>
80009d2e:	10 9b       	mov	r11,r8
80009d30:	30 09       	mov	r9,0
80009d32:	30 aa       	mov	r10,10
80009d34:	0e 9c       	mov	r12,r7
80009d36:	e0 a0 07 2d 	rcall	8000ab90 <__multadd>
80009d3a:	50 4c       	stdsp	sp[0x10],r12
80009d3c:	c0 e8       	rjmp	80009d58 <_dtoa_r+0xae4>
80009d3e:	40 4b       	lddsp	r11,sp[0x10]
80009d40:	30 09       	mov	r9,0
80009d42:	30 aa       	mov	r10,10
80009d44:	0e 9c       	mov	r12,r7
80009d46:	e0 a0 07 25 	rcall	8000ab90 <__multadd>
80009d4a:	08 9b       	mov	r11,r4
80009d4c:	50 4c       	stdsp	sp[0x10],r12
80009d4e:	30 09       	mov	r9,0
80009d50:	30 aa       	mov	r10,10
80009d52:	0e 9c       	mov	r12,r7
80009d54:	e0 a0 07 1e 	rcall	8000ab90 <__multadd>
80009d58:	18 94       	mov	r4,r12
80009d5a:	40 9c       	lddsp	r12,sp[0x24]
80009d5c:	2f fc       	sub	r12,-1
80009d5e:	50 9c       	stdsp	sp[0x24],r12
80009d60:	c7 9b       	rjmp	80009c52 <_dtoa_r+0x9de>
80009d62:	30 18       	mov	r8,1
80009d64:	06 90       	mov	r0,r3
80009d66:	40 85       	lddsp	r5,sp[0x20]
80009d68:	08 93       	mov	r3,r4
80009d6a:	0c 94       	mov	r4,r6
80009d6c:	10 96       	mov	r6,r8
80009d6e:	04 9b       	mov	r11,r2
80009d70:	00 9c       	mov	r12,r0
80009d72:	fe b0 f9 f1 	rcall	80009154 <quorem>
80009d76:	2d 0c       	sub	r12,-48
80009d78:	0a cc       	st.b	r5++,r12
80009d7a:	02 36       	cp.w	r6,r1
80009d7c:	c0 a4       	brge	80009d90 <_dtoa_r+0xb1c>
80009d7e:	00 9b       	mov	r11,r0
80009d80:	30 09       	mov	r9,0
80009d82:	30 aa       	mov	r10,10
80009d84:	0e 9c       	mov	r12,r7
80009d86:	2f f6       	sub	r6,-1
80009d88:	e0 a0 07 04 	rcall	8000ab90 <__multadd>
80009d8c:	18 90       	mov	r0,r12
80009d8e:	cf 0b       	rjmp	80009d6e <_dtoa_r+0xafa>
80009d90:	08 96       	mov	r6,r4
80009d92:	30 0b       	mov	r11,0
80009d94:	06 94       	mov	r4,r3
80009d96:	50 4b       	stdsp	sp[0x10],r11
80009d98:	00 93       	mov	r3,r0
80009d9a:	18 90       	mov	r0,r12
80009d9c:	c0 28       	rjmp	80009da0 <_dtoa_r+0xb2c>
80009d9e:	40 26       	lddsp	r6,sp[0x8]
80009da0:	06 9b       	mov	r11,r3
80009da2:	30 1a       	mov	r10,1
80009da4:	0e 9c       	mov	r12,r7
80009da6:	e0 a0 06 29 	rcall	8000a9f8 <__lshift>
80009daa:	04 9b       	mov	r11,r2
80009dac:	18 93       	mov	r3,r12
80009dae:	e0 a0 05 02 	rcall	8000a7b2 <__mcmp>
80009db2:	e0 89 00 12 	brgt	80009dd6 <_dtoa_r+0xb62>
80009db6:	c1 b1       	brne	80009dec <_dtoa_r+0xb78>
80009db8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009dbc:	c0 d1       	brne	80009dd6 <_dtoa_r+0xb62>
80009dbe:	c1 78       	rjmp	80009dec <_dtoa_r+0xb78>
80009dc0:	40 89       	lddsp	r9,sp[0x20]
80009dc2:	12 38       	cp.w	r8,r9
80009dc4:	c0 30       	breq	80009dca <_dtoa_r+0xb56>
80009dc6:	10 95       	mov	r5,r8
80009dc8:	c0 88       	rjmp	80009dd8 <_dtoa_r+0xb64>
80009dca:	2f f6       	sub	r6,-1
80009dcc:	50 66       	stdsp	sp[0x18],r6
80009dce:	33 18       	mov	r8,49
80009dd0:	40 8c       	lddsp	r12,sp[0x20]
80009dd2:	b8 88       	st.b	r12[0x0],r8
80009dd4:	c1 38       	rjmp	80009dfa <_dtoa_r+0xb86>
80009dd6:	33 9a       	mov	r10,57
80009dd8:	0a 98       	mov	r8,r5
80009dda:	11 79       	ld.ub	r9,--r8
80009ddc:	f4 09 18 00 	cp.b	r9,r10
80009de0:	cf 00       	breq	80009dc0 <_dtoa_r+0xb4c>
80009de2:	2f f9       	sub	r9,-1
80009de4:	b0 89       	st.b	r8[0x0],r9
80009de6:	c0 98       	rjmp	80009df8 <_dtoa_r+0xb84>
80009de8:	10 95       	mov	r5,r8
80009dea:	c0 28       	rjmp	80009dee <_dtoa_r+0xb7a>
80009dec:	33 09       	mov	r9,48
80009dee:	0a 98       	mov	r8,r5
80009df0:	11 7a       	ld.ub	r10,--r8
80009df2:	f2 0a 18 00 	cp.b	r10,r9
80009df6:	cf 90       	breq	80009de8 <_dtoa_r+0xb74>
80009df8:	50 66       	stdsp	sp[0x18],r6
80009dfa:	04 9b       	mov	r11,r2
80009dfc:	0e 9c       	mov	r12,r7
80009dfe:	e0 a0 04 f3 	rcall	8000a7e4 <_Bfree>
80009e02:	58 04       	cp.w	r4,0
80009e04:	c1 20       	breq	80009e28 <_dtoa_r+0xbb4>
80009e06:	40 4b       	lddsp	r11,sp[0x10]
80009e08:	08 3b       	cp.w	r11,r4
80009e0a:	5f 19       	srne	r9
80009e0c:	58 0b       	cp.w	r11,0
80009e0e:	5f 18       	srne	r8
80009e10:	f3 e8 00 08 	and	r8,r9,r8
80009e14:	c0 40       	breq	80009e1c <_dtoa_r+0xba8>
80009e16:	0e 9c       	mov	r12,r7
80009e18:	e0 a0 04 e6 	rcall	8000a7e4 <_Bfree>
80009e1c:	08 9b       	mov	r11,r4
80009e1e:	0e 9c       	mov	r12,r7
80009e20:	e0 a0 04 e2 	rcall	8000a7e4 <_Bfree>
80009e24:	c0 28       	rjmp	80009e28 <_dtoa_r+0xbb4>
80009e26:	50 66       	stdsp	sp[0x18],r6
80009e28:	0e 9c       	mov	r12,r7
80009e2a:	06 9b       	mov	r11,r3
80009e2c:	e0 a0 04 dc 	rcall	8000a7e4 <_Bfree>
80009e30:	30 08       	mov	r8,0
80009e32:	aa 88       	st.b	r5[0x0],r8
80009e34:	40 68       	lddsp	r8,sp[0x18]
80009e36:	41 5a       	lddsp	r10,sp[0x54]
80009e38:	2f f8       	sub	r8,-1
80009e3a:	41 29       	lddsp	r9,sp[0x48]
80009e3c:	95 08       	st.w	r10[0x0],r8
80009e3e:	40 8c       	lddsp	r12,sp[0x20]
80009e40:	58 09       	cp.w	r9,0
80009e42:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009e46:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009e4a:	2e 6d       	sub	sp,-104
80009e4c:	d8 32       	popm	r0-r7,pc
80009e4e:	d7 03       	nop

80009e50 <__errno>:
80009e50:	e0 68 0a 2c 	mov	r8,2604
80009e54:	70 0c       	ld.w	r12,r8[0x0]
80009e56:	2f 4c       	sub	r12,-12
80009e58:	5e fc       	retal	r12
80009e5a:	d7 03       	nop

80009e5c <_fflush_r>:
80009e5c:	d4 21       	pushm	r4-r7,lr
80009e5e:	16 97       	mov	r7,r11
80009e60:	18 96       	mov	r6,r12
80009e62:	76 48       	ld.w	r8,r11[0x10]
80009e64:	58 08       	cp.w	r8,0
80009e66:	c7 f0       	breq	80009f64 <_fflush_r+0x108>
80009e68:	58 0c       	cp.w	r12,0
80009e6a:	c0 50       	breq	80009e74 <_fflush_r+0x18>
80009e6c:	78 68       	ld.w	r8,r12[0x18]
80009e6e:	58 08       	cp.w	r8,0
80009e70:	c0 21       	brne	80009e74 <_fflush_r+0x18>
80009e72:	cc dc       	rcall	8000a00c <__sinit>
80009e74:	fe c8 cf 0c 	sub	r8,pc,-12532
80009e78:	10 37       	cp.w	r7,r8
80009e7a:	c0 31       	brne	80009e80 <_fflush_r+0x24>
80009e7c:	6c 07       	ld.w	r7,r6[0x0]
80009e7e:	c0 c8       	rjmp	80009e96 <_fflush_r+0x3a>
80009e80:	fe c8 ce f8 	sub	r8,pc,-12552
80009e84:	10 37       	cp.w	r7,r8
80009e86:	c0 31       	brne	80009e8c <_fflush_r+0x30>
80009e88:	6c 17       	ld.w	r7,r6[0x4]
80009e8a:	c0 68       	rjmp	80009e96 <_fflush_r+0x3a>
80009e8c:	fe c8 ce e4 	sub	r8,pc,-12572
80009e90:	10 37       	cp.w	r7,r8
80009e92:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009e96:	8e 6a       	ld.sh	r10,r7[0xc]
80009e98:	14 98       	mov	r8,r10
80009e9a:	ed ba 00 03 	bld	r10,0x3
80009e9e:	c4 20       	breq	80009f22 <_fflush_r+0xc6>
80009ea0:	ab ba       	sbr	r10,0xb
80009ea2:	ae 6a       	st.h	r7[0xc],r10
80009ea4:	6e 18       	ld.w	r8,r7[0x4]
80009ea6:	58 08       	cp.w	r8,0
80009ea8:	e0 89 00 06 	brgt	80009eb4 <_fflush_r+0x58>
80009eac:	6f 08       	ld.w	r8,r7[0x40]
80009eae:	58 08       	cp.w	r8,0
80009eb0:	e0 8a 00 5a 	brle	80009f64 <_fflush_r+0x108>
80009eb4:	6e b8       	ld.w	r8,r7[0x2c]
80009eb6:	58 08       	cp.w	r8,0
80009eb8:	c5 60       	breq	80009f64 <_fflush_r+0x108>
80009eba:	e2 1a 10 00 	andl	r10,0x1000,COH
80009ebe:	c0 30       	breq	80009ec4 <_fflush_r+0x68>
80009ec0:	6f 55       	ld.w	r5,r7[0x54]
80009ec2:	c0 f8       	rjmp	80009ee0 <_fflush_r+0x84>
80009ec4:	30 19       	mov	r9,1
80009ec6:	6e 8b       	ld.w	r11,r7[0x20]
80009ec8:	0c 9c       	mov	r12,r6
80009eca:	5d 18       	icall	r8
80009ecc:	18 95       	mov	r5,r12
80009ece:	5b fc       	cp.w	r12,-1
80009ed0:	c0 81       	brne	80009ee0 <_fflush_r+0x84>
80009ed2:	6c 38       	ld.w	r8,r6[0xc]
80009ed4:	59 d8       	cp.w	r8,29
80009ed6:	c4 70       	breq	80009f64 <_fflush_r+0x108>
80009ed8:	8e 68       	ld.sh	r8,r7[0xc]
80009eda:	a7 a8       	sbr	r8,0x6
80009edc:	ae 68       	st.h	r7[0xc],r8
80009ede:	d8 22       	popm	r4-r7,pc
80009ee0:	8e 68       	ld.sh	r8,r7[0xc]
80009ee2:	ed b8 00 02 	bld	r8,0x2
80009ee6:	c0 91       	brne	80009ef8 <_fflush_r+0x9c>
80009ee8:	6e 18       	ld.w	r8,r7[0x4]
80009eea:	10 15       	sub	r5,r8
80009eec:	6e d8       	ld.w	r8,r7[0x34]
80009eee:	58 08       	cp.w	r8,0
80009ef0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009ef4:	eb d8 e1 15 	subne	r5,r5,r8
80009ef8:	6e b8       	ld.w	r8,r7[0x2c]
80009efa:	0c 9c       	mov	r12,r6
80009efc:	30 09       	mov	r9,0
80009efe:	0a 9a       	mov	r10,r5
80009f00:	6e 8b       	ld.w	r11,r7[0x20]
80009f02:	5d 18       	icall	r8
80009f04:	8e 68       	ld.sh	r8,r7[0xc]
80009f06:	0a 3c       	cp.w	r12,r5
80009f08:	c2 61       	brne	80009f54 <_fflush_r+0xf8>
80009f0a:	ab d8       	cbr	r8,0xb
80009f0c:	30 0c       	mov	r12,0
80009f0e:	6e 49       	ld.w	r9,r7[0x10]
80009f10:	ae 68       	st.h	r7[0xc],r8
80009f12:	8f 1c       	st.w	r7[0x4],r12
80009f14:	8f 09       	st.w	r7[0x0],r9
80009f16:	ed b8 00 0c 	bld	r8,0xc
80009f1a:	c2 51       	brne	80009f64 <_fflush_r+0x108>
80009f1c:	ef 45 00 54 	st.w	r7[84],r5
80009f20:	d8 22       	popm	r4-r7,pc
80009f22:	6e 45       	ld.w	r5,r7[0x10]
80009f24:	58 05       	cp.w	r5,0
80009f26:	c1 f0       	breq	80009f64 <_fflush_r+0x108>
80009f28:	6e 04       	ld.w	r4,r7[0x0]
80009f2a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009f2e:	8f 05       	st.w	r7[0x0],r5
80009f30:	f9 b8 01 00 	movne	r8,0
80009f34:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009f38:	0a 14       	sub	r4,r5
80009f3a:	8f 28       	st.w	r7[0x8],r8
80009f3c:	c1 18       	rjmp	80009f5e <_fflush_r+0x102>
80009f3e:	08 99       	mov	r9,r4
80009f40:	0a 9a       	mov	r10,r5
80009f42:	6e a8       	ld.w	r8,r7[0x28]
80009f44:	6e 8b       	ld.w	r11,r7[0x20]
80009f46:	0c 9c       	mov	r12,r6
80009f48:	5d 18       	icall	r8
80009f4a:	18 14       	sub	r4,r12
80009f4c:	58 0c       	cp.w	r12,0
80009f4e:	e0 89 00 07 	brgt	80009f5c <_fflush_r+0x100>
80009f52:	8e 68       	ld.sh	r8,r7[0xc]
80009f54:	a7 a8       	sbr	r8,0x6
80009f56:	3f fc       	mov	r12,-1
80009f58:	ae 68       	st.h	r7[0xc],r8
80009f5a:	d8 22       	popm	r4-r7,pc
80009f5c:	18 05       	add	r5,r12
80009f5e:	58 04       	cp.w	r4,0
80009f60:	fe 99 ff ef 	brgt	80009f3e <_fflush_r+0xe2>
80009f64:	d8 2a       	popm	r4-r7,pc,r12=0
80009f66:	d7 03       	nop

80009f68 <__sfp_lock_acquire>:
80009f68:	5e fc       	retal	r12

80009f6a <__sfp_lock_release>:
80009f6a:	5e fc       	retal	r12

80009f6c <_cleanup_r>:
80009f6c:	d4 01       	pushm	lr
80009f6e:	fe cb f0 ae 	sub	r11,pc,-3922
80009f72:	e0 a0 02 f7 	rcall	8000a560 <_fwalk>
80009f76:	d8 02       	popm	pc

80009f78 <__sfmoreglue>:
80009f78:	d4 21       	pushm	r4-r7,lr
80009f7a:	16 95       	mov	r5,r11
80009f7c:	f6 06 10 5c 	mul	r6,r11,92
80009f80:	ec cb ff f4 	sub	r11,r6,-12
80009f84:	fe b0 e2 88 	rcall	80006494 <_malloc_r>
80009f88:	18 97       	mov	r7,r12
80009f8a:	c0 90       	breq	80009f9c <__sfmoreglue+0x24>
80009f8c:	99 15       	st.w	r12[0x4],r5
80009f8e:	30 0b       	mov	r11,0
80009f90:	2f 4c       	sub	r12,-12
80009f92:	0c 9a       	mov	r10,r6
80009f94:	8f 2c       	st.w	r7[0x8],r12
80009f96:	8f 0b       	st.w	r7[0x0],r11
80009f98:	fe b0 e5 3e 	rcall	80006a14 <memset>
80009f9c:	0e 9c       	mov	r12,r7
80009f9e:	d8 22       	popm	r4-r7,pc

80009fa0 <__sfp>:
80009fa0:	d4 21       	pushm	r4-r7,lr
80009fa2:	fe c8 cf d6 	sub	r8,pc,-12330
80009fa6:	18 96       	mov	r6,r12
80009fa8:	70 07       	ld.w	r7,r8[0x0]
80009faa:	6e 68       	ld.w	r8,r7[0x18]
80009fac:	58 08       	cp.w	r8,0
80009fae:	c0 31       	brne	80009fb4 <__sfp+0x14>
80009fb0:	0e 9c       	mov	r12,r7
80009fb2:	c2 dc       	rcall	8000a00c <__sinit>
80009fb4:	ee c7 ff 28 	sub	r7,r7,-216
80009fb8:	30 05       	mov	r5,0
80009fba:	6e 2c       	ld.w	r12,r7[0x8]
80009fbc:	6e 18       	ld.w	r8,r7[0x4]
80009fbe:	c0 68       	rjmp	80009fca <__sfp+0x2a>
80009fc0:	98 69       	ld.sh	r9,r12[0xc]
80009fc2:	ea 09 19 00 	cp.h	r9,r5
80009fc6:	c1 10       	breq	80009fe8 <__sfp+0x48>
80009fc8:	2a 4c       	sub	r12,-92
80009fca:	20 18       	sub	r8,1
80009fcc:	cf a7       	brpl	80009fc0 <__sfp+0x20>
80009fce:	6e 08       	ld.w	r8,r7[0x0]
80009fd0:	58 08       	cp.w	r8,0
80009fd2:	c0 61       	brne	80009fde <__sfp+0x3e>
80009fd4:	30 4b       	mov	r11,4
80009fd6:	0c 9c       	mov	r12,r6
80009fd8:	cd 0f       	rcall	80009f78 <__sfmoreglue>
80009fda:	8f 0c       	st.w	r7[0x0],r12
80009fdc:	c0 30       	breq	80009fe2 <__sfp+0x42>
80009fde:	6e 07       	ld.w	r7,r7[0x0]
80009fe0:	ce db       	rjmp	80009fba <__sfp+0x1a>
80009fe2:	30 c8       	mov	r8,12
80009fe4:	8d 38       	st.w	r6[0xc],r8
80009fe6:	d8 22       	popm	r4-r7,pc
80009fe8:	30 08       	mov	r8,0
80009fea:	f9 48 00 4c 	st.w	r12[76],r8
80009fee:	99 08       	st.w	r12[0x0],r8
80009ff0:	99 28       	st.w	r12[0x8],r8
80009ff2:	99 18       	st.w	r12[0x4],r8
80009ff4:	99 48       	st.w	r12[0x10],r8
80009ff6:	99 58       	st.w	r12[0x14],r8
80009ff8:	99 68       	st.w	r12[0x18],r8
80009ffa:	99 d8       	st.w	r12[0x34],r8
80009ffc:	99 e8       	st.w	r12[0x38],r8
80009ffe:	f9 48 00 48 	st.w	r12[72],r8
8000a002:	3f f8       	mov	r8,-1
8000a004:	b8 78       	st.h	r12[0xe],r8
8000a006:	30 18       	mov	r8,1
8000a008:	b8 68       	st.h	r12[0xc],r8
8000a00a:	d8 22       	popm	r4-r7,pc

8000a00c <__sinit>:
8000a00c:	d4 21       	pushm	r4-r7,lr
8000a00e:	18 96       	mov	r6,r12
8000a010:	78 67       	ld.w	r7,r12[0x18]
8000a012:	58 07       	cp.w	r7,0
8000a014:	c4 91       	brne	8000a0a6 <__sinit+0x9a>
8000a016:	fe c8 00 aa 	sub	r8,pc,170
8000a01a:	30 15       	mov	r5,1
8000a01c:	99 a8       	st.w	r12[0x28],r8
8000a01e:	f9 47 00 d8 	st.w	r12[216],r7
8000a022:	f9 47 00 dc 	st.w	r12[220],r7
8000a026:	f9 47 00 e0 	st.w	r12[224],r7
8000a02a:	99 65       	st.w	r12[0x18],r5
8000a02c:	cb af       	rcall	80009fa0 <__sfp>
8000a02e:	8d 0c       	st.w	r6[0x0],r12
8000a030:	0c 9c       	mov	r12,r6
8000a032:	cb 7f       	rcall	80009fa0 <__sfp>
8000a034:	8d 1c       	st.w	r6[0x4],r12
8000a036:	0c 9c       	mov	r12,r6
8000a038:	cb 4f       	rcall	80009fa0 <__sfp>
8000a03a:	6c 09       	ld.w	r9,r6[0x0]
8000a03c:	30 48       	mov	r8,4
8000a03e:	93 07       	st.w	r9[0x0],r7
8000a040:	b2 68       	st.h	r9[0xc],r8
8000a042:	93 17       	st.w	r9[0x4],r7
8000a044:	93 27       	st.w	r9[0x8],r7
8000a046:	6c 18       	ld.w	r8,r6[0x4]
8000a048:	b2 77       	st.h	r9[0xe],r7
8000a04a:	93 47       	st.w	r9[0x10],r7
8000a04c:	93 57       	st.w	r9[0x14],r7
8000a04e:	93 67       	st.w	r9[0x18],r7
8000a050:	93 89       	st.w	r9[0x20],r9
8000a052:	91 07       	st.w	r8[0x0],r7
8000a054:	91 17       	st.w	r8[0x4],r7
8000a056:	91 27       	st.w	r8[0x8],r7
8000a058:	fe ce f3 24 	sub	lr,pc,-3292
8000a05c:	fe cb f3 54 	sub	r11,pc,-3244
8000a060:	93 9e       	st.w	r9[0x24],lr
8000a062:	93 ab       	st.w	r9[0x28],r11
8000a064:	fe ca f3 7c 	sub	r10,pc,-3204
8000a068:	fe c4 f3 88 	sub	r4,pc,-3192
8000a06c:	93 ba       	st.w	r9[0x2c],r10
8000a06e:	93 c4       	st.w	r9[0x30],r4
8000a070:	30 99       	mov	r9,9
8000a072:	b0 69       	st.h	r8[0xc],r9
8000a074:	b0 75       	st.h	r8[0xe],r5
8000a076:	91 c4       	st.w	r8[0x30],r4
8000a078:	91 47       	st.w	r8[0x10],r7
8000a07a:	91 57       	st.w	r8[0x14],r7
8000a07c:	91 67       	st.w	r8[0x18],r7
8000a07e:	91 88       	st.w	r8[0x20],r8
8000a080:	91 9e       	st.w	r8[0x24],lr
8000a082:	91 ab       	st.w	r8[0x28],r11
8000a084:	91 ba       	st.w	r8[0x2c],r10
8000a086:	8d 2c       	st.w	r6[0x8],r12
8000a088:	31 28       	mov	r8,18
8000a08a:	99 07       	st.w	r12[0x0],r7
8000a08c:	b8 68       	st.h	r12[0xc],r8
8000a08e:	99 17       	st.w	r12[0x4],r7
8000a090:	99 27       	st.w	r12[0x8],r7
8000a092:	30 28       	mov	r8,2
8000a094:	b8 78       	st.h	r12[0xe],r8
8000a096:	99 c4       	st.w	r12[0x30],r4
8000a098:	99 67       	st.w	r12[0x18],r7
8000a09a:	99 9e       	st.w	r12[0x24],lr
8000a09c:	99 ab       	st.w	r12[0x28],r11
8000a09e:	99 ba       	st.w	r12[0x2c],r10
8000a0a0:	99 47       	st.w	r12[0x10],r7
8000a0a2:	99 57       	st.w	r12[0x14],r7
8000a0a4:	99 8c       	st.w	r12[0x20],r12
8000a0a6:	d8 22       	popm	r4-r7,pc

8000a0a8 <_malloc_trim_r>:
8000a0a8:	d4 21       	pushm	r4-r7,lr
8000a0aa:	16 95       	mov	r5,r11
8000a0ac:	18 97       	mov	r7,r12
8000a0ae:	fe b0 d7 f5 	rcall	80005098 <__malloc_lock>
8000a0b2:	e0 64 05 2c 	mov	r4,1324
8000a0b6:	68 28       	ld.w	r8,r4[0x8]
8000a0b8:	70 16       	ld.w	r6,r8[0x4]
8000a0ba:	e0 16 ff fc 	andl	r6,0xfffc
8000a0be:	ec c8 ff 91 	sub	r8,r6,-111
8000a0c2:	f0 05 01 05 	sub	r5,r8,r5
8000a0c6:	e0 15 ff 80 	andl	r5,0xff80
8000a0ca:	ea c5 00 80 	sub	r5,r5,128
8000a0ce:	e0 45 00 7f 	cp.w	r5,127
8000a0d2:	e0 8a 00 25 	brle	8000a11c <_malloc_trim_r+0x74>
8000a0d6:	30 0b       	mov	r11,0
8000a0d8:	0e 9c       	mov	r12,r7
8000a0da:	fe b0 e6 05 	rcall	80006ce4 <_sbrk_r>
8000a0de:	68 28       	ld.w	r8,r4[0x8]
8000a0e0:	0c 08       	add	r8,r6
8000a0e2:	10 3c       	cp.w	r12,r8
8000a0e4:	c1 c1       	brne	8000a11c <_malloc_trim_r+0x74>
8000a0e6:	ea 0b 11 00 	rsub	r11,r5,0
8000a0ea:	0e 9c       	mov	r12,r7
8000a0ec:	fe b0 e5 fc 	rcall	80006ce4 <_sbrk_r>
8000a0f0:	5b fc       	cp.w	r12,-1
8000a0f2:	c1 91       	brne	8000a124 <_malloc_trim_r+0x7c>
8000a0f4:	30 0b       	mov	r11,0
8000a0f6:	0e 9c       	mov	r12,r7
8000a0f8:	fe b0 e5 f6 	rcall	80006ce4 <_sbrk_r>
8000a0fc:	68 28       	ld.w	r8,r4[0x8]
8000a0fe:	f8 08 01 09 	sub	r9,r12,r8
8000a102:	58 f9       	cp.w	r9,15
8000a104:	e0 8a 00 0c 	brle	8000a11c <_malloc_trim_r+0x74>
8000a108:	a1 a9       	sbr	r9,0x0
8000a10a:	91 19       	st.w	r8[0x4],r9
8000a10c:	e0 68 09 38 	mov	r8,2360
8000a110:	70 09       	ld.w	r9,r8[0x0]
8000a112:	e0 68 0d 44 	mov	r8,3396
8000a116:	f8 09 01 09 	sub	r9,r12,r9
8000a11a:	91 09       	st.w	r8[0x0],r9
8000a11c:	0e 9c       	mov	r12,r7
8000a11e:	fe b0 d7 c3 	rcall	800050a4 <__malloc_unlock>
8000a122:	d8 2a       	popm	r4-r7,pc,r12=0
8000a124:	68 28       	ld.w	r8,r4[0x8]
8000a126:	0a 16       	sub	r6,r5
8000a128:	a1 a6       	sbr	r6,0x0
8000a12a:	91 16       	st.w	r8[0x4],r6
8000a12c:	e0 68 0d 44 	mov	r8,3396
8000a130:	70 09       	ld.w	r9,r8[0x0]
8000a132:	0a 19       	sub	r9,r5
8000a134:	0e 9c       	mov	r12,r7
8000a136:	91 09       	st.w	r8[0x0],r9
8000a138:	fe b0 d7 b6 	rcall	800050a4 <__malloc_unlock>
8000a13c:	da 2a       	popm	r4-r7,pc,r12=1
8000a13e:	d7 03       	nop

8000a140 <_free_r>:
8000a140:	d4 21       	pushm	r4-r7,lr
8000a142:	16 96       	mov	r6,r11
8000a144:	18 97       	mov	r7,r12
8000a146:	58 0b       	cp.w	r11,0
8000a148:	e0 80 00 c0 	breq	8000a2c8 <_free_r+0x188>
8000a14c:	fe b0 d7 a6 	rcall	80005098 <__malloc_lock>
8000a150:	20 86       	sub	r6,8
8000a152:	e0 6a 05 2c 	mov	r10,1324
8000a156:	6c 18       	ld.w	r8,r6[0x4]
8000a158:	74 2e       	ld.w	lr,r10[0x8]
8000a15a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a15e:	a1 c8       	cbr	r8,0x0
8000a160:	ec 08 00 09 	add	r9,r6,r8
8000a164:	72 1b       	ld.w	r11,r9[0x4]
8000a166:	e0 1b ff fc 	andl	r11,0xfffc
8000a16a:	1c 39       	cp.w	r9,lr
8000a16c:	c1 e1       	brne	8000a1a8 <_free_r+0x68>
8000a16e:	f6 08 00 08 	add	r8,r11,r8
8000a172:	58 0c       	cp.w	r12,0
8000a174:	c0 81       	brne	8000a184 <_free_r+0x44>
8000a176:	6c 09       	ld.w	r9,r6[0x0]
8000a178:	12 16       	sub	r6,r9
8000a17a:	12 08       	add	r8,r9
8000a17c:	6c 3b       	ld.w	r11,r6[0xc]
8000a17e:	6c 29       	ld.w	r9,r6[0x8]
8000a180:	97 29       	st.w	r11[0x8],r9
8000a182:	93 3b       	st.w	r9[0xc],r11
8000a184:	10 99       	mov	r9,r8
8000a186:	95 26       	st.w	r10[0x8],r6
8000a188:	a1 a9       	sbr	r9,0x0
8000a18a:	8d 19       	st.w	r6[0x4],r9
8000a18c:	e0 69 09 34 	mov	r9,2356
8000a190:	72 09       	ld.w	r9,r9[0x0]
8000a192:	12 38       	cp.w	r8,r9
8000a194:	c0 63       	brcs	8000a1a0 <_free_r+0x60>
8000a196:	e0 68 0d 40 	mov	r8,3392
8000a19a:	0e 9c       	mov	r12,r7
8000a19c:	70 0b       	ld.w	r11,r8[0x0]
8000a19e:	c8 5f       	rcall	8000a0a8 <_malloc_trim_r>
8000a1a0:	0e 9c       	mov	r12,r7
8000a1a2:	fe b0 d7 81 	rcall	800050a4 <__malloc_unlock>
8000a1a6:	d8 22       	popm	r4-r7,pc
8000a1a8:	93 1b       	st.w	r9[0x4],r11
8000a1aa:	58 0c       	cp.w	r12,0
8000a1ac:	c0 30       	breq	8000a1b2 <_free_r+0x72>
8000a1ae:	30 0c       	mov	r12,0
8000a1b0:	c1 08       	rjmp	8000a1d0 <_free_r+0x90>
8000a1b2:	6c 0e       	ld.w	lr,r6[0x0]
8000a1b4:	f4 c5 ff f8 	sub	r5,r10,-8
8000a1b8:	1c 16       	sub	r6,lr
8000a1ba:	1c 08       	add	r8,lr
8000a1bc:	6c 2e       	ld.w	lr,r6[0x8]
8000a1be:	0a 3e       	cp.w	lr,r5
8000a1c0:	f9 bc 00 01 	moveq	r12,1
8000a1c4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a1c8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a1cc:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a1d0:	f2 0b 00 0e 	add	lr,r9,r11
8000a1d4:	7c 1e       	ld.w	lr,lr[0x4]
8000a1d6:	ed be 00 00 	bld	lr,0x0
8000a1da:	c1 40       	breq	8000a202 <_free_r+0xc2>
8000a1dc:	16 08       	add	r8,r11
8000a1de:	58 0c       	cp.w	r12,0
8000a1e0:	c0 d1       	brne	8000a1fa <_free_r+0xba>
8000a1e2:	e0 6e 05 2c 	mov	lr,1324
8000a1e6:	72 2b       	ld.w	r11,r9[0x8]
8000a1e8:	2f 8e       	sub	lr,-8
8000a1ea:	1c 3b       	cp.w	r11,lr
8000a1ec:	c0 71       	brne	8000a1fa <_free_r+0xba>
8000a1ee:	97 36       	st.w	r11[0xc],r6
8000a1f0:	97 26       	st.w	r11[0x8],r6
8000a1f2:	8d 2b       	st.w	r6[0x8],r11
8000a1f4:	8d 3b       	st.w	r6[0xc],r11
8000a1f6:	30 1c       	mov	r12,1
8000a1f8:	c0 58       	rjmp	8000a202 <_free_r+0xc2>
8000a1fa:	72 2b       	ld.w	r11,r9[0x8]
8000a1fc:	72 39       	ld.w	r9,r9[0xc]
8000a1fe:	93 2b       	st.w	r9[0x8],r11
8000a200:	97 39       	st.w	r11[0xc],r9
8000a202:	10 99       	mov	r9,r8
8000a204:	ec 08 09 08 	st.w	r6[r8],r8
8000a208:	a1 a9       	sbr	r9,0x0
8000a20a:	8d 19       	st.w	r6[0x4],r9
8000a20c:	58 0c       	cp.w	r12,0
8000a20e:	c5 a1       	brne	8000a2c2 <_free_r+0x182>
8000a210:	e0 48 01 ff 	cp.w	r8,511
8000a214:	e0 8b 00 13 	brhi	8000a23a <_free_r+0xfa>
8000a218:	a3 98       	lsr	r8,0x3
8000a21a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a21e:	72 2b       	ld.w	r11,r9[0x8]
8000a220:	8d 39       	st.w	r6[0xc],r9
8000a222:	8d 2b       	st.w	r6[0x8],r11
8000a224:	97 36       	st.w	r11[0xc],r6
8000a226:	93 26       	st.w	r9[0x8],r6
8000a228:	a3 48       	asr	r8,0x2
8000a22a:	74 19       	ld.w	r9,r10[0x4]
8000a22c:	30 1b       	mov	r11,1
8000a22e:	f6 08 09 48 	lsl	r8,r11,r8
8000a232:	f3 e8 10 08 	or	r8,r9,r8
8000a236:	95 18       	st.w	r10[0x4],r8
8000a238:	c4 58       	rjmp	8000a2c2 <_free_r+0x182>
8000a23a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a23e:	58 4b       	cp.w	r11,4
8000a240:	e0 8b 00 06 	brhi	8000a24c <_free_r+0x10c>
8000a244:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a248:	2c 8b       	sub	r11,-56
8000a24a:	c2 08       	rjmp	8000a28a <_free_r+0x14a>
8000a24c:	59 4b       	cp.w	r11,20
8000a24e:	e0 8b 00 04 	brhi	8000a256 <_free_r+0x116>
8000a252:	2a 5b       	sub	r11,-91
8000a254:	c1 b8       	rjmp	8000a28a <_free_r+0x14a>
8000a256:	e0 4b 00 54 	cp.w	r11,84
8000a25a:	e0 8b 00 06 	brhi	8000a266 <_free_r+0x126>
8000a25e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a262:	29 2b       	sub	r11,-110
8000a264:	c1 38       	rjmp	8000a28a <_free_r+0x14a>
8000a266:	e0 4b 01 54 	cp.w	r11,340
8000a26a:	e0 8b 00 06 	brhi	8000a276 <_free_r+0x136>
8000a26e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a272:	28 9b       	sub	r11,-119
8000a274:	c0 b8       	rjmp	8000a28a <_free_r+0x14a>
8000a276:	e0 4b 05 54 	cp.w	r11,1364
8000a27a:	e0 88 00 05 	brls	8000a284 <_free_r+0x144>
8000a27e:	37 eb       	mov	r11,126
8000a280:	c0 58       	rjmp	8000a28a <_free_r+0x14a>
8000a282:	d7 03       	nop
8000a284:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a288:	28 4b       	sub	r11,-124
8000a28a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a28e:	78 29       	ld.w	r9,r12[0x8]
8000a290:	18 39       	cp.w	r9,r12
8000a292:	c0 e1       	brne	8000a2ae <_free_r+0x16e>
8000a294:	74 18       	ld.w	r8,r10[0x4]
8000a296:	a3 4b       	asr	r11,0x2
8000a298:	30 1c       	mov	r12,1
8000a29a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a29e:	f1 eb 10 0b 	or	r11,r8,r11
8000a2a2:	12 98       	mov	r8,r9
8000a2a4:	95 1b       	st.w	r10[0x4],r11
8000a2a6:	c0 a8       	rjmp	8000a2ba <_free_r+0x17a>
8000a2a8:	72 29       	ld.w	r9,r9[0x8]
8000a2aa:	18 39       	cp.w	r9,r12
8000a2ac:	c0 60       	breq	8000a2b8 <_free_r+0x178>
8000a2ae:	72 1a       	ld.w	r10,r9[0x4]
8000a2b0:	e0 1a ff fc 	andl	r10,0xfffc
8000a2b4:	14 38       	cp.w	r8,r10
8000a2b6:	cf 93       	brcs	8000a2a8 <_free_r+0x168>
8000a2b8:	72 38       	ld.w	r8,r9[0xc]
8000a2ba:	8d 38       	st.w	r6[0xc],r8
8000a2bc:	8d 29       	st.w	r6[0x8],r9
8000a2be:	93 36       	st.w	r9[0xc],r6
8000a2c0:	91 26       	st.w	r8[0x8],r6
8000a2c2:	0e 9c       	mov	r12,r7
8000a2c4:	fe b0 d6 f0 	rcall	800050a4 <__malloc_unlock>
8000a2c8:	d8 22       	popm	r4-r7,pc
8000a2ca:	d7 03       	nop

8000a2cc <__sfvwrite_r>:
8000a2cc:	d4 31       	pushm	r0-r7,lr
8000a2ce:	20 3d       	sub	sp,12
8000a2d0:	14 94       	mov	r4,r10
8000a2d2:	18 95       	mov	r5,r12
8000a2d4:	16 97       	mov	r7,r11
8000a2d6:	74 28       	ld.w	r8,r10[0x8]
8000a2d8:	58 08       	cp.w	r8,0
8000a2da:	e0 80 01 40 	breq	8000a55a <__sfvwrite_r+0x28e>
8000a2de:	96 68       	ld.sh	r8,r11[0xc]
8000a2e0:	ed b8 00 03 	bld	r8,0x3
8000a2e4:	c0 41       	brne	8000a2ec <__sfvwrite_r+0x20>
8000a2e6:	76 48       	ld.w	r8,r11[0x10]
8000a2e8:	58 08       	cp.w	r8,0
8000a2ea:	c0 c1       	brne	8000a302 <__sfvwrite_r+0x36>
8000a2ec:	0e 9b       	mov	r11,r7
8000a2ee:	0a 9c       	mov	r12,r5
8000a2f0:	fe b0 f6 c4 	rcall	80009078 <__swsetup_r>
8000a2f4:	c0 70       	breq	8000a302 <__sfvwrite_r+0x36>
8000a2f6:	8e 68       	ld.sh	r8,r7[0xc]
8000a2f8:	a7 a8       	sbr	r8,0x6
8000a2fa:	ae 68       	st.h	r7[0xc],r8
8000a2fc:	30 98       	mov	r8,9
8000a2fe:	8b 38       	st.w	r5[0xc],r8
8000a300:	c2 b9       	rjmp	8000a556 <__sfvwrite_r+0x28a>
8000a302:	8e 63       	ld.sh	r3,r7[0xc]
8000a304:	68 00       	ld.w	r0,r4[0x0]
8000a306:	06 96       	mov	r6,r3
8000a308:	e2 16 00 02 	andl	r6,0x2,COH
8000a30c:	c2 10       	breq	8000a34e <__sfvwrite_r+0x82>
8000a30e:	30 03       	mov	r3,0
8000a310:	e0 62 04 00 	mov	r2,1024
8000a314:	06 96       	mov	r6,r3
8000a316:	c0 48       	rjmp	8000a31e <__sfvwrite_r+0x52>
8000a318:	60 03       	ld.w	r3,r0[0x0]
8000a31a:	60 16       	ld.w	r6,r0[0x4]
8000a31c:	2f 80       	sub	r0,-8
8000a31e:	58 06       	cp.w	r6,0
8000a320:	cf c0       	breq	8000a318 <__sfvwrite_r+0x4c>
8000a322:	e0 46 04 00 	cp.w	r6,1024
8000a326:	ec 09 17 80 	movls	r9,r6
8000a32a:	e4 09 17 b0 	movhi	r9,r2
8000a32e:	06 9a       	mov	r10,r3
8000a330:	6e a8       	ld.w	r8,r7[0x28]
8000a332:	6e 8b       	ld.w	r11,r7[0x20]
8000a334:	0a 9c       	mov	r12,r5
8000a336:	5d 18       	icall	r8
8000a338:	18 16       	sub	r6,r12
8000a33a:	58 0c       	cp.w	r12,0
8000a33c:	e0 8a 01 0a 	brle	8000a550 <__sfvwrite_r+0x284>
8000a340:	68 28       	ld.w	r8,r4[0x8]
8000a342:	18 18       	sub	r8,r12
8000a344:	89 28       	st.w	r4[0x8],r8
8000a346:	e0 80 01 0a 	breq	8000a55a <__sfvwrite_r+0x28e>
8000a34a:	18 03       	add	r3,r12
8000a34c:	ce 9b       	rjmp	8000a31e <__sfvwrite_r+0x52>
8000a34e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a352:	c0 70       	breq	8000a360 <__sfvwrite_r+0x94>
8000a354:	50 06       	stdsp	sp[0x0],r6
8000a356:	0c 93       	mov	r3,r6
8000a358:	0c 91       	mov	r1,r6
8000a35a:	50 15       	stdsp	sp[0x4],r5
8000a35c:	08 92       	mov	r2,r4
8000a35e:	c9 c8       	rjmp	8000a496 <__sfvwrite_r+0x1ca>
8000a360:	06 96       	mov	r6,r3
8000a362:	08 91       	mov	r1,r4
8000a364:	c0 48       	rjmp	8000a36c <__sfvwrite_r+0xa0>
8000a366:	60 03       	ld.w	r3,r0[0x0]
8000a368:	60 16       	ld.w	r6,r0[0x4]
8000a36a:	2f 80       	sub	r0,-8
8000a36c:	58 06       	cp.w	r6,0
8000a36e:	cf c0       	breq	8000a366 <__sfvwrite_r+0x9a>
8000a370:	8e 68       	ld.sh	r8,r7[0xc]
8000a372:	6e 24       	ld.w	r4,r7[0x8]
8000a374:	10 99       	mov	r9,r8
8000a376:	e2 19 02 00 	andl	r9,0x200,COH
8000a37a:	c5 50       	breq	8000a424 <__sfvwrite_r+0x158>
8000a37c:	08 36       	cp.w	r6,r4
8000a37e:	c4 43       	brcs	8000a406 <__sfvwrite_r+0x13a>
8000a380:	10 99       	mov	r9,r8
8000a382:	e2 19 04 80 	andl	r9,0x480,COH
8000a386:	c4 00       	breq	8000a406 <__sfvwrite_r+0x13a>
8000a388:	6e 4b       	ld.w	r11,r7[0x10]
8000a38a:	6e 09       	ld.w	r9,r7[0x0]
8000a38c:	16 19       	sub	r9,r11
8000a38e:	50 09       	stdsp	sp[0x0],r9
8000a390:	6e 59       	ld.w	r9,r7[0x14]
8000a392:	10 9c       	mov	r12,r8
8000a394:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a398:	30 28       	mov	r8,2
8000a39a:	f4 08 0c 08 	divs	r8,r10,r8
8000a39e:	fa e9 00 04 	st.d	sp[4],r8
8000a3a2:	10 94       	mov	r4,r8
8000a3a4:	40 09       	lddsp	r9,sp[0x0]
8000a3a6:	e2 1c 04 00 	andl	r12,0x400,COH
8000a3aa:	2f f9       	sub	r9,-1
8000a3ac:	0c 09       	add	r9,r6
8000a3ae:	12 38       	cp.w	r8,r9
8000a3b0:	f2 04 17 30 	movlo	r4,r9
8000a3b4:	58 0c       	cp.w	r12,0
8000a3b6:	c1 10       	breq	8000a3d8 <__sfvwrite_r+0x10c>
8000a3b8:	08 9b       	mov	r11,r4
8000a3ba:	0a 9c       	mov	r12,r5
8000a3bc:	fe b0 e0 6c 	rcall	80006494 <_malloc_r>
8000a3c0:	18 92       	mov	r2,r12
8000a3c2:	c1 40       	breq	8000a3ea <__sfvwrite_r+0x11e>
8000a3c4:	40 0a       	lddsp	r10,sp[0x0]
8000a3c6:	6e 4b       	ld.w	r11,r7[0x10]
8000a3c8:	fe b0 e2 82 	rcall	800068cc <memcpy>
8000a3cc:	8e 68       	ld.sh	r8,r7[0xc]
8000a3ce:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a3d2:	a7 b8       	sbr	r8,0x7
8000a3d4:	ae 68       	st.h	r7[0xc],r8
8000a3d6:	c0 d8       	rjmp	8000a3f0 <__sfvwrite_r+0x124>
8000a3d8:	08 9a       	mov	r10,r4
8000a3da:	0a 9c       	mov	r12,r5
8000a3dc:	fe b0 e3 24 	rcall	80006a24 <_realloc_r>
8000a3e0:	18 92       	mov	r2,r12
8000a3e2:	c0 71       	brne	8000a3f0 <__sfvwrite_r+0x124>
8000a3e4:	6e 4b       	ld.w	r11,r7[0x10]
8000a3e6:	0a 9c       	mov	r12,r5
8000a3e8:	ca ce       	rcall	8000a140 <_free_r>
8000a3ea:	30 c8       	mov	r8,12
8000a3ec:	8b 38       	st.w	r5[0xc],r8
8000a3ee:	cb 18       	rjmp	8000a550 <__sfvwrite_r+0x284>
8000a3f0:	40 0a       	lddsp	r10,sp[0x0]
8000a3f2:	40 09       	lddsp	r9,sp[0x0]
8000a3f4:	e8 0a 01 0a 	sub	r10,r4,r10
8000a3f8:	e4 09 00 08 	add	r8,r2,r9
8000a3fc:	8f 54       	st.w	r7[0x14],r4
8000a3fe:	8f 2a       	st.w	r7[0x8],r10
8000a400:	8f 08       	st.w	r7[0x0],r8
8000a402:	8f 42       	st.w	r7[0x10],r2
8000a404:	0c 94       	mov	r4,r6
8000a406:	08 36       	cp.w	r6,r4
8000a408:	ec 04 17 30 	movlo	r4,r6
8000a40c:	06 9b       	mov	r11,r3
8000a40e:	08 9a       	mov	r10,r4
8000a410:	6e 0c       	ld.w	r12,r7[0x0]
8000a412:	c3 ad       	rcall	8000a686 <memmove>
8000a414:	6e 08       	ld.w	r8,r7[0x0]
8000a416:	08 08       	add	r8,r4
8000a418:	8f 08       	st.w	r7[0x0],r8
8000a41a:	6e 28       	ld.w	r8,r7[0x8]
8000a41c:	08 18       	sub	r8,r4
8000a41e:	0c 94       	mov	r4,r6
8000a420:	8f 28       	st.w	r7[0x8],r8
8000a422:	c2 e8       	rjmp	8000a47e <__sfvwrite_r+0x1b2>
8000a424:	08 36       	cp.w	r6,r4
8000a426:	5f ba       	srhi	r10
8000a428:	6e 0c       	ld.w	r12,r7[0x0]
8000a42a:	6e 48       	ld.w	r8,r7[0x10]
8000a42c:	10 3c       	cp.w	r12,r8
8000a42e:	5f b8       	srhi	r8
8000a430:	f5 e8 00 08 	and	r8,r10,r8
8000a434:	f2 08 18 00 	cp.b	r8,r9
8000a438:	c0 d0       	breq	8000a452 <__sfvwrite_r+0x186>
8000a43a:	06 9b       	mov	r11,r3
8000a43c:	08 9a       	mov	r10,r4
8000a43e:	c2 4d       	rcall	8000a686 <memmove>
8000a440:	6e 08       	ld.w	r8,r7[0x0]
8000a442:	08 08       	add	r8,r4
8000a444:	0e 9b       	mov	r11,r7
8000a446:	8f 08       	st.w	r7[0x0],r8
8000a448:	0a 9c       	mov	r12,r5
8000a44a:	fe b0 fd 09 	rcall	80009e5c <_fflush_r>
8000a44e:	c1 80       	breq	8000a47e <__sfvwrite_r+0x1b2>
8000a450:	c8 08       	rjmp	8000a550 <__sfvwrite_r+0x284>
8000a452:	6e 59       	ld.w	r9,r7[0x14]
8000a454:	12 36       	cp.w	r6,r9
8000a456:	c0 a3       	brcs	8000a46a <__sfvwrite_r+0x19e>
8000a458:	6e a8       	ld.w	r8,r7[0x28]
8000a45a:	06 9a       	mov	r10,r3
8000a45c:	6e 8b       	ld.w	r11,r7[0x20]
8000a45e:	0a 9c       	mov	r12,r5
8000a460:	5d 18       	icall	r8
8000a462:	18 94       	mov	r4,r12
8000a464:	e0 89 00 0d 	brgt	8000a47e <__sfvwrite_r+0x1b2>
8000a468:	c7 48       	rjmp	8000a550 <__sfvwrite_r+0x284>
8000a46a:	0c 9a       	mov	r10,r6
8000a46c:	06 9b       	mov	r11,r3
8000a46e:	c0 cd       	rcall	8000a686 <memmove>
8000a470:	6e 08       	ld.w	r8,r7[0x0]
8000a472:	0c 08       	add	r8,r6
8000a474:	0c 94       	mov	r4,r6
8000a476:	8f 08       	st.w	r7[0x0],r8
8000a478:	6e 28       	ld.w	r8,r7[0x8]
8000a47a:	0c 18       	sub	r8,r6
8000a47c:	8f 28       	st.w	r7[0x8],r8
8000a47e:	62 28       	ld.w	r8,r1[0x8]
8000a480:	08 18       	sub	r8,r4
8000a482:	83 28       	st.w	r1[0x8],r8
8000a484:	c6 b0       	breq	8000a55a <__sfvwrite_r+0x28e>
8000a486:	08 16       	sub	r6,r4
8000a488:	08 03       	add	r3,r4
8000a48a:	c7 1b       	rjmp	8000a36c <__sfvwrite_r+0xa0>
8000a48c:	60 03       	ld.w	r3,r0[0x0]
8000a48e:	60 11       	ld.w	r1,r0[0x4]
8000a490:	30 08       	mov	r8,0
8000a492:	2f 80       	sub	r0,-8
8000a494:	50 08       	stdsp	sp[0x0],r8
8000a496:	58 01       	cp.w	r1,0
8000a498:	cf a0       	breq	8000a48c <__sfvwrite_r+0x1c0>
8000a49a:	40 0a       	lddsp	r10,sp[0x0]
8000a49c:	58 0a       	cp.w	r10,0
8000a49e:	c1 41       	brne	8000a4c6 <__sfvwrite_r+0x1fa>
8000a4a0:	e2 c6 ff ff 	sub	r6,r1,-1
8000a4a4:	02 9a       	mov	r10,r1
8000a4a6:	30 ab       	mov	r11,10
8000a4a8:	06 9c       	mov	r12,r3
8000a4aa:	ce 3c       	rcall	8000a670 <memchr>
8000a4ac:	f8 c8 ff ff 	sub	r8,r12,-1
8000a4b0:	58 0c       	cp.w	r12,0
8000a4b2:	f1 d3 e1 16 	subne	r6,r8,r3
8000a4b6:	f9 b9 01 01 	movne	r9,1
8000a4ba:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a4be:	f9 b8 00 01 	moveq	r8,1
8000a4c2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a4c6:	02 36       	cp.w	r6,r1
8000a4c8:	ec 04 17 80 	movls	r4,r6
8000a4cc:	e2 04 17 b0 	movhi	r4,r1
8000a4d0:	6e 59       	ld.w	r9,r7[0x14]
8000a4d2:	6e 25       	ld.w	r5,r7[0x8]
8000a4d4:	f2 05 00 05 	add	r5,r9,r5
8000a4d8:	0a 34       	cp.w	r4,r5
8000a4da:	5f 9a       	srgt	r10
8000a4dc:	6e 0c       	ld.w	r12,r7[0x0]
8000a4de:	6e 48       	ld.w	r8,r7[0x10]
8000a4e0:	10 3c       	cp.w	r12,r8
8000a4e2:	5f b8       	srhi	r8
8000a4e4:	f5 e8 00 08 	and	r8,r10,r8
8000a4e8:	30 0a       	mov	r10,0
8000a4ea:	f4 08 18 00 	cp.b	r8,r10
8000a4ee:	c0 d0       	breq	8000a508 <__sfvwrite_r+0x23c>
8000a4f0:	06 9b       	mov	r11,r3
8000a4f2:	0a 9a       	mov	r10,r5
8000a4f4:	cc 9c       	rcall	8000a686 <memmove>
8000a4f6:	6e 08       	ld.w	r8,r7[0x0]
8000a4f8:	0a 08       	add	r8,r5
8000a4fa:	0e 9b       	mov	r11,r7
8000a4fc:	8f 08       	st.w	r7[0x0],r8
8000a4fe:	40 1c       	lddsp	r12,sp[0x4]
8000a500:	fe b0 fc ae 	rcall	80009e5c <_fflush_r>
8000a504:	c1 70       	breq	8000a532 <__sfvwrite_r+0x266>
8000a506:	c2 58       	rjmp	8000a550 <__sfvwrite_r+0x284>
8000a508:	12 34       	cp.w	r4,r9
8000a50a:	c0 a5       	brlt	8000a51e <__sfvwrite_r+0x252>
8000a50c:	6e a8       	ld.w	r8,r7[0x28]
8000a50e:	06 9a       	mov	r10,r3
8000a510:	6e 8b       	ld.w	r11,r7[0x20]
8000a512:	40 1c       	lddsp	r12,sp[0x4]
8000a514:	5d 18       	icall	r8
8000a516:	18 95       	mov	r5,r12
8000a518:	e0 89 00 0d 	brgt	8000a532 <__sfvwrite_r+0x266>
8000a51c:	c1 a8       	rjmp	8000a550 <__sfvwrite_r+0x284>
8000a51e:	08 9a       	mov	r10,r4
8000a520:	06 9b       	mov	r11,r3
8000a522:	cb 2c       	rcall	8000a686 <memmove>
8000a524:	6e 08       	ld.w	r8,r7[0x0]
8000a526:	08 08       	add	r8,r4
8000a528:	08 95       	mov	r5,r4
8000a52a:	8f 08       	st.w	r7[0x0],r8
8000a52c:	6e 28       	ld.w	r8,r7[0x8]
8000a52e:	08 18       	sub	r8,r4
8000a530:	8f 28       	st.w	r7[0x8],r8
8000a532:	0a 16       	sub	r6,r5
8000a534:	c0 71       	brne	8000a542 <__sfvwrite_r+0x276>
8000a536:	0e 9b       	mov	r11,r7
8000a538:	40 1c       	lddsp	r12,sp[0x4]
8000a53a:	fe b0 fc 91 	rcall	80009e5c <_fflush_r>
8000a53e:	c0 91       	brne	8000a550 <__sfvwrite_r+0x284>
8000a540:	50 06       	stdsp	sp[0x0],r6
8000a542:	64 28       	ld.w	r8,r2[0x8]
8000a544:	0a 18       	sub	r8,r5
8000a546:	85 28       	st.w	r2[0x8],r8
8000a548:	c0 90       	breq	8000a55a <__sfvwrite_r+0x28e>
8000a54a:	0a 11       	sub	r1,r5
8000a54c:	0a 03       	add	r3,r5
8000a54e:	ca 4b       	rjmp	8000a496 <__sfvwrite_r+0x1ca>
8000a550:	8e 68       	ld.sh	r8,r7[0xc]
8000a552:	a7 a8       	sbr	r8,0x6
8000a554:	ae 68       	st.h	r7[0xc],r8
8000a556:	3f fc       	mov	r12,-1
8000a558:	c0 28       	rjmp	8000a55c <__sfvwrite_r+0x290>
8000a55a:	30 0c       	mov	r12,0
8000a55c:	2f dd       	sub	sp,-12
8000a55e:	d8 32       	popm	r0-r7,pc

8000a560 <_fwalk>:
8000a560:	d4 31       	pushm	r0-r7,lr
8000a562:	30 05       	mov	r5,0
8000a564:	16 91       	mov	r1,r11
8000a566:	f8 c7 ff 28 	sub	r7,r12,-216
8000a56a:	0a 92       	mov	r2,r5
8000a56c:	fe b0 fc fe 	rcall	80009f68 <__sfp_lock_acquire>
8000a570:	3f f3       	mov	r3,-1
8000a572:	c1 68       	rjmp	8000a59e <_fwalk+0x3e>
8000a574:	6e 26       	ld.w	r6,r7[0x8]
8000a576:	6e 14       	ld.w	r4,r7[0x4]
8000a578:	2f 46       	sub	r6,-12
8000a57a:	c0 c8       	rjmp	8000a592 <_fwalk+0x32>
8000a57c:	8c 08       	ld.sh	r8,r6[0x0]
8000a57e:	e4 08 19 00 	cp.h	r8,r2
8000a582:	c0 70       	breq	8000a590 <_fwalk+0x30>
8000a584:	8c 18       	ld.sh	r8,r6[0x2]
8000a586:	e6 08 19 00 	cp.h	r8,r3
8000a58a:	c0 30       	breq	8000a590 <_fwalk+0x30>
8000a58c:	5d 11       	icall	r1
8000a58e:	18 45       	or	r5,r12
8000a590:	2a 46       	sub	r6,-92
8000a592:	20 14       	sub	r4,1
8000a594:	ec cc 00 0c 	sub	r12,r6,12
8000a598:	58 04       	cp.w	r4,0
8000a59a:	cf 14       	brge	8000a57c <_fwalk+0x1c>
8000a59c:	6e 07       	ld.w	r7,r7[0x0]
8000a59e:	58 07       	cp.w	r7,0
8000a5a0:	ce a1       	brne	8000a574 <_fwalk+0x14>
8000a5a2:	fe b0 fc e4 	rcall	80009f6a <__sfp_lock_release>
8000a5a6:	0a 9c       	mov	r12,r5
8000a5a8:	d8 32       	popm	r0-r7,pc
8000a5aa:	d7 03       	nop

8000a5ac <_localeconv_r>:
8000a5ac:	fe cc d5 dc 	sub	r12,pc,-10788
8000a5b0:	5e fc       	retal	r12
8000a5b2:	d7 03       	nop

8000a5b4 <__smakebuf_r>:
8000a5b4:	d4 21       	pushm	r4-r7,lr
8000a5b6:	20 fd       	sub	sp,60
8000a5b8:	96 68       	ld.sh	r8,r11[0xc]
8000a5ba:	16 97       	mov	r7,r11
8000a5bc:	18 96       	mov	r6,r12
8000a5be:	e2 18 00 02 	andl	r8,0x2,COH
8000a5c2:	c3 d1       	brne	8000a63c <__smakebuf_r+0x88>
8000a5c4:	96 7b       	ld.sh	r11,r11[0xe]
8000a5c6:	f0 0b 19 00 	cp.h	r11,r8
8000a5ca:	c0 55       	brlt	8000a5d4 <__smakebuf_r+0x20>
8000a5cc:	1a 9a       	mov	r10,sp
8000a5ce:	e0 a0 04 81 	rcall	8000aed0 <_fstat_r>
8000a5d2:	c0 f4       	brge	8000a5f0 <__smakebuf_r+0x3c>
8000a5d4:	8e 65       	ld.sh	r5,r7[0xc]
8000a5d6:	0a 98       	mov	r8,r5
8000a5d8:	ab b8       	sbr	r8,0xb
8000a5da:	e2 15 00 80 	andl	r5,0x80,COH
8000a5de:	ae 68       	st.h	r7[0xc],r8
8000a5e0:	30 04       	mov	r4,0
8000a5e2:	e0 68 04 00 	mov	r8,1024
8000a5e6:	f9 b5 01 40 	movne	r5,64
8000a5ea:	f0 05 17 00 	moveq	r5,r8
8000a5ee:	c1 c8       	rjmp	8000a626 <__smakebuf_r+0x72>
8000a5f0:	40 18       	lddsp	r8,sp[0x4]
8000a5f2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a5f6:	e0 48 20 00 	cp.w	r8,8192
8000a5fa:	5f 04       	sreq	r4
8000a5fc:	e0 48 80 00 	cp.w	r8,32768
8000a600:	c0 e1       	brne	8000a61c <__smakebuf_r+0x68>
8000a602:	6e b9       	ld.w	r9,r7[0x2c]
8000a604:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a608:	10 39       	cp.w	r9,r8
8000a60a:	c0 91       	brne	8000a61c <__smakebuf_r+0x68>
8000a60c:	8e 68       	ld.sh	r8,r7[0xc]
8000a60e:	e0 65 04 00 	mov	r5,1024
8000a612:	ab a8       	sbr	r8,0xa
8000a614:	ef 45 00 50 	st.w	r7[80],r5
8000a618:	ae 68       	st.h	r7[0xc],r8
8000a61a:	c0 68       	rjmp	8000a626 <__smakebuf_r+0x72>
8000a61c:	8e 68       	ld.sh	r8,r7[0xc]
8000a61e:	e0 65 04 00 	mov	r5,1024
8000a622:	ab b8       	sbr	r8,0xb
8000a624:	ae 68       	st.h	r7[0xc],r8
8000a626:	0a 9b       	mov	r11,r5
8000a628:	0c 9c       	mov	r12,r6
8000a62a:	fe b0 df 35 	rcall	80006494 <_malloc_r>
8000a62e:	8e 68       	ld.sh	r8,r7[0xc]
8000a630:	c0 d1       	brne	8000a64a <__smakebuf_r+0x96>
8000a632:	ed b8 00 09 	bld	r8,0x9
8000a636:	c1 b0       	breq	8000a66c <__smakebuf_r+0xb8>
8000a638:	a1 b8       	sbr	r8,0x1
8000a63a:	ae 68       	st.h	r7[0xc],r8
8000a63c:	ee c8 ff b9 	sub	r8,r7,-71
8000a640:	8f 48       	st.w	r7[0x10],r8
8000a642:	8f 08       	st.w	r7[0x0],r8
8000a644:	30 18       	mov	r8,1
8000a646:	8f 58       	st.w	r7[0x14],r8
8000a648:	c1 28       	rjmp	8000a66c <__smakebuf_r+0xb8>
8000a64a:	a7 b8       	sbr	r8,0x7
8000a64c:	8f 4c       	st.w	r7[0x10],r12
8000a64e:	ae 68       	st.h	r7[0xc],r8
8000a650:	8f 55       	st.w	r7[0x14],r5
8000a652:	fe c8 06 e6 	sub	r8,pc,1766
8000a656:	8f 0c       	st.w	r7[0x0],r12
8000a658:	8d a8       	st.w	r6[0x28],r8
8000a65a:	58 04       	cp.w	r4,0
8000a65c:	c0 80       	breq	8000a66c <__smakebuf_r+0xb8>
8000a65e:	8e 7c       	ld.sh	r12,r7[0xe]
8000a660:	fe b0 e3 94 	rcall	80006d88 <isatty>
8000a664:	c0 40       	breq	8000a66c <__smakebuf_r+0xb8>
8000a666:	8e 68       	ld.sh	r8,r7[0xc]
8000a668:	a1 a8       	sbr	r8,0x0
8000a66a:	ae 68       	st.h	r7[0xc],r8
8000a66c:	2f 1d       	sub	sp,-60
8000a66e:	d8 22       	popm	r4-r7,pc

8000a670 <memchr>:
8000a670:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a674:	c0 68       	rjmp	8000a680 <memchr+0x10>
8000a676:	20 1a       	sub	r10,1
8000a678:	19 88       	ld.ub	r8,r12[0x0]
8000a67a:	16 38       	cp.w	r8,r11
8000a67c:	5e 0c       	reteq	r12
8000a67e:	2f fc       	sub	r12,-1
8000a680:	58 0a       	cp.w	r10,0
8000a682:	cf a1       	brne	8000a676 <memchr+0x6>
8000a684:	5e fa       	retal	r10

8000a686 <memmove>:
8000a686:	d4 01       	pushm	lr
8000a688:	18 3b       	cp.w	r11,r12
8000a68a:	c1 92       	brcc	8000a6bc <memmove+0x36>
8000a68c:	f6 0a 00 09 	add	r9,r11,r10
8000a690:	12 3c       	cp.w	r12,r9
8000a692:	c1 52       	brcc	8000a6bc <memmove+0x36>
8000a694:	f8 0a 00 0b 	add	r11,r12,r10
8000a698:	30 08       	mov	r8,0
8000a69a:	c0 68       	rjmp	8000a6a6 <memmove+0x20>
8000a69c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a6a0:	20 1a       	sub	r10,1
8000a6a2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a6a6:	20 18       	sub	r8,1
8000a6a8:	58 0a       	cp.w	r10,0
8000a6aa:	cf 91       	brne	8000a69c <memmove+0x16>
8000a6ac:	d8 02       	popm	pc
8000a6ae:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a6b2:	20 1a       	sub	r10,1
8000a6b4:	f8 08 0b 09 	st.b	r12[r8],r9
8000a6b8:	2f f8       	sub	r8,-1
8000a6ba:	c0 28       	rjmp	8000a6be <memmove+0x38>
8000a6bc:	30 08       	mov	r8,0
8000a6be:	58 0a       	cp.w	r10,0
8000a6c0:	cf 71       	brne	8000a6ae <memmove+0x28>
8000a6c2:	d8 02       	popm	pc

8000a6c4 <__hi0bits>:
8000a6c4:	18 98       	mov	r8,r12
8000a6c6:	e0 1c 00 00 	andl	r12,0x0
8000a6ca:	f0 09 15 10 	lsl	r9,r8,0x10
8000a6ce:	58 0c       	cp.w	r12,0
8000a6d0:	f2 08 17 00 	moveq	r8,r9
8000a6d4:	f9 bc 00 10 	moveq	r12,16
8000a6d8:	f9 bc 01 00 	movne	r12,0
8000a6dc:	10 9a       	mov	r10,r8
8000a6de:	f0 09 15 08 	lsl	r9,r8,0x8
8000a6e2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a6e6:	f7 bc 00 f8 	subeq	r12,-8
8000a6ea:	f2 08 17 00 	moveq	r8,r9
8000a6ee:	10 9a       	mov	r10,r8
8000a6f0:	f0 09 15 04 	lsl	r9,r8,0x4
8000a6f4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a6f8:	f7 bc 00 fc 	subeq	r12,-4
8000a6fc:	f2 08 17 00 	moveq	r8,r9
8000a700:	10 9a       	mov	r10,r8
8000a702:	f0 09 15 02 	lsl	r9,r8,0x2
8000a706:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a70a:	f7 bc 00 fe 	subeq	r12,-2
8000a70e:	f2 08 17 00 	moveq	r8,r9
8000a712:	58 08       	cp.w	r8,0
8000a714:	5e 5c       	retlt	r12
8000a716:	ed b8 00 1e 	bld	r8,0x1e
8000a71a:	f9 bc 01 20 	movne	r12,32
8000a71e:	f7 bc 00 ff 	subeq	r12,-1
8000a722:	5e fc       	retal	r12

8000a724 <__lo0bits>:
8000a724:	18 99       	mov	r9,r12
8000a726:	78 08       	ld.w	r8,r12[0x0]
8000a728:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a72c:	c1 50       	breq	8000a756 <__lo0bits+0x32>
8000a72e:	ed b8 00 00 	bld	r8,0x0
8000a732:	c0 21       	brne	8000a736 <__lo0bits+0x12>
8000a734:	5e fd       	retal	0
8000a736:	10 9b       	mov	r11,r8
8000a738:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a73c:	e2 1b 00 02 	andl	r11,0x2,COH
8000a740:	a3 88       	lsr	r8,0x2
8000a742:	58 0b       	cp.w	r11,0
8000a744:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a748:	f9 bc 01 01 	movne	r12,1
8000a74c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a750:	f9 bc 00 02 	moveq	r12,2
8000a754:	5e fc       	retal	r12
8000a756:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a75a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a75e:	58 0a       	cp.w	r10,0
8000a760:	f6 08 17 00 	moveq	r8,r11
8000a764:	f9 bc 00 10 	moveq	r12,16
8000a768:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a76c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a770:	58 0b       	cp.w	r11,0
8000a772:	f7 bc 00 f8 	subeq	r12,-8
8000a776:	f4 08 17 00 	moveq	r8,r10
8000a77a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a77e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a782:	58 0b       	cp.w	r11,0
8000a784:	f7 bc 00 fc 	subeq	r12,-4
8000a788:	f4 08 17 00 	moveq	r8,r10
8000a78c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a790:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a794:	58 0b       	cp.w	r11,0
8000a796:	f7 bc 00 fe 	subeq	r12,-2
8000a79a:	f4 08 17 00 	moveq	r8,r10
8000a79e:	ed b8 00 00 	bld	r8,0x0
8000a7a2:	c0 60       	breq	8000a7ae <__lo0bits+0x8a>
8000a7a4:	a1 98       	lsr	r8,0x1
8000a7a6:	c0 31       	brne	8000a7ac <__lo0bits+0x88>
8000a7a8:	32 0c       	mov	r12,32
8000a7aa:	5e fc       	retal	r12
8000a7ac:	2f fc       	sub	r12,-1
8000a7ae:	93 08       	st.w	r9[0x0],r8
8000a7b0:	5e fc       	retal	r12

8000a7b2 <__mcmp>:
8000a7b2:	d4 01       	pushm	lr
8000a7b4:	18 98       	mov	r8,r12
8000a7b6:	76 49       	ld.w	r9,r11[0x10]
8000a7b8:	78 4c       	ld.w	r12,r12[0x10]
8000a7ba:	12 1c       	sub	r12,r9
8000a7bc:	c1 31       	brne	8000a7e2 <__mcmp+0x30>
8000a7be:	2f b9       	sub	r9,-5
8000a7c0:	a3 69       	lsl	r9,0x2
8000a7c2:	12 0b       	add	r11,r9
8000a7c4:	f0 09 00 09 	add	r9,r8,r9
8000a7c8:	2e c8       	sub	r8,-20
8000a7ca:	13 4e       	ld.w	lr,--r9
8000a7cc:	17 4a       	ld.w	r10,--r11
8000a7ce:	14 3e       	cp.w	lr,r10
8000a7d0:	c0 60       	breq	8000a7dc <__mcmp+0x2a>
8000a7d2:	f9 bc 03 ff 	movlo	r12,-1
8000a7d6:	f9 bc 02 01 	movhs	r12,1
8000a7da:	d8 02       	popm	pc
8000a7dc:	10 39       	cp.w	r9,r8
8000a7de:	fe 9b ff f6 	brhi	8000a7ca <__mcmp+0x18>
8000a7e2:	d8 02       	popm	pc

8000a7e4 <_Bfree>:
8000a7e4:	d4 21       	pushm	r4-r7,lr
8000a7e6:	18 97       	mov	r7,r12
8000a7e8:	16 95       	mov	r5,r11
8000a7ea:	78 96       	ld.w	r6,r12[0x24]
8000a7ec:	58 06       	cp.w	r6,0
8000a7ee:	c0 91       	brne	8000a800 <_Bfree+0x1c>
8000a7f0:	31 0c       	mov	r12,16
8000a7f2:	fe b0 de 49 	rcall	80006484 <malloc>
8000a7f6:	99 36       	st.w	r12[0xc],r6
8000a7f8:	8f 9c       	st.w	r7[0x24],r12
8000a7fa:	99 16       	st.w	r12[0x4],r6
8000a7fc:	99 26       	st.w	r12[0x8],r6
8000a7fe:	99 06       	st.w	r12[0x0],r6
8000a800:	58 05       	cp.w	r5,0
8000a802:	c0 90       	breq	8000a814 <_Bfree+0x30>
8000a804:	6a 19       	ld.w	r9,r5[0x4]
8000a806:	6e 98       	ld.w	r8,r7[0x24]
8000a808:	70 38       	ld.w	r8,r8[0xc]
8000a80a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a80e:	8b 0a       	st.w	r5[0x0],r10
8000a810:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a814:	d8 22       	popm	r4-r7,pc
8000a816:	d7 03       	nop

8000a818 <_Balloc>:
8000a818:	d4 21       	pushm	r4-r7,lr
8000a81a:	18 97       	mov	r7,r12
8000a81c:	16 96       	mov	r6,r11
8000a81e:	78 95       	ld.w	r5,r12[0x24]
8000a820:	58 05       	cp.w	r5,0
8000a822:	c0 91       	brne	8000a834 <_Balloc+0x1c>
8000a824:	31 0c       	mov	r12,16
8000a826:	fe b0 de 2f 	rcall	80006484 <malloc>
8000a82a:	99 35       	st.w	r12[0xc],r5
8000a82c:	8f 9c       	st.w	r7[0x24],r12
8000a82e:	99 15       	st.w	r12[0x4],r5
8000a830:	99 25       	st.w	r12[0x8],r5
8000a832:	99 05       	st.w	r12[0x0],r5
8000a834:	6e 95       	ld.w	r5,r7[0x24]
8000a836:	6a 38       	ld.w	r8,r5[0xc]
8000a838:	58 08       	cp.w	r8,0
8000a83a:	c0 b1       	brne	8000a850 <_Balloc+0x38>
8000a83c:	31 0a       	mov	r10,16
8000a83e:	30 4b       	mov	r11,4
8000a840:	0e 9c       	mov	r12,r7
8000a842:	e0 a0 02 a7 	rcall	8000ad90 <_calloc_r>
8000a846:	8b 3c       	st.w	r5[0xc],r12
8000a848:	6e 98       	ld.w	r8,r7[0x24]
8000a84a:	70 3c       	ld.w	r12,r8[0xc]
8000a84c:	58 0c       	cp.w	r12,0
8000a84e:	c1 b0       	breq	8000a884 <_Balloc+0x6c>
8000a850:	6e 98       	ld.w	r8,r7[0x24]
8000a852:	70 38       	ld.w	r8,r8[0xc]
8000a854:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a858:	70 0c       	ld.w	r12,r8[0x0]
8000a85a:	58 0c       	cp.w	r12,0
8000a85c:	c0 40       	breq	8000a864 <_Balloc+0x4c>
8000a85e:	78 09       	ld.w	r9,r12[0x0]
8000a860:	91 09       	st.w	r8[0x0],r9
8000a862:	c0 e8       	rjmp	8000a87e <_Balloc+0x66>
8000a864:	0e 9c       	mov	r12,r7
8000a866:	30 17       	mov	r7,1
8000a868:	0e 9b       	mov	r11,r7
8000a86a:	ee 06 09 47 	lsl	r7,r7,r6
8000a86e:	ee ca ff fb 	sub	r10,r7,-5
8000a872:	a3 6a       	lsl	r10,0x2
8000a874:	e0 a0 02 8e 	rcall	8000ad90 <_calloc_r>
8000a878:	c0 60       	breq	8000a884 <_Balloc+0x6c>
8000a87a:	99 16       	st.w	r12[0x4],r6
8000a87c:	99 27       	st.w	r12[0x8],r7
8000a87e:	30 08       	mov	r8,0
8000a880:	99 38       	st.w	r12[0xc],r8
8000a882:	99 48       	st.w	r12[0x10],r8
8000a884:	d8 22       	popm	r4-r7,pc
8000a886:	d7 03       	nop

8000a888 <__d2b>:
8000a888:	d4 31       	pushm	r0-r7,lr
8000a88a:	20 2d       	sub	sp,8
8000a88c:	16 93       	mov	r3,r11
8000a88e:	12 96       	mov	r6,r9
8000a890:	10 95       	mov	r5,r8
8000a892:	14 92       	mov	r2,r10
8000a894:	30 1b       	mov	r11,1
8000a896:	cc 1f       	rcall	8000a818 <_Balloc>
8000a898:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a89c:	50 09       	stdsp	sp[0x0],r9
8000a89e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a8a2:	b5 a9       	sbr	r9,0x14
8000a8a4:	f0 01 16 14 	lsr	r1,r8,0x14
8000a8a8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a8ac:	18 94       	mov	r4,r12
8000a8ae:	58 02       	cp.w	r2,0
8000a8b0:	c1 d0       	breq	8000a8ea <__d2b+0x62>
8000a8b2:	fa cc ff f8 	sub	r12,sp,-8
8000a8b6:	18 d2       	st.w	--r12,r2
8000a8b8:	c3 6f       	rcall	8000a724 <__lo0bits>
8000a8ba:	40 18       	lddsp	r8,sp[0x4]
8000a8bc:	c0 d0       	breq	8000a8d6 <__d2b+0x4e>
8000a8be:	40 09       	lddsp	r9,sp[0x0]
8000a8c0:	f8 0a 11 20 	rsub	r10,r12,32
8000a8c4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a8c8:	f5 e8 10 08 	or	r8,r10,r8
8000a8cc:	89 58       	st.w	r4[0x14],r8
8000a8ce:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a8d2:	50 09       	stdsp	sp[0x0],r9
8000a8d4:	c0 28       	rjmp	8000a8d8 <__d2b+0x50>
8000a8d6:	89 58       	st.w	r4[0x14],r8
8000a8d8:	40 08       	lddsp	r8,sp[0x0]
8000a8da:	58 08       	cp.w	r8,0
8000a8dc:	f9 b3 01 02 	movne	r3,2
8000a8e0:	f9 b3 00 01 	moveq	r3,1
8000a8e4:	89 68       	st.w	r4[0x18],r8
8000a8e6:	89 43       	st.w	r4[0x10],r3
8000a8e8:	c0 88       	rjmp	8000a8f8 <__d2b+0x70>
8000a8ea:	1a 9c       	mov	r12,sp
8000a8ec:	c1 cf       	rcall	8000a724 <__lo0bits>
8000a8ee:	30 13       	mov	r3,1
8000a8f0:	40 08       	lddsp	r8,sp[0x0]
8000a8f2:	2e 0c       	sub	r12,-32
8000a8f4:	89 43       	st.w	r4[0x10],r3
8000a8f6:	89 58       	st.w	r4[0x14],r8
8000a8f8:	58 01       	cp.w	r1,0
8000a8fa:	c0 90       	breq	8000a90c <__d2b+0x84>
8000a8fc:	e2 c1 04 33 	sub	r1,r1,1075
8000a900:	18 01       	add	r1,r12
8000a902:	8d 01       	st.w	r6[0x0],r1
8000a904:	f8 0c 11 35 	rsub	r12,r12,53
8000a908:	8b 0c       	st.w	r5[0x0],r12
8000a90a:	c0 c8       	rjmp	8000a922 <__d2b+0x9a>
8000a90c:	e6 c8 ff fc 	sub	r8,r3,-4
8000a910:	f8 cc 04 32 	sub	r12,r12,1074
8000a914:	a5 73       	lsl	r3,0x5
8000a916:	8d 0c       	st.w	r6[0x0],r12
8000a918:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a91c:	cd 4e       	rcall	8000a6c4 <__hi0bits>
8000a91e:	18 13       	sub	r3,r12
8000a920:	8b 03       	st.w	r5[0x0],r3
8000a922:	08 9c       	mov	r12,r4
8000a924:	2f ed       	sub	sp,-8
8000a926:	d8 32       	popm	r0-r7,pc

8000a928 <__mdiff>:
8000a928:	d4 31       	pushm	r0-r7,lr
8000a92a:	74 48       	ld.w	r8,r10[0x10]
8000a92c:	76 45       	ld.w	r5,r11[0x10]
8000a92e:	16 97       	mov	r7,r11
8000a930:	14 96       	mov	r6,r10
8000a932:	10 15       	sub	r5,r8
8000a934:	c1 31       	brne	8000a95a <__mdiff+0x32>
8000a936:	2f b8       	sub	r8,-5
8000a938:	ee ce ff ec 	sub	lr,r7,-20
8000a93c:	a3 68       	lsl	r8,0x2
8000a93e:	f4 08 00 0b 	add	r11,r10,r8
8000a942:	ee 08 00 08 	add	r8,r7,r8
8000a946:	11 4a       	ld.w	r10,--r8
8000a948:	17 49       	ld.w	r9,--r11
8000a94a:	12 3a       	cp.w	r10,r9
8000a94c:	c0 30       	breq	8000a952 <__mdiff+0x2a>
8000a94e:	c0 e2       	brcc	8000a96a <__mdiff+0x42>
8000a950:	c0 78       	rjmp	8000a95e <__mdiff+0x36>
8000a952:	1c 38       	cp.w	r8,lr
8000a954:	fe 9b ff f9 	brhi	8000a946 <__mdiff+0x1e>
8000a958:	c4 98       	rjmp	8000a9ea <__mdiff+0xc2>
8000a95a:	58 05       	cp.w	r5,0
8000a95c:	c0 64       	brge	8000a968 <__mdiff+0x40>
8000a95e:	0e 98       	mov	r8,r7
8000a960:	30 15       	mov	r5,1
8000a962:	0c 97       	mov	r7,r6
8000a964:	10 96       	mov	r6,r8
8000a966:	c0 28       	rjmp	8000a96a <__mdiff+0x42>
8000a968:	30 05       	mov	r5,0
8000a96a:	6e 1b       	ld.w	r11,r7[0x4]
8000a96c:	c5 6f       	rcall	8000a818 <_Balloc>
8000a96e:	6e 49       	ld.w	r9,r7[0x10]
8000a970:	6c 44       	ld.w	r4,r6[0x10]
8000a972:	99 35       	st.w	r12[0xc],r5
8000a974:	2f b4       	sub	r4,-5
8000a976:	f2 c5 ff fb 	sub	r5,r9,-5
8000a97a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a97e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a982:	2e c6       	sub	r6,-20
8000a984:	2e c7       	sub	r7,-20
8000a986:	f8 c8 ff ec 	sub	r8,r12,-20
8000a98a:	30 0a       	mov	r10,0
8000a98c:	0f 0e       	ld.w	lr,r7++
8000a98e:	0d 0b       	ld.w	r11,r6++
8000a990:	fc 02 16 10 	lsr	r2,lr,0x10
8000a994:	f6 03 16 10 	lsr	r3,r11,0x10
8000a998:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a99c:	e4 03 01 03 	sub	r3,r2,r3
8000a9a0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9a4:	fc 0b 01 0b 	sub	r11,lr,r11
8000a9a8:	f6 0a 00 0a 	add	r10,r11,r10
8000a9ac:	b0 1a       	st.h	r8[0x2],r10
8000a9ae:	b1 4a       	asr	r10,0x10
8000a9b0:	e6 0a 00 0a 	add	r10,r3,r10
8000a9b4:	b0 0a       	st.h	r8[0x0],r10
8000a9b6:	2f c8       	sub	r8,-4
8000a9b8:	b1 4a       	asr	r10,0x10
8000a9ba:	08 36       	cp.w	r6,r4
8000a9bc:	ce 83       	brcs	8000a98c <__mdiff+0x64>
8000a9be:	c0 d8       	rjmp	8000a9d8 <__mdiff+0xb0>
8000a9c0:	0f 0b       	ld.w	r11,r7++
8000a9c2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a9c6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a9ca:	16 0a       	add	r10,r11
8000a9cc:	b0 1a       	st.h	r8[0x2],r10
8000a9ce:	b1 4a       	asr	r10,0x10
8000a9d0:	1c 0a       	add	r10,lr
8000a9d2:	b0 0a       	st.h	r8[0x0],r10
8000a9d4:	2f c8       	sub	r8,-4
8000a9d6:	b1 4a       	asr	r10,0x10
8000a9d8:	0a 37       	cp.w	r7,r5
8000a9da:	cf 33       	brcs	8000a9c0 <__mdiff+0x98>
8000a9dc:	c0 28       	rjmp	8000a9e0 <__mdiff+0xb8>
8000a9de:	20 19       	sub	r9,1
8000a9e0:	11 4a       	ld.w	r10,--r8
8000a9e2:	58 0a       	cp.w	r10,0
8000a9e4:	cf d0       	breq	8000a9de <__mdiff+0xb6>
8000a9e6:	99 49       	st.w	r12[0x10],r9
8000a9e8:	d8 32       	popm	r0-r7,pc
8000a9ea:	30 0b       	mov	r11,0
8000a9ec:	c1 6f       	rcall	8000a818 <_Balloc>
8000a9ee:	30 18       	mov	r8,1
8000a9f0:	99 48       	st.w	r12[0x10],r8
8000a9f2:	30 08       	mov	r8,0
8000a9f4:	99 58       	st.w	r12[0x14],r8
8000a9f6:	d8 32       	popm	r0-r7,pc

8000a9f8 <__lshift>:
8000a9f8:	d4 31       	pushm	r0-r7,lr
8000a9fa:	16 97       	mov	r7,r11
8000a9fc:	76 46       	ld.w	r6,r11[0x10]
8000a9fe:	f4 02 14 05 	asr	r2,r10,0x5
8000aa02:	2f f6       	sub	r6,-1
8000aa04:	14 93       	mov	r3,r10
8000aa06:	18 94       	mov	r4,r12
8000aa08:	04 06       	add	r6,r2
8000aa0a:	76 1b       	ld.w	r11,r11[0x4]
8000aa0c:	6e 28       	ld.w	r8,r7[0x8]
8000aa0e:	c0 38       	rjmp	8000aa14 <__lshift+0x1c>
8000aa10:	2f fb       	sub	r11,-1
8000aa12:	a1 78       	lsl	r8,0x1
8000aa14:	10 36       	cp.w	r6,r8
8000aa16:	fe 99 ff fd 	brgt	8000aa10 <__lshift+0x18>
8000aa1a:	08 9c       	mov	r12,r4
8000aa1c:	cf ee       	rcall	8000a818 <_Balloc>
8000aa1e:	30 09       	mov	r9,0
8000aa20:	18 95       	mov	r5,r12
8000aa22:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa26:	12 9a       	mov	r10,r9
8000aa28:	c0 38       	rjmp	8000aa2e <__lshift+0x36>
8000aa2a:	10 aa       	st.w	r8++,r10
8000aa2c:	2f f9       	sub	r9,-1
8000aa2e:	04 39       	cp.w	r9,r2
8000aa30:	cf d5       	brlt	8000aa2a <__lshift+0x32>
8000aa32:	6e 4b       	ld.w	r11,r7[0x10]
8000aa34:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aa38:	2f bb       	sub	r11,-5
8000aa3a:	ee c9 ff ec 	sub	r9,r7,-20
8000aa3e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aa42:	58 03       	cp.w	r3,0
8000aa44:	c1 30       	breq	8000aa6a <__lshift+0x72>
8000aa46:	e6 0c 11 20 	rsub	r12,r3,32
8000aa4a:	30 0a       	mov	r10,0
8000aa4c:	72 02       	ld.w	r2,r9[0x0]
8000aa4e:	e4 03 09 42 	lsl	r2,r2,r3
8000aa52:	04 4a       	or	r10,r2
8000aa54:	10 aa       	st.w	r8++,r10
8000aa56:	13 0a       	ld.w	r10,r9++
8000aa58:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aa5c:	16 39       	cp.w	r9,r11
8000aa5e:	cf 73       	brcs	8000aa4c <__lshift+0x54>
8000aa60:	91 0a       	st.w	r8[0x0],r10
8000aa62:	58 0a       	cp.w	r10,0
8000aa64:	c0 70       	breq	8000aa72 <__lshift+0x7a>
8000aa66:	2f f6       	sub	r6,-1
8000aa68:	c0 58       	rjmp	8000aa72 <__lshift+0x7a>
8000aa6a:	13 0a       	ld.w	r10,r9++
8000aa6c:	10 aa       	st.w	r8++,r10
8000aa6e:	16 39       	cp.w	r9,r11
8000aa70:	cf d3       	brcs	8000aa6a <__lshift+0x72>
8000aa72:	08 9c       	mov	r12,r4
8000aa74:	20 16       	sub	r6,1
8000aa76:	0e 9b       	mov	r11,r7
8000aa78:	8b 46       	st.w	r5[0x10],r6
8000aa7a:	cb 5e       	rcall	8000a7e4 <_Bfree>
8000aa7c:	0a 9c       	mov	r12,r5
8000aa7e:	d8 32       	popm	r0-r7,pc

8000aa80 <__multiply>:
8000aa80:	d4 31       	pushm	r0-r7,lr
8000aa82:	20 2d       	sub	sp,8
8000aa84:	76 49       	ld.w	r9,r11[0x10]
8000aa86:	74 48       	ld.w	r8,r10[0x10]
8000aa88:	16 96       	mov	r6,r11
8000aa8a:	14 95       	mov	r5,r10
8000aa8c:	10 39       	cp.w	r9,r8
8000aa8e:	ec 08 17 50 	movlt	r8,r6
8000aa92:	ea 06 17 50 	movlt	r6,r5
8000aa96:	f0 05 17 50 	movlt	r5,r8
8000aa9a:	6c 28       	ld.w	r8,r6[0x8]
8000aa9c:	76 43       	ld.w	r3,r11[0x10]
8000aa9e:	74 42       	ld.w	r2,r10[0x10]
8000aaa0:	76 1b       	ld.w	r11,r11[0x4]
8000aaa2:	e4 03 00 07 	add	r7,r2,r3
8000aaa6:	10 37       	cp.w	r7,r8
8000aaa8:	f7 bb 09 ff 	subgt	r11,-1
8000aaac:	cb 6e       	rcall	8000a818 <_Balloc>
8000aaae:	ee c4 ff fb 	sub	r4,r7,-5
8000aab2:	f8 c9 ff ec 	sub	r9,r12,-20
8000aab6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000aaba:	30 0a       	mov	r10,0
8000aabc:	12 98       	mov	r8,r9
8000aabe:	c0 28       	rjmp	8000aac2 <__multiply+0x42>
8000aac0:	10 aa       	st.w	r8++,r10
8000aac2:	08 38       	cp.w	r8,r4
8000aac4:	cf e3       	brcs	8000aac0 <__multiply+0x40>
8000aac6:	2f b3       	sub	r3,-5
8000aac8:	2f b2       	sub	r2,-5
8000aaca:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000aace:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000aad2:	ec cb ff ec 	sub	r11,r6,-20
8000aad6:	50 12       	stdsp	sp[0x4],r2
8000aad8:	ea ca ff ec 	sub	r10,r5,-20
8000aadc:	c4 48       	rjmp	8000ab64 <__multiply+0xe4>
8000aade:	94 95       	ld.uh	r5,r10[0x2]
8000aae0:	58 05       	cp.w	r5,0
8000aae2:	c2 00       	breq	8000ab22 <__multiply+0xa2>
8000aae4:	12 98       	mov	r8,r9
8000aae6:	16 96       	mov	r6,r11
8000aae8:	30 0e       	mov	lr,0
8000aaea:	50 09       	stdsp	sp[0x0],r9
8000aaec:	0d 02       	ld.w	r2,r6++
8000aaee:	e4 00 16 10 	lsr	r0,r2,0x10
8000aaf2:	70 01       	ld.w	r1,r8[0x0]
8000aaf4:	70 09       	ld.w	r9,r8[0x0]
8000aaf6:	b1 81       	lsr	r1,0x10
8000aaf8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000aafc:	e0 05 03 41 	mac	r1,r0,r5
8000ab00:	ab 32       	mul	r2,r5
8000ab02:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ab06:	00 02       	add	r2,r0
8000ab08:	e4 0e 00 0e 	add	lr,r2,lr
8000ab0c:	b0 1e       	st.h	r8[0x2],lr
8000ab0e:	b1 8e       	lsr	lr,0x10
8000ab10:	1c 01       	add	r1,lr
8000ab12:	b0 01       	st.h	r8[0x0],r1
8000ab14:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ab18:	2f c8       	sub	r8,-4
8000ab1a:	06 36       	cp.w	r6,r3
8000ab1c:	ce 83       	brcs	8000aaec <__multiply+0x6c>
8000ab1e:	40 09       	lddsp	r9,sp[0x0]
8000ab20:	91 0e       	st.w	r8[0x0],lr
8000ab22:	94 86       	ld.uh	r6,r10[0x0]
8000ab24:	58 06       	cp.w	r6,0
8000ab26:	c1 d0       	breq	8000ab60 <__multiply+0xe0>
8000ab28:	72 02       	ld.w	r2,r9[0x0]
8000ab2a:	12 98       	mov	r8,r9
8000ab2c:	16 9e       	mov	lr,r11
8000ab2e:	30 05       	mov	r5,0
8000ab30:	b0 12       	st.h	r8[0x2],r2
8000ab32:	1d 01       	ld.w	r1,lr++
8000ab34:	90 82       	ld.uh	r2,r8[0x0]
8000ab36:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ab3a:	ad 30       	mul	r0,r6
8000ab3c:	e0 02 00 02 	add	r2,r0,r2
8000ab40:	e4 05 00 05 	add	r5,r2,r5
8000ab44:	b0 05       	st.h	r8[0x0],r5
8000ab46:	b1 85       	lsr	r5,0x10
8000ab48:	b1 81       	lsr	r1,0x10
8000ab4a:	2f c8       	sub	r8,-4
8000ab4c:	ad 31       	mul	r1,r6
8000ab4e:	90 92       	ld.uh	r2,r8[0x2]
8000ab50:	e2 02 00 02 	add	r2,r1,r2
8000ab54:	0a 02       	add	r2,r5
8000ab56:	e4 05 16 10 	lsr	r5,r2,0x10
8000ab5a:	06 3e       	cp.w	lr,r3
8000ab5c:	ce a3       	brcs	8000ab30 <__multiply+0xb0>
8000ab5e:	91 02       	st.w	r8[0x0],r2
8000ab60:	2f ca       	sub	r10,-4
8000ab62:	2f c9       	sub	r9,-4
8000ab64:	40 18       	lddsp	r8,sp[0x4]
8000ab66:	10 3a       	cp.w	r10,r8
8000ab68:	cb b3       	brcs	8000aade <__multiply+0x5e>
8000ab6a:	c0 28       	rjmp	8000ab6e <__multiply+0xee>
8000ab6c:	20 17       	sub	r7,1
8000ab6e:	58 07       	cp.w	r7,0
8000ab70:	e0 8a 00 05 	brle	8000ab7a <__multiply+0xfa>
8000ab74:	09 48       	ld.w	r8,--r4
8000ab76:	58 08       	cp.w	r8,0
8000ab78:	cf a0       	breq	8000ab6c <__multiply+0xec>
8000ab7a:	99 47       	st.w	r12[0x10],r7
8000ab7c:	2f ed       	sub	sp,-8
8000ab7e:	d8 32       	popm	r0-r7,pc

8000ab80 <__i2b>:
8000ab80:	d4 21       	pushm	r4-r7,lr
8000ab82:	16 97       	mov	r7,r11
8000ab84:	30 1b       	mov	r11,1
8000ab86:	c4 9e       	rcall	8000a818 <_Balloc>
8000ab88:	30 19       	mov	r9,1
8000ab8a:	99 57       	st.w	r12[0x14],r7
8000ab8c:	99 49       	st.w	r12[0x10],r9
8000ab8e:	d8 22       	popm	r4-r7,pc

8000ab90 <__multadd>:
8000ab90:	d4 31       	pushm	r0-r7,lr
8000ab92:	30 08       	mov	r8,0
8000ab94:	12 95       	mov	r5,r9
8000ab96:	16 97       	mov	r7,r11
8000ab98:	18 96       	mov	r6,r12
8000ab9a:	76 44       	ld.w	r4,r11[0x10]
8000ab9c:	f6 c9 ff ec 	sub	r9,r11,-20
8000aba0:	72 0b       	ld.w	r11,r9[0x0]
8000aba2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000aba6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000abaa:	f4 0c 02 4c 	mul	r12,r10,r12
8000abae:	f4 0b 03 45 	mac	r5,r10,r11
8000abb2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000abb6:	b1 85       	lsr	r5,0x10
8000abb8:	18 05       	add	r5,r12
8000abba:	ea 0c 15 10 	lsl	r12,r5,0x10
8000abbe:	f8 0b 00 0b 	add	r11,r12,r11
8000abc2:	12 ab       	st.w	r9++,r11
8000abc4:	2f f8       	sub	r8,-1
8000abc6:	b1 85       	lsr	r5,0x10
8000abc8:	08 38       	cp.w	r8,r4
8000abca:	ce b5       	brlt	8000aba0 <__multadd+0x10>
8000abcc:	58 05       	cp.w	r5,0
8000abce:	c1 c0       	breq	8000ac06 <__multadd+0x76>
8000abd0:	6e 28       	ld.w	r8,r7[0x8]
8000abd2:	10 34       	cp.w	r4,r8
8000abd4:	c1 35       	brlt	8000abfa <__multadd+0x6a>
8000abd6:	6e 1b       	ld.w	r11,r7[0x4]
8000abd8:	0c 9c       	mov	r12,r6
8000abda:	2f fb       	sub	r11,-1
8000abdc:	c1 ee       	rcall	8000a818 <_Balloc>
8000abde:	6e 4a       	ld.w	r10,r7[0x10]
8000abe0:	ee cb ff f4 	sub	r11,r7,-12
8000abe4:	18 93       	mov	r3,r12
8000abe6:	2f ea       	sub	r10,-2
8000abe8:	2f 4c       	sub	r12,-12
8000abea:	a3 6a       	lsl	r10,0x2
8000abec:	fe b0 de 70 	rcall	800068cc <memcpy>
8000abf0:	0e 9b       	mov	r11,r7
8000abf2:	0c 9c       	mov	r12,r6
8000abf4:	fe b0 fd f8 	rcall	8000a7e4 <_Bfree>
8000abf8:	06 97       	mov	r7,r3
8000abfa:	e8 c8 ff ff 	sub	r8,r4,-1
8000abfe:	2f b4       	sub	r4,-5
8000ac00:	8f 48       	st.w	r7[0x10],r8
8000ac02:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ac06:	0e 9c       	mov	r12,r7
8000ac08:	d8 32       	popm	r0-r7,pc
8000ac0a:	d7 03       	nop

8000ac0c <__pow5mult>:
8000ac0c:	d4 31       	pushm	r0-r7,lr
8000ac0e:	14 96       	mov	r6,r10
8000ac10:	18 97       	mov	r7,r12
8000ac12:	16 94       	mov	r4,r11
8000ac14:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ac18:	c0 90       	breq	8000ac2a <__pow5mult+0x1e>
8000ac1a:	20 18       	sub	r8,1
8000ac1c:	fe c9 dc 10 	sub	r9,pc,-9200
8000ac20:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ac24:	30 09       	mov	r9,0
8000ac26:	cb 5f       	rcall	8000ab90 <__multadd>
8000ac28:	18 94       	mov	r4,r12
8000ac2a:	a3 46       	asr	r6,0x2
8000ac2c:	c3 40       	breq	8000ac94 <__pow5mult+0x88>
8000ac2e:	6e 95       	ld.w	r5,r7[0x24]
8000ac30:	58 05       	cp.w	r5,0
8000ac32:	c0 91       	brne	8000ac44 <__pow5mult+0x38>
8000ac34:	31 0c       	mov	r12,16
8000ac36:	fe b0 dc 27 	rcall	80006484 <malloc>
8000ac3a:	99 35       	st.w	r12[0xc],r5
8000ac3c:	8f 9c       	st.w	r7[0x24],r12
8000ac3e:	99 15       	st.w	r12[0x4],r5
8000ac40:	99 25       	st.w	r12[0x8],r5
8000ac42:	99 05       	st.w	r12[0x0],r5
8000ac44:	6e 93       	ld.w	r3,r7[0x24]
8000ac46:	66 25       	ld.w	r5,r3[0x8]
8000ac48:	58 05       	cp.w	r5,0
8000ac4a:	c0 c1       	brne	8000ac62 <__pow5mult+0x56>
8000ac4c:	e0 6b 02 71 	mov	r11,625
8000ac50:	0e 9c       	mov	r12,r7
8000ac52:	c9 7f       	rcall	8000ab80 <__i2b>
8000ac54:	87 2c       	st.w	r3[0x8],r12
8000ac56:	30 08       	mov	r8,0
8000ac58:	18 95       	mov	r5,r12
8000ac5a:	99 08       	st.w	r12[0x0],r8
8000ac5c:	c0 38       	rjmp	8000ac62 <__pow5mult+0x56>
8000ac5e:	06 9c       	mov	r12,r3
8000ac60:	18 95       	mov	r5,r12
8000ac62:	ed b6 00 00 	bld	r6,0x0
8000ac66:	c0 b1       	brne	8000ac7c <__pow5mult+0x70>
8000ac68:	08 9b       	mov	r11,r4
8000ac6a:	0a 9a       	mov	r10,r5
8000ac6c:	0e 9c       	mov	r12,r7
8000ac6e:	c0 9f       	rcall	8000aa80 <__multiply>
8000ac70:	08 9b       	mov	r11,r4
8000ac72:	18 93       	mov	r3,r12
8000ac74:	0e 9c       	mov	r12,r7
8000ac76:	06 94       	mov	r4,r3
8000ac78:	fe b0 fd b6 	rcall	8000a7e4 <_Bfree>
8000ac7c:	a1 56       	asr	r6,0x1
8000ac7e:	c0 b0       	breq	8000ac94 <__pow5mult+0x88>
8000ac80:	6a 03       	ld.w	r3,r5[0x0]
8000ac82:	58 03       	cp.w	r3,0
8000ac84:	ce d1       	brne	8000ac5e <__pow5mult+0x52>
8000ac86:	0a 9a       	mov	r10,r5
8000ac88:	0a 9b       	mov	r11,r5
8000ac8a:	0e 9c       	mov	r12,r7
8000ac8c:	cf ae       	rcall	8000aa80 <__multiply>
8000ac8e:	8b 0c       	st.w	r5[0x0],r12
8000ac90:	99 03       	st.w	r12[0x0],r3
8000ac92:	ce 7b       	rjmp	8000ac60 <__pow5mult+0x54>
8000ac94:	08 9c       	mov	r12,r4
8000ac96:	d8 32       	popm	r0-r7,pc

8000ac98 <__isinfd>:
8000ac98:	14 98       	mov	r8,r10
8000ac9a:	fc 19 7f f0 	movh	r9,0x7ff0
8000ac9e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000aca2:	f0 0b 11 00 	rsub	r11,r8,0
8000aca6:	f7 e8 10 08 	or	r8,r11,r8
8000acaa:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000acae:	f2 08 01 08 	sub	r8,r9,r8
8000acb2:	f0 0c 11 00 	rsub	r12,r8,0
8000acb6:	f9 e8 10 08 	or	r8,r12,r8
8000acba:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000acbe:	2f fc       	sub	r12,-1
8000acc0:	5e fc       	retal	r12

8000acc2 <__isnand>:
8000acc2:	14 98       	mov	r8,r10
8000acc4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000acc8:	f0 0c 11 00 	rsub	r12,r8,0
8000accc:	10 4c       	or	r12,r8
8000acce:	fc 18 7f f0 	movh	r8,0x7ff0
8000acd2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000acd6:	f0 0c 01 0c 	sub	r12,r8,r12
8000acda:	bf 9c       	lsr	r12,0x1f
8000acdc:	5e fc       	retal	r12
8000acde:	d7 03       	nop

8000ace0 <__sclose>:
8000ace0:	d4 01       	pushm	lr
8000ace2:	96 7b       	ld.sh	r11,r11[0xe]
8000ace4:	c8 2c       	rcall	8000ade8 <_close_r>
8000ace6:	d8 02       	popm	pc

8000ace8 <__sseek>:
8000ace8:	d4 21       	pushm	r4-r7,lr
8000acea:	16 97       	mov	r7,r11
8000acec:	96 7b       	ld.sh	r11,r11[0xe]
8000acee:	c0 3d       	rcall	8000aef4 <_lseek_r>
8000acf0:	8e 68       	ld.sh	r8,r7[0xc]
8000acf2:	10 99       	mov	r9,r8
8000acf4:	ad c8       	cbr	r8,0xc
8000acf6:	ad a9       	sbr	r9,0xc
8000acf8:	5b fc       	cp.w	r12,-1
8000acfa:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000acfe:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ad02:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ad06:	d8 22       	popm	r4-r7,pc

8000ad08 <__swrite>:
8000ad08:	d4 21       	pushm	r4-r7,lr
8000ad0a:	96 68       	ld.sh	r8,r11[0xc]
8000ad0c:	16 97       	mov	r7,r11
8000ad0e:	14 95       	mov	r5,r10
8000ad10:	12 94       	mov	r4,r9
8000ad12:	e2 18 01 00 	andl	r8,0x100,COH
8000ad16:	18 96       	mov	r6,r12
8000ad18:	c0 50       	breq	8000ad22 <__swrite+0x1a>
8000ad1a:	30 29       	mov	r9,2
8000ad1c:	30 0a       	mov	r10,0
8000ad1e:	96 7b       	ld.sh	r11,r11[0xe]
8000ad20:	ce ac       	rcall	8000aef4 <_lseek_r>
8000ad22:	8e 68       	ld.sh	r8,r7[0xc]
8000ad24:	ad c8       	cbr	r8,0xc
8000ad26:	08 99       	mov	r9,r4
8000ad28:	0a 9a       	mov	r10,r5
8000ad2a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ad2c:	0c 9c       	mov	r12,r6
8000ad2e:	ae 68       	st.h	r7[0xc],r8
8000ad30:	c1 cc       	rcall	8000ad68 <_write_r>
8000ad32:	d8 22       	popm	r4-r7,pc

8000ad34 <__sread>:
8000ad34:	d4 21       	pushm	r4-r7,lr
8000ad36:	16 97       	mov	r7,r11
8000ad38:	96 7b       	ld.sh	r11,r11[0xe]
8000ad3a:	cf 1c       	rcall	8000af1c <_read_r>
8000ad3c:	c0 65       	brlt	8000ad48 <__sread+0x14>
8000ad3e:	6f 58       	ld.w	r8,r7[0x54]
8000ad40:	18 08       	add	r8,r12
8000ad42:	ef 48 00 54 	st.w	r7[84],r8
8000ad46:	d8 22       	popm	r4-r7,pc
8000ad48:	8e 68       	ld.sh	r8,r7[0xc]
8000ad4a:	ad c8       	cbr	r8,0xc
8000ad4c:	ae 68       	st.h	r7[0xc],r8
8000ad4e:	d8 22       	popm	r4-r7,pc

8000ad50 <strlen>:
8000ad50:	30 09       	mov	r9,0
8000ad52:	18 98       	mov	r8,r12
8000ad54:	c0 28       	rjmp	8000ad58 <strlen+0x8>
8000ad56:	2f f8       	sub	r8,-1
8000ad58:	11 8a       	ld.ub	r10,r8[0x0]
8000ad5a:	f2 0a 18 00 	cp.b	r10,r9
8000ad5e:	cf c1       	brne	8000ad56 <strlen+0x6>
8000ad60:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad64:	5e fc       	retal	r12
8000ad66:	d7 03       	nop

8000ad68 <_write_r>:
8000ad68:	d4 21       	pushm	r4-r7,lr
8000ad6a:	16 98       	mov	r8,r11
8000ad6c:	18 97       	mov	r7,r12
8000ad6e:	10 9c       	mov	r12,r8
8000ad70:	30 08       	mov	r8,0
8000ad72:	14 9b       	mov	r11,r10
8000ad74:	e0 66 40 f0 	mov	r6,16624
8000ad78:	12 9a       	mov	r10,r9
8000ad7a:	8d 08       	st.w	r6[0x0],r8
8000ad7c:	fe b0 d1 ba 	rcall	800050f0 <_write>
8000ad80:	5b fc       	cp.w	r12,-1
8000ad82:	c0 51       	brne	8000ad8c <_write_r+0x24>
8000ad84:	6c 08       	ld.w	r8,r6[0x0]
8000ad86:	58 08       	cp.w	r8,0
8000ad88:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad8c:	d8 22       	popm	r4-r7,pc
8000ad8e:	d7 03       	nop

8000ad90 <_calloc_r>:
8000ad90:	d4 21       	pushm	r4-r7,lr
8000ad92:	f4 0b 02 4b 	mul	r11,r10,r11
8000ad96:	fe b0 db 7f 	rcall	80006494 <_malloc_r>
8000ad9a:	18 97       	mov	r7,r12
8000ad9c:	c2 30       	breq	8000ade2 <_calloc_r+0x52>
8000ad9e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ada2:	e0 1a ff fc 	andl	r10,0xfffc
8000ada6:	20 4a       	sub	r10,4
8000ada8:	e0 4a 00 24 	cp.w	r10,36
8000adac:	e0 8b 00 18 	brhi	8000addc <_calloc_r+0x4c>
8000adb0:	18 98       	mov	r8,r12
8000adb2:	59 3a       	cp.w	r10,19
8000adb4:	e0 88 00 0f 	brls	8000add2 <_calloc_r+0x42>
8000adb8:	30 09       	mov	r9,0
8000adba:	10 a9       	st.w	r8++,r9
8000adbc:	10 a9       	st.w	r8++,r9
8000adbe:	59 ba       	cp.w	r10,27
8000adc0:	e0 88 00 09 	brls	8000add2 <_calloc_r+0x42>
8000adc4:	10 a9       	st.w	r8++,r9
8000adc6:	10 a9       	st.w	r8++,r9
8000adc8:	e0 4a 00 24 	cp.w	r10,36
8000adcc:	c0 31       	brne	8000add2 <_calloc_r+0x42>
8000adce:	10 a9       	st.w	r8++,r9
8000add0:	10 a9       	st.w	r8++,r9
8000add2:	30 09       	mov	r9,0
8000add4:	10 a9       	st.w	r8++,r9
8000add6:	91 19       	st.w	r8[0x4],r9
8000add8:	91 09       	st.w	r8[0x0],r9
8000adda:	c0 48       	rjmp	8000ade2 <_calloc_r+0x52>
8000addc:	30 0b       	mov	r11,0
8000adde:	fe b0 de 1b 	rcall	80006a14 <memset>
8000ade2:	0e 9c       	mov	r12,r7
8000ade4:	d8 22       	popm	r4-r7,pc
8000ade6:	d7 03       	nop

8000ade8 <_close_r>:
8000ade8:	d4 21       	pushm	r4-r7,lr
8000adea:	30 08       	mov	r8,0
8000adec:	18 97       	mov	r7,r12
8000adee:	e0 66 40 f0 	mov	r6,16624
8000adf2:	16 9c       	mov	r12,r11
8000adf4:	8d 08       	st.w	r6[0x0],r8
8000adf6:	fe b0 df b5 	rcall	80006d60 <_close>
8000adfa:	5b fc       	cp.w	r12,-1
8000adfc:	c0 51       	brne	8000ae06 <_close_r+0x1e>
8000adfe:	6c 08       	ld.w	r8,r6[0x0]
8000ae00:	58 08       	cp.w	r8,0
8000ae02:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae06:	d8 22       	popm	r4-r7,pc

8000ae08 <_fclose_r>:
8000ae08:	d4 21       	pushm	r4-r7,lr
8000ae0a:	18 96       	mov	r6,r12
8000ae0c:	16 97       	mov	r7,r11
8000ae0e:	58 0b       	cp.w	r11,0
8000ae10:	c0 31       	brne	8000ae16 <_fclose_r+0xe>
8000ae12:	16 95       	mov	r5,r11
8000ae14:	c5 38       	rjmp	8000aeba <_fclose_r+0xb2>
8000ae16:	fe b0 f8 a9 	rcall	80009f68 <__sfp_lock_acquire>
8000ae1a:	58 06       	cp.w	r6,0
8000ae1c:	c0 70       	breq	8000ae2a <_fclose_r+0x22>
8000ae1e:	6c 68       	ld.w	r8,r6[0x18]
8000ae20:	58 08       	cp.w	r8,0
8000ae22:	c0 41       	brne	8000ae2a <_fclose_r+0x22>
8000ae24:	0c 9c       	mov	r12,r6
8000ae26:	fe b0 f8 f3 	rcall	8000a00c <__sinit>
8000ae2a:	fe c8 de c2 	sub	r8,pc,-8510
8000ae2e:	10 37       	cp.w	r7,r8
8000ae30:	c0 31       	brne	8000ae36 <_fclose_r+0x2e>
8000ae32:	6c 07       	ld.w	r7,r6[0x0]
8000ae34:	c0 c8       	rjmp	8000ae4c <_fclose_r+0x44>
8000ae36:	fe c8 de ae 	sub	r8,pc,-8530
8000ae3a:	10 37       	cp.w	r7,r8
8000ae3c:	c0 31       	brne	8000ae42 <_fclose_r+0x3a>
8000ae3e:	6c 17       	ld.w	r7,r6[0x4]
8000ae40:	c0 68       	rjmp	8000ae4c <_fclose_r+0x44>
8000ae42:	fe c8 de 9a 	sub	r8,pc,-8550
8000ae46:	10 37       	cp.w	r7,r8
8000ae48:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae4c:	8e 69       	ld.sh	r9,r7[0xc]
8000ae4e:	30 08       	mov	r8,0
8000ae50:	f0 09 19 00 	cp.h	r9,r8
8000ae54:	c0 51       	brne	8000ae5e <_fclose_r+0x56>
8000ae56:	fe b0 f8 8a 	rcall	80009f6a <__sfp_lock_release>
8000ae5a:	30 05       	mov	r5,0
8000ae5c:	c2 f8       	rjmp	8000aeba <_fclose_r+0xb2>
8000ae5e:	0e 9b       	mov	r11,r7
8000ae60:	0c 9c       	mov	r12,r6
8000ae62:	fe b0 f7 fd 	rcall	80009e5c <_fflush_r>
8000ae66:	6e c8       	ld.w	r8,r7[0x30]
8000ae68:	18 95       	mov	r5,r12
8000ae6a:	58 08       	cp.w	r8,0
8000ae6c:	c0 60       	breq	8000ae78 <_fclose_r+0x70>
8000ae6e:	6e 8b       	ld.w	r11,r7[0x20]
8000ae70:	0c 9c       	mov	r12,r6
8000ae72:	5d 18       	icall	r8
8000ae74:	f9 b5 05 ff 	movlt	r5,-1
8000ae78:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7a:	ed b8 00 07 	bld	r8,0x7
8000ae7e:	c0 51       	brne	8000ae88 <_fclose_r+0x80>
8000ae80:	6e 4b       	ld.w	r11,r7[0x10]
8000ae82:	0c 9c       	mov	r12,r6
8000ae84:	fe b0 f9 5e 	rcall	8000a140 <_free_r>
8000ae88:	6e db       	ld.w	r11,r7[0x34]
8000ae8a:	58 0b       	cp.w	r11,0
8000ae8c:	c0 a0       	breq	8000aea0 <_fclose_r+0x98>
8000ae8e:	ee c8 ff bc 	sub	r8,r7,-68
8000ae92:	10 3b       	cp.w	r11,r8
8000ae94:	c0 40       	breq	8000ae9c <_fclose_r+0x94>
8000ae96:	0c 9c       	mov	r12,r6
8000ae98:	fe b0 f9 54 	rcall	8000a140 <_free_r>
8000ae9c:	30 08       	mov	r8,0
8000ae9e:	8f d8       	st.w	r7[0x34],r8
8000aea0:	6f 2b       	ld.w	r11,r7[0x48]
8000aea2:	58 0b       	cp.w	r11,0
8000aea4:	c0 70       	breq	8000aeb2 <_fclose_r+0xaa>
8000aea6:	0c 9c       	mov	r12,r6
8000aea8:	fe b0 f9 4c 	rcall	8000a140 <_free_r>
8000aeac:	30 08       	mov	r8,0
8000aeae:	ef 48 00 48 	st.w	r7[72],r8
8000aeb2:	30 08       	mov	r8,0
8000aeb4:	ae 68       	st.h	r7[0xc],r8
8000aeb6:	fe b0 f8 5a 	rcall	80009f6a <__sfp_lock_release>
8000aeba:	0a 9c       	mov	r12,r5
8000aebc:	d8 22       	popm	r4-r7,pc
8000aebe:	d7 03       	nop

8000aec0 <fclose>:
8000aec0:	d4 01       	pushm	lr
8000aec2:	e0 68 0a 2c 	mov	r8,2604
8000aec6:	18 9b       	mov	r11,r12
8000aec8:	70 0c       	ld.w	r12,r8[0x0]
8000aeca:	c9 ff       	rcall	8000ae08 <_fclose_r>
8000aecc:	d8 02       	popm	pc
8000aece:	d7 03       	nop

8000aed0 <_fstat_r>:
8000aed0:	d4 21       	pushm	r4-r7,lr
8000aed2:	16 98       	mov	r8,r11
8000aed4:	18 97       	mov	r7,r12
8000aed6:	10 9c       	mov	r12,r8
8000aed8:	30 08       	mov	r8,0
8000aeda:	e0 66 40 f0 	mov	r6,16624
8000aede:	14 9b       	mov	r11,r10
8000aee0:	8d 08       	st.w	r6[0x0],r8
8000aee2:	fe b0 df 67 	rcall	80006db0 <_fstat>
8000aee6:	5b fc       	cp.w	r12,-1
8000aee8:	c0 51       	brne	8000aef2 <_fstat_r+0x22>
8000aeea:	6c 08       	ld.w	r8,r6[0x0]
8000aeec:	58 08       	cp.w	r8,0
8000aeee:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aef2:	d8 22       	popm	r4-r7,pc

8000aef4 <_lseek_r>:
8000aef4:	d4 21       	pushm	r4-r7,lr
8000aef6:	16 98       	mov	r8,r11
8000aef8:	18 97       	mov	r7,r12
8000aefa:	10 9c       	mov	r12,r8
8000aefc:	30 08       	mov	r8,0
8000aefe:	14 9b       	mov	r11,r10
8000af00:	e0 66 40 f0 	mov	r6,16624
8000af04:	12 9a       	mov	r10,r9
8000af06:	8d 08       	st.w	r6[0x0],r8
8000af08:	fe b0 df 36 	rcall	80006d74 <_lseek>
8000af0c:	5b fc       	cp.w	r12,-1
8000af0e:	c0 51       	brne	8000af18 <_lseek_r+0x24>
8000af10:	6c 08       	ld.w	r8,r6[0x0]
8000af12:	58 08       	cp.w	r8,0
8000af14:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af18:	d8 22       	popm	r4-r7,pc
8000af1a:	d7 03       	nop

8000af1c <_read_r>:
8000af1c:	d4 21       	pushm	r4-r7,lr
8000af1e:	16 98       	mov	r8,r11
8000af20:	18 97       	mov	r7,r12
8000af22:	10 9c       	mov	r12,r8
8000af24:	30 08       	mov	r8,0
8000af26:	14 9b       	mov	r11,r10
8000af28:	e0 66 40 f0 	mov	r6,16624
8000af2c:	12 9a       	mov	r10,r9
8000af2e:	8d 08       	st.w	r6[0x0],r8
8000af30:	fe b0 d0 c0 	rcall	800050b0 <_read>
8000af34:	5b fc       	cp.w	r12,-1
8000af36:	c0 51       	brne	8000af40 <_read_r+0x24>
8000af38:	6c 08       	ld.w	r8,r6[0x0]
8000af3a:	58 08       	cp.w	r8,0
8000af3c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af40:	d8 22       	popm	r4-r7,pc
8000af42:	d7 03       	nop

8000af44 <__avr32_f64_mul>:
8000af44:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000af48:	e0 80 00 dc 	breq	8000b100 <__avr32_f64_mul_op1_zero>
8000af4c:	d4 21       	pushm	r4-r7,lr
8000af4e:	f7 e9 20 0e 	eor	lr,r11,r9
8000af52:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000af56:	30 15       	mov	r5,1
8000af58:	c4 30       	breq	8000afde <__avr32_f64_mul_op1_subnormal>
8000af5a:	ab 6b       	lsl	r11,0xa
8000af5c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000af60:	ab 6a       	lsl	r10,0xa
8000af62:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000af66:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000af6a:	c5 c0       	breq	8000b022 <__avr32_f64_mul_op2_subnormal>
8000af6c:	a1 78       	lsl	r8,0x1
8000af6e:	5c f9       	rol	r9
8000af70:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000af74:	e0 47 07 ff 	cp.w	r7,2047
8000af78:	c7 70       	breq	8000b066 <__avr32_f64_mul_op_nan_or_inf>
8000af7a:	e0 46 07 ff 	cp.w	r6,2047
8000af7e:	c7 40       	breq	8000b066 <__avr32_f64_mul_op_nan_or_inf>
8000af80:	ee 06 00 0c 	add	r12,r7,r6
8000af84:	e0 2c 03 fe 	sub	r12,1022
8000af88:	f6 08 06 44 	mulu.d	r4,r11,r8
8000af8c:	f4 09 07 44 	macu.d	r4,r10,r9
8000af90:	f4 08 06 46 	mulu.d	r6,r10,r8
8000af94:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000af98:	08 07       	add	r7,r4
8000af9a:	f4 05 00 4a 	adc	r10,r10,r5
8000af9e:	5c 0b       	acr	r11
8000afa0:	ed bb 00 14 	bld	r11,0x14
8000afa4:	c0 50       	breq	8000afae <__avr32_f64_mul+0x6a>
8000afa6:	a1 77       	lsl	r7,0x1
8000afa8:	5c fa       	rol	r10
8000afaa:	5c fb       	rol	r11
8000afac:	20 1c       	sub	r12,1
8000afae:	58 0c       	cp.w	r12,0
8000afb0:	e0 8a 00 6f 	brle	8000b08e <__avr32_f64_mul_res_subnormal>
8000afb4:	e0 4c 07 ff 	cp.w	r12,2047
8000afb8:	e0 84 00 9c 	brge	8000b0f0 <__avr32_f64_mul_res_inf>
8000afbc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000afc0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000afc4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000afc8:	ee 17 80 00 	eorh	r7,0x8000
8000afcc:	f1 b7 04 20 	satu	r7,0x1
8000afd0:	0e 0a       	add	r10,r7
8000afd2:	5c 0b       	acr	r11
8000afd4:	ed be 00 1f 	bld	lr,0x1f
8000afd8:	ef bb 00 1f 	bst	r11,0x1f
8000afdc:	d8 22       	popm	r4-r7,pc

8000afde <__avr32_f64_mul_op1_subnormal>:
8000afde:	e4 1b 00 0f 	andh	r11,0xf
8000afe2:	f4 0c 12 00 	clz	r12,r10
8000afe6:	f6 06 12 00 	clz	r6,r11
8000afea:	f7 bc 03 e1 	sublo	r12,-31
8000afee:	f8 06 17 30 	movlo	r6,r12
8000aff2:	f7 b6 02 01 	subhs	r6,1
8000aff6:	e0 46 00 20 	cp.w	r6,32
8000affa:	c0 d4       	brge	8000b014 <__avr32_f64_mul_op1_subnormal+0x36>
8000affc:	ec 0c 11 20 	rsub	r12,r6,32
8000b000:	f6 06 09 4b 	lsl	r11,r11,r6
8000b004:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b008:	18 4b       	or	r11,r12
8000b00a:	f4 06 09 4a 	lsl	r10,r10,r6
8000b00e:	20 b6       	sub	r6,11
8000b010:	0c 17       	sub	r7,r6
8000b012:	ca ab       	rjmp	8000af66 <__avr32_f64_mul+0x22>
8000b014:	f4 06 09 4b 	lsl	r11,r10,r6
8000b018:	c6 40       	breq	8000b0e0 <__avr32_f64_mul_res_zero>
8000b01a:	30 0a       	mov	r10,0
8000b01c:	20 b6       	sub	r6,11
8000b01e:	0c 17       	sub	r7,r6
8000b020:	ca 3b       	rjmp	8000af66 <__avr32_f64_mul+0x22>

8000b022 <__avr32_f64_mul_op2_subnormal>:
8000b022:	e4 19 00 0f 	andh	r9,0xf
8000b026:	f0 0c 12 00 	clz	r12,r8
8000b02a:	f2 05 12 00 	clz	r5,r9
8000b02e:	f7 bc 03 ea 	sublo	r12,-22
8000b032:	f8 05 17 30 	movlo	r5,r12
8000b036:	f7 b5 02 0a 	subhs	r5,10
8000b03a:	e0 45 00 20 	cp.w	r5,32
8000b03e:	c0 d4       	brge	8000b058 <__avr32_f64_mul_op2_subnormal+0x36>
8000b040:	ea 0c 11 20 	rsub	r12,r5,32
8000b044:	f2 05 09 49 	lsl	r9,r9,r5
8000b048:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b04c:	18 49       	or	r9,r12
8000b04e:	f0 05 09 48 	lsl	r8,r8,r5
8000b052:	20 25       	sub	r5,2
8000b054:	0a 16       	sub	r6,r5
8000b056:	c8 fb       	rjmp	8000af74 <__avr32_f64_mul+0x30>
8000b058:	f0 05 09 49 	lsl	r9,r8,r5
8000b05c:	c4 20       	breq	8000b0e0 <__avr32_f64_mul_res_zero>
8000b05e:	30 08       	mov	r8,0
8000b060:	20 25       	sub	r5,2
8000b062:	0a 16       	sub	r6,r5
8000b064:	c8 8b       	rjmp	8000af74 <__avr32_f64_mul+0x30>

8000b066 <__avr32_f64_mul_op_nan_or_inf>:
8000b066:	e4 19 00 0f 	andh	r9,0xf
8000b06a:	e4 1b 00 0f 	andh	r11,0xf
8000b06e:	14 4b       	or	r11,r10
8000b070:	10 49       	or	r9,r8
8000b072:	e0 47 07 ff 	cp.w	r7,2047
8000b076:	c0 91       	brne	8000b088 <__avr32_f64_mul_op1_not_naninf>
8000b078:	58 0b       	cp.w	r11,0
8000b07a:	c3 81       	brne	8000b0ea <__avr32_f64_mul_res_nan>
8000b07c:	e0 46 07 ff 	cp.w	r6,2047
8000b080:	c3 81       	brne	8000b0f0 <__avr32_f64_mul_res_inf>
8000b082:	58 09       	cp.w	r9,0
8000b084:	c3 60       	breq	8000b0f0 <__avr32_f64_mul_res_inf>
8000b086:	c3 28       	rjmp	8000b0ea <__avr32_f64_mul_res_nan>

8000b088 <__avr32_f64_mul_op1_not_naninf>:
8000b088:	58 09       	cp.w	r9,0
8000b08a:	c3 30       	breq	8000b0f0 <__avr32_f64_mul_res_inf>
8000b08c:	c2 f8       	rjmp	8000b0ea <__avr32_f64_mul_res_nan>

8000b08e <__avr32_f64_mul_res_subnormal>:
8000b08e:	5c 3c       	neg	r12
8000b090:	2f fc       	sub	r12,-1
8000b092:	f1 bc 04 c0 	satu	r12,0x6
8000b096:	e0 4c 00 20 	cp.w	r12,32
8000b09a:	c1 14       	brge	8000b0bc <__avr32_f64_mul_res_subnormal+0x2e>
8000b09c:	f8 08 11 20 	rsub	r8,r12,32
8000b0a0:	0e 46       	or	r6,r7
8000b0a2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b0a6:	f4 08 09 49 	lsl	r9,r10,r8
8000b0aa:	12 47       	or	r7,r9
8000b0ac:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b0b0:	f6 08 09 49 	lsl	r9,r11,r8
8000b0b4:	12 4a       	or	r10,r9
8000b0b6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b0ba:	c8 3b       	rjmp	8000afc0 <__avr32_f64_mul+0x7c>
8000b0bc:	f8 08 11 20 	rsub	r8,r12,32
8000b0c0:	f9 b9 00 00 	moveq	r9,0
8000b0c4:	c0 30       	breq	8000b0ca <__avr32_f64_mul_res_subnormal+0x3c>
8000b0c6:	f6 08 09 49 	lsl	r9,r11,r8
8000b0ca:	0e 46       	or	r6,r7
8000b0cc:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b0d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b0d4:	f3 ea 10 07 	or	r7,r9,r10
8000b0d8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b0dc:	30 0b       	mov	r11,0
8000b0de:	c7 1b       	rjmp	8000afc0 <__avr32_f64_mul+0x7c>

8000b0e0 <__avr32_f64_mul_res_zero>:
8000b0e0:	1c 9b       	mov	r11,lr
8000b0e2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b0e6:	30 0a       	mov	r10,0
8000b0e8:	d8 22       	popm	r4-r7,pc

8000b0ea <__avr32_f64_mul_res_nan>:
8000b0ea:	3f fb       	mov	r11,-1
8000b0ec:	3f fa       	mov	r10,-1
8000b0ee:	d8 22       	popm	r4-r7,pc

8000b0f0 <__avr32_f64_mul_res_inf>:
8000b0f0:	f0 6b 00 00 	mov	r11,-1048576
8000b0f4:	ed be 00 1f 	bld	lr,0x1f
8000b0f8:	ef bb 00 1f 	bst	r11,0x1f
8000b0fc:	30 0a       	mov	r10,0
8000b0fe:	d8 22       	popm	r4-r7,pc

8000b100 <__avr32_f64_mul_op1_zero>:
8000b100:	f7 e9 20 0b 	eor	r11,r11,r9
8000b104:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b108:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b10c:	e0 4c 07 ff 	cp.w	r12,2047
8000b110:	5e 1c       	retne	r12
8000b112:	3f fa       	mov	r10,-1
8000b114:	3f fb       	mov	r11,-1
8000b116:	5e fc       	retal	r12

8000b118 <__avr32_f64_sub_from_add>:
8000b118:	ee 19 80 00 	eorh	r9,0x8000

8000b11c <__avr32_f64_sub>:
8000b11c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b120:	e0 86 00 ca 	brmi	8000b2b4 <__avr32_f64_add_from_sub>
8000b124:	eb cd 40 e0 	pushm	r5-r7,lr
8000b128:	16 9c       	mov	r12,r11
8000b12a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b12e:	bf db       	cbr	r11,0x1f
8000b130:	bf d9       	cbr	r9,0x1f
8000b132:	10 3a       	cp.w	r10,r8
8000b134:	f2 0b 13 00 	cpc	r11,r9
8000b138:	c0 92       	brcc	8000b14a <__avr32_f64_sub+0x2e>
8000b13a:	16 97       	mov	r7,r11
8000b13c:	12 9b       	mov	r11,r9
8000b13e:	0e 99       	mov	r9,r7
8000b140:	14 97       	mov	r7,r10
8000b142:	10 9a       	mov	r10,r8
8000b144:	0e 98       	mov	r8,r7
8000b146:	ee 1c 80 00 	eorh	r12,0x8000
8000b14a:	f6 07 16 14 	lsr	r7,r11,0x14
8000b14e:	ab 7b       	lsl	r11,0xb
8000b150:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b154:	ab 7a       	lsl	r10,0xb
8000b156:	bf bb       	sbr	r11,0x1f
8000b158:	f2 06 16 14 	lsr	r6,r9,0x14
8000b15c:	c4 40       	breq	8000b1e4 <__avr32_f64_sub_opL_subnormal>
8000b15e:	ab 79       	lsl	r9,0xb
8000b160:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b164:	ab 78       	lsl	r8,0xb
8000b166:	bf b9       	sbr	r9,0x1f

8000b168 <__avr32_f64_sub_opL_subnormal_done>:
8000b168:	e0 47 07 ff 	cp.w	r7,2047
8000b16c:	c4 f0       	breq	8000b20a <__avr32_f64_sub_opH_nan_or_inf>
8000b16e:	0e 26       	rsub	r6,r7
8000b170:	c1 20       	breq	8000b194 <__avr32_f64_sub_shift_done>
8000b172:	ec 05 11 20 	rsub	r5,r6,32
8000b176:	e0 46 00 20 	cp.w	r6,32
8000b17a:	c7 c2       	brcc	8000b272 <__avr32_f64_sub_longshift>
8000b17c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b180:	f2 05 09 45 	lsl	r5,r9,r5
8000b184:	f0 06 0a 48 	lsr	r8,r8,r6
8000b188:	f2 06 0a 49 	lsr	r9,r9,r6
8000b18c:	0a 48       	or	r8,r5
8000b18e:	58 0e       	cp.w	lr,0
8000b190:	5f 1e       	srne	lr
8000b192:	1c 48       	or	r8,lr

8000b194 <__avr32_f64_sub_shift_done>:
8000b194:	10 1a       	sub	r10,r8
8000b196:	f6 09 01 4b 	sbc	r11,r11,r9
8000b19a:	f6 06 12 00 	clz	r6,r11
8000b19e:	c0 e0       	breq	8000b1ba <__avr32_f64_sub_longnormalize_done>
8000b1a0:	c7 83       	brcs	8000b290 <__avr32_f64_sub_longnormalize>
8000b1a2:	ec 0e 11 20 	rsub	lr,r6,32
8000b1a6:	f6 06 09 4b 	lsl	r11,r11,r6
8000b1aa:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b1ae:	1c 4b       	or	r11,lr
8000b1b0:	f4 06 09 4a 	lsl	r10,r10,r6
8000b1b4:	0c 17       	sub	r7,r6
8000b1b6:	e0 8a 00 39 	brle	8000b228 <__avr32_f64_sub_subnormal_result>

8000b1ba <__avr32_f64_sub_longnormalize_done>:
8000b1ba:	f4 09 15 15 	lsl	r9,r10,0x15
8000b1be:	ab 9a       	lsr	r10,0xb
8000b1c0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b1c4:	ab 9b       	lsr	r11,0xb
8000b1c6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b1ca:	18 4b       	or	r11,r12

8000b1cc <__avr32_f64_sub_round>:
8000b1cc:	fc 17 80 00 	movh	r7,0x8000
8000b1d0:	ed ba 00 00 	bld	r10,0x0
8000b1d4:	f7 b7 01 ff 	subne	r7,-1
8000b1d8:	0e 39       	cp.w	r9,r7
8000b1da:	5f 29       	srhs	r9
8000b1dc:	12 0a       	add	r10,r9
8000b1de:	5c 0b       	acr	r11
8000b1e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b1e4 <__avr32_f64_sub_opL_subnormal>:
8000b1e4:	ab 79       	lsl	r9,0xb
8000b1e6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b1ea:	ab 78       	lsl	r8,0xb
8000b1ec:	f3 e8 10 0e 	or	lr,r9,r8
8000b1f0:	f9 b6 01 01 	movne	r6,1
8000b1f4:	ee 0e 11 00 	rsub	lr,r7,0
8000b1f8:	f9 b7 00 01 	moveq	r7,1
8000b1fc:	ef bb 00 1f 	bst	r11,0x1f
8000b200:	f7 ea 10 0e 	or	lr,r11,r10
8000b204:	f9 b7 00 00 	moveq	r7,0
8000b208:	cb 0b       	rjmp	8000b168 <__avr32_f64_sub_opL_subnormal_done>

8000b20a <__avr32_f64_sub_opH_nan_or_inf>:
8000b20a:	bf db       	cbr	r11,0x1f
8000b20c:	f7 ea 10 0e 	or	lr,r11,r10
8000b210:	c0 81       	brne	8000b220 <__avr32_f64_sub_return_nan>
8000b212:	e0 46 07 ff 	cp.w	r6,2047
8000b216:	c0 50       	breq	8000b220 <__avr32_f64_sub_return_nan>
8000b218:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b21c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b220 <__avr32_f64_sub_return_nan>:
8000b220:	3f fa       	mov	r10,-1
8000b222:	3f fb       	mov	r11,-1
8000b224:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b228 <__avr32_f64_sub_subnormal_result>:
8000b228:	5c 37       	neg	r7
8000b22a:	2f f7       	sub	r7,-1
8000b22c:	f1 b7 04 c0 	satu	r7,0x6
8000b230:	e0 47 00 20 	cp.w	r7,32
8000b234:	c1 14       	brge	8000b256 <__avr32_f64_sub_subnormal_result+0x2e>
8000b236:	ee 08 11 20 	rsub	r8,r7,32
8000b23a:	f4 08 09 49 	lsl	r9,r10,r8
8000b23e:	5f 16       	srne	r6
8000b240:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b244:	0c 4a       	or	r10,r6
8000b246:	f6 08 09 49 	lsl	r9,r11,r8
8000b24a:	f5 e9 10 0a 	or	r10,r10,r9
8000b24e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b252:	30 07       	mov	r7,0
8000b254:	cb 3b       	rjmp	8000b1ba <__avr32_f64_sub_longnormalize_done>
8000b256:	ee 08 11 40 	rsub	r8,r7,64
8000b25a:	f6 08 09 49 	lsl	r9,r11,r8
8000b25e:	14 49       	or	r9,r10
8000b260:	5f 16       	srne	r6
8000b262:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b266:	0c 4a       	or	r10,r6
8000b268:	30 0b       	mov	r11,0
8000b26a:	30 07       	mov	r7,0
8000b26c:	ca 7b       	rjmp	8000b1ba <__avr32_f64_sub_longnormalize_done>
8000b26e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b272 <__avr32_f64_sub_longshift>:
8000b272:	f1 b6 04 c0 	satu	r6,0x6
8000b276:	f0 0e 17 00 	moveq	lr,r8
8000b27a:	c0 40       	breq	8000b282 <__avr32_f64_sub_longshift+0x10>
8000b27c:	f2 05 09 4e 	lsl	lr,r9,r5
8000b280:	10 4e       	or	lr,r8
8000b282:	f2 06 0a 48 	lsr	r8,r9,r6
8000b286:	30 09       	mov	r9,0
8000b288:	58 0e       	cp.w	lr,0
8000b28a:	5f 1e       	srne	lr
8000b28c:	1c 48       	or	r8,lr
8000b28e:	c8 3b       	rjmp	8000b194 <__avr32_f64_sub_shift_done>

8000b290 <__avr32_f64_sub_longnormalize>:
8000b290:	f4 06 12 00 	clz	r6,r10
8000b294:	f9 b7 03 00 	movlo	r7,0
8000b298:	f9 b6 03 00 	movlo	r6,0
8000b29c:	f9 bc 03 00 	movlo	r12,0
8000b2a0:	f7 b6 02 e0 	subhs	r6,-32
8000b2a4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b2a8:	30 0a       	mov	r10,0
8000b2aa:	0c 17       	sub	r7,r6
8000b2ac:	fe 9a ff be 	brle	8000b228 <__avr32_f64_sub_subnormal_result>
8000b2b0:	c8 5b       	rjmp	8000b1ba <__avr32_f64_sub_longnormalize_done>
8000b2b2:	d7 03       	nop

8000b2b4 <__avr32_f64_add_from_sub>:
8000b2b4:	ee 19 80 00 	eorh	r9,0x8000

8000b2b8 <__avr32_f64_add>:
8000b2b8:	f7 e9 20 0c 	eor	r12,r11,r9
8000b2bc:	fe 96 ff 2e 	brmi	8000b118 <__avr32_f64_sub_from_add>
8000b2c0:	eb cd 40 e0 	pushm	r5-r7,lr
8000b2c4:	16 9c       	mov	r12,r11
8000b2c6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b2ca:	bf db       	cbr	r11,0x1f
8000b2cc:	bf d9       	cbr	r9,0x1f
8000b2ce:	12 3b       	cp.w	r11,r9
8000b2d0:	c0 72       	brcc	8000b2de <__avr32_f64_add+0x26>
8000b2d2:	16 97       	mov	r7,r11
8000b2d4:	12 9b       	mov	r11,r9
8000b2d6:	0e 99       	mov	r9,r7
8000b2d8:	14 97       	mov	r7,r10
8000b2da:	10 9a       	mov	r10,r8
8000b2dc:	0e 98       	mov	r8,r7
8000b2de:	30 0e       	mov	lr,0
8000b2e0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b2e4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b2e8:	b5 ab       	sbr	r11,0x14
8000b2ea:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b2ee:	c6 20       	breq	8000b3b2 <__avr32_f64_add_op2_subnormal>
8000b2f0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b2f4:	b5 a9       	sbr	r9,0x14
8000b2f6:	e0 47 07 ff 	cp.w	r7,2047
8000b2fa:	c2 80       	breq	8000b34a <__avr32_f64_add_opH_nan_or_inf>
8000b2fc:	0e 26       	rsub	r6,r7
8000b2fe:	c1 20       	breq	8000b322 <__avr32_f64_add_shift_done>
8000b300:	e0 46 00 36 	cp.w	r6,54
8000b304:	c1 52       	brcc	8000b32e <__avr32_f64_add_res_of_done>
8000b306:	ec 05 11 20 	rsub	r5,r6,32
8000b30a:	e0 46 00 20 	cp.w	r6,32
8000b30e:	c3 52       	brcc	8000b378 <__avr32_f64_add_longshift>
8000b310:	f0 05 09 4e 	lsl	lr,r8,r5
8000b314:	f2 05 09 45 	lsl	r5,r9,r5
8000b318:	f0 06 0a 48 	lsr	r8,r8,r6
8000b31c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b320:	0a 48       	or	r8,r5

8000b322 <__avr32_f64_add_shift_done>:
8000b322:	10 0a       	add	r10,r8
8000b324:	f6 09 00 4b 	adc	r11,r11,r9
8000b328:	ed bb 00 15 	bld	r11,0x15
8000b32c:	c3 40       	breq	8000b394 <__avr32_f64_add_res_of>

8000b32e <__avr32_f64_add_res_of_done>:
8000b32e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b332:	18 4b       	or	r11,r12

8000b334 <__avr32_f64_add_round>:
8000b334:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b338:	18 4e       	or	lr,r12
8000b33a:	ee 1e 80 00 	eorh	lr,0x8000
8000b33e:	f1 be 04 20 	satu	lr,0x1
8000b342:	1c 0a       	add	r10,lr
8000b344:	5c 0b       	acr	r11
8000b346:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b34a <__avr32_f64_add_opH_nan_or_inf>:
8000b34a:	b5 cb       	cbr	r11,0x14
8000b34c:	f7 ea 10 0e 	or	lr,r11,r10
8000b350:	c1 01       	brne	8000b370 <__avr32_f64_add_return_nan>
8000b352:	e0 46 07 ff 	cp.w	r6,2047
8000b356:	c0 30       	breq	8000b35c <__avr32_f64_add_opL_nan_or_inf>
8000b358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b35c <__avr32_f64_add_opL_nan_or_inf>:
8000b35c:	b5 c9       	cbr	r9,0x14
8000b35e:	f3 e8 10 0e 	or	lr,r9,r8
8000b362:	c0 71       	brne	8000b370 <__avr32_f64_add_return_nan>
8000b364:	30 0a       	mov	r10,0
8000b366:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b36a:	18 4b       	or	r11,r12
8000b36c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b370 <__avr32_f64_add_return_nan>:
8000b370:	3f fa       	mov	r10,-1
8000b372:	3f fb       	mov	r11,-1
8000b374:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b378 <__avr32_f64_add_longshift>:
8000b378:	f1 b6 04 c0 	satu	r6,0x6
8000b37c:	f0 0e 17 00 	moveq	lr,r8
8000b380:	c0 60       	breq	8000b38c <__avr32_f64_add_longshift+0x14>
8000b382:	f2 05 09 4e 	lsl	lr,r9,r5
8000b386:	58 08       	cp.w	r8,0
8000b388:	5f 18       	srne	r8
8000b38a:	10 4e       	or	lr,r8
8000b38c:	f2 06 0a 48 	lsr	r8,r9,r6
8000b390:	30 09       	mov	r9,0
8000b392:	cc 8b       	rjmp	8000b322 <__avr32_f64_add_shift_done>

8000b394 <__avr32_f64_add_res_of>:
8000b394:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b398:	a1 9b       	lsr	r11,0x1
8000b39a:	5d 0a       	ror	r10
8000b39c:	5d 0e       	ror	lr
8000b39e:	2f f7       	sub	r7,-1
8000b3a0:	e0 47 07 ff 	cp.w	r7,2047
8000b3a4:	f9 ba 00 00 	moveq	r10,0
8000b3a8:	f9 bb 00 00 	moveq	r11,0
8000b3ac:	f9 be 00 00 	moveq	lr,0
8000b3b0:	cb fb       	rjmp	8000b32e <__avr32_f64_add_res_of_done>

8000b3b2 <__avr32_f64_add_op2_subnormal>:
8000b3b2:	30 16       	mov	r6,1
8000b3b4:	58 07       	cp.w	r7,0
8000b3b6:	ca 01       	brne	8000b2f6 <__avr32_f64_add+0x3e>
8000b3b8:	b5 cb       	cbr	r11,0x14
8000b3ba:	10 0a       	add	r10,r8
8000b3bc:	f6 09 00 4b 	adc	r11,r11,r9
8000b3c0:	18 4b       	or	r11,r12
8000b3c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b3c6:	d7 03       	nop

8000b3c8 <__avr32_f64_to_u32>:
8000b3c8:	58 0b       	cp.w	r11,0
8000b3ca:	5e 6d       	retmi	0

8000b3cc <__avr32_f64_to_s32>:
8000b3cc:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b3d0:	b5 9c       	lsr	r12,0x15
8000b3d2:	e0 2c 03 ff 	sub	r12,1023
8000b3d6:	5e 3d       	retlo	0
8000b3d8:	f8 0c 11 1f 	rsub	r12,r12,31
8000b3dc:	16 99       	mov	r9,r11
8000b3de:	ab 7b       	lsl	r11,0xb
8000b3e0:	bf bb       	sbr	r11,0x1f
8000b3e2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b3e6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b3ea:	a1 79       	lsl	r9,0x1
8000b3ec:	5e 2b       	reths	r11
8000b3ee:	5c 3b       	neg	r11
8000b3f0:	5e fb       	retal	r11

8000b3f2 <__avr32_u32_to_f64>:
8000b3f2:	f8 cb 00 00 	sub	r11,r12,0
8000b3f6:	30 0c       	mov	r12,0
8000b3f8:	c0 38       	rjmp	8000b3fe <__avr32_s32_to_f64+0x4>

8000b3fa <__avr32_s32_to_f64>:
8000b3fa:	18 9b       	mov	r11,r12
8000b3fc:	5c 4b       	abs	r11
8000b3fe:	30 0a       	mov	r10,0
8000b400:	5e 0b       	reteq	r11
8000b402:	d4 01       	pushm	lr
8000b404:	e0 69 04 1e 	mov	r9,1054
8000b408:	f6 08 12 00 	clz	r8,r11
8000b40c:	c1 70       	breq	8000b43a <__avr32_s32_to_f64+0x40>
8000b40e:	c0 c3       	brcs	8000b426 <__avr32_s32_to_f64+0x2c>
8000b410:	f0 0e 11 20 	rsub	lr,r8,32
8000b414:	f6 08 09 4b 	lsl	r11,r11,r8
8000b418:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b41c:	1c 4b       	or	r11,lr
8000b41e:	f4 08 09 4a 	lsl	r10,r10,r8
8000b422:	10 19       	sub	r9,r8
8000b424:	c0 b8       	rjmp	8000b43a <__avr32_s32_to_f64+0x40>
8000b426:	f4 08 12 00 	clz	r8,r10
8000b42a:	f9 b8 03 00 	movlo	r8,0
8000b42e:	f7 b8 02 e0 	subhs	r8,-32
8000b432:	f4 08 09 4b 	lsl	r11,r10,r8
8000b436:	30 0a       	mov	r10,0
8000b438:	10 19       	sub	r9,r8
8000b43a:	58 09       	cp.w	r9,0
8000b43c:	e0 89 00 30 	brgt	8000b49c <__avr32_s32_to_f64+0xa2>
8000b440:	5c 39       	neg	r9
8000b442:	2f f9       	sub	r9,-1
8000b444:	e0 49 00 36 	cp.w	r9,54
8000b448:	c0 43       	brcs	8000b450 <__avr32_s32_to_f64+0x56>
8000b44a:	30 0b       	mov	r11,0
8000b44c:	30 0a       	mov	r10,0
8000b44e:	c2 68       	rjmp	8000b49a <__avr32_s32_to_f64+0xa0>
8000b450:	2f 69       	sub	r9,-10
8000b452:	f2 08 11 20 	rsub	r8,r9,32
8000b456:	e0 49 00 20 	cp.w	r9,32
8000b45a:	c0 b2       	brcc	8000b470 <__avr32_s32_to_f64+0x76>
8000b45c:	f4 08 09 4e 	lsl	lr,r10,r8
8000b460:	f6 08 09 48 	lsl	r8,r11,r8
8000b464:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b468:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b46c:	10 4b       	or	r11,r8
8000b46e:	c0 88       	rjmp	8000b47e <__avr32_s32_to_f64+0x84>
8000b470:	f6 08 09 4e 	lsl	lr,r11,r8
8000b474:	14 4e       	or	lr,r10
8000b476:	16 9a       	mov	r10,r11
8000b478:	30 0b       	mov	r11,0
8000b47a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b47e:	ed ba 00 00 	bld	r10,0x0
8000b482:	c0 92       	brcc	8000b494 <__avr32_s32_to_f64+0x9a>
8000b484:	1c 7e       	tst	lr,lr
8000b486:	c0 41       	brne	8000b48e <__avr32_s32_to_f64+0x94>
8000b488:	ed ba 00 01 	bld	r10,0x1
8000b48c:	c0 42       	brcc	8000b494 <__avr32_s32_to_f64+0x9a>
8000b48e:	2f fa       	sub	r10,-1
8000b490:	f7 bb 02 ff 	subhs	r11,-1
8000b494:	5c fc       	rol	r12
8000b496:	5d 0b       	ror	r11
8000b498:	5d 0a       	ror	r10
8000b49a:	d8 02       	popm	pc
8000b49c:	e0 68 03 ff 	mov	r8,1023
8000b4a0:	ed ba 00 0b 	bld	r10,0xb
8000b4a4:	f7 b8 00 ff 	subeq	r8,-1
8000b4a8:	10 0a       	add	r10,r8
8000b4aa:	5c 0b       	acr	r11
8000b4ac:	f7 b9 03 fe 	sublo	r9,-2
8000b4b0:	e0 49 07 ff 	cp.w	r9,2047
8000b4b4:	c0 55       	brlt	8000b4be <__avr32_s32_to_f64+0xc4>
8000b4b6:	30 0a       	mov	r10,0
8000b4b8:	fc 1b ff e0 	movh	r11,0xffe0
8000b4bc:	c0 c8       	rjmp	8000b4d4 <__floatsidf_return_op1>
8000b4be:	ed bb 00 1f 	bld	r11,0x1f
8000b4c2:	f7 b9 01 01 	subne	r9,1
8000b4c6:	ab 9a       	lsr	r10,0xb
8000b4c8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b4cc:	a1 7b       	lsl	r11,0x1
8000b4ce:	ab 9b       	lsr	r11,0xb
8000b4d0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b4d4 <__floatsidf_return_op1>:
8000b4d4:	a1 7c       	lsl	r12,0x1
8000b4d6:	5d 0b       	ror	r11
8000b4d8:	d8 02       	popm	pc

8000b4da <__avr32_f64_cmp_eq>:
8000b4da:	10 3a       	cp.w	r10,r8
8000b4dc:	f2 0b 13 00 	cpc	r11,r9
8000b4e0:	c0 80       	breq	8000b4f0 <__avr32_f64_cmp_eq+0x16>
8000b4e2:	a1 7b       	lsl	r11,0x1
8000b4e4:	a1 79       	lsl	r9,0x1
8000b4e6:	14 4b       	or	r11,r10
8000b4e8:	12 4b       	or	r11,r9
8000b4ea:	10 4b       	or	r11,r8
8000b4ec:	5e 0f       	reteq	1
8000b4ee:	5e fd       	retal	0
8000b4f0:	a1 7b       	lsl	r11,0x1
8000b4f2:	fc 1c ff e0 	movh	r12,0xffe0
8000b4f6:	58 0a       	cp.w	r10,0
8000b4f8:	f8 0b 13 00 	cpc	r11,r12
8000b4fc:	5e 8f       	retls	1
8000b4fe:	5e fd       	retal	0

8000b500 <__avr32_f64_cmp_ge>:
8000b500:	1a de       	st.w	--sp,lr
8000b502:	1a d7       	st.w	--sp,r7
8000b504:	a1 7b       	lsl	r11,0x1
8000b506:	5f 3c       	srlo	r12
8000b508:	a1 79       	lsl	r9,0x1
8000b50a:	5f 37       	srlo	r7
8000b50c:	5c fc       	rol	r12
8000b50e:	fc 1e ff e0 	movh	lr,0xffe0
8000b512:	58 0a       	cp.w	r10,0
8000b514:	fc 0b 13 00 	cpc	r11,lr
8000b518:	e0 8b 00 1d 	brhi	8000b552 <__avr32_f64_cmp_ge+0x52>
8000b51c:	58 08       	cp.w	r8,0
8000b51e:	fc 09 13 00 	cpc	r9,lr
8000b522:	e0 8b 00 18 	brhi	8000b552 <__avr32_f64_cmp_ge+0x52>
8000b526:	58 0b       	cp.w	r11,0
8000b528:	f5 ba 00 00 	subfeq	r10,0
8000b52c:	c1 50       	breq	8000b556 <__avr32_f64_cmp_ge+0x56>
8000b52e:	1b 07       	ld.w	r7,sp++
8000b530:	1b 0e       	ld.w	lr,sp++
8000b532:	58 3c       	cp.w	r12,3
8000b534:	c0 a0       	breq	8000b548 <__avr32_f64_cmp_ge+0x48>
8000b536:	58 1c       	cp.w	r12,1
8000b538:	c0 33       	brcs	8000b53e <__avr32_f64_cmp_ge+0x3e>
8000b53a:	5e 0f       	reteq	1
8000b53c:	5e 1d       	retne	0
8000b53e:	10 3a       	cp.w	r10,r8
8000b540:	f2 0b 13 00 	cpc	r11,r9
8000b544:	5e 2f       	reths	1
8000b546:	5e 3d       	retlo	0
8000b548:	14 38       	cp.w	r8,r10
8000b54a:	f6 09 13 00 	cpc	r9,r11
8000b54e:	5e 2f       	reths	1
8000b550:	5e 3d       	retlo	0
8000b552:	1b 07       	ld.w	r7,sp++
8000b554:	d8 0a       	popm	pc,r12=0
8000b556:	58 17       	cp.w	r7,1
8000b558:	5f 0c       	sreq	r12
8000b55a:	58 09       	cp.w	r9,0
8000b55c:	f5 b8 00 00 	subfeq	r8,0
8000b560:	1b 07       	ld.w	r7,sp++
8000b562:	1b 0e       	ld.w	lr,sp++
8000b564:	5e 0f       	reteq	1
8000b566:	5e fc       	retal	r12

8000b568 <__avr32_f64_cmp_lt>:
8000b568:	1a de       	st.w	--sp,lr
8000b56a:	1a d7       	st.w	--sp,r7
8000b56c:	a1 7b       	lsl	r11,0x1
8000b56e:	5f 3c       	srlo	r12
8000b570:	a1 79       	lsl	r9,0x1
8000b572:	5f 37       	srlo	r7
8000b574:	5c fc       	rol	r12
8000b576:	fc 1e ff e0 	movh	lr,0xffe0
8000b57a:	58 0a       	cp.w	r10,0
8000b57c:	fc 0b 13 00 	cpc	r11,lr
8000b580:	e0 8b 00 1d 	brhi	8000b5ba <__avr32_f64_cmp_lt+0x52>
8000b584:	58 08       	cp.w	r8,0
8000b586:	fc 09 13 00 	cpc	r9,lr
8000b58a:	e0 8b 00 18 	brhi	8000b5ba <__avr32_f64_cmp_lt+0x52>
8000b58e:	58 0b       	cp.w	r11,0
8000b590:	f5 ba 00 00 	subfeq	r10,0
8000b594:	c1 50       	breq	8000b5be <__avr32_f64_cmp_lt+0x56>
8000b596:	1b 07       	ld.w	r7,sp++
8000b598:	1b 0e       	ld.w	lr,sp++
8000b59a:	58 3c       	cp.w	r12,3
8000b59c:	c0 a0       	breq	8000b5b0 <__avr32_f64_cmp_lt+0x48>
8000b59e:	58 1c       	cp.w	r12,1
8000b5a0:	c0 33       	brcs	8000b5a6 <__avr32_f64_cmp_lt+0x3e>
8000b5a2:	5e 0d       	reteq	0
8000b5a4:	5e 1f       	retne	1
8000b5a6:	10 3a       	cp.w	r10,r8
8000b5a8:	f2 0b 13 00 	cpc	r11,r9
8000b5ac:	5e 2d       	reths	0
8000b5ae:	5e 3f       	retlo	1
8000b5b0:	14 38       	cp.w	r8,r10
8000b5b2:	f6 09 13 00 	cpc	r9,r11
8000b5b6:	5e 2d       	reths	0
8000b5b8:	5e 3f       	retlo	1
8000b5ba:	1b 07       	ld.w	r7,sp++
8000b5bc:	d8 0a       	popm	pc,r12=0
8000b5be:	58 17       	cp.w	r7,1
8000b5c0:	5f 1c       	srne	r12
8000b5c2:	58 09       	cp.w	r9,0
8000b5c4:	f5 b8 00 00 	subfeq	r8,0
8000b5c8:	1b 07       	ld.w	r7,sp++
8000b5ca:	1b 0e       	ld.w	lr,sp++
8000b5cc:	5e 0d       	reteq	0
8000b5ce:	5e fc       	retal	r12

8000b5d0 <__avr32_f64_div>:
8000b5d0:	eb cd 40 ff 	pushm	r0-r7,lr
8000b5d4:	f7 e9 20 0e 	eor	lr,r11,r9
8000b5d8:	f6 07 16 14 	lsr	r7,r11,0x14
8000b5dc:	a9 7b       	lsl	r11,0x9
8000b5de:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b5e2:	a9 7a       	lsl	r10,0x9
8000b5e4:	bd bb       	sbr	r11,0x1d
8000b5e6:	e4 1b 3f ff 	andh	r11,0x3fff
8000b5ea:	ab d7       	cbr	r7,0xb
8000b5ec:	e0 80 00 cc 	breq	8000b784 <__avr32_f64_div_round_subnormal+0x54>
8000b5f0:	e0 47 07 ff 	cp.w	r7,2047
8000b5f4:	e0 84 00 b5 	brge	8000b75e <__avr32_f64_div_round_subnormal+0x2e>
8000b5f8:	f2 06 16 14 	lsr	r6,r9,0x14
8000b5fc:	a9 79       	lsl	r9,0x9
8000b5fe:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b602:	a9 78       	lsl	r8,0x9
8000b604:	bd b9       	sbr	r9,0x1d
8000b606:	e4 19 3f ff 	andh	r9,0x3fff
8000b60a:	ab d6       	cbr	r6,0xb
8000b60c:	e0 80 00 e2 	breq	8000b7d0 <__avr32_f64_div_round_subnormal+0xa0>
8000b610:	e0 46 07 ff 	cp.w	r6,2047
8000b614:	e0 84 00 b2 	brge	8000b778 <__avr32_f64_div_round_subnormal+0x48>
8000b618:	0c 17       	sub	r7,r6
8000b61a:	fe 37 fc 01 	sub	r7,-1023
8000b61e:	fc 1c 80 00 	movh	r12,0x8000
8000b622:	f8 03 16 01 	lsr	r3,r12,0x1
8000b626:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b62a:	5c d4       	com	r4
8000b62c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b630:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b634:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b638:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b63c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b640:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b644:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b648:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b64c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b650:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b654:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b658:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b65c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b660:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b664:	e4 09 07 40 	macu.d	r0,r2,r9
8000b668:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b66c:	02 04       	add	r4,r1
8000b66e:	5c 05       	acr	r5
8000b670:	a3 65       	lsl	r5,0x2
8000b672:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b676:	a3 64       	lsl	r4,0x2
8000b678:	5c 34       	neg	r4
8000b67a:	f8 05 01 45 	sbc	r5,r12,r5
8000b67e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b682:	e4 05 07 40 	macu.d	r0,r2,r5
8000b686:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b68a:	02 04       	add	r4,r1
8000b68c:	5c 05       	acr	r5
8000b68e:	ea 03 15 02 	lsl	r3,r5,0x2
8000b692:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b696:	e8 02 15 02 	lsl	r2,r4,0x2
8000b69a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b69e:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6a2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6a6:	02 04       	add	r4,r1
8000b6a8:	5c 05       	acr	r5
8000b6aa:	a3 65       	lsl	r5,0x2
8000b6ac:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b6b0:	a3 64       	lsl	r4,0x2
8000b6b2:	5c 34       	neg	r4
8000b6b4:	f8 05 01 45 	sbc	r5,r12,r5
8000b6b8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b6bc:	e4 05 07 40 	macu.d	r0,r2,r5
8000b6c0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6c4:	02 04       	add	r4,r1
8000b6c6:	5c 05       	acr	r5
8000b6c8:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6cc:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b6d0:	e8 02 15 02 	lsl	r2,r4,0x2
8000b6d4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b6d8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b6dc:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b6e0:	02 02       	add	r2,r1
8000b6e2:	5c 03       	acr	r3
8000b6e4:	ed b3 00 1c 	bld	r3,0x1c
8000b6e8:	c0 90       	breq	8000b6fa <__avr32_f64_div+0x12a>
8000b6ea:	a1 72       	lsl	r2,0x1
8000b6ec:	5c f3       	rol	r3
8000b6ee:	20 17       	sub	r7,1
8000b6f0:	a3 9a       	lsr	r10,0x3
8000b6f2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b6f6:	a3 9b       	lsr	r11,0x3
8000b6f8:	c0 58       	rjmp	8000b702 <__avr32_f64_div+0x132>
8000b6fa:	a5 8a       	lsr	r10,0x4
8000b6fc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b700:	a5 8b       	lsr	r11,0x4
8000b702:	58 07       	cp.w	r7,0
8000b704:	e0 8a 00 8b 	brle	8000b81a <__avr32_f64_div_res_subnormal>
8000b708:	e0 12 ff 00 	andl	r2,0xff00
8000b70c:	e8 12 00 80 	orl	r2,0x80
8000b710:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b714:	e4 09 07 40 	macu.d	r0,r2,r9
8000b718:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b71c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b720:	00 05       	add	r5,r0
8000b722:	f0 01 00 48 	adc	r8,r8,r1
8000b726:	5c 09       	acr	r9
8000b728:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b72c:	58 04       	cp.w	r4,0
8000b72e:	5c 25       	cpc	r5

8000b730 <__avr32_f64_div_round_subnormal>:
8000b730:	f4 08 13 00 	cpc	r8,r10
8000b734:	f6 09 13 00 	cpc	r9,r11
8000b738:	5f 36       	srlo	r6
8000b73a:	f8 06 17 00 	moveq	r6,r12
8000b73e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b742:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b746:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b74a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b74e:	ed be 00 1f 	bld	lr,0x1f
8000b752:	ef bb 00 1f 	bst	r11,0x1f
8000b756:	0c 0a       	add	r10,r6
8000b758:	5c 0b       	acr	r11
8000b75a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b75e:	e4 1b 00 0f 	andh	r11,0xf
8000b762:	14 4b       	or	r11,r10
8000b764:	e0 81 00 a7 	brne	8000b8b2 <__avr32_f64_div_res_subnormal+0x98>
8000b768:	f2 06 16 14 	lsr	r6,r9,0x14
8000b76c:	ab d6       	cbr	r6,0xb
8000b76e:	e0 46 07 ff 	cp.w	r6,2047
8000b772:	e0 81 00 a4 	brne	8000b8ba <__avr32_f64_div_res_subnormal+0xa0>
8000b776:	c9 e8       	rjmp	8000b8b2 <__avr32_f64_div_res_subnormal+0x98>
8000b778:	e4 19 00 0f 	andh	r9,0xf
8000b77c:	10 49       	or	r9,r8
8000b77e:	e0 81 00 9a 	brne	8000b8b2 <__avr32_f64_div_res_subnormal+0x98>
8000b782:	c9 28       	rjmp	8000b8a6 <__avr32_f64_div_res_subnormal+0x8c>
8000b784:	a3 7b       	lsl	r11,0x3
8000b786:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b78a:	a3 7a       	lsl	r10,0x3
8000b78c:	f5 eb 10 04 	or	r4,r10,r11
8000b790:	e0 80 00 a0 	breq	8000b8d0 <__avr32_f64_div_op1_zero>
8000b794:	f6 04 12 00 	clz	r4,r11
8000b798:	c1 70       	breq	8000b7c6 <__avr32_f64_div_round_subnormal+0x96>
8000b79a:	c0 c3       	brcs	8000b7b2 <__avr32_f64_div_round_subnormal+0x82>
8000b79c:	e8 05 11 20 	rsub	r5,r4,32
8000b7a0:	f6 04 09 4b 	lsl	r11,r11,r4
8000b7a4:	f4 05 0a 45 	lsr	r5,r10,r5
8000b7a8:	0a 4b       	or	r11,r5
8000b7aa:	f4 04 09 4a 	lsl	r10,r10,r4
8000b7ae:	08 17       	sub	r7,r4
8000b7b0:	c0 b8       	rjmp	8000b7c6 <__avr32_f64_div_round_subnormal+0x96>
8000b7b2:	f4 04 12 00 	clz	r4,r10
8000b7b6:	f9 b4 03 00 	movlo	r4,0
8000b7ba:	f7 b4 02 e0 	subhs	r4,-32
8000b7be:	f4 04 09 4b 	lsl	r11,r10,r4
8000b7c2:	30 0a       	mov	r10,0
8000b7c4:	08 17       	sub	r7,r4
8000b7c6:	a3 8a       	lsr	r10,0x2
8000b7c8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b7cc:	a3 8b       	lsr	r11,0x2
8000b7ce:	c1 1b       	rjmp	8000b5f0 <__avr32_f64_div+0x20>
8000b7d0:	a3 79       	lsl	r9,0x3
8000b7d2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b7d6:	a3 78       	lsl	r8,0x3
8000b7d8:	f3 e8 10 04 	or	r4,r9,r8
8000b7dc:	c6 f0       	breq	8000b8ba <__avr32_f64_div_res_subnormal+0xa0>
8000b7de:	f2 04 12 00 	clz	r4,r9
8000b7e2:	c1 70       	breq	8000b810 <__avr32_f64_div_round_subnormal+0xe0>
8000b7e4:	c0 c3       	brcs	8000b7fc <__avr32_f64_div_round_subnormal+0xcc>
8000b7e6:	e8 05 11 20 	rsub	r5,r4,32
8000b7ea:	f2 04 09 49 	lsl	r9,r9,r4
8000b7ee:	f0 05 0a 45 	lsr	r5,r8,r5
8000b7f2:	0a 49       	or	r9,r5
8000b7f4:	f0 04 09 48 	lsl	r8,r8,r4
8000b7f8:	08 16       	sub	r6,r4
8000b7fa:	c0 b8       	rjmp	8000b810 <__avr32_f64_div_round_subnormal+0xe0>
8000b7fc:	f0 04 12 00 	clz	r4,r8
8000b800:	f9 b4 03 00 	movlo	r4,0
8000b804:	f7 b4 02 e0 	subhs	r4,-32
8000b808:	f0 04 09 49 	lsl	r9,r8,r4
8000b80c:	30 08       	mov	r8,0
8000b80e:	08 16       	sub	r6,r4
8000b810:	a3 88       	lsr	r8,0x2
8000b812:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b816:	a3 89       	lsr	r9,0x2
8000b818:	cf ca       	rjmp	8000b610 <__avr32_f64_div+0x40>

8000b81a <__avr32_f64_div_res_subnormal>:
8000b81a:	5c 37       	neg	r7
8000b81c:	2f f7       	sub	r7,-1
8000b81e:	f1 b7 04 c0 	satu	r7,0x6
8000b822:	e0 47 00 20 	cp.w	r7,32
8000b826:	c1 54       	brge	8000b850 <__avr32_f64_div_res_subnormal+0x36>
8000b828:	ee 06 11 20 	rsub	r6,r7,32
8000b82c:	e4 07 0a 42 	lsr	r2,r2,r7
8000b830:	e6 06 09 4c 	lsl	r12,r3,r6
8000b834:	18 42       	or	r2,r12
8000b836:	e6 07 0a 43 	lsr	r3,r3,r7
8000b83a:	f4 06 09 41 	lsl	r1,r10,r6
8000b83e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b842:	f6 06 09 4c 	lsl	r12,r11,r6
8000b846:	18 4a       	or	r10,r12
8000b848:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b84c:	30 00       	mov	r0,0
8000b84e:	c1 58       	rjmp	8000b878 <__avr32_f64_div_res_subnormal+0x5e>
8000b850:	ee 06 11 20 	rsub	r6,r7,32
8000b854:	f9 b0 00 00 	moveq	r0,0
8000b858:	f9 bc 00 00 	moveq	r12,0
8000b85c:	c0 50       	breq	8000b866 <__avr32_f64_div_res_subnormal+0x4c>
8000b85e:	f4 06 09 40 	lsl	r0,r10,r6
8000b862:	f6 06 09 4c 	lsl	r12,r11,r6
8000b866:	e6 07 0a 42 	lsr	r2,r3,r7
8000b86a:	30 03       	mov	r3,0
8000b86c:	f4 07 0a 41 	lsr	r1,r10,r7
8000b870:	18 41       	or	r1,r12
8000b872:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b876:	30 0b       	mov	r11,0
8000b878:	e0 12 ff 00 	andl	r2,0xff00
8000b87c:	e8 12 00 80 	orl	r2,0x80
8000b880:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b884:	e4 09 07 46 	macu.d	r6,r2,r9
8000b888:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b88c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b890:	0c 05       	add	r5,r6
8000b892:	f0 07 00 48 	adc	r8,r8,r7
8000b896:	5c 09       	acr	r9
8000b898:	30 07       	mov	r7,0
8000b89a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b89e:	00 34       	cp.w	r4,r0
8000b8a0:	e2 05 13 00 	cpc	r5,r1
8000b8a4:	c4 6b       	rjmp	8000b730 <__avr32_f64_div_round_subnormal>
8000b8a6:	1c 9b       	mov	r11,lr
8000b8a8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b8ac:	30 0a       	mov	r10,0
8000b8ae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b8b2:	3f fb       	mov	r11,-1
8000b8b4:	30 0a       	mov	r10,0
8000b8b6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b8ba:	f5 eb 10 04 	or	r4,r10,r11
8000b8be:	c0 90       	breq	8000b8d0 <__avr32_f64_div_op1_zero>
8000b8c0:	1c 9b       	mov	r11,lr
8000b8c2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b8c6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b8ca:	30 0a       	mov	r10,0
8000b8cc:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b8d0 <__avr32_f64_div_op1_zero>:
8000b8d0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b8d4:	ce f0       	breq	8000b8b2 <__avr32_f64_div_res_subnormal+0x98>
8000b8d6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b8da:	e0 44 07 ff 	cp.w	r4,2047
8000b8de:	ce 41       	brne	8000b8a6 <__avr32_f64_div_res_subnormal+0x8c>
8000b8e0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b8e4:	ce 10       	breq	8000b8a6 <__avr32_f64_div_res_subnormal+0x8c>
8000b8e6:	ce 6b       	rjmp	8000b8b2 <__avr32_f64_div_res_subnormal+0x98>

8000b8e8 <__avr32_udiv64>:
8000b8e8:	d4 31       	pushm	r0-r7,lr
8000b8ea:	1a 97       	mov	r7,sp
8000b8ec:	20 3d       	sub	sp,12
8000b8ee:	10 9c       	mov	r12,r8
8000b8f0:	12 9e       	mov	lr,r9
8000b8f2:	14 93       	mov	r3,r10
8000b8f4:	58 09       	cp.w	r9,0
8000b8f6:	e0 81 00 bd 	brne	8000ba70 <__avr32_udiv64+0x188>
8000b8fa:	16 38       	cp.w	r8,r11
8000b8fc:	e0 88 00 40 	brls	8000b97c <__avr32_udiv64+0x94>
8000b900:	f0 08 12 00 	clz	r8,r8
8000b904:	c0 d0       	breq	8000b91e <__avr32_udiv64+0x36>
8000b906:	f6 08 09 4b 	lsl	r11,r11,r8
8000b90a:	f0 09 11 20 	rsub	r9,r8,32
8000b90e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b912:	f4 09 0a 49 	lsr	r9,r10,r9
8000b916:	f4 08 09 43 	lsl	r3,r10,r8
8000b91a:	f3 eb 10 0b 	or	r11,r9,r11
8000b91e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b922:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b926:	f6 0e 0d 00 	divu	r0,r11,lr
8000b92a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b92e:	00 99       	mov	r9,r0
8000b930:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b934:	e0 0a 02 48 	mul	r8,r0,r10
8000b938:	10 3b       	cp.w	r11,r8
8000b93a:	c0 a2       	brcc	8000b94e <__avr32_udiv64+0x66>
8000b93c:	20 19       	sub	r9,1
8000b93e:	18 0b       	add	r11,r12
8000b940:	18 3b       	cp.w	r11,r12
8000b942:	c0 63       	brcs	8000b94e <__avr32_udiv64+0x66>
8000b944:	10 3b       	cp.w	r11,r8
8000b946:	f7 b9 03 01 	sublo	r9,1
8000b94a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b94e:	f6 08 01 01 	sub	r1,r11,r8
8000b952:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b956:	e2 0e 0d 00 	divu	r0,r1,lr
8000b95a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b95e:	00 98       	mov	r8,r0
8000b960:	e0 0a 02 4a 	mul	r10,r0,r10
8000b964:	14 33       	cp.w	r3,r10
8000b966:	c0 82       	brcc	8000b976 <__avr32_udiv64+0x8e>
8000b968:	20 18       	sub	r8,1
8000b96a:	18 03       	add	r3,r12
8000b96c:	18 33       	cp.w	r3,r12
8000b96e:	c0 43       	brcs	8000b976 <__avr32_udiv64+0x8e>
8000b970:	14 33       	cp.w	r3,r10
8000b972:	f7 b8 03 01 	sublo	r8,1
8000b976:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b97a:	cd f8       	rjmp	8000bb38 <__avr32_udiv64+0x250>
8000b97c:	58 08       	cp.w	r8,0
8000b97e:	c0 51       	brne	8000b988 <__avr32_udiv64+0xa0>
8000b980:	30 19       	mov	r9,1
8000b982:	f2 08 0d 08 	divu	r8,r9,r8
8000b986:	10 9c       	mov	r12,r8
8000b988:	f8 06 12 00 	clz	r6,r12
8000b98c:	c0 41       	brne	8000b994 <__avr32_udiv64+0xac>
8000b98e:	18 1b       	sub	r11,r12
8000b990:	30 19       	mov	r9,1
8000b992:	c4 08       	rjmp	8000ba12 <__avr32_udiv64+0x12a>
8000b994:	ec 01 11 20 	rsub	r1,r6,32
8000b998:	f4 01 0a 49 	lsr	r9,r10,r1
8000b99c:	f8 06 09 4c 	lsl	r12,r12,r6
8000b9a0:	f6 06 09 48 	lsl	r8,r11,r6
8000b9a4:	f6 01 0a 41 	lsr	r1,r11,r1
8000b9a8:	f3 e8 10 08 	or	r8,r9,r8
8000b9ac:	f8 03 16 10 	lsr	r3,r12,0x10
8000b9b0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b9b4:	e2 03 0d 00 	divu	r0,r1,r3
8000b9b8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b9bc:	00 9e       	mov	lr,r0
8000b9be:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b9c2:	e0 05 02 49 	mul	r9,r0,r5
8000b9c6:	12 3b       	cp.w	r11,r9
8000b9c8:	c0 a2       	brcc	8000b9dc <__avr32_udiv64+0xf4>
8000b9ca:	20 1e       	sub	lr,1
8000b9cc:	18 0b       	add	r11,r12
8000b9ce:	18 3b       	cp.w	r11,r12
8000b9d0:	c0 63       	brcs	8000b9dc <__avr32_udiv64+0xf4>
8000b9d2:	12 3b       	cp.w	r11,r9
8000b9d4:	f7 be 03 01 	sublo	lr,1
8000b9d8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b9dc:	12 1b       	sub	r11,r9
8000b9de:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b9e2:	f6 03 0d 02 	divu	r2,r11,r3
8000b9e6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b9ea:	04 99       	mov	r9,r2
8000b9ec:	e4 05 02 4b 	mul	r11,r2,r5
8000b9f0:	16 38       	cp.w	r8,r11
8000b9f2:	c0 a2       	brcc	8000ba06 <__avr32_udiv64+0x11e>
8000b9f4:	20 19       	sub	r9,1
8000b9f6:	18 08       	add	r8,r12
8000b9f8:	18 38       	cp.w	r8,r12
8000b9fa:	c0 63       	brcs	8000ba06 <__avr32_udiv64+0x11e>
8000b9fc:	16 38       	cp.w	r8,r11
8000b9fe:	f7 b9 03 01 	sublo	r9,1
8000ba02:	f1 dc e3 08 	addcs	r8,r8,r12
8000ba06:	f4 06 09 43 	lsl	r3,r10,r6
8000ba0a:	f0 0b 01 0b 	sub	r11,r8,r11
8000ba0e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ba12:	f8 06 16 10 	lsr	r6,r12,0x10
8000ba16:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ba1a:	f6 06 0d 00 	divu	r0,r11,r6
8000ba1e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba22:	00 9a       	mov	r10,r0
8000ba24:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba28:	e0 0e 02 48 	mul	r8,r0,lr
8000ba2c:	10 3b       	cp.w	r11,r8
8000ba2e:	c0 a2       	brcc	8000ba42 <__avr32_udiv64+0x15a>
8000ba30:	20 1a       	sub	r10,1
8000ba32:	18 0b       	add	r11,r12
8000ba34:	18 3b       	cp.w	r11,r12
8000ba36:	c0 63       	brcs	8000ba42 <__avr32_udiv64+0x15a>
8000ba38:	10 3b       	cp.w	r11,r8
8000ba3a:	f7 ba 03 01 	sublo	r10,1
8000ba3e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba42:	f6 08 01 01 	sub	r1,r11,r8
8000ba46:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba4a:	e2 06 0d 00 	divu	r0,r1,r6
8000ba4e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ba52:	00 98       	mov	r8,r0
8000ba54:	e0 0e 02 4b 	mul	r11,r0,lr
8000ba58:	16 33       	cp.w	r3,r11
8000ba5a:	c0 82       	brcc	8000ba6a <__avr32_udiv64+0x182>
8000ba5c:	20 18       	sub	r8,1
8000ba5e:	18 03       	add	r3,r12
8000ba60:	18 33       	cp.w	r3,r12
8000ba62:	c0 43       	brcs	8000ba6a <__avr32_udiv64+0x182>
8000ba64:	16 33       	cp.w	r3,r11
8000ba66:	f7 b8 03 01 	sublo	r8,1
8000ba6a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ba6e:	c6 98       	rjmp	8000bb40 <__avr32_udiv64+0x258>
8000ba70:	16 39       	cp.w	r9,r11
8000ba72:	e0 8b 00 65 	brhi	8000bb3c <__avr32_udiv64+0x254>
8000ba76:	f2 09 12 00 	clz	r9,r9
8000ba7a:	c0 b1       	brne	8000ba90 <__avr32_udiv64+0x1a8>
8000ba7c:	10 3a       	cp.w	r10,r8
8000ba7e:	5f 2a       	srhs	r10
8000ba80:	1c 3b       	cp.w	r11,lr
8000ba82:	5f b8       	srhi	r8
8000ba84:	10 4a       	or	r10,r8
8000ba86:	f2 0a 18 00 	cp.b	r10,r9
8000ba8a:	c5 90       	breq	8000bb3c <__avr32_udiv64+0x254>
8000ba8c:	30 18       	mov	r8,1
8000ba8e:	c5 98       	rjmp	8000bb40 <__avr32_udiv64+0x258>
8000ba90:	f0 09 09 46 	lsl	r6,r8,r9
8000ba94:	f2 03 11 20 	rsub	r3,r9,32
8000ba98:	fc 09 09 4e 	lsl	lr,lr,r9
8000ba9c:	f0 03 0a 48 	lsr	r8,r8,r3
8000baa0:	f6 09 09 4c 	lsl	r12,r11,r9
8000baa4:	f4 03 0a 42 	lsr	r2,r10,r3
8000baa8:	ef 46 ff f4 	st.w	r7[-12],r6
8000baac:	f6 03 0a 43 	lsr	r3,r11,r3
8000bab0:	18 42       	or	r2,r12
8000bab2:	f1 ee 10 0c 	or	r12,r8,lr
8000bab6:	f8 01 16 10 	lsr	r1,r12,0x10
8000baba:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000babe:	e6 01 0d 04 	divu	r4,r3,r1
8000bac2:	e4 03 16 10 	lsr	r3,r2,0x10
8000bac6:	08 9e       	mov	lr,r4
8000bac8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bacc:	e8 06 02 48 	mul	r8,r4,r6
8000bad0:	10 33       	cp.w	r3,r8
8000bad2:	c0 a2       	brcc	8000bae6 <__avr32_udiv64+0x1fe>
8000bad4:	20 1e       	sub	lr,1
8000bad6:	18 03       	add	r3,r12
8000bad8:	18 33       	cp.w	r3,r12
8000bada:	c0 63       	brcs	8000bae6 <__avr32_udiv64+0x1fe>
8000badc:	10 33       	cp.w	r3,r8
8000bade:	f7 be 03 01 	sublo	lr,1
8000bae2:	e7 dc e3 03 	addcs	r3,r3,r12
8000bae6:	10 13       	sub	r3,r8
8000bae8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000baec:	e6 01 0d 00 	divu	r0,r3,r1
8000baf0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000baf4:	00 98       	mov	r8,r0
8000baf6:	e0 06 02 46 	mul	r6,r0,r6
8000bafa:	0c 3b       	cp.w	r11,r6
8000bafc:	c0 a2       	brcc	8000bb10 <__avr32_udiv64+0x228>
8000bafe:	20 18       	sub	r8,1
8000bb00:	18 0b       	add	r11,r12
8000bb02:	18 3b       	cp.w	r11,r12
8000bb04:	c0 63       	brcs	8000bb10 <__avr32_udiv64+0x228>
8000bb06:	0c 3b       	cp.w	r11,r6
8000bb08:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb0c:	f7 b8 03 01 	sublo	r8,1
8000bb10:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bb14:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bb18:	0c 1b       	sub	r11,r6
8000bb1a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bb1e:	06 95       	mov	r5,r3
8000bb20:	16 35       	cp.w	r5,r11
8000bb22:	e0 8b 00 0a 	brhi	8000bb36 <__avr32_udiv64+0x24e>
8000bb26:	5f 0b       	sreq	r11
8000bb28:	f4 09 09 49 	lsl	r9,r10,r9
8000bb2c:	12 32       	cp.w	r2,r9
8000bb2e:	5f b9       	srhi	r9
8000bb30:	f7 e9 00 09 	and	r9,r11,r9
8000bb34:	c0 60       	breq	8000bb40 <__avr32_udiv64+0x258>
8000bb36:	20 18       	sub	r8,1
8000bb38:	30 09       	mov	r9,0
8000bb3a:	c0 38       	rjmp	8000bb40 <__avr32_udiv64+0x258>
8000bb3c:	30 09       	mov	r9,0
8000bb3e:	12 98       	mov	r8,r9
8000bb40:	10 9a       	mov	r10,r8
8000bb42:	12 93       	mov	r3,r9
8000bb44:	10 92       	mov	r2,r8
8000bb46:	12 9b       	mov	r11,r9
8000bb48:	2f dd       	sub	sp,-12
8000bb4a:	d8 32       	popm	r0-r7,pc

8000bb4c <__avr32_umod64>:
8000bb4c:	d4 31       	pushm	r0-r7,lr
8000bb4e:	1a 97       	mov	r7,sp
8000bb50:	20 3d       	sub	sp,12
8000bb52:	10 9c       	mov	r12,r8
8000bb54:	12 95       	mov	r5,r9
8000bb56:	14 9e       	mov	lr,r10
8000bb58:	16 91       	mov	r1,r11
8000bb5a:	16 96       	mov	r6,r11
8000bb5c:	58 09       	cp.w	r9,0
8000bb5e:	e0 81 00 81 	brne	8000bc60 <__avr32_umod64+0x114>
8000bb62:	16 38       	cp.w	r8,r11
8000bb64:	e0 88 00 12 	brls	8000bb88 <__avr32_umod64+0x3c>
8000bb68:	f0 08 12 00 	clz	r8,r8
8000bb6c:	c4 e0       	breq	8000bc08 <__avr32_umod64+0xbc>
8000bb6e:	f6 08 09 46 	lsl	r6,r11,r8
8000bb72:	f8 08 09 4c 	lsl	r12,r12,r8
8000bb76:	f0 0b 11 20 	rsub	r11,r8,32
8000bb7a:	f4 08 09 4e 	lsl	lr,r10,r8
8000bb7e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bb82:	f7 e6 10 06 	or	r6,r11,r6
8000bb86:	c4 18       	rjmp	8000bc08 <__avr32_umod64+0xbc>
8000bb88:	58 08       	cp.w	r8,0
8000bb8a:	c0 51       	brne	8000bb94 <__avr32_umod64+0x48>
8000bb8c:	30 19       	mov	r9,1
8000bb8e:	f2 08 0d 08 	divu	r8,r9,r8
8000bb92:	10 9c       	mov	r12,r8
8000bb94:	f8 08 12 00 	clz	r8,r12
8000bb98:	c0 31       	brne	8000bb9e <__avr32_umod64+0x52>
8000bb9a:	18 16       	sub	r6,r12
8000bb9c:	c3 68       	rjmp	8000bc08 <__avr32_umod64+0xbc>
8000bb9e:	f0 03 11 20 	rsub	r3,r8,32
8000bba2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bba6:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbaa:	ec 08 09 49 	lsl	r9,r6,r8
8000bbae:	ec 03 0a 43 	lsr	r3,r6,r3
8000bbb2:	f7 e9 10 09 	or	r9,r11,r9
8000bbb6:	f8 05 16 10 	lsr	r5,r12,0x10
8000bbba:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bbbe:	e6 05 0d 02 	divu	r2,r3,r5
8000bbc2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bbc6:	ec 02 02 4b 	mul	r11,r6,r2
8000bbca:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bbce:	16 3e       	cp.w	lr,r11
8000bbd0:	c0 72       	brcc	8000bbde <__avr32_umod64+0x92>
8000bbd2:	18 0e       	add	lr,r12
8000bbd4:	18 3e       	cp.w	lr,r12
8000bbd6:	c0 43       	brcs	8000bbde <__avr32_umod64+0x92>
8000bbd8:	16 3e       	cp.w	lr,r11
8000bbda:	fd dc e3 0e 	addcs	lr,lr,r12
8000bbde:	fc 0b 01 03 	sub	r3,lr,r11
8000bbe2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bbe6:	e6 05 0d 02 	divu	r2,r3,r5
8000bbea:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bbee:	a5 36       	mul	r6,r2
8000bbf0:	0c 39       	cp.w	r9,r6
8000bbf2:	c0 72       	brcc	8000bc00 <__avr32_umod64+0xb4>
8000bbf4:	18 09       	add	r9,r12
8000bbf6:	18 39       	cp.w	r9,r12
8000bbf8:	c0 43       	brcs	8000bc00 <__avr32_umod64+0xb4>
8000bbfa:	0c 39       	cp.w	r9,r6
8000bbfc:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc00:	f2 06 01 06 	sub	r6,r9,r6
8000bc04:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc08:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bc0c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bc10:	ec 0a 0d 02 	divu	r2,r6,r10
8000bc14:	fc 09 16 10 	lsr	r9,lr,0x10
8000bc18:	ea 02 02 4b 	mul	r11,r5,r2
8000bc1c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc20:	16 39       	cp.w	r9,r11
8000bc22:	c0 72       	brcc	8000bc30 <__avr32_umod64+0xe4>
8000bc24:	18 09       	add	r9,r12
8000bc26:	18 39       	cp.w	r9,r12
8000bc28:	c0 43       	brcs	8000bc30 <__avr32_umod64+0xe4>
8000bc2a:	16 39       	cp.w	r9,r11
8000bc2c:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc30:	f2 0b 01 0b 	sub	r11,r9,r11
8000bc34:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bc38:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bc3c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bc40:	ea 0a 02 4a 	mul	r10,r5,r10
8000bc44:	14 3e       	cp.w	lr,r10
8000bc46:	c0 72       	brcc	8000bc54 <__avr32_umod64+0x108>
8000bc48:	18 0e       	add	lr,r12
8000bc4a:	18 3e       	cp.w	lr,r12
8000bc4c:	c0 43       	brcs	8000bc54 <__avr32_umod64+0x108>
8000bc4e:	14 3e       	cp.w	lr,r10
8000bc50:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc54:	fc 0a 01 0a 	sub	r10,lr,r10
8000bc58:	30 0b       	mov	r11,0
8000bc5a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bc5e:	c7 b8       	rjmp	8000bd54 <__avr32_umod64+0x208>
8000bc60:	16 39       	cp.w	r9,r11
8000bc62:	e0 8b 00 79 	brhi	8000bd54 <__avr32_umod64+0x208>
8000bc66:	f2 09 12 00 	clz	r9,r9
8000bc6a:	c1 21       	brne	8000bc8e <__avr32_umod64+0x142>
8000bc6c:	10 3a       	cp.w	r10,r8
8000bc6e:	5f 2b       	srhs	r11
8000bc70:	0a 31       	cp.w	r1,r5
8000bc72:	5f ba       	srhi	r10
8000bc74:	f7 ea 10 0a 	or	r10,r11,r10
8000bc78:	f2 0a 18 00 	cp.b	r10,r9
8000bc7c:	c0 60       	breq	8000bc88 <__avr32_umod64+0x13c>
8000bc7e:	fc 08 01 0c 	sub	r12,lr,r8
8000bc82:	e2 05 01 46 	sbc	r6,r1,r5
8000bc86:	18 9e       	mov	lr,r12
8000bc88:	0c 9b       	mov	r11,r6
8000bc8a:	1c 9a       	mov	r10,lr
8000bc8c:	c6 48       	rjmp	8000bd54 <__avr32_umod64+0x208>
8000bc8e:	ea 09 09 4c 	lsl	r12,r5,r9
8000bc92:	f2 06 11 20 	rsub	r6,r9,32
8000bc96:	f6 09 09 4b 	lsl	r11,r11,r9
8000bc9a:	f0 09 09 42 	lsl	r2,r8,r9
8000bc9e:	ef 46 ff f4 	st.w	r7[-12],r6
8000bca2:	f0 06 0a 48 	lsr	r8,r8,r6
8000bca6:	18 48       	or	r8,r12
8000bca8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bcac:	f4 09 09 43 	lsl	r3,r10,r9
8000bcb0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bcb4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bcb8:	16 4a       	or	r10,r11
8000bcba:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bcbe:	f8 0b 0d 04 	divu	r4,r12,r11
8000bcc2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bcc6:	08 91       	mov	r1,r4
8000bcc8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bccc:	e8 0e 02 46 	mul	r6,r4,lr
8000bcd0:	0c 3c       	cp.w	r12,r6
8000bcd2:	c0 a2       	brcc	8000bce6 <__avr32_umod64+0x19a>
8000bcd4:	20 11       	sub	r1,1
8000bcd6:	10 0c       	add	r12,r8
8000bcd8:	10 3c       	cp.w	r12,r8
8000bcda:	c0 63       	brcs	8000bce6 <__avr32_umod64+0x19a>
8000bcdc:	0c 3c       	cp.w	r12,r6
8000bcde:	f7 b1 03 01 	sublo	r1,1
8000bce2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bce6:	0c 1c       	sub	r12,r6
8000bce8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bcec:	f8 0b 0d 04 	divu	r4,r12,r11
8000bcf0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bcf4:	08 96       	mov	r6,r4
8000bcf6:	e8 0e 02 4e 	mul	lr,r4,lr
8000bcfa:	1c 3b       	cp.w	r11,lr
8000bcfc:	c0 a2       	brcc	8000bd10 <__avr32_umod64+0x1c4>
8000bcfe:	20 16       	sub	r6,1
8000bd00:	10 0b       	add	r11,r8
8000bd02:	10 3b       	cp.w	r11,r8
8000bd04:	c0 63       	brcs	8000bd10 <__avr32_umod64+0x1c4>
8000bd06:	1c 3b       	cp.w	r11,lr
8000bd08:	f7 b6 03 01 	sublo	r6,1
8000bd0c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bd10:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bd14:	1c 1b       	sub	r11,lr
8000bd16:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bd1a:	00 9e       	mov	lr,r0
8000bd1c:	02 9c       	mov	r12,r1
8000bd1e:	16 3c       	cp.w	r12,r11
8000bd20:	e0 8b 00 08 	brhi	8000bd30 <__avr32_umod64+0x1e4>
8000bd24:	5f 06       	sreq	r6
8000bd26:	06 30       	cp.w	r0,r3
8000bd28:	5f ba       	srhi	r10
8000bd2a:	ed ea 00 0a 	and	r10,r6,r10
8000bd2e:	c0 60       	breq	8000bd3a <__avr32_umod64+0x1ee>
8000bd30:	fc 02 01 04 	sub	r4,lr,r2
8000bd34:	f8 08 01 4c 	sbc	r12,r12,r8
8000bd38:	08 9e       	mov	lr,r4
8000bd3a:	e6 0e 01 0a 	sub	r10,r3,lr
8000bd3e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bd42:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bd46:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bd4a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bd4e:	f8 01 09 4c 	lsl	r12,r12,r1
8000bd52:	18 4a       	or	r10,r12
8000bd54:	2f dd       	sub	sp,-12
8000bd56:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 6f b0 	sub	pc,pc,28592

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c6 1f 	rcall	80004b44 <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c6 18 	rcall	80004b44 <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c6 11 	rcall	80004b44 <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c6 0a 	rcall	80004b44 <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
