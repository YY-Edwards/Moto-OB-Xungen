
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bc98  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000de00  8000de00  0000e200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000164c  8000e000  8000e000  0000e400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000f64c  8000f64c  0000fa4c  2**0
                  ALLOC
  6 .data         00000a54  00000004  8000f650  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00009c78  00000a58  800100a4  00010658  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00003844  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002e240  00000000  00000000  00015664  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007812  00000000  00000000  000438a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000dca1  00000000  00000000  0004b0b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000040f0  00000000  00000000  00058d58  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000082df  00000000  00000000  0005ce48  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000ff95  00000000  00000000  00065127  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001848  00000000  00000000  000750c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b3 f4 	sub	pc,pc,-19468

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 1c       	sub	r12,r7

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 70       	tst	r0,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	e0 00       	*unknown*
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	7f 68       	ld.w	r8,pc[0x58]

80002050 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 63       	and	r3,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	e0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	7f 68       	ld.w	r8,pc[0x58]
80002080:	00 00       	add	r0,r0
80002082:	0a 62       	and	r2,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	e0 10 80 00 	andl	r0,0x8000
80002096:	7f 68       	ld.w	r8,pc[0x58]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	e0 30 80 00 	sub	r0,98304
800020aa:	7f 68       	ld.w	r8,pc[0x58]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	e0 4c 80 00 	cp.w	r12,32768
800020be:	7f 68       	ld.w	r8,pc[0x58]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	e0 68 80 00 	mov	r8,32768
800020d2:	7f 68       	ld.w	r8,pc[0x58]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	e0 80 80 00 	breq	8001212e <_data_lma+0x2ade>
80002132:	7f 68       	ld.w	r8,pc[0x58]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	e0 98 80 00 	brls	80032136 <_data_lma+0x22ae6>
8000213a:	e0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	e0 c4 80 00 	sub	r4,r0,-32768
80002142:	e0 e0 eb cd 	ld.d	r0,r0[-5171]

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	e0 f8 80 00 	ld.w	r8,r0[-32768]
80002182:	7f 68       	ld.w	r8,pc[0x58]
80002184:	00 00       	add	r0,r0
80002186:	00 08       	add	r8,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	e1 0c 80 00 	ld.sh	r12,r0[-32768]
8000218e:	e1 1c d4 31 	ld.uh	r12,r0[-11215]

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	e1 30 80 00 	ld.ub	r0,r0[-32768]
8000224a:	7f 68       	ld.w	r8,pc[0x58]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	e1 50 80 00 	st.h	r0[-32768],r0
80002252:	e1 64 80 00 	st.b	r0[-32768],r4
80002256:	e1 7c 80 00 	stcond	r0[-32768],r12
8000225a:	e1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	e1 c4 80 00 	ldm	r4,pc
80002262:	e1 ec 80 00 	sthh.w	r0[r0],r0:b,r12:b
80002266:	e2 10 80 00 	andl	r0,0x8000,COH
8000226a:	e2 38 eb cd 	sub	r8,256973

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	e2 5c 80 00 	cp.w	r12,229376
800022a6:	7f 68       	ld.w	r8,pc[0x58]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	e1 50 80 00 	st.h	r0[-32768],r0
800022ae:	e2 74 eb cd 	mov	r4,256973

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 51       	brne	800022ca <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
800022c2:	48 cc       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x40>
800022c4:	f0 1f 00 0c 	mcall	800022f4 <BatteryLevel_brdcst_func+0x44>
800022c8:	c0 48       	rjmp	800022d0 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
800022ca:	48 cc       	lddpc	r12,800022f8 <BatteryLevel_brdcst_func+0x48>
800022cc:	f0 1f 00 0a 	mcall	800022f4 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
800022d0:	0f 98       	ld.ub	r8,r7[0x1]
800022d2:	1a d8       	st.w	--sp,r8
800022d4:	48 ac       	lddpc	r12,800022fc <BatteryLevel_brdcst_func+0x4c>
800022d6:	f0 1f 00 08 	mcall	800022f4 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
800022da:	8e 98       	ld.uh	r8,r7[0x2]
800022dc:	1a d8       	st.w	--sp,r8
800022de:	48 9c       	lddpc	r12,80002300 <BatteryLevel_brdcst_func+0x50>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 88       	lddpc	r8,80002304 <BatteryLevel_brdcst_func+0x54>
800022e8:	b0 89       	st.b	r8[0x0],r9
800022ea:	2f ed       	sub	sp,-8

}
800022ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	e2 90 80 00 	breq	800722f2 <_data_lma+0x62ca2>
800022f6:	7f 68       	ld.w	r8,pc[0x58]
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	e2 a0 80 00 	rcall	800522fa <_data_lma+0x42caa>
800022fe:	e2 b4       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	e2 cc 00 00 	sub	r12,r1,0
80002306:	0a 84       	andn	r4,r5

80002308 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
80002308:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
8000230a:	19 a8       	ld.ub	r8,r12[0x2]
8000230c:	30 19       	mov	r9,1
8000230e:	f2 08 18 00 	cp.b	r8,r9
80002312:	c0 51       	brne	8000231c <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002314:	48 6c       	lddpc	r12,8000232c <ShutDown_brdcst_func+0x24>
80002316:	f0 1f 00 07 	mcall	80002330 <ShutDown_brdcst_func+0x28>
8000231a:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
8000231c:	30 29       	mov	r9,2
8000231e:	f2 08 18 00 	cp.b	r8,r9
80002322:	c0 41       	brne	8000232a <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002324:	48 4c       	lddpc	r12,80002334 <ShutDown_brdcst_func+0x2c>
80002326:	f0 1f 00 03 	mcall	80002330 <ShutDown_brdcst_func+0x28>
8000232a:	d8 02       	popm	pc
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	e2 e4 80 00 	ld.d	r4,r1[-32768]
80002332:	7f 68       	ld.w	r8,pc[0x58]
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	e2 f8 eb cd 	ld.w	r8,r1[-5171]

80002338 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002338:	eb cd 40 80 	pushm	r7,lr
8000233c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000233e:	19 a9       	ld.ub	r9,r12[0x2]
80002340:	30 08       	mov	r8,0
80002342:	f0 09 18 00 	cp.b	r9,r8
80002346:	c0 61       	brne	80002352 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
80002348:	48 dc       	lddpc	r12,8000237c <DataSession_reply_func+0x44>
8000234a:	f0 1f 00 0e 	mcall	80002380 <DataSession_reply_func+0x48>
8000234e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002352:	48 dc       	lddpc	r12,80002384 <DataSession_reply_func+0x4c>
80002354:	f0 1f 00 0b 	mcall	80002380 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
80002358:	0f a8       	ld.ub	r8,r7[0x2]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 bc       	lddpc	r12,80002388 <DataSession_reply_func+0x50>
8000235e:	f0 1f 00 09 	mcall	80002380 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002362:	0f b8       	ld.ub	r8,r7[0x3]
80002364:	1a d8       	st.w	--sp,r8
80002366:	48 ac       	lddpc	r12,8000238c <DataSession_reply_func+0x54>
80002368:	f0 1f 00 06 	mcall	80002380 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
8000236c:	0f c8       	ld.ub	r8,r7[0x4]
8000236e:	1a d8       	st.w	--sp,r8
80002370:	48 8c       	lddpc	r12,80002390 <DataSession_reply_func+0x58>
80002372:	f0 1f 00 04 	mcall	80002380 <DataSession_reply_func+0x48>
80002376:	2f dd       	sub	sp,-12
80002378:	e3 cd 80 80 	ldm	sp++,r7,pc
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	e3 08 80 00 	ld.sh	r8,r1[-32768]
80002382:	7f 68       	ld.w	r8,pc[0x58]
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	e3 18 80 00 	ld.uh	r8,r1[-32768]
8000238a:	e3 28 80 00 	ld.sb	r8,r1[-32768]
8000238e:	e3 38 80 00 	ld.ub	r8,r1[-32768]
80002392:	e3 44 eb cd 	st.w	r1[-5171],r4

80002394 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002394:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002398:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000239c:	0f 98       	ld.ub	r8,r7[0x1]
8000239e:	1a d8       	st.w	--sp,r8
800023a0:	48 bc       	lddpc	r12,800023cc <CallControl_brdcst_func+0x38>
800023a2:	f0 1f 00 0c 	mcall	800023d0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800023a6:	2f fd       	sub	sp,-4
800023a8:	0f 99       	ld.ub	r9,r7[0x1]
800023aa:	30 38       	mov	r8,3
800023ac:	f0 09 18 00 	cp.b	r9,r8
800023b0:	c0 41       	brne	800023b8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023b2:	30 09       	mov	r9,0
800023b4:	48 88       	lddpc	r8,800023d4 <CallControl_brdcst_func+0x40>
800023b6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023b8:	0f 99       	ld.ub	r9,r7[0x1]
800023ba:	30 48       	mov	r8,4
800023bc:	f0 09 18 00 	cp.b	r9,r8
800023c0:	c0 41       	brne	800023c8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023c2:	30 19       	mov	r9,1
800023c4:	48 48       	lddpc	r8,800023d4 <CallControl_brdcst_func+0x40>
800023c6:	b0 89       	st.b	r8[0x0],r9
800023c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	e3 50 80 00 	st.h	r1[-32768],r0
800023d2:	7f 68       	ld.w	r8,pc[0x58]
800023d4:	00 00       	add	r0,r0
800023d6:	0a 86       	andn	r6,r5

800023d8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023dc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023e0:	0f 99       	ld.ub	r9,r7[0x1]
800023e2:	30 08       	mov	r8,0
800023e4:	f0 09 18 00 	cp.b	r9,r8
800023e8:	c0 71       	brne	800023f6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023ea:	48 ac       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x38>
800023ec:	f0 1f 00 0a 	mcall	80002414 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023f0:	30 09       	mov	r9,0
800023f2:	48 a8       	lddpc	r8,80002418 <TransmitControl_brdcst_func+0x40>
800023f4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023f6:	0f 99       	ld.ub	r9,r7[0x1]
800023f8:	30 18       	mov	r8,1
800023fa:	f0 09 18 00 	cp.b	r9,r8
800023fe:	c0 71       	brne	8000240c <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002400:	48 7c       	lddpc	r12,8000241c <TransmitControl_brdcst_func+0x44>
80002402:	f0 1f 00 05 	mcall	80002414 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002406:	30 19       	mov	r9,1
80002408:	48 48       	lddpc	r8,80002418 <TransmitControl_brdcst_func+0x40>
8000240a:	b0 89       	st.b	r8[0x0],r9
8000240c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	e3 68 80 00 	st.b	r1[-32768],r8
80002416:	7f 68       	ld.w	r8,pc[0x58]
80002418:	00 00       	add	r0,r0
8000241a:	0a 60       	and	r0,r5
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	e3 80       	*unknown*

80002420 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002420:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002424:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002428:	0f 89       	ld.ub	r9,r7[0x0]
8000242a:	30 08       	mov	r8,0
8000242c:	f0 09 18 00 	cp.b	r9,r8
80002430:	c1 61       	brne	8000245c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002432:	48 ec       	lddpc	r12,80002468 <TransmitControl_reply_func+0x48>
80002434:	f0 1f 00 0e 	mcall	8000246c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002438:	0f 98       	ld.ub	r8,r7[0x1]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 dc       	lddpc	r12,80002470 <TransmitControl_reply_func+0x50>
8000243e:	f0 1f 00 0c 	mcall	8000246c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002442:	0f a8       	ld.ub	r8,r7[0x2]
80002444:	1a d8       	st.w	--sp,r8
80002446:	48 cc       	lddpc	r12,80002474 <TransmitControl_reply_func+0x54>
80002448:	f0 1f 00 09 	mcall	8000246c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000244c:	0f b8       	ld.ub	r8,r7[0x3]
8000244e:	1a d8       	st.w	--sp,r8
80002450:	48 ac       	lddpc	r12,80002478 <TransmitControl_reply_func+0x58>
80002452:	f0 1f 00 07 	mcall	8000246c <TransmitControl_reply_func+0x4c>
80002456:	2f dd       	sub	sp,-12
80002458:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000245c:	48 8c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x5c>
8000245e:	f0 1f 00 04 	mcall	8000246c <TransmitControl_reply_func+0x4c>
80002462:	e3 cd 80 80 	ldm	sp++,r7,pc
80002466:	00 00       	add	r0,r0
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	e3 94       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	7f 68       	ld.w	r8,pc[0x58]
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	e3 b0       	*unknown*
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	e3 c4 80 00 	ldm	r4++,pc
8000247a:	e3 e0 80 00 	sthh.w	r0[r0],r1:b,r0:b
8000247e:	e3 f0 d4 01 	ld.shvc	r0,r1[0x2]

80002480 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002480:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002482:	19 a9       	ld.ub	r9,r12[0x2]
80002484:	30 08       	mov	r8,0
80002486:	f0 09 18 00 	cp.b	r9,r8
8000248a:	c0 51       	brne	80002494 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
8000248c:	48 4c       	lddpc	r12,8000249c <AudioRoutingControl_reply_func+0x1c>
8000248e:	f0 1f 00 05 	mcall	800024a0 <AudioRoutingControl_reply_func+0x20>
80002492:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002494:	48 4c       	lddpc	r12,800024a4 <AudioRoutingControl_reply_func+0x24>
80002496:	f0 1f 00 03 	mcall	800024a0 <AudioRoutingControl_reply_func+0x20>
8000249a:	d8 02       	popm	pc
8000249c:	80 00       	ld.sh	r0,r0[0x0]
8000249e:	e4 08       	*unknown*
800024a0:	80 00       	ld.sh	r0,r0[0x0]
800024a2:	7f 68       	ld.w	r8,pc[0x58]
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	e4 18 eb cd 	andh	r8,0xebcd

800024a8 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800024a8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024ac:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024b0:	0f 89       	ld.ub	r9,r7[0x0]
800024b2:	30 08       	mov	r8,0
800024b4:	f0 09 18 00 	cp.b	r9,r8
800024b8:	c1 b1       	brne	800024ee <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ba:	0f b8       	ld.ub	r8,r7[0x3]
800024bc:	31 09       	mov	r9,16
800024be:	f2 08 18 00 	cp.b	r8,r9
800024c2:	c0 f1       	brne	800024e0 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024c4:	48 dc       	lddpc	r12,800024f8 <Volume_reply_func+0x50>
800024c6:	f0 1f 00 0e 	mcall	800024fc <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024ca:	0f 99       	ld.ub	r9,r7[0x1]
800024cc:	0f a8       	ld.ub	r8,r7[0x2]
800024ce:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024d2:	1a d8       	st.w	--sp,r8
800024d4:	48 bc       	lddpc	r12,80002500 <Volume_reply_func+0x58>
800024d6:	f0 1f 00 0a 	mcall	800024fc <Volume_reply_func+0x54>
800024da:	2f fd       	sub	sp,-4
800024dc:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024e0:	1a d8       	st.w	--sp,r8
800024e2:	48 9c       	lddpc	r12,80002504 <Volume_reply_func+0x5c>
800024e4:	f0 1f 00 06 	mcall	800024fc <Volume_reply_func+0x54>
800024e8:	2f fd       	sub	sp,-4
800024ea:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024ee:	48 7c       	lddpc	r12,80002508 <Volume_reply_func+0x60>
800024f0:	f0 1f 00 03 	mcall	800024fc <Volume_reply_func+0x54>
800024f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	e4 2c 80 00 	sub	r12,294912
800024fe:	7f 68       	ld.w	r8,pc[0x58]
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	e4 40 80 00 	cp.w	r0,294912
80002506:	e4 5c 80 00 	cp.w	r12,360448
8000250a:	e4 74 d4 01 	mov	r4,381953

8000250c <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
8000250c:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000250e:	19 d9       	ld.ub	r9,r12[0x5]
80002510:	30 08       	mov	r8,0
80002512:	f0 09 18 00 	cp.b	r9,r8
80002516:	c0 81       	brne	80002526 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002518:	10 99       	mov	r9,r8
8000251a:	48 78       	lddpc	r8,80002534 <spk_brdcst_func+0x28>
8000251c:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000251e:	48 7c       	lddpc	r12,80002538 <spk_brdcst_func+0x2c>
80002520:	f0 1f 00 07 	mcall	8000253c <spk_brdcst_func+0x30>
80002524:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002526:	30 19       	mov	r9,1
80002528:	48 38       	lddpc	r8,80002534 <spk_brdcst_func+0x28>
8000252a:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
8000252c:	48 5c       	lddpc	r12,80002540 <spk_brdcst_func+0x34>
8000252e:	f0 1f 00 04 	mcall	8000253c <spk_brdcst_func+0x30>
80002532:	d8 02       	popm	pc
80002534:	00 00       	add	r0,r0
80002536:	0a 7d       	tst	sp,r5
80002538:	80 00       	ld.sh	r0,r0[0x0]
8000253a:	e4 8c 80 00 	brvs	8009253a <_data_lma+0x82eea>
8000253e:	7f 68       	ld.w	r8,pc[0x58]
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	e4 9c d4 01 	brvs	800bcd44 <_data_lma+0xad6f4>

80002544 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002544:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002546:	19 a9       	ld.ub	r9,r12[0x2]
80002548:	30 08       	mov	r8,0
8000254a:	f0 09 18 00 	cp.b	r9,r8
8000254e:	c0 f1       	brne	8000256c <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002550:	19 e9       	ld.ub	r9,r12[0x6]
80002552:	f0 09 18 00 	cp.b	r9,r8
80002556:	c0 40       	breq	8000255e <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002558:	30 19       	mov	r9,1
8000255a:	48 98       	lddpc	r8,8000257c <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000255e:	19 e8       	ld.ub	r8,r12[0x6]
80002560:	1a d8       	st.w	--sp,r8
80002562:	48 8c       	lddpc	r12,80002580 <spk_reply_func+0x3c>
80002564:	f0 1f 00 08 	mcall	80002584 <spk_reply_func+0x40>
80002568:	2f fd       	sub	sp,-4
8000256a:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
8000256c:	30 09       	mov	r9,0
8000256e:	48 48       	lddpc	r8,8000257c <spk_reply_func+0x38>
80002570:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002572:	48 6c       	lddpc	r12,80002588 <spk_reply_func+0x44>
80002574:	f0 1f 00 04 	mcall	80002584 <spk_reply_func+0x40>
80002578:	d8 02       	popm	pc
8000257a:	00 00       	add	r0,r0
8000257c:	00 00       	add	r0,r0
8000257e:	0a 7d       	tst	sp,r5
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	e4 a8       	*unknown*
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	7f 68       	ld.w	r8,pc[0x58]
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	e4 b8       	*unknown*

8000258c <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
8000258c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002590:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002594:	0f a9       	ld.ub	r9,r7[0x2]
80002596:	30 08       	mov	r8,0
80002598:	f0 09 18 00 	cp.b	r9,r8
8000259c:	c0 71       	brne	800025aa <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000259e:	48 dc       	lddpc	r12,800025d0 <mic_brdcst_func+0x44>
800025a0:	f0 1f 00 0d 	mcall	800025d4 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800025a4:	30 09       	mov	r9,0
800025a6:	48 d8       	lddpc	r8,800025d8 <mic_brdcst_func+0x4c>
800025a8:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800025aa:	0f a9       	ld.ub	r9,r7[0x2]
800025ac:	31 18       	mov	r8,17
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 d1       	brne	800025cc <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025b4:	48 ac       	lddpc	r12,800025dc <mic_brdcst_func+0x50>
800025b6:	f0 1f 00 08 	mcall	800025d4 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ba:	48 89       	lddpc	r9,800025d8 <mic_brdcst_func+0x4c>
800025bc:	30 18       	mov	r8,1
800025be:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025c0:	13 89       	ld.ub	r9,r9[0x0]
800025c2:	f0 09 18 00 	cp.b	r9,r8
800025c6:	c0 31       	brne	800025cc <mic_brdcst_func+0x40>
800025c8:	48 68       	lddpc	r8,800025e0 <mic_brdcst_func+0x54>
800025ca:	11 88       	ld.ub	r8,r8[0x0]
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	e4 c4 80 00 	sub	r4,r2,-32768
800025d6:	7f 68       	ld.w	r8,pc[0x58]
800025d8:	00 00       	add	r0,r0
800025da:	0a 7c       	tst	r12,r5
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	e4 d8 00 00 	satsub.w	r8,r2,0
800025e2:	0a 86       	andn	r6,r5

800025e4 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025e4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025e8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025ec:	49 ac       	lddpc	r12,80002654 <mic_reply_func+0x70>
800025ee:	f0 1f 00 1b 	mcall	80002658 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025f2:	0f 89       	ld.ub	r9,r7[0x0]
800025f4:	30 08       	mov	r8,0
800025f6:	f0 09 18 00 	cp.b	r9,r8
800025fa:	c2 71       	brne	80002648 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025fc:	0f 98       	ld.ub	r8,r7[0x1]
800025fe:	30 29       	mov	r9,2
80002600:	f2 08 18 00 	cp.b	r8,r9
80002604:	c1 b1       	brne	8000263a <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002606:	49 6c       	lddpc	r12,8000265c <mic_reply_func+0x78>
80002608:	f0 1f 00 14 	mcall	80002658 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000260c:	0f a8       	ld.ub	r8,r7[0x2]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 4c       	lddpc	r12,80002660 <mic_reply_func+0x7c>
80002612:	f0 1f 00 12 	mcall	80002658 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002616:	0f b8       	ld.ub	r8,r7[0x3]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 3c       	lddpc	r12,80002664 <mic_reply_func+0x80>
8000261c:	f0 1f 00 0f 	mcall	80002658 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002620:	0f c8       	ld.ub	r8,r7[0x4]
80002622:	1a d8       	st.w	--sp,r8
80002624:	49 1c       	lddpc	r12,80002668 <mic_reply_func+0x84>
80002626:	f0 1f 00 0d 	mcall	80002658 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000262a:	0f d8       	ld.ub	r8,r7[0x5]
8000262c:	1a d8       	st.w	--sp,r8
8000262e:	49 0c       	lddpc	r12,8000266c <mic_reply_func+0x88>
80002630:	f0 1f 00 0a 	mcall	80002658 <mic_reply_func+0x74>
80002634:	2f cd       	sub	sp,-16
80002636:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000263a:	1a d8       	st.w	--sp,r8
8000263c:	48 dc       	lddpc	r12,80002670 <mic_reply_func+0x8c>
8000263e:	f0 1f 00 07 	mcall	80002658 <mic_reply_func+0x74>
80002642:	2f fd       	sub	sp,-4
80002644:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002648:	48 bc       	lddpc	r12,80002674 <mic_reply_func+0x90>
8000264a:	f0 1f 00 04 	mcall	80002658 <mic_reply_func+0x74>
8000264e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002652:	00 00       	add	r0,r0
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	e4 ec 80 00 	ld.d	r12,r2[-32768]
8000265a:	7f 68       	ld.w	r8,pc[0x58]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	e4 fc 80 00 	ld.w	r12,r2[-32768]
80002662:	e5 10 80 00 	ld.uh	r0,r2[-32768]
80002666:	e5 24 80 00 	ld.sb	r4,r2[-32768]
8000266a:	e5 40 80 00 	st.w	r2[-32768],r0
8000266e:	e5 58 80 00 	st.h	r2[-32768],r8
80002672:	e5 70 80 00 	stcond	r2[-32768],r0
80002676:	e5 88       	*unknown*

80002678 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002678:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
8000267c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002680:	48 bc       	lddpc	r12,800026ac <dcm_brdcst_func+0x34>
80002682:	f0 1f 00 0c 	mcall	800026b0 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002686:	0f 88       	ld.ub	r8,r7[0x0]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 bc       	lddpc	r12,800026b4 <dcm_brdcst_func+0x3c>
8000268c:	f0 1f 00 09 	mcall	800026b0 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002690:	0f a8       	ld.ub	r8,r7[0x2]
80002692:	1a d8       	st.w	--sp,r8
80002694:	48 9c       	lddpc	r12,800026b8 <dcm_brdcst_func+0x40>
80002696:	f0 1f 00 07 	mcall	800026b0 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000269a:	0f 98       	ld.ub	r8,r7[0x1]
8000269c:	1a d8       	st.w	--sp,r8
8000269e:	48 8c       	lddpc	r12,800026bc <dcm_brdcst_func+0x44>
800026a0:	f0 1f 00 04 	mcall	800026b0 <dcm_brdcst_func+0x38>
800026a4:	2f dd       	sub	sp,-12
	
	
}
800026a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	e5 98       	*unknown*
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	7f 68       	ld.w	r8,pc[0x58]
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	e5 ac 80 00 	cop	cp4,cr0,cr0,cr0,0x58
800026ba:	e5 c0 80 00 	ldmts	r0,pc
800026be:	e5 d8       	*unknown*

800026c0 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026c0:	eb cd 40 80 	pushm	r7,lr
800026c4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026c6:	19 a9       	ld.ub	r9,r12[0x2]
800026c8:	30 08       	mov	r8,0
800026ca:	f0 09 18 00 	cp.b	r9,r8
800026ce:	c1 b1       	brne	80002704 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026d0:	19 b8       	ld.ub	r8,r12[0x3]
800026d2:	30 19       	mov	r9,1
800026d4:	f2 08 18 00 	cp.b	r8,r9
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026da:	48 ec       	lddpc	r12,80002710 <dcm_reply_func+0x50>
800026dc:	f0 1f 00 0e 	mcall	80002714 <dcm_reply_func+0x54>
800026e0:	c0 a8       	rjmp	800026f4 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026e2:	58 08       	cp.w	r8,0
800026e4:	c0 51       	brne	800026ee <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026e6:	48 dc       	lddpc	r12,80002718 <dcm_reply_func+0x58>
800026e8:	f0 1f 00 0b 	mcall	80002714 <dcm_reply_func+0x54>
800026ec:	c0 48       	rjmp	800026f4 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026ee:	48 cc       	lddpc	r12,8000271c <dcm_reply_func+0x5c>
800026f0:	f0 1f 00 09 	mcall	80002714 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026f4:	0f d8       	ld.ub	r8,r7[0x5]
800026f6:	1a d8       	st.w	--sp,r8
800026f8:	48 ac       	lddpc	r12,80002720 <dcm_reply_func+0x60>
800026fa:	f0 1f 00 07 	mcall	80002714 <dcm_reply_func+0x54>
800026fe:	2f fd       	sub	sp,-4
80002700:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002704:	48 8c       	lddpc	r12,80002724 <dcm_reply_func+0x64>
80002706:	f0 1f 00 04 	mcall	80002714 <dcm_reply_func+0x54>
8000270a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000270e:	00 00       	add	r0,r0
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	e5 f4 80 00 	ld.wls	r4,r2[0x0]
80002716:	7f 68       	ld.w	r8,pc[0x58]
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	e6 08       	*unknown*
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	e6 1c 80 00 	andh	r12,0x8000,COH
80002722:	e6 30 80 00 	sub	r0,491520
80002726:	e6 3c d4 01 	sub	r12,513025

80002728 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002728:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000272a:	19 a9       	ld.ub	r9,r12[0x2]
8000272c:	30 08       	mov	r8,0
8000272e:	f0 09 18 00 	cp.b	r9,r8
80002732:	c0 51       	brne	8000273c <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002734:	48 4c       	lddpc	r12,80002744 <ToneControl_reply_func+0x1c>
80002736:	f0 1f 00 05 	mcall	80002748 <ToneControl_reply_func+0x20>
8000273a:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
8000273c:	48 4c       	lddpc	r12,8000274c <ToneControl_reply_func+0x24>
8000273e:	f0 1f 00 03 	mcall	80002748 <ToneControl_reply_func+0x20>
80002742:	d8 02       	popm	pc
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	e6 48 80 00 	cp.w	r8,425984
8000274a:	7f 68       	ld.w	r8,pc[0x58]
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	e6 54 eb cd 	cp.w	r4,519117

80002750 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002750:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
80002754:	49 7c       	lddpc	r12,800027b0 <app_init+0x60>
80002756:	f0 1f 00 18 	mcall	800027b4 <app_init+0x64>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000275a:	49 8b       	lddpc	r11,800027b8 <app_init+0x68>
8000275c:	49 8c       	lddpc	r12,800027bc <app_init+0x6c>
8000275e:	f0 1f 00 19 	mcall	800027c0 <app_init+0x70>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002762:	f0 1f 00 19 	mcall	800027c4 <app_init+0x74>
80002766:	49 98       	lddpc	r8,800027c8 <app_init+0x78>
80002768:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000276a:	70 08       	ld.w	r8,r8[0x0]
8000276c:	58 08       	cp.w	r8,0
8000276e:	c0 41       	brne	80002776 <app_init+0x26>
	{
		log("Create the count_mutex semaphore failure\n");
80002770:	49 7c       	lddpc	r12,800027cc <app_init+0x7c>
80002772:	f0 1f 00 18 	mcall	800027d0 <app_init+0x80>
	}
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002776:	30 07       	mov	r7,0
80002778:	1a d7       	st.w	--sp,r7
8000277a:	1a d7       	st.w	--sp,r7
8000277c:	1a d7       	st.w	--sp,r7
8000277e:	30 28       	mov	r8,2
80002780:	0e 99       	mov	r9,r7
80002782:	e0 6a 02 ee 	mov	r10,750
80002786:	49 4b       	lddpc	r11,800027d4 <app_init+0x84>
80002788:	49 4c       	lddpc	r12,800027d8 <app_init+0x88>
8000278a:	f0 1f 00 15 	mcall	800027dc <app_init+0x8c>
8000278e:	49 56       	lddpc	r6,800027e0 <app_init+0x90>
80002790:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  2
	,  NULL );
	
	 res = xTaskCreate(
80002792:	1a d7       	st.w	--sp,r7
80002794:	1a d7       	st.w	--sp,r7
80002796:	1a d7       	st.w	--sp,r7
80002798:	30 18       	mov	r8,1
8000279a:	0e 99       	mov	r9,r7
8000279c:	e0 6a 03 84 	mov	r10,900
800027a0:	49 1b       	lddpc	r11,800027e4 <app_init+0x94>
800027a2:	49 2c       	lddpc	r12,800027e8 <app_init+0x98>
800027a4:	f0 1f 00 0e 	mcall	800027dc <app_init+0x8c>
800027a8:	8d 0c       	st.w	r6[0x0],r12
800027aa:	2f ad       	sub	sp,-24
	 ,  900
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
800027ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800027b0:	00 00       	add	r0,r0
800027b2:	00 10       	sub	r0,r0
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	48 28       	lddpc	r8,800027bc <app_init+0x6c>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	20 3c       	sub	r12,3
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	20 50       	sub	r0,5
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	34 d0       	mov	r0,77
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	74 30       	ld.w	r0,r10[0xc]
800027c8:	00 00       	add	r0,r0
800027ca:	0a 78       	tst	r8,r5
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	e6 60 80 00 	mov	r0,425984
800027d2:	7f 68       	ld.w	r8,pc[0x58]
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	e6 8c 80 00 	brvs	800d27d6 <_data_lma+0xc3186>
800027da:	29 1c       	sub	r12,-111
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	7b a4       	ld.w	r4,sp[0x68]
800027e0:	00 00       	add	r0,r0
800027e2:	0a 5c       	eor	r12,r5
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	e6 94 80 00 	brge	800f27e6 <_data_lma+0xe3196>
800027ea:	27 ec       	sub	r12,126

800027ec <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027ec:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027ee:	32 0c       	mov	r12,32
800027f0:	f0 1f 00 34 	mcall	800028c0 <send_message+0xd4>
800027f4:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027f6:	f0 1f 00 34 	mcall	800028c4 <send_message+0xd8>
800027fa:	4b 48       	lddpc	r8,800028c8 <send_message+0xdc>
800027fc:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027fe:	4b 45       	lddpc	r5,800028cc <send_message+0xe0>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002800:	4b 47       	lddpc	r7,800028d0 <send_message+0xe4>
80002802:	30 16       	mov	r6,1
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002804:	4b 43       	lddpc	r3,800028d4 <send_message+0xe8>
		{
			log("Current_total_message_count: %d\n", message_count);
80002806:	4b 50       	lddpc	r0,800028d8 <send_message+0xec>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
80002808:	30 12       	mov	r2,1
8000280a:	4b 51       	lddpc	r1,800028dc <send_message+0xf0>
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
8000280c:	f0 1f 00 35 	mcall	800028e0 <send_message+0xf4>
80002810:	5c 8c       	casts.h	r12
80002812:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002814:	c4 80       	breq	800028a4 <send_message+0xb8>
80002816:	0f 88       	ld.ub	r8,r7[0x0]
80002818:	58 08       	cp.w	r8,0
8000281a:	c4 51       	brne	800028a4 <send_message+0xb8>
8000281c:	07 88       	ld.ub	r8,r3[0x0]
8000281e:	58 08       	cp.w	r8,0
80002820:	c4 20       	breq	800028a4 <send_message+0xb8>
		{
			log("Current_total_message_count: %d\n", message_count);
80002822:	5c 7c       	castu.h	r12
80002824:	1a dc       	st.w	--sp,r12
80002826:	00 9c       	mov	r12,r0
80002828:	f0 1f 00 2f 	mcall	800028e4 <send_message+0xf8>
			if(m_buff==NULL)break;
8000282c:	2f fd       	sub	sp,-4
8000282e:	58 04       	cp.w	r4,0
80002830:	c4 70       	breq	800028be <send_message+0xd2>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
80002832:	04 9a       	mov	r10,r2
80002834:	08 9b       	mov	r11,r4
80002836:	8a 8c       	ld.uh	r12,r5[0x0]
80002838:	f0 1f 00 2c 	mcall	800028e8 <send_message+0xfc>
8000283c:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
8000283e:	c2 d1       	brne	80002898 <send_message+0xac>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
80002840:	36 4a       	mov	r10,100
80002842:	32 0b       	mov	r11,32
80002844:	08 9c       	mov	r12,r4
80002846:	f0 1f 00 2a 	mcall	800028ec <send_message+0x100>
				//if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
				if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
8000284a:	4a a8       	lddpc	r8,800028f0 <send_message+0x104>
8000284c:	70 0c       	ld.w	r12,r8[0x0]
8000284e:	30 09       	mov	r9,0
80002850:	e0 6a 9c 40 	mov	r10,40000
80002854:	12 9b       	mov	r11,r9
80002856:	f0 1f 00 28 	mcall	800028f4 <send_message+0x108>
8000285a:	58 1c       	cp.w	r12,1
8000285c:	c0 51       	brne	80002866 <send_message+0x7a>
				{
					log("xSemaphoreTake okay!\n");
8000285e:	4a 7c       	lddpc	r12,800028f8 <send_message+0x10c>
80002860:	f0 1f 00 21 	mcall	800028e4 <send_message+0xf8>
80002864:	c2 78       	rjmp	800028b2 <send_message+0xc6>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002866:	4a 6c       	lddpc	r12,800028fc <send_message+0x110>
80002868:	f0 1f 00 1f 	mcall	800028e4 <send_message+0xf8>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
8000286c:	e0 6b 00 b7 	mov	r11,183
80002870:	04 9c       	mov	r12,r2
80002872:	f0 1f 00 24 	mcall	80002900 <send_message+0x114>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002876:	04 9a       	mov	r10,r2
80002878:	32 0b       	mov	r11,32
8000287a:	08 9c       	mov	r12,r4
8000287c:	f0 1f 00 22 	mcall	80002904 <send_message+0x118>
80002880:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
80002882:	c0 51       	brne	8000288c <send_message+0xa0>
					{
						log("save message okay\n");
80002884:	4a 1c       	lddpc	r12,80002908 <send_message+0x11c>
80002886:	f0 1f 00 18 	mcall	800028e4 <send_message+0xf8>
8000288a:	c1 48       	rjmp	800028b2 <send_message+0xc6>
					}
					else
					{
						log("!!!save message err : %d\n", status);
8000288c:	1a dc       	st.w	--sp,r12
8000288e:	4a 0c       	lddpc	r12,8000290c <send_message+0x120>
80002890:	f0 1f 00 15 	mcall	800028e4 <send_message+0xf8>
80002894:	2f fd       	sub	sp,-4
80002896:	c0 e8       	rjmp	800028b2 <send_message+0xc6>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
80002898:	1a dc       	st.w	--sp,r12
8000289a:	49 ec       	lddpc	r12,80002910 <send_message+0x124>
8000289c:	f0 1f 00 12 	mcall	800028e4 <send_message+0xf8>
800028a0:	2f fd       	sub	sp,-4
800028a2:	c0 88       	rjmp	800028b2 <send_message+0xc6>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800028a4:	0f 88       	ld.ub	r8,r7[0x0]
800028a6:	ec 08 18 00 	cp.b	r8,r6
800028aa:	c0 41       	brne	800028b2 <send_message+0xc6>
		{
			log("The device battery level is low !\n");
800028ac:	49 ac       	lddpc	r12,80002914 <send_message+0x128>
800028ae:	f0 1f 00 0e 	mcall	800028e4 <send_message+0xf8>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028b2:	e0 6b 07 d0 	mov	r11,2000
800028b6:	48 5c       	lddpc	r12,800028c8 <send_message+0xdc>
800028b8:	f0 1f 00 18 	mcall	80002918 <send_message+0x12c>
	
	}
800028bc:	ca 8b       	rjmp	8000280c <send_message+0x20>
800028be:	d8 32       	popm	r0-r7,pc
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	6f dc       	ld.w	r12,r7[0x74]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	78 94       	ld.w	r4,r12[0x24]
800028c8:	00 00       	add	r0,r0
800028ca:	0a 64       	and	r4,r5
800028cc:	00 00       	add	r0,r0
800028ce:	0a 6a       	and	r10,r5
800028d0:	00 00       	add	r0,r0
800028d2:	0a 84       	andn	r4,r5
800028d4:	00 00       	add	r0,r0
800028d6:	0a 68       	and	r8,r5
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	e6 9c 00 00 	brvs	800e28da <_data_lma+0xd328a>
800028de:	00 0c       	add	r12,r0
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	62 a0       	ld.w	r0,r1[0x28]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	7f 68       	ld.w	r8,pc[0x58]
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	5f c0       	srvs	r0
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	48 7c       	lddpc	r12,80002908 <send_message+0x11c>
800028f0:	00 00       	add	r0,r0
800028f2:	0b a0       	ld.ub	r0,r5[0x2]
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	71 24       	ld.w	r4,r8[0x48]
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	e6 c0 80 00 	sub	r0,r3,-32768
800028fe:	e6 d8 80 00 	satsub.w	r8,r3,-32768
80002902:	49 b8       	lddpc	r8,8000296c <app_cfg+0x50>
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	61 10       	ld.w	r0,r0[0x44]
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	e6 f4 80 00 	ld.w	r4,r3[-32768]
8000290e:	e7 08 80 00 	ld.sh	r8,r3[-32768]
80002912:	e7 24 80 00 	ld.sb	r4,r3[-32768]
80002916:	e7 3c 80 00 	ld.ub	r12,r3[-32768]
8000291a:	7a 44       	ld.w	r4,sp[0x10]

8000291c <app_cfg>:
}

static __app_Thread_(app_cfg)
{
8000291c:	d4 31       	pushm	r0-r7,lr
8000291e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
80002920:	f0 1f 00 4d 	mcall	80002a54 <app_cfg+0x138>
80002924:	4c d8       	lddpc	r8,80002a58 <app_cfg+0x13c>
80002926:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002928:	4c d7       	lddpc	r7,80002a5c <app_cfg+0x140>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000292a:	4c e5       	lddpc	r5,80002a60 <app_cfg+0x144>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000292c:	32 01       	mov	r1,32
8000292e:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002930:	4c d4       	lddpc	r4,80002a64 <app_cfg+0x148>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002932:	6e 08       	ld.w	r8,r7[0x0]
80002934:	58 28       	cp.w	r8,2
80002936:	c3 90       	breq	800029a8 <app_cfg+0x8c>
80002938:	58 38       	cp.w	r8,3
8000293a:	c4 60       	breq	800029c6 <app_cfg+0xaa>
8000293c:	58 08       	cp.w	r8,0
8000293e:	e0 81 00 85 	brne	80002a48 <app_cfg+0x12c>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002942:	4c a8       	lddpc	r8,80002a68 <app_cfg+0x14c>
80002944:	70 08       	ld.w	r8,r8[0x0]
80002946:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000294a:	58 38       	cp.w	r8,3
8000294c:	c1 61       	brne	80002978 <app_cfg+0x5c>
8000294e:	4c 88       	lddpc	r8,80002a6c <app_cfg+0x150>
80002950:	11 88       	ld.ub	r8,r8[0x0]
80002952:	58 08       	cp.w	r8,0
80002954:	c1 21       	brne	80002978 <app_cfg+0x5c>
				{
					connect_flag=1;
80002956:	30 19       	mov	r9,1
80002958:	4c 58       	lddpc	r8,80002a6c <app_cfg+0x150>
8000295a:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000295c:	30 cb       	mov	r11,12
8000295e:	30 1c       	mov	r12,1
80002960:	f0 1f 00 44 	mcall	80002a70 <app_cfg+0x154>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002964:	30 cb       	mov	r11,12
80002966:	30 1c       	mov	r12,1
80002968:	f0 1f 00 42 	mcall	80002a70 <app_cfg+0x154>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
8000296c:	30 28       	mov	r8,2
8000296e:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002970:	4c 1c       	lddpc	r12,80002a74 <app_cfg+0x158>
80002972:	f0 1f 00 42 	mcall	80002a78 <app_cfg+0x15c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002976:	c6 98       	rjmp	80002a48 <app_cfg+0x12c>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002978:	d7 03       	nop
					nop();
8000297a:	d7 03       	nop
					nop();
8000297c:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
8000297e:	4c 0c       	lddpc	r12,80002a7c <app_cfg+0x160>
80002980:	f0 1f 00 3e 	mcall	80002a78 <app_cfg+0x15c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002984:	4b f8       	lddpc	r8,80002a80 <app_cfg+0x164>
80002986:	11 d2       	ld.ub	r2,r8[0x5]
80002988:	11 cc       	ld.ub	r12,r8[0x4]
8000298a:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
8000298c:	11 aa       	ld.ub	r10,r8[0x2]
8000298e:	11 99       	ld.ub	r9,r8[0x1]
80002990:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002992:	1a d2       	st.w	--sp,r2
80002994:	1a dc       	st.w	--sp,r12
80002996:	1a db       	st.w	--sp,r11
80002998:	1a da       	st.w	--sp,r10
8000299a:	1a d9       	st.w	--sp,r9
8000299c:	1a d8       	st.w	--sp,r8
8000299e:	4b ac       	lddpc	r12,80002a84 <app_cfg+0x168>
800029a0:	f0 1f 00 36 	mcall	80002a78 <app_cfg+0x15c>
800029a4:	2f ad       	sub	sp,-24
800029a6:	c5 18       	rjmp	80002a48 <app_cfg+0x12c>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800029a8:	0b 88       	ld.ub	r8,r5[0x0]
800029aa:	58 08       	cp.w	r8,0
800029ac:	c0 70       	breq	800029ba <app_cfg+0x9e>
							
							OB_State = OB_WAITINGAPPTASK;
800029ae:	30 38       	mov	r8,3
800029b0:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
800029b2:	4b 6c       	lddpc	r12,80002a88 <app_cfg+0x16c>
800029b4:	f0 1f 00 31 	mcall	80002a78 <app_cfg+0x15c>
800029b8:	c4 88       	rjmp	80002a48 <app_cfg+0x12c>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800029ba:	36 4a       	mov	r10,100
800029bc:	02 9b       	mov	r11,r1
800029be:	0c 9c       	mov	r12,r6
800029c0:	f0 1f 00 33 	mcall	80002a8c <app_cfg+0x170>
800029c4:	c4 28       	rjmp	80002a48 <app_cfg+0x12c>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800029c6:	68 0c       	ld.w	r12,r4[0x0]
800029c8:	0c 99       	mov	r9,r6
800029ca:	e0 6a 0f a0 	mov	r10,4000
800029ce:	1a 9b       	mov	r11,sp
800029d0:	f0 1f 00 30 	mcall	80002a90 <app_cfg+0x174>
800029d4:	58 1c       	cp.w	r12,1
800029d6:	c3 51       	brne	80002a40 <app_cfg+0x124>
					{
						if(data_ptr!=NULL){//save message
800029d8:	40 08       	lddsp	r8,sp[0x0]
800029da:	58 08       	cp.w	r8,0
800029dc:	c3 20       	breq	80002a40 <app_cfg+0x124>
							
							log("receive okay!\n");
800029de:	4a ec       	lddpc	r12,80002a94 <app_cfg+0x178>
800029e0:	f0 1f 00 26 	mcall	80002a78 <app_cfg+0x15c>
							xSemaphoreTake(count_mutex, portMAX_DELAY);
800029e4:	4a d0       	lddpc	r0,80002a98 <app_cfg+0x17c>
800029e6:	60 0c       	ld.w	r12,r0[0x0]
800029e8:	0c 99       	mov	r9,r6
800029ea:	3f fa       	mov	r10,-1
800029ec:	0c 9b       	mov	r11,r6
800029ee:	f0 1f 00 29 	mcall	80002a90 <app_cfg+0x174>
							global_count--;
800029f2:	4a b2       	lddpc	r2,80002a9c <app_cfg+0x180>
800029f4:	64 08       	ld.w	r8,r2[0x0]
800029f6:	20 18       	sub	r8,1
800029f8:	85 08       	st.w	r2[0x0],r8
							xSemaphoreGive(count_mutex);
800029fa:	60 0c       	ld.w	r12,r0[0x0]
800029fc:	0c 99       	mov	r9,r6
800029fe:	0c 9a       	mov	r10,r6
80002a00:	0c 9b       	mov	r11,r6
80002a02:	f0 1f 00 28 	mcall	80002aa0 <app_cfg+0x184>
							log("global_count:%d\n", global_count);
80002a06:	64 08       	ld.w	r8,r2[0x0]
80002a08:	1a d8       	st.w	--sp,r8
80002a0a:	4a 7c       	lddpc	r12,80002aa4 <app_cfg+0x188>
80002a0c:	f0 1f 00 1b 	mcall	80002a78 <app_cfg+0x15c>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
80002a10:	30 1a       	mov	r10,1
80002a12:	02 9b       	mov	r11,r1
80002a14:	40 1c       	lddsp	r12,sp[0x4]
80002a16:	f0 1f 00 25 	mcall	80002aa8 <app_cfg+0x18c>
80002a1a:	4a 58       	lddpc	r8,80002aac <app_cfg+0x190>
80002a1c:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
80002a1e:	2f fd       	sub	sp,-4
80002a20:	58 0c       	cp.w	r12,0
80002a22:	c0 51       	brne	80002a2c <app_cfg+0x110>
							{
								log("save message okay\n");
80002a24:	4a 3c       	lddpc	r12,80002ab0 <app_cfg+0x194>
80002a26:	f0 1f 00 15 	mcall	80002a78 <app_cfg+0x15c>
80002a2a:	c0 68       	rjmp	80002a36 <app_cfg+0x11a>
							}
							else
							{
								log("!!! save message err : %d\n", status);
80002a2c:	1a dc       	st.w	--sp,r12
80002a2e:	4a 2c       	lddpc	r12,80002ab4 <app_cfg+0x198>
80002a30:	f0 1f 00 12 	mcall	80002a78 <app_cfg+0x15c>
80002a34:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
80002a36:	4a 18       	lddpc	r8,80002ab8 <app_cfg+0x19c>
80002a38:	70 0c       	ld.w	r12,r8[0x0]
80002a3a:	40 0b       	lddsp	r11,sp[0x0]
80002a3c:	f0 1f 00 20 	mcall	80002abc <app_cfg+0x1a0>
							
						}
						
					}						
											
					nop();
80002a40:	d7 03       	nop
					//water_value = uxTaskGetStackHighWaterMark(NULL);
					//log("app-thread water_value: %d\n", water_value);
					log("app task run!\n");
80002a42:	4a 0c       	lddpc	r12,80002ac0 <app_cfg+0x1a4>
80002a44:	f0 1f 00 0d 	mcall	80002a78 <app_cfg+0x15c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (1500*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002a48:	e0 6b 0b b8 	mov	r11,3000
80002a4c:	48 3c       	lddpc	r12,80002a58 <app_cfg+0x13c>
80002a4e:	f0 1f 00 1e 	mcall	80002ac4 <app_cfg+0x1a8>
	}
80002a52:	c7 0b       	rjmp	80002932 <app_cfg+0x16>
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	78 94       	ld.w	r4,r12[0x24]
80002a58:	00 00       	add	r0,r0
80002a5a:	0a 58       	eor	r8,r5
80002a5c:	00 00       	add	r0,r0
80002a5e:	0a 6c       	and	r12,r5
80002a60:	00 00       	add	r0,r0
80002a62:	00 08       	add	r8,r0
80002a64:	00 00       	add	r0,r0
80002a66:	0b 90       	ld.ub	r0,r5[0x1]
80002a68:	00 00       	add	r0,r0
80002a6a:	0e 1c       	sub	r12,r7
80002a6c:	00 00       	add	r0,r0
80002a6e:	0a 68       	and	r8,r5
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	49 b8       	lddpc	r8,80002adc <Phyuserinput_brdcst_func+0x14>
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	e7 60 80 00 	st.b	r3[-32768],r0
80002a7a:	7f 68       	ld.w	r8,pc[0x58]
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	e7 74 00 00 	stcond	r3[0],r4
80002a82:	0e 20       	rsub	r0,r7
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	e7 84       	*unknown*
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	e7 b0       	*unknown*
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	48 7c       	lddpc	r12,80002aa8 <app_cfg+0x18c>
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	71 24       	ld.w	r4,r8[0x48]
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	e7 c0 00 00 	ldmts	r0++,
80002a9a:	0a 78       	tst	r8,r5
80002a9c:	00 00       	add	r0,r0
80002a9e:	0a 80       	andn	r0,r5
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	73 30       	ld.w	r0,r9[0x4c]
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	e7 d0 80 00 	ldswp.w	r0,r3[0]
80002aaa:	61 10       	ld.w	r0,r0[0x44]
80002aac:	00 00       	add	r0,r0
80002aae:	00 04       	add	r4,r0
80002ab0:	80 00       	ld.sh	r0,r0[0x0]
80002ab2:	e6 f4 80 00 	ld.w	r4,r3[-32768]
80002ab6:	e7 e4 00 00 	and	r0,r3,r4
80002aba:	0b 9c       	ld.ub	r12,r5[0x1]
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	35 50       	mov	r0,85
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	e8 00       	*unknown*
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	7a 44       	ld.w	r4,sp[0x10]

80002ac8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ac8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002acc:	19 c7       	ld.ub	r7,r12[0x4]
80002ace:	19 d8       	ld.ub	r8,r12[0x5]
80002ad0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002ad4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002ad6:	48 dc       	lddpc	r12,80002b08 <Phyuserinput_brdcst_func+0x40>
80002ad8:	f0 1f 00 0d 	mcall	80002b0c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002adc:	36 08       	mov	r8,96
80002ade:	f0 07 19 00 	cp.h	r7,r8
80002ae2:	c1 11       	brne	80002b04 <Phyuserinput_brdcst_func+0x3c>
80002ae4:	48 b8       	lddpc	r8,80002b10 <Phyuserinput_brdcst_func+0x48>
80002ae6:	11 89       	ld.ub	r9,r8[0x0]
80002ae8:	30 18       	mov	r8,1
80002aea:	f0 09 18 00 	cp.b	r9,r8
80002aee:	c0 b1       	brne	80002b04 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002af0:	34 5b       	mov	r11,69
80002af2:	30 1c       	mov	r12,1
80002af4:	f0 1f 00 08 	mcall	80002b14 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002af8:	e0 6c 07 d0 	mov	r12,2000
80002afc:	f0 1f 00 07 	mcall	80002b18 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002b00:	f0 1f 00 07 	mcall	80002b1c <Phyuserinput_brdcst_func+0x54>
80002b04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	e8 10 80 00 	orl	r0,0x8000
80002b0e:	7f 68       	ld.w	r8,pc[0x58]
80002b10:	00 00       	add	r0,r0
80002b12:	0a 68       	and	r8,r5
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	49 b8       	lddpc	r8,80002b80 <DataSession_brdcst_func+0x60>
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	79 fc       	ld.w	r12,r12[0x7c]
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	59 f8       	cp.w	r8,31

80002b20 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b20:	d4 21       	pushm	r4-r7,lr
80002b22:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002b24:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002b28:	0d 88       	ld.ub	r8,r6[0x0]
80002b2a:	32 49       	mov	r9,36
80002b2c:	f2 08 18 00 	cp.b	r8,r9
80002b30:	c2 a1       	brne	80002b84 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002b32:	4c fc       	lddpc	r12,80002c6c <DataSession_brdcst_func+0x14c>
80002b34:	f0 1f 00 4f 	mcall	80002c70 <DataSession_brdcst_func+0x150>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002b38:	0d a5       	ld.ub	r5,r6[0x2]
80002b3a:	0d b8       	ld.ub	r8,r6[0x3]
80002b3c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002b40:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002b42:	0d 98       	ld.ub	r8,r6[0x1]
80002b44:	1a d8       	st.w	--sp,r8
80002b46:	4c cc       	lddpc	r12,80002c74 <DataSession_brdcst_func+0x154>
80002b48:	f0 1f 00 4a 	mcall	80002c70 <DataSession_brdcst_func+0x150>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002b4c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002b50:	1a d8       	st.w	--sp,r8
80002b52:	4c ac       	lddpc	r12,80002c78 <DataSession_brdcst_func+0x158>
80002b54:	f0 1f 00 47 	mcall	80002c70 <DataSession_brdcst_func+0x150>
		for(i=0; i<data_length; i++)
80002b58:	2f ed       	sub	sp,-8
80002b5a:	58 05       	cp.w	r5,0
80002b5c:	e0 80 00 85 	breq	80002c66 <DataSession_brdcst_func+0x146>
80002b60:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002b62:	4c 74       	lddpc	r4,80002c7c <DataSession_brdcst_func+0x15c>
80002b64:	ec 07 00 08 	add	r8,r6,r7
80002b68:	11 c8       	ld.ub	r8,r8[0x4]
80002b6a:	1a d8       	st.w	--sp,r8
80002b6c:	1a d7       	st.w	--sp,r7
80002b6e:	08 9c       	mov	r12,r4
80002b70:	f0 1f 00 40 	mcall	80002c70 <DataSession_brdcst_func+0x150>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002b74:	2f f7       	sub	r7,-1
80002b76:	5c 57       	castu.b	r7
80002b78:	2f ed       	sub	sp,-8
80002b7a:	ee 05 19 00 	cp.h	r5,r7
80002b7e:	fe 9b ff f3 	brhi	80002b64 <DataSession_brdcst_func+0x44>
80002b82:	c7 28       	rjmp	80002c66 <DataSession_brdcst_func+0x146>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002b84:	1a d8       	st.w	--sp,r8
80002b86:	4b fc       	lddpc	r12,80002c80 <DataSession_brdcst_func+0x160>
80002b88:	f0 1f 00 3a 	mcall	80002c70 <DataSession_brdcst_func+0x150>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002b8c:	0d 88       	ld.ub	r8,r6[0x0]
80002b8e:	2f fd       	sub	sp,-4
80002b90:	30 39       	mov	r9,3
80002b92:	f2 08 18 00 	cp.b	r8,r9
80002b96:	c0 d1       	brne	80002bb0 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002b98:	4b bc       	lddpc	r12,80002c84 <DataSession_brdcst_func+0x164>
80002b9a:	f0 1f 00 36 	mcall	80002c70 <DataSession_brdcst_func+0x150>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b9e:	e0 6c 07 d0 	mov	r12,2000
80002ba2:	f0 1f 00 3a 	mcall	80002c88 <DataSession_brdcst_func+0x168>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002ba6:	37 7b       	mov	r11,119
80002ba8:	30 1c       	mov	r12,1
80002baa:	f0 1f 00 39 	mcall	80002c8c <DataSession_brdcst_func+0x16c>
80002bae:	c4 98       	rjmp	80002c40 <DataSession_brdcst_func+0x120>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002bb0:	30 49       	mov	r9,4
80002bb2:	f2 08 18 00 	cp.b	r8,r9
80002bb6:	c4 51       	brne	80002c40 <DataSession_brdcst_func+0x120>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002bb8:	32 0a       	mov	r10,32
80002bba:	ec cb ff fc 	sub	r11,r6,-4
80002bbe:	1a 9c       	mov	r12,sp
80002bc0:	f0 1f 00 34 	mcall	80002c90 <DataSession_brdcst_func+0x170>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002bc4:	4b 48       	lddpc	r8,80002c94 <DataSession_brdcst_func+0x174>
80002bc6:	70 0c       	ld.w	r12,r8[0x0]
80002bc8:	f0 1f 00 34 	mcall	80002c98 <DataSession_brdcst_func+0x178>
80002bcc:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002bce:	c3 10       	breq	80002c30 <DataSession_brdcst_func+0x110>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002bd0:	32 0a       	mov	r10,32
80002bd2:	1a 9b       	mov	r11,sp
80002bd4:	f0 1f 00 2f 	mcall	80002c90 <DataSession_brdcst_func+0x170>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002bd8:	4b 18       	lddpc	r8,80002c9c <DataSession_brdcst_func+0x17c>
80002bda:	70 0c       	ld.w	r12,r8[0x0]
80002bdc:	30 09       	mov	r9,0
80002bde:	12 9a       	mov	r10,r9
80002be0:	fa cb ff e0 	sub	r11,sp,-32
80002be4:	f0 1f 00 2f 	mcall	80002ca0 <DataSession_brdcst_func+0x180>
80002be8:	58 1c       	cp.w	r12,1
80002bea:	c1 10       	breq	80002c0c <DataSession_brdcst_func+0xec>
				{
					log("xg_resend_queue: full\n" );
80002bec:	4a ec       	lddpc	r12,80002ca4 <DataSession_brdcst_func+0x184>
80002bee:	f0 1f 00 21 	mcall	80002c70 <DataSession_brdcst_func+0x150>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002bf2:	32 3b       	mov	r11,35
80002bf4:	30 1c       	mov	r12,1
80002bf6:	f0 1f 00 26 	mcall	80002c8c <DataSession_brdcst_func+0x16c>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002bfa:	e0 6c 17 70 	mov	r12,6000
80002bfe:	f0 1f 00 23 	mcall	80002c88 <DataSession_brdcst_func+0x168>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002c02:	32 3b       	mov	r11,35
80002c04:	30 0c       	mov	r12,0
80002c06:	f0 1f 00 22 	mcall	80002c8c <DataSession_brdcst_func+0x16c>
80002c0a:	c1 68       	rjmp	80002c36 <DataSession_brdcst_func+0x116>
				}
				else
				{
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002c0c:	4a 77       	lddpc	r7,80002ca8 <DataSession_brdcst_func+0x188>
80002c0e:	6e 0c       	ld.w	r12,r7[0x0]
80002c10:	30 09       	mov	r9,0
80002c12:	3f fa       	mov	r10,-1
80002c14:	12 9b       	mov	r11,r9
80002c16:	f0 1f 00 26 	mcall	80002cac <DataSession_brdcst_func+0x18c>
					global_count++;
80002c1a:	4a 68       	lddpc	r8,80002cb0 <DataSession_brdcst_func+0x190>
80002c1c:	70 09       	ld.w	r9,r8[0x0]
80002c1e:	2f f9       	sub	r9,-1
80002c20:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002c22:	6e 0c       	ld.w	r12,r7[0x0]
80002c24:	30 09       	mov	r9,0
80002c26:	12 9a       	mov	r10,r9
80002c28:	12 9b       	mov	r11,r9
80002c2a:	f0 1f 00 1e 	mcall	80002ca0 <DataSession_brdcst_func+0x180>
80002c2e:	c0 48       	rjmp	80002c36 <DataSession_brdcst_func+0x116>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002c30:	4a 1c       	lddpc	r12,80002cb4 <DataSession_brdcst_func+0x194>
80002c32:	f0 1f 00 10 	mcall	80002c70 <DataSession_brdcst_func+0x150>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002c36:	e0 6b 00 b7 	mov	r11,183
80002c3a:	30 1c       	mov	r12,1
80002c3c:	f0 1f 00 14 	mcall	80002c8c <DataSession_brdcst_func+0x16c>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002c40:	0d 89       	ld.ub	r9,r6[0x0]
80002c42:	20 39       	sub	r9,3
80002c44:	30 18       	mov	r8,1
80002c46:	f0 09 18 00 	cp.b	r9,r8
80002c4a:	e0 8b 00 0e 	brhi	80002c66 <DataSession_brdcst_func+0x146>
		{		
			//if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
			if( xSemaphoreGive( xBinarySemaphore ) != pdTRUE )
80002c4e:	49 b8       	lddpc	r8,80002cb8 <DataSession_brdcst_func+0x198>
80002c50:	70 0c       	ld.w	r12,r8[0x0]
80002c52:	30 09       	mov	r9,0
80002c54:	12 9a       	mov	r10,r9
80002c56:	12 9b       	mov	r11,r9
80002c58:	f0 1f 00 12 	mcall	80002ca0 <DataSession_brdcst_func+0x180>
80002c5c:	58 1c       	cp.w	r12,1
80002c5e:	c0 40       	breq	80002c66 <DataSession_brdcst_func+0x146>
			{
				log("xSemaphoreGive: err\n\r" );
80002c60:	49 7c       	lddpc	r12,80002cbc <DataSession_brdcst_func+0x19c>
80002c62:	f0 1f 00 04 	mcall	80002c70 <DataSession_brdcst_func+0x150>
				//
		//}
		
	}
	
}
80002c66:	2f 7d       	sub	sp,-36
80002c68:	d8 22       	popm	r4-r7,pc
80002c6a:	00 00       	add	r0,r0
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	e8 30 80 00 	sub	r0,622592
80002c72:	7f 68       	ld.w	r8,pc[0x58]
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	e8 44 80 00 	cp.w	r4,557056
80002c7a:	e8 5c 80 00 	cp.w	r12,622592
80002c7e:	e8 78 80 00 	mov	r8,622592
80002c82:	e8 90 80 00 	breq	80132c82 <_data_lma+0x123632>
80002c86:	e8 9c 80 00 	brvs	80132c86 <_data_lma+0x123636>
80002c8a:	79 fc       	ld.w	r12,r12[0x7c]
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	49 b8       	lddpc	r8,80002cf8 <send_flash_command>
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	88 12       	ld.sh	r2,r4[0x2]
80002c94:	00 00       	add	r0,r0
80002c96:	0b 9c       	ld.ub	r12,r5[0x1]
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	36 fc       	mov	r12,111
80002c9c:	00 00       	add	r0,r0
80002c9e:	0b 90       	ld.ub	r0,r5[0x1]
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	73 30       	ld.w	r0,r9[0x4c]
80002ca4:	80 00       	ld.sh	r0,r0[0x0]
80002ca6:	e8 b4       	*unknown*
80002ca8:	00 00       	add	r0,r0
80002caa:	0a 78       	tst	r8,r5
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	71 24       	ld.w	r4,r8[0x48]
80002cb0:	00 00       	add	r0,r0
80002cb2:	0a 80       	andn	r0,r5
80002cb4:	80 00       	ld.sh	r0,r0[0x0]
80002cb6:	e8 cc 00 00 	sub	r12,r4,0
80002cba:	0b a0       	ld.ub	r0,r5[0x2]
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	e8 dc d4 01 	satsub.w	r12,r4,-11263

80002cc0 <DeviceInitializationStatus_brdcst_func>:
volatile xSemaphoreHandle count_mutex = NULL;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002cc0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002cc2:	19 e8       	ld.ub	r8,r12[0x6]
80002cc4:	30 19       	mov	r9,1
80002cc6:	f2 08 18 00 	cp.b	r8,r9
80002cca:	c0 61       	brne	80002cd6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002ccc:	48 98       	lddpc	r8,80002cf0 <DeviceInitializationStatus_brdcst_func+0x30>
80002cce:	70 09       	ld.w	r9,r8[0x0]
80002cd0:	a1 a9       	sbr	r9,0x0
80002cd2:	91 09       	st.w	r8[0x0],r9
80002cd4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002cd6:	30 29       	mov	r9,2
80002cd8:	f2 08 18 00 	cp.b	r8,r9
80002cdc:	c0 80       	breq	80002cec <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002cde:	48 58       	lddpc	r8,80002cf0 <DeviceInitializationStatus_brdcst_func+0x30>
80002ce0:	70 09       	ld.w	r9,r8[0x0]
80002ce2:	e0 19 ff fc 	andl	r9,0xfffc
80002ce6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002ce8:	f0 1f 00 03 	mcall	80002cf4 <DeviceInitializationStatus_brdcst_func+0x34>
80002cec:	d8 02       	popm	pc
80002cee:	00 00       	add	r0,r0
80002cf0:	00 00       	add	r0,r0
80002cf2:	0e 1c       	sub	r12,r7
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	49 0c       	lddpc	r12,80002d34 <send_flash_command+0x3c>

80002cf8 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002cf8:	eb cd 40 fc 	pushm	r2-r7,lr
80002cfc:	20 1d       	sub	sp,4
80002cfe:	18 97       	mov	r7,r12
80002d00:	14 95       	mov	r5,r10
80002d02:	12 96       	mov	r6,r9
	U16 status = 1;
80002d04:	30 18       	mov	r8,1
80002d06:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002d08:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002d0c:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002d10:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002d14:	30 1b       	mov	r11,1
80002d16:	4e 58       	lddpc	r8,80002ea8 <send_flash_command+0x1b0>
80002d18:	70 0c       	ld.w	r12,r8[0x0]
80002d1a:	f0 1f 00 65 	mcall	80002eac <send_flash_command+0x1b4>

    switch (command)
80002d1e:	30 58       	mov	r8,5
80002d20:	f0 07 19 00 	cp.h	r7,r8
80002d24:	c3 40       	breq	80002d8c <send_flash_command+0x94>
80002d26:	e0 8b 00 18 	brhi	80002d56 <send_flash_command+0x5e>
80002d2a:	30 28       	mov	r8,2
80002d2c:	f0 07 19 00 	cp.h	r7,r8
80002d30:	c5 e0       	breq	80002dec <send_flash_command+0xf4>
80002d32:	e0 8b 00 08 	brhi	80002d42 <send_flash_command+0x4a>
80002d36:	30 18       	mov	r8,1
80002d38:	f0 07 19 00 	cp.h	r7,r8
80002d3c:	e0 81 00 ad 	brne	80002e96 <send_flash_command+0x19e>
80002d40:	c9 e8       	rjmp	80002e7c <send_flash_command+0x184>
80002d42:	30 38       	mov	r8,3
80002d44:	f0 07 19 00 	cp.h	r7,r8
80002d48:	c7 20       	breq	80002e2c <send_flash_command+0x134>
80002d4a:	30 48       	mov	r8,4
80002d4c:	f0 07 19 00 	cp.h	r7,r8
80002d50:	e0 81 00 a3 	brne	80002e96 <send_flash_command+0x19e>
80002d54:	c2 c8       	rjmp	80002dac <send_flash_command+0xb4>
80002d56:	35 28       	mov	r8,82
80002d58:	f0 07 19 00 	cp.h	r7,r8
80002d5c:	c2 f0       	breq	80002dba <send_flash_command+0xc2>
80002d5e:	e0 8b 00 0c 	brhi	80002d76 <send_flash_command+0x7e>
80002d62:	30 68       	mov	r8,6
80002d64:	f0 07 19 00 	cp.h	r7,r8
80002d68:	c2 20       	breq	80002dac <send_flash_command+0xb4>
80002d6a:	32 08       	mov	r8,32
80002d6c:	f0 07 19 00 	cp.h	r7,r8
80002d70:	e0 81 00 93 	brne	80002e96 <send_flash_command+0x19e>
80002d74:	c2 38       	rjmp	80002dba <send_flash_command+0xc2>
80002d76:	36 08       	mov	r8,96
80002d78:	f0 07 19 00 	cp.h	r7,r8
80002d7c:	c3 20       	breq	80002de0 <send_flash_command+0xe8>
80002d7e:	e0 68 00 d8 	mov	r8,216
80002d82:	f0 07 19 00 	cp.h	r7,r8
80002d86:	e0 81 00 88 	brne	80002e96 <send_flash_command+0x19e>
80002d8a:	c1 88       	rjmp	80002dba <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002d8c:	4c 77       	lddpc	r7,80002ea8 <send_flash_command+0x1b0>
80002d8e:	30 5b       	mov	r11,5
80002d90:	6e 0c       	ld.w	r12,r7[0x0]
80002d92:	f0 1f 00 48 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_dummy();
80002d96:	e0 6b 00 ff 	mov	r11,255
80002d9a:	6e 0c       	ld.w	r12,r7[0x0]
80002d9c:	f0 1f 00 45 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002da0:	fa cb ff fe 	sub	r11,sp,-2
80002da4:	6e 0c       	ld.w	r12,r7[0x0]
80002da6:	f0 1f 00 44 	mcall	80002eb4 <send_flash_command+0x1bc>
			break;
80002daa:	c7 68       	rjmp	80002e96 <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002dac:	0e 9b       	mov	r11,r7
80002dae:	5c 7b       	castu.h	r11
80002db0:	4b e8       	lddpc	r8,80002ea8 <send_flash_command+0x1b0>
80002db2:	70 0c       	ld.w	r12,r8[0x0]
80002db4:	f0 1f 00 3f 	mcall	80002eb0 <send_flash_command+0x1b8>
			break;
80002db8:	c6 f8       	rjmp	80002e96 <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002dba:	4b c6       	lddpc	r6,80002ea8 <send_flash_command+0x1b0>
80002dbc:	0e 9b       	mov	r11,r7
80002dbe:	5c 7b       	castu.h	r11
80002dc0:	6c 0c       	ld.w	r12,r6[0x0]
80002dc2:	f0 1f 00 3c 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002dc6:	08 9b       	mov	r11,r4
80002dc8:	6c 0c       	ld.w	r12,r6[0x0]
80002dca:	f0 1f 00 3a 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002dce:	06 9b       	mov	r11,r3
80002dd0:	6c 0c       	ld.w	r12,r6[0x0]
80002dd2:	f0 1f 00 38 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002dd6:	04 9b       	mov	r11,r2
80002dd8:	6c 0c       	ld.w	r12,r6[0x0]
80002dda:	f0 1f 00 36 	mcall	80002eb0 <send_flash_command+0x1b8>
			break;
80002dde:	c5 c8       	rjmp	80002e96 <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002de0:	36 0b       	mov	r11,96
80002de2:	4b 28       	lddpc	r8,80002ea8 <send_flash_command+0x1b0>
80002de4:	70 0c       	ld.w	r12,r8[0x0]
80002de6:	f0 1f 00 33 	mcall	80002eb0 <send_flash_command+0x1b8>
			break;
80002dea:	c5 68       	rjmp	80002e96 <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002dec:	4a f7       	lddpc	r7,80002ea8 <send_flash_command+0x1b0>
80002dee:	30 2b       	mov	r11,2
80002df0:	6e 0c       	ld.w	r12,r7[0x0]
80002df2:	f0 1f 00 30 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002df6:	08 9b       	mov	r11,r4
80002df8:	6e 0c       	ld.w	r12,r7[0x0]
80002dfa:	f0 1f 00 2e 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002dfe:	06 9b       	mov	r11,r3
80002e00:	6e 0c       	ld.w	r12,r7[0x0]
80002e02:	f0 1f 00 2c 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e06:	04 9b       	mov	r11,r2
80002e08:	6e 0c       	ld.w	r12,r7[0x0]
80002e0a:	f0 1f 00 2a 	mcall	80002eb0 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e0e:	58 06       	cp.w	r6,0
80002e10:	c4 30       	breq	80002e96 <send_flash_command+0x19e>
80002e12:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002e14:	4a 54       	lddpc	r4,80002ea8 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002e16:	0f 3b       	ld.ub	r11,r7++
80002e18:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002e1a:	68 0c       	ld.w	r12,r4[0x0]
80002e1c:	f0 1f 00 25 	mcall	80002eb0 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e20:	0e 98       	mov	r8,r7
80002e22:	0a 18       	sub	r8,r5
80002e24:	ec 08 19 00 	cp.h	r8,r6
80002e28:	cf 73       	brcs	80002e16 <send_flash_command+0x11e>
80002e2a:	c3 68       	rjmp	80002e96 <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002e2c:	49 f7       	lddpc	r7,80002ea8 <send_flash_command+0x1b0>
80002e2e:	30 3b       	mov	r11,3
80002e30:	6e 0c       	ld.w	r12,r7[0x0]
80002e32:	f0 1f 00 20 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e36:	08 9b       	mov	r11,r4
80002e38:	6e 0c       	ld.w	r12,r7[0x0]
80002e3a:	f0 1f 00 1e 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e3e:	06 9b       	mov	r11,r3
80002e40:	6e 0c       	ld.w	r12,r7[0x0]
80002e42:	f0 1f 00 1c 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e46:	04 9b       	mov	r11,r2
80002e48:	6e 0c       	ld.w	r12,r7[0x0]
80002e4a:	f0 1f 00 1a 	mcall	80002eb0 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e4e:	58 06       	cp.w	r6,0
80002e50:	c2 30       	breq	80002e96 <send_flash_command+0x19e>
80002e52:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002e54:	49 54       	lddpc	r4,80002ea8 <send_flash_command+0x1b0>
80002e56:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002e5a:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002e5c:	06 9b       	mov	r11,r3
80002e5e:	68 0c       	ld.w	r12,r4[0x0]
80002e60:	f0 1f 00 14 	mcall	80002eb0 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002e64:	1a 9b       	mov	r11,sp
80002e66:	68 0c       	ld.w	r12,r4[0x0]
80002e68:	f0 1f 00 13 	mcall	80002eb4 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002e6c:	9a 08       	ld.sh	r8,sp[0x0]
80002e6e:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e70:	0e 98       	mov	r8,r7
80002e72:	0a 18       	sub	r8,r5
80002e74:	ec 08 19 00 	cp.h	r8,r6
80002e78:	cf 23       	brcs	80002e5c <send_flash_command+0x164>
80002e7a:	c0 e8       	rjmp	80002e96 <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002e7c:	48 b7       	lddpc	r7,80002ea8 <send_flash_command+0x1b0>
80002e7e:	30 1b       	mov	r11,1
80002e80:	6e 0c       	ld.w	r12,r7[0x0]
80002e82:	f0 1f 00 0c 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e86:	30 0b       	mov	r11,0
80002e88:	6e 0c       	ld.w	r12,r7[0x0]
80002e8a:	f0 1f 00 0a 	mcall	80002eb0 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e8e:	30 0b       	mov	r11,0
80002e90:	6e 0c       	ld.w	r12,r7[0x0]
80002e92:	f0 1f 00 08 	mcall	80002eb0 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002e96:	30 1b       	mov	r11,1
80002e98:	48 48       	lddpc	r8,80002ea8 <send_flash_command+0x1b0>
80002e9a:	70 0c       	ld.w	r12,r8[0x0]
80002e9c:	f0 1f 00 07 	mcall	80002eb8 <send_flash_command+0x1c0>

	return status;
}
80002ea0:	9a 1c       	ld.sh	r12,sp[0x2]
80002ea2:	2f fd       	sub	sp,-4
80002ea4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002ea8:	00 00       	add	r0,r0
80002eaa:	1e 28       	rsub	r8,pc
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	69 8c       	ld.w	r12,r4[0x60]
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	68 26       	ld.w	r6,r4[0x8]
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	68 42       	ld.w	r2,r4[0x10]
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	69 4c       	ld.w	r12,r4[0x50]

80002ebc <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002ebc:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002ebe:	58 0a       	cp.w	r10,0
80002ec0:	5f 09       	sreq	r9
80002ec2:	e0 68 ff fe 	mov	r8,65534
80002ec6:	ea 18 00 7f 	orh	r8,0x7f
80002eca:	10 3c       	cp.w	r12,r8
80002ecc:	5f b8       	srhi	r8
80002ece:	f3 e8 10 08 	or	r8,r9,r8
80002ed2:	c0 e1       	brne	80002eee <data_flash_read_block+0x32>
80002ed4:	e0 68 10 00 	mov	r8,4096
80002ed8:	f0 0b 19 00 	cp.h	r11,r8
80002edc:	e0 8b 00 09 	brhi	80002eee <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ee0:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ee4:	18 9b       	mov	r11,r12
80002ee6:	30 3c       	mov	r12,3
80002ee8:	f0 1f 00 02 	mcall	80002ef0 <data_flash_read_block+0x34>
80002eec:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002eee:	da 0a       	popm	pc,r12=1
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	2c f8       	sub	r8,-49

80002ef4 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ef4:	eb cd 40 fc 	pushm	r2-r7,lr
80002ef8:	18 94       	mov	r4,r12
80002efa:	16 93       	mov	r3,r11
80002efc:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002efe:	58 0c       	cp.w	r12,0
80002f00:	5f 09       	sreq	r9
80002f02:	e0 68 ff fe 	mov	r8,65534
80002f06:	ea 18 00 7f 	orh	r8,0x7f
80002f0a:	10 3b       	cp.w	r11,r8
80002f0c:	5f b8       	srhi	r8
80002f0e:	f3 e8 10 08 	or	r8,r9,r8
80002f12:	c3 a1       	brne	80002f86 <data_flash_write_page+0x92>
80002f14:	e0 68 01 00 	mov	r8,256
80002f18:	f0 0a 19 00 	cp.h	r10,r8
80002f1c:	e0 8b 00 35 	brhi	80002f86 <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002f20:	30 06       	mov	r6,0
80002f22:	30 55       	mov	r5,5
80002f24:	30 17       	mov	r7,1
80002f26:	0c 99       	mov	r9,r6
80002f28:	0c 9a       	mov	r10,r6
80002f2a:	0c 9b       	mov	r11,r6
80002f2c:	0a 9c       	mov	r12,r5
80002f2e:	f0 1f 00 19 	mcall	80002f90 <data_flash_write_page+0x9c>
80002f32:	ee 0c 19 00 	cp.h	r12,r7
80002f36:	cf 80       	breq	80002f26 <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002f38:	30 09       	mov	r9,0
80002f3a:	12 9a       	mov	r10,r9
80002f3c:	12 9b       	mov	r11,r9
80002f3e:	30 6c       	mov	r12,6
80002f40:	f0 1f 00 14 	mcall	80002f90 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002f44:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002f48:	08 9a       	mov	r10,r4
80002f4a:	06 9b       	mov	r11,r3
80002f4c:	30 2c       	mov	r12,2
80002f4e:	f0 1f 00 11 	mcall	80002f90 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002f52:	30 06       	mov	r6,0
80002f54:	30 57       	mov	r7,5
80002f56:	0c 99       	mov	r9,r6
80002f58:	0c 9a       	mov	r10,r6
80002f5a:	0c 9b       	mov	r11,r6
80002f5c:	0e 9c       	mov	r12,r7
80002f5e:	f0 1f 00 0d 	mcall	80002f90 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002f62:	5c 7c       	castu.h	r12
80002f64:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002f68:	cf 71       	brne	80002f56 <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002f6a:	18 97       	mov	r7,r12
80002f6c:	e2 17 00 20 	andl	r7,0x20,COH
80002f70:	f9 b7 01 06 	movne	r7,6
80002f74:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002f78:	30 09       	mov	r9,0
80002f7a:	12 9a       	mov	r10,r9
80002f7c:	12 9b       	mov	r11,r9
80002f7e:	30 4c       	mov	r12,4
80002f80:	f0 1f 00 04 	mcall	80002f90 <data_flash_write_page+0x9c>

	return return_code;
80002f84:	c0 28       	rjmp	80002f88 <data_flash_write_page+0x94>
80002f86:	30 17       	mov	r7,1
}
80002f88:	0e 9c       	mov	r12,r7
80002f8a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002f8e:	00 00       	add	r0,r0
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	2c f8       	sub	r8,-49

80002f94 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002f94:	d4 31       	pushm	r0-r7,lr
80002f96:	18 94       	mov	r4,r12
80002f98:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002f9c:	16 97       	mov	r7,r11
80002f9e:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002fa0:	30 03       	mov	r3,0
80002fa2:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002fa4:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002fa8:	c4 98       	rjmp	8000303a <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002faa:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002fae:	c1 b1       	brne	80002fe4 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002fb0:	e0 06 19 00 	cp.h	r6,r0
80002fb4:	e0 8b 00 0a 	brhi	80002fc8 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002fb8:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002fbc:	0e 9b       	mov	r11,r7
80002fbe:	08 9c       	mov	r12,r4
80002fc0:	f0 1f 00 24 	mcall	80003050 <data_flash_write_block+0xbc>
80002fc4:	30 06       	mov	r6,0
80002fc6:	c3 a8       	rjmp	8000303a <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002fc8:	e0 6a 01 00 	mov	r10,256
80002fcc:	0e 9b       	mov	r11,r7
80002fce:	08 9c       	mov	r12,r4
80002fd0:	f0 1f 00 20 	mcall	80003050 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002fd4:	ec c6 01 00 	sub	r6,r6,256
80002fd8:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002fda:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002fde:	ee c7 ff 00 	sub	r7,r7,-256
80002fe2:	c2 c8       	rjmp	8000303a <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002fe4:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002fe8:	0e 09       	add	r9,r7
80002fea:	0e 98       	mov	r8,r7
80002fec:	e4 18 00 7f 	andh	r8,0x7f
80002ff0:	e0 18 ff 00 	andl	r8,0xff00
80002ff4:	f0 c8 ff 00 	sub	r8,r8,-256
80002ff8:	10 39       	cp.w	r9,r8
80002ffa:	e0 88 00 19 	brls	8000302c <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002ffe:	0e 91       	mov	r1,r7
80003000:	5c 51       	castu.b	r1
80003002:	e0 6a 01 00 	mov	r10,256
80003006:	02 1a       	sub	r10,r1
80003008:	5c 7a       	castu.h	r10
8000300a:	0e 9b       	mov	r11,r7
8000300c:	08 9c       	mov	r12,r4
8000300e:	f0 1f 00 11 	mcall	80003050 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003012:	ec c6 01 00 	sub	r6,r6,256
80003016:	02 06       	add	r6,r1
80003018:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
8000301a:	e0 68 01 00 	mov	r8,256
8000301e:	f0 05 01 05 	sub	r5,r8,r5
80003022:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003024:	e0 17 ff 00 	andl	r7,0xff00
80003028:	10 07       	add	r7,r8
8000302a:	c0 88       	rjmp	8000303a <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
8000302c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003030:	0e 9b       	mov	r11,r7
80003032:	08 9c       	mov	r12,r4
80003034:	f0 1f 00 07 	mcall	80003050 <data_flash_write_block+0xbc>
80003038:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
8000303a:	e6 06 19 00 	cp.h	r6,r3
8000303e:	5f 19       	srne	r9
80003040:	58 7c       	cp.w	r12,7
80003042:	5f 08       	sreq	r8
80003044:	f3 e8 00 08 	and	r8,r9,r8
80003048:	e4 08 18 00 	cp.b	r8,r2
8000304c:	ca f1       	brne	80002faa <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
8000304e:	d8 32       	popm	r0-r7,pc
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	2e f4       	sub	r4,-17

80003054 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80003054:	eb cd 40 f8 	pushm	r3-r7,lr
80003058:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
8000305a:	e0 68 ff fe 	mov	r8,65534
8000305e:	ea 18 00 7f 	orh	r8,0x7f
80003062:	10 3c       	cp.w	r12,r8
80003064:	e0 88 00 04 	brls	8000306c <data_flash_erase_block+0x18>
80003068:	30 17       	mov	r7,1
8000306a:	c3 f8       	rjmp	800030e8 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
8000306c:	58 1b       	cp.w	r11,1
8000306e:	c0 31       	brne	80003074 <data_flash_erase_block+0x20>
80003070:	32 03       	mov	r3,32
80003072:	c0 a8       	rjmp	80003086 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80003074:	58 2b       	cp.w	r11,2
80003076:	c0 31       	brne	8000307c <data_flash_erase_block+0x28>
80003078:	35 23       	mov	r3,82
8000307a:	c0 68       	rjmp	80003086 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
8000307c:	e0 63 00 d8 	mov	r3,216
80003080:	58 3b       	cp.w	r11,3
80003082:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80003086:	30 06       	mov	r6,0
80003088:	30 55       	mov	r5,5
8000308a:	30 17       	mov	r7,1
8000308c:	0c 99       	mov	r9,r6
8000308e:	0c 9a       	mov	r10,r6
80003090:	0c 9b       	mov	r11,r6
80003092:	0a 9c       	mov	r12,r5
80003094:	f0 1f 00 17 	mcall	800030f0 <data_flash_erase_block+0x9c>
80003098:	ee 0c 19 00 	cp.h	r12,r7
8000309c:	cf 80       	breq	8000308c <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
8000309e:	30 09       	mov	r9,0
800030a0:	12 9a       	mov	r10,r9
800030a2:	12 9b       	mov	r11,r9
800030a4:	30 6c       	mov	r12,6
800030a6:	f0 1f 00 13 	mcall	800030f0 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
800030aa:	30 09       	mov	r9,0
800030ac:	12 9a       	mov	r10,r9
800030ae:	08 9b       	mov	r11,r4
800030b0:	06 9c       	mov	r12,r3
800030b2:	f0 1f 00 10 	mcall	800030f0 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800030b6:	30 06       	mov	r6,0
800030b8:	30 57       	mov	r7,5
800030ba:	0c 99       	mov	r9,r6
800030bc:	0c 9a       	mov	r10,r6
800030be:	0c 9b       	mov	r11,r6
800030c0:	0e 9c       	mov	r12,r7
800030c2:	f0 1f 00 0c 	mcall	800030f0 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
800030c6:	5c 7c       	castu.h	r12
800030c8:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800030cc:	cf 71       	brne	800030ba <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
800030ce:	18 97       	mov	r7,r12
800030d0:	e2 17 00 20 	andl	r7,0x20,COH
800030d4:	f9 b7 01 04 	movne	r7,4
800030d8:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800030dc:	30 09       	mov	r9,0
800030de:	12 9a       	mov	r10,r9
800030e0:	12 9b       	mov	r11,r9
800030e2:	30 4c       	mov	r12,4
800030e4:	f0 1f 00 03 	mcall	800030f0 <data_flash_erase_block+0x9c>

	return return_code;
}
800030e8:	0e 9c       	mov	r12,r7
800030ea:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800030ee:	00 00       	add	r0,r0
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	2c f8       	sub	r8,-49

800030f4 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
800030f4:	d4 31       	pushm	r0-r7,lr
800030f6:	20 3d       	sub	sp,12
800030f8:	50 0c       	stdsp	sp[0x0],r12
800030fa:	16 91       	mov	r1,r11
800030fc:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
800030fe:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80003102:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80003104:	e0 69 10 00 	mov	r9,4096
80003108:	f2 0a 01 07 	sub	r7,r9,r10
8000310c:	ea 07 19 00 	cp.h	r7,r5
80003110:	ea 07 17 b0 	movhi	r7,r5
80003114:	5c 87       	casts.h	r7
80003116:	16 92       	mov	r2,r11
80003118:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
8000311c:	4a e4       	lddpc	r4,800031d4 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000311e:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003120:	e8 c8 ff ff 	sub	r8,r4,-1
80003124:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80003126:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003128:	08 9a       	mov	r10,r4
8000312a:	e0 6b 10 00 	mov	r11,4096
8000312e:	04 9c       	mov	r12,r2
80003130:	f0 1f 00 2a 	mcall	800031d8 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80003134:	58 07       	cp.w	r7,0
80003136:	c3 00       	breq	80003196 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80003138:	40 13       	lddsp	r3,sp[0x4]
8000313a:	5c 73       	castu.h	r3
8000313c:	e8 03 07 08 	ld.ub	r8,r4[r3]
80003140:	ec 08 18 00 	cp.b	r8,r6
80003144:	c1 11       	brne	80003166 <data_flash_write+0x72>
80003146:	e6 c9 ff ff 	sub	r9,r3,-1
8000314a:	08 09       	add	r9,r4
8000314c:	30 08       	mov	r8,0
8000314e:	c0 58       	rjmp	80003158 <data_flash_write+0x64>
80003150:	13 3a       	ld.ub	r10,r9++
80003152:	ec 0a 18 00 	cp.b	r10,r6
80003156:	c0 81       	brne	80003166 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80003158:	2f f8       	sub	r8,-1
8000315a:	5c 88       	casts.h	r8
8000315c:	f0 07 19 00 	cp.h	r7,r8
80003160:	fe 9b ff f8 	brhi	80003150 <data_flash_write+0x5c>
80003164:	c1 98       	rjmp	80003196 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80003166:	30 1b       	mov	r11,1
80003168:	04 9c       	mov	r12,r2
8000316a:	f0 1f 00 1d 	mcall	800031dc <data_flash_write+0xe8>
8000316e:	40 08       	lddsp	r8,sp[0x0]
80003170:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003172:	40 2a       	lddsp	r10,sp[0x8]
80003174:	40 19       	lddsp	r9,sp[0x4]
80003176:	12 0a       	add	r10,r9
80003178:	0e 99       	mov	r9,r7
8000317a:	20 19       	sub	r9,1
8000317c:	5c 79       	castu.h	r9
8000317e:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80003180:	11 39       	ld.ub	r9,r8++
80003182:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80003184:	14 33       	cp.w	r3,r10
80003186:	cf d1       	brne	80003180 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80003188:	e0 6a 10 00 	mov	r10,4096
8000318c:	04 9b       	mov	r11,r2
8000318e:	08 9c       	mov	r12,r4
80003190:	f0 1f 00 14 	mcall	800031e0 <data_flash_write+0xec>
80003194:	c0 78       	rjmp	800031a2 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80003196:	0e 9a       	mov	r10,r7
80003198:	5c 7a       	castu.h	r10
8000319a:	02 9b       	mov	r11,r1
8000319c:	40 0c       	lddsp	r12,sp[0x0]
8000319e:	f0 1f 00 11 	mcall	800031e0 <data_flash_write+0xec>
800031a2:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
800031a6:	0e 98       	mov	r8,r7
800031a8:	ee 05 19 00 	cp.h	r5,r7
800031ac:	c1 20       	breq	800031d0 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
800031ae:	5c 78       	castu.h	r8
800031b0:	40 0a       	lddsp	r10,sp[0x0]
800031b2:	10 0a       	add	r10,r8
800031b4:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
800031b6:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
800031b8:	0e 15       	sub	r5,r7
800031ba:	5c 85       	casts.h	r5
800031bc:	e0 05 19 00 	cp.h	r5,r0
800031c0:	ea 07 17 80 	movls	r7,r5
800031c4:	e0 07 17 b0 	movhi	r7,r0
800031c8:	5c 87       	casts.h	r7
800031ca:	30 09       	mov	r9,0
800031cc:	50 19       	stdsp	sp[0x4],r9
800031ce:	ca db       	rjmp	80003128 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
800031d0:	2f dd       	sub	sp,-12
800031d2:	d8 32       	popm	r0-r7,pc
800031d4:	00 00       	add	r0,r0
800031d6:	0e 28       	rsub	r8,r7
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	2e bc       	sub	r12,-21
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	30 54       	mov	r4,5
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	2f 94       	sub	r4,-7

800031e4 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800031e4:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800031e6:	48 78       	lddpc	r8,80003200 <W25Q64_SPI_SetSpeed+0x1c>
800031e8:	70 09       	ld.w	r9,r8[0x0]
800031ea:	72 da       	ld.w	r10,r9[0x34]
800031ec:	5c 7c       	castu.h	r12
800031ee:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800031f2:	f9 ea 10 0a 	or	r10,r12,r10
800031f6:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
800031f8:	70 0c       	ld.w	r12,r8[0x0]
800031fa:	f0 1f 00 03 	mcall	80003204 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
800031fe:	d8 02       	popm	pc
80003200:	00 00       	add	r0,r0
80003202:	1e 28       	rsub	r8,pc
80003204:	80 00       	ld.sh	r0,r0[0x0]
80003206:	68 20       	ld.w	r0,r4[0x8]

80003208 <W25Q64_SPI_SetSpeedLow>:
void W25Q64_SPI_SetSpeedLow(void)
{
80003208:	d4 01       	pushm	lr
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
8000320a:	e0 6c 02 00 	mov	r12,512
8000320e:	f0 1f 00 02 	mcall	80003214 <W25Q64_SPI_SetSpeedLow+0xc>
	
}
80003212:	d8 02       	popm	pc
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	31 e4       	mov	r4,30

80003218 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003218:	eb cd 40 c0 	pushm	r6-r7,lr
8000321c:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
8000321e:	4b a8       	lddpc	r8,80003304 <data_flash_init+0xec>
80003220:	fa c6 ff fc 	sub	r6,sp,-4
80003224:	f0 ea 00 00 	ld.d	r10,r8[0]
80003228:	ec eb 00 00 	st.d	r6[0],r10
8000322c:	f0 e8 00 08 	ld.d	r8,r8[8]
80003230:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003234:	30 4b       	mov	r11,4
80003236:	4b 5c       	lddpc	r12,80003308 <data_flash_init+0xf0>
80003238:	f0 1f 00 35 	mcall	8000330c <data_flash_init+0xf4>

	spi = &AVR32_SPI;
8000323c:	4b 57       	lddpc	r7,80003310 <data_flash_init+0xf8>
8000323e:	fe 7c 24 00 	mov	r12,-56320
80003242:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003244:	0c 9b       	mov	r11,r6
80003246:	f0 1f 00 34 	mcall	80003314 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000324a:	30 09       	mov	r9,0
8000324c:	12 9a       	mov	r10,r9
8000324e:	12 9b       	mov	r11,r9
80003250:	6e 0c       	ld.w	r12,r7[0x0]
80003252:	f0 1f 00 32 	mcall	80003318 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
80003256:	6e 0c       	ld.w	r12,r7[0x0]
80003258:	f0 1f 00 31 	mcall	8000331c <data_flash_init+0x104>

	W25Q64_SPI_SetSpeedLow();
8000325c:	f0 1f 00 31 	mcall	80003320 <data_flash_init+0x108>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80003260:	e0 6a 36 00 	mov	r10,13824
80003264:	ea 1a 01 6e 	orh	r10,0x16e
80003268:	0c 9b       	mov	r11,r6
8000326a:	6e 0c       	ld.w	r12,r7[0x0]
8000326c:	f0 1f 00 2e 	mcall	80003324 <data_flash_init+0x10c>
80003270:	c0 50       	breq	8000327a <data_flash_init+0x62>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80003272:	30 29       	mov	r9,2
80003274:	4a d8       	lddpc	r8,80003328 <data_flash_init+0x110>
80003276:	b0 89       	st.b	r8[0x0],r9
		return;
80003278:	c4 28       	rjmp	800032fc <data_flash_init+0xe4>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
8000327a:	1a 96       	mov	r6,sp
8000327c:	30 4a       	mov	r10,4
8000327e:	4a cb       	lddpc	r11,8000332c <data_flash_init+0x114>
80003280:	1a 9c       	mov	r12,sp
80003282:	f0 1f 00 2c 	mcall	80003330 <data_flash_init+0x118>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80003286:	4a 37       	lddpc	r7,80003310 <data_flash_init+0xf8>
80003288:	30 1b       	mov	r11,1
8000328a:	6e 0c       	ld.w	r12,r7[0x0]
8000328c:	f0 1f 00 2a 	mcall	80003334 <data_flash_init+0x11c>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80003290:	e0 6b 00 90 	mov	r11,144
80003294:	6e 0c       	ld.w	r12,r7[0x0]
80003296:	f0 1f 00 29 	mcall	80003338 <data_flash_init+0x120>
	spi_write_zero();
8000329a:	30 0b       	mov	r11,0
8000329c:	6e 0c       	ld.w	r12,r7[0x0]
8000329e:	f0 1f 00 27 	mcall	80003338 <data_flash_init+0x120>
	spi_write_zero();
800032a2:	30 0b       	mov	r11,0
800032a4:	6e 0c       	ld.w	r12,r7[0x0]
800032a6:	f0 1f 00 25 	mcall	80003338 <data_flash_init+0x120>
	spi_write_zero();
800032aa:	30 0b       	mov	r11,0
800032ac:	6e 0c       	ld.w	r12,r7[0x0]
800032ae:	f0 1f 00 23 	mcall	80003338 <data_flash_init+0x120>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
800032b2:	e0 6b 00 ff 	mov	r11,255
800032b6:	6e 0c       	ld.w	r12,r7[0x0]
800032b8:	f0 1f 00 20 	mcall	80003338 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[0]);
800032bc:	1a 9b       	mov	r11,sp
800032be:	6e 0c       	ld.w	r12,r7[0x0]
800032c0:	f0 1f 00 1f 	mcall	8000333c <data_flash_init+0x124>
	
	spi_write_dummy();
800032c4:	e0 6b 00 ff 	mov	r11,255
800032c8:	6e 0c       	ld.w	r12,r7[0x0]
800032ca:	f0 1f 00 1c 	mcall	80003338 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[1]);
800032ce:	fa cb ff fe 	sub	r11,sp,-2
800032d2:	6e 0c       	ld.w	r12,r7[0x0]
800032d4:	f0 1f 00 1a 	mcall	8000333c <data_flash_init+0x124>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
800032d8:	30 1b       	mov	r11,1
800032da:	6e 0c       	ld.w	r12,r7[0x0]
800032dc:	f0 1f 00 19 	mcall	80003340 <data_flash_init+0x128>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
800032e0:	e0 68 00 ef 	mov	r8,239
800032e4:	9a 09       	ld.sh	r9,sp[0x0]
800032e6:	f0 09 19 00 	cp.h	r9,r8
800032ea:	c0 61       	brne	800032f6 <data_flash_init+0xde>
800032ec:	31 68       	mov	r8,22
800032ee:	9a 19       	ld.sh	r9,sp[0x2]
800032f0:	f0 09 19 00 	cp.h	r9,r8
800032f4:	c0 40       	breq	800032fc <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
800032f6:	30 39       	mov	r9,3
800032f8:	48 c8       	lddpc	r8,80003328 <data_flash_init+0x110>
800032fa:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
800032fc:	2f bd       	sub	sp,-20
800032fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003302:	00 00       	add	r0,r0
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	e9 18 80 00 	ld.uh	r8,r4[-32768]
8000330a:	e8 f4 80 00 	ld.w	r4,r4[-32768]
8000330e:	63 4c       	ld.w	r12,r1[0x50]
80003310:	00 00       	add	r0,r0
80003312:	1e 28       	rsub	r8,pc
80003314:	80 00       	ld.sh	r0,r0[0x0]
80003316:	67 bc       	ld.w	r12,r3[0x6c]
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	67 f4       	ld.w	r4,r3[0x7c]
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	68 20       	ld.w	r0,r4[0x8]
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	32 08       	mov	r8,32
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	68 64       	ld.w	r4,r4[0x18]
80003328:	00 00       	add	r0,r0
8000332a:	0a 87       	andn	r7,r5
8000332c:	80 00       	ld.sh	r0,r0[0x0]
8000332e:	e9 14 80 00 	ld.uh	r4,r4[-32768]
80003332:	88 12       	ld.sh	r2,r4[0x2]
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	69 8c       	ld.w	r12,r4[0x60]
80003338:	80 00       	ld.sh	r0,r0[0x0]
8000333a:	68 26       	ld.w	r6,r4[0x8]
8000333c:	80 00       	ld.sh	r0,r0[0x0]
8000333e:	68 42       	ld.w	r2,r4[0x10]
80003340:	80 00       	ld.sh	r0,r0[0x0]
80003342:	69 4c       	ld.w	r12,r4[0x50]

80003344 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003344:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80003346:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80003348:	30 0a       	mov	r10,0
8000334a:	32 8b       	mov	r11,40
8000334c:	49 5c       	lddpc	r12,800033a0 <xg_rtc_init+0x5c>
8000334e:	f0 1f 00 16 	mcall	800033a4 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80003352:	30 ea       	mov	r10,14
80003354:	30 1b       	mov	r11,1
80003356:	fe 7c 0d 00 	mov	r12,-62208
8000335a:	f0 1f 00 14 	mcall	800033a8 <xg_rtc_init+0x64>
8000335e:	c0 41       	brne	80003366 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003360:	49 3c       	lddpc	r12,800033ac <xg_rtc_init+0x68>
80003362:	f0 1f 00 14 	mcall	800033b0 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80003366:	30 0b       	mov	r11,0
80003368:	fe 7c 0d 00 	mov	r12,-62208
8000336c:	f0 1f 00 12 	mcall	800033b4 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003370:	fe 7c 0d 00 	mov	r12,-62208
80003374:	f0 1f 00 11 	mcall	800033b8 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80003378:	fe 7c 0d 00 	mov	r12,-62208
8000337c:	f0 1f 00 10 	mcall	800033bc <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003380:	49 08       	lddpc	r8,800033c0 <xg_rtc_init+0x7c>
80003382:	31 09       	mov	r9,16
80003384:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80003386:	30 29       	mov	r9,2
80003388:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000338a:	31 d9       	mov	r9,29
8000338c:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
8000338e:	31 79       	mov	r9,23
80003390:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003392:	33 b9       	mov	r9,59
80003394:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80003396:	32 89       	mov	r9,40
80003398:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000339a:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
8000339c:	d8 02       	popm	pc
8000339e:	00 00       	add	r0,r0
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	33 c4       	mov	r4,60
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	63 d0       	ld.w	r0,r1[0x74]
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	67 1c       	ld.w	r12,r3[0x44]
800033ac:	80 00       	ld.sh	r0,r0[0x0]
800033ae:	e9 28 80 00 	ld.sb	r8,r4[-32768]
800033b2:	7f 68       	ld.w	r8,pc[0x58]
800033b4:	80 00       	ld.sh	r0,r0[0x0]
800033b6:	66 d8       	ld.w	r8,r3[0x34]
800033b8:	80 00       	ld.sh	r0,r0[0x0]
800033ba:	66 d0       	ld.w	r0,r3[0x34]
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	66 ac       	ld.w	r12,r3[0x28]
800033c0:	00 00       	add	r0,r0
800033c2:	0e 20       	rsub	r0,r7

800033c4 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800033c4:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800033c6:	4b 98       	lddpc	r8,800034a8 <rtc_irq+0xe4>
800033c8:	11 d9       	ld.ub	r9,r8[0x5]
800033ca:	2f f9       	sub	r9,-1
800033cc:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800033ce:	11 d9       	ld.ub	r9,r8[0x5]
800033d0:	33 b8       	mov	r8,59
800033d2:	f0 09 18 00 	cp.b	r9,r8
800033d6:	e0 88 00 5f 	brls	80003494 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800033da:	4b 48       	lddpc	r8,800034a8 <rtc_irq+0xe4>
800033dc:	30 09       	mov	r9,0
800033de:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800033e0:	11 c9       	ld.ub	r9,r8[0x4]
800033e2:	2f f9       	sub	r9,-1
800033e4:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800033e6:	11 c9       	ld.ub	r9,r8[0x4]
800033e8:	33 b8       	mov	r8,59
800033ea:	f0 09 18 00 	cp.b	r9,r8
800033ee:	e0 88 00 53 	brls	80003494 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800033f2:	4a e8       	lddpc	r8,800034a8 <rtc_irq+0xe4>
800033f4:	30 09       	mov	r9,0
800033f6:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800033f8:	11 b9       	ld.ub	r9,r8[0x3]
800033fa:	2f f9       	sub	r9,-1
800033fc:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800033fe:	11 b9       	ld.ub	r9,r8[0x3]
80003400:	31 78       	mov	r8,23
80003402:	f0 09 18 00 	cp.b	r9,r8
80003406:	e0 88 00 47 	brls	80003494 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
8000340a:	4a 88       	lddpc	r8,800034a8 <rtc_irq+0xe4>
8000340c:	30 09       	mov	r9,0
8000340e:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003410:	11 88       	ld.ub	r8,r8[0x0]
80003412:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003416:	e0 69 01 6e 	mov	r9,366
8000341a:	e0 6a 01 6d 	mov	r10,365
8000341e:	f4 08 17 10 	movne	r8,r10
80003422:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80003426:	4a 19       	lddpc	r9,800034a8 <rtc_irq+0xe4>
80003428:	13 9a       	ld.ub	r10,r9[0x1]
8000342a:	30 29       	mov	r9,2
8000342c:	f2 0a 18 00 	cp.b	r10,r9
80003430:	c0 b0       	breq	80003446 <rtc_irq+0x82>
80003432:	49 e8       	lddpc	r8,800034a8 <rtc_irq+0xe4>
80003434:	11 99       	ld.ub	r9,r8[0x1]
80003436:	11 9a       	ld.ub	r10,r8[0x1]
80003438:	a3 9a       	lsr	r10,0x3
8000343a:	12 0a       	add	r10,r9
8000343c:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003440:	2e 2a       	sub	r10,-30
80003442:	5c 5a       	castu.b	r10
80003444:	c0 58       	rjmp	8000344e <rtc_irq+0x8a>
80003446:	f0 c8 01 51 	sub	r8,r8,337
8000344a:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
8000344e:	49 78       	lddpc	r8,800034a8 <rtc_irq+0xe4>
80003450:	11 a9       	ld.ub	r9,r8[0x2]
80003452:	2f f9       	sub	r9,-1
80003454:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80003456:	11 a8       	ld.ub	r8,r8[0x2]
80003458:	f0 0a 18 00 	cp.b	r10,r8
8000345c:	c1 c2       	brcc	80003494 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
8000345e:	49 38       	lddpc	r8,800034a8 <rtc_irq+0xe4>
80003460:	30 19       	mov	r9,1
80003462:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003464:	11 99       	ld.ub	r9,r8[0x1]
80003466:	2f f9       	sub	r9,-1
80003468:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
8000346a:	11 99       	ld.ub	r9,r8[0x1]
8000346c:	30 c8       	mov	r8,12
8000346e:	f0 09 18 00 	cp.b	r9,r8
80003472:	e0 88 00 11 	brls	80003494 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80003476:	48 d8       	lddpc	r8,800034a8 <rtc_irq+0xe4>
80003478:	30 19       	mov	r9,1
8000347a:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
8000347c:	11 89       	ld.ub	r9,r8[0x0]
8000347e:	2f f9       	sub	r9,-1
80003480:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80003482:	11 89       	ld.ub	r9,r8[0x0]
80003484:	39 68       	mov	r8,-106
80003486:	f0 09 18 00 	cp.b	r9,r8
8000348a:	e0 88 00 05 	brls	80003494 <rtc_irq+0xd0>
8000348e:	30 09       	mov	r9,0
80003490:	48 68       	lddpc	r8,800034a8 <rtc_irq+0xe4>
80003492:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003494:	fe 7c 0d 00 	mov	r12,-62208
80003498:	f0 1f 00 05 	mcall	800034ac <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
8000349c:	30 19       	mov	r9,1
8000349e:	48 58       	lddpc	r8,800034b0 <rtc_irq+0xec>
800034a0:	91 09       	st.w	r8[0x0],r9
}
800034a2:	d4 02       	popm	lr
800034a4:	d6 03       	rete
800034a6:	00 00       	add	r0,r0
800034a8:	00 00       	add	r0,r0
800034aa:	0e 20       	rsub	r0,r7
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	66 fc       	ld.w	r12,r3[0x3c]
800034b0:	00 00       	add	r0,r0
800034b2:	04 fc       	st.b	--r2,r12

800034b4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800034b4:	20 1c       	sub	r12,1
800034b6:	5c 5c       	castu.b	r12
800034b8:	31 18       	mov	r8,17
800034ba:	f0 0c 18 00 	cp.b	r12,r8
800034be:	e0 88 00 03 	brls	800034c4 <CalculateBurst+0x10>
800034c2:	5e fd       	retal	0
800034c4:	48 28       	lddpc	r8,800034cc <CalculateBurst+0x18>
800034c6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800034ca:	5e fc       	retal	r12
800034cc:	80 00       	ld.sh	r0,r0[0x0]
800034ce:	e9 48 48 38 	st.w	r4[18488],r8

800034d0 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800034d0:	48 38       	lddpc	r8,800034dc <payload_init+0xc>
800034d2:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800034d4:	48 38       	lddpc	r8,800034e0 <payload_init+0x10>
800034d6:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800034d8:	5e fc       	retal	r12
800034da:	00 00       	add	r0,r0
800034dc:	00 00       	add	r0,r0
800034de:	0a 88       	andn	r8,r5
800034e0:	00 00       	add	r0,r0
800034e2:	0a 8c       	andn	r12,r5

800034e4 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800034e4:	d4 01       	pushm	lr
800034e6:	20 2d       	sub	sp,8
800034e8:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800034ea:	30 09       	mov	r9,0
800034ec:	fa ca ff f8 	sub	r10,sp,-8
800034f0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800034f2:	1a 9b       	mov	r11,sp
800034f4:	f0 1f 00 02 	mcall	800034fc <set_idle_store_isr+0x18>
}
800034f8:	2f ed       	sub	sp,-8
800034fa:	d8 02       	popm	pc
800034fc:	80 00       	ld.sh	r0,r0[0x0]
800034fe:	72 e0       	ld.w	r0,r9[0x38]

80003500 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003500:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80003502:	48 48       	lddpc	r8,80003510 <payload_rx+0x10>
80003504:	70 08       	ld.w	r8,r8[0x0]
80003506:	18 9b       	mov	r11,r12
80003508:	10 9c       	mov	r12,r8
8000350a:	f0 1f 00 03 	mcall	80003514 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
8000350e:	d8 02       	popm	pc
80003510:	00 00       	add	r0,r0
80003512:	0a c4       	st.b	r5++,r4
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	34 e4       	mov	r4,78

80003518 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003518:	d4 01       	pushm	lr
8000351a:	20 2d       	sub	sp,8
8000351c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000351e:	58 0c       	cp.w	r12,0
80003520:	c1 10       	breq	80003542 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003522:	30 08       	mov	r8,0
80003524:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003526:	98 88       	ld.uh	r8,r12[0x0]
80003528:	e2 18 f0 00 	andl	r8,0xf000,COH
8000352c:	e0 48 40 00 	cp.w	r8,16384
80003530:	c0 91       	brne	80003542 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003532:	48 68       	lddpc	r8,80003548 <phy_rx+0x30>
80003534:	70 0c       	ld.w	r12,r8[0x0]
80003536:	30 09       	mov	r9,0
80003538:	fa ca ff fc 	sub	r10,sp,-4
8000353c:	1a 9b       	mov	r11,sp
8000353e:	f0 1f 00 04 	mcall	8000354c <phy_rx+0x34>
		}	

    }
		
 
}
80003542:	2f ed       	sub	sp,-8
80003544:	d8 02       	popm	pc
80003546:	00 00       	add	r0,r0
80003548:	00 00       	add	r0,r0
8000354a:	0a d0       	st.w	--r5,r0
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	72 e0       	ld.w	r0,r9[0x38]

80003550 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003550:	eb cd 40 80 	pushm	r7,lr
80003554:	20 1d       	sub	sp,4
80003556:	fa c7 ff fc 	sub	r7,sp,-4
8000355a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
8000355c:	30 09       	mov	r9,0
8000355e:	12 9a       	mov	r10,r9
80003560:	1a 9b       	mov	r11,sp
80003562:	f0 1f 00 03 	mcall	8000356c <set_idle_store+0x1c>
}
80003566:	2f fd       	sub	sp,-4
80003568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	73 30       	ld.w	r0,r9[0x4c]

80003570 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003570:	d4 01       	pushm	lr
80003572:	20 1d       	sub	sp,4
80003574:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003576:	98 88       	ld.uh	r8,r12[0x0]
80003578:	e2 18 f0 00 	andl	r8,0xf000,COH
8000357c:	e0 48 40 00 	cp.w	r8,16384
80003580:	c0 d1       	brne	8000359a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003582:	49 08       	lddpc	r8,800035c0 <phy_tx+0x50>
80003584:	70 08       	ld.w	r8,r8[0x0]
80003586:	58 08       	cp.w	r8,0
80003588:	c1 a0       	breq	800035bc <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000358a:	48 e8       	lddpc	r8,800035c0 <phy_tx+0x50>
8000358c:	70 0c       	ld.w	r12,r8[0x0]
8000358e:	30 09       	mov	r9,0
80003590:	12 9a       	mov	r10,r9
80003592:	1a 9b       	mov	r11,sp
80003594:	f0 1f 00 0c 	mcall	800035c4 <phy_tx+0x54>
80003598:	c1 28       	rjmp	800035bc <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000359a:	e0 48 10 00 	cp.w	r8,4096
8000359e:	5f 0a       	sreq	r10
800035a0:	e0 48 20 00 	cp.w	r8,8192
800035a4:	5f 09       	sreq	r9
800035a6:	f5 e9 10 09 	or	r9,r10,r9
800035aa:	c0 71       	brne	800035b8 <phy_tx+0x48>
800035ac:	e0 48 50 00 	cp.w	r8,20480
800035b0:	c0 40       	breq	800035b8 <phy_tx+0x48>
800035b2:	e0 48 60 00 	cp.w	r8,24576
800035b6:	c0 31       	brne	800035bc <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
800035b8:	48 48       	lddpc	r8,800035c8 <phy_tx+0x58>
800035ba:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
800035bc:	2f fd       	sub	sp,-4
800035be:	d8 02       	popm	pc
800035c0:	00 00       	add	r0,r0
800035c2:	0a f0       	st.b	--r5,r0
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	73 30       	ld.w	r0,r9[0x4c]
800035c8:	00 00       	add	r0,r0
800035ca:	0a e4       	st.h	--r5,r4

800035cc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
800035cc:	d4 01       	pushm	lr
800035ce:	20 2d       	sub	sp,8
	void * ptr = NULL;
800035d0:	30 08       	mov	r8,0
800035d2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800035d4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
800035d6:	1a 9a       	mov	r10,sp
800035d8:	fa cb ff fc 	sub	r11,sp,-4
800035dc:	f0 1f 00 05 	mcall	800035f0 <get_idle_store_isr+0x24>
800035e0:	58 1c       	cp.w	r12,1
800035e2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800035e6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
800035ea:	2f ed       	sub	sp,-8
800035ec:	d8 02       	popm	pc
800035ee:	00 00       	add	r0,r0
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	70 34       	ld.w	r4,r8[0xc]

800035f4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800035f4:	eb cd 40 c0 	pushm	r6-r7,lr
800035f8:	20 1d       	sub	sp,4
800035fa:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800035fc:	4b a8       	lddpc	r8,800036e4 <phy_tx_func+0xf0>
800035fe:	70 08       	ld.w	r8,r8[0x0]
80003600:	58 08       	cp.w	r8,0
80003602:	c6 60       	breq	800036ce <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003604:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003606:	30 08       	mov	r8,0
80003608:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
8000360a:	4b 88       	lddpc	r8,800036e8 <phy_tx_func+0xf4>
8000360c:	70 08       	ld.w	r8,r8[0x0]
8000360e:	58 18       	cp.w	r8,1
80003610:	c2 60       	breq	8000365c <phy_tx_func+0x68>
80003612:	c0 43       	brcs	8000361a <phy_tx_func+0x26>
80003614:	58 28       	cp.w	r8,2
80003616:	c5 c1       	brne	800036ce <phy_tx_func+0xda>
80003618:	c5 58       	rjmp	800036c2 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
8000361a:	4b 38       	lddpc	r8,800036e4 <phy_tx_func+0xf0>
8000361c:	70 0c       	ld.w	r12,r8[0x0]
8000361e:	1a 9a       	mov	r10,sp
80003620:	4b 3b       	lddpc	r11,800036ec <phy_tx_func+0xf8>
80003622:	f0 1f 00 34 	mcall	800036f0 <phy_tx_func+0xfc>
80003626:	58 1c       	cp.w	r12,1
80003628:	c1 41       	brne	80003650 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
8000362a:	4b 18       	lddpc	r8,800036ec <phy_tx_func+0xf8>
8000362c:	70 08       	ld.w	r8,r8[0x0]
8000362e:	90 08       	ld.sh	r8,r8[0x0]
80003630:	10 9a       	mov	r10,r8
80003632:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003636:	4b 09       	lddpc	r9,800036f4 <phy_tx_func+0x100>
80003638:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
8000363a:	5c 78       	castu.h	r8
8000363c:	ea 18 ab cd 	orh	r8,0xabcd
80003640:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003642:	30 19       	mov	r9,1
80003644:	4a d8       	lddpc	r8,800036f8 <phy_tx_func+0x104>
80003646:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003648:	30 19       	mov	r9,1
8000364a:	4a 88       	lddpc	r8,800036e8 <phy_tx_func+0xf4>
8000364c:	91 09       	st.w	r8[0x0],r9
8000364e:	c4 08       	rjmp	800036ce <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003650:	e0 68 5a 5a 	mov	r8,23130
80003654:	ea 18 ab cd 	orh	r8,0xabcd
80003658:	8f 18       	st.w	r7[0x4],r8
8000365a:	c3 a8       	rjmp	800036ce <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000365c:	4a 7a       	lddpc	r10,800036f8 <phy_tx_func+0x104>
8000365e:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003660:	4a 39       	lddpc	r9,800036ec <phy_tx_func+0xf8>
80003662:	72 09       	ld.w	r9,r9[0x0]
80003664:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003668:	b1 69       	lsl	r9,0x10
8000366a:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000366c:	2f f8       	sub	r8,-1
8000366e:	5c 58       	castu.b	r8
80003670:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80003672:	4a 1b       	lddpc	r11,800036f4 <phy_tx_func+0x100>
80003674:	96 0c       	ld.sh	r12,r11[0x0]
80003676:	20 2c       	sub	r12,2
80003678:	5c 8c       	casts.h	r12
8000367a:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000367e:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003680:	30 0b       	mov	r11,0
80003682:	f6 0a 19 00 	cp.h	r10,r11
80003686:	e0 89 00 09 	brgt	80003698 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000368a:	e8 19 00 ba 	orl	r9,0xba
8000368e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003690:	30 09       	mov	r9,0
80003692:	49 68       	lddpc	r8,800036e8 <phy_tx_func+0xf4>
80003694:	91 09       	st.w	r8[0x0],r9
80003696:	c1 c8       	rjmp	800036ce <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003698:	49 5a       	lddpc	r10,800036ec <phy_tx_func+0xf8>
8000369a:	74 0a       	ld.w	r10,r10[0x0]
8000369c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
800036a0:	14 49       	or	r9,r10
800036a2:	8f 19       	st.w	r7[0x4],r9
800036a4:	2f f8       	sub	r8,-1
800036a6:	49 59       	lddpc	r9,800036f8 <phy_tx_func+0x104>
800036a8:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
800036aa:	20 2c       	sub	r12,2
800036ac:	49 28       	lddpc	r8,800036f4 <phy_tx_func+0x100>
800036ae:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800036b0:	30 08       	mov	r8,0
800036b2:	f0 0c 19 00 	cp.h	r12,r8
800036b6:	e0 89 00 0c 	brgt	800036ce <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
800036ba:	30 29       	mov	r9,2
800036bc:	48 b8       	lddpc	r8,800036e8 <phy_tx_func+0xf4>
800036be:	91 09       	st.w	r8[0x0],r9
800036c0:	c0 78       	rjmp	800036ce <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
800036c2:	fc 18 00 ba 	movh	r8,0xba
800036c6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
800036c8:	30 09       	mov	r9,0
800036ca:	48 88       	lddpc	r8,800036e8 <phy_tx_func+0xf4>
800036cc:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
800036ce:	e0 68 5a 5a 	mov	r8,23130
800036d2:	ea 18 ab cd 	orh	r8,0xabcd
800036d6:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
800036d8:	30 08       	mov	r8,0
800036da:	8f 38       	st.w	r7[0xc],r8
}
800036dc:	2f fd       	sub	sp,-4
800036de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036e2:	00 00       	add	r0,r0
800036e4:	00 00       	add	r0,r0
800036e6:	0a f0       	st.b	--r5,r0
800036e8:	00 00       	add	r0,r0
800036ea:	0a b0       	st.h	r5++,r0
800036ec:	00 00       	add	r0,r0
800036ee:	0a bc       	st.h	r5++,r12
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	70 34       	ld.w	r4,r8[0xc]
800036f4:	00 00       	add	r0,r0
800036f6:	0a d8       	st.w	--r5,r8
800036f8:	00 00       	add	r0,r0
800036fa:	0a 90       	mov	r0,r5

800036fc <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800036fc:	d4 01       	pushm	lr
800036fe:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003700:	30 0a       	mov	r10,0
80003702:	fa cb ff fc 	sub	r11,sp,-4
80003706:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003708:	14 99       	mov	r9,r10
8000370a:	1a 9b       	mov	r11,sp
8000370c:	f0 1f 00 05 	mcall	80003720 <get_idle_store+0x24>
80003710:	58 1c       	cp.w	r12,1
80003712:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003716:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000371a:	2f fd       	sub	sp,-4
8000371c:	d8 02       	popm	pc
8000371e:	00 00       	add	r0,r0
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	71 24       	ld.w	r4,r8[0x48]

80003724 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003724:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003726:	48 5b       	lddpc	r11,80003738 <phy_init+0x14>
80003728:	48 5c       	lddpc	r12,8000373c <phy_init+0x18>
8000372a:	f0 1f 00 06 	mcall	80003740 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
8000372e:	f0 1f 00 06 	mcall	80003744 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80003732:	f0 1f 00 06 	mcall	80003748 <phy_init+0x24>
	
}
80003736:	d8 02       	popm	pc
80003738:	80 00       	ld.sh	r0,r0[0x0]
8000373a:	35 f4       	mov	r4,95
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	37 4c       	mov	r12,116
80003740:	80 00       	ld.sh	r0,r0[0x0]
80003742:	47 a0       	lddsp	r0,sp[0x1e8]
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	47 b4       	lddsp	r4,sp[0x1ec]
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	51 64       	stdsp	sp[0x58],r4

8000374c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000374c:	eb cd 40 e0 	pushm	r5-r7,lr
80003750:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003752:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80003756:	70 08       	ld.w	r8,r8[0x0]
80003758:	58 08       	cp.w	r8,0
8000375a:	e0 80 01 08 	breq	8000396a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000375e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003760:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003764:	70 09       	ld.w	r9,r8[0x0]
80003766:	2f f9       	sub	r9,-1
80003768:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000376a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
8000376e:	70 08       	ld.w	r8,r8[0x0]
80003770:	58 18       	cp.w	r8,1
80003772:	e0 80 00 85 	breq	8000387c <phy_rx_func+0x130>
80003776:	c0 73       	brcs	80003784 <phy_rx_func+0x38>
80003778:	58 28       	cp.w	r8,2
8000377a:	c5 c0       	breq	80003832 <phy_rx_func+0xe6>
8000377c:	58 38       	cp.w	r8,3
8000377e:	e0 81 00 f6 	brne	8000396a <phy_rx_func+0x21e>
80003782:	cd 58       	rjmp	8000392c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003784:	e0 6a 5a 5a 	mov	r10,23130
80003788:	ea 1a ab cd 	orh	r10,0xabcd
8000378c:	14 36       	cp.w	r6,r10
8000378e:	e0 80 00 ee 	breq	8000396a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003792:	ec 08 16 10 	lsr	r8,r6,0x10
80003796:	e0 48 ab cd 	cp.w	r8,43981
8000379a:	e0 81 00 e8 	brne	8000396a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000379e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800037a2:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800037a6:	20 28       	sub	r8,2
800037a8:	fe f9 0e 30 	ld.w	r9,pc[3632]
800037ac:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800037ae:	30 09       	mov	r9,0
800037b0:	f2 08 19 00 	cp.h	r8,r9
800037b4:	e0 8a 00 db 	brle	8000396a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
800037b8:	fe f8 0e 24 	ld.w	r8,pc[3620]
800037bc:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800037be:	fe f8 0e 22 	ld.w	r8,pc[3618]
800037c2:	70 0c       	ld.w	r12,r8[0x0]
800037c4:	f0 1f 03 88 	mcall	800045e4 <phy_rx_func+0xe98>
800037c8:	fe f8 0e 20 	ld.w	r8,pc[3616]
800037cc:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800037ce:	58 0c       	cp.w	r12,0
800037d0:	e0 80 00 cd 	breq	8000396a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800037d4:	fe f8 0e 08 	ld.w	r8,pc[3592]
800037d8:	90 09       	ld.sh	r9,r8[0x0]
800037da:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800037de:	2f f9       	sub	r9,-1
800037e0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037e2:	fe fa 0e 06 	ld.w	r10,pc[3590]
800037e6:	74 0a       	ld.w	r10,r10[0x0]
800037e8:	fe fb 0d e8 	ld.w	r11,pc[3560]
800037ec:	76 0b       	ld.w	r11,r11[0x0]
800037ee:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800037f2:	2f f9       	sub	r9,-1
800037f4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800037f6:	e2 16 0f 00 	andl	r6,0xf00,COH
800037fa:	e0 46 01 00 	cp.w	r6,256
800037fe:	c0 c0       	breq	80003816 <phy_rx_func+0xca>
80003800:	e0 8b 00 05 	brhi	8000380a <phy_rx_func+0xbe>
80003804:	58 06       	cp.w	r6,0
80003806:	c0 80       	breq	80003816 <phy_rx_func+0xca>
80003808:	c0 c8       	rjmp	80003820 <phy_rx_func+0xd4>
8000380a:	e0 46 02 00 	cp.w	r6,512
8000380e:	c0 40       	breq	80003816 <phy_rx_func+0xca>
80003810:	e0 46 03 00 	cp.w	r6,768
80003814:	c0 61       	brne	80003820 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003816:	30 29       	mov	r9,2
80003818:	fe f8 0d bc 	ld.w	r8,pc[3516]
8000381c:	91 09       	st.w	r8[0x0],r9
8000381e:	ca 68       	rjmp	8000396a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003820:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003824:	70 0c       	ld.w	r12,r8[0x0]
80003826:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000382a:	70 0b       	ld.w	r11,r8[0x0]
8000382c:	f0 1f 03 70 	mcall	800045ec <phy_rx_func+0xea0>
80003830:	c9 d8       	rjmp	8000396a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003832:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003836:	b1 86       	lsr	r6,0x10
80003838:	14 06       	add	r6,r10
8000383a:	fe f8 0d b6 	ld.w	r8,pc[3510]
8000383e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003840:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003844:	90 09       	ld.sh	r9,r8[0x0]
80003846:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000384a:	76 0b       	ld.w	r11,r11[0x0]
8000384c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003850:	2f f9       	sub	r9,-1
80003852:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003854:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003858:	92 08       	ld.sh	r8,r9[0x0]
8000385a:	20 28       	sub	r8,2
8000385c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000385e:	30 09       	mov	r9,0
80003860:	f2 08 19 00 	cp.h	r8,r9
80003864:	e0 8a 00 07 	brle	80003872 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003868:	30 19       	mov	r9,1
8000386a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
8000386e:	91 09       	st.w	r8[0x0],r9
80003870:	c7 d8       	rjmp	8000396a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003872:	30 39       	mov	r9,3
80003874:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003878:	91 09       	st.w	r8[0x0],r9
8000387a:	c7 88       	rjmp	8000396a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000387c:	ec 0a 14 10 	asr	r10,r6,0x10
80003880:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003884:	90 09       	ld.sh	r9,r8[0x0]
80003886:	14 09       	add	r9,r10
80003888:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000388a:	fe f9 0d 52 	ld.w	r9,pc[3410]
8000388e:	92 08       	ld.sh	r8,r9[0x0]
80003890:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003894:	76 0b       	ld.w	r11,r11[0x0]
80003896:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000389a:	2f f8       	sub	r8,-1
8000389c:	5c 88       	casts.h	r8
8000389e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800038a0:	fe fa 0d 38 	ld.w	r10,pc[3384]
800038a4:	94 09       	ld.sh	r9,r10[0x0]
800038a6:	20 29       	sub	r9,2
800038a8:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800038aa:	30 0a       	mov	r10,0
800038ac:	f4 09 19 00 	cp.h	r9,r10
800038b0:	e0 89 00 20 	brgt	800038f0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800038b4:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800038b8:	e0 46 00 ba 	cp.w	r6,186
800038bc:	c0 d1       	brne	800038d6 <phy_rx_func+0x18a>
800038be:	fe f8 0d 32 	ld.w	r8,pc[3378]
800038c2:	90 09       	ld.sh	r9,r8[0x0]
800038c4:	f4 09 19 00 	cp.h	r9,r10
800038c8:	c0 71       	brne	800038d6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800038ca:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800038ce:	70 0c       	ld.w	r12,r8[0x0]
800038d0:	f0 1f 03 49 	mcall	800045f4 <phy_rx_func+0xea8>
800038d4:	c0 98       	rjmp	800038e6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800038d6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800038da:	70 0c       	ld.w	r12,r8[0x0]
800038dc:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800038e0:	70 0b       	ld.w	r11,r8[0x0]
800038e2:	f0 1f 03 43 	mcall	800045ec <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800038e6:	30 09       	mov	r9,0
800038e8:	fe f8 0c ec 	ld.w	r8,pc[3308]
800038ec:	91 09       	st.w	r8[0x0],r9
800038ee:	c3 e8       	rjmp	8000396a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800038f0:	5c 86       	casts.h	r6
800038f2:	fe f9 0c fe 	ld.w	r9,pc[3326]
800038f6:	92 0a       	ld.sh	r10,r9[0x0]
800038f8:	0c 0a       	add	r10,r6
800038fa:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800038fc:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003900:	72 09       	ld.w	r9,r9[0x0]
80003902:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003906:	2f f8       	sub	r8,-1
80003908:	fe f9 0c d4 	ld.w	r9,pc[3284]
8000390c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000390e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003912:	92 08       	ld.sh	r8,r9[0x0]
80003914:	20 28       	sub	r8,2
80003916:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003918:	30 09       	mov	r9,0
8000391a:	f2 08 19 00 	cp.h	r8,r9
8000391e:	e0 89 00 26 	brgt	8000396a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003922:	30 39       	mov	r9,3
80003924:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003928:	91 09       	st.w	r8[0x0],r9
8000392a:	c2 08       	rjmp	8000396a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000392c:	e6 16 00 ff 	andh	r6,0xff,COH
80003930:	fc 19 00 ba 	movh	r9,0xba
80003934:	12 36       	cp.w	r6,r9
80003936:	c0 e1       	brne	80003952 <phy_rx_func+0x206>
80003938:	fe f8 0c b8 	ld.w	r8,pc[3256]
8000393c:	90 09       	ld.sh	r9,r8[0x0]
8000393e:	30 08       	mov	r8,0
80003940:	f0 09 19 00 	cp.h	r9,r8
80003944:	c0 71       	brne	80003952 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003946:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000394a:	70 0c       	ld.w	r12,r8[0x0]
8000394c:	f0 1f 03 2a 	mcall	800045f4 <phy_rx_func+0xea8>
80003950:	c0 98       	rjmp	80003962 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003952:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003956:	70 0c       	ld.w	r12,r8[0x0]
80003958:	fe f8 0c 90 	ld.w	r8,pc[3216]
8000395c:	70 0b       	ld.w	r11,r8[0x0]
8000395e:	f0 1f 03 24 	mcall	800045ec <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003962:	30 09       	mov	r9,0
80003964:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003968:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000396a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000396e:	11 89       	ld.ub	r9,r8[0x0]
80003970:	30 08       	mov	r8,0
80003972:	f0 09 18 00 	cp.b	r9,r8
80003976:	c1 31       	brne	8000399c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003978:	fe f6 0c 84 	ld.w	r6,pc[3204]
8000397c:	6c 0c       	ld.w	r12,r6[0x0]
8000397e:	f0 1f 03 1a 	mcall	800045e4 <phy_rx_func+0xe98>
80003982:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003986:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003988:	6c 0c       	ld.w	r12,r6[0x0]
8000398a:	f0 1f 03 17 	mcall	800045e4 <phy_rx_func+0xe98>
8000398e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003992:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003994:	30 19       	mov	r9,1
80003996:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000399a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000399c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800039a0:	70 08       	ld.w	r8,r8[0x0]
800039a2:	58 28       	cp.w	r8,2
800039a4:	e0 80 01 98 	breq	80003cd4 <phy_rx_func+0x588>
800039a8:	e0 8b 00 06 	brhi	800039b4 <phy_rx_func+0x268>
800039ac:	58 08       	cp.w	r8,0
800039ae:	c0 b0       	breq	800039c4 <phy_rx_func+0x278>
800039b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800039b4:	58 38       	cp.w	r8,3
800039b6:	e0 80 05 c5 	breq	80004540 <phy_rx_func+0xdf4>
800039ba:	58 48       	cp.w	r8,4
800039bc:	e0 81 06 05 	brne	800045c6 <phy_rx_func+0xe7a>
800039c0:	e0 8f 02 4b 	bral	80003e56 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800039c4:	6e 28       	ld.w	r8,r7[0x8]
800039c6:	e0 6a 5a 5a 	mov	r10,23130
800039ca:	ea 1a ab cd 	orh	r10,0xabcd
800039ce:	14 38       	cp.w	r8,r10
800039d0:	c0 71       	brne	800039de <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800039d2:	30 09       	mov	r9,0
800039d4:	fe f8 0c 38 	ld.w	r8,pc[3128]
800039d8:	91 09       	st.w	r8[0x0],r9
800039da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800039de:	10 99       	mov	r9,r8
800039e0:	e0 19 00 00 	andl	r9,0x0
800039e4:	fc 1a ab cd 	movh	r10,0xabcd
800039e8:	14 39       	cp.w	r9,r10
800039ea:	e0 81 05 ee 	brne	800045c6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800039ee:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800039f2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800039f6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800039f8:	6e 29       	ld.w	r9,r7[0x8]
800039fa:	e2 19 f0 00 	andl	r9,0xf000,COH
800039fe:	e0 49 c0 00 	cp.w	r9,49152
80003a02:	e0 81 00 ce 	brne	80003b9e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003a06:	30 1a       	mov	r10,1
80003a08:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003a0c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003a0e:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003a12:	72 09       	ld.w	r9,r9[0x0]
80003a14:	58 09       	cp.w	r9,0
80003a16:	c0 71       	brne	80003a24 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a18:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003a1c:	f0 1f 03 00 	mcall	8000461c <phy_rx_func+0xed0>
80003a20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003a24:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003a28:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003a2c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003a2e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a32:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003a36:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003a3a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003a3c:	13 89       	ld.ub	r9,r9[0x0]
80003a3e:	37 fa       	mov	r10,127
80003a40:	f4 09 18 00 	cp.b	r9,r10
80003a44:	c6 d0       	breq	80003b1e <phy_rx_func+0x3d2>
80003a46:	e0 8b 00 0c 	brhi	80003a5e <phy_rx_func+0x312>
80003a4a:	31 2a       	mov	r10,18
80003a4c:	f4 09 18 00 	cp.b	r9,r10
80003a50:	c4 20       	breq	80003ad4 <phy_rx_func+0x388>
80003a52:	31 3a       	mov	r10,19
80003a54:	f4 09 18 00 	cp.b	r9,r10
80003a58:	e0 81 00 83 	brne	80003b5e <phy_rx_func+0x412>
80003a5c:	c5 b8       	rjmp	80003b12 <phy_rx_func+0x3c6>
80003a5e:	2f 09       	sub	r9,-16
80003a60:	30 1a       	mov	r10,1
80003a62:	f4 09 18 00 	cp.b	r9,r10
80003a66:	e0 8b 00 7c 	brhi	80003b5e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003a6a:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003a6e:	e2 18 00 f0 	andl	r8,0xf0,COH
80003a72:	59 08       	cp.w	r8,16
80003a74:	c0 71       	brne	80003a82 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003a76:	30 19       	mov	r9,1
80003a78:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003a7c:	91 09       	st.w	r8[0x0],r9
80003a7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003a82:	e0 48 00 20 	cp.w	r8,32
80003a86:	c2 11       	brne	80003ac8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003a88:	30 a9       	mov	r9,10
80003a8a:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003a8e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003a90:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003a94:	6c 08       	ld.w	r8,r6[0x0]
80003a96:	f0 0a 11 ff 	rsub	r10,r8,-1
80003a9a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003a9e:	2f f8       	sub	r8,-1
80003aa0:	6e 0c       	ld.w	r12,r7[0x0]
80003aa2:	f4 ca fe 00 	sub	r10,r10,-512
80003aa6:	30 0b       	mov	r11,0
80003aa8:	10 0c       	add	r12,r8
80003aaa:	f0 1f 02 e1 	mcall	8000462c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003aae:	30 08       	mov	r8,0
80003ab0:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003ab2:	6e 0c       	ld.w	r12,r7[0x0]
80003ab4:	f0 1f 02 df 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ab8:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003abc:	70 0c       	ld.w	r12,r8[0x0]
80003abe:	f0 1f 02 ca 	mcall	800045e4 <phy_rx_func+0xe98>
80003ac2:	8f 0c       	st.w	r7[0x0],r12
80003ac4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003ac8:	30 09       	mov	r9,0
80003aca:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003ace:	91 09       	st.w	r8[0x0],r9
80003ad0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003ad4:	20 48       	sub	r8,4
80003ad6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003ada:	93 08       	st.w	r9[0x0],r8
80003adc:	58 08       	cp.w	r8,0
80003ade:	e0 80 05 74 	breq	800045c6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003ae2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003ae6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003aea:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003aee:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003af0:	8e 69       	ld.sh	r9,r7[0xc]
80003af2:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003af6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003af8:	8e 79       	ld.sh	r9,r7[0xe]
80003afa:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003afc:	f0 1f 02 d0 	mcall	8000463c <phy_rx_func+0xef0>
80003b00:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003b04:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b06:	30 49       	mov	r9,4
80003b08:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003b0c:	91 09       	st.w	r8[0x0],r9
80003b0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003b12:	30 09       	mov	r9,0
80003b14:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003b18:	91 09       	st.w	r8[0x0],r9
80003b1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b1e:	20 48       	sub	r8,4
80003b20:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003b24:	93 08       	st.w	r9[0x0],r8
80003b26:	58 08       	cp.w	r8,0
80003b28:	e0 80 05 4f 	breq	800045c6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003b2c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003b30:	70 09       	ld.w	r9,r8[0x0]
80003b32:	8e 7b       	ld.sh	r11,r7[0xe]
80003b34:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003b38:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003b3c:	2f f9       	sub	r9,-1
80003b3e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003b40:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003b44:	70 09       	ld.w	r9,r8[0x0]
80003b46:	20 29       	sub	r9,2
80003b48:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003b4a:	30 29       	mov	r9,2
80003b4c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003b50:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003b52:	30 39       	mov	r9,3
80003b54:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003b58:	91 09       	st.w	r8[0x0],r9
80003b5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003b5e:	30 3a       	mov	r10,3
80003b60:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003b64:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003b66:	6e 2a       	ld.w	r10,r7[0x8]
80003b68:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003b6c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003b6e:	6e 3a       	ld.w	r10,r7[0xc]
80003b70:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003b72:	59 48       	cp.w	r8,20
80003b74:	c0 61       	brne	80003b80 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003b76:	31 89       	mov	r9,24
80003b78:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003b7c:	91 09       	st.w	r8[0x0],r9
80003b7e:	c0 a8       	rjmp	80003b92 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003b80:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003b84:	70 08       	ld.w	r8,r8[0x0]
80003b86:	59 08       	cp.w	r8,16
80003b88:	c0 51       	brne	80003b92 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003b8a:	31 09       	mov	r9,16
80003b8c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003b90:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b92:	30 49       	mov	r9,4
80003b94:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003b98:	91 09       	st.w	r8[0x0],r9
80003b9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003b9e:	e0 49 10 00 	cp.w	r9,4096
80003ba2:	5f 1a       	srne	r10
80003ba4:	e0 49 20 00 	cp.w	r9,8192
80003ba8:	5f 19       	srne	r9
80003baa:	f5 e9 00 09 	and	r9,r10,r9
80003bae:	e0 81 05 0c 	brne	800045c6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003bb2:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003bb6:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003bb8:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003bbc:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003bbe:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003bc2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003bc4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003bc8:	72 09       	ld.w	r9,r9[0x0]
80003bca:	58 09       	cp.w	r9,0
80003bcc:	c0 71       	brne	80003bda <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003bce:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003bd2:	f0 1f 02 93 	mcall	8000461c <phy_rx_func+0xed0>
80003bd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bda:	6e 2a       	ld.w	r10,r7[0x8]
80003bdc:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003be0:	58 1a       	cp.w	r10,1
80003be2:	e0 8b 00 4d 	brhi	80003c7c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003be6:	20 48       	sub	r8,4
80003be8:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003bec:	93 08       	st.w	r9[0x0],r8
80003bee:	58 08       	cp.w	r8,0
80003bf0:	e0 80 04 eb 	breq	800045c6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003bf4:	8e 68       	ld.sh	r8,r7[0xc]
80003bf6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003bfa:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003bfe:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003c00:	30 09       	mov	r9,0
80003c02:	f2 08 19 00 	cp.h	r8,r9
80003c06:	c0 70       	breq	80003c14 <phy_rx_func+0x4c8>
80003c08:	30 19       	mov	r9,1
80003c0a:	f2 08 19 00 	cp.h	r8,r9
80003c0e:	e0 81 04 dc 	brne	800045c6 <phy_rx_func+0xe7a>
80003c12:	c2 68       	rjmp	80003c5e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c14:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003c18:	70 0a       	ld.w	r10,r8[0x0]
80003c1a:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003c1e:	72 09       	ld.w	r9,r9[0x0]
80003c20:	8e 7b       	ld.sh	r11,r7[0xe]
80003c22:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003c26:	70 09       	ld.w	r9,r8[0x0]
80003c28:	2f f9       	sub	r9,-1
80003c2a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c2c:	e0 49 00 ff 	cp.w	r9,255
80003c30:	e0 88 00 11 	brls	80003c52 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003c34:	30 09       	mov	r9,0
80003c36:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003c38:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003c3c:	6e 0c       	ld.w	r12,r7[0x0]
80003c3e:	f0 1f 02 7d 	mcall	80004630 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003c42:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003c46:	70 0c       	ld.w	r12,r8[0x0]
80003c48:	f0 1f 02 67 	mcall	800045e4 <phy_rx_func+0xe98>
80003c4c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003c4e:	e0 80 04 bc 	breq	800045c6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003c52:	30 29       	mov	r9,2
80003c54:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003c58:	91 09       	st.w	r8[0x0],r9
80003c5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c5e:	8e 79       	ld.sh	r9,r7[0xe]
80003c60:	30 38       	mov	r8,3
80003c62:	f0 09 19 00 	cp.h	r9,r8
80003c66:	c0 51       	brne	80003c70 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003c68:	30 19       	mov	r9,1
80003c6a:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003c6e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003c70:	30 29       	mov	r9,2
80003c72:	fe f8 09 96 	ld.w	r8,pc[2454]
80003c76:	91 09       	st.w	r8[0x0],r9
80003c78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003c7c:	58 18       	cp.w	r8,1
80003c7e:	e0 88 04 a4 	brls	800045c6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003c82:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003c86:	70 0a       	ld.w	r10,r8[0x0]
80003c88:	6e 3b       	ld.w	r11,r7[0xc]
80003c8a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c8e:	70 09       	ld.w	r9,r8[0x0]
80003c90:	2f f9       	sub	r9,-1
80003c92:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c94:	e0 49 00 ff 	cp.w	r9,255
80003c98:	e0 88 00 11 	brls	80003cba <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003c9c:	30 09       	mov	r9,0
80003c9e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003ca0:	fe f7 09 60 	ld.w	r7,pc[2400]
80003ca4:	6e 0c       	ld.w	r12,r7[0x0]
80003ca6:	f0 1f 02 63 	mcall	80004630 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003caa:	fe f8 09 52 	ld.w	r8,pc[2386]
80003cae:	70 0c       	ld.w	r12,r8[0x0]
80003cb0:	f0 1f 02 4d 	mcall	800045e4 <phy_rx_func+0xe98>
80003cb4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003cb6:	e0 80 04 88 	breq	800045c6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003cba:	fe f9 09 56 	ld.w	r9,pc[2390]
80003cbe:	72 08       	ld.w	r8,r9[0x0]
80003cc0:	20 28       	sub	r8,2
80003cc2:	93 08       	st.w	r9[0x0],r8
80003cc4:	e0 80 04 81 	breq	800045c6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003cc8:	30 29       	mov	r9,2
80003cca:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003cce:	91 09       	st.w	r8[0x0],r9
80003cd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003cd4:	fe f8 09 84 	ld.w	r8,pc[2436]
80003cd8:	70 0a       	ld.w	r10,r8[0x0]
80003cda:	fe f9 09 26 	ld.w	r9,pc[2342]
80003cde:	72 09       	ld.w	r9,r9[0x0]
80003ce0:	8e 4b       	ld.sh	r11,r7[0x8]
80003ce2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003ce6:	70 09       	ld.w	r9,r8[0x0]
80003ce8:	2f f9       	sub	r9,-1
80003cea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003cec:	e0 49 00 ff 	cp.w	r9,255
80003cf0:	e0 88 00 16 	brls	80003d1c <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003cf4:	30 09       	mov	r9,0
80003cf6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cf8:	fe f6 09 08 	ld.w	r6,pc[2312]
80003cfc:	6c 0c       	ld.w	r12,r6[0x0]
80003cfe:	f0 1f 02 4d 	mcall	80004630 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d02:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003d06:	70 0c       	ld.w	r12,r8[0x0]
80003d08:	f0 1f 02 37 	mcall	800045e4 <phy_rx_func+0xe98>
80003d0c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d0e:	c0 71       	brne	80003d1c <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003d10:	30 09       	mov	r9,0
80003d12:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003d16:	91 09       	st.w	r8[0x0],r9
80003d18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003d1c:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003d20:	72 08       	ld.w	r8,r9[0x0]
80003d22:	20 28       	sub	r8,2
80003d24:	93 08       	st.w	r9[0x0],r8
80003d26:	c0 71       	brne	80003d34 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003d28:	30 09       	mov	r9,0
80003d2a:	fe f8 08 de 	ld.w	r8,pc[2270]
80003d2e:	91 09       	st.w	r8[0x0],r9
80003d30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003d34:	fe f8 09 24 	ld.w	r8,pc[2340]
80003d38:	70 0a       	ld.w	r10,r8[0x0]
80003d3a:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003d3e:	72 09       	ld.w	r9,r9[0x0]
80003d40:	8e 5b       	ld.sh	r11,r7[0xa]
80003d42:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d46:	70 09       	ld.w	r9,r8[0x0]
80003d48:	2f f9       	sub	r9,-1
80003d4a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d4c:	e0 49 00 ff 	cp.w	r9,255
80003d50:	e0 88 00 16 	brls	80003d7c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003d54:	30 09       	mov	r9,0
80003d56:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d58:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003d5c:	6c 0c       	ld.w	r12,r6[0x0]
80003d5e:	f0 1f 02 35 	mcall	80004630 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d62:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003d66:	70 0c       	ld.w	r12,r8[0x0]
80003d68:	f0 1f 02 1f 	mcall	800045e4 <phy_rx_func+0xe98>
80003d6c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d6e:	c0 71       	brne	80003d7c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003d70:	30 09       	mov	r9,0
80003d72:	fe f8 08 96 	ld.w	r8,pc[2198]
80003d76:	91 09       	st.w	r8[0x0],r9
80003d78:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003d7c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003d80:	72 08       	ld.w	r8,r9[0x0]
80003d82:	20 28       	sub	r8,2
80003d84:	93 08       	st.w	r9[0x0],r8
80003d86:	c0 71       	brne	80003d94 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003d88:	30 09       	mov	r9,0
80003d8a:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003d8e:	91 09       	st.w	r8[0x0],r9
80003d90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003d94:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003d98:	70 0a       	ld.w	r10,r8[0x0]
80003d9a:	fe f9 08 66 	ld.w	r9,pc[2150]
80003d9e:	72 09       	ld.w	r9,r9[0x0]
80003da0:	8e 6b       	ld.sh	r11,r7[0xc]
80003da2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003da6:	70 09       	ld.w	r9,r8[0x0]
80003da8:	2f f9       	sub	r9,-1
80003daa:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003dac:	e0 49 00 ff 	cp.w	r9,255
80003db0:	e0 88 00 16 	brls	80003ddc <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003db4:	30 09       	mov	r9,0
80003db6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003db8:	fe f6 08 48 	ld.w	r6,pc[2120]
80003dbc:	6c 0c       	ld.w	r12,r6[0x0]
80003dbe:	f0 1f 02 1d 	mcall	80004630 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003dc2:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003dc6:	70 0c       	ld.w	r12,r8[0x0]
80003dc8:	f0 1f 02 07 	mcall	800045e4 <phy_rx_func+0xe98>
80003dcc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003dce:	c0 71       	brne	80003ddc <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003dd0:	30 09       	mov	r9,0
80003dd2:	fe f8 08 36 	ld.w	r8,pc[2102]
80003dd6:	91 09       	st.w	r8[0x0],r9
80003dd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003ddc:	fe f9 08 34 	ld.w	r9,pc[2100]
80003de0:	72 08       	ld.w	r8,r9[0x0]
80003de2:	20 28       	sub	r8,2
80003de4:	93 08       	st.w	r9[0x0],r8
80003de6:	c0 71       	brne	80003df4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003de8:	30 09       	mov	r9,0
80003dea:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003dee:	91 09       	st.w	r8[0x0],r9
80003df0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003df4:	fe f8 08 64 	ld.w	r8,pc[2148]
80003df8:	70 0a       	ld.w	r10,r8[0x0]
80003dfa:	fe f9 08 06 	ld.w	r9,pc[2054]
80003dfe:	72 09       	ld.w	r9,r9[0x0]
80003e00:	8e 7b       	ld.sh	r11,r7[0xe]
80003e02:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003e06:	70 09       	ld.w	r9,r8[0x0]
80003e08:	2f f9       	sub	r9,-1
80003e0a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e0c:	e0 49 00 ff 	cp.w	r9,255
80003e10:	e0 88 00 16 	brls	80003e3c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003e14:	30 09       	mov	r9,0
80003e16:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e18:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003e1c:	6e 0c       	ld.w	r12,r7[0x0]
80003e1e:	f0 1f 02 05 	mcall	80004630 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e22:	fe f8 07 da 	ld.w	r8,pc[2010]
80003e26:	70 0c       	ld.w	r12,r8[0x0]
80003e28:	f0 1f 01 ef 	mcall	800045e4 <phy_rx_func+0xe98>
80003e2c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003e2e:	c0 71       	brne	80003e3c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003e30:	30 09       	mov	r9,0
80003e32:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003e36:	91 09       	st.w	r8[0x0],r9
80003e38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e3c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003e40:	72 08       	ld.w	r8,r9[0x0]
80003e42:	20 28       	sub	r8,2
80003e44:	93 08       	st.w	r9[0x0],r8
80003e46:	e0 81 03 c0 	brne	800045c6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003e4a:	30 09       	mov	r9,0
80003e4c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003e50:	91 09       	st.w	r8[0x0],r9
80003e52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003e56:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003e5a:	11 89       	ld.ub	r9,r8[0x0]
80003e5c:	31 28       	mov	r8,18
80003e5e:	f0 09 18 00 	cp.b	r9,r8
80003e62:	e0 81 01 4c 	brne	800040fa <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003e66:	ef 39 00 09 	ld.ub	r9,r7[9]
80003e6a:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003e6e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003e70:	11 89       	ld.ub	r9,r8[0x0]
80003e72:	3f 28       	mov	r8,-14
80003e74:	f0 09 18 00 	cp.b	r9,r8
80003e78:	e0 81 01 3b 	brne	800040ee <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003e7c:	30 19       	mov	r9,1
80003e7e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e82:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003e84:	6e 29       	ld.w	r9,r7[0x8]
80003e86:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003e8a:	fe f8 07 86 	ld.w	r8,pc[1926]
80003e8e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003e90:	8e 59       	ld.sh	r9,r7[0xa]
80003e92:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e96:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003e98:	8e 69       	ld.sh	r9,r7[0xc]
80003e9a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003e9c:	8e 79       	ld.sh	r9,r7[0xe]
80003e9e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003ea0:	fe f8 07 88 	ld.w	r8,pc[1928]
80003ea4:	fe f9 07 60 	ld.w	r9,pc[1888]
80003ea8:	72 0a       	ld.w	r10,r9[0x0]
80003eaa:	70 09       	ld.w	r9,r8[0x0]
80003eac:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003eb0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003eb4:	70 09       	ld.w	r9,r8[0x0]
80003eb6:	2f f9       	sub	r9,-1
80003eb8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eba:	e0 49 01 ff 	cp.w	r9,511
80003ebe:	e0 88 00 16 	brls	80003eea <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ec2:	30 09       	mov	r9,0
80003ec4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ec6:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003eca:	6c 0c       	ld.w	r12,r6[0x0]
80003ecc:	f0 1f 01 d9 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ed0:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003ed4:	70 0c       	ld.w	r12,r8[0x0]
80003ed6:	f0 1f 01 c4 	mcall	800045e4 <phy_rx_func+0xe98>
80003eda:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003edc:	c0 71       	brne	80003eea <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003ede:	30 09       	mov	r9,0
80003ee0:	fe f8 07 28 	ld.w	r8,pc[1832]
80003ee4:	91 09       	st.w	r8[0x0],r9
80003ee6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003eea:	fe f9 07 26 	ld.w	r9,pc[1830]
80003eee:	72 08       	ld.w	r8,r9[0x0]
80003ef0:	20 18       	sub	r8,1
80003ef2:	93 08       	st.w	r9[0x0],r8
80003ef4:	c0 71       	brne	80003f02 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003ef6:	30 09       	mov	r9,0
80003ef8:	fe f8 07 10 	ld.w	r8,pc[1808]
80003efc:	91 09       	st.w	r8[0x0],r9
80003efe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003f02:	fe f8 07 26 	ld.w	r8,pc[1830]
80003f06:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003f0a:	72 0a       	ld.w	r10,r9[0x0]
80003f0c:	70 09       	ld.w	r9,r8[0x0]
80003f0e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f12:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f16:	70 09       	ld.w	r9,r8[0x0]
80003f18:	2f f9       	sub	r9,-1
80003f1a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f1c:	e0 49 01 ff 	cp.w	r9,511
80003f20:	e0 88 00 16 	brls	80003f4c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f24:	30 09       	mov	r9,0
80003f26:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f28:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003f2c:	6c 0c       	ld.w	r12,r6[0x0]
80003f2e:	f0 1f 01 c1 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f32:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003f36:	70 0c       	ld.w	r12,r8[0x0]
80003f38:	f0 1f 01 ab 	mcall	800045e4 <phy_rx_func+0xe98>
80003f3c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f3e:	c0 71       	brne	80003f4c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003f40:	30 09       	mov	r9,0
80003f42:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003f46:	91 09       	st.w	r8[0x0],r9
80003f48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f4c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003f50:	72 08       	ld.w	r8,r9[0x0]
80003f52:	20 18       	sub	r8,1
80003f54:	93 08       	st.w	r9[0x0],r8
80003f56:	c0 71       	brne	80003f64 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003f58:	30 09       	mov	r9,0
80003f5a:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003f5e:	91 09       	st.w	r8[0x0],r9
80003f60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003f64:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003f68:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003f6c:	72 0a       	ld.w	r10,r9[0x0]
80003f6e:	70 09       	ld.w	r9,r8[0x0]
80003f70:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f74:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f78:	70 09       	ld.w	r9,r8[0x0]
80003f7a:	2f f9       	sub	r9,-1
80003f7c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f7e:	e0 49 01 ff 	cp.w	r9,511
80003f82:	e0 88 00 16 	brls	80003fae <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f86:	30 09       	mov	r9,0
80003f88:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f8a:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003f8e:	6c 0c       	ld.w	r12,r6[0x0]
80003f90:	f0 1f 01 a8 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f94:	fe f8 06 68 	ld.w	r8,pc[1640]
80003f98:	70 0c       	ld.w	r12,r8[0x0]
80003f9a:	f0 1f 01 93 	mcall	800045e4 <phy_rx_func+0xe98>
80003f9e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003fa0:	c0 71       	brne	80003fae <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003fa2:	30 09       	mov	r9,0
80003fa4:	fe f8 06 64 	ld.w	r8,pc[1636]
80003fa8:	91 09       	st.w	r8[0x0],r9
80003faa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003fae:	fe f9 06 62 	ld.w	r9,pc[1634]
80003fb2:	72 08       	ld.w	r8,r9[0x0]
80003fb4:	20 18       	sub	r8,1
80003fb6:	93 08       	st.w	r9[0x0],r8
80003fb8:	c0 71       	brne	80003fc6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003fba:	30 09       	mov	r9,0
80003fbc:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003fc0:	91 09       	st.w	r8[0x0],r9
80003fc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003fc6:	fe f8 06 62 	ld.w	r8,pc[1634]
80003fca:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003fce:	72 0a       	ld.w	r10,r9[0x0]
80003fd0:	70 09       	ld.w	r9,r8[0x0]
80003fd2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003fd6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fda:	70 09       	ld.w	r9,r8[0x0]
80003fdc:	2f f9       	sub	r9,-1
80003fde:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fe0:	e0 49 01 ff 	cp.w	r9,511
80003fe4:	e0 88 00 16 	brls	80004010 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003fe8:	30 09       	mov	r9,0
80003fea:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003fec:	fe f6 06 18 	ld.w	r6,pc[1560]
80003ff0:	6c 0c       	ld.w	r12,r6[0x0]
80003ff2:	f0 1f 01 90 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ff6:	fe f8 06 06 	ld.w	r8,pc[1542]
80003ffa:	70 0c       	ld.w	r12,r8[0x0]
80003ffc:	f0 1f 01 7a 	mcall	800045e4 <phy_rx_func+0xe98>
80004000:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004002:	c0 71       	brne	80004010 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80004004:	30 09       	mov	r9,0
80004006:	fe f8 06 02 	ld.w	r8,pc[1538]
8000400a:	91 09       	st.w	r8[0x0],r9
8000400c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004010:	fe f9 06 00 	ld.w	r9,pc[1536]
80004014:	72 08       	ld.w	r8,r9[0x0]
80004016:	20 18       	sub	r8,1
80004018:	93 08       	st.w	r9[0x0],r8
8000401a:	c0 71       	brne	80004028 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
8000401c:	30 09       	mov	r9,0
8000401e:	fe f8 05 ea 	ld.w	r8,pc[1514]
80004022:	91 09       	st.w	r8[0x0],r9
80004024:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004028:	fe f8 06 00 	ld.w	r8,pc[1536]
8000402c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80004030:	72 0a       	ld.w	r10,r9[0x0]
80004032:	70 09       	ld.w	r9,r8[0x0]
80004034:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004038:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000403c:	70 09       	ld.w	r9,r8[0x0]
8000403e:	2f f9       	sub	r9,-1
80004040:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004042:	e0 49 01 ff 	cp.w	r9,511
80004046:	e0 88 00 16 	brls	80004072 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000404a:	30 09       	mov	r9,0
8000404c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000404e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80004052:	6c 0c       	ld.w	r12,r6[0x0]
80004054:	f0 1f 01 77 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004058:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000405c:	70 0c       	ld.w	r12,r8[0x0]
8000405e:	f0 1f 01 62 	mcall	800045e4 <phy_rx_func+0xe98>
80004062:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004064:	c0 71       	brne	80004072 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80004066:	30 09       	mov	r9,0
80004068:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000406c:	91 09       	st.w	r8[0x0],r9
8000406e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004072:	fe f9 05 9e 	ld.w	r9,pc[1438]
80004076:	72 08       	ld.w	r8,r9[0x0]
80004078:	20 18       	sub	r8,1
8000407a:	93 08       	st.w	r9[0x0],r8
8000407c:	c0 71       	brne	8000408a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000407e:	30 09       	mov	r9,0
80004080:	fe f8 05 88 	ld.w	r8,pc[1416]
80004084:	91 09       	st.w	r8[0x0],r9
80004086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000408a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000408e:	fe f9 05 76 	ld.w	r9,pc[1398]
80004092:	72 0a       	ld.w	r10,r9[0x0]
80004094:	70 09       	ld.w	r9,r8[0x0]
80004096:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000409a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000409e:	70 09       	ld.w	r9,r8[0x0]
800040a0:	2f f9       	sub	r9,-1
800040a2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040a4:	e0 49 01 ff 	cp.w	r9,511
800040a8:	e0 88 00 16 	brls	800040d4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800040ac:	30 09       	mov	r9,0
800040ae:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800040b0:	fe f7 05 54 	ld.w	r7,pc[1364]
800040b4:	6e 0c       	ld.w	r12,r7[0x0]
800040b6:	f0 1f 01 5f 	mcall	80004630 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800040ba:	fe f8 05 42 	ld.w	r8,pc[1346]
800040be:	70 0c       	ld.w	r12,r8[0x0]
800040c0:	f0 1f 01 49 	mcall	800045e4 <phy_rx_func+0xe98>
800040c4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800040c6:	c0 71       	brne	800040d4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800040c8:	30 09       	mov	r9,0
800040ca:	fe f8 05 3e 	ld.w	r8,pc[1342]
800040ce:	91 09       	st.w	r8[0x0],r9
800040d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800040d4:	fe f9 05 3c 	ld.w	r9,pc[1340]
800040d8:	72 08       	ld.w	r8,r9[0x0]
800040da:	20 18       	sub	r8,1
800040dc:	93 08       	st.w	r9[0x0],r8
800040de:	e0 81 02 74 	brne	800045c6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800040e2:	30 09       	mov	r9,0
800040e4:	fe f8 05 24 	ld.w	r8,pc[1316]
800040e8:	91 09       	st.w	r8[0x0],r9
800040ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800040ee:	30 09       	mov	r9,0
800040f0:	fe f8 05 18 	ld.w	r8,pc[1304]
800040f4:	91 09       	st.w	r8[0x0],r9
800040f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800040fa:	fe f8 05 26 	ld.w	r8,pc[1318]
800040fe:	11 89       	ld.ub	r9,r8[0x0]
80004100:	3f 28       	mov	r8,-14
80004102:	f0 09 18 00 	cp.b	r9,r8
80004106:	c4 31       	brne	8000418c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004108:	8e 49       	ld.sh	r9,r7[0x8]
8000410a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000410e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004110:	fe f8 05 18 	ld.w	r8,pc[1304]
80004114:	fe f9 04 f0 	ld.w	r9,pc[1264]
80004118:	72 0a       	ld.w	r10,r9[0x0]
8000411a:	70 09       	ld.w	r9,r8[0x0]
8000411c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004120:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004124:	70 09       	ld.w	r9,r8[0x0]
80004126:	2f f9       	sub	r9,-1
80004128:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000412a:	e0 49 01 ff 	cp.w	r9,511
8000412e:	e0 88 00 16 	brls	8000415a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004132:	30 09       	mov	r9,0
80004134:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004136:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000413a:	6e 0c       	ld.w	r12,r7[0x0]
8000413c:	f0 1f 01 3d 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004140:	fe f8 04 bc 	ld.w	r8,pc[1212]
80004144:	70 0c       	ld.w	r12,r8[0x0]
80004146:	f0 1f 01 28 	mcall	800045e4 <phy_rx_func+0xe98>
8000414a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000414c:	c0 71       	brne	8000415a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000414e:	30 09       	mov	r9,0
80004150:	fe f8 04 b8 	ld.w	r8,pc[1208]
80004154:	91 09       	st.w	r8[0x0],r9
80004156:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000415a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000415e:	72 08       	ld.w	r8,r9[0x0]
80004160:	20 18       	sub	r8,1
80004162:	93 08       	st.w	r9[0x0],r8
80004164:	c0 71       	brne	80004172 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80004166:	30 09       	mov	r9,0
80004168:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000416c:	91 09       	st.w	r8[0x0],r9
8000416e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80004172:	20 18       	sub	r8,1
80004174:	fe f9 04 9c 	ld.w	r9,pc[1180]
80004178:	93 08       	st.w	r9[0x0],r8
8000417a:	58 08       	cp.w	r8,0
8000417c:	e0 81 02 25 	brne	800045c6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80004180:	30 09       	mov	r9,0
80004182:	fe f8 04 86 	ld.w	r8,pc[1158]
80004186:	91 09       	st.w	r8[0x0],r9
80004188:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000418c:	fe f8 04 94 	ld.w	r8,pc[1172]
80004190:	11 89       	ld.ub	r9,r8[0x0]
80004192:	3f 38       	mov	r8,-13
80004194:	f0 09 18 00 	cp.b	r9,r8
80004198:	e0 81 01 0c 	brne	800043b0 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000419c:	8e 49       	ld.sh	r9,r7[0x8]
8000419e:	fe f8 04 c2 	ld.w	r8,pc[1218]
800041a2:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800041a4:	8e 59       	ld.sh	r9,r7[0xa]
800041a6:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800041a8:	8e 69       	ld.sh	r9,r7[0xc]
800041aa:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800041ac:	fe f8 04 7c 	ld.w	r8,pc[1148]
800041b0:	fe f9 04 54 	ld.w	r9,pc[1108]
800041b4:	72 0a       	ld.w	r10,r9[0x0]
800041b6:	70 09       	ld.w	r9,r8[0x0]
800041b8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800041bc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041c0:	70 09       	ld.w	r9,r8[0x0]
800041c2:	2f f9       	sub	r9,-1
800041c4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041c6:	e0 49 01 ff 	cp.w	r9,511
800041ca:	e0 88 00 16 	brls	800041f6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800041ce:	30 09       	mov	r9,0
800041d0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041d2:	fe f6 04 32 	ld.w	r6,pc[1074]
800041d6:	6c 0c       	ld.w	r12,r6[0x0]
800041d8:	f0 1f 01 16 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041dc:	fe f8 04 20 	ld.w	r8,pc[1056]
800041e0:	70 0c       	ld.w	r12,r8[0x0]
800041e2:	f0 1f 01 01 	mcall	800045e4 <phy_rx_func+0xe98>
800041e6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041e8:	c0 71       	brne	800041f6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800041ea:	30 09       	mov	r9,0
800041ec:	fe f8 04 1c 	ld.w	r8,pc[1052]
800041f0:	91 09       	st.w	r8[0x0],r9
800041f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041f6:	fe f9 04 1a 	ld.w	r9,pc[1050]
800041fa:	72 08       	ld.w	r8,r9[0x0]
800041fc:	20 18       	sub	r8,1
800041fe:	93 08       	st.w	r9[0x0],r8
80004200:	c0 71       	brne	8000420e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80004202:	30 09       	mov	r9,0
80004204:	fe f8 04 04 	ld.w	r8,pc[1028]
80004208:	91 09       	st.w	r8[0x0],r9
8000420a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000420e:	fe f8 04 1a 	ld.w	r8,pc[1050]
80004212:	fe f9 03 f2 	ld.w	r9,pc[1010]
80004216:	72 0a       	ld.w	r10,r9[0x0]
80004218:	70 09       	ld.w	r9,r8[0x0]
8000421a:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000421e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004222:	70 09       	ld.w	r9,r8[0x0]
80004224:	2f f9       	sub	r9,-1
80004226:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004228:	e0 49 01 ff 	cp.w	r9,511
8000422c:	e0 88 00 16 	brls	80004258 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80004230:	30 09       	mov	r9,0
80004232:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004234:	fe f6 03 d0 	ld.w	r6,pc[976]
80004238:	6c 0c       	ld.w	r12,r6[0x0]
8000423a:	f0 1f 00 fe 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000423e:	fe f8 03 be 	ld.w	r8,pc[958]
80004242:	70 0c       	ld.w	r12,r8[0x0]
80004244:	f0 1f 00 e8 	mcall	800045e4 <phy_rx_func+0xe98>
80004248:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000424a:	c0 71       	brne	80004258 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000424c:	30 09       	mov	r9,0
8000424e:	fe f8 03 ba 	ld.w	r8,pc[954]
80004252:	91 09       	st.w	r8[0x0],r9
80004254:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004258:	fe f9 03 b8 	ld.w	r9,pc[952]
8000425c:	72 08       	ld.w	r8,r9[0x0]
8000425e:	20 18       	sub	r8,1
80004260:	93 08       	st.w	r9[0x0],r8
80004262:	c0 71       	brne	80004270 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80004264:	30 09       	mov	r9,0
80004266:	fe f8 03 a2 	ld.w	r8,pc[930]
8000426a:	91 09       	st.w	r8[0x0],r9
8000426c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80004270:	fe f8 03 b8 	ld.w	r8,pc[952]
80004274:	fe f9 03 90 	ld.w	r9,pc[912]
80004278:	72 0a       	ld.w	r10,r9[0x0]
8000427a:	70 09       	ld.w	r9,r8[0x0]
8000427c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004280:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004284:	70 09       	ld.w	r9,r8[0x0]
80004286:	2f f9       	sub	r9,-1
80004288:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000428a:	e0 49 01 ff 	cp.w	r9,511
8000428e:	e0 88 00 16 	brls	800042ba <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004292:	30 09       	mov	r9,0
80004294:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004296:	fe f6 03 6e 	ld.w	r6,pc[878]
8000429a:	6c 0c       	ld.w	r12,r6[0x0]
8000429c:	f0 1f 00 e5 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042a0:	fe f8 03 5c 	ld.w	r8,pc[860]
800042a4:	70 0c       	ld.w	r12,r8[0x0]
800042a6:	f0 1f 00 d0 	mcall	800045e4 <phy_rx_func+0xe98>
800042aa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042ac:	c0 71       	brne	800042ba <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800042ae:	30 09       	mov	r9,0
800042b0:	fe f8 03 58 	ld.w	r8,pc[856]
800042b4:	91 09       	st.w	r8[0x0],r9
800042b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800042ba:	fe f9 03 56 	ld.w	r9,pc[854]
800042be:	72 08       	ld.w	r8,r9[0x0]
800042c0:	20 18       	sub	r8,1
800042c2:	93 08       	st.w	r9[0x0],r8
800042c4:	c0 71       	brne	800042d2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800042c6:	30 09       	mov	r9,0
800042c8:	fe f8 03 40 	ld.w	r8,pc[832]
800042cc:	91 09       	st.w	r8[0x0],r9
800042ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800042d2:	fe f8 03 56 	ld.w	r8,pc[854]
800042d6:	fe f9 03 2e 	ld.w	r9,pc[814]
800042da:	72 0a       	ld.w	r10,r9[0x0]
800042dc:	70 09       	ld.w	r9,r8[0x0]
800042de:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800042e2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042e6:	70 09       	ld.w	r9,r8[0x0]
800042e8:	2f f9       	sub	r9,-1
800042ea:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042ec:	e0 49 01 ff 	cp.w	r9,511
800042f0:	e0 88 00 16 	brls	8000431c <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800042f4:	30 09       	mov	r9,0
800042f6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042f8:	fe f6 03 0c 	ld.w	r6,pc[780]
800042fc:	6c 0c       	ld.w	r12,r6[0x0]
800042fe:	f0 1f 00 cd 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004302:	fe f8 02 fa 	ld.w	r8,pc[762]
80004306:	70 0c       	ld.w	r12,r8[0x0]
80004308:	f0 1f 00 b7 	mcall	800045e4 <phy_rx_func+0xe98>
8000430c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000430e:	c0 71       	brne	8000431c <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80004310:	30 09       	mov	r9,0
80004312:	fe f8 02 f6 	ld.w	r8,pc[758]
80004316:	91 09       	st.w	r8[0x0],r9
80004318:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000431c:	fe f9 02 f4 	ld.w	r9,pc[756]
80004320:	72 08       	ld.w	r8,r9[0x0]
80004322:	20 18       	sub	r8,1
80004324:	93 08       	st.w	r9[0x0],r8
80004326:	c0 71       	brne	80004334 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80004328:	30 09       	mov	r9,0
8000432a:	fe f8 02 de 	ld.w	r8,pc[734]
8000432e:	91 09       	st.w	r8[0x0],r9
80004330:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004334:	fe f8 02 f4 	ld.w	r8,pc[756]
80004338:	fe f9 02 cc 	ld.w	r9,pc[716]
8000433c:	72 0a       	ld.w	r10,r9[0x0]
8000433e:	70 09       	ld.w	r9,r8[0x0]
80004340:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004344:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004348:	70 09       	ld.w	r9,r8[0x0]
8000434a:	2f f9       	sub	r9,-1
8000434c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000434e:	e0 49 01 ff 	cp.w	r9,511
80004352:	e0 88 00 16 	brls	8000437e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80004356:	30 09       	mov	r9,0
80004358:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000435a:	fe f7 02 aa 	ld.w	r7,pc[682]
8000435e:	6e 0c       	ld.w	r12,r7[0x0]
80004360:	f0 1f 00 b4 	mcall	80004630 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004364:	fe f8 02 98 	ld.w	r8,pc[664]
80004368:	70 0c       	ld.w	r12,r8[0x0]
8000436a:	f0 1f 00 9f 	mcall	800045e4 <phy_rx_func+0xe98>
8000436e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004370:	c0 71       	brne	8000437e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80004372:	30 09       	mov	r9,0
80004374:	fe f8 02 94 	ld.w	r8,pc[660]
80004378:	91 09       	st.w	r8[0x0],r9
8000437a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000437e:	fe f9 02 92 	ld.w	r9,pc[658]
80004382:	72 08       	ld.w	r8,r9[0x0]
80004384:	20 18       	sub	r8,1
80004386:	93 08       	st.w	r9[0x0],r8
80004388:	c0 71       	brne	80004396 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000438a:	30 09       	mov	r9,0
8000438c:	fe f8 02 7c 	ld.w	r8,pc[636]
80004390:	91 09       	st.w	r8[0x0],r9
80004392:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004396:	20 18       	sub	r8,1
80004398:	fe f9 02 78 	ld.w	r9,pc[632]
8000439c:	93 08       	st.w	r9[0x0],r8
8000439e:	58 08       	cp.w	r8,0
800043a0:	e0 81 01 13 	brne	800045c6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
800043a4:	30 09       	mov	r9,0
800043a6:	fe f8 02 62 	ld.w	r8,pc[610]
800043aa:	91 09       	st.w	r8[0x0],r9
800043ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800043b0:	fe f8 02 70 	ld.w	r8,pc[624]
800043b4:	11 89       	ld.ub	r9,r8[0x0]
800043b6:	30 48       	mov	r8,4
800043b8:	f0 09 18 00 	cp.b	r9,r8
800043bc:	c0 80       	breq	800043cc <phy_rx_func+0xc80>
800043be:	fe f8 02 62 	ld.w	r8,pc[610]
800043c2:	11 89       	ld.ub	r9,r8[0x0]
800043c4:	30 38       	mov	r8,3
800043c6:	f0 09 18 00 	cp.b	r9,r8
800043ca:	c1 41       	brne	800043f2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800043cc:	6e 29       	ld.w	r9,r7[0x8]
800043ce:	fe f8 02 7a 	ld.w	r8,pc[634]
800043d2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800043d4:	6e 39       	ld.w	r9,r7[0xc]
800043d6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800043d8:	fe f9 02 38 	ld.w	r9,pc[568]
800043dc:	72 08       	ld.w	r8,r9[0x0]
800043de:	20 88       	sub	r8,8
800043e0:	93 08       	st.w	r9[0x0],r8
800043e2:	e0 81 00 f2 	brne	800045c6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800043e6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800043e8:	fe f9 02 20 	ld.w	r9,pc[544]
800043ec:	93 08       	st.w	r9[0x0],r8
800043ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800043f2:	fe f8 02 2e 	ld.w	r8,pc[558]
800043f6:	11 89       	ld.ub	r9,r8[0x0]
800043f8:	31 38       	mov	r8,19
800043fa:	f0 09 18 00 	cp.b	r9,r8
800043fe:	e0 81 00 9c 	brne	80004536 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80004402:	fe f8 02 62 	ld.w	r8,pc[610]
80004406:	11 88       	ld.ub	r8,r8[0x0]
80004408:	30 c9       	mov	r9,12
8000440a:	f2 08 18 00 	cp.b	r8,r9
8000440e:	e0 81 00 7b 	brne	80004504 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80004412:	8e 49       	ld.sh	r9,r7[0x8]
80004414:	fe f8 02 54 	ld.w	r8,pc[596]
80004418:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
8000441c:	30 09       	mov	r9,0
8000441e:	fe f8 02 46 	ld.w	r8,pc[582]
80004422:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004424:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004428:	3f 38       	mov	r8,-13
8000442a:	f0 09 18 00 	cp.b	r9,r8
8000442e:	c6 61       	brne	800044fa <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80004430:	10 99       	mov	r9,r8
80004432:	4f c8       	lddpc	r8,80004620 <phy_rx_func+0xed4>
80004434:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80004436:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000443a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000443e:	4f 58       	lddpc	r8,80004610 <phy_rx_func+0xec4>
80004440:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80004442:	30 19       	mov	r9,1
80004444:	fe f8 02 0c 	ld.w	r8,pc[524]
80004448:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000444a:	8e 79       	ld.sh	r9,r7[0xe]
8000444c:	fe f8 02 14 	ld.w	r8,pc[532]
80004450:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80004452:	4f 68       	lddpc	r8,80004628 <phy_rx_func+0xedc>
80004454:	4e c9       	lddpc	r9,80004604 <phy_rx_func+0xeb8>
80004456:	72 0a       	ld.w	r10,r9[0x0]
80004458:	70 09       	ld.w	r9,r8[0x0]
8000445a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000445e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004462:	70 09       	ld.w	r9,r8[0x0]
80004464:	2f f9       	sub	r9,-1
80004466:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004468:	e0 49 01 ff 	cp.w	r9,511
8000446c:	e0 88 00 13 	brls	80004492 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80004470:	30 09       	mov	r9,0
80004472:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004474:	4e 46       	lddpc	r6,80004604 <phy_rx_func+0xeb8>
80004476:	6c 0c       	ld.w	r12,r6[0x0]
80004478:	f0 1f 00 6e 	mcall	80004630 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000447c:	4e 08       	lddpc	r8,800045fc <phy_rx_func+0xeb0>
8000447e:	70 0c       	ld.w	r12,r8[0x0]
80004480:	f0 1f 00 59 	mcall	800045e4 <phy_rx_func+0xe98>
80004484:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004486:	c0 61       	brne	80004492 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80004488:	30 09       	mov	r9,0
8000448a:	4e 08       	lddpc	r8,80004608 <phy_rx_func+0xebc>
8000448c:	91 09       	st.w	r8[0x0],r9
8000448e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004492:	4e 09       	lddpc	r9,80004610 <phy_rx_func+0xec4>
80004494:	72 08       	ld.w	r8,r9[0x0]
80004496:	20 18       	sub	r8,1
80004498:	93 08       	st.w	r9[0x0],r8
8000449a:	c0 61       	brne	800044a6 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
8000449c:	30 09       	mov	r9,0
8000449e:	4d b8       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800044a0:	91 09       	st.w	r8[0x0],r9
800044a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
800044a6:	4e 18       	lddpc	r8,80004628 <phy_rx_func+0xedc>
800044a8:	4d 79       	lddpc	r9,80004604 <phy_rx_func+0xeb8>
800044aa:	72 0a       	ld.w	r10,r9[0x0]
800044ac:	70 09       	ld.w	r9,r8[0x0]
800044ae:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800044b2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800044b6:	70 09       	ld.w	r9,r8[0x0]
800044b8:	2f f9       	sub	r9,-1
800044ba:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800044bc:	e0 49 01 ff 	cp.w	r9,511
800044c0:	e0 88 00 13 	brls	800044e6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800044c4:	30 09       	mov	r9,0
800044c6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800044c8:	4c f7       	lddpc	r7,80004604 <phy_rx_func+0xeb8>
800044ca:	6e 0c       	ld.w	r12,r7[0x0]
800044cc:	f0 1f 00 59 	mcall	80004630 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800044d0:	4c b8       	lddpc	r8,800045fc <phy_rx_func+0xeb0>
800044d2:	70 0c       	ld.w	r12,r8[0x0]
800044d4:	f0 1f 00 44 	mcall	800045e4 <phy_rx_func+0xe98>
800044d8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800044da:	c0 61       	brne	800044e6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800044dc:	30 09       	mov	r9,0
800044de:	4c b8       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800044e0:	91 09       	st.w	r8[0x0],r9
800044e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800044e6:	4c b9       	lddpc	r9,80004610 <phy_rx_func+0xec4>
800044e8:	72 08       	ld.w	r8,r9[0x0]
800044ea:	20 18       	sub	r8,1
800044ec:	93 08       	st.w	r9[0x0],r8
800044ee:	c6 c1       	brne	800045c6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800044f0:	30 09       	mov	r9,0
800044f2:	4c 68       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800044f4:	91 09       	st.w	r8[0x0],r9
800044f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800044fa:	30 09       	mov	r9,0
800044fc:	4c 38       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800044fe:	91 09       	st.w	r8[0x0],r9
80004500:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004504:	8e 4a       	ld.sh	r10,r7[0x8]
80004506:	4d 99       	lddpc	r9,80004668 <phy_rx_func+0xf1c>
80004508:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
8000450c:	4d 6a       	lddpc	r10,80004664 <phy_rx_func+0xf18>
8000450e:	15 88       	ld.ub	r8,r10[0x0]
80004510:	f0 cb ff ff 	sub	r11,r8,-1
80004514:	8e 5c       	ld.sh	r12,r7[0xa]
80004516:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
8000451a:	f0 cb ff fe 	sub	r11,r8,-2
8000451e:	8e 6c       	ld.sh	r12,r7[0xc]
80004520:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004524:	f0 cb ff fd 	sub	r11,r8,-3
80004528:	8e 7c       	ld.sh	r12,r7[0xe]
8000452a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000452e:	2f c8       	sub	r8,-4
80004530:	b4 88       	st.b	r10[0x0],r8
80004532:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004536:	30 09       	mov	r9,0
80004538:	4b 48       	lddpc	r8,80004608 <phy_rx_func+0xebc>
8000453a:	91 09       	st.w	r8[0x0],r9
8000453c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004540:	4c 08       	lddpc	r8,80004640 <phy_rx_func+0xef4>
80004542:	70 09       	ld.w	r9,r8[0x0]
80004544:	8e 4b       	ld.sh	r11,r7[0x8]
80004546:	4c 0a       	lddpc	r10,80004644 <phy_rx_func+0xef8>
80004548:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
8000454c:	2f f9       	sub	r9,-1
8000454e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004550:	4b 58       	lddpc	r8,80004624 <phy_rx_func+0xed8>
80004552:	70 09       	ld.w	r9,r8[0x0]
80004554:	20 29       	sub	r9,2
80004556:	91 09       	st.w	r8[0x0],r9
80004558:	70 08       	ld.w	r8,r8[0x0]
8000455a:	58 08       	cp.w	r8,0
8000455c:	c2 f1       	brne	800045ba <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
8000455e:	30 09       	mov	r9,0
80004560:	4b 88       	lddpc	r8,80004640 <phy_rx_func+0xef4>
80004562:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004564:	8e 59       	ld.sh	r9,r7[0xa]
80004566:	fe 78 82 12 	mov	r8,-32238
8000456a:	f0 09 19 00 	cp.h	r9,r8
8000456e:	c2 11       	brne	800045b0 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004570:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004574:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004578:	4a f8       	lddpc	r8,80004634 <phy_rx_func+0xee8>
8000457a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
8000457c:	8e 59       	ld.sh	r9,r7[0xa]
8000457e:	4a f8       	lddpc	r8,80004638 <phy_rx_func+0xeec>
80004580:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004582:	8e 69       	ld.sh	r9,r7[0xc]
80004584:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004586:	f0 1f 00 2e 	mcall	8000463c <phy_rx_func+0xef0>
8000458a:	4a 18       	lddpc	r8,8000460c <phy_rx_func+0xec0>
8000458c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000458e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004592:	31 38       	mov	r8,19
80004594:	f0 09 18 00 	cp.b	r9,r8
80004598:	c0 71       	brne	800045a6 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
8000459a:	10 99       	mov	r9,r8
8000459c:	4a 18       	lddpc	r8,80004620 <phy_rx_func+0xed4>
8000459e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
800045a0:	30 09       	mov	r9,0
800045a2:	49 c8       	lddpc	r8,80004610 <phy_rx_func+0xec4>
800045a4:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800045a6:	30 49       	mov	r9,4
800045a8:	49 88       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800045aa:	91 09       	st.w	r8[0x0],r9
800045ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800045b0:	30 09       	mov	r9,0
800045b2:	49 68       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800045b4:	91 09       	st.w	r8[0x0],r9
800045b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800045ba:	4a dc       	lddpc	r12,8000466c <phy_rx_func+0xf20>
800045bc:	f0 1f 00 18 	mcall	8000461c <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
800045c0:	30 09       	mov	r9,0
800045c2:	49 28       	lddpc	r8,80004608 <phy_rx_func+0xebc>
800045c4:	91 09       	st.w	r8[0x0],r9
800045c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800045ca:	00 00       	add	r0,r0
800045cc:	00 00       	add	r0,r0
800045ce:	0a d0       	st.w	--r5,r0
800045d0:	00 00       	add	r0,r0
800045d2:	0a e8       	st.h	--r5,r8
800045d4:	00 00       	add	r0,r0
800045d6:	0a c8       	st.b	r5++,r8
800045d8:	00 00       	add	r0,r0
800045da:	0a aa       	st.w	r5++,r10
800045dc:	00 00       	add	r0,r0
800045de:	0a 98       	mov	r8,r5
800045e0:	00 00       	add	r0,r0
800045e2:	0a c0       	st.b	r5++,r0
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	35 cc       	mov	r12,92
800045e8:	00 00       	add	r0,r0
800045ea:	0a b8       	st.h	r5++,r8
800045ec:	80 00       	ld.sh	r0,r0[0x0]
800045ee:	34 e4       	mov	r4,78
800045f0:	00 00       	add	r0,r0
800045f2:	0a cc       	st.b	r5++,r12
800045f4:	80 00       	ld.sh	r0,r0[0x0]
800045f6:	35 18       	mov	r8,81
800045f8:	00 00       	add	r0,r0
800045fa:	0a a9       	st.w	r5++,r9
800045fc:	00 00       	add	r0,r0
800045fe:	0a c4       	st.b	r5++,r4
80004600:	00 00       	add	r0,r0
80004602:	0a d4       	st.w	--r5,r4
80004604:	00 00       	add	r0,r0
80004606:	0a ac       	st.w	r5++,r12
80004608:	00 00       	add	r0,r0
8000460a:	0a f4       	st.b	--r5,r4
8000460c:	00 00       	add	r0,r0
8000460e:	0a dc       	st.w	--r5,r12
80004610:	00 00       	add	r0,r0
80004612:	0a 94       	mov	r4,r5
80004614:	00 00       	add	r0,r0
80004616:	0a 61       	and	r1,r5
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	e9 90       	*unknown*
8000461c:	80 00       	ld.sh	r0,r0[0x0]
8000461e:	80 f4       	ld.uh	r4,r0[0xe]
80004620:	00 00       	add	r0,r0
80004622:	0a a8       	st.w	r5++,r8
80004624:	00 00       	add	r0,r0
80004626:	0b 00       	ld.w	r0,r5++
80004628:	00 00       	add	r0,r0
8000462a:	0a e0       	st.h	--r5,r0
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	89 5a       	st.w	r4[0x14],r10
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	35 00       	mov	r0,80
80004634:	00 00       	add	r0,r0
80004636:	0a 74       	tst	r4,r5
80004638:	00 00       	add	r0,r0
8000463a:	1f 30       	ld.ub	r0,pc++
8000463c:	80 00       	ld.sh	r0,r0[0x0]
8000463e:	34 b4       	mov	r4,75
80004640:	00 00       	add	r0,r0
80004642:	0a 9c       	mov	r12,r5
80004644:	00 00       	add	r0,r0
80004646:	1e 34       	cp.w	r4,pc
80004648:	00 00       	add	r0,r0
8000464a:	0a a0       	st.w	r5++,r0
8000464c:	00 00       	add	r0,r0
8000464e:	0a 62       	and	r2,r5
80004650:	00 00       	add	r0,r0
80004652:	0a 7e       	tst	lr,r5
80004654:	00 00       	add	r0,r0
80004656:	0a f8       	st.b	--r5,r8
80004658:	00 00       	add	r0,r0
8000465a:	0a b4       	st.h	r5++,r4
8000465c:	00 00       	add	r0,r0
8000465e:	0a 85       	andn	r5,r5
80004660:	00 00       	add	r0,r0
80004662:	1e 2c       	rsub	r12,pc
80004664:	00 00       	add	r0,r0
80004666:	0a ec       	st.h	--r5,r12
80004668:	00 00       	add	r0,r0
8000466a:	1f 34       	ld.ub	r4,pc++
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	e9 a8 d4 01 	ldc.d	cp6,cr4,r8[0x4]

80004670 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004670:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80004672:	49 a8       	lddpc	r8,800046d8 <pdca_int_handler+0x68>
80004674:	70 09       	ld.w	r9,r8[0x0]
80004676:	2f f9       	sub	r9,-1
80004678:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000467a:	49 98       	lddpc	r8,800046dc <pdca_int_handler+0x6c>
8000467c:	11 89       	ld.ub	r9,r8[0x0]
8000467e:	ec 19 00 01 	eorl	r9,0x1
80004682:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004684:	11 89       	ld.ub	r9,r8[0x0]
80004686:	a5 69       	lsl	r9,0x4
80004688:	2f c9       	sub	r9,-4
8000468a:	49 6a       	lddpc	r10,800046e0 <pdca_int_handler+0x70>
8000468c:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000468e:	fe 7a 00 40 	mov	r10,-65472
80004692:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004694:	30 39       	mov	r9,3
80004696:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004698:	11 8a       	ld.ub	r10,r8[0x0]
8000469a:	a5 6a       	lsl	r10,0x4
8000469c:	2f ca       	sub	r10,-4
8000469e:	49 28       	lddpc	r8,800046e4 <pdca_int_handler+0x74>
800046a0:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800046a2:	fe 78 00 00 	mov	r8,-65536
800046a6:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800046a8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800046aa:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800046ac:	48 f8       	lddpc	r8,800046e8 <pdca_int_handler+0x78>
800046ae:	70 08       	ld.w	r8,r8[0x0]
800046b0:	58 08       	cp.w	r8,0
800046b2:	c0 70       	breq	800046c0 <pdca_int_handler+0x50>
800046b4:	48 a9       	lddpc	r9,800046dc <pdca_int_handler+0x6c>
800046b6:	13 89       	ld.ub	r9,r9[0x0]
800046b8:	a5 69       	lsl	r9,0x4
800046ba:	48 bc       	lddpc	r12,800046e4 <pdca_int_handler+0x74>
800046bc:	12 0c       	add	r12,r9
800046be:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800046c0:	48 b8       	lddpc	r8,800046ec <pdca_int_handler+0x7c>
800046c2:	70 08       	ld.w	r8,r8[0x0]
800046c4:	58 08       	cp.w	r8,0
800046c6:	c0 70       	breq	800046d4 <pdca_int_handler+0x64>
800046c8:	48 59       	lddpc	r9,800046dc <pdca_int_handler+0x6c>
800046ca:	13 89       	ld.ub	r9,r9[0x0]
800046cc:	a5 69       	lsl	r9,0x4
800046ce:	48 5c       	lddpc	r12,800046e0 <pdca_int_handler+0x70>
800046d0:	12 0c       	add	r12,r9
800046d2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800046d4:	d4 02       	popm	lr
800046d6:	d6 03       	rete
800046d8:	00 00       	add	r0,r0
800046da:	0b 08       	ld.w	r8,r5++
800046dc:	00 00       	add	r0,r0
800046de:	97 54       	st.w	r11[0x14],r4
800046e0:	00 00       	add	r0,r0
800046e2:	97 7c       	st.w	r11[0x1c],r12
800046e4:	00 00       	add	r0,r0
800046e6:	97 5c       	st.w	r11[0x14],r12
800046e8:	00 00       	add	r0,r0
800046ea:	0b 04       	ld.w	r4,r5++
800046ec:	00 00       	add	r0,r0
800046ee:	0b 0c       	ld.w	r12,r5++

800046f0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800046f0:	fe 78 10 00 	mov	r8,-61440
800046f4:	e0 69 0d c0 	mov	r9,3520
800046f8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800046fc:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004700:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004704:	fe 78 34 00 	mov	r8,-52224
80004708:	e0 69 80 00 	mov	r9,32768
8000470c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000470e:	30 09       	mov	r9,0
80004710:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004712:	e0 69 04 21 	mov	r9,1057
80004716:	ea 19 3f 20 	orh	r9,0x3f20
8000471a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
8000471c:	e0 69 02 9f 	mov	r9,671
80004720:	ea 19 01 00 	orh	r9,0x100
80004724:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80004726:	e0 6a 04 02 	mov	r10,1026
8000472a:	ea 1a 3f 20 	orh	r10,0x3f20
8000472e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004730:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004732:	5e fc       	retal	r12

80004734 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004734:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004736:	30 19       	mov	r9,1
80004738:	49 78       	lddpc	r8,80004794 <local_start_PDC+0x60>
8000473a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
8000473c:	fe 78 00 00 	mov	r8,-65536
80004740:	30 7b       	mov	r11,7
80004742:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004744:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004746:	49 59       	lddpc	r9,80004798 <local_start_PDC+0x64>
80004748:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000474c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000474e:	30 3a       	mov	r10,3
80004750:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004752:	30 1c       	mov	r12,1
80004754:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004756:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004758:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000475a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000475c:	30 2c       	mov	r12,2
8000475e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004760:	48 f9       	lddpc	r9,8000479c <local_start_PDC+0x68>
80004762:	e0 68 5a 5a 	mov	r8,23130
80004766:	ea 18 ab cd 	orh	r8,0xabcd
8000476a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
8000476c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000476e:	30 0e       	mov	lr,0
80004770:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004772:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004774:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004776:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004778:	fe 78 00 40 	mov	r8,-65472
8000477c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000477e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004780:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004784:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004786:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004788:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000478a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000478c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000478e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004790:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004792:	d8 02       	popm	pc
80004794:	00 00       	add	r0,r0
80004796:	97 54       	st.w	r11[0x14],r4
80004798:	00 00       	add	r0,r0
8000479a:	97 5c       	st.w	r11[0x14],r12
8000479c:	00 00       	add	r0,r0
8000479e:	97 7c       	st.w	r11[0x1c],r12

800047a0 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800047a0:	48 38       	lddpc	r8,800047ac <register_rx_tx_func+0xc>
800047a2:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800047a4:	48 38       	lddpc	r8,800047b0 <register_rx_tx_func+0x10>
800047a6:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800047a8:	5e fc       	retal	r12
800047aa:	00 00       	add	r0,r0
800047ac:	00 00       	add	r0,r0
800047ae:	0b 04       	ld.w	r4,r5++
800047b0:	00 00       	add	r0,r0
800047b2:	0b 0c       	ld.w	r12,r5++

800047b4 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800047b4:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800047b6:	fe 78 10 00 	mov	r8,-61440
800047ba:	30 29       	mov	r9,2
800047bc:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800047c0:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800047c4:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
800047c6:	30 3a       	mov	r10,3
800047c8:	36 0b       	mov	r11,96
800047ca:	49 4c       	lddpc	r12,80004818 <ssc_init+0x64>
800047cc:	f0 1f 00 14 	mcall	8000481c <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
800047d0:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800047d2:	fe 79 10 00 	mov	r9,-61440
800047d6:	f2 f8 01 60 	ld.w	r8,r9[352]
800047da:	e2 18 00 02 	andl	r8,0x2,COH
800047de:	cf c0       	breq	800047d6 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800047e0:	fe 79 10 00 	mov	r9,-61440
800047e4:	f2 f8 01 60 	ld.w	r8,r9[352]
800047e8:	e2 18 00 02 	andl	r8,0x2,COH
800047ec:	cf c1       	brne	800047e4 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
800047ee:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800047f0:	f0 1f 00 0c 	mcall	80004820 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
800047f4:	f0 1f 00 0c 	mcall	80004824 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800047f8:	fe 79 00 00 	mov	r9,-65536
800047fc:	30 18       	mov	r8,1
800047fe:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004800:	fe 7a 00 40 	mov	r10,-65472
80004804:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004806:	e0 6b 01 01 	mov	r11,257
8000480a:	fe 7a 34 00 	mov	r10,-52224
8000480e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80004810:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80004812:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004814:	d8 02       	popm	pc
80004816:	00 00       	add	r0,r0
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	46 70       	lddsp	r0,sp[0x19c]
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	63 d0       	ld.w	r0,r1[0x74]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	46 f0       	lddsp	r0,sp[0x1bc]
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	47 34       	lddsp	r4,sp[0x1cc]

80004828 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004828:	48 28       	lddpc	r8,80004830 <xcmp_register_app_list+0x8>
8000482a:	91 0c       	st.w	r8[0x0],r12
}
8000482c:	5e fc       	retal	r12
8000482e:	00 00       	add	r0,r0
80004830:	00 00       	add	r0,r0
80004832:	97 9c       	st.w	r11[0x24],r12

80004834 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004834:	eb cd 40 80 	pushm	r7,lr
80004838:	fa cd 01 00 	sub	sp,sp,256
8000483c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000483e:	16 98       	mov	r8,r11
80004840:	2f 08       	sub	r8,-16
80004842:	af a8       	sbr	r8,0xe
80004844:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004846:	3f f8       	mov	r8,-1
80004848:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000484a:	30 b9       	mov	r9,11
8000484c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000484e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004850:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004852:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004854:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004856:	f6 ca ff fe 	sub	r10,r11,-2
8000485a:	18 9b       	mov	r11,r12
8000485c:	fa cc ff f0 	sub	r12,sp,-16
80004860:	f0 1f 00 05 	mcall	80004874 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004864:	2f e7       	sub	r7,-2
80004866:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004868:	1a 9c       	mov	r12,sp
8000486a:	f0 1f 00 04 	mcall	80004878 <xcmp_tx+0x44>
}
8000486e:	2c 0d       	sub	sp,-256
80004870:	e3 cd 80 80 	ldm	sp++,r7,pc
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	88 12       	ld.sh	r2,r4[0x2]
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	4e 44       	lddpc	r4,80004a08 <xcmp_IdleTestTone+0x50>

8000487c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
8000487c:	d4 21       	pushm	r4-r7,lr
8000487e:	fa cd 00 d0 	sub	sp,sp,208
80004882:	18 94       	mov	r4,r12
80004884:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80004886:	e0 68 01 00 	mov	r8,256
8000488a:	f0 0b 19 00 	cp.h	r11,r8
8000488e:	e0 8b 00 38 	brhi	800048fe <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004892:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80004896:	e0 68 04 1d 	mov	r8,1053
8000489a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
8000489c:	30 18       	mov	r8,1
8000489e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
800048a0:	32 08       	mov	r8,32
800048a2:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
800048a4:	30 28       	mov	r8,2
800048a6:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
800048a8:	30 48       	mov	r8,4
800048aa:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800048ac:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
800048b0:	ea 1a 0c 00 	orh	r10,0xc00
800048b4:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800048b6:	30 4a       	mov	r10,4
800048b8:	1a 9b       	mov	r11,sp
800048ba:	fa cc ff f4 	sub	r12,sp,-12
800048be:	f0 1f 00 12 	mcall	80004904 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800048c2:	30 f8       	mov	r8,15
800048c4:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800048c8:	3a 78       	mov	r8,-89
800048ca:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800048ce:	30 08       	mov	r8,0
800048d0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800048d4:	0e 9a       	mov	r10,r7
800048d6:	5c 7a       	castu.h	r10
800048d8:	f4 08 16 08 	lsr	r8,r10,0x8
800048dc:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800048e0:	0e 96       	mov	r6,r7
800048e2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800048e6:	08 9b       	mov	r11,r4
800048e8:	fa cc ff eb 	sub	r12,sp,-21
800048ec:	f0 1f 00 06 	mcall	80004904 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800048f0:	ee cb ff f3 	sub	r11,r7,-13
800048f4:	5c 5b       	castu.b	r11
800048f6:	fa cc ff fa 	sub	r12,sp,-6
800048fa:	f0 1f 00 04 	mcall	80004908 <xcmp_data_session_req+0x8c>
}
800048fe:	2c cd       	sub	sp,-208
80004900:	d8 22       	popm	r4-r7,pc
80004902:	00 00       	add	r0,r0
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	88 12       	ld.sh	r2,r4[0x2]
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	48 34       	lddpc	r4,80004914 <xcmp_DeviceInitializationStatus_request+0x8>

8000490c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000490c:	d4 01       	pushm	lr
8000490e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004912:	fe 78 b4 00 	mov	r8,-19456
80004916:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004918:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000491c:	30 89       	mov	r9,8
8000491e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004920:	30 19       	mov	r9,1
80004922:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004924:	30 09       	mov	r9,0
80004926:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004928:	30 5a       	mov	r10,5
8000492a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000492c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000492e:	30 7a       	mov	r10,7
80004930:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004932:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004934:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004936:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000493a:	30 9b       	mov	r11,9
8000493c:	fa cc ff fe 	sub	r12,sp,-2
80004940:	f0 1f 00 02 	mcall	80004948 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004944:	2c dd       	sub	sp,-204
80004946:	d8 02       	popm	pc
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	48 34       	lddpc	r4,80004954 <xcmp_opcode_not_supported+0x8>

8000494c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000494c:	d4 01       	pushm	lr
8000494e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004952:	fe 78 80 00 	mov	r8,-32768
80004956:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004958:	30 38       	mov	r8,3
8000495a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000495c:	30 1b       	mov	r11,1
8000495e:	fa cc ff fe 	sub	r12,sp,-2
80004962:	f0 1f 00 03 	mcall	8000496c <xcmp_opcode_not_supported+0x20>
}
80004966:	2c dd       	sub	sp,-204
80004968:	d8 02       	popm	pc
8000496a:	00 00       	add	r0,r0
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	48 34       	lddpc	r4,80004978 <xcmp_exec_func+0x8>

80004970 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004970:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004972:	96 88       	ld.uh	r8,r11[0x0]
80004974:	e2 18 f0 00 	andl	r8,0xf000,COH
80004978:	e0 48 80 00 	cp.w	r8,32768
8000497c:	c0 f0       	breq	8000499a <xcmp_exec_func+0x2a>
8000497e:	e0 48 b0 00 	cp.w	r8,45056
80004982:	c1 20       	breq	800049a6 <xcmp_exec_func+0x36>
80004984:	58 08       	cp.w	r8,0
80004986:	c1 51       	brne	800049b0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004988:	78 08       	ld.w	r8,r12[0x0]
8000498a:	58 08       	cp.w	r8,0
8000498c:	c0 40       	breq	80004994 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000498e:	16 9c       	mov	r12,r11
80004990:	5d 18       	icall	r8
80004992:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004994:	f0 1f 00 08 	mcall	800049b4 <xcmp_exec_func+0x44>
80004998:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000499a:	78 18       	ld.w	r8,r12[0x4]
8000499c:	58 08       	cp.w	r8,0
8000499e:	c0 90       	breq	800049b0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800049a0:	16 9c       	mov	r12,r11
800049a2:	5d 18       	icall	r8
800049a4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800049a6:	78 28       	ld.w	r8,r12[0x8]
800049a8:	58 08       	cp.w	r8,0
800049aa:	c0 30       	breq	800049b0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800049ac:	16 9c       	mov	r12,r11
800049ae:	5d 18       	icall	r8
800049b0:	d8 02       	popm	pc
800049b2:	00 00       	add	r0,r0
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	49 4c       	lddpc	r12,80004a04 <xcmp_IdleTestTone+0x4c>

800049b8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800049b8:	d4 01       	pushm	lr
800049ba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800049be:	e0 68 04 09 	mov	r8,1033
800049c2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800049c4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800049c8:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800049ca:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800049ce:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800049d0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800049d2:	30 09       	mov	r9,0
800049d4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800049d6:	fb 69 00 08 	st.b	sp[8],r9
800049da:	fa c8 ff f7 	sub	r8,sp,-9
800049de:	b0 89       	st.b	r8[0x0],r9
800049e0:	fa c8 ff f6 	sub	r8,sp,-10
800049e4:	b0 89       	st.b	r8[0x0],r9
800049e6:	fa c8 ff f5 	sub	r8,sp,-11
800049ea:	b0 89       	st.b	r8[0x0],r9
800049ec:	fa c8 ff f4 	sub	r8,sp,-12
800049f0:	b0 89       	st.b	r8[0x0],r9
800049f2:	fa c8 ff f3 	sub	r8,sp,-13
800049f6:	b0 89       	st.b	r8[0x0],r9
800049f8:	fa c8 ff f2 	sub	r8,sp,-14
800049fc:	b0 89       	st.b	r8[0x0],r9
800049fe:	fa c8 ff f1 	sub	r8,sp,-15
80004a02:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004a04:	30 cb       	mov	r11,12
80004a06:	fa cc ff fe 	sub	r12,sp,-2
80004a0a:	f0 1f 00 03 	mcall	80004a14 <xcmp_IdleTestTone+0x5c>
}
80004a0e:	2c dd       	sub	sp,-204
80004a10:	d8 02       	popm	pc
80004a12:	00 00       	add	r0,r0
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	48 34       	lddpc	r4,80004a20 <xcmp_init+0x8>

80004a18 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004a18:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004a1a:	48 dc       	lddpc	r12,80004a4c <xcmp_init+0x34>
80004a1c:	f0 1f 00 0d 	mcall	80004a50 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004a20:	30 4b       	mov	r11,4
80004a22:	31 4c       	mov	r12,20
80004a24:	f0 1f 00 0c 	mcall	80004a54 <xcmp_init+0x3c>
80004a28:	48 c8       	lddpc	r8,80004a58 <xcmp_init+0x40>
80004a2a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004a2c:	30 09       	mov	r9,0
80004a2e:	1a d9       	st.w	--sp,r9
80004a30:	1a d9       	st.w	--sp,r9
80004a32:	1a d9       	st.w	--sp,r9
80004a34:	30 38       	mov	r8,3
80004a36:	e0 6a 04 00 	mov	r10,1024
80004a3a:	48 9b       	lddpc	r11,80004a5c <xcmp_init+0x44>
80004a3c:	48 9c       	lddpc	r12,80004a60 <xcmp_init+0x48>
80004a3e:	f0 1f 00 0a 	mcall	80004a64 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004a42:	f0 1f 00 0a 	mcall	80004a68 <xcmp_init+0x50>
80004a46:	2f dd       	sub	sp,-12
	
}
80004a48:	d8 02       	popm	pc
80004a4a:	00 00       	add	r0,r0
80004a4c:	80 00       	ld.sh	r0,r0[0x0]
80004a4e:	4b 68       	lddpc	r8,80004b24 <xcmp_rx_process+0xb8>
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	4b b4       	lddpc	r4,80004b3c <xcmp_rx_process+0xd0>
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	74 88       	ld.w	r8,r10[0x20]
80004a58:	00 00       	add	r0,r0
80004a5a:	0b 28       	ld.uh	r8,r5++
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	e9 d4 80 00 	ldswp.w	r4,r4[0]
80004a62:	4a 6c       	lddpc	r12,80004af8 <xcmp_rx_process+0x8c>
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	7b a4       	ld.w	r4,sp[0x68]
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	4b ec       	lddpc	r12,80004b60 <xcmp_rx_process+0xf4>

80004a6c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004a6c:	d4 31       	pushm	r0-r7,lr
80004a6e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a70:	4b 16       	lddpc	r6,80004b34 <xcmp_rx_process+0xc8>
80004a72:	30 05       	mov	r5,0
80004a74:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004a76:	4b 13       	lddpc	r3,80004b38 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004a78:	4b 12       	lddpc	r2,80004b3c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004a7a:	4b 21       	lddpc	r1,80004b40 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004a7c:	4b 20       	lddpc	r0,80004b44 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a7e:	6c 0c       	ld.w	r12,r6[0x0]
80004a80:	0a 99       	mov	r9,r5
80004a82:	08 9a       	mov	r10,r4
80004a84:	1a 9b       	mov	r11,sp
80004a86:	f0 1f 00 31 	mcall	80004b48 <xcmp_rx_process+0xdc>
80004a8a:	58 1c       	cp.w	r12,1
80004a8c:	cf 91       	brne	80004a7e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004a8e:	40 0b       	lddsp	r11,sp[0x0]
80004a90:	58 0b       	cp.w	r11,0
80004a92:	cf 60       	breq	80004a7e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004a94:	96 0a       	ld.sh	r10,r11[0x0]
80004a96:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a9a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004a9e:	59 c8       	cp.w	r8,28
80004aa0:	c1 e0       	breq	80004adc <xcmp_rx_process+0x70>
80004aa2:	e0 89 00 07 	brgt	80004ab0 <xcmp_rx_process+0x44>
80004aa6:	58 e8       	cp.w	r8,14
80004aa8:	c0 e0       	breq	80004ac4 <xcmp_rx_process+0x58>
80004aaa:	58 f8       	cp.w	r8,15
80004aac:	c2 41       	brne	80004af4 <xcmp_rx_process+0x88>
80004aae:	c0 f8       	rjmp	80004acc <xcmp_rx_process+0x60>
80004ab0:	e0 48 01 09 	cp.w	r8,265
80004ab4:	c1 80       	breq	80004ae4 <xcmp_rx_process+0x78>
80004ab6:	e0 48 01 0a 	cp.w	r8,266
80004aba:	c1 90       	breq	80004aec <xcmp_rx_process+0x80>
80004abc:	e0 48 00 2c 	cp.w	r8,44
80004ac0:	c1 a1       	brne	80004af4 <xcmp_rx_process+0x88>
80004ac2:	c0 98       	rjmp	80004ad4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004ac4:	4a 2c       	lddpc	r12,80004b4c <xcmp_rx_process+0xe0>
80004ac6:	f0 1f 00 23 	mcall	80004b50 <xcmp_rx_process+0xe4>
					break;
80004aca:	c2 f8       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004acc:	4a 2c       	lddpc	r12,80004b54 <xcmp_rx_process+0xe8>
80004ace:	f0 1f 00 21 	mcall	80004b50 <xcmp_rx_process+0xe4>
					break;
80004ad2:	c2 b8       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004ad4:	4a 1c       	lddpc	r12,80004b58 <xcmp_rx_process+0xec>
80004ad6:	f0 1f 00 1f 	mcall	80004b50 <xcmp_rx_process+0xe4>
					break;
80004ada:	c2 78       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004adc:	04 9c       	mov	r12,r2
80004ade:	f0 1f 00 1d 	mcall	80004b50 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004ae2:	c2 38       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004ae4:	02 9c       	mov	r12,r1
80004ae6:	f0 1f 00 1b 	mcall	80004b50 <xcmp_rx_process+0xe4>
					break;
80004aea:	c1 f8       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004aec:	00 9c       	mov	r12,r0
80004aee:	f0 1f 00 19 	mcall	80004b50 <xcmp_rx_process+0xe4>
					break;
80004af2:	c1 b8       	rjmp	80004b28 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004af4:	12 98       	mov	r8,r9
80004af6:	e2 18 04 00 	andl	r8,0x400,COH
80004afa:	c0 70       	breq	80004b08 <xcmp_rx_process+0x9c>
80004afc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004b00:	e0 48 00 68 	cp.w	r8,104
80004b04:	e0 8a 00 08 	brle	80004b14 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004b08:	e2 19 f0 00 	andl	r9,0xf000,COH
80004b0c:	c0 e1       	brne	80004b28 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004b0e:	f0 1f 00 14 	mcall	80004b5c <xcmp_rx_process+0xf0>
80004b12:	c0 b8       	rjmp	80004b28 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004b14:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004b18:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004b1c:	49 19       	lddpc	r9,80004b60 <xcmp_rx_process+0xf4>
80004b1e:	72 08       	ld.w	r8,r9[0x0]
80004b20:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004b24:	f0 1f 00 0b 	mcall	80004b50 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004b28:	66 0c       	ld.w	r12,r3[0x0]
80004b2a:	40 0b       	lddsp	r11,sp[0x0]
80004b2c:	f0 1f 00 0e 	mcall	80004b64 <xcmp_rx_process+0xf8>
80004b30:	ca 7b       	rjmp	80004a7e <xcmp_rx_process+0x12>
80004b32:	00 00       	add	r0,r0
80004b34:	00 00       	add	r0,r0
80004b36:	0b 28       	ld.uh	r8,r5++
80004b38:	00 00       	add	r0,r0
80004b3a:	0a c0       	st.b	r5++,r0
80004b3c:	00 00       	add	r0,r0
80004b3e:	0b 38       	ld.ub	r8,r5++
80004b40:	00 00       	add	r0,r0
80004b42:	0b 2c       	ld.uh	r12,r5++
80004b44:	00 00       	add	r0,r0
80004b46:	0b 1c       	ld.sh	r12,r5++
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	71 24       	ld.w	r4,r8[0x48]
80004b4c:	00 00       	add	r0,r0
80004b4e:	0b 50       	ld.sh	r0,--r5
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	49 70       	lddpc	r0,80004bac <xcmp_rx+0x44>
80004b54:	00 00       	add	r0,r0
80004b56:	0b 10       	ld.sh	r0,r5++
80004b58:	00 00       	add	r0,r0
80004b5a:	0b 44       	ld.w	r4,--r5
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	49 4c       	lddpc	r12,80004bac <xcmp_rx+0x44>
80004b60:	00 00       	add	r0,r0
80004b62:	97 9c       	st.w	r11[0x24],r12
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	35 50       	mov	r0,85

80004b68 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004b68:	eb cd 40 90 	pushm	r4,r7,lr
80004b6c:	20 1d       	sub	sp,4
80004b6e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b72:	48 c8       	lddpc	r8,80004ba0 <xcmp_rx+0x38>
80004b74:	70 0c       	ld.w	r12,r8[0x0]
80004b76:	f0 1f 00 0c 	mcall	80004ba4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004b7a:	c1 00       	breq	80004b9a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b7c:	fa c7 ff fc 	sub	r7,sp,-4
80004b80:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004b82:	e0 6a 00 ca 	mov	r10,202
80004b86:	08 9b       	mov	r11,r4
80004b88:	f0 1f 00 08 	mcall	80004ba8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004b8c:	48 88       	lddpc	r8,80004bac <xcmp_rx+0x44>
80004b8e:	70 0c       	ld.w	r12,r8[0x0]
80004b90:	30 09       	mov	r9,0
80004b92:	12 9a       	mov	r10,r9
80004b94:	1a 9b       	mov	r11,sp
80004b96:	f0 1f 00 07 	mcall	80004bb0 <xcmp_rx+0x48>
	}	
}
80004b9a:	2f fd       	sub	sp,-4
80004b9c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004ba0:	00 00       	add	r0,r0
80004ba2:	0a c0       	st.b	r5++,r0
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	36 fc       	mov	r12,111
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	88 12       	ld.sh	r2,r4[0x2]
80004bac:	00 00       	add	r0,r0
80004bae:	0b 28       	ld.uh	r8,r5++
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	73 30       	ld.w	r0,r9[0x4c]

80004bb4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004bb4:	48 28       	lddpc	r8,80004bbc <xnl_register_xcmp_func+0x8>
80004bb6:	91 0c       	st.w	r8[0x0],r12
}
80004bb8:	5e fc       	retal	r12
80004bba:	00 00       	add	r0,r0
80004bbc:	00 00       	add	r0,r0
80004bbe:	0b 7c       	ld.ub	r12,--r5

80004bc0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004bc0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004bc2:	48 88       	lddpc	r8,80004be0 <xnl_get_msg_ack_func+0x20>
80004bc4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004bc6:	98 49       	ld.sh	r9,r12[0x8]
80004bc8:	f0 09 19 00 	cp.h	r9,r8
80004bcc:	c0 81       	brne	80004bdc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004bce:	48 68       	lddpc	r8,80004be4 <xnl_get_msg_ack_func+0x24>
80004bd0:	70 0c       	ld.w	r12,r8[0x0]
80004bd2:	30 09       	mov	r9,0
80004bd4:	12 9a       	mov	r10,r9
80004bd6:	12 9b       	mov	r11,r9
80004bd8:	f0 1f 00 04 	mcall	80004be8 <xnl_get_msg_ack_func+0x28>
80004bdc:	d8 02       	popm	pc
80004bde:	00 00       	add	r0,r0
80004be0:	00 00       	add	r0,r0
80004be2:	0b 62       	ld.uh	r2,--r5
80004be4:	00 00       	add	r0,r0
80004be6:	0b 5c       	ld.sh	r12,--r5
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	73 30       	ld.w	r0,r9[0x4c]

80004bec <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004bec:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004bf0:	30 09       	mov	r9,0
80004bf2:	4b 78       	lddpc	r8,80004ccc <xnl_init+0xe0>
80004bf4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004bf6:	30 0b       	mov	r11,0
80004bf8:	30 1c       	mov	r12,1
80004bfa:	f0 1f 00 36 	mcall	80004cd0 <xnl_init+0xe4>
80004bfe:	4b 68       	lddpc	r8,80004cd4 <xnl_init+0xe8>
80004c00:	91 0c       	st.w	r8[0x0],r12
80004c02:	70 08       	ld.w	r8,r8[0x0]
80004c04:	58 08       	cp.w	r8,0
80004c06:	c0 80       	breq	80004c16 <xnl_init+0x2a>
80004c08:	4b 38       	lddpc	r8,80004cd4 <xnl_init+0xe8>
80004c0a:	70 0c       	ld.w	r12,r8[0x0]
80004c0c:	30 09       	mov	r9,0
80004c0e:	12 9a       	mov	r10,r9
80004c10:	12 9b       	mov	r11,r9
80004c12:	f0 1f 00 32 	mcall	80004cd8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004c16:	30 4b       	mov	r11,4
80004c18:	33 cc       	mov	r12,60
80004c1a:	f0 1f 00 2e 	mcall	80004cd0 <xnl_init+0xe4>
80004c1e:	4b 08       	lddpc	r8,80004cdc <xnl_init+0xf0>
80004c20:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004c22:	30 4b       	mov	r11,4
80004c24:	36 4c       	mov	r12,100
80004c26:	f0 1f 00 2b 	mcall	80004cd0 <xnl_init+0xe4>
80004c2a:	4a e8       	lddpc	r8,80004ce0 <xnl_init+0xf4>
80004c2c:	91 0c       	st.w	r8[0x0],r12
80004c2e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004c30:	10 96       	mov	r6,r8
80004c32:	4a d5       	lddpc	r5,80004ce4 <xnl_init+0xf8>
80004c34:	6c 0c       	ld.w	r12,r6[0x0]
80004c36:	ea 07 00 0b 	add	r11,r5,r7
80004c3a:	f0 1f 00 2c 	mcall	80004ce8 <xnl_init+0xfc>
80004c3e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004c42:	e0 47 64 00 	cp.w	r7,25600
80004c46:	cf 71       	brne	80004c34 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c48:	30 4b       	mov	r11,4
80004c4a:	33 2c       	mov	r12,50
80004c4c:	f0 1f 00 21 	mcall	80004cd0 <xnl_init+0xe4>
80004c50:	4a 78       	lddpc	r8,80004cec <xnl_init+0x100>
80004c52:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c54:	30 4b       	mov	r11,4
80004c56:	32 8c       	mov	r12,40
80004c58:	f0 1f 00 1e 	mcall	80004cd0 <xnl_init+0xe4>
80004c5c:	4a 58       	lddpc	r8,80004cf0 <xnl_init+0x104>
80004c5e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004c60:	30 4b       	mov	r11,4
80004c62:	30 ac       	mov	r12,10
80004c64:	f0 1f 00 1b 	mcall	80004cd0 <xnl_init+0xe4>
80004c68:	4a 38       	lddpc	r8,80004cf4 <xnl_init+0x108>
80004c6a:	91 0c       	st.w	r8[0x0],r12
80004c6c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004c6e:	10 96       	mov	r6,r8
80004c70:	4a 25       	lddpc	r5,80004cf8 <xnl_init+0x10c>
80004c72:	6c 0c       	ld.w	r12,r6[0x0]
80004c74:	ea 07 00 0b 	add	r11,r5,r7
80004c78:	f0 1f 00 1c 	mcall	80004ce8 <xnl_init+0xfc>
80004c7c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004c80:	e0 47 14 00 	cp.w	r7,5120
80004c84:	cf 71       	brne	80004c72 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c86:	30 4b       	mov	r11,4
80004c88:	30 5c       	mov	r12,5
80004c8a:	f0 1f 00 12 	mcall	80004cd0 <xnl_init+0xe4>
80004c8e:	49 c8       	lddpc	r8,80004cfc <xnl_init+0x110>
80004c90:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004c92:	30 07       	mov	r7,0
80004c94:	1a d7       	st.w	--sp,r7
80004c96:	1a d7       	st.w	--sp,r7
80004c98:	1a d7       	st.w	--sp,r7
80004c9a:	30 38       	mov	r8,3
80004c9c:	0e 99       	mov	r9,r7
80004c9e:	e0 6a 00 dc 	mov	r10,220
80004ca2:	49 8b       	lddpc	r11,80004d00 <xnl_init+0x114>
80004ca4:	49 8c       	lddpc	r12,80004d04 <xnl_init+0x118>
80004ca6:	f0 1f 00 19 	mcall	80004d08 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004caa:	1a d7       	st.w	--sp,r7
80004cac:	1a d7       	st.w	--sp,r7
80004cae:	1a d7       	st.w	--sp,r7
80004cb0:	30 38       	mov	r8,3
80004cb2:	0e 99       	mov	r9,r7
80004cb4:	e0 6a 00 82 	mov	r10,130
80004cb8:	49 5b       	lddpc	r11,80004d0c <xnl_init+0x120>
80004cba:	49 6c       	lddpc	r12,80004d10 <xnl_init+0x124>
80004cbc:	f0 1f 00 13 	mcall	80004d08 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004cc0:	f0 1f 00 15 	mcall	80004d14 <xnl_init+0x128>
80004cc4:	2f ad       	sub	sp,-24
}
80004cc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004cca:	00 00       	add	r0,r0
80004ccc:	00 00       	add	r0,r0
80004cce:	0b 62       	ld.uh	r2,--r5
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	74 88       	ld.w	r8,r10[0x20]
80004cd4:	00 00       	add	r0,r0
80004cd6:	0b 5c       	ld.sh	r12,--r5
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	73 30       	ld.w	r0,r9[0x4c]
80004cdc:	00 00       	add	r0,r0
80004cde:	0b 70       	ld.ub	r0,--r5
80004ce0:	00 00       	add	r0,r0
80004ce2:	0a c0       	st.b	r5++,r0
80004ce4:	00 00       	add	r0,r0
80004ce6:	33 4e       	mov	lr,52
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	35 50       	mov	r0,85
80004cec:	00 00       	add	r0,r0
80004cee:	0a f0       	st.b	--r5,r0
80004cf0:	00 00       	add	r0,r0
80004cf2:	0a d0       	st.w	--r5,r0
80004cf4:	00 00       	add	r0,r0
80004cf6:	0a c4       	st.b	r5++,r4
80004cf8:	00 00       	add	r0,r0
80004cfa:	1f 4e       	ld.w	lr,--pc
80004cfc:	00 00       	add	r0,r0
80004cfe:	0a fc       	st.b	--r5,r12
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	e9 dc 80 00 	ldswp.w	r12,r4[0]
80004d06:	4d 18       	lddpc	r8,80004e48 <xnl_tx+0x4>
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	7b a4       	ld.w	r4,sp[0x68]
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	e9 e4 80 00 	sthh.w	r0[r0],r4:b,r4:b
80004d12:	4d 78       	lddpc	r8,80004e6c <xnl_tx+0x28>
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	37 24       	mov	r4,114

80004d18 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004d18:	eb cd 40 fe 	pushm	r1-r7,lr
80004d1c:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d1e:	49 26       	lddpc	r6,80004d64 <xnl_rx_process+0x4c>
80004d20:	30 05       	mov	r5,0
80004d22:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d24:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d26:	49 11       	lddpc	r1,80004d68 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d28:	49 12       	lddpc	r2,80004d6c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d2a:	6c 0c       	ld.w	r12,r6[0x0]
80004d2c:	0a 99       	mov	r9,r5
80004d2e:	08 9a       	mov	r10,r4
80004d30:	1a 9b       	mov	r11,sp
80004d32:	f0 1f 00 10 	mcall	80004d70 <xnl_rx_process+0x58>
80004d36:	58 1c       	cp.w	r12,1
80004d38:	cf 91       	brne	80004d2a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004d3a:	40 0c       	lddsp	r12,sp[0x0]
80004d3c:	58 0c       	cp.w	r12,0
80004d3e:	cf 60       	breq	80004d2a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d40:	98 28       	ld.sh	r8,r12[0x4]
80004d42:	e6 08 19 00 	cp.h	r8,r3
80004d46:	e0 8b 00 0a 	brhi	80004d5a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d4a:	5c 78       	castu.h	r8
80004d4c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004d50:	58 09       	cp.w	r9,0
80004d52:	c0 40       	breq	80004d5a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004d54:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004d58:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d5a:	62 0c       	ld.w	r12,r1[0x0]
80004d5c:	40 0b       	lddsp	r11,sp[0x0]
80004d5e:	f0 1f 00 06 	mcall	80004d74 <xnl_rx_process+0x5c>
80004d62:	ce 4b       	rjmp	80004d2a <xnl_rx_process+0x12>
80004d64:	00 00       	add	r0,r0
80004d66:	0a d0       	st.w	--r5,r0
80004d68:	00 00       	add	r0,r0
80004d6a:	0a c0       	st.b	r5++,r0
80004d6c:	00 00       	add	r0,r0
80004d6e:	05 00       	ld.w	r0,r2++
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	71 24       	ld.w	r4,r8[0x48]
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	35 50       	mov	r0,85

80004d78 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004d78:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d7a:	4a a6       	lddpc	r6,80004e20 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d7c:	4a a2       	lddpc	r2,80004e24 <xnl_tx_process+0xac>
80004d7e:	4a b4       	lddpc	r4,80004e28 <xnl_tx_process+0xb0>
80004d80:	30 07       	mov	r7,0
80004d82:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004d84:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004d86:	4a a5       	lddpc	r5,80004e2c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004d88:	4a a3       	lddpc	r3,80004e30 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d8a:	6c 08       	ld.w	r8,r6[0x0]
80004d8c:	58 08       	cp.w	r8,0
80004d8e:	c0 40       	breq	80004d96 <xnl_tx_process+0x1e>
80004d90:	58 18       	cp.w	r8,1
80004d92:	cf d1       	brne	80004d8c <xnl_tx_process+0x14>
80004d94:	c2 48       	rjmp	80004ddc <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d96:	64 0c       	ld.w	r12,r2[0x0]
80004d98:	0e 99       	mov	r9,r7
80004d9a:	02 9a       	mov	r10,r1
80004d9c:	08 9b       	mov	r11,r4
80004d9e:	f0 1f 00 26 	mcall	80004e34 <xnl_tx_process+0xbc>
80004da2:	58 1c       	cp.w	r12,1
80004da4:	cf 31       	brne	80004d8a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004da6:	68 0b       	ld.w	r11,r4[0x0]
80004da8:	58 0b       	cp.w	r11,0
80004daa:	cf 00       	breq	80004d8a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004dac:	96 28       	ld.sh	r8,r11[0x4]
80004dae:	e0 08 19 00 	cp.h	r8,r0
80004db2:	c0 71       	brne	80004dc0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004db4:	4a 18       	lddpc	r8,80004e38 <xnl_tx_process+0xc0>
80004db6:	70 08       	ld.w	r8,r8[0x0]
80004db8:	10 9c       	mov	r12,r8
80004dba:	f0 1f 00 21 	mcall	80004e3c <xnl_tx_process+0xc4>
						break;
80004dbe:	ce 6b       	rjmp	80004d8a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004dc0:	16 9c       	mov	r12,r11
80004dc2:	f0 1f 00 20 	mcall	80004e40 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004dc6:	30 18       	mov	r8,1
80004dc8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004dca:	66 0c       	ld.w	r12,r3[0x0]
80004dcc:	0e 99       	mov	r9,r7
80004dce:	0e 9a       	mov	r10,r7
80004dd0:	0e 9b       	mov	r11,r7
80004dd2:	f0 1f 00 19 	mcall	80004e34 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004dd6:	30 18       	mov	r8,1
80004dd8:	8d 08       	st.w	r6[0x0],r8
80004dda:	cd 8b       	rjmp	80004d8a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004ddc:	66 0c       	ld.w	r12,r3[0x0]
80004dde:	0e 99       	mov	r9,r7
80004de0:	36 4a       	mov	r10,100
80004de2:	0e 9b       	mov	r11,r7
80004de4:	f0 1f 00 14 	mcall	80004e34 <xnl_tx_process+0xbc>
80004de8:	58 1c       	cp.w	r12,1
80004dea:	c0 81       	brne	80004dfa <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004dec:	49 38       	lddpc	r8,80004e38 <xnl_tx_process+0xc0>
80004dee:	70 0c       	ld.w	r12,r8[0x0]
80004df0:	68 0b       	ld.w	r11,r4[0x0]
80004df2:	f0 1f 00 13 	mcall	80004e3c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004df6:	8d 07       	st.w	r6[0x0],r7
80004df8:	cc 9b       	rjmp	80004d8a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004dfa:	6a 08       	ld.w	r8,r5[0x0]
80004dfc:	58 38       	cp.w	r8,3
80004dfe:	e0 89 00 09 	brgt	80004e10 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004e02:	68 0c       	ld.w	r12,r4[0x0]
80004e04:	f0 1f 00 0f 	mcall	80004e40 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004e08:	6a 08       	ld.w	r8,r5[0x0]
80004e0a:	2f f8       	sub	r8,-1
80004e0c:	8b 08       	st.w	r5[0x0],r8
80004e0e:	cb eb       	rjmp	80004d8a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004e10:	48 a8       	lddpc	r8,80004e38 <xnl_tx_process+0xc0>
80004e12:	70 0c       	ld.w	r12,r8[0x0]
80004e14:	68 0b       	ld.w	r11,r4[0x0]
80004e16:	f0 1f 00 0a 	mcall	80004e3c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004e1a:	8d 07       	st.w	r6[0x0],r7
80004e1c:	cb 7b       	rjmp	80004d8a <xnl_tx_process+0x12>
80004e1e:	00 00       	add	r0,r0
80004e20:	00 00       	add	r0,r0
80004e22:	0b 6c       	ld.uh	r12,--r5
80004e24:	00 00       	add	r0,r0
80004e26:	0b 70       	ld.ub	r0,--r5
80004e28:	00 00       	add	r0,r0
80004e2a:	0b 78       	ld.ub	r8,--r5
80004e2c:	00 00       	add	r0,r0
80004e2e:	0b 74       	ld.ub	r4,--r5
80004e30:	00 00       	add	r0,r0
80004e32:	0b 5c       	ld.sh	r12,--r5
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	71 24       	ld.w	r4,r8[0x48]
80004e38:	00 00       	add	r0,r0
80004e3a:	0a c0       	st.b	r5++,r0
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	35 50       	mov	r0,85
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	35 70       	mov	r0,87

80004e44 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004e44:	eb cd 40 c0 	pushm	r6-r7,lr
80004e48:	20 1d       	sub	sp,4
80004e4a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004e4c:	98 39       	ld.sh	r9,r12[0x6]
80004e4e:	3f f8       	mov	r8,-1
80004e50:	f0 09 19 00 	cp.h	r9,r8
80004e54:	c0 a1       	brne	80004e68 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004e56:	4a e9       	lddpc	r9,80004f0c <xnl_tx+0xc8>
80004e58:	13 88       	ld.ub	r8,r9[0x0]
80004e5a:	2f f8       	sub	r8,-1
80004e5c:	5c 58       	castu.b	r8
80004e5e:	b2 88       	st.b	r9[0x0],r8
80004e60:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004e64:	a9 a8       	sbr	r8,0x8
80004e66:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004e68:	8c 49       	ld.sh	r9,r6[0x8]
80004e6a:	3f f8       	mov	r8,-1
80004e6c:	f0 09 19 00 	cp.h	r9,r8
80004e70:	c0 41       	brne	80004e78 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004e72:	4a 88       	lddpc	r8,80004f10 <xnl_tx+0xcc>
80004e74:	90 18       	ld.sh	r8,r8[0x2]
80004e76:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004e78:	8c 59       	ld.sh	r9,r6[0xa]
80004e7a:	3f f8       	mov	r8,-1
80004e7c:	f0 09 19 00 	cp.h	r9,r8
80004e80:	c0 41       	brne	80004e88 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004e82:	4a 48       	lddpc	r8,80004f10 <xnl_tx+0xcc>
80004e84:	90 28       	ld.sh	r8,r8[0x4]
80004e86:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004e88:	8c 69       	ld.sh	r9,r6[0xc]
80004e8a:	3f f8       	mov	r8,-1
80004e8c:	f0 09 19 00 	cp.h	r9,r8
80004e90:	c0 e1       	brne	80004eac <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e92:	4a 08       	lddpc	r8,80004f10 <xnl_tx+0xcc>
80004e94:	90 49       	ld.sh	r9,r8[0x8]
80004e96:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e98:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e9a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e9c:	90 49       	ld.sh	r9,r8[0x8]
80004e9e:	e0 19 ff 00 	andl	r9,0xff00
80004ea2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004ea6:	f3 e8 10 08 	or	r8,r9,r8
80004eaa:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004eac:	0d 98       	ld.ub	r8,r6[0x1]
80004eae:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004eb0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004eb4:	10 0c       	add	r12,r8
80004eb6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004eb8:	58 0c       	cp.w	r12,0
80004eba:	e0 89 00 04 	brgt	80004ec2 <xnl_tx+0x7e>
80004ebe:	30 09       	mov	r9,0
80004ec0:	c0 d8       	rjmp	80004eda <xnl_tx+0x96>
80004ec2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004ec6:	2f ec       	sub	r12,-2
80004ec8:	30 09       	mov	r9,0
80004eca:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004ecc:	15 1b       	ld.sh	r11,r10++
80004ece:	f6 09 00 09 	add	r9,r11,r9
80004ed2:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004ed4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004ed6:	18 38       	cp.w	r8,r12
80004ed8:	cf a1       	brne	80004ecc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004eda:	5c 39       	neg	r9
80004edc:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004ede:	48 e8       	lddpc	r8,80004f14 <xnl_tx+0xd0>
80004ee0:	70 0c       	ld.w	r12,r8[0x0]
80004ee2:	f0 1f 00 0e 	mcall	80004f18 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004ee6:	c1 00       	breq	80004f06 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004ee8:	fa c7 ff fc 	sub	r7,sp,-4
80004eec:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004eee:	e0 6a 01 00 	mov	r10,256
80004ef2:	0c 9b       	mov	r11,r6
80004ef4:	f0 1f 00 0a 	mcall	80004f1c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004ef8:	48 a8       	lddpc	r8,80004f20 <xnl_tx+0xdc>
80004efa:	70 0c       	ld.w	r12,r8[0x0]
80004efc:	30 09       	mov	r9,0
80004efe:	12 9a       	mov	r10,r9
80004f00:	1a 9b       	mov	r11,sp
80004f02:	f0 1f 00 09 	mcall	80004f24 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004f06:	2f fd       	sub	sp,-4
80004f08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f0c:	00 00       	add	r0,r0
80004f0e:	0b 60       	ld.uh	r0,--r5
80004f10:	00 00       	add	r0,r0
80004f12:	0b 62       	ld.uh	r2,--r5
80004f14:	00 00       	add	r0,r0
80004f16:	0a c0       	st.b	r5++,r0
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	36 fc       	mov	r12,111
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	88 12       	ld.sh	r2,r4[0x2]
80004f20:	00 00       	add	r0,r0
80004f22:	0b 70       	ld.ub	r0,--r5
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	73 30       	ld.w	r0,r9[0x4c]

80004f28 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004f28:	eb cd 40 80 	pushm	r7,lr
80004f2c:	fa cd 01 00 	sub	sp,sp,256
80004f30:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f32:	e0 68 40 0e 	mov	r8,16398
80004f36:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f38:	3f f8       	mov	r8,-1
80004f3a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004f3c:	30 c8       	mov	r8,12
80004f3e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004f40:	98 38       	ld.sh	r8,r12[0x6]
80004f42:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004f44:	98 58       	ld.sh	r8,r12[0xa]
80004f46:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004f48:	98 48       	ld.sh	r8,r12[0x8]
80004f4a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004f4c:	98 68       	ld.sh	r8,r12[0xc]
80004f4e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004f50:	30 08       	mov	r8,0
80004f52:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004f54:	1a 9c       	mov	r12,sp
80004f56:	f0 1f 00 0a 	mcall	80004f7c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004f5a:	fa cd 00 cc 	sub	sp,sp,204
80004f5e:	e0 6a 00 ca 	mov	r10,202
80004f62:	ee cb ff f0 	sub	r11,r7,-16
80004f66:	1a 9c       	mov	r12,sp
80004f68:	f0 1f 00 06 	mcall	80004f80 <xnl_data_msg_func+0x58>
80004f6c:	48 68       	lddpc	r8,80004f84 <xnl_data_msg_func+0x5c>
80004f6e:	70 08       	ld.w	r8,r8[0x0]
80004f70:	5d 18       	icall	r8
80004f72:	fa cd ff 34 	sub	sp,sp,-204
}
80004f76:	2c 0d       	sub	sp,-256
80004f78:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4e 44       	lddpc	r4,8000510c <xnl_device_conn_reply_func+0x4>
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	88 12       	ld.sh	r2,r4[0x2]
80004f84:	00 00       	add	r0,r0
80004f86:	0b 7c       	ld.ub	r12,--r5

80004f88 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004f88:	d4 21       	pushm	r4-r7,lr
80004f8a:	fa cd 01 00 	sub	sp,sp,256
80004f8e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004f90:	4c 28       	lddpc	r8,80005098 <xnl_device_auth_reply_func+0x110>
80004f92:	11 88       	ld.ub	r8,r8[0x0]
80004f94:	58 08       	cp.w	r8,0
80004f96:	e0 81 00 7f 	brne	80005094 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004f9a:	4c 18       	lddpc	r8,8000509c <xnl_device_auth_reply_func+0x114>
80004f9c:	70 0c       	ld.w	r12,r8[0x0]
80004f9e:	30 09       	mov	r9,0
80004fa0:	12 9a       	mov	r10,r9
80004fa2:	12 9b       	mov	r11,r9
80004fa4:	f0 1f 00 3f 	mcall	800050a0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004fa8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004fac:	4b b8       	lddpc	r8,80005098 <xnl_device_auth_reply_func+0x110>
80004fae:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004fb0:	ef 39 00 12 	ld.ub	r9,r7[18]
80004fb4:	ef 38 00 13 	ld.ub	r8,r7[19]
80004fb8:	b1 68       	lsl	r8,0x10
80004fba:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004fbe:	ef 38 00 15 	ld.ub	r8,r7[21]
80004fc2:	f3 e8 10 08 	or	r8,r9,r8
80004fc6:	ef 39 00 14 	ld.ub	r9,r7[20]
80004fca:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004fce:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004fd2:	ef 38 00 17 	ld.ub	r8,r7[23]
80004fd6:	b1 68       	lsl	r8,0x10
80004fd8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004fdc:	ef 38 00 19 	ld.ub	r8,r7[25]
80004fe0:	f5 e8 10 08 	or	r8,r10,r8
80004fe4:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004fe8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004fec:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004fee:	e0 64 79 b9 	mov	r4,31161
80004ff2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004ff6:	e0 65 45 07 	mov	r5,17671
80004ffa:	ea 15 8a bd 	orh	r5,0x8abd
80004ffe:	e0 66 f9 3d 	mov	r6,63805
80005002:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005006:	e0 6e b8 cf 	mov	lr,47311
8000500a:	ea 1e 36 83 	orh	lr,0x3683
8000500e:	e0 67 aa 1c 	mov	r7,43548
80005012:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005016:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005018:	f4 08 00 0c 	add	r12,r10,r8
8000501c:	f0 0b 15 04 	lsl	r11,r8,0x4
80005020:	0a 0b       	add	r11,r5
80005022:	f9 eb 20 0b 	eor	r11,r12,r11
80005026:	f0 0c 16 05 	lsr	r12,r8,0x5
8000502a:	0c 0c       	add	r12,r6
8000502c:	18 5b       	eor	r11,r12
8000502e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005030:	f2 0c 15 04 	lsl	r12,r9,0x4
80005034:	1c 0c       	add	r12,lr
80005036:	f2 0b 16 05 	lsr	r11,r9,0x5
8000503a:	0e 0b       	add	r11,r7
8000503c:	f9 eb 20 0b 	eor	r11,r12,r11
80005040:	f2 0a 00 0c 	add	r12,r9,r10
80005044:	18 5b       	eor	r11,r12
80005046:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005048:	e0 6b 37 20 	mov	r11,14112
8000504c:	ea 1b c6 ef 	orh	r11,0xc6ef
80005050:	16 3a       	cp.w	r10,r11
80005052:	ce 21       	brne	80005016 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005054:	e0 6a 40 1a 	mov	r10,16410
80005058:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000505a:	3f fa       	mov	r10,-1
8000505c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000505e:	30 6b       	mov	r11,6
80005060:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005062:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005064:	48 db       	lddpc	r11,80005098 <xnl_device_auth_reply_func+0x110>
80005066:	96 1c       	ld.sh	r12,r11[0x2]
80005068:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000506a:	96 2b       	ld.sh	r11,r11[0x4]
8000506c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000506e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80005070:	30 ca       	mov	r10,12
80005072:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005074:	30 0a       	mov	r10,0
80005076:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000507a:	30 7a       	mov	r10,7
8000507c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80005080:	30 2a       	mov	r10,2
80005082:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005086:	fa ca ff ec 	sub	r10,sp,-20
8000508a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000508c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000508e:	1a 9c       	mov	r12,sp
80005090:	f0 1f 00 05 	mcall	800050a4 <xnl_device_auth_reply_func+0x11c>
}
80005094:	2c 0d       	sub	sp,-256
80005096:	d8 22       	popm	r4-r7,pc
80005098:	00 00       	add	r0,r0
8000509a:	0b 62       	ld.uh	r2,--r5
8000509c:	00 00       	add	r0,r0
8000509e:	0b 5c       	ld.sh	r12,--r5
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	73 30       	ld.w	r0,r9[0x4c]
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	4e 44       	lddpc	r4,80005234 <WriteRawRC+0x10>

800050a8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800050a8:	eb cd 40 80 	pushm	r7,lr
800050ac:	fa cd 01 00 	sub	sp,sp,256
800050b0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800050b2:	49 28       	lddpc	r8,800050f8 <xnl_master_status_brdcst_func+0x50>
800050b4:	11 88       	ld.ub	r8,r8[0x0]
800050b6:	58 08       	cp.w	r8,0
800050b8:	c1 c1       	brne	800050f0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800050ba:	49 18       	lddpc	r8,800050fc <xnl_master_status_brdcst_func+0x54>
800050bc:	70 0c       	ld.w	r12,r8[0x0]
800050be:	30 09       	mov	r9,0
800050c0:	12 9a       	mov	r10,r9
800050c2:	12 9b       	mov	r11,r9
800050c4:	f0 1f 00 0f 	mcall	80005100 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800050c8:	8e 58       	ld.sh	r8,r7[0xa]
800050ca:	48 c9       	lddpc	r9,800050f8 <xnl_master_status_brdcst_func+0x50>
800050cc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800050ce:	e0 68 40 0e 	mov	r8,16398
800050d2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050d4:	3f f8       	mov	r8,-1
800050d6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800050d8:	30 4a       	mov	r10,4
800050da:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800050dc:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800050de:	92 19       	ld.sh	r9,r9[0x2]
800050e0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800050e2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050e4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800050e6:	30 08       	mov	r8,0
800050e8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800050ea:	1a 9c       	mov	r12,sp
800050ec:	f0 1f 00 06 	mcall	80005104 <xnl_master_status_brdcst_func+0x5c>
}
800050f0:	2c 0d       	sub	sp,-256
800050f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800050f6:	00 00       	add	r0,r0
800050f8:	00 00       	add	r0,r0
800050fa:	0b 62       	ld.uh	r2,--r5
800050fc:	00 00       	add	r0,r0
800050fe:	0b 5c       	ld.sh	r12,--r5
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	73 30       	ld.w	r0,r9[0x4c]
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	4e 44       	lddpc	r4,80005294 <PcdReset+0x30>

80005108 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005108:	eb cd 40 80 	pushm	r7,lr
8000510c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000510e:	49 28       	lddpc	r8,80005154 <xnl_device_conn_reply_func+0x4c>
80005110:	70 0c       	ld.w	r12,r8[0x0]
80005112:	30 09       	mov	r9,0
80005114:	12 9a       	mov	r10,r9
80005116:	12 9b       	mov	r11,r9
80005118:	f0 1f 00 10 	mcall	80005158 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000511c:	ef 18 00 10 	ld.uh	r8,r7[16]
80005120:	10 99       	mov	r9,r8
80005122:	e2 19 ff 00 	andl	r9,0xff00,COH
80005126:	e0 49 01 00 	cp.w	r9,256
8000512a:	c0 60       	breq	80005136 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000512c:	0e 9c       	mov	r12,r7
8000512e:	f0 1f 00 0c 	mcall	8000515c <xnl_device_conn_reply_func+0x54>
80005132:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005136:	a9 68       	lsl	r8,0x8
80005138:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000513c:	48 98       	lddpc	r8,80005160 <xnl_device_conn_reply_func+0x58>
8000513e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005140:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005144:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80005146:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000514a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000514c:	30 19       	mov	r9,1
8000514e:	b0 89       	st.b	r8[0x0],r9
80005150:	e3 cd 80 80 	ldm	sp++,r7,pc
80005154:	00 00       	add	r0,r0
80005156:	0b 5c       	ld.sh	r12,--r5
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	73 30       	ld.w	r0,r9[0x4c]
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	50 a8       	stdsp	sp[0x28],r8
80005160:	00 00       	add	r0,r0
80005162:	0b 62       	ld.uh	r2,--r5

80005164 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80005164:	d4 01       	pushm	lr
80005166:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000516a:	e0 68 40 0e 	mov	r8,16398
8000516e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005170:	3f f8       	mov	r8,-1
80005172:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005174:	30 38       	mov	r8,3
80005176:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005178:	30 08       	mov	r8,0
8000517a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000517c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000517e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005180:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005182:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005184:	1a 9c       	mov	r12,sp
80005186:	f0 1f 00 03 	mcall	80005190 <xnl_send_device_master_query+0x2c>
}
8000518a:	2c 0d       	sub	sp,-256
8000518c:	d8 02       	popm	pc
8000518e:	00 00       	add	r0,r0
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	4e 44       	lddpc	r4,80005320 <ReadRawRC+0x3c>

80005194 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80005194:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80005196:	48 78       	lddpc	r8,800051b0 <RC522_SPI_SetSpeed+0x1c>
80005198:	70 09       	ld.w	r9,r8[0x0]
8000519a:	72 ca       	ld.w	r10,r9[0x30]
8000519c:	5c 7c       	castu.h	r12
8000519e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800051a2:	f9 ea 10 0a 	or	r10,r12,r10
800051a6:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800051a8:	70 0c       	ld.w	r12,r8[0x0]
800051aa:	f0 1f 00 03 	mcall	800051b4 <RC522_SPI_SetSpeed+0x20>
		
	
}
800051ae:	d8 02       	popm	pc
800051b0:	00 00       	add	r0,r0
800051b2:	1e 28       	rsub	r8,pc
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	68 20       	ld.w	r0,r4[0x8]

800051b8 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800051b8:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800051ba:	e0 6c 0a 00 	mov	r12,2560
800051be:	f0 1f 00 02 	mcall	800051c4 <RC522_SPI_SetSpeedLow+0xc>
	
}
800051c2:	d8 02       	popm	pc
800051c4:	80 00       	ld.sh	r0,r0[0x0]
800051c6:	51 94       	stdsp	sp[0x64],r4

800051c8 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800051c8:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800051cc:	48 76       	lddpc	r6,800051e8 <RC522_ReadByte+0x20>
800051ce:	e0 6b 00 ff 	mov	r11,255
800051d2:	6c 0c       	ld.w	r12,r6[0x0]
800051d4:	f0 1f 00 06 	mcall	800051ec <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800051d8:	30 07       	mov	r7,0
800051da:	0e 9b       	mov	r11,r7
800051dc:	6c 0c       	ld.w	r12,r6[0x0]
800051de:	f0 1f 00 05 	mcall	800051f0 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800051e2:	0f 9c       	ld.ub	r12,r7[0x1]
800051e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051e8:	00 00       	add	r0,r0
800051ea:	1e 28       	rsub	r8,pc
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	68 26       	ld.w	r6,r4[0x8]
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	68 42       	ld.w	r2,r4[0x10]

800051f4 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800051f4:	eb cd 40 80 	pushm	r7,lr
800051f8:	20 1d       	sub	sp,4
800051fa:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800051fc:	48 77       	lddpc	r7,80005218 <RC522_WriteByte+0x24>
800051fe:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80005202:	6e 0c       	ld.w	r12,r7[0x0]
80005204:	f0 1f 00 06 	mcall	8000521c <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80005208:	1a 9b       	mov	r11,sp
8000520a:	6e 0c       	ld.w	r12,r7[0x0]
8000520c:	f0 1f 00 05 	mcall	80005220 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80005210:	5c 5c       	castu.b	r12
80005212:	2f fd       	sub	sp,-4
80005214:	e3 cd 80 80 	ldm	sp++,r7,pc
80005218:	00 00       	add	r0,r0
8000521a:	1e 28       	rsub	r8,pc
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	68 26       	ld.w	r6,r4[0x8]
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	68 42       	ld.w	r2,r4[0x10]

80005224 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005224:	eb cd 40 e0 	pushm	r5-r7,lr
80005228:	18 96       	mov	r6,r12
8000522a:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000522c:	48 a7       	lddpc	r7,80005254 <WriteRawRC+0x30>
8000522e:	30 0b       	mov	r11,0
80005230:	6e 0c       	ld.w	r12,r7[0x0]
80005232:	f0 1f 00 0a 	mcall	80005258 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80005236:	ec 0c 15 01 	lsl	r12,r6,0x1
8000523a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000523e:	f0 1f 00 08 	mcall	8000525c <WriteRawRC+0x38>
	RC522_WriteByte(value);
80005242:	0a 9c       	mov	r12,r5
80005244:	f0 1f 00 06 	mcall	8000525c <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80005248:	30 0b       	mov	r11,0
8000524a:	6e 0c       	ld.w	r12,r7[0x0]
8000524c:	f0 1f 00 05 	mcall	80005260 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80005250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005254:	00 00       	add	r0,r0
80005256:	1e 28       	rsub	r8,pc
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	69 8c       	ld.w	r12,r4[0x60]
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	51 f4       	stdsp	sp[0x7c],r4
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	69 4c       	ld.w	r12,r4[0x50]

80005264 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80005264:	d4 01       	pushm	lr

	SET_RC522RST;
80005266:	31 9c       	mov	r12,25
80005268:	f0 1f 00 1b 	mcall	800052d4 <PcdReset+0x70>
	delay_ns(10);
8000526c:	30 ac       	mov	r12,10
8000526e:	f0 1f 00 1b 	mcall	800052d8 <PcdReset+0x74>

	CLR_RC522RST;
80005272:	31 9c       	mov	r12,25
80005274:	f0 1f 00 1a 	mcall	800052dc <PcdReset+0x78>
	delay_ns(10);
80005278:	30 ac       	mov	r12,10
8000527a:	f0 1f 00 18 	mcall	800052d8 <PcdReset+0x74>

	SET_RC522RST;
8000527e:	31 9c       	mov	r12,25
80005280:	f0 1f 00 15 	mcall	800052d4 <PcdReset+0x70>
	delay_ns(10);
80005284:	30 ac       	mov	r12,10
80005286:	f0 1f 00 15 	mcall	800052d8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000528a:	30 fb       	mov	r11,15
8000528c:	30 1c       	mov	r12,1
8000528e:	f0 1f 00 15 	mcall	800052e0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80005292:	30 fb       	mov	r11,15
80005294:	30 1c       	mov	r12,1
80005296:	f0 1f 00 13 	mcall	800052e0 <PcdReset+0x7c>
	delay_ns(10);
8000529a:	30 ac       	mov	r12,10
8000529c:	f0 1f 00 0f 	mcall	800052d8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800052a0:	33 db       	mov	r11,61
800052a2:	31 1c       	mov	r12,17
800052a4:	f0 1f 00 0f 	mcall	800052e0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800052a8:	31 eb       	mov	r11,30
800052aa:	32 dc       	mov	r12,45
800052ac:	f0 1f 00 0d 	mcall	800052e0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800052b0:	30 0b       	mov	r11,0
800052b2:	32 cc       	mov	r12,44
800052b4:	f0 1f 00 0b 	mcall	800052e0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800052b8:	e0 6b 00 8d 	mov	r11,141
800052bc:	32 ac       	mov	r12,42
800052be:	f0 1f 00 09 	mcall	800052e0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800052c2:	33 eb       	mov	r11,62
800052c4:	32 bc       	mov	r12,43
800052c6:	f0 1f 00 07 	mcall	800052e0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800052ca:	34 0b       	mov	r11,64
800052cc:	31 5c       	mov	r12,21
800052ce:	f0 1f 00 05 	mcall	800052e0 <PcdReset+0x7c>
	
	return MI_OK;
}
800052d2:	d8 0a       	popm	pc,r12=0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	63 94       	ld.w	r4,r1[0x64]
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	5b fc       	cp.w	r12,-1
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	63 b0       	ld.w	r0,r1[0x6c]
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	52 24       	stdsp	sp[0x88],r4

800052e4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800052e4:	eb cd 40 c0 	pushm	r6-r7,lr
800052e8:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800052ea:	48 c7       	lddpc	r7,80005318 <ReadRawRC+0x34>
800052ec:	30 0b       	mov	r11,0
800052ee:	6e 0c       	ld.w	r12,r7[0x0]
800052f0:	f0 1f 00 0b 	mcall	8000531c <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800052f4:	a1 76       	lsl	r6,0x1
800052f6:	0c 9c       	mov	r12,r6
800052f8:	e2 1c 00 7e 	andl	r12,0x7e,COH
800052fc:	a7 bc       	sbr	r12,0x7
800052fe:	f0 1f 00 09 	mcall	80005320 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80005302:	f0 1f 00 09 	mcall	80005324 <ReadRawRC+0x40>
80005306:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80005308:	30 0b       	mov	r11,0
8000530a:	6e 0c       	ld.w	r12,r7[0x0]
8000530c:	f0 1f 00 07 	mcall	80005328 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80005310:	0c 9c       	mov	r12,r6
80005312:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005316:	00 00       	add	r0,r0
80005318:	00 00       	add	r0,r0
8000531a:	1e 28       	rsub	r8,pc
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	69 8c       	ld.w	r12,r4[0x60]
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	51 f4       	stdsp	sp[0x7c],r4
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	51 c8       	stdsp	sp[0x70],r8
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	69 4c       	ld.w	r12,r4[0x50]

8000532c <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
8000532c:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
8000532e:	30 1c       	mov	r12,1
80005330:	f0 1f 00 02 	mcall	80005338 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005334:	d8 02       	popm	pc
80005336:	00 00       	add	r0,r0
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	52 e4       	stdsp	sp[0xb8],r4

8000533c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
8000533c:	eb cd 40 80 	pushm	r7,lr
80005340:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005342:	30 1c       	mov	r12,1
80005344:	f0 1f 00 0d 	mcall	80005378 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80005348:	30 18       	mov	r8,1
8000534a:	f0 07 18 00 	cp.b	r7,r8
8000534e:	c0 91       	brne	80005360 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80005350:	18 9b       	mov	r11,r12
80005352:	a5 ab       	sbr	r11,0x4
80005354:	5c 5b       	castu.b	r11
80005356:	30 1c       	mov	r12,1
80005358:	f0 1f 00 09 	mcall	8000537c <Powerdown_RC522+0x40>
8000535c:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80005360:	18 9b       	mov	r11,r12
80005362:	30 1c       	mov	r12,1
80005364:	f0 1f 00 06 	mcall	8000537c <Powerdown_RC522+0x40>
		delay_ns(2);
80005368:	30 2c       	mov	r12,2
8000536a:	f0 1f 00 06 	mcall	80005380 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
8000536e:	f0 1f 00 06 	mcall	80005384 <Powerdown_RC522+0x48>
80005372:	e3 cd 80 80 	ldm	sp++,r7,pc
80005376:	00 00       	add	r0,r0
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	52 e4       	stdsp	sp[0xb8],r4
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	52 24       	stdsp	sp[0x88],r4
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	5b fc       	cp.w	r12,-1
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	53 2c       	stdsp	sp[0xc8],r12

80005388 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80005388:	eb cd 40 c0 	pushm	r6-r7,lr
8000538c:	18 97       	mov	r7,r12
8000538e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80005390:	f0 1f 00 05 	mcall	800053a4 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005394:	f9 e6 10 0b 	or	r11,r12,r6
80005398:	5c 5b       	castu.b	r11
8000539a:	0e 9c       	mov	r12,r7
8000539c:	f0 1f 00 03 	mcall	800053a8 <SetBitMask+0x20>
}
800053a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	52 e4       	stdsp	sp[0xb8],r4
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	52 24       	stdsp	sp[0x88],r4

800053ac <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800053ac:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800053ae:	31 4c       	mov	r12,20
800053b0:	f0 1f 00 05 	mcall	800053c4 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800053b4:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800053b8:	c0 51       	brne	800053c2 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800053ba:	30 3b       	mov	r11,3
800053bc:	31 4c       	mov	r12,20
800053be:	f0 1f 00 03 	mcall	800053c8 <PcdAntennaOn+0x1c>
800053c2:	d8 02       	popm	pc
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	52 e4       	stdsp	sp[0xb8],r4
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	53 88       	stdsp	sp[0xe0],r8

800053cc <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800053cc:	eb cd 40 c0 	pushm	r6-r7,lr
800053d0:	18 97       	mov	r7,r12
800053d2:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800053d4:	f0 1f 00 06 	mcall	800053ec <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800053d8:	5c d6       	com	r6
800053da:	f9 e6 00 06 	and	r6,r12,r6
800053de:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800053e2:	0e 9c       	mov	r12,r7
800053e4:	f0 1f 00 03 	mcall	800053f0 <ClearBitMask+0x24>
	
}
800053e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	52 e4       	stdsp	sp[0xb8],r4
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	52 24       	stdsp	sp[0x88],r4

800053f4 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800053f4:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800053f6:	30 3b       	mov	r11,3
800053f8:	31 4c       	mov	r12,20
800053fa:	f0 1f 00 02 	mcall	80005400 <PcdAntennaOff+0xc>
}
800053fe:	d8 02       	popm	pc
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	53 cc       	stdsp	sp[0xf0],r12

80005404 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80005404:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80005406:	34 18       	mov	r8,65
80005408:	f0 0c 18 00 	cp.b	r12,r8
8000540c:	c0 20       	breq	80005410 <M500PcdConfigISOType+0xc>
8000540e:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80005410:	30 8b       	mov	r11,8
80005412:	16 9c       	mov	r12,r11
80005414:	f0 1f 00 14 	mcall	80005464 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80005418:	33 db       	mov	r11,61
8000541a:	31 1c       	mov	r12,17
8000541c:	f0 1f 00 13 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005420:	e0 6b 00 86 	mov	r11,134
80005424:	31 7c       	mov	r12,23
80005426:	f0 1f 00 11 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000542a:	37 fb       	mov	r11,127
8000542c:	32 6c       	mov	r12,38
8000542e:	f0 1f 00 0f 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005432:	31 eb       	mov	r11,30
80005434:	32 dc       	mov	r12,45
80005436:	f0 1f 00 0d 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000543a:	30 0b       	mov	r11,0
8000543c:	32 cc       	mov	r12,44
8000543e:	f0 1f 00 0b 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80005442:	e0 6b 00 8d 	mov	r11,141
80005446:	32 ac       	mov	r12,42
80005448:	f0 1f 00 08 	mcall	80005468 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
8000544c:	33 eb       	mov	r11,62
8000544e:	32 bc       	mov	r12,43
80005450:	f0 1f 00 06 	mcall	80005468 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80005454:	e0 6c 03 e8 	mov	r12,1000
80005458:	f0 1f 00 05 	mcall	8000546c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
8000545c:	f0 1f 00 05 	mcall	80005470 <M500PcdConfigISOType+0x6c>
80005460:	d8 0a       	popm	pc,r12=0
80005462:	00 00       	add	r0,r0
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	53 cc       	stdsp	sp[0xf0],r12
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	52 24       	stdsp	sp[0x88],r4
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	5b fc       	cp.w	r12,-1
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	53 ac       	stdsp	sp[0xe8],r12

80005474 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80005474:	eb cd 40 80 	pushm	r7,lr
80005478:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000547a:	49 d8       	lddpc	r8,800054ec <rc522_init+0x78>
8000547c:	1a 97       	mov	r7,sp
8000547e:	f0 ea 00 00 	ld.d	r10,r8[0]
80005482:	fa eb 00 00 	st.d	sp[0],r10
80005486:	f0 e8 00 08 	ld.d	r8,r8[8]
8000548a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
8000548e:	30 1b       	mov	r11,1
80005490:	49 8c       	lddpc	r12,800054f0 <rc522_init+0x7c>
80005492:	f0 1f 00 19 	mcall	800054f4 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80005496:	31 9c       	mov	r12,25
80005498:	f0 1f 00 18 	mcall	800054f8 <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
8000549c:	31 9c       	mov	r12,25
8000549e:	f0 1f 00 18 	mcall	800054fc <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
800054a2:	fe 7c 24 00 	mov	r12,-56320
800054a6:	49 78       	lddpc	r8,80005500 <rc522_init+0x8c>
800054a8:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800054aa:	e0 6a 36 00 	mov	r10,13824
800054ae:	ea 1a 01 6e 	orh	r10,0x16e
800054b2:	1a 9b       	mov	r11,sp
800054b4:	f0 1f 00 14 	mcall	80005504 <rc522_init+0x90>
800054b8:	c0 50       	breq	800054c2 <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800054ba:	30 29       	mov	r9,2
800054bc:	49 38       	lddpc	r8,80005508 <rc522_init+0x94>
800054be:	b0 89       	st.b	r8[0x0],r9
800054c0:	c0 38       	rjmp	800054c6 <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800054c2:	f0 1f 00 13 	mcall	8000550c <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800054c6:	f0 1f 00 13 	mcall	80005510 <rc522_init+0x9c>
	
	PcdAntennaOff();
800054ca:	f0 1f 00 13 	mcall	80005514 <rc522_init+0xa0>
	
	delay_ms(2); 
800054ce:	30 2c       	mov	r12,2
800054d0:	f0 1f 00 12 	mcall	80005518 <rc522_init+0xa4>
	
	PcdAntennaOn();
800054d4:	f0 1f 00 12 	mcall	8000551c <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
800054d8:	34 1c       	mov	r12,65
800054da:	f0 1f 00 12 	mcall	80005520 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
800054de:	30 1c       	mov	r12,1
800054e0:	f0 1f 00 11 	mcall	80005524 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

800054e4:	2f cd       	sub	sp,-16
800054e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800054ea:	00 00       	add	r0,r0
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	e9 f4 80 00 	ld.wls	r4,r4[0x0]
800054f2:	ea 04       	*unknown*
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	63 4c       	ld.w	r12,r1[0x50]
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	63 7c       	ld.w	r12,r1[0x5c]
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	63 94       	ld.w	r4,r1[0x64]
80005500:	00 00       	add	r0,r0
80005502:	1e 28       	rsub	r8,pc
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	68 64       	ld.w	r4,r4[0x18]
80005508:	00 00       	add	r0,r0
8000550a:	0b 80       	ld.ub	r0,r5[0x0]
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	51 b8       	stdsp	sp[0x6c],r8
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	52 64       	stdsp	sp[0x98],r4
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	53 f4       	stdsp	sp[0xfc],r4
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	5c 3c       	neg	r12
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	53 ac       	stdsp	sp[0xe8],r12
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	54 04       	stdsp	sp[0x100],r4
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	53 3c       	stdsp	sp[0xcc],r12

80005528 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80005528:	d4 31       	pushm	r0-r7,lr
8000552a:	20 1d       	sub	sp,4
8000552c:	18 92       	mov	r2,r12
8000552e:	16 95       	mov	r5,r11
80005530:	14 96       	mov	r6,r10
80005532:	50 09       	stdsp	sp[0x0],r9
80005534:	10 90       	mov	r0,r8
80005536:	f8 c8 00 0c 	sub	r8,r12,12
8000553a:	5c 58       	castu.b	r8
8000553c:	30 29       	mov	r9,2
8000553e:	f2 08 18 00 	cp.b	r8,r9
80005542:	e0 88 00 05 	brls	8000554c <PcdComMF522+0x24>
80005546:	30 03       	mov	r3,0
80005548:	06 91       	mov	r1,r3
8000554a:	c0 78       	rjmp	80005558 <PcdComMF522+0x30>
8000554c:	4c f9       	lddpc	r9,80005688 <PcdComMF522+0x160>
8000554e:	f2 08 07 01 	ld.ub	r1,r9[r8]
80005552:	4c f9       	lddpc	r9,8000568c <PcdComMF522+0x164>
80005554:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80005558:	02 9b       	mov	r11,r1
8000555a:	a7 bb       	sbr	r11,0x7
8000555c:	30 2c       	mov	r12,2
8000555e:	f0 1f 00 4d 	mcall	80005690 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80005562:	e0 6b 00 80 	mov	r11,128
80005566:	30 4c       	mov	r12,4
80005568:	f0 1f 00 4b 	mcall	80005694 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000556c:	30 0b       	mov	r11,0
8000556e:	30 1c       	mov	r12,1
80005570:	f0 1f 00 48 	mcall	80005690 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80005574:	e0 6b 00 80 	mov	r11,128
80005578:	30 ac       	mov	r12,10
8000557a:	f0 1f 00 48 	mcall	80005698 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
8000557e:	58 06       	cp.w	r6,0
80005580:	c0 c0       	breq	80005598 <PcdComMF522+0x70>
80005582:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80005584:	30 94       	mov	r4,9
80005586:	0f 3b       	ld.ub	r11,r7++
80005588:	08 9c       	mov	r12,r4
8000558a:	f0 1f 00 42 	mcall	80005690 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
8000558e:	0e 98       	mov	r8,r7
80005590:	0a 18       	sub	r8,r5
80005592:	ec 08 19 00 	cp.h	r8,r6
80005596:	cf 83       	brcs	80005586 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80005598:	04 9b       	mov	r11,r2
8000559a:	30 1c       	mov	r12,1
8000559c:	f0 1f 00 3d 	mcall	80005690 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
800055a0:	30 c8       	mov	r8,12
800055a2:	f0 02 18 00 	cp.b	r2,r8
800055a6:	c0 61       	brne	800055b2 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
800055a8:	e0 6b 00 80 	mov	r11,128
800055ac:	30 dc       	mov	r12,13
800055ae:	f0 1f 00 3b 	mcall	80005698 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800055b2:	30 4c       	mov	r12,4
800055b4:	f0 1f 00 3a 	mcall	8000569c <PcdComMF522+0x174>
800055b8:	18 97       	mov	r7,r12
800055ba:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055be:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800055c0:	30 44       	mov	r4,4
800055c2:	c0 88       	rjmp	800055d2 <PcdComMF522+0xaa>
800055c4:	08 9c       	mov	r12,r4
800055c6:	f0 1f 00 36 	mcall	8000569c <PcdComMF522+0x174>
800055ca:	18 97       	mov	r7,r12
		i--;
800055cc:	20 16       	sub	r6,1
800055ce:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055d0:	c0 a0       	breq	800055e4 <PcdComMF522+0xbc>
800055d2:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800055d6:	c4 c1       	brne	8000566e <PcdComMF522+0x146>
800055d8:	ef e3 00 08 	and	r8,r7,r3
800055dc:	ea 08 18 00 	cp.b	r8,r5
800055e0:	cf 20       	breq	800055c4 <PcdComMF522+0x9c>
800055e2:	c4 68       	rjmp	8000566e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800055e4:	e0 6b 00 80 	mov	r11,128
800055e8:	30 dc       	mov	r12,13
800055ea:	f0 1f 00 2b 	mcall	80005694 <PcdComMF522+0x16c>
800055ee:	30 27       	mov	r7,2
800055f0:	c3 38       	rjmp	80005656 <PcdComMF522+0x12e>
800055f2:	02 67       	and	r7,r1
800055f4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800055f8:	30 c8       	mov	r8,12
800055fa:	f0 02 18 00 	cp.b	r2,r8
800055fe:	c2 c1       	brne	80005656 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80005600:	30 ac       	mov	r12,10
80005602:	f0 1f 00 27 	mcall	8000569c <PcdComMF522+0x174>
80005606:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80005608:	30 cc       	mov	r12,12
8000560a:	f0 1f 00 25 	mcall	8000569c <PcdComMF522+0x174>
8000560e:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005612:	c0 70       	breq	80005620 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005614:	08 98       	mov	r8,r4
80005616:	20 18       	sub	r8,1
80005618:	f8 08 00 3c 	add	r12,r12,r8<<0x3
8000561c:	a0 8c       	st.b	r0[0x0],r12
8000561e:	c0 48       	rjmp	80005626 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005620:	e8 08 15 03 	lsl	r8,r4,0x3
80005624:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80005626:	58 04       	cp.w	r4,0
80005628:	c0 61       	brne	80005634 <PcdComMF522+0x10c>
8000562a:	30 14       	mov	r4,1
8000562c:	40 05       	lddsp	r5,sp[0x0]
8000562e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005630:	30 93       	mov	r3,9
80005632:	c0 98       	rjmp	80005644 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005634:	31 28       	mov	r8,18
80005636:	f0 04 18 00 	cp.b	r4,r8
8000563a:	f9 b4 0b 12 	movhi	r4,18
8000563e:	58 04       	cp.w	r4,0
80005640:	cf 61       	brne	8000562c <PcdComMF522+0x104>
80005642:	c0 a8       	rjmp	80005656 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005644:	06 9c       	mov	r12,r3
80005646:	f0 1f 00 16 	mcall	8000569c <PcdComMF522+0x174>
8000564a:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
8000564c:	ec 05 01 08 	sub	r8,r6,r5
80005650:	e8 08 19 00 	cp.h	r8,r4
80005654:	cf 83       	brcs	80005644 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80005656:	e0 6b 00 80 	mov	r11,128
8000565a:	30 cc       	mov	r12,12
8000565c:	f0 1f 00 0f 	mcall	80005698 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80005660:	30 0b       	mov	r11,0
80005662:	30 1c       	mov	r12,1
80005664:	f0 1f 00 0b 	mcall	80005690 <PcdComMF522+0x168>
	return status;
}
80005668:	0e 9c       	mov	r12,r7
8000566a:	2f fd       	sub	sp,-4
8000566c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
8000566e:	e0 6b 00 80 	mov	r11,128
80005672:	30 dc       	mov	r12,13
80005674:	f0 1f 00 08 	mcall	80005694 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80005678:	30 6c       	mov	r12,6
8000567a:	f0 1f 00 09 	mcall	8000569c <PcdComMF522+0x174>
8000567e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80005682:	cb 80       	breq	800055f2 <PcdComMF522+0xca>
80005684:	30 27       	mov	r7,2
80005686:	ce 8b       	rjmp	80005656 <PcdComMF522+0x12e>
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	e9 ec 80 00 	sthh.w	r0[r0],r4:b,r12:b
8000568e:	e9 f0 80 00 	ld.wls	r0,r4[0x0]
80005692:	52 24       	stdsp	sp[0x88],r4
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	53 cc       	stdsp	sp[0xf0],r12
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	53 88       	stdsp	sp[0xe0],r8
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	52 e4       	stdsp	sp[0xb8],r4

800056a0 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
800056a0:	eb cd 40 c0 	pushm	r6-r7,lr
800056a4:	20 5d       	sub	sp,20
800056a6:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
800056a8:	30 8b       	mov	r11,8
800056aa:	16 9c       	mov	r12,r11
800056ac:	f0 1f 00 1a 	mcall	80005714 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
800056b0:	30 0b       	mov	r11,0
800056b2:	30 dc       	mov	r12,13
800056b4:	f0 1f 00 19 	mcall	80005718 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800056b8:	e0 6b 00 80 	mov	r11,128
800056bc:	30 ec       	mov	r12,14
800056be:	f0 1f 00 16 	mcall	80005714 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800056c2:	39 38       	mov	r8,-109
800056c4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800056c6:	32 08       	mov	r8,32
800056c8:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800056ca:	1a 9b       	mov	r11,sp
800056cc:	fa c8 ff ed 	sub	r8,sp,-19
800056d0:	1a 99       	mov	r9,sp
800056d2:	30 2a       	mov	r10,2
800056d4:	30 cc       	mov	r12,12
800056d6:	f0 1f 00 12 	mcall	8000571c <PcdAnticoll+0x7c>
800056da:	18 97       	mov	r7,r12

	if (status == MI_OK)
800056dc:	c1 21       	brne	80005700 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056de:	1b 89       	ld.ub	r9,sp[0x0]
800056e0:	ac 89       	st.b	r6[0x0],r9
800056e2:	1b 98       	ld.ub	r8,sp[0x1]
800056e4:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800056e6:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056e8:	1b a8       	ld.ub	r8,sp[0x2]
800056ea:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800056ec:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056f0:	1b b9       	ld.ub	r9,sp[0x3]
800056f2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800056f4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800056f6:	1b c9       	ld.ub	r9,sp[0x4]
800056f8:	f0 09 18 00 	cp.b	r9,r8
800056fc:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80005700:	e0 6b 00 80 	mov	r11,128
80005704:	30 ec       	mov	r12,14
80005706:	f0 1f 00 07 	mcall	80005720 <PcdAnticoll+0x80>
	return status;
}
8000570a:	0e 9c       	mov	r12,r7
8000570c:	2f bd       	sub	sp,-20
8000570e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005712:	00 00       	add	r0,r0
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	53 cc       	stdsp	sp[0xf0],r12
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	52 24       	stdsp	sp[0x88],r4
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	55 28       	stdsp	sp[0x148],r8
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	53 88       	stdsp	sp[0xe0],r8

80005724 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005724:	eb cd 40 c0 	pushm	r6-r7,lr
80005728:	20 5d       	sub	sp,20
8000572a:	18 97       	mov	r7,r12
8000572c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
8000572e:	30 8b       	mov	r11,8
80005730:	16 9c       	mov	r12,r11
80005732:	f0 1f 00 12 	mcall	80005778 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80005736:	30 7b       	mov	r11,7
80005738:	30 dc       	mov	r12,13
8000573a:	f0 1f 00 11 	mcall	8000577c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
8000573e:	30 3b       	mov	r11,3
80005740:	31 4c       	mov	r12,20
80005742:	f0 1f 00 10 	mcall	80005780 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80005746:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80005748:	1a 9b       	mov	r11,sp
8000574a:	fa c8 ff ed 	sub	r8,sp,-19
8000574e:	1a 99       	mov	r9,sp
80005750:	30 1a       	mov	r10,1
80005752:	30 cc       	mov	r12,12
80005754:	f0 1f 00 0c 	mcall	80005784 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80005758:	c0 c1       	brne	80005770 <PcdRequest+0x4c>
8000575a:	31 08       	mov	r8,16
8000575c:	fb 39 00 13 	ld.ub	r9,sp[19]
80005760:	f0 09 18 00 	cp.b	r9,r8
80005764:	c0 61       	brne	80005770 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80005766:	1b 88       	ld.ub	r8,sp[0x0]
80005768:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000576a:	1b 98       	ld.ub	r8,sp[0x1]
8000576c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
8000576e:	c0 28       	rjmp	80005772 <PcdRequest+0x4e>
80005770:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80005772:	2f bd       	sub	sp,-20
80005774:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	53 cc       	stdsp	sp[0xf0],r12
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	52 24       	stdsp	sp[0x88],r4
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	53 88       	stdsp	sp[0xe0],r8
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	55 28       	stdsp	sp[0x148],r8

80005788 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80005788:	eb cd 40 f8 	pushm	r3-r7,lr
8000578c:	18 95       	mov	r5,r12
8000578e:	16 96       	mov	r6,r11
80005790:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005792:	30 4b       	mov	r11,4
80005794:	30 5c       	mov	r12,5
80005796:	f0 1f 00 1c 	mcall	80005804 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000579a:	30 0b       	mov	r11,0
8000579c:	30 1c       	mov	r12,1
8000579e:	f0 1f 00 1b 	mcall	80005808 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
800057a2:	e0 6b 00 80 	mov	r11,128
800057a6:	30 ac       	mov	r12,10
800057a8:	f0 1f 00 19 	mcall	8000580c <CalulateCRC+0x84>
	for (i=0; i<len; i++)
800057ac:	58 06       	cp.w	r6,0
800057ae:	c0 c0       	breq	800057c6 <CalulateCRC+0x3e>
800057b0:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
800057b2:	30 94       	mov	r4,9
800057b4:	0f 3b       	ld.ub	r11,r7++
800057b6:	08 9c       	mov	r12,r4
800057b8:	f0 1f 00 14 	mcall	80005808 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800057bc:	0e 98       	mov	r8,r7
800057be:	0a 18       	sub	r8,r5
800057c0:	ec 08 18 00 	cp.b	r8,r6
800057c4:	cf 83       	brcs	800057b4 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800057c6:	30 3b       	mov	r11,3
800057c8:	30 1c       	mov	r12,1
800057ca:	f0 1f 00 10 	mcall	80005808 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800057ce:	30 5c       	mov	r12,5
800057d0:	f0 1f 00 10 	mcall	80005810 <CalulateCRC+0x88>
800057d4:	e0 67 00 fe 	mov	r7,254
800057d8:	30 56       	mov	r6,5
800057da:	c0 78       	rjmp	800057e8 <CalulateCRC+0x60>
800057dc:	0c 9c       	mov	r12,r6
800057de:	f0 1f 00 0d 	mcall	80005810 <CalulateCRC+0x88>
		i--;
800057e2:	20 17       	sub	r7,1
800057e4:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800057e6:	c0 40       	breq	800057ee <CalulateCRC+0x66>
800057e8:	e2 1c 00 04 	andl	r12,0x4,COH
800057ec:	cf 80       	breq	800057dc <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800057ee:	32 2c       	mov	r12,34
800057f0:	f0 1f 00 08 	mcall	80005810 <CalulateCRC+0x88>
800057f4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800057f6:	32 1c       	mov	r12,33
800057f8:	f0 1f 00 06 	mcall	80005810 <CalulateCRC+0x88>
800057fc:	a6 9c       	st.b	r3[0x1],r12
}
800057fe:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005802:	00 00       	add	r0,r0
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	53 cc       	stdsp	sp[0xf0],r12
80005808:	80 00       	ld.sh	r0,r0[0x0]
8000580a:	52 24       	stdsp	sp[0x88],r4
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	53 88       	stdsp	sp[0xe0],r8
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	52 e4       	stdsp	sp[0xb8],r4

80005814 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005814:	eb cd 40 80 	pushm	r7,lr
80005818:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000581a:	39 38       	mov	r8,-109
8000581c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000581e:	37 08       	mov	r8,112
80005820:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005822:	30 08       	mov	r8,0
80005824:	ba e8       	st.b	sp[0x6],r8
80005826:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000582a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000582e:	19 89       	ld.ub	r9,r12[0x0]
80005830:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005832:	19 3a       	ld.ub	r10,r12++
80005834:	1b e9       	ld.ub	r9,sp[0x6]
80005836:	f5 e9 20 09 	eor	r9,r10,r9
8000583a:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
8000583c:	16 38       	cp.w	r8,r11
8000583e:	cf 81       	brne	8000582e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005840:	1a 97       	mov	r7,sp
80005842:	fa ca ff f9 	sub	r10,sp,-7
80005846:	30 7b       	mov	r11,7
80005848:	1a 9c       	mov	r12,sp
8000584a:	f0 1f 00 0d 	mcall	8000587c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
8000584e:	30 8b       	mov	r11,8
80005850:	16 9c       	mov	r12,r11
80005852:	f0 1f 00 0c 	mcall	80005880 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80005856:	fa c8 ff ed 	sub	r8,sp,-19
8000585a:	1a 99       	mov	r9,sp
8000585c:	30 9a       	mov	r10,9
8000585e:	1a 9b       	mov	r11,sp
80005860:	30 cc       	mov	r12,12
80005862:	f0 1f 00 09 	mcall	80005884 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80005866:	c0 71       	brne	80005874 <PcdSelect+0x60>
80005868:	31 88       	mov	r8,24
8000586a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000586e:	f0 09 18 00 	cp.b	r9,r8
80005872:	c0 20       	breq	80005876 <PcdSelect+0x62>
80005874:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80005876:	2f bd       	sub	sp,-20
80005878:	e3 cd 80 80 	ldm	sp++,r7,pc
8000587c:	80 00       	ld.sh	r0,r0[0x0]
8000587e:	57 88       	stdsp	sp[0x1e0],r8
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	53 cc       	stdsp	sp[0xf0],r12
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	55 28       	stdsp	sp[0x148],r8

80005888 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005888:	eb cd 40 c0 	pushm	r6-r7,lr
8000588c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000588e:	f0 1f 00 37 	mcall	80005968 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005892:	4b 7b       	lddpc	r11,8000596c <rfid_auto_reader+0xe4>
80005894:	35 2c       	mov	r12,82
80005896:	f0 1f 00 37 	mcall	80005970 <rfid_auto_reader+0xe8>
8000589a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
8000589c:	c6 31       	brne	80005962 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000589e:	4b 48       	lddpc	r8,8000596c <rfid_auto_reader+0xe4>
800058a0:	11 88       	ld.ub	r8,r8[0x0]
800058a2:	30 49       	mov	r9,4
800058a4:	f2 08 18 00 	cp.b	r8,r9
800058a8:	c0 b1       	brne	800058be <rfid_auto_reader+0x36>
800058aa:	4b 19       	lddpc	r9,8000596c <rfid_auto_reader+0xe4>
800058ac:	13 9a       	ld.ub	r10,r9[0x1]
800058ae:	30 09       	mov	r9,0
800058b0:	f2 0a 18 00 	cp.b	r10,r9
800058b4:	c0 51       	brne	800058be <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
800058b6:	4b 0c       	lddpc	r12,80005974 <rfid_auto_reader+0xec>
800058b8:	f0 1f 00 30 	mcall	80005978 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800058bc:	c3 c8       	rjmp	80005934 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058be:	30 29       	mov	r9,2
800058c0:	f2 08 18 00 	cp.b	r8,r9
800058c4:	c0 b1       	brne	800058da <rfid_auto_reader+0x52>
800058c6:	4a a9       	lddpc	r9,8000596c <rfid_auto_reader+0xe4>
800058c8:	13 9a       	ld.ub	r10,r9[0x1]
800058ca:	30 09       	mov	r9,0
800058cc:	f2 0a 18 00 	cp.b	r10,r9
800058d0:	c0 51       	brne	800058da <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800058d2:	4a bc       	lddpc	r12,8000597c <rfid_auto_reader+0xf4>
800058d4:	f0 1f 00 29 	mcall	80005978 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058d8:	c2 e8       	rjmp	80005934 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058da:	34 49       	mov	r9,68
800058dc:	f2 08 18 00 	cp.b	r8,r9
800058e0:	c0 b1       	brne	800058f6 <rfid_auto_reader+0x6e>
800058e2:	4a 39       	lddpc	r9,8000596c <rfid_auto_reader+0xe4>
800058e4:	13 9a       	ld.ub	r10,r9[0x1]
800058e6:	30 09       	mov	r9,0
800058e8:	f2 0a 18 00 	cp.b	r10,r9
800058ec:	c0 51       	brne	800058f6 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
800058ee:	4a 5c       	lddpc	r12,80005980 <rfid_auto_reader+0xf8>
800058f0:	f0 1f 00 22 	mcall	80005978 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058f4:	c2 08       	rjmp	80005934 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800058f6:	30 89       	mov	r9,8
800058f8:	f2 08 18 00 	cp.b	r8,r9
800058fc:	c0 b1       	brne	80005912 <rfid_auto_reader+0x8a>
800058fe:	49 c9       	lddpc	r9,8000596c <rfid_auto_reader+0xe4>
80005900:	13 9a       	ld.ub	r10,r9[0x1]
80005902:	30 09       	mov	r9,0
80005904:	f2 0a 18 00 	cp.b	r10,r9
80005908:	c0 51       	brne	80005912 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
8000590a:	49 fc       	lddpc	r12,80005984 <rfid_auto_reader+0xfc>
8000590c:	f0 1f 00 1b 	mcall	80005978 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005910:	c1 28       	rjmp	80005934 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005912:	34 49       	mov	r9,68
80005914:	f2 08 18 00 	cp.b	r8,r9
80005918:	c0 b1       	brne	8000592e <rfid_auto_reader+0xa6>
8000591a:	49 58       	lddpc	r8,8000596c <rfid_auto_reader+0xe4>
8000591c:	11 99       	ld.ub	r9,r8[0x1]
8000591e:	30 38       	mov	r8,3
80005920:	f0 09 18 00 	cp.b	r9,r8
80005924:	c0 51       	brne	8000592e <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80005926:	49 9c       	lddpc	r12,80005988 <rfid_auto_reader+0x100>
80005928:	f0 1f 00 14 	mcall	80005978 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000592c:	c0 48       	rjmp	80005934 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
8000592e:	49 8c       	lddpc	r12,8000598c <rfid_auto_reader+0x104>
80005930:	f0 1f 00 12 	mcall	80005978 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005934:	49 7c       	lddpc	r12,80005990 <rfid_auto_reader+0x108>
80005936:	f0 1f 00 18 	mcall	80005994 <rfid_auto_reader+0x10c>
8000593a:	18 97       	mov	r7,r12
	if(status!=MI_OK)
8000593c:	c0 60       	breq	80005948 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
8000593e:	34 fb       	mov	r11,79
80005940:	30 1c       	mov	r12,1
80005942:	f0 1f 00 16 	mcall	80005998 <rfid_auto_reader+0x110>
		return status;
80005946:	c0 e8       	rjmp	80005962 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005948:	49 2c       	lddpc	r12,80005990 <rfid_auto_reader+0x108>
8000594a:	f0 1f 00 15 	mcall	8000599c <rfid_auto_reader+0x114>
8000594e:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005950:	c0 91       	brne	80005962 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005952:	30 4a       	mov	r10,4
80005954:	48 fb       	lddpc	r11,80005990 <rfid_auto_reader+0x108>
80005956:	0c 9c       	mov	r12,r6
80005958:	f0 1f 00 12 	mcall	800059a0 <rfid_auto_reader+0x118>
		log("select okay\n");
8000595c:	49 2c       	lddpc	r12,800059a4 <rfid_auto_reader+0x11c>
8000595e:	f0 1f 00 07 	mcall	80005978 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005962:	0e 9c       	mov	r12,r7
80005964:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	52 64       	stdsp	sp[0x98],r4
8000596c:	00 00       	add	r0,r0
8000596e:	97 b0       	st.w	r11[0x2c],r0
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	57 24       	stdsp	sp[0x1c8],r4
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	ea 0c       	*unknown*
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	7f 68       	ld.w	r8,pc[0x58]
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	ea 18 80 00 	orh	r8,0x8000
80005982:	ea 24 80 00 	sub	r4,688128
80005986:	ea 34 80 00 	sub	r4,753664
8000598a:	ea 3c 80 00 	sub	r12,753664
8000598e:	ea 48 00 00 	cp.w	r8,655360
80005992:	97 b4       	st.w	r11[0x2c],r4
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	56 a0       	stdsp	sp[0x1a8],r0
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	49 b8       	lddpc	r8,80005a04 <scan_rfid_save_message+0xc>
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	58 14       	cp.w	r4,1
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	88 12       	ld.sh	r2,r4[0x2]
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	ea 54 eb cd 	cp.w	r4,781261

800059a8 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
800059a8:	eb cd 40 80 	pushm	r7,lr
800059ac:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
800059ae:	f0 1f 00 0d 	mcall	800059e0 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
800059b2:	30 0c       	mov	r12,0
800059b4:	f0 1f 00 0c 	mcall	800059e4 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
800059b8:	0e 9c       	mov	r12,r7
800059ba:	f0 1f 00 0c 	mcall	800059e8 <scan_patrol+0x40>
800059be:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800059c0:	30 1c       	mov	r12,1
800059c2:	f0 1f 00 09 	mcall	800059e4 <scan_patrol+0x3c>
	if(return_err == 0)
800059c6:	58 07       	cp.w	r7,0
800059c8:	c0 51       	brne	800059d2 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800059ca:	48 9c       	lddpc	r12,800059ec <scan_patrol+0x44>
800059cc:	f0 1f 00 09 	mcall	800059f0 <scan_patrol+0x48>
800059d0:	c0 48       	rjmp	800059d8 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800059d2:	48 9c       	lddpc	r12,800059f4 <scan_patrol+0x4c>
800059d4:	f0 1f 00 07 	mcall	800059f0 <scan_patrol+0x48>
		
	return return_err;

}
800059d8:	0e 9c       	mov	r12,r7
800059da:	e3 cd 80 80 	ldm	sp++,r7,pc
800059de:	00 00       	add	r0,r0
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	52 64       	stdsp	sp[0x98],r4
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	53 3c       	stdsp	sp[0xcc],r12
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	58 88       	cp.w	r8,8
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	ea 64 80 00 	mov	r4,688128
800059f2:	7f 68       	ld.w	r8,pc[0x58]
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	ea 78 eb cd 	mov	r8,781261

800059f8 <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
800059f8:	eb cd 40 e0 	pushm	r5-r7,lr
800059fc:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800059fe:	4e 9c       	lddpc	r12,80005ba0 <scan_rfid_save_message+0x1a8>
80005a00:	30 08       	mov	r8,0
80005a02:	30 09       	mov	r9,0
80005a04:	f8 e9 00 00 	st.d	r12[0],r8
80005a08:	30 0a       	mov	r10,0
80005a0a:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005a0c:	fa e9 00 24 	st.d	sp[36],r8
80005a10:	fa e9 00 2c 	st.d	sp[44],r8
80005a14:	fa e9 00 34 	st.d	sp[52],r8
80005a18:	fa e9 00 3c 	st.d	sp[60],r8
80005a1c:	fa e9 00 44 	st.d	sp[68],r8
80005a20:	fa e9 00 4c 	st.d	sp[76],r8
80005a24:	fa e9 00 54 	st.d	sp[84],r8
80005a28:	fa e9 00 5c 	st.d	sp[92],r8
80005a2c:	fa e9 00 64 	st.d	sp[100],r8
80005a30:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80005a34:	f0 1f 00 5c 	mcall	80005ba4 <scan_rfid_save_message+0x1ac>
80005a38:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005a3a:	e0 81 00 a7 	brne	80005b88 <scan_rfid_save_message+0x190>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005a3e:	4d 96       	lddpc	r6,80005ba0 <scan_rfid_save_message+0x1a8>
80005a40:	0d b8       	ld.ub	r8,r6[0x3]
80005a42:	1a d8       	st.w	--sp,r8
80005a44:	0d a8       	ld.ub	r8,r6[0x2]
80005a46:	1a d8       	st.w	--sp,r8
80005a48:	0d 98       	ld.ub	r8,r6[0x1]
80005a4a:	1a d8       	st.w	--sp,r8
80005a4c:	0d 88       	ld.ub	r8,r6[0x0]
80005a4e:	1a d8       	st.w	--sp,r8
80005a50:	4d 6c       	lddpc	r12,80005ba8 <scan_rfid_save_message+0x1b0>
80005a52:	f0 1f 00 57 	mcall	80005bac <scan_rfid_save_message+0x1b4>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005a56:	34 4b       	mov	r11,68
80005a58:	30 1c       	mov	r12,1
80005a5a:	f0 1f 00 56 	mcall	80005bb0 <scan_rfid_save_message+0x1b8>
80005a5e:	fa c8 ff ec 	sub	r8,sp,-20
80005a62:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80005a66:	ec c5 ff fc 	sub	r5,r6,-4
80005a6a:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a6c:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a6e:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005a70:	0d 8a       	ld.ub	r10,r6[0x0]
80005a72:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a76:	fc 0b 18 00 	cp.b	r11,lr
80005a7a:	f7 bb 08 d0 	subls	r11,-48
80005a7e:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005a82:	f7 bb 0b a9 	subhi	r11,-87
80005a86:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a8a:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005a8c:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005a90:	fc 0a 18 00 	cp.b	r10,lr
80005a94:	f7 ba 08 d0 	subls	r10,-48
80005a98:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005a9c:	f7 ba 0b a9 	subhi	r10,-87
80005aa0:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005aa4:	b0 bc       	st.b	r8[0x3],r12
80005aa6:	2f f6       	sub	r6,-1
80005aa8:	2f c8       	sub	r8,-4
80005aaa:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005aac:	0a 36       	cp.w	r6,r5
80005aae:	ce 11       	brne	80005a70 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005ab0:	30 6a       	mov	r10,6
80005ab2:	4c 1b       	lddpc	r11,80005bb4 <scan_rfid_save_message+0x1bc>
80005ab4:	fa cc ff ec 	sub	r12,sp,-20
80005ab8:	f0 1f 00 40 	mcall	80005bb8 <scan_rfid_save_message+0x1c0>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005abc:	4c 08       	lddpc	r8,80005bbc <scan_rfid_save_message+0x1c4>
80005abe:	11 89       	ld.ub	r9,r8[0x0]
80005ac0:	39 f8       	mov	r8,-97
80005ac2:	f0 09 18 00 	cp.b	r9,r8
80005ac6:	e0 88 00 05 	brls	80005ad0 <scan_rfid_save_message+0xd8>
80005aca:	38 09       	mov	r9,-128
80005acc:	4b c8       	lddpc	r8,80005bbc <scan_rfid_save_message+0x1c4>
80005ace:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005ad0:	4b b8       	lddpc	r8,80005bbc <scan_rfid_save_message+0x1c4>
80005ad2:	11 86       	ld.ub	r6,r8[0x0]
80005ad4:	2f f6       	sub	r6,-1
80005ad6:	5c 56       	castu.b	r6
80005ad8:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005ada:	30 5a       	mov	r10,5
80005adc:	4b 9b       	lddpc	r11,80005bc0 <scan_rfid_save_message+0x1c8>
80005ade:	fa cc ff e1 	sub	r12,sp,-31
80005ae2:	f0 1f 00 36 	mcall	80005bb8 <scan_rfid_save_message+0x1c0>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005ae6:	31 e8       	mov	r8,30
80005ae8:	fb 58 00 1a 	st.h	sp[26],r8
80005aec:	fb 66 00 1e 	st.b	sp[30],r6
80005af0:	fe 78 e0 00 	mov	r8,-8192
80005af4:	fb 58 00 1c 	st.h	sp[28],r8
80005af8:	30 aa       	mov	r10,10
80005afa:	fa cb ff e6 	sub	r11,sp,-26
80005afe:	fa cc ff dc 	sub	r12,sp,-36
80005b02:	f0 1f 00 2e 	mcall	80005bb8 <scan_rfid_save_message+0x1c0>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005b06:	31 6a       	mov	r10,22
80005b08:	fa cb ff fc 	sub	r11,sp,-4
80005b0c:	fa cc ff d2 	sub	r12,sp,-46
80005b10:	f0 1f 00 2a 	mcall	80005bb8 <scan_rfid_save_message+0x1c0>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005b14:	4a c8       	lddpc	r8,80005bc4 <scan_rfid_save_message+0x1cc>
80005b16:	70 0c       	ld.w	r12,r8[0x0]
80005b18:	f0 1f 00 2c 	mcall	80005bc8 <scan_rfid_save_message+0x1d0>
80005b1c:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005b1e:	c3 10       	breq	80005b80 <scan_rfid_save_message+0x188>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005b20:	32 0a       	mov	r10,32
80005b22:	fa cb ff dc 	sub	r11,sp,-36
80005b26:	f0 1f 00 25 	mcall	80005bb8 <scan_rfid_save_message+0x1c0>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005b2a:	4a 98       	lddpc	r8,80005bcc <scan_rfid_save_message+0x1d4>
80005b2c:	70 0c       	ld.w	r12,r8[0x0]
80005b2e:	30 09       	mov	r9,0
80005b30:	12 9a       	mov	r10,r9
80005b32:	1a 9b       	mov	r11,sp
80005b34:	f0 1f 00 27 	mcall	80005bd0 <scan_rfid_save_message+0x1d8>
80005b38:	58 1c       	cp.w	r12,1
80005b3a:	c1 10       	breq	80005b5c <scan_rfid_save_message+0x164>
			{
				log("xg_resend_queue: full\n" );
80005b3c:	4a 6c       	lddpc	r12,80005bd4 <scan_rfid_save_message+0x1dc>
80005b3e:	f0 1f 00 1c 	mcall	80005bac <scan_rfid_save_message+0x1b4>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005b42:	32 3b       	mov	r11,35
80005b44:	30 1c       	mov	r12,1
80005b46:	f0 1f 00 1b 	mcall	80005bb0 <scan_rfid_save_message+0x1b8>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005b4a:	e0 6c 17 70 	mov	r12,6000
80005b4e:	f0 1f 00 23 	mcall	80005bd8 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005b52:	32 3b       	mov	r11,35
80005b54:	30 0c       	mov	r12,0
80005b56:	f0 1f 00 17 	mcall	80005bb0 <scan_rfid_save_message+0x1b8>
80005b5a:	c1 e8       	rjmp	80005b96 <scan_rfid_save_message+0x19e>
			}
			else
			{
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005b5c:	4a 06       	lddpc	r6,80005bdc <scan_rfid_save_message+0x1e4>
80005b5e:	6c 0c       	ld.w	r12,r6[0x0]
80005b60:	30 09       	mov	r9,0
80005b62:	3f fa       	mov	r10,-1
80005b64:	12 9b       	mov	r11,r9
80005b66:	f0 1f 00 1f 	mcall	80005be0 <scan_rfid_save_message+0x1e8>
				global_count++;
80005b6a:	49 f8       	lddpc	r8,80005be4 <scan_rfid_save_message+0x1ec>
80005b6c:	70 09       	ld.w	r9,r8[0x0]
80005b6e:	2f f9       	sub	r9,-1
80005b70:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005b72:	6c 0c       	ld.w	r12,r6[0x0]
80005b74:	30 09       	mov	r9,0
80005b76:	12 9a       	mov	r10,r9
80005b78:	12 9b       	mov	r11,r9
80005b7a:	f0 1f 00 16 	mcall	80005bd0 <scan_rfid_save_message+0x1d8>
80005b7e:	c0 c8       	rjmp	80005b96 <scan_rfid_save_message+0x19e>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005b80:	49 ac       	lddpc	r12,80005be8 <scan_rfid_save_message+0x1f0>
80005b82:	f0 1f 00 0b 	mcall	80005bac <scan_rfid_save_message+0x1b4>
80005b86:	c0 88       	rjmp	80005b96 <scan_rfid_save_message+0x19e>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005b88:	34 fb       	mov	r11,79
80005b8a:	30 1c       	mov	r12,1
80005b8c:	f0 1f 00 09 	mcall	80005bb0 <scan_rfid_save_message+0x1b8>
		log("no card find...\n");
80005b90:	49 7c       	lddpc	r12,80005bec <scan_rfid_save_message+0x1f4>
80005b92:	f0 1f 00 07 	mcall	80005bac <scan_rfid_save_message+0x1b4>
	}
	
	return return_err;
	

}
80005b96:	0e 9c       	mov	r12,r7
80005b98:	2e 3d       	sub	sp,-116
80005b9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b9e:	00 00       	add	r0,r0
80005ba0:	00 00       	add	r0,r0
80005ba2:	0b 84       	ld.ub	r4,r5[0x0]
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	59 a8       	cp.w	r8,26
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	ea 8c 80 00 	brvs	80155baa <_data_lma+0x14655a>
80005bae:	7f 68       	ld.w	r8,pc[0x58]
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	49 b8       	lddpc	r8,80005c1c <delay_us+0x8>
80005bb4:	00 00       	add	r0,r0
80005bb6:	0e 20       	rsub	r0,r7
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	88 12       	ld.sh	r2,r4[0x2]
80005bbc:	00 00       	add	r0,r0
80005bbe:	05 3c       	ld.ub	r12,r2++
80005bc0:	00 00       	add	r0,r0
80005bc2:	05 34       	ld.ub	r4,r2++
80005bc4:	00 00       	add	r0,r0
80005bc6:	0b 9c       	ld.ub	r12,r5[0x1]
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	36 fc       	mov	r12,111
80005bcc:	00 00       	add	r0,r0
80005bce:	0b 90       	ld.ub	r0,r5[0x1]
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	73 30       	ld.w	r0,r9[0x4c]
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	e8 b4       	*unknown*
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	79 fc       	ld.w	r12,r12[0x7c]
80005bdc:	00 00       	add	r0,r0
80005bde:	0a 78       	tst	r8,r5
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	71 24       	ld.w	r4,r8[0x48]
80005be4:	00 00       	add	r0,r0
80005be6:	0a 80       	andn	r0,r5
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	e8 cc 80 00 	sub	r12,r4,-32768
80005bee:	ea a8       	*unknown*

80005bf0 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005bf0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005bf2:	f0 1f 00 02 	mcall	80005bf8 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005bf6:	d8 02       	popm	pc
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	54 74       	stdsp	sp[0x11c],r4

80005bfc <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005bfc:	58 0c       	cp.w	r12,0
80005bfe:	5e 0c       	reteq	r12
80005c00:	30 08       	mov	r8,0
	{
		nop();
80005c02:	d7 03       	nop
		nop();
80005c04:	d7 03       	nop
		nop();
80005c06:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005c08:	2f f8       	sub	r8,-1
80005c0a:	10 3c       	cp.w	r12,r8
80005c0c:	fe 9b ff fb 	brhi	80005c02 <delay_ns+0x6>
80005c10:	5e fc       	retal	r12
80005c12:	d7 03       	nop

80005c14 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005c14:	eb cd 40 e0 	pushm	r5-r7,lr
80005c18:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005c1a:	58 0c       	cp.w	r12,0
80005c1c:	c0 b0       	breq	80005c32 <delay_us+0x1e>
80005c1e:	30 07       	mov	r7,0
		delay_ns(1000);
80005c20:	e0 65 03 e8 	mov	r5,1000
80005c24:	0a 9c       	mov	r12,r5
80005c26:	f0 1f 00 05 	mcall	80005c38 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005c2a:	2f f7       	sub	r7,-1
80005c2c:	0e 36       	cp.w	r6,r7
80005c2e:	fe 9b ff fb 	brhi	80005c24 <delay_us+0x10>
80005c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c36:	00 00       	add	r0,r0
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	5b fc       	cp.w	r12,-1

80005c3c <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005c3c:	eb cd 40 e0 	pushm	r5-r7,lr
80005c40:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005c42:	58 0c       	cp.w	r12,0
80005c44:	c0 b0       	breq	80005c5a <delay_ms+0x1e>
80005c46:	30 07       	mov	r7,0
		delay_us(1000);
80005c48:	e0 65 03 e8 	mov	r5,1000
80005c4c:	0a 9c       	mov	r12,r5
80005c4e:	f0 1f 00 05 	mcall	80005c60 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005c52:	2f f7       	sub	r7,-1
80005c54:	0e 36       	cp.w	r6,r7
80005c56:	fe 9b ff fb 	brhi	80005c4c <delay_ms+0x10>
80005c5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c5e:	00 00       	add	r0,r0
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	5c 14       	scr	r4

80005c64 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005c64:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005c66:	30 3b       	mov	r11,3
80005c68:	48 8c       	lddpc	r12,80005c88 <local_start_timer+0x24>
80005c6a:	f0 1f 00 09 	mcall	80005c8c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005c6e:	fe 78 38 00 	mov	r8,-51200
80005c72:	e0 69 91 0d 	mov	r9,37133
80005c76:	ea 19 00 52 	orh	r9,0x52
80005c7a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005c7c:	32 09       	mov	r9,32
80005c7e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c80:	30 59       	mov	r9,5
80005c82:	91 09       	st.w	r8[0x0],r9
}
80005c84:	d8 02       	popm	pc
80005c86:	00 00       	add	r0,r0
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	ea bc       	*unknown*
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	63 4c       	ld.w	r12,r1[0x50]

80005c90 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005c90:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005c92:	30 3a       	mov	r10,3
80005c94:	e0 6b 1b 00 	mov	r11,6912
80005c98:	ea 1b 00 b7 	orh	r11,0xb7
80005c9c:	fe 7c 0c 00 	mov	r12,-62464
80005ca0:	f0 1f 00 19 	mcall	80005d04 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005ca4:	31 08       	mov	r8,16
80005ca6:	1a d8       	st.w	--sp,r8
80005ca8:	30 08       	mov	r8,0
80005caa:	30 19       	mov	r9,1
80005cac:	30 7a       	mov	r10,7
80005cae:	10 9b       	mov	r11,r8
80005cb0:	fe 7c 0c 00 	mov	r12,-62464
80005cb4:	f0 1f 00 15 	mcall	80005d08 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005cb8:	30 08       	mov	r8,0
80005cba:	30 19       	mov	r9,1
80005cbc:	12 9a       	mov	r10,r9
80005cbe:	10 9b       	mov	r11,r8
80005cc0:	fe 7c 0c 00 	mov	r12,-62464
80005cc4:	f0 1f 00 12 	mcall	80005d0c <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005cc8:	30 0b       	mov	r11,0
80005cca:	fe 7c 0c 00 	mov	r12,-62464
80005cce:	f0 1f 00 11 	mcall	80005d10 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005cd2:	fe 7c 0c 00 	mov	r12,-62464
80005cd6:	f0 1f 00 10 	mcall	80005d14 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005cda:	30 0a       	mov	r10,0
80005cdc:	1a da       	st.w	--sp,r10
80005cde:	1a da       	st.w	--sp,r10
80005ce0:	14 98       	mov	r8,r10
80005ce2:	14 99       	mov	r9,r10
80005ce4:	30 1b       	mov	r11,1
80005ce6:	fe 7c 0c 00 	mov	r12,-62464
80005cea:	f0 1f 00 0c 	mcall	80005d18 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005cee:	30 1c       	mov	r12,1
80005cf0:	f0 1f 00 0b 	mcall	80005d1c <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005cf4:	30 2b       	mov	r11,2
80005cf6:	fe 7c 0c 00 	mov	r12,-62464
80005cfa:	f0 1f 00 0a 	mcall	80005d20 <local_start_pll0+0x90>
80005cfe:	2f dd       	sub	sp,-12
/****/
}
80005d00:	d8 02       	popm	pc
80005d02:	00 00       	add	r0,r0
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	66 54       	ld.w	r4,r3[0x14]
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	65 f6       	ld.w	r6,r2[0x7c]
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	66 18       	ld.w	r8,r3[0x4]
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	66 32       	ld.w	r2,r3[0xc]
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	66 40       	ld.w	r0,r3[0x10]
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	65 b0       	ld.w	r0,r2[0x6c]
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	62 ec       	ld.w	r12,r1[0x38]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	66 4a       	ld.w	r10,r3[0x10]

80005d24 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005d24:	d4 31       	pushm	r0-r7,lr
80005d26:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005d28:	f0 1f 00 88 	mcall	80005f48 <xg_flashc_init+0x224>
80005d2c:	fe f8 02 20 	ld.w	r8,pc[544]
80005d30:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005d32:	70 08       	ld.w	r8,r8[0x0]
80005d34:	58 08       	cp.w	r8,0
80005d36:	c0 51       	brne	80005d40 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005d38:	fe fc 02 18 	ld.w	r12,pc[536]
80005d3c:	f0 1f 00 86 	mcall	80005f54 <xg_flashc_init+0x230>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005d40:	30 0b       	mov	r11,0
80005d42:	30 1c       	mov	r12,1
80005d44:	f0 1f 00 85 	mcall	80005f58 <xg_flashc_init+0x234>
80005d48:	fe f8 02 14 	ld.w	r8,pc[532]
80005d4c:	91 0c       	st.w	r8[0x0],r12
80005d4e:	70 08       	ld.w	r8,r8[0x0]
80005d50:	58 08       	cp.w	r8,0
80005d52:	c0 90       	breq	80005d64 <xg_flashc_init+0x40>
80005d54:	fe f8 02 08 	ld.w	r8,pc[520]
80005d58:	70 0c       	ld.w	r12,r8[0x0]
80005d5a:	30 09       	mov	r9,0
80005d5c:	12 9a       	mov	r10,r9
80005d5e:	12 9b       	mov	r11,r9
80005d60:	f0 1f 00 80 	mcall	80005f60 <xg_flashc_init+0x23c>
	if (xBinarySemaphore == NULL)
80005d64:	4f e8       	lddpc	r8,80005f5c <xg_flashc_init+0x238>
80005d66:	70 08       	ld.w	r8,r8[0x0]
80005d68:	58 08       	cp.w	r8,0
80005d6a:	c0 41       	brne	80005d72 <xg_flashc_init+0x4e>
	{
		log("Create the xBinarySemaphore semaphore failure\n");
80005d6c:	4f ec       	lddpc	r12,80005f64 <xg_flashc_init+0x240>
80005d6e:	f0 1f 00 7a 	mcall	80005f54 <xg_flashc_init+0x230>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
80005d72:	30 4b       	mov	r11,4
80005d74:	36 4c       	mov	r12,100
80005d76:	f0 1f 00 79 	mcall	80005f58 <xg_flashc_init+0x234>
80005d7a:	4f c8       	lddpc	r8,80005f68 <xg_flashc_init+0x244>
80005d7c:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005d7e:	30 4b       	mov	r11,4
80005d80:	37 8c       	mov	r12,120
80005d82:	f0 1f 00 76 	mcall	80005f58 <xg_flashc_init+0x234>
80005d86:	4f a8       	lddpc	r8,80005f6c <xg_flashc_init+0x248>
80005d88:	91 0c       	st.w	r8[0x0],r12
80005d8a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005d8c:	10 96       	mov	r6,r8
80005d8e:	4f 95       	lddpc	r5,80005f70 <xg_flashc_init+0x24c>
80005d90:	6c 0c       	ld.w	r12,r6[0x0]
80005d92:	ea 07 00 0b 	add	r11,r5,r7
80005d96:	f0 1f 00 78 	mcall	80005f74 <xg_flashc_init+0x250>
80005d9a:	2e 07       	sub	r7,-32
	//}
	
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005d9c:	e0 47 0f 00 	cp.w	r7,3840
80005da0:	cf 81       	brne	80005d90 <xg_flashc_init+0x6c>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005da2:	f0 1f 00 76 	mcall	80005f78 <xg_flashc_init+0x254>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005da6:	30 0a       	mov	r10,0
80005da8:	30 0b       	mov	r11,0
80005daa:	4f 58       	lddpc	r8,80005f7c <xg_flashc_init+0x258>
80005dac:	b1 2a       	st.d	r8++,r10
80005dae:	b1 2a       	st.d	r8++,r10
80005db0:	b1 2a       	st.d	r8++,r10
80005db2:	b1 2a       	st.d	r8++,r10
80005db4:	b1 2a       	st.d	r8++,r10
80005db6:	b1 2a       	st.d	r8++,r10
80005db8:	b1 2a       	st.d	r8++,r10
80005dba:	b1 2a       	st.d	r8++,r10
80005dbc:	b1 2a       	st.d	r8++,r10
80005dbe:	f0 eb 00 00 	st.d	r8[0],r10
80005dc2:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005dc4:	4e e7       	lddpc	r7,80005f7c <xg_flashc_init+0x258>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005dc6:	ee c4 ff f8 	sub	r4,r7,-8
80005dca:	e8 c3 ff f8 	sub	r3,r4,-8
80005dce:	e6 c2 ff f8 	sub	r2,r3,-8
80005dd2:	e4 c1 ff f8 	sub	r1,r2,-8
80005dd6:	e2 c0 ff f8 	sub	r0,r1,-8
80005dda:	e0 ca ff f8 	sub	r10,r0,-8
80005dde:	50 0a       	stdsp	sp[0x0],r10
80005de0:	2f 8a       	sub	r10,-8
80005de2:	50 1a       	stdsp	sp[0x4],r10
80005de4:	2f 8a       	sub	r10,-8
80005de6:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005de8:	0e 9a       	mov	r10,r7
80005dea:	30 6b       	mov	r11,6
80005dec:	30 0c       	mov	r12,0
80005dee:	f0 1f 00 65 	mcall	80005f80 <xg_flashc_init+0x25c>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005df2:	30 6a       	mov	r10,6
80005df4:	0e 9b       	mov	r11,r7
80005df6:	4e 4c       	lddpc	r12,80005f84 <xg_flashc_init+0x260>
80005df8:	f0 1f 00 64 	mcall	80005f88 <xg_flashc_init+0x264>
80005dfc:	c1 c0       	breq	80005e34 <xg_flashc_init+0x110>
80005dfe:	c8 b8       	rjmp	80005f14 <xg_flashc_init+0x1f0>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005e00:	30 6a       	mov	r10,6
80005e02:	30 0b       	mov	r11,0
80005e04:	4e 0c       	lddpc	r12,80005f84 <xg_flashc_init+0x260>
80005e06:	f0 1f 00 62 	mcall	80005f8c <xg_flashc_init+0x268>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005e0a:	4d d7       	lddpc	r7,80005f7c <xg_flashc_init+0x258>
80005e0c:	35 0a       	mov	r10,80
80005e0e:	30 0b       	mov	r11,0
80005e10:	0e 9c       	mov	r12,r7
80005e12:	f0 1f 00 60 	mcall	80005f90 <xg_flashc_init+0x26c>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005e16:	30 2a       	mov	r10,2
80005e18:	30 6b       	mov	r11,6
80005e1a:	0e 9c       	mov	r12,r7
80005e1c:	f0 1f 00 5c 	mcall	80005f8c <xg_flashc_init+0x268>
			if(return_code != DF_WRITE_COMPLETED)
80005e20:	58 7c       	cp.w	r12,7
80005e22:	e0 81 00 90 	brne	80005f42 <xg_flashc_init+0x21e>
			{
				return FALSE;
			}
			current_message_index = 0;
80005e26:	30 09       	mov	r9,0
80005e28:	4d b8       	lddpc	r8,80005f94 <xg_flashc_init+0x270>
80005e2a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005e2c:	4d bc       	lddpc	r12,80005f98 <xg_flashc_init+0x274>
80005e2e:	f0 1f 00 4a 	mcall	80005f54 <xg_flashc_init+0x230>
80005e32:	c8 58       	rjmp	80005f3c <xg_flashc_init+0x218>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005e34:	1a d7       	st.w	--sp,r7
80005e36:	4d ac       	lddpc	r12,80005f9c <xg_flashc_init+0x278>
80005e38:	f0 1f 00 47 	mcall	80005f54 <xg_flashc_init+0x230>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005e3c:	4d 6a       	lddpc	r10,80005f94 <xg_flashc_init+0x270>
80005e3e:	30 2b       	mov	r11,2
80005e40:	30 6c       	mov	r12,6
80005e42:	f0 1f 00 50 	mcall	80005f80 <xg_flashc_init+0x25c>
			if(return_code == DF_OK)
80005e46:	2f fd       	sub	sp,-4
80005e48:	58 0c       	cp.w	r12,0
80005e4a:	e0 81 00 7c 	brne	80005f42 <xg_flashc_init+0x21e>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005e4e:	4d 28       	lddpc	r8,80005f94 <xg_flashc_init+0x270>
80005e50:	90 08       	ld.sh	r8,r8[0x0]
80005e52:	58 08       	cp.w	r8,0
80005e54:	c7 10       	breq	80005f36 <xg_flashc_init+0x212>
					
					log("current_message_index: %d\n", current_message_index);
80005e56:	5c 78       	castu.h	r8
80005e58:	1a d8       	st.w	--sp,r8
80005e5a:	4d 2c       	lddpc	r12,80005fa0 <xg_flashc_init+0x27c>
80005e5c:	f0 1f 00 3e 	mcall	80005f54 <xg_flashc_init+0x230>
					memset(str, 0x00, sizeof(str));	
80005e60:	30 08       	mov	r8,0
80005e62:	30 09       	mov	r9,0
80005e64:	ee e9 00 00 	st.d	r7[0],r8
80005e68:	e8 e9 00 00 	st.d	r4[0],r8
80005e6c:	e6 e9 00 00 	st.d	r3[0],r8
80005e70:	e4 e9 00 00 	st.d	r2[0],r8
80005e74:	e2 e9 00 00 	st.d	r1[0],r8
80005e78:	e0 e9 00 00 	st.d	r0[0],r8
80005e7c:	40 1a       	lddsp	r10,sp[0x4]
80005e7e:	f4 e9 00 00 	st.d	r10[0],r8
80005e82:	40 2a       	lddsp	r10,sp[0x8]
80005e84:	f4 e9 00 00 	st.d	r10[0],r8
80005e88:	40 3a       	lddsp	r10,sp[0xc]
80005e8a:	b5 28       	st.d	r10++,r8
80005e8c:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005e90:	4c 18       	lddpc	r8,80005f94 <xg_flashc_init+0x270>
80005e92:	90 85       	ld.uh	r5,r8[0x0]
80005e94:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005e96:	0e 9a       	mov	r10,r7
80005e98:	30 8b       	mov	r11,8
80005e9a:	0a 9c       	mov	r12,r5
80005e9c:	f0 1f 00 39 	mcall	80005f80 <xg_flashc_init+0x25c>
					if(return_code == DF_OK)
80005ea0:	2f fd       	sub	sp,-4
80005ea2:	58 0c       	cp.w	r12,0
80005ea4:	c4 91       	brne	80005f36 <xg_flashc_init+0x212>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005ea6:	0f 89       	ld.ub	r9,r7[0x0]
80005ea8:	0f 98       	ld.ub	r8,r7[0x1]
80005eaa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005eae:	4b a9       	lddpc	r9,80005f94 <xg_flashc_init+0x270>
80005eb0:	92 09       	ld.sh	r9,r9[0x0]
80005eb2:	f0 09 19 00 	cp.h	r9,r8
80005eb6:	c2 c1       	brne	80005f0e <xg_flashc_init+0x1ea>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005eb8:	0f e9       	ld.ub	r9,r7[0x6]
80005eba:	0f f8       	ld.ub	r8,r7[0x7]
80005ebc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005ec0:	0f aa       	ld.ub	r10,r7[0x2]
80005ec2:	0f b8       	ld.ub	r8,r7[0x3]
80005ec4:	b1 68       	lsl	r8,0x10
80005ec6:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005eca:	0f ca       	ld.ub	r10,r7[0x4]
80005ecc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005ed0:	0f da       	ld.ub	r10,r7[0x5]
80005ed2:	f5 e8 10 08 	or	r8,r10,r8
80005ed6:	f2 08 00 08 	add	r8,r9,r8
80005eda:	4b 36       	lddpc	r6,80005fa4 <xg_flashc_init+0x280>
80005edc:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005ede:	1a d8       	st.w	--sp,r8
80005ee0:	4b 2c       	lddpc	r12,80005fa8 <xg_flashc_init+0x284>
80005ee2:	f0 1f 00 1d 	mcall	80005f54 <xg_flashc_init+0x230>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005ee6:	2f fd       	sub	sp,-4
80005ee8:	6c 08       	ld.w	r8,r6[0x0]
80005eea:	e0 69 ff ff 	mov	r9,65535
80005eee:	ea 19 00 7f 	orh	r9,0x7f
80005ef2:	12 38       	cp.w	r8,r9
80005ef4:	e0 88 00 21 	brls	80005f36 <xg_flashc_init+0x212>
										
								log("\r\n----message storage is full!!!----\r\n");
80005ef8:	4a dc       	lddpc	r12,80005fac <xg_flashc_init+0x288>
80005efa:	f0 1f 00 17 	mcall	80005f54 <xg_flashc_init+0x230>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005efe:	30 4b       	mov	r11,4
80005f00:	30 0c       	mov	r12,0
80005f02:	f0 1f 00 2c 	mcall	80005fb0 <xg_flashc_init+0x28c>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005f06:	58 5c       	cp.w	r12,5
80005f08:	fe 90 ff 70 	breq	80005de8 <xg_flashc_init+0xc4>
80005f0c:	c1 b8       	rjmp	80005f42 <xg_flashc_init+0x21e>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005f0e:	4a ac       	lddpc	r12,80005fb4 <xg_flashc_init+0x290>
80005f10:	f0 1f 00 11 	mcall	80005f54 <xg_flashc_init+0x230>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f14:	30 3b       	mov	r11,3
80005f16:	0a 9c       	mov	r12,r5
80005f18:	f0 1f 00 26 	mcall	80005fb0 <xg_flashc_init+0x28c>
				if(return_code != DF_ERASE_COMPLETED)
80005f1c:	58 5c       	cp.w	r12,5
80005f1e:	c1 21       	brne	80005f42 <xg_flashc_init+0x21e>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f20:	30 3b       	mov	r11,3
80005f22:	e0 78 00 00 	mov	r8,65536
80005f26:	ea 08 00 0c 	add	r12,r5,r8
80005f2a:	f0 1f 00 22 	mcall	80005fb0 <xg_flashc_init+0x28c>
				if(return_code != DF_ERASE_COMPLETED)
80005f2e:	58 5c       	cp.w	r12,5
80005f30:	fe 90 ff 68 	breq	80005e00 <xg_flashc_init+0xdc>
80005f34:	c0 78       	rjmp	80005f42 <xg_flashc_init+0x21e>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005f36:	4a 1c       	lddpc	r12,80005fb8 <xg_flashc_init+0x294>
80005f38:	f0 1f 00 07 	mcall	80005f54 <xg_flashc_init+0x230>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005f3c:	30 19       	mov	r9,1
80005f3e:	4a 08       	lddpc	r8,80005fbc <xg_flashc_init+0x298>
80005f40:	b0 89       	st.b	r8[0x0],r9
	
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005f42:	2f dd       	sub	sp,-12
80005f44:	d8 32       	popm	r0-r7,pc
80005f46:	00 00       	add	r0,r0
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	74 30       	ld.w	r0,r10[0xc]
80005f4c:	00 00       	add	r0,r0
80005f4e:	0b 98       	ld.ub	r8,r5[0x1]
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	ea d4 80 00 	satsub.w	r4,r5,-32768
80005f56:	7f 68       	ld.w	r8,pc[0x58]
80005f58:	80 00       	ld.sh	r0,r0[0x0]
80005f5a:	74 88       	ld.w	r8,r10[0x20]
80005f5c:	00 00       	add	r0,r0
80005f5e:	0b a0       	ld.ub	r0,r5[0x2]
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	73 30       	ld.w	r0,r9[0x4c]
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	eb 00 00 00 	ld.sh	r0,r5[0]
80005f6a:	0b 90       	ld.ub	r0,r5[0x1]
80005f6c:	00 00       	add	r0,r0
80005f6e:	0b 9c       	ld.ub	r12,r5[0x1]
80005f70:	00 00       	add	r0,r0
80005f72:	97 b8       	st.w	r11[0x2c],r8
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	35 50       	mov	r0,85
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	32 18       	mov	r8,33
80005f7c:	00 00       	add	r0,r0
80005f7e:	0b a8       	ld.ub	r8,r5[0x2]
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	2e bc       	sub	r12,-21
80005f84:	00 00       	add	r0,r0
80005f86:	05 40       	ld.w	r0,--r2
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	87 ec       	st.w	r3[0x38],r12
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	30 f4       	mov	r4,15
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	89 5a       	st.w	r4[0x14],r10
80005f94:	00 00       	add	r0,r0
80005f96:	0b a4       	ld.ub	r4,r5[0x2]
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	eb 30 80 00 	ld.ub	r0,r5[-32768]
80005f9e:	eb 5c 80 00 	st.h	r5[-32768],r12
80005fa2:	eb 68 00 00 	st.b	r5[0],r8
80005fa6:	05 48       	ld.w	r8,--r2
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	eb 84       	*unknown*
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	eb a8 80 00 	stc.w	cp4,r8[0x0],cr0
80005fb2:	30 54       	mov	r4,5
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	eb d0 80 00 	ldswp.w	r0,r5[0]
80005fba:	eb f8 00 00 	ld.weq	r8,r5[0x0]
80005fbe:	0b 94       	ld.ub	r4,r5[0x1]

80005fc0 <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005fc0:	d4 31       	pushm	r0-r7,lr
80005fc2:	20 2d       	sub	sp,8
80005fc4:	18 95       	mov	r5,r12
80005fc6:	16 96       	mov	r6,r11
80005fc8:	14 93       	mov	r3,r10
	xgflash_status_t status = XG_ERROR;
	
	if(!list_init_success_flag)return XG_ERROR;
80005fca:	4c 78       	lddpc	r8,800060e4 <xgflash_get_message_data+0x124>
80005fcc:	11 89       	ld.ub	r9,r8[0x0]
80005fce:	30 08       	mov	r8,0
80005fd0:	f0 09 18 00 	cp.b	r9,r8
80005fd4:	c0 31       	brne	80005fda <xgflash_get_message_data+0x1a>
80005fd6:	3f f7       	mov	r7,-1
80005fd8:	c8 28       	rjmp	800060dc <xgflash_get_message_data+0x11c>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005fda:	4c 48       	lddpc	r8,800060e8 <xgflash_get_message_data+0x128>
80005fdc:	70 0c       	ld.w	r12,r8[0x0]
80005fde:	30 09       	mov	r9,0
80005fe0:	3f fa       	mov	r10,-1
80005fe2:	12 9b       	mov	r11,r9
80005fe4:	f0 1f 00 42 	mcall	800060ec <xgflash_get_message_data+0x12c>
	/* check input parameter */
	if (message_index > current_message_index)
80005fe8:	4c 28       	lddpc	r8,800060f0 <xgflash_get_message_data+0x130>
80005fea:	90 88       	ld.uh	r8,r8[0x0]
80005fec:	0a 38       	cp.w	r8,r5
80005fee:	c0 a2       	brcc	80006002 <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005ff0:	4b e8       	lddpc	r8,800060e8 <xgflash_get_message_data+0x128>
80005ff2:	70 0c       	ld.w	r12,r8[0x0]
80005ff4:	30 09       	mov	r9,0
80005ff6:	12 9a       	mov	r10,r9
80005ff8:	12 9b       	mov	r11,r9
80005ffa:	f0 1f 00 3f 	mcall	800060f4 <xgflash_get_message_data+0x134>
80005ffe:	30 17       	mov	r7,1
		return XG_INVALID_PARAM;
80006000:	c6 e8       	rjmp	800060dc <xgflash_get_message_data+0x11c>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80006002:	fa ca ff f8 	sub	r10,sp,-8
80006006:	30 08       	mov	r8,0
80006008:	30 09       	mov	r9,0
8000600a:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
8000600c:	1a 9a       	mov	r10,sp
8000600e:	30 8b       	mov	r11,8
80006010:	ea 0c 15 03 	lsl	r12,r5,0x3
80006014:	f0 1f 00 39 	mcall	800060f8 <xgflash_get_message_data+0x138>
	if (return_code == DF_OK)
80006018:	c5 a1       	brne	800060cc <xgflash_get_message_data+0x10c>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
8000601a:	9a 88       	ld.uh	r8,sp[0x0]
8000601c:	0a 38       	cp.w	r8,r5
8000601e:	c3 31       	brne	80006084 <xgflash_get_message_data+0xc4>
		{
			bytes_remained = ptr->offset;
80006020:	40 18       	lddsp	r8,sp[0x4]
80006022:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80006026:	9a 95       	ld.uh	r5,sp[0x2]
80006028:	b1 88       	lsr	r8,0x10
8000602a:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000602e:	30 04       	mov	r4,0
80006030:	08 92       	mov	r2,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80006032:	e0 61 01 ff 	mov	r1,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006036:	e0 60 02 00 	mov	r0,512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000603a:	c1 98       	rjmp	8000606c <xgflash_get_message_data+0xac>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000603c:	e2 07 19 00 	cp.h	r7,r1
80006040:	e0 8b 00 0a 	brhi	80006054 <xgflash_get_message_data+0x94>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80006044:	0c 9a       	mov	r10,r6
80006046:	0e 9b       	mov	r11,r7
80006048:	5c 7b       	castu.h	r11
8000604a:	0a 9c       	mov	r12,r5
8000604c:	f0 1f 00 2b 	mcall	800060f8 <xgflash_get_message_data+0x138>
80006050:	30 07       	mov	r7,0
80006052:	c0 d8       	rjmp	8000606c <xgflash_get_message_data+0xac>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006054:	0c 9a       	mov	r10,r6
80006056:	00 9b       	mov	r11,r0
80006058:	0a 9c       	mov	r12,r5
8000605a:	f0 1f 00 28 	mcall	800060f8 <xgflash_get_message_data+0x138>
					bytes_remained-=DF_DATA_SPACE_SIZE;
8000605e:	ee c7 02 00 	sub	r7,r7,512
80006062:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80006064:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80006068:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000606c:	e8 07 19 00 	cp.h	r7,r4
80006070:	5f 19       	srne	r9
80006072:	58 0c       	cp.w	r12,0
80006074:	5f 08       	sreq	r8
80006076:	f3 e8 00 08 	and	r8,r9,r8
8000607a:	e4 08 18 00 	cp.b	r8,r2
8000607e:	cd f1       	brne	8000603c <xgflash_get_message_data+0x7c>
80006080:	30 07       	mov	r7,0
80006082:	c0 58       	rjmp	8000608c <xgflash_get_message_data+0xcc>
			}
			status = XG_OK;
		}
		else
		{
			log("Err flash data\n");
80006084:	49 ec       	lddpc	r12,800060fc <xgflash_get_message_data+0x13c>
80006086:	f0 1f 00 1f 	mcall	80006100 <xgflash_get_message_data+0x140>
8000608a:	30 87       	mov	r7,8
			
			//xSemaphoreGive(xgflash_mutex);//unlock
			status = 8;
			//return 7;
		}
		if(erase)//erase the message
8000608c:	58 03       	cp.w	r3,0
8000608e:	c1 70       	breq	800060bc <xgflash_get_message_data+0xfc>
		{
			memset(str, 0x00, sizeof(str));
80006090:	30 08       	mov	r8,0
80006092:	30 09       	mov	r9,0
80006094:	fa e9 00 00 	st.d	sp[0],r8
			//reset:current_message_index and erase info
			current_message_index-=1;
80006098:	49 6c       	lddpc	r12,800060f0 <xgflash_get_message_data+0x130>
8000609a:	98 08       	ld.sh	r8,r12[0x0]
8000609c:	20 18       	sub	r8,1
8000609e:	b8 08       	st.h	r12[0x0],r8
			return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800060a0:	30 2a       	mov	r10,2
800060a2:	30 6b       	mov	r11,6
800060a4:	f0 1f 00 18 	mcall	80006104 <xgflash_get_message_data+0x144>
			if (return_code != DF_WRITE_COMPLETED)
800060a8:	58 7c       	cp.w	r12,7
800060aa:	c0 50       	breq	800060b4 <xgflash_get_message_data+0xf4>
			{
				log("data_flash_write 1...\n");
800060ac:	49 7c       	lddpc	r12,80006108 <xgflash_get_message_data+0x148>
800060ae:	f0 1f 00 15 	mcall	80006100 <xgflash_get_message_data+0x140>
800060b2:	30 77       	mov	r7,7
				//status = XG_FLASH_WRITE_FAIL;
			//}
					//
			////erase data and reset:current_save_message_offset
			//return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
			current_save_message_offset-=32;//出错在这...如果掉线，未执行，则会出现存储碎片
800060b4:	49 68       	lddpc	r8,8000610c <xgflash_get_message_data+0x14c>
800060b6:	70 09       	ld.w	r9,r8[0x0]
800060b8:	22 09       	sub	r9,32
800060ba:	91 09       	st.w	r8[0x0],r9
				//status = XG_FLASH_WRITE_FAIL;
			//}
					
		}
				
		xSemaphoreGive(xgflash_mutex);//unlock
800060bc:	48 b8       	lddpc	r8,800060e8 <xgflash_get_message_data+0x128>
800060be:	70 0c       	ld.w	r12,r8[0x0]
800060c0:	30 09       	mov	r9,0
800060c2:	12 9a       	mov	r10,r9
800060c4:	12 9b       	mov	r11,r9
800060c6:	f0 1f 00 0c 	mcall	800060f4 <xgflash_get_message_data+0x134>
		//status = XG_OK;
		return status;
800060ca:	c0 98       	rjmp	800060dc <xgflash_get_message_data+0x11c>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
800060cc:	48 78       	lddpc	r8,800060e8 <xgflash_get_message_data+0x128>
800060ce:	70 0c       	ld.w	r12,r8[0x0]
800060d0:	30 09       	mov	r9,0
800060d2:	12 9a       	mov	r10,r9
800060d4:	12 9b       	mov	r11,r9
800060d6:	f0 1f 00 08 	mcall	800060f4 <xgflash_get_message_data+0x134>
800060da:	30 67       	mov	r7,6
	return XG_FLASH_READ_FAIL;
		
}
800060dc:	0e 9c       	mov	r12,r7
800060de:	2f ed       	sub	sp,-8
800060e0:	d8 32       	popm	r0-r7,pc
800060e2:	00 00       	add	r0,r0
800060e4:	00 00       	add	r0,r0
800060e6:	0b 94       	ld.ub	r4,r5[0x1]
800060e8:	00 00       	add	r0,r0
800060ea:	0b 98       	ld.ub	r8,r5[0x1]
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	71 24       	ld.w	r4,r8[0x48]
800060f0:	00 00       	add	r0,r0
800060f2:	0b a4       	ld.ub	r4,r5[0x2]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	73 30       	ld.w	r0,r9[0x4c]
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	2e bc       	sub	r12,-21
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	ec 34 80 00 	sub	r4,884736
80006102:	7f 68       	ld.w	r8,pc[0x58]
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	30 f4       	mov	r4,15
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	ec 44 00 00 	cp.w	r4,786432
8000610e:	05 48       	ld.w	r8,--r2

80006110 <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
80006110:	d4 21       	pushm	r4-r7,lr
80006112:	20 2d       	sub	sp,8
80006114:	18 96       	mov	r6,r12
80006116:	16 97       	mov	r7,r11
80006118:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
8000611a:	4d 68       	lddpc	r8,80006270 <xgflash_message_save+0x160>
8000611c:	11 89       	ld.ub	r9,r8[0x0]
8000611e:	30 08       	mov	r8,0
80006120:	f0 09 18 00 	cp.b	r9,r8
80006124:	c0 31       	brne	8000612a <xgflash_message_save+0x1a>
80006126:	3f fc       	mov	r12,-1
80006128:	ca 28       	rjmp	8000626c <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
8000612a:	4d 38       	lddpc	r8,80006274 <xgflash_message_save+0x164>
8000612c:	70 0c       	ld.w	r12,r8[0x0]
8000612e:	30 09       	mov	r9,0
80006130:	3f fa       	mov	r10,-1
80006132:	12 9b       	mov	r11,r9
80006134:	f0 1f 00 51 	mcall	80006278 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80006138:	58 06       	cp.w	r6,0
8000613a:	5f 09       	sreq	r9
8000613c:	e0 68 02 00 	mov	r8,512
80006140:	f0 07 19 00 	cp.h	r7,r8
80006144:	5f b8       	srhi	r8
80006146:	f3 e8 10 08 	or	r8,r9,r8
8000614a:	c0 30       	breq	80006150 <xgflash_message_save+0x40>
8000614c:	30 1c       	mov	r12,1
8000614e:	c8 f8       	rjmp	8000626c <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
80006150:	0e 94       	mov	r4,r7
80006152:	5c 74       	castu.h	r4
80006154:	4c a9       	lddpc	r9,8000627c <xgflash_message_save+0x16c>
80006156:	72 08       	ld.w	r8,r9[0x0]
80006158:	e8 08 00 08 	add	r8,r4,r8
8000615c:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
8000615e:	e0 48 f0 00 	cp.w	r8,61440
80006162:	e0 88 00 07 	brls	80006170 <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
80006166:	30 09       	mov	r9,0
80006168:	4c 58       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
8000616a:	91 09       	st.w	r8[0x0],r9
8000616c:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
8000616e:	c7 f8       	rjmp	8000626c <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
80006170:	4c 48       	lddpc	r8,80006280 <xgflash_message_save+0x170>
80006172:	70 0b       	ld.w	r11,r8[0x0]
80006174:	e0 68 ff ff 	mov	r8,65535
80006178:	ea 18 00 7f 	orh	r8,0x7f
8000617c:	10 3b       	cp.w	r11,r8
8000617e:	e0 88 00 10 	brls	8000619e <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
80006182:	4c 1c       	lddpc	r12,80006284 <xgflash_message_save+0x174>
80006184:	f0 1f 00 41 	mcall	80006288 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
80006188:	30 0b       	mov	r11,0
8000618a:	4b d8       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
8000618c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000618e:	4b a8       	lddpc	r8,80006274 <xgflash_message_save+0x164>
80006190:	70 0c       	ld.w	r12,r8[0x0]
80006192:	16 99       	mov	r9,r11
80006194:	16 9a       	mov	r10,r11
80006196:	f0 1f 00 3e 	mcall	8000628c <xgflash_message_save+0x17c>
8000619a:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
8000619c:	c6 88       	rjmp	8000626c <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000619e:	0e 9a       	mov	r10,r7
800061a0:	5c 7a       	castu.h	r10
800061a2:	0c 9c       	mov	r12,r6
800061a4:	f0 1f 00 3b 	mcall	80006290 <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
800061a8:	58 7c       	cp.w	r12,7
800061aa:	c0 c0       	breq	800061c2 <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
800061ac:	30 0b       	mov	r11,0
800061ae:	4b 48       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
800061b0:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
800061b2:	4b 18       	lddpc	r8,80006274 <xgflash_message_save+0x164>
800061b4:	70 0c       	ld.w	r12,r8[0x0]
800061b6:	16 99       	mov	r9,r11
800061b8:	16 9a       	mov	r10,r11
800061ba:	f0 1f 00 35 	mcall	8000628c <xgflash_message_save+0x17c>
800061be:	30 7c       	mov	r12,7
		return XG_FLASH_WRITE_FAIL;
800061c0:	c5 68       	rjmp	8000626c <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
800061c2:	4b 08       	lddpc	r8,80006280 <xgflash_message_save+0x170>
800061c4:	70 09       	ld.w	r9,r8[0x0]
800061c6:	12 04       	add	r4,r9
800061c8:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
800061ca:	1a d4       	st.w	--sp,r4
800061cc:	4b 2c       	lddpc	r12,80006294 <xgflash_message_save+0x184>
800061ce:	f0 1f 00 2f 	mcall	80006288 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
800061d2:	2f fd       	sub	sp,-4
800061d4:	30 18       	mov	r8,1
800061d6:	f0 05 18 00 	cp.b	r5,r8
800061da:	c4 11       	brne	8000625c <xgflash_message_save+0x14c>
	{
		current_message_index++;
800061dc:	4a f9       	lddpc	r9,80006298 <xgflash_message_save+0x188>
800061de:	92 08       	ld.sh	r8,r9[0x0]
800061e0:	2f f8       	sub	r8,-1
800061e2:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
800061e4:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
800061e6:	4a 69       	lddpc	r9,8000627c <xgflash_message_save+0x16c>
800061e8:	72 09       	ld.w	r9,r9[0x0]
800061ea:	4a 6a       	lddpc	r10,80006280 <xgflash_message_save+0x170>
800061ec:	74 0a       	ld.w	r10,r10[0x0]
800061ee:	12 1a       	sub	r10,r9
800061f0:	40 0b       	lddsp	r11,sp[0x0]
800061f2:	e0 1b 00 00 	andl	r11,0x0
800061f6:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
800061fa:	50 0b       	stdsp	sp[0x0],r11
800061fc:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
800061fe:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80006200:	5c 78       	castu.h	r8
80006202:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80006206:	e2 4b 00 00 	cp.w	r11,131072
8000620a:	e0 88 00 10 	brls	8000622a <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
8000620e:	4a 4c       	lddpc	r12,8000629c <xgflash_message_save+0x18c>
80006210:	f0 1f 00 1e 	mcall	80006288 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
80006214:	30 0b       	mov	r11,0
80006216:	49 a8       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
80006218:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
8000621a:	49 78       	lddpc	r8,80006274 <xgflash_message_save+0x164>
8000621c:	70 0c       	ld.w	r12,r8[0x0]
8000621e:	16 99       	mov	r9,r11
80006220:	16 9a       	mov	r10,r11
80006222:	f0 1f 00 1b 	mcall	8000628c <xgflash_message_save+0x17c>
80006226:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80006228:	c2 28       	rjmp	8000626c <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
8000622a:	30 8a       	mov	r10,8
8000622c:	1a 9c       	mov	r12,sp
8000622e:	f0 1f 00 19 	mcall	80006290 <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80006232:	30 2a       	mov	r10,2
80006234:	30 6b       	mov	r11,6
80006236:	49 9c       	lddpc	r12,80006298 <xgflash_message_save+0x188>
80006238:	f0 1f 00 16 	mcall	80006290 <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
8000623c:	58 7c       	cp.w	r12,7
8000623e:	c0 c0       	breq	80006256 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
80006240:	30 0b       	mov	r11,0
80006242:	48 f8       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
80006244:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006246:	48 c8       	lddpc	r8,80006274 <xgflash_message_save+0x164>
80006248:	70 0c       	ld.w	r12,r8[0x0]
8000624a:	16 99       	mov	r9,r11
8000624c:	16 9a       	mov	r10,r11
8000624e:	f0 1f 00 10 	mcall	8000628c <xgflash_message_save+0x17c>
80006252:	30 7c       	mov	r12,7
			return XG_FLASH_WRITE_FAIL;
80006254:	c0 c8       	rjmp	8000626c <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
80006256:	30 09       	mov	r9,0
80006258:	48 98       	lddpc	r8,8000627c <xgflash_message_save+0x16c>
8000625a:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
8000625c:	48 68       	lddpc	r8,80006274 <xgflash_message_save+0x164>
8000625e:	70 0c       	ld.w	r12,r8[0x0]
80006260:	30 09       	mov	r9,0
80006262:	12 9a       	mov	r10,r9
80006264:	12 9b       	mov	r11,r9
80006266:	f0 1f 00 0a 	mcall	8000628c <xgflash_message_save+0x17c>
8000626a:	30 0c       	mov	r12,0
	return XG_OK;

}
8000626c:	2f ed       	sub	sp,-8
8000626e:	d8 22       	popm	r4-r7,pc
80006270:	00 00       	add	r0,r0
80006272:	0b 94       	ld.ub	r4,r5[0x1]
80006274:	00 00       	add	r0,r0
80006276:	0b 98       	ld.ub	r8,r5[0x1]
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	71 24       	ld.w	r4,r8[0x48]
8000627c:	00 00       	add	r0,r0
8000627e:	0b f8       	ld.ub	r8,r5[0x7]
80006280:	00 00       	add	r0,r0
80006282:	05 48       	ld.w	r8,--r2
80006284:	80 00       	ld.sh	r0,r0[0x0]
80006286:	ec 5c 80 00 	cp.w	r12,884736
8000628a:	7f 68       	ld.w	r8,pc[0x58]
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	73 30       	ld.w	r0,r9[0x4c]
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	30 f4       	mov	r4,15
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	eb 84       	*unknown*
80006298:	00 00       	add	r0,r0
8000629a:	0b a4       	ld.ub	r4,r5[0x2]
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	ec 8c eb cd 	brvs	801a3a38 <_data_lma+0x1943e8>

800062a0 <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
800062a0:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
800062a4:	48 d8       	lddpc	r8,800062d8 <xgflash_get_message_count+0x38>
800062a6:	11 89       	ld.ub	r9,r8[0x0]
800062a8:	30 08       	mov	r8,0
800062aa:	f0 09 18 00 	cp.b	r9,r8
800062ae:	c0 31       	brne	800062b4 <xgflash_get_message_count+0x14>
800062b0:	3f f7       	mov	r7,-1
800062b2:	c1 08       	rjmp	800062d2 <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
800062b4:	48 a6       	lddpc	r6,800062dc <xgflash_get_message_count+0x3c>
800062b6:	6c 0c       	ld.w	r12,r6[0x0]
800062b8:	30 09       	mov	r9,0
800062ba:	3f fa       	mov	r10,-1
800062bc:	12 9b       	mov	r11,r9
800062be:	f0 1f 00 09 	mcall	800062e0 <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
800062c2:	48 98       	lddpc	r8,800062e4 <xgflash_get_message_count+0x44>
800062c4:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
800062c6:	6c 0c       	ld.w	r12,r6[0x0]
800062c8:	30 09       	mov	r9,0
800062ca:	12 9a       	mov	r10,r9
800062cc:	12 9b       	mov	r11,r9
800062ce:	f0 1f 00 07 	mcall	800062e8 <xgflash_get_message_count+0x48>

	return return_value;
	
}
800062d2:	0e 9c       	mov	r12,r7
800062d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062d8:	00 00       	add	r0,r0
800062da:	0b 94       	ld.ub	r4,r5[0x1]
800062dc:	00 00       	add	r0,r0
800062de:	0b 98       	ld.ub	r8,r5[0x1]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	71 24       	ld.w	r4,r8[0x48]
800062e4:	00 00       	add	r0,r0
800062e6:	0b a4       	ld.ub	r4,r5[0x2]
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	73 30       	ld.w	r0,r9[0x4c]

800062ec <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800062ec:	fe 68 14 00 	mov	r8,-125952
800062f0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800062f2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800062f6:	91 09       	st.w	r8[0x0],r9
}
800062f8:	5e fc       	retal	r12

800062fa <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800062fa:	f8 08 16 05 	lsr	r8,r12,0x5
800062fe:	a9 68       	lsl	r8,0x8
80006300:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006304:	58 1b       	cp.w	r11,1
80006306:	c0 d0       	breq	80006320 <gpio_enable_module_pin+0x26>
80006308:	c0 63       	brcs	80006314 <gpio_enable_module_pin+0x1a>
8000630a:	58 2b       	cp.w	r11,2
8000630c:	c1 00       	breq	8000632c <gpio_enable_module_pin+0x32>
8000630e:	58 3b       	cp.w	r11,3
80006310:	c1 40       	breq	80006338 <gpio_enable_module_pin+0x3e>
80006312:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006314:	30 19       	mov	r9,1
80006316:	f2 0c 09 49 	lsl	r9,r9,r12
8000631a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000631c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000631e:	c1 28       	rjmp	80006342 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006320:	30 19       	mov	r9,1
80006322:	f2 0c 09 49 	lsl	r9,r9,r12
80006326:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006328:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000632a:	c0 c8       	rjmp	80006342 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000632c:	30 19       	mov	r9,1
8000632e:	f2 0c 09 49 	lsl	r9,r9,r12
80006332:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006334:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006336:	c0 68       	rjmp	80006342 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006338:	30 19       	mov	r9,1
8000633a:	f2 0c 09 49 	lsl	r9,r9,r12
8000633e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006340:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006342:	30 19       	mov	r9,1
80006344:	f2 0c 09 4c 	lsl	r12,r9,r12
80006348:	91 2c       	st.w	r8[0x8],r12
8000634a:	5e fd       	retal	0

8000634c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000634c:	d4 21       	pushm	r4-r7,lr
8000634e:	18 97       	mov	r7,r12
80006350:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006352:	58 0b       	cp.w	r11,0
80006354:	c0 31       	brne	8000635a <gpio_enable_module+0xe>
80006356:	30 05       	mov	r5,0
80006358:	c0 d8       	rjmp	80006372 <gpio_enable_module+0x26>
8000635a:	30 06       	mov	r6,0
8000635c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000635e:	6e 1b       	ld.w	r11,r7[0x4]
80006360:	6e 0c       	ld.w	r12,r7[0x0]
80006362:	f0 1f 00 06 	mcall	80006378 <gpio_enable_module+0x2c>
80006366:	18 45       	or	r5,r12
		gpiomap++;
80006368:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000636a:	2f f6       	sub	r6,-1
8000636c:	0c 34       	cp.w	r4,r6
8000636e:	fe 9b ff f8 	brhi	8000635e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006372:	0a 9c       	mov	r12,r5
80006374:	d8 22       	popm	r4-r7,pc
80006376:	00 00       	add	r0,r0
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	62 fa       	ld.w	r10,r1[0x3c]

8000637c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000637c:	f8 08 16 05 	lsr	r8,r12,0x5
80006380:	a9 68       	lsl	r8,0x8
80006382:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006386:	30 19       	mov	r9,1
80006388:	f2 0c 09 4c 	lsl	r12,r9,r12
8000638c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006390:	91 1c       	st.w	r8[0x4],r12
}
80006392:	5e fc       	retal	r12

80006394 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006394:	f8 08 16 05 	lsr	r8,r12,0x5
80006398:	a9 68       	lsl	r8,0x8
8000639a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000639e:	30 19       	mov	r9,1
800063a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800063a4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800063a8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800063ac:	91 1c       	st.w	r8[0x4],r12
}
800063ae:	5e fc       	retal	r12

800063b0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800063b0:	f8 08 16 05 	lsr	r8,r12,0x5
800063b4:	a9 68       	lsl	r8,0x8
800063b6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800063ba:	30 19       	mov	r9,1
800063bc:	f2 0c 09 4c 	lsl	r12,r9,r12
800063c0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800063c4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800063c8:	91 1c       	st.w	r8[0x4],r12
}
800063ca:	5e fc       	retal	r12

800063cc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800063cc:	c0 08       	rjmp	800063cc <_unhandled_interrupt>
800063ce:	d7 03       	nop

800063d0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800063d0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800063d4:	49 99       	lddpc	r9,80006438 <INTC_register_interrupt+0x68>
800063d6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800063da:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800063de:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800063e0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800063e4:	58 0a       	cp.w	r10,0
800063e6:	c0 91       	brne	800063f8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800063e8:	49 59       	lddpc	r9,8000643c <INTC_register_interrupt+0x6c>
800063ea:	49 6a       	lddpc	r10,80006440 <INTC_register_interrupt+0x70>
800063ec:	12 1a       	sub	r10,r9
800063ee:	fe 79 08 00 	mov	r9,-63488
800063f2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800063f6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800063f8:	58 1a       	cp.w	r10,1
800063fa:	c0 a1       	brne	8000640e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800063fc:	49 09       	lddpc	r9,8000643c <INTC_register_interrupt+0x6c>
800063fe:	49 2a       	lddpc	r10,80006444 <INTC_register_interrupt+0x74>
80006400:	12 1a       	sub	r10,r9
80006402:	bf aa       	sbr	r10,0x1e
80006404:	fe 79 08 00 	mov	r9,-63488
80006408:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000640c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000640e:	58 2a       	cp.w	r10,2
80006410:	c0 a1       	brne	80006424 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80006412:	48 b9       	lddpc	r9,8000643c <INTC_register_interrupt+0x6c>
80006414:	48 da       	lddpc	r10,80006448 <INTC_register_interrupt+0x78>
80006416:	12 1a       	sub	r10,r9
80006418:	bf ba       	sbr	r10,0x1f
8000641a:	fe 79 08 00 	mov	r9,-63488
8000641e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006422:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006424:	48 69       	lddpc	r9,8000643c <INTC_register_interrupt+0x6c>
80006426:	48 aa       	lddpc	r10,8000644c <INTC_register_interrupt+0x7c>
80006428:	12 1a       	sub	r10,r9
8000642a:	ea 1a c0 00 	orh	r10,0xc000
8000642e:	fe 79 08 00 	mov	r9,-63488
80006432:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006436:	5e fc       	retal	r12
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	ed 1c 80 00 	ld.uh	r12,r6[-32768]
8000643e:	de 00       	acall	0xe0
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	df 04       	*unknown*
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	df 12       	popm	r0-r3,r11-r12,lr-pc
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	df 20       	acall	0xf2
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	df 2e       	*unknown*

80006450 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006450:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006452:	49 18       	lddpc	r8,80006494 <INTC_init_interrupts+0x44>
80006454:	e3 b8 00 01 	mtsr	0x4,r8
80006458:	49 0e       	lddpc	lr,80006498 <INTC_init_interrupts+0x48>
8000645a:	30 07       	mov	r7,0
8000645c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000645e:	49 0c       	lddpc	r12,8000649c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006460:	49 05       	lddpc	r5,800064a0 <INTC_init_interrupts+0x50>
80006462:	10 15       	sub	r5,r8
80006464:	fe 76 08 00 	mov	r6,-63488
80006468:	c1 08       	rjmp	80006488 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000646a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000646c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000646e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006470:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006474:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006476:	10 3a       	cp.w	r10,r8
80006478:	fe 9b ff fc 	brhi	80006470 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000647c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006480:	2f f7       	sub	r7,-1
80006482:	2f 8e       	sub	lr,-8
80006484:	59 37       	cp.w	r7,19
80006486:	c0 50       	breq	80006490 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006488:	7c 08       	ld.w	r8,lr[0x0]
8000648a:	58 08       	cp.w	r8,0
8000648c:	ce f1       	brne	8000646a <INTC_init_interrupts+0x1a>
8000648e:	cf 7b       	rjmp	8000647c <INTC_init_interrupts+0x2c>
80006490:	d8 22       	popm	r4-r7,pc
80006492:	00 00       	add	r0,r0
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	de 00       	acall	0xe0
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	ed 1c 80 00 	ld.uh	r12,r6[-32768]
8000649e:	63 cc       	ld.w	r12,r1[0x70]
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	df 04       	*unknown*

800064a4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800064a4:	fe 78 08 00 	mov	r8,-63488
800064a8:	e0 69 00 83 	mov	r9,131
800064ac:	f2 0c 01 0c 	sub	r12,r9,r12
800064b0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800064b4:	f2 ca ff c0 	sub	r10,r9,-64
800064b8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064bc:	58 08       	cp.w	r8,0
800064be:	c0 21       	brne	800064c2 <_get_interrupt_handler+0x1e>
800064c0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800064c2:	f0 08 12 00 	clz	r8,r8
800064c6:	48 5a       	lddpc	r10,800064d8 <_get_interrupt_handler+0x34>
800064c8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800064cc:	f0 08 11 1f 	rsub	r8,r8,31
800064d0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064d2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800064d6:	5e fc       	retal	r12
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	ed 1c 78 a8 	ld.uh	r12,r6[30888]

800064dc <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800064dc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800064de:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800064e2:	99 a8       	st.w	r12[0x28],r8
}
800064e4:	5e fc       	retal	r12
800064e6:	d7 03       	nop

800064e8 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800064e8:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800064ea:	ec 5b bb 9f 	cp.w	r11,899999
800064ee:	e0 8b 00 04 	brhi	800064f6 <pm_enable_osc0_crystal+0xe>
800064f2:	30 4b       	mov	r11,4
800064f4:	c1 38       	rjmp	8000651a <pm_enable_osc0_crystal+0x32>
800064f6:	e0 68 c6 bf 	mov	r8,50879
800064fa:	ea 18 00 2d 	orh	r8,0x2d
800064fe:	10 3b       	cp.w	r11,r8
80006500:	e0 8b 00 04 	brhi	80006508 <pm_enable_osc0_crystal+0x20>
80006504:	30 5b       	mov	r11,5
80006506:	c0 a8       	rjmp	8000651a <pm_enable_osc0_crystal+0x32>
80006508:	e0 68 12 00 	mov	r8,4608
8000650c:	ea 18 00 7a 	orh	r8,0x7a
80006510:	10 3b       	cp.w	r11,r8
80006512:	f9 bb 03 06 	movlo	r11,6
80006516:	f9 bb 02 07 	movhs	r11,7
8000651a:	f0 1f 00 02 	mcall	80006520 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000651e:	d8 02       	popm	pc
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	64 dc       	ld.w	r12,r2[0x34]

80006524 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006524:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006526:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000652a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000652c:	78 08       	ld.w	r8,r12[0x0]
8000652e:	a3 a8       	sbr	r8,0x2
80006530:	99 08       	st.w	r12[0x0],r8
}
80006532:	5e fc       	retal	r12

80006534 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006534:	79 58       	ld.w	r8,r12[0x54]
80006536:	e2 18 00 80 	andl	r8,0x80,COH
8000653a:	cf d0       	breq	80006534 <pm_wait_for_clk0_ready>
}
8000653c:	5e fc       	retal	r12
8000653e:	d7 03       	nop

80006540 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80006540:	eb cd 40 80 	pushm	r7,lr
80006544:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006546:	f0 1f 00 04 	mcall	80006554 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000654a:	0e 9c       	mov	r12,r7
8000654c:	f0 1f 00 03 	mcall	80006558 <pm_enable_clk0+0x18>
}
80006550:	e3 cd 80 80 	ldm	sp++,r7,pc
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	65 24       	ld.w	r4,r2[0x48]
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	65 34       	ld.w	r4,r2[0x4c]

8000655c <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
8000655c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000655e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006562:	99 c8       	st.w	r12[0x30],r8
}
80006564:	5e fc       	retal	r12
80006566:	d7 03       	nop

80006568 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80006568:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000656a:	30 1b       	mov	r11,1
8000656c:	f0 1f 00 02 	mcall	80006574 <pm_enable_osc32_crystal+0xc>
}
80006570:	d8 02       	popm	pc
80006572:	00 00       	add	r0,r0
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	65 5c       	ld.w	r12,r2[0x54]

80006578 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006578:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000657a:	30 19       	mov	r9,1
8000657c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80006580:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006584:	99 c8       	st.w	r12[0x30],r8
}
80006586:	5e fc       	retal	r12

80006588 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80006588:	79 58       	ld.w	r8,r12[0x54]
8000658a:	e2 18 02 00 	andl	r8,0x200,COH
8000658e:	cf d0       	breq	80006588 <pm_wait_for_clk32_ready>
}
80006590:	5e fc       	retal	r12
80006592:	d7 03       	nop

80006594 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006594:	eb cd 40 80 	pushm	r7,lr
80006598:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000659a:	f0 1f 00 04 	mcall	800065a8 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000659e:	0e 9c       	mov	r12,r7
800065a0:	f0 1f 00 03 	mcall	800065ac <pm_enable_clk32+0x18>
}
800065a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	65 78       	ld.w	r8,r2[0x5c]
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	65 88       	ld.w	r8,r2[0x60]

800065b0 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800065b0:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800065b4:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800065b8:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800065ba:	09 f7       	ld.ub	r7,r4[0x7]
800065bc:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800065c0:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800065c4:	09 b4       	ld.ub	r4,r4[0x3]
800065c6:	08 96       	mov	r6,r4
800065c8:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800065cc:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800065d0:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800065d4:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800065d8:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800065dc:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800065e0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800065e4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800065e8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800065ea:	79 58       	ld.w	r8,r12[0x54]
800065ec:	e2 18 00 20 	andl	r8,0x20,COH
800065f0:	cf d0       	breq	800065ea <pm_cksel+0x3a>
}
800065f2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800065f6 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800065f6:	eb cd 40 80 	pushm	r7,lr
800065fa:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800065fc:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800065fe:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006602:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006606:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000660a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000660e:	2f 8b       	sub	r11,-8
80006610:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006614:	e3 cd 80 80 	ldm	sp++,r7,pc

80006618 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006618:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000661a:	2f 8b       	sub	r11,-8
8000661c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80006620:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006624:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006628:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000662c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006630:	d8 02       	popm	pc

80006632 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80006632:	2f 8b       	sub	r11,-8
80006634:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006638:	a1 a8       	sbr	r8,0x0
8000663a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000663e:	5e fc       	retal	r12

80006640 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006640:	79 58       	ld.w	r8,r12[0x54]
80006642:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006646:	cf d0       	breq	80006640 <pm_wait_for_pll0_locked>
}
80006648:	5e fc       	retal	r12

8000664a <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000664a:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000664c:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80006650:	99 08       	st.w	r12[0x0],r8
}
80006652:	5e fc       	retal	r12

80006654 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006654:	eb cd 40 c0 	pushm	r6-r7,lr
80006658:	18 97       	mov	r7,r12
8000665a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000665c:	f0 1f 00 06 	mcall	80006674 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80006660:	0c 9b       	mov	r11,r6
80006662:	0e 9c       	mov	r12,r7
80006664:	f0 1f 00 05 	mcall	80006678 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006668:	30 1b       	mov	r11,1
8000666a:	0e 9c       	mov	r12,r7
8000666c:	f0 1f 00 04 	mcall	8000667c <pm_switch_to_osc0+0x28>
}
80006670:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	64 e8       	ld.w	r8,r2[0x38]
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	65 40       	ld.w	r0,r2[0x50]
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	66 4a       	ld.w	r10,r3[0x10]

80006680 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80006680:	78 0c       	ld.w	r12,r12[0x0]
}
80006682:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80006686:	5e fc       	retal	r12

80006688 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80006688:	eb cd 40 c0 	pushm	r6-r7,lr
8000668c:	18 97       	mov	r7,r12
8000668e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80006690:	0e 9c       	mov	r12,r7
80006692:	f0 1f 00 06 	mcall	800066a8 <rtc_set_value+0x20>
80006696:	cf d1       	brne	80006690 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80006698:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000669a:	0e 9c       	mov	r12,r7
8000669c:	f0 1f 00 03 	mcall	800066a8 <rtc_set_value+0x20>
800066a0:	cf d1       	brne	8000669a <rtc_set_value+0x12>
}
800066a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066a6:	00 00       	add	r0,r0
800066a8:	80 00       	ld.sh	r0,r0[0x0]
800066aa:	66 80       	ld.w	r0,r3[0x20]

800066ac <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800066ac:	eb cd 40 80 	pushm	r7,lr
800066b0:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800066b2:	0e 9c       	mov	r12,r7
800066b4:	f0 1f 00 06 	mcall	800066cc <rtc_enable+0x20>
800066b8:	cf d1       	brne	800066b2 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800066ba:	6e 08       	ld.w	r8,r7[0x0]
800066bc:	a1 a8       	sbr	r8,0x0
800066be:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066c0:	0e 9c       	mov	r12,r7
800066c2:	f0 1f 00 03 	mcall	800066cc <rtc_enable+0x20>
800066c6:	cf d1       	brne	800066c0 <rtc_enable+0x14>
}
800066c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800066cc:	80 00       	ld.sh	r0,r0[0x0]
800066ce:	66 80       	ld.w	r0,r3[0x20]

800066d0 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800066d0:	30 18       	mov	r8,1
800066d2:	99 48       	st.w	r12[0x10],r8
}
800066d4:	5e fc       	retal	r12
800066d6:	d7 03       	nop

800066d8 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800066d8:	eb cd 40 c0 	pushm	r6-r7,lr
800066dc:	18 97       	mov	r7,r12
800066de:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800066e0:	0e 9c       	mov	r12,r7
800066e2:	f0 1f 00 06 	mcall	800066f8 <rtc_set_top_value+0x20>
800066e6:	cf d1       	brne	800066e0 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800066e8:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066ea:	0e 9c       	mov	r12,r7
800066ec:	f0 1f 00 03 	mcall	800066f8 <rtc_set_top_value+0x20>
800066f0:	cf d1       	brne	800066ea <rtc_set_top_value+0x12>
}
800066f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066f6:	00 00       	add	r0,r0
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	66 80       	ld.w	r0,r3[0x20]

800066fc <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800066fc:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80006700:	e6 18 00 01 	andh	r8,0x1,COH
80006704:	c0 71       	brne	80006712 <rtc_clear_interrupt+0x16>
80006706:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006708:	30 18       	mov	r8,1
8000670a:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000670c:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000670e:	d5 03       	csrf	0x10
80006710:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006712:	30 18       	mov	r8,1
80006714:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006716:	78 78       	ld.w	r8,r12[0x1c]
80006718:	5e fc       	retal	r12
8000671a:	d7 03       	nop

8000671c <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
8000671c:	eb cd 40 e0 	pushm	r5-r7,lr
80006720:	18 97       	mov	r7,r12
80006722:	16 96       	mov	r6,r11
80006724:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80006726:	30 18       	mov	r8,1
80006728:	f0 0b 18 00 	cp.b	r11,r8
8000672c:	5f b9       	srhi	r9
8000672e:	30 f8       	mov	r8,15
80006730:	f0 0a 18 00 	cp.b	r10,r8
80006734:	5f b8       	srhi	r8
80006736:	f3 e8 10 08 	or	r8,r9,r8
8000673a:	c0 30       	breq	80006740 <rtc_init+0x24>
8000673c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80006740:	30 18       	mov	r8,1
80006742:	f0 0b 18 00 	cp.b	r11,r8
80006746:	c0 a1       	brne	8000675a <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80006748:	fe 7c 0c 00 	mov	r12,-62464
8000674c:	f0 1f 00 0f 	mcall	80006788 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80006750:	30 0b       	mov	r11,0
80006752:	fe 7c 0c 00 	mov	r12,-62464
80006756:	f0 1f 00 0e 	mcall	8000678c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000675a:	0e 9c       	mov	r12,r7
8000675c:	f0 1f 00 0d 	mcall	80006790 <rtc_init+0x74>
80006760:	cf d1       	brne	8000675a <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80006762:	a3 76       	lsl	r6,0x3
80006764:	b1 a6       	sbr	r6,0x10
80006766:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000676a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
8000676c:	0e 9c       	mov	r12,r7
8000676e:	f0 1f 00 09 	mcall	80006790 <rtc_init+0x74>
80006772:	cf d1       	brne	8000676c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006774:	30 0b       	mov	r11,0
80006776:	0e 9c       	mov	r12,r7
80006778:	f0 1f 00 07 	mcall	80006794 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
8000677c:	3f fb       	mov	r11,-1
8000677e:	0e 9c       	mov	r12,r7
80006780:	f0 1f 00 06 	mcall	80006798 <rtc_init+0x7c>
80006784:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	65 68       	ld.w	r8,r2[0x58]
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	65 94       	ld.w	r4,r2[0x64]
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	66 80       	ld.w	r0,r3[0x20]
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	66 88       	ld.w	r8,r3[0x20]
80006798:	80 00       	ld.sh	r0,r0[0x0]
8000679a:	66 d8       	ld.w	r8,r3[0x34]

8000679c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000679c:	f8 c8 00 01 	sub	r8,r12,1
800067a0:	f0 0b 00 0b 	add	r11,r8,r11
800067a4:	f6 0c 0d 0a 	divu	r10,r11,r12
800067a8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800067aa:	f4 c8 00 01 	sub	r8,r10,1
800067ae:	e0 48 00 fe 	cp.w	r8,254
800067b2:	e0 88 00 03 	brls	800067b8 <getBaudDiv+0x1c>
800067b6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800067b8:	5c 8c       	casts.h	r12
}
800067ba:	5e fc       	retal	r12

800067bc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800067bc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067c0:	30 18       	mov	r8,1
800067c2:	f0 09 18 00 	cp.b	r9,r8
800067c6:	e0 88 00 04 	brls	800067ce <spi_initMaster+0x12>
800067ca:	30 2c       	mov	r12,2
800067cc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800067ce:	e0 68 00 80 	mov	r8,128
800067d2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800067d4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800067d6:	30 19       	mov	r9,1
800067d8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800067dc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067e0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800067e4:	30 09       	mov	r9,0
800067e6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800067ea:	30 fa       	mov	r10,15
800067ec:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800067f0:	99 18       	st.w	r12[0x4],r8
800067f2:	5e f9       	retal	r9

800067f4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800067f4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800067f6:	30 18       	mov	r8,1
800067f8:	f0 0b 18 00 	cp.b	r11,r8
800067fc:	5f be       	srhi	lr
800067fe:	f0 0a 18 00 	cp.b	r10,r8
80006802:	5f b8       	srhi	r8
80006804:	fd e8 10 08 	or	r8,lr,r8
80006808:	c0 30       	breq	8000680e <spi_selectionMode+0x1a>
8000680a:	30 2c       	mov	r12,2
8000680c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000680e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006810:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006814:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006818:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000681c:	99 18       	st.w	r12[0x4],r8
8000681e:	d8 0a       	popm	pc,r12=0

80006820 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006820:	30 18       	mov	r8,1
80006822:	99 08       	st.w	r12[0x0],r8
}
80006824:	5e fc       	retal	r12

80006826 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006826:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000682a:	c0 58       	rjmp	80006834 <spi_write+0xe>
		if (!timeout--) {
8000682c:	58 08       	cp.w	r8,0
8000682e:	c0 21       	brne	80006832 <spi_write+0xc>
80006830:	5e ff       	retal	1
80006832:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006834:	78 49       	ld.w	r9,r12[0x10]
80006836:	e2 19 00 02 	andl	r9,0x2,COH
8000683a:	cf 90       	breq	8000682c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000683c:	5c 7b       	castu.h	r11
8000683e:	99 3b       	st.w	r12[0xc],r11
80006840:	5e fd       	retal	0

80006842 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80006842:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006846:	c0 58       	rjmp	80006850 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80006848:	58 08       	cp.w	r8,0
8000684a:	c0 21       	brne	8000684e <spi_read+0xc>
8000684c:	5e ff       	retal	1
8000684e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006850:	78 49       	ld.w	r9,r12[0x10]
80006852:	e2 19 02 01 	andl	r9,0x201,COH
80006856:	e0 49 02 01 	cp.w	r9,513
8000685a:	cf 71       	brne	80006848 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000685c:	78 28       	ld.w	r8,r12[0x8]
8000685e:	b6 08       	st.h	r11[0x0],r8
80006860:	5e fd       	retal	0
80006862:	d7 03       	nop

80006864 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006864:	eb cd 40 f8 	pushm	r3-r7,lr
80006868:	18 95       	mov	r5,r12
8000686a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000686c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006870:	30 38       	mov	r8,3
80006872:	f0 06 18 00 	cp.b	r6,r8
80006876:	e0 8b 00 5e 	brhi	80006932 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000687a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000687e:	30 18       	mov	r8,1
80006880:	f0 04 18 00 	cp.b	r4,r8
80006884:	e0 8b 00 57 	brhi	80006932 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006888:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000688c:	30 78       	mov	r8,7
8000688e:	f0 03 18 00 	cp.b	r3,r8
80006892:	e0 88 00 50 	brls	80006932 <spi_setupChipReg+0xce>
80006896:	31 08       	mov	r8,16
80006898:	f0 03 18 00 	cp.b	r3,r8
8000689c:	e0 8b 00 4b 	brhi	80006932 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800068a0:	14 9b       	mov	r11,r10
800068a2:	6e 1c       	ld.w	r12,r7[0x4]
800068a4:	f0 1f 00 26 	mcall	8000693c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800068a8:	c4 55       	brlt	80006932 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800068aa:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800068ac:	ec 09 16 01 	lsr	r9,r6,0x1
800068b0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800068b4:	ec 16 00 01 	eorl	r6,0x1
800068b8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800068bc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800068c0:	20 83       	sub	r3,8
800068c2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800068c6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800068ca:	ef 39 00 09 	ld.ub	r9,r7[9]
800068ce:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800068d2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800068d6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800068da:	0f 89       	ld.ub	r9,r7[0x0]
800068dc:	30 1a       	mov	r10,1
800068de:	f4 09 18 00 	cp.b	r9,r10
800068e2:	c0 d0       	breq	800068fc <spi_setupChipReg+0x98>
800068e4:	c0 a3       	brcs	800068f8 <spi_setupChipReg+0x94>
800068e6:	30 2a       	mov	r10,2
800068e8:	f4 09 18 00 	cp.b	r9,r10
800068ec:	c0 a0       	breq	80006900 <spi_setupChipReg+0x9c>
800068ee:	30 3a       	mov	r10,3
800068f0:	f4 09 18 00 	cp.b	r9,r10
800068f4:	c1 f1       	brne	80006932 <spi_setupChipReg+0xce>
800068f6:	c0 78       	rjmp	80006904 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800068f8:	8b c8       	st.w	r5[0x30],r8
		break;
800068fa:	c0 68       	rjmp	80006906 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800068fc:	8b d8       	st.w	r5[0x34],r8
		break;
800068fe:	c0 48       	rjmp	80006906 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80006900:	8b e8       	st.w	r5[0x38],r8
		break;
80006902:	c0 28       	rjmp	80006906 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006904:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006906:	48 f8       	lddpc	r8,80006940 <spi_setupChipReg+0xdc>
80006908:	70 08       	ld.w	r8,r8[0x0]
8000690a:	58 08       	cp.w	r8,0
8000690c:	c1 61       	brne	80006938 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000690e:	30 0b       	mov	r11,0
80006910:	30 1c       	mov	r12,1
80006912:	f0 1f 00 0d 	mcall	80006944 <spi_setupChipReg+0xe0>
80006916:	48 b8       	lddpc	r8,80006940 <spi_setupChipReg+0xdc>
80006918:	91 0c       	st.w	r8[0x0],r12
8000691a:	58 0c       	cp.w	r12,0
8000691c:	c0 a0       	breq	80006930 <spi_setupChipReg+0xcc>
8000691e:	30 09       	mov	r9,0
80006920:	12 9a       	mov	r10,r9
80006922:	12 9b       	mov	r11,r9
80006924:	f0 1f 00 09 	mcall	80006948 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006928:	48 68       	lddpc	r8,80006940 <spi_setupChipReg+0xdc>
8000692a:	70 08       	ld.w	r8,r8[0x0]
8000692c:	58 08       	cp.w	r8,0
8000692e:	c0 51       	brne	80006938 <spi_setupChipReg+0xd4>
80006930:	c0 08       	rjmp	80006930 <spi_setupChipReg+0xcc>
80006932:	30 2c       	mov	r12,2
80006934:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006938:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	67 9c       	ld.w	r12,r3[0x64]
80006940:	00 00       	add	r0,r0
80006942:	a6 bc       	st.b	r3[0x3],r12
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	74 88       	ld.w	r8,r10[0x20]
80006948:	80 00       	ld.sh	r0,r0[0x0]
8000694a:	73 30       	ld.w	r0,r9[0x4c]

8000694c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000694c:	d4 01       	pushm	lr
8000694e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006952:	c0 58       	rjmp	8000695c <spi_unselectChip+0x10>
		if (!timeout--) {
80006954:	58 08       	cp.w	r8,0
80006956:	c0 21       	brne	8000695a <spi_unselectChip+0xe>
80006958:	da 0a       	popm	pc,r12=1
8000695a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000695c:	78 49       	ld.w	r9,r12[0x10]
8000695e:	e2 19 02 00 	andl	r9,0x200,COH
80006962:	cf 90       	breq	80006954 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006964:	78 18       	ld.w	r8,r12[0x4]
80006966:	ea 18 00 0f 	orh	r8,0xf
8000696a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000696c:	fc 18 01 00 	movh	r8,0x100
80006970:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80006972:	30 09       	mov	r9,0
80006974:	12 9a       	mov	r10,r9
80006976:	12 9b       	mov	r11,r9
80006978:	48 38       	lddpc	r8,80006984 <spi_unselectChip+0x38>
8000697a:	70 0c       	ld.w	r12,r8[0x0]
8000697c:	f0 1f 00 03 	mcall	80006988 <spi_unselectChip+0x3c>
80006980:	d8 0a       	popm	pc,r12=0
80006982:	00 00       	add	r0,r0
80006984:	00 00       	add	r0,r0
80006986:	a6 bc       	st.b	r3[0x3],r12
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	73 30       	ld.w	r0,r9[0x4c]

8000698c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000698c:	eb cd 40 f8 	pushm	r3-r7,lr
80006990:	18 94       	mov	r4,r12
80006992:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006994:	49 a6       	lddpc	r6,800069fc <spi_selectChip+0x70>
80006996:	30 07       	mov	r7,0
80006998:	31 45       	mov	r5,20
8000699a:	0e 99       	mov	r9,r7
8000699c:	0a 9a       	mov	r10,r5
8000699e:	0e 9b       	mov	r11,r7
800069a0:	6c 0c       	ld.w	r12,r6[0x0]
800069a2:	f0 1f 00 18 	mcall	80006a00 <spi_selectChip+0x74>
800069a6:	cf a0       	breq	8000699a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800069a8:	68 18       	ld.w	r8,r4[0x4]
800069aa:	ea 18 00 0f 	orh	r8,0xf
800069ae:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800069b0:	68 18       	ld.w	r8,r4[0x4]
800069b2:	e2 18 00 04 	andl	r8,0x4,COH
800069b6:	c1 10       	breq	800069d8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800069b8:	30 e8       	mov	r8,14
800069ba:	f0 03 18 00 	cp.b	r3,r8
800069be:	e0 8b 00 1c 	brhi	800069f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800069c2:	68 19       	ld.w	r9,r4[0x4]
800069c4:	e6 08 15 10 	lsl	r8,r3,0x10
800069c8:	ea 18 ff f0 	orh	r8,0xfff0
800069cc:	e8 18 ff ff 	orl	r8,0xffff
800069d0:	12 68       	and	r8,r9
800069d2:	89 18       	st.w	r4[0x4],r8
800069d4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800069d8:	30 38       	mov	r8,3
800069da:	f0 03 18 00 	cp.b	r3,r8
800069de:	e0 8b 00 0c 	brhi	800069f6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800069e2:	68 19       	ld.w	r9,r4[0x4]
800069e4:	2f 03       	sub	r3,-16
800069e6:	30 18       	mov	r8,1
800069e8:	f0 03 09 48 	lsl	r8,r8,r3
800069ec:	5c d8       	com	r8
800069ee:	12 68       	and	r8,r9
800069f0:	89 18       	st.w	r4[0x4],r8
800069f2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800069f6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800069f8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800069fc:	00 00       	add	r0,r0
800069fe:	a6 bc       	st.b	r3[0x3],r12
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	71 24       	ld.w	r4,r8[0x48]

80006a04 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006a04:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006a06:	f6 08 15 04 	lsl	r8,r11,0x4
80006a0a:	14 38       	cp.w	r8,r10
80006a0c:	f9 b8 08 10 	movls	r8,16
80006a10:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006a14:	f0 0b 02 4b 	mul	r11,r8,r11
80006a18:	f6 09 16 01 	lsr	r9,r11,0x1
80006a1c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006a20:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006a24:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006a28:	f2 cb 00 01 	sub	r11,r9,1
80006a2c:	e0 4b ff fe 	cp.w	r11,65534
80006a30:	e0 88 00 03 	brls	80006a36 <usart_set_async_baudrate+0x32>
80006a34:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006a36:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006a38:	e8 6e 00 00 	mov	lr,524288
80006a3c:	59 08       	cp.w	r8,16
80006a3e:	fc 08 17 10 	movne	r8,lr
80006a42:	f9 b8 00 00 	moveq	r8,0
80006a46:	e4 1b ff f7 	andh	r11,0xfff7
80006a4a:	e0 1b fe cf 	andl	r11,0xfecf
80006a4e:	16 48       	or	r8,r11
80006a50:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006a52:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006a56:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006a5a:	99 89       	st.w	r12[0x20],r9
80006a5c:	d8 0a       	popm	pc,r12=0

80006a5e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006a5e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006a60:	e2 18 00 02 	andl	r8,0x2,COH
80006a64:	c0 31       	brne	80006a6a <usart_write_char+0xc>
80006a66:	30 2c       	mov	r12,2
80006a68:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006a6a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006a6e:	99 7b       	st.w	r12[0x1c],r11
80006a70:	5e fd       	retal	0
80006a72:	d7 03       	nop

80006a74 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006a74:	eb cd 40 e0 	pushm	r5-r7,lr
80006a78:	18 96       	mov	r6,r12
80006a7a:	16 95       	mov	r5,r11
80006a7c:	e0 67 27 0f 	mov	r7,9999
80006a80:	c0 68       	rjmp	80006a8c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006a82:	58 07       	cp.w	r7,0
80006a84:	c0 31       	brne	80006a8a <usart_putchar+0x16>
80006a86:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006a8a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006a8c:	0a 9b       	mov	r11,r5
80006a8e:	0c 9c       	mov	r12,r6
80006a90:	f0 1f 00 03 	mcall	80006a9c <usart_putchar+0x28>
80006a94:	cf 71       	brne	80006a82 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006a96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006a9a:	00 00       	add	r0,r0
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	6a 5e       	ld.w	lr,r5[0x14]

80006aa0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006aa0:	78 58       	ld.w	r8,r12[0x14]
80006aa2:	e2 18 00 e0 	andl	r8,0xe0,COH
80006aa6:	c0 30       	breq	80006aac <usart_read_char+0xc>
80006aa8:	30 4c       	mov	r12,4
80006aaa:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006aac:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006aae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ab2:	c0 31       	brne	80006ab8 <usart_read_char+0x18>
80006ab4:	30 3c       	mov	r12,3
80006ab6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006ab8:	78 68       	ld.w	r8,r12[0x18]
80006aba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006abe:	97 08       	st.w	r11[0x0],r8
80006ac0:	5e fd       	retal	0
80006ac2:	d7 03       	nop

80006ac4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ac8:	20 1d       	sub	sp,4
80006aca:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006acc:	1a 97       	mov	r7,sp
80006ace:	1a 9b       	mov	r11,sp
80006ad0:	0c 9c       	mov	r12,r6
80006ad2:	f0 1f 00 07 	mcall	80006aec <usart_getchar+0x28>
80006ad6:	58 3c       	cp.w	r12,3
80006ad8:	cf b0       	breq	80006ace <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006ada:	58 4c       	cp.w	r12,4
80006adc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006ae0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006ae4:	2f fd       	sub	sp,-4
80006ae6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006aea:	00 00       	add	r0,r0
80006aec:	80 00       	ld.sh	r0,r0[0x0]
80006aee:	6a a0       	ld.w	r0,r5[0x28]

80006af0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006af0:	eb cd 40 c0 	pushm	r6-r7,lr
80006af4:	18 96       	mov	r6,r12
80006af6:	16 97       	mov	r7,r11
  while (*string != '\0')
80006af8:	17 8b       	ld.ub	r11,r11[0x0]
80006afa:	58 0b       	cp.w	r11,0
80006afc:	c0 80       	breq	80006b0c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006afe:	2f f7       	sub	r7,-1
80006b00:	0c 9c       	mov	r12,r6
80006b02:	f0 1f 00 04 	mcall	80006b10 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006b06:	0f 8b       	ld.ub	r11,r7[0x0]
80006b08:	58 0b       	cp.w	r11,0
80006b0a:	cf a1       	brne	80006afe <usart_write_line+0xe>
80006b0c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	6a 74       	ld.w	r4,r5[0x1c]

80006b14 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006b14:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006b18:	e6 18 00 01 	andh	r8,0x1,COH
80006b1c:	c0 71       	brne	80006b2a <usart_reset+0x16>
80006b1e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006b20:	3f f8       	mov	r8,-1
80006b22:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b24:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006b26:	d5 03       	csrf	0x10
80006b28:	c0 48       	rjmp	80006b30 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006b2a:	3f f8       	mov	r8,-1
80006b2c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b2e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006b30:	30 08       	mov	r8,0
80006b32:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006b34:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006b36:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006b38:	ea 68 61 0c 	mov	r8,680204
80006b3c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006b3e:	5e fc       	retal	r12

80006b40 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006b40:	eb cd 40 e0 	pushm	r5-r7,lr
80006b44:	18 96       	mov	r6,r12
80006b46:	16 97       	mov	r7,r11
80006b48:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006b4a:	f0 1f 00 2f 	mcall	80006c04 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006b4e:	58 07       	cp.w	r7,0
80006b50:	c5 80       	breq	80006c00 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006b52:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b54:	30 49       	mov	r9,4
80006b56:	f2 08 18 00 	cp.b	r8,r9
80006b5a:	e0 88 00 53 	brls	80006c00 <usart_init_rs232+0xc0>
80006b5e:	30 99       	mov	r9,9
80006b60:	f2 08 18 00 	cp.b	r8,r9
80006b64:	e0 8b 00 4e 	brhi	80006c00 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006b68:	0f d9       	ld.ub	r9,r7[0x5]
80006b6a:	30 78       	mov	r8,7
80006b6c:	f0 09 18 00 	cp.b	r9,r8
80006b70:	e0 8b 00 48 	brhi	80006c00 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006b74:	8e 39       	ld.sh	r9,r7[0x6]
80006b76:	e0 68 01 01 	mov	r8,257
80006b7a:	f0 09 19 00 	cp.h	r9,r8
80006b7e:	e0 8b 00 41 	brhi	80006c00 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006b82:	ef 39 00 08 	ld.ub	r9,r7[8]
80006b86:	30 38       	mov	r8,3
80006b88:	f0 09 18 00 	cp.b	r9,r8
80006b8c:	e0 8b 00 3a 	brhi	80006c00 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006b90:	0a 9a       	mov	r10,r5
80006b92:	6e 0b       	ld.w	r11,r7[0x0]
80006b94:	0c 9c       	mov	r12,r6
80006b96:	f0 1f 00 1d 	mcall	80006c08 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b9a:	58 1c       	cp.w	r12,1
80006b9c:	c3 20       	breq	80006c00 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006b9e:	0f c8       	ld.ub	r8,r7[0x4]
80006ba0:	30 99       	mov	r9,9
80006ba2:	f2 08 18 00 	cp.b	r8,r9
80006ba6:	c0 51       	brne	80006bb0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006ba8:	6c 18       	ld.w	r8,r6[0x4]
80006baa:	b1 b8       	sbr	r8,0x11
80006bac:	8d 18       	st.w	r6[0x4],r8
80006bae:	c0 68       	rjmp	80006bba <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006bb0:	6c 19       	ld.w	r9,r6[0x4]
80006bb2:	20 58       	sub	r8,5
80006bb4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006bb8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006bba:	6c 19       	ld.w	r9,r6[0x4]
80006bbc:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006bc0:	0f d8       	ld.ub	r8,r7[0x5]
80006bc2:	a9 78       	lsl	r8,0x9
80006bc4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006bc8:	12 48       	or	r8,r9
80006bca:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006bcc:	8e 38       	ld.sh	r8,r7[0x6]
80006bce:	30 29       	mov	r9,2
80006bd0:	f2 08 19 00 	cp.h	r8,r9
80006bd4:	e0 88 00 09 	brls	80006be6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006bd8:	6c 18       	ld.w	r8,r6[0x4]
80006bda:	ad b8       	sbr	r8,0xd
80006bdc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006bde:	8e b8       	ld.uh	r8,r7[0x6]
80006be0:	20 28       	sub	r8,2
80006be2:	8d a8       	st.w	r6[0x28],r8
80006be4:	c0 68       	rjmp	80006bf0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006be6:	6c 19       	ld.w	r9,r6[0x4]
80006be8:	5c 78       	castu.h	r8
80006bea:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006bee:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006bf0:	6c 18       	ld.w	r8,r6[0x4]
80006bf2:	e0 18 ff f0 	andl	r8,0xfff0
80006bf6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006bf8:	35 08       	mov	r8,80
80006bfa:	8d 08       	st.w	r6[0x0],r8
80006bfc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006c00:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	6b 14       	ld.w	r4,r5[0x44]
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	6a 04       	ld.w	r4,r5[0x0]

80006c0c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006c0c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006c10:	fe c0 8e 10 	sub	r0,pc,-29168

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006c14:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006c18:	d5 53       	csrf	0x15
  cp      r0, r1
80006c1a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006c1c:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006c20:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006c22:	c0 62       	brcc	80006c2e <idata_load_loop_end>
  cp      r0, r1
80006c24:	48 92       	lddpc	r2,80006c48 <udata_clear_loop_end+0x4>

80006c26 <idata_load_loop>:
  brlo    idata_load_loop
80006c26:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006c28:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006c2a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006c2c:	cf d3       	brcs	80006c26 <idata_load_loop>

80006c2e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006c2e:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006c32:	e0 61 a6 d0 	mov	r1,42704
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006c36:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006c38:	c0 62       	brcc	80006c44 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006c3a:	30 02       	mov	r2,0
80006c3c:	30 03       	mov	r3,0

80006c3e <udata_clear_loop>:
80006c3e:	a1 22       	st.d	r0++,r2
80006c40:	02 30       	cp.w	r0,r1
80006c42:	cf e3       	brcs	80006c3e <udata_clear_loop>

80006c44 <udata_clear_loop_end>:
80006c44:	fe cf e9 28 	sub	pc,pc,-5848
80006c48:	80 00       	ld.sh	r0,r0[0x0]
80006c4a:	f6 50 f8 c8 	cp.w	r0,-526136

80006c4c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006c4c:	f8 c8 ff f8 	sub	r8,r12,-8
80006c50:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006c52:	3f f9       	mov	r9,-1
80006c54:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006c56:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006c58:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006c5a:	30 08       	mov	r8,0
80006c5c:	99 08       	st.w	r12[0x0],r8
}
80006c5e:	5e fc       	retal	r12

80006c60 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006c60:	30 08       	mov	r8,0
80006c62:	99 48       	st.w	r12[0x10],r8
}
80006c64:	5e fc       	retal	r12

80006c66 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006c66:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006c68:	70 19       	ld.w	r9,r8[0x4]
80006c6a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006c6c:	78 19       	ld.w	r9,r12[0x4]
80006c6e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006c70:	70 19       	ld.w	r9,r8[0x4]
80006c72:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006c74:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006c76:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006c78:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006c7a:	78 08       	ld.w	r8,r12[0x0]
80006c7c:	2f f8       	sub	r8,-1
80006c7e:	99 08       	st.w	r12[0x0],r8
}
80006c80:	5e fc       	retal	r12

80006c82 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006c82:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006c84:	5b fa       	cp.w	r10,-1
80006c86:	c0 31       	brne	80006c8c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006c88:	78 48       	ld.w	r8,r12[0x10]
80006c8a:	c0 c8       	rjmp	80006ca2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006c8c:	f8 c8 ff f8 	sub	r8,r12,-8
80006c90:	70 19       	ld.w	r9,r8[0x4]
80006c92:	72 09       	ld.w	r9,r9[0x0]
80006c94:	12 3a       	cp.w	r10,r9
80006c96:	c0 63       	brcs	80006ca2 <vListInsert+0x20>
80006c98:	70 18       	ld.w	r8,r8[0x4]
80006c9a:	70 19       	ld.w	r9,r8[0x4]
80006c9c:	72 09       	ld.w	r9,r9[0x0]
80006c9e:	12 3a       	cp.w	r10,r9
80006ca0:	cf c2       	brcc	80006c98 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006ca2:	70 19       	ld.w	r9,r8[0x4]
80006ca4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006ca6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006ca8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006caa:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006cac:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006cae:	78 08       	ld.w	r8,r12[0x0]
80006cb0:	2f f8       	sub	r8,-1
80006cb2:	99 08       	st.w	r12[0x0],r8
}
80006cb4:	5e fc       	retal	r12

80006cb6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006cb6:	78 18       	ld.w	r8,r12[0x4]
80006cb8:	78 29       	ld.w	r9,r12[0x8]
80006cba:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006cbc:	78 28       	ld.w	r8,r12[0x8]
80006cbe:	78 19       	ld.w	r9,r12[0x4]
80006cc0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006cc2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006cc4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006cc6:	18 39       	cp.w	r9,r12
80006cc8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006ccc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006cd0:	30 09       	mov	r9,0
80006cd2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006cd4:	70 09       	ld.w	r9,r8[0x0]
80006cd6:	20 19       	sub	r9,1
80006cd8:	91 09       	st.w	r8[0x0],r9
}
80006cda:	5e fc       	retal	r12

80006cdc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006cdc:	e0 68 08 08 	mov	r8,2056
80006ce0:	ea 18 08 08 	orh	r8,0x808
80006ce4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006ce6:	e0 68 09 09 	mov	r8,2313
80006cea:	ea 18 09 09 	orh	r8,0x909
80006cee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006cf0:	e0 68 0a 0a 	mov	r8,2570
80006cf4:	ea 18 0a 0a 	orh	r8,0xa0a
80006cf8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006cfa:	e0 68 0b 0b 	mov	r8,2827
80006cfe:	ea 18 0b 0b 	orh	r8,0xb0b
80006d02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006d04:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006d06:	e0 68 be ef 	mov	r8,48879
80006d0a:	ea 18 de ad 	orh	r8,0xdead
80006d0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006d10:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006d12:	fc 18 00 40 	movh	r8,0x40
80006d16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006d18:	e0 68 00 ff 	mov	r8,255
80006d1c:	ea 18 ff 00 	orh	r8,0xff00
80006d20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006d22:	e0 68 01 01 	mov	r8,257
80006d26:	ea 18 01 01 	orh	r8,0x101
80006d2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006d2c:	e0 68 02 02 	mov	r8,514
80006d30:	ea 18 02 02 	orh	r8,0x202
80006d34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006d36:	e0 68 03 03 	mov	r8,771
80006d3a:	ea 18 03 03 	orh	r8,0x303
80006d3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006d40:	e0 68 04 04 	mov	r8,1028
80006d44:	ea 18 04 04 	orh	r8,0x404
80006d48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006d4a:	e0 68 05 05 	mov	r8,1285
80006d4e:	ea 18 05 05 	orh	r8,0x505
80006d52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006d54:	e0 68 06 06 	mov	r8,1542
80006d58:	ea 18 06 06 	orh	r8,0x606
80006d5c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006d5e:	e0 68 07 07 	mov	r8,1799
80006d62:	ea 18 07 07 	orh	r8,0x707
80006d66:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006d68:	30 08       	mov	r8,0
80006d6a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006d6c:	5e fc       	retal	r12
80006d6e:	d7 03       	nop

80006d70 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006d70:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006d72:	48 38       	lddpc	r8,80006d7c <vPortEnterCritical+0xc>
80006d74:	70 09       	ld.w	r9,r8[0x0]
80006d76:	2f f9       	sub	r9,-1
80006d78:	91 09       	st.w	r8[0x0],r9
}
80006d7a:	5e fc       	retal	r12
80006d7c:	00 00       	add	r0,r0
80006d7e:	05 4c       	ld.w	r12,--r2

80006d80 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006d80:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006d82:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006d84:	30 0a       	mov	r10,0
80006d86:	14 9b       	mov	r11,r10
80006d88:	49 2c       	lddpc	r12,80006dd0 <xPortStartScheduler+0x50>
80006d8a:	f0 1f 00 13 	mcall	80006dd4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006d8e:	e0 68 5d c0 	mov	r8,24000
80006d92:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006d96:	30 08       	mov	r8,0
80006d98:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006d9c:	e0 68 0d 74 	mov	r8,3444
80006da0:	ea 18 00 00 	orh	r8,0x0
80006da4:	70 00       	ld.w	r0,r8[0x0]
80006da6:	60 0d       	ld.w	sp,r0[0x0]
80006da8:	1b 00       	ld.w	r0,sp++
80006daa:	e0 68 05 4c 	mov	r8,1356
80006dae:	ea 18 00 00 	orh	r8,0x0
80006db2:	91 00       	st.w	r8[0x0],r0
80006db4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006db8:	2f ed       	sub	sp,-8
80006dba:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006dbe:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006dc2:	e3 b0 00 00 	mtsr	0x0,r0
80006dc6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006dca:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006dce:	d8 0a       	popm	pc,r12=0
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	6e 9c       	ld.w	r12,r7[0x24]
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	63 d0       	ld.w	r0,r1[0x74]

80006dd8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006dd8:	20 6d       	sub	sp,24
80006dda:	eb cd 00 ff 	pushm	r0-r7
80006dde:	fa c7 ff c0 	sub	r7,sp,-64
80006de2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006de6:	ef 40 ff e0 	st.w	r7[-32],r0
80006dea:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006dee:	ef 40 ff e4 	st.w	r7[-28],r0
80006df2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006df6:	e0 68 05 4c 	mov	r8,1356
80006dfa:	ea 18 00 00 	orh	r8,0x0
80006dfe:	70 00       	ld.w	r0,r8[0x0]
80006e00:	1a d0       	st.w	--sp,r0
80006e02:	f0 1f 00 1a 	mcall	80006e68 <LABEL_RET_SCALL_263+0x14>
80006e06:	e0 68 0d 74 	mov	r8,3444
80006e0a:	ea 18 00 00 	orh	r8,0x0
80006e0e:	70 00       	ld.w	r0,r8[0x0]
80006e10:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006e12:	f0 1f 00 17 	mcall	80006e6c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006e16:	e0 68 0d 74 	mov	r8,3444
80006e1a:	ea 18 00 00 	orh	r8,0x0
80006e1e:	70 00       	ld.w	r0,r8[0x0]
80006e20:	60 0d       	ld.w	sp,r0[0x0]
80006e22:	1b 00       	ld.w	r0,sp++
80006e24:	e0 68 05 4c 	mov	r8,1356
80006e28:	ea 18 00 00 	orh	r8,0x0
80006e2c:	91 00       	st.w	r8[0x0],r0
80006e2e:	fa c7 ff d8 	sub	r7,sp,-40
80006e32:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006e36:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006e3a:	e0 61 05 4c 	mov	r1,1356
80006e3e:	ea 11 00 00 	orh	r1,0x0
80006e42:	62 02       	ld.w	r2,r1[0x0]
80006e44:	58 02       	cp.w	r2,0
80006e46:	c0 70       	breq	80006e54 <LABEL_RET_SCALL_263>
80006e48:	e4 c2 00 01 	sub	r2,r2,1
80006e4c:	83 02       	st.w	r1[0x0],r2
80006e4e:	58 02       	cp.w	r2,0
80006e50:	c0 21       	brne	80006e54 <LABEL_RET_SCALL_263>
80006e52:	b1 c0       	cbr	r0,0x10

80006e54 <LABEL_RET_SCALL_263>:
80006e54:	ef 40 ff f8 	st.w	r7[-8],r0
80006e58:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006e5c:	ef 40 ff fc 	st.w	r7[-4],r0
80006e60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006e64:	2f ad       	sub	sp,-24
80006e66:	d6 13       	rets
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	6d 70       	ld.w	r0,r6[0x5c]
80006e6c:	80 00       	ld.sh	r0,r0[0x0]
80006e6e:	75 0c       	ld.w	r12,r10[0x40]

80006e70 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006e70:	e1 b8 00 43 	mfsr	r8,0x10c
80006e74:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006e78:	5e fc       	retal	r12
80006e7a:	d7 03       	nop

80006e7c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006e7c:	48 78       	lddpc	r8,80006e98 <vPortExitCritical+0x1c>
80006e7e:	70 08       	ld.w	r8,r8[0x0]
80006e80:	58 08       	cp.w	r8,0
80006e82:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006e84:	48 58       	lddpc	r8,80006e98 <vPortExitCritical+0x1c>
80006e86:	70 09       	ld.w	r9,r8[0x0]
80006e88:	20 19       	sub	r9,1
80006e8a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006e8c:	70 08       	ld.w	r8,r8[0x0]
80006e8e:	58 08       	cp.w	r8,0
80006e90:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006e92:	d5 03       	csrf	0x10
80006e94:	5e fc       	retal	r12
80006e96:	00 00       	add	r0,r0
80006e98:	00 00       	add	r0,r0
80006e9a:	05 4c       	ld.w	r12,--r2

80006e9c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006e9c:	eb cd 00 ff 	pushm	r0-r7
80006ea0:	e0 68 05 4c 	mov	r8,1356
80006ea4:	ea 18 00 00 	orh	r8,0x0
80006ea8:	70 00       	ld.w	r0,r8[0x0]
80006eaa:	1a d0       	st.w	--sp,r0
80006eac:	7a 90       	ld.w	r0,sp[0x24]
80006eae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006eb2:	58 10       	cp.w	r0,1
80006eb4:	e0 8b 00 08 	brhi	80006ec4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006eb8:	e0 68 0d 74 	mov	r8,3444
80006ebc:	ea 18 00 00 	orh	r8,0x0
80006ec0:	70 00       	ld.w	r0,r8[0x0]
80006ec2:	81 0d       	st.w	r0[0x0],sp

80006ec4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006ec4:	f0 1f 00 12 	mcall	80006f0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006ec8:	f0 1f 00 12 	mcall	80006f10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006ecc:	f0 1f 00 12 	mcall	80006f14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006ed0:	f0 1f 00 12 	mcall	80006f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006ed4:	7a 90       	ld.w	r0,sp[0x24]
80006ed6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006eda:	58 10       	cp.w	r0,1
80006edc:	e0 8b 00 0e 	brhi	80006ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006ee0:	f0 1f 00 0c 	mcall	80006f10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006ee4:	f0 1f 00 0e 	mcall	80006f1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006ee8:	f0 1f 00 0c 	mcall	80006f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006eec:	e0 68 0d 74 	mov	r8,3444
80006ef0:	ea 18 00 00 	orh	r8,0x0
80006ef4:	70 00       	ld.w	r0,r8[0x0]
80006ef6:	60 0d       	ld.w	sp,r0[0x0]

80006ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006ef8:	1b 00       	ld.w	r0,sp++
80006efa:	e0 68 05 4c 	mov	r8,1356
80006efe:	ea 18 00 00 	orh	r8,0x0
80006f02:	91 00       	st.w	r8[0x0],r0
80006f04:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f08:	d6 03       	rete
80006f0a:	00 00       	add	r0,r0
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	6e 70       	ld.w	r0,r7[0x1c]
80006f10:	80 00       	ld.sh	r0,r0[0x0]
80006f12:	6d 70       	ld.w	r0,r6[0x5c]
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	77 10       	ld.w	r0,r11[0x44]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	6e 7c       	ld.w	r12,r7[0x1c]
80006f1c:	80 00       	ld.sh	r0,r0[0x0]
80006f1e:	75 0c       	ld.w	r12,r10[0x40]

80006f20 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006f20:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006f22:	f0 1f 00 02 	mcall	80006f28 <__malloc_lock+0x8>
}
80006f26:	d8 02       	popm	pc
80006f28:	80 00       	ld.sh	r0,r0[0x0]
80006f2a:	74 fc       	ld.w	r12,r10[0x3c]

80006f2c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006f2c:	d4 01       	pushm	lr
	xTaskResumeAll();
80006f2e:	f0 1f 00 02 	mcall	80006f34 <__malloc_unlock+0x8>
}
80006f32:	d8 02       	popm	pc
80006f34:	80 00       	ld.sh	r0,r0[0x0]
80006f36:	78 b8       	ld.w	r8,r12[0x2c]

80006f38 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006f38:	d4 21       	pushm	r4-r7,lr
80006f3a:	16 95       	mov	r5,r11
80006f3c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006f3e:	58 0c       	cp.w	r12,0
80006f40:	c0 30       	breq	80006f46 <_read+0xe>
80006f42:	3f f7       	mov	r7,-1
80006f44:	c1 48       	rjmp	80006f6c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006f46:	58 0a       	cp.w	r10,0
80006f48:	e0 89 00 04 	brgt	80006f50 <_read+0x18>
80006f4c:	30 07       	mov	r7,0
80006f4e:	c0 f8       	rjmp	80006f6c <_read+0x34>
80006f50:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006f52:	48 84       	lddpc	r4,80006f70 <_read+0x38>
80006f54:	68 0c       	ld.w	r12,r4[0x0]
80006f56:	f0 1f 00 08 	mcall	80006f74 <_read+0x3c>
    if (c < 0)
80006f5a:	c0 95       	brlt	80006f6c <_read+0x34>
      break;

    *ptr++ = c;
80006f5c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006f60:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006f62:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006f66:	58 08       	cp.w	r8,0
80006f68:	fe 99 ff f6 	brgt	80006f54 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006f6c:	0e 9c       	mov	r12,r7
80006f6e:	d8 22       	popm	r4-r7,pc
80006f70:	00 00       	add	r0,r0
80006f72:	a6 c0       	st.b	r3[0x4],r0
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	6a c4       	ld.w	r4,r5[0x30]

80006f78 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006f78:	d4 21       	pushm	r4-r7,lr
80006f7a:	16 95       	mov	r5,r11
80006f7c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006f7e:	20 1c       	sub	r12,1
80006f80:	58 2c       	cp.w	r12,2
80006f82:	e0 8b 00 12 	brhi	80006fa6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f86:	58 0a       	cp.w	r10,0
80006f88:	c0 31       	brne	80006f8e <_write+0x16>
80006f8a:	30 07       	mov	r7,0
80006f8c:	c0 e8       	rjmp	80006fa8 <_write+0x30>
80006f8e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006f90:	48 74       	lddpc	r4,80006fac <_write+0x34>
80006f92:	68 0c       	ld.w	r12,r4[0x0]
80006f94:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006f98:	f0 1f 00 06 	mcall	80006fb0 <_write+0x38>
80006f9c:	c0 55       	brlt	80006fa6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006f9e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006fa0:	0e 36       	cp.w	r6,r7
80006fa2:	cf 81       	brne	80006f92 <_write+0x1a>
80006fa4:	c0 28       	rjmp	80006fa8 <_write+0x30>
80006fa6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006fa8:	0e 9c       	mov	r12,r7
80006faa:	d8 22       	popm	r4-r7,pc
80006fac:	00 00       	add	r0,r0
80006fae:	a6 c0       	st.b	r3[0x4],r0
80006fb0:	80 00       	ld.sh	r0,r0[0x0]
80006fb2:	6a 74       	ld.w	r4,r5[0x1c]

80006fb4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006fb4:	eb cd 40 80 	pushm	r7,lr
80006fb8:	18 97       	mov	r7,r12
	if( pv )
80006fba:	58 0c       	cp.w	r12,0
80006fbc:	c0 80       	breq	80006fcc <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006fbe:	f0 1f 00 05 	mcall	80006fd0 <vPortFree+0x1c>
		{
			free( pv );
80006fc2:	0e 9c       	mov	r12,r7
80006fc4:	f0 1f 00 04 	mcall	80006fd4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006fc8:	f0 1f 00 04 	mcall	80006fd8 <vPortFree+0x24>
80006fcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	74 fc       	ld.w	r12,r10[0x3c]
80006fd4:	80 00       	ld.sh	r0,r0[0x0]
80006fd6:	83 94       	st.w	r1[0x24],r4
80006fd8:	80 00       	ld.sh	r0,r0[0x0]
80006fda:	78 b8       	ld.w	r8,r12[0x2c]

80006fdc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006fdc:	eb cd 40 80 	pushm	r7,lr
80006fe0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006fe2:	f0 1f 00 06 	mcall	80006ff8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006fe6:	0e 9c       	mov	r12,r7
80006fe8:	f0 1f 00 05 	mcall	80006ffc <pvPortMalloc+0x20>
80006fec:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006fee:	f0 1f 00 05 	mcall	80007000 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006ff2:	0e 9c       	mov	r12,r7
80006ff4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	74 fc       	ld.w	r12,r10[0x3c]
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	83 a4       	st.w	r1[0x28],r4
80007000:	80 00       	ld.sh	r0,r0[0x0]
80007002:	78 b8       	ld.w	r8,r12[0x2c]

80007004 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80007004:	d4 01       	pushm	lr
80007006:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80007008:	78 09       	ld.w	r9,r12[0x0]
8000700a:	58 09       	cp.w	r9,0
8000700c:	c1 10       	breq	8000702e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000700e:	78 3a       	ld.w	r10,r12[0xc]
80007010:	79 09       	ld.w	r9,r12[0x40]
80007012:	f4 09 00 09 	add	r9,r10,r9
80007016:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80007018:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000701a:	14 39       	cp.w	r9,r10
8000701c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80007020:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80007024:	79 0a       	ld.w	r10,r12[0x40]
80007026:	78 3b       	ld.w	r11,r12[0xc]
80007028:	10 9c       	mov	r12,r8
8000702a:	f0 1f 00 02 	mcall	80007030 <prvCopyDataFromQueue+0x2c>
8000702e:	d8 02       	popm	pc
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	88 12       	ld.sh	r2,r4[0x2]

80007034 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80007034:	eb cd 40 c0 	pushm	r6-r7,lr
80007038:	18 97       	mov	r7,r12
8000703a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000703c:	78 e8       	ld.w	r8,r12[0x38]
8000703e:	58 08       	cp.w	r8,0
80007040:	c0 31       	brne	80007046 <xQueueReceiveFromISR+0x12>
80007042:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80007046:	f0 1f 00 0e 	mcall	8000707c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000704a:	6e e8       	ld.w	r8,r7[0x38]
8000704c:	20 18       	sub	r8,1
8000704e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80007050:	6f 18       	ld.w	r8,r7[0x44]
80007052:	5b f8       	cp.w	r8,-1
80007054:	c0 d1       	brne	8000706e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007056:	6e 48       	ld.w	r8,r7[0x10]
80007058:	58 08       	cp.w	r8,0
8000705a:	c0 f0       	breq	80007078 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000705c:	ee cc ff f0 	sub	r12,r7,-16
80007060:	f0 1f 00 08 	mcall	80007080 <xQueueReceiveFromISR+0x4c>
80007064:	c0 a0       	breq	80007078 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80007066:	30 1c       	mov	r12,1
80007068:	8d 0c       	st.w	r6[0x0],r12
8000706a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000706e:	2f f8       	sub	r8,-1
80007070:	ef 48 00 44 	st.w	r7[68],r8
80007074:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007078:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	70 04       	ld.w	r4,r8[0x0]
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	76 94       	ld.w	r4,r11[0x24]

80007084 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80007084:	eb cd 40 c0 	pushm	r6-r7,lr
80007088:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000708a:	f0 1f 00 23 	mcall	80007114 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000708e:	6f 28       	ld.w	r8,r7[0x48]
80007090:	58 08       	cp.w	r8,0
80007092:	e0 8a 00 18 	brle	800070c2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007096:	6e 98       	ld.w	r8,r7[0x24]
80007098:	58 08       	cp.w	r8,0
8000709a:	c1 40       	breq	800070c2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000709c:	ee c6 ff dc 	sub	r6,r7,-36
800070a0:	c0 48       	rjmp	800070a8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800070a2:	6e 98       	ld.w	r8,r7[0x24]
800070a4:	58 08       	cp.w	r8,0
800070a6:	c0 e0       	breq	800070c2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800070a8:	0c 9c       	mov	r12,r6
800070aa:	f0 1f 00 1c 	mcall	80007118 <prvUnlockQueue+0x94>
800070ae:	c0 30       	breq	800070b4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800070b0:	f0 1f 00 1b 	mcall	8000711c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800070b4:	6f 28       	ld.w	r8,r7[0x48]
800070b6:	20 18       	sub	r8,1
800070b8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800070bc:	58 08       	cp.w	r8,0
800070be:	fe 99 ff f2 	brgt	800070a2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800070c2:	3f f8       	mov	r8,-1
800070c4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800070c8:	f0 1f 00 16 	mcall	80007120 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800070cc:	f0 1f 00 12 	mcall	80007114 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070d0:	6f 18       	ld.w	r8,r7[0x44]
800070d2:	58 08       	cp.w	r8,0
800070d4:	e0 8a 00 18 	brle	80007104 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070d8:	6e 48       	ld.w	r8,r7[0x10]
800070da:	58 08       	cp.w	r8,0
800070dc:	c1 40       	breq	80007104 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070de:	ee c6 ff f0 	sub	r6,r7,-16
800070e2:	c0 48       	rjmp	800070ea <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070e4:	6e 48       	ld.w	r8,r7[0x10]
800070e6:	58 08       	cp.w	r8,0
800070e8:	c0 e0       	breq	80007104 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070ea:	0c 9c       	mov	r12,r6
800070ec:	f0 1f 00 0b 	mcall	80007118 <prvUnlockQueue+0x94>
800070f0:	c0 30       	breq	800070f6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800070f2:	f0 1f 00 0b 	mcall	8000711c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800070f6:	6f 18       	ld.w	r8,r7[0x44]
800070f8:	20 18       	sub	r8,1
800070fa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070fe:	58 08       	cp.w	r8,0
80007100:	fe 99 ff f2 	brgt	800070e4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80007104:	3f f8       	mov	r8,-1
80007106:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000710a:	f0 1f 00 06 	mcall	80007120 <prvUnlockQueue+0x9c>
}
8000710e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007112:	00 00       	add	r0,r0
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	6d 70       	ld.w	r0,r6[0x5c]
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	76 94       	ld.w	r4,r11[0x24]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	75 a0       	ld.w	r0,r10[0x68]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	6e 7c       	ld.w	r12,r7[0x1c]

80007124 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80007124:	d4 31       	pushm	r0-r7,lr
80007126:	20 5d       	sub	sp,20
80007128:	18 97       	mov	r7,r12
8000712a:	50 0b       	stdsp	sp[0x0],r11
8000712c:	50 2a       	stdsp	sp[0x8],r10
8000712e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007130:	f8 c2 ff dc 	sub	r2,r12,-36
80007134:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007136:	fa c4 ff f4 	sub	r4,sp,-12
8000713a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000713c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000713e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80007142:	f0 1f 00 3e 	mcall	80007238 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007146:	6e e8       	ld.w	r8,r7[0x38]
80007148:	58 08       	cp.w	r8,0
8000714a:	c2 a0       	breq	8000719e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000714c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000714e:	40 0b       	lddsp	r11,sp[0x0]
80007150:	0e 9c       	mov	r12,r7
80007152:	f0 1f 00 3b 	mcall	8000723c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80007156:	40 18       	lddsp	r8,sp[0x4]
80007158:	58 08       	cp.w	r8,0
8000715a:	c1 51       	brne	80007184 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000715c:	6e e8       	ld.w	r8,r7[0x38]
8000715e:	20 18       	sub	r8,1
80007160:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007162:	6e 08       	ld.w	r8,r7[0x0]
80007164:	58 08       	cp.w	r8,0
80007166:	c0 41       	brne	8000716e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80007168:	f0 1f 00 36 	mcall	80007240 <xQueueGenericReceive+0x11c>
8000716c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000716e:	6e 48       	ld.w	r8,r7[0x10]
80007170:	58 08       	cp.w	r8,0
80007172:	c1 20       	breq	80007196 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80007174:	ee cc ff f0 	sub	r12,r7,-16
80007178:	f0 1f 00 33 	mcall	80007244 <xQueueGenericReceive+0x120>
8000717c:	58 1c       	cp.w	r12,1
8000717e:	c0 c1       	brne	80007196 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80007180:	d7 33       	scall
80007182:	c0 a8       	rjmp	80007196 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80007184:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007186:	6e 98       	ld.w	r8,r7[0x24]
80007188:	58 08       	cp.w	r8,0
8000718a:	c0 60       	breq	80007196 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000718c:	04 9c       	mov	r12,r2
8000718e:	f0 1f 00 2e 	mcall	80007244 <xQueueGenericReceive+0x120>
80007192:	c0 20       	breq	80007196 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80007194:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80007196:	f0 1f 00 2d 	mcall	80007248 <xQueueGenericReceive+0x124>
8000719a:	30 1c       	mov	r12,1
				return pdPASS;
8000719c:	c4 c8       	rjmp	80007234 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000719e:	40 28       	lddsp	r8,sp[0x8]
800071a0:	58 08       	cp.w	r8,0
800071a2:	c0 51       	brne	800071ac <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800071a4:	f0 1f 00 29 	mcall	80007248 <xQueueGenericReceive+0x124>
800071a8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800071aa:	c4 58       	rjmp	80007234 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800071ac:	58 05       	cp.w	r5,0
800071ae:	c0 51       	brne	800071b8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800071b0:	08 9c       	mov	r12,r4
800071b2:	f0 1f 00 27 	mcall	8000724c <xQueueGenericReceive+0x128>
800071b6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800071b8:	f0 1f 00 24 	mcall	80007248 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800071bc:	f0 1f 00 25 	mcall	80007250 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800071c0:	f0 1f 00 1e 	mcall	80007238 <xQueueGenericReceive+0x114>
800071c4:	6f 18       	ld.w	r8,r7[0x44]
800071c6:	5b f8       	cp.w	r8,-1
800071c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800071cc:	6f 28       	ld.w	r8,r7[0x48]
800071ce:	5b f8       	cp.w	r8,-1
800071d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800071d4:	f0 1f 00 1d 	mcall	80007248 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071d8:	06 9b       	mov	r11,r3
800071da:	08 9c       	mov	r12,r4
800071dc:	f0 1f 00 1e 	mcall	80007254 <xQueueGenericReceive+0x130>
800071e0:	c2 41       	brne	80007228 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800071e2:	f0 1f 00 16 	mcall	80007238 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800071e6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800071e8:	f0 1f 00 18 	mcall	80007248 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800071ec:	58 06       	cp.w	r6,0
800071ee:	c1 71       	brne	8000721c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800071f0:	6e 08       	ld.w	r8,r7[0x0]
800071f2:	58 08       	cp.w	r8,0
800071f4:	c0 81       	brne	80007204 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800071f6:	f0 1f 00 11 	mcall	80007238 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800071fa:	6e 1c       	ld.w	r12,r7[0x4]
800071fc:	f0 1f 00 17 	mcall	80007258 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80007200:	f0 1f 00 12 	mcall	80007248 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007204:	40 2b       	lddsp	r11,sp[0x8]
80007206:	04 9c       	mov	r12,r2
80007208:	f0 1f 00 15 	mcall	8000725c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000720c:	0e 9c       	mov	r12,r7
8000720e:	f0 1f 00 15 	mcall	80007260 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80007212:	f0 1f 00 15 	mcall	80007264 <xQueueGenericReceive+0x140>
80007216:	c9 61       	brne	80007142 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007218:	d7 33       	scall
8000721a:	c9 4b       	rjmp	80007142 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000721c:	0e 9c       	mov	r12,r7
8000721e:	f0 1f 00 11 	mcall	80007260 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80007222:	f0 1f 00 11 	mcall	80007264 <xQueueGenericReceive+0x140>
80007226:	c8 eb       	rjmp	80007142 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007228:	0e 9c       	mov	r12,r7
8000722a:	f0 1f 00 0e 	mcall	80007260 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000722e:	f0 1f 00 0e 	mcall	80007264 <xQueueGenericReceive+0x140>
80007232:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80007234:	2f bd       	sub	sp,-20
80007236:	d8 32       	popm	r0-r7,pc
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	6d 70       	ld.w	r0,r6[0x5c]
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	70 04       	ld.w	r4,r8[0x0]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	75 ac       	ld.w	r12,r10[0x68]
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	76 94       	ld.w	r4,r11[0x24]
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	6e 7c       	ld.w	r12,r7[0x1c]
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	75 88       	ld.w	r8,r10[0x60]
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	74 fc       	ld.w	r12,r10[0x3c]
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	78 24       	ld.w	r4,r12[0x8]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	76 10       	ld.w	r0,r11[0x4]
8000725c:	80 00       	ld.sh	r0,r0[0x0]
8000725e:	7a c4       	ld.w	r4,sp[0x30]
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	70 84       	ld.w	r4,r8[0x20]
80007264:	80 00       	ld.sh	r0,r0[0x0]
80007266:	78 b8       	ld.w	r8,r12[0x2c]

80007268 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80007268:	eb cd 40 80 	pushm	r7,lr
8000726c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000726e:	79 08       	ld.w	r8,r12[0x40]
80007270:	58 08       	cp.w	r8,0
80007272:	c0 a1       	brne	80007286 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007274:	78 08       	ld.w	r8,r12[0x0]
80007276:	58 08       	cp.w	r8,0
80007278:	c2 b1       	brne	800072ce <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000727a:	78 1c       	ld.w	r12,r12[0x4]
8000727c:	f0 1f 00 17 	mcall	800072d8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80007280:	30 08       	mov	r8,0
80007282:	8f 18       	st.w	r7[0x4],r8
80007284:	c2 58       	rjmp	800072ce <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80007286:	58 0a       	cp.w	r10,0
80007288:	c1 01       	brne	800072a8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000728a:	10 9a       	mov	r10,r8
8000728c:	78 2c       	ld.w	r12,r12[0x8]
8000728e:	f0 1f 00 14 	mcall	800072dc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80007292:	6e 29       	ld.w	r9,r7[0x8]
80007294:	6f 08       	ld.w	r8,r7[0x40]
80007296:	f2 08 00 08 	add	r8,r9,r8
8000729a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000729c:	6e 19       	ld.w	r9,r7[0x4]
8000729e:	12 38       	cp.w	r8,r9
800072a0:	c1 73       	brcs	800072ce <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800072a2:	6e 08       	ld.w	r8,r7[0x0]
800072a4:	8f 28       	st.w	r7[0x8],r8
800072a6:	c1 48       	rjmp	800072ce <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800072a8:	10 9a       	mov	r10,r8
800072aa:	78 3c       	ld.w	r12,r12[0xc]
800072ac:	f0 1f 00 0c 	mcall	800072dc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800072b0:	6f 08       	ld.w	r8,r7[0x40]
800072b2:	6e 39       	ld.w	r9,r7[0xc]
800072b4:	f2 08 01 08 	sub	r8,r9,r8
800072b8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800072ba:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800072bc:	12 38       	cp.w	r8,r9
800072be:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800072c2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800072c6:	f3 d8 e3 19 	subcs	r9,r9,r8
800072ca:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800072ce:	6e e8       	ld.w	r8,r7[0x38]
800072d0:	2f f8       	sub	r8,-1
800072d2:	8f e8       	st.w	r7[0x38],r8
}
800072d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	75 b8       	ld.w	r8,r10[0x6c]
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	88 12       	ld.sh	r2,r4[0x2]

800072e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800072e0:	eb cd 40 c0 	pushm	r6-r7,lr
800072e4:	18 97       	mov	r7,r12
800072e6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800072e8:	78 ec       	ld.w	r12,r12[0x38]
800072ea:	6e f8       	ld.w	r8,r7[0x3c]
800072ec:	10 3c       	cp.w	r12,r8
800072ee:	c0 33       	brcs	800072f4 <xQueueGenericSendFromISR+0x14>
800072f0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800072f4:	12 9a       	mov	r10,r9
800072f6:	0e 9c       	mov	r12,r7
800072f8:	f0 1f 00 0c 	mcall	80007328 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800072fc:	6f 28       	ld.w	r8,r7[0x48]
800072fe:	5b f8       	cp.w	r8,-1
80007300:	c0 d1       	brne	8000731a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007302:	6e 98       	ld.w	r8,r7[0x24]
80007304:	58 08       	cp.w	r8,0
80007306:	c0 f0       	breq	80007324 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007308:	ee cc ff dc 	sub	r12,r7,-36
8000730c:	f0 1f 00 08 	mcall	8000732c <xQueueGenericSendFromISR+0x4c>
80007310:	c0 a0       	breq	80007324 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80007312:	30 1c       	mov	r12,1
80007314:	8d 0c       	st.w	r6[0x0],r12
80007316:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000731a:	2f f8       	sub	r8,-1
8000731c:	ef 48 00 48 	st.w	r7[72],r8
80007320:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007324:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	72 68       	ld.w	r8,r9[0x18]
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	76 94       	ld.w	r4,r11[0x24]

80007330 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80007330:	d4 31       	pushm	r0-r7,lr
80007332:	20 5d       	sub	sp,20
80007334:	18 97       	mov	r7,r12
80007336:	50 0b       	stdsp	sp[0x0],r11
80007338:	50 2a       	stdsp	sp[0x8],r10
8000733a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000733c:	f8 c0 ff f0 	sub	r0,r12,-16
80007340:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007342:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007346:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007348:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000734c:	f0 1f 00 2f 	mcall	80007408 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80007350:	6e e9       	ld.w	r9,r7[0x38]
80007352:	6e f8       	ld.w	r8,r7[0x3c]
80007354:	10 39       	cp.w	r9,r8
80007356:	c1 42       	brcc	8000737e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007358:	40 1a       	lddsp	r10,sp[0x4]
8000735a:	40 0b       	lddsp	r11,sp[0x0]
8000735c:	0e 9c       	mov	r12,r7
8000735e:	f0 1f 00 2c 	mcall	8000740c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007362:	6e 98       	ld.w	r8,r7[0x24]
80007364:	58 08       	cp.w	r8,0
80007366:	c0 80       	breq	80007376 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80007368:	ee cc ff dc 	sub	r12,r7,-36
8000736c:	f0 1f 00 29 	mcall	80007410 <xQueueGenericSend+0xe0>
80007370:	58 1c       	cp.w	r12,1
80007372:	c0 21       	brne	80007376 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80007374:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80007376:	f0 1f 00 28 	mcall	80007414 <xQueueGenericSend+0xe4>
8000737a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000737c:	c4 38       	rjmp	80007402 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000737e:	40 28       	lddsp	r8,sp[0x8]
80007380:	58 08       	cp.w	r8,0
80007382:	c0 51       	brne	8000738c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007384:	f0 1f 00 24 	mcall	80007414 <xQueueGenericSend+0xe4>
80007388:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000738a:	c3 c8       	rjmp	80007402 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000738c:	58 04       	cp.w	r4,0
8000738e:	c0 51       	brne	80007398 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007390:	06 9c       	mov	r12,r3
80007392:	f0 1f 00 22 	mcall	80007418 <xQueueGenericSend+0xe8>
80007396:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007398:	f0 1f 00 1f 	mcall	80007414 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000739c:	f0 1f 00 20 	mcall	8000741c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800073a0:	f0 1f 00 1a 	mcall	80007408 <xQueueGenericSend+0xd8>
800073a4:	6f 18       	ld.w	r8,r7[0x44]
800073a6:	5b f8       	cp.w	r8,-1
800073a8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800073ac:	6f 28       	ld.w	r8,r7[0x48]
800073ae:	5b f8       	cp.w	r8,-1
800073b0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800073b4:	f0 1f 00 18 	mcall	80007414 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800073b8:	04 9b       	mov	r11,r2
800073ba:	06 9c       	mov	r12,r3
800073bc:	f0 1f 00 19 	mcall	80007420 <xQueueGenericSend+0xf0>
800073c0:	c1 b1       	brne	800073f6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800073c2:	f0 1f 00 12 	mcall	80007408 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800073c6:	6e e5       	ld.w	r5,r7[0x38]
800073c8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800073ca:	f0 1f 00 13 	mcall	80007414 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800073ce:	0c 35       	cp.w	r5,r6
800073d0:	c0 d1       	brne	800073ea <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800073d2:	40 2b       	lddsp	r11,sp[0x8]
800073d4:	00 9c       	mov	r12,r0
800073d6:	f0 1f 00 14 	mcall	80007424 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800073da:	0e 9c       	mov	r12,r7
800073dc:	f0 1f 00 13 	mcall	80007428 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800073e0:	f0 1f 00 13 	mcall	8000742c <xQueueGenericSend+0xfc>
800073e4:	cb 41       	brne	8000734c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800073e6:	d7 33       	scall
800073e8:	cb 2b       	rjmp	8000734c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800073ea:	0e 9c       	mov	r12,r7
800073ec:	f0 1f 00 0f 	mcall	80007428 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800073f0:	f0 1f 00 0f 	mcall	8000742c <xQueueGenericSend+0xfc>
800073f4:	ca cb       	rjmp	8000734c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800073f6:	0e 9c       	mov	r12,r7
800073f8:	f0 1f 00 0c 	mcall	80007428 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800073fc:	f0 1f 00 0c 	mcall	8000742c <xQueueGenericSend+0xfc>
80007400:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80007402:	2f bd       	sub	sp,-20
80007404:	d8 32       	popm	r0-r7,pc
80007406:	00 00       	add	r0,r0
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	6d 70       	ld.w	r0,r6[0x5c]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	72 68       	ld.w	r8,r9[0x18]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	76 94       	ld.w	r4,r11[0x24]
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	6e 7c       	ld.w	r12,r7[0x1c]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	75 88       	ld.w	r8,r10[0x60]
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	74 fc       	ld.w	r12,r10[0x3c]
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	78 24       	ld.w	r4,r12[0x8]
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	7a c4       	ld.w	r4,sp[0x30]
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	70 84       	ld.w	r4,r8[0x20]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	78 b8       	ld.w	r8,r12[0x2c]

80007430 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80007430:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007434:	34 cc       	mov	r12,76
80007436:	f0 1f 00 12 	mcall	8000747c <xQueueCreateMutex+0x4c>
8000743a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000743c:	c1 d0       	breq	80007476 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000743e:	30 06       	mov	r6,0
80007440:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80007442:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80007444:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80007446:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80007448:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000744a:	30 18       	mov	r8,1
8000744c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000744e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80007452:	3f f8       	mov	r8,-1
80007454:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80007458:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000745c:	2f 0c       	sub	r12,-16
8000745e:	f0 1f 00 09 	mcall	80007480 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80007462:	ee cc ff dc 	sub	r12,r7,-36
80007466:	f0 1f 00 07 	mcall	80007480 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000746a:	0c 99       	mov	r9,r6
8000746c:	0c 9a       	mov	r10,r6
8000746e:	0c 9b       	mov	r11,r6
80007470:	0e 9c       	mov	r12,r7
80007472:	f0 1f 00 05 	mcall	80007484 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80007476:	0e 9c       	mov	r12,r7
80007478:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	6f dc       	ld.w	r12,r7[0x74]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	6c 4c       	ld.w	r12,r6[0x10]
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	73 30       	ld.w	r0,r9[0x4c]

80007488 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80007488:	d4 21       	pushm	r4-r7,lr
8000748a:	18 97       	mov	r7,r12
8000748c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000748e:	58 0c       	cp.w	r12,0
80007490:	c2 f0       	breq	800074ee <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007492:	34 cc       	mov	r12,76
80007494:	f0 1f 00 17 	mcall	800074f0 <xQueueCreate+0x68>
80007498:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000749a:	c2 a0       	breq	800074ee <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000749c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800074a0:	e8 cc ff ff 	sub	r12,r4,-1
800074a4:	f0 1f 00 13 	mcall	800074f0 <xQueueCreate+0x68>
800074a8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800074aa:	c1 e0       	breq	800074e6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800074ac:	f8 04 00 04 	add	r4,r12,r4
800074b0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800074b2:	30 08       	mov	r8,0
800074b4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800074b6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800074b8:	ee c8 00 01 	sub	r8,r7,1
800074bc:	ad 38       	mul	r8,r6
800074be:	10 0c       	add	r12,r8
800074c0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800074c2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800074c4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800074c8:	3f f8       	mov	r8,-1
800074ca:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800074ce:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800074d2:	ea cc ff f0 	sub	r12,r5,-16
800074d6:	f0 1f 00 08 	mcall	800074f4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800074da:	ea cc ff dc 	sub	r12,r5,-36
800074de:	f0 1f 00 06 	mcall	800074f4 <xQueueCreate+0x6c>
800074e2:	0a 9c       	mov	r12,r5
800074e4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800074e6:	0a 9c       	mov	r12,r5
800074e8:	f0 1f 00 04 	mcall	800074f8 <xQueueCreate+0x70>
800074ec:	d8 2a       	popm	r4-r7,pc,r12=0
800074ee:	d8 2a       	popm	r4-r7,pc,r12=0
800074f0:	80 00       	ld.sh	r0,r0[0x0]
800074f2:	6f dc       	ld.w	r12,r7[0x74]
800074f4:	80 00       	ld.sh	r0,r0[0x0]
800074f6:	6c 4c       	ld.w	r12,r6[0x10]
800074f8:	80 00       	ld.sh	r0,r0[0x0]
800074fa:	6f b4       	ld.w	r4,r7[0x6c]

800074fc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800074fc:	48 38       	lddpc	r8,80007508 <vTaskSuspendAll+0xc>
800074fe:	70 09       	ld.w	r9,r8[0x0]
80007500:	2f f9       	sub	r9,-1
80007502:	91 09       	st.w	r8[0x0],r9
}
80007504:	5e fc       	retal	r12
80007506:	00 00       	add	r0,r0
80007508:	00 00       	add	r0,r0
8000750a:	0d a4       	ld.ub	r4,r6[0x2]

8000750c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000750c:	49 a8       	lddpc	r8,80007574 <vTaskSwitchContext+0x68>
8000750e:	70 08       	ld.w	r8,r8[0x0]
80007510:	58 08       	cp.w	r8,0
80007512:	c0 b1       	brne	80007528 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007514:	49 98       	lddpc	r8,80007578 <vTaskSwitchContext+0x6c>
80007516:	70 08       	ld.w	r8,r8[0x0]
80007518:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000751c:	49 89       	lddpc	r9,8000757c <vTaskSwitchContext+0x70>
8000751e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80007522:	58 08       	cp.w	r8,0
80007524:	c0 60       	breq	80007530 <vTaskSwitchContext+0x24>
80007526:	c1 18       	rjmp	80007548 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80007528:	30 19       	mov	r9,1
8000752a:	49 68       	lddpc	r8,80007580 <vTaskSwitchContext+0x74>
8000752c:	91 09       	st.w	r8[0x0],r9
8000752e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007530:	49 28       	lddpc	r8,80007578 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007532:	49 3a       	lddpc	r10,8000757c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007534:	70 09       	ld.w	r9,r8[0x0]
80007536:	20 19       	sub	r9,1
80007538:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000753a:	70 09       	ld.w	r9,r8[0x0]
8000753c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007540:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80007544:	58 09       	cp.w	r9,0
80007546:	cf 70       	breq	80007534 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80007548:	48 c8       	lddpc	r8,80007578 <vTaskSwitchContext+0x6c>
8000754a:	70 08       	ld.w	r8,r8[0x0]
8000754c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007550:	48 b9       	lddpc	r9,8000757c <vTaskSwitchContext+0x70>
80007552:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007556:	70 19       	ld.w	r9,r8[0x4]
80007558:	72 19       	ld.w	r9,r9[0x4]
8000755a:	91 19       	st.w	r8[0x4],r9
8000755c:	f0 ca ff f8 	sub	r10,r8,-8
80007560:	14 39       	cp.w	r9,r10
80007562:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80007566:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000756a:	70 18       	ld.w	r8,r8[0x4]
8000756c:	70 39       	ld.w	r9,r8[0xc]
8000756e:	48 68       	lddpc	r8,80007584 <vTaskSwitchContext+0x78>
80007570:	91 09       	st.w	r8[0x0],r9
80007572:	5e fc       	retal	r12
80007574:	00 00       	add	r0,r0
80007576:	0d a4       	ld.ub	r4,r6[0x2]
80007578:	00 00       	add	r0,r0
8000757a:	0d dc       	ld.ub	r12,r6[0x5]
8000757c:	00 00       	add	r0,r0
8000757e:	0c c0       	st.b	r6++,r0
80007580:	00 00       	add	r0,r0
80007582:	0d c4       	ld.ub	r4,r6[0x4]
80007584:	00 00       	add	r0,r0
80007586:	0d 74       	ld.ub	r4,--r6

80007588 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80007588:	48 48       	lddpc	r8,80007598 <vTaskSetTimeOutState+0x10>
8000758a:	70 08       	ld.w	r8,r8[0x0]
8000758c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000758e:	48 48       	lddpc	r8,8000759c <vTaskSetTimeOutState+0x14>
80007590:	70 08       	ld.w	r8,r8[0x0]
80007592:	99 18       	st.w	r12[0x4],r8
}
80007594:	5e fc       	retal	r12
80007596:	00 00       	add	r0,r0
80007598:	00 00       	add	r0,r0
8000759a:	0c b8       	st.h	r6++,r8
8000759c:	00 00       	add	r0,r0
8000759e:	0d a0       	ld.ub	r0,r6[0x2]

800075a0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800075a0:	30 19       	mov	r9,1
800075a2:	48 28       	lddpc	r8,800075a8 <vTaskMissedYield+0x8>
800075a4:	91 09       	st.w	r8[0x0],r9
}
800075a6:	5e fc       	retal	r12
800075a8:	00 00       	add	r0,r0
800075aa:	0d c4       	ld.ub	r4,r6[0x4]

800075ac <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800075ac:	48 28       	lddpc	r8,800075b4 <xTaskGetCurrentTaskHandle+0x8>
800075ae:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800075b0:	5e fc       	retal	r12
800075b2:	00 00       	add	r0,r0
800075b4:	00 00       	add	r0,r0
800075b6:	0d 74       	ld.ub	r4,--r6

800075b8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800075b8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800075bc:	58 0c       	cp.w	r12,0
800075be:	c1 f0       	breq	800075fc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800075c0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800075c2:	78 b9       	ld.w	r9,r12[0x2c]
800075c4:	79 18       	ld.w	r8,r12[0x44]
800075c6:	10 39       	cp.w	r9,r8
800075c8:	c1 a0       	breq	800075fc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800075ca:	f8 c6 ff fc 	sub	r6,r12,-4
800075ce:	0c 9c       	mov	r12,r6
800075d0:	f0 1f 00 0c 	mcall	80007600 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800075d4:	6f 1c       	ld.w	r12,r7[0x44]
800075d6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800075d8:	f8 08 11 08 	rsub	r8,r12,8
800075dc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800075de:	48 a8       	lddpc	r8,80007604 <vTaskPriorityDisinherit+0x4c>
800075e0:	70 08       	ld.w	r8,r8[0x0]
800075e2:	10 3c       	cp.w	r12,r8
800075e4:	e0 88 00 04 	brls	800075ec <vTaskPriorityDisinherit+0x34>
800075e8:	48 78       	lddpc	r8,80007604 <vTaskPriorityDisinherit+0x4c>
800075ea:	91 0c       	st.w	r8[0x0],r12
800075ec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075f0:	0c 9b       	mov	r11,r6
800075f2:	48 68       	lddpc	r8,80007608 <vTaskPriorityDisinherit+0x50>
800075f4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075f8:	f0 1f 00 05 	mcall	8000760c <vTaskPriorityDisinherit+0x54>
800075fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007600:	80 00       	ld.sh	r0,r0[0x0]
80007602:	6c b6       	ld.w	r6,r6[0x2c]
80007604:	00 00       	add	r0,r0
80007606:	0d dc       	ld.ub	r12,r6[0x5]
80007608:	00 00       	add	r0,r0
8000760a:	0c c0       	st.b	r6++,r0
8000760c:	80 00       	ld.sh	r0,r0[0x0]
8000760e:	6c 66       	ld.w	r6,r6[0x18]

80007610 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80007610:	eb cd 40 c0 	pushm	r6-r7,lr
80007614:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80007616:	49 b8       	lddpc	r8,80007680 <vTaskPriorityInherit+0x70>
80007618:	70 08       	ld.w	r8,r8[0x0]
8000761a:	78 b9       	ld.w	r9,r12[0x2c]
8000761c:	70 b8       	ld.w	r8,r8[0x2c]
8000761e:	10 39       	cp.w	r9,r8
80007620:	c2 d2       	brcc	8000767a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80007622:	49 88       	lddpc	r8,80007680 <vTaskPriorityInherit+0x70>
80007624:	70 08       	ld.w	r8,r8[0x0]
80007626:	70 b8       	ld.w	r8,r8[0x2c]
80007628:	f0 08 11 08 	rsub	r8,r8,8
8000762c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000762e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80007632:	49 59       	lddpc	r9,80007684 <vTaskPriorityInherit+0x74>
80007634:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007638:	78 59       	ld.w	r9,r12[0x14]
8000763a:	10 39       	cp.w	r9,r8
8000763c:	c1 b1       	brne	80007672 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000763e:	f8 c6 ff fc 	sub	r6,r12,-4
80007642:	0c 9c       	mov	r12,r6
80007644:	f0 1f 00 11 	mcall	80007688 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007648:	48 e8       	lddpc	r8,80007680 <vTaskPriorityInherit+0x70>
8000764a:	70 08       	ld.w	r8,r8[0x0]
8000764c:	70 bc       	ld.w	r12,r8[0x2c]
8000764e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80007650:	48 f8       	lddpc	r8,8000768c <vTaskPriorityInherit+0x7c>
80007652:	70 08       	ld.w	r8,r8[0x0]
80007654:	10 3c       	cp.w	r12,r8
80007656:	e0 88 00 04 	brls	8000765e <vTaskPriorityInherit+0x4e>
8000765a:	48 d8       	lddpc	r8,8000768c <vTaskPriorityInherit+0x7c>
8000765c:	91 0c       	st.w	r8[0x0],r12
8000765e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007662:	0c 9b       	mov	r11,r6
80007664:	48 88       	lddpc	r8,80007684 <vTaskPriorityInherit+0x74>
80007666:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000766a:	f0 1f 00 0a 	mcall	80007690 <vTaskPriorityInherit+0x80>
8000766e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007672:	48 48       	lddpc	r8,80007680 <vTaskPriorityInherit+0x70>
80007674:	70 08       	ld.w	r8,r8[0x0]
80007676:	70 b8       	ld.w	r8,r8[0x2c]
80007678:	99 b8       	st.w	r12[0x2c],r8
8000767a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000767e:	00 00       	add	r0,r0
80007680:	00 00       	add	r0,r0
80007682:	0d 74       	ld.ub	r4,--r6
80007684:	00 00       	add	r0,r0
80007686:	0c c0       	st.b	r6++,r0
80007688:	80 00       	ld.sh	r0,r0[0x0]
8000768a:	6c b6       	ld.w	r6,r6[0x2c]
8000768c:	00 00       	add	r0,r0
8000768e:	0d dc       	ld.ub	r12,r6[0x5]
80007690:	80 00       	ld.sh	r0,r0[0x0]
80007692:	6c 66       	ld.w	r6,r6[0x18]

80007694 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80007694:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80007698:	78 38       	ld.w	r8,r12[0xc]
8000769a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000769c:	ee c6 ff e8 	sub	r6,r7,-24
800076a0:	0c 9c       	mov	r12,r6
800076a2:	f0 1f 00 15 	mcall	800076f4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800076a6:	49 58       	lddpc	r8,800076f8 <xTaskRemoveFromEventList+0x64>
800076a8:	70 08       	ld.w	r8,r8[0x0]
800076aa:	58 08       	cp.w	r8,0
800076ac:	c1 71       	brne	800076da <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800076ae:	ee c6 ff fc 	sub	r6,r7,-4
800076b2:	0c 9c       	mov	r12,r6
800076b4:	f0 1f 00 10 	mcall	800076f4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800076b8:	6e bc       	ld.w	r12,r7[0x2c]
800076ba:	49 18       	lddpc	r8,800076fc <xTaskRemoveFromEventList+0x68>
800076bc:	70 08       	ld.w	r8,r8[0x0]
800076be:	10 3c       	cp.w	r12,r8
800076c0:	e0 88 00 04 	brls	800076c8 <xTaskRemoveFromEventList+0x34>
800076c4:	48 e8       	lddpc	r8,800076fc <xTaskRemoveFromEventList+0x68>
800076c6:	91 0c       	st.w	r8[0x0],r12
800076c8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800076cc:	0c 9b       	mov	r11,r6
800076ce:	48 d8       	lddpc	r8,80007700 <xTaskRemoveFromEventList+0x6c>
800076d0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800076d4:	f0 1f 00 0c 	mcall	80007704 <xTaskRemoveFromEventList+0x70>
800076d8:	c0 58       	rjmp	800076e2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800076da:	0c 9b       	mov	r11,r6
800076dc:	48 bc       	lddpc	r12,80007708 <xTaskRemoveFromEventList+0x74>
800076de:	f0 1f 00 0a 	mcall	80007704 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800076e2:	48 b8       	lddpc	r8,8000770c <xTaskRemoveFromEventList+0x78>
800076e4:	70 08       	ld.w	r8,r8[0x0]
800076e6:	6e b9       	ld.w	r9,r7[0x2c]
800076e8:	70 b8       	ld.w	r8,r8[0x2c]
800076ea:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800076ec:	5f 2c       	srhs	r12
800076ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076f2:	00 00       	add	r0,r0
800076f4:	80 00       	ld.sh	r0,r0[0x0]
800076f6:	6c b6       	ld.w	r6,r6[0x2c]
800076f8:	00 00       	add	r0,r0
800076fa:	0d a4       	ld.ub	r4,r6[0x2]
800076fc:	00 00       	add	r0,r0
800076fe:	0d dc       	ld.ub	r12,r6[0x5]
80007700:	00 00       	add	r0,r0
80007702:	0c c0       	st.b	r6++,r0
80007704:	80 00       	ld.sh	r0,r0[0x0]
80007706:	6c 66       	ld.w	r6,r6[0x18]
80007708:	00 00       	add	r0,r0
8000770a:	0d 78       	ld.ub	r8,--r6
8000770c:	00 00       	add	r0,r0
8000770e:	0d 74       	ld.ub	r4,--r6

80007710 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80007710:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007714:	4b 98       	lddpc	r8,800077f8 <vTaskIncrementTick+0xe8>
80007716:	70 08       	ld.w	r8,r8[0x0]
80007718:	58 08       	cp.w	r8,0
8000771a:	c6 91       	brne	800077ec <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000771c:	4b 88       	lddpc	r8,800077fc <vTaskIncrementTick+0xec>
8000771e:	70 09       	ld.w	r9,r8[0x0]
80007720:	2f f9       	sub	r9,-1
80007722:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80007724:	70 08       	ld.w	r8,r8[0x0]
80007726:	58 08       	cp.w	r8,0
80007728:	c1 a1       	brne	8000775c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000772a:	4b 68       	lddpc	r8,80007800 <vTaskIncrementTick+0xf0>
8000772c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000772e:	4b 69       	lddpc	r9,80007804 <vTaskIncrementTick+0xf4>
80007730:	72 0b       	ld.w	r11,r9[0x0]
80007732:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007734:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80007736:	4b 59       	lddpc	r9,80007808 <vTaskIncrementTick+0xf8>
80007738:	72 0a       	ld.w	r10,r9[0x0]
8000773a:	2f fa       	sub	r10,-1
8000773c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000773e:	70 08       	ld.w	r8,r8[0x0]
80007740:	70 08       	ld.w	r8,r8[0x0]
80007742:	58 08       	cp.w	r8,0
80007744:	c0 51       	brne	8000774e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80007746:	3f f9       	mov	r9,-1
80007748:	4b 18       	lddpc	r8,8000780c <vTaskIncrementTick+0xfc>
8000774a:	91 09       	st.w	r8[0x0],r9
8000774c:	c0 88       	rjmp	8000775c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000774e:	4a d8       	lddpc	r8,80007800 <vTaskIncrementTick+0xf0>
80007750:	70 08       	ld.w	r8,r8[0x0]
80007752:	70 38       	ld.w	r8,r8[0xc]
80007754:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80007756:	70 19       	ld.w	r9,r8[0x4]
80007758:	4a d8       	lddpc	r8,8000780c <vTaskIncrementTick+0xfc>
8000775a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000775c:	4a 88       	lddpc	r8,800077fc <vTaskIncrementTick+0xec>
8000775e:	70 09       	ld.w	r9,r8[0x0]
80007760:	4a b8       	lddpc	r8,8000780c <vTaskIncrementTick+0xfc>
80007762:	70 08       	ld.w	r8,r8[0x0]
80007764:	10 39       	cp.w	r9,r8
80007766:	c4 73       	brcs	800077f4 <vTaskIncrementTick+0xe4>
80007768:	4a 68       	lddpc	r8,80007800 <vTaskIncrementTick+0xf0>
8000776a:	70 08       	ld.w	r8,r8[0x0]
8000776c:	70 08       	ld.w	r8,r8[0x0]
8000776e:	58 08       	cp.w	r8,0
80007770:	c0 c0       	breq	80007788 <vTaskIncrementTick+0x78>
80007772:	4a 48       	lddpc	r8,80007800 <vTaskIncrementTick+0xf0>
80007774:	70 08       	ld.w	r8,r8[0x0]
80007776:	70 38       	ld.w	r8,r8[0xc]
80007778:	70 37       	ld.w	r7,r8[0xc]
8000777a:	6e 18       	ld.w	r8,r7[0x4]
8000777c:	4a 09       	lddpc	r9,800077fc <vTaskIncrementTick+0xec>
8000777e:	72 09       	ld.w	r9,r9[0x0]
80007780:	12 38       	cp.w	r8,r9
80007782:	e0 88 00 14 	brls	800077aa <vTaskIncrementTick+0x9a>
80007786:	c0 e8       	rjmp	800077a2 <vTaskIncrementTick+0x92>
80007788:	3f f9       	mov	r9,-1
8000778a:	4a 18       	lddpc	r8,8000780c <vTaskIncrementTick+0xfc>
8000778c:	91 09       	st.w	r8[0x0],r9
8000778e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007792:	6a 08       	ld.w	r8,r5[0x0]
80007794:	70 38       	ld.w	r8,r8[0xc]
80007796:	70 37       	ld.w	r7,r8[0xc]
80007798:	6e 18       	ld.w	r8,r7[0x4]
8000779a:	64 09       	ld.w	r9,r2[0x0]
8000779c:	12 38       	cp.w	r8,r9
8000779e:	e0 88 00 0a 	brls	800077b2 <vTaskIncrementTick+0xa2>
800077a2:	49 b9       	lddpc	r9,8000780c <vTaskIncrementTick+0xfc>
800077a4:	93 08       	st.w	r9[0x0],r8
800077a6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077aa:	49 a4       	lddpc	r4,80007810 <vTaskIncrementTick+0x100>
800077ac:	49 a3       	lddpc	r3,80007814 <vTaskIncrementTick+0x104>
800077ae:	49 55       	lddpc	r5,80007800 <vTaskIncrementTick+0xf0>
800077b0:	49 32       	lddpc	r2,800077fc <vTaskIncrementTick+0xec>
800077b2:	ee c6 ff fc 	sub	r6,r7,-4
800077b6:	0c 9c       	mov	r12,r6
800077b8:	f0 1f 00 18 	mcall	80007818 <vTaskIncrementTick+0x108>
800077bc:	6e a8       	ld.w	r8,r7[0x28]
800077be:	58 08       	cp.w	r8,0
800077c0:	c0 50       	breq	800077ca <vTaskIncrementTick+0xba>
800077c2:	ee cc ff e8 	sub	r12,r7,-24
800077c6:	f0 1f 00 15 	mcall	80007818 <vTaskIncrementTick+0x108>
800077ca:	6e bc       	ld.w	r12,r7[0x2c]
800077cc:	68 08       	ld.w	r8,r4[0x0]
800077ce:	10 3c       	cp.w	r12,r8
800077d0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800077d4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800077d8:	0c 9b       	mov	r11,r6
800077da:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800077de:	f0 1f 00 10 	mcall	8000781c <vTaskIncrementTick+0x10c>
800077e2:	6a 08       	ld.w	r8,r5[0x0]
800077e4:	70 08       	ld.w	r8,r8[0x0]
800077e6:	58 08       	cp.w	r8,0
800077e8:	cd 51       	brne	80007792 <vTaskIncrementTick+0x82>
800077ea:	cc fb       	rjmp	80007788 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800077ec:	48 d8       	lddpc	r8,80007820 <vTaskIncrementTick+0x110>
800077ee:	70 09       	ld.w	r9,r8[0x0]
800077f0:	2f f9       	sub	r9,-1
800077f2:	91 09       	st.w	r8[0x0],r9
800077f4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077f8:	00 00       	add	r0,r0
800077fa:	0d a4       	ld.ub	r4,r6[0x2]
800077fc:	00 00       	add	r0,r0
800077fe:	0d a0       	ld.ub	r0,r6[0x2]
80007800:	00 00       	add	r0,r0
80007802:	0c ac       	st.w	r6++,r12
80007804:	00 00       	add	r0,r0
80007806:	0c bc       	st.h	r6++,r12
80007808:	00 00       	add	r0,r0
8000780a:	0c b8       	st.h	r6++,r8
8000780c:	00 00       	add	r0,r0
8000780e:	05 50       	ld.sh	r0,--r2
80007810:	00 00       	add	r0,r0
80007812:	0d dc       	ld.ub	r12,r6[0x5]
80007814:	00 00       	add	r0,r0
80007816:	0c c0       	st.b	r6++,r0
80007818:	80 00       	ld.sh	r0,r0[0x0]
8000781a:	6c b6       	ld.w	r6,r6[0x2c]
8000781c:	80 00       	ld.sh	r0,r0[0x0]
8000781e:	6c 66       	ld.w	r6,r6[0x18]
80007820:	00 00       	add	r0,r0
80007822:	0c a4       	st.w	r6++,r4

80007824 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007824:	eb cd 40 c0 	pushm	r6-r7,lr
80007828:	18 97       	mov	r7,r12
8000782a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000782c:	f0 1f 00 15 	mcall	80007880 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80007830:	6c 08       	ld.w	r8,r6[0x0]
80007832:	5b f8       	cp.w	r8,-1
80007834:	c0 31       	brne	8000783a <xTaskCheckForTimeOut+0x16>
80007836:	30 07       	mov	r7,0
80007838:	c1 f8       	rjmp	80007876 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000783a:	49 39       	lddpc	r9,80007884 <xTaskCheckForTimeOut+0x60>
8000783c:	72 09       	ld.w	r9,r9[0x0]
8000783e:	6e 0a       	ld.w	r10,r7[0x0]
80007840:	12 3a       	cp.w	r10,r9
80007842:	c0 70       	breq	80007850 <xTaskCheckForTimeOut+0x2c>
80007844:	49 19       	lddpc	r9,80007888 <xTaskCheckForTimeOut+0x64>
80007846:	72 09       	ld.w	r9,r9[0x0]
80007848:	6e 1a       	ld.w	r10,r7[0x4]
8000784a:	12 3a       	cp.w	r10,r9
8000784c:	e0 88 00 14 	brls	80007874 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80007850:	48 e9       	lddpc	r9,80007888 <xTaskCheckForTimeOut+0x64>
80007852:	72 0a       	ld.w	r10,r9[0x0]
80007854:	6e 19       	ld.w	r9,r7[0x4]
80007856:	12 1a       	sub	r10,r9
80007858:	14 38       	cp.w	r8,r10
8000785a:	e0 88 00 0d 	brls	80007874 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000785e:	48 ba       	lddpc	r10,80007888 <xTaskCheckForTimeOut+0x64>
80007860:	74 0a       	ld.w	r10,r10[0x0]
80007862:	14 19       	sub	r9,r10
80007864:	f2 08 00 08 	add	r8,r9,r8
80007868:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000786a:	0e 9c       	mov	r12,r7
8000786c:	f0 1f 00 08 	mcall	8000788c <xTaskCheckForTimeOut+0x68>
80007870:	30 07       	mov	r7,0
80007872:	c0 28       	rjmp	80007876 <xTaskCheckForTimeOut+0x52>
80007874:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80007876:	f0 1f 00 07 	mcall	80007890 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000787a:	0e 9c       	mov	r12,r7
8000787c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007880:	80 00       	ld.sh	r0,r0[0x0]
80007882:	6d 70       	ld.w	r0,r6[0x5c]
80007884:	00 00       	add	r0,r0
80007886:	0c b8       	st.h	r6++,r8
80007888:	00 00       	add	r0,r0
8000788a:	0d a0       	ld.ub	r0,r6[0x2]
8000788c:	80 00       	ld.sh	r0,r0[0x0]
8000788e:	75 88       	ld.w	r8,r10[0x60]
80007890:	80 00       	ld.sh	r0,r0[0x0]
80007892:	6e 7c       	ld.w	r12,r7[0x1c]

80007894 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007894:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80007898:	f0 1f 00 05 	mcall	800078ac <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000789c:	48 58       	lddpc	r8,800078b0 <xTaskGetTickCount+0x1c>
8000789e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800078a0:	f0 1f 00 05 	mcall	800078b4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800078a4:	0e 9c       	mov	r12,r7
800078a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800078aa:	00 00       	add	r0,r0
800078ac:	80 00       	ld.sh	r0,r0[0x0]
800078ae:	6d 70       	ld.w	r0,r6[0x5c]
800078b0:	00 00       	add	r0,r0
800078b2:	0d a0       	ld.ub	r0,r6[0x2]
800078b4:	80 00       	ld.sh	r0,r0[0x0]
800078b6:	6e 7c       	ld.w	r12,r7[0x1c]

800078b8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800078b8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800078bc:	f0 1f 00 2c 	mcall	8000796c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800078c0:	4a c8       	lddpc	r8,80007970 <xTaskResumeAll+0xb8>
800078c2:	70 09       	ld.w	r9,r8[0x0]
800078c4:	20 19       	sub	r9,1
800078c6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800078c8:	70 08       	ld.w	r8,r8[0x0]
800078ca:	58 08       	cp.w	r8,0
800078cc:	c4 91       	brne	8000795e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800078ce:	4a a8       	lddpc	r8,80007974 <xTaskResumeAll+0xbc>
800078d0:	70 08       	ld.w	r8,r8[0x0]
800078d2:	58 08       	cp.w	r8,0
800078d4:	c4 50       	breq	8000795e <xTaskResumeAll+0xa6>
800078d6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800078d8:	4a 85       	lddpc	r5,80007978 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800078da:	4a 93       	lddpc	r3,8000797c <xTaskResumeAll+0xc4>
800078dc:	4a 92       	lddpc	r2,80007980 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800078de:	4a a1       	lddpc	r1,80007984 <xTaskResumeAll+0xcc>
800078e0:	c1 e8       	rjmp	8000791c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800078e2:	6a 38       	ld.w	r8,r5[0xc]
800078e4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800078e6:	ee cc ff e8 	sub	r12,r7,-24
800078ea:	f0 1f 00 28 	mcall	80007988 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800078ee:	ee c6 ff fc 	sub	r6,r7,-4
800078f2:	0c 9c       	mov	r12,r6
800078f4:	f0 1f 00 25 	mcall	80007988 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800078f8:	6e bc       	ld.w	r12,r7[0x2c]
800078fa:	66 08       	ld.w	r8,r3[0x0]
800078fc:	10 3c       	cp.w	r12,r8
800078fe:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007902:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007906:	0c 9b       	mov	r11,r6
80007908:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000790c:	f0 1f 00 20 	mcall	8000798c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007910:	62 08       	ld.w	r8,r1[0x0]
80007912:	6e b9       	ld.w	r9,r7[0x2c]
80007914:	70 b8       	ld.w	r8,r8[0x2c]
80007916:	10 39       	cp.w	r9,r8
80007918:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000791c:	6a 08       	ld.w	r8,r5[0x0]
8000791e:	58 08       	cp.w	r8,0
80007920:	ce 11       	brne	800078e2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007922:	49 c8       	lddpc	r8,80007990 <xTaskResumeAll+0xd8>
80007924:	70 08       	ld.w	r8,r8[0x0]
80007926:	58 08       	cp.w	r8,0
80007928:	c0 f0       	breq	80007946 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000792a:	49 a8       	lddpc	r8,80007990 <xTaskResumeAll+0xd8>
8000792c:	70 08       	ld.w	r8,r8[0x0]
8000792e:	58 08       	cp.w	r8,0
80007930:	c1 10       	breq	80007952 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80007932:	49 87       	lddpc	r7,80007990 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007934:	f0 1f 00 18 	mcall	80007994 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007938:	6e 08       	ld.w	r8,r7[0x0]
8000793a:	20 18       	sub	r8,1
8000793c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000793e:	6e 08       	ld.w	r8,r7[0x0]
80007940:	58 08       	cp.w	r8,0
80007942:	cf 91       	brne	80007934 <xTaskResumeAll+0x7c>
80007944:	c0 78       	rjmp	80007952 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80007946:	58 14       	cp.w	r4,1
80007948:	c0 50       	breq	80007952 <xTaskResumeAll+0x9a>
8000794a:	49 48       	lddpc	r8,80007998 <xTaskResumeAll+0xe0>
8000794c:	70 08       	ld.w	r8,r8[0x0]
8000794e:	58 18       	cp.w	r8,1
80007950:	c0 71       	brne	8000795e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80007952:	30 09       	mov	r9,0
80007954:	49 18       	lddpc	r8,80007998 <xTaskResumeAll+0xe0>
80007956:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007958:	d7 33       	scall
8000795a:	30 17       	mov	r7,1
8000795c:	c0 28       	rjmp	80007960 <xTaskResumeAll+0xa8>
8000795e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80007960:	f0 1f 00 0f 	mcall	8000799c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007964:	0e 9c       	mov	r12,r7
80007966:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000796a:	00 00       	add	r0,r0
8000796c:	80 00       	ld.sh	r0,r0[0x0]
8000796e:	6d 70       	ld.w	r0,r6[0x5c]
80007970:	00 00       	add	r0,r0
80007972:	0d a4       	ld.ub	r4,r6[0x2]
80007974:	00 00       	add	r0,r0
80007976:	0d c0       	ld.ub	r0,r6[0x4]
80007978:	00 00       	add	r0,r0
8000797a:	0d 78       	ld.ub	r8,--r6
8000797c:	00 00       	add	r0,r0
8000797e:	0d dc       	ld.ub	r12,r6[0x5]
80007980:	00 00       	add	r0,r0
80007982:	0c c0       	st.b	r6++,r0
80007984:	00 00       	add	r0,r0
80007986:	0d 74       	ld.ub	r4,--r6
80007988:	80 00       	ld.sh	r0,r0[0x0]
8000798a:	6c b6       	ld.w	r6,r6[0x2c]
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	6c 66       	ld.w	r6,r6[0x18]
80007990:	00 00       	add	r0,r0
80007992:	0c a4       	st.w	r6++,r4
80007994:	80 00       	ld.sh	r0,r0[0x0]
80007996:	77 10       	ld.w	r0,r11[0x44]
80007998:	00 00       	add	r0,r0
8000799a:	0d c4       	ld.ub	r4,r6[0x4]
8000799c:	80 00       	ld.sh	r0,r0[0x0]
8000799e:	6e 7c       	ld.w	r12,r7[0x1c]

800079a0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800079a0:	eb cd 40 80 	pushm	r7,lr
800079a4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800079a6:	49 08       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x44>
800079a8:	70 08       	ld.w	r8,r8[0x0]
800079aa:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800079ac:	48 f8       	lddpc	r8,800079e8 <prvAddCurrentTaskToDelayedList+0x48>
800079ae:	70 08       	ld.w	r8,r8[0x0]
800079b0:	10 3c       	cp.w	r12,r8
800079b2:	c0 a2       	brcc	800079c6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079b4:	48 c8       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x44>
800079b6:	70 0b       	ld.w	r11,r8[0x0]
800079b8:	48 d8       	lddpc	r8,800079ec <prvAddCurrentTaskToDelayedList+0x4c>
800079ba:	70 0c       	ld.w	r12,r8[0x0]
800079bc:	2f cb       	sub	r11,-4
800079be:	f0 1f 00 0d 	mcall	800079f0 <prvAddCurrentTaskToDelayedList+0x50>
800079c2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079c6:	48 88       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x44>
800079c8:	70 0b       	ld.w	r11,r8[0x0]
800079ca:	48 b8       	lddpc	r8,800079f4 <prvAddCurrentTaskToDelayedList+0x54>
800079cc:	70 0c       	ld.w	r12,r8[0x0]
800079ce:	2f cb       	sub	r11,-4
800079d0:	f0 1f 00 08 	mcall	800079f0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800079d4:	48 98       	lddpc	r8,800079f8 <prvAddCurrentTaskToDelayedList+0x58>
800079d6:	70 08       	ld.w	r8,r8[0x0]
800079d8:	10 37       	cp.w	r7,r8
800079da:	c0 32       	brcc	800079e0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800079dc:	48 78       	lddpc	r8,800079f8 <prvAddCurrentTaskToDelayedList+0x58>
800079de:	91 07       	st.w	r8[0x0],r7
800079e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800079e4:	00 00       	add	r0,r0
800079e6:	0d 74       	ld.ub	r4,--r6
800079e8:	00 00       	add	r0,r0
800079ea:	0d a0       	ld.ub	r0,r6[0x2]
800079ec:	00 00       	add	r0,r0
800079ee:	0c bc       	st.h	r6++,r12
800079f0:	80 00       	ld.sh	r0,r0[0x0]
800079f2:	6c 82       	ld.w	r2,r6[0x20]
800079f4:	00 00       	add	r0,r0
800079f6:	0c ac       	st.w	r6++,r12
800079f8:	00 00       	add	r0,r0
800079fa:	05 50       	ld.sh	r0,--r2

800079fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800079fc:	eb cd 40 c0 	pushm	r6-r7,lr
80007a00:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80007a02:	58 0c       	cp.w	r12,0
80007a04:	c1 10       	breq	80007a26 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80007a06:	f0 1f 00 0a 	mcall	80007a2c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80007a0a:	48 a8       	lddpc	r8,80007a30 <vTaskDelay+0x34>
80007a0c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a0e:	48 a8       	lddpc	r8,80007a34 <vTaskDelay+0x38>
80007a10:	70 0c       	ld.w	r12,r8[0x0]
80007a12:	2f cc       	sub	r12,-4
80007a14:	f0 1f 00 09 	mcall	80007a38 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a18:	ee 06 00 0c 	add	r12,r7,r6
80007a1c:	f0 1f 00 08 	mcall	80007a3c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007a20:	f0 1f 00 08 	mcall	80007a40 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a24:	c0 21       	brne	80007a28 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80007a26:	d7 33       	scall
80007a28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	74 fc       	ld.w	r12,r10[0x3c]
80007a30:	00 00       	add	r0,r0
80007a32:	0d a0       	ld.ub	r0,r6[0x2]
80007a34:	00 00       	add	r0,r0
80007a36:	0d 74       	ld.ub	r4,--r6
80007a38:	80 00       	ld.sh	r0,r0[0x0]
80007a3a:	6c b6       	ld.w	r6,r6[0x2c]
80007a3c:	80 00       	ld.sh	r0,r0[0x0]
80007a3e:	79 a0       	ld.w	r0,r12[0x68]
80007a40:	80 00       	ld.sh	r0,r0[0x0]
80007a42:	78 b8       	ld.w	r8,r12[0x2c]

80007a44 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007a44:	eb cd 40 c0 	pushm	r6-r7,lr
80007a48:	18 96       	mov	r6,r12
80007a4a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007a4c:	f0 1f 00 18 	mcall	80007aac <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007a50:	6c 08       	ld.w	r8,r6[0x0]
80007a52:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007a54:	49 79       	lddpc	r9,80007ab0 <vTaskDelayUntil+0x6c>
80007a56:	72 09       	ld.w	r9,r9[0x0]
80007a58:	12 38       	cp.w	r8,r9
80007a5a:	e0 88 00 0c 	brls	80007a72 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007a5e:	0e 38       	cp.w	r8,r7
80007a60:	e0 88 00 22 	brls	80007aa4 <vTaskDelayUntil+0x60>
80007a64:	49 38       	lddpc	r8,80007ab0 <vTaskDelayUntil+0x6c>
80007a66:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a68:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007a6a:	10 37       	cp.w	r7,r8
80007a6c:	e0 88 00 14 	brls	80007a94 <vTaskDelayUntil+0x50>
80007a70:	c0 a8       	rjmp	80007a84 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007a72:	0e 38       	cp.w	r8,r7
80007a74:	e0 8b 00 16 	brhi	80007aa0 <vTaskDelayUntil+0x5c>
80007a78:	48 e8       	lddpc	r8,80007ab0 <vTaskDelayUntil+0x6c>
80007a7a:	70 08       	ld.w	r8,r8[0x0]
80007a7c:	10 37       	cp.w	r7,r8
80007a7e:	e0 8b 00 11 	brhi	80007aa0 <vTaskDelayUntil+0x5c>
80007a82:	c1 18       	rjmp	80007aa4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a84:	48 c8       	lddpc	r8,80007ab4 <vTaskDelayUntil+0x70>
80007a86:	70 0c       	ld.w	r12,r8[0x0]
80007a88:	2f cc       	sub	r12,-4
80007a8a:	f0 1f 00 0c 	mcall	80007ab8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a8e:	0e 9c       	mov	r12,r7
80007a90:	f0 1f 00 0b 	mcall	80007abc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007a94:	f0 1f 00 0b 	mcall	80007ac0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a98:	c0 81       	brne	80007aa8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007a9a:	d7 33       	scall
80007a9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007aa0:	8d 07       	st.w	r6[0x0],r7
80007aa2:	cf 1b       	rjmp	80007a84 <vTaskDelayUntil+0x40>
80007aa4:	8d 07       	st.w	r6[0x0],r7
80007aa6:	cf 7b       	rjmp	80007a94 <vTaskDelayUntil+0x50>
80007aa8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007aac:	80 00       	ld.sh	r0,r0[0x0]
80007aae:	74 fc       	ld.w	r12,r10[0x3c]
80007ab0:	00 00       	add	r0,r0
80007ab2:	0d a0       	ld.ub	r0,r6[0x2]
80007ab4:	00 00       	add	r0,r0
80007ab6:	0d 74       	ld.ub	r4,--r6
80007ab8:	80 00       	ld.sh	r0,r0[0x0]
80007aba:	6c b6       	ld.w	r6,r6[0x2c]
80007abc:	80 00       	ld.sh	r0,r0[0x0]
80007abe:	79 a0       	ld.w	r0,r12[0x68]
80007ac0:	80 00       	ld.sh	r0,r0[0x0]
80007ac2:	78 b8       	ld.w	r8,r12[0x2c]

80007ac4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80007ac8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007aca:	48 e7       	lddpc	r7,80007b00 <vTaskPlaceOnEventList+0x3c>
80007acc:	6e 0b       	ld.w	r11,r7[0x0]
80007ace:	2e 8b       	sub	r11,-24
80007ad0:	f0 1f 00 0d 	mcall	80007b04 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007ad4:	6e 0c       	ld.w	r12,r7[0x0]
80007ad6:	2f cc       	sub	r12,-4
80007ad8:	f0 1f 00 0c 	mcall	80007b08 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007adc:	5b f6       	cp.w	r6,-1
80007ade:	c0 81       	brne	80007aee <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007ae0:	6e 0b       	ld.w	r11,r7[0x0]
80007ae2:	2f cb       	sub	r11,-4
80007ae4:	48 ac       	lddpc	r12,80007b0c <vTaskPlaceOnEventList+0x48>
80007ae6:	f0 1f 00 0b 	mcall	80007b10 <vTaskPlaceOnEventList+0x4c>
80007aea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007aee:	48 a8       	lddpc	r8,80007b14 <vTaskPlaceOnEventList+0x50>
80007af0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007af2:	ec 0c 00 0c 	add	r12,r6,r12
80007af6:	f0 1f 00 09 	mcall	80007b18 <vTaskPlaceOnEventList+0x54>
80007afa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007afe:	00 00       	add	r0,r0
80007b00:	00 00       	add	r0,r0
80007b02:	0d 74       	ld.ub	r4,--r6
80007b04:	80 00       	ld.sh	r0,r0[0x0]
80007b06:	6c 82       	ld.w	r2,r6[0x20]
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	6c b6       	ld.w	r6,r6[0x2c]
80007b0c:	00 00       	add	r0,r0
80007b0e:	0d c8       	ld.ub	r8,r6[0x4]
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	6c 66       	ld.w	r6,r6[0x18]
80007b14:	00 00       	add	r0,r0
80007b16:	0d a0       	ld.ub	r0,r6[0x2]
80007b18:	80 00       	ld.sh	r0,r0[0x0]
80007b1a:	79 a0       	ld.w	r0,r12[0x68]

80007b1c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007b1c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b20:	49 67       	lddpc	r7,80007b78 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b22:	49 74       	lddpc	r4,80007b7c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007b24:	49 73       	lddpc	r3,80007b80 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b26:	49 85       	lddpc	r5,80007b84 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b28:	6e 08       	ld.w	r8,r7[0x0]
80007b2a:	58 08       	cp.w	r8,0
80007b2c:	c1 e0       	breq	80007b68 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007b2e:	f0 1f 00 17 	mcall	80007b88 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b32:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007b34:	f0 1f 00 16 	mcall	80007b8c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007b38:	58 06       	cp.w	r6,0
80007b3a:	c1 70       	breq	80007b68 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007b3c:	f0 1f 00 15 	mcall	80007b90 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007b40:	68 38       	ld.w	r8,r4[0xc]
80007b42:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007b44:	ec cc ff fc 	sub	r12,r6,-4
80007b48:	f0 1f 00 13 	mcall	80007b94 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007b4c:	66 08       	ld.w	r8,r3[0x0]
80007b4e:	20 18       	sub	r8,1
80007b50:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007b52:	6e 08       	ld.w	r8,r7[0x0]
80007b54:	20 18       	sub	r8,1
80007b56:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007b58:	f0 1f 00 10 	mcall	80007b98 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007b5c:	6c cc       	ld.w	r12,r6[0x30]
80007b5e:	f0 1f 00 10 	mcall	80007b9c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007b62:	0c 9c       	mov	r12,r6
80007b64:	f0 1f 00 0e 	mcall	80007b9c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b68:	6a 08       	ld.w	r8,r5[0x0]
80007b6a:	58 18       	cp.w	r8,1
80007b6c:	e0 88 00 03 	brls	80007b72 <prvIdleTask+0x56>
			{
				taskYIELD();
80007b70:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007b72:	f0 1f 00 0c 	mcall	80007ba0 <prvIdleTask+0x84>
		}
		#endif
	}
80007b76:	cd 9b       	rjmp	80007b28 <prvIdleTask+0xc>
80007b78:	00 00       	add	r0,r0
80007b7a:	0c b4       	st.h	r6++,r4
80007b7c:	00 00       	add	r0,r0
80007b7e:	0d 60       	ld.uh	r0,--r6
80007b80:	00 00       	add	r0,r0
80007b82:	0d c0       	ld.ub	r0,r6[0x4]
80007b84:	00 00       	add	r0,r0
80007b86:	0c c0       	st.b	r6++,r0
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	74 fc       	ld.w	r12,r10[0x3c]
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	78 b8       	ld.w	r8,r12[0x2c]
80007b90:	80 00       	ld.sh	r0,r0[0x0]
80007b92:	6d 70       	ld.w	r0,r6[0x5c]
80007b94:	80 00       	ld.sh	r0,r0[0x0]
80007b96:	6c b6       	ld.w	r6,r6[0x2c]
80007b98:	80 00       	ld.sh	r0,r0[0x0]
80007b9a:	6e 7c       	ld.w	r12,r7[0x1c]
80007b9c:	80 00       	ld.sh	r0,r0[0x0]
80007b9e:	6f b4       	ld.w	r4,r7[0x6c]
80007ba0:	80 00       	ld.sh	r0,r0[0x0]
80007ba2:	20 2c       	sub	r12,2

80007ba4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007ba4:	d4 31       	pushm	r0-r7,lr
80007ba6:	20 1d       	sub	sp,4
80007ba8:	fa c4 ff d8 	sub	r4,sp,-40
80007bac:	50 0c       	stdsp	sp[0x0],r12
80007bae:	16 91       	mov	r1,r11
80007bb0:	14 97       	mov	r7,r10
80007bb2:	12 90       	mov	r0,r9
80007bb4:	10 93       	mov	r3,r8
80007bb6:	68 02       	ld.w	r2,r4[0x0]
80007bb8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007bba:	34 8c       	mov	r12,72
80007bbc:	f0 1f 00 5c 	mcall	80007d2c <xTaskGenericCreate+0x188>
80007bc0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007bc2:	c0 31       	brne	80007bc8 <xTaskGenericCreate+0x24>
80007bc4:	3f fc       	mov	r12,-1
80007bc6:	ca f8       	rjmp	80007d24 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007bc8:	58 06       	cp.w	r6,0
80007bca:	e0 81 00 af 	brne	80007d28 <xTaskGenericCreate+0x184>
80007bce:	0e 9c       	mov	r12,r7
80007bd0:	5c 7c       	castu.h	r12
80007bd2:	a3 6c       	lsl	r12,0x2
80007bd4:	f0 1f 00 56 	mcall	80007d2c <xTaskGenericCreate+0x188>
80007bd8:	18 96       	mov	r6,r12
80007bda:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007bdc:	c0 61       	brne	80007be8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007bde:	0a 9c       	mov	r12,r5
80007be0:	f0 1f 00 54 	mcall	80007d30 <xTaskGenericCreate+0x18c>
80007be4:	3f fc       	mov	r12,-1
80007be6:	c9 f8       	rjmp	80007d24 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007be8:	5c 77       	castu.h	r7
80007bea:	ee 0a 15 02 	lsl	r10,r7,0x2
80007bee:	e0 6b 00 a5 	mov	r11,165
80007bf2:	0c 9c       	mov	r12,r6
80007bf4:	f0 1f 00 50 	mcall	80007d34 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007bf8:	ee c6 00 01 	sub	r6,r7,1
80007bfc:	6a c8       	ld.w	r8,r5[0x30]
80007bfe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007c02:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007c06:	31 0a       	mov	r10,16
80007c08:	02 9b       	mov	r11,r1
80007c0a:	ea cc ff cc 	sub	r12,r5,-52
80007c0e:	f0 1f 00 4b 	mcall	80007d38 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007c12:	30 08       	mov	r8,0
80007c14:	eb 68 00 43 	st.b	r5[67],r8
80007c18:	58 73       	cp.w	r3,7
80007c1a:	e6 07 17 80 	movls	r7,r3
80007c1e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007c22:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007c24:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007c28:	ea c4 ff fc 	sub	r4,r5,-4
80007c2c:	08 9c       	mov	r12,r4
80007c2e:	f0 1f 00 44 	mcall	80007d3c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007c32:	ea cc ff e8 	sub	r12,r5,-24
80007c36:	f0 1f 00 42 	mcall	80007d3c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007c3a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007c3c:	ee 07 11 08 	rsub	r7,r7,8
80007c40:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007c42:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007c44:	00 9a       	mov	r10,r0
80007c46:	40 0b       	lddsp	r11,sp[0x0]
80007c48:	0c 9c       	mov	r12,r6
80007c4a:	f0 1f 00 3e 	mcall	80007d40 <xTaskGenericCreate+0x19c>
80007c4e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007c50:	58 02       	cp.w	r2,0
80007c52:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007c56:	f0 1f 00 3c 	mcall	80007d44 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007c5a:	4b c8       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a4>
80007c5c:	70 09       	ld.w	r9,r8[0x0]
80007c5e:	2f f9       	sub	r9,-1
80007c60:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007c62:	4b b8       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1a8>
80007c64:	70 08       	ld.w	r8,r8[0x0]
80007c66:	58 08       	cp.w	r8,0
80007c68:	c2 61       	brne	80007cb4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007c6a:	4b 98       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1a8>
80007c6c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007c6e:	4b 78       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a4>
80007c70:	70 08       	ld.w	r8,r8[0x0]
80007c72:	58 18       	cp.w	r8,1
80007c74:	c2 b1       	brne	80007cca <xTaskGenericCreate+0x126>
80007c76:	4b 77       	lddpc	r7,80007d50 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007c78:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007c7c:	0e 9c       	mov	r12,r7
80007c7e:	f0 1f 00 36 	mcall	80007d54 <xTaskGenericCreate+0x1b0>
80007c82:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007c84:	0c 37       	cp.w	r7,r6
80007c86:	cf b1       	brne	80007c7c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007c88:	4b 47       	lddpc	r7,80007d58 <xTaskGenericCreate+0x1b4>
80007c8a:	0e 9c       	mov	r12,r7
80007c8c:	f0 1f 00 32 	mcall	80007d54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007c90:	4b 36       	lddpc	r6,80007d5c <xTaskGenericCreate+0x1b8>
80007c92:	0c 9c       	mov	r12,r6
80007c94:	f0 1f 00 30 	mcall	80007d54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007c98:	4b 2c       	lddpc	r12,80007d60 <xTaskGenericCreate+0x1bc>
80007c9a:	f0 1f 00 2f 	mcall	80007d54 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007c9e:	4b 2c       	lddpc	r12,80007d64 <xTaskGenericCreate+0x1c0>
80007ca0:	f0 1f 00 2d 	mcall	80007d54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007ca4:	4b 1c       	lddpc	r12,80007d68 <xTaskGenericCreate+0x1c4>
80007ca6:	f0 1f 00 2c 	mcall	80007d54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007caa:	4b 18       	lddpc	r8,80007d6c <xTaskGenericCreate+0x1c8>
80007cac:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007cae:	4b 18       	lddpc	r8,80007d70 <xTaskGenericCreate+0x1cc>
80007cb0:	91 06       	st.w	r8[0x0],r6
80007cb2:	c0 c8       	rjmp	80007cca <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007cb4:	4b 08       	lddpc	r8,80007d74 <xTaskGenericCreate+0x1d0>
80007cb6:	70 08       	ld.w	r8,r8[0x0]
80007cb8:	58 08       	cp.w	r8,0
80007cba:	c0 81       	brne	80007cca <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007cbc:	4a 48       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1a8>
80007cbe:	70 08       	ld.w	r8,r8[0x0]
80007cc0:	70 b8       	ld.w	r8,r8[0x2c]
80007cc2:	10 33       	cp.w	r3,r8
80007cc4:	c0 33       	brcs	80007cca <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007cc6:	4a 28       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1a8>
80007cc8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007cca:	6a b8       	ld.w	r8,r5[0x2c]
80007ccc:	4a b9       	lddpc	r9,80007d78 <xTaskGenericCreate+0x1d4>
80007cce:	72 09       	ld.w	r9,r9[0x0]
80007cd0:	12 38       	cp.w	r8,r9
80007cd2:	e0 88 00 04 	brls	80007cda <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007cd6:	4a 99       	lddpc	r9,80007d78 <xTaskGenericCreate+0x1d4>
80007cd8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007cda:	4a 98       	lddpc	r8,80007d7c <xTaskGenericCreate+0x1d8>
80007cdc:	70 09       	ld.w	r9,r8[0x0]
80007cde:	2f f9       	sub	r9,-1
80007ce0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007ce2:	6a b8       	ld.w	r8,r5[0x2c]
80007ce4:	4a 79       	lddpc	r9,80007d80 <xTaskGenericCreate+0x1dc>
80007ce6:	72 09       	ld.w	r9,r9[0x0]
80007ce8:	12 38       	cp.w	r8,r9
80007cea:	e0 88 00 04 	brls	80007cf2 <xTaskGenericCreate+0x14e>
80007cee:	4a 59       	lddpc	r9,80007d80 <xTaskGenericCreate+0x1dc>
80007cf0:	93 08       	st.w	r9[0x0],r8
80007cf2:	6a bc       	ld.w	r12,r5[0x2c]
80007cf4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007cf8:	08 9b       	mov	r11,r4
80007cfa:	49 68       	lddpc	r8,80007d50 <xTaskGenericCreate+0x1ac>
80007cfc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007d00:	f0 1f 00 21 	mcall	80007d84 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007d04:	f0 1f 00 21 	mcall	80007d88 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007d08:	49 b8       	lddpc	r8,80007d74 <xTaskGenericCreate+0x1d0>
80007d0a:	70 08       	ld.w	r8,r8[0x0]
80007d0c:	58 08       	cp.w	r8,0
80007d0e:	c0 a0       	breq	80007d22 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007d10:	48 f8       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1a8>
80007d12:	70 08       	ld.w	r8,r8[0x0]
80007d14:	70 b8       	ld.w	r8,r8[0x2c]
80007d16:	10 33       	cp.w	r3,r8
80007d18:	e0 88 00 05 	brls	80007d22 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007d1c:	d7 33       	scall
80007d1e:	30 1c       	mov	r12,1
80007d20:	c0 28       	rjmp	80007d24 <xTaskGenericCreate+0x180>
80007d22:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007d24:	2f fd       	sub	sp,-4
80007d26:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007d28:	99 c6       	st.w	r12[0x30],r6
80007d2a:	c5 fb       	rjmp	80007be8 <xTaskGenericCreate+0x44>
80007d2c:	80 00       	ld.sh	r0,r0[0x0]
80007d2e:	6f dc       	ld.w	r12,r7[0x74]
80007d30:	80 00       	ld.sh	r0,r0[0x0]
80007d32:	6f b4       	ld.w	r4,r7[0x6c]
80007d34:	80 00       	ld.sh	r0,r0[0x0]
80007d36:	89 5a       	st.w	r4[0x14],r10
80007d38:	80 00       	ld.sh	r0,r0[0x0]
80007d3a:	8c 84       	ld.uh	r4,r6[0x0]
80007d3c:	80 00       	ld.sh	r0,r0[0x0]
80007d3e:	6c 60       	ld.w	r0,r6[0x18]
80007d40:	80 00       	ld.sh	r0,r0[0x0]
80007d42:	6c dc       	ld.w	r12,r6[0x34]
80007d44:	80 00       	ld.sh	r0,r0[0x0]
80007d46:	6d 70       	ld.w	r0,r6[0x5c]
80007d48:	00 00       	add	r0,r0
80007d4a:	0d c0       	ld.ub	r0,r6[0x4]
80007d4c:	00 00       	add	r0,r0
80007d4e:	0d 74       	ld.ub	r4,--r6
80007d50:	00 00       	add	r0,r0
80007d52:	0c c0       	st.b	r6++,r0
80007d54:	80 00       	ld.sh	r0,r0[0x0]
80007d56:	6c 4c       	ld.w	r12,r6[0x10]
80007d58:	00 00       	add	r0,r0
80007d5a:	0d 8c       	ld.ub	r12,r6[0x0]
80007d5c:	00 00       	add	r0,r0
80007d5e:	0d a8       	ld.ub	r8,r6[0x2]
80007d60:	00 00       	add	r0,r0
80007d62:	0d 78       	ld.ub	r8,--r6
80007d64:	00 00       	add	r0,r0
80007d66:	0d 60       	ld.uh	r0,--r6
80007d68:	00 00       	add	r0,r0
80007d6a:	0d c8       	ld.ub	r8,r6[0x4]
80007d6c:	00 00       	add	r0,r0
80007d6e:	0c ac       	st.w	r6++,r12
80007d70:	00 00       	add	r0,r0
80007d72:	0c bc       	st.h	r6++,r12
80007d74:	00 00       	add	r0,r0
80007d76:	0c b0       	st.h	r6++,r0
80007d78:	00 00       	add	r0,r0
80007d7a:	0c a8       	st.w	r6++,r8
80007d7c:	00 00       	add	r0,r0
80007d7e:	0d bc       	ld.ub	r12,r6[0x3]
80007d80:	00 00       	add	r0,r0
80007d82:	0d dc       	ld.ub	r12,r6[0x5]
80007d84:	80 00       	ld.sh	r0,r0[0x0]
80007d86:	6c 66       	ld.w	r6,r6[0x18]
80007d88:	80 00       	ld.sh	r0,r0[0x0]
80007d8a:	6e 7c       	ld.w	r12,r7[0x1c]

80007d8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007d8c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007d8e:	30 09       	mov	r9,0
80007d90:	1a d9       	st.w	--sp,r9
80007d92:	1a d9       	st.w	--sp,r9
80007d94:	1a d9       	st.w	--sp,r9
80007d96:	12 98       	mov	r8,r9
80007d98:	e0 6a 01 00 	mov	r10,256
80007d9c:	48 9b       	lddpc	r11,80007dc0 <vTaskStartScheduler+0x34>
80007d9e:	48 ac       	lddpc	r12,80007dc4 <vTaskStartScheduler+0x38>
80007da0:	f0 1f 00 0a 	mcall	80007dc8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007da4:	2f dd       	sub	sp,-12
80007da6:	58 1c       	cp.w	r12,1
80007da8:	c0 a1       	brne	80007dbc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007daa:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007dac:	30 19       	mov	r9,1
80007dae:	48 88       	lddpc	r8,80007dcc <vTaskStartScheduler+0x40>
80007db0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007db2:	30 09       	mov	r9,0
80007db4:	48 78       	lddpc	r8,80007dd0 <vTaskStartScheduler+0x44>
80007db6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007db8:	f0 1f 00 07 	mcall	80007dd4 <vTaskStartScheduler+0x48>
80007dbc:	d8 02       	popm	pc
80007dbe:	00 00       	add	r0,r0
80007dc0:	80 00       	ld.sh	r0,r0[0x0]
80007dc2:	ed b4       	*unknown*
80007dc4:	80 00       	ld.sh	r0,r0[0x0]
80007dc6:	7b 1c       	ld.w	r12,sp[0x44]
80007dc8:	80 00       	ld.sh	r0,r0[0x0]
80007dca:	7b a4       	ld.w	r4,sp[0x68]
80007dcc:	00 00       	add	r0,r0
80007dce:	0c b0       	st.h	r6++,r0
80007dd0:	00 00       	add	r0,r0
80007dd2:	0d a0       	ld.ub	r0,r6[0x2]
80007dd4:	80 00       	ld.sh	r0,r0[0x0]
80007dd6:	6d 80       	ld.w	r0,r6[0x60]

80007dd8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007dd8:	16 cc       	st.b	r11++,r12
	return str;
}
80007dda:	5e fb       	retal	r11

80007ddc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007ddc:	eb cd 40 c0 	pushm	r6-r7,lr
80007de0:	20 3d       	sub	sp,12
80007de2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007de4:	30 06       	mov	r6,0
80007de6:	30 07       	mov	r7,0
80007de8:	fa e7 00 00 	st.d	sp[0],r6
80007dec:	30 0c       	mov	r12,0
80007dee:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007df0:	58 08       	cp.w	r8,0
80007df2:	c1 30       	breq	80007e18 <PrintHex+0x3c>
80007df4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007df6:	1a 9c       	mov	r12,sp
80007df8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007dfc:	58 9e       	cp.w	lr,9
80007dfe:	e0 8a 00 04 	brle	80007e06 <PrintHex+0x2a>
80007e02:	2c 9e       	sub	lr,-55
80007e04:	c0 48       	rjmp	80007e0c <PrintHex+0x30>
80007e06:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007e0a:	2d 0e       	sub	lr,-48
80007e0c:	f8 09 0b 0e 	st.b	r12[r9],lr
80007e10:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007e12:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007e14:	cf 21       	brne	80007df8 <PrintHex+0x1c>
80007e16:	c0 48       	rjmp	80007e1e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007e18:	33 08       	mov	r8,48
80007e1a:	ba 88       	st.b	sp[0x0],r8
80007e1c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007e1e:	f6 09 01 08 	sub	r8,r11,r9
80007e22:	58 08       	cp.w	r8,0
80007e24:	e0 8a 00 13 	brle	80007e4a <PrintHex+0x6e>
	{
		char num = len - cnt;
80007e28:	12 1b       	sub	r11,r9
80007e2a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007e2e:	18 9e       	mov	lr,r12
80007e30:	58 0c       	cp.w	r12,0
80007e32:	e0 8a 00 0c 	brle	80007e4a <PrintHex+0x6e>
80007e36:	1a 9b       	mov	r11,sp
80007e38:	12 0b       	add	r11,r9
80007e3a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007e3c:	33 07       	mov	r7,48
80007e3e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007e40:	2f f8       	sub	r8,-1
80007e42:	1c 38       	cp.w	r8,lr
80007e44:	cf d5       	brlt	80007e3e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e46:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e4a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007e4e:	f0 cb ff ff 	sub	r11,r8,-1
80007e52:	58 0b       	cp.w	r11,0
80007e54:	e0 8a 00 19 	brle	80007e86 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e58:	fa cb ff f4 	sub	r11,sp,-12
80007e5c:	f6 09 00 09 	add	r9,r11,r9
80007e60:	37 8b       	mov	r11,120
80007e62:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007e66:	fa c9 ff f4 	sub	r9,sp,-12
80007e6a:	10 09       	add	r9,r8
80007e6c:	33 0b       	mov	r11,48
80007e6e:	f3 6b ff f4 	st.b	r9[-12],r11
80007e72:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e76:	fa ce 00 01 	sub	lr,sp,1
80007e7a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007e7c:	11 8b       	ld.ub	r11,r8[0x0]
80007e7e:	12 cb       	st.b	r9++,r11
80007e80:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007e82:	1c 38       	cp.w	r8,lr
80007e84:	cf c1       	brne	80007e7c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007e86:	14 9c       	mov	r12,r10
80007e88:	2f dd       	sub	sp,-12
80007e8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007e8e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007e8e:	d4 21       	pushm	r4-r7,lr
80007e90:	20 3d       	sub	sp,12
80007e92:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007e94:	30 06       	mov	r6,0
80007e96:	30 07       	mov	r7,0
80007e98:	fa e7 00 00 	st.d	sp[0],r6
80007e9c:	30 0c       	mov	r12,0
80007e9e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007ea0:	58 08       	cp.w	r8,0
80007ea2:	c0 35       	brlt	80007ea8 <PrintDec+0x1a>
80007ea4:	14 97       	mov	r7,r10
80007ea6:	c0 58       	rjmp	80007eb0 <PrintDec+0x22>
	{
		*p++ = '-';
80007ea8:	14 97       	mov	r7,r10
80007eaa:	32 d9       	mov	r9,45
80007eac:	0e c9       	st.b	r7++,r9
		i = -i;
80007eae:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007eb0:	58 08       	cp.w	r8,0
80007eb2:	c0 51       	brne	80007ebc <PrintDec+0x2e>
80007eb4:	33 08       	mov	r8,48
80007eb6:	ba 88       	st.b	sp[0x0],r8
80007eb8:	30 1e       	mov	lr,1
80007eba:	c2 f8       	rjmp	80007f18 <PrintDec+0x8a>
	
	int ten = i%10;
80007ebc:	e0 65 66 67 	mov	r5,26215
80007ec0:	ea 15 66 66 	orh	r5,0x6666
80007ec4:	f0 05 04 44 	muls.d	r4,r8,r5
80007ec8:	ea 0c 14 02 	asr	r12,r5,0x2
80007ecc:	f0 09 14 1f 	asr	r9,r8,0x1f
80007ed0:	f8 09 01 09 	sub	r9,r12,r9
80007ed4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ed8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007edc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007ede:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007ee0:	e0 66 66 67 	mov	r6,26215
80007ee4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007ee8:	2d 09       	sub	r9,-48
80007eea:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007eee:	2f fe       	sub	lr,-1
		i /= 10;
80007ef0:	f0 06 04 44 	muls.d	r4,r8,r6
80007ef4:	ea 09 14 02 	asr	r9,r5,0x2
80007ef8:	bf 58       	asr	r8,0x1f
80007efa:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007efe:	f0 06 04 44 	muls.d	r4,r8,r6
80007f02:	ea 09 14 02 	asr	r9,r5,0x2
80007f06:	f0 05 14 1f 	asr	r5,r8,0x1f
80007f0a:	0a 19       	sub	r9,r5
80007f0c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f10:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007f14:	58 08       	cp.w	r8,0
80007f16:	ce 91       	brne	80007ee8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007f18:	f6 0e 01 08 	sub	r8,r11,lr
80007f1c:	58 08       	cp.w	r8,0
80007f1e:	e0 89 00 06 	brgt	80007f2a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f22:	58 0e       	cp.w	lr,0
80007f24:	e0 89 00 14 	brgt	80007f4c <PrintDec+0xbe>
80007f28:	c1 d8       	rjmp	80007f62 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007f2a:	1c 1b       	sub	r11,lr
80007f2c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007f2e:	16 9c       	mov	r12,r11
80007f30:	58 0b       	cp.w	r11,0
80007f32:	fe 9a ff f8 	brle	80007f22 <PrintDec+0x94>
80007f36:	1a 99       	mov	r9,sp
80007f38:	1c 09       	add	r9,lr
80007f3a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007f3c:	33 06       	mov	r6,48
80007f3e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007f40:	2f f8       	sub	r8,-1
80007f42:	18 38       	cp.w	r8,r12
80007f44:	cf d5       	brlt	80007f3e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007f46:	f6 0e 00 0e 	add	lr,r11,lr
80007f4a:	ce cb       	rjmp	80007f22 <PrintDec+0x94>
80007f4c:	fa c8 ff f4 	sub	r8,sp,-12
80007f50:	1c 08       	add	r8,lr
80007f52:	20 d8       	sub	r8,13
80007f54:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007f58:	11 89       	ld.ub	r9,r8[0x0]
80007f5a:	0e c9       	st.b	r7++,r9
80007f5c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f5e:	16 38       	cp.w	r8,r11
80007f60:	cf c1       	brne	80007f58 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007f62:	14 9c       	mov	r12,r10
80007f64:	2f dd       	sub	sp,-12
80007f66:	d8 22       	popm	r4-r7,pc

80007f68 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007f68:	d4 31       	pushm	r0-r7,lr
80007f6a:	fa cd 02 08 	sub	sp,sp,520
80007f6e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007f70:	e0 6a 01 00 	mov	r10,256
80007f74:	30 0b       	mov	r11,0
80007f76:	fa cc fe f8 	sub	r12,sp,-264
80007f7a:	f0 1f 00 4e 	mcall	800080b0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007f7e:	fa c4 fd d4 	sub	r4,sp,-556
80007f82:	30 0a       	mov	r10,0
80007f84:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f86:	fa c3 ff fc 	sub	r3,sp,-4
80007f8a:	e0 61 01 00 	mov	r1,256
80007f8e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007f90:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007f92:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f96:	02 9a       	mov	r10,r1
80007f98:	00 9b       	mov	r11,r0
80007f9a:	06 9c       	mov	r12,r3
80007f9c:	f0 1f 00 45 	mcall	800080b0 <log+0x148>
			
					if(*str == '%')
80007fa0:	0f 88       	ld.ub	r8,r7[0x0]
80007fa2:	e4 08 18 00 	cp.b	r8,r2
80007fa6:	c5 71       	brne	80008054 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007fa8:	ee c8 ff ff 	sub	r8,r7,-1
80007fac:	11 89       	ld.ub	r9,r8[0x0]
80007fae:	4c 2a       	lddpc	r10,800080b4 <log+0x14c>
80007fb0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007fb2:	23 09       	sub	r9,48
80007fb4:	30 9a       	mov	r10,9
80007fb6:	f4 09 18 00 	cp.b	r9,r10
80007fba:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007fbe:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007fc2:	f7 b9 08 30 	subls	r9,48
80007fc6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007fca:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007fce:	0f 88       	ld.ub	r8,r7[0x0]
80007fd0:	22 58       	sub	r8,37
80007fd2:	e0 48 00 53 	cp.w	r8,83
80007fd6:	e0 8b 00 31 	brhi	80008038 <log+0xd0>
80007fda:	4b 89       	lddpc	r9,800080b8 <log+0x150>
80007fdc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007fe0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007fe4:	06 9a       	mov	r10,r3
80007fe6:	40 0b       	lddsp	r11,sp[0x0]
80007fe8:	5c 5b       	castu.b	r11
80007fea:	68 0c       	ld.w	r12,r4[0x0]
80007fec:	f0 1f 00 34 	mcall	800080bc <log+0x154>
							break;
80007ff0:	c2 98       	rjmp	80008042 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007ff2:	4b 4c       	lddpc	r12,800080c0 <log+0x158>
80007ff4:	f0 1f 00 34 	mcall	800080c4 <log+0x15c>
80007ff8:	08 95       	mov	r5,r4
80007ffa:	06 9c       	mov	r12,r3
							break;
80007ffc:	c2 38       	rjmp	80008042 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007ffe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80008002:	06 9a       	mov	r10,r3
80008004:	40 0b       	lddsp	r11,sp[0x0]
80008006:	5c 5b       	castu.b	r11
80008008:	68 0c       	ld.w	r12,r4[0x0]
8000800a:	f0 1f 00 30 	mcall	800080c8 <log+0x160>
8000800e:	06 9c       	mov	r12,r3
							break;
80008010:	c1 98       	rjmp	80008042 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80008012:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80008016:	06 9b       	mov	r11,r3
80008018:	09 bc       	ld.ub	r12,r4[0x3]
8000801a:	f0 1f 00 2d 	mcall	800080cc <log+0x164>
8000801e:	06 9c       	mov	r12,r3
							break;
80008020:	c1 18       	rjmp	80008042 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80008022:	e8 c5 ff fc 	sub	r5,r4,-4
80008026:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80008028:	c0 d8       	rjmp	80008042 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000802a:	06 9b       	mov	r11,r3
8000802c:	32 5c       	mov	r12,37
8000802e:	f0 1f 00 28 	mcall	800080cc <log+0x164>
80008032:	08 95       	mov	r5,r4
80008034:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80008036:	c0 68       	rjmp	80008042 <log+0xda>
							
							default:
							log("I need relax.");
80008038:	4a 6c       	lddpc	r12,800080d0 <log+0x168>
8000803a:	f0 1f 00 23 	mcall	800080c4 <log+0x15c>
8000803e:	08 95       	mov	r5,r4
80008040:	06 9c       	mov	r12,r3
						}
						str++;
80008042:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008044:	1a dc       	st.w	--sp,r12
80008046:	1a d6       	st.w	--sp,r6
80008048:	4a 3b       	lddpc	r11,800080d4 <log+0x16c>
8000804a:	0c 9c       	mov	r12,r6
8000804c:	f0 1f 00 23 	mcall	800080d8 <log+0x170>
80008050:	2f ed       	sub	sp,-8
80008052:	c0 a8       	rjmp	80008066 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008054:	2f f7       	sub	r7,-1
80008056:	1a d8       	st.w	--sp,r8
80008058:	1a d6       	st.w	--sp,r6
8000805a:	4a 1b       	lddpc	r11,800080dc <log+0x174>
8000805c:	0c 9c       	mov	r12,r6
8000805e:	f0 1f 00 1f 	mcall	800080d8 <log+0x170>
80008062:	08 95       	mov	r5,r4
80008064:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80008066:	0f 89       	ld.ub	r9,r7[0x0]
80008068:	30 08       	mov	r8,0
8000806a:	f0 09 18 00 	cp.b	r9,r8
8000806e:	c0 30       	breq	80008074 <log+0x10c>
80008070:	0a 94       	mov	r4,r5
80008072:	c9 2b       	rjmp	80007f96 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80008074:	fa c7 fe f8 	sub	r7,sp,-264
80008078:	1a d7       	st.w	--sp,r7
8000807a:	49 ab       	lddpc	r11,800080e0 <log+0x178>
8000807c:	0e 9c       	mov	r12,r7
8000807e:	f0 1f 00 17 	mcall	800080d8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80008082:	5c 5c       	castu.b	r12
80008084:	f8 c6 ff ff 	sub	r6,r12,-1
80008088:	0c 9c       	mov	r12,r6
8000808a:	f0 1f 00 17 	mcall	800080e4 <log+0x17c>
8000808e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80008090:	0c 9a       	mov	r10,r6
80008092:	0e 9b       	mov	r11,r7
80008094:	f0 1f 00 15 	mcall	800080e8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80008098:	30 09       	mov	r9,0
8000809a:	30 5a       	mov	r10,5
8000809c:	fa cb fe f8 	sub	r11,sp,-264
800080a0:	49 38       	lddpc	r8,800080ec <log+0x184>
800080a2:	70 0c       	ld.w	r12,r8[0x0]
800080a4:	f0 1f 00 13 	mcall	800080f0 <log+0x188>
800080a8:	2f fd       	sub	sp,-4
	
	
}
800080aa:	fe 3d fd f8 	sub	sp,-520
800080ae:	d8 32       	popm	r0-r7,pc
800080b0:	80 00       	ld.sh	r0,r0[0x0]
800080b2:	89 5a       	st.w	r4[0x14],r10
800080b4:	00 00       	add	r0,r0
800080b6:	0d e0       	ld.ub	r0,r6[0x6]
800080b8:	80 00       	ld.sh	r0,r0[0x0]
800080ba:	ed bc       	*unknown*
800080bc:	80 00       	ld.sh	r0,r0[0x0]
800080be:	7e 8e       	ld.w	lr,pc[0x20]
800080c0:	80 00       	ld.sh	r0,r0[0x0]
800080c2:	f0 68 80 00 	mov	r8,-1015808
800080c6:	7f 68       	ld.w	r8,pc[0x58]
800080c8:	80 00       	ld.sh	r0,r0[0x0]
800080ca:	7d dc       	ld.w	r12,lr[0x74]
800080cc:	80 00       	ld.sh	r0,r0[0x0]
800080ce:	7d d8       	ld.w	r8,lr[0x74]
800080d0:	80 00       	ld.sh	r0,r0[0x0]
800080d2:	f0 78 80 00 	mov	r8,-950272
800080d6:	f0 88 80 00 	brls	7fe180d6 <_estack+0x7fe000d6>
800080da:	8c 48       	ld.sh	r8,r6[0x8]
800080dc:	80 00       	ld.sh	r0,r0[0x0]
800080de:	f0 90 80 00 	breq	7fe380de <_estack+0x7fe200de>
800080e2:	f0 98 80 00 	brls	7fe380e2 <_estack+0x7fe200e2>
800080e6:	6f dc       	ld.w	r12,r7[0x74]
800080e8:	80 00       	ld.sh	r0,r0[0x0]
800080ea:	88 12       	ld.sh	r2,r4[0x2]
800080ec:	00 00       	add	r0,r0
800080ee:	a6 c4       	st.b	r3[0x4],r4
800080f0:	80 00       	ld.sh	r0,r0[0x0]
800080f2:	73 30       	ld.w	r0,r9[0x4c]

800080f4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800080f4:	d4 31       	pushm	r0-r7,lr
800080f6:	fa cd 02 0c 	sub	sp,sp,524
800080fa:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800080fc:	e0 6a 01 00 	mov	r10,256
80008100:	30 0b       	mov	r11,0
80008102:	fa cc fe f4 	sub	r12,sp,-268
80008106:	f0 1f 00 4c 	mcall	80008234 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000810a:	fa c4 fd d0 	sub	r4,sp,-560
8000810e:	30 0a       	mov	r10,0
80008110:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80008112:	fa c3 ff fc 	sub	r3,sp,-4
80008116:	e0 61 01 00 	mov	r1,256
8000811a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000811c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000811e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80008122:	02 9a       	mov	r10,r1
80008124:	00 9b       	mov	r11,r0
80008126:	06 9c       	mov	r12,r3
80008128:	f0 1f 00 43 	mcall	80008234 <logFromISR+0x140>
			
			if(*str == '%')
8000812c:	0f 88       	ld.ub	r8,r7[0x0]
8000812e:	e4 08 18 00 	cp.b	r8,r2
80008132:	c5 11       	brne	800081d4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80008134:	ee c8 ff ff 	sub	r8,r7,-1
80008138:	11 89       	ld.ub	r9,r8[0x0]
8000813a:	4c 0a       	lddpc	r10,80008238 <logFromISR+0x144>
8000813c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000813e:	23 09       	sub	r9,48
80008140:	30 9a       	mov	r10,9
80008142:	f4 09 18 00 	cp.b	r9,r10
80008146:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000814a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000814e:	f7 b9 08 30 	subls	r9,48
80008152:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80008156:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000815a:	0f 88       	ld.ub	r8,r7[0x0]
8000815c:	22 58       	sub	r8,37
8000815e:	e0 48 00 53 	cp.w	r8,83
80008162:	e0 8b 00 2b 	brhi	800081b8 <logFromISR+0xc4>
80008166:	4b 69       	lddpc	r9,8000823c <logFromISR+0x148>
80008168:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000816c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80008170:	06 9a       	mov	r10,r3
80008172:	40 0b       	lddsp	r11,sp[0x0]
80008174:	5c 5b       	castu.b	r11
80008176:	68 0c       	ld.w	r12,r4[0x0]
80008178:	f0 1f 00 32 	mcall	80008240 <logFromISR+0x14c>
					break;
8000817c:	c2 38       	rjmp	800081c2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000817e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80008182:	06 9a       	mov	r10,r3
80008184:	40 0b       	lddsp	r11,sp[0x0]
80008186:	5c 5b       	castu.b	r11
80008188:	68 0c       	ld.w	r12,r4[0x0]
8000818a:	f0 1f 00 2f 	mcall	80008244 <logFromISR+0x150>
8000818e:	06 9c       	mov	r12,r3
					break;
80008190:	c1 98       	rjmp	800081c2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80008192:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80008196:	06 9b       	mov	r11,r3
80008198:	09 bc       	ld.ub	r12,r4[0x3]
8000819a:	f0 1f 00 2c 	mcall	80008248 <logFromISR+0x154>
8000819e:	06 9c       	mov	r12,r3
					break;
800081a0:	c1 18       	rjmp	800081c2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800081a2:	e8 c5 ff fc 	sub	r5,r4,-4
800081a6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800081a8:	c0 d8       	rjmp	800081c2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800081aa:	06 9b       	mov	r11,r3
800081ac:	32 5c       	mov	r12,37
800081ae:	f0 1f 00 27 	mcall	80008248 <logFromISR+0x154>
800081b2:	08 95       	mov	r5,r4
800081b4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800081b6:	c0 68       	rjmp	800081c2 <logFromISR+0xce>
					default:
					log("I need relax.");
800081b8:	4a 5c       	lddpc	r12,8000824c <logFromISR+0x158>
800081ba:	f0 1f 00 26 	mcall	80008250 <logFromISR+0x15c>
800081be:	08 95       	mov	r5,r4
800081c0:	06 9c       	mov	r12,r3
				}
				str++;
800081c2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800081c4:	1a dc       	st.w	--sp,r12
800081c6:	1a d6       	st.w	--sp,r6
800081c8:	4a 3b       	lddpc	r11,80008254 <logFromISR+0x160>
800081ca:	0c 9c       	mov	r12,r6
800081cc:	f0 1f 00 23 	mcall	80008258 <logFromISR+0x164>
800081d0:	2f ed       	sub	sp,-8
800081d2:	c0 a8       	rjmp	800081e6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800081d4:	2f f7       	sub	r7,-1
800081d6:	1a d8       	st.w	--sp,r8
800081d8:	1a d6       	st.w	--sp,r6
800081da:	4a 1b       	lddpc	r11,8000825c <logFromISR+0x168>
800081dc:	0c 9c       	mov	r12,r6
800081de:	f0 1f 00 1f 	mcall	80008258 <logFromISR+0x164>
800081e2:	08 95       	mov	r5,r4
800081e4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800081e6:	0f 89       	ld.ub	r9,r7[0x0]
800081e8:	30 08       	mov	r8,0
800081ea:	f0 09 18 00 	cp.b	r9,r8
800081ee:	c0 30       	breq	800081f4 <logFromISR+0x100>
800081f0:	0a 94       	mov	r4,r5
800081f2:	c9 8b       	rjmp	80008122 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800081f4:	fa c7 fe f4 	sub	r7,sp,-268
800081f8:	1a d7       	st.w	--sp,r7
800081fa:	49 ab       	lddpc	r11,80008260 <logFromISR+0x16c>
800081fc:	0e 9c       	mov	r12,r7
800081fe:	f0 1f 00 17 	mcall	80008258 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80008202:	5c 5c       	castu.b	r12
80008204:	f8 c6 ff ff 	sub	r6,r12,-1
80008208:	0c 9c       	mov	r12,r6
8000820a:	f0 1f 00 17 	mcall	80008264 <logFromISR+0x170>
8000820e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80008210:	0c 9a       	mov	r10,r6
80008212:	0e 9b       	mov	r11,r7
80008214:	f0 1f 00 15 	mcall	80008268 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80008218:	30 09       	mov	r9,0
8000821a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000821c:	fa ca fe f8 	sub	r10,sp,-264
80008220:	fa cb fe f4 	sub	r11,sp,-268
80008224:	49 28       	lddpc	r8,8000826c <logFromISR+0x178>
80008226:	70 0c       	ld.w	r12,r8[0x0]
80008228:	f0 1f 00 12 	mcall	80008270 <logFromISR+0x17c>
8000822c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000822e:	fe 3d fd f4 	sub	sp,-524
80008232:	d8 32       	popm	r0-r7,pc
80008234:	80 00       	ld.sh	r0,r0[0x0]
80008236:	89 5a       	st.w	r4[0x14],r10
80008238:	00 00       	add	r0,r0
8000823a:	0d e1       	ld.ub	r1,r6[0x6]
8000823c:	80 00       	ld.sh	r0,r0[0x0]
8000823e:	ef 0c 80 00 	ld.sh	r12,r7[-32768]
80008242:	7e 8e       	ld.w	lr,pc[0x20]
80008244:	80 00       	ld.sh	r0,r0[0x0]
80008246:	7d dc       	ld.w	r12,lr[0x74]
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	7d d8       	ld.w	r8,lr[0x74]
8000824c:	80 00       	ld.sh	r0,r0[0x0]
8000824e:	f0 78 80 00 	mov	r8,-950272
80008252:	7f 68       	ld.w	r8,pc[0x58]
80008254:	80 00       	ld.sh	r0,r0[0x0]
80008256:	f0 88 80 00 	brls	7fe18256 <_estack+0x7fe00256>
8000825a:	8c 48       	ld.sh	r8,r6[0x8]
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	f0 90 80 00 	breq	7fe3825e <_estack+0x7fe2025e>
80008262:	f0 98 80 00 	brls	7fe38262 <_estack+0x7fe20262>
80008266:	6f dc       	ld.w	r12,r7[0x74]
80008268:	80 00       	ld.sh	r0,r0[0x0]
8000826a:	88 12       	ld.sh	r2,r4[0x2]
8000826c:	00 00       	add	r0,r0
8000826e:	a6 c4       	st.b	r3[0x4],r4
80008270:	80 00       	ld.sh	r0,r0[0x0]
80008272:	72 e0       	ld.w	r0,r9[0x38]

80008274 <log_init>:
		
	return str;
}

void log_init(void)
{
80008274:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80008276:	30 2b       	mov	r11,2
80008278:	48 fc       	lddpc	r12,800082b4 <log_init+0x40>
8000827a:	f0 1f 00 10 	mcall	800082b8 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000827e:	e0 6a 36 00 	mov	r10,13824
80008282:	ea 1a 01 6e 	orh	r10,0x16e
80008286:	48 eb       	lddpc	r11,800082bc <log_init+0x48>
80008288:	fe 7c 18 00 	mov	r12,-59392
8000828c:	f0 1f 00 0d 	mcall	800082c0 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80008290:	30 4b       	mov	r11,4
80008292:	33 2c       	mov	r12,50
80008294:	f0 1f 00 0c 	mcall	800082c4 <log_init+0x50>
80008298:	48 c8       	lddpc	r8,800082c8 <log_init+0x54>
8000829a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000829c:	30 09       	mov	r9,0
8000829e:	1a d9       	st.w	--sp,r9
800082a0:	1a d9       	st.w	--sp,r9
800082a2:	1a d9       	st.w	--sp,r9
800082a4:	30 28       	mov	r8,2
800082a6:	36 4a       	mov	r10,100
800082a8:	48 9b       	lddpc	r11,800082cc <log_init+0x58>
800082aa:	48 ac       	lddpc	r12,800082d0 <log_init+0x5c>
800082ac:	f0 1f 00 0a 	mcall	800082d4 <log_init+0x60>
800082b0:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800082b2:	d8 02       	popm	pc
800082b4:	80 00       	ld.sh	r0,r0[0x0]
800082b6:	f0 a4       	*unknown*
800082b8:	80 00       	ld.sh	r0,r0[0x0]
800082ba:	63 4c       	ld.w	r12,r1[0x50]
800082bc:	80 00       	ld.sh	r0,r0[0x0]
800082be:	f0 5c 80 00 	cp.w	r12,-950272
800082c2:	6b 40       	ld.w	r0,r5[0x50]
800082c4:	80 00       	ld.sh	r0,r0[0x0]
800082c6:	74 88       	ld.w	r8,r10[0x20]
800082c8:	00 00       	add	r0,r0
800082ca:	a6 c4       	st.b	r3[0x4],r4
800082cc:	80 00       	ld.sh	r0,r0[0x0]
800082ce:	f0 a0 80 00 	rcall	7fe182ce <_estack+0x7fe002ce>
800082d2:	82 d8       	ld.uh	r8,r1[0xa]
800082d4:	80 00       	ld.sh	r0,r0[0x0]
800082d6:	7b a4       	ld.w	r4,sp[0x68]

800082d8 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800082d8:	eb cd 40 f8 	pushm	r3-r7,lr
800082dc:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082de:	48 c7       	lddpc	r7,8000830c <task_log+0x34>
800082e0:	30 05       	mov	r5,0
800082e2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800082e4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082e8:	0a 99       	mov	r9,r5
800082ea:	08 9a       	mov	r10,r4
800082ec:	1a 9b       	mov	r11,sp
800082ee:	6e 0c       	ld.w	r12,r7[0x0]
800082f0:	f0 1f 00 08 	mcall	80008310 <task_log+0x38>
800082f4:	58 1c       	cp.w	r12,1
800082f6:	cf 91       	brne	800082e8 <task_log+0x10>
		{
			if( NULL != str)
800082f8:	40 0b       	lddsp	r11,sp[0x0]
800082fa:	58 0b       	cp.w	r11,0
800082fc:	cf 60       	breq	800082e8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800082fe:	06 9c       	mov	r12,r3
80008300:	f0 1f 00 05 	mcall	80008314 <task_log+0x3c>
				vPortFree(str);
80008304:	40 0c       	lddsp	r12,sp[0x0]
80008306:	f0 1f 00 05 	mcall	80008318 <task_log+0x40>
8000830a:	ce fb       	rjmp	800082e8 <task_log+0x10>
8000830c:	00 00       	add	r0,r0
8000830e:	a6 c4       	st.b	r3[0x4],r4
80008310:	80 00       	ld.sh	r0,r0[0x0]
80008312:	71 24       	ld.w	r4,r8[0x48]
80008314:	80 00       	ld.sh	r0,r0[0x0]
80008316:	6a f0       	ld.w	r0,r5[0x3c]
80008318:	80 00       	ld.sh	r0,r0[0x0]
8000831a:	6f b4       	ld.w	r4,r7[0x6c]

8000831c <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
8000831c:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000831e:	fe 78 10 00 	mov	r8,-61440
80008322:	30 19       	mov	r9,1
80008324:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80008328:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000832c:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80008330:	d3 03       	ssrf	0x10
	local_start_pll0();
80008332:	f0 1f 00 0d 	mcall	80008364 <main+0x48>
		
	INTC_init_interrupts();
80008336:	f0 1f 00 0d 	mcall	80008368 <main+0x4c>
		
	log_init();
8000833a:	f0 1f 00 0d 	mcall	8000836c <main+0x50>
	log("----start debug----");
8000833e:	48 dc       	lddpc	r12,80008370 <main+0x54>
80008340:	f0 1f 00 0d 	mcall	80008374 <main+0x58>
	
	xg_flashc_init();
80008344:	f0 1f 00 0d 	mcall	80008378 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80008348:	f0 1f 00 0d 	mcall	8000837c <main+0x60>
		
	app_init();
8000834c:	f0 1f 00 0d 	mcall	80008380 <main+0x64>
	
	xg_rtc_init();
80008350:	f0 1f 00 0d 	mcall	80008384 <main+0x68>
		
	xcmp_init();
80008354:	f0 1f 00 0d 	mcall	80008388 <main+0x6c>

	local_start_timer();
80008358:	f0 1f 00 0d 	mcall	8000838c <main+0x70>
		
	vTaskStartScheduler();
8000835c:	f0 1f 00 0d 	mcall	80008390 <main+0x74>
	return 0;
	
}
80008360:	d8 0a       	popm	pc,r12=0
80008362:	00 00       	add	r0,r0
80008364:	80 00       	ld.sh	r0,r0[0x0]
80008366:	5c 90       	brev	r0
80008368:	80 00       	ld.sh	r0,r0[0x0]
8000836a:	64 50       	ld.w	r0,r2[0x14]
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	82 74       	ld.sh	r4,r1[0xe]
80008370:	80 00       	ld.sh	r0,r0[0x0]
80008372:	f0 b4       	*unknown*
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	7f 68       	ld.w	r8,pc[0x58]
80008378:	80 00       	ld.sh	r0,r0[0x0]
8000837a:	5d 24       	mustr	r4
8000837c:	80 00       	ld.sh	r0,r0[0x0]
8000837e:	5b f0       	cp.w	r0,-1
80008380:	80 00       	ld.sh	r0,r0[0x0]
80008382:	27 50       	sub	r0,117
80008384:	80 00       	ld.sh	r0,r0[0x0]
80008386:	33 44       	mov	r4,52
80008388:	80 00       	ld.sh	r0,r0[0x0]
8000838a:	4a 18       	lddpc	r8,8000840c <_malloc_r+0x58>
8000838c:	80 00       	ld.sh	r0,r0[0x0]
8000838e:	5c 64       	casts.b	r4
80008390:	80 00       	ld.sh	r0,r0[0x0]
80008392:	7d 8c       	ld.w	r12,lr[0x60]

80008394 <free>:
80008394:	d4 01       	pushm	lr
80008396:	e0 68 0a 54 	mov	r8,2644
8000839a:	18 9b       	mov	r11,r12
8000839c:	70 0c       	ld.w	r12,r8[0x0]
8000839e:	e0 a0 1e 73 	rcall	8000c084 <_free_r>
800083a2:	d8 02       	popm	pc

800083a4 <malloc>:
800083a4:	d4 01       	pushm	lr
800083a6:	e0 68 0a 54 	mov	r8,2644
800083aa:	18 9b       	mov	r11,r12
800083ac:	70 0c       	ld.w	r12,r8[0x0]
800083ae:	c0 3c       	rcall	800083b4 <_malloc_r>
800083b0:	d8 02       	popm	pc
800083b2:	d7 03       	nop

800083b4 <_malloc_r>:
800083b4:	d4 31       	pushm	r0-r7,lr
800083b6:	f6 c8 ff f5 	sub	r8,r11,-11
800083ba:	18 95       	mov	r5,r12
800083bc:	10 97       	mov	r7,r8
800083be:	e0 17 ff f8 	andl	r7,0xfff8
800083c2:	59 68       	cp.w	r8,22
800083c4:	f9 b7 08 10 	movls	r7,16
800083c8:	16 37       	cp.w	r7,r11
800083ca:	5f 38       	srlo	r8
800083cc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800083d0:	c0 50       	breq	800083da <_malloc_r+0x26>
800083d2:	30 c8       	mov	r8,12
800083d4:	99 38       	st.w	r12[0xc],r8
800083d6:	e0 8f 01 fa 	bral	800087ca <_malloc_r+0x416>
800083da:	fe b0 f5 a3 	rcall	80006f20 <__malloc_lock>
800083de:	e0 47 01 f7 	cp.w	r7,503
800083e2:	e0 8b 00 1d 	brhi	8000841c <_malloc_r+0x68>
800083e6:	ee 03 16 03 	lsr	r3,r7,0x3
800083ea:	e0 68 05 54 	mov	r8,1364
800083ee:	f0 03 00 38 	add	r8,r8,r3<<0x3
800083f2:	70 36       	ld.w	r6,r8[0xc]
800083f4:	10 36       	cp.w	r6,r8
800083f6:	c0 61       	brne	80008402 <_malloc_r+0x4e>
800083f8:	ec c8 ff f8 	sub	r8,r6,-8
800083fc:	70 36       	ld.w	r6,r8[0xc]
800083fe:	10 36       	cp.w	r6,r8
80008400:	c0 c0       	breq	80008418 <_malloc_r+0x64>
80008402:	6c 18       	ld.w	r8,r6[0x4]
80008404:	e0 18 ff fc 	andl	r8,0xfffc
80008408:	6c 3a       	ld.w	r10,r6[0xc]
8000840a:	ec 08 00 09 	add	r9,r6,r8
8000840e:	0a 9c       	mov	r12,r5
80008410:	6c 28       	ld.w	r8,r6[0x8]
80008412:	95 28       	st.w	r10[0x8],r8
80008414:	91 3a       	st.w	r8[0xc],r10
80008416:	c4 78       	rjmp	800084a4 <_malloc_r+0xf0>
80008418:	2f e3       	sub	r3,-2
8000841a:	c4 d8       	rjmp	800084b4 <_malloc_r+0x100>
8000841c:	ee 03 16 09 	lsr	r3,r7,0x9
80008420:	c0 41       	brne	80008428 <_malloc_r+0x74>
80008422:	ee 03 16 03 	lsr	r3,r7,0x3
80008426:	c2 68       	rjmp	80008472 <_malloc_r+0xbe>
80008428:	58 43       	cp.w	r3,4
8000842a:	e0 8b 00 06 	brhi	80008436 <_malloc_r+0x82>
8000842e:	ee 03 16 06 	lsr	r3,r7,0x6
80008432:	2c 83       	sub	r3,-56
80008434:	c1 f8       	rjmp	80008472 <_malloc_r+0xbe>
80008436:	59 43       	cp.w	r3,20
80008438:	e0 8b 00 04 	brhi	80008440 <_malloc_r+0x8c>
8000843c:	2a 53       	sub	r3,-91
8000843e:	c1 a8       	rjmp	80008472 <_malloc_r+0xbe>
80008440:	e0 43 00 54 	cp.w	r3,84
80008444:	e0 8b 00 06 	brhi	80008450 <_malloc_r+0x9c>
80008448:	ee 03 16 0c 	lsr	r3,r7,0xc
8000844c:	29 23       	sub	r3,-110
8000844e:	c1 28       	rjmp	80008472 <_malloc_r+0xbe>
80008450:	e0 43 01 54 	cp.w	r3,340
80008454:	e0 8b 00 06 	brhi	80008460 <_malloc_r+0xac>
80008458:	ee 03 16 0f 	lsr	r3,r7,0xf
8000845c:	28 93       	sub	r3,-119
8000845e:	c0 a8       	rjmp	80008472 <_malloc_r+0xbe>
80008460:	e0 43 05 54 	cp.w	r3,1364
80008464:	e0 88 00 04 	brls	8000846c <_malloc_r+0xb8>
80008468:	37 e3       	mov	r3,126
8000846a:	c0 48       	rjmp	80008472 <_malloc_r+0xbe>
8000846c:	ee 03 16 12 	lsr	r3,r7,0x12
80008470:	28 43       	sub	r3,-124
80008472:	e0 6a 05 54 	mov	r10,1364
80008476:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000847a:	74 36       	ld.w	r6,r10[0xc]
8000847c:	c1 98       	rjmp	800084ae <_malloc_r+0xfa>
8000847e:	6c 19       	ld.w	r9,r6[0x4]
80008480:	e0 19 ff fc 	andl	r9,0xfffc
80008484:	f2 07 01 0b 	sub	r11,r9,r7
80008488:	58 fb       	cp.w	r11,15
8000848a:	e0 8a 00 04 	brle	80008492 <_malloc_r+0xde>
8000848e:	20 13       	sub	r3,1
80008490:	c1 18       	rjmp	800084b2 <_malloc_r+0xfe>
80008492:	6c 38       	ld.w	r8,r6[0xc]
80008494:	58 0b       	cp.w	r11,0
80008496:	c0 b5       	brlt	800084ac <_malloc_r+0xf8>
80008498:	6c 2a       	ld.w	r10,r6[0x8]
8000849a:	ec 09 00 09 	add	r9,r6,r9
8000849e:	0a 9c       	mov	r12,r5
800084a0:	91 2a       	st.w	r8[0x8],r10
800084a2:	95 38       	st.w	r10[0xc],r8
800084a4:	72 18       	ld.w	r8,r9[0x4]
800084a6:	a1 a8       	sbr	r8,0x0
800084a8:	93 18       	st.w	r9[0x4],r8
800084aa:	cb c8       	rjmp	80008622 <_malloc_r+0x26e>
800084ac:	10 96       	mov	r6,r8
800084ae:	14 36       	cp.w	r6,r10
800084b0:	ce 71       	brne	8000847e <_malloc_r+0xca>
800084b2:	2f f3       	sub	r3,-1
800084b4:	e0 6a 05 54 	mov	r10,1364
800084b8:	f4 cc ff f8 	sub	r12,r10,-8
800084bc:	78 26       	ld.w	r6,r12[0x8]
800084be:	18 36       	cp.w	r6,r12
800084c0:	c6 c0       	breq	80008598 <_malloc_r+0x1e4>
800084c2:	6c 19       	ld.w	r9,r6[0x4]
800084c4:	e0 19 ff fc 	andl	r9,0xfffc
800084c8:	f2 07 01 08 	sub	r8,r9,r7
800084cc:	58 f8       	cp.w	r8,15
800084ce:	e0 89 00 8f 	brgt	800085ec <_malloc_r+0x238>
800084d2:	99 3c       	st.w	r12[0xc],r12
800084d4:	99 2c       	st.w	r12[0x8],r12
800084d6:	58 08       	cp.w	r8,0
800084d8:	c0 55       	brlt	800084e2 <_malloc_r+0x12e>
800084da:	ec 09 00 09 	add	r9,r6,r9
800084de:	0a 9c       	mov	r12,r5
800084e0:	ce 2b       	rjmp	800084a4 <_malloc_r+0xf0>
800084e2:	e0 49 01 ff 	cp.w	r9,511
800084e6:	e0 8b 00 13 	brhi	8000850c <_malloc_r+0x158>
800084ea:	a3 99       	lsr	r9,0x3
800084ec:	f4 09 00 38 	add	r8,r10,r9<<0x3
800084f0:	70 2b       	ld.w	r11,r8[0x8]
800084f2:	8d 38       	st.w	r6[0xc],r8
800084f4:	8d 2b       	st.w	r6[0x8],r11
800084f6:	97 36       	st.w	r11[0xc],r6
800084f8:	91 26       	st.w	r8[0x8],r6
800084fa:	a3 49       	asr	r9,0x2
800084fc:	74 18       	ld.w	r8,r10[0x4]
800084fe:	30 1b       	mov	r11,1
80008500:	f6 09 09 49 	lsl	r9,r11,r9
80008504:	f1 e9 10 09 	or	r9,r8,r9
80008508:	95 19       	st.w	r10[0x4],r9
8000850a:	c4 78       	rjmp	80008598 <_malloc_r+0x1e4>
8000850c:	f2 0a 16 09 	lsr	r10,r9,0x9
80008510:	58 4a       	cp.w	r10,4
80008512:	e0 8b 00 07 	brhi	80008520 <_malloc_r+0x16c>
80008516:	f2 0a 16 06 	lsr	r10,r9,0x6
8000851a:	2c 8a       	sub	r10,-56
8000851c:	c2 08       	rjmp	8000855c <_malloc_r+0x1a8>
8000851e:	d7 03       	nop
80008520:	59 4a       	cp.w	r10,20
80008522:	e0 8b 00 04 	brhi	8000852a <_malloc_r+0x176>
80008526:	2a 5a       	sub	r10,-91
80008528:	c1 a8       	rjmp	8000855c <_malloc_r+0x1a8>
8000852a:	e0 4a 00 54 	cp.w	r10,84
8000852e:	e0 8b 00 06 	brhi	8000853a <_malloc_r+0x186>
80008532:	f2 0a 16 0c 	lsr	r10,r9,0xc
80008536:	29 2a       	sub	r10,-110
80008538:	c1 28       	rjmp	8000855c <_malloc_r+0x1a8>
8000853a:	e0 4a 01 54 	cp.w	r10,340
8000853e:	e0 8b 00 06 	brhi	8000854a <_malloc_r+0x196>
80008542:	f2 0a 16 0f 	lsr	r10,r9,0xf
80008546:	28 9a       	sub	r10,-119
80008548:	c0 a8       	rjmp	8000855c <_malloc_r+0x1a8>
8000854a:	e0 4a 05 54 	cp.w	r10,1364
8000854e:	e0 88 00 04 	brls	80008556 <_malloc_r+0x1a2>
80008552:	37 ea       	mov	r10,126
80008554:	c0 48       	rjmp	8000855c <_malloc_r+0x1a8>
80008556:	f2 0a 16 12 	lsr	r10,r9,0x12
8000855a:	28 4a       	sub	r10,-124
8000855c:	e0 6b 05 54 	mov	r11,1364
80008560:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80008564:	68 28       	ld.w	r8,r4[0x8]
80008566:	08 38       	cp.w	r8,r4
80008568:	c0 e1       	brne	80008584 <_malloc_r+0x1d0>
8000856a:	76 19       	ld.w	r9,r11[0x4]
8000856c:	a3 4a       	asr	r10,0x2
8000856e:	30 1e       	mov	lr,1
80008570:	fc 0a 09 4a 	lsl	r10,lr,r10
80008574:	f3 ea 10 0a 	or	r10,r9,r10
80008578:	10 99       	mov	r9,r8
8000857a:	97 1a       	st.w	r11[0x4],r10
8000857c:	c0 a8       	rjmp	80008590 <_malloc_r+0x1dc>
8000857e:	70 28       	ld.w	r8,r8[0x8]
80008580:	08 38       	cp.w	r8,r4
80008582:	c0 60       	breq	8000858e <_malloc_r+0x1da>
80008584:	70 1a       	ld.w	r10,r8[0x4]
80008586:	e0 1a ff fc 	andl	r10,0xfffc
8000858a:	14 39       	cp.w	r9,r10
8000858c:	cf 93       	brcs	8000857e <_malloc_r+0x1ca>
8000858e:	70 39       	ld.w	r9,r8[0xc]
80008590:	8d 39       	st.w	r6[0xc],r9
80008592:	8d 28       	st.w	r6[0x8],r8
80008594:	91 36       	st.w	r8[0xc],r6
80008596:	93 26       	st.w	r9[0x8],r6
80008598:	e6 08 14 02 	asr	r8,r3,0x2
8000859c:	30 1b       	mov	r11,1
8000859e:	e0 64 05 54 	mov	r4,1364
800085a2:	f6 08 09 4b 	lsl	r11,r11,r8
800085a6:	68 18       	ld.w	r8,r4[0x4]
800085a8:	10 3b       	cp.w	r11,r8
800085aa:	e0 8b 00 6b 	brhi	80008680 <_malloc_r+0x2cc>
800085ae:	f7 e8 00 09 	and	r9,r11,r8
800085b2:	c0 b1       	brne	800085c8 <_malloc_r+0x214>
800085b4:	e0 13 ff fc 	andl	r3,0xfffc
800085b8:	a1 7b       	lsl	r11,0x1
800085ba:	2f c3       	sub	r3,-4
800085bc:	c0 38       	rjmp	800085c2 <_malloc_r+0x20e>
800085be:	2f c3       	sub	r3,-4
800085c0:	a1 7b       	lsl	r11,0x1
800085c2:	f7 e8 00 09 	and	r9,r11,r8
800085c6:	cf c0       	breq	800085be <_malloc_r+0x20a>
800085c8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800085cc:	06 92       	mov	r2,r3
800085ce:	1c 91       	mov	r1,lr
800085d0:	62 36       	ld.w	r6,r1[0xc]
800085d2:	c2 e8       	rjmp	8000862e <_malloc_r+0x27a>
800085d4:	6c 1a       	ld.w	r10,r6[0x4]
800085d6:	e0 1a ff fc 	andl	r10,0xfffc
800085da:	f4 07 01 08 	sub	r8,r10,r7
800085de:	58 f8       	cp.w	r8,15
800085e0:	e0 8a 00 15 	brle	8000860a <_malloc_r+0x256>
800085e4:	6c 3a       	ld.w	r10,r6[0xc]
800085e6:	6c 29       	ld.w	r9,r6[0x8]
800085e8:	95 29       	st.w	r10[0x8],r9
800085ea:	93 3a       	st.w	r9[0xc],r10
800085ec:	0e 99       	mov	r9,r7
800085ee:	ec 07 00 07 	add	r7,r6,r7
800085f2:	a1 a9       	sbr	r9,0x0
800085f4:	99 37       	st.w	r12[0xc],r7
800085f6:	99 27       	st.w	r12[0x8],r7
800085f8:	8d 19       	st.w	r6[0x4],r9
800085fa:	ee 08 09 08 	st.w	r7[r8],r8
800085fe:	8f 2c       	st.w	r7[0x8],r12
80008600:	8f 3c       	st.w	r7[0xc],r12
80008602:	a1 a8       	sbr	r8,0x0
80008604:	0a 9c       	mov	r12,r5
80008606:	8f 18       	st.w	r7[0x4],r8
80008608:	c0 d8       	rjmp	80008622 <_malloc_r+0x26e>
8000860a:	6c 39       	ld.w	r9,r6[0xc]
8000860c:	58 08       	cp.w	r8,0
8000860e:	c0 f5       	brlt	8000862c <_malloc_r+0x278>
80008610:	ec 0a 00 0a 	add	r10,r6,r10
80008614:	74 18       	ld.w	r8,r10[0x4]
80008616:	a1 a8       	sbr	r8,0x0
80008618:	0a 9c       	mov	r12,r5
8000861a:	95 18       	st.w	r10[0x4],r8
8000861c:	6c 28       	ld.w	r8,r6[0x8]
8000861e:	93 28       	st.w	r9[0x8],r8
80008620:	91 39       	st.w	r8[0xc],r9
80008622:	fe b0 f4 85 	rcall	80006f2c <__malloc_unlock>
80008626:	ec cc ff f8 	sub	r12,r6,-8
8000862a:	d8 32       	popm	r0-r7,pc
8000862c:	12 96       	mov	r6,r9
8000862e:	02 36       	cp.w	r6,r1
80008630:	cd 21       	brne	800085d4 <_malloc_r+0x220>
80008632:	2f f2       	sub	r2,-1
80008634:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008638:	c0 30       	breq	8000863e <_malloc_r+0x28a>
8000863a:	2f 81       	sub	r1,-8
8000863c:	cc ab       	rjmp	800085d0 <_malloc_r+0x21c>
8000863e:	1c 98       	mov	r8,lr
80008640:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80008644:	c0 81       	brne	80008654 <_malloc_r+0x2a0>
80008646:	68 19       	ld.w	r9,r4[0x4]
80008648:	f6 08 11 ff 	rsub	r8,r11,-1
8000864c:	f3 e8 00 08 	and	r8,r9,r8
80008650:	89 18       	st.w	r4[0x4],r8
80008652:	c0 78       	rjmp	80008660 <_malloc_r+0x2ac>
80008654:	f0 c9 00 08 	sub	r9,r8,8
80008658:	20 13       	sub	r3,1
8000865a:	70 08       	ld.w	r8,r8[0x0]
8000865c:	12 38       	cp.w	r8,r9
8000865e:	cf 10       	breq	80008640 <_malloc_r+0x28c>
80008660:	a1 7b       	lsl	r11,0x1
80008662:	68 18       	ld.w	r8,r4[0x4]
80008664:	10 3b       	cp.w	r11,r8
80008666:	e0 8b 00 0d 	brhi	80008680 <_malloc_r+0x2cc>
8000866a:	58 0b       	cp.w	r11,0
8000866c:	c0 a0       	breq	80008680 <_malloc_r+0x2cc>
8000866e:	04 93       	mov	r3,r2
80008670:	c0 38       	rjmp	80008676 <_malloc_r+0x2c2>
80008672:	2f c3       	sub	r3,-4
80008674:	a1 7b       	lsl	r11,0x1
80008676:	f7 e8 00 09 	and	r9,r11,r8
8000867a:	ca 71       	brne	800085c8 <_malloc_r+0x214>
8000867c:	cf bb       	rjmp	80008672 <_malloc_r+0x2be>
8000867e:	d7 03       	nop
80008680:	68 23       	ld.w	r3,r4[0x8]
80008682:	66 12       	ld.w	r2,r3[0x4]
80008684:	e0 12 ff fc 	andl	r2,0xfffc
80008688:	0e 32       	cp.w	r2,r7
8000868a:	5f 39       	srlo	r9
8000868c:	e4 07 01 08 	sub	r8,r2,r7
80008690:	58 f8       	cp.w	r8,15
80008692:	5f aa       	srle	r10
80008694:	f5 e9 10 09 	or	r9,r10,r9
80008698:	e0 80 00 9a 	breq	800087cc <_malloc_r+0x418>
8000869c:	e0 68 0d ec 	mov	r8,3564
800086a0:	70 01       	ld.w	r1,r8[0x0]
800086a2:	e0 68 09 60 	mov	r8,2400
800086a6:	2f 01       	sub	r1,-16
800086a8:	70 08       	ld.w	r8,r8[0x0]
800086aa:	0e 01       	add	r1,r7
800086ac:	5b f8       	cp.w	r8,-1
800086ae:	c0 40       	breq	800086b6 <_malloc_r+0x302>
800086b0:	28 11       	sub	r1,-127
800086b2:	e0 11 ff 80 	andl	r1,0xff80
800086b6:	02 9b       	mov	r11,r1
800086b8:	0a 9c       	mov	r12,r5
800086ba:	e0 a0 02 b7 	rcall	80008c28 <_sbrk_r>
800086be:	18 96       	mov	r6,r12
800086c0:	5b fc       	cp.w	r12,-1
800086c2:	c7 50       	breq	800087ac <_malloc_r+0x3f8>
800086c4:	e6 02 00 08 	add	r8,r3,r2
800086c8:	10 3c       	cp.w	r12,r8
800086ca:	c0 32       	brcc	800086d0 <_malloc_r+0x31c>
800086cc:	08 33       	cp.w	r3,r4
800086ce:	c6 f1       	brne	800087ac <_malloc_r+0x3f8>
800086d0:	e0 6a 0d f0 	mov	r10,3568
800086d4:	74 09       	ld.w	r9,r10[0x0]
800086d6:	e2 09 00 09 	add	r9,r1,r9
800086da:	95 09       	st.w	r10[0x0],r9
800086dc:	10 36       	cp.w	r6,r8
800086de:	c0 a1       	brne	800086f2 <_malloc_r+0x33e>
800086e0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800086e4:	c0 71       	brne	800086f2 <_malloc_r+0x33e>
800086e6:	e2 02 00 02 	add	r2,r1,r2
800086ea:	68 28       	ld.w	r8,r4[0x8]
800086ec:	a1 a2       	sbr	r2,0x0
800086ee:	91 12       	st.w	r8[0x4],r2
800086f0:	c4 f8       	rjmp	8000878e <_malloc_r+0x3da>
800086f2:	e0 6a 09 60 	mov	r10,2400
800086f6:	74 0b       	ld.w	r11,r10[0x0]
800086f8:	5b fb       	cp.w	r11,-1
800086fa:	c0 31       	brne	80008700 <_malloc_r+0x34c>
800086fc:	95 06       	st.w	r10[0x0],r6
800086fe:	c0 78       	rjmp	8000870c <_malloc_r+0x358>
80008700:	ec 09 00 09 	add	r9,r6,r9
80008704:	e0 6a 0d f0 	mov	r10,3568
80008708:	10 19       	sub	r9,r8
8000870a:	95 09       	st.w	r10[0x0],r9
8000870c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80008710:	f0 09 11 08 	rsub	r9,r8,8
80008714:	58 08       	cp.w	r8,0
80008716:	f2 08 17 10 	movne	r8,r9
8000871a:	ed d8 e1 06 	addne	r6,r6,r8
8000871e:	28 08       	sub	r8,-128
80008720:	ec 01 00 01 	add	r1,r6,r1
80008724:	0a 9c       	mov	r12,r5
80008726:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000872a:	f0 01 01 01 	sub	r1,r8,r1
8000872e:	02 9b       	mov	r11,r1
80008730:	e0 a0 02 7c 	rcall	80008c28 <_sbrk_r>
80008734:	e0 68 0d f0 	mov	r8,3568
80008738:	5b fc       	cp.w	r12,-1
8000873a:	ec 0c 17 00 	moveq	r12,r6
8000873e:	f9 b1 00 00 	moveq	r1,0
80008742:	70 09       	ld.w	r9,r8[0x0]
80008744:	0c 1c       	sub	r12,r6
80008746:	89 26       	st.w	r4[0x8],r6
80008748:	02 0c       	add	r12,r1
8000874a:	12 01       	add	r1,r9
8000874c:	a1 ac       	sbr	r12,0x0
8000874e:	91 01       	st.w	r8[0x0],r1
80008750:	8d 1c       	st.w	r6[0x4],r12
80008752:	08 33       	cp.w	r3,r4
80008754:	c1 d0       	breq	8000878e <_malloc_r+0x3da>
80008756:	58 f2       	cp.w	r2,15
80008758:	e0 8b 00 05 	brhi	80008762 <_malloc_r+0x3ae>
8000875c:	30 18       	mov	r8,1
8000875e:	8d 18       	st.w	r6[0x4],r8
80008760:	c2 68       	rjmp	800087ac <_malloc_r+0x3f8>
80008762:	30 59       	mov	r9,5
80008764:	20 c2       	sub	r2,12
80008766:	e0 12 ff f8 	andl	r2,0xfff8
8000876a:	e6 02 00 08 	add	r8,r3,r2
8000876e:	91 29       	st.w	r8[0x8],r9
80008770:	91 19       	st.w	r8[0x4],r9
80008772:	66 18       	ld.w	r8,r3[0x4]
80008774:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008778:	e5 e8 10 08 	or	r8,r2,r8
8000877c:	87 18       	st.w	r3[0x4],r8
8000877e:	58 f2       	cp.w	r2,15
80008780:	e0 88 00 07 	brls	8000878e <_malloc_r+0x3da>
80008784:	e6 cb ff f8 	sub	r11,r3,-8
80008788:	0a 9c       	mov	r12,r5
8000878a:	e0 a0 1c 7d 	rcall	8000c084 <_free_r>
8000878e:	e0 69 0d e8 	mov	r9,3560
80008792:	72 0a       	ld.w	r10,r9[0x0]
80008794:	e0 68 0d f0 	mov	r8,3568
80008798:	70 08       	ld.w	r8,r8[0x0]
8000879a:	14 38       	cp.w	r8,r10
8000879c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800087a0:	e0 69 0d e4 	mov	r9,3556
800087a4:	72 0a       	ld.w	r10,r9[0x0]
800087a6:	14 38       	cp.w	r8,r10
800087a8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800087ac:	68 28       	ld.w	r8,r4[0x8]
800087ae:	70 18       	ld.w	r8,r8[0x4]
800087b0:	e0 18 ff fc 	andl	r8,0xfffc
800087b4:	0e 38       	cp.w	r8,r7
800087b6:	5f 39       	srlo	r9
800087b8:	0e 18       	sub	r8,r7
800087ba:	58 f8       	cp.w	r8,15
800087bc:	5f aa       	srle	r10
800087be:	f5 e9 10 09 	or	r9,r10,r9
800087c2:	c0 50       	breq	800087cc <_malloc_r+0x418>
800087c4:	0a 9c       	mov	r12,r5
800087c6:	fe b0 f3 b3 	rcall	80006f2c <__malloc_unlock>
800087ca:	d8 3a       	popm	r0-r7,pc,r12=0
800087cc:	68 26       	ld.w	r6,r4[0x8]
800087ce:	a1 a8       	sbr	r8,0x0
800087d0:	0e 99       	mov	r9,r7
800087d2:	a1 a9       	sbr	r9,0x0
800087d4:	8d 19       	st.w	r6[0x4],r9
800087d6:	ec 07 00 07 	add	r7,r6,r7
800087da:	0a 9c       	mov	r12,r5
800087dc:	89 27       	st.w	r4[0x8],r7
800087de:	8f 18       	st.w	r7[0x4],r8
800087e0:	fe b0 f3 a6 	rcall	80006f2c <__malloc_unlock>
800087e4:	ec cc ff f8 	sub	r12,r6,-8
800087e8:	d8 32       	popm	r0-r7,pc
800087ea:	d7 03       	nop

800087ec <memcmp>:
800087ec:	d4 01       	pushm	lr
800087ee:	30 08       	mov	r8,0
800087f0:	c0 d8       	rjmp	8000880a <memcmp+0x1e>
800087f2:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800087f6:	f6 08 07 09 	ld.ub	r9,r11[r8]
800087fa:	20 1a       	sub	r10,1
800087fc:	2f f8       	sub	r8,-1
800087fe:	f2 0e 18 00 	cp.b	lr,r9
80008802:	c0 40       	breq	8000880a <memcmp+0x1e>
80008804:	fc 09 01 0c 	sub	r12,lr,r9
80008808:	d8 02       	popm	pc
8000880a:	58 0a       	cp.w	r10,0
8000880c:	cf 31       	brne	800087f2 <memcmp+0x6>
8000880e:	14 9c       	mov	r12,r10
80008810:	d8 02       	popm	pc

80008812 <memcpy>:
80008812:	58 8a       	cp.w	r10,8
80008814:	c2 f5       	brlt	80008872 <memcpy+0x60>
80008816:	f9 eb 10 09 	or	r9,r12,r11
8000881a:	e2 19 00 03 	andl	r9,0x3,COH
8000881e:	e0 81 00 97 	brne	8000894c <memcpy+0x13a>
80008822:	e0 4a 00 20 	cp.w	r10,32
80008826:	c3 b4       	brge	8000889c <memcpy+0x8a>
80008828:	f4 08 14 02 	asr	r8,r10,0x2
8000882c:	f0 09 11 08 	rsub	r9,r8,8
80008830:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008834:	76 69       	ld.w	r9,r11[0x18]
80008836:	99 69       	st.w	r12[0x18],r9
80008838:	76 59       	ld.w	r9,r11[0x14]
8000883a:	99 59       	st.w	r12[0x14],r9
8000883c:	76 49       	ld.w	r9,r11[0x10]
8000883e:	99 49       	st.w	r12[0x10],r9
80008840:	76 39       	ld.w	r9,r11[0xc]
80008842:	99 39       	st.w	r12[0xc],r9
80008844:	76 29       	ld.w	r9,r11[0x8]
80008846:	99 29       	st.w	r12[0x8],r9
80008848:	76 19       	ld.w	r9,r11[0x4]
8000884a:	99 19       	st.w	r12[0x4],r9
8000884c:	76 09       	ld.w	r9,r11[0x0]
8000884e:	99 09       	st.w	r12[0x0],r9
80008850:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008854:	f8 08 00 28 	add	r8,r12,r8<<0x2
80008858:	e0 1a 00 03 	andl	r10,0x3
8000885c:	f4 0a 11 04 	rsub	r10,r10,4
80008860:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008864:	17 a9       	ld.ub	r9,r11[0x2]
80008866:	b0 a9       	st.b	r8[0x2],r9
80008868:	17 99       	ld.ub	r9,r11[0x1]
8000886a:	b0 99       	st.b	r8[0x1],r9
8000886c:	17 89       	ld.ub	r9,r11[0x0]
8000886e:	b0 89       	st.b	r8[0x0],r9
80008870:	5e fc       	retal	r12
80008872:	f4 0a 11 09 	rsub	r10,r10,9
80008876:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000887a:	17 f9       	ld.ub	r9,r11[0x7]
8000887c:	b8 f9       	st.b	r12[0x7],r9
8000887e:	17 e9       	ld.ub	r9,r11[0x6]
80008880:	b8 e9       	st.b	r12[0x6],r9
80008882:	17 d9       	ld.ub	r9,r11[0x5]
80008884:	b8 d9       	st.b	r12[0x5],r9
80008886:	17 c9       	ld.ub	r9,r11[0x4]
80008888:	b8 c9       	st.b	r12[0x4],r9
8000888a:	17 b9       	ld.ub	r9,r11[0x3]
8000888c:	b8 b9       	st.b	r12[0x3],r9
8000888e:	17 a9       	ld.ub	r9,r11[0x2]
80008890:	b8 a9       	st.b	r12[0x2],r9
80008892:	17 99       	ld.ub	r9,r11[0x1]
80008894:	b8 99       	st.b	r12[0x1],r9
80008896:	17 89       	ld.ub	r9,r11[0x0]
80008898:	b8 89       	st.b	r12[0x0],r9
8000889a:	5e fc       	retal	r12
8000889c:	eb cd 40 c0 	pushm	r6-r7,lr
800088a0:	18 99       	mov	r9,r12
800088a2:	22 0a       	sub	r10,32
800088a4:	b7 07       	ld.d	r6,r11++
800088a6:	b3 26       	st.d	r9++,r6
800088a8:	b7 07       	ld.d	r6,r11++
800088aa:	b3 26       	st.d	r9++,r6
800088ac:	b7 07       	ld.d	r6,r11++
800088ae:	b3 26       	st.d	r9++,r6
800088b0:	b7 07       	ld.d	r6,r11++
800088b2:	b3 26       	st.d	r9++,r6
800088b4:	22 0a       	sub	r10,32
800088b6:	cf 74       	brge	800088a4 <memcpy+0x92>
800088b8:	2f 0a       	sub	r10,-16
800088ba:	c0 65       	brlt	800088c6 <memcpy+0xb4>
800088bc:	b7 07       	ld.d	r6,r11++
800088be:	b3 26       	st.d	r9++,r6
800088c0:	b7 07       	ld.d	r6,r11++
800088c2:	b3 26       	st.d	r9++,r6
800088c4:	21 0a       	sub	r10,16
800088c6:	5c 3a       	neg	r10
800088c8:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800088cc:	d7 03       	nop
800088ce:	d7 03       	nop
800088d0:	f7 36 00 0e 	ld.ub	r6,r11[14]
800088d4:	f3 66 00 0e 	st.b	r9[14],r6
800088d8:	f7 36 00 0d 	ld.ub	r6,r11[13]
800088dc:	f3 66 00 0d 	st.b	r9[13],r6
800088e0:	f7 36 00 0c 	ld.ub	r6,r11[12]
800088e4:	f3 66 00 0c 	st.b	r9[12],r6
800088e8:	f7 36 00 0b 	ld.ub	r6,r11[11]
800088ec:	f3 66 00 0b 	st.b	r9[11],r6
800088f0:	f7 36 00 0a 	ld.ub	r6,r11[10]
800088f4:	f3 66 00 0a 	st.b	r9[10],r6
800088f8:	f7 36 00 09 	ld.ub	r6,r11[9]
800088fc:	f3 66 00 09 	st.b	r9[9],r6
80008900:	f7 36 00 08 	ld.ub	r6,r11[8]
80008904:	f3 66 00 08 	st.b	r9[8],r6
80008908:	f7 36 00 07 	ld.ub	r6,r11[7]
8000890c:	f3 66 00 07 	st.b	r9[7],r6
80008910:	f7 36 00 06 	ld.ub	r6,r11[6]
80008914:	f3 66 00 06 	st.b	r9[6],r6
80008918:	f7 36 00 05 	ld.ub	r6,r11[5]
8000891c:	f3 66 00 05 	st.b	r9[5],r6
80008920:	f7 36 00 04 	ld.ub	r6,r11[4]
80008924:	f3 66 00 04 	st.b	r9[4],r6
80008928:	f7 36 00 03 	ld.ub	r6,r11[3]
8000892c:	f3 66 00 03 	st.b	r9[3],r6
80008930:	f7 36 00 02 	ld.ub	r6,r11[2]
80008934:	f3 66 00 02 	st.b	r9[2],r6
80008938:	f7 36 00 01 	ld.ub	r6,r11[1]
8000893c:	f3 66 00 01 	st.b	r9[1],r6
80008940:	f7 36 00 00 	ld.ub	r6,r11[0]
80008944:	f3 66 00 00 	st.b	r9[0],r6
80008948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000894c:	20 1a       	sub	r10,1
8000894e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008952:	f8 0a 0b 09 	st.b	r12[r10],r9
80008956:	cf b1       	brne	8000894c <memcpy+0x13a>
80008958:	5e fc       	retal	r12

8000895a <memset>:
8000895a:	18 98       	mov	r8,r12
8000895c:	c0 38       	rjmp	80008962 <memset+0x8>
8000895e:	10 cb       	st.b	r8++,r11
80008960:	20 1a       	sub	r10,1
80008962:	58 0a       	cp.w	r10,0
80008964:	cf d1       	brne	8000895e <memset+0x4>
80008966:	5e fc       	retal	r12

80008968 <_realloc_r>:
80008968:	d4 31       	pushm	r0-r7,lr
8000896a:	20 1d       	sub	sp,4
8000896c:	16 94       	mov	r4,r11
8000896e:	18 92       	mov	r2,r12
80008970:	14 9b       	mov	r11,r10
80008972:	58 04       	cp.w	r4,0
80008974:	c0 51       	brne	8000897e <_realloc_r+0x16>
80008976:	fe b0 fd 1f 	rcall	800083b4 <_malloc_r>
8000897a:	18 95       	mov	r5,r12
8000897c:	c5 39       	rjmp	80008c22 <_realloc_r+0x2ba>
8000897e:	50 0a       	stdsp	sp[0x0],r10
80008980:	fe b0 f2 d0 	rcall	80006f20 <__malloc_lock>
80008984:	40 0b       	lddsp	r11,sp[0x0]
80008986:	f6 c8 ff f5 	sub	r8,r11,-11
8000898a:	e8 c1 00 08 	sub	r1,r4,8
8000898e:	10 96       	mov	r6,r8
80008990:	62 1c       	ld.w	r12,r1[0x4]
80008992:	e0 16 ff f8 	andl	r6,0xfff8
80008996:	59 68       	cp.w	r8,22
80008998:	f9 b6 08 10 	movls	r6,16
8000899c:	16 36       	cp.w	r6,r11
8000899e:	5f 38       	srlo	r8
800089a0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800089a4:	c0 50       	breq	800089ae <_realloc_r+0x46>
800089a6:	30 c8       	mov	r8,12
800089a8:	30 05       	mov	r5,0
800089aa:	85 38       	st.w	r2[0xc],r8
800089ac:	c3 b9       	rjmp	80008c22 <_realloc_r+0x2ba>
800089ae:	18 90       	mov	r0,r12
800089b0:	e0 10 ff fc 	andl	r0,0xfffc
800089b4:	0c 30       	cp.w	r0,r6
800089b6:	e0 84 01 0b 	brge	80008bcc <_realloc_r+0x264>
800089ba:	e0 68 05 54 	mov	r8,1364
800089be:	e2 00 00 09 	add	r9,r1,r0
800089c2:	70 25       	ld.w	r5,r8[0x8]
800089c4:	0a 39       	cp.w	r9,r5
800089c6:	c0 90       	breq	800089d8 <_realloc_r+0x70>
800089c8:	72 1a       	ld.w	r10,r9[0x4]
800089ca:	a1 ca       	cbr	r10,0x0
800089cc:	f2 0a 00 0a 	add	r10,r9,r10
800089d0:	74 1a       	ld.w	r10,r10[0x4]
800089d2:	ed ba 00 00 	bld	r10,0x0
800089d6:	c2 20       	breq	80008a1a <_realloc_r+0xb2>
800089d8:	72 1a       	ld.w	r10,r9[0x4]
800089da:	e0 1a ff fc 	andl	r10,0xfffc
800089de:	f4 00 00 03 	add	r3,r10,r0
800089e2:	0a 39       	cp.w	r9,r5
800089e4:	c1 31       	brne	80008a0a <_realloc_r+0xa2>
800089e6:	ec c7 ff f0 	sub	r7,r6,-16
800089ea:	0e 33       	cp.w	r3,r7
800089ec:	c1 95       	brlt	80008a1e <_realloc_r+0xb6>
800089ee:	e2 06 00 09 	add	r9,r1,r6
800089f2:	0c 13       	sub	r3,r6
800089f4:	a1 a3       	sbr	r3,0x0
800089f6:	93 13       	st.w	r9[0x4],r3
800089f8:	91 29       	st.w	r8[0x8],r9
800089fa:	04 9c       	mov	r12,r2
800089fc:	62 18       	ld.w	r8,r1[0x4]
800089fe:	08 95       	mov	r5,r4
80008a00:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a04:	10 46       	or	r6,r8
80008a06:	83 16       	st.w	r1[0x4],r6
80008a08:	c0 b9       	rjmp	80008c1e <_realloc_r+0x2b6>
80008a0a:	0c 33       	cp.w	r3,r6
80008a0c:	c0 95       	brlt	80008a1e <_realloc_r+0xb6>
80008a0e:	72 28       	ld.w	r8,r9[0x8]
80008a10:	02 97       	mov	r7,r1
80008a12:	72 39       	ld.w	r9,r9[0xc]
80008a14:	93 28       	st.w	r9[0x8],r8
80008a16:	91 39       	st.w	r8[0xc],r9
80008a18:	cd c8       	rjmp	80008bd0 <_realloc_r+0x268>
80008a1a:	30 0a       	mov	r10,0
80008a1c:	14 99       	mov	r9,r10
80008a1e:	ed bc 00 00 	bld	r12,0x0
80008a22:	e0 80 00 95 	breq	80008b4c <_realloc_r+0x1e4>
80008a26:	62 07       	ld.w	r7,r1[0x0]
80008a28:	e2 07 01 07 	sub	r7,r1,r7
80008a2c:	6e 1c       	ld.w	r12,r7[0x4]
80008a2e:	e0 1c ff fc 	andl	r12,0xfffc
80008a32:	58 09       	cp.w	r9,0
80008a34:	c5 60       	breq	80008ae0 <_realloc_r+0x178>
80008a36:	f8 00 00 03 	add	r3,r12,r0
80008a3a:	0a 39       	cp.w	r9,r5
80008a3c:	c4 81       	brne	80008acc <_realloc_r+0x164>
80008a3e:	14 03       	add	r3,r10
80008a40:	ec c9 ff f0 	sub	r9,r6,-16
80008a44:	12 33       	cp.w	r3,r9
80008a46:	c4 d5       	brlt	80008ae0 <_realloc_r+0x178>
80008a48:	6e 3a       	ld.w	r10,r7[0xc]
80008a4a:	6e 29       	ld.w	r9,r7[0x8]
80008a4c:	95 29       	st.w	r10[0x8],r9
80008a4e:	93 3a       	st.w	r9[0xc],r10
80008a50:	ee c5 ff f8 	sub	r5,r7,-8
80008a54:	e0 ca 00 04 	sub	r10,r0,4
80008a58:	e0 4a 00 24 	cp.w	r10,36
80008a5c:	e0 8b 00 25 	brhi	80008aa6 <_realloc_r+0x13e>
80008a60:	0a 99       	mov	r9,r5
80008a62:	59 3a       	cp.w	r10,19
80008a64:	e0 88 00 1a 	brls	80008a98 <_realloc_r+0x130>
80008a68:	09 09       	ld.w	r9,r4++
80008a6a:	8b 09       	st.w	r5[0x0],r9
80008a6c:	09 09       	ld.w	r9,r4++
80008a6e:	8f 39       	st.w	r7[0xc],r9
80008a70:	ee c9 ff f0 	sub	r9,r7,-16
80008a74:	59 ba       	cp.w	r10,27
80008a76:	e0 88 00 11 	brls	80008a98 <_realloc_r+0x130>
80008a7a:	09 0b       	ld.w	r11,r4++
80008a7c:	93 0b       	st.w	r9[0x0],r11
80008a7e:	09 09       	ld.w	r9,r4++
80008a80:	8f 59       	st.w	r7[0x14],r9
80008a82:	ee c9 ff e8 	sub	r9,r7,-24
80008a86:	e0 4a 00 24 	cp.w	r10,36
80008a8a:	c0 71       	brne	80008a98 <_realloc_r+0x130>
80008a8c:	09 0a       	ld.w	r10,r4++
80008a8e:	93 0a       	st.w	r9[0x0],r10
80008a90:	ee c9 ff e0 	sub	r9,r7,-32
80008a94:	09 0a       	ld.w	r10,r4++
80008a96:	8f 7a       	st.w	r7[0x1c],r10
80008a98:	09 0a       	ld.w	r10,r4++
80008a9a:	12 aa       	st.w	r9++,r10
80008a9c:	68 0a       	ld.w	r10,r4[0x0]
80008a9e:	93 0a       	st.w	r9[0x0],r10
80008aa0:	68 1a       	ld.w	r10,r4[0x4]
80008aa2:	93 1a       	st.w	r9[0x4],r10
80008aa4:	c0 78       	rjmp	80008ab2 <_realloc_r+0x14a>
80008aa6:	50 08       	stdsp	sp[0x0],r8
80008aa8:	08 9b       	mov	r11,r4
80008aaa:	0a 9c       	mov	r12,r5
80008aac:	e0 a0 1d 8f 	rcall	8000c5ca <memmove>
80008ab0:	40 08       	lddsp	r8,sp[0x0]
80008ab2:	ee 06 00 09 	add	r9,r7,r6
80008ab6:	0c 13       	sub	r3,r6
80008ab8:	a1 a3       	sbr	r3,0x0
80008aba:	93 13       	st.w	r9[0x4],r3
80008abc:	91 29       	st.w	r8[0x8],r9
80008abe:	04 9c       	mov	r12,r2
80008ac0:	6e 18       	ld.w	r8,r7[0x4]
80008ac2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008ac6:	10 46       	or	r6,r8
80008ac8:	8f 16       	st.w	r7[0x4],r6
80008aca:	ca a8       	rjmp	80008c1e <_realloc_r+0x2b6>
80008acc:	14 03       	add	r3,r10
80008ace:	0c 33       	cp.w	r3,r6
80008ad0:	c0 85       	brlt	80008ae0 <_realloc_r+0x178>
80008ad2:	72 28       	ld.w	r8,r9[0x8]
80008ad4:	72 39       	ld.w	r9,r9[0xc]
80008ad6:	93 28       	st.w	r9[0x8],r8
80008ad8:	91 39       	st.w	r8[0xc],r9
80008ada:	6e 28       	ld.w	r8,r7[0x8]
80008adc:	6e 39       	ld.w	r9,r7[0xc]
80008ade:	c0 78       	rjmp	80008aec <_realloc_r+0x184>
80008ae0:	f8 00 00 03 	add	r3,r12,r0
80008ae4:	0c 33       	cp.w	r3,r6
80008ae6:	c3 35       	brlt	80008b4c <_realloc_r+0x1e4>
80008ae8:	6e 39       	ld.w	r9,r7[0xc]
80008aea:	6e 28       	ld.w	r8,r7[0x8]
80008aec:	93 28       	st.w	r9[0x8],r8
80008aee:	91 39       	st.w	r8[0xc],r9
80008af0:	e0 ca 00 04 	sub	r10,r0,4
80008af4:	ee cc ff f8 	sub	r12,r7,-8
80008af8:	e0 4a 00 24 	cp.w	r10,36
80008afc:	e0 8b 00 24 	brhi	80008b44 <_realloc_r+0x1dc>
80008b00:	59 3a       	cp.w	r10,19
80008b02:	e0 88 00 1a 	brls	80008b36 <_realloc_r+0x1ce>
80008b06:	09 08       	ld.w	r8,r4++
80008b08:	99 08       	st.w	r12[0x0],r8
80008b0a:	09 08       	ld.w	r8,r4++
80008b0c:	8f 38       	st.w	r7[0xc],r8
80008b0e:	ee cc ff f0 	sub	r12,r7,-16
80008b12:	59 ba       	cp.w	r10,27
80008b14:	e0 88 00 11 	brls	80008b36 <_realloc_r+0x1ce>
80008b18:	09 08       	ld.w	r8,r4++
80008b1a:	99 08       	st.w	r12[0x0],r8
80008b1c:	09 08       	ld.w	r8,r4++
80008b1e:	8f 58       	st.w	r7[0x14],r8
80008b20:	ee cc ff e8 	sub	r12,r7,-24
80008b24:	e0 4a 00 24 	cp.w	r10,36
80008b28:	c0 71       	brne	80008b36 <_realloc_r+0x1ce>
80008b2a:	09 08       	ld.w	r8,r4++
80008b2c:	99 08       	st.w	r12[0x0],r8
80008b2e:	ee cc ff e0 	sub	r12,r7,-32
80008b32:	09 08       	ld.w	r8,r4++
80008b34:	8f 78       	st.w	r7[0x1c],r8
80008b36:	09 08       	ld.w	r8,r4++
80008b38:	18 a8       	st.w	r12++,r8
80008b3a:	68 08       	ld.w	r8,r4[0x0]
80008b3c:	99 08       	st.w	r12[0x0],r8
80008b3e:	68 18       	ld.w	r8,r4[0x4]
80008b40:	99 18       	st.w	r12[0x4],r8
80008b42:	c4 78       	rjmp	80008bd0 <_realloc_r+0x268>
80008b44:	08 9b       	mov	r11,r4
80008b46:	e0 a0 1d 42 	rcall	8000c5ca <memmove>
80008b4a:	c4 38       	rjmp	80008bd0 <_realloc_r+0x268>
80008b4c:	04 9c       	mov	r12,r2
80008b4e:	fe b0 fc 33 	rcall	800083b4 <_malloc_r>
80008b52:	18 95       	mov	r5,r12
80008b54:	c3 a0       	breq	80008bc8 <_realloc_r+0x260>
80008b56:	62 18       	ld.w	r8,r1[0x4]
80008b58:	f8 c9 00 08 	sub	r9,r12,8
80008b5c:	a1 c8       	cbr	r8,0x0
80008b5e:	e2 08 00 08 	add	r8,r1,r8
80008b62:	10 39       	cp.w	r9,r8
80008b64:	c0 71       	brne	80008b72 <_realloc_r+0x20a>
80008b66:	72 13       	ld.w	r3,r9[0x4]
80008b68:	02 97       	mov	r7,r1
80008b6a:	e0 13 ff fc 	andl	r3,0xfffc
80008b6e:	00 03       	add	r3,r0
80008b70:	c3 08       	rjmp	80008bd0 <_realloc_r+0x268>
80008b72:	e0 ca 00 04 	sub	r10,r0,4
80008b76:	e0 4a 00 24 	cp.w	r10,36
80008b7a:	e0 8b 00 20 	brhi	80008bba <_realloc_r+0x252>
80008b7e:	08 99       	mov	r9,r4
80008b80:	18 98       	mov	r8,r12
80008b82:	59 3a       	cp.w	r10,19
80008b84:	e0 88 00 14 	brls	80008bac <_realloc_r+0x244>
80008b88:	13 0b       	ld.w	r11,r9++
80008b8a:	10 ab       	st.w	r8++,r11
80008b8c:	13 0b       	ld.w	r11,r9++
80008b8e:	10 ab       	st.w	r8++,r11
80008b90:	59 ba       	cp.w	r10,27
80008b92:	e0 88 00 0d 	brls	80008bac <_realloc_r+0x244>
80008b96:	13 0b       	ld.w	r11,r9++
80008b98:	10 ab       	st.w	r8++,r11
80008b9a:	13 0b       	ld.w	r11,r9++
80008b9c:	10 ab       	st.w	r8++,r11
80008b9e:	e0 4a 00 24 	cp.w	r10,36
80008ba2:	c0 51       	brne	80008bac <_realloc_r+0x244>
80008ba4:	13 0a       	ld.w	r10,r9++
80008ba6:	10 aa       	st.w	r8++,r10
80008ba8:	13 0a       	ld.w	r10,r9++
80008baa:	10 aa       	st.w	r8++,r10
80008bac:	13 0a       	ld.w	r10,r9++
80008bae:	10 aa       	st.w	r8++,r10
80008bb0:	72 0a       	ld.w	r10,r9[0x0]
80008bb2:	91 0a       	st.w	r8[0x0],r10
80008bb4:	72 19       	ld.w	r9,r9[0x4]
80008bb6:	91 19       	st.w	r8[0x4],r9
80008bb8:	c0 48       	rjmp	80008bc0 <_realloc_r+0x258>
80008bba:	08 9b       	mov	r11,r4
80008bbc:	e0 a0 1d 07 	rcall	8000c5ca <memmove>
80008bc0:	08 9b       	mov	r11,r4
80008bc2:	04 9c       	mov	r12,r2
80008bc4:	e0 a0 1a 60 	rcall	8000c084 <_free_r>
80008bc8:	04 9c       	mov	r12,r2
80008bca:	c2 a8       	rjmp	80008c1e <_realloc_r+0x2b6>
80008bcc:	00 93       	mov	r3,r0
80008bce:	02 97       	mov	r7,r1
80008bd0:	e6 06 01 09 	sub	r9,r3,r6
80008bd4:	6e 18       	ld.w	r8,r7[0x4]
80008bd6:	58 f9       	cp.w	r9,15
80008bd8:	e0 88 00 16 	brls	80008c04 <_realloc_r+0x29c>
80008bdc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008be0:	ed e8 10 08 	or	r8,r6,r8
80008be4:	8f 18       	st.w	r7[0x4],r8
80008be6:	12 98       	mov	r8,r9
80008be8:	a1 a8       	sbr	r8,0x0
80008bea:	ee 06 00 0b 	add	r11,r7,r6
80008bee:	f6 09 00 09 	add	r9,r11,r9
80008bf2:	97 18       	st.w	r11[0x4],r8
80008bf4:	72 18       	ld.w	r8,r9[0x4]
80008bf6:	a1 a8       	sbr	r8,0x0
80008bf8:	2f 8b       	sub	r11,-8
80008bfa:	93 18       	st.w	r9[0x4],r8
80008bfc:	04 9c       	mov	r12,r2
80008bfe:	e0 a0 1a 43 	rcall	8000c084 <_free_r>
80008c02:	c0 b8       	rjmp	80008c18 <_realloc_r+0x2b0>
80008c04:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008c08:	e7 e8 10 08 	or	r8,r3,r8
80008c0c:	8f 18       	st.w	r7[0x4],r8
80008c0e:	ee 03 00 03 	add	r3,r7,r3
80008c12:	66 18       	ld.w	r8,r3[0x4]
80008c14:	a1 a8       	sbr	r8,0x0
80008c16:	87 18       	st.w	r3[0x4],r8
80008c18:	04 9c       	mov	r12,r2
80008c1a:	ee c5 ff f8 	sub	r5,r7,-8
80008c1e:	fe b0 f1 87 	rcall	80006f2c <__malloc_unlock>
80008c22:	0a 9c       	mov	r12,r5
80008c24:	2f fd       	sub	sp,-4
80008c26:	d8 32       	popm	r0-r7,pc

80008c28 <_sbrk_r>:
80008c28:	d4 21       	pushm	r4-r7,lr
80008c2a:	30 08       	mov	r8,0
80008c2c:	18 97       	mov	r7,r12
80008c2e:	e0 66 a6 c8 	mov	r6,42696
80008c32:	16 9c       	mov	r12,r11
80008c34:	8d 08       	st.w	r6[0x0],r8
80008c36:	c8 5c       	rcall	80008d40 <_sbrk>
80008c38:	5b fc       	cp.w	r12,-1
80008c3a:	c0 51       	brne	80008c44 <_sbrk_r+0x1c>
80008c3c:	6c 08       	ld.w	r8,r6[0x0]
80008c3e:	58 08       	cp.w	r8,0
80008c40:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008c44:	d8 22       	popm	r4-r7,pc
80008c46:	d7 03       	nop

80008c48 <sprintf>:
80008c48:	d4 01       	pushm	lr
80008c4a:	21 7d       	sub	sp,92
80008c4c:	e0 68 ff ff 	mov	r8,65535
80008c50:	ea 18 7f ff 	orh	r8,0x7fff
80008c54:	50 58       	stdsp	sp[0x14],r8
80008c56:	50 28       	stdsp	sp[0x8],r8
80008c58:	e0 68 02 08 	mov	r8,520
80008c5c:	ba 68       	st.h	sp[0xc],r8
80008c5e:	3f f8       	mov	r8,-1
80008c60:	ba 78       	st.h	sp[0xe],r8
80008c62:	e0 68 0a 54 	mov	r8,2644
80008c66:	50 4c       	stdsp	sp[0x10],r12
80008c68:	16 9a       	mov	r10,r11
80008c6a:	50 0c       	stdsp	sp[0x0],r12
80008c6c:	fa c9 ff a0 	sub	r9,sp,-96
80008c70:	70 0c       	ld.w	r12,r8[0x0]
80008c72:	1a 9b       	mov	r11,sp
80008c74:	e0 a0 02 1a 	rcall	800090a8 <_vfprintf_r>
80008c78:	30 09       	mov	r9,0
80008c7a:	40 08       	lddsp	r8,sp[0x0]
80008c7c:	b0 89       	st.b	r8[0x0],r9
80008c7e:	2e 9d       	sub	sp,-92
80008c80:	d8 02       	popm	pc
80008c82:	d7 03       	nop

80008c84 <strncpy>:
80008c84:	30 08       	mov	r8,0
80008c86:	10 3a       	cp.w	r10,r8
80008c88:	5e 0c       	reteq	r12
80008c8a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008c8e:	f8 08 0b 09 	st.b	r12[r8],r9
80008c92:	2f f8       	sub	r8,-1
80008c94:	58 09       	cp.w	r9,0
80008c96:	cf 81       	brne	80008c86 <strncpy+0x2>
80008c98:	10 3a       	cp.w	r10,r8
80008c9a:	5e 0c       	reteq	r12
80008c9c:	f8 08 0b 09 	st.b	r12[r8],r9
80008ca0:	2f f8       	sub	r8,-1
80008ca2:	cf bb       	rjmp	80008c98 <strncpy+0x14>

80008ca4 <_close>:
80008ca4:	30 28       	mov	r8,2
80008ca6:	d6 73       	breakpoint
80008ca8:	3f fc       	mov	r12,-1
80008caa:	35 8b       	mov	r11,88
80008cac:	58 0c       	cp.w	r12,0
80008cae:	5e 4c       	retge	r12
80008cb0:	e0 6a a6 c8 	mov	r10,42696
80008cb4:	95 0b       	st.w	r10[0x0],r11
80008cb6:	5e fc       	retal	r12

80008cb8 <_lseek>:
80008cb8:	30 58       	mov	r8,5
80008cba:	d6 73       	breakpoint
80008cbc:	3f fc       	mov	r12,-1
80008cbe:	35 8b       	mov	r11,88
80008cc0:	58 0c       	cp.w	r12,0
80008cc2:	5e 4c       	retge	r12
80008cc4:	e0 6a a6 c8 	mov	r10,42696
80008cc8:	95 0b       	st.w	r10[0x0],r11
80008cca:	5e fc       	retal	r12

80008ccc <isatty>:
80008ccc:	30 b8       	mov	r8,11
80008cce:	d6 73       	breakpoint
80008cd0:	3f fc       	mov	r12,-1
80008cd2:	35 8b       	mov	r11,88
80008cd4:	58 0c       	cp.w	r12,0
80008cd6:	5e 4c       	retge	r12
80008cd8:	e0 6a a6 c8 	mov	r10,42696
80008cdc:	95 0b       	st.w	r10[0x0],r11
80008cde:	5e fc       	retal	r12

80008ce0 <_fstat_host>:
80008ce0:	30 98       	mov	r8,9
80008ce2:	d6 73       	breakpoint
80008ce4:	3f fc       	mov	r12,-1
80008ce6:	35 8b       	mov	r11,88
80008ce8:	58 0c       	cp.w	r12,0
80008cea:	5e 4c       	retge	r12
80008cec:	e0 6a a6 c8 	mov	r10,42696
80008cf0:	95 0b       	st.w	r10[0x0],r11
80008cf2:	5e fc       	retal	r12

80008cf4 <_fstat>:
80008cf4:	d4 21       	pushm	r4-r7,lr
80008cf6:	21 0d       	sub	sp,64
80008cf8:	16 97       	mov	r7,r11
80008cfa:	1a 9b       	mov	r11,sp
80008cfc:	cf 2f       	rcall	80008ce0 <_fstat_host>
80008cfe:	c0 34       	brge	80008d04 <_fstat+0x10>
80008d00:	3f fc       	mov	r12,-1
80008d02:	c1 c8       	rjmp	80008d3a <_fstat+0x46>
80008d04:	40 08       	lddsp	r8,sp[0x0]
80008d06:	ae 08       	st.h	r7[0x0],r8
80008d08:	40 18       	lddsp	r8,sp[0x4]
80008d0a:	ae 18       	st.h	r7[0x2],r8
80008d0c:	40 28       	lddsp	r8,sp[0x8]
80008d0e:	8f 18       	st.w	r7[0x4],r8
80008d10:	40 38       	lddsp	r8,sp[0xc]
80008d12:	ae 48       	st.h	r7[0x8],r8
80008d14:	40 48       	lddsp	r8,sp[0x10]
80008d16:	ae 58       	st.h	r7[0xa],r8
80008d18:	40 58       	lddsp	r8,sp[0x14]
80008d1a:	ae 68       	st.h	r7[0xc],r8
80008d1c:	40 68       	lddsp	r8,sp[0x18]
80008d1e:	ae 78       	st.h	r7[0xe],r8
80008d20:	40 88       	lddsp	r8,sp[0x20]
80008d22:	8f 48       	st.w	r7[0x10],r8
80008d24:	40 a8       	lddsp	r8,sp[0x28]
80008d26:	8f b8       	st.w	r7[0x2c],r8
80008d28:	40 c8       	lddsp	r8,sp[0x30]
80008d2a:	8f c8       	st.w	r7[0x30],r8
80008d2c:	40 d8       	lddsp	r8,sp[0x34]
80008d2e:	8f 58       	st.w	r7[0x14],r8
80008d30:	40 e8       	lddsp	r8,sp[0x38]
80008d32:	30 0c       	mov	r12,0
80008d34:	8f 78       	st.w	r7[0x1c],r8
80008d36:	40 f8       	lddsp	r8,sp[0x3c]
80008d38:	8f 98       	st.w	r7[0x24],r8
80008d3a:	2f 0d       	sub	sp,-64
80008d3c:	d8 22       	popm	r4-r7,pc
80008d3e:	d7 03       	nop

80008d40 <_sbrk>:
80008d40:	d4 01       	pushm	lr
80008d42:	e0 68 0e 18 	mov	r8,3608
80008d46:	70 09       	ld.w	r9,r8[0x0]
80008d48:	58 09       	cp.w	r9,0
80008d4a:	c0 41       	brne	80008d52 <_sbrk+0x12>
80008d4c:	e0 69 a6 d0 	mov	r9,42704
80008d50:	91 09       	st.w	r8[0x0],r9
80008d52:	e0 69 0e 18 	mov	r9,3608
80008d56:	e0 7a 70 00 	mov	r10,94208
80008d5a:	72 08       	ld.w	r8,r9[0x0]
80008d5c:	f0 0c 00 0c 	add	r12,r8,r12
80008d60:	14 3c       	cp.w	r12,r10
80008d62:	e0 8b 00 04 	brhi	80008d6a <_sbrk+0x2a>
80008d66:	93 0c       	st.w	r9[0x0],r12
80008d68:	c0 68       	rjmp	80008d74 <_sbrk+0x34>
80008d6a:	e0 a0 18 15 	rcall	8000bd94 <__errno>
80008d6e:	30 c8       	mov	r8,12
80008d70:	99 08       	st.w	r12[0x0],r8
80008d72:	3f f8       	mov	r8,-1
80008d74:	10 9c       	mov	r12,r8
80008d76:	d8 02       	popm	pc

80008d78 <get_arg>:
80008d78:	d4 31       	pushm	r0-r7,lr
80008d7a:	20 8d       	sub	sp,32
80008d7c:	fa c4 ff bc 	sub	r4,sp,-68
80008d80:	50 4b       	stdsp	sp[0x10],r11
80008d82:	68 2e       	ld.w	lr,r4[0x8]
80008d84:	50 58       	stdsp	sp[0x14],r8
80008d86:	12 96       	mov	r6,r9
80008d88:	7c 0b       	ld.w	r11,lr[0x0]
80008d8a:	70 05       	ld.w	r5,r8[0x0]
80008d8c:	50 6e       	stdsp	sp[0x18],lr
80008d8e:	58 0b       	cp.w	r11,0
80008d90:	f4 0b 17 00 	moveq	r11,r10
80008d94:	68 03       	ld.w	r3,r4[0x0]
80008d96:	68 11       	ld.w	r1,r4[0x4]
80008d98:	40 49       	lddsp	r9,sp[0x10]
80008d9a:	30 08       	mov	r8,0
80008d9c:	c2 89       	rjmp	80008fec <get_arg+0x274>
80008d9e:	2f fb       	sub	r11,-1
80008da0:	32 5c       	mov	r12,37
80008da2:	17 8a       	ld.ub	r10,r11[0x0]
80008da4:	f8 0a 18 00 	cp.b	r10,r12
80008da8:	5f 1e       	srne	lr
80008daa:	f0 0a 18 00 	cp.b	r10,r8
80008dae:	5f 1c       	srne	r12
80008db0:	fd ec 00 0c 	and	r12,lr,r12
80008db4:	f0 0c 18 00 	cp.b	r12,r8
80008db8:	cf 31       	brne	80008d9e <get_arg+0x26>
80008dba:	58 0a       	cp.w	r10,0
80008dbc:	e0 80 01 25 	breq	80009006 <get_arg+0x28e>
80008dc0:	30 0c       	mov	r12,0
80008dc2:	3f fa       	mov	r10,-1
80008dc4:	18 90       	mov	r0,r12
80008dc6:	50 3a       	stdsp	sp[0xc],r10
80008dc8:	18 94       	mov	r4,r12
80008dca:	18 92       	mov	r2,r12
80008dcc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008dd0:	16 97       	mov	r7,r11
80008dd2:	50 7c       	stdsp	sp[0x1c],r12
80008dd4:	fe cc 9a 38 	sub	r12,pc,-26056
80008dd8:	0f 3a       	ld.ub	r10,r7++
80008dda:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008dde:	40 7c       	lddsp	r12,sp[0x1c]
80008de0:	1c 0c       	add	r12,lr
80008de2:	fe ce 9b 0e 	sub	lr,pc,-25842
80008de6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008dea:	20 1e       	sub	lr,1
80008dec:	50 0e       	stdsp	sp[0x0],lr
80008dee:	fe ce 9b 86 	sub	lr,pc,-25722
80008df2:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008df6:	50 7c       	stdsp	sp[0x1c],r12
80008df8:	40 0c       	lddsp	r12,sp[0x0]
80008dfa:	58 7c       	cp.w	r12,7
80008dfc:	e0 8b 00 f1 	brhi	80008fde <get_arg+0x266>
80008e00:	fe ce 9d 38 	sub	lr,pc,-25288
80008e04:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008e08:	36 8b       	mov	r11,104
80008e0a:	f6 0a 18 00 	cp.b	r10,r11
80008e0e:	e0 80 00 e8 	breq	80008fde <get_arg+0x266>
80008e12:	37 1b       	mov	r11,113
80008e14:	f6 0a 18 00 	cp.b	r10,r11
80008e18:	c0 70       	breq	80008e26 <get_arg+0xae>
80008e1a:	34 cb       	mov	r11,76
80008e1c:	f6 0a 18 00 	cp.b	r10,r11
80008e20:	c0 51       	brne	80008e2a <get_arg+0xb2>
80008e22:	a3 b4       	sbr	r4,0x3
80008e24:	cd d8       	rjmp	80008fde <get_arg+0x266>
80008e26:	a5 b4       	sbr	r4,0x5
80008e28:	cd b8       	rjmp	80008fde <get_arg+0x266>
80008e2a:	08 9a       	mov	r10,r4
80008e2c:	0e 9b       	mov	r11,r7
80008e2e:	a5 aa       	sbr	r10,0x4
80008e30:	17 3c       	ld.ub	r12,r11++
80008e32:	a5 b4       	sbr	r4,0x5
80008e34:	36 ce       	mov	lr,108
80008e36:	fc 0c 18 00 	cp.b	r12,lr
80008e3a:	e0 80 00 d3 	breq	80008fe0 <get_arg+0x268>
80008e3e:	14 94       	mov	r4,r10
80008e40:	cc f8       	rjmp	80008fde <get_arg+0x266>
80008e42:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008e46:	36 7c       	mov	r12,103
80008e48:	f8 0a 18 00 	cp.b	r10,r12
80008e4c:	e0 8b 00 27 	brhi	80008e9a <get_arg+0x122>
80008e50:	36 5b       	mov	r11,101
80008e52:	f6 0a 18 00 	cp.b	r10,r11
80008e56:	c4 82       	brcc	80008ee6 <get_arg+0x16e>
80008e58:	34 fb       	mov	r11,79
80008e5a:	f6 0a 18 00 	cp.b	r10,r11
80008e5e:	c4 80       	breq	80008eee <get_arg+0x176>
80008e60:	e0 8b 00 0c 	brhi	80008e78 <get_arg+0x100>
80008e64:	34 5b       	mov	r11,69
80008e66:	f6 0a 18 00 	cp.b	r10,r11
80008e6a:	c3 e0       	breq	80008ee6 <get_arg+0x16e>
80008e6c:	34 7b       	mov	r11,71
80008e6e:	f6 0a 18 00 	cp.b	r10,r11
80008e72:	c3 a0       	breq	80008ee6 <get_arg+0x16e>
80008e74:	34 4b       	mov	r11,68
80008e76:	c0 88       	rjmp	80008e86 <get_arg+0x10e>
80008e78:	35 8b       	mov	r11,88
80008e7a:	f6 0a 18 00 	cp.b	r10,r11
80008e7e:	c2 c0       	breq	80008ed6 <get_arg+0x15e>
80008e80:	e0 8b 00 07 	brhi	80008e8e <get_arg+0x116>
80008e84:	35 5b       	mov	r11,85
80008e86:	f6 0a 18 00 	cp.b	r10,r11
80008e8a:	c3 51       	brne	80008ef4 <get_arg+0x17c>
80008e8c:	c3 18       	rjmp	80008eee <get_arg+0x176>
80008e8e:	36 3b       	mov	r11,99
80008e90:	f6 0a 18 00 	cp.b	r10,r11
80008e94:	c2 f0       	breq	80008ef2 <get_arg+0x17a>
80008e96:	36 4b       	mov	r11,100
80008e98:	c0 e8       	rjmp	80008eb4 <get_arg+0x13c>
80008e9a:	37 0b       	mov	r11,112
80008e9c:	f6 0a 18 00 	cp.b	r10,r11
80008ea0:	c2 50       	breq	80008eea <get_arg+0x172>
80008ea2:	e0 8b 00 0d 	brhi	80008ebc <get_arg+0x144>
80008ea6:	36 eb       	mov	r11,110
80008ea8:	f6 0a 18 00 	cp.b	r10,r11
80008eac:	c1 f0       	breq	80008eea <get_arg+0x172>
80008eae:	e0 8b 00 14 	brhi	80008ed6 <get_arg+0x15e>
80008eb2:	36 9b       	mov	r11,105
80008eb4:	f6 0a 18 00 	cp.b	r10,r11
80008eb8:	c1 e1       	brne	80008ef4 <get_arg+0x17c>
80008eba:	c0 e8       	rjmp	80008ed6 <get_arg+0x15e>
80008ebc:	37 5b       	mov	r11,117
80008ebe:	f6 0a 18 00 	cp.b	r10,r11
80008ec2:	c0 a0       	breq	80008ed6 <get_arg+0x15e>
80008ec4:	37 8b       	mov	r11,120
80008ec6:	f6 0a 18 00 	cp.b	r10,r11
80008eca:	c0 60       	breq	80008ed6 <get_arg+0x15e>
80008ecc:	37 3b       	mov	r11,115
80008ece:	f6 0a 18 00 	cp.b	r10,r11
80008ed2:	c1 11       	brne	80008ef4 <get_arg+0x17c>
80008ed4:	c0 b8       	rjmp	80008eea <get_arg+0x172>
80008ed6:	ed b4 00 04 	bld	r4,0x4
80008eda:	c0 a0       	breq	80008eee <get_arg+0x176>
80008edc:	ed b4 00 05 	bld	r4,0x5
80008ee0:	c0 91       	brne	80008ef2 <get_arg+0x17a>
80008ee2:	30 20       	mov	r0,2
80008ee4:	c0 88       	rjmp	80008ef4 <get_arg+0x17c>
80008ee6:	30 40       	mov	r0,4
80008ee8:	c0 68       	rjmp	80008ef4 <get_arg+0x17c>
80008eea:	30 30       	mov	r0,3
80008eec:	c0 48       	rjmp	80008ef4 <get_arg+0x17c>
80008eee:	30 10       	mov	r0,1
80008ef0:	c0 28       	rjmp	80008ef4 <get_arg+0x17c>
80008ef2:	30 00       	mov	r0,0
80008ef4:	40 3b       	lddsp	r11,sp[0xc]
80008ef6:	5b fb       	cp.w	r11,-1
80008ef8:	c0 40       	breq	80008f00 <get_arg+0x188>
80008efa:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008efe:	c7 08       	rjmp	80008fde <get_arg+0x266>
80008f00:	58 60       	cp.w	r0,6
80008f02:	e0 8b 00 6e 	brhi	80008fde <get_arg+0x266>
80008f06:	6c 0a       	ld.w	r10,r6[0x0]
80008f08:	ea cc ff ff 	sub	r12,r5,-1
80008f0c:	fe ce 9e 24 	sub	lr,pc,-25052
80008f10:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008f14:	f4 cb ff f8 	sub	r11,r10,-8
80008f18:	8d 0b       	st.w	r6[0x0],r11
80008f1a:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f1e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f22:	c0 f8       	rjmp	80008f40 <get_arg+0x1c8>
80008f24:	f4 cb ff fc 	sub	r11,r10,-4
80008f28:	8d 0b       	st.w	r6[0x0],r11
80008f2a:	74 0a       	ld.w	r10,r10[0x0]
80008f2c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f30:	c0 88       	rjmp	80008f40 <get_arg+0x1c8>
80008f32:	f4 cb ff f8 	sub	r11,r10,-8
80008f36:	8d 0b       	st.w	r6[0x0],r11
80008f38:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f3c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f40:	0e 9b       	mov	r11,r7
80008f42:	18 95       	mov	r5,r12
80008f44:	c4 e8       	rjmp	80008fe0 <get_arg+0x268>
80008f46:	62 0a       	ld.w	r10,r1[0x0]
80008f48:	5b fa       	cp.w	r10,-1
80008f4a:	c0 b1       	brne	80008f60 <get_arg+0x1e8>
80008f4c:	50 19       	stdsp	sp[0x4],r9
80008f4e:	50 28       	stdsp	sp[0x8],r8
80008f50:	e0 6a 00 80 	mov	r10,128
80008f54:	30 0b       	mov	r11,0
80008f56:	02 9c       	mov	r12,r1
80008f58:	fe b0 fd 01 	rcall	8000895a <memset>
80008f5c:	40 28       	lddsp	r8,sp[0x8]
80008f5e:	40 19       	lddsp	r9,sp[0x4]
80008f60:	e4 cc 00 01 	sub	r12,r2,1
80008f64:	0e 9b       	mov	r11,r7
80008f66:	50 3c       	stdsp	sp[0xc],r12
80008f68:	f2 0c 0c 49 	max	r9,r9,r12
80008f6c:	c3 a8       	rjmp	80008fe0 <get_arg+0x268>
80008f6e:	62 0a       	ld.w	r10,r1[0x0]
80008f70:	5b fa       	cp.w	r10,-1
80008f72:	c0 b1       	brne	80008f88 <get_arg+0x210>
80008f74:	50 19       	stdsp	sp[0x4],r9
80008f76:	50 28       	stdsp	sp[0x8],r8
80008f78:	e0 6a 00 80 	mov	r10,128
80008f7c:	30 0b       	mov	r11,0
80008f7e:	02 9c       	mov	r12,r1
80008f80:	fe b0 fc ed 	rcall	8000895a <memset>
80008f84:	40 28       	lddsp	r8,sp[0x8]
80008f86:	40 19       	lddsp	r9,sp[0x4]
80008f88:	20 12       	sub	r2,1
80008f8a:	30 0a       	mov	r10,0
80008f8c:	0e 9b       	mov	r11,r7
80008f8e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008f92:	f2 02 0c 49 	max	r9,r9,r2
80008f96:	c2 58       	rjmp	80008fe0 <get_arg+0x268>
80008f98:	16 97       	mov	r7,r11
80008f9a:	6c 0a       	ld.w	r10,r6[0x0]
80008f9c:	f4 cb ff fc 	sub	r11,r10,-4
80008fa0:	8d 0b       	st.w	r6[0x0],r11
80008fa2:	74 0a       	ld.w	r10,r10[0x0]
80008fa4:	0e 9b       	mov	r11,r7
80008fa6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008faa:	2f f5       	sub	r5,-1
80008fac:	c1 a8       	rjmp	80008fe0 <get_arg+0x268>
80008fae:	f4 c2 00 30 	sub	r2,r10,48
80008fb2:	c0 68       	rjmp	80008fbe <get_arg+0x246>
80008fb4:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008fb8:	2f f7       	sub	r7,-1
80008fba:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008fbe:	0f 8a       	ld.ub	r10,r7[0x0]
80008fc0:	58 0a       	cp.w	r10,0
80008fc2:	c0 e0       	breq	80008fde <get_arg+0x266>
80008fc4:	23 0a       	sub	r10,48
80008fc6:	58 9a       	cp.w	r10,9
80008fc8:	fe 98 ff f6 	brls	80008fb4 <get_arg+0x23c>
80008fcc:	c0 98       	rjmp	80008fde <get_arg+0x266>
80008fce:	2f f7       	sub	r7,-1
80008fd0:	0f 8a       	ld.ub	r10,r7[0x0]
80008fd2:	58 0a       	cp.w	r10,0
80008fd4:	c0 50       	breq	80008fde <get_arg+0x266>
80008fd6:	23 0a       	sub	r10,48
80008fd8:	58 9a       	cp.w	r10,9
80008fda:	fe 98 ff fa 	brls	80008fce <get_arg+0x256>
80008fde:	0e 9b       	mov	r11,r7
80008fe0:	40 7c       	lddsp	r12,sp[0x1c]
80008fe2:	30 ba       	mov	r10,11
80008fe4:	f4 0c 18 00 	cp.b	r12,r10
80008fe8:	fe 91 fe f2 	brne	80008dcc <get_arg+0x54>
80008fec:	40 42       	lddsp	r2,sp[0x10]
80008fee:	17 8c       	ld.ub	r12,r11[0x0]
80008ff0:	0a 32       	cp.w	r2,r5
80008ff2:	5f 4a       	srge	r10
80008ff4:	f0 0c 18 00 	cp.b	r12,r8
80008ff8:	5f 1c       	srne	r12
80008ffa:	f9 ea 00 0a 	and	r10,r12,r10
80008ffe:	f0 0a 18 00 	cp.b	r10,r8
80009002:	fe 91 fe cf 	brne	80008da0 <get_arg+0x28>
80009006:	30 08       	mov	r8,0
80009008:	40 4e       	lddsp	lr,sp[0x10]
8000900a:	17 8a       	ld.ub	r10,r11[0x0]
8000900c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80009010:	f0 0a 18 00 	cp.b	r10,r8
80009014:	fc 09 17 10 	movne	r9,lr
80009018:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000901c:	06 9e       	mov	lr,r3
8000901e:	c2 a8       	rjmp	80009072 <get_arg+0x2fa>
80009020:	62 0a       	ld.w	r10,r1[0x0]
80009022:	58 3a       	cp.w	r10,3
80009024:	c1 e0       	breq	80009060 <get_arg+0x2e8>
80009026:	e0 89 00 07 	brgt	80009034 <get_arg+0x2bc>
8000902a:	58 1a       	cp.w	r10,1
8000902c:	c1 a0       	breq	80009060 <get_arg+0x2e8>
8000902e:	58 2a       	cp.w	r10,2
80009030:	c1 81       	brne	80009060 <get_arg+0x2e8>
80009032:	c0 58       	rjmp	8000903c <get_arg+0x2c4>
80009034:	58 5a       	cp.w	r10,5
80009036:	c0 c0       	breq	8000904e <get_arg+0x2d6>
80009038:	c0 b5       	brlt	8000904e <get_arg+0x2d6>
8000903a:	c1 38       	rjmp	80009060 <get_arg+0x2e8>
8000903c:	6c 0a       	ld.w	r10,r6[0x0]
8000903e:	f4 cc ff f8 	sub	r12,r10,-8
80009042:	8d 0c       	st.w	r6[0x0],r12
80009044:	f4 e2 00 00 	ld.d	r2,r10[0]
80009048:	f0 e3 00 00 	st.d	r8[0],r2
8000904c:	c1 08       	rjmp	8000906c <get_arg+0x2f4>
8000904e:	6c 0a       	ld.w	r10,r6[0x0]
80009050:	f4 cc ff f8 	sub	r12,r10,-8
80009054:	8d 0c       	st.w	r6[0x0],r12
80009056:	f4 e2 00 00 	ld.d	r2,r10[0]
8000905a:	f0 e3 00 00 	st.d	r8[0],r2
8000905e:	c0 78       	rjmp	8000906c <get_arg+0x2f4>
80009060:	6c 0a       	ld.w	r10,r6[0x0]
80009062:	f4 cc ff fc 	sub	r12,r10,-4
80009066:	8d 0c       	st.w	r6[0x0],r12
80009068:	74 0a       	ld.w	r10,r10[0x0]
8000906a:	91 0a       	st.w	r8[0x0],r10
8000906c:	2f f5       	sub	r5,-1
8000906e:	2f 88       	sub	r8,-8
80009070:	2f c1       	sub	r1,-4
80009072:	12 35       	cp.w	r5,r9
80009074:	fe 9a ff d6 	brle	80009020 <get_arg+0x2a8>
80009078:	1c 93       	mov	r3,lr
8000907a:	40 52       	lddsp	r2,sp[0x14]
8000907c:	40 6e       	lddsp	lr,sp[0x18]
8000907e:	85 05       	st.w	r2[0x0],r5
80009080:	9d 0b       	st.w	lr[0x0],r11
80009082:	40 4b       	lddsp	r11,sp[0x10]
80009084:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80009088:	2f 8d       	sub	sp,-32
8000908a:	d8 32       	popm	r0-r7,pc

8000908c <__sprint_r>:
8000908c:	d4 21       	pushm	r4-r7,lr
8000908e:	14 97       	mov	r7,r10
80009090:	74 28       	ld.w	r8,r10[0x8]
80009092:	58 08       	cp.w	r8,0
80009094:	c0 41       	brne	8000909c <__sprint_r+0x10>
80009096:	95 18       	st.w	r10[0x4],r8
80009098:	10 9c       	mov	r12,r8
8000909a:	d8 22       	popm	r4-r7,pc
8000909c:	e0 a0 18 ba 	rcall	8000c210 <__sfvwrite_r>
800090a0:	30 08       	mov	r8,0
800090a2:	8f 18       	st.w	r7[0x4],r8
800090a4:	8f 28       	st.w	r7[0x8],r8
800090a6:	d8 22       	popm	r4-r7,pc

800090a8 <_vfprintf_r>:
800090a8:	d4 31       	pushm	r0-r7,lr
800090aa:	fa cd 06 bc 	sub	sp,sp,1724
800090ae:	51 09       	stdsp	sp[0x40],r9
800090b0:	16 91       	mov	r1,r11
800090b2:	14 97       	mov	r7,r10
800090b4:	18 95       	mov	r5,r12
800090b6:	e0 a0 1a 1d 	rcall	8000c4f0 <_localeconv_r>
800090ba:	78 0c       	ld.w	r12,r12[0x0]
800090bc:	50 cc       	stdsp	sp[0x30],r12
800090be:	58 05       	cp.w	r5,0
800090c0:	c0 70       	breq	800090ce <_vfprintf_r+0x26>
800090c2:	6a 68       	ld.w	r8,r5[0x18]
800090c4:	58 08       	cp.w	r8,0
800090c6:	c0 41       	brne	800090ce <_vfprintf_r+0x26>
800090c8:	0a 9c       	mov	r12,r5
800090ca:	e0 a0 17 43 	rcall	8000bf50 <__sinit>
800090ce:	fe c8 9c 22 	sub	r8,pc,-25566
800090d2:	10 31       	cp.w	r1,r8
800090d4:	c0 31       	brne	800090da <_vfprintf_r+0x32>
800090d6:	6a 01       	ld.w	r1,r5[0x0]
800090d8:	c0 c8       	rjmp	800090f0 <_vfprintf_r+0x48>
800090da:	fe c8 9c 0e 	sub	r8,pc,-25586
800090de:	10 31       	cp.w	r1,r8
800090e0:	c0 31       	brne	800090e6 <_vfprintf_r+0x3e>
800090e2:	6a 11       	ld.w	r1,r5[0x4]
800090e4:	c0 68       	rjmp	800090f0 <_vfprintf_r+0x48>
800090e6:	fe c8 9b fa 	sub	r8,pc,-25606
800090ea:	10 31       	cp.w	r1,r8
800090ec:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800090f0:	82 68       	ld.sh	r8,r1[0xc]
800090f2:	ed b8 00 03 	bld	r8,0x3
800090f6:	c0 41       	brne	800090fe <_vfprintf_r+0x56>
800090f8:	62 48       	ld.w	r8,r1[0x10]
800090fa:	58 08       	cp.w	r8,0
800090fc:	c0 71       	brne	8000910a <_vfprintf_r+0x62>
800090fe:	02 9b       	mov	r11,r1
80009100:	0a 9c       	mov	r12,r5
80009102:	e0 a0 0f 5d 	rcall	8000afbc <__swsetup_r>
80009106:	e0 81 0f 54 	brne	8000afae <_vfprintf_r+0x1f06>
8000910a:	82 68       	ld.sh	r8,r1[0xc]
8000910c:	10 99       	mov	r9,r8
8000910e:	e2 19 00 1a 	andl	r9,0x1a,COH
80009112:	58 a9       	cp.w	r9,10
80009114:	c3 c1       	brne	8000918c <_vfprintf_r+0xe4>
80009116:	82 79       	ld.sh	r9,r1[0xe]
80009118:	30 0a       	mov	r10,0
8000911a:	f4 09 19 00 	cp.h	r9,r10
8000911e:	c3 75       	brlt	8000918c <_vfprintf_r+0xe4>
80009120:	a1 d8       	cbr	r8,0x1
80009122:	fb 58 05 d0 	st.h	sp[1488],r8
80009126:	62 88       	ld.w	r8,r1[0x20]
80009128:	fb 48 05 e4 	st.w	sp[1508],r8
8000912c:	62 a8       	ld.w	r8,r1[0x28]
8000912e:	fb 48 05 ec 	st.w	sp[1516],r8
80009132:	fa c8 ff bc 	sub	r8,sp,-68
80009136:	fb 48 05 d4 	st.w	sp[1492],r8
8000913a:	fb 48 05 c4 	st.w	sp[1476],r8
8000913e:	e0 68 04 00 	mov	r8,1024
80009142:	fb 48 05 d8 	st.w	sp[1496],r8
80009146:	fb 48 05 cc 	st.w	sp[1484],r8
8000914a:	30 08       	mov	r8,0
8000914c:	fb 59 05 d2 	st.h	sp[1490],r9
80009150:	0e 9a       	mov	r10,r7
80009152:	41 09       	lddsp	r9,sp[0x40]
80009154:	fa c7 fa 3c 	sub	r7,sp,-1476
80009158:	fb 48 05 dc 	st.w	sp[1500],r8
8000915c:	0a 9c       	mov	r12,r5
8000915e:	0e 9b       	mov	r11,r7
80009160:	ca 4f       	rcall	800090a8 <_vfprintf_r>
80009162:	50 bc       	stdsp	sp[0x2c],r12
80009164:	c0 95       	brlt	80009176 <_vfprintf_r+0xce>
80009166:	0e 9b       	mov	r11,r7
80009168:	0a 9c       	mov	r12,r5
8000916a:	e0 a0 16 1b 	rcall	8000bda0 <_fflush_r>
8000916e:	40 be       	lddsp	lr,sp[0x2c]
80009170:	f9 be 01 ff 	movne	lr,-1
80009174:	50 be       	stdsp	sp[0x2c],lr
80009176:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000917a:	ed b8 00 06 	bld	r8,0x6
8000917e:	e0 81 0f 1a 	brne	8000afb2 <_vfprintf_r+0x1f0a>
80009182:	82 68       	ld.sh	r8,r1[0xc]
80009184:	a7 a8       	sbr	r8,0x6
80009186:	a2 68       	st.h	r1[0xc],r8
80009188:	e0 8f 0f 15 	bral	8000afb2 <_vfprintf_r+0x1f0a>
8000918c:	30 08       	mov	r8,0
8000918e:	fb 48 06 b4 	st.w	sp[1716],r8
80009192:	fb 48 06 90 	st.w	sp[1680],r8
80009196:	fb 48 06 8c 	st.w	sp[1676],r8
8000919a:	fb 48 06 b0 	st.w	sp[1712],r8
8000919e:	30 08       	mov	r8,0
800091a0:	30 09       	mov	r9,0
800091a2:	50 a7       	stdsp	sp[0x28],r7
800091a4:	50 78       	stdsp	sp[0x1c],r8
800091a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800091aa:	3f f8       	mov	r8,-1
800091ac:	50 59       	stdsp	sp[0x14],r9
800091ae:	fb 43 06 88 	st.w	sp[1672],r3
800091b2:	fb 48 05 44 	st.w	sp[1348],r8
800091b6:	12 9c       	mov	r12,r9
800091b8:	50 69       	stdsp	sp[0x18],r9
800091ba:	50 d9       	stdsp	sp[0x34],r9
800091bc:	50 e9       	stdsp	sp[0x38],r9
800091be:	50 b9       	stdsp	sp[0x2c],r9
800091c0:	12 97       	mov	r7,r9
800091c2:	0a 94       	mov	r4,r5
800091c4:	40 a2       	lddsp	r2,sp[0x28]
800091c6:	32 5a       	mov	r10,37
800091c8:	30 08       	mov	r8,0
800091ca:	c0 28       	rjmp	800091ce <_vfprintf_r+0x126>
800091cc:	2f f2       	sub	r2,-1
800091ce:	05 89       	ld.ub	r9,r2[0x0]
800091d0:	f0 09 18 00 	cp.b	r9,r8
800091d4:	5f 1b       	srne	r11
800091d6:	f4 09 18 00 	cp.b	r9,r10
800091da:	5f 19       	srne	r9
800091dc:	f3 eb 00 0b 	and	r11,r9,r11
800091e0:	f0 0b 18 00 	cp.b	r11,r8
800091e4:	cf 41       	brne	800091cc <_vfprintf_r+0x124>
800091e6:	40 ab       	lddsp	r11,sp[0x28]
800091e8:	e4 0b 01 06 	sub	r6,r2,r11
800091ec:	c1 e0       	breq	80009228 <_vfprintf_r+0x180>
800091ee:	fa f8 06 90 	ld.w	r8,sp[1680]
800091f2:	0c 08       	add	r8,r6
800091f4:	87 0b       	st.w	r3[0x0],r11
800091f6:	fb 48 06 90 	st.w	sp[1680],r8
800091fa:	87 16       	st.w	r3[0x4],r6
800091fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009200:	2f f8       	sub	r8,-1
80009202:	fb 48 06 8c 	st.w	sp[1676],r8
80009206:	58 78       	cp.w	r8,7
80009208:	e0 89 00 04 	brgt	80009210 <_vfprintf_r+0x168>
8000920c:	2f 83       	sub	r3,-8
8000920e:	c0 a8       	rjmp	80009222 <_vfprintf_r+0x17a>
80009210:	fa ca f9 78 	sub	r10,sp,-1672
80009214:	02 9b       	mov	r11,r1
80009216:	08 9c       	mov	r12,r4
80009218:	c3 af       	rcall	8000908c <__sprint_r>
8000921a:	e0 81 0e c6 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000921e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009222:	40 ba       	lddsp	r10,sp[0x2c]
80009224:	0c 0a       	add	r10,r6
80009226:	50 ba       	stdsp	sp[0x2c],r10
80009228:	05 89       	ld.ub	r9,r2[0x0]
8000922a:	30 08       	mov	r8,0
8000922c:	f0 09 18 00 	cp.b	r9,r8
80009230:	e0 80 0e aa 	breq	8000af84 <_vfprintf_r+0x1edc>
80009234:	30 09       	mov	r9,0
80009236:	fb 68 06 bb 	st.b	sp[1723],r8
8000923a:	0e 96       	mov	r6,r7
8000923c:	e4 c8 ff ff 	sub	r8,r2,-1
80009240:	3f fe       	mov	lr,-1
80009242:	50 93       	stdsp	sp[0x24],r3
80009244:	50 41       	stdsp	sp[0x10],r1
80009246:	0e 93       	mov	r3,r7
80009248:	04 91       	mov	r1,r2
8000924a:	50 89       	stdsp	sp[0x20],r9
8000924c:	50 a8       	stdsp	sp[0x28],r8
8000924e:	50 2e       	stdsp	sp[0x8],lr
80009250:	50 39       	stdsp	sp[0xc],r9
80009252:	12 95       	mov	r5,r9
80009254:	12 90       	mov	r0,r9
80009256:	10 97       	mov	r7,r8
80009258:	08 92       	mov	r2,r4
8000925a:	c0 78       	rjmp	80009268 <_vfprintf_r+0x1c0>
8000925c:	3f fc       	mov	r12,-1
8000925e:	08 97       	mov	r7,r4
80009260:	50 2c       	stdsp	sp[0x8],r12
80009262:	c0 38       	rjmp	80009268 <_vfprintf_r+0x1c0>
80009264:	30 0b       	mov	r11,0
80009266:	50 3b       	stdsp	sp[0xc],r11
80009268:	0f 38       	ld.ub	r8,r7++
8000926a:	c0 28       	rjmp	8000926e <_vfprintf_r+0x1c6>
8000926c:	12 90       	mov	r0,r9
8000926e:	f0 c9 00 20 	sub	r9,r8,32
80009272:	e0 49 00 58 	cp.w	r9,88
80009276:	e0 8b 0a 30 	brhi	8000a6d6 <_vfprintf_r+0x162e>
8000927a:	fe ca a1 76 	sub	r10,pc,-24202
8000927e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80009282:	50 a7       	stdsp	sp[0x28],r7
80009284:	50 80       	stdsp	sp[0x20],r0
80009286:	0c 97       	mov	r7,r6
80009288:	04 94       	mov	r4,r2
8000928a:	06 96       	mov	r6,r3
8000928c:	02 92       	mov	r2,r1
8000928e:	fe c9 9f 4e 	sub	r9,pc,-24754
80009292:	40 93       	lddsp	r3,sp[0x24]
80009294:	10 90       	mov	r0,r8
80009296:	40 41       	lddsp	r1,sp[0x10]
80009298:	50 d9       	stdsp	sp[0x34],r9
8000929a:	e0 8f 08 8e 	bral	8000a3b6 <_vfprintf_r+0x130e>
8000929e:	30 08       	mov	r8,0
800092a0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800092a4:	f0 09 18 00 	cp.b	r9,r8
800092a8:	ce 01       	brne	80009268 <_vfprintf_r+0x1c0>
800092aa:	32 08       	mov	r8,32
800092ac:	c6 e8       	rjmp	80009388 <_vfprintf_r+0x2e0>
800092ae:	a1 a5       	sbr	r5,0x0
800092b0:	cd cb       	rjmp	80009268 <_vfprintf_r+0x1c0>
800092b2:	0f 89       	ld.ub	r9,r7[0x0]
800092b4:	f2 c8 00 30 	sub	r8,r9,48
800092b8:	58 98       	cp.w	r8,9
800092ba:	e0 8b 00 1d 	brhi	800092f4 <_vfprintf_r+0x24c>
800092be:	ee c8 ff ff 	sub	r8,r7,-1
800092c2:	30 0b       	mov	r11,0
800092c4:	23 09       	sub	r9,48
800092c6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800092ca:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800092ce:	11 39       	ld.ub	r9,r8++
800092d0:	f2 ca 00 30 	sub	r10,r9,48
800092d4:	58 9a       	cp.w	r10,9
800092d6:	fe 98 ff f7 	brls	800092c4 <_vfprintf_r+0x21c>
800092da:	e0 49 00 24 	cp.w	r9,36
800092de:	cc 31       	brne	80009264 <_vfprintf_r+0x1bc>
800092e0:	e0 4b 00 20 	cp.w	r11,32
800092e4:	e0 89 0e 60 	brgt	8000afa4 <_vfprintf_r+0x1efc>
800092e8:	20 1b       	sub	r11,1
800092ea:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092ee:	12 3b       	cp.w	r11,r9
800092f0:	c0 95       	brlt	80009302 <_vfprintf_r+0x25a>
800092f2:	c1 08       	rjmp	80009312 <_vfprintf_r+0x26a>
800092f4:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092f8:	ec ca ff ff 	sub	r10,r6,-1
800092fc:	12 36       	cp.w	r6,r9
800092fe:	c1 f5       	brlt	8000933c <_vfprintf_r+0x294>
80009300:	c2 68       	rjmp	8000934c <_vfprintf_r+0x2a4>
80009302:	fa ce f9 44 	sub	lr,sp,-1724
80009306:	10 97       	mov	r7,r8
80009308:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000930c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80009310:	c3 58       	rjmp	8000937a <_vfprintf_r+0x2d2>
80009312:	10 97       	mov	r7,r8
80009314:	fa c8 f9 50 	sub	r8,sp,-1712
80009318:	1a d8       	st.w	--sp,r8
8000931a:	fa c8 fa b8 	sub	r8,sp,-1352
8000931e:	1a d8       	st.w	--sp,r8
80009320:	fa c8 fb b4 	sub	r8,sp,-1100
80009324:	02 9a       	mov	r10,r1
80009326:	1a d8       	st.w	--sp,r8
80009328:	04 9c       	mov	r12,r2
8000932a:	fa c8 f9 40 	sub	r8,sp,-1728
8000932e:	fa c9 ff b4 	sub	r9,sp,-76
80009332:	fe b0 fd 23 	rcall	80008d78 <get_arg>
80009336:	2f dd       	sub	sp,-12
80009338:	78 00       	ld.w	r0,r12[0x0]
8000933a:	c2 08       	rjmp	8000937a <_vfprintf_r+0x2d2>
8000933c:	fa cc f9 44 	sub	r12,sp,-1724
80009340:	14 96       	mov	r6,r10
80009342:	f8 03 00 38 	add	r8,r12,r3<<0x3
80009346:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000934a:	c1 88       	rjmp	8000937a <_vfprintf_r+0x2d2>
8000934c:	41 08       	lddsp	r8,sp[0x40]
8000934e:	59 f9       	cp.w	r9,31
80009350:	e0 89 00 11 	brgt	80009372 <_vfprintf_r+0x2ca>
80009354:	f0 cb ff fc 	sub	r11,r8,-4
80009358:	51 0b       	stdsp	sp[0x40],r11
8000935a:	70 00       	ld.w	r0,r8[0x0]
8000935c:	fa cb f9 44 	sub	r11,sp,-1724
80009360:	f6 09 00 38 	add	r8,r11,r9<<0x3
80009364:	f1 40 fd 88 	st.w	r8[-632],r0
80009368:	2f f9       	sub	r9,-1
8000936a:	14 96       	mov	r6,r10
8000936c:	fb 49 06 b4 	st.w	sp[1716],r9
80009370:	c0 58       	rjmp	8000937a <_vfprintf_r+0x2d2>
80009372:	70 00       	ld.w	r0,r8[0x0]
80009374:	14 96       	mov	r6,r10
80009376:	2f c8       	sub	r8,-4
80009378:	51 08       	stdsp	sp[0x40],r8
8000937a:	58 00       	cp.w	r0,0
8000937c:	fe 94 ff 76 	brge	80009268 <_vfprintf_r+0x1c0>
80009380:	5c 30       	neg	r0
80009382:	a3 a5       	sbr	r5,0x2
80009384:	c7 2b       	rjmp	80009268 <_vfprintf_r+0x1c0>
80009386:	32 b8       	mov	r8,43
80009388:	fb 68 06 bb 	st.b	sp[1723],r8
8000938c:	c6 eb       	rjmp	80009268 <_vfprintf_r+0x1c0>
8000938e:	0f 38       	ld.ub	r8,r7++
80009390:	e0 48 00 2a 	cp.w	r8,42
80009394:	c0 30       	breq	8000939a <_vfprintf_r+0x2f2>
80009396:	30 09       	mov	r9,0
80009398:	c7 98       	rjmp	8000948a <_vfprintf_r+0x3e2>
8000939a:	0f 88       	ld.ub	r8,r7[0x0]
8000939c:	f0 c9 00 30 	sub	r9,r8,48
800093a0:	58 99       	cp.w	r9,9
800093a2:	e0 8b 00 1f 	brhi	800093e0 <_vfprintf_r+0x338>
800093a6:	ee c4 ff ff 	sub	r4,r7,-1
800093aa:	30 0b       	mov	r11,0
800093ac:	23 08       	sub	r8,48
800093ae:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800093b2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800093b6:	09 38       	ld.ub	r8,r4++
800093b8:	f0 c9 00 30 	sub	r9,r8,48
800093bc:	58 99       	cp.w	r9,9
800093be:	fe 98 ff f7 	brls	800093ac <_vfprintf_r+0x304>
800093c2:	e0 48 00 24 	cp.w	r8,36
800093c6:	fe 91 ff 4f 	brne	80009264 <_vfprintf_r+0x1bc>
800093ca:	e0 4b 00 20 	cp.w	r11,32
800093ce:	e0 89 0d eb 	brgt	8000afa4 <_vfprintf_r+0x1efc>
800093d2:	20 1b       	sub	r11,1
800093d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093d8:	10 3b       	cp.w	r11,r8
800093da:	c0 a5       	brlt	800093ee <_vfprintf_r+0x346>
800093dc:	c1 18       	rjmp	800093fe <_vfprintf_r+0x356>
800093de:	d7 03       	nop
800093e0:	fa fa 06 b4 	ld.w	r10,sp[1716]
800093e4:	ec c9 ff ff 	sub	r9,r6,-1
800093e8:	14 36       	cp.w	r6,r10
800093ea:	c1 f5       	brlt	80009428 <_vfprintf_r+0x380>
800093ec:	c2 88       	rjmp	8000943c <_vfprintf_r+0x394>
800093ee:	fa ca f9 44 	sub	r10,sp,-1724
800093f2:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800093f6:	f6 fb fd 88 	ld.w	r11,r11[-632]
800093fa:	50 2b       	stdsp	sp[0x8],r11
800093fc:	c3 c8       	rjmp	80009474 <_vfprintf_r+0x3cc>
800093fe:	fa c8 f9 50 	sub	r8,sp,-1712
80009402:	1a d8       	st.w	--sp,r8
80009404:	fa c8 fa b8 	sub	r8,sp,-1352
80009408:	1a d8       	st.w	--sp,r8
8000940a:	fa c8 fb b4 	sub	r8,sp,-1100
8000940e:	02 9a       	mov	r10,r1
80009410:	1a d8       	st.w	--sp,r8
80009412:	04 9c       	mov	r12,r2
80009414:	fa c8 f9 40 	sub	r8,sp,-1728
80009418:	fa c9 ff b4 	sub	r9,sp,-76
8000941c:	fe b0 fc ae 	rcall	80008d78 <get_arg>
80009420:	2f dd       	sub	sp,-12
80009422:	78 0c       	ld.w	r12,r12[0x0]
80009424:	50 2c       	stdsp	sp[0x8],r12
80009426:	c2 78       	rjmp	80009474 <_vfprintf_r+0x3cc>
80009428:	12 96       	mov	r6,r9
8000942a:	0e 94       	mov	r4,r7
8000942c:	fa c9 f9 44 	sub	r9,sp,-1724
80009430:	f2 03 00 38 	add	r8,r9,r3<<0x3
80009434:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80009438:	50 28       	stdsp	sp[0x8],r8
8000943a:	c1 d8       	rjmp	80009474 <_vfprintf_r+0x3cc>
8000943c:	41 08       	lddsp	r8,sp[0x40]
8000943e:	59 fa       	cp.w	r10,31
80009440:	e0 89 00 14 	brgt	80009468 <_vfprintf_r+0x3c0>
80009444:	f0 cb ff fc 	sub	r11,r8,-4
80009448:	70 08       	ld.w	r8,r8[0x0]
8000944a:	51 0b       	stdsp	sp[0x40],r11
8000944c:	50 28       	stdsp	sp[0x8],r8
8000944e:	fa c6 f9 44 	sub	r6,sp,-1724
80009452:	40 2e       	lddsp	lr,sp[0x8]
80009454:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80009458:	f1 4e fd 88 	st.w	r8[-632],lr
8000945c:	2f fa       	sub	r10,-1
8000945e:	0e 94       	mov	r4,r7
80009460:	fb 4a 06 b4 	st.w	sp[1716],r10
80009464:	12 96       	mov	r6,r9
80009466:	c0 78       	rjmp	80009474 <_vfprintf_r+0x3cc>
80009468:	70 0c       	ld.w	r12,r8[0x0]
8000946a:	0e 94       	mov	r4,r7
8000946c:	2f c8       	sub	r8,-4
8000946e:	50 2c       	stdsp	sp[0x8],r12
80009470:	12 96       	mov	r6,r9
80009472:	51 08       	stdsp	sp[0x40],r8
80009474:	40 2b       	lddsp	r11,sp[0x8]
80009476:	58 0b       	cp.w	r11,0
80009478:	fe 95 fe f2 	brlt	8000925c <_vfprintf_r+0x1b4>
8000947c:	08 97       	mov	r7,r4
8000947e:	cf 5a       	rjmp	80009268 <_vfprintf_r+0x1c0>
80009480:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009484:	0f 38       	ld.ub	r8,r7++
80009486:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000948a:	f0 ca 00 30 	sub	r10,r8,48
8000948e:	58 9a       	cp.w	r10,9
80009490:	fe 98 ff f8 	brls	80009480 <_vfprintf_r+0x3d8>
80009494:	3f fa       	mov	r10,-1
80009496:	f2 0a 0c 49 	max	r9,r9,r10
8000949a:	50 29       	stdsp	sp[0x8],r9
8000949c:	ce 9a       	rjmp	8000926e <_vfprintf_r+0x1c6>
8000949e:	a7 b5       	sbr	r5,0x7
800094a0:	ce 4a       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094a2:	30 09       	mov	r9,0
800094a4:	23 08       	sub	r8,48
800094a6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800094aa:	f0 09 00 19 	add	r9,r8,r9<<0x1
800094ae:	0f 38       	ld.ub	r8,r7++
800094b0:	f0 ca 00 30 	sub	r10,r8,48
800094b4:	58 9a       	cp.w	r10,9
800094b6:	fe 98 ff f7 	brls	800094a4 <_vfprintf_r+0x3fc>
800094ba:	e0 48 00 24 	cp.w	r8,36
800094be:	fe 91 fe d7 	brne	8000926c <_vfprintf_r+0x1c4>
800094c2:	e0 49 00 20 	cp.w	r9,32
800094c6:	e0 89 0d 6f 	brgt	8000afa4 <_vfprintf_r+0x1efc>
800094ca:	f2 c3 00 01 	sub	r3,r9,1
800094ce:	30 19       	mov	r9,1
800094d0:	50 39       	stdsp	sp[0xc],r9
800094d2:	cc ba       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094d4:	a3 b5       	sbr	r5,0x3
800094d6:	cc 9a       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094d8:	a7 a5       	sbr	r5,0x6
800094da:	cc 7a       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094dc:	0a 98       	mov	r8,r5
800094de:	a5 b5       	sbr	r5,0x5
800094e0:	a5 a8       	sbr	r8,0x4
800094e2:	0f 89       	ld.ub	r9,r7[0x0]
800094e4:	36 ce       	mov	lr,108
800094e6:	fc 09 18 00 	cp.b	r9,lr
800094ea:	f7 b7 00 ff 	subeq	r7,-1
800094ee:	f0 05 17 10 	movne	r5,r8
800094f2:	cb ba       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094f4:	a5 b5       	sbr	r5,0x5
800094f6:	cb 9a       	rjmp	80009268 <_vfprintf_r+0x1c0>
800094f8:	50 a7       	stdsp	sp[0x28],r7
800094fa:	50 80       	stdsp	sp[0x20],r0
800094fc:	0c 97       	mov	r7,r6
800094fe:	10 90       	mov	r0,r8
80009500:	06 96       	mov	r6,r3
80009502:	04 94       	mov	r4,r2
80009504:	40 93       	lddsp	r3,sp[0x24]
80009506:	02 92       	mov	r2,r1
80009508:	0e 99       	mov	r9,r7
8000950a:	40 41       	lddsp	r1,sp[0x10]
8000950c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009510:	40 3c       	lddsp	r12,sp[0xc]
80009512:	58 0c       	cp.w	r12,0
80009514:	c1 d0       	breq	8000954e <_vfprintf_r+0x4a6>
80009516:	10 36       	cp.w	r6,r8
80009518:	c0 64       	brge	80009524 <_vfprintf_r+0x47c>
8000951a:	fa cb f9 44 	sub	r11,sp,-1724
8000951e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009522:	c1 d8       	rjmp	8000955c <_vfprintf_r+0x4b4>
80009524:	fa c8 f9 50 	sub	r8,sp,-1712
80009528:	1a d8       	st.w	--sp,r8
8000952a:	fa c8 fa b8 	sub	r8,sp,-1352
8000952e:	1a d8       	st.w	--sp,r8
80009530:	fa c8 fb b4 	sub	r8,sp,-1100
80009534:	1a d8       	st.w	--sp,r8
80009536:	fa c8 f9 40 	sub	r8,sp,-1728
8000953a:	fa c9 ff b4 	sub	r9,sp,-76
8000953e:	04 9a       	mov	r10,r2
80009540:	0c 9b       	mov	r11,r6
80009542:	08 9c       	mov	r12,r4
80009544:	fe b0 fc 1a 	rcall	80008d78 <get_arg>
80009548:	2f dd       	sub	sp,-12
8000954a:	19 b8       	ld.ub	r8,r12[0x3]
8000954c:	c2 28       	rjmp	80009590 <_vfprintf_r+0x4e8>
8000954e:	2f f7       	sub	r7,-1
80009550:	10 39       	cp.w	r9,r8
80009552:	c0 84       	brge	80009562 <_vfprintf_r+0x4ba>
80009554:	fa ca f9 44 	sub	r10,sp,-1724
80009558:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000955c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80009560:	c1 88       	rjmp	80009590 <_vfprintf_r+0x4e8>
80009562:	41 09       	lddsp	r9,sp[0x40]
80009564:	59 f8       	cp.w	r8,31
80009566:	e0 89 00 12 	brgt	8000958a <_vfprintf_r+0x4e2>
8000956a:	f2 ca ff fc 	sub	r10,r9,-4
8000956e:	51 0a       	stdsp	sp[0x40],r10
80009570:	72 09       	ld.w	r9,r9[0x0]
80009572:	fa c6 f9 44 	sub	r6,sp,-1724
80009576:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000957a:	2f f8       	sub	r8,-1
8000957c:	f5 49 fd 88 	st.w	r10[-632],r9
80009580:	fb 48 06 b4 	st.w	sp[1716],r8
80009584:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80009588:	c0 48       	rjmp	80009590 <_vfprintf_r+0x4e8>
8000958a:	13 b8       	ld.ub	r8,r9[0x3]
8000958c:	2f c9       	sub	r9,-4
8000958e:	51 09       	stdsp	sp[0x40],r9
80009590:	fb 68 06 60 	st.b	sp[1632],r8
80009594:	30 0e       	mov	lr,0
80009596:	30 08       	mov	r8,0
80009598:	30 12       	mov	r2,1
8000959a:	fb 68 06 bb 	st.b	sp[1723],r8
8000959e:	50 2e       	stdsp	sp[0x8],lr
800095a0:	e0 8f 08 ad 	bral	8000a6fa <_vfprintf_r+0x1652>
800095a4:	50 a7       	stdsp	sp[0x28],r7
800095a6:	50 80       	stdsp	sp[0x20],r0
800095a8:	0c 97       	mov	r7,r6
800095aa:	04 94       	mov	r4,r2
800095ac:	06 96       	mov	r6,r3
800095ae:	02 92       	mov	r2,r1
800095b0:	40 93       	lddsp	r3,sp[0x24]
800095b2:	10 90       	mov	r0,r8
800095b4:	40 41       	lddsp	r1,sp[0x10]
800095b6:	a5 a5       	sbr	r5,0x4
800095b8:	c0 a8       	rjmp	800095cc <_vfprintf_r+0x524>
800095ba:	50 a7       	stdsp	sp[0x28],r7
800095bc:	50 80       	stdsp	sp[0x20],r0
800095be:	0c 97       	mov	r7,r6
800095c0:	04 94       	mov	r4,r2
800095c2:	06 96       	mov	r6,r3
800095c4:	02 92       	mov	r2,r1
800095c6:	40 93       	lddsp	r3,sp[0x24]
800095c8:	10 90       	mov	r0,r8
800095ca:	40 41       	lddsp	r1,sp[0x10]
800095cc:	ed b5 00 05 	bld	r5,0x5
800095d0:	c5 11       	brne	80009672 <_vfprintf_r+0x5ca>
800095d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095d6:	40 3c       	lddsp	r12,sp[0xc]
800095d8:	58 0c       	cp.w	r12,0
800095da:	c1 e0       	breq	80009616 <_vfprintf_r+0x56e>
800095dc:	10 36       	cp.w	r6,r8
800095de:	c0 64       	brge	800095ea <_vfprintf_r+0x542>
800095e0:	fa cb f9 44 	sub	r11,sp,-1724
800095e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095e8:	c2 08       	rjmp	80009628 <_vfprintf_r+0x580>
800095ea:	fa c8 f9 50 	sub	r8,sp,-1712
800095ee:	1a d8       	st.w	--sp,r8
800095f0:	fa c8 fa b8 	sub	r8,sp,-1352
800095f4:	0c 9b       	mov	r11,r6
800095f6:	1a d8       	st.w	--sp,r8
800095f8:	fa c8 fb b4 	sub	r8,sp,-1100
800095fc:	1a d8       	st.w	--sp,r8
800095fe:	fa c9 ff b4 	sub	r9,sp,-76
80009602:	fa c8 f9 40 	sub	r8,sp,-1728
80009606:	04 9a       	mov	r10,r2
80009608:	08 9c       	mov	r12,r4
8000960a:	fe b0 fb b7 	rcall	80008d78 <get_arg>
8000960e:	2f dd       	sub	sp,-12
80009610:	78 1b       	ld.w	r11,r12[0x4]
80009612:	78 09       	ld.w	r9,r12[0x0]
80009614:	c2 b8       	rjmp	8000966a <_vfprintf_r+0x5c2>
80009616:	ee ca ff ff 	sub	r10,r7,-1
8000961a:	10 37       	cp.w	r7,r8
8000961c:	c0 b4       	brge	80009632 <_vfprintf_r+0x58a>
8000961e:	fa c9 f9 44 	sub	r9,sp,-1724
80009622:	14 97       	mov	r7,r10
80009624:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009628:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000962c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009630:	c1 d8       	rjmp	8000966a <_vfprintf_r+0x5c2>
80009632:	41 09       	lddsp	r9,sp[0x40]
80009634:	59 f8       	cp.w	r8,31
80009636:	e0 89 00 14 	brgt	8000965e <_vfprintf_r+0x5b6>
8000963a:	f2 cb ff f8 	sub	r11,r9,-8
8000963e:	51 0b       	stdsp	sp[0x40],r11
80009640:	fa c6 f9 44 	sub	r6,sp,-1724
80009644:	72 1b       	ld.w	r11,r9[0x4]
80009646:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000964a:	72 09       	ld.w	r9,r9[0x0]
8000964c:	f9 4b fd 8c 	st.w	r12[-628],r11
80009650:	f9 49 fd 88 	st.w	r12[-632],r9
80009654:	2f f8       	sub	r8,-1
80009656:	14 97       	mov	r7,r10
80009658:	fb 48 06 b4 	st.w	sp[1716],r8
8000965c:	c0 78       	rjmp	8000966a <_vfprintf_r+0x5c2>
8000965e:	f2 c8 ff f8 	sub	r8,r9,-8
80009662:	72 1b       	ld.w	r11,r9[0x4]
80009664:	14 97       	mov	r7,r10
80009666:	51 08       	stdsp	sp[0x40],r8
80009668:	72 09       	ld.w	r9,r9[0x0]
8000966a:	16 98       	mov	r8,r11
8000966c:	fa e9 00 00 	st.d	sp[0],r8
80009670:	ca e8       	rjmp	800097cc <_vfprintf_r+0x724>
80009672:	ed b5 00 04 	bld	r5,0x4
80009676:	c1 71       	brne	800096a4 <_vfprintf_r+0x5fc>
80009678:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000967c:	40 3e       	lddsp	lr,sp[0xc]
8000967e:	58 0e       	cp.w	lr,0
80009680:	c0 80       	breq	80009690 <_vfprintf_r+0x5e8>
80009682:	10 36       	cp.w	r6,r8
80009684:	c6 94       	brge	80009756 <_vfprintf_r+0x6ae>
80009686:	fa cc f9 44 	sub	r12,sp,-1724
8000968a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000968e:	c8 28       	rjmp	80009792 <_vfprintf_r+0x6ea>
80009690:	ee ca ff ff 	sub	r10,r7,-1
80009694:	10 37       	cp.w	r7,r8
80009696:	e0 84 00 81 	brge	80009798 <_vfprintf_r+0x6f0>
8000969a:	fa cb f9 44 	sub	r11,sp,-1724
8000969e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096a2:	c7 78       	rjmp	80009790 <_vfprintf_r+0x6e8>
800096a4:	ed b5 00 06 	bld	r5,0x6
800096a8:	c4 b1       	brne	8000973e <_vfprintf_r+0x696>
800096aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096ae:	40 3c       	lddsp	r12,sp[0xc]
800096b0:	58 0c       	cp.w	r12,0
800096b2:	c1 d0       	breq	800096ec <_vfprintf_r+0x644>
800096b4:	10 36       	cp.w	r6,r8
800096b6:	c0 64       	brge	800096c2 <_vfprintf_r+0x61a>
800096b8:	fa cb f9 44 	sub	r11,sp,-1724
800096bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096c0:	c1 f8       	rjmp	800096fe <_vfprintf_r+0x656>
800096c2:	fa c8 f9 50 	sub	r8,sp,-1712
800096c6:	1a d8       	st.w	--sp,r8
800096c8:	fa c8 fa b8 	sub	r8,sp,-1352
800096cc:	1a d8       	st.w	--sp,r8
800096ce:	fa c8 fb b4 	sub	r8,sp,-1100
800096d2:	1a d8       	st.w	--sp,r8
800096d4:	fa c8 f9 40 	sub	r8,sp,-1728
800096d8:	fa c9 ff b4 	sub	r9,sp,-76
800096dc:	04 9a       	mov	r10,r2
800096de:	0c 9b       	mov	r11,r6
800096e0:	08 9c       	mov	r12,r4
800096e2:	fe b0 fb 4b 	rcall	80008d78 <get_arg>
800096e6:	2f dd       	sub	sp,-12
800096e8:	98 18       	ld.sh	r8,r12[0x2]
800096ea:	c2 68       	rjmp	80009736 <_vfprintf_r+0x68e>
800096ec:	ee ca ff ff 	sub	r10,r7,-1
800096f0:	10 37       	cp.w	r7,r8
800096f2:	c0 94       	brge	80009704 <_vfprintf_r+0x65c>
800096f4:	fa c9 f9 44 	sub	r9,sp,-1724
800096f8:	14 97       	mov	r7,r10
800096fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096fe:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009702:	c1 a8       	rjmp	80009736 <_vfprintf_r+0x68e>
80009704:	41 09       	lddsp	r9,sp[0x40]
80009706:	59 f8       	cp.w	r8,31
80009708:	e0 89 00 13 	brgt	8000972e <_vfprintf_r+0x686>
8000970c:	f2 cb ff fc 	sub	r11,r9,-4
80009710:	51 0b       	stdsp	sp[0x40],r11
80009712:	72 09       	ld.w	r9,r9[0x0]
80009714:	fa c6 f9 44 	sub	r6,sp,-1724
80009718:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000971c:	2f f8       	sub	r8,-1
8000971e:	f7 49 fd 88 	st.w	r11[-632],r9
80009722:	fb 48 06 b4 	st.w	sp[1716],r8
80009726:	14 97       	mov	r7,r10
80009728:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000972c:	c0 58       	rjmp	80009736 <_vfprintf_r+0x68e>
8000972e:	92 18       	ld.sh	r8,r9[0x2]
80009730:	14 97       	mov	r7,r10
80009732:	2f c9       	sub	r9,-4
80009734:	51 09       	stdsp	sp[0x40],r9
80009736:	50 18       	stdsp	sp[0x4],r8
80009738:	bf 58       	asr	r8,0x1f
8000973a:	50 08       	stdsp	sp[0x0],r8
8000973c:	c4 88       	rjmp	800097cc <_vfprintf_r+0x724>
8000973e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009742:	40 3c       	lddsp	r12,sp[0xc]
80009744:	58 0c       	cp.w	r12,0
80009746:	c1 d0       	breq	80009780 <_vfprintf_r+0x6d8>
80009748:	10 36       	cp.w	r6,r8
8000974a:	c0 64       	brge	80009756 <_vfprintf_r+0x6ae>
8000974c:	fa cb f9 44 	sub	r11,sp,-1724
80009750:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009754:	c1 f8       	rjmp	80009792 <_vfprintf_r+0x6ea>
80009756:	fa c8 f9 50 	sub	r8,sp,-1712
8000975a:	1a d8       	st.w	--sp,r8
8000975c:	fa c8 fa b8 	sub	r8,sp,-1352
80009760:	0c 9b       	mov	r11,r6
80009762:	1a d8       	st.w	--sp,r8
80009764:	fa c8 fb b4 	sub	r8,sp,-1100
80009768:	04 9a       	mov	r10,r2
8000976a:	1a d8       	st.w	--sp,r8
8000976c:	08 9c       	mov	r12,r4
8000976e:	fa c8 f9 40 	sub	r8,sp,-1728
80009772:	fa c9 ff b4 	sub	r9,sp,-76
80009776:	fe b0 fb 01 	rcall	80008d78 <get_arg>
8000977a:	2f dd       	sub	sp,-12
8000977c:	78 0b       	ld.w	r11,r12[0x0]
8000977e:	c2 48       	rjmp	800097c6 <_vfprintf_r+0x71e>
80009780:	ee ca ff ff 	sub	r10,r7,-1
80009784:	10 37       	cp.w	r7,r8
80009786:	c0 94       	brge	80009798 <_vfprintf_r+0x6f0>
80009788:	fa c9 f9 44 	sub	r9,sp,-1724
8000978c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009790:	14 97       	mov	r7,r10
80009792:	ec fb fd 88 	ld.w	r11,r6[-632]
80009796:	c1 88       	rjmp	800097c6 <_vfprintf_r+0x71e>
80009798:	41 09       	lddsp	r9,sp[0x40]
8000979a:	59 f8       	cp.w	r8,31
8000979c:	e0 89 00 11 	brgt	800097be <_vfprintf_r+0x716>
800097a0:	f2 cb ff fc 	sub	r11,r9,-4
800097a4:	51 0b       	stdsp	sp[0x40],r11
800097a6:	fa c6 f9 44 	sub	r6,sp,-1724
800097aa:	72 0b       	ld.w	r11,r9[0x0]
800097ac:	ec 08 00 39 	add	r9,r6,r8<<0x3
800097b0:	f3 4b fd 88 	st.w	r9[-632],r11
800097b4:	2f f8       	sub	r8,-1
800097b6:	14 97       	mov	r7,r10
800097b8:	fb 48 06 b4 	st.w	sp[1716],r8
800097bc:	c0 58       	rjmp	800097c6 <_vfprintf_r+0x71e>
800097be:	72 0b       	ld.w	r11,r9[0x0]
800097c0:	14 97       	mov	r7,r10
800097c2:	2f c9       	sub	r9,-4
800097c4:	51 09       	stdsp	sp[0x40],r9
800097c6:	50 1b       	stdsp	sp[0x4],r11
800097c8:	bf 5b       	asr	r11,0x1f
800097ca:	50 0b       	stdsp	sp[0x0],r11
800097cc:	fa ea 00 00 	ld.d	r10,sp[0]
800097d0:	58 0a       	cp.w	r10,0
800097d2:	5c 2b       	cpc	r11
800097d4:	c0 e4       	brge	800097f0 <_vfprintf_r+0x748>
800097d6:	30 08       	mov	r8,0
800097d8:	fa ea 00 00 	ld.d	r10,sp[0]
800097dc:	30 09       	mov	r9,0
800097de:	f0 0a 01 0a 	sub	r10,r8,r10
800097e2:	f2 0b 01 4b 	sbc	r11,r9,r11
800097e6:	32 d8       	mov	r8,45
800097e8:	fa eb 00 00 	st.d	sp[0],r10
800097ec:	fb 68 06 bb 	st.b	sp[1723],r8
800097f0:	30 18       	mov	r8,1
800097f2:	e0 8f 06 fa 	bral	8000a5e6 <_vfprintf_r+0x153e>
800097f6:	50 a7       	stdsp	sp[0x28],r7
800097f8:	50 80       	stdsp	sp[0x20],r0
800097fa:	0c 97       	mov	r7,r6
800097fc:	04 94       	mov	r4,r2
800097fe:	06 96       	mov	r6,r3
80009800:	02 92       	mov	r2,r1
80009802:	40 93       	lddsp	r3,sp[0x24]
80009804:	10 90       	mov	r0,r8
80009806:	40 41       	lddsp	r1,sp[0x10]
80009808:	0e 99       	mov	r9,r7
8000980a:	ed b5 00 03 	bld	r5,0x3
8000980e:	c4 11       	brne	80009890 <_vfprintf_r+0x7e8>
80009810:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009814:	40 3a       	lddsp	r10,sp[0xc]
80009816:	58 0a       	cp.w	r10,0
80009818:	c1 90       	breq	8000984a <_vfprintf_r+0x7a2>
8000981a:	10 36       	cp.w	r6,r8
8000981c:	c6 45       	brlt	800098e4 <_vfprintf_r+0x83c>
8000981e:	fa c8 f9 50 	sub	r8,sp,-1712
80009822:	1a d8       	st.w	--sp,r8
80009824:	fa c8 fa b8 	sub	r8,sp,-1352
80009828:	1a d8       	st.w	--sp,r8
8000982a:	fa c8 fb b4 	sub	r8,sp,-1100
8000982e:	0c 9b       	mov	r11,r6
80009830:	1a d8       	st.w	--sp,r8
80009832:	04 9a       	mov	r10,r2
80009834:	fa c8 f9 40 	sub	r8,sp,-1728
80009838:	fa c9 ff b4 	sub	r9,sp,-76
8000983c:	08 9c       	mov	r12,r4
8000983e:	fe b0 fa 9d 	rcall	80008d78 <get_arg>
80009842:	2f dd       	sub	sp,-12
80009844:	78 16       	ld.w	r6,r12[0x4]
80009846:	50 76       	stdsp	sp[0x1c],r6
80009848:	c4 88       	rjmp	800098d8 <_vfprintf_r+0x830>
8000984a:	2f f7       	sub	r7,-1
8000984c:	10 39       	cp.w	r9,r8
8000984e:	c0 c4       	brge	80009866 <_vfprintf_r+0x7be>
80009850:	fa ce f9 44 	sub	lr,sp,-1724
80009854:	fc 06 00 36 	add	r6,lr,r6<<0x3
80009858:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000985c:	50 7c       	stdsp	sp[0x1c],r12
8000985e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009862:	50 56       	stdsp	sp[0x14],r6
80009864:	c6 68       	rjmp	80009930 <_vfprintf_r+0x888>
80009866:	41 09       	lddsp	r9,sp[0x40]
80009868:	59 f8       	cp.w	r8,31
8000986a:	e0 89 00 10 	brgt	8000988a <_vfprintf_r+0x7e2>
8000986e:	f2 ca ff f8 	sub	r10,r9,-8
80009872:	72 1b       	ld.w	r11,r9[0x4]
80009874:	51 0a       	stdsp	sp[0x40],r10
80009876:	72 09       	ld.w	r9,r9[0x0]
80009878:	fa ca f9 44 	sub	r10,sp,-1724
8000987c:	50 7b       	stdsp	sp[0x1c],r11
8000987e:	50 59       	stdsp	sp[0x14],r9
80009880:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009884:	40 5b       	lddsp	r11,sp[0x14]
80009886:	40 7a       	lddsp	r10,sp[0x1c]
80009888:	c4 78       	rjmp	80009916 <_vfprintf_r+0x86e>
8000988a:	72 18       	ld.w	r8,r9[0x4]
8000988c:	50 78       	stdsp	sp[0x1c],r8
8000988e:	c4 c8       	rjmp	80009926 <_vfprintf_r+0x87e>
80009890:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009894:	40 3e       	lddsp	lr,sp[0xc]
80009896:	58 0e       	cp.w	lr,0
80009898:	c2 30       	breq	800098de <_vfprintf_r+0x836>
8000989a:	10 36       	cp.w	r6,r8
8000989c:	c0 94       	brge	800098ae <_vfprintf_r+0x806>
8000989e:	fa cc f9 44 	sub	r12,sp,-1724
800098a2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800098a6:	ec fb fd 8c 	ld.w	r11,r6[-628]
800098aa:	50 7b       	stdsp	sp[0x1c],r11
800098ac:	cd 9b       	rjmp	8000985e <_vfprintf_r+0x7b6>
800098ae:	fa c8 f9 50 	sub	r8,sp,-1712
800098b2:	1a d8       	st.w	--sp,r8
800098b4:	fa c8 fa b8 	sub	r8,sp,-1352
800098b8:	04 9a       	mov	r10,r2
800098ba:	1a d8       	st.w	--sp,r8
800098bc:	fa c8 fb b4 	sub	r8,sp,-1100
800098c0:	0c 9b       	mov	r11,r6
800098c2:	1a d8       	st.w	--sp,r8
800098c4:	08 9c       	mov	r12,r4
800098c6:	fa c8 f9 40 	sub	r8,sp,-1728
800098ca:	fa c9 ff b4 	sub	r9,sp,-76
800098ce:	fe b0 fa 55 	rcall	80008d78 <get_arg>
800098d2:	2f dd       	sub	sp,-12
800098d4:	78 1a       	ld.w	r10,r12[0x4]
800098d6:	50 7a       	stdsp	sp[0x1c],r10
800098d8:	78 0c       	ld.w	r12,r12[0x0]
800098da:	50 5c       	stdsp	sp[0x14],r12
800098dc:	c2 a8       	rjmp	80009930 <_vfprintf_r+0x888>
800098de:	2f f7       	sub	r7,-1
800098e0:	10 39       	cp.w	r9,r8
800098e2:	c0 94       	brge	800098f4 <_vfprintf_r+0x84c>
800098e4:	fa c9 f9 44 	sub	r9,sp,-1724
800098e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800098ec:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800098f0:	50 78       	stdsp	sp[0x1c],r8
800098f2:	cb 6b       	rjmp	8000985e <_vfprintf_r+0x7b6>
800098f4:	41 09       	lddsp	r9,sp[0x40]
800098f6:	59 f8       	cp.w	r8,31
800098f8:	e0 89 00 15 	brgt	80009922 <_vfprintf_r+0x87a>
800098fc:	f2 ca ff f8 	sub	r10,r9,-8
80009900:	72 16       	ld.w	r6,r9[0x4]
80009902:	72 09       	ld.w	r9,r9[0x0]
80009904:	51 0a       	stdsp	sp[0x40],r10
80009906:	50 59       	stdsp	sp[0x14],r9
80009908:	fa ce f9 44 	sub	lr,sp,-1724
8000990c:	50 76       	stdsp	sp[0x1c],r6
8000990e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009912:	40 5b       	lddsp	r11,sp[0x14]
80009914:	0c 9a       	mov	r10,r6
80009916:	f2 eb fd 88 	st.d	r9[-632],r10
8000991a:	2f f8       	sub	r8,-1
8000991c:	fb 48 06 b4 	st.w	sp[1716],r8
80009920:	c0 88       	rjmp	80009930 <_vfprintf_r+0x888>
80009922:	72 1c       	ld.w	r12,r9[0x4]
80009924:	50 7c       	stdsp	sp[0x1c],r12
80009926:	f2 c8 ff f8 	sub	r8,r9,-8
8000992a:	51 08       	stdsp	sp[0x40],r8
8000992c:	72 09       	ld.w	r9,r9[0x0]
8000992e:	50 59       	stdsp	sp[0x14],r9
80009930:	40 5b       	lddsp	r11,sp[0x14]
80009932:	40 7a       	lddsp	r10,sp[0x1c]
80009934:	e0 a0 19 54 	rcall	8000cbdc <__isinfd>
80009938:	18 96       	mov	r6,r12
8000993a:	c1 70       	breq	80009968 <_vfprintf_r+0x8c0>
8000993c:	30 08       	mov	r8,0
8000993e:	30 09       	mov	r9,0
80009940:	40 5b       	lddsp	r11,sp[0x14]
80009942:	40 7a       	lddsp	r10,sp[0x1c]
80009944:	e0 a0 1d b4 	rcall	8000d4ac <__avr32_f64_cmp_lt>
80009948:	c0 40       	breq	80009950 <_vfprintf_r+0x8a8>
8000994a:	32 d8       	mov	r8,45
8000994c:	fb 68 06 bb 	st.b	sp[1723],r8
80009950:	fe c8 a5 fc 	sub	r8,pc,-23044
80009954:	fe c6 a5 fc 	sub	r6,pc,-23044
80009958:	a7 d5       	cbr	r5,0x7
8000995a:	e0 40 00 47 	cp.w	r0,71
8000995e:	f0 06 17 a0 	movle	r6,r8
80009962:	30 32       	mov	r2,3
80009964:	e0 8f 06 ce 	bral	8000a700 <_vfprintf_r+0x1658>
80009968:	40 5b       	lddsp	r11,sp[0x14]
8000996a:	40 7a       	lddsp	r10,sp[0x1c]
8000996c:	e0 a0 19 4d 	rcall	8000cc06 <__isnand>
80009970:	c0 e0       	breq	8000998c <_vfprintf_r+0x8e4>
80009972:	50 26       	stdsp	sp[0x8],r6
80009974:	fe c8 a6 18 	sub	r8,pc,-23016
80009978:	fe c6 a6 18 	sub	r6,pc,-23016
8000997c:	a7 d5       	cbr	r5,0x7
8000997e:	e0 40 00 47 	cp.w	r0,71
80009982:	f0 06 17 a0 	movle	r6,r8
80009986:	30 32       	mov	r2,3
80009988:	e0 8f 06 c2 	bral	8000a70c <_vfprintf_r+0x1664>
8000998c:	40 2a       	lddsp	r10,sp[0x8]
8000998e:	5b fa       	cp.w	r10,-1
80009990:	c0 41       	brne	80009998 <_vfprintf_r+0x8f0>
80009992:	30 69       	mov	r9,6
80009994:	50 29       	stdsp	sp[0x8],r9
80009996:	c1 18       	rjmp	800099b8 <_vfprintf_r+0x910>
80009998:	e0 40 00 47 	cp.w	r0,71
8000999c:	5f 09       	sreq	r9
8000999e:	e0 40 00 67 	cp.w	r0,103
800099a2:	5f 08       	sreq	r8
800099a4:	f3 e8 10 08 	or	r8,r9,r8
800099a8:	f8 08 18 00 	cp.b	r8,r12
800099ac:	c0 60       	breq	800099b8 <_vfprintf_r+0x910>
800099ae:	40 28       	lddsp	r8,sp[0x8]
800099b0:	58 08       	cp.w	r8,0
800099b2:	f9 b8 00 01 	moveq	r8,1
800099b6:	50 28       	stdsp	sp[0x8],r8
800099b8:	40 78       	lddsp	r8,sp[0x1c]
800099ba:	40 59       	lddsp	r9,sp[0x14]
800099bc:	fa e9 06 94 	st.d	sp[1684],r8
800099c0:	a9 a5       	sbr	r5,0x8
800099c2:	fa f8 06 94 	ld.w	r8,sp[1684]
800099c6:	58 08       	cp.w	r8,0
800099c8:	c0 65       	brlt	800099d4 <_vfprintf_r+0x92c>
800099ca:	40 5e       	lddsp	lr,sp[0x14]
800099cc:	30 0c       	mov	r12,0
800099ce:	50 6e       	stdsp	sp[0x18],lr
800099d0:	50 9c       	stdsp	sp[0x24],r12
800099d2:	c0 78       	rjmp	800099e0 <_vfprintf_r+0x938>
800099d4:	40 5b       	lddsp	r11,sp[0x14]
800099d6:	32 da       	mov	r10,45
800099d8:	ee 1b 80 00 	eorh	r11,0x8000
800099dc:	50 9a       	stdsp	sp[0x24],r10
800099de:	50 6b       	stdsp	sp[0x18],r11
800099e0:	e0 40 00 46 	cp.w	r0,70
800099e4:	5f 09       	sreq	r9
800099e6:	e0 40 00 66 	cp.w	r0,102
800099ea:	5f 08       	sreq	r8
800099ec:	f3 e8 10 08 	or	r8,r9,r8
800099f0:	50 48       	stdsp	sp[0x10],r8
800099f2:	c0 40       	breq	800099fa <_vfprintf_r+0x952>
800099f4:	40 22       	lddsp	r2,sp[0x8]
800099f6:	30 39       	mov	r9,3
800099f8:	c1 08       	rjmp	80009a18 <_vfprintf_r+0x970>
800099fa:	e0 40 00 45 	cp.w	r0,69
800099fe:	5f 09       	sreq	r9
80009a00:	e0 40 00 65 	cp.w	r0,101
80009a04:	5f 08       	sreq	r8
80009a06:	40 22       	lddsp	r2,sp[0x8]
80009a08:	10 49       	or	r9,r8
80009a0a:	2f f2       	sub	r2,-1
80009a0c:	40 46       	lddsp	r6,sp[0x10]
80009a0e:	ec 09 18 00 	cp.b	r9,r6
80009a12:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009a16:	30 29       	mov	r9,2
80009a18:	fa c8 f9 5c 	sub	r8,sp,-1700
80009a1c:	1a d8       	st.w	--sp,r8
80009a1e:	fa c8 f9 54 	sub	r8,sp,-1708
80009a22:	1a d8       	st.w	--sp,r8
80009a24:	fa c8 f9 4c 	sub	r8,sp,-1716
80009a28:	08 9c       	mov	r12,r4
80009a2a:	1a d8       	st.w	--sp,r8
80009a2c:	04 98       	mov	r8,r2
80009a2e:	40 9b       	lddsp	r11,sp[0x24]
80009a30:	40 aa       	lddsp	r10,sp[0x28]
80009a32:	e0 a0 0b c3 	rcall	8000b1b8 <_dtoa_r>
80009a36:	e0 40 00 47 	cp.w	r0,71
80009a3a:	5f 19       	srne	r9
80009a3c:	e0 40 00 67 	cp.w	r0,103
80009a40:	5f 18       	srne	r8
80009a42:	18 96       	mov	r6,r12
80009a44:	2f dd       	sub	sp,-12
80009a46:	f3 e8 00 08 	and	r8,r9,r8
80009a4a:	c0 41       	brne	80009a52 <_vfprintf_r+0x9aa>
80009a4c:	ed b5 00 00 	bld	r5,0x0
80009a50:	c3 01       	brne	80009ab0 <_vfprintf_r+0xa08>
80009a52:	ec 02 00 0e 	add	lr,r6,r2
80009a56:	50 3e       	stdsp	sp[0xc],lr
80009a58:	40 4c       	lddsp	r12,sp[0x10]
80009a5a:	58 0c       	cp.w	r12,0
80009a5c:	c1 50       	breq	80009a86 <_vfprintf_r+0x9de>
80009a5e:	0d 89       	ld.ub	r9,r6[0x0]
80009a60:	33 08       	mov	r8,48
80009a62:	f0 09 18 00 	cp.b	r9,r8
80009a66:	c0 b1       	brne	80009a7c <_vfprintf_r+0x9d4>
80009a68:	30 08       	mov	r8,0
80009a6a:	30 09       	mov	r9,0
80009a6c:	40 6b       	lddsp	r11,sp[0x18]
80009a6e:	40 7a       	lddsp	r10,sp[0x1c]
80009a70:	e0 a0 1c d7 	rcall	8000d41e <__avr32_f64_cmp_eq>
80009a74:	fb b2 00 01 	rsubeq	r2,1
80009a78:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009a7c:	40 3b       	lddsp	r11,sp[0xc]
80009a7e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a82:	10 0b       	add	r11,r8
80009a84:	50 3b       	stdsp	sp[0xc],r11
80009a86:	40 6b       	lddsp	r11,sp[0x18]
80009a88:	30 08       	mov	r8,0
80009a8a:	30 09       	mov	r9,0
80009a8c:	40 7a       	lddsp	r10,sp[0x1c]
80009a8e:	e0 a0 1c c8 	rcall	8000d41e <__avr32_f64_cmp_eq>
80009a92:	c0 90       	breq	80009aa4 <_vfprintf_r+0x9fc>
80009a94:	40 3a       	lddsp	r10,sp[0xc]
80009a96:	fb 4a 06 a4 	st.w	sp[1700],r10
80009a9a:	c0 58       	rjmp	80009aa4 <_vfprintf_r+0x9fc>
80009a9c:	10 c9       	st.b	r8++,r9
80009a9e:	fb 48 06 a4 	st.w	sp[1700],r8
80009aa2:	c0 28       	rjmp	80009aa6 <_vfprintf_r+0x9fe>
80009aa4:	33 09       	mov	r9,48
80009aa6:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009aaa:	40 3e       	lddsp	lr,sp[0xc]
80009aac:	1c 38       	cp.w	r8,lr
80009aae:	cf 73       	brcs	80009a9c <_vfprintf_r+0x9f4>
80009ab0:	e0 40 00 47 	cp.w	r0,71
80009ab4:	5f 09       	sreq	r9
80009ab6:	e0 40 00 67 	cp.w	r0,103
80009aba:	5f 08       	sreq	r8
80009abc:	f3 e8 10 08 	or	r8,r9,r8
80009ac0:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009ac4:	0c 19       	sub	r9,r6
80009ac6:	50 69       	stdsp	sp[0x18],r9
80009ac8:	58 08       	cp.w	r8,0
80009aca:	c0 b0       	breq	80009ae0 <_vfprintf_r+0xa38>
80009acc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ad0:	5b d8       	cp.w	r8,-3
80009ad2:	c0 55       	brlt	80009adc <_vfprintf_r+0xa34>
80009ad4:	40 2c       	lddsp	r12,sp[0x8]
80009ad6:	18 38       	cp.w	r8,r12
80009ad8:	e0 8a 00 6a 	brle	80009bac <_vfprintf_r+0xb04>
80009adc:	20 20       	sub	r0,2
80009ade:	c0 58       	rjmp	80009ae8 <_vfprintf_r+0xa40>
80009ae0:	e0 40 00 65 	cp.w	r0,101
80009ae4:	e0 89 00 46 	brgt	80009b70 <_vfprintf_r+0xac8>
80009ae8:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009aec:	fb 60 06 9c 	st.b	sp[1692],r0
80009af0:	20 1b       	sub	r11,1
80009af2:	fb 4b 06 ac 	st.w	sp[1708],r11
80009af6:	c0 47       	brpl	80009afe <_vfprintf_r+0xa56>
80009af8:	5c 3b       	neg	r11
80009afa:	32 d8       	mov	r8,45
80009afc:	c0 28       	rjmp	80009b00 <_vfprintf_r+0xa58>
80009afe:	32 b8       	mov	r8,43
80009b00:	fb 68 06 9d 	st.b	sp[1693],r8
80009b04:	58 9b       	cp.w	r11,9
80009b06:	e0 8a 00 1d 	brle	80009b40 <_vfprintf_r+0xa98>
80009b0a:	fa c9 fa 35 	sub	r9,sp,-1483
80009b0e:	30 aa       	mov	r10,10
80009b10:	12 98       	mov	r8,r9
80009b12:	0e 9c       	mov	r12,r7
80009b14:	0c 92       	mov	r2,r6
80009b16:	f6 0a 0c 06 	divs	r6,r11,r10
80009b1a:	0e 9b       	mov	r11,r7
80009b1c:	2d 0b       	sub	r11,-48
80009b1e:	10 fb       	st.b	--r8,r11
80009b20:	0c 9b       	mov	r11,r6
80009b22:	58 96       	cp.w	r6,9
80009b24:	fe 99 ff f9 	brgt	80009b16 <_vfprintf_r+0xa6e>
80009b28:	2d 0b       	sub	r11,-48
80009b2a:	18 97       	mov	r7,r12
80009b2c:	04 96       	mov	r6,r2
80009b2e:	10 fb       	st.b	--r8,r11
80009b30:	fa ca f9 62 	sub	r10,sp,-1694
80009b34:	c0 38       	rjmp	80009b3a <_vfprintf_r+0xa92>
80009b36:	11 3b       	ld.ub	r11,r8++
80009b38:	14 cb       	st.b	r10++,r11
80009b3a:	12 38       	cp.w	r8,r9
80009b3c:	cf d3       	brcs	80009b36 <_vfprintf_r+0xa8e>
80009b3e:	c0 98       	rjmp	80009b50 <_vfprintf_r+0xaa8>
80009b40:	2d 0b       	sub	r11,-48
80009b42:	33 08       	mov	r8,48
80009b44:	fb 6b 06 9f 	st.b	sp[1695],r11
80009b48:	fb 68 06 9e 	st.b	sp[1694],r8
80009b4c:	fa ca f9 60 	sub	r10,sp,-1696
80009b50:	fa c8 f9 64 	sub	r8,sp,-1692
80009b54:	f4 08 01 08 	sub	r8,r10,r8
80009b58:	50 e8       	stdsp	sp[0x38],r8
80009b5a:	10 92       	mov	r2,r8
80009b5c:	40 6b       	lddsp	r11,sp[0x18]
80009b5e:	16 02       	add	r2,r11
80009b60:	58 1b       	cp.w	r11,1
80009b62:	e0 89 00 05 	brgt	80009b6c <_vfprintf_r+0xac4>
80009b66:	ed b5 00 00 	bld	r5,0x0
80009b6a:	c3 51       	brne	80009bd4 <_vfprintf_r+0xb2c>
80009b6c:	2f f2       	sub	r2,-1
80009b6e:	c3 38       	rjmp	80009bd4 <_vfprintf_r+0xb2c>
80009b70:	e0 40 00 66 	cp.w	r0,102
80009b74:	c1 c1       	brne	80009bac <_vfprintf_r+0xb04>
80009b76:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b7a:	58 02       	cp.w	r2,0
80009b7c:	e0 8a 00 0c 	brle	80009b94 <_vfprintf_r+0xaec>
80009b80:	40 2a       	lddsp	r10,sp[0x8]
80009b82:	58 0a       	cp.w	r10,0
80009b84:	c0 41       	brne	80009b8c <_vfprintf_r+0xae4>
80009b86:	ed b5 00 00 	bld	r5,0x0
80009b8a:	c2 51       	brne	80009bd4 <_vfprintf_r+0xb2c>
80009b8c:	2f f2       	sub	r2,-1
80009b8e:	40 29       	lddsp	r9,sp[0x8]
80009b90:	12 02       	add	r2,r9
80009b92:	c0 b8       	rjmp	80009ba8 <_vfprintf_r+0xb00>
80009b94:	40 28       	lddsp	r8,sp[0x8]
80009b96:	58 08       	cp.w	r8,0
80009b98:	c0 61       	brne	80009ba4 <_vfprintf_r+0xafc>
80009b9a:	ed b5 00 00 	bld	r5,0x0
80009b9e:	c0 30       	breq	80009ba4 <_vfprintf_r+0xafc>
80009ba0:	30 12       	mov	r2,1
80009ba2:	c1 98       	rjmp	80009bd4 <_vfprintf_r+0xb2c>
80009ba4:	40 22       	lddsp	r2,sp[0x8]
80009ba6:	2f e2       	sub	r2,-2
80009ba8:	36 60       	mov	r0,102
80009baa:	c1 58       	rjmp	80009bd4 <_vfprintf_r+0xb2c>
80009bac:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bb0:	40 6e       	lddsp	lr,sp[0x18]
80009bb2:	1c 32       	cp.w	r2,lr
80009bb4:	c0 65       	brlt	80009bc0 <_vfprintf_r+0xb18>
80009bb6:	ed b5 00 00 	bld	r5,0x0
80009bba:	f7 b2 00 ff 	subeq	r2,-1
80009bbe:	c0 a8       	rjmp	80009bd2 <_vfprintf_r+0xb2a>
80009bc0:	e4 08 11 02 	rsub	r8,r2,2
80009bc4:	40 6c       	lddsp	r12,sp[0x18]
80009bc6:	58 02       	cp.w	r2,0
80009bc8:	f0 02 17 a0 	movle	r2,r8
80009bcc:	f9 b2 09 01 	movgt	r2,1
80009bd0:	18 02       	add	r2,r12
80009bd2:	36 70       	mov	r0,103
80009bd4:	40 9b       	lddsp	r11,sp[0x24]
80009bd6:	58 0b       	cp.w	r11,0
80009bd8:	e0 80 05 94 	breq	8000a700 <_vfprintf_r+0x1658>
80009bdc:	32 d8       	mov	r8,45
80009bde:	fb 68 06 bb 	st.b	sp[1723],r8
80009be2:	e0 8f 05 93 	bral	8000a708 <_vfprintf_r+0x1660>
80009be6:	50 a7       	stdsp	sp[0x28],r7
80009be8:	04 94       	mov	r4,r2
80009bea:	0c 97       	mov	r7,r6
80009bec:	02 92       	mov	r2,r1
80009bee:	06 96       	mov	r6,r3
80009bf0:	40 41       	lddsp	r1,sp[0x10]
80009bf2:	40 93       	lddsp	r3,sp[0x24]
80009bf4:	0e 99       	mov	r9,r7
80009bf6:	ed b5 00 05 	bld	r5,0x5
80009bfa:	c4 81       	brne	80009c8a <_vfprintf_r+0xbe2>
80009bfc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c00:	40 3e       	lddsp	lr,sp[0xc]
80009c02:	58 0e       	cp.w	lr,0
80009c04:	c1 d0       	breq	80009c3e <_vfprintf_r+0xb96>
80009c06:	10 36       	cp.w	r6,r8
80009c08:	c0 64       	brge	80009c14 <_vfprintf_r+0xb6c>
80009c0a:	fa cc f9 44 	sub	r12,sp,-1724
80009c0e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009c12:	c1 d8       	rjmp	80009c4c <_vfprintf_r+0xba4>
80009c14:	fa c8 f9 50 	sub	r8,sp,-1712
80009c18:	1a d8       	st.w	--sp,r8
80009c1a:	fa c8 fa b8 	sub	r8,sp,-1352
80009c1e:	04 9a       	mov	r10,r2
80009c20:	1a d8       	st.w	--sp,r8
80009c22:	fa c8 fb b4 	sub	r8,sp,-1100
80009c26:	0c 9b       	mov	r11,r6
80009c28:	1a d8       	st.w	--sp,r8
80009c2a:	08 9c       	mov	r12,r4
80009c2c:	fa c8 f9 40 	sub	r8,sp,-1728
80009c30:	fa c9 ff b4 	sub	r9,sp,-76
80009c34:	fe b0 f8 a2 	rcall	80008d78 <get_arg>
80009c38:	2f dd       	sub	sp,-12
80009c3a:	78 0a       	ld.w	r10,r12[0x0]
80009c3c:	c2 08       	rjmp	80009c7c <_vfprintf_r+0xbd4>
80009c3e:	2f f7       	sub	r7,-1
80009c40:	10 39       	cp.w	r9,r8
80009c42:	c0 84       	brge	80009c52 <_vfprintf_r+0xbaa>
80009c44:	fa cb f9 44 	sub	r11,sp,-1724
80009c48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c4c:	ec fa fd 88 	ld.w	r10,r6[-632]
80009c50:	c1 68       	rjmp	80009c7c <_vfprintf_r+0xbd4>
80009c52:	41 09       	lddsp	r9,sp[0x40]
80009c54:	59 f8       	cp.w	r8,31
80009c56:	e0 89 00 10 	brgt	80009c76 <_vfprintf_r+0xbce>
80009c5a:	f2 ca ff fc 	sub	r10,r9,-4
80009c5e:	51 0a       	stdsp	sp[0x40],r10
80009c60:	fa c6 f9 44 	sub	r6,sp,-1724
80009c64:	72 0a       	ld.w	r10,r9[0x0]
80009c66:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c6a:	f3 4a fd 88 	st.w	r9[-632],r10
80009c6e:	2f f8       	sub	r8,-1
80009c70:	fb 48 06 b4 	st.w	sp[1716],r8
80009c74:	c0 48       	rjmp	80009c7c <_vfprintf_r+0xbd4>
80009c76:	72 0a       	ld.w	r10,r9[0x0]
80009c78:	2f c9       	sub	r9,-4
80009c7a:	51 09       	stdsp	sp[0x40],r9
80009c7c:	40 be       	lddsp	lr,sp[0x2c]
80009c7e:	1c 98       	mov	r8,lr
80009c80:	95 1e       	st.w	r10[0x4],lr
80009c82:	bf 58       	asr	r8,0x1f
80009c84:	95 08       	st.w	r10[0x0],r8
80009c86:	fe 9f fa 9f 	bral	800091c4 <_vfprintf_r+0x11c>
80009c8a:	ed b5 00 04 	bld	r5,0x4
80009c8e:	c4 80       	breq	80009d1e <_vfprintf_r+0xc76>
80009c90:	e2 15 00 40 	andl	r5,0x40,COH
80009c94:	c4 50       	breq	80009d1e <_vfprintf_r+0xc76>
80009c96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c9a:	40 3c       	lddsp	r12,sp[0xc]
80009c9c:	58 0c       	cp.w	r12,0
80009c9e:	c1 d0       	breq	80009cd8 <_vfprintf_r+0xc30>
80009ca0:	10 36       	cp.w	r6,r8
80009ca2:	c0 64       	brge	80009cae <_vfprintf_r+0xc06>
80009ca4:	fa cb f9 44 	sub	r11,sp,-1724
80009ca8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009cac:	c1 d8       	rjmp	80009ce6 <_vfprintf_r+0xc3e>
80009cae:	fa c8 f9 50 	sub	r8,sp,-1712
80009cb2:	1a d8       	st.w	--sp,r8
80009cb4:	fa c8 fa b8 	sub	r8,sp,-1352
80009cb8:	04 9a       	mov	r10,r2
80009cba:	1a d8       	st.w	--sp,r8
80009cbc:	fa c8 fb b4 	sub	r8,sp,-1100
80009cc0:	0c 9b       	mov	r11,r6
80009cc2:	1a d8       	st.w	--sp,r8
80009cc4:	08 9c       	mov	r12,r4
80009cc6:	fa c8 f9 40 	sub	r8,sp,-1728
80009cca:	fa c9 ff b4 	sub	r9,sp,-76
80009cce:	fe b0 f8 55 	rcall	80008d78 <get_arg>
80009cd2:	2f dd       	sub	sp,-12
80009cd4:	78 0a       	ld.w	r10,r12[0x0]
80009cd6:	c2 08       	rjmp	80009d16 <_vfprintf_r+0xc6e>
80009cd8:	2f f7       	sub	r7,-1
80009cda:	10 39       	cp.w	r9,r8
80009cdc:	c0 84       	brge	80009cec <_vfprintf_r+0xc44>
80009cde:	fa ca f9 44 	sub	r10,sp,-1724
80009ce2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009ce6:	ec fa fd 88 	ld.w	r10,r6[-632]
80009cea:	c1 68       	rjmp	80009d16 <_vfprintf_r+0xc6e>
80009cec:	41 09       	lddsp	r9,sp[0x40]
80009cee:	59 f8       	cp.w	r8,31
80009cf0:	e0 89 00 10 	brgt	80009d10 <_vfprintf_r+0xc68>
80009cf4:	f2 ca ff fc 	sub	r10,r9,-4
80009cf8:	51 0a       	stdsp	sp[0x40],r10
80009cfa:	fa c6 f9 44 	sub	r6,sp,-1724
80009cfe:	72 0a       	ld.w	r10,r9[0x0]
80009d00:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d04:	f3 4a fd 88 	st.w	r9[-632],r10
80009d08:	2f f8       	sub	r8,-1
80009d0a:	fb 48 06 b4 	st.w	sp[1716],r8
80009d0e:	c0 48       	rjmp	80009d16 <_vfprintf_r+0xc6e>
80009d10:	72 0a       	ld.w	r10,r9[0x0]
80009d12:	2f c9       	sub	r9,-4
80009d14:	51 09       	stdsp	sp[0x40],r9
80009d16:	40 be       	lddsp	lr,sp[0x2c]
80009d18:	b4 0e       	st.h	r10[0x0],lr
80009d1a:	fe 9f fa 55 	bral	800091c4 <_vfprintf_r+0x11c>
80009d1e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d22:	40 3c       	lddsp	r12,sp[0xc]
80009d24:	58 0c       	cp.w	r12,0
80009d26:	c1 d0       	breq	80009d60 <_vfprintf_r+0xcb8>
80009d28:	10 36       	cp.w	r6,r8
80009d2a:	c0 64       	brge	80009d36 <_vfprintf_r+0xc8e>
80009d2c:	fa cb f9 44 	sub	r11,sp,-1724
80009d30:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d34:	c1 d8       	rjmp	80009d6e <_vfprintf_r+0xcc6>
80009d36:	fa c8 f9 50 	sub	r8,sp,-1712
80009d3a:	1a d8       	st.w	--sp,r8
80009d3c:	fa c8 fa b8 	sub	r8,sp,-1352
80009d40:	04 9a       	mov	r10,r2
80009d42:	1a d8       	st.w	--sp,r8
80009d44:	fa c8 fb b4 	sub	r8,sp,-1100
80009d48:	0c 9b       	mov	r11,r6
80009d4a:	1a d8       	st.w	--sp,r8
80009d4c:	08 9c       	mov	r12,r4
80009d4e:	fa c8 f9 40 	sub	r8,sp,-1728
80009d52:	fa c9 ff b4 	sub	r9,sp,-76
80009d56:	fe b0 f8 11 	rcall	80008d78 <get_arg>
80009d5a:	2f dd       	sub	sp,-12
80009d5c:	78 0a       	ld.w	r10,r12[0x0]
80009d5e:	c2 08       	rjmp	80009d9e <_vfprintf_r+0xcf6>
80009d60:	2f f7       	sub	r7,-1
80009d62:	10 39       	cp.w	r9,r8
80009d64:	c0 84       	brge	80009d74 <_vfprintf_r+0xccc>
80009d66:	fa ca f9 44 	sub	r10,sp,-1724
80009d6a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009d6e:	ec fa fd 88 	ld.w	r10,r6[-632]
80009d72:	c1 68       	rjmp	80009d9e <_vfprintf_r+0xcf6>
80009d74:	41 09       	lddsp	r9,sp[0x40]
80009d76:	59 f8       	cp.w	r8,31
80009d78:	e0 89 00 10 	brgt	80009d98 <_vfprintf_r+0xcf0>
80009d7c:	f2 ca ff fc 	sub	r10,r9,-4
80009d80:	51 0a       	stdsp	sp[0x40],r10
80009d82:	fa c6 f9 44 	sub	r6,sp,-1724
80009d86:	72 0a       	ld.w	r10,r9[0x0]
80009d88:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d8c:	f3 4a fd 88 	st.w	r9[-632],r10
80009d90:	2f f8       	sub	r8,-1
80009d92:	fb 48 06 b4 	st.w	sp[1716],r8
80009d96:	c0 48       	rjmp	80009d9e <_vfprintf_r+0xcf6>
80009d98:	72 0a       	ld.w	r10,r9[0x0]
80009d9a:	2f c9       	sub	r9,-4
80009d9c:	51 09       	stdsp	sp[0x40],r9
80009d9e:	40 be       	lddsp	lr,sp[0x2c]
80009da0:	95 0e       	st.w	r10[0x0],lr
80009da2:	fe 9f fa 11 	bral	800091c4 <_vfprintf_r+0x11c>
80009da6:	50 a7       	stdsp	sp[0x28],r7
80009da8:	50 80       	stdsp	sp[0x20],r0
80009daa:	0c 97       	mov	r7,r6
80009dac:	04 94       	mov	r4,r2
80009dae:	06 96       	mov	r6,r3
80009db0:	02 92       	mov	r2,r1
80009db2:	40 93       	lddsp	r3,sp[0x24]
80009db4:	10 90       	mov	r0,r8
80009db6:	40 41       	lddsp	r1,sp[0x10]
80009db8:	a5 a5       	sbr	r5,0x4
80009dba:	c0 a8       	rjmp	80009dce <_vfprintf_r+0xd26>
80009dbc:	50 a7       	stdsp	sp[0x28],r7
80009dbe:	50 80       	stdsp	sp[0x20],r0
80009dc0:	0c 97       	mov	r7,r6
80009dc2:	04 94       	mov	r4,r2
80009dc4:	06 96       	mov	r6,r3
80009dc6:	02 92       	mov	r2,r1
80009dc8:	40 93       	lddsp	r3,sp[0x24]
80009dca:	10 90       	mov	r0,r8
80009dcc:	40 41       	lddsp	r1,sp[0x10]
80009dce:	ed b5 00 05 	bld	r5,0x5
80009dd2:	c5 d1       	brne	80009e8c <_vfprintf_r+0xde4>
80009dd4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009dd8:	40 3c       	lddsp	r12,sp[0xc]
80009dda:	58 0c       	cp.w	r12,0
80009ddc:	c2 60       	breq	80009e28 <_vfprintf_r+0xd80>
80009dde:	10 36       	cp.w	r6,r8
80009de0:	c0 a4       	brge	80009df4 <_vfprintf_r+0xd4c>
80009de2:	fa cb f9 44 	sub	r11,sp,-1724
80009de6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009dea:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009dee:	fa e9 00 00 	st.d	sp[0],r8
80009df2:	c1 88       	rjmp	80009e22 <_vfprintf_r+0xd7a>
80009df4:	fa c8 f9 50 	sub	r8,sp,-1712
80009df8:	1a d8       	st.w	--sp,r8
80009dfa:	fa c8 fa b8 	sub	r8,sp,-1352
80009dfe:	04 9a       	mov	r10,r2
80009e00:	1a d8       	st.w	--sp,r8
80009e02:	0c 9b       	mov	r11,r6
80009e04:	fa c8 fb b4 	sub	r8,sp,-1100
80009e08:	08 9c       	mov	r12,r4
80009e0a:	1a d8       	st.w	--sp,r8
80009e0c:	fa c8 f9 40 	sub	r8,sp,-1728
80009e10:	fa c9 ff b4 	sub	r9,sp,-76
80009e14:	fe b0 f7 b2 	rcall	80008d78 <get_arg>
80009e18:	2f dd       	sub	sp,-12
80009e1a:	f8 ea 00 00 	ld.d	r10,r12[0]
80009e1e:	fa eb 00 00 	st.d	sp[0],r10
80009e22:	30 08       	mov	r8,0
80009e24:	e0 8f 03 de 	bral	8000a5e0 <_vfprintf_r+0x1538>
80009e28:	ee ca ff ff 	sub	r10,r7,-1
80009e2c:	10 37       	cp.w	r7,r8
80009e2e:	c0 b4       	brge	80009e44 <_vfprintf_r+0xd9c>
80009e30:	fa c9 f9 44 	sub	r9,sp,-1724
80009e34:	14 97       	mov	r7,r10
80009e36:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e3a:	ec ea fd 88 	ld.d	r10,r6[-632]
80009e3e:	fa eb 00 00 	st.d	sp[0],r10
80009e42:	c1 88       	rjmp	80009e72 <_vfprintf_r+0xdca>
80009e44:	41 09       	lddsp	r9,sp[0x40]
80009e46:	59 f8       	cp.w	r8,31
80009e48:	e0 89 00 18 	brgt	80009e78 <_vfprintf_r+0xdd0>
80009e4c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e50:	f2 cb ff f8 	sub	r11,r9,-8
80009e54:	fa e7 00 00 	st.d	sp[0],r6
80009e58:	51 0b       	stdsp	sp[0x40],r11
80009e5a:	fa c6 f9 44 	sub	r6,sp,-1724
80009e5e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e62:	fa e6 00 00 	ld.d	r6,sp[0]
80009e66:	f2 e7 fd 88 	st.d	r9[-632],r6
80009e6a:	2f f8       	sub	r8,-1
80009e6c:	14 97       	mov	r7,r10
80009e6e:	fb 48 06 b4 	st.w	sp[1716],r8
80009e72:	40 38       	lddsp	r8,sp[0xc]
80009e74:	e0 8f 03 b6 	bral	8000a5e0 <_vfprintf_r+0x1538>
80009e78:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e7c:	40 38       	lddsp	r8,sp[0xc]
80009e7e:	fa e7 00 00 	st.d	sp[0],r6
80009e82:	2f 89       	sub	r9,-8
80009e84:	14 97       	mov	r7,r10
80009e86:	51 09       	stdsp	sp[0x40],r9
80009e88:	e0 8f 03 ac 	bral	8000a5e0 <_vfprintf_r+0x1538>
80009e8c:	ed b5 00 04 	bld	r5,0x4
80009e90:	c1 61       	brne	80009ebc <_vfprintf_r+0xe14>
80009e92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e96:	40 3e       	lddsp	lr,sp[0xc]
80009e98:	58 0e       	cp.w	lr,0
80009e9a:	c0 80       	breq	80009eaa <_vfprintf_r+0xe02>
80009e9c:	10 36       	cp.w	r6,r8
80009e9e:	c6 74       	brge	80009f6c <_vfprintf_r+0xec4>
80009ea0:	fa cc f9 44 	sub	r12,sp,-1724
80009ea4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009ea8:	c8 08       	rjmp	80009fa8 <_vfprintf_r+0xf00>
80009eaa:	ee ca ff ff 	sub	r10,r7,-1
80009eae:	10 37       	cp.w	r7,r8
80009eb0:	c7 f4       	brge	80009fae <_vfprintf_r+0xf06>
80009eb2:	fa cb f9 44 	sub	r11,sp,-1724
80009eb6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009eba:	c7 68       	rjmp	80009fa6 <_vfprintf_r+0xefe>
80009ebc:	ed b5 00 06 	bld	r5,0x6
80009ec0:	c4 a1       	brne	80009f54 <_vfprintf_r+0xeac>
80009ec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ec6:	40 3c       	lddsp	r12,sp[0xc]
80009ec8:	58 0c       	cp.w	r12,0
80009eca:	c1 d0       	breq	80009f04 <_vfprintf_r+0xe5c>
80009ecc:	10 36       	cp.w	r6,r8
80009ece:	c0 64       	brge	80009eda <_vfprintf_r+0xe32>
80009ed0:	fa cb f9 44 	sub	r11,sp,-1724
80009ed4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ed8:	c1 f8       	rjmp	80009f16 <_vfprintf_r+0xe6e>
80009eda:	fa c8 f9 50 	sub	r8,sp,-1712
80009ede:	1a d8       	st.w	--sp,r8
80009ee0:	fa c8 fa b8 	sub	r8,sp,-1352
80009ee4:	1a d8       	st.w	--sp,r8
80009ee6:	fa c8 fb b4 	sub	r8,sp,-1100
80009eea:	1a d8       	st.w	--sp,r8
80009eec:	fa c8 f9 40 	sub	r8,sp,-1728
80009ef0:	fa c9 ff b4 	sub	r9,sp,-76
80009ef4:	04 9a       	mov	r10,r2
80009ef6:	0c 9b       	mov	r11,r6
80009ef8:	08 9c       	mov	r12,r4
80009efa:	fe b0 f7 3f 	rcall	80008d78 <get_arg>
80009efe:	2f dd       	sub	sp,-12
80009f00:	98 18       	ld.sh	r8,r12[0x2]
80009f02:	c2 68       	rjmp	80009f4e <_vfprintf_r+0xea6>
80009f04:	ee ca ff ff 	sub	r10,r7,-1
80009f08:	10 37       	cp.w	r7,r8
80009f0a:	c0 94       	brge	80009f1c <_vfprintf_r+0xe74>
80009f0c:	fa c9 f9 44 	sub	r9,sp,-1724
80009f10:	14 97       	mov	r7,r10
80009f12:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f16:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009f1a:	c1 a8       	rjmp	80009f4e <_vfprintf_r+0xea6>
80009f1c:	41 09       	lddsp	r9,sp[0x40]
80009f1e:	59 f8       	cp.w	r8,31
80009f20:	e0 89 00 13 	brgt	80009f46 <_vfprintf_r+0xe9e>
80009f24:	f2 cb ff fc 	sub	r11,r9,-4
80009f28:	51 0b       	stdsp	sp[0x40],r11
80009f2a:	72 09       	ld.w	r9,r9[0x0]
80009f2c:	fa c6 f9 44 	sub	r6,sp,-1724
80009f30:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009f34:	2f f8       	sub	r8,-1
80009f36:	f7 49 fd 88 	st.w	r11[-632],r9
80009f3a:	fb 48 06 b4 	st.w	sp[1716],r8
80009f3e:	14 97       	mov	r7,r10
80009f40:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009f44:	c0 58       	rjmp	80009f4e <_vfprintf_r+0xea6>
80009f46:	92 18       	ld.sh	r8,r9[0x2]
80009f48:	14 97       	mov	r7,r10
80009f4a:	2f c9       	sub	r9,-4
80009f4c:	51 09       	stdsp	sp[0x40],r9
80009f4e:	5c 78       	castu.h	r8
80009f50:	50 18       	stdsp	sp[0x4],r8
80009f52:	c4 68       	rjmp	80009fde <_vfprintf_r+0xf36>
80009f54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f58:	40 3c       	lddsp	r12,sp[0xc]
80009f5a:	58 0c       	cp.w	r12,0
80009f5c:	c1 d0       	breq	80009f96 <_vfprintf_r+0xeee>
80009f5e:	10 36       	cp.w	r6,r8
80009f60:	c0 64       	brge	80009f6c <_vfprintf_r+0xec4>
80009f62:	fa cb f9 44 	sub	r11,sp,-1724
80009f66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009f6a:	c1 f8       	rjmp	80009fa8 <_vfprintf_r+0xf00>
80009f6c:	fa c8 f9 50 	sub	r8,sp,-1712
80009f70:	1a d8       	st.w	--sp,r8
80009f72:	fa c8 fa b8 	sub	r8,sp,-1352
80009f76:	0c 9b       	mov	r11,r6
80009f78:	1a d8       	st.w	--sp,r8
80009f7a:	fa c8 fb b4 	sub	r8,sp,-1100
80009f7e:	04 9a       	mov	r10,r2
80009f80:	1a d8       	st.w	--sp,r8
80009f82:	08 9c       	mov	r12,r4
80009f84:	fa c8 f9 40 	sub	r8,sp,-1728
80009f88:	fa c9 ff b4 	sub	r9,sp,-76
80009f8c:	fe b0 f6 f6 	rcall	80008d78 <get_arg>
80009f90:	2f dd       	sub	sp,-12
80009f92:	78 0b       	ld.w	r11,r12[0x0]
80009f94:	c2 48       	rjmp	80009fdc <_vfprintf_r+0xf34>
80009f96:	ee ca ff ff 	sub	r10,r7,-1
80009f9a:	10 37       	cp.w	r7,r8
80009f9c:	c0 94       	brge	80009fae <_vfprintf_r+0xf06>
80009f9e:	fa c9 f9 44 	sub	r9,sp,-1724
80009fa2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009fa6:	14 97       	mov	r7,r10
80009fa8:	ec fb fd 88 	ld.w	r11,r6[-632]
80009fac:	c1 88       	rjmp	80009fdc <_vfprintf_r+0xf34>
80009fae:	41 09       	lddsp	r9,sp[0x40]
80009fb0:	59 f8       	cp.w	r8,31
80009fb2:	e0 89 00 11 	brgt	80009fd4 <_vfprintf_r+0xf2c>
80009fb6:	f2 cb ff fc 	sub	r11,r9,-4
80009fba:	51 0b       	stdsp	sp[0x40],r11
80009fbc:	fa c6 f9 44 	sub	r6,sp,-1724
80009fc0:	72 0b       	ld.w	r11,r9[0x0]
80009fc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009fc6:	f3 4b fd 88 	st.w	r9[-632],r11
80009fca:	2f f8       	sub	r8,-1
80009fcc:	14 97       	mov	r7,r10
80009fce:	fb 48 06 b4 	st.w	sp[1716],r8
80009fd2:	c0 58       	rjmp	80009fdc <_vfprintf_r+0xf34>
80009fd4:	72 0b       	ld.w	r11,r9[0x0]
80009fd6:	14 97       	mov	r7,r10
80009fd8:	2f c9       	sub	r9,-4
80009fda:	51 09       	stdsp	sp[0x40],r9
80009fdc:	50 1b       	stdsp	sp[0x4],r11
80009fde:	30 0e       	mov	lr,0
80009fe0:	50 0e       	stdsp	sp[0x0],lr
80009fe2:	1c 98       	mov	r8,lr
80009fe4:	e0 8f 02 fe 	bral	8000a5e0 <_vfprintf_r+0x1538>
80009fe8:	50 a7       	stdsp	sp[0x28],r7
80009fea:	50 80       	stdsp	sp[0x20],r0
80009fec:	0c 97       	mov	r7,r6
80009fee:	04 94       	mov	r4,r2
80009ff0:	06 96       	mov	r6,r3
80009ff2:	02 92       	mov	r2,r1
80009ff4:	40 93       	lddsp	r3,sp[0x24]
80009ff6:	40 41       	lddsp	r1,sp[0x10]
80009ff8:	0e 99       	mov	r9,r7
80009ffa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ffe:	40 3c       	lddsp	r12,sp[0xc]
8000a000:	58 0c       	cp.w	r12,0
8000a002:	c1 d0       	breq	8000a03c <_vfprintf_r+0xf94>
8000a004:	10 36       	cp.w	r6,r8
8000a006:	c0 64       	brge	8000a012 <_vfprintf_r+0xf6a>
8000a008:	fa cb f9 44 	sub	r11,sp,-1724
8000a00c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a010:	c1 d8       	rjmp	8000a04a <_vfprintf_r+0xfa2>
8000a012:	fa c8 f9 50 	sub	r8,sp,-1712
8000a016:	1a d8       	st.w	--sp,r8
8000a018:	fa c8 fa b8 	sub	r8,sp,-1352
8000a01c:	1a d8       	st.w	--sp,r8
8000a01e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a022:	1a d8       	st.w	--sp,r8
8000a024:	fa c9 ff b4 	sub	r9,sp,-76
8000a028:	fa c8 f9 40 	sub	r8,sp,-1728
8000a02c:	04 9a       	mov	r10,r2
8000a02e:	0c 9b       	mov	r11,r6
8000a030:	08 9c       	mov	r12,r4
8000a032:	fe b0 f6 a3 	rcall	80008d78 <get_arg>
8000a036:	2f dd       	sub	sp,-12
8000a038:	78 09       	ld.w	r9,r12[0x0]
8000a03a:	c2 18       	rjmp	8000a07c <_vfprintf_r+0xfd4>
8000a03c:	2f f7       	sub	r7,-1
8000a03e:	10 39       	cp.w	r9,r8
8000a040:	c0 84       	brge	8000a050 <_vfprintf_r+0xfa8>
8000a042:	fa ca f9 44 	sub	r10,sp,-1724
8000a046:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a04a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000a04e:	c1 78       	rjmp	8000a07c <_vfprintf_r+0xfd4>
8000a050:	41 09       	lddsp	r9,sp[0x40]
8000a052:	59 f8       	cp.w	r8,31
8000a054:	e0 89 00 10 	brgt	8000a074 <_vfprintf_r+0xfcc>
8000a058:	f2 ca ff fc 	sub	r10,r9,-4
8000a05c:	51 0a       	stdsp	sp[0x40],r10
8000a05e:	fa c6 f9 44 	sub	r6,sp,-1724
8000a062:	72 09       	ld.w	r9,r9[0x0]
8000a064:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000a068:	f5 49 fd 88 	st.w	r10[-632],r9
8000a06c:	2f f8       	sub	r8,-1
8000a06e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a072:	c0 58       	rjmp	8000a07c <_vfprintf_r+0xfd4>
8000a074:	f2 c8 ff fc 	sub	r8,r9,-4
8000a078:	51 08       	stdsp	sp[0x40],r8
8000a07a:	72 09       	ld.w	r9,r9[0x0]
8000a07c:	33 08       	mov	r8,48
8000a07e:	fb 68 06 b8 	st.b	sp[1720],r8
8000a082:	37 88       	mov	r8,120
8000a084:	30 0e       	mov	lr,0
8000a086:	fb 68 06 b9 	st.b	sp[1721],r8
8000a08a:	fe cc ad 26 	sub	r12,pc,-21210
8000a08e:	50 19       	stdsp	sp[0x4],r9
8000a090:	a1 b5       	sbr	r5,0x1
8000a092:	50 0e       	stdsp	sp[0x0],lr
8000a094:	50 dc       	stdsp	sp[0x34],r12
8000a096:	30 28       	mov	r8,2
8000a098:	37 80       	mov	r0,120
8000a09a:	e0 8f 02 a3 	bral	8000a5e0 <_vfprintf_r+0x1538>
8000a09e:	50 a7       	stdsp	sp[0x28],r7
8000a0a0:	50 80       	stdsp	sp[0x20],r0
8000a0a2:	10 90       	mov	r0,r8
8000a0a4:	30 08       	mov	r8,0
8000a0a6:	fb 68 06 bb 	st.b	sp[1723],r8
8000a0aa:	0c 97       	mov	r7,r6
8000a0ac:	04 94       	mov	r4,r2
8000a0ae:	06 96       	mov	r6,r3
8000a0b0:	02 92       	mov	r2,r1
8000a0b2:	40 93       	lddsp	r3,sp[0x24]
8000a0b4:	40 41       	lddsp	r1,sp[0x10]
8000a0b6:	0e 99       	mov	r9,r7
8000a0b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a0bc:	40 3b       	lddsp	r11,sp[0xc]
8000a0be:	58 0b       	cp.w	r11,0
8000a0c0:	c1 d0       	breq	8000a0fa <_vfprintf_r+0x1052>
8000a0c2:	10 36       	cp.w	r6,r8
8000a0c4:	c0 64       	brge	8000a0d0 <_vfprintf_r+0x1028>
8000a0c6:	fa ca f9 44 	sub	r10,sp,-1724
8000a0ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a0ce:	c1 d8       	rjmp	8000a108 <_vfprintf_r+0x1060>
8000a0d0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a0d4:	1a d8       	st.w	--sp,r8
8000a0d6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a0da:	1a d8       	st.w	--sp,r8
8000a0dc:	fa c8 fb b4 	sub	r8,sp,-1100
8000a0e0:	0c 9b       	mov	r11,r6
8000a0e2:	1a d8       	st.w	--sp,r8
8000a0e4:	04 9a       	mov	r10,r2
8000a0e6:	fa c8 f9 40 	sub	r8,sp,-1728
8000a0ea:	fa c9 ff b4 	sub	r9,sp,-76
8000a0ee:	08 9c       	mov	r12,r4
8000a0f0:	fe b0 f6 44 	rcall	80008d78 <get_arg>
8000a0f4:	2f dd       	sub	sp,-12
8000a0f6:	78 06       	ld.w	r6,r12[0x0]
8000a0f8:	c2 08       	rjmp	8000a138 <_vfprintf_r+0x1090>
8000a0fa:	2f f7       	sub	r7,-1
8000a0fc:	10 39       	cp.w	r9,r8
8000a0fe:	c0 84       	brge	8000a10e <_vfprintf_r+0x1066>
8000a100:	fa c9 f9 44 	sub	r9,sp,-1724
8000a104:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a108:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a10c:	c1 68       	rjmp	8000a138 <_vfprintf_r+0x1090>
8000a10e:	41 09       	lddsp	r9,sp[0x40]
8000a110:	59 f8       	cp.w	r8,31
8000a112:	e0 89 00 10 	brgt	8000a132 <_vfprintf_r+0x108a>
8000a116:	f2 ca ff fc 	sub	r10,r9,-4
8000a11a:	51 0a       	stdsp	sp[0x40],r10
8000a11c:	72 06       	ld.w	r6,r9[0x0]
8000a11e:	fa ce f9 44 	sub	lr,sp,-1724
8000a122:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a126:	f3 46 fd 88 	st.w	r9[-632],r6
8000a12a:	2f f8       	sub	r8,-1
8000a12c:	fb 48 06 b4 	st.w	sp[1716],r8
8000a130:	c0 48       	rjmp	8000a138 <_vfprintf_r+0x1090>
8000a132:	72 06       	ld.w	r6,r9[0x0]
8000a134:	2f c9       	sub	r9,-4
8000a136:	51 09       	stdsp	sp[0x40],r9
8000a138:	40 2c       	lddsp	r12,sp[0x8]
8000a13a:	58 0c       	cp.w	r12,0
8000a13c:	c1 05       	brlt	8000a15c <_vfprintf_r+0x10b4>
8000a13e:	18 9a       	mov	r10,r12
8000a140:	30 0b       	mov	r11,0
8000a142:	0c 9c       	mov	r12,r6
8000a144:	e0 a0 12 38 	rcall	8000c5b4 <memchr>
8000a148:	e0 80 02 df 	breq	8000a706 <_vfprintf_r+0x165e>
8000a14c:	f8 06 01 02 	sub	r2,r12,r6
8000a150:	40 2b       	lddsp	r11,sp[0x8]
8000a152:	16 32       	cp.w	r2,r11
8000a154:	e0 89 02 d9 	brgt	8000a706 <_vfprintf_r+0x165e>
8000a158:	e0 8f 02 d4 	bral	8000a700 <_vfprintf_r+0x1658>
8000a15c:	30 0a       	mov	r10,0
8000a15e:	0c 9c       	mov	r12,r6
8000a160:	50 2a       	stdsp	sp[0x8],r10
8000a162:	e0 a0 15 99 	rcall	8000cc94 <strlen>
8000a166:	18 92       	mov	r2,r12
8000a168:	e0 8f 02 d2 	bral	8000a70c <_vfprintf_r+0x1664>
8000a16c:	50 a7       	stdsp	sp[0x28],r7
8000a16e:	50 80       	stdsp	sp[0x20],r0
8000a170:	0c 97       	mov	r7,r6
8000a172:	04 94       	mov	r4,r2
8000a174:	06 96       	mov	r6,r3
8000a176:	02 92       	mov	r2,r1
8000a178:	40 93       	lddsp	r3,sp[0x24]
8000a17a:	10 90       	mov	r0,r8
8000a17c:	40 41       	lddsp	r1,sp[0x10]
8000a17e:	a5 a5       	sbr	r5,0x4
8000a180:	c0 a8       	rjmp	8000a194 <_vfprintf_r+0x10ec>
8000a182:	50 a7       	stdsp	sp[0x28],r7
8000a184:	50 80       	stdsp	sp[0x20],r0
8000a186:	0c 97       	mov	r7,r6
8000a188:	04 94       	mov	r4,r2
8000a18a:	06 96       	mov	r6,r3
8000a18c:	02 92       	mov	r2,r1
8000a18e:	40 93       	lddsp	r3,sp[0x24]
8000a190:	10 90       	mov	r0,r8
8000a192:	40 41       	lddsp	r1,sp[0x10]
8000a194:	ed b5 00 05 	bld	r5,0x5
8000a198:	c5 61       	brne	8000a244 <_vfprintf_r+0x119c>
8000a19a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a19e:	40 39       	lddsp	r9,sp[0xc]
8000a1a0:	58 09       	cp.w	r9,0
8000a1a2:	c2 10       	breq	8000a1e4 <_vfprintf_r+0x113c>
8000a1a4:	10 36       	cp.w	r6,r8
8000a1a6:	c0 74       	brge	8000a1b4 <_vfprintf_r+0x110c>
8000a1a8:	fa c8 f9 44 	sub	r8,sp,-1724
8000a1ac:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a1b0:	c2 38       	rjmp	8000a1f6 <_vfprintf_r+0x114e>
8000a1b2:	d7 03       	nop
8000a1b4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a1b8:	1a d8       	st.w	--sp,r8
8000a1ba:	fa c8 fa b8 	sub	r8,sp,-1352
8000a1be:	1a d8       	st.w	--sp,r8
8000a1c0:	fa c8 fb b4 	sub	r8,sp,-1100
8000a1c4:	1a d8       	st.w	--sp,r8
8000a1c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000a1ca:	fa c9 ff b4 	sub	r9,sp,-76
8000a1ce:	04 9a       	mov	r10,r2
8000a1d0:	0c 9b       	mov	r11,r6
8000a1d2:	08 9c       	mov	r12,r4
8000a1d4:	fe b0 f5 d2 	rcall	80008d78 <get_arg>
8000a1d8:	2f dd       	sub	sp,-12
8000a1da:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a1de:	fa e9 00 00 	st.d	sp[0],r8
8000a1e2:	c2 e8       	rjmp	8000a23e <_vfprintf_r+0x1196>
8000a1e4:	ee ca ff ff 	sub	r10,r7,-1
8000a1e8:	10 37       	cp.w	r7,r8
8000a1ea:	c0 b4       	brge	8000a200 <_vfprintf_r+0x1158>
8000a1ec:	fa c8 f9 44 	sub	r8,sp,-1724
8000a1f0:	14 97       	mov	r7,r10
8000a1f2:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a1f6:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a1fa:	fa eb 00 00 	st.d	sp[0],r10
8000a1fe:	c2 08       	rjmp	8000a23e <_vfprintf_r+0x1196>
8000a200:	41 09       	lddsp	r9,sp[0x40]
8000a202:	59 f8       	cp.w	r8,31
8000a204:	e0 89 00 16 	brgt	8000a230 <_vfprintf_r+0x1188>
8000a208:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a20c:	f2 cb ff f8 	sub	r11,r9,-8
8000a210:	fa e7 00 00 	st.d	sp[0],r6
8000a214:	51 0b       	stdsp	sp[0x40],r11
8000a216:	fa c6 f9 44 	sub	r6,sp,-1724
8000a21a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a21e:	fa e6 00 00 	ld.d	r6,sp[0]
8000a222:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a226:	2f f8       	sub	r8,-1
8000a228:	14 97       	mov	r7,r10
8000a22a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a22e:	c0 88       	rjmp	8000a23e <_vfprintf_r+0x1196>
8000a230:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a234:	2f 89       	sub	r9,-8
8000a236:	fa e7 00 00 	st.d	sp[0],r6
8000a23a:	51 09       	stdsp	sp[0x40],r9
8000a23c:	14 97       	mov	r7,r10
8000a23e:	30 18       	mov	r8,1
8000a240:	e0 8f 01 d0 	bral	8000a5e0 <_vfprintf_r+0x1538>
8000a244:	ed b5 00 04 	bld	r5,0x4
8000a248:	c1 61       	brne	8000a274 <_vfprintf_r+0x11cc>
8000a24a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a24e:	40 3e       	lddsp	lr,sp[0xc]
8000a250:	58 0e       	cp.w	lr,0
8000a252:	c0 80       	breq	8000a262 <_vfprintf_r+0x11ba>
8000a254:	10 36       	cp.w	r6,r8
8000a256:	c6 74       	brge	8000a324 <_vfprintf_r+0x127c>
8000a258:	fa cc f9 44 	sub	r12,sp,-1724
8000a25c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a260:	c8 08       	rjmp	8000a360 <_vfprintf_r+0x12b8>
8000a262:	ee ca ff ff 	sub	r10,r7,-1
8000a266:	10 37       	cp.w	r7,r8
8000a268:	c7 f4       	brge	8000a366 <_vfprintf_r+0x12be>
8000a26a:	fa cb f9 44 	sub	r11,sp,-1724
8000a26e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a272:	c7 68       	rjmp	8000a35e <_vfprintf_r+0x12b6>
8000a274:	ed b5 00 06 	bld	r5,0x6
8000a278:	c4 a1       	brne	8000a30c <_vfprintf_r+0x1264>
8000a27a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a27e:	40 3c       	lddsp	r12,sp[0xc]
8000a280:	58 0c       	cp.w	r12,0
8000a282:	c1 d0       	breq	8000a2bc <_vfprintf_r+0x1214>
8000a284:	10 36       	cp.w	r6,r8
8000a286:	c0 64       	brge	8000a292 <_vfprintf_r+0x11ea>
8000a288:	fa cb f9 44 	sub	r11,sp,-1724
8000a28c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a290:	c1 f8       	rjmp	8000a2ce <_vfprintf_r+0x1226>
8000a292:	fa c8 f9 50 	sub	r8,sp,-1712
8000a296:	1a d8       	st.w	--sp,r8
8000a298:	fa c8 fa b8 	sub	r8,sp,-1352
8000a29c:	1a d8       	st.w	--sp,r8
8000a29e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a2a2:	1a d8       	st.w	--sp,r8
8000a2a4:	fa c8 f9 40 	sub	r8,sp,-1728
8000a2a8:	fa c9 ff b4 	sub	r9,sp,-76
8000a2ac:	04 9a       	mov	r10,r2
8000a2ae:	0c 9b       	mov	r11,r6
8000a2b0:	08 9c       	mov	r12,r4
8000a2b2:	fe b0 f5 63 	rcall	80008d78 <get_arg>
8000a2b6:	2f dd       	sub	sp,-12
8000a2b8:	98 18       	ld.sh	r8,r12[0x2]
8000a2ba:	c2 68       	rjmp	8000a306 <_vfprintf_r+0x125e>
8000a2bc:	ee ca ff ff 	sub	r10,r7,-1
8000a2c0:	10 37       	cp.w	r7,r8
8000a2c2:	c0 94       	brge	8000a2d4 <_vfprintf_r+0x122c>
8000a2c4:	fa c9 f9 44 	sub	r9,sp,-1724
8000a2c8:	14 97       	mov	r7,r10
8000a2ca:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a2ce:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a2d2:	c1 a8       	rjmp	8000a306 <_vfprintf_r+0x125e>
8000a2d4:	41 09       	lddsp	r9,sp[0x40]
8000a2d6:	59 f8       	cp.w	r8,31
8000a2d8:	e0 89 00 13 	brgt	8000a2fe <_vfprintf_r+0x1256>
8000a2dc:	f2 cb ff fc 	sub	r11,r9,-4
8000a2e0:	51 0b       	stdsp	sp[0x40],r11
8000a2e2:	72 09       	ld.w	r9,r9[0x0]
8000a2e4:	fa c6 f9 44 	sub	r6,sp,-1724
8000a2e8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a2ec:	2f f8       	sub	r8,-1
8000a2ee:	f7 49 fd 88 	st.w	r11[-632],r9
8000a2f2:	fb 48 06 b4 	st.w	sp[1716],r8
8000a2f6:	14 97       	mov	r7,r10
8000a2f8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a2fc:	c0 58       	rjmp	8000a306 <_vfprintf_r+0x125e>
8000a2fe:	92 18       	ld.sh	r8,r9[0x2]
8000a300:	14 97       	mov	r7,r10
8000a302:	2f c9       	sub	r9,-4
8000a304:	51 09       	stdsp	sp[0x40],r9
8000a306:	5c 78       	castu.h	r8
8000a308:	50 18       	stdsp	sp[0x4],r8
8000a30a:	c4 68       	rjmp	8000a396 <_vfprintf_r+0x12ee>
8000a30c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a310:	40 3c       	lddsp	r12,sp[0xc]
8000a312:	58 0c       	cp.w	r12,0
8000a314:	c1 d0       	breq	8000a34e <_vfprintf_r+0x12a6>
8000a316:	10 36       	cp.w	r6,r8
8000a318:	c0 64       	brge	8000a324 <_vfprintf_r+0x127c>
8000a31a:	fa cb f9 44 	sub	r11,sp,-1724
8000a31e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a322:	c1 f8       	rjmp	8000a360 <_vfprintf_r+0x12b8>
8000a324:	fa c8 f9 50 	sub	r8,sp,-1712
8000a328:	1a d8       	st.w	--sp,r8
8000a32a:	fa c8 fa b8 	sub	r8,sp,-1352
8000a32e:	0c 9b       	mov	r11,r6
8000a330:	1a d8       	st.w	--sp,r8
8000a332:	fa c8 fb b4 	sub	r8,sp,-1100
8000a336:	04 9a       	mov	r10,r2
8000a338:	1a d8       	st.w	--sp,r8
8000a33a:	08 9c       	mov	r12,r4
8000a33c:	fa c8 f9 40 	sub	r8,sp,-1728
8000a340:	fa c9 ff b4 	sub	r9,sp,-76
8000a344:	fe b0 f5 1a 	rcall	80008d78 <get_arg>
8000a348:	2f dd       	sub	sp,-12
8000a34a:	78 0b       	ld.w	r11,r12[0x0]
8000a34c:	c2 48       	rjmp	8000a394 <_vfprintf_r+0x12ec>
8000a34e:	ee ca ff ff 	sub	r10,r7,-1
8000a352:	10 37       	cp.w	r7,r8
8000a354:	c0 94       	brge	8000a366 <_vfprintf_r+0x12be>
8000a356:	fa c9 f9 44 	sub	r9,sp,-1724
8000a35a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a35e:	14 97       	mov	r7,r10
8000a360:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a364:	c1 88       	rjmp	8000a394 <_vfprintf_r+0x12ec>
8000a366:	41 09       	lddsp	r9,sp[0x40]
8000a368:	59 f8       	cp.w	r8,31
8000a36a:	e0 89 00 11 	brgt	8000a38c <_vfprintf_r+0x12e4>
8000a36e:	f2 cb ff fc 	sub	r11,r9,-4
8000a372:	51 0b       	stdsp	sp[0x40],r11
8000a374:	fa c6 f9 44 	sub	r6,sp,-1724
8000a378:	72 0b       	ld.w	r11,r9[0x0]
8000a37a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a37e:	f3 4b fd 88 	st.w	r9[-632],r11
8000a382:	2f f8       	sub	r8,-1
8000a384:	14 97       	mov	r7,r10
8000a386:	fb 48 06 b4 	st.w	sp[1716],r8
8000a38a:	c0 58       	rjmp	8000a394 <_vfprintf_r+0x12ec>
8000a38c:	72 0b       	ld.w	r11,r9[0x0]
8000a38e:	14 97       	mov	r7,r10
8000a390:	2f c9       	sub	r9,-4
8000a392:	51 09       	stdsp	sp[0x40],r9
8000a394:	50 1b       	stdsp	sp[0x4],r11
8000a396:	30 0e       	mov	lr,0
8000a398:	30 18       	mov	r8,1
8000a39a:	50 0e       	stdsp	sp[0x0],lr
8000a39c:	c2 29       	rjmp	8000a5e0 <_vfprintf_r+0x1538>
8000a39e:	50 a7       	stdsp	sp[0x28],r7
8000a3a0:	50 80       	stdsp	sp[0x20],r0
8000a3a2:	0c 97       	mov	r7,r6
8000a3a4:	04 94       	mov	r4,r2
8000a3a6:	06 96       	mov	r6,r3
8000a3a8:	02 92       	mov	r2,r1
8000a3aa:	fe cc b0 46 	sub	r12,pc,-20410
8000a3ae:	40 93       	lddsp	r3,sp[0x24]
8000a3b0:	10 90       	mov	r0,r8
8000a3b2:	40 41       	lddsp	r1,sp[0x10]
8000a3b4:	50 dc       	stdsp	sp[0x34],r12
8000a3b6:	ed b5 00 05 	bld	r5,0x5
8000a3ba:	c5 51       	brne	8000a464 <_vfprintf_r+0x13bc>
8000a3bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a3c0:	40 3b       	lddsp	r11,sp[0xc]
8000a3c2:	58 0b       	cp.w	r11,0
8000a3c4:	c2 20       	breq	8000a408 <_vfprintf_r+0x1360>
8000a3c6:	10 36       	cp.w	r6,r8
8000a3c8:	c0 a4       	brge	8000a3dc <_vfprintf_r+0x1334>
8000a3ca:	fa ca f9 44 	sub	r10,sp,-1724
8000a3ce:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a3d2:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a3d6:	fa e9 00 00 	st.d	sp[0],r8
8000a3da:	cf 28       	rjmp	8000a5be <_vfprintf_r+0x1516>
8000a3dc:	fa c8 f9 50 	sub	r8,sp,-1712
8000a3e0:	1a d8       	st.w	--sp,r8
8000a3e2:	fa c8 fa b8 	sub	r8,sp,-1352
8000a3e6:	04 9a       	mov	r10,r2
8000a3e8:	1a d8       	st.w	--sp,r8
8000a3ea:	0c 9b       	mov	r11,r6
8000a3ec:	fa c8 fb b4 	sub	r8,sp,-1100
8000a3f0:	08 9c       	mov	r12,r4
8000a3f2:	1a d8       	st.w	--sp,r8
8000a3f4:	fa c8 f9 40 	sub	r8,sp,-1728
8000a3f8:	fa c9 ff b4 	sub	r9,sp,-76
8000a3fc:	fe b0 f4 be 	rcall	80008d78 <get_arg>
8000a400:	2f dd       	sub	sp,-12
8000a402:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a406:	c0 c8       	rjmp	8000a41e <_vfprintf_r+0x1376>
8000a408:	ee ca ff ff 	sub	r10,r7,-1
8000a40c:	10 37       	cp.w	r7,r8
8000a40e:	c0 b4       	brge	8000a424 <_vfprintf_r+0x137c>
8000a410:	fa c9 f9 44 	sub	r9,sp,-1724
8000a414:	14 97       	mov	r7,r10
8000a416:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a41a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a41e:	fa eb 00 00 	st.d	sp[0],r10
8000a422:	cc e8       	rjmp	8000a5be <_vfprintf_r+0x1516>
8000a424:	41 09       	lddsp	r9,sp[0x40]
8000a426:	59 f8       	cp.w	r8,31
8000a428:	e0 89 00 16 	brgt	8000a454 <_vfprintf_r+0x13ac>
8000a42c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a430:	f2 cb ff f8 	sub	r11,r9,-8
8000a434:	fa e7 00 00 	st.d	sp[0],r6
8000a438:	51 0b       	stdsp	sp[0x40],r11
8000a43a:	fa c6 f9 44 	sub	r6,sp,-1724
8000a43e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a442:	fa e6 00 00 	ld.d	r6,sp[0]
8000a446:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a44a:	2f f8       	sub	r8,-1
8000a44c:	14 97       	mov	r7,r10
8000a44e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a452:	cb 68       	rjmp	8000a5be <_vfprintf_r+0x1516>
8000a454:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a458:	2f 89       	sub	r9,-8
8000a45a:	fa e7 00 00 	st.d	sp[0],r6
8000a45e:	51 09       	stdsp	sp[0x40],r9
8000a460:	14 97       	mov	r7,r10
8000a462:	ca e8       	rjmp	8000a5be <_vfprintf_r+0x1516>
8000a464:	ed b5 00 04 	bld	r5,0x4
8000a468:	c1 71       	brne	8000a496 <_vfprintf_r+0x13ee>
8000a46a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a46e:	40 3e       	lddsp	lr,sp[0xc]
8000a470:	58 0e       	cp.w	lr,0
8000a472:	c0 80       	breq	8000a482 <_vfprintf_r+0x13da>
8000a474:	10 36       	cp.w	r6,r8
8000a476:	c6 94       	brge	8000a548 <_vfprintf_r+0x14a0>
8000a478:	fa cc f9 44 	sub	r12,sp,-1724
8000a47c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a480:	c8 28       	rjmp	8000a584 <_vfprintf_r+0x14dc>
8000a482:	ee ca ff ff 	sub	r10,r7,-1
8000a486:	10 37       	cp.w	r7,r8
8000a488:	e0 84 00 81 	brge	8000a58a <_vfprintf_r+0x14e2>
8000a48c:	fa cb f9 44 	sub	r11,sp,-1724
8000a490:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a494:	c7 78       	rjmp	8000a582 <_vfprintf_r+0x14da>
8000a496:	ed b5 00 06 	bld	r5,0x6
8000a49a:	c4 b1       	brne	8000a530 <_vfprintf_r+0x1488>
8000a49c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a4a0:	40 3c       	lddsp	r12,sp[0xc]
8000a4a2:	58 0c       	cp.w	r12,0
8000a4a4:	c1 d0       	breq	8000a4de <_vfprintf_r+0x1436>
8000a4a6:	10 36       	cp.w	r6,r8
8000a4a8:	c0 64       	brge	8000a4b4 <_vfprintf_r+0x140c>
8000a4aa:	fa cb f9 44 	sub	r11,sp,-1724
8000a4ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a4b2:	c1 f8       	rjmp	8000a4f0 <_vfprintf_r+0x1448>
8000a4b4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a4b8:	1a d8       	st.w	--sp,r8
8000a4ba:	fa c8 fa b8 	sub	r8,sp,-1352
8000a4be:	1a d8       	st.w	--sp,r8
8000a4c0:	fa c8 fb b4 	sub	r8,sp,-1100
8000a4c4:	1a d8       	st.w	--sp,r8
8000a4c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000a4ca:	fa c9 ff b4 	sub	r9,sp,-76
8000a4ce:	04 9a       	mov	r10,r2
8000a4d0:	0c 9b       	mov	r11,r6
8000a4d2:	08 9c       	mov	r12,r4
8000a4d4:	fe b0 f4 52 	rcall	80008d78 <get_arg>
8000a4d8:	2f dd       	sub	sp,-12
8000a4da:	98 18       	ld.sh	r8,r12[0x2]
8000a4dc:	c2 78       	rjmp	8000a52a <_vfprintf_r+0x1482>
8000a4de:	ee ca ff ff 	sub	r10,r7,-1
8000a4e2:	10 37       	cp.w	r7,r8
8000a4e4:	c0 a4       	brge	8000a4f8 <_vfprintf_r+0x1450>
8000a4e6:	fa c9 f9 44 	sub	r9,sp,-1724
8000a4ea:	14 97       	mov	r7,r10
8000a4ec:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a4f0:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a4f4:	c1 b8       	rjmp	8000a52a <_vfprintf_r+0x1482>
8000a4f6:	d7 03       	nop
8000a4f8:	41 09       	lddsp	r9,sp[0x40]
8000a4fa:	59 f8       	cp.w	r8,31
8000a4fc:	e0 89 00 13 	brgt	8000a522 <_vfprintf_r+0x147a>
8000a500:	f2 cb ff fc 	sub	r11,r9,-4
8000a504:	51 0b       	stdsp	sp[0x40],r11
8000a506:	72 09       	ld.w	r9,r9[0x0]
8000a508:	fa c6 f9 44 	sub	r6,sp,-1724
8000a50c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a510:	2f f8       	sub	r8,-1
8000a512:	f7 49 fd 88 	st.w	r11[-632],r9
8000a516:	fb 48 06 b4 	st.w	sp[1716],r8
8000a51a:	14 97       	mov	r7,r10
8000a51c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a520:	c0 58       	rjmp	8000a52a <_vfprintf_r+0x1482>
8000a522:	92 18       	ld.sh	r8,r9[0x2]
8000a524:	14 97       	mov	r7,r10
8000a526:	2f c9       	sub	r9,-4
8000a528:	51 09       	stdsp	sp[0x40],r9
8000a52a:	5c 78       	castu.h	r8
8000a52c:	50 18       	stdsp	sp[0x4],r8
8000a52e:	c4 68       	rjmp	8000a5ba <_vfprintf_r+0x1512>
8000a530:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a534:	40 3c       	lddsp	r12,sp[0xc]
8000a536:	58 0c       	cp.w	r12,0
8000a538:	c1 d0       	breq	8000a572 <_vfprintf_r+0x14ca>
8000a53a:	10 36       	cp.w	r6,r8
8000a53c:	c0 64       	brge	8000a548 <_vfprintf_r+0x14a0>
8000a53e:	fa cb f9 44 	sub	r11,sp,-1724
8000a542:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a546:	c1 f8       	rjmp	8000a584 <_vfprintf_r+0x14dc>
8000a548:	fa c8 f9 50 	sub	r8,sp,-1712
8000a54c:	1a d8       	st.w	--sp,r8
8000a54e:	fa c8 fa b8 	sub	r8,sp,-1352
8000a552:	0c 9b       	mov	r11,r6
8000a554:	1a d8       	st.w	--sp,r8
8000a556:	fa c8 fb b4 	sub	r8,sp,-1100
8000a55a:	04 9a       	mov	r10,r2
8000a55c:	1a d8       	st.w	--sp,r8
8000a55e:	08 9c       	mov	r12,r4
8000a560:	fa c8 f9 40 	sub	r8,sp,-1728
8000a564:	fa c9 ff b4 	sub	r9,sp,-76
8000a568:	fe b0 f4 08 	rcall	80008d78 <get_arg>
8000a56c:	2f dd       	sub	sp,-12
8000a56e:	78 0b       	ld.w	r11,r12[0x0]
8000a570:	c2 48       	rjmp	8000a5b8 <_vfprintf_r+0x1510>
8000a572:	ee ca ff ff 	sub	r10,r7,-1
8000a576:	10 37       	cp.w	r7,r8
8000a578:	c0 94       	brge	8000a58a <_vfprintf_r+0x14e2>
8000a57a:	fa c9 f9 44 	sub	r9,sp,-1724
8000a57e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a582:	14 97       	mov	r7,r10
8000a584:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a588:	c1 88       	rjmp	8000a5b8 <_vfprintf_r+0x1510>
8000a58a:	41 09       	lddsp	r9,sp[0x40]
8000a58c:	59 f8       	cp.w	r8,31
8000a58e:	e0 89 00 11 	brgt	8000a5b0 <_vfprintf_r+0x1508>
8000a592:	f2 cb ff fc 	sub	r11,r9,-4
8000a596:	51 0b       	stdsp	sp[0x40],r11
8000a598:	fa c6 f9 44 	sub	r6,sp,-1724
8000a59c:	72 0b       	ld.w	r11,r9[0x0]
8000a59e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a5a2:	f3 4b fd 88 	st.w	r9[-632],r11
8000a5a6:	2f f8       	sub	r8,-1
8000a5a8:	14 97       	mov	r7,r10
8000a5aa:	fb 48 06 b4 	st.w	sp[1716],r8
8000a5ae:	c0 58       	rjmp	8000a5b8 <_vfprintf_r+0x1510>
8000a5b0:	72 0b       	ld.w	r11,r9[0x0]
8000a5b2:	14 97       	mov	r7,r10
8000a5b4:	2f c9       	sub	r9,-4
8000a5b6:	51 09       	stdsp	sp[0x40],r9
8000a5b8:	50 1b       	stdsp	sp[0x4],r11
8000a5ba:	30 0e       	mov	lr,0
8000a5bc:	50 0e       	stdsp	sp[0x0],lr
8000a5be:	40 08       	lddsp	r8,sp[0x0]
8000a5c0:	40 1c       	lddsp	r12,sp[0x4]
8000a5c2:	18 48       	or	r8,r12
8000a5c4:	5f 19       	srne	r9
8000a5c6:	0a 98       	mov	r8,r5
8000a5c8:	eb e9 00 09 	and	r9,r5,r9
8000a5cc:	a1 b8       	sbr	r8,0x1
8000a5ce:	58 09       	cp.w	r9,0
8000a5d0:	c0 70       	breq	8000a5de <_vfprintf_r+0x1536>
8000a5d2:	10 95       	mov	r5,r8
8000a5d4:	fb 60 06 b9 	st.b	sp[1721],r0
8000a5d8:	33 08       	mov	r8,48
8000a5da:	fb 68 06 b8 	st.b	sp[1720],r8
8000a5de:	30 28       	mov	r8,2
8000a5e0:	30 09       	mov	r9,0
8000a5e2:	fb 69 06 bb 	st.b	sp[1723],r9
8000a5e6:	0a 99       	mov	r9,r5
8000a5e8:	a7 d9       	cbr	r9,0x7
8000a5ea:	40 2b       	lddsp	r11,sp[0x8]
8000a5ec:	40 16       	lddsp	r6,sp[0x4]
8000a5ee:	58 0b       	cp.w	r11,0
8000a5f0:	5f 1a       	srne	r10
8000a5f2:	f2 05 17 40 	movge	r5,r9
8000a5f6:	fa c2 f9 78 	sub	r2,sp,-1672
8000a5fa:	40 09       	lddsp	r9,sp[0x0]
8000a5fc:	0c 49       	or	r9,r6
8000a5fe:	5f 19       	srne	r9
8000a600:	f5 e9 10 09 	or	r9,r10,r9
8000a604:	c5 c0       	breq	8000a6bc <_vfprintf_r+0x1614>
8000a606:	30 19       	mov	r9,1
8000a608:	f2 08 18 00 	cp.b	r8,r9
8000a60c:	c0 60       	breq	8000a618 <_vfprintf_r+0x1570>
8000a60e:	30 29       	mov	r9,2
8000a610:	f2 08 18 00 	cp.b	r8,r9
8000a614:	c0 41       	brne	8000a61c <_vfprintf_r+0x1574>
8000a616:	c3 c8       	rjmp	8000a68e <_vfprintf_r+0x15e6>
8000a618:	04 96       	mov	r6,r2
8000a61a:	c3 08       	rjmp	8000a67a <_vfprintf_r+0x15d2>
8000a61c:	04 96       	mov	r6,r2
8000a61e:	fa e8 00 00 	ld.d	r8,sp[0]
8000a622:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a626:	2d 0a       	sub	r10,-48
8000a628:	0c fa       	st.b	--r6,r10
8000a62a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a62e:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a632:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a636:	18 99       	mov	r9,r12
8000a638:	16 98       	mov	r8,r11
8000a63a:	58 08       	cp.w	r8,0
8000a63c:	5c 29       	cpc	r9
8000a63e:	cf 21       	brne	8000a622 <_vfprintf_r+0x157a>
8000a640:	fa e9 00 00 	st.d	sp[0],r8
8000a644:	ed b5 00 00 	bld	r5,0x0
8000a648:	c4 51       	brne	8000a6d2 <_vfprintf_r+0x162a>
8000a64a:	33 09       	mov	r9,48
8000a64c:	f2 0a 18 00 	cp.b	r10,r9
8000a650:	c4 10       	breq	8000a6d2 <_vfprintf_r+0x162a>
8000a652:	0c f9       	st.b	--r6,r9
8000a654:	c3 f8       	rjmp	8000a6d2 <_vfprintf_r+0x162a>
8000a656:	fa ea 00 00 	ld.d	r10,sp[0]
8000a65a:	30 a8       	mov	r8,10
8000a65c:	30 09       	mov	r9,0
8000a65e:	e0 a0 1a 19 	rcall	8000da90 <__avr32_umod64>
8000a662:	30 a8       	mov	r8,10
8000a664:	2d 0a       	sub	r10,-48
8000a666:	30 09       	mov	r9,0
8000a668:	ac 8a       	st.b	r6[0x0],r10
8000a66a:	fa ea 00 00 	ld.d	r10,sp[0]
8000a66e:	e0 a0 18 df 	rcall	8000d82c <__avr32_udiv64>
8000a672:	16 99       	mov	r9,r11
8000a674:	14 98       	mov	r8,r10
8000a676:	fa e9 00 00 	st.d	sp[0],r8
8000a67a:	20 16       	sub	r6,1
8000a67c:	fa ea 00 00 	ld.d	r10,sp[0]
8000a680:	58 9a       	cp.w	r10,9
8000a682:	5c 2b       	cpc	r11
8000a684:	fe 9b ff e9 	brhi	8000a656 <_vfprintf_r+0x15ae>
8000a688:	1b f8       	ld.ub	r8,sp[0x7]
8000a68a:	2d 08       	sub	r8,-48
8000a68c:	c2 08       	rjmp	8000a6cc <_vfprintf_r+0x1624>
8000a68e:	04 96       	mov	r6,r2
8000a690:	fa e8 00 00 	ld.d	r8,sp[0]
8000a694:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a698:	40 de       	lddsp	lr,sp[0x34]
8000a69a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a69e:	0c fa       	st.b	--r6,r10
8000a6a0:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a6a4:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a6a8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a6ac:	16 99       	mov	r9,r11
8000a6ae:	14 98       	mov	r8,r10
8000a6b0:	58 08       	cp.w	r8,0
8000a6b2:	5c 29       	cpc	r9
8000a6b4:	cf 01       	brne	8000a694 <_vfprintf_r+0x15ec>
8000a6b6:	fa e9 00 00 	st.d	sp[0],r8
8000a6ba:	c0 c8       	rjmp	8000a6d2 <_vfprintf_r+0x162a>
8000a6bc:	58 08       	cp.w	r8,0
8000a6be:	c0 91       	brne	8000a6d0 <_vfprintf_r+0x1628>
8000a6c0:	ed b5 00 00 	bld	r5,0x0
8000a6c4:	c0 61       	brne	8000a6d0 <_vfprintf_r+0x1628>
8000a6c6:	fa c6 f9 79 	sub	r6,sp,-1671
8000a6ca:	33 08       	mov	r8,48
8000a6cc:	ac 88       	st.b	r6[0x0],r8
8000a6ce:	c0 28       	rjmp	8000a6d2 <_vfprintf_r+0x162a>
8000a6d0:	04 96       	mov	r6,r2
8000a6d2:	0c 12       	sub	r2,r6
8000a6d4:	c1 c8       	rjmp	8000a70c <_vfprintf_r+0x1664>
8000a6d6:	50 a7       	stdsp	sp[0x28],r7
8000a6d8:	50 80       	stdsp	sp[0x20],r0
8000a6da:	40 93       	lddsp	r3,sp[0x24]
8000a6dc:	0c 97       	mov	r7,r6
8000a6de:	10 90       	mov	r0,r8
8000a6e0:	04 94       	mov	r4,r2
8000a6e2:	40 41       	lddsp	r1,sp[0x10]
8000a6e4:	58 08       	cp.w	r8,0
8000a6e6:	e0 80 04 4f 	breq	8000af84 <_vfprintf_r+0x1edc>
8000a6ea:	fb 68 06 60 	st.b	sp[1632],r8
8000a6ee:	30 0c       	mov	r12,0
8000a6f0:	30 08       	mov	r8,0
8000a6f2:	30 12       	mov	r2,1
8000a6f4:	fb 68 06 bb 	st.b	sp[1723],r8
8000a6f8:	50 2c       	stdsp	sp[0x8],r12
8000a6fa:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a6fe:	c0 78       	rjmp	8000a70c <_vfprintf_r+0x1664>
8000a700:	30 0b       	mov	r11,0
8000a702:	50 2b       	stdsp	sp[0x8],r11
8000a704:	c0 48       	rjmp	8000a70c <_vfprintf_r+0x1664>
8000a706:	40 22       	lddsp	r2,sp[0x8]
8000a708:	30 0a       	mov	r10,0
8000a70a:	50 2a       	stdsp	sp[0x8],r10
8000a70c:	40 29       	lddsp	r9,sp[0x8]
8000a70e:	e4 09 0c 49 	max	r9,r2,r9
8000a712:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a716:	50 39       	stdsp	sp[0xc],r9
8000a718:	0a 9e       	mov	lr,r5
8000a71a:	30 09       	mov	r9,0
8000a71c:	e2 1e 00 02 	andl	lr,0x2,COH
8000a720:	f2 08 18 00 	cp.b	r8,r9
8000a724:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a728:	f7 b8 01 ff 	subne	r8,-1
8000a72c:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a730:	0a 9b       	mov	r11,r5
8000a732:	58 0e       	cp.w	lr,0
8000a734:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a738:	f7 bc 01 fe 	subne	r12,-2
8000a73c:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a740:	e2 1b 00 84 	andl	r11,0x84,COH
8000a744:	50 fe       	stdsp	sp[0x3c],lr
8000a746:	50 9b       	stdsp	sp[0x24],r11
8000a748:	c4 71       	brne	8000a7d6 <_vfprintf_r+0x172e>
8000a74a:	40 8a       	lddsp	r10,sp[0x20]
8000a74c:	40 39       	lddsp	r9,sp[0xc]
8000a74e:	12 1a       	sub	r10,r9
8000a750:	50 4a       	stdsp	sp[0x10],r10
8000a752:	58 0a       	cp.w	r10,0
8000a754:	e0 89 00 20 	brgt	8000a794 <_vfprintf_r+0x16ec>
8000a758:	c3 f8       	rjmp	8000a7d6 <_vfprintf_r+0x172e>
8000a75a:	2f 09       	sub	r9,-16
8000a75c:	2f f8       	sub	r8,-1
8000a75e:	fe ce b3 e2 	sub	lr,pc,-19486
8000a762:	31 0c       	mov	r12,16
8000a764:	fb 49 06 90 	st.w	sp[1680],r9
8000a768:	87 0e       	st.w	r3[0x0],lr
8000a76a:	87 1c       	st.w	r3[0x4],r12
8000a76c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a770:	58 78       	cp.w	r8,7
8000a772:	e0 89 00 04 	brgt	8000a77a <_vfprintf_r+0x16d2>
8000a776:	2f 83       	sub	r3,-8
8000a778:	c0 b8       	rjmp	8000a78e <_vfprintf_r+0x16e6>
8000a77a:	fa ca f9 78 	sub	r10,sp,-1672
8000a77e:	02 9b       	mov	r11,r1
8000a780:	08 9c       	mov	r12,r4
8000a782:	fe b0 f4 85 	rcall	8000908c <__sprint_r>
8000a786:	e0 81 04 10 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a78a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a78e:	40 4b       	lddsp	r11,sp[0x10]
8000a790:	21 0b       	sub	r11,16
8000a792:	50 4b       	stdsp	sp[0x10],r11
8000a794:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a798:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a79c:	fe ca b4 20 	sub	r10,pc,-19424
8000a7a0:	40 4e       	lddsp	lr,sp[0x10]
8000a7a2:	59 0e       	cp.w	lr,16
8000a7a4:	fe 99 ff db 	brgt	8000a75a <_vfprintf_r+0x16b2>
8000a7a8:	1c 09       	add	r9,lr
8000a7aa:	2f f8       	sub	r8,-1
8000a7ac:	87 0a       	st.w	r3[0x0],r10
8000a7ae:	fb 49 06 90 	st.w	sp[1680],r9
8000a7b2:	87 1e       	st.w	r3[0x4],lr
8000a7b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7b8:	58 78       	cp.w	r8,7
8000a7ba:	e0 89 00 04 	brgt	8000a7c2 <_vfprintf_r+0x171a>
8000a7be:	2f 83       	sub	r3,-8
8000a7c0:	c0 b8       	rjmp	8000a7d6 <_vfprintf_r+0x172e>
8000a7c2:	fa ca f9 78 	sub	r10,sp,-1672
8000a7c6:	02 9b       	mov	r11,r1
8000a7c8:	08 9c       	mov	r12,r4
8000a7ca:	fe b0 f4 61 	rcall	8000908c <__sprint_r>
8000a7ce:	e0 81 03 ec 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a7d2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7d6:	30 09       	mov	r9,0
8000a7d8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a7dc:	f2 08 18 00 	cp.b	r8,r9
8000a7e0:	c1 f0       	breq	8000a81e <_vfprintf_r+0x1776>
8000a7e2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7e6:	fa c9 f9 45 	sub	r9,sp,-1723
8000a7ea:	2f f8       	sub	r8,-1
8000a7ec:	87 09       	st.w	r3[0x0],r9
8000a7ee:	fb 48 06 90 	st.w	sp[1680],r8
8000a7f2:	30 19       	mov	r9,1
8000a7f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7f8:	87 19       	st.w	r3[0x4],r9
8000a7fa:	2f f8       	sub	r8,-1
8000a7fc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a800:	58 78       	cp.w	r8,7
8000a802:	e0 89 00 04 	brgt	8000a80a <_vfprintf_r+0x1762>
8000a806:	2f 83       	sub	r3,-8
8000a808:	c0 b8       	rjmp	8000a81e <_vfprintf_r+0x1776>
8000a80a:	fa ca f9 78 	sub	r10,sp,-1672
8000a80e:	02 9b       	mov	r11,r1
8000a810:	08 9c       	mov	r12,r4
8000a812:	fe b0 f4 3d 	rcall	8000908c <__sprint_r>
8000a816:	e0 81 03 c8 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a81a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a81e:	40 fc       	lddsp	r12,sp[0x3c]
8000a820:	58 0c       	cp.w	r12,0
8000a822:	c1 f0       	breq	8000a860 <_vfprintf_r+0x17b8>
8000a824:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a828:	fa c9 f9 48 	sub	r9,sp,-1720
8000a82c:	2f e8       	sub	r8,-2
8000a82e:	87 09       	st.w	r3[0x0],r9
8000a830:	fb 48 06 90 	st.w	sp[1680],r8
8000a834:	30 29       	mov	r9,2
8000a836:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a83a:	87 19       	st.w	r3[0x4],r9
8000a83c:	2f f8       	sub	r8,-1
8000a83e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a842:	58 78       	cp.w	r8,7
8000a844:	e0 89 00 04 	brgt	8000a84c <_vfprintf_r+0x17a4>
8000a848:	2f 83       	sub	r3,-8
8000a84a:	c0 b8       	rjmp	8000a860 <_vfprintf_r+0x17b8>
8000a84c:	fa ca f9 78 	sub	r10,sp,-1672
8000a850:	02 9b       	mov	r11,r1
8000a852:	08 9c       	mov	r12,r4
8000a854:	fe b0 f4 1c 	rcall	8000908c <__sprint_r>
8000a858:	e0 81 03 a7 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a85c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a860:	40 9b       	lddsp	r11,sp[0x24]
8000a862:	e0 4b 00 80 	cp.w	r11,128
8000a866:	c4 71       	brne	8000a8f4 <_vfprintf_r+0x184c>
8000a868:	40 8a       	lddsp	r10,sp[0x20]
8000a86a:	40 39       	lddsp	r9,sp[0xc]
8000a86c:	12 1a       	sub	r10,r9
8000a86e:	50 4a       	stdsp	sp[0x10],r10
8000a870:	58 0a       	cp.w	r10,0
8000a872:	e0 89 00 20 	brgt	8000a8b2 <_vfprintf_r+0x180a>
8000a876:	c3 f8       	rjmp	8000a8f4 <_vfprintf_r+0x184c>
8000a878:	2f 09       	sub	r9,-16
8000a87a:	2f f8       	sub	r8,-1
8000a87c:	fe ce b4 f0 	sub	lr,pc,-19216
8000a880:	31 0c       	mov	r12,16
8000a882:	fb 49 06 90 	st.w	sp[1680],r9
8000a886:	87 0e       	st.w	r3[0x0],lr
8000a888:	87 1c       	st.w	r3[0x4],r12
8000a88a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a88e:	58 78       	cp.w	r8,7
8000a890:	e0 89 00 04 	brgt	8000a898 <_vfprintf_r+0x17f0>
8000a894:	2f 83       	sub	r3,-8
8000a896:	c0 b8       	rjmp	8000a8ac <_vfprintf_r+0x1804>
8000a898:	fa ca f9 78 	sub	r10,sp,-1672
8000a89c:	02 9b       	mov	r11,r1
8000a89e:	08 9c       	mov	r12,r4
8000a8a0:	fe b0 f3 f6 	rcall	8000908c <__sprint_r>
8000a8a4:	e0 81 03 81 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a8a8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8ac:	40 4b       	lddsp	r11,sp[0x10]
8000a8ae:	21 0b       	sub	r11,16
8000a8b0:	50 4b       	stdsp	sp[0x10],r11
8000a8b2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a8b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a8ba:	fe ca b5 2e 	sub	r10,pc,-19154
8000a8be:	40 4e       	lddsp	lr,sp[0x10]
8000a8c0:	59 0e       	cp.w	lr,16
8000a8c2:	fe 99 ff db 	brgt	8000a878 <_vfprintf_r+0x17d0>
8000a8c6:	1c 09       	add	r9,lr
8000a8c8:	2f f8       	sub	r8,-1
8000a8ca:	87 0a       	st.w	r3[0x0],r10
8000a8cc:	fb 49 06 90 	st.w	sp[1680],r9
8000a8d0:	87 1e       	st.w	r3[0x4],lr
8000a8d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8d6:	58 78       	cp.w	r8,7
8000a8d8:	e0 89 00 04 	brgt	8000a8e0 <_vfprintf_r+0x1838>
8000a8dc:	2f 83       	sub	r3,-8
8000a8de:	c0 b8       	rjmp	8000a8f4 <_vfprintf_r+0x184c>
8000a8e0:	fa ca f9 78 	sub	r10,sp,-1672
8000a8e4:	02 9b       	mov	r11,r1
8000a8e6:	08 9c       	mov	r12,r4
8000a8e8:	fe b0 f3 d2 	rcall	8000908c <__sprint_r>
8000a8ec:	e0 81 03 5d 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a8f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8f4:	40 2c       	lddsp	r12,sp[0x8]
8000a8f6:	04 1c       	sub	r12,r2
8000a8f8:	50 2c       	stdsp	sp[0x8],r12
8000a8fa:	58 0c       	cp.w	r12,0
8000a8fc:	e0 89 00 20 	brgt	8000a93c <_vfprintf_r+0x1894>
8000a900:	c3 f8       	rjmp	8000a97e <_vfprintf_r+0x18d6>
8000a902:	2f 09       	sub	r9,-16
8000a904:	2f f8       	sub	r8,-1
8000a906:	fe cb b5 7a 	sub	r11,pc,-19078
8000a90a:	31 0a       	mov	r10,16
8000a90c:	fb 49 06 90 	st.w	sp[1680],r9
8000a910:	87 0b       	st.w	r3[0x0],r11
8000a912:	87 1a       	st.w	r3[0x4],r10
8000a914:	fb 48 06 8c 	st.w	sp[1676],r8
8000a918:	58 78       	cp.w	r8,7
8000a91a:	e0 89 00 04 	brgt	8000a922 <_vfprintf_r+0x187a>
8000a91e:	2f 83       	sub	r3,-8
8000a920:	c0 b8       	rjmp	8000a936 <_vfprintf_r+0x188e>
8000a922:	fa ca f9 78 	sub	r10,sp,-1672
8000a926:	02 9b       	mov	r11,r1
8000a928:	08 9c       	mov	r12,r4
8000a92a:	fe b0 f3 b1 	rcall	8000908c <__sprint_r>
8000a92e:	e0 81 03 3c 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a932:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a936:	40 29       	lddsp	r9,sp[0x8]
8000a938:	21 09       	sub	r9,16
8000a93a:	50 29       	stdsp	sp[0x8],r9
8000a93c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a940:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a944:	fe ca b5 b8 	sub	r10,pc,-19016
8000a948:	40 2e       	lddsp	lr,sp[0x8]
8000a94a:	59 0e       	cp.w	lr,16
8000a94c:	fe 99 ff db 	brgt	8000a902 <_vfprintf_r+0x185a>
8000a950:	1c 09       	add	r9,lr
8000a952:	2f f8       	sub	r8,-1
8000a954:	87 0a       	st.w	r3[0x0],r10
8000a956:	fb 49 06 90 	st.w	sp[1680],r9
8000a95a:	87 1e       	st.w	r3[0x4],lr
8000a95c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a960:	58 78       	cp.w	r8,7
8000a962:	e0 89 00 04 	brgt	8000a96a <_vfprintf_r+0x18c2>
8000a966:	2f 83       	sub	r3,-8
8000a968:	c0 b8       	rjmp	8000a97e <_vfprintf_r+0x18d6>
8000a96a:	fa ca f9 78 	sub	r10,sp,-1672
8000a96e:	02 9b       	mov	r11,r1
8000a970:	08 9c       	mov	r12,r4
8000a972:	fe b0 f3 8d 	rcall	8000908c <__sprint_r>
8000a976:	e0 81 03 18 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a97a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a97e:	ed b5 00 08 	bld	r5,0x8
8000a982:	c0 b0       	breq	8000a998 <_vfprintf_r+0x18f0>
8000a984:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a988:	87 12       	st.w	r3[0x4],r2
8000a98a:	87 06       	st.w	r3[0x0],r6
8000a98c:	f0 02 00 02 	add	r2,r8,r2
8000a990:	fb 42 06 90 	st.w	sp[1680],r2
8000a994:	e0 8f 01 d4 	bral	8000ad3c <_vfprintf_r+0x1c94>
8000a998:	e0 40 00 65 	cp.w	r0,101
8000a99c:	e0 8a 01 d6 	brle	8000ad48 <_vfprintf_r+0x1ca0>
8000a9a0:	30 08       	mov	r8,0
8000a9a2:	30 09       	mov	r9,0
8000a9a4:	40 5b       	lddsp	r11,sp[0x14]
8000a9a6:	40 7a       	lddsp	r10,sp[0x1c]
8000a9a8:	e0 a0 15 3b 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000a9ac:	c7 90       	breq	8000aa9e <_vfprintf_r+0x19f6>
8000a9ae:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9b2:	fe c9 b6 3a 	sub	r9,pc,-18886
8000a9b6:	2f f8       	sub	r8,-1
8000a9b8:	87 09       	st.w	r3[0x0],r9
8000a9ba:	fb 48 06 90 	st.w	sp[1680],r8
8000a9be:	30 19       	mov	r9,1
8000a9c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9c4:	87 19       	st.w	r3[0x4],r9
8000a9c6:	2f f8       	sub	r8,-1
8000a9c8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9cc:	58 78       	cp.w	r8,7
8000a9ce:	e0 89 00 05 	brgt	8000a9d8 <_vfprintf_r+0x1930>
8000a9d2:	2f 83       	sub	r3,-8
8000a9d4:	c0 c8       	rjmp	8000a9ec <_vfprintf_r+0x1944>
8000a9d6:	d7 03       	nop
8000a9d8:	fa ca f9 78 	sub	r10,sp,-1672
8000a9dc:	02 9b       	mov	r11,r1
8000a9de:	08 9c       	mov	r12,r4
8000a9e0:	fe b0 f3 56 	rcall	8000908c <__sprint_r>
8000a9e4:	e0 81 02 e1 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000a9e8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9ec:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a9f0:	40 6c       	lddsp	r12,sp[0x18]
8000a9f2:	18 38       	cp.w	r8,r12
8000a9f4:	c0 55       	brlt	8000a9fe <_vfprintf_r+0x1956>
8000a9f6:	ed b5 00 00 	bld	r5,0x0
8000a9fa:	e0 81 02 6b 	brne	8000aed0 <_vfprintf_r+0x1e28>
8000a9fe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa02:	2f f8       	sub	r8,-1
8000aa04:	40 cb       	lddsp	r11,sp[0x30]
8000aa06:	fb 48 06 90 	st.w	sp[1680],r8
8000aa0a:	30 19       	mov	r9,1
8000aa0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa10:	87 0b       	st.w	r3[0x0],r11
8000aa12:	2f f8       	sub	r8,-1
8000aa14:	87 19       	st.w	r3[0x4],r9
8000aa16:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa1a:	58 78       	cp.w	r8,7
8000aa1c:	e0 89 00 04 	brgt	8000aa24 <_vfprintf_r+0x197c>
8000aa20:	2f 83       	sub	r3,-8
8000aa22:	c0 b8       	rjmp	8000aa38 <_vfprintf_r+0x1990>
8000aa24:	fa ca f9 78 	sub	r10,sp,-1672
8000aa28:	02 9b       	mov	r11,r1
8000aa2a:	08 9c       	mov	r12,r4
8000aa2c:	fe b0 f3 30 	rcall	8000908c <__sprint_r>
8000aa30:	e0 81 02 bb 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000aa34:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa38:	40 66       	lddsp	r6,sp[0x18]
8000aa3a:	20 16       	sub	r6,1
8000aa3c:	58 06       	cp.w	r6,0
8000aa3e:	e0 89 00 1d 	brgt	8000aa78 <_vfprintf_r+0x19d0>
8000aa42:	e0 8f 02 47 	bral	8000aed0 <_vfprintf_r+0x1e28>
8000aa46:	2f 09       	sub	r9,-16
8000aa48:	2f f8       	sub	r8,-1
8000aa4a:	fb 49 06 90 	st.w	sp[1680],r9
8000aa4e:	87 02       	st.w	r3[0x0],r2
8000aa50:	87 10       	st.w	r3[0x4],r0
8000aa52:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa56:	58 78       	cp.w	r8,7
8000aa58:	e0 89 00 04 	brgt	8000aa60 <_vfprintf_r+0x19b8>
8000aa5c:	2f 83       	sub	r3,-8
8000aa5e:	c0 b8       	rjmp	8000aa74 <_vfprintf_r+0x19cc>
8000aa60:	fa ca f9 78 	sub	r10,sp,-1672
8000aa64:	02 9b       	mov	r11,r1
8000aa66:	08 9c       	mov	r12,r4
8000aa68:	fe b0 f3 12 	rcall	8000908c <__sprint_r>
8000aa6c:	e0 81 02 9d 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000aa70:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa74:	21 06       	sub	r6,16
8000aa76:	c0 48       	rjmp	8000aa7e <_vfprintf_r+0x19d6>
8000aa78:	fe c2 b6 ec 	sub	r2,pc,-18708
8000aa7c:	31 00       	mov	r0,16
8000aa7e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa82:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa86:	fe ca b6 fa 	sub	r10,pc,-18694
8000aa8a:	59 06       	cp.w	r6,16
8000aa8c:	fe 99 ff dd 	brgt	8000aa46 <_vfprintf_r+0x199e>
8000aa90:	0c 09       	add	r9,r6
8000aa92:	87 0a       	st.w	r3[0x0],r10
8000aa94:	fb 49 06 90 	st.w	sp[1680],r9
8000aa98:	2f f8       	sub	r8,-1
8000aa9a:	87 16       	st.w	r3[0x4],r6
8000aa9c:	c5 39       	rjmp	8000ad42 <_vfprintf_r+0x1c9a>
8000aa9e:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000aaa2:	58 0a       	cp.w	r10,0
8000aaa4:	e0 89 00 92 	brgt	8000abc8 <_vfprintf_r+0x1b20>
8000aaa8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aaac:	fe c9 b7 34 	sub	r9,pc,-18636
8000aab0:	2f f8       	sub	r8,-1
8000aab2:	87 09       	st.w	r3[0x0],r9
8000aab4:	fb 48 06 90 	st.w	sp[1680],r8
8000aab8:	30 19       	mov	r9,1
8000aaba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aabe:	87 19       	st.w	r3[0x4],r9
8000aac0:	2f f8       	sub	r8,-1
8000aac2:	fb 48 06 8c 	st.w	sp[1676],r8
8000aac6:	58 78       	cp.w	r8,7
8000aac8:	e0 89 00 04 	brgt	8000aad0 <_vfprintf_r+0x1a28>
8000aacc:	2f 83       	sub	r3,-8
8000aace:	c0 b8       	rjmp	8000aae4 <_vfprintf_r+0x1a3c>
8000aad0:	fa ca f9 78 	sub	r10,sp,-1672
8000aad4:	02 9b       	mov	r11,r1
8000aad6:	08 9c       	mov	r12,r4
8000aad8:	fe b0 f2 da 	rcall	8000908c <__sprint_r>
8000aadc:	e0 81 02 65 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000aae0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aae4:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aae8:	58 08       	cp.w	r8,0
8000aaea:	c0 81       	brne	8000aafa <_vfprintf_r+0x1a52>
8000aaec:	40 6a       	lddsp	r10,sp[0x18]
8000aaee:	58 0a       	cp.w	r10,0
8000aaf0:	c0 51       	brne	8000aafa <_vfprintf_r+0x1a52>
8000aaf2:	ed b5 00 00 	bld	r5,0x0
8000aaf6:	e0 81 01 ed 	brne	8000aed0 <_vfprintf_r+0x1e28>
8000aafa:	40 c9       	lddsp	r9,sp[0x30]
8000aafc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab00:	2f f8       	sub	r8,-1
8000ab02:	87 09       	st.w	r3[0x0],r9
8000ab04:	fb 48 06 90 	st.w	sp[1680],r8
8000ab08:	30 19       	mov	r9,1
8000ab0a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab0e:	87 19       	st.w	r3[0x4],r9
8000ab10:	2f f8       	sub	r8,-1
8000ab12:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab16:	58 78       	cp.w	r8,7
8000ab18:	e0 89 00 04 	brgt	8000ab20 <_vfprintf_r+0x1a78>
8000ab1c:	2f 83       	sub	r3,-8
8000ab1e:	c0 b8       	rjmp	8000ab34 <_vfprintf_r+0x1a8c>
8000ab20:	fa ca f9 78 	sub	r10,sp,-1672
8000ab24:	02 9b       	mov	r11,r1
8000ab26:	08 9c       	mov	r12,r4
8000ab28:	fe b0 f2 b2 	rcall	8000908c <__sprint_r>
8000ab2c:	e0 81 02 3d 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ab30:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab34:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab38:	5c 32       	neg	r2
8000ab3a:	58 02       	cp.w	r2,0
8000ab3c:	e0 89 00 1d 	brgt	8000ab76 <_vfprintf_r+0x1ace>
8000ab40:	c3 d8       	rjmp	8000abba <_vfprintf_r+0x1b12>
8000ab42:	2f 09       	sub	r9,-16
8000ab44:	2f f8       	sub	r8,-1
8000ab46:	31 0e       	mov	lr,16
8000ab48:	fb 49 06 90 	st.w	sp[1680],r9
8000ab4c:	87 00       	st.w	r3[0x0],r0
8000ab4e:	87 1e       	st.w	r3[0x4],lr
8000ab50:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab54:	58 78       	cp.w	r8,7
8000ab56:	e0 89 00 04 	brgt	8000ab5e <_vfprintf_r+0x1ab6>
8000ab5a:	2f 83       	sub	r3,-8
8000ab5c:	c0 b8       	rjmp	8000ab72 <_vfprintf_r+0x1aca>
8000ab5e:	fa ca f9 78 	sub	r10,sp,-1672
8000ab62:	02 9b       	mov	r11,r1
8000ab64:	08 9c       	mov	r12,r4
8000ab66:	fe b0 f2 93 	rcall	8000908c <__sprint_r>
8000ab6a:	e0 81 02 1e 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ab6e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab72:	21 02       	sub	r2,16
8000ab74:	c0 38       	rjmp	8000ab7a <_vfprintf_r+0x1ad2>
8000ab76:	fe c0 b7 ea 	sub	r0,pc,-18454
8000ab7a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab82:	fe ca b7 f6 	sub	r10,pc,-18442
8000ab86:	59 02       	cp.w	r2,16
8000ab88:	fe 99 ff dd 	brgt	8000ab42 <_vfprintf_r+0x1a9a>
8000ab8c:	04 09       	add	r9,r2
8000ab8e:	2f f8       	sub	r8,-1
8000ab90:	87 0a       	st.w	r3[0x0],r10
8000ab92:	fb 49 06 90 	st.w	sp[1680],r9
8000ab96:	87 12       	st.w	r3[0x4],r2
8000ab98:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab9c:	58 78       	cp.w	r8,7
8000ab9e:	e0 89 00 04 	brgt	8000aba6 <_vfprintf_r+0x1afe>
8000aba2:	2f 83       	sub	r3,-8
8000aba4:	c0 b8       	rjmp	8000abba <_vfprintf_r+0x1b12>
8000aba6:	fa ca f9 78 	sub	r10,sp,-1672
8000abaa:	02 9b       	mov	r11,r1
8000abac:	08 9c       	mov	r12,r4
8000abae:	fe b0 f2 6f 	rcall	8000908c <__sprint_r>
8000abb2:	e0 81 01 fa 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000abb6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abba:	40 6c       	lddsp	r12,sp[0x18]
8000abbc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000abc0:	87 06       	st.w	r3[0x0],r6
8000abc2:	87 1c       	st.w	r3[0x4],r12
8000abc4:	18 08       	add	r8,r12
8000abc6:	cb 98       	rjmp	8000ad38 <_vfprintf_r+0x1c90>
8000abc8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000abcc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abd0:	40 6b       	lddsp	r11,sp[0x18]
8000abd2:	16 3a       	cp.w	r10,r11
8000abd4:	c6 f5       	brlt	8000acb2 <_vfprintf_r+0x1c0a>
8000abd6:	16 09       	add	r9,r11
8000abd8:	2f f8       	sub	r8,-1
8000abda:	87 06       	st.w	r3[0x0],r6
8000abdc:	fb 49 06 90 	st.w	sp[1680],r9
8000abe0:	87 1b       	st.w	r3[0x4],r11
8000abe2:	fb 48 06 8c 	st.w	sp[1676],r8
8000abe6:	58 78       	cp.w	r8,7
8000abe8:	e0 89 00 04 	brgt	8000abf0 <_vfprintf_r+0x1b48>
8000abec:	2f 83       	sub	r3,-8
8000abee:	c0 b8       	rjmp	8000ac04 <_vfprintf_r+0x1b5c>
8000abf0:	fa ca f9 78 	sub	r10,sp,-1672
8000abf4:	02 9b       	mov	r11,r1
8000abf6:	08 9c       	mov	r12,r4
8000abf8:	fe b0 f2 4a 	rcall	8000908c <__sprint_r>
8000abfc:	e0 81 01 d5 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ac00:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac04:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ac08:	40 6a       	lddsp	r10,sp[0x18]
8000ac0a:	14 16       	sub	r6,r10
8000ac0c:	58 06       	cp.w	r6,0
8000ac0e:	e0 89 00 1c 	brgt	8000ac46 <_vfprintf_r+0x1b9e>
8000ac12:	c3 d8       	rjmp	8000ac8c <_vfprintf_r+0x1be4>
8000ac14:	2f 09       	sub	r9,-16
8000ac16:	2f f8       	sub	r8,-1
8000ac18:	fb 49 06 90 	st.w	sp[1680],r9
8000ac1c:	87 02       	st.w	r3[0x0],r2
8000ac1e:	87 10       	st.w	r3[0x4],r0
8000ac20:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac24:	58 78       	cp.w	r8,7
8000ac26:	e0 89 00 04 	brgt	8000ac2e <_vfprintf_r+0x1b86>
8000ac2a:	2f 83       	sub	r3,-8
8000ac2c:	c0 b8       	rjmp	8000ac42 <_vfprintf_r+0x1b9a>
8000ac2e:	fa ca f9 78 	sub	r10,sp,-1672
8000ac32:	02 9b       	mov	r11,r1
8000ac34:	08 9c       	mov	r12,r4
8000ac36:	fe b0 f2 2b 	rcall	8000908c <__sprint_r>
8000ac3a:	e0 81 01 b6 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ac3e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac42:	21 06       	sub	r6,16
8000ac44:	c0 48       	rjmp	8000ac4c <_vfprintf_r+0x1ba4>
8000ac46:	fe c2 b8 ba 	sub	r2,pc,-18246
8000ac4a:	31 00       	mov	r0,16
8000ac4c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ac50:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac54:	fe ca b8 c8 	sub	r10,pc,-18232
8000ac58:	59 06       	cp.w	r6,16
8000ac5a:	fe 99 ff dd 	brgt	8000ac14 <_vfprintf_r+0x1b6c>
8000ac5e:	0c 09       	add	r9,r6
8000ac60:	2f f8       	sub	r8,-1
8000ac62:	87 0a       	st.w	r3[0x0],r10
8000ac64:	fb 49 06 90 	st.w	sp[1680],r9
8000ac68:	87 16       	st.w	r3[0x4],r6
8000ac6a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac6e:	58 78       	cp.w	r8,7
8000ac70:	e0 89 00 04 	brgt	8000ac78 <_vfprintf_r+0x1bd0>
8000ac74:	2f 83       	sub	r3,-8
8000ac76:	c0 b8       	rjmp	8000ac8c <_vfprintf_r+0x1be4>
8000ac78:	fa ca f9 78 	sub	r10,sp,-1672
8000ac7c:	02 9b       	mov	r11,r1
8000ac7e:	08 9c       	mov	r12,r4
8000ac80:	fe b0 f2 06 	rcall	8000908c <__sprint_r>
8000ac84:	e0 81 01 91 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ac88:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac8c:	ed b5 00 00 	bld	r5,0x0
8000ac90:	e0 81 01 20 	brne	8000aed0 <_vfprintf_r+0x1e28>
8000ac94:	40 c9       	lddsp	r9,sp[0x30]
8000ac96:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac9a:	2f f8       	sub	r8,-1
8000ac9c:	87 09       	st.w	r3[0x0],r9
8000ac9e:	fb 48 06 90 	st.w	sp[1680],r8
8000aca2:	30 19       	mov	r9,1
8000aca4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aca8:	87 19       	st.w	r3[0x4],r9
8000acaa:	2f f8       	sub	r8,-1
8000acac:	fb 48 06 8c 	st.w	sp[1676],r8
8000acb0:	c0 29       	rjmp	8000aeb4 <_vfprintf_r+0x1e0c>
8000acb2:	14 09       	add	r9,r10
8000acb4:	2f f8       	sub	r8,-1
8000acb6:	fb 49 06 90 	st.w	sp[1680],r9
8000acba:	87 06       	st.w	r3[0x0],r6
8000acbc:	87 1a       	st.w	r3[0x4],r10
8000acbe:	fb 48 06 8c 	st.w	sp[1676],r8
8000acc2:	58 78       	cp.w	r8,7
8000acc4:	e0 89 00 04 	brgt	8000accc <_vfprintf_r+0x1c24>
8000acc8:	2f 83       	sub	r3,-8
8000acca:	c0 b8       	rjmp	8000ace0 <_vfprintf_r+0x1c38>
8000accc:	fa ca f9 78 	sub	r10,sp,-1672
8000acd0:	02 9b       	mov	r11,r1
8000acd2:	08 9c       	mov	r12,r4
8000acd4:	fe b0 f1 dc 	rcall	8000908c <__sprint_r>
8000acd8:	e0 81 01 67 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000acdc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ace0:	40 c8       	lddsp	r8,sp[0x30]
8000ace2:	87 08       	st.w	r3[0x0],r8
8000ace4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ace8:	2f f8       	sub	r8,-1
8000acea:	30 19       	mov	r9,1
8000acec:	fb 48 06 90 	st.w	sp[1680],r8
8000acf0:	87 19       	st.w	r3[0x4],r9
8000acf2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acf6:	2f f8       	sub	r8,-1
8000acf8:	fb 48 06 8c 	st.w	sp[1676],r8
8000acfc:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ad00:	58 78       	cp.w	r8,7
8000ad02:	e0 89 00 04 	brgt	8000ad0a <_vfprintf_r+0x1c62>
8000ad06:	2f 83       	sub	r3,-8
8000ad08:	c0 b8       	rjmp	8000ad1e <_vfprintf_r+0x1c76>
8000ad0a:	fa ca f9 78 	sub	r10,sp,-1672
8000ad0e:	02 9b       	mov	r11,r1
8000ad10:	08 9c       	mov	r12,r4
8000ad12:	fe b0 f1 bd 	rcall	8000908c <__sprint_r>
8000ad16:	e0 81 01 48 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ad1a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad1e:	04 06       	add	r6,r2
8000ad20:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ad24:	87 06       	st.w	r3[0x0],r6
8000ad26:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad2a:	40 66       	lddsp	r6,sp[0x18]
8000ad2c:	40 6e       	lddsp	lr,sp[0x18]
8000ad2e:	10 16       	sub	r6,r8
8000ad30:	f2 08 01 08 	sub	r8,r9,r8
8000ad34:	87 16       	st.w	r3[0x4],r6
8000ad36:	1c 08       	add	r8,lr
8000ad38:	fb 48 06 90 	st.w	sp[1680],r8
8000ad3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad40:	2f f8       	sub	r8,-1
8000ad42:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad46:	cb 78       	rjmp	8000aeb4 <_vfprintf_r+0x1e0c>
8000ad48:	40 6c       	lddsp	r12,sp[0x18]
8000ad4a:	58 1c       	cp.w	r12,1
8000ad4c:	e0 89 00 06 	brgt	8000ad58 <_vfprintf_r+0x1cb0>
8000ad50:	ed b5 00 00 	bld	r5,0x0
8000ad54:	e0 81 00 85 	brne	8000ae5e <_vfprintf_r+0x1db6>
8000ad58:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad5c:	2f f8       	sub	r8,-1
8000ad5e:	30 19       	mov	r9,1
8000ad60:	fb 48 06 90 	st.w	sp[1680],r8
8000ad64:	87 06       	st.w	r3[0x0],r6
8000ad66:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad6a:	87 19       	st.w	r3[0x4],r9
8000ad6c:	2f f8       	sub	r8,-1
8000ad6e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad72:	58 78       	cp.w	r8,7
8000ad74:	e0 89 00 04 	brgt	8000ad7c <_vfprintf_r+0x1cd4>
8000ad78:	2f 83       	sub	r3,-8
8000ad7a:	c0 b8       	rjmp	8000ad90 <_vfprintf_r+0x1ce8>
8000ad7c:	fa ca f9 78 	sub	r10,sp,-1672
8000ad80:	02 9b       	mov	r11,r1
8000ad82:	08 9c       	mov	r12,r4
8000ad84:	fe b0 f1 84 	rcall	8000908c <__sprint_r>
8000ad88:	e0 81 01 0f 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ad8c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad90:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad94:	2f f8       	sub	r8,-1
8000ad96:	40 cb       	lddsp	r11,sp[0x30]
8000ad98:	fb 48 06 90 	st.w	sp[1680],r8
8000ad9c:	30 19       	mov	r9,1
8000ad9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ada2:	87 0b       	st.w	r3[0x0],r11
8000ada4:	2f f8       	sub	r8,-1
8000ada6:	87 19       	st.w	r3[0x4],r9
8000ada8:	fb 48 06 8c 	st.w	sp[1676],r8
8000adac:	58 78       	cp.w	r8,7
8000adae:	e0 89 00 05 	brgt	8000adb8 <_vfprintf_r+0x1d10>
8000adb2:	2f 83       	sub	r3,-8
8000adb4:	c0 c8       	rjmp	8000adcc <_vfprintf_r+0x1d24>
8000adb6:	d7 03       	nop
8000adb8:	fa ca f9 78 	sub	r10,sp,-1672
8000adbc:	02 9b       	mov	r11,r1
8000adbe:	08 9c       	mov	r12,r4
8000adc0:	fe b0 f1 66 	rcall	8000908c <__sprint_r>
8000adc4:	e0 81 00 f1 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000adc8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adcc:	30 08       	mov	r8,0
8000adce:	30 09       	mov	r9,0
8000add0:	40 5b       	lddsp	r11,sp[0x14]
8000add2:	40 7a       	lddsp	r10,sp[0x1c]
8000add4:	e0 a0 13 25 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000add8:	40 68       	lddsp	r8,sp[0x18]
8000adda:	20 18       	sub	r8,1
8000addc:	58 0c       	cp.w	r12,0
8000adde:	c0 d1       	brne	8000adf8 <_vfprintf_r+0x1d50>
8000ade0:	2f f6       	sub	r6,-1
8000ade2:	87 18       	st.w	r3[0x4],r8
8000ade4:	87 06       	st.w	r3[0x0],r6
8000ade6:	fa f6 06 90 	ld.w	r6,sp[1680]
8000adea:	10 06       	add	r6,r8
8000adec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000adf0:	fb 46 06 90 	st.w	sp[1680],r6
8000adf4:	2f f8       	sub	r8,-1
8000adf6:	c3 18       	rjmp	8000ae58 <_vfprintf_r+0x1db0>
8000adf8:	10 96       	mov	r6,r8
8000adfa:	58 08       	cp.w	r8,0
8000adfc:	e0 89 00 1c 	brgt	8000ae34 <_vfprintf_r+0x1d8c>
8000ae00:	c4 b8       	rjmp	8000ae96 <_vfprintf_r+0x1dee>
8000ae02:	2f 09       	sub	r9,-16
8000ae04:	2f f8       	sub	r8,-1
8000ae06:	fb 49 06 90 	st.w	sp[1680],r9
8000ae0a:	87 02       	st.w	r3[0x0],r2
8000ae0c:	87 10       	st.w	r3[0x4],r0
8000ae0e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae12:	58 78       	cp.w	r8,7
8000ae14:	e0 89 00 04 	brgt	8000ae1c <_vfprintf_r+0x1d74>
8000ae18:	2f 83       	sub	r3,-8
8000ae1a:	c0 b8       	rjmp	8000ae30 <_vfprintf_r+0x1d88>
8000ae1c:	fa ca f9 78 	sub	r10,sp,-1672
8000ae20:	02 9b       	mov	r11,r1
8000ae22:	08 9c       	mov	r12,r4
8000ae24:	fe b0 f1 34 	rcall	8000908c <__sprint_r>
8000ae28:	e0 81 00 bf 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ae2c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae30:	21 06       	sub	r6,16
8000ae32:	c0 48       	rjmp	8000ae3a <_vfprintf_r+0x1d92>
8000ae34:	fe c2 ba a8 	sub	r2,pc,-17752
8000ae38:	31 00       	mov	r0,16
8000ae3a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ae3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae42:	fe ca ba b6 	sub	r10,pc,-17738
8000ae46:	59 06       	cp.w	r6,16
8000ae48:	fe 99 ff dd 	brgt	8000ae02 <_vfprintf_r+0x1d5a>
8000ae4c:	0c 09       	add	r9,r6
8000ae4e:	87 0a       	st.w	r3[0x0],r10
8000ae50:	fb 49 06 90 	st.w	sp[1680],r9
8000ae54:	2f f8       	sub	r8,-1
8000ae56:	87 16       	st.w	r3[0x4],r6
8000ae58:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae5c:	c0 e8       	rjmp	8000ae78 <_vfprintf_r+0x1dd0>
8000ae5e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae62:	2f f8       	sub	r8,-1
8000ae64:	30 19       	mov	r9,1
8000ae66:	fb 48 06 90 	st.w	sp[1680],r8
8000ae6a:	87 06       	st.w	r3[0x0],r6
8000ae6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae70:	87 19       	st.w	r3[0x4],r9
8000ae72:	2f f8       	sub	r8,-1
8000ae74:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae78:	58 78       	cp.w	r8,7
8000ae7a:	e0 89 00 04 	brgt	8000ae82 <_vfprintf_r+0x1dda>
8000ae7e:	2f 83       	sub	r3,-8
8000ae80:	c0 b8       	rjmp	8000ae96 <_vfprintf_r+0x1dee>
8000ae82:	fa ca f9 78 	sub	r10,sp,-1672
8000ae86:	02 9b       	mov	r11,r1
8000ae88:	08 9c       	mov	r12,r4
8000ae8a:	fe b0 f1 01 	rcall	8000908c <__sprint_r>
8000ae8e:	e0 81 00 8c 	brne	8000afa6 <_vfprintf_r+0x1efe>
8000ae92:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae96:	40 ea       	lddsp	r10,sp[0x38]
8000ae98:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae9c:	14 08       	add	r8,r10
8000ae9e:	fa c9 f9 64 	sub	r9,sp,-1692
8000aea2:	fb 48 06 90 	st.w	sp[1680],r8
8000aea6:	87 1a       	st.w	r3[0x4],r10
8000aea8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aeac:	87 09       	st.w	r3[0x0],r9
8000aeae:	2f f8       	sub	r8,-1
8000aeb0:	fb 48 06 8c 	st.w	sp[1676],r8
8000aeb4:	58 78       	cp.w	r8,7
8000aeb6:	e0 89 00 04 	brgt	8000aebe <_vfprintf_r+0x1e16>
8000aeba:	2f 83       	sub	r3,-8
8000aebc:	c0 a8       	rjmp	8000aed0 <_vfprintf_r+0x1e28>
8000aebe:	fa ca f9 78 	sub	r10,sp,-1672
8000aec2:	02 9b       	mov	r11,r1
8000aec4:	08 9c       	mov	r12,r4
8000aec6:	fe b0 f0 e3 	rcall	8000908c <__sprint_r>
8000aeca:	c6 e1       	brne	8000afa6 <_vfprintf_r+0x1efe>
8000aecc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aed0:	e2 15 00 04 	andl	r5,0x4,COH
8000aed4:	c3 f0       	breq	8000af52 <_vfprintf_r+0x1eaa>
8000aed6:	40 86       	lddsp	r6,sp[0x20]
8000aed8:	40 39       	lddsp	r9,sp[0xc]
8000aeda:	12 16       	sub	r6,r9
8000aedc:	58 06       	cp.w	r6,0
8000aede:	e0 89 00 1a 	brgt	8000af12 <_vfprintf_r+0x1e6a>
8000aee2:	c3 88       	rjmp	8000af52 <_vfprintf_r+0x1eaa>
8000aee4:	2f 09       	sub	r9,-16
8000aee6:	2f f8       	sub	r8,-1
8000aee8:	fb 49 06 90 	st.w	sp[1680],r9
8000aeec:	87 05       	st.w	r3[0x0],r5
8000aeee:	87 12       	st.w	r3[0x4],r2
8000aef0:	fb 48 06 8c 	st.w	sp[1676],r8
8000aef4:	58 78       	cp.w	r8,7
8000aef6:	e0 89 00 04 	brgt	8000aefe <_vfprintf_r+0x1e56>
8000aefa:	2f 83       	sub	r3,-8
8000aefc:	c0 98       	rjmp	8000af0e <_vfprintf_r+0x1e66>
8000aefe:	00 9a       	mov	r10,r0
8000af00:	02 9b       	mov	r11,r1
8000af02:	08 9c       	mov	r12,r4
8000af04:	fe b0 f0 c4 	rcall	8000908c <__sprint_r>
8000af08:	c4 f1       	brne	8000afa6 <_vfprintf_r+0x1efe>
8000af0a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af0e:	21 06       	sub	r6,16
8000af10:	c0 68       	rjmp	8000af1c <_vfprintf_r+0x1e74>
8000af12:	fe c5 bb 96 	sub	r5,pc,-17514
8000af16:	31 02       	mov	r2,16
8000af18:	fa c0 f9 78 	sub	r0,sp,-1672
8000af1c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000af20:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af24:	fe ca bb a8 	sub	r10,pc,-17496
8000af28:	59 06       	cp.w	r6,16
8000af2a:	fe 99 ff dd 	brgt	8000aee4 <_vfprintf_r+0x1e3c>
8000af2e:	0c 09       	add	r9,r6
8000af30:	2f f8       	sub	r8,-1
8000af32:	87 0a       	st.w	r3[0x0],r10
8000af34:	87 16       	st.w	r3[0x4],r6
8000af36:	fb 49 06 90 	st.w	sp[1680],r9
8000af3a:	fb 48 06 8c 	st.w	sp[1676],r8
8000af3e:	58 78       	cp.w	r8,7
8000af40:	e0 8a 00 09 	brle	8000af52 <_vfprintf_r+0x1eaa>
8000af44:	fa ca f9 78 	sub	r10,sp,-1672
8000af48:	02 9b       	mov	r11,r1
8000af4a:	08 9c       	mov	r12,r4
8000af4c:	fe b0 f0 a0 	rcall	8000908c <__sprint_r>
8000af50:	c2 b1       	brne	8000afa6 <_vfprintf_r+0x1efe>
8000af52:	40 bc       	lddsp	r12,sp[0x2c]
8000af54:	40 36       	lddsp	r6,sp[0xc]
8000af56:	40 8e       	lddsp	lr,sp[0x20]
8000af58:	ec 0e 0c 48 	max	r8,r6,lr
8000af5c:	10 0c       	add	r12,r8
8000af5e:	50 bc       	stdsp	sp[0x2c],r12
8000af60:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af64:	58 08       	cp.w	r8,0
8000af66:	c0 80       	breq	8000af76 <_vfprintf_r+0x1ece>
8000af68:	fa ca f9 78 	sub	r10,sp,-1672
8000af6c:	02 9b       	mov	r11,r1
8000af6e:	08 9c       	mov	r12,r4
8000af70:	fe b0 f0 8e 	rcall	8000908c <__sprint_r>
8000af74:	c1 91       	brne	8000afa6 <_vfprintf_r+0x1efe>
8000af76:	30 0b       	mov	r11,0
8000af78:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af7c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000af80:	fe 9f f1 22 	bral	800091c4 <_vfprintf_r+0x11c>
8000af84:	08 95       	mov	r5,r4
8000af86:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af8a:	58 08       	cp.w	r8,0
8000af8c:	c0 80       	breq	8000af9c <_vfprintf_r+0x1ef4>
8000af8e:	08 9c       	mov	r12,r4
8000af90:	fa ca f9 78 	sub	r10,sp,-1672
8000af94:	02 9b       	mov	r11,r1
8000af96:	fe b0 f0 7b 	rcall	8000908c <__sprint_r>
8000af9a:	c0 61       	brne	8000afa6 <_vfprintf_r+0x1efe>
8000af9c:	30 08       	mov	r8,0
8000af9e:	fb 48 06 8c 	st.w	sp[1676],r8
8000afa2:	c0 28       	rjmp	8000afa6 <_vfprintf_r+0x1efe>
8000afa4:	40 41       	lddsp	r1,sp[0x10]
8000afa6:	82 68       	ld.sh	r8,r1[0xc]
8000afa8:	ed b8 00 06 	bld	r8,0x6
8000afac:	c0 31       	brne	8000afb2 <_vfprintf_r+0x1f0a>
8000afae:	3f fa       	mov	r10,-1
8000afb0:	50 ba       	stdsp	sp[0x2c],r10
8000afb2:	40 bc       	lddsp	r12,sp[0x2c]
8000afb4:	fe 3d f9 44 	sub	sp,-1724
8000afb8:	d8 32       	popm	r0-r7,pc
8000afba:	d7 03       	nop

8000afbc <__swsetup_r>:
8000afbc:	d4 21       	pushm	r4-r7,lr
8000afbe:	e0 68 0a 54 	mov	r8,2644
8000afc2:	18 96       	mov	r6,r12
8000afc4:	16 97       	mov	r7,r11
8000afc6:	70 0c       	ld.w	r12,r8[0x0]
8000afc8:	58 0c       	cp.w	r12,0
8000afca:	c0 60       	breq	8000afd6 <__swsetup_r+0x1a>
8000afcc:	78 68       	ld.w	r8,r12[0x18]
8000afce:	58 08       	cp.w	r8,0
8000afd0:	c0 31       	brne	8000afd6 <__swsetup_r+0x1a>
8000afd2:	e0 a0 07 bf 	rcall	8000bf50 <__sinit>
8000afd6:	fe c8 bb 2a 	sub	r8,pc,-17622
8000afda:	10 37       	cp.w	r7,r8
8000afdc:	c0 61       	brne	8000afe8 <__swsetup_r+0x2c>
8000afde:	e0 68 0a 54 	mov	r8,2644
8000afe2:	70 08       	ld.w	r8,r8[0x0]
8000afe4:	70 07       	ld.w	r7,r8[0x0]
8000afe6:	c1 28       	rjmp	8000b00a <__swsetup_r+0x4e>
8000afe8:	fe c8 bb 1c 	sub	r8,pc,-17636
8000afec:	10 37       	cp.w	r7,r8
8000afee:	c0 61       	brne	8000affa <__swsetup_r+0x3e>
8000aff0:	e0 68 0a 54 	mov	r8,2644
8000aff4:	70 08       	ld.w	r8,r8[0x0]
8000aff6:	70 17       	ld.w	r7,r8[0x4]
8000aff8:	c0 98       	rjmp	8000b00a <__swsetup_r+0x4e>
8000affa:	fe c8 bb 0e 	sub	r8,pc,-17650
8000affe:	10 37       	cp.w	r7,r8
8000b000:	c0 51       	brne	8000b00a <__swsetup_r+0x4e>
8000b002:	e0 68 0a 54 	mov	r8,2644
8000b006:	70 08       	ld.w	r8,r8[0x0]
8000b008:	70 27       	ld.w	r7,r8[0x8]
8000b00a:	8e 68       	ld.sh	r8,r7[0xc]
8000b00c:	ed b8 00 03 	bld	r8,0x3
8000b010:	c1 e0       	breq	8000b04c <__swsetup_r+0x90>
8000b012:	ed b8 00 04 	bld	r8,0x4
8000b016:	c3 e1       	brne	8000b092 <__swsetup_r+0xd6>
8000b018:	ed b8 00 02 	bld	r8,0x2
8000b01c:	c1 51       	brne	8000b046 <__swsetup_r+0x8a>
8000b01e:	6e db       	ld.w	r11,r7[0x34]
8000b020:	58 0b       	cp.w	r11,0
8000b022:	c0 a0       	breq	8000b036 <__swsetup_r+0x7a>
8000b024:	ee c8 ff bc 	sub	r8,r7,-68
8000b028:	10 3b       	cp.w	r11,r8
8000b02a:	c0 40       	breq	8000b032 <__swsetup_r+0x76>
8000b02c:	0c 9c       	mov	r12,r6
8000b02e:	e0 a0 08 2b 	rcall	8000c084 <_free_r>
8000b032:	30 08       	mov	r8,0
8000b034:	8f d8       	st.w	r7[0x34],r8
8000b036:	8e 68       	ld.sh	r8,r7[0xc]
8000b038:	e0 18 ff db 	andl	r8,0xffdb
8000b03c:	ae 68       	st.h	r7[0xc],r8
8000b03e:	30 08       	mov	r8,0
8000b040:	8f 18       	st.w	r7[0x4],r8
8000b042:	6e 48       	ld.w	r8,r7[0x10]
8000b044:	8f 08       	st.w	r7[0x0],r8
8000b046:	8e 68       	ld.sh	r8,r7[0xc]
8000b048:	a3 b8       	sbr	r8,0x3
8000b04a:	ae 68       	st.h	r7[0xc],r8
8000b04c:	6e 48       	ld.w	r8,r7[0x10]
8000b04e:	58 08       	cp.w	r8,0
8000b050:	c0 b1       	brne	8000b066 <__swsetup_r+0xaa>
8000b052:	8e 68       	ld.sh	r8,r7[0xc]
8000b054:	e2 18 02 80 	andl	r8,0x280,COH
8000b058:	e0 48 02 00 	cp.w	r8,512
8000b05c:	c0 50       	breq	8000b066 <__swsetup_r+0xaa>
8000b05e:	0c 9c       	mov	r12,r6
8000b060:	0e 9b       	mov	r11,r7
8000b062:	e0 a0 0a 4b 	rcall	8000c4f8 <__smakebuf_r>
8000b066:	8e 69       	ld.sh	r9,r7[0xc]
8000b068:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000b06c:	c0 70       	breq	8000b07a <__swsetup_r+0xbe>
8000b06e:	30 08       	mov	r8,0
8000b070:	8f 28       	st.w	r7[0x8],r8
8000b072:	6e 58       	ld.w	r8,r7[0x14]
8000b074:	5c 38       	neg	r8
8000b076:	8f 68       	st.w	r7[0x18],r8
8000b078:	c0 68       	rjmp	8000b084 <__swsetup_r+0xc8>
8000b07a:	ed b9 00 01 	bld	r9,0x1
8000b07e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000b082:	8f 28       	st.w	r7[0x8],r8
8000b084:	6e 48       	ld.w	r8,r7[0x10]
8000b086:	58 08       	cp.w	r8,0
8000b088:	c0 61       	brne	8000b094 <__swsetup_r+0xd8>
8000b08a:	8e 68       	ld.sh	r8,r7[0xc]
8000b08c:	ed b8 00 07 	bld	r8,0x7
8000b090:	c0 21       	brne	8000b094 <__swsetup_r+0xd8>
8000b092:	dc 2a       	popm	r4-r7,pc,r12=-1
8000b094:	d8 2a       	popm	r4-r7,pc,r12=0
8000b096:	d7 03       	nop

8000b098 <quorem>:
8000b098:	d4 31       	pushm	r0-r7,lr
8000b09a:	20 2d       	sub	sp,8
8000b09c:	18 97       	mov	r7,r12
8000b09e:	78 48       	ld.w	r8,r12[0x10]
8000b0a0:	76 46       	ld.w	r6,r11[0x10]
8000b0a2:	0c 38       	cp.w	r8,r6
8000b0a4:	c0 34       	brge	8000b0aa <quorem+0x12>
8000b0a6:	30 0c       	mov	r12,0
8000b0a8:	c8 58       	rjmp	8000b1b2 <quorem+0x11a>
8000b0aa:	ec c2 ff fc 	sub	r2,r6,-4
8000b0ae:	f6 c3 ff ec 	sub	r3,r11,-20
8000b0b2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000b0b6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000b0ba:	2f f9       	sub	r9,-1
8000b0bc:	20 16       	sub	r6,1
8000b0be:	f8 09 0d 08 	divu	r8,r12,r9
8000b0c2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000b0c6:	ee c4 ff ec 	sub	r4,r7,-20
8000b0ca:	10 95       	mov	r5,r8
8000b0cc:	58 08       	cp.w	r8,0
8000b0ce:	c4 10       	breq	8000b150 <quorem+0xb8>
8000b0d0:	30 09       	mov	r9,0
8000b0d2:	06 9a       	mov	r10,r3
8000b0d4:	08 98       	mov	r8,r4
8000b0d6:	12 91       	mov	r1,r9
8000b0d8:	50 0b       	stdsp	sp[0x0],r11
8000b0da:	70 0e       	ld.w	lr,r8[0x0]
8000b0dc:	b1 8e       	lsr	lr,0x10
8000b0de:	50 1e       	stdsp	sp[0x4],lr
8000b0e0:	15 0e       	ld.w	lr,r10++
8000b0e2:	fc 00 16 10 	lsr	r0,lr,0x10
8000b0e6:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b0ea:	ea 0e 03 41 	mac	r1,r5,lr
8000b0ee:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000b0f2:	b1 81       	lsr	r1,0x10
8000b0f4:	40 1b       	lddsp	r11,sp[0x4]
8000b0f6:	ea 00 02 40 	mul	r0,r5,r0
8000b0fa:	e2 00 00 00 	add	r0,r1,r0
8000b0fe:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000b102:	02 1b       	sub	r11,r1
8000b104:	50 1b       	stdsp	sp[0x4],r11
8000b106:	70 0b       	ld.w	r11,r8[0x0]
8000b108:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000b10c:	02 09       	add	r9,r1
8000b10e:	f2 0e 01 0e 	sub	lr,r9,lr
8000b112:	b0 1e       	st.h	r8[0x2],lr
8000b114:	fc 09 14 10 	asr	r9,lr,0x10
8000b118:	40 1e       	lddsp	lr,sp[0x4]
8000b11a:	fc 09 00 09 	add	r9,lr,r9
8000b11e:	b0 09       	st.h	r8[0x0],r9
8000b120:	e0 01 16 10 	lsr	r1,r0,0x10
8000b124:	2f c8       	sub	r8,-4
8000b126:	b1 49       	asr	r9,0x10
8000b128:	04 3a       	cp.w	r10,r2
8000b12a:	fe 98 ff d8 	brls	8000b0da <quorem+0x42>
8000b12e:	40 0b       	lddsp	r11,sp[0x0]
8000b130:	58 0c       	cp.w	r12,0
8000b132:	c0 f1       	brne	8000b150 <quorem+0xb8>
8000b134:	ec c8 ff fb 	sub	r8,r6,-5
8000b138:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b13c:	c0 28       	rjmp	8000b140 <quorem+0xa8>
8000b13e:	20 16       	sub	r6,1
8000b140:	20 48       	sub	r8,4
8000b142:	08 38       	cp.w	r8,r4
8000b144:	e0 88 00 05 	brls	8000b14e <quorem+0xb6>
8000b148:	70 09       	ld.w	r9,r8[0x0]
8000b14a:	58 09       	cp.w	r9,0
8000b14c:	cf 90       	breq	8000b13e <quorem+0xa6>
8000b14e:	8f 46       	st.w	r7[0x10],r6
8000b150:	0e 9c       	mov	r12,r7
8000b152:	e0 a0 0a d2 	rcall	8000c6f6 <__mcmp>
8000b156:	c2 d5       	brlt	8000b1b0 <quorem+0x118>
8000b158:	2f f5       	sub	r5,-1
8000b15a:	08 98       	mov	r8,r4
8000b15c:	30 09       	mov	r9,0
8000b15e:	07 0b       	ld.w	r11,r3++
8000b160:	f6 0a 16 10 	lsr	r10,r11,0x10
8000b164:	70 0c       	ld.w	r12,r8[0x0]
8000b166:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b16a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b16e:	14 1e       	sub	lr,r10
8000b170:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b174:	16 1a       	sub	r10,r11
8000b176:	12 0a       	add	r10,r9
8000b178:	b0 1a       	st.h	r8[0x2],r10
8000b17a:	b1 4a       	asr	r10,0x10
8000b17c:	fc 0a 00 09 	add	r9,lr,r10
8000b180:	b0 09       	st.h	r8[0x0],r9
8000b182:	2f c8       	sub	r8,-4
8000b184:	b1 49       	asr	r9,0x10
8000b186:	04 33       	cp.w	r3,r2
8000b188:	fe 98 ff eb 	brls	8000b15e <quorem+0xc6>
8000b18c:	ec c8 ff fb 	sub	r8,r6,-5
8000b190:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b194:	58 09       	cp.w	r9,0
8000b196:	c0 d1       	brne	8000b1b0 <quorem+0x118>
8000b198:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b19c:	c0 28       	rjmp	8000b1a0 <quorem+0x108>
8000b19e:	20 16       	sub	r6,1
8000b1a0:	20 48       	sub	r8,4
8000b1a2:	08 38       	cp.w	r8,r4
8000b1a4:	e0 88 00 05 	brls	8000b1ae <quorem+0x116>
8000b1a8:	70 09       	ld.w	r9,r8[0x0]
8000b1aa:	58 09       	cp.w	r9,0
8000b1ac:	cf 90       	breq	8000b19e <quorem+0x106>
8000b1ae:	8f 46       	st.w	r7[0x10],r6
8000b1b0:	0a 9c       	mov	r12,r5
8000b1b2:	2f ed       	sub	sp,-8
8000b1b4:	d8 32       	popm	r0-r7,pc
8000b1b6:	d7 03       	nop

8000b1b8 <_dtoa_r>:
8000b1b8:	d4 31       	pushm	r0-r7,lr
8000b1ba:	21 ad       	sub	sp,104
8000b1bc:	fa c4 ff 74 	sub	r4,sp,-140
8000b1c0:	18 97       	mov	r7,r12
8000b1c2:	16 95       	mov	r5,r11
8000b1c4:	68 2c       	ld.w	r12,r4[0x8]
8000b1c6:	50 c9       	stdsp	sp[0x30],r9
8000b1c8:	68 16       	ld.w	r6,r4[0x4]
8000b1ca:	68 09       	ld.w	r9,r4[0x0]
8000b1cc:	50 e8       	stdsp	sp[0x38],r8
8000b1ce:	14 94       	mov	r4,r10
8000b1d0:	51 2c       	stdsp	sp[0x48],r12
8000b1d2:	fa e5 00 08 	st.d	sp[8],r4
8000b1d6:	51 59       	stdsp	sp[0x54],r9
8000b1d8:	6e 95       	ld.w	r5,r7[0x24]
8000b1da:	58 05       	cp.w	r5,0
8000b1dc:	c0 91       	brne	8000b1ee <_dtoa_r+0x36>
8000b1de:	31 0c       	mov	r12,16
8000b1e0:	fe b0 e8 e2 	rcall	800083a4 <malloc>
8000b1e4:	99 35       	st.w	r12[0xc],r5
8000b1e6:	8f 9c       	st.w	r7[0x24],r12
8000b1e8:	99 15       	st.w	r12[0x4],r5
8000b1ea:	99 25       	st.w	r12[0x8],r5
8000b1ec:	99 05       	st.w	r12[0x0],r5
8000b1ee:	6e 99       	ld.w	r9,r7[0x24]
8000b1f0:	72 08       	ld.w	r8,r9[0x0]
8000b1f2:	58 08       	cp.w	r8,0
8000b1f4:	c0 f0       	breq	8000b212 <_dtoa_r+0x5a>
8000b1f6:	72 1a       	ld.w	r10,r9[0x4]
8000b1f8:	91 1a       	st.w	r8[0x4],r10
8000b1fa:	30 1a       	mov	r10,1
8000b1fc:	72 19       	ld.w	r9,r9[0x4]
8000b1fe:	f4 09 09 49 	lsl	r9,r10,r9
8000b202:	10 9b       	mov	r11,r8
8000b204:	91 29       	st.w	r8[0x8],r9
8000b206:	0e 9c       	mov	r12,r7
8000b208:	e0 a0 0a 90 	rcall	8000c728 <_Bfree>
8000b20c:	6e 98       	ld.w	r8,r7[0x24]
8000b20e:	30 09       	mov	r9,0
8000b210:	91 09       	st.w	r8[0x0],r9
8000b212:	40 28       	lddsp	r8,sp[0x8]
8000b214:	10 94       	mov	r4,r8
8000b216:	58 08       	cp.w	r8,0
8000b218:	c0 64       	brge	8000b224 <_dtoa_r+0x6c>
8000b21a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b21e:	50 28       	stdsp	sp[0x8],r8
8000b220:	30 18       	mov	r8,1
8000b222:	c0 28       	rjmp	8000b226 <_dtoa_r+0x6e>
8000b224:	30 08       	mov	r8,0
8000b226:	8d 08       	st.w	r6[0x0],r8
8000b228:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b22c:	40 26       	lddsp	r6,sp[0x8]
8000b22e:	0c 98       	mov	r8,r6
8000b230:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b234:	18 38       	cp.w	r8,r12
8000b236:	c2 01       	brne	8000b276 <_dtoa_r+0xbe>
8000b238:	e0 68 27 0f 	mov	r8,9999
8000b23c:	41 5b       	lddsp	r11,sp[0x54]
8000b23e:	97 08       	st.w	r11[0x0],r8
8000b240:	40 3a       	lddsp	r10,sp[0xc]
8000b242:	58 0a       	cp.w	r10,0
8000b244:	c0 71       	brne	8000b252 <_dtoa_r+0x9a>
8000b246:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b24a:	c0 41       	brne	8000b252 <_dtoa_r+0x9a>
8000b24c:	fe cc bd b0 	sub	r12,pc,-16976
8000b250:	c0 38       	rjmp	8000b256 <_dtoa_r+0x9e>
8000b252:	fe cc bd aa 	sub	r12,pc,-16982
8000b256:	41 29       	lddsp	r9,sp[0x48]
8000b258:	58 09       	cp.w	r9,0
8000b25a:	e0 80 05 9a 	breq	8000bd8e <_dtoa_r+0xbd6>
8000b25e:	f8 c8 ff fd 	sub	r8,r12,-3
8000b262:	f8 c9 ff f8 	sub	r9,r12,-8
8000b266:	11 8b       	ld.ub	r11,r8[0x0]
8000b268:	30 0a       	mov	r10,0
8000b26a:	41 25       	lddsp	r5,sp[0x48]
8000b26c:	f4 0b 18 00 	cp.b	r11,r10
8000b270:	f2 08 17 10 	movne	r8,r9
8000b274:	c1 68       	rjmp	8000b2a0 <_dtoa_r+0xe8>
8000b276:	fa ea 00 08 	ld.d	r10,sp[8]
8000b27a:	30 08       	mov	r8,0
8000b27c:	fa eb 00 3c 	st.d	sp[60],r10
8000b280:	30 09       	mov	r9,0
8000b282:	e0 a0 10 ce 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000b286:	c1 00       	breq	8000b2a6 <_dtoa_r+0xee>
8000b288:	30 18       	mov	r8,1
8000b28a:	41 5a       	lddsp	r10,sp[0x54]
8000b28c:	95 08       	st.w	r10[0x0],r8
8000b28e:	fe cc bf 16 	sub	r12,pc,-16618
8000b292:	41 29       	lddsp	r9,sp[0x48]
8000b294:	f8 08 00 08 	add	r8,r12,r8
8000b298:	58 09       	cp.w	r9,0
8000b29a:	e0 80 05 7a 	breq	8000bd8e <_dtoa_r+0xbd6>
8000b29e:	12 95       	mov	r5,r9
8000b2a0:	8b 08       	st.w	r5[0x0],r8
8000b2a2:	e0 8f 05 76 	bral	8000bd8e <_dtoa_r+0xbd6>
8000b2a6:	fa c8 ff 9c 	sub	r8,sp,-100
8000b2aa:	fa c9 ff a0 	sub	r9,sp,-96
8000b2ae:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b2b2:	0e 9c       	mov	r12,r7
8000b2b4:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b2b8:	e0 a0 0a 8a 	rcall	8000c7cc <__d2b>
8000b2bc:	18 93       	mov	r3,r12
8000b2be:	58 05       	cp.w	r5,0
8000b2c0:	c0 d0       	breq	8000b2da <_dtoa_r+0x122>
8000b2c2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b2c6:	30 04       	mov	r4,0
8000b2c8:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b2cc:	ea c5 03 ff 	sub	r5,r5,1023
8000b2d0:	10 9b       	mov	r11,r8
8000b2d2:	51 74       	stdsp	sp[0x5c],r4
8000b2d4:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b2d8:	c2 58       	rjmp	8000b322 <_dtoa_r+0x16a>
8000b2da:	41 88       	lddsp	r8,sp[0x60]
8000b2dc:	41 9c       	lddsp	r12,sp[0x64]
8000b2de:	10 0c       	add	r12,r8
8000b2e0:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b2e4:	e0 45 00 20 	cp.w	r5,32
8000b2e8:	e0 8a 00 0e 	brle	8000b304 <_dtoa_r+0x14c>
8000b2ec:	f8 cc fb ee 	sub	r12,r12,-1042
8000b2f0:	40 3b       	lddsp	r11,sp[0xc]
8000b2f2:	ea 08 11 40 	rsub	r8,r5,64
8000b2f6:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b2fa:	ec 08 09 46 	lsl	r6,r6,r8
8000b2fe:	0c 4c       	or	r12,r6
8000b300:	c0 78       	rjmp	8000b30e <_dtoa_r+0x156>
8000b302:	d7 03       	nop
8000b304:	ea 0c 11 20 	rsub	r12,r5,32
8000b308:	40 3a       	lddsp	r10,sp[0xc]
8000b30a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b30e:	e0 a0 10 14 	rcall	8000d336 <__avr32_u32_to_f64>
8000b312:	fc 18 fe 10 	movh	r8,0xfe10
8000b316:	30 19       	mov	r9,1
8000b318:	ea c5 04 33 	sub	r5,r5,1075
8000b31c:	f0 0b 00 0b 	add	r11,r8,r11
8000b320:	51 79       	stdsp	sp[0x5c],r9
8000b322:	30 08       	mov	r8,0
8000b324:	fc 19 3f f8 	movh	r9,0x3ff8
8000b328:	e0 a0 0e 9c 	rcall	8000d060 <__avr32_f64_sub>
8000b32c:	e0 68 43 61 	mov	r8,17249
8000b330:	ea 18 63 6f 	orh	r8,0x636f
8000b334:	e0 69 87 a7 	mov	r9,34727
8000b338:	ea 19 3f d2 	orh	r9,0x3fd2
8000b33c:	e0 a0 0d a6 	rcall	8000ce88 <__avr32_f64_mul>
8000b340:	e0 68 c8 b3 	mov	r8,51379
8000b344:	ea 18 8b 60 	orh	r8,0x8b60
8000b348:	e0 69 8a 28 	mov	r9,35368
8000b34c:	ea 19 3f c6 	orh	r9,0x3fc6
8000b350:	e0 a0 0f 56 	rcall	8000d1fc <__avr32_f64_add>
8000b354:	0a 9c       	mov	r12,r5
8000b356:	14 90       	mov	r0,r10
8000b358:	16 91       	mov	r1,r11
8000b35a:	e0 a0 0f f2 	rcall	8000d33e <__avr32_s32_to_f64>
8000b35e:	e0 68 79 fb 	mov	r8,31227
8000b362:	ea 18 50 9f 	orh	r8,0x509f
8000b366:	e0 69 44 13 	mov	r9,17427
8000b36a:	ea 19 3f d3 	orh	r9,0x3fd3
8000b36e:	e0 a0 0d 8d 	rcall	8000ce88 <__avr32_f64_mul>
8000b372:	14 98       	mov	r8,r10
8000b374:	16 99       	mov	r9,r11
8000b376:	00 9a       	mov	r10,r0
8000b378:	02 9b       	mov	r11,r1
8000b37a:	e0 a0 0f 41 	rcall	8000d1fc <__avr32_f64_add>
8000b37e:	14 90       	mov	r0,r10
8000b380:	16 91       	mov	r1,r11
8000b382:	e0 a0 0f c7 	rcall	8000d310 <__avr32_f64_to_s32>
8000b386:	30 08       	mov	r8,0
8000b388:	18 96       	mov	r6,r12
8000b38a:	30 09       	mov	r9,0
8000b38c:	00 9a       	mov	r10,r0
8000b38e:	02 9b       	mov	r11,r1
8000b390:	e0 a0 10 8e 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b394:	c0 c0       	breq	8000b3ac <_dtoa_r+0x1f4>
8000b396:	0c 9c       	mov	r12,r6
8000b398:	e0 a0 0f d3 	rcall	8000d33e <__avr32_s32_to_f64>
8000b39c:	14 98       	mov	r8,r10
8000b39e:	16 99       	mov	r9,r11
8000b3a0:	00 9a       	mov	r10,r0
8000b3a2:	02 9b       	mov	r11,r1
8000b3a4:	e0 a0 10 3d 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000b3a8:	f7 b6 00 01 	subeq	r6,1
8000b3ac:	59 66       	cp.w	r6,22
8000b3ae:	e0 88 00 05 	brls	8000b3b8 <_dtoa_r+0x200>
8000b3b2:	30 18       	mov	r8,1
8000b3b4:	51 48       	stdsp	sp[0x50],r8
8000b3b6:	c1 38       	rjmp	8000b3dc <_dtoa_r+0x224>
8000b3b8:	fe c8 be 5c 	sub	r8,pc,-16804
8000b3bc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b3c0:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b3c4:	e0 a0 10 74 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b3c8:	f9 b4 00 00 	moveq	r4,0
8000b3cc:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b3d0:	f7 b6 01 01 	subne	r6,1
8000b3d4:	f9 bc 01 00 	movne	r12,0
8000b3d8:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b3dc:	41 90       	lddsp	r0,sp[0x64]
8000b3de:	20 10       	sub	r0,1
8000b3e0:	0a 10       	sub	r0,r5
8000b3e2:	c0 46       	brmi	8000b3ea <_dtoa_r+0x232>
8000b3e4:	50 40       	stdsp	sp[0x10],r0
8000b3e6:	30 00       	mov	r0,0
8000b3e8:	c0 48       	rjmp	8000b3f0 <_dtoa_r+0x238>
8000b3ea:	30 0b       	mov	r11,0
8000b3ec:	5c 30       	neg	r0
8000b3ee:	50 4b       	stdsp	sp[0x10],r11
8000b3f0:	ec 02 11 00 	rsub	r2,r6,0
8000b3f4:	58 06       	cp.w	r6,0
8000b3f6:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b3fa:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b3fe:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b402:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b406:	f9 b2 04 00 	movge	r2,0
8000b40a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b40e:	f9 b9 05 00 	movlt	r9,0
8000b412:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b416:	40 c8       	lddsp	r8,sp[0x30]
8000b418:	58 98       	cp.w	r8,9
8000b41a:	e0 8b 00 20 	brhi	8000b45a <_dtoa_r+0x2a2>
8000b41e:	58 58       	cp.w	r8,5
8000b420:	f9 b4 0a 01 	movle	r4,1
8000b424:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b428:	f7 b5 09 04 	subgt	r5,4
8000b42c:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b430:	f9 b4 09 00 	movgt	r4,0
8000b434:	40 cc       	lddsp	r12,sp[0x30]
8000b436:	58 3c       	cp.w	r12,3
8000b438:	c2 d0       	breq	8000b492 <_dtoa_r+0x2da>
8000b43a:	e0 89 00 05 	brgt	8000b444 <_dtoa_r+0x28c>
8000b43e:	58 2c       	cp.w	r12,2
8000b440:	c1 01       	brne	8000b460 <_dtoa_r+0x2a8>
8000b442:	c1 88       	rjmp	8000b472 <_dtoa_r+0x2ba>
8000b444:	40 cb       	lddsp	r11,sp[0x30]
8000b446:	58 4b       	cp.w	r11,4
8000b448:	c0 60       	breq	8000b454 <_dtoa_r+0x29c>
8000b44a:	58 5b       	cp.w	r11,5
8000b44c:	c0 a1       	brne	8000b460 <_dtoa_r+0x2a8>
8000b44e:	30 1a       	mov	r10,1
8000b450:	50 da       	stdsp	sp[0x34],r10
8000b452:	c2 28       	rjmp	8000b496 <_dtoa_r+0x2de>
8000b454:	30 19       	mov	r9,1
8000b456:	50 d9       	stdsp	sp[0x34],r9
8000b458:	c0 f8       	rjmp	8000b476 <_dtoa_r+0x2be>
8000b45a:	30 08       	mov	r8,0
8000b45c:	30 14       	mov	r4,1
8000b45e:	50 c8       	stdsp	sp[0x30],r8
8000b460:	3f f5       	mov	r5,-1
8000b462:	30 1c       	mov	r12,1
8000b464:	30 0b       	mov	r11,0
8000b466:	50 95       	stdsp	sp[0x24],r5
8000b468:	50 dc       	stdsp	sp[0x34],r12
8000b46a:	0a 91       	mov	r1,r5
8000b46c:	31 28       	mov	r8,18
8000b46e:	50 eb       	stdsp	sp[0x38],r11
8000b470:	c2 08       	rjmp	8000b4b0 <_dtoa_r+0x2f8>
8000b472:	30 0a       	mov	r10,0
8000b474:	50 da       	stdsp	sp[0x34],r10
8000b476:	40 e9       	lddsp	r9,sp[0x38]
8000b478:	58 09       	cp.w	r9,0
8000b47a:	e0 89 00 07 	brgt	8000b488 <_dtoa_r+0x2d0>
8000b47e:	30 18       	mov	r8,1
8000b480:	50 98       	stdsp	sp[0x24],r8
8000b482:	10 91       	mov	r1,r8
8000b484:	50 e8       	stdsp	sp[0x38],r8
8000b486:	c1 58       	rjmp	8000b4b0 <_dtoa_r+0x2f8>
8000b488:	40 e5       	lddsp	r5,sp[0x38]
8000b48a:	50 95       	stdsp	sp[0x24],r5
8000b48c:	0a 91       	mov	r1,r5
8000b48e:	0a 98       	mov	r8,r5
8000b490:	c1 08       	rjmp	8000b4b0 <_dtoa_r+0x2f8>
8000b492:	30 0c       	mov	r12,0
8000b494:	50 dc       	stdsp	sp[0x34],r12
8000b496:	40 eb       	lddsp	r11,sp[0x38]
8000b498:	ec 0b 00 0b 	add	r11,r6,r11
8000b49c:	50 9b       	stdsp	sp[0x24],r11
8000b49e:	16 98       	mov	r8,r11
8000b4a0:	2f f8       	sub	r8,-1
8000b4a2:	58 08       	cp.w	r8,0
8000b4a4:	e0 89 00 05 	brgt	8000b4ae <_dtoa_r+0x2f6>
8000b4a8:	10 91       	mov	r1,r8
8000b4aa:	30 18       	mov	r8,1
8000b4ac:	c0 28       	rjmp	8000b4b0 <_dtoa_r+0x2f8>
8000b4ae:	10 91       	mov	r1,r8
8000b4b0:	30 09       	mov	r9,0
8000b4b2:	6e 9a       	ld.w	r10,r7[0x24]
8000b4b4:	95 19       	st.w	r10[0x4],r9
8000b4b6:	30 49       	mov	r9,4
8000b4b8:	c0 68       	rjmp	8000b4c4 <_dtoa_r+0x30c>
8000b4ba:	d7 03       	nop
8000b4bc:	6a 1a       	ld.w	r10,r5[0x4]
8000b4be:	a1 79       	lsl	r9,0x1
8000b4c0:	2f fa       	sub	r10,-1
8000b4c2:	8b 1a       	st.w	r5[0x4],r10
8000b4c4:	6e 95       	ld.w	r5,r7[0x24]
8000b4c6:	f2 ca ff ec 	sub	r10,r9,-20
8000b4ca:	10 3a       	cp.w	r10,r8
8000b4cc:	fe 98 ff f8 	brls	8000b4bc <_dtoa_r+0x304>
8000b4d0:	6a 1b       	ld.w	r11,r5[0x4]
8000b4d2:	0e 9c       	mov	r12,r7
8000b4d4:	e0 a0 09 44 	rcall	8000c75c <_Balloc>
8000b4d8:	58 e1       	cp.w	r1,14
8000b4da:	5f 88       	srls	r8
8000b4dc:	8b 0c       	st.w	r5[0x0],r12
8000b4de:	f1 e4 00 04 	and	r4,r8,r4
8000b4e2:	6e 98       	ld.w	r8,r7[0x24]
8000b4e4:	70 08       	ld.w	r8,r8[0x0]
8000b4e6:	50 88       	stdsp	sp[0x20],r8
8000b4e8:	e0 80 01 82 	breq	8000b7ec <_dtoa_r+0x634>
8000b4ec:	58 06       	cp.w	r6,0
8000b4ee:	e0 8a 00 43 	brle	8000b574 <_dtoa_r+0x3bc>
8000b4f2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b4f6:	fe c8 bf 9a 	sub	r8,pc,-16486
8000b4fa:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b4fe:	fa e5 00 18 	st.d	sp[24],r4
8000b502:	ec 04 14 04 	asr	r4,r6,0x4
8000b506:	ed b4 00 04 	bld	r4,0x4
8000b50a:	c0 30       	breq	8000b510 <_dtoa_r+0x358>
8000b50c:	30 25       	mov	r5,2
8000b50e:	c1 08       	rjmp	8000b52e <_dtoa_r+0x376>
8000b510:	fe c8 be ec 	sub	r8,pc,-16660
8000b514:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b518:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b51c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b520:	e0 a0 0f fa 	rcall	8000d514 <__avr32_f64_div>
8000b524:	30 35       	mov	r5,3
8000b526:	14 98       	mov	r8,r10
8000b528:	16 99       	mov	r9,r11
8000b52a:	fa e9 00 08 	st.d	sp[8],r8
8000b52e:	fe cc bf 0a 	sub	r12,pc,-16630
8000b532:	50 a3       	stdsp	sp[0x28],r3
8000b534:	0c 93       	mov	r3,r6
8000b536:	18 96       	mov	r6,r12
8000b538:	c0 f8       	rjmp	8000b556 <_dtoa_r+0x39e>
8000b53a:	fa ea 00 18 	ld.d	r10,sp[24]
8000b53e:	ed b4 00 00 	bld	r4,0x0
8000b542:	c0 81       	brne	8000b552 <_dtoa_r+0x39a>
8000b544:	ec e8 00 00 	ld.d	r8,r6[0]
8000b548:	2f f5       	sub	r5,-1
8000b54a:	e0 a0 0c 9f 	rcall	8000ce88 <__avr32_f64_mul>
8000b54e:	fa eb 00 18 	st.d	sp[24],r10
8000b552:	a1 54       	asr	r4,0x1
8000b554:	2f 86       	sub	r6,-8
8000b556:	58 04       	cp.w	r4,0
8000b558:	cf 11       	brne	8000b53a <_dtoa_r+0x382>
8000b55a:	fa e8 00 18 	ld.d	r8,sp[24]
8000b55e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b562:	06 96       	mov	r6,r3
8000b564:	e0 a0 0f d8 	rcall	8000d514 <__avr32_f64_div>
8000b568:	40 a3       	lddsp	r3,sp[0x28]
8000b56a:	14 98       	mov	r8,r10
8000b56c:	16 99       	mov	r9,r11
8000b56e:	fa e9 00 08 	st.d	sp[8],r8
8000b572:	c2 f8       	rjmp	8000b5d0 <_dtoa_r+0x418>
8000b574:	ec 08 11 00 	rsub	r8,r6,0
8000b578:	c0 31       	brne	8000b57e <_dtoa_r+0x3c6>
8000b57a:	30 25       	mov	r5,2
8000b57c:	c2 a8       	rjmp	8000b5d0 <_dtoa_r+0x418>
8000b57e:	fe cc bf 5a 	sub	r12,pc,-16550
8000b582:	f0 04 14 04 	asr	r4,r8,0x4
8000b586:	50 1c       	stdsp	sp[0x4],r12
8000b588:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b58c:	fe c9 c0 30 	sub	r9,pc,-16336
8000b590:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b594:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b598:	e0 a0 0c 78 	rcall	8000ce88 <__avr32_f64_mul>
8000b59c:	40 1c       	lddsp	r12,sp[0x4]
8000b59e:	50 63       	stdsp	sp[0x18],r3
8000b5a0:	30 25       	mov	r5,2
8000b5a2:	0c 93       	mov	r3,r6
8000b5a4:	fa eb 00 08 	st.d	sp[8],r10
8000b5a8:	18 96       	mov	r6,r12
8000b5aa:	c0 f8       	rjmp	8000b5c8 <_dtoa_r+0x410>
8000b5ac:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5b0:	ed b4 00 00 	bld	r4,0x0
8000b5b4:	c0 81       	brne	8000b5c4 <_dtoa_r+0x40c>
8000b5b6:	ec e8 00 00 	ld.d	r8,r6[0]
8000b5ba:	2f f5       	sub	r5,-1
8000b5bc:	e0 a0 0c 66 	rcall	8000ce88 <__avr32_f64_mul>
8000b5c0:	fa eb 00 08 	st.d	sp[8],r10
8000b5c4:	a1 54       	asr	r4,0x1
8000b5c6:	2f 86       	sub	r6,-8
8000b5c8:	58 04       	cp.w	r4,0
8000b5ca:	cf 11       	brne	8000b5ac <_dtoa_r+0x3f4>
8000b5cc:	06 96       	mov	r6,r3
8000b5ce:	40 63       	lddsp	r3,sp[0x18]
8000b5d0:	41 4a       	lddsp	r10,sp[0x50]
8000b5d2:	58 0a       	cp.w	r10,0
8000b5d4:	c2 a0       	breq	8000b628 <_dtoa_r+0x470>
8000b5d6:	fa e8 00 08 	ld.d	r8,sp[8]
8000b5da:	58 01       	cp.w	r1,0
8000b5dc:	5f 94       	srgt	r4
8000b5de:	fa e9 00 18 	st.d	sp[24],r8
8000b5e2:	30 08       	mov	r8,0
8000b5e4:	fc 19 3f f0 	movh	r9,0x3ff0
8000b5e8:	fa ea 00 18 	ld.d	r10,sp[24]
8000b5ec:	e0 a0 0f 60 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b5f0:	f9 bc 00 00 	moveq	r12,0
8000b5f4:	f9 bc 01 01 	movne	r12,1
8000b5f8:	e9 ec 00 0c 	and	r12,r4,r12
8000b5fc:	c1 60       	breq	8000b628 <_dtoa_r+0x470>
8000b5fe:	40 98       	lddsp	r8,sp[0x24]
8000b600:	58 08       	cp.w	r8,0
8000b602:	e0 8a 00 f1 	brle	8000b7e4 <_dtoa_r+0x62c>
8000b606:	30 08       	mov	r8,0
8000b608:	fc 19 40 24 	movh	r9,0x4024
8000b60c:	ec c4 00 01 	sub	r4,r6,1
8000b610:	fa ea 00 18 	ld.d	r10,sp[24]
8000b614:	2f f5       	sub	r5,-1
8000b616:	50 64       	stdsp	sp[0x18],r4
8000b618:	e0 a0 0c 38 	rcall	8000ce88 <__avr32_f64_mul>
8000b61c:	40 94       	lddsp	r4,sp[0x24]
8000b61e:	14 98       	mov	r8,r10
8000b620:	16 99       	mov	r9,r11
8000b622:	fa e9 00 08 	st.d	sp[8],r8
8000b626:	c0 38       	rjmp	8000b62c <_dtoa_r+0x474>
8000b628:	50 66       	stdsp	sp[0x18],r6
8000b62a:	02 94       	mov	r4,r1
8000b62c:	0a 9c       	mov	r12,r5
8000b62e:	e0 a0 0e 88 	rcall	8000d33e <__avr32_s32_to_f64>
8000b632:	fa e8 00 08 	ld.d	r8,sp[8]
8000b636:	e0 a0 0c 29 	rcall	8000ce88 <__avr32_f64_mul>
8000b63a:	30 08       	mov	r8,0
8000b63c:	fc 19 40 1c 	movh	r9,0x401c
8000b640:	e0 a0 0d de 	rcall	8000d1fc <__avr32_f64_add>
8000b644:	14 98       	mov	r8,r10
8000b646:	16 99       	mov	r9,r11
8000b648:	fa e9 00 28 	st.d	sp[40],r8
8000b64c:	fc 18 fc c0 	movh	r8,0xfcc0
8000b650:	40 a5       	lddsp	r5,sp[0x28]
8000b652:	10 05       	add	r5,r8
8000b654:	50 a5       	stdsp	sp[0x28],r5
8000b656:	58 04       	cp.w	r4,0
8000b658:	c2 11       	brne	8000b69a <_dtoa_r+0x4e2>
8000b65a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b65e:	30 08       	mov	r8,0
8000b660:	fc 19 40 14 	movh	r9,0x4014
8000b664:	e0 a0 0c fe 	rcall	8000d060 <__avr32_f64_sub>
8000b668:	40 bc       	lddsp	r12,sp[0x2c]
8000b66a:	fa eb 00 08 	st.d	sp[8],r10
8000b66e:	14 98       	mov	r8,r10
8000b670:	16 99       	mov	r9,r11
8000b672:	18 9a       	mov	r10,r12
8000b674:	0a 9b       	mov	r11,r5
8000b676:	e0 a0 0f 1b 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b67a:	e0 81 02 54 	brne	8000bb22 <_dtoa_r+0x96a>
8000b67e:	0a 98       	mov	r8,r5
8000b680:	40 b9       	lddsp	r9,sp[0x2c]
8000b682:	ee 18 80 00 	eorh	r8,0x8000
8000b686:	fa ea 00 08 	ld.d	r10,sp[8]
8000b68a:	10 95       	mov	r5,r8
8000b68c:	12 98       	mov	r8,r9
8000b68e:	0a 99       	mov	r9,r5
8000b690:	e0 a0 0f 0e 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b694:	e0 81 02 3e 	brne	8000bb10 <_dtoa_r+0x958>
8000b698:	ca 68       	rjmp	8000b7e4 <_dtoa_r+0x62c>
8000b69a:	fe c9 c1 3e 	sub	r9,pc,-16066
8000b69e:	e8 c8 00 01 	sub	r8,r4,1
8000b6a2:	40 d5       	lddsp	r5,sp[0x34]
8000b6a4:	58 05       	cp.w	r5,0
8000b6a6:	c4 f0       	breq	8000b744 <_dtoa_r+0x58c>
8000b6a8:	30 0c       	mov	r12,0
8000b6aa:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b6ae:	51 3c       	stdsp	sp[0x4c],r12
8000b6b0:	30 0a       	mov	r10,0
8000b6b2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b6b6:	e0 a0 0f 2f 	rcall	8000d514 <__avr32_f64_div>
8000b6ba:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6be:	40 85       	lddsp	r5,sp[0x20]
8000b6c0:	e0 a0 0c d0 	rcall	8000d060 <__avr32_f64_sub>
8000b6c4:	fa eb 00 28 	st.d	sp[40],r10
8000b6c8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6cc:	e0 a0 0e 22 	rcall	8000d310 <__avr32_f64_to_s32>
8000b6d0:	51 6c       	stdsp	sp[0x58],r12
8000b6d2:	e0 a0 0e 36 	rcall	8000d33e <__avr32_s32_to_f64>
8000b6d6:	14 98       	mov	r8,r10
8000b6d8:	16 99       	mov	r9,r11
8000b6da:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6de:	e0 a0 0c c1 	rcall	8000d060 <__avr32_f64_sub>
8000b6e2:	fa eb 00 08 	st.d	sp[8],r10
8000b6e6:	41 68       	lddsp	r8,sp[0x58]
8000b6e8:	2d 08       	sub	r8,-48
8000b6ea:	0a c8       	st.b	r5++,r8
8000b6ec:	41 39       	lddsp	r9,sp[0x4c]
8000b6ee:	2f f9       	sub	r9,-1
8000b6f0:	51 39       	stdsp	sp[0x4c],r9
8000b6f2:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6f6:	e0 a0 0e db 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b6fa:	e0 81 03 39 	brne	8000bd6c <_dtoa_r+0xbb4>
8000b6fe:	fa e8 00 08 	ld.d	r8,sp[8]
8000b702:	30 0a       	mov	r10,0
8000b704:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b708:	e0 a0 0c ac 	rcall	8000d060 <__avr32_f64_sub>
8000b70c:	fa e8 00 28 	ld.d	r8,sp[40]
8000b710:	e0 a0 0e ce 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b714:	fa ea 00 28 	ld.d	r10,sp[40]
8000b718:	30 08       	mov	r8,0
8000b71a:	fc 19 40 24 	movh	r9,0x4024
8000b71e:	e0 81 00 da 	brne	8000b8d2 <_dtoa_r+0x71a>
8000b722:	41 3c       	lddsp	r12,sp[0x4c]
8000b724:	08 3c       	cp.w	r12,r4
8000b726:	c5 f4       	brge	8000b7e4 <_dtoa_r+0x62c>
8000b728:	e0 a0 0b b0 	rcall	8000ce88 <__avr32_f64_mul>
8000b72c:	30 08       	mov	r8,0
8000b72e:	fa eb 00 28 	st.d	sp[40],r10
8000b732:	fc 19 40 24 	movh	r9,0x4024
8000b736:	fa ea 00 08 	ld.d	r10,sp[8]
8000b73a:	e0 a0 0b a7 	rcall	8000ce88 <__avr32_f64_mul>
8000b73e:	fa eb 00 08 	st.d	sp[8],r10
8000b742:	cc 3b       	rjmp	8000b6c8 <_dtoa_r+0x510>
8000b744:	40 85       	lddsp	r5,sp[0x20]
8000b746:	08 05       	add	r5,r4
8000b748:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b74c:	51 35       	stdsp	sp[0x4c],r5
8000b74e:	fa e8 00 28 	ld.d	r8,sp[40]
8000b752:	40 85       	lddsp	r5,sp[0x20]
8000b754:	e0 a0 0b 9a 	rcall	8000ce88 <__avr32_f64_mul>
8000b758:	fa eb 00 28 	st.d	sp[40],r10
8000b75c:	fa ea 00 08 	ld.d	r10,sp[8]
8000b760:	e0 a0 0d d8 	rcall	8000d310 <__avr32_f64_to_s32>
8000b764:	51 6c       	stdsp	sp[0x58],r12
8000b766:	e0 a0 0d ec 	rcall	8000d33e <__avr32_s32_to_f64>
8000b76a:	14 98       	mov	r8,r10
8000b76c:	16 99       	mov	r9,r11
8000b76e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b772:	e0 a0 0c 77 	rcall	8000d060 <__avr32_f64_sub>
8000b776:	fa eb 00 08 	st.d	sp[8],r10
8000b77a:	41 68       	lddsp	r8,sp[0x58]
8000b77c:	2d 08       	sub	r8,-48
8000b77e:	0a c8       	st.b	r5++,r8
8000b780:	41 3c       	lddsp	r12,sp[0x4c]
8000b782:	18 35       	cp.w	r5,r12
8000b784:	c2 81       	brne	8000b7d4 <_dtoa_r+0x61c>
8000b786:	30 08       	mov	r8,0
8000b788:	fc 19 3f e0 	movh	r9,0x3fe0
8000b78c:	fa ea 00 28 	ld.d	r10,sp[40]
8000b790:	e0 a0 0d 36 	rcall	8000d1fc <__avr32_f64_add>
8000b794:	40 85       	lddsp	r5,sp[0x20]
8000b796:	fa e8 00 08 	ld.d	r8,sp[8]
8000b79a:	08 05       	add	r5,r4
8000b79c:	e0 a0 0e 88 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b7a0:	e0 81 00 99 	brne	8000b8d2 <_dtoa_r+0x71a>
8000b7a4:	fa e8 00 28 	ld.d	r8,sp[40]
8000b7a8:	30 0a       	mov	r10,0
8000b7aa:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b7ae:	e0 a0 0c 59 	rcall	8000d060 <__avr32_f64_sub>
8000b7b2:	14 98       	mov	r8,r10
8000b7b4:	16 99       	mov	r9,r11
8000b7b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7ba:	e0 a0 0e 79 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b7be:	c1 30       	breq	8000b7e4 <_dtoa_r+0x62c>
8000b7c0:	33 09       	mov	r9,48
8000b7c2:	0a 98       	mov	r8,r5
8000b7c4:	11 7a       	ld.ub	r10,--r8
8000b7c6:	f2 0a 18 00 	cp.b	r10,r9
8000b7ca:	e0 81 02 d1 	brne	8000bd6c <_dtoa_r+0xbb4>
8000b7ce:	10 95       	mov	r5,r8
8000b7d0:	cf 9b       	rjmp	8000b7c2 <_dtoa_r+0x60a>
8000b7d2:	d7 03       	nop
8000b7d4:	30 08       	mov	r8,0
8000b7d6:	fc 19 40 24 	movh	r9,0x4024
8000b7da:	e0 a0 0b 57 	rcall	8000ce88 <__avr32_f64_mul>
8000b7de:	fa eb 00 08 	st.d	sp[8],r10
8000b7e2:	cb db       	rjmp	8000b75c <_dtoa_r+0x5a4>
8000b7e4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b7e8:	fa eb 00 08 	st.d	sp[8],r10
8000b7ec:	58 e6       	cp.w	r6,14
8000b7ee:	5f ab       	srle	r11
8000b7f0:	41 8a       	lddsp	r10,sp[0x60]
8000b7f2:	30 08       	mov	r8,0
8000b7f4:	f4 09 11 ff 	rsub	r9,r10,-1
8000b7f8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b7fc:	f0 09 18 00 	cp.b	r9,r8
8000b800:	e0 80 00 82 	breq	8000b904 <_dtoa_r+0x74c>
8000b804:	40 ea       	lddsp	r10,sp[0x38]
8000b806:	58 01       	cp.w	r1,0
8000b808:	5f a9       	srle	r9
8000b80a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b80e:	fe ca c2 b2 	sub	r10,pc,-15694
8000b812:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b816:	fa e5 00 10 	st.d	sp[16],r4
8000b81a:	f0 09 18 00 	cp.b	r9,r8
8000b81e:	c1 40       	breq	8000b846 <_dtoa_r+0x68e>
8000b820:	58 01       	cp.w	r1,0
8000b822:	e0 81 01 77 	brne	8000bb10 <_dtoa_r+0x958>
8000b826:	30 08       	mov	r8,0
8000b828:	fc 19 40 14 	movh	r9,0x4014
8000b82c:	08 9a       	mov	r10,r4
8000b82e:	0a 9b       	mov	r11,r5
8000b830:	e0 a0 0b 2c 	rcall	8000ce88 <__avr32_f64_mul>
8000b834:	fa e8 00 08 	ld.d	r8,sp[8]
8000b838:	e0 a0 0e 06 	rcall	8000d444 <__avr32_f64_cmp_ge>
8000b83c:	e0 81 01 6a 	brne	8000bb10 <_dtoa_r+0x958>
8000b840:	02 92       	mov	r2,r1
8000b842:	e0 8f 01 72 	bral	8000bb26 <_dtoa_r+0x96e>
8000b846:	40 85       	lddsp	r5,sp[0x20]
8000b848:	30 14       	mov	r4,1
8000b84a:	fa e8 00 10 	ld.d	r8,sp[16]
8000b84e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b852:	e0 a0 0e 61 	rcall	8000d514 <__avr32_f64_div>
8000b856:	e0 a0 0d 5d 	rcall	8000d310 <__avr32_f64_to_s32>
8000b85a:	18 92       	mov	r2,r12
8000b85c:	e0 a0 0d 71 	rcall	8000d33e <__avr32_s32_to_f64>
8000b860:	fa e8 00 10 	ld.d	r8,sp[16]
8000b864:	e0 a0 0b 12 	rcall	8000ce88 <__avr32_f64_mul>
8000b868:	14 98       	mov	r8,r10
8000b86a:	16 99       	mov	r9,r11
8000b86c:	fa ea 00 08 	ld.d	r10,sp[8]
8000b870:	e0 a0 0b f8 	rcall	8000d060 <__avr32_f64_sub>
8000b874:	fa eb 00 08 	st.d	sp[8],r10
8000b878:	e4 c8 ff d0 	sub	r8,r2,-48
8000b87c:	0a c8       	st.b	r5++,r8
8000b87e:	fc 19 40 24 	movh	r9,0x4024
8000b882:	30 08       	mov	r8,0
8000b884:	02 34       	cp.w	r4,r1
8000b886:	c3 31       	brne	8000b8ec <_dtoa_r+0x734>
8000b888:	fa e8 00 08 	ld.d	r8,sp[8]
8000b88c:	e0 a0 0c b8 	rcall	8000d1fc <__avr32_f64_add>
8000b890:	16 91       	mov	r1,r11
8000b892:	14 90       	mov	r0,r10
8000b894:	14 98       	mov	r8,r10
8000b896:	02 99       	mov	r9,r1
8000b898:	fa ea 00 10 	ld.d	r10,sp[16]
8000b89c:	e0 a0 0e 08 	rcall	8000d4ac <__avr32_f64_cmp_lt>
8000b8a0:	c1 a1       	brne	8000b8d4 <_dtoa_r+0x71c>
8000b8a2:	fa e8 00 10 	ld.d	r8,sp[16]
8000b8a6:	00 9a       	mov	r10,r0
8000b8a8:	02 9b       	mov	r11,r1
8000b8aa:	e0 a0 0d ba 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000b8ae:	e0 80 02 5e 	breq	8000bd6a <_dtoa_r+0xbb2>
8000b8b2:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b8b6:	c0 f1       	brne	8000b8d4 <_dtoa_r+0x71c>
8000b8b8:	e0 8f 02 59 	bral	8000bd6a <_dtoa_r+0xbb2>
8000b8bc:	40 8a       	lddsp	r10,sp[0x20]
8000b8be:	14 38       	cp.w	r8,r10
8000b8c0:	c0 30       	breq	8000b8c6 <_dtoa_r+0x70e>
8000b8c2:	10 95       	mov	r5,r8
8000b8c4:	c0 98       	rjmp	8000b8d6 <_dtoa_r+0x71e>
8000b8c6:	33 08       	mov	r8,48
8000b8c8:	40 89       	lddsp	r9,sp[0x20]
8000b8ca:	2f f6       	sub	r6,-1
8000b8cc:	b2 88       	st.b	r9[0x0],r8
8000b8ce:	40 88       	lddsp	r8,sp[0x20]
8000b8d0:	c0 88       	rjmp	8000b8e0 <_dtoa_r+0x728>
8000b8d2:	40 66       	lddsp	r6,sp[0x18]
8000b8d4:	33 99       	mov	r9,57
8000b8d6:	0a 98       	mov	r8,r5
8000b8d8:	11 7a       	ld.ub	r10,--r8
8000b8da:	f2 0a 18 00 	cp.b	r10,r9
8000b8de:	ce f0       	breq	8000b8bc <_dtoa_r+0x704>
8000b8e0:	50 66       	stdsp	sp[0x18],r6
8000b8e2:	11 89       	ld.ub	r9,r8[0x0]
8000b8e4:	2f f9       	sub	r9,-1
8000b8e6:	b0 89       	st.b	r8[0x0],r9
8000b8e8:	e0 8f 02 42 	bral	8000bd6c <_dtoa_r+0xbb4>
8000b8ec:	e0 a0 0a ce 	rcall	8000ce88 <__avr32_f64_mul>
8000b8f0:	2f f4       	sub	r4,-1
8000b8f2:	fa eb 00 08 	st.d	sp[8],r10
8000b8f6:	30 08       	mov	r8,0
8000b8f8:	30 09       	mov	r9,0
8000b8fa:	e0 a0 0d 92 	rcall	8000d41e <__avr32_f64_cmp_eq>
8000b8fe:	ca 60       	breq	8000b84a <_dtoa_r+0x692>
8000b900:	e0 8f 02 35 	bral	8000bd6a <_dtoa_r+0xbb2>
8000b904:	40 d8       	lddsp	r8,sp[0x34]
8000b906:	58 08       	cp.w	r8,0
8000b908:	c0 51       	brne	8000b912 <_dtoa_r+0x75a>
8000b90a:	04 98       	mov	r8,r2
8000b90c:	00 95       	mov	r5,r0
8000b90e:	40 d4       	lddsp	r4,sp[0x34]
8000b910:	c3 78       	rjmp	8000b97e <_dtoa_r+0x7c6>
8000b912:	40 c5       	lddsp	r5,sp[0x30]
8000b914:	58 15       	cp.w	r5,1
8000b916:	e0 89 00 0f 	brgt	8000b934 <_dtoa_r+0x77c>
8000b91a:	41 74       	lddsp	r4,sp[0x5c]
8000b91c:	58 04       	cp.w	r4,0
8000b91e:	c0 40       	breq	8000b926 <_dtoa_r+0x76e>
8000b920:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b924:	c0 48       	rjmp	8000b92c <_dtoa_r+0x774>
8000b926:	41 99       	lddsp	r9,sp[0x64]
8000b928:	f2 09 11 36 	rsub	r9,r9,54
8000b92c:	04 98       	mov	r8,r2
8000b92e:	00 95       	mov	r5,r0
8000b930:	c1 c8       	rjmp	8000b968 <_dtoa_r+0x7b0>
8000b932:	d7 03       	nop
8000b934:	e2 c8 00 01 	sub	r8,r1,1
8000b938:	58 01       	cp.w	r1,0
8000b93a:	e0 05 17 40 	movge	r5,r0
8000b93e:	e2 09 17 40 	movge	r9,r1
8000b942:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b946:	f9 b9 05 00 	movlt	r9,0
8000b94a:	10 32       	cp.w	r2,r8
8000b94c:	e5 d8 e4 18 	subge	r8,r2,r8
8000b950:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b954:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b958:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b95c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b960:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b964:	f9 b8 05 00 	movlt	r8,0
8000b968:	40 4b       	lddsp	r11,sp[0x10]
8000b96a:	12 0b       	add	r11,r9
8000b96c:	50 08       	stdsp	sp[0x0],r8
8000b96e:	50 4b       	stdsp	sp[0x10],r11
8000b970:	12 00       	add	r0,r9
8000b972:	30 1b       	mov	r11,1
8000b974:	0e 9c       	mov	r12,r7
8000b976:	e0 a0 08 a7 	rcall	8000cac4 <__i2b>
8000b97a:	40 08       	lddsp	r8,sp[0x0]
8000b97c:	18 94       	mov	r4,r12
8000b97e:	40 4a       	lddsp	r10,sp[0x10]
8000b980:	58 05       	cp.w	r5,0
8000b982:	5f 99       	srgt	r9
8000b984:	58 0a       	cp.w	r10,0
8000b986:	5f 9a       	srgt	r10
8000b988:	f5 e9 00 09 	and	r9,r10,r9
8000b98c:	c0 80       	breq	8000b99c <_dtoa_r+0x7e4>
8000b98e:	40 4c       	lddsp	r12,sp[0x10]
8000b990:	f8 05 0d 49 	min	r9,r12,r5
8000b994:	12 1c       	sub	r12,r9
8000b996:	12 10       	sub	r0,r9
8000b998:	50 4c       	stdsp	sp[0x10],r12
8000b99a:	12 15       	sub	r5,r9
8000b99c:	58 02       	cp.w	r2,0
8000b99e:	e0 8a 00 27 	brle	8000b9ec <_dtoa_r+0x834>
8000b9a2:	40 db       	lddsp	r11,sp[0x34]
8000b9a4:	58 0b       	cp.w	r11,0
8000b9a6:	c1 d0       	breq	8000b9e0 <_dtoa_r+0x828>
8000b9a8:	58 08       	cp.w	r8,0
8000b9aa:	e0 8a 00 17 	brle	8000b9d8 <_dtoa_r+0x820>
8000b9ae:	10 9a       	mov	r10,r8
8000b9b0:	50 08       	stdsp	sp[0x0],r8
8000b9b2:	08 9b       	mov	r11,r4
8000b9b4:	0e 9c       	mov	r12,r7
8000b9b6:	e0 a0 08 cd 	rcall	8000cb50 <__pow5mult>
8000b9ba:	06 9a       	mov	r10,r3
8000b9bc:	18 9b       	mov	r11,r12
8000b9be:	18 94       	mov	r4,r12
8000b9c0:	0e 9c       	mov	r12,r7
8000b9c2:	e0 a0 08 01 	rcall	8000c9c4 <__multiply>
8000b9c6:	18 99       	mov	r9,r12
8000b9c8:	06 9b       	mov	r11,r3
8000b9ca:	50 19       	stdsp	sp[0x4],r9
8000b9cc:	0e 9c       	mov	r12,r7
8000b9ce:	e0 a0 06 ad 	rcall	8000c728 <_Bfree>
8000b9d2:	40 19       	lddsp	r9,sp[0x4]
8000b9d4:	40 08       	lddsp	r8,sp[0x0]
8000b9d6:	12 93       	mov	r3,r9
8000b9d8:	e4 08 01 0a 	sub	r10,r2,r8
8000b9dc:	c0 80       	breq	8000b9ec <_dtoa_r+0x834>
8000b9de:	c0 28       	rjmp	8000b9e2 <_dtoa_r+0x82a>
8000b9e0:	04 9a       	mov	r10,r2
8000b9e2:	06 9b       	mov	r11,r3
8000b9e4:	0e 9c       	mov	r12,r7
8000b9e6:	e0 a0 08 b5 	rcall	8000cb50 <__pow5mult>
8000b9ea:	18 93       	mov	r3,r12
8000b9ec:	30 1b       	mov	r11,1
8000b9ee:	0e 9c       	mov	r12,r7
8000b9f0:	e0 a0 08 6a 	rcall	8000cac4 <__i2b>
8000b9f4:	41 1a       	lddsp	r10,sp[0x44]
8000b9f6:	18 92       	mov	r2,r12
8000b9f8:	58 0a       	cp.w	r10,0
8000b9fa:	e0 8a 00 07 	brle	8000ba08 <_dtoa_r+0x850>
8000b9fe:	18 9b       	mov	r11,r12
8000ba00:	0e 9c       	mov	r12,r7
8000ba02:	e0 a0 08 a7 	rcall	8000cb50 <__pow5mult>
8000ba06:	18 92       	mov	r2,r12
8000ba08:	40 c9       	lddsp	r9,sp[0x30]
8000ba0a:	58 19       	cp.w	r9,1
8000ba0c:	e0 89 00 14 	brgt	8000ba34 <_dtoa_r+0x87c>
8000ba10:	40 38       	lddsp	r8,sp[0xc]
8000ba12:	58 08       	cp.w	r8,0
8000ba14:	c1 01       	brne	8000ba34 <_dtoa_r+0x87c>
8000ba16:	40 29       	lddsp	r9,sp[0x8]
8000ba18:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ba1c:	c0 c1       	brne	8000ba34 <_dtoa_r+0x87c>
8000ba1e:	12 98       	mov	r8,r9
8000ba20:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ba24:	c0 80       	breq	8000ba34 <_dtoa_r+0x87c>
8000ba26:	40 4c       	lddsp	r12,sp[0x10]
8000ba28:	30 1b       	mov	r11,1
8000ba2a:	2f fc       	sub	r12,-1
8000ba2c:	2f f0       	sub	r0,-1
8000ba2e:	50 4c       	stdsp	sp[0x10],r12
8000ba30:	50 6b       	stdsp	sp[0x18],r11
8000ba32:	c0 38       	rjmp	8000ba38 <_dtoa_r+0x880>
8000ba34:	30 0a       	mov	r10,0
8000ba36:	50 6a       	stdsp	sp[0x18],r10
8000ba38:	41 19       	lddsp	r9,sp[0x44]
8000ba3a:	58 09       	cp.w	r9,0
8000ba3c:	c0 31       	brne	8000ba42 <_dtoa_r+0x88a>
8000ba3e:	30 1c       	mov	r12,1
8000ba40:	c0 98       	rjmp	8000ba52 <_dtoa_r+0x89a>
8000ba42:	64 48       	ld.w	r8,r2[0x10]
8000ba44:	2f c8       	sub	r8,-4
8000ba46:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ba4a:	e0 a0 05 df 	rcall	8000c608 <__hi0bits>
8000ba4e:	f8 0c 11 20 	rsub	r12,r12,32
8000ba52:	40 4b       	lddsp	r11,sp[0x10]
8000ba54:	f8 0b 00 08 	add	r8,r12,r11
8000ba58:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ba5c:	c0 c0       	breq	8000ba74 <_dtoa_r+0x8bc>
8000ba5e:	f0 08 11 20 	rsub	r8,r8,32
8000ba62:	58 48       	cp.w	r8,4
8000ba64:	e0 8a 00 06 	brle	8000ba70 <_dtoa_r+0x8b8>
8000ba68:	20 48       	sub	r8,4
8000ba6a:	10 0b       	add	r11,r8
8000ba6c:	50 4b       	stdsp	sp[0x10],r11
8000ba6e:	c0 78       	rjmp	8000ba7c <_dtoa_r+0x8c4>
8000ba70:	58 48       	cp.w	r8,4
8000ba72:	c0 70       	breq	8000ba80 <_dtoa_r+0x8c8>
8000ba74:	40 4a       	lddsp	r10,sp[0x10]
8000ba76:	2e 48       	sub	r8,-28
8000ba78:	10 0a       	add	r10,r8
8000ba7a:	50 4a       	stdsp	sp[0x10],r10
8000ba7c:	10 00       	add	r0,r8
8000ba7e:	10 05       	add	r5,r8
8000ba80:	58 00       	cp.w	r0,0
8000ba82:	e0 8a 00 08 	brle	8000ba92 <_dtoa_r+0x8da>
8000ba86:	06 9b       	mov	r11,r3
8000ba88:	00 9a       	mov	r10,r0
8000ba8a:	0e 9c       	mov	r12,r7
8000ba8c:	e0 a0 07 58 	rcall	8000c93c <__lshift>
8000ba90:	18 93       	mov	r3,r12
8000ba92:	40 49       	lddsp	r9,sp[0x10]
8000ba94:	58 09       	cp.w	r9,0
8000ba96:	e0 8a 00 08 	brle	8000baa6 <_dtoa_r+0x8ee>
8000ba9a:	04 9b       	mov	r11,r2
8000ba9c:	12 9a       	mov	r10,r9
8000ba9e:	0e 9c       	mov	r12,r7
8000baa0:	e0 a0 07 4e 	rcall	8000c93c <__lshift>
8000baa4:	18 92       	mov	r2,r12
8000baa6:	41 48       	lddsp	r8,sp[0x50]
8000baa8:	58 08       	cp.w	r8,0
8000baaa:	c1 b0       	breq	8000bae0 <_dtoa_r+0x928>
8000baac:	04 9b       	mov	r11,r2
8000baae:	06 9c       	mov	r12,r3
8000bab0:	e0 a0 06 23 	rcall	8000c6f6 <__mcmp>
8000bab4:	c1 64       	brge	8000bae0 <_dtoa_r+0x928>
8000bab6:	06 9b       	mov	r11,r3
8000bab8:	30 09       	mov	r9,0
8000baba:	30 aa       	mov	r10,10
8000babc:	0e 9c       	mov	r12,r7
8000babe:	e0 a0 08 0b 	rcall	8000cad4 <__multadd>
8000bac2:	20 16       	sub	r6,1
8000bac4:	18 93       	mov	r3,r12
8000bac6:	40 dc       	lddsp	r12,sp[0x34]
8000bac8:	58 0c       	cp.w	r12,0
8000baca:	c0 31       	brne	8000bad0 <_dtoa_r+0x918>
8000bacc:	40 91       	lddsp	r1,sp[0x24]
8000bace:	c0 98       	rjmp	8000bae0 <_dtoa_r+0x928>
8000bad0:	08 9b       	mov	r11,r4
8000bad2:	40 91       	lddsp	r1,sp[0x24]
8000bad4:	30 09       	mov	r9,0
8000bad6:	30 aa       	mov	r10,10
8000bad8:	0e 9c       	mov	r12,r7
8000bada:	e0 a0 07 fd 	rcall	8000cad4 <__multadd>
8000bade:	18 94       	mov	r4,r12
8000bae0:	58 01       	cp.w	r1,0
8000bae2:	5f a9       	srle	r9
8000bae4:	40 cb       	lddsp	r11,sp[0x30]
8000bae6:	58 2b       	cp.w	r11,2
8000bae8:	5f 98       	srgt	r8
8000baea:	f3 e8 00 08 	and	r8,r9,r8
8000baee:	c2 50       	breq	8000bb38 <_dtoa_r+0x980>
8000baf0:	58 01       	cp.w	r1,0
8000baf2:	c1 11       	brne	8000bb14 <_dtoa_r+0x95c>
8000baf4:	04 9b       	mov	r11,r2
8000baf6:	02 99       	mov	r9,r1
8000baf8:	30 5a       	mov	r10,5
8000bafa:	0e 9c       	mov	r12,r7
8000bafc:	e0 a0 07 ec 	rcall	8000cad4 <__multadd>
8000bb00:	18 92       	mov	r2,r12
8000bb02:	18 9b       	mov	r11,r12
8000bb04:	06 9c       	mov	r12,r3
8000bb06:	e0 a0 05 f8 	rcall	8000c6f6 <__mcmp>
8000bb0a:	e0 89 00 0f 	brgt	8000bb28 <_dtoa_r+0x970>
8000bb0e:	c0 38       	rjmp	8000bb14 <_dtoa_r+0x95c>
8000bb10:	30 02       	mov	r2,0
8000bb12:	04 94       	mov	r4,r2
8000bb14:	40 ea       	lddsp	r10,sp[0x38]
8000bb16:	30 09       	mov	r9,0
8000bb18:	5c da       	com	r10
8000bb1a:	40 85       	lddsp	r5,sp[0x20]
8000bb1c:	50 6a       	stdsp	sp[0x18],r10
8000bb1e:	50 49       	stdsp	sp[0x10],r9
8000bb20:	c0 f9       	rjmp	8000bd3e <_dtoa_r+0xb86>
8000bb22:	08 92       	mov	r2,r4
8000bb24:	40 66       	lddsp	r6,sp[0x18]
8000bb26:	04 94       	mov	r4,r2
8000bb28:	2f f6       	sub	r6,-1
8000bb2a:	50 66       	stdsp	sp[0x18],r6
8000bb2c:	33 18       	mov	r8,49
8000bb2e:	40 85       	lddsp	r5,sp[0x20]
8000bb30:	0a c8       	st.b	r5++,r8
8000bb32:	30 08       	mov	r8,0
8000bb34:	50 48       	stdsp	sp[0x10],r8
8000bb36:	c0 49       	rjmp	8000bd3e <_dtoa_r+0xb86>
8000bb38:	40 dc       	lddsp	r12,sp[0x34]
8000bb3a:	58 0c       	cp.w	r12,0
8000bb3c:	e0 80 00 b5 	breq	8000bca6 <_dtoa_r+0xaee>
8000bb40:	58 05       	cp.w	r5,0
8000bb42:	e0 8a 00 08 	brle	8000bb52 <_dtoa_r+0x99a>
8000bb46:	08 9b       	mov	r11,r4
8000bb48:	0a 9a       	mov	r10,r5
8000bb4a:	0e 9c       	mov	r12,r7
8000bb4c:	e0 a0 06 f8 	rcall	8000c93c <__lshift>
8000bb50:	18 94       	mov	r4,r12
8000bb52:	40 6b       	lddsp	r11,sp[0x18]
8000bb54:	58 0b       	cp.w	r11,0
8000bb56:	c0 31       	brne	8000bb5c <_dtoa_r+0x9a4>
8000bb58:	08 9c       	mov	r12,r4
8000bb5a:	c1 38       	rjmp	8000bb80 <_dtoa_r+0x9c8>
8000bb5c:	68 1b       	ld.w	r11,r4[0x4]
8000bb5e:	0e 9c       	mov	r12,r7
8000bb60:	e0 a0 05 fe 	rcall	8000c75c <_Balloc>
8000bb64:	68 4a       	ld.w	r10,r4[0x10]
8000bb66:	18 95       	mov	r5,r12
8000bb68:	e8 cb ff f4 	sub	r11,r4,-12
8000bb6c:	2f ea       	sub	r10,-2
8000bb6e:	2f 4c       	sub	r12,-12
8000bb70:	a3 6a       	lsl	r10,0x2
8000bb72:	fe b0 e6 50 	rcall	80008812 <memcpy>
8000bb76:	0a 9b       	mov	r11,r5
8000bb78:	30 1a       	mov	r10,1
8000bb7a:	0e 9c       	mov	r12,r7
8000bb7c:	e0 a0 06 e0 	rcall	8000c93c <__lshift>
8000bb80:	50 44       	stdsp	sp[0x10],r4
8000bb82:	40 3a       	lddsp	r10,sp[0xc]
8000bb84:	30 19       	mov	r9,1
8000bb86:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000bb8a:	18 94       	mov	r4,r12
8000bb8c:	50 da       	stdsp	sp[0x34],r10
8000bb8e:	40 85       	lddsp	r5,sp[0x20]
8000bb90:	50 99       	stdsp	sp[0x24],r9
8000bb92:	50 26       	stdsp	sp[0x8],r6
8000bb94:	50 e1       	stdsp	sp[0x38],r1
8000bb96:	04 9b       	mov	r11,r2
8000bb98:	06 9c       	mov	r12,r3
8000bb9a:	fe b0 fa 7f 	rcall	8000b098 <quorem>
8000bb9e:	40 4b       	lddsp	r11,sp[0x10]
8000bba0:	f8 c0 ff d0 	sub	r0,r12,-48
8000bba4:	06 9c       	mov	r12,r3
8000bba6:	e0 a0 05 a8 	rcall	8000c6f6 <__mcmp>
8000bbaa:	08 9a       	mov	r10,r4
8000bbac:	50 6c       	stdsp	sp[0x18],r12
8000bbae:	04 9b       	mov	r11,r2
8000bbb0:	0e 9c       	mov	r12,r7
8000bbb2:	e0 a0 06 5d 	rcall	8000c86c <__mdiff>
8000bbb6:	18 91       	mov	r1,r12
8000bbb8:	78 38       	ld.w	r8,r12[0xc]
8000bbba:	58 08       	cp.w	r8,0
8000bbbc:	c0 30       	breq	8000bbc2 <_dtoa_r+0xa0a>
8000bbbe:	30 16       	mov	r6,1
8000bbc0:	c0 68       	rjmp	8000bbcc <_dtoa_r+0xa14>
8000bbc2:	18 9b       	mov	r11,r12
8000bbc4:	06 9c       	mov	r12,r3
8000bbc6:	e0 a0 05 98 	rcall	8000c6f6 <__mcmp>
8000bbca:	18 96       	mov	r6,r12
8000bbcc:	0e 9c       	mov	r12,r7
8000bbce:	02 9b       	mov	r11,r1
8000bbd0:	e0 a0 05 ac 	rcall	8000c728 <_Bfree>
8000bbd4:	40 cc       	lddsp	r12,sp[0x30]
8000bbd6:	ed ec 10 08 	or	r8,r6,r12
8000bbda:	c0 d1       	brne	8000bbf4 <_dtoa_r+0xa3c>
8000bbdc:	40 db       	lddsp	r11,sp[0x34]
8000bbde:	58 0b       	cp.w	r11,0
8000bbe0:	c0 a1       	brne	8000bbf4 <_dtoa_r+0xa3c>
8000bbe2:	40 26       	lddsp	r6,sp[0x8]
8000bbe4:	e0 40 00 39 	cp.w	r0,57
8000bbe8:	c3 00       	breq	8000bc48 <_dtoa_r+0xa90>
8000bbea:	40 6a       	lddsp	r10,sp[0x18]
8000bbec:	58 0a       	cp.w	r10,0
8000bbee:	e0 89 00 24 	brgt	8000bc36 <_dtoa_r+0xa7e>
8000bbf2:	c2 f8       	rjmp	8000bc50 <_dtoa_r+0xa98>
8000bbf4:	40 69       	lddsp	r9,sp[0x18]
8000bbf6:	58 09       	cp.w	r9,0
8000bbf8:	c0 85       	brlt	8000bc08 <_dtoa_r+0xa50>
8000bbfa:	12 98       	mov	r8,r9
8000bbfc:	40 cc       	lddsp	r12,sp[0x30]
8000bbfe:	18 48       	or	r8,r12
8000bc00:	c1 d1       	brne	8000bc3a <_dtoa_r+0xa82>
8000bc02:	40 db       	lddsp	r11,sp[0x34]
8000bc04:	58 0b       	cp.w	r11,0
8000bc06:	c1 a1       	brne	8000bc3a <_dtoa_r+0xa82>
8000bc08:	0c 99       	mov	r9,r6
8000bc0a:	40 26       	lddsp	r6,sp[0x8]
8000bc0c:	58 09       	cp.w	r9,0
8000bc0e:	e0 8a 00 21 	brle	8000bc50 <_dtoa_r+0xa98>
8000bc12:	06 9b       	mov	r11,r3
8000bc14:	30 1a       	mov	r10,1
8000bc16:	0e 9c       	mov	r12,r7
8000bc18:	e0 a0 06 92 	rcall	8000c93c <__lshift>
8000bc1c:	04 9b       	mov	r11,r2
8000bc1e:	18 93       	mov	r3,r12
8000bc20:	e0 a0 05 6b 	rcall	8000c6f6 <__mcmp>
8000bc24:	e0 89 00 06 	brgt	8000bc30 <_dtoa_r+0xa78>
8000bc28:	c1 41       	brne	8000bc50 <_dtoa_r+0xa98>
8000bc2a:	ed b0 00 00 	bld	r0,0x0
8000bc2e:	c1 11       	brne	8000bc50 <_dtoa_r+0xa98>
8000bc30:	e0 40 00 39 	cp.w	r0,57
8000bc34:	c0 a0       	breq	8000bc48 <_dtoa_r+0xa90>
8000bc36:	2f f0       	sub	r0,-1
8000bc38:	c0 c8       	rjmp	8000bc50 <_dtoa_r+0xa98>
8000bc3a:	58 06       	cp.w	r6,0
8000bc3c:	e0 8a 00 0c 	brle	8000bc54 <_dtoa_r+0xa9c>
8000bc40:	40 26       	lddsp	r6,sp[0x8]
8000bc42:	e0 40 00 39 	cp.w	r0,57
8000bc46:	c0 41       	brne	8000bc4e <_dtoa_r+0xa96>
8000bc48:	33 98       	mov	r8,57
8000bc4a:	0a c8       	st.b	r5++,r8
8000bc4c:	c6 78       	rjmp	8000bd1a <_dtoa_r+0xb62>
8000bc4e:	2f f0       	sub	r0,-1
8000bc50:	0a c0       	st.b	r5++,r0
8000bc52:	c7 58       	rjmp	8000bd3c <_dtoa_r+0xb84>
8000bc54:	0a c0       	st.b	r5++,r0
8000bc56:	40 9a       	lddsp	r10,sp[0x24]
8000bc58:	40 e9       	lddsp	r9,sp[0x38]
8000bc5a:	12 3a       	cp.w	r10,r9
8000bc5c:	c4 30       	breq	8000bce2 <_dtoa_r+0xb2a>
8000bc5e:	06 9b       	mov	r11,r3
8000bc60:	30 09       	mov	r9,0
8000bc62:	30 aa       	mov	r10,10
8000bc64:	0e 9c       	mov	r12,r7
8000bc66:	e0 a0 07 37 	rcall	8000cad4 <__multadd>
8000bc6a:	40 48       	lddsp	r8,sp[0x10]
8000bc6c:	18 93       	mov	r3,r12
8000bc6e:	08 38       	cp.w	r8,r4
8000bc70:	c0 91       	brne	8000bc82 <_dtoa_r+0xaca>
8000bc72:	10 9b       	mov	r11,r8
8000bc74:	30 09       	mov	r9,0
8000bc76:	30 aa       	mov	r10,10
8000bc78:	0e 9c       	mov	r12,r7
8000bc7a:	e0 a0 07 2d 	rcall	8000cad4 <__multadd>
8000bc7e:	50 4c       	stdsp	sp[0x10],r12
8000bc80:	c0 e8       	rjmp	8000bc9c <_dtoa_r+0xae4>
8000bc82:	40 4b       	lddsp	r11,sp[0x10]
8000bc84:	30 09       	mov	r9,0
8000bc86:	30 aa       	mov	r10,10
8000bc88:	0e 9c       	mov	r12,r7
8000bc8a:	e0 a0 07 25 	rcall	8000cad4 <__multadd>
8000bc8e:	08 9b       	mov	r11,r4
8000bc90:	50 4c       	stdsp	sp[0x10],r12
8000bc92:	30 09       	mov	r9,0
8000bc94:	30 aa       	mov	r10,10
8000bc96:	0e 9c       	mov	r12,r7
8000bc98:	e0 a0 07 1e 	rcall	8000cad4 <__multadd>
8000bc9c:	18 94       	mov	r4,r12
8000bc9e:	40 9c       	lddsp	r12,sp[0x24]
8000bca0:	2f fc       	sub	r12,-1
8000bca2:	50 9c       	stdsp	sp[0x24],r12
8000bca4:	c7 9b       	rjmp	8000bb96 <_dtoa_r+0x9de>
8000bca6:	30 18       	mov	r8,1
8000bca8:	06 90       	mov	r0,r3
8000bcaa:	40 85       	lddsp	r5,sp[0x20]
8000bcac:	08 93       	mov	r3,r4
8000bcae:	0c 94       	mov	r4,r6
8000bcb0:	10 96       	mov	r6,r8
8000bcb2:	04 9b       	mov	r11,r2
8000bcb4:	00 9c       	mov	r12,r0
8000bcb6:	fe b0 f9 f1 	rcall	8000b098 <quorem>
8000bcba:	2d 0c       	sub	r12,-48
8000bcbc:	0a cc       	st.b	r5++,r12
8000bcbe:	02 36       	cp.w	r6,r1
8000bcc0:	c0 a4       	brge	8000bcd4 <_dtoa_r+0xb1c>
8000bcc2:	00 9b       	mov	r11,r0
8000bcc4:	30 09       	mov	r9,0
8000bcc6:	30 aa       	mov	r10,10
8000bcc8:	0e 9c       	mov	r12,r7
8000bcca:	2f f6       	sub	r6,-1
8000bccc:	e0 a0 07 04 	rcall	8000cad4 <__multadd>
8000bcd0:	18 90       	mov	r0,r12
8000bcd2:	cf 0b       	rjmp	8000bcb2 <_dtoa_r+0xafa>
8000bcd4:	08 96       	mov	r6,r4
8000bcd6:	30 0b       	mov	r11,0
8000bcd8:	06 94       	mov	r4,r3
8000bcda:	50 4b       	stdsp	sp[0x10],r11
8000bcdc:	00 93       	mov	r3,r0
8000bcde:	18 90       	mov	r0,r12
8000bce0:	c0 28       	rjmp	8000bce4 <_dtoa_r+0xb2c>
8000bce2:	40 26       	lddsp	r6,sp[0x8]
8000bce4:	06 9b       	mov	r11,r3
8000bce6:	30 1a       	mov	r10,1
8000bce8:	0e 9c       	mov	r12,r7
8000bcea:	e0 a0 06 29 	rcall	8000c93c <__lshift>
8000bcee:	04 9b       	mov	r11,r2
8000bcf0:	18 93       	mov	r3,r12
8000bcf2:	e0 a0 05 02 	rcall	8000c6f6 <__mcmp>
8000bcf6:	e0 89 00 12 	brgt	8000bd1a <_dtoa_r+0xb62>
8000bcfa:	c1 b1       	brne	8000bd30 <_dtoa_r+0xb78>
8000bcfc:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bd00:	c0 d1       	brne	8000bd1a <_dtoa_r+0xb62>
8000bd02:	c1 78       	rjmp	8000bd30 <_dtoa_r+0xb78>
8000bd04:	40 89       	lddsp	r9,sp[0x20]
8000bd06:	12 38       	cp.w	r8,r9
8000bd08:	c0 30       	breq	8000bd0e <_dtoa_r+0xb56>
8000bd0a:	10 95       	mov	r5,r8
8000bd0c:	c0 88       	rjmp	8000bd1c <_dtoa_r+0xb64>
8000bd0e:	2f f6       	sub	r6,-1
8000bd10:	50 66       	stdsp	sp[0x18],r6
8000bd12:	33 18       	mov	r8,49
8000bd14:	40 8c       	lddsp	r12,sp[0x20]
8000bd16:	b8 88       	st.b	r12[0x0],r8
8000bd18:	c1 38       	rjmp	8000bd3e <_dtoa_r+0xb86>
8000bd1a:	33 9a       	mov	r10,57
8000bd1c:	0a 98       	mov	r8,r5
8000bd1e:	11 79       	ld.ub	r9,--r8
8000bd20:	f4 09 18 00 	cp.b	r9,r10
8000bd24:	cf 00       	breq	8000bd04 <_dtoa_r+0xb4c>
8000bd26:	2f f9       	sub	r9,-1
8000bd28:	b0 89       	st.b	r8[0x0],r9
8000bd2a:	c0 98       	rjmp	8000bd3c <_dtoa_r+0xb84>
8000bd2c:	10 95       	mov	r5,r8
8000bd2e:	c0 28       	rjmp	8000bd32 <_dtoa_r+0xb7a>
8000bd30:	33 09       	mov	r9,48
8000bd32:	0a 98       	mov	r8,r5
8000bd34:	11 7a       	ld.ub	r10,--r8
8000bd36:	f2 0a 18 00 	cp.b	r10,r9
8000bd3a:	cf 90       	breq	8000bd2c <_dtoa_r+0xb74>
8000bd3c:	50 66       	stdsp	sp[0x18],r6
8000bd3e:	04 9b       	mov	r11,r2
8000bd40:	0e 9c       	mov	r12,r7
8000bd42:	e0 a0 04 f3 	rcall	8000c728 <_Bfree>
8000bd46:	58 04       	cp.w	r4,0
8000bd48:	c1 20       	breq	8000bd6c <_dtoa_r+0xbb4>
8000bd4a:	40 4b       	lddsp	r11,sp[0x10]
8000bd4c:	08 3b       	cp.w	r11,r4
8000bd4e:	5f 19       	srne	r9
8000bd50:	58 0b       	cp.w	r11,0
8000bd52:	5f 18       	srne	r8
8000bd54:	f3 e8 00 08 	and	r8,r9,r8
8000bd58:	c0 40       	breq	8000bd60 <_dtoa_r+0xba8>
8000bd5a:	0e 9c       	mov	r12,r7
8000bd5c:	e0 a0 04 e6 	rcall	8000c728 <_Bfree>
8000bd60:	08 9b       	mov	r11,r4
8000bd62:	0e 9c       	mov	r12,r7
8000bd64:	e0 a0 04 e2 	rcall	8000c728 <_Bfree>
8000bd68:	c0 28       	rjmp	8000bd6c <_dtoa_r+0xbb4>
8000bd6a:	50 66       	stdsp	sp[0x18],r6
8000bd6c:	0e 9c       	mov	r12,r7
8000bd6e:	06 9b       	mov	r11,r3
8000bd70:	e0 a0 04 dc 	rcall	8000c728 <_Bfree>
8000bd74:	30 08       	mov	r8,0
8000bd76:	aa 88       	st.b	r5[0x0],r8
8000bd78:	40 68       	lddsp	r8,sp[0x18]
8000bd7a:	41 5a       	lddsp	r10,sp[0x54]
8000bd7c:	2f f8       	sub	r8,-1
8000bd7e:	41 29       	lddsp	r9,sp[0x48]
8000bd80:	95 08       	st.w	r10[0x0],r8
8000bd82:	40 8c       	lddsp	r12,sp[0x20]
8000bd84:	58 09       	cp.w	r9,0
8000bd86:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bd8a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bd8e:	2e 6d       	sub	sp,-104
8000bd90:	d8 32       	popm	r0-r7,pc
8000bd92:	d7 03       	nop

8000bd94 <__errno>:
8000bd94:	e0 68 0a 54 	mov	r8,2644
8000bd98:	70 0c       	ld.w	r12,r8[0x0]
8000bd9a:	2f 4c       	sub	r12,-12
8000bd9c:	5e fc       	retal	r12
8000bd9e:	d7 03       	nop

8000bda0 <_fflush_r>:
8000bda0:	d4 21       	pushm	r4-r7,lr
8000bda2:	16 97       	mov	r7,r11
8000bda4:	18 96       	mov	r6,r12
8000bda6:	76 48       	ld.w	r8,r11[0x10]
8000bda8:	58 08       	cp.w	r8,0
8000bdaa:	c7 f0       	breq	8000bea8 <_fflush_r+0x108>
8000bdac:	58 0c       	cp.w	r12,0
8000bdae:	c0 50       	breq	8000bdb8 <_fflush_r+0x18>
8000bdb0:	78 68       	ld.w	r8,r12[0x18]
8000bdb2:	58 08       	cp.w	r8,0
8000bdb4:	c0 21       	brne	8000bdb8 <_fflush_r+0x18>
8000bdb6:	cc dc       	rcall	8000bf50 <__sinit>
8000bdb8:	fe c8 c9 0c 	sub	r8,pc,-14068
8000bdbc:	10 37       	cp.w	r7,r8
8000bdbe:	c0 31       	brne	8000bdc4 <_fflush_r+0x24>
8000bdc0:	6c 07       	ld.w	r7,r6[0x0]
8000bdc2:	c0 c8       	rjmp	8000bdda <_fflush_r+0x3a>
8000bdc4:	fe c8 c8 f8 	sub	r8,pc,-14088
8000bdc8:	10 37       	cp.w	r7,r8
8000bdca:	c0 31       	brne	8000bdd0 <_fflush_r+0x30>
8000bdcc:	6c 17       	ld.w	r7,r6[0x4]
8000bdce:	c0 68       	rjmp	8000bdda <_fflush_r+0x3a>
8000bdd0:	fe c8 c8 e4 	sub	r8,pc,-14108
8000bdd4:	10 37       	cp.w	r7,r8
8000bdd6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdda:	8e 6a       	ld.sh	r10,r7[0xc]
8000bddc:	14 98       	mov	r8,r10
8000bdde:	ed ba 00 03 	bld	r10,0x3
8000bde2:	c4 20       	breq	8000be66 <_fflush_r+0xc6>
8000bde4:	ab ba       	sbr	r10,0xb
8000bde6:	ae 6a       	st.h	r7[0xc],r10
8000bde8:	6e 18       	ld.w	r8,r7[0x4]
8000bdea:	58 08       	cp.w	r8,0
8000bdec:	e0 89 00 06 	brgt	8000bdf8 <_fflush_r+0x58>
8000bdf0:	6f 08       	ld.w	r8,r7[0x40]
8000bdf2:	58 08       	cp.w	r8,0
8000bdf4:	e0 8a 00 5a 	brle	8000bea8 <_fflush_r+0x108>
8000bdf8:	6e b8       	ld.w	r8,r7[0x2c]
8000bdfa:	58 08       	cp.w	r8,0
8000bdfc:	c5 60       	breq	8000bea8 <_fflush_r+0x108>
8000bdfe:	e2 1a 10 00 	andl	r10,0x1000,COH
8000be02:	c0 30       	breq	8000be08 <_fflush_r+0x68>
8000be04:	6f 55       	ld.w	r5,r7[0x54]
8000be06:	c0 f8       	rjmp	8000be24 <_fflush_r+0x84>
8000be08:	30 19       	mov	r9,1
8000be0a:	6e 8b       	ld.w	r11,r7[0x20]
8000be0c:	0c 9c       	mov	r12,r6
8000be0e:	5d 18       	icall	r8
8000be10:	18 95       	mov	r5,r12
8000be12:	5b fc       	cp.w	r12,-1
8000be14:	c0 81       	brne	8000be24 <_fflush_r+0x84>
8000be16:	6c 38       	ld.w	r8,r6[0xc]
8000be18:	59 d8       	cp.w	r8,29
8000be1a:	c4 70       	breq	8000bea8 <_fflush_r+0x108>
8000be1c:	8e 68       	ld.sh	r8,r7[0xc]
8000be1e:	a7 a8       	sbr	r8,0x6
8000be20:	ae 68       	st.h	r7[0xc],r8
8000be22:	d8 22       	popm	r4-r7,pc
8000be24:	8e 68       	ld.sh	r8,r7[0xc]
8000be26:	ed b8 00 02 	bld	r8,0x2
8000be2a:	c0 91       	brne	8000be3c <_fflush_r+0x9c>
8000be2c:	6e 18       	ld.w	r8,r7[0x4]
8000be2e:	10 15       	sub	r5,r8
8000be30:	6e d8       	ld.w	r8,r7[0x34]
8000be32:	58 08       	cp.w	r8,0
8000be34:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000be38:	eb d8 e1 15 	subne	r5,r5,r8
8000be3c:	6e b8       	ld.w	r8,r7[0x2c]
8000be3e:	0c 9c       	mov	r12,r6
8000be40:	30 09       	mov	r9,0
8000be42:	0a 9a       	mov	r10,r5
8000be44:	6e 8b       	ld.w	r11,r7[0x20]
8000be46:	5d 18       	icall	r8
8000be48:	8e 68       	ld.sh	r8,r7[0xc]
8000be4a:	0a 3c       	cp.w	r12,r5
8000be4c:	c2 61       	brne	8000be98 <_fflush_r+0xf8>
8000be4e:	ab d8       	cbr	r8,0xb
8000be50:	30 0c       	mov	r12,0
8000be52:	6e 49       	ld.w	r9,r7[0x10]
8000be54:	ae 68       	st.h	r7[0xc],r8
8000be56:	8f 1c       	st.w	r7[0x4],r12
8000be58:	8f 09       	st.w	r7[0x0],r9
8000be5a:	ed b8 00 0c 	bld	r8,0xc
8000be5e:	c2 51       	brne	8000bea8 <_fflush_r+0x108>
8000be60:	ef 45 00 54 	st.w	r7[84],r5
8000be64:	d8 22       	popm	r4-r7,pc
8000be66:	6e 45       	ld.w	r5,r7[0x10]
8000be68:	58 05       	cp.w	r5,0
8000be6a:	c1 f0       	breq	8000bea8 <_fflush_r+0x108>
8000be6c:	6e 04       	ld.w	r4,r7[0x0]
8000be6e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000be72:	8f 05       	st.w	r7[0x0],r5
8000be74:	f9 b8 01 00 	movne	r8,0
8000be78:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000be7c:	0a 14       	sub	r4,r5
8000be7e:	8f 28       	st.w	r7[0x8],r8
8000be80:	c1 18       	rjmp	8000bea2 <_fflush_r+0x102>
8000be82:	08 99       	mov	r9,r4
8000be84:	0a 9a       	mov	r10,r5
8000be86:	6e a8       	ld.w	r8,r7[0x28]
8000be88:	6e 8b       	ld.w	r11,r7[0x20]
8000be8a:	0c 9c       	mov	r12,r6
8000be8c:	5d 18       	icall	r8
8000be8e:	18 14       	sub	r4,r12
8000be90:	58 0c       	cp.w	r12,0
8000be92:	e0 89 00 07 	brgt	8000bea0 <_fflush_r+0x100>
8000be96:	8e 68       	ld.sh	r8,r7[0xc]
8000be98:	a7 a8       	sbr	r8,0x6
8000be9a:	3f fc       	mov	r12,-1
8000be9c:	ae 68       	st.h	r7[0xc],r8
8000be9e:	d8 22       	popm	r4-r7,pc
8000bea0:	18 05       	add	r5,r12
8000bea2:	58 04       	cp.w	r4,0
8000bea4:	fe 99 ff ef 	brgt	8000be82 <_fflush_r+0xe2>
8000bea8:	d8 2a       	popm	r4-r7,pc,r12=0
8000beaa:	d7 03       	nop

8000beac <__sfp_lock_acquire>:
8000beac:	5e fc       	retal	r12

8000beae <__sfp_lock_release>:
8000beae:	5e fc       	retal	r12

8000beb0 <_cleanup_r>:
8000beb0:	d4 01       	pushm	lr
8000beb2:	fe cb f0 ae 	sub	r11,pc,-3922
8000beb6:	e0 a0 02 f7 	rcall	8000c4a4 <_fwalk>
8000beba:	d8 02       	popm	pc

8000bebc <__sfmoreglue>:
8000bebc:	d4 21       	pushm	r4-r7,lr
8000bebe:	16 95       	mov	r5,r11
8000bec0:	f6 06 10 5c 	mul	r6,r11,92
8000bec4:	ec cb ff f4 	sub	r11,r6,-12
8000bec8:	fe b0 e2 76 	rcall	800083b4 <_malloc_r>
8000becc:	18 97       	mov	r7,r12
8000bece:	c0 90       	breq	8000bee0 <__sfmoreglue+0x24>
8000bed0:	99 15       	st.w	r12[0x4],r5
8000bed2:	30 0b       	mov	r11,0
8000bed4:	2f 4c       	sub	r12,-12
8000bed6:	0c 9a       	mov	r10,r6
8000bed8:	8f 2c       	st.w	r7[0x8],r12
8000beda:	8f 0b       	st.w	r7[0x0],r11
8000bedc:	fe b0 e5 3f 	rcall	8000895a <memset>
8000bee0:	0e 9c       	mov	r12,r7
8000bee2:	d8 22       	popm	r4-r7,pc

8000bee4 <__sfp>:
8000bee4:	d4 21       	pushm	r4-r7,lr
8000bee6:	fe c8 c9 d6 	sub	r8,pc,-13866
8000beea:	18 96       	mov	r6,r12
8000beec:	70 07       	ld.w	r7,r8[0x0]
8000beee:	6e 68       	ld.w	r8,r7[0x18]
8000bef0:	58 08       	cp.w	r8,0
8000bef2:	c0 31       	brne	8000bef8 <__sfp+0x14>
8000bef4:	0e 9c       	mov	r12,r7
8000bef6:	c2 dc       	rcall	8000bf50 <__sinit>
8000bef8:	ee c7 ff 28 	sub	r7,r7,-216
8000befc:	30 05       	mov	r5,0
8000befe:	6e 2c       	ld.w	r12,r7[0x8]
8000bf00:	6e 18       	ld.w	r8,r7[0x4]
8000bf02:	c0 68       	rjmp	8000bf0e <__sfp+0x2a>
8000bf04:	98 69       	ld.sh	r9,r12[0xc]
8000bf06:	ea 09 19 00 	cp.h	r9,r5
8000bf0a:	c1 10       	breq	8000bf2c <__sfp+0x48>
8000bf0c:	2a 4c       	sub	r12,-92
8000bf0e:	20 18       	sub	r8,1
8000bf10:	cf a7       	brpl	8000bf04 <__sfp+0x20>
8000bf12:	6e 08       	ld.w	r8,r7[0x0]
8000bf14:	58 08       	cp.w	r8,0
8000bf16:	c0 61       	brne	8000bf22 <__sfp+0x3e>
8000bf18:	30 4b       	mov	r11,4
8000bf1a:	0c 9c       	mov	r12,r6
8000bf1c:	cd 0f       	rcall	8000bebc <__sfmoreglue>
8000bf1e:	8f 0c       	st.w	r7[0x0],r12
8000bf20:	c0 30       	breq	8000bf26 <__sfp+0x42>
8000bf22:	6e 07       	ld.w	r7,r7[0x0]
8000bf24:	ce db       	rjmp	8000befe <__sfp+0x1a>
8000bf26:	30 c8       	mov	r8,12
8000bf28:	8d 38       	st.w	r6[0xc],r8
8000bf2a:	d8 22       	popm	r4-r7,pc
8000bf2c:	30 08       	mov	r8,0
8000bf2e:	f9 48 00 4c 	st.w	r12[76],r8
8000bf32:	99 08       	st.w	r12[0x0],r8
8000bf34:	99 28       	st.w	r12[0x8],r8
8000bf36:	99 18       	st.w	r12[0x4],r8
8000bf38:	99 48       	st.w	r12[0x10],r8
8000bf3a:	99 58       	st.w	r12[0x14],r8
8000bf3c:	99 68       	st.w	r12[0x18],r8
8000bf3e:	99 d8       	st.w	r12[0x34],r8
8000bf40:	99 e8       	st.w	r12[0x38],r8
8000bf42:	f9 48 00 48 	st.w	r12[72],r8
8000bf46:	3f f8       	mov	r8,-1
8000bf48:	b8 78       	st.h	r12[0xe],r8
8000bf4a:	30 18       	mov	r8,1
8000bf4c:	b8 68       	st.h	r12[0xc],r8
8000bf4e:	d8 22       	popm	r4-r7,pc

8000bf50 <__sinit>:
8000bf50:	d4 21       	pushm	r4-r7,lr
8000bf52:	18 96       	mov	r6,r12
8000bf54:	78 67       	ld.w	r7,r12[0x18]
8000bf56:	58 07       	cp.w	r7,0
8000bf58:	c4 91       	brne	8000bfea <__sinit+0x9a>
8000bf5a:	fe c8 00 aa 	sub	r8,pc,170
8000bf5e:	30 15       	mov	r5,1
8000bf60:	99 a8       	st.w	r12[0x28],r8
8000bf62:	f9 47 00 d8 	st.w	r12[216],r7
8000bf66:	f9 47 00 dc 	st.w	r12[220],r7
8000bf6a:	f9 47 00 e0 	st.w	r12[224],r7
8000bf6e:	99 65       	st.w	r12[0x18],r5
8000bf70:	cb af       	rcall	8000bee4 <__sfp>
8000bf72:	8d 0c       	st.w	r6[0x0],r12
8000bf74:	0c 9c       	mov	r12,r6
8000bf76:	cb 7f       	rcall	8000bee4 <__sfp>
8000bf78:	8d 1c       	st.w	r6[0x4],r12
8000bf7a:	0c 9c       	mov	r12,r6
8000bf7c:	cb 4f       	rcall	8000bee4 <__sfp>
8000bf7e:	6c 09       	ld.w	r9,r6[0x0]
8000bf80:	30 48       	mov	r8,4
8000bf82:	93 07       	st.w	r9[0x0],r7
8000bf84:	b2 68       	st.h	r9[0xc],r8
8000bf86:	93 17       	st.w	r9[0x4],r7
8000bf88:	93 27       	st.w	r9[0x8],r7
8000bf8a:	6c 18       	ld.w	r8,r6[0x4]
8000bf8c:	b2 77       	st.h	r9[0xe],r7
8000bf8e:	93 47       	st.w	r9[0x10],r7
8000bf90:	93 57       	st.w	r9[0x14],r7
8000bf92:	93 67       	st.w	r9[0x18],r7
8000bf94:	93 89       	st.w	r9[0x20],r9
8000bf96:	91 07       	st.w	r8[0x0],r7
8000bf98:	91 17       	st.w	r8[0x4],r7
8000bf9a:	91 27       	st.w	r8[0x8],r7
8000bf9c:	fe ce f3 24 	sub	lr,pc,-3292
8000bfa0:	fe cb f3 54 	sub	r11,pc,-3244
8000bfa4:	93 9e       	st.w	r9[0x24],lr
8000bfa6:	93 ab       	st.w	r9[0x28],r11
8000bfa8:	fe ca f3 7c 	sub	r10,pc,-3204
8000bfac:	fe c4 f3 88 	sub	r4,pc,-3192
8000bfb0:	93 ba       	st.w	r9[0x2c],r10
8000bfb2:	93 c4       	st.w	r9[0x30],r4
8000bfb4:	30 99       	mov	r9,9
8000bfb6:	b0 69       	st.h	r8[0xc],r9
8000bfb8:	b0 75       	st.h	r8[0xe],r5
8000bfba:	91 c4       	st.w	r8[0x30],r4
8000bfbc:	91 47       	st.w	r8[0x10],r7
8000bfbe:	91 57       	st.w	r8[0x14],r7
8000bfc0:	91 67       	st.w	r8[0x18],r7
8000bfc2:	91 88       	st.w	r8[0x20],r8
8000bfc4:	91 9e       	st.w	r8[0x24],lr
8000bfc6:	91 ab       	st.w	r8[0x28],r11
8000bfc8:	91 ba       	st.w	r8[0x2c],r10
8000bfca:	8d 2c       	st.w	r6[0x8],r12
8000bfcc:	31 28       	mov	r8,18
8000bfce:	99 07       	st.w	r12[0x0],r7
8000bfd0:	b8 68       	st.h	r12[0xc],r8
8000bfd2:	99 17       	st.w	r12[0x4],r7
8000bfd4:	99 27       	st.w	r12[0x8],r7
8000bfd6:	30 28       	mov	r8,2
8000bfd8:	b8 78       	st.h	r12[0xe],r8
8000bfda:	99 c4       	st.w	r12[0x30],r4
8000bfdc:	99 67       	st.w	r12[0x18],r7
8000bfde:	99 9e       	st.w	r12[0x24],lr
8000bfe0:	99 ab       	st.w	r12[0x28],r11
8000bfe2:	99 ba       	st.w	r12[0x2c],r10
8000bfe4:	99 47       	st.w	r12[0x10],r7
8000bfe6:	99 57       	st.w	r12[0x14],r7
8000bfe8:	99 8c       	st.w	r12[0x20],r12
8000bfea:	d8 22       	popm	r4-r7,pc

8000bfec <_malloc_trim_r>:
8000bfec:	d4 21       	pushm	r4-r7,lr
8000bfee:	16 95       	mov	r5,r11
8000bff0:	18 97       	mov	r7,r12
8000bff2:	fe b0 d7 97 	rcall	80006f20 <__malloc_lock>
8000bff6:	e0 64 05 54 	mov	r4,1364
8000bffa:	68 28       	ld.w	r8,r4[0x8]
8000bffc:	70 16       	ld.w	r6,r8[0x4]
8000bffe:	e0 16 ff fc 	andl	r6,0xfffc
8000c002:	ec c8 ff 91 	sub	r8,r6,-111
8000c006:	f0 05 01 05 	sub	r5,r8,r5
8000c00a:	e0 15 ff 80 	andl	r5,0xff80
8000c00e:	ea c5 00 80 	sub	r5,r5,128
8000c012:	e0 45 00 7f 	cp.w	r5,127
8000c016:	e0 8a 00 25 	brle	8000c060 <_malloc_trim_r+0x74>
8000c01a:	30 0b       	mov	r11,0
8000c01c:	0e 9c       	mov	r12,r7
8000c01e:	fe b0 e6 05 	rcall	80008c28 <_sbrk_r>
8000c022:	68 28       	ld.w	r8,r4[0x8]
8000c024:	0c 08       	add	r8,r6
8000c026:	10 3c       	cp.w	r12,r8
8000c028:	c1 c1       	brne	8000c060 <_malloc_trim_r+0x74>
8000c02a:	ea 0b 11 00 	rsub	r11,r5,0
8000c02e:	0e 9c       	mov	r12,r7
8000c030:	fe b0 e5 fc 	rcall	80008c28 <_sbrk_r>
8000c034:	5b fc       	cp.w	r12,-1
8000c036:	c1 91       	brne	8000c068 <_malloc_trim_r+0x7c>
8000c038:	30 0b       	mov	r11,0
8000c03a:	0e 9c       	mov	r12,r7
8000c03c:	fe b0 e5 f6 	rcall	80008c28 <_sbrk_r>
8000c040:	68 28       	ld.w	r8,r4[0x8]
8000c042:	f8 08 01 09 	sub	r9,r12,r8
8000c046:	58 f9       	cp.w	r9,15
8000c048:	e0 8a 00 0c 	brle	8000c060 <_malloc_trim_r+0x74>
8000c04c:	a1 a9       	sbr	r9,0x0
8000c04e:	91 19       	st.w	r8[0x4],r9
8000c050:	e0 68 09 60 	mov	r8,2400
8000c054:	70 09       	ld.w	r9,r8[0x0]
8000c056:	e0 68 0d f0 	mov	r8,3568
8000c05a:	f8 09 01 09 	sub	r9,r12,r9
8000c05e:	91 09       	st.w	r8[0x0],r9
8000c060:	0e 9c       	mov	r12,r7
8000c062:	fe b0 d7 65 	rcall	80006f2c <__malloc_unlock>
8000c066:	d8 2a       	popm	r4-r7,pc,r12=0
8000c068:	68 28       	ld.w	r8,r4[0x8]
8000c06a:	0a 16       	sub	r6,r5
8000c06c:	a1 a6       	sbr	r6,0x0
8000c06e:	91 16       	st.w	r8[0x4],r6
8000c070:	e0 68 0d f0 	mov	r8,3568
8000c074:	70 09       	ld.w	r9,r8[0x0]
8000c076:	0a 19       	sub	r9,r5
8000c078:	0e 9c       	mov	r12,r7
8000c07a:	91 09       	st.w	r8[0x0],r9
8000c07c:	fe b0 d7 58 	rcall	80006f2c <__malloc_unlock>
8000c080:	da 2a       	popm	r4-r7,pc,r12=1
8000c082:	d7 03       	nop

8000c084 <_free_r>:
8000c084:	d4 21       	pushm	r4-r7,lr
8000c086:	16 96       	mov	r6,r11
8000c088:	18 97       	mov	r7,r12
8000c08a:	58 0b       	cp.w	r11,0
8000c08c:	e0 80 00 c0 	breq	8000c20c <_free_r+0x188>
8000c090:	fe b0 d7 48 	rcall	80006f20 <__malloc_lock>
8000c094:	20 86       	sub	r6,8
8000c096:	e0 6a 05 54 	mov	r10,1364
8000c09a:	6c 18       	ld.w	r8,r6[0x4]
8000c09c:	74 2e       	ld.w	lr,r10[0x8]
8000c09e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000c0a2:	a1 c8       	cbr	r8,0x0
8000c0a4:	ec 08 00 09 	add	r9,r6,r8
8000c0a8:	72 1b       	ld.w	r11,r9[0x4]
8000c0aa:	e0 1b ff fc 	andl	r11,0xfffc
8000c0ae:	1c 39       	cp.w	r9,lr
8000c0b0:	c1 e1       	brne	8000c0ec <_free_r+0x68>
8000c0b2:	f6 08 00 08 	add	r8,r11,r8
8000c0b6:	58 0c       	cp.w	r12,0
8000c0b8:	c0 81       	brne	8000c0c8 <_free_r+0x44>
8000c0ba:	6c 09       	ld.w	r9,r6[0x0]
8000c0bc:	12 16       	sub	r6,r9
8000c0be:	12 08       	add	r8,r9
8000c0c0:	6c 3b       	ld.w	r11,r6[0xc]
8000c0c2:	6c 29       	ld.w	r9,r6[0x8]
8000c0c4:	97 29       	st.w	r11[0x8],r9
8000c0c6:	93 3b       	st.w	r9[0xc],r11
8000c0c8:	10 99       	mov	r9,r8
8000c0ca:	95 26       	st.w	r10[0x8],r6
8000c0cc:	a1 a9       	sbr	r9,0x0
8000c0ce:	8d 19       	st.w	r6[0x4],r9
8000c0d0:	e0 69 09 5c 	mov	r9,2396
8000c0d4:	72 09       	ld.w	r9,r9[0x0]
8000c0d6:	12 38       	cp.w	r8,r9
8000c0d8:	c0 63       	brcs	8000c0e4 <_free_r+0x60>
8000c0da:	e0 68 0d ec 	mov	r8,3564
8000c0de:	0e 9c       	mov	r12,r7
8000c0e0:	70 0b       	ld.w	r11,r8[0x0]
8000c0e2:	c8 5f       	rcall	8000bfec <_malloc_trim_r>
8000c0e4:	0e 9c       	mov	r12,r7
8000c0e6:	fe b0 d7 23 	rcall	80006f2c <__malloc_unlock>
8000c0ea:	d8 22       	popm	r4-r7,pc
8000c0ec:	93 1b       	st.w	r9[0x4],r11
8000c0ee:	58 0c       	cp.w	r12,0
8000c0f0:	c0 30       	breq	8000c0f6 <_free_r+0x72>
8000c0f2:	30 0c       	mov	r12,0
8000c0f4:	c1 08       	rjmp	8000c114 <_free_r+0x90>
8000c0f6:	6c 0e       	ld.w	lr,r6[0x0]
8000c0f8:	f4 c5 ff f8 	sub	r5,r10,-8
8000c0fc:	1c 16       	sub	r6,lr
8000c0fe:	1c 08       	add	r8,lr
8000c100:	6c 2e       	ld.w	lr,r6[0x8]
8000c102:	0a 3e       	cp.w	lr,r5
8000c104:	f9 bc 00 01 	moveq	r12,1
8000c108:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000c10c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000c110:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000c114:	f2 0b 00 0e 	add	lr,r9,r11
8000c118:	7c 1e       	ld.w	lr,lr[0x4]
8000c11a:	ed be 00 00 	bld	lr,0x0
8000c11e:	c1 40       	breq	8000c146 <_free_r+0xc2>
8000c120:	16 08       	add	r8,r11
8000c122:	58 0c       	cp.w	r12,0
8000c124:	c0 d1       	brne	8000c13e <_free_r+0xba>
8000c126:	e0 6e 05 54 	mov	lr,1364
8000c12a:	72 2b       	ld.w	r11,r9[0x8]
8000c12c:	2f 8e       	sub	lr,-8
8000c12e:	1c 3b       	cp.w	r11,lr
8000c130:	c0 71       	brne	8000c13e <_free_r+0xba>
8000c132:	97 36       	st.w	r11[0xc],r6
8000c134:	97 26       	st.w	r11[0x8],r6
8000c136:	8d 2b       	st.w	r6[0x8],r11
8000c138:	8d 3b       	st.w	r6[0xc],r11
8000c13a:	30 1c       	mov	r12,1
8000c13c:	c0 58       	rjmp	8000c146 <_free_r+0xc2>
8000c13e:	72 2b       	ld.w	r11,r9[0x8]
8000c140:	72 39       	ld.w	r9,r9[0xc]
8000c142:	93 2b       	st.w	r9[0x8],r11
8000c144:	97 39       	st.w	r11[0xc],r9
8000c146:	10 99       	mov	r9,r8
8000c148:	ec 08 09 08 	st.w	r6[r8],r8
8000c14c:	a1 a9       	sbr	r9,0x0
8000c14e:	8d 19       	st.w	r6[0x4],r9
8000c150:	58 0c       	cp.w	r12,0
8000c152:	c5 a1       	brne	8000c206 <_free_r+0x182>
8000c154:	e0 48 01 ff 	cp.w	r8,511
8000c158:	e0 8b 00 13 	brhi	8000c17e <_free_r+0xfa>
8000c15c:	a3 98       	lsr	r8,0x3
8000c15e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c162:	72 2b       	ld.w	r11,r9[0x8]
8000c164:	8d 39       	st.w	r6[0xc],r9
8000c166:	8d 2b       	st.w	r6[0x8],r11
8000c168:	97 36       	st.w	r11[0xc],r6
8000c16a:	93 26       	st.w	r9[0x8],r6
8000c16c:	a3 48       	asr	r8,0x2
8000c16e:	74 19       	ld.w	r9,r10[0x4]
8000c170:	30 1b       	mov	r11,1
8000c172:	f6 08 09 48 	lsl	r8,r11,r8
8000c176:	f3 e8 10 08 	or	r8,r9,r8
8000c17a:	95 18       	st.w	r10[0x4],r8
8000c17c:	c4 58       	rjmp	8000c206 <_free_r+0x182>
8000c17e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000c182:	58 4b       	cp.w	r11,4
8000c184:	e0 8b 00 06 	brhi	8000c190 <_free_r+0x10c>
8000c188:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c18c:	2c 8b       	sub	r11,-56
8000c18e:	c2 08       	rjmp	8000c1ce <_free_r+0x14a>
8000c190:	59 4b       	cp.w	r11,20
8000c192:	e0 8b 00 04 	brhi	8000c19a <_free_r+0x116>
8000c196:	2a 5b       	sub	r11,-91
8000c198:	c1 b8       	rjmp	8000c1ce <_free_r+0x14a>
8000c19a:	e0 4b 00 54 	cp.w	r11,84
8000c19e:	e0 8b 00 06 	brhi	8000c1aa <_free_r+0x126>
8000c1a2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c1a6:	29 2b       	sub	r11,-110
8000c1a8:	c1 38       	rjmp	8000c1ce <_free_r+0x14a>
8000c1aa:	e0 4b 01 54 	cp.w	r11,340
8000c1ae:	e0 8b 00 06 	brhi	8000c1ba <_free_r+0x136>
8000c1b2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c1b6:	28 9b       	sub	r11,-119
8000c1b8:	c0 b8       	rjmp	8000c1ce <_free_r+0x14a>
8000c1ba:	e0 4b 05 54 	cp.w	r11,1364
8000c1be:	e0 88 00 05 	brls	8000c1c8 <_free_r+0x144>
8000c1c2:	37 eb       	mov	r11,126
8000c1c4:	c0 58       	rjmp	8000c1ce <_free_r+0x14a>
8000c1c6:	d7 03       	nop
8000c1c8:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c1cc:	28 4b       	sub	r11,-124
8000c1ce:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c1d2:	78 29       	ld.w	r9,r12[0x8]
8000c1d4:	18 39       	cp.w	r9,r12
8000c1d6:	c0 e1       	brne	8000c1f2 <_free_r+0x16e>
8000c1d8:	74 18       	ld.w	r8,r10[0x4]
8000c1da:	a3 4b       	asr	r11,0x2
8000c1dc:	30 1c       	mov	r12,1
8000c1de:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c1e2:	f1 eb 10 0b 	or	r11,r8,r11
8000c1e6:	12 98       	mov	r8,r9
8000c1e8:	95 1b       	st.w	r10[0x4],r11
8000c1ea:	c0 a8       	rjmp	8000c1fe <_free_r+0x17a>
8000c1ec:	72 29       	ld.w	r9,r9[0x8]
8000c1ee:	18 39       	cp.w	r9,r12
8000c1f0:	c0 60       	breq	8000c1fc <_free_r+0x178>
8000c1f2:	72 1a       	ld.w	r10,r9[0x4]
8000c1f4:	e0 1a ff fc 	andl	r10,0xfffc
8000c1f8:	14 38       	cp.w	r8,r10
8000c1fa:	cf 93       	brcs	8000c1ec <_free_r+0x168>
8000c1fc:	72 38       	ld.w	r8,r9[0xc]
8000c1fe:	8d 38       	st.w	r6[0xc],r8
8000c200:	8d 29       	st.w	r6[0x8],r9
8000c202:	93 36       	st.w	r9[0xc],r6
8000c204:	91 26       	st.w	r8[0x8],r6
8000c206:	0e 9c       	mov	r12,r7
8000c208:	fe b0 d6 92 	rcall	80006f2c <__malloc_unlock>
8000c20c:	d8 22       	popm	r4-r7,pc
8000c20e:	d7 03       	nop

8000c210 <__sfvwrite_r>:
8000c210:	d4 31       	pushm	r0-r7,lr
8000c212:	20 3d       	sub	sp,12
8000c214:	14 94       	mov	r4,r10
8000c216:	18 95       	mov	r5,r12
8000c218:	16 97       	mov	r7,r11
8000c21a:	74 28       	ld.w	r8,r10[0x8]
8000c21c:	58 08       	cp.w	r8,0
8000c21e:	e0 80 01 40 	breq	8000c49e <__sfvwrite_r+0x28e>
8000c222:	96 68       	ld.sh	r8,r11[0xc]
8000c224:	ed b8 00 03 	bld	r8,0x3
8000c228:	c0 41       	brne	8000c230 <__sfvwrite_r+0x20>
8000c22a:	76 48       	ld.w	r8,r11[0x10]
8000c22c:	58 08       	cp.w	r8,0
8000c22e:	c0 c1       	brne	8000c246 <__sfvwrite_r+0x36>
8000c230:	0e 9b       	mov	r11,r7
8000c232:	0a 9c       	mov	r12,r5
8000c234:	fe b0 f6 c4 	rcall	8000afbc <__swsetup_r>
8000c238:	c0 70       	breq	8000c246 <__sfvwrite_r+0x36>
8000c23a:	8e 68       	ld.sh	r8,r7[0xc]
8000c23c:	a7 a8       	sbr	r8,0x6
8000c23e:	ae 68       	st.h	r7[0xc],r8
8000c240:	30 98       	mov	r8,9
8000c242:	8b 38       	st.w	r5[0xc],r8
8000c244:	c2 b9       	rjmp	8000c49a <__sfvwrite_r+0x28a>
8000c246:	8e 63       	ld.sh	r3,r7[0xc]
8000c248:	68 00       	ld.w	r0,r4[0x0]
8000c24a:	06 96       	mov	r6,r3
8000c24c:	e2 16 00 02 	andl	r6,0x2,COH
8000c250:	c2 10       	breq	8000c292 <__sfvwrite_r+0x82>
8000c252:	30 03       	mov	r3,0
8000c254:	e0 62 04 00 	mov	r2,1024
8000c258:	06 96       	mov	r6,r3
8000c25a:	c0 48       	rjmp	8000c262 <__sfvwrite_r+0x52>
8000c25c:	60 03       	ld.w	r3,r0[0x0]
8000c25e:	60 16       	ld.w	r6,r0[0x4]
8000c260:	2f 80       	sub	r0,-8
8000c262:	58 06       	cp.w	r6,0
8000c264:	cf c0       	breq	8000c25c <__sfvwrite_r+0x4c>
8000c266:	e0 46 04 00 	cp.w	r6,1024
8000c26a:	ec 09 17 80 	movls	r9,r6
8000c26e:	e4 09 17 b0 	movhi	r9,r2
8000c272:	06 9a       	mov	r10,r3
8000c274:	6e a8       	ld.w	r8,r7[0x28]
8000c276:	6e 8b       	ld.w	r11,r7[0x20]
8000c278:	0a 9c       	mov	r12,r5
8000c27a:	5d 18       	icall	r8
8000c27c:	18 16       	sub	r6,r12
8000c27e:	58 0c       	cp.w	r12,0
8000c280:	e0 8a 01 0a 	brle	8000c494 <__sfvwrite_r+0x284>
8000c284:	68 28       	ld.w	r8,r4[0x8]
8000c286:	18 18       	sub	r8,r12
8000c288:	89 28       	st.w	r4[0x8],r8
8000c28a:	e0 80 01 0a 	breq	8000c49e <__sfvwrite_r+0x28e>
8000c28e:	18 03       	add	r3,r12
8000c290:	ce 9b       	rjmp	8000c262 <__sfvwrite_r+0x52>
8000c292:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c296:	c0 70       	breq	8000c2a4 <__sfvwrite_r+0x94>
8000c298:	50 06       	stdsp	sp[0x0],r6
8000c29a:	0c 93       	mov	r3,r6
8000c29c:	0c 91       	mov	r1,r6
8000c29e:	50 15       	stdsp	sp[0x4],r5
8000c2a0:	08 92       	mov	r2,r4
8000c2a2:	c9 c8       	rjmp	8000c3da <__sfvwrite_r+0x1ca>
8000c2a4:	06 96       	mov	r6,r3
8000c2a6:	08 91       	mov	r1,r4
8000c2a8:	c0 48       	rjmp	8000c2b0 <__sfvwrite_r+0xa0>
8000c2aa:	60 03       	ld.w	r3,r0[0x0]
8000c2ac:	60 16       	ld.w	r6,r0[0x4]
8000c2ae:	2f 80       	sub	r0,-8
8000c2b0:	58 06       	cp.w	r6,0
8000c2b2:	cf c0       	breq	8000c2aa <__sfvwrite_r+0x9a>
8000c2b4:	8e 68       	ld.sh	r8,r7[0xc]
8000c2b6:	6e 24       	ld.w	r4,r7[0x8]
8000c2b8:	10 99       	mov	r9,r8
8000c2ba:	e2 19 02 00 	andl	r9,0x200,COH
8000c2be:	c5 50       	breq	8000c368 <__sfvwrite_r+0x158>
8000c2c0:	08 36       	cp.w	r6,r4
8000c2c2:	c4 43       	brcs	8000c34a <__sfvwrite_r+0x13a>
8000c2c4:	10 99       	mov	r9,r8
8000c2c6:	e2 19 04 80 	andl	r9,0x480,COH
8000c2ca:	c4 00       	breq	8000c34a <__sfvwrite_r+0x13a>
8000c2cc:	6e 4b       	ld.w	r11,r7[0x10]
8000c2ce:	6e 09       	ld.w	r9,r7[0x0]
8000c2d0:	16 19       	sub	r9,r11
8000c2d2:	50 09       	stdsp	sp[0x0],r9
8000c2d4:	6e 59       	ld.w	r9,r7[0x14]
8000c2d6:	10 9c       	mov	r12,r8
8000c2d8:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c2dc:	30 28       	mov	r8,2
8000c2de:	f4 08 0c 08 	divs	r8,r10,r8
8000c2e2:	fa e9 00 04 	st.d	sp[4],r8
8000c2e6:	10 94       	mov	r4,r8
8000c2e8:	40 09       	lddsp	r9,sp[0x0]
8000c2ea:	e2 1c 04 00 	andl	r12,0x400,COH
8000c2ee:	2f f9       	sub	r9,-1
8000c2f0:	0c 09       	add	r9,r6
8000c2f2:	12 38       	cp.w	r8,r9
8000c2f4:	f2 04 17 30 	movlo	r4,r9
8000c2f8:	58 0c       	cp.w	r12,0
8000c2fa:	c1 10       	breq	8000c31c <__sfvwrite_r+0x10c>
8000c2fc:	08 9b       	mov	r11,r4
8000c2fe:	0a 9c       	mov	r12,r5
8000c300:	fe b0 e0 5a 	rcall	800083b4 <_malloc_r>
8000c304:	18 92       	mov	r2,r12
8000c306:	c1 40       	breq	8000c32e <__sfvwrite_r+0x11e>
8000c308:	40 0a       	lddsp	r10,sp[0x0]
8000c30a:	6e 4b       	ld.w	r11,r7[0x10]
8000c30c:	fe b0 e2 83 	rcall	80008812 <memcpy>
8000c310:	8e 68       	ld.sh	r8,r7[0xc]
8000c312:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c316:	a7 b8       	sbr	r8,0x7
8000c318:	ae 68       	st.h	r7[0xc],r8
8000c31a:	c0 d8       	rjmp	8000c334 <__sfvwrite_r+0x124>
8000c31c:	08 9a       	mov	r10,r4
8000c31e:	0a 9c       	mov	r12,r5
8000c320:	fe b0 e3 24 	rcall	80008968 <_realloc_r>
8000c324:	18 92       	mov	r2,r12
8000c326:	c0 71       	brne	8000c334 <__sfvwrite_r+0x124>
8000c328:	6e 4b       	ld.w	r11,r7[0x10]
8000c32a:	0a 9c       	mov	r12,r5
8000c32c:	ca ce       	rcall	8000c084 <_free_r>
8000c32e:	30 c8       	mov	r8,12
8000c330:	8b 38       	st.w	r5[0xc],r8
8000c332:	cb 18       	rjmp	8000c494 <__sfvwrite_r+0x284>
8000c334:	40 0a       	lddsp	r10,sp[0x0]
8000c336:	40 09       	lddsp	r9,sp[0x0]
8000c338:	e8 0a 01 0a 	sub	r10,r4,r10
8000c33c:	e4 09 00 08 	add	r8,r2,r9
8000c340:	8f 54       	st.w	r7[0x14],r4
8000c342:	8f 2a       	st.w	r7[0x8],r10
8000c344:	8f 08       	st.w	r7[0x0],r8
8000c346:	8f 42       	st.w	r7[0x10],r2
8000c348:	0c 94       	mov	r4,r6
8000c34a:	08 36       	cp.w	r6,r4
8000c34c:	ec 04 17 30 	movlo	r4,r6
8000c350:	06 9b       	mov	r11,r3
8000c352:	08 9a       	mov	r10,r4
8000c354:	6e 0c       	ld.w	r12,r7[0x0]
8000c356:	c3 ad       	rcall	8000c5ca <memmove>
8000c358:	6e 08       	ld.w	r8,r7[0x0]
8000c35a:	08 08       	add	r8,r4
8000c35c:	8f 08       	st.w	r7[0x0],r8
8000c35e:	6e 28       	ld.w	r8,r7[0x8]
8000c360:	08 18       	sub	r8,r4
8000c362:	0c 94       	mov	r4,r6
8000c364:	8f 28       	st.w	r7[0x8],r8
8000c366:	c2 e8       	rjmp	8000c3c2 <__sfvwrite_r+0x1b2>
8000c368:	08 36       	cp.w	r6,r4
8000c36a:	5f ba       	srhi	r10
8000c36c:	6e 0c       	ld.w	r12,r7[0x0]
8000c36e:	6e 48       	ld.w	r8,r7[0x10]
8000c370:	10 3c       	cp.w	r12,r8
8000c372:	5f b8       	srhi	r8
8000c374:	f5 e8 00 08 	and	r8,r10,r8
8000c378:	f2 08 18 00 	cp.b	r8,r9
8000c37c:	c0 d0       	breq	8000c396 <__sfvwrite_r+0x186>
8000c37e:	06 9b       	mov	r11,r3
8000c380:	08 9a       	mov	r10,r4
8000c382:	c2 4d       	rcall	8000c5ca <memmove>
8000c384:	6e 08       	ld.w	r8,r7[0x0]
8000c386:	08 08       	add	r8,r4
8000c388:	0e 9b       	mov	r11,r7
8000c38a:	8f 08       	st.w	r7[0x0],r8
8000c38c:	0a 9c       	mov	r12,r5
8000c38e:	fe b0 fd 09 	rcall	8000bda0 <_fflush_r>
8000c392:	c1 80       	breq	8000c3c2 <__sfvwrite_r+0x1b2>
8000c394:	c8 08       	rjmp	8000c494 <__sfvwrite_r+0x284>
8000c396:	6e 59       	ld.w	r9,r7[0x14]
8000c398:	12 36       	cp.w	r6,r9
8000c39a:	c0 a3       	brcs	8000c3ae <__sfvwrite_r+0x19e>
8000c39c:	6e a8       	ld.w	r8,r7[0x28]
8000c39e:	06 9a       	mov	r10,r3
8000c3a0:	6e 8b       	ld.w	r11,r7[0x20]
8000c3a2:	0a 9c       	mov	r12,r5
8000c3a4:	5d 18       	icall	r8
8000c3a6:	18 94       	mov	r4,r12
8000c3a8:	e0 89 00 0d 	brgt	8000c3c2 <__sfvwrite_r+0x1b2>
8000c3ac:	c7 48       	rjmp	8000c494 <__sfvwrite_r+0x284>
8000c3ae:	0c 9a       	mov	r10,r6
8000c3b0:	06 9b       	mov	r11,r3
8000c3b2:	c0 cd       	rcall	8000c5ca <memmove>
8000c3b4:	6e 08       	ld.w	r8,r7[0x0]
8000c3b6:	0c 08       	add	r8,r6
8000c3b8:	0c 94       	mov	r4,r6
8000c3ba:	8f 08       	st.w	r7[0x0],r8
8000c3bc:	6e 28       	ld.w	r8,r7[0x8]
8000c3be:	0c 18       	sub	r8,r6
8000c3c0:	8f 28       	st.w	r7[0x8],r8
8000c3c2:	62 28       	ld.w	r8,r1[0x8]
8000c3c4:	08 18       	sub	r8,r4
8000c3c6:	83 28       	st.w	r1[0x8],r8
8000c3c8:	c6 b0       	breq	8000c49e <__sfvwrite_r+0x28e>
8000c3ca:	08 16       	sub	r6,r4
8000c3cc:	08 03       	add	r3,r4
8000c3ce:	c7 1b       	rjmp	8000c2b0 <__sfvwrite_r+0xa0>
8000c3d0:	60 03       	ld.w	r3,r0[0x0]
8000c3d2:	60 11       	ld.w	r1,r0[0x4]
8000c3d4:	30 08       	mov	r8,0
8000c3d6:	2f 80       	sub	r0,-8
8000c3d8:	50 08       	stdsp	sp[0x0],r8
8000c3da:	58 01       	cp.w	r1,0
8000c3dc:	cf a0       	breq	8000c3d0 <__sfvwrite_r+0x1c0>
8000c3de:	40 0a       	lddsp	r10,sp[0x0]
8000c3e0:	58 0a       	cp.w	r10,0
8000c3e2:	c1 41       	brne	8000c40a <__sfvwrite_r+0x1fa>
8000c3e4:	e2 c6 ff ff 	sub	r6,r1,-1
8000c3e8:	02 9a       	mov	r10,r1
8000c3ea:	30 ab       	mov	r11,10
8000c3ec:	06 9c       	mov	r12,r3
8000c3ee:	ce 3c       	rcall	8000c5b4 <memchr>
8000c3f0:	f8 c8 ff ff 	sub	r8,r12,-1
8000c3f4:	58 0c       	cp.w	r12,0
8000c3f6:	f1 d3 e1 16 	subne	r6,r8,r3
8000c3fa:	f9 b9 01 01 	movne	r9,1
8000c3fe:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c402:	f9 b8 00 01 	moveq	r8,1
8000c406:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c40a:	02 36       	cp.w	r6,r1
8000c40c:	ec 04 17 80 	movls	r4,r6
8000c410:	e2 04 17 b0 	movhi	r4,r1
8000c414:	6e 59       	ld.w	r9,r7[0x14]
8000c416:	6e 25       	ld.w	r5,r7[0x8]
8000c418:	f2 05 00 05 	add	r5,r9,r5
8000c41c:	0a 34       	cp.w	r4,r5
8000c41e:	5f 9a       	srgt	r10
8000c420:	6e 0c       	ld.w	r12,r7[0x0]
8000c422:	6e 48       	ld.w	r8,r7[0x10]
8000c424:	10 3c       	cp.w	r12,r8
8000c426:	5f b8       	srhi	r8
8000c428:	f5 e8 00 08 	and	r8,r10,r8
8000c42c:	30 0a       	mov	r10,0
8000c42e:	f4 08 18 00 	cp.b	r8,r10
8000c432:	c0 d0       	breq	8000c44c <__sfvwrite_r+0x23c>
8000c434:	06 9b       	mov	r11,r3
8000c436:	0a 9a       	mov	r10,r5
8000c438:	cc 9c       	rcall	8000c5ca <memmove>
8000c43a:	6e 08       	ld.w	r8,r7[0x0]
8000c43c:	0a 08       	add	r8,r5
8000c43e:	0e 9b       	mov	r11,r7
8000c440:	8f 08       	st.w	r7[0x0],r8
8000c442:	40 1c       	lddsp	r12,sp[0x4]
8000c444:	fe b0 fc ae 	rcall	8000bda0 <_fflush_r>
8000c448:	c1 70       	breq	8000c476 <__sfvwrite_r+0x266>
8000c44a:	c2 58       	rjmp	8000c494 <__sfvwrite_r+0x284>
8000c44c:	12 34       	cp.w	r4,r9
8000c44e:	c0 a5       	brlt	8000c462 <__sfvwrite_r+0x252>
8000c450:	6e a8       	ld.w	r8,r7[0x28]
8000c452:	06 9a       	mov	r10,r3
8000c454:	6e 8b       	ld.w	r11,r7[0x20]
8000c456:	40 1c       	lddsp	r12,sp[0x4]
8000c458:	5d 18       	icall	r8
8000c45a:	18 95       	mov	r5,r12
8000c45c:	e0 89 00 0d 	brgt	8000c476 <__sfvwrite_r+0x266>
8000c460:	c1 a8       	rjmp	8000c494 <__sfvwrite_r+0x284>
8000c462:	08 9a       	mov	r10,r4
8000c464:	06 9b       	mov	r11,r3
8000c466:	cb 2c       	rcall	8000c5ca <memmove>
8000c468:	6e 08       	ld.w	r8,r7[0x0]
8000c46a:	08 08       	add	r8,r4
8000c46c:	08 95       	mov	r5,r4
8000c46e:	8f 08       	st.w	r7[0x0],r8
8000c470:	6e 28       	ld.w	r8,r7[0x8]
8000c472:	08 18       	sub	r8,r4
8000c474:	8f 28       	st.w	r7[0x8],r8
8000c476:	0a 16       	sub	r6,r5
8000c478:	c0 71       	brne	8000c486 <__sfvwrite_r+0x276>
8000c47a:	0e 9b       	mov	r11,r7
8000c47c:	40 1c       	lddsp	r12,sp[0x4]
8000c47e:	fe b0 fc 91 	rcall	8000bda0 <_fflush_r>
8000c482:	c0 91       	brne	8000c494 <__sfvwrite_r+0x284>
8000c484:	50 06       	stdsp	sp[0x0],r6
8000c486:	64 28       	ld.w	r8,r2[0x8]
8000c488:	0a 18       	sub	r8,r5
8000c48a:	85 28       	st.w	r2[0x8],r8
8000c48c:	c0 90       	breq	8000c49e <__sfvwrite_r+0x28e>
8000c48e:	0a 11       	sub	r1,r5
8000c490:	0a 03       	add	r3,r5
8000c492:	ca 4b       	rjmp	8000c3da <__sfvwrite_r+0x1ca>
8000c494:	8e 68       	ld.sh	r8,r7[0xc]
8000c496:	a7 a8       	sbr	r8,0x6
8000c498:	ae 68       	st.h	r7[0xc],r8
8000c49a:	3f fc       	mov	r12,-1
8000c49c:	c0 28       	rjmp	8000c4a0 <__sfvwrite_r+0x290>
8000c49e:	30 0c       	mov	r12,0
8000c4a0:	2f dd       	sub	sp,-12
8000c4a2:	d8 32       	popm	r0-r7,pc

8000c4a4 <_fwalk>:
8000c4a4:	d4 31       	pushm	r0-r7,lr
8000c4a6:	30 05       	mov	r5,0
8000c4a8:	16 91       	mov	r1,r11
8000c4aa:	f8 c7 ff 28 	sub	r7,r12,-216
8000c4ae:	0a 92       	mov	r2,r5
8000c4b0:	fe b0 fc fe 	rcall	8000beac <__sfp_lock_acquire>
8000c4b4:	3f f3       	mov	r3,-1
8000c4b6:	c1 68       	rjmp	8000c4e2 <_fwalk+0x3e>
8000c4b8:	6e 26       	ld.w	r6,r7[0x8]
8000c4ba:	6e 14       	ld.w	r4,r7[0x4]
8000c4bc:	2f 46       	sub	r6,-12
8000c4be:	c0 c8       	rjmp	8000c4d6 <_fwalk+0x32>
8000c4c0:	8c 08       	ld.sh	r8,r6[0x0]
8000c4c2:	e4 08 19 00 	cp.h	r8,r2
8000c4c6:	c0 70       	breq	8000c4d4 <_fwalk+0x30>
8000c4c8:	8c 18       	ld.sh	r8,r6[0x2]
8000c4ca:	e6 08 19 00 	cp.h	r8,r3
8000c4ce:	c0 30       	breq	8000c4d4 <_fwalk+0x30>
8000c4d0:	5d 11       	icall	r1
8000c4d2:	18 45       	or	r5,r12
8000c4d4:	2a 46       	sub	r6,-92
8000c4d6:	20 14       	sub	r4,1
8000c4d8:	ec cc 00 0c 	sub	r12,r6,12
8000c4dc:	58 04       	cp.w	r4,0
8000c4de:	cf 14       	brge	8000c4c0 <_fwalk+0x1c>
8000c4e0:	6e 07       	ld.w	r7,r7[0x0]
8000c4e2:	58 07       	cp.w	r7,0
8000c4e4:	ce a1       	brne	8000c4b8 <_fwalk+0x14>
8000c4e6:	fe b0 fc e4 	rcall	8000beae <__sfp_lock_release>
8000c4ea:	0a 9c       	mov	r12,r5
8000c4ec:	d8 32       	popm	r0-r7,pc
8000c4ee:	d7 03       	nop

8000c4f0 <_localeconv_r>:
8000c4f0:	fe cc cf dc 	sub	r12,pc,-12324
8000c4f4:	5e fc       	retal	r12
8000c4f6:	d7 03       	nop

8000c4f8 <__smakebuf_r>:
8000c4f8:	d4 21       	pushm	r4-r7,lr
8000c4fa:	20 fd       	sub	sp,60
8000c4fc:	96 68       	ld.sh	r8,r11[0xc]
8000c4fe:	16 97       	mov	r7,r11
8000c500:	18 96       	mov	r6,r12
8000c502:	e2 18 00 02 	andl	r8,0x2,COH
8000c506:	c3 d1       	brne	8000c580 <__smakebuf_r+0x88>
8000c508:	96 7b       	ld.sh	r11,r11[0xe]
8000c50a:	f0 0b 19 00 	cp.h	r11,r8
8000c50e:	c0 55       	brlt	8000c518 <__smakebuf_r+0x20>
8000c510:	1a 9a       	mov	r10,sp
8000c512:	e0 a0 04 81 	rcall	8000ce14 <_fstat_r>
8000c516:	c0 f4       	brge	8000c534 <__smakebuf_r+0x3c>
8000c518:	8e 65       	ld.sh	r5,r7[0xc]
8000c51a:	0a 98       	mov	r8,r5
8000c51c:	ab b8       	sbr	r8,0xb
8000c51e:	e2 15 00 80 	andl	r5,0x80,COH
8000c522:	ae 68       	st.h	r7[0xc],r8
8000c524:	30 04       	mov	r4,0
8000c526:	e0 68 04 00 	mov	r8,1024
8000c52a:	f9 b5 01 40 	movne	r5,64
8000c52e:	f0 05 17 00 	moveq	r5,r8
8000c532:	c1 c8       	rjmp	8000c56a <__smakebuf_r+0x72>
8000c534:	40 18       	lddsp	r8,sp[0x4]
8000c536:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c53a:	e0 48 20 00 	cp.w	r8,8192
8000c53e:	5f 04       	sreq	r4
8000c540:	e0 48 80 00 	cp.w	r8,32768
8000c544:	c0 e1       	brne	8000c560 <__smakebuf_r+0x68>
8000c546:	6e b9       	ld.w	r9,r7[0x2c]
8000c548:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c54c:	10 39       	cp.w	r9,r8
8000c54e:	c0 91       	brne	8000c560 <__smakebuf_r+0x68>
8000c550:	8e 68       	ld.sh	r8,r7[0xc]
8000c552:	e0 65 04 00 	mov	r5,1024
8000c556:	ab a8       	sbr	r8,0xa
8000c558:	ef 45 00 50 	st.w	r7[80],r5
8000c55c:	ae 68       	st.h	r7[0xc],r8
8000c55e:	c0 68       	rjmp	8000c56a <__smakebuf_r+0x72>
8000c560:	8e 68       	ld.sh	r8,r7[0xc]
8000c562:	e0 65 04 00 	mov	r5,1024
8000c566:	ab b8       	sbr	r8,0xb
8000c568:	ae 68       	st.h	r7[0xc],r8
8000c56a:	0a 9b       	mov	r11,r5
8000c56c:	0c 9c       	mov	r12,r6
8000c56e:	fe b0 df 23 	rcall	800083b4 <_malloc_r>
8000c572:	8e 68       	ld.sh	r8,r7[0xc]
8000c574:	c0 d1       	brne	8000c58e <__smakebuf_r+0x96>
8000c576:	ed b8 00 09 	bld	r8,0x9
8000c57a:	c1 b0       	breq	8000c5b0 <__smakebuf_r+0xb8>
8000c57c:	a1 b8       	sbr	r8,0x1
8000c57e:	ae 68       	st.h	r7[0xc],r8
8000c580:	ee c8 ff b9 	sub	r8,r7,-71
8000c584:	8f 48       	st.w	r7[0x10],r8
8000c586:	8f 08       	st.w	r7[0x0],r8
8000c588:	30 18       	mov	r8,1
8000c58a:	8f 58       	st.w	r7[0x14],r8
8000c58c:	c1 28       	rjmp	8000c5b0 <__smakebuf_r+0xb8>
8000c58e:	a7 b8       	sbr	r8,0x7
8000c590:	8f 4c       	st.w	r7[0x10],r12
8000c592:	ae 68       	st.h	r7[0xc],r8
8000c594:	8f 55       	st.w	r7[0x14],r5
8000c596:	fe c8 06 e6 	sub	r8,pc,1766
8000c59a:	8f 0c       	st.w	r7[0x0],r12
8000c59c:	8d a8       	st.w	r6[0x28],r8
8000c59e:	58 04       	cp.w	r4,0
8000c5a0:	c0 80       	breq	8000c5b0 <__smakebuf_r+0xb8>
8000c5a2:	8e 7c       	ld.sh	r12,r7[0xe]
8000c5a4:	fe b0 e3 94 	rcall	80008ccc <isatty>
8000c5a8:	c0 40       	breq	8000c5b0 <__smakebuf_r+0xb8>
8000c5aa:	8e 68       	ld.sh	r8,r7[0xc]
8000c5ac:	a1 a8       	sbr	r8,0x0
8000c5ae:	ae 68       	st.h	r7[0xc],r8
8000c5b0:	2f 1d       	sub	sp,-60
8000c5b2:	d8 22       	popm	r4-r7,pc

8000c5b4 <memchr>:
8000c5b4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c5b8:	c0 68       	rjmp	8000c5c4 <memchr+0x10>
8000c5ba:	20 1a       	sub	r10,1
8000c5bc:	19 88       	ld.ub	r8,r12[0x0]
8000c5be:	16 38       	cp.w	r8,r11
8000c5c0:	5e 0c       	reteq	r12
8000c5c2:	2f fc       	sub	r12,-1
8000c5c4:	58 0a       	cp.w	r10,0
8000c5c6:	cf a1       	brne	8000c5ba <memchr+0x6>
8000c5c8:	5e fa       	retal	r10

8000c5ca <memmove>:
8000c5ca:	d4 01       	pushm	lr
8000c5cc:	18 3b       	cp.w	r11,r12
8000c5ce:	c1 92       	brcc	8000c600 <memmove+0x36>
8000c5d0:	f6 0a 00 09 	add	r9,r11,r10
8000c5d4:	12 3c       	cp.w	r12,r9
8000c5d6:	c1 52       	brcc	8000c600 <memmove+0x36>
8000c5d8:	f8 0a 00 0b 	add	r11,r12,r10
8000c5dc:	30 08       	mov	r8,0
8000c5de:	c0 68       	rjmp	8000c5ea <memmove+0x20>
8000c5e0:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c5e4:	20 1a       	sub	r10,1
8000c5e6:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c5ea:	20 18       	sub	r8,1
8000c5ec:	58 0a       	cp.w	r10,0
8000c5ee:	cf 91       	brne	8000c5e0 <memmove+0x16>
8000c5f0:	d8 02       	popm	pc
8000c5f2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c5f6:	20 1a       	sub	r10,1
8000c5f8:	f8 08 0b 09 	st.b	r12[r8],r9
8000c5fc:	2f f8       	sub	r8,-1
8000c5fe:	c0 28       	rjmp	8000c602 <memmove+0x38>
8000c600:	30 08       	mov	r8,0
8000c602:	58 0a       	cp.w	r10,0
8000c604:	cf 71       	brne	8000c5f2 <memmove+0x28>
8000c606:	d8 02       	popm	pc

8000c608 <__hi0bits>:
8000c608:	18 98       	mov	r8,r12
8000c60a:	e0 1c 00 00 	andl	r12,0x0
8000c60e:	f0 09 15 10 	lsl	r9,r8,0x10
8000c612:	58 0c       	cp.w	r12,0
8000c614:	f2 08 17 00 	moveq	r8,r9
8000c618:	f9 bc 00 10 	moveq	r12,16
8000c61c:	f9 bc 01 00 	movne	r12,0
8000c620:	10 9a       	mov	r10,r8
8000c622:	f0 09 15 08 	lsl	r9,r8,0x8
8000c626:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c62a:	f7 bc 00 f8 	subeq	r12,-8
8000c62e:	f2 08 17 00 	moveq	r8,r9
8000c632:	10 9a       	mov	r10,r8
8000c634:	f0 09 15 04 	lsl	r9,r8,0x4
8000c638:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c63c:	f7 bc 00 fc 	subeq	r12,-4
8000c640:	f2 08 17 00 	moveq	r8,r9
8000c644:	10 9a       	mov	r10,r8
8000c646:	f0 09 15 02 	lsl	r9,r8,0x2
8000c64a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c64e:	f7 bc 00 fe 	subeq	r12,-2
8000c652:	f2 08 17 00 	moveq	r8,r9
8000c656:	58 08       	cp.w	r8,0
8000c658:	5e 5c       	retlt	r12
8000c65a:	ed b8 00 1e 	bld	r8,0x1e
8000c65e:	f9 bc 01 20 	movne	r12,32
8000c662:	f7 bc 00 ff 	subeq	r12,-1
8000c666:	5e fc       	retal	r12

8000c668 <__lo0bits>:
8000c668:	18 99       	mov	r9,r12
8000c66a:	78 08       	ld.w	r8,r12[0x0]
8000c66c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c670:	c1 50       	breq	8000c69a <__lo0bits+0x32>
8000c672:	ed b8 00 00 	bld	r8,0x0
8000c676:	c0 21       	brne	8000c67a <__lo0bits+0x12>
8000c678:	5e fd       	retal	0
8000c67a:	10 9b       	mov	r11,r8
8000c67c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c680:	e2 1b 00 02 	andl	r11,0x2,COH
8000c684:	a3 88       	lsr	r8,0x2
8000c686:	58 0b       	cp.w	r11,0
8000c688:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c68c:	f9 bc 01 01 	movne	r12,1
8000c690:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c694:	f9 bc 00 02 	moveq	r12,2
8000c698:	5e fc       	retal	r12
8000c69a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c69e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c6a2:	58 0a       	cp.w	r10,0
8000c6a4:	f6 08 17 00 	moveq	r8,r11
8000c6a8:	f9 bc 00 10 	moveq	r12,16
8000c6ac:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c6b0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c6b4:	58 0b       	cp.w	r11,0
8000c6b6:	f7 bc 00 f8 	subeq	r12,-8
8000c6ba:	f4 08 17 00 	moveq	r8,r10
8000c6be:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c6c2:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c6c6:	58 0b       	cp.w	r11,0
8000c6c8:	f7 bc 00 fc 	subeq	r12,-4
8000c6cc:	f4 08 17 00 	moveq	r8,r10
8000c6d0:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c6d4:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c6d8:	58 0b       	cp.w	r11,0
8000c6da:	f7 bc 00 fe 	subeq	r12,-2
8000c6de:	f4 08 17 00 	moveq	r8,r10
8000c6e2:	ed b8 00 00 	bld	r8,0x0
8000c6e6:	c0 60       	breq	8000c6f2 <__lo0bits+0x8a>
8000c6e8:	a1 98       	lsr	r8,0x1
8000c6ea:	c0 31       	brne	8000c6f0 <__lo0bits+0x88>
8000c6ec:	32 0c       	mov	r12,32
8000c6ee:	5e fc       	retal	r12
8000c6f0:	2f fc       	sub	r12,-1
8000c6f2:	93 08       	st.w	r9[0x0],r8
8000c6f4:	5e fc       	retal	r12

8000c6f6 <__mcmp>:
8000c6f6:	d4 01       	pushm	lr
8000c6f8:	18 98       	mov	r8,r12
8000c6fa:	76 49       	ld.w	r9,r11[0x10]
8000c6fc:	78 4c       	ld.w	r12,r12[0x10]
8000c6fe:	12 1c       	sub	r12,r9
8000c700:	c1 31       	brne	8000c726 <__mcmp+0x30>
8000c702:	2f b9       	sub	r9,-5
8000c704:	a3 69       	lsl	r9,0x2
8000c706:	12 0b       	add	r11,r9
8000c708:	f0 09 00 09 	add	r9,r8,r9
8000c70c:	2e c8       	sub	r8,-20
8000c70e:	13 4e       	ld.w	lr,--r9
8000c710:	17 4a       	ld.w	r10,--r11
8000c712:	14 3e       	cp.w	lr,r10
8000c714:	c0 60       	breq	8000c720 <__mcmp+0x2a>
8000c716:	f9 bc 03 ff 	movlo	r12,-1
8000c71a:	f9 bc 02 01 	movhs	r12,1
8000c71e:	d8 02       	popm	pc
8000c720:	10 39       	cp.w	r9,r8
8000c722:	fe 9b ff f6 	brhi	8000c70e <__mcmp+0x18>
8000c726:	d8 02       	popm	pc

8000c728 <_Bfree>:
8000c728:	d4 21       	pushm	r4-r7,lr
8000c72a:	18 97       	mov	r7,r12
8000c72c:	16 95       	mov	r5,r11
8000c72e:	78 96       	ld.w	r6,r12[0x24]
8000c730:	58 06       	cp.w	r6,0
8000c732:	c0 91       	brne	8000c744 <_Bfree+0x1c>
8000c734:	31 0c       	mov	r12,16
8000c736:	fe b0 de 37 	rcall	800083a4 <malloc>
8000c73a:	99 36       	st.w	r12[0xc],r6
8000c73c:	8f 9c       	st.w	r7[0x24],r12
8000c73e:	99 16       	st.w	r12[0x4],r6
8000c740:	99 26       	st.w	r12[0x8],r6
8000c742:	99 06       	st.w	r12[0x0],r6
8000c744:	58 05       	cp.w	r5,0
8000c746:	c0 90       	breq	8000c758 <_Bfree+0x30>
8000c748:	6a 19       	ld.w	r9,r5[0x4]
8000c74a:	6e 98       	ld.w	r8,r7[0x24]
8000c74c:	70 38       	ld.w	r8,r8[0xc]
8000c74e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c752:	8b 0a       	st.w	r5[0x0],r10
8000c754:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c758:	d8 22       	popm	r4-r7,pc
8000c75a:	d7 03       	nop

8000c75c <_Balloc>:
8000c75c:	d4 21       	pushm	r4-r7,lr
8000c75e:	18 97       	mov	r7,r12
8000c760:	16 96       	mov	r6,r11
8000c762:	78 95       	ld.w	r5,r12[0x24]
8000c764:	58 05       	cp.w	r5,0
8000c766:	c0 91       	brne	8000c778 <_Balloc+0x1c>
8000c768:	31 0c       	mov	r12,16
8000c76a:	fe b0 de 1d 	rcall	800083a4 <malloc>
8000c76e:	99 35       	st.w	r12[0xc],r5
8000c770:	8f 9c       	st.w	r7[0x24],r12
8000c772:	99 15       	st.w	r12[0x4],r5
8000c774:	99 25       	st.w	r12[0x8],r5
8000c776:	99 05       	st.w	r12[0x0],r5
8000c778:	6e 95       	ld.w	r5,r7[0x24]
8000c77a:	6a 38       	ld.w	r8,r5[0xc]
8000c77c:	58 08       	cp.w	r8,0
8000c77e:	c0 b1       	brne	8000c794 <_Balloc+0x38>
8000c780:	31 0a       	mov	r10,16
8000c782:	30 4b       	mov	r11,4
8000c784:	0e 9c       	mov	r12,r7
8000c786:	e0 a0 02 a7 	rcall	8000ccd4 <_calloc_r>
8000c78a:	8b 3c       	st.w	r5[0xc],r12
8000c78c:	6e 98       	ld.w	r8,r7[0x24]
8000c78e:	70 3c       	ld.w	r12,r8[0xc]
8000c790:	58 0c       	cp.w	r12,0
8000c792:	c1 b0       	breq	8000c7c8 <_Balloc+0x6c>
8000c794:	6e 98       	ld.w	r8,r7[0x24]
8000c796:	70 38       	ld.w	r8,r8[0xc]
8000c798:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c79c:	70 0c       	ld.w	r12,r8[0x0]
8000c79e:	58 0c       	cp.w	r12,0
8000c7a0:	c0 40       	breq	8000c7a8 <_Balloc+0x4c>
8000c7a2:	78 09       	ld.w	r9,r12[0x0]
8000c7a4:	91 09       	st.w	r8[0x0],r9
8000c7a6:	c0 e8       	rjmp	8000c7c2 <_Balloc+0x66>
8000c7a8:	0e 9c       	mov	r12,r7
8000c7aa:	30 17       	mov	r7,1
8000c7ac:	0e 9b       	mov	r11,r7
8000c7ae:	ee 06 09 47 	lsl	r7,r7,r6
8000c7b2:	ee ca ff fb 	sub	r10,r7,-5
8000c7b6:	a3 6a       	lsl	r10,0x2
8000c7b8:	e0 a0 02 8e 	rcall	8000ccd4 <_calloc_r>
8000c7bc:	c0 60       	breq	8000c7c8 <_Balloc+0x6c>
8000c7be:	99 16       	st.w	r12[0x4],r6
8000c7c0:	99 27       	st.w	r12[0x8],r7
8000c7c2:	30 08       	mov	r8,0
8000c7c4:	99 38       	st.w	r12[0xc],r8
8000c7c6:	99 48       	st.w	r12[0x10],r8
8000c7c8:	d8 22       	popm	r4-r7,pc
8000c7ca:	d7 03       	nop

8000c7cc <__d2b>:
8000c7cc:	d4 31       	pushm	r0-r7,lr
8000c7ce:	20 2d       	sub	sp,8
8000c7d0:	16 93       	mov	r3,r11
8000c7d2:	12 96       	mov	r6,r9
8000c7d4:	10 95       	mov	r5,r8
8000c7d6:	14 92       	mov	r2,r10
8000c7d8:	30 1b       	mov	r11,1
8000c7da:	cc 1f       	rcall	8000c75c <_Balloc>
8000c7dc:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c7e0:	50 09       	stdsp	sp[0x0],r9
8000c7e2:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c7e6:	b5 a9       	sbr	r9,0x14
8000c7e8:	f0 01 16 14 	lsr	r1,r8,0x14
8000c7ec:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c7f0:	18 94       	mov	r4,r12
8000c7f2:	58 02       	cp.w	r2,0
8000c7f4:	c1 d0       	breq	8000c82e <__d2b+0x62>
8000c7f6:	fa cc ff f8 	sub	r12,sp,-8
8000c7fa:	18 d2       	st.w	--r12,r2
8000c7fc:	c3 6f       	rcall	8000c668 <__lo0bits>
8000c7fe:	40 18       	lddsp	r8,sp[0x4]
8000c800:	c0 d0       	breq	8000c81a <__d2b+0x4e>
8000c802:	40 09       	lddsp	r9,sp[0x0]
8000c804:	f8 0a 11 20 	rsub	r10,r12,32
8000c808:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c80c:	f5 e8 10 08 	or	r8,r10,r8
8000c810:	89 58       	st.w	r4[0x14],r8
8000c812:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c816:	50 09       	stdsp	sp[0x0],r9
8000c818:	c0 28       	rjmp	8000c81c <__d2b+0x50>
8000c81a:	89 58       	st.w	r4[0x14],r8
8000c81c:	40 08       	lddsp	r8,sp[0x0]
8000c81e:	58 08       	cp.w	r8,0
8000c820:	f9 b3 01 02 	movne	r3,2
8000c824:	f9 b3 00 01 	moveq	r3,1
8000c828:	89 68       	st.w	r4[0x18],r8
8000c82a:	89 43       	st.w	r4[0x10],r3
8000c82c:	c0 88       	rjmp	8000c83c <__d2b+0x70>
8000c82e:	1a 9c       	mov	r12,sp
8000c830:	c1 cf       	rcall	8000c668 <__lo0bits>
8000c832:	30 13       	mov	r3,1
8000c834:	40 08       	lddsp	r8,sp[0x0]
8000c836:	2e 0c       	sub	r12,-32
8000c838:	89 43       	st.w	r4[0x10],r3
8000c83a:	89 58       	st.w	r4[0x14],r8
8000c83c:	58 01       	cp.w	r1,0
8000c83e:	c0 90       	breq	8000c850 <__d2b+0x84>
8000c840:	e2 c1 04 33 	sub	r1,r1,1075
8000c844:	18 01       	add	r1,r12
8000c846:	8d 01       	st.w	r6[0x0],r1
8000c848:	f8 0c 11 35 	rsub	r12,r12,53
8000c84c:	8b 0c       	st.w	r5[0x0],r12
8000c84e:	c0 c8       	rjmp	8000c866 <__d2b+0x9a>
8000c850:	e6 c8 ff fc 	sub	r8,r3,-4
8000c854:	f8 cc 04 32 	sub	r12,r12,1074
8000c858:	a5 73       	lsl	r3,0x5
8000c85a:	8d 0c       	st.w	r6[0x0],r12
8000c85c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c860:	cd 4e       	rcall	8000c608 <__hi0bits>
8000c862:	18 13       	sub	r3,r12
8000c864:	8b 03       	st.w	r5[0x0],r3
8000c866:	08 9c       	mov	r12,r4
8000c868:	2f ed       	sub	sp,-8
8000c86a:	d8 32       	popm	r0-r7,pc

8000c86c <__mdiff>:
8000c86c:	d4 31       	pushm	r0-r7,lr
8000c86e:	74 48       	ld.w	r8,r10[0x10]
8000c870:	76 45       	ld.w	r5,r11[0x10]
8000c872:	16 97       	mov	r7,r11
8000c874:	14 96       	mov	r6,r10
8000c876:	10 15       	sub	r5,r8
8000c878:	c1 31       	brne	8000c89e <__mdiff+0x32>
8000c87a:	2f b8       	sub	r8,-5
8000c87c:	ee ce ff ec 	sub	lr,r7,-20
8000c880:	a3 68       	lsl	r8,0x2
8000c882:	f4 08 00 0b 	add	r11,r10,r8
8000c886:	ee 08 00 08 	add	r8,r7,r8
8000c88a:	11 4a       	ld.w	r10,--r8
8000c88c:	17 49       	ld.w	r9,--r11
8000c88e:	12 3a       	cp.w	r10,r9
8000c890:	c0 30       	breq	8000c896 <__mdiff+0x2a>
8000c892:	c0 e2       	brcc	8000c8ae <__mdiff+0x42>
8000c894:	c0 78       	rjmp	8000c8a2 <__mdiff+0x36>
8000c896:	1c 38       	cp.w	r8,lr
8000c898:	fe 9b ff f9 	brhi	8000c88a <__mdiff+0x1e>
8000c89c:	c4 98       	rjmp	8000c92e <__mdiff+0xc2>
8000c89e:	58 05       	cp.w	r5,0
8000c8a0:	c0 64       	brge	8000c8ac <__mdiff+0x40>
8000c8a2:	0e 98       	mov	r8,r7
8000c8a4:	30 15       	mov	r5,1
8000c8a6:	0c 97       	mov	r7,r6
8000c8a8:	10 96       	mov	r6,r8
8000c8aa:	c0 28       	rjmp	8000c8ae <__mdiff+0x42>
8000c8ac:	30 05       	mov	r5,0
8000c8ae:	6e 1b       	ld.w	r11,r7[0x4]
8000c8b0:	c5 6f       	rcall	8000c75c <_Balloc>
8000c8b2:	6e 49       	ld.w	r9,r7[0x10]
8000c8b4:	6c 44       	ld.w	r4,r6[0x10]
8000c8b6:	99 35       	st.w	r12[0xc],r5
8000c8b8:	2f b4       	sub	r4,-5
8000c8ba:	f2 c5 ff fb 	sub	r5,r9,-5
8000c8be:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c8c2:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c8c6:	2e c6       	sub	r6,-20
8000c8c8:	2e c7       	sub	r7,-20
8000c8ca:	f8 c8 ff ec 	sub	r8,r12,-20
8000c8ce:	30 0a       	mov	r10,0
8000c8d0:	0f 0e       	ld.w	lr,r7++
8000c8d2:	0d 0b       	ld.w	r11,r6++
8000c8d4:	fc 02 16 10 	lsr	r2,lr,0x10
8000c8d8:	f6 03 16 10 	lsr	r3,r11,0x10
8000c8dc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c8e0:	e4 03 01 03 	sub	r3,r2,r3
8000c8e4:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c8e8:	fc 0b 01 0b 	sub	r11,lr,r11
8000c8ec:	f6 0a 00 0a 	add	r10,r11,r10
8000c8f0:	b0 1a       	st.h	r8[0x2],r10
8000c8f2:	b1 4a       	asr	r10,0x10
8000c8f4:	e6 0a 00 0a 	add	r10,r3,r10
8000c8f8:	b0 0a       	st.h	r8[0x0],r10
8000c8fa:	2f c8       	sub	r8,-4
8000c8fc:	b1 4a       	asr	r10,0x10
8000c8fe:	08 36       	cp.w	r6,r4
8000c900:	ce 83       	brcs	8000c8d0 <__mdiff+0x64>
8000c902:	c0 d8       	rjmp	8000c91c <__mdiff+0xb0>
8000c904:	0f 0b       	ld.w	r11,r7++
8000c906:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c90a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c90e:	16 0a       	add	r10,r11
8000c910:	b0 1a       	st.h	r8[0x2],r10
8000c912:	b1 4a       	asr	r10,0x10
8000c914:	1c 0a       	add	r10,lr
8000c916:	b0 0a       	st.h	r8[0x0],r10
8000c918:	2f c8       	sub	r8,-4
8000c91a:	b1 4a       	asr	r10,0x10
8000c91c:	0a 37       	cp.w	r7,r5
8000c91e:	cf 33       	brcs	8000c904 <__mdiff+0x98>
8000c920:	c0 28       	rjmp	8000c924 <__mdiff+0xb8>
8000c922:	20 19       	sub	r9,1
8000c924:	11 4a       	ld.w	r10,--r8
8000c926:	58 0a       	cp.w	r10,0
8000c928:	cf d0       	breq	8000c922 <__mdiff+0xb6>
8000c92a:	99 49       	st.w	r12[0x10],r9
8000c92c:	d8 32       	popm	r0-r7,pc
8000c92e:	30 0b       	mov	r11,0
8000c930:	c1 6f       	rcall	8000c75c <_Balloc>
8000c932:	30 18       	mov	r8,1
8000c934:	99 48       	st.w	r12[0x10],r8
8000c936:	30 08       	mov	r8,0
8000c938:	99 58       	st.w	r12[0x14],r8
8000c93a:	d8 32       	popm	r0-r7,pc

8000c93c <__lshift>:
8000c93c:	d4 31       	pushm	r0-r7,lr
8000c93e:	16 97       	mov	r7,r11
8000c940:	76 46       	ld.w	r6,r11[0x10]
8000c942:	f4 02 14 05 	asr	r2,r10,0x5
8000c946:	2f f6       	sub	r6,-1
8000c948:	14 93       	mov	r3,r10
8000c94a:	18 94       	mov	r4,r12
8000c94c:	04 06       	add	r6,r2
8000c94e:	76 1b       	ld.w	r11,r11[0x4]
8000c950:	6e 28       	ld.w	r8,r7[0x8]
8000c952:	c0 38       	rjmp	8000c958 <__lshift+0x1c>
8000c954:	2f fb       	sub	r11,-1
8000c956:	a1 78       	lsl	r8,0x1
8000c958:	10 36       	cp.w	r6,r8
8000c95a:	fe 99 ff fd 	brgt	8000c954 <__lshift+0x18>
8000c95e:	08 9c       	mov	r12,r4
8000c960:	cf ee       	rcall	8000c75c <_Balloc>
8000c962:	30 09       	mov	r9,0
8000c964:	18 95       	mov	r5,r12
8000c966:	f8 c8 ff ec 	sub	r8,r12,-20
8000c96a:	12 9a       	mov	r10,r9
8000c96c:	c0 38       	rjmp	8000c972 <__lshift+0x36>
8000c96e:	10 aa       	st.w	r8++,r10
8000c970:	2f f9       	sub	r9,-1
8000c972:	04 39       	cp.w	r9,r2
8000c974:	cf d5       	brlt	8000c96e <__lshift+0x32>
8000c976:	6e 4b       	ld.w	r11,r7[0x10]
8000c978:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c97c:	2f bb       	sub	r11,-5
8000c97e:	ee c9 ff ec 	sub	r9,r7,-20
8000c982:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c986:	58 03       	cp.w	r3,0
8000c988:	c1 30       	breq	8000c9ae <__lshift+0x72>
8000c98a:	e6 0c 11 20 	rsub	r12,r3,32
8000c98e:	30 0a       	mov	r10,0
8000c990:	72 02       	ld.w	r2,r9[0x0]
8000c992:	e4 03 09 42 	lsl	r2,r2,r3
8000c996:	04 4a       	or	r10,r2
8000c998:	10 aa       	st.w	r8++,r10
8000c99a:	13 0a       	ld.w	r10,r9++
8000c99c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c9a0:	16 39       	cp.w	r9,r11
8000c9a2:	cf 73       	brcs	8000c990 <__lshift+0x54>
8000c9a4:	91 0a       	st.w	r8[0x0],r10
8000c9a6:	58 0a       	cp.w	r10,0
8000c9a8:	c0 70       	breq	8000c9b6 <__lshift+0x7a>
8000c9aa:	2f f6       	sub	r6,-1
8000c9ac:	c0 58       	rjmp	8000c9b6 <__lshift+0x7a>
8000c9ae:	13 0a       	ld.w	r10,r9++
8000c9b0:	10 aa       	st.w	r8++,r10
8000c9b2:	16 39       	cp.w	r9,r11
8000c9b4:	cf d3       	brcs	8000c9ae <__lshift+0x72>
8000c9b6:	08 9c       	mov	r12,r4
8000c9b8:	20 16       	sub	r6,1
8000c9ba:	0e 9b       	mov	r11,r7
8000c9bc:	8b 46       	st.w	r5[0x10],r6
8000c9be:	cb 5e       	rcall	8000c728 <_Bfree>
8000c9c0:	0a 9c       	mov	r12,r5
8000c9c2:	d8 32       	popm	r0-r7,pc

8000c9c4 <__multiply>:
8000c9c4:	d4 31       	pushm	r0-r7,lr
8000c9c6:	20 2d       	sub	sp,8
8000c9c8:	76 49       	ld.w	r9,r11[0x10]
8000c9ca:	74 48       	ld.w	r8,r10[0x10]
8000c9cc:	16 96       	mov	r6,r11
8000c9ce:	14 95       	mov	r5,r10
8000c9d0:	10 39       	cp.w	r9,r8
8000c9d2:	ec 08 17 50 	movlt	r8,r6
8000c9d6:	ea 06 17 50 	movlt	r6,r5
8000c9da:	f0 05 17 50 	movlt	r5,r8
8000c9de:	6c 28       	ld.w	r8,r6[0x8]
8000c9e0:	76 43       	ld.w	r3,r11[0x10]
8000c9e2:	74 42       	ld.w	r2,r10[0x10]
8000c9e4:	76 1b       	ld.w	r11,r11[0x4]
8000c9e6:	e4 03 00 07 	add	r7,r2,r3
8000c9ea:	10 37       	cp.w	r7,r8
8000c9ec:	f7 bb 09 ff 	subgt	r11,-1
8000c9f0:	cb 6e       	rcall	8000c75c <_Balloc>
8000c9f2:	ee c4 ff fb 	sub	r4,r7,-5
8000c9f6:	f8 c9 ff ec 	sub	r9,r12,-20
8000c9fa:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c9fe:	30 0a       	mov	r10,0
8000ca00:	12 98       	mov	r8,r9
8000ca02:	c0 28       	rjmp	8000ca06 <__multiply+0x42>
8000ca04:	10 aa       	st.w	r8++,r10
8000ca06:	08 38       	cp.w	r8,r4
8000ca08:	cf e3       	brcs	8000ca04 <__multiply+0x40>
8000ca0a:	2f b3       	sub	r3,-5
8000ca0c:	2f b2       	sub	r2,-5
8000ca0e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ca12:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ca16:	ec cb ff ec 	sub	r11,r6,-20
8000ca1a:	50 12       	stdsp	sp[0x4],r2
8000ca1c:	ea ca ff ec 	sub	r10,r5,-20
8000ca20:	c4 48       	rjmp	8000caa8 <__multiply+0xe4>
8000ca22:	94 95       	ld.uh	r5,r10[0x2]
8000ca24:	58 05       	cp.w	r5,0
8000ca26:	c2 00       	breq	8000ca66 <__multiply+0xa2>
8000ca28:	12 98       	mov	r8,r9
8000ca2a:	16 96       	mov	r6,r11
8000ca2c:	30 0e       	mov	lr,0
8000ca2e:	50 09       	stdsp	sp[0x0],r9
8000ca30:	0d 02       	ld.w	r2,r6++
8000ca32:	e4 00 16 10 	lsr	r0,r2,0x10
8000ca36:	70 01       	ld.w	r1,r8[0x0]
8000ca38:	70 09       	ld.w	r9,r8[0x0]
8000ca3a:	b1 81       	lsr	r1,0x10
8000ca3c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ca40:	e0 05 03 41 	mac	r1,r0,r5
8000ca44:	ab 32       	mul	r2,r5
8000ca46:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ca4a:	00 02       	add	r2,r0
8000ca4c:	e4 0e 00 0e 	add	lr,r2,lr
8000ca50:	b0 1e       	st.h	r8[0x2],lr
8000ca52:	b1 8e       	lsr	lr,0x10
8000ca54:	1c 01       	add	r1,lr
8000ca56:	b0 01       	st.h	r8[0x0],r1
8000ca58:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ca5c:	2f c8       	sub	r8,-4
8000ca5e:	06 36       	cp.w	r6,r3
8000ca60:	ce 83       	brcs	8000ca30 <__multiply+0x6c>
8000ca62:	40 09       	lddsp	r9,sp[0x0]
8000ca64:	91 0e       	st.w	r8[0x0],lr
8000ca66:	94 86       	ld.uh	r6,r10[0x0]
8000ca68:	58 06       	cp.w	r6,0
8000ca6a:	c1 d0       	breq	8000caa4 <__multiply+0xe0>
8000ca6c:	72 02       	ld.w	r2,r9[0x0]
8000ca6e:	12 98       	mov	r8,r9
8000ca70:	16 9e       	mov	lr,r11
8000ca72:	30 05       	mov	r5,0
8000ca74:	b0 12       	st.h	r8[0x2],r2
8000ca76:	1d 01       	ld.w	r1,lr++
8000ca78:	90 82       	ld.uh	r2,r8[0x0]
8000ca7a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ca7e:	ad 30       	mul	r0,r6
8000ca80:	e0 02 00 02 	add	r2,r0,r2
8000ca84:	e4 05 00 05 	add	r5,r2,r5
8000ca88:	b0 05       	st.h	r8[0x0],r5
8000ca8a:	b1 85       	lsr	r5,0x10
8000ca8c:	b1 81       	lsr	r1,0x10
8000ca8e:	2f c8       	sub	r8,-4
8000ca90:	ad 31       	mul	r1,r6
8000ca92:	90 92       	ld.uh	r2,r8[0x2]
8000ca94:	e2 02 00 02 	add	r2,r1,r2
8000ca98:	0a 02       	add	r2,r5
8000ca9a:	e4 05 16 10 	lsr	r5,r2,0x10
8000ca9e:	06 3e       	cp.w	lr,r3
8000caa0:	ce a3       	brcs	8000ca74 <__multiply+0xb0>
8000caa2:	91 02       	st.w	r8[0x0],r2
8000caa4:	2f ca       	sub	r10,-4
8000caa6:	2f c9       	sub	r9,-4
8000caa8:	40 18       	lddsp	r8,sp[0x4]
8000caaa:	10 3a       	cp.w	r10,r8
8000caac:	cb b3       	brcs	8000ca22 <__multiply+0x5e>
8000caae:	c0 28       	rjmp	8000cab2 <__multiply+0xee>
8000cab0:	20 17       	sub	r7,1
8000cab2:	58 07       	cp.w	r7,0
8000cab4:	e0 8a 00 05 	brle	8000cabe <__multiply+0xfa>
8000cab8:	09 48       	ld.w	r8,--r4
8000caba:	58 08       	cp.w	r8,0
8000cabc:	cf a0       	breq	8000cab0 <__multiply+0xec>
8000cabe:	99 47       	st.w	r12[0x10],r7
8000cac0:	2f ed       	sub	sp,-8
8000cac2:	d8 32       	popm	r0-r7,pc

8000cac4 <__i2b>:
8000cac4:	d4 21       	pushm	r4-r7,lr
8000cac6:	16 97       	mov	r7,r11
8000cac8:	30 1b       	mov	r11,1
8000caca:	c4 9e       	rcall	8000c75c <_Balloc>
8000cacc:	30 19       	mov	r9,1
8000cace:	99 57       	st.w	r12[0x14],r7
8000cad0:	99 49       	st.w	r12[0x10],r9
8000cad2:	d8 22       	popm	r4-r7,pc

8000cad4 <__multadd>:
8000cad4:	d4 31       	pushm	r0-r7,lr
8000cad6:	30 08       	mov	r8,0
8000cad8:	12 95       	mov	r5,r9
8000cada:	16 97       	mov	r7,r11
8000cadc:	18 96       	mov	r6,r12
8000cade:	76 44       	ld.w	r4,r11[0x10]
8000cae0:	f6 c9 ff ec 	sub	r9,r11,-20
8000cae4:	72 0b       	ld.w	r11,r9[0x0]
8000cae6:	f6 0c 16 10 	lsr	r12,r11,0x10
8000caea:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000caee:	f4 0c 02 4c 	mul	r12,r10,r12
8000caf2:	f4 0b 03 45 	mac	r5,r10,r11
8000caf6:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000cafa:	b1 85       	lsr	r5,0x10
8000cafc:	18 05       	add	r5,r12
8000cafe:	ea 0c 15 10 	lsl	r12,r5,0x10
8000cb02:	f8 0b 00 0b 	add	r11,r12,r11
8000cb06:	12 ab       	st.w	r9++,r11
8000cb08:	2f f8       	sub	r8,-1
8000cb0a:	b1 85       	lsr	r5,0x10
8000cb0c:	08 38       	cp.w	r8,r4
8000cb0e:	ce b5       	brlt	8000cae4 <__multadd+0x10>
8000cb10:	58 05       	cp.w	r5,0
8000cb12:	c1 c0       	breq	8000cb4a <__multadd+0x76>
8000cb14:	6e 28       	ld.w	r8,r7[0x8]
8000cb16:	10 34       	cp.w	r4,r8
8000cb18:	c1 35       	brlt	8000cb3e <__multadd+0x6a>
8000cb1a:	6e 1b       	ld.w	r11,r7[0x4]
8000cb1c:	0c 9c       	mov	r12,r6
8000cb1e:	2f fb       	sub	r11,-1
8000cb20:	c1 ee       	rcall	8000c75c <_Balloc>
8000cb22:	6e 4a       	ld.w	r10,r7[0x10]
8000cb24:	ee cb ff f4 	sub	r11,r7,-12
8000cb28:	18 93       	mov	r3,r12
8000cb2a:	2f ea       	sub	r10,-2
8000cb2c:	2f 4c       	sub	r12,-12
8000cb2e:	a3 6a       	lsl	r10,0x2
8000cb30:	fe b0 de 71 	rcall	80008812 <memcpy>
8000cb34:	0e 9b       	mov	r11,r7
8000cb36:	0c 9c       	mov	r12,r6
8000cb38:	fe b0 fd f8 	rcall	8000c728 <_Bfree>
8000cb3c:	06 97       	mov	r7,r3
8000cb3e:	e8 c8 ff ff 	sub	r8,r4,-1
8000cb42:	2f b4       	sub	r4,-5
8000cb44:	8f 48       	st.w	r7[0x10],r8
8000cb46:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000cb4a:	0e 9c       	mov	r12,r7
8000cb4c:	d8 32       	popm	r0-r7,pc
8000cb4e:	d7 03       	nop

8000cb50 <__pow5mult>:
8000cb50:	d4 31       	pushm	r0-r7,lr
8000cb52:	14 96       	mov	r6,r10
8000cb54:	18 97       	mov	r7,r12
8000cb56:	16 94       	mov	r4,r11
8000cb58:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000cb5c:	c0 90       	breq	8000cb6e <__pow5mult+0x1e>
8000cb5e:	20 18       	sub	r8,1
8000cb60:	fe c9 d6 10 	sub	r9,pc,-10736
8000cb64:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000cb68:	30 09       	mov	r9,0
8000cb6a:	cb 5f       	rcall	8000cad4 <__multadd>
8000cb6c:	18 94       	mov	r4,r12
8000cb6e:	a3 46       	asr	r6,0x2
8000cb70:	c3 40       	breq	8000cbd8 <__pow5mult+0x88>
8000cb72:	6e 95       	ld.w	r5,r7[0x24]
8000cb74:	58 05       	cp.w	r5,0
8000cb76:	c0 91       	brne	8000cb88 <__pow5mult+0x38>
8000cb78:	31 0c       	mov	r12,16
8000cb7a:	fe b0 dc 15 	rcall	800083a4 <malloc>
8000cb7e:	99 35       	st.w	r12[0xc],r5
8000cb80:	8f 9c       	st.w	r7[0x24],r12
8000cb82:	99 15       	st.w	r12[0x4],r5
8000cb84:	99 25       	st.w	r12[0x8],r5
8000cb86:	99 05       	st.w	r12[0x0],r5
8000cb88:	6e 93       	ld.w	r3,r7[0x24]
8000cb8a:	66 25       	ld.w	r5,r3[0x8]
8000cb8c:	58 05       	cp.w	r5,0
8000cb8e:	c0 c1       	brne	8000cba6 <__pow5mult+0x56>
8000cb90:	e0 6b 02 71 	mov	r11,625
8000cb94:	0e 9c       	mov	r12,r7
8000cb96:	c9 7f       	rcall	8000cac4 <__i2b>
8000cb98:	87 2c       	st.w	r3[0x8],r12
8000cb9a:	30 08       	mov	r8,0
8000cb9c:	18 95       	mov	r5,r12
8000cb9e:	99 08       	st.w	r12[0x0],r8
8000cba0:	c0 38       	rjmp	8000cba6 <__pow5mult+0x56>
8000cba2:	06 9c       	mov	r12,r3
8000cba4:	18 95       	mov	r5,r12
8000cba6:	ed b6 00 00 	bld	r6,0x0
8000cbaa:	c0 b1       	brne	8000cbc0 <__pow5mult+0x70>
8000cbac:	08 9b       	mov	r11,r4
8000cbae:	0a 9a       	mov	r10,r5
8000cbb0:	0e 9c       	mov	r12,r7
8000cbb2:	c0 9f       	rcall	8000c9c4 <__multiply>
8000cbb4:	08 9b       	mov	r11,r4
8000cbb6:	18 93       	mov	r3,r12
8000cbb8:	0e 9c       	mov	r12,r7
8000cbba:	06 94       	mov	r4,r3
8000cbbc:	fe b0 fd b6 	rcall	8000c728 <_Bfree>
8000cbc0:	a1 56       	asr	r6,0x1
8000cbc2:	c0 b0       	breq	8000cbd8 <__pow5mult+0x88>
8000cbc4:	6a 03       	ld.w	r3,r5[0x0]
8000cbc6:	58 03       	cp.w	r3,0
8000cbc8:	ce d1       	brne	8000cba2 <__pow5mult+0x52>
8000cbca:	0a 9a       	mov	r10,r5
8000cbcc:	0a 9b       	mov	r11,r5
8000cbce:	0e 9c       	mov	r12,r7
8000cbd0:	cf ae       	rcall	8000c9c4 <__multiply>
8000cbd2:	8b 0c       	st.w	r5[0x0],r12
8000cbd4:	99 03       	st.w	r12[0x0],r3
8000cbd6:	ce 7b       	rjmp	8000cba4 <__pow5mult+0x54>
8000cbd8:	08 9c       	mov	r12,r4
8000cbda:	d8 32       	popm	r0-r7,pc

8000cbdc <__isinfd>:
8000cbdc:	14 98       	mov	r8,r10
8000cbde:	fc 19 7f f0 	movh	r9,0x7ff0
8000cbe2:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cbe6:	f0 0b 11 00 	rsub	r11,r8,0
8000cbea:	f7 e8 10 08 	or	r8,r11,r8
8000cbee:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000cbf2:	f2 08 01 08 	sub	r8,r9,r8
8000cbf6:	f0 0c 11 00 	rsub	r12,r8,0
8000cbfa:	f9 e8 10 08 	or	r8,r12,r8
8000cbfe:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000cc02:	2f fc       	sub	r12,-1
8000cc04:	5e fc       	retal	r12

8000cc06 <__isnand>:
8000cc06:	14 98       	mov	r8,r10
8000cc08:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cc0c:	f0 0c 11 00 	rsub	r12,r8,0
8000cc10:	10 4c       	or	r12,r8
8000cc12:	fc 18 7f f0 	movh	r8,0x7ff0
8000cc16:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000cc1a:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc1e:	bf 9c       	lsr	r12,0x1f
8000cc20:	5e fc       	retal	r12
8000cc22:	d7 03       	nop

8000cc24 <__sclose>:
8000cc24:	d4 01       	pushm	lr
8000cc26:	96 7b       	ld.sh	r11,r11[0xe]
8000cc28:	c8 2c       	rcall	8000cd2c <_close_r>
8000cc2a:	d8 02       	popm	pc

8000cc2c <__sseek>:
8000cc2c:	d4 21       	pushm	r4-r7,lr
8000cc2e:	16 97       	mov	r7,r11
8000cc30:	96 7b       	ld.sh	r11,r11[0xe]
8000cc32:	c0 3d       	rcall	8000ce38 <_lseek_r>
8000cc34:	8e 68       	ld.sh	r8,r7[0xc]
8000cc36:	10 99       	mov	r9,r8
8000cc38:	ad c8       	cbr	r8,0xc
8000cc3a:	ad a9       	sbr	r9,0xc
8000cc3c:	5b fc       	cp.w	r12,-1
8000cc3e:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cc42:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cc46:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cc4a:	d8 22       	popm	r4-r7,pc

8000cc4c <__swrite>:
8000cc4c:	d4 21       	pushm	r4-r7,lr
8000cc4e:	96 68       	ld.sh	r8,r11[0xc]
8000cc50:	16 97       	mov	r7,r11
8000cc52:	14 95       	mov	r5,r10
8000cc54:	12 94       	mov	r4,r9
8000cc56:	e2 18 01 00 	andl	r8,0x100,COH
8000cc5a:	18 96       	mov	r6,r12
8000cc5c:	c0 50       	breq	8000cc66 <__swrite+0x1a>
8000cc5e:	30 29       	mov	r9,2
8000cc60:	30 0a       	mov	r10,0
8000cc62:	96 7b       	ld.sh	r11,r11[0xe]
8000cc64:	ce ac       	rcall	8000ce38 <_lseek_r>
8000cc66:	8e 68       	ld.sh	r8,r7[0xc]
8000cc68:	ad c8       	cbr	r8,0xc
8000cc6a:	08 99       	mov	r9,r4
8000cc6c:	0a 9a       	mov	r10,r5
8000cc6e:	8e 7b       	ld.sh	r11,r7[0xe]
8000cc70:	0c 9c       	mov	r12,r6
8000cc72:	ae 68       	st.h	r7[0xc],r8
8000cc74:	c1 cc       	rcall	8000ccac <_write_r>
8000cc76:	d8 22       	popm	r4-r7,pc

8000cc78 <__sread>:
8000cc78:	d4 21       	pushm	r4-r7,lr
8000cc7a:	16 97       	mov	r7,r11
8000cc7c:	96 7b       	ld.sh	r11,r11[0xe]
8000cc7e:	cf 1c       	rcall	8000ce60 <_read_r>
8000cc80:	c0 65       	brlt	8000cc8c <__sread+0x14>
8000cc82:	6f 58       	ld.w	r8,r7[0x54]
8000cc84:	18 08       	add	r8,r12
8000cc86:	ef 48 00 54 	st.w	r7[84],r8
8000cc8a:	d8 22       	popm	r4-r7,pc
8000cc8c:	8e 68       	ld.sh	r8,r7[0xc]
8000cc8e:	ad c8       	cbr	r8,0xc
8000cc90:	ae 68       	st.h	r7[0xc],r8
8000cc92:	d8 22       	popm	r4-r7,pc

8000cc94 <strlen>:
8000cc94:	30 09       	mov	r9,0
8000cc96:	18 98       	mov	r8,r12
8000cc98:	c0 28       	rjmp	8000cc9c <strlen+0x8>
8000cc9a:	2f f8       	sub	r8,-1
8000cc9c:	11 8a       	ld.ub	r10,r8[0x0]
8000cc9e:	f2 0a 18 00 	cp.b	r10,r9
8000cca2:	cf c1       	brne	8000cc9a <strlen+0x6>
8000cca4:	f0 0c 01 0c 	sub	r12,r8,r12
8000cca8:	5e fc       	retal	r12
8000ccaa:	d7 03       	nop

8000ccac <_write_r>:
8000ccac:	d4 21       	pushm	r4-r7,lr
8000ccae:	16 98       	mov	r8,r11
8000ccb0:	18 97       	mov	r7,r12
8000ccb2:	10 9c       	mov	r12,r8
8000ccb4:	30 08       	mov	r8,0
8000ccb6:	14 9b       	mov	r11,r10
8000ccb8:	e0 66 a6 c8 	mov	r6,42696
8000ccbc:	12 9a       	mov	r10,r9
8000ccbe:	8d 08       	st.w	r6[0x0],r8
8000ccc0:	fe b0 d1 5c 	rcall	80006f78 <_write>
8000ccc4:	5b fc       	cp.w	r12,-1
8000ccc6:	c0 51       	brne	8000ccd0 <_write_r+0x24>
8000ccc8:	6c 08       	ld.w	r8,r6[0x0]
8000ccca:	58 08       	cp.w	r8,0
8000cccc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ccd0:	d8 22       	popm	r4-r7,pc
8000ccd2:	d7 03       	nop

8000ccd4 <_calloc_r>:
8000ccd4:	d4 21       	pushm	r4-r7,lr
8000ccd6:	f4 0b 02 4b 	mul	r11,r10,r11
8000ccda:	fe b0 db 6d 	rcall	800083b4 <_malloc_r>
8000ccde:	18 97       	mov	r7,r12
8000cce0:	c2 30       	breq	8000cd26 <_calloc_r+0x52>
8000cce2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cce6:	e0 1a ff fc 	andl	r10,0xfffc
8000ccea:	20 4a       	sub	r10,4
8000ccec:	e0 4a 00 24 	cp.w	r10,36
8000ccf0:	e0 8b 00 18 	brhi	8000cd20 <_calloc_r+0x4c>
8000ccf4:	18 98       	mov	r8,r12
8000ccf6:	59 3a       	cp.w	r10,19
8000ccf8:	e0 88 00 0f 	brls	8000cd16 <_calloc_r+0x42>
8000ccfc:	30 09       	mov	r9,0
8000ccfe:	10 a9       	st.w	r8++,r9
8000cd00:	10 a9       	st.w	r8++,r9
8000cd02:	59 ba       	cp.w	r10,27
8000cd04:	e0 88 00 09 	brls	8000cd16 <_calloc_r+0x42>
8000cd08:	10 a9       	st.w	r8++,r9
8000cd0a:	10 a9       	st.w	r8++,r9
8000cd0c:	e0 4a 00 24 	cp.w	r10,36
8000cd10:	c0 31       	brne	8000cd16 <_calloc_r+0x42>
8000cd12:	10 a9       	st.w	r8++,r9
8000cd14:	10 a9       	st.w	r8++,r9
8000cd16:	30 09       	mov	r9,0
8000cd18:	10 a9       	st.w	r8++,r9
8000cd1a:	91 19       	st.w	r8[0x4],r9
8000cd1c:	91 09       	st.w	r8[0x0],r9
8000cd1e:	c0 48       	rjmp	8000cd26 <_calloc_r+0x52>
8000cd20:	30 0b       	mov	r11,0
8000cd22:	fe b0 de 1c 	rcall	8000895a <memset>
8000cd26:	0e 9c       	mov	r12,r7
8000cd28:	d8 22       	popm	r4-r7,pc
8000cd2a:	d7 03       	nop

8000cd2c <_close_r>:
8000cd2c:	d4 21       	pushm	r4-r7,lr
8000cd2e:	30 08       	mov	r8,0
8000cd30:	18 97       	mov	r7,r12
8000cd32:	e0 66 a6 c8 	mov	r6,42696
8000cd36:	16 9c       	mov	r12,r11
8000cd38:	8d 08       	st.w	r6[0x0],r8
8000cd3a:	fe b0 df b5 	rcall	80008ca4 <_close>
8000cd3e:	5b fc       	cp.w	r12,-1
8000cd40:	c0 51       	brne	8000cd4a <_close_r+0x1e>
8000cd42:	6c 08       	ld.w	r8,r6[0x0]
8000cd44:	58 08       	cp.w	r8,0
8000cd46:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cd4a:	d8 22       	popm	r4-r7,pc

8000cd4c <_fclose_r>:
8000cd4c:	d4 21       	pushm	r4-r7,lr
8000cd4e:	18 96       	mov	r6,r12
8000cd50:	16 97       	mov	r7,r11
8000cd52:	58 0b       	cp.w	r11,0
8000cd54:	c0 31       	brne	8000cd5a <_fclose_r+0xe>
8000cd56:	16 95       	mov	r5,r11
8000cd58:	c5 38       	rjmp	8000cdfe <_fclose_r+0xb2>
8000cd5a:	fe b0 f8 a9 	rcall	8000beac <__sfp_lock_acquire>
8000cd5e:	58 06       	cp.w	r6,0
8000cd60:	c0 70       	breq	8000cd6e <_fclose_r+0x22>
8000cd62:	6c 68       	ld.w	r8,r6[0x18]
8000cd64:	58 08       	cp.w	r8,0
8000cd66:	c0 41       	brne	8000cd6e <_fclose_r+0x22>
8000cd68:	0c 9c       	mov	r12,r6
8000cd6a:	fe b0 f8 f3 	rcall	8000bf50 <__sinit>
8000cd6e:	fe c8 d8 c2 	sub	r8,pc,-10046
8000cd72:	10 37       	cp.w	r7,r8
8000cd74:	c0 31       	brne	8000cd7a <_fclose_r+0x2e>
8000cd76:	6c 07       	ld.w	r7,r6[0x0]
8000cd78:	c0 c8       	rjmp	8000cd90 <_fclose_r+0x44>
8000cd7a:	fe c8 d8 ae 	sub	r8,pc,-10066
8000cd7e:	10 37       	cp.w	r7,r8
8000cd80:	c0 31       	brne	8000cd86 <_fclose_r+0x3a>
8000cd82:	6c 17       	ld.w	r7,r6[0x4]
8000cd84:	c0 68       	rjmp	8000cd90 <_fclose_r+0x44>
8000cd86:	fe c8 d8 9a 	sub	r8,pc,-10086
8000cd8a:	10 37       	cp.w	r7,r8
8000cd8c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cd90:	8e 69       	ld.sh	r9,r7[0xc]
8000cd92:	30 08       	mov	r8,0
8000cd94:	f0 09 19 00 	cp.h	r9,r8
8000cd98:	c0 51       	brne	8000cda2 <_fclose_r+0x56>
8000cd9a:	fe b0 f8 8a 	rcall	8000beae <__sfp_lock_release>
8000cd9e:	30 05       	mov	r5,0
8000cda0:	c2 f8       	rjmp	8000cdfe <_fclose_r+0xb2>
8000cda2:	0e 9b       	mov	r11,r7
8000cda4:	0c 9c       	mov	r12,r6
8000cda6:	fe b0 f7 fd 	rcall	8000bda0 <_fflush_r>
8000cdaa:	6e c8       	ld.w	r8,r7[0x30]
8000cdac:	18 95       	mov	r5,r12
8000cdae:	58 08       	cp.w	r8,0
8000cdb0:	c0 60       	breq	8000cdbc <_fclose_r+0x70>
8000cdb2:	6e 8b       	ld.w	r11,r7[0x20]
8000cdb4:	0c 9c       	mov	r12,r6
8000cdb6:	5d 18       	icall	r8
8000cdb8:	f9 b5 05 ff 	movlt	r5,-1
8000cdbc:	8e 68       	ld.sh	r8,r7[0xc]
8000cdbe:	ed b8 00 07 	bld	r8,0x7
8000cdc2:	c0 51       	brne	8000cdcc <_fclose_r+0x80>
8000cdc4:	6e 4b       	ld.w	r11,r7[0x10]
8000cdc6:	0c 9c       	mov	r12,r6
8000cdc8:	fe b0 f9 5e 	rcall	8000c084 <_free_r>
8000cdcc:	6e db       	ld.w	r11,r7[0x34]
8000cdce:	58 0b       	cp.w	r11,0
8000cdd0:	c0 a0       	breq	8000cde4 <_fclose_r+0x98>
8000cdd2:	ee c8 ff bc 	sub	r8,r7,-68
8000cdd6:	10 3b       	cp.w	r11,r8
8000cdd8:	c0 40       	breq	8000cde0 <_fclose_r+0x94>
8000cdda:	0c 9c       	mov	r12,r6
8000cddc:	fe b0 f9 54 	rcall	8000c084 <_free_r>
8000cde0:	30 08       	mov	r8,0
8000cde2:	8f d8       	st.w	r7[0x34],r8
8000cde4:	6f 2b       	ld.w	r11,r7[0x48]
8000cde6:	58 0b       	cp.w	r11,0
8000cde8:	c0 70       	breq	8000cdf6 <_fclose_r+0xaa>
8000cdea:	0c 9c       	mov	r12,r6
8000cdec:	fe b0 f9 4c 	rcall	8000c084 <_free_r>
8000cdf0:	30 08       	mov	r8,0
8000cdf2:	ef 48 00 48 	st.w	r7[72],r8
8000cdf6:	30 08       	mov	r8,0
8000cdf8:	ae 68       	st.h	r7[0xc],r8
8000cdfa:	fe b0 f8 5a 	rcall	8000beae <__sfp_lock_release>
8000cdfe:	0a 9c       	mov	r12,r5
8000ce00:	d8 22       	popm	r4-r7,pc
8000ce02:	d7 03       	nop

8000ce04 <fclose>:
8000ce04:	d4 01       	pushm	lr
8000ce06:	e0 68 0a 54 	mov	r8,2644
8000ce0a:	18 9b       	mov	r11,r12
8000ce0c:	70 0c       	ld.w	r12,r8[0x0]
8000ce0e:	c9 ff       	rcall	8000cd4c <_fclose_r>
8000ce10:	d8 02       	popm	pc
8000ce12:	d7 03       	nop

8000ce14 <_fstat_r>:
8000ce14:	d4 21       	pushm	r4-r7,lr
8000ce16:	16 98       	mov	r8,r11
8000ce18:	18 97       	mov	r7,r12
8000ce1a:	10 9c       	mov	r12,r8
8000ce1c:	30 08       	mov	r8,0
8000ce1e:	e0 66 a6 c8 	mov	r6,42696
8000ce22:	14 9b       	mov	r11,r10
8000ce24:	8d 08       	st.w	r6[0x0],r8
8000ce26:	fe b0 df 67 	rcall	80008cf4 <_fstat>
8000ce2a:	5b fc       	cp.w	r12,-1
8000ce2c:	c0 51       	brne	8000ce36 <_fstat_r+0x22>
8000ce2e:	6c 08       	ld.w	r8,r6[0x0]
8000ce30:	58 08       	cp.w	r8,0
8000ce32:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce36:	d8 22       	popm	r4-r7,pc

8000ce38 <_lseek_r>:
8000ce38:	d4 21       	pushm	r4-r7,lr
8000ce3a:	16 98       	mov	r8,r11
8000ce3c:	18 97       	mov	r7,r12
8000ce3e:	10 9c       	mov	r12,r8
8000ce40:	30 08       	mov	r8,0
8000ce42:	14 9b       	mov	r11,r10
8000ce44:	e0 66 a6 c8 	mov	r6,42696
8000ce48:	12 9a       	mov	r10,r9
8000ce4a:	8d 08       	st.w	r6[0x0],r8
8000ce4c:	fe b0 df 36 	rcall	80008cb8 <_lseek>
8000ce50:	5b fc       	cp.w	r12,-1
8000ce52:	c0 51       	brne	8000ce5c <_lseek_r+0x24>
8000ce54:	6c 08       	ld.w	r8,r6[0x0]
8000ce56:	58 08       	cp.w	r8,0
8000ce58:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce5c:	d8 22       	popm	r4-r7,pc
8000ce5e:	d7 03       	nop

8000ce60 <_read_r>:
8000ce60:	d4 21       	pushm	r4-r7,lr
8000ce62:	16 98       	mov	r8,r11
8000ce64:	18 97       	mov	r7,r12
8000ce66:	10 9c       	mov	r12,r8
8000ce68:	30 08       	mov	r8,0
8000ce6a:	14 9b       	mov	r11,r10
8000ce6c:	e0 66 a6 c8 	mov	r6,42696
8000ce70:	12 9a       	mov	r10,r9
8000ce72:	8d 08       	st.w	r6[0x0],r8
8000ce74:	fe b0 d0 62 	rcall	80006f38 <_read>
8000ce78:	5b fc       	cp.w	r12,-1
8000ce7a:	c0 51       	brne	8000ce84 <_read_r+0x24>
8000ce7c:	6c 08       	ld.w	r8,r6[0x0]
8000ce7e:	58 08       	cp.w	r8,0
8000ce80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce84:	d8 22       	popm	r4-r7,pc
8000ce86:	d7 03       	nop

8000ce88 <__avr32_f64_mul>:
8000ce88:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ce8c:	e0 80 00 dc 	breq	8000d044 <__avr32_f64_mul_op1_zero>
8000ce90:	d4 21       	pushm	r4-r7,lr
8000ce92:	f7 e9 20 0e 	eor	lr,r11,r9
8000ce96:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ce9a:	30 15       	mov	r5,1
8000ce9c:	c4 30       	breq	8000cf22 <__avr32_f64_mul_op1_subnormal>
8000ce9e:	ab 6b       	lsl	r11,0xa
8000cea0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000cea4:	ab 6a       	lsl	r10,0xa
8000cea6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ceaa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ceae:	c5 c0       	breq	8000cf66 <__avr32_f64_mul_op2_subnormal>
8000ceb0:	a1 78       	lsl	r8,0x1
8000ceb2:	5c f9       	rol	r9
8000ceb4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ceb8:	e0 47 07 ff 	cp.w	r7,2047
8000cebc:	c7 70       	breq	8000cfaa <__avr32_f64_mul_op_nan_or_inf>
8000cebe:	e0 46 07 ff 	cp.w	r6,2047
8000cec2:	c7 40       	breq	8000cfaa <__avr32_f64_mul_op_nan_or_inf>
8000cec4:	ee 06 00 0c 	add	r12,r7,r6
8000cec8:	e0 2c 03 fe 	sub	r12,1022
8000cecc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ced0:	f4 09 07 44 	macu.d	r4,r10,r9
8000ced4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ced8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000cedc:	08 07       	add	r7,r4
8000cede:	f4 05 00 4a 	adc	r10,r10,r5
8000cee2:	5c 0b       	acr	r11
8000cee4:	ed bb 00 14 	bld	r11,0x14
8000cee8:	c0 50       	breq	8000cef2 <__avr32_f64_mul+0x6a>
8000ceea:	a1 77       	lsl	r7,0x1
8000ceec:	5c fa       	rol	r10
8000ceee:	5c fb       	rol	r11
8000cef0:	20 1c       	sub	r12,1
8000cef2:	58 0c       	cp.w	r12,0
8000cef4:	e0 8a 00 6f 	brle	8000cfd2 <__avr32_f64_mul_res_subnormal>
8000cef8:	e0 4c 07 ff 	cp.w	r12,2047
8000cefc:	e0 84 00 9c 	brge	8000d034 <__avr32_f64_mul_res_inf>
8000cf00:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cf04:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cf08:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cf0c:	ee 17 80 00 	eorh	r7,0x8000
8000cf10:	f1 b7 04 20 	satu	r7,0x1
8000cf14:	0e 0a       	add	r10,r7
8000cf16:	5c 0b       	acr	r11
8000cf18:	ed be 00 1f 	bld	lr,0x1f
8000cf1c:	ef bb 00 1f 	bst	r11,0x1f
8000cf20:	d8 22       	popm	r4-r7,pc

8000cf22 <__avr32_f64_mul_op1_subnormal>:
8000cf22:	e4 1b 00 0f 	andh	r11,0xf
8000cf26:	f4 0c 12 00 	clz	r12,r10
8000cf2a:	f6 06 12 00 	clz	r6,r11
8000cf2e:	f7 bc 03 e1 	sublo	r12,-31
8000cf32:	f8 06 17 30 	movlo	r6,r12
8000cf36:	f7 b6 02 01 	subhs	r6,1
8000cf3a:	e0 46 00 20 	cp.w	r6,32
8000cf3e:	c0 d4       	brge	8000cf58 <__avr32_f64_mul_op1_subnormal+0x36>
8000cf40:	ec 0c 11 20 	rsub	r12,r6,32
8000cf44:	f6 06 09 4b 	lsl	r11,r11,r6
8000cf48:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cf4c:	18 4b       	or	r11,r12
8000cf4e:	f4 06 09 4a 	lsl	r10,r10,r6
8000cf52:	20 b6       	sub	r6,11
8000cf54:	0c 17       	sub	r7,r6
8000cf56:	ca ab       	rjmp	8000ceaa <__avr32_f64_mul+0x22>
8000cf58:	f4 06 09 4b 	lsl	r11,r10,r6
8000cf5c:	c6 40       	breq	8000d024 <__avr32_f64_mul_res_zero>
8000cf5e:	30 0a       	mov	r10,0
8000cf60:	20 b6       	sub	r6,11
8000cf62:	0c 17       	sub	r7,r6
8000cf64:	ca 3b       	rjmp	8000ceaa <__avr32_f64_mul+0x22>

8000cf66 <__avr32_f64_mul_op2_subnormal>:
8000cf66:	e4 19 00 0f 	andh	r9,0xf
8000cf6a:	f0 0c 12 00 	clz	r12,r8
8000cf6e:	f2 05 12 00 	clz	r5,r9
8000cf72:	f7 bc 03 ea 	sublo	r12,-22
8000cf76:	f8 05 17 30 	movlo	r5,r12
8000cf7a:	f7 b5 02 0a 	subhs	r5,10
8000cf7e:	e0 45 00 20 	cp.w	r5,32
8000cf82:	c0 d4       	brge	8000cf9c <__avr32_f64_mul_op2_subnormal+0x36>
8000cf84:	ea 0c 11 20 	rsub	r12,r5,32
8000cf88:	f2 05 09 49 	lsl	r9,r9,r5
8000cf8c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cf90:	18 49       	or	r9,r12
8000cf92:	f0 05 09 48 	lsl	r8,r8,r5
8000cf96:	20 25       	sub	r5,2
8000cf98:	0a 16       	sub	r6,r5
8000cf9a:	c8 fb       	rjmp	8000ceb8 <__avr32_f64_mul+0x30>
8000cf9c:	f0 05 09 49 	lsl	r9,r8,r5
8000cfa0:	c4 20       	breq	8000d024 <__avr32_f64_mul_res_zero>
8000cfa2:	30 08       	mov	r8,0
8000cfa4:	20 25       	sub	r5,2
8000cfa6:	0a 16       	sub	r6,r5
8000cfa8:	c8 8b       	rjmp	8000ceb8 <__avr32_f64_mul+0x30>

8000cfaa <__avr32_f64_mul_op_nan_or_inf>:
8000cfaa:	e4 19 00 0f 	andh	r9,0xf
8000cfae:	e4 1b 00 0f 	andh	r11,0xf
8000cfb2:	14 4b       	or	r11,r10
8000cfb4:	10 49       	or	r9,r8
8000cfb6:	e0 47 07 ff 	cp.w	r7,2047
8000cfba:	c0 91       	brne	8000cfcc <__avr32_f64_mul_op1_not_naninf>
8000cfbc:	58 0b       	cp.w	r11,0
8000cfbe:	c3 81       	brne	8000d02e <__avr32_f64_mul_res_nan>
8000cfc0:	e0 46 07 ff 	cp.w	r6,2047
8000cfc4:	c3 81       	brne	8000d034 <__avr32_f64_mul_res_inf>
8000cfc6:	58 09       	cp.w	r9,0
8000cfc8:	c3 60       	breq	8000d034 <__avr32_f64_mul_res_inf>
8000cfca:	c3 28       	rjmp	8000d02e <__avr32_f64_mul_res_nan>

8000cfcc <__avr32_f64_mul_op1_not_naninf>:
8000cfcc:	58 09       	cp.w	r9,0
8000cfce:	c3 30       	breq	8000d034 <__avr32_f64_mul_res_inf>
8000cfd0:	c2 f8       	rjmp	8000d02e <__avr32_f64_mul_res_nan>

8000cfd2 <__avr32_f64_mul_res_subnormal>:
8000cfd2:	5c 3c       	neg	r12
8000cfd4:	2f fc       	sub	r12,-1
8000cfd6:	f1 bc 04 c0 	satu	r12,0x6
8000cfda:	e0 4c 00 20 	cp.w	r12,32
8000cfde:	c1 14       	brge	8000d000 <__avr32_f64_mul_res_subnormal+0x2e>
8000cfe0:	f8 08 11 20 	rsub	r8,r12,32
8000cfe4:	0e 46       	or	r6,r7
8000cfe6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000cfea:	f4 08 09 49 	lsl	r9,r10,r8
8000cfee:	12 47       	or	r7,r9
8000cff0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000cff4:	f6 08 09 49 	lsl	r9,r11,r8
8000cff8:	12 4a       	or	r10,r9
8000cffa:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cffe:	c8 3b       	rjmp	8000cf04 <__avr32_f64_mul+0x7c>
8000d000:	f8 08 11 20 	rsub	r8,r12,32
8000d004:	f9 b9 00 00 	moveq	r9,0
8000d008:	c0 30       	breq	8000d00e <__avr32_f64_mul_res_subnormal+0x3c>
8000d00a:	f6 08 09 49 	lsl	r9,r11,r8
8000d00e:	0e 46       	or	r6,r7
8000d010:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000d014:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d018:	f3 ea 10 07 	or	r7,r9,r10
8000d01c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000d020:	30 0b       	mov	r11,0
8000d022:	c7 1b       	rjmp	8000cf04 <__avr32_f64_mul+0x7c>

8000d024 <__avr32_f64_mul_res_zero>:
8000d024:	1c 9b       	mov	r11,lr
8000d026:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d02a:	30 0a       	mov	r10,0
8000d02c:	d8 22       	popm	r4-r7,pc

8000d02e <__avr32_f64_mul_res_nan>:
8000d02e:	3f fb       	mov	r11,-1
8000d030:	3f fa       	mov	r10,-1
8000d032:	d8 22       	popm	r4-r7,pc

8000d034 <__avr32_f64_mul_res_inf>:
8000d034:	f0 6b 00 00 	mov	r11,-1048576
8000d038:	ed be 00 1f 	bld	lr,0x1f
8000d03c:	ef bb 00 1f 	bst	r11,0x1f
8000d040:	30 0a       	mov	r10,0
8000d042:	d8 22       	popm	r4-r7,pc

8000d044 <__avr32_f64_mul_op1_zero>:
8000d044:	f7 e9 20 0b 	eor	r11,r11,r9
8000d048:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d04c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000d050:	e0 4c 07 ff 	cp.w	r12,2047
8000d054:	5e 1c       	retne	r12
8000d056:	3f fa       	mov	r10,-1
8000d058:	3f fb       	mov	r11,-1
8000d05a:	5e fc       	retal	r12

8000d05c <__avr32_f64_sub_from_add>:
8000d05c:	ee 19 80 00 	eorh	r9,0x8000

8000d060 <__avr32_f64_sub>:
8000d060:	f7 e9 20 0c 	eor	r12,r11,r9
8000d064:	e0 86 00 ca 	brmi	8000d1f8 <__avr32_f64_add_from_sub>
8000d068:	eb cd 40 e0 	pushm	r5-r7,lr
8000d06c:	16 9c       	mov	r12,r11
8000d06e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d072:	bf db       	cbr	r11,0x1f
8000d074:	bf d9       	cbr	r9,0x1f
8000d076:	10 3a       	cp.w	r10,r8
8000d078:	f2 0b 13 00 	cpc	r11,r9
8000d07c:	c0 92       	brcc	8000d08e <__avr32_f64_sub+0x2e>
8000d07e:	16 97       	mov	r7,r11
8000d080:	12 9b       	mov	r11,r9
8000d082:	0e 99       	mov	r9,r7
8000d084:	14 97       	mov	r7,r10
8000d086:	10 9a       	mov	r10,r8
8000d088:	0e 98       	mov	r8,r7
8000d08a:	ee 1c 80 00 	eorh	r12,0x8000
8000d08e:	f6 07 16 14 	lsr	r7,r11,0x14
8000d092:	ab 7b       	lsl	r11,0xb
8000d094:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d098:	ab 7a       	lsl	r10,0xb
8000d09a:	bf bb       	sbr	r11,0x1f
8000d09c:	f2 06 16 14 	lsr	r6,r9,0x14
8000d0a0:	c4 40       	breq	8000d128 <__avr32_f64_sub_opL_subnormal>
8000d0a2:	ab 79       	lsl	r9,0xb
8000d0a4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d0a8:	ab 78       	lsl	r8,0xb
8000d0aa:	bf b9       	sbr	r9,0x1f

8000d0ac <__avr32_f64_sub_opL_subnormal_done>:
8000d0ac:	e0 47 07 ff 	cp.w	r7,2047
8000d0b0:	c4 f0       	breq	8000d14e <__avr32_f64_sub_opH_nan_or_inf>
8000d0b2:	0e 26       	rsub	r6,r7
8000d0b4:	c1 20       	breq	8000d0d8 <__avr32_f64_sub_shift_done>
8000d0b6:	ec 05 11 20 	rsub	r5,r6,32
8000d0ba:	e0 46 00 20 	cp.w	r6,32
8000d0be:	c7 c2       	brcc	8000d1b6 <__avr32_f64_sub_longshift>
8000d0c0:	f0 05 09 4e 	lsl	lr,r8,r5
8000d0c4:	f2 05 09 45 	lsl	r5,r9,r5
8000d0c8:	f0 06 0a 48 	lsr	r8,r8,r6
8000d0cc:	f2 06 0a 49 	lsr	r9,r9,r6
8000d0d0:	0a 48       	or	r8,r5
8000d0d2:	58 0e       	cp.w	lr,0
8000d0d4:	5f 1e       	srne	lr
8000d0d6:	1c 48       	or	r8,lr

8000d0d8 <__avr32_f64_sub_shift_done>:
8000d0d8:	10 1a       	sub	r10,r8
8000d0da:	f6 09 01 4b 	sbc	r11,r11,r9
8000d0de:	f6 06 12 00 	clz	r6,r11
8000d0e2:	c0 e0       	breq	8000d0fe <__avr32_f64_sub_longnormalize_done>
8000d0e4:	c7 83       	brcs	8000d1d4 <__avr32_f64_sub_longnormalize>
8000d0e6:	ec 0e 11 20 	rsub	lr,r6,32
8000d0ea:	f6 06 09 4b 	lsl	r11,r11,r6
8000d0ee:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d0f2:	1c 4b       	or	r11,lr
8000d0f4:	f4 06 09 4a 	lsl	r10,r10,r6
8000d0f8:	0c 17       	sub	r7,r6
8000d0fa:	e0 8a 00 39 	brle	8000d16c <__avr32_f64_sub_subnormal_result>

8000d0fe <__avr32_f64_sub_longnormalize_done>:
8000d0fe:	f4 09 15 15 	lsl	r9,r10,0x15
8000d102:	ab 9a       	lsr	r10,0xb
8000d104:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d108:	ab 9b       	lsr	r11,0xb
8000d10a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d10e:	18 4b       	or	r11,r12

8000d110 <__avr32_f64_sub_round>:
8000d110:	fc 17 80 00 	movh	r7,0x8000
8000d114:	ed ba 00 00 	bld	r10,0x0
8000d118:	f7 b7 01 ff 	subne	r7,-1
8000d11c:	0e 39       	cp.w	r9,r7
8000d11e:	5f 29       	srhs	r9
8000d120:	12 0a       	add	r10,r9
8000d122:	5c 0b       	acr	r11
8000d124:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d128 <__avr32_f64_sub_opL_subnormal>:
8000d128:	ab 79       	lsl	r9,0xb
8000d12a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d12e:	ab 78       	lsl	r8,0xb
8000d130:	f3 e8 10 0e 	or	lr,r9,r8
8000d134:	f9 b6 01 01 	movne	r6,1
8000d138:	ee 0e 11 00 	rsub	lr,r7,0
8000d13c:	f9 b7 00 01 	moveq	r7,1
8000d140:	ef bb 00 1f 	bst	r11,0x1f
8000d144:	f7 ea 10 0e 	or	lr,r11,r10
8000d148:	f9 b7 00 00 	moveq	r7,0
8000d14c:	cb 0b       	rjmp	8000d0ac <__avr32_f64_sub_opL_subnormal_done>

8000d14e <__avr32_f64_sub_opH_nan_or_inf>:
8000d14e:	bf db       	cbr	r11,0x1f
8000d150:	f7 ea 10 0e 	or	lr,r11,r10
8000d154:	c0 81       	brne	8000d164 <__avr32_f64_sub_return_nan>
8000d156:	e0 46 07 ff 	cp.w	r6,2047
8000d15a:	c0 50       	breq	8000d164 <__avr32_f64_sub_return_nan>
8000d15c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000d160:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d164 <__avr32_f64_sub_return_nan>:
8000d164:	3f fa       	mov	r10,-1
8000d166:	3f fb       	mov	r11,-1
8000d168:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d16c <__avr32_f64_sub_subnormal_result>:
8000d16c:	5c 37       	neg	r7
8000d16e:	2f f7       	sub	r7,-1
8000d170:	f1 b7 04 c0 	satu	r7,0x6
8000d174:	e0 47 00 20 	cp.w	r7,32
8000d178:	c1 14       	brge	8000d19a <__avr32_f64_sub_subnormal_result+0x2e>
8000d17a:	ee 08 11 20 	rsub	r8,r7,32
8000d17e:	f4 08 09 49 	lsl	r9,r10,r8
8000d182:	5f 16       	srne	r6
8000d184:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d188:	0c 4a       	or	r10,r6
8000d18a:	f6 08 09 49 	lsl	r9,r11,r8
8000d18e:	f5 e9 10 0a 	or	r10,r10,r9
8000d192:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d196:	30 07       	mov	r7,0
8000d198:	cb 3b       	rjmp	8000d0fe <__avr32_f64_sub_longnormalize_done>
8000d19a:	ee 08 11 40 	rsub	r8,r7,64
8000d19e:	f6 08 09 49 	lsl	r9,r11,r8
8000d1a2:	14 49       	or	r9,r10
8000d1a4:	5f 16       	srne	r6
8000d1a6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d1aa:	0c 4a       	or	r10,r6
8000d1ac:	30 0b       	mov	r11,0
8000d1ae:	30 07       	mov	r7,0
8000d1b0:	ca 7b       	rjmp	8000d0fe <__avr32_f64_sub_longnormalize_done>
8000d1b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d1b6 <__avr32_f64_sub_longshift>:
8000d1b6:	f1 b6 04 c0 	satu	r6,0x6
8000d1ba:	f0 0e 17 00 	moveq	lr,r8
8000d1be:	c0 40       	breq	8000d1c6 <__avr32_f64_sub_longshift+0x10>
8000d1c0:	f2 05 09 4e 	lsl	lr,r9,r5
8000d1c4:	10 4e       	or	lr,r8
8000d1c6:	f2 06 0a 48 	lsr	r8,r9,r6
8000d1ca:	30 09       	mov	r9,0
8000d1cc:	58 0e       	cp.w	lr,0
8000d1ce:	5f 1e       	srne	lr
8000d1d0:	1c 48       	or	r8,lr
8000d1d2:	c8 3b       	rjmp	8000d0d8 <__avr32_f64_sub_shift_done>

8000d1d4 <__avr32_f64_sub_longnormalize>:
8000d1d4:	f4 06 12 00 	clz	r6,r10
8000d1d8:	f9 b7 03 00 	movlo	r7,0
8000d1dc:	f9 b6 03 00 	movlo	r6,0
8000d1e0:	f9 bc 03 00 	movlo	r12,0
8000d1e4:	f7 b6 02 e0 	subhs	r6,-32
8000d1e8:	f4 06 09 4b 	lsl	r11,r10,r6
8000d1ec:	30 0a       	mov	r10,0
8000d1ee:	0c 17       	sub	r7,r6
8000d1f0:	fe 9a ff be 	brle	8000d16c <__avr32_f64_sub_subnormal_result>
8000d1f4:	c8 5b       	rjmp	8000d0fe <__avr32_f64_sub_longnormalize_done>
8000d1f6:	d7 03       	nop

8000d1f8 <__avr32_f64_add_from_sub>:
8000d1f8:	ee 19 80 00 	eorh	r9,0x8000

8000d1fc <__avr32_f64_add>:
8000d1fc:	f7 e9 20 0c 	eor	r12,r11,r9
8000d200:	fe 96 ff 2e 	brmi	8000d05c <__avr32_f64_sub_from_add>
8000d204:	eb cd 40 e0 	pushm	r5-r7,lr
8000d208:	16 9c       	mov	r12,r11
8000d20a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d20e:	bf db       	cbr	r11,0x1f
8000d210:	bf d9       	cbr	r9,0x1f
8000d212:	12 3b       	cp.w	r11,r9
8000d214:	c0 72       	brcc	8000d222 <__avr32_f64_add+0x26>
8000d216:	16 97       	mov	r7,r11
8000d218:	12 9b       	mov	r11,r9
8000d21a:	0e 99       	mov	r9,r7
8000d21c:	14 97       	mov	r7,r10
8000d21e:	10 9a       	mov	r10,r8
8000d220:	0e 98       	mov	r8,r7
8000d222:	30 0e       	mov	lr,0
8000d224:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d228:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d22c:	b5 ab       	sbr	r11,0x14
8000d22e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d232:	c6 20       	breq	8000d2f6 <__avr32_f64_add_op2_subnormal>
8000d234:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d238:	b5 a9       	sbr	r9,0x14
8000d23a:	e0 47 07 ff 	cp.w	r7,2047
8000d23e:	c2 80       	breq	8000d28e <__avr32_f64_add_opH_nan_or_inf>
8000d240:	0e 26       	rsub	r6,r7
8000d242:	c1 20       	breq	8000d266 <__avr32_f64_add_shift_done>
8000d244:	e0 46 00 36 	cp.w	r6,54
8000d248:	c1 52       	brcc	8000d272 <__avr32_f64_add_res_of_done>
8000d24a:	ec 05 11 20 	rsub	r5,r6,32
8000d24e:	e0 46 00 20 	cp.w	r6,32
8000d252:	c3 52       	brcc	8000d2bc <__avr32_f64_add_longshift>
8000d254:	f0 05 09 4e 	lsl	lr,r8,r5
8000d258:	f2 05 09 45 	lsl	r5,r9,r5
8000d25c:	f0 06 0a 48 	lsr	r8,r8,r6
8000d260:	f2 06 0a 49 	lsr	r9,r9,r6
8000d264:	0a 48       	or	r8,r5

8000d266 <__avr32_f64_add_shift_done>:
8000d266:	10 0a       	add	r10,r8
8000d268:	f6 09 00 4b 	adc	r11,r11,r9
8000d26c:	ed bb 00 15 	bld	r11,0x15
8000d270:	c3 40       	breq	8000d2d8 <__avr32_f64_add_res_of>

8000d272 <__avr32_f64_add_res_of_done>:
8000d272:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d276:	18 4b       	or	r11,r12

8000d278 <__avr32_f64_add_round>:
8000d278:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d27c:	18 4e       	or	lr,r12
8000d27e:	ee 1e 80 00 	eorh	lr,0x8000
8000d282:	f1 be 04 20 	satu	lr,0x1
8000d286:	1c 0a       	add	r10,lr
8000d288:	5c 0b       	acr	r11
8000d28a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d28e <__avr32_f64_add_opH_nan_or_inf>:
8000d28e:	b5 cb       	cbr	r11,0x14
8000d290:	f7 ea 10 0e 	or	lr,r11,r10
8000d294:	c1 01       	brne	8000d2b4 <__avr32_f64_add_return_nan>
8000d296:	e0 46 07 ff 	cp.w	r6,2047
8000d29a:	c0 30       	breq	8000d2a0 <__avr32_f64_add_opL_nan_or_inf>
8000d29c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2a0 <__avr32_f64_add_opL_nan_or_inf>:
8000d2a0:	b5 c9       	cbr	r9,0x14
8000d2a2:	f3 e8 10 0e 	or	lr,r9,r8
8000d2a6:	c0 71       	brne	8000d2b4 <__avr32_f64_add_return_nan>
8000d2a8:	30 0a       	mov	r10,0
8000d2aa:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d2ae:	18 4b       	or	r11,r12
8000d2b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2b4 <__avr32_f64_add_return_nan>:
8000d2b4:	3f fa       	mov	r10,-1
8000d2b6:	3f fb       	mov	r11,-1
8000d2b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2bc <__avr32_f64_add_longshift>:
8000d2bc:	f1 b6 04 c0 	satu	r6,0x6
8000d2c0:	f0 0e 17 00 	moveq	lr,r8
8000d2c4:	c0 60       	breq	8000d2d0 <__avr32_f64_add_longshift+0x14>
8000d2c6:	f2 05 09 4e 	lsl	lr,r9,r5
8000d2ca:	58 08       	cp.w	r8,0
8000d2cc:	5f 18       	srne	r8
8000d2ce:	10 4e       	or	lr,r8
8000d2d0:	f2 06 0a 48 	lsr	r8,r9,r6
8000d2d4:	30 09       	mov	r9,0
8000d2d6:	cc 8b       	rjmp	8000d266 <__avr32_f64_add_shift_done>

8000d2d8 <__avr32_f64_add_res_of>:
8000d2d8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d2dc:	a1 9b       	lsr	r11,0x1
8000d2de:	5d 0a       	ror	r10
8000d2e0:	5d 0e       	ror	lr
8000d2e2:	2f f7       	sub	r7,-1
8000d2e4:	e0 47 07 ff 	cp.w	r7,2047
8000d2e8:	f9 ba 00 00 	moveq	r10,0
8000d2ec:	f9 bb 00 00 	moveq	r11,0
8000d2f0:	f9 be 00 00 	moveq	lr,0
8000d2f4:	cb fb       	rjmp	8000d272 <__avr32_f64_add_res_of_done>

8000d2f6 <__avr32_f64_add_op2_subnormal>:
8000d2f6:	30 16       	mov	r6,1
8000d2f8:	58 07       	cp.w	r7,0
8000d2fa:	ca 01       	brne	8000d23a <__avr32_f64_add+0x3e>
8000d2fc:	b5 cb       	cbr	r11,0x14
8000d2fe:	10 0a       	add	r10,r8
8000d300:	f6 09 00 4b 	adc	r11,r11,r9
8000d304:	18 4b       	or	r11,r12
8000d306:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d30a:	d7 03       	nop

8000d30c <__avr32_f64_to_u32>:
8000d30c:	58 0b       	cp.w	r11,0
8000d30e:	5e 6d       	retmi	0

8000d310 <__avr32_f64_to_s32>:
8000d310:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d314:	b5 9c       	lsr	r12,0x15
8000d316:	e0 2c 03 ff 	sub	r12,1023
8000d31a:	5e 3d       	retlo	0
8000d31c:	f8 0c 11 1f 	rsub	r12,r12,31
8000d320:	16 99       	mov	r9,r11
8000d322:	ab 7b       	lsl	r11,0xb
8000d324:	bf bb       	sbr	r11,0x1f
8000d326:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d32a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d32e:	a1 79       	lsl	r9,0x1
8000d330:	5e 2b       	reths	r11
8000d332:	5c 3b       	neg	r11
8000d334:	5e fb       	retal	r11

8000d336 <__avr32_u32_to_f64>:
8000d336:	f8 cb 00 00 	sub	r11,r12,0
8000d33a:	30 0c       	mov	r12,0
8000d33c:	c0 38       	rjmp	8000d342 <__avr32_s32_to_f64+0x4>

8000d33e <__avr32_s32_to_f64>:
8000d33e:	18 9b       	mov	r11,r12
8000d340:	5c 4b       	abs	r11
8000d342:	30 0a       	mov	r10,0
8000d344:	5e 0b       	reteq	r11
8000d346:	d4 01       	pushm	lr
8000d348:	e0 69 04 1e 	mov	r9,1054
8000d34c:	f6 08 12 00 	clz	r8,r11
8000d350:	c1 70       	breq	8000d37e <__avr32_s32_to_f64+0x40>
8000d352:	c0 c3       	brcs	8000d36a <__avr32_s32_to_f64+0x2c>
8000d354:	f0 0e 11 20 	rsub	lr,r8,32
8000d358:	f6 08 09 4b 	lsl	r11,r11,r8
8000d35c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d360:	1c 4b       	or	r11,lr
8000d362:	f4 08 09 4a 	lsl	r10,r10,r8
8000d366:	10 19       	sub	r9,r8
8000d368:	c0 b8       	rjmp	8000d37e <__avr32_s32_to_f64+0x40>
8000d36a:	f4 08 12 00 	clz	r8,r10
8000d36e:	f9 b8 03 00 	movlo	r8,0
8000d372:	f7 b8 02 e0 	subhs	r8,-32
8000d376:	f4 08 09 4b 	lsl	r11,r10,r8
8000d37a:	30 0a       	mov	r10,0
8000d37c:	10 19       	sub	r9,r8
8000d37e:	58 09       	cp.w	r9,0
8000d380:	e0 89 00 30 	brgt	8000d3e0 <__avr32_s32_to_f64+0xa2>
8000d384:	5c 39       	neg	r9
8000d386:	2f f9       	sub	r9,-1
8000d388:	e0 49 00 36 	cp.w	r9,54
8000d38c:	c0 43       	brcs	8000d394 <__avr32_s32_to_f64+0x56>
8000d38e:	30 0b       	mov	r11,0
8000d390:	30 0a       	mov	r10,0
8000d392:	c2 68       	rjmp	8000d3de <__avr32_s32_to_f64+0xa0>
8000d394:	2f 69       	sub	r9,-10
8000d396:	f2 08 11 20 	rsub	r8,r9,32
8000d39a:	e0 49 00 20 	cp.w	r9,32
8000d39e:	c0 b2       	brcc	8000d3b4 <__avr32_s32_to_f64+0x76>
8000d3a0:	f4 08 09 4e 	lsl	lr,r10,r8
8000d3a4:	f6 08 09 48 	lsl	r8,r11,r8
8000d3a8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3ac:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d3b0:	10 4b       	or	r11,r8
8000d3b2:	c0 88       	rjmp	8000d3c2 <__avr32_s32_to_f64+0x84>
8000d3b4:	f6 08 09 4e 	lsl	lr,r11,r8
8000d3b8:	14 4e       	or	lr,r10
8000d3ba:	16 9a       	mov	r10,r11
8000d3bc:	30 0b       	mov	r11,0
8000d3be:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3c2:	ed ba 00 00 	bld	r10,0x0
8000d3c6:	c0 92       	brcc	8000d3d8 <__avr32_s32_to_f64+0x9a>
8000d3c8:	1c 7e       	tst	lr,lr
8000d3ca:	c0 41       	brne	8000d3d2 <__avr32_s32_to_f64+0x94>
8000d3cc:	ed ba 00 01 	bld	r10,0x1
8000d3d0:	c0 42       	brcc	8000d3d8 <__avr32_s32_to_f64+0x9a>
8000d3d2:	2f fa       	sub	r10,-1
8000d3d4:	f7 bb 02 ff 	subhs	r11,-1
8000d3d8:	5c fc       	rol	r12
8000d3da:	5d 0b       	ror	r11
8000d3dc:	5d 0a       	ror	r10
8000d3de:	d8 02       	popm	pc
8000d3e0:	e0 68 03 ff 	mov	r8,1023
8000d3e4:	ed ba 00 0b 	bld	r10,0xb
8000d3e8:	f7 b8 00 ff 	subeq	r8,-1
8000d3ec:	10 0a       	add	r10,r8
8000d3ee:	5c 0b       	acr	r11
8000d3f0:	f7 b9 03 fe 	sublo	r9,-2
8000d3f4:	e0 49 07 ff 	cp.w	r9,2047
8000d3f8:	c0 55       	brlt	8000d402 <__avr32_s32_to_f64+0xc4>
8000d3fa:	30 0a       	mov	r10,0
8000d3fc:	fc 1b ff e0 	movh	r11,0xffe0
8000d400:	c0 c8       	rjmp	8000d418 <__floatsidf_return_op1>
8000d402:	ed bb 00 1f 	bld	r11,0x1f
8000d406:	f7 b9 01 01 	subne	r9,1
8000d40a:	ab 9a       	lsr	r10,0xb
8000d40c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d410:	a1 7b       	lsl	r11,0x1
8000d412:	ab 9b       	lsr	r11,0xb
8000d414:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d418 <__floatsidf_return_op1>:
8000d418:	a1 7c       	lsl	r12,0x1
8000d41a:	5d 0b       	ror	r11
8000d41c:	d8 02       	popm	pc

8000d41e <__avr32_f64_cmp_eq>:
8000d41e:	10 3a       	cp.w	r10,r8
8000d420:	f2 0b 13 00 	cpc	r11,r9
8000d424:	c0 80       	breq	8000d434 <__avr32_f64_cmp_eq+0x16>
8000d426:	a1 7b       	lsl	r11,0x1
8000d428:	a1 79       	lsl	r9,0x1
8000d42a:	14 4b       	or	r11,r10
8000d42c:	12 4b       	or	r11,r9
8000d42e:	10 4b       	or	r11,r8
8000d430:	5e 0f       	reteq	1
8000d432:	5e fd       	retal	0
8000d434:	a1 7b       	lsl	r11,0x1
8000d436:	fc 1c ff e0 	movh	r12,0xffe0
8000d43a:	58 0a       	cp.w	r10,0
8000d43c:	f8 0b 13 00 	cpc	r11,r12
8000d440:	5e 8f       	retls	1
8000d442:	5e fd       	retal	0

8000d444 <__avr32_f64_cmp_ge>:
8000d444:	1a de       	st.w	--sp,lr
8000d446:	1a d7       	st.w	--sp,r7
8000d448:	a1 7b       	lsl	r11,0x1
8000d44a:	5f 3c       	srlo	r12
8000d44c:	a1 79       	lsl	r9,0x1
8000d44e:	5f 37       	srlo	r7
8000d450:	5c fc       	rol	r12
8000d452:	fc 1e ff e0 	movh	lr,0xffe0
8000d456:	58 0a       	cp.w	r10,0
8000d458:	fc 0b 13 00 	cpc	r11,lr
8000d45c:	e0 8b 00 1d 	brhi	8000d496 <__avr32_f64_cmp_ge+0x52>
8000d460:	58 08       	cp.w	r8,0
8000d462:	fc 09 13 00 	cpc	r9,lr
8000d466:	e0 8b 00 18 	brhi	8000d496 <__avr32_f64_cmp_ge+0x52>
8000d46a:	58 0b       	cp.w	r11,0
8000d46c:	f5 ba 00 00 	subfeq	r10,0
8000d470:	c1 50       	breq	8000d49a <__avr32_f64_cmp_ge+0x56>
8000d472:	1b 07       	ld.w	r7,sp++
8000d474:	1b 0e       	ld.w	lr,sp++
8000d476:	58 3c       	cp.w	r12,3
8000d478:	c0 a0       	breq	8000d48c <__avr32_f64_cmp_ge+0x48>
8000d47a:	58 1c       	cp.w	r12,1
8000d47c:	c0 33       	brcs	8000d482 <__avr32_f64_cmp_ge+0x3e>
8000d47e:	5e 0f       	reteq	1
8000d480:	5e 1d       	retne	0
8000d482:	10 3a       	cp.w	r10,r8
8000d484:	f2 0b 13 00 	cpc	r11,r9
8000d488:	5e 2f       	reths	1
8000d48a:	5e 3d       	retlo	0
8000d48c:	14 38       	cp.w	r8,r10
8000d48e:	f6 09 13 00 	cpc	r9,r11
8000d492:	5e 2f       	reths	1
8000d494:	5e 3d       	retlo	0
8000d496:	1b 07       	ld.w	r7,sp++
8000d498:	d8 0a       	popm	pc,r12=0
8000d49a:	58 17       	cp.w	r7,1
8000d49c:	5f 0c       	sreq	r12
8000d49e:	58 09       	cp.w	r9,0
8000d4a0:	f5 b8 00 00 	subfeq	r8,0
8000d4a4:	1b 07       	ld.w	r7,sp++
8000d4a6:	1b 0e       	ld.w	lr,sp++
8000d4a8:	5e 0f       	reteq	1
8000d4aa:	5e fc       	retal	r12

8000d4ac <__avr32_f64_cmp_lt>:
8000d4ac:	1a de       	st.w	--sp,lr
8000d4ae:	1a d7       	st.w	--sp,r7
8000d4b0:	a1 7b       	lsl	r11,0x1
8000d4b2:	5f 3c       	srlo	r12
8000d4b4:	a1 79       	lsl	r9,0x1
8000d4b6:	5f 37       	srlo	r7
8000d4b8:	5c fc       	rol	r12
8000d4ba:	fc 1e ff e0 	movh	lr,0xffe0
8000d4be:	58 0a       	cp.w	r10,0
8000d4c0:	fc 0b 13 00 	cpc	r11,lr
8000d4c4:	e0 8b 00 1d 	brhi	8000d4fe <__avr32_f64_cmp_lt+0x52>
8000d4c8:	58 08       	cp.w	r8,0
8000d4ca:	fc 09 13 00 	cpc	r9,lr
8000d4ce:	e0 8b 00 18 	brhi	8000d4fe <__avr32_f64_cmp_lt+0x52>
8000d4d2:	58 0b       	cp.w	r11,0
8000d4d4:	f5 ba 00 00 	subfeq	r10,0
8000d4d8:	c1 50       	breq	8000d502 <__avr32_f64_cmp_lt+0x56>
8000d4da:	1b 07       	ld.w	r7,sp++
8000d4dc:	1b 0e       	ld.w	lr,sp++
8000d4de:	58 3c       	cp.w	r12,3
8000d4e0:	c0 a0       	breq	8000d4f4 <__avr32_f64_cmp_lt+0x48>
8000d4e2:	58 1c       	cp.w	r12,1
8000d4e4:	c0 33       	brcs	8000d4ea <__avr32_f64_cmp_lt+0x3e>
8000d4e6:	5e 0d       	reteq	0
8000d4e8:	5e 1f       	retne	1
8000d4ea:	10 3a       	cp.w	r10,r8
8000d4ec:	f2 0b 13 00 	cpc	r11,r9
8000d4f0:	5e 2d       	reths	0
8000d4f2:	5e 3f       	retlo	1
8000d4f4:	14 38       	cp.w	r8,r10
8000d4f6:	f6 09 13 00 	cpc	r9,r11
8000d4fa:	5e 2d       	reths	0
8000d4fc:	5e 3f       	retlo	1
8000d4fe:	1b 07       	ld.w	r7,sp++
8000d500:	d8 0a       	popm	pc,r12=0
8000d502:	58 17       	cp.w	r7,1
8000d504:	5f 1c       	srne	r12
8000d506:	58 09       	cp.w	r9,0
8000d508:	f5 b8 00 00 	subfeq	r8,0
8000d50c:	1b 07       	ld.w	r7,sp++
8000d50e:	1b 0e       	ld.w	lr,sp++
8000d510:	5e 0d       	reteq	0
8000d512:	5e fc       	retal	r12

8000d514 <__avr32_f64_div>:
8000d514:	eb cd 40 ff 	pushm	r0-r7,lr
8000d518:	f7 e9 20 0e 	eor	lr,r11,r9
8000d51c:	f6 07 16 14 	lsr	r7,r11,0x14
8000d520:	a9 7b       	lsl	r11,0x9
8000d522:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d526:	a9 7a       	lsl	r10,0x9
8000d528:	bd bb       	sbr	r11,0x1d
8000d52a:	e4 1b 3f ff 	andh	r11,0x3fff
8000d52e:	ab d7       	cbr	r7,0xb
8000d530:	e0 80 00 cc 	breq	8000d6c8 <__avr32_f64_div_round_subnormal+0x54>
8000d534:	e0 47 07 ff 	cp.w	r7,2047
8000d538:	e0 84 00 b5 	brge	8000d6a2 <__avr32_f64_div_round_subnormal+0x2e>
8000d53c:	f2 06 16 14 	lsr	r6,r9,0x14
8000d540:	a9 79       	lsl	r9,0x9
8000d542:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d546:	a9 78       	lsl	r8,0x9
8000d548:	bd b9       	sbr	r9,0x1d
8000d54a:	e4 19 3f ff 	andh	r9,0x3fff
8000d54e:	ab d6       	cbr	r6,0xb
8000d550:	e0 80 00 e2 	breq	8000d714 <__avr32_f64_div_round_subnormal+0xa0>
8000d554:	e0 46 07 ff 	cp.w	r6,2047
8000d558:	e0 84 00 b2 	brge	8000d6bc <__avr32_f64_div_round_subnormal+0x48>
8000d55c:	0c 17       	sub	r7,r6
8000d55e:	fe 37 fc 01 	sub	r7,-1023
8000d562:	fc 1c 80 00 	movh	r12,0x8000
8000d566:	f8 03 16 01 	lsr	r3,r12,0x1
8000d56a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d56e:	5c d4       	com	r4
8000d570:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d574:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d578:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d57c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d580:	ea 03 15 02 	lsl	r3,r5,0x2
8000d584:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d588:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d58c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d590:	ea 03 15 02 	lsl	r3,r5,0x2
8000d594:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d598:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d59c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5a4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5a8:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5ac:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5b0:	02 04       	add	r4,r1
8000d5b2:	5c 05       	acr	r5
8000d5b4:	a3 65       	lsl	r5,0x2
8000d5b6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5ba:	a3 64       	lsl	r4,0x2
8000d5bc:	5c 34       	neg	r4
8000d5be:	f8 05 01 45 	sbc	r5,r12,r5
8000d5c2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d5c6:	e4 05 07 40 	macu.d	r0,r2,r5
8000d5ca:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5ce:	02 04       	add	r4,r1
8000d5d0:	5c 05       	acr	r5
8000d5d2:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5d6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d5da:	e8 02 15 02 	lsl	r2,r4,0x2
8000d5de:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5e2:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5e6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5ea:	02 04       	add	r4,r1
8000d5ec:	5c 05       	acr	r5
8000d5ee:	a3 65       	lsl	r5,0x2
8000d5f0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5f4:	a3 64       	lsl	r4,0x2
8000d5f6:	5c 34       	neg	r4
8000d5f8:	f8 05 01 45 	sbc	r5,r12,r5
8000d5fc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d600:	e4 05 07 40 	macu.d	r0,r2,r5
8000d604:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d608:	02 04       	add	r4,r1
8000d60a:	5c 05       	acr	r5
8000d60c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d610:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d614:	e8 02 15 02 	lsl	r2,r4,0x2
8000d618:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d61c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d620:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d624:	02 02       	add	r2,r1
8000d626:	5c 03       	acr	r3
8000d628:	ed b3 00 1c 	bld	r3,0x1c
8000d62c:	c0 90       	breq	8000d63e <__avr32_f64_div+0x12a>
8000d62e:	a1 72       	lsl	r2,0x1
8000d630:	5c f3       	rol	r3
8000d632:	20 17       	sub	r7,1
8000d634:	a3 9a       	lsr	r10,0x3
8000d636:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d63a:	a3 9b       	lsr	r11,0x3
8000d63c:	c0 58       	rjmp	8000d646 <__avr32_f64_div+0x132>
8000d63e:	a5 8a       	lsr	r10,0x4
8000d640:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d644:	a5 8b       	lsr	r11,0x4
8000d646:	58 07       	cp.w	r7,0
8000d648:	e0 8a 00 8b 	brle	8000d75e <__avr32_f64_div_res_subnormal>
8000d64c:	e0 12 ff 00 	andl	r2,0xff00
8000d650:	e8 12 00 80 	orl	r2,0x80
8000d654:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d658:	e4 09 07 40 	macu.d	r0,r2,r9
8000d65c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d660:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d664:	00 05       	add	r5,r0
8000d666:	f0 01 00 48 	adc	r8,r8,r1
8000d66a:	5c 09       	acr	r9
8000d66c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d670:	58 04       	cp.w	r4,0
8000d672:	5c 25       	cpc	r5

8000d674 <__avr32_f64_div_round_subnormal>:
8000d674:	f4 08 13 00 	cpc	r8,r10
8000d678:	f6 09 13 00 	cpc	r9,r11
8000d67c:	5f 36       	srlo	r6
8000d67e:	f8 06 17 00 	moveq	r6,r12
8000d682:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d686:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d68a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d68e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d692:	ed be 00 1f 	bld	lr,0x1f
8000d696:	ef bb 00 1f 	bst	r11,0x1f
8000d69a:	0c 0a       	add	r10,r6
8000d69c:	5c 0b       	acr	r11
8000d69e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d6a2:	e4 1b 00 0f 	andh	r11,0xf
8000d6a6:	14 4b       	or	r11,r10
8000d6a8:	e0 81 00 a7 	brne	8000d7f6 <__avr32_f64_div_res_subnormal+0x98>
8000d6ac:	f2 06 16 14 	lsr	r6,r9,0x14
8000d6b0:	ab d6       	cbr	r6,0xb
8000d6b2:	e0 46 07 ff 	cp.w	r6,2047
8000d6b6:	e0 81 00 a4 	brne	8000d7fe <__avr32_f64_div_res_subnormal+0xa0>
8000d6ba:	c9 e8       	rjmp	8000d7f6 <__avr32_f64_div_res_subnormal+0x98>
8000d6bc:	e4 19 00 0f 	andh	r9,0xf
8000d6c0:	10 49       	or	r9,r8
8000d6c2:	e0 81 00 9a 	brne	8000d7f6 <__avr32_f64_div_res_subnormal+0x98>
8000d6c6:	c9 28       	rjmp	8000d7ea <__avr32_f64_div_res_subnormal+0x8c>
8000d6c8:	a3 7b       	lsl	r11,0x3
8000d6ca:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d6ce:	a3 7a       	lsl	r10,0x3
8000d6d0:	f5 eb 10 04 	or	r4,r10,r11
8000d6d4:	e0 80 00 a0 	breq	8000d814 <__avr32_f64_div_op1_zero>
8000d6d8:	f6 04 12 00 	clz	r4,r11
8000d6dc:	c1 70       	breq	8000d70a <__avr32_f64_div_round_subnormal+0x96>
8000d6de:	c0 c3       	brcs	8000d6f6 <__avr32_f64_div_round_subnormal+0x82>
8000d6e0:	e8 05 11 20 	rsub	r5,r4,32
8000d6e4:	f6 04 09 4b 	lsl	r11,r11,r4
8000d6e8:	f4 05 0a 45 	lsr	r5,r10,r5
8000d6ec:	0a 4b       	or	r11,r5
8000d6ee:	f4 04 09 4a 	lsl	r10,r10,r4
8000d6f2:	08 17       	sub	r7,r4
8000d6f4:	c0 b8       	rjmp	8000d70a <__avr32_f64_div_round_subnormal+0x96>
8000d6f6:	f4 04 12 00 	clz	r4,r10
8000d6fa:	f9 b4 03 00 	movlo	r4,0
8000d6fe:	f7 b4 02 e0 	subhs	r4,-32
8000d702:	f4 04 09 4b 	lsl	r11,r10,r4
8000d706:	30 0a       	mov	r10,0
8000d708:	08 17       	sub	r7,r4
8000d70a:	a3 8a       	lsr	r10,0x2
8000d70c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d710:	a3 8b       	lsr	r11,0x2
8000d712:	c1 1b       	rjmp	8000d534 <__avr32_f64_div+0x20>
8000d714:	a3 79       	lsl	r9,0x3
8000d716:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d71a:	a3 78       	lsl	r8,0x3
8000d71c:	f3 e8 10 04 	or	r4,r9,r8
8000d720:	c6 f0       	breq	8000d7fe <__avr32_f64_div_res_subnormal+0xa0>
8000d722:	f2 04 12 00 	clz	r4,r9
8000d726:	c1 70       	breq	8000d754 <__avr32_f64_div_round_subnormal+0xe0>
8000d728:	c0 c3       	brcs	8000d740 <__avr32_f64_div_round_subnormal+0xcc>
8000d72a:	e8 05 11 20 	rsub	r5,r4,32
8000d72e:	f2 04 09 49 	lsl	r9,r9,r4
8000d732:	f0 05 0a 45 	lsr	r5,r8,r5
8000d736:	0a 49       	or	r9,r5
8000d738:	f0 04 09 48 	lsl	r8,r8,r4
8000d73c:	08 16       	sub	r6,r4
8000d73e:	c0 b8       	rjmp	8000d754 <__avr32_f64_div_round_subnormal+0xe0>
8000d740:	f0 04 12 00 	clz	r4,r8
8000d744:	f9 b4 03 00 	movlo	r4,0
8000d748:	f7 b4 02 e0 	subhs	r4,-32
8000d74c:	f0 04 09 49 	lsl	r9,r8,r4
8000d750:	30 08       	mov	r8,0
8000d752:	08 16       	sub	r6,r4
8000d754:	a3 88       	lsr	r8,0x2
8000d756:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d75a:	a3 89       	lsr	r9,0x2
8000d75c:	cf ca       	rjmp	8000d554 <__avr32_f64_div+0x40>

8000d75e <__avr32_f64_div_res_subnormal>:
8000d75e:	5c 37       	neg	r7
8000d760:	2f f7       	sub	r7,-1
8000d762:	f1 b7 04 c0 	satu	r7,0x6
8000d766:	e0 47 00 20 	cp.w	r7,32
8000d76a:	c1 54       	brge	8000d794 <__avr32_f64_div_res_subnormal+0x36>
8000d76c:	ee 06 11 20 	rsub	r6,r7,32
8000d770:	e4 07 0a 42 	lsr	r2,r2,r7
8000d774:	e6 06 09 4c 	lsl	r12,r3,r6
8000d778:	18 42       	or	r2,r12
8000d77a:	e6 07 0a 43 	lsr	r3,r3,r7
8000d77e:	f4 06 09 41 	lsl	r1,r10,r6
8000d782:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d786:	f6 06 09 4c 	lsl	r12,r11,r6
8000d78a:	18 4a       	or	r10,r12
8000d78c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d790:	30 00       	mov	r0,0
8000d792:	c1 58       	rjmp	8000d7bc <__avr32_f64_div_res_subnormal+0x5e>
8000d794:	ee 06 11 20 	rsub	r6,r7,32
8000d798:	f9 b0 00 00 	moveq	r0,0
8000d79c:	f9 bc 00 00 	moveq	r12,0
8000d7a0:	c0 50       	breq	8000d7aa <__avr32_f64_div_res_subnormal+0x4c>
8000d7a2:	f4 06 09 40 	lsl	r0,r10,r6
8000d7a6:	f6 06 09 4c 	lsl	r12,r11,r6
8000d7aa:	e6 07 0a 42 	lsr	r2,r3,r7
8000d7ae:	30 03       	mov	r3,0
8000d7b0:	f4 07 0a 41 	lsr	r1,r10,r7
8000d7b4:	18 41       	or	r1,r12
8000d7b6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d7ba:	30 0b       	mov	r11,0
8000d7bc:	e0 12 ff 00 	andl	r2,0xff00
8000d7c0:	e8 12 00 80 	orl	r2,0x80
8000d7c4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d7c8:	e4 09 07 46 	macu.d	r6,r2,r9
8000d7cc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d7d0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d7d4:	0c 05       	add	r5,r6
8000d7d6:	f0 07 00 48 	adc	r8,r8,r7
8000d7da:	5c 09       	acr	r9
8000d7dc:	30 07       	mov	r7,0
8000d7de:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d7e2:	00 34       	cp.w	r4,r0
8000d7e4:	e2 05 13 00 	cpc	r5,r1
8000d7e8:	c4 6b       	rjmp	8000d674 <__avr32_f64_div_round_subnormal>
8000d7ea:	1c 9b       	mov	r11,lr
8000d7ec:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d7f0:	30 0a       	mov	r10,0
8000d7f2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7f6:	3f fb       	mov	r11,-1
8000d7f8:	30 0a       	mov	r10,0
8000d7fa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7fe:	f5 eb 10 04 	or	r4,r10,r11
8000d802:	c0 90       	breq	8000d814 <__avr32_f64_div_op1_zero>
8000d804:	1c 9b       	mov	r11,lr
8000d806:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d80a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d80e:	30 0a       	mov	r10,0
8000d810:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d814 <__avr32_f64_div_op1_zero>:
8000d814:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d818:	ce f0       	breq	8000d7f6 <__avr32_f64_div_res_subnormal+0x98>
8000d81a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d81e:	e0 44 07 ff 	cp.w	r4,2047
8000d822:	ce 41       	brne	8000d7ea <__avr32_f64_div_res_subnormal+0x8c>
8000d824:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d828:	ce 10       	breq	8000d7ea <__avr32_f64_div_res_subnormal+0x8c>
8000d82a:	ce 6b       	rjmp	8000d7f6 <__avr32_f64_div_res_subnormal+0x98>

8000d82c <__avr32_udiv64>:
8000d82c:	d4 31       	pushm	r0-r7,lr
8000d82e:	1a 97       	mov	r7,sp
8000d830:	20 3d       	sub	sp,12
8000d832:	10 9c       	mov	r12,r8
8000d834:	12 9e       	mov	lr,r9
8000d836:	14 93       	mov	r3,r10
8000d838:	58 09       	cp.w	r9,0
8000d83a:	e0 81 00 bd 	brne	8000d9b4 <__avr32_udiv64+0x188>
8000d83e:	16 38       	cp.w	r8,r11
8000d840:	e0 88 00 40 	brls	8000d8c0 <__avr32_udiv64+0x94>
8000d844:	f0 08 12 00 	clz	r8,r8
8000d848:	c0 d0       	breq	8000d862 <__avr32_udiv64+0x36>
8000d84a:	f6 08 09 4b 	lsl	r11,r11,r8
8000d84e:	f0 09 11 20 	rsub	r9,r8,32
8000d852:	f8 08 09 4c 	lsl	r12,r12,r8
8000d856:	f4 09 0a 49 	lsr	r9,r10,r9
8000d85a:	f4 08 09 43 	lsl	r3,r10,r8
8000d85e:	f3 eb 10 0b 	or	r11,r9,r11
8000d862:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d866:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d86a:	f6 0e 0d 00 	divu	r0,r11,lr
8000d86e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d872:	00 99       	mov	r9,r0
8000d874:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d878:	e0 0a 02 48 	mul	r8,r0,r10
8000d87c:	10 3b       	cp.w	r11,r8
8000d87e:	c0 a2       	brcc	8000d892 <__avr32_udiv64+0x66>
8000d880:	20 19       	sub	r9,1
8000d882:	18 0b       	add	r11,r12
8000d884:	18 3b       	cp.w	r11,r12
8000d886:	c0 63       	brcs	8000d892 <__avr32_udiv64+0x66>
8000d888:	10 3b       	cp.w	r11,r8
8000d88a:	f7 b9 03 01 	sublo	r9,1
8000d88e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d892:	f6 08 01 01 	sub	r1,r11,r8
8000d896:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d89a:	e2 0e 0d 00 	divu	r0,r1,lr
8000d89e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d8a2:	00 98       	mov	r8,r0
8000d8a4:	e0 0a 02 4a 	mul	r10,r0,r10
8000d8a8:	14 33       	cp.w	r3,r10
8000d8aa:	c0 82       	brcc	8000d8ba <__avr32_udiv64+0x8e>
8000d8ac:	20 18       	sub	r8,1
8000d8ae:	18 03       	add	r3,r12
8000d8b0:	18 33       	cp.w	r3,r12
8000d8b2:	c0 43       	brcs	8000d8ba <__avr32_udiv64+0x8e>
8000d8b4:	14 33       	cp.w	r3,r10
8000d8b6:	f7 b8 03 01 	sublo	r8,1
8000d8ba:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d8be:	cd f8       	rjmp	8000da7c <__avr32_udiv64+0x250>
8000d8c0:	58 08       	cp.w	r8,0
8000d8c2:	c0 51       	brne	8000d8cc <__avr32_udiv64+0xa0>
8000d8c4:	30 19       	mov	r9,1
8000d8c6:	f2 08 0d 08 	divu	r8,r9,r8
8000d8ca:	10 9c       	mov	r12,r8
8000d8cc:	f8 06 12 00 	clz	r6,r12
8000d8d0:	c0 41       	brne	8000d8d8 <__avr32_udiv64+0xac>
8000d8d2:	18 1b       	sub	r11,r12
8000d8d4:	30 19       	mov	r9,1
8000d8d6:	c4 08       	rjmp	8000d956 <__avr32_udiv64+0x12a>
8000d8d8:	ec 01 11 20 	rsub	r1,r6,32
8000d8dc:	f4 01 0a 49 	lsr	r9,r10,r1
8000d8e0:	f8 06 09 4c 	lsl	r12,r12,r6
8000d8e4:	f6 06 09 48 	lsl	r8,r11,r6
8000d8e8:	f6 01 0a 41 	lsr	r1,r11,r1
8000d8ec:	f3 e8 10 08 	or	r8,r9,r8
8000d8f0:	f8 03 16 10 	lsr	r3,r12,0x10
8000d8f4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d8f8:	e2 03 0d 00 	divu	r0,r1,r3
8000d8fc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d900:	00 9e       	mov	lr,r0
8000d902:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d906:	e0 05 02 49 	mul	r9,r0,r5
8000d90a:	12 3b       	cp.w	r11,r9
8000d90c:	c0 a2       	brcc	8000d920 <__avr32_udiv64+0xf4>
8000d90e:	20 1e       	sub	lr,1
8000d910:	18 0b       	add	r11,r12
8000d912:	18 3b       	cp.w	r11,r12
8000d914:	c0 63       	brcs	8000d920 <__avr32_udiv64+0xf4>
8000d916:	12 3b       	cp.w	r11,r9
8000d918:	f7 be 03 01 	sublo	lr,1
8000d91c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d920:	12 1b       	sub	r11,r9
8000d922:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d926:	f6 03 0d 02 	divu	r2,r11,r3
8000d92a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d92e:	04 99       	mov	r9,r2
8000d930:	e4 05 02 4b 	mul	r11,r2,r5
8000d934:	16 38       	cp.w	r8,r11
8000d936:	c0 a2       	brcc	8000d94a <__avr32_udiv64+0x11e>
8000d938:	20 19       	sub	r9,1
8000d93a:	18 08       	add	r8,r12
8000d93c:	18 38       	cp.w	r8,r12
8000d93e:	c0 63       	brcs	8000d94a <__avr32_udiv64+0x11e>
8000d940:	16 38       	cp.w	r8,r11
8000d942:	f7 b9 03 01 	sublo	r9,1
8000d946:	f1 dc e3 08 	addcs	r8,r8,r12
8000d94a:	f4 06 09 43 	lsl	r3,r10,r6
8000d94e:	f0 0b 01 0b 	sub	r11,r8,r11
8000d952:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d956:	f8 06 16 10 	lsr	r6,r12,0x10
8000d95a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d95e:	f6 06 0d 00 	divu	r0,r11,r6
8000d962:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d966:	00 9a       	mov	r10,r0
8000d968:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d96c:	e0 0e 02 48 	mul	r8,r0,lr
8000d970:	10 3b       	cp.w	r11,r8
8000d972:	c0 a2       	brcc	8000d986 <__avr32_udiv64+0x15a>
8000d974:	20 1a       	sub	r10,1
8000d976:	18 0b       	add	r11,r12
8000d978:	18 3b       	cp.w	r11,r12
8000d97a:	c0 63       	brcs	8000d986 <__avr32_udiv64+0x15a>
8000d97c:	10 3b       	cp.w	r11,r8
8000d97e:	f7 ba 03 01 	sublo	r10,1
8000d982:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d986:	f6 08 01 01 	sub	r1,r11,r8
8000d98a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d98e:	e2 06 0d 00 	divu	r0,r1,r6
8000d992:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d996:	00 98       	mov	r8,r0
8000d998:	e0 0e 02 4b 	mul	r11,r0,lr
8000d99c:	16 33       	cp.w	r3,r11
8000d99e:	c0 82       	brcc	8000d9ae <__avr32_udiv64+0x182>
8000d9a0:	20 18       	sub	r8,1
8000d9a2:	18 03       	add	r3,r12
8000d9a4:	18 33       	cp.w	r3,r12
8000d9a6:	c0 43       	brcs	8000d9ae <__avr32_udiv64+0x182>
8000d9a8:	16 33       	cp.w	r3,r11
8000d9aa:	f7 b8 03 01 	sublo	r8,1
8000d9ae:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d9b2:	c6 98       	rjmp	8000da84 <__avr32_udiv64+0x258>
8000d9b4:	16 39       	cp.w	r9,r11
8000d9b6:	e0 8b 00 65 	brhi	8000da80 <__avr32_udiv64+0x254>
8000d9ba:	f2 09 12 00 	clz	r9,r9
8000d9be:	c0 b1       	brne	8000d9d4 <__avr32_udiv64+0x1a8>
8000d9c0:	10 3a       	cp.w	r10,r8
8000d9c2:	5f 2a       	srhs	r10
8000d9c4:	1c 3b       	cp.w	r11,lr
8000d9c6:	5f b8       	srhi	r8
8000d9c8:	10 4a       	or	r10,r8
8000d9ca:	f2 0a 18 00 	cp.b	r10,r9
8000d9ce:	c5 90       	breq	8000da80 <__avr32_udiv64+0x254>
8000d9d0:	30 18       	mov	r8,1
8000d9d2:	c5 98       	rjmp	8000da84 <__avr32_udiv64+0x258>
8000d9d4:	f0 09 09 46 	lsl	r6,r8,r9
8000d9d8:	f2 03 11 20 	rsub	r3,r9,32
8000d9dc:	fc 09 09 4e 	lsl	lr,lr,r9
8000d9e0:	f0 03 0a 48 	lsr	r8,r8,r3
8000d9e4:	f6 09 09 4c 	lsl	r12,r11,r9
8000d9e8:	f4 03 0a 42 	lsr	r2,r10,r3
8000d9ec:	ef 46 ff f4 	st.w	r7[-12],r6
8000d9f0:	f6 03 0a 43 	lsr	r3,r11,r3
8000d9f4:	18 42       	or	r2,r12
8000d9f6:	f1 ee 10 0c 	or	r12,r8,lr
8000d9fa:	f8 01 16 10 	lsr	r1,r12,0x10
8000d9fe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000da02:	e6 01 0d 04 	divu	r4,r3,r1
8000da06:	e4 03 16 10 	lsr	r3,r2,0x10
8000da0a:	08 9e       	mov	lr,r4
8000da0c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000da10:	e8 06 02 48 	mul	r8,r4,r6
8000da14:	10 33       	cp.w	r3,r8
8000da16:	c0 a2       	brcc	8000da2a <__avr32_udiv64+0x1fe>
8000da18:	20 1e       	sub	lr,1
8000da1a:	18 03       	add	r3,r12
8000da1c:	18 33       	cp.w	r3,r12
8000da1e:	c0 63       	brcs	8000da2a <__avr32_udiv64+0x1fe>
8000da20:	10 33       	cp.w	r3,r8
8000da22:	f7 be 03 01 	sublo	lr,1
8000da26:	e7 dc e3 03 	addcs	r3,r3,r12
8000da2a:	10 13       	sub	r3,r8
8000da2c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000da30:	e6 01 0d 00 	divu	r0,r3,r1
8000da34:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000da38:	00 98       	mov	r8,r0
8000da3a:	e0 06 02 46 	mul	r6,r0,r6
8000da3e:	0c 3b       	cp.w	r11,r6
8000da40:	c0 a2       	brcc	8000da54 <__avr32_udiv64+0x228>
8000da42:	20 18       	sub	r8,1
8000da44:	18 0b       	add	r11,r12
8000da46:	18 3b       	cp.w	r11,r12
8000da48:	c0 63       	brcs	8000da54 <__avr32_udiv64+0x228>
8000da4a:	0c 3b       	cp.w	r11,r6
8000da4c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000da50:	f7 b8 03 01 	sublo	r8,1
8000da54:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000da58:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000da5c:	0c 1b       	sub	r11,r6
8000da5e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000da62:	06 95       	mov	r5,r3
8000da64:	16 35       	cp.w	r5,r11
8000da66:	e0 8b 00 0a 	brhi	8000da7a <__avr32_udiv64+0x24e>
8000da6a:	5f 0b       	sreq	r11
8000da6c:	f4 09 09 49 	lsl	r9,r10,r9
8000da70:	12 32       	cp.w	r2,r9
8000da72:	5f b9       	srhi	r9
8000da74:	f7 e9 00 09 	and	r9,r11,r9
8000da78:	c0 60       	breq	8000da84 <__avr32_udiv64+0x258>
8000da7a:	20 18       	sub	r8,1
8000da7c:	30 09       	mov	r9,0
8000da7e:	c0 38       	rjmp	8000da84 <__avr32_udiv64+0x258>
8000da80:	30 09       	mov	r9,0
8000da82:	12 98       	mov	r8,r9
8000da84:	10 9a       	mov	r10,r8
8000da86:	12 93       	mov	r3,r9
8000da88:	10 92       	mov	r2,r8
8000da8a:	12 9b       	mov	r11,r9
8000da8c:	2f dd       	sub	sp,-12
8000da8e:	d8 32       	popm	r0-r7,pc

8000da90 <__avr32_umod64>:
8000da90:	d4 31       	pushm	r0-r7,lr
8000da92:	1a 97       	mov	r7,sp
8000da94:	20 3d       	sub	sp,12
8000da96:	10 9c       	mov	r12,r8
8000da98:	12 95       	mov	r5,r9
8000da9a:	14 9e       	mov	lr,r10
8000da9c:	16 91       	mov	r1,r11
8000da9e:	16 96       	mov	r6,r11
8000daa0:	58 09       	cp.w	r9,0
8000daa2:	e0 81 00 81 	brne	8000dba4 <__avr32_umod64+0x114>
8000daa6:	16 38       	cp.w	r8,r11
8000daa8:	e0 88 00 12 	brls	8000dacc <__avr32_umod64+0x3c>
8000daac:	f0 08 12 00 	clz	r8,r8
8000dab0:	c4 e0       	breq	8000db4c <__avr32_umod64+0xbc>
8000dab2:	f6 08 09 46 	lsl	r6,r11,r8
8000dab6:	f8 08 09 4c 	lsl	r12,r12,r8
8000daba:	f0 0b 11 20 	rsub	r11,r8,32
8000dabe:	f4 08 09 4e 	lsl	lr,r10,r8
8000dac2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000dac6:	f7 e6 10 06 	or	r6,r11,r6
8000daca:	c4 18       	rjmp	8000db4c <__avr32_umod64+0xbc>
8000dacc:	58 08       	cp.w	r8,0
8000dace:	c0 51       	brne	8000dad8 <__avr32_umod64+0x48>
8000dad0:	30 19       	mov	r9,1
8000dad2:	f2 08 0d 08 	divu	r8,r9,r8
8000dad6:	10 9c       	mov	r12,r8
8000dad8:	f8 08 12 00 	clz	r8,r12
8000dadc:	c0 31       	brne	8000dae2 <__avr32_umod64+0x52>
8000dade:	18 16       	sub	r6,r12
8000dae0:	c3 68       	rjmp	8000db4c <__avr32_umod64+0xbc>
8000dae2:	f0 03 11 20 	rsub	r3,r8,32
8000dae6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000daea:	f8 08 09 4c 	lsl	r12,r12,r8
8000daee:	ec 08 09 49 	lsl	r9,r6,r8
8000daf2:	ec 03 0a 43 	lsr	r3,r6,r3
8000daf6:	f7 e9 10 09 	or	r9,r11,r9
8000dafa:	f8 05 16 10 	lsr	r5,r12,0x10
8000dafe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000db02:	e6 05 0d 02 	divu	r2,r3,r5
8000db06:	f2 0e 16 10 	lsr	lr,r9,0x10
8000db0a:	ec 02 02 4b 	mul	r11,r6,r2
8000db0e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000db12:	16 3e       	cp.w	lr,r11
8000db14:	c0 72       	brcc	8000db22 <__avr32_umod64+0x92>
8000db16:	18 0e       	add	lr,r12
8000db18:	18 3e       	cp.w	lr,r12
8000db1a:	c0 43       	brcs	8000db22 <__avr32_umod64+0x92>
8000db1c:	16 3e       	cp.w	lr,r11
8000db1e:	fd dc e3 0e 	addcs	lr,lr,r12
8000db22:	fc 0b 01 03 	sub	r3,lr,r11
8000db26:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000db2a:	e6 05 0d 02 	divu	r2,r3,r5
8000db2e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db32:	a5 36       	mul	r6,r2
8000db34:	0c 39       	cp.w	r9,r6
8000db36:	c0 72       	brcc	8000db44 <__avr32_umod64+0xb4>
8000db38:	18 09       	add	r9,r12
8000db3a:	18 39       	cp.w	r9,r12
8000db3c:	c0 43       	brcs	8000db44 <__avr32_umod64+0xb4>
8000db3e:	0c 39       	cp.w	r9,r6
8000db40:	f3 dc e3 09 	addcs	r9,r9,r12
8000db44:	f2 06 01 06 	sub	r6,r9,r6
8000db48:	f4 08 09 4e 	lsl	lr,r10,r8
8000db4c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000db50:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000db54:	ec 0a 0d 02 	divu	r2,r6,r10
8000db58:	fc 09 16 10 	lsr	r9,lr,0x10
8000db5c:	ea 02 02 4b 	mul	r11,r5,r2
8000db60:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db64:	16 39       	cp.w	r9,r11
8000db66:	c0 72       	brcc	8000db74 <__avr32_umod64+0xe4>
8000db68:	18 09       	add	r9,r12
8000db6a:	18 39       	cp.w	r9,r12
8000db6c:	c0 43       	brcs	8000db74 <__avr32_umod64+0xe4>
8000db6e:	16 39       	cp.w	r9,r11
8000db70:	f3 dc e3 09 	addcs	r9,r9,r12
8000db74:	f2 0b 01 0b 	sub	r11,r9,r11
8000db78:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000db7c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000db80:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000db84:	ea 0a 02 4a 	mul	r10,r5,r10
8000db88:	14 3e       	cp.w	lr,r10
8000db8a:	c0 72       	brcc	8000db98 <__avr32_umod64+0x108>
8000db8c:	18 0e       	add	lr,r12
8000db8e:	18 3e       	cp.w	lr,r12
8000db90:	c0 43       	brcs	8000db98 <__avr32_umod64+0x108>
8000db92:	14 3e       	cp.w	lr,r10
8000db94:	fd dc e3 0e 	addcs	lr,lr,r12
8000db98:	fc 0a 01 0a 	sub	r10,lr,r10
8000db9c:	30 0b       	mov	r11,0
8000db9e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000dba2:	c7 b8       	rjmp	8000dc98 <__avr32_umod64+0x208>
8000dba4:	16 39       	cp.w	r9,r11
8000dba6:	e0 8b 00 79 	brhi	8000dc98 <__avr32_umod64+0x208>
8000dbaa:	f2 09 12 00 	clz	r9,r9
8000dbae:	c1 21       	brne	8000dbd2 <__avr32_umod64+0x142>
8000dbb0:	10 3a       	cp.w	r10,r8
8000dbb2:	5f 2b       	srhs	r11
8000dbb4:	0a 31       	cp.w	r1,r5
8000dbb6:	5f ba       	srhi	r10
8000dbb8:	f7 ea 10 0a 	or	r10,r11,r10
8000dbbc:	f2 0a 18 00 	cp.b	r10,r9
8000dbc0:	c0 60       	breq	8000dbcc <__avr32_umod64+0x13c>
8000dbc2:	fc 08 01 0c 	sub	r12,lr,r8
8000dbc6:	e2 05 01 46 	sbc	r6,r1,r5
8000dbca:	18 9e       	mov	lr,r12
8000dbcc:	0c 9b       	mov	r11,r6
8000dbce:	1c 9a       	mov	r10,lr
8000dbd0:	c6 48       	rjmp	8000dc98 <__avr32_umod64+0x208>
8000dbd2:	ea 09 09 4c 	lsl	r12,r5,r9
8000dbd6:	f2 06 11 20 	rsub	r6,r9,32
8000dbda:	f6 09 09 4b 	lsl	r11,r11,r9
8000dbde:	f0 09 09 42 	lsl	r2,r8,r9
8000dbe2:	ef 46 ff f4 	st.w	r7[-12],r6
8000dbe6:	f0 06 0a 48 	lsr	r8,r8,r6
8000dbea:	18 48       	or	r8,r12
8000dbec:	e2 06 0a 4c 	lsr	r12,r1,r6
8000dbf0:	f4 09 09 43 	lsl	r3,r10,r9
8000dbf4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000dbf8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000dbfc:	16 4a       	or	r10,r11
8000dbfe:	f0 0b 16 10 	lsr	r11,r8,0x10
8000dc02:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc06:	f4 0c 16 10 	lsr	r12,r10,0x10
8000dc0a:	08 91       	mov	r1,r4
8000dc0c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000dc10:	e8 0e 02 46 	mul	r6,r4,lr
8000dc14:	0c 3c       	cp.w	r12,r6
8000dc16:	c0 a2       	brcc	8000dc2a <__avr32_umod64+0x19a>
8000dc18:	20 11       	sub	r1,1
8000dc1a:	10 0c       	add	r12,r8
8000dc1c:	10 3c       	cp.w	r12,r8
8000dc1e:	c0 63       	brcs	8000dc2a <__avr32_umod64+0x19a>
8000dc20:	0c 3c       	cp.w	r12,r6
8000dc22:	f7 b1 03 01 	sublo	r1,1
8000dc26:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000dc2a:	0c 1c       	sub	r12,r6
8000dc2c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000dc30:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc34:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dc38:	08 96       	mov	r6,r4
8000dc3a:	e8 0e 02 4e 	mul	lr,r4,lr
8000dc3e:	1c 3b       	cp.w	r11,lr
8000dc40:	c0 a2       	brcc	8000dc54 <__avr32_umod64+0x1c4>
8000dc42:	20 16       	sub	r6,1
8000dc44:	10 0b       	add	r11,r8
8000dc46:	10 3b       	cp.w	r11,r8
8000dc48:	c0 63       	brcs	8000dc54 <__avr32_umod64+0x1c4>
8000dc4a:	1c 3b       	cp.w	r11,lr
8000dc4c:	f7 b6 03 01 	sublo	r6,1
8000dc50:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dc54:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dc58:	1c 1b       	sub	r11,lr
8000dc5a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dc5e:	00 9e       	mov	lr,r0
8000dc60:	02 9c       	mov	r12,r1
8000dc62:	16 3c       	cp.w	r12,r11
8000dc64:	e0 8b 00 08 	brhi	8000dc74 <__avr32_umod64+0x1e4>
8000dc68:	5f 06       	sreq	r6
8000dc6a:	06 30       	cp.w	r0,r3
8000dc6c:	5f ba       	srhi	r10
8000dc6e:	ed ea 00 0a 	and	r10,r6,r10
8000dc72:	c0 60       	breq	8000dc7e <__avr32_umod64+0x1ee>
8000dc74:	fc 02 01 04 	sub	r4,lr,r2
8000dc78:	f8 08 01 4c 	sbc	r12,r12,r8
8000dc7c:	08 9e       	mov	lr,r4
8000dc7e:	e6 0e 01 0a 	sub	r10,r3,lr
8000dc82:	f6 0c 01 4c 	sbc	r12,r11,r12
8000dc86:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000dc8a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000dc8e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000dc92:	f8 01 09 4c 	lsl	r12,r12,r1
8000dc96:	18 4a       	or	r10,r12
8000dc98:	2f dd       	sub	sp,-12
8000dc9a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000de00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000de00:	c0 08       	rjmp	8000de00 <_evba>
	...

8000de04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000de04:	c0 08       	rjmp	8000de04 <_handle_TLB_Multiple_Hit>
	...

8000de08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000de08:	c0 08       	rjmp	8000de08 <_handle_Bus_Error_Data_Fetch>
	...

8000de0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000de0c:	c0 08       	rjmp	8000de0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000de10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000de10:	c0 08       	rjmp	8000de10 <_handle_NMI>
	...

8000de14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000de14:	c0 08       	rjmp	8000de14 <_handle_Instruction_Address>
	...

8000de18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000de18:	c0 08       	rjmp	8000de18 <_handle_ITLB_Protection>
	...

8000de1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000de1c:	c0 08       	rjmp	8000de1c <_handle_Breakpoint>
	...

8000de20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000de20:	c0 08       	rjmp	8000de20 <_handle_Illegal_Opcode>
	...

8000de24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000de24:	c0 08       	rjmp	8000de24 <_handle_Unimplemented_Instruction>
	...

8000de28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000de28:	c0 08       	rjmp	8000de28 <_handle_Privilege_Violation>
	...

8000de2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000de2c:	c0 08       	rjmp	8000de2c <_handle_Floating_Point>
	...

8000de30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000de30:	c0 08       	rjmp	8000de30 <_handle_Coprocessor_Absent>
	...

8000de34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000de34:	c0 08       	rjmp	8000de34 <_handle_Data_Address_Read>
	...

8000de38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000de38:	c0 08       	rjmp	8000de38 <_handle_Data_Address_Write>
	...

8000de3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000de3c:	c0 08       	rjmp	8000de3c <_handle_DTLB_Protection_Read>
	...

8000de40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000de40:	c0 08       	rjmp	8000de40 <_handle_DTLB_Protection_Write>
	...

8000de44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000de44:	c0 08       	rjmp	8000de44 <_handle_DTLB_Modified>
	...

8000de50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000de50:	c0 08       	rjmp	8000de50 <_handle_ITLB_Miss>
	...

8000de60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000de60:	c0 08       	rjmp	8000de60 <_handle_DTLB_Miss_Read>
	...

8000de70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000de70:	c0 08       	rjmp	8000de70 <_handle_DTLB_Miss_Write>
	...

8000df00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000df00:	fe cf 71 28 	sub	pc,pc,28968

8000df04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000df04:	30 0c       	mov	r12,0
8000df06:	fe b0 c2 cf 	rcall	800064a4 <_get_interrupt_handler>
8000df0a:	58 0c       	cp.w	r12,0
8000df0c:	f8 0f 17 10 	movne	pc,r12
8000df10:	d6 03       	rete

8000df12 <_int1>:
8000df12:	30 1c       	mov	r12,1
8000df14:	fe b0 c2 c8 	rcall	800064a4 <_get_interrupt_handler>
8000df18:	58 0c       	cp.w	r12,0
8000df1a:	f8 0f 17 10 	movne	pc,r12
8000df1e:	d6 03       	rete

8000df20 <_int2>:
8000df20:	30 2c       	mov	r12,2
8000df22:	fe b0 c2 c1 	rcall	800064a4 <_get_interrupt_handler>
8000df26:	58 0c       	cp.w	r12,0
8000df28:	f8 0f 17 10 	movne	pc,r12
8000df2c:	d6 03       	rete

8000df2e <_int3>:
8000df2e:	30 3c       	mov	r12,3
8000df30:	fe b0 c2 ba 	rcall	800064a4 <_get_interrupt_handler>
8000df34:	58 0c       	cp.w	r12,0
8000df36:	f8 0f 17 10 	movne	pc,r12
8000df3a:	d6 03       	rete

8000df3c <ipr_val>:
8000df3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000df4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dffc:	d7 03 d7 03                                         ....
