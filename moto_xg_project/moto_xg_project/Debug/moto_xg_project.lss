
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bc94  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000de00  8000de00  0000e200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001624  8000e000  8000e000  0000e400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000f624  8000f624  0000fa24  2**0
                  ALLOC
  6 .data         00000a54  00000004  8000f628  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b2f8  00000a58  8001007c  00010658  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00003844  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002e241  00000000  00000000  00015664  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000781b  00000000  00000000  000438a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000dc9f  00000000  00000000  0004b0c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000040e4  00000000  00000000  00058d60  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000082df  00000000  00000000  0005ce44  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000ff71  00000000  00000000  00065123  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001848  00000000  00000000  00075098  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b3 f8 	sub	pc,pc,-19464

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 1c       	sub	r12,r7

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 70       	tst	r0,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	e0 00       	*unknown*
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	7f 64       	ld.w	r4,pc[0x58]

80002050 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 5f       	eor	pc,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	e0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	7f 64       	ld.w	r4,pc[0x58]
80002080:	00 00       	add	r0,r0
80002082:	0a 60       	and	r0,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	e0 10 80 00 	andl	r0,0x8000
80002096:	7f 64       	ld.w	r4,pc[0x58]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	e0 30 80 00 	sub	r0,98304
800020aa:	7f 64       	ld.w	r4,pc[0x58]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	e0 4c 80 00 	cp.w	r12,32768
800020be:	7f 64       	ld.w	r4,pc[0x58]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	e0 68 80 00 	mov	r8,32768
800020d2:	7f 64       	ld.w	r4,pc[0x58]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	e0 80 80 00 	breq	8001212e <_data_lma+0x2b06>
80002132:	7f 64       	ld.w	r4,pc[0x58]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	e0 98 80 00 	brls	80032136 <_data_lma+0x22b0e>
8000213a:	e0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	e0 c4 80 00 	sub	r4,r0,-32768
80002142:	e0 e0 eb cd 	ld.d	r0,r0[-5171]

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	e0 f8 80 00 	ld.w	r8,r0[-32768]
80002182:	7f 64       	ld.w	r4,pc[0x58]
80002184:	00 00       	add	r0,r0
80002186:	00 08       	add	r8,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	e1 0c 80 00 	ld.sh	r12,r0[-32768]
8000218e:	e1 1c d4 31 	ld.uh	r12,r0[-11215]

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	e1 30 80 00 	ld.ub	r0,r0[-32768]
8000224a:	7f 64       	ld.w	r4,pc[0x58]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	e1 50 80 00 	st.h	r0[-32768],r0
80002252:	e1 64 80 00 	st.b	r0[-32768],r4
80002256:	e1 7c 80 00 	stcond	r0[-32768],r12
8000225a:	e1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	e1 c4 80 00 	ldm	r4,pc
80002262:	e1 ec 80 00 	sthh.w	r0[r0],r0:b,r12:b
80002266:	e2 10 80 00 	andl	r0,0x8000,COH
8000226a:	e2 38 eb cd 	sub	r8,256973

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	e2 5c 80 00 	cp.w	r12,229376
800022a6:	7f 64       	ld.w	r4,pc[0x58]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	e1 50 80 00 	st.h	r0[-32768],r0
800022ae:	e2 74 eb cd 	mov	r4,256973

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 40       	breq	800022c8 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022c2:	48 5c       	lddpc	r12,800022d4 <BatteryLevel_brdcst_func+0x24>
800022c4:	f0 1f 00 05 	mcall	800022d8 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	48 58       	lddpc	r8,800022dc <BatteryLevel_brdcst_func+0x2c>
800022cc:	b0 89       	st.b	r8[0x0],r9

}
800022ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	e2 90 80 00 	breq	800722d6 <_data_lma+0x62cae>
800022da:	7f 64       	ld.w	r4,pc[0x58]
800022dc:	00 00       	add	r0,r0
800022de:	0a 84       	andn	r4,r5

800022e0 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022e2:	19 a8       	ld.ub	r8,r12[0x2]
800022e4:	30 19       	mov	r9,1
800022e6:	f2 08 18 00 	cp.b	r8,r9
800022ea:	c0 51       	brne	800022f4 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
800022ec:	48 6c       	lddpc	r12,80002304 <ShutDown_brdcst_func+0x24>
800022ee:	f0 1f 00 07 	mcall	80002308 <ShutDown_brdcst_func+0x28>
800022f2:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
800022f4:	30 29       	mov	r9,2
800022f6:	f2 08 18 00 	cp.b	r8,r9
800022fa:	c0 41       	brne	80002302 <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
800022fc:	48 4c       	lddpc	r12,8000230c <ShutDown_brdcst_func+0x2c>
800022fe:	f0 1f 00 03 	mcall	80002308 <ShutDown_brdcst_func+0x28>
80002302:	d8 02       	popm	pc
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	e2 a4       	*unknown*
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	7f 64       	ld.w	r4,pc[0x58]
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	e2 b8       	*unknown*

80002310 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002310:	eb cd 40 80 	pushm	r7,lr
80002314:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002316:	19 a9       	ld.ub	r9,r12[0x2]
80002318:	30 08       	mov	r8,0
8000231a:	f0 09 18 00 	cp.b	r9,r8
8000231e:	c0 61       	brne	8000232a <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
80002320:	48 dc       	lddpc	r12,80002354 <DataSession_reply_func+0x44>
80002322:	f0 1f 00 0e 	mcall	80002358 <DataSession_reply_func+0x48>
80002326:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
8000232a:	48 dc       	lddpc	r12,8000235c <DataSession_reply_func+0x4c>
8000232c:	f0 1f 00 0b 	mcall	80002358 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
80002330:	0f a8       	ld.ub	r8,r7[0x2]
80002332:	1a d8       	st.w	--sp,r8
80002334:	48 bc       	lddpc	r12,80002360 <DataSession_reply_func+0x50>
80002336:	f0 1f 00 09 	mcall	80002358 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
8000233a:	0f b8       	ld.ub	r8,r7[0x3]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ac       	lddpc	r12,80002364 <DataSession_reply_func+0x54>
80002340:	f0 1f 00 06 	mcall	80002358 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002344:	0f c8       	ld.ub	r8,r7[0x4]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 8c       	lddpc	r12,80002368 <DataSession_reply_func+0x58>
8000234a:	f0 1f 00 04 	mcall	80002358 <DataSession_reply_func+0x48>
8000234e:	2f dd       	sub	sp,-12
80002350:	e3 cd 80 80 	ldm	sp++,r7,pc
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	e2 c8 80 00 	sub	r8,r1,-32768
8000235a:	7f 64       	ld.w	r4,pc[0x58]
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	e2 d8 80 00 	satsub.w	r8,r1,-32768
80002362:	e2 e8 80 00 	ld.d	r8,r1[-32768]
80002366:	e2 f8 80 00 	ld.w	r8,r1[-32768]
8000236a:	e3 04 eb cd 	ld.sh	r4,r1[-5171]

8000236c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000236c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002370:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002374:	0f 98       	ld.ub	r8,r7[0x1]
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 bc       	lddpc	r12,800023a4 <CallControl_brdcst_func+0x38>
8000237a:	f0 1f 00 0c 	mcall	800023a8 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000237e:	2f fd       	sub	sp,-4
80002380:	0f 99       	ld.ub	r9,r7[0x1]
80002382:	30 38       	mov	r8,3
80002384:	f0 09 18 00 	cp.b	r9,r8
80002388:	c0 41       	brne	80002390 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000238a:	30 09       	mov	r9,0
8000238c:	48 88       	lddpc	r8,800023ac <CallControl_brdcst_func+0x40>
8000238e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002390:	0f 99       	ld.ub	r9,r7[0x1]
80002392:	30 48       	mov	r8,4
80002394:	f0 09 18 00 	cp.b	r9,r8
80002398:	c0 41       	brne	800023a0 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000239a:	30 19       	mov	r9,1
8000239c:	48 48       	lddpc	r8,800023ac <CallControl_brdcst_func+0x40>
8000239e:	b0 89       	st.b	r8[0x0],r9
800023a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	e3 10 80 00 	ld.uh	r0,r1[-32768]
800023aa:	7f 64       	ld.w	r4,pc[0x58]
800023ac:	00 00       	add	r0,r0
800023ae:	0a 86       	andn	r6,r5

800023b0 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023b4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023b8:	0f 99       	ld.ub	r9,r7[0x1]
800023ba:	30 08       	mov	r8,0
800023bc:	f0 09 18 00 	cp.b	r9,r8
800023c0:	c0 71       	brne	800023ce <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023c2:	48 ac       	lddpc	r12,800023e8 <TransmitControl_brdcst_func+0x38>
800023c4:	f0 1f 00 0a 	mcall	800023ec <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023c8:	30 09       	mov	r9,0
800023ca:	48 a8       	lddpc	r8,800023f0 <TransmitControl_brdcst_func+0x40>
800023cc:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ce:	0f 99       	ld.ub	r9,r7[0x1]
800023d0:	30 18       	mov	r8,1
800023d2:	f0 09 18 00 	cp.b	r9,r8
800023d6:	c0 71       	brne	800023e4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023d8:	48 7c       	lddpc	r12,800023f4 <TransmitControl_brdcst_func+0x44>
800023da:	f0 1f 00 05 	mcall	800023ec <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023de:	30 19       	mov	r9,1
800023e0:	48 48       	lddpc	r8,800023f0 <TransmitControl_brdcst_func+0x40>
800023e2:	b0 89       	st.b	r8[0x0],r9
800023e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	e3 28 80 00 	ld.sb	r8,r1[-32768]
800023ee:	7f 64       	ld.w	r4,pc[0x58]
800023f0:	00 00       	add	r0,r0
800023f2:	0a 5c       	eor	r12,r5
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	e3 40 eb cd 	st.w	r1[-5171],r0

800023f8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002400:	0f 89       	ld.ub	r9,r7[0x0]
80002402:	30 08       	mov	r8,0
80002404:	f0 09 18 00 	cp.b	r9,r8
80002408:	c1 61       	brne	80002434 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000240a:	48 ec       	lddpc	r12,80002440 <TransmitControl_reply_func+0x48>
8000240c:	f0 1f 00 0e 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 dc       	lddpc	r12,80002448 <TransmitControl_reply_func+0x50>
80002416:	f0 1f 00 0c 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000241a:	0f a8       	ld.ub	r8,r7[0x2]
8000241c:	1a d8       	st.w	--sp,r8
8000241e:	48 cc       	lddpc	r12,8000244c <TransmitControl_reply_func+0x54>
80002420:	f0 1f 00 09 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002424:	0f b8       	ld.ub	r8,r7[0x3]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 ac       	lddpc	r12,80002450 <TransmitControl_reply_func+0x58>
8000242a:	f0 1f 00 07 	mcall	80002444 <TransmitControl_reply_func+0x4c>
8000242e:	2f dd       	sub	sp,-12
80002430:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002434:	48 8c       	lddpc	r12,80002454 <TransmitControl_reply_func+0x5c>
80002436:	f0 1f 00 04 	mcall	80002444 <TransmitControl_reply_func+0x4c>
8000243a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000243e:	00 00       	add	r0,r0
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	e3 54 80 00 	st.h	r1[-32768],r4
80002446:	7f 64       	ld.w	r4,pc[0x58]
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	e3 70 80 00 	stcond	r1[-32768],r0
8000244e:	e3 84       	*unknown*
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	e3 a0 80 00 	cop	cp4,cr0,cr0,cr0,0x20
80002456:	e3 b0       	*unknown*

80002458 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002458:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000245a:	19 a9       	ld.ub	r9,r12[0x2]
8000245c:	30 08       	mov	r8,0
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 51       	brne	8000246c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002464:	48 4c       	lddpc	r12,80002474 <AudioRoutingControl_reply_func+0x1c>
80002466:	f0 1f 00 05 	mcall	80002478 <AudioRoutingControl_reply_func+0x20>
8000246a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000246c:	48 4c       	lddpc	r12,8000247c <AudioRoutingControl_reply_func+0x24>
8000246e:	f0 1f 00 03 	mcall	80002478 <AudioRoutingControl_reply_func+0x20>
80002472:	d8 02       	popm	pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	e3 c8 80 00 	ldm	r8++,pc
8000247a:	7f 64       	ld.w	r4,pc[0x58]
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	e3 d8       	*unknown*

80002480 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002480:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002484:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002488:	0f 89       	ld.ub	r9,r7[0x0]
8000248a:	30 08       	mov	r8,0
8000248c:	f0 09 18 00 	cp.b	r9,r8
80002490:	c1 b1       	brne	800024c6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002492:	0f b8       	ld.ub	r8,r7[0x3]
80002494:	31 09       	mov	r9,16
80002496:	f2 08 18 00 	cp.b	r8,r9
8000249a:	c0 f1       	brne	800024b8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000249c:	48 dc       	lddpc	r12,800024d0 <Volume_reply_func+0x50>
8000249e:	f0 1f 00 0e 	mcall	800024d4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024a2:	0f 99       	ld.ub	r9,r7[0x1]
800024a4:	0f a8       	ld.ub	r8,r7[0x2]
800024a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024aa:	1a d8       	st.w	--sp,r8
800024ac:	48 bc       	lddpc	r12,800024d8 <Volume_reply_func+0x58>
800024ae:	f0 1f 00 0a 	mcall	800024d4 <Volume_reply_func+0x54>
800024b2:	2f fd       	sub	sp,-4
800024b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 9c       	lddpc	r12,800024dc <Volume_reply_func+0x5c>
800024bc:	f0 1f 00 06 	mcall	800024d4 <Volume_reply_func+0x54>
800024c0:	2f fd       	sub	sp,-4
800024c2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024c6:	48 7c       	lddpc	r12,800024e0 <Volume_reply_func+0x60>
800024c8:	f0 1f 00 03 	mcall	800024d4 <Volume_reply_func+0x54>
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	e3 ec 80 00 	sthh.w	r0[r0],r1:b,r12:b
800024d6:	7f 64       	ld.w	r4,pc[0x58]
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	e4 00       	*unknown*
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	e4 1c 80 00 	andh	r12,0x8000
800024e2:	e4 34 d4 01 	sub	r4,381953

800024e4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024e6:	19 d9       	ld.ub	r9,r12[0x5]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 81       	brne	800024fe <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024f0:	10 99       	mov	r9,r8
800024f2:	48 78       	lddpc	r8,8000250c <spk_brdcst_func+0x28>
800024f4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024f6:	48 7c       	lddpc	r12,80002510 <spk_brdcst_func+0x2c>
800024f8:	f0 1f 00 07 	mcall	80002514 <spk_brdcst_func+0x30>
800024fc:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024fe:	30 19       	mov	r9,1
80002500:	48 38       	lddpc	r8,8000250c <spk_brdcst_func+0x28>
80002502:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002504:	48 5c       	lddpc	r12,80002518 <spk_brdcst_func+0x34>
80002506:	f0 1f 00 04 	mcall	80002514 <spk_brdcst_func+0x30>
8000250a:	d8 02       	popm	pc
8000250c:	00 00       	add	r0,r0
8000250e:	0a 7d       	tst	sp,r5
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	e4 4c 80 00 	cp.w	r12,294912
80002516:	7f 64       	ld.w	r4,pc[0x58]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	e4 5c d4 01 	cp.w	r12,381953

8000251c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000251e:	19 a9       	ld.ub	r9,r12[0x2]
80002520:	30 08       	mov	r8,0
80002522:	f0 09 18 00 	cp.b	r9,r8
80002526:	c0 f1       	brne	80002544 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002528:	19 e9       	ld.ub	r9,r12[0x6]
8000252a:	f0 09 18 00 	cp.b	r9,r8
8000252e:	c0 40       	breq	80002536 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002530:	30 19       	mov	r9,1
80002532:	48 98       	lddpc	r8,80002554 <spk_reply_func+0x38>
80002534:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002536:	19 e8       	ld.ub	r8,r12[0x6]
80002538:	1a d8       	st.w	--sp,r8
8000253a:	48 8c       	lddpc	r12,80002558 <spk_reply_func+0x3c>
8000253c:	f0 1f 00 08 	mcall	8000255c <spk_reply_func+0x40>
80002540:	2f fd       	sub	sp,-4
80002542:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002544:	30 09       	mov	r9,0
80002546:	48 48       	lddpc	r8,80002554 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000254a:	48 6c       	lddpc	r12,80002560 <spk_reply_func+0x44>
8000254c:	f0 1f 00 04 	mcall	8000255c <spk_reply_func+0x40>
80002550:	d8 02       	popm	pc
80002552:	00 00       	add	r0,r0
80002554:	00 00       	add	r0,r0
80002556:	0a 7d       	tst	sp,r5
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	e4 68 80 00 	mov	r8,294912
8000255e:	7f 64       	ld.w	r4,pc[0x58]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	e4 78 eb cd 	mov	r8,388045

80002564 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002564:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002568:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000256c:	0f a9       	ld.ub	r9,r7[0x2]
8000256e:	30 08       	mov	r8,0
80002570:	f0 09 18 00 	cp.b	r9,r8
80002574:	c0 71       	brne	80002582 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002576:	48 dc       	lddpc	r12,800025a8 <mic_brdcst_func+0x44>
80002578:	f0 1f 00 0d 	mcall	800025ac <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000257c:	30 09       	mov	r9,0
8000257e:	48 d8       	lddpc	r8,800025b0 <mic_brdcst_func+0x4c>
80002580:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002582:	0f a9       	ld.ub	r9,r7[0x2]
80002584:	31 18       	mov	r8,17
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 d1       	brne	800025a4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000258c:	48 ac       	lddpc	r12,800025b4 <mic_brdcst_func+0x50>
8000258e:	f0 1f 00 08 	mcall	800025ac <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002592:	48 89       	lddpc	r9,800025b0 <mic_brdcst_func+0x4c>
80002594:	30 18       	mov	r8,1
80002596:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002598:	13 89       	ld.ub	r9,r9[0x0]
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 31       	brne	800025a4 <mic_brdcst_func+0x40>
800025a0:	48 68       	lddpc	r8,800025b8 <mic_brdcst_func+0x54>
800025a2:	11 88       	ld.ub	r8,r8[0x0]
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	e4 84 80 00 	brge	800925aa <_data_lma+0x82f82>
800025ae:	7f 64       	ld.w	r4,pc[0x58]
800025b0:	00 00       	add	r0,r0
800025b2:	0a 7c       	tst	r12,r5
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	e4 98 00 00 	brls	800a25b6 <_data_lma+0x92f8e>
800025ba:	0a 86       	andn	r6,r5

800025bc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025c0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025c4:	49 ac       	lddpc	r12,8000262c <mic_reply_func+0x70>
800025c6:	f0 1f 00 1b 	mcall	80002630 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ca:	0f 89       	ld.ub	r9,r7[0x0]
800025cc:	30 08       	mov	r8,0
800025ce:	f0 09 18 00 	cp.b	r9,r8
800025d2:	c2 71       	brne	80002620 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025d4:	0f 98       	ld.ub	r8,r7[0x1]
800025d6:	30 29       	mov	r9,2
800025d8:	f2 08 18 00 	cp.b	r8,r9
800025dc:	c1 b1       	brne	80002612 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025de:	49 6c       	lddpc	r12,80002634 <mic_reply_func+0x78>
800025e0:	f0 1f 00 14 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025e4:	0f a8       	ld.ub	r8,r7[0x2]
800025e6:	1a d8       	st.w	--sp,r8
800025e8:	49 4c       	lddpc	r12,80002638 <mic_reply_func+0x7c>
800025ea:	f0 1f 00 12 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025ee:	0f b8       	ld.ub	r8,r7[0x3]
800025f0:	1a d8       	st.w	--sp,r8
800025f2:	49 3c       	lddpc	r12,8000263c <mic_reply_func+0x80>
800025f4:	f0 1f 00 0f 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025f8:	0f c8       	ld.ub	r8,r7[0x4]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 1c       	lddpc	r12,80002640 <mic_reply_func+0x84>
800025fe:	f0 1f 00 0d 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002602:	0f d8       	ld.ub	r8,r7[0x5]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 0c       	lddpc	r12,80002644 <mic_reply_func+0x88>
80002608:	f0 1f 00 0a 	mcall	80002630 <mic_reply_func+0x74>
8000260c:	2f cd       	sub	sp,-16
8000260e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002612:	1a d8       	st.w	--sp,r8
80002614:	48 dc       	lddpc	r12,80002648 <mic_reply_func+0x8c>
80002616:	f0 1f 00 07 	mcall	80002630 <mic_reply_func+0x74>
8000261a:	2f fd       	sub	sp,-4
8000261c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002620:	48 bc       	lddpc	r12,8000264c <mic_reply_func+0x90>
80002622:	f0 1f 00 04 	mcall	80002630 <mic_reply_func+0x74>
80002626:	e3 cd 80 80 	ldm	sp++,r7,pc
8000262a:	00 00       	add	r0,r0
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	e4 ac       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	7f 64       	ld.w	r4,pc[0x58]
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	e4 bc       	*unknown*
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	e4 d0 80 00 	satsub.w	r0,r2,-32768
8000263e:	e4 e4 80 00 	ld.d	r4,r2[-32768]
80002642:	e5 00 80 00 	ld.sh	r0,r2[-32768]
80002646:	e5 18 80 00 	ld.uh	r8,r2[-32768]
8000264a:	e5 30 80 00 	ld.ub	r0,r2[-32768]
8000264e:	e5 48 eb cd 	st.w	r2[-5171],r8

80002650 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002658:	48 bc       	lddpc	r12,80002684 <dcm_brdcst_func+0x34>
8000265a:	f0 1f 00 0c 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000265e:	0f 88       	ld.ub	r8,r7[0x0]
80002660:	1a d8       	st.w	--sp,r8
80002662:	48 bc       	lddpc	r12,8000268c <dcm_brdcst_func+0x3c>
80002664:	f0 1f 00 09 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002668:	0f a8       	ld.ub	r8,r7[0x2]
8000266a:	1a d8       	st.w	--sp,r8
8000266c:	48 9c       	lddpc	r12,80002690 <dcm_brdcst_func+0x40>
8000266e:	f0 1f 00 07 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002672:	0f 98       	ld.ub	r8,r7[0x1]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 8c       	lddpc	r12,80002694 <dcm_brdcst_func+0x44>
80002678:	f0 1f 00 04 	mcall	80002688 <dcm_brdcst_func+0x38>
8000267c:	2f dd       	sub	sp,-12
	
	
}
8000267e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002682:	00 00       	add	r0,r0
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	e5 58 80 00 	st.h	r2[-32768],r8
8000268a:	7f 64       	ld.w	r4,pc[0x58]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	e5 6c 80 00 	st.b	r2[-32768],r12
80002692:	e5 80       	*unknown*
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	e5 98       	*unknown*

80002698 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002698:	eb cd 40 80 	pushm	r7,lr
8000269c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000269e:	19 a9       	ld.ub	r9,r12[0x2]
800026a0:	30 08       	mov	r8,0
800026a2:	f0 09 18 00 	cp.b	r9,r8
800026a6:	c1 b1       	brne	800026dc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026a8:	19 b8       	ld.ub	r8,r12[0x3]
800026aa:	30 19       	mov	r9,1
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c0 51       	brne	800026ba <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026b2:	48 ec       	lddpc	r12,800026e8 <dcm_reply_func+0x50>
800026b4:	f0 1f 00 0e 	mcall	800026ec <dcm_reply_func+0x54>
800026b8:	c0 a8       	rjmp	800026cc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ba:	58 08       	cp.w	r8,0
800026bc:	c0 51       	brne	800026c6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026be:	48 dc       	lddpc	r12,800026f0 <dcm_reply_func+0x58>
800026c0:	f0 1f 00 0b 	mcall	800026ec <dcm_reply_func+0x54>
800026c4:	c0 48       	rjmp	800026cc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026c6:	48 cc       	lddpc	r12,800026f4 <dcm_reply_func+0x5c>
800026c8:	f0 1f 00 09 	mcall	800026ec <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026cc:	0f d8       	ld.ub	r8,r7[0x5]
800026ce:	1a d8       	st.w	--sp,r8
800026d0:	48 ac       	lddpc	r12,800026f8 <dcm_reply_func+0x60>
800026d2:	f0 1f 00 07 	mcall	800026ec <dcm_reply_func+0x54>
800026d6:	2f fd       	sub	sp,-4
800026d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026dc:	48 8c       	lddpc	r12,800026fc <dcm_reply_func+0x64>
800026de:	f0 1f 00 04 	mcall	800026ec <dcm_reply_func+0x54>
800026e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e6:	00 00       	add	r0,r0
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	e5 b4       	*unknown*
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	7f 64       	ld.w	r4,pc[0x58]
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	e5 c8 80 00 	ldmts	r8,pc
800026f6:	e5 dc 80 00 	ldswp.w	r12,r2[0]
800026fa:	e5 f0 80 00 	ld.wls	r0,r2[0x0]
800026fe:	e5 fc d4 01 	ld.shvc	r12,r2[0x2]

80002700 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002700:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002702:	19 a9       	ld.ub	r9,r12[0x2]
80002704:	30 08       	mov	r8,0
80002706:	f0 09 18 00 	cp.b	r9,r8
8000270a:	c0 51       	brne	80002714 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000270c:	48 4c       	lddpc	r12,8000271c <ToneControl_reply_func+0x1c>
8000270e:	f0 1f 00 05 	mcall	80002720 <ToneControl_reply_func+0x20>
80002712:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002714:	48 4c       	lddpc	r12,80002724 <ToneControl_reply_func+0x24>
80002716:	f0 1f 00 03 	mcall	80002720 <ToneControl_reply_func+0x20>
8000271a:	d8 02       	popm	pc
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	e6 08       	*unknown*
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	7f 64       	ld.w	r4,pc[0x58]
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	e6 14 eb cd 	andh	r4,0xebcd,COH

80002728 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002728:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
8000272c:	49 7c       	lddpc	r12,80002788 <app_init+0x60>
8000272e:	f0 1f 00 18 	mcall	8000278c <app_init+0x64>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002732:	49 8b       	lddpc	r11,80002790 <app_init+0x68>
80002734:	49 8c       	lddpc	r12,80002794 <app_init+0x6c>
80002736:	f0 1f 00 19 	mcall	80002798 <app_init+0x70>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
8000273a:	f0 1f 00 19 	mcall	8000279c <app_init+0x74>
8000273e:	49 98       	lddpc	r8,800027a0 <app_init+0x78>
80002740:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
80002742:	70 08       	ld.w	r8,r8[0x0]
80002744:	58 08       	cp.w	r8,0
80002746:	c0 41       	brne	8000274e <app_init+0x26>
	{
		log("Create the count_mutex semaphore failure\n");
80002748:	49 7c       	lddpc	r12,800027a4 <app_init+0x7c>
8000274a:	f0 1f 00 18 	mcall	800027a8 <app_init+0x80>
	}
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000274e:	30 07       	mov	r7,0
80002750:	1a d7       	st.w	--sp,r7
80002752:	1a d7       	st.w	--sp,r7
80002754:	1a d7       	st.w	--sp,r7
80002756:	30 28       	mov	r8,2
80002758:	0e 99       	mov	r9,r7
8000275a:	e0 6a 02 ee 	mov	r10,750
8000275e:	49 4b       	lddpc	r11,800027ac <app_init+0x84>
80002760:	49 4c       	lddpc	r12,800027b0 <app_init+0x88>
80002762:	f0 1f 00 15 	mcall	800027b4 <app_init+0x8c>
80002766:	49 56       	lddpc	r6,800027b8 <app_init+0x90>
80002768:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  2
	,  NULL );
	
	 res = xTaskCreate(
8000276a:	1a d7       	st.w	--sp,r7
8000276c:	1a d7       	st.w	--sp,r7
8000276e:	1a d7       	st.w	--sp,r7
80002770:	30 18       	mov	r8,1
80002772:	0e 99       	mov	r9,r7
80002774:	e0 6a 03 20 	mov	r10,800
80002778:	49 1b       	lddpc	r11,800027bc <app_init+0x94>
8000277a:	49 2c       	lddpc	r12,800027c0 <app_init+0x98>
8000277c:	f0 1f 00 0e 	mcall	800027b4 <app_init+0x8c>
80002780:	8d 0c       	st.w	r6[0x0],r12
80002782:	2f ad       	sub	sp,-24
	 ,  800
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
80002784:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002788:	00 00       	add	r0,r0
8000278a:	00 10       	sub	r0,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	48 1c       	lddpc	r12,80002790 <app_init+0x68>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 3c       	sub	r12,3
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 50       	sub	r0,5
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	34 c4       	mov	r4,76
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	74 2c       	ld.w	r12,r10[0x8]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 78       	tst	r8,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	e6 20 80 00 	sub	r0,425984
800027aa:	7f 64       	ld.w	r4,pc[0x58]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	e6 4c 80 00 	cp.w	r12,425984
800027b2:	29 10       	sub	r0,-111
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	7b a0       	ld.w	r0,sp[0x68]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 58       	eor	r8,r5
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	e6 54 80 00 	cp.w	r4,491520
800027c2:	27 c4       	sub	r4,124

800027c4 <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027c4:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c6:	32 0c       	mov	r12,32
800027c8:	f0 1f 00 3a 	mcall	800028b0 <send_message+0xec>
800027cc:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 3a 	mcall	800028b4 <send_message+0xf0>
800027d2:	4b a8       	lddpc	r8,800028b8 <send_message+0xf4>
800027d4:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
	/*clear xBinarySemaphore and wait Datasession broadcast reply*/
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
800027d6:	4b a8       	lddpc	r8,800028bc <send_message+0xf8>
800027d8:	70 0c       	ld.w	r12,r8[0x0]
800027da:	30 09       	mov	r9,0
800027dc:	3f fa       	mov	r10,-1
800027de:	12 9b       	mov	r11,r9
800027e0:	f0 1f 00 38 	mcall	800028c0 <send_message+0xfc>
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027e4:	4b 85       	lddpc	r5,800028c4 <send_message+0x100>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800027e6:	4b 97       	lddpc	r7,800028c8 <send_message+0x104>
800027e8:	30 16       	mov	r6,1
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027ea:	4b 93       	lddpc	r3,800028cc <send_message+0x108>
		{
			log("Current_total_message_count: %d\n", message_count);
800027ec:	4b 90       	lddpc	r0,800028d0 <send_message+0x10c>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
800027ee:	30 12       	mov	r2,1
800027f0:	4b 91       	lddpc	r1,800028d4 <send_message+0x110>
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027f2:	f0 1f 00 3a 	mcall	800028d8 <send_message+0x114>
800027f6:	5c 8c       	casts.h	r12
800027f8:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027fa:	c4 c0       	breq	80002892 <send_message+0xce>
800027fc:	0f 88       	ld.ub	r8,r7[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c4 91       	brne	80002892 <send_message+0xce>
80002802:	07 88       	ld.ub	r8,r3[0x0]
80002804:	58 08       	cp.w	r8,0
80002806:	c4 60       	breq	80002892 <send_message+0xce>
		{
			log("Current_total_message_count: %d\n", message_count);
80002808:	5c 7c       	castu.h	r12
8000280a:	1a dc       	st.w	--sp,r12
8000280c:	00 9c       	mov	r12,r0
8000280e:	f0 1f 00 34 	mcall	800028dc <send_message+0x118>
			if(m_buff==NULL)break;
80002812:	2f fd       	sub	sp,-4
80002814:	58 04       	cp.w	r4,0
80002816:	c4 b0       	breq	800028ac <send_message+0xe8>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
80002818:	04 9a       	mov	r10,r2
8000281a:	08 9b       	mov	r11,r4
8000281c:	8a 8c       	ld.uh	r12,r5[0x0]
8000281e:	f0 1f 00 31 	mcall	800028e0 <send_message+0x11c>
80002822:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
80002824:	c3 11       	brne	80002886 <send_message+0xc2>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
80002826:	36 4a       	mov	r10,100
80002828:	32 0b       	mov	r11,32
8000282a:	08 9c       	mov	r12,r4
8000282c:	f0 1f 00 2e 	mcall	800028e4 <send_message+0x120>
				
				//if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
				if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
80002830:	4a 38       	lddpc	r8,800028bc <send_message+0xf8>
80002832:	70 0c       	ld.w	r12,r8[0x0]
80002834:	30 09       	mov	r9,0
80002836:	e0 6a 9c 40 	mov	r10,40000
8000283a:	12 9b       	mov	r11,r9
8000283c:	f0 1f 00 21 	mcall	800028c0 <send_message+0xfc>
80002840:	58 1c       	cp.w	r12,1
80002842:	c0 91       	brne	80002854 <send_message+0x90>
				{
					log("xSemaphoreTake okay!\n");
80002844:	4a 9c       	lddpc	r12,800028e8 <send_message+0x124>
80002846:	f0 1f 00 26 	mcall	800028dc <send_message+0x118>
					vTaskDelay((2000*2) / portTICK_RATE_MS);
8000284a:	e0 6c 0f a0 	mov	r12,4000
8000284e:	f0 1f 00 28 	mcall	800028ec <send_message+0x128>
80002852:	c2 78       	rjmp	800028a0 <send_message+0xdc>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002854:	4a 7c       	lddpc	r12,800028f0 <send_message+0x12c>
80002856:	f0 1f 00 22 	mcall	800028dc <send_message+0x118>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
8000285a:	e0 6b 00 b7 	mov	r11,183
8000285e:	04 9c       	mov	r12,r2
80002860:	f0 1f 00 25 	mcall	800028f4 <send_message+0x130>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002864:	04 9a       	mov	r10,r2
80002866:	32 0b       	mov	r11,32
80002868:	08 9c       	mov	r12,r4
8000286a:	f0 1f 00 24 	mcall	800028f8 <send_message+0x134>
8000286e:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
80002870:	c0 51       	brne	8000287a <send_message+0xb6>
					{
						log("save message-2 okay\n");
80002872:	4a 3c       	lddpc	r12,800028fc <send_message+0x138>
80002874:	f0 1f 00 1a 	mcall	800028dc <send_message+0x118>
80002878:	c1 48       	rjmp	800028a0 <send_message+0xdc>
					}
					else
					{
						log("!!!save message err : %d\n", status);
8000287a:	1a dc       	st.w	--sp,r12
8000287c:	4a 1c       	lddpc	r12,80002900 <send_message+0x13c>
8000287e:	f0 1f 00 18 	mcall	800028dc <send_message+0x118>
80002882:	2f fd       	sub	sp,-4
80002884:	c0 e8       	rjmp	800028a0 <send_message+0xdc>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
80002886:	1a dc       	st.w	--sp,r12
80002888:	49 fc       	lddpc	r12,80002904 <send_message+0x140>
8000288a:	f0 1f 00 15 	mcall	800028dc <send_message+0x118>
8000288e:	2f fd       	sub	sp,-4
80002890:	c0 88       	rjmp	800028a0 <send_message+0xdc>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002892:	0f 88       	ld.ub	r8,r7[0x0]
80002894:	ec 08 18 00 	cp.b	r8,r6
80002898:	c0 41       	brne	800028a0 <send_message+0xdc>
		{
			log("The device battery level is low !\n");
8000289a:	49 cc       	lddpc	r12,80002908 <send_message+0x144>
8000289c:	f0 1f 00 10 	mcall	800028dc <send_message+0x118>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil(&xLastWakeTime, (5000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028a0:	e0 6b 27 10 	mov	r11,10000
800028a4:	48 5c       	lddpc	r12,800028b8 <send_message+0xf4>
800028a6:	f0 1f 00 1a 	mcall	8000290c <send_message+0x148>
	
	}
800028aa:	ca 4b       	rjmp	800027f2 <send_message+0x2e>
800028ac:	d8 32       	popm	r0-r7,pc
800028ae:	00 00       	add	r0,r0
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	6f d8       	ld.w	r8,r7[0x74]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	78 90       	ld.w	r0,r12[0x24]
800028b8:	00 00       	add	r0,r0
800028ba:	0a 64       	and	r4,r5
800028bc:	00 00       	add	r0,r0
800028be:	0b a0       	ld.ub	r0,r5[0x2]
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	71 20       	ld.w	r0,r8[0x48]
800028c4:	00 00       	add	r0,r0
800028c6:	0a 62       	and	r2,r5
800028c8:	00 00       	add	r0,r0
800028ca:	0a 84       	andn	r4,r5
800028cc:	00 00       	add	r0,r0
800028ce:	0a 5e       	eor	lr,r5
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	e6 5c 00 00 	cp.w	r12,458752
800028d6:	00 0c       	add	r12,r0
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	62 9c       	ld.w	r12,r1[0x24]
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	7f 64       	ld.w	r4,pc[0x58]
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	5f bc       	srhi	r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	48 70       	lddpc	r0,80002900 <send_message+0x13c>
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	e6 80 80 00 	breq	800d28ea <_data_lma+0xc32c2>
800028ee:	79 f8       	ld.w	r8,r12[0x7c]
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	e6 98 80 00 	brls	800f28f2 <_data_lma+0xe32ca>
800028f6:	49 ac       	lddpc	r12,8000295c <app_cfg+0x4c>
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	61 0c       	ld.w	r12,r0[0x40]
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	e6 b4       	*unknown*
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	e6 cc 80 00 	sub	r12,r3,-32768
80002906:	e6 e8 80 00 	ld.d	r8,r3[-32768]
8000290a:	e7 00 80 00 	ld.sh	r0,r3[-32768]
8000290e:	7a 40       	ld.w	r0,sp[0x10]

80002910 <app_cfg>:
}

static __app_Thread_(app_cfg)
{
80002910:	d4 31       	pushm	r0-r7,lr
80002912:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
80002914:	f0 1f 00 4d 	mcall	80002a48 <app_cfg+0x138>
80002918:	4c d8       	lddpc	r8,80002a4c <app_cfg+0x13c>
8000291a:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
8000291c:	4c d7       	lddpc	r7,80002a50 <app_cfg+0x140>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000291e:	4c e3       	lddpc	r3,80002a54 <app_cfg+0x144>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002920:	32 00       	mov	r0,32
80002922:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
80002924:	4c d2       	lddpc	r2,80002a58 <app_cfg+0x148>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002926:	6e 08       	ld.w	r8,r7[0x0]
80002928:	58 28       	cp.w	r8,2
8000292a:	c3 90       	breq	8000299c <app_cfg+0x8c>
8000292c:	58 38       	cp.w	r8,3
8000292e:	c4 60       	breq	800029ba <app_cfg+0xaa>
80002930:	58 08       	cp.w	r8,0
80002932:	e0 81 00 85 	brne	80002a3c <app_cfg+0x12c>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002936:	4c a8       	lddpc	r8,80002a5c <app_cfg+0x14c>
80002938:	70 08       	ld.w	r8,r8[0x0]
8000293a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000293e:	58 38       	cp.w	r8,3
80002940:	c1 61       	brne	8000296c <app_cfg+0x5c>
80002942:	4c 88       	lddpc	r8,80002a60 <app_cfg+0x150>
80002944:	11 88       	ld.ub	r8,r8[0x0]
80002946:	58 08       	cp.w	r8,0
80002948:	c1 21       	brne	8000296c <app_cfg+0x5c>
				{
					connect_flag=1;
8000294a:	30 19       	mov	r9,1
8000294c:	4c 58       	lddpc	r8,80002a60 <app_cfg+0x150>
8000294e:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002950:	30 cb       	mov	r11,12
80002952:	30 1c       	mov	r12,1
80002954:	f0 1f 00 44 	mcall	80002a64 <app_cfg+0x154>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002958:	30 cb       	mov	r11,12
8000295a:	30 1c       	mov	r12,1
8000295c:	f0 1f 00 42 	mcall	80002a64 <app_cfg+0x154>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002960:	30 28       	mov	r8,2
80002962:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002964:	4c 1c       	lddpc	r12,80002a68 <app_cfg+0x158>
80002966:	f0 1f 00 42 	mcall	80002a6c <app_cfg+0x15c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000296a:	c6 98       	rjmp	80002a3c <app_cfg+0x12c>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
8000296c:	d7 03       	nop
					nop();
8000296e:	d7 03       	nop
					nop();
80002970:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002972:	4c 0c       	lddpc	r12,80002a70 <app_cfg+0x160>
80002974:	f0 1f 00 3e 	mcall	80002a6c <app_cfg+0x15c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002978:	4b f8       	lddpc	r8,80002a74 <app_cfg+0x164>
8000297a:	11 d5       	ld.ub	r5,r8[0x5]
8000297c:	11 cc       	ld.ub	r12,r8[0x4]
8000297e:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
80002980:	11 aa       	ld.ub	r10,r8[0x2]
80002982:	11 99       	ld.ub	r9,r8[0x1]
80002984:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002986:	1a d5       	st.w	--sp,r5
80002988:	1a dc       	st.w	--sp,r12
8000298a:	1a db       	st.w	--sp,r11
8000298c:	1a da       	st.w	--sp,r10
8000298e:	1a d9       	st.w	--sp,r9
80002990:	1a d8       	st.w	--sp,r8
80002992:	4b ac       	lddpc	r12,80002a78 <app_cfg+0x168>
80002994:	f0 1f 00 36 	mcall	80002a6c <app_cfg+0x15c>
80002998:	2f ad       	sub	sp,-24
8000299a:	c5 18       	rjmp	80002a3c <app_cfg+0x12c>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000299c:	07 88       	ld.ub	r8,r3[0x0]
8000299e:	58 08       	cp.w	r8,0
800029a0:	c0 70       	breq	800029ae <app_cfg+0x9e>
							
							OB_State = OB_WAITINGAPPTASK;
800029a2:	30 38       	mov	r8,3
800029a4:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
800029a6:	4b 6c       	lddpc	r12,80002a7c <app_cfg+0x16c>
800029a8:	f0 1f 00 31 	mcall	80002a6c <app_cfg+0x15c>
800029ac:	c4 88       	rjmp	80002a3c <app_cfg+0x12c>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800029ae:	36 4a       	mov	r10,100
800029b0:	00 9b       	mov	r11,r0
800029b2:	0c 9c       	mov	r12,r6
800029b4:	f0 1f 00 33 	mcall	80002a80 <app_cfg+0x170>
800029b8:	c4 28       	rjmp	80002a3c <app_cfg+0x12c>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
800029ba:	64 0c       	ld.w	r12,r2[0x0]
800029bc:	0c 99       	mov	r9,r6
800029be:	0c 9a       	mov	r10,r6
800029c0:	1a 9b       	mov	r11,sp
800029c2:	f0 1f 00 31 	mcall	80002a84 <app_cfg+0x174>
800029c6:	58 1c       	cp.w	r12,1
800029c8:	c3 61       	brne	80002a34 <app_cfg+0x124>
					{
						if(data_ptr!=NULL){//save message
800029ca:	40 08       	lddsp	r8,sp[0x0]
800029cc:	58 08       	cp.w	r8,0
800029ce:	c3 70       	breq	80002a3c <app_cfg+0x12c>
							
							log("receive okay!\n");
800029d0:	4a ec       	lddpc	r12,80002a88 <app_cfg+0x178>
800029d2:	f0 1f 00 27 	mcall	80002a6c <app_cfg+0x15c>
							xSemaphoreTake(count_mutex, portMAX_DELAY);
800029d6:	4a e4       	lddpc	r4,80002a8c <app_cfg+0x17c>
800029d8:	68 0c       	ld.w	r12,r4[0x0]
800029da:	0c 99       	mov	r9,r6
800029dc:	3f fa       	mov	r10,-1
800029de:	0c 9b       	mov	r11,r6
800029e0:	f0 1f 00 29 	mcall	80002a84 <app_cfg+0x174>
							global_count--;
800029e4:	4a b5       	lddpc	r5,80002a90 <app_cfg+0x180>
800029e6:	6a 08       	ld.w	r8,r5[0x0]
800029e8:	20 18       	sub	r8,1
800029ea:	8b 08       	st.w	r5[0x0],r8
							xSemaphoreGive(count_mutex);
800029ec:	68 0c       	ld.w	r12,r4[0x0]
800029ee:	0c 99       	mov	r9,r6
800029f0:	0c 9a       	mov	r10,r6
800029f2:	0c 9b       	mov	r11,r6
800029f4:	f0 1f 00 28 	mcall	80002a94 <app_cfg+0x184>
							log("global_count:%d\n", global_count);
800029f8:	6a 08       	ld.w	r8,r5[0x0]
800029fa:	1a d8       	st.w	--sp,r8
800029fc:	4a 7c       	lddpc	r12,80002a98 <app_cfg+0x188>
800029fe:	f0 1f 00 1c 	mcall	80002a6c <app_cfg+0x15c>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
80002a02:	30 1a       	mov	r10,1
80002a04:	00 9b       	mov	r11,r0
80002a06:	40 1c       	lddsp	r12,sp[0x4]
80002a08:	f0 1f 00 25 	mcall	80002a9c <app_cfg+0x18c>
80002a0c:	4a 58       	lddpc	r8,80002aa0 <app_cfg+0x190>
80002a0e:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
80002a10:	2f fd       	sub	sp,-4
80002a12:	58 0c       	cp.w	r12,0
80002a14:	c0 51       	brne	80002a1e <app_cfg+0x10e>
							{
								log("save message okay\n");
80002a16:	4a 4c       	lddpc	r12,80002aa4 <app_cfg+0x194>
80002a18:	f0 1f 00 15 	mcall	80002a6c <app_cfg+0x15c>
80002a1c:	c0 68       	rjmp	80002a28 <app_cfg+0x118>
							}
							else
							{
								log("!!! save message err : %d\n", status);
80002a1e:	1a dc       	st.w	--sp,r12
80002a20:	4a 2c       	lddpc	r12,80002aa8 <app_cfg+0x198>
80002a22:	f0 1f 00 13 	mcall	80002a6c <app_cfg+0x15c>
80002a26:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
80002a28:	4a 18       	lddpc	r8,80002aac <app_cfg+0x19c>
80002a2a:	70 0c       	ld.w	r12,r8[0x0]
80002a2c:	40 0b       	lddsp	r11,sp[0x0]
80002a2e:	f0 1f 00 21 	mcall	80002ab0 <app_cfg+0x1a0>
80002a32:	c0 58       	rjmp	80002a3c <app_cfg+0x12c>
						
					}
					else
					{						
											
						nop();
80002a34:	d7 03       	nop
						//water_value = uxTaskGetStackHighWaterMark(NULL);
						//log("app-thread water_value: %d\n", water_value);
						log("app task run!\n");
80002a36:	4a 0c       	lddpc	r12,80002ab4 <app_cfg+0x1a4>
80002a38:	f0 1f 00 0d 	mcall	80002a6c <app_cfg+0x15c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (1200*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002a3c:	e0 6b 09 60 	mov	r11,2400
80002a40:	48 3c       	lddpc	r12,80002a4c <app_cfg+0x13c>
80002a42:	f0 1f 00 1e 	mcall	80002ab8 <app_cfg+0x1a8>
	}
80002a46:	c7 0b       	rjmp	80002926 <app_cfg+0x16>
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	78 90       	ld.w	r0,r12[0x24]
80002a4c:	00 00       	add	r0,r0
80002a4e:	0a 68       	and	r8,r5
80002a50:	00 00       	add	r0,r0
80002a52:	0a 6c       	and	r12,r5
80002a54:	00 00       	add	r0,r0
80002a56:	00 08       	add	r8,r0
80002a58:	00 00       	add	r0,r0
80002a5a:	0b 90       	ld.ub	r0,r5[0x1]
80002a5c:	00 00       	add	r0,r0
80002a5e:	0e 1c       	sub	r12,r7
80002a60:	00 00       	add	r0,r0
80002a62:	0a 5e       	eor	lr,r5
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	49 ac       	lddpc	r12,80002acc <Phyuserinput_brdcst_func+0x10>
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	e7 24 80 00 	ld.sb	r4,r3[-32768]
80002a6e:	7f 64       	ld.w	r4,pc[0x58]
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	e7 38 00 00 	ld.ub	r8,r3[0]
80002a76:	0e 20       	rsub	r0,r7
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	e7 48 80 00 	st.w	r3[-32768],r8
80002a7e:	e7 74 80 00 	stcond	r3[-32768],r4
80002a82:	48 70       	lddpc	r0,80002a9c <app_cfg+0x18c>
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	71 20       	ld.w	r0,r8[0x48]
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	e7 84       	*unknown*
80002a8c:	00 00       	add	r0,r0
80002a8e:	0a 78       	tst	r8,r5
80002a90:	00 00       	add	r0,r0
80002a92:	0a 80       	andn	r0,r5
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	73 2c       	ld.w	r12,r9[0x48]
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	e7 94       	*unknown*
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	61 0c       	ld.w	r12,r0[0x40]
80002aa0:	00 00       	add	r0,r0
80002aa2:	00 04       	add	r4,r0
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	e7 a8 80 00 	cop	cp4,cr0,cr0,cr0,0x70
80002aaa:	e7 bc 00 00 	mtdr	0x0,r12
80002aae:	0b 9c       	ld.ub	r12,r5[0x1]
80002ab0:	80 00       	ld.sh	r0,r0[0x0]
80002ab2:	35 44       	mov	r4,84
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	e7 d8 80 00 	ldswp.w	r8,r3[0]
80002aba:	7a 40       	ld.w	r0,sp[0x10]

80002abc <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002abc:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002ac0:	19 c7       	ld.ub	r7,r12[0x4]
80002ac2:	19 d8       	ld.ub	r8,r12[0x5]
80002ac4:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002ac8:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002aca:	48 dc       	lddpc	r12,80002afc <Phyuserinput_brdcst_func+0x40>
80002acc:	f0 1f 00 0d 	mcall	80002b00 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002ad0:	36 08       	mov	r8,96
80002ad2:	f0 07 19 00 	cp.h	r7,r8
80002ad6:	c1 11       	brne	80002af8 <Phyuserinput_brdcst_func+0x3c>
80002ad8:	48 b8       	lddpc	r8,80002b04 <Phyuserinput_brdcst_func+0x48>
80002ada:	11 89       	ld.ub	r9,r8[0x0]
80002adc:	30 18       	mov	r8,1
80002ade:	f0 09 18 00 	cp.b	r9,r8
80002ae2:	c0 b1       	brne	80002af8 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002ae4:	34 5b       	mov	r11,69
80002ae6:	30 1c       	mov	r12,1
80002ae8:	f0 1f 00 08 	mcall	80002b08 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002aec:	e0 6c 07 d0 	mov	r12,2000
80002af0:	f0 1f 00 07 	mcall	80002b0c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002af4:	f0 1f 00 07 	mcall	80002b10 <Phyuserinput_brdcst_func+0x54>
80002af8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	e7 e8 80 00 	sthh.w	r0[r0],r3:b,r8:b
80002b02:	7f 64       	ld.w	r4,pc[0x58]
80002b04:	00 00       	add	r0,r0
80002b06:	0a 5e       	eor	lr,r5
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	49 ac       	lddpc	r12,80002b70 <DataSession_brdcst_func+0x5c>
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	79 f8       	ld.w	r8,r12[0x7c]
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	59 ec       	cp.w	r12,30

80002b14 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b14:	d4 21       	pushm	r4-r7,lr
80002b16:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002b18:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002b1c:	0d 88       	ld.ub	r8,r6[0x0]
80002b1e:	32 49       	mov	r9,36
80002b20:	f2 08 18 00 	cp.b	r8,r9
80002b24:	c2 a1       	brne	80002b78 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002b26:	4c fc       	lddpc	r12,80002c60 <DataSession_brdcst_func+0x14c>
80002b28:	f0 1f 00 4f 	mcall	80002c64 <DataSession_brdcst_func+0x150>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002b2c:	0d a5       	ld.ub	r5,r6[0x2]
80002b2e:	0d b8       	ld.ub	r8,r6[0x3]
80002b30:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002b34:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002b36:	0d 98       	ld.ub	r8,r6[0x1]
80002b38:	1a d8       	st.w	--sp,r8
80002b3a:	4c cc       	lddpc	r12,80002c68 <DataSession_brdcst_func+0x154>
80002b3c:	f0 1f 00 4a 	mcall	80002c64 <DataSession_brdcst_func+0x150>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002b40:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002b44:	1a d8       	st.w	--sp,r8
80002b46:	4c ac       	lddpc	r12,80002c6c <DataSession_brdcst_func+0x158>
80002b48:	f0 1f 00 47 	mcall	80002c64 <DataSession_brdcst_func+0x150>
		for(i=0; i<data_length; i++)
80002b4c:	2f ed       	sub	sp,-8
80002b4e:	58 05       	cp.w	r5,0
80002b50:	e0 80 00 85 	breq	80002c5a <DataSession_brdcst_func+0x146>
80002b54:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002b56:	4c 74       	lddpc	r4,80002c70 <DataSession_brdcst_func+0x15c>
80002b58:	ec 07 00 08 	add	r8,r6,r7
80002b5c:	11 c8       	ld.ub	r8,r8[0x4]
80002b5e:	1a d8       	st.w	--sp,r8
80002b60:	1a d7       	st.w	--sp,r7
80002b62:	08 9c       	mov	r12,r4
80002b64:	f0 1f 00 40 	mcall	80002c64 <DataSession_brdcst_func+0x150>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002b68:	2f f7       	sub	r7,-1
80002b6a:	5c 57       	castu.b	r7
80002b6c:	2f ed       	sub	sp,-8
80002b6e:	ee 05 19 00 	cp.h	r5,r7
80002b72:	fe 9b ff f3 	brhi	80002b58 <DataSession_brdcst_func+0x44>
80002b76:	c7 28       	rjmp	80002c5a <DataSession_brdcst_func+0x146>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002b78:	1a d8       	st.w	--sp,r8
80002b7a:	4b fc       	lddpc	r12,80002c74 <DataSession_brdcst_func+0x160>
80002b7c:	f0 1f 00 3a 	mcall	80002c64 <DataSession_brdcst_func+0x150>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002b80:	0d 88       	ld.ub	r8,r6[0x0]
80002b82:	2f fd       	sub	sp,-4
80002b84:	30 39       	mov	r9,3
80002b86:	f2 08 18 00 	cp.b	r8,r9
80002b8a:	c0 d1       	brne	80002ba4 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002b8c:	4b bc       	lddpc	r12,80002c78 <DataSession_brdcst_func+0x164>
80002b8e:	f0 1f 00 36 	mcall	80002c64 <DataSession_brdcst_func+0x150>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b92:	e0 6c 07 d0 	mov	r12,2000
80002b96:	f0 1f 00 3a 	mcall	80002c7c <DataSession_brdcst_func+0x168>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002b9a:	37 7b       	mov	r11,119
80002b9c:	30 1c       	mov	r12,1
80002b9e:	f0 1f 00 39 	mcall	80002c80 <DataSession_brdcst_func+0x16c>
80002ba2:	c4 98       	rjmp	80002c34 <DataSession_brdcst_func+0x120>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002ba4:	30 49       	mov	r9,4
80002ba6:	f2 08 18 00 	cp.b	r8,r9
80002baa:	c4 51       	brne	80002c34 <DataSession_brdcst_func+0x120>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002bac:	32 0a       	mov	r10,32
80002bae:	ec cb ff fc 	sub	r11,r6,-4
80002bb2:	1a 9c       	mov	r12,sp
80002bb4:	f0 1f 00 34 	mcall	80002c84 <DataSession_brdcst_func+0x170>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002bb8:	4b 48       	lddpc	r8,80002c88 <DataSession_brdcst_func+0x174>
80002bba:	70 0c       	ld.w	r12,r8[0x0]
80002bbc:	f0 1f 00 34 	mcall	80002c8c <DataSession_brdcst_func+0x178>
80002bc0:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002bc2:	c3 10       	breq	80002c24 <DataSession_brdcst_func+0x110>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002bc4:	32 0a       	mov	r10,32
80002bc6:	1a 9b       	mov	r11,sp
80002bc8:	f0 1f 00 2f 	mcall	80002c84 <DataSession_brdcst_func+0x170>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002bcc:	4b 18       	lddpc	r8,80002c90 <DataSession_brdcst_func+0x17c>
80002bce:	70 0c       	ld.w	r12,r8[0x0]
80002bd0:	30 09       	mov	r9,0
80002bd2:	12 9a       	mov	r10,r9
80002bd4:	fa cb ff e0 	sub	r11,sp,-32
80002bd8:	f0 1f 00 2f 	mcall	80002c94 <DataSession_brdcst_func+0x180>
80002bdc:	58 1c       	cp.w	r12,1
80002bde:	c1 10       	breq	80002c00 <DataSession_brdcst_func+0xec>
				{
					log("xg_resend_queue: full\n" );
80002be0:	4a ec       	lddpc	r12,80002c98 <DataSession_brdcst_func+0x184>
80002be2:	f0 1f 00 21 	mcall	80002c64 <DataSession_brdcst_func+0x150>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002be6:	32 3b       	mov	r11,35
80002be8:	30 1c       	mov	r12,1
80002bea:	f0 1f 00 26 	mcall	80002c80 <DataSession_brdcst_func+0x16c>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002bee:	e0 6c 17 70 	mov	r12,6000
80002bf2:	f0 1f 00 23 	mcall	80002c7c <DataSession_brdcst_func+0x168>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002bf6:	32 3b       	mov	r11,35
80002bf8:	30 0c       	mov	r12,0
80002bfa:	f0 1f 00 22 	mcall	80002c80 <DataSession_brdcst_func+0x16c>
80002bfe:	c1 68       	rjmp	80002c2a <DataSession_brdcst_func+0x116>
				}
				else
				{
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002c00:	4a 77       	lddpc	r7,80002c9c <DataSession_brdcst_func+0x188>
80002c02:	6e 0c       	ld.w	r12,r7[0x0]
80002c04:	30 09       	mov	r9,0
80002c06:	3f fa       	mov	r10,-1
80002c08:	12 9b       	mov	r11,r9
80002c0a:	f0 1f 00 26 	mcall	80002ca0 <DataSession_brdcst_func+0x18c>
					global_count++;
80002c0e:	4a 68       	lddpc	r8,80002ca4 <DataSession_brdcst_func+0x190>
80002c10:	70 09       	ld.w	r9,r8[0x0]
80002c12:	2f f9       	sub	r9,-1
80002c14:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002c16:	6e 0c       	ld.w	r12,r7[0x0]
80002c18:	30 09       	mov	r9,0
80002c1a:	12 9a       	mov	r10,r9
80002c1c:	12 9b       	mov	r11,r9
80002c1e:	f0 1f 00 1e 	mcall	80002c94 <DataSession_brdcst_func+0x180>
80002c22:	c0 48       	rjmp	80002c2a <DataSession_brdcst_func+0x116>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002c24:	4a 1c       	lddpc	r12,80002ca8 <DataSession_brdcst_func+0x194>
80002c26:	f0 1f 00 10 	mcall	80002c64 <DataSession_brdcst_func+0x150>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002c2a:	e0 6b 00 b7 	mov	r11,183
80002c2e:	30 1c       	mov	r12,1
80002c30:	f0 1f 00 14 	mcall	80002c80 <DataSession_brdcst_func+0x16c>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002c34:	0d 89       	ld.ub	r9,r6[0x0]
80002c36:	20 39       	sub	r9,3
80002c38:	30 18       	mov	r8,1
80002c3a:	f0 09 18 00 	cp.b	r9,r8
80002c3e:	e0 8b 00 0e 	brhi	80002c5a <DataSession_brdcst_func+0x146>
		{		
			//if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
			if( xSemaphoreGive( xBinarySemaphore ) != pdTRUE )
80002c42:	49 b8       	lddpc	r8,80002cac <DataSession_brdcst_func+0x198>
80002c44:	70 0c       	ld.w	r12,r8[0x0]
80002c46:	30 09       	mov	r9,0
80002c48:	12 9a       	mov	r10,r9
80002c4a:	12 9b       	mov	r11,r9
80002c4c:	f0 1f 00 12 	mcall	80002c94 <DataSession_brdcst_func+0x180>
80002c50:	58 1c       	cp.w	r12,1
80002c52:	c0 40       	breq	80002c5a <DataSession_brdcst_func+0x146>
			{
				log("xSemaphoreGive: err\n\r" );
80002c54:	49 7c       	lddpc	r12,80002cb0 <DataSession_brdcst_func+0x19c>
80002c56:	f0 1f 00 04 	mcall	80002c64 <DataSession_brdcst_func+0x150>
				//
		//}
		
	}
	
}
80002c5a:	2f 7d       	sub	sp,-36
80002c5c:	d8 22       	popm	r4-r7,pc
80002c5e:	00 00       	add	r0,r0
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	e8 08       	*unknown*
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	7f 64       	ld.w	r4,pc[0x58]
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	e8 1c 80 00 	orl	r12,0x8000
80002c6e:	e8 34 80 00 	sub	r4,622592
80002c72:	e8 50 80 00 	cp.w	r0,622592
80002c76:	e8 68 80 00 	mov	r8,557056
80002c7a:	e8 74 80 00 	mov	r4,622592
80002c7e:	79 f8       	ld.w	r8,r12[0x7c]
80002c80:	80 00       	ld.sh	r0,r0[0x0]
80002c82:	49 ac       	lddpc	r12,80002ce8 <DeviceInitializationStatus_brdcst_func+0x34>
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	88 0e       	ld.sh	lr,r4[0x0]
80002c88:	00 00       	add	r0,r0
80002c8a:	0b 9c       	ld.ub	r12,r5[0x1]
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	36 f0       	mov	r0,111
80002c90:	00 00       	add	r0,r0
80002c92:	0b 90       	ld.ub	r0,r5[0x1]
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	73 2c       	ld.w	r12,r9[0x48]
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	e8 8c 00 00 	brvs	80102c9a <_data_lma+0xf3672>
80002c9e:	0a 78       	tst	r8,r5
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	71 20       	ld.w	r0,r8[0x48]
80002ca4:	00 00       	add	r0,r0
80002ca6:	0a 80       	andn	r0,r5
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	e8 a4       	*unknown*
80002cac:	00 00       	add	r0,r0
80002cae:	0b a0       	ld.ub	r0,r5[0x2]
80002cb0:	80 00       	ld.sh	r0,r0[0x0]
80002cb2:	e8 b4       	*unknown*

80002cb4 <DeviceInitializationStatus_brdcst_func>:
volatile xSemaphoreHandle count_mutex = NULL;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002cb4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002cb6:	19 e8       	ld.ub	r8,r12[0x6]
80002cb8:	30 19       	mov	r9,1
80002cba:	f2 08 18 00 	cp.b	r8,r9
80002cbe:	c0 61       	brne	80002cca <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002cc0:	48 98       	lddpc	r8,80002ce4 <DeviceInitializationStatus_brdcst_func+0x30>
80002cc2:	70 09       	ld.w	r9,r8[0x0]
80002cc4:	a1 a9       	sbr	r9,0x0
80002cc6:	91 09       	st.w	r8[0x0],r9
80002cc8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002cca:	30 29       	mov	r9,2
80002ccc:	f2 08 18 00 	cp.b	r8,r9
80002cd0:	c0 80       	breq	80002ce0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002cd2:	48 58       	lddpc	r8,80002ce4 <DeviceInitializationStatus_brdcst_func+0x30>
80002cd4:	70 09       	ld.w	r9,r8[0x0]
80002cd6:	e0 19 ff fc 	andl	r9,0xfffc
80002cda:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002cdc:	f0 1f 00 03 	mcall	80002ce8 <DeviceInitializationStatus_brdcst_func+0x34>
80002ce0:	d8 02       	popm	pc
80002ce2:	00 00       	add	r0,r0
80002ce4:	00 00       	add	r0,r0
80002ce6:	0e 1c       	sub	r12,r7
80002ce8:	80 00       	ld.sh	r0,r0[0x0]
80002cea:	49 00       	lddpc	r0,80002d28 <send_flash_command+0x3c>

80002cec <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002cec:	eb cd 40 fc 	pushm	r2-r7,lr
80002cf0:	20 1d       	sub	sp,4
80002cf2:	18 97       	mov	r7,r12
80002cf4:	14 95       	mov	r5,r10
80002cf6:	12 96       	mov	r6,r9
	U16 status = 1;
80002cf8:	30 18       	mov	r8,1
80002cfa:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002cfc:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002d00:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002d04:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002d08:	30 1b       	mov	r11,1
80002d0a:	4e 58       	lddpc	r8,80002e9c <send_flash_command+0x1b0>
80002d0c:	70 0c       	ld.w	r12,r8[0x0]
80002d0e:	f0 1f 00 65 	mcall	80002ea0 <send_flash_command+0x1b4>

    switch (command)
80002d12:	30 58       	mov	r8,5
80002d14:	f0 07 19 00 	cp.h	r7,r8
80002d18:	c3 40       	breq	80002d80 <send_flash_command+0x94>
80002d1a:	e0 8b 00 18 	brhi	80002d4a <send_flash_command+0x5e>
80002d1e:	30 28       	mov	r8,2
80002d20:	f0 07 19 00 	cp.h	r7,r8
80002d24:	c5 e0       	breq	80002de0 <send_flash_command+0xf4>
80002d26:	e0 8b 00 08 	brhi	80002d36 <send_flash_command+0x4a>
80002d2a:	30 18       	mov	r8,1
80002d2c:	f0 07 19 00 	cp.h	r7,r8
80002d30:	e0 81 00 ad 	brne	80002e8a <send_flash_command+0x19e>
80002d34:	c9 e8       	rjmp	80002e70 <send_flash_command+0x184>
80002d36:	30 38       	mov	r8,3
80002d38:	f0 07 19 00 	cp.h	r7,r8
80002d3c:	c7 20       	breq	80002e20 <send_flash_command+0x134>
80002d3e:	30 48       	mov	r8,4
80002d40:	f0 07 19 00 	cp.h	r7,r8
80002d44:	e0 81 00 a3 	brne	80002e8a <send_flash_command+0x19e>
80002d48:	c2 c8       	rjmp	80002da0 <send_flash_command+0xb4>
80002d4a:	35 28       	mov	r8,82
80002d4c:	f0 07 19 00 	cp.h	r7,r8
80002d50:	c2 f0       	breq	80002dae <send_flash_command+0xc2>
80002d52:	e0 8b 00 0c 	brhi	80002d6a <send_flash_command+0x7e>
80002d56:	30 68       	mov	r8,6
80002d58:	f0 07 19 00 	cp.h	r7,r8
80002d5c:	c2 20       	breq	80002da0 <send_flash_command+0xb4>
80002d5e:	32 08       	mov	r8,32
80002d60:	f0 07 19 00 	cp.h	r7,r8
80002d64:	e0 81 00 93 	brne	80002e8a <send_flash_command+0x19e>
80002d68:	c2 38       	rjmp	80002dae <send_flash_command+0xc2>
80002d6a:	36 08       	mov	r8,96
80002d6c:	f0 07 19 00 	cp.h	r7,r8
80002d70:	c3 20       	breq	80002dd4 <send_flash_command+0xe8>
80002d72:	e0 68 00 d8 	mov	r8,216
80002d76:	f0 07 19 00 	cp.h	r7,r8
80002d7a:	e0 81 00 88 	brne	80002e8a <send_flash_command+0x19e>
80002d7e:	c1 88       	rjmp	80002dae <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002d80:	4c 77       	lddpc	r7,80002e9c <send_flash_command+0x1b0>
80002d82:	30 5b       	mov	r11,5
80002d84:	6e 0c       	ld.w	r12,r7[0x0]
80002d86:	f0 1f 00 48 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_dummy();
80002d8a:	e0 6b 00 ff 	mov	r11,255
80002d8e:	6e 0c       	ld.w	r12,r7[0x0]
80002d90:	f0 1f 00 45 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002d94:	fa cb ff fe 	sub	r11,sp,-2
80002d98:	6e 0c       	ld.w	r12,r7[0x0]
80002d9a:	f0 1f 00 44 	mcall	80002ea8 <send_flash_command+0x1bc>
			break;
80002d9e:	c7 68       	rjmp	80002e8a <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002da0:	0e 9b       	mov	r11,r7
80002da2:	5c 7b       	castu.h	r11
80002da4:	4b e8       	lddpc	r8,80002e9c <send_flash_command+0x1b0>
80002da6:	70 0c       	ld.w	r12,r8[0x0]
80002da8:	f0 1f 00 3f 	mcall	80002ea4 <send_flash_command+0x1b8>
			break;
80002dac:	c6 f8       	rjmp	80002e8a <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002dae:	4b c6       	lddpc	r6,80002e9c <send_flash_command+0x1b0>
80002db0:	0e 9b       	mov	r11,r7
80002db2:	5c 7b       	castu.h	r11
80002db4:	6c 0c       	ld.w	r12,r6[0x0]
80002db6:	f0 1f 00 3c 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002dba:	08 9b       	mov	r11,r4
80002dbc:	6c 0c       	ld.w	r12,r6[0x0]
80002dbe:	f0 1f 00 3a 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002dc2:	06 9b       	mov	r11,r3
80002dc4:	6c 0c       	ld.w	r12,r6[0x0]
80002dc6:	f0 1f 00 38 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002dca:	04 9b       	mov	r11,r2
80002dcc:	6c 0c       	ld.w	r12,r6[0x0]
80002dce:	f0 1f 00 36 	mcall	80002ea4 <send_flash_command+0x1b8>
			break;
80002dd2:	c5 c8       	rjmp	80002e8a <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002dd4:	36 0b       	mov	r11,96
80002dd6:	4b 28       	lddpc	r8,80002e9c <send_flash_command+0x1b0>
80002dd8:	70 0c       	ld.w	r12,r8[0x0]
80002dda:	f0 1f 00 33 	mcall	80002ea4 <send_flash_command+0x1b8>
			break;
80002dde:	c5 68       	rjmp	80002e8a <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002de0:	4a f7       	lddpc	r7,80002e9c <send_flash_command+0x1b0>
80002de2:	30 2b       	mov	r11,2
80002de4:	6e 0c       	ld.w	r12,r7[0x0]
80002de6:	f0 1f 00 30 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002dea:	08 9b       	mov	r11,r4
80002dec:	6e 0c       	ld.w	r12,r7[0x0]
80002dee:	f0 1f 00 2e 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002df2:	06 9b       	mov	r11,r3
80002df4:	6e 0c       	ld.w	r12,r7[0x0]
80002df6:	f0 1f 00 2c 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002dfa:	04 9b       	mov	r11,r2
80002dfc:	6e 0c       	ld.w	r12,r7[0x0]
80002dfe:	f0 1f 00 2a 	mcall	80002ea4 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e02:	58 06       	cp.w	r6,0
80002e04:	c4 30       	breq	80002e8a <send_flash_command+0x19e>
80002e06:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002e08:	4a 54       	lddpc	r4,80002e9c <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002e0a:	0f 3b       	ld.ub	r11,r7++
80002e0c:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002e0e:	68 0c       	ld.w	r12,r4[0x0]
80002e10:	f0 1f 00 25 	mcall	80002ea4 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e14:	0e 98       	mov	r8,r7
80002e16:	0a 18       	sub	r8,r5
80002e18:	ec 08 19 00 	cp.h	r8,r6
80002e1c:	cf 73       	brcs	80002e0a <send_flash_command+0x11e>
80002e1e:	c3 68       	rjmp	80002e8a <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002e20:	49 f7       	lddpc	r7,80002e9c <send_flash_command+0x1b0>
80002e22:	30 3b       	mov	r11,3
80002e24:	6e 0c       	ld.w	r12,r7[0x0]
80002e26:	f0 1f 00 20 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e2a:	08 9b       	mov	r11,r4
80002e2c:	6e 0c       	ld.w	r12,r7[0x0]
80002e2e:	f0 1f 00 1e 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e32:	06 9b       	mov	r11,r3
80002e34:	6e 0c       	ld.w	r12,r7[0x0]
80002e36:	f0 1f 00 1c 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e3a:	04 9b       	mov	r11,r2
80002e3c:	6e 0c       	ld.w	r12,r7[0x0]
80002e3e:	f0 1f 00 1a 	mcall	80002ea4 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e42:	58 06       	cp.w	r6,0
80002e44:	c2 30       	breq	80002e8a <send_flash_command+0x19e>
80002e46:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002e48:	49 54       	lddpc	r4,80002e9c <send_flash_command+0x1b0>
80002e4a:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002e4e:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002e50:	06 9b       	mov	r11,r3
80002e52:	68 0c       	ld.w	r12,r4[0x0]
80002e54:	f0 1f 00 14 	mcall	80002ea4 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002e58:	1a 9b       	mov	r11,sp
80002e5a:	68 0c       	ld.w	r12,r4[0x0]
80002e5c:	f0 1f 00 13 	mcall	80002ea8 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002e60:	9a 08       	ld.sh	r8,sp[0x0]
80002e62:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e64:	0e 98       	mov	r8,r7
80002e66:	0a 18       	sub	r8,r5
80002e68:	ec 08 19 00 	cp.h	r8,r6
80002e6c:	cf 23       	brcs	80002e50 <send_flash_command+0x164>
80002e6e:	c0 e8       	rjmp	80002e8a <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002e70:	48 b7       	lddpc	r7,80002e9c <send_flash_command+0x1b0>
80002e72:	30 1b       	mov	r11,1
80002e74:	6e 0c       	ld.w	r12,r7[0x0]
80002e76:	f0 1f 00 0c 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e7a:	30 0b       	mov	r11,0
80002e7c:	6e 0c       	ld.w	r12,r7[0x0]
80002e7e:	f0 1f 00 0a 	mcall	80002ea4 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e82:	30 0b       	mov	r11,0
80002e84:	6e 0c       	ld.w	r12,r7[0x0]
80002e86:	f0 1f 00 08 	mcall	80002ea4 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002e8a:	30 1b       	mov	r11,1
80002e8c:	48 48       	lddpc	r8,80002e9c <send_flash_command+0x1b0>
80002e8e:	70 0c       	ld.w	r12,r8[0x0]
80002e90:	f0 1f 00 07 	mcall	80002eac <send_flash_command+0x1c0>

	return status;
}
80002e94:	9a 1c       	ld.sh	r12,sp[0x2]
80002e96:	2f fd       	sub	sp,-4
80002e98:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002e9c:	00 00       	add	r0,r0
80002e9e:	1e 28       	rsub	r8,pc
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	69 88       	ld.w	r8,r4[0x60]
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	68 22       	ld.w	r2,r4[0x8]
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	68 3e       	ld.w	lr,r4[0xc]
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	69 48       	ld.w	r8,r4[0x50]

80002eb0 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002eb0:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002eb2:	58 0a       	cp.w	r10,0
80002eb4:	5f 09       	sreq	r9
80002eb6:	e0 68 ff fe 	mov	r8,65534
80002eba:	ea 18 00 7f 	orh	r8,0x7f
80002ebe:	10 3c       	cp.w	r12,r8
80002ec0:	5f b8       	srhi	r8
80002ec2:	f3 e8 10 08 	or	r8,r9,r8
80002ec6:	c0 e1       	brne	80002ee2 <data_flash_read_block+0x32>
80002ec8:	e0 68 10 00 	mov	r8,4096
80002ecc:	f0 0b 19 00 	cp.h	r11,r8
80002ed0:	e0 8b 00 09 	brhi	80002ee2 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ed4:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ed8:	18 9b       	mov	r11,r12
80002eda:	30 3c       	mov	r12,3
80002edc:	f0 1f 00 02 	mcall	80002ee4 <data_flash_read_block+0x34>
80002ee0:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ee2:	da 0a       	popm	pc,r12=1
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	2c ec       	sub	r12,-50

80002ee8 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ee8:	eb cd 40 fc 	pushm	r2-r7,lr
80002eec:	18 94       	mov	r4,r12
80002eee:	16 93       	mov	r3,r11
80002ef0:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ef2:	58 0c       	cp.w	r12,0
80002ef4:	5f 09       	sreq	r9
80002ef6:	e0 68 ff fe 	mov	r8,65534
80002efa:	ea 18 00 7f 	orh	r8,0x7f
80002efe:	10 3b       	cp.w	r11,r8
80002f00:	5f b8       	srhi	r8
80002f02:	f3 e8 10 08 	or	r8,r9,r8
80002f06:	c3 a1       	brne	80002f7a <data_flash_write_page+0x92>
80002f08:	e0 68 01 00 	mov	r8,256
80002f0c:	f0 0a 19 00 	cp.h	r10,r8
80002f10:	e0 8b 00 35 	brhi	80002f7a <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002f14:	30 06       	mov	r6,0
80002f16:	30 55       	mov	r5,5
80002f18:	30 17       	mov	r7,1
80002f1a:	0c 99       	mov	r9,r6
80002f1c:	0c 9a       	mov	r10,r6
80002f1e:	0c 9b       	mov	r11,r6
80002f20:	0a 9c       	mov	r12,r5
80002f22:	f0 1f 00 19 	mcall	80002f84 <data_flash_write_page+0x9c>
80002f26:	ee 0c 19 00 	cp.h	r12,r7
80002f2a:	cf 80       	breq	80002f1a <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002f2c:	30 09       	mov	r9,0
80002f2e:	12 9a       	mov	r10,r9
80002f30:	12 9b       	mov	r11,r9
80002f32:	30 6c       	mov	r12,6
80002f34:	f0 1f 00 14 	mcall	80002f84 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002f38:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002f3c:	08 9a       	mov	r10,r4
80002f3e:	06 9b       	mov	r11,r3
80002f40:	30 2c       	mov	r12,2
80002f42:	f0 1f 00 11 	mcall	80002f84 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002f46:	30 06       	mov	r6,0
80002f48:	30 57       	mov	r7,5
80002f4a:	0c 99       	mov	r9,r6
80002f4c:	0c 9a       	mov	r10,r6
80002f4e:	0c 9b       	mov	r11,r6
80002f50:	0e 9c       	mov	r12,r7
80002f52:	f0 1f 00 0d 	mcall	80002f84 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002f56:	5c 7c       	castu.h	r12
80002f58:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002f5c:	cf 71       	brne	80002f4a <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002f5e:	18 97       	mov	r7,r12
80002f60:	e2 17 00 20 	andl	r7,0x20,COH
80002f64:	f9 b7 01 06 	movne	r7,6
80002f68:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002f6c:	30 09       	mov	r9,0
80002f6e:	12 9a       	mov	r10,r9
80002f70:	12 9b       	mov	r11,r9
80002f72:	30 4c       	mov	r12,4
80002f74:	f0 1f 00 04 	mcall	80002f84 <data_flash_write_page+0x9c>

	return return_code;
80002f78:	c0 28       	rjmp	80002f7c <data_flash_write_page+0x94>
80002f7a:	30 17       	mov	r7,1
}
80002f7c:	0e 9c       	mov	r12,r7
80002f7e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002f82:	00 00       	add	r0,r0
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	2c ec       	sub	r12,-50

80002f88 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002f88:	d4 31       	pushm	r0-r7,lr
80002f8a:	18 94       	mov	r4,r12
80002f8c:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002f90:	16 97       	mov	r7,r11
80002f92:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f94:	30 03       	mov	r3,0
80002f96:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002f98:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f9c:	c4 98       	rjmp	8000302e <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002f9e:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002fa2:	c1 b1       	brne	80002fd8 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002fa4:	e0 06 19 00 	cp.h	r6,r0
80002fa8:	e0 8b 00 0a 	brhi	80002fbc <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002fac:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002fb0:	0e 9b       	mov	r11,r7
80002fb2:	08 9c       	mov	r12,r4
80002fb4:	f0 1f 00 24 	mcall	80003044 <data_flash_write_block+0xbc>
80002fb8:	30 06       	mov	r6,0
80002fba:	c3 a8       	rjmp	8000302e <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002fbc:	e0 6a 01 00 	mov	r10,256
80002fc0:	0e 9b       	mov	r11,r7
80002fc2:	08 9c       	mov	r12,r4
80002fc4:	f0 1f 00 20 	mcall	80003044 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002fc8:	ec c6 01 00 	sub	r6,r6,256
80002fcc:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002fce:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002fd2:	ee c7 ff 00 	sub	r7,r7,-256
80002fd6:	c2 c8       	rjmp	8000302e <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002fd8:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002fdc:	0e 09       	add	r9,r7
80002fde:	0e 98       	mov	r8,r7
80002fe0:	e4 18 00 7f 	andh	r8,0x7f
80002fe4:	e0 18 ff 00 	andl	r8,0xff00
80002fe8:	f0 c8 ff 00 	sub	r8,r8,-256
80002fec:	10 39       	cp.w	r9,r8
80002fee:	e0 88 00 19 	brls	80003020 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002ff2:	0e 91       	mov	r1,r7
80002ff4:	5c 51       	castu.b	r1
80002ff6:	e0 6a 01 00 	mov	r10,256
80002ffa:	02 1a       	sub	r10,r1
80002ffc:	5c 7a       	castu.h	r10
80002ffe:	0e 9b       	mov	r11,r7
80003000:	08 9c       	mov	r12,r4
80003002:	f0 1f 00 11 	mcall	80003044 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003006:	ec c6 01 00 	sub	r6,r6,256
8000300a:	02 06       	add	r6,r1
8000300c:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
8000300e:	e0 68 01 00 	mov	r8,256
80003012:	f0 05 01 05 	sub	r5,r8,r5
80003016:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003018:	e0 17 ff 00 	andl	r7,0xff00
8000301c:	10 07       	add	r7,r8
8000301e:	c0 88       	rjmp	8000302e <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003020:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003024:	0e 9b       	mov	r11,r7
80003026:	08 9c       	mov	r12,r4
80003028:	f0 1f 00 07 	mcall	80003044 <data_flash_write_block+0xbc>
8000302c:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
8000302e:	e6 06 19 00 	cp.h	r6,r3
80003032:	5f 19       	srne	r9
80003034:	58 7c       	cp.w	r12,7
80003036:	5f 08       	sreq	r8
80003038:	f3 e8 00 08 	and	r8,r9,r8
8000303c:	e4 08 18 00 	cp.b	r8,r2
80003040:	ca f1       	brne	80002f9e <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80003042:	d8 32       	popm	r0-r7,pc
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	2e e8       	sub	r8,-18

80003048 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80003048:	eb cd 40 f8 	pushm	r3-r7,lr
8000304c:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
8000304e:	e0 68 ff fe 	mov	r8,65534
80003052:	ea 18 00 7f 	orh	r8,0x7f
80003056:	10 3c       	cp.w	r12,r8
80003058:	e0 88 00 04 	brls	80003060 <data_flash_erase_block+0x18>
8000305c:	30 17       	mov	r7,1
8000305e:	c3 f8       	rjmp	800030dc <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80003060:	58 1b       	cp.w	r11,1
80003062:	c0 31       	brne	80003068 <data_flash_erase_block+0x20>
80003064:	32 03       	mov	r3,32
80003066:	c0 a8       	rjmp	8000307a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80003068:	58 2b       	cp.w	r11,2
8000306a:	c0 31       	brne	80003070 <data_flash_erase_block+0x28>
8000306c:	35 23       	mov	r3,82
8000306e:	c0 68       	rjmp	8000307a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80003070:	e0 63 00 d8 	mov	r3,216
80003074:	58 3b       	cp.w	r11,3
80003076:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
8000307a:	30 06       	mov	r6,0
8000307c:	30 55       	mov	r5,5
8000307e:	30 17       	mov	r7,1
80003080:	0c 99       	mov	r9,r6
80003082:	0c 9a       	mov	r10,r6
80003084:	0c 9b       	mov	r11,r6
80003086:	0a 9c       	mov	r12,r5
80003088:	f0 1f 00 17 	mcall	800030e4 <data_flash_erase_block+0x9c>
8000308c:	ee 0c 19 00 	cp.h	r12,r7
80003090:	cf 80       	breq	80003080 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003092:	30 09       	mov	r9,0
80003094:	12 9a       	mov	r10,r9
80003096:	12 9b       	mov	r11,r9
80003098:	30 6c       	mov	r12,6
8000309a:	f0 1f 00 13 	mcall	800030e4 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
8000309e:	30 09       	mov	r9,0
800030a0:	12 9a       	mov	r10,r9
800030a2:	08 9b       	mov	r11,r4
800030a4:	06 9c       	mov	r12,r3
800030a6:	f0 1f 00 10 	mcall	800030e4 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800030aa:	30 06       	mov	r6,0
800030ac:	30 57       	mov	r7,5
800030ae:	0c 99       	mov	r9,r6
800030b0:	0c 9a       	mov	r10,r6
800030b2:	0c 9b       	mov	r11,r6
800030b4:	0e 9c       	mov	r12,r7
800030b6:	f0 1f 00 0c 	mcall	800030e4 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
800030ba:	5c 7c       	castu.h	r12
800030bc:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800030c0:	cf 71       	brne	800030ae <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
800030c2:	18 97       	mov	r7,r12
800030c4:	e2 17 00 20 	andl	r7,0x20,COH
800030c8:	f9 b7 01 04 	movne	r7,4
800030cc:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800030d0:	30 09       	mov	r9,0
800030d2:	12 9a       	mov	r10,r9
800030d4:	12 9b       	mov	r11,r9
800030d6:	30 4c       	mov	r12,4
800030d8:	f0 1f 00 03 	mcall	800030e4 <data_flash_erase_block+0x9c>

	return return_code;
}
800030dc:	0e 9c       	mov	r12,r7
800030de:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800030e2:	00 00       	add	r0,r0
800030e4:	80 00       	ld.sh	r0,r0[0x0]
800030e6:	2c ec       	sub	r12,-50

800030e8 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
800030e8:	d4 31       	pushm	r0-r7,lr
800030ea:	20 3d       	sub	sp,12
800030ec:	50 0c       	stdsp	sp[0x0],r12
800030ee:	16 91       	mov	r1,r11
800030f0:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
800030f2:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
800030f6:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
800030f8:	e0 69 10 00 	mov	r9,4096
800030fc:	f2 0a 01 07 	sub	r7,r9,r10
80003100:	ea 07 19 00 	cp.h	r7,r5
80003104:	ea 07 17 b0 	movhi	r7,r5
80003108:	5c 87       	casts.h	r7
8000310a:	16 92       	mov	r2,r11
8000310c:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003110:	4a e4       	lddpc	r4,800031c8 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80003112:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003114:	e8 c8 ff ff 	sub	r8,r4,-1
80003118:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
8000311a:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
8000311c:	08 9a       	mov	r10,r4
8000311e:	e0 6b 10 00 	mov	r11,4096
80003122:	04 9c       	mov	r12,r2
80003124:	f0 1f 00 2a 	mcall	800031cc <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80003128:	58 07       	cp.w	r7,0
8000312a:	c3 00       	breq	8000318a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000312c:	40 13       	lddsp	r3,sp[0x4]
8000312e:	5c 73       	castu.h	r3
80003130:	e8 03 07 08 	ld.ub	r8,r4[r3]
80003134:	ec 08 18 00 	cp.b	r8,r6
80003138:	c1 11       	brne	8000315a <data_flash_write+0x72>
8000313a:	e6 c9 ff ff 	sub	r9,r3,-1
8000313e:	08 09       	add	r9,r4
80003140:	30 08       	mov	r8,0
80003142:	c0 58       	rjmp	8000314c <data_flash_write+0x64>
80003144:	13 3a       	ld.ub	r10,r9++
80003146:	ec 0a 18 00 	cp.b	r10,r6
8000314a:	c0 81       	brne	8000315a <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
8000314c:	2f f8       	sub	r8,-1
8000314e:	5c 88       	casts.h	r8
80003150:	f0 07 19 00 	cp.h	r7,r8
80003154:	fe 9b ff f8 	brhi	80003144 <data_flash_write+0x5c>
80003158:	c1 98       	rjmp	8000318a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
8000315a:	30 1b       	mov	r11,1
8000315c:	04 9c       	mov	r12,r2
8000315e:	f0 1f 00 1d 	mcall	800031d0 <data_flash_write+0xe8>
80003162:	40 08       	lddsp	r8,sp[0x0]
80003164:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003166:	40 2a       	lddsp	r10,sp[0x8]
80003168:	40 19       	lddsp	r9,sp[0x4]
8000316a:	12 0a       	add	r10,r9
8000316c:	0e 99       	mov	r9,r7
8000316e:	20 19       	sub	r9,1
80003170:	5c 79       	castu.h	r9
80003172:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80003174:	11 39       	ld.ub	r9,r8++
80003176:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80003178:	14 33       	cp.w	r3,r10
8000317a:	cf d1       	brne	80003174 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
8000317c:	e0 6a 10 00 	mov	r10,4096
80003180:	04 9b       	mov	r11,r2
80003182:	08 9c       	mov	r12,r4
80003184:	f0 1f 00 14 	mcall	800031d4 <data_flash_write+0xec>
80003188:	c0 78       	rjmp	80003196 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
8000318a:	0e 9a       	mov	r10,r7
8000318c:	5c 7a       	castu.h	r10
8000318e:	02 9b       	mov	r11,r1
80003190:	40 0c       	lddsp	r12,sp[0x0]
80003192:	f0 1f 00 11 	mcall	800031d4 <data_flash_write+0xec>
80003196:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
8000319a:	0e 98       	mov	r8,r7
8000319c:	ee 05 19 00 	cp.h	r5,r7
800031a0:	c1 20       	breq	800031c4 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
800031a2:	5c 78       	castu.h	r8
800031a4:	40 0a       	lddsp	r10,sp[0x0]
800031a6:	10 0a       	add	r10,r8
800031a8:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
800031aa:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
800031ac:	0e 15       	sub	r5,r7
800031ae:	5c 85       	casts.h	r5
800031b0:	e0 05 19 00 	cp.h	r5,r0
800031b4:	ea 07 17 80 	movls	r7,r5
800031b8:	e0 07 17 b0 	movhi	r7,r0
800031bc:	5c 87       	casts.h	r7
800031be:	30 09       	mov	r9,0
800031c0:	50 19       	stdsp	sp[0x4],r9
800031c2:	ca db       	rjmp	8000311c <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
800031c4:	2f dd       	sub	sp,-12
800031c6:	d8 32       	popm	r0-r7,pc
800031c8:	00 00       	add	r0,r0
800031ca:	0e 28       	rsub	r8,r7
800031cc:	80 00       	ld.sh	r0,r0[0x0]
800031ce:	2e b0       	sub	r0,-21
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	30 48       	mov	r8,4
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	2f 88       	sub	r8,-8

800031d8 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800031d8:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800031da:	48 78       	lddpc	r8,800031f4 <W25Q64_SPI_SetSpeed+0x1c>
800031dc:	70 09       	ld.w	r9,r8[0x0]
800031de:	72 da       	ld.w	r10,r9[0x34]
800031e0:	5c 7c       	castu.h	r12
800031e2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800031e6:	f9 ea 10 0a 	or	r10,r12,r10
800031ea:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
800031ec:	70 0c       	ld.w	r12,r8[0x0]
800031ee:	f0 1f 00 03 	mcall	800031f8 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
800031f2:	d8 02       	popm	pc
800031f4:	00 00       	add	r0,r0
800031f6:	1e 28       	rsub	r8,pc
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	68 1c       	ld.w	r12,r4[0x4]

800031fc <W25Q64_SPI_SetSpeedLow>:
void W25Q64_SPI_SetSpeedLow(void)
{
800031fc:	d4 01       	pushm	lr
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
800031fe:	e0 6c 02 00 	mov	r12,512
80003202:	f0 1f 00 02 	mcall	80003208 <W25Q64_SPI_SetSpeedLow+0xc>
	
}
80003206:	d8 02       	popm	pc
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	31 d8       	mov	r8,29

8000320c <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
8000320c:	eb cd 40 c0 	pushm	r6-r7,lr
80003210:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80003212:	4b a8       	lddpc	r8,800032f8 <data_flash_init+0xec>
80003214:	fa c6 ff fc 	sub	r6,sp,-4
80003218:	f0 ea 00 00 	ld.d	r10,r8[0]
8000321c:	ec eb 00 00 	st.d	r6[0],r10
80003220:	f0 e8 00 08 	ld.d	r8,r8[8]
80003224:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003228:	30 4b       	mov	r11,4
8000322a:	4b 5c       	lddpc	r12,800032fc <data_flash_init+0xf0>
8000322c:	f0 1f 00 35 	mcall	80003300 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80003230:	4b 57       	lddpc	r7,80003304 <data_flash_init+0xf8>
80003232:	fe 7c 24 00 	mov	r12,-56320
80003236:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003238:	0c 9b       	mov	r11,r6
8000323a:	f0 1f 00 34 	mcall	80003308 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000323e:	30 09       	mov	r9,0
80003240:	12 9a       	mov	r10,r9
80003242:	12 9b       	mov	r11,r9
80003244:	6e 0c       	ld.w	r12,r7[0x0]
80003246:	f0 1f 00 32 	mcall	8000330c <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
8000324a:	6e 0c       	ld.w	r12,r7[0x0]
8000324c:	f0 1f 00 31 	mcall	80003310 <data_flash_init+0x104>

	W25Q64_SPI_SetSpeedLow();
80003250:	f0 1f 00 31 	mcall	80003314 <data_flash_init+0x108>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80003254:	e0 6a 36 00 	mov	r10,13824
80003258:	ea 1a 01 6e 	orh	r10,0x16e
8000325c:	0c 9b       	mov	r11,r6
8000325e:	6e 0c       	ld.w	r12,r7[0x0]
80003260:	f0 1f 00 2e 	mcall	80003318 <data_flash_init+0x10c>
80003264:	c0 50       	breq	8000326e <data_flash_init+0x62>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80003266:	30 29       	mov	r9,2
80003268:	4a d8       	lddpc	r8,8000331c <data_flash_init+0x110>
8000326a:	b0 89       	st.b	r8[0x0],r9
		return;
8000326c:	c4 28       	rjmp	800032f0 <data_flash_init+0xe4>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
8000326e:	1a 96       	mov	r6,sp
80003270:	30 4a       	mov	r10,4
80003272:	4a cb       	lddpc	r11,80003320 <data_flash_init+0x114>
80003274:	1a 9c       	mov	r12,sp
80003276:	f0 1f 00 2c 	mcall	80003324 <data_flash_init+0x118>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
8000327a:	4a 37       	lddpc	r7,80003304 <data_flash_init+0xf8>
8000327c:	30 1b       	mov	r11,1
8000327e:	6e 0c       	ld.w	r12,r7[0x0]
80003280:	f0 1f 00 2a 	mcall	80003328 <data_flash_init+0x11c>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80003284:	e0 6b 00 90 	mov	r11,144
80003288:	6e 0c       	ld.w	r12,r7[0x0]
8000328a:	f0 1f 00 29 	mcall	8000332c <data_flash_init+0x120>
	spi_write_zero();
8000328e:	30 0b       	mov	r11,0
80003290:	6e 0c       	ld.w	r12,r7[0x0]
80003292:	f0 1f 00 27 	mcall	8000332c <data_flash_init+0x120>
	spi_write_zero();
80003296:	30 0b       	mov	r11,0
80003298:	6e 0c       	ld.w	r12,r7[0x0]
8000329a:	f0 1f 00 25 	mcall	8000332c <data_flash_init+0x120>
	spi_write_zero();
8000329e:	30 0b       	mov	r11,0
800032a0:	6e 0c       	ld.w	r12,r7[0x0]
800032a2:	f0 1f 00 23 	mcall	8000332c <data_flash_init+0x120>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
800032a6:	e0 6b 00 ff 	mov	r11,255
800032aa:	6e 0c       	ld.w	r12,r7[0x0]
800032ac:	f0 1f 00 20 	mcall	8000332c <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[0]);
800032b0:	1a 9b       	mov	r11,sp
800032b2:	6e 0c       	ld.w	r12,r7[0x0]
800032b4:	f0 1f 00 1f 	mcall	80003330 <data_flash_init+0x124>
	
	spi_write_dummy();
800032b8:	e0 6b 00 ff 	mov	r11,255
800032bc:	6e 0c       	ld.w	r12,r7[0x0]
800032be:	f0 1f 00 1c 	mcall	8000332c <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[1]);
800032c2:	fa cb ff fe 	sub	r11,sp,-2
800032c6:	6e 0c       	ld.w	r12,r7[0x0]
800032c8:	f0 1f 00 1a 	mcall	80003330 <data_flash_init+0x124>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
800032cc:	30 1b       	mov	r11,1
800032ce:	6e 0c       	ld.w	r12,r7[0x0]
800032d0:	f0 1f 00 19 	mcall	80003334 <data_flash_init+0x128>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
800032d4:	e0 68 00 ef 	mov	r8,239
800032d8:	9a 09       	ld.sh	r9,sp[0x0]
800032da:	f0 09 19 00 	cp.h	r9,r8
800032de:	c0 61       	brne	800032ea <data_flash_init+0xde>
800032e0:	31 68       	mov	r8,22
800032e2:	9a 19       	ld.sh	r9,sp[0x2]
800032e4:	f0 09 19 00 	cp.h	r9,r8
800032e8:	c0 40       	breq	800032f0 <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
800032ea:	30 39       	mov	r9,3
800032ec:	48 c8       	lddpc	r8,8000331c <data_flash_init+0x110>
800032ee:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
800032f0:	2f bd       	sub	sp,-20
800032f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032f6:	00 00       	add	r0,r0
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	e8 f0 80 00 	ld.w	r0,r4[-32768]
800032fe:	e8 cc 80 00 	sub	r12,r4,-32768
80003302:	63 48       	ld.w	r8,r1[0x50]
80003304:	00 00       	add	r0,r0
80003306:	1e 28       	rsub	r8,pc
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	67 b8       	ld.w	r8,r3[0x6c]
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	67 f0       	ld.w	r0,r3[0x7c]
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	68 1c       	ld.w	r12,r4[0x4]
80003314:	80 00       	ld.sh	r0,r0[0x0]
80003316:	31 fc       	mov	r12,31
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	68 60       	ld.w	r0,r4[0x18]
8000331c:	00 00       	add	r0,r0
8000331e:	0a 87       	andn	r7,r5
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	e8 ec 80 00 	ld.d	r12,r4[-32768]
80003326:	88 0e       	ld.sh	lr,r4[0x0]
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	69 88       	ld.w	r8,r4[0x60]
8000332c:	80 00       	ld.sh	r0,r0[0x0]
8000332e:	68 22       	ld.w	r2,r4[0x8]
80003330:	80 00       	ld.sh	r0,r0[0x0]
80003332:	68 3e       	ld.w	lr,r4[0xc]
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	69 48       	ld.w	r8,r4[0x50]

80003338 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003338:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000333a:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000333c:	30 0a       	mov	r10,0
8000333e:	32 8b       	mov	r11,40
80003340:	49 5c       	lddpc	r12,80003394 <xg_rtc_init+0x5c>
80003342:	f0 1f 00 16 	mcall	80003398 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80003346:	30 ea       	mov	r10,14
80003348:	30 1b       	mov	r11,1
8000334a:	fe 7c 0d 00 	mov	r12,-62208
8000334e:	f0 1f 00 14 	mcall	8000339c <xg_rtc_init+0x64>
80003352:	c0 41       	brne	8000335a <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003354:	49 3c       	lddpc	r12,800033a0 <xg_rtc_init+0x68>
80003356:	f0 1f 00 14 	mcall	800033a4 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
8000335a:	30 0b       	mov	r11,0
8000335c:	fe 7c 0d 00 	mov	r12,-62208
80003360:	f0 1f 00 12 	mcall	800033a8 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003364:	fe 7c 0d 00 	mov	r12,-62208
80003368:	f0 1f 00 11 	mcall	800033ac <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
8000336c:	fe 7c 0d 00 	mov	r12,-62208
80003370:	f0 1f 00 10 	mcall	800033b0 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003374:	49 08       	lddpc	r8,800033b4 <xg_rtc_init+0x7c>
80003376:	31 09       	mov	r9,16
80003378:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000337a:	30 29       	mov	r9,2
8000337c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000337e:	31 d9       	mov	r9,29
80003380:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003382:	31 79       	mov	r9,23
80003384:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003386:	33 b9       	mov	r9,59
80003388:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000338a:	32 89       	mov	r9,40
8000338c:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000338e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003390:	d8 02       	popm	pc
80003392:	00 00       	add	r0,r0
80003394:	80 00       	ld.sh	r0,r0[0x0]
80003396:	33 b8       	mov	r8,59
80003398:	80 00       	ld.sh	r0,r0[0x0]
8000339a:	63 cc       	ld.w	r12,r1[0x70]
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	67 18       	ld.w	r8,r3[0x44]
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	e9 00 80 00 	ld.sh	r0,r4[-32768]
800033a6:	7f 64       	ld.w	r4,pc[0x58]
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	66 d4       	ld.w	r4,r3[0x34]
800033ac:	80 00       	ld.sh	r0,r0[0x0]
800033ae:	66 cc       	ld.w	r12,r3[0x30]
800033b0:	80 00       	ld.sh	r0,r0[0x0]
800033b2:	66 a8       	ld.w	r8,r3[0x28]
800033b4:	00 00       	add	r0,r0
800033b6:	0e 20       	rsub	r0,r7

800033b8 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800033b8:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800033ba:	4b 98       	lddpc	r8,8000349c <rtc_irq+0xe4>
800033bc:	11 d9       	ld.ub	r9,r8[0x5]
800033be:	2f f9       	sub	r9,-1
800033c0:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800033c2:	11 d9       	ld.ub	r9,r8[0x5]
800033c4:	33 b8       	mov	r8,59
800033c6:	f0 09 18 00 	cp.b	r9,r8
800033ca:	e0 88 00 5f 	brls	80003488 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800033ce:	4b 48       	lddpc	r8,8000349c <rtc_irq+0xe4>
800033d0:	30 09       	mov	r9,0
800033d2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800033d4:	11 c9       	ld.ub	r9,r8[0x4]
800033d6:	2f f9       	sub	r9,-1
800033d8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800033da:	11 c9       	ld.ub	r9,r8[0x4]
800033dc:	33 b8       	mov	r8,59
800033de:	f0 09 18 00 	cp.b	r9,r8
800033e2:	e0 88 00 53 	brls	80003488 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800033e6:	4a e8       	lddpc	r8,8000349c <rtc_irq+0xe4>
800033e8:	30 09       	mov	r9,0
800033ea:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800033ec:	11 b9       	ld.ub	r9,r8[0x3]
800033ee:	2f f9       	sub	r9,-1
800033f0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800033f2:	11 b9       	ld.ub	r9,r8[0x3]
800033f4:	31 78       	mov	r8,23
800033f6:	f0 09 18 00 	cp.b	r9,r8
800033fa:	e0 88 00 47 	brls	80003488 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800033fe:	4a 88       	lddpc	r8,8000349c <rtc_irq+0xe4>
80003400:	30 09       	mov	r9,0
80003402:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003404:	11 88       	ld.ub	r8,r8[0x0]
80003406:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000340a:	e0 69 01 6e 	mov	r9,366
8000340e:	e0 6a 01 6d 	mov	r10,365
80003412:	f4 08 17 10 	movne	r8,r10
80003416:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000341a:	4a 19       	lddpc	r9,8000349c <rtc_irq+0xe4>
8000341c:	13 9a       	ld.ub	r10,r9[0x1]
8000341e:	30 29       	mov	r9,2
80003420:	f2 0a 18 00 	cp.b	r10,r9
80003424:	c0 b0       	breq	8000343a <rtc_irq+0x82>
80003426:	49 e8       	lddpc	r8,8000349c <rtc_irq+0xe4>
80003428:	11 99       	ld.ub	r9,r8[0x1]
8000342a:	11 9a       	ld.ub	r10,r8[0x1]
8000342c:	a3 9a       	lsr	r10,0x3
8000342e:	12 0a       	add	r10,r9
80003430:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003434:	2e 2a       	sub	r10,-30
80003436:	5c 5a       	castu.b	r10
80003438:	c0 58       	rjmp	80003442 <rtc_irq+0x8a>
8000343a:	f0 c8 01 51 	sub	r8,r8,337
8000343e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003442:	49 78       	lddpc	r8,8000349c <rtc_irq+0xe4>
80003444:	11 a9       	ld.ub	r9,r8[0x2]
80003446:	2f f9       	sub	r9,-1
80003448:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000344a:	11 a8       	ld.ub	r8,r8[0x2]
8000344c:	f0 0a 18 00 	cp.b	r10,r8
80003450:	c1 c2       	brcc	80003488 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80003452:	49 38       	lddpc	r8,8000349c <rtc_irq+0xe4>
80003454:	30 19       	mov	r9,1
80003456:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003458:	11 99       	ld.ub	r9,r8[0x1]
8000345a:	2f f9       	sub	r9,-1
8000345c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
8000345e:	11 99       	ld.ub	r9,r8[0x1]
80003460:	30 c8       	mov	r8,12
80003462:	f0 09 18 00 	cp.b	r9,r8
80003466:	e0 88 00 11 	brls	80003488 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
8000346a:	48 d8       	lddpc	r8,8000349c <rtc_irq+0xe4>
8000346c:	30 19       	mov	r9,1
8000346e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003470:	11 89       	ld.ub	r9,r8[0x0]
80003472:	2f f9       	sub	r9,-1
80003474:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80003476:	11 89       	ld.ub	r9,r8[0x0]
80003478:	39 68       	mov	r8,-106
8000347a:	f0 09 18 00 	cp.b	r9,r8
8000347e:	e0 88 00 05 	brls	80003488 <rtc_irq+0xd0>
80003482:	30 09       	mov	r9,0
80003484:	48 68       	lddpc	r8,8000349c <rtc_irq+0xe4>
80003486:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003488:	fe 7c 0d 00 	mov	r12,-62208
8000348c:	f0 1f 00 05 	mcall	800034a0 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003490:	30 19       	mov	r9,1
80003492:	48 58       	lddpc	r8,800034a4 <rtc_irq+0xec>
80003494:	91 09       	st.w	r8[0x0],r9
}
80003496:	d4 02       	popm	lr
80003498:	d6 03       	rete
8000349a:	00 00       	add	r0,r0
8000349c:	00 00       	add	r0,r0
8000349e:	0e 20       	rsub	r0,r7
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	66 f8       	ld.w	r8,r3[0x3c]
800034a4:	00 00       	add	r0,r0
800034a6:	04 fc       	st.b	--r2,r12

800034a8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800034a8:	20 1c       	sub	r12,1
800034aa:	5c 5c       	castu.b	r12
800034ac:	31 18       	mov	r8,17
800034ae:	f0 0c 18 00 	cp.b	r12,r8
800034b2:	e0 88 00 03 	brls	800034b8 <CalculateBurst+0x10>
800034b6:	5e fd       	retal	0
800034b8:	48 28       	lddpc	r8,800034c0 <CalculateBurst+0x18>
800034ba:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800034be:	5e fc       	retal	r12
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	e9 20 48 38 	ld.sb	r0,r4[18488]

800034c4 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800034c4:	48 38       	lddpc	r8,800034d0 <payload_init+0xc>
800034c6:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800034c8:	48 38       	lddpc	r8,800034d4 <payload_init+0x10>
800034ca:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800034cc:	5e fc       	retal	r12
800034ce:	00 00       	add	r0,r0
800034d0:	00 00       	add	r0,r0
800034d2:	0a 88       	andn	r8,r5
800034d4:	00 00       	add	r0,r0
800034d6:	0a 8c       	andn	r12,r5

800034d8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800034d8:	d4 01       	pushm	lr
800034da:	20 2d       	sub	sp,8
800034dc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800034de:	30 09       	mov	r9,0
800034e0:	fa ca ff f8 	sub	r10,sp,-8
800034e4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800034e6:	1a 9b       	mov	r11,sp
800034e8:	f0 1f 00 02 	mcall	800034f0 <set_idle_store_isr+0x18>
}
800034ec:	2f ed       	sub	sp,-8
800034ee:	d8 02       	popm	pc
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	72 dc       	ld.w	r12,r9[0x34]

800034f4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
800034f4:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
800034f6:	48 48       	lddpc	r8,80003504 <payload_rx+0x10>
800034f8:	70 08       	ld.w	r8,r8[0x0]
800034fa:	18 9b       	mov	r11,r12
800034fc:	10 9c       	mov	r12,r8
800034fe:	f0 1f 00 03 	mcall	80003508 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80003502:	d8 02       	popm	pc
80003504:	00 00       	add	r0,r0
80003506:	0a c4       	st.b	r5++,r4
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	34 d8       	mov	r8,77

8000350c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
8000350c:	d4 01       	pushm	lr
8000350e:	20 2d       	sub	sp,8
80003510:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003512:	58 0c       	cp.w	r12,0
80003514:	c1 10       	breq	80003536 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003516:	30 08       	mov	r8,0
80003518:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000351a:	98 88       	ld.uh	r8,r12[0x0]
8000351c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003520:	e0 48 40 00 	cp.w	r8,16384
80003524:	c0 91       	brne	80003536 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003526:	48 68       	lddpc	r8,8000353c <phy_rx+0x30>
80003528:	70 0c       	ld.w	r12,r8[0x0]
8000352a:	30 09       	mov	r9,0
8000352c:	fa ca ff fc 	sub	r10,sp,-4
80003530:	1a 9b       	mov	r11,sp
80003532:	f0 1f 00 04 	mcall	80003540 <phy_rx+0x34>
		}	

    }
		
 
}
80003536:	2f ed       	sub	sp,-8
80003538:	d8 02       	popm	pc
8000353a:	00 00       	add	r0,r0
8000353c:	00 00       	add	r0,r0
8000353e:	0a d0       	st.w	--r5,r0
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	72 dc       	ld.w	r12,r9[0x34]

80003544 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003544:	eb cd 40 80 	pushm	r7,lr
80003548:	20 1d       	sub	sp,4
8000354a:	fa c7 ff fc 	sub	r7,sp,-4
8000354e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003550:	30 09       	mov	r9,0
80003552:	12 9a       	mov	r10,r9
80003554:	1a 9b       	mov	r11,sp
80003556:	f0 1f 00 03 	mcall	80003560 <set_idle_store+0x1c>
}
8000355a:	2f fd       	sub	sp,-4
8000355c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003560:	80 00       	ld.sh	r0,r0[0x0]
80003562:	73 2c       	ld.w	r12,r9[0x48]

80003564 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003564:	d4 01       	pushm	lr
80003566:	20 1d       	sub	sp,4
80003568:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
8000356a:	98 88       	ld.uh	r8,r12[0x0]
8000356c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003570:	e0 48 40 00 	cp.w	r8,16384
80003574:	c0 d1       	brne	8000358e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003576:	49 08       	lddpc	r8,800035b4 <phy_tx+0x50>
80003578:	70 08       	ld.w	r8,r8[0x0]
8000357a:	58 08       	cp.w	r8,0
8000357c:	c1 a0       	breq	800035b0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000357e:	48 e8       	lddpc	r8,800035b4 <phy_tx+0x50>
80003580:	70 0c       	ld.w	r12,r8[0x0]
80003582:	30 09       	mov	r9,0
80003584:	12 9a       	mov	r10,r9
80003586:	1a 9b       	mov	r11,sp
80003588:	f0 1f 00 0c 	mcall	800035b8 <phy_tx+0x54>
8000358c:	c1 28       	rjmp	800035b0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000358e:	e0 48 10 00 	cp.w	r8,4096
80003592:	5f 0a       	sreq	r10
80003594:	e0 48 20 00 	cp.w	r8,8192
80003598:	5f 09       	sreq	r9
8000359a:	f5 e9 10 09 	or	r9,r10,r9
8000359e:	c0 71       	brne	800035ac <phy_tx+0x48>
800035a0:	e0 48 50 00 	cp.w	r8,20480
800035a4:	c0 40       	breq	800035ac <phy_tx+0x48>
800035a6:	e0 48 60 00 	cp.w	r8,24576
800035aa:	c0 31       	brne	800035b0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
800035ac:	48 48       	lddpc	r8,800035bc <phy_tx+0x58>
800035ae:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
800035b0:	2f fd       	sub	sp,-4
800035b2:	d8 02       	popm	pc
800035b4:	00 00       	add	r0,r0
800035b6:	0a f0       	st.b	--r5,r0
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	73 2c       	ld.w	r12,r9[0x48]
800035bc:	00 00       	add	r0,r0
800035be:	0a e4       	st.h	--r5,r4

800035c0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
800035c0:	d4 01       	pushm	lr
800035c2:	20 2d       	sub	sp,8
	void * ptr = NULL;
800035c4:	30 08       	mov	r8,0
800035c6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800035c8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
800035ca:	1a 9a       	mov	r10,sp
800035cc:	fa cb ff fc 	sub	r11,sp,-4
800035d0:	f0 1f 00 05 	mcall	800035e4 <get_idle_store_isr+0x24>
800035d4:	58 1c       	cp.w	r12,1
800035d6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800035da:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
800035de:	2f ed       	sub	sp,-8
800035e0:	d8 02       	popm	pc
800035e2:	00 00       	add	r0,r0
800035e4:	80 00       	ld.sh	r0,r0[0x0]
800035e6:	70 30       	ld.w	r0,r8[0xc]

800035e8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800035e8:	eb cd 40 c0 	pushm	r6-r7,lr
800035ec:	20 1d       	sub	sp,4
800035ee:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800035f0:	4b a8       	lddpc	r8,800036d8 <phy_tx_func+0xf0>
800035f2:	70 08       	ld.w	r8,r8[0x0]
800035f4:	58 08       	cp.w	r8,0
800035f6:	c6 60       	breq	800036c2 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800035f8:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800035fa:	30 08       	mov	r8,0
800035fc:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800035fe:	4b 88       	lddpc	r8,800036dc <phy_tx_func+0xf4>
80003600:	70 08       	ld.w	r8,r8[0x0]
80003602:	58 18       	cp.w	r8,1
80003604:	c2 60       	breq	80003650 <phy_tx_func+0x68>
80003606:	c0 43       	brcs	8000360e <phy_tx_func+0x26>
80003608:	58 28       	cp.w	r8,2
8000360a:	c5 c1       	brne	800036c2 <phy_tx_func+0xda>
8000360c:	c5 58       	rjmp	800036b6 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
8000360e:	4b 38       	lddpc	r8,800036d8 <phy_tx_func+0xf0>
80003610:	70 0c       	ld.w	r12,r8[0x0]
80003612:	1a 9a       	mov	r10,sp
80003614:	4b 3b       	lddpc	r11,800036e0 <phy_tx_func+0xf8>
80003616:	f0 1f 00 34 	mcall	800036e4 <phy_tx_func+0xfc>
8000361a:	58 1c       	cp.w	r12,1
8000361c:	c1 41       	brne	80003644 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
8000361e:	4b 18       	lddpc	r8,800036e0 <phy_tx_func+0xf8>
80003620:	70 08       	ld.w	r8,r8[0x0]
80003622:	90 08       	ld.sh	r8,r8[0x0]
80003624:	10 9a       	mov	r10,r8
80003626:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000362a:	4b 09       	lddpc	r9,800036e8 <phy_tx_func+0x100>
8000362c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
8000362e:	5c 78       	castu.h	r8
80003630:	ea 18 ab cd 	orh	r8,0xabcd
80003634:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003636:	30 19       	mov	r9,1
80003638:	4a d8       	lddpc	r8,800036ec <phy_tx_func+0x104>
8000363a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
8000363c:	30 19       	mov	r9,1
8000363e:	4a 88       	lddpc	r8,800036dc <phy_tx_func+0xf4>
80003640:	91 09       	st.w	r8[0x0],r9
80003642:	c4 08       	rjmp	800036c2 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003644:	e0 68 5a 5a 	mov	r8,23130
80003648:	ea 18 ab cd 	orh	r8,0xabcd
8000364c:	8f 18       	st.w	r7[0x4],r8
8000364e:	c3 a8       	rjmp	800036c2 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003650:	4a 7a       	lddpc	r10,800036ec <phy_tx_func+0x104>
80003652:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003654:	4a 39       	lddpc	r9,800036e0 <phy_tx_func+0xf8>
80003656:	72 09       	ld.w	r9,r9[0x0]
80003658:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
8000365c:	b1 69       	lsl	r9,0x10
8000365e:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003660:	2f f8       	sub	r8,-1
80003662:	5c 58       	castu.b	r8
80003664:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80003666:	4a 1b       	lddpc	r11,800036e8 <phy_tx_func+0x100>
80003668:	96 0c       	ld.sh	r12,r11[0x0]
8000366a:	20 2c       	sub	r12,2
8000366c:	5c 8c       	casts.h	r12
8000366e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80003672:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003674:	30 0b       	mov	r11,0
80003676:	f6 0a 19 00 	cp.h	r10,r11
8000367a:	e0 89 00 09 	brgt	8000368c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000367e:	e8 19 00 ba 	orl	r9,0xba
80003682:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003684:	30 09       	mov	r9,0
80003686:	49 68       	lddpc	r8,800036dc <phy_tx_func+0xf4>
80003688:	91 09       	st.w	r8[0x0],r9
8000368a:	c1 c8       	rjmp	800036c2 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
8000368c:	49 5a       	lddpc	r10,800036e0 <phy_tx_func+0xf8>
8000368e:	74 0a       	ld.w	r10,r10[0x0]
80003690:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003694:	14 49       	or	r9,r10
80003696:	8f 19       	st.w	r7[0x4],r9
80003698:	2f f8       	sub	r8,-1
8000369a:	49 59       	lddpc	r9,800036ec <phy_tx_func+0x104>
8000369c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000369e:	20 2c       	sub	r12,2
800036a0:	49 28       	lddpc	r8,800036e8 <phy_tx_func+0x100>
800036a2:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800036a4:	30 08       	mov	r8,0
800036a6:	f0 0c 19 00 	cp.h	r12,r8
800036aa:	e0 89 00 0c 	brgt	800036c2 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
800036ae:	30 29       	mov	r9,2
800036b0:	48 b8       	lddpc	r8,800036dc <phy_tx_func+0xf4>
800036b2:	91 09       	st.w	r8[0x0],r9
800036b4:	c0 78       	rjmp	800036c2 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
800036b6:	fc 18 00 ba 	movh	r8,0xba
800036ba:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
800036bc:	30 09       	mov	r9,0
800036be:	48 88       	lddpc	r8,800036dc <phy_tx_func+0xf4>
800036c0:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
800036c2:	e0 68 5a 5a 	mov	r8,23130
800036c6:	ea 18 ab cd 	orh	r8,0xabcd
800036ca:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
800036cc:	30 08       	mov	r8,0
800036ce:	8f 38       	st.w	r7[0xc],r8
}
800036d0:	2f fd       	sub	sp,-4
800036d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036d6:	00 00       	add	r0,r0
800036d8:	00 00       	add	r0,r0
800036da:	0a f0       	st.b	--r5,r0
800036dc:	00 00       	add	r0,r0
800036de:	0a b0       	st.h	r5++,r0
800036e0:	00 00       	add	r0,r0
800036e2:	0a bc       	st.h	r5++,r12
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	70 30       	ld.w	r0,r8[0xc]
800036e8:	00 00       	add	r0,r0
800036ea:	0a d8       	st.w	--r5,r8
800036ec:	00 00       	add	r0,r0
800036ee:	0a 90       	mov	r0,r5

800036f0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800036f0:	d4 01       	pushm	lr
800036f2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800036f4:	30 0a       	mov	r10,0
800036f6:	fa cb ff fc 	sub	r11,sp,-4
800036fa:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800036fc:	14 99       	mov	r9,r10
800036fe:	1a 9b       	mov	r11,sp
80003700:	f0 1f 00 05 	mcall	80003714 <get_idle_store+0x24>
80003704:	58 1c       	cp.w	r12,1
80003706:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000370a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000370e:	2f fd       	sub	sp,-4
80003710:	d8 02       	popm	pc
80003712:	00 00       	add	r0,r0
80003714:	80 00       	ld.sh	r0,r0[0x0]
80003716:	71 20       	ld.w	r0,r8[0x48]

80003718 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003718:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000371a:	48 5b       	lddpc	r11,8000372c <phy_init+0x14>
8000371c:	48 5c       	lddpc	r12,80003730 <phy_init+0x18>
8000371e:	f0 1f 00 06 	mcall	80003734 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80003722:	f0 1f 00 06 	mcall	80003738 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80003726:	f0 1f 00 06 	mcall	8000373c <phy_init+0x24>
	
}
8000372a:	d8 02       	popm	pc
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	35 e8       	mov	r8,94
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	37 40       	mov	r0,116
80003734:	80 00       	ld.sh	r0,r0[0x0]
80003736:	47 94       	lddsp	r4,sp[0x1e4]
80003738:	80 00       	ld.sh	r0,r0[0x0]
8000373a:	47 a8       	lddsp	r8,sp[0x1e8]
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	51 58       	stdsp	sp[0x54],r8

80003740 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003740:	eb cd 40 e0 	pushm	r5-r7,lr
80003744:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003746:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000374a:	70 08       	ld.w	r8,r8[0x0]
8000374c:	58 08       	cp.w	r8,0
8000374e:	e0 80 01 08 	breq	8000395e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003752:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003754:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003758:	70 09       	ld.w	r9,r8[0x0]
8000375a:	2f f9       	sub	r9,-1
8000375c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000375e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003762:	70 08       	ld.w	r8,r8[0x0]
80003764:	58 18       	cp.w	r8,1
80003766:	e0 80 00 85 	breq	80003870 <phy_rx_func+0x130>
8000376a:	c0 73       	brcs	80003778 <phy_rx_func+0x38>
8000376c:	58 28       	cp.w	r8,2
8000376e:	c5 c0       	breq	80003826 <phy_rx_func+0xe6>
80003770:	58 38       	cp.w	r8,3
80003772:	e0 81 00 f6 	brne	8000395e <phy_rx_func+0x21e>
80003776:	cd 58       	rjmp	80003920 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003778:	e0 6a 5a 5a 	mov	r10,23130
8000377c:	ea 1a ab cd 	orh	r10,0xabcd
80003780:	14 36       	cp.w	r6,r10
80003782:	e0 80 00 ee 	breq	8000395e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003786:	ec 08 16 10 	lsr	r8,r6,0x10
8000378a:	e0 48 ab cd 	cp.w	r8,43981
8000378e:	e0 81 00 e8 	brne	8000395e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003792:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003796:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000379a:	20 28       	sub	r8,2
8000379c:	fe f9 0e 30 	ld.w	r9,pc[3632]
800037a0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800037a2:	30 09       	mov	r9,0
800037a4:	f2 08 19 00 	cp.h	r8,r9
800037a8:	e0 8a 00 db 	brle	8000395e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
800037ac:	fe f8 0e 24 	ld.w	r8,pc[3620]
800037b0:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800037b2:	fe f8 0e 22 	ld.w	r8,pc[3618]
800037b6:	70 0c       	ld.w	r12,r8[0x0]
800037b8:	f0 1f 03 88 	mcall	800045d8 <phy_rx_func+0xe98>
800037bc:	fe f8 0e 20 	ld.w	r8,pc[3616]
800037c0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800037c2:	58 0c       	cp.w	r12,0
800037c4:	e0 80 00 cd 	breq	8000395e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800037c8:	fe f8 0e 08 	ld.w	r8,pc[3592]
800037cc:	90 09       	ld.sh	r9,r8[0x0]
800037ce:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800037d2:	2f f9       	sub	r9,-1
800037d4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037d6:	fe fa 0e 06 	ld.w	r10,pc[3590]
800037da:	74 0a       	ld.w	r10,r10[0x0]
800037dc:	fe fb 0d e8 	ld.w	r11,pc[3560]
800037e0:	76 0b       	ld.w	r11,r11[0x0]
800037e2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800037e6:	2f f9       	sub	r9,-1
800037e8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800037ea:	e2 16 0f 00 	andl	r6,0xf00,COH
800037ee:	e0 46 01 00 	cp.w	r6,256
800037f2:	c0 c0       	breq	8000380a <phy_rx_func+0xca>
800037f4:	e0 8b 00 05 	brhi	800037fe <phy_rx_func+0xbe>
800037f8:	58 06       	cp.w	r6,0
800037fa:	c0 80       	breq	8000380a <phy_rx_func+0xca>
800037fc:	c0 c8       	rjmp	80003814 <phy_rx_func+0xd4>
800037fe:	e0 46 02 00 	cp.w	r6,512
80003802:	c0 40       	breq	8000380a <phy_rx_func+0xca>
80003804:	e0 46 03 00 	cp.w	r6,768
80003808:	c0 61       	brne	80003814 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000380a:	30 29       	mov	r9,2
8000380c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	ca 68       	rjmp	8000395e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003814:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003818:	70 0c       	ld.w	r12,r8[0x0]
8000381a:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000381e:	70 0b       	ld.w	r11,r8[0x0]
80003820:	f0 1f 03 70 	mcall	800045e0 <phy_rx_func+0xea0>
80003824:	c9 d8       	rjmp	8000395e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003826:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000382a:	b1 86       	lsr	r6,0x10
8000382c:	14 06       	add	r6,r10
8000382e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003832:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003834:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003838:	90 09       	ld.sh	r9,r8[0x0]
8000383a:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000383e:	76 0b       	ld.w	r11,r11[0x0]
80003840:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003844:	2f f9       	sub	r9,-1
80003846:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003848:	fe f9 0d 84 	ld.w	r9,pc[3460]
8000384c:	92 08       	ld.sh	r8,r9[0x0]
8000384e:	20 28       	sub	r8,2
80003850:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003852:	30 09       	mov	r9,0
80003854:	f2 08 19 00 	cp.h	r8,r9
80003858:	e0 8a 00 07 	brle	80003866 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000385c:	30 19       	mov	r9,1
8000385e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003862:	91 09       	st.w	r8[0x0],r9
80003864:	c7 d8       	rjmp	8000395e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003866:	30 39       	mov	r9,3
80003868:	fe f8 0d 60 	ld.w	r8,pc[3424]
8000386c:	91 09       	st.w	r8[0x0],r9
8000386e:	c7 88       	rjmp	8000395e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003870:	ec 0a 14 10 	asr	r10,r6,0x10
80003874:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003878:	90 09       	ld.sh	r9,r8[0x0]
8000387a:	14 09       	add	r9,r10
8000387c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000387e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003882:	92 08       	ld.sh	r8,r9[0x0]
80003884:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003888:	76 0b       	ld.w	r11,r11[0x0]
8000388a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000388e:	2f f8       	sub	r8,-1
80003890:	5c 88       	casts.h	r8
80003892:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003894:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003898:	94 09       	ld.sh	r9,r10[0x0]
8000389a:	20 29       	sub	r9,2
8000389c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000389e:	30 0a       	mov	r10,0
800038a0:	f4 09 19 00 	cp.h	r9,r10
800038a4:	e0 89 00 20 	brgt	800038e4 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800038a8:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800038ac:	e0 46 00 ba 	cp.w	r6,186
800038b0:	c0 d1       	brne	800038ca <phy_rx_func+0x18a>
800038b2:	fe f8 0d 32 	ld.w	r8,pc[3378]
800038b6:	90 09       	ld.sh	r9,r8[0x0]
800038b8:	f4 09 19 00 	cp.h	r9,r10
800038bc:	c0 71       	brne	800038ca <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800038be:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800038c2:	70 0c       	ld.w	r12,r8[0x0]
800038c4:	f0 1f 03 49 	mcall	800045e8 <phy_rx_func+0xea8>
800038c8:	c0 98       	rjmp	800038da <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800038ca:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800038ce:	70 0c       	ld.w	r12,r8[0x0]
800038d0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800038d4:	70 0b       	ld.w	r11,r8[0x0]
800038d6:	f0 1f 03 43 	mcall	800045e0 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800038da:	30 09       	mov	r9,0
800038dc:	fe f8 0c ec 	ld.w	r8,pc[3308]
800038e0:	91 09       	st.w	r8[0x0],r9
800038e2:	c3 e8       	rjmp	8000395e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800038e4:	5c 86       	casts.h	r6
800038e6:	fe f9 0c fe 	ld.w	r9,pc[3326]
800038ea:	92 0a       	ld.sh	r10,r9[0x0]
800038ec:	0c 0a       	add	r10,r6
800038ee:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800038f0:	fe f9 0c ec 	ld.w	r9,pc[3308]
800038f4:	72 09       	ld.w	r9,r9[0x0]
800038f6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800038fa:	2f f8       	sub	r8,-1
800038fc:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003900:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003902:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003906:	92 08       	ld.sh	r8,r9[0x0]
80003908:	20 28       	sub	r8,2
8000390a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000390c:	30 09       	mov	r9,0
8000390e:	f2 08 19 00 	cp.h	r8,r9
80003912:	e0 89 00 26 	brgt	8000395e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003916:	30 39       	mov	r9,3
80003918:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	c2 08       	rjmp	8000395e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003920:	e6 16 00 ff 	andh	r6,0xff,COH
80003924:	fc 19 00 ba 	movh	r9,0xba
80003928:	12 36       	cp.w	r6,r9
8000392a:	c0 e1       	brne	80003946 <phy_rx_func+0x206>
8000392c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003930:	90 09       	ld.sh	r9,r8[0x0]
80003932:	30 08       	mov	r8,0
80003934:	f0 09 19 00 	cp.h	r9,r8
80003938:	c0 71       	brne	80003946 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000393a:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000393e:	70 0c       	ld.w	r12,r8[0x0]
80003940:	f0 1f 03 2a 	mcall	800045e8 <phy_rx_func+0xea8>
80003944:	c0 98       	rjmp	80003956 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003946:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000394a:	70 0c       	ld.w	r12,r8[0x0]
8000394c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003950:	70 0b       	ld.w	r11,r8[0x0]
80003952:	f0 1f 03 24 	mcall	800045e0 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003956:	30 09       	mov	r9,0
80003958:	fe f8 0c 70 	ld.w	r8,pc[3184]
8000395c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000395e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003962:	11 89       	ld.ub	r9,r8[0x0]
80003964:	30 08       	mov	r8,0
80003966:	f0 09 18 00 	cp.b	r9,r8
8000396a:	c1 31       	brne	80003990 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
8000396c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003970:	6c 0c       	ld.w	r12,r6[0x0]
80003972:	f0 1f 03 1a 	mcall	800045d8 <phy_rx_func+0xe98>
80003976:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000397a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000397c:	6c 0c       	ld.w	r12,r6[0x0]
8000397e:	f0 1f 03 17 	mcall	800045d8 <phy_rx_func+0xe98>
80003982:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003986:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003988:	30 19       	mov	r9,1
8000398a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000398e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003990:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003994:	70 08       	ld.w	r8,r8[0x0]
80003996:	58 28       	cp.w	r8,2
80003998:	e0 80 01 98 	breq	80003cc8 <phy_rx_func+0x588>
8000399c:	e0 8b 00 06 	brhi	800039a8 <phy_rx_func+0x268>
800039a0:	58 08       	cp.w	r8,0
800039a2:	c0 b0       	breq	800039b8 <phy_rx_func+0x278>
800039a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800039a8:	58 38       	cp.w	r8,3
800039aa:	e0 80 05 c5 	breq	80004534 <phy_rx_func+0xdf4>
800039ae:	58 48       	cp.w	r8,4
800039b0:	e0 81 06 05 	brne	800045ba <phy_rx_func+0xe7a>
800039b4:	e0 8f 02 4b 	bral	80003e4a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800039b8:	6e 28       	ld.w	r8,r7[0x8]
800039ba:	e0 6a 5a 5a 	mov	r10,23130
800039be:	ea 1a ab cd 	orh	r10,0xabcd
800039c2:	14 38       	cp.w	r8,r10
800039c4:	c0 71       	brne	800039d2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800039c6:	30 09       	mov	r9,0
800039c8:	fe f8 0c 38 	ld.w	r8,pc[3128]
800039cc:	91 09       	st.w	r8[0x0],r9
800039ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800039d2:	10 99       	mov	r9,r8
800039d4:	e0 19 00 00 	andl	r9,0x0
800039d8:	fc 1a ab cd 	movh	r10,0xabcd
800039dc:	14 39       	cp.w	r9,r10
800039de:	e0 81 05 ee 	brne	800045ba <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800039e2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800039e6:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800039ea:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800039ec:	6e 29       	ld.w	r9,r7[0x8]
800039ee:	e2 19 f0 00 	andl	r9,0xf000,COH
800039f2:	e0 49 c0 00 	cp.w	r9,49152
800039f6:	e0 81 00 ce 	brne	80003b92 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800039fa:	30 1a       	mov	r10,1
800039fc:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003a00:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003a02:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003a06:	72 09       	ld.w	r9,r9[0x0]
80003a08:	58 09       	cp.w	r9,0
80003a0a:	c0 71       	brne	80003a18 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a0c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003a10:	f0 1f 03 00 	mcall	80004610 <phy_rx_func+0xed0>
80003a14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003a18:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003a1c:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003a20:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003a22:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a26:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003a2a:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003a2e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003a30:	13 89       	ld.ub	r9,r9[0x0]
80003a32:	37 fa       	mov	r10,127
80003a34:	f4 09 18 00 	cp.b	r9,r10
80003a38:	c6 d0       	breq	80003b12 <phy_rx_func+0x3d2>
80003a3a:	e0 8b 00 0c 	brhi	80003a52 <phy_rx_func+0x312>
80003a3e:	31 2a       	mov	r10,18
80003a40:	f4 09 18 00 	cp.b	r9,r10
80003a44:	c4 20       	breq	80003ac8 <phy_rx_func+0x388>
80003a46:	31 3a       	mov	r10,19
80003a48:	f4 09 18 00 	cp.b	r9,r10
80003a4c:	e0 81 00 83 	brne	80003b52 <phy_rx_func+0x412>
80003a50:	c5 b8       	rjmp	80003b06 <phy_rx_func+0x3c6>
80003a52:	2f 09       	sub	r9,-16
80003a54:	30 1a       	mov	r10,1
80003a56:	f4 09 18 00 	cp.b	r9,r10
80003a5a:	e0 8b 00 7c 	brhi	80003b52 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003a5e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003a62:	e2 18 00 f0 	andl	r8,0xf0,COH
80003a66:	59 08       	cp.w	r8,16
80003a68:	c0 71       	brne	80003a76 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003a6a:	30 19       	mov	r9,1
80003a6c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003a70:	91 09       	st.w	r8[0x0],r9
80003a72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003a76:	e0 48 00 20 	cp.w	r8,32
80003a7a:	c2 11       	brne	80003abc <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003a7c:	30 a9       	mov	r9,10
80003a7e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003a82:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003a84:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003a88:	6c 08       	ld.w	r8,r6[0x0]
80003a8a:	f0 0a 11 ff 	rsub	r10,r8,-1
80003a8e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003a92:	2f f8       	sub	r8,-1
80003a94:	6e 0c       	ld.w	r12,r7[0x0]
80003a96:	f4 ca fe 00 	sub	r10,r10,-512
80003a9a:	30 0b       	mov	r11,0
80003a9c:	10 0c       	add	r12,r8
80003a9e:	f0 1f 02 e1 	mcall	80004620 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003aa2:	30 08       	mov	r8,0
80003aa4:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003aa6:	6e 0c       	ld.w	r12,r7[0x0]
80003aa8:	f0 1f 02 df 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003aac:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003ab0:	70 0c       	ld.w	r12,r8[0x0]
80003ab2:	f0 1f 02 ca 	mcall	800045d8 <phy_rx_func+0xe98>
80003ab6:	8f 0c       	st.w	r7[0x0],r12
80003ab8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003abc:	30 09       	mov	r9,0
80003abe:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003ac2:	91 09       	st.w	r8[0x0],r9
80003ac4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003ac8:	20 48       	sub	r8,4
80003aca:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003ace:	93 08       	st.w	r9[0x0],r8
80003ad0:	58 08       	cp.w	r8,0
80003ad2:	e0 80 05 74 	breq	800045ba <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003ad6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003ada:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003ade:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003ae2:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003ae4:	8e 69       	ld.sh	r9,r7[0xc]
80003ae6:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003aea:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003aec:	8e 79       	ld.sh	r9,r7[0xe]
80003aee:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003af0:	f0 1f 02 d0 	mcall	80004630 <phy_rx_func+0xef0>
80003af4:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003af8:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003afa:	30 49       	mov	r9,4
80003afc:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003b00:	91 09       	st.w	r8[0x0],r9
80003b02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003b06:	30 09       	mov	r9,0
80003b08:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003b0c:	91 09       	st.w	r8[0x0],r9
80003b0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b12:	20 48       	sub	r8,4
80003b14:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003b18:	93 08       	st.w	r9[0x0],r8
80003b1a:	58 08       	cp.w	r8,0
80003b1c:	e0 80 05 4f 	breq	800045ba <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003b20:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003b24:	70 09       	ld.w	r9,r8[0x0]
80003b26:	8e 7b       	ld.sh	r11,r7[0xe]
80003b28:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003b2c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003b30:	2f f9       	sub	r9,-1
80003b32:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003b34:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003b38:	70 09       	ld.w	r9,r8[0x0]
80003b3a:	20 29       	sub	r9,2
80003b3c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003b3e:	30 29       	mov	r9,2
80003b40:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003b44:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003b46:	30 39       	mov	r9,3
80003b48:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003b4c:	91 09       	st.w	r8[0x0],r9
80003b4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003b52:	30 3a       	mov	r10,3
80003b54:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003b58:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003b5a:	6e 2a       	ld.w	r10,r7[0x8]
80003b5c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003b60:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003b62:	6e 3a       	ld.w	r10,r7[0xc]
80003b64:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003b66:	59 48       	cp.w	r8,20
80003b68:	c0 61       	brne	80003b74 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003b6a:	31 89       	mov	r9,24
80003b6c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003b70:	91 09       	st.w	r8[0x0],r9
80003b72:	c0 a8       	rjmp	80003b86 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003b74:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003b78:	70 08       	ld.w	r8,r8[0x0]
80003b7a:	59 08       	cp.w	r8,16
80003b7c:	c0 51       	brne	80003b86 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003b7e:	31 09       	mov	r9,16
80003b80:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003b84:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b86:	30 49       	mov	r9,4
80003b88:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003b8c:	91 09       	st.w	r8[0x0],r9
80003b8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003b92:	e0 49 10 00 	cp.w	r9,4096
80003b96:	5f 1a       	srne	r10
80003b98:	e0 49 20 00 	cp.w	r9,8192
80003b9c:	5f 19       	srne	r9
80003b9e:	f5 e9 00 09 	and	r9,r10,r9
80003ba2:	e0 81 05 0c 	brne	800045ba <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003ba6:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003baa:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003bac:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003bb0:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003bb2:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003bb6:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003bb8:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003bbc:	72 09       	ld.w	r9,r9[0x0]
80003bbe:	58 09       	cp.w	r9,0
80003bc0:	c0 71       	brne	80003bce <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003bc2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003bc6:	f0 1f 02 93 	mcall	80004610 <phy_rx_func+0xed0>
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bce:	6e 2a       	ld.w	r10,r7[0x8]
80003bd0:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003bd4:	58 1a       	cp.w	r10,1
80003bd6:	e0 8b 00 4d 	brhi	80003c70 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003bda:	20 48       	sub	r8,4
80003bdc:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003be0:	93 08       	st.w	r9[0x0],r8
80003be2:	58 08       	cp.w	r8,0
80003be4:	e0 80 04 eb 	breq	800045ba <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003be8:	8e 68       	ld.sh	r8,r7[0xc]
80003bea:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003bee:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003bf2:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003bf4:	30 09       	mov	r9,0
80003bf6:	f2 08 19 00 	cp.h	r8,r9
80003bfa:	c0 70       	breq	80003c08 <phy_rx_func+0x4c8>
80003bfc:	30 19       	mov	r9,1
80003bfe:	f2 08 19 00 	cp.h	r8,r9
80003c02:	e0 81 04 dc 	brne	800045ba <phy_rx_func+0xe7a>
80003c06:	c2 68       	rjmp	80003c52 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c08:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003c0c:	70 0a       	ld.w	r10,r8[0x0]
80003c0e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003c12:	72 09       	ld.w	r9,r9[0x0]
80003c14:	8e 7b       	ld.sh	r11,r7[0xe]
80003c16:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003c1a:	70 09       	ld.w	r9,r8[0x0]
80003c1c:	2f f9       	sub	r9,-1
80003c1e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c20:	e0 49 00 ff 	cp.w	r9,255
80003c24:	e0 88 00 11 	brls	80003c46 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003c28:	30 09       	mov	r9,0
80003c2a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003c2c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003c30:	6e 0c       	ld.w	r12,r7[0x0]
80003c32:	f0 1f 02 7d 	mcall	80004624 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003c36:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003c3a:	70 0c       	ld.w	r12,r8[0x0]
80003c3c:	f0 1f 02 67 	mcall	800045d8 <phy_rx_func+0xe98>
80003c40:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003c42:	e0 80 04 bc 	breq	800045ba <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003c46:	30 29       	mov	r9,2
80003c48:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003c4c:	91 09       	st.w	r8[0x0],r9
80003c4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c52:	8e 79       	ld.sh	r9,r7[0xe]
80003c54:	30 38       	mov	r8,3
80003c56:	f0 09 19 00 	cp.h	r9,r8
80003c5a:	c0 51       	brne	80003c64 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003c5c:	30 19       	mov	r9,1
80003c5e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003c62:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003c64:	30 29       	mov	r9,2
80003c66:	fe f8 09 96 	ld.w	r8,pc[2454]
80003c6a:	91 09       	st.w	r8[0x0],r9
80003c6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003c70:	58 18       	cp.w	r8,1
80003c72:	e0 88 04 a4 	brls	800045ba <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003c76:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003c7a:	70 0a       	ld.w	r10,r8[0x0]
80003c7c:	6e 3b       	ld.w	r11,r7[0xc]
80003c7e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c82:	70 09       	ld.w	r9,r8[0x0]
80003c84:	2f f9       	sub	r9,-1
80003c86:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c88:	e0 49 00 ff 	cp.w	r9,255
80003c8c:	e0 88 00 11 	brls	80003cae <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003c90:	30 09       	mov	r9,0
80003c92:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c94:	fe f7 09 60 	ld.w	r7,pc[2400]
80003c98:	6e 0c       	ld.w	r12,r7[0x0]
80003c9a:	f0 1f 02 63 	mcall	80004624 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c9e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003ca2:	70 0c       	ld.w	r12,r8[0x0]
80003ca4:	f0 1f 02 4d 	mcall	800045d8 <phy_rx_func+0xe98>
80003ca8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003caa:	e0 80 04 88 	breq	800045ba <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003cae:	fe f9 09 56 	ld.w	r9,pc[2390]
80003cb2:	72 08       	ld.w	r8,r9[0x0]
80003cb4:	20 28       	sub	r8,2
80003cb6:	93 08       	st.w	r9[0x0],r8
80003cb8:	e0 80 04 81 	breq	800045ba <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003cbc:	30 29       	mov	r9,2
80003cbe:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003cc2:	91 09       	st.w	r8[0x0],r9
80003cc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003cc8:	fe f8 09 84 	ld.w	r8,pc[2436]
80003ccc:	70 0a       	ld.w	r10,r8[0x0]
80003cce:	fe f9 09 26 	ld.w	r9,pc[2342]
80003cd2:	72 09       	ld.w	r9,r9[0x0]
80003cd4:	8e 4b       	ld.sh	r11,r7[0x8]
80003cd6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003cda:	70 09       	ld.w	r9,r8[0x0]
80003cdc:	2f f9       	sub	r9,-1
80003cde:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ce0:	e0 49 00 ff 	cp.w	r9,255
80003ce4:	e0 88 00 16 	brls	80003d10 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003ce8:	30 09       	mov	r9,0
80003cea:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cec:	fe f6 09 08 	ld.w	r6,pc[2312]
80003cf0:	6c 0c       	ld.w	r12,r6[0x0]
80003cf2:	f0 1f 02 4d 	mcall	80004624 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003cf6:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003cfa:	70 0c       	ld.w	r12,r8[0x0]
80003cfc:	f0 1f 02 37 	mcall	800045d8 <phy_rx_func+0xe98>
80003d00:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d02:	c0 71       	brne	80003d10 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003d04:	30 09       	mov	r9,0
80003d06:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003d0a:	91 09       	st.w	r8[0x0],r9
80003d0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003d10:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003d14:	72 08       	ld.w	r8,r9[0x0]
80003d16:	20 28       	sub	r8,2
80003d18:	93 08       	st.w	r9[0x0],r8
80003d1a:	c0 71       	brne	80003d28 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003d1c:	30 09       	mov	r9,0
80003d1e:	fe f8 08 de 	ld.w	r8,pc[2270]
80003d22:	91 09       	st.w	r8[0x0],r9
80003d24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003d28:	fe f8 09 24 	ld.w	r8,pc[2340]
80003d2c:	70 0a       	ld.w	r10,r8[0x0]
80003d2e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003d32:	72 09       	ld.w	r9,r9[0x0]
80003d34:	8e 5b       	ld.sh	r11,r7[0xa]
80003d36:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d3a:	70 09       	ld.w	r9,r8[0x0]
80003d3c:	2f f9       	sub	r9,-1
80003d3e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d40:	e0 49 00 ff 	cp.w	r9,255
80003d44:	e0 88 00 16 	brls	80003d70 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003d48:	30 09       	mov	r9,0
80003d4a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d4c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003d50:	6c 0c       	ld.w	r12,r6[0x0]
80003d52:	f0 1f 02 35 	mcall	80004624 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d56:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003d5a:	70 0c       	ld.w	r12,r8[0x0]
80003d5c:	f0 1f 02 1f 	mcall	800045d8 <phy_rx_func+0xe98>
80003d60:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d62:	c0 71       	brne	80003d70 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003d64:	30 09       	mov	r9,0
80003d66:	fe f8 08 96 	ld.w	r8,pc[2198]
80003d6a:	91 09       	st.w	r8[0x0],r9
80003d6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003d70:	fe f9 08 94 	ld.w	r9,pc[2196]
80003d74:	72 08       	ld.w	r8,r9[0x0]
80003d76:	20 28       	sub	r8,2
80003d78:	93 08       	st.w	r9[0x0],r8
80003d7a:	c0 71       	brne	80003d88 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003d7c:	30 09       	mov	r9,0
80003d7e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003d82:	91 09       	st.w	r8[0x0],r9
80003d84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003d88:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003d8c:	70 0a       	ld.w	r10,r8[0x0]
80003d8e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003d92:	72 09       	ld.w	r9,r9[0x0]
80003d94:	8e 6b       	ld.sh	r11,r7[0xc]
80003d96:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d9a:	70 09       	ld.w	r9,r8[0x0]
80003d9c:	2f f9       	sub	r9,-1
80003d9e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003da0:	e0 49 00 ff 	cp.w	r9,255
80003da4:	e0 88 00 16 	brls	80003dd0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003da8:	30 09       	mov	r9,0
80003daa:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003dac:	fe f6 08 48 	ld.w	r6,pc[2120]
80003db0:	6c 0c       	ld.w	r12,r6[0x0]
80003db2:	f0 1f 02 1d 	mcall	80004624 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003db6:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003dba:	70 0c       	ld.w	r12,r8[0x0]
80003dbc:	f0 1f 02 07 	mcall	800045d8 <phy_rx_func+0xe98>
80003dc0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003dc2:	c0 71       	brne	80003dd0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003dc4:	30 09       	mov	r9,0
80003dc6:	fe f8 08 36 	ld.w	r8,pc[2102]
80003dca:	91 09       	st.w	r8[0x0],r9
80003dcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003dd0:	fe f9 08 34 	ld.w	r9,pc[2100]
80003dd4:	72 08       	ld.w	r8,r9[0x0]
80003dd6:	20 28       	sub	r8,2
80003dd8:	93 08       	st.w	r9[0x0],r8
80003dda:	c0 71       	brne	80003de8 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003ddc:	30 09       	mov	r9,0
80003dde:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003de2:	91 09       	st.w	r8[0x0],r9
80003de4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003de8:	fe f8 08 64 	ld.w	r8,pc[2148]
80003dec:	70 0a       	ld.w	r10,r8[0x0]
80003dee:	fe f9 08 06 	ld.w	r9,pc[2054]
80003df2:	72 09       	ld.w	r9,r9[0x0]
80003df4:	8e 7b       	ld.sh	r11,r7[0xe]
80003df6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003dfa:	70 09       	ld.w	r9,r8[0x0]
80003dfc:	2f f9       	sub	r9,-1
80003dfe:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e00:	e0 49 00 ff 	cp.w	r9,255
80003e04:	e0 88 00 16 	brls	80003e30 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003e08:	30 09       	mov	r9,0
80003e0a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e0c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003e10:	6e 0c       	ld.w	r12,r7[0x0]
80003e12:	f0 1f 02 05 	mcall	80004624 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e16:	fe f8 07 da 	ld.w	r8,pc[2010]
80003e1a:	70 0c       	ld.w	r12,r8[0x0]
80003e1c:	f0 1f 01 ef 	mcall	800045d8 <phy_rx_func+0xe98>
80003e20:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003e22:	c0 71       	brne	80003e30 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003e24:	30 09       	mov	r9,0
80003e26:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003e2a:	91 09       	st.w	r8[0x0],r9
80003e2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e30:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003e34:	72 08       	ld.w	r8,r9[0x0]
80003e36:	20 28       	sub	r8,2
80003e38:	93 08       	st.w	r9[0x0],r8
80003e3a:	e0 81 03 c0 	brne	800045ba <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003e3e:	30 09       	mov	r9,0
80003e40:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003e44:	91 09       	st.w	r8[0x0],r9
80003e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003e4a:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003e4e:	11 89       	ld.ub	r9,r8[0x0]
80003e50:	31 28       	mov	r8,18
80003e52:	f0 09 18 00 	cp.b	r9,r8
80003e56:	e0 81 01 4c 	brne	800040ee <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003e5a:	ef 39 00 09 	ld.ub	r9,r7[9]
80003e5e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003e62:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003e64:	11 89       	ld.ub	r9,r8[0x0]
80003e66:	3f 28       	mov	r8,-14
80003e68:	f0 09 18 00 	cp.b	r9,r8
80003e6c:	e0 81 01 3b 	brne	800040e2 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003e70:	30 19       	mov	r9,1
80003e72:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e76:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003e78:	6e 29       	ld.w	r9,r7[0x8]
80003e7a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003e7e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003e82:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003e84:	8e 59       	ld.sh	r9,r7[0xa]
80003e86:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e8a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003e8c:	8e 69       	ld.sh	r9,r7[0xc]
80003e8e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003e90:	8e 79       	ld.sh	r9,r7[0xe]
80003e92:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003e94:	fe f8 07 88 	ld.w	r8,pc[1928]
80003e98:	fe f9 07 60 	ld.w	r9,pc[1888]
80003e9c:	72 0a       	ld.w	r10,r9[0x0]
80003e9e:	70 09       	ld.w	r9,r8[0x0]
80003ea0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003ea4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ea8:	70 09       	ld.w	r9,r8[0x0]
80003eaa:	2f f9       	sub	r9,-1
80003eac:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003eae:	e0 49 01 ff 	cp.w	r9,511
80003eb2:	e0 88 00 16 	brls	80003ede <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003eb6:	30 09       	mov	r9,0
80003eb8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003eba:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003ebe:	6c 0c       	ld.w	r12,r6[0x0]
80003ec0:	f0 1f 01 d9 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ec4:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003ec8:	70 0c       	ld.w	r12,r8[0x0]
80003eca:	f0 1f 01 c4 	mcall	800045d8 <phy_rx_func+0xe98>
80003ece:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ed0:	c0 71       	brne	80003ede <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003ed2:	30 09       	mov	r9,0
80003ed4:	fe f8 07 28 	ld.w	r8,pc[1832]
80003ed8:	91 09       	st.w	r8[0x0],r9
80003eda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ede:	fe f9 07 26 	ld.w	r9,pc[1830]
80003ee2:	72 08       	ld.w	r8,r9[0x0]
80003ee4:	20 18       	sub	r8,1
80003ee6:	93 08       	st.w	r9[0x0],r8
80003ee8:	c0 71       	brne	80003ef6 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003eea:	30 09       	mov	r9,0
80003eec:	fe f8 07 10 	ld.w	r8,pc[1808]
80003ef0:	91 09       	st.w	r8[0x0],r9
80003ef2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003ef6:	fe f8 07 26 	ld.w	r8,pc[1830]
80003efa:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003efe:	72 0a       	ld.w	r10,r9[0x0]
80003f00:	70 09       	ld.w	r9,r8[0x0]
80003f02:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f06:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f0a:	70 09       	ld.w	r9,r8[0x0]
80003f0c:	2f f9       	sub	r9,-1
80003f0e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f10:	e0 49 01 ff 	cp.w	r9,511
80003f14:	e0 88 00 16 	brls	80003f40 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f18:	30 09       	mov	r9,0
80003f1a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f1c:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003f20:	6c 0c       	ld.w	r12,r6[0x0]
80003f22:	f0 1f 01 c1 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f26:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003f2a:	70 0c       	ld.w	r12,r8[0x0]
80003f2c:	f0 1f 01 ab 	mcall	800045d8 <phy_rx_func+0xe98>
80003f30:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f32:	c0 71       	brne	80003f40 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003f34:	30 09       	mov	r9,0
80003f36:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003f3a:	91 09       	st.w	r8[0x0],r9
80003f3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f40:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003f44:	72 08       	ld.w	r8,r9[0x0]
80003f46:	20 18       	sub	r8,1
80003f48:	93 08       	st.w	r9[0x0],r8
80003f4a:	c0 71       	brne	80003f58 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003f4c:	30 09       	mov	r9,0
80003f4e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003f52:	91 09       	st.w	r8[0x0],r9
80003f54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003f58:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003f5c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003f60:	72 0a       	ld.w	r10,r9[0x0]
80003f62:	70 09       	ld.w	r9,r8[0x0]
80003f64:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f68:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f6c:	70 09       	ld.w	r9,r8[0x0]
80003f6e:	2f f9       	sub	r9,-1
80003f70:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f72:	e0 49 01 ff 	cp.w	r9,511
80003f76:	e0 88 00 16 	brls	80003fa2 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f7a:	30 09       	mov	r9,0
80003f7c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f7e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003f82:	6c 0c       	ld.w	r12,r6[0x0]
80003f84:	f0 1f 01 a8 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f88:	fe f8 06 68 	ld.w	r8,pc[1640]
80003f8c:	70 0c       	ld.w	r12,r8[0x0]
80003f8e:	f0 1f 01 93 	mcall	800045d8 <phy_rx_func+0xe98>
80003f92:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f94:	c0 71       	brne	80003fa2 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003f96:	30 09       	mov	r9,0
80003f98:	fe f8 06 64 	ld.w	r8,pc[1636]
80003f9c:	91 09       	st.w	r8[0x0],r9
80003f9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003fa2:	fe f9 06 62 	ld.w	r9,pc[1634]
80003fa6:	72 08       	ld.w	r8,r9[0x0]
80003fa8:	20 18       	sub	r8,1
80003faa:	93 08       	st.w	r9[0x0],r8
80003fac:	c0 71       	brne	80003fba <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003fae:	30 09       	mov	r9,0
80003fb0:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003fb4:	91 09       	st.w	r8[0x0],r9
80003fb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003fba:	fe f8 06 62 	ld.w	r8,pc[1634]
80003fbe:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003fc2:	72 0a       	ld.w	r10,r9[0x0]
80003fc4:	70 09       	ld.w	r9,r8[0x0]
80003fc6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003fca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fce:	70 09       	ld.w	r9,r8[0x0]
80003fd0:	2f f9       	sub	r9,-1
80003fd2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fd4:	e0 49 01 ff 	cp.w	r9,511
80003fd8:	e0 88 00 16 	brls	80004004 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003fdc:	30 09       	mov	r9,0
80003fde:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003fe0:	fe f6 06 18 	ld.w	r6,pc[1560]
80003fe4:	6c 0c       	ld.w	r12,r6[0x0]
80003fe6:	f0 1f 01 90 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003fea:	fe f8 06 06 	ld.w	r8,pc[1542]
80003fee:	70 0c       	ld.w	r12,r8[0x0]
80003ff0:	f0 1f 01 7a 	mcall	800045d8 <phy_rx_func+0xe98>
80003ff4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ff6:	c0 71       	brne	80004004 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003ff8:	30 09       	mov	r9,0
80003ffa:	fe f8 06 02 	ld.w	r8,pc[1538]
80003ffe:	91 09       	st.w	r8[0x0],r9
80004000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004004:	fe f9 06 00 	ld.w	r9,pc[1536]
80004008:	72 08       	ld.w	r8,r9[0x0]
8000400a:	20 18       	sub	r8,1
8000400c:	93 08       	st.w	r9[0x0],r8
8000400e:	c0 71       	brne	8000401c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004010:	30 09       	mov	r9,0
80004012:	fe f8 05 ea 	ld.w	r8,pc[1514]
80004016:	91 09       	st.w	r8[0x0],r9
80004018:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000401c:	fe f8 06 00 	ld.w	r8,pc[1536]
80004020:	fe f9 05 d8 	ld.w	r9,pc[1496]
80004024:	72 0a       	ld.w	r10,r9[0x0]
80004026:	70 09       	ld.w	r9,r8[0x0]
80004028:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000402c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004030:	70 09       	ld.w	r9,r8[0x0]
80004032:	2f f9       	sub	r9,-1
80004034:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004036:	e0 49 01 ff 	cp.w	r9,511
8000403a:	e0 88 00 16 	brls	80004066 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000403e:	30 09       	mov	r9,0
80004040:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004042:	fe f6 05 b6 	ld.w	r6,pc[1462]
80004046:	6c 0c       	ld.w	r12,r6[0x0]
80004048:	f0 1f 01 77 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000404c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80004050:	70 0c       	ld.w	r12,r8[0x0]
80004052:	f0 1f 01 62 	mcall	800045d8 <phy_rx_func+0xe98>
80004056:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004058:	c0 71       	brne	80004066 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000405a:	30 09       	mov	r9,0
8000405c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80004060:	91 09       	st.w	r8[0x0],r9
80004062:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004066:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000406a:	72 08       	ld.w	r8,r9[0x0]
8000406c:	20 18       	sub	r8,1
8000406e:	93 08       	st.w	r9[0x0],r8
80004070:	c0 71       	brne	8000407e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80004072:	30 09       	mov	r9,0
80004074:	fe f8 05 88 	ld.w	r8,pc[1416]
80004078:	91 09       	st.w	r8[0x0],r9
8000407a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000407e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80004082:	fe f9 05 76 	ld.w	r9,pc[1398]
80004086:	72 0a       	ld.w	r10,r9[0x0]
80004088:	70 09       	ld.w	r9,r8[0x0]
8000408a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000408e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004092:	70 09       	ld.w	r9,r8[0x0]
80004094:	2f f9       	sub	r9,-1
80004096:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004098:	e0 49 01 ff 	cp.w	r9,511
8000409c:	e0 88 00 16 	brls	800040c8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800040a0:	30 09       	mov	r9,0
800040a2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800040a4:	fe f7 05 54 	ld.w	r7,pc[1364]
800040a8:	6e 0c       	ld.w	r12,r7[0x0]
800040aa:	f0 1f 01 5f 	mcall	80004624 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800040ae:	fe f8 05 42 	ld.w	r8,pc[1346]
800040b2:	70 0c       	ld.w	r12,r8[0x0]
800040b4:	f0 1f 01 49 	mcall	800045d8 <phy_rx_func+0xe98>
800040b8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800040ba:	c0 71       	brne	800040c8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800040bc:	30 09       	mov	r9,0
800040be:	fe f8 05 3e 	ld.w	r8,pc[1342]
800040c2:	91 09       	st.w	r8[0x0],r9
800040c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800040c8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800040cc:	72 08       	ld.w	r8,r9[0x0]
800040ce:	20 18       	sub	r8,1
800040d0:	93 08       	st.w	r9[0x0],r8
800040d2:	e0 81 02 74 	brne	800045ba <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800040d6:	30 09       	mov	r9,0
800040d8:	fe f8 05 24 	ld.w	r8,pc[1316]
800040dc:	91 09       	st.w	r8[0x0],r9
800040de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800040e2:	30 09       	mov	r9,0
800040e4:	fe f8 05 18 	ld.w	r8,pc[1304]
800040e8:	91 09       	st.w	r8[0x0],r9
800040ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800040ee:	fe f8 05 26 	ld.w	r8,pc[1318]
800040f2:	11 89       	ld.ub	r9,r8[0x0]
800040f4:	3f 28       	mov	r8,-14
800040f6:	f0 09 18 00 	cp.b	r9,r8
800040fa:	c4 31       	brne	80004180 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800040fc:	8e 49       	ld.sh	r9,r7[0x8]
800040fe:	fe f8 05 56 	ld.w	r8,pc[1366]
80004102:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004104:	fe f8 05 18 	ld.w	r8,pc[1304]
80004108:	fe f9 04 f0 	ld.w	r9,pc[1264]
8000410c:	72 0a       	ld.w	r10,r9[0x0]
8000410e:	70 09       	ld.w	r9,r8[0x0]
80004110:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004114:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004118:	70 09       	ld.w	r9,r8[0x0]
8000411a:	2f f9       	sub	r9,-1
8000411c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000411e:	e0 49 01 ff 	cp.w	r9,511
80004122:	e0 88 00 16 	brls	8000414e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004126:	30 09       	mov	r9,0
80004128:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000412a:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000412e:	6e 0c       	ld.w	r12,r7[0x0]
80004130:	f0 1f 01 3d 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004134:	fe f8 04 bc 	ld.w	r8,pc[1212]
80004138:	70 0c       	ld.w	r12,r8[0x0]
8000413a:	f0 1f 01 28 	mcall	800045d8 <phy_rx_func+0xe98>
8000413e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004140:	c0 71       	brne	8000414e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80004142:	30 09       	mov	r9,0
80004144:	fe f8 04 b8 	ld.w	r8,pc[1208]
80004148:	91 09       	st.w	r8[0x0],r9
8000414a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000414e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80004152:	72 08       	ld.w	r8,r9[0x0]
80004154:	20 18       	sub	r8,1
80004156:	93 08       	st.w	r9[0x0],r8
80004158:	c0 71       	brne	80004166 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000415a:	30 09       	mov	r9,0
8000415c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80004160:	91 09       	st.w	r8[0x0],r9
80004162:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80004166:	20 18       	sub	r8,1
80004168:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000416c:	93 08       	st.w	r9[0x0],r8
8000416e:	58 08       	cp.w	r8,0
80004170:	e0 81 02 25 	brne	800045ba <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80004174:	30 09       	mov	r9,0
80004176:	fe f8 04 86 	ld.w	r8,pc[1158]
8000417a:	91 09       	st.w	r8[0x0],r9
8000417c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80004180:	fe f8 04 94 	ld.w	r8,pc[1172]
80004184:	11 89       	ld.ub	r9,r8[0x0]
80004186:	3f 38       	mov	r8,-13
80004188:	f0 09 18 00 	cp.b	r9,r8
8000418c:	e0 81 01 0c 	brne	800043a4 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004190:	8e 49       	ld.sh	r9,r7[0x8]
80004192:	fe f8 04 c2 	ld.w	r8,pc[1218]
80004196:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80004198:	8e 59       	ld.sh	r9,r7[0xa]
8000419a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000419c:	8e 69       	ld.sh	r9,r7[0xc]
8000419e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800041a0:	fe f8 04 7c 	ld.w	r8,pc[1148]
800041a4:	fe f9 04 54 	ld.w	r9,pc[1108]
800041a8:	72 0a       	ld.w	r10,r9[0x0]
800041aa:	70 09       	ld.w	r9,r8[0x0]
800041ac:	ef 3b 00 08 	ld.ub	r11,r7[8]
800041b0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041b4:	70 09       	ld.w	r9,r8[0x0]
800041b6:	2f f9       	sub	r9,-1
800041b8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041ba:	e0 49 01 ff 	cp.w	r9,511
800041be:	e0 88 00 16 	brls	800041ea <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800041c2:	30 09       	mov	r9,0
800041c4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041c6:	fe f6 04 32 	ld.w	r6,pc[1074]
800041ca:	6c 0c       	ld.w	r12,r6[0x0]
800041cc:	f0 1f 01 16 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041d0:	fe f8 04 20 	ld.w	r8,pc[1056]
800041d4:	70 0c       	ld.w	r12,r8[0x0]
800041d6:	f0 1f 01 01 	mcall	800045d8 <phy_rx_func+0xe98>
800041da:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041dc:	c0 71       	brne	800041ea <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800041de:	30 09       	mov	r9,0
800041e0:	fe f8 04 1c 	ld.w	r8,pc[1052]
800041e4:	91 09       	st.w	r8[0x0],r9
800041e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041ea:	fe f9 04 1a 	ld.w	r9,pc[1050]
800041ee:	72 08       	ld.w	r8,r9[0x0]
800041f0:	20 18       	sub	r8,1
800041f2:	93 08       	st.w	r9[0x0],r8
800041f4:	c0 71       	brne	80004202 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800041f6:	30 09       	mov	r9,0
800041f8:	fe f8 04 04 	ld.w	r8,pc[1028]
800041fc:	91 09       	st.w	r8[0x0],r9
800041fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80004202:	fe f8 04 1a 	ld.w	r8,pc[1050]
80004206:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000420a:	72 0a       	ld.w	r10,r9[0x0]
8000420c:	70 09       	ld.w	r9,r8[0x0]
8000420e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80004212:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004216:	70 09       	ld.w	r9,r8[0x0]
80004218:	2f f9       	sub	r9,-1
8000421a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000421c:	e0 49 01 ff 	cp.w	r9,511
80004220:	e0 88 00 16 	brls	8000424c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80004224:	30 09       	mov	r9,0
80004226:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004228:	fe f6 03 d0 	ld.w	r6,pc[976]
8000422c:	6c 0c       	ld.w	r12,r6[0x0]
8000422e:	f0 1f 00 fe 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004232:	fe f8 03 be 	ld.w	r8,pc[958]
80004236:	70 0c       	ld.w	r12,r8[0x0]
80004238:	f0 1f 00 e8 	mcall	800045d8 <phy_rx_func+0xe98>
8000423c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000423e:	c0 71       	brne	8000424c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80004240:	30 09       	mov	r9,0
80004242:	fe f8 03 ba 	ld.w	r8,pc[954]
80004246:	91 09       	st.w	r8[0x0],r9
80004248:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000424c:	fe f9 03 b8 	ld.w	r9,pc[952]
80004250:	72 08       	ld.w	r8,r9[0x0]
80004252:	20 18       	sub	r8,1
80004254:	93 08       	st.w	r9[0x0],r8
80004256:	c0 71       	brne	80004264 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80004258:	30 09       	mov	r9,0
8000425a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000425e:	91 09       	st.w	r8[0x0],r9
80004260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80004264:	fe f8 03 b8 	ld.w	r8,pc[952]
80004268:	fe f9 03 90 	ld.w	r9,pc[912]
8000426c:	72 0a       	ld.w	r10,r9[0x0]
8000426e:	70 09       	ld.w	r9,r8[0x0]
80004270:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004274:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004278:	70 09       	ld.w	r9,r8[0x0]
8000427a:	2f f9       	sub	r9,-1
8000427c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000427e:	e0 49 01 ff 	cp.w	r9,511
80004282:	e0 88 00 16 	brls	800042ae <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004286:	30 09       	mov	r9,0
80004288:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000428a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000428e:	6c 0c       	ld.w	r12,r6[0x0]
80004290:	f0 1f 00 e5 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004294:	fe f8 03 5c 	ld.w	r8,pc[860]
80004298:	70 0c       	ld.w	r12,r8[0x0]
8000429a:	f0 1f 00 d0 	mcall	800045d8 <phy_rx_func+0xe98>
8000429e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042a0:	c0 71       	brne	800042ae <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800042a2:	30 09       	mov	r9,0
800042a4:	fe f8 03 58 	ld.w	r8,pc[856]
800042a8:	91 09       	st.w	r8[0x0],r9
800042aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800042ae:	fe f9 03 56 	ld.w	r9,pc[854]
800042b2:	72 08       	ld.w	r8,r9[0x0]
800042b4:	20 18       	sub	r8,1
800042b6:	93 08       	st.w	r9[0x0],r8
800042b8:	c0 71       	brne	800042c6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800042ba:	30 09       	mov	r9,0
800042bc:	fe f8 03 40 	ld.w	r8,pc[832]
800042c0:	91 09       	st.w	r8[0x0],r9
800042c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800042c6:	fe f8 03 56 	ld.w	r8,pc[854]
800042ca:	fe f9 03 2e 	ld.w	r9,pc[814]
800042ce:	72 0a       	ld.w	r10,r9[0x0]
800042d0:	70 09       	ld.w	r9,r8[0x0]
800042d2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800042d6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042da:	70 09       	ld.w	r9,r8[0x0]
800042dc:	2f f9       	sub	r9,-1
800042de:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042e0:	e0 49 01 ff 	cp.w	r9,511
800042e4:	e0 88 00 16 	brls	80004310 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800042e8:	30 09       	mov	r9,0
800042ea:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042ec:	fe f6 03 0c 	ld.w	r6,pc[780]
800042f0:	6c 0c       	ld.w	r12,r6[0x0]
800042f2:	f0 1f 00 cd 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042f6:	fe f8 02 fa 	ld.w	r8,pc[762]
800042fa:	70 0c       	ld.w	r12,r8[0x0]
800042fc:	f0 1f 00 b7 	mcall	800045d8 <phy_rx_func+0xe98>
80004300:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004302:	c0 71       	brne	80004310 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80004304:	30 09       	mov	r9,0
80004306:	fe f8 02 f6 	ld.w	r8,pc[758]
8000430a:	91 09       	st.w	r8[0x0],r9
8000430c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004310:	fe f9 02 f4 	ld.w	r9,pc[756]
80004314:	72 08       	ld.w	r8,r9[0x0]
80004316:	20 18       	sub	r8,1
80004318:	93 08       	st.w	r9[0x0],r8
8000431a:	c0 71       	brne	80004328 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
8000431c:	30 09       	mov	r9,0
8000431e:	fe f8 02 de 	ld.w	r8,pc[734]
80004322:	91 09       	st.w	r8[0x0],r9
80004324:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004328:	fe f8 02 f4 	ld.w	r8,pc[756]
8000432c:	fe f9 02 cc 	ld.w	r9,pc[716]
80004330:	72 0a       	ld.w	r10,r9[0x0]
80004332:	70 09       	ld.w	r9,r8[0x0]
80004334:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004338:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000433c:	70 09       	ld.w	r9,r8[0x0]
8000433e:	2f f9       	sub	r9,-1
80004340:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004342:	e0 49 01 ff 	cp.w	r9,511
80004346:	e0 88 00 16 	brls	80004372 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000434a:	30 09       	mov	r9,0
8000434c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000434e:	fe f7 02 aa 	ld.w	r7,pc[682]
80004352:	6e 0c       	ld.w	r12,r7[0x0]
80004354:	f0 1f 00 b4 	mcall	80004624 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004358:	fe f8 02 98 	ld.w	r8,pc[664]
8000435c:	70 0c       	ld.w	r12,r8[0x0]
8000435e:	f0 1f 00 9f 	mcall	800045d8 <phy_rx_func+0xe98>
80004362:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004364:	c0 71       	brne	80004372 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80004366:	30 09       	mov	r9,0
80004368:	fe f8 02 94 	ld.w	r8,pc[660]
8000436c:	91 09       	st.w	r8[0x0],r9
8000436e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004372:	fe f9 02 92 	ld.w	r9,pc[658]
80004376:	72 08       	ld.w	r8,r9[0x0]
80004378:	20 18       	sub	r8,1
8000437a:	93 08       	st.w	r9[0x0],r8
8000437c:	c0 71       	brne	8000438a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000437e:	30 09       	mov	r9,0
80004380:	fe f8 02 7c 	ld.w	r8,pc[636]
80004384:	91 09       	st.w	r8[0x0],r9
80004386:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000438a:	20 18       	sub	r8,1
8000438c:	fe f9 02 78 	ld.w	r9,pc[632]
80004390:	93 08       	st.w	r9[0x0],r8
80004392:	58 08       	cp.w	r8,0
80004394:	e0 81 01 13 	brne	800045ba <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004398:	30 09       	mov	r9,0
8000439a:	fe f8 02 62 	ld.w	r8,pc[610]
8000439e:	91 09       	st.w	r8[0x0],r9
800043a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800043a4:	fe f8 02 70 	ld.w	r8,pc[624]
800043a8:	11 89       	ld.ub	r9,r8[0x0]
800043aa:	30 48       	mov	r8,4
800043ac:	f0 09 18 00 	cp.b	r9,r8
800043b0:	c0 80       	breq	800043c0 <phy_rx_func+0xc80>
800043b2:	fe f8 02 62 	ld.w	r8,pc[610]
800043b6:	11 89       	ld.ub	r9,r8[0x0]
800043b8:	30 38       	mov	r8,3
800043ba:	f0 09 18 00 	cp.b	r9,r8
800043be:	c1 41       	brne	800043e6 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800043c0:	6e 29       	ld.w	r9,r7[0x8]
800043c2:	fe f8 02 7a 	ld.w	r8,pc[634]
800043c6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800043c8:	6e 39       	ld.w	r9,r7[0xc]
800043ca:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800043cc:	fe f9 02 38 	ld.w	r9,pc[568]
800043d0:	72 08       	ld.w	r8,r9[0x0]
800043d2:	20 88       	sub	r8,8
800043d4:	93 08       	st.w	r9[0x0],r8
800043d6:	e0 81 00 f2 	brne	800045ba <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800043da:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800043dc:	fe f9 02 20 	ld.w	r9,pc[544]
800043e0:	93 08       	st.w	r9[0x0],r8
800043e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800043e6:	fe f8 02 2e 	ld.w	r8,pc[558]
800043ea:	11 89       	ld.ub	r9,r8[0x0]
800043ec:	31 38       	mov	r8,19
800043ee:	f0 09 18 00 	cp.b	r9,r8
800043f2:	e0 81 00 9c 	brne	8000452a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800043f6:	fe f8 02 62 	ld.w	r8,pc[610]
800043fa:	11 88       	ld.ub	r8,r8[0x0]
800043fc:	30 c9       	mov	r9,12
800043fe:	f2 08 18 00 	cp.b	r8,r9
80004402:	e0 81 00 7b 	brne	800044f8 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80004406:	8e 49       	ld.sh	r9,r7[0x8]
80004408:	fe f8 02 54 	ld.w	r8,pc[596]
8000440c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004410:	30 09       	mov	r9,0
80004412:	fe f8 02 46 	ld.w	r8,pc[582]
80004416:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004418:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000441c:	3f 38       	mov	r8,-13
8000441e:	f0 09 18 00 	cp.b	r9,r8
80004422:	c6 61       	brne	800044ee <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80004424:	10 99       	mov	r9,r8
80004426:	4f c8       	lddpc	r8,80004614 <phy_rx_func+0xed4>
80004428:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000442a:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000442e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80004432:	4f 58       	lddpc	r8,80004604 <phy_rx_func+0xec4>
80004434:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80004436:	30 19       	mov	r9,1
80004438:	fe f8 02 0c 	ld.w	r8,pc[524]
8000443c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000443e:	8e 79       	ld.sh	r9,r7[0xe]
80004440:	fe f8 02 14 	ld.w	r8,pc[532]
80004444:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80004446:	4f 68       	lddpc	r8,8000461c <phy_rx_func+0xedc>
80004448:	4e c9       	lddpc	r9,800045f8 <phy_rx_func+0xeb8>
8000444a:	72 0a       	ld.w	r10,r9[0x0]
8000444c:	70 09       	ld.w	r9,r8[0x0]
8000444e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004452:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004456:	70 09       	ld.w	r9,r8[0x0]
80004458:	2f f9       	sub	r9,-1
8000445a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000445c:	e0 49 01 ff 	cp.w	r9,511
80004460:	e0 88 00 13 	brls	80004486 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80004464:	30 09       	mov	r9,0
80004466:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004468:	4e 46       	lddpc	r6,800045f8 <phy_rx_func+0xeb8>
8000446a:	6c 0c       	ld.w	r12,r6[0x0]
8000446c:	f0 1f 00 6e 	mcall	80004624 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004470:	4e 08       	lddpc	r8,800045f0 <phy_rx_func+0xeb0>
80004472:	70 0c       	ld.w	r12,r8[0x0]
80004474:	f0 1f 00 59 	mcall	800045d8 <phy_rx_func+0xe98>
80004478:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000447a:	c0 61       	brne	80004486 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
8000447c:	30 09       	mov	r9,0
8000447e:	4e 08       	lddpc	r8,800045fc <phy_rx_func+0xebc>
80004480:	91 09       	st.w	r8[0x0],r9
80004482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004486:	4e 09       	lddpc	r9,80004604 <phy_rx_func+0xec4>
80004488:	72 08       	ld.w	r8,r9[0x0]
8000448a:	20 18       	sub	r8,1
8000448c:	93 08       	st.w	r9[0x0],r8
8000448e:	c0 61       	brne	8000449a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004490:	30 09       	mov	r9,0
80004492:	4d b8       	lddpc	r8,800045fc <phy_rx_func+0xebc>
80004494:	91 09       	st.w	r8[0x0],r9
80004496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000449a:	4e 18       	lddpc	r8,8000461c <phy_rx_func+0xedc>
8000449c:	4d 79       	lddpc	r9,800045f8 <phy_rx_func+0xeb8>
8000449e:	72 0a       	ld.w	r10,r9[0x0]
800044a0:	70 09       	ld.w	r9,r8[0x0]
800044a2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800044a6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800044aa:	70 09       	ld.w	r9,r8[0x0]
800044ac:	2f f9       	sub	r9,-1
800044ae:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800044b0:	e0 49 01 ff 	cp.w	r9,511
800044b4:	e0 88 00 13 	brls	800044da <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800044b8:	30 09       	mov	r9,0
800044ba:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800044bc:	4c f7       	lddpc	r7,800045f8 <phy_rx_func+0xeb8>
800044be:	6e 0c       	ld.w	r12,r7[0x0]
800044c0:	f0 1f 00 59 	mcall	80004624 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800044c4:	4c b8       	lddpc	r8,800045f0 <phy_rx_func+0xeb0>
800044c6:	70 0c       	ld.w	r12,r8[0x0]
800044c8:	f0 1f 00 44 	mcall	800045d8 <phy_rx_func+0xe98>
800044cc:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800044ce:	c0 61       	brne	800044da <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800044d0:	30 09       	mov	r9,0
800044d2:	4c b8       	lddpc	r8,800045fc <phy_rx_func+0xebc>
800044d4:	91 09       	st.w	r8[0x0],r9
800044d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800044da:	4c b9       	lddpc	r9,80004604 <phy_rx_func+0xec4>
800044dc:	72 08       	ld.w	r8,r9[0x0]
800044de:	20 18       	sub	r8,1
800044e0:	93 08       	st.w	r9[0x0],r8
800044e2:	c6 c1       	brne	800045ba <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800044e4:	30 09       	mov	r9,0
800044e6:	4c 68       	lddpc	r8,800045fc <phy_rx_func+0xebc>
800044e8:	91 09       	st.w	r8[0x0],r9
800044ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800044ee:	30 09       	mov	r9,0
800044f0:	4c 38       	lddpc	r8,800045fc <phy_rx_func+0xebc>
800044f2:	91 09       	st.w	r8[0x0],r9
800044f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800044f8:	8e 4a       	ld.sh	r10,r7[0x8]
800044fa:	4d 99       	lddpc	r9,8000465c <phy_rx_func+0xf1c>
800044fc:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004500:	4d 6a       	lddpc	r10,80004658 <phy_rx_func+0xf18>
80004502:	15 88       	ld.ub	r8,r10[0x0]
80004504:	f0 cb ff ff 	sub	r11,r8,-1
80004508:	8e 5c       	ld.sh	r12,r7[0xa]
8000450a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
8000450e:	f0 cb ff fe 	sub	r11,r8,-2
80004512:	8e 6c       	ld.sh	r12,r7[0xc]
80004514:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004518:	f0 cb ff fd 	sub	r11,r8,-3
8000451c:	8e 7c       	ld.sh	r12,r7[0xe]
8000451e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80004522:	2f c8       	sub	r8,-4
80004524:	b4 88       	st.b	r10[0x0],r8
80004526:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
8000452a:	30 09       	mov	r9,0
8000452c:	4b 48       	lddpc	r8,800045fc <phy_rx_func+0xebc>
8000452e:	91 09       	st.w	r8[0x0],r9
80004530:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004534:	4c 08       	lddpc	r8,80004634 <phy_rx_func+0xef4>
80004536:	70 09       	ld.w	r9,r8[0x0]
80004538:	8e 4b       	ld.sh	r11,r7[0x8]
8000453a:	4c 0a       	lddpc	r10,80004638 <phy_rx_func+0xef8>
8000453c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004540:	2f f9       	sub	r9,-1
80004542:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004544:	4b 58       	lddpc	r8,80004618 <phy_rx_func+0xed8>
80004546:	70 09       	ld.w	r9,r8[0x0]
80004548:	20 29       	sub	r9,2
8000454a:	91 09       	st.w	r8[0x0],r9
8000454c:	70 08       	ld.w	r8,r8[0x0]
8000454e:	58 08       	cp.w	r8,0
80004550:	c2 f1       	brne	800045ae <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80004552:	30 09       	mov	r9,0
80004554:	4b 88       	lddpc	r8,80004634 <phy_rx_func+0xef4>
80004556:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004558:	8e 59       	ld.sh	r9,r7[0xa]
8000455a:	fe 78 82 12 	mov	r8,-32238
8000455e:	f0 09 19 00 	cp.h	r9,r8
80004562:	c2 11       	brne	800045a4 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004564:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004568:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000456c:	4a f8       	lddpc	r8,80004628 <phy_rx_func+0xee8>
8000456e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004570:	8e 59       	ld.sh	r9,r7[0xa]
80004572:	4a f8       	lddpc	r8,8000462c <phy_rx_func+0xeec>
80004574:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004576:	8e 69       	ld.sh	r9,r7[0xc]
80004578:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
8000457a:	f0 1f 00 2e 	mcall	80004630 <phy_rx_func+0xef0>
8000457e:	4a 18       	lddpc	r8,80004600 <phy_rx_func+0xec0>
80004580:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004582:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004586:	31 38       	mov	r8,19
80004588:	f0 09 18 00 	cp.b	r9,r8
8000458c:	c0 71       	brne	8000459a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
8000458e:	10 99       	mov	r9,r8
80004590:	4a 18       	lddpc	r8,80004614 <phy_rx_func+0xed4>
80004592:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004594:	30 09       	mov	r9,0
80004596:	49 c8       	lddpc	r8,80004604 <phy_rx_func+0xec4>
80004598:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000459a:	30 49       	mov	r9,4
8000459c:	49 88       	lddpc	r8,800045fc <phy_rx_func+0xebc>
8000459e:	91 09       	st.w	r8[0x0],r9
800045a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800045a4:	30 09       	mov	r9,0
800045a6:	49 68       	lddpc	r8,800045fc <phy_rx_func+0xebc>
800045a8:	91 09       	st.w	r8[0x0],r9
800045aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800045ae:	4a dc       	lddpc	r12,80004660 <phy_rx_func+0xf20>
800045b0:	f0 1f 00 18 	mcall	80004610 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
800045b4:	30 09       	mov	r9,0
800045b6:	49 28       	lddpc	r8,800045fc <phy_rx_func+0xebc>
800045b8:	91 09       	st.w	r8[0x0],r9
800045ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800045be:	00 00       	add	r0,r0
800045c0:	00 00       	add	r0,r0
800045c2:	0a d0       	st.w	--r5,r0
800045c4:	00 00       	add	r0,r0
800045c6:	0a e8       	st.h	--r5,r8
800045c8:	00 00       	add	r0,r0
800045ca:	0a c8       	st.b	r5++,r8
800045cc:	00 00       	add	r0,r0
800045ce:	0a aa       	st.w	r5++,r10
800045d0:	00 00       	add	r0,r0
800045d2:	0a 98       	mov	r8,r5
800045d4:	00 00       	add	r0,r0
800045d6:	0a c0       	st.b	r5++,r0
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	35 c0       	mov	r0,92
800045dc:	00 00       	add	r0,r0
800045de:	0a b8       	st.h	r5++,r8
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	34 d8       	mov	r8,77
800045e4:	00 00       	add	r0,r0
800045e6:	0a cc       	st.b	r5++,r12
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	35 0c       	mov	r12,80
800045ec:	00 00       	add	r0,r0
800045ee:	0a a9       	st.w	r5++,r9
800045f0:	00 00       	add	r0,r0
800045f2:	0a c4       	st.b	r5++,r4
800045f4:	00 00       	add	r0,r0
800045f6:	0a d4       	st.w	--r5,r4
800045f8:	00 00       	add	r0,r0
800045fa:	0a ac       	st.w	r5++,r12
800045fc:	00 00       	add	r0,r0
800045fe:	0a f4       	st.b	--r5,r4
80004600:	00 00       	add	r0,r0
80004602:	0a dc       	st.w	--r5,r12
80004604:	00 00       	add	r0,r0
80004606:	0a 94       	mov	r4,r5
80004608:	00 00       	add	r0,r0
8000460a:	0a 5d       	eor	sp,r5
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	e9 68 80 00 	st.b	r4[-32768],r8
80004612:	80 f0       	ld.uh	r0,r0[0xe]
80004614:	00 00       	add	r0,r0
80004616:	0a a8       	st.w	r5++,r8
80004618:	00 00       	add	r0,r0
8000461a:	0b 00       	ld.w	r0,r5++
8000461c:	00 00       	add	r0,r0
8000461e:	0a e0       	st.h	--r5,r0
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	89 56       	st.w	r4[0x14],r6
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	34 f4       	mov	r4,79
80004628:	00 00       	add	r0,r0
8000462a:	0a 74       	tst	r4,r5
8000462c:	00 00       	add	r0,r0
8000462e:	1f 30       	ld.ub	r0,pc++
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	34 a8       	mov	r8,74
80004634:	00 00       	add	r0,r0
80004636:	0a 9c       	mov	r12,r5
80004638:	00 00       	add	r0,r0
8000463a:	1e 34       	cp.w	r4,pc
8000463c:	00 00       	add	r0,r0
8000463e:	0a a0       	st.w	r5++,r0
80004640:	00 00       	add	r0,r0
80004642:	0a 60       	and	r0,r5
80004644:	00 00       	add	r0,r0
80004646:	0a 7e       	tst	lr,r5
80004648:	00 00       	add	r0,r0
8000464a:	0a f8       	st.b	--r5,r8
8000464c:	00 00       	add	r0,r0
8000464e:	0a b4       	st.h	r5++,r4
80004650:	00 00       	add	r0,r0
80004652:	0a 85       	andn	r5,r5
80004654:	00 00       	add	r0,r0
80004656:	1e 2c       	rsub	r12,pc
80004658:	00 00       	add	r0,r0
8000465a:	0a ec       	st.h	--r5,r12
8000465c:	00 00       	add	r0,r0
8000465e:	1f 34       	ld.ub	r4,pc++
80004660:	80 00       	ld.sh	r0,r0[0x0]
80004662:	e9 80       	*unknown*

80004664 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004664:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80004666:	49 a8       	lddpc	r8,800046cc <pdca_int_handler+0x68>
80004668:	70 09       	ld.w	r9,r8[0x0]
8000466a:	2f f9       	sub	r9,-1
8000466c:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000466e:	49 98       	lddpc	r8,800046d0 <pdca_int_handler+0x6c>
80004670:	11 89       	ld.ub	r9,r8[0x0]
80004672:	ec 19 00 01 	eorl	r9,0x1
80004676:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004678:	11 89       	ld.ub	r9,r8[0x0]
8000467a:	a5 69       	lsl	r9,0x4
8000467c:	2f c9       	sub	r9,-4
8000467e:	49 6a       	lddpc	r10,800046d4 <pdca_int_handler+0x70>
80004680:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004682:	fe 7a 00 40 	mov	r10,-65472
80004686:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004688:	30 39       	mov	r9,3
8000468a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
8000468c:	11 8a       	ld.ub	r10,r8[0x0]
8000468e:	a5 6a       	lsl	r10,0x4
80004690:	2f ca       	sub	r10,-4
80004692:	49 28       	lddpc	r8,800046d8 <pdca_int_handler+0x74>
80004694:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004696:	fe 78 00 00 	mov	r8,-65536
8000469a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000469c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000469e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800046a0:	48 f8       	lddpc	r8,800046dc <pdca_int_handler+0x78>
800046a2:	70 08       	ld.w	r8,r8[0x0]
800046a4:	58 08       	cp.w	r8,0
800046a6:	c0 70       	breq	800046b4 <pdca_int_handler+0x50>
800046a8:	48 a9       	lddpc	r9,800046d0 <pdca_int_handler+0x6c>
800046aa:	13 89       	ld.ub	r9,r9[0x0]
800046ac:	a5 69       	lsl	r9,0x4
800046ae:	48 bc       	lddpc	r12,800046d8 <pdca_int_handler+0x74>
800046b0:	12 0c       	add	r12,r9
800046b2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800046b4:	48 b8       	lddpc	r8,800046e0 <pdca_int_handler+0x7c>
800046b6:	70 08       	ld.w	r8,r8[0x0]
800046b8:	58 08       	cp.w	r8,0
800046ba:	c0 70       	breq	800046c8 <pdca_int_handler+0x64>
800046bc:	48 59       	lddpc	r9,800046d0 <pdca_int_handler+0x6c>
800046be:	13 89       	ld.ub	r9,r9[0x0]
800046c0:	a5 69       	lsl	r9,0x4
800046c2:	48 5c       	lddpc	r12,800046d4 <pdca_int_handler+0x70>
800046c4:	12 0c       	add	r12,r9
800046c6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800046c8:	d4 02       	popm	lr
800046ca:	d6 03       	rete
800046cc:	00 00       	add	r0,r0
800046ce:	0b 08       	ld.w	r8,r5++
800046d0:	00 00       	add	r0,r0
800046d2:	97 54       	st.w	r11[0x14],r4
800046d4:	00 00       	add	r0,r0
800046d6:	97 7c       	st.w	r11[0x1c],r12
800046d8:	00 00       	add	r0,r0
800046da:	97 5c       	st.w	r11[0x14],r12
800046dc:	00 00       	add	r0,r0
800046de:	0b 04       	ld.w	r4,r5++
800046e0:	00 00       	add	r0,r0
800046e2:	0b 0c       	ld.w	r12,r5++

800046e4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800046e4:	fe 78 10 00 	mov	r8,-61440
800046e8:	e0 69 0d c0 	mov	r9,3520
800046ec:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800046f0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800046f4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800046f8:	fe 78 34 00 	mov	r8,-52224
800046fc:	e0 69 80 00 	mov	r9,32768
80004700:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004702:	30 09       	mov	r9,0
80004704:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004706:	e0 69 04 21 	mov	r9,1057
8000470a:	ea 19 3f 20 	orh	r9,0x3f20
8000470e:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004710:	e0 69 02 9f 	mov	r9,671
80004714:	ea 19 01 00 	orh	r9,0x100
80004718:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
8000471a:	e0 6a 04 02 	mov	r10,1026
8000471e:	ea 1a 3f 20 	orh	r10,0x3f20
80004722:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004724:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004726:	5e fc       	retal	r12

80004728 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004728:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000472a:	30 19       	mov	r9,1
8000472c:	49 78       	lddpc	r8,80004788 <local_start_PDC+0x60>
8000472e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004730:	fe 78 00 00 	mov	r8,-65536
80004734:	30 7b       	mov	r11,7
80004736:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004738:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000473a:	49 59       	lddpc	r9,8000478c <local_start_PDC+0x64>
8000473c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004740:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004742:	30 3a       	mov	r10,3
80004744:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004746:	30 1c       	mov	r12,1
80004748:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000474a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000474c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000474e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004750:	30 2c       	mov	r12,2
80004752:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004754:	48 f9       	lddpc	r9,80004790 <local_start_PDC+0x68>
80004756:	e0 68 5a 5a 	mov	r8,23130
8000475a:	ea 18 ab cd 	orh	r8,0xabcd
8000475e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004760:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004762:	30 0e       	mov	lr,0
80004764:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004766:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004768:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000476a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000476c:	fe 78 00 40 	mov	r8,-65472
80004770:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004772:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004774:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004778:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000477a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000477c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000477e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004780:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004782:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004784:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004786:	d8 02       	popm	pc
80004788:	00 00       	add	r0,r0
8000478a:	97 54       	st.w	r11[0x14],r4
8000478c:	00 00       	add	r0,r0
8000478e:	97 5c       	st.w	r11[0x14],r12
80004790:	00 00       	add	r0,r0
80004792:	97 7c       	st.w	r11[0x1c],r12

80004794 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004794:	48 38       	lddpc	r8,800047a0 <register_rx_tx_func+0xc>
80004796:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004798:	48 38       	lddpc	r8,800047a4 <register_rx_tx_func+0x10>
8000479a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000479c:	5e fc       	retal	r12
8000479e:	00 00       	add	r0,r0
800047a0:	00 00       	add	r0,r0
800047a2:	0b 04       	ld.w	r4,r5++
800047a4:	00 00       	add	r0,r0
800047a6:	0b 0c       	ld.w	r12,r5++

800047a8 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800047a8:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800047aa:	fe 78 10 00 	mov	r8,-61440
800047ae:	30 29       	mov	r9,2
800047b0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800047b4:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800047b8:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
800047ba:	30 3a       	mov	r10,3
800047bc:	36 0b       	mov	r11,96
800047be:	49 4c       	lddpc	r12,8000480c <ssc_init+0x64>
800047c0:	f0 1f 00 14 	mcall	80004810 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
800047c4:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800047c6:	fe 79 10 00 	mov	r9,-61440
800047ca:	f2 f8 01 60 	ld.w	r8,r9[352]
800047ce:	e2 18 00 02 	andl	r8,0x2,COH
800047d2:	cf c0       	breq	800047ca <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800047d4:	fe 79 10 00 	mov	r9,-61440
800047d8:	f2 f8 01 60 	ld.w	r8,r9[352]
800047dc:	e2 18 00 02 	andl	r8,0x2,COH
800047e0:	cf c1       	brne	800047d8 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
800047e2:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800047e4:	f0 1f 00 0c 	mcall	80004814 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
800047e8:	f0 1f 00 0c 	mcall	80004818 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800047ec:	fe 79 00 00 	mov	r9,-65536
800047f0:	30 18       	mov	r8,1
800047f2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800047f4:	fe 7a 00 40 	mov	r10,-65472
800047f8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800047fa:	e0 6b 01 01 	mov	r11,257
800047fe:	fe 7a 34 00 	mov	r10,-52224
80004802:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80004804:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80004806:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004808:	d8 02       	popm	pc
8000480a:	00 00       	add	r0,r0
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	46 64       	lddsp	r4,sp[0x198]
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	63 cc       	ld.w	r12,r1[0x70]
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	46 e4       	lddsp	r4,sp[0x1b8]
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	47 28       	lddsp	r8,sp[0x1c8]

8000481c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000481c:	48 28       	lddpc	r8,80004824 <xcmp_register_app_list+0x8>
8000481e:	91 0c       	st.w	r8[0x0],r12
}
80004820:	5e fc       	retal	r12
80004822:	00 00       	add	r0,r0
80004824:	00 00       	add	r0,r0
80004826:	97 9c       	st.w	r11[0x24],r12

80004828 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004828:	eb cd 40 80 	pushm	r7,lr
8000482c:	fa cd 01 00 	sub	sp,sp,256
80004830:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004832:	16 98       	mov	r8,r11
80004834:	2f 08       	sub	r8,-16
80004836:	af a8       	sbr	r8,0xe
80004838:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000483a:	3f f8       	mov	r8,-1
8000483c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000483e:	30 b9       	mov	r9,11
80004840:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004842:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004844:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004846:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004848:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000484a:	f6 ca ff fe 	sub	r10,r11,-2
8000484e:	18 9b       	mov	r11,r12
80004850:	fa cc ff f0 	sub	r12,sp,-16
80004854:	f0 1f 00 05 	mcall	80004868 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004858:	2f e7       	sub	r7,-2
8000485a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000485c:	1a 9c       	mov	r12,sp
8000485e:	f0 1f 00 04 	mcall	8000486c <xcmp_tx+0x44>
}
80004862:	2c 0d       	sub	sp,-256
80004864:	e3 cd 80 80 	ldm	sp++,r7,pc
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	88 0e       	ld.sh	lr,r4[0x0]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	4e 38       	lddpc	r8,800049f8 <xcmp_IdleTestTone+0x4c>

80004870 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80004870:	d4 21       	pushm	r4-r7,lr
80004872:	fa cd 00 d0 	sub	sp,sp,208
80004876:	18 94       	mov	r4,r12
80004878:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000487a:	e0 68 01 00 	mov	r8,256
8000487e:	f0 0b 19 00 	cp.h	r11,r8
80004882:	e0 8b 00 38 	brhi	800048f2 <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004886:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000488a:	e0 68 04 1d 	mov	r8,1053
8000488e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004890:	30 18       	mov	r8,1
80004892:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004894:	32 08       	mov	r8,32
80004896:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004898:	30 28       	mov	r8,2
8000489a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
8000489c:	30 48       	mov	r8,4
8000489e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800048a0:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
800048a4:	ea 1a 0c 00 	orh	r10,0xc00
800048a8:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800048aa:	30 4a       	mov	r10,4
800048ac:	1a 9b       	mov	r11,sp
800048ae:	fa cc ff f4 	sub	r12,sp,-12
800048b2:	f0 1f 00 12 	mcall	800048f8 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800048b6:	30 f8       	mov	r8,15
800048b8:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800048bc:	3a 78       	mov	r8,-89
800048be:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800048c2:	30 08       	mov	r8,0
800048c4:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800048c8:	0e 9a       	mov	r10,r7
800048ca:	5c 7a       	castu.h	r10
800048cc:	f4 08 16 08 	lsr	r8,r10,0x8
800048d0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800048d4:	0e 96       	mov	r6,r7
800048d6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800048da:	08 9b       	mov	r11,r4
800048dc:	fa cc ff eb 	sub	r12,sp,-21
800048e0:	f0 1f 00 06 	mcall	800048f8 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800048e4:	ee cb ff f3 	sub	r11,r7,-13
800048e8:	5c 5b       	castu.b	r11
800048ea:	fa cc ff fa 	sub	r12,sp,-6
800048ee:	f0 1f 00 04 	mcall	800048fc <xcmp_data_session_req+0x8c>
}
800048f2:	2c cd       	sub	sp,-208
800048f4:	d8 22       	popm	r4-r7,pc
800048f6:	00 00       	add	r0,r0
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	88 0e       	ld.sh	lr,r4[0x0]
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	48 28       	lddpc	r8,80004904 <xcmp_DeviceInitializationStatus_request+0x4>

80004900 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004900:	d4 01       	pushm	lr
80004902:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004906:	fe 78 b4 00 	mov	r8,-19456
8000490a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000490c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004910:	30 89       	mov	r9,8
80004912:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004914:	30 19       	mov	r9,1
80004916:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004918:	30 09       	mov	r9,0
8000491a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000491c:	30 5a       	mov	r10,5
8000491e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004920:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004922:	30 7a       	mov	r10,7
80004924:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004926:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004928:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000492a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000492e:	30 9b       	mov	r11,9
80004930:	fa cc ff fe 	sub	r12,sp,-2
80004934:	f0 1f 00 02 	mcall	8000493c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004938:	2c dd       	sub	sp,-204
8000493a:	d8 02       	popm	pc
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	48 28       	lddpc	r8,80004944 <xcmp_opcode_not_supported+0x4>

80004940 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004940:	d4 01       	pushm	lr
80004942:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004946:	fe 78 80 00 	mov	r8,-32768
8000494a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000494c:	30 38       	mov	r8,3
8000494e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004950:	30 1b       	mov	r11,1
80004952:	fa cc ff fe 	sub	r12,sp,-2
80004956:	f0 1f 00 03 	mcall	80004960 <xcmp_opcode_not_supported+0x20>
}
8000495a:	2c dd       	sub	sp,-204
8000495c:	d8 02       	popm	pc
8000495e:	00 00       	add	r0,r0
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	48 28       	lddpc	r8,80004968 <xcmp_exec_func+0x4>

80004964 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004964:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004966:	96 88       	ld.uh	r8,r11[0x0]
80004968:	e2 18 f0 00 	andl	r8,0xf000,COH
8000496c:	e0 48 80 00 	cp.w	r8,32768
80004970:	c0 f0       	breq	8000498e <xcmp_exec_func+0x2a>
80004972:	e0 48 b0 00 	cp.w	r8,45056
80004976:	c1 20       	breq	8000499a <xcmp_exec_func+0x36>
80004978:	58 08       	cp.w	r8,0
8000497a:	c1 51       	brne	800049a4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000497c:	78 08       	ld.w	r8,r12[0x0]
8000497e:	58 08       	cp.w	r8,0
80004980:	c0 40       	breq	80004988 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004982:	16 9c       	mov	r12,r11
80004984:	5d 18       	icall	r8
80004986:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004988:	f0 1f 00 08 	mcall	800049a8 <xcmp_exec_func+0x44>
8000498c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000498e:	78 18       	ld.w	r8,r12[0x4]
80004990:	58 08       	cp.w	r8,0
80004992:	c0 90       	breq	800049a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004994:	16 9c       	mov	r12,r11
80004996:	5d 18       	icall	r8
80004998:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000499a:	78 28       	ld.w	r8,r12[0x8]
8000499c:	58 08       	cp.w	r8,0
8000499e:	c0 30       	breq	800049a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800049a0:	16 9c       	mov	r12,r11
800049a2:	5d 18       	icall	r8
800049a4:	d8 02       	popm	pc
800049a6:	00 00       	add	r0,r0
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	49 40       	lddpc	r0,800049f8 <xcmp_IdleTestTone+0x4c>

800049ac <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800049ac:	d4 01       	pushm	lr
800049ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800049b2:	e0 68 04 09 	mov	r8,1033
800049b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800049b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800049bc:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800049be:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800049c2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800049c4:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800049c6:	30 09       	mov	r9,0
800049c8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800049ca:	fb 69 00 08 	st.b	sp[8],r9
800049ce:	fa c8 ff f7 	sub	r8,sp,-9
800049d2:	b0 89       	st.b	r8[0x0],r9
800049d4:	fa c8 ff f6 	sub	r8,sp,-10
800049d8:	b0 89       	st.b	r8[0x0],r9
800049da:	fa c8 ff f5 	sub	r8,sp,-11
800049de:	b0 89       	st.b	r8[0x0],r9
800049e0:	fa c8 ff f4 	sub	r8,sp,-12
800049e4:	b0 89       	st.b	r8[0x0],r9
800049e6:	fa c8 ff f3 	sub	r8,sp,-13
800049ea:	b0 89       	st.b	r8[0x0],r9
800049ec:	fa c8 ff f2 	sub	r8,sp,-14
800049f0:	b0 89       	st.b	r8[0x0],r9
800049f2:	fa c8 ff f1 	sub	r8,sp,-15
800049f6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800049f8:	30 cb       	mov	r11,12
800049fa:	fa cc ff fe 	sub	r12,sp,-2
800049fe:	f0 1f 00 03 	mcall	80004a08 <xcmp_IdleTestTone+0x5c>
}
80004a02:	2c dd       	sub	sp,-204
80004a04:	d8 02       	popm	pc
80004a06:	00 00       	add	r0,r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 28       	lddpc	r8,80004a10 <xcmp_init+0x4>

80004a0c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004a0c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004a0e:	48 dc       	lddpc	r12,80004a40 <xcmp_init+0x34>
80004a10:	f0 1f 00 0d 	mcall	80004a44 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004a14:	30 4b       	mov	r11,4
80004a16:	31 4c       	mov	r12,20
80004a18:	f0 1f 00 0c 	mcall	80004a48 <xcmp_init+0x3c>
80004a1c:	48 c8       	lddpc	r8,80004a4c <xcmp_init+0x40>
80004a1e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004a20:	30 09       	mov	r9,0
80004a22:	1a d9       	st.w	--sp,r9
80004a24:	1a d9       	st.w	--sp,r9
80004a26:	1a d9       	st.w	--sp,r9
80004a28:	30 38       	mov	r8,3
80004a2a:	e0 6a 04 00 	mov	r10,1024
80004a2e:	48 9b       	lddpc	r11,80004a50 <xcmp_init+0x44>
80004a30:	48 9c       	lddpc	r12,80004a54 <xcmp_init+0x48>
80004a32:	f0 1f 00 0a 	mcall	80004a58 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004a36:	f0 1f 00 0a 	mcall	80004a5c <xcmp_init+0x50>
80004a3a:	2f dd       	sub	sp,-12
	
}
80004a3c:	d8 02       	popm	pc
80004a3e:	00 00       	add	r0,r0
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	4b 5c       	lddpc	r12,80004b14 <xcmp_rx_process+0xb4>
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	4b a8       	lddpc	r8,80004b2c <xcmp_rx_process+0xcc>
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	74 84       	ld.w	r4,r10[0x20]
80004a4c:	00 00       	add	r0,r0
80004a4e:	0b 28       	ld.uh	r8,r5++
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	e9 ac 80 00 	ldc.w	cp4,cr0,r12[0x0]
80004a56:	4a 60       	lddpc	r0,80004aec <xcmp_rx_process+0x8c>
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	7b a0       	ld.w	r0,sp[0x68]
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	4b e0       	lddpc	r0,80004b54 <xcmp_rx_process+0xf4>

80004a60 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004a60:	d4 31       	pushm	r0-r7,lr
80004a62:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a64:	4b 16       	lddpc	r6,80004b28 <xcmp_rx_process+0xc8>
80004a66:	30 05       	mov	r5,0
80004a68:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004a6a:	4b 13       	lddpc	r3,80004b2c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004a6c:	4b 12       	lddpc	r2,80004b30 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004a6e:	4b 21       	lddpc	r1,80004b34 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004a70:	4b 20       	lddpc	r0,80004b38 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a72:	6c 0c       	ld.w	r12,r6[0x0]
80004a74:	0a 99       	mov	r9,r5
80004a76:	08 9a       	mov	r10,r4
80004a78:	1a 9b       	mov	r11,sp
80004a7a:	f0 1f 00 31 	mcall	80004b3c <xcmp_rx_process+0xdc>
80004a7e:	58 1c       	cp.w	r12,1
80004a80:	cf 91       	brne	80004a72 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004a82:	40 0b       	lddsp	r11,sp[0x0]
80004a84:	58 0b       	cp.w	r11,0
80004a86:	cf 60       	breq	80004a72 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004a88:	96 0a       	ld.sh	r10,r11[0x0]
80004a8a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a8e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004a92:	59 c8       	cp.w	r8,28
80004a94:	c1 e0       	breq	80004ad0 <xcmp_rx_process+0x70>
80004a96:	e0 89 00 07 	brgt	80004aa4 <xcmp_rx_process+0x44>
80004a9a:	58 e8       	cp.w	r8,14
80004a9c:	c0 e0       	breq	80004ab8 <xcmp_rx_process+0x58>
80004a9e:	58 f8       	cp.w	r8,15
80004aa0:	c2 41       	brne	80004ae8 <xcmp_rx_process+0x88>
80004aa2:	c0 f8       	rjmp	80004ac0 <xcmp_rx_process+0x60>
80004aa4:	e0 48 01 09 	cp.w	r8,265
80004aa8:	c1 80       	breq	80004ad8 <xcmp_rx_process+0x78>
80004aaa:	e0 48 01 0a 	cp.w	r8,266
80004aae:	c1 90       	breq	80004ae0 <xcmp_rx_process+0x80>
80004ab0:	e0 48 00 2c 	cp.w	r8,44
80004ab4:	c1 a1       	brne	80004ae8 <xcmp_rx_process+0x88>
80004ab6:	c0 98       	rjmp	80004ac8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004ab8:	4a 2c       	lddpc	r12,80004b40 <xcmp_rx_process+0xe0>
80004aba:	f0 1f 00 23 	mcall	80004b44 <xcmp_rx_process+0xe4>
					break;
80004abe:	c2 f8       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004ac0:	4a 2c       	lddpc	r12,80004b48 <xcmp_rx_process+0xe8>
80004ac2:	f0 1f 00 21 	mcall	80004b44 <xcmp_rx_process+0xe4>
					break;
80004ac6:	c2 b8       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004ac8:	4a 1c       	lddpc	r12,80004b4c <xcmp_rx_process+0xec>
80004aca:	f0 1f 00 1f 	mcall	80004b44 <xcmp_rx_process+0xe4>
					break;
80004ace:	c2 78       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004ad0:	04 9c       	mov	r12,r2
80004ad2:	f0 1f 00 1d 	mcall	80004b44 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004ad6:	c2 38       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004ad8:	02 9c       	mov	r12,r1
80004ada:	f0 1f 00 1b 	mcall	80004b44 <xcmp_rx_process+0xe4>
					break;
80004ade:	c1 f8       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004ae0:	00 9c       	mov	r12,r0
80004ae2:	f0 1f 00 19 	mcall	80004b44 <xcmp_rx_process+0xe4>
					break;
80004ae6:	c1 b8       	rjmp	80004b1c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004ae8:	12 98       	mov	r8,r9
80004aea:	e2 18 04 00 	andl	r8,0x400,COH
80004aee:	c0 70       	breq	80004afc <xcmp_rx_process+0x9c>
80004af0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004af4:	e0 48 00 68 	cp.w	r8,104
80004af8:	e0 8a 00 08 	brle	80004b08 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004afc:	e2 19 f0 00 	andl	r9,0xf000,COH
80004b00:	c0 e1       	brne	80004b1c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004b02:	f0 1f 00 14 	mcall	80004b50 <xcmp_rx_process+0xf0>
80004b06:	c0 b8       	rjmp	80004b1c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004b08:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004b0c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004b10:	49 19       	lddpc	r9,80004b54 <xcmp_rx_process+0xf4>
80004b12:	72 08       	ld.w	r8,r9[0x0]
80004b14:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004b18:	f0 1f 00 0b 	mcall	80004b44 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004b1c:	66 0c       	ld.w	r12,r3[0x0]
80004b1e:	40 0b       	lddsp	r11,sp[0x0]
80004b20:	f0 1f 00 0e 	mcall	80004b58 <xcmp_rx_process+0xf8>
80004b24:	ca 7b       	rjmp	80004a72 <xcmp_rx_process+0x12>
80004b26:	00 00       	add	r0,r0
80004b28:	00 00       	add	r0,r0
80004b2a:	0b 28       	ld.uh	r8,r5++
80004b2c:	00 00       	add	r0,r0
80004b2e:	0a c0       	st.b	r5++,r0
80004b30:	00 00       	add	r0,r0
80004b32:	0b 38       	ld.ub	r8,r5++
80004b34:	00 00       	add	r0,r0
80004b36:	0b 2c       	ld.uh	r12,r5++
80004b38:	00 00       	add	r0,r0
80004b3a:	0b 1c       	ld.sh	r12,r5++
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	71 20       	ld.w	r0,r8[0x48]
80004b40:	00 00       	add	r0,r0
80004b42:	0b 50       	ld.sh	r0,--r5
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	49 64       	lddpc	r4,80004b9c <xcmp_rx+0x40>
80004b48:	00 00       	add	r0,r0
80004b4a:	0b 10       	ld.sh	r0,r5++
80004b4c:	00 00       	add	r0,r0
80004b4e:	0b 44       	ld.w	r4,--r5
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	49 40       	lddpc	r0,80004ba0 <xcmp_rx+0x44>
80004b54:	00 00       	add	r0,r0
80004b56:	97 9c       	st.w	r11[0x24],r12
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	35 44       	mov	r4,84

80004b5c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004b5c:	eb cd 40 90 	pushm	r4,r7,lr
80004b60:	20 1d       	sub	sp,4
80004b62:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b66:	48 c8       	lddpc	r8,80004b94 <xcmp_rx+0x38>
80004b68:	70 0c       	ld.w	r12,r8[0x0]
80004b6a:	f0 1f 00 0c 	mcall	80004b98 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004b6e:	c1 00       	breq	80004b8e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b70:	fa c7 ff fc 	sub	r7,sp,-4
80004b74:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004b76:	e0 6a 00 ca 	mov	r10,202
80004b7a:	08 9b       	mov	r11,r4
80004b7c:	f0 1f 00 08 	mcall	80004b9c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004b80:	48 88       	lddpc	r8,80004ba0 <xcmp_rx+0x44>
80004b82:	70 0c       	ld.w	r12,r8[0x0]
80004b84:	30 09       	mov	r9,0
80004b86:	12 9a       	mov	r10,r9
80004b88:	1a 9b       	mov	r11,sp
80004b8a:	f0 1f 00 07 	mcall	80004ba4 <xcmp_rx+0x48>
	}	
}
80004b8e:	2f fd       	sub	sp,-4
80004b90:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004b94:	00 00       	add	r0,r0
80004b96:	0a c0       	st.b	r5++,r0
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	36 f0       	mov	r0,111
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	88 0e       	ld.sh	lr,r4[0x0]
80004ba0:	00 00       	add	r0,r0
80004ba2:	0b 28       	ld.uh	r8,r5++
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	73 2c       	ld.w	r12,r9[0x48]

80004ba8 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004ba8:	48 28       	lddpc	r8,80004bb0 <xnl_register_xcmp_func+0x8>
80004baa:	91 0c       	st.w	r8[0x0],r12
}
80004bac:	5e fc       	retal	r12
80004bae:	00 00       	add	r0,r0
80004bb0:	00 00       	add	r0,r0
80004bb2:	0b 7c       	ld.ub	r12,--r5

80004bb4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004bb4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004bb6:	48 88       	lddpc	r8,80004bd4 <xnl_get_msg_ack_func+0x20>
80004bb8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004bba:	98 49       	ld.sh	r9,r12[0x8]
80004bbc:	f0 09 19 00 	cp.h	r9,r8
80004bc0:	c0 81       	brne	80004bd0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004bc2:	48 68       	lddpc	r8,80004bd8 <xnl_get_msg_ack_func+0x24>
80004bc4:	70 0c       	ld.w	r12,r8[0x0]
80004bc6:	30 09       	mov	r9,0
80004bc8:	12 9a       	mov	r10,r9
80004bca:	12 9b       	mov	r11,r9
80004bcc:	f0 1f 00 04 	mcall	80004bdc <xnl_get_msg_ack_func+0x28>
80004bd0:	d8 02       	popm	pc
80004bd2:	00 00       	add	r0,r0
80004bd4:	00 00       	add	r0,r0
80004bd6:	0b 62       	ld.uh	r2,--r5
80004bd8:	00 00       	add	r0,r0
80004bda:	0b 5c       	ld.sh	r12,--r5
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	73 2c       	ld.w	r12,r9[0x48]

80004be0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004be0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004be4:	30 09       	mov	r9,0
80004be6:	4b 78       	lddpc	r8,80004cc0 <xnl_init+0xe0>
80004be8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004bea:	30 0b       	mov	r11,0
80004bec:	30 1c       	mov	r12,1
80004bee:	f0 1f 00 36 	mcall	80004cc4 <xnl_init+0xe4>
80004bf2:	4b 68       	lddpc	r8,80004cc8 <xnl_init+0xe8>
80004bf4:	91 0c       	st.w	r8[0x0],r12
80004bf6:	70 08       	ld.w	r8,r8[0x0]
80004bf8:	58 08       	cp.w	r8,0
80004bfa:	c0 80       	breq	80004c0a <xnl_init+0x2a>
80004bfc:	4b 38       	lddpc	r8,80004cc8 <xnl_init+0xe8>
80004bfe:	70 0c       	ld.w	r12,r8[0x0]
80004c00:	30 09       	mov	r9,0
80004c02:	12 9a       	mov	r10,r9
80004c04:	12 9b       	mov	r11,r9
80004c06:	f0 1f 00 32 	mcall	80004ccc <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004c0a:	30 4b       	mov	r11,4
80004c0c:	33 cc       	mov	r12,60
80004c0e:	f0 1f 00 2e 	mcall	80004cc4 <xnl_init+0xe4>
80004c12:	4b 08       	lddpc	r8,80004cd0 <xnl_init+0xf0>
80004c14:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004c16:	30 4b       	mov	r11,4
80004c18:	36 4c       	mov	r12,100
80004c1a:	f0 1f 00 2b 	mcall	80004cc4 <xnl_init+0xe4>
80004c1e:	4a e8       	lddpc	r8,80004cd4 <xnl_init+0xf4>
80004c20:	91 0c       	st.w	r8[0x0],r12
80004c22:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004c24:	10 96       	mov	r6,r8
80004c26:	4a d5       	lddpc	r5,80004cd8 <xnl_init+0xf8>
80004c28:	6c 0c       	ld.w	r12,r6[0x0]
80004c2a:	ea 07 00 0b 	add	r11,r5,r7
80004c2e:	f0 1f 00 2c 	mcall	80004cdc <xnl_init+0xfc>
80004c32:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004c36:	e0 47 64 00 	cp.w	r7,25600
80004c3a:	cf 71       	brne	80004c28 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c3c:	30 4b       	mov	r11,4
80004c3e:	33 2c       	mov	r12,50
80004c40:	f0 1f 00 21 	mcall	80004cc4 <xnl_init+0xe4>
80004c44:	4a 78       	lddpc	r8,80004ce0 <xnl_init+0x100>
80004c46:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c48:	30 4b       	mov	r11,4
80004c4a:	32 8c       	mov	r12,40
80004c4c:	f0 1f 00 1e 	mcall	80004cc4 <xnl_init+0xe4>
80004c50:	4a 58       	lddpc	r8,80004ce4 <xnl_init+0x104>
80004c52:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004c54:	30 4b       	mov	r11,4
80004c56:	30 ac       	mov	r12,10
80004c58:	f0 1f 00 1b 	mcall	80004cc4 <xnl_init+0xe4>
80004c5c:	4a 38       	lddpc	r8,80004ce8 <xnl_init+0x108>
80004c5e:	91 0c       	st.w	r8[0x0],r12
80004c60:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004c62:	10 96       	mov	r6,r8
80004c64:	4a 25       	lddpc	r5,80004cec <xnl_init+0x10c>
80004c66:	6c 0c       	ld.w	r12,r6[0x0]
80004c68:	ea 07 00 0b 	add	r11,r5,r7
80004c6c:	f0 1f 00 1c 	mcall	80004cdc <xnl_init+0xfc>
80004c70:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004c74:	e0 47 14 00 	cp.w	r7,5120
80004c78:	cf 71       	brne	80004c66 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c7a:	30 4b       	mov	r11,4
80004c7c:	30 5c       	mov	r12,5
80004c7e:	f0 1f 00 12 	mcall	80004cc4 <xnl_init+0xe4>
80004c82:	49 c8       	lddpc	r8,80004cf0 <xnl_init+0x110>
80004c84:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004c86:	30 07       	mov	r7,0
80004c88:	1a d7       	st.w	--sp,r7
80004c8a:	1a d7       	st.w	--sp,r7
80004c8c:	1a d7       	st.w	--sp,r7
80004c8e:	30 38       	mov	r8,3
80004c90:	0e 99       	mov	r9,r7
80004c92:	e0 6a 00 dc 	mov	r10,220
80004c96:	49 8b       	lddpc	r11,80004cf4 <xnl_init+0x114>
80004c98:	49 8c       	lddpc	r12,80004cf8 <xnl_init+0x118>
80004c9a:	f0 1f 00 19 	mcall	80004cfc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004c9e:	1a d7       	st.w	--sp,r7
80004ca0:	1a d7       	st.w	--sp,r7
80004ca2:	1a d7       	st.w	--sp,r7
80004ca4:	30 38       	mov	r8,3
80004ca6:	0e 99       	mov	r9,r7
80004ca8:	e0 6a 00 82 	mov	r10,130
80004cac:	49 5b       	lddpc	r11,80004d00 <xnl_init+0x120>
80004cae:	49 6c       	lddpc	r12,80004d04 <xnl_init+0x124>
80004cb0:	f0 1f 00 13 	mcall	80004cfc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004cb4:	f0 1f 00 15 	mcall	80004d08 <xnl_init+0x128>
80004cb8:	2f ad       	sub	sp,-24
}
80004cba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004cbe:	00 00       	add	r0,r0
80004cc0:	00 00       	add	r0,r0
80004cc2:	0b 62       	ld.uh	r2,--r5
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	74 84       	ld.w	r4,r10[0x20]
80004cc8:	00 00       	add	r0,r0
80004cca:	0b 5c       	ld.sh	r12,--r5
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	73 2c       	ld.w	r12,r9[0x48]
80004cd0:	00 00       	add	r0,r0
80004cd2:	0b 70       	ld.ub	r0,--r5
80004cd4:	00 00       	add	r0,r0
80004cd6:	0a c0       	st.b	r5++,r0
80004cd8:	00 00       	add	r0,r0
80004cda:	33 4e       	mov	lr,52
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	35 44       	mov	r4,84
80004ce0:	00 00       	add	r0,r0
80004ce2:	0a f0       	st.b	--r5,r0
80004ce4:	00 00       	add	r0,r0
80004ce6:	0a d0       	st.w	--r5,r0
80004ce8:	00 00       	add	r0,r0
80004cea:	0a c4       	st.b	r5++,r4
80004cec:	00 00       	add	r0,r0
80004cee:	1f 4e       	ld.w	lr,--pc
80004cf0:	00 00       	add	r0,r0
80004cf2:	0a fc       	st.b	--r5,r12
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	e9 b4       	*unknown*
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	4d 0c       	lddpc	r12,80004e38 <xnl_tx>
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	7b a0       	ld.w	r0,sp[0x68]
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	e9 bc       	*unknown*
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	4d 6c       	lddpc	r12,80004e5c <xnl_tx+0x24>
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	37 18       	mov	r8,113

80004d0c <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004d0c:	eb cd 40 fe 	pushm	r1-r7,lr
80004d10:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d12:	49 26       	lddpc	r6,80004d58 <xnl_rx_process+0x4c>
80004d14:	30 05       	mov	r5,0
80004d16:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d18:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d1a:	49 11       	lddpc	r1,80004d5c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d1c:	49 12       	lddpc	r2,80004d60 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d1e:	6c 0c       	ld.w	r12,r6[0x0]
80004d20:	0a 99       	mov	r9,r5
80004d22:	08 9a       	mov	r10,r4
80004d24:	1a 9b       	mov	r11,sp
80004d26:	f0 1f 00 10 	mcall	80004d64 <xnl_rx_process+0x58>
80004d2a:	58 1c       	cp.w	r12,1
80004d2c:	cf 91       	brne	80004d1e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004d2e:	40 0c       	lddsp	r12,sp[0x0]
80004d30:	58 0c       	cp.w	r12,0
80004d32:	cf 60       	breq	80004d1e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d34:	98 28       	ld.sh	r8,r12[0x4]
80004d36:	e6 08 19 00 	cp.h	r8,r3
80004d3a:	e0 8b 00 0a 	brhi	80004d4e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d3e:	5c 78       	castu.h	r8
80004d40:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004d44:	58 09       	cp.w	r9,0
80004d46:	c0 40       	breq	80004d4e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004d48:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004d4c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d4e:	62 0c       	ld.w	r12,r1[0x0]
80004d50:	40 0b       	lddsp	r11,sp[0x0]
80004d52:	f0 1f 00 06 	mcall	80004d68 <xnl_rx_process+0x5c>
80004d56:	ce 4b       	rjmp	80004d1e <xnl_rx_process+0x12>
80004d58:	00 00       	add	r0,r0
80004d5a:	0a d0       	st.w	--r5,r0
80004d5c:	00 00       	add	r0,r0
80004d5e:	0a c0       	st.b	r5++,r0
80004d60:	00 00       	add	r0,r0
80004d62:	05 00       	ld.w	r0,r2++
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	71 20       	ld.w	r0,r8[0x48]
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	35 44       	mov	r4,84

80004d6c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004d6c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d6e:	4a a6       	lddpc	r6,80004e14 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d70:	4a a2       	lddpc	r2,80004e18 <xnl_tx_process+0xac>
80004d72:	4a b4       	lddpc	r4,80004e1c <xnl_tx_process+0xb0>
80004d74:	30 07       	mov	r7,0
80004d76:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004d78:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004d7a:	4a a5       	lddpc	r5,80004e20 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004d7c:	4a a3       	lddpc	r3,80004e24 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d7e:	6c 08       	ld.w	r8,r6[0x0]
80004d80:	58 08       	cp.w	r8,0
80004d82:	c0 40       	breq	80004d8a <xnl_tx_process+0x1e>
80004d84:	58 18       	cp.w	r8,1
80004d86:	cf d1       	brne	80004d80 <xnl_tx_process+0x14>
80004d88:	c2 48       	rjmp	80004dd0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d8a:	64 0c       	ld.w	r12,r2[0x0]
80004d8c:	0e 99       	mov	r9,r7
80004d8e:	02 9a       	mov	r10,r1
80004d90:	08 9b       	mov	r11,r4
80004d92:	f0 1f 00 26 	mcall	80004e28 <xnl_tx_process+0xbc>
80004d96:	58 1c       	cp.w	r12,1
80004d98:	cf 31       	brne	80004d7e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004d9a:	68 0b       	ld.w	r11,r4[0x0]
80004d9c:	58 0b       	cp.w	r11,0
80004d9e:	cf 00       	breq	80004d7e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004da0:	96 28       	ld.sh	r8,r11[0x4]
80004da2:	e0 08 19 00 	cp.h	r8,r0
80004da6:	c0 71       	brne	80004db4 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004da8:	4a 18       	lddpc	r8,80004e2c <xnl_tx_process+0xc0>
80004daa:	70 08       	ld.w	r8,r8[0x0]
80004dac:	10 9c       	mov	r12,r8
80004dae:	f0 1f 00 21 	mcall	80004e30 <xnl_tx_process+0xc4>
						break;
80004db2:	ce 6b       	rjmp	80004d7e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004db4:	16 9c       	mov	r12,r11
80004db6:	f0 1f 00 20 	mcall	80004e34 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004dba:	30 18       	mov	r8,1
80004dbc:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004dbe:	66 0c       	ld.w	r12,r3[0x0]
80004dc0:	0e 99       	mov	r9,r7
80004dc2:	0e 9a       	mov	r10,r7
80004dc4:	0e 9b       	mov	r11,r7
80004dc6:	f0 1f 00 19 	mcall	80004e28 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004dca:	30 18       	mov	r8,1
80004dcc:	8d 08       	st.w	r6[0x0],r8
80004dce:	cd 8b       	rjmp	80004d7e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004dd0:	66 0c       	ld.w	r12,r3[0x0]
80004dd2:	0e 99       	mov	r9,r7
80004dd4:	36 4a       	mov	r10,100
80004dd6:	0e 9b       	mov	r11,r7
80004dd8:	f0 1f 00 14 	mcall	80004e28 <xnl_tx_process+0xbc>
80004ddc:	58 1c       	cp.w	r12,1
80004dde:	c0 81       	brne	80004dee <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004de0:	49 38       	lddpc	r8,80004e2c <xnl_tx_process+0xc0>
80004de2:	70 0c       	ld.w	r12,r8[0x0]
80004de4:	68 0b       	ld.w	r11,r4[0x0]
80004de6:	f0 1f 00 13 	mcall	80004e30 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004dea:	8d 07       	st.w	r6[0x0],r7
80004dec:	cc 9b       	rjmp	80004d7e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004dee:	6a 08       	ld.w	r8,r5[0x0]
80004df0:	58 38       	cp.w	r8,3
80004df2:	e0 89 00 09 	brgt	80004e04 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004df6:	68 0c       	ld.w	r12,r4[0x0]
80004df8:	f0 1f 00 0f 	mcall	80004e34 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004dfc:	6a 08       	ld.w	r8,r5[0x0]
80004dfe:	2f f8       	sub	r8,-1
80004e00:	8b 08       	st.w	r5[0x0],r8
80004e02:	cb eb       	rjmp	80004d7e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004e04:	48 a8       	lddpc	r8,80004e2c <xnl_tx_process+0xc0>
80004e06:	70 0c       	ld.w	r12,r8[0x0]
80004e08:	68 0b       	ld.w	r11,r4[0x0]
80004e0a:	f0 1f 00 0a 	mcall	80004e30 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004e0e:	8d 07       	st.w	r6[0x0],r7
80004e10:	cb 7b       	rjmp	80004d7e <xnl_tx_process+0x12>
80004e12:	00 00       	add	r0,r0
80004e14:	00 00       	add	r0,r0
80004e16:	0b 6c       	ld.uh	r12,--r5
80004e18:	00 00       	add	r0,r0
80004e1a:	0b 70       	ld.ub	r0,--r5
80004e1c:	00 00       	add	r0,r0
80004e1e:	0b 78       	ld.ub	r8,--r5
80004e20:	00 00       	add	r0,r0
80004e22:	0b 74       	ld.ub	r4,--r5
80004e24:	00 00       	add	r0,r0
80004e26:	0b 5c       	ld.sh	r12,--r5
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	71 20       	ld.w	r0,r8[0x48]
80004e2c:	00 00       	add	r0,r0
80004e2e:	0a c0       	st.b	r5++,r0
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	35 44       	mov	r4,84
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	35 64       	mov	r4,86

80004e38 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004e38:	eb cd 40 c0 	pushm	r6-r7,lr
80004e3c:	20 1d       	sub	sp,4
80004e3e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004e40:	98 39       	ld.sh	r9,r12[0x6]
80004e42:	3f f8       	mov	r8,-1
80004e44:	f0 09 19 00 	cp.h	r9,r8
80004e48:	c0 a1       	brne	80004e5c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004e4a:	4a e9       	lddpc	r9,80004f00 <xnl_tx+0xc8>
80004e4c:	13 88       	ld.ub	r8,r9[0x0]
80004e4e:	2f f8       	sub	r8,-1
80004e50:	5c 58       	castu.b	r8
80004e52:	b2 88       	st.b	r9[0x0],r8
80004e54:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004e58:	a9 a8       	sbr	r8,0x8
80004e5a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004e5c:	8c 49       	ld.sh	r9,r6[0x8]
80004e5e:	3f f8       	mov	r8,-1
80004e60:	f0 09 19 00 	cp.h	r9,r8
80004e64:	c0 41       	brne	80004e6c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004e66:	4a 88       	lddpc	r8,80004f04 <xnl_tx+0xcc>
80004e68:	90 18       	ld.sh	r8,r8[0x2]
80004e6a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004e6c:	8c 59       	ld.sh	r9,r6[0xa]
80004e6e:	3f f8       	mov	r8,-1
80004e70:	f0 09 19 00 	cp.h	r9,r8
80004e74:	c0 41       	brne	80004e7c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004e76:	4a 48       	lddpc	r8,80004f04 <xnl_tx+0xcc>
80004e78:	90 28       	ld.sh	r8,r8[0x4]
80004e7a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004e7c:	8c 69       	ld.sh	r9,r6[0xc]
80004e7e:	3f f8       	mov	r8,-1
80004e80:	f0 09 19 00 	cp.h	r9,r8
80004e84:	c0 e1       	brne	80004ea0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e86:	4a 08       	lddpc	r8,80004f04 <xnl_tx+0xcc>
80004e88:	90 49       	ld.sh	r9,r8[0x8]
80004e8a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e8c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e8e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e90:	90 49       	ld.sh	r9,r8[0x8]
80004e92:	e0 19 ff 00 	andl	r9,0xff00
80004e96:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004e9a:	f3 e8 10 08 	or	r8,r9,r8
80004e9e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004ea0:	0d 98       	ld.ub	r8,r6[0x1]
80004ea2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004ea4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004ea8:	10 0c       	add	r12,r8
80004eaa:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004eac:	58 0c       	cp.w	r12,0
80004eae:	e0 89 00 04 	brgt	80004eb6 <xnl_tx+0x7e>
80004eb2:	30 09       	mov	r9,0
80004eb4:	c0 d8       	rjmp	80004ece <xnl_tx+0x96>
80004eb6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004eba:	2f ec       	sub	r12,-2
80004ebc:	30 09       	mov	r9,0
80004ebe:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004ec0:	15 1b       	ld.sh	r11,r10++
80004ec2:	f6 09 00 09 	add	r9,r11,r9
80004ec6:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004ec8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004eca:	18 38       	cp.w	r8,r12
80004ecc:	cf a1       	brne	80004ec0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004ece:	5c 39       	neg	r9
80004ed0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004ed2:	48 e8       	lddpc	r8,80004f08 <xnl_tx+0xd0>
80004ed4:	70 0c       	ld.w	r12,r8[0x0]
80004ed6:	f0 1f 00 0e 	mcall	80004f0c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004eda:	c1 00       	breq	80004efa <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004edc:	fa c7 ff fc 	sub	r7,sp,-4
80004ee0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004ee2:	e0 6a 01 00 	mov	r10,256
80004ee6:	0c 9b       	mov	r11,r6
80004ee8:	f0 1f 00 0a 	mcall	80004f10 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004eec:	48 a8       	lddpc	r8,80004f14 <xnl_tx+0xdc>
80004eee:	70 0c       	ld.w	r12,r8[0x0]
80004ef0:	30 09       	mov	r9,0
80004ef2:	12 9a       	mov	r10,r9
80004ef4:	1a 9b       	mov	r11,sp
80004ef6:	f0 1f 00 09 	mcall	80004f18 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004efa:	2f fd       	sub	sp,-4
80004efc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f00:	00 00       	add	r0,r0
80004f02:	0b 60       	ld.uh	r0,--r5
80004f04:	00 00       	add	r0,r0
80004f06:	0b 62       	ld.uh	r2,--r5
80004f08:	00 00       	add	r0,r0
80004f0a:	0a c0       	st.b	r5++,r0
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	36 f0       	mov	r0,111
80004f10:	80 00       	ld.sh	r0,r0[0x0]
80004f12:	88 0e       	ld.sh	lr,r4[0x0]
80004f14:	00 00       	add	r0,r0
80004f16:	0b 70       	ld.ub	r0,--r5
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	73 2c       	ld.w	r12,r9[0x48]

80004f1c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004f1c:	eb cd 40 80 	pushm	r7,lr
80004f20:	fa cd 01 00 	sub	sp,sp,256
80004f24:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f26:	e0 68 40 0e 	mov	r8,16398
80004f2a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f2c:	3f f8       	mov	r8,-1
80004f2e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004f30:	30 c8       	mov	r8,12
80004f32:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004f34:	98 38       	ld.sh	r8,r12[0x6]
80004f36:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004f38:	98 58       	ld.sh	r8,r12[0xa]
80004f3a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004f3c:	98 48       	ld.sh	r8,r12[0x8]
80004f3e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004f40:	98 68       	ld.sh	r8,r12[0xc]
80004f42:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004f44:	30 08       	mov	r8,0
80004f46:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004f48:	1a 9c       	mov	r12,sp
80004f4a:	f0 1f 00 0a 	mcall	80004f70 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004f4e:	fa cd 00 cc 	sub	sp,sp,204
80004f52:	e0 6a 00 ca 	mov	r10,202
80004f56:	ee cb ff f0 	sub	r11,r7,-16
80004f5a:	1a 9c       	mov	r12,sp
80004f5c:	f0 1f 00 06 	mcall	80004f74 <xnl_data_msg_func+0x58>
80004f60:	48 68       	lddpc	r8,80004f78 <xnl_data_msg_func+0x5c>
80004f62:	70 08       	ld.w	r8,r8[0x0]
80004f64:	5d 18       	icall	r8
80004f66:	fa cd ff 34 	sub	sp,sp,-204
}
80004f6a:	2c 0d       	sub	sp,-256
80004f6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	4e 38       	lddpc	r8,800050fc <xnl_device_conn_reply_func>
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	88 0e       	ld.sh	lr,r4[0x0]
80004f78:	00 00       	add	r0,r0
80004f7a:	0b 7c       	ld.ub	r12,--r5

80004f7c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004f7c:	d4 21       	pushm	r4-r7,lr
80004f7e:	fa cd 01 00 	sub	sp,sp,256
80004f82:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004f84:	4c 28       	lddpc	r8,8000508c <xnl_device_auth_reply_func+0x110>
80004f86:	11 88       	ld.ub	r8,r8[0x0]
80004f88:	58 08       	cp.w	r8,0
80004f8a:	e0 81 00 7f 	brne	80005088 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004f8e:	4c 18       	lddpc	r8,80005090 <xnl_device_auth_reply_func+0x114>
80004f90:	70 0c       	ld.w	r12,r8[0x0]
80004f92:	30 09       	mov	r9,0
80004f94:	12 9a       	mov	r10,r9
80004f96:	12 9b       	mov	r11,r9
80004f98:	f0 1f 00 3f 	mcall	80005094 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004f9c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004fa0:	4b b8       	lddpc	r8,8000508c <xnl_device_auth_reply_func+0x110>
80004fa2:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004fa4:	ef 39 00 12 	ld.ub	r9,r7[18]
80004fa8:	ef 38 00 13 	ld.ub	r8,r7[19]
80004fac:	b1 68       	lsl	r8,0x10
80004fae:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004fb2:	ef 38 00 15 	ld.ub	r8,r7[21]
80004fb6:	f3 e8 10 08 	or	r8,r9,r8
80004fba:	ef 39 00 14 	ld.ub	r9,r7[20]
80004fbe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004fc2:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004fc6:	ef 38 00 17 	ld.ub	r8,r7[23]
80004fca:	b1 68       	lsl	r8,0x10
80004fcc:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004fd0:	ef 38 00 19 	ld.ub	r8,r7[25]
80004fd4:	f5 e8 10 08 	or	r8,r10,r8
80004fd8:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004fdc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004fe0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004fe2:	e0 64 79 b9 	mov	r4,31161
80004fe6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004fea:	e0 65 45 07 	mov	r5,17671
80004fee:	ea 15 8a bd 	orh	r5,0x8abd
80004ff2:	e0 66 f9 3d 	mov	r6,63805
80004ff6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004ffa:	e0 6e b8 cf 	mov	lr,47311
80004ffe:	ea 1e 36 83 	orh	lr,0x3683
80005002:	e0 67 aa 1c 	mov	r7,43548
80005006:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000500a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000500c:	f4 08 00 0c 	add	r12,r10,r8
80005010:	f0 0b 15 04 	lsl	r11,r8,0x4
80005014:	0a 0b       	add	r11,r5
80005016:	f9 eb 20 0b 	eor	r11,r12,r11
8000501a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000501e:	0c 0c       	add	r12,r6
80005020:	18 5b       	eor	r11,r12
80005022:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005024:	f2 0c 15 04 	lsl	r12,r9,0x4
80005028:	1c 0c       	add	r12,lr
8000502a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000502e:	0e 0b       	add	r11,r7
80005030:	f9 eb 20 0b 	eor	r11,r12,r11
80005034:	f2 0a 00 0c 	add	r12,r9,r10
80005038:	18 5b       	eor	r11,r12
8000503a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000503c:	e0 6b 37 20 	mov	r11,14112
80005040:	ea 1b c6 ef 	orh	r11,0xc6ef
80005044:	16 3a       	cp.w	r10,r11
80005046:	ce 21       	brne	8000500a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005048:	e0 6a 40 1a 	mov	r10,16410
8000504c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000504e:	3f fa       	mov	r10,-1
80005050:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005052:	30 6b       	mov	r11,6
80005054:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005056:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005058:	48 db       	lddpc	r11,8000508c <xnl_device_auth_reply_func+0x110>
8000505a:	96 1c       	ld.sh	r12,r11[0x2]
8000505c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000505e:	96 2b       	ld.sh	r11,r11[0x4]
80005060:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005062:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80005064:	30 ca       	mov	r10,12
80005066:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005068:	30 0a       	mov	r10,0
8000506a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000506e:	30 7a       	mov	r10,7
80005070:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80005074:	30 2a       	mov	r10,2
80005076:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000507a:	fa ca ff ec 	sub	r10,sp,-20
8000507e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005080:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005082:	1a 9c       	mov	r12,sp
80005084:	f0 1f 00 05 	mcall	80005098 <xnl_device_auth_reply_func+0x11c>
}
80005088:	2c 0d       	sub	sp,-256
8000508a:	d8 22       	popm	r4-r7,pc
8000508c:	00 00       	add	r0,r0
8000508e:	0b 62       	ld.uh	r2,--r5
80005090:	00 00       	add	r0,r0
80005092:	0b 5c       	ld.sh	r12,--r5
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	73 2c       	ld.w	r12,r9[0x48]
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4e 38       	lddpc	r8,80005224 <WriteRawRC+0xc>

8000509c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000509c:	eb cd 40 80 	pushm	r7,lr
800050a0:	fa cd 01 00 	sub	sp,sp,256
800050a4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800050a6:	49 28       	lddpc	r8,800050ec <xnl_master_status_brdcst_func+0x50>
800050a8:	11 88       	ld.ub	r8,r8[0x0]
800050aa:	58 08       	cp.w	r8,0
800050ac:	c1 c1       	brne	800050e4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800050ae:	49 18       	lddpc	r8,800050f0 <xnl_master_status_brdcst_func+0x54>
800050b0:	70 0c       	ld.w	r12,r8[0x0]
800050b2:	30 09       	mov	r9,0
800050b4:	12 9a       	mov	r10,r9
800050b6:	12 9b       	mov	r11,r9
800050b8:	f0 1f 00 0f 	mcall	800050f4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800050bc:	8e 58       	ld.sh	r8,r7[0xa]
800050be:	48 c9       	lddpc	r9,800050ec <xnl_master_status_brdcst_func+0x50>
800050c0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800050c2:	e0 68 40 0e 	mov	r8,16398
800050c6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050c8:	3f f8       	mov	r8,-1
800050ca:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800050cc:	30 4a       	mov	r10,4
800050ce:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800050d0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800050d2:	92 19       	ld.sh	r9,r9[0x2]
800050d4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800050d6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050d8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800050da:	30 08       	mov	r8,0
800050dc:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800050de:	1a 9c       	mov	r12,sp
800050e0:	f0 1f 00 06 	mcall	800050f8 <xnl_master_status_brdcst_func+0x5c>
}
800050e4:	2c 0d       	sub	sp,-256
800050e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800050ea:	00 00       	add	r0,r0
800050ec:	00 00       	add	r0,r0
800050ee:	0b 62       	ld.uh	r2,--r5
800050f0:	00 00       	add	r0,r0
800050f2:	0b 5c       	ld.sh	r12,--r5
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	73 2c       	ld.w	r12,r9[0x48]
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	4e 38       	lddpc	r8,80005284 <PcdReset+0x2c>

800050fc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800050fc:	eb cd 40 80 	pushm	r7,lr
80005100:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005102:	49 28       	lddpc	r8,80005148 <xnl_device_conn_reply_func+0x4c>
80005104:	70 0c       	ld.w	r12,r8[0x0]
80005106:	30 09       	mov	r9,0
80005108:	12 9a       	mov	r10,r9
8000510a:	12 9b       	mov	r11,r9
8000510c:	f0 1f 00 10 	mcall	8000514c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005110:	ef 18 00 10 	ld.uh	r8,r7[16]
80005114:	10 99       	mov	r9,r8
80005116:	e2 19 ff 00 	andl	r9,0xff00,COH
8000511a:	e0 49 01 00 	cp.w	r9,256
8000511e:	c0 60       	breq	8000512a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005120:	0e 9c       	mov	r12,r7
80005122:	f0 1f 00 0c 	mcall	80005150 <xnl_device_conn_reply_func+0x54>
80005126:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000512a:	a9 68       	lsl	r8,0x8
8000512c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005130:	48 98       	lddpc	r8,80005154 <xnl_device_conn_reply_func+0x58>
80005132:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005134:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005138:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000513a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000513e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005140:	30 19       	mov	r9,1
80005142:	b0 89       	st.b	r8[0x0],r9
80005144:	e3 cd 80 80 	ldm	sp++,r7,pc
80005148:	00 00       	add	r0,r0
8000514a:	0b 5c       	ld.sh	r12,--r5
8000514c:	80 00       	ld.sh	r0,r0[0x0]
8000514e:	73 2c       	ld.w	r12,r9[0x48]
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	50 9c       	stdsp	sp[0x24],r12
80005154:	00 00       	add	r0,r0
80005156:	0b 62       	ld.uh	r2,--r5

80005158 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80005158:	d4 01       	pushm	lr
8000515a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000515e:	e0 68 40 0e 	mov	r8,16398
80005162:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005164:	3f f8       	mov	r8,-1
80005166:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005168:	30 38       	mov	r8,3
8000516a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000516c:	30 08       	mov	r8,0
8000516e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005170:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005172:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005174:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005176:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005178:	1a 9c       	mov	r12,sp
8000517a:	f0 1f 00 03 	mcall	80005184 <xnl_send_device_master_query+0x2c>
}
8000517e:	2c 0d       	sub	sp,-256
80005180:	d8 02       	popm	pc
80005182:	00 00       	add	r0,r0
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	4e 38       	lddpc	r8,80005310 <ReadRawRC+0x38>

80005188 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80005188:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000518a:	48 78       	lddpc	r8,800051a4 <RC522_SPI_SetSpeed+0x1c>
8000518c:	70 09       	ld.w	r9,r8[0x0]
8000518e:	72 ca       	ld.w	r10,r9[0x30]
80005190:	5c 7c       	castu.h	r12
80005192:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80005196:	f9 ea 10 0a 	or	r10,r12,r10
8000519a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000519c:	70 0c       	ld.w	r12,r8[0x0]
8000519e:	f0 1f 00 03 	mcall	800051a8 <RC522_SPI_SetSpeed+0x20>
		
	
}
800051a2:	d8 02       	popm	pc
800051a4:	00 00       	add	r0,r0
800051a6:	1e 28       	rsub	r8,pc
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	68 1c       	ld.w	r12,r4[0x4]

800051ac <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800051ac:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800051ae:	e0 6c 0a 00 	mov	r12,2560
800051b2:	f0 1f 00 02 	mcall	800051b8 <RC522_SPI_SetSpeedLow+0xc>
	
}
800051b6:	d8 02       	popm	pc
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	51 88       	stdsp	sp[0x60],r8

800051bc <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800051bc:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800051c0:	48 76       	lddpc	r6,800051dc <RC522_ReadByte+0x20>
800051c2:	e0 6b 00 ff 	mov	r11,255
800051c6:	6c 0c       	ld.w	r12,r6[0x0]
800051c8:	f0 1f 00 06 	mcall	800051e0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800051cc:	30 07       	mov	r7,0
800051ce:	0e 9b       	mov	r11,r7
800051d0:	6c 0c       	ld.w	r12,r6[0x0]
800051d2:	f0 1f 00 05 	mcall	800051e4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800051d6:	0f 9c       	ld.ub	r12,r7[0x1]
800051d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051dc:	00 00       	add	r0,r0
800051de:	1e 28       	rsub	r8,pc
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	68 22       	ld.w	r2,r4[0x8]
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	68 3e       	ld.w	lr,r4[0xc]

800051e8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800051e8:	eb cd 40 80 	pushm	r7,lr
800051ec:	20 1d       	sub	sp,4
800051ee:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800051f0:	48 77       	lddpc	r7,8000520c <RC522_WriteByte+0x24>
800051f2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800051f6:	6e 0c       	ld.w	r12,r7[0x0]
800051f8:	f0 1f 00 06 	mcall	80005210 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800051fc:	1a 9b       	mov	r11,sp
800051fe:	6e 0c       	ld.w	r12,r7[0x0]
80005200:	f0 1f 00 05 	mcall	80005214 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80005204:	5c 5c       	castu.b	r12
80005206:	2f fd       	sub	sp,-4
80005208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000520c:	00 00       	add	r0,r0
8000520e:	1e 28       	rsub	r8,pc
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	68 22       	ld.w	r2,r4[0x8]
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	68 3e       	ld.w	lr,r4[0xc]

80005218 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005218:	eb cd 40 e0 	pushm	r5-r7,lr
8000521c:	18 96       	mov	r6,r12
8000521e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005220:	48 a7       	lddpc	r7,80005248 <WriteRawRC+0x30>
80005222:	30 0b       	mov	r11,0
80005224:	6e 0c       	ld.w	r12,r7[0x0]
80005226:	f0 1f 00 0a 	mcall	8000524c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000522a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000522e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005232:	f0 1f 00 08 	mcall	80005250 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80005236:	0a 9c       	mov	r12,r5
80005238:	f0 1f 00 06 	mcall	80005250 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000523c:	30 0b       	mov	r11,0
8000523e:	6e 0c       	ld.w	r12,r7[0x0]
80005240:	f0 1f 00 05 	mcall	80005254 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80005244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005248:	00 00       	add	r0,r0
8000524a:	1e 28       	rsub	r8,pc
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	69 88       	ld.w	r8,r4[0x60]
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	51 e8       	stdsp	sp[0x78],r8
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	69 48       	ld.w	r8,r4[0x50]

80005258 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80005258:	d4 01       	pushm	lr

	SET_RC522RST;
8000525a:	31 9c       	mov	r12,25
8000525c:	f0 1f 00 1b 	mcall	800052c8 <PcdReset+0x70>
	delay_ns(10);
80005260:	30 ac       	mov	r12,10
80005262:	f0 1f 00 1b 	mcall	800052cc <PcdReset+0x74>

	CLR_RC522RST;
80005266:	31 9c       	mov	r12,25
80005268:	f0 1f 00 1a 	mcall	800052d0 <PcdReset+0x78>
	delay_ns(10);
8000526c:	30 ac       	mov	r12,10
8000526e:	f0 1f 00 18 	mcall	800052cc <PcdReset+0x74>

	SET_RC522RST;
80005272:	31 9c       	mov	r12,25
80005274:	f0 1f 00 15 	mcall	800052c8 <PcdReset+0x70>
	delay_ns(10);
80005278:	30 ac       	mov	r12,10
8000527a:	f0 1f 00 15 	mcall	800052cc <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000527e:	30 fb       	mov	r11,15
80005280:	30 1c       	mov	r12,1
80005282:	f0 1f 00 15 	mcall	800052d4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80005286:	30 fb       	mov	r11,15
80005288:	30 1c       	mov	r12,1
8000528a:	f0 1f 00 13 	mcall	800052d4 <PcdReset+0x7c>
	delay_ns(10);
8000528e:	30 ac       	mov	r12,10
80005290:	f0 1f 00 0f 	mcall	800052cc <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80005294:	33 db       	mov	r11,61
80005296:	31 1c       	mov	r12,17
80005298:	f0 1f 00 0f 	mcall	800052d4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000529c:	31 eb       	mov	r11,30
8000529e:	32 dc       	mov	r12,45
800052a0:	f0 1f 00 0d 	mcall	800052d4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800052a4:	30 0b       	mov	r11,0
800052a6:	32 cc       	mov	r12,44
800052a8:	f0 1f 00 0b 	mcall	800052d4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800052ac:	e0 6b 00 8d 	mov	r11,141
800052b0:	32 ac       	mov	r12,42
800052b2:	f0 1f 00 09 	mcall	800052d4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800052b6:	33 eb       	mov	r11,62
800052b8:	32 bc       	mov	r12,43
800052ba:	f0 1f 00 07 	mcall	800052d4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800052be:	34 0b       	mov	r11,64
800052c0:	31 5c       	mov	r12,21
800052c2:	f0 1f 00 05 	mcall	800052d4 <PcdReset+0x7c>
	
	return MI_OK;
}
800052c6:	d8 0a       	popm	pc,r12=0
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	63 90       	ld.w	r0,r1[0x64]
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	5b f0       	cp.w	r0,-1
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	63 ac       	ld.w	r12,r1[0x68]
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	52 18       	stdsp	sp[0x84],r8

800052d8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800052d8:	eb cd 40 c0 	pushm	r6-r7,lr
800052dc:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800052de:	48 c7       	lddpc	r7,8000530c <ReadRawRC+0x34>
800052e0:	30 0b       	mov	r11,0
800052e2:	6e 0c       	ld.w	r12,r7[0x0]
800052e4:	f0 1f 00 0b 	mcall	80005310 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800052e8:	a1 76       	lsl	r6,0x1
800052ea:	0c 9c       	mov	r12,r6
800052ec:	e2 1c 00 7e 	andl	r12,0x7e,COH
800052f0:	a7 bc       	sbr	r12,0x7
800052f2:	f0 1f 00 09 	mcall	80005314 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800052f6:	f0 1f 00 09 	mcall	80005318 <ReadRawRC+0x40>
800052fa:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800052fc:	30 0b       	mov	r11,0
800052fe:	6e 0c       	ld.w	r12,r7[0x0]
80005300:	f0 1f 00 07 	mcall	8000531c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80005304:	0c 9c       	mov	r12,r6
80005306:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000530a:	00 00       	add	r0,r0
8000530c:	00 00       	add	r0,r0
8000530e:	1e 28       	rsub	r8,pc
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	69 88       	ld.w	r8,r4[0x60]
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	51 e8       	stdsp	sp[0x78],r8
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	51 bc       	stdsp	sp[0x6c],r12
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	69 48       	ld.w	r8,r4[0x50]

80005320 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005320:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80005322:	30 1c       	mov	r12,1
80005324:	f0 1f 00 02 	mcall	8000532c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005328:	d8 02       	popm	pc
8000532a:	00 00       	add	r0,r0
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	52 d8       	stdsp	sp[0xb4],r8

80005330 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80005330:	eb cd 40 80 	pushm	r7,lr
80005334:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005336:	30 1c       	mov	r12,1
80005338:	f0 1f 00 0d 	mcall	8000536c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
8000533c:	30 18       	mov	r8,1
8000533e:	f0 07 18 00 	cp.b	r7,r8
80005342:	c0 91       	brne	80005354 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80005344:	18 9b       	mov	r11,r12
80005346:	a5 ab       	sbr	r11,0x4
80005348:	5c 5b       	castu.b	r11
8000534a:	30 1c       	mov	r12,1
8000534c:	f0 1f 00 09 	mcall	80005370 <Powerdown_RC522+0x40>
80005350:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80005354:	18 9b       	mov	r11,r12
80005356:	30 1c       	mov	r12,1
80005358:	f0 1f 00 06 	mcall	80005370 <Powerdown_RC522+0x40>
		delay_ns(2);
8000535c:	30 2c       	mov	r12,2
8000535e:	f0 1f 00 06 	mcall	80005374 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80005362:	f0 1f 00 06 	mcall	80005378 <Powerdown_RC522+0x48>
80005366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000536a:	00 00       	add	r0,r0
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	52 d8       	stdsp	sp[0xb4],r8
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	52 18       	stdsp	sp[0x84],r8
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	5b f0       	cp.w	r0,-1
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	53 20       	stdsp	sp[0xc8],r0

8000537c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000537c:	eb cd 40 c0 	pushm	r6-r7,lr
80005380:	18 97       	mov	r7,r12
80005382:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80005384:	f0 1f 00 05 	mcall	80005398 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005388:	f9 e6 10 0b 	or	r11,r12,r6
8000538c:	5c 5b       	castu.b	r11
8000538e:	0e 9c       	mov	r12,r7
80005390:	f0 1f 00 03 	mcall	8000539c <SetBitMask+0x20>
}
80005394:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	52 d8       	stdsp	sp[0xb4],r8
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	52 18       	stdsp	sp[0x84],r8

800053a0 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800053a0:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800053a2:	31 4c       	mov	r12,20
800053a4:	f0 1f 00 05 	mcall	800053b8 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800053a8:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800053ac:	c0 51       	brne	800053b6 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800053ae:	30 3b       	mov	r11,3
800053b0:	31 4c       	mov	r12,20
800053b2:	f0 1f 00 03 	mcall	800053bc <PcdAntennaOn+0x1c>
800053b6:	d8 02       	popm	pc
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	52 d8       	stdsp	sp[0xb4],r8
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	53 7c       	stdsp	sp[0xdc],r12

800053c0 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800053c0:	eb cd 40 c0 	pushm	r6-r7,lr
800053c4:	18 97       	mov	r7,r12
800053c6:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800053c8:	f0 1f 00 06 	mcall	800053e0 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800053cc:	5c d6       	com	r6
800053ce:	f9 e6 00 06 	and	r6,r12,r6
800053d2:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800053d6:	0e 9c       	mov	r12,r7
800053d8:	f0 1f 00 03 	mcall	800053e4 <ClearBitMask+0x24>
	
}
800053dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	52 d8       	stdsp	sp[0xb4],r8
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	52 18       	stdsp	sp[0x84],r8

800053e8 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800053e8:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800053ea:	30 3b       	mov	r11,3
800053ec:	31 4c       	mov	r12,20
800053ee:	f0 1f 00 02 	mcall	800053f4 <PcdAntennaOff+0xc>
}
800053f2:	d8 02       	popm	pc
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	53 c0       	stdsp	sp[0xf0],r0

800053f8 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800053f8:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800053fa:	34 18       	mov	r8,65
800053fc:	f0 0c 18 00 	cp.b	r12,r8
80005400:	c0 20       	breq	80005404 <M500PcdConfigISOType+0xc>
80005402:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80005404:	30 8b       	mov	r11,8
80005406:	16 9c       	mov	r12,r11
80005408:	f0 1f 00 14 	mcall	80005458 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
8000540c:	33 db       	mov	r11,61
8000540e:	31 1c       	mov	r12,17
80005410:	f0 1f 00 13 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005414:	e0 6b 00 86 	mov	r11,134
80005418:	31 7c       	mov	r12,23
8000541a:	f0 1f 00 11 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000541e:	37 fb       	mov	r11,127
80005420:	32 6c       	mov	r12,38
80005422:	f0 1f 00 0f 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005426:	31 eb       	mov	r11,30
80005428:	32 dc       	mov	r12,45
8000542a:	f0 1f 00 0d 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000542e:	30 0b       	mov	r11,0
80005430:	32 cc       	mov	r12,44
80005432:	f0 1f 00 0b 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80005436:	e0 6b 00 8d 	mov	r11,141
8000543a:	32 ac       	mov	r12,42
8000543c:	f0 1f 00 08 	mcall	8000545c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80005440:	33 eb       	mov	r11,62
80005442:	32 bc       	mov	r12,43
80005444:	f0 1f 00 06 	mcall	8000545c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80005448:	e0 6c 03 e8 	mov	r12,1000
8000544c:	f0 1f 00 05 	mcall	80005460 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80005450:	f0 1f 00 05 	mcall	80005464 <M500PcdConfigISOType+0x6c>
80005454:	d8 0a       	popm	pc,r12=0
80005456:	00 00       	add	r0,r0
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	53 c0       	stdsp	sp[0xf0],r0
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	52 18       	stdsp	sp[0x84],r8
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	5b f0       	cp.w	r0,-1
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	53 a0       	stdsp	sp[0xe8],r0

80005468 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80005468:	eb cd 40 80 	pushm	r7,lr
8000546c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000546e:	49 d8       	lddpc	r8,800054e0 <rc522_init+0x78>
80005470:	1a 97       	mov	r7,sp
80005472:	f0 ea 00 00 	ld.d	r10,r8[0]
80005476:	fa eb 00 00 	st.d	sp[0],r10
8000547a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000547e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80005482:	30 1b       	mov	r11,1
80005484:	49 8c       	lddpc	r12,800054e4 <rc522_init+0x7c>
80005486:	f0 1f 00 19 	mcall	800054e8 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000548a:	31 9c       	mov	r12,25
8000548c:	f0 1f 00 18 	mcall	800054ec <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80005490:	31 9c       	mov	r12,25
80005492:	f0 1f 00 18 	mcall	800054f0 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80005496:	fe 7c 24 00 	mov	r12,-56320
8000549a:	49 78       	lddpc	r8,800054f4 <rc522_init+0x8c>
8000549c:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
8000549e:	e0 6a 36 00 	mov	r10,13824
800054a2:	ea 1a 01 6e 	orh	r10,0x16e
800054a6:	1a 9b       	mov	r11,sp
800054a8:	f0 1f 00 14 	mcall	800054f8 <rc522_init+0x90>
800054ac:	c0 50       	breq	800054b6 <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800054ae:	30 29       	mov	r9,2
800054b0:	49 38       	lddpc	r8,800054fc <rc522_init+0x94>
800054b2:	b0 89       	st.b	r8[0x0],r9
800054b4:	c0 38       	rjmp	800054ba <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800054b6:	f0 1f 00 13 	mcall	80005500 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800054ba:	f0 1f 00 13 	mcall	80005504 <rc522_init+0x9c>
	
	PcdAntennaOff();
800054be:	f0 1f 00 13 	mcall	80005508 <rc522_init+0xa0>
	
	delay_ms(2); 
800054c2:	30 2c       	mov	r12,2
800054c4:	f0 1f 00 12 	mcall	8000550c <rc522_init+0xa4>
	
	PcdAntennaOn();
800054c8:	f0 1f 00 12 	mcall	80005510 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
800054cc:	34 1c       	mov	r12,65
800054ce:	f0 1f 00 12 	mcall	80005514 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
800054d2:	30 1c       	mov	r12,1
800054d4:	f0 1f 00 11 	mcall	80005518 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

800054d8:	2f cd       	sub	sp,-16
800054da:	e3 cd 80 80 	ldm	sp++,r7,pc
800054de:	00 00       	add	r0,r0
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	e9 cc 80 00 	stm	r12,pc
800054e6:	e9 dc 80 00 	ldswp.w	r12,r4[0]
800054ea:	63 48       	ld.w	r8,r1[0x50]
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	63 78       	ld.w	r8,r1[0x5c]
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	63 90       	ld.w	r0,r1[0x64]
800054f4:	00 00       	add	r0,r0
800054f6:	1e 28       	rsub	r8,pc
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	68 60       	ld.w	r0,r4[0x18]
800054fc:	00 00       	add	r0,r0
800054fe:	0b 80       	ld.ub	r0,r5[0x0]
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	51 ac       	stdsp	sp[0x68],r12
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	52 58       	stdsp	sp[0x94],r8
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	53 e8       	stdsp	sp[0xf8],r8
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	5c 30       	neg	r0
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	53 a0       	stdsp	sp[0xe8],r0
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	53 f8       	stdsp	sp[0xfc],r8
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	53 30       	stdsp	sp[0xcc],r0

8000551c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
8000551c:	d4 31       	pushm	r0-r7,lr
8000551e:	20 1d       	sub	sp,4
80005520:	18 92       	mov	r2,r12
80005522:	16 95       	mov	r5,r11
80005524:	14 96       	mov	r6,r10
80005526:	50 09       	stdsp	sp[0x0],r9
80005528:	10 90       	mov	r0,r8
8000552a:	f8 c8 00 0c 	sub	r8,r12,12
8000552e:	5c 58       	castu.b	r8
80005530:	30 29       	mov	r9,2
80005532:	f2 08 18 00 	cp.b	r8,r9
80005536:	e0 88 00 05 	brls	80005540 <PcdComMF522+0x24>
8000553a:	30 03       	mov	r3,0
8000553c:	06 91       	mov	r1,r3
8000553e:	c0 78       	rjmp	8000554c <PcdComMF522+0x30>
80005540:	4c f9       	lddpc	r9,8000567c <PcdComMF522+0x160>
80005542:	f2 08 07 01 	ld.ub	r1,r9[r8]
80005546:	4c f9       	lddpc	r9,80005680 <PcdComMF522+0x164>
80005548:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
8000554c:	02 9b       	mov	r11,r1
8000554e:	a7 bb       	sbr	r11,0x7
80005550:	30 2c       	mov	r12,2
80005552:	f0 1f 00 4d 	mcall	80005684 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80005556:	e0 6b 00 80 	mov	r11,128
8000555a:	30 4c       	mov	r12,4
8000555c:	f0 1f 00 4b 	mcall	80005688 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80005560:	30 0b       	mov	r11,0
80005562:	30 1c       	mov	r12,1
80005564:	f0 1f 00 48 	mcall	80005684 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80005568:	e0 6b 00 80 	mov	r11,128
8000556c:	30 ac       	mov	r12,10
8000556e:	f0 1f 00 48 	mcall	8000568c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80005572:	58 06       	cp.w	r6,0
80005574:	c0 c0       	breq	8000558c <PcdComMF522+0x70>
80005576:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80005578:	30 94       	mov	r4,9
8000557a:	0f 3b       	ld.ub	r11,r7++
8000557c:	08 9c       	mov	r12,r4
8000557e:	f0 1f 00 42 	mcall	80005684 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80005582:	0e 98       	mov	r8,r7
80005584:	0a 18       	sub	r8,r5
80005586:	ec 08 19 00 	cp.h	r8,r6
8000558a:	cf 83       	brcs	8000557a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
8000558c:	04 9b       	mov	r11,r2
8000558e:	30 1c       	mov	r12,1
80005590:	f0 1f 00 3d 	mcall	80005684 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005594:	30 c8       	mov	r8,12
80005596:	f0 02 18 00 	cp.b	r2,r8
8000559a:	c0 61       	brne	800055a6 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
8000559c:	e0 6b 00 80 	mov	r11,128
800055a0:	30 dc       	mov	r12,13
800055a2:	f0 1f 00 3b 	mcall	8000568c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800055a6:	30 4c       	mov	r12,4
800055a8:	f0 1f 00 3a 	mcall	80005690 <PcdComMF522+0x174>
800055ac:	18 97       	mov	r7,r12
800055ae:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055b2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800055b4:	30 44       	mov	r4,4
800055b6:	c0 88       	rjmp	800055c6 <PcdComMF522+0xaa>
800055b8:	08 9c       	mov	r12,r4
800055ba:	f0 1f 00 36 	mcall	80005690 <PcdComMF522+0x174>
800055be:	18 97       	mov	r7,r12
		i--;
800055c0:	20 16       	sub	r6,1
800055c2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055c4:	c0 a0       	breq	800055d8 <PcdComMF522+0xbc>
800055c6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800055ca:	c4 c1       	brne	80005662 <PcdComMF522+0x146>
800055cc:	ef e3 00 08 	and	r8,r7,r3
800055d0:	ea 08 18 00 	cp.b	r8,r5
800055d4:	cf 20       	breq	800055b8 <PcdComMF522+0x9c>
800055d6:	c4 68       	rjmp	80005662 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800055d8:	e0 6b 00 80 	mov	r11,128
800055dc:	30 dc       	mov	r12,13
800055de:	f0 1f 00 2b 	mcall	80005688 <PcdComMF522+0x16c>
800055e2:	30 27       	mov	r7,2
800055e4:	c3 38       	rjmp	8000564a <PcdComMF522+0x12e>
800055e6:	02 67       	and	r7,r1
800055e8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800055ec:	30 c8       	mov	r8,12
800055ee:	f0 02 18 00 	cp.b	r2,r8
800055f2:	c2 c1       	brne	8000564a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800055f4:	30 ac       	mov	r12,10
800055f6:	f0 1f 00 27 	mcall	80005690 <PcdComMF522+0x174>
800055fa:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
800055fc:	30 cc       	mov	r12,12
800055fe:	f0 1f 00 25 	mcall	80005690 <PcdComMF522+0x174>
80005602:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005606:	c0 70       	breq	80005614 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005608:	08 98       	mov	r8,r4
8000560a:	20 18       	sub	r8,1
8000560c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005610:	a0 8c       	st.b	r0[0x0],r12
80005612:	c0 48       	rjmp	8000561a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005614:	e8 08 15 03 	lsl	r8,r4,0x3
80005618:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000561a:	58 04       	cp.w	r4,0
8000561c:	c0 61       	brne	80005628 <PcdComMF522+0x10c>
8000561e:	30 14       	mov	r4,1
80005620:	40 05       	lddsp	r5,sp[0x0]
80005622:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005624:	30 93       	mov	r3,9
80005626:	c0 98       	rjmp	80005638 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005628:	31 28       	mov	r8,18
8000562a:	f0 04 18 00 	cp.b	r4,r8
8000562e:	f9 b4 0b 12 	movhi	r4,18
80005632:	58 04       	cp.w	r4,0
80005634:	cf 61       	brne	80005620 <PcdComMF522+0x104>
80005636:	c0 a8       	rjmp	8000564a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005638:	06 9c       	mov	r12,r3
8000563a:	f0 1f 00 16 	mcall	80005690 <PcdComMF522+0x174>
8000563e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005640:	ec 05 01 08 	sub	r8,r6,r5
80005644:	e8 08 19 00 	cp.h	r8,r4
80005648:	cf 83       	brcs	80005638 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
8000564a:	e0 6b 00 80 	mov	r11,128
8000564e:	30 cc       	mov	r12,12
80005650:	f0 1f 00 0f 	mcall	8000568c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80005654:	30 0b       	mov	r11,0
80005656:	30 1c       	mov	r12,1
80005658:	f0 1f 00 0b 	mcall	80005684 <PcdComMF522+0x168>
	return status;
}
8000565c:	0e 9c       	mov	r12,r7
8000565e:	2f fd       	sub	sp,-4
80005660:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80005662:	e0 6b 00 80 	mov	r11,128
80005666:	30 dc       	mov	r12,13
80005668:	f0 1f 00 08 	mcall	80005688 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
8000566c:	30 6c       	mov	r12,6
8000566e:	f0 1f 00 09 	mcall	80005690 <PcdComMF522+0x174>
80005672:	e2 1c 00 1b 	andl	r12,0x1b,COH
80005676:	cb 80       	breq	800055e6 <PcdComMF522+0xca>
80005678:	30 27       	mov	r7,2
8000567a:	ce 8b       	rjmp	8000564a <PcdComMF522+0x12e>
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	e9 c4 80 00 	stm	r4,pc
80005682:	e9 c8 80 00 	stm	r8,pc
80005686:	52 18       	stdsp	sp[0x84],r8
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	53 c0       	stdsp	sp[0xf0],r0
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	53 7c       	stdsp	sp[0xdc],r12
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	52 d8       	stdsp	sp[0xb4],r8

80005694 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005694:	eb cd 40 c0 	pushm	r6-r7,lr
80005698:	20 5d       	sub	sp,20
8000569a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
8000569c:	30 8b       	mov	r11,8
8000569e:	16 9c       	mov	r12,r11
800056a0:	f0 1f 00 1a 	mcall	80005708 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
800056a4:	30 0b       	mov	r11,0
800056a6:	30 dc       	mov	r12,13
800056a8:	f0 1f 00 19 	mcall	8000570c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800056ac:	e0 6b 00 80 	mov	r11,128
800056b0:	30 ec       	mov	r12,14
800056b2:	f0 1f 00 16 	mcall	80005708 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800056b6:	39 38       	mov	r8,-109
800056b8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800056ba:	32 08       	mov	r8,32
800056bc:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800056be:	1a 9b       	mov	r11,sp
800056c0:	fa c8 ff ed 	sub	r8,sp,-19
800056c4:	1a 99       	mov	r9,sp
800056c6:	30 2a       	mov	r10,2
800056c8:	30 cc       	mov	r12,12
800056ca:	f0 1f 00 12 	mcall	80005710 <PcdAnticoll+0x7c>
800056ce:	18 97       	mov	r7,r12

	if (status == MI_OK)
800056d0:	c1 21       	brne	800056f4 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056d2:	1b 89       	ld.ub	r9,sp[0x0]
800056d4:	ac 89       	st.b	r6[0x0],r9
800056d6:	1b 98       	ld.ub	r8,sp[0x1]
800056d8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800056da:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056dc:	1b a8       	ld.ub	r8,sp[0x2]
800056de:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800056e0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056e4:	1b b9       	ld.ub	r9,sp[0x3]
800056e6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800056e8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800056ea:	1b c9       	ld.ub	r9,sp[0x4]
800056ec:	f0 09 18 00 	cp.b	r9,r8
800056f0:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800056f4:	e0 6b 00 80 	mov	r11,128
800056f8:	30 ec       	mov	r12,14
800056fa:	f0 1f 00 07 	mcall	80005714 <PcdAnticoll+0x80>
	return status;
}
800056fe:	0e 9c       	mov	r12,r7
80005700:	2f bd       	sub	sp,-20
80005702:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005706:	00 00       	add	r0,r0
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	53 c0       	stdsp	sp[0xf0],r0
8000570c:	80 00       	ld.sh	r0,r0[0x0]
8000570e:	52 18       	stdsp	sp[0x84],r8
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	55 1c       	stdsp	sp[0x144],r12
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	53 7c       	stdsp	sp[0xdc],r12

80005718 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005718:	eb cd 40 c0 	pushm	r6-r7,lr
8000571c:	20 5d       	sub	sp,20
8000571e:	18 97       	mov	r7,r12
80005720:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80005722:	30 8b       	mov	r11,8
80005724:	16 9c       	mov	r12,r11
80005726:	f0 1f 00 12 	mcall	8000576c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
8000572a:	30 7b       	mov	r11,7
8000572c:	30 dc       	mov	r12,13
8000572e:	f0 1f 00 11 	mcall	80005770 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80005732:	30 3b       	mov	r11,3
80005734:	31 4c       	mov	r12,20
80005736:	f0 1f 00 10 	mcall	80005774 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
8000573a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
8000573c:	1a 9b       	mov	r11,sp
8000573e:	fa c8 ff ed 	sub	r8,sp,-19
80005742:	1a 99       	mov	r9,sp
80005744:	30 1a       	mov	r10,1
80005746:	30 cc       	mov	r12,12
80005748:	f0 1f 00 0c 	mcall	80005778 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
8000574c:	c0 c1       	brne	80005764 <PcdRequest+0x4c>
8000574e:	31 08       	mov	r8,16
80005750:	fb 39 00 13 	ld.ub	r9,sp[19]
80005754:	f0 09 18 00 	cp.b	r9,r8
80005758:	c0 61       	brne	80005764 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
8000575a:	1b 88       	ld.ub	r8,sp[0x0]
8000575c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000575e:	1b 98       	ld.ub	r8,sp[0x1]
80005760:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80005762:	c0 28       	rjmp	80005766 <PcdRequest+0x4e>
80005764:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80005766:	2f bd       	sub	sp,-20
80005768:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	53 c0       	stdsp	sp[0xf0],r0
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	52 18       	stdsp	sp[0x84],r8
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	53 7c       	stdsp	sp[0xdc],r12
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	55 1c       	stdsp	sp[0x144],r12

8000577c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
8000577c:	eb cd 40 f8 	pushm	r3-r7,lr
80005780:	18 95       	mov	r5,r12
80005782:	16 96       	mov	r6,r11
80005784:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005786:	30 4b       	mov	r11,4
80005788:	30 5c       	mov	r12,5
8000578a:	f0 1f 00 1c 	mcall	800057f8 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000578e:	30 0b       	mov	r11,0
80005790:	30 1c       	mov	r12,1
80005792:	f0 1f 00 1b 	mcall	800057fc <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005796:	e0 6b 00 80 	mov	r11,128
8000579a:	30 ac       	mov	r12,10
8000579c:	f0 1f 00 19 	mcall	80005800 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
800057a0:	58 06       	cp.w	r6,0
800057a2:	c0 c0       	breq	800057ba <CalulateCRC+0x3e>
800057a4:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
800057a6:	30 94       	mov	r4,9
800057a8:	0f 3b       	ld.ub	r11,r7++
800057aa:	08 9c       	mov	r12,r4
800057ac:	f0 1f 00 14 	mcall	800057fc <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800057b0:	0e 98       	mov	r8,r7
800057b2:	0a 18       	sub	r8,r5
800057b4:	ec 08 18 00 	cp.b	r8,r6
800057b8:	cf 83       	brcs	800057a8 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800057ba:	30 3b       	mov	r11,3
800057bc:	30 1c       	mov	r12,1
800057be:	f0 1f 00 10 	mcall	800057fc <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800057c2:	30 5c       	mov	r12,5
800057c4:	f0 1f 00 10 	mcall	80005804 <CalulateCRC+0x88>
800057c8:	e0 67 00 fe 	mov	r7,254
800057cc:	30 56       	mov	r6,5
800057ce:	c0 78       	rjmp	800057dc <CalulateCRC+0x60>
800057d0:	0c 9c       	mov	r12,r6
800057d2:	f0 1f 00 0d 	mcall	80005804 <CalulateCRC+0x88>
		i--;
800057d6:	20 17       	sub	r7,1
800057d8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800057da:	c0 40       	breq	800057e2 <CalulateCRC+0x66>
800057dc:	e2 1c 00 04 	andl	r12,0x4,COH
800057e0:	cf 80       	breq	800057d0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800057e2:	32 2c       	mov	r12,34
800057e4:	f0 1f 00 08 	mcall	80005804 <CalulateCRC+0x88>
800057e8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800057ea:	32 1c       	mov	r12,33
800057ec:	f0 1f 00 06 	mcall	80005804 <CalulateCRC+0x88>
800057f0:	a6 9c       	st.b	r3[0x1],r12
}
800057f2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800057f6:	00 00       	add	r0,r0
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	53 c0       	stdsp	sp[0xf0],r0
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	52 18       	stdsp	sp[0x84],r8
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	53 7c       	stdsp	sp[0xdc],r12
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	52 d8       	stdsp	sp[0xb4],r8

80005808 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005808:	eb cd 40 80 	pushm	r7,lr
8000580c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000580e:	39 38       	mov	r8,-109
80005810:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80005812:	37 08       	mov	r8,112
80005814:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005816:	30 08       	mov	r8,0
80005818:	ba e8       	st.b	sp[0x6],r8
8000581a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000581e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80005822:	19 89       	ld.ub	r9,r12[0x0]
80005824:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005826:	19 3a       	ld.ub	r10,r12++
80005828:	1b e9       	ld.ub	r9,sp[0x6]
8000582a:	f5 e9 20 09 	eor	r9,r10,r9
8000582e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80005830:	16 38       	cp.w	r8,r11
80005832:	cf 81       	brne	80005822 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005834:	1a 97       	mov	r7,sp
80005836:	fa ca ff f9 	sub	r10,sp,-7
8000583a:	30 7b       	mov	r11,7
8000583c:	1a 9c       	mov	r12,sp
8000583e:	f0 1f 00 0d 	mcall	80005870 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80005842:	30 8b       	mov	r11,8
80005844:	16 9c       	mov	r12,r11
80005846:	f0 1f 00 0c 	mcall	80005874 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
8000584a:	fa c8 ff ed 	sub	r8,sp,-19
8000584e:	1a 99       	mov	r9,sp
80005850:	30 9a       	mov	r10,9
80005852:	1a 9b       	mov	r11,sp
80005854:	30 cc       	mov	r12,12
80005856:	f0 1f 00 09 	mcall	80005878 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
8000585a:	c0 71       	brne	80005868 <PcdSelect+0x60>
8000585c:	31 88       	mov	r8,24
8000585e:	fb 39 00 13 	ld.ub	r9,sp[19]
80005862:	f0 09 18 00 	cp.b	r9,r8
80005866:	c0 20       	breq	8000586a <PcdSelect+0x62>
80005868:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
8000586a:	2f bd       	sub	sp,-20
8000586c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	57 7c       	stdsp	sp[0x1dc],r12
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	53 c0       	stdsp	sp[0xf0],r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	55 1c       	stdsp	sp[0x144],r12

8000587c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
8000587c:	eb cd 40 c0 	pushm	r6-r7,lr
80005880:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005882:	f0 1f 00 37 	mcall	8000595c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005886:	4b 7b       	lddpc	r11,80005960 <rfid_auto_reader+0xe4>
80005888:	35 2c       	mov	r12,82
8000588a:	f0 1f 00 37 	mcall	80005964 <rfid_auto_reader+0xe8>
8000588e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005890:	c6 31       	brne	80005956 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005892:	4b 48       	lddpc	r8,80005960 <rfid_auto_reader+0xe4>
80005894:	11 88       	ld.ub	r8,r8[0x0]
80005896:	30 49       	mov	r9,4
80005898:	f2 08 18 00 	cp.b	r8,r9
8000589c:	c0 b1       	brne	800058b2 <rfid_auto_reader+0x36>
8000589e:	4b 19       	lddpc	r9,80005960 <rfid_auto_reader+0xe4>
800058a0:	13 9a       	ld.ub	r10,r9[0x1]
800058a2:	30 09       	mov	r9,0
800058a4:	f2 0a 18 00 	cp.b	r10,r9
800058a8:	c0 51       	brne	800058b2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
800058aa:	4b 0c       	lddpc	r12,80005968 <rfid_auto_reader+0xec>
800058ac:	f0 1f 00 30 	mcall	8000596c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800058b0:	c3 c8       	rjmp	80005928 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058b2:	30 29       	mov	r9,2
800058b4:	f2 08 18 00 	cp.b	r8,r9
800058b8:	c0 b1       	brne	800058ce <rfid_auto_reader+0x52>
800058ba:	4a a9       	lddpc	r9,80005960 <rfid_auto_reader+0xe4>
800058bc:	13 9a       	ld.ub	r10,r9[0x1]
800058be:	30 09       	mov	r9,0
800058c0:	f2 0a 18 00 	cp.b	r10,r9
800058c4:	c0 51       	brne	800058ce <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800058c6:	4a bc       	lddpc	r12,80005970 <rfid_auto_reader+0xf4>
800058c8:	f0 1f 00 29 	mcall	8000596c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058cc:	c2 e8       	rjmp	80005928 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058ce:	34 49       	mov	r9,68
800058d0:	f2 08 18 00 	cp.b	r8,r9
800058d4:	c0 b1       	brne	800058ea <rfid_auto_reader+0x6e>
800058d6:	4a 39       	lddpc	r9,80005960 <rfid_auto_reader+0xe4>
800058d8:	13 9a       	ld.ub	r10,r9[0x1]
800058da:	30 09       	mov	r9,0
800058dc:	f2 0a 18 00 	cp.b	r10,r9
800058e0:	c0 51       	brne	800058ea <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
800058e2:	4a 5c       	lddpc	r12,80005974 <rfid_auto_reader+0xf8>
800058e4:	f0 1f 00 22 	mcall	8000596c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058e8:	c2 08       	rjmp	80005928 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800058ea:	30 89       	mov	r9,8
800058ec:	f2 08 18 00 	cp.b	r8,r9
800058f0:	c0 b1       	brne	80005906 <rfid_auto_reader+0x8a>
800058f2:	49 c9       	lddpc	r9,80005960 <rfid_auto_reader+0xe4>
800058f4:	13 9a       	ld.ub	r10,r9[0x1]
800058f6:	30 09       	mov	r9,0
800058f8:	f2 0a 18 00 	cp.b	r10,r9
800058fc:	c0 51       	brne	80005906 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
800058fe:	49 fc       	lddpc	r12,80005978 <rfid_auto_reader+0xfc>
80005900:	f0 1f 00 1b 	mcall	8000596c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005904:	c1 28       	rjmp	80005928 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005906:	34 49       	mov	r9,68
80005908:	f2 08 18 00 	cp.b	r8,r9
8000590c:	c0 b1       	brne	80005922 <rfid_auto_reader+0xa6>
8000590e:	49 58       	lddpc	r8,80005960 <rfid_auto_reader+0xe4>
80005910:	11 99       	ld.ub	r9,r8[0x1]
80005912:	30 38       	mov	r8,3
80005914:	f0 09 18 00 	cp.b	r9,r8
80005918:	c0 51       	brne	80005922 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000591a:	49 9c       	lddpc	r12,8000597c <rfid_auto_reader+0x100>
8000591c:	f0 1f 00 14 	mcall	8000596c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005920:	c0 48       	rjmp	80005928 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005922:	49 8c       	lddpc	r12,80005980 <rfid_auto_reader+0x104>
80005924:	f0 1f 00 12 	mcall	8000596c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005928:	49 7c       	lddpc	r12,80005984 <rfid_auto_reader+0x108>
8000592a:	f0 1f 00 18 	mcall	80005988 <rfid_auto_reader+0x10c>
8000592e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005930:	c0 60       	breq	8000593c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80005932:	34 fb       	mov	r11,79
80005934:	30 1c       	mov	r12,1
80005936:	f0 1f 00 16 	mcall	8000598c <rfid_auto_reader+0x110>
		return status;
8000593a:	c0 e8       	rjmp	80005956 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
8000593c:	49 2c       	lddpc	r12,80005984 <rfid_auto_reader+0x108>
8000593e:	f0 1f 00 15 	mcall	80005990 <rfid_auto_reader+0x114>
80005942:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005944:	c0 91       	brne	80005956 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005946:	30 4a       	mov	r10,4
80005948:	48 fb       	lddpc	r11,80005984 <rfid_auto_reader+0x108>
8000594a:	0c 9c       	mov	r12,r6
8000594c:	f0 1f 00 12 	mcall	80005994 <rfid_auto_reader+0x118>
		log("select okay\n");
80005950:	49 2c       	lddpc	r12,80005998 <rfid_auto_reader+0x11c>
80005952:	f0 1f 00 07 	mcall	8000596c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005956:	0e 9c       	mov	r12,r7
80005958:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	52 58       	stdsp	sp[0x94],r8
80005960:	00 00       	add	r0,r0
80005962:	97 b0       	st.w	r11[0x2c],r0
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	57 18       	stdsp	sp[0x1c4],r8
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	e9 e4 80 00 	sthh.w	r0[r0],r4:b,r4:b
8000596e:	7f 64       	ld.w	r4,pc[0x58]
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	e9 f0 80 00 	ld.wls	r0,r4[0x0]
80005976:	e9 fc 80 00 	ld.wls	r12,r4[0x0]
8000597a:	ea 0c       	*unknown*
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	ea 14 80 00 	orh	r4,0x8000
80005982:	ea 20 00 00 	sub	r0,655360
80005986:	97 b4       	st.w	r11[0x2c],r4
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	56 94       	stdsp	sp[0x1a4],r4
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	49 ac       	lddpc	r12,800059f4 <scan_rfid_save_message+0x8>
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	58 08       	cp.w	r8,0
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	88 0e       	ld.sh	lr,r4[0x0]
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	ea 2c eb cd 	sub	r12,715725

8000599c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
8000599c:	eb cd 40 80 	pushm	r7,lr
800059a0:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
800059a2:	f0 1f 00 0d 	mcall	800059d4 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
800059a6:	30 0c       	mov	r12,0
800059a8:	f0 1f 00 0c 	mcall	800059d8 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
800059ac:	0e 9c       	mov	r12,r7
800059ae:	f0 1f 00 0c 	mcall	800059dc <scan_patrol+0x40>
800059b2:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800059b4:	30 1c       	mov	r12,1
800059b6:	f0 1f 00 09 	mcall	800059d8 <scan_patrol+0x3c>
	if(return_err == 0)
800059ba:	58 07       	cp.w	r7,0
800059bc:	c0 51       	brne	800059c6 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800059be:	48 9c       	lddpc	r12,800059e0 <scan_patrol+0x44>
800059c0:	f0 1f 00 09 	mcall	800059e4 <scan_patrol+0x48>
800059c4:	c0 48       	rjmp	800059cc <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800059c6:	48 9c       	lddpc	r12,800059e8 <scan_patrol+0x4c>
800059c8:	f0 1f 00 07 	mcall	800059e4 <scan_patrol+0x48>
		
	return return_err;

}
800059cc:	0e 9c       	mov	r12,r7
800059ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800059d2:	00 00       	add	r0,r0
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	52 58       	stdsp	sp[0x94],r8
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	53 30       	stdsp	sp[0xcc],r0
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	58 7c       	cp.w	r12,7
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	ea 3c 80 00 	sub	r12,753664
800059e6:	7f 64       	ld.w	r4,pc[0x58]
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	ea 50 eb cd 	cp.w	r0,781261

800059ec <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
800059ec:	eb cd 40 e0 	pushm	r5-r7,lr
800059f0:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800059f2:	4e 9c       	lddpc	r12,80005b94 <scan_rfid_save_message+0x1a8>
800059f4:	30 08       	mov	r8,0
800059f6:	30 09       	mov	r9,0
800059f8:	f8 e9 00 00 	st.d	r12[0],r8
800059fc:	30 0a       	mov	r10,0
800059fe:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005a00:	fa e9 00 24 	st.d	sp[36],r8
80005a04:	fa e9 00 2c 	st.d	sp[44],r8
80005a08:	fa e9 00 34 	st.d	sp[52],r8
80005a0c:	fa e9 00 3c 	st.d	sp[60],r8
80005a10:	fa e9 00 44 	st.d	sp[68],r8
80005a14:	fa e9 00 4c 	st.d	sp[76],r8
80005a18:	fa e9 00 54 	st.d	sp[84],r8
80005a1c:	fa e9 00 5c 	st.d	sp[92],r8
80005a20:	fa e9 00 64 	st.d	sp[100],r8
80005a24:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80005a28:	f0 1f 00 5c 	mcall	80005b98 <scan_rfid_save_message+0x1ac>
80005a2c:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005a2e:	e0 81 00 a7 	brne	80005b7c <scan_rfid_save_message+0x190>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005a32:	4d 96       	lddpc	r6,80005b94 <scan_rfid_save_message+0x1a8>
80005a34:	0d b8       	ld.ub	r8,r6[0x3]
80005a36:	1a d8       	st.w	--sp,r8
80005a38:	0d a8       	ld.ub	r8,r6[0x2]
80005a3a:	1a d8       	st.w	--sp,r8
80005a3c:	0d 98       	ld.ub	r8,r6[0x1]
80005a3e:	1a d8       	st.w	--sp,r8
80005a40:	0d 88       	ld.ub	r8,r6[0x0]
80005a42:	1a d8       	st.w	--sp,r8
80005a44:	4d 6c       	lddpc	r12,80005b9c <scan_rfid_save_message+0x1b0>
80005a46:	f0 1f 00 57 	mcall	80005ba0 <scan_rfid_save_message+0x1b4>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005a4a:	34 4b       	mov	r11,68
80005a4c:	30 1c       	mov	r12,1
80005a4e:	f0 1f 00 56 	mcall	80005ba4 <scan_rfid_save_message+0x1b8>
80005a52:	fa c8 ff ec 	sub	r8,sp,-20
80005a56:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80005a5a:	ec c5 ff fc 	sub	r5,r6,-4
80005a5e:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a60:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a62:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005a64:	0d 8a       	ld.ub	r10,r6[0x0]
80005a66:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a6a:	fc 0b 18 00 	cp.b	r11,lr
80005a6e:	f7 bb 08 d0 	subls	r11,-48
80005a72:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005a76:	f7 bb 0b a9 	subhi	r11,-87
80005a7a:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a7e:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005a80:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005a84:	fc 0a 18 00 	cp.b	r10,lr
80005a88:	f7 ba 08 d0 	subls	r10,-48
80005a8c:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005a90:	f7 ba 0b a9 	subhi	r10,-87
80005a94:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005a98:	b0 bc       	st.b	r8[0x3],r12
80005a9a:	2f f6       	sub	r6,-1
80005a9c:	2f c8       	sub	r8,-4
80005a9e:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005aa0:	0a 36       	cp.w	r6,r5
80005aa2:	ce 11       	brne	80005a64 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005aa4:	30 6a       	mov	r10,6
80005aa6:	4c 1b       	lddpc	r11,80005ba8 <scan_rfid_save_message+0x1bc>
80005aa8:	fa cc ff ec 	sub	r12,sp,-20
80005aac:	f0 1f 00 40 	mcall	80005bac <scan_rfid_save_message+0x1c0>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005ab0:	4c 08       	lddpc	r8,80005bb0 <scan_rfid_save_message+0x1c4>
80005ab2:	11 89       	ld.ub	r9,r8[0x0]
80005ab4:	39 f8       	mov	r8,-97
80005ab6:	f0 09 18 00 	cp.b	r9,r8
80005aba:	e0 88 00 05 	brls	80005ac4 <scan_rfid_save_message+0xd8>
80005abe:	38 09       	mov	r9,-128
80005ac0:	4b c8       	lddpc	r8,80005bb0 <scan_rfid_save_message+0x1c4>
80005ac2:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005ac4:	4b b8       	lddpc	r8,80005bb0 <scan_rfid_save_message+0x1c4>
80005ac6:	11 86       	ld.ub	r6,r8[0x0]
80005ac8:	2f f6       	sub	r6,-1
80005aca:	5c 56       	castu.b	r6
80005acc:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005ace:	30 5a       	mov	r10,5
80005ad0:	4b 9b       	lddpc	r11,80005bb4 <scan_rfid_save_message+0x1c8>
80005ad2:	fa cc ff e1 	sub	r12,sp,-31
80005ad6:	f0 1f 00 36 	mcall	80005bac <scan_rfid_save_message+0x1c0>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005ada:	31 e8       	mov	r8,30
80005adc:	fb 58 00 1a 	st.h	sp[26],r8
80005ae0:	fb 66 00 1e 	st.b	sp[30],r6
80005ae4:	fe 78 e0 00 	mov	r8,-8192
80005ae8:	fb 58 00 1c 	st.h	sp[28],r8
80005aec:	30 aa       	mov	r10,10
80005aee:	fa cb ff e6 	sub	r11,sp,-26
80005af2:	fa cc ff dc 	sub	r12,sp,-36
80005af6:	f0 1f 00 2e 	mcall	80005bac <scan_rfid_save_message+0x1c0>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005afa:	31 6a       	mov	r10,22
80005afc:	fa cb ff fc 	sub	r11,sp,-4
80005b00:	fa cc ff d2 	sub	r12,sp,-46
80005b04:	f0 1f 00 2a 	mcall	80005bac <scan_rfid_save_message+0x1c0>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005b08:	4a c8       	lddpc	r8,80005bb8 <scan_rfid_save_message+0x1cc>
80005b0a:	70 0c       	ld.w	r12,r8[0x0]
80005b0c:	f0 1f 00 2c 	mcall	80005bbc <scan_rfid_save_message+0x1d0>
80005b10:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005b12:	c3 10       	breq	80005b74 <scan_rfid_save_message+0x188>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005b14:	32 0a       	mov	r10,32
80005b16:	fa cb ff dc 	sub	r11,sp,-36
80005b1a:	f0 1f 00 25 	mcall	80005bac <scan_rfid_save_message+0x1c0>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005b1e:	4a 98       	lddpc	r8,80005bc0 <scan_rfid_save_message+0x1d4>
80005b20:	70 0c       	ld.w	r12,r8[0x0]
80005b22:	30 09       	mov	r9,0
80005b24:	12 9a       	mov	r10,r9
80005b26:	1a 9b       	mov	r11,sp
80005b28:	f0 1f 00 27 	mcall	80005bc4 <scan_rfid_save_message+0x1d8>
80005b2c:	58 1c       	cp.w	r12,1
80005b2e:	c1 10       	breq	80005b50 <scan_rfid_save_message+0x164>
			{
				log("xg_resend_queue: full\n" );
80005b30:	4a 6c       	lddpc	r12,80005bc8 <scan_rfid_save_message+0x1dc>
80005b32:	f0 1f 00 1c 	mcall	80005ba0 <scan_rfid_save_message+0x1b4>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005b36:	32 3b       	mov	r11,35
80005b38:	30 1c       	mov	r12,1
80005b3a:	f0 1f 00 1b 	mcall	80005ba4 <scan_rfid_save_message+0x1b8>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005b3e:	e0 6c 17 70 	mov	r12,6000
80005b42:	f0 1f 00 23 	mcall	80005bcc <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005b46:	32 3b       	mov	r11,35
80005b48:	30 0c       	mov	r12,0
80005b4a:	f0 1f 00 17 	mcall	80005ba4 <scan_rfid_save_message+0x1b8>
80005b4e:	c1 e8       	rjmp	80005b8a <scan_rfid_save_message+0x19e>
			}
			else
			{
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005b50:	4a 06       	lddpc	r6,80005bd0 <scan_rfid_save_message+0x1e4>
80005b52:	6c 0c       	ld.w	r12,r6[0x0]
80005b54:	30 09       	mov	r9,0
80005b56:	3f fa       	mov	r10,-1
80005b58:	12 9b       	mov	r11,r9
80005b5a:	f0 1f 00 1f 	mcall	80005bd4 <scan_rfid_save_message+0x1e8>
				global_count++;
80005b5e:	49 f8       	lddpc	r8,80005bd8 <scan_rfid_save_message+0x1ec>
80005b60:	70 09       	ld.w	r9,r8[0x0]
80005b62:	2f f9       	sub	r9,-1
80005b64:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005b66:	6c 0c       	ld.w	r12,r6[0x0]
80005b68:	30 09       	mov	r9,0
80005b6a:	12 9a       	mov	r10,r9
80005b6c:	12 9b       	mov	r11,r9
80005b6e:	f0 1f 00 16 	mcall	80005bc4 <scan_rfid_save_message+0x1d8>
80005b72:	c0 c8       	rjmp	80005b8a <scan_rfid_save_message+0x19e>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005b74:	49 ac       	lddpc	r12,80005bdc <scan_rfid_save_message+0x1f0>
80005b76:	f0 1f 00 0b 	mcall	80005ba0 <scan_rfid_save_message+0x1b4>
80005b7a:	c0 88       	rjmp	80005b8a <scan_rfid_save_message+0x19e>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005b7c:	34 fb       	mov	r11,79
80005b7e:	30 1c       	mov	r12,1
80005b80:	f0 1f 00 09 	mcall	80005ba4 <scan_rfid_save_message+0x1b8>
		log("no card find...\n");
80005b84:	49 7c       	lddpc	r12,80005be0 <scan_rfid_save_message+0x1f4>
80005b86:	f0 1f 00 07 	mcall	80005ba0 <scan_rfid_save_message+0x1b4>
	}
	
	return return_err;
	

}
80005b8a:	0e 9c       	mov	r12,r7
80005b8c:	2e 3d       	sub	sp,-116
80005b8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b92:	00 00       	add	r0,r0
80005b94:	00 00       	add	r0,r0
80005b96:	0b 84       	ld.ub	r4,r5[0x0]
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	59 9c       	cp.w	r12,25
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	ea 64 80 00 	mov	r4,688128
80005ba2:	7f 64       	ld.w	r4,pc[0x58]
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	49 ac       	lddpc	r12,80005c0c <delay_us+0x4>
80005ba8:	00 00       	add	r0,r0
80005baa:	0e 20       	rsub	r0,r7
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	88 0e       	ld.sh	lr,r4[0x0]
80005bb0:	00 00       	add	r0,r0
80005bb2:	05 3c       	ld.ub	r12,r2++
80005bb4:	00 00       	add	r0,r0
80005bb6:	05 34       	ld.ub	r4,r2++
80005bb8:	00 00       	add	r0,r0
80005bba:	0b 9c       	ld.ub	r12,r5[0x1]
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	36 f0       	mov	r0,111
80005bc0:	00 00       	add	r0,r0
80005bc2:	0b 90       	ld.ub	r0,r5[0x1]
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	73 2c       	ld.w	r12,r9[0x48]
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	e8 8c 80 00 	brvs	80115bca <_data_lma+0x1065a2>
80005bce:	79 f8       	ld.w	r8,r12[0x7c]
80005bd0:	00 00       	add	r0,r0
80005bd2:	0a 78       	tst	r8,r5
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	71 20       	ld.w	r0,r8[0x48]
80005bd8:	00 00       	add	r0,r0
80005bda:	0a 80       	andn	r0,r5
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	e8 a4       	*unknown*
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	ea 80 d4 01 	breq	801603e4 <_data_lma+0x150dbc>

80005be4 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005be4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005be6:	f0 1f 00 02 	mcall	80005bec <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005bea:	d8 02       	popm	pc
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	54 68       	stdsp	sp[0x118],r8

80005bf0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005bf0:	58 0c       	cp.w	r12,0
80005bf2:	5e 0c       	reteq	r12
80005bf4:	30 08       	mov	r8,0
	{
		nop();
80005bf6:	d7 03       	nop
		nop();
80005bf8:	d7 03       	nop
		nop();
80005bfa:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005bfc:	2f f8       	sub	r8,-1
80005bfe:	10 3c       	cp.w	r12,r8
80005c00:	fe 9b ff fb 	brhi	80005bf6 <delay_ns+0x6>
80005c04:	5e fc       	retal	r12
80005c06:	d7 03       	nop

80005c08 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005c08:	eb cd 40 e0 	pushm	r5-r7,lr
80005c0c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005c0e:	58 0c       	cp.w	r12,0
80005c10:	c0 b0       	breq	80005c26 <delay_us+0x1e>
80005c12:	30 07       	mov	r7,0
		delay_ns(1000);
80005c14:	e0 65 03 e8 	mov	r5,1000
80005c18:	0a 9c       	mov	r12,r5
80005c1a:	f0 1f 00 05 	mcall	80005c2c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005c1e:	2f f7       	sub	r7,-1
80005c20:	0e 36       	cp.w	r6,r7
80005c22:	fe 9b ff fb 	brhi	80005c18 <delay_us+0x10>
80005c26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c2a:	00 00       	add	r0,r0
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	5b f0       	cp.w	r0,-1

80005c30 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005c30:	eb cd 40 e0 	pushm	r5-r7,lr
80005c34:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005c36:	58 0c       	cp.w	r12,0
80005c38:	c0 b0       	breq	80005c4e <delay_ms+0x1e>
80005c3a:	30 07       	mov	r7,0
		delay_us(1000);
80005c3c:	e0 65 03 e8 	mov	r5,1000
80005c40:	0a 9c       	mov	r12,r5
80005c42:	f0 1f 00 05 	mcall	80005c54 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005c46:	2f f7       	sub	r7,-1
80005c48:	0e 36       	cp.w	r6,r7
80005c4a:	fe 9b ff fb 	brhi	80005c40 <delay_ms+0x10>
80005c4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c52:	00 00       	add	r0,r0
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	5c 08       	acr	r8

80005c58 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005c58:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005c5a:	30 3b       	mov	r11,3
80005c5c:	48 8c       	lddpc	r12,80005c7c <local_start_timer+0x24>
80005c5e:	f0 1f 00 09 	mcall	80005c80 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005c62:	fe 78 38 00 	mov	r8,-51200
80005c66:	e0 69 91 0d 	mov	r9,37133
80005c6a:	ea 19 00 52 	orh	r9,0x52
80005c6e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005c70:	32 09       	mov	r9,32
80005c72:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c74:	30 59       	mov	r9,5
80005c76:	91 09       	st.w	r8[0x0],r9
}
80005c78:	d8 02       	popm	pc
80005c7a:	00 00       	add	r0,r0
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	ea 94 80 00 	brge	80175c7e <_data_lma+0x166656>
80005c82:	63 48       	ld.w	r8,r1[0x50]

80005c84 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005c84:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005c86:	30 3a       	mov	r10,3
80005c88:	e0 6b 1b 00 	mov	r11,6912
80005c8c:	ea 1b 00 b7 	orh	r11,0xb7
80005c90:	fe 7c 0c 00 	mov	r12,-62464
80005c94:	f0 1f 00 19 	mcall	80005cf8 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005c98:	31 08       	mov	r8,16
80005c9a:	1a d8       	st.w	--sp,r8
80005c9c:	30 08       	mov	r8,0
80005c9e:	30 19       	mov	r9,1
80005ca0:	30 7a       	mov	r10,7
80005ca2:	10 9b       	mov	r11,r8
80005ca4:	fe 7c 0c 00 	mov	r12,-62464
80005ca8:	f0 1f 00 15 	mcall	80005cfc <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005cac:	30 08       	mov	r8,0
80005cae:	30 19       	mov	r9,1
80005cb0:	12 9a       	mov	r10,r9
80005cb2:	10 9b       	mov	r11,r8
80005cb4:	fe 7c 0c 00 	mov	r12,-62464
80005cb8:	f0 1f 00 12 	mcall	80005d00 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005cbc:	30 0b       	mov	r11,0
80005cbe:	fe 7c 0c 00 	mov	r12,-62464
80005cc2:	f0 1f 00 11 	mcall	80005d04 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005cc6:	fe 7c 0c 00 	mov	r12,-62464
80005cca:	f0 1f 00 10 	mcall	80005d08 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005cce:	30 0a       	mov	r10,0
80005cd0:	1a da       	st.w	--sp,r10
80005cd2:	1a da       	st.w	--sp,r10
80005cd4:	14 98       	mov	r8,r10
80005cd6:	14 99       	mov	r9,r10
80005cd8:	30 1b       	mov	r11,1
80005cda:	fe 7c 0c 00 	mov	r12,-62464
80005cde:	f0 1f 00 0c 	mcall	80005d0c <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005ce2:	30 1c       	mov	r12,1
80005ce4:	f0 1f 00 0b 	mcall	80005d10 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005ce8:	30 2b       	mov	r11,2
80005cea:	fe 7c 0c 00 	mov	r12,-62464
80005cee:	f0 1f 00 0a 	mcall	80005d14 <local_start_pll0+0x90>
80005cf2:	2f dd       	sub	sp,-12
/****/
}
80005cf4:	d8 02       	popm	pc
80005cf6:	00 00       	add	r0,r0
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	66 50       	ld.w	r0,r3[0x14]
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	65 f2       	ld.w	r2,r2[0x7c]
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	66 14       	ld.w	r4,r3[0x4]
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	66 2e       	ld.w	lr,r3[0x8]
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	66 3c       	ld.w	r12,r3[0xc]
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	65 ac       	ld.w	r12,r2[0x68]
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	62 e8       	ld.w	r8,r1[0x38]
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	66 46       	ld.w	r6,r3[0x10]

80005d18 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005d18:	d4 31       	pushm	r0-r7,lr
80005d1a:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005d1c:	f0 1f 00 8a 	mcall	80005f44 <xg_flashc_init+0x22c>
80005d20:	fe f8 02 28 	ld.w	r8,pc[552]
80005d24:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005d26:	70 08       	ld.w	r8,r8[0x0]
80005d28:	58 08       	cp.w	r8,0
80005d2a:	c0 51       	brne	80005d34 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005d2c:	fe fc 02 20 	ld.w	r12,pc[544]
80005d30:	f0 1f 00 88 	mcall	80005f50 <xg_flashc_init+0x238>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005d34:	30 0b       	mov	r11,0
80005d36:	30 1c       	mov	r12,1
80005d38:	f0 1f 00 87 	mcall	80005f54 <xg_flashc_init+0x23c>
80005d3c:	fe f8 02 1c 	ld.w	r8,pc[540]
80005d40:	91 0c       	st.w	r8[0x0],r12
80005d42:	70 08       	ld.w	r8,r8[0x0]
80005d44:	58 08       	cp.w	r8,0
80005d46:	c0 90       	breq	80005d58 <xg_flashc_init+0x40>
80005d48:	fe f8 02 10 	ld.w	r8,pc[528]
80005d4c:	70 0c       	ld.w	r12,r8[0x0]
80005d4e:	30 09       	mov	r9,0
80005d50:	12 9a       	mov	r10,r9
80005d52:	12 9b       	mov	r11,r9
80005d54:	f0 1f 00 82 	mcall	80005f5c <xg_flashc_init+0x244>
	if (xBinarySemaphore == NULL)
80005d58:	fe f8 02 00 	ld.w	r8,pc[512]
80005d5c:	70 08       	ld.w	r8,r8[0x0]
80005d5e:	58 08       	cp.w	r8,0
80005d60:	c0 51       	brne	80005d6a <xg_flashc_init+0x52>
	{
		log("Create the xBinarySemaphore semaphore failure\n");
80005d62:	fe fc 01 fe 	ld.w	r12,pc[510]
80005d66:	f0 1f 00 7b 	mcall	80005f50 <xg_flashc_init+0x238>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
80005d6a:	30 4b       	mov	r11,4
80005d6c:	e0 6c 01 0e 	mov	r12,270
80005d70:	f0 1f 00 79 	mcall	80005f54 <xg_flashc_init+0x23c>
80005d74:	4f c8       	lddpc	r8,80005f64 <xg_flashc_init+0x24c>
80005d76:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005d78:	30 4b       	mov	r11,4
80005d7a:	e0 6c 01 2c 	mov	r12,300
80005d7e:	f0 1f 00 76 	mcall	80005f54 <xg_flashc_init+0x23c>
80005d82:	4f a8       	lddpc	r8,80005f68 <xg_flashc_init+0x250>
80005d84:	91 0c       	st.w	r8[0x0],r12
80005d86:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005d88:	10 96       	mov	r6,r8
80005d8a:	4f 95       	lddpc	r5,80005f6c <xg_flashc_init+0x254>
80005d8c:	6c 0c       	ld.w	r12,r6[0x0]
80005d8e:	ea 07 00 0b 	add	r11,r5,r7
80005d92:	f0 1f 00 78 	mcall	80005f70 <xg_flashc_init+0x258>
80005d96:	2e 07       	sub	r7,-32
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005d98:	e0 47 25 80 	cp.w	r7,9600
80005d9c:	cf 81       	brne	80005d8c <xg_flashc_init+0x74>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005d9e:	f0 1f 00 76 	mcall	80005f74 <xg_flashc_init+0x25c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005da2:	30 0a       	mov	r10,0
80005da4:	30 0b       	mov	r11,0
80005da6:	4f 58       	lddpc	r8,80005f78 <xg_flashc_init+0x260>
80005da8:	b1 2a       	st.d	r8++,r10
80005daa:	b1 2a       	st.d	r8++,r10
80005dac:	b1 2a       	st.d	r8++,r10
80005dae:	b1 2a       	st.d	r8++,r10
80005db0:	b1 2a       	st.d	r8++,r10
80005db2:	b1 2a       	st.d	r8++,r10
80005db4:	b1 2a       	st.d	r8++,r10
80005db6:	b1 2a       	st.d	r8++,r10
80005db8:	b1 2a       	st.d	r8++,r10
80005dba:	f0 eb 00 00 	st.d	r8[0],r10
80005dbe:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005dc0:	4e e7       	lddpc	r7,80005f78 <xg_flashc_init+0x260>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005dc2:	ee c4 ff f8 	sub	r4,r7,-8
80005dc6:	e8 c3 ff f8 	sub	r3,r4,-8
80005dca:	e6 c2 ff f8 	sub	r2,r3,-8
80005dce:	e4 c1 ff f8 	sub	r1,r2,-8
80005dd2:	e2 c0 ff f8 	sub	r0,r1,-8
80005dd6:	e0 ca ff f8 	sub	r10,r0,-8
80005dda:	50 0a       	stdsp	sp[0x0],r10
80005ddc:	2f 8a       	sub	r10,-8
80005dde:	50 1a       	stdsp	sp[0x4],r10
80005de0:	2f 8a       	sub	r10,-8
80005de2:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005de4:	0e 9a       	mov	r10,r7
80005de6:	30 6b       	mov	r11,6
80005de8:	30 0c       	mov	r12,0
80005dea:	f0 1f 00 65 	mcall	80005f7c <xg_flashc_init+0x264>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005dee:	30 6a       	mov	r10,6
80005df0:	0e 9b       	mov	r11,r7
80005df2:	4e 4c       	lddpc	r12,80005f80 <xg_flashc_init+0x268>
80005df4:	f0 1f 00 64 	mcall	80005f84 <xg_flashc_init+0x26c>
80005df8:	c1 c0       	breq	80005e30 <xg_flashc_init+0x118>
80005dfa:	c8 b8       	rjmp	80005f10 <xg_flashc_init+0x1f8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005dfc:	30 6a       	mov	r10,6
80005dfe:	30 0b       	mov	r11,0
80005e00:	4e 0c       	lddpc	r12,80005f80 <xg_flashc_init+0x268>
80005e02:	f0 1f 00 62 	mcall	80005f88 <xg_flashc_init+0x270>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005e06:	4d d7       	lddpc	r7,80005f78 <xg_flashc_init+0x260>
80005e08:	35 0a       	mov	r10,80
80005e0a:	30 0b       	mov	r11,0
80005e0c:	0e 9c       	mov	r12,r7
80005e0e:	f0 1f 00 60 	mcall	80005f8c <xg_flashc_init+0x274>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005e12:	30 2a       	mov	r10,2
80005e14:	30 6b       	mov	r11,6
80005e16:	0e 9c       	mov	r12,r7
80005e18:	f0 1f 00 5c 	mcall	80005f88 <xg_flashc_init+0x270>
			if(return_code != DF_WRITE_COMPLETED)
80005e1c:	58 7c       	cp.w	r12,7
80005e1e:	e0 81 00 90 	brne	80005f3e <xg_flashc_init+0x226>
			{
				return FALSE;
			}
			current_message_index = 0;
80005e22:	30 09       	mov	r9,0
80005e24:	4d b8       	lddpc	r8,80005f90 <xg_flashc_init+0x278>
80005e26:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005e28:	4d bc       	lddpc	r12,80005f94 <xg_flashc_init+0x27c>
80005e2a:	f0 1f 00 4a 	mcall	80005f50 <xg_flashc_init+0x238>
80005e2e:	c8 58       	rjmp	80005f38 <xg_flashc_init+0x220>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005e30:	1a d7       	st.w	--sp,r7
80005e32:	4d ac       	lddpc	r12,80005f98 <xg_flashc_init+0x280>
80005e34:	f0 1f 00 47 	mcall	80005f50 <xg_flashc_init+0x238>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005e38:	4d 6a       	lddpc	r10,80005f90 <xg_flashc_init+0x278>
80005e3a:	30 2b       	mov	r11,2
80005e3c:	30 6c       	mov	r12,6
80005e3e:	f0 1f 00 50 	mcall	80005f7c <xg_flashc_init+0x264>
			if(return_code == DF_OK)
80005e42:	2f fd       	sub	sp,-4
80005e44:	58 0c       	cp.w	r12,0
80005e46:	e0 81 00 7c 	brne	80005f3e <xg_flashc_init+0x226>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005e4a:	4d 28       	lddpc	r8,80005f90 <xg_flashc_init+0x278>
80005e4c:	90 08       	ld.sh	r8,r8[0x0]
80005e4e:	58 08       	cp.w	r8,0
80005e50:	c7 10       	breq	80005f32 <xg_flashc_init+0x21a>
					
					log("current_message_index: %d\n", current_message_index);
80005e52:	5c 78       	castu.h	r8
80005e54:	1a d8       	st.w	--sp,r8
80005e56:	4d 2c       	lddpc	r12,80005f9c <xg_flashc_init+0x284>
80005e58:	f0 1f 00 3e 	mcall	80005f50 <xg_flashc_init+0x238>
					memset(str, 0x00, sizeof(str));	
80005e5c:	30 08       	mov	r8,0
80005e5e:	30 09       	mov	r9,0
80005e60:	ee e9 00 00 	st.d	r7[0],r8
80005e64:	e8 e9 00 00 	st.d	r4[0],r8
80005e68:	e6 e9 00 00 	st.d	r3[0],r8
80005e6c:	e4 e9 00 00 	st.d	r2[0],r8
80005e70:	e2 e9 00 00 	st.d	r1[0],r8
80005e74:	e0 e9 00 00 	st.d	r0[0],r8
80005e78:	40 1a       	lddsp	r10,sp[0x4]
80005e7a:	f4 e9 00 00 	st.d	r10[0],r8
80005e7e:	40 2a       	lddsp	r10,sp[0x8]
80005e80:	f4 e9 00 00 	st.d	r10[0],r8
80005e84:	40 3a       	lddsp	r10,sp[0xc]
80005e86:	b5 28       	st.d	r10++,r8
80005e88:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005e8c:	4c 18       	lddpc	r8,80005f90 <xg_flashc_init+0x278>
80005e8e:	90 85       	ld.uh	r5,r8[0x0]
80005e90:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005e92:	0e 9a       	mov	r10,r7
80005e94:	30 8b       	mov	r11,8
80005e96:	0a 9c       	mov	r12,r5
80005e98:	f0 1f 00 39 	mcall	80005f7c <xg_flashc_init+0x264>
					if(return_code == DF_OK)
80005e9c:	2f fd       	sub	sp,-4
80005e9e:	58 0c       	cp.w	r12,0
80005ea0:	c4 91       	brne	80005f32 <xg_flashc_init+0x21a>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005ea2:	0f 89       	ld.ub	r9,r7[0x0]
80005ea4:	0f 98       	ld.ub	r8,r7[0x1]
80005ea6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005eaa:	4b a9       	lddpc	r9,80005f90 <xg_flashc_init+0x278>
80005eac:	92 09       	ld.sh	r9,r9[0x0]
80005eae:	f0 09 19 00 	cp.h	r9,r8
80005eb2:	c2 c1       	brne	80005f0a <xg_flashc_init+0x1f2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005eb4:	0f e9       	ld.ub	r9,r7[0x6]
80005eb6:	0f f8       	ld.ub	r8,r7[0x7]
80005eb8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005ebc:	0f aa       	ld.ub	r10,r7[0x2]
80005ebe:	0f b8       	ld.ub	r8,r7[0x3]
80005ec0:	b1 68       	lsl	r8,0x10
80005ec2:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005ec6:	0f ca       	ld.ub	r10,r7[0x4]
80005ec8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005ecc:	0f da       	ld.ub	r10,r7[0x5]
80005ece:	f5 e8 10 08 	or	r8,r10,r8
80005ed2:	f2 08 00 08 	add	r8,r9,r8
80005ed6:	4b 36       	lddpc	r6,80005fa0 <xg_flashc_init+0x288>
80005ed8:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005eda:	1a d8       	st.w	--sp,r8
80005edc:	4b 2c       	lddpc	r12,80005fa4 <xg_flashc_init+0x28c>
80005ede:	f0 1f 00 1d 	mcall	80005f50 <xg_flashc_init+0x238>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005ee2:	2f fd       	sub	sp,-4
80005ee4:	6c 08       	ld.w	r8,r6[0x0]
80005ee6:	e0 69 ff ff 	mov	r9,65535
80005eea:	ea 19 00 7f 	orh	r9,0x7f
80005eee:	12 38       	cp.w	r8,r9
80005ef0:	e0 88 00 21 	brls	80005f32 <xg_flashc_init+0x21a>
										
								log("\r\n----message storage is full!!!----\r\n");
80005ef4:	4a dc       	lddpc	r12,80005fa8 <xg_flashc_init+0x290>
80005ef6:	f0 1f 00 17 	mcall	80005f50 <xg_flashc_init+0x238>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005efa:	30 4b       	mov	r11,4
80005efc:	30 0c       	mov	r12,0
80005efe:	f0 1f 00 2c 	mcall	80005fac <xg_flashc_init+0x294>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005f02:	58 5c       	cp.w	r12,5
80005f04:	fe 90 ff 70 	breq	80005de4 <xg_flashc_init+0xcc>
80005f08:	c1 b8       	rjmp	80005f3e <xg_flashc_init+0x226>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005f0a:	4a ac       	lddpc	r12,80005fb0 <xg_flashc_init+0x298>
80005f0c:	f0 1f 00 11 	mcall	80005f50 <xg_flashc_init+0x238>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f10:	30 3b       	mov	r11,3
80005f12:	0a 9c       	mov	r12,r5
80005f14:	f0 1f 00 26 	mcall	80005fac <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f18:	58 5c       	cp.w	r12,5
80005f1a:	c1 21       	brne	80005f3e <xg_flashc_init+0x226>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f1c:	30 3b       	mov	r11,3
80005f1e:	e0 78 00 00 	mov	r8,65536
80005f22:	ea 08 00 0c 	add	r12,r5,r8
80005f26:	f0 1f 00 22 	mcall	80005fac <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f2a:	58 5c       	cp.w	r12,5
80005f2c:	fe 90 ff 68 	breq	80005dfc <xg_flashc_init+0xe4>
80005f30:	c0 78       	rjmp	80005f3e <xg_flashc_init+0x226>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005f32:	4a 1c       	lddpc	r12,80005fb4 <xg_flashc_init+0x29c>
80005f34:	f0 1f 00 07 	mcall	80005f50 <xg_flashc_init+0x238>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005f38:	30 19       	mov	r9,1
80005f3a:	4a 08       	lddpc	r8,80005fb8 <xg_flashc_init+0x2a0>
80005f3c:	b0 89       	st.b	r8[0x0],r9
	
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005f3e:	2f dd       	sub	sp,-12
80005f40:	d8 32       	popm	r0-r7,pc
80005f42:	00 00       	add	r0,r0
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	74 2c       	ld.w	r12,r10[0x8]
80005f48:	00 00       	add	r0,r0
80005f4a:	0b 98       	ld.ub	r8,r5[0x1]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	ea ac       	*unknown*
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	7f 64       	ld.w	r4,pc[0x58]
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	74 84       	ld.w	r4,r10[0x20]
80005f58:	00 00       	add	r0,r0
80005f5a:	0b a0       	ld.ub	r0,r5[0x2]
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	73 2c       	ld.w	r12,r9[0x48]
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	ea d8 00 00 	satsub.w	r8,r5,0
80005f66:	0b 90       	ld.ub	r0,r5[0x1]
80005f68:	00 00       	add	r0,r0
80005f6a:	0b 9c       	ld.ub	r12,r5[0x1]
80005f6c:	00 00       	add	r0,r0
80005f6e:	97 b8       	st.w	r11[0x2c],r8
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	35 44       	mov	r4,84
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	32 0c       	mov	r12,32
80005f78:	00 00       	add	r0,r0
80005f7a:	0b a8       	ld.ub	r8,r5[0x2]
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	2e b0       	sub	r0,-21
80005f80:	00 00       	add	r0,r0
80005f82:	05 40       	ld.w	r0,--r2
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	87 e8       	st.w	r3[0x38],r8
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	30 e8       	mov	r8,14
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	89 56       	st.w	r4[0x14],r6
80005f90:	00 00       	add	r0,r0
80005f92:	0b a4       	ld.ub	r4,r5[0x2]
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	eb 08 80 00 	ld.sh	r8,r5[-32768]
80005f9a:	eb 34 80 00 	ld.ub	r4,r5[-32768]
80005f9e:	eb 40 00 00 	st.w	r5[0],r0
80005fa2:	05 48       	ld.w	r8,--r2
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	eb 5c 80 00 	st.h	r5[-32768],r12
80005faa:	eb 80       	*unknown*
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	30 48       	mov	r8,4
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	eb a8 80 00 	stc.w	cp4,r8[0x0],cr0
80005fb6:	eb d0 00 00 	ldins.h	r0:b,r5[0]
80005fba:	0b 94       	ld.ub	r4,r5[0x1]

80005fbc <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005fbc:	d4 31       	pushm	r0-r7,lr
80005fbe:	20 2d       	sub	sp,8
80005fc0:	18 95       	mov	r5,r12
80005fc2:	16 96       	mov	r6,r11
80005fc4:	14 93       	mov	r3,r10
	xgflash_status_t status = XG_ERROR;
	
	if(!list_init_success_flag)return XG_ERROR;
80005fc6:	4c 78       	lddpc	r8,800060e0 <xgflash_get_message_data+0x124>
80005fc8:	11 89       	ld.ub	r9,r8[0x0]
80005fca:	30 08       	mov	r8,0
80005fcc:	f0 09 18 00 	cp.b	r9,r8
80005fd0:	c0 31       	brne	80005fd6 <xgflash_get_message_data+0x1a>
80005fd2:	3f f7       	mov	r7,-1
80005fd4:	c8 28       	rjmp	800060d8 <xgflash_get_message_data+0x11c>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005fd6:	4c 48       	lddpc	r8,800060e4 <xgflash_get_message_data+0x128>
80005fd8:	70 0c       	ld.w	r12,r8[0x0]
80005fda:	30 09       	mov	r9,0
80005fdc:	3f fa       	mov	r10,-1
80005fde:	12 9b       	mov	r11,r9
80005fe0:	f0 1f 00 42 	mcall	800060e8 <xgflash_get_message_data+0x12c>
	/* check input parameter */
	if (message_index > current_message_index)
80005fe4:	4c 28       	lddpc	r8,800060ec <xgflash_get_message_data+0x130>
80005fe6:	90 88       	ld.uh	r8,r8[0x0]
80005fe8:	0a 38       	cp.w	r8,r5
80005fea:	c0 a2       	brcc	80005ffe <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005fec:	4b e8       	lddpc	r8,800060e4 <xgflash_get_message_data+0x128>
80005fee:	70 0c       	ld.w	r12,r8[0x0]
80005ff0:	30 09       	mov	r9,0
80005ff2:	12 9a       	mov	r10,r9
80005ff4:	12 9b       	mov	r11,r9
80005ff6:	f0 1f 00 3f 	mcall	800060f0 <xgflash_get_message_data+0x134>
80005ffa:	30 17       	mov	r7,1
		return XG_INVALID_PARAM;
80005ffc:	c6 e8       	rjmp	800060d8 <xgflash_get_message_data+0x11c>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80005ffe:	fa ca ff f8 	sub	r10,sp,-8
80006002:	30 08       	mov	r8,0
80006004:	30 09       	mov	r9,0
80006006:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80006008:	1a 9a       	mov	r10,sp
8000600a:	30 8b       	mov	r11,8
8000600c:	ea 0c 15 03 	lsl	r12,r5,0x3
80006010:	f0 1f 00 39 	mcall	800060f4 <xgflash_get_message_data+0x138>
	if (return_code == DF_OK)
80006014:	c5 a1       	brne	800060c8 <xgflash_get_message_data+0x10c>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80006016:	9a 88       	ld.uh	r8,sp[0x0]
80006018:	0a 38       	cp.w	r8,r5
8000601a:	c3 31       	brne	80006080 <xgflash_get_message_data+0xc4>
		{
			bytes_remained = ptr->offset;
8000601c:	40 18       	lddsp	r8,sp[0x4]
8000601e:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80006022:	9a 95       	ld.uh	r5,sp[0x2]
80006024:	b1 88       	lsr	r8,0x10
80006026:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000602a:	30 04       	mov	r4,0
8000602c:	08 92       	mov	r2,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000602e:	e0 61 01 ff 	mov	r1,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006032:	e0 60 02 00 	mov	r0,512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80006036:	c1 98       	rjmp	80006068 <xgflash_get_message_data+0xac>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80006038:	e2 07 19 00 	cp.h	r7,r1
8000603c:	e0 8b 00 0a 	brhi	80006050 <xgflash_get_message_data+0x94>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80006040:	0c 9a       	mov	r10,r6
80006042:	0e 9b       	mov	r11,r7
80006044:	5c 7b       	castu.h	r11
80006046:	0a 9c       	mov	r12,r5
80006048:	f0 1f 00 2b 	mcall	800060f4 <xgflash_get_message_data+0x138>
8000604c:	30 07       	mov	r7,0
8000604e:	c0 d8       	rjmp	80006068 <xgflash_get_message_data+0xac>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006050:	0c 9a       	mov	r10,r6
80006052:	00 9b       	mov	r11,r0
80006054:	0a 9c       	mov	r12,r5
80006056:	f0 1f 00 28 	mcall	800060f4 <xgflash_get_message_data+0x138>
					bytes_remained-=DF_DATA_SPACE_SIZE;
8000605a:	ee c7 02 00 	sub	r7,r7,512
8000605e:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80006060:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80006064:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80006068:	e8 07 19 00 	cp.h	r7,r4
8000606c:	5f 19       	srne	r9
8000606e:	58 0c       	cp.w	r12,0
80006070:	5f 08       	sreq	r8
80006072:	f3 e8 00 08 	and	r8,r9,r8
80006076:	e4 08 18 00 	cp.b	r8,r2
8000607a:	cd f1       	brne	80006038 <xgflash_get_message_data+0x7c>
8000607c:	30 07       	mov	r7,0
8000607e:	c0 58       	rjmp	80006088 <xgflash_get_message_data+0xcc>
			}
			status = XG_OK;
		}
		else
		{
			log("Err flash data\n");
80006080:	49 ec       	lddpc	r12,800060f8 <xgflash_get_message_data+0x13c>
80006082:	f0 1f 00 1f 	mcall	800060fc <xgflash_get_message_data+0x140>
80006086:	30 87       	mov	r7,8
			
			//xSemaphoreGive(xgflash_mutex);//unlock
			status = 8;
			//return 7;
		}
		if(erase)//erase the message
80006088:	58 03       	cp.w	r3,0
8000608a:	c1 70       	breq	800060b8 <xgflash_get_message_data+0xfc>
		{
			memset(str, 0x00, sizeof(str));
8000608c:	30 08       	mov	r8,0
8000608e:	30 09       	mov	r9,0
80006090:	fa e9 00 00 	st.d	sp[0],r8
			//reset:current_message_index and erase info
			current_message_index-=1;
80006094:	49 6c       	lddpc	r12,800060ec <xgflash_get_message_data+0x130>
80006096:	98 08       	ld.sh	r8,r12[0x0]
80006098:	20 18       	sub	r8,1
8000609a:	b8 08       	st.h	r12[0x0],r8
			return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000609c:	30 2a       	mov	r10,2
8000609e:	30 6b       	mov	r11,6
800060a0:	f0 1f 00 18 	mcall	80006100 <xgflash_get_message_data+0x144>
			if (return_code != DF_WRITE_COMPLETED)
800060a4:	58 7c       	cp.w	r12,7
800060a6:	c0 50       	breq	800060b0 <xgflash_get_message_data+0xf4>
			{
				log("data_flash_write 1...\n");
800060a8:	49 7c       	lddpc	r12,80006104 <xgflash_get_message_data+0x148>
800060aa:	f0 1f 00 15 	mcall	800060fc <xgflash_get_message_data+0x140>
800060ae:	30 77       	mov	r7,7
				//status = XG_FLASH_WRITE_FAIL;
			//}
					//
			////erase data and reset:current_save_message_offset
			//return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
			current_save_message_offset-=32;//出错在这...如果掉线，未执行，则会出现存储碎片
800060b0:	49 68       	lddpc	r8,80006108 <xgflash_get_message_data+0x14c>
800060b2:	70 09       	ld.w	r9,r8[0x0]
800060b4:	22 09       	sub	r9,32
800060b6:	91 09       	st.w	r8[0x0],r9
				//status = XG_FLASH_WRITE_FAIL;
			//}
					
		}
				
		xSemaphoreGive(xgflash_mutex);//unlock
800060b8:	48 b8       	lddpc	r8,800060e4 <xgflash_get_message_data+0x128>
800060ba:	70 0c       	ld.w	r12,r8[0x0]
800060bc:	30 09       	mov	r9,0
800060be:	12 9a       	mov	r10,r9
800060c0:	12 9b       	mov	r11,r9
800060c2:	f0 1f 00 0c 	mcall	800060f0 <xgflash_get_message_data+0x134>
		//status = XG_OK;
		return status;
800060c6:	c0 98       	rjmp	800060d8 <xgflash_get_message_data+0x11c>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
800060c8:	48 78       	lddpc	r8,800060e4 <xgflash_get_message_data+0x128>
800060ca:	70 0c       	ld.w	r12,r8[0x0]
800060cc:	30 09       	mov	r9,0
800060ce:	12 9a       	mov	r10,r9
800060d0:	12 9b       	mov	r11,r9
800060d2:	f0 1f 00 08 	mcall	800060f0 <xgflash_get_message_data+0x134>
800060d6:	30 67       	mov	r7,6
	return XG_FLASH_READ_FAIL;
		
}
800060d8:	0e 9c       	mov	r12,r7
800060da:	2f ed       	sub	sp,-8
800060dc:	d8 32       	popm	r0-r7,pc
800060de:	00 00       	add	r0,r0
800060e0:	00 00       	add	r0,r0
800060e2:	0b 94       	ld.ub	r4,r5[0x1]
800060e4:	00 00       	add	r0,r0
800060e6:	0b 98       	ld.ub	r8,r5[0x1]
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	71 20       	ld.w	r0,r8[0x48]
800060ec:	00 00       	add	r0,r0
800060ee:	0b a4       	ld.ub	r4,r5[0x2]
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	73 2c       	ld.w	r12,r9[0x48]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	2e b0       	sub	r0,-21
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	ec 0c       	*unknown*
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	7f 64       	ld.w	r4,pc[0x58]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	30 e8       	mov	r8,14
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	ec 1c 00 00 	eorl	r12,0x0
8000610a:	05 48       	ld.w	r8,--r2

8000610c <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
8000610c:	d4 21       	pushm	r4-r7,lr
8000610e:	20 2d       	sub	sp,8
80006110:	18 96       	mov	r6,r12
80006112:	16 97       	mov	r7,r11
80006114:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80006116:	4d 68       	lddpc	r8,8000626c <xgflash_message_save+0x160>
80006118:	11 89       	ld.ub	r9,r8[0x0]
8000611a:	30 08       	mov	r8,0
8000611c:	f0 09 18 00 	cp.b	r9,r8
80006120:	c0 31       	brne	80006126 <xgflash_message_save+0x1a>
80006122:	3f fc       	mov	r12,-1
80006124:	ca 28       	rjmp	80006268 <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
80006126:	4d 38       	lddpc	r8,80006270 <xgflash_message_save+0x164>
80006128:	70 0c       	ld.w	r12,r8[0x0]
8000612a:	30 09       	mov	r9,0
8000612c:	3f fa       	mov	r10,-1
8000612e:	12 9b       	mov	r11,r9
80006130:	f0 1f 00 51 	mcall	80006274 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80006134:	58 06       	cp.w	r6,0
80006136:	5f 09       	sreq	r9
80006138:	e0 68 02 00 	mov	r8,512
8000613c:	f0 07 19 00 	cp.h	r7,r8
80006140:	5f b8       	srhi	r8
80006142:	f3 e8 10 08 	or	r8,r9,r8
80006146:	c0 30       	breq	8000614c <xgflash_message_save+0x40>
80006148:	30 1c       	mov	r12,1
8000614a:	c8 f8       	rjmp	80006268 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
8000614c:	0e 94       	mov	r4,r7
8000614e:	5c 74       	castu.h	r4
80006150:	4c a9       	lddpc	r9,80006278 <xgflash_message_save+0x16c>
80006152:	72 08       	ld.w	r8,r9[0x0]
80006154:	e8 08 00 08 	add	r8,r4,r8
80006158:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
8000615a:	e0 48 f0 00 	cp.w	r8,61440
8000615e:	e0 88 00 07 	brls	8000616c <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
80006162:	30 09       	mov	r9,0
80006164:	4c 58       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
80006166:	91 09       	st.w	r8[0x0],r9
80006168:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
8000616a:	c7 f8       	rjmp	80006268 <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
8000616c:	4c 48       	lddpc	r8,8000627c <xgflash_message_save+0x170>
8000616e:	70 0b       	ld.w	r11,r8[0x0]
80006170:	e0 68 ff ff 	mov	r8,65535
80006174:	ea 18 00 7f 	orh	r8,0x7f
80006178:	10 3b       	cp.w	r11,r8
8000617a:	e0 88 00 10 	brls	8000619a <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
8000617e:	4c 1c       	lddpc	r12,80006280 <xgflash_message_save+0x174>
80006180:	f0 1f 00 41 	mcall	80006284 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
80006184:	30 0b       	mov	r11,0
80006186:	4b d8       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
80006188:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000618a:	4b a8       	lddpc	r8,80006270 <xgflash_message_save+0x164>
8000618c:	70 0c       	ld.w	r12,r8[0x0]
8000618e:	16 99       	mov	r9,r11
80006190:	16 9a       	mov	r10,r11
80006192:	f0 1f 00 3e 	mcall	80006288 <xgflash_message_save+0x17c>
80006196:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80006198:	c6 88       	rjmp	80006268 <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000619a:	0e 9a       	mov	r10,r7
8000619c:	5c 7a       	castu.h	r10
8000619e:	0c 9c       	mov	r12,r6
800061a0:	f0 1f 00 3b 	mcall	8000628c <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
800061a4:	58 7c       	cp.w	r12,7
800061a6:	c0 c0       	breq	800061be <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
800061a8:	30 0b       	mov	r11,0
800061aa:	4b 48       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
800061ac:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
800061ae:	4b 18       	lddpc	r8,80006270 <xgflash_message_save+0x164>
800061b0:	70 0c       	ld.w	r12,r8[0x0]
800061b2:	16 99       	mov	r9,r11
800061b4:	16 9a       	mov	r10,r11
800061b6:	f0 1f 00 35 	mcall	80006288 <xgflash_message_save+0x17c>
800061ba:	30 7c       	mov	r12,7
		return XG_FLASH_WRITE_FAIL;
800061bc:	c5 68       	rjmp	80006268 <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
800061be:	4b 08       	lddpc	r8,8000627c <xgflash_message_save+0x170>
800061c0:	70 09       	ld.w	r9,r8[0x0]
800061c2:	12 04       	add	r4,r9
800061c4:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
800061c6:	1a d4       	st.w	--sp,r4
800061c8:	4b 2c       	lddpc	r12,80006290 <xgflash_message_save+0x184>
800061ca:	f0 1f 00 2f 	mcall	80006284 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
800061ce:	2f fd       	sub	sp,-4
800061d0:	30 18       	mov	r8,1
800061d2:	f0 05 18 00 	cp.b	r5,r8
800061d6:	c4 11       	brne	80006258 <xgflash_message_save+0x14c>
	{
		current_message_index++;
800061d8:	4a f9       	lddpc	r9,80006294 <xgflash_message_save+0x188>
800061da:	92 08       	ld.sh	r8,r9[0x0]
800061dc:	2f f8       	sub	r8,-1
800061de:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
800061e0:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
800061e2:	4a 69       	lddpc	r9,80006278 <xgflash_message_save+0x16c>
800061e4:	72 09       	ld.w	r9,r9[0x0]
800061e6:	4a 6a       	lddpc	r10,8000627c <xgflash_message_save+0x170>
800061e8:	74 0a       	ld.w	r10,r10[0x0]
800061ea:	12 1a       	sub	r10,r9
800061ec:	40 0b       	lddsp	r11,sp[0x0]
800061ee:	e0 1b 00 00 	andl	r11,0x0
800061f2:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
800061f6:	50 0b       	stdsp	sp[0x0],r11
800061f8:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
800061fa:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
800061fc:	5c 78       	castu.h	r8
800061fe:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80006202:	e2 4b 00 00 	cp.w	r11,131072
80006206:	e0 88 00 10 	brls	80006226 <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
8000620a:	4a 4c       	lddpc	r12,80006298 <xgflash_message_save+0x18c>
8000620c:	f0 1f 00 1e 	mcall	80006284 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
80006210:	30 0b       	mov	r11,0
80006212:	49 a8       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
80006214:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006216:	49 78       	lddpc	r8,80006270 <xgflash_message_save+0x164>
80006218:	70 0c       	ld.w	r12,r8[0x0]
8000621a:	16 99       	mov	r9,r11
8000621c:	16 9a       	mov	r10,r11
8000621e:	f0 1f 00 1b 	mcall	80006288 <xgflash_message_save+0x17c>
80006222:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80006224:	c2 28       	rjmp	80006268 <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
80006226:	30 8a       	mov	r10,8
80006228:	1a 9c       	mov	r12,sp
8000622a:	f0 1f 00 19 	mcall	8000628c <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000622e:	30 2a       	mov	r10,2
80006230:	30 6b       	mov	r11,6
80006232:	49 9c       	lddpc	r12,80006294 <xgflash_message_save+0x188>
80006234:	f0 1f 00 16 	mcall	8000628c <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
80006238:	58 7c       	cp.w	r12,7
8000623a:	c0 c0       	breq	80006252 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
8000623c:	30 0b       	mov	r11,0
8000623e:	48 f8       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
80006240:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006242:	48 c8       	lddpc	r8,80006270 <xgflash_message_save+0x164>
80006244:	70 0c       	ld.w	r12,r8[0x0]
80006246:	16 99       	mov	r9,r11
80006248:	16 9a       	mov	r10,r11
8000624a:	f0 1f 00 10 	mcall	80006288 <xgflash_message_save+0x17c>
8000624e:	30 7c       	mov	r12,7
			return XG_FLASH_WRITE_FAIL;
80006250:	c0 c8       	rjmp	80006268 <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
80006252:	30 09       	mov	r9,0
80006254:	48 98       	lddpc	r8,80006278 <xgflash_message_save+0x16c>
80006256:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
80006258:	48 68       	lddpc	r8,80006270 <xgflash_message_save+0x164>
8000625a:	70 0c       	ld.w	r12,r8[0x0]
8000625c:	30 09       	mov	r9,0
8000625e:	12 9a       	mov	r10,r9
80006260:	12 9b       	mov	r11,r9
80006262:	f0 1f 00 0a 	mcall	80006288 <xgflash_message_save+0x17c>
80006266:	30 0c       	mov	r12,0
	return XG_OK;

}
80006268:	2f ed       	sub	sp,-8
8000626a:	d8 22       	popm	r4-r7,pc
8000626c:	00 00       	add	r0,r0
8000626e:	0b 94       	ld.ub	r4,r5[0x1]
80006270:	00 00       	add	r0,r0
80006272:	0b 98       	ld.ub	r8,r5[0x1]
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	71 20       	ld.w	r0,r8[0x48]
80006278:	00 00       	add	r0,r0
8000627a:	0b f8       	ld.ub	r8,r5[0x7]
8000627c:	00 00       	add	r0,r0
8000627e:	05 48       	ld.w	r8,--r2
80006280:	80 00       	ld.sh	r0,r0[0x0]
80006282:	ec 34 80 00 	sub	r4,884736
80006286:	7f 64       	ld.w	r4,pc[0x58]
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	73 2c       	ld.w	r12,r9[0x48]
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	30 e8       	mov	r8,14
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	eb 5c 00 00 	st.h	r5[0],r12
80006296:	0b a4       	ld.ub	r4,r5[0x2]
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	ec 64 eb cd 	mov	r4,846797

8000629c <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
8000629c:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
800062a0:	48 d8       	lddpc	r8,800062d4 <xgflash_get_message_count+0x38>
800062a2:	11 89       	ld.ub	r9,r8[0x0]
800062a4:	30 08       	mov	r8,0
800062a6:	f0 09 18 00 	cp.b	r9,r8
800062aa:	c0 31       	brne	800062b0 <xgflash_get_message_count+0x14>
800062ac:	3f f7       	mov	r7,-1
800062ae:	c1 08       	rjmp	800062ce <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
800062b0:	48 a6       	lddpc	r6,800062d8 <xgflash_get_message_count+0x3c>
800062b2:	6c 0c       	ld.w	r12,r6[0x0]
800062b4:	30 09       	mov	r9,0
800062b6:	3f fa       	mov	r10,-1
800062b8:	12 9b       	mov	r11,r9
800062ba:	f0 1f 00 09 	mcall	800062dc <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
800062be:	48 98       	lddpc	r8,800062e0 <xgflash_get_message_count+0x44>
800062c0:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
800062c2:	6c 0c       	ld.w	r12,r6[0x0]
800062c4:	30 09       	mov	r9,0
800062c6:	12 9a       	mov	r10,r9
800062c8:	12 9b       	mov	r11,r9
800062ca:	f0 1f 00 07 	mcall	800062e4 <xgflash_get_message_count+0x48>

	return return_value;
	
}
800062ce:	0e 9c       	mov	r12,r7
800062d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062d4:	00 00       	add	r0,r0
800062d6:	0b 94       	ld.ub	r4,r5[0x1]
800062d8:	00 00       	add	r0,r0
800062da:	0b 98       	ld.ub	r8,r5[0x1]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	71 20       	ld.w	r0,r8[0x48]
800062e0:	00 00       	add	r0,r0
800062e2:	0b a4       	ld.ub	r4,r5[0x2]
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	73 2c       	ld.w	r12,r9[0x48]

800062e8 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800062e8:	fe 68 14 00 	mov	r8,-125952
800062ec:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800062ee:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800062f2:	91 09       	st.w	r8[0x0],r9
}
800062f4:	5e fc       	retal	r12

800062f6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800062f6:	f8 08 16 05 	lsr	r8,r12,0x5
800062fa:	a9 68       	lsl	r8,0x8
800062fc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006300:	58 1b       	cp.w	r11,1
80006302:	c0 d0       	breq	8000631c <gpio_enable_module_pin+0x26>
80006304:	c0 63       	brcs	80006310 <gpio_enable_module_pin+0x1a>
80006306:	58 2b       	cp.w	r11,2
80006308:	c1 00       	breq	80006328 <gpio_enable_module_pin+0x32>
8000630a:	58 3b       	cp.w	r11,3
8000630c:	c1 40       	breq	80006334 <gpio_enable_module_pin+0x3e>
8000630e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006310:	30 19       	mov	r9,1
80006312:	f2 0c 09 49 	lsl	r9,r9,r12
80006316:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006318:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000631a:	c1 28       	rjmp	8000633e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000631c:	30 19       	mov	r9,1
8000631e:	f2 0c 09 49 	lsl	r9,r9,r12
80006322:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006324:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006326:	c0 c8       	rjmp	8000633e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006328:	30 19       	mov	r9,1
8000632a:	f2 0c 09 49 	lsl	r9,r9,r12
8000632e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006330:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006332:	c0 68       	rjmp	8000633e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006334:	30 19       	mov	r9,1
80006336:	f2 0c 09 49 	lsl	r9,r9,r12
8000633a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000633c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000633e:	30 19       	mov	r9,1
80006340:	f2 0c 09 4c 	lsl	r12,r9,r12
80006344:	91 2c       	st.w	r8[0x8],r12
80006346:	5e fd       	retal	0

80006348 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006348:	d4 21       	pushm	r4-r7,lr
8000634a:	18 97       	mov	r7,r12
8000634c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000634e:	58 0b       	cp.w	r11,0
80006350:	c0 31       	brne	80006356 <gpio_enable_module+0xe>
80006352:	30 05       	mov	r5,0
80006354:	c0 d8       	rjmp	8000636e <gpio_enable_module+0x26>
80006356:	30 06       	mov	r6,0
80006358:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000635a:	6e 1b       	ld.w	r11,r7[0x4]
8000635c:	6e 0c       	ld.w	r12,r7[0x0]
8000635e:	f0 1f 00 06 	mcall	80006374 <gpio_enable_module+0x2c>
80006362:	18 45       	or	r5,r12
		gpiomap++;
80006364:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006366:	2f f6       	sub	r6,-1
80006368:	0c 34       	cp.w	r4,r6
8000636a:	fe 9b ff f8 	brhi	8000635a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000636e:	0a 9c       	mov	r12,r5
80006370:	d8 22       	popm	r4-r7,pc
80006372:	00 00       	add	r0,r0
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	62 f6       	ld.w	r6,r1[0x3c]

80006378 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006378:	f8 08 16 05 	lsr	r8,r12,0x5
8000637c:	a9 68       	lsl	r8,0x8
8000637e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006382:	30 19       	mov	r9,1
80006384:	f2 0c 09 4c 	lsl	r12,r9,r12
80006388:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000638c:	91 1c       	st.w	r8[0x4],r12
}
8000638e:	5e fc       	retal	r12

80006390 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006390:	f8 08 16 05 	lsr	r8,r12,0x5
80006394:	a9 68       	lsl	r8,0x8
80006396:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000639a:	30 19       	mov	r9,1
8000639c:	f2 0c 09 4c 	lsl	r12,r9,r12
800063a0:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800063a4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800063a8:	91 1c       	st.w	r8[0x4],r12
}
800063aa:	5e fc       	retal	r12

800063ac <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800063ac:	f8 08 16 05 	lsr	r8,r12,0x5
800063b0:	a9 68       	lsl	r8,0x8
800063b2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800063b6:	30 19       	mov	r9,1
800063b8:	f2 0c 09 4c 	lsl	r12,r9,r12
800063bc:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800063c0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800063c4:	91 1c       	st.w	r8[0x4],r12
}
800063c6:	5e fc       	retal	r12

800063c8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800063c8:	c0 08       	rjmp	800063c8 <_unhandled_interrupt>
800063ca:	d7 03       	nop

800063cc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800063cc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800063d0:	49 99       	lddpc	r9,80006434 <INTC_register_interrupt+0x68>
800063d2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800063d6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800063da:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800063dc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800063e0:	58 0a       	cp.w	r10,0
800063e2:	c0 91       	brne	800063f4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800063e4:	49 59       	lddpc	r9,80006438 <INTC_register_interrupt+0x6c>
800063e6:	49 6a       	lddpc	r10,8000643c <INTC_register_interrupt+0x70>
800063e8:	12 1a       	sub	r10,r9
800063ea:	fe 79 08 00 	mov	r9,-63488
800063ee:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800063f2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800063f4:	58 1a       	cp.w	r10,1
800063f6:	c0 a1       	brne	8000640a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800063f8:	49 09       	lddpc	r9,80006438 <INTC_register_interrupt+0x6c>
800063fa:	49 2a       	lddpc	r10,80006440 <INTC_register_interrupt+0x74>
800063fc:	12 1a       	sub	r10,r9
800063fe:	bf aa       	sbr	r10,0x1e
80006400:	fe 79 08 00 	mov	r9,-63488
80006404:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006408:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000640a:	58 2a       	cp.w	r10,2
8000640c:	c0 a1       	brne	80006420 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000640e:	48 b9       	lddpc	r9,80006438 <INTC_register_interrupt+0x6c>
80006410:	48 da       	lddpc	r10,80006444 <INTC_register_interrupt+0x78>
80006412:	12 1a       	sub	r10,r9
80006414:	bf ba       	sbr	r10,0x1f
80006416:	fe 79 08 00 	mov	r9,-63488
8000641a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000641e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006420:	48 69       	lddpc	r9,80006438 <INTC_register_interrupt+0x6c>
80006422:	48 aa       	lddpc	r10,80006448 <INTC_register_interrupt+0x7c>
80006424:	12 1a       	sub	r10,r9
80006426:	ea 1a c0 00 	orh	r10,0xc000
8000642a:	fe 79 08 00 	mov	r9,-63488
8000642e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006432:	5e fc       	retal	r12
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	ec f4 80 00 	ld.w	r4,r6[-32768]
8000643a:	de 00       	acall	0xe0
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	df 04       	*unknown*
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	df 12       	popm	r0-r3,r11-r12,lr-pc
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	df 20       	acall	0xf2
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	df 2e       	*unknown*

8000644c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000644c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000644e:	49 18       	lddpc	r8,80006490 <INTC_init_interrupts+0x44>
80006450:	e3 b8 00 01 	mtsr	0x4,r8
80006454:	49 0e       	lddpc	lr,80006494 <INTC_init_interrupts+0x48>
80006456:	30 07       	mov	r7,0
80006458:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000645a:	49 0c       	lddpc	r12,80006498 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000645c:	49 05       	lddpc	r5,8000649c <INTC_init_interrupts+0x50>
8000645e:	10 15       	sub	r5,r8
80006460:	fe 76 08 00 	mov	r6,-63488
80006464:	c1 08       	rjmp	80006484 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006466:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006468:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000646a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000646c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006470:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006472:	10 3a       	cp.w	r10,r8
80006474:	fe 9b ff fc 	brhi	8000646c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006478:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000647c:	2f f7       	sub	r7,-1
8000647e:	2f 8e       	sub	lr,-8
80006480:	59 37       	cp.w	r7,19
80006482:	c0 50       	breq	8000648c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006484:	7c 08       	ld.w	r8,lr[0x0]
80006486:	58 08       	cp.w	r8,0
80006488:	ce f1       	brne	80006466 <INTC_init_interrupts+0x1a>
8000648a:	cf 7b       	rjmp	80006478 <INTC_init_interrupts+0x2c>
8000648c:	d8 22       	popm	r4-r7,pc
8000648e:	00 00       	add	r0,r0
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	de 00       	acall	0xe0
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	ec f4 80 00 	ld.w	r4,r6[-32768]
8000649a:	63 c8       	ld.w	r8,r1[0x70]
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	df 04       	*unknown*

800064a0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800064a0:	fe 78 08 00 	mov	r8,-63488
800064a4:	e0 69 00 83 	mov	r9,131
800064a8:	f2 0c 01 0c 	sub	r12,r9,r12
800064ac:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800064b0:	f2 ca ff c0 	sub	r10,r9,-64
800064b4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064b8:	58 08       	cp.w	r8,0
800064ba:	c0 21       	brne	800064be <_get_interrupt_handler+0x1e>
800064bc:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800064be:	f0 08 12 00 	clz	r8,r8
800064c2:	48 5a       	lddpc	r10,800064d4 <_get_interrupt_handler+0x34>
800064c4:	f4 09 00 39 	add	r9,r10,r9<<0x3
800064c8:	f0 08 11 1f 	rsub	r8,r8,31
800064cc:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064ce:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800064d2:	5e fc       	retal	r12
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	ec f4 78 a8 	ld.w	r4,r6[30888]

800064d8 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800064d8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800064da:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800064de:	99 a8       	st.w	r12[0x28],r8
}
800064e0:	5e fc       	retal	r12
800064e2:	d7 03       	nop

800064e4 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800064e4:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800064e6:	ec 5b bb 9f 	cp.w	r11,899999
800064ea:	e0 8b 00 04 	brhi	800064f2 <pm_enable_osc0_crystal+0xe>
800064ee:	30 4b       	mov	r11,4
800064f0:	c1 38       	rjmp	80006516 <pm_enable_osc0_crystal+0x32>
800064f2:	e0 68 c6 bf 	mov	r8,50879
800064f6:	ea 18 00 2d 	orh	r8,0x2d
800064fa:	10 3b       	cp.w	r11,r8
800064fc:	e0 8b 00 04 	brhi	80006504 <pm_enable_osc0_crystal+0x20>
80006500:	30 5b       	mov	r11,5
80006502:	c0 a8       	rjmp	80006516 <pm_enable_osc0_crystal+0x32>
80006504:	e0 68 12 00 	mov	r8,4608
80006508:	ea 18 00 7a 	orh	r8,0x7a
8000650c:	10 3b       	cp.w	r11,r8
8000650e:	f9 bb 03 06 	movlo	r11,6
80006512:	f9 bb 02 07 	movhs	r11,7
80006516:	f0 1f 00 02 	mcall	8000651c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000651a:	d8 02       	popm	pc
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	64 d8       	ld.w	r8,r2[0x34]

80006520 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006520:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006522:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006526:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006528:	78 08       	ld.w	r8,r12[0x0]
8000652a:	a3 a8       	sbr	r8,0x2
8000652c:	99 08       	st.w	r12[0x0],r8
}
8000652e:	5e fc       	retal	r12

80006530 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006530:	79 58       	ld.w	r8,r12[0x54]
80006532:	e2 18 00 80 	andl	r8,0x80,COH
80006536:	cf d0       	breq	80006530 <pm_wait_for_clk0_ready>
}
80006538:	5e fc       	retal	r12
8000653a:	d7 03       	nop

8000653c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000653c:	eb cd 40 80 	pushm	r7,lr
80006540:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006542:	f0 1f 00 04 	mcall	80006550 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80006546:	0e 9c       	mov	r12,r7
80006548:	f0 1f 00 03 	mcall	80006554 <pm_enable_clk0+0x18>
}
8000654c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	65 20       	ld.w	r0,r2[0x48]
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	65 30       	ld.w	r0,r2[0x4c]

80006558 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006558:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000655a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000655e:	99 c8       	st.w	r12[0x30],r8
}
80006560:	5e fc       	retal	r12
80006562:	d7 03       	nop

80006564 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80006564:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80006566:	30 1b       	mov	r11,1
80006568:	f0 1f 00 02 	mcall	80006570 <pm_enable_osc32_crystal+0xc>
}
8000656c:	d8 02       	popm	pc
8000656e:	00 00       	add	r0,r0
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	65 58       	ld.w	r8,r2[0x54]

80006574 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006574:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80006576:	30 19       	mov	r9,1
80006578:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
8000657c:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006580:	99 c8       	st.w	r12[0x30],r8
}
80006582:	5e fc       	retal	r12

80006584 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80006584:	79 58       	ld.w	r8,r12[0x54]
80006586:	e2 18 02 00 	andl	r8,0x200,COH
8000658a:	cf d0       	breq	80006584 <pm_wait_for_clk32_ready>
}
8000658c:	5e fc       	retal	r12
8000658e:	d7 03       	nop

80006590 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006590:	eb cd 40 80 	pushm	r7,lr
80006594:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80006596:	f0 1f 00 04 	mcall	800065a4 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000659a:	0e 9c       	mov	r12,r7
8000659c:	f0 1f 00 03 	mcall	800065a8 <pm_enable_clk32+0x18>
}
800065a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	65 74       	ld.w	r4,r2[0x5c]
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	65 84       	ld.w	r4,r2[0x60]

800065ac <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800065ac:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800065b0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800065b4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800065b6:	09 f7       	ld.ub	r7,r4[0x7]
800065b8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800065bc:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800065c0:	09 b4       	ld.ub	r4,r4[0x3]
800065c2:	08 96       	mov	r6,r4
800065c4:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800065c8:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800065cc:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800065d0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800065d4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800065d8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800065dc:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800065e0:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800065e4:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800065e6:	79 58       	ld.w	r8,r12[0x54]
800065e8:	e2 18 00 20 	andl	r8,0x20,COH
800065ec:	cf d0       	breq	800065e6 <pm_cksel+0x3a>
}
800065ee:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800065f2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800065f2:	eb cd 40 80 	pushm	r7,lr
800065f6:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800065f8:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800065fa:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800065fe:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006602:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006606:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000660a:	2f 8b       	sub	r11,-8
8000660c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006610:	e3 cd 80 80 	ldm	sp++,r7,pc

80006614 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006614:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006616:	2f 8b       	sub	r11,-8
80006618:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000661c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006620:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006624:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006628:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000662c:	d8 02       	popm	pc

8000662e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000662e:	2f 8b       	sub	r11,-8
80006630:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006634:	a1 a8       	sbr	r8,0x0
80006636:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000663a:	5e fc       	retal	r12

8000663c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000663c:	79 58       	ld.w	r8,r12[0x54]
8000663e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006642:	cf d0       	breq	8000663c <pm_wait_for_pll0_locked>
}
80006644:	5e fc       	retal	r12

80006646 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80006646:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80006648:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000664c:	99 08       	st.w	r12[0x0],r8
}
8000664e:	5e fc       	retal	r12

80006650 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006650:	eb cd 40 c0 	pushm	r6-r7,lr
80006654:	18 97       	mov	r7,r12
80006656:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80006658:	f0 1f 00 06 	mcall	80006670 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000665c:	0c 9b       	mov	r11,r6
8000665e:	0e 9c       	mov	r12,r7
80006660:	f0 1f 00 05 	mcall	80006674 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006664:	30 1b       	mov	r11,1
80006666:	0e 9c       	mov	r12,r7
80006668:	f0 1f 00 04 	mcall	80006678 <pm_switch_to_osc0+0x28>
}
8000666c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	64 e4       	ld.w	r4,r2[0x38]
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	65 3c       	ld.w	r12,r2[0x4c]
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	66 46       	ld.w	r6,r3[0x10]

8000667c <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
8000667c:	78 0c       	ld.w	r12,r12[0x0]
}
8000667e:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80006682:	5e fc       	retal	r12

80006684 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80006684:	eb cd 40 c0 	pushm	r6-r7,lr
80006688:	18 97       	mov	r7,r12
8000668a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000668c:	0e 9c       	mov	r12,r7
8000668e:	f0 1f 00 06 	mcall	800066a4 <rtc_set_value+0x20>
80006692:	cf d1       	brne	8000668c <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80006694:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006696:	0e 9c       	mov	r12,r7
80006698:	f0 1f 00 03 	mcall	800066a4 <rtc_set_value+0x20>
8000669c:	cf d1       	brne	80006696 <rtc_set_value+0x12>
}
8000669e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066a2:	00 00       	add	r0,r0
800066a4:	80 00       	ld.sh	r0,r0[0x0]
800066a6:	66 7c       	ld.w	r12,r3[0x1c]

800066a8 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800066a8:	eb cd 40 80 	pushm	r7,lr
800066ac:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800066ae:	0e 9c       	mov	r12,r7
800066b0:	f0 1f 00 06 	mcall	800066c8 <rtc_enable+0x20>
800066b4:	cf d1       	brne	800066ae <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800066b6:	6e 08       	ld.w	r8,r7[0x0]
800066b8:	a1 a8       	sbr	r8,0x0
800066ba:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066bc:	0e 9c       	mov	r12,r7
800066be:	f0 1f 00 03 	mcall	800066c8 <rtc_enable+0x20>
800066c2:	cf d1       	brne	800066bc <rtc_enable+0x14>
}
800066c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800066c8:	80 00       	ld.sh	r0,r0[0x0]
800066ca:	66 7c       	ld.w	r12,r3[0x1c]

800066cc <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800066cc:	30 18       	mov	r8,1
800066ce:	99 48       	st.w	r12[0x10],r8
}
800066d0:	5e fc       	retal	r12
800066d2:	d7 03       	nop

800066d4 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800066d4:	eb cd 40 c0 	pushm	r6-r7,lr
800066d8:	18 97       	mov	r7,r12
800066da:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800066dc:	0e 9c       	mov	r12,r7
800066de:	f0 1f 00 06 	mcall	800066f4 <rtc_set_top_value+0x20>
800066e2:	cf d1       	brne	800066dc <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800066e4:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066e6:	0e 9c       	mov	r12,r7
800066e8:	f0 1f 00 03 	mcall	800066f4 <rtc_set_top_value+0x20>
800066ec:	cf d1       	brne	800066e6 <rtc_set_top_value+0x12>
}
800066ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066f2:	00 00       	add	r0,r0
800066f4:	80 00       	ld.sh	r0,r0[0x0]
800066f6:	66 7c       	ld.w	r12,r3[0x1c]

800066f8 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800066f8:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800066fc:	e6 18 00 01 	andh	r8,0x1,COH
80006700:	c0 71       	brne	8000670e <rtc_clear_interrupt+0x16>
80006702:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006704:	30 18       	mov	r8,1
80006706:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006708:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000670a:	d5 03       	csrf	0x10
8000670c:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000670e:	30 18       	mov	r8,1
80006710:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006712:	78 78       	ld.w	r8,r12[0x1c]
80006714:	5e fc       	retal	r12
80006716:	d7 03       	nop

80006718 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006718:	eb cd 40 e0 	pushm	r5-r7,lr
8000671c:	18 97       	mov	r7,r12
8000671e:	16 96       	mov	r6,r11
80006720:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80006722:	30 18       	mov	r8,1
80006724:	f0 0b 18 00 	cp.b	r11,r8
80006728:	5f b9       	srhi	r9
8000672a:	30 f8       	mov	r8,15
8000672c:	f0 0a 18 00 	cp.b	r10,r8
80006730:	5f b8       	srhi	r8
80006732:	f3 e8 10 08 	or	r8,r9,r8
80006736:	c0 30       	breq	8000673c <rtc_init+0x24>
80006738:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
8000673c:	30 18       	mov	r8,1
8000673e:	f0 0b 18 00 	cp.b	r11,r8
80006742:	c0 a1       	brne	80006756 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80006744:	fe 7c 0c 00 	mov	r12,-62464
80006748:	f0 1f 00 0f 	mcall	80006784 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
8000674c:	30 0b       	mov	r11,0
8000674e:	fe 7c 0c 00 	mov	r12,-62464
80006752:	f0 1f 00 0e 	mcall	80006788 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80006756:	0e 9c       	mov	r12,r7
80006758:	f0 1f 00 0d 	mcall	8000678c <rtc_init+0x74>
8000675c:	cf d1       	brne	80006756 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
8000675e:	a3 76       	lsl	r6,0x3
80006760:	b1 a6       	sbr	r6,0x10
80006762:	ed e5 10 85 	or	r5,r6,r5<<0x8
80006766:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80006768:	0e 9c       	mov	r12,r7
8000676a:	f0 1f 00 09 	mcall	8000678c <rtc_init+0x74>
8000676e:	cf d1       	brne	80006768 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006770:	30 0b       	mov	r11,0
80006772:	0e 9c       	mov	r12,r7
80006774:	f0 1f 00 07 	mcall	80006790 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80006778:	3f fb       	mov	r11,-1
8000677a:	0e 9c       	mov	r12,r7
8000677c:	f0 1f 00 06 	mcall	80006794 <rtc_init+0x7c>
80006780:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	65 64       	ld.w	r4,r2[0x58]
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	65 90       	ld.w	r0,r2[0x64]
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	66 7c       	ld.w	r12,r3[0x1c]
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	66 84       	ld.w	r4,r3[0x20]
80006794:	80 00       	ld.sh	r0,r0[0x0]
80006796:	66 d4       	ld.w	r4,r3[0x34]

80006798 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80006798:	f8 c8 00 01 	sub	r8,r12,1
8000679c:	f0 0b 00 0b 	add	r11,r8,r11
800067a0:	f6 0c 0d 0a 	divu	r10,r11,r12
800067a4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800067a6:	f4 c8 00 01 	sub	r8,r10,1
800067aa:	e0 48 00 fe 	cp.w	r8,254
800067ae:	e0 88 00 03 	brls	800067b4 <getBaudDiv+0x1c>
800067b2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800067b4:	5c 8c       	casts.h	r12
}
800067b6:	5e fc       	retal	r12

800067b8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800067b8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067bc:	30 18       	mov	r8,1
800067be:	f0 09 18 00 	cp.b	r9,r8
800067c2:	e0 88 00 04 	brls	800067ca <spi_initMaster+0x12>
800067c6:	30 2c       	mov	r12,2
800067c8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800067ca:	e0 68 00 80 	mov	r8,128
800067ce:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800067d0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800067d2:	30 19       	mov	r9,1
800067d4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800067d8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067dc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800067e0:	30 09       	mov	r9,0
800067e2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800067e6:	30 fa       	mov	r10,15
800067e8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800067ec:	99 18       	st.w	r12[0x4],r8
800067ee:	5e f9       	retal	r9

800067f0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800067f0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800067f2:	30 18       	mov	r8,1
800067f4:	f0 0b 18 00 	cp.b	r11,r8
800067f8:	5f be       	srhi	lr
800067fa:	f0 0a 18 00 	cp.b	r10,r8
800067fe:	5f b8       	srhi	r8
80006800:	fd e8 10 08 	or	r8,lr,r8
80006804:	c0 30       	breq	8000680a <spi_selectionMode+0x1a>
80006806:	30 2c       	mov	r12,2
80006808:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000680a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000680c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006810:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006814:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006818:	99 18       	st.w	r12[0x4],r8
8000681a:	d8 0a       	popm	pc,r12=0

8000681c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000681c:	30 18       	mov	r8,1
8000681e:	99 08       	st.w	r12[0x0],r8
}
80006820:	5e fc       	retal	r12

80006822 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006822:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006826:	c0 58       	rjmp	80006830 <spi_write+0xe>
		if (!timeout--) {
80006828:	58 08       	cp.w	r8,0
8000682a:	c0 21       	brne	8000682e <spi_write+0xc>
8000682c:	5e ff       	retal	1
8000682e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006830:	78 49       	ld.w	r9,r12[0x10]
80006832:	e2 19 00 02 	andl	r9,0x2,COH
80006836:	cf 90       	breq	80006828 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80006838:	5c 7b       	castu.h	r11
8000683a:	99 3b       	st.w	r12[0xc],r11
8000683c:	5e fd       	retal	0

8000683e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000683e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006842:	c0 58       	rjmp	8000684c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80006844:	58 08       	cp.w	r8,0
80006846:	c0 21       	brne	8000684a <spi_read+0xc>
80006848:	5e ff       	retal	1
8000684a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000684c:	78 49       	ld.w	r9,r12[0x10]
8000684e:	e2 19 02 01 	andl	r9,0x201,COH
80006852:	e0 49 02 01 	cp.w	r9,513
80006856:	cf 71       	brne	80006844 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80006858:	78 28       	ld.w	r8,r12[0x8]
8000685a:	b6 08       	st.h	r11[0x0],r8
8000685c:	5e fd       	retal	0
8000685e:	d7 03       	nop

80006860 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006860:	eb cd 40 f8 	pushm	r3-r7,lr
80006864:	18 95       	mov	r5,r12
80006866:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006868:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000686c:	30 38       	mov	r8,3
8000686e:	f0 06 18 00 	cp.b	r6,r8
80006872:	e0 8b 00 5e 	brhi	8000692e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80006876:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000687a:	30 18       	mov	r8,1
8000687c:	f0 04 18 00 	cp.b	r4,r8
80006880:	e0 8b 00 57 	brhi	8000692e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006884:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006888:	30 78       	mov	r8,7
8000688a:	f0 03 18 00 	cp.b	r3,r8
8000688e:	e0 88 00 50 	brls	8000692e <spi_setupChipReg+0xce>
80006892:	31 08       	mov	r8,16
80006894:	f0 03 18 00 	cp.b	r3,r8
80006898:	e0 8b 00 4b 	brhi	8000692e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000689c:	14 9b       	mov	r11,r10
8000689e:	6e 1c       	ld.w	r12,r7[0x4]
800068a0:	f0 1f 00 26 	mcall	80006938 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800068a4:	c4 55       	brlt	8000692e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800068a6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800068a8:	ec 09 16 01 	lsr	r9,r6,0x1
800068ac:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800068b0:	ec 16 00 01 	eorl	r6,0x1
800068b4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800068b8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800068bc:	20 83       	sub	r3,8
800068be:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800068c2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800068c6:	ef 39 00 09 	ld.ub	r9,r7[9]
800068ca:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800068ce:	ef 39 00 0a 	ld.ub	r9,r7[10]
800068d2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800068d6:	0f 89       	ld.ub	r9,r7[0x0]
800068d8:	30 1a       	mov	r10,1
800068da:	f4 09 18 00 	cp.b	r9,r10
800068de:	c0 d0       	breq	800068f8 <spi_setupChipReg+0x98>
800068e0:	c0 a3       	brcs	800068f4 <spi_setupChipReg+0x94>
800068e2:	30 2a       	mov	r10,2
800068e4:	f4 09 18 00 	cp.b	r9,r10
800068e8:	c0 a0       	breq	800068fc <spi_setupChipReg+0x9c>
800068ea:	30 3a       	mov	r10,3
800068ec:	f4 09 18 00 	cp.b	r9,r10
800068f0:	c1 f1       	brne	8000692e <spi_setupChipReg+0xce>
800068f2:	c0 78       	rjmp	80006900 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800068f4:	8b c8       	st.w	r5[0x30],r8
		break;
800068f6:	c0 68       	rjmp	80006902 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800068f8:	8b d8       	st.w	r5[0x34],r8
		break;
800068fa:	c0 48       	rjmp	80006902 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800068fc:	8b e8       	st.w	r5[0x38],r8
		break;
800068fe:	c0 28       	rjmp	80006902 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006900:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006902:	48 f8       	lddpc	r8,8000693c <spi_setupChipReg+0xdc>
80006904:	70 08       	ld.w	r8,r8[0x0]
80006906:	58 08       	cp.w	r8,0
80006908:	c1 61       	brne	80006934 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000690a:	30 0b       	mov	r11,0
8000690c:	30 1c       	mov	r12,1
8000690e:	f0 1f 00 0d 	mcall	80006940 <spi_setupChipReg+0xe0>
80006912:	48 b8       	lddpc	r8,8000693c <spi_setupChipReg+0xdc>
80006914:	91 0c       	st.w	r8[0x0],r12
80006916:	58 0c       	cp.w	r12,0
80006918:	c0 a0       	breq	8000692c <spi_setupChipReg+0xcc>
8000691a:	30 09       	mov	r9,0
8000691c:	12 9a       	mov	r10,r9
8000691e:	12 9b       	mov	r11,r9
80006920:	f0 1f 00 09 	mcall	80006944 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006924:	48 68       	lddpc	r8,8000693c <spi_setupChipReg+0xdc>
80006926:	70 08       	ld.w	r8,r8[0x0]
80006928:	58 08       	cp.w	r8,0
8000692a:	c0 51       	brne	80006934 <spi_setupChipReg+0xd4>
8000692c:	c0 08       	rjmp	8000692c <spi_setupChipReg+0xcc>
8000692e:	30 2c       	mov	r12,2
80006930:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006934:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	67 98       	ld.w	r8,r3[0x64]
8000693c:	00 00       	add	r0,r0
8000693e:	bd 3c       	mul	r12,lr
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	74 84       	ld.w	r4,r10[0x20]
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	73 2c       	ld.w	r12,r9[0x48]

80006948 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006948:	d4 01       	pushm	lr
8000694a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000694e:	c0 58       	rjmp	80006958 <spi_unselectChip+0x10>
		if (!timeout--) {
80006950:	58 08       	cp.w	r8,0
80006952:	c0 21       	brne	80006956 <spi_unselectChip+0xe>
80006954:	da 0a       	popm	pc,r12=1
80006956:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006958:	78 49       	ld.w	r9,r12[0x10]
8000695a:	e2 19 02 00 	andl	r9,0x200,COH
8000695e:	cf 90       	breq	80006950 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006960:	78 18       	ld.w	r8,r12[0x4]
80006962:	ea 18 00 0f 	orh	r8,0xf
80006966:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80006968:	fc 18 01 00 	movh	r8,0x100
8000696c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000696e:	30 09       	mov	r9,0
80006970:	12 9a       	mov	r10,r9
80006972:	12 9b       	mov	r11,r9
80006974:	48 38       	lddpc	r8,80006980 <spi_unselectChip+0x38>
80006976:	70 0c       	ld.w	r12,r8[0x0]
80006978:	f0 1f 00 03 	mcall	80006984 <spi_unselectChip+0x3c>
8000697c:	d8 0a       	popm	pc,r12=0
8000697e:	00 00       	add	r0,r0
80006980:	00 00       	add	r0,r0
80006982:	bd 3c       	mul	r12,lr
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	73 2c       	ld.w	r12,r9[0x48]

80006988 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006988:	eb cd 40 f8 	pushm	r3-r7,lr
8000698c:	18 94       	mov	r4,r12
8000698e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006990:	49 a6       	lddpc	r6,800069f8 <spi_selectChip+0x70>
80006992:	30 07       	mov	r7,0
80006994:	31 45       	mov	r5,20
80006996:	0e 99       	mov	r9,r7
80006998:	0a 9a       	mov	r10,r5
8000699a:	0e 9b       	mov	r11,r7
8000699c:	6c 0c       	ld.w	r12,r6[0x0]
8000699e:	f0 1f 00 18 	mcall	800069fc <spi_selectChip+0x74>
800069a2:	cf a0       	breq	80006996 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800069a4:	68 18       	ld.w	r8,r4[0x4]
800069a6:	ea 18 00 0f 	orh	r8,0xf
800069aa:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800069ac:	68 18       	ld.w	r8,r4[0x4]
800069ae:	e2 18 00 04 	andl	r8,0x4,COH
800069b2:	c1 10       	breq	800069d4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800069b4:	30 e8       	mov	r8,14
800069b6:	f0 03 18 00 	cp.b	r3,r8
800069ba:	e0 8b 00 1c 	brhi	800069f2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800069be:	68 19       	ld.w	r9,r4[0x4]
800069c0:	e6 08 15 10 	lsl	r8,r3,0x10
800069c4:	ea 18 ff f0 	orh	r8,0xfff0
800069c8:	e8 18 ff ff 	orl	r8,0xffff
800069cc:	12 68       	and	r8,r9
800069ce:	89 18       	st.w	r4[0x4],r8
800069d0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800069d4:	30 38       	mov	r8,3
800069d6:	f0 03 18 00 	cp.b	r3,r8
800069da:	e0 8b 00 0c 	brhi	800069f2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800069de:	68 19       	ld.w	r9,r4[0x4]
800069e0:	2f 03       	sub	r3,-16
800069e2:	30 18       	mov	r8,1
800069e4:	f0 03 09 48 	lsl	r8,r8,r3
800069e8:	5c d8       	com	r8
800069ea:	12 68       	and	r8,r9
800069ec:	89 18       	st.w	r4[0x4],r8
800069ee:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800069f2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800069f4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800069f8:	00 00       	add	r0,r0
800069fa:	bd 3c       	mul	r12,lr
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	71 20       	ld.w	r0,r8[0x48]

80006a00 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006a00:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006a02:	f6 08 15 04 	lsl	r8,r11,0x4
80006a06:	14 38       	cp.w	r8,r10
80006a08:	f9 b8 08 10 	movls	r8,16
80006a0c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006a10:	f0 0b 02 4b 	mul	r11,r8,r11
80006a14:	f6 09 16 01 	lsr	r9,r11,0x1
80006a18:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006a1c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006a20:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006a24:	f2 cb 00 01 	sub	r11,r9,1
80006a28:	e0 4b ff fe 	cp.w	r11,65534
80006a2c:	e0 88 00 03 	brls	80006a32 <usart_set_async_baudrate+0x32>
80006a30:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006a32:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006a34:	e8 6e 00 00 	mov	lr,524288
80006a38:	59 08       	cp.w	r8,16
80006a3a:	fc 08 17 10 	movne	r8,lr
80006a3e:	f9 b8 00 00 	moveq	r8,0
80006a42:	e4 1b ff f7 	andh	r11,0xfff7
80006a46:	e0 1b fe cf 	andl	r11,0xfecf
80006a4a:	16 48       	or	r8,r11
80006a4c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006a4e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006a52:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006a56:	99 89       	st.w	r12[0x20],r9
80006a58:	d8 0a       	popm	pc,r12=0

80006a5a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006a5a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006a5c:	e2 18 00 02 	andl	r8,0x2,COH
80006a60:	c0 31       	brne	80006a66 <usart_write_char+0xc>
80006a62:	30 2c       	mov	r12,2
80006a64:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006a66:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006a6a:	99 7b       	st.w	r12[0x1c],r11
80006a6c:	5e fd       	retal	0
80006a6e:	d7 03       	nop

80006a70 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006a70:	eb cd 40 e0 	pushm	r5-r7,lr
80006a74:	18 96       	mov	r6,r12
80006a76:	16 95       	mov	r5,r11
80006a78:	e0 67 27 0f 	mov	r7,9999
80006a7c:	c0 68       	rjmp	80006a88 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006a7e:	58 07       	cp.w	r7,0
80006a80:	c0 31       	brne	80006a86 <usart_putchar+0x16>
80006a82:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006a86:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006a88:	0a 9b       	mov	r11,r5
80006a8a:	0c 9c       	mov	r12,r6
80006a8c:	f0 1f 00 03 	mcall	80006a98 <usart_putchar+0x28>
80006a90:	cf 71       	brne	80006a7e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006a92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006a96:	00 00       	add	r0,r0
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	6a 5a       	ld.w	r10,r5[0x14]

80006a9c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006a9c:	78 58       	ld.w	r8,r12[0x14]
80006a9e:	e2 18 00 e0 	andl	r8,0xe0,COH
80006aa2:	c0 30       	breq	80006aa8 <usart_read_char+0xc>
80006aa4:	30 4c       	mov	r12,4
80006aa6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006aa8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006aaa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006aae:	c0 31       	brne	80006ab4 <usart_read_char+0x18>
80006ab0:	30 3c       	mov	r12,3
80006ab2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006ab4:	78 68       	ld.w	r8,r12[0x18]
80006ab6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006aba:	97 08       	st.w	r11[0x0],r8
80006abc:	5e fd       	retal	0
80006abe:	d7 03       	nop

80006ac0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006ac0:	eb cd 40 c0 	pushm	r6-r7,lr
80006ac4:	20 1d       	sub	sp,4
80006ac6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006ac8:	1a 97       	mov	r7,sp
80006aca:	1a 9b       	mov	r11,sp
80006acc:	0c 9c       	mov	r12,r6
80006ace:	f0 1f 00 07 	mcall	80006ae8 <usart_getchar+0x28>
80006ad2:	58 3c       	cp.w	r12,3
80006ad4:	cf b0       	breq	80006aca <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006ad6:	58 4c       	cp.w	r12,4
80006ad8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006adc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006ae0:	2f fd       	sub	sp,-4
80006ae2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ae6:	00 00       	add	r0,r0
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	6a 9c       	ld.w	r12,r5[0x24]

80006aec <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006aec:	eb cd 40 c0 	pushm	r6-r7,lr
80006af0:	18 96       	mov	r6,r12
80006af2:	16 97       	mov	r7,r11
  while (*string != '\0')
80006af4:	17 8b       	ld.ub	r11,r11[0x0]
80006af6:	58 0b       	cp.w	r11,0
80006af8:	c0 80       	breq	80006b08 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006afa:	2f f7       	sub	r7,-1
80006afc:	0c 9c       	mov	r12,r6
80006afe:	f0 1f 00 04 	mcall	80006b0c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006b02:	0f 8b       	ld.ub	r11,r7[0x0]
80006b04:	58 0b       	cp.w	r11,0
80006b06:	cf a1       	brne	80006afa <usart_write_line+0xe>
80006b08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	6a 70       	ld.w	r0,r5[0x1c]

80006b10 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006b10:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006b14:	e6 18 00 01 	andh	r8,0x1,COH
80006b18:	c0 71       	brne	80006b26 <usart_reset+0x16>
80006b1a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006b1c:	3f f8       	mov	r8,-1
80006b1e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b20:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006b22:	d5 03       	csrf	0x10
80006b24:	c0 48       	rjmp	80006b2c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006b26:	3f f8       	mov	r8,-1
80006b28:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b2a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006b2c:	30 08       	mov	r8,0
80006b2e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006b30:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006b32:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006b34:	ea 68 61 0c 	mov	r8,680204
80006b38:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006b3a:	5e fc       	retal	r12

80006b3c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006b3c:	eb cd 40 e0 	pushm	r5-r7,lr
80006b40:	18 96       	mov	r6,r12
80006b42:	16 97       	mov	r7,r11
80006b44:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006b46:	f0 1f 00 2f 	mcall	80006c00 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006b4a:	58 07       	cp.w	r7,0
80006b4c:	c5 80       	breq	80006bfc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006b4e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b50:	30 49       	mov	r9,4
80006b52:	f2 08 18 00 	cp.b	r8,r9
80006b56:	e0 88 00 53 	brls	80006bfc <usart_init_rs232+0xc0>
80006b5a:	30 99       	mov	r9,9
80006b5c:	f2 08 18 00 	cp.b	r8,r9
80006b60:	e0 8b 00 4e 	brhi	80006bfc <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006b64:	0f d9       	ld.ub	r9,r7[0x5]
80006b66:	30 78       	mov	r8,7
80006b68:	f0 09 18 00 	cp.b	r9,r8
80006b6c:	e0 8b 00 48 	brhi	80006bfc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006b70:	8e 39       	ld.sh	r9,r7[0x6]
80006b72:	e0 68 01 01 	mov	r8,257
80006b76:	f0 09 19 00 	cp.h	r9,r8
80006b7a:	e0 8b 00 41 	brhi	80006bfc <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006b7e:	ef 39 00 08 	ld.ub	r9,r7[8]
80006b82:	30 38       	mov	r8,3
80006b84:	f0 09 18 00 	cp.b	r9,r8
80006b88:	e0 8b 00 3a 	brhi	80006bfc <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006b8c:	0a 9a       	mov	r10,r5
80006b8e:	6e 0b       	ld.w	r11,r7[0x0]
80006b90:	0c 9c       	mov	r12,r6
80006b92:	f0 1f 00 1d 	mcall	80006c04 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b96:	58 1c       	cp.w	r12,1
80006b98:	c3 20       	breq	80006bfc <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006b9a:	0f c8       	ld.ub	r8,r7[0x4]
80006b9c:	30 99       	mov	r9,9
80006b9e:	f2 08 18 00 	cp.b	r8,r9
80006ba2:	c0 51       	brne	80006bac <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006ba4:	6c 18       	ld.w	r8,r6[0x4]
80006ba6:	b1 b8       	sbr	r8,0x11
80006ba8:	8d 18       	st.w	r6[0x4],r8
80006baa:	c0 68       	rjmp	80006bb6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006bac:	6c 19       	ld.w	r9,r6[0x4]
80006bae:	20 58       	sub	r8,5
80006bb0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006bb4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006bb6:	6c 19       	ld.w	r9,r6[0x4]
80006bb8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006bbc:	0f d8       	ld.ub	r8,r7[0x5]
80006bbe:	a9 78       	lsl	r8,0x9
80006bc0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006bc4:	12 48       	or	r8,r9
80006bc6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006bc8:	8e 38       	ld.sh	r8,r7[0x6]
80006bca:	30 29       	mov	r9,2
80006bcc:	f2 08 19 00 	cp.h	r8,r9
80006bd0:	e0 88 00 09 	brls	80006be2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006bd4:	6c 18       	ld.w	r8,r6[0x4]
80006bd6:	ad b8       	sbr	r8,0xd
80006bd8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006bda:	8e b8       	ld.uh	r8,r7[0x6]
80006bdc:	20 28       	sub	r8,2
80006bde:	8d a8       	st.w	r6[0x28],r8
80006be0:	c0 68       	rjmp	80006bec <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006be2:	6c 19       	ld.w	r9,r6[0x4]
80006be4:	5c 78       	castu.h	r8
80006be6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006bea:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006bec:	6c 18       	ld.w	r8,r6[0x4]
80006bee:	e0 18 ff f0 	andl	r8,0xfff0
80006bf2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006bf4:	35 08       	mov	r8,80
80006bf6:	8d 08       	st.w	r6[0x0],r8
80006bf8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006bfc:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	6b 10       	ld.w	r0,r5[0x44]
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	6a 00       	ld.w	r0,r5[0x0]

80006c08 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006c08:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006c0c:	fe c0 8e 0c 	sub	r0,pc,-29172

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006c10:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006c14:	d5 53       	csrf	0x15
  cp      r0, r1
80006c16:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006c18:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006c1c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006c1e:	c0 62       	brcc	80006c2a <idata_load_loop_end>
  cp      r0, r1
80006c20:	48 92       	lddpc	r2,80006c44 <udata_clear_loop_end+0x4>

80006c22 <idata_load_loop>:
  brlo    idata_load_loop
80006c22:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006c24:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006c26:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006c28:	cf d3       	brcs	80006c22 <idata_load_loop>

80006c2a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006c2a:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006c2e:	e0 61 bd 50 	mov	r1,48464
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006c32:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006c34:	c0 62       	brcc	80006c40 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006c36:	30 02       	mov	r2,0
80006c38:	30 03       	mov	r3,0

80006c3a <udata_clear_loop>:
80006c3a:	a1 22       	st.d	r0++,r2
80006c3c:	02 30       	cp.w	r0,r1
80006c3e:	cf e3       	brcs	80006c3a <udata_clear_loop>

80006c40 <udata_clear_loop_end>:
80006c40:	fe cf e9 28 	sub	pc,pc,-5848
80006c44:	80 00       	ld.sh	r0,r0[0x0]
80006c46:	f6 28 f8 c8 	sub	r8,-591672

80006c48 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006c48:	f8 c8 ff f8 	sub	r8,r12,-8
80006c4c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006c4e:	3f f9       	mov	r9,-1
80006c50:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006c52:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006c54:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006c56:	30 08       	mov	r8,0
80006c58:	99 08       	st.w	r12[0x0],r8
}
80006c5a:	5e fc       	retal	r12

80006c5c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006c5c:	30 08       	mov	r8,0
80006c5e:	99 48       	st.w	r12[0x10],r8
}
80006c60:	5e fc       	retal	r12

80006c62 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006c62:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006c64:	70 19       	ld.w	r9,r8[0x4]
80006c66:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006c68:	78 19       	ld.w	r9,r12[0x4]
80006c6a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006c6c:	70 19       	ld.w	r9,r8[0x4]
80006c6e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006c70:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006c72:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006c74:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006c76:	78 08       	ld.w	r8,r12[0x0]
80006c78:	2f f8       	sub	r8,-1
80006c7a:	99 08       	st.w	r12[0x0],r8
}
80006c7c:	5e fc       	retal	r12

80006c7e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006c7e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006c80:	5b fa       	cp.w	r10,-1
80006c82:	c0 31       	brne	80006c88 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006c84:	78 48       	ld.w	r8,r12[0x10]
80006c86:	c0 c8       	rjmp	80006c9e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006c88:	f8 c8 ff f8 	sub	r8,r12,-8
80006c8c:	70 19       	ld.w	r9,r8[0x4]
80006c8e:	72 09       	ld.w	r9,r9[0x0]
80006c90:	12 3a       	cp.w	r10,r9
80006c92:	c0 63       	brcs	80006c9e <vListInsert+0x20>
80006c94:	70 18       	ld.w	r8,r8[0x4]
80006c96:	70 19       	ld.w	r9,r8[0x4]
80006c98:	72 09       	ld.w	r9,r9[0x0]
80006c9a:	12 3a       	cp.w	r10,r9
80006c9c:	cf c2       	brcc	80006c94 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006c9e:	70 19       	ld.w	r9,r8[0x4]
80006ca0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006ca2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006ca4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006ca6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006ca8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006caa:	78 08       	ld.w	r8,r12[0x0]
80006cac:	2f f8       	sub	r8,-1
80006cae:	99 08       	st.w	r12[0x0],r8
}
80006cb0:	5e fc       	retal	r12

80006cb2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006cb2:	78 18       	ld.w	r8,r12[0x4]
80006cb4:	78 29       	ld.w	r9,r12[0x8]
80006cb6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006cb8:	78 28       	ld.w	r8,r12[0x8]
80006cba:	78 19       	ld.w	r9,r12[0x4]
80006cbc:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006cbe:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006cc0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006cc2:	18 39       	cp.w	r9,r12
80006cc4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006cc8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006ccc:	30 09       	mov	r9,0
80006cce:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006cd0:	70 09       	ld.w	r9,r8[0x0]
80006cd2:	20 19       	sub	r9,1
80006cd4:	91 09       	st.w	r8[0x0],r9
}
80006cd6:	5e fc       	retal	r12

80006cd8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006cd8:	e0 68 08 08 	mov	r8,2056
80006cdc:	ea 18 08 08 	orh	r8,0x808
80006ce0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006ce2:	e0 68 09 09 	mov	r8,2313
80006ce6:	ea 18 09 09 	orh	r8,0x909
80006cea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006cec:	e0 68 0a 0a 	mov	r8,2570
80006cf0:	ea 18 0a 0a 	orh	r8,0xa0a
80006cf4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006cf6:	e0 68 0b 0b 	mov	r8,2827
80006cfa:	ea 18 0b 0b 	orh	r8,0xb0b
80006cfe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006d00:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006d02:	e0 68 be ef 	mov	r8,48879
80006d06:	ea 18 de ad 	orh	r8,0xdead
80006d0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006d0c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006d0e:	fc 18 00 40 	movh	r8,0x40
80006d12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006d14:	e0 68 00 ff 	mov	r8,255
80006d18:	ea 18 ff 00 	orh	r8,0xff00
80006d1c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006d1e:	e0 68 01 01 	mov	r8,257
80006d22:	ea 18 01 01 	orh	r8,0x101
80006d26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006d28:	e0 68 02 02 	mov	r8,514
80006d2c:	ea 18 02 02 	orh	r8,0x202
80006d30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006d32:	e0 68 03 03 	mov	r8,771
80006d36:	ea 18 03 03 	orh	r8,0x303
80006d3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006d3c:	e0 68 04 04 	mov	r8,1028
80006d40:	ea 18 04 04 	orh	r8,0x404
80006d44:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006d46:	e0 68 05 05 	mov	r8,1285
80006d4a:	ea 18 05 05 	orh	r8,0x505
80006d4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006d50:	e0 68 06 06 	mov	r8,1542
80006d54:	ea 18 06 06 	orh	r8,0x606
80006d58:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006d5a:	e0 68 07 07 	mov	r8,1799
80006d5e:	ea 18 07 07 	orh	r8,0x707
80006d62:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006d64:	30 08       	mov	r8,0
80006d66:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006d68:	5e fc       	retal	r12
80006d6a:	d7 03       	nop

80006d6c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006d6c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006d6e:	48 38       	lddpc	r8,80006d78 <vPortEnterCritical+0xc>
80006d70:	70 09       	ld.w	r9,r8[0x0]
80006d72:	2f f9       	sub	r9,-1
80006d74:	91 09       	st.w	r8[0x0],r9
}
80006d76:	5e fc       	retal	r12
80006d78:	00 00       	add	r0,r0
80006d7a:	05 4c       	ld.w	r12,--r2

80006d7c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006d7c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006d7e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006d80:	30 0a       	mov	r10,0
80006d82:	14 9b       	mov	r11,r10
80006d84:	49 2c       	lddpc	r12,80006dcc <xPortStartScheduler+0x50>
80006d86:	f0 1f 00 13 	mcall	80006dd0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006d8a:	e0 68 5d c0 	mov	r8,24000
80006d8e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006d92:	30 08       	mov	r8,0
80006d94:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006d98:	e0 68 0d 74 	mov	r8,3444
80006d9c:	ea 18 00 00 	orh	r8,0x0
80006da0:	70 00       	ld.w	r0,r8[0x0]
80006da2:	60 0d       	ld.w	sp,r0[0x0]
80006da4:	1b 00       	ld.w	r0,sp++
80006da6:	e0 68 05 4c 	mov	r8,1356
80006daa:	ea 18 00 00 	orh	r8,0x0
80006dae:	91 00       	st.w	r8[0x0],r0
80006db0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006db4:	2f ed       	sub	sp,-8
80006db6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006dba:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006dbe:	e3 b0 00 00 	mtsr	0x0,r0
80006dc2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006dc6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006dca:	d8 0a       	popm	pc,r12=0
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	6e 98       	ld.w	r8,r7[0x24]
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	63 cc       	ld.w	r12,r1[0x70]

80006dd4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006dd4:	20 6d       	sub	sp,24
80006dd6:	eb cd 00 ff 	pushm	r0-r7
80006dda:	fa c7 ff c0 	sub	r7,sp,-64
80006dde:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006de2:	ef 40 ff e0 	st.w	r7[-32],r0
80006de6:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006dea:	ef 40 ff e4 	st.w	r7[-28],r0
80006dee:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006df2:	e0 68 05 4c 	mov	r8,1356
80006df6:	ea 18 00 00 	orh	r8,0x0
80006dfa:	70 00       	ld.w	r0,r8[0x0]
80006dfc:	1a d0       	st.w	--sp,r0
80006dfe:	f0 1f 00 1a 	mcall	80006e64 <LABEL_RET_SCALL_263+0x14>
80006e02:	e0 68 0d 74 	mov	r8,3444
80006e06:	ea 18 00 00 	orh	r8,0x0
80006e0a:	70 00       	ld.w	r0,r8[0x0]
80006e0c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006e0e:	f0 1f 00 17 	mcall	80006e68 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006e12:	e0 68 0d 74 	mov	r8,3444
80006e16:	ea 18 00 00 	orh	r8,0x0
80006e1a:	70 00       	ld.w	r0,r8[0x0]
80006e1c:	60 0d       	ld.w	sp,r0[0x0]
80006e1e:	1b 00       	ld.w	r0,sp++
80006e20:	e0 68 05 4c 	mov	r8,1356
80006e24:	ea 18 00 00 	orh	r8,0x0
80006e28:	91 00       	st.w	r8[0x0],r0
80006e2a:	fa c7 ff d8 	sub	r7,sp,-40
80006e2e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006e32:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006e36:	e0 61 05 4c 	mov	r1,1356
80006e3a:	ea 11 00 00 	orh	r1,0x0
80006e3e:	62 02       	ld.w	r2,r1[0x0]
80006e40:	58 02       	cp.w	r2,0
80006e42:	c0 70       	breq	80006e50 <LABEL_RET_SCALL_263>
80006e44:	e4 c2 00 01 	sub	r2,r2,1
80006e48:	83 02       	st.w	r1[0x0],r2
80006e4a:	58 02       	cp.w	r2,0
80006e4c:	c0 21       	brne	80006e50 <LABEL_RET_SCALL_263>
80006e4e:	b1 c0       	cbr	r0,0x10

80006e50 <LABEL_RET_SCALL_263>:
80006e50:	ef 40 ff f8 	st.w	r7[-8],r0
80006e54:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006e58:	ef 40 ff fc 	st.w	r7[-4],r0
80006e5c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006e60:	2f ad       	sub	sp,-24
80006e62:	d6 13       	rets
80006e64:	80 00       	ld.sh	r0,r0[0x0]
80006e66:	6d 6c       	ld.w	r12,r6[0x58]
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	75 08       	ld.w	r8,r10[0x40]

80006e6c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006e6c:	e1 b8 00 43 	mfsr	r8,0x10c
80006e70:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006e74:	5e fc       	retal	r12
80006e76:	d7 03       	nop

80006e78 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006e78:	48 78       	lddpc	r8,80006e94 <vPortExitCritical+0x1c>
80006e7a:	70 08       	ld.w	r8,r8[0x0]
80006e7c:	58 08       	cp.w	r8,0
80006e7e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006e80:	48 58       	lddpc	r8,80006e94 <vPortExitCritical+0x1c>
80006e82:	70 09       	ld.w	r9,r8[0x0]
80006e84:	20 19       	sub	r9,1
80006e86:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006e88:	70 08       	ld.w	r8,r8[0x0]
80006e8a:	58 08       	cp.w	r8,0
80006e8c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006e8e:	d5 03       	csrf	0x10
80006e90:	5e fc       	retal	r12
80006e92:	00 00       	add	r0,r0
80006e94:	00 00       	add	r0,r0
80006e96:	05 4c       	ld.w	r12,--r2

80006e98 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006e98:	eb cd 00 ff 	pushm	r0-r7
80006e9c:	e0 68 05 4c 	mov	r8,1356
80006ea0:	ea 18 00 00 	orh	r8,0x0
80006ea4:	70 00       	ld.w	r0,r8[0x0]
80006ea6:	1a d0       	st.w	--sp,r0
80006ea8:	7a 90       	ld.w	r0,sp[0x24]
80006eaa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006eae:	58 10       	cp.w	r0,1
80006eb0:	e0 8b 00 08 	brhi	80006ec0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006eb4:	e0 68 0d 74 	mov	r8,3444
80006eb8:	ea 18 00 00 	orh	r8,0x0
80006ebc:	70 00       	ld.w	r0,r8[0x0]
80006ebe:	81 0d       	st.w	r0[0x0],sp

80006ec0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006ec0:	f0 1f 00 12 	mcall	80006f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006ec4:	f0 1f 00 12 	mcall	80006f0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006ec8:	f0 1f 00 12 	mcall	80006f10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006ecc:	f0 1f 00 12 	mcall	80006f14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006ed0:	7a 90       	ld.w	r0,sp[0x24]
80006ed2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006ed6:	58 10       	cp.w	r0,1
80006ed8:	e0 8b 00 0e 	brhi	80006ef4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006edc:	f0 1f 00 0c 	mcall	80006f0c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006ee0:	f0 1f 00 0e 	mcall	80006f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006ee4:	f0 1f 00 0c 	mcall	80006f14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006ee8:	e0 68 0d 74 	mov	r8,3444
80006eec:	ea 18 00 00 	orh	r8,0x0
80006ef0:	70 00       	ld.w	r0,r8[0x0]
80006ef2:	60 0d       	ld.w	sp,r0[0x0]

80006ef4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006ef4:	1b 00       	ld.w	r0,sp++
80006ef6:	e0 68 05 4c 	mov	r8,1356
80006efa:	ea 18 00 00 	orh	r8,0x0
80006efe:	91 00       	st.w	r8[0x0],r0
80006f00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f04:	d6 03       	rete
80006f06:	00 00       	add	r0,r0
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	6e 6c       	ld.w	r12,r7[0x18]
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	6d 6c       	ld.w	r12,r6[0x58]
80006f10:	80 00       	ld.sh	r0,r0[0x0]
80006f12:	77 0c       	ld.w	r12,r11[0x40]
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	6e 78       	ld.w	r8,r7[0x1c]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	75 08       	ld.w	r8,r10[0x40]

80006f1c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006f1c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006f1e:	f0 1f 00 02 	mcall	80006f24 <__malloc_lock+0x8>
}
80006f22:	d8 02       	popm	pc
80006f24:	80 00       	ld.sh	r0,r0[0x0]
80006f26:	74 f8       	ld.w	r8,r10[0x3c]

80006f28 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006f28:	d4 01       	pushm	lr
	xTaskResumeAll();
80006f2a:	f0 1f 00 02 	mcall	80006f30 <__malloc_unlock+0x8>
}
80006f2e:	d8 02       	popm	pc
80006f30:	80 00       	ld.sh	r0,r0[0x0]
80006f32:	78 b4       	ld.w	r4,r12[0x2c]

80006f34 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006f34:	d4 21       	pushm	r4-r7,lr
80006f36:	16 95       	mov	r5,r11
80006f38:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006f3a:	58 0c       	cp.w	r12,0
80006f3c:	c0 30       	breq	80006f42 <_read+0xe>
80006f3e:	3f f7       	mov	r7,-1
80006f40:	c1 48       	rjmp	80006f68 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006f42:	58 0a       	cp.w	r10,0
80006f44:	e0 89 00 04 	brgt	80006f4c <_read+0x18>
80006f48:	30 07       	mov	r7,0
80006f4a:	c0 f8       	rjmp	80006f68 <_read+0x34>
80006f4c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006f4e:	48 84       	lddpc	r4,80006f6c <_read+0x38>
80006f50:	68 0c       	ld.w	r12,r4[0x0]
80006f52:	f0 1f 00 08 	mcall	80006f70 <_read+0x3c>
    if (c < 0)
80006f56:	c0 95       	brlt	80006f68 <_read+0x34>
      break;

    *ptr++ = c;
80006f58:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006f5c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006f5e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006f62:	58 08       	cp.w	r8,0
80006f64:	fe 99 ff f6 	brgt	80006f50 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006f68:	0e 9c       	mov	r12,r7
80006f6a:	d8 22       	popm	r4-r7,pc
80006f6c:	00 00       	add	r0,r0
80006f6e:	bd 40       	asr	r0,0x1c
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	6a c0       	ld.w	r0,r5[0x30]

80006f74 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006f74:	d4 21       	pushm	r4-r7,lr
80006f76:	16 95       	mov	r5,r11
80006f78:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006f7a:	20 1c       	sub	r12,1
80006f7c:	58 2c       	cp.w	r12,2
80006f7e:	e0 8b 00 12 	brhi	80006fa2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f82:	58 0a       	cp.w	r10,0
80006f84:	c0 31       	brne	80006f8a <_write+0x16>
80006f86:	30 07       	mov	r7,0
80006f88:	c0 e8       	rjmp	80006fa4 <_write+0x30>
80006f8a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006f8c:	48 74       	lddpc	r4,80006fa8 <_write+0x34>
80006f8e:	68 0c       	ld.w	r12,r4[0x0]
80006f90:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006f94:	f0 1f 00 06 	mcall	80006fac <_write+0x38>
80006f98:	c0 55       	brlt	80006fa2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006f9a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f9c:	0e 36       	cp.w	r6,r7
80006f9e:	cf 81       	brne	80006f8e <_write+0x1a>
80006fa0:	c0 28       	rjmp	80006fa4 <_write+0x30>
80006fa2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006fa4:	0e 9c       	mov	r12,r7
80006fa6:	d8 22       	popm	r4-r7,pc
80006fa8:	00 00       	add	r0,r0
80006faa:	bd 40       	asr	r0,0x1c
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	6a 70       	ld.w	r0,r5[0x1c]

80006fb0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006fb0:	eb cd 40 80 	pushm	r7,lr
80006fb4:	18 97       	mov	r7,r12
	if( pv )
80006fb6:	58 0c       	cp.w	r12,0
80006fb8:	c0 80       	breq	80006fc8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006fba:	f0 1f 00 05 	mcall	80006fcc <vPortFree+0x1c>
		{
			free( pv );
80006fbe:	0e 9c       	mov	r12,r7
80006fc0:	f0 1f 00 04 	mcall	80006fd0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006fc4:	f0 1f 00 04 	mcall	80006fd4 <vPortFree+0x24>
80006fc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fcc:	80 00       	ld.sh	r0,r0[0x0]
80006fce:	74 f8       	ld.w	r8,r10[0x3c]
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	83 90       	st.w	r1[0x24],r0
80006fd4:	80 00       	ld.sh	r0,r0[0x0]
80006fd6:	78 b4       	ld.w	r4,r12[0x2c]

80006fd8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006fd8:	eb cd 40 80 	pushm	r7,lr
80006fdc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006fde:	f0 1f 00 06 	mcall	80006ff4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006fe2:	0e 9c       	mov	r12,r7
80006fe4:	f0 1f 00 05 	mcall	80006ff8 <pvPortMalloc+0x20>
80006fe8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006fea:	f0 1f 00 05 	mcall	80006ffc <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006fee:	0e 9c       	mov	r12,r7
80006ff0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ff4:	80 00       	ld.sh	r0,r0[0x0]
80006ff6:	74 f8       	ld.w	r8,r10[0x3c]
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	83 a0       	st.w	r1[0x28],r0
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	78 b4       	ld.w	r4,r12[0x2c]

80007000 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80007000:	d4 01       	pushm	lr
80007002:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80007004:	78 09       	ld.w	r9,r12[0x0]
80007006:	58 09       	cp.w	r9,0
80007008:	c1 10       	breq	8000702a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000700a:	78 3a       	ld.w	r10,r12[0xc]
8000700c:	79 09       	ld.w	r9,r12[0x40]
8000700e:	f4 09 00 09 	add	r9,r10,r9
80007012:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80007014:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80007016:	14 39       	cp.w	r9,r10
80007018:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000701c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80007020:	79 0a       	ld.w	r10,r12[0x40]
80007022:	78 3b       	ld.w	r11,r12[0xc]
80007024:	10 9c       	mov	r12,r8
80007026:	f0 1f 00 02 	mcall	8000702c <prvCopyDataFromQueue+0x2c>
8000702a:	d8 02       	popm	pc
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	88 0e       	ld.sh	lr,r4[0x0]

80007030 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80007030:	eb cd 40 c0 	pushm	r6-r7,lr
80007034:	18 97       	mov	r7,r12
80007036:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007038:	78 e8       	ld.w	r8,r12[0x38]
8000703a:	58 08       	cp.w	r8,0
8000703c:	c0 31       	brne	80007042 <xQueueReceiveFromISR+0x12>
8000703e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80007042:	f0 1f 00 0e 	mcall	80007078 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80007046:	6e e8       	ld.w	r8,r7[0x38]
80007048:	20 18       	sub	r8,1
8000704a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000704c:	6f 18       	ld.w	r8,r7[0x44]
8000704e:	5b f8       	cp.w	r8,-1
80007050:	c0 d1       	brne	8000706a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007052:	6e 48       	ld.w	r8,r7[0x10]
80007054:	58 08       	cp.w	r8,0
80007056:	c0 f0       	breq	80007074 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007058:	ee cc ff f0 	sub	r12,r7,-16
8000705c:	f0 1f 00 08 	mcall	8000707c <xQueueReceiveFromISR+0x4c>
80007060:	c0 a0       	breq	80007074 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80007062:	30 1c       	mov	r12,1
80007064:	8d 0c       	st.w	r6[0x0],r12
80007066:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000706a:	2f f8       	sub	r8,-1
8000706c:	ef 48 00 44 	st.w	r7[68],r8
80007070:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007074:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007078:	80 00       	ld.sh	r0,r0[0x0]
8000707a:	70 00       	ld.w	r0,r8[0x0]
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	76 90       	ld.w	r0,r11[0x24]

80007080 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80007080:	eb cd 40 c0 	pushm	r6-r7,lr
80007084:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80007086:	f0 1f 00 23 	mcall	80007110 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000708a:	6f 28       	ld.w	r8,r7[0x48]
8000708c:	58 08       	cp.w	r8,0
8000708e:	e0 8a 00 18 	brle	800070be <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007092:	6e 98       	ld.w	r8,r7[0x24]
80007094:	58 08       	cp.w	r8,0
80007096:	c1 40       	breq	800070be <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007098:	ee c6 ff dc 	sub	r6,r7,-36
8000709c:	c0 48       	rjmp	800070a4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000709e:	6e 98       	ld.w	r8,r7[0x24]
800070a0:	58 08       	cp.w	r8,0
800070a2:	c0 e0       	breq	800070be <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800070a4:	0c 9c       	mov	r12,r6
800070a6:	f0 1f 00 1c 	mcall	80007114 <prvUnlockQueue+0x94>
800070aa:	c0 30       	breq	800070b0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800070ac:	f0 1f 00 1b 	mcall	80007118 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800070b0:	6f 28       	ld.w	r8,r7[0x48]
800070b2:	20 18       	sub	r8,1
800070b4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800070b8:	58 08       	cp.w	r8,0
800070ba:	fe 99 ff f2 	brgt	8000709e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800070be:	3f f8       	mov	r8,-1
800070c0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800070c4:	f0 1f 00 16 	mcall	8000711c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800070c8:	f0 1f 00 12 	mcall	80007110 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070cc:	6f 18       	ld.w	r8,r7[0x44]
800070ce:	58 08       	cp.w	r8,0
800070d0:	e0 8a 00 18 	brle	80007100 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070d4:	6e 48       	ld.w	r8,r7[0x10]
800070d6:	58 08       	cp.w	r8,0
800070d8:	c1 40       	breq	80007100 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070da:	ee c6 ff f0 	sub	r6,r7,-16
800070de:	c0 48       	rjmp	800070e6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070e0:	6e 48       	ld.w	r8,r7[0x10]
800070e2:	58 08       	cp.w	r8,0
800070e4:	c0 e0       	breq	80007100 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070e6:	0c 9c       	mov	r12,r6
800070e8:	f0 1f 00 0b 	mcall	80007114 <prvUnlockQueue+0x94>
800070ec:	c0 30       	breq	800070f2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800070ee:	f0 1f 00 0b 	mcall	80007118 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800070f2:	6f 18       	ld.w	r8,r7[0x44]
800070f4:	20 18       	sub	r8,1
800070f6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070fa:	58 08       	cp.w	r8,0
800070fc:	fe 99 ff f2 	brgt	800070e0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80007100:	3f f8       	mov	r8,-1
80007102:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80007106:	f0 1f 00 06 	mcall	8000711c <prvUnlockQueue+0x9c>
}
8000710a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000710e:	00 00       	add	r0,r0
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	6d 6c       	ld.w	r12,r6[0x58]
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	76 90       	ld.w	r0,r11[0x24]
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	75 9c       	ld.w	r12,r10[0x64]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	6e 78       	ld.w	r8,r7[0x1c]

80007120 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80007120:	d4 31       	pushm	r0-r7,lr
80007122:	20 5d       	sub	sp,20
80007124:	18 97       	mov	r7,r12
80007126:	50 0b       	stdsp	sp[0x0],r11
80007128:	50 2a       	stdsp	sp[0x8],r10
8000712a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000712c:	f8 c2 ff dc 	sub	r2,r12,-36
80007130:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007132:	fa c4 ff f4 	sub	r4,sp,-12
80007136:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007138:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000713a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000713e:	f0 1f 00 3e 	mcall	80007234 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007142:	6e e8       	ld.w	r8,r7[0x38]
80007144:	58 08       	cp.w	r8,0
80007146:	c2 a0       	breq	8000719a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80007148:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000714a:	40 0b       	lddsp	r11,sp[0x0]
8000714c:	0e 9c       	mov	r12,r7
8000714e:	f0 1f 00 3b 	mcall	80007238 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80007152:	40 18       	lddsp	r8,sp[0x4]
80007154:	58 08       	cp.w	r8,0
80007156:	c1 51       	brne	80007180 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80007158:	6e e8       	ld.w	r8,r7[0x38]
8000715a:	20 18       	sub	r8,1
8000715c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000715e:	6e 08       	ld.w	r8,r7[0x0]
80007160:	58 08       	cp.w	r8,0
80007162:	c0 41       	brne	8000716a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80007164:	f0 1f 00 36 	mcall	8000723c <xQueueGenericReceive+0x11c>
80007168:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000716a:	6e 48       	ld.w	r8,r7[0x10]
8000716c:	58 08       	cp.w	r8,0
8000716e:	c1 20       	breq	80007192 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80007170:	ee cc ff f0 	sub	r12,r7,-16
80007174:	f0 1f 00 33 	mcall	80007240 <xQueueGenericReceive+0x120>
80007178:	58 1c       	cp.w	r12,1
8000717a:	c0 c1       	brne	80007192 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000717c:	d7 33       	scall
8000717e:	c0 a8       	rjmp	80007192 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80007180:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007182:	6e 98       	ld.w	r8,r7[0x24]
80007184:	58 08       	cp.w	r8,0
80007186:	c0 60       	breq	80007192 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007188:	04 9c       	mov	r12,r2
8000718a:	f0 1f 00 2e 	mcall	80007240 <xQueueGenericReceive+0x120>
8000718e:	c0 20       	breq	80007192 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80007190:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80007192:	f0 1f 00 2d 	mcall	80007244 <xQueueGenericReceive+0x124>
80007196:	30 1c       	mov	r12,1
				return pdPASS;
80007198:	c4 c8       	rjmp	80007230 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000719a:	40 28       	lddsp	r8,sp[0x8]
8000719c:	58 08       	cp.w	r8,0
8000719e:	c0 51       	brne	800071a8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800071a0:	f0 1f 00 29 	mcall	80007244 <xQueueGenericReceive+0x124>
800071a4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800071a6:	c4 58       	rjmp	80007230 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800071a8:	58 05       	cp.w	r5,0
800071aa:	c0 51       	brne	800071b4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800071ac:	08 9c       	mov	r12,r4
800071ae:	f0 1f 00 27 	mcall	80007248 <xQueueGenericReceive+0x128>
800071b2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800071b4:	f0 1f 00 24 	mcall	80007244 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800071b8:	f0 1f 00 25 	mcall	8000724c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800071bc:	f0 1f 00 1e 	mcall	80007234 <xQueueGenericReceive+0x114>
800071c0:	6f 18       	ld.w	r8,r7[0x44]
800071c2:	5b f8       	cp.w	r8,-1
800071c4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800071c8:	6f 28       	ld.w	r8,r7[0x48]
800071ca:	5b f8       	cp.w	r8,-1
800071cc:	ef f1 0a 12 	st.weq	r7[0x48],r1
800071d0:	f0 1f 00 1d 	mcall	80007244 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071d4:	06 9b       	mov	r11,r3
800071d6:	08 9c       	mov	r12,r4
800071d8:	f0 1f 00 1e 	mcall	80007250 <xQueueGenericReceive+0x130>
800071dc:	c2 41       	brne	80007224 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800071de:	f0 1f 00 16 	mcall	80007234 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800071e2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800071e4:	f0 1f 00 18 	mcall	80007244 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800071e8:	58 06       	cp.w	r6,0
800071ea:	c1 71       	brne	80007218 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800071ec:	6e 08       	ld.w	r8,r7[0x0]
800071ee:	58 08       	cp.w	r8,0
800071f0:	c0 81       	brne	80007200 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800071f2:	f0 1f 00 11 	mcall	80007234 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800071f6:	6e 1c       	ld.w	r12,r7[0x4]
800071f8:	f0 1f 00 17 	mcall	80007254 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800071fc:	f0 1f 00 12 	mcall	80007244 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007200:	40 2b       	lddsp	r11,sp[0x8]
80007202:	04 9c       	mov	r12,r2
80007204:	f0 1f 00 15 	mcall	80007258 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80007208:	0e 9c       	mov	r12,r7
8000720a:	f0 1f 00 15 	mcall	8000725c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000720e:	f0 1f 00 15 	mcall	80007260 <xQueueGenericReceive+0x140>
80007212:	c9 61       	brne	8000713e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007214:	d7 33       	scall
80007216:	c9 4b       	rjmp	8000713e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007218:	0e 9c       	mov	r12,r7
8000721a:	f0 1f 00 11 	mcall	8000725c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000721e:	f0 1f 00 11 	mcall	80007260 <xQueueGenericReceive+0x140>
80007222:	c8 eb       	rjmp	8000713e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007224:	0e 9c       	mov	r12,r7
80007226:	f0 1f 00 0e 	mcall	8000725c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000722a:	f0 1f 00 0e 	mcall	80007260 <xQueueGenericReceive+0x140>
8000722e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80007230:	2f bd       	sub	sp,-20
80007232:	d8 32       	popm	r0-r7,pc
80007234:	80 00       	ld.sh	r0,r0[0x0]
80007236:	6d 6c       	ld.w	r12,r6[0x58]
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	70 00       	ld.w	r0,r8[0x0]
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	75 a8       	ld.w	r8,r10[0x68]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	76 90       	ld.w	r0,r11[0x24]
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	6e 78       	ld.w	r8,r7[0x1c]
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	75 84       	ld.w	r4,r10[0x60]
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	74 f8       	ld.w	r8,r10[0x3c]
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	78 20       	ld.w	r0,r12[0x8]
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	76 0c       	ld.w	r12,r11[0x0]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	7a c0       	ld.w	r0,sp[0x30]
8000725c:	80 00       	ld.sh	r0,r0[0x0]
8000725e:	70 80       	ld.w	r0,r8[0x20]
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	78 b4       	ld.w	r4,r12[0x2c]

80007264 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80007264:	eb cd 40 80 	pushm	r7,lr
80007268:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000726a:	79 08       	ld.w	r8,r12[0x40]
8000726c:	58 08       	cp.w	r8,0
8000726e:	c0 a1       	brne	80007282 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007270:	78 08       	ld.w	r8,r12[0x0]
80007272:	58 08       	cp.w	r8,0
80007274:	c2 b1       	brne	800072ca <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80007276:	78 1c       	ld.w	r12,r12[0x4]
80007278:	f0 1f 00 17 	mcall	800072d4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000727c:	30 08       	mov	r8,0
8000727e:	8f 18       	st.w	r7[0x4],r8
80007280:	c2 58       	rjmp	800072ca <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80007282:	58 0a       	cp.w	r10,0
80007284:	c1 01       	brne	800072a4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007286:	10 9a       	mov	r10,r8
80007288:	78 2c       	ld.w	r12,r12[0x8]
8000728a:	f0 1f 00 14 	mcall	800072d8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000728e:	6e 29       	ld.w	r9,r7[0x8]
80007290:	6f 08       	ld.w	r8,r7[0x40]
80007292:	f2 08 00 08 	add	r8,r9,r8
80007296:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80007298:	6e 19       	ld.w	r9,r7[0x4]
8000729a:	12 38       	cp.w	r8,r9
8000729c:	c1 73       	brcs	800072ca <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000729e:	6e 08       	ld.w	r8,r7[0x0]
800072a0:	8f 28       	st.w	r7[0x8],r8
800072a2:	c1 48       	rjmp	800072ca <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800072a4:	10 9a       	mov	r10,r8
800072a6:	78 3c       	ld.w	r12,r12[0xc]
800072a8:	f0 1f 00 0c 	mcall	800072d8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800072ac:	6f 08       	ld.w	r8,r7[0x40]
800072ae:	6e 39       	ld.w	r9,r7[0xc]
800072b0:	f2 08 01 08 	sub	r8,r9,r8
800072b4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800072b6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800072b8:	12 38       	cp.w	r8,r9
800072ba:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800072be:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800072c2:	f3 d8 e3 19 	subcs	r9,r9,r8
800072c6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800072ca:	6e e8       	ld.w	r8,r7[0x38]
800072cc:	2f f8       	sub	r8,-1
800072ce:	8f e8       	st.w	r7[0x38],r8
}
800072d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	75 b4       	ld.w	r4,r10[0x6c]
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	88 0e       	ld.sh	lr,r4[0x0]

800072dc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800072dc:	eb cd 40 c0 	pushm	r6-r7,lr
800072e0:	18 97       	mov	r7,r12
800072e2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800072e4:	78 ec       	ld.w	r12,r12[0x38]
800072e6:	6e f8       	ld.w	r8,r7[0x3c]
800072e8:	10 3c       	cp.w	r12,r8
800072ea:	c0 33       	brcs	800072f0 <xQueueGenericSendFromISR+0x14>
800072ec:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800072f0:	12 9a       	mov	r10,r9
800072f2:	0e 9c       	mov	r12,r7
800072f4:	f0 1f 00 0c 	mcall	80007324 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800072f8:	6f 28       	ld.w	r8,r7[0x48]
800072fa:	5b f8       	cp.w	r8,-1
800072fc:	c0 d1       	brne	80007316 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800072fe:	6e 98       	ld.w	r8,r7[0x24]
80007300:	58 08       	cp.w	r8,0
80007302:	c0 f0       	breq	80007320 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007304:	ee cc ff dc 	sub	r12,r7,-36
80007308:	f0 1f 00 08 	mcall	80007328 <xQueueGenericSendFromISR+0x4c>
8000730c:	c0 a0       	breq	80007320 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000730e:	30 1c       	mov	r12,1
80007310:	8d 0c       	st.w	r6[0x0],r12
80007312:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80007316:	2f f8       	sub	r8,-1
80007318:	ef 48 00 48 	st.w	r7[72],r8
8000731c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007320:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	72 64       	ld.w	r4,r9[0x18]
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	76 90       	ld.w	r0,r11[0x24]

8000732c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000732c:	d4 31       	pushm	r0-r7,lr
8000732e:	20 5d       	sub	sp,20
80007330:	18 97       	mov	r7,r12
80007332:	50 0b       	stdsp	sp[0x0],r11
80007334:	50 2a       	stdsp	sp[0x8],r10
80007336:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007338:	f8 c0 ff f0 	sub	r0,r12,-16
8000733c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000733e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007342:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007344:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80007348:	f0 1f 00 2f 	mcall	80007404 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000734c:	6e e9       	ld.w	r9,r7[0x38]
8000734e:	6e f8       	ld.w	r8,r7[0x3c]
80007350:	10 39       	cp.w	r9,r8
80007352:	c1 42       	brcc	8000737a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007354:	40 1a       	lddsp	r10,sp[0x4]
80007356:	40 0b       	lddsp	r11,sp[0x0]
80007358:	0e 9c       	mov	r12,r7
8000735a:	f0 1f 00 2c 	mcall	80007408 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000735e:	6e 98       	ld.w	r8,r7[0x24]
80007360:	58 08       	cp.w	r8,0
80007362:	c0 80       	breq	80007372 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80007364:	ee cc ff dc 	sub	r12,r7,-36
80007368:	f0 1f 00 29 	mcall	8000740c <xQueueGenericSend+0xe0>
8000736c:	58 1c       	cp.w	r12,1
8000736e:	c0 21       	brne	80007372 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80007370:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80007372:	f0 1f 00 28 	mcall	80007410 <xQueueGenericSend+0xe4>
80007376:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80007378:	c4 38       	rjmp	800073fe <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000737a:	40 28       	lddsp	r8,sp[0x8]
8000737c:	58 08       	cp.w	r8,0
8000737e:	c0 51       	brne	80007388 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007380:	f0 1f 00 24 	mcall	80007410 <xQueueGenericSend+0xe4>
80007384:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80007386:	c3 c8       	rjmp	800073fe <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80007388:	58 04       	cp.w	r4,0
8000738a:	c0 51       	brne	80007394 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000738c:	06 9c       	mov	r12,r3
8000738e:	f0 1f 00 22 	mcall	80007414 <xQueueGenericSend+0xe8>
80007392:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007394:	f0 1f 00 1f 	mcall	80007410 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007398:	f0 1f 00 20 	mcall	80007418 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000739c:	f0 1f 00 1a 	mcall	80007404 <xQueueGenericSend+0xd8>
800073a0:	6f 18       	ld.w	r8,r7[0x44]
800073a2:	5b f8       	cp.w	r8,-1
800073a4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800073a8:	6f 28       	ld.w	r8,r7[0x48]
800073aa:	5b f8       	cp.w	r8,-1
800073ac:	ef f1 0a 12 	st.weq	r7[0x48],r1
800073b0:	f0 1f 00 18 	mcall	80007410 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800073b4:	04 9b       	mov	r11,r2
800073b6:	06 9c       	mov	r12,r3
800073b8:	f0 1f 00 19 	mcall	8000741c <xQueueGenericSend+0xf0>
800073bc:	c1 b1       	brne	800073f2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800073be:	f0 1f 00 12 	mcall	80007404 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800073c2:	6e e5       	ld.w	r5,r7[0x38]
800073c4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800073c6:	f0 1f 00 13 	mcall	80007410 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800073ca:	0c 35       	cp.w	r5,r6
800073cc:	c0 d1       	brne	800073e6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800073ce:	40 2b       	lddsp	r11,sp[0x8]
800073d0:	00 9c       	mov	r12,r0
800073d2:	f0 1f 00 14 	mcall	80007420 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800073d6:	0e 9c       	mov	r12,r7
800073d8:	f0 1f 00 13 	mcall	80007424 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800073dc:	f0 1f 00 13 	mcall	80007428 <xQueueGenericSend+0xfc>
800073e0:	cb 41       	brne	80007348 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800073e2:	d7 33       	scall
800073e4:	cb 2b       	rjmp	80007348 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800073e6:	0e 9c       	mov	r12,r7
800073e8:	f0 1f 00 0f 	mcall	80007424 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800073ec:	f0 1f 00 0f 	mcall	80007428 <xQueueGenericSend+0xfc>
800073f0:	ca cb       	rjmp	80007348 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800073f2:	0e 9c       	mov	r12,r7
800073f4:	f0 1f 00 0c 	mcall	80007424 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800073f8:	f0 1f 00 0c 	mcall	80007428 <xQueueGenericSend+0xfc>
800073fc:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800073fe:	2f bd       	sub	sp,-20
80007400:	d8 32       	popm	r0-r7,pc
80007402:	00 00       	add	r0,r0
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	6d 6c       	ld.w	r12,r6[0x58]
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	72 64       	ld.w	r4,r9[0x18]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	76 90       	ld.w	r0,r11[0x24]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	6e 78       	ld.w	r8,r7[0x1c]
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	75 84       	ld.w	r4,r10[0x60]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	74 f8       	ld.w	r8,r10[0x3c]
8000741c:	80 00       	ld.sh	r0,r0[0x0]
8000741e:	78 20       	ld.w	r0,r12[0x8]
80007420:	80 00       	ld.sh	r0,r0[0x0]
80007422:	7a c0       	ld.w	r0,sp[0x30]
80007424:	80 00       	ld.sh	r0,r0[0x0]
80007426:	70 80       	ld.w	r0,r8[0x20]
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	78 b4       	ld.w	r4,r12[0x2c]

8000742c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000742c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007430:	34 cc       	mov	r12,76
80007432:	f0 1f 00 12 	mcall	80007478 <xQueueCreateMutex+0x4c>
80007436:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80007438:	c1 d0       	breq	80007472 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000743a:	30 06       	mov	r6,0
8000743c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000743e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80007440:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80007442:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80007444:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80007446:	30 18       	mov	r8,1
80007448:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000744a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000744e:	3f f8       	mov	r8,-1
80007450:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80007454:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80007458:	2f 0c       	sub	r12,-16
8000745a:	f0 1f 00 09 	mcall	8000747c <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000745e:	ee cc ff dc 	sub	r12,r7,-36
80007462:	f0 1f 00 07 	mcall	8000747c <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80007466:	0c 99       	mov	r9,r6
80007468:	0c 9a       	mov	r10,r6
8000746a:	0c 9b       	mov	r11,r6
8000746c:	0e 9c       	mov	r12,r7
8000746e:	f0 1f 00 05 	mcall	80007480 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80007472:	0e 9c       	mov	r12,r7
80007474:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007478:	80 00       	ld.sh	r0,r0[0x0]
8000747a:	6f d8       	ld.w	r8,r7[0x74]
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	6c 48       	ld.w	r8,r6[0x10]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	73 2c       	ld.w	r12,r9[0x48]

80007484 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80007484:	d4 21       	pushm	r4-r7,lr
80007486:	18 97       	mov	r7,r12
80007488:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000748a:	58 0c       	cp.w	r12,0
8000748c:	c2 f0       	breq	800074ea <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000748e:	34 cc       	mov	r12,76
80007490:	f0 1f 00 17 	mcall	800074ec <xQueueCreate+0x68>
80007494:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80007496:	c2 a0       	breq	800074ea <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80007498:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000749c:	e8 cc ff ff 	sub	r12,r4,-1
800074a0:	f0 1f 00 13 	mcall	800074ec <xQueueCreate+0x68>
800074a4:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800074a6:	c1 e0       	breq	800074e2 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800074a8:	f8 04 00 04 	add	r4,r12,r4
800074ac:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800074ae:	30 08       	mov	r8,0
800074b0:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800074b2:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800074b4:	ee c8 00 01 	sub	r8,r7,1
800074b8:	ad 38       	mul	r8,r6
800074ba:	10 0c       	add	r12,r8
800074bc:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800074be:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800074c0:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800074c4:	3f f8       	mov	r8,-1
800074c6:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800074ca:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800074ce:	ea cc ff f0 	sub	r12,r5,-16
800074d2:	f0 1f 00 08 	mcall	800074f0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800074d6:	ea cc ff dc 	sub	r12,r5,-36
800074da:	f0 1f 00 06 	mcall	800074f0 <xQueueCreate+0x6c>
800074de:	0a 9c       	mov	r12,r5
800074e0:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800074e2:	0a 9c       	mov	r12,r5
800074e4:	f0 1f 00 04 	mcall	800074f4 <xQueueCreate+0x70>
800074e8:	d8 2a       	popm	r4-r7,pc,r12=0
800074ea:	d8 2a       	popm	r4-r7,pc,r12=0
800074ec:	80 00       	ld.sh	r0,r0[0x0]
800074ee:	6f d8       	ld.w	r8,r7[0x74]
800074f0:	80 00       	ld.sh	r0,r0[0x0]
800074f2:	6c 48       	ld.w	r8,r6[0x10]
800074f4:	80 00       	ld.sh	r0,r0[0x0]
800074f6:	6f b0       	ld.w	r0,r7[0x6c]

800074f8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800074f8:	48 38       	lddpc	r8,80007504 <vTaskSuspendAll+0xc>
800074fa:	70 09       	ld.w	r9,r8[0x0]
800074fc:	2f f9       	sub	r9,-1
800074fe:	91 09       	st.w	r8[0x0],r9
}
80007500:	5e fc       	retal	r12
80007502:	00 00       	add	r0,r0
80007504:	00 00       	add	r0,r0
80007506:	0d a4       	ld.ub	r4,r6[0x2]

80007508 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80007508:	49 a8       	lddpc	r8,80007570 <vTaskSwitchContext+0x68>
8000750a:	70 08       	ld.w	r8,r8[0x0]
8000750c:	58 08       	cp.w	r8,0
8000750e:	c0 b1       	brne	80007524 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007510:	49 98       	lddpc	r8,80007574 <vTaskSwitchContext+0x6c>
80007512:	70 08       	ld.w	r8,r8[0x0]
80007514:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007518:	49 89       	lddpc	r9,80007578 <vTaskSwitchContext+0x70>
8000751a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000751e:	58 08       	cp.w	r8,0
80007520:	c0 60       	breq	8000752c <vTaskSwitchContext+0x24>
80007522:	c1 18       	rjmp	80007544 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80007524:	30 19       	mov	r9,1
80007526:	49 68       	lddpc	r8,8000757c <vTaskSwitchContext+0x74>
80007528:	91 09       	st.w	r8[0x0],r9
8000752a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000752c:	49 28       	lddpc	r8,80007574 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000752e:	49 3a       	lddpc	r10,80007578 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007530:	70 09       	ld.w	r9,r8[0x0]
80007532:	20 19       	sub	r9,1
80007534:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007536:	70 09       	ld.w	r9,r8[0x0]
80007538:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000753c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80007540:	58 09       	cp.w	r9,0
80007542:	cf 70       	breq	80007530 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80007544:	48 c8       	lddpc	r8,80007574 <vTaskSwitchContext+0x6c>
80007546:	70 08       	ld.w	r8,r8[0x0]
80007548:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000754c:	48 b9       	lddpc	r9,80007578 <vTaskSwitchContext+0x70>
8000754e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007552:	70 19       	ld.w	r9,r8[0x4]
80007554:	72 19       	ld.w	r9,r9[0x4]
80007556:	91 19       	st.w	r8[0x4],r9
80007558:	f0 ca ff f8 	sub	r10,r8,-8
8000755c:	14 39       	cp.w	r9,r10
8000755e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80007562:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80007566:	70 18       	ld.w	r8,r8[0x4]
80007568:	70 39       	ld.w	r9,r8[0xc]
8000756a:	48 68       	lddpc	r8,80007580 <vTaskSwitchContext+0x78>
8000756c:	91 09       	st.w	r8[0x0],r9
8000756e:	5e fc       	retal	r12
80007570:	00 00       	add	r0,r0
80007572:	0d a4       	ld.ub	r4,r6[0x2]
80007574:	00 00       	add	r0,r0
80007576:	0d dc       	ld.ub	r12,r6[0x5]
80007578:	00 00       	add	r0,r0
8000757a:	0c c0       	st.b	r6++,r0
8000757c:	00 00       	add	r0,r0
8000757e:	0d c4       	ld.ub	r4,r6[0x4]
80007580:	00 00       	add	r0,r0
80007582:	0d 74       	ld.ub	r4,--r6

80007584 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80007584:	48 48       	lddpc	r8,80007594 <vTaskSetTimeOutState+0x10>
80007586:	70 08       	ld.w	r8,r8[0x0]
80007588:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000758a:	48 48       	lddpc	r8,80007598 <vTaskSetTimeOutState+0x14>
8000758c:	70 08       	ld.w	r8,r8[0x0]
8000758e:	99 18       	st.w	r12[0x4],r8
}
80007590:	5e fc       	retal	r12
80007592:	00 00       	add	r0,r0
80007594:	00 00       	add	r0,r0
80007596:	0c b8       	st.h	r6++,r8
80007598:	00 00       	add	r0,r0
8000759a:	0d a0       	ld.ub	r0,r6[0x2]

8000759c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000759c:	30 19       	mov	r9,1
8000759e:	48 28       	lddpc	r8,800075a4 <vTaskMissedYield+0x8>
800075a0:	91 09       	st.w	r8[0x0],r9
}
800075a2:	5e fc       	retal	r12
800075a4:	00 00       	add	r0,r0
800075a6:	0d c4       	ld.ub	r4,r6[0x4]

800075a8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800075a8:	48 28       	lddpc	r8,800075b0 <xTaskGetCurrentTaskHandle+0x8>
800075aa:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800075ac:	5e fc       	retal	r12
800075ae:	00 00       	add	r0,r0
800075b0:	00 00       	add	r0,r0
800075b2:	0d 74       	ld.ub	r4,--r6

800075b4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800075b4:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800075b8:	58 0c       	cp.w	r12,0
800075ba:	c1 f0       	breq	800075f8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800075bc:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800075be:	78 b9       	ld.w	r9,r12[0x2c]
800075c0:	79 18       	ld.w	r8,r12[0x44]
800075c2:	10 39       	cp.w	r9,r8
800075c4:	c1 a0       	breq	800075f8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800075c6:	f8 c6 ff fc 	sub	r6,r12,-4
800075ca:	0c 9c       	mov	r12,r6
800075cc:	f0 1f 00 0c 	mcall	800075fc <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800075d0:	6f 1c       	ld.w	r12,r7[0x44]
800075d2:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800075d4:	f8 08 11 08 	rsub	r8,r12,8
800075d8:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800075da:	48 a8       	lddpc	r8,80007600 <vTaskPriorityDisinherit+0x4c>
800075dc:	70 08       	ld.w	r8,r8[0x0]
800075de:	10 3c       	cp.w	r12,r8
800075e0:	e0 88 00 04 	brls	800075e8 <vTaskPriorityDisinherit+0x34>
800075e4:	48 78       	lddpc	r8,80007600 <vTaskPriorityDisinherit+0x4c>
800075e6:	91 0c       	st.w	r8[0x0],r12
800075e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075ec:	0c 9b       	mov	r11,r6
800075ee:	48 68       	lddpc	r8,80007604 <vTaskPriorityDisinherit+0x50>
800075f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075f4:	f0 1f 00 05 	mcall	80007608 <vTaskPriorityDisinherit+0x54>
800075f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800075fc:	80 00       	ld.sh	r0,r0[0x0]
800075fe:	6c b2       	ld.w	r2,r6[0x2c]
80007600:	00 00       	add	r0,r0
80007602:	0d dc       	ld.ub	r12,r6[0x5]
80007604:	00 00       	add	r0,r0
80007606:	0c c0       	st.b	r6++,r0
80007608:	80 00       	ld.sh	r0,r0[0x0]
8000760a:	6c 62       	ld.w	r2,r6[0x18]

8000760c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000760c:	eb cd 40 c0 	pushm	r6-r7,lr
80007610:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80007612:	49 b8       	lddpc	r8,8000767c <vTaskPriorityInherit+0x70>
80007614:	70 08       	ld.w	r8,r8[0x0]
80007616:	78 b9       	ld.w	r9,r12[0x2c]
80007618:	70 b8       	ld.w	r8,r8[0x2c]
8000761a:	10 39       	cp.w	r9,r8
8000761c:	c2 d2       	brcc	80007676 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000761e:	49 88       	lddpc	r8,8000767c <vTaskPriorityInherit+0x70>
80007620:	70 08       	ld.w	r8,r8[0x0]
80007622:	70 b8       	ld.w	r8,r8[0x2c]
80007624:	f0 08 11 08 	rsub	r8,r8,8
80007628:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000762a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000762e:	49 59       	lddpc	r9,80007680 <vTaskPriorityInherit+0x74>
80007630:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007634:	78 59       	ld.w	r9,r12[0x14]
80007636:	10 39       	cp.w	r9,r8
80007638:	c1 b1       	brne	8000766e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000763a:	f8 c6 ff fc 	sub	r6,r12,-4
8000763e:	0c 9c       	mov	r12,r6
80007640:	f0 1f 00 11 	mcall	80007684 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007644:	48 e8       	lddpc	r8,8000767c <vTaskPriorityInherit+0x70>
80007646:	70 08       	ld.w	r8,r8[0x0]
80007648:	70 bc       	ld.w	r12,r8[0x2c]
8000764a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
8000764c:	48 f8       	lddpc	r8,80007688 <vTaskPriorityInherit+0x7c>
8000764e:	70 08       	ld.w	r8,r8[0x0]
80007650:	10 3c       	cp.w	r12,r8
80007652:	e0 88 00 04 	brls	8000765a <vTaskPriorityInherit+0x4e>
80007656:	48 d8       	lddpc	r8,80007688 <vTaskPriorityInherit+0x7c>
80007658:	91 0c       	st.w	r8[0x0],r12
8000765a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000765e:	0c 9b       	mov	r11,r6
80007660:	48 88       	lddpc	r8,80007680 <vTaskPriorityInherit+0x74>
80007662:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007666:	f0 1f 00 0a 	mcall	8000768c <vTaskPriorityInherit+0x80>
8000766a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000766e:	48 48       	lddpc	r8,8000767c <vTaskPriorityInherit+0x70>
80007670:	70 08       	ld.w	r8,r8[0x0]
80007672:	70 b8       	ld.w	r8,r8[0x2c]
80007674:	99 b8       	st.w	r12[0x2c],r8
80007676:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000767a:	00 00       	add	r0,r0
8000767c:	00 00       	add	r0,r0
8000767e:	0d 74       	ld.ub	r4,--r6
80007680:	00 00       	add	r0,r0
80007682:	0c c0       	st.b	r6++,r0
80007684:	80 00       	ld.sh	r0,r0[0x0]
80007686:	6c b2       	ld.w	r2,r6[0x2c]
80007688:	00 00       	add	r0,r0
8000768a:	0d dc       	ld.ub	r12,r6[0x5]
8000768c:	80 00       	ld.sh	r0,r0[0x0]
8000768e:	6c 62       	ld.w	r2,r6[0x18]

80007690 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80007690:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80007694:	78 38       	ld.w	r8,r12[0xc]
80007696:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007698:	ee c6 ff e8 	sub	r6,r7,-24
8000769c:	0c 9c       	mov	r12,r6
8000769e:	f0 1f 00 15 	mcall	800076f0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800076a2:	49 58       	lddpc	r8,800076f4 <xTaskRemoveFromEventList+0x64>
800076a4:	70 08       	ld.w	r8,r8[0x0]
800076a6:	58 08       	cp.w	r8,0
800076a8:	c1 71       	brne	800076d6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800076aa:	ee c6 ff fc 	sub	r6,r7,-4
800076ae:	0c 9c       	mov	r12,r6
800076b0:	f0 1f 00 10 	mcall	800076f0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800076b4:	6e bc       	ld.w	r12,r7[0x2c]
800076b6:	49 18       	lddpc	r8,800076f8 <xTaskRemoveFromEventList+0x68>
800076b8:	70 08       	ld.w	r8,r8[0x0]
800076ba:	10 3c       	cp.w	r12,r8
800076bc:	e0 88 00 04 	brls	800076c4 <xTaskRemoveFromEventList+0x34>
800076c0:	48 e8       	lddpc	r8,800076f8 <xTaskRemoveFromEventList+0x68>
800076c2:	91 0c       	st.w	r8[0x0],r12
800076c4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800076c8:	0c 9b       	mov	r11,r6
800076ca:	48 d8       	lddpc	r8,800076fc <xTaskRemoveFromEventList+0x6c>
800076cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800076d0:	f0 1f 00 0c 	mcall	80007700 <xTaskRemoveFromEventList+0x70>
800076d4:	c0 58       	rjmp	800076de <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800076d6:	0c 9b       	mov	r11,r6
800076d8:	48 bc       	lddpc	r12,80007704 <xTaskRemoveFromEventList+0x74>
800076da:	f0 1f 00 0a 	mcall	80007700 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800076de:	48 b8       	lddpc	r8,80007708 <xTaskRemoveFromEventList+0x78>
800076e0:	70 08       	ld.w	r8,r8[0x0]
800076e2:	6e b9       	ld.w	r9,r7[0x2c]
800076e4:	70 b8       	ld.w	r8,r8[0x2c]
800076e6:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800076e8:	5f 2c       	srhs	r12
800076ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076ee:	00 00       	add	r0,r0
800076f0:	80 00       	ld.sh	r0,r0[0x0]
800076f2:	6c b2       	ld.w	r2,r6[0x2c]
800076f4:	00 00       	add	r0,r0
800076f6:	0d a4       	ld.ub	r4,r6[0x2]
800076f8:	00 00       	add	r0,r0
800076fa:	0d dc       	ld.ub	r12,r6[0x5]
800076fc:	00 00       	add	r0,r0
800076fe:	0c c0       	st.b	r6++,r0
80007700:	80 00       	ld.sh	r0,r0[0x0]
80007702:	6c 62       	ld.w	r2,r6[0x18]
80007704:	00 00       	add	r0,r0
80007706:	0d 78       	ld.ub	r8,--r6
80007708:	00 00       	add	r0,r0
8000770a:	0d 74       	ld.ub	r4,--r6

8000770c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000770c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007710:	4b 98       	lddpc	r8,800077f4 <vTaskIncrementTick+0xe8>
80007712:	70 08       	ld.w	r8,r8[0x0]
80007714:	58 08       	cp.w	r8,0
80007716:	c6 91       	brne	800077e8 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80007718:	4b 88       	lddpc	r8,800077f8 <vTaskIncrementTick+0xec>
8000771a:	70 09       	ld.w	r9,r8[0x0]
8000771c:	2f f9       	sub	r9,-1
8000771e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80007720:	70 08       	ld.w	r8,r8[0x0]
80007722:	58 08       	cp.w	r8,0
80007724:	c1 a1       	brne	80007758 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80007726:	4b 68       	lddpc	r8,800077fc <vTaskIncrementTick+0xf0>
80007728:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000772a:	4b 69       	lddpc	r9,80007800 <vTaskIncrementTick+0xf4>
8000772c:	72 0b       	ld.w	r11,r9[0x0]
8000772e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007730:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80007732:	4b 59       	lddpc	r9,80007804 <vTaskIncrementTick+0xf8>
80007734:	72 0a       	ld.w	r10,r9[0x0]
80007736:	2f fa       	sub	r10,-1
80007738:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000773a:	70 08       	ld.w	r8,r8[0x0]
8000773c:	70 08       	ld.w	r8,r8[0x0]
8000773e:	58 08       	cp.w	r8,0
80007740:	c0 51       	brne	8000774a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80007742:	3f f9       	mov	r9,-1
80007744:	4b 18       	lddpc	r8,80007808 <vTaskIncrementTick+0xfc>
80007746:	91 09       	st.w	r8[0x0],r9
80007748:	c0 88       	rjmp	80007758 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000774a:	4a d8       	lddpc	r8,800077fc <vTaskIncrementTick+0xf0>
8000774c:	70 08       	ld.w	r8,r8[0x0]
8000774e:	70 38       	ld.w	r8,r8[0xc]
80007750:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80007752:	70 19       	ld.w	r9,r8[0x4]
80007754:	4a d8       	lddpc	r8,80007808 <vTaskIncrementTick+0xfc>
80007756:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80007758:	4a 88       	lddpc	r8,800077f8 <vTaskIncrementTick+0xec>
8000775a:	70 09       	ld.w	r9,r8[0x0]
8000775c:	4a b8       	lddpc	r8,80007808 <vTaskIncrementTick+0xfc>
8000775e:	70 08       	ld.w	r8,r8[0x0]
80007760:	10 39       	cp.w	r9,r8
80007762:	c4 73       	brcs	800077f0 <vTaskIncrementTick+0xe4>
80007764:	4a 68       	lddpc	r8,800077fc <vTaskIncrementTick+0xf0>
80007766:	70 08       	ld.w	r8,r8[0x0]
80007768:	70 08       	ld.w	r8,r8[0x0]
8000776a:	58 08       	cp.w	r8,0
8000776c:	c0 c0       	breq	80007784 <vTaskIncrementTick+0x78>
8000776e:	4a 48       	lddpc	r8,800077fc <vTaskIncrementTick+0xf0>
80007770:	70 08       	ld.w	r8,r8[0x0]
80007772:	70 38       	ld.w	r8,r8[0xc]
80007774:	70 37       	ld.w	r7,r8[0xc]
80007776:	6e 18       	ld.w	r8,r7[0x4]
80007778:	4a 09       	lddpc	r9,800077f8 <vTaskIncrementTick+0xec>
8000777a:	72 09       	ld.w	r9,r9[0x0]
8000777c:	12 38       	cp.w	r8,r9
8000777e:	e0 88 00 14 	brls	800077a6 <vTaskIncrementTick+0x9a>
80007782:	c0 e8       	rjmp	8000779e <vTaskIncrementTick+0x92>
80007784:	3f f9       	mov	r9,-1
80007786:	4a 18       	lddpc	r8,80007808 <vTaskIncrementTick+0xfc>
80007788:	91 09       	st.w	r8[0x0],r9
8000778a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000778e:	6a 08       	ld.w	r8,r5[0x0]
80007790:	70 38       	ld.w	r8,r8[0xc]
80007792:	70 37       	ld.w	r7,r8[0xc]
80007794:	6e 18       	ld.w	r8,r7[0x4]
80007796:	64 09       	ld.w	r9,r2[0x0]
80007798:	12 38       	cp.w	r8,r9
8000779a:	e0 88 00 0a 	brls	800077ae <vTaskIncrementTick+0xa2>
8000779e:	49 b9       	lddpc	r9,80007808 <vTaskIncrementTick+0xfc>
800077a0:	93 08       	st.w	r9[0x0],r8
800077a2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077a6:	49 a4       	lddpc	r4,8000780c <vTaskIncrementTick+0x100>
800077a8:	49 a3       	lddpc	r3,80007810 <vTaskIncrementTick+0x104>
800077aa:	49 55       	lddpc	r5,800077fc <vTaskIncrementTick+0xf0>
800077ac:	49 32       	lddpc	r2,800077f8 <vTaskIncrementTick+0xec>
800077ae:	ee c6 ff fc 	sub	r6,r7,-4
800077b2:	0c 9c       	mov	r12,r6
800077b4:	f0 1f 00 18 	mcall	80007814 <vTaskIncrementTick+0x108>
800077b8:	6e a8       	ld.w	r8,r7[0x28]
800077ba:	58 08       	cp.w	r8,0
800077bc:	c0 50       	breq	800077c6 <vTaskIncrementTick+0xba>
800077be:	ee cc ff e8 	sub	r12,r7,-24
800077c2:	f0 1f 00 15 	mcall	80007814 <vTaskIncrementTick+0x108>
800077c6:	6e bc       	ld.w	r12,r7[0x2c]
800077c8:	68 08       	ld.w	r8,r4[0x0]
800077ca:	10 3c       	cp.w	r12,r8
800077cc:	e9 fc ba 00 	st.whi	r4[0x0],r12
800077d0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800077d4:	0c 9b       	mov	r11,r6
800077d6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800077da:	f0 1f 00 10 	mcall	80007818 <vTaskIncrementTick+0x10c>
800077de:	6a 08       	ld.w	r8,r5[0x0]
800077e0:	70 08       	ld.w	r8,r8[0x0]
800077e2:	58 08       	cp.w	r8,0
800077e4:	cd 51       	brne	8000778e <vTaskIncrementTick+0x82>
800077e6:	cc fb       	rjmp	80007784 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800077e8:	48 d8       	lddpc	r8,8000781c <vTaskIncrementTick+0x110>
800077ea:	70 09       	ld.w	r9,r8[0x0]
800077ec:	2f f9       	sub	r9,-1
800077ee:	91 09       	st.w	r8[0x0],r9
800077f0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077f4:	00 00       	add	r0,r0
800077f6:	0d a4       	ld.ub	r4,r6[0x2]
800077f8:	00 00       	add	r0,r0
800077fa:	0d a0       	ld.ub	r0,r6[0x2]
800077fc:	00 00       	add	r0,r0
800077fe:	0c ac       	st.w	r6++,r12
80007800:	00 00       	add	r0,r0
80007802:	0c bc       	st.h	r6++,r12
80007804:	00 00       	add	r0,r0
80007806:	0c b8       	st.h	r6++,r8
80007808:	00 00       	add	r0,r0
8000780a:	05 50       	ld.sh	r0,--r2
8000780c:	00 00       	add	r0,r0
8000780e:	0d dc       	ld.ub	r12,r6[0x5]
80007810:	00 00       	add	r0,r0
80007812:	0c c0       	st.b	r6++,r0
80007814:	80 00       	ld.sh	r0,r0[0x0]
80007816:	6c b2       	ld.w	r2,r6[0x2c]
80007818:	80 00       	ld.sh	r0,r0[0x0]
8000781a:	6c 62       	ld.w	r2,r6[0x18]
8000781c:	00 00       	add	r0,r0
8000781e:	0c a4       	st.w	r6++,r4

80007820 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007820:	eb cd 40 c0 	pushm	r6-r7,lr
80007824:	18 97       	mov	r7,r12
80007826:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80007828:	f0 1f 00 15 	mcall	8000787c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000782c:	6c 08       	ld.w	r8,r6[0x0]
8000782e:	5b f8       	cp.w	r8,-1
80007830:	c0 31       	brne	80007836 <xTaskCheckForTimeOut+0x16>
80007832:	30 07       	mov	r7,0
80007834:	c1 f8       	rjmp	80007872 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80007836:	49 39       	lddpc	r9,80007880 <xTaskCheckForTimeOut+0x60>
80007838:	72 09       	ld.w	r9,r9[0x0]
8000783a:	6e 0a       	ld.w	r10,r7[0x0]
8000783c:	12 3a       	cp.w	r10,r9
8000783e:	c0 70       	breq	8000784c <xTaskCheckForTimeOut+0x2c>
80007840:	49 19       	lddpc	r9,80007884 <xTaskCheckForTimeOut+0x64>
80007842:	72 09       	ld.w	r9,r9[0x0]
80007844:	6e 1a       	ld.w	r10,r7[0x4]
80007846:	12 3a       	cp.w	r10,r9
80007848:	e0 88 00 14 	brls	80007870 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000784c:	48 e9       	lddpc	r9,80007884 <xTaskCheckForTimeOut+0x64>
8000784e:	72 0a       	ld.w	r10,r9[0x0]
80007850:	6e 19       	ld.w	r9,r7[0x4]
80007852:	12 1a       	sub	r10,r9
80007854:	14 38       	cp.w	r8,r10
80007856:	e0 88 00 0d 	brls	80007870 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000785a:	48 ba       	lddpc	r10,80007884 <xTaskCheckForTimeOut+0x64>
8000785c:	74 0a       	ld.w	r10,r10[0x0]
8000785e:	14 19       	sub	r9,r10
80007860:	f2 08 00 08 	add	r8,r9,r8
80007864:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80007866:	0e 9c       	mov	r12,r7
80007868:	f0 1f 00 08 	mcall	80007888 <xTaskCheckForTimeOut+0x68>
8000786c:	30 07       	mov	r7,0
8000786e:	c0 28       	rjmp	80007872 <xTaskCheckForTimeOut+0x52>
80007870:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80007872:	f0 1f 00 07 	mcall	8000788c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80007876:	0e 9c       	mov	r12,r7
80007878:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000787c:	80 00       	ld.sh	r0,r0[0x0]
8000787e:	6d 6c       	ld.w	r12,r6[0x58]
80007880:	00 00       	add	r0,r0
80007882:	0c b8       	st.h	r6++,r8
80007884:	00 00       	add	r0,r0
80007886:	0d a0       	ld.ub	r0,r6[0x2]
80007888:	80 00       	ld.sh	r0,r0[0x0]
8000788a:	75 84       	ld.w	r4,r10[0x60]
8000788c:	80 00       	ld.sh	r0,r0[0x0]
8000788e:	6e 78       	ld.w	r8,r7[0x1c]

80007890 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007890:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80007894:	f0 1f 00 05 	mcall	800078a8 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007898:	48 58       	lddpc	r8,800078ac <xTaskGetTickCount+0x1c>
8000789a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000789c:	f0 1f 00 05 	mcall	800078b0 <xTaskGetTickCount+0x20>

	return xTicks;
}
800078a0:	0e 9c       	mov	r12,r7
800078a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800078a6:	00 00       	add	r0,r0
800078a8:	80 00       	ld.sh	r0,r0[0x0]
800078aa:	6d 6c       	ld.w	r12,r6[0x58]
800078ac:	00 00       	add	r0,r0
800078ae:	0d a0       	ld.ub	r0,r6[0x2]
800078b0:	80 00       	ld.sh	r0,r0[0x0]
800078b2:	6e 78       	ld.w	r8,r7[0x1c]

800078b4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800078b4:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800078b8:	f0 1f 00 2c 	mcall	80007968 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800078bc:	4a c8       	lddpc	r8,8000796c <xTaskResumeAll+0xb8>
800078be:	70 09       	ld.w	r9,r8[0x0]
800078c0:	20 19       	sub	r9,1
800078c2:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800078c4:	70 08       	ld.w	r8,r8[0x0]
800078c6:	58 08       	cp.w	r8,0
800078c8:	c4 91       	brne	8000795a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800078ca:	4a a8       	lddpc	r8,80007970 <xTaskResumeAll+0xbc>
800078cc:	70 08       	ld.w	r8,r8[0x0]
800078ce:	58 08       	cp.w	r8,0
800078d0:	c4 50       	breq	8000795a <xTaskResumeAll+0xa6>
800078d2:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800078d4:	4a 85       	lddpc	r5,80007974 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800078d6:	4a 93       	lddpc	r3,80007978 <xTaskResumeAll+0xc4>
800078d8:	4a 92       	lddpc	r2,8000797c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800078da:	4a a1       	lddpc	r1,80007980 <xTaskResumeAll+0xcc>
800078dc:	c1 e8       	rjmp	80007918 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800078de:	6a 38       	ld.w	r8,r5[0xc]
800078e0:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800078e2:	ee cc ff e8 	sub	r12,r7,-24
800078e6:	f0 1f 00 28 	mcall	80007984 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800078ea:	ee c6 ff fc 	sub	r6,r7,-4
800078ee:	0c 9c       	mov	r12,r6
800078f0:	f0 1f 00 25 	mcall	80007984 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800078f4:	6e bc       	ld.w	r12,r7[0x2c]
800078f6:	66 08       	ld.w	r8,r3[0x0]
800078f8:	10 3c       	cp.w	r12,r8
800078fa:	e7 fc ba 00 	st.whi	r3[0x0],r12
800078fe:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007902:	0c 9b       	mov	r11,r6
80007904:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80007908:	f0 1f 00 20 	mcall	80007988 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000790c:	62 08       	ld.w	r8,r1[0x0]
8000790e:	6e b9       	ld.w	r9,r7[0x2c]
80007910:	70 b8       	ld.w	r8,r8[0x2c]
80007912:	10 39       	cp.w	r9,r8
80007914:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007918:	6a 08       	ld.w	r8,r5[0x0]
8000791a:	58 08       	cp.w	r8,0
8000791c:	ce 11       	brne	800078de <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000791e:	49 c8       	lddpc	r8,8000798c <xTaskResumeAll+0xd8>
80007920:	70 08       	ld.w	r8,r8[0x0]
80007922:	58 08       	cp.w	r8,0
80007924:	c0 f0       	breq	80007942 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007926:	49 a8       	lddpc	r8,8000798c <xTaskResumeAll+0xd8>
80007928:	70 08       	ld.w	r8,r8[0x0]
8000792a:	58 08       	cp.w	r8,0
8000792c:	c1 10       	breq	8000794e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000792e:	49 87       	lddpc	r7,8000798c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007930:	f0 1f 00 18 	mcall	80007990 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007934:	6e 08       	ld.w	r8,r7[0x0]
80007936:	20 18       	sub	r8,1
80007938:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000793a:	6e 08       	ld.w	r8,r7[0x0]
8000793c:	58 08       	cp.w	r8,0
8000793e:	cf 91       	brne	80007930 <xTaskResumeAll+0x7c>
80007940:	c0 78       	rjmp	8000794e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80007942:	58 14       	cp.w	r4,1
80007944:	c0 50       	breq	8000794e <xTaskResumeAll+0x9a>
80007946:	49 48       	lddpc	r8,80007994 <xTaskResumeAll+0xe0>
80007948:	70 08       	ld.w	r8,r8[0x0]
8000794a:	58 18       	cp.w	r8,1
8000794c:	c0 71       	brne	8000795a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000794e:	30 09       	mov	r9,0
80007950:	49 18       	lddpc	r8,80007994 <xTaskResumeAll+0xe0>
80007952:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007954:	d7 33       	scall
80007956:	30 17       	mov	r7,1
80007958:	c0 28       	rjmp	8000795c <xTaskResumeAll+0xa8>
8000795a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000795c:	f0 1f 00 0f 	mcall	80007998 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007960:	0e 9c       	mov	r12,r7
80007962:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007966:	00 00       	add	r0,r0
80007968:	80 00       	ld.sh	r0,r0[0x0]
8000796a:	6d 6c       	ld.w	r12,r6[0x58]
8000796c:	00 00       	add	r0,r0
8000796e:	0d a4       	ld.ub	r4,r6[0x2]
80007970:	00 00       	add	r0,r0
80007972:	0d c0       	ld.ub	r0,r6[0x4]
80007974:	00 00       	add	r0,r0
80007976:	0d 78       	ld.ub	r8,--r6
80007978:	00 00       	add	r0,r0
8000797a:	0d dc       	ld.ub	r12,r6[0x5]
8000797c:	00 00       	add	r0,r0
8000797e:	0c c0       	st.b	r6++,r0
80007980:	00 00       	add	r0,r0
80007982:	0d 74       	ld.ub	r4,--r6
80007984:	80 00       	ld.sh	r0,r0[0x0]
80007986:	6c b2       	ld.w	r2,r6[0x2c]
80007988:	80 00       	ld.sh	r0,r0[0x0]
8000798a:	6c 62       	ld.w	r2,r6[0x18]
8000798c:	00 00       	add	r0,r0
8000798e:	0c a4       	st.w	r6++,r4
80007990:	80 00       	ld.sh	r0,r0[0x0]
80007992:	77 0c       	ld.w	r12,r11[0x40]
80007994:	00 00       	add	r0,r0
80007996:	0d c4       	ld.ub	r4,r6[0x4]
80007998:	80 00       	ld.sh	r0,r0[0x0]
8000799a:	6e 78       	ld.w	r8,r7[0x1c]

8000799c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000799c:	eb cd 40 80 	pushm	r7,lr
800079a0:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800079a2:	49 08       	lddpc	r8,800079e0 <prvAddCurrentTaskToDelayedList+0x44>
800079a4:	70 08       	ld.w	r8,r8[0x0]
800079a6:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800079a8:	48 f8       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x48>
800079aa:	70 08       	ld.w	r8,r8[0x0]
800079ac:	10 3c       	cp.w	r12,r8
800079ae:	c0 a2       	brcc	800079c2 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079b0:	48 c8       	lddpc	r8,800079e0 <prvAddCurrentTaskToDelayedList+0x44>
800079b2:	70 0b       	ld.w	r11,r8[0x0]
800079b4:	48 d8       	lddpc	r8,800079e8 <prvAddCurrentTaskToDelayedList+0x4c>
800079b6:	70 0c       	ld.w	r12,r8[0x0]
800079b8:	2f cb       	sub	r11,-4
800079ba:	f0 1f 00 0d 	mcall	800079ec <prvAddCurrentTaskToDelayedList+0x50>
800079be:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079c2:	48 88       	lddpc	r8,800079e0 <prvAddCurrentTaskToDelayedList+0x44>
800079c4:	70 0b       	ld.w	r11,r8[0x0]
800079c6:	48 b8       	lddpc	r8,800079f0 <prvAddCurrentTaskToDelayedList+0x54>
800079c8:	70 0c       	ld.w	r12,r8[0x0]
800079ca:	2f cb       	sub	r11,-4
800079cc:	f0 1f 00 08 	mcall	800079ec <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800079d0:	48 98       	lddpc	r8,800079f4 <prvAddCurrentTaskToDelayedList+0x58>
800079d2:	70 08       	ld.w	r8,r8[0x0]
800079d4:	10 37       	cp.w	r7,r8
800079d6:	c0 32       	brcc	800079dc <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800079d8:	48 78       	lddpc	r8,800079f4 <prvAddCurrentTaskToDelayedList+0x58>
800079da:	91 07       	st.w	r8[0x0],r7
800079dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800079e0:	00 00       	add	r0,r0
800079e2:	0d 74       	ld.ub	r4,--r6
800079e4:	00 00       	add	r0,r0
800079e6:	0d a0       	ld.ub	r0,r6[0x2]
800079e8:	00 00       	add	r0,r0
800079ea:	0c bc       	st.h	r6++,r12
800079ec:	80 00       	ld.sh	r0,r0[0x0]
800079ee:	6c 7e       	ld.w	lr,r6[0x1c]
800079f0:	00 00       	add	r0,r0
800079f2:	0c ac       	st.w	r6++,r12
800079f4:	00 00       	add	r0,r0
800079f6:	05 50       	ld.sh	r0,--r2

800079f8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800079f8:	eb cd 40 c0 	pushm	r6-r7,lr
800079fc:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800079fe:	58 0c       	cp.w	r12,0
80007a00:	c1 10       	breq	80007a22 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80007a02:	f0 1f 00 0a 	mcall	80007a28 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80007a06:	48 a8       	lddpc	r8,80007a2c <vTaskDelay+0x34>
80007a08:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a0a:	48 a8       	lddpc	r8,80007a30 <vTaskDelay+0x38>
80007a0c:	70 0c       	ld.w	r12,r8[0x0]
80007a0e:	2f cc       	sub	r12,-4
80007a10:	f0 1f 00 09 	mcall	80007a34 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a14:	ee 06 00 0c 	add	r12,r7,r6
80007a18:	f0 1f 00 08 	mcall	80007a38 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007a1c:	f0 1f 00 08 	mcall	80007a3c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a20:	c0 21       	brne	80007a24 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80007a22:	d7 33       	scall
80007a24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	74 f8       	ld.w	r8,r10[0x3c]
80007a2c:	00 00       	add	r0,r0
80007a2e:	0d a0       	ld.ub	r0,r6[0x2]
80007a30:	00 00       	add	r0,r0
80007a32:	0d 74       	ld.ub	r4,--r6
80007a34:	80 00       	ld.sh	r0,r0[0x0]
80007a36:	6c b2       	ld.w	r2,r6[0x2c]
80007a38:	80 00       	ld.sh	r0,r0[0x0]
80007a3a:	79 9c       	ld.w	r12,r12[0x64]
80007a3c:	80 00       	ld.sh	r0,r0[0x0]
80007a3e:	78 b4       	ld.w	r4,r12[0x2c]

80007a40 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007a40:	eb cd 40 c0 	pushm	r6-r7,lr
80007a44:	18 96       	mov	r6,r12
80007a46:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007a48:	f0 1f 00 18 	mcall	80007aa8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007a4c:	6c 08       	ld.w	r8,r6[0x0]
80007a4e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007a50:	49 79       	lddpc	r9,80007aac <vTaskDelayUntil+0x6c>
80007a52:	72 09       	ld.w	r9,r9[0x0]
80007a54:	12 38       	cp.w	r8,r9
80007a56:	e0 88 00 0c 	brls	80007a6e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007a5a:	0e 38       	cp.w	r8,r7
80007a5c:	e0 88 00 22 	brls	80007aa0 <vTaskDelayUntil+0x60>
80007a60:	49 38       	lddpc	r8,80007aac <vTaskDelayUntil+0x6c>
80007a62:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a64:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007a66:	10 37       	cp.w	r7,r8
80007a68:	e0 88 00 14 	brls	80007a90 <vTaskDelayUntil+0x50>
80007a6c:	c0 a8       	rjmp	80007a80 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007a6e:	0e 38       	cp.w	r8,r7
80007a70:	e0 8b 00 16 	brhi	80007a9c <vTaskDelayUntil+0x5c>
80007a74:	48 e8       	lddpc	r8,80007aac <vTaskDelayUntil+0x6c>
80007a76:	70 08       	ld.w	r8,r8[0x0]
80007a78:	10 37       	cp.w	r7,r8
80007a7a:	e0 8b 00 11 	brhi	80007a9c <vTaskDelayUntil+0x5c>
80007a7e:	c1 18       	rjmp	80007aa0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a80:	48 c8       	lddpc	r8,80007ab0 <vTaskDelayUntil+0x70>
80007a82:	70 0c       	ld.w	r12,r8[0x0]
80007a84:	2f cc       	sub	r12,-4
80007a86:	f0 1f 00 0c 	mcall	80007ab4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a8a:	0e 9c       	mov	r12,r7
80007a8c:	f0 1f 00 0b 	mcall	80007ab8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007a90:	f0 1f 00 0b 	mcall	80007abc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a94:	c0 81       	brne	80007aa4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007a96:	d7 33       	scall
80007a98:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a9c:	8d 07       	st.w	r6[0x0],r7
80007a9e:	cf 1b       	rjmp	80007a80 <vTaskDelayUntil+0x40>
80007aa0:	8d 07       	st.w	r6[0x0],r7
80007aa2:	cf 7b       	rjmp	80007a90 <vTaskDelayUntil+0x50>
80007aa4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007aa8:	80 00       	ld.sh	r0,r0[0x0]
80007aaa:	74 f8       	ld.w	r8,r10[0x3c]
80007aac:	00 00       	add	r0,r0
80007aae:	0d a0       	ld.ub	r0,r6[0x2]
80007ab0:	00 00       	add	r0,r0
80007ab2:	0d 74       	ld.ub	r4,--r6
80007ab4:	80 00       	ld.sh	r0,r0[0x0]
80007ab6:	6c b2       	ld.w	r2,r6[0x2c]
80007ab8:	80 00       	ld.sh	r0,r0[0x0]
80007aba:	79 9c       	ld.w	r12,r12[0x64]
80007abc:	80 00       	ld.sh	r0,r0[0x0]
80007abe:	78 b4       	ld.w	r4,r12[0x2c]

80007ac0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007ac0:	eb cd 40 c0 	pushm	r6-r7,lr
80007ac4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007ac6:	48 e7       	lddpc	r7,80007afc <vTaskPlaceOnEventList+0x3c>
80007ac8:	6e 0b       	ld.w	r11,r7[0x0]
80007aca:	2e 8b       	sub	r11,-24
80007acc:	f0 1f 00 0d 	mcall	80007b00 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007ad0:	6e 0c       	ld.w	r12,r7[0x0]
80007ad2:	2f cc       	sub	r12,-4
80007ad4:	f0 1f 00 0c 	mcall	80007b04 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007ad8:	5b f6       	cp.w	r6,-1
80007ada:	c0 81       	brne	80007aea <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007adc:	6e 0b       	ld.w	r11,r7[0x0]
80007ade:	2f cb       	sub	r11,-4
80007ae0:	48 ac       	lddpc	r12,80007b08 <vTaskPlaceOnEventList+0x48>
80007ae2:	f0 1f 00 0b 	mcall	80007b0c <vTaskPlaceOnEventList+0x4c>
80007ae6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007aea:	48 a8       	lddpc	r8,80007b10 <vTaskPlaceOnEventList+0x50>
80007aec:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007aee:	ec 0c 00 0c 	add	r12,r6,r12
80007af2:	f0 1f 00 09 	mcall	80007b14 <vTaskPlaceOnEventList+0x54>
80007af6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007afa:	00 00       	add	r0,r0
80007afc:	00 00       	add	r0,r0
80007afe:	0d 74       	ld.ub	r4,--r6
80007b00:	80 00       	ld.sh	r0,r0[0x0]
80007b02:	6c 7e       	ld.w	lr,r6[0x1c]
80007b04:	80 00       	ld.sh	r0,r0[0x0]
80007b06:	6c b2       	ld.w	r2,r6[0x2c]
80007b08:	00 00       	add	r0,r0
80007b0a:	0d c8       	ld.ub	r8,r6[0x4]
80007b0c:	80 00       	ld.sh	r0,r0[0x0]
80007b0e:	6c 62       	ld.w	r2,r6[0x18]
80007b10:	00 00       	add	r0,r0
80007b12:	0d a0       	ld.ub	r0,r6[0x2]
80007b14:	80 00       	ld.sh	r0,r0[0x0]
80007b16:	79 9c       	ld.w	r12,r12[0x64]

80007b18 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007b18:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b1c:	49 67       	lddpc	r7,80007b74 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b1e:	49 74       	lddpc	r4,80007b78 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007b20:	49 73       	lddpc	r3,80007b7c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b22:	49 85       	lddpc	r5,80007b80 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b24:	6e 08       	ld.w	r8,r7[0x0]
80007b26:	58 08       	cp.w	r8,0
80007b28:	c1 e0       	breq	80007b64 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007b2a:	f0 1f 00 17 	mcall	80007b84 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b2e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007b30:	f0 1f 00 16 	mcall	80007b88 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007b34:	58 06       	cp.w	r6,0
80007b36:	c1 70       	breq	80007b64 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007b38:	f0 1f 00 15 	mcall	80007b8c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007b3c:	68 38       	ld.w	r8,r4[0xc]
80007b3e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007b40:	ec cc ff fc 	sub	r12,r6,-4
80007b44:	f0 1f 00 13 	mcall	80007b90 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007b48:	66 08       	ld.w	r8,r3[0x0]
80007b4a:	20 18       	sub	r8,1
80007b4c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007b4e:	6e 08       	ld.w	r8,r7[0x0]
80007b50:	20 18       	sub	r8,1
80007b52:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007b54:	f0 1f 00 10 	mcall	80007b94 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007b58:	6c cc       	ld.w	r12,r6[0x30]
80007b5a:	f0 1f 00 10 	mcall	80007b98 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007b5e:	0c 9c       	mov	r12,r6
80007b60:	f0 1f 00 0e 	mcall	80007b98 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b64:	6a 08       	ld.w	r8,r5[0x0]
80007b66:	58 18       	cp.w	r8,1
80007b68:	e0 88 00 03 	brls	80007b6e <prvIdleTask+0x56>
			{
				taskYIELD();
80007b6c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007b6e:	f0 1f 00 0c 	mcall	80007b9c <prvIdleTask+0x84>
		}
		#endif
	}
80007b72:	cd 9b       	rjmp	80007b24 <prvIdleTask+0xc>
80007b74:	00 00       	add	r0,r0
80007b76:	0c b4       	st.h	r6++,r4
80007b78:	00 00       	add	r0,r0
80007b7a:	0d 60       	ld.uh	r0,--r6
80007b7c:	00 00       	add	r0,r0
80007b7e:	0d c0       	ld.ub	r0,r6[0x4]
80007b80:	00 00       	add	r0,r0
80007b82:	0c c0       	st.b	r6++,r0
80007b84:	80 00       	ld.sh	r0,r0[0x0]
80007b86:	74 f8       	ld.w	r8,r10[0x3c]
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	78 b4       	ld.w	r4,r12[0x2c]
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	6d 6c       	ld.w	r12,r6[0x58]
80007b90:	80 00       	ld.sh	r0,r0[0x0]
80007b92:	6c b2       	ld.w	r2,r6[0x2c]
80007b94:	80 00       	ld.sh	r0,r0[0x0]
80007b96:	6e 78       	ld.w	r8,r7[0x1c]
80007b98:	80 00       	ld.sh	r0,r0[0x0]
80007b9a:	6f b0       	ld.w	r0,r7[0x6c]
80007b9c:	80 00       	ld.sh	r0,r0[0x0]
80007b9e:	20 2c       	sub	r12,2

80007ba0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007ba0:	d4 31       	pushm	r0-r7,lr
80007ba2:	20 1d       	sub	sp,4
80007ba4:	fa c4 ff d8 	sub	r4,sp,-40
80007ba8:	50 0c       	stdsp	sp[0x0],r12
80007baa:	16 91       	mov	r1,r11
80007bac:	14 97       	mov	r7,r10
80007bae:	12 90       	mov	r0,r9
80007bb0:	10 93       	mov	r3,r8
80007bb2:	68 02       	ld.w	r2,r4[0x0]
80007bb4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007bb6:	34 8c       	mov	r12,72
80007bb8:	f0 1f 00 5c 	mcall	80007d28 <xTaskGenericCreate+0x188>
80007bbc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007bbe:	c0 31       	brne	80007bc4 <xTaskGenericCreate+0x24>
80007bc0:	3f fc       	mov	r12,-1
80007bc2:	ca f8       	rjmp	80007d20 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007bc4:	58 06       	cp.w	r6,0
80007bc6:	e0 81 00 af 	brne	80007d24 <xTaskGenericCreate+0x184>
80007bca:	0e 9c       	mov	r12,r7
80007bcc:	5c 7c       	castu.h	r12
80007bce:	a3 6c       	lsl	r12,0x2
80007bd0:	f0 1f 00 56 	mcall	80007d28 <xTaskGenericCreate+0x188>
80007bd4:	18 96       	mov	r6,r12
80007bd6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007bd8:	c0 61       	brne	80007be4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007bda:	0a 9c       	mov	r12,r5
80007bdc:	f0 1f 00 54 	mcall	80007d2c <xTaskGenericCreate+0x18c>
80007be0:	3f fc       	mov	r12,-1
80007be2:	c9 f8       	rjmp	80007d20 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007be4:	5c 77       	castu.h	r7
80007be6:	ee 0a 15 02 	lsl	r10,r7,0x2
80007bea:	e0 6b 00 a5 	mov	r11,165
80007bee:	0c 9c       	mov	r12,r6
80007bf0:	f0 1f 00 50 	mcall	80007d30 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007bf4:	ee c6 00 01 	sub	r6,r7,1
80007bf8:	6a c8       	ld.w	r8,r5[0x30]
80007bfa:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007bfe:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007c02:	31 0a       	mov	r10,16
80007c04:	02 9b       	mov	r11,r1
80007c06:	ea cc ff cc 	sub	r12,r5,-52
80007c0a:	f0 1f 00 4b 	mcall	80007d34 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007c0e:	30 08       	mov	r8,0
80007c10:	eb 68 00 43 	st.b	r5[67],r8
80007c14:	58 73       	cp.w	r3,7
80007c16:	e6 07 17 80 	movls	r7,r3
80007c1a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007c1e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007c20:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007c24:	ea c4 ff fc 	sub	r4,r5,-4
80007c28:	08 9c       	mov	r12,r4
80007c2a:	f0 1f 00 44 	mcall	80007d38 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007c2e:	ea cc ff e8 	sub	r12,r5,-24
80007c32:	f0 1f 00 42 	mcall	80007d38 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007c36:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007c38:	ee 07 11 08 	rsub	r7,r7,8
80007c3c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007c3e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007c40:	00 9a       	mov	r10,r0
80007c42:	40 0b       	lddsp	r11,sp[0x0]
80007c44:	0c 9c       	mov	r12,r6
80007c46:	f0 1f 00 3e 	mcall	80007d3c <xTaskGenericCreate+0x19c>
80007c4a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007c4c:	58 02       	cp.w	r2,0
80007c4e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007c52:	f0 1f 00 3c 	mcall	80007d40 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007c56:	4b c8       	lddpc	r8,80007d44 <xTaskGenericCreate+0x1a4>
80007c58:	70 09       	ld.w	r9,r8[0x0]
80007c5a:	2f f9       	sub	r9,-1
80007c5c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007c5e:	4b b8       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a8>
80007c60:	70 08       	ld.w	r8,r8[0x0]
80007c62:	58 08       	cp.w	r8,0
80007c64:	c2 61       	brne	80007cb0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007c66:	4b 98       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a8>
80007c68:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007c6a:	4b 78       	lddpc	r8,80007d44 <xTaskGenericCreate+0x1a4>
80007c6c:	70 08       	ld.w	r8,r8[0x0]
80007c6e:	58 18       	cp.w	r8,1
80007c70:	c2 b1       	brne	80007cc6 <xTaskGenericCreate+0x126>
80007c72:	4b 77       	lddpc	r7,80007d4c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007c74:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007c78:	0e 9c       	mov	r12,r7
80007c7a:	f0 1f 00 36 	mcall	80007d50 <xTaskGenericCreate+0x1b0>
80007c7e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007c80:	0c 37       	cp.w	r7,r6
80007c82:	cf b1       	brne	80007c78 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007c84:	4b 47       	lddpc	r7,80007d54 <xTaskGenericCreate+0x1b4>
80007c86:	0e 9c       	mov	r12,r7
80007c88:	f0 1f 00 32 	mcall	80007d50 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007c8c:	4b 36       	lddpc	r6,80007d58 <xTaskGenericCreate+0x1b8>
80007c8e:	0c 9c       	mov	r12,r6
80007c90:	f0 1f 00 30 	mcall	80007d50 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007c94:	4b 2c       	lddpc	r12,80007d5c <xTaskGenericCreate+0x1bc>
80007c96:	f0 1f 00 2f 	mcall	80007d50 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007c9a:	4b 2c       	lddpc	r12,80007d60 <xTaskGenericCreate+0x1c0>
80007c9c:	f0 1f 00 2d 	mcall	80007d50 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007ca0:	4b 1c       	lddpc	r12,80007d64 <xTaskGenericCreate+0x1c4>
80007ca2:	f0 1f 00 2c 	mcall	80007d50 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007ca6:	4b 18       	lddpc	r8,80007d68 <xTaskGenericCreate+0x1c8>
80007ca8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007caa:	4b 18       	lddpc	r8,80007d6c <xTaskGenericCreate+0x1cc>
80007cac:	91 06       	st.w	r8[0x0],r6
80007cae:	c0 c8       	rjmp	80007cc6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007cb0:	4b 08       	lddpc	r8,80007d70 <xTaskGenericCreate+0x1d0>
80007cb2:	70 08       	ld.w	r8,r8[0x0]
80007cb4:	58 08       	cp.w	r8,0
80007cb6:	c0 81       	brne	80007cc6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007cb8:	4a 48       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a8>
80007cba:	70 08       	ld.w	r8,r8[0x0]
80007cbc:	70 b8       	ld.w	r8,r8[0x2c]
80007cbe:	10 33       	cp.w	r3,r8
80007cc0:	c0 33       	brcs	80007cc6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007cc2:	4a 28       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a8>
80007cc4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007cc6:	6a b8       	ld.w	r8,r5[0x2c]
80007cc8:	4a b9       	lddpc	r9,80007d74 <xTaskGenericCreate+0x1d4>
80007cca:	72 09       	ld.w	r9,r9[0x0]
80007ccc:	12 38       	cp.w	r8,r9
80007cce:	e0 88 00 04 	brls	80007cd6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007cd2:	4a 99       	lddpc	r9,80007d74 <xTaskGenericCreate+0x1d4>
80007cd4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007cd6:	4a 98       	lddpc	r8,80007d78 <xTaskGenericCreate+0x1d8>
80007cd8:	70 09       	ld.w	r9,r8[0x0]
80007cda:	2f f9       	sub	r9,-1
80007cdc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007cde:	6a b8       	ld.w	r8,r5[0x2c]
80007ce0:	4a 79       	lddpc	r9,80007d7c <xTaskGenericCreate+0x1dc>
80007ce2:	72 09       	ld.w	r9,r9[0x0]
80007ce4:	12 38       	cp.w	r8,r9
80007ce6:	e0 88 00 04 	brls	80007cee <xTaskGenericCreate+0x14e>
80007cea:	4a 59       	lddpc	r9,80007d7c <xTaskGenericCreate+0x1dc>
80007cec:	93 08       	st.w	r9[0x0],r8
80007cee:	6a bc       	ld.w	r12,r5[0x2c]
80007cf0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007cf4:	08 9b       	mov	r11,r4
80007cf6:	49 68       	lddpc	r8,80007d4c <xTaskGenericCreate+0x1ac>
80007cf8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007cfc:	f0 1f 00 21 	mcall	80007d80 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007d00:	f0 1f 00 21 	mcall	80007d84 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007d04:	49 b8       	lddpc	r8,80007d70 <xTaskGenericCreate+0x1d0>
80007d06:	70 08       	ld.w	r8,r8[0x0]
80007d08:	58 08       	cp.w	r8,0
80007d0a:	c0 a0       	breq	80007d1e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007d0c:	48 f8       	lddpc	r8,80007d48 <xTaskGenericCreate+0x1a8>
80007d0e:	70 08       	ld.w	r8,r8[0x0]
80007d10:	70 b8       	ld.w	r8,r8[0x2c]
80007d12:	10 33       	cp.w	r3,r8
80007d14:	e0 88 00 05 	brls	80007d1e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007d18:	d7 33       	scall
80007d1a:	30 1c       	mov	r12,1
80007d1c:	c0 28       	rjmp	80007d20 <xTaskGenericCreate+0x180>
80007d1e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007d20:	2f fd       	sub	sp,-4
80007d22:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007d24:	99 c6       	st.w	r12[0x30],r6
80007d26:	c5 fb       	rjmp	80007be4 <xTaskGenericCreate+0x44>
80007d28:	80 00       	ld.sh	r0,r0[0x0]
80007d2a:	6f d8       	ld.w	r8,r7[0x74]
80007d2c:	80 00       	ld.sh	r0,r0[0x0]
80007d2e:	6f b0       	ld.w	r0,r7[0x6c]
80007d30:	80 00       	ld.sh	r0,r0[0x0]
80007d32:	89 56       	st.w	r4[0x14],r6
80007d34:	80 00       	ld.sh	r0,r0[0x0]
80007d36:	8c 80       	ld.uh	r0,r6[0x0]
80007d38:	80 00       	ld.sh	r0,r0[0x0]
80007d3a:	6c 5c       	ld.w	r12,r6[0x14]
80007d3c:	80 00       	ld.sh	r0,r0[0x0]
80007d3e:	6c d8       	ld.w	r8,r6[0x34]
80007d40:	80 00       	ld.sh	r0,r0[0x0]
80007d42:	6d 6c       	ld.w	r12,r6[0x58]
80007d44:	00 00       	add	r0,r0
80007d46:	0d c0       	ld.ub	r0,r6[0x4]
80007d48:	00 00       	add	r0,r0
80007d4a:	0d 74       	ld.ub	r4,--r6
80007d4c:	00 00       	add	r0,r0
80007d4e:	0c c0       	st.b	r6++,r0
80007d50:	80 00       	ld.sh	r0,r0[0x0]
80007d52:	6c 48       	ld.w	r8,r6[0x10]
80007d54:	00 00       	add	r0,r0
80007d56:	0d 8c       	ld.ub	r12,r6[0x0]
80007d58:	00 00       	add	r0,r0
80007d5a:	0d a8       	ld.ub	r8,r6[0x2]
80007d5c:	00 00       	add	r0,r0
80007d5e:	0d 78       	ld.ub	r8,--r6
80007d60:	00 00       	add	r0,r0
80007d62:	0d 60       	ld.uh	r0,--r6
80007d64:	00 00       	add	r0,r0
80007d66:	0d c8       	ld.ub	r8,r6[0x4]
80007d68:	00 00       	add	r0,r0
80007d6a:	0c ac       	st.w	r6++,r12
80007d6c:	00 00       	add	r0,r0
80007d6e:	0c bc       	st.h	r6++,r12
80007d70:	00 00       	add	r0,r0
80007d72:	0c b0       	st.h	r6++,r0
80007d74:	00 00       	add	r0,r0
80007d76:	0c a8       	st.w	r6++,r8
80007d78:	00 00       	add	r0,r0
80007d7a:	0d bc       	ld.ub	r12,r6[0x3]
80007d7c:	00 00       	add	r0,r0
80007d7e:	0d dc       	ld.ub	r12,r6[0x5]
80007d80:	80 00       	ld.sh	r0,r0[0x0]
80007d82:	6c 62       	ld.w	r2,r6[0x18]
80007d84:	80 00       	ld.sh	r0,r0[0x0]
80007d86:	6e 78       	ld.w	r8,r7[0x1c]

80007d88 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007d88:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007d8a:	30 09       	mov	r9,0
80007d8c:	1a d9       	st.w	--sp,r9
80007d8e:	1a d9       	st.w	--sp,r9
80007d90:	1a d9       	st.w	--sp,r9
80007d92:	12 98       	mov	r8,r9
80007d94:	e0 6a 01 00 	mov	r10,256
80007d98:	48 9b       	lddpc	r11,80007dbc <vTaskStartScheduler+0x34>
80007d9a:	48 ac       	lddpc	r12,80007dc0 <vTaskStartScheduler+0x38>
80007d9c:	f0 1f 00 0a 	mcall	80007dc4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007da0:	2f dd       	sub	sp,-12
80007da2:	58 1c       	cp.w	r12,1
80007da4:	c0 a1       	brne	80007db8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007da6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007da8:	30 19       	mov	r9,1
80007daa:	48 88       	lddpc	r8,80007dc8 <vTaskStartScheduler+0x40>
80007dac:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007dae:	30 09       	mov	r9,0
80007db0:	48 78       	lddpc	r8,80007dcc <vTaskStartScheduler+0x44>
80007db2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007db4:	f0 1f 00 07 	mcall	80007dd0 <vTaskStartScheduler+0x48>
80007db8:	d8 02       	popm	pc
80007dba:	00 00       	add	r0,r0
80007dbc:	80 00       	ld.sh	r0,r0[0x0]
80007dbe:	ed 8c       	*unknown*
80007dc0:	80 00       	ld.sh	r0,r0[0x0]
80007dc2:	7b 18       	ld.w	r8,sp[0x44]
80007dc4:	80 00       	ld.sh	r0,r0[0x0]
80007dc6:	7b a0       	ld.w	r0,sp[0x68]
80007dc8:	00 00       	add	r0,r0
80007dca:	0c b0       	st.h	r6++,r0
80007dcc:	00 00       	add	r0,r0
80007dce:	0d a0       	ld.ub	r0,r6[0x2]
80007dd0:	80 00       	ld.sh	r0,r0[0x0]
80007dd2:	6d 7c       	ld.w	r12,r6[0x5c]

80007dd4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007dd4:	16 cc       	st.b	r11++,r12
	return str;
}
80007dd6:	5e fb       	retal	r11

80007dd8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007dd8:	eb cd 40 c0 	pushm	r6-r7,lr
80007ddc:	20 3d       	sub	sp,12
80007dde:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007de0:	30 06       	mov	r6,0
80007de2:	30 07       	mov	r7,0
80007de4:	fa e7 00 00 	st.d	sp[0],r6
80007de8:	30 0c       	mov	r12,0
80007dea:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007dec:	58 08       	cp.w	r8,0
80007dee:	c1 30       	breq	80007e14 <PrintHex+0x3c>
80007df0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007df2:	1a 9c       	mov	r12,sp
80007df4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007df8:	58 9e       	cp.w	lr,9
80007dfa:	e0 8a 00 04 	brle	80007e02 <PrintHex+0x2a>
80007dfe:	2c 9e       	sub	lr,-55
80007e00:	c0 48       	rjmp	80007e08 <PrintHex+0x30>
80007e02:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007e06:	2d 0e       	sub	lr,-48
80007e08:	f8 09 0b 0e 	st.b	r12[r9],lr
80007e0c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007e0e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007e10:	cf 21       	brne	80007df4 <PrintHex+0x1c>
80007e12:	c0 48       	rjmp	80007e1a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007e14:	33 08       	mov	r8,48
80007e16:	ba 88       	st.b	sp[0x0],r8
80007e18:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007e1a:	f6 09 01 08 	sub	r8,r11,r9
80007e1e:	58 08       	cp.w	r8,0
80007e20:	e0 8a 00 13 	brle	80007e46 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007e24:	12 1b       	sub	r11,r9
80007e26:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007e2a:	18 9e       	mov	lr,r12
80007e2c:	58 0c       	cp.w	r12,0
80007e2e:	e0 8a 00 0c 	brle	80007e46 <PrintHex+0x6e>
80007e32:	1a 9b       	mov	r11,sp
80007e34:	12 0b       	add	r11,r9
80007e36:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007e38:	33 07       	mov	r7,48
80007e3a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007e3c:	2f f8       	sub	r8,-1
80007e3e:	1c 38       	cp.w	r8,lr
80007e40:	cf d5       	brlt	80007e3a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e42:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e46:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007e4a:	f0 cb ff ff 	sub	r11,r8,-1
80007e4e:	58 0b       	cp.w	r11,0
80007e50:	e0 8a 00 19 	brle	80007e82 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e54:	fa cb ff f4 	sub	r11,sp,-12
80007e58:	f6 09 00 09 	add	r9,r11,r9
80007e5c:	37 8b       	mov	r11,120
80007e5e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007e62:	fa c9 ff f4 	sub	r9,sp,-12
80007e66:	10 09       	add	r9,r8
80007e68:	33 0b       	mov	r11,48
80007e6a:	f3 6b ff f4 	st.b	r9[-12],r11
80007e6e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e72:	fa ce 00 01 	sub	lr,sp,1
80007e76:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007e78:	11 8b       	ld.ub	r11,r8[0x0]
80007e7a:	12 cb       	st.b	r9++,r11
80007e7c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007e7e:	1c 38       	cp.w	r8,lr
80007e80:	cf c1       	brne	80007e78 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007e82:	14 9c       	mov	r12,r10
80007e84:	2f dd       	sub	sp,-12
80007e86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007e8a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007e8a:	d4 21       	pushm	r4-r7,lr
80007e8c:	20 3d       	sub	sp,12
80007e8e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007e90:	30 06       	mov	r6,0
80007e92:	30 07       	mov	r7,0
80007e94:	fa e7 00 00 	st.d	sp[0],r6
80007e98:	30 0c       	mov	r12,0
80007e9a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007e9c:	58 08       	cp.w	r8,0
80007e9e:	c0 35       	brlt	80007ea4 <PrintDec+0x1a>
80007ea0:	14 97       	mov	r7,r10
80007ea2:	c0 58       	rjmp	80007eac <PrintDec+0x22>
	{
		*p++ = '-';
80007ea4:	14 97       	mov	r7,r10
80007ea6:	32 d9       	mov	r9,45
80007ea8:	0e c9       	st.b	r7++,r9
		i = -i;
80007eaa:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007eac:	58 08       	cp.w	r8,0
80007eae:	c0 51       	brne	80007eb8 <PrintDec+0x2e>
80007eb0:	33 08       	mov	r8,48
80007eb2:	ba 88       	st.b	sp[0x0],r8
80007eb4:	30 1e       	mov	lr,1
80007eb6:	c2 f8       	rjmp	80007f14 <PrintDec+0x8a>
	
	int ten = i%10;
80007eb8:	e0 65 66 67 	mov	r5,26215
80007ebc:	ea 15 66 66 	orh	r5,0x6666
80007ec0:	f0 05 04 44 	muls.d	r4,r8,r5
80007ec4:	ea 0c 14 02 	asr	r12,r5,0x2
80007ec8:	f0 09 14 1f 	asr	r9,r8,0x1f
80007ecc:	f8 09 01 09 	sub	r9,r12,r9
80007ed0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ed4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007ed8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007eda:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007edc:	e0 66 66 67 	mov	r6,26215
80007ee0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007ee4:	2d 09       	sub	r9,-48
80007ee6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007eea:	2f fe       	sub	lr,-1
		i /= 10;
80007eec:	f0 06 04 44 	muls.d	r4,r8,r6
80007ef0:	ea 09 14 02 	asr	r9,r5,0x2
80007ef4:	bf 58       	asr	r8,0x1f
80007ef6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007efa:	f0 06 04 44 	muls.d	r4,r8,r6
80007efe:	ea 09 14 02 	asr	r9,r5,0x2
80007f02:	f0 05 14 1f 	asr	r5,r8,0x1f
80007f06:	0a 19       	sub	r9,r5
80007f08:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f0c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007f10:	58 08       	cp.w	r8,0
80007f12:	ce 91       	brne	80007ee4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007f14:	f6 0e 01 08 	sub	r8,r11,lr
80007f18:	58 08       	cp.w	r8,0
80007f1a:	e0 89 00 06 	brgt	80007f26 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f1e:	58 0e       	cp.w	lr,0
80007f20:	e0 89 00 14 	brgt	80007f48 <PrintDec+0xbe>
80007f24:	c1 d8       	rjmp	80007f5e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007f26:	1c 1b       	sub	r11,lr
80007f28:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007f2a:	16 9c       	mov	r12,r11
80007f2c:	58 0b       	cp.w	r11,0
80007f2e:	fe 9a ff f8 	brle	80007f1e <PrintDec+0x94>
80007f32:	1a 99       	mov	r9,sp
80007f34:	1c 09       	add	r9,lr
80007f36:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007f38:	33 06       	mov	r6,48
80007f3a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007f3c:	2f f8       	sub	r8,-1
80007f3e:	18 38       	cp.w	r8,r12
80007f40:	cf d5       	brlt	80007f3a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007f42:	f6 0e 00 0e 	add	lr,r11,lr
80007f46:	ce cb       	rjmp	80007f1e <PrintDec+0x94>
80007f48:	fa c8 ff f4 	sub	r8,sp,-12
80007f4c:	1c 08       	add	r8,lr
80007f4e:	20 d8       	sub	r8,13
80007f50:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007f54:	11 89       	ld.ub	r9,r8[0x0]
80007f56:	0e c9       	st.b	r7++,r9
80007f58:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f5a:	16 38       	cp.w	r8,r11
80007f5c:	cf c1       	brne	80007f54 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007f5e:	14 9c       	mov	r12,r10
80007f60:	2f dd       	sub	sp,-12
80007f62:	d8 22       	popm	r4-r7,pc

80007f64 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007f64:	d4 31       	pushm	r0-r7,lr
80007f66:	fa cd 02 08 	sub	sp,sp,520
80007f6a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007f6c:	e0 6a 01 00 	mov	r10,256
80007f70:	30 0b       	mov	r11,0
80007f72:	fa cc fe f8 	sub	r12,sp,-264
80007f76:	f0 1f 00 4e 	mcall	800080ac <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007f7a:	fa c4 fd d4 	sub	r4,sp,-556
80007f7e:	30 0a       	mov	r10,0
80007f80:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f82:	fa c3 ff fc 	sub	r3,sp,-4
80007f86:	e0 61 01 00 	mov	r1,256
80007f8a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007f8c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007f8e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f92:	02 9a       	mov	r10,r1
80007f94:	00 9b       	mov	r11,r0
80007f96:	06 9c       	mov	r12,r3
80007f98:	f0 1f 00 45 	mcall	800080ac <log+0x148>
			
					if(*str == '%')
80007f9c:	0f 88       	ld.ub	r8,r7[0x0]
80007f9e:	e4 08 18 00 	cp.b	r8,r2
80007fa2:	c5 71       	brne	80008050 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007fa4:	ee c8 ff ff 	sub	r8,r7,-1
80007fa8:	11 89       	ld.ub	r9,r8[0x0]
80007faa:	4c 2a       	lddpc	r10,800080b0 <log+0x14c>
80007fac:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007fae:	23 09       	sub	r9,48
80007fb0:	30 9a       	mov	r10,9
80007fb2:	f4 09 18 00 	cp.b	r9,r10
80007fb6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007fba:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007fbe:	f7 b9 08 30 	subls	r9,48
80007fc2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007fc6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007fca:	0f 88       	ld.ub	r8,r7[0x0]
80007fcc:	22 58       	sub	r8,37
80007fce:	e0 48 00 53 	cp.w	r8,83
80007fd2:	e0 8b 00 31 	brhi	80008034 <log+0xd0>
80007fd6:	4b 89       	lddpc	r9,800080b4 <log+0x150>
80007fd8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007fdc:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007fe0:	06 9a       	mov	r10,r3
80007fe2:	40 0b       	lddsp	r11,sp[0x0]
80007fe4:	5c 5b       	castu.b	r11
80007fe6:	68 0c       	ld.w	r12,r4[0x0]
80007fe8:	f0 1f 00 34 	mcall	800080b8 <log+0x154>
							break;
80007fec:	c2 98       	rjmp	8000803e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007fee:	4b 4c       	lddpc	r12,800080bc <log+0x158>
80007ff0:	f0 1f 00 34 	mcall	800080c0 <log+0x15c>
80007ff4:	08 95       	mov	r5,r4
80007ff6:	06 9c       	mov	r12,r3
							break;
80007ff8:	c2 38       	rjmp	8000803e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007ffa:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007ffe:	06 9a       	mov	r10,r3
80008000:	40 0b       	lddsp	r11,sp[0x0]
80008002:	5c 5b       	castu.b	r11
80008004:	68 0c       	ld.w	r12,r4[0x0]
80008006:	f0 1f 00 30 	mcall	800080c4 <log+0x160>
8000800a:	06 9c       	mov	r12,r3
							break;
8000800c:	c1 98       	rjmp	8000803e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000800e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80008012:	06 9b       	mov	r11,r3
80008014:	09 bc       	ld.ub	r12,r4[0x3]
80008016:	f0 1f 00 2d 	mcall	800080c8 <log+0x164>
8000801a:	06 9c       	mov	r12,r3
							break;
8000801c:	c1 18       	rjmp	8000803e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000801e:	e8 c5 ff fc 	sub	r5,r4,-4
80008022:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80008024:	c0 d8       	rjmp	8000803e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80008026:	06 9b       	mov	r11,r3
80008028:	32 5c       	mov	r12,37
8000802a:	f0 1f 00 28 	mcall	800080c8 <log+0x164>
8000802e:	08 95       	mov	r5,r4
80008030:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80008032:	c0 68       	rjmp	8000803e <log+0xda>
							
							default:
							log("I need relax.");
80008034:	4a 6c       	lddpc	r12,800080cc <log+0x168>
80008036:	f0 1f 00 23 	mcall	800080c0 <log+0x15c>
8000803a:	08 95       	mov	r5,r4
8000803c:	06 9c       	mov	r12,r3
						}
						str++;
8000803e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008040:	1a dc       	st.w	--sp,r12
80008042:	1a d6       	st.w	--sp,r6
80008044:	4a 3b       	lddpc	r11,800080d0 <log+0x16c>
80008046:	0c 9c       	mov	r12,r6
80008048:	f0 1f 00 23 	mcall	800080d4 <log+0x170>
8000804c:	2f ed       	sub	sp,-8
8000804e:	c0 a8       	rjmp	80008062 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008050:	2f f7       	sub	r7,-1
80008052:	1a d8       	st.w	--sp,r8
80008054:	1a d6       	st.w	--sp,r6
80008056:	4a 1b       	lddpc	r11,800080d8 <log+0x174>
80008058:	0c 9c       	mov	r12,r6
8000805a:	f0 1f 00 1f 	mcall	800080d4 <log+0x170>
8000805e:	08 95       	mov	r5,r4
80008060:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80008062:	0f 89       	ld.ub	r9,r7[0x0]
80008064:	30 08       	mov	r8,0
80008066:	f0 09 18 00 	cp.b	r9,r8
8000806a:	c0 30       	breq	80008070 <log+0x10c>
8000806c:	0a 94       	mov	r4,r5
8000806e:	c9 2b       	rjmp	80007f92 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80008070:	fa c7 fe f8 	sub	r7,sp,-264
80008074:	1a d7       	st.w	--sp,r7
80008076:	49 ab       	lddpc	r11,800080dc <log+0x178>
80008078:	0e 9c       	mov	r12,r7
8000807a:	f0 1f 00 17 	mcall	800080d4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000807e:	5c 5c       	castu.b	r12
80008080:	f8 c6 ff ff 	sub	r6,r12,-1
80008084:	0c 9c       	mov	r12,r6
80008086:	f0 1f 00 17 	mcall	800080e0 <log+0x17c>
8000808a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000808c:	0c 9a       	mov	r10,r6
8000808e:	0e 9b       	mov	r11,r7
80008090:	f0 1f 00 15 	mcall	800080e4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80008094:	30 09       	mov	r9,0
80008096:	30 5a       	mov	r10,5
80008098:	fa cb fe f8 	sub	r11,sp,-264
8000809c:	49 38       	lddpc	r8,800080e8 <log+0x184>
8000809e:	70 0c       	ld.w	r12,r8[0x0]
800080a0:	f0 1f 00 13 	mcall	800080ec <log+0x188>
800080a4:	2f fd       	sub	sp,-4
	
	
}
800080a6:	fe 3d fd f8 	sub	sp,-520
800080aa:	d8 32       	popm	r0-r7,pc
800080ac:	80 00       	ld.sh	r0,r0[0x0]
800080ae:	89 56       	st.w	r4[0x14],r6
800080b0:	00 00       	add	r0,r0
800080b2:	0d e0       	ld.ub	r0,r6[0x6]
800080b4:	80 00       	ld.sh	r0,r0[0x0]
800080b6:	ed 94       	*unknown*
800080b8:	80 00       	ld.sh	r0,r0[0x0]
800080ba:	7e 8a       	ld.w	r10,pc[0x20]
800080bc:	80 00       	ld.sh	r0,r0[0x0]
800080be:	f0 40 80 00 	cp.w	r0,-1015808
800080c2:	7f 64       	ld.w	r4,pc[0x58]
800080c4:	80 00       	ld.sh	r0,r0[0x0]
800080c6:	7d d8       	ld.w	r8,lr[0x74]
800080c8:	80 00       	ld.sh	r0,r0[0x0]
800080ca:	7d d4       	ld.w	r4,lr[0x74]
800080cc:	80 00       	ld.sh	r0,r0[0x0]
800080ce:	f0 50 80 00 	cp.w	r0,-950272
800080d2:	f0 60 80 00 	mov	r0,-1015808
800080d6:	8c 44       	ld.sh	r4,r6[0x8]
800080d8:	80 00       	ld.sh	r0,r0[0x0]
800080da:	f0 68 80 00 	mov	r8,-1015808
800080de:	f0 70 80 00 	mov	r0,-950272
800080e2:	6f d8       	ld.w	r8,r7[0x74]
800080e4:	80 00       	ld.sh	r0,r0[0x0]
800080e6:	88 0e       	ld.sh	lr,r4[0x0]
800080e8:	00 00       	add	r0,r0
800080ea:	bd 44       	asr	r4,0x1c
800080ec:	80 00       	ld.sh	r0,r0[0x0]
800080ee:	73 2c       	ld.w	r12,r9[0x48]

800080f0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800080f0:	d4 31       	pushm	r0-r7,lr
800080f2:	fa cd 02 0c 	sub	sp,sp,524
800080f6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800080f8:	e0 6a 01 00 	mov	r10,256
800080fc:	30 0b       	mov	r11,0
800080fe:	fa cc fe f4 	sub	r12,sp,-268
80008102:	f0 1f 00 4c 	mcall	80008230 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80008106:	fa c4 fd d0 	sub	r4,sp,-560
8000810a:	30 0a       	mov	r10,0
8000810c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000810e:	fa c3 ff fc 	sub	r3,sp,-4
80008112:	e0 61 01 00 	mov	r1,256
80008116:	14 90       	mov	r0,r10
			
			if(*str == '%')
80008118:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000811a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000811e:	02 9a       	mov	r10,r1
80008120:	00 9b       	mov	r11,r0
80008122:	06 9c       	mov	r12,r3
80008124:	f0 1f 00 43 	mcall	80008230 <logFromISR+0x140>
			
			if(*str == '%')
80008128:	0f 88       	ld.ub	r8,r7[0x0]
8000812a:	e4 08 18 00 	cp.b	r8,r2
8000812e:	c5 11       	brne	800081d0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80008130:	ee c8 ff ff 	sub	r8,r7,-1
80008134:	11 89       	ld.ub	r9,r8[0x0]
80008136:	4c 0a       	lddpc	r10,80008234 <logFromISR+0x144>
80008138:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000813a:	23 09       	sub	r9,48
8000813c:	30 9a       	mov	r10,9
8000813e:	f4 09 18 00 	cp.b	r9,r10
80008142:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80008146:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000814a:	f7 b9 08 30 	subls	r9,48
8000814e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80008152:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80008156:	0f 88       	ld.ub	r8,r7[0x0]
80008158:	22 58       	sub	r8,37
8000815a:	e0 48 00 53 	cp.w	r8,83
8000815e:	e0 8b 00 2b 	brhi	800081b4 <logFromISR+0xc4>
80008162:	4b 69       	lddpc	r9,80008238 <logFromISR+0x148>
80008164:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80008168:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000816c:	06 9a       	mov	r10,r3
8000816e:	40 0b       	lddsp	r11,sp[0x0]
80008170:	5c 5b       	castu.b	r11
80008172:	68 0c       	ld.w	r12,r4[0x0]
80008174:	f0 1f 00 32 	mcall	8000823c <logFromISR+0x14c>
					break;
80008178:	c2 38       	rjmp	800081be <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000817a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000817e:	06 9a       	mov	r10,r3
80008180:	40 0b       	lddsp	r11,sp[0x0]
80008182:	5c 5b       	castu.b	r11
80008184:	68 0c       	ld.w	r12,r4[0x0]
80008186:	f0 1f 00 2f 	mcall	80008240 <logFromISR+0x150>
8000818a:	06 9c       	mov	r12,r3
					break;
8000818c:	c1 98       	rjmp	800081be <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000818e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80008192:	06 9b       	mov	r11,r3
80008194:	09 bc       	ld.ub	r12,r4[0x3]
80008196:	f0 1f 00 2c 	mcall	80008244 <logFromISR+0x154>
8000819a:	06 9c       	mov	r12,r3
					break;
8000819c:	c1 18       	rjmp	800081be <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000819e:	e8 c5 ff fc 	sub	r5,r4,-4
800081a2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800081a4:	c0 d8       	rjmp	800081be <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800081a6:	06 9b       	mov	r11,r3
800081a8:	32 5c       	mov	r12,37
800081aa:	f0 1f 00 27 	mcall	80008244 <logFromISR+0x154>
800081ae:	08 95       	mov	r5,r4
800081b0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800081b2:	c0 68       	rjmp	800081be <logFromISR+0xce>
					default:
					log("I need relax.");
800081b4:	4a 5c       	lddpc	r12,80008248 <logFromISR+0x158>
800081b6:	f0 1f 00 26 	mcall	8000824c <logFromISR+0x15c>
800081ba:	08 95       	mov	r5,r4
800081bc:	06 9c       	mov	r12,r3
				}
				str++;
800081be:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800081c0:	1a dc       	st.w	--sp,r12
800081c2:	1a d6       	st.w	--sp,r6
800081c4:	4a 3b       	lddpc	r11,80008250 <logFromISR+0x160>
800081c6:	0c 9c       	mov	r12,r6
800081c8:	f0 1f 00 23 	mcall	80008254 <logFromISR+0x164>
800081cc:	2f ed       	sub	sp,-8
800081ce:	c0 a8       	rjmp	800081e2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800081d0:	2f f7       	sub	r7,-1
800081d2:	1a d8       	st.w	--sp,r8
800081d4:	1a d6       	st.w	--sp,r6
800081d6:	4a 1b       	lddpc	r11,80008258 <logFromISR+0x168>
800081d8:	0c 9c       	mov	r12,r6
800081da:	f0 1f 00 1f 	mcall	80008254 <logFromISR+0x164>
800081de:	08 95       	mov	r5,r4
800081e0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800081e2:	0f 89       	ld.ub	r9,r7[0x0]
800081e4:	30 08       	mov	r8,0
800081e6:	f0 09 18 00 	cp.b	r9,r8
800081ea:	c0 30       	breq	800081f0 <logFromISR+0x100>
800081ec:	0a 94       	mov	r4,r5
800081ee:	c9 8b       	rjmp	8000811e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800081f0:	fa c7 fe f4 	sub	r7,sp,-268
800081f4:	1a d7       	st.w	--sp,r7
800081f6:	49 ab       	lddpc	r11,8000825c <logFromISR+0x16c>
800081f8:	0e 9c       	mov	r12,r7
800081fa:	f0 1f 00 17 	mcall	80008254 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800081fe:	5c 5c       	castu.b	r12
80008200:	f8 c6 ff ff 	sub	r6,r12,-1
80008204:	0c 9c       	mov	r12,r6
80008206:	f0 1f 00 17 	mcall	80008260 <logFromISR+0x170>
8000820a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000820c:	0c 9a       	mov	r10,r6
8000820e:	0e 9b       	mov	r11,r7
80008210:	f0 1f 00 15 	mcall	80008264 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80008214:	30 09       	mov	r9,0
80008216:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80008218:	fa ca fe f8 	sub	r10,sp,-264
8000821c:	fa cb fe f4 	sub	r11,sp,-268
80008220:	49 28       	lddpc	r8,80008268 <logFromISR+0x178>
80008222:	70 0c       	ld.w	r12,r8[0x0]
80008224:	f0 1f 00 12 	mcall	8000826c <logFromISR+0x17c>
80008228:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000822a:	fe 3d fd f4 	sub	sp,-524
8000822e:	d8 32       	popm	r0-r7,pc
80008230:	80 00       	ld.sh	r0,r0[0x0]
80008232:	89 56       	st.w	r4[0x14],r6
80008234:	00 00       	add	r0,r0
80008236:	0d e1       	ld.ub	r1,r6[0x6]
80008238:	80 00       	ld.sh	r0,r0[0x0]
8000823a:	ee e4 80 00 	ld.d	r4,r7[-32768]
8000823e:	7e 8a       	ld.w	r10,pc[0x20]
80008240:	80 00       	ld.sh	r0,r0[0x0]
80008242:	7d d8       	ld.w	r8,lr[0x74]
80008244:	80 00       	ld.sh	r0,r0[0x0]
80008246:	7d d4       	ld.w	r4,lr[0x74]
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	f0 50 80 00 	cp.w	r0,-950272
8000824e:	7f 64       	ld.w	r4,pc[0x58]
80008250:	80 00       	ld.sh	r0,r0[0x0]
80008252:	f0 60 80 00 	mov	r0,-1015808
80008256:	8c 44       	ld.sh	r4,r6[0x8]
80008258:	80 00       	ld.sh	r0,r0[0x0]
8000825a:	f0 68 80 00 	mov	r8,-1015808
8000825e:	f0 70 80 00 	mov	r0,-950272
80008262:	6f d8       	ld.w	r8,r7[0x74]
80008264:	80 00       	ld.sh	r0,r0[0x0]
80008266:	88 0e       	ld.sh	lr,r4[0x0]
80008268:	00 00       	add	r0,r0
8000826a:	bd 44       	asr	r4,0x1c
8000826c:	80 00       	ld.sh	r0,r0[0x0]
8000826e:	72 dc       	ld.w	r12,r9[0x34]

80008270 <log_init>:
		
	return str;
}

void log_init(void)
{
80008270:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80008272:	30 2b       	mov	r11,2
80008274:	48 fc       	lddpc	r12,800082b0 <log_init+0x40>
80008276:	f0 1f 00 10 	mcall	800082b4 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000827a:	e0 6a 36 00 	mov	r10,13824
8000827e:	ea 1a 01 6e 	orh	r10,0x16e
80008282:	48 eb       	lddpc	r11,800082b8 <log_init+0x48>
80008284:	fe 7c 18 00 	mov	r12,-59392
80008288:	f0 1f 00 0d 	mcall	800082bc <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000828c:	30 4b       	mov	r11,4
8000828e:	33 2c       	mov	r12,50
80008290:	f0 1f 00 0c 	mcall	800082c0 <log_init+0x50>
80008294:	48 c8       	lddpc	r8,800082c4 <log_init+0x54>
80008296:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80008298:	30 09       	mov	r9,0
8000829a:	1a d9       	st.w	--sp,r9
8000829c:	1a d9       	st.w	--sp,r9
8000829e:	1a d9       	st.w	--sp,r9
800082a0:	30 28       	mov	r8,2
800082a2:	36 4a       	mov	r10,100
800082a4:	48 9b       	lddpc	r11,800082c8 <log_init+0x58>
800082a6:	48 ac       	lddpc	r12,800082cc <log_init+0x5c>
800082a8:	f0 1f 00 0a 	mcall	800082d0 <log_init+0x60>
800082ac:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800082ae:	d8 02       	popm	pc
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	f0 7c 80 00 	mov	r12,-950272
800082b6:	63 48       	ld.w	r8,r1[0x50]
800082b8:	80 00       	ld.sh	r0,r0[0x0]
800082ba:	f0 34 80 00 	sub	r4,-950272
800082be:	6b 3c       	ld.w	r12,r5[0x4c]
800082c0:	80 00       	ld.sh	r0,r0[0x0]
800082c2:	74 84       	ld.w	r4,r10[0x20]
800082c4:	00 00       	add	r0,r0
800082c6:	bd 44       	asr	r4,0x1c
800082c8:	80 00       	ld.sh	r0,r0[0x0]
800082ca:	f0 78 80 00 	mov	r8,-950272
800082ce:	82 d4       	ld.uh	r4,r1[0xa]
800082d0:	80 00       	ld.sh	r0,r0[0x0]
800082d2:	7b a0       	ld.w	r0,sp[0x68]

800082d4 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800082d4:	eb cd 40 f8 	pushm	r3-r7,lr
800082d8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082da:	48 c7       	lddpc	r7,80008308 <task_log+0x34>
800082dc:	30 05       	mov	r5,0
800082de:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800082e0:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082e4:	0a 99       	mov	r9,r5
800082e6:	08 9a       	mov	r10,r4
800082e8:	1a 9b       	mov	r11,sp
800082ea:	6e 0c       	ld.w	r12,r7[0x0]
800082ec:	f0 1f 00 08 	mcall	8000830c <task_log+0x38>
800082f0:	58 1c       	cp.w	r12,1
800082f2:	cf 91       	brne	800082e4 <task_log+0x10>
		{
			if( NULL != str)
800082f4:	40 0b       	lddsp	r11,sp[0x0]
800082f6:	58 0b       	cp.w	r11,0
800082f8:	cf 60       	breq	800082e4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800082fa:	06 9c       	mov	r12,r3
800082fc:	f0 1f 00 05 	mcall	80008310 <task_log+0x3c>
				vPortFree(str);
80008300:	40 0c       	lddsp	r12,sp[0x0]
80008302:	f0 1f 00 05 	mcall	80008314 <task_log+0x40>
80008306:	ce fb       	rjmp	800082e4 <task_log+0x10>
80008308:	00 00       	add	r0,r0
8000830a:	bd 44       	asr	r4,0x1c
8000830c:	80 00       	ld.sh	r0,r0[0x0]
8000830e:	71 20       	ld.w	r0,r8[0x48]
80008310:	80 00       	ld.sh	r0,r0[0x0]
80008312:	6a ec       	ld.w	r12,r5[0x38]
80008314:	80 00       	ld.sh	r0,r0[0x0]
80008316:	6f b0       	ld.w	r0,r7[0x6c]

80008318 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80008318:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000831a:	fe 78 10 00 	mov	r8,-61440
8000831e:	30 19       	mov	r9,1
80008320:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80008324:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80008328:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000832c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000832e:	f0 1f 00 0d 	mcall	80008360 <main+0x48>
		
	INTC_init_interrupts();
80008332:	f0 1f 00 0d 	mcall	80008364 <main+0x4c>
		
	log_init();
80008336:	f0 1f 00 0d 	mcall	80008368 <main+0x50>
	log("----start debug----");
8000833a:	48 dc       	lddpc	r12,8000836c <main+0x54>
8000833c:	f0 1f 00 0d 	mcall	80008370 <main+0x58>
	
	xg_flashc_init();
80008340:	f0 1f 00 0d 	mcall	80008374 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80008344:	f0 1f 00 0d 	mcall	80008378 <main+0x60>
		
	app_init();
80008348:	f0 1f 00 0d 	mcall	8000837c <main+0x64>
	
	xg_rtc_init();
8000834c:	f0 1f 00 0d 	mcall	80008380 <main+0x68>
		
	xcmp_init();
80008350:	f0 1f 00 0d 	mcall	80008384 <main+0x6c>

	local_start_timer();
80008354:	f0 1f 00 0d 	mcall	80008388 <main+0x70>
		
	vTaskStartScheduler();
80008358:	f0 1f 00 0d 	mcall	8000838c <main+0x74>
	return 0;
	
}
8000835c:	d8 0a       	popm	pc,r12=0
8000835e:	00 00       	add	r0,r0
80008360:	80 00       	ld.sh	r0,r0[0x0]
80008362:	5c 84       	casts.h	r4
80008364:	80 00       	ld.sh	r0,r0[0x0]
80008366:	64 4c       	ld.w	r12,r2[0x10]
80008368:	80 00       	ld.sh	r0,r0[0x0]
8000836a:	82 70       	ld.sh	r0,r1[0xe]
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	f0 8c 80 00 	brvs	7fe1836e <_estack+0x7fe0036e>
80008372:	7f 64       	ld.w	r4,pc[0x58]
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	5d 18       	icall	r8
80008378:	80 00       	ld.sh	r0,r0[0x0]
8000837a:	5b e4       	cp.w	r4,-2
8000837c:	80 00       	ld.sh	r0,r0[0x0]
8000837e:	27 28       	sub	r8,114
80008380:	80 00       	ld.sh	r0,r0[0x0]
80008382:	33 38       	mov	r8,51
80008384:	80 00       	ld.sh	r0,r0[0x0]
80008386:	4a 0c       	lddpc	r12,80008404 <_malloc_r+0x54>
80008388:	80 00       	ld.sh	r0,r0[0x0]
8000838a:	5c 58       	castu.b	r8
8000838c:	80 00       	ld.sh	r0,r0[0x0]
8000838e:	7d 88       	ld.w	r8,lr[0x60]

80008390 <free>:
80008390:	d4 01       	pushm	lr
80008392:	e0 68 0a 54 	mov	r8,2644
80008396:	18 9b       	mov	r11,r12
80008398:	70 0c       	ld.w	r12,r8[0x0]
8000839a:	e0 a0 1e 73 	rcall	8000c080 <_free_r>
8000839e:	d8 02       	popm	pc

800083a0 <malloc>:
800083a0:	d4 01       	pushm	lr
800083a2:	e0 68 0a 54 	mov	r8,2644
800083a6:	18 9b       	mov	r11,r12
800083a8:	70 0c       	ld.w	r12,r8[0x0]
800083aa:	c0 3c       	rcall	800083b0 <_malloc_r>
800083ac:	d8 02       	popm	pc
800083ae:	d7 03       	nop

800083b0 <_malloc_r>:
800083b0:	d4 31       	pushm	r0-r7,lr
800083b2:	f6 c8 ff f5 	sub	r8,r11,-11
800083b6:	18 95       	mov	r5,r12
800083b8:	10 97       	mov	r7,r8
800083ba:	e0 17 ff f8 	andl	r7,0xfff8
800083be:	59 68       	cp.w	r8,22
800083c0:	f9 b7 08 10 	movls	r7,16
800083c4:	16 37       	cp.w	r7,r11
800083c6:	5f 38       	srlo	r8
800083c8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800083cc:	c0 50       	breq	800083d6 <_malloc_r+0x26>
800083ce:	30 c8       	mov	r8,12
800083d0:	99 38       	st.w	r12[0xc],r8
800083d2:	e0 8f 01 fa 	bral	800087c6 <_malloc_r+0x416>
800083d6:	fe b0 f5 a3 	rcall	80006f1c <__malloc_lock>
800083da:	e0 47 01 f7 	cp.w	r7,503
800083de:	e0 8b 00 1d 	brhi	80008418 <_malloc_r+0x68>
800083e2:	ee 03 16 03 	lsr	r3,r7,0x3
800083e6:	e0 68 05 54 	mov	r8,1364
800083ea:	f0 03 00 38 	add	r8,r8,r3<<0x3
800083ee:	70 36       	ld.w	r6,r8[0xc]
800083f0:	10 36       	cp.w	r6,r8
800083f2:	c0 61       	brne	800083fe <_malloc_r+0x4e>
800083f4:	ec c8 ff f8 	sub	r8,r6,-8
800083f8:	70 36       	ld.w	r6,r8[0xc]
800083fa:	10 36       	cp.w	r6,r8
800083fc:	c0 c0       	breq	80008414 <_malloc_r+0x64>
800083fe:	6c 18       	ld.w	r8,r6[0x4]
80008400:	e0 18 ff fc 	andl	r8,0xfffc
80008404:	6c 3a       	ld.w	r10,r6[0xc]
80008406:	ec 08 00 09 	add	r9,r6,r8
8000840a:	0a 9c       	mov	r12,r5
8000840c:	6c 28       	ld.w	r8,r6[0x8]
8000840e:	95 28       	st.w	r10[0x8],r8
80008410:	91 3a       	st.w	r8[0xc],r10
80008412:	c4 78       	rjmp	800084a0 <_malloc_r+0xf0>
80008414:	2f e3       	sub	r3,-2
80008416:	c4 d8       	rjmp	800084b0 <_malloc_r+0x100>
80008418:	ee 03 16 09 	lsr	r3,r7,0x9
8000841c:	c0 41       	brne	80008424 <_malloc_r+0x74>
8000841e:	ee 03 16 03 	lsr	r3,r7,0x3
80008422:	c2 68       	rjmp	8000846e <_malloc_r+0xbe>
80008424:	58 43       	cp.w	r3,4
80008426:	e0 8b 00 06 	brhi	80008432 <_malloc_r+0x82>
8000842a:	ee 03 16 06 	lsr	r3,r7,0x6
8000842e:	2c 83       	sub	r3,-56
80008430:	c1 f8       	rjmp	8000846e <_malloc_r+0xbe>
80008432:	59 43       	cp.w	r3,20
80008434:	e0 8b 00 04 	brhi	8000843c <_malloc_r+0x8c>
80008438:	2a 53       	sub	r3,-91
8000843a:	c1 a8       	rjmp	8000846e <_malloc_r+0xbe>
8000843c:	e0 43 00 54 	cp.w	r3,84
80008440:	e0 8b 00 06 	brhi	8000844c <_malloc_r+0x9c>
80008444:	ee 03 16 0c 	lsr	r3,r7,0xc
80008448:	29 23       	sub	r3,-110
8000844a:	c1 28       	rjmp	8000846e <_malloc_r+0xbe>
8000844c:	e0 43 01 54 	cp.w	r3,340
80008450:	e0 8b 00 06 	brhi	8000845c <_malloc_r+0xac>
80008454:	ee 03 16 0f 	lsr	r3,r7,0xf
80008458:	28 93       	sub	r3,-119
8000845a:	c0 a8       	rjmp	8000846e <_malloc_r+0xbe>
8000845c:	e0 43 05 54 	cp.w	r3,1364
80008460:	e0 88 00 04 	brls	80008468 <_malloc_r+0xb8>
80008464:	37 e3       	mov	r3,126
80008466:	c0 48       	rjmp	8000846e <_malloc_r+0xbe>
80008468:	ee 03 16 12 	lsr	r3,r7,0x12
8000846c:	28 43       	sub	r3,-124
8000846e:	e0 6a 05 54 	mov	r10,1364
80008472:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80008476:	74 36       	ld.w	r6,r10[0xc]
80008478:	c1 98       	rjmp	800084aa <_malloc_r+0xfa>
8000847a:	6c 19       	ld.w	r9,r6[0x4]
8000847c:	e0 19 ff fc 	andl	r9,0xfffc
80008480:	f2 07 01 0b 	sub	r11,r9,r7
80008484:	58 fb       	cp.w	r11,15
80008486:	e0 8a 00 04 	brle	8000848e <_malloc_r+0xde>
8000848a:	20 13       	sub	r3,1
8000848c:	c1 18       	rjmp	800084ae <_malloc_r+0xfe>
8000848e:	6c 38       	ld.w	r8,r6[0xc]
80008490:	58 0b       	cp.w	r11,0
80008492:	c0 b5       	brlt	800084a8 <_malloc_r+0xf8>
80008494:	6c 2a       	ld.w	r10,r6[0x8]
80008496:	ec 09 00 09 	add	r9,r6,r9
8000849a:	0a 9c       	mov	r12,r5
8000849c:	91 2a       	st.w	r8[0x8],r10
8000849e:	95 38       	st.w	r10[0xc],r8
800084a0:	72 18       	ld.w	r8,r9[0x4]
800084a2:	a1 a8       	sbr	r8,0x0
800084a4:	93 18       	st.w	r9[0x4],r8
800084a6:	cb c8       	rjmp	8000861e <_malloc_r+0x26e>
800084a8:	10 96       	mov	r6,r8
800084aa:	14 36       	cp.w	r6,r10
800084ac:	ce 71       	brne	8000847a <_malloc_r+0xca>
800084ae:	2f f3       	sub	r3,-1
800084b0:	e0 6a 05 54 	mov	r10,1364
800084b4:	f4 cc ff f8 	sub	r12,r10,-8
800084b8:	78 26       	ld.w	r6,r12[0x8]
800084ba:	18 36       	cp.w	r6,r12
800084bc:	c6 c0       	breq	80008594 <_malloc_r+0x1e4>
800084be:	6c 19       	ld.w	r9,r6[0x4]
800084c0:	e0 19 ff fc 	andl	r9,0xfffc
800084c4:	f2 07 01 08 	sub	r8,r9,r7
800084c8:	58 f8       	cp.w	r8,15
800084ca:	e0 89 00 8f 	brgt	800085e8 <_malloc_r+0x238>
800084ce:	99 3c       	st.w	r12[0xc],r12
800084d0:	99 2c       	st.w	r12[0x8],r12
800084d2:	58 08       	cp.w	r8,0
800084d4:	c0 55       	brlt	800084de <_malloc_r+0x12e>
800084d6:	ec 09 00 09 	add	r9,r6,r9
800084da:	0a 9c       	mov	r12,r5
800084dc:	ce 2b       	rjmp	800084a0 <_malloc_r+0xf0>
800084de:	e0 49 01 ff 	cp.w	r9,511
800084e2:	e0 8b 00 13 	brhi	80008508 <_malloc_r+0x158>
800084e6:	a3 99       	lsr	r9,0x3
800084e8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800084ec:	70 2b       	ld.w	r11,r8[0x8]
800084ee:	8d 38       	st.w	r6[0xc],r8
800084f0:	8d 2b       	st.w	r6[0x8],r11
800084f2:	97 36       	st.w	r11[0xc],r6
800084f4:	91 26       	st.w	r8[0x8],r6
800084f6:	a3 49       	asr	r9,0x2
800084f8:	74 18       	ld.w	r8,r10[0x4]
800084fa:	30 1b       	mov	r11,1
800084fc:	f6 09 09 49 	lsl	r9,r11,r9
80008500:	f1 e9 10 09 	or	r9,r8,r9
80008504:	95 19       	st.w	r10[0x4],r9
80008506:	c4 78       	rjmp	80008594 <_malloc_r+0x1e4>
80008508:	f2 0a 16 09 	lsr	r10,r9,0x9
8000850c:	58 4a       	cp.w	r10,4
8000850e:	e0 8b 00 07 	brhi	8000851c <_malloc_r+0x16c>
80008512:	f2 0a 16 06 	lsr	r10,r9,0x6
80008516:	2c 8a       	sub	r10,-56
80008518:	c2 08       	rjmp	80008558 <_malloc_r+0x1a8>
8000851a:	d7 03       	nop
8000851c:	59 4a       	cp.w	r10,20
8000851e:	e0 8b 00 04 	brhi	80008526 <_malloc_r+0x176>
80008522:	2a 5a       	sub	r10,-91
80008524:	c1 a8       	rjmp	80008558 <_malloc_r+0x1a8>
80008526:	e0 4a 00 54 	cp.w	r10,84
8000852a:	e0 8b 00 06 	brhi	80008536 <_malloc_r+0x186>
8000852e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80008532:	29 2a       	sub	r10,-110
80008534:	c1 28       	rjmp	80008558 <_malloc_r+0x1a8>
80008536:	e0 4a 01 54 	cp.w	r10,340
8000853a:	e0 8b 00 06 	brhi	80008546 <_malloc_r+0x196>
8000853e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80008542:	28 9a       	sub	r10,-119
80008544:	c0 a8       	rjmp	80008558 <_malloc_r+0x1a8>
80008546:	e0 4a 05 54 	cp.w	r10,1364
8000854a:	e0 88 00 04 	brls	80008552 <_malloc_r+0x1a2>
8000854e:	37 ea       	mov	r10,126
80008550:	c0 48       	rjmp	80008558 <_malloc_r+0x1a8>
80008552:	f2 0a 16 12 	lsr	r10,r9,0x12
80008556:	28 4a       	sub	r10,-124
80008558:	e0 6b 05 54 	mov	r11,1364
8000855c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80008560:	68 28       	ld.w	r8,r4[0x8]
80008562:	08 38       	cp.w	r8,r4
80008564:	c0 e1       	brne	80008580 <_malloc_r+0x1d0>
80008566:	76 19       	ld.w	r9,r11[0x4]
80008568:	a3 4a       	asr	r10,0x2
8000856a:	30 1e       	mov	lr,1
8000856c:	fc 0a 09 4a 	lsl	r10,lr,r10
80008570:	f3 ea 10 0a 	or	r10,r9,r10
80008574:	10 99       	mov	r9,r8
80008576:	97 1a       	st.w	r11[0x4],r10
80008578:	c0 a8       	rjmp	8000858c <_malloc_r+0x1dc>
8000857a:	70 28       	ld.w	r8,r8[0x8]
8000857c:	08 38       	cp.w	r8,r4
8000857e:	c0 60       	breq	8000858a <_malloc_r+0x1da>
80008580:	70 1a       	ld.w	r10,r8[0x4]
80008582:	e0 1a ff fc 	andl	r10,0xfffc
80008586:	14 39       	cp.w	r9,r10
80008588:	cf 93       	brcs	8000857a <_malloc_r+0x1ca>
8000858a:	70 39       	ld.w	r9,r8[0xc]
8000858c:	8d 39       	st.w	r6[0xc],r9
8000858e:	8d 28       	st.w	r6[0x8],r8
80008590:	91 36       	st.w	r8[0xc],r6
80008592:	93 26       	st.w	r9[0x8],r6
80008594:	e6 08 14 02 	asr	r8,r3,0x2
80008598:	30 1b       	mov	r11,1
8000859a:	e0 64 05 54 	mov	r4,1364
8000859e:	f6 08 09 4b 	lsl	r11,r11,r8
800085a2:	68 18       	ld.w	r8,r4[0x4]
800085a4:	10 3b       	cp.w	r11,r8
800085a6:	e0 8b 00 6b 	brhi	8000867c <_malloc_r+0x2cc>
800085aa:	f7 e8 00 09 	and	r9,r11,r8
800085ae:	c0 b1       	brne	800085c4 <_malloc_r+0x214>
800085b0:	e0 13 ff fc 	andl	r3,0xfffc
800085b4:	a1 7b       	lsl	r11,0x1
800085b6:	2f c3       	sub	r3,-4
800085b8:	c0 38       	rjmp	800085be <_malloc_r+0x20e>
800085ba:	2f c3       	sub	r3,-4
800085bc:	a1 7b       	lsl	r11,0x1
800085be:	f7 e8 00 09 	and	r9,r11,r8
800085c2:	cf c0       	breq	800085ba <_malloc_r+0x20a>
800085c4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800085c8:	06 92       	mov	r2,r3
800085ca:	1c 91       	mov	r1,lr
800085cc:	62 36       	ld.w	r6,r1[0xc]
800085ce:	c2 e8       	rjmp	8000862a <_malloc_r+0x27a>
800085d0:	6c 1a       	ld.w	r10,r6[0x4]
800085d2:	e0 1a ff fc 	andl	r10,0xfffc
800085d6:	f4 07 01 08 	sub	r8,r10,r7
800085da:	58 f8       	cp.w	r8,15
800085dc:	e0 8a 00 15 	brle	80008606 <_malloc_r+0x256>
800085e0:	6c 3a       	ld.w	r10,r6[0xc]
800085e2:	6c 29       	ld.w	r9,r6[0x8]
800085e4:	95 29       	st.w	r10[0x8],r9
800085e6:	93 3a       	st.w	r9[0xc],r10
800085e8:	0e 99       	mov	r9,r7
800085ea:	ec 07 00 07 	add	r7,r6,r7
800085ee:	a1 a9       	sbr	r9,0x0
800085f0:	99 37       	st.w	r12[0xc],r7
800085f2:	99 27       	st.w	r12[0x8],r7
800085f4:	8d 19       	st.w	r6[0x4],r9
800085f6:	ee 08 09 08 	st.w	r7[r8],r8
800085fa:	8f 2c       	st.w	r7[0x8],r12
800085fc:	8f 3c       	st.w	r7[0xc],r12
800085fe:	a1 a8       	sbr	r8,0x0
80008600:	0a 9c       	mov	r12,r5
80008602:	8f 18       	st.w	r7[0x4],r8
80008604:	c0 d8       	rjmp	8000861e <_malloc_r+0x26e>
80008606:	6c 39       	ld.w	r9,r6[0xc]
80008608:	58 08       	cp.w	r8,0
8000860a:	c0 f5       	brlt	80008628 <_malloc_r+0x278>
8000860c:	ec 0a 00 0a 	add	r10,r6,r10
80008610:	74 18       	ld.w	r8,r10[0x4]
80008612:	a1 a8       	sbr	r8,0x0
80008614:	0a 9c       	mov	r12,r5
80008616:	95 18       	st.w	r10[0x4],r8
80008618:	6c 28       	ld.w	r8,r6[0x8]
8000861a:	93 28       	st.w	r9[0x8],r8
8000861c:	91 39       	st.w	r8[0xc],r9
8000861e:	fe b0 f4 85 	rcall	80006f28 <__malloc_unlock>
80008622:	ec cc ff f8 	sub	r12,r6,-8
80008626:	d8 32       	popm	r0-r7,pc
80008628:	12 96       	mov	r6,r9
8000862a:	02 36       	cp.w	r6,r1
8000862c:	cd 21       	brne	800085d0 <_malloc_r+0x220>
8000862e:	2f f2       	sub	r2,-1
80008630:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008634:	c0 30       	breq	8000863a <_malloc_r+0x28a>
80008636:	2f 81       	sub	r1,-8
80008638:	cc ab       	rjmp	800085cc <_malloc_r+0x21c>
8000863a:	1c 98       	mov	r8,lr
8000863c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80008640:	c0 81       	brne	80008650 <_malloc_r+0x2a0>
80008642:	68 19       	ld.w	r9,r4[0x4]
80008644:	f6 08 11 ff 	rsub	r8,r11,-1
80008648:	f3 e8 00 08 	and	r8,r9,r8
8000864c:	89 18       	st.w	r4[0x4],r8
8000864e:	c0 78       	rjmp	8000865c <_malloc_r+0x2ac>
80008650:	f0 c9 00 08 	sub	r9,r8,8
80008654:	20 13       	sub	r3,1
80008656:	70 08       	ld.w	r8,r8[0x0]
80008658:	12 38       	cp.w	r8,r9
8000865a:	cf 10       	breq	8000863c <_malloc_r+0x28c>
8000865c:	a1 7b       	lsl	r11,0x1
8000865e:	68 18       	ld.w	r8,r4[0x4]
80008660:	10 3b       	cp.w	r11,r8
80008662:	e0 8b 00 0d 	brhi	8000867c <_malloc_r+0x2cc>
80008666:	58 0b       	cp.w	r11,0
80008668:	c0 a0       	breq	8000867c <_malloc_r+0x2cc>
8000866a:	04 93       	mov	r3,r2
8000866c:	c0 38       	rjmp	80008672 <_malloc_r+0x2c2>
8000866e:	2f c3       	sub	r3,-4
80008670:	a1 7b       	lsl	r11,0x1
80008672:	f7 e8 00 09 	and	r9,r11,r8
80008676:	ca 71       	brne	800085c4 <_malloc_r+0x214>
80008678:	cf bb       	rjmp	8000866e <_malloc_r+0x2be>
8000867a:	d7 03       	nop
8000867c:	68 23       	ld.w	r3,r4[0x8]
8000867e:	66 12       	ld.w	r2,r3[0x4]
80008680:	e0 12 ff fc 	andl	r2,0xfffc
80008684:	0e 32       	cp.w	r2,r7
80008686:	5f 39       	srlo	r9
80008688:	e4 07 01 08 	sub	r8,r2,r7
8000868c:	58 f8       	cp.w	r8,15
8000868e:	5f aa       	srle	r10
80008690:	f5 e9 10 09 	or	r9,r10,r9
80008694:	e0 80 00 9a 	breq	800087c8 <_malloc_r+0x418>
80008698:	e0 68 0d ec 	mov	r8,3564
8000869c:	70 01       	ld.w	r1,r8[0x0]
8000869e:	e0 68 09 60 	mov	r8,2400
800086a2:	2f 01       	sub	r1,-16
800086a4:	70 08       	ld.w	r8,r8[0x0]
800086a6:	0e 01       	add	r1,r7
800086a8:	5b f8       	cp.w	r8,-1
800086aa:	c0 40       	breq	800086b2 <_malloc_r+0x302>
800086ac:	28 11       	sub	r1,-127
800086ae:	e0 11 ff 80 	andl	r1,0xff80
800086b2:	02 9b       	mov	r11,r1
800086b4:	0a 9c       	mov	r12,r5
800086b6:	e0 a0 02 b7 	rcall	80008c24 <_sbrk_r>
800086ba:	18 96       	mov	r6,r12
800086bc:	5b fc       	cp.w	r12,-1
800086be:	c7 50       	breq	800087a8 <_malloc_r+0x3f8>
800086c0:	e6 02 00 08 	add	r8,r3,r2
800086c4:	10 3c       	cp.w	r12,r8
800086c6:	c0 32       	brcc	800086cc <_malloc_r+0x31c>
800086c8:	08 33       	cp.w	r3,r4
800086ca:	c6 f1       	brne	800087a8 <_malloc_r+0x3f8>
800086cc:	e0 6a 0d f0 	mov	r10,3568
800086d0:	74 09       	ld.w	r9,r10[0x0]
800086d2:	e2 09 00 09 	add	r9,r1,r9
800086d6:	95 09       	st.w	r10[0x0],r9
800086d8:	10 36       	cp.w	r6,r8
800086da:	c0 a1       	brne	800086ee <_malloc_r+0x33e>
800086dc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800086e0:	c0 71       	brne	800086ee <_malloc_r+0x33e>
800086e2:	e2 02 00 02 	add	r2,r1,r2
800086e6:	68 28       	ld.w	r8,r4[0x8]
800086e8:	a1 a2       	sbr	r2,0x0
800086ea:	91 12       	st.w	r8[0x4],r2
800086ec:	c4 f8       	rjmp	8000878a <_malloc_r+0x3da>
800086ee:	e0 6a 09 60 	mov	r10,2400
800086f2:	74 0b       	ld.w	r11,r10[0x0]
800086f4:	5b fb       	cp.w	r11,-1
800086f6:	c0 31       	brne	800086fc <_malloc_r+0x34c>
800086f8:	95 06       	st.w	r10[0x0],r6
800086fa:	c0 78       	rjmp	80008708 <_malloc_r+0x358>
800086fc:	ec 09 00 09 	add	r9,r6,r9
80008700:	e0 6a 0d f0 	mov	r10,3568
80008704:	10 19       	sub	r9,r8
80008706:	95 09       	st.w	r10[0x0],r9
80008708:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000870c:	f0 09 11 08 	rsub	r9,r8,8
80008710:	58 08       	cp.w	r8,0
80008712:	f2 08 17 10 	movne	r8,r9
80008716:	ed d8 e1 06 	addne	r6,r6,r8
8000871a:	28 08       	sub	r8,-128
8000871c:	ec 01 00 01 	add	r1,r6,r1
80008720:	0a 9c       	mov	r12,r5
80008722:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80008726:	f0 01 01 01 	sub	r1,r8,r1
8000872a:	02 9b       	mov	r11,r1
8000872c:	e0 a0 02 7c 	rcall	80008c24 <_sbrk_r>
80008730:	e0 68 0d f0 	mov	r8,3568
80008734:	5b fc       	cp.w	r12,-1
80008736:	ec 0c 17 00 	moveq	r12,r6
8000873a:	f9 b1 00 00 	moveq	r1,0
8000873e:	70 09       	ld.w	r9,r8[0x0]
80008740:	0c 1c       	sub	r12,r6
80008742:	89 26       	st.w	r4[0x8],r6
80008744:	02 0c       	add	r12,r1
80008746:	12 01       	add	r1,r9
80008748:	a1 ac       	sbr	r12,0x0
8000874a:	91 01       	st.w	r8[0x0],r1
8000874c:	8d 1c       	st.w	r6[0x4],r12
8000874e:	08 33       	cp.w	r3,r4
80008750:	c1 d0       	breq	8000878a <_malloc_r+0x3da>
80008752:	58 f2       	cp.w	r2,15
80008754:	e0 8b 00 05 	brhi	8000875e <_malloc_r+0x3ae>
80008758:	30 18       	mov	r8,1
8000875a:	8d 18       	st.w	r6[0x4],r8
8000875c:	c2 68       	rjmp	800087a8 <_malloc_r+0x3f8>
8000875e:	30 59       	mov	r9,5
80008760:	20 c2       	sub	r2,12
80008762:	e0 12 ff f8 	andl	r2,0xfff8
80008766:	e6 02 00 08 	add	r8,r3,r2
8000876a:	91 29       	st.w	r8[0x8],r9
8000876c:	91 19       	st.w	r8[0x4],r9
8000876e:	66 18       	ld.w	r8,r3[0x4]
80008770:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008774:	e5 e8 10 08 	or	r8,r2,r8
80008778:	87 18       	st.w	r3[0x4],r8
8000877a:	58 f2       	cp.w	r2,15
8000877c:	e0 88 00 07 	brls	8000878a <_malloc_r+0x3da>
80008780:	e6 cb ff f8 	sub	r11,r3,-8
80008784:	0a 9c       	mov	r12,r5
80008786:	e0 a0 1c 7d 	rcall	8000c080 <_free_r>
8000878a:	e0 69 0d e8 	mov	r9,3560
8000878e:	72 0a       	ld.w	r10,r9[0x0]
80008790:	e0 68 0d f0 	mov	r8,3568
80008794:	70 08       	ld.w	r8,r8[0x0]
80008796:	14 38       	cp.w	r8,r10
80008798:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000879c:	e0 69 0d e4 	mov	r9,3556
800087a0:	72 0a       	ld.w	r10,r9[0x0]
800087a2:	14 38       	cp.w	r8,r10
800087a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800087a8:	68 28       	ld.w	r8,r4[0x8]
800087aa:	70 18       	ld.w	r8,r8[0x4]
800087ac:	e0 18 ff fc 	andl	r8,0xfffc
800087b0:	0e 38       	cp.w	r8,r7
800087b2:	5f 39       	srlo	r9
800087b4:	0e 18       	sub	r8,r7
800087b6:	58 f8       	cp.w	r8,15
800087b8:	5f aa       	srle	r10
800087ba:	f5 e9 10 09 	or	r9,r10,r9
800087be:	c0 50       	breq	800087c8 <_malloc_r+0x418>
800087c0:	0a 9c       	mov	r12,r5
800087c2:	fe b0 f3 b3 	rcall	80006f28 <__malloc_unlock>
800087c6:	d8 3a       	popm	r0-r7,pc,r12=0
800087c8:	68 26       	ld.w	r6,r4[0x8]
800087ca:	a1 a8       	sbr	r8,0x0
800087cc:	0e 99       	mov	r9,r7
800087ce:	a1 a9       	sbr	r9,0x0
800087d0:	8d 19       	st.w	r6[0x4],r9
800087d2:	ec 07 00 07 	add	r7,r6,r7
800087d6:	0a 9c       	mov	r12,r5
800087d8:	89 27       	st.w	r4[0x8],r7
800087da:	8f 18       	st.w	r7[0x4],r8
800087dc:	fe b0 f3 a6 	rcall	80006f28 <__malloc_unlock>
800087e0:	ec cc ff f8 	sub	r12,r6,-8
800087e4:	d8 32       	popm	r0-r7,pc
800087e6:	d7 03       	nop

800087e8 <memcmp>:
800087e8:	d4 01       	pushm	lr
800087ea:	30 08       	mov	r8,0
800087ec:	c0 d8       	rjmp	80008806 <memcmp+0x1e>
800087ee:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800087f2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800087f6:	20 1a       	sub	r10,1
800087f8:	2f f8       	sub	r8,-1
800087fa:	f2 0e 18 00 	cp.b	lr,r9
800087fe:	c0 40       	breq	80008806 <memcmp+0x1e>
80008800:	fc 09 01 0c 	sub	r12,lr,r9
80008804:	d8 02       	popm	pc
80008806:	58 0a       	cp.w	r10,0
80008808:	cf 31       	brne	800087ee <memcmp+0x6>
8000880a:	14 9c       	mov	r12,r10
8000880c:	d8 02       	popm	pc

8000880e <memcpy>:
8000880e:	58 8a       	cp.w	r10,8
80008810:	c2 f5       	brlt	8000886e <memcpy+0x60>
80008812:	f9 eb 10 09 	or	r9,r12,r11
80008816:	e2 19 00 03 	andl	r9,0x3,COH
8000881a:	e0 81 00 97 	brne	80008948 <memcpy+0x13a>
8000881e:	e0 4a 00 20 	cp.w	r10,32
80008822:	c3 b4       	brge	80008898 <memcpy+0x8a>
80008824:	f4 08 14 02 	asr	r8,r10,0x2
80008828:	f0 09 11 08 	rsub	r9,r8,8
8000882c:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008830:	76 69       	ld.w	r9,r11[0x18]
80008832:	99 69       	st.w	r12[0x18],r9
80008834:	76 59       	ld.w	r9,r11[0x14]
80008836:	99 59       	st.w	r12[0x14],r9
80008838:	76 49       	ld.w	r9,r11[0x10]
8000883a:	99 49       	st.w	r12[0x10],r9
8000883c:	76 39       	ld.w	r9,r11[0xc]
8000883e:	99 39       	st.w	r12[0xc],r9
80008840:	76 29       	ld.w	r9,r11[0x8]
80008842:	99 29       	st.w	r12[0x8],r9
80008844:	76 19       	ld.w	r9,r11[0x4]
80008846:	99 19       	st.w	r12[0x4],r9
80008848:	76 09       	ld.w	r9,r11[0x0]
8000884a:	99 09       	st.w	r12[0x0],r9
8000884c:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008850:	f8 08 00 28 	add	r8,r12,r8<<0x2
80008854:	e0 1a 00 03 	andl	r10,0x3
80008858:	f4 0a 11 04 	rsub	r10,r10,4
8000885c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008860:	17 a9       	ld.ub	r9,r11[0x2]
80008862:	b0 a9       	st.b	r8[0x2],r9
80008864:	17 99       	ld.ub	r9,r11[0x1]
80008866:	b0 99       	st.b	r8[0x1],r9
80008868:	17 89       	ld.ub	r9,r11[0x0]
8000886a:	b0 89       	st.b	r8[0x0],r9
8000886c:	5e fc       	retal	r12
8000886e:	f4 0a 11 09 	rsub	r10,r10,9
80008872:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008876:	17 f9       	ld.ub	r9,r11[0x7]
80008878:	b8 f9       	st.b	r12[0x7],r9
8000887a:	17 e9       	ld.ub	r9,r11[0x6]
8000887c:	b8 e9       	st.b	r12[0x6],r9
8000887e:	17 d9       	ld.ub	r9,r11[0x5]
80008880:	b8 d9       	st.b	r12[0x5],r9
80008882:	17 c9       	ld.ub	r9,r11[0x4]
80008884:	b8 c9       	st.b	r12[0x4],r9
80008886:	17 b9       	ld.ub	r9,r11[0x3]
80008888:	b8 b9       	st.b	r12[0x3],r9
8000888a:	17 a9       	ld.ub	r9,r11[0x2]
8000888c:	b8 a9       	st.b	r12[0x2],r9
8000888e:	17 99       	ld.ub	r9,r11[0x1]
80008890:	b8 99       	st.b	r12[0x1],r9
80008892:	17 89       	ld.ub	r9,r11[0x0]
80008894:	b8 89       	st.b	r12[0x0],r9
80008896:	5e fc       	retal	r12
80008898:	eb cd 40 c0 	pushm	r6-r7,lr
8000889c:	18 99       	mov	r9,r12
8000889e:	22 0a       	sub	r10,32
800088a0:	b7 07       	ld.d	r6,r11++
800088a2:	b3 26       	st.d	r9++,r6
800088a4:	b7 07       	ld.d	r6,r11++
800088a6:	b3 26       	st.d	r9++,r6
800088a8:	b7 07       	ld.d	r6,r11++
800088aa:	b3 26       	st.d	r9++,r6
800088ac:	b7 07       	ld.d	r6,r11++
800088ae:	b3 26       	st.d	r9++,r6
800088b0:	22 0a       	sub	r10,32
800088b2:	cf 74       	brge	800088a0 <memcpy+0x92>
800088b4:	2f 0a       	sub	r10,-16
800088b6:	c0 65       	brlt	800088c2 <memcpy+0xb4>
800088b8:	b7 07       	ld.d	r6,r11++
800088ba:	b3 26       	st.d	r9++,r6
800088bc:	b7 07       	ld.d	r6,r11++
800088be:	b3 26       	st.d	r9++,r6
800088c0:	21 0a       	sub	r10,16
800088c2:	5c 3a       	neg	r10
800088c4:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800088c8:	d7 03       	nop
800088ca:	d7 03       	nop
800088cc:	f7 36 00 0e 	ld.ub	r6,r11[14]
800088d0:	f3 66 00 0e 	st.b	r9[14],r6
800088d4:	f7 36 00 0d 	ld.ub	r6,r11[13]
800088d8:	f3 66 00 0d 	st.b	r9[13],r6
800088dc:	f7 36 00 0c 	ld.ub	r6,r11[12]
800088e0:	f3 66 00 0c 	st.b	r9[12],r6
800088e4:	f7 36 00 0b 	ld.ub	r6,r11[11]
800088e8:	f3 66 00 0b 	st.b	r9[11],r6
800088ec:	f7 36 00 0a 	ld.ub	r6,r11[10]
800088f0:	f3 66 00 0a 	st.b	r9[10],r6
800088f4:	f7 36 00 09 	ld.ub	r6,r11[9]
800088f8:	f3 66 00 09 	st.b	r9[9],r6
800088fc:	f7 36 00 08 	ld.ub	r6,r11[8]
80008900:	f3 66 00 08 	st.b	r9[8],r6
80008904:	f7 36 00 07 	ld.ub	r6,r11[7]
80008908:	f3 66 00 07 	st.b	r9[7],r6
8000890c:	f7 36 00 06 	ld.ub	r6,r11[6]
80008910:	f3 66 00 06 	st.b	r9[6],r6
80008914:	f7 36 00 05 	ld.ub	r6,r11[5]
80008918:	f3 66 00 05 	st.b	r9[5],r6
8000891c:	f7 36 00 04 	ld.ub	r6,r11[4]
80008920:	f3 66 00 04 	st.b	r9[4],r6
80008924:	f7 36 00 03 	ld.ub	r6,r11[3]
80008928:	f3 66 00 03 	st.b	r9[3],r6
8000892c:	f7 36 00 02 	ld.ub	r6,r11[2]
80008930:	f3 66 00 02 	st.b	r9[2],r6
80008934:	f7 36 00 01 	ld.ub	r6,r11[1]
80008938:	f3 66 00 01 	st.b	r9[1],r6
8000893c:	f7 36 00 00 	ld.ub	r6,r11[0]
80008940:	f3 66 00 00 	st.b	r9[0],r6
80008944:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008948:	20 1a       	sub	r10,1
8000894a:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000894e:	f8 0a 0b 09 	st.b	r12[r10],r9
80008952:	cf b1       	brne	80008948 <memcpy+0x13a>
80008954:	5e fc       	retal	r12

80008956 <memset>:
80008956:	18 98       	mov	r8,r12
80008958:	c0 38       	rjmp	8000895e <memset+0x8>
8000895a:	10 cb       	st.b	r8++,r11
8000895c:	20 1a       	sub	r10,1
8000895e:	58 0a       	cp.w	r10,0
80008960:	cf d1       	brne	8000895a <memset+0x4>
80008962:	5e fc       	retal	r12

80008964 <_realloc_r>:
80008964:	d4 31       	pushm	r0-r7,lr
80008966:	20 1d       	sub	sp,4
80008968:	16 94       	mov	r4,r11
8000896a:	18 92       	mov	r2,r12
8000896c:	14 9b       	mov	r11,r10
8000896e:	58 04       	cp.w	r4,0
80008970:	c0 51       	brne	8000897a <_realloc_r+0x16>
80008972:	fe b0 fd 1f 	rcall	800083b0 <_malloc_r>
80008976:	18 95       	mov	r5,r12
80008978:	c5 39       	rjmp	80008c1e <_realloc_r+0x2ba>
8000897a:	50 0a       	stdsp	sp[0x0],r10
8000897c:	fe b0 f2 d0 	rcall	80006f1c <__malloc_lock>
80008980:	40 0b       	lddsp	r11,sp[0x0]
80008982:	f6 c8 ff f5 	sub	r8,r11,-11
80008986:	e8 c1 00 08 	sub	r1,r4,8
8000898a:	10 96       	mov	r6,r8
8000898c:	62 1c       	ld.w	r12,r1[0x4]
8000898e:	e0 16 ff f8 	andl	r6,0xfff8
80008992:	59 68       	cp.w	r8,22
80008994:	f9 b6 08 10 	movls	r6,16
80008998:	16 36       	cp.w	r6,r11
8000899a:	5f 38       	srlo	r8
8000899c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800089a0:	c0 50       	breq	800089aa <_realloc_r+0x46>
800089a2:	30 c8       	mov	r8,12
800089a4:	30 05       	mov	r5,0
800089a6:	85 38       	st.w	r2[0xc],r8
800089a8:	c3 b9       	rjmp	80008c1e <_realloc_r+0x2ba>
800089aa:	18 90       	mov	r0,r12
800089ac:	e0 10 ff fc 	andl	r0,0xfffc
800089b0:	0c 30       	cp.w	r0,r6
800089b2:	e0 84 01 0b 	brge	80008bc8 <_realloc_r+0x264>
800089b6:	e0 68 05 54 	mov	r8,1364
800089ba:	e2 00 00 09 	add	r9,r1,r0
800089be:	70 25       	ld.w	r5,r8[0x8]
800089c0:	0a 39       	cp.w	r9,r5
800089c2:	c0 90       	breq	800089d4 <_realloc_r+0x70>
800089c4:	72 1a       	ld.w	r10,r9[0x4]
800089c6:	a1 ca       	cbr	r10,0x0
800089c8:	f2 0a 00 0a 	add	r10,r9,r10
800089cc:	74 1a       	ld.w	r10,r10[0x4]
800089ce:	ed ba 00 00 	bld	r10,0x0
800089d2:	c2 20       	breq	80008a16 <_realloc_r+0xb2>
800089d4:	72 1a       	ld.w	r10,r9[0x4]
800089d6:	e0 1a ff fc 	andl	r10,0xfffc
800089da:	f4 00 00 03 	add	r3,r10,r0
800089de:	0a 39       	cp.w	r9,r5
800089e0:	c1 31       	brne	80008a06 <_realloc_r+0xa2>
800089e2:	ec c7 ff f0 	sub	r7,r6,-16
800089e6:	0e 33       	cp.w	r3,r7
800089e8:	c1 95       	brlt	80008a1a <_realloc_r+0xb6>
800089ea:	e2 06 00 09 	add	r9,r1,r6
800089ee:	0c 13       	sub	r3,r6
800089f0:	a1 a3       	sbr	r3,0x0
800089f2:	93 13       	st.w	r9[0x4],r3
800089f4:	91 29       	st.w	r8[0x8],r9
800089f6:	04 9c       	mov	r12,r2
800089f8:	62 18       	ld.w	r8,r1[0x4]
800089fa:	08 95       	mov	r5,r4
800089fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a00:	10 46       	or	r6,r8
80008a02:	83 16       	st.w	r1[0x4],r6
80008a04:	c0 b9       	rjmp	80008c1a <_realloc_r+0x2b6>
80008a06:	0c 33       	cp.w	r3,r6
80008a08:	c0 95       	brlt	80008a1a <_realloc_r+0xb6>
80008a0a:	72 28       	ld.w	r8,r9[0x8]
80008a0c:	02 97       	mov	r7,r1
80008a0e:	72 39       	ld.w	r9,r9[0xc]
80008a10:	93 28       	st.w	r9[0x8],r8
80008a12:	91 39       	st.w	r8[0xc],r9
80008a14:	cd c8       	rjmp	80008bcc <_realloc_r+0x268>
80008a16:	30 0a       	mov	r10,0
80008a18:	14 99       	mov	r9,r10
80008a1a:	ed bc 00 00 	bld	r12,0x0
80008a1e:	e0 80 00 95 	breq	80008b48 <_realloc_r+0x1e4>
80008a22:	62 07       	ld.w	r7,r1[0x0]
80008a24:	e2 07 01 07 	sub	r7,r1,r7
80008a28:	6e 1c       	ld.w	r12,r7[0x4]
80008a2a:	e0 1c ff fc 	andl	r12,0xfffc
80008a2e:	58 09       	cp.w	r9,0
80008a30:	c5 60       	breq	80008adc <_realloc_r+0x178>
80008a32:	f8 00 00 03 	add	r3,r12,r0
80008a36:	0a 39       	cp.w	r9,r5
80008a38:	c4 81       	brne	80008ac8 <_realloc_r+0x164>
80008a3a:	14 03       	add	r3,r10
80008a3c:	ec c9 ff f0 	sub	r9,r6,-16
80008a40:	12 33       	cp.w	r3,r9
80008a42:	c4 d5       	brlt	80008adc <_realloc_r+0x178>
80008a44:	6e 3a       	ld.w	r10,r7[0xc]
80008a46:	6e 29       	ld.w	r9,r7[0x8]
80008a48:	95 29       	st.w	r10[0x8],r9
80008a4a:	93 3a       	st.w	r9[0xc],r10
80008a4c:	ee c5 ff f8 	sub	r5,r7,-8
80008a50:	e0 ca 00 04 	sub	r10,r0,4
80008a54:	e0 4a 00 24 	cp.w	r10,36
80008a58:	e0 8b 00 25 	brhi	80008aa2 <_realloc_r+0x13e>
80008a5c:	0a 99       	mov	r9,r5
80008a5e:	59 3a       	cp.w	r10,19
80008a60:	e0 88 00 1a 	brls	80008a94 <_realloc_r+0x130>
80008a64:	09 09       	ld.w	r9,r4++
80008a66:	8b 09       	st.w	r5[0x0],r9
80008a68:	09 09       	ld.w	r9,r4++
80008a6a:	8f 39       	st.w	r7[0xc],r9
80008a6c:	ee c9 ff f0 	sub	r9,r7,-16
80008a70:	59 ba       	cp.w	r10,27
80008a72:	e0 88 00 11 	brls	80008a94 <_realloc_r+0x130>
80008a76:	09 0b       	ld.w	r11,r4++
80008a78:	93 0b       	st.w	r9[0x0],r11
80008a7a:	09 09       	ld.w	r9,r4++
80008a7c:	8f 59       	st.w	r7[0x14],r9
80008a7e:	ee c9 ff e8 	sub	r9,r7,-24
80008a82:	e0 4a 00 24 	cp.w	r10,36
80008a86:	c0 71       	brne	80008a94 <_realloc_r+0x130>
80008a88:	09 0a       	ld.w	r10,r4++
80008a8a:	93 0a       	st.w	r9[0x0],r10
80008a8c:	ee c9 ff e0 	sub	r9,r7,-32
80008a90:	09 0a       	ld.w	r10,r4++
80008a92:	8f 7a       	st.w	r7[0x1c],r10
80008a94:	09 0a       	ld.w	r10,r4++
80008a96:	12 aa       	st.w	r9++,r10
80008a98:	68 0a       	ld.w	r10,r4[0x0]
80008a9a:	93 0a       	st.w	r9[0x0],r10
80008a9c:	68 1a       	ld.w	r10,r4[0x4]
80008a9e:	93 1a       	st.w	r9[0x4],r10
80008aa0:	c0 78       	rjmp	80008aae <_realloc_r+0x14a>
80008aa2:	50 08       	stdsp	sp[0x0],r8
80008aa4:	08 9b       	mov	r11,r4
80008aa6:	0a 9c       	mov	r12,r5
80008aa8:	e0 a0 1d 8f 	rcall	8000c5c6 <memmove>
80008aac:	40 08       	lddsp	r8,sp[0x0]
80008aae:	ee 06 00 09 	add	r9,r7,r6
80008ab2:	0c 13       	sub	r3,r6
80008ab4:	a1 a3       	sbr	r3,0x0
80008ab6:	93 13       	st.w	r9[0x4],r3
80008ab8:	91 29       	st.w	r8[0x8],r9
80008aba:	04 9c       	mov	r12,r2
80008abc:	6e 18       	ld.w	r8,r7[0x4]
80008abe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008ac2:	10 46       	or	r6,r8
80008ac4:	8f 16       	st.w	r7[0x4],r6
80008ac6:	ca a8       	rjmp	80008c1a <_realloc_r+0x2b6>
80008ac8:	14 03       	add	r3,r10
80008aca:	0c 33       	cp.w	r3,r6
80008acc:	c0 85       	brlt	80008adc <_realloc_r+0x178>
80008ace:	72 28       	ld.w	r8,r9[0x8]
80008ad0:	72 39       	ld.w	r9,r9[0xc]
80008ad2:	93 28       	st.w	r9[0x8],r8
80008ad4:	91 39       	st.w	r8[0xc],r9
80008ad6:	6e 28       	ld.w	r8,r7[0x8]
80008ad8:	6e 39       	ld.w	r9,r7[0xc]
80008ada:	c0 78       	rjmp	80008ae8 <_realloc_r+0x184>
80008adc:	f8 00 00 03 	add	r3,r12,r0
80008ae0:	0c 33       	cp.w	r3,r6
80008ae2:	c3 35       	brlt	80008b48 <_realloc_r+0x1e4>
80008ae4:	6e 39       	ld.w	r9,r7[0xc]
80008ae6:	6e 28       	ld.w	r8,r7[0x8]
80008ae8:	93 28       	st.w	r9[0x8],r8
80008aea:	91 39       	st.w	r8[0xc],r9
80008aec:	e0 ca 00 04 	sub	r10,r0,4
80008af0:	ee cc ff f8 	sub	r12,r7,-8
80008af4:	e0 4a 00 24 	cp.w	r10,36
80008af8:	e0 8b 00 24 	brhi	80008b40 <_realloc_r+0x1dc>
80008afc:	59 3a       	cp.w	r10,19
80008afe:	e0 88 00 1a 	brls	80008b32 <_realloc_r+0x1ce>
80008b02:	09 08       	ld.w	r8,r4++
80008b04:	99 08       	st.w	r12[0x0],r8
80008b06:	09 08       	ld.w	r8,r4++
80008b08:	8f 38       	st.w	r7[0xc],r8
80008b0a:	ee cc ff f0 	sub	r12,r7,-16
80008b0e:	59 ba       	cp.w	r10,27
80008b10:	e0 88 00 11 	brls	80008b32 <_realloc_r+0x1ce>
80008b14:	09 08       	ld.w	r8,r4++
80008b16:	99 08       	st.w	r12[0x0],r8
80008b18:	09 08       	ld.w	r8,r4++
80008b1a:	8f 58       	st.w	r7[0x14],r8
80008b1c:	ee cc ff e8 	sub	r12,r7,-24
80008b20:	e0 4a 00 24 	cp.w	r10,36
80008b24:	c0 71       	brne	80008b32 <_realloc_r+0x1ce>
80008b26:	09 08       	ld.w	r8,r4++
80008b28:	99 08       	st.w	r12[0x0],r8
80008b2a:	ee cc ff e0 	sub	r12,r7,-32
80008b2e:	09 08       	ld.w	r8,r4++
80008b30:	8f 78       	st.w	r7[0x1c],r8
80008b32:	09 08       	ld.w	r8,r4++
80008b34:	18 a8       	st.w	r12++,r8
80008b36:	68 08       	ld.w	r8,r4[0x0]
80008b38:	99 08       	st.w	r12[0x0],r8
80008b3a:	68 18       	ld.w	r8,r4[0x4]
80008b3c:	99 18       	st.w	r12[0x4],r8
80008b3e:	c4 78       	rjmp	80008bcc <_realloc_r+0x268>
80008b40:	08 9b       	mov	r11,r4
80008b42:	e0 a0 1d 42 	rcall	8000c5c6 <memmove>
80008b46:	c4 38       	rjmp	80008bcc <_realloc_r+0x268>
80008b48:	04 9c       	mov	r12,r2
80008b4a:	fe b0 fc 33 	rcall	800083b0 <_malloc_r>
80008b4e:	18 95       	mov	r5,r12
80008b50:	c3 a0       	breq	80008bc4 <_realloc_r+0x260>
80008b52:	62 18       	ld.w	r8,r1[0x4]
80008b54:	f8 c9 00 08 	sub	r9,r12,8
80008b58:	a1 c8       	cbr	r8,0x0
80008b5a:	e2 08 00 08 	add	r8,r1,r8
80008b5e:	10 39       	cp.w	r9,r8
80008b60:	c0 71       	brne	80008b6e <_realloc_r+0x20a>
80008b62:	72 13       	ld.w	r3,r9[0x4]
80008b64:	02 97       	mov	r7,r1
80008b66:	e0 13 ff fc 	andl	r3,0xfffc
80008b6a:	00 03       	add	r3,r0
80008b6c:	c3 08       	rjmp	80008bcc <_realloc_r+0x268>
80008b6e:	e0 ca 00 04 	sub	r10,r0,4
80008b72:	e0 4a 00 24 	cp.w	r10,36
80008b76:	e0 8b 00 20 	brhi	80008bb6 <_realloc_r+0x252>
80008b7a:	08 99       	mov	r9,r4
80008b7c:	18 98       	mov	r8,r12
80008b7e:	59 3a       	cp.w	r10,19
80008b80:	e0 88 00 14 	brls	80008ba8 <_realloc_r+0x244>
80008b84:	13 0b       	ld.w	r11,r9++
80008b86:	10 ab       	st.w	r8++,r11
80008b88:	13 0b       	ld.w	r11,r9++
80008b8a:	10 ab       	st.w	r8++,r11
80008b8c:	59 ba       	cp.w	r10,27
80008b8e:	e0 88 00 0d 	brls	80008ba8 <_realloc_r+0x244>
80008b92:	13 0b       	ld.w	r11,r9++
80008b94:	10 ab       	st.w	r8++,r11
80008b96:	13 0b       	ld.w	r11,r9++
80008b98:	10 ab       	st.w	r8++,r11
80008b9a:	e0 4a 00 24 	cp.w	r10,36
80008b9e:	c0 51       	brne	80008ba8 <_realloc_r+0x244>
80008ba0:	13 0a       	ld.w	r10,r9++
80008ba2:	10 aa       	st.w	r8++,r10
80008ba4:	13 0a       	ld.w	r10,r9++
80008ba6:	10 aa       	st.w	r8++,r10
80008ba8:	13 0a       	ld.w	r10,r9++
80008baa:	10 aa       	st.w	r8++,r10
80008bac:	72 0a       	ld.w	r10,r9[0x0]
80008bae:	91 0a       	st.w	r8[0x0],r10
80008bb0:	72 19       	ld.w	r9,r9[0x4]
80008bb2:	91 19       	st.w	r8[0x4],r9
80008bb4:	c0 48       	rjmp	80008bbc <_realloc_r+0x258>
80008bb6:	08 9b       	mov	r11,r4
80008bb8:	e0 a0 1d 07 	rcall	8000c5c6 <memmove>
80008bbc:	08 9b       	mov	r11,r4
80008bbe:	04 9c       	mov	r12,r2
80008bc0:	e0 a0 1a 60 	rcall	8000c080 <_free_r>
80008bc4:	04 9c       	mov	r12,r2
80008bc6:	c2 a8       	rjmp	80008c1a <_realloc_r+0x2b6>
80008bc8:	00 93       	mov	r3,r0
80008bca:	02 97       	mov	r7,r1
80008bcc:	e6 06 01 09 	sub	r9,r3,r6
80008bd0:	6e 18       	ld.w	r8,r7[0x4]
80008bd2:	58 f9       	cp.w	r9,15
80008bd4:	e0 88 00 16 	brls	80008c00 <_realloc_r+0x29c>
80008bd8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008bdc:	ed e8 10 08 	or	r8,r6,r8
80008be0:	8f 18       	st.w	r7[0x4],r8
80008be2:	12 98       	mov	r8,r9
80008be4:	a1 a8       	sbr	r8,0x0
80008be6:	ee 06 00 0b 	add	r11,r7,r6
80008bea:	f6 09 00 09 	add	r9,r11,r9
80008bee:	97 18       	st.w	r11[0x4],r8
80008bf0:	72 18       	ld.w	r8,r9[0x4]
80008bf2:	a1 a8       	sbr	r8,0x0
80008bf4:	2f 8b       	sub	r11,-8
80008bf6:	93 18       	st.w	r9[0x4],r8
80008bf8:	04 9c       	mov	r12,r2
80008bfa:	e0 a0 1a 43 	rcall	8000c080 <_free_r>
80008bfe:	c0 b8       	rjmp	80008c14 <_realloc_r+0x2b0>
80008c00:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008c04:	e7 e8 10 08 	or	r8,r3,r8
80008c08:	8f 18       	st.w	r7[0x4],r8
80008c0a:	ee 03 00 03 	add	r3,r7,r3
80008c0e:	66 18       	ld.w	r8,r3[0x4]
80008c10:	a1 a8       	sbr	r8,0x0
80008c12:	87 18       	st.w	r3[0x4],r8
80008c14:	04 9c       	mov	r12,r2
80008c16:	ee c5 ff f8 	sub	r5,r7,-8
80008c1a:	fe b0 f1 87 	rcall	80006f28 <__malloc_unlock>
80008c1e:	0a 9c       	mov	r12,r5
80008c20:	2f fd       	sub	sp,-4
80008c22:	d8 32       	popm	r0-r7,pc

80008c24 <_sbrk_r>:
80008c24:	d4 21       	pushm	r4-r7,lr
80008c26:	30 08       	mov	r8,0
80008c28:	18 97       	mov	r7,r12
80008c2a:	e0 66 bd 48 	mov	r6,48456
80008c2e:	16 9c       	mov	r12,r11
80008c30:	8d 08       	st.w	r6[0x0],r8
80008c32:	c8 5c       	rcall	80008d3c <_sbrk>
80008c34:	5b fc       	cp.w	r12,-1
80008c36:	c0 51       	brne	80008c40 <_sbrk_r+0x1c>
80008c38:	6c 08       	ld.w	r8,r6[0x0]
80008c3a:	58 08       	cp.w	r8,0
80008c3c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008c40:	d8 22       	popm	r4-r7,pc
80008c42:	d7 03       	nop

80008c44 <sprintf>:
80008c44:	d4 01       	pushm	lr
80008c46:	21 7d       	sub	sp,92
80008c48:	e0 68 ff ff 	mov	r8,65535
80008c4c:	ea 18 7f ff 	orh	r8,0x7fff
80008c50:	50 58       	stdsp	sp[0x14],r8
80008c52:	50 28       	stdsp	sp[0x8],r8
80008c54:	e0 68 02 08 	mov	r8,520
80008c58:	ba 68       	st.h	sp[0xc],r8
80008c5a:	3f f8       	mov	r8,-1
80008c5c:	ba 78       	st.h	sp[0xe],r8
80008c5e:	e0 68 0a 54 	mov	r8,2644
80008c62:	50 4c       	stdsp	sp[0x10],r12
80008c64:	16 9a       	mov	r10,r11
80008c66:	50 0c       	stdsp	sp[0x0],r12
80008c68:	fa c9 ff a0 	sub	r9,sp,-96
80008c6c:	70 0c       	ld.w	r12,r8[0x0]
80008c6e:	1a 9b       	mov	r11,sp
80008c70:	e0 a0 02 1a 	rcall	800090a4 <_vfprintf_r>
80008c74:	30 09       	mov	r9,0
80008c76:	40 08       	lddsp	r8,sp[0x0]
80008c78:	b0 89       	st.b	r8[0x0],r9
80008c7a:	2e 9d       	sub	sp,-92
80008c7c:	d8 02       	popm	pc
80008c7e:	d7 03       	nop

80008c80 <strncpy>:
80008c80:	30 08       	mov	r8,0
80008c82:	10 3a       	cp.w	r10,r8
80008c84:	5e 0c       	reteq	r12
80008c86:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008c8a:	f8 08 0b 09 	st.b	r12[r8],r9
80008c8e:	2f f8       	sub	r8,-1
80008c90:	58 09       	cp.w	r9,0
80008c92:	cf 81       	brne	80008c82 <strncpy+0x2>
80008c94:	10 3a       	cp.w	r10,r8
80008c96:	5e 0c       	reteq	r12
80008c98:	f8 08 0b 09 	st.b	r12[r8],r9
80008c9c:	2f f8       	sub	r8,-1
80008c9e:	cf bb       	rjmp	80008c94 <strncpy+0x14>

80008ca0 <_close>:
80008ca0:	30 28       	mov	r8,2
80008ca2:	d6 73       	breakpoint
80008ca4:	3f fc       	mov	r12,-1
80008ca6:	35 8b       	mov	r11,88
80008ca8:	58 0c       	cp.w	r12,0
80008caa:	5e 4c       	retge	r12
80008cac:	e0 6a bd 48 	mov	r10,48456
80008cb0:	95 0b       	st.w	r10[0x0],r11
80008cb2:	5e fc       	retal	r12

80008cb4 <_lseek>:
80008cb4:	30 58       	mov	r8,5
80008cb6:	d6 73       	breakpoint
80008cb8:	3f fc       	mov	r12,-1
80008cba:	35 8b       	mov	r11,88
80008cbc:	58 0c       	cp.w	r12,0
80008cbe:	5e 4c       	retge	r12
80008cc0:	e0 6a bd 48 	mov	r10,48456
80008cc4:	95 0b       	st.w	r10[0x0],r11
80008cc6:	5e fc       	retal	r12

80008cc8 <isatty>:
80008cc8:	30 b8       	mov	r8,11
80008cca:	d6 73       	breakpoint
80008ccc:	3f fc       	mov	r12,-1
80008cce:	35 8b       	mov	r11,88
80008cd0:	58 0c       	cp.w	r12,0
80008cd2:	5e 4c       	retge	r12
80008cd4:	e0 6a bd 48 	mov	r10,48456
80008cd8:	95 0b       	st.w	r10[0x0],r11
80008cda:	5e fc       	retal	r12

80008cdc <_fstat_host>:
80008cdc:	30 98       	mov	r8,9
80008cde:	d6 73       	breakpoint
80008ce0:	3f fc       	mov	r12,-1
80008ce2:	35 8b       	mov	r11,88
80008ce4:	58 0c       	cp.w	r12,0
80008ce6:	5e 4c       	retge	r12
80008ce8:	e0 6a bd 48 	mov	r10,48456
80008cec:	95 0b       	st.w	r10[0x0],r11
80008cee:	5e fc       	retal	r12

80008cf0 <_fstat>:
80008cf0:	d4 21       	pushm	r4-r7,lr
80008cf2:	21 0d       	sub	sp,64
80008cf4:	16 97       	mov	r7,r11
80008cf6:	1a 9b       	mov	r11,sp
80008cf8:	cf 2f       	rcall	80008cdc <_fstat_host>
80008cfa:	c0 34       	brge	80008d00 <_fstat+0x10>
80008cfc:	3f fc       	mov	r12,-1
80008cfe:	c1 c8       	rjmp	80008d36 <_fstat+0x46>
80008d00:	40 08       	lddsp	r8,sp[0x0]
80008d02:	ae 08       	st.h	r7[0x0],r8
80008d04:	40 18       	lddsp	r8,sp[0x4]
80008d06:	ae 18       	st.h	r7[0x2],r8
80008d08:	40 28       	lddsp	r8,sp[0x8]
80008d0a:	8f 18       	st.w	r7[0x4],r8
80008d0c:	40 38       	lddsp	r8,sp[0xc]
80008d0e:	ae 48       	st.h	r7[0x8],r8
80008d10:	40 48       	lddsp	r8,sp[0x10]
80008d12:	ae 58       	st.h	r7[0xa],r8
80008d14:	40 58       	lddsp	r8,sp[0x14]
80008d16:	ae 68       	st.h	r7[0xc],r8
80008d18:	40 68       	lddsp	r8,sp[0x18]
80008d1a:	ae 78       	st.h	r7[0xe],r8
80008d1c:	40 88       	lddsp	r8,sp[0x20]
80008d1e:	8f 48       	st.w	r7[0x10],r8
80008d20:	40 a8       	lddsp	r8,sp[0x28]
80008d22:	8f b8       	st.w	r7[0x2c],r8
80008d24:	40 c8       	lddsp	r8,sp[0x30]
80008d26:	8f c8       	st.w	r7[0x30],r8
80008d28:	40 d8       	lddsp	r8,sp[0x34]
80008d2a:	8f 58       	st.w	r7[0x14],r8
80008d2c:	40 e8       	lddsp	r8,sp[0x38]
80008d2e:	30 0c       	mov	r12,0
80008d30:	8f 78       	st.w	r7[0x1c],r8
80008d32:	40 f8       	lddsp	r8,sp[0x3c]
80008d34:	8f 98       	st.w	r7[0x24],r8
80008d36:	2f 0d       	sub	sp,-64
80008d38:	d8 22       	popm	r4-r7,pc
80008d3a:	d7 03       	nop

80008d3c <_sbrk>:
80008d3c:	d4 01       	pushm	lr
80008d3e:	e0 68 0e 18 	mov	r8,3608
80008d42:	70 09       	ld.w	r9,r8[0x0]
80008d44:	58 09       	cp.w	r9,0
80008d46:	c0 41       	brne	80008d4e <_sbrk+0x12>
80008d48:	e0 69 bd 50 	mov	r9,48464
80008d4c:	91 09       	st.w	r8[0x0],r9
80008d4e:	e0 69 0e 18 	mov	r9,3608
80008d52:	e0 7a 70 00 	mov	r10,94208
80008d56:	72 08       	ld.w	r8,r9[0x0]
80008d58:	f0 0c 00 0c 	add	r12,r8,r12
80008d5c:	14 3c       	cp.w	r12,r10
80008d5e:	e0 8b 00 04 	brhi	80008d66 <_sbrk+0x2a>
80008d62:	93 0c       	st.w	r9[0x0],r12
80008d64:	c0 68       	rjmp	80008d70 <_sbrk+0x34>
80008d66:	e0 a0 18 15 	rcall	8000bd90 <__errno>
80008d6a:	30 c8       	mov	r8,12
80008d6c:	99 08       	st.w	r12[0x0],r8
80008d6e:	3f f8       	mov	r8,-1
80008d70:	10 9c       	mov	r12,r8
80008d72:	d8 02       	popm	pc

80008d74 <get_arg>:
80008d74:	d4 31       	pushm	r0-r7,lr
80008d76:	20 8d       	sub	sp,32
80008d78:	fa c4 ff bc 	sub	r4,sp,-68
80008d7c:	50 4b       	stdsp	sp[0x10],r11
80008d7e:	68 2e       	ld.w	lr,r4[0x8]
80008d80:	50 58       	stdsp	sp[0x14],r8
80008d82:	12 96       	mov	r6,r9
80008d84:	7c 0b       	ld.w	r11,lr[0x0]
80008d86:	70 05       	ld.w	r5,r8[0x0]
80008d88:	50 6e       	stdsp	sp[0x18],lr
80008d8a:	58 0b       	cp.w	r11,0
80008d8c:	f4 0b 17 00 	moveq	r11,r10
80008d90:	68 03       	ld.w	r3,r4[0x0]
80008d92:	68 11       	ld.w	r1,r4[0x4]
80008d94:	40 49       	lddsp	r9,sp[0x10]
80008d96:	30 08       	mov	r8,0
80008d98:	c2 89       	rjmp	80008fe8 <get_arg+0x274>
80008d9a:	2f fb       	sub	r11,-1
80008d9c:	32 5c       	mov	r12,37
80008d9e:	17 8a       	ld.ub	r10,r11[0x0]
80008da0:	f8 0a 18 00 	cp.b	r10,r12
80008da4:	5f 1e       	srne	lr
80008da6:	f0 0a 18 00 	cp.b	r10,r8
80008daa:	5f 1c       	srne	r12
80008dac:	fd ec 00 0c 	and	r12,lr,r12
80008db0:	f0 0c 18 00 	cp.b	r12,r8
80008db4:	cf 31       	brne	80008d9a <get_arg+0x26>
80008db6:	58 0a       	cp.w	r10,0
80008db8:	e0 80 01 25 	breq	80009002 <get_arg+0x28e>
80008dbc:	30 0c       	mov	r12,0
80008dbe:	3f fa       	mov	r10,-1
80008dc0:	18 90       	mov	r0,r12
80008dc2:	50 3a       	stdsp	sp[0xc],r10
80008dc4:	18 94       	mov	r4,r12
80008dc6:	18 92       	mov	r2,r12
80008dc8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008dcc:	16 97       	mov	r7,r11
80008dce:	50 7c       	stdsp	sp[0x1c],r12
80008dd0:	fe cc 9a 5c 	sub	r12,pc,-26020
80008dd4:	0f 3a       	ld.ub	r10,r7++
80008dd6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008dda:	40 7c       	lddsp	r12,sp[0x1c]
80008ddc:	1c 0c       	add	r12,lr
80008dde:	fe ce 9b 32 	sub	lr,pc,-25806
80008de2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008de6:	20 1e       	sub	lr,1
80008de8:	50 0e       	stdsp	sp[0x0],lr
80008dea:	fe ce 9b aa 	sub	lr,pc,-25686
80008dee:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008df2:	50 7c       	stdsp	sp[0x1c],r12
80008df4:	40 0c       	lddsp	r12,sp[0x0]
80008df6:	58 7c       	cp.w	r12,7
80008df8:	e0 8b 00 f1 	brhi	80008fda <get_arg+0x266>
80008dfc:	fe ce 9d 5c 	sub	lr,pc,-25252
80008e00:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008e04:	36 8b       	mov	r11,104
80008e06:	f6 0a 18 00 	cp.b	r10,r11
80008e0a:	e0 80 00 e8 	breq	80008fda <get_arg+0x266>
80008e0e:	37 1b       	mov	r11,113
80008e10:	f6 0a 18 00 	cp.b	r10,r11
80008e14:	c0 70       	breq	80008e22 <get_arg+0xae>
80008e16:	34 cb       	mov	r11,76
80008e18:	f6 0a 18 00 	cp.b	r10,r11
80008e1c:	c0 51       	brne	80008e26 <get_arg+0xb2>
80008e1e:	a3 b4       	sbr	r4,0x3
80008e20:	cd d8       	rjmp	80008fda <get_arg+0x266>
80008e22:	a5 b4       	sbr	r4,0x5
80008e24:	cd b8       	rjmp	80008fda <get_arg+0x266>
80008e26:	08 9a       	mov	r10,r4
80008e28:	0e 9b       	mov	r11,r7
80008e2a:	a5 aa       	sbr	r10,0x4
80008e2c:	17 3c       	ld.ub	r12,r11++
80008e2e:	a5 b4       	sbr	r4,0x5
80008e30:	36 ce       	mov	lr,108
80008e32:	fc 0c 18 00 	cp.b	r12,lr
80008e36:	e0 80 00 d3 	breq	80008fdc <get_arg+0x268>
80008e3a:	14 94       	mov	r4,r10
80008e3c:	cc f8       	rjmp	80008fda <get_arg+0x266>
80008e3e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008e42:	36 7c       	mov	r12,103
80008e44:	f8 0a 18 00 	cp.b	r10,r12
80008e48:	e0 8b 00 27 	brhi	80008e96 <get_arg+0x122>
80008e4c:	36 5b       	mov	r11,101
80008e4e:	f6 0a 18 00 	cp.b	r10,r11
80008e52:	c4 82       	brcc	80008ee2 <get_arg+0x16e>
80008e54:	34 fb       	mov	r11,79
80008e56:	f6 0a 18 00 	cp.b	r10,r11
80008e5a:	c4 80       	breq	80008eea <get_arg+0x176>
80008e5c:	e0 8b 00 0c 	brhi	80008e74 <get_arg+0x100>
80008e60:	34 5b       	mov	r11,69
80008e62:	f6 0a 18 00 	cp.b	r10,r11
80008e66:	c3 e0       	breq	80008ee2 <get_arg+0x16e>
80008e68:	34 7b       	mov	r11,71
80008e6a:	f6 0a 18 00 	cp.b	r10,r11
80008e6e:	c3 a0       	breq	80008ee2 <get_arg+0x16e>
80008e70:	34 4b       	mov	r11,68
80008e72:	c0 88       	rjmp	80008e82 <get_arg+0x10e>
80008e74:	35 8b       	mov	r11,88
80008e76:	f6 0a 18 00 	cp.b	r10,r11
80008e7a:	c2 c0       	breq	80008ed2 <get_arg+0x15e>
80008e7c:	e0 8b 00 07 	brhi	80008e8a <get_arg+0x116>
80008e80:	35 5b       	mov	r11,85
80008e82:	f6 0a 18 00 	cp.b	r10,r11
80008e86:	c3 51       	brne	80008ef0 <get_arg+0x17c>
80008e88:	c3 18       	rjmp	80008eea <get_arg+0x176>
80008e8a:	36 3b       	mov	r11,99
80008e8c:	f6 0a 18 00 	cp.b	r10,r11
80008e90:	c2 f0       	breq	80008eee <get_arg+0x17a>
80008e92:	36 4b       	mov	r11,100
80008e94:	c0 e8       	rjmp	80008eb0 <get_arg+0x13c>
80008e96:	37 0b       	mov	r11,112
80008e98:	f6 0a 18 00 	cp.b	r10,r11
80008e9c:	c2 50       	breq	80008ee6 <get_arg+0x172>
80008e9e:	e0 8b 00 0d 	brhi	80008eb8 <get_arg+0x144>
80008ea2:	36 eb       	mov	r11,110
80008ea4:	f6 0a 18 00 	cp.b	r10,r11
80008ea8:	c1 f0       	breq	80008ee6 <get_arg+0x172>
80008eaa:	e0 8b 00 14 	brhi	80008ed2 <get_arg+0x15e>
80008eae:	36 9b       	mov	r11,105
80008eb0:	f6 0a 18 00 	cp.b	r10,r11
80008eb4:	c1 e1       	brne	80008ef0 <get_arg+0x17c>
80008eb6:	c0 e8       	rjmp	80008ed2 <get_arg+0x15e>
80008eb8:	37 5b       	mov	r11,117
80008eba:	f6 0a 18 00 	cp.b	r10,r11
80008ebe:	c0 a0       	breq	80008ed2 <get_arg+0x15e>
80008ec0:	37 8b       	mov	r11,120
80008ec2:	f6 0a 18 00 	cp.b	r10,r11
80008ec6:	c0 60       	breq	80008ed2 <get_arg+0x15e>
80008ec8:	37 3b       	mov	r11,115
80008eca:	f6 0a 18 00 	cp.b	r10,r11
80008ece:	c1 11       	brne	80008ef0 <get_arg+0x17c>
80008ed0:	c0 b8       	rjmp	80008ee6 <get_arg+0x172>
80008ed2:	ed b4 00 04 	bld	r4,0x4
80008ed6:	c0 a0       	breq	80008eea <get_arg+0x176>
80008ed8:	ed b4 00 05 	bld	r4,0x5
80008edc:	c0 91       	brne	80008eee <get_arg+0x17a>
80008ede:	30 20       	mov	r0,2
80008ee0:	c0 88       	rjmp	80008ef0 <get_arg+0x17c>
80008ee2:	30 40       	mov	r0,4
80008ee4:	c0 68       	rjmp	80008ef0 <get_arg+0x17c>
80008ee6:	30 30       	mov	r0,3
80008ee8:	c0 48       	rjmp	80008ef0 <get_arg+0x17c>
80008eea:	30 10       	mov	r0,1
80008eec:	c0 28       	rjmp	80008ef0 <get_arg+0x17c>
80008eee:	30 00       	mov	r0,0
80008ef0:	40 3b       	lddsp	r11,sp[0xc]
80008ef2:	5b fb       	cp.w	r11,-1
80008ef4:	c0 40       	breq	80008efc <get_arg+0x188>
80008ef6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008efa:	c7 08       	rjmp	80008fda <get_arg+0x266>
80008efc:	58 60       	cp.w	r0,6
80008efe:	e0 8b 00 6e 	brhi	80008fda <get_arg+0x266>
80008f02:	6c 0a       	ld.w	r10,r6[0x0]
80008f04:	ea cc ff ff 	sub	r12,r5,-1
80008f08:	fe ce 9e 48 	sub	lr,pc,-25016
80008f0c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008f10:	f4 cb ff f8 	sub	r11,r10,-8
80008f14:	8d 0b       	st.w	r6[0x0],r11
80008f16:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f1a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f1e:	c0 f8       	rjmp	80008f3c <get_arg+0x1c8>
80008f20:	f4 cb ff fc 	sub	r11,r10,-4
80008f24:	8d 0b       	st.w	r6[0x0],r11
80008f26:	74 0a       	ld.w	r10,r10[0x0]
80008f28:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f2c:	c0 88       	rjmp	80008f3c <get_arg+0x1c8>
80008f2e:	f4 cb ff f8 	sub	r11,r10,-8
80008f32:	8d 0b       	st.w	r6[0x0],r11
80008f34:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f38:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f3c:	0e 9b       	mov	r11,r7
80008f3e:	18 95       	mov	r5,r12
80008f40:	c4 e8       	rjmp	80008fdc <get_arg+0x268>
80008f42:	62 0a       	ld.w	r10,r1[0x0]
80008f44:	5b fa       	cp.w	r10,-1
80008f46:	c0 b1       	brne	80008f5c <get_arg+0x1e8>
80008f48:	50 19       	stdsp	sp[0x4],r9
80008f4a:	50 28       	stdsp	sp[0x8],r8
80008f4c:	e0 6a 00 80 	mov	r10,128
80008f50:	30 0b       	mov	r11,0
80008f52:	02 9c       	mov	r12,r1
80008f54:	fe b0 fd 01 	rcall	80008956 <memset>
80008f58:	40 28       	lddsp	r8,sp[0x8]
80008f5a:	40 19       	lddsp	r9,sp[0x4]
80008f5c:	e4 cc 00 01 	sub	r12,r2,1
80008f60:	0e 9b       	mov	r11,r7
80008f62:	50 3c       	stdsp	sp[0xc],r12
80008f64:	f2 0c 0c 49 	max	r9,r9,r12
80008f68:	c3 a8       	rjmp	80008fdc <get_arg+0x268>
80008f6a:	62 0a       	ld.w	r10,r1[0x0]
80008f6c:	5b fa       	cp.w	r10,-1
80008f6e:	c0 b1       	brne	80008f84 <get_arg+0x210>
80008f70:	50 19       	stdsp	sp[0x4],r9
80008f72:	50 28       	stdsp	sp[0x8],r8
80008f74:	e0 6a 00 80 	mov	r10,128
80008f78:	30 0b       	mov	r11,0
80008f7a:	02 9c       	mov	r12,r1
80008f7c:	fe b0 fc ed 	rcall	80008956 <memset>
80008f80:	40 28       	lddsp	r8,sp[0x8]
80008f82:	40 19       	lddsp	r9,sp[0x4]
80008f84:	20 12       	sub	r2,1
80008f86:	30 0a       	mov	r10,0
80008f88:	0e 9b       	mov	r11,r7
80008f8a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008f8e:	f2 02 0c 49 	max	r9,r9,r2
80008f92:	c2 58       	rjmp	80008fdc <get_arg+0x268>
80008f94:	16 97       	mov	r7,r11
80008f96:	6c 0a       	ld.w	r10,r6[0x0]
80008f98:	f4 cb ff fc 	sub	r11,r10,-4
80008f9c:	8d 0b       	st.w	r6[0x0],r11
80008f9e:	74 0a       	ld.w	r10,r10[0x0]
80008fa0:	0e 9b       	mov	r11,r7
80008fa2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008fa6:	2f f5       	sub	r5,-1
80008fa8:	c1 a8       	rjmp	80008fdc <get_arg+0x268>
80008faa:	f4 c2 00 30 	sub	r2,r10,48
80008fae:	c0 68       	rjmp	80008fba <get_arg+0x246>
80008fb0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008fb4:	2f f7       	sub	r7,-1
80008fb6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008fba:	0f 8a       	ld.ub	r10,r7[0x0]
80008fbc:	58 0a       	cp.w	r10,0
80008fbe:	c0 e0       	breq	80008fda <get_arg+0x266>
80008fc0:	23 0a       	sub	r10,48
80008fc2:	58 9a       	cp.w	r10,9
80008fc4:	fe 98 ff f6 	brls	80008fb0 <get_arg+0x23c>
80008fc8:	c0 98       	rjmp	80008fda <get_arg+0x266>
80008fca:	2f f7       	sub	r7,-1
80008fcc:	0f 8a       	ld.ub	r10,r7[0x0]
80008fce:	58 0a       	cp.w	r10,0
80008fd0:	c0 50       	breq	80008fda <get_arg+0x266>
80008fd2:	23 0a       	sub	r10,48
80008fd4:	58 9a       	cp.w	r10,9
80008fd6:	fe 98 ff fa 	brls	80008fca <get_arg+0x256>
80008fda:	0e 9b       	mov	r11,r7
80008fdc:	40 7c       	lddsp	r12,sp[0x1c]
80008fde:	30 ba       	mov	r10,11
80008fe0:	f4 0c 18 00 	cp.b	r12,r10
80008fe4:	fe 91 fe f2 	brne	80008dc8 <get_arg+0x54>
80008fe8:	40 42       	lddsp	r2,sp[0x10]
80008fea:	17 8c       	ld.ub	r12,r11[0x0]
80008fec:	0a 32       	cp.w	r2,r5
80008fee:	5f 4a       	srge	r10
80008ff0:	f0 0c 18 00 	cp.b	r12,r8
80008ff4:	5f 1c       	srne	r12
80008ff6:	f9 ea 00 0a 	and	r10,r12,r10
80008ffa:	f0 0a 18 00 	cp.b	r10,r8
80008ffe:	fe 91 fe cf 	brne	80008d9c <get_arg+0x28>
80009002:	30 08       	mov	r8,0
80009004:	40 4e       	lddsp	lr,sp[0x10]
80009006:	17 8a       	ld.ub	r10,r11[0x0]
80009008:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000900c:	f0 0a 18 00 	cp.b	r10,r8
80009010:	fc 09 17 10 	movne	r9,lr
80009014:	e6 05 00 38 	add	r8,r3,r5<<0x3
80009018:	06 9e       	mov	lr,r3
8000901a:	c2 a8       	rjmp	8000906e <get_arg+0x2fa>
8000901c:	62 0a       	ld.w	r10,r1[0x0]
8000901e:	58 3a       	cp.w	r10,3
80009020:	c1 e0       	breq	8000905c <get_arg+0x2e8>
80009022:	e0 89 00 07 	brgt	80009030 <get_arg+0x2bc>
80009026:	58 1a       	cp.w	r10,1
80009028:	c1 a0       	breq	8000905c <get_arg+0x2e8>
8000902a:	58 2a       	cp.w	r10,2
8000902c:	c1 81       	brne	8000905c <get_arg+0x2e8>
8000902e:	c0 58       	rjmp	80009038 <get_arg+0x2c4>
80009030:	58 5a       	cp.w	r10,5
80009032:	c0 c0       	breq	8000904a <get_arg+0x2d6>
80009034:	c0 b5       	brlt	8000904a <get_arg+0x2d6>
80009036:	c1 38       	rjmp	8000905c <get_arg+0x2e8>
80009038:	6c 0a       	ld.w	r10,r6[0x0]
8000903a:	f4 cc ff f8 	sub	r12,r10,-8
8000903e:	8d 0c       	st.w	r6[0x0],r12
80009040:	f4 e2 00 00 	ld.d	r2,r10[0]
80009044:	f0 e3 00 00 	st.d	r8[0],r2
80009048:	c1 08       	rjmp	80009068 <get_arg+0x2f4>
8000904a:	6c 0a       	ld.w	r10,r6[0x0]
8000904c:	f4 cc ff f8 	sub	r12,r10,-8
80009050:	8d 0c       	st.w	r6[0x0],r12
80009052:	f4 e2 00 00 	ld.d	r2,r10[0]
80009056:	f0 e3 00 00 	st.d	r8[0],r2
8000905a:	c0 78       	rjmp	80009068 <get_arg+0x2f4>
8000905c:	6c 0a       	ld.w	r10,r6[0x0]
8000905e:	f4 cc ff fc 	sub	r12,r10,-4
80009062:	8d 0c       	st.w	r6[0x0],r12
80009064:	74 0a       	ld.w	r10,r10[0x0]
80009066:	91 0a       	st.w	r8[0x0],r10
80009068:	2f f5       	sub	r5,-1
8000906a:	2f 88       	sub	r8,-8
8000906c:	2f c1       	sub	r1,-4
8000906e:	12 35       	cp.w	r5,r9
80009070:	fe 9a ff d6 	brle	8000901c <get_arg+0x2a8>
80009074:	1c 93       	mov	r3,lr
80009076:	40 52       	lddsp	r2,sp[0x14]
80009078:	40 6e       	lddsp	lr,sp[0x18]
8000907a:	85 05       	st.w	r2[0x0],r5
8000907c:	9d 0b       	st.w	lr[0x0],r11
8000907e:	40 4b       	lddsp	r11,sp[0x10]
80009080:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80009084:	2f 8d       	sub	sp,-32
80009086:	d8 32       	popm	r0-r7,pc

80009088 <__sprint_r>:
80009088:	d4 21       	pushm	r4-r7,lr
8000908a:	14 97       	mov	r7,r10
8000908c:	74 28       	ld.w	r8,r10[0x8]
8000908e:	58 08       	cp.w	r8,0
80009090:	c0 41       	brne	80009098 <__sprint_r+0x10>
80009092:	95 18       	st.w	r10[0x4],r8
80009094:	10 9c       	mov	r12,r8
80009096:	d8 22       	popm	r4-r7,pc
80009098:	e0 a0 18 ba 	rcall	8000c20c <__sfvwrite_r>
8000909c:	30 08       	mov	r8,0
8000909e:	8f 18       	st.w	r7[0x4],r8
800090a0:	8f 28       	st.w	r7[0x8],r8
800090a2:	d8 22       	popm	r4-r7,pc

800090a4 <_vfprintf_r>:
800090a4:	d4 31       	pushm	r0-r7,lr
800090a6:	fa cd 06 bc 	sub	sp,sp,1724
800090aa:	51 09       	stdsp	sp[0x40],r9
800090ac:	16 91       	mov	r1,r11
800090ae:	14 97       	mov	r7,r10
800090b0:	18 95       	mov	r5,r12
800090b2:	e0 a0 1a 1d 	rcall	8000c4ec <_localeconv_r>
800090b6:	78 0c       	ld.w	r12,r12[0x0]
800090b8:	50 cc       	stdsp	sp[0x30],r12
800090ba:	58 05       	cp.w	r5,0
800090bc:	c0 70       	breq	800090ca <_vfprintf_r+0x26>
800090be:	6a 68       	ld.w	r8,r5[0x18]
800090c0:	58 08       	cp.w	r8,0
800090c2:	c0 41       	brne	800090ca <_vfprintf_r+0x26>
800090c4:	0a 9c       	mov	r12,r5
800090c6:	e0 a0 17 43 	rcall	8000bf4c <__sinit>
800090ca:	fe c8 9c 46 	sub	r8,pc,-25530
800090ce:	10 31       	cp.w	r1,r8
800090d0:	c0 31       	brne	800090d6 <_vfprintf_r+0x32>
800090d2:	6a 01       	ld.w	r1,r5[0x0]
800090d4:	c0 c8       	rjmp	800090ec <_vfprintf_r+0x48>
800090d6:	fe c8 9c 32 	sub	r8,pc,-25550
800090da:	10 31       	cp.w	r1,r8
800090dc:	c0 31       	brne	800090e2 <_vfprintf_r+0x3e>
800090de:	6a 11       	ld.w	r1,r5[0x4]
800090e0:	c0 68       	rjmp	800090ec <_vfprintf_r+0x48>
800090e2:	fe c8 9c 1e 	sub	r8,pc,-25570
800090e6:	10 31       	cp.w	r1,r8
800090e8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800090ec:	82 68       	ld.sh	r8,r1[0xc]
800090ee:	ed b8 00 03 	bld	r8,0x3
800090f2:	c0 41       	brne	800090fa <_vfprintf_r+0x56>
800090f4:	62 48       	ld.w	r8,r1[0x10]
800090f6:	58 08       	cp.w	r8,0
800090f8:	c0 71       	brne	80009106 <_vfprintf_r+0x62>
800090fa:	02 9b       	mov	r11,r1
800090fc:	0a 9c       	mov	r12,r5
800090fe:	e0 a0 0f 5d 	rcall	8000afb8 <__swsetup_r>
80009102:	e0 81 0f 54 	brne	8000afaa <_vfprintf_r+0x1f06>
80009106:	82 68       	ld.sh	r8,r1[0xc]
80009108:	10 99       	mov	r9,r8
8000910a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000910e:	58 a9       	cp.w	r9,10
80009110:	c3 c1       	brne	80009188 <_vfprintf_r+0xe4>
80009112:	82 79       	ld.sh	r9,r1[0xe]
80009114:	30 0a       	mov	r10,0
80009116:	f4 09 19 00 	cp.h	r9,r10
8000911a:	c3 75       	brlt	80009188 <_vfprintf_r+0xe4>
8000911c:	a1 d8       	cbr	r8,0x1
8000911e:	fb 58 05 d0 	st.h	sp[1488],r8
80009122:	62 88       	ld.w	r8,r1[0x20]
80009124:	fb 48 05 e4 	st.w	sp[1508],r8
80009128:	62 a8       	ld.w	r8,r1[0x28]
8000912a:	fb 48 05 ec 	st.w	sp[1516],r8
8000912e:	fa c8 ff bc 	sub	r8,sp,-68
80009132:	fb 48 05 d4 	st.w	sp[1492],r8
80009136:	fb 48 05 c4 	st.w	sp[1476],r8
8000913a:	e0 68 04 00 	mov	r8,1024
8000913e:	fb 48 05 d8 	st.w	sp[1496],r8
80009142:	fb 48 05 cc 	st.w	sp[1484],r8
80009146:	30 08       	mov	r8,0
80009148:	fb 59 05 d2 	st.h	sp[1490],r9
8000914c:	0e 9a       	mov	r10,r7
8000914e:	41 09       	lddsp	r9,sp[0x40]
80009150:	fa c7 fa 3c 	sub	r7,sp,-1476
80009154:	fb 48 05 dc 	st.w	sp[1500],r8
80009158:	0a 9c       	mov	r12,r5
8000915a:	0e 9b       	mov	r11,r7
8000915c:	ca 4f       	rcall	800090a4 <_vfprintf_r>
8000915e:	50 bc       	stdsp	sp[0x2c],r12
80009160:	c0 95       	brlt	80009172 <_vfprintf_r+0xce>
80009162:	0e 9b       	mov	r11,r7
80009164:	0a 9c       	mov	r12,r5
80009166:	e0 a0 16 1b 	rcall	8000bd9c <_fflush_r>
8000916a:	40 be       	lddsp	lr,sp[0x2c]
8000916c:	f9 be 01 ff 	movne	lr,-1
80009170:	50 be       	stdsp	sp[0x2c],lr
80009172:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80009176:	ed b8 00 06 	bld	r8,0x6
8000917a:	e0 81 0f 1a 	brne	8000afae <_vfprintf_r+0x1f0a>
8000917e:	82 68       	ld.sh	r8,r1[0xc]
80009180:	a7 a8       	sbr	r8,0x6
80009182:	a2 68       	st.h	r1[0xc],r8
80009184:	e0 8f 0f 15 	bral	8000afae <_vfprintf_r+0x1f0a>
80009188:	30 08       	mov	r8,0
8000918a:	fb 48 06 b4 	st.w	sp[1716],r8
8000918e:	fb 48 06 90 	st.w	sp[1680],r8
80009192:	fb 48 06 8c 	st.w	sp[1676],r8
80009196:	fb 48 06 b0 	st.w	sp[1712],r8
8000919a:	30 08       	mov	r8,0
8000919c:	30 09       	mov	r9,0
8000919e:	50 a7       	stdsp	sp[0x28],r7
800091a0:	50 78       	stdsp	sp[0x1c],r8
800091a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800091a6:	3f f8       	mov	r8,-1
800091a8:	50 59       	stdsp	sp[0x14],r9
800091aa:	fb 43 06 88 	st.w	sp[1672],r3
800091ae:	fb 48 05 44 	st.w	sp[1348],r8
800091b2:	12 9c       	mov	r12,r9
800091b4:	50 69       	stdsp	sp[0x18],r9
800091b6:	50 d9       	stdsp	sp[0x34],r9
800091b8:	50 e9       	stdsp	sp[0x38],r9
800091ba:	50 b9       	stdsp	sp[0x2c],r9
800091bc:	12 97       	mov	r7,r9
800091be:	0a 94       	mov	r4,r5
800091c0:	40 a2       	lddsp	r2,sp[0x28]
800091c2:	32 5a       	mov	r10,37
800091c4:	30 08       	mov	r8,0
800091c6:	c0 28       	rjmp	800091ca <_vfprintf_r+0x126>
800091c8:	2f f2       	sub	r2,-1
800091ca:	05 89       	ld.ub	r9,r2[0x0]
800091cc:	f0 09 18 00 	cp.b	r9,r8
800091d0:	5f 1b       	srne	r11
800091d2:	f4 09 18 00 	cp.b	r9,r10
800091d6:	5f 19       	srne	r9
800091d8:	f3 eb 00 0b 	and	r11,r9,r11
800091dc:	f0 0b 18 00 	cp.b	r11,r8
800091e0:	cf 41       	brne	800091c8 <_vfprintf_r+0x124>
800091e2:	40 ab       	lddsp	r11,sp[0x28]
800091e4:	e4 0b 01 06 	sub	r6,r2,r11
800091e8:	c1 e0       	breq	80009224 <_vfprintf_r+0x180>
800091ea:	fa f8 06 90 	ld.w	r8,sp[1680]
800091ee:	0c 08       	add	r8,r6
800091f0:	87 0b       	st.w	r3[0x0],r11
800091f2:	fb 48 06 90 	st.w	sp[1680],r8
800091f6:	87 16       	st.w	r3[0x4],r6
800091f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091fc:	2f f8       	sub	r8,-1
800091fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009202:	58 78       	cp.w	r8,7
80009204:	e0 89 00 04 	brgt	8000920c <_vfprintf_r+0x168>
80009208:	2f 83       	sub	r3,-8
8000920a:	c0 a8       	rjmp	8000921e <_vfprintf_r+0x17a>
8000920c:	fa ca f9 78 	sub	r10,sp,-1672
80009210:	02 9b       	mov	r11,r1
80009212:	08 9c       	mov	r12,r4
80009214:	c3 af       	rcall	80009088 <__sprint_r>
80009216:	e0 81 0e c6 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000921a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000921e:	40 ba       	lddsp	r10,sp[0x2c]
80009220:	0c 0a       	add	r10,r6
80009222:	50 ba       	stdsp	sp[0x2c],r10
80009224:	05 89       	ld.ub	r9,r2[0x0]
80009226:	30 08       	mov	r8,0
80009228:	f0 09 18 00 	cp.b	r9,r8
8000922c:	e0 80 0e aa 	breq	8000af80 <_vfprintf_r+0x1edc>
80009230:	30 09       	mov	r9,0
80009232:	fb 68 06 bb 	st.b	sp[1723],r8
80009236:	0e 96       	mov	r6,r7
80009238:	e4 c8 ff ff 	sub	r8,r2,-1
8000923c:	3f fe       	mov	lr,-1
8000923e:	50 93       	stdsp	sp[0x24],r3
80009240:	50 41       	stdsp	sp[0x10],r1
80009242:	0e 93       	mov	r3,r7
80009244:	04 91       	mov	r1,r2
80009246:	50 89       	stdsp	sp[0x20],r9
80009248:	50 a8       	stdsp	sp[0x28],r8
8000924a:	50 2e       	stdsp	sp[0x8],lr
8000924c:	50 39       	stdsp	sp[0xc],r9
8000924e:	12 95       	mov	r5,r9
80009250:	12 90       	mov	r0,r9
80009252:	10 97       	mov	r7,r8
80009254:	08 92       	mov	r2,r4
80009256:	c0 78       	rjmp	80009264 <_vfprintf_r+0x1c0>
80009258:	3f fc       	mov	r12,-1
8000925a:	08 97       	mov	r7,r4
8000925c:	50 2c       	stdsp	sp[0x8],r12
8000925e:	c0 38       	rjmp	80009264 <_vfprintf_r+0x1c0>
80009260:	30 0b       	mov	r11,0
80009262:	50 3b       	stdsp	sp[0xc],r11
80009264:	0f 38       	ld.ub	r8,r7++
80009266:	c0 28       	rjmp	8000926a <_vfprintf_r+0x1c6>
80009268:	12 90       	mov	r0,r9
8000926a:	f0 c9 00 20 	sub	r9,r8,32
8000926e:	e0 49 00 58 	cp.w	r9,88
80009272:	e0 8b 0a 30 	brhi	8000a6d2 <_vfprintf_r+0x162e>
80009276:	fe ca a1 9a 	sub	r10,pc,-24166
8000927a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000927e:	50 a7       	stdsp	sp[0x28],r7
80009280:	50 80       	stdsp	sp[0x20],r0
80009282:	0c 97       	mov	r7,r6
80009284:	04 94       	mov	r4,r2
80009286:	06 96       	mov	r6,r3
80009288:	02 92       	mov	r2,r1
8000928a:	fe c9 9f 72 	sub	r9,pc,-24718
8000928e:	40 93       	lddsp	r3,sp[0x24]
80009290:	10 90       	mov	r0,r8
80009292:	40 41       	lddsp	r1,sp[0x10]
80009294:	50 d9       	stdsp	sp[0x34],r9
80009296:	e0 8f 08 8e 	bral	8000a3b2 <_vfprintf_r+0x130e>
8000929a:	30 08       	mov	r8,0
8000929c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800092a0:	f0 09 18 00 	cp.b	r9,r8
800092a4:	ce 01       	brne	80009264 <_vfprintf_r+0x1c0>
800092a6:	32 08       	mov	r8,32
800092a8:	c6 e8       	rjmp	80009384 <_vfprintf_r+0x2e0>
800092aa:	a1 a5       	sbr	r5,0x0
800092ac:	cd cb       	rjmp	80009264 <_vfprintf_r+0x1c0>
800092ae:	0f 89       	ld.ub	r9,r7[0x0]
800092b0:	f2 c8 00 30 	sub	r8,r9,48
800092b4:	58 98       	cp.w	r8,9
800092b6:	e0 8b 00 1d 	brhi	800092f0 <_vfprintf_r+0x24c>
800092ba:	ee c8 ff ff 	sub	r8,r7,-1
800092be:	30 0b       	mov	r11,0
800092c0:	23 09       	sub	r9,48
800092c2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800092c6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800092ca:	11 39       	ld.ub	r9,r8++
800092cc:	f2 ca 00 30 	sub	r10,r9,48
800092d0:	58 9a       	cp.w	r10,9
800092d2:	fe 98 ff f7 	brls	800092c0 <_vfprintf_r+0x21c>
800092d6:	e0 49 00 24 	cp.w	r9,36
800092da:	cc 31       	brne	80009260 <_vfprintf_r+0x1bc>
800092dc:	e0 4b 00 20 	cp.w	r11,32
800092e0:	e0 89 0e 60 	brgt	8000afa0 <_vfprintf_r+0x1efc>
800092e4:	20 1b       	sub	r11,1
800092e6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092ea:	12 3b       	cp.w	r11,r9
800092ec:	c0 95       	brlt	800092fe <_vfprintf_r+0x25a>
800092ee:	c1 08       	rjmp	8000930e <_vfprintf_r+0x26a>
800092f0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092f4:	ec ca ff ff 	sub	r10,r6,-1
800092f8:	12 36       	cp.w	r6,r9
800092fa:	c1 f5       	brlt	80009338 <_vfprintf_r+0x294>
800092fc:	c2 68       	rjmp	80009348 <_vfprintf_r+0x2a4>
800092fe:	fa ce f9 44 	sub	lr,sp,-1724
80009302:	10 97       	mov	r7,r8
80009304:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80009308:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000930c:	c3 58       	rjmp	80009376 <_vfprintf_r+0x2d2>
8000930e:	10 97       	mov	r7,r8
80009310:	fa c8 f9 50 	sub	r8,sp,-1712
80009314:	1a d8       	st.w	--sp,r8
80009316:	fa c8 fa b8 	sub	r8,sp,-1352
8000931a:	1a d8       	st.w	--sp,r8
8000931c:	fa c8 fb b4 	sub	r8,sp,-1100
80009320:	02 9a       	mov	r10,r1
80009322:	1a d8       	st.w	--sp,r8
80009324:	04 9c       	mov	r12,r2
80009326:	fa c8 f9 40 	sub	r8,sp,-1728
8000932a:	fa c9 ff b4 	sub	r9,sp,-76
8000932e:	fe b0 fd 23 	rcall	80008d74 <get_arg>
80009332:	2f dd       	sub	sp,-12
80009334:	78 00       	ld.w	r0,r12[0x0]
80009336:	c2 08       	rjmp	80009376 <_vfprintf_r+0x2d2>
80009338:	fa cc f9 44 	sub	r12,sp,-1724
8000933c:	14 96       	mov	r6,r10
8000933e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80009342:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80009346:	c1 88       	rjmp	80009376 <_vfprintf_r+0x2d2>
80009348:	41 08       	lddsp	r8,sp[0x40]
8000934a:	59 f9       	cp.w	r9,31
8000934c:	e0 89 00 11 	brgt	8000936e <_vfprintf_r+0x2ca>
80009350:	f0 cb ff fc 	sub	r11,r8,-4
80009354:	51 0b       	stdsp	sp[0x40],r11
80009356:	70 00       	ld.w	r0,r8[0x0]
80009358:	fa cb f9 44 	sub	r11,sp,-1724
8000935c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80009360:	f1 40 fd 88 	st.w	r8[-632],r0
80009364:	2f f9       	sub	r9,-1
80009366:	14 96       	mov	r6,r10
80009368:	fb 49 06 b4 	st.w	sp[1716],r9
8000936c:	c0 58       	rjmp	80009376 <_vfprintf_r+0x2d2>
8000936e:	70 00       	ld.w	r0,r8[0x0]
80009370:	14 96       	mov	r6,r10
80009372:	2f c8       	sub	r8,-4
80009374:	51 08       	stdsp	sp[0x40],r8
80009376:	58 00       	cp.w	r0,0
80009378:	fe 94 ff 76 	brge	80009264 <_vfprintf_r+0x1c0>
8000937c:	5c 30       	neg	r0
8000937e:	a3 a5       	sbr	r5,0x2
80009380:	c7 2b       	rjmp	80009264 <_vfprintf_r+0x1c0>
80009382:	32 b8       	mov	r8,43
80009384:	fb 68 06 bb 	st.b	sp[1723],r8
80009388:	c6 eb       	rjmp	80009264 <_vfprintf_r+0x1c0>
8000938a:	0f 38       	ld.ub	r8,r7++
8000938c:	e0 48 00 2a 	cp.w	r8,42
80009390:	c0 30       	breq	80009396 <_vfprintf_r+0x2f2>
80009392:	30 09       	mov	r9,0
80009394:	c7 98       	rjmp	80009486 <_vfprintf_r+0x3e2>
80009396:	0f 88       	ld.ub	r8,r7[0x0]
80009398:	f0 c9 00 30 	sub	r9,r8,48
8000939c:	58 99       	cp.w	r9,9
8000939e:	e0 8b 00 1f 	brhi	800093dc <_vfprintf_r+0x338>
800093a2:	ee c4 ff ff 	sub	r4,r7,-1
800093a6:	30 0b       	mov	r11,0
800093a8:	23 08       	sub	r8,48
800093aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800093ae:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800093b2:	09 38       	ld.ub	r8,r4++
800093b4:	f0 c9 00 30 	sub	r9,r8,48
800093b8:	58 99       	cp.w	r9,9
800093ba:	fe 98 ff f7 	brls	800093a8 <_vfprintf_r+0x304>
800093be:	e0 48 00 24 	cp.w	r8,36
800093c2:	fe 91 ff 4f 	brne	80009260 <_vfprintf_r+0x1bc>
800093c6:	e0 4b 00 20 	cp.w	r11,32
800093ca:	e0 89 0d eb 	brgt	8000afa0 <_vfprintf_r+0x1efc>
800093ce:	20 1b       	sub	r11,1
800093d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093d4:	10 3b       	cp.w	r11,r8
800093d6:	c0 a5       	brlt	800093ea <_vfprintf_r+0x346>
800093d8:	c1 18       	rjmp	800093fa <_vfprintf_r+0x356>
800093da:	d7 03       	nop
800093dc:	fa fa 06 b4 	ld.w	r10,sp[1716]
800093e0:	ec c9 ff ff 	sub	r9,r6,-1
800093e4:	14 36       	cp.w	r6,r10
800093e6:	c1 f5       	brlt	80009424 <_vfprintf_r+0x380>
800093e8:	c2 88       	rjmp	80009438 <_vfprintf_r+0x394>
800093ea:	fa ca f9 44 	sub	r10,sp,-1724
800093ee:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800093f2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800093f6:	50 2b       	stdsp	sp[0x8],r11
800093f8:	c3 c8       	rjmp	80009470 <_vfprintf_r+0x3cc>
800093fa:	fa c8 f9 50 	sub	r8,sp,-1712
800093fe:	1a d8       	st.w	--sp,r8
80009400:	fa c8 fa b8 	sub	r8,sp,-1352
80009404:	1a d8       	st.w	--sp,r8
80009406:	fa c8 fb b4 	sub	r8,sp,-1100
8000940a:	02 9a       	mov	r10,r1
8000940c:	1a d8       	st.w	--sp,r8
8000940e:	04 9c       	mov	r12,r2
80009410:	fa c8 f9 40 	sub	r8,sp,-1728
80009414:	fa c9 ff b4 	sub	r9,sp,-76
80009418:	fe b0 fc ae 	rcall	80008d74 <get_arg>
8000941c:	2f dd       	sub	sp,-12
8000941e:	78 0c       	ld.w	r12,r12[0x0]
80009420:	50 2c       	stdsp	sp[0x8],r12
80009422:	c2 78       	rjmp	80009470 <_vfprintf_r+0x3cc>
80009424:	12 96       	mov	r6,r9
80009426:	0e 94       	mov	r4,r7
80009428:	fa c9 f9 44 	sub	r9,sp,-1724
8000942c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80009430:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80009434:	50 28       	stdsp	sp[0x8],r8
80009436:	c1 d8       	rjmp	80009470 <_vfprintf_r+0x3cc>
80009438:	41 08       	lddsp	r8,sp[0x40]
8000943a:	59 fa       	cp.w	r10,31
8000943c:	e0 89 00 14 	brgt	80009464 <_vfprintf_r+0x3c0>
80009440:	f0 cb ff fc 	sub	r11,r8,-4
80009444:	70 08       	ld.w	r8,r8[0x0]
80009446:	51 0b       	stdsp	sp[0x40],r11
80009448:	50 28       	stdsp	sp[0x8],r8
8000944a:	fa c6 f9 44 	sub	r6,sp,-1724
8000944e:	40 2e       	lddsp	lr,sp[0x8]
80009450:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80009454:	f1 4e fd 88 	st.w	r8[-632],lr
80009458:	2f fa       	sub	r10,-1
8000945a:	0e 94       	mov	r4,r7
8000945c:	fb 4a 06 b4 	st.w	sp[1716],r10
80009460:	12 96       	mov	r6,r9
80009462:	c0 78       	rjmp	80009470 <_vfprintf_r+0x3cc>
80009464:	70 0c       	ld.w	r12,r8[0x0]
80009466:	0e 94       	mov	r4,r7
80009468:	2f c8       	sub	r8,-4
8000946a:	50 2c       	stdsp	sp[0x8],r12
8000946c:	12 96       	mov	r6,r9
8000946e:	51 08       	stdsp	sp[0x40],r8
80009470:	40 2b       	lddsp	r11,sp[0x8]
80009472:	58 0b       	cp.w	r11,0
80009474:	fe 95 fe f2 	brlt	80009258 <_vfprintf_r+0x1b4>
80009478:	08 97       	mov	r7,r4
8000947a:	cf 5a       	rjmp	80009264 <_vfprintf_r+0x1c0>
8000947c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009480:	0f 38       	ld.ub	r8,r7++
80009482:	f4 09 00 19 	add	r9,r10,r9<<0x1
80009486:	f0 ca 00 30 	sub	r10,r8,48
8000948a:	58 9a       	cp.w	r10,9
8000948c:	fe 98 ff f8 	brls	8000947c <_vfprintf_r+0x3d8>
80009490:	3f fa       	mov	r10,-1
80009492:	f2 0a 0c 49 	max	r9,r9,r10
80009496:	50 29       	stdsp	sp[0x8],r9
80009498:	ce 9a       	rjmp	8000926a <_vfprintf_r+0x1c6>
8000949a:	a7 b5       	sbr	r5,0x7
8000949c:	ce 4a       	rjmp	80009264 <_vfprintf_r+0x1c0>
8000949e:	30 09       	mov	r9,0
800094a0:	23 08       	sub	r8,48
800094a2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800094a6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800094aa:	0f 38       	ld.ub	r8,r7++
800094ac:	f0 ca 00 30 	sub	r10,r8,48
800094b0:	58 9a       	cp.w	r10,9
800094b2:	fe 98 ff f7 	brls	800094a0 <_vfprintf_r+0x3fc>
800094b6:	e0 48 00 24 	cp.w	r8,36
800094ba:	fe 91 fe d7 	brne	80009268 <_vfprintf_r+0x1c4>
800094be:	e0 49 00 20 	cp.w	r9,32
800094c2:	e0 89 0d 6f 	brgt	8000afa0 <_vfprintf_r+0x1efc>
800094c6:	f2 c3 00 01 	sub	r3,r9,1
800094ca:	30 19       	mov	r9,1
800094cc:	50 39       	stdsp	sp[0xc],r9
800094ce:	cc ba       	rjmp	80009264 <_vfprintf_r+0x1c0>
800094d0:	a3 b5       	sbr	r5,0x3
800094d2:	cc 9a       	rjmp	80009264 <_vfprintf_r+0x1c0>
800094d4:	a7 a5       	sbr	r5,0x6
800094d6:	cc 7a       	rjmp	80009264 <_vfprintf_r+0x1c0>
800094d8:	0a 98       	mov	r8,r5
800094da:	a5 b5       	sbr	r5,0x5
800094dc:	a5 a8       	sbr	r8,0x4
800094de:	0f 89       	ld.ub	r9,r7[0x0]
800094e0:	36 ce       	mov	lr,108
800094e2:	fc 09 18 00 	cp.b	r9,lr
800094e6:	f7 b7 00 ff 	subeq	r7,-1
800094ea:	f0 05 17 10 	movne	r5,r8
800094ee:	cb ba       	rjmp	80009264 <_vfprintf_r+0x1c0>
800094f0:	a5 b5       	sbr	r5,0x5
800094f2:	cb 9a       	rjmp	80009264 <_vfprintf_r+0x1c0>
800094f4:	50 a7       	stdsp	sp[0x28],r7
800094f6:	50 80       	stdsp	sp[0x20],r0
800094f8:	0c 97       	mov	r7,r6
800094fa:	10 90       	mov	r0,r8
800094fc:	06 96       	mov	r6,r3
800094fe:	04 94       	mov	r4,r2
80009500:	40 93       	lddsp	r3,sp[0x24]
80009502:	02 92       	mov	r2,r1
80009504:	0e 99       	mov	r9,r7
80009506:	40 41       	lddsp	r1,sp[0x10]
80009508:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000950c:	40 3c       	lddsp	r12,sp[0xc]
8000950e:	58 0c       	cp.w	r12,0
80009510:	c1 d0       	breq	8000954a <_vfprintf_r+0x4a6>
80009512:	10 36       	cp.w	r6,r8
80009514:	c0 64       	brge	80009520 <_vfprintf_r+0x47c>
80009516:	fa cb f9 44 	sub	r11,sp,-1724
8000951a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000951e:	c1 d8       	rjmp	80009558 <_vfprintf_r+0x4b4>
80009520:	fa c8 f9 50 	sub	r8,sp,-1712
80009524:	1a d8       	st.w	--sp,r8
80009526:	fa c8 fa b8 	sub	r8,sp,-1352
8000952a:	1a d8       	st.w	--sp,r8
8000952c:	fa c8 fb b4 	sub	r8,sp,-1100
80009530:	1a d8       	st.w	--sp,r8
80009532:	fa c8 f9 40 	sub	r8,sp,-1728
80009536:	fa c9 ff b4 	sub	r9,sp,-76
8000953a:	04 9a       	mov	r10,r2
8000953c:	0c 9b       	mov	r11,r6
8000953e:	08 9c       	mov	r12,r4
80009540:	fe b0 fc 1a 	rcall	80008d74 <get_arg>
80009544:	2f dd       	sub	sp,-12
80009546:	19 b8       	ld.ub	r8,r12[0x3]
80009548:	c2 28       	rjmp	8000958c <_vfprintf_r+0x4e8>
8000954a:	2f f7       	sub	r7,-1
8000954c:	10 39       	cp.w	r9,r8
8000954e:	c0 84       	brge	8000955e <_vfprintf_r+0x4ba>
80009550:	fa ca f9 44 	sub	r10,sp,-1724
80009554:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009558:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000955c:	c1 88       	rjmp	8000958c <_vfprintf_r+0x4e8>
8000955e:	41 09       	lddsp	r9,sp[0x40]
80009560:	59 f8       	cp.w	r8,31
80009562:	e0 89 00 12 	brgt	80009586 <_vfprintf_r+0x4e2>
80009566:	f2 ca ff fc 	sub	r10,r9,-4
8000956a:	51 0a       	stdsp	sp[0x40],r10
8000956c:	72 09       	ld.w	r9,r9[0x0]
8000956e:	fa c6 f9 44 	sub	r6,sp,-1724
80009572:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009576:	2f f8       	sub	r8,-1
80009578:	f5 49 fd 88 	st.w	r10[-632],r9
8000957c:	fb 48 06 b4 	st.w	sp[1716],r8
80009580:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80009584:	c0 48       	rjmp	8000958c <_vfprintf_r+0x4e8>
80009586:	13 b8       	ld.ub	r8,r9[0x3]
80009588:	2f c9       	sub	r9,-4
8000958a:	51 09       	stdsp	sp[0x40],r9
8000958c:	fb 68 06 60 	st.b	sp[1632],r8
80009590:	30 0e       	mov	lr,0
80009592:	30 08       	mov	r8,0
80009594:	30 12       	mov	r2,1
80009596:	fb 68 06 bb 	st.b	sp[1723],r8
8000959a:	50 2e       	stdsp	sp[0x8],lr
8000959c:	e0 8f 08 ad 	bral	8000a6f6 <_vfprintf_r+0x1652>
800095a0:	50 a7       	stdsp	sp[0x28],r7
800095a2:	50 80       	stdsp	sp[0x20],r0
800095a4:	0c 97       	mov	r7,r6
800095a6:	04 94       	mov	r4,r2
800095a8:	06 96       	mov	r6,r3
800095aa:	02 92       	mov	r2,r1
800095ac:	40 93       	lddsp	r3,sp[0x24]
800095ae:	10 90       	mov	r0,r8
800095b0:	40 41       	lddsp	r1,sp[0x10]
800095b2:	a5 a5       	sbr	r5,0x4
800095b4:	c0 a8       	rjmp	800095c8 <_vfprintf_r+0x524>
800095b6:	50 a7       	stdsp	sp[0x28],r7
800095b8:	50 80       	stdsp	sp[0x20],r0
800095ba:	0c 97       	mov	r7,r6
800095bc:	04 94       	mov	r4,r2
800095be:	06 96       	mov	r6,r3
800095c0:	02 92       	mov	r2,r1
800095c2:	40 93       	lddsp	r3,sp[0x24]
800095c4:	10 90       	mov	r0,r8
800095c6:	40 41       	lddsp	r1,sp[0x10]
800095c8:	ed b5 00 05 	bld	r5,0x5
800095cc:	c5 11       	brne	8000966e <_vfprintf_r+0x5ca>
800095ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095d2:	40 3c       	lddsp	r12,sp[0xc]
800095d4:	58 0c       	cp.w	r12,0
800095d6:	c1 e0       	breq	80009612 <_vfprintf_r+0x56e>
800095d8:	10 36       	cp.w	r6,r8
800095da:	c0 64       	brge	800095e6 <_vfprintf_r+0x542>
800095dc:	fa cb f9 44 	sub	r11,sp,-1724
800095e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095e4:	c2 08       	rjmp	80009624 <_vfprintf_r+0x580>
800095e6:	fa c8 f9 50 	sub	r8,sp,-1712
800095ea:	1a d8       	st.w	--sp,r8
800095ec:	fa c8 fa b8 	sub	r8,sp,-1352
800095f0:	0c 9b       	mov	r11,r6
800095f2:	1a d8       	st.w	--sp,r8
800095f4:	fa c8 fb b4 	sub	r8,sp,-1100
800095f8:	1a d8       	st.w	--sp,r8
800095fa:	fa c9 ff b4 	sub	r9,sp,-76
800095fe:	fa c8 f9 40 	sub	r8,sp,-1728
80009602:	04 9a       	mov	r10,r2
80009604:	08 9c       	mov	r12,r4
80009606:	fe b0 fb b7 	rcall	80008d74 <get_arg>
8000960a:	2f dd       	sub	sp,-12
8000960c:	78 1b       	ld.w	r11,r12[0x4]
8000960e:	78 09       	ld.w	r9,r12[0x0]
80009610:	c2 b8       	rjmp	80009666 <_vfprintf_r+0x5c2>
80009612:	ee ca ff ff 	sub	r10,r7,-1
80009616:	10 37       	cp.w	r7,r8
80009618:	c0 b4       	brge	8000962e <_vfprintf_r+0x58a>
8000961a:	fa c9 f9 44 	sub	r9,sp,-1724
8000961e:	14 97       	mov	r7,r10
80009620:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009624:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009628:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000962c:	c1 d8       	rjmp	80009666 <_vfprintf_r+0x5c2>
8000962e:	41 09       	lddsp	r9,sp[0x40]
80009630:	59 f8       	cp.w	r8,31
80009632:	e0 89 00 14 	brgt	8000965a <_vfprintf_r+0x5b6>
80009636:	f2 cb ff f8 	sub	r11,r9,-8
8000963a:	51 0b       	stdsp	sp[0x40],r11
8000963c:	fa c6 f9 44 	sub	r6,sp,-1724
80009640:	72 1b       	ld.w	r11,r9[0x4]
80009642:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80009646:	72 09       	ld.w	r9,r9[0x0]
80009648:	f9 4b fd 8c 	st.w	r12[-628],r11
8000964c:	f9 49 fd 88 	st.w	r12[-632],r9
80009650:	2f f8       	sub	r8,-1
80009652:	14 97       	mov	r7,r10
80009654:	fb 48 06 b4 	st.w	sp[1716],r8
80009658:	c0 78       	rjmp	80009666 <_vfprintf_r+0x5c2>
8000965a:	f2 c8 ff f8 	sub	r8,r9,-8
8000965e:	72 1b       	ld.w	r11,r9[0x4]
80009660:	14 97       	mov	r7,r10
80009662:	51 08       	stdsp	sp[0x40],r8
80009664:	72 09       	ld.w	r9,r9[0x0]
80009666:	16 98       	mov	r8,r11
80009668:	fa e9 00 00 	st.d	sp[0],r8
8000966c:	ca e8       	rjmp	800097c8 <_vfprintf_r+0x724>
8000966e:	ed b5 00 04 	bld	r5,0x4
80009672:	c1 71       	brne	800096a0 <_vfprintf_r+0x5fc>
80009674:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009678:	40 3e       	lddsp	lr,sp[0xc]
8000967a:	58 0e       	cp.w	lr,0
8000967c:	c0 80       	breq	8000968c <_vfprintf_r+0x5e8>
8000967e:	10 36       	cp.w	r6,r8
80009680:	c6 94       	brge	80009752 <_vfprintf_r+0x6ae>
80009682:	fa cc f9 44 	sub	r12,sp,-1724
80009686:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000968a:	c8 28       	rjmp	8000978e <_vfprintf_r+0x6ea>
8000968c:	ee ca ff ff 	sub	r10,r7,-1
80009690:	10 37       	cp.w	r7,r8
80009692:	e0 84 00 81 	brge	80009794 <_vfprintf_r+0x6f0>
80009696:	fa cb f9 44 	sub	r11,sp,-1724
8000969a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000969e:	c7 78       	rjmp	8000978c <_vfprintf_r+0x6e8>
800096a0:	ed b5 00 06 	bld	r5,0x6
800096a4:	c4 b1       	brne	8000973a <_vfprintf_r+0x696>
800096a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096aa:	40 3c       	lddsp	r12,sp[0xc]
800096ac:	58 0c       	cp.w	r12,0
800096ae:	c1 d0       	breq	800096e8 <_vfprintf_r+0x644>
800096b0:	10 36       	cp.w	r6,r8
800096b2:	c0 64       	brge	800096be <_vfprintf_r+0x61a>
800096b4:	fa cb f9 44 	sub	r11,sp,-1724
800096b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096bc:	c1 f8       	rjmp	800096fa <_vfprintf_r+0x656>
800096be:	fa c8 f9 50 	sub	r8,sp,-1712
800096c2:	1a d8       	st.w	--sp,r8
800096c4:	fa c8 fa b8 	sub	r8,sp,-1352
800096c8:	1a d8       	st.w	--sp,r8
800096ca:	fa c8 fb b4 	sub	r8,sp,-1100
800096ce:	1a d8       	st.w	--sp,r8
800096d0:	fa c8 f9 40 	sub	r8,sp,-1728
800096d4:	fa c9 ff b4 	sub	r9,sp,-76
800096d8:	04 9a       	mov	r10,r2
800096da:	0c 9b       	mov	r11,r6
800096dc:	08 9c       	mov	r12,r4
800096de:	fe b0 fb 4b 	rcall	80008d74 <get_arg>
800096e2:	2f dd       	sub	sp,-12
800096e4:	98 18       	ld.sh	r8,r12[0x2]
800096e6:	c2 68       	rjmp	80009732 <_vfprintf_r+0x68e>
800096e8:	ee ca ff ff 	sub	r10,r7,-1
800096ec:	10 37       	cp.w	r7,r8
800096ee:	c0 94       	brge	80009700 <_vfprintf_r+0x65c>
800096f0:	fa c9 f9 44 	sub	r9,sp,-1724
800096f4:	14 97       	mov	r7,r10
800096f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800096fe:	c1 a8       	rjmp	80009732 <_vfprintf_r+0x68e>
80009700:	41 09       	lddsp	r9,sp[0x40]
80009702:	59 f8       	cp.w	r8,31
80009704:	e0 89 00 13 	brgt	8000972a <_vfprintf_r+0x686>
80009708:	f2 cb ff fc 	sub	r11,r9,-4
8000970c:	51 0b       	stdsp	sp[0x40],r11
8000970e:	72 09       	ld.w	r9,r9[0x0]
80009710:	fa c6 f9 44 	sub	r6,sp,-1724
80009714:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009718:	2f f8       	sub	r8,-1
8000971a:	f7 49 fd 88 	st.w	r11[-632],r9
8000971e:	fb 48 06 b4 	st.w	sp[1716],r8
80009722:	14 97       	mov	r7,r10
80009724:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009728:	c0 58       	rjmp	80009732 <_vfprintf_r+0x68e>
8000972a:	92 18       	ld.sh	r8,r9[0x2]
8000972c:	14 97       	mov	r7,r10
8000972e:	2f c9       	sub	r9,-4
80009730:	51 09       	stdsp	sp[0x40],r9
80009732:	50 18       	stdsp	sp[0x4],r8
80009734:	bf 58       	asr	r8,0x1f
80009736:	50 08       	stdsp	sp[0x0],r8
80009738:	c4 88       	rjmp	800097c8 <_vfprintf_r+0x724>
8000973a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000973e:	40 3c       	lddsp	r12,sp[0xc]
80009740:	58 0c       	cp.w	r12,0
80009742:	c1 d0       	breq	8000977c <_vfprintf_r+0x6d8>
80009744:	10 36       	cp.w	r6,r8
80009746:	c0 64       	brge	80009752 <_vfprintf_r+0x6ae>
80009748:	fa cb f9 44 	sub	r11,sp,-1724
8000974c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009750:	c1 f8       	rjmp	8000978e <_vfprintf_r+0x6ea>
80009752:	fa c8 f9 50 	sub	r8,sp,-1712
80009756:	1a d8       	st.w	--sp,r8
80009758:	fa c8 fa b8 	sub	r8,sp,-1352
8000975c:	0c 9b       	mov	r11,r6
8000975e:	1a d8       	st.w	--sp,r8
80009760:	fa c8 fb b4 	sub	r8,sp,-1100
80009764:	04 9a       	mov	r10,r2
80009766:	1a d8       	st.w	--sp,r8
80009768:	08 9c       	mov	r12,r4
8000976a:	fa c8 f9 40 	sub	r8,sp,-1728
8000976e:	fa c9 ff b4 	sub	r9,sp,-76
80009772:	fe b0 fb 01 	rcall	80008d74 <get_arg>
80009776:	2f dd       	sub	sp,-12
80009778:	78 0b       	ld.w	r11,r12[0x0]
8000977a:	c2 48       	rjmp	800097c2 <_vfprintf_r+0x71e>
8000977c:	ee ca ff ff 	sub	r10,r7,-1
80009780:	10 37       	cp.w	r7,r8
80009782:	c0 94       	brge	80009794 <_vfprintf_r+0x6f0>
80009784:	fa c9 f9 44 	sub	r9,sp,-1724
80009788:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000978c:	14 97       	mov	r7,r10
8000978e:	ec fb fd 88 	ld.w	r11,r6[-632]
80009792:	c1 88       	rjmp	800097c2 <_vfprintf_r+0x71e>
80009794:	41 09       	lddsp	r9,sp[0x40]
80009796:	59 f8       	cp.w	r8,31
80009798:	e0 89 00 11 	brgt	800097ba <_vfprintf_r+0x716>
8000979c:	f2 cb ff fc 	sub	r11,r9,-4
800097a0:	51 0b       	stdsp	sp[0x40],r11
800097a2:	fa c6 f9 44 	sub	r6,sp,-1724
800097a6:	72 0b       	ld.w	r11,r9[0x0]
800097a8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800097ac:	f3 4b fd 88 	st.w	r9[-632],r11
800097b0:	2f f8       	sub	r8,-1
800097b2:	14 97       	mov	r7,r10
800097b4:	fb 48 06 b4 	st.w	sp[1716],r8
800097b8:	c0 58       	rjmp	800097c2 <_vfprintf_r+0x71e>
800097ba:	72 0b       	ld.w	r11,r9[0x0]
800097bc:	14 97       	mov	r7,r10
800097be:	2f c9       	sub	r9,-4
800097c0:	51 09       	stdsp	sp[0x40],r9
800097c2:	50 1b       	stdsp	sp[0x4],r11
800097c4:	bf 5b       	asr	r11,0x1f
800097c6:	50 0b       	stdsp	sp[0x0],r11
800097c8:	fa ea 00 00 	ld.d	r10,sp[0]
800097cc:	58 0a       	cp.w	r10,0
800097ce:	5c 2b       	cpc	r11
800097d0:	c0 e4       	brge	800097ec <_vfprintf_r+0x748>
800097d2:	30 08       	mov	r8,0
800097d4:	fa ea 00 00 	ld.d	r10,sp[0]
800097d8:	30 09       	mov	r9,0
800097da:	f0 0a 01 0a 	sub	r10,r8,r10
800097de:	f2 0b 01 4b 	sbc	r11,r9,r11
800097e2:	32 d8       	mov	r8,45
800097e4:	fa eb 00 00 	st.d	sp[0],r10
800097e8:	fb 68 06 bb 	st.b	sp[1723],r8
800097ec:	30 18       	mov	r8,1
800097ee:	e0 8f 06 fa 	bral	8000a5e2 <_vfprintf_r+0x153e>
800097f2:	50 a7       	stdsp	sp[0x28],r7
800097f4:	50 80       	stdsp	sp[0x20],r0
800097f6:	0c 97       	mov	r7,r6
800097f8:	04 94       	mov	r4,r2
800097fa:	06 96       	mov	r6,r3
800097fc:	02 92       	mov	r2,r1
800097fe:	40 93       	lddsp	r3,sp[0x24]
80009800:	10 90       	mov	r0,r8
80009802:	40 41       	lddsp	r1,sp[0x10]
80009804:	0e 99       	mov	r9,r7
80009806:	ed b5 00 03 	bld	r5,0x3
8000980a:	c4 11       	brne	8000988c <_vfprintf_r+0x7e8>
8000980c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009810:	40 3a       	lddsp	r10,sp[0xc]
80009812:	58 0a       	cp.w	r10,0
80009814:	c1 90       	breq	80009846 <_vfprintf_r+0x7a2>
80009816:	10 36       	cp.w	r6,r8
80009818:	c6 45       	brlt	800098e0 <_vfprintf_r+0x83c>
8000981a:	fa c8 f9 50 	sub	r8,sp,-1712
8000981e:	1a d8       	st.w	--sp,r8
80009820:	fa c8 fa b8 	sub	r8,sp,-1352
80009824:	1a d8       	st.w	--sp,r8
80009826:	fa c8 fb b4 	sub	r8,sp,-1100
8000982a:	0c 9b       	mov	r11,r6
8000982c:	1a d8       	st.w	--sp,r8
8000982e:	04 9a       	mov	r10,r2
80009830:	fa c8 f9 40 	sub	r8,sp,-1728
80009834:	fa c9 ff b4 	sub	r9,sp,-76
80009838:	08 9c       	mov	r12,r4
8000983a:	fe b0 fa 9d 	rcall	80008d74 <get_arg>
8000983e:	2f dd       	sub	sp,-12
80009840:	78 16       	ld.w	r6,r12[0x4]
80009842:	50 76       	stdsp	sp[0x1c],r6
80009844:	c4 88       	rjmp	800098d4 <_vfprintf_r+0x830>
80009846:	2f f7       	sub	r7,-1
80009848:	10 39       	cp.w	r9,r8
8000984a:	c0 c4       	brge	80009862 <_vfprintf_r+0x7be>
8000984c:	fa ce f9 44 	sub	lr,sp,-1724
80009850:	fc 06 00 36 	add	r6,lr,r6<<0x3
80009854:	ec fc fd 8c 	ld.w	r12,r6[-628]
80009858:	50 7c       	stdsp	sp[0x1c],r12
8000985a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000985e:	50 56       	stdsp	sp[0x14],r6
80009860:	c6 68       	rjmp	8000992c <_vfprintf_r+0x888>
80009862:	41 09       	lddsp	r9,sp[0x40]
80009864:	59 f8       	cp.w	r8,31
80009866:	e0 89 00 10 	brgt	80009886 <_vfprintf_r+0x7e2>
8000986a:	f2 ca ff f8 	sub	r10,r9,-8
8000986e:	72 1b       	ld.w	r11,r9[0x4]
80009870:	51 0a       	stdsp	sp[0x40],r10
80009872:	72 09       	ld.w	r9,r9[0x0]
80009874:	fa ca f9 44 	sub	r10,sp,-1724
80009878:	50 7b       	stdsp	sp[0x1c],r11
8000987a:	50 59       	stdsp	sp[0x14],r9
8000987c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009880:	40 5b       	lddsp	r11,sp[0x14]
80009882:	40 7a       	lddsp	r10,sp[0x1c]
80009884:	c4 78       	rjmp	80009912 <_vfprintf_r+0x86e>
80009886:	72 18       	ld.w	r8,r9[0x4]
80009888:	50 78       	stdsp	sp[0x1c],r8
8000988a:	c4 c8       	rjmp	80009922 <_vfprintf_r+0x87e>
8000988c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009890:	40 3e       	lddsp	lr,sp[0xc]
80009892:	58 0e       	cp.w	lr,0
80009894:	c2 30       	breq	800098da <_vfprintf_r+0x836>
80009896:	10 36       	cp.w	r6,r8
80009898:	c0 94       	brge	800098aa <_vfprintf_r+0x806>
8000989a:	fa cc f9 44 	sub	r12,sp,-1724
8000989e:	f8 06 00 36 	add	r6,r12,r6<<0x3
800098a2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800098a6:	50 7b       	stdsp	sp[0x1c],r11
800098a8:	cd 9b       	rjmp	8000985a <_vfprintf_r+0x7b6>
800098aa:	fa c8 f9 50 	sub	r8,sp,-1712
800098ae:	1a d8       	st.w	--sp,r8
800098b0:	fa c8 fa b8 	sub	r8,sp,-1352
800098b4:	04 9a       	mov	r10,r2
800098b6:	1a d8       	st.w	--sp,r8
800098b8:	fa c8 fb b4 	sub	r8,sp,-1100
800098bc:	0c 9b       	mov	r11,r6
800098be:	1a d8       	st.w	--sp,r8
800098c0:	08 9c       	mov	r12,r4
800098c2:	fa c8 f9 40 	sub	r8,sp,-1728
800098c6:	fa c9 ff b4 	sub	r9,sp,-76
800098ca:	fe b0 fa 55 	rcall	80008d74 <get_arg>
800098ce:	2f dd       	sub	sp,-12
800098d0:	78 1a       	ld.w	r10,r12[0x4]
800098d2:	50 7a       	stdsp	sp[0x1c],r10
800098d4:	78 0c       	ld.w	r12,r12[0x0]
800098d6:	50 5c       	stdsp	sp[0x14],r12
800098d8:	c2 a8       	rjmp	8000992c <_vfprintf_r+0x888>
800098da:	2f f7       	sub	r7,-1
800098dc:	10 39       	cp.w	r9,r8
800098de:	c0 94       	brge	800098f0 <_vfprintf_r+0x84c>
800098e0:	fa c9 f9 44 	sub	r9,sp,-1724
800098e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800098e8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800098ec:	50 78       	stdsp	sp[0x1c],r8
800098ee:	cb 6b       	rjmp	8000985a <_vfprintf_r+0x7b6>
800098f0:	41 09       	lddsp	r9,sp[0x40]
800098f2:	59 f8       	cp.w	r8,31
800098f4:	e0 89 00 15 	brgt	8000991e <_vfprintf_r+0x87a>
800098f8:	f2 ca ff f8 	sub	r10,r9,-8
800098fc:	72 16       	ld.w	r6,r9[0x4]
800098fe:	72 09       	ld.w	r9,r9[0x0]
80009900:	51 0a       	stdsp	sp[0x40],r10
80009902:	50 59       	stdsp	sp[0x14],r9
80009904:	fa ce f9 44 	sub	lr,sp,-1724
80009908:	50 76       	stdsp	sp[0x1c],r6
8000990a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000990e:	40 5b       	lddsp	r11,sp[0x14]
80009910:	0c 9a       	mov	r10,r6
80009912:	f2 eb fd 88 	st.d	r9[-632],r10
80009916:	2f f8       	sub	r8,-1
80009918:	fb 48 06 b4 	st.w	sp[1716],r8
8000991c:	c0 88       	rjmp	8000992c <_vfprintf_r+0x888>
8000991e:	72 1c       	ld.w	r12,r9[0x4]
80009920:	50 7c       	stdsp	sp[0x1c],r12
80009922:	f2 c8 ff f8 	sub	r8,r9,-8
80009926:	51 08       	stdsp	sp[0x40],r8
80009928:	72 09       	ld.w	r9,r9[0x0]
8000992a:	50 59       	stdsp	sp[0x14],r9
8000992c:	40 5b       	lddsp	r11,sp[0x14]
8000992e:	40 7a       	lddsp	r10,sp[0x1c]
80009930:	e0 a0 19 54 	rcall	8000cbd8 <__isinfd>
80009934:	18 96       	mov	r6,r12
80009936:	c1 70       	breq	80009964 <_vfprintf_r+0x8c0>
80009938:	30 08       	mov	r8,0
8000993a:	30 09       	mov	r9,0
8000993c:	40 5b       	lddsp	r11,sp[0x14]
8000993e:	40 7a       	lddsp	r10,sp[0x1c]
80009940:	e0 a0 1d b4 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
80009944:	c0 40       	breq	8000994c <_vfprintf_r+0x8a8>
80009946:	32 d8       	mov	r8,45
80009948:	fb 68 06 bb 	st.b	sp[1723],r8
8000994c:	fe c8 a6 20 	sub	r8,pc,-23008
80009950:	fe c6 a6 20 	sub	r6,pc,-23008
80009954:	a7 d5       	cbr	r5,0x7
80009956:	e0 40 00 47 	cp.w	r0,71
8000995a:	f0 06 17 a0 	movle	r6,r8
8000995e:	30 32       	mov	r2,3
80009960:	e0 8f 06 ce 	bral	8000a6fc <_vfprintf_r+0x1658>
80009964:	40 5b       	lddsp	r11,sp[0x14]
80009966:	40 7a       	lddsp	r10,sp[0x1c]
80009968:	e0 a0 19 4d 	rcall	8000cc02 <__isnand>
8000996c:	c0 e0       	breq	80009988 <_vfprintf_r+0x8e4>
8000996e:	50 26       	stdsp	sp[0x8],r6
80009970:	fe c8 a6 3c 	sub	r8,pc,-22980
80009974:	fe c6 a6 3c 	sub	r6,pc,-22980
80009978:	a7 d5       	cbr	r5,0x7
8000997a:	e0 40 00 47 	cp.w	r0,71
8000997e:	f0 06 17 a0 	movle	r6,r8
80009982:	30 32       	mov	r2,3
80009984:	e0 8f 06 c2 	bral	8000a708 <_vfprintf_r+0x1664>
80009988:	40 2a       	lddsp	r10,sp[0x8]
8000998a:	5b fa       	cp.w	r10,-1
8000998c:	c0 41       	brne	80009994 <_vfprintf_r+0x8f0>
8000998e:	30 69       	mov	r9,6
80009990:	50 29       	stdsp	sp[0x8],r9
80009992:	c1 18       	rjmp	800099b4 <_vfprintf_r+0x910>
80009994:	e0 40 00 47 	cp.w	r0,71
80009998:	5f 09       	sreq	r9
8000999a:	e0 40 00 67 	cp.w	r0,103
8000999e:	5f 08       	sreq	r8
800099a0:	f3 e8 10 08 	or	r8,r9,r8
800099a4:	f8 08 18 00 	cp.b	r8,r12
800099a8:	c0 60       	breq	800099b4 <_vfprintf_r+0x910>
800099aa:	40 28       	lddsp	r8,sp[0x8]
800099ac:	58 08       	cp.w	r8,0
800099ae:	f9 b8 00 01 	moveq	r8,1
800099b2:	50 28       	stdsp	sp[0x8],r8
800099b4:	40 78       	lddsp	r8,sp[0x1c]
800099b6:	40 59       	lddsp	r9,sp[0x14]
800099b8:	fa e9 06 94 	st.d	sp[1684],r8
800099bc:	a9 a5       	sbr	r5,0x8
800099be:	fa f8 06 94 	ld.w	r8,sp[1684]
800099c2:	58 08       	cp.w	r8,0
800099c4:	c0 65       	brlt	800099d0 <_vfprintf_r+0x92c>
800099c6:	40 5e       	lddsp	lr,sp[0x14]
800099c8:	30 0c       	mov	r12,0
800099ca:	50 6e       	stdsp	sp[0x18],lr
800099cc:	50 9c       	stdsp	sp[0x24],r12
800099ce:	c0 78       	rjmp	800099dc <_vfprintf_r+0x938>
800099d0:	40 5b       	lddsp	r11,sp[0x14]
800099d2:	32 da       	mov	r10,45
800099d4:	ee 1b 80 00 	eorh	r11,0x8000
800099d8:	50 9a       	stdsp	sp[0x24],r10
800099da:	50 6b       	stdsp	sp[0x18],r11
800099dc:	e0 40 00 46 	cp.w	r0,70
800099e0:	5f 09       	sreq	r9
800099e2:	e0 40 00 66 	cp.w	r0,102
800099e6:	5f 08       	sreq	r8
800099e8:	f3 e8 10 08 	or	r8,r9,r8
800099ec:	50 48       	stdsp	sp[0x10],r8
800099ee:	c0 40       	breq	800099f6 <_vfprintf_r+0x952>
800099f0:	40 22       	lddsp	r2,sp[0x8]
800099f2:	30 39       	mov	r9,3
800099f4:	c1 08       	rjmp	80009a14 <_vfprintf_r+0x970>
800099f6:	e0 40 00 45 	cp.w	r0,69
800099fa:	5f 09       	sreq	r9
800099fc:	e0 40 00 65 	cp.w	r0,101
80009a00:	5f 08       	sreq	r8
80009a02:	40 22       	lddsp	r2,sp[0x8]
80009a04:	10 49       	or	r9,r8
80009a06:	2f f2       	sub	r2,-1
80009a08:	40 46       	lddsp	r6,sp[0x10]
80009a0a:	ec 09 18 00 	cp.b	r9,r6
80009a0e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009a12:	30 29       	mov	r9,2
80009a14:	fa c8 f9 5c 	sub	r8,sp,-1700
80009a18:	1a d8       	st.w	--sp,r8
80009a1a:	fa c8 f9 54 	sub	r8,sp,-1708
80009a1e:	1a d8       	st.w	--sp,r8
80009a20:	fa c8 f9 4c 	sub	r8,sp,-1716
80009a24:	08 9c       	mov	r12,r4
80009a26:	1a d8       	st.w	--sp,r8
80009a28:	04 98       	mov	r8,r2
80009a2a:	40 9b       	lddsp	r11,sp[0x24]
80009a2c:	40 aa       	lddsp	r10,sp[0x28]
80009a2e:	e0 a0 0b c3 	rcall	8000b1b4 <_dtoa_r>
80009a32:	e0 40 00 47 	cp.w	r0,71
80009a36:	5f 19       	srne	r9
80009a38:	e0 40 00 67 	cp.w	r0,103
80009a3c:	5f 18       	srne	r8
80009a3e:	18 96       	mov	r6,r12
80009a40:	2f dd       	sub	sp,-12
80009a42:	f3 e8 00 08 	and	r8,r9,r8
80009a46:	c0 41       	brne	80009a4e <_vfprintf_r+0x9aa>
80009a48:	ed b5 00 00 	bld	r5,0x0
80009a4c:	c3 01       	brne	80009aac <_vfprintf_r+0xa08>
80009a4e:	ec 02 00 0e 	add	lr,r6,r2
80009a52:	50 3e       	stdsp	sp[0xc],lr
80009a54:	40 4c       	lddsp	r12,sp[0x10]
80009a56:	58 0c       	cp.w	r12,0
80009a58:	c1 50       	breq	80009a82 <_vfprintf_r+0x9de>
80009a5a:	0d 89       	ld.ub	r9,r6[0x0]
80009a5c:	33 08       	mov	r8,48
80009a5e:	f0 09 18 00 	cp.b	r9,r8
80009a62:	c0 b1       	brne	80009a78 <_vfprintf_r+0x9d4>
80009a64:	30 08       	mov	r8,0
80009a66:	30 09       	mov	r9,0
80009a68:	40 6b       	lddsp	r11,sp[0x18]
80009a6a:	40 7a       	lddsp	r10,sp[0x1c]
80009a6c:	e0 a0 1c d7 	rcall	8000d41a <__avr32_f64_cmp_eq>
80009a70:	fb b2 00 01 	rsubeq	r2,1
80009a74:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009a78:	40 3b       	lddsp	r11,sp[0xc]
80009a7a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a7e:	10 0b       	add	r11,r8
80009a80:	50 3b       	stdsp	sp[0xc],r11
80009a82:	40 6b       	lddsp	r11,sp[0x18]
80009a84:	30 08       	mov	r8,0
80009a86:	30 09       	mov	r9,0
80009a88:	40 7a       	lddsp	r10,sp[0x1c]
80009a8a:	e0 a0 1c c8 	rcall	8000d41a <__avr32_f64_cmp_eq>
80009a8e:	c0 90       	breq	80009aa0 <_vfprintf_r+0x9fc>
80009a90:	40 3a       	lddsp	r10,sp[0xc]
80009a92:	fb 4a 06 a4 	st.w	sp[1700],r10
80009a96:	c0 58       	rjmp	80009aa0 <_vfprintf_r+0x9fc>
80009a98:	10 c9       	st.b	r8++,r9
80009a9a:	fb 48 06 a4 	st.w	sp[1700],r8
80009a9e:	c0 28       	rjmp	80009aa2 <_vfprintf_r+0x9fe>
80009aa0:	33 09       	mov	r9,48
80009aa2:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009aa6:	40 3e       	lddsp	lr,sp[0xc]
80009aa8:	1c 38       	cp.w	r8,lr
80009aaa:	cf 73       	brcs	80009a98 <_vfprintf_r+0x9f4>
80009aac:	e0 40 00 47 	cp.w	r0,71
80009ab0:	5f 09       	sreq	r9
80009ab2:	e0 40 00 67 	cp.w	r0,103
80009ab6:	5f 08       	sreq	r8
80009ab8:	f3 e8 10 08 	or	r8,r9,r8
80009abc:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009ac0:	0c 19       	sub	r9,r6
80009ac2:	50 69       	stdsp	sp[0x18],r9
80009ac4:	58 08       	cp.w	r8,0
80009ac6:	c0 b0       	breq	80009adc <_vfprintf_r+0xa38>
80009ac8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009acc:	5b d8       	cp.w	r8,-3
80009ace:	c0 55       	brlt	80009ad8 <_vfprintf_r+0xa34>
80009ad0:	40 2c       	lddsp	r12,sp[0x8]
80009ad2:	18 38       	cp.w	r8,r12
80009ad4:	e0 8a 00 6a 	brle	80009ba8 <_vfprintf_r+0xb04>
80009ad8:	20 20       	sub	r0,2
80009ada:	c0 58       	rjmp	80009ae4 <_vfprintf_r+0xa40>
80009adc:	e0 40 00 65 	cp.w	r0,101
80009ae0:	e0 89 00 46 	brgt	80009b6c <_vfprintf_r+0xac8>
80009ae4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009ae8:	fb 60 06 9c 	st.b	sp[1692],r0
80009aec:	20 1b       	sub	r11,1
80009aee:	fb 4b 06 ac 	st.w	sp[1708],r11
80009af2:	c0 47       	brpl	80009afa <_vfprintf_r+0xa56>
80009af4:	5c 3b       	neg	r11
80009af6:	32 d8       	mov	r8,45
80009af8:	c0 28       	rjmp	80009afc <_vfprintf_r+0xa58>
80009afa:	32 b8       	mov	r8,43
80009afc:	fb 68 06 9d 	st.b	sp[1693],r8
80009b00:	58 9b       	cp.w	r11,9
80009b02:	e0 8a 00 1d 	brle	80009b3c <_vfprintf_r+0xa98>
80009b06:	fa c9 fa 35 	sub	r9,sp,-1483
80009b0a:	30 aa       	mov	r10,10
80009b0c:	12 98       	mov	r8,r9
80009b0e:	0e 9c       	mov	r12,r7
80009b10:	0c 92       	mov	r2,r6
80009b12:	f6 0a 0c 06 	divs	r6,r11,r10
80009b16:	0e 9b       	mov	r11,r7
80009b18:	2d 0b       	sub	r11,-48
80009b1a:	10 fb       	st.b	--r8,r11
80009b1c:	0c 9b       	mov	r11,r6
80009b1e:	58 96       	cp.w	r6,9
80009b20:	fe 99 ff f9 	brgt	80009b12 <_vfprintf_r+0xa6e>
80009b24:	2d 0b       	sub	r11,-48
80009b26:	18 97       	mov	r7,r12
80009b28:	04 96       	mov	r6,r2
80009b2a:	10 fb       	st.b	--r8,r11
80009b2c:	fa ca f9 62 	sub	r10,sp,-1694
80009b30:	c0 38       	rjmp	80009b36 <_vfprintf_r+0xa92>
80009b32:	11 3b       	ld.ub	r11,r8++
80009b34:	14 cb       	st.b	r10++,r11
80009b36:	12 38       	cp.w	r8,r9
80009b38:	cf d3       	brcs	80009b32 <_vfprintf_r+0xa8e>
80009b3a:	c0 98       	rjmp	80009b4c <_vfprintf_r+0xaa8>
80009b3c:	2d 0b       	sub	r11,-48
80009b3e:	33 08       	mov	r8,48
80009b40:	fb 6b 06 9f 	st.b	sp[1695],r11
80009b44:	fb 68 06 9e 	st.b	sp[1694],r8
80009b48:	fa ca f9 60 	sub	r10,sp,-1696
80009b4c:	fa c8 f9 64 	sub	r8,sp,-1692
80009b50:	f4 08 01 08 	sub	r8,r10,r8
80009b54:	50 e8       	stdsp	sp[0x38],r8
80009b56:	10 92       	mov	r2,r8
80009b58:	40 6b       	lddsp	r11,sp[0x18]
80009b5a:	16 02       	add	r2,r11
80009b5c:	58 1b       	cp.w	r11,1
80009b5e:	e0 89 00 05 	brgt	80009b68 <_vfprintf_r+0xac4>
80009b62:	ed b5 00 00 	bld	r5,0x0
80009b66:	c3 51       	brne	80009bd0 <_vfprintf_r+0xb2c>
80009b68:	2f f2       	sub	r2,-1
80009b6a:	c3 38       	rjmp	80009bd0 <_vfprintf_r+0xb2c>
80009b6c:	e0 40 00 66 	cp.w	r0,102
80009b70:	c1 c1       	brne	80009ba8 <_vfprintf_r+0xb04>
80009b72:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b76:	58 02       	cp.w	r2,0
80009b78:	e0 8a 00 0c 	brle	80009b90 <_vfprintf_r+0xaec>
80009b7c:	40 2a       	lddsp	r10,sp[0x8]
80009b7e:	58 0a       	cp.w	r10,0
80009b80:	c0 41       	brne	80009b88 <_vfprintf_r+0xae4>
80009b82:	ed b5 00 00 	bld	r5,0x0
80009b86:	c2 51       	brne	80009bd0 <_vfprintf_r+0xb2c>
80009b88:	2f f2       	sub	r2,-1
80009b8a:	40 29       	lddsp	r9,sp[0x8]
80009b8c:	12 02       	add	r2,r9
80009b8e:	c0 b8       	rjmp	80009ba4 <_vfprintf_r+0xb00>
80009b90:	40 28       	lddsp	r8,sp[0x8]
80009b92:	58 08       	cp.w	r8,0
80009b94:	c0 61       	brne	80009ba0 <_vfprintf_r+0xafc>
80009b96:	ed b5 00 00 	bld	r5,0x0
80009b9a:	c0 30       	breq	80009ba0 <_vfprintf_r+0xafc>
80009b9c:	30 12       	mov	r2,1
80009b9e:	c1 98       	rjmp	80009bd0 <_vfprintf_r+0xb2c>
80009ba0:	40 22       	lddsp	r2,sp[0x8]
80009ba2:	2f e2       	sub	r2,-2
80009ba4:	36 60       	mov	r0,102
80009ba6:	c1 58       	rjmp	80009bd0 <_vfprintf_r+0xb2c>
80009ba8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bac:	40 6e       	lddsp	lr,sp[0x18]
80009bae:	1c 32       	cp.w	r2,lr
80009bb0:	c0 65       	brlt	80009bbc <_vfprintf_r+0xb18>
80009bb2:	ed b5 00 00 	bld	r5,0x0
80009bb6:	f7 b2 00 ff 	subeq	r2,-1
80009bba:	c0 a8       	rjmp	80009bce <_vfprintf_r+0xb2a>
80009bbc:	e4 08 11 02 	rsub	r8,r2,2
80009bc0:	40 6c       	lddsp	r12,sp[0x18]
80009bc2:	58 02       	cp.w	r2,0
80009bc4:	f0 02 17 a0 	movle	r2,r8
80009bc8:	f9 b2 09 01 	movgt	r2,1
80009bcc:	18 02       	add	r2,r12
80009bce:	36 70       	mov	r0,103
80009bd0:	40 9b       	lddsp	r11,sp[0x24]
80009bd2:	58 0b       	cp.w	r11,0
80009bd4:	e0 80 05 94 	breq	8000a6fc <_vfprintf_r+0x1658>
80009bd8:	32 d8       	mov	r8,45
80009bda:	fb 68 06 bb 	st.b	sp[1723],r8
80009bde:	e0 8f 05 93 	bral	8000a704 <_vfprintf_r+0x1660>
80009be2:	50 a7       	stdsp	sp[0x28],r7
80009be4:	04 94       	mov	r4,r2
80009be6:	0c 97       	mov	r7,r6
80009be8:	02 92       	mov	r2,r1
80009bea:	06 96       	mov	r6,r3
80009bec:	40 41       	lddsp	r1,sp[0x10]
80009bee:	40 93       	lddsp	r3,sp[0x24]
80009bf0:	0e 99       	mov	r9,r7
80009bf2:	ed b5 00 05 	bld	r5,0x5
80009bf6:	c4 81       	brne	80009c86 <_vfprintf_r+0xbe2>
80009bf8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bfc:	40 3e       	lddsp	lr,sp[0xc]
80009bfe:	58 0e       	cp.w	lr,0
80009c00:	c1 d0       	breq	80009c3a <_vfprintf_r+0xb96>
80009c02:	10 36       	cp.w	r6,r8
80009c04:	c0 64       	brge	80009c10 <_vfprintf_r+0xb6c>
80009c06:	fa cc f9 44 	sub	r12,sp,-1724
80009c0a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009c0e:	c1 d8       	rjmp	80009c48 <_vfprintf_r+0xba4>
80009c10:	fa c8 f9 50 	sub	r8,sp,-1712
80009c14:	1a d8       	st.w	--sp,r8
80009c16:	fa c8 fa b8 	sub	r8,sp,-1352
80009c1a:	04 9a       	mov	r10,r2
80009c1c:	1a d8       	st.w	--sp,r8
80009c1e:	fa c8 fb b4 	sub	r8,sp,-1100
80009c22:	0c 9b       	mov	r11,r6
80009c24:	1a d8       	st.w	--sp,r8
80009c26:	08 9c       	mov	r12,r4
80009c28:	fa c8 f9 40 	sub	r8,sp,-1728
80009c2c:	fa c9 ff b4 	sub	r9,sp,-76
80009c30:	fe b0 f8 a2 	rcall	80008d74 <get_arg>
80009c34:	2f dd       	sub	sp,-12
80009c36:	78 0a       	ld.w	r10,r12[0x0]
80009c38:	c2 08       	rjmp	80009c78 <_vfprintf_r+0xbd4>
80009c3a:	2f f7       	sub	r7,-1
80009c3c:	10 39       	cp.w	r9,r8
80009c3e:	c0 84       	brge	80009c4e <_vfprintf_r+0xbaa>
80009c40:	fa cb f9 44 	sub	r11,sp,-1724
80009c44:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c48:	ec fa fd 88 	ld.w	r10,r6[-632]
80009c4c:	c1 68       	rjmp	80009c78 <_vfprintf_r+0xbd4>
80009c4e:	41 09       	lddsp	r9,sp[0x40]
80009c50:	59 f8       	cp.w	r8,31
80009c52:	e0 89 00 10 	brgt	80009c72 <_vfprintf_r+0xbce>
80009c56:	f2 ca ff fc 	sub	r10,r9,-4
80009c5a:	51 0a       	stdsp	sp[0x40],r10
80009c5c:	fa c6 f9 44 	sub	r6,sp,-1724
80009c60:	72 0a       	ld.w	r10,r9[0x0]
80009c62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c66:	f3 4a fd 88 	st.w	r9[-632],r10
80009c6a:	2f f8       	sub	r8,-1
80009c6c:	fb 48 06 b4 	st.w	sp[1716],r8
80009c70:	c0 48       	rjmp	80009c78 <_vfprintf_r+0xbd4>
80009c72:	72 0a       	ld.w	r10,r9[0x0]
80009c74:	2f c9       	sub	r9,-4
80009c76:	51 09       	stdsp	sp[0x40],r9
80009c78:	40 be       	lddsp	lr,sp[0x2c]
80009c7a:	1c 98       	mov	r8,lr
80009c7c:	95 1e       	st.w	r10[0x4],lr
80009c7e:	bf 58       	asr	r8,0x1f
80009c80:	95 08       	st.w	r10[0x0],r8
80009c82:	fe 9f fa 9f 	bral	800091c0 <_vfprintf_r+0x11c>
80009c86:	ed b5 00 04 	bld	r5,0x4
80009c8a:	c4 80       	breq	80009d1a <_vfprintf_r+0xc76>
80009c8c:	e2 15 00 40 	andl	r5,0x40,COH
80009c90:	c4 50       	breq	80009d1a <_vfprintf_r+0xc76>
80009c92:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c96:	40 3c       	lddsp	r12,sp[0xc]
80009c98:	58 0c       	cp.w	r12,0
80009c9a:	c1 d0       	breq	80009cd4 <_vfprintf_r+0xc30>
80009c9c:	10 36       	cp.w	r6,r8
80009c9e:	c0 64       	brge	80009caa <_vfprintf_r+0xc06>
80009ca0:	fa cb f9 44 	sub	r11,sp,-1724
80009ca4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ca8:	c1 d8       	rjmp	80009ce2 <_vfprintf_r+0xc3e>
80009caa:	fa c8 f9 50 	sub	r8,sp,-1712
80009cae:	1a d8       	st.w	--sp,r8
80009cb0:	fa c8 fa b8 	sub	r8,sp,-1352
80009cb4:	04 9a       	mov	r10,r2
80009cb6:	1a d8       	st.w	--sp,r8
80009cb8:	fa c8 fb b4 	sub	r8,sp,-1100
80009cbc:	0c 9b       	mov	r11,r6
80009cbe:	1a d8       	st.w	--sp,r8
80009cc0:	08 9c       	mov	r12,r4
80009cc2:	fa c8 f9 40 	sub	r8,sp,-1728
80009cc6:	fa c9 ff b4 	sub	r9,sp,-76
80009cca:	fe b0 f8 55 	rcall	80008d74 <get_arg>
80009cce:	2f dd       	sub	sp,-12
80009cd0:	78 0a       	ld.w	r10,r12[0x0]
80009cd2:	c2 08       	rjmp	80009d12 <_vfprintf_r+0xc6e>
80009cd4:	2f f7       	sub	r7,-1
80009cd6:	10 39       	cp.w	r9,r8
80009cd8:	c0 84       	brge	80009ce8 <_vfprintf_r+0xc44>
80009cda:	fa ca f9 44 	sub	r10,sp,-1724
80009cde:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009ce2:	ec fa fd 88 	ld.w	r10,r6[-632]
80009ce6:	c1 68       	rjmp	80009d12 <_vfprintf_r+0xc6e>
80009ce8:	41 09       	lddsp	r9,sp[0x40]
80009cea:	59 f8       	cp.w	r8,31
80009cec:	e0 89 00 10 	brgt	80009d0c <_vfprintf_r+0xc68>
80009cf0:	f2 ca ff fc 	sub	r10,r9,-4
80009cf4:	51 0a       	stdsp	sp[0x40],r10
80009cf6:	fa c6 f9 44 	sub	r6,sp,-1724
80009cfa:	72 0a       	ld.w	r10,r9[0x0]
80009cfc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d00:	f3 4a fd 88 	st.w	r9[-632],r10
80009d04:	2f f8       	sub	r8,-1
80009d06:	fb 48 06 b4 	st.w	sp[1716],r8
80009d0a:	c0 48       	rjmp	80009d12 <_vfprintf_r+0xc6e>
80009d0c:	72 0a       	ld.w	r10,r9[0x0]
80009d0e:	2f c9       	sub	r9,-4
80009d10:	51 09       	stdsp	sp[0x40],r9
80009d12:	40 be       	lddsp	lr,sp[0x2c]
80009d14:	b4 0e       	st.h	r10[0x0],lr
80009d16:	fe 9f fa 55 	bral	800091c0 <_vfprintf_r+0x11c>
80009d1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d1e:	40 3c       	lddsp	r12,sp[0xc]
80009d20:	58 0c       	cp.w	r12,0
80009d22:	c1 d0       	breq	80009d5c <_vfprintf_r+0xcb8>
80009d24:	10 36       	cp.w	r6,r8
80009d26:	c0 64       	brge	80009d32 <_vfprintf_r+0xc8e>
80009d28:	fa cb f9 44 	sub	r11,sp,-1724
80009d2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d30:	c1 d8       	rjmp	80009d6a <_vfprintf_r+0xcc6>
80009d32:	fa c8 f9 50 	sub	r8,sp,-1712
80009d36:	1a d8       	st.w	--sp,r8
80009d38:	fa c8 fa b8 	sub	r8,sp,-1352
80009d3c:	04 9a       	mov	r10,r2
80009d3e:	1a d8       	st.w	--sp,r8
80009d40:	fa c8 fb b4 	sub	r8,sp,-1100
80009d44:	0c 9b       	mov	r11,r6
80009d46:	1a d8       	st.w	--sp,r8
80009d48:	08 9c       	mov	r12,r4
80009d4a:	fa c8 f9 40 	sub	r8,sp,-1728
80009d4e:	fa c9 ff b4 	sub	r9,sp,-76
80009d52:	fe b0 f8 11 	rcall	80008d74 <get_arg>
80009d56:	2f dd       	sub	sp,-12
80009d58:	78 0a       	ld.w	r10,r12[0x0]
80009d5a:	c2 08       	rjmp	80009d9a <_vfprintf_r+0xcf6>
80009d5c:	2f f7       	sub	r7,-1
80009d5e:	10 39       	cp.w	r9,r8
80009d60:	c0 84       	brge	80009d70 <_vfprintf_r+0xccc>
80009d62:	fa ca f9 44 	sub	r10,sp,-1724
80009d66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009d6a:	ec fa fd 88 	ld.w	r10,r6[-632]
80009d6e:	c1 68       	rjmp	80009d9a <_vfprintf_r+0xcf6>
80009d70:	41 09       	lddsp	r9,sp[0x40]
80009d72:	59 f8       	cp.w	r8,31
80009d74:	e0 89 00 10 	brgt	80009d94 <_vfprintf_r+0xcf0>
80009d78:	f2 ca ff fc 	sub	r10,r9,-4
80009d7c:	51 0a       	stdsp	sp[0x40],r10
80009d7e:	fa c6 f9 44 	sub	r6,sp,-1724
80009d82:	72 0a       	ld.w	r10,r9[0x0]
80009d84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d88:	f3 4a fd 88 	st.w	r9[-632],r10
80009d8c:	2f f8       	sub	r8,-1
80009d8e:	fb 48 06 b4 	st.w	sp[1716],r8
80009d92:	c0 48       	rjmp	80009d9a <_vfprintf_r+0xcf6>
80009d94:	72 0a       	ld.w	r10,r9[0x0]
80009d96:	2f c9       	sub	r9,-4
80009d98:	51 09       	stdsp	sp[0x40],r9
80009d9a:	40 be       	lddsp	lr,sp[0x2c]
80009d9c:	95 0e       	st.w	r10[0x0],lr
80009d9e:	fe 9f fa 11 	bral	800091c0 <_vfprintf_r+0x11c>
80009da2:	50 a7       	stdsp	sp[0x28],r7
80009da4:	50 80       	stdsp	sp[0x20],r0
80009da6:	0c 97       	mov	r7,r6
80009da8:	04 94       	mov	r4,r2
80009daa:	06 96       	mov	r6,r3
80009dac:	02 92       	mov	r2,r1
80009dae:	40 93       	lddsp	r3,sp[0x24]
80009db0:	10 90       	mov	r0,r8
80009db2:	40 41       	lddsp	r1,sp[0x10]
80009db4:	a5 a5       	sbr	r5,0x4
80009db6:	c0 a8       	rjmp	80009dca <_vfprintf_r+0xd26>
80009db8:	50 a7       	stdsp	sp[0x28],r7
80009dba:	50 80       	stdsp	sp[0x20],r0
80009dbc:	0c 97       	mov	r7,r6
80009dbe:	04 94       	mov	r4,r2
80009dc0:	06 96       	mov	r6,r3
80009dc2:	02 92       	mov	r2,r1
80009dc4:	40 93       	lddsp	r3,sp[0x24]
80009dc6:	10 90       	mov	r0,r8
80009dc8:	40 41       	lddsp	r1,sp[0x10]
80009dca:	ed b5 00 05 	bld	r5,0x5
80009dce:	c5 d1       	brne	80009e88 <_vfprintf_r+0xde4>
80009dd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009dd4:	40 3c       	lddsp	r12,sp[0xc]
80009dd6:	58 0c       	cp.w	r12,0
80009dd8:	c2 60       	breq	80009e24 <_vfprintf_r+0xd80>
80009dda:	10 36       	cp.w	r6,r8
80009ddc:	c0 a4       	brge	80009df0 <_vfprintf_r+0xd4c>
80009dde:	fa cb f9 44 	sub	r11,sp,-1724
80009de2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009de6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009dea:	fa e9 00 00 	st.d	sp[0],r8
80009dee:	c1 88       	rjmp	80009e1e <_vfprintf_r+0xd7a>
80009df0:	fa c8 f9 50 	sub	r8,sp,-1712
80009df4:	1a d8       	st.w	--sp,r8
80009df6:	fa c8 fa b8 	sub	r8,sp,-1352
80009dfa:	04 9a       	mov	r10,r2
80009dfc:	1a d8       	st.w	--sp,r8
80009dfe:	0c 9b       	mov	r11,r6
80009e00:	fa c8 fb b4 	sub	r8,sp,-1100
80009e04:	08 9c       	mov	r12,r4
80009e06:	1a d8       	st.w	--sp,r8
80009e08:	fa c8 f9 40 	sub	r8,sp,-1728
80009e0c:	fa c9 ff b4 	sub	r9,sp,-76
80009e10:	fe b0 f7 b2 	rcall	80008d74 <get_arg>
80009e14:	2f dd       	sub	sp,-12
80009e16:	f8 ea 00 00 	ld.d	r10,r12[0]
80009e1a:	fa eb 00 00 	st.d	sp[0],r10
80009e1e:	30 08       	mov	r8,0
80009e20:	e0 8f 03 de 	bral	8000a5dc <_vfprintf_r+0x1538>
80009e24:	ee ca ff ff 	sub	r10,r7,-1
80009e28:	10 37       	cp.w	r7,r8
80009e2a:	c0 b4       	brge	80009e40 <_vfprintf_r+0xd9c>
80009e2c:	fa c9 f9 44 	sub	r9,sp,-1724
80009e30:	14 97       	mov	r7,r10
80009e32:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e36:	ec ea fd 88 	ld.d	r10,r6[-632]
80009e3a:	fa eb 00 00 	st.d	sp[0],r10
80009e3e:	c1 88       	rjmp	80009e6e <_vfprintf_r+0xdca>
80009e40:	41 09       	lddsp	r9,sp[0x40]
80009e42:	59 f8       	cp.w	r8,31
80009e44:	e0 89 00 18 	brgt	80009e74 <_vfprintf_r+0xdd0>
80009e48:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e4c:	f2 cb ff f8 	sub	r11,r9,-8
80009e50:	fa e7 00 00 	st.d	sp[0],r6
80009e54:	51 0b       	stdsp	sp[0x40],r11
80009e56:	fa c6 f9 44 	sub	r6,sp,-1724
80009e5a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e5e:	fa e6 00 00 	ld.d	r6,sp[0]
80009e62:	f2 e7 fd 88 	st.d	r9[-632],r6
80009e66:	2f f8       	sub	r8,-1
80009e68:	14 97       	mov	r7,r10
80009e6a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e6e:	40 38       	lddsp	r8,sp[0xc]
80009e70:	e0 8f 03 b6 	bral	8000a5dc <_vfprintf_r+0x1538>
80009e74:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e78:	40 38       	lddsp	r8,sp[0xc]
80009e7a:	fa e7 00 00 	st.d	sp[0],r6
80009e7e:	2f 89       	sub	r9,-8
80009e80:	14 97       	mov	r7,r10
80009e82:	51 09       	stdsp	sp[0x40],r9
80009e84:	e0 8f 03 ac 	bral	8000a5dc <_vfprintf_r+0x1538>
80009e88:	ed b5 00 04 	bld	r5,0x4
80009e8c:	c1 61       	brne	80009eb8 <_vfprintf_r+0xe14>
80009e8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e92:	40 3e       	lddsp	lr,sp[0xc]
80009e94:	58 0e       	cp.w	lr,0
80009e96:	c0 80       	breq	80009ea6 <_vfprintf_r+0xe02>
80009e98:	10 36       	cp.w	r6,r8
80009e9a:	c6 74       	brge	80009f68 <_vfprintf_r+0xec4>
80009e9c:	fa cc f9 44 	sub	r12,sp,-1724
80009ea0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009ea4:	c8 08       	rjmp	80009fa4 <_vfprintf_r+0xf00>
80009ea6:	ee ca ff ff 	sub	r10,r7,-1
80009eaa:	10 37       	cp.w	r7,r8
80009eac:	c7 f4       	brge	80009faa <_vfprintf_r+0xf06>
80009eae:	fa cb f9 44 	sub	r11,sp,-1724
80009eb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009eb6:	c7 68       	rjmp	80009fa2 <_vfprintf_r+0xefe>
80009eb8:	ed b5 00 06 	bld	r5,0x6
80009ebc:	c4 a1       	brne	80009f50 <_vfprintf_r+0xeac>
80009ebe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ec2:	40 3c       	lddsp	r12,sp[0xc]
80009ec4:	58 0c       	cp.w	r12,0
80009ec6:	c1 d0       	breq	80009f00 <_vfprintf_r+0xe5c>
80009ec8:	10 36       	cp.w	r6,r8
80009eca:	c0 64       	brge	80009ed6 <_vfprintf_r+0xe32>
80009ecc:	fa cb f9 44 	sub	r11,sp,-1724
80009ed0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ed4:	c1 f8       	rjmp	80009f12 <_vfprintf_r+0xe6e>
80009ed6:	fa c8 f9 50 	sub	r8,sp,-1712
80009eda:	1a d8       	st.w	--sp,r8
80009edc:	fa c8 fa b8 	sub	r8,sp,-1352
80009ee0:	1a d8       	st.w	--sp,r8
80009ee2:	fa c8 fb b4 	sub	r8,sp,-1100
80009ee6:	1a d8       	st.w	--sp,r8
80009ee8:	fa c8 f9 40 	sub	r8,sp,-1728
80009eec:	fa c9 ff b4 	sub	r9,sp,-76
80009ef0:	04 9a       	mov	r10,r2
80009ef2:	0c 9b       	mov	r11,r6
80009ef4:	08 9c       	mov	r12,r4
80009ef6:	fe b0 f7 3f 	rcall	80008d74 <get_arg>
80009efa:	2f dd       	sub	sp,-12
80009efc:	98 18       	ld.sh	r8,r12[0x2]
80009efe:	c2 68       	rjmp	80009f4a <_vfprintf_r+0xea6>
80009f00:	ee ca ff ff 	sub	r10,r7,-1
80009f04:	10 37       	cp.w	r7,r8
80009f06:	c0 94       	brge	80009f18 <_vfprintf_r+0xe74>
80009f08:	fa c9 f9 44 	sub	r9,sp,-1724
80009f0c:	14 97       	mov	r7,r10
80009f0e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f12:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009f16:	c1 a8       	rjmp	80009f4a <_vfprintf_r+0xea6>
80009f18:	41 09       	lddsp	r9,sp[0x40]
80009f1a:	59 f8       	cp.w	r8,31
80009f1c:	e0 89 00 13 	brgt	80009f42 <_vfprintf_r+0xe9e>
80009f20:	f2 cb ff fc 	sub	r11,r9,-4
80009f24:	51 0b       	stdsp	sp[0x40],r11
80009f26:	72 09       	ld.w	r9,r9[0x0]
80009f28:	fa c6 f9 44 	sub	r6,sp,-1724
80009f2c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009f30:	2f f8       	sub	r8,-1
80009f32:	f7 49 fd 88 	st.w	r11[-632],r9
80009f36:	fb 48 06 b4 	st.w	sp[1716],r8
80009f3a:	14 97       	mov	r7,r10
80009f3c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009f40:	c0 58       	rjmp	80009f4a <_vfprintf_r+0xea6>
80009f42:	92 18       	ld.sh	r8,r9[0x2]
80009f44:	14 97       	mov	r7,r10
80009f46:	2f c9       	sub	r9,-4
80009f48:	51 09       	stdsp	sp[0x40],r9
80009f4a:	5c 78       	castu.h	r8
80009f4c:	50 18       	stdsp	sp[0x4],r8
80009f4e:	c4 68       	rjmp	80009fda <_vfprintf_r+0xf36>
80009f50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f54:	40 3c       	lddsp	r12,sp[0xc]
80009f56:	58 0c       	cp.w	r12,0
80009f58:	c1 d0       	breq	80009f92 <_vfprintf_r+0xeee>
80009f5a:	10 36       	cp.w	r6,r8
80009f5c:	c0 64       	brge	80009f68 <_vfprintf_r+0xec4>
80009f5e:	fa cb f9 44 	sub	r11,sp,-1724
80009f62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009f66:	c1 f8       	rjmp	80009fa4 <_vfprintf_r+0xf00>
80009f68:	fa c8 f9 50 	sub	r8,sp,-1712
80009f6c:	1a d8       	st.w	--sp,r8
80009f6e:	fa c8 fa b8 	sub	r8,sp,-1352
80009f72:	0c 9b       	mov	r11,r6
80009f74:	1a d8       	st.w	--sp,r8
80009f76:	fa c8 fb b4 	sub	r8,sp,-1100
80009f7a:	04 9a       	mov	r10,r2
80009f7c:	1a d8       	st.w	--sp,r8
80009f7e:	08 9c       	mov	r12,r4
80009f80:	fa c8 f9 40 	sub	r8,sp,-1728
80009f84:	fa c9 ff b4 	sub	r9,sp,-76
80009f88:	fe b0 f6 f6 	rcall	80008d74 <get_arg>
80009f8c:	2f dd       	sub	sp,-12
80009f8e:	78 0b       	ld.w	r11,r12[0x0]
80009f90:	c2 48       	rjmp	80009fd8 <_vfprintf_r+0xf34>
80009f92:	ee ca ff ff 	sub	r10,r7,-1
80009f96:	10 37       	cp.w	r7,r8
80009f98:	c0 94       	brge	80009faa <_vfprintf_r+0xf06>
80009f9a:	fa c9 f9 44 	sub	r9,sp,-1724
80009f9e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009fa2:	14 97       	mov	r7,r10
80009fa4:	ec fb fd 88 	ld.w	r11,r6[-632]
80009fa8:	c1 88       	rjmp	80009fd8 <_vfprintf_r+0xf34>
80009faa:	41 09       	lddsp	r9,sp[0x40]
80009fac:	59 f8       	cp.w	r8,31
80009fae:	e0 89 00 11 	brgt	80009fd0 <_vfprintf_r+0xf2c>
80009fb2:	f2 cb ff fc 	sub	r11,r9,-4
80009fb6:	51 0b       	stdsp	sp[0x40],r11
80009fb8:	fa c6 f9 44 	sub	r6,sp,-1724
80009fbc:	72 0b       	ld.w	r11,r9[0x0]
80009fbe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009fc2:	f3 4b fd 88 	st.w	r9[-632],r11
80009fc6:	2f f8       	sub	r8,-1
80009fc8:	14 97       	mov	r7,r10
80009fca:	fb 48 06 b4 	st.w	sp[1716],r8
80009fce:	c0 58       	rjmp	80009fd8 <_vfprintf_r+0xf34>
80009fd0:	72 0b       	ld.w	r11,r9[0x0]
80009fd2:	14 97       	mov	r7,r10
80009fd4:	2f c9       	sub	r9,-4
80009fd6:	51 09       	stdsp	sp[0x40],r9
80009fd8:	50 1b       	stdsp	sp[0x4],r11
80009fda:	30 0e       	mov	lr,0
80009fdc:	50 0e       	stdsp	sp[0x0],lr
80009fde:	1c 98       	mov	r8,lr
80009fe0:	e0 8f 02 fe 	bral	8000a5dc <_vfprintf_r+0x1538>
80009fe4:	50 a7       	stdsp	sp[0x28],r7
80009fe6:	50 80       	stdsp	sp[0x20],r0
80009fe8:	0c 97       	mov	r7,r6
80009fea:	04 94       	mov	r4,r2
80009fec:	06 96       	mov	r6,r3
80009fee:	02 92       	mov	r2,r1
80009ff0:	40 93       	lddsp	r3,sp[0x24]
80009ff2:	40 41       	lddsp	r1,sp[0x10]
80009ff4:	0e 99       	mov	r9,r7
80009ff6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ffa:	40 3c       	lddsp	r12,sp[0xc]
80009ffc:	58 0c       	cp.w	r12,0
80009ffe:	c1 d0       	breq	8000a038 <_vfprintf_r+0xf94>
8000a000:	10 36       	cp.w	r6,r8
8000a002:	c0 64       	brge	8000a00e <_vfprintf_r+0xf6a>
8000a004:	fa cb f9 44 	sub	r11,sp,-1724
8000a008:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a00c:	c1 d8       	rjmp	8000a046 <_vfprintf_r+0xfa2>
8000a00e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a012:	1a d8       	st.w	--sp,r8
8000a014:	fa c8 fa b8 	sub	r8,sp,-1352
8000a018:	1a d8       	st.w	--sp,r8
8000a01a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a01e:	1a d8       	st.w	--sp,r8
8000a020:	fa c9 ff b4 	sub	r9,sp,-76
8000a024:	fa c8 f9 40 	sub	r8,sp,-1728
8000a028:	04 9a       	mov	r10,r2
8000a02a:	0c 9b       	mov	r11,r6
8000a02c:	08 9c       	mov	r12,r4
8000a02e:	fe b0 f6 a3 	rcall	80008d74 <get_arg>
8000a032:	2f dd       	sub	sp,-12
8000a034:	78 09       	ld.w	r9,r12[0x0]
8000a036:	c2 18       	rjmp	8000a078 <_vfprintf_r+0xfd4>
8000a038:	2f f7       	sub	r7,-1
8000a03a:	10 39       	cp.w	r9,r8
8000a03c:	c0 84       	brge	8000a04c <_vfprintf_r+0xfa8>
8000a03e:	fa ca f9 44 	sub	r10,sp,-1724
8000a042:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a046:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000a04a:	c1 78       	rjmp	8000a078 <_vfprintf_r+0xfd4>
8000a04c:	41 09       	lddsp	r9,sp[0x40]
8000a04e:	59 f8       	cp.w	r8,31
8000a050:	e0 89 00 10 	brgt	8000a070 <_vfprintf_r+0xfcc>
8000a054:	f2 ca ff fc 	sub	r10,r9,-4
8000a058:	51 0a       	stdsp	sp[0x40],r10
8000a05a:	fa c6 f9 44 	sub	r6,sp,-1724
8000a05e:	72 09       	ld.w	r9,r9[0x0]
8000a060:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000a064:	f5 49 fd 88 	st.w	r10[-632],r9
8000a068:	2f f8       	sub	r8,-1
8000a06a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a06e:	c0 58       	rjmp	8000a078 <_vfprintf_r+0xfd4>
8000a070:	f2 c8 ff fc 	sub	r8,r9,-4
8000a074:	51 08       	stdsp	sp[0x40],r8
8000a076:	72 09       	ld.w	r9,r9[0x0]
8000a078:	33 08       	mov	r8,48
8000a07a:	fb 68 06 b8 	st.b	sp[1720],r8
8000a07e:	37 88       	mov	r8,120
8000a080:	30 0e       	mov	lr,0
8000a082:	fb 68 06 b9 	st.b	sp[1721],r8
8000a086:	fe cc ad 4a 	sub	r12,pc,-21174
8000a08a:	50 19       	stdsp	sp[0x4],r9
8000a08c:	a1 b5       	sbr	r5,0x1
8000a08e:	50 0e       	stdsp	sp[0x0],lr
8000a090:	50 dc       	stdsp	sp[0x34],r12
8000a092:	30 28       	mov	r8,2
8000a094:	37 80       	mov	r0,120
8000a096:	e0 8f 02 a3 	bral	8000a5dc <_vfprintf_r+0x1538>
8000a09a:	50 a7       	stdsp	sp[0x28],r7
8000a09c:	50 80       	stdsp	sp[0x20],r0
8000a09e:	10 90       	mov	r0,r8
8000a0a0:	30 08       	mov	r8,0
8000a0a2:	fb 68 06 bb 	st.b	sp[1723],r8
8000a0a6:	0c 97       	mov	r7,r6
8000a0a8:	04 94       	mov	r4,r2
8000a0aa:	06 96       	mov	r6,r3
8000a0ac:	02 92       	mov	r2,r1
8000a0ae:	40 93       	lddsp	r3,sp[0x24]
8000a0b0:	40 41       	lddsp	r1,sp[0x10]
8000a0b2:	0e 99       	mov	r9,r7
8000a0b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a0b8:	40 3b       	lddsp	r11,sp[0xc]
8000a0ba:	58 0b       	cp.w	r11,0
8000a0bc:	c1 d0       	breq	8000a0f6 <_vfprintf_r+0x1052>
8000a0be:	10 36       	cp.w	r6,r8
8000a0c0:	c0 64       	brge	8000a0cc <_vfprintf_r+0x1028>
8000a0c2:	fa ca f9 44 	sub	r10,sp,-1724
8000a0c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a0ca:	c1 d8       	rjmp	8000a104 <_vfprintf_r+0x1060>
8000a0cc:	fa c8 f9 50 	sub	r8,sp,-1712
8000a0d0:	1a d8       	st.w	--sp,r8
8000a0d2:	fa c8 fa b8 	sub	r8,sp,-1352
8000a0d6:	1a d8       	st.w	--sp,r8
8000a0d8:	fa c8 fb b4 	sub	r8,sp,-1100
8000a0dc:	0c 9b       	mov	r11,r6
8000a0de:	1a d8       	st.w	--sp,r8
8000a0e0:	04 9a       	mov	r10,r2
8000a0e2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a0e6:	fa c9 ff b4 	sub	r9,sp,-76
8000a0ea:	08 9c       	mov	r12,r4
8000a0ec:	fe b0 f6 44 	rcall	80008d74 <get_arg>
8000a0f0:	2f dd       	sub	sp,-12
8000a0f2:	78 06       	ld.w	r6,r12[0x0]
8000a0f4:	c2 08       	rjmp	8000a134 <_vfprintf_r+0x1090>
8000a0f6:	2f f7       	sub	r7,-1
8000a0f8:	10 39       	cp.w	r9,r8
8000a0fa:	c0 84       	brge	8000a10a <_vfprintf_r+0x1066>
8000a0fc:	fa c9 f9 44 	sub	r9,sp,-1724
8000a100:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a104:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a108:	c1 68       	rjmp	8000a134 <_vfprintf_r+0x1090>
8000a10a:	41 09       	lddsp	r9,sp[0x40]
8000a10c:	59 f8       	cp.w	r8,31
8000a10e:	e0 89 00 10 	brgt	8000a12e <_vfprintf_r+0x108a>
8000a112:	f2 ca ff fc 	sub	r10,r9,-4
8000a116:	51 0a       	stdsp	sp[0x40],r10
8000a118:	72 06       	ld.w	r6,r9[0x0]
8000a11a:	fa ce f9 44 	sub	lr,sp,-1724
8000a11e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a122:	f3 46 fd 88 	st.w	r9[-632],r6
8000a126:	2f f8       	sub	r8,-1
8000a128:	fb 48 06 b4 	st.w	sp[1716],r8
8000a12c:	c0 48       	rjmp	8000a134 <_vfprintf_r+0x1090>
8000a12e:	72 06       	ld.w	r6,r9[0x0]
8000a130:	2f c9       	sub	r9,-4
8000a132:	51 09       	stdsp	sp[0x40],r9
8000a134:	40 2c       	lddsp	r12,sp[0x8]
8000a136:	58 0c       	cp.w	r12,0
8000a138:	c1 05       	brlt	8000a158 <_vfprintf_r+0x10b4>
8000a13a:	18 9a       	mov	r10,r12
8000a13c:	30 0b       	mov	r11,0
8000a13e:	0c 9c       	mov	r12,r6
8000a140:	e0 a0 12 38 	rcall	8000c5b0 <memchr>
8000a144:	e0 80 02 df 	breq	8000a702 <_vfprintf_r+0x165e>
8000a148:	f8 06 01 02 	sub	r2,r12,r6
8000a14c:	40 2b       	lddsp	r11,sp[0x8]
8000a14e:	16 32       	cp.w	r2,r11
8000a150:	e0 89 02 d9 	brgt	8000a702 <_vfprintf_r+0x165e>
8000a154:	e0 8f 02 d4 	bral	8000a6fc <_vfprintf_r+0x1658>
8000a158:	30 0a       	mov	r10,0
8000a15a:	0c 9c       	mov	r12,r6
8000a15c:	50 2a       	stdsp	sp[0x8],r10
8000a15e:	e0 a0 15 99 	rcall	8000cc90 <strlen>
8000a162:	18 92       	mov	r2,r12
8000a164:	e0 8f 02 d2 	bral	8000a708 <_vfprintf_r+0x1664>
8000a168:	50 a7       	stdsp	sp[0x28],r7
8000a16a:	50 80       	stdsp	sp[0x20],r0
8000a16c:	0c 97       	mov	r7,r6
8000a16e:	04 94       	mov	r4,r2
8000a170:	06 96       	mov	r6,r3
8000a172:	02 92       	mov	r2,r1
8000a174:	40 93       	lddsp	r3,sp[0x24]
8000a176:	10 90       	mov	r0,r8
8000a178:	40 41       	lddsp	r1,sp[0x10]
8000a17a:	a5 a5       	sbr	r5,0x4
8000a17c:	c0 a8       	rjmp	8000a190 <_vfprintf_r+0x10ec>
8000a17e:	50 a7       	stdsp	sp[0x28],r7
8000a180:	50 80       	stdsp	sp[0x20],r0
8000a182:	0c 97       	mov	r7,r6
8000a184:	04 94       	mov	r4,r2
8000a186:	06 96       	mov	r6,r3
8000a188:	02 92       	mov	r2,r1
8000a18a:	40 93       	lddsp	r3,sp[0x24]
8000a18c:	10 90       	mov	r0,r8
8000a18e:	40 41       	lddsp	r1,sp[0x10]
8000a190:	ed b5 00 05 	bld	r5,0x5
8000a194:	c5 61       	brne	8000a240 <_vfprintf_r+0x119c>
8000a196:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a19a:	40 39       	lddsp	r9,sp[0xc]
8000a19c:	58 09       	cp.w	r9,0
8000a19e:	c2 10       	breq	8000a1e0 <_vfprintf_r+0x113c>
8000a1a0:	10 36       	cp.w	r6,r8
8000a1a2:	c0 74       	brge	8000a1b0 <_vfprintf_r+0x110c>
8000a1a4:	fa c8 f9 44 	sub	r8,sp,-1724
8000a1a8:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a1ac:	c2 38       	rjmp	8000a1f2 <_vfprintf_r+0x114e>
8000a1ae:	d7 03       	nop
8000a1b0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a1b4:	1a d8       	st.w	--sp,r8
8000a1b6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a1ba:	1a d8       	st.w	--sp,r8
8000a1bc:	fa c8 fb b4 	sub	r8,sp,-1100
8000a1c0:	1a d8       	st.w	--sp,r8
8000a1c2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a1c6:	fa c9 ff b4 	sub	r9,sp,-76
8000a1ca:	04 9a       	mov	r10,r2
8000a1cc:	0c 9b       	mov	r11,r6
8000a1ce:	08 9c       	mov	r12,r4
8000a1d0:	fe b0 f5 d2 	rcall	80008d74 <get_arg>
8000a1d4:	2f dd       	sub	sp,-12
8000a1d6:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a1da:	fa e9 00 00 	st.d	sp[0],r8
8000a1de:	c2 e8       	rjmp	8000a23a <_vfprintf_r+0x1196>
8000a1e0:	ee ca ff ff 	sub	r10,r7,-1
8000a1e4:	10 37       	cp.w	r7,r8
8000a1e6:	c0 b4       	brge	8000a1fc <_vfprintf_r+0x1158>
8000a1e8:	fa c8 f9 44 	sub	r8,sp,-1724
8000a1ec:	14 97       	mov	r7,r10
8000a1ee:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a1f2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a1f6:	fa eb 00 00 	st.d	sp[0],r10
8000a1fa:	c2 08       	rjmp	8000a23a <_vfprintf_r+0x1196>
8000a1fc:	41 09       	lddsp	r9,sp[0x40]
8000a1fe:	59 f8       	cp.w	r8,31
8000a200:	e0 89 00 16 	brgt	8000a22c <_vfprintf_r+0x1188>
8000a204:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a208:	f2 cb ff f8 	sub	r11,r9,-8
8000a20c:	fa e7 00 00 	st.d	sp[0],r6
8000a210:	51 0b       	stdsp	sp[0x40],r11
8000a212:	fa c6 f9 44 	sub	r6,sp,-1724
8000a216:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a21a:	fa e6 00 00 	ld.d	r6,sp[0]
8000a21e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a222:	2f f8       	sub	r8,-1
8000a224:	14 97       	mov	r7,r10
8000a226:	fb 48 06 b4 	st.w	sp[1716],r8
8000a22a:	c0 88       	rjmp	8000a23a <_vfprintf_r+0x1196>
8000a22c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a230:	2f 89       	sub	r9,-8
8000a232:	fa e7 00 00 	st.d	sp[0],r6
8000a236:	51 09       	stdsp	sp[0x40],r9
8000a238:	14 97       	mov	r7,r10
8000a23a:	30 18       	mov	r8,1
8000a23c:	e0 8f 01 d0 	bral	8000a5dc <_vfprintf_r+0x1538>
8000a240:	ed b5 00 04 	bld	r5,0x4
8000a244:	c1 61       	brne	8000a270 <_vfprintf_r+0x11cc>
8000a246:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a24a:	40 3e       	lddsp	lr,sp[0xc]
8000a24c:	58 0e       	cp.w	lr,0
8000a24e:	c0 80       	breq	8000a25e <_vfprintf_r+0x11ba>
8000a250:	10 36       	cp.w	r6,r8
8000a252:	c6 74       	brge	8000a320 <_vfprintf_r+0x127c>
8000a254:	fa cc f9 44 	sub	r12,sp,-1724
8000a258:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a25c:	c8 08       	rjmp	8000a35c <_vfprintf_r+0x12b8>
8000a25e:	ee ca ff ff 	sub	r10,r7,-1
8000a262:	10 37       	cp.w	r7,r8
8000a264:	c7 f4       	brge	8000a362 <_vfprintf_r+0x12be>
8000a266:	fa cb f9 44 	sub	r11,sp,-1724
8000a26a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a26e:	c7 68       	rjmp	8000a35a <_vfprintf_r+0x12b6>
8000a270:	ed b5 00 06 	bld	r5,0x6
8000a274:	c4 a1       	brne	8000a308 <_vfprintf_r+0x1264>
8000a276:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a27a:	40 3c       	lddsp	r12,sp[0xc]
8000a27c:	58 0c       	cp.w	r12,0
8000a27e:	c1 d0       	breq	8000a2b8 <_vfprintf_r+0x1214>
8000a280:	10 36       	cp.w	r6,r8
8000a282:	c0 64       	brge	8000a28e <_vfprintf_r+0x11ea>
8000a284:	fa cb f9 44 	sub	r11,sp,-1724
8000a288:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a28c:	c1 f8       	rjmp	8000a2ca <_vfprintf_r+0x1226>
8000a28e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a292:	1a d8       	st.w	--sp,r8
8000a294:	fa c8 fa b8 	sub	r8,sp,-1352
8000a298:	1a d8       	st.w	--sp,r8
8000a29a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a29e:	1a d8       	st.w	--sp,r8
8000a2a0:	fa c8 f9 40 	sub	r8,sp,-1728
8000a2a4:	fa c9 ff b4 	sub	r9,sp,-76
8000a2a8:	04 9a       	mov	r10,r2
8000a2aa:	0c 9b       	mov	r11,r6
8000a2ac:	08 9c       	mov	r12,r4
8000a2ae:	fe b0 f5 63 	rcall	80008d74 <get_arg>
8000a2b2:	2f dd       	sub	sp,-12
8000a2b4:	98 18       	ld.sh	r8,r12[0x2]
8000a2b6:	c2 68       	rjmp	8000a302 <_vfprintf_r+0x125e>
8000a2b8:	ee ca ff ff 	sub	r10,r7,-1
8000a2bc:	10 37       	cp.w	r7,r8
8000a2be:	c0 94       	brge	8000a2d0 <_vfprintf_r+0x122c>
8000a2c0:	fa c9 f9 44 	sub	r9,sp,-1724
8000a2c4:	14 97       	mov	r7,r10
8000a2c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a2ca:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a2ce:	c1 a8       	rjmp	8000a302 <_vfprintf_r+0x125e>
8000a2d0:	41 09       	lddsp	r9,sp[0x40]
8000a2d2:	59 f8       	cp.w	r8,31
8000a2d4:	e0 89 00 13 	brgt	8000a2fa <_vfprintf_r+0x1256>
8000a2d8:	f2 cb ff fc 	sub	r11,r9,-4
8000a2dc:	51 0b       	stdsp	sp[0x40],r11
8000a2de:	72 09       	ld.w	r9,r9[0x0]
8000a2e0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a2e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a2e8:	2f f8       	sub	r8,-1
8000a2ea:	f7 49 fd 88 	st.w	r11[-632],r9
8000a2ee:	fb 48 06 b4 	st.w	sp[1716],r8
8000a2f2:	14 97       	mov	r7,r10
8000a2f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a2f8:	c0 58       	rjmp	8000a302 <_vfprintf_r+0x125e>
8000a2fa:	92 18       	ld.sh	r8,r9[0x2]
8000a2fc:	14 97       	mov	r7,r10
8000a2fe:	2f c9       	sub	r9,-4
8000a300:	51 09       	stdsp	sp[0x40],r9
8000a302:	5c 78       	castu.h	r8
8000a304:	50 18       	stdsp	sp[0x4],r8
8000a306:	c4 68       	rjmp	8000a392 <_vfprintf_r+0x12ee>
8000a308:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a30c:	40 3c       	lddsp	r12,sp[0xc]
8000a30e:	58 0c       	cp.w	r12,0
8000a310:	c1 d0       	breq	8000a34a <_vfprintf_r+0x12a6>
8000a312:	10 36       	cp.w	r6,r8
8000a314:	c0 64       	brge	8000a320 <_vfprintf_r+0x127c>
8000a316:	fa cb f9 44 	sub	r11,sp,-1724
8000a31a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a31e:	c1 f8       	rjmp	8000a35c <_vfprintf_r+0x12b8>
8000a320:	fa c8 f9 50 	sub	r8,sp,-1712
8000a324:	1a d8       	st.w	--sp,r8
8000a326:	fa c8 fa b8 	sub	r8,sp,-1352
8000a32a:	0c 9b       	mov	r11,r6
8000a32c:	1a d8       	st.w	--sp,r8
8000a32e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a332:	04 9a       	mov	r10,r2
8000a334:	1a d8       	st.w	--sp,r8
8000a336:	08 9c       	mov	r12,r4
8000a338:	fa c8 f9 40 	sub	r8,sp,-1728
8000a33c:	fa c9 ff b4 	sub	r9,sp,-76
8000a340:	fe b0 f5 1a 	rcall	80008d74 <get_arg>
8000a344:	2f dd       	sub	sp,-12
8000a346:	78 0b       	ld.w	r11,r12[0x0]
8000a348:	c2 48       	rjmp	8000a390 <_vfprintf_r+0x12ec>
8000a34a:	ee ca ff ff 	sub	r10,r7,-1
8000a34e:	10 37       	cp.w	r7,r8
8000a350:	c0 94       	brge	8000a362 <_vfprintf_r+0x12be>
8000a352:	fa c9 f9 44 	sub	r9,sp,-1724
8000a356:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a35a:	14 97       	mov	r7,r10
8000a35c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a360:	c1 88       	rjmp	8000a390 <_vfprintf_r+0x12ec>
8000a362:	41 09       	lddsp	r9,sp[0x40]
8000a364:	59 f8       	cp.w	r8,31
8000a366:	e0 89 00 11 	brgt	8000a388 <_vfprintf_r+0x12e4>
8000a36a:	f2 cb ff fc 	sub	r11,r9,-4
8000a36e:	51 0b       	stdsp	sp[0x40],r11
8000a370:	fa c6 f9 44 	sub	r6,sp,-1724
8000a374:	72 0b       	ld.w	r11,r9[0x0]
8000a376:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a37a:	f3 4b fd 88 	st.w	r9[-632],r11
8000a37e:	2f f8       	sub	r8,-1
8000a380:	14 97       	mov	r7,r10
8000a382:	fb 48 06 b4 	st.w	sp[1716],r8
8000a386:	c0 58       	rjmp	8000a390 <_vfprintf_r+0x12ec>
8000a388:	72 0b       	ld.w	r11,r9[0x0]
8000a38a:	14 97       	mov	r7,r10
8000a38c:	2f c9       	sub	r9,-4
8000a38e:	51 09       	stdsp	sp[0x40],r9
8000a390:	50 1b       	stdsp	sp[0x4],r11
8000a392:	30 0e       	mov	lr,0
8000a394:	30 18       	mov	r8,1
8000a396:	50 0e       	stdsp	sp[0x0],lr
8000a398:	c2 29       	rjmp	8000a5dc <_vfprintf_r+0x1538>
8000a39a:	50 a7       	stdsp	sp[0x28],r7
8000a39c:	50 80       	stdsp	sp[0x20],r0
8000a39e:	0c 97       	mov	r7,r6
8000a3a0:	04 94       	mov	r4,r2
8000a3a2:	06 96       	mov	r6,r3
8000a3a4:	02 92       	mov	r2,r1
8000a3a6:	fe cc b0 6a 	sub	r12,pc,-20374
8000a3aa:	40 93       	lddsp	r3,sp[0x24]
8000a3ac:	10 90       	mov	r0,r8
8000a3ae:	40 41       	lddsp	r1,sp[0x10]
8000a3b0:	50 dc       	stdsp	sp[0x34],r12
8000a3b2:	ed b5 00 05 	bld	r5,0x5
8000a3b6:	c5 51       	brne	8000a460 <_vfprintf_r+0x13bc>
8000a3b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a3bc:	40 3b       	lddsp	r11,sp[0xc]
8000a3be:	58 0b       	cp.w	r11,0
8000a3c0:	c2 20       	breq	8000a404 <_vfprintf_r+0x1360>
8000a3c2:	10 36       	cp.w	r6,r8
8000a3c4:	c0 a4       	brge	8000a3d8 <_vfprintf_r+0x1334>
8000a3c6:	fa ca f9 44 	sub	r10,sp,-1724
8000a3ca:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a3ce:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a3d2:	fa e9 00 00 	st.d	sp[0],r8
8000a3d6:	cf 28       	rjmp	8000a5ba <_vfprintf_r+0x1516>
8000a3d8:	fa c8 f9 50 	sub	r8,sp,-1712
8000a3dc:	1a d8       	st.w	--sp,r8
8000a3de:	fa c8 fa b8 	sub	r8,sp,-1352
8000a3e2:	04 9a       	mov	r10,r2
8000a3e4:	1a d8       	st.w	--sp,r8
8000a3e6:	0c 9b       	mov	r11,r6
8000a3e8:	fa c8 fb b4 	sub	r8,sp,-1100
8000a3ec:	08 9c       	mov	r12,r4
8000a3ee:	1a d8       	st.w	--sp,r8
8000a3f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000a3f4:	fa c9 ff b4 	sub	r9,sp,-76
8000a3f8:	fe b0 f4 be 	rcall	80008d74 <get_arg>
8000a3fc:	2f dd       	sub	sp,-12
8000a3fe:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a402:	c0 c8       	rjmp	8000a41a <_vfprintf_r+0x1376>
8000a404:	ee ca ff ff 	sub	r10,r7,-1
8000a408:	10 37       	cp.w	r7,r8
8000a40a:	c0 b4       	brge	8000a420 <_vfprintf_r+0x137c>
8000a40c:	fa c9 f9 44 	sub	r9,sp,-1724
8000a410:	14 97       	mov	r7,r10
8000a412:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a416:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a41a:	fa eb 00 00 	st.d	sp[0],r10
8000a41e:	cc e8       	rjmp	8000a5ba <_vfprintf_r+0x1516>
8000a420:	41 09       	lddsp	r9,sp[0x40]
8000a422:	59 f8       	cp.w	r8,31
8000a424:	e0 89 00 16 	brgt	8000a450 <_vfprintf_r+0x13ac>
8000a428:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a42c:	f2 cb ff f8 	sub	r11,r9,-8
8000a430:	fa e7 00 00 	st.d	sp[0],r6
8000a434:	51 0b       	stdsp	sp[0x40],r11
8000a436:	fa c6 f9 44 	sub	r6,sp,-1724
8000a43a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a43e:	fa e6 00 00 	ld.d	r6,sp[0]
8000a442:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a446:	2f f8       	sub	r8,-1
8000a448:	14 97       	mov	r7,r10
8000a44a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a44e:	cb 68       	rjmp	8000a5ba <_vfprintf_r+0x1516>
8000a450:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a454:	2f 89       	sub	r9,-8
8000a456:	fa e7 00 00 	st.d	sp[0],r6
8000a45a:	51 09       	stdsp	sp[0x40],r9
8000a45c:	14 97       	mov	r7,r10
8000a45e:	ca e8       	rjmp	8000a5ba <_vfprintf_r+0x1516>
8000a460:	ed b5 00 04 	bld	r5,0x4
8000a464:	c1 71       	brne	8000a492 <_vfprintf_r+0x13ee>
8000a466:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a46a:	40 3e       	lddsp	lr,sp[0xc]
8000a46c:	58 0e       	cp.w	lr,0
8000a46e:	c0 80       	breq	8000a47e <_vfprintf_r+0x13da>
8000a470:	10 36       	cp.w	r6,r8
8000a472:	c6 94       	brge	8000a544 <_vfprintf_r+0x14a0>
8000a474:	fa cc f9 44 	sub	r12,sp,-1724
8000a478:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a47c:	c8 28       	rjmp	8000a580 <_vfprintf_r+0x14dc>
8000a47e:	ee ca ff ff 	sub	r10,r7,-1
8000a482:	10 37       	cp.w	r7,r8
8000a484:	e0 84 00 81 	brge	8000a586 <_vfprintf_r+0x14e2>
8000a488:	fa cb f9 44 	sub	r11,sp,-1724
8000a48c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a490:	c7 78       	rjmp	8000a57e <_vfprintf_r+0x14da>
8000a492:	ed b5 00 06 	bld	r5,0x6
8000a496:	c4 b1       	brne	8000a52c <_vfprintf_r+0x1488>
8000a498:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a49c:	40 3c       	lddsp	r12,sp[0xc]
8000a49e:	58 0c       	cp.w	r12,0
8000a4a0:	c1 d0       	breq	8000a4da <_vfprintf_r+0x1436>
8000a4a2:	10 36       	cp.w	r6,r8
8000a4a4:	c0 64       	brge	8000a4b0 <_vfprintf_r+0x140c>
8000a4a6:	fa cb f9 44 	sub	r11,sp,-1724
8000a4aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a4ae:	c1 f8       	rjmp	8000a4ec <_vfprintf_r+0x1448>
8000a4b0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a4b4:	1a d8       	st.w	--sp,r8
8000a4b6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a4ba:	1a d8       	st.w	--sp,r8
8000a4bc:	fa c8 fb b4 	sub	r8,sp,-1100
8000a4c0:	1a d8       	st.w	--sp,r8
8000a4c2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a4c6:	fa c9 ff b4 	sub	r9,sp,-76
8000a4ca:	04 9a       	mov	r10,r2
8000a4cc:	0c 9b       	mov	r11,r6
8000a4ce:	08 9c       	mov	r12,r4
8000a4d0:	fe b0 f4 52 	rcall	80008d74 <get_arg>
8000a4d4:	2f dd       	sub	sp,-12
8000a4d6:	98 18       	ld.sh	r8,r12[0x2]
8000a4d8:	c2 78       	rjmp	8000a526 <_vfprintf_r+0x1482>
8000a4da:	ee ca ff ff 	sub	r10,r7,-1
8000a4de:	10 37       	cp.w	r7,r8
8000a4e0:	c0 a4       	brge	8000a4f4 <_vfprintf_r+0x1450>
8000a4e2:	fa c9 f9 44 	sub	r9,sp,-1724
8000a4e6:	14 97       	mov	r7,r10
8000a4e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a4ec:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a4f0:	c1 b8       	rjmp	8000a526 <_vfprintf_r+0x1482>
8000a4f2:	d7 03       	nop
8000a4f4:	41 09       	lddsp	r9,sp[0x40]
8000a4f6:	59 f8       	cp.w	r8,31
8000a4f8:	e0 89 00 13 	brgt	8000a51e <_vfprintf_r+0x147a>
8000a4fc:	f2 cb ff fc 	sub	r11,r9,-4
8000a500:	51 0b       	stdsp	sp[0x40],r11
8000a502:	72 09       	ld.w	r9,r9[0x0]
8000a504:	fa c6 f9 44 	sub	r6,sp,-1724
8000a508:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a50c:	2f f8       	sub	r8,-1
8000a50e:	f7 49 fd 88 	st.w	r11[-632],r9
8000a512:	fb 48 06 b4 	st.w	sp[1716],r8
8000a516:	14 97       	mov	r7,r10
8000a518:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a51c:	c0 58       	rjmp	8000a526 <_vfprintf_r+0x1482>
8000a51e:	92 18       	ld.sh	r8,r9[0x2]
8000a520:	14 97       	mov	r7,r10
8000a522:	2f c9       	sub	r9,-4
8000a524:	51 09       	stdsp	sp[0x40],r9
8000a526:	5c 78       	castu.h	r8
8000a528:	50 18       	stdsp	sp[0x4],r8
8000a52a:	c4 68       	rjmp	8000a5b6 <_vfprintf_r+0x1512>
8000a52c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a530:	40 3c       	lddsp	r12,sp[0xc]
8000a532:	58 0c       	cp.w	r12,0
8000a534:	c1 d0       	breq	8000a56e <_vfprintf_r+0x14ca>
8000a536:	10 36       	cp.w	r6,r8
8000a538:	c0 64       	brge	8000a544 <_vfprintf_r+0x14a0>
8000a53a:	fa cb f9 44 	sub	r11,sp,-1724
8000a53e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a542:	c1 f8       	rjmp	8000a580 <_vfprintf_r+0x14dc>
8000a544:	fa c8 f9 50 	sub	r8,sp,-1712
8000a548:	1a d8       	st.w	--sp,r8
8000a54a:	fa c8 fa b8 	sub	r8,sp,-1352
8000a54e:	0c 9b       	mov	r11,r6
8000a550:	1a d8       	st.w	--sp,r8
8000a552:	fa c8 fb b4 	sub	r8,sp,-1100
8000a556:	04 9a       	mov	r10,r2
8000a558:	1a d8       	st.w	--sp,r8
8000a55a:	08 9c       	mov	r12,r4
8000a55c:	fa c8 f9 40 	sub	r8,sp,-1728
8000a560:	fa c9 ff b4 	sub	r9,sp,-76
8000a564:	fe b0 f4 08 	rcall	80008d74 <get_arg>
8000a568:	2f dd       	sub	sp,-12
8000a56a:	78 0b       	ld.w	r11,r12[0x0]
8000a56c:	c2 48       	rjmp	8000a5b4 <_vfprintf_r+0x1510>
8000a56e:	ee ca ff ff 	sub	r10,r7,-1
8000a572:	10 37       	cp.w	r7,r8
8000a574:	c0 94       	brge	8000a586 <_vfprintf_r+0x14e2>
8000a576:	fa c9 f9 44 	sub	r9,sp,-1724
8000a57a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a57e:	14 97       	mov	r7,r10
8000a580:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a584:	c1 88       	rjmp	8000a5b4 <_vfprintf_r+0x1510>
8000a586:	41 09       	lddsp	r9,sp[0x40]
8000a588:	59 f8       	cp.w	r8,31
8000a58a:	e0 89 00 11 	brgt	8000a5ac <_vfprintf_r+0x1508>
8000a58e:	f2 cb ff fc 	sub	r11,r9,-4
8000a592:	51 0b       	stdsp	sp[0x40],r11
8000a594:	fa c6 f9 44 	sub	r6,sp,-1724
8000a598:	72 0b       	ld.w	r11,r9[0x0]
8000a59a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a59e:	f3 4b fd 88 	st.w	r9[-632],r11
8000a5a2:	2f f8       	sub	r8,-1
8000a5a4:	14 97       	mov	r7,r10
8000a5a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000a5aa:	c0 58       	rjmp	8000a5b4 <_vfprintf_r+0x1510>
8000a5ac:	72 0b       	ld.w	r11,r9[0x0]
8000a5ae:	14 97       	mov	r7,r10
8000a5b0:	2f c9       	sub	r9,-4
8000a5b2:	51 09       	stdsp	sp[0x40],r9
8000a5b4:	50 1b       	stdsp	sp[0x4],r11
8000a5b6:	30 0e       	mov	lr,0
8000a5b8:	50 0e       	stdsp	sp[0x0],lr
8000a5ba:	40 08       	lddsp	r8,sp[0x0]
8000a5bc:	40 1c       	lddsp	r12,sp[0x4]
8000a5be:	18 48       	or	r8,r12
8000a5c0:	5f 19       	srne	r9
8000a5c2:	0a 98       	mov	r8,r5
8000a5c4:	eb e9 00 09 	and	r9,r5,r9
8000a5c8:	a1 b8       	sbr	r8,0x1
8000a5ca:	58 09       	cp.w	r9,0
8000a5cc:	c0 70       	breq	8000a5da <_vfprintf_r+0x1536>
8000a5ce:	10 95       	mov	r5,r8
8000a5d0:	fb 60 06 b9 	st.b	sp[1721],r0
8000a5d4:	33 08       	mov	r8,48
8000a5d6:	fb 68 06 b8 	st.b	sp[1720],r8
8000a5da:	30 28       	mov	r8,2
8000a5dc:	30 09       	mov	r9,0
8000a5de:	fb 69 06 bb 	st.b	sp[1723],r9
8000a5e2:	0a 99       	mov	r9,r5
8000a5e4:	a7 d9       	cbr	r9,0x7
8000a5e6:	40 2b       	lddsp	r11,sp[0x8]
8000a5e8:	40 16       	lddsp	r6,sp[0x4]
8000a5ea:	58 0b       	cp.w	r11,0
8000a5ec:	5f 1a       	srne	r10
8000a5ee:	f2 05 17 40 	movge	r5,r9
8000a5f2:	fa c2 f9 78 	sub	r2,sp,-1672
8000a5f6:	40 09       	lddsp	r9,sp[0x0]
8000a5f8:	0c 49       	or	r9,r6
8000a5fa:	5f 19       	srne	r9
8000a5fc:	f5 e9 10 09 	or	r9,r10,r9
8000a600:	c5 c0       	breq	8000a6b8 <_vfprintf_r+0x1614>
8000a602:	30 19       	mov	r9,1
8000a604:	f2 08 18 00 	cp.b	r8,r9
8000a608:	c0 60       	breq	8000a614 <_vfprintf_r+0x1570>
8000a60a:	30 29       	mov	r9,2
8000a60c:	f2 08 18 00 	cp.b	r8,r9
8000a610:	c0 41       	brne	8000a618 <_vfprintf_r+0x1574>
8000a612:	c3 c8       	rjmp	8000a68a <_vfprintf_r+0x15e6>
8000a614:	04 96       	mov	r6,r2
8000a616:	c3 08       	rjmp	8000a676 <_vfprintf_r+0x15d2>
8000a618:	04 96       	mov	r6,r2
8000a61a:	fa e8 00 00 	ld.d	r8,sp[0]
8000a61e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a622:	2d 0a       	sub	r10,-48
8000a624:	0c fa       	st.b	--r6,r10
8000a626:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a62a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a62e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a632:	18 99       	mov	r9,r12
8000a634:	16 98       	mov	r8,r11
8000a636:	58 08       	cp.w	r8,0
8000a638:	5c 29       	cpc	r9
8000a63a:	cf 21       	brne	8000a61e <_vfprintf_r+0x157a>
8000a63c:	fa e9 00 00 	st.d	sp[0],r8
8000a640:	ed b5 00 00 	bld	r5,0x0
8000a644:	c4 51       	brne	8000a6ce <_vfprintf_r+0x162a>
8000a646:	33 09       	mov	r9,48
8000a648:	f2 0a 18 00 	cp.b	r10,r9
8000a64c:	c4 10       	breq	8000a6ce <_vfprintf_r+0x162a>
8000a64e:	0c f9       	st.b	--r6,r9
8000a650:	c3 f8       	rjmp	8000a6ce <_vfprintf_r+0x162a>
8000a652:	fa ea 00 00 	ld.d	r10,sp[0]
8000a656:	30 a8       	mov	r8,10
8000a658:	30 09       	mov	r9,0
8000a65a:	e0 a0 1a 19 	rcall	8000da8c <__avr32_umod64>
8000a65e:	30 a8       	mov	r8,10
8000a660:	2d 0a       	sub	r10,-48
8000a662:	30 09       	mov	r9,0
8000a664:	ac 8a       	st.b	r6[0x0],r10
8000a666:	fa ea 00 00 	ld.d	r10,sp[0]
8000a66a:	e0 a0 18 df 	rcall	8000d828 <__avr32_udiv64>
8000a66e:	16 99       	mov	r9,r11
8000a670:	14 98       	mov	r8,r10
8000a672:	fa e9 00 00 	st.d	sp[0],r8
8000a676:	20 16       	sub	r6,1
8000a678:	fa ea 00 00 	ld.d	r10,sp[0]
8000a67c:	58 9a       	cp.w	r10,9
8000a67e:	5c 2b       	cpc	r11
8000a680:	fe 9b ff e9 	brhi	8000a652 <_vfprintf_r+0x15ae>
8000a684:	1b f8       	ld.ub	r8,sp[0x7]
8000a686:	2d 08       	sub	r8,-48
8000a688:	c2 08       	rjmp	8000a6c8 <_vfprintf_r+0x1624>
8000a68a:	04 96       	mov	r6,r2
8000a68c:	fa e8 00 00 	ld.d	r8,sp[0]
8000a690:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a694:	40 de       	lddsp	lr,sp[0x34]
8000a696:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a69a:	0c fa       	st.b	--r6,r10
8000a69c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a6a0:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a6a4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a6a8:	16 99       	mov	r9,r11
8000a6aa:	14 98       	mov	r8,r10
8000a6ac:	58 08       	cp.w	r8,0
8000a6ae:	5c 29       	cpc	r9
8000a6b0:	cf 01       	brne	8000a690 <_vfprintf_r+0x15ec>
8000a6b2:	fa e9 00 00 	st.d	sp[0],r8
8000a6b6:	c0 c8       	rjmp	8000a6ce <_vfprintf_r+0x162a>
8000a6b8:	58 08       	cp.w	r8,0
8000a6ba:	c0 91       	brne	8000a6cc <_vfprintf_r+0x1628>
8000a6bc:	ed b5 00 00 	bld	r5,0x0
8000a6c0:	c0 61       	brne	8000a6cc <_vfprintf_r+0x1628>
8000a6c2:	fa c6 f9 79 	sub	r6,sp,-1671
8000a6c6:	33 08       	mov	r8,48
8000a6c8:	ac 88       	st.b	r6[0x0],r8
8000a6ca:	c0 28       	rjmp	8000a6ce <_vfprintf_r+0x162a>
8000a6cc:	04 96       	mov	r6,r2
8000a6ce:	0c 12       	sub	r2,r6
8000a6d0:	c1 c8       	rjmp	8000a708 <_vfprintf_r+0x1664>
8000a6d2:	50 a7       	stdsp	sp[0x28],r7
8000a6d4:	50 80       	stdsp	sp[0x20],r0
8000a6d6:	40 93       	lddsp	r3,sp[0x24]
8000a6d8:	0c 97       	mov	r7,r6
8000a6da:	10 90       	mov	r0,r8
8000a6dc:	04 94       	mov	r4,r2
8000a6de:	40 41       	lddsp	r1,sp[0x10]
8000a6e0:	58 08       	cp.w	r8,0
8000a6e2:	e0 80 04 4f 	breq	8000af80 <_vfprintf_r+0x1edc>
8000a6e6:	fb 68 06 60 	st.b	sp[1632],r8
8000a6ea:	30 0c       	mov	r12,0
8000a6ec:	30 08       	mov	r8,0
8000a6ee:	30 12       	mov	r2,1
8000a6f0:	fb 68 06 bb 	st.b	sp[1723],r8
8000a6f4:	50 2c       	stdsp	sp[0x8],r12
8000a6f6:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a6fa:	c0 78       	rjmp	8000a708 <_vfprintf_r+0x1664>
8000a6fc:	30 0b       	mov	r11,0
8000a6fe:	50 2b       	stdsp	sp[0x8],r11
8000a700:	c0 48       	rjmp	8000a708 <_vfprintf_r+0x1664>
8000a702:	40 22       	lddsp	r2,sp[0x8]
8000a704:	30 0a       	mov	r10,0
8000a706:	50 2a       	stdsp	sp[0x8],r10
8000a708:	40 29       	lddsp	r9,sp[0x8]
8000a70a:	e4 09 0c 49 	max	r9,r2,r9
8000a70e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a712:	50 39       	stdsp	sp[0xc],r9
8000a714:	0a 9e       	mov	lr,r5
8000a716:	30 09       	mov	r9,0
8000a718:	e2 1e 00 02 	andl	lr,0x2,COH
8000a71c:	f2 08 18 00 	cp.b	r8,r9
8000a720:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a724:	f7 b8 01 ff 	subne	r8,-1
8000a728:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a72c:	0a 9b       	mov	r11,r5
8000a72e:	58 0e       	cp.w	lr,0
8000a730:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a734:	f7 bc 01 fe 	subne	r12,-2
8000a738:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a73c:	e2 1b 00 84 	andl	r11,0x84,COH
8000a740:	50 fe       	stdsp	sp[0x3c],lr
8000a742:	50 9b       	stdsp	sp[0x24],r11
8000a744:	c4 71       	brne	8000a7d2 <_vfprintf_r+0x172e>
8000a746:	40 8a       	lddsp	r10,sp[0x20]
8000a748:	40 39       	lddsp	r9,sp[0xc]
8000a74a:	12 1a       	sub	r10,r9
8000a74c:	50 4a       	stdsp	sp[0x10],r10
8000a74e:	58 0a       	cp.w	r10,0
8000a750:	e0 89 00 20 	brgt	8000a790 <_vfprintf_r+0x16ec>
8000a754:	c3 f8       	rjmp	8000a7d2 <_vfprintf_r+0x172e>
8000a756:	2f 09       	sub	r9,-16
8000a758:	2f f8       	sub	r8,-1
8000a75a:	fe ce b4 06 	sub	lr,pc,-19450
8000a75e:	31 0c       	mov	r12,16
8000a760:	fb 49 06 90 	st.w	sp[1680],r9
8000a764:	87 0e       	st.w	r3[0x0],lr
8000a766:	87 1c       	st.w	r3[0x4],r12
8000a768:	fb 48 06 8c 	st.w	sp[1676],r8
8000a76c:	58 78       	cp.w	r8,7
8000a76e:	e0 89 00 04 	brgt	8000a776 <_vfprintf_r+0x16d2>
8000a772:	2f 83       	sub	r3,-8
8000a774:	c0 b8       	rjmp	8000a78a <_vfprintf_r+0x16e6>
8000a776:	fa ca f9 78 	sub	r10,sp,-1672
8000a77a:	02 9b       	mov	r11,r1
8000a77c:	08 9c       	mov	r12,r4
8000a77e:	fe b0 f4 85 	rcall	80009088 <__sprint_r>
8000a782:	e0 81 04 10 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a786:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a78a:	40 4b       	lddsp	r11,sp[0x10]
8000a78c:	21 0b       	sub	r11,16
8000a78e:	50 4b       	stdsp	sp[0x10],r11
8000a790:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a794:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a798:	fe ca b4 44 	sub	r10,pc,-19388
8000a79c:	40 4e       	lddsp	lr,sp[0x10]
8000a79e:	59 0e       	cp.w	lr,16
8000a7a0:	fe 99 ff db 	brgt	8000a756 <_vfprintf_r+0x16b2>
8000a7a4:	1c 09       	add	r9,lr
8000a7a6:	2f f8       	sub	r8,-1
8000a7a8:	87 0a       	st.w	r3[0x0],r10
8000a7aa:	fb 49 06 90 	st.w	sp[1680],r9
8000a7ae:	87 1e       	st.w	r3[0x4],lr
8000a7b0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7b4:	58 78       	cp.w	r8,7
8000a7b6:	e0 89 00 04 	brgt	8000a7be <_vfprintf_r+0x171a>
8000a7ba:	2f 83       	sub	r3,-8
8000a7bc:	c0 b8       	rjmp	8000a7d2 <_vfprintf_r+0x172e>
8000a7be:	fa ca f9 78 	sub	r10,sp,-1672
8000a7c2:	02 9b       	mov	r11,r1
8000a7c4:	08 9c       	mov	r12,r4
8000a7c6:	fe b0 f4 61 	rcall	80009088 <__sprint_r>
8000a7ca:	e0 81 03 ec 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a7ce:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7d2:	30 09       	mov	r9,0
8000a7d4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a7d8:	f2 08 18 00 	cp.b	r8,r9
8000a7dc:	c1 f0       	breq	8000a81a <_vfprintf_r+0x1776>
8000a7de:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7e2:	fa c9 f9 45 	sub	r9,sp,-1723
8000a7e6:	2f f8       	sub	r8,-1
8000a7e8:	87 09       	st.w	r3[0x0],r9
8000a7ea:	fb 48 06 90 	st.w	sp[1680],r8
8000a7ee:	30 19       	mov	r9,1
8000a7f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7f4:	87 19       	st.w	r3[0x4],r9
8000a7f6:	2f f8       	sub	r8,-1
8000a7f8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7fc:	58 78       	cp.w	r8,7
8000a7fe:	e0 89 00 04 	brgt	8000a806 <_vfprintf_r+0x1762>
8000a802:	2f 83       	sub	r3,-8
8000a804:	c0 b8       	rjmp	8000a81a <_vfprintf_r+0x1776>
8000a806:	fa ca f9 78 	sub	r10,sp,-1672
8000a80a:	02 9b       	mov	r11,r1
8000a80c:	08 9c       	mov	r12,r4
8000a80e:	fe b0 f4 3d 	rcall	80009088 <__sprint_r>
8000a812:	e0 81 03 c8 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a816:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a81a:	40 fc       	lddsp	r12,sp[0x3c]
8000a81c:	58 0c       	cp.w	r12,0
8000a81e:	c1 f0       	breq	8000a85c <_vfprintf_r+0x17b8>
8000a820:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a824:	fa c9 f9 48 	sub	r9,sp,-1720
8000a828:	2f e8       	sub	r8,-2
8000a82a:	87 09       	st.w	r3[0x0],r9
8000a82c:	fb 48 06 90 	st.w	sp[1680],r8
8000a830:	30 29       	mov	r9,2
8000a832:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a836:	87 19       	st.w	r3[0x4],r9
8000a838:	2f f8       	sub	r8,-1
8000a83a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a83e:	58 78       	cp.w	r8,7
8000a840:	e0 89 00 04 	brgt	8000a848 <_vfprintf_r+0x17a4>
8000a844:	2f 83       	sub	r3,-8
8000a846:	c0 b8       	rjmp	8000a85c <_vfprintf_r+0x17b8>
8000a848:	fa ca f9 78 	sub	r10,sp,-1672
8000a84c:	02 9b       	mov	r11,r1
8000a84e:	08 9c       	mov	r12,r4
8000a850:	fe b0 f4 1c 	rcall	80009088 <__sprint_r>
8000a854:	e0 81 03 a7 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a858:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a85c:	40 9b       	lddsp	r11,sp[0x24]
8000a85e:	e0 4b 00 80 	cp.w	r11,128
8000a862:	c4 71       	brne	8000a8f0 <_vfprintf_r+0x184c>
8000a864:	40 8a       	lddsp	r10,sp[0x20]
8000a866:	40 39       	lddsp	r9,sp[0xc]
8000a868:	12 1a       	sub	r10,r9
8000a86a:	50 4a       	stdsp	sp[0x10],r10
8000a86c:	58 0a       	cp.w	r10,0
8000a86e:	e0 89 00 20 	brgt	8000a8ae <_vfprintf_r+0x180a>
8000a872:	c3 f8       	rjmp	8000a8f0 <_vfprintf_r+0x184c>
8000a874:	2f 09       	sub	r9,-16
8000a876:	2f f8       	sub	r8,-1
8000a878:	fe ce b5 14 	sub	lr,pc,-19180
8000a87c:	31 0c       	mov	r12,16
8000a87e:	fb 49 06 90 	st.w	sp[1680],r9
8000a882:	87 0e       	st.w	r3[0x0],lr
8000a884:	87 1c       	st.w	r3[0x4],r12
8000a886:	fb 48 06 8c 	st.w	sp[1676],r8
8000a88a:	58 78       	cp.w	r8,7
8000a88c:	e0 89 00 04 	brgt	8000a894 <_vfprintf_r+0x17f0>
8000a890:	2f 83       	sub	r3,-8
8000a892:	c0 b8       	rjmp	8000a8a8 <_vfprintf_r+0x1804>
8000a894:	fa ca f9 78 	sub	r10,sp,-1672
8000a898:	02 9b       	mov	r11,r1
8000a89a:	08 9c       	mov	r12,r4
8000a89c:	fe b0 f3 f6 	rcall	80009088 <__sprint_r>
8000a8a0:	e0 81 03 81 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a8a4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8a8:	40 4b       	lddsp	r11,sp[0x10]
8000a8aa:	21 0b       	sub	r11,16
8000a8ac:	50 4b       	stdsp	sp[0x10],r11
8000a8ae:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a8b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a8b6:	fe ca b5 52 	sub	r10,pc,-19118
8000a8ba:	40 4e       	lddsp	lr,sp[0x10]
8000a8bc:	59 0e       	cp.w	lr,16
8000a8be:	fe 99 ff db 	brgt	8000a874 <_vfprintf_r+0x17d0>
8000a8c2:	1c 09       	add	r9,lr
8000a8c4:	2f f8       	sub	r8,-1
8000a8c6:	87 0a       	st.w	r3[0x0],r10
8000a8c8:	fb 49 06 90 	st.w	sp[1680],r9
8000a8cc:	87 1e       	st.w	r3[0x4],lr
8000a8ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8d2:	58 78       	cp.w	r8,7
8000a8d4:	e0 89 00 04 	brgt	8000a8dc <_vfprintf_r+0x1838>
8000a8d8:	2f 83       	sub	r3,-8
8000a8da:	c0 b8       	rjmp	8000a8f0 <_vfprintf_r+0x184c>
8000a8dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a8e0:	02 9b       	mov	r11,r1
8000a8e2:	08 9c       	mov	r12,r4
8000a8e4:	fe b0 f3 d2 	rcall	80009088 <__sprint_r>
8000a8e8:	e0 81 03 5d 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a8ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8f0:	40 2c       	lddsp	r12,sp[0x8]
8000a8f2:	04 1c       	sub	r12,r2
8000a8f4:	50 2c       	stdsp	sp[0x8],r12
8000a8f6:	58 0c       	cp.w	r12,0
8000a8f8:	e0 89 00 20 	brgt	8000a938 <_vfprintf_r+0x1894>
8000a8fc:	c3 f8       	rjmp	8000a97a <_vfprintf_r+0x18d6>
8000a8fe:	2f 09       	sub	r9,-16
8000a900:	2f f8       	sub	r8,-1
8000a902:	fe cb b5 9e 	sub	r11,pc,-19042
8000a906:	31 0a       	mov	r10,16
8000a908:	fb 49 06 90 	st.w	sp[1680],r9
8000a90c:	87 0b       	st.w	r3[0x0],r11
8000a90e:	87 1a       	st.w	r3[0x4],r10
8000a910:	fb 48 06 8c 	st.w	sp[1676],r8
8000a914:	58 78       	cp.w	r8,7
8000a916:	e0 89 00 04 	brgt	8000a91e <_vfprintf_r+0x187a>
8000a91a:	2f 83       	sub	r3,-8
8000a91c:	c0 b8       	rjmp	8000a932 <_vfprintf_r+0x188e>
8000a91e:	fa ca f9 78 	sub	r10,sp,-1672
8000a922:	02 9b       	mov	r11,r1
8000a924:	08 9c       	mov	r12,r4
8000a926:	fe b0 f3 b1 	rcall	80009088 <__sprint_r>
8000a92a:	e0 81 03 3c 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a92e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a932:	40 29       	lddsp	r9,sp[0x8]
8000a934:	21 09       	sub	r9,16
8000a936:	50 29       	stdsp	sp[0x8],r9
8000a938:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a93c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a940:	fe ca b5 dc 	sub	r10,pc,-18980
8000a944:	40 2e       	lddsp	lr,sp[0x8]
8000a946:	59 0e       	cp.w	lr,16
8000a948:	fe 99 ff db 	brgt	8000a8fe <_vfprintf_r+0x185a>
8000a94c:	1c 09       	add	r9,lr
8000a94e:	2f f8       	sub	r8,-1
8000a950:	87 0a       	st.w	r3[0x0],r10
8000a952:	fb 49 06 90 	st.w	sp[1680],r9
8000a956:	87 1e       	st.w	r3[0x4],lr
8000a958:	fb 48 06 8c 	st.w	sp[1676],r8
8000a95c:	58 78       	cp.w	r8,7
8000a95e:	e0 89 00 04 	brgt	8000a966 <_vfprintf_r+0x18c2>
8000a962:	2f 83       	sub	r3,-8
8000a964:	c0 b8       	rjmp	8000a97a <_vfprintf_r+0x18d6>
8000a966:	fa ca f9 78 	sub	r10,sp,-1672
8000a96a:	02 9b       	mov	r11,r1
8000a96c:	08 9c       	mov	r12,r4
8000a96e:	fe b0 f3 8d 	rcall	80009088 <__sprint_r>
8000a972:	e0 81 03 18 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a976:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a97a:	ed b5 00 08 	bld	r5,0x8
8000a97e:	c0 b0       	breq	8000a994 <_vfprintf_r+0x18f0>
8000a980:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a984:	87 12       	st.w	r3[0x4],r2
8000a986:	87 06       	st.w	r3[0x0],r6
8000a988:	f0 02 00 02 	add	r2,r8,r2
8000a98c:	fb 42 06 90 	st.w	sp[1680],r2
8000a990:	e0 8f 01 d4 	bral	8000ad38 <_vfprintf_r+0x1c94>
8000a994:	e0 40 00 65 	cp.w	r0,101
8000a998:	e0 8a 01 d6 	brle	8000ad44 <_vfprintf_r+0x1ca0>
8000a99c:	30 08       	mov	r8,0
8000a99e:	30 09       	mov	r9,0
8000a9a0:	40 5b       	lddsp	r11,sp[0x14]
8000a9a2:	40 7a       	lddsp	r10,sp[0x1c]
8000a9a4:	e0 a0 15 3b 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000a9a8:	c7 90       	breq	8000aa9a <_vfprintf_r+0x19f6>
8000a9aa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9ae:	fe c9 b6 5e 	sub	r9,pc,-18850
8000a9b2:	2f f8       	sub	r8,-1
8000a9b4:	87 09       	st.w	r3[0x0],r9
8000a9b6:	fb 48 06 90 	st.w	sp[1680],r8
8000a9ba:	30 19       	mov	r9,1
8000a9bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9c0:	87 19       	st.w	r3[0x4],r9
8000a9c2:	2f f8       	sub	r8,-1
8000a9c4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9c8:	58 78       	cp.w	r8,7
8000a9ca:	e0 89 00 05 	brgt	8000a9d4 <_vfprintf_r+0x1930>
8000a9ce:	2f 83       	sub	r3,-8
8000a9d0:	c0 c8       	rjmp	8000a9e8 <_vfprintf_r+0x1944>
8000a9d2:	d7 03       	nop
8000a9d4:	fa ca f9 78 	sub	r10,sp,-1672
8000a9d8:	02 9b       	mov	r11,r1
8000a9da:	08 9c       	mov	r12,r4
8000a9dc:	fe b0 f3 56 	rcall	80009088 <__sprint_r>
8000a9e0:	e0 81 02 e1 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000a9e4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9e8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a9ec:	40 6c       	lddsp	r12,sp[0x18]
8000a9ee:	18 38       	cp.w	r8,r12
8000a9f0:	c0 55       	brlt	8000a9fa <_vfprintf_r+0x1956>
8000a9f2:	ed b5 00 00 	bld	r5,0x0
8000a9f6:	e0 81 02 6b 	brne	8000aecc <_vfprintf_r+0x1e28>
8000a9fa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9fe:	2f f8       	sub	r8,-1
8000aa00:	40 cb       	lddsp	r11,sp[0x30]
8000aa02:	fb 48 06 90 	st.w	sp[1680],r8
8000aa06:	30 19       	mov	r9,1
8000aa08:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa0c:	87 0b       	st.w	r3[0x0],r11
8000aa0e:	2f f8       	sub	r8,-1
8000aa10:	87 19       	st.w	r3[0x4],r9
8000aa12:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa16:	58 78       	cp.w	r8,7
8000aa18:	e0 89 00 04 	brgt	8000aa20 <_vfprintf_r+0x197c>
8000aa1c:	2f 83       	sub	r3,-8
8000aa1e:	c0 b8       	rjmp	8000aa34 <_vfprintf_r+0x1990>
8000aa20:	fa ca f9 78 	sub	r10,sp,-1672
8000aa24:	02 9b       	mov	r11,r1
8000aa26:	08 9c       	mov	r12,r4
8000aa28:	fe b0 f3 30 	rcall	80009088 <__sprint_r>
8000aa2c:	e0 81 02 bb 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000aa30:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa34:	40 66       	lddsp	r6,sp[0x18]
8000aa36:	20 16       	sub	r6,1
8000aa38:	58 06       	cp.w	r6,0
8000aa3a:	e0 89 00 1d 	brgt	8000aa74 <_vfprintf_r+0x19d0>
8000aa3e:	e0 8f 02 47 	bral	8000aecc <_vfprintf_r+0x1e28>
8000aa42:	2f 09       	sub	r9,-16
8000aa44:	2f f8       	sub	r8,-1
8000aa46:	fb 49 06 90 	st.w	sp[1680],r9
8000aa4a:	87 02       	st.w	r3[0x0],r2
8000aa4c:	87 10       	st.w	r3[0x4],r0
8000aa4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa52:	58 78       	cp.w	r8,7
8000aa54:	e0 89 00 04 	brgt	8000aa5c <_vfprintf_r+0x19b8>
8000aa58:	2f 83       	sub	r3,-8
8000aa5a:	c0 b8       	rjmp	8000aa70 <_vfprintf_r+0x19cc>
8000aa5c:	fa ca f9 78 	sub	r10,sp,-1672
8000aa60:	02 9b       	mov	r11,r1
8000aa62:	08 9c       	mov	r12,r4
8000aa64:	fe b0 f3 12 	rcall	80009088 <__sprint_r>
8000aa68:	e0 81 02 9d 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000aa6c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa70:	21 06       	sub	r6,16
8000aa72:	c0 48       	rjmp	8000aa7a <_vfprintf_r+0x19d6>
8000aa74:	fe c2 b7 10 	sub	r2,pc,-18672
8000aa78:	31 00       	mov	r0,16
8000aa7a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa82:	fe ca b7 1e 	sub	r10,pc,-18658
8000aa86:	59 06       	cp.w	r6,16
8000aa88:	fe 99 ff dd 	brgt	8000aa42 <_vfprintf_r+0x199e>
8000aa8c:	0c 09       	add	r9,r6
8000aa8e:	87 0a       	st.w	r3[0x0],r10
8000aa90:	fb 49 06 90 	st.w	sp[1680],r9
8000aa94:	2f f8       	sub	r8,-1
8000aa96:	87 16       	st.w	r3[0x4],r6
8000aa98:	c5 39       	rjmp	8000ad3e <_vfprintf_r+0x1c9a>
8000aa9a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000aa9e:	58 0a       	cp.w	r10,0
8000aaa0:	e0 89 00 92 	brgt	8000abc4 <_vfprintf_r+0x1b20>
8000aaa4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aaa8:	fe c9 b7 58 	sub	r9,pc,-18600
8000aaac:	2f f8       	sub	r8,-1
8000aaae:	87 09       	st.w	r3[0x0],r9
8000aab0:	fb 48 06 90 	st.w	sp[1680],r8
8000aab4:	30 19       	mov	r9,1
8000aab6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aaba:	87 19       	st.w	r3[0x4],r9
8000aabc:	2f f8       	sub	r8,-1
8000aabe:	fb 48 06 8c 	st.w	sp[1676],r8
8000aac2:	58 78       	cp.w	r8,7
8000aac4:	e0 89 00 04 	brgt	8000aacc <_vfprintf_r+0x1a28>
8000aac8:	2f 83       	sub	r3,-8
8000aaca:	c0 b8       	rjmp	8000aae0 <_vfprintf_r+0x1a3c>
8000aacc:	fa ca f9 78 	sub	r10,sp,-1672
8000aad0:	02 9b       	mov	r11,r1
8000aad2:	08 9c       	mov	r12,r4
8000aad4:	fe b0 f2 da 	rcall	80009088 <__sprint_r>
8000aad8:	e0 81 02 65 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000aadc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aae0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aae4:	58 08       	cp.w	r8,0
8000aae6:	c0 81       	brne	8000aaf6 <_vfprintf_r+0x1a52>
8000aae8:	40 6a       	lddsp	r10,sp[0x18]
8000aaea:	58 0a       	cp.w	r10,0
8000aaec:	c0 51       	brne	8000aaf6 <_vfprintf_r+0x1a52>
8000aaee:	ed b5 00 00 	bld	r5,0x0
8000aaf2:	e0 81 01 ed 	brne	8000aecc <_vfprintf_r+0x1e28>
8000aaf6:	40 c9       	lddsp	r9,sp[0x30]
8000aaf8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aafc:	2f f8       	sub	r8,-1
8000aafe:	87 09       	st.w	r3[0x0],r9
8000ab00:	fb 48 06 90 	st.w	sp[1680],r8
8000ab04:	30 19       	mov	r9,1
8000ab06:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab0a:	87 19       	st.w	r3[0x4],r9
8000ab0c:	2f f8       	sub	r8,-1
8000ab0e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab12:	58 78       	cp.w	r8,7
8000ab14:	e0 89 00 04 	brgt	8000ab1c <_vfprintf_r+0x1a78>
8000ab18:	2f 83       	sub	r3,-8
8000ab1a:	c0 b8       	rjmp	8000ab30 <_vfprintf_r+0x1a8c>
8000ab1c:	fa ca f9 78 	sub	r10,sp,-1672
8000ab20:	02 9b       	mov	r11,r1
8000ab22:	08 9c       	mov	r12,r4
8000ab24:	fe b0 f2 b2 	rcall	80009088 <__sprint_r>
8000ab28:	e0 81 02 3d 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ab2c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab30:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab34:	5c 32       	neg	r2
8000ab36:	58 02       	cp.w	r2,0
8000ab38:	e0 89 00 1d 	brgt	8000ab72 <_vfprintf_r+0x1ace>
8000ab3c:	c3 d8       	rjmp	8000abb6 <_vfprintf_r+0x1b12>
8000ab3e:	2f 09       	sub	r9,-16
8000ab40:	2f f8       	sub	r8,-1
8000ab42:	31 0e       	mov	lr,16
8000ab44:	fb 49 06 90 	st.w	sp[1680],r9
8000ab48:	87 00       	st.w	r3[0x0],r0
8000ab4a:	87 1e       	st.w	r3[0x4],lr
8000ab4c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab50:	58 78       	cp.w	r8,7
8000ab52:	e0 89 00 04 	brgt	8000ab5a <_vfprintf_r+0x1ab6>
8000ab56:	2f 83       	sub	r3,-8
8000ab58:	c0 b8       	rjmp	8000ab6e <_vfprintf_r+0x1aca>
8000ab5a:	fa ca f9 78 	sub	r10,sp,-1672
8000ab5e:	02 9b       	mov	r11,r1
8000ab60:	08 9c       	mov	r12,r4
8000ab62:	fe b0 f2 93 	rcall	80009088 <__sprint_r>
8000ab66:	e0 81 02 1e 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ab6a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab6e:	21 02       	sub	r2,16
8000ab70:	c0 38       	rjmp	8000ab76 <_vfprintf_r+0x1ad2>
8000ab72:	fe c0 b8 0e 	sub	r0,pc,-18418
8000ab76:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab7a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab7e:	fe ca b8 1a 	sub	r10,pc,-18406
8000ab82:	59 02       	cp.w	r2,16
8000ab84:	fe 99 ff dd 	brgt	8000ab3e <_vfprintf_r+0x1a9a>
8000ab88:	04 09       	add	r9,r2
8000ab8a:	2f f8       	sub	r8,-1
8000ab8c:	87 0a       	st.w	r3[0x0],r10
8000ab8e:	fb 49 06 90 	st.w	sp[1680],r9
8000ab92:	87 12       	st.w	r3[0x4],r2
8000ab94:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab98:	58 78       	cp.w	r8,7
8000ab9a:	e0 89 00 04 	brgt	8000aba2 <_vfprintf_r+0x1afe>
8000ab9e:	2f 83       	sub	r3,-8
8000aba0:	c0 b8       	rjmp	8000abb6 <_vfprintf_r+0x1b12>
8000aba2:	fa ca f9 78 	sub	r10,sp,-1672
8000aba6:	02 9b       	mov	r11,r1
8000aba8:	08 9c       	mov	r12,r4
8000abaa:	fe b0 f2 6f 	rcall	80009088 <__sprint_r>
8000abae:	e0 81 01 fa 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000abb2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abb6:	40 6c       	lddsp	r12,sp[0x18]
8000abb8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000abbc:	87 06       	st.w	r3[0x0],r6
8000abbe:	87 1c       	st.w	r3[0x4],r12
8000abc0:	18 08       	add	r8,r12
8000abc2:	cb 98       	rjmp	8000ad34 <_vfprintf_r+0x1c90>
8000abc4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000abc8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abcc:	40 6b       	lddsp	r11,sp[0x18]
8000abce:	16 3a       	cp.w	r10,r11
8000abd0:	c6 f5       	brlt	8000acae <_vfprintf_r+0x1c0a>
8000abd2:	16 09       	add	r9,r11
8000abd4:	2f f8       	sub	r8,-1
8000abd6:	87 06       	st.w	r3[0x0],r6
8000abd8:	fb 49 06 90 	st.w	sp[1680],r9
8000abdc:	87 1b       	st.w	r3[0x4],r11
8000abde:	fb 48 06 8c 	st.w	sp[1676],r8
8000abe2:	58 78       	cp.w	r8,7
8000abe4:	e0 89 00 04 	brgt	8000abec <_vfprintf_r+0x1b48>
8000abe8:	2f 83       	sub	r3,-8
8000abea:	c0 b8       	rjmp	8000ac00 <_vfprintf_r+0x1b5c>
8000abec:	fa ca f9 78 	sub	r10,sp,-1672
8000abf0:	02 9b       	mov	r11,r1
8000abf2:	08 9c       	mov	r12,r4
8000abf4:	fe b0 f2 4a 	rcall	80009088 <__sprint_r>
8000abf8:	e0 81 01 d5 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000abfc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac00:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ac04:	40 6a       	lddsp	r10,sp[0x18]
8000ac06:	14 16       	sub	r6,r10
8000ac08:	58 06       	cp.w	r6,0
8000ac0a:	e0 89 00 1c 	brgt	8000ac42 <_vfprintf_r+0x1b9e>
8000ac0e:	c3 d8       	rjmp	8000ac88 <_vfprintf_r+0x1be4>
8000ac10:	2f 09       	sub	r9,-16
8000ac12:	2f f8       	sub	r8,-1
8000ac14:	fb 49 06 90 	st.w	sp[1680],r9
8000ac18:	87 02       	st.w	r3[0x0],r2
8000ac1a:	87 10       	st.w	r3[0x4],r0
8000ac1c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac20:	58 78       	cp.w	r8,7
8000ac22:	e0 89 00 04 	brgt	8000ac2a <_vfprintf_r+0x1b86>
8000ac26:	2f 83       	sub	r3,-8
8000ac28:	c0 b8       	rjmp	8000ac3e <_vfprintf_r+0x1b9a>
8000ac2a:	fa ca f9 78 	sub	r10,sp,-1672
8000ac2e:	02 9b       	mov	r11,r1
8000ac30:	08 9c       	mov	r12,r4
8000ac32:	fe b0 f2 2b 	rcall	80009088 <__sprint_r>
8000ac36:	e0 81 01 b6 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ac3a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac3e:	21 06       	sub	r6,16
8000ac40:	c0 48       	rjmp	8000ac48 <_vfprintf_r+0x1ba4>
8000ac42:	fe c2 b8 de 	sub	r2,pc,-18210
8000ac46:	31 00       	mov	r0,16
8000ac48:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ac4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac50:	fe ca b8 ec 	sub	r10,pc,-18196
8000ac54:	59 06       	cp.w	r6,16
8000ac56:	fe 99 ff dd 	brgt	8000ac10 <_vfprintf_r+0x1b6c>
8000ac5a:	0c 09       	add	r9,r6
8000ac5c:	2f f8       	sub	r8,-1
8000ac5e:	87 0a       	st.w	r3[0x0],r10
8000ac60:	fb 49 06 90 	st.w	sp[1680],r9
8000ac64:	87 16       	st.w	r3[0x4],r6
8000ac66:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac6a:	58 78       	cp.w	r8,7
8000ac6c:	e0 89 00 04 	brgt	8000ac74 <_vfprintf_r+0x1bd0>
8000ac70:	2f 83       	sub	r3,-8
8000ac72:	c0 b8       	rjmp	8000ac88 <_vfprintf_r+0x1be4>
8000ac74:	fa ca f9 78 	sub	r10,sp,-1672
8000ac78:	02 9b       	mov	r11,r1
8000ac7a:	08 9c       	mov	r12,r4
8000ac7c:	fe b0 f2 06 	rcall	80009088 <__sprint_r>
8000ac80:	e0 81 01 91 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ac84:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac88:	ed b5 00 00 	bld	r5,0x0
8000ac8c:	e0 81 01 20 	brne	8000aecc <_vfprintf_r+0x1e28>
8000ac90:	40 c9       	lddsp	r9,sp[0x30]
8000ac92:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac96:	2f f8       	sub	r8,-1
8000ac98:	87 09       	st.w	r3[0x0],r9
8000ac9a:	fb 48 06 90 	st.w	sp[1680],r8
8000ac9e:	30 19       	mov	r9,1
8000aca0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aca4:	87 19       	st.w	r3[0x4],r9
8000aca6:	2f f8       	sub	r8,-1
8000aca8:	fb 48 06 8c 	st.w	sp[1676],r8
8000acac:	c0 29       	rjmp	8000aeb0 <_vfprintf_r+0x1e0c>
8000acae:	14 09       	add	r9,r10
8000acb0:	2f f8       	sub	r8,-1
8000acb2:	fb 49 06 90 	st.w	sp[1680],r9
8000acb6:	87 06       	st.w	r3[0x0],r6
8000acb8:	87 1a       	st.w	r3[0x4],r10
8000acba:	fb 48 06 8c 	st.w	sp[1676],r8
8000acbe:	58 78       	cp.w	r8,7
8000acc0:	e0 89 00 04 	brgt	8000acc8 <_vfprintf_r+0x1c24>
8000acc4:	2f 83       	sub	r3,-8
8000acc6:	c0 b8       	rjmp	8000acdc <_vfprintf_r+0x1c38>
8000acc8:	fa ca f9 78 	sub	r10,sp,-1672
8000accc:	02 9b       	mov	r11,r1
8000acce:	08 9c       	mov	r12,r4
8000acd0:	fe b0 f1 dc 	rcall	80009088 <__sprint_r>
8000acd4:	e0 81 01 67 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000acd8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000acdc:	40 c8       	lddsp	r8,sp[0x30]
8000acde:	87 08       	st.w	r3[0x0],r8
8000ace0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ace4:	2f f8       	sub	r8,-1
8000ace6:	30 19       	mov	r9,1
8000ace8:	fb 48 06 90 	st.w	sp[1680],r8
8000acec:	87 19       	st.w	r3[0x4],r9
8000acee:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acf2:	2f f8       	sub	r8,-1
8000acf4:	fb 48 06 8c 	st.w	sp[1676],r8
8000acf8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000acfc:	58 78       	cp.w	r8,7
8000acfe:	e0 89 00 04 	brgt	8000ad06 <_vfprintf_r+0x1c62>
8000ad02:	2f 83       	sub	r3,-8
8000ad04:	c0 b8       	rjmp	8000ad1a <_vfprintf_r+0x1c76>
8000ad06:	fa ca f9 78 	sub	r10,sp,-1672
8000ad0a:	02 9b       	mov	r11,r1
8000ad0c:	08 9c       	mov	r12,r4
8000ad0e:	fe b0 f1 bd 	rcall	80009088 <__sprint_r>
8000ad12:	e0 81 01 48 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ad16:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad1a:	04 06       	add	r6,r2
8000ad1c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ad20:	87 06       	st.w	r3[0x0],r6
8000ad22:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad26:	40 66       	lddsp	r6,sp[0x18]
8000ad28:	40 6e       	lddsp	lr,sp[0x18]
8000ad2a:	10 16       	sub	r6,r8
8000ad2c:	f2 08 01 08 	sub	r8,r9,r8
8000ad30:	87 16       	st.w	r3[0x4],r6
8000ad32:	1c 08       	add	r8,lr
8000ad34:	fb 48 06 90 	st.w	sp[1680],r8
8000ad38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad3c:	2f f8       	sub	r8,-1
8000ad3e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad42:	cb 78       	rjmp	8000aeb0 <_vfprintf_r+0x1e0c>
8000ad44:	40 6c       	lddsp	r12,sp[0x18]
8000ad46:	58 1c       	cp.w	r12,1
8000ad48:	e0 89 00 06 	brgt	8000ad54 <_vfprintf_r+0x1cb0>
8000ad4c:	ed b5 00 00 	bld	r5,0x0
8000ad50:	e0 81 00 85 	brne	8000ae5a <_vfprintf_r+0x1db6>
8000ad54:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad58:	2f f8       	sub	r8,-1
8000ad5a:	30 19       	mov	r9,1
8000ad5c:	fb 48 06 90 	st.w	sp[1680],r8
8000ad60:	87 06       	st.w	r3[0x0],r6
8000ad62:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad66:	87 19       	st.w	r3[0x4],r9
8000ad68:	2f f8       	sub	r8,-1
8000ad6a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad6e:	58 78       	cp.w	r8,7
8000ad70:	e0 89 00 04 	brgt	8000ad78 <_vfprintf_r+0x1cd4>
8000ad74:	2f 83       	sub	r3,-8
8000ad76:	c0 b8       	rjmp	8000ad8c <_vfprintf_r+0x1ce8>
8000ad78:	fa ca f9 78 	sub	r10,sp,-1672
8000ad7c:	02 9b       	mov	r11,r1
8000ad7e:	08 9c       	mov	r12,r4
8000ad80:	fe b0 f1 84 	rcall	80009088 <__sprint_r>
8000ad84:	e0 81 01 0f 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ad88:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad8c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad90:	2f f8       	sub	r8,-1
8000ad92:	40 cb       	lddsp	r11,sp[0x30]
8000ad94:	fb 48 06 90 	st.w	sp[1680],r8
8000ad98:	30 19       	mov	r9,1
8000ad9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad9e:	87 0b       	st.w	r3[0x0],r11
8000ada0:	2f f8       	sub	r8,-1
8000ada2:	87 19       	st.w	r3[0x4],r9
8000ada4:	fb 48 06 8c 	st.w	sp[1676],r8
8000ada8:	58 78       	cp.w	r8,7
8000adaa:	e0 89 00 05 	brgt	8000adb4 <_vfprintf_r+0x1d10>
8000adae:	2f 83       	sub	r3,-8
8000adb0:	c0 c8       	rjmp	8000adc8 <_vfprintf_r+0x1d24>
8000adb2:	d7 03       	nop
8000adb4:	fa ca f9 78 	sub	r10,sp,-1672
8000adb8:	02 9b       	mov	r11,r1
8000adba:	08 9c       	mov	r12,r4
8000adbc:	fe b0 f1 66 	rcall	80009088 <__sprint_r>
8000adc0:	e0 81 00 f1 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000adc4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adc8:	30 08       	mov	r8,0
8000adca:	30 09       	mov	r9,0
8000adcc:	40 5b       	lddsp	r11,sp[0x14]
8000adce:	40 7a       	lddsp	r10,sp[0x1c]
8000add0:	e0 a0 13 25 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000add4:	40 68       	lddsp	r8,sp[0x18]
8000add6:	20 18       	sub	r8,1
8000add8:	58 0c       	cp.w	r12,0
8000adda:	c0 d1       	brne	8000adf4 <_vfprintf_r+0x1d50>
8000addc:	2f f6       	sub	r6,-1
8000adde:	87 18       	st.w	r3[0x4],r8
8000ade0:	87 06       	st.w	r3[0x0],r6
8000ade2:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ade6:	10 06       	add	r6,r8
8000ade8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000adec:	fb 46 06 90 	st.w	sp[1680],r6
8000adf0:	2f f8       	sub	r8,-1
8000adf2:	c3 18       	rjmp	8000ae54 <_vfprintf_r+0x1db0>
8000adf4:	10 96       	mov	r6,r8
8000adf6:	58 08       	cp.w	r8,0
8000adf8:	e0 89 00 1c 	brgt	8000ae30 <_vfprintf_r+0x1d8c>
8000adfc:	c4 b8       	rjmp	8000ae92 <_vfprintf_r+0x1dee>
8000adfe:	2f 09       	sub	r9,-16
8000ae00:	2f f8       	sub	r8,-1
8000ae02:	fb 49 06 90 	st.w	sp[1680],r9
8000ae06:	87 02       	st.w	r3[0x0],r2
8000ae08:	87 10       	st.w	r3[0x4],r0
8000ae0a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae0e:	58 78       	cp.w	r8,7
8000ae10:	e0 89 00 04 	brgt	8000ae18 <_vfprintf_r+0x1d74>
8000ae14:	2f 83       	sub	r3,-8
8000ae16:	c0 b8       	rjmp	8000ae2c <_vfprintf_r+0x1d88>
8000ae18:	fa ca f9 78 	sub	r10,sp,-1672
8000ae1c:	02 9b       	mov	r11,r1
8000ae1e:	08 9c       	mov	r12,r4
8000ae20:	fe b0 f1 34 	rcall	80009088 <__sprint_r>
8000ae24:	e0 81 00 bf 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ae28:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae2c:	21 06       	sub	r6,16
8000ae2e:	c0 48       	rjmp	8000ae36 <_vfprintf_r+0x1d92>
8000ae30:	fe c2 ba cc 	sub	r2,pc,-17716
8000ae34:	31 00       	mov	r0,16
8000ae36:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ae3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae3e:	fe ca ba da 	sub	r10,pc,-17702
8000ae42:	59 06       	cp.w	r6,16
8000ae44:	fe 99 ff dd 	brgt	8000adfe <_vfprintf_r+0x1d5a>
8000ae48:	0c 09       	add	r9,r6
8000ae4a:	87 0a       	st.w	r3[0x0],r10
8000ae4c:	fb 49 06 90 	st.w	sp[1680],r9
8000ae50:	2f f8       	sub	r8,-1
8000ae52:	87 16       	st.w	r3[0x4],r6
8000ae54:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae58:	c0 e8       	rjmp	8000ae74 <_vfprintf_r+0x1dd0>
8000ae5a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae5e:	2f f8       	sub	r8,-1
8000ae60:	30 19       	mov	r9,1
8000ae62:	fb 48 06 90 	st.w	sp[1680],r8
8000ae66:	87 06       	st.w	r3[0x0],r6
8000ae68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae6c:	87 19       	st.w	r3[0x4],r9
8000ae6e:	2f f8       	sub	r8,-1
8000ae70:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae74:	58 78       	cp.w	r8,7
8000ae76:	e0 89 00 04 	brgt	8000ae7e <_vfprintf_r+0x1dda>
8000ae7a:	2f 83       	sub	r3,-8
8000ae7c:	c0 b8       	rjmp	8000ae92 <_vfprintf_r+0x1dee>
8000ae7e:	fa ca f9 78 	sub	r10,sp,-1672
8000ae82:	02 9b       	mov	r11,r1
8000ae84:	08 9c       	mov	r12,r4
8000ae86:	fe b0 f1 01 	rcall	80009088 <__sprint_r>
8000ae8a:	e0 81 00 8c 	brne	8000afa2 <_vfprintf_r+0x1efe>
8000ae8e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae92:	40 ea       	lddsp	r10,sp[0x38]
8000ae94:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae98:	14 08       	add	r8,r10
8000ae9a:	fa c9 f9 64 	sub	r9,sp,-1692
8000ae9e:	fb 48 06 90 	st.w	sp[1680],r8
8000aea2:	87 1a       	st.w	r3[0x4],r10
8000aea4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aea8:	87 09       	st.w	r3[0x0],r9
8000aeaa:	2f f8       	sub	r8,-1
8000aeac:	fb 48 06 8c 	st.w	sp[1676],r8
8000aeb0:	58 78       	cp.w	r8,7
8000aeb2:	e0 89 00 04 	brgt	8000aeba <_vfprintf_r+0x1e16>
8000aeb6:	2f 83       	sub	r3,-8
8000aeb8:	c0 a8       	rjmp	8000aecc <_vfprintf_r+0x1e28>
8000aeba:	fa ca f9 78 	sub	r10,sp,-1672
8000aebe:	02 9b       	mov	r11,r1
8000aec0:	08 9c       	mov	r12,r4
8000aec2:	fe b0 f0 e3 	rcall	80009088 <__sprint_r>
8000aec6:	c6 e1       	brne	8000afa2 <_vfprintf_r+0x1efe>
8000aec8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aecc:	e2 15 00 04 	andl	r5,0x4,COH
8000aed0:	c3 f0       	breq	8000af4e <_vfprintf_r+0x1eaa>
8000aed2:	40 86       	lddsp	r6,sp[0x20]
8000aed4:	40 39       	lddsp	r9,sp[0xc]
8000aed6:	12 16       	sub	r6,r9
8000aed8:	58 06       	cp.w	r6,0
8000aeda:	e0 89 00 1a 	brgt	8000af0e <_vfprintf_r+0x1e6a>
8000aede:	c3 88       	rjmp	8000af4e <_vfprintf_r+0x1eaa>
8000aee0:	2f 09       	sub	r9,-16
8000aee2:	2f f8       	sub	r8,-1
8000aee4:	fb 49 06 90 	st.w	sp[1680],r9
8000aee8:	87 05       	st.w	r3[0x0],r5
8000aeea:	87 12       	st.w	r3[0x4],r2
8000aeec:	fb 48 06 8c 	st.w	sp[1676],r8
8000aef0:	58 78       	cp.w	r8,7
8000aef2:	e0 89 00 04 	brgt	8000aefa <_vfprintf_r+0x1e56>
8000aef6:	2f 83       	sub	r3,-8
8000aef8:	c0 98       	rjmp	8000af0a <_vfprintf_r+0x1e66>
8000aefa:	00 9a       	mov	r10,r0
8000aefc:	02 9b       	mov	r11,r1
8000aefe:	08 9c       	mov	r12,r4
8000af00:	fe b0 f0 c4 	rcall	80009088 <__sprint_r>
8000af04:	c4 f1       	brne	8000afa2 <_vfprintf_r+0x1efe>
8000af06:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af0a:	21 06       	sub	r6,16
8000af0c:	c0 68       	rjmp	8000af18 <_vfprintf_r+0x1e74>
8000af0e:	fe c5 bb ba 	sub	r5,pc,-17478
8000af12:	31 02       	mov	r2,16
8000af14:	fa c0 f9 78 	sub	r0,sp,-1672
8000af18:	fa f9 06 90 	ld.w	r9,sp[1680]
8000af1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af20:	fe ca bb cc 	sub	r10,pc,-17460
8000af24:	59 06       	cp.w	r6,16
8000af26:	fe 99 ff dd 	brgt	8000aee0 <_vfprintf_r+0x1e3c>
8000af2a:	0c 09       	add	r9,r6
8000af2c:	2f f8       	sub	r8,-1
8000af2e:	87 0a       	st.w	r3[0x0],r10
8000af30:	87 16       	st.w	r3[0x4],r6
8000af32:	fb 49 06 90 	st.w	sp[1680],r9
8000af36:	fb 48 06 8c 	st.w	sp[1676],r8
8000af3a:	58 78       	cp.w	r8,7
8000af3c:	e0 8a 00 09 	brle	8000af4e <_vfprintf_r+0x1eaa>
8000af40:	fa ca f9 78 	sub	r10,sp,-1672
8000af44:	02 9b       	mov	r11,r1
8000af46:	08 9c       	mov	r12,r4
8000af48:	fe b0 f0 a0 	rcall	80009088 <__sprint_r>
8000af4c:	c2 b1       	brne	8000afa2 <_vfprintf_r+0x1efe>
8000af4e:	40 bc       	lddsp	r12,sp[0x2c]
8000af50:	40 36       	lddsp	r6,sp[0xc]
8000af52:	40 8e       	lddsp	lr,sp[0x20]
8000af54:	ec 0e 0c 48 	max	r8,r6,lr
8000af58:	10 0c       	add	r12,r8
8000af5a:	50 bc       	stdsp	sp[0x2c],r12
8000af5c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af60:	58 08       	cp.w	r8,0
8000af62:	c0 80       	breq	8000af72 <_vfprintf_r+0x1ece>
8000af64:	fa ca f9 78 	sub	r10,sp,-1672
8000af68:	02 9b       	mov	r11,r1
8000af6a:	08 9c       	mov	r12,r4
8000af6c:	fe b0 f0 8e 	rcall	80009088 <__sprint_r>
8000af70:	c1 91       	brne	8000afa2 <_vfprintf_r+0x1efe>
8000af72:	30 0b       	mov	r11,0
8000af74:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af78:	fb 4b 06 8c 	st.w	sp[1676],r11
8000af7c:	fe 9f f1 22 	bral	800091c0 <_vfprintf_r+0x11c>
8000af80:	08 95       	mov	r5,r4
8000af82:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af86:	58 08       	cp.w	r8,0
8000af88:	c0 80       	breq	8000af98 <_vfprintf_r+0x1ef4>
8000af8a:	08 9c       	mov	r12,r4
8000af8c:	fa ca f9 78 	sub	r10,sp,-1672
8000af90:	02 9b       	mov	r11,r1
8000af92:	fe b0 f0 7b 	rcall	80009088 <__sprint_r>
8000af96:	c0 61       	brne	8000afa2 <_vfprintf_r+0x1efe>
8000af98:	30 08       	mov	r8,0
8000af9a:	fb 48 06 8c 	st.w	sp[1676],r8
8000af9e:	c0 28       	rjmp	8000afa2 <_vfprintf_r+0x1efe>
8000afa0:	40 41       	lddsp	r1,sp[0x10]
8000afa2:	82 68       	ld.sh	r8,r1[0xc]
8000afa4:	ed b8 00 06 	bld	r8,0x6
8000afa8:	c0 31       	brne	8000afae <_vfprintf_r+0x1f0a>
8000afaa:	3f fa       	mov	r10,-1
8000afac:	50 ba       	stdsp	sp[0x2c],r10
8000afae:	40 bc       	lddsp	r12,sp[0x2c]
8000afb0:	fe 3d f9 44 	sub	sp,-1724
8000afb4:	d8 32       	popm	r0-r7,pc
8000afb6:	d7 03       	nop

8000afb8 <__swsetup_r>:
8000afb8:	d4 21       	pushm	r4-r7,lr
8000afba:	e0 68 0a 54 	mov	r8,2644
8000afbe:	18 96       	mov	r6,r12
8000afc0:	16 97       	mov	r7,r11
8000afc2:	70 0c       	ld.w	r12,r8[0x0]
8000afc4:	58 0c       	cp.w	r12,0
8000afc6:	c0 60       	breq	8000afd2 <__swsetup_r+0x1a>
8000afc8:	78 68       	ld.w	r8,r12[0x18]
8000afca:	58 08       	cp.w	r8,0
8000afcc:	c0 31       	brne	8000afd2 <__swsetup_r+0x1a>
8000afce:	e0 a0 07 bf 	rcall	8000bf4c <__sinit>
8000afd2:	fe c8 bb 4e 	sub	r8,pc,-17586
8000afd6:	10 37       	cp.w	r7,r8
8000afd8:	c0 61       	brne	8000afe4 <__swsetup_r+0x2c>
8000afda:	e0 68 0a 54 	mov	r8,2644
8000afde:	70 08       	ld.w	r8,r8[0x0]
8000afe0:	70 07       	ld.w	r7,r8[0x0]
8000afe2:	c1 28       	rjmp	8000b006 <__swsetup_r+0x4e>
8000afe4:	fe c8 bb 40 	sub	r8,pc,-17600
8000afe8:	10 37       	cp.w	r7,r8
8000afea:	c0 61       	brne	8000aff6 <__swsetup_r+0x3e>
8000afec:	e0 68 0a 54 	mov	r8,2644
8000aff0:	70 08       	ld.w	r8,r8[0x0]
8000aff2:	70 17       	ld.w	r7,r8[0x4]
8000aff4:	c0 98       	rjmp	8000b006 <__swsetup_r+0x4e>
8000aff6:	fe c8 bb 32 	sub	r8,pc,-17614
8000affa:	10 37       	cp.w	r7,r8
8000affc:	c0 51       	brne	8000b006 <__swsetup_r+0x4e>
8000affe:	e0 68 0a 54 	mov	r8,2644
8000b002:	70 08       	ld.w	r8,r8[0x0]
8000b004:	70 27       	ld.w	r7,r8[0x8]
8000b006:	8e 68       	ld.sh	r8,r7[0xc]
8000b008:	ed b8 00 03 	bld	r8,0x3
8000b00c:	c1 e0       	breq	8000b048 <__swsetup_r+0x90>
8000b00e:	ed b8 00 04 	bld	r8,0x4
8000b012:	c3 e1       	brne	8000b08e <__swsetup_r+0xd6>
8000b014:	ed b8 00 02 	bld	r8,0x2
8000b018:	c1 51       	brne	8000b042 <__swsetup_r+0x8a>
8000b01a:	6e db       	ld.w	r11,r7[0x34]
8000b01c:	58 0b       	cp.w	r11,0
8000b01e:	c0 a0       	breq	8000b032 <__swsetup_r+0x7a>
8000b020:	ee c8 ff bc 	sub	r8,r7,-68
8000b024:	10 3b       	cp.w	r11,r8
8000b026:	c0 40       	breq	8000b02e <__swsetup_r+0x76>
8000b028:	0c 9c       	mov	r12,r6
8000b02a:	e0 a0 08 2b 	rcall	8000c080 <_free_r>
8000b02e:	30 08       	mov	r8,0
8000b030:	8f d8       	st.w	r7[0x34],r8
8000b032:	8e 68       	ld.sh	r8,r7[0xc]
8000b034:	e0 18 ff db 	andl	r8,0xffdb
8000b038:	ae 68       	st.h	r7[0xc],r8
8000b03a:	30 08       	mov	r8,0
8000b03c:	8f 18       	st.w	r7[0x4],r8
8000b03e:	6e 48       	ld.w	r8,r7[0x10]
8000b040:	8f 08       	st.w	r7[0x0],r8
8000b042:	8e 68       	ld.sh	r8,r7[0xc]
8000b044:	a3 b8       	sbr	r8,0x3
8000b046:	ae 68       	st.h	r7[0xc],r8
8000b048:	6e 48       	ld.w	r8,r7[0x10]
8000b04a:	58 08       	cp.w	r8,0
8000b04c:	c0 b1       	brne	8000b062 <__swsetup_r+0xaa>
8000b04e:	8e 68       	ld.sh	r8,r7[0xc]
8000b050:	e2 18 02 80 	andl	r8,0x280,COH
8000b054:	e0 48 02 00 	cp.w	r8,512
8000b058:	c0 50       	breq	8000b062 <__swsetup_r+0xaa>
8000b05a:	0c 9c       	mov	r12,r6
8000b05c:	0e 9b       	mov	r11,r7
8000b05e:	e0 a0 0a 4b 	rcall	8000c4f4 <__smakebuf_r>
8000b062:	8e 69       	ld.sh	r9,r7[0xc]
8000b064:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000b068:	c0 70       	breq	8000b076 <__swsetup_r+0xbe>
8000b06a:	30 08       	mov	r8,0
8000b06c:	8f 28       	st.w	r7[0x8],r8
8000b06e:	6e 58       	ld.w	r8,r7[0x14]
8000b070:	5c 38       	neg	r8
8000b072:	8f 68       	st.w	r7[0x18],r8
8000b074:	c0 68       	rjmp	8000b080 <__swsetup_r+0xc8>
8000b076:	ed b9 00 01 	bld	r9,0x1
8000b07a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000b07e:	8f 28       	st.w	r7[0x8],r8
8000b080:	6e 48       	ld.w	r8,r7[0x10]
8000b082:	58 08       	cp.w	r8,0
8000b084:	c0 61       	brne	8000b090 <__swsetup_r+0xd8>
8000b086:	8e 68       	ld.sh	r8,r7[0xc]
8000b088:	ed b8 00 07 	bld	r8,0x7
8000b08c:	c0 21       	brne	8000b090 <__swsetup_r+0xd8>
8000b08e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000b090:	d8 2a       	popm	r4-r7,pc,r12=0
8000b092:	d7 03       	nop

8000b094 <quorem>:
8000b094:	d4 31       	pushm	r0-r7,lr
8000b096:	20 2d       	sub	sp,8
8000b098:	18 97       	mov	r7,r12
8000b09a:	78 48       	ld.w	r8,r12[0x10]
8000b09c:	76 46       	ld.w	r6,r11[0x10]
8000b09e:	0c 38       	cp.w	r8,r6
8000b0a0:	c0 34       	brge	8000b0a6 <quorem+0x12>
8000b0a2:	30 0c       	mov	r12,0
8000b0a4:	c8 58       	rjmp	8000b1ae <quorem+0x11a>
8000b0a6:	ec c2 ff fc 	sub	r2,r6,-4
8000b0aa:	f6 c3 ff ec 	sub	r3,r11,-20
8000b0ae:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000b0b2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000b0b6:	2f f9       	sub	r9,-1
8000b0b8:	20 16       	sub	r6,1
8000b0ba:	f8 09 0d 08 	divu	r8,r12,r9
8000b0be:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000b0c2:	ee c4 ff ec 	sub	r4,r7,-20
8000b0c6:	10 95       	mov	r5,r8
8000b0c8:	58 08       	cp.w	r8,0
8000b0ca:	c4 10       	breq	8000b14c <quorem+0xb8>
8000b0cc:	30 09       	mov	r9,0
8000b0ce:	06 9a       	mov	r10,r3
8000b0d0:	08 98       	mov	r8,r4
8000b0d2:	12 91       	mov	r1,r9
8000b0d4:	50 0b       	stdsp	sp[0x0],r11
8000b0d6:	70 0e       	ld.w	lr,r8[0x0]
8000b0d8:	b1 8e       	lsr	lr,0x10
8000b0da:	50 1e       	stdsp	sp[0x4],lr
8000b0dc:	15 0e       	ld.w	lr,r10++
8000b0de:	fc 00 16 10 	lsr	r0,lr,0x10
8000b0e2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b0e6:	ea 0e 03 41 	mac	r1,r5,lr
8000b0ea:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000b0ee:	b1 81       	lsr	r1,0x10
8000b0f0:	40 1b       	lddsp	r11,sp[0x4]
8000b0f2:	ea 00 02 40 	mul	r0,r5,r0
8000b0f6:	e2 00 00 00 	add	r0,r1,r0
8000b0fa:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000b0fe:	02 1b       	sub	r11,r1
8000b100:	50 1b       	stdsp	sp[0x4],r11
8000b102:	70 0b       	ld.w	r11,r8[0x0]
8000b104:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000b108:	02 09       	add	r9,r1
8000b10a:	f2 0e 01 0e 	sub	lr,r9,lr
8000b10e:	b0 1e       	st.h	r8[0x2],lr
8000b110:	fc 09 14 10 	asr	r9,lr,0x10
8000b114:	40 1e       	lddsp	lr,sp[0x4]
8000b116:	fc 09 00 09 	add	r9,lr,r9
8000b11a:	b0 09       	st.h	r8[0x0],r9
8000b11c:	e0 01 16 10 	lsr	r1,r0,0x10
8000b120:	2f c8       	sub	r8,-4
8000b122:	b1 49       	asr	r9,0x10
8000b124:	04 3a       	cp.w	r10,r2
8000b126:	fe 98 ff d8 	brls	8000b0d6 <quorem+0x42>
8000b12a:	40 0b       	lddsp	r11,sp[0x0]
8000b12c:	58 0c       	cp.w	r12,0
8000b12e:	c0 f1       	brne	8000b14c <quorem+0xb8>
8000b130:	ec c8 ff fb 	sub	r8,r6,-5
8000b134:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b138:	c0 28       	rjmp	8000b13c <quorem+0xa8>
8000b13a:	20 16       	sub	r6,1
8000b13c:	20 48       	sub	r8,4
8000b13e:	08 38       	cp.w	r8,r4
8000b140:	e0 88 00 05 	brls	8000b14a <quorem+0xb6>
8000b144:	70 09       	ld.w	r9,r8[0x0]
8000b146:	58 09       	cp.w	r9,0
8000b148:	cf 90       	breq	8000b13a <quorem+0xa6>
8000b14a:	8f 46       	st.w	r7[0x10],r6
8000b14c:	0e 9c       	mov	r12,r7
8000b14e:	e0 a0 0a d2 	rcall	8000c6f2 <__mcmp>
8000b152:	c2 d5       	brlt	8000b1ac <quorem+0x118>
8000b154:	2f f5       	sub	r5,-1
8000b156:	08 98       	mov	r8,r4
8000b158:	30 09       	mov	r9,0
8000b15a:	07 0b       	ld.w	r11,r3++
8000b15c:	f6 0a 16 10 	lsr	r10,r11,0x10
8000b160:	70 0c       	ld.w	r12,r8[0x0]
8000b162:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b166:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b16a:	14 1e       	sub	lr,r10
8000b16c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b170:	16 1a       	sub	r10,r11
8000b172:	12 0a       	add	r10,r9
8000b174:	b0 1a       	st.h	r8[0x2],r10
8000b176:	b1 4a       	asr	r10,0x10
8000b178:	fc 0a 00 09 	add	r9,lr,r10
8000b17c:	b0 09       	st.h	r8[0x0],r9
8000b17e:	2f c8       	sub	r8,-4
8000b180:	b1 49       	asr	r9,0x10
8000b182:	04 33       	cp.w	r3,r2
8000b184:	fe 98 ff eb 	brls	8000b15a <quorem+0xc6>
8000b188:	ec c8 ff fb 	sub	r8,r6,-5
8000b18c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b190:	58 09       	cp.w	r9,0
8000b192:	c0 d1       	brne	8000b1ac <quorem+0x118>
8000b194:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b198:	c0 28       	rjmp	8000b19c <quorem+0x108>
8000b19a:	20 16       	sub	r6,1
8000b19c:	20 48       	sub	r8,4
8000b19e:	08 38       	cp.w	r8,r4
8000b1a0:	e0 88 00 05 	brls	8000b1aa <quorem+0x116>
8000b1a4:	70 09       	ld.w	r9,r8[0x0]
8000b1a6:	58 09       	cp.w	r9,0
8000b1a8:	cf 90       	breq	8000b19a <quorem+0x106>
8000b1aa:	8f 46       	st.w	r7[0x10],r6
8000b1ac:	0a 9c       	mov	r12,r5
8000b1ae:	2f ed       	sub	sp,-8
8000b1b0:	d8 32       	popm	r0-r7,pc
8000b1b2:	d7 03       	nop

8000b1b4 <_dtoa_r>:
8000b1b4:	d4 31       	pushm	r0-r7,lr
8000b1b6:	21 ad       	sub	sp,104
8000b1b8:	fa c4 ff 74 	sub	r4,sp,-140
8000b1bc:	18 97       	mov	r7,r12
8000b1be:	16 95       	mov	r5,r11
8000b1c0:	68 2c       	ld.w	r12,r4[0x8]
8000b1c2:	50 c9       	stdsp	sp[0x30],r9
8000b1c4:	68 16       	ld.w	r6,r4[0x4]
8000b1c6:	68 09       	ld.w	r9,r4[0x0]
8000b1c8:	50 e8       	stdsp	sp[0x38],r8
8000b1ca:	14 94       	mov	r4,r10
8000b1cc:	51 2c       	stdsp	sp[0x48],r12
8000b1ce:	fa e5 00 08 	st.d	sp[8],r4
8000b1d2:	51 59       	stdsp	sp[0x54],r9
8000b1d4:	6e 95       	ld.w	r5,r7[0x24]
8000b1d6:	58 05       	cp.w	r5,0
8000b1d8:	c0 91       	brne	8000b1ea <_dtoa_r+0x36>
8000b1da:	31 0c       	mov	r12,16
8000b1dc:	fe b0 e8 e2 	rcall	800083a0 <malloc>
8000b1e0:	99 35       	st.w	r12[0xc],r5
8000b1e2:	8f 9c       	st.w	r7[0x24],r12
8000b1e4:	99 15       	st.w	r12[0x4],r5
8000b1e6:	99 25       	st.w	r12[0x8],r5
8000b1e8:	99 05       	st.w	r12[0x0],r5
8000b1ea:	6e 99       	ld.w	r9,r7[0x24]
8000b1ec:	72 08       	ld.w	r8,r9[0x0]
8000b1ee:	58 08       	cp.w	r8,0
8000b1f0:	c0 f0       	breq	8000b20e <_dtoa_r+0x5a>
8000b1f2:	72 1a       	ld.w	r10,r9[0x4]
8000b1f4:	91 1a       	st.w	r8[0x4],r10
8000b1f6:	30 1a       	mov	r10,1
8000b1f8:	72 19       	ld.w	r9,r9[0x4]
8000b1fa:	f4 09 09 49 	lsl	r9,r10,r9
8000b1fe:	10 9b       	mov	r11,r8
8000b200:	91 29       	st.w	r8[0x8],r9
8000b202:	0e 9c       	mov	r12,r7
8000b204:	e0 a0 0a 90 	rcall	8000c724 <_Bfree>
8000b208:	6e 98       	ld.w	r8,r7[0x24]
8000b20a:	30 09       	mov	r9,0
8000b20c:	91 09       	st.w	r8[0x0],r9
8000b20e:	40 28       	lddsp	r8,sp[0x8]
8000b210:	10 94       	mov	r4,r8
8000b212:	58 08       	cp.w	r8,0
8000b214:	c0 64       	brge	8000b220 <_dtoa_r+0x6c>
8000b216:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b21a:	50 28       	stdsp	sp[0x8],r8
8000b21c:	30 18       	mov	r8,1
8000b21e:	c0 28       	rjmp	8000b222 <_dtoa_r+0x6e>
8000b220:	30 08       	mov	r8,0
8000b222:	8d 08       	st.w	r6[0x0],r8
8000b224:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b228:	40 26       	lddsp	r6,sp[0x8]
8000b22a:	0c 98       	mov	r8,r6
8000b22c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b230:	18 38       	cp.w	r8,r12
8000b232:	c2 01       	brne	8000b272 <_dtoa_r+0xbe>
8000b234:	e0 68 27 0f 	mov	r8,9999
8000b238:	41 5b       	lddsp	r11,sp[0x54]
8000b23a:	97 08       	st.w	r11[0x0],r8
8000b23c:	40 3a       	lddsp	r10,sp[0xc]
8000b23e:	58 0a       	cp.w	r10,0
8000b240:	c0 71       	brne	8000b24e <_dtoa_r+0x9a>
8000b242:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b246:	c0 41       	brne	8000b24e <_dtoa_r+0x9a>
8000b248:	fe cc bd d4 	sub	r12,pc,-16940
8000b24c:	c0 38       	rjmp	8000b252 <_dtoa_r+0x9e>
8000b24e:	fe cc bd ce 	sub	r12,pc,-16946
8000b252:	41 29       	lddsp	r9,sp[0x48]
8000b254:	58 09       	cp.w	r9,0
8000b256:	e0 80 05 9a 	breq	8000bd8a <_dtoa_r+0xbd6>
8000b25a:	f8 c8 ff fd 	sub	r8,r12,-3
8000b25e:	f8 c9 ff f8 	sub	r9,r12,-8
8000b262:	11 8b       	ld.ub	r11,r8[0x0]
8000b264:	30 0a       	mov	r10,0
8000b266:	41 25       	lddsp	r5,sp[0x48]
8000b268:	f4 0b 18 00 	cp.b	r11,r10
8000b26c:	f2 08 17 10 	movne	r8,r9
8000b270:	c1 68       	rjmp	8000b29c <_dtoa_r+0xe8>
8000b272:	fa ea 00 08 	ld.d	r10,sp[8]
8000b276:	30 08       	mov	r8,0
8000b278:	fa eb 00 3c 	st.d	sp[60],r10
8000b27c:	30 09       	mov	r9,0
8000b27e:	e0 a0 10 ce 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000b282:	c1 00       	breq	8000b2a2 <_dtoa_r+0xee>
8000b284:	30 18       	mov	r8,1
8000b286:	41 5a       	lddsp	r10,sp[0x54]
8000b288:	95 08       	st.w	r10[0x0],r8
8000b28a:	fe cc bf 3a 	sub	r12,pc,-16582
8000b28e:	41 29       	lddsp	r9,sp[0x48]
8000b290:	f8 08 00 08 	add	r8,r12,r8
8000b294:	58 09       	cp.w	r9,0
8000b296:	e0 80 05 7a 	breq	8000bd8a <_dtoa_r+0xbd6>
8000b29a:	12 95       	mov	r5,r9
8000b29c:	8b 08       	st.w	r5[0x0],r8
8000b29e:	e0 8f 05 76 	bral	8000bd8a <_dtoa_r+0xbd6>
8000b2a2:	fa c8 ff 9c 	sub	r8,sp,-100
8000b2a6:	fa c9 ff a0 	sub	r9,sp,-96
8000b2aa:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b2ae:	0e 9c       	mov	r12,r7
8000b2b0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b2b4:	e0 a0 0a 8a 	rcall	8000c7c8 <__d2b>
8000b2b8:	18 93       	mov	r3,r12
8000b2ba:	58 05       	cp.w	r5,0
8000b2bc:	c0 d0       	breq	8000b2d6 <_dtoa_r+0x122>
8000b2be:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b2c2:	30 04       	mov	r4,0
8000b2c4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b2c8:	ea c5 03 ff 	sub	r5,r5,1023
8000b2cc:	10 9b       	mov	r11,r8
8000b2ce:	51 74       	stdsp	sp[0x5c],r4
8000b2d0:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b2d4:	c2 58       	rjmp	8000b31e <_dtoa_r+0x16a>
8000b2d6:	41 88       	lddsp	r8,sp[0x60]
8000b2d8:	41 9c       	lddsp	r12,sp[0x64]
8000b2da:	10 0c       	add	r12,r8
8000b2dc:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b2e0:	e0 45 00 20 	cp.w	r5,32
8000b2e4:	e0 8a 00 0e 	brle	8000b300 <_dtoa_r+0x14c>
8000b2e8:	f8 cc fb ee 	sub	r12,r12,-1042
8000b2ec:	40 3b       	lddsp	r11,sp[0xc]
8000b2ee:	ea 08 11 40 	rsub	r8,r5,64
8000b2f2:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b2f6:	ec 08 09 46 	lsl	r6,r6,r8
8000b2fa:	0c 4c       	or	r12,r6
8000b2fc:	c0 78       	rjmp	8000b30a <_dtoa_r+0x156>
8000b2fe:	d7 03       	nop
8000b300:	ea 0c 11 20 	rsub	r12,r5,32
8000b304:	40 3a       	lddsp	r10,sp[0xc]
8000b306:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b30a:	e0 a0 10 14 	rcall	8000d332 <__avr32_u32_to_f64>
8000b30e:	fc 18 fe 10 	movh	r8,0xfe10
8000b312:	30 19       	mov	r9,1
8000b314:	ea c5 04 33 	sub	r5,r5,1075
8000b318:	f0 0b 00 0b 	add	r11,r8,r11
8000b31c:	51 79       	stdsp	sp[0x5c],r9
8000b31e:	30 08       	mov	r8,0
8000b320:	fc 19 3f f8 	movh	r9,0x3ff8
8000b324:	e0 a0 0e 9c 	rcall	8000d05c <__avr32_f64_sub>
8000b328:	e0 68 43 61 	mov	r8,17249
8000b32c:	ea 18 63 6f 	orh	r8,0x636f
8000b330:	e0 69 87 a7 	mov	r9,34727
8000b334:	ea 19 3f d2 	orh	r9,0x3fd2
8000b338:	e0 a0 0d a6 	rcall	8000ce84 <__avr32_f64_mul>
8000b33c:	e0 68 c8 b3 	mov	r8,51379
8000b340:	ea 18 8b 60 	orh	r8,0x8b60
8000b344:	e0 69 8a 28 	mov	r9,35368
8000b348:	ea 19 3f c6 	orh	r9,0x3fc6
8000b34c:	e0 a0 0f 56 	rcall	8000d1f8 <__avr32_f64_add>
8000b350:	0a 9c       	mov	r12,r5
8000b352:	14 90       	mov	r0,r10
8000b354:	16 91       	mov	r1,r11
8000b356:	e0 a0 0f f2 	rcall	8000d33a <__avr32_s32_to_f64>
8000b35a:	e0 68 79 fb 	mov	r8,31227
8000b35e:	ea 18 50 9f 	orh	r8,0x509f
8000b362:	e0 69 44 13 	mov	r9,17427
8000b366:	ea 19 3f d3 	orh	r9,0x3fd3
8000b36a:	e0 a0 0d 8d 	rcall	8000ce84 <__avr32_f64_mul>
8000b36e:	14 98       	mov	r8,r10
8000b370:	16 99       	mov	r9,r11
8000b372:	00 9a       	mov	r10,r0
8000b374:	02 9b       	mov	r11,r1
8000b376:	e0 a0 0f 41 	rcall	8000d1f8 <__avr32_f64_add>
8000b37a:	14 90       	mov	r0,r10
8000b37c:	16 91       	mov	r1,r11
8000b37e:	e0 a0 0f c7 	rcall	8000d30c <__avr32_f64_to_s32>
8000b382:	30 08       	mov	r8,0
8000b384:	18 96       	mov	r6,r12
8000b386:	30 09       	mov	r9,0
8000b388:	00 9a       	mov	r10,r0
8000b38a:	02 9b       	mov	r11,r1
8000b38c:	e0 a0 10 8e 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b390:	c0 c0       	breq	8000b3a8 <_dtoa_r+0x1f4>
8000b392:	0c 9c       	mov	r12,r6
8000b394:	e0 a0 0f d3 	rcall	8000d33a <__avr32_s32_to_f64>
8000b398:	14 98       	mov	r8,r10
8000b39a:	16 99       	mov	r9,r11
8000b39c:	00 9a       	mov	r10,r0
8000b39e:	02 9b       	mov	r11,r1
8000b3a0:	e0 a0 10 3d 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000b3a4:	f7 b6 00 01 	subeq	r6,1
8000b3a8:	59 66       	cp.w	r6,22
8000b3aa:	e0 88 00 05 	brls	8000b3b4 <_dtoa_r+0x200>
8000b3ae:	30 18       	mov	r8,1
8000b3b0:	51 48       	stdsp	sp[0x50],r8
8000b3b2:	c1 38       	rjmp	8000b3d8 <_dtoa_r+0x224>
8000b3b4:	fe c8 be 80 	sub	r8,pc,-16768
8000b3b8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b3bc:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b3c0:	e0 a0 10 74 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b3c4:	f9 b4 00 00 	moveq	r4,0
8000b3c8:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b3cc:	f7 b6 01 01 	subne	r6,1
8000b3d0:	f9 bc 01 00 	movne	r12,0
8000b3d4:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b3d8:	41 90       	lddsp	r0,sp[0x64]
8000b3da:	20 10       	sub	r0,1
8000b3dc:	0a 10       	sub	r0,r5
8000b3de:	c0 46       	brmi	8000b3e6 <_dtoa_r+0x232>
8000b3e0:	50 40       	stdsp	sp[0x10],r0
8000b3e2:	30 00       	mov	r0,0
8000b3e4:	c0 48       	rjmp	8000b3ec <_dtoa_r+0x238>
8000b3e6:	30 0b       	mov	r11,0
8000b3e8:	5c 30       	neg	r0
8000b3ea:	50 4b       	stdsp	sp[0x10],r11
8000b3ec:	ec 02 11 00 	rsub	r2,r6,0
8000b3f0:	58 06       	cp.w	r6,0
8000b3f2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b3f6:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b3fa:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b3fe:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b402:	f9 b2 04 00 	movge	r2,0
8000b406:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b40a:	f9 b9 05 00 	movlt	r9,0
8000b40e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b412:	40 c8       	lddsp	r8,sp[0x30]
8000b414:	58 98       	cp.w	r8,9
8000b416:	e0 8b 00 20 	brhi	8000b456 <_dtoa_r+0x2a2>
8000b41a:	58 58       	cp.w	r8,5
8000b41c:	f9 b4 0a 01 	movle	r4,1
8000b420:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b424:	f7 b5 09 04 	subgt	r5,4
8000b428:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b42c:	f9 b4 09 00 	movgt	r4,0
8000b430:	40 cc       	lddsp	r12,sp[0x30]
8000b432:	58 3c       	cp.w	r12,3
8000b434:	c2 d0       	breq	8000b48e <_dtoa_r+0x2da>
8000b436:	e0 89 00 05 	brgt	8000b440 <_dtoa_r+0x28c>
8000b43a:	58 2c       	cp.w	r12,2
8000b43c:	c1 01       	brne	8000b45c <_dtoa_r+0x2a8>
8000b43e:	c1 88       	rjmp	8000b46e <_dtoa_r+0x2ba>
8000b440:	40 cb       	lddsp	r11,sp[0x30]
8000b442:	58 4b       	cp.w	r11,4
8000b444:	c0 60       	breq	8000b450 <_dtoa_r+0x29c>
8000b446:	58 5b       	cp.w	r11,5
8000b448:	c0 a1       	brne	8000b45c <_dtoa_r+0x2a8>
8000b44a:	30 1a       	mov	r10,1
8000b44c:	50 da       	stdsp	sp[0x34],r10
8000b44e:	c2 28       	rjmp	8000b492 <_dtoa_r+0x2de>
8000b450:	30 19       	mov	r9,1
8000b452:	50 d9       	stdsp	sp[0x34],r9
8000b454:	c0 f8       	rjmp	8000b472 <_dtoa_r+0x2be>
8000b456:	30 08       	mov	r8,0
8000b458:	30 14       	mov	r4,1
8000b45a:	50 c8       	stdsp	sp[0x30],r8
8000b45c:	3f f5       	mov	r5,-1
8000b45e:	30 1c       	mov	r12,1
8000b460:	30 0b       	mov	r11,0
8000b462:	50 95       	stdsp	sp[0x24],r5
8000b464:	50 dc       	stdsp	sp[0x34],r12
8000b466:	0a 91       	mov	r1,r5
8000b468:	31 28       	mov	r8,18
8000b46a:	50 eb       	stdsp	sp[0x38],r11
8000b46c:	c2 08       	rjmp	8000b4ac <_dtoa_r+0x2f8>
8000b46e:	30 0a       	mov	r10,0
8000b470:	50 da       	stdsp	sp[0x34],r10
8000b472:	40 e9       	lddsp	r9,sp[0x38]
8000b474:	58 09       	cp.w	r9,0
8000b476:	e0 89 00 07 	brgt	8000b484 <_dtoa_r+0x2d0>
8000b47a:	30 18       	mov	r8,1
8000b47c:	50 98       	stdsp	sp[0x24],r8
8000b47e:	10 91       	mov	r1,r8
8000b480:	50 e8       	stdsp	sp[0x38],r8
8000b482:	c1 58       	rjmp	8000b4ac <_dtoa_r+0x2f8>
8000b484:	40 e5       	lddsp	r5,sp[0x38]
8000b486:	50 95       	stdsp	sp[0x24],r5
8000b488:	0a 91       	mov	r1,r5
8000b48a:	0a 98       	mov	r8,r5
8000b48c:	c1 08       	rjmp	8000b4ac <_dtoa_r+0x2f8>
8000b48e:	30 0c       	mov	r12,0
8000b490:	50 dc       	stdsp	sp[0x34],r12
8000b492:	40 eb       	lddsp	r11,sp[0x38]
8000b494:	ec 0b 00 0b 	add	r11,r6,r11
8000b498:	50 9b       	stdsp	sp[0x24],r11
8000b49a:	16 98       	mov	r8,r11
8000b49c:	2f f8       	sub	r8,-1
8000b49e:	58 08       	cp.w	r8,0
8000b4a0:	e0 89 00 05 	brgt	8000b4aa <_dtoa_r+0x2f6>
8000b4a4:	10 91       	mov	r1,r8
8000b4a6:	30 18       	mov	r8,1
8000b4a8:	c0 28       	rjmp	8000b4ac <_dtoa_r+0x2f8>
8000b4aa:	10 91       	mov	r1,r8
8000b4ac:	30 09       	mov	r9,0
8000b4ae:	6e 9a       	ld.w	r10,r7[0x24]
8000b4b0:	95 19       	st.w	r10[0x4],r9
8000b4b2:	30 49       	mov	r9,4
8000b4b4:	c0 68       	rjmp	8000b4c0 <_dtoa_r+0x30c>
8000b4b6:	d7 03       	nop
8000b4b8:	6a 1a       	ld.w	r10,r5[0x4]
8000b4ba:	a1 79       	lsl	r9,0x1
8000b4bc:	2f fa       	sub	r10,-1
8000b4be:	8b 1a       	st.w	r5[0x4],r10
8000b4c0:	6e 95       	ld.w	r5,r7[0x24]
8000b4c2:	f2 ca ff ec 	sub	r10,r9,-20
8000b4c6:	10 3a       	cp.w	r10,r8
8000b4c8:	fe 98 ff f8 	brls	8000b4b8 <_dtoa_r+0x304>
8000b4cc:	6a 1b       	ld.w	r11,r5[0x4]
8000b4ce:	0e 9c       	mov	r12,r7
8000b4d0:	e0 a0 09 44 	rcall	8000c758 <_Balloc>
8000b4d4:	58 e1       	cp.w	r1,14
8000b4d6:	5f 88       	srls	r8
8000b4d8:	8b 0c       	st.w	r5[0x0],r12
8000b4da:	f1 e4 00 04 	and	r4,r8,r4
8000b4de:	6e 98       	ld.w	r8,r7[0x24]
8000b4e0:	70 08       	ld.w	r8,r8[0x0]
8000b4e2:	50 88       	stdsp	sp[0x20],r8
8000b4e4:	e0 80 01 82 	breq	8000b7e8 <_dtoa_r+0x634>
8000b4e8:	58 06       	cp.w	r6,0
8000b4ea:	e0 8a 00 43 	brle	8000b570 <_dtoa_r+0x3bc>
8000b4ee:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b4f2:	fe c8 bf be 	sub	r8,pc,-16450
8000b4f6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b4fa:	fa e5 00 18 	st.d	sp[24],r4
8000b4fe:	ec 04 14 04 	asr	r4,r6,0x4
8000b502:	ed b4 00 04 	bld	r4,0x4
8000b506:	c0 30       	breq	8000b50c <_dtoa_r+0x358>
8000b508:	30 25       	mov	r5,2
8000b50a:	c1 08       	rjmp	8000b52a <_dtoa_r+0x376>
8000b50c:	fe c8 bf 10 	sub	r8,pc,-16624
8000b510:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b514:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b518:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b51c:	e0 a0 0f fa 	rcall	8000d510 <__avr32_f64_div>
8000b520:	30 35       	mov	r5,3
8000b522:	14 98       	mov	r8,r10
8000b524:	16 99       	mov	r9,r11
8000b526:	fa e9 00 08 	st.d	sp[8],r8
8000b52a:	fe cc bf 2e 	sub	r12,pc,-16594
8000b52e:	50 a3       	stdsp	sp[0x28],r3
8000b530:	0c 93       	mov	r3,r6
8000b532:	18 96       	mov	r6,r12
8000b534:	c0 f8       	rjmp	8000b552 <_dtoa_r+0x39e>
8000b536:	fa ea 00 18 	ld.d	r10,sp[24]
8000b53a:	ed b4 00 00 	bld	r4,0x0
8000b53e:	c0 81       	brne	8000b54e <_dtoa_r+0x39a>
8000b540:	ec e8 00 00 	ld.d	r8,r6[0]
8000b544:	2f f5       	sub	r5,-1
8000b546:	e0 a0 0c 9f 	rcall	8000ce84 <__avr32_f64_mul>
8000b54a:	fa eb 00 18 	st.d	sp[24],r10
8000b54e:	a1 54       	asr	r4,0x1
8000b550:	2f 86       	sub	r6,-8
8000b552:	58 04       	cp.w	r4,0
8000b554:	cf 11       	brne	8000b536 <_dtoa_r+0x382>
8000b556:	fa e8 00 18 	ld.d	r8,sp[24]
8000b55a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b55e:	06 96       	mov	r6,r3
8000b560:	e0 a0 0f d8 	rcall	8000d510 <__avr32_f64_div>
8000b564:	40 a3       	lddsp	r3,sp[0x28]
8000b566:	14 98       	mov	r8,r10
8000b568:	16 99       	mov	r9,r11
8000b56a:	fa e9 00 08 	st.d	sp[8],r8
8000b56e:	c2 f8       	rjmp	8000b5cc <_dtoa_r+0x418>
8000b570:	ec 08 11 00 	rsub	r8,r6,0
8000b574:	c0 31       	brne	8000b57a <_dtoa_r+0x3c6>
8000b576:	30 25       	mov	r5,2
8000b578:	c2 a8       	rjmp	8000b5cc <_dtoa_r+0x418>
8000b57a:	fe cc bf 7e 	sub	r12,pc,-16514
8000b57e:	f0 04 14 04 	asr	r4,r8,0x4
8000b582:	50 1c       	stdsp	sp[0x4],r12
8000b584:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b588:	fe c9 c0 54 	sub	r9,pc,-16300
8000b58c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b590:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b594:	e0 a0 0c 78 	rcall	8000ce84 <__avr32_f64_mul>
8000b598:	40 1c       	lddsp	r12,sp[0x4]
8000b59a:	50 63       	stdsp	sp[0x18],r3
8000b59c:	30 25       	mov	r5,2
8000b59e:	0c 93       	mov	r3,r6
8000b5a0:	fa eb 00 08 	st.d	sp[8],r10
8000b5a4:	18 96       	mov	r6,r12
8000b5a6:	c0 f8       	rjmp	8000b5c4 <_dtoa_r+0x410>
8000b5a8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5ac:	ed b4 00 00 	bld	r4,0x0
8000b5b0:	c0 81       	brne	8000b5c0 <_dtoa_r+0x40c>
8000b5b2:	ec e8 00 00 	ld.d	r8,r6[0]
8000b5b6:	2f f5       	sub	r5,-1
8000b5b8:	e0 a0 0c 66 	rcall	8000ce84 <__avr32_f64_mul>
8000b5bc:	fa eb 00 08 	st.d	sp[8],r10
8000b5c0:	a1 54       	asr	r4,0x1
8000b5c2:	2f 86       	sub	r6,-8
8000b5c4:	58 04       	cp.w	r4,0
8000b5c6:	cf 11       	brne	8000b5a8 <_dtoa_r+0x3f4>
8000b5c8:	06 96       	mov	r6,r3
8000b5ca:	40 63       	lddsp	r3,sp[0x18]
8000b5cc:	41 4a       	lddsp	r10,sp[0x50]
8000b5ce:	58 0a       	cp.w	r10,0
8000b5d0:	c2 a0       	breq	8000b624 <_dtoa_r+0x470>
8000b5d2:	fa e8 00 08 	ld.d	r8,sp[8]
8000b5d6:	58 01       	cp.w	r1,0
8000b5d8:	5f 94       	srgt	r4
8000b5da:	fa e9 00 18 	st.d	sp[24],r8
8000b5de:	30 08       	mov	r8,0
8000b5e0:	fc 19 3f f0 	movh	r9,0x3ff0
8000b5e4:	fa ea 00 18 	ld.d	r10,sp[24]
8000b5e8:	e0 a0 0f 60 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b5ec:	f9 bc 00 00 	moveq	r12,0
8000b5f0:	f9 bc 01 01 	movne	r12,1
8000b5f4:	e9 ec 00 0c 	and	r12,r4,r12
8000b5f8:	c1 60       	breq	8000b624 <_dtoa_r+0x470>
8000b5fa:	40 98       	lddsp	r8,sp[0x24]
8000b5fc:	58 08       	cp.w	r8,0
8000b5fe:	e0 8a 00 f1 	brle	8000b7e0 <_dtoa_r+0x62c>
8000b602:	30 08       	mov	r8,0
8000b604:	fc 19 40 24 	movh	r9,0x4024
8000b608:	ec c4 00 01 	sub	r4,r6,1
8000b60c:	fa ea 00 18 	ld.d	r10,sp[24]
8000b610:	2f f5       	sub	r5,-1
8000b612:	50 64       	stdsp	sp[0x18],r4
8000b614:	e0 a0 0c 38 	rcall	8000ce84 <__avr32_f64_mul>
8000b618:	40 94       	lddsp	r4,sp[0x24]
8000b61a:	14 98       	mov	r8,r10
8000b61c:	16 99       	mov	r9,r11
8000b61e:	fa e9 00 08 	st.d	sp[8],r8
8000b622:	c0 38       	rjmp	8000b628 <_dtoa_r+0x474>
8000b624:	50 66       	stdsp	sp[0x18],r6
8000b626:	02 94       	mov	r4,r1
8000b628:	0a 9c       	mov	r12,r5
8000b62a:	e0 a0 0e 88 	rcall	8000d33a <__avr32_s32_to_f64>
8000b62e:	fa e8 00 08 	ld.d	r8,sp[8]
8000b632:	e0 a0 0c 29 	rcall	8000ce84 <__avr32_f64_mul>
8000b636:	30 08       	mov	r8,0
8000b638:	fc 19 40 1c 	movh	r9,0x401c
8000b63c:	e0 a0 0d de 	rcall	8000d1f8 <__avr32_f64_add>
8000b640:	14 98       	mov	r8,r10
8000b642:	16 99       	mov	r9,r11
8000b644:	fa e9 00 28 	st.d	sp[40],r8
8000b648:	fc 18 fc c0 	movh	r8,0xfcc0
8000b64c:	40 a5       	lddsp	r5,sp[0x28]
8000b64e:	10 05       	add	r5,r8
8000b650:	50 a5       	stdsp	sp[0x28],r5
8000b652:	58 04       	cp.w	r4,0
8000b654:	c2 11       	brne	8000b696 <_dtoa_r+0x4e2>
8000b656:	fa ea 00 08 	ld.d	r10,sp[8]
8000b65a:	30 08       	mov	r8,0
8000b65c:	fc 19 40 14 	movh	r9,0x4014
8000b660:	e0 a0 0c fe 	rcall	8000d05c <__avr32_f64_sub>
8000b664:	40 bc       	lddsp	r12,sp[0x2c]
8000b666:	fa eb 00 08 	st.d	sp[8],r10
8000b66a:	14 98       	mov	r8,r10
8000b66c:	16 99       	mov	r9,r11
8000b66e:	18 9a       	mov	r10,r12
8000b670:	0a 9b       	mov	r11,r5
8000b672:	e0 a0 0f 1b 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b676:	e0 81 02 54 	brne	8000bb1e <_dtoa_r+0x96a>
8000b67a:	0a 98       	mov	r8,r5
8000b67c:	40 b9       	lddsp	r9,sp[0x2c]
8000b67e:	ee 18 80 00 	eorh	r8,0x8000
8000b682:	fa ea 00 08 	ld.d	r10,sp[8]
8000b686:	10 95       	mov	r5,r8
8000b688:	12 98       	mov	r8,r9
8000b68a:	0a 99       	mov	r9,r5
8000b68c:	e0 a0 0f 0e 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b690:	e0 81 02 3e 	brne	8000bb0c <_dtoa_r+0x958>
8000b694:	ca 68       	rjmp	8000b7e0 <_dtoa_r+0x62c>
8000b696:	fe c9 c1 62 	sub	r9,pc,-16030
8000b69a:	e8 c8 00 01 	sub	r8,r4,1
8000b69e:	40 d5       	lddsp	r5,sp[0x34]
8000b6a0:	58 05       	cp.w	r5,0
8000b6a2:	c4 f0       	breq	8000b740 <_dtoa_r+0x58c>
8000b6a4:	30 0c       	mov	r12,0
8000b6a6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b6aa:	51 3c       	stdsp	sp[0x4c],r12
8000b6ac:	30 0a       	mov	r10,0
8000b6ae:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b6b2:	e0 a0 0f 2f 	rcall	8000d510 <__avr32_f64_div>
8000b6b6:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6ba:	40 85       	lddsp	r5,sp[0x20]
8000b6bc:	e0 a0 0c d0 	rcall	8000d05c <__avr32_f64_sub>
8000b6c0:	fa eb 00 28 	st.d	sp[40],r10
8000b6c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6c8:	e0 a0 0e 22 	rcall	8000d30c <__avr32_f64_to_s32>
8000b6cc:	51 6c       	stdsp	sp[0x58],r12
8000b6ce:	e0 a0 0e 36 	rcall	8000d33a <__avr32_s32_to_f64>
8000b6d2:	14 98       	mov	r8,r10
8000b6d4:	16 99       	mov	r9,r11
8000b6d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6da:	e0 a0 0c c1 	rcall	8000d05c <__avr32_f64_sub>
8000b6de:	fa eb 00 08 	st.d	sp[8],r10
8000b6e2:	41 68       	lddsp	r8,sp[0x58]
8000b6e4:	2d 08       	sub	r8,-48
8000b6e6:	0a c8       	st.b	r5++,r8
8000b6e8:	41 39       	lddsp	r9,sp[0x4c]
8000b6ea:	2f f9       	sub	r9,-1
8000b6ec:	51 39       	stdsp	sp[0x4c],r9
8000b6ee:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6f2:	e0 a0 0e db 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b6f6:	e0 81 03 39 	brne	8000bd68 <_dtoa_r+0xbb4>
8000b6fa:	fa e8 00 08 	ld.d	r8,sp[8]
8000b6fe:	30 0a       	mov	r10,0
8000b700:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b704:	e0 a0 0c ac 	rcall	8000d05c <__avr32_f64_sub>
8000b708:	fa e8 00 28 	ld.d	r8,sp[40]
8000b70c:	e0 a0 0e ce 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b710:	fa ea 00 28 	ld.d	r10,sp[40]
8000b714:	30 08       	mov	r8,0
8000b716:	fc 19 40 24 	movh	r9,0x4024
8000b71a:	e0 81 00 da 	brne	8000b8ce <_dtoa_r+0x71a>
8000b71e:	41 3c       	lddsp	r12,sp[0x4c]
8000b720:	08 3c       	cp.w	r12,r4
8000b722:	c5 f4       	brge	8000b7e0 <_dtoa_r+0x62c>
8000b724:	e0 a0 0b b0 	rcall	8000ce84 <__avr32_f64_mul>
8000b728:	30 08       	mov	r8,0
8000b72a:	fa eb 00 28 	st.d	sp[40],r10
8000b72e:	fc 19 40 24 	movh	r9,0x4024
8000b732:	fa ea 00 08 	ld.d	r10,sp[8]
8000b736:	e0 a0 0b a7 	rcall	8000ce84 <__avr32_f64_mul>
8000b73a:	fa eb 00 08 	st.d	sp[8],r10
8000b73e:	cc 3b       	rjmp	8000b6c4 <_dtoa_r+0x510>
8000b740:	40 85       	lddsp	r5,sp[0x20]
8000b742:	08 05       	add	r5,r4
8000b744:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b748:	51 35       	stdsp	sp[0x4c],r5
8000b74a:	fa e8 00 28 	ld.d	r8,sp[40]
8000b74e:	40 85       	lddsp	r5,sp[0x20]
8000b750:	e0 a0 0b 9a 	rcall	8000ce84 <__avr32_f64_mul>
8000b754:	fa eb 00 28 	st.d	sp[40],r10
8000b758:	fa ea 00 08 	ld.d	r10,sp[8]
8000b75c:	e0 a0 0d d8 	rcall	8000d30c <__avr32_f64_to_s32>
8000b760:	51 6c       	stdsp	sp[0x58],r12
8000b762:	e0 a0 0d ec 	rcall	8000d33a <__avr32_s32_to_f64>
8000b766:	14 98       	mov	r8,r10
8000b768:	16 99       	mov	r9,r11
8000b76a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b76e:	e0 a0 0c 77 	rcall	8000d05c <__avr32_f64_sub>
8000b772:	fa eb 00 08 	st.d	sp[8],r10
8000b776:	41 68       	lddsp	r8,sp[0x58]
8000b778:	2d 08       	sub	r8,-48
8000b77a:	0a c8       	st.b	r5++,r8
8000b77c:	41 3c       	lddsp	r12,sp[0x4c]
8000b77e:	18 35       	cp.w	r5,r12
8000b780:	c2 81       	brne	8000b7d0 <_dtoa_r+0x61c>
8000b782:	30 08       	mov	r8,0
8000b784:	fc 19 3f e0 	movh	r9,0x3fe0
8000b788:	fa ea 00 28 	ld.d	r10,sp[40]
8000b78c:	e0 a0 0d 36 	rcall	8000d1f8 <__avr32_f64_add>
8000b790:	40 85       	lddsp	r5,sp[0x20]
8000b792:	fa e8 00 08 	ld.d	r8,sp[8]
8000b796:	08 05       	add	r5,r4
8000b798:	e0 a0 0e 88 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b79c:	e0 81 00 99 	brne	8000b8ce <_dtoa_r+0x71a>
8000b7a0:	fa e8 00 28 	ld.d	r8,sp[40]
8000b7a4:	30 0a       	mov	r10,0
8000b7a6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b7aa:	e0 a0 0c 59 	rcall	8000d05c <__avr32_f64_sub>
8000b7ae:	14 98       	mov	r8,r10
8000b7b0:	16 99       	mov	r9,r11
8000b7b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7b6:	e0 a0 0e 79 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b7ba:	c1 30       	breq	8000b7e0 <_dtoa_r+0x62c>
8000b7bc:	33 09       	mov	r9,48
8000b7be:	0a 98       	mov	r8,r5
8000b7c0:	11 7a       	ld.ub	r10,--r8
8000b7c2:	f2 0a 18 00 	cp.b	r10,r9
8000b7c6:	e0 81 02 d1 	brne	8000bd68 <_dtoa_r+0xbb4>
8000b7ca:	10 95       	mov	r5,r8
8000b7cc:	cf 9b       	rjmp	8000b7be <_dtoa_r+0x60a>
8000b7ce:	d7 03       	nop
8000b7d0:	30 08       	mov	r8,0
8000b7d2:	fc 19 40 24 	movh	r9,0x4024
8000b7d6:	e0 a0 0b 57 	rcall	8000ce84 <__avr32_f64_mul>
8000b7da:	fa eb 00 08 	st.d	sp[8],r10
8000b7de:	cb db       	rjmp	8000b758 <_dtoa_r+0x5a4>
8000b7e0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b7e4:	fa eb 00 08 	st.d	sp[8],r10
8000b7e8:	58 e6       	cp.w	r6,14
8000b7ea:	5f ab       	srle	r11
8000b7ec:	41 8a       	lddsp	r10,sp[0x60]
8000b7ee:	30 08       	mov	r8,0
8000b7f0:	f4 09 11 ff 	rsub	r9,r10,-1
8000b7f4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b7f8:	f0 09 18 00 	cp.b	r9,r8
8000b7fc:	e0 80 00 82 	breq	8000b900 <_dtoa_r+0x74c>
8000b800:	40 ea       	lddsp	r10,sp[0x38]
8000b802:	58 01       	cp.w	r1,0
8000b804:	5f a9       	srle	r9
8000b806:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b80a:	fe ca c2 d6 	sub	r10,pc,-15658
8000b80e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b812:	fa e5 00 10 	st.d	sp[16],r4
8000b816:	f0 09 18 00 	cp.b	r9,r8
8000b81a:	c1 40       	breq	8000b842 <_dtoa_r+0x68e>
8000b81c:	58 01       	cp.w	r1,0
8000b81e:	e0 81 01 77 	brne	8000bb0c <_dtoa_r+0x958>
8000b822:	30 08       	mov	r8,0
8000b824:	fc 19 40 14 	movh	r9,0x4014
8000b828:	08 9a       	mov	r10,r4
8000b82a:	0a 9b       	mov	r11,r5
8000b82c:	e0 a0 0b 2c 	rcall	8000ce84 <__avr32_f64_mul>
8000b830:	fa e8 00 08 	ld.d	r8,sp[8]
8000b834:	e0 a0 0e 06 	rcall	8000d440 <__avr32_f64_cmp_ge>
8000b838:	e0 81 01 6a 	brne	8000bb0c <_dtoa_r+0x958>
8000b83c:	02 92       	mov	r2,r1
8000b83e:	e0 8f 01 72 	bral	8000bb22 <_dtoa_r+0x96e>
8000b842:	40 85       	lddsp	r5,sp[0x20]
8000b844:	30 14       	mov	r4,1
8000b846:	fa e8 00 10 	ld.d	r8,sp[16]
8000b84a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b84e:	e0 a0 0e 61 	rcall	8000d510 <__avr32_f64_div>
8000b852:	e0 a0 0d 5d 	rcall	8000d30c <__avr32_f64_to_s32>
8000b856:	18 92       	mov	r2,r12
8000b858:	e0 a0 0d 71 	rcall	8000d33a <__avr32_s32_to_f64>
8000b85c:	fa e8 00 10 	ld.d	r8,sp[16]
8000b860:	e0 a0 0b 12 	rcall	8000ce84 <__avr32_f64_mul>
8000b864:	14 98       	mov	r8,r10
8000b866:	16 99       	mov	r9,r11
8000b868:	fa ea 00 08 	ld.d	r10,sp[8]
8000b86c:	e0 a0 0b f8 	rcall	8000d05c <__avr32_f64_sub>
8000b870:	fa eb 00 08 	st.d	sp[8],r10
8000b874:	e4 c8 ff d0 	sub	r8,r2,-48
8000b878:	0a c8       	st.b	r5++,r8
8000b87a:	fc 19 40 24 	movh	r9,0x4024
8000b87e:	30 08       	mov	r8,0
8000b880:	02 34       	cp.w	r4,r1
8000b882:	c3 31       	brne	8000b8e8 <_dtoa_r+0x734>
8000b884:	fa e8 00 08 	ld.d	r8,sp[8]
8000b888:	e0 a0 0c b8 	rcall	8000d1f8 <__avr32_f64_add>
8000b88c:	16 91       	mov	r1,r11
8000b88e:	14 90       	mov	r0,r10
8000b890:	14 98       	mov	r8,r10
8000b892:	02 99       	mov	r9,r1
8000b894:	fa ea 00 10 	ld.d	r10,sp[16]
8000b898:	e0 a0 0e 08 	rcall	8000d4a8 <__avr32_f64_cmp_lt>
8000b89c:	c1 a1       	brne	8000b8d0 <_dtoa_r+0x71c>
8000b89e:	fa e8 00 10 	ld.d	r8,sp[16]
8000b8a2:	00 9a       	mov	r10,r0
8000b8a4:	02 9b       	mov	r11,r1
8000b8a6:	e0 a0 0d ba 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000b8aa:	e0 80 02 5e 	breq	8000bd66 <_dtoa_r+0xbb2>
8000b8ae:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b8b2:	c0 f1       	brne	8000b8d0 <_dtoa_r+0x71c>
8000b8b4:	e0 8f 02 59 	bral	8000bd66 <_dtoa_r+0xbb2>
8000b8b8:	40 8a       	lddsp	r10,sp[0x20]
8000b8ba:	14 38       	cp.w	r8,r10
8000b8bc:	c0 30       	breq	8000b8c2 <_dtoa_r+0x70e>
8000b8be:	10 95       	mov	r5,r8
8000b8c0:	c0 98       	rjmp	8000b8d2 <_dtoa_r+0x71e>
8000b8c2:	33 08       	mov	r8,48
8000b8c4:	40 89       	lddsp	r9,sp[0x20]
8000b8c6:	2f f6       	sub	r6,-1
8000b8c8:	b2 88       	st.b	r9[0x0],r8
8000b8ca:	40 88       	lddsp	r8,sp[0x20]
8000b8cc:	c0 88       	rjmp	8000b8dc <_dtoa_r+0x728>
8000b8ce:	40 66       	lddsp	r6,sp[0x18]
8000b8d0:	33 99       	mov	r9,57
8000b8d2:	0a 98       	mov	r8,r5
8000b8d4:	11 7a       	ld.ub	r10,--r8
8000b8d6:	f2 0a 18 00 	cp.b	r10,r9
8000b8da:	ce f0       	breq	8000b8b8 <_dtoa_r+0x704>
8000b8dc:	50 66       	stdsp	sp[0x18],r6
8000b8de:	11 89       	ld.ub	r9,r8[0x0]
8000b8e0:	2f f9       	sub	r9,-1
8000b8e2:	b0 89       	st.b	r8[0x0],r9
8000b8e4:	e0 8f 02 42 	bral	8000bd68 <_dtoa_r+0xbb4>
8000b8e8:	e0 a0 0a ce 	rcall	8000ce84 <__avr32_f64_mul>
8000b8ec:	2f f4       	sub	r4,-1
8000b8ee:	fa eb 00 08 	st.d	sp[8],r10
8000b8f2:	30 08       	mov	r8,0
8000b8f4:	30 09       	mov	r9,0
8000b8f6:	e0 a0 0d 92 	rcall	8000d41a <__avr32_f64_cmp_eq>
8000b8fa:	ca 60       	breq	8000b846 <_dtoa_r+0x692>
8000b8fc:	e0 8f 02 35 	bral	8000bd66 <_dtoa_r+0xbb2>
8000b900:	40 d8       	lddsp	r8,sp[0x34]
8000b902:	58 08       	cp.w	r8,0
8000b904:	c0 51       	brne	8000b90e <_dtoa_r+0x75a>
8000b906:	04 98       	mov	r8,r2
8000b908:	00 95       	mov	r5,r0
8000b90a:	40 d4       	lddsp	r4,sp[0x34]
8000b90c:	c3 78       	rjmp	8000b97a <_dtoa_r+0x7c6>
8000b90e:	40 c5       	lddsp	r5,sp[0x30]
8000b910:	58 15       	cp.w	r5,1
8000b912:	e0 89 00 0f 	brgt	8000b930 <_dtoa_r+0x77c>
8000b916:	41 74       	lddsp	r4,sp[0x5c]
8000b918:	58 04       	cp.w	r4,0
8000b91a:	c0 40       	breq	8000b922 <_dtoa_r+0x76e>
8000b91c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b920:	c0 48       	rjmp	8000b928 <_dtoa_r+0x774>
8000b922:	41 99       	lddsp	r9,sp[0x64]
8000b924:	f2 09 11 36 	rsub	r9,r9,54
8000b928:	04 98       	mov	r8,r2
8000b92a:	00 95       	mov	r5,r0
8000b92c:	c1 c8       	rjmp	8000b964 <_dtoa_r+0x7b0>
8000b92e:	d7 03       	nop
8000b930:	e2 c8 00 01 	sub	r8,r1,1
8000b934:	58 01       	cp.w	r1,0
8000b936:	e0 05 17 40 	movge	r5,r0
8000b93a:	e2 09 17 40 	movge	r9,r1
8000b93e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b942:	f9 b9 05 00 	movlt	r9,0
8000b946:	10 32       	cp.w	r2,r8
8000b948:	e5 d8 e4 18 	subge	r8,r2,r8
8000b94c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b950:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b954:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b958:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b95c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b960:	f9 b8 05 00 	movlt	r8,0
8000b964:	40 4b       	lddsp	r11,sp[0x10]
8000b966:	12 0b       	add	r11,r9
8000b968:	50 08       	stdsp	sp[0x0],r8
8000b96a:	50 4b       	stdsp	sp[0x10],r11
8000b96c:	12 00       	add	r0,r9
8000b96e:	30 1b       	mov	r11,1
8000b970:	0e 9c       	mov	r12,r7
8000b972:	e0 a0 08 a7 	rcall	8000cac0 <__i2b>
8000b976:	40 08       	lddsp	r8,sp[0x0]
8000b978:	18 94       	mov	r4,r12
8000b97a:	40 4a       	lddsp	r10,sp[0x10]
8000b97c:	58 05       	cp.w	r5,0
8000b97e:	5f 99       	srgt	r9
8000b980:	58 0a       	cp.w	r10,0
8000b982:	5f 9a       	srgt	r10
8000b984:	f5 e9 00 09 	and	r9,r10,r9
8000b988:	c0 80       	breq	8000b998 <_dtoa_r+0x7e4>
8000b98a:	40 4c       	lddsp	r12,sp[0x10]
8000b98c:	f8 05 0d 49 	min	r9,r12,r5
8000b990:	12 1c       	sub	r12,r9
8000b992:	12 10       	sub	r0,r9
8000b994:	50 4c       	stdsp	sp[0x10],r12
8000b996:	12 15       	sub	r5,r9
8000b998:	58 02       	cp.w	r2,0
8000b99a:	e0 8a 00 27 	brle	8000b9e8 <_dtoa_r+0x834>
8000b99e:	40 db       	lddsp	r11,sp[0x34]
8000b9a0:	58 0b       	cp.w	r11,0
8000b9a2:	c1 d0       	breq	8000b9dc <_dtoa_r+0x828>
8000b9a4:	58 08       	cp.w	r8,0
8000b9a6:	e0 8a 00 17 	brle	8000b9d4 <_dtoa_r+0x820>
8000b9aa:	10 9a       	mov	r10,r8
8000b9ac:	50 08       	stdsp	sp[0x0],r8
8000b9ae:	08 9b       	mov	r11,r4
8000b9b0:	0e 9c       	mov	r12,r7
8000b9b2:	e0 a0 08 cd 	rcall	8000cb4c <__pow5mult>
8000b9b6:	06 9a       	mov	r10,r3
8000b9b8:	18 9b       	mov	r11,r12
8000b9ba:	18 94       	mov	r4,r12
8000b9bc:	0e 9c       	mov	r12,r7
8000b9be:	e0 a0 08 01 	rcall	8000c9c0 <__multiply>
8000b9c2:	18 99       	mov	r9,r12
8000b9c4:	06 9b       	mov	r11,r3
8000b9c6:	50 19       	stdsp	sp[0x4],r9
8000b9c8:	0e 9c       	mov	r12,r7
8000b9ca:	e0 a0 06 ad 	rcall	8000c724 <_Bfree>
8000b9ce:	40 19       	lddsp	r9,sp[0x4]
8000b9d0:	40 08       	lddsp	r8,sp[0x0]
8000b9d2:	12 93       	mov	r3,r9
8000b9d4:	e4 08 01 0a 	sub	r10,r2,r8
8000b9d8:	c0 80       	breq	8000b9e8 <_dtoa_r+0x834>
8000b9da:	c0 28       	rjmp	8000b9de <_dtoa_r+0x82a>
8000b9dc:	04 9a       	mov	r10,r2
8000b9de:	06 9b       	mov	r11,r3
8000b9e0:	0e 9c       	mov	r12,r7
8000b9e2:	e0 a0 08 b5 	rcall	8000cb4c <__pow5mult>
8000b9e6:	18 93       	mov	r3,r12
8000b9e8:	30 1b       	mov	r11,1
8000b9ea:	0e 9c       	mov	r12,r7
8000b9ec:	e0 a0 08 6a 	rcall	8000cac0 <__i2b>
8000b9f0:	41 1a       	lddsp	r10,sp[0x44]
8000b9f2:	18 92       	mov	r2,r12
8000b9f4:	58 0a       	cp.w	r10,0
8000b9f6:	e0 8a 00 07 	brle	8000ba04 <_dtoa_r+0x850>
8000b9fa:	18 9b       	mov	r11,r12
8000b9fc:	0e 9c       	mov	r12,r7
8000b9fe:	e0 a0 08 a7 	rcall	8000cb4c <__pow5mult>
8000ba02:	18 92       	mov	r2,r12
8000ba04:	40 c9       	lddsp	r9,sp[0x30]
8000ba06:	58 19       	cp.w	r9,1
8000ba08:	e0 89 00 14 	brgt	8000ba30 <_dtoa_r+0x87c>
8000ba0c:	40 38       	lddsp	r8,sp[0xc]
8000ba0e:	58 08       	cp.w	r8,0
8000ba10:	c1 01       	brne	8000ba30 <_dtoa_r+0x87c>
8000ba12:	40 29       	lddsp	r9,sp[0x8]
8000ba14:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ba18:	c0 c1       	brne	8000ba30 <_dtoa_r+0x87c>
8000ba1a:	12 98       	mov	r8,r9
8000ba1c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ba20:	c0 80       	breq	8000ba30 <_dtoa_r+0x87c>
8000ba22:	40 4c       	lddsp	r12,sp[0x10]
8000ba24:	30 1b       	mov	r11,1
8000ba26:	2f fc       	sub	r12,-1
8000ba28:	2f f0       	sub	r0,-1
8000ba2a:	50 4c       	stdsp	sp[0x10],r12
8000ba2c:	50 6b       	stdsp	sp[0x18],r11
8000ba2e:	c0 38       	rjmp	8000ba34 <_dtoa_r+0x880>
8000ba30:	30 0a       	mov	r10,0
8000ba32:	50 6a       	stdsp	sp[0x18],r10
8000ba34:	41 19       	lddsp	r9,sp[0x44]
8000ba36:	58 09       	cp.w	r9,0
8000ba38:	c0 31       	brne	8000ba3e <_dtoa_r+0x88a>
8000ba3a:	30 1c       	mov	r12,1
8000ba3c:	c0 98       	rjmp	8000ba4e <_dtoa_r+0x89a>
8000ba3e:	64 48       	ld.w	r8,r2[0x10]
8000ba40:	2f c8       	sub	r8,-4
8000ba42:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ba46:	e0 a0 05 df 	rcall	8000c604 <__hi0bits>
8000ba4a:	f8 0c 11 20 	rsub	r12,r12,32
8000ba4e:	40 4b       	lddsp	r11,sp[0x10]
8000ba50:	f8 0b 00 08 	add	r8,r12,r11
8000ba54:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ba58:	c0 c0       	breq	8000ba70 <_dtoa_r+0x8bc>
8000ba5a:	f0 08 11 20 	rsub	r8,r8,32
8000ba5e:	58 48       	cp.w	r8,4
8000ba60:	e0 8a 00 06 	brle	8000ba6c <_dtoa_r+0x8b8>
8000ba64:	20 48       	sub	r8,4
8000ba66:	10 0b       	add	r11,r8
8000ba68:	50 4b       	stdsp	sp[0x10],r11
8000ba6a:	c0 78       	rjmp	8000ba78 <_dtoa_r+0x8c4>
8000ba6c:	58 48       	cp.w	r8,4
8000ba6e:	c0 70       	breq	8000ba7c <_dtoa_r+0x8c8>
8000ba70:	40 4a       	lddsp	r10,sp[0x10]
8000ba72:	2e 48       	sub	r8,-28
8000ba74:	10 0a       	add	r10,r8
8000ba76:	50 4a       	stdsp	sp[0x10],r10
8000ba78:	10 00       	add	r0,r8
8000ba7a:	10 05       	add	r5,r8
8000ba7c:	58 00       	cp.w	r0,0
8000ba7e:	e0 8a 00 08 	brle	8000ba8e <_dtoa_r+0x8da>
8000ba82:	06 9b       	mov	r11,r3
8000ba84:	00 9a       	mov	r10,r0
8000ba86:	0e 9c       	mov	r12,r7
8000ba88:	e0 a0 07 58 	rcall	8000c938 <__lshift>
8000ba8c:	18 93       	mov	r3,r12
8000ba8e:	40 49       	lddsp	r9,sp[0x10]
8000ba90:	58 09       	cp.w	r9,0
8000ba92:	e0 8a 00 08 	brle	8000baa2 <_dtoa_r+0x8ee>
8000ba96:	04 9b       	mov	r11,r2
8000ba98:	12 9a       	mov	r10,r9
8000ba9a:	0e 9c       	mov	r12,r7
8000ba9c:	e0 a0 07 4e 	rcall	8000c938 <__lshift>
8000baa0:	18 92       	mov	r2,r12
8000baa2:	41 48       	lddsp	r8,sp[0x50]
8000baa4:	58 08       	cp.w	r8,0
8000baa6:	c1 b0       	breq	8000badc <_dtoa_r+0x928>
8000baa8:	04 9b       	mov	r11,r2
8000baaa:	06 9c       	mov	r12,r3
8000baac:	e0 a0 06 23 	rcall	8000c6f2 <__mcmp>
8000bab0:	c1 64       	brge	8000badc <_dtoa_r+0x928>
8000bab2:	06 9b       	mov	r11,r3
8000bab4:	30 09       	mov	r9,0
8000bab6:	30 aa       	mov	r10,10
8000bab8:	0e 9c       	mov	r12,r7
8000baba:	e0 a0 08 0b 	rcall	8000cad0 <__multadd>
8000babe:	20 16       	sub	r6,1
8000bac0:	18 93       	mov	r3,r12
8000bac2:	40 dc       	lddsp	r12,sp[0x34]
8000bac4:	58 0c       	cp.w	r12,0
8000bac6:	c0 31       	brne	8000bacc <_dtoa_r+0x918>
8000bac8:	40 91       	lddsp	r1,sp[0x24]
8000baca:	c0 98       	rjmp	8000badc <_dtoa_r+0x928>
8000bacc:	08 9b       	mov	r11,r4
8000bace:	40 91       	lddsp	r1,sp[0x24]
8000bad0:	30 09       	mov	r9,0
8000bad2:	30 aa       	mov	r10,10
8000bad4:	0e 9c       	mov	r12,r7
8000bad6:	e0 a0 07 fd 	rcall	8000cad0 <__multadd>
8000bada:	18 94       	mov	r4,r12
8000badc:	58 01       	cp.w	r1,0
8000bade:	5f a9       	srle	r9
8000bae0:	40 cb       	lddsp	r11,sp[0x30]
8000bae2:	58 2b       	cp.w	r11,2
8000bae4:	5f 98       	srgt	r8
8000bae6:	f3 e8 00 08 	and	r8,r9,r8
8000baea:	c2 50       	breq	8000bb34 <_dtoa_r+0x980>
8000baec:	58 01       	cp.w	r1,0
8000baee:	c1 11       	brne	8000bb10 <_dtoa_r+0x95c>
8000baf0:	04 9b       	mov	r11,r2
8000baf2:	02 99       	mov	r9,r1
8000baf4:	30 5a       	mov	r10,5
8000baf6:	0e 9c       	mov	r12,r7
8000baf8:	e0 a0 07 ec 	rcall	8000cad0 <__multadd>
8000bafc:	18 92       	mov	r2,r12
8000bafe:	18 9b       	mov	r11,r12
8000bb00:	06 9c       	mov	r12,r3
8000bb02:	e0 a0 05 f8 	rcall	8000c6f2 <__mcmp>
8000bb06:	e0 89 00 0f 	brgt	8000bb24 <_dtoa_r+0x970>
8000bb0a:	c0 38       	rjmp	8000bb10 <_dtoa_r+0x95c>
8000bb0c:	30 02       	mov	r2,0
8000bb0e:	04 94       	mov	r4,r2
8000bb10:	40 ea       	lddsp	r10,sp[0x38]
8000bb12:	30 09       	mov	r9,0
8000bb14:	5c da       	com	r10
8000bb16:	40 85       	lddsp	r5,sp[0x20]
8000bb18:	50 6a       	stdsp	sp[0x18],r10
8000bb1a:	50 49       	stdsp	sp[0x10],r9
8000bb1c:	c0 f9       	rjmp	8000bd3a <_dtoa_r+0xb86>
8000bb1e:	08 92       	mov	r2,r4
8000bb20:	40 66       	lddsp	r6,sp[0x18]
8000bb22:	04 94       	mov	r4,r2
8000bb24:	2f f6       	sub	r6,-1
8000bb26:	50 66       	stdsp	sp[0x18],r6
8000bb28:	33 18       	mov	r8,49
8000bb2a:	40 85       	lddsp	r5,sp[0x20]
8000bb2c:	0a c8       	st.b	r5++,r8
8000bb2e:	30 08       	mov	r8,0
8000bb30:	50 48       	stdsp	sp[0x10],r8
8000bb32:	c0 49       	rjmp	8000bd3a <_dtoa_r+0xb86>
8000bb34:	40 dc       	lddsp	r12,sp[0x34]
8000bb36:	58 0c       	cp.w	r12,0
8000bb38:	e0 80 00 b5 	breq	8000bca2 <_dtoa_r+0xaee>
8000bb3c:	58 05       	cp.w	r5,0
8000bb3e:	e0 8a 00 08 	brle	8000bb4e <_dtoa_r+0x99a>
8000bb42:	08 9b       	mov	r11,r4
8000bb44:	0a 9a       	mov	r10,r5
8000bb46:	0e 9c       	mov	r12,r7
8000bb48:	e0 a0 06 f8 	rcall	8000c938 <__lshift>
8000bb4c:	18 94       	mov	r4,r12
8000bb4e:	40 6b       	lddsp	r11,sp[0x18]
8000bb50:	58 0b       	cp.w	r11,0
8000bb52:	c0 31       	brne	8000bb58 <_dtoa_r+0x9a4>
8000bb54:	08 9c       	mov	r12,r4
8000bb56:	c1 38       	rjmp	8000bb7c <_dtoa_r+0x9c8>
8000bb58:	68 1b       	ld.w	r11,r4[0x4]
8000bb5a:	0e 9c       	mov	r12,r7
8000bb5c:	e0 a0 05 fe 	rcall	8000c758 <_Balloc>
8000bb60:	68 4a       	ld.w	r10,r4[0x10]
8000bb62:	18 95       	mov	r5,r12
8000bb64:	e8 cb ff f4 	sub	r11,r4,-12
8000bb68:	2f ea       	sub	r10,-2
8000bb6a:	2f 4c       	sub	r12,-12
8000bb6c:	a3 6a       	lsl	r10,0x2
8000bb6e:	fe b0 e6 50 	rcall	8000880e <memcpy>
8000bb72:	0a 9b       	mov	r11,r5
8000bb74:	30 1a       	mov	r10,1
8000bb76:	0e 9c       	mov	r12,r7
8000bb78:	e0 a0 06 e0 	rcall	8000c938 <__lshift>
8000bb7c:	50 44       	stdsp	sp[0x10],r4
8000bb7e:	40 3a       	lddsp	r10,sp[0xc]
8000bb80:	30 19       	mov	r9,1
8000bb82:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000bb86:	18 94       	mov	r4,r12
8000bb88:	50 da       	stdsp	sp[0x34],r10
8000bb8a:	40 85       	lddsp	r5,sp[0x20]
8000bb8c:	50 99       	stdsp	sp[0x24],r9
8000bb8e:	50 26       	stdsp	sp[0x8],r6
8000bb90:	50 e1       	stdsp	sp[0x38],r1
8000bb92:	04 9b       	mov	r11,r2
8000bb94:	06 9c       	mov	r12,r3
8000bb96:	fe b0 fa 7f 	rcall	8000b094 <quorem>
8000bb9a:	40 4b       	lddsp	r11,sp[0x10]
8000bb9c:	f8 c0 ff d0 	sub	r0,r12,-48
8000bba0:	06 9c       	mov	r12,r3
8000bba2:	e0 a0 05 a8 	rcall	8000c6f2 <__mcmp>
8000bba6:	08 9a       	mov	r10,r4
8000bba8:	50 6c       	stdsp	sp[0x18],r12
8000bbaa:	04 9b       	mov	r11,r2
8000bbac:	0e 9c       	mov	r12,r7
8000bbae:	e0 a0 06 5d 	rcall	8000c868 <__mdiff>
8000bbb2:	18 91       	mov	r1,r12
8000bbb4:	78 38       	ld.w	r8,r12[0xc]
8000bbb6:	58 08       	cp.w	r8,0
8000bbb8:	c0 30       	breq	8000bbbe <_dtoa_r+0xa0a>
8000bbba:	30 16       	mov	r6,1
8000bbbc:	c0 68       	rjmp	8000bbc8 <_dtoa_r+0xa14>
8000bbbe:	18 9b       	mov	r11,r12
8000bbc0:	06 9c       	mov	r12,r3
8000bbc2:	e0 a0 05 98 	rcall	8000c6f2 <__mcmp>
8000bbc6:	18 96       	mov	r6,r12
8000bbc8:	0e 9c       	mov	r12,r7
8000bbca:	02 9b       	mov	r11,r1
8000bbcc:	e0 a0 05 ac 	rcall	8000c724 <_Bfree>
8000bbd0:	40 cc       	lddsp	r12,sp[0x30]
8000bbd2:	ed ec 10 08 	or	r8,r6,r12
8000bbd6:	c0 d1       	brne	8000bbf0 <_dtoa_r+0xa3c>
8000bbd8:	40 db       	lddsp	r11,sp[0x34]
8000bbda:	58 0b       	cp.w	r11,0
8000bbdc:	c0 a1       	brne	8000bbf0 <_dtoa_r+0xa3c>
8000bbde:	40 26       	lddsp	r6,sp[0x8]
8000bbe0:	e0 40 00 39 	cp.w	r0,57
8000bbe4:	c3 00       	breq	8000bc44 <_dtoa_r+0xa90>
8000bbe6:	40 6a       	lddsp	r10,sp[0x18]
8000bbe8:	58 0a       	cp.w	r10,0
8000bbea:	e0 89 00 24 	brgt	8000bc32 <_dtoa_r+0xa7e>
8000bbee:	c2 f8       	rjmp	8000bc4c <_dtoa_r+0xa98>
8000bbf0:	40 69       	lddsp	r9,sp[0x18]
8000bbf2:	58 09       	cp.w	r9,0
8000bbf4:	c0 85       	brlt	8000bc04 <_dtoa_r+0xa50>
8000bbf6:	12 98       	mov	r8,r9
8000bbf8:	40 cc       	lddsp	r12,sp[0x30]
8000bbfa:	18 48       	or	r8,r12
8000bbfc:	c1 d1       	brne	8000bc36 <_dtoa_r+0xa82>
8000bbfe:	40 db       	lddsp	r11,sp[0x34]
8000bc00:	58 0b       	cp.w	r11,0
8000bc02:	c1 a1       	brne	8000bc36 <_dtoa_r+0xa82>
8000bc04:	0c 99       	mov	r9,r6
8000bc06:	40 26       	lddsp	r6,sp[0x8]
8000bc08:	58 09       	cp.w	r9,0
8000bc0a:	e0 8a 00 21 	brle	8000bc4c <_dtoa_r+0xa98>
8000bc0e:	06 9b       	mov	r11,r3
8000bc10:	30 1a       	mov	r10,1
8000bc12:	0e 9c       	mov	r12,r7
8000bc14:	e0 a0 06 92 	rcall	8000c938 <__lshift>
8000bc18:	04 9b       	mov	r11,r2
8000bc1a:	18 93       	mov	r3,r12
8000bc1c:	e0 a0 05 6b 	rcall	8000c6f2 <__mcmp>
8000bc20:	e0 89 00 06 	brgt	8000bc2c <_dtoa_r+0xa78>
8000bc24:	c1 41       	brne	8000bc4c <_dtoa_r+0xa98>
8000bc26:	ed b0 00 00 	bld	r0,0x0
8000bc2a:	c1 11       	brne	8000bc4c <_dtoa_r+0xa98>
8000bc2c:	e0 40 00 39 	cp.w	r0,57
8000bc30:	c0 a0       	breq	8000bc44 <_dtoa_r+0xa90>
8000bc32:	2f f0       	sub	r0,-1
8000bc34:	c0 c8       	rjmp	8000bc4c <_dtoa_r+0xa98>
8000bc36:	58 06       	cp.w	r6,0
8000bc38:	e0 8a 00 0c 	brle	8000bc50 <_dtoa_r+0xa9c>
8000bc3c:	40 26       	lddsp	r6,sp[0x8]
8000bc3e:	e0 40 00 39 	cp.w	r0,57
8000bc42:	c0 41       	brne	8000bc4a <_dtoa_r+0xa96>
8000bc44:	33 98       	mov	r8,57
8000bc46:	0a c8       	st.b	r5++,r8
8000bc48:	c6 78       	rjmp	8000bd16 <_dtoa_r+0xb62>
8000bc4a:	2f f0       	sub	r0,-1
8000bc4c:	0a c0       	st.b	r5++,r0
8000bc4e:	c7 58       	rjmp	8000bd38 <_dtoa_r+0xb84>
8000bc50:	0a c0       	st.b	r5++,r0
8000bc52:	40 9a       	lddsp	r10,sp[0x24]
8000bc54:	40 e9       	lddsp	r9,sp[0x38]
8000bc56:	12 3a       	cp.w	r10,r9
8000bc58:	c4 30       	breq	8000bcde <_dtoa_r+0xb2a>
8000bc5a:	06 9b       	mov	r11,r3
8000bc5c:	30 09       	mov	r9,0
8000bc5e:	30 aa       	mov	r10,10
8000bc60:	0e 9c       	mov	r12,r7
8000bc62:	e0 a0 07 37 	rcall	8000cad0 <__multadd>
8000bc66:	40 48       	lddsp	r8,sp[0x10]
8000bc68:	18 93       	mov	r3,r12
8000bc6a:	08 38       	cp.w	r8,r4
8000bc6c:	c0 91       	brne	8000bc7e <_dtoa_r+0xaca>
8000bc6e:	10 9b       	mov	r11,r8
8000bc70:	30 09       	mov	r9,0
8000bc72:	30 aa       	mov	r10,10
8000bc74:	0e 9c       	mov	r12,r7
8000bc76:	e0 a0 07 2d 	rcall	8000cad0 <__multadd>
8000bc7a:	50 4c       	stdsp	sp[0x10],r12
8000bc7c:	c0 e8       	rjmp	8000bc98 <_dtoa_r+0xae4>
8000bc7e:	40 4b       	lddsp	r11,sp[0x10]
8000bc80:	30 09       	mov	r9,0
8000bc82:	30 aa       	mov	r10,10
8000bc84:	0e 9c       	mov	r12,r7
8000bc86:	e0 a0 07 25 	rcall	8000cad0 <__multadd>
8000bc8a:	08 9b       	mov	r11,r4
8000bc8c:	50 4c       	stdsp	sp[0x10],r12
8000bc8e:	30 09       	mov	r9,0
8000bc90:	30 aa       	mov	r10,10
8000bc92:	0e 9c       	mov	r12,r7
8000bc94:	e0 a0 07 1e 	rcall	8000cad0 <__multadd>
8000bc98:	18 94       	mov	r4,r12
8000bc9a:	40 9c       	lddsp	r12,sp[0x24]
8000bc9c:	2f fc       	sub	r12,-1
8000bc9e:	50 9c       	stdsp	sp[0x24],r12
8000bca0:	c7 9b       	rjmp	8000bb92 <_dtoa_r+0x9de>
8000bca2:	30 18       	mov	r8,1
8000bca4:	06 90       	mov	r0,r3
8000bca6:	40 85       	lddsp	r5,sp[0x20]
8000bca8:	08 93       	mov	r3,r4
8000bcaa:	0c 94       	mov	r4,r6
8000bcac:	10 96       	mov	r6,r8
8000bcae:	04 9b       	mov	r11,r2
8000bcb0:	00 9c       	mov	r12,r0
8000bcb2:	fe b0 f9 f1 	rcall	8000b094 <quorem>
8000bcb6:	2d 0c       	sub	r12,-48
8000bcb8:	0a cc       	st.b	r5++,r12
8000bcba:	02 36       	cp.w	r6,r1
8000bcbc:	c0 a4       	brge	8000bcd0 <_dtoa_r+0xb1c>
8000bcbe:	00 9b       	mov	r11,r0
8000bcc0:	30 09       	mov	r9,0
8000bcc2:	30 aa       	mov	r10,10
8000bcc4:	0e 9c       	mov	r12,r7
8000bcc6:	2f f6       	sub	r6,-1
8000bcc8:	e0 a0 07 04 	rcall	8000cad0 <__multadd>
8000bccc:	18 90       	mov	r0,r12
8000bcce:	cf 0b       	rjmp	8000bcae <_dtoa_r+0xafa>
8000bcd0:	08 96       	mov	r6,r4
8000bcd2:	30 0b       	mov	r11,0
8000bcd4:	06 94       	mov	r4,r3
8000bcd6:	50 4b       	stdsp	sp[0x10],r11
8000bcd8:	00 93       	mov	r3,r0
8000bcda:	18 90       	mov	r0,r12
8000bcdc:	c0 28       	rjmp	8000bce0 <_dtoa_r+0xb2c>
8000bcde:	40 26       	lddsp	r6,sp[0x8]
8000bce0:	06 9b       	mov	r11,r3
8000bce2:	30 1a       	mov	r10,1
8000bce4:	0e 9c       	mov	r12,r7
8000bce6:	e0 a0 06 29 	rcall	8000c938 <__lshift>
8000bcea:	04 9b       	mov	r11,r2
8000bcec:	18 93       	mov	r3,r12
8000bcee:	e0 a0 05 02 	rcall	8000c6f2 <__mcmp>
8000bcf2:	e0 89 00 12 	brgt	8000bd16 <_dtoa_r+0xb62>
8000bcf6:	c1 b1       	brne	8000bd2c <_dtoa_r+0xb78>
8000bcf8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bcfc:	c0 d1       	brne	8000bd16 <_dtoa_r+0xb62>
8000bcfe:	c1 78       	rjmp	8000bd2c <_dtoa_r+0xb78>
8000bd00:	40 89       	lddsp	r9,sp[0x20]
8000bd02:	12 38       	cp.w	r8,r9
8000bd04:	c0 30       	breq	8000bd0a <_dtoa_r+0xb56>
8000bd06:	10 95       	mov	r5,r8
8000bd08:	c0 88       	rjmp	8000bd18 <_dtoa_r+0xb64>
8000bd0a:	2f f6       	sub	r6,-1
8000bd0c:	50 66       	stdsp	sp[0x18],r6
8000bd0e:	33 18       	mov	r8,49
8000bd10:	40 8c       	lddsp	r12,sp[0x20]
8000bd12:	b8 88       	st.b	r12[0x0],r8
8000bd14:	c1 38       	rjmp	8000bd3a <_dtoa_r+0xb86>
8000bd16:	33 9a       	mov	r10,57
8000bd18:	0a 98       	mov	r8,r5
8000bd1a:	11 79       	ld.ub	r9,--r8
8000bd1c:	f4 09 18 00 	cp.b	r9,r10
8000bd20:	cf 00       	breq	8000bd00 <_dtoa_r+0xb4c>
8000bd22:	2f f9       	sub	r9,-1
8000bd24:	b0 89       	st.b	r8[0x0],r9
8000bd26:	c0 98       	rjmp	8000bd38 <_dtoa_r+0xb84>
8000bd28:	10 95       	mov	r5,r8
8000bd2a:	c0 28       	rjmp	8000bd2e <_dtoa_r+0xb7a>
8000bd2c:	33 09       	mov	r9,48
8000bd2e:	0a 98       	mov	r8,r5
8000bd30:	11 7a       	ld.ub	r10,--r8
8000bd32:	f2 0a 18 00 	cp.b	r10,r9
8000bd36:	cf 90       	breq	8000bd28 <_dtoa_r+0xb74>
8000bd38:	50 66       	stdsp	sp[0x18],r6
8000bd3a:	04 9b       	mov	r11,r2
8000bd3c:	0e 9c       	mov	r12,r7
8000bd3e:	e0 a0 04 f3 	rcall	8000c724 <_Bfree>
8000bd42:	58 04       	cp.w	r4,0
8000bd44:	c1 20       	breq	8000bd68 <_dtoa_r+0xbb4>
8000bd46:	40 4b       	lddsp	r11,sp[0x10]
8000bd48:	08 3b       	cp.w	r11,r4
8000bd4a:	5f 19       	srne	r9
8000bd4c:	58 0b       	cp.w	r11,0
8000bd4e:	5f 18       	srne	r8
8000bd50:	f3 e8 00 08 	and	r8,r9,r8
8000bd54:	c0 40       	breq	8000bd5c <_dtoa_r+0xba8>
8000bd56:	0e 9c       	mov	r12,r7
8000bd58:	e0 a0 04 e6 	rcall	8000c724 <_Bfree>
8000bd5c:	08 9b       	mov	r11,r4
8000bd5e:	0e 9c       	mov	r12,r7
8000bd60:	e0 a0 04 e2 	rcall	8000c724 <_Bfree>
8000bd64:	c0 28       	rjmp	8000bd68 <_dtoa_r+0xbb4>
8000bd66:	50 66       	stdsp	sp[0x18],r6
8000bd68:	0e 9c       	mov	r12,r7
8000bd6a:	06 9b       	mov	r11,r3
8000bd6c:	e0 a0 04 dc 	rcall	8000c724 <_Bfree>
8000bd70:	30 08       	mov	r8,0
8000bd72:	aa 88       	st.b	r5[0x0],r8
8000bd74:	40 68       	lddsp	r8,sp[0x18]
8000bd76:	41 5a       	lddsp	r10,sp[0x54]
8000bd78:	2f f8       	sub	r8,-1
8000bd7a:	41 29       	lddsp	r9,sp[0x48]
8000bd7c:	95 08       	st.w	r10[0x0],r8
8000bd7e:	40 8c       	lddsp	r12,sp[0x20]
8000bd80:	58 09       	cp.w	r9,0
8000bd82:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bd86:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bd8a:	2e 6d       	sub	sp,-104
8000bd8c:	d8 32       	popm	r0-r7,pc
8000bd8e:	d7 03       	nop

8000bd90 <__errno>:
8000bd90:	e0 68 0a 54 	mov	r8,2644
8000bd94:	70 0c       	ld.w	r12,r8[0x0]
8000bd96:	2f 4c       	sub	r12,-12
8000bd98:	5e fc       	retal	r12
8000bd9a:	d7 03       	nop

8000bd9c <_fflush_r>:
8000bd9c:	d4 21       	pushm	r4-r7,lr
8000bd9e:	16 97       	mov	r7,r11
8000bda0:	18 96       	mov	r6,r12
8000bda2:	76 48       	ld.w	r8,r11[0x10]
8000bda4:	58 08       	cp.w	r8,0
8000bda6:	c7 f0       	breq	8000bea4 <_fflush_r+0x108>
8000bda8:	58 0c       	cp.w	r12,0
8000bdaa:	c0 50       	breq	8000bdb4 <_fflush_r+0x18>
8000bdac:	78 68       	ld.w	r8,r12[0x18]
8000bdae:	58 08       	cp.w	r8,0
8000bdb0:	c0 21       	brne	8000bdb4 <_fflush_r+0x18>
8000bdb2:	cc dc       	rcall	8000bf4c <__sinit>
8000bdb4:	fe c8 c9 30 	sub	r8,pc,-14032
8000bdb8:	10 37       	cp.w	r7,r8
8000bdba:	c0 31       	brne	8000bdc0 <_fflush_r+0x24>
8000bdbc:	6c 07       	ld.w	r7,r6[0x0]
8000bdbe:	c0 c8       	rjmp	8000bdd6 <_fflush_r+0x3a>
8000bdc0:	fe c8 c9 1c 	sub	r8,pc,-14052
8000bdc4:	10 37       	cp.w	r7,r8
8000bdc6:	c0 31       	brne	8000bdcc <_fflush_r+0x30>
8000bdc8:	6c 17       	ld.w	r7,r6[0x4]
8000bdca:	c0 68       	rjmp	8000bdd6 <_fflush_r+0x3a>
8000bdcc:	fe c8 c9 08 	sub	r8,pc,-14072
8000bdd0:	10 37       	cp.w	r7,r8
8000bdd2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdd6:	8e 6a       	ld.sh	r10,r7[0xc]
8000bdd8:	14 98       	mov	r8,r10
8000bdda:	ed ba 00 03 	bld	r10,0x3
8000bdde:	c4 20       	breq	8000be62 <_fflush_r+0xc6>
8000bde0:	ab ba       	sbr	r10,0xb
8000bde2:	ae 6a       	st.h	r7[0xc],r10
8000bde4:	6e 18       	ld.w	r8,r7[0x4]
8000bde6:	58 08       	cp.w	r8,0
8000bde8:	e0 89 00 06 	brgt	8000bdf4 <_fflush_r+0x58>
8000bdec:	6f 08       	ld.w	r8,r7[0x40]
8000bdee:	58 08       	cp.w	r8,0
8000bdf0:	e0 8a 00 5a 	brle	8000bea4 <_fflush_r+0x108>
8000bdf4:	6e b8       	ld.w	r8,r7[0x2c]
8000bdf6:	58 08       	cp.w	r8,0
8000bdf8:	c5 60       	breq	8000bea4 <_fflush_r+0x108>
8000bdfa:	e2 1a 10 00 	andl	r10,0x1000,COH
8000bdfe:	c0 30       	breq	8000be04 <_fflush_r+0x68>
8000be00:	6f 55       	ld.w	r5,r7[0x54]
8000be02:	c0 f8       	rjmp	8000be20 <_fflush_r+0x84>
8000be04:	30 19       	mov	r9,1
8000be06:	6e 8b       	ld.w	r11,r7[0x20]
8000be08:	0c 9c       	mov	r12,r6
8000be0a:	5d 18       	icall	r8
8000be0c:	18 95       	mov	r5,r12
8000be0e:	5b fc       	cp.w	r12,-1
8000be10:	c0 81       	brne	8000be20 <_fflush_r+0x84>
8000be12:	6c 38       	ld.w	r8,r6[0xc]
8000be14:	59 d8       	cp.w	r8,29
8000be16:	c4 70       	breq	8000bea4 <_fflush_r+0x108>
8000be18:	8e 68       	ld.sh	r8,r7[0xc]
8000be1a:	a7 a8       	sbr	r8,0x6
8000be1c:	ae 68       	st.h	r7[0xc],r8
8000be1e:	d8 22       	popm	r4-r7,pc
8000be20:	8e 68       	ld.sh	r8,r7[0xc]
8000be22:	ed b8 00 02 	bld	r8,0x2
8000be26:	c0 91       	brne	8000be38 <_fflush_r+0x9c>
8000be28:	6e 18       	ld.w	r8,r7[0x4]
8000be2a:	10 15       	sub	r5,r8
8000be2c:	6e d8       	ld.w	r8,r7[0x34]
8000be2e:	58 08       	cp.w	r8,0
8000be30:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000be34:	eb d8 e1 15 	subne	r5,r5,r8
8000be38:	6e b8       	ld.w	r8,r7[0x2c]
8000be3a:	0c 9c       	mov	r12,r6
8000be3c:	30 09       	mov	r9,0
8000be3e:	0a 9a       	mov	r10,r5
8000be40:	6e 8b       	ld.w	r11,r7[0x20]
8000be42:	5d 18       	icall	r8
8000be44:	8e 68       	ld.sh	r8,r7[0xc]
8000be46:	0a 3c       	cp.w	r12,r5
8000be48:	c2 61       	brne	8000be94 <_fflush_r+0xf8>
8000be4a:	ab d8       	cbr	r8,0xb
8000be4c:	30 0c       	mov	r12,0
8000be4e:	6e 49       	ld.w	r9,r7[0x10]
8000be50:	ae 68       	st.h	r7[0xc],r8
8000be52:	8f 1c       	st.w	r7[0x4],r12
8000be54:	8f 09       	st.w	r7[0x0],r9
8000be56:	ed b8 00 0c 	bld	r8,0xc
8000be5a:	c2 51       	brne	8000bea4 <_fflush_r+0x108>
8000be5c:	ef 45 00 54 	st.w	r7[84],r5
8000be60:	d8 22       	popm	r4-r7,pc
8000be62:	6e 45       	ld.w	r5,r7[0x10]
8000be64:	58 05       	cp.w	r5,0
8000be66:	c1 f0       	breq	8000bea4 <_fflush_r+0x108>
8000be68:	6e 04       	ld.w	r4,r7[0x0]
8000be6a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000be6e:	8f 05       	st.w	r7[0x0],r5
8000be70:	f9 b8 01 00 	movne	r8,0
8000be74:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000be78:	0a 14       	sub	r4,r5
8000be7a:	8f 28       	st.w	r7[0x8],r8
8000be7c:	c1 18       	rjmp	8000be9e <_fflush_r+0x102>
8000be7e:	08 99       	mov	r9,r4
8000be80:	0a 9a       	mov	r10,r5
8000be82:	6e a8       	ld.w	r8,r7[0x28]
8000be84:	6e 8b       	ld.w	r11,r7[0x20]
8000be86:	0c 9c       	mov	r12,r6
8000be88:	5d 18       	icall	r8
8000be8a:	18 14       	sub	r4,r12
8000be8c:	58 0c       	cp.w	r12,0
8000be8e:	e0 89 00 07 	brgt	8000be9c <_fflush_r+0x100>
8000be92:	8e 68       	ld.sh	r8,r7[0xc]
8000be94:	a7 a8       	sbr	r8,0x6
8000be96:	3f fc       	mov	r12,-1
8000be98:	ae 68       	st.h	r7[0xc],r8
8000be9a:	d8 22       	popm	r4-r7,pc
8000be9c:	18 05       	add	r5,r12
8000be9e:	58 04       	cp.w	r4,0
8000bea0:	fe 99 ff ef 	brgt	8000be7e <_fflush_r+0xe2>
8000bea4:	d8 2a       	popm	r4-r7,pc,r12=0
8000bea6:	d7 03       	nop

8000bea8 <__sfp_lock_acquire>:
8000bea8:	5e fc       	retal	r12

8000beaa <__sfp_lock_release>:
8000beaa:	5e fc       	retal	r12

8000beac <_cleanup_r>:
8000beac:	d4 01       	pushm	lr
8000beae:	fe cb f0 ae 	sub	r11,pc,-3922
8000beb2:	e0 a0 02 f7 	rcall	8000c4a0 <_fwalk>
8000beb6:	d8 02       	popm	pc

8000beb8 <__sfmoreglue>:
8000beb8:	d4 21       	pushm	r4-r7,lr
8000beba:	16 95       	mov	r5,r11
8000bebc:	f6 06 10 5c 	mul	r6,r11,92
8000bec0:	ec cb ff f4 	sub	r11,r6,-12
8000bec4:	fe b0 e2 76 	rcall	800083b0 <_malloc_r>
8000bec8:	18 97       	mov	r7,r12
8000beca:	c0 90       	breq	8000bedc <__sfmoreglue+0x24>
8000becc:	99 15       	st.w	r12[0x4],r5
8000bece:	30 0b       	mov	r11,0
8000bed0:	2f 4c       	sub	r12,-12
8000bed2:	0c 9a       	mov	r10,r6
8000bed4:	8f 2c       	st.w	r7[0x8],r12
8000bed6:	8f 0b       	st.w	r7[0x0],r11
8000bed8:	fe b0 e5 3f 	rcall	80008956 <memset>
8000bedc:	0e 9c       	mov	r12,r7
8000bede:	d8 22       	popm	r4-r7,pc

8000bee0 <__sfp>:
8000bee0:	d4 21       	pushm	r4-r7,lr
8000bee2:	fe c8 c9 fa 	sub	r8,pc,-13830
8000bee6:	18 96       	mov	r6,r12
8000bee8:	70 07       	ld.w	r7,r8[0x0]
8000beea:	6e 68       	ld.w	r8,r7[0x18]
8000beec:	58 08       	cp.w	r8,0
8000beee:	c0 31       	brne	8000bef4 <__sfp+0x14>
8000bef0:	0e 9c       	mov	r12,r7
8000bef2:	c2 dc       	rcall	8000bf4c <__sinit>
8000bef4:	ee c7 ff 28 	sub	r7,r7,-216
8000bef8:	30 05       	mov	r5,0
8000befa:	6e 2c       	ld.w	r12,r7[0x8]
8000befc:	6e 18       	ld.w	r8,r7[0x4]
8000befe:	c0 68       	rjmp	8000bf0a <__sfp+0x2a>
8000bf00:	98 69       	ld.sh	r9,r12[0xc]
8000bf02:	ea 09 19 00 	cp.h	r9,r5
8000bf06:	c1 10       	breq	8000bf28 <__sfp+0x48>
8000bf08:	2a 4c       	sub	r12,-92
8000bf0a:	20 18       	sub	r8,1
8000bf0c:	cf a7       	brpl	8000bf00 <__sfp+0x20>
8000bf0e:	6e 08       	ld.w	r8,r7[0x0]
8000bf10:	58 08       	cp.w	r8,0
8000bf12:	c0 61       	brne	8000bf1e <__sfp+0x3e>
8000bf14:	30 4b       	mov	r11,4
8000bf16:	0c 9c       	mov	r12,r6
8000bf18:	cd 0f       	rcall	8000beb8 <__sfmoreglue>
8000bf1a:	8f 0c       	st.w	r7[0x0],r12
8000bf1c:	c0 30       	breq	8000bf22 <__sfp+0x42>
8000bf1e:	6e 07       	ld.w	r7,r7[0x0]
8000bf20:	ce db       	rjmp	8000befa <__sfp+0x1a>
8000bf22:	30 c8       	mov	r8,12
8000bf24:	8d 38       	st.w	r6[0xc],r8
8000bf26:	d8 22       	popm	r4-r7,pc
8000bf28:	30 08       	mov	r8,0
8000bf2a:	f9 48 00 4c 	st.w	r12[76],r8
8000bf2e:	99 08       	st.w	r12[0x0],r8
8000bf30:	99 28       	st.w	r12[0x8],r8
8000bf32:	99 18       	st.w	r12[0x4],r8
8000bf34:	99 48       	st.w	r12[0x10],r8
8000bf36:	99 58       	st.w	r12[0x14],r8
8000bf38:	99 68       	st.w	r12[0x18],r8
8000bf3a:	99 d8       	st.w	r12[0x34],r8
8000bf3c:	99 e8       	st.w	r12[0x38],r8
8000bf3e:	f9 48 00 48 	st.w	r12[72],r8
8000bf42:	3f f8       	mov	r8,-1
8000bf44:	b8 78       	st.h	r12[0xe],r8
8000bf46:	30 18       	mov	r8,1
8000bf48:	b8 68       	st.h	r12[0xc],r8
8000bf4a:	d8 22       	popm	r4-r7,pc

8000bf4c <__sinit>:
8000bf4c:	d4 21       	pushm	r4-r7,lr
8000bf4e:	18 96       	mov	r6,r12
8000bf50:	78 67       	ld.w	r7,r12[0x18]
8000bf52:	58 07       	cp.w	r7,0
8000bf54:	c4 91       	brne	8000bfe6 <__sinit+0x9a>
8000bf56:	fe c8 00 aa 	sub	r8,pc,170
8000bf5a:	30 15       	mov	r5,1
8000bf5c:	99 a8       	st.w	r12[0x28],r8
8000bf5e:	f9 47 00 d8 	st.w	r12[216],r7
8000bf62:	f9 47 00 dc 	st.w	r12[220],r7
8000bf66:	f9 47 00 e0 	st.w	r12[224],r7
8000bf6a:	99 65       	st.w	r12[0x18],r5
8000bf6c:	cb af       	rcall	8000bee0 <__sfp>
8000bf6e:	8d 0c       	st.w	r6[0x0],r12
8000bf70:	0c 9c       	mov	r12,r6
8000bf72:	cb 7f       	rcall	8000bee0 <__sfp>
8000bf74:	8d 1c       	st.w	r6[0x4],r12
8000bf76:	0c 9c       	mov	r12,r6
8000bf78:	cb 4f       	rcall	8000bee0 <__sfp>
8000bf7a:	6c 09       	ld.w	r9,r6[0x0]
8000bf7c:	30 48       	mov	r8,4
8000bf7e:	93 07       	st.w	r9[0x0],r7
8000bf80:	b2 68       	st.h	r9[0xc],r8
8000bf82:	93 17       	st.w	r9[0x4],r7
8000bf84:	93 27       	st.w	r9[0x8],r7
8000bf86:	6c 18       	ld.w	r8,r6[0x4]
8000bf88:	b2 77       	st.h	r9[0xe],r7
8000bf8a:	93 47       	st.w	r9[0x10],r7
8000bf8c:	93 57       	st.w	r9[0x14],r7
8000bf8e:	93 67       	st.w	r9[0x18],r7
8000bf90:	93 89       	st.w	r9[0x20],r9
8000bf92:	91 07       	st.w	r8[0x0],r7
8000bf94:	91 17       	st.w	r8[0x4],r7
8000bf96:	91 27       	st.w	r8[0x8],r7
8000bf98:	fe ce f3 24 	sub	lr,pc,-3292
8000bf9c:	fe cb f3 54 	sub	r11,pc,-3244
8000bfa0:	93 9e       	st.w	r9[0x24],lr
8000bfa2:	93 ab       	st.w	r9[0x28],r11
8000bfa4:	fe ca f3 7c 	sub	r10,pc,-3204
8000bfa8:	fe c4 f3 88 	sub	r4,pc,-3192
8000bfac:	93 ba       	st.w	r9[0x2c],r10
8000bfae:	93 c4       	st.w	r9[0x30],r4
8000bfb0:	30 99       	mov	r9,9
8000bfb2:	b0 69       	st.h	r8[0xc],r9
8000bfb4:	b0 75       	st.h	r8[0xe],r5
8000bfb6:	91 c4       	st.w	r8[0x30],r4
8000bfb8:	91 47       	st.w	r8[0x10],r7
8000bfba:	91 57       	st.w	r8[0x14],r7
8000bfbc:	91 67       	st.w	r8[0x18],r7
8000bfbe:	91 88       	st.w	r8[0x20],r8
8000bfc0:	91 9e       	st.w	r8[0x24],lr
8000bfc2:	91 ab       	st.w	r8[0x28],r11
8000bfc4:	91 ba       	st.w	r8[0x2c],r10
8000bfc6:	8d 2c       	st.w	r6[0x8],r12
8000bfc8:	31 28       	mov	r8,18
8000bfca:	99 07       	st.w	r12[0x0],r7
8000bfcc:	b8 68       	st.h	r12[0xc],r8
8000bfce:	99 17       	st.w	r12[0x4],r7
8000bfd0:	99 27       	st.w	r12[0x8],r7
8000bfd2:	30 28       	mov	r8,2
8000bfd4:	b8 78       	st.h	r12[0xe],r8
8000bfd6:	99 c4       	st.w	r12[0x30],r4
8000bfd8:	99 67       	st.w	r12[0x18],r7
8000bfda:	99 9e       	st.w	r12[0x24],lr
8000bfdc:	99 ab       	st.w	r12[0x28],r11
8000bfde:	99 ba       	st.w	r12[0x2c],r10
8000bfe0:	99 47       	st.w	r12[0x10],r7
8000bfe2:	99 57       	st.w	r12[0x14],r7
8000bfe4:	99 8c       	st.w	r12[0x20],r12
8000bfe6:	d8 22       	popm	r4-r7,pc

8000bfe8 <_malloc_trim_r>:
8000bfe8:	d4 21       	pushm	r4-r7,lr
8000bfea:	16 95       	mov	r5,r11
8000bfec:	18 97       	mov	r7,r12
8000bfee:	fe b0 d7 97 	rcall	80006f1c <__malloc_lock>
8000bff2:	e0 64 05 54 	mov	r4,1364
8000bff6:	68 28       	ld.w	r8,r4[0x8]
8000bff8:	70 16       	ld.w	r6,r8[0x4]
8000bffa:	e0 16 ff fc 	andl	r6,0xfffc
8000bffe:	ec c8 ff 91 	sub	r8,r6,-111
8000c002:	f0 05 01 05 	sub	r5,r8,r5
8000c006:	e0 15 ff 80 	andl	r5,0xff80
8000c00a:	ea c5 00 80 	sub	r5,r5,128
8000c00e:	e0 45 00 7f 	cp.w	r5,127
8000c012:	e0 8a 00 25 	brle	8000c05c <_malloc_trim_r+0x74>
8000c016:	30 0b       	mov	r11,0
8000c018:	0e 9c       	mov	r12,r7
8000c01a:	fe b0 e6 05 	rcall	80008c24 <_sbrk_r>
8000c01e:	68 28       	ld.w	r8,r4[0x8]
8000c020:	0c 08       	add	r8,r6
8000c022:	10 3c       	cp.w	r12,r8
8000c024:	c1 c1       	brne	8000c05c <_malloc_trim_r+0x74>
8000c026:	ea 0b 11 00 	rsub	r11,r5,0
8000c02a:	0e 9c       	mov	r12,r7
8000c02c:	fe b0 e5 fc 	rcall	80008c24 <_sbrk_r>
8000c030:	5b fc       	cp.w	r12,-1
8000c032:	c1 91       	brne	8000c064 <_malloc_trim_r+0x7c>
8000c034:	30 0b       	mov	r11,0
8000c036:	0e 9c       	mov	r12,r7
8000c038:	fe b0 e5 f6 	rcall	80008c24 <_sbrk_r>
8000c03c:	68 28       	ld.w	r8,r4[0x8]
8000c03e:	f8 08 01 09 	sub	r9,r12,r8
8000c042:	58 f9       	cp.w	r9,15
8000c044:	e0 8a 00 0c 	brle	8000c05c <_malloc_trim_r+0x74>
8000c048:	a1 a9       	sbr	r9,0x0
8000c04a:	91 19       	st.w	r8[0x4],r9
8000c04c:	e0 68 09 60 	mov	r8,2400
8000c050:	70 09       	ld.w	r9,r8[0x0]
8000c052:	e0 68 0d f0 	mov	r8,3568
8000c056:	f8 09 01 09 	sub	r9,r12,r9
8000c05a:	91 09       	st.w	r8[0x0],r9
8000c05c:	0e 9c       	mov	r12,r7
8000c05e:	fe b0 d7 65 	rcall	80006f28 <__malloc_unlock>
8000c062:	d8 2a       	popm	r4-r7,pc,r12=0
8000c064:	68 28       	ld.w	r8,r4[0x8]
8000c066:	0a 16       	sub	r6,r5
8000c068:	a1 a6       	sbr	r6,0x0
8000c06a:	91 16       	st.w	r8[0x4],r6
8000c06c:	e0 68 0d f0 	mov	r8,3568
8000c070:	70 09       	ld.w	r9,r8[0x0]
8000c072:	0a 19       	sub	r9,r5
8000c074:	0e 9c       	mov	r12,r7
8000c076:	91 09       	st.w	r8[0x0],r9
8000c078:	fe b0 d7 58 	rcall	80006f28 <__malloc_unlock>
8000c07c:	da 2a       	popm	r4-r7,pc,r12=1
8000c07e:	d7 03       	nop

8000c080 <_free_r>:
8000c080:	d4 21       	pushm	r4-r7,lr
8000c082:	16 96       	mov	r6,r11
8000c084:	18 97       	mov	r7,r12
8000c086:	58 0b       	cp.w	r11,0
8000c088:	e0 80 00 c0 	breq	8000c208 <_free_r+0x188>
8000c08c:	fe b0 d7 48 	rcall	80006f1c <__malloc_lock>
8000c090:	20 86       	sub	r6,8
8000c092:	e0 6a 05 54 	mov	r10,1364
8000c096:	6c 18       	ld.w	r8,r6[0x4]
8000c098:	74 2e       	ld.w	lr,r10[0x8]
8000c09a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000c09e:	a1 c8       	cbr	r8,0x0
8000c0a0:	ec 08 00 09 	add	r9,r6,r8
8000c0a4:	72 1b       	ld.w	r11,r9[0x4]
8000c0a6:	e0 1b ff fc 	andl	r11,0xfffc
8000c0aa:	1c 39       	cp.w	r9,lr
8000c0ac:	c1 e1       	brne	8000c0e8 <_free_r+0x68>
8000c0ae:	f6 08 00 08 	add	r8,r11,r8
8000c0b2:	58 0c       	cp.w	r12,0
8000c0b4:	c0 81       	brne	8000c0c4 <_free_r+0x44>
8000c0b6:	6c 09       	ld.w	r9,r6[0x0]
8000c0b8:	12 16       	sub	r6,r9
8000c0ba:	12 08       	add	r8,r9
8000c0bc:	6c 3b       	ld.w	r11,r6[0xc]
8000c0be:	6c 29       	ld.w	r9,r6[0x8]
8000c0c0:	97 29       	st.w	r11[0x8],r9
8000c0c2:	93 3b       	st.w	r9[0xc],r11
8000c0c4:	10 99       	mov	r9,r8
8000c0c6:	95 26       	st.w	r10[0x8],r6
8000c0c8:	a1 a9       	sbr	r9,0x0
8000c0ca:	8d 19       	st.w	r6[0x4],r9
8000c0cc:	e0 69 09 5c 	mov	r9,2396
8000c0d0:	72 09       	ld.w	r9,r9[0x0]
8000c0d2:	12 38       	cp.w	r8,r9
8000c0d4:	c0 63       	brcs	8000c0e0 <_free_r+0x60>
8000c0d6:	e0 68 0d ec 	mov	r8,3564
8000c0da:	0e 9c       	mov	r12,r7
8000c0dc:	70 0b       	ld.w	r11,r8[0x0]
8000c0de:	c8 5f       	rcall	8000bfe8 <_malloc_trim_r>
8000c0e0:	0e 9c       	mov	r12,r7
8000c0e2:	fe b0 d7 23 	rcall	80006f28 <__malloc_unlock>
8000c0e6:	d8 22       	popm	r4-r7,pc
8000c0e8:	93 1b       	st.w	r9[0x4],r11
8000c0ea:	58 0c       	cp.w	r12,0
8000c0ec:	c0 30       	breq	8000c0f2 <_free_r+0x72>
8000c0ee:	30 0c       	mov	r12,0
8000c0f0:	c1 08       	rjmp	8000c110 <_free_r+0x90>
8000c0f2:	6c 0e       	ld.w	lr,r6[0x0]
8000c0f4:	f4 c5 ff f8 	sub	r5,r10,-8
8000c0f8:	1c 16       	sub	r6,lr
8000c0fa:	1c 08       	add	r8,lr
8000c0fc:	6c 2e       	ld.w	lr,r6[0x8]
8000c0fe:	0a 3e       	cp.w	lr,r5
8000c100:	f9 bc 00 01 	moveq	r12,1
8000c104:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000c108:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000c10c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000c110:	f2 0b 00 0e 	add	lr,r9,r11
8000c114:	7c 1e       	ld.w	lr,lr[0x4]
8000c116:	ed be 00 00 	bld	lr,0x0
8000c11a:	c1 40       	breq	8000c142 <_free_r+0xc2>
8000c11c:	16 08       	add	r8,r11
8000c11e:	58 0c       	cp.w	r12,0
8000c120:	c0 d1       	brne	8000c13a <_free_r+0xba>
8000c122:	e0 6e 05 54 	mov	lr,1364
8000c126:	72 2b       	ld.w	r11,r9[0x8]
8000c128:	2f 8e       	sub	lr,-8
8000c12a:	1c 3b       	cp.w	r11,lr
8000c12c:	c0 71       	brne	8000c13a <_free_r+0xba>
8000c12e:	97 36       	st.w	r11[0xc],r6
8000c130:	97 26       	st.w	r11[0x8],r6
8000c132:	8d 2b       	st.w	r6[0x8],r11
8000c134:	8d 3b       	st.w	r6[0xc],r11
8000c136:	30 1c       	mov	r12,1
8000c138:	c0 58       	rjmp	8000c142 <_free_r+0xc2>
8000c13a:	72 2b       	ld.w	r11,r9[0x8]
8000c13c:	72 39       	ld.w	r9,r9[0xc]
8000c13e:	93 2b       	st.w	r9[0x8],r11
8000c140:	97 39       	st.w	r11[0xc],r9
8000c142:	10 99       	mov	r9,r8
8000c144:	ec 08 09 08 	st.w	r6[r8],r8
8000c148:	a1 a9       	sbr	r9,0x0
8000c14a:	8d 19       	st.w	r6[0x4],r9
8000c14c:	58 0c       	cp.w	r12,0
8000c14e:	c5 a1       	brne	8000c202 <_free_r+0x182>
8000c150:	e0 48 01 ff 	cp.w	r8,511
8000c154:	e0 8b 00 13 	brhi	8000c17a <_free_r+0xfa>
8000c158:	a3 98       	lsr	r8,0x3
8000c15a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c15e:	72 2b       	ld.w	r11,r9[0x8]
8000c160:	8d 39       	st.w	r6[0xc],r9
8000c162:	8d 2b       	st.w	r6[0x8],r11
8000c164:	97 36       	st.w	r11[0xc],r6
8000c166:	93 26       	st.w	r9[0x8],r6
8000c168:	a3 48       	asr	r8,0x2
8000c16a:	74 19       	ld.w	r9,r10[0x4]
8000c16c:	30 1b       	mov	r11,1
8000c16e:	f6 08 09 48 	lsl	r8,r11,r8
8000c172:	f3 e8 10 08 	or	r8,r9,r8
8000c176:	95 18       	st.w	r10[0x4],r8
8000c178:	c4 58       	rjmp	8000c202 <_free_r+0x182>
8000c17a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000c17e:	58 4b       	cp.w	r11,4
8000c180:	e0 8b 00 06 	brhi	8000c18c <_free_r+0x10c>
8000c184:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c188:	2c 8b       	sub	r11,-56
8000c18a:	c2 08       	rjmp	8000c1ca <_free_r+0x14a>
8000c18c:	59 4b       	cp.w	r11,20
8000c18e:	e0 8b 00 04 	brhi	8000c196 <_free_r+0x116>
8000c192:	2a 5b       	sub	r11,-91
8000c194:	c1 b8       	rjmp	8000c1ca <_free_r+0x14a>
8000c196:	e0 4b 00 54 	cp.w	r11,84
8000c19a:	e0 8b 00 06 	brhi	8000c1a6 <_free_r+0x126>
8000c19e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c1a2:	29 2b       	sub	r11,-110
8000c1a4:	c1 38       	rjmp	8000c1ca <_free_r+0x14a>
8000c1a6:	e0 4b 01 54 	cp.w	r11,340
8000c1aa:	e0 8b 00 06 	brhi	8000c1b6 <_free_r+0x136>
8000c1ae:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c1b2:	28 9b       	sub	r11,-119
8000c1b4:	c0 b8       	rjmp	8000c1ca <_free_r+0x14a>
8000c1b6:	e0 4b 05 54 	cp.w	r11,1364
8000c1ba:	e0 88 00 05 	brls	8000c1c4 <_free_r+0x144>
8000c1be:	37 eb       	mov	r11,126
8000c1c0:	c0 58       	rjmp	8000c1ca <_free_r+0x14a>
8000c1c2:	d7 03       	nop
8000c1c4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c1c8:	28 4b       	sub	r11,-124
8000c1ca:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c1ce:	78 29       	ld.w	r9,r12[0x8]
8000c1d0:	18 39       	cp.w	r9,r12
8000c1d2:	c0 e1       	brne	8000c1ee <_free_r+0x16e>
8000c1d4:	74 18       	ld.w	r8,r10[0x4]
8000c1d6:	a3 4b       	asr	r11,0x2
8000c1d8:	30 1c       	mov	r12,1
8000c1da:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c1de:	f1 eb 10 0b 	or	r11,r8,r11
8000c1e2:	12 98       	mov	r8,r9
8000c1e4:	95 1b       	st.w	r10[0x4],r11
8000c1e6:	c0 a8       	rjmp	8000c1fa <_free_r+0x17a>
8000c1e8:	72 29       	ld.w	r9,r9[0x8]
8000c1ea:	18 39       	cp.w	r9,r12
8000c1ec:	c0 60       	breq	8000c1f8 <_free_r+0x178>
8000c1ee:	72 1a       	ld.w	r10,r9[0x4]
8000c1f0:	e0 1a ff fc 	andl	r10,0xfffc
8000c1f4:	14 38       	cp.w	r8,r10
8000c1f6:	cf 93       	brcs	8000c1e8 <_free_r+0x168>
8000c1f8:	72 38       	ld.w	r8,r9[0xc]
8000c1fa:	8d 38       	st.w	r6[0xc],r8
8000c1fc:	8d 29       	st.w	r6[0x8],r9
8000c1fe:	93 36       	st.w	r9[0xc],r6
8000c200:	91 26       	st.w	r8[0x8],r6
8000c202:	0e 9c       	mov	r12,r7
8000c204:	fe b0 d6 92 	rcall	80006f28 <__malloc_unlock>
8000c208:	d8 22       	popm	r4-r7,pc
8000c20a:	d7 03       	nop

8000c20c <__sfvwrite_r>:
8000c20c:	d4 31       	pushm	r0-r7,lr
8000c20e:	20 3d       	sub	sp,12
8000c210:	14 94       	mov	r4,r10
8000c212:	18 95       	mov	r5,r12
8000c214:	16 97       	mov	r7,r11
8000c216:	74 28       	ld.w	r8,r10[0x8]
8000c218:	58 08       	cp.w	r8,0
8000c21a:	e0 80 01 40 	breq	8000c49a <__sfvwrite_r+0x28e>
8000c21e:	96 68       	ld.sh	r8,r11[0xc]
8000c220:	ed b8 00 03 	bld	r8,0x3
8000c224:	c0 41       	brne	8000c22c <__sfvwrite_r+0x20>
8000c226:	76 48       	ld.w	r8,r11[0x10]
8000c228:	58 08       	cp.w	r8,0
8000c22a:	c0 c1       	brne	8000c242 <__sfvwrite_r+0x36>
8000c22c:	0e 9b       	mov	r11,r7
8000c22e:	0a 9c       	mov	r12,r5
8000c230:	fe b0 f6 c4 	rcall	8000afb8 <__swsetup_r>
8000c234:	c0 70       	breq	8000c242 <__sfvwrite_r+0x36>
8000c236:	8e 68       	ld.sh	r8,r7[0xc]
8000c238:	a7 a8       	sbr	r8,0x6
8000c23a:	ae 68       	st.h	r7[0xc],r8
8000c23c:	30 98       	mov	r8,9
8000c23e:	8b 38       	st.w	r5[0xc],r8
8000c240:	c2 b9       	rjmp	8000c496 <__sfvwrite_r+0x28a>
8000c242:	8e 63       	ld.sh	r3,r7[0xc]
8000c244:	68 00       	ld.w	r0,r4[0x0]
8000c246:	06 96       	mov	r6,r3
8000c248:	e2 16 00 02 	andl	r6,0x2,COH
8000c24c:	c2 10       	breq	8000c28e <__sfvwrite_r+0x82>
8000c24e:	30 03       	mov	r3,0
8000c250:	e0 62 04 00 	mov	r2,1024
8000c254:	06 96       	mov	r6,r3
8000c256:	c0 48       	rjmp	8000c25e <__sfvwrite_r+0x52>
8000c258:	60 03       	ld.w	r3,r0[0x0]
8000c25a:	60 16       	ld.w	r6,r0[0x4]
8000c25c:	2f 80       	sub	r0,-8
8000c25e:	58 06       	cp.w	r6,0
8000c260:	cf c0       	breq	8000c258 <__sfvwrite_r+0x4c>
8000c262:	e0 46 04 00 	cp.w	r6,1024
8000c266:	ec 09 17 80 	movls	r9,r6
8000c26a:	e4 09 17 b0 	movhi	r9,r2
8000c26e:	06 9a       	mov	r10,r3
8000c270:	6e a8       	ld.w	r8,r7[0x28]
8000c272:	6e 8b       	ld.w	r11,r7[0x20]
8000c274:	0a 9c       	mov	r12,r5
8000c276:	5d 18       	icall	r8
8000c278:	18 16       	sub	r6,r12
8000c27a:	58 0c       	cp.w	r12,0
8000c27c:	e0 8a 01 0a 	brle	8000c490 <__sfvwrite_r+0x284>
8000c280:	68 28       	ld.w	r8,r4[0x8]
8000c282:	18 18       	sub	r8,r12
8000c284:	89 28       	st.w	r4[0x8],r8
8000c286:	e0 80 01 0a 	breq	8000c49a <__sfvwrite_r+0x28e>
8000c28a:	18 03       	add	r3,r12
8000c28c:	ce 9b       	rjmp	8000c25e <__sfvwrite_r+0x52>
8000c28e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c292:	c0 70       	breq	8000c2a0 <__sfvwrite_r+0x94>
8000c294:	50 06       	stdsp	sp[0x0],r6
8000c296:	0c 93       	mov	r3,r6
8000c298:	0c 91       	mov	r1,r6
8000c29a:	50 15       	stdsp	sp[0x4],r5
8000c29c:	08 92       	mov	r2,r4
8000c29e:	c9 c8       	rjmp	8000c3d6 <__sfvwrite_r+0x1ca>
8000c2a0:	06 96       	mov	r6,r3
8000c2a2:	08 91       	mov	r1,r4
8000c2a4:	c0 48       	rjmp	8000c2ac <__sfvwrite_r+0xa0>
8000c2a6:	60 03       	ld.w	r3,r0[0x0]
8000c2a8:	60 16       	ld.w	r6,r0[0x4]
8000c2aa:	2f 80       	sub	r0,-8
8000c2ac:	58 06       	cp.w	r6,0
8000c2ae:	cf c0       	breq	8000c2a6 <__sfvwrite_r+0x9a>
8000c2b0:	8e 68       	ld.sh	r8,r7[0xc]
8000c2b2:	6e 24       	ld.w	r4,r7[0x8]
8000c2b4:	10 99       	mov	r9,r8
8000c2b6:	e2 19 02 00 	andl	r9,0x200,COH
8000c2ba:	c5 50       	breq	8000c364 <__sfvwrite_r+0x158>
8000c2bc:	08 36       	cp.w	r6,r4
8000c2be:	c4 43       	brcs	8000c346 <__sfvwrite_r+0x13a>
8000c2c0:	10 99       	mov	r9,r8
8000c2c2:	e2 19 04 80 	andl	r9,0x480,COH
8000c2c6:	c4 00       	breq	8000c346 <__sfvwrite_r+0x13a>
8000c2c8:	6e 4b       	ld.w	r11,r7[0x10]
8000c2ca:	6e 09       	ld.w	r9,r7[0x0]
8000c2cc:	16 19       	sub	r9,r11
8000c2ce:	50 09       	stdsp	sp[0x0],r9
8000c2d0:	6e 59       	ld.w	r9,r7[0x14]
8000c2d2:	10 9c       	mov	r12,r8
8000c2d4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c2d8:	30 28       	mov	r8,2
8000c2da:	f4 08 0c 08 	divs	r8,r10,r8
8000c2de:	fa e9 00 04 	st.d	sp[4],r8
8000c2e2:	10 94       	mov	r4,r8
8000c2e4:	40 09       	lddsp	r9,sp[0x0]
8000c2e6:	e2 1c 04 00 	andl	r12,0x400,COH
8000c2ea:	2f f9       	sub	r9,-1
8000c2ec:	0c 09       	add	r9,r6
8000c2ee:	12 38       	cp.w	r8,r9
8000c2f0:	f2 04 17 30 	movlo	r4,r9
8000c2f4:	58 0c       	cp.w	r12,0
8000c2f6:	c1 10       	breq	8000c318 <__sfvwrite_r+0x10c>
8000c2f8:	08 9b       	mov	r11,r4
8000c2fa:	0a 9c       	mov	r12,r5
8000c2fc:	fe b0 e0 5a 	rcall	800083b0 <_malloc_r>
8000c300:	18 92       	mov	r2,r12
8000c302:	c1 40       	breq	8000c32a <__sfvwrite_r+0x11e>
8000c304:	40 0a       	lddsp	r10,sp[0x0]
8000c306:	6e 4b       	ld.w	r11,r7[0x10]
8000c308:	fe b0 e2 83 	rcall	8000880e <memcpy>
8000c30c:	8e 68       	ld.sh	r8,r7[0xc]
8000c30e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c312:	a7 b8       	sbr	r8,0x7
8000c314:	ae 68       	st.h	r7[0xc],r8
8000c316:	c0 d8       	rjmp	8000c330 <__sfvwrite_r+0x124>
8000c318:	08 9a       	mov	r10,r4
8000c31a:	0a 9c       	mov	r12,r5
8000c31c:	fe b0 e3 24 	rcall	80008964 <_realloc_r>
8000c320:	18 92       	mov	r2,r12
8000c322:	c0 71       	brne	8000c330 <__sfvwrite_r+0x124>
8000c324:	6e 4b       	ld.w	r11,r7[0x10]
8000c326:	0a 9c       	mov	r12,r5
8000c328:	ca ce       	rcall	8000c080 <_free_r>
8000c32a:	30 c8       	mov	r8,12
8000c32c:	8b 38       	st.w	r5[0xc],r8
8000c32e:	cb 18       	rjmp	8000c490 <__sfvwrite_r+0x284>
8000c330:	40 0a       	lddsp	r10,sp[0x0]
8000c332:	40 09       	lddsp	r9,sp[0x0]
8000c334:	e8 0a 01 0a 	sub	r10,r4,r10
8000c338:	e4 09 00 08 	add	r8,r2,r9
8000c33c:	8f 54       	st.w	r7[0x14],r4
8000c33e:	8f 2a       	st.w	r7[0x8],r10
8000c340:	8f 08       	st.w	r7[0x0],r8
8000c342:	8f 42       	st.w	r7[0x10],r2
8000c344:	0c 94       	mov	r4,r6
8000c346:	08 36       	cp.w	r6,r4
8000c348:	ec 04 17 30 	movlo	r4,r6
8000c34c:	06 9b       	mov	r11,r3
8000c34e:	08 9a       	mov	r10,r4
8000c350:	6e 0c       	ld.w	r12,r7[0x0]
8000c352:	c3 ad       	rcall	8000c5c6 <memmove>
8000c354:	6e 08       	ld.w	r8,r7[0x0]
8000c356:	08 08       	add	r8,r4
8000c358:	8f 08       	st.w	r7[0x0],r8
8000c35a:	6e 28       	ld.w	r8,r7[0x8]
8000c35c:	08 18       	sub	r8,r4
8000c35e:	0c 94       	mov	r4,r6
8000c360:	8f 28       	st.w	r7[0x8],r8
8000c362:	c2 e8       	rjmp	8000c3be <__sfvwrite_r+0x1b2>
8000c364:	08 36       	cp.w	r6,r4
8000c366:	5f ba       	srhi	r10
8000c368:	6e 0c       	ld.w	r12,r7[0x0]
8000c36a:	6e 48       	ld.w	r8,r7[0x10]
8000c36c:	10 3c       	cp.w	r12,r8
8000c36e:	5f b8       	srhi	r8
8000c370:	f5 e8 00 08 	and	r8,r10,r8
8000c374:	f2 08 18 00 	cp.b	r8,r9
8000c378:	c0 d0       	breq	8000c392 <__sfvwrite_r+0x186>
8000c37a:	06 9b       	mov	r11,r3
8000c37c:	08 9a       	mov	r10,r4
8000c37e:	c2 4d       	rcall	8000c5c6 <memmove>
8000c380:	6e 08       	ld.w	r8,r7[0x0]
8000c382:	08 08       	add	r8,r4
8000c384:	0e 9b       	mov	r11,r7
8000c386:	8f 08       	st.w	r7[0x0],r8
8000c388:	0a 9c       	mov	r12,r5
8000c38a:	fe b0 fd 09 	rcall	8000bd9c <_fflush_r>
8000c38e:	c1 80       	breq	8000c3be <__sfvwrite_r+0x1b2>
8000c390:	c8 08       	rjmp	8000c490 <__sfvwrite_r+0x284>
8000c392:	6e 59       	ld.w	r9,r7[0x14]
8000c394:	12 36       	cp.w	r6,r9
8000c396:	c0 a3       	brcs	8000c3aa <__sfvwrite_r+0x19e>
8000c398:	6e a8       	ld.w	r8,r7[0x28]
8000c39a:	06 9a       	mov	r10,r3
8000c39c:	6e 8b       	ld.w	r11,r7[0x20]
8000c39e:	0a 9c       	mov	r12,r5
8000c3a0:	5d 18       	icall	r8
8000c3a2:	18 94       	mov	r4,r12
8000c3a4:	e0 89 00 0d 	brgt	8000c3be <__sfvwrite_r+0x1b2>
8000c3a8:	c7 48       	rjmp	8000c490 <__sfvwrite_r+0x284>
8000c3aa:	0c 9a       	mov	r10,r6
8000c3ac:	06 9b       	mov	r11,r3
8000c3ae:	c0 cd       	rcall	8000c5c6 <memmove>
8000c3b0:	6e 08       	ld.w	r8,r7[0x0]
8000c3b2:	0c 08       	add	r8,r6
8000c3b4:	0c 94       	mov	r4,r6
8000c3b6:	8f 08       	st.w	r7[0x0],r8
8000c3b8:	6e 28       	ld.w	r8,r7[0x8]
8000c3ba:	0c 18       	sub	r8,r6
8000c3bc:	8f 28       	st.w	r7[0x8],r8
8000c3be:	62 28       	ld.w	r8,r1[0x8]
8000c3c0:	08 18       	sub	r8,r4
8000c3c2:	83 28       	st.w	r1[0x8],r8
8000c3c4:	c6 b0       	breq	8000c49a <__sfvwrite_r+0x28e>
8000c3c6:	08 16       	sub	r6,r4
8000c3c8:	08 03       	add	r3,r4
8000c3ca:	c7 1b       	rjmp	8000c2ac <__sfvwrite_r+0xa0>
8000c3cc:	60 03       	ld.w	r3,r0[0x0]
8000c3ce:	60 11       	ld.w	r1,r0[0x4]
8000c3d0:	30 08       	mov	r8,0
8000c3d2:	2f 80       	sub	r0,-8
8000c3d4:	50 08       	stdsp	sp[0x0],r8
8000c3d6:	58 01       	cp.w	r1,0
8000c3d8:	cf a0       	breq	8000c3cc <__sfvwrite_r+0x1c0>
8000c3da:	40 0a       	lddsp	r10,sp[0x0]
8000c3dc:	58 0a       	cp.w	r10,0
8000c3de:	c1 41       	brne	8000c406 <__sfvwrite_r+0x1fa>
8000c3e0:	e2 c6 ff ff 	sub	r6,r1,-1
8000c3e4:	02 9a       	mov	r10,r1
8000c3e6:	30 ab       	mov	r11,10
8000c3e8:	06 9c       	mov	r12,r3
8000c3ea:	ce 3c       	rcall	8000c5b0 <memchr>
8000c3ec:	f8 c8 ff ff 	sub	r8,r12,-1
8000c3f0:	58 0c       	cp.w	r12,0
8000c3f2:	f1 d3 e1 16 	subne	r6,r8,r3
8000c3f6:	f9 b9 01 01 	movne	r9,1
8000c3fa:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c3fe:	f9 b8 00 01 	moveq	r8,1
8000c402:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c406:	02 36       	cp.w	r6,r1
8000c408:	ec 04 17 80 	movls	r4,r6
8000c40c:	e2 04 17 b0 	movhi	r4,r1
8000c410:	6e 59       	ld.w	r9,r7[0x14]
8000c412:	6e 25       	ld.w	r5,r7[0x8]
8000c414:	f2 05 00 05 	add	r5,r9,r5
8000c418:	0a 34       	cp.w	r4,r5
8000c41a:	5f 9a       	srgt	r10
8000c41c:	6e 0c       	ld.w	r12,r7[0x0]
8000c41e:	6e 48       	ld.w	r8,r7[0x10]
8000c420:	10 3c       	cp.w	r12,r8
8000c422:	5f b8       	srhi	r8
8000c424:	f5 e8 00 08 	and	r8,r10,r8
8000c428:	30 0a       	mov	r10,0
8000c42a:	f4 08 18 00 	cp.b	r8,r10
8000c42e:	c0 d0       	breq	8000c448 <__sfvwrite_r+0x23c>
8000c430:	06 9b       	mov	r11,r3
8000c432:	0a 9a       	mov	r10,r5
8000c434:	cc 9c       	rcall	8000c5c6 <memmove>
8000c436:	6e 08       	ld.w	r8,r7[0x0]
8000c438:	0a 08       	add	r8,r5
8000c43a:	0e 9b       	mov	r11,r7
8000c43c:	8f 08       	st.w	r7[0x0],r8
8000c43e:	40 1c       	lddsp	r12,sp[0x4]
8000c440:	fe b0 fc ae 	rcall	8000bd9c <_fflush_r>
8000c444:	c1 70       	breq	8000c472 <__sfvwrite_r+0x266>
8000c446:	c2 58       	rjmp	8000c490 <__sfvwrite_r+0x284>
8000c448:	12 34       	cp.w	r4,r9
8000c44a:	c0 a5       	brlt	8000c45e <__sfvwrite_r+0x252>
8000c44c:	6e a8       	ld.w	r8,r7[0x28]
8000c44e:	06 9a       	mov	r10,r3
8000c450:	6e 8b       	ld.w	r11,r7[0x20]
8000c452:	40 1c       	lddsp	r12,sp[0x4]
8000c454:	5d 18       	icall	r8
8000c456:	18 95       	mov	r5,r12
8000c458:	e0 89 00 0d 	brgt	8000c472 <__sfvwrite_r+0x266>
8000c45c:	c1 a8       	rjmp	8000c490 <__sfvwrite_r+0x284>
8000c45e:	08 9a       	mov	r10,r4
8000c460:	06 9b       	mov	r11,r3
8000c462:	cb 2c       	rcall	8000c5c6 <memmove>
8000c464:	6e 08       	ld.w	r8,r7[0x0]
8000c466:	08 08       	add	r8,r4
8000c468:	08 95       	mov	r5,r4
8000c46a:	8f 08       	st.w	r7[0x0],r8
8000c46c:	6e 28       	ld.w	r8,r7[0x8]
8000c46e:	08 18       	sub	r8,r4
8000c470:	8f 28       	st.w	r7[0x8],r8
8000c472:	0a 16       	sub	r6,r5
8000c474:	c0 71       	brne	8000c482 <__sfvwrite_r+0x276>
8000c476:	0e 9b       	mov	r11,r7
8000c478:	40 1c       	lddsp	r12,sp[0x4]
8000c47a:	fe b0 fc 91 	rcall	8000bd9c <_fflush_r>
8000c47e:	c0 91       	brne	8000c490 <__sfvwrite_r+0x284>
8000c480:	50 06       	stdsp	sp[0x0],r6
8000c482:	64 28       	ld.w	r8,r2[0x8]
8000c484:	0a 18       	sub	r8,r5
8000c486:	85 28       	st.w	r2[0x8],r8
8000c488:	c0 90       	breq	8000c49a <__sfvwrite_r+0x28e>
8000c48a:	0a 11       	sub	r1,r5
8000c48c:	0a 03       	add	r3,r5
8000c48e:	ca 4b       	rjmp	8000c3d6 <__sfvwrite_r+0x1ca>
8000c490:	8e 68       	ld.sh	r8,r7[0xc]
8000c492:	a7 a8       	sbr	r8,0x6
8000c494:	ae 68       	st.h	r7[0xc],r8
8000c496:	3f fc       	mov	r12,-1
8000c498:	c0 28       	rjmp	8000c49c <__sfvwrite_r+0x290>
8000c49a:	30 0c       	mov	r12,0
8000c49c:	2f dd       	sub	sp,-12
8000c49e:	d8 32       	popm	r0-r7,pc

8000c4a0 <_fwalk>:
8000c4a0:	d4 31       	pushm	r0-r7,lr
8000c4a2:	30 05       	mov	r5,0
8000c4a4:	16 91       	mov	r1,r11
8000c4a6:	f8 c7 ff 28 	sub	r7,r12,-216
8000c4aa:	0a 92       	mov	r2,r5
8000c4ac:	fe b0 fc fe 	rcall	8000bea8 <__sfp_lock_acquire>
8000c4b0:	3f f3       	mov	r3,-1
8000c4b2:	c1 68       	rjmp	8000c4de <_fwalk+0x3e>
8000c4b4:	6e 26       	ld.w	r6,r7[0x8]
8000c4b6:	6e 14       	ld.w	r4,r7[0x4]
8000c4b8:	2f 46       	sub	r6,-12
8000c4ba:	c0 c8       	rjmp	8000c4d2 <_fwalk+0x32>
8000c4bc:	8c 08       	ld.sh	r8,r6[0x0]
8000c4be:	e4 08 19 00 	cp.h	r8,r2
8000c4c2:	c0 70       	breq	8000c4d0 <_fwalk+0x30>
8000c4c4:	8c 18       	ld.sh	r8,r6[0x2]
8000c4c6:	e6 08 19 00 	cp.h	r8,r3
8000c4ca:	c0 30       	breq	8000c4d0 <_fwalk+0x30>
8000c4cc:	5d 11       	icall	r1
8000c4ce:	18 45       	or	r5,r12
8000c4d0:	2a 46       	sub	r6,-92
8000c4d2:	20 14       	sub	r4,1
8000c4d4:	ec cc 00 0c 	sub	r12,r6,12
8000c4d8:	58 04       	cp.w	r4,0
8000c4da:	cf 14       	brge	8000c4bc <_fwalk+0x1c>
8000c4dc:	6e 07       	ld.w	r7,r7[0x0]
8000c4de:	58 07       	cp.w	r7,0
8000c4e0:	ce a1       	brne	8000c4b4 <_fwalk+0x14>
8000c4e2:	fe b0 fc e4 	rcall	8000beaa <__sfp_lock_release>
8000c4e6:	0a 9c       	mov	r12,r5
8000c4e8:	d8 32       	popm	r0-r7,pc
8000c4ea:	d7 03       	nop

8000c4ec <_localeconv_r>:
8000c4ec:	fe cc d0 00 	sub	r12,pc,-12288
8000c4f0:	5e fc       	retal	r12
8000c4f2:	d7 03       	nop

8000c4f4 <__smakebuf_r>:
8000c4f4:	d4 21       	pushm	r4-r7,lr
8000c4f6:	20 fd       	sub	sp,60
8000c4f8:	96 68       	ld.sh	r8,r11[0xc]
8000c4fa:	16 97       	mov	r7,r11
8000c4fc:	18 96       	mov	r6,r12
8000c4fe:	e2 18 00 02 	andl	r8,0x2,COH
8000c502:	c3 d1       	brne	8000c57c <__smakebuf_r+0x88>
8000c504:	96 7b       	ld.sh	r11,r11[0xe]
8000c506:	f0 0b 19 00 	cp.h	r11,r8
8000c50a:	c0 55       	brlt	8000c514 <__smakebuf_r+0x20>
8000c50c:	1a 9a       	mov	r10,sp
8000c50e:	e0 a0 04 81 	rcall	8000ce10 <_fstat_r>
8000c512:	c0 f4       	brge	8000c530 <__smakebuf_r+0x3c>
8000c514:	8e 65       	ld.sh	r5,r7[0xc]
8000c516:	0a 98       	mov	r8,r5
8000c518:	ab b8       	sbr	r8,0xb
8000c51a:	e2 15 00 80 	andl	r5,0x80,COH
8000c51e:	ae 68       	st.h	r7[0xc],r8
8000c520:	30 04       	mov	r4,0
8000c522:	e0 68 04 00 	mov	r8,1024
8000c526:	f9 b5 01 40 	movne	r5,64
8000c52a:	f0 05 17 00 	moveq	r5,r8
8000c52e:	c1 c8       	rjmp	8000c566 <__smakebuf_r+0x72>
8000c530:	40 18       	lddsp	r8,sp[0x4]
8000c532:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c536:	e0 48 20 00 	cp.w	r8,8192
8000c53a:	5f 04       	sreq	r4
8000c53c:	e0 48 80 00 	cp.w	r8,32768
8000c540:	c0 e1       	brne	8000c55c <__smakebuf_r+0x68>
8000c542:	6e b9       	ld.w	r9,r7[0x2c]
8000c544:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c548:	10 39       	cp.w	r9,r8
8000c54a:	c0 91       	brne	8000c55c <__smakebuf_r+0x68>
8000c54c:	8e 68       	ld.sh	r8,r7[0xc]
8000c54e:	e0 65 04 00 	mov	r5,1024
8000c552:	ab a8       	sbr	r8,0xa
8000c554:	ef 45 00 50 	st.w	r7[80],r5
8000c558:	ae 68       	st.h	r7[0xc],r8
8000c55a:	c0 68       	rjmp	8000c566 <__smakebuf_r+0x72>
8000c55c:	8e 68       	ld.sh	r8,r7[0xc]
8000c55e:	e0 65 04 00 	mov	r5,1024
8000c562:	ab b8       	sbr	r8,0xb
8000c564:	ae 68       	st.h	r7[0xc],r8
8000c566:	0a 9b       	mov	r11,r5
8000c568:	0c 9c       	mov	r12,r6
8000c56a:	fe b0 df 23 	rcall	800083b0 <_malloc_r>
8000c56e:	8e 68       	ld.sh	r8,r7[0xc]
8000c570:	c0 d1       	brne	8000c58a <__smakebuf_r+0x96>
8000c572:	ed b8 00 09 	bld	r8,0x9
8000c576:	c1 b0       	breq	8000c5ac <__smakebuf_r+0xb8>
8000c578:	a1 b8       	sbr	r8,0x1
8000c57a:	ae 68       	st.h	r7[0xc],r8
8000c57c:	ee c8 ff b9 	sub	r8,r7,-71
8000c580:	8f 48       	st.w	r7[0x10],r8
8000c582:	8f 08       	st.w	r7[0x0],r8
8000c584:	30 18       	mov	r8,1
8000c586:	8f 58       	st.w	r7[0x14],r8
8000c588:	c1 28       	rjmp	8000c5ac <__smakebuf_r+0xb8>
8000c58a:	a7 b8       	sbr	r8,0x7
8000c58c:	8f 4c       	st.w	r7[0x10],r12
8000c58e:	ae 68       	st.h	r7[0xc],r8
8000c590:	8f 55       	st.w	r7[0x14],r5
8000c592:	fe c8 06 e6 	sub	r8,pc,1766
8000c596:	8f 0c       	st.w	r7[0x0],r12
8000c598:	8d a8       	st.w	r6[0x28],r8
8000c59a:	58 04       	cp.w	r4,0
8000c59c:	c0 80       	breq	8000c5ac <__smakebuf_r+0xb8>
8000c59e:	8e 7c       	ld.sh	r12,r7[0xe]
8000c5a0:	fe b0 e3 94 	rcall	80008cc8 <isatty>
8000c5a4:	c0 40       	breq	8000c5ac <__smakebuf_r+0xb8>
8000c5a6:	8e 68       	ld.sh	r8,r7[0xc]
8000c5a8:	a1 a8       	sbr	r8,0x0
8000c5aa:	ae 68       	st.h	r7[0xc],r8
8000c5ac:	2f 1d       	sub	sp,-60
8000c5ae:	d8 22       	popm	r4-r7,pc

8000c5b0 <memchr>:
8000c5b0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c5b4:	c0 68       	rjmp	8000c5c0 <memchr+0x10>
8000c5b6:	20 1a       	sub	r10,1
8000c5b8:	19 88       	ld.ub	r8,r12[0x0]
8000c5ba:	16 38       	cp.w	r8,r11
8000c5bc:	5e 0c       	reteq	r12
8000c5be:	2f fc       	sub	r12,-1
8000c5c0:	58 0a       	cp.w	r10,0
8000c5c2:	cf a1       	brne	8000c5b6 <memchr+0x6>
8000c5c4:	5e fa       	retal	r10

8000c5c6 <memmove>:
8000c5c6:	d4 01       	pushm	lr
8000c5c8:	18 3b       	cp.w	r11,r12
8000c5ca:	c1 92       	brcc	8000c5fc <memmove+0x36>
8000c5cc:	f6 0a 00 09 	add	r9,r11,r10
8000c5d0:	12 3c       	cp.w	r12,r9
8000c5d2:	c1 52       	brcc	8000c5fc <memmove+0x36>
8000c5d4:	f8 0a 00 0b 	add	r11,r12,r10
8000c5d8:	30 08       	mov	r8,0
8000c5da:	c0 68       	rjmp	8000c5e6 <memmove+0x20>
8000c5dc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c5e0:	20 1a       	sub	r10,1
8000c5e2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c5e6:	20 18       	sub	r8,1
8000c5e8:	58 0a       	cp.w	r10,0
8000c5ea:	cf 91       	brne	8000c5dc <memmove+0x16>
8000c5ec:	d8 02       	popm	pc
8000c5ee:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c5f2:	20 1a       	sub	r10,1
8000c5f4:	f8 08 0b 09 	st.b	r12[r8],r9
8000c5f8:	2f f8       	sub	r8,-1
8000c5fa:	c0 28       	rjmp	8000c5fe <memmove+0x38>
8000c5fc:	30 08       	mov	r8,0
8000c5fe:	58 0a       	cp.w	r10,0
8000c600:	cf 71       	brne	8000c5ee <memmove+0x28>
8000c602:	d8 02       	popm	pc

8000c604 <__hi0bits>:
8000c604:	18 98       	mov	r8,r12
8000c606:	e0 1c 00 00 	andl	r12,0x0
8000c60a:	f0 09 15 10 	lsl	r9,r8,0x10
8000c60e:	58 0c       	cp.w	r12,0
8000c610:	f2 08 17 00 	moveq	r8,r9
8000c614:	f9 bc 00 10 	moveq	r12,16
8000c618:	f9 bc 01 00 	movne	r12,0
8000c61c:	10 9a       	mov	r10,r8
8000c61e:	f0 09 15 08 	lsl	r9,r8,0x8
8000c622:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c626:	f7 bc 00 f8 	subeq	r12,-8
8000c62a:	f2 08 17 00 	moveq	r8,r9
8000c62e:	10 9a       	mov	r10,r8
8000c630:	f0 09 15 04 	lsl	r9,r8,0x4
8000c634:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c638:	f7 bc 00 fc 	subeq	r12,-4
8000c63c:	f2 08 17 00 	moveq	r8,r9
8000c640:	10 9a       	mov	r10,r8
8000c642:	f0 09 15 02 	lsl	r9,r8,0x2
8000c646:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c64a:	f7 bc 00 fe 	subeq	r12,-2
8000c64e:	f2 08 17 00 	moveq	r8,r9
8000c652:	58 08       	cp.w	r8,0
8000c654:	5e 5c       	retlt	r12
8000c656:	ed b8 00 1e 	bld	r8,0x1e
8000c65a:	f9 bc 01 20 	movne	r12,32
8000c65e:	f7 bc 00 ff 	subeq	r12,-1
8000c662:	5e fc       	retal	r12

8000c664 <__lo0bits>:
8000c664:	18 99       	mov	r9,r12
8000c666:	78 08       	ld.w	r8,r12[0x0]
8000c668:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c66c:	c1 50       	breq	8000c696 <__lo0bits+0x32>
8000c66e:	ed b8 00 00 	bld	r8,0x0
8000c672:	c0 21       	brne	8000c676 <__lo0bits+0x12>
8000c674:	5e fd       	retal	0
8000c676:	10 9b       	mov	r11,r8
8000c678:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c67c:	e2 1b 00 02 	andl	r11,0x2,COH
8000c680:	a3 88       	lsr	r8,0x2
8000c682:	58 0b       	cp.w	r11,0
8000c684:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c688:	f9 bc 01 01 	movne	r12,1
8000c68c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c690:	f9 bc 00 02 	moveq	r12,2
8000c694:	5e fc       	retal	r12
8000c696:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c69a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c69e:	58 0a       	cp.w	r10,0
8000c6a0:	f6 08 17 00 	moveq	r8,r11
8000c6a4:	f9 bc 00 10 	moveq	r12,16
8000c6a8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c6ac:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c6b0:	58 0b       	cp.w	r11,0
8000c6b2:	f7 bc 00 f8 	subeq	r12,-8
8000c6b6:	f4 08 17 00 	moveq	r8,r10
8000c6ba:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c6be:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c6c2:	58 0b       	cp.w	r11,0
8000c6c4:	f7 bc 00 fc 	subeq	r12,-4
8000c6c8:	f4 08 17 00 	moveq	r8,r10
8000c6cc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c6d0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c6d4:	58 0b       	cp.w	r11,0
8000c6d6:	f7 bc 00 fe 	subeq	r12,-2
8000c6da:	f4 08 17 00 	moveq	r8,r10
8000c6de:	ed b8 00 00 	bld	r8,0x0
8000c6e2:	c0 60       	breq	8000c6ee <__lo0bits+0x8a>
8000c6e4:	a1 98       	lsr	r8,0x1
8000c6e6:	c0 31       	brne	8000c6ec <__lo0bits+0x88>
8000c6e8:	32 0c       	mov	r12,32
8000c6ea:	5e fc       	retal	r12
8000c6ec:	2f fc       	sub	r12,-1
8000c6ee:	93 08       	st.w	r9[0x0],r8
8000c6f0:	5e fc       	retal	r12

8000c6f2 <__mcmp>:
8000c6f2:	d4 01       	pushm	lr
8000c6f4:	18 98       	mov	r8,r12
8000c6f6:	76 49       	ld.w	r9,r11[0x10]
8000c6f8:	78 4c       	ld.w	r12,r12[0x10]
8000c6fa:	12 1c       	sub	r12,r9
8000c6fc:	c1 31       	brne	8000c722 <__mcmp+0x30>
8000c6fe:	2f b9       	sub	r9,-5
8000c700:	a3 69       	lsl	r9,0x2
8000c702:	12 0b       	add	r11,r9
8000c704:	f0 09 00 09 	add	r9,r8,r9
8000c708:	2e c8       	sub	r8,-20
8000c70a:	13 4e       	ld.w	lr,--r9
8000c70c:	17 4a       	ld.w	r10,--r11
8000c70e:	14 3e       	cp.w	lr,r10
8000c710:	c0 60       	breq	8000c71c <__mcmp+0x2a>
8000c712:	f9 bc 03 ff 	movlo	r12,-1
8000c716:	f9 bc 02 01 	movhs	r12,1
8000c71a:	d8 02       	popm	pc
8000c71c:	10 39       	cp.w	r9,r8
8000c71e:	fe 9b ff f6 	brhi	8000c70a <__mcmp+0x18>
8000c722:	d8 02       	popm	pc

8000c724 <_Bfree>:
8000c724:	d4 21       	pushm	r4-r7,lr
8000c726:	18 97       	mov	r7,r12
8000c728:	16 95       	mov	r5,r11
8000c72a:	78 96       	ld.w	r6,r12[0x24]
8000c72c:	58 06       	cp.w	r6,0
8000c72e:	c0 91       	brne	8000c740 <_Bfree+0x1c>
8000c730:	31 0c       	mov	r12,16
8000c732:	fe b0 de 37 	rcall	800083a0 <malloc>
8000c736:	99 36       	st.w	r12[0xc],r6
8000c738:	8f 9c       	st.w	r7[0x24],r12
8000c73a:	99 16       	st.w	r12[0x4],r6
8000c73c:	99 26       	st.w	r12[0x8],r6
8000c73e:	99 06       	st.w	r12[0x0],r6
8000c740:	58 05       	cp.w	r5,0
8000c742:	c0 90       	breq	8000c754 <_Bfree+0x30>
8000c744:	6a 19       	ld.w	r9,r5[0x4]
8000c746:	6e 98       	ld.w	r8,r7[0x24]
8000c748:	70 38       	ld.w	r8,r8[0xc]
8000c74a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c74e:	8b 0a       	st.w	r5[0x0],r10
8000c750:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c754:	d8 22       	popm	r4-r7,pc
8000c756:	d7 03       	nop

8000c758 <_Balloc>:
8000c758:	d4 21       	pushm	r4-r7,lr
8000c75a:	18 97       	mov	r7,r12
8000c75c:	16 96       	mov	r6,r11
8000c75e:	78 95       	ld.w	r5,r12[0x24]
8000c760:	58 05       	cp.w	r5,0
8000c762:	c0 91       	brne	8000c774 <_Balloc+0x1c>
8000c764:	31 0c       	mov	r12,16
8000c766:	fe b0 de 1d 	rcall	800083a0 <malloc>
8000c76a:	99 35       	st.w	r12[0xc],r5
8000c76c:	8f 9c       	st.w	r7[0x24],r12
8000c76e:	99 15       	st.w	r12[0x4],r5
8000c770:	99 25       	st.w	r12[0x8],r5
8000c772:	99 05       	st.w	r12[0x0],r5
8000c774:	6e 95       	ld.w	r5,r7[0x24]
8000c776:	6a 38       	ld.w	r8,r5[0xc]
8000c778:	58 08       	cp.w	r8,0
8000c77a:	c0 b1       	brne	8000c790 <_Balloc+0x38>
8000c77c:	31 0a       	mov	r10,16
8000c77e:	30 4b       	mov	r11,4
8000c780:	0e 9c       	mov	r12,r7
8000c782:	e0 a0 02 a7 	rcall	8000ccd0 <_calloc_r>
8000c786:	8b 3c       	st.w	r5[0xc],r12
8000c788:	6e 98       	ld.w	r8,r7[0x24]
8000c78a:	70 3c       	ld.w	r12,r8[0xc]
8000c78c:	58 0c       	cp.w	r12,0
8000c78e:	c1 b0       	breq	8000c7c4 <_Balloc+0x6c>
8000c790:	6e 98       	ld.w	r8,r7[0x24]
8000c792:	70 38       	ld.w	r8,r8[0xc]
8000c794:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c798:	70 0c       	ld.w	r12,r8[0x0]
8000c79a:	58 0c       	cp.w	r12,0
8000c79c:	c0 40       	breq	8000c7a4 <_Balloc+0x4c>
8000c79e:	78 09       	ld.w	r9,r12[0x0]
8000c7a0:	91 09       	st.w	r8[0x0],r9
8000c7a2:	c0 e8       	rjmp	8000c7be <_Balloc+0x66>
8000c7a4:	0e 9c       	mov	r12,r7
8000c7a6:	30 17       	mov	r7,1
8000c7a8:	0e 9b       	mov	r11,r7
8000c7aa:	ee 06 09 47 	lsl	r7,r7,r6
8000c7ae:	ee ca ff fb 	sub	r10,r7,-5
8000c7b2:	a3 6a       	lsl	r10,0x2
8000c7b4:	e0 a0 02 8e 	rcall	8000ccd0 <_calloc_r>
8000c7b8:	c0 60       	breq	8000c7c4 <_Balloc+0x6c>
8000c7ba:	99 16       	st.w	r12[0x4],r6
8000c7bc:	99 27       	st.w	r12[0x8],r7
8000c7be:	30 08       	mov	r8,0
8000c7c0:	99 38       	st.w	r12[0xc],r8
8000c7c2:	99 48       	st.w	r12[0x10],r8
8000c7c4:	d8 22       	popm	r4-r7,pc
8000c7c6:	d7 03       	nop

8000c7c8 <__d2b>:
8000c7c8:	d4 31       	pushm	r0-r7,lr
8000c7ca:	20 2d       	sub	sp,8
8000c7cc:	16 93       	mov	r3,r11
8000c7ce:	12 96       	mov	r6,r9
8000c7d0:	10 95       	mov	r5,r8
8000c7d2:	14 92       	mov	r2,r10
8000c7d4:	30 1b       	mov	r11,1
8000c7d6:	cc 1f       	rcall	8000c758 <_Balloc>
8000c7d8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c7dc:	50 09       	stdsp	sp[0x0],r9
8000c7de:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c7e2:	b5 a9       	sbr	r9,0x14
8000c7e4:	f0 01 16 14 	lsr	r1,r8,0x14
8000c7e8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c7ec:	18 94       	mov	r4,r12
8000c7ee:	58 02       	cp.w	r2,0
8000c7f0:	c1 d0       	breq	8000c82a <__d2b+0x62>
8000c7f2:	fa cc ff f8 	sub	r12,sp,-8
8000c7f6:	18 d2       	st.w	--r12,r2
8000c7f8:	c3 6f       	rcall	8000c664 <__lo0bits>
8000c7fa:	40 18       	lddsp	r8,sp[0x4]
8000c7fc:	c0 d0       	breq	8000c816 <__d2b+0x4e>
8000c7fe:	40 09       	lddsp	r9,sp[0x0]
8000c800:	f8 0a 11 20 	rsub	r10,r12,32
8000c804:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c808:	f5 e8 10 08 	or	r8,r10,r8
8000c80c:	89 58       	st.w	r4[0x14],r8
8000c80e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c812:	50 09       	stdsp	sp[0x0],r9
8000c814:	c0 28       	rjmp	8000c818 <__d2b+0x50>
8000c816:	89 58       	st.w	r4[0x14],r8
8000c818:	40 08       	lddsp	r8,sp[0x0]
8000c81a:	58 08       	cp.w	r8,0
8000c81c:	f9 b3 01 02 	movne	r3,2
8000c820:	f9 b3 00 01 	moveq	r3,1
8000c824:	89 68       	st.w	r4[0x18],r8
8000c826:	89 43       	st.w	r4[0x10],r3
8000c828:	c0 88       	rjmp	8000c838 <__d2b+0x70>
8000c82a:	1a 9c       	mov	r12,sp
8000c82c:	c1 cf       	rcall	8000c664 <__lo0bits>
8000c82e:	30 13       	mov	r3,1
8000c830:	40 08       	lddsp	r8,sp[0x0]
8000c832:	2e 0c       	sub	r12,-32
8000c834:	89 43       	st.w	r4[0x10],r3
8000c836:	89 58       	st.w	r4[0x14],r8
8000c838:	58 01       	cp.w	r1,0
8000c83a:	c0 90       	breq	8000c84c <__d2b+0x84>
8000c83c:	e2 c1 04 33 	sub	r1,r1,1075
8000c840:	18 01       	add	r1,r12
8000c842:	8d 01       	st.w	r6[0x0],r1
8000c844:	f8 0c 11 35 	rsub	r12,r12,53
8000c848:	8b 0c       	st.w	r5[0x0],r12
8000c84a:	c0 c8       	rjmp	8000c862 <__d2b+0x9a>
8000c84c:	e6 c8 ff fc 	sub	r8,r3,-4
8000c850:	f8 cc 04 32 	sub	r12,r12,1074
8000c854:	a5 73       	lsl	r3,0x5
8000c856:	8d 0c       	st.w	r6[0x0],r12
8000c858:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c85c:	cd 4e       	rcall	8000c604 <__hi0bits>
8000c85e:	18 13       	sub	r3,r12
8000c860:	8b 03       	st.w	r5[0x0],r3
8000c862:	08 9c       	mov	r12,r4
8000c864:	2f ed       	sub	sp,-8
8000c866:	d8 32       	popm	r0-r7,pc

8000c868 <__mdiff>:
8000c868:	d4 31       	pushm	r0-r7,lr
8000c86a:	74 48       	ld.w	r8,r10[0x10]
8000c86c:	76 45       	ld.w	r5,r11[0x10]
8000c86e:	16 97       	mov	r7,r11
8000c870:	14 96       	mov	r6,r10
8000c872:	10 15       	sub	r5,r8
8000c874:	c1 31       	brne	8000c89a <__mdiff+0x32>
8000c876:	2f b8       	sub	r8,-5
8000c878:	ee ce ff ec 	sub	lr,r7,-20
8000c87c:	a3 68       	lsl	r8,0x2
8000c87e:	f4 08 00 0b 	add	r11,r10,r8
8000c882:	ee 08 00 08 	add	r8,r7,r8
8000c886:	11 4a       	ld.w	r10,--r8
8000c888:	17 49       	ld.w	r9,--r11
8000c88a:	12 3a       	cp.w	r10,r9
8000c88c:	c0 30       	breq	8000c892 <__mdiff+0x2a>
8000c88e:	c0 e2       	brcc	8000c8aa <__mdiff+0x42>
8000c890:	c0 78       	rjmp	8000c89e <__mdiff+0x36>
8000c892:	1c 38       	cp.w	r8,lr
8000c894:	fe 9b ff f9 	brhi	8000c886 <__mdiff+0x1e>
8000c898:	c4 98       	rjmp	8000c92a <__mdiff+0xc2>
8000c89a:	58 05       	cp.w	r5,0
8000c89c:	c0 64       	brge	8000c8a8 <__mdiff+0x40>
8000c89e:	0e 98       	mov	r8,r7
8000c8a0:	30 15       	mov	r5,1
8000c8a2:	0c 97       	mov	r7,r6
8000c8a4:	10 96       	mov	r6,r8
8000c8a6:	c0 28       	rjmp	8000c8aa <__mdiff+0x42>
8000c8a8:	30 05       	mov	r5,0
8000c8aa:	6e 1b       	ld.w	r11,r7[0x4]
8000c8ac:	c5 6f       	rcall	8000c758 <_Balloc>
8000c8ae:	6e 49       	ld.w	r9,r7[0x10]
8000c8b0:	6c 44       	ld.w	r4,r6[0x10]
8000c8b2:	99 35       	st.w	r12[0xc],r5
8000c8b4:	2f b4       	sub	r4,-5
8000c8b6:	f2 c5 ff fb 	sub	r5,r9,-5
8000c8ba:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c8be:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c8c2:	2e c6       	sub	r6,-20
8000c8c4:	2e c7       	sub	r7,-20
8000c8c6:	f8 c8 ff ec 	sub	r8,r12,-20
8000c8ca:	30 0a       	mov	r10,0
8000c8cc:	0f 0e       	ld.w	lr,r7++
8000c8ce:	0d 0b       	ld.w	r11,r6++
8000c8d0:	fc 02 16 10 	lsr	r2,lr,0x10
8000c8d4:	f6 03 16 10 	lsr	r3,r11,0x10
8000c8d8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c8dc:	e4 03 01 03 	sub	r3,r2,r3
8000c8e0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c8e4:	fc 0b 01 0b 	sub	r11,lr,r11
8000c8e8:	f6 0a 00 0a 	add	r10,r11,r10
8000c8ec:	b0 1a       	st.h	r8[0x2],r10
8000c8ee:	b1 4a       	asr	r10,0x10
8000c8f0:	e6 0a 00 0a 	add	r10,r3,r10
8000c8f4:	b0 0a       	st.h	r8[0x0],r10
8000c8f6:	2f c8       	sub	r8,-4
8000c8f8:	b1 4a       	asr	r10,0x10
8000c8fa:	08 36       	cp.w	r6,r4
8000c8fc:	ce 83       	brcs	8000c8cc <__mdiff+0x64>
8000c8fe:	c0 d8       	rjmp	8000c918 <__mdiff+0xb0>
8000c900:	0f 0b       	ld.w	r11,r7++
8000c902:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c906:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c90a:	16 0a       	add	r10,r11
8000c90c:	b0 1a       	st.h	r8[0x2],r10
8000c90e:	b1 4a       	asr	r10,0x10
8000c910:	1c 0a       	add	r10,lr
8000c912:	b0 0a       	st.h	r8[0x0],r10
8000c914:	2f c8       	sub	r8,-4
8000c916:	b1 4a       	asr	r10,0x10
8000c918:	0a 37       	cp.w	r7,r5
8000c91a:	cf 33       	brcs	8000c900 <__mdiff+0x98>
8000c91c:	c0 28       	rjmp	8000c920 <__mdiff+0xb8>
8000c91e:	20 19       	sub	r9,1
8000c920:	11 4a       	ld.w	r10,--r8
8000c922:	58 0a       	cp.w	r10,0
8000c924:	cf d0       	breq	8000c91e <__mdiff+0xb6>
8000c926:	99 49       	st.w	r12[0x10],r9
8000c928:	d8 32       	popm	r0-r7,pc
8000c92a:	30 0b       	mov	r11,0
8000c92c:	c1 6f       	rcall	8000c758 <_Balloc>
8000c92e:	30 18       	mov	r8,1
8000c930:	99 48       	st.w	r12[0x10],r8
8000c932:	30 08       	mov	r8,0
8000c934:	99 58       	st.w	r12[0x14],r8
8000c936:	d8 32       	popm	r0-r7,pc

8000c938 <__lshift>:
8000c938:	d4 31       	pushm	r0-r7,lr
8000c93a:	16 97       	mov	r7,r11
8000c93c:	76 46       	ld.w	r6,r11[0x10]
8000c93e:	f4 02 14 05 	asr	r2,r10,0x5
8000c942:	2f f6       	sub	r6,-1
8000c944:	14 93       	mov	r3,r10
8000c946:	18 94       	mov	r4,r12
8000c948:	04 06       	add	r6,r2
8000c94a:	76 1b       	ld.w	r11,r11[0x4]
8000c94c:	6e 28       	ld.w	r8,r7[0x8]
8000c94e:	c0 38       	rjmp	8000c954 <__lshift+0x1c>
8000c950:	2f fb       	sub	r11,-1
8000c952:	a1 78       	lsl	r8,0x1
8000c954:	10 36       	cp.w	r6,r8
8000c956:	fe 99 ff fd 	brgt	8000c950 <__lshift+0x18>
8000c95a:	08 9c       	mov	r12,r4
8000c95c:	cf ee       	rcall	8000c758 <_Balloc>
8000c95e:	30 09       	mov	r9,0
8000c960:	18 95       	mov	r5,r12
8000c962:	f8 c8 ff ec 	sub	r8,r12,-20
8000c966:	12 9a       	mov	r10,r9
8000c968:	c0 38       	rjmp	8000c96e <__lshift+0x36>
8000c96a:	10 aa       	st.w	r8++,r10
8000c96c:	2f f9       	sub	r9,-1
8000c96e:	04 39       	cp.w	r9,r2
8000c970:	cf d5       	brlt	8000c96a <__lshift+0x32>
8000c972:	6e 4b       	ld.w	r11,r7[0x10]
8000c974:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c978:	2f bb       	sub	r11,-5
8000c97a:	ee c9 ff ec 	sub	r9,r7,-20
8000c97e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c982:	58 03       	cp.w	r3,0
8000c984:	c1 30       	breq	8000c9aa <__lshift+0x72>
8000c986:	e6 0c 11 20 	rsub	r12,r3,32
8000c98a:	30 0a       	mov	r10,0
8000c98c:	72 02       	ld.w	r2,r9[0x0]
8000c98e:	e4 03 09 42 	lsl	r2,r2,r3
8000c992:	04 4a       	or	r10,r2
8000c994:	10 aa       	st.w	r8++,r10
8000c996:	13 0a       	ld.w	r10,r9++
8000c998:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c99c:	16 39       	cp.w	r9,r11
8000c99e:	cf 73       	brcs	8000c98c <__lshift+0x54>
8000c9a0:	91 0a       	st.w	r8[0x0],r10
8000c9a2:	58 0a       	cp.w	r10,0
8000c9a4:	c0 70       	breq	8000c9b2 <__lshift+0x7a>
8000c9a6:	2f f6       	sub	r6,-1
8000c9a8:	c0 58       	rjmp	8000c9b2 <__lshift+0x7a>
8000c9aa:	13 0a       	ld.w	r10,r9++
8000c9ac:	10 aa       	st.w	r8++,r10
8000c9ae:	16 39       	cp.w	r9,r11
8000c9b0:	cf d3       	brcs	8000c9aa <__lshift+0x72>
8000c9b2:	08 9c       	mov	r12,r4
8000c9b4:	20 16       	sub	r6,1
8000c9b6:	0e 9b       	mov	r11,r7
8000c9b8:	8b 46       	st.w	r5[0x10],r6
8000c9ba:	cb 5e       	rcall	8000c724 <_Bfree>
8000c9bc:	0a 9c       	mov	r12,r5
8000c9be:	d8 32       	popm	r0-r7,pc

8000c9c0 <__multiply>:
8000c9c0:	d4 31       	pushm	r0-r7,lr
8000c9c2:	20 2d       	sub	sp,8
8000c9c4:	76 49       	ld.w	r9,r11[0x10]
8000c9c6:	74 48       	ld.w	r8,r10[0x10]
8000c9c8:	16 96       	mov	r6,r11
8000c9ca:	14 95       	mov	r5,r10
8000c9cc:	10 39       	cp.w	r9,r8
8000c9ce:	ec 08 17 50 	movlt	r8,r6
8000c9d2:	ea 06 17 50 	movlt	r6,r5
8000c9d6:	f0 05 17 50 	movlt	r5,r8
8000c9da:	6c 28       	ld.w	r8,r6[0x8]
8000c9dc:	76 43       	ld.w	r3,r11[0x10]
8000c9de:	74 42       	ld.w	r2,r10[0x10]
8000c9e0:	76 1b       	ld.w	r11,r11[0x4]
8000c9e2:	e4 03 00 07 	add	r7,r2,r3
8000c9e6:	10 37       	cp.w	r7,r8
8000c9e8:	f7 bb 09 ff 	subgt	r11,-1
8000c9ec:	cb 6e       	rcall	8000c758 <_Balloc>
8000c9ee:	ee c4 ff fb 	sub	r4,r7,-5
8000c9f2:	f8 c9 ff ec 	sub	r9,r12,-20
8000c9f6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c9fa:	30 0a       	mov	r10,0
8000c9fc:	12 98       	mov	r8,r9
8000c9fe:	c0 28       	rjmp	8000ca02 <__multiply+0x42>
8000ca00:	10 aa       	st.w	r8++,r10
8000ca02:	08 38       	cp.w	r8,r4
8000ca04:	cf e3       	brcs	8000ca00 <__multiply+0x40>
8000ca06:	2f b3       	sub	r3,-5
8000ca08:	2f b2       	sub	r2,-5
8000ca0a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ca0e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ca12:	ec cb ff ec 	sub	r11,r6,-20
8000ca16:	50 12       	stdsp	sp[0x4],r2
8000ca18:	ea ca ff ec 	sub	r10,r5,-20
8000ca1c:	c4 48       	rjmp	8000caa4 <__multiply+0xe4>
8000ca1e:	94 95       	ld.uh	r5,r10[0x2]
8000ca20:	58 05       	cp.w	r5,0
8000ca22:	c2 00       	breq	8000ca62 <__multiply+0xa2>
8000ca24:	12 98       	mov	r8,r9
8000ca26:	16 96       	mov	r6,r11
8000ca28:	30 0e       	mov	lr,0
8000ca2a:	50 09       	stdsp	sp[0x0],r9
8000ca2c:	0d 02       	ld.w	r2,r6++
8000ca2e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ca32:	70 01       	ld.w	r1,r8[0x0]
8000ca34:	70 09       	ld.w	r9,r8[0x0]
8000ca36:	b1 81       	lsr	r1,0x10
8000ca38:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ca3c:	e0 05 03 41 	mac	r1,r0,r5
8000ca40:	ab 32       	mul	r2,r5
8000ca42:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ca46:	00 02       	add	r2,r0
8000ca48:	e4 0e 00 0e 	add	lr,r2,lr
8000ca4c:	b0 1e       	st.h	r8[0x2],lr
8000ca4e:	b1 8e       	lsr	lr,0x10
8000ca50:	1c 01       	add	r1,lr
8000ca52:	b0 01       	st.h	r8[0x0],r1
8000ca54:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ca58:	2f c8       	sub	r8,-4
8000ca5a:	06 36       	cp.w	r6,r3
8000ca5c:	ce 83       	brcs	8000ca2c <__multiply+0x6c>
8000ca5e:	40 09       	lddsp	r9,sp[0x0]
8000ca60:	91 0e       	st.w	r8[0x0],lr
8000ca62:	94 86       	ld.uh	r6,r10[0x0]
8000ca64:	58 06       	cp.w	r6,0
8000ca66:	c1 d0       	breq	8000caa0 <__multiply+0xe0>
8000ca68:	72 02       	ld.w	r2,r9[0x0]
8000ca6a:	12 98       	mov	r8,r9
8000ca6c:	16 9e       	mov	lr,r11
8000ca6e:	30 05       	mov	r5,0
8000ca70:	b0 12       	st.h	r8[0x2],r2
8000ca72:	1d 01       	ld.w	r1,lr++
8000ca74:	90 82       	ld.uh	r2,r8[0x0]
8000ca76:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ca7a:	ad 30       	mul	r0,r6
8000ca7c:	e0 02 00 02 	add	r2,r0,r2
8000ca80:	e4 05 00 05 	add	r5,r2,r5
8000ca84:	b0 05       	st.h	r8[0x0],r5
8000ca86:	b1 85       	lsr	r5,0x10
8000ca88:	b1 81       	lsr	r1,0x10
8000ca8a:	2f c8       	sub	r8,-4
8000ca8c:	ad 31       	mul	r1,r6
8000ca8e:	90 92       	ld.uh	r2,r8[0x2]
8000ca90:	e2 02 00 02 	add	r2,r1,r2
8000ca94:	0a 02       	add	r2,r5
8000ca96:	e4 05 16 10 	lsr	r5,r2,0x10
8000ca9a:	06 3e       	cp.w	lr,r3
8000ca9c:	ce a3       	brcs	8000ca70 <__multiply+0xb0>
8000ca9e:	91 02       	st.w	r8[0x0],r2
8000caa0:	2f ca       	sub	r10,-4
8000caa2:	2f c9       	sub	r9,-4
8000caa4:	40 18       	lddsp	r8,sp[0x4]
8000caa6:	10 3a       	cp.w	r10,r8
8000caa8:	cb b3       	brcs	8000ca1e <__multiply+0x5e>
8000caaa:	c0 28       	rjmp	8000caae <__multiply+0xee>
8000caac:	20 17       	sub	r7,1
8000caae:	58 07       	cp.w	r7,0
8000cab0:	e0 8a 00 05 	brle	8000caba <__multiply+0xfa>
8000cab4:	09 48       	ld.w	r8,--r4
8000cab6:	58 08       	cp.w	r8,0
8000cab8:	cf a0       	breq	8000caac <__multiply+0xec>
8000caba:	99 47       	st.w	r12[0x10],r7
8000cabc:	2f ed       	sub	sp,-8
8000cabe:	d8 32       	popm	r0-r7,pc

8000cac0 <__i2b>:
8000cac0:	d4 21       	pushm	r4-r7,lr
8000cac2:	16 97       	mov	r7,r11
8000cac4:	30 1b       	mov	r11,1
8000cac6:	c4 9e       	rcall	8000c758 <_Balloc>
8000cac8:	30 19       	mov	r9,1
8000caca:	99 57       	st.w	r12[0x14],r7
8000cacc:	99 49       	st.w	r12[0x10],r9
8000cace:	d8 22       	popm	r4-r7,pc

8000cad0 <__multadd>:
8000cad0:	d4 31       	pushm	r0-r7,lr
8000cad2:	30 08       	mov	r8,0
8000cad4:	12 95       	mov	r5,r9
8000cad6:	16 97       	mov	r7,r11
8000cad8:	18 96       	mov	r6,r12
8000cada:	76 44       	ld.w	r4,r11[0x10]
8000cadc:	f6 c9 ff ec 	sub	r9,r11,-20
8000cae0:	72 0b       	ld.w	r11,r9[0x0]
8000cae2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000cae6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000caea:	f4 0c 02 4c 	mul	r12,r10,r12
8000caee:	f4 0b 03 45 	mac	r5,r10,r11
8000caf2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000caf6:	b1 85       	lsr	r5,0x10
8000caf8:	18 05       	add	r5,r12
8000cafa:	ea 0c 15 10 	lsl	r12,r5,0x10
8000cafe:	f8 0b 00 0b 	add	r11,r12,r11
8000cb02:	12 ab       	st.w	r9++,r11
8000cb04:	2f f8       	sub	r8,-1
8000cb06:	b1 85       	lsr	r5,0x10
8000cb08:	08 38       	cp.w	r8,r4
8000cb0a:	ce b5       	brlt	8000cae0 <__multadd+0x10>
8000cb0c:	58 05       	cp.w	r5,0
8000cb0e:	c1 c0       	breq	8000cb46 <__multadd+0x76>
8000cb10:	6e 28       	ld.w	r8,r7[0x8]
8000cb12:	10 34       	cp.w	r4,r8
8000cb14:	c1 35       	brlt	8000cb3a <__multadd+0x6a>
8000cb16:	6e 1b       	ld.w	r11,r7[0x4]
8000cb18:	0c 9c       	mov	r12,r6
8000cb1a:	2f fb       	sub	r11,-1
8000cb1c:	c1 ee       	rcall	8000c758 <_Balloc>
8000cb1e:	6e 4a       	ld.w	r10,r7[0x10]
8000cb20:	ee cb ff f4 	sub	r11,r7,-12
8000cb24:	18 93       	mov	r3,r12
8000cb26:	2f ea       	sub	r10,-2
8000cb28:	2f 4c       	sub	r12,-12
8000cb2a:	a3 6a       	lsl	r10,0x2
8000cb2c:	fe b0 de 71 	rcall	8000880e <memcpy>
8000cb30:	0e 9b       	mov	r11,r7
8000cb32:	0c 9c       	mov	r12,r6
8000cb34:	fe b0 fd f8 	rcall	8000c724 <_Bfree>
8000cb38:	06 97       	mov	r7,r3
8000cb3a:	e8 c8 ff ff 	sub	r8,r4,-1
8000cb3e:	2f b4       	sub	r4,-5
8000cb40:	8f 48       	st.w	r7[0x10],r8
8000cb42:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000cb46:	0e 9c       	mov	r12,r7
8000cb48:	d8 32       	popm	r0-r7,pc
8000cb4a:	d7 03       	nop

8000cb4c <__pow5mult>:
8000cb4c:	d4 31       	pushm	r0-r7,lr
8000cb4e:	14 96       	mov	r6,r10
8000cb50:	18 97       	mov	r7,r12
8000cb52:	16 94       	mov	r4,r11
8000cb54:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000cb58:	c0 90       	breq	8000cb6a <__pow5mult+0x1e>
8000cb5a:	20 18       	sub	r8,1
8000cb5c:	fe c9 d6 34 	sub	r9,pc,-10700
8000cb60:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000cb64:	30 09       	mov	r9,0
8000cb66:	cb 5f       	rcall	8000cad0 <__multadd>
8000cb68:	18 94       	mov	r4,r12
8000cb6a:	a3 46       	asr	r6,0x2
8000cb6c:	c3 40       	breq	8000cbd4 <__pow5mult+0x88>
8000cb6e:	6e 95       	ld.w	r5,r7[0x24]
8000cb70:	58 05       	cp.w	r5,0
8000cb72:	c0 91       	brne	8000cb84 <__pow5mult+0x38>
8000cb74:	31 0c       	mov	r12,16
8000cb76:	fe b0 dc 15 	rcall	800083a0 <malloc>
8000cb7a:	99 35       	st.w	r12[0xc],r5
8000cb7c:	8f 9c       	st.w	r7[0x24],r12
8000cb7e:	99 15       	st.w	r12[0x4],r5
8000cb80:	99 25       	st.w	r12[0x8],r5
8000cb82:	99 05       	st.w	r12[0x0],r5
8000cb84:	6e 93       	ld.w	r3,r7[0x24]
8000cb86:	66 25       	ld.w	r5,r3[0x8]
8000cb88:	58 05       	cp.w	r5,0
8000cb8a:	c0 c1       	brne	8000cba2 <__pow5mult+0x56>
8000cb8c:	e0 6b 02 71 	mov	r11,625
8000cb90:	0e 9c       	mov	r12,r7
8000cb92:	c9 7f       	rcall	8000cac0 <__i2b>
8000cb94:	87 2c       	st.w	r3[0x8],r12
8000cb96:	30 08       	mov	r8,0
8000cb98:	18 95       	mov	r5,r12
8000cb9a:	99 08       	st.w	r12[0x0],r8
8000cb9c:	c0 38       	rjmp	8000cba2 <__pow5mult+0x56>
8000cb9e:	06 9c       	mov	r12,r3
8000cba0:	18 95       	mov	r5,r12
8000cba2:	ed b6 00 00 	bld	r6,0x0
8000cba6:	c0 b1       	brne	8000cbbc <__pow5mult+0x70>
8000cba8:	08 9b       	mov	r11,r4
8000cbaa:	0a 9a       	mov	r10,r5
8000cbac:	0e 9c       	mov	r12,r7
8000cbae:	c0 9f       	rcall	8000c9c0 <__multiply>
8000cbb0:	08 9b       	mov	r11,r4
8000cbb2:	18 93       	mov	r3,r12
8000cbb4:	0e 9c       	mov	r12,r7
8000cbb6:	06 94       	mov	r4,r3
8000cbb8:	fe b0 fd b6 	rcall	8000c724 <_Bfree>
8000cbbc:	a1 56       	asr	r6,0x1
8000cbbe:	c0 b0       	breq	8000cbd4 <__pow5mult+0x88>
8000cbc0:	6a 03       	ld.w	r3,r5[0x0]
8000cbc2:	58 03       	cp.w	r3,0
8000cbc4:	ce d1       	brne	8000cb9e <__pow5mult+0x52>
8000cbc6:	0a 9a       	mov	r10,r5
8000cbc8:	0a 9b       	mov	r11,r5
8000cbca:	0e 9c       	mov	r12,r7
8000cbcc:	cf ae       	rcall	8000c9c0 <__multiply>
8000cbce:	8b 0c       	st.w	r5[0x0],r12
8000cbd0:	99 03       	st.w	r12[0x0],r3
8000cbd2:	ce 7b       	rjmp	8000cba0 <__pow5mult+0x54>
8000cbd4:	08 9c       	mov	r12,r4
8000cbd6:	d8 32       	popm	r0-r7,pc

8000cbd8 <__isinfd>:
8000cbd8:	14 98       	mov	r8,r10
8000cbda:	fc 19 7f f0 	movh	r9,0x7ff0
8000cbde:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cbe2:	f0 0b 11 00 	rsub	r11,r8,0
8000cbe6:	f7 e8 10 08 	or	r8,r11,r8
8000cbea:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000cbee:	f2 08 01 08 	sub	r8,r9,r8
8000cbf2:	f0 0c 11 00 	rsub	r12,r8,0
8000cbf6:	f9 e8 10 08 	or	r8,r12,r8
8000cbfa:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000cbfe:	2f fc       	sub	r12,-1
8000cc00:	5e fc       	retal	r12

8000cc02 <__isnand>:
8000cc02:	14 98       	mov	r8,r10
8000cc04:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cc08:	f0 0c 11 00 	rsub	r12,r8,0
8000cc0c:	10 4c       	or	r12,r8
8000cc0e:	fc 18 7f f0 	movh	r8,0x7ff0
8000cc12:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000cc16:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc1a:	bf 9c       	lsr	r12,0x1f
8000cc1c:	5e fc       	retal	r12
8000cc1e:	d7 03       	nop

8000cc20 <__sclose>:
8000cc20:	d4 01       	pushm	lr
8000cc22:	96 7b       	ld.sh	r11,r11[0xe]
8000cc24:	c8 2c       	rcall	8000cd28 <_close_r>
8000cc26:	d8 02       	popm	pc

8000cc28 <__sseek>:
8000cc28:	d4 21       	pushm	r4-r7,lr
8000cc2a:	16 97       	mov	r7,r11
8000cc2c:	96 7b       	ld.sh	r11,r11[0xe]
8000cc2e:	c0 3d       	rcall	8000ce34 <_lseek_r>
8000cc30:	8e 68       	ld.sh	r8,r7[0xc]
8000cc32:	10 99       	mov	r9,r8
8000cc34:	ad c8       	cbr	r8,0xc
8000cc36:	ad a9       	sbr	r9,0xc
8000cc38:	5b fc       	cp.w	r12,-1
8000cc3a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cc3e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cc42:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cc46:	d8 22       	popm	r4-r7,pc

8000cc48 <__swrite>:
8000cc48:	d4 21       	pushm	r4-r7,lr
8000cc4a:	96 68       	ld.sh	r8,r11[0xc]
8000cc4c:	16 97       	mov	r7,r11
8000cc4e:	14 95       	mov	r5,r10
8000cc50:	12 94       	mov	r4,r9
8000cc52:	e2 18 01 00 	andl	r8,0x100,COH
8000cc56:	18 96       	mov	r6,r12
8000cc58:	c0 50       	breq	8000cc62 <__swrite+0x1a>
8000cc5a:	30 29       	mov	r9,2
8000cc5c:	30 0a       	mov	r10,0
8000cc5e:	96 7b       	ld.sh	r11,r11[0xe]
8000cc60:	ce ac       	rcall	8000ce34 <_lseek_r>
8000cc62:	8e 68       	ld.sh	r8,r7[0xc]
8000cc64:	ad c8       	cbr	r8,0xc
8000cc66:	08 99       	mov	r9,r4
8000cc68:	0a 9a       	mov	r10,r5
8000cc6a:	8e 7b       	ld.sh	r11,r7[0xe]
8000cc6c:	0c 9c       	mov	r12,r6
8000cc6e:	ae 68       	st.h	r7[0xc],r8
8000cc70:	c1 cc       	rcall	8000cca8 <_write_r>
8000cc72:	d8 22       	popm	r4-r7,pc

8000cc74 <__sread>:
8000cc74:	d4 21       	pushm	r4-r7,lr
8000cc76:	16 97       	mov	r7,r11
8000cc78:	96 7b       	ld.sh	r11,r11[0xe]
8000cc7a:	cf 1c       	rcall	8000ce5c <_read_r>
8000cc7c:	c0 65       	brlt	8000cc88 <__sread+0x14>
8000cc7e:	6f 58       	ld.w	r8,r7[0x54]
8000cc80:	18 08       	add	r8,r12
8000cc82:	ef 48 00 54 	st.w	r7[84],r8
8000cc86:	d8 22       	popm	r4-r7,pc
8000cc88:	8e 68       	ld.sh	r8,r7[0xc]
8000cc8a:	ad c8       	cbr	r8,0xc
8000cc8c:	ae 68       	st.h	r7[0xc],r8
8000cc8e:	d8 22       	popm	r4-r7,pc

8000cc90 <strlen>:
8000cc90:	30 09       	mov	r9,0
8000cc92:	18 98       	mov	r8,r12
8000cc94:	c0 28       	rjmp	8000cc98 <strlen+0x8>
8000cc96:	2f f8       	sub	r8,-1
8000cc98:	11 8a       	ld.ub	r10,r8[0x0]
8000cc9a:	f2 0a 18 00 	cp.b	r10,r9
8000cc9e:	cf c1       	brne	8000cc96 <strlen+0x6>
8000cca0:	f0 0c 01 0c 	sub	r12,r8,r12
8000cca4:	5e fc       	retal	r12
8000cca6:	d7 03       	nop

8000cca8 <_write_r>:
8000cca8:	d4 21       	pushm	r4-r7,lr
8000ccaa:	16 98       	mov	r8,r11
8000ccac:	18 97       	mov	r7,r12
8000ccae:	10 9c       	mov	r12,r8
8000ccb0:	30 08       	mov	r8,0
8000ccb2:	14 9b       	mov	r11,r10
8000ccb4:	e0 66 bd 48 	mov	r6,48456
8000ccb8:	12 9a       	mov	r10,r9
8000ccba:	8d 08       	st.w	r6[0x0],r8
8000ccbc:	fe b0 d1 5c 	rcall	80006f74 <_write>
8000ccc0:	5b fc       	cp.w	r12,-1
8000ccc2:	c0 51       	brne	8000cccc <_write_r+0x24>
8000ccc4:	6c 08       	ld.w	r8,r6[0x0]
8000ccc6:	58 08       	cp.w	r8,0
8000ccc8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cccc:	d8 22       	popm	r4-r7,pc
8000ccce:	d7 03       	nop

8000ccd0 <_calloc_r>:
8000ccd0:	d4 21       	pushm	r4-r7,lr
8000ccd2:	f4 0b 02 4b 	mul	r11,r10,r11
8000ccd6:	fe b0 db 6d 	rcall	800083b0 <_malloc_r>
8000ccda:	18 97       	mov	r7,r12
8000ccdc:	c2 30       	breq	8000cd22 <_calloc_r+0x52>
8000ccde:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cce2:	e0 1a ff fc 	andl	r10,0xfffc
8000cce6:	20 4a       	sub	r10,4
8000cce8:	e0 4a 00 24 	cp.w	r10,36
8000ccec:	e0 8b 00 18 	brhi	8000cd1c <_calloc_r+0x4c>
8000ccf0:	18 98       	mov	r8,r12
8000ccf2:	59 3a       	cp.w	r10,19
8000ccf4:	e0 88 00 0f 	brls	8000cd12 <_calloc_r+0x42>
8000ccf8:	30 09       	mov	r9,0
8000ccfa:	10 a9       	st.w	r8++,r9
8000ccfc:	10 a9       	st.w	r8++,r9
8000ccfe:	59 ba       	cp.w	r10,27
8000cd00:	e0 88 00 09 	brls	8000cd12 <_calloc_r+0x42>
8000cd04:	10 a9       	st.w	r8++,r9
8000cd06:	10 a9       	st.w	r8++,r9
8000cd08:	e0 4a 00 24 	cp.w	r10,36
8000cd0c:	c0 31       	brne	8000cd12 <_calloc_r+0x42>
8000cd0e:	10 a9       	st.w	r8++,r9
8000cd10:	10 a9       	st.w	r8++,r9
8000cd12:	30 09       	mov	r9,0
8000cd14:	10 a9       	st.w	r8++,r9
8000cd16:	91 19       	st.w	r8[0x4],r9
8000cd18:	91 09       	st.w	r8[0x0],r9
8000cd1a:	c0 48       	rjmp	8000cd22 <_calloc_r+0x52>
8000cd1c:	30 0b       	mov	r11,0
8000cd1e:	fe b0 de 1c 	rcall	80008956 <memset>
8000cd22:	0e 9c       	mov	r12,r7
8000cd24:	d8 22       	popm	r4-r7,pc
8000cd26:	d7 03       	nop

8000cd28 <_close_r>:
8000cd28:	d4 21       	pushm	r4-r7,lr
8000cd2a:	30 08       	mov	r8,0
8000cd2c:	18 97       	mov	r7,r12
8000cd2e:	e0 66 bd 48 	mov	r6,48456
8000cd32:	16 9c       	mov	r12,r11
8000cd34:	8d 08       	st.w	r6[0x0],r8
8000cd36:	fe b0 df b5 	rcall	80008ca0 <_close>
8000cd3a:	5b fc       	cp.w	r12,-1
8000cd3c:	c0 51       	brne	8000cd46 <_close_r+0x1e>
8000cd3e:	6c 08       	ld.w	r8,r6[0x0]
8000cd40:	58 08       	cp.w	r8,0
8000cd42:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cd46:	d8 22       	popm	r4-r7,pc

8000cd48 <_fclose_r>:
8000cd48:	d4 21       	pushm	r4-r7,lr
8000cd4a:	18 96       	mov	r6,r12
8000cd4c:	16 97       	mov	r7,r11
8000cd4e:	58 0b       	cp.w	r11,0
8000cd50:	c0 31       	brne	8000cd56 <_fclose_r+0xe>
8000cd52:	16 95       	mov	r5,r11
8000cd54:	c5 38       	rjmp	8000cdfa <_fclose_r+0xb2>
8000cd56:	fe b0 f8 a9 	rcall	8000bea8 <__sfp_lock_acquire>
8000cd5a:	58 06       	cp.w	r6,0
8000cd5c:	c0 70       	breq	8000cd6a <_fclose_r+0x22>
8000cd5e:	6c 68       	ld.w	r8,r6[0x18]
8000cd60:	58 08       	cp.w	r8,0
8000cd62:	c0 41       	brne	8000cd6a <_fclose_r+0x22>
8000cd64:	0c 9c       	mov	r12,r6
8000cd66:	fe b0 f8 f3 	rcall	8000bf4c <__sinit>
8000cd6a:	fe c8 d8 e6 	sub	r8,pc,-10010
8000cd6e:	10 37       	cp.w	r7,r8
8000cd70:	c0 31       	brne	8000cd76 <_fclose_r+0x2e>
8000cd72:	6c 07       	ld.w	r7,r6[0x0]
8000cd74:	c0 c8       	rjmp	8000cd8c <_fclose_r+0x44>
8000cd76:	fe c8 d8 d2 	sub	r8,pc,-10030
8000cd7a:	10 37       	cp.w	r7,r8
8000cd7c:	c0 31       	brne	8000cd82 <_fclose_r+0x3a>
8000cd7e:	6c 17       	ld.w	r7,r6[0x4]
8000cd80:	c0 68       	rjmp	8000cd8c <_fclose_r+0x44>
8000cd82:	fe c8 d8 be 	sub	r8,pc,-10050
8000cd86:	10 37       	cp.w	r7,r8
8000cd88:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cd8c:	8e 69       	ld.sh	r9,r7[0xc]
8000cd8e:	30 08       	mov	r8,0
8000cd90:	f0 09 19 00 	cp.h	r9,r8
8000cd94:	c0 51       	brne	8000cd9e <_fclose_r+0x56>
8000cd96:	fe b0 f8 8a 	rcall	8000beaa <__sfp_lock_release>
8000cd9a:	30 05       	mov	r5,0
8000cd9c:	c2 f8       	rjmp	8000cdfa <_fclose_r+0xb2>
8000cd9e:	0e 9b       	mov	r11,r7
8000cda0:	0c 9c       	mov	r12,r6
8000cda2:	fe b0 f7 fd 	rcall	8000bd9c <_fflush_r>
8000cda6:	6e c8       	ld.w	r8,r7[0x30]
8000cda8:	18 95       	mov	r5,r12
8000cdaa:	58 08       	cp.w	r8,0
8000cdac:	c0 60       	breq	8000cdb8 <_fclose_r+0x70>
8000cdae:	6e 8b       	ld.w	r11,r7[0x20]
8000cdb0:	0c 9c       	mov	r12,r6
8000cdb2:	5d 18       	icall	r8
8000cdb4:	f9 b5 05 ff 	movlt	r5,-1
8000cdb8:	8e 68       	ld.sh	r8,r7[0xc]
8000cdba:	ed b8 00 07 	bld	r8,0x7
8000cdbe:	c0 51       	brne	8000cdc8 <_fclose_r+0x80>
8000cdc0:	6e 4b       	ld.w	r11,r7[0x10]
8000cdc2:	0c 9c       	mov	r12,r6
8000cdc4:	fe b0 f9 5e 	rcall	8000c080 <_free_r>
8000cdc8:	6e db       	ld.w	r11,r7[0x34]
8000cdca:	58 0b       	cp.w	r11,0
8000cdcc:	c0 a0       	breq	8000cde0 <_fclose_r+0x98>
8000cdce:	ee c8 ff bc 	sub	r8,r7,-68
8000cdd2:	10 3b       	cp.w	r11,r8
8000cdd4:	c0 40       	breq	8000cddc <_fclose_r+0x94>
8000cdd6:	0c 9c       	mov	r12,r6
8000cdd8:	fe b0 f9 54 	rcall	8000c080 <_free_r>
8000cddc:	30 08       	mov	r8,0
8000cdde:	8f d8       	st.w	r7[0x34],r8
8000cde0:	6f 2b       	ld.w	r11,r7[0x48]
8000cde2:	58 0b       	cp.w	r11,0
8000cde4:	c0 70       	breq	8000cdf2 <_fclose_r+0xaa>
8000cde6:	0c 9c       	mov	r12,r6
8000cde8:	fe b0 f9 4c 	rcall	8000c080 <_free_r>
8000cdec:	30 08       	mov	r8,0
8000cdee:	ef 48 00 48 	st.w	r7[72],r8
8000cdf2:	30 08       	mov	r8,0
8000cdf4:	ae 68       	st.h	r7[0xc],r8
8000cdf6:	fe b0 f8 5a 	rcall	8000beaa <__sfp_lock_release>
8000cdfa:	0a 9c       	mov	r12,r5
8000cdfc:	d8 22       	popm	r4-r7,pc
8000cdfe:	d7 03       	nop

8000ce00 <fclose>:
8000ce00:	d4 01       	pushm	lr
8000ce02:	e0 68 0a 54 	mov	r8,2644
8000ce06:	18 9b       	mov	r11,r12
8000ce08:	70 0c       	ld.w	r12,r8[0x0]
8000ce0a:	c9 ff       	rcall	8000cd48 <_fclose_r>
8000ce0c:	d8 02       	popm	pc
8000ce0e:	d7 03       	nop

8000ce10 <_fstat_r>:
8000ce10:	d4 21       	pushm	r4-r7,lr
8000ce12:	16 98       	mov	r8,r11
8000ce14:	18 97       	mov	r7,r12
8000ce16:	10 9c       	mov	r12,r8
8000ce18:	30 08       	mov	r8,0
8000ce1a:	e0 66 bd 48 	mov	r6,48456
8000ce1e:	14 9b       	mov	r11,r10
8000ce20:	8d 08       	st.w	r6[0x0],r8
8000ce22:	fe b0 df 67 	rcall	80008cf0 <_fstat>
8000ce26:	5b fc       	cp.w	r12,-1
8000ce28:	c0 51       	brne	8000ce32 <_fstat_r+0x22>
8000ce2a:	6c 08       	ld.w	r8,r6[0x0]
8000ce2c:	58 08       	cp.w	r8,0
8000ce2e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce32:	d8 22       	popm	r4-r7,pc

8000ce34 <_lseek_r>:
8000ce34:	d4 21       	pushm	r4-r7,lr
8000ce36:	16 98       	mov	r8,r11
8000ce38:	18 97       	mov	r7,r12
8000ce3a:	10 9c       	mov	r12,r8
8000ce3c:	30 08       	mov	r8,0
8000ce3e:	14 9b       	mov	r11,r10
8000ce40:	e0 66 bd 48 	mov	r6,48456
8000ce44:	12 9a       	mov	r10,r9
8000ce46:	8d 08       	st.w	r6[0x0],r8
8000ce48:	fe b0 df 36 	rcall	80008cb4 <_lseek>
8000ce4c:	5b fc       	cp.w	r12,-1
8000ce4e:	c0 51       	brne	8000ce58 <_lseek_r+0x24>
8000ce50:	6c 08       	ld.w	r8,r6[0x0]
8000ce52:	58 08       	cp.w	r8,0
8000ce54:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce58:	d8 22       	popm	r4-r7,pc
8000ce5a:	d7 03       	nop

8000ce5c <_read_r>:
8000ce5c:	d4 21       	pushm	r4-r7,lr
8000ce5e:	16 98       	mov	r8,r11
8000ce60:	18 97       	mov	r7,r12
8000ce62:	10 9c       	mov	r12,r8
8000ce64:	30 08       	mov	r8,0
8000ce66:	14 9b       	mov	r11,r10
8000ce68:	e0 66 bd 48 	mov	r6,48456
8000ce6c:	12 9a       	mov	r10,r9
8000ce6e:	8d 08       	st.w	r6[0x0],r8
8000ce70:	fe b0 d0 62 	rcall	80006f34 <_read>
8000ce74:	5b fc       	cp.w	r12,-1
8000ce76:	c0 51       	brne	8000ce80 <_read_r+0x24>
8000ce78:	6c 08       	ld.w	r8,r6[0x0]
8000ce7a:	58 08       	cp.w	r8,0
8000ce7c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce80:	d8 22       	popm	r4-r7,pc
8000ce82:	d7 03       	nop

8000ce84 <__avr32_f64_mul>:
8000ce84:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ce88:	e0 80 00 dc 	breq	8000d040 <__avr32_f64_mul_op1_zero>
8000ce8c:	d4 21       	pushm	r4-r7,lr
8000ce8e:	f7 e9 20 0e 	eor	lr,r11,r9
8000ce92:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ce96:	30 15       	mov	r5,1
8000ce98:	c4 30       	breq	8000cf1e <__avr32_f64_mul_op1_subnormal>
8000ce9a:	ab 6b       	lsl	r11,0xa
8000ce9c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000cea0:	ab 6a       	lsl	r10,0xa
8000cea2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000cea6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ceaa:	c5 c0       	breq	8000cf62 <__avr32_f64_mul_op2_subnormal>
8000ceac:	a1 78       	lsl	r8,0x1
8000ceae:	5c f9       	rol	r9
8000ceb0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ceb4:	e0 47 07 ff 	cp.w	r7,2047
8000ceb8:	c7 70       	breq	8000cfa6 <__avr32_f64_mul_op_nan_or_inf>
8000ceba:	e0 46 07 ff 	cp.w	r6,2047
8000cebe:	c7 40       	breq	8000cfa6 <__avr32_f64_mul_op_nan_or_inf>
8000cec0:	ee 06 00 0c 	add	r12,r7,r6
8000cec4:	e0 2c 03 fe 	sub	r12,1022
8000cec8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000cecc:	f4 09 07 44 	macu.d	r4,r10,r9
8000ced0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ced4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ced8:	08 07       	add	r7,r4
8000ceda:	f4 05 00 4a 	adc	r10,r10,r5
8000cede:	5c 0b       	acr	r11
8000cee0:	ed bb 00 14 	bld	r11,0x14
8000cee4:	c0 50       	breq	8000ceee <__avr32_f64_mul+0x6a>
8000cee6:	a1 77       	lsl	r7,0x1
8000cee8:	5c fa       	rol	r10
8000ceea:	5c fb       	rol	r11
8000ceec:	20 1c       	sub	r12,1
8000ceee:	58 0c       	cp.w	r12,0
8000cef0:	e0 8a 00 6f 	brle	8000cfce <__avr32_f64_mul_res_subnormal>
8000cef4:	e0 4c 07 ff 	cp.w	r12,2047
8000cef8:	e0 84 00 9c 	brge	8000d030 <__avr32_f64_mul_res_inf>
8000cefc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cf00:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cf04:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cf08:	ee 17 80 00 	eorh	r7,0x8000
8000cf0c:	f1 b7 04 20 	satu	r7,0x1
8000cf10:	0e 0a       	add	r10,r7
8000cf12:	5c 0b       	acr	r11
8000cf14:	ed be 00 1f 	bld	lr,0x1f
8000cf18:	ef bb 00 1f 	bst	r11,0x1f
8000cf1c:	d8 22       	popm	r4-r7,pc

8000cf1e <__avr32_f64_mul_op1_subnormal>:
8000cf1e:	e4 1b 00 0f 	andh	r11,0xf
8000cf22:	f4 0c 12 00 	clz	r12,r10
8000cf26:	f6 06 12 00 	clz	r6,r11
8000cf2a:	f7 bc 03 e1 	sublo	r12,-31
8000cf2e:	f8 06 17 30 	movlo	r6,r12
8000cf32:	f7 b6 02 01 	subhs	r6,1
8000cf36:	e0 46 00 20 	cp.w	r6,32
8000cf3a:	c0 d4       	brge	8000cf54 <__avr32_f64_mul_op1_subnormal+0x36>
8000cf3c:	ec 0c 11 20 	rsub	r12,r6,32
8000cf40:	f6 06 09 4b 	lsl	r11,r11,r6
8000cf44:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cf48:	18 4b       	or	r11,r12
8000cf4a:	f4 06 09 4a 	lsl	r10,r10,r6
8000cf4e:	20 b6       	sub	r6,11
8000cf50:	0c 17       	sub	r7,r6
8000cf52:	ca ab       	rjmp	8000cea6 <__avr32_f64_mul+0x22>
8000cf54:	f4 06 09 4b 	lsl	r11,r10,r6
8000cf58:	c6 40       	breq	8000d020 <__avr32_f64_mul_res_zero>
8000cf5a:	30 0a       	mov	r10,0
8000cf5c:	20 b6       	sub	r6,11
8000cf5e:	0c 17       	sub	r7,r6
8000cf60:	ca 3b       	rjmp	8000cea6 <__avr32_f64_mul+0x22>

8000cf62 <__avr32_f64_mul_op2_subnormal>:
8000cf62:	e4 19 00 0f 	andh	r9,0xf
8000cf66:	f0 0c 12 00 	clz	r12,r8
8000cf6a:	f2 05 12 00 	clz	r5,r9
8000cf6e:	f7 bc 03 ea 	sublo	r12,-22
8000cf72:	f8 05 17 30 	movlo	r5,r12
8000cf76:	f7 b5 02 0a 	subhs	r5,10
8000cf7a:	e0 45 00 20 	cp.w	r5,32
8000cf7e:	c0 d4       	brge	8000cf98 <__avr32_f64_mul_op2_subnormal+0x36>
8000cf80:	ea 0c 11 20 	rsub	r12,r5,32
8000cf84:	f2 05 09 49 	lsl	r9,r9,r5
8000cf88:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cf8c:	18 49       	or	r9,r12
8000cf8e:	f0 05 09 48 	lsl	r8,r8,r5
8000cf92:	20 25       	sub	r5,2
8000cf94:	0a 16       	sub	r6,r5
8000cf96:	c8 fb       	rjmp	8000ceb4 <__avr32_f64_mul+0x30>
8000cf98:	f0 05 09 49 	lsl	r9,r8,r5
8000cf9c:	c4 20       	breq	8000d020 <__avr32_f64_mul_res_zero>
8000cf9e:	30 08       	mov	r8,0
8000cfa0:	20 25       	sub	r5,2
8000cfa2:	0a 16       	sub	r6,r5
8000cfa4:	c8 8b       	rjmp	8000ceb4 <__avr32_f64_mul+0x30>

8000cfa6 <__avr32_f64_mul_op_nan_or_inf>:
8000cfa6:	e4 19 00 0f 	andh	r9,0xf
8000cfaa:	e4 1b 00 0f 	andh	r11,0xf
8000cfae:	14 4b       	or	r11,r10
8000cfb0:	10 49       	or	r9,r8
8000cfb2:	e0 47 07 ff 	cp.w	r7,2047
8000cfb6:	c0 91       	brne	8000cfc8 <__avr32_f64_mul_op1_not_naninf>
8000cfb8:	58 0b       	cp.w	r11,0
8000cfba:	c3 81       	brne	8000d02a <__avr32_f64_mul_res_nan>
8000cfbc:	e0 46 07 ff 	cp.w	r6,2047
8000cfc0:	c3 81       	brne	8000d030 <__avr32_f64_mul_res_inf>
8000cfc2:	58 09       	cp.w	r9,0
8000cfc4:	c3 60       	breq	8000d030 <__avr32_f64_mul_res_inf>
8000cfc6:	c3 28       	rjmp	8000d02a <__avr32_f64_mul_res_nan>

8000cfc8 <__avr32_f64_mul_op1_not_naninf>:
8000cfc8:	58 09       	cp.w	r9,0
8000cfca:	c3 30       	breq	8000d030 <__avr32_f64_mul_res_inf>
8000cfcc:	c2 f8       	rjmp	8000d02a <__avr32_f64_mul_res_nan>

8000cfce <__avr32_f64_mul_res_subnormal>:
8000cfce:	5c 3c       	neg	r12
8000cfd0:	2f fc       	sub	r12,-1
8000cfd2:	f1 bc 04 c0 	satu	r12,0x6
8000cfd6:	e0 4c 00 20 	cp.w	r12,32
8000cfda:	c1 14       	brge	8000cffc <__avr32_f64_mul_res_subnormal+0x2e>
8000cfdc:	f8 08 11 20 	rsub	r8,r12,32
8000cfe0:	0e 46       	or	r6,r7
8000cfe2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000cfe6:	f4 08 09 49 	lsl	r9,r10,r8
8000cfea:	12 47       	or	r7,r9
8000cfec:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000cff0:	f6 08 09 49 	lsl	r9,r11,r8
8000cff4:	12 4a       	or	r10,r9
8000cff6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cffa:	c8 3b       	rjmp	8000cf00 <__avr32_f64_mul+0x7c>
8000cffc:	f8 08 11 20 	rsub	r8,r12,32
8000d000:	f9 b9 00 00 	moveq	r9,0
8000d004:	c0 30       	breq	8000d00a <__avr32_f64_mul_res_subnormal+0x3c>
8000d006:	f6 08 09 49 	lsl	r9,r11,r8
8000d00a:	0e 46       	or	r6,r7
8000d00c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000d010:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d014:	f3 ea 10 07 	or	r7,r9,r10
8000d018:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000d01c:	30 0b       	mov	r11,0
8000d01e:	c7 1b       	rjmp	8000cf00 <__avr32_f64_mul+0x7c>

8000d020 <__avr32_f64_mul_res_zero>:
8000d020:	1c 9b       	mov	r11,lr
8000d022:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d026:	30 0a       	mov	r10,0
8000d028:	d8 22       	popm	r4-r7,pc

8000d02a <__avr32_f64_mul_res_nan>:
8000d02a:	3f fb       	mov	r11,-1
8000d02c:	3f fa       	mov	r10,-1
8000d02e:	d8 22       	popm	r4-r7,pc

8000d030 <__avr32_f64_mul_res_inf>:
8000d030:	f0 6b 00 00 	mov	r11,-1048576
8000d034:	ed be 00 1f 	bld	lr,0x1f
8000d038:	ef bb 00 1f 	bst	r11,0x1f
8000d03c:	30 0a       	mov	r10,0
8000d03e:	d8 22       	popm	r4-r7,pc

8000d040 <__avr32_f64_mul_op1_zero>:
8000d040:	f7 e9 20 0b 	eor	r11,r11,r9
8000d044:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d048:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000d04c:	e0 4c 07 ff 	cp.w	r12,2047
8000d050:	5e 1c       	retne	r12
8000d052:	3f fa       	mov	r10,-1
8000d054:	3f fb       	mov	r11,-1
8000d056:	5e fc       	retal	r12

8000d058 <__avr32_f64_sub_from_add>:
8000d058:	ee 19 80 00 	eorh	r9,0x8000

8000d05c <__avr32_f64_sub>:
8000d05c:	f7 e9 20 0c 	eor	r12,r11,r9
8000d060:	e0 86 00 ca 	brmi	8000d1f4 <__avr32_f64_add_from_sub>
8000d064:	eb cd 40 e0 	pushm	r5-r7,lr
8000d068:	16 9c       	mov	r12,r11
8000d06a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d06e:	bf db       	cbr	r11,0x1f
8000d070:	bf d9       	cbr	r9,0x1f
8000d072:	10 3a       	cp.w	r10,r8
8000d074:	f2 0b 13 00 	cpc	r11,r9
8000d078:	c0 92       	brcc	8000d08a <__avr32_f64_sub+0x2e>
8000d07a:	16 97       	mov	r7,r11
8000d07c:	12 9b       	mov	r11,r9
8000d07e:	0e 99       	mov	r9,r7
8000d080:	14 97       	mov	r7,r10
8000d082:	10 9a       	mov	r10,r8
8000d084:	0e 98       	mov	r8,r7
8000d086:	ee 1c 80 00 	eorh	r12,0x8000
8000d08a:	f6 07 16 14 	lsr	r7,r11,0x14
8000d08e:	ab 7b       	lsl	r11,0xb
8000d090:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d094:	ab 7a       	lsl	r10,0xb
8000d096:	bf bb       	sbr	r11,0x1f
8000d098:	f2 06 16 14 	lsr	r6,r9,0x14
8000d09c:	c4 40       	breq	8000d124 <__avr32_f64_sub_opL_subnormal>
8000d09e:	ab 79       	lsl	r9,0xb
8000d0a0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d0a4:	ab 78       	lsl	r8,0xb
8000d0a6:	bf b9       	sbr	r9,0x1f

8000d0a8 <__avr32_f64_sub_opL_subnormal_done>:
8000d0a8:	e0 47 07 ff 	cp.w	r7,2047
8000d0ac:	c4 f0       	breq	8000d14a <__avr32_f64_sub_opH_nan_or_inf>
8000d0ae:	0e 26       	rsub	r6,r7
8000d0b0:	c1 20       	breq	8000d0d4 <__avr32_f64_sub_shift_done>
8000d0b2:	ec 05 11 20 	rsub	r5,r6,32
8000d0b6:	e0 46 00 20 	cp.w	r6,32
8000d0ba:	c7 c2       	brcc	8000d1b2 <__avr32_f64_sub_longshift>
8000d0bc:	f0 05 09 4e 	lsl	lr,r8,r5
8000d0c0:	f2 05 09 45 	lsl	r5,r9,r5
8000d0c4:	f0 06 0a 48 	lsr	r8,r8,r6
8000d0c8:	f2 06 0a 49 	lsr	r9,r9,r6
8000d0cc:	0a 48       	or	r8,r5
8000d0ce:	58 0e       	cp.w	lr,0
8000d0d0:	5f 1e       	srne	lr
8000d0d2:	1c 48       	or	r8,lr

8000d0d4 <__avr32_f64_sub_shift_done>:
8000d0d4:	10 1a       	sub	r10,r8
8000d0d6:	f6 09 01 4b 	sbc	r11,r11,r9
8000d0da:	f6 06 12 00 	clz	r6,r11
8000d0de:	c0 e0       	breq	8000d0fa <__avr32_f64_sub_longnormalize_done>
8000d0e0:	c7 83       	brcs	8000d1d0 <__avr32_f64_sub_longnormalize>
8000d0e2:	ec 0e 11 20 	rsub	lr,r6,32
8000d0e6:	f6 06 09 4b 	lsl	r11,r11,r6
8000d0ea:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d0ee:	1c 4b       	or	r11,lr
8000d0f0:	f4 06 09 4a 	lsl	r10,r10,r6
8000d0f4:	0c 17       	sub	r7,r6
8000d0f6:	e0 8a 00 39 	brle	8000d168 <__avr32_f64_sub_subnormal_result>

8000d0fa <__avr32_f64_sub_longnormalize_done>:
8000d0fa:	f4 09 15 15 	lsl	r9,r10,0x15
8000d0fe:	ab 9a       	lsr	r10,0xb
8000d100:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d104:	ab 9b       	lsr	r11,0xb
8000d106:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d10a:	18 4b       	or	r11,r12

8000d10c <__avr32_f64_sub_round>:
8000d10c:	fc 17 80 00 	movh	r7,0x8000
8000d110:	ed ba 00 00 	bld	r10,0x0
8000d114:	f7 b7 01 ff 	subne	r7,-1
8000d118:	0e 39       	cp.w	r9,r7
8000d11a:	5f 29       	srhs	r9
8000d11c:	12 0a       	add	r10,r9
8000d11e:	5c 0b       	acr	r11
8000d120:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d124 <__avr32_f64_sub_opL_subnormal>:
8000d124:	ab 79       	lsl	r9,0xb
8000d126:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d12a:	ab 78       	lsl	r8,0xb
8000d12c:	f3 e8 10 0e 	or	lr,r9,r8
8000d130:	f9 b6 01 01 	movne	r6,1
8000d134:	ee 0e 11 00 	rsub	lr,r7,0
8000d138:	f9 b7 00 01 	moveq	r7,1
8000d13c:	ef bb 00 1f 	bst	r11,0x1f
8000d140:	f7 ea 10 0e 	or	lr,r11,r10
8000d144:	f9 b7 00 00 	moveq	r7,0
8000d148:	cb 0b       	rjmp	8000d0a8 <__avr32_f64_sub_opL_subnormal_done>

8000d14a <__avr32_f64_sub_opH_nan_or_inf>:
8000d14a:	bf db       	cbr	r11,0x1f
8000d14c:	f7 ea 10 0e 	or	lr,r11,r10
8000d150:	c0 81       	brne	8000d160 <__avr32_f64_sub_return_nan>
8000d152:	e0 46 07 ff 	cp.w	r6,2047
8000d156:	c0 50       	breq	8000d160 <__avr32_f64_sub_return_nan>
8000d158:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000d15c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d160 <__avr32_f64_sub_return_nan>:
8000d160:	3f fa       	mov	r10,-1
8000d162:	3f fb       	mov	r11,-1
8000d164:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d168 <__avr32_f64_sub_subnormal_result>:
8000d168:	5c 37       	neg	r7
8000d16a:	2f f7       	sub	r7,-1
8000d16c:	f1 b7 04 c0 	satu	r7,0x6
8000d170:	e0 47 00 20 	cp.w	r7,32
8000d174:	c1 14       	brge	8000d196 <__avr32_f64_sub_subnormal_result+0x2e>
8000d176:	ee 08 11 20 	rsub	r8,r7,32
8000d17a:	f4 08 09 49 	lsl	r9,r10,r8
8000d17e:	5f 16       	srne	r6
8000d180:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d184:	0c 4a       	or	r10,r6
8000d186:	f6 08 09 49 	lsl	r9,r11,r8
8000d18a:	f5 e9 10 0a 	or	r10,r10,r9
8000d18e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d192:	30 07       	mov	r7,0
8000d194:	cb 3b       	rjmp	8000d0fa <__avr32_f64_sub_longnormalize_done>
8000d196:	ee 08 11 40 	rsub	r8,r7,64
8000d19a:	f6 08 09 49 	lsl	r9,r11,r8
8000d19e:	14 49       	or	r9,r10
8000d1a0:	5f 16       	srne	r6
8000d1a2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d1a6:	0c 4a       	or	r10,r6
8000d1a8:	30 0b       	mov	r11,0
8000d1aa:	30 07       	mov	r7,0
8000d1ac:	ca 7b       	rjmp	8000d0fa <__avr32_f64_sub_longnormalize_done>
8000d1ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d1b2 <__avr32_f64_sub_longshift>:
8000d1b2:	f1 b6 04 c0 	satu	r6,0x6
8000d1b6:	f0 0e 17 00 	moveq	lr,r8
8000d1ba:	c0 40       	breq	8000d1c2 <__avr32_f64_sub_longshift+0x10>
8000d1bc:	f2 05 09 4e 	lsl	lr,r9,r5
8000d1c0:	10 4e       	or	lr,r8
8000d1c2:	f2 06 0a 48 	lsr	r8,r9,r6
8000d1c6:	30 09       	mov	r9,0
8000d1c8:	58 0e       	cp.w	lr,0
8000d1ca:	5f 1e       	srne	lr
8000d1cc:	1c 48       	or	r8,lr
8000d1ce:	c8 3b       	rjmp	8000d0d4 <__avr32_f64_sub_shift_done>

8000d1d0 <__avr32_f64_sub_longnormalize>:
8000d1d0:	f4 06 12 00 	clz	r6,r10
8000d1d4:	f9 b7 03 00 	movlo	r7,0
8000d1d8:	f9 b6 03 00 	movlo	r6,0
8000d1dc:	f9 bc 03 00 	movlo	r12,0
8000d1e0:	f7 b6 02 e0 	subhs	r6,-32
8000d1e4:	f4 06 09 4b 	lsl	r11,r10,r6
8000d1e8:	30 0a       	mov	r10,0
8000d1ea:	0c 17       	sub	r7,r6
8000d1ec:	fe 9a ff be 	brle	8000d168 <__avr32_f64_sub_subnormal_result>
8000d1f0:	c8 5b       	rjmp	8000d0fa <__avr32_f64_sub_longnormalize_done>
8000d1f2:	d7 03       	nop

8000d1f4 <__avr32_f64_add_from_sub>:
8000d1f4:	ee 19 80 00 	eorh	r9,0x8000

8000d1f8 <__avr32_f64_add>:
8000d1f8:	f7 e9 20 0c 	eor	r12,r11,r9
8000d1fc:	fe 96 ff 2e 	brmi	8000d058 <__avr32_f64_sub_from_add>
8000d200:	eb cd 40 e0 	pushm	r5-r7,lr
8000d204:	16 9c       	mov	r12,r11
8000d206:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d20a:	bf db       	cbr	r11,0x1f
8000d20c:	bf d9       	cbr	r9,0x1f
8000d20e:	12 3b       	cp.w	r11,r9
8000d210:	c0 72       	brcc	8000d21e <__avr32_f64_add+0x26>
8000d212:	16 97       	mov	r7,r11
8000d214:	12 9b       	mov	r11,r9
8000d216:	0e 99       	mov	r9,r7
8000d218:	14 97       	mov	r7,r10
8000d21a:	10 9a       	mov	r10,r8
8000d21c:	0e 98       	mov	r8,r7
8000d21e:	30 0e       	mov	lr,0
8000d220:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d224:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d228:	b5 ab       	sbr	r11,0x14
8000d22a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d22e:	c6 20       	breq	8000d2f2 <__avr32_f64_add_op2_subnormal>
8000d230:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d234:	b5 a9       	sbr	r9,0x14
8000d236:	e0 47 07 ff 	cp.w	r7,2047
8000d23a:	c2 80       	breq	8000d28a <__avr32_f64_add_opH_nan_or_inf>
8000d23c:	0e 26       	rsub	r6,r7
8000d23e:	c1 20       	breq	8000d262 <__avr32_f64_add_shift_done>
8000d240:	e0 46 00 36 	cp.w	r6,54
8000d244:	c1 52       	brcc	8000d26e <__avr32_f64_add_res_of_done>
8000d246:	ec 05 11 20 	rsub	r5,r6,32
8000d24a:	e0 46 00 20 	cp.w	r6,32
8000d24e:	c3 52       	brcc	8000d2b8 <__avr32_f64_add_longshift>
8000d250:	f0 05 09 4e 	lsl	lr,r8,r5
8000d254:	f2 05 09 45 	lsl	r5,r9,r5
8000d258:	f0 06 0a 48 	lsr	r8,r8,r6
8000d25c:	f2 06 0a 49 	lsr	r9,r9,r6
8000d260:	0a 48       	or	r8,r5

8000d262 <__avr32_f64_add_shift_done>:
8000d262:	10 0a       	add	r10,r8
8000d264:	f6 09 00 4b 	adc	r11,r11,r9
8000d268:	ed bb 00 15 	bld	r11,0x15
8000d26c:	c3 40       	breq	8000d2d4 <__avr32_f64_add_res_of>

8000d26e <__avr32_f64_add_res_of_done>:
8000d26e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d272:	18 4b       	or	r11,r12

8000d274 <__avr32_f64_add_round>:
8000d274:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d278:	18 4e       	or	lr,r12
8000d27a:	ee 1e 80 00 	eorh	lr,0x8000
8000d27e:	f1 be 04 20 	satu	lr,0x1
8000d282:	1c 0a       	add	r10,lr
8000d284:	5c 0b       	acr	r11
8000d286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d28a <__avr32_f64_add_opH_nan_or_inf>:
8000d28a:	b5 cb       	cbr	r11,0x14
8000d28c:	f7 ea 10 0e 	or	lr,r11,r10
8000d290:	c1 01       	brne	8000d2b0 <__avr32_f64_add_return_nan>
8000d292:	e0 46 07 ff 	cp.w	r6,2047
8000d296:	c0 30       	breq	8000d29c <__avr32_f64_add_opL_nan_or_inf>
8000d298:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d29c <__avr32_f64_add_opL_nan_or_inf>:
8000d29c:	b5 c9       	cbr	r9,0x14
8000d29e:	f3 e8 10 0e 	or	lr,r9,r8
8000d2a2:	c0 71       	brne	8000d2b0 <__avr32_f64_add_return_nan>
8000d2a4:	30 0a       	mov	r10,0
8000d2a6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d2aa:	18 4b       	or	r11,r12
8000d2ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2b0 <__avr32_f64_add_return_nan>:
8000d2b0:	3f fa       	mov	r10,-1
8000d2b2:	3f fb       	mov	r11,-1
8000d2b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2b8 <__avr32_f64_add_longshift>:
8000d2b8:	f1 b6 04 c0 	satu	r6,0x6
8000d2bc:	f0 0e 17 00 	moveq	lr,r8
8000d2c0:	c0 60       	breq	8000d2cc <__avr32_f64_add_longshift+0x14>
8000d2c2:	f2 05 09 4e 	lsl	lr,r9,r5
8000d2c6:	58 08       	cp.w	r8,0
8000d2c8:	5f 18       	srne	r8
8000d2ca:	10 4e       	or	lr,r8
8000d2cc:	f2 06 0a 48 	lsr	r8,r9,r6
8000d2d0:	30 09       	mov	r9,0
8000d2d2:	cc 8b       	rjmp	8000d262 <__avr32_f64_add_shift_done>

8000d2d4 <__avr32_f64_add_res_of>:
8000d2d4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d2d8:	a1 9b       	lsr	r11,0x1
8000d2da:	5d 0a       	ror	r10
8000d2dc:	5d 0e       	ror	lr
8000d2de:	2f f7       	sub	r7,-1
8000d2e0:	e0 47 07 ff 	cp.w	r7,2047
8000d2e4:	f9 ba 00 00 	moveq	r10,0
8000d2e8:	f9 bb 00 00 	moveq	r11,0
8000d2ec:	f9 be 00 00 	moveq	lr,0
8000d2f0:	cb fb       	rjmp	8000d26e <__avr32_f64_add_res_of_done>

8000d2f2 <__avr32_f64_add_op2_subnormal>:
8000d2f2:	30 16       	mov	r6,1
8000d2f4:	58 07       	cp.w	r7,0
8000d2f6:	ca 01       	brne	8000d236 <__avr32_f64_add+0x3e>
8000d2f8:	b5 cb       	cbr	r11,0x14
8000d2fa:	10 0a       	add	r10,r8
8000d2fc:	f6 09 00 4b 	adc	r11,r11,r9
8000d300:	18 4b       	or	r11,r12
8000d302:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d306:	d7 03       	nop

8000d308 <__avr32_f64_to_u32>:
8000d308:	58 0b       	cp.w	r11,0
8000d30a:	5e 6d       	retmi	0

8000d30c <__avr32_f64_to_s32>:
8000d30c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d310:	b5 9c       	lsr	r12,0x15
8000d312:	e0 2c 03 ff 	sub	r12,1023
8000d316:	5e 3d       	retlo	0
8000d318:	f8 0c 11 1f 	rsub	r12,r12,31
8000d31c:	16 99       	mov	r9,r11
8000d31e:	ab 7b       	lsl	r11,0xb
8000d320:	bf bb       	sbr	r11,0x1f
8000d322:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d326:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d32a:	a1 79       	lsl	r9,0x1
8000d32c:	5e 2b       	reths	r11
8000d32e:	5c 3b       	neg	r11
8000d330:	5e fb       	retal	r11

8000d332 <__avr32_u32_to_f64>:
8000d332:	f8 cb 00 00 	sub	r11,r12,0
8000d336:	30 0c       	mov	r12,0
8000d338:	c0 38       	rjmp	8000d33e <__avr32_s32_to_f64+0x4>

8000d33a <__avr32_s32_to_f64>:
8000d33a:	18 9b       	mov	r11,r12
8000d33c:	5c 4b       	abs	r11
8000d33e:	30 0a       	mov	r10,0
8000d340:	5e 0b       	reteq	r11
8000d342:	d4 01       	pushm	lr
8000d344:	e0 69 04 1e 	mov	r9,1054
8000d348:	f6 08 12 00 	clz	r8,r11
8000d34c:	c1 70       	breq	8000d37a <__avr32_s32_to_f64+0x40>
8000d34e:	c0 c3       	brcs	8000d366 <__avr32_s32_to_f64+0x2c>
8000d350:	f0 0e 11 20 	rsub	lr,r8,32
8000d354:	f6 08 09 4b 	lsl	r11,r11,r8
8000d358:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d35c:	1c 4b       	or	r11,lr
8000d35e:	f4 08 09 4a 	lsl	r10,r10,r8
8000d362:	10 19       	sub	r9,r8
8000d364:	c0 b8       	rjmp	8000d37a <__avr32_s32_to_f64+0x40>
8000d366:	f4 08 12 00 	clz	r8,r10
8000d36a:	f9 b8 03 00 	movlo	r8,0
8000d36e:	f7 b8 02 e0 	subhs	r8,-32
8000d372:	f4 08 09 4b 	lsl	r11,r10,r8
8000d376:	30 0a       	mov	r10,0
8000d378:	10 19       	sub	r9,r8
8000d37a:	58 09       	cp.w	r9,0
8000d37c:	e0 89 00 30 	brgt	8000d3dc <__avr32_s32_to_f64+0xa2>
8000d380:	5c 39       	neg	r9
8000d382:	2f f9       	sub	r9,-1
8000d384:	e0 49 00 36 	cp.w	r9,54
8000d388:	c0 43       	brcs	8000d390 <__avr32_s32_to_f64+0x56>
8000d38a:	30 0b       	mov	r11,0
8000d38c:	30 0a       	mov	r10,0
8000d38e:	c2 68       	rjmp	8000d3da <__avr32_s32_to_f64+0xa0>
8000d390:	2f 69       	sub	r9,-10
8000d392:	f2 08 11 20 	rsub	r8,r9,32
8000d396:	e0 49 00 20 	cp.w	r9,32
8000d39a:	c0 b2       	brcc	8000d3b0 <__avr32_s32_to_f64+0x76>
8000d39c:	f4 08 09 4e 	lsl	lr,r10,r8
8000d3a0:	f6 08 09 48 	lsl	r8,r11,r8
8000d3a4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3a8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d3ac:	10 4b       	or	r11,r8
8000d3ae:	c0 88       	rjmp	8000d3be <__avr32_s32_to_f64+0x84>
8000d3b0:	f6 08 09 4e 	lsl	lr,r11,r8
8000d3b4:	14 4e       	or	lr,r10
8000d3b6:	16 9a       	mov	r10,r11
8000d3b8:	30 0b       	mov	r11,0
8000d3ba:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3be:	ed ba 00 00 	bld	r10,0x0
8000d3c2:	c0 92       	brcc	8000d3d4 <__avr32_s32_to_f64+0x9a>
8000d3c4:	1c 7e       	tst	lr,lr
8000d3c6:	c0 41       	brne	8000d3ce <__avr32_s32_to_f64+0x94>
8000d3c8:	ed ba 00 01 	bld	r10,0x1
8000d3cc:	c0 42       	brcc	8000d3d4 <__avr32_s32_to_f64+0x9a>
8000d3ce:	2f fa       	sub	r10,-1
8000d3d0:	f7 bb 02 ff 	subhs	r11,-1
8000d3d4:	5c fc       	rol	r12
8000d3d6:	5d 0b       	ror	r11
8000d3d8:	5d 0a       	ror	r10
8000d3da:	d8 02       	popm	pc
8000d3dc:	e0 68 03 ff 	mov	r8,1023
8000d3e0:	ed ba 00 0b 	bld	r10,0xb
8000d3e4:	f7 b8 00 ff 	subeq	r8,-1
8000d3e8:	10 0a       	add	r10,r8
8000d3ea:	5c 0b       	acr	r11
8000d3ec:	f7 b9 03 fe 	sublo	r9,-2
8000d3f0:	e0 49 07 ff 	cp.w	r9,2047
8000d3f4:	c0 55       	brlt	8000d3fe <__avr32_s32_to_f64+0xc4>
8000d3f6:	30 0a       	mov	r10,0
8000d3f8:	fc 1b ff e0 	movh	r11,0xffe0
8000d3fc:	c0 c8       	rjmp	8000d414 <__floatsidf_return_op1>
8000d3fe:	ed bb 00 1f 	bld	r11,0x1f
8000d402:	f7 b9 01 01 	subne	r9,1
8000d406:	ab 9a       	lsr	r10,0xb
8000d408:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d40c:	a1 7b       	lsl	r11,0x1
8000d40e:	ab 9b       	lsr	r11,0xb
8000d410:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d414 <__floatsidf_return_op1>:
8000d414:	a1 7c       	lsl	r12,0x1
8000d416:	5d 0b       	ror	r11
8000d418:	d8 02       	popm	pc

8000d41a <__avr32_f64_cmp_eq>:
8000d41a:	10 3a       	cp.w	r10,r8
8000d41c:	f2 0b 13 00 	cpc	r11,r9
8000d420:	c0 80       	breq	8000d430 <__avr32_f64_cmp_eq+0x16>
8000d422:	a1 7b       	lsl	r11,0x1
8000d424:	a1 79       	lsl	r9,0x1
8000d426:	14 4b       	or	r11,r10
8000d428:	12 4b       	or	r11,r9
8000d42a:	10 4b       	or	r11,r8
8000d42c:	5e 0f       	reteq	1
8000d42e:	5e fd       	retal	0
8000d430:	a1 7b       	lsl	r11,0x1
8000d432:	fc 1c ff e0 	movh	r12,0xffe0
8000d436:	58 0a       	cp.w	r10,0
8000d438:	f8 0b 13 00 	cpc	r11,r12
8000d43c:	5e 8f       	retls	1
8000d43e:	5e fd       	retal	0

8000d440 <__avr32_f64_cmp_ge>:
8000d440:	1a de       	st.w	--sp,lr
8000d442:	1a d7       	st.w	--sp,r7
8000d444:	a1 7b       	lsl	r11,0x1
8000d446:	5f 3c       	srlo	r12
8000d448:	a1 79       	lsl	r9,0x1
8000d44a:	5f 37       	srlo	r7
8000d44c:	5c fc       	rol	r12
8000d44e:	fc 1e ff e0 	movh	lr,0xffe0
8000d452:	58 0a       	cp.w	r10,0
8000d454:	fc 0b 13 00 	cpc	r11,lr
8000d458:	e0 8b 00 1d 	brhi	8000d492 <__avr32_f64_cmp_ge+0x52>
8000d45c:	58 08       	cp.w	r8,0
8000d45e:	fc 09 13 00 	cpc	r9,lr
8000d462:	e0 8b 00 18 	brhi	8000d492 <__avr32_f64_cmp_ge+0x52>
8000d466:	58 0b       	cp.w	r11,0
8000d468:	f5 ba 00 00 	subfeq	r10,0
8000d46c:	c1 50       	breq	8000d496 <__avr32_f64_cmp_ge+0x56>
8000d46e:	1b 07       	ld.w	r7,sp++
8000d470:	1b 0e       	ld.w	lr,sp++
8000d472:	58 3c       	cp.w	r12,3
8000d474:	c0 a0       	breq	8000d488 <__avr32_f64_cmp_ge+0x48>
8000d476:	58 1c       	cp.w	r12,1
8000d478:	c0 33       	brcs	8000d47e <__avr32_f64_cmp_ge+0x3e>
8000d47a:	5e 0f       	reteq	1
8000d47c:	5e 1d       	retne	0
8000d47e:	10 3a       	cp.w	r10,r8
8000d480:	f2 0b 13 00 	cpc	r11,r9
8000d484:	5e 2f       	reths	1
8000d486:	5e 3d       	retlo	0
8000d488:	14 38       	cp.w	r8,r10
8000d48a:	f6 09 13 00 	cpc	r9,r11
8000d48e:	5e 2f       	reths	1
8000d490:	5e 3d       	retlo	0
8000d492:	1b 07       	ld.w	r7,sp++
8000d494:	d8 0a       	popm	pc,r12=0
8000d496:	58 17       	cp.w	r7,1
8000d498:	5f 0c       	sreq	r12
8000d49a:	58 09       	cp.w	r9,0
8000d49c:	f5 b8 00 00 	subfeq	r8,0
8000d4a0:	1b 07       	ld.w	r7,sp++
8000d4a2:	1b 0e       	ld.w	lr,sp++
8000d4a4:	5e 0f       	reteq	1
8000d4a6:	5e fc       	retal	r12

8000d4a8 <__avr32_f64_cmp_lt>:
8000d4a8:	1a de       	st.w	--sp,lr
8000d4aa:	1a d7       	st.w	--sp,r7
8000d4ac:	a1 7b       	lsl	r11,0x1
8000d4ae:	5f 3c       	srlo	r12
8000d4b0:	a1 79       	lsl	r9,0x1
8000d4b2:	5f 37       	srlo	r7
8000d4b4:	5c fc       	rol	r12
8000d4b6:	fc 1e ff e0 	movh	lr,0xffe0
8000d4ba:	58 0a       	cp.w	r10,0
8000d4bc:	fc 0b 13 00 	cpc	r11,lr
8000d4c0:	e0 8b 00 1d 	brhi	8000d4fa <__avr32_f64_cmp_lt+0x52>
8000d4c4:	58 08       	cp.w	r8,0
8000d4c6:	fc 09 13 00 	cpc	r9,lr
8000d4ca:	e0 8b 00 18 	brhi	8000d4fa <__avr32_f64_cmp_lt+0x52>
8000d4ce:	58 0b       	cp.w	r11,0
8000d4d0:	f5 ba 00 00 	subfeq	r10,0
8000d4d4:	c1 50       	breq	8000d4fe <__avr32_f64_cmp_lt+0x56>
8000d4d6:	1b 07       	ld.w	r7,sp++
8000d4d8:	1b 0e       	ld.w	lr,sp++
8000d4da:	58 3c       	cp.w	r12,3
8000d4dc:	c0 a0       	breq	8000d4f0 <__avr32_f64_cmp_lt+0x48>
8000d4de:	58 1c       	cp.w	r12,1
8000d4e0:	c0 33       	brcs	8000d4e6 <__avr32_f64_cmp_lt+0x3e>
8000d4e2:	5e 0d       	reteq	0
8000d4e4:	5e 1f       	retne	1
8000d4e6:	10 3a       	cp.w	r10,r8
8000d4e8:	f2 0b 13 00 	cpc	r11,r9
8000d4ec:	5e 2d       	reths	0
8000d4ee:	5e 3f       	retlo	1
8000d4f0:	14 38       	cp.w	r8,r10
8000d4f2:	f6 09 13 00 	cpc	r9,r11
8000d4f6:	5e 2d       	reths	0
8000d4f8:	5e 3f       	retlo	1
8000d4fa:	1b 07       	ld.w	r7,sp++
8000d4fc:	d8 0a       	popm	pc,r12=0
8000d4fe:	58 17       	cp.w	r7,1
8000d500:	5f 1c       	srne	r12
8000d502:	58 09       	cp.w	r9,0
8000d504:	f5 b8 00 00 	subfeq	r8,0
8000d508:	1b 07       	ld.w	r7,sp++
8000d50a:	1b 0e       	ld.w	lr,sp++
8000d50c:	5e 0d       	reteq	0
8000d50e:	5e fc       	retal	r12

8000d510 <__avr32_f64_div>:
8000d510:	eb cd 40 ff 	pushm	r0-r7,lr
8000d514:	f7 e9 20 0e 	eor	lr,r11,r9
8000d518:	f6 07 16 14 	lsr	r7,r11,0x14
8000d51c:	a9 7b       	lsl	r11,0x9
8000d51e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d522:	a9 7a       	lsl	r10,0x9
8000d524:	bd bb       	sbr	r11,0x1d
8000d526:	e4 1b 3f ff 	andh	r11,0x3fff
8000d52a:	ab d7       	cbr	r7,0xb
8000d52c:	e0 80 00 cc 	breq	8000d6c4 <__avr32_f64_div_round_subnormal+0x54>
8000d530:	e0 47 07 ff 	cp.w	r7,2047
8000d534:	e0 84 00 b5 	brge	8000d69e <__avr32_f64_div_round_subnormal+0x2e>
8000d538:	f2 06 16 14 	lsr	r6,r9,0x14
8000d53c:	a9 79       	lsl	r9,0x9
8000d53e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d542:	a9 78       	lsl	r8,0x9
8000d544:	bd b9       	sbr	r9,0x1d
8000d546:	e4 19 3f ff 	andh	r9,0x3fff
8000d54a:	ab d6       	cbr	r6,0xb
8000d54c:	e0 80 00 e2 	breq	8000d710 <__avr32_f64_div_round_subnormal+0xa0>
8000d550:	e0 46 07 ff 	cp.w	r6,2047
8000d554:	e0 84 00 b2 	brge	8000d6b8 <__avr32_f64_div_round_subnormal+0x48>
8000d558:	0c 17       	sub	r7,r6
8000d55a:	fe 37 fc 01 	sub	r7,-1023
8000d55e:	fc 1c 80 00 	movh	r12,0x8000
8000d562:	f8 03 16 01 	lsr	r3,r12,0x1
8000d566:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d56a:	5c d4       	com	r4
8000d56c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d570:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d574:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d578:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d57c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d580:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d584:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d588:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d58c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d590:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d594:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d598:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d59c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5a0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5a4:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5a8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5ac:	02 04       	add	r4,r1
8000d5ae:	5c 05       	acr	r5
8000d5b0:	a3 65       	lsl	r5,0x2
8000d5b2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5b6:	a3 64       	lsl	r4,0x2
8000d5b8:	5c 34       	neg	r4
8000d5ba:	f8 05 01 45 	sbc	r5,r12,r5
8000d5be:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d5c2:	e4 05 07 40 	macu.d	r0,r2,r5
8000d5c6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5ca:	02 04       	add	r4,r1
8000d5cc:	5c 05       	acr	r5
8000d5ce:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5d2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d5d6:	e8 02 15 02 	lsl	r2,r4,0x2
8000d5da:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5de:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5e2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5e6:	02 04       	add	r4,r1
8000d5e8:	5c 05       	acr	r5
8000d5ea:	a3 65       	lsl	r5,0x2
8000d5ec:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5f0:	a3 64       	lsl	r4,0x2
8000d5f2:	5c 34       	neg	r4
8000d5f4:	f8 05 01 45 	sbc	r5,r12,r5
8000d5f8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d5fc:	e4 05 07 40 	macu.d	r0,r2,r5
8000d600:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d604:	02 04       	add	r4,r1
8000d606:	5c 05       	acr	r5
8000d608:	ea 03 15 02 	lsl	r3,r5,0x2
8000d60c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d610:	e8 02 15 02 	lsl	r2,r4,0x2
8000d614:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d618:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d61c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d620:	02 02       	add	r2,r1
8000d622:	5c 03       	acr	r3
8000d624:	ed b3 00 1c 	bld	r3,0x1c
8000d628:	c0 90       	breq	8000d63a <__avr32_f64_div+0x12a>
8000d62a:	a1 72       	lsl	r2,0x1
8000d62c:	5c f3       	rol	r3
8000d62e:	20 17       	sub	r7,1
8000d630:	a3 9a       	lsr	r10,0x3
8000d632:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d636:	a3 9b       	lsr	r11,0x3
8000d638:	c0 58       	rjmp	8000d642 <__avr32_f64_div+0x132>
8000d63a:	a5 8a       	lsr	r10,0x4
8000d63c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d640:	a5 8b       	lsr	r11,0x4
8000d642:	58 07       	cp.w	r7,0
8000d644:	e0 8a 00 8b 	brle	8000d75a <__avr32_f64_div_res_subnormal>
8000d648:	e0 12 ff 00 	andl	r2,0xff00
8000d64c:	e8 12 00 80 	orl	r2,0x80
8000d650:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d654:	e4 09 07 40 	macu.d	r0,r2,r9
8000d658:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d65c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d660:	00 05       	add	r5,r0
8000d662:	f0 01 00 48 	adc	r8,r8,r1
8000d666:	5c 09       	acr	r9
8000d668:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d66c:	58 04       	cp.w	r4,0
8000d66e:	5c 25       	cpc	r5

8000d670 <__avr32_f64_div_round_subnormal>:
8000d670:	f4 08 13 00 	cpc	r8,r10
8000d674:	f6 09 13 00 	cpc	r9,r11
8000d678:	5f 36       	srlo	r6
8000d67a:	f8 06 17 00 	moveq	r6,r12
8000d67e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d682:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d686:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d68a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d68e:	ed be 00 1f 	bld	lr,0x1f
8000d692:	ef bb 00 1f 	bst	r11,0x1f
8000d696:	0c 0a       	add	r10,r6
8000d698:	5c 0b       	acr	r11
8000d69a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d69e:	e4 1b 00 0f 	andh	r11,0xf
8000d6a2:	14 4b       	or	r11,r10
8000d6a4:	e0 81 00 a7 	brne	8000d7f2 <__avr32_f64_div_res_subnormal+0x98>
8000d6a8:	f2 06 16 14 	lsr	r6,r9,0x14
8000d6ac:	ab d6       	cbr	r6,0xb
8000d6ae:	e0 46 07 ff 	cp.w	r6,2047
8000d6b2:	e0 81 00 a4 	brne	8000d7fa <__avr32_f64_div_res_subnormal+0xa0>
8000d6b6:	c9 e8       	rjmp	8000d7f2 <__avr32_f64_div_res_subnormal+0x98>
8000d6b8:	e4 19 00 0f 	andh	r9,0xf
8000d6bc:	10 49       	or	r9,r8
8000d6be:	e0 81 00 9a 	brne	8000d7f2 <__avr32_f64_div_res_subnormal+0x98>
8000d6c2:	c9 28       	rjmp	8000d7e6 <__avr32_f64_div_res_subnormal+0x8c>
8000d6c4:	a3 7b       	lsl	r11,0x3
8000d6c6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d6ca:	a3 7a       	lsl	r10,0x3
8000d6cc:	f5 eb 10 04 	or	r4,r10,r11
8000d6d0:	e0 80 00 a0 	breq	8000d810 <__avr32_f64_div_op1_zero>
8000d6d4:	f6 04 12 00 	clz	r4,r11
8000d6d8:	c1 70       	breq	8000d706 <__avr32_f64_div_round_subnormal+0x96>
8000d6da:	c0 c3       	brcs	8000d6f2 <__avr32_f64_div_round_subnormal+0x82>
8000d6dc:	e8 05 11 20 	rsub	r5,r4,32
8000d6e0:	f6 04 09 4b 	lsl	r11,r11,r4
8000d6e4:	f4 05 0a 45 	lsr	r5,r10,r5
8000d6e8:	0a 4b       	or	r11,r5
8000d6ea:	f4 04 09 4a 	lsl	r10,r10,r4
8000d6ee:	08 17       	sub	r7,r4
8000d6f0:	c0 b8       	rjmp	8000d706 <__avr32_f64_div_round_subnormal+0x96>
8000d6f2:	f4 04 12 00 	clz	r4,r10
8000d6f6:	f9 b4 03 00 	movlo	r4,0
8000d6fa:	f7 b4 02 e0 	subhs	r4,-32
8000d6fe:	f4 04 09 4b 	lsl	r11,r10,r4
8000d702:	30 0a       	mov	r10,0
8000d704:	08 17       	sub	r7,r4
8000d706:	a3 8a       	lsr	r10,0x2
8000d708:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d70c:	a3 8b       	lsr	r11,0x2
8000d70e:	c1 1b       	rjmp	8000d530 <__avr32_f64_div+0x20>
8000d710:	a3 79       	lsl	r9,0x3
8000d712:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d716:	a3 78       	lsl	r8,0x3
8000d718:	f3 e8 10 04 	or	r4,r9,r8
8000d71c:	c6 f0       	breq	8000d7fa <__avr32_f64_div_res_subnormal+0xa0>
8000d71e:	f2 04 12 00 	clz	r4,r9
8000d722:	c1 70       	breq	8000d750 <__avr32_f64_div_round_subnormal+0xe0>
8000d724:	c0 c3       	brcs	8000d73c <__avr32_f64_div_round_subnormal+0xcc>
8000d726:	e8 05 11 20 	rsub	r5,r4,32
8000d72a:	f2 04 09 49 	lsl	r9,r9,r4
8000d72e:	f0 05 0a 45 	lsr	r5,r8,r5
8000d732:	0a 49       	or	r9,r5
8000d734:	f0 04 09 48 	lsl	r8,r8,r4
8000d738:	08 16       	sub	r6,r4
8000d73a:	c0 b8       	rjmp	8000d750 <__avr32_f64_div_round_subnormal+0xe0>
8000d73c:	f0 04 12 00 	clz	r4,r8
8000d740:	f9 b4 03 00 	movlo	r4,0
8000d744:	f7 b4 02 e0 	subhs	r4,-32
8000d748:	f0 04 09 49 	lsl	r9,r8,r4
8000d74c:	30 08       	mov	r8,0
8000d74e:	08 16       	sub	r6,r4
8000d750:	a3 88       	lsr	r8,0x2
8000d752:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d756:	a3 89       	lsr	r9,0x2
8000d758:	cf ca       	rjmp	8000d550 <__avr32_f64_div+0x40>

8000d75a <__avr32_f64_div_res_subnormal>:
8000d75a:	5c 37       	neg	r7
8000d75c:	2f f7       	sub	r7,-1
8000d75e:	f1 b7 04 c0 	satu	r7,0x6
8000d762:	e0 47 00 20 	cp.w	r7,32
8000d766:	c1 54       	brge	8000d790 <__avr32_f64_div_res_subnormal+0x36>
8000d768:	ee 06 11 20 	rsub	r6,r7,32
8000d76c:	e4 07 0a 42 	lsr	r2,r2,r7
8000d770:	e6 06 09 4c 	lsl	r12,r3,r6
8000d774:	18 42       	or	r2,r12
8000d776:	e6 07 0a 43 	lsr	r3,r3,r7
8000d77a:	f4 06 09 41 	lsl	r1,r10,r6
8000d77e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d782:	f6 06 09 4c 	lsl	r12,r11,r6
8000d786:	18 4a       	or	r10,r12
8000d788:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d78c:	30 00       	mov	r0,0
8000d78e:	c1 58       	rjmp	8000d7b8 <__avr32_f64_div_res_subnormal+0x5e>
8000d790:	ee 06 11 20 	rsub	r6,r7,32
8000d794:	f9 b0 00 00 	moveq	r0,0
8000d798:	f9 bc 00 00 	moveq	r12,0
8000d79c:	c0 50       	breq	8000d7a6 <__avr32_f64_div_res_subnormal+0x4c>
8000d79e:	f4 06 09 40 	lsl	r0,r10,r6
8000d7a2:	f6 06 09 4c 	lsl	r12,r11,r6
8000d7a6:	e6 07 0a 42 	lsr	r2,r3,r7
8000d7aa:	30 03       	mov	r3,0
8000d7ac:	f4 07 0a 41 	lsr	r1,r10,r7
8000d7b0:	18 41       	or	r1,r12
8000d7b2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d7b6:	30 0b       	mov	r11,0
8000d7b8:	e0 12 ff 00 	andl	r2,0xff00
8000d7bc:	e8 12 00 80 	orl	r2,0x80
8000d7c0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d7c4:	e4 09 07 46 	macu.d	r6,r2,r9
8000d7c8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d7cc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d7d0:	0c 05       	add	r5,r6
8000d7d2:	f0 07 00 48 	adc	r8,r8,r7
8000d7d6:	5c 09       	acr	r9
8000d7d8:	30 07       	mov	r7,0
8000d7da:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d7de:	00 34       	cp.w	r4,r0
8000d7e0:	e2 05 13 00 	cpc	r5,r1
8000d7e4:	c4 6b       	rjmp	8000d670 <__avr32_f64_div_round_subnormal>
8000d7e6:	1c 9b       	mov	r11,lr
8000d7e8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d7ec:	30 0a       	mov	r10,0
8000d7ee:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7f2:	3f fb       	mov	r11,-1
8000d7f4:	30 0a       	mov	r10,0
8000d7f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7fa:	f5 eb 10 04 	or	r4,r10,r11
8000d7fe:	c0 90       	breq	8000d810 <__avr32_f64_div_op1_zero>
8000d800:	1c 9b       	mov	r11,lr
8000d802:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d806:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d80a:	30 0a       	mov	r10,0
8000d80c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d810 <__avr32_f64_div_op1_zero>:
8000d810:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d814:	ce f0       	breq	8000d7f2 <__avr32_f64_div_res_subnormal+0x98>
8000d816:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d81a:	e0 44 07 ff 	cp.w	r4,2047
8000d81e:	ce 41       	brne	8000d7e6 <__avr32_f64_div_res_subnormal+0x8c>
8000d820:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d824:	ce 10       	breq	8000d7e6 <__avr32_f64_div_res_subnormal+0x8c>
8000d826:	ce 6b       	rjmp	8000d7f2 <__avr32_f64_div_res_subnormal+0x98>

8000d828 <__avr32_udiv64>:
8000d828:	d4 31       	pushm	r0-r7,lr
8000d82a:	1a 97       	mov	r7,sp
8000d82c:	20 3d       	sub	sp,12
8000d82e:	10 9c       	mov	r12,r8
8000d830:	12 9e       	mov	lr,r9
8000d832:	14 93       	mov	r3,r10
8000d834:	58 09       	cp.w	r9,0
8000d836:	e0 81 00 bd 	brne	8000d9b0 <__avr32_udiv64+0x188>
8000d83a:	16 38       	cp.w	r8,r11
8000d83c:	e0 88 00 40 	brls	8000d8bc <__avr32_udiv64+0x94>
8000d840:	f0 08 12 00 	clz	r8,r8
8000d844:	c0 d0       	breq	8000d85e <__avr32_udiv64+0x36>
8000d846:	f6 08 09 4b 	lsl	r11,r11,r8
8000d84a:	f0 09 11 20 	rsub	r9,r8,32
8000d84e:	f8 08 09 4c 	lsl	r12,r12,r8
8000d852:	f4 09 0a 49 	lsr	r9,r10,r9
8000d856:	f4 08 09 43 	lsl	r3,r10,r8
8000d85a:	f3 eb 10 0b 	or	r11,r9,r11
8000d85e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d862:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d866:	f6 0e 0d 00 	divu	r0,r11,lr
8000d86a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d86e:	00 99       	mov	r9,r0
8000d870:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d874:	e0 0a 02 48 	mul	r8,r0,r10
8000d878:	10 3b       	cp.w	r11,r8
8000d87a:	c0 a2       	brcc	8000d88e <__avr32_udiv64+0x66>
8000d87c:	20 19       	sub	r9,1
8000d87e:	18 0b       	add	r11,r12
8000d880:	18 3b       	cp.w	r11,r12
8000d882:	c0 63       	brcs	8000d88e <__avr32_udiv64+0x66>
8000d884:	10 3b       	cp.w	r11,r8
8000d886:	f7 b9 03 01 	sublo	r9,1
8000d88a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d88e:	f6 08 01 01 	sub	r1,r11,r8
8000d892:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d896:	e2 0e 0d 00 	divu	r0,r1,lr
8000d89a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d89e:	00 98       	mov	r8,r0
8000d8a0:	e0 0a 02 4a 	mul	r10,r0,r10
8000d8a4:	14 33       	cp.w	r3,r10
8000d8a6:	c0 82       	brcc	8000d8b6 <__avr32_udiv64+0x8e>
8000d8a8:	20 18       	sub	r8,1
8000d8aa:	18 03       	add	r3,r12
8000d8ac:	18 33       	cp.w	r3,r12
8000d8ae:	c0 43       	brcs	8000d8b6 <__avr32_udiv64+0x8e>
8000d8b0:	14 33       	cp.w	r3,r10
8000d8b2:	f7 b8 03 01 	sublo	r8,1
8000d8b6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d8ba:	cd f8       	rjmp	8000da78 <__avr32_udiv64+0x250>
8000d8bc:	58 08       	cp.w	r8,0
8000d8be:	c0 51       	brne	8000d8c8 <__avr32_udiv64+0xa0>
8000d8c0:	30 19       	mov	r9,1
8000d8c2:	f2 08 0d 08 	divu	r8,r9,r8
8000d8c6:	10 9c       	mov	r12,r8
8000d8c8:	f8 06 12 00 	clz	r6,r12
8000d8cc:	c0 41       	brne	8000d8d4 <__avr32_udiv64+0xac>
8000d8ce:	18 1b       	sub	r11,r12
8000d8d0:	30 19       	mov	r9,1
8000d8d2:	c4 08       	rjmp	8000d952 <__avr32_udiv64+0x12a>
8000d8d4:	ec 01 11 20 	rsub	r1,r6,32
8000d8d8:	f4 01 0a 49 	lsr	r9,r10,r1
8000d8dc:	f8 06 09 4c 	lsl	r12,r12,r6
8000d8e0:	f6 06 09 48 	lsl	r8,r11,r6
8000d8e4:	f6 01 0a 41 	lsr	r1,r11,r1
8000d8e8:	f3 e8 10 08 	or	r8,r9,r8
8000d8ec:	f8 03 16 10 	lsr	r3,r12,0x10
8000d8f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d8f4:	e2 03 0d 00 	divu	r0,r1,r3
8000d8f8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d8fc:	00 9e       	mov	lr,r0
8000d8fe:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d902:	e0 05 02 49 	mul	r9,r0,r5
8000d906:	12 3b       	cp.w	r11,r9
8000d908:	c0 a2       	brcc	8000d91c <__avr32_udiv64+0xf4>
8000d90a:	20 1e       	sub	lr,1
8000d90c:	18 0b       	add	r11,r12
8000d90e:	18 3b       	cp.w	r11,r12
8000d910:	c0 63       	brcs	8000d91c <__avr32_udiv64+0xf4>
8000d912:	12 3b       	cp.w	r11,r9
8000d914:	f7 be 03 01 	sublo	lr,1
8000d918:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d91c:	12 1b       	sub	r11,r9
8000d91e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d922:	f6 03 0d 02 	divu	r2,r11,r3
8000d926:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d92a:	04 99       	mov	r9,r2
8000d92c:	e4 05 02 4b 	mul	r11,r2,r5
8000d930:	16 38       	cp.w	r8,r11
8000d932:	c0 a2       	brcc	8000d946 <__avr32_udiv64+0x11e>
8000d934:	20 19       	sub	r9,1
8000d936:	18 08       	add	r8,r12
8000d938:	18 38       	cp.w	r8,r12
8000d93a:	c0 63       	brcs	8000d946 <__avr32_udiv64+0x11e>
8000d93c:	16 38       	cp.w	r8,r11
8000d93e:	f7 b9 03 01 	sublo	r9,1
8000d942:	f1 dc e3 08 	addcs	r8,r8,r12
8000d946:	f4 06 09 43 	lsl	r3,r10,r6
8000d94a:	f0 0b 01 0b 	sub	r11,r8,r11
8000d94e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d952:	f8 06 16 10 	lsr	r6,r12,0x10
8000d956:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d95a:	f6 06 0d 00 	divu	r0,r11,r6
8000d95e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d962:	00 9a       	mov	r10,r0
8000d964:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d968:	e0 0e 02 48 	mul	r8,r0,lr
8000d96c:	10 3b       	cp.w	r11,r8
8000d96e:	c0 a2       	brcc	8000d982 <__avr32_udiv64+0x15a>
8000d970:	20 1a       	sub	r10,1
8000d972:	18 0b       	add	r11,r12
8000d974:	18 3b       	cp.w	r11,r12
8000d976:	c0 63       	brcs	8000d982 <__avr32_udiv64+0x15a>
8000d978:	10 3b       	cp.w	r11,r8
8000d97a:	f7 ba 03 01 	sublo	r10,1
8000d97e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d982:	f6 08 01 01 	sub	r1,r11,r8
8000d986:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d98a:	e2 06 0d 00 	divu	r0,r1,r6
8000d98e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d992:	00 98       	mov	r8,r0
8000d994:	e0 0e 02 4b 	mul	r11,r0,lr
8000d998:	16 33       	cp.w	r3,r11
8000d99a:	c0 82       	brcc	8000d9aa <__avr32_udiv64+0x182>
8000d99c:	20 18       	sub	r8,1
8000d99e:	18 03       	add	r3,r12
8000d9a0:	18 33       	cp.w	r3,r12
8000d9a2:	c0 43       	brcs	8000d9aa <__avr32_udiv64+0x182>
8000d9a4:	16 33       	cp.w	r3,r11
8000d9a6:	f7 b8 03 01 	sublo	r8,1
8000d9aa:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d9ae:	c6 98       	rjmp	8000da80 <__avr32_udiv64+0x258>
8000d9b0:	16 39       	cp.w	r9,r11
8000d9b2:	e0 8b 00 65 	brhi	8000da7c <__avr32_udiv64+0x254>
8000d9b6:	f2 09 12 00 	clz	r9,r9
8000d9ba:	c0 b1       	brne	8000d9d0 <__avr32_udiv64+0x1a8>
8000d9bc:	10 3a       	cp.w	r10,r8
8000d9be:	5f 2a       	srhs	r10
8000d9c0:	1c 3b       	cp.w	r11,lr
8000d9c2:	5f b8       	srhi	r8
8000d9c4:	10 4a       	or	r10,r8
8000d9c6:	f2 0a 18 00 	cp.b	r10,r9
8000d9ca:	c5 90       	breq	8000da7c <__avr32_udiv64+0x254>
8000d9cc:	30 18       	mov	r8,1
8000d9ce:	c5 98       	rjmp	8000da80 <__avr32_udiv64+0x258>
8000d9d0:	f0 09 09 46 	lsl	r6,r8,r9
8000d9d4:	f2 03 11 20 	rsub	r3,r9,32
8000d9d8:	fc 09 09 4e 	lsl	lr,lr,r9
8000d9dc:	f0 03 0a 48 	lsr	r8,r8,r3
8000d9e0:	f6 09 09 4c 	lsl	r12,r11,r9
8000d9e4:	f4 03 0a 42 	lsr	r2,r10,r3
8000d9e8:	ef 46 ff f4 	st.w	r7[-12],r6
8000d9ec:	f6 03 0a 43 	lsr	r3,r11,r3
8000d9f0:	18 42       	or	r2,r12
8000d9f2:	f1 ee 10 0c 	or	r12,r8,lr
8000d9f6:	f8 01 16 10 	lsr	r1,r12,0x10
8000d9fa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d9fe:	e6 01 0d 04 	divu	r4,r3,r1
8000da02:	e4 03 16 10 	lsr	r3,r2,0x10
8000da06:	08 9e       	mov	lr,r4
8000da08:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000da0c:	e8 06 02 48 	mul	r8,r4,r6
8000da10:	10 33       	cp.w	r3,r8
8000da12:	c0 a2       	brcc	8000da26 <__avr32_udiv64+0x1fe>
8000da14:	20 1e       	sub	lr,1
8000da16:	18 03       	add	r3,r12
8000da18:	18 33       	cp.w	r3,r12
8000da1a:	c0 63       	brcs	8000da26 <__avr32_udiv64+0x1fe>
8000da1c:	10 33       	cp.w	r3,r8
8000da1e:	f7 be 03 01 	sublo	lr,1
8000da22:	e7 dc e3 03 	addcs	r3,r3,r12
8000da26:	10 13       	sub	r3,r8
8000da28:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000da2c:	e6 01 0d 00 	divu	r0,r3,r1
8000da30:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000da34:	00 98       	mov	r8,r0
8000da36:	e0 06 02 46 	mul	r6,r0,r6
8000da3a:	0c 3b       	cp.w	r11,r6
8000da3c:	c0 a2       	brcc	8000da50 <__avr32_udiv64+0x228>
8000da3e:	20 18       	sub	r8,1
8000da40:	18 0b       	add	r11,r12
8000da42:	18 3b       	cp.w	r11,r12
8000da44:	c0 63       	brcs	8000da50 <__avr32_udiv64+0x228>
8000da46:	0c 3b       	cp.w	r11,r6
8000da48:	f7 dc e3 0b 	addcs	r11,r11,r12
8000da4c:	f7 b8 03 01 	sublo	r8,1
8000da50:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000da54:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000da58:	0c 1b       	sub	r11,r6
8000da5a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000da5e:	06 95       	mov	r5,r3
8000da60:	16 35       	cp.w	r5,r11
8000da62:	e0 8b 00 0a 	brhi	8000da76 <__avr32_udiv64+0x24e>
8000da66:	5f 0b       	sreq	r11
8000da68:	f4 09 09 49 	lsl	r9,r10,r9
8000da6c:	12 32       	cp.w	r2,r9
8000da6e:	5f b9       	srhi	r9
8000da70:	f7 e9 00 09 	and	r9,r11,r9
8000da74:	c0 60       	breq	8000da80 <__avr32_udiv64+0x258>
8000da76:	20 18       	sub	r8,1
8000da78:	30 09       	mov	r9,0
8000da7a:	c0 38       	rjmp	8000da80 <__avr32_udiv64+0x258>
8000da7c:	30 09       	mov	r9,0
8000da7e:	12 98       	mov	r8,r9
8000da80:	10 9a       	mov	r10,r8
8000da82:	12 93       	mov	r3,r9
8000da84:	10 92       	mov	r2,r8
8000da86:	12 9b       	mov	r11,r9
8000da88:	2f dd       	sub	sp,-12
8000da8a:	d8 32       	popm	r0-r7,pc

8000da8c <__avr32_umod64>:
8000da8c:	d4 31       	pushm	r0-r7,lr
8000da8e:	1a 97       	mov	r7,sp
8000da90:	20 3d       	sub	sp,12
8000da92:	10 9c       	mov	r12,r8
8000da94:	12 95       	mov	r5,r9
8000da96:	14 9e       	mov	lr,r10
8000da98:	16 91       	mov	r1,r11
8000da9a:	16 96       	mov	r6,r11
8000da9c:	58 09       	cp.w	r9,0
8000da9e:	e0 81 00 81 	brne	8000dba0 <__avr32_umod64+0x114>
8000daa2:	16 38       	cp.w	r8,r11
8000daa4:	e0 88 00 12 	brls	8000dac8 <__avr32_umod64+0x3c>
8000daa8:	f0 08 12 00 	clz	r8,r8
8000daac:	c4 e0       	breq	8000db48 <__avr32_umod64+0xbc>
8000daae:	f6 08 09 46 	lsl	r6,r11,r8
8000dab2:	f8 08 09 4c 	lsl	r12,r12,r8
8000dab6:	f0 0b 11 20 	rsub	r11,r8,32
8000daba:	f4 08 09 4e 	lsl	lr,r10,r8
8000dabe:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000dac2:	f7 e6 10 06 	or	r6,r11,r6
8000dac6:	c4 18       	rjmp	8000db48 <__avr32_umod64+0xbc>
8000dac8:	58 08       	cp.w	r8,0
8000daca:	c0 51       	brne	8000dad4 <__avr32_umod64+0x48>
8000dacc:	30 19       	mov	r9,1
8000dace:	f2 08 0d 08 	divu	r8,r9,r8
8000dad2:	10 9c       	mov	r12,r8
8000dad4:	f8 08 12 00 	clz	r8,r12
8000dad8:	c0 31       	brne	8000dade <__avr32_umod64+0x52>
8000dada:	18 16       	sub	r6,r12
8000dadc:	c3 68       	rjmp	8000db48 <__avr32_umod64+0xbc>
8000dade:	f0 03 11 20 	rsub	r3,r8,32
8000dae2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000dae6:	f8 08 09 4c 	lsl	r12,r12,r8
8000daea:	ec 08 09 49 	lsl	r9,r6,r8
8000daee:	ec 03 0a 43 	lsr	r3,r6,r3
8000daf2:	f7 e9 10 09 	or	r9,r11,r9
8000daf6:	f8 05 16 10 	lsr	r5,r12,0x10
8000dafa:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000dafe:	e6 05 0d 02 	divu	r2,r3,r5
8000db02:	f2 0e 16 10 	lsr	lr,r9,0x10
8000db06:	ec 02 02 4b 	mul	r11,r6,r2
8000db0a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000db0e:	16 3e       	cp.w	lr,r11
8000db10:	c0 72       	brcc	8000db1e <__avr32_umod64+0x92>
8000db12:	18 0e       	add	lr,r12
8000db14:	18 3e       	cp.w	lr,r12
8000db16:	c0 43       	brcs	8000db1e <__avr32_umod64+0x92>
8000db18:	16 3e       	cp.w	lr,r11
8000db1a:	fd dc e3 0e 	addcs	lr,lr,r12
8000db1e:	fc 0b 01 03 	sub	r3,lr,r11
8000db22:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000db26:	e6 05 0d 02 	divu	r2,r3,r5
8000db2a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db2e:	a5 36       	mul	r6,r2
8000db30:	0c 39       	cp.w	r9,r6
8000db32:	c0 72       	brcc	8000db40 <__avr32_umod64+0xb4>
8000db34:	18 09       	add	r9,r12
8000db36:	18 39       	cp.w	r9,r12
8000db38:	c0 43       	brcs	8000db40 <__avr32_umod64+0xb4>
8000db3a:	0c 39       	cp.w	r9,r6
8000db3c:	f3 dc e3 09 	addcs	r9,r9,r12
8000db40:	f2 06 01 06 	sub	r6,r9,r6
8000db44:	f4 08 09 4e 	lsl	lr,r10,r8
8000db48:	f8 0a 16 10 	lsr	r10,r12,0x10
8000db4c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000db50:	ec 0a 0d 02 	divu	r2,r6,r10
8000db54:	fc 09 16 10 	lsr	r9,lr,0x10
8000db58:	ea 02 02 4b 	mul	r11,r5,r2
8000db5c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db60:	16 39       	cp.w	r9,r11
8000db62:	c0 72       	brcc	8000db70 <__avr32_umod64+0xe4>
8000db64:	18 09       	add	r9,r12
8000db66:	18 39       	cp.w	r9,r12
8000db68:	c0 43       	brcs	8000db70 <__avr32_umod64+0xe4>
8000db6a:	16 39       	cp.w	r9,r11
8000db6c:	f3 dc e3 09 	addcs	r9,r9,r12
8000db70:	f2 0b 01 0b 	sub	r11,r9,r11
8000db74:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000db78:	f6 0a 0d 0a 	divu	r10,r11,r10
8000db7c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000db80:	ea 0a 02 4a 	mul	r10,r5,r10
8000db84:	14 3e       	cp.w	lr,r10
8000db86:	c0 72       	brcc	8000db94 <__avr32_umod64+0x108>
8000db88:	18 0e       	add	lr,r12
8000db8a:	18 3e       	cp.w	lr,r12
8000db8c:	c0 43       	brcs	8000db94 <__avr32_umod64+0x108>
8000db8e:	14 3e       	cp.w	lr,r10
8000db90:	fd dc e3 0e 	addcs	lr,lr,r12
8000db94:	fc 0a 01 0a 	sub	r10,lr,r10
8000db98:	30 0b       	mov	r11,0
8000db9a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000db9e:	c7 b8       	rjmp	8000dc94 <__avr32_umod64+0x208>
8000dba0:	16 39       	cp.w	r9,r11
8000dba2:	e0 8b 00 79 	brhi	8000dc94 <__avr32_umod64+0x208>
8000dba6:	f2 09 12 00 	clz	r9,r9
8000dbaa:	c1 21       	brne	8000dbce <__avr32_umod64+0x142>
8000dbac:	10 3a       	cp.w	r10,r8
8000dbae:	5f 2b       	srhs	r11
8000dbb0:	0a 31       	cp.w	r1,r5
8000dbb2:	5f ba       	srhi	r10
8000dbb4:	f7 ea 10 0a 	or	r10,r11,r10
8000dbb8:	f2 0a 18 00 	cp.b	r10,r9
8000dbbc:	c0 60       	breq	8000dbc8 <__avr32_umod64+0x13c>
8000dbbe:	fc 08 01 0c 	sub	r12,lr,r8
8000dbc2:	e2 05 01 46 	sbc	r6,r1,r5
8000dbc6:	18 9e       	mov	lr,r12
8000dbc8:	0c 9b       	mov	r11,r6
8000dbca:	1c 9a       	mov	r10,lr
8000dbcc:	c6 48       	rjmp	8000dc94 <__avr32_umod64+0x208>
8000dbce:	ea 09 09 4c 	lsl	r12,r5,r9
8000dbd2:	f2 06 11 20 	rsub	r6,r9,32
8000dbd6:	f6 09 09 4b 	lsl	r11,r11,r9
8000dbda:	f0 09 09 42 	lsl	r2,r8,r9
8000dbde:	ef 46 ff f4 	st.w	r7[-12],r6
8000dbe2:	f0 06 0a 48 	lsr	r8,r8,r6
8000dbe6:	18 48       	or	r8,r12
8000dbe8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000dbec:	f4 09 09 43 	lsl	r3,r10,r9
8000dbf0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000dbf4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000dbf8:	16 4a       	or	r10,r11
8000dbfa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000dbfe:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc02:	f4 0c 16 10 	lsr	r12,r10,0x10
8000dc06:	08 91       	mov	r1,r4
8000dc08:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000dc0c:	e8 0e 02 46 	mul	r6,r4,lr
8000dc10:	0c 3c       	cp.w	r12,r6
8000dc12:	c0 a2       	brcc	8000dc26 <__avr32_umod64+0x19a>
8000dc14:	20 11       	sub	r1,1
8000dc16:	10 0c       	add	r12,r8
8000dc18:	10 3c       	cp.w	r12,r8
8000dc1a:	c0 63       	brcs	8000dc26 <__avr32_umod64+0x19a>
8000dc1c:	0c 3c       	cp.w	r12,r6
8000dc1e:	f7 b1 03 01 	sublo	r1,1
8000dc22:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000dc26:	0c 1c       	sub	r12,r6
8000dc28:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000dc2c:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc30:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dc34:	08 96       	mov	r6,r4
8000dc36:	e8 0e 02 4e 	mul	lr,r4,lr
8000dc3a:	1c 3b       	cp.w	r11,lr
8000dc3c:	c0 a2       	brcc	8000dc50 <__avr32_umod64+0x1c4>
8000dc3e:	20 16       	sub	r6,1
8000dc40:	10 0b       	add	r11,r8
8000dc42:	10 3b       	cp.w	r11,r8
8000dc44:	c0 63       	brcs	8000dc50 <__avr32_umod64+0x1c4>
8000dc46:	1c 3b       	cp.w	r11,lr
8000dc48:	f7 b6 03 01 	sublo	r6,1
8000dc4c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dc50:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dc54:	1c 1b       	sub	r11,lr
8000dc56:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dc5a:	00 9e       	mov	lr,r0
8000dc5c:	02 9c       	mov	r12,r1
8000dc5e:	16 3c       	cp.w	r12,r11
8000dc60:	e0 8b 00 08 	brhi	8000dc70 <__avr32_umod64+0x1e4>
8000dc64:	5f 06       	sreq	r6
8000dc66:	06 30       	cp.w	r0,r3
8000dc68:	5f ba       	srhi	r10
8000dc6a:	ed ea 00 0a 	and	r10,r6,r10
8000dc6e:	c0 60       	breq	8000dc7a <__avr32_umod64+0x1ee>
8000dc70:	fc 02 01 04 	sub	r4,lr,r2
8000dc74:	f8 08 01 4c 	sbc	r12,r12,r8
8000dc78:	08 9e       	mov	lr,r4
8000dc7a:	e6 0e 01 0a 	sub	r10,r3,lr
8000dc7e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000dc82:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000dc86:	f8 09 0a 4b 	lsr	r11,r12,r9
8000dc8a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000dc8e:	f8 01 09 4c 	lsl	r12,r12,r1
8000dc92:	18 4a       	or	r10,r12
8000dc94:	2f dd       	sub	sp,-12
8000dc96:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000de00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000de00:	c0 08       	rjmp	8000de00 <_evba>
	...

8000de04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000de04:	c0 08       	rjmp	8000de04 <_handle_TLB_Multiple_Hit>
	...

8000de08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000de08:	c0 08       	rjmp	8000de08 <_handle_Bus_Error_Data_Fetch>
	...

8000de0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000de0c:	c0 08       	rjmp	8000de0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000de10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000de10:	c0 08       	rjmp	8000de10 <_handle_NMI>
	...

8000de14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000de14:	c0 08       	rjmp	8000de14 <_handle_Instruction_Address>
	...

8000de18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000de18:	c0 08       	rjmp	8000de18 <_handle_ITLB_Protection>
	...

8000de1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000de1c:	c0 08       	rjmp	8000de1c <_handle_Breakpoint>
	...

8000de20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000de20:	c0 08       	rjmp	8000de20 <_handle_Illegal_Opcode>
	...

8000de24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000de24:	c0 08       	rjmp	8000de24 <_handle_Unimplemented_Instruction>
	...

8000de28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000de28:	c0 08       	rjmp	8000de28 <_handle_Privilege_Violation>
	...

8000de2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000de2c:	c0 08       	rjmp	8000de2c <_handle_Floating_Point>
	...

8000de30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000de30:	c0 08       	rjmp	8000de30 <_handle_Coprocessor_Absent>
	...

8000de34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000de34:	c0 08       	rjmp	8000de34 <_handle_Data_Address_Read>
	...

8000de38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000de38:	c0 08       	rjmp	8000de38 <_handle_Data_Address_Write>
	...

8000de3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000de3c:	c0 08       	rjmp	8000de3c <_handle_DTLB_Protection_Read>
	...

8000de40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000de40:	c0 08       	rjmp	8000de40 <_handle_DTLB_Protection_Write>
	...

8000de44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000de44:	c0 08       	rjmp	8000de44 <_handle_DTLB_Modified>
	...

8000de50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000de50:	c0 08       	rjmp	8000de50 <_handle_ITLB_Miss>
	...

8000de60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000de60:	c0 08       	rjmp	8000de60 <_handle_DTLB_Miss_Read>
	...

8000de70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000de70:	c0 08       	rjmp	8000de70 <_handle_DTLB_Miss_Write>
	...

8000df00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000df00:	fe cf 71 2c 	sub	pc,pc,28972

8000df04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000df04:	30 0c       	mov	r12,0
8000df06:	fe b0 c2 cd 	rcall	800064a0 <_get_interrupt_handler>
8000df0a:	58 0c       	cp.w	r12,0
8000df0c:	f8 0f 17 10 	movne	pc,r12
8000df10:	d6 03       	rete

8000df12 <_int1>:
8000df12:	30 1c       	mov	r12,1
8000df14:	fe b0 c2 c6 	rcall	800064a0 <_get_interrupt_handler>
8000df18:	58 0c       	cp.w	r12,0
8000df1a:	f8 0f 17 10 	movne	pc,r12
8000df1e:	d6 03       	rete

8000df20 <_int2>:
8000df20:	30 2c       	mov	r12,2
8000df22:	fe b0 c2 bf 	rcall	800064a0 <_get_interrupt_handler>
8000df26:	58 0c       	cp.w	r12,0
8000df28:	f8 0f 17 10 	movne	pc,r12
8000df2c:	d6 03       	rete

8000df2e <_int3>:
8000df2e:	30 3c       	mov	r12,3
8000df30:	fe b0 c2 b8 	rcall	800064a0 <_get_interrupt_handler>
8000df34:	58 0c       	cp.w	r12,0
8000df36:	f8 0f 17 10 	movne	pc,r12
8000df3a:	d6 03       	rete

8000df3c <ipr_val>:
8000df3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000df4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dffc:	d7 03 d7 03                                         ....
