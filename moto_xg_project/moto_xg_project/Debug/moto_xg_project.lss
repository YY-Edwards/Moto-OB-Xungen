
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ac34  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012d4  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e2d4  8000e2d4  0000e6d4  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000e2d8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00004918  00000a40  8000ed14  0000f240  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001680  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000035f0  00000000  00000000  000108f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c29c  00000000  00000000  00013ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007281  00000000  00000000  0004017c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d384  00000000  00000000  000473fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003cdc  00000000  00000000  00054784  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007f6d  00000000  00000000  00058460  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f267  00000000  00000000  000603cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001748  00000000  00000000  0006f638  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c4 44 	sub	pc,pc,-15292

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d a0       	ld.ub	r0,r6[0x2]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 60       	and	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3f 14       	mov	r4,-15
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b bc       	sub	r12,-69
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 c4       	sub	r4,124
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6b 6c       	ld.w	r12,r5[0x58]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6f 30       	ld.w	r0,r7[0x4c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 57       	eor	r7,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f 30       	ld.w	r0,r7[0x4c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 49       	or	r9,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6f 30       	ld.w	r0,r7[0x4c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6f 30       	ld.w	r0,r7[0x4c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6f 30       	ld.w	r0,r7[0x4c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6f 30       	ld.w	r0,r7[0x4c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6f 30       	ld.w	r0,r7[0x4c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d1 00       	acall	0x10
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6f 30       	ld.w	r0,r7[0x4c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d1 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d1 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d1 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6f 30       	ld.w	r0,r7[0x4c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d1 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d1 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d1 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d1 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d1 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d2 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 40       	acall	0x24

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d2 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6f 30       	ld.w	r0,r7[0x4c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d1 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d2 7c       	*unknown*

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 cc       	lddpc	r12,80002344 <BatteryLevel_brdcst_func+0x40>
80002318:	f0 1f 00 0c 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 cc       	lddpc	r12,8000234c <BatteryLevel_brdcst_func+0x48>
80002320:	f0 1f 00 0a 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 ac       	lddpc	r12,80002350 <BatteryLevel_brdcst_func+0x4c>
8000232a:	f0 1f 00 08 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
8000232e:	8e 98       	ld.uh	r8,r7[0x2]
80002330:	1a d8       	st.w	--sp,r8
80002332:	48 9c       	lddpc	r12,80002354 <BatteryLevel_brdcst_func+0x50>
80002334:	f0 1f 00 05 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
80002338:	0f 89       	ld.ub	r9,r7[0x0]
8000233a:	48 88       	lddpc	r8,80002358 <BatteryLevel_brdcst_func+0x54>
8000233c:	b0 89       	st.b	r8[0x0],r9
8000233e:	2f ed       	sub	sp,-8

}
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d2 98       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	6f 30       	ld.w	r0,r7[0x4c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d2 a8       	*unknown*
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	d2 bc       	*unknown*
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	d2 d4       	*unknown*
80002358:	00 00       	add	r0,r0
8000235a:	0a 41       	or	r1,r5

8000235c <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
8000235c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
8000235e:	19 a8       	ld.ub	r8,r12[0x2]
80002360:	30 19       	mov	r9,1
80002362:	f2 08 18 00 	cp.b	r8,r9
80002366:	c0 51       	brne	80002370 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002368:	48 6c       	lddpc	r12,80002380 <ShutDown_brdcst_func+0x24>
8000236a:	f0 1f 00 07 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000236e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002370:	30 29       	mov	r9,2
80002372:	f2 08 18 00 	cp.b	r8,r9
80002376:	c0 41       	brne	8000237e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002378:	48 4c       	lddpc	r12,80002388 <ShutDown_brdcst_func+0x2c>
8000237a:	f0 1f 00 03 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000237e:	d8 02       	popm	pc
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d2 ec       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	6f 30       	ld.w	r0,r7[0x4c]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d3 00       	acall	0x30

8000238c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000238c:	eb cd 40 80 	pushm	r7,lr
80002390:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002392:	19 a9       	ld.ub	r9,r12[0x2]
80002394:	30 08       	mov	r8,0
80002396:	f0 09 18 00 	cp.b	r9,r8
8000239a:	c1 11       	brne	800023bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000239c:	49 3c       	lddpc	r12,800023e8 <DataSession_reply_func+0x5c>
8000239e:	f0 1f 00 14 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023a2:	0f b8       	ld.ub	r8,r7[0x3]
800023a4:	1a d8       	st.w	--sp,r8
800023a6:	49 3c       	lddpc	r12,800023f0 <DataSession_reply_func+0x64>
800023a8:	f0 1f 00 11 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023ac:	0f c8       	ld.ub	r8,r7[0x4]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 1c       	lddpc	r12,800023f4 <DataSession_reply_func+0x68>
800023b2:	f0 1f 00 0f 	mcall	800023ec <DataSession_reply_func+0x60>
800023b6:	2f ed       	sub	sp,-8
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023bc:	48 fc       	lddpc	r12,800023f8 <DataSession_reply_func+0x6c>
800023be:	f0 1f 00 0c 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023c2:	0f a8       	ld.ub	r8,r7[0x2]
800023c4:	1a d8       	st.w	--sp,r8
800023c6:	48 ec       	lddpc	r12,800023fc <DataSession_reply_func+0x70>
800023c8:	f0 1f 00 09 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023cc:	0f b8       	ld.ub	r8,r7[0x3]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x74>
800023d2:	f0 1f 00 07 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023d6:	0f c8       	ld.ub	r8,r7[0x4]
800023d8:	1a d8       	st.w	--sp,r8
800023da:	48 bc       	lddpc	r12,80002404 <DataSession_reply_func+0x78>
800023dc:	f0 1f 00 04 	mcall	800023ec <DataSession_reply_func+0x60>
800023e0:	2f dd       	sub	sp,-12
800023e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e6:	00 00       	add	r0,r0
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d3 10       	acall	0x31
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	6f 30       	ld.w	r0,r7[0x4c]
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	d3 20       	acall	0x32
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d3 2c       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	d3 38       	*unknown*
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d3 48       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d3 58       	*unknown*
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d3 64       	*unknown*

80002408 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000240c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 bc       	lddpc	r12,80002440 <CallControl_brdcst_func+0x38>
80002416:	f0 1f 00 0c 	mcall	80002444 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000241a:	2f fd       	sub	sp,-4
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 38       	mov	r8,3
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002426:	30 09       	mov	r9,0
80002428:	48 88       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000242c:	0f 99       	ld.ub	r9,r7[0x1]
8000242e:	30 48       	mov	r8,4
80002430:	f0 09 18 00 	cp.b	r9,r8
80002434:	c0 41       	brne	8000243c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002436:	30 19       	mov	r9,1
80002438:	48 48       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000243a:	b0 89       	st.b	r8[0x0],r9
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	d3 70       	acall	0x37
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	6f 30       	ld.w	r0,r7[0x4c]
80002448:	00 00       	add	r0,r0
8000244a:	0a 4b       	or	r11,r5

8000244c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000244c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002450:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 08       	mov	r8,0
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 71       	brne	8000246a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000245e:	48 ac       	lddpc	r12,80002484 <TransmitControl_brdcst_func+0x38>
80002460:	f0 1f 00 0a 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002464:	30 09       	mov	r9,0
80002466:	48 a8       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
80002468:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000246a:	0f 99       	ld.ub	r9,r7[0x1]
8000246c:	30 18       	mov	r8,1
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c0 71       	brne	80002480 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002474:	48 7c       	lddpc	r12,80002490 <TransmitControl_brdcst_func+0x44>
80002476:	f0 1f 00 05 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000247a:	30 19       	mov	r9,1
8000247c:	48 48       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
8000247e:	b0 89       	st.b	r8[0x0],r9
80002480:	e3 cd 80 80 	ldm	sp++,r7,pc
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d3 88       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	6f 30       	ld.w	r0,r7[0x4c]
8000248c:	00 00       	add	r0,r0
8000248e:	0a 4a       	or	r10,r5
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 a0       	acall	0x3a

80002494 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 61       	brne	800024d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024a6:	48 ec       	lddpc	r12,800024dc <TransmitControl_reply_func+0x48>
800024a8:	f0 1f 00 0e 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024ac:	0f 98       	ld.ub	r8,r7[0x1]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	48 dc       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x50>
800024b2:	f0 1f 00 0c 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024b6:	0f a8       	ld.ub	r8,r7[0x2]
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 cc       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x54>
800024bc:	f0 1f 00 09 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024c0:	0f b8       	ld.ub	r8,r7[0x3]
800024c2:	1a d8       	st.w	--sp,r8
800024c4:	48 ac       	lddpc	r12,800024ec <TransmitControl_reply_func+0x58>
800024c6:	f0 1f 00 07 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024ca:	2f dd       	sub	sp,-12
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 8c       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x5c>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d3 b4       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6f 30       	ld.w	r0,r7[0x4c]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d3 d0       	acall	0x3d
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d3 e4       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d4 00       	acall	0x40
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d4 10       	acall	0x41

800024f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024f6:	19 a9       	ld.ub	r9,r12[0x2]
800024f8:	30 08       	mov	r8,0
800024fa:	f0 09 18 00 	cp.b	r9,r8
800024fe:	c0 51       	brne	80002508 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002500:	48 4c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x1c>
80002502:	f0 1f 00 05 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
80002506:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002508:	48 4c       	lddpc	r12,80002518 <AudioRoutingControl_reply_func+0x24>
8000250a:	f0 1f 00 03 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
8000250e:	d8 02       	popm	pc
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	d4 28       	*unknown*
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	6f 30       	ld.w	r0,r7[0x4c]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d4 38       	*unknown*

8000251c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 b1       	brne	80002562 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000252e:	0f b8       	ld.ub	r8,r7[0x3]
80002530:	31 09       	mov	r9,16
80002532:	f2 08 18 00 	cp.b	r8,r9
80002536:	c0 f1       	brne	80002554 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002538:	48 dc       	lddpc	r12,8000256c <Volume_reply_func+0x50>
8000253a:	f0 1f 00 0e 	mcall	80002570 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000253e:	0f 99       	ld.ub	r9,r7[0x1]
80002540:	0f a8       	ld.ub	r8,r7[0x2]
80002542:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002546:	1a d8       	st.w	--sp,r8
80002548:	48 bc       	lddpc	r12,80002574 <Volume_reply_func+0x58>
8000254a:	f0 1f 00 0a 	mcall	80002570 <Volume_reply_func+0x54>
8000254e:	2f fd       	sub	sp,-4
80002550:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 9c       	lddpc	r12,80002578 <Volume_reply_func+0x5c>
80002558:	f0 1f 00 06 	mcall	80002570 <Volume_reply_func+0x54>
8000255c:	2f fd       	sub	sp,-4
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002562:	48 7c       	lddpc	r12,8000257c <Volume_reply_func+0x60>
80002564:	f0 1f 00 03 	mcall	80002570 <Volume_reply_func+0x54>
80002568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 4c       	*unknown*
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	6f 30       	ld.w	r0,r7[0x4c]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 60       	acall	0x46
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d4 7c       	*unknown*
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d4 94       	*unknown*

80002580 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002582:	19 d9       	ld.ub	r9,r12[0x5]
80002584:	30 08       	mov	r8,0
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 81       	brne	8000259a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000258c:	10 99       	mov	r9,r8
8000258e:	48 78       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
80002590:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002592:	48 7c       	lddpc	r12,800025ac <spk_brdcst_func+0x2c>
80002594:	f0 1f 00 07 	mcall	800025b0 <spk_brdcst_func+0x30>
80002598:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000259a:	30 19       	mov	r9,1
8000259c:	48 38       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
8000259e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025a0:	48 5c       	lddpc	r12,800025b4 <spk_brdcst_func+0x34>
800025a2:	f0 1f 00 04 	mcall	800025b0 <spk_brdcst_func+0x30>
800025a6:	d8 02       	popm	pc
800025a8:	00 00       	add	r0,r0
800025aa:	0a 40       	or	r0,r5
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d4 ac       	*unknown*
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	6f 30       	ld.w	r0,r7[0x4c]
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d4 bc       	*unknown*

800025b8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ba:	19 a9       	ld.ub	r9,r12[0x2]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 f1       	brne	800025e0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025c4:	19 e9       	ld.ub	r9,r12[0x6]
800025c6:	f0 09 18 00 	cp.b	r9,r8
800025ca:	c0 40       	breq	800025d2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025cc:	30 19       	mov	r9,1
800025ce:	48 98       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025d0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025d2:	19 e8       	ld.ub	r8,r12[0x6]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	48 8c       	lddpc	r12,800025f4 <spk_reply_func+0x3c>
800025d8:	f0 1f 00 08 	mcall	800025f8 <spk_reply_func+0x40>
800025dc:	2f fd       	sub	sp,-4
800025de:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025e0:	30 09       	mov	r9,0
800025e2:	48 48       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025e4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025e6:	48 6c       	lddpc	r12,800025fc <spk_reply_func+0x44>
800025e8:	f0 1f 00 04 	mcall	800025f8 <spk_reply_func+0x40>
800025ec:	d8 02       	popm	pc
800025ee:	00 00       	add	r0,r0
800025f0:	00 00       	add	r0,r0
800025f2:	0a 40       	or	r0,r5
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d4 c8       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	6f 30       	ld.w	r0,r7[0x4c]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d4 d8       	*unknown*

80002600 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002600:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002604:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002608:	0f a9       	ld.ub	r9,r7[0x2]
8000260a:	30 08       	mov	r8,0
8000260c:	f0 09 18 00 	cp.b	r9,r8
80002610:	c0 71       	brne	8000261e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002612:	48 dc       	lddpc	r12,80002644 <mic_brdcst_func+0x44>
80002614:	f0 1f 00 0d 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 d8       	lddpc	r8,8000264c <mic_brdcst_func+0x4c>
8000261c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000261e:	0f a9       	ld.ub	r9,r7[0x2]
80002620:	31 18       	mov	r8,17
80002622:	f0 09 18 00 	cp.b	r9,r8
80002626:	c0 d1       	brne	80002640 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002628:	48 ac       	lddpc	r12,80002650 <mic_brdcst_func+0x50>
8000262a:	f0 1f 00 08 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000262e:	48 89       	lddpc	r9,8000264c <mic_brdcst_func+0x4c>
80002630:	30 18       	mov	r8,1
80002632:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002634:	13 89       	ld.ub	r9,r9[0x0]
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 31       	brne	80002640 <mic_brdcst_func+0x40>
8000263c:	48 68       	lddpc	r8,80002654 <mic_brdcst_func+0x54>
8000263e:	11 88       	ld.ub	r8,r8[0x0]
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d4 e4       	*unknown*
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	6f 30       	ld.w	r0,r7[0x4c]
8000264c:	00 00       	add	r0,r0
8000264e:	0a 56       	eor	r6,r5
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 f8       	*unknown*
80002654:	00 00       	add	r0,r0
80002656:	0a 4b       	or	r11,r5

80002658 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002658:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000265c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002660:	49 ac       	lddpc	r12,800026c8 <mic_reply_func+0x70>
80002662:	f0 1f 00 1b 	mcall	800026cc <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002666:	0f 89       	ld.ub	r9,r7[0x0]
80002668:	30 08       	mov	r8,0
8000266a:	f0 09 18 00 	cp.b	r9,r8
8000266e:	c2 71       	brne	800026bc <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002670:	0f 98       	ld.ub	r8,r7[0x1]
80002672:	30 29       	mov	r9,2
80002674:	f2 08 18 00 	cp.b	r8,r9
80002678:	c1 b1       	brne	800026ae <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000267a:	49 6c       	lddpc	r12,800026d0 <mic_reply_func+0x78>
8000267c:	f0 1f 00 14 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002680:	0f a8       	ld.ub	r8,r7[0x2]
80002682:	1a d8       	st.w	--sp,r8
80002684:	49 4c       	lddpc	r12,800026d4 <mic_reply_func+0x7c>
80002686:	f0 1f 00 12 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000268a:	0f b8       	ld.ub	r8,r7[0x3]
8000268c:	1a d8       	st.w	--sp,r8
8000268e:	49 3c       	lddpc	r12,800026d8 <mic_reply_func+0x80>
80002690:	f0 1f 00 0f 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002694:	0f c8       	ld.ub	r8,r7[0x4]
80002696:	1a d8       	st.w	--sp,r8
80002698:	49 1c       	lddpc	r12,800026dc <mic_reply_func+0x84>
8000269a:	f0 1f 00 0d 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000269e:	0f d8       	ld.ub	r8,r7[0x5]
800026a0:	1a d8       	st.w	--sp,r8
800026a2:	49 0c       	lddpc	r12,800026e0 <mic_reply_func+0x88>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_reply_func+0x74>
800026a8:	2f cd       	sub	sp,-16
800026aa:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ae:	1a d8       	st.w	--sp,r8
800026b0:	48 dc       	lddpc	r12,800026e4 <mic_reply_func+0x8c>
800026b2:	f0 1f 00 07 	mcall	800026cc <mic_reply_func+0x74>
800026b6:	2f fd       	sub	sp,-4
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026bc:	48 bc       	lddpc	r12,800026e8 <mic_reply_func+0x90>
800026be:	f0 1f 00 04 	mcall	800026cc <mic_reply_func+0x74>
800026c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c6:	00 00       	add	r0,r0
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d5 0c       	*unknown*
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	6f 30       	ld.w	r0,r7[0x4c]
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d5 1c       	*unknown*
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d5 30       	acall	0x53
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d5 44       	*unknown*
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d5 60       	acall	0x56
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d5 78       	*unknown*
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	d5 90       	acall	0x59
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	d5 a8       	*unknown*

800026ec <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f4:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x34>
800026f6:	f0 1f 00 0c 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026fa:	0f 88       	ld.ub	r8,r7[0x0]
800026fc:	1a d8       	st.w	--sp,r8
800026fe:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x3c>
80002700:	f0 1f 00 09 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	48 9c       	lddpc	r12,8000272c <dcm_brdcst_func+0x40>
8000270a:	f0 1f 00 07 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000270e:	0f 98       	ld.ub	r8,r7[0x1]
80002710:	1a d8       	st.w	--sp,r8
80002712:	48 8c       	lddpc	r12,80002730 <dcm_brdcst_func+0x44>
80002714:	f0 1f 00 04 	mcall	80002724 <dcm_brdcst_func+0x38>
80002718:	2f dd       	sub	sp,-12
	
	
}
8000271a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271e:	00 00       	add	r0,r0
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d5 b8       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	6f 30       	ld.w	r0,r7[0x4c]
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d5 cc       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	d5 e0       	acall	0x5e
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d5 f8       	*unknown*

80002734 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002734:	eb cd 40 80 	pushm	r7,lr
80002738:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000273a:	19 a9       	ld.ub	r9,r12[0x2]
8000273c:	30 08       	mov	r8,0
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c1 b1       	brne	80002778 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002744:	19 b8       	ld.ub	r8,r12[0x3]
80002746:	30 19       	mov	r9,1
80002748:	f2 08 18 00 	cp.b	r8,r9
8000274c:	c0 51       	brne	80002756 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000274e:	48 ec       	lddpc	r12,80002784 <dcm_reply_func+0x50>
80002750:	f0 1f 00 0e 	mcall	80002788 <dcm_reply_func+0x54>
80002754:	c0 a8       	rjmp	80002768 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002756:	58 08       	cp.w	r8,0
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000275a:	48 dc       	lddpc	r12,8000278c <dcm_reply_func+0x58>
8000275c:	f0 1f 00 0b 	mcall	80002788 <dcm_reply_func+0x54>
80002760:	c0 48       	rjmp	80002768 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002762:	48 cc       	lddpc	r12,80002790 <dcm_reply_func+0x5c>
80002764:	f0 1f 00 09 	mcall	80002788 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002768:	0f d8       	ld.ub	r8,r7[0x5]
8000276a:	1a d8       	st.w	--sp,r8
8000276c:	48 ac       	lddpc	r12,80002794 <dcm_reply_func+0x60>
8000276e:	f0 1f 00 07 	mcall	80002788 <dcm_reply_func+0x54>
80002772:	2f fd       	sub	sp,-4
80002774:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002778:	48 8c       	lddpc	r12,80002798 <dcm_reply_func+0x64>
8000277a:	f0 1f 00 04 	mcall	80002788 <dcm_reply_func+0x54>
8000277e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002782:	00 00       	add	r0,r0
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d6 14       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	6f 30       	ld.w	r0,r7[0x4c]
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d6 28       	*unknown*
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d6 3c       	*unknown*
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d6 50       	acall	0x65
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d6 5c       	*unknown*

8000279c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000279e:	19 a9       	ld.ub	r9,r12[0x2]
800027a0:	30 08       	mov	r8,0
800027a2:	f0 09 18 00 	cp.b	r9,r8
800027a6:	c0 51       	brne	800027b0 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x1c>
800027aa:	f0 1f 00 05 	mcall	800027bc <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x24>
800027b2:	f0 1f 00 03 	mcall	800027bc <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d6 68       	*unknown*
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	6f 30       	ld.w	r0,r7[0x4c]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	d6 74       	*unknown*

800027c4 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027c4:	d4 31       	pushm	r0-r7,lr
800027c6:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c8:	31 ac       	mov	r12,26
800027ca:	f0 1f 00 29 	mcall	8000286c <app_cfg+0xa8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 29 	mcall	80002870 <app_cfg+0xac>
800027d2:	4a 98       	lddpc	r8,80002874 <app_cfg+0xb0>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
800027d6:	4a 97       	lddpc	r7,80002878 <app_cfg+0xb4>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027d8:	4a 96       	lddpc	r6,8000287c <app_cfg+0xb8>
				else
				{
					nop();
					nop();
					nop();
					log("connecting...\n");
800027da:	4a a5       	lddpc	r5,80002880 <app_cfg+0xbc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027dc:	4a a4       	lddpc	r4,80002884 <app_cfg+0xc0>
				{
					connect_flag=1;
800027de:	30 13       	mov	r3,1
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027e0:	30 c2       	mov	r2,12
800027e2:	30 11       	mov	r1,1
					OB_State = OB_WAITINGAPPTASK;
800027e4:	30 30       	mov	r0,3
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	58 08       	cp.w	r8,0
800027ea:	c0 40       	breq	800027f2 <app_cfg+0x2e>
800027ec:	58 38       	cp.w	r8,3
800027ee:	c3 91       	brne	80002860 <app_cfg+0x9c>
800027f0:	c1 a8       	rjmp	80002824 <app_cfg+0x60>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	6c 08       	ld.w	r8,r6[0x0]
800027f4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f8:	58 38       	cp.w	r8,3
800027fa:	c0 e1       	brne	80002816 <app_cfg+0x52>
800027fc:	09 88       	ld.ub	r8,r4[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c0 b1       	brne	80002816 <app_cfg+0x52>
				{
					connect_flag=1;
80002802:	a8 83       	st.b	r4[0x0],r3
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	04 9b       	mov	r11,r2
80002806:	02 9c       	mov	r12,r1
80002808:	f0 1f 00 20 	mcall	80002888 <app_cfg+0xc4>
					OB_State = OB_WAITINGAPPTASK;
8000280c:	8f 00       	st.w	r7[0x0],r0
					log("connect OB okay!\n");
8000280e:	4a 0c       	lddpc	r12,8000288c <app_cfg+0xc8>
80002810:	f0 1f 00 20 	mcall	80002890 <app_cfg+0xcc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002814:	c2 68       	rjmp	80002860 <app_cfg+0x9c>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002816:	d7 03       	nop
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					log("connecting...\n");
8000281c:	0a 9c       	mov	r12,r5
8000281e:	f0 1f 00 1d 	mcall	80002890 <app_cfg+0xcc>
80002822:	c1 f8       	rjmp	80002860 <app_cfg+0x9c>
				}
								
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002824:	49 c8       	lddpc	r8,80002894 <app_cfg+0xd0>
80002826:	70 0c       	ld.w	r12,r8[0x0]
80002828:	30 09       	mov	r9,0
8000282a:	e0 6a 0f a0 	mov	r10,4000
8000282e:	1a 9b       	mov	r11,sp
80002830:	f0 1f 00 1a 	mcall	80002898 <app_cfg+0xd4>
80002834:	58 1c       	cp.w	r12,1
80002836:	c1 11       	brne	80002858 <app_cfg+0x94>
					{
						if(data_ptr!=NULL){//resend message
80002838:	40 08       	lddsp	r8,sp[0x0]
8000283a:	58 08       	cp.w	r8,0
8000283c:	c0 e0       	breq	80002858 <app_cfg+0x94>
							
							log("receive Okay!\n");						
8000283e:	49 8c       	lddpc	r12,8000289c <app_cfg+0xd8>
80002840:	f0 1f 00 14 	mcall	80002890 <app_cfg+0xcc>
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
80002844:	30 9a       	mov	r10,9
80002846:	31 ab       	mov	r11,26
80002848:	40 0c       	lddsp	r12,sp[0x0]
8000284a:	f0 1f 00 16 	mcall	800028a0 <app_cfg+0xdc>
							set_message_store(data_ptr);
8000284e:	49 68       	lddpc	r8,800028a4 <app_cfg+0xe0>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	40 0b       	lddsp	r11,sp[0x0]
80002854:	f0 1f 00 15 	mcall	800028a8 <app_cfg+0xe4>
							
						}
						
					}
										
					nop();
80002858:	d7 03       	nop
					log("app task run!\n");
8000285a:	49 5c       	lddpc	r12,800028ac <app_cfg+0xe8>
8000285c:	f0 1f 00 0d 	mcall	80002890 <app_cfg+0xcc>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002860:	e0 6b 0f a0 	mov	r11,4000
80002864:	48 4c       	lddpc	r12,80002874 <app_cfg+0xb0>
80002866:	f0 1f 00 13 	mcall	800028b0 <app_cfg+0xec>
	}
8000286a:	cb eb       	rjmp	800027e6 <app_cfg+0x22>
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	5f 8c       	srls	r12
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	68 5c       	ld.w	r12,r4[0x14]
80002874:	00 00       	add	r0,r0
80002876:	0a 44       	or	r4,r5
80002878:	00 00       	add	r0,r0
8000287a:	0a 58       	eor	r8,r5
8000287c:	00 00       	add	r0,r0
8000287e:	0d a0       	ld.ub	r0,r6[0x2]
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	d6 94       	*unknown*
80002884:	00 00       	add	r0,r0
80002886:	0a 55       	eor	r5,r5
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	40 a0       	lddsp	r0,sp[0x28]
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d6 80       	acall	0x68
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	6f 30       	ld.w	r0,r7[0x4c]
80002894:	00 00       	add	r0,r0
80002896:	0b 70       	ld.ub	r0,--r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	60 d4       	ld.w	r4,r0[0x34]
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d6 a4       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	3f 68       	mov	r8,-10
800028a4:	00 00       	add	r0,r0
800028a6:	0b 78       	ld.ub	r8,--r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2c 3c       	sub	r12,-61
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	d6 b4       	*unknown*
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	6a 0c       	ld.w	r12,r5[0x0]

800028b4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800028b4:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800028b8:	19 c7       	ld.ub	r7,r12[0x4]
800028ba:	19 d8       	ld.ub	r8,r12[0x5]
800028bc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800028c0:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800028c2:	48 dc       	lddpc	r12,800028f4 <Phyuserinput_brdcst_func+0x40>
800028c4:	f0 1f 00 0d 	mcall	800028f8 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800028c8:	36 08       	mov	r8,96
800028ca:	f0 07 19 00 	cp.h	r7,r8
800028ce:	c1 11       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
800028d0:	48 b8       	lddpc	r8,800028fc <Phyuserinput_brdcst_func+0x48>
800028d2:	11 89       	ld.ub	r9,r8[0x0]
800028d4:	30 18       	mov	r8,1
800028d6:	f0 09 18 00 	cp.b	r9,r8
800028da:	c0 b1       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028dc:	31 4b       	mov	r11,20
800028de:	30 1c       	mov	r12,1
800028e0:	f0 1f 00 08 	mcall	80002900 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
800028e4:	e0 6c 01 90 	mov	r12,400
800028e8:	f0 1f 00 07 	mcall	80002904 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028ec:	f0 1f 00 07 	mcall	80002908 <Phyuserinput_brdcst_func+0x54>
800028f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d6 c4       	*unknown*
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	6f 30       	ld.w	r0,r7[0x4c]
800028fc:	00 00       	add	r0,r0
800028fe:	0a 55       	eor	r5,r5
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	40 a0       	lddsp	r0,sp[0x28]
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	69 c4       	ld.w	r4,r4[0x70]
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	50 e0       	stdsp	sp[0x38],r0

8000290c <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000290c:	d4 21       	pushm	r4-r7,lr
8000290e:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002910:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002914:	0d 88       	ld.ub	r8,r6[0x0]
80002916:	32 49       	mov	r9,36
80002918:	f2 08 18 00 	cp.b	r8,r9
8000291c:	c2 91       	brne	8000296e <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000291e:	4a ec       	lddpc	r12,800029d4 <DataSession_brdcst_func+0xc8>
80002920:	f0 1f 00 2e 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002924:	0d a5       	ld.ub	r5,r6[0x2]
80002926:	0d b8       	ld.ub	r8,r6[0x3]
80002928:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000292c:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000292e:	0d 98       	ld.ub	r8,r6[0x1]
80002930:	1a d8       	st.w	--sp,r8
80002932:	4a bc       	lddpc	r12,800029dc <DataSession_brdcst_func+0xd0>
80002934:	f0 1f 00 29 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002938:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	4a 9c       	lddpc	r12,800029e0 <DataSession_brdcst_func+0xd4>
80002940:	f0 1f 00 26 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		for(i=0; i<data_length; i++)
80002944:	2f ed       	sub	sp,-8
80002946:	58 05       	cp.w	r5,0
80002948:	c4 30       	breq	800029ce <DataSession_brdcst_func+0xc2>
8000294a:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000294c:	4a 64       	lddpc	r4,800029e4 <DataSession_brdcst_func+0xd8>
8000294e:	ec 07 00 08 	add	r8,r6,r7
80002952:	11 c8       	ld.ub	r8,r8[0x4]
80002954:	1a d8       	st.w	--sp,r8
80002956:	1a d7       	st.w	--sp,r7
80002958:	08 9c       	mov	r12,r4
8000295a:	f0 1f 00 20 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000295e:	2f f7       	sub	r7,-1
80002960:	5c 57       	castu.b	r7
80002962:	2f ed       	sub	sp,-8
80002964:	ee 05 19 00 	cp.h	r5,r7
80002968:	fe 9b ff f3 	brhi	8000294e <DataSession_brdcst_func+0x42>
8000296c:	c3 18       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000296e:	1a d8       	st.w	--sp,r8
80002970:	49 ec       	lddpc	r12,800029e8 <DataSession_brdcst_func+0xdc>
80002972:	f0 1f 00 1a 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002976:	0d 88       	ld.ub	r8,r6[0x0]
80002978:	2f fd       	sub	sp,-4
8000297a:	30 39       	mov	r9,3
8000297c:	f2 08 18 00 	cp.b	r8,r9
80002980:	c0 51       	brne	8000298a <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002982:	49 bc       	lddpc	r12,800029ec <DataSession_brdcst_func+0xe0>
80002984:	f0 1f 00 15 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
80002988:	c2 38       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000298a:	30 49       	mov	r9,4
8000298c:	f2 08 18 00 	cp.b	r8,r9
80002990:	c1 f1       	brne	800029ce <DataSession_brdcst_func+0xc2>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002992:	31 aa       	mov	r10,26
80002994:	ec cb ff fc 	sub	r11,r6,-4
80002998:	fa cc ff fe 	sub	r12,sp,-2
8000299c:	f0 1f 00 15 	mcall	800029f0 <DataSession_brdcst_func+0xe4>

			Message_Protocol_t * myptr = get_message_store();	
800029a0:	49 58       	lddpc	r8,800029f4 <DataSession_brdcst_func+0xe8>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 15 	mcall	800029f8 <DataSession_brdcst_func+0xec>
800029a8:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
800029aa:	c0 f0       	breq	800029c8 <DataSession_brdcst_func+0xbc>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800029ac:	31 aa       	mov	r10,26
800029ae:	fa cb ff fe 	sub	r11,sp,-2
800029b2:	f0 1f 00 10 	mcall	800029f0 <DataSession_brdcst_func+0xe4>
				xQueueSend(xg_resend_queue, &myptr, 0);
800029b6:	49 28       	lddpc	r8,800029fc <DataSession_brdcst_func+0xf0>
800029b8:	70 0c       	ld.w	r12,r8[0x0]
800029ba:	30 09       	mov	r9,0
800029bc:	12 9a       	mov	r10,r9
800029be:	fa cb ff e4 	sub	r11,sp,-28
800029c2:	f0 1f 00 10 	mcall	80002a00 <DataSession_brdcst_func+0xf4>
800029c6:	c0 48       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
			}
			else
			{
				log("myptr: err\n\r" );
800029c8:	48 fc       	lddpc	r12,80002a04 <DataSession_brdcst_func+0xf8>
800029ca:	f0 1f 00 04 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
				//
		//}
		
	}
	
}
800029ce:	2f 8d       	sub	sp,-32
800029d0:	d8 22       	popm	r4-r7,pc
800029d2:	00 00       	add	r0,r0
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	d6 e4       	*unknown*
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	6f 30       	ld.w	r0,r7[0x4c]
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	d6 f8       	*unknown*
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	d7 10       	acall	0x71
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	d7 2c       	*unknown*
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	d7 44       	*unknown*
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	d7 50       	acall	0x75
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	77 ac       	ld.w	r12,r11[0x68]
800029f4:	00 00       	add	r0,r0
800029f6:	0b 78       	ld.ub	r8,--r5
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	2d e8       	sub	r8,-34
800029fc:	00 00       	add	r0,r0
800029fe:	0b 70       	ld.ub	r0,--r5
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	62 e0       	ld.w	r0,r1[0x38]
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	d7 68       	*unknown*

80002a08 <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a08:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a0a:	19 e8       	ld.ub	r8,r12[0x6]
80002a0c:	30 19       	mov	r9,1
80002a0e:	f2 08 18 00 	cp.b	r8,r9
80002a12:	c0 61       	brne	80002a1e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a14:	48 98       	lddpc	r8,80002a38 <DeviceInitializationStatus_brdcst_func+0x30>
80002a16:	70 09       	ld.w	r9,r8[0x0]
80002a18:	a1 a9       	sbr	r9,0x0
80002a1a:	91 09       	st.w	r8[0x0],r9
80002a1c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a1e:	30 29       	mov	r9,2
80002a20:	f2 08 18 00 	cp.b	r8,r9
80002a24:	c0 80       	breq	80002a34 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a26:	48 58       	lddpc	r8,80002a38 <DeviceInitializationStatus_brdcst_func+0x30>
80002a28:	70 09       	ld.w	r9,r8[0x0]
80002a2a:	e0 19 ff fc 	andl	r9,0xfffc
80002a2e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a30:	f0 1f 00 03 	mcall	80002a3c <DeviceInitializationStatus_brdcst_func+0x34>
80002a34:	d8 02       	popm	pc
80002a36:	00 00       	add	r0,r0
80002a38:	00 00       	add	r0,r0
80002a3a:	0d a0       	ld.ub	r0,r6[0x2]
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	3f f4       	mov	r4,-1

80002a40 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80002a40:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80002a42:	48 78       	lddpc	r8,80002a5c <W25Q64_SPI_SetSpeed+0x1c>
80002a44:	70 09       	ld.w	r9,r8[0x0]
80002a46:	72 da       	ld.w	r10,r9[0x34]
80002a48:	5c 7c       	castu.h	r12
80002a4a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002a4e:	f9 ea 10 0a 	or	r10,r12,r10
80002a52:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80002a54:	70 0c       	ld.w	r12,r8[0x0]
80002a56:	f0 1f 00 03 	mcall	80002a60 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
80002a5a:	d8 02       	popm	pc
80002a5c:	00 00       	add	r0,r0
80002a5e:	1d ac       	ld.ub	r12,lr[0x2]
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	57 d0       	stdsp	sp[0x1f4],r0

80002a64 <W25Q64_SPI_SetSpeedHi>:
{
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
	
}
void W25Q64_SPI_SetSpeedHi(void)
{
80002a64:	d4 01       	pushm	lr
	
	W25Q64_SPI_SetSpeed(0x0100);//baudDiv=1
80002a66:	e0 6c 01 00 	mov	r12,256
80002a6a:	f0 1f 00 02 	mcall	80002a70 <W25Q64_SPI_SetSpeedHi+0xc>
	
}
80002a6e:	d8 02       	popm	pc
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	2a 40       	sub	r0,-92

80002a74 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002a74:	eb cd 40 c0 	pushm	r6-r7,lr
80002a78:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80002a7a:	4b a8       	lddpc	r8,80002b60 <data_flash_init+0xec>
80002a7c:	fa c6 ff fc 	sub	r6,sp,-4
80002a80:	f0 ea 00 00 	ld.d	r10,r8[0]
80002a84:	ec eb 00 00 	st.d	r6[0],r10
80002a88:	f0 e8 00 08 	ld.d	r8,r8[8]
80002a8c:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002a90:	30 4b       	mov	r11,4
80002a92:	4b 5c       	lddpc	r12,80002b64 <data_flash_init+0xf0>
80002a94:	f0 1f 00 35 	mcall	80002b68 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80002a98:	4b 57       	lddpc	r7,80002b6c <data_flash_init+0xf8>
80002a9a:	fe 7c 24 00 	mov	r12,-56320
80002a9e:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002aa0:	0c 9b       	mov	r11,r6
80002aa2:	f0 1f 00 34 	mcall	80002b70 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002aa6:	30 09       	mov	r9,0
80002aa8:	12 9a       	mov	r10,r9
80002aaa:	12 9b       	mov	r11,r9
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 32 	mcall	80002b74 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
80002ab2:	6e 0c       	ld.w	r12,r7[0x0]
80002ab4:	f0 1f 00 31 	mcall	80002b78 <data_flash_init+0x104>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002ab8:	e0 6a 36 00 	mov	r10,13824
80002abc:	ea 1a 01 6e 	orh	r10,0x16e
80002ac0:	0c 9b       	mov	r11,r6
80002ac2:	6e 0c       	ld.w	r12,r7[0x0]
80002ac4:	f0 1f 00 2e 	mcall	80002b7c <data_flash_init+0x108>
80002ac8:	c0 50       	breq	80002ad2 <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002aca:	30 29       	mov	r9,2
80002acc:	4a d8       	lddpc	r8,80002b80 <data_flash_init+0x10c>
80002ace:	b0 89       	st.b	r8[0x0],r9
		return;
80002ad0:	c4 58       	rjmp	80002b5a <data_flash_init+0xe6>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002ad2:	1a 96       	mov	r6,sp
80002ad4:	30 4a       	mov	r10,4
80002ad6:	4a cb       	lddpc	r11,80002b84 <data_flash_init+0x110>
80002ad8:	1a 9c       	mov	r12,sp
80002ada:	f0 1f 00 2c 	mcall	80002b88 <data_flash_init+0x114>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80002ade:	4a 47       	lddpc	r7,80002b6c <data_flash_init+0xf8>
80002ae0:	30 1b       	mov	r11,1
80002ae2:	6e 0c       	ld.w	r12,r7[0x0]
80002ae4:	f0 1f 00 2a 	mcall	80002b8c <data_flash_init+0x118>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80002ae8:	e0 6b 00 90 	mov	r11,144
80002aec:	6e 0c       	ld.w	r12,r7[0x0]
80002aee:	f0 1f 00 29 	mcall	80002b90 <data_flash_init+0x11c>
	spi_write_zero();
80002af2:	30 0b       	mov	r11,0
80002af4:	6e 0c       	ld.w	r12,r7[0x0]
80002af6:	f0 1f 00 27 	mcall	80002b90 <data_flash_init+0x11c>
	spi_write_zero();
80002afa:	30 0b       	mov	r11,0
80002afc:	6e 0c       	ld.w	r12,r7[0x0]
80002afe:	f0 1f 00 25 	mcall	80002b90 <data_flash_init+0x11c>
	spi_write_zero();
80002b02:	30 0b       	mov	r11,0
80002b04:	6e 0c       	ld.w	r12,r7[0x0]
80002b06:	f0 1f 00 23 	mcall	80002b90 <data_flash_init+0x11c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80002b0a:	e0 6b 00 ff 	mov	r11,255
80002b0e:	6e 0c       	ld.w	r12,r7[0x0]
80002b10:	f0 1f 00 20 	mcall	80002b90 <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[0]);
80002b14:	1a 9b       	mov	r11,sp
80002b16:	6e 0c       	ld.w	r12,r7[0x0]
80002b18:	f0 1f 00 1f 	mcall	80002b94 <data_flash_init+0x120>
	
	spi_write_dummy();
80002b1c:	e0 6b 00 ff 	mov	r11,255
80002b20:	6e 0c       	ld.w	r12,r7[0x0]
80002b22:	f0 1f 00 1c 	mcall	80002b90 <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[1]);
80002b26:	fa cb ff fe 	sub	r11,sp,-2
80002b2a:	6e 0c       	ld.w	r12,r7[0x0]
80002b2c:	f0 1f 00 1a 	mcall	80002b94 <data_flash_init+0x120>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b30:	30 1b       	mov	r11,1
80002b32:	6e 0c       	ld.w	r12,r7[0x0]
80002b34:	f0 1f 00 19 	mcall	80002b98 <data_flash_init+0x124>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002b38:	e0 68 00 ef 	mov	r8,239
80002b3c:	9a 09       	ld.sh	r9,sp[0x0]
80002b3e:	f0 09 19 00 	cp.h	r9,r8
80002b42:	c0 61       	brne	80002b4e <data_flash_init+0xda>
80002b44:	31 68       	mov	r8,22
80002b46:	9a 19       	ld.sh	r9,sp[0x2]
80002b48:	f0 09 19 00 	cp.h	r9,r8
80002b4c:	c0 50       	breq	80002b56 <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002b4e:	30 39       	mov	r9,3
80002b50:	48 c8       	lddpc	r8,80002b80 <data_flash_init+0x10c>
80002b52:	b0 89       	st.b	r8[0x0],r9
		return;
80002b54:	c0 38       	rjmp	80002b5a <data_flash_init+0xe6>
	}

	W25Q64_SPI_SetSpeedHi();
80002b56:	f0 1f 00 12 	mcall	80002b9c <data_flash_init+0x128>
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80002b5a:	2f bd       	sub	sp,-20
80002b5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	d7 9c       	*unknown*
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	d7 78       	*unknown*
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	54 6c       	stdsp	sp[0x118],r12
80002b6c:	00 00       	add	r0,r0
80002b6e:	1d ac       	ld.ub	r12,lr[0x2]
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	57 6c       	stdsp	sp[0x1d8],r12
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	57 a4       	stdsp	sp[0x1e8],r4
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	57 d0       	stdsp	sp[0x1f4],r0
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	58 14       	cp.w	r4,1
80002b80:	00 00       	add	r0,r0
80002b82:	0a 64       	and	r4,r5
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	d7 98       	*unknown*
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	77 ac       	ld.w	r12,r11[0x68]
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	59 3c       	cp.w	r12,19
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	57 d6       	stdsp	sp[0x1f4],r6
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	57 f2       	stdsp	sp[0x1fc],r2
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	58 fc       	cp.w	r12,15
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	2a 64       	sub	r4,-90

80002ba0 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002ba0:	20 1c       	sub	r12,1
80002ba2:	5c 5c       	castu.b	r12
80002ba4:	31 18       	mov	r8,17
80002ba6:	f0 0c 18 00 	cp.b	r12,r8
80002baa:	e0 88 00 03 	brls	80002bb0 <CalculateBurst+0x10>
80002bae:	5e fd       	retal	0
80002bb0:	48 28       	lddpc	r8,80002bb8 <CalculateBurst+0x18>
80002bb2:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002bb6:	5e fc       	retal	r12
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	d7 ac       	*unknown*

80002bbc <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002bbc:	48 38       	lddpc	r8,80002bc8 <payload_init+0xc>
80002bbe:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002bc0:	48 38       	lddpc	r8,80002bcc <payload_init+0x10>
80002bc2:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002bc4:	5e fc       	retal	r12
80002bc6:	00 00       	add	r0,r0
80002bc8:	00 00       	add	r0,r0
80002bca:	0a 68       	and	r8,r5
80002bcc:	00 00       	add	r0,r0
80002bce:	0a 6c       	and	r12,r5

80002bd0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002bd0:	d4 01       	pushm	lr
80002bd2:	20 2d       	sub	sp,8
80002bd4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bd6:	30 09       	mov	r9,0
80002bd8:	fa ca ff f8 	sub	r10,sp,-8
80002bdc:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bde:	1a 9b       	mov	r11,sp
80002be0:	f0 1f 00 02 	mcall	80002be8 <set_idle_store_isr+0x18>
}
80002be4:	2f ed       	sub	sp,-8
80002be6:	d8 02       	popm	pc
80002be8:	80 00       	ld.sh	r0,r0[0x0]
80002bea:	62 90       	ld.w	r0,r1[0x24]

80002bec <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bec:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002bee:	48 48       	lddpc	r8,80002bfc <payload_rx+0x10>
80002bf0:	70 08       	ld.w	r8,r8[0x0]
80002bf2:	18 9b       	mov	r11,r12
80002bf4:	10 9c       	mov	r12,r8
80002bf6:	f0 1f 00 03 	mcall	80002c00 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002bfa:	d8 02       	popm	pc
80002bfc:	00 00       	add	r0,r0
80002bfe:	0a a4       	st.w	r5++,r4
80002c00:	80 00       	ld.sh	r0,r0[0x0]
80002c02:	2b d0       	sub	r0,-67

80002c04 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002c04:	d4 01       	pushm	lr
80002c06:	20 2d       	sub	sp,8
80002c08:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002c0a:	58 0c       	cp.w	r12,0
80002c0c:	c1 10       	breq	80002c2e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c0e:	30 08       	mov	r8,0
80002c10:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002c12:	98 88       	ld.uh	r8,r12[0x0]
80002c14:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c18:	e0 48 40 00 	cp.w	r8,16384
80002c1c:	c0 91       	brne	80002c2e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002c1e:	48 68       	lddpc	r8,80002c34 <phy_rx+0x30>
80002c20:	70 0c       	ld.w	r12,r8[0x0]
80002c22:	30 09       	mov	r9,0
80002c24:	fa ca ff fc 	sub	r10,sp,-4
80002c28:	1a 9b       	mov	r11,sp
80002c2a:	f0 1f 00 04 	mcall	80002c38 <phy_rx+0x34>
		}	

    }
		
 
}
80002c2e:	2f ed       	sub	sp,-8
80002c30:	d8 02       	popm	pc
80002c32:	00 00       	add	r0,r0
80002c34:	00 00       	add	r0,r0
80002c36:	0a b0       	st.h	r5++,r0
80002c38:	80 00       	ld.sh	r0,r0[0x0]
80002c3a:	62 90       	ld.w	r0,r1[0x24]

80002c3c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c3c:	eb cd 40 80 	pushm	r7,lr
80002c40:	20 1d       	sub	sp,4
80002c42:	fa c7 ff fc 	sub	r7,sp,-4
80002c46:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c48:	30 09       	mov	r9,0
80002c4a:	12 9a       	mov	r10,r9
80002c4c:	1a 9b       	mov	r11,sp
80002c4e:	f0 1f 00 03 	mcall	80002c58 <set_idle_store+0x1c>
}
80002c52:	2f fd       	sub	sp,-4
80002c54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	62 e0       	ld.w	r0,r1[0x38]

80002c5c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c5c:	d4 01       	pushm	lr
80002c5e:	20 1d       	sub	sp,4
80002c60:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c62:	98 88       	ld.uh	r8,r12[0x0]
80002c64:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c68:	e0 48 40 00 	cp.w	r8,16384
80002c6c:	c0 d1       	brne	80002c86 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c6e:	49 08       	lddpc	r8,80002cac <phy_tx+0x50>
80002c70:	70 08       	ld.w	r8,r8[0x0]
80002c72:	58 08       	cp.w	r8,0
80002c74:	c1 a0       	breq	80002ca8 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c76:	48 e8       	lddpc	r8,80002cac <phy_tx+0x50>
80002c78:	70 0c       	ld.w	r12,r8[0x0]
80002c7a:	30 09       	mov	r9,0
80002c7c:	12 9a       	mov	r10,r9
80002c7e:	1a 9b       	mov	r11,sp
80002c80:	f0 1f 00 0c 	mcall	80002cb0 <phy_tx+0x54>
80002c84:	c1 28       	rjmp	80002ca8 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c86:	e0 48 10 00 	cp.w	r8,4096
80002c8a:	5f 0a       	sreq	r10
80002c8c:	e0 48 20 00 	cp.w	r8,8192
80002c90:	5f 09       	sreq	r9
80002c92:	f5 e9 10 09 	or	r9,r10,r9
80002c96:	c0 71       	brne	80002ca4 <phy_tx+0x48>
80002c98:	e0 48 50 00 	cp.w	r8,20480
80002c9c:	c0 40       	breq	80002ca4 <phy_tx+0x48>
80002c9e:	e0 48 60 00 	cp.w	r8,24576
80002ca2:	c0 31       	brne	80002ca8 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002ca4:	48 48       	lddpc	r8,80002cb4 <phy_tx+0x58>
80002ca6:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002ca8:	2f fd       	sub	sp,-4
80002caa:	d8 02       	popm	pc
80002cac:	00 00       	add	r0,r0
80002cae:	0a d0       	st.w	--r5,r0
80002cb0:	80 00       	ld.sh	r0,r0[0x0]
80002cb2:	62 e0       	ld.w	r0,r1[0x38]
80002cb4:	00 00       	add	r0,r0
80002cb6:	0a c4       	st.b	r5++,r4

80002cb8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002cb8:	d4 01       	pushm	lr
80002cba:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002cbc:	30 08       	mov	r8,0
80002cbe:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cc0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002cc2:	1a 9a       	mov	r10,sp
80002cc4:	fa cb ff fc 	sub	r11,sp,-4
80002cc8:	f0 1f 00 05 	mcall	80002cdc <get_idle_store_isr+0x24>
80002ccc:	58 1c       	cp.w	r12,1
80002cce:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cd2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002cd6:	2f ed       	sub	sp,-8
80002cd8:	d8 02       	popm	pc
80002cda:	00 00       	add	r0,r0
80002cdc:	80 00       	ld.sh	r0,r0[0x0]
80002cde:	5f e4       	srqs	r4

80002ce0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ce0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ce4:	20 1d       	sub	sp,4
80002ce6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ce8:	4b a8       	lddpc	r8,80002dd0 <phy_tx_func+0xf0>
80002cea:	70 08       	ld.w	r8,r8[0x0]
80002cec:	58 08       	cp.w	r8,0
80002cee:	c6 60       	breq	80002dba <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002cf0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cf2:	30 08       	mov	r8,0
80002cf4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cf6:	4b 88       	lddpc	r8,80002dd4 <phy_tx_func+0xf4>
80002cf8:	70 08       	ld.w	r8,r8[0x0]
80002cfa:	58 18       	cp.w	r8,1
80002cfc:	c2 60       	breq	80002d48 <phy_tx_func+0x68>
80002cfe:	c0 43       	brcs	80002d06 <phy_tx_func+0x26>
80002d00:	58 28       	cp.w	r8,2
80002d02:	c5 c1       	brne	80002dba <phy_tx_func+0xda>
80002d04:	c5 58       	rjmp	80002dae <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002d06:	4b 38       	lddpc	r8,80002dd0 <phy_tx_func+0xf0>
80002d08:	70 0c       	ld.w	r12,r8[0x0]
80002d0a:	1a 9a       	mov	r10,sp
80002d0c:	4b 3b       	lddpc	r11,80002dd8 <phy_tx_func+0xf8>
80002d0e:	f0 1f 00 34 	mcall	80002ddc <phy_tx_func+0xfc>
80002d12:	58 1c       	cp.w	r12,1
80002d14:	c1 41       	brne	80002d3c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002d16:	4b 18       	lddpc	r8,80002dd8 <phy_tx_func+0xf8>
80002d18:	70 08       	ld.w	r8,r8[0x0]
80002d1a:	90 08       	ld.sh	r8,r8[0x0]
80002d1c:	10 9a       	mov	r10,r8
80002d1e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d22:	4b 09       	lddpc	r9,80002de0 <phy_tx_func+0x100>
80002d24:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d26:	5c 78       	castu.h	r8
80002d28:	ea 18 ab cd 	orh	r8,0xabcd
80002d2c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002d2e:	30 19       	mov	r9,1
80002d30:	4a d8       	lddpc	r8,80002de4 <phy_tx_func+0x104>
80002d32:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d34:	30 19       	mov	r9,1
80002d36:	4a 88       	lddpc	r8,80002dd4 <phy_tx_func+0xf4>
80002d38:	91 09       	st.w	r8[0x0],r9
80002d3a:	c4 08       	rjmp	80002dba <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d3c:	e0 68 5a 5a 	mov	r8,23130
80002d40:	ea 18 ab cd 	orh	r8,0xabcd
80002d44:	8f 18       	st.w	r7[0x4],r8
80002d46:	c3 a8       	rjmp	80002dba <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d48:	4a 7a       	lddpc	r10,80002de4 <phy_tx_func+0x104>
80002d4a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d4c:	4a 39       	lddpc	r9,80002dd8 <phy_tx_func+0xf8>
80002d4e:	72 09       	ld.w	r9,r9[0x0]
80002d50:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d54:	b1 69       	lsl	r9,0x10
80002d56:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d58:	2f f8       	sub	r8,-1
80002d5a:	5c 58       	castu.b	r8
80002d5c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d5e:	4a 1b       	lddpc	r11,80002de0 <phy_tx_func+0x100>
80002d60:	96 0c       	ld.sh	r12,r11[0x0]
80002d62:	20 2c       	sub	r12,2
80002d64:	5c 8c       	casts.h	r12
80002d66:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d6a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d6c:	30 0b       	mov	r11,0
80002d6e:	f6 0a 19 00 	cp.h	r10,r11
80002d72:	e0 89 00 09 	brgt	80002d84 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d76:	e8 19 00 ba 	orl	r9,0xba
80002d7a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d7c:	30 09       	mov	r9,0
80002d7e:	49 68       	lddpc	r8,80002dd4 <phy_tx_func+0xf4>
80002d80:	91 09       	st.w	r8[0x0],r9
80002d82:	c1 c8       	rjmp	80002dba <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d84:	49 5a       	lddpc	r10,80002dd8 <phy_tx_func+0xf8>
80002d86:	74 0a       	ld.w	r10,r10[0x0]
80002d88:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d8c:	14 49       	or	r9,r10
80002d8e:	8f 19       	st.w	r7[0x4],r9
80002d90:	2f f8       	sub	r8,-1
80002d92:	49 59       	lddpc	r9,80002de4 <phy_tx_func+0x104>
80002d94:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d96:	20 2c       	sub	r12,2
80002d98:	49 28       	lddpc	r8,80002de0 <phy_tx_func+0x100>
80002d9a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d9c:	30 08       	mov	r8,0
80002d9e:	f0 0c 19 00 	cp.h	r12,r8
80002da2:	e0 89 00 0c 	brgt	80002dba <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002da6:	30 29       	mov	r9,2
80002da8:	48 b8       	lddpc	r8,80002dd4 <phy_tx_func+0xf4>
80002daa:	91 09       	st.w	r8[0x0],r9
80002dac:	c0 78       	rjmp	80002dba <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002dae:	fc 18 00 ba 	movh	r8,0xba
80002db2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002db4:	30 09       	mov	r9,0
80002db6:	48 88       	lddpc	r8,80002dd4 <phy_tx_func+0xf4>
80002db8:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002dba:	e0 68 5a 5a 	mov	r8,23130
80002dbe:	ea 18 ab cd 	orh	r8,0xabcd
80002dc2:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002dc4:	30 08       	mov	r8,0
80002dc6:	8f 38       	st.w	r7[0xc],r8
}
80002dc8:	2f fd       	sub	sp,-4
80002dca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002dce:	00 00       	add	r0,r0
80002dd0:	00 00       	add	r0,r0
80002dd2:	0a d0       	st.w	--r5,r0
80002dd4:	00 00       	add	r0,r0
80002dd6:	0a 90       	mov	r0,r5
80002dd8:	00 00       	add	r0,r0
80002dda:	0a 9c       	mov	r12,r5
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	5f e4       	srqs	r4
80002de0:	00 00       	add	r0,r0
80002de2:	0a b8       	st.h	r5++,r8
80002de4:	00 00       	add	r0,r0
80002de6:	0a 70       	tst	r0,r5

80002de8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002de8:	d4 01       	pushm	lr
80002dea:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002dec:	30 0a       	mov	r10,0
80002dee:	fa cb ff fc 	sub	r11,sp,-4
80002df2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002df4:	14 99       	mov	r9,r10
80002df6:	1a 9b       	mov	r11,sp
80002df8:	f0 1f 00 05 	mcall	80002e0c <get_idle_store+0x24>
80002dfc:	58 1c       	cp.w	r12,1
80002dfe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002e02:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002e06:	2f fd       	sub	sp,-4
80002e08:	d8 02       	popm	pc
80002e0a:	00 00       	add	r0,r0
80002e0c:	80 00       	ld.sh	r0,r0[0x0]
80002e0e:	60 d4       	ld.w	r4,r0[0x34]

80002e10 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002e10:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002e12:	48 5b       	lddpc	r11,80002e24 <phy_init+0x14>
80002e14:	48 5c       	lddpc	r12,80002e28 <phy_init+0x18>
80002e16:	f0 1f 00 06 	mcall	80002e2c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002e1a:	f0 1f 00 06 	mcall	80002e30 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002e1e:	f0 1f 00 06 	mcall	80002e34 <phy_init+0x24>
	
}
80002e22:	d8 02       	popm	pc
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	2c e0       	sub	r0,-50
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	2e 38       	sub	r8,-29
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	3e 8c       	mov	r12,-24
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	3e a0       	mov	r0,-22
80002e34:	80 00       	ld.sh	r0,r0[0x0]
80002e36:	48 4c       	lddpc	r12,80002e44 <phy_rx_func+0xc>

80002e38 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e38:	eb cd 40 e0 	pushm	r5-r7,lr
80002e3c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e3e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e42:	70 08       	ld.w	r8,r8[0x0]
80002e44:	58 08       	cp.w	r8,0
80002e46:	e0 80 01 08 	breq	80003056 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e4a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e4c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e50:	70 09       	ld.w	r9,r8[0x0]
80002e52:	2f f9       	sub	r9,-1
80002e54:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e56:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e5a:	70 08       	ld.w	r8,r8[0x0]
80002e5c:	58 18       	cp.w	r8,1
80002e5e:	e0 80 00 85 	breq	80002f68 <phy_rx_func+0x130>
80002e62:	c0 73       	brcs	80002e70 <phy_rx_func+0x38>
80002e64:	58 28       	cp.w	r8,2
80002e66:	c5 c0       	breq	80002f1e <phy_rx_func+0xe6>
80002e68:	58 38       	cp.w	r8,3
80002e6a:	e0 81 00 f6 	brne	80003056 <phy_rx_func+0x21e>
80002e6e:	cd 58       	rjmp	80003018 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e70:	e0 6a 5a 5a 	mov	r10,23130
80002e74:	ea 1a ab cd 	orh	r10,0xabcd
80002e78:	14 36       	cp.w	r6,r10
80002e7a:	e0 80 00 ee 	breq	80003056 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e7e:	ec 08 16 10 	lsr	r8,r6,0x10
80002e82:	e0 48 ab cd 	cp.w	r8,43981
80002e86:	e0 81 00 e8 	brne	80003056 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e8a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e8e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e92:	20 28       	sub	r8,2
80002e94:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e98:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e9a:	30 09       	mov	r9,0
80002e9c:	f2 08 19 00 	cp.h	r8,r9
80002ea0:	e0 8a 00 db 	brle	80003056 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ea4:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002ea8:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002eaa:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002eae:	70 0c       	ld.w	r12,r8[0x0]
80002eb0:	f0 1f 03 88 	mcall	80003cd0 <phy_rx_func+0xe98>
80002eb4:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002eb8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002eba:	58 0c       	cp.w	r12,0
80002ebc:	e0 80 00 cd 	breq	80003056 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002ec0:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002ec4:	90 09       	ld.sh	r9,r8[0x0]
80002ec6:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002eca:	2f f9       	sub	r9,-1
80002ecc:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002ece:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002ed2:	74 0a       	ld.w	r10,r10[0x0]
80002ed4:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ed8:	76 0b       	ld.w	r11,r11[0x0]
80002eda:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002ede:	2f f9       	sub	r9,-1
80002ee0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002ee2:	e2 16 0f 00 	andl	r6,0xf00,COH
80002ee6:	e0 46 01 00 	cp.w	r6,256
80002eea:	c0 c0       	breq	80002f02 <phy_rx_func+0xca>
80002eec:	e0 8b 00 05 	brhi	80002ef6 <phy_rx_func+0xbe>
80002ef0:	58 06       	cp.w	r6,0
80002ef2:	c0 80       	breq	80002f02 <phy_rx_func+0xca>
80002ef4:	c0 c8       	rjmp	80002f0c <phy_rx_func+0xd4>
80002ef6:	e0 46 02 00 	cp.w	r6,512
80002efa:	c0 40       	breq	80002f02 <phy_rx_func+0xca>
80002efc:	e0 46 03 00 	cp.w	r6,768
80002f00:	c0 61       	brne	80002f0c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f02:	30 29       	mov	r9,2
80002f04:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002f08:	91 09       	st.w	r8[0x0],r9
80002f0a:	ca 68       	rjmp	80003056 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f0c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f10:	70 0c       	ld.w	r12,r8[0x0]
80002f12:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f16:	70 0b       	ld.w	r11,r8[0x0]
80002f18:	f0 1f 03 70 	mcall	80003cd8 <phy_rx_func+0xea0>
80002f1c:	c9 d8       	rjmp	80003056 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f1e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f22:	b1 86       	lsr	r6,0x10
80002f24:	14 06       	add	r6,r10
80002f26:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002f2a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f2c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f30:	90 09       	ld.sh	r9,r8[0x0]
80002f32:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f36:	76 0b       	ld.w	r11,r11[0x0]
80002f38:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f3c:	2f f9       	sub	r9,-1
80002f3e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f40:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f44:	92 08       	ld.sh	r8,r9[0x0]
80002f46:	20 28       	sub	r8,2
80002f48:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f4a:	30 09       	mov	r9,0
80002f4c:	f2 08 19 00 	cp.h	r8,r9
80002f50:	e0 8a 00 07 	brle	80002f5e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f54:	30 19       	mov	r9,1
80002f56:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f5a:	91 09       	st.w	r8[0x0],r9
80002f5c:	c7 d8       	rjmp	80003056 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f5e:	30 39       	mov	r9,3
80002f60:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f64:	91 09       	st.w	r8[0x0],r9
80002f66:	c7 88       	rjmp	80003056 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f68:	ec 0a 14 10 	asr	r10,r6,0x10
80002f6c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f70:	90 09       	ld.sh	r9,r8[0x0]
80002f72:	14 09       	add	r9,r10
80002f74:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f76:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f7a:	92 08       	ld.sh	r8,r9[0x0]
80002f7c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f80:	76 0b       	ld.w	r11,r11[0x0]
80002f82:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f86:	2f f8       	sub	r8,-1
80002f88:	5c 88       	casts.h	r8
80002f8a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f8c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f90:	94 09       	ld.sh	r9,r10[0x0]
80002f92:	20 29       	sub	r9,2
80002f94:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f96:	30 0a       	mov	r10,0
80002f98:	f4 09 19 00 	cp.h	r9,r10
80002f9c:	e0 89 00 20 	brgt	80002fdc <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002fa0:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002fa4:	e0 46 00 ba 	cp.w	r6,186
80002fa8:	c0 d1       	brne	80002fc2 <phy_rx_func+0x18a>
80002faa:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002fae:	90 09       	ld.sh	r9,r8[0x0]
80002fb0:	f4 09 19 00 	cp.h	r9,r10
80002fb4:	c0 71       	brne	80002fc2 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002fb6:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002fba:	70 0c       	ld.w	r12,r8[0x0]
80002fbc:	f0 1f 03 49 	mcall	80003ce0 <phy_rx_func+0xea8>
80002fc0:	c0 98       	rjmp	80002fd2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002fc2:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002fc6:	70 0c       	ld.w	r12,r8[0x0]
80002fc8:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002fcc:	70 0b       	ld.w	r11,r8[0x0]
80002fce:	f0 1f 03 43 	mcall	80003cd8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002fd2:	30 09       	mov	r9,0
80002fd4:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002fd8:	91 09       	st.w	r8[0x0],r9
80002fda:	c3 e8       	rjmp	80003056 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002fdc:	5c 86       	casts.h	r6
80002fde:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002fe2:	92 0a       	ld.sh	r10,r9[0x0]
80002fe4:	0c 0a       	add	r10,r6
80002fe6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fe8:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002fec:	72 09       	ld.w	r9,r9[0x0]
80002fee:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002ff2:	2f f8       	sub	r8,-1
80002ff4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002ff8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002ffa:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002ffe:	92 08       	ld.sh	r8,r9[0x0]
80003000:	20 28       	sub	r8,2
80003002:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003004:	30 09       	mov	r9,0
80003006:	f2 08 19 00 	cp.h	r8,r9
8000300a:	e0 89 00 26 	brgt	80003056 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000300e:	30 39       	mov	r9,3
80003010:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003014:	91 09       	st.w	r8[0x0],r9
80003016:	c2 08       	rjmp	80003056 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003018:	e6 16 00 ff 	andh	r6,0xff,COH
8000301c:	fc 19 00 ba 	movh	r9,0xba
80003020:	12 36       	cp.w	r6,r9
80003022:	c0 e1       	brne	8000303e <phy_rx_func+0x206>
80003024:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003028:	90 09       	ld.sh	r9,r8[0x0]
8000302a:	30 08       	mov	r8,0
8000302c:	f0 09 19 00 	cp.h	r9,r8
80003030:	c0 71       	brne	8000303e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003032:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003036:	70 0c       	ld.w	r12,r8[0x0]
80003038:	f0 1f 03 2a 	mcall	80003ce0 <phy_rx_func+0xea8>
8000303c:	c0 98       	rjmp	8000304e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000303e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003042:	70 0c       	ld.w	r12,r8[0x0]
80003044:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003048:	70 0b       	ld.w	r11,r8[0x0]
8000304a:	f0 1f 03 24 	mcall	80003cd8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000304e:	30 09       	mov	r9,0
80003050:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003054:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003056:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000305a:	11 89       	ld.ub	r9,r8[0x0]
8000305c:	30 08       	mov	r8,0
8000305e:	f0 09 18 00 	cp.b	r9,r8
80003062:	c1 31       	brne	80003088 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003064:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003068:	6c 0c       	ld.w	r12,r6[0x0]
8000306a:	f0 1f 03 1a 	mcall	80003cd0 <phy_rx_func+0xe98>
8000306e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003072:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003074:	6c 0c       	ld.w	r12,r6[0x0]
80003076:	f0 1f 03 17 	mcall	80003cd0 <phy_rx_func+0xe98>
8000307a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000307e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003080:	30 19       	mov	r9,1
80003082:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003086:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003088:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000308c:	70 08       	ld.w	r8,r8[0x0]
8000308e:	58 28       	cp.w	r8,2
80003090:	e0 80 01 98 	breq	800033c0 <phy_rx_func+0x588>
80003094:	e0 8b 00 06 	brhi	800030a0 <phy_rx_func+0x268>
80003098:	58 08       	cp.w	r8,0
8000309a:	c0 b0       	breq	800030b0 <phy_rx_func+0x278>
8000309c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030a0:	58 38       	cp.w	r8,3
800030a2:	e0 80 05 c5 	breq	80003c2c <phy_rx_func+0xdf4>
800030a6:	58 48       	cp.w	r8,4
800030a8:	e0 81 06 05 	brne	80003cb2 <phy_rx_func+0xe7a>
800030ac:	e0 8f 02 4b 	bral	80003542 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800030b0:	6e 28       	ld.w	r8,r7[0x8]
800030b2:	e0 6a 5a 5a 	mov	r10,23130
800030b6:	ea 1a ab cd 	orh	r10,0xabcd
800030ba:	14 38       	cp.w	r8,r10
800030bc:	c0 71       	brne	800030ca <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800030be:	30 09       	mov	r9,0
800030c0:	fe f8 0c 38 	ld.w	r8,pc[3128]
800030c4:	91 09       	st.w	r8[0x0],r9
800030c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800030ca:	10 99       	mov	r9,r8
800030cc:	e0 19 00 00 	andl	r9,0x0
800030d0:	fc 1a ab cd 	movh	r10,0xabcd
800030d4:	14 39       	cp.w	r9,r10
800030d6:	e0 81 05 ee 	brne	80003cb2 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800030da:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800030de:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800030e2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800030e4:	6e 29       	ld.w	r9,r7[0x8]
800030e6:	e2 19 f0 00 	andl	r9,0xf000,COH
800030ea:	e0 49 c0 00 	cp.w	r9,49152
800030ee:	e0 81 00 ce 	brne	8000328a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800030f2:	30 1a       	mov	r10,1
800030f4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030f8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030fa:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030fe:	72 09       	ld.w	r9,r9[0x0]
80003100:	58 09       	cp.w	r9,0
80003102:	c0 71       	brne	80003110 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003104:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003108:	f0 1f 03 00 	mcall	80003d08 <phy_rx_func+0xed0>
8000310c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003110:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003114:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003118:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000311a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000311e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003122:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003126:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003128:	13 89       	ld.ub	r9,r9[0x0]
8000312a:	37 fa       	mov	r10,127
8000312c:	f4 09 18 00 	cp.b	r9,r10
80003130:	c6 d0       	breq	8000320a <phy_rx_func+0x3d2>
80003132:	e0 8b 00 0c 	brhi	8000314a <phy_rx_func+0x312>
80003136:	31 2a       	mov	r10,18
80003138:	f4 09 18 00 	cp.b	r9,r10
8000313c:	c4 20       	breq	800031c0 <phy_rx_func+0x388>
8000313e:	31 3a       	mov	r10,19
80003140:	f4 09 18 00 	cp.b	r9,r10
80003144:	e0 81 00 83 	brne	8000324a <phy_rx_func+0x412>
80003148:	c5 b8       	rjmp	800031fe <phy_rx_func+0x3c6>
8000314a:	2f 09       	sub	r9,-16
8000314c:	30 1a       	mov	r10,1
8000314e:	f4 09 18 00 	cp.b	r9,r10
80003152:	e0 8b 00 7c 	brhi	8000324a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003156:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000315a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000315e:	59 08       	cp.w	r8,16
80003160:	c0 71       	brne	8000316e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003162:	30 19       	mov	r9,1
80003164:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003168:	91 09       	st.w	r8[0x0],r9
8000316a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000316e:	e0 48 00 20 	cp.w	r8,32
80003172:	c2 11       	brne	800031b4 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003174:	30 a9       	mov	r9,10
80003176:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000317a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000317c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003180:	6c 08       	ld.w	r8,r6[0x0]
80003182:	f0 0a 11 ff 	rsub	r10,r8,-1
80003186:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000318a:	2f f8       	sub	r8,-1
8000318c:	6e 0c       	ld.w	r12,r7[0x0]
8000318e:	f4 ca fe 00 	sub	r10,r10,-512
80003192:	30 0b       	mov	r11,0
80003194:	10 0c       	add	r12,r8
80003196:	f0 1f 02 e1 	mcall	80003d18 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000319a:	30 08       	mov	r8,0
8000319c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000319e:	6e 0c       	ld.w	r12,r7[0x0]
800031a0:	f0 1f 02 df 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800031a4:	fe f8 0b 44 	ld.w	r8,pc[2884]
800031a8:	70 0c       	ld.w	r12,r8[0x0]
800031aa:	f0 1f 02 ca 	mcall	80003cd0 <phy_rx_func+0xe98>
800031ae:	8f 0c       	st.w	r7[0x0],r12
800031b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800031b4:	30 09       	mov	r9,0
800031b6:	fe f8 0b 42 	ld.w	r8,pc[2882]
800031ba:	91 09       	st.w	r8[0x0],r9
800031bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031c0:	20 48       	sub	r8,4
800031c2:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800031c6:	93 08       	st.w	r9[0x0],r8
800031c8:	58 08       	cp.w	r8,0
800031ca:	e0 80 05 74 	breq	80003cb2 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800031ce:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800031d2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800031d6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800031da:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800031dc:	8e 69       	ld.sh	r9,r7[0xc]
800031de:	fe f8 0b 46 	ld.w	r8,pc[2886]
800031e2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800031e4:	8e 79       	ld.sh	r9,r7[0xe]
800031e6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800031e8:	f0 1f 02 d0 	mcall	80003d28 <phy_rx_func+0xef0>
800031ec:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800031f0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800031f2:	30 49       	mov	r9,4
800031f4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031f8:	91 09       	st.w	r8[0x0],r9
800031fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031fe:	30 09       	mov	r9,0
80003200:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003204:	91 09       	st.w	r8[0x0],r9
80003206:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000320a:	20 48       	sub	r8,4
8000320c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003210:	93 08       	st.w	r9[0x0],r8
80003212:	58 08       	cp.w	r8,0
80003214:	e0 80 05 4f 	breq	80003cb2 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003218:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000321c:	70 09       	ld.w	r9,r8[0x0]
8000321e:	8e 7b       	ld.sh	r11,r7[0xe]
80003220:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003224:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003228:	2f f9       	sub	r9,-1
8000322a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000322c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003230:	70 09       	ld.w	r9,r8[0x0]
80003232:	20 29       	sub	r9,2
80003234:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003236:	30 29       	mov	r9,2
80003238:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000323c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000323e:	30 39       	mov	r9,3
80003240:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003244:	91 09       	st.w	r8[0x0],r9
80003246:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000324a:	30 3a       	mov	r10,3
8000324c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003250:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003252:	6e 2a       	ld.w	r10,r7[0x8]
80003254:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003258:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000325a:	6e 3a       	ld.w	r10,r7[0xc]
8000325c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000325e:	59 48       	cp.w	r8,20
80003260:	c0 61       	brne	8000326c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003262:	31 89       	mov	r9,24
80003264:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003268:	91 09       	st.w	r8[0x0],r9
8000326a:	c0 a8       	rjmp	8000327e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000326c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003270:	70 08       	ld.w	r8,r8[0x0]
80003272:	59 08       	cp.w	r8,16
80003274:	c0 51       	brne	8000327e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003276:	31 09       	mov	r9,16
80003278:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000327c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000327e:	30 49       	mov	r9,4
80003280:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003284:	91 09       	st.w	r8[0x0],r9
80003286:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000328a:	e0 49 10 00 	cp.w	r9,4096
8000328e:	5f 1a       	srne	r10
80003290:	e0 49 20 00 	cp.w	r9,8192
80003294:	5f 19       	srne	r9
80003296:	f5 e9 00 09 	and	r9,r10,r9
8000329a:	e0 81 05 0c 	brne	80003cb2 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000329e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800032a2:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800032a4:	fe fa 0a 98 	ld.w	r10,pc[2712]
800032a8:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800032aa:	fe fa 0a 62 	ld.w	r10,pc[2658]
800032ae:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800032b0:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800032b4:	72 09       	ld.w	r9,r9[0x0]
800032b6:	58 09       	cp.w	r9,0
800032b8:	c0 71       	brne	800032c6 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032ba:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800032be:	f0 1f 02 93 	mcall	80003d08 <phy_rx_func+0xed0>
800032c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032c6:	6e 2a       	ld.w	r10,r7[0x8]
800032c8:	e2 1a 0f 00 	andl	r10,0xf00,COH
800032cc:	58 1a       	cp.w	r10,1
800032ce:	e0 8b 00 4d 	brhi	80003368 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800032d2:	20 48       	sub	r8,4
800032d4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800032d8:	93 08       	st.w	r9[0x0],r8
800032da:	58 08       	cp.w	r8,0
800032dc:	e0 80 04 eb 	breq	80003cb2 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800032e0:	8e 68       	ld.sh	r8,r7[0xc]
800032e2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800032e6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800032ea:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800032ec:	30 09       	mov	r9,0
800032ee:	f2 08 19 00 	cp.h	r8,r9
800032f2:	c0 70       	breq	80003300 <phy_rx_func+0x4c8>
800032f4:	30 19       	mov	r9,1
800032f6:	f2 08 19 00 	cp.h	r8,r9
800032fa:	e0 81 04 dc 	brne	80003cb2 <phy_rx_func+0xe7a>
800032fe:	c2 68       	rjmp	8000334a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003300:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003304:	70 0a       	ld.w	r10,r8[0x0]
80003306:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000330a:	72 09       	ld.w	r9,r9[0x0]
8000330c:	8e 7b       	ld.sh	r11,r7[0xe]
8000330e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003312:	70 09       	ld.w	r9,r8[0x0]
80003314:	2f f9       	sub	r9,-1
80003316:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003318:	e0 49 00 ff 	cp.w	r9,255
8000331c:	e0 88 00 11 	brls	8000333e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003320:	30 09       	mov	r9,0
80003322:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003324:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003328:	6e 0c       	ld.w	r12,r7[0x0]
8000332a:	f0 1f 02 7d 	mcall	80003d1c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000332e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003332:	70 0c       	ld.w	r12,r8[0x0]
80003334:	f0 1f 02 67 	mcall	80003cd0 <phy_rx_func+0xe98>
80003338:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000333a:	e0 80 04 bc 	breq	80003cb2 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000333e:	30 29       	mov	r9,2
80003340:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003344:	91 09       	st.w	r8[0x0],r9
80003346:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000334a:	8e 79       	ld.sh	r9,r7[0xe]
8000334c:	30 38       	mov	r8,3
8000334e:	f0 09 19 00 	cp.h	r9,r8
80003352:	c0 51       	brne	8000335c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003354:	30 19       	mov	r9,1
80003356:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000335a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000335c:	30 29       	mov	r9,2
8000335e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003368:	58 18       	cp.w	r8,1
8000336a:	e0 88 04 a4 	brls	80003cb2 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000336e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003372:	70 0a       	ld.w	r10,r8[0x0]
80003374:	6e 3b       	ld.w	r11,r7[0xc]
80003376:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	2f f9       	sub	r9,-1
8000337e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003380:	e0 49 00 ff 	cp.w	r9,255
80003384:	e0 88 00 11 	brls	800033a6 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003388:	30 09       	mov	r9,0
8000338a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000338c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003390:	6e 0c       	ld.w	r12,r7[0x0]
80003392:	f0 1f 02 63 	mcall	80003d1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003396:	fe f8 09 52 	ld.w	r8,pc[2386]
8000339a:	70 0c       	ld.w	r12,r8[0x0]
8000339c:	f0 1f 02 4d 	mcall	80003cd0 <phy_rx_func+0xe98>
800033a0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033a2:	e0 80 04 88 	breq	80003cb2 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800033a6:	fe f9 09 56 	ld.w	r9,pc[2390]
800033aa:	72 08       	ld.w	r8,r9[0x0]
800033ac:	20 28       	sub	r8,2
800033ae:	93 08       	st.w	r9[0x0],r8
800033b0:	e0 80 04 81 	breq	80003cb2 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800033b4:	30 29       	mov	r9,2
800033b6:	fe f8 09 3e 	ld.w	r8,pc[2366]
800033ba:	91 09       	st.w	r8[0x0],r9
800033bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800033c0:	fe f8 09 84 	ld.w	r8,pc[2436]
800033c4:	70 0a       	ld.w	r10,r8[0x0]
800033c6:	fe f9 09 26 	ld.w	r9,pc[2342]
800033ca:	72 09       	ld.w	r9,r9[0x0]
800033cc:	8e 4b       	ld.sh	r11,r7[0x8]
800033ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800033d2:	70 09       	ld.w	r9,r8[0x0]
800033d4:	2f f9       	sub	r9,-1
800033d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033d8:	e0 49 00 ff 	cp.w	r9,255
800033dc:	e0 88 00 16 	brls	80003408 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800033e0:	30 09       	mov	r9,0
800033e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033e4:	fe f6 09 08 	ld.w	r6,pc[2312]
800033e8:	6c 0c       	ld.w	r12,r6[0x0]
800033ea:	f0 1f 02 4d 	mcall	80003d1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033ee:	fe f8 08 fa 	ld.w	r8,pc[2298]
800033f2:	70 0c       	ld.w	r12,r8[0x0]
800033f4:	f0 1f 02 37 	mcall	80003cd0 <phy_rx_func+0xe98>
800033f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033fa:	c0 71       	brne	80003408 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033fc:	30 09       	mov	r9,0
800033fe:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003402:	91 09       	st.w	r8[0x0],r9
80003404:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003408:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000340c:	72 08       	ld.w	r8,r9[0x0]
8000340e:	20 28       	sub	r8,2
80003410:	93 08       	st.w	r9[0x0],r8
80003412:	c0 71       	brne	80003420 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003414:	30 09       	mov	r9,0
80003416:	fe f8 08 de 	ld.w	r8,pc[2270]
8000341a:	91 09       	st.w	r8[0x0],r9
8000341c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003420:	fe f8 09 24 	ld.w	r8,pc[2340]
80003424:	70 0a       	ld.w	r10,r8[0x0]
80003426:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000342a:	72 09       	ld.w	r9,r9[0x0]
8000342c:	8e 5b       	ld.sh	r11,r7[0xa]
8000342e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003432:	70 09       	ld.w	r9,r8[0x0]
80003434:	2f f9       	sub	r9,-1
80003436:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003438:	e0 49 00 ff 	cp.w	r9,255
8000343c:	e0 88 00 16 	brls	80003468 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003440:	30 09       	mov	r9,0
80003442:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003444:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003448:	6c 0c       	ld.w	r12,r6[0x0]
8000344a:	f0 1f 02 35 	mcall	80003d1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000344e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003452:	70 0c       	ld.w	r12,r8[0x0]
80003454:	f0 1f 02 1f 	mcall	80003cd0 <phy_rx_func+0xe98>
80003458:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000345a:	c0 71       	brne	80003468 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000345c:	30 09       	mov	r9,0
8000345e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003462:	91 09       	st.w	r8[0x0],r9
80003464:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003468:	fe f9 08 94 	ld.w	r9,pc[2196]
8000346c:	72 08       	ld.w	r8,r9[0x0]
8000346e:	20 28       	sub	r8,2
80003470:	93 08       	st.w	r9[0x0],r8
80003472:	c0 71       	brne	80003480 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003474:	30 09       	mov	r9,0
80003476:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000347a:	91 09       	st.w	r8[0x0],r9
8000347c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003480:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003484:	70 0a       	ld.w	r10,r8[0x0]
80003486:	fe f9 08 66 	ld.w	r9,pc[2150]
8000348a:	72 09       	ld.w	r9,r9[0x0]
8000348c:	8e 6b       	ld.sh	r11,r7[0xc]
8000348e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003492:	70 09       	ld.w	r9,r8[0x0]
80003494:	2f f9       	sub	r9,-1
80003496:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003498:	e0 49 00 ff 	cp.w	r9,255
8000349c:	e0 88 00 16 	brls	800034c8 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800034a0:	30 09       	mov	r9,0
800034a2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034a4:	fe f6 08 48 	ld.w	r6,pc[2120]
800034a8:	6c 0c       	ld.w	r12,r6[0x0]
800034aa:	f0 1f 02 1d 	mcall	80003d1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034ae:	fe f8 08 3a 	ld.w	r8,pc[2106]
800034b2:	70 0c       	ld.w	r12,r8[0x0]
800034b4:	f0 1f 02 07 	mcall	80003cd0 <phy_rx_func+0xe98>
800034b8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034ba:	c0 71       	brne	800034c8 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800034bc:	30 09       	mov	r9,0
800034be:	fe f8 08 36 	ld.w	r8,pc[2102]
800034c2:	91 09       	st.w	r8[0x0],r9
800034c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034c8:	fe f9 08 34 	ld.w	r9,pc[2100]
800034cc:	72 08       	ld.w	r8,r9[0x0]
800034ce:	20 28       	sub	r8,2
800034d0:	93 08       	st.w	r9[0x0],r8
800034d2:	c0 71       	brne	800034e0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800034d4:	30 09       	mov	r9,0
800034d6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800034da:	91 09       	st.w	r8[0x0],r9
800034dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034e0:	fe f8 08 64 	ld.w	r8,pc[2148]
800034e4:	70 0a       	ld.w	r10,r8[0x0]
800034e6:	fe f9 08 06 	ld.w	r9,pc[2054]
800034ea:	72 09       	ld.w	r9,r9[0x0]
800034ec:	8e 7b       	ld.sh	r11,r7[0xe]
800034ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034f2:	70 09       	ld.w	r9,r8[0x0]
800034f4:	2f f9       	sub	r9,-1
800034f6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034f8:	e0 49 00 ff 	cp.w	r9,255
800034fc:	e0 88 00 16 	brls	80003528 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003500:	30 09       	mov	r9,0
80003502:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003504:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003508:	6e 0c       	ld.w	r12,r7[0x0]
8000350a:	f0 1f 02 05 	mcall	80003d1c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000350e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003512:	70 0c       	ld.w	r12,r8[0x0]
80003514:	f0 1f 01 ef 	mcall	80003cd0 <phy_rx_func+0xe98>
80003518:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000351a:	c0 71       	brne	80003528 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000351c:	30 09       	mov	r9,0
8000351e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003522:	91 09       	st.w	r8[0x0],r9
80003524:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003528:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000352c:	72 08       	ld.w	r8,r9[0x0]
8000352e:	20 28       	sub	r8,2
80003530:	93 08       	st.w	r9[0x0],r8
80003532:	e0 81 03 c0 	brne	80003cb2 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003536:	30 09       	mov	r9,0
80003538:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000353c:	91 09       	st.w	r8[0x0],r9
8000353e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003542:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003546:	11 89       	ld.ub	r9,r8[0x0]
80003548:	31 28       	mov	r8,18
8000354a:	f0 09 18 00 	cp.b	r9,r8
8000354e:	e0 81 01 4c 	brne	800037e6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003552:	ef 39 00 09 	ld.ub	r9,r7[9]
80003556:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000355a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000355c:	11 89       	ld.ub	r9,r8[0x0]
8000355e:	3f 28       	mov	r8,-14
80003560:	f0 09 18 00 	cp.b	r9,r8
80003564:	e0 81 01 3b 	brne	800037da <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003568:	30 19       	mov	r9,1
8000356a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000356e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003570:	6e 29       	ld.w	r9,r7[0x8]
80003572:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003576:	fe f8 07 86 	ld.w	r8,pc[1926]
8000357a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000357c:	8e 59       	ld.sh	r9,r7[0xa]
8000357e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003582:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003584:	8e 69       	ld.sh	r9,r7[0xc]
80003586:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003588:	8e 79       	ld.sh	r9,r7[0xe]
8000358a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000358c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003590:	fe f9 07 60 	ld.w	r9,pc[1888]
80003594:	72 0a       	ld.w	r10,r9[0x0]
80003596:	70 09       	ld.w	r9,r8[0x0]
80003598:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000359c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035a0:	70 09       	ld.w	r9,r8[0x0]
800035a2:	2f f9       	sub	r9,-1
800035a4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035a6:	e0 49 01 ff 	cp.w	r9,511
800035aa:	e0 88 00 16 	brls	800035d6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ae:	30 09       	mov	r9,0
800035b0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035b2:	fe f6 07 3e 	ld.w	r6,pc[1854]
800035b6:	6c 0c       	ld.w	r12,r6[0x0]
800035b8:	f0 1f 01 d9 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035bc:	fe f8 07 2c 	ld.w	r8,pc[1836]
800035c0:	70 0c       	ld.w	r12,r8[0x0]
800035c2:	f0 1f 01 c4 	mcall	80003cd0 <phy_rx_func+0xe98>
800035c6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035c8:	c0 71       	brne	800035d6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800035ca:	30 09       	mov	r9,0
800035cc:	fe f8 07 28 	ld.w	r8,pc[1832]
800035d0:	91 09       	st.w	r8[0x0],r9
800035d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035d6:	fe f9 07 26 	ld.w	r9,pc[1830]
800035da:	72 08       	ld.w	r8,r9[0x0]
800035dc:	20 18       	sub	r8,1
800035de:	93 08       	st.w	r9[0x0],r8
800035e0:	c0 71       	brne	800035ee <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800035e2:	30 09       	mov	r9,0
800035e4:	fe f8 07 10 	ld.w	r8,pc[1808]
800035e8:	91 09       	st.w	r8[0x0],r9
800035ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035ee:	fe f8 07 26 	ld.w	r8,pc[1830]
800035f2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800035f6:	72 0a       	ld.w	r10,r9[0x0]
800035f8:	70 09       	ld.w	r9,r8[0x0]
800035fa:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035fe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003602:	70 09       	ld.w	r9,r8[0x0]
80003604:	2f f9       	sub	r9,-1
80003606:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003608:	e0 49 01 ff 	cp.w	r9,511
8000360c:	e0 88 00 16 	brls	80003638 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003610:	30 09       	mov	r9,0
80003612:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003614:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003618:	6c 0c       	ld.w	r12,r6[0x0]
8000361a:	f0 1f 01 c1 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000361e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003622:	70 0c       	ld.w	r12,r8[0x0]
80003624:	f0 1f 01 ab 	mcall	80003cd0 <phy_rx_func+0xe98>
80003628:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000362a:	c0 71       	brne	80003638 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
8000362c:	30 09       	mov	r9,0
8000362e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003632:	91 09       	st.w	r8[0x0],r9
80003634:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003638:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000363c:	72 08       	ld.w	r8,r9[0x0]
8000363e:	20 18       	sub	r8,1
80003640:	93 08       	st.w	r9[0x0],r8
80003642:	c0 71       	brne	80003650 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003644:	30 09       	mov	r9,0
80003646:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000364a:	91 09       	st.w	r8[0x0],r9
8000364c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003650:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003654:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003658:	72 0a       	ld.w	r10,r9[0x0]
8000365a:	70 09       	ld.w	r9,r8[0x0]
8000365c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003660:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003664:	70 09       	ld.w	r9,r8[0x0]
80003666:	2f f9       	sub	r9,-1
80003668:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000366a:	e0 49 01 ff 	cp.w	r9,511
8000366e:	e0 88 00 16 	brls	8000369a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003672:	30 09       	mov	r9,0
80003674:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003676:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000367a:	6c 0c       	ld.w	r12,r6[0x0]
8000367c:	f0 1f 01 a8 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003680:	fe f8 06 68 	ld.w	r8,pc[1640]
80003684:	70 0c       	ld.w	r12,r8[0x0]
80003686:	f0 1f 01 93 	mcall	80003cd0 <phy_rx_func+0xe98>
8000368a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000368c:	c0 71       	brne	8000369a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000368e:	30 09       	mov	r9,0
80003690:	fe f8 06 64 	ld.w	r8,pc[1636]
80003694:	91 09       	st.w	r8[0x0],r9
80003696:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000369a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000369e:	72 08       	ld.w	r8,r9[0x0]
800036a0:	20 18       	sub	r8,1
800036a2:	93 08       	st.w	r9[0x0],r8
800036a4:	c0 71       	brne	800036b2 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800036a6:	30 09       	mov	r9,0
800036a8:	fe f8 06 4c 	ld.w	r8,pc[1612]
800036ac:	91 09       	st.w	r8[0x0],r9
800036ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800036b2:	fe f8 06 62 	ld.w	r8,pc[1634]
800036b6:	fe f9 06 3a 	ld.w	r9,pc[1594]
800036ba:	72 0a       	ld.w	r10,r9[0x0]
800036bc:	70 09       	ld.w	r9,r8[0x0]
800036be:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800036c2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036c6:	70 09       	ld.w	r9,r8[0x0]
800036c8:	2f f9       	sub	r9,-1
800036ca:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036cc:	e0 49 01 ff 	cp.w	r9,511
800036d0:	e0 88 00 16 	brls	800036fc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800036d4:	30 09       	mov	r9,0
800036d6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036d8:	fe f6 06 18 	ld.w	r6,pc[1560]
800036dc:	6c 0c       	ld.w	r12,r6[0x0]
800036de:	f0 1f 01 90 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036e2:	fe f8 06 06 	ld.w	r8,pc[1542]
800036e6:	70 0c       	ld.w	r12,r8[0x0]
800036e8:	f0 1f 01 7a 	mcall	80003cd0 <phy_rx_func+0xe98>
800036ec:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ee:	c0 71       	brne	800036fc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800036f0:	30 09       	mov	r9,0
800036f2:	fe f8 06 02 	ld.w	r8,pc[1538]
800036f6:	91 09       	st.w	r8[0x0],r9
800036f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036fc:	fe f9 06 00 	ld.w	r9,pc[1536]
80003700:	72 08       	ld.w	r8,r9[0x0]
80003702:	20 18       	sub	r8,1
80003704:	93 08       	st.w	r9[0x0],r8
80003706:	c0 71       	brne	80003714 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003708:	30 09       	mov	r9,0
8000370a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000370e:	91 09       	st.w	r8[0x0],r9
80003710:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003714:	fe f8 06 00 	ld.w	r8,pc[1536]
80003718:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000371c:	72 0a       	ld.w	r10,r9[0x0]
8000371e:	70 09       	ld.w	r9,r8[0x0]
80003720:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003724:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003728:	70 09       	ld.w	r9,r8[0x0]
8000372a:	2f f9       	sub	r9,-1
8000372c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000372e:	e0 49 01 ff 	cp.w	r9,511
80003732:	e0 88 00 16 	brls	8000375e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003736:	30 09       	mov	r9,0
80003738:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000373a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000373e:	6c 0c       	ld.w	r12,r6[0x0]
80003740:	f0 1f 01 77 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003744:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003748:	70 0c       	ld.w	r12,r8[0x0]
8000374a:	f0 1f 01 62 	mcall	80003cd0 <phy_rx_func+0xe98>
8000374e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003750:	c0 71       	brne	8000375e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003752:	30 09       	mov	r9,0
80003754:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003758:	91 09       	st.w	r8[0x0],r9
8000375a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000375e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003762:	72 08       	ld.w	r8,r9[0x0]
80003764:	20 18       	sub	r8,1
80003766:	93 08       	st.w	r9[0x0],r8
80003768:	c0 71       	brne	80003776 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003776:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000377a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000377e:	72 0a       	ld.w	r10,r9[0x0]
80003780:	70 09       	ld.w	r9,r8[0x0]
80003782:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003786:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	2f f9       	sub	r9,-1
8000378e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003790:	e0 49 01 ff 	cp.w	r9,511
80003794:	e0 88 00 16 	brls	800037c0 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003798:	30 09       	mov	r9,0
8000379a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000379c:	fe f7 05 54 	ld.w	r7,pc[1364]
800037a0:	6e 0c       	ld.w	r12,r7[0x0]
800037a2:	f0 1f 01 5f 	mcall	80003d1c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037a6:	fe f8 05 42 	ld.w	r8,pc[1346]
800037aa:	70 0c       	ld.w	r12,r8[0x0]
800037ac:	f0 1f 01 49 	mcall	80003cd0 <phy_rx_func+0xe98>
800037b0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037b2:	c0 71       	brne	800037c0 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800037b4:	30 09       	mov	r9,0
800037b6:	fe f8 05 3e 	ld.w	r8,pc[1342]
800037ba:	91 09       	st.w	r8[0x0],r9
800037bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037c0:	fe f9 05 3c 	ld.w	r9,pc[1340]
800037c4:	72 08       	ld.w	r8,r9[0x0]
800037c6:	20 18       	sub	r8,1
800037c8:	93 08       	st.w	r9[0x0],r8
800037ca:	e0 81 02 74 	brne	80003cb2 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800037ce:	30 09       	mov	r9,0
800037d0:	fe f8 05 24 	ld.w	r8,pc[1316]
800037d4:	91 09       	st.w	r8[0x0],r9
800037d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037da:	30 09       	mov	r9,0
800037dc:	fe f8 05 18 	ld.w	r8,pc[1304]
800037e0:	91 09       	st.w	r8[0x0],r9
800037e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037e6:	fe f8 05 26 	ld.w	r8,pc[1318]
800037ea:	11 89       	ld.ub	r9,r8[0x0]
800037ec:	3f 28       	mov	r8,-14
800037ee:	f0 09 18 00 	cp.b	r9,r8
800037f2:	c4 31       	brne	80003878 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037f4:	8e 49       	ld.sh	r9,r7[0x8]
800037f6:	fe f8 05 56 	ld.w	r8,pc[1366]
800037fa:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037fc:	fe f8 05 18 	ld.w	r8,pc[1304]
80003800:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003804:	72 0a       	ld.w	r10,r9[0x0]
80003806:	70 09       	ld.w	r9,r8[0x0]
80003808:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000380c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003810:	70 09       	ld.w	r9,r8[0x0]
80003812:	2f f9       	sub	r9,-1
80003814:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003816:	e0 49 01 ff 	cp.w	r9,511
8000381a:	e0 88 00 16 	brls	80003846 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000381e:	30 09       	mov	r9,0
80003820:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003822:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003826:	6e 0c       	ld.w	r12,r7[0x0]
80003828:	f0 1f 01 3d 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000382c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003830:	70 0c       	ld.w	r12,r8[0x0]
80003832:	f0 1f 01 28 	mcall	80003cd0 <phy_rx_func+0xe98>
80003836:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003838:	c0 71       	brne	80003846 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000383a:	30 09       	mov	r9,0
8000383c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003840:	91 09       	st.w	r8[0x0],r9
80003842:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003846:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000384a:	72 08       	ld.w	r8,r9[0x0]
8000384c:	20 18       	sub	r8,1
8000384e:	93 08       	st.w	r9[0x0],r8
80003850:	c0 71       	brne	8000385e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000385e:	20 18       	sub	r8,1
80003860:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003864:	93 08       	st.w	r9[0x0],r8
80003866:	58 08       	cp.w	r8,0
80003868:	e0 81 02 25 	brne	80003cb2 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003878:	fe f8 04 94 	ld.w	r8,pc[1172]
8000387c:	11 89       	ld.ub	r9,r8[0x0]
8000387e:	3f 38       	mov	r8,-13
80003880:	f0 09 18 00 	cp.b	r9,r8
80003884:	e0 81 01 0c 	brne	80003a9c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003888:	8e 49       	ld.sh	r9,r7[0x8]
8000388a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000388e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003890:	8e 59       	ld.sh	r9,r7[0xa]
80003892:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003894:	8e 69       	ld.sh	r9,r7[0xc]
80003896:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003898:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000389c:	fe f9 04 54 	ld.w	r9,pc[1108]
800038a0:	72 0a       	ld.w	r10,r9[0x0]
800038a2:	70 09       	ld.w	r9,r8[0x0]
800038a4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800038a8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ac:	70 09       	ld.w	r9,r8[0x0]
800038ae:	2f f9       	sub	r9,-1
800038b0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038b2:	e0 49 01 ff 	cp.w	r9,511
800038b6:	e0 88 00 16 	brls	800038e2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ba:	30 09       	mov	r9,0
800038bc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038be:	fe f6 04 32 	ld.w	r6,pc[1074]
800038c2:	6c 0c       	ld.w	r12,r6[0x0]
800038c4:	f0 1f 01 16 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038c8:	fe f8 04 20 	ld.w	r8,pc[1056]
800038cc:	70 0c       	ld.w	r12,r8[0x0]
800038ce:	f0 1f 01 01 	mcall	80003cd0 <phy_rx_func+0xe98>
800038d2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038d4:	c0 71       	brne	800038e2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800038d6:	30 09       	mov	r9,0
800038d8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800038dc:	91 09       	st.w	r8[0x0],r9
800038de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038e2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800038e6:	72 08       	ld.w	r8,r9[0x0]
800038e8:	20 18       	sub	r8,1
800038ea:	93 08       	st.w	r9[0x0],r8
800038ec:	c0 71       	brne	800038fa <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800038ee:	30 09       	mov	r9,0
800038f0:	fe f8 04 04 	ld.w	r8,pc[1028]
800038f4:	91 09       	st.w	r8[0x0],r9
800038f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038fa:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038fe:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003902:	72 0a       	ld.w	r10,r9[0x0]
80003904:	70 09       	ld.w	r9,r8[0x0]
80003906:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000390a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000390e:	70 09       	ld.w	r9,r8[0x0]
80003910:	2f f9       	sub	r9,-1
80003912:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003914:	e0 49 01 ff 	cp.w	r9,511
80003918:	e0 88 00 16 	brls	80003944 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000391c:	30 09       	mov	r9,0
8000391e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003920:	fe f6 03 d0 	ld.w	r6,pc[976]
80003924:	6c 0c       	ld.w	r12,r6[0x0]
80003926:	f0 1f 00 fe 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000392a:	fe f8 03 be 	ld.w	r8,pc[958]
8000392e:	70 0c       	ld.w	r12,r8[0x0]
80003930:	f0 1f 00 e8 	mcall	80003cd0 <phy_rx_func+0xe98>
80003934:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003936:	c0 71       	brne	80003944 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003938:	30 09       	mov	r9,0
8000393a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000393e:	91 09       	st.w	r8[0x0],r9
80003940:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003944:	fe f9 03 b8 	ld.w	r9,pc[952]
80003948:	72 08       	ld.w	r8,r9[0x0]
8000394a:	20 18       	sub	r8,1
8000394c:	93 08       	st.w	r9[0x0],r8
8000394e:	c0 71       	brne	8000395c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003950:	30 09       	mov	r9,0
80003952:	fe f8 03 a2 	ld.w	r8,pc[930]
80003956:	91 09       	st.w	r8[0x0],r9
80003958:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000395c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003960:	fe f9 03 90 	ld.w	r9,pc[912]
80003964:	72 0a       	ld.w	r10,r9[0x0]
80003966:	70 09       	ld.w	r9,r8[0x0]
80003968:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000396c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003970:	70 09       	ld.w	r9,r8[0x0]
80003972:	2f f9       	sub	r9,-1
80003974:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003976:	e0 49 01 ff 	cp.w	r9,511
8000397a:	e0 88 00 16 	brls	800039a6 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000397e:	30 09       	mov	r9,0
80003980:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003982:	fe f6 03 6e 	ld.w	r6,pc[878]
80003986:	6c 0c       	ld.w	r12,r6[0x0]
80003988:	f0 1f 00 e5 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000398c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003990:	70 0c       	ld.w	r12,r8[0x0]
80003992:	f0 1f 00 d0 	mcall	80003cd0 <phy_rx_func+0xe98>
80003996:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003998:	c0 71       	brne	800039a6 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000399a:	30 09       	mov	r9,0
8000399c:	fe f8 03 58 	ld.w	r8,pc[856]
800039a0:	91 09       	st.w	r8[0x0],r9
800039a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039a6:	fe f9 03 56 	ld.w	r9,pc[854]
800039aa:	72 08       	ld.w	r8,r9[0x0]
800039ac:	20 18       	sub	r8,1
800039ae:	93 08       	st.w	r9[0x0],r8
800039b0:	c0 71       	brne	800039be <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800039b2:	30 09       	mov	r9,0
800039b4:	fe f8 03 40 	ld.w	r8,pc[832]
800039b8:	91 09       	st.w	r8[0x0],r9
800039ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800039be:	fe f8 03 56 	ld.w	r8,pc[854]
800039c2:	fe f9 03 2e 	ld.w	r9,pc[814]
800039c6:	72 0a       	ld.w	r10,r9[0x0]
800039c8:	70 09       	ld.w	r9,r8[0x0]
800039ca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800039ce:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039d2:	70 09       	ld.w	r9,r8[0x0]
800039d4:	2f f9       	sub	r9,-1
800039d6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039d8:	e0 49 01 ff 	cp.w	r9,511
800039dc:	e0 88 00 16 	brls	80003a08 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800039e0:	30 09       	mov	r9,0
800039e2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039e4:	fe f6 03 0c 	ld.w	r6,pc[780]
800039e8:	6c 0c       	ld.w	r12,r6[0x0]
800039ea:	f0 1f 00 cd 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ee:	fe f8 02 fa 	ld.w	r8,pc[762]
800039f2:	70 0c       	ld.w	r12,r8[0x0]
800039f4:	f0 1f 00 b7 	mcall	80003cd0 <phy_rx_func+0xe98>
800039f8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039fa:	c0 71       	brne	80003a08 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039fc:	30 09       	mov	r9,0
800039fe:	fe f8 02 f6 	ld.w	r8,pc[758]
80003a02:	91 09       	st.w	r8[0x0],r9
80003a04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a08:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a0c:	72 08       	ld.w	r8,r9[0x0]
80003a0e:	20 18       	sub	r8,1
80003a10:	93 08       	st.w	r9[0x0],r8
80003a12:	c0 71       	brne	80003a20 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a14:	30 09       	mov	r9,0
80003a16:	fe f8 02 de 	ld.w	r8,pc[734]
80003a1a:	91 09       	st.w	r8[0x0],r9
80003a1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003a20:	fe f8 02 f4 	ld.w	r8,pc[756]
80003a24:	fe f9 02 cc 	ld.w	r9,pc[716]
80003a28:	72 0a       	ld.w	r10,r9[0x0]
80003a2a:	70 09       	ld.w	r9,r8[0x0]
80003a2c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a30:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a34:	70 09       	ld.w	r9,r8[0x0]
80003a36:	2f f9       	sub	r9,-1
80003a38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3a:	e0 49 01 ff 	cp.w	r9,511
80003a3e:	e0 88 00 16 	brls	80003a6a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a42:	30 09       	mov	r9,0
80003a44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a46:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a4a:	6e 0c       	ld.w	r12,r7[0x0]
80003a4c:	f0 1f 00 b4 	mcall	80003d1c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	fe f8 02 98 	ld.w	r8,pc[664]
80003a54:	70 0c       	ld.w	r12,r8[0x0]
80003a56:	f0 1f 00 9f 	mcall	80003cd0 <phy_rx_func+0xe98>
80003a5a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a5c:	c0 71       	brne	80003a6a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a5e:	30 09       	mov	r9,0
80003a60:	fe f8 02 94 	ld.w	r8,pc[660]
80003a64:	91 09       	st.w	r8[0x0],r9
80003a66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a6a:	fe f9 02 92 	ld.w	r9,pc[658]
80003a6e:	72 08       	ld.w	r8,r9[0x0]
80003a70:	20 18       	sub	r8,1
80003a72:	93 08       	st.w	r9[0x0],r8
80003a74:	c0 71       	brne	80003a82 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a76:	30 09       	mov	r9,0
80003a78:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a7c:	91 09       	st.w	r8[0x0],r9
80003a7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a82:	20 18       	sub	r8,1
80003a84:	fe f9 02 78 	ld.w	r9,pc[632]
80003a88:	93 08       	st.w	r9[0x0],r8
80003a8a:	58 08       	cp.w	r8,0
80003a8c:	e0 81 01 13 	brne	80003cb2 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a90:	30 09       	mov	r9,0
80003a92:	fe f8 02 62 	ld.w	r8,pc[610]
80003a96:	91 09       	st.w	r8[0x0],r9
80003a98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a9c:	fe f8 02 70 	ld.w	r8,pc[624]
80003aa0:	11 89       	ld.ub	r9,r8[0x0]
80003aa2:	30 48       	mov	r8,4
80003aa4:	f0 09 18 00 	cp.b	r9,r8
80003aa8:	c0 80       	breq	80003ab8 <phy_rx_func+0xc80>
80003aaa:	fe f8 02 62 	ld.w	r8,pc[610]
80003aae:	11 89       	ld.ub	r9,r8[0x0]
80003ab0:	30 38       	mov	r8,3
80003ab2:	f0 09 18 00 	cp.b	r9,r8
80003ab6:	c1 41       	brne	80003ade <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003ab8:	6e 29       	ld.w	r9,r7[0x8]
80003aba:	fe f8 02 7a 	ld.w	r8,pc[634]
80003abe:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003ac0:	6e 39       	ld.w	r9,r7[0xc]
80003ac2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003ac4:	fe f9 02 38 	ld.w	r9,pc[568]
80003ac8:	72 08       	ld.w	r8,r9[0x0]
80003aca:	20 88       	sub	r8,8
80003acc:	93 08       	st.w	r9[0x0],r8
80003ace:	e0 81 00 f2 	brne	80003cb2 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003ad2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ad4:	fe f9 02 20 	ld.w	r9,pc[544]
80003ad8:	93 08       	st.w	r9[0x0],r8
80003ada:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003ade:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ae2:	11 89       	ld.ub	r9,r8[0x0]
80003ae4:	31 38       	mov	r8,19
80003ae6:	f0 09 18 00 	cp.b	r9,r8
80003aea:	e0 81 00 9c 	brne	80003c22 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003aee:	fe f8 02 62 	ld.w	r8,pc[610]
80003af2:	11 88       	ld.ub	r8,r8[0x0]
80003af4:	30 c9       	mov	r9,12
80003af6:	f2 08 18 00 	cp.b	r8,r9
80003afa:	e0 81 00 7b 	brne	80003bf0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003afe:	8e 49       	ld.sh	r9,r7[0x8]
80003b00:	fe f8 02 54 	ld.w	r8,pc[596]
80003b04:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003b08:	30 09       	mov	r9,0
80003b0a:	fe f8 02 46 	ld.w	r8,pc[582]
80003b0e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b10:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b14:	3f 38       	mov	r8,-13
80003b16:	f0 09 18 00 	cp.b	r9,r8
80003b1a:	c6 61       	brne	80003be6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003b1c:	10 99       	mov	r9,r8
80003b1e:	4f c8       	lddpc	r8,80003d0c <phy_rx_func+0xed4>
80003b20:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003b22:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003b26:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003b2a:	4f 58       	lddpc	r8,80003cfc <phy_rx_func+0xec4>
80003b2c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b2e:	30 19       	mov	r9,1
80003b30:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b34:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b36:	8e 79       	ld.sh	r9,r7[0xe]
80003b38:	fe f8 02 14 	ld.w	r8,pc[532]
80003b3c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b3e:	4f 68       	lddpc	r8,80003d14 <phy_rx_func+0xedc>
80003b40:	4e c9       	lddpc	r9,80003cf0 <phy_rx_func+0xeb8>
80003b42:	72 0a       	ld.w	r10,r9[0x0]
80003b44:	70 09       	ld.w	r9,r8[0x0]
80003b46:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b4a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b4e:	70 09       	ld.w	r9,r8[0x0]
80003b50:	2f f9       	sub	r9,-1
80003b52:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b54:	e0 49 01 ff 	cp.w	r9,511
80003b58:	e0 88 00 13 	brls	80003b7e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b5c:	30 09       	mov	r9,0
80003b5e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b60:	4e 46       	lddpc	r6,80003cf0 <phy_rx_func+0xeb8>
80003b62:	6c 0c       	ld.w	r12,r6[0x0]
80003b64:	f0 1f 00 6e 	mcall	80003d1c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b68:	4e 08       	lddpc	r8,80003ce8 <phy_rx_func+0xeb0>
80003b6a:	70 0c       	ld.w	r12,r8[0x0]
80003b6c:	f0 1f 00 59 	mcall	80003cd0 <phy_rx_func+0xe98>
80003b70:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b72:	c0 61       	brne	80003b7e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b74:	30 09       	mov	r9,0
80003b76:	4e 08       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003b78:	91 09       	st.w	r8[0x0],r9
80003b7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b7e:	4e 09       	lddpc	r9,80003cfc <phy_rx_func+0xec4>
80003b80:	72 08       	ld.w	r8,r9[0x0]
80003b82:	20 18       	sub	r8,1
80003b84:	93 08       	st.w	r9[0x0],r8
80003b86:	c0 61       	brne	80003b92 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b88:	30 09       	mov	r9,0
80003b8a:	4d b8       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003b8c:	91 09       	st.w	r8[0x0],r9
80003b8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b92:	4e 18       	lddpc	r8,80003d14 <phy_rx_func+0xedc>
80003b94:	4d 79       	lddpc	r9,80003cf0 <phy_rx_func+0xeb8>
80003b96:	72 0a       	ld.w	r10,r9[0x0]
80003b98:	70 09       	ld.w	r9,r8[0x0]
80003b9a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b9e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ba2:	70 09       	ld.w	r9,r8[0x0]
80003ba4:	2f f9       	sub	r9,-1
80003ba6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ba8:	e0 49 01 ff 	cp.w	r9,511
80003bac:	e0 88 00 13 	brls	80003bd2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003bb0:	30 09       	mov	r9,0
80003bb2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003bb4:	4c f7       	lddpc	r7,80003cf0 <phy_rx_func+0xeb8>
80003bb6:	6e 0c       	ld.w	r12,r7[0x0]
80003bb8:	f0 1f 00 59 	mcall	80003d1c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bbc:	4c b8       	lddpc	r8,80003ce8 <phy_rx_func+0xeb0>
80003bbe:	70 0c       	ld.w	r12,r8[0x0]
80003bc0:	f0 1f 00 44 	mcall	80003cd0 <phy_rx_func+0xe98>
80003bc4:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003bc6:	c0 61       	brne	80003bd2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003bc8:	30 09       	mov	r9,0
80003bca:	4c b8       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003bcc:	91 09       	st.w	r8[0x0],r9
80003bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003bd2:	4c b9       	lddpc	r9,80003cfc <phy_rx_func+0xec4>
80003bd4:	72 08       	ld.w	r8,r9[0x0]
80003bd6:	20 18       	sub	r8,1
80003bd8:	93 08       	st.w	r9[0x0],r8
80003bda:	c6 c1       	brne	80003cb2 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003bdc:	30 09       	mov	r9,0
80003bde:	4c 68       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003be0:	91 09       	st.w	r8[0x0],r9
80003be2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003be6:	30 09       	mov	r9,0
80003be8:	4c 38       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003bea:	91 09       	st.w	r8[0x0],r9
80003bec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003bf0:	8e 4a       	ld.sh	r10,r7[0x8]
80003bf2:	4d 99       	lddpc	r9,80003d54 <phy_rx_func+0xf1c>
80003bf4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bf8:	4d 6a       	lddpc	r10,80003d50 <phy_rx_func+0xf18>
80003bfa:	15 88       	ld.ub	r8,r10[0x0]
80003bfc:	f0 cb ff ff 	sub	r11,r8,-1
80003c00:	8e 5c       	ld.sh	r12,r7[0xa]
80003c02:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003c06:	f0 cb ff fe 	sub	r11,r8,-2
80003c0a:	8e 6c       	ld.sh	r12,r7[0xc]
80003c0c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c10:	f0 cb ff fd 	sub	r11,r8,-3
80003c14:	8e 7c       	ld.sh	r12,r7[0xe]
80003c16:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003c1a:	2f c8       	sub	r8,-4
80003c1c:	b4 88       	st.b	r10[0x0],r8
80003c1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003c22:	30 09       	mov	r9,0
80003c24:	4b 48       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003c26:	91 09       	st.w	r8[0x0],r9
80003c28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003c2c:	4c 08       	lddpc	r8,80003d2c <phy_rx_func+0xef4>
80003c2e:	70 09       	ld.w	r9,r8[0x0]
80003c30:	8e 4b       	ld.sh	r11,r7[0x8]
80003c32:	4c 0a       	lddpc	r10,80003d30 <phy_rx_func+0xef8>
80003c34:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c38:	2f f9       	sub	r9,-1
80003c3a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c3c:	4b 58       	lddpc	r8,80003d10 <phy_rx_func+0xed8>
80003c3e:	70 09       	ld.w	r9,r8[0x0]
80003c40:	20 29       	sub	r9,2
80003c42:	91 09       	st.w	r8[0x0],r9
80003c44:	70 08       	ld.w	r8,r8[0x0]
80003c46:	58 08       	cp.w	r8,0
80003c48:	c2 f1       	brne	80003ca6 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c4a:	30 09       	mov	r9,0
80003c4c:	4b 88       	lddpc	r8,80003d2c <phy_rx_func+0xef4>
80003c4e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c50:	8e 59       	ld.sh	r9,r7[0xa]
80003c52:	fe 78 82 12 	mov	r8,-32238
80003c56:	f0 09 19 00 	cp.h	r9,r8
80003c5a:	c2 11       	brne	80003c9c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c5c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c60:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c64:	4a f8       	lddpc	r8,80003d20 <phy_rx_func+0xee8>
80003c66:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c68:	8e 59       	ld.sh	r9,r7[0xa]
80003c6a:	4a f8       	lddpc	r8,80003d24 <phy_rx_func+0xeec>
80003c6c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c6e:	8e 69       	ld.sh	r9,r7[0xc]
80003c70:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c72:	f0 1f 00 2e 	mcall	80003d28 <phy_rx_func+0xef0>
80003c76:	4a 18       	lddpc	r8,80003cf8 <phy_rx_func+0xec0>
80003c78:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c7a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c7e:	31 38       	mov	r8,19
80003c80:	f0 09 18 00 	cp.b	r9,r8
80003c84:	c0 71       	brne	80003c92 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c86:	10 99       	mov	r9,r8
80003c88:	4a 18       	lddpc	r8,80003d0c <phy_rx_func+0xed4>
80003c8a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c8c:	30 09       	mov	r9,0
80003c8e:	49 c8       	lddpc	r8,80003cfc <phy_rx_func+0xec4>
80003c90:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c92:	30 49       	mov	r9,4
80003c94:	49 88       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003c96:	91 09       	st.w	r8[0x0],r9
80003c98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c9c:	30 09       	mov	r9,0
80003c9e:	49 68       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003ca0:	91 09       	st.w	r8[0x0],r9
80003ca2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ca6:	4a dc       	lddpc	r12,80003d58 <phy_rx_func+0xf20>
80003ca8:	f0 1f 00 18 	mcall	80003d08 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003cac:	30 09       	mov	r9,0
80003cae:	49 28       	lddpc	r8,80003cf4 <phy_rx_func+0xebc>
80003cb0:	91 09       	st.w	r8[0x0],r9
80003cb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003cb6:	00 00       	add	r0,r0
80003cb8:	00 00       	add	r0,r0
80003cba:	0a b0       	st.h	r5++,r0
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a c8       	st.b	r5++,r8
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a a8       	st.w	r5++,r8
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a 8a       	andn	r10,r5
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 78       	tst	r8,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	0a a0       	st.w	r5++,r0
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	2c b8       	sub	r8,-53
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 98       	mov	r8,r5
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	2b d0       	sub	r0,-67
80003cdc:	00 00       	add	r0,r0
80003cde:	0a ac       	st.w	r5++,r12
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	2c 04       	sub	r4,-64
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a 89       	andn	r9,r5
80003ce8:	00 00       	add	r0,r0
80003cea:	0a a4       	st.w	r5++,r4
80003cec:	00 00       	add	r0,r0
80003cee:	0a b4       	st.h	r5++,r4
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 8c       	andn	r12,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	0a d4       	st.w	--r5,r4
80003cf8:	00 00       	add	r0,r0
80003cfa:	0a bc       	st.h	r5++,r12
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a 74       	tst	r4,r5
80003d00:	00 00       	add	r0,r0
80003d02:	0a 54       	eor	r4,r5
80003d04:	80 00       	ld.sh	r0,r0[0x0]
80003d06:	d7 f4       	*unknown*
80003d08:	80 00       	ld.sh	r0,r0[0x0]
80003d0a:	70 bc       	ld.w	r12,r8[0x2c]
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a 88       	andn	r8,r5
80003d10:	00 00       	add	r0,r0
80003d12:	0a e0       	st.h	--r5,r0
80003d14:	00 00       	add	r0,r0
80003d16:	0a c0       	st.b	r5++,r0
80003d18:	80 00       	ld.sh	r0,r0[0x0]
80003d1a:	78 f4       	ld.w	r4,r12[0x3c]
80003d1c:	80 00       	ld.sh	r0,r0[0x0]
80003d1e:	2b ec       	sub	r12,-66
80003d20:	00 00       	add	r0,r0
80003d22:	0a 48       	or	r8,r5
80003d24:	00 00       	add	r0,r0
80003d26:	1e b4       	st.h	pc++,r4
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	2b a0       	sub	r0,-70
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a 7c       	tst	r12,r5
80003d30:	00 00       	add	r0,r0
80003d32:	1d b8       	ld.ub	r8,lr[0x3]
80003d34:	00 00       	add	r0,r0
80003d36:	0a 80       	andn	r0,r5
80003d38:	00 00       	add	r0,r0
80003d3a:	0a 49       	or	r9,r5
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a 4c       	or	r12,r5
80003d40:	00 00       	add	r0,r0
80003d42:	0a d8       	st.w	--r5,r8
80003d44:	00 00       	add	r0,r0
80003d46:	0a 94       	mov	r4,r5
80003d48:	00 00       	add	r0,r0
80003d4a:	0a 5c       	eor	r12,r5
80003d4c:	00 00       	add	r0,r0
80003d4e:	1d b0       	ld.ub	r0,lr[0x3]
80003d50:	00 00       	add	r0,r0
80003d52:	0a cc       	st.b	r5++,r12
80003d54:	00 00       	add	r0,r0
80003d56:	1e b8       	st.h	pc++,r8
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	d8 0c       	*unknown*

80003d5c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d5c:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d5e:	49 a8       	lddpc	r8,80003dc4 <pdca_int_handler+0x68>
80003d60:	70 09       	ld.w	r9,r8[0x0]
80003d62:	2f f9       	sub	r9,-1
80003d64:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d66:	49 98       	lddpc	r8,80003dc8 <pdca_int_handler+0x6c>
80003d68:	11 89       	ld.ub	r9,r8[0x0]
80003d6a:	ec 19 00 01 	eorl	r9,0x1
80003d6e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d70:	11 89       	ld.ub	r9,r8[0x0]
80003d72:	a5 69       	lsl	r9,0x4
80003d74:	2f c9       	sub	r9,-4
80003d76:	49 6a       	lddpc	r10,80003dcc <pdca_int_handler+0x70>
80003d78:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d7a:	fe 7a 00 40 	mov	r10,-65472
80003d7e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d80:	30 39       	mov	r9,3
80003d82:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d84:	11 8a       	ld.ub	r10,r8[0x0]
80003d86:	a5 6a       	lsl	r10,0x4
80003d88:	2f ca       	sub	r10,-4
80003d8a:	49 28       	lddpc	r8,80003dd0 <pdca_int_handler+0x74>
80003d8c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d8e:	fe 78 00 00 	mov	r8,-65536
80003d92:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d94:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d96:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d98:	48 f8       	lddpc	r8,80003dd4 <pdca_int_handler+0x78>
80003d9a:	70 08       	ld.w	r8,r8[0x0]
80003d9c:	58 08       	cp.w	r8,0
80003d9e:	c0 70       	breq	80003dac <pdca_int_handler+0x50>
80003da0:	48 a9       	lddpc	r9,80003dc8 <pdca_int_handler+0x6c>
80003da2:	13 89       	ld.ub	r9,r9[0x0]
80003da4:	a5 69       	lsl	r9,0x4
80003da6:	48 bc       	lddpc	r12,80003dd0 <pdca_int_handler+0x74>
80003da8:	12 0c       	add	r12,r9
80003daa:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003dac:	48 b8       	lddpc	r8,80003dd8 <pdca_int_handler+0x7c>
80003dae:	70 08       	ld.w	r8,r8[0x0]
80003db0:	58 08       	cp.w	r8,0
80003db2:	c0 70       	breq	80003dc0 <pdca_int_handler+0x64>
80003db4:	48 59       	lddpc	r9,80003dc8 <pdca_int_handler+0x6c>
80003db6:	13 89       	ld.ub	r9,r9[0x0]
80003db8:	a5 69       	lsl	r9,0x4
80003dba:	48 5c       	lddpc	r12,80003dcc <pdca_int_handler+0x70>
80003dbc:	12 0c       	add	r12,r9
80003dbe:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003dc0:	d4 02       	popm	lr
80003dc2:	d6 03       	rete
80003dc4:	00 00       	add	r0,r0
80003dc6:	0a e8       	st.h	--r5,r8
80003dc8:	00 00       	add	r0,r0
80003dca:	50 d8       	stdsp	sp[0x34],r8
80003dcc:	00 00       	add	r0,r0
80003dce:	51 00       	stdsp	sp[0x40],r0
80003dd0:	00 00       	add	r0,r0
80003dd2:	50 e0       	stdsp	sp[0x38],r0
80003dd4:	00 00       	add	r0,r0
80003dd6:	0a e4       	st.h	--r5,r4
80003dd8:	00 00       	add	r0,r0
80003dda:	0a ec       	st.h	--r5,r12

80003ddc <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003ddc:	fe 78 10 00 	mov	r8,-61440
80003de0:	e0 69 0d c0 	mov	r9,3520
80003de4:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003de8:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003dec:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003df0:	fe 78 34 00 	mov	r8,-52224
80003df4:	e0 69 80 00 	mov	r9,32768
80003df8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dfa:	30 09       	mov	r9,0
80003dfc:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003dfe:	e0 69 04 21 	mov	r9,1057
80003e02:	ea 19 3f 20 	orh	r9,0x3f20
80003e06:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003e08:	e0 69 02 9f 	mov	r9,671
80003e0c:	ea 19 01 00 	orh	r9,0x100
80003e10:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e12:	e0 6a 04 02 	mov	r10,1026
80003e16:	ea 1a 3f 20 	orh	r10,0x3f20
80003e1a:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003e1c:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003e1e:	5e fc       	retal	r12

80003e20 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003e20:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003e22:	30 19       	mov	r9,1
80003e24:	49 78       	lddpc	r8,80003e80 <local_start_PDC+0x60>
80003e26:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e28:	fe 78 00 00 	mov	r8,-65536
80003e2c:	30 7b       	mov	r11,7
80003e2e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e30:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e32:	49 59       	lddpc	r9,80003e84 <local_start_PDC+0x64>
80003e34:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e38:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e3a:	30 3a       	mov	r10,3
80003e3c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e3e:	30 1c       	mov	r12,1
80003e40:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e42:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e44:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e46:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e48:	30 2c       	mov	r12,2
80003e4a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e4c:	48 f9       	lddpc	r9,80003e88 <local_start_PDC+0x68>
80003e4e:	e0 68 5a 5a 	mov	r8,23130
80003e52:	ea 18 ab cd 	orh	r8,0xabcd
80003e56:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e58:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e5a:	30 0e       	mov	lr,0
80003e5c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e5e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e60:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e62:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e64:	fe 78 00 40 	mov	r8,-65472
80003e68:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e6a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e6c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e70:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e72:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e74:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e76:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e78:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e7a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e7c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e7e:	d8 02       	popm	pc
80003e80:	00 00       	add	r0,r0
80003e82:	50 d8       	stdsp	sp[0x34],r8
80003e84:	00 00       	add	r0,r0
80003e86:	50 e0       	stdsp	sp[0x38],r0
80003e88:	00 00       	add	r0,r0
80003e8a:	51 00       	stdsp	sp[0x40],r0

80003e8c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e8c:	48 38       	lddpc	r8,80003e98 <register_rx_tx_func+0xc>
80003e8e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e90:	48 38       	lddpc	r8,80003e9c <register_rx_tx_func+0x10>
80003e92:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e94:	5e fc       	retal	r12
80003e96:	00 00       	add	r0,r0
80003e98:	00 00       	add	r0,r0
80003e9a:	0a e4       	st.h	--r5,r4
80003e9c:	00 00       	add	r0,r0
80003e9e:	0a ec       	st.h	--r5,r12

80003ea0 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003ea0:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003ea2:	fe 78 10 00 	mov	r8,-61440
80003ea6:	30 29       	mov	r9,2
80003ea8:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003eac:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003eb0:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003eb2:	30 3a       	mov	r10,3
80003eb4:	36 0b       	mov	r11,96
80003eb6:	49 4c       	lddpc	r12,80003f04 <ssc_init+0x64>
80003eb8:	f0 1f 00 14 	mcall	80003f08 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003ebc:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003ebe:	fe 79 10 00 	mov	r9,-61440
80003ec2:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ec6:	e2 18 00 02 	andl	r8,0x2,COH
80003eca:	cf c0       	breq	80003ec2 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ecc:	fe 79 10 00 	mov	r9,-61440
80003ed0:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ed4:	e2 18 00 02 	andl	r8,0x2,COH
80003ed8:	cf c1       	brne	80003ed0 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003eda:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003edc:	f0 1f 00 0c 	mcall	80003f0c <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ee0:	f0 1f 00 0c 	mcall	80003f10 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ee4:	fe 79 00 00 	mov	r9,-65536
80003ee8:	30 18       	mov	r8,1
80003eea:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003eec:	fe 7a 00 40 	mov	r10,-65472
80003ef0:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ef2:	e0 6b 01 01 	mov	r11,257
80003ef6:	fe 7a 34 00 	mov	r10,-52224
80003efa:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003efc:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003efe:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f00:	d8 02       	popm	pc
80003f02:	00 00       	add	r0,r0
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	3d 5c       	mov	r12,-43
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	54 f0       	stdsp	sp[0x13c],r0
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	3d dc       	mov	r12,-35
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	3e 20       	mov	r0,-30

80003f14 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f14:	48 28       	lddpc	r8,80003f1c <xcmp_register_app_list+0x8>
80003f16:	91 0c       	st.w	r8[0x0],r12
}
80003f18:	5e fc       	retal	r12
80003f1a:	00 00       	add	r0,r0
80003f1c:	00 00       	add	r0,r0
80003f1e:	51 20       	stdsp	sp[0x48],r0

80003f20 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003f20:	eb cd 40 80 	pushm	r7,lr
80003f24:	fa cd 01 00 	sub	sp,sp,256
80003f28:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f2a:	16 98       	mov	r8,r11
80003f2c:	2f 08       	sub	r8,-16
80003f2e:	af a8       	sbr	r8,0xe
80003f30:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f32:	3f f8       	mov	r8,-1
80003f34:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f36:	30 b9       	mov	r9,11
80003f38:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f3a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f3c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f3e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f40:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f42:	f6 ca ff fe 	sub	r10,r11,-2
80003f46:	18 9b       	mov	r11,r12
80003f48:	fa cc ff f0 	sub	r12,sp,-16
80003f4c:	f0 1f 00 05 	mcall	80003f60 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f50:	2f e7       	sub	r7,-2
80003f52:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f54:	1a 9c       	mov	r12,sp
80003f56:	f0 1f 00 04 	mcall	80003f64 <xcmp_tx+0x44>
}
80003f5a:	2c 0d       	sub	sp,-256
80003f5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	77 ac       	ld.w	r12,r11[0x68]
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	45 2c       	lddsp	r12,sp[0x148]

80003f68 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f68:	d4 21       	pushm	r4-r7,lr
80003f6a:	fa cd 00 d0 	sub	sp,sp,208
80003f6e:	18 94       	mov	r4,r12
80003f70:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f72:	e0 68 01 00 	mov	r8,256
80003f76:	f0 0b 19 00 	cp.h	r11,r8
80003f7a:	e0 8b 00 36 	brhi	80003fe6 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f7e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f82:	e0 68 04 1d 	mov	r8,1053
80003f86:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f88:	30 18       	mov	r8,1
80003f8a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f8c:	32 08       	mov	r8,32
80003f8e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f90:	30 28       	mov	r8,2
80003f92:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f94:	30 48       	mov	r8,4
80003f96:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f98:	ea 1a 0c 00 	orh	r10,0xc00
80003f9c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f9e:	30 4a       	mov	r10,4
80003fa0:	1a 9b       	mov	r11,sp
80003fa2:	fa cc ff f4 	sub	r12,sp,-12
80003fa6:	f0 1f 00 12 	mcall	80003fec <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003faa:	30 f8       	mov	r8,15
80003fac:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003fb0:	3a 78       	mov	r8,-89
80003fb2:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003fb6:	30 08       	mov	r8,0
80003fb8:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003fbc:	0e 9a       	mov	r10,r7
80003fbe:	5c 7a       	castu.h	r10
80003fc0:	f4 08 16 08 	lsr	r8,r10,0x8
80003fc4:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003fc8:	0e 96       	mov	r6,r7
80003fca:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003fce:	08 9b       	mov	r11,r4
80003fd0:	fa cc ff eb 	sub	r12,sp,-21
80003fd4:	f0 1f 00 06 	mcall	80003fec <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003fd8:	ee cb ff f3 	sub	r11,r7,-13
80003fdc:	5c 5b       	castu.b	r11
80003fde:	fa cc ff fa 	sub	r12,sp,-6
80003fe2:	f0 1f 00 04 	mcall	80003ff0 <xcmp_data_session_req+0x88>
}
80003fe6:	2c cd       	sub	sp,-208
80003fe8:	d8 22       	popm	r4-r7,pc
80003fea:	00 00       	add	r0,r0
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	77 ac       	ld.w	r12,r11[0x68]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	3f 20       	mov	r0,-14

80003ff4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003ff4:	d4 01       	pushm	lr
80003ff6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ffa:	fe 78 b4 00 	mov	r8,-19456
80003ffe:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004000:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004004:	30 89       	mov	r9,8
80004006:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004008:	30 19       	mov	r9,1
8000400a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
8000400c:	30 09       	mov	r9,0
8000400e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004010:	30 5a       	mov	r10,5
80004012:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004014:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004016:	30 7a       	mov	r10,7
80004018:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000401a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000401c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000401e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004022:	30 9b       	mov	r11,9
80004024:	fa cc ff fe 	sub	r12,sp,-2
80004028:	f0 1f 00 02 	mcall	80004030 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000402c:	2c dd       	sub	sp,-204
8000402e:	d8 02       	popm	pc
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	3f 20       	mov	r0,-14

80004034 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004034:	d4 01       	pushm	lr
80004036:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000403a:	fe 78 80 00 	mov	r8,-32768
8000403e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004040:	30 38       	mov	r8,3
80004042:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004044:	30 1b       	mov	r11,1
80004046:	fa cc ff fe 	sub	r12,sp,-2
8000404a:	f0 1f 00 03 	mcall	80004054 <xcmp_opcode_not_supported+0x20>
}
8000404e:	2c dd       	sub	sp,-204
80004050:	d8 02       	popm	pc
80004052:	00 00       	add	r0,r0
80004054:	80 00       	ld.sh	r0,r0[0x0]
80004056:	3f 20       	mov	r0,-14

80004058 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004058:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000405a:	96 88       	ld.uh	r8,r11[0x0]
8000405c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004060:	e0 48 80 00 	cp.w	r8,32768
80004064:	c0 f0       	breq	80004082 <xcmp_exec_func+0x2a>
80004066:	e0 48 b0 00 	cp.w	r8,45056
8000406a:	c1 20       	breq	8000408e <xcmp_exec_func+0x36>
8000406c:	58 08       	cp.w	r8,0
8000406e:	c1 51       	brne	80004098 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004070:	78 08       	ld.w	r8,r12[0x0]
80004072:	58 08       	cp.w	r8,0
80004074:	c0 40       	breq	8000407c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004076:	16 9c       	mov	r12,r11
80004078:	5d 18       	icall	r8
8000407a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
8000407c:	f0 1f 00 08 	mcall	8000409c <xcmp_exec_func+0x44>
80004080:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004082:	78 18       	ld.w	r8,r12[0x4]
80004084:	58 08       	cp.w	r8,0
80004086:	c0 90       	breq	80004098 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004088:	16 9c       	mov	r12,r11
8000408a:	5d 18       	icall	r8
8000408c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000408e:	78 28       	ld.w	r8,r12[0x8]
80004090:	58 08       	cp.w	r8,0
80004092:	c0 30       	breq	80004098 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004094:	16 9c       	mov	r12,r11
80004096:	5d 18       	icall	r8
80004098:	d8 02       	popm	pc
8000409a:	00 00       	add	r0,r0
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	40 34       	lddsp	r4,sp[0xc]

800040a0 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800040a0:	d4 01       	pushm	lr
800040a2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800040a6:	e0 68 04 09 	mov	r8,1033
800040aa:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800040ac:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800040b0:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800040b2:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800040b6:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800040b8:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800040ba:	30 09       	mov	r9,0
800040bc:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800040be:	fb 69 00 08 	st.b	sp[8],r9
800040c2:	fa c8 ff f7 	sub	r8,sp,-9
800040c6:	b0 89       	st.b	r8[0x0],r9
800040c8:	fa c8 ff f6 	sub	r8,sp,-10
800040cc:	b0 89       	st.b	r8[0x0],r9
800040ce:	fa c8 ff f5 	sub	r8,sp,-11
800040d2:	b0 89       	st.b	r8[0x0],r9
800040d4:	fa c8 ff f4 	sub	r8,sp,-12
800040d8:	b0 89       	st.b	r8[0x0],r9
800040da:	fa c8 ff f3 	sub	r8,sp,-13
800040de:	b0 89       	st.b	r8[0x0],r9
800040e0:	fa c8 ff f2 	sub	r8,sp,-14
800040e4:	b0 89       	st.b	r8[0x0],r9
800040e6:	fa c8 ff f1 	sub	r8,sp,-15
800040ea:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040ec:	30 cb       	mov	r11,12
800040ee:	fa cc ff fe 	sub	r12,sp,-2
800040f2:	f0 1f 00 03 	mcall	800040fc <xcmp_IdleTestTone+0x5c>
}
800040f6:	2c dd       	sub	sp,-204
800040f8:	d8 02       	popm	pc
800040fa:	00 00       	add	r0,r0
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	3f 20       	mov	r0,-14

80004100 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004100:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004102:	48 dc       	lddpc	r12,80004134 <xcmp_init+0x34>
80004104:	f0 1f 00 0d 	mcall	80004138 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004108:	30 4b       	mov	r11,4
8000410a:	31 4c       	mov	r12,20
8000410c:	f0 1f 00 0c 	mcall	8000413c <xcmp_init+0x3c>
80004110:	48 c8       	lddpc	r8,80004140 <xcmp_init+0x40>
80004112:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004114:	30 09       	mov	r9,0
80004116:	1a d9       	st.w	--sp,r9
80004118:	1a d9       	st.w	--sp,r9
8000411a:	1a d9       	st.w	--sp,r9
8000411c:	30 38       	mov	r8,3
8000411e:	e0 6a 04 00 	mov	r10,1024
80004122:	48 9b       	lddpc	r11,80004144 <xcmp_init+0x44>
80004124:	48 9c       	lddpc	r12,80004148 <xcmp_init+0x48>
80004126:	f0 1f 00 0a 	mcall	8000414c <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
8000412a:	f0 1f 00 0a 	mcall	80004150 <xcmp_init+0x50>
8000412e:	2f dd       	sub	sp,-12
	
}
80004130:	d8 02       	popm	pc
80004132:	00 00       	add	r0,r0
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	42 50       	lddsp	r0,sp[0x94]
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	42 9c       	lddsp	r12,sp[0xa4]
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	64 38       	ld.w	r8,r2[0xc]
80004140:	00 00       	add	r0,r0
80004142:	0b 08       	ld.w	r8,r5++
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	d8 38       	*unknown*
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	41 54       	lddsp	r4,sp[0x54]
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	6b 6c       	ld.w	r12,r5[0x58]
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	42 d4       	lddsp	r4,sp[0xb4]

80004154 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004154:	d4 31       	pushm	r0-r7,lr
80004156:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004158:	4b 16       	lddpc	r6,8000421c <xcmp_rx_process+0xc8>
8000415a:	30 05       	mov	r5,0
8000415c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000415e:	4b 13       	lddpc	r3,80004220 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004160:	4b 12       	lddpc	r2,80004224 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004162:	4b 21       	lddpc	r1,80004228 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004164:	4b 20       	lddpc	r0,8000422c <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004166:	6c 0c       	ld.w	r12,r6[0x0]
80004168:	0a 99       	mov	r9,r5
8000416a:	08 9a       	mov	r10,r4
8000416c:	1a 9b       	mov	r11,sp
8000416e:	f0 1f 00 31 	mcall	80004230 <xcmp_rx_process+0xdc>
80004172:	58 1c       	cp.w	r12,1
80004174:	cf 91       	brne	80004166 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004176:	40 0b       	lddsp	r11,sp[0x0]
80004178:	58 0b       	cp.w	r11,0
8000417a:	cf 60       	breq	80004166 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
8000417c:	96 0a       	ld.sh	r10,r11[0x0]
8000417e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004182:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004186:	59 c8       	cp.w	r8,28
80004188:	c1 e0       	breq	800041c4 <xcmp_rx_process+0x70>
8000418a:	e0 89 00 07 	brgt	80004198 <xcmp_rx_process+0x44>
8000418e:	58 e8       	cp.w	r8,14
80004190:	c0 e0       	breq	800041ac <xcmp_rx_process+0x58>
80004192:	58 f8       	cp.w	r8,15
80004194:	c2 41       	brne	800041dc <xcmp_rx_process+0x88>
80004196:	c0 f8       	rjmp	800041b4 <xcmp_rx_process+0x60>
80004198:	e0 48 01 09 	cp.w	r8,265
8000419c:	c1 80       	breq	800041cc <xcmp_rx_process+0x78>
8000419e:	e0 48 01 0a 	cp.w	r8,266
800041a2:	c1 90       	breq	800041d4 <xcmp_rx_process+0x80>
800041a4:	e0 48 00 2c 	cp.w	r8,44
800041a8:	c1 a1       	brne	800041dc <xcmp_rx_process+0x88>
800041aa:	c0 98       	rjmp	800041bc <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800041ac:	4a 2c       	lddpc	r12,80004234 <xcmp_rx_process+0xe0>
800041ae:	f0 1f 00 23 	mcall	80004238 <xcmp_rx_process+0xe4>
					break;
800041b2:	c2 f8       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800041b4:	4a 2c       	lddpc	r12,8000423c <xcmp_rx_process+0xe8>
800041b6:	f0 1f 00 21 	mcall	80004238 <xcmp_rx_process+0xe4>
					break;
800041ba:	c2 b8       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800041bc:	4a 1c       	lddpc	r12,80004240 <xcmp_rx_process+0xec>
800041be:	f0 1f 00 1f 	mcall	80004238 <xcmp_rx_process+0xe4>
					break;
800041c2:	c2 78       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041c4:	04 9c       	mov	r12,r2
800041c6:	f0 1f 00 1d 	mcall	80004238 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041ca:	c2 38       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041cc:	02 9c       	mov	r12,r1
800041ce:	f0 1f 00 1b 	mcall	80004238 <xcmp_rx_process+0xe4>
					break;
800041d2:	c1 f8       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041d4:	00 9c       	mov	r12,r0
800041d6:	f0 1f 00 19 	mcall	80004238 <xcmp_rx_process+0xe4>
					break;
800041da:	c1 b8       	rjmp	80004210 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041dc:	12 98       	mov	r8,r9
800041de:	e2 18 04 00 	andl	r8,0x400,COH
800041e2:	c0 70       	breq	800041f0 <xcmp_rx_process+0x9c>
800041e4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041e8:	e0 48 00 68 	cp.w	r8,104
800041ec:	e0 8a 00 08 	brle	800041fc <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041f0:	e2 19 f0 00 	andl	r9,0xf000,COH
800041f4:	c0 e1       	brne	80004210 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041f6:	f0 1f 00 14 	mcall	80004244 <xcmp_rx_process+0xf0>
800041fa:	c0 b8       	rjmp	80004210 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041fc:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004200:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004204:	49 19       	lddpc	r9,80004248 <xcmp_rx_process+0xf4>
80004206:	72 08       	ld.w	r8,r9[0x0]
80004208:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000420c:	f0 1f 00 0b 	mcall	80004238 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004210:	66 0c       	ld.w	r12,r3[0x0]
80004212:	40 0b       	lddsp	r11,sp[0x0]
80004214:	f0 1f 00 0e 	mcall	8000424c <xcmp_rx_process+0xf8>
80004218:	ca 7b       	rjmp	80004166 <xcmp_rx_process+0x12>
8000421a:	00 00       	add	r0,r0
8000421c:	00 00       	add	r0,r0
8000421e:	0b 08       	ld.w	r8,r5++
80004220:	00 00       	add	r0,r0
80004222:	0a a0       	st.w	r5++,r0
80004224:	00 00       	add	r0,r0
80004226:	0b 18       	ld.sh	r8,r5++
80004228:	00 00       	add	r0,r0
8000422a:	0b 0c       	ld.w	r12,r5++
8000422c:	00 00       	add	r0,r0
8000422e:	0a fc       	st.b	--r5,r12
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	60 d4       	ld.w	r4,r0[0x34]
80004234:	00 00       	add	r0,r0
80004236:	0b 30       	ld.ub	r0,r5++
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	40 58       	lddsp	r8,sp[0x14]
8000423c:	00 00       	add	r0,r0
8000423e:	0a f0       	st.b	--r5,r0
80004240:	00 00       	add	r0,r0
80004242:	0b 24       	ld.uh	r4,r5++
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	40 34       	lddsp	r4,sp[0xc]
80004248:	00 00       	add	r0,r0
8000424a:	51 20       	stdsp	sp[0x48],r0
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	2c 3c       	sub	r12,-61

80004250 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004250:	eb cd 40 90 	pushm	r4,r7,lr
80004254:	20 1d       	sub	sp,4
80004256:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000425a:	48 c8       	lddpc	r8,80004288 <xcmp_rx+0x38>
8000425c:	70 0c       	ld.w	r12,r8[0x0]
8000425e:	f0 1f 00 0c 	mcall	8000428c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004262:	c1 00       	breq	80004282 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004264:	fa c7 ff fc 	sub	r7,sp,-4
80004268:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000426a:	e0 6a 00 ca 	mov	r10,202
8000426e:	08 9b       	mov	r11,r4
80004270:	f0 1f 00 08 	mcall	80004290 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004274:	48 88       	lddpc	r8,80004294 <xcmp_rx+0x44>
80004276:	70 0c       	ld.w	r12,r8[0x0]
80004278:	30 09       	mov	r9,0
8000427a:	12 9a       	mov	r10,r9
8000427c:	1a 9b       	mov	r11,sp
8000427e:	f0 1f 00 07 	mcall	80004298 <xcmp_rx+0x48>
	}	
}
80004282:	2f fd       	sub	sp,-4
80004284:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004288:	00 00       	add	r0,r0
8000428a:	0a a0       	st.w	r5++,r0
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	2d e8       	sub	r8,-34
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	77 ac       	ld.w	r12,r11[0x68]
80004294:	00 00       	add	r0,r0
80004296:	0b 08       	ld.w	r8,r5++
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	62 e0       	ld.w	r0,r1[0x38]

8000429c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000429c:	48 28       	lddpc	r8,800042a4 <xnl_register_xcmp_func+0x8>
8000429e:	91 0c       	st.w	r8[0x0],r12
}
800042a0:	5e fc       	retal	r12
800042a2:	00 00       	add	r0,r0
800042a4:	00 00       	add	r0,r0
800042a6:	0b 5c       	ld.sh	r12,--r5

800042a8 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800042a8:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800042aa:	48 88       	lddpc	r8,800042c8 <xnl_get_msg_ack_func+0x20>
800042ac:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800042ae:	98 49       	ld.sh	r9,r12[0x8]
800042b0:	f0 09 19 00 	cp.h	r9,r8
800042b4:	c0 81       	brne	800042c4 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800042b6:	48 68       	lddpc	r8,800042cc <xnl_get_msg_ack_func+0x24>
800042b8:	70 0c       	ld.w	r12,r8[0x0]
800042ba:	30 09       	mov	r9,0
800042bc:	12 9a       	mov	r10,r9
800042be:	12 9b       	mov	r11,r9
800042c0:	f0 1f 00 04 	mcall	800042d0 <xnl_get_msg_ack_func+0x28>
800042c4:	d8 02       	popm	pc
800042c6:	00 00       	add	r0,r0
800042c8:	00 00       	add	r0,r0
800042ca:	0b 42       	ld.w	r2,--r5
800042cc:	00 00       	add	r0,r0
800042ce:	0b 3c       	ld.ub	r12,r5++
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	62 e0       	ld.w	r0,r1[0x38]

800042d4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042d4:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800042d8:	30 09       	mov	r9,0
800042da:	4b 78       	lddpc	r8,800043b4 <xnl_init+0xe0>
800042dc:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042de:	30 0b       	mov	r11,0
800042e0:	30 1c       	mov	r12,1
800042e2:	f0 1f 00 36 	mcall	800043b8 <xnl_init+0xe4>
800042e6:	4b 68       	lddpc	r8,800043bc <xnl_init+0xe8>
800042e8:	91 0c       	st.w	r8[0x0],r12
800042ea:	70 08       	ld.w	r8,r8[0x0]
800042ec:	58 08       	cp.w	r8,0
800042ee:	c0 80       	breq	800042fe <xnl_init+0x2a>
800042f0:	4b 38       	lddpc	r8,800043bc <xnl_init+0xe8>
800042f2:	70 0c       	ld.w	r12,r8[0x0]
800042f4:	30 09       	mov	r9,0
800042f6:	12 9a       	mov	r10,r9
800042f8:	12 9b       	mov	r11,r9
800042fa:	f0 1f 00 32 	mcall	800043c0 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042fe:	30 4b       	mov	r11,4
80004300:	31 4c       	mov	r12,20
80004302:	f0 1f 00 2e 	mcall	800043b8 <xnl_init+0xe4>
80004306:	4b 08       	lddpc	r8,800043c4 <xnl_init+0xf0>
80004308:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000430a:	30 4b       	mov	r11,4
8000430c:	31 ec       	mov	r12,30
8000430e:	f0 1f 00 2b 	mcall	800043b8 <xnl_init+0xe4>
80004312:	4a e8       	lddpc	r8,800043c8 <xnl_init+0xf4>
80004314:	91 0c       	st.w	r8[0x0],r12
80004316:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004318:	10 96       	mov	r6,r8
8000431a:	4a d5       	lddpc	r5,800043cc <xnl_init+0xf8>
8000431c:	6c 0c       	ld.w	r12,r6[0x0]
8000431e:	ea 07 00 0b 	add	r11,r5,r7
80004322:	f0 1f 00 2c 	mcall	800043d0 <xnl_init+0xfc>
80004326:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000432a:	e0 47 1e 00 	cp.w	r7,7680
8000432e:	cf 71       	brne	8000431c <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004330:	30 4b       	mov	r11,4
80004332:	31 4c       	mov	r12,20
80004334:	f0 1f 00 21 	mcall	800043b8 <xnl_init+0xe4>
80004338:	4a 78       	lddpc	r8,800043d4 <xnl_init+0x100>
8000433a:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000433c:	30 4b       	mov	r11,4
8000433e:	30 ac       	mov	r12,10
80004340:	f0 1f 00 1e 	mcall	800043b8 <xnl_init+0xe4>
80004344:	4a 58       	lddpc	r8,800043d8 <xnl_init+0x104>
80004346:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004348:	30 4b       	mov	r11,4
8000434a:	30 ac       	mov	r12,10
8000434c:	f0 1f 00 1b 	mcall	800043b8 <xnl_init+0xe4>
80004350:	4a 38       	lddpc	r8,800043dc <xnl_init+0x108>
80004352:	91 0c       	st.w	r8[0x0],r12
80004354:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004356:	10 96       	mov	r6,r8
80004358:	4a 25       	lddpc	r5,800043e0 <xnl_init+0x10c>
8000435a:	6c 0c       	ld.w	r12,r6[0x0]
8000435c:	ea 07 00 0b 	add	r11,r5,r7
80004360:	f0 1f 00 1c 	mcall	800043d0 <xnl_init+0xfc>
80004364:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004368:	e0 47 14 00 	cp.w	r7,5120
8000436c:	cf 71       	brne	8000435a <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000436e:	30 4b       	mov	r11,4
80004370:	30 5c       	mov	r12,5
80004372:	f0 1f 00 12 	mcall	800043b8 <xnl_init+0xe4>
80004376:	49 c8       	lddpc	r8,800043e4 <xnl_init+0x110>
80004378:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000437a:	30 07       	mov	r7,0
8000437c:	1a d7       	st.w	--sp,r7
8000437e:	1a d7       	st.w	--sp,r7
80004380:	1a d7       	st.w	--sp,r7
80004382:	30 38       	mov	r8,3
80004384:	0e 99       	mov	r9,r7
80004386:	e0 6a 00 dc 	mov	r10,220
8000438a:	49 8b       	lddpc	r11,800043e8 <xnl_init+0x114>
8000438c:	49 8c       	lddpc	r12,800043ec <xnl_init+0x118>
8000438e:	f0 1f 00 19 	mcall	800043f0 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004392:	1a d7       	st.w	--sp,r7
80004394:	1a d7       	st.w	--sp,r7
80004396:	1a d7       	st.w	--sp,r7
80004398:	30 38       	mov	r8,3
8000439a:	0e 99       	mov	r9,r7
8000439c:	e0 6a 00 82 	mov	r10,130
800043a0:	49 5b       	lddpc	r11,800043f4 <xnl_init+0x120>
800043a2:	49 6c       	lddpc	r12,800043f8 <xnl_init+0x124>
800043a4:	f0 1f 00 13 	mcall	800043f0 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800043a8:	f0 1f 00 15 	mcall	800043fc <xnl_init+0x128>
800043ac:	2f ad       	sub	sp,-24
}
800043ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043b2:	00 00       	add	r0,r0
800043b4:	00 00       	add	r0,r0
800043b6:	0b 42       	ld.w	r2,--r5
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	64 38       	ld.w	r8,r2[0xc]
800043bc:	00 00       	add	r0,r0
800043be:	0b 3c       	ld.ub	r12,r5++
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	62 e0       	ld.w	r0,r1[0x38]
800043c4:	00 00       	add	r0,r0
800043c6:	0b 50       	ld.sh	r0,--r5
800043c8:	00 00       	add	r0,r0
800043ca:	0a a0       	st.w	r5++,r0
800043cc:	00 00       	add	r0,r0
800043ce:	32 d2       	mov	r2,45
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	2c 3c       	sub	r12,-61
800043d4:	00 00       	add	r0,r0
800043d6:	0a d0       	st.w	--r5,r0
800043d8:	00 00       	add	r0,r0
800043da:	0a b0       	st.h	r5++,r0
800043dc:	00 00       	add	r0,r0
800043de:	0a a4       	st.w	r5++,r4
800043e0:	00 00       	add	r0,r0
800043e2:	1e d2       	st.w	--pc,r2
800043e4:	00 00       	add	r0,r0
800043e6:	0a dc       	st.w	--r5,r12
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	d8 40       	acall	0x84
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	44 00       	lddsp	r0,sp[0x100]
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	6b 6c       	ld.w	r12,r5[0x58]
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	d8 48       	*unknown*
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	44 60       	lddsp	r0,sp[0x118]
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	2e 10       	sub	r0,-31

80004400 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004400:	eb cd 40 fe 	pushm	r1-r7,lr
80004404:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004406:	49 26       	lddpc	r6,8000444c <xnl_rx_process+0x4c>
80004408:	30 05       	mov	r5,0
8000440a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000440c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000440e:	49 11       	lddpc	r1,80004450 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004410:	49 12       	lddpc	r2,80004454 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004412:	6c 0c       	ld.w	r12,r6[0x0]
80004414:	0a 99       	mov	r9,r5
80004416:	08 9a       	mov	r10,r4
80004418:	1a 9b       	mov	r11,sp
8000441a:	f0 1f 00 10 	mcall	80004458 <xnl_rx_process+0x58>
8000441e:	58 1c       	cp.w	r12,1
80004420:	cf 91       	brne	80004412 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004422:	40 0c       	lddsp	r12,sp[0x0]
80004424:	58 0c       	cp.w	r12,0
80004426:	cf 60       	breq	80004412 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004428:	98 28       	ld.sh	r8,r12[0x4]
8000442a:	e6 08 19 00 	cp.h	r8,r3
8000442e:	e0 8b 00 0a 	brhi	80004442 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004432:	5c 78       	castu.h	r8
80004434:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004438:	58 09       	cp.w	r9,0
8000443a:	c0 40       	breq	80004442 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000443c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004440:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004442:	62 0c       	ld.w	r12,r1[0x0]
80004444:	40 0b       	lddsp	r11,sp[0x0]
80004446:	f0 1f 00 06 	mcall	8000445c <xnl_rx_process+0x5c>
8000444a:	ce 4b       	rjmp	80004412 <xnl_rx_process+0x12>
8000444c:	00 00       	add	r0,r0
8000444e:	0a b0       	st.h	r5++,r0
80004450:	00 00       	add	r0,r0
80004452:	0a a0       	st.w	r5++,r0
80004454:	00 00       	add	r0,r0
80004456:	04 f4       	st.b	--r2,r4
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	60 d4       	ld.w	r4,r0[0x34]
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	2c 3c       	sub	r12,-61

80004460 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004460:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004462:	4a a6       	lddpc	r6,80004508 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004464:	4a a2       	lddpc	r2,8000450c <xnl_tx_process+0xac>
80004466:	4a b4       	lddpc	r4,80004510 <xnl_tx_process+0xb0>
80004468:	30 07       	mov	r7,0
8000446a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000446c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000446e:	4a a5       	lddpc	r5,80004514 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004470:	4a a3       	lddpc	r3,80004518 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004472:	6c 08       	ld.w	r8,r6[0x0]
80004474:	58 08       	cp.w	r8,0
80004476:	c0 40       	breq	8000447e <xnl_tx_process+0x1e>
80004478:	58 18       	cp.w	r8,1
8000447a:	cf d1       	brne	80004474 <xnl_tx_process+0x14>
8000447c:	c2 48       	rjmp	800044c4 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000447e:	64 0c       	ld.w	r12,r2[0x0]
80004480:	0e 99       	mov	r9,r7
80004482:	02 9a       	mov	r10,r1
80004484:	08 9b       	mov	r11,r4
80004486:	f0 1f 00 26 	mcall	8000451c <xnl_tx_process+0xbc>
8000448a:	58 1c       	cp.w	r12,1
8000448c:	cf 31       	brne	80004472 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000448e:	68 0b       	ld.w	r11,r4[0x0]
80004490:	58 0b       	cp.w	r11,0
80004492:	cf 00       	breq	80004472 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004494:	96 28       	ld.sh	r8,r11[0x4]
80004496:	e0 08 19 00 	cp.h	r8,r0
8000449a:	c0 71       	brne	800044a8 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000449c:	4a 18       	lddpc	r8,80004520 <xnl_tx_process+0xc0>
8000449e:	70 08       	ld.w	r8,r8[0x0]
800044a0:	10 9c       	mov	r12,r8
800044a2:	f0 1f 00 21 	mcall	80004524 <xnl_tx_process+0xc4>
						break;
800044a6:	ce 6b       	rjmp	80004472 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800044a8:	16 9c       	mov	r12,r11
800044aa:	f0 1f 00 20 	mcall	80004528 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044ae:	30 18       	mov	r8,1
800044b0:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044b2:	66 0c       	ld.w	r12,r3[0x0]
800044b4:	0e 99       	mov	r9,r7
800044b6:	0e 9a       	mov	r10,r7
800044b8:	0e 9b       	mov	r11,r7
800044ba:	f0 1f 00 19 	mcall	8000451c <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800044be:	30 18       	mov	r8,1
800044c0:	8d 08       	st.w	r6[0x0],r8
800044c2:	cd 8b       	rjmp	80004472 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044c4:	66 0c       	ld.w	r12,r3[0x0]
800044c6:	0e 99       	mov	r9,r7
800044c8:	36 4a       	mov	r10,100
800044ca:	0e 9b       	mov	r11,r7
800044cc:	f0 1f 00 14 	mcall	8000451c <xnl_tx_process+0xbc>
800044d0:	58 1c       	cp.w	r12,1
800044d2:	c0 81       	brne	800044e2 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800044d4:	49 38       	lddpc	r8,80004520 <xnl_tx_process+0xc0>
800044d6:	70 0c       	ld.w	r12,r8[0x0]
800044d8:	68 0b       	ld.w	r11,r4[0x0]
800044da:	f0 1f 00 13 	mcall	80004524 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800044de:	8d 07       	st.w	r6[0x0],r7
800044e0:	cc 9b       	rjmp	80004472 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800044e2:	6a 08       	ld.w	r8,r5[0x0]
800044e4:	58 38       	cp.w	r8,3
800044e6:	e0 89 00 09 	brgt	800044f8 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800044ea:	68 0c       	ld.w	r12,r4[0x0]
800044ec:	f0 1f 00 0f 	mcall	80004528 <xnl_tx_process+0xc8>
						xnl_send_times++;
800044f0:	6a 08       	ld.w	r8,r5[0x0]
800044f2:	2f f8       	sub	r8,-1
800044f4:	8b 08       	st.w	r5[0x0],r8
800044f6:	cb eb       	rjmp	80004472 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044f8:	48 a8       	lddpc	r8,80004520 <xnl_tx_process+0xc0>
800044fa:	70 0c       	ld.w	r12,r8[0x0]
800044fc:	68 0b       	ld.w	r11,r4[0x0]
800044fe:	f0 1f 00 0a 	mcall	80004524 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004502:	8d 07       	st.w	r6[0x0],r7
80004504:	cb 7b       	rjmp	80004472 <xnl_tx_process+0x12>
80004506:	00 00       	add	r0,r0
80004508:	00 00       	add	r0,r0
8000450a:	0b 4c       	ld.w	r12,--r5
8000450c:	00 00       	add	r0,r0
8000450e:	0b 50       	ld.sh	r0,--r5
80004510:	00 00       	add	r0,r0
80004512:	0b 58       	ld.sh	r8,--r5
80004514:	00 00       	add	r0,r0
80004516:	0b 54       	ld.sh	r4,--r5
80004518:	00 00       	add	r0,r0
8000451a:	0b 3c       	ld.ub	r12,r5++
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	60 d4       	ld.w	r4,r0[0x34]
80004520:	00 00       	add	r0,r0
80004522:	0a a0       	st.w	r5++,r0
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	2c 3c       	sub	r12,-61
80004528:	80 00       	ld.sh	r0,r0[0x0]
8000452a:	2c 5c       	sub	r12,-59

8000452c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000452c:	eb cd 40 c0 	pushm	r6-r7,lr
80004530:	20 1d       	sub	sp,4
80004532:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004534:	98 39       	ld.sh	r9,r12[0x6]
80004536:	3f f8       	mov	r8,-1
80004538:	f0 09 19 00 	cp.h	r9,r8
8000453c:	c0 a1       	brne	80004550 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000453e:	4a e9       	lddpc	r9,800045f4 <xnl_tx+0xc8>
80004540:	13 88       	ld.ub	r8,r9[0x0]
80004542:	2f f8       	sub	r8,-1
80004544:	5c 58       	castu.b	r8
80004546:	b2 88       	st.b	r9[0x0],r8
80004548:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000454c:	a9 a8       	sbr	r8,0x8
8000454e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004550:	8c 49       	ld.sh	r9,r6[0x8]
80004552:	3f f8       	mov	r8,-1
80004554:	f0 09 19 00 	cp.h	r9,r8
80004558:	c0 41       	brne	80004560 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000455a:	4a 88       	lddpc	r8,800045f8 <xnl_tx+0xcc>
8000455c:	90 18       	ld.sh	r8,r8[0x2]
8000455e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004560:	8c 59       	ld.sh	r9,r6[0xa]
80004562:	3f f8       	mov	r8,-1
80004564:	f0 09 19 00 	cp.h	r9,r8
80004568:	c0 41       	brne	80004570 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000456a:	4a 48       	lddpc	r8,800045f8 <xnl_tx+0xcc>
8000456c:	90 28       	ld.sh	r8,r8[0x4]
8000456e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004570:	8c 69       	ld.sh	r9,r6[0xc]
80004572:	3f f8       	mov	r8,-1
80004574:	f0 09 19 00 	cp.h	r9,r8
80004578:	c0 e1       	brne	80004594 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000457a:	4a 08       	lddpc	r8,800045f8 <xnl_tx+0xcc>
8000457c:	90 49       	ld.sh	r9,r8[0x8]
8000457e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004580:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004582:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004584:	90 49       	ld.sh	r9,r8[0x8]
80004586:	e0 19 ff 00 	andl	r9,0xff00
8000458a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000458e:	f3 e8 10 08 	or	r8,r9,r8
80004592:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004594:	0d 98       	ld.ub	r8,r6[0x1]
80004596:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004598:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000459c:	10 0c       	add	r12,r8
8000459e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045a0:	58 0c       	cp.w	r12,0
800045a2:	e0 89 00 04 	brgt	800045aa <xnl_tx+0x7e>
800045a6:	30 09       	mov	r9,0
800045a8:	c0 d8       	rjmp	800045c2 <xnl_tx+0x96>
800045aa:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800045ae:	2f ec       	sub	r12,-2
800045b0:	30 09       	mov	r9,0
800045b2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800045b4:	15 1b       	ld.sh	r11,r10++
800045b6:	f6 09 00 09 	add	r9,r11,r9
800045ba:	5c 89       	casts.h	r9
		indextohWord     += 1;
800045bc:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045be:	18 38       	cp.w	r8,r12
800045c0:	cf a1       	brne	800045b4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800045c2:	5c 39       	neg	r9
800045c4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045c6:	48 e8       	lddpc	r8,800045fc <xnl_tx+0xd0>
800045c8:	70 0c       	ld.w	r12,r8[0x0]
800045ca:	f0 1f 00 0e 	mcall	80004600 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045ce:	c1 00       	breq	800045ee <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045d0:	fa c7 ff fc 	sub	r7,sp,-4
800045d4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045d6:	e0 6a 01 00 	mov	r10,256
800045da:	0c 9b       	mov	r11,r6
800045dc:	f0 1f 00 0a 	mcall	80004604 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045e0:	48 a8       	lddpc	r8,80004608 <xnl_tx+0xdc>
800045e2:	70 0c       	ld.w	r12,r8[0x0]
800045e4:	30 09       	mov	r9,0
800045e6:	12 9a       	mov	r10,r9
800045e8:	1a 9b       	mov	r11,sp
800045ea:	f0 1f 00 09 	mcall	8000460c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800045ee:	2f fd       	sub	sp,-4
800045f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045f4:	00 00       	add	r0,r0
800045f6:	0b 40       	ld.w	r0,--r5
800045f8:	00 00       	add	r0,r0
800045fa:	0b 42       	ld.w	r2,--r5
800045fc:	00 00       	add	r0,r0
800045fe:	0a a0       	st.w	r5++,r0
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	2d e8       	sub	r8,-34
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	77 ac       	ld.w	r12,r11[0x68]
80004608:	00 00       	add	r0,r0
8000460a:	0b 50       	ld.sh	r0,--r5
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	62 e0       	ld.w	r0,r1[0x38]

80004610 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004610:	eb cd 40 80 	pushm	r7,lr
80004614:	fa cd 01 00 	sub	sp,sp,256
80004618:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000461a:	e0 68 40 0e 	mov	r8,16398
8000461e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004620:	3f f8       	mov	r8,-1
80004622:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004624:	30 c8       	mov	r8,12
80004626:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004628:	98 38       	ld.sh	r8,r12[0x6]
8000462a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
8000462c:	98 58       	ld.sh	r8,r12[0xa]
8000462e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004630:	98 48       	ld.sh	r8,r12[0x8]
80004632:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004634:	98 68       	ld.sh	r8,r12[0xc]
80004636:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004638:	30 08       	mov	r8,0
8000463a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000463c:	1a 9c       	mov	r12,sp
8000463e:	f0 1f 00 0a 	mcall	80004664 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004642:	fa cd 00 cc 	sub	sp,sp,204
80004646:	e0 6a 00 ca 	mov	r10,202
8000464a:	ee cb ff f0 	sub	r11,r7,-16
8000464e:	1a 9c       	mov	r12,sp
80004650:	f0 1f 00 06 	mcall	80004668 <xnl_data_msg_func+0x58>
80004654:	48 68       	lddpc	r8,8000466c <xnl_data_msg_func+0x5c>
80004656:	70 08       	ld.w	r8,r8[0x0]
80004658:	5d 18       	icall	r8
8000465a:	fa cd ff 34 	sub	sp,sp,-204
}
8000465e:	2c 0d       	sub	sp,-256
80004660:	e3 cd 80 80 	ldm	sp++,r7,pc
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	45 2c       	lddsp	r12,sp[0x148]
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	77 ac       	ld.w	r12,r11[0x68]
8000466c:	00 00       	add	r0,r0
8000466e:	0b 5c       	ld.sh	r12,--r5

80004670 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004670:	d4 21       	pushm	r4-r7,lr
80004672:	fa cd 01 00 	sub	sp,sp,256
80004676:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004678:	4c 28       	lddpc	r8,80004780 <xnl_device_auth_reply_func+0x110>
8000467a:	11 88       	ld.ub	r8,r8[0x0]
8000467c:	58 08       	cp.w	r8,0
8000467e:	e0 81 00 7f 	brne	8000477c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004682:	4c 18       	lddpc	r8,80004784 <xnl_device_auth_reply_func+0x114>
80004684:	70 0c       	ld.w	r12,r8[0x0]
80004686:	30 09       	mov	r9,0
80004688:	12 9a       	mov	r10,r9
8000468a:	12 9b       	mov	r11,r9
8000468c:	f0 1f 00 3f 	mcall	80004788 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004690:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004694:	4b b8       	lddpc	r8,80004780 <xnl_device_auth_reply_func+0x110>
80004696:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004698:	ef 39 00 12 	ld.ub	r9,r7[18]
8000469c:	ef 38 00 13 	ld.ub	r8,r7[19]
800046a0:	b1 68       	lsl	r8,0x10
800046a2:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800046a6:	ef 38 00 15 	ld.ub	r8,r7[21]
800046aa:	f3 e8 10 08 	or	r8,r9,r8
800046ae:	ef 39 00 14 	ld.ub	r9,r7[20]
800046b2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800046b6:	ef 3a 00 16 	ld.ub	r10,r7[22]
800046ba:	ef 38 00 17 	ld.ub	r8,r7[23]
800046be:	b1 68       	lsl	r8,0x10
800046c0:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046c4:	ef 38 00 19 	ld.ub	r8,r7[25]
800046c8:	f5 e8 10 08 	or	r8,r10,r8
800046cc:	ef 3a 00 18 	ld.ub	r10,r7[24]
800046d0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800046d4:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046d6:	e0 64 79 b9 	mov	r4,31161
800046da:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046de:	e0 65 45 07 	mov	r5,17671
800046e2:	ea 15 8a bd 	orh	r5,0x8abd
800046e6:	e0 66 f9 3d 	mov	r6,63805
800046ea:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046ee:	e0 6e b8 cf 	mov	lr,47311
800046f2:	ea 1e 36 83 	orh	lr,0x3683
800046f6:	e0 67 aa 1c 	mov	r7,43548
800046fa:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046fe:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004700:	f4 08 00 0c 	add	r12,r10,r8
80004704:	f0 0b 15 04 	lsl	r11,r8,0x4
80004708:	0a 0b       	add	r11,r5
8000470a:	f9 eb 20 0b 	eor	r11,r12,r11
8000470e:	f0 0c 16 05 	lsr	r12,r8,0x5
80004712:	0c 0c       	add	r12,r6
80004714:	18 5b       	eor	r11,r12
80004716:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004718:	f2 0c 15 04 	lsl	r12,r9,0x4
8000471c:	1c 0c       	add	r12,lr
8000471e:	f2 0b 16 05 	lsr	r11,r9,0x5
80004722:	0e 0b       	add	r11,r7
80004724:	f9 eb 20 0b 	eor	r11,r12,r11
80004728:	f2 0a 00 0c 	add	r12,r9,r10
8000472c:	18 5b       	eor	r11,r12
8000472e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004730:	e0 6b 37 20 	mov	r11,14112
80004734:	ea 1b c6 ef 	orh	r11,0xc6ef
80004738:	16 3a       	cp.w	r10,r11
8000473a:	ce 21       	brne	800046fe <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000473c:	e0 6a 40 1a 	mov	r10,16410
80004740:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004742:	3f fa       	mov	r10,-1
80004744:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004746:	30 6b       	mov	r11,6
80004748:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000474a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000474c:	48 db       	lddpc	r11,80004780 <xnl_device_auth_reply_func+0x110>
8000474e:	96 1c       	ld.sh	r12,r11[0x2]
80004750:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004752:	96 2b       	ld.sh	r11,r11[0x4]
80004754:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004756:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004758:	30 ca       	mov	r10,12
8000475a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000475c:	30 0a       	mov	r10,0
8000475e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004762:	30 7a       	mov	r10,7
80004764:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004768:	30 2a       	mov	r10,2
8000476a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000476e:	fa ca ff ec 	sub	r10,sp,-20
80004772:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004774:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004776:	1a 9c       	mov	r12,sp
80004778:	f0 1f 00 05 	mcall	8000478c <xnl_device_auth_reply_func+0x11c>
}
8000477c:	2c 0d       	sub	sp,-256
8000477e:	d8 22       	popm	r4-r7,pc
80004780:	00 00       	add	r0,r0
80004782:	0b 42       	ld.w	r2,--r5
80004784:	00 00       	add	r0,r0
80004786:	0b 3c       	ld.ub	r12,r5++
80004788:	80 00       	ld.sh	r0,r0[0x0]
8000478a:	62 e0       	ld.w	r0,r1[0x38]
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	45 2c       	lddsp	r12,sp[0x148]

80004790 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004790:	eb cd 40 80 	pushm	r7,lr
80004794:	fa cd 01 00 	sub	sp,sp,256
80004798:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000479a:	49 28       	lddpc	r8,800047e0 <xnl_master_status_brdcst_func+0x50>
8000479c:	11 88       	ld.ub	r8,r8[0x0]
8000479e:	58 08       	cp.w	r8,0
800047a0:	c1 c1       	brne	800047d8 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800047a2:	49 18       	lddpc	r8,800047e4 <xnl_master_status_brdcst_func+0x54>
800047a4:	70 0c       	ld.w	r12,r8[0x0]
800047a6:	30 09       	mov	r9,0
800047a8:	12 9a       	mov	r10,r9
800047aa:	12 9b       	mov	r11,r9
800047ac:	f0 1f 00 0f 	mcall	800047e8 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800047b0:	8e 58       	ld.sh	r8,r7[0xa]
800047b2:	48 c9       	lddpc	r9,800047e0 <xnl_master_status_brdcst_func+0x50>
800047b4:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047b6:	e0 68 40 0e 	mov	r8,16398
800047ba:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047bc:	3f f8       	mov	r8,-1
800047be:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800047c0:	30 4a       	mov	r10,4
800047c2:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047c4:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047c6:	92 19       	ld.sh	r9,r9[0x2]
800047c8:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047ca:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047cc:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047ce:	30 08       	mov	r8,0
800047d0:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800047d2:	1a 9c       	mov	r12,sp
800047d4:	f0 1f 00 06 	mcall	800047ec <xnl_master_status_brdcst_func+0x5c>
}
800047d8:	2c 0d       	sub	sp,-256
800047da:	e3 cd 80 80 	ldm	sp++,r7,pc
800047de:	00 00       	add	r0,r0
800047e0:	00 00       	add	r0,r0
800047e2:	0b 42       	ld.w	r2,--r5
800047e4:	00 00       	add	r0,r0
800047e6:	0b 3c       	ld.ub	r12,r5++
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	62 e0       	ld.w	r0,r1[0x38]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	45 2c       	lddsp	r12,sp[0x148]

800047f0 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800047f0:	eb cd 40 80 	pushm	r7,lr
800047f4:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047f6:	49 28       	lddpc	r8,8000483c <xnl_device_conn_reply_func+0x4c>
800047f8:	70 0c       	ld.w	r12,r8[0x0]
800047fa:	30 09       	mov	r9,0
800047fc:	12 9a       	mov	r10,r9
800047fe:	12 9b       	mov	r11,r9
80004800:	f0 1f 00 10 	mcall	80004840 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004804:	ef 18 00 10 	ld.uh	r8,r7[16]
80004808:	10 99       	mov	r9,r8
8000480a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000480e:	e0 49 01 00 	cp.w	r9,256
80004812:	c0 60       	breq	8000481e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004814:	0e 9c       	mov	r12,r7
80004816:	f0 1f 00 0c 	mcall	80004844 <xnl_device_conn_reply_func+0x54>
8000481a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000481e:	a9 68       	lsl	r8,0x8
80004820:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004824:	48 98       	lddpc	r8,80004848 <xnl_device_conn_reply_func+0x58>
80004826:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004828:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000482c:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000482e:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004832:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004834:	30 19       	mov	r9,1
80004836:	b0 89       	st.b	r8[0x0],r9
80004838:	e3 cd 80 80 	ldm	sp++,r7,pc
8000483c:	00 00       	add	r0,r0
8000483e:	0b 3c       	ld.ub	r12,r5++
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	62 e0       	ld.w	r0,r1[0x38]
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	47 90       	lddsp	r0,sp[0x1e4]
80004848:	00 00       	add	r0,r0
8000484a:	0b 42       	ld.w	r2,--r5

8000484c <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
8000484c:	d4 01       	pushm	lr
8000484e:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004852:	e0 68 40 0e 	mov	r8,16398
80004856:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004858:	3f f8       	mov	r8,-1
8000485a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000485c:	30 38       	mov	r8,3
8000485e:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004860:	30 08       	mov	r8,0
80004862:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004864:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004866:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004868:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000486a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000486c:	1a 9c       	mov	r12,sp
8000486e:	f0 1f 00 03 	mcall	80004878 <xnl_send_device_master_query+0x2c>
}
80004872:	2c 0d       	sub	sp,-256
80004874:	d8 02       	popm	pc
80004876:	00 00       	add	r0,r0
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	45 2c       	lddsp	r12,sp[0x148]

8000487c <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000487c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000487e:	48 78       	lddpc	r8,80004898 <RC522_SPI_SetSpeed+0x1c>
80004880:	70 09       	ld.w	r9,r8[0x0]
80004882:	72 ca       	ld.w	r10,r9[0x30]
80004884:	5c 7c       	castu.h	r12
80004886:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000488a:	f9 ea 10 0a 	or	r10,r12,r10
8000488e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004890:	70 0c       	ld.w	r12,r8[0x0]
80004892:	f0 1f 00 03 	mcall	8000489c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004896:	d8 02       	popm	pc
80004898:	00 00       	add	r0,r0
8000489a:	1d ac       	ld.ub	r12,lr[0x2]
8000489c:	80 00       	ld.sh	r0,r0[0x0]
8000489e:	57 d0       	stdsp	sp[0x1f4],r0

800048a0 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800048a0:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800048a2:	e0 6c 0a 00 	mov	r12,2560
800048a6:	f0 1f 00 02 	mcall	800048ac <RC522_SPI_SetSpeedLow+0xc>
	
}
800048aa:	d8 02       	popm	pc
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	48 7c       	lddpc	r12,800048c8 <RC522_ReadByte+0x18>

800048b0 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800048b0:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800048b4:	48 76       	lddpc	r6,800048d0 <RC522_ReadByte+0x20>
800048b6:	e0 6b 00 ff 	mov	r11,255
800048ba:	6c 0c       	ld.w	r12,r6[0x0]
800048bc:	f0 1f 00 06 	mcall	800048d4 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800048c0:	30 07       	mov	r7,0
800048c2:	0e 9b       	mov	r11,r7
800048c4:	6c 0c       	ld.w	r12,r6[0x0]
800048c6:	f0 1f 00 05 	mcall	800048d8 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800048ca:	0f 9c       	ld.ub	r12,r7[0x1]
800048cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048d0:	00 00       	add	r0,r0
800048d2:	1d ac       	ld.ub	r12,lr[0x2]
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	57 d6       	stdsp	sp[0x1f4],r6
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	57 f2       	stdsp	sp[0x1fc],r2

800048dc <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800048dc:	eb cd 40 80 	pushm	r7,lr
800048e0:	20 1d       	sub	sp,4
800048e2:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048e4:	48 77       	lddpc	r7,80004900 <RC522_WriteByte+0x24>
800048e6:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800048ea:	6e 0c       	ld.w	r12,r7[0x0]
800048ec:	f0 1f 00 06 	mcall	80004904 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048f0:	1a 9b       	mov	r11,sp
800048f2:	6e 0c       	ld.w	r12,r7[0x0]
800048f4:	f0 1f 00 05 	mcall	80004908 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048f8:	5c 5c       	castu.b	r12
800048fa:	2f fd       	sub	sp,-4
800048fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004900:	00 00       	add	r0,r0
80004902:	1d ac       	ld.ub	r12,lr[0x2]
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	57 d6       	stdsp	sp[0x1f4],r6
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	57 f2       	stdsp	sp[0x1fc],r2

8000490c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000490c:	eb cd 40 e0 	pushm	r5-r7,lr
80004910:	18 96       	mov	r6,r12
80004912:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004914:	48 a7       	lddpc	r7,8000493c <WriteRawRC+0x30>
80004916:	30 0b       	mov	r11,0
80004918:	6e 0c       	ld.w	r12,r7[0x0]
8000491a:	f0 1f 00 0a 	mcall	80004940 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000491e:	ec 0c 15 01 	lsl	r12,r6,0x1
80004922:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004926:	f0 1f 00 08 	mcall	80004944 <WriteRawRC+0x38>
	RC522_WriteByte(value);
8000492a:	0a 9c       	mov	r12,r5
8000492c:	f0 1f 00 06 	mcall	80004944 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004930:	30 0b       	mov	r11,0
80004932:	6e 0c       	ld.w	r12,r7[0x0]
80004934:	f0 1f 00 05 	mcall	80004948 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000493c:	00 00       	add	r0,r0
8000493e:	1d ac       	ld.ub	r12,lr[0x2]
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	59 3c       	cp.w	r12,19
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	48 dc       	lddpc	r12,80004978 <PcdReset+0x2c>
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	58 fc       	cp.w	r12,15

8000494c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000494c:	d4 01       	pushm	lr

	SET_RC522RST;
8000494e:	31 9c       	mov	r12,25
80004950:	f0 1f 00 1b 	mcall	800049bc <PcdReset+0x70>
	delay_ns(10);
80004954:	30 ac       	mov	r12,10
80004956:	f0 1f 00 1b 	mcall	800049c0 <PcdReset+0x74>

	CLR_RC522RST;
8000495a:	31 9c       	mov	r12,25
8000495c:	f0 1f 00 1a 	mcall	800049c4 <PcdReset+0x78>
	delay_ns(10);
80004960:	30 ac       	mov	r12,10
80004962:	f0 1f 00 18 	mcall	800049c0 <PcdReset+0x74>

	SET_RC522RST;
80004966:	31 9c       	mov	r12,25
80004968:	f0 1f 00 15 	mcall	800049bc <PcdReset+0x70>
	delay_ns(10);
8000496c:	30 ac       	mov	r12,10
8000496e:	f0 1f 00 15 	mcall	800049c0 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004972:	30 fb       	mov	r11,15
80004974:	30 1c       	mov	r12,1
80004976:	f0 1f 00 15 	mcall	800049c8 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000497a:	30 fb       	mov	r11,15
8000497c:	30 1c       	mov	r12,1
8000497e:	f0 1f 00 13 	mcall	800049c8 <PcdReset+0x7c>
	delay_ns(10);
80004982:	30 ac       	mov	r12,10
80004984:	f0 1f 00 0f 	mcall	800049c0 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004988:	33 db       	mov	r11,61
8000498a:	31 1c       	mov	r12,17
8000498c:	f0 1f 00 0f 	mcall	800049c8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004990:	31 eb       	mov	r11,30
80004992:	32 dc       	mov	r12,45
80004994:	f0 1f 00 0d 	mcall	800049c8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004998:	30 0b       	mov	r11,0
8000499a:	32 cc       	mov	r12,44
8000499c:	f0 1f 00 0b 	mcall	800049c8 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800049a0:	e0 6b 00 8d 	mov	r11,141
800049a4:	32 ac       	mov	r12,42
800049a6:	f0 1f 00 09 	mcall	800049c8 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800049aa:	33 eb       	mov	r11,62
800049ac:	32 bc       	mov	r12,43
800049ae:	f0 1f 00 07 	mcall	800049c8 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800049b2:	34 0b       	mov	r11,64
800049b4:	31 5c       	mov	r12,21
800049b6:	f0 1f 00 05 	mcall	800049c8 <PcdReset+0x7c>
	
	return MI_OK;
}
800049ba:	d8 0a       	popm	pc,r12=0
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	54 b4       	stdsp	sp[0x12c],r4
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	52 44       	stdsp	sp[0x90],r4
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	54 d0       	stdsp	sp[0x134],r0
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	49 0c       	lddpc	r12,80004a08 <ReadRawRC+0x3c>

800049cc <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049cc:	eb cd 40 c0 	pushm	r6-r7,lr
800049d0:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800049d2:	48 c7       	lddpc	r7,80004a00 <ReadRawRC+0x34>
800049d4:	30 0b       	mov	r11,0
800049d6:	6e 0c       	ld.w	r12,r7[0x0]
800049d8:	f0 1f 00 0b 	mcall	80004a04 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049dc:	a1 76       	lsl	r6,0x1
800049de:	0c 9c       	mov	r12,r6
800049e0:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049e4:	a7 bc       	sbr	r12,0x7
800049e6:	f0 1f 00 09 	mcall	80004a08 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800049ea:	f0 1f 00 09 	mcall	80004a0c <ReadRawRC+0x40>
800049ee:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049f0:	30 0b       	mov	r11,0
800049f2:	6e 0c       	ld.w	r12,r7[0x0]
800049f4:	f0 1f 00 07 	mcall	80004a10 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800049f8:	0c 9c       	mov	r12,r6
800049fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049fe:	00 00       	add	r0,r0
80004a00:	00 00       	add	r0,r0
80004a02:	1d ac       	ld.ub	r12,lr[0x2]
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	59 3c       	cp.w	r12,19
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 dc       	lddpc	r12,80004a3c <Powerdown_RC522+0x18>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	48 b0       	lddpc	r0,80004a38 <Powerdown_RC522+0x14>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	58 fc       	cp.w	r12,15

80004a14 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004a14:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004a16:	30 1c       	mov	r12,1
80004a18:	f0 1f 00 02 	mcall	80004a20 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004a1c:	d8 02       	popm	pc
80004a1e:	00 00       	add	r0,r0
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	49 cc       	lddpc	r12,80004a90 <SetBitMask+0x20>

80004a24 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004a24:	eb cd 40 80 	pushm	r7,lr
80004a28:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004a2a:	30 1c       	mov	r12,1
80004a2c:	f0 1f 00 0d 	mcall	80004a60 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004a30:	30 18       	mov	r8,1
80004a32:	f0 07 18 00 	cp.b	r7,r8
80004a36:	c0 91       	brne	80004a48 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004a38:	18 9b       	mov	r11,r12
80004a3a:	a5 ab       	sbr	r11,0x4
80004a3c:	5c 5b       	castu.b	r11
80004a3e:	30 1c       	mov	r12,1
80004a40:	f0 1f 00 09 	mcall	80004a64 <Powerdown_RC522+0x40>
80004a44:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004a48:	18 9b       	mov	r11,r12
80004a4a:	30 1c       	mov	r12,1
80004a4c:	f0 1f 00 06 	mcall	80004a64 <Powerdown_RC522+0x40>
		delay_ns(2);
80004a50:	30 2c       	mov	r12,2
80004a52:	f0 1f 00 06 	mcall	80004a68 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004a56:	f0 1f 00 06 	mcall	80004a6c <Powerdown_RC522+0x48>
80004a5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a5e:	00 00       	add	r0,r0
80004a60:	80 00       	ld.sh	r0,r0[0x0]
80004a62:	49 cc       	lddpc	r12,80004ad0 <ClearBitMask+0x1c>
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	49 0c       	lddpc	r12,80004aa4 <PcdAntennaOn+0x10>
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	52 44       	stdsp	sp[0x90],r4
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	4a 14       	lddpc	r4,80004af0 <M500PcdConfigISOType+0x4>

80004a70 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a70:	eb cd 40 c0 	pushm	r6-r7,lr
80004a74:	18 97       	mov	r7,r12
80004a76:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a78:	f0 1f 00 05 	mcall	80004a8c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a7c:	f9 e6 10 0b 	or	r11,r12,r6
80004a80:	5c 5b       	castu.b	r11
80004a82:	0e 9c       	mov	r12,r7
80004a84:	f0 1f 00 03 	mcall	80004a90 <SetBitMask+0x20>
}
80004a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	49 cc       	lddpc	r12,80004afc <M500PcdConfigISOType+0x10>
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	49 0c       	lddpc	r12,80004ad0 <ClearBitMask+0x1c>

80004a94 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a94:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a96:	31 4c       	mov	r12,20
80004a98:	f0 1f 00 05 	mcall	80004aac <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a9c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004aa0:	c0 51       	brne	80004aaa <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004aa2:	30 3b       	mov	r11,3
80004aa4:	31 4c       	mov	r12,20
80004aa6:	f0 1f 00 03 	mcall	80004ab0 <PcdAntennaOn+0x1c>
80004aaa:	d8 02       	popm	pc
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	49 cc       	lddpc	r12,80004b1c <M500PcdConfigISOType+0x30>
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	4a 70       	lddpc	r0,80004b4c <M500PcdConfigISOType+0x60>

80004ab4 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004ab4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ab8:	18 97       	mov	r7,r12
80004aba:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004abc:	f0 1f 00 06 	mcall	80004ad4 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004ac0:	5c d6       	com	r6
80004ac2:	f9 e6 00 06 	and	r6,r12,r6
80004ac6:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004aca:	0e 9c       	mov	r12,r7
80004acc:	f0 1f 00 03 	mcall	80004ad8 <ClearBitMask+0x24>
	
}
80004ad0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	49 cc       	lddpc	r12,80004b44 <M500PcdConfigISOType+0x58>
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	49 0c       	lddpc	r12,80004b18 <M500PcdConfigISOType+0x2c>

80004adc <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004adc:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004ade:	30 3b       	mov	r11,3
80004ae0:	31 4c       	mov	r12,20
80004ae2:	f0 1f 00 02 	mcall	80004ae8 <PcdAntennaOff+0xc>
}
80004ae6:	d8 02       	popm	pc
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	4a b4       	lddpc	r4,80004b94 <rc522_init+0x38>

80004aec <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004aec:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004aee:	34 18       	mov	r8,65
80004af0:	f0 0c 18 00 	cp.b	r12,r8
80004af4:	c0 20       	breq	80004af8 <M500PcdConfigISOType+0xc>
80004af6:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004af8:	30 8b       	mov	r11,8
80004afa:	16 9c       	mov	r12,r11
80004afc:	f0 1f 00 14 	mcall	80004b4c <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004b00:	33 db       	mov	r11,61
80004b02:	31 1c       	mov	r12,17
80004b04:	f0 1f 00 13 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b08:	e0 6b 00 86 	mov	r11,134
80004b0c:	31 7c       	mov	r12,23
80004b0e:	f0 1f 00 11 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b12:	37 fb       	mov	r11,127
80004b14:	32 6c       	mov	r12,38
80004b16:	f0 1f 00 0f 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b1a:	31 eb       	mov	r11,30
80004b1c:	32 dc       	mov	r12,45
80004b1e:	f0 1f 00 0d 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b22:	30 0b       	mov	r11,0
80004b24:	32 cc       	mov	r12,44
80004b26:	f0 1f 00 0b 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b2a:	e0 6b 00 8d 	mov	r11,141
80004b2e:	32 ac       	mov	r12,42
80004b30:	f0 1f 00 08 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b34:	33 eb       	mov	r11,62
80004b36:	32 bc       	mov	r12,43
80004b38:	f0 1f 00 06 	mcall	80004b50 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004b3c:	e0 6c 03 e8 	mov	r12,1000
80004b40:	f0 1f 00 05 	mcall	80004b54 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004b44:	f0 1f 00 05 	mcall	80004b58 <M500PcdConfigISOType+0x6c>
80004b48:	d8 0a       	popm	pc,r12=0
80004b4a:	00 00       	add	r0,r0
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	4a b4       	lddpc	r4,80004bf8 <rc522_init+0x9c>
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	49 0c       	lddpc	r12,80004b90 <rc522_init+0x34>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	52 44       	stdsp	sp[0x90],r4
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	4a 94       	lddpc	r4,80004bfc <rc522_init+0xa0>

80004b5c <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b5c:	eb cd 40 80 	pushm	r7,lr
80004b60:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b62:	49 d8       	lddpc	r8,80004bd4 <rc522_init+0x78>
80004b64:	1a 97       	mov	r7,sp
80004b66:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b6a:	fa eb 00 00 	st.d	sp[0],r10
80004b6e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b72:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b76:	30 1b       	mov	r11,1
80004b78:	49 8c       	lddpc	r12,80004bd8 <rc522_init+0x7c>
80004b7a:	f0 1f 00 19 	mcall	80004bdc <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b7e:	31 9c       	mov	r12,25
80004b80:	f0 1f 00 18 	mcall	80004be0 <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b84:	31 9c       	mov	r12,25
80004b86:	f0 1f 00 18 	mcall	80004be4 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004b8a:	fe 7c 24 00 	mov	r12,-56320
80004b8e:	49 78       	lddpc	r8,80004be8 <rc522_init+0x8c>
80004b90:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b92:	e0 6a 36 00 	mov	r10,13824
80004b96:	ea 1a 01 6e 	orh	r10,0x16e
80004b9a:	1a 9b       	mov	r11,sp
80004b9c:	f0 1f 00 14 	mcall	80004bec <rc522_init+0x90>
80004ba0:	c0 50       	breq	80004baa <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004ba2:	30 29       	mov	r9,2
80004ba4:	49 38       	lddpc	r8,80004bf0 <rc522_init+0x94>
80004ba6:	b0 89       	st.b	r8[0x0],r9
80004ba8:	c0 38       	rjmp	80004bae <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004baa:	f0 1f 00 13 	mcall	80004bf4 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004bae:	f0 1f 00 13 	mcall	80004bf8 <rc522_init+0x9c>
	
	PcdAntennaOff();
80004bb2:	f0 1f 00 13 	mcall	80004bfc <rc522_init+0xa0>
	
	delay_ms(2); 
80004bb6:	30 2c       	mov	r12,2
80004bb8:	f0 1f 00 12 	mcall	80004c00 <rc522_init+0xa4>
	
	PcdAntennaOn();
80004bbc:	f0 1f 00 12 	mcall	80004c04 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
80004bc0:	34 1c       	mov	r12,65
80004bc2:	f0 1f 00 12 	mcall	80004c08 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004bc6:	30 1c       	mov	r12,1
80004bc8:	f0 1f 00 11 	mcall	80004c0c <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004bcc:	2f cd       	sub	sp,-16
80004bce:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bd2:	00 00       	add	r0,r0
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	d8 58       	*unknown*
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	d8 68       	*unknown*
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	54 6c       	stdsp	sp[0x118],r12
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	54 9c       	stdsp	sp[0x124],r12
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	54 b4       	stdsp	sp[0x12c],r4
80004be8:	00 00       	add	r0,r0
80004bea:	1d ac       	ld.ub	r12,lr[0x2]
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	58 14       	cp.w	r4,1
80004bf0:	00 00       	add	r0,r0
80004bf2:	0b 60       	ld.uh	r0,--r5
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	48 a0       	lddpc	r0,80004c1c <PcdComMF522+0xc>
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	49 4c       	lddpc	r12,80004c48 <PcdComMF522+0x38>
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	4a dc       	lddpc	r12,80004cb0 <PcdComMF522+0xa0>
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	52 84       	stdsp	sp[0xa0],r4
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	4a 94       	lddpc	r4,80004ca8 <PcdComMF522+0x98>
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	4a ec       	lddpc	r12,80004cc0 <PcdComMF522+0xb0>
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	4a 24       	lddpc	r4,80004c94 <PcdComMF522+0x84>

80004c10 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c10:	d4 31       	pushm	r0-r7,lr
80004c12:	20 1d       	sub	sp,4
80004c14:	18 92       	mov	r2,r12
80004c16:	16 95       	mov	r5,r11
80004c18:	14 96       	mov	r6,r10
80004c1a:	50 09       	stdsp	sp[0x0],r9
80004c1c:	10 90       	mov	r0,r8
80004c1e:	f8 c8 00 0c 	sub	r8,r12,12
80004c22:	5c 58       	castu.b	r8
80004c24:	30 29       	mov	r9,2
80004c26:	f2 08 18 00 	cp.b	r8,r9
80004c2a:	e0 88 00 05 	brls	80004c34 <PcdComMF522+0x24>
80004c2e:	30 03       	mov	r3,0
80004c30:	06 91       	mov	r1,r3
80004c32:	c0 78       	rjmp	80004c40 <PcdComMF522+0x30>
80004c34:	4c f9       	lddpc	r9,80004d70 <PcdComMF522+0x160>
80004c36:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c3a:	4c f9       	lddpc	r9,80004d74 <PcdComMF522+0x164>
80004c3c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c40:	02 9b       	mov	r11,r1
80004c42:	a7 bb       	sbr	r11,0x7
80004c44:	30 2c       	mov	r12,2
80004c46:	f0 1f 00 4d 	mcall	80004d78 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c4a:	e0 6b 00 80 	mov	r11,128
80004c4e:	30 4c       	mov	r12,4
80004c50:	f0 1f 00 4b 	mcall	80004d7c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c54:	30 0b       	mov	r11,0
80004c56:	30 1c       	mov	r12,1
80004c58:	f0 1f 00 48 	mcall	80004d78 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c5c:	e0 6b 00 80 	mov	r11,128
80004c60:	30 ac       	mov	r12,10
80004c62:	f0 1f 00 48 	mcall	80004d80 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c66:	58 06       	cp.w	r6,0
80004c68:	c0 c0       	breq	80004c80 <PcdComMF522+0x70>
80004c6a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c6c:	30 94       	mov	r4,9
80004c6e:	0f 3b       	ld.ub	r11,r7++
80004c70:	08 9c       	mov	r12,r4
80004c72:	f0 1f 00 42 	mcall	80004d78 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c76:	0e 98       	mov	r8,r7
80004c78:	0a 18       	sub	r8,r5
80004c7a:	ec 08 19 00 	cp.h	r8,r6
80004c7e:	cf 83       	brcs	80004c6e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c80:	04 9b       	mov	r11,r2
80004c82:	30 1c       	mov	r12,1
80004c84:	f0 1f 00 3d 	mcall	80004d78 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c88:	30 c8       	mov	r8,12
80004c8a:	f0 02 18 00 	cp.b	r2,r8
80004c8e:	c0 61       	brne	80004c9a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c90:	e0 6b 00 80 	mov	r11,128
80004c94:	30 dc       	mov	r12,13
80004c96:	f0 1f 00 3b 	mcall	80004d80 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c9a:	30 4c       	mov	r12,4
80004c9c:	f0 1f 00 3a 	mcall	80004d84 <PcdComMF522+0x174>
80004ca0:	18 97       	mov	r7,r12
80004ca2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ca6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ca8:	30 44       	mov	r4,4
80004caa:	c0 88       	rjmp	80004cba <PcdComMF522+0xaa>
80004cac:	08 9c       	mov	r12,r4
80004cae:	f0 1f 00 36 	mcall	80004d84 <PcdComMF522+0x174>
80004cb2:	18 97       	mov	r7,r12
		i--;
80004cb4:	20 16       	sub	r6,1
80004cb6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004cb8:	c0 a0       	breq	80004ccc <PcdComMF522+0xbc>
80004cba:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004cbe:	c4 c1       	brne	80004d56 <PcdComMF522+0x146>
80004cc0:	ef e3 00 08 	and	r8,r7,r3
80004cc4:	ea 08 18 00 	cp.b	r8,r5
80004cc8:	cf 20       	breq	80004cac <PcdComMF522+0x9c>
80004cca:	c4 68       	rjmp	80004d56 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ccc:	e0 6b 00 80 	mov	r11,128
80004cd0:	30 dc       	mov	r12,13
80004cd2:	f0 1f 00 2b 	mcall	80004d7c <PcdComMF522+0x16c>
80004cd6:	30 27       	mov	r7,2
80004cd8:	c3 38       	rjmp	80004d3e <PcdComMF522+0x12e>
80004cda:	02 67       	and	r7,r1
80004cdc:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ce0:	30 c8       	mov	r8,12
80004ce2:	f0 02 18 00 	cp.b	r2,r8
80004ce6:	c2 c1       	brne	80004d3e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ce8:	30 ac       	mov	r12,10
80004cea:	f0 1f 00 27 	mcall	80004d84 <PcdComMF522+0x174>
80004cee:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004cf0:	30 cc       	mov	r12,12
80004cf2:	f0 1f 00 25 	mcall	80004d84 <PcdComMF522+0x174>
80004cf6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004cfa:	c0 70       	breq	80004d08 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004cfc:	08 98       	mov	r8,r4
80004cfe:	20 18       	sub	r8,1
80004d00:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d04:	a0 8c       	st.b	r0[0x0],r12
80004d06:	c0 48       	rjmp	80004d0e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d08:	e8 08 15 03 	lsl	r8,r4,0x3
80004d0c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d0e:	58 04       	cp.w	r4,0
80004d10:	c0 61       	brne	80004d1c <PcdComMF522+0x10c>
80004d12:	30 14       	mov	r4,1
80004d14:	40 05       	lddsp	r5,sp[0x0]
80004d16:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d18:	30 93       	mov	r3,9
80004d1a:	c0 98       	rjmp	80004d2c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d1c:	31 28       	mov	r8,18
80004d1e:	f0 04 18 00 	cp.b	r4,r8
80004d22:	f9 b4 0b 12 	movhi	r4,18
80004d26:	58 04       	cp.w	r4,0
80004d28:	cf 61       	brne	80004d14 <PcdComMF522+0x104>
80004d2a:	c0 a8       	rjmp	80004d3e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d2c:	06 9c       	mov	r12,r3
80004d2e:	f0 1f 00 16 	mcall	80004d84 <PcdComMF522+0x174>
80004d32:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d34:	ec 05 01 08 	sub	r8,r6,r5
80004d38:	e8 08 19 00 	cp.h	r8,r4
80004d3c:	cf 83       	brcs	80004d2c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d3e:	e0 6b 00 80 	mov	r11,128
80004d42:	30 cc       	mov	r12,12
80004d44:	f0 1f 00 0f 	mcall	80004d80 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d48:	30 0b       	mov	r11,0
80004d4a:	30 1c       	mov	r12,1
80004d4c:	f0 1f 00 0b 	mcall	80004d78 <PcdComMF522+0x168>
	return status;
}
80004d50:	0e 9c       	mov	r12,r7
80004d52:	2f fd       	sub	sp,-4
80004d54:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d56:	e0 6b 00 80 	mov	r11,128
80004d5a:	30 dc       	mov	r12,13
80004d5c:	f0 1f 00 08 	mcall	80004d7c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d60:	30 6c       	mov	r12,6
80004d62:	f0 1f 00 09 	mcall	80004d84 <PcdComMF522+0x174>
80004d66:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d6a:	cb 80       	breq	80004cda <PcdComMF522+0xca>
80004d6c:	30 27       	mov	r7,2
80004d6e:	ce 8b       	rjmp	80004d3e <PcdComMF522+0x12e>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	d8 50       	acall	0x85
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	d8 54       	*unknown*
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	49 0c       	lddpc	r12,80004db8 <PcdAnticoll+0x30>
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	4a b4       	lddpc	r4,80004e28 <PcdRequest+0x1c>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4a 70       	lddpc	r0,80004e1c <PcdRequest+0x10>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	49 cc       	lddpc	r12,80004df4 <PcdAnticoll+0x6c>

80004d88 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d88:	eb cd 40 c0 	pushm	r6-r7,lr
80004d8c:	20 5d       	sub	sp,20
80004d8e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d90:	30 8b       	mov	r11,8
80004d92:	16 9c       	mov	r12,r11
80004d94:	f0 1f 00 1a 	mcall	80004dfc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d98:	30 0b       	mov	r11,0
80004d9a:	30 dc       	mov	r12,13
80004d9c:	f0 1f 00 19 	mcall	80004e00 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004da0:	e0 6b 00 80 	mov	r11,128
80004da4:	30 ec       	mov	r12,14
80004da6:	f0 1f 00 16 	mcall	80004dfc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004daa:	39 38       	mov	r8,-109
80004dac:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004dae:	32 08       	mov	r8,32
80004db0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004db2:	1a 9b       	mov	r11,sp
80004db4:	fa c8 ff ed 	sub	r8,sp,-19
80004db8:	1a 99       	mov	r9,sp
80004dba:	30 2a       	mov	r10,2
80004dbc:	30 cc       	mov	r12,12
80004dbe:	f0 1f 00 12 	mcall	80004e04 <PcdAnticoll+0x7c>
80004dc2:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004dc4:	c1 21       	brne	80004de8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dc6:	1b 89       	ld.ub	r9,sp[0x0]
80004dc8:	ac 89       	st.b	r6[0x0],r9
80004dca:	1b 98       	ld.ub	r8,sp[0x1]
80004dcc:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004dce:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dd0:	1b a8       	ld.ub	r8,sp[0x2]
80004dd2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004dd4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dd8:	1b b9       	ld.ub	r9,sp[0x3]
80004dda:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ddc:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004dde:	1b c9       	ld.ub	r9,sp[0x4]
80004de0:	f0 09 18 00 	cp.b	r9,r8
80004de4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004de8:	e0 6b 00 80 	mov	r11,128
80004dec:	30 ec       	mov	r12,14
80004dee:	f0 1f 00 07 	mcall	80004e08 <PcdAnticoll+0x80>
	return status;
}
80004df2:	0e 9c       	mov	r12,r7
80004df4:	2f bd       	sub	sp,-20
80004df6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dfa:	00 00       	add	r0,r0
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4a b4       	lddpc	r4,80004ea8 <CalulateCRC+0x38>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	49 0c       	lddpc	r12,80004e40 <PcdRequest+0x34>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	4c 10       	lddpc	r0,80004f08 <PcdSelect+0xc>
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	4a 70       	lddpc	r0,80004ea4 <CalulateCRC+0x34>

80004e0c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e0c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e10:	20 5d       	sub	sp,20
80004e12:	18 97       	mov	r7,r12
80004e14:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e16:	30 8b       	mov	r11,8
80004e18:	16 9c       	mov	r12,r11
80004e1a:	f0 1f 00 12 	mcall	80004e60 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e1e:	30 7b       	mov	r11,7
80004e20:	30 dc       	mov	r12,13
80004e22:	f0 1f 00 11 	mcall	80004e64 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004e26:	30 3b       	mov	r11,3
80004e28:	31 4c       	mov	r12,20
80004e2a:	f0 1f 00 10 	mcall	80004e68 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004e2e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004e30:	1a 9b       	mov	r11,sp
80004e32:	fa c8 ff ed 	sub	r8,sp,-19
80004e36:	1a 99       	mov	r9,sp
80004e38:	30 1a       	mov	r10,1
80004e3a:	30 cc       	mov	r12,12
80004e3c:	f0 1f 00 0c 	mcall	80004e6c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e40:	c0 c1       	brne	80004e58 <PcdRequest+0x4c>
80004e42:	31 08       	mov	r8,16
80004e44:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e48:	f0 09 18 00 	cp.b	r9,r8
80004e4c:	c0 61       	brne	80004e58 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e4e:	1b 88       	ld.ub	r8,sp[0x0]
80004e50:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e52:	1b 98       	ld.ub	r8,sp[0x1]
80004e54:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e56:	c0 28       	rjmp	80004e5a <PcdRequest+0x4e>
80004e58:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e5a:	2f bd       	sub	sp,-20
80004e5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	4a b4       	lddpc	r4,80004f0c <PcdSelect+0x10>
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	49 0c       	lddpc	r12,80004ea4 <CalulateCRC+0x34>
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	4a 70       	lddpc	r0,80004f04 <PcdSelect+0x8>
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4c 10       	lddpc	r0,80004f70 <rfid_auto_reader>

80004e70 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e70:	eb cd 40 f8 	pushm	r3-r7,lr
80004e74:	18 95       	mov	r5,r12
80004e76:	16 96       	mov	r6,r11
80004e78:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e7a:	30 4b       	mov	r11,4
80004e7c:	30 5c       	mov	r12,5
80004e7e:	f0 1f 00 1c 	mcall	80004eec <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e82:	30 0b       	mov	r11,0
80004e84:	30 1c       	mov	r12,1
80004e86:	f0 1f 00 1b 	mcall	80004ef0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e8a:	e0 6b 00 80 	mov	r11,128
80004e8e:	30 ac       	mov	r12,10
80004e90:	f0 1f 00 19 	mcall	80004ef4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e94:	58 06       	cp.w	r6,0
80004e96:	c0 c0       	breq	80004eae <CalulateCRC+0x3e>
80004e98:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e9a:	30 94       	mov	r4,9
80004e9c:	0f 3b       	ld.ub	r11,r7++
80004e9e:	08 9c       	mov	r12,r4
80004ea0:	f0 1f 00 14 	mcall	80004ef0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004ea4:	0e 98       	mov	r8,r7
80004ea6:	0a 18       	sub	r8,r5
80004ea8:	ec 08 18 00 	cp.b	r8,r6
80004eac:	cf 83       	brcs	80004e9c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004eae:	30 3b       	mov	r11,3
80004eb0:	30 1c       	mov	r12,1
80004eb2:	f0 1f 00 10 	mcall	80004ef0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004eb6:	30 5c       	mov	r12,5
80004eb8:	f0 1f 00 10 	mcall	80004ef8 <CalulateCRC+0x88>
80004ebc:	e0 67 00 fe 	mov	r7,254
80004ec0:	30 56       	mov	r6,5
80004ec2:	c0 78       	rjmp	80004ed0 <CalulateCRC+0x60>
80004ec4:	0c 9c       	mov	r12,r6
80004ec6:	f0 1f 00 0d 	mcall	80004ef8 <CalulateCRC+0x88>
		i--;
80004eca:	20 17       	sub	r7,1
80004ecc:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004ece:	c0 40       	breq	80004ed6 <CalulateCRC+0x66>
80004ed0:	e2 1c 00 04 	andl	r12,0x4,COH
80004ed4:	cf 80       	breq	80004ec4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004ed6:	32 2c       	mov	r12,34
80004ed8:	f0 1f 00 08 	mcall	80004ef8 <CalulateCRC+0x88>
80004edc:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ede:	32 1c       	mov	r12,33
80004ee0:	f0 1f 00 06 	mcall	80004ef8 <CalulateCRC+0x88>
80004ee4:	a6 9c       	st.b	r3[0x1],r12
}
80004ee6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004eea:	00 00       	add	r0,r0
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	4a b4       	lddpc	r4,80004f98 <rfid_auto_reader+0x28>
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	49 0c       	lddpc	r12,80004f30 <PcdSelect+0x34>
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4a 70       	lddpc	r0,80004f90 <rfid_auto_reader+0x20>
80004ef8:	80 00       	ld.sh	r0,r0[0x0]
80004efa:	49 cc       	lddpc	r12,80004f68 <PcdSelect+0x6c>

80004efc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004efc:	eb cd 40 80 	pushm	r7,lr
80004f00:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f02:	39 38       	mov	r8,-109
80004f04:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f06:	37 08       	mov	r8,112
80004f08:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f0a:	30 08       	mov	r8,0
80004f0c:	ba e8       	st.b	sp[0x6],r8
80004f0e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f12:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f16:	19 89       	ld.ub	r9,r12[0x0]
80004f18:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f1a:	19 3a       	ld.ub	r10,r12++
80004f1c:	1b e9       	ld.ub	r9,sp[0x6]
80004f1e:	f5 e9 20 09 	eor	r9,r10,r9
80004f22:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004f24:	16 38       	cp.w	r8,r11
80004f26:	cf 81       	brne	80004f16 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004f28:	1a 97       	mov	r7,sp
80004f2a:	fa ca ff f9 	sub	r10,sp,-7
80004f2e:	30 7b       	mov	r11,7
80004f30:	1a 9c       	mov	r12,sp
80004f32:	f0 1f 00 0d 	mcall	80004f64 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004f36:	30 8b       	mov	r11,8
80004f38:	16 9c       	mov	r12,r11
80004f3a:	f0 1f 00 0c 	mcall	80004f68 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f3e:	fa c8 ff ed 	sub	r8,sp,-19
80004f42:	1a 99       	mov	r9,sp
80004f44:	30 9a       	mov	r10,9
80004f46:	1a 9b       	mov	r11,sp
80004f48:	30 cc       	mov	r12,12
80004f4a:	f0 1f 00 09 	mcall	80004f6c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f4e:	c0 71       	brne	80004f5c <PcdSelect+0x60>
80004f50:	31 88       	mov	r8,24
80004f52:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f56:	f0 09 18 00 	cp.b	r9,r8
80004f5a:	c0 20       	breq	80004f5e <PcdSelect+0x62>
80004f5c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f5e:	2f bd       	sub	sp,-20
80004f60:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4e 70       	lddpc	r0,80005100 <rfid_sendID_message+0x20>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	4a b4       	lddpc	r4,80005014 <rfid_auto_reader+0xa4>
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	4c 10       	lddpc	r0,80005070 <rfid_auto_reader+0x100>

80004f70 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f70:	eb cd 40 c0 	pushm	r6-r7,lr
80004f74:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f76:	f0 1f 00 37 	mcall	80005050 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f7a:	4b 7b       	lddpc	r11,80005054 <rfid_auto_reader+0xe4>
80004f7c:	35 2c       	mov	r12,82
80004f7e:	f0 1f 00 37 	mcall	80005058 <rfid_auto_reader+0xe8>
80004f82:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f84:	c6 31       	brne	8000504a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f86:	4b 48       	lddpc	r8,80005054 <rfid_auto_reader+0xe4>
80004f88:	11 88       	ld.ub	r8,r8[0x0]
80004f8a:	30 49       	mov	r9,4
80004f8c:	f2 08 18 00 	cp.b	r8,r9
80004f90:	c0 b1       	brne	80004fa6 <rfid_auto_reader+0x36>
80004f92:	4b 19       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004f94:	13 9a       	ld.ub	r10,r9[0x1]
80004f96:	30 09       	mov	r9,0
80004f98:	f2 0a 18 00 	cp.b	r10,r9
80004f9c:	c0 51       	brne	80004fa6 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f9e:	4b 0c       	lddpc	r12,8000505c <rfid_auto_reader+0xec>
80004fa0:	f0 1f 00 30 	mcall	80005060 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004fa4:	c3 c8       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fa6:	30 29       	mov	r9,2
80004fa8:	f2 08 18 00 	cp.b	r8,r9
80004fac:	c0 b1       	brne	80004fc2 <rfid_auto_reader+0x52>
80004fae:	4a a9       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fb0:	13 9a       	ld.ub	r10,r9[0x1]
80004fb2:	30 09       	mov	r9,0
80004fb4:	f2 0a 18 00 	cp.b	r10,r9
80004fb8:	c0 51       	brne	80004fc2 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004fba:	4a bc       	lddpc	r12,80005064 <rfid_auto_reader+0xf4>
80004fbc:	f0 1f 00 29 	mcall	80005060 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fc0:	c2 e8       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fc2:	34 49       	mov	r9,68
80004fc4:	f2 08 18 00 	cp.b	r8,r9
80004fc8:	c0 b1       	brne	80004fde <rfid_auto_reader+0x6e>
80004fca:	4a 39       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fcc:	13 9a       	ld.ub	r10,r9[0x1]
80004fce:	30 09       	mov	r9,0
80004fd0:	f2 0a 18 00 	cp.b	r10,r9
80004fd4:	c0 51       	brne	80004fde <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004fd6:	4a 5c       	lddpc	r12,80005068 <rfid_auto_reader+0xf8>
80004fd8:	f0 1f 00 22 	mcall	80005060 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fdc:	c2 08       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fde:	30 89       	mov	r9,8
80004fe0:	f2 08 18 00 	cp.b	r8,r9
80004fe4:	c0 b1       	brne	80004ffa <rfid_auto_reader+0x8a>
80004fe6:	49 c9       	lddpc	r9,80005054 <rfid_auto_reader+0xe4>
80004fe8:	13 9a       	ld.ub	r10,r9[0x1]
80004fea:	30 09       	mov	r9,0
80004fec:	f2 0a 18 00 	cp.b	r10,r9
80004ff0:	c0 51       	brne	80004ffa <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004ff2:	49 fc       	lddpc	r12,8000506c <rfid_auto_reader+0xfc>
80004ff4:	f0 1f 00 1b 	mcall	80005060 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ff8:	c1 28       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ffa:	34 49       	mov	r9,68
80004ffc:	f2 08 18 00 	cp.b	r8,r9
80005000:	c0 b1       	brne	80005016 <rfid_auto_reader+0xa6>
80005002:	49 58       	lddpc	r8,80005054 <rfid_auto_reader+0xe4>
80005004:	11 99       	ld.ub	r9,r8[0x1]
80005006:	30 38       	mov	r8,3
80005008:	f0 09 18 00 	cp.b	r9,r8
8000500c:	c0 51       	brne	80005016 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000500e:	49 9c       	lddpc	r12,80005070 <rfid_auto_reader+0x100>
80005010:	f0 1f 00 14 	mcall	80005060 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005014:	c0 48       	rjmp	8000501c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005016:	49 8c       	lddpc	r12,80005074 <rfid_auto_reader+0x104>
80005018:	f0 1f 00 12 	mcall	80005060 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000501c:	49 7c       	lddpc	r12,80005078 <rfid_auto_reader+0x108>
8000501e:	f0 1f 00 18 	mcall	8000507c <rfid_auto_reader+0x10c>
80005022:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005024:	c0 60       	breq	80005030 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80005026:	37 8b       	mov	r11,120
80005028:	30 1c       	mov	r12,1
8000502a:	f0 1f 00 16 	mcall	80005080 <rfid_auto_reader+0x110>
		return status;
8000502e:	c0 e8       	rjmp	8000504a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005030:	49 2c       	lddpc	r12,80005078 <rfid_auto_reader+0x108>
80005032:	f0 1f 00 15 	mcall	80005084 <rfid_auto_reader+0x114>
80005036:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005038:	c0 91       	brne	8000504a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
8000503a:	30 4a       	mov	r10,4
8000503c:	48 fb       	lddpc	r11,80005078 <rfid_auto_reader+0x108>
8000503e:	0c 9c       	mov	r12,r6
80005040:	f0 1f 00 12 	mcall	80005088 <rfid_auto_reader+0x118>
		log("select okay\n");
80005044:	49 2c       	lddpc	r12,8000508c <rfid_auto_reader+0x11c>
80005046:	f0 1f 00 07 	mcall	80005060 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000504a:	0e 9c       	mov	r12,r7
8000504c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	49 4c       	lddpc	r12,800050a0 <scan_patrol+0x10>
80005054:	00 00       	add	r0,r0
80005056:	51 34       	stdsp	sp[0x4c],r4
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	4e 0c       	lddpc	r12,800051d8 <rfid_sendID_message+0xf8>
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	d8 70       	acall	0x87
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	6f 30       	ld.w	r0,r7[0x4c]
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	d8 7c       	*unknown*
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	d8 88       	*unknown*
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	d8 98       	*unknown*
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	d8 a0       	acall	0x8a
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	d8 ac       	*unknown*
80005078:	00 00       	add	r0,r0
8000507a:	51 38       	stdsp	sp[0x4c],r8
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	4d 88       	lddpc	r8,800051dc <rfid_sendID_message+0xfc>
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	40 a0       	lddsp	r0,sp[0x28]
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4e fc       	lddpc	r12,80005240 <rfid_init+0x8>
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	77 ac       	ld.w	r12,r11[0x68]
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	d8 b8       	*unknown*

80005090 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005090:	eb cd 40 80 	pushm	r7,lr
80005094:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005096:	f0 1f 00 0d 	mcall	800050c8 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
8000509a:	30 0c       	mov	r12,0
8000509c:	f0 1f 00 0c 	mcall	800050cc <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
800050a0:	0e 9c       	mov	r12,r7
800050a2:	f0 1f 00 0c 	mcall	800050d0 <scan_patrol+0x40>
800050a6:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800050a8:	30 1c       	mov	r12,1
800050aa:	f0 1f 00 09 	mcall	800050cc <scan_patrol+0x3c>
	if(return_err == 0)
800050ae:	58 07       	cp.w	r7,0
800050b0:	c0 51       	brne	800050ba <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800050b2:	48 9c       	lddpc	r12,800050d4 <scan_patrol+0x44>
800050b4:	f0 1f 00 09 	mcall	800050d8 <scan_patrol+0x48>
800050b8:	c0 48       	rjmp	800050c0 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800050ba:	48 9c       	lddpc	r12,800050dc <scan_patrol+0x4c>
800050bc:	f0 1f 00 07 	mcall	800050d8 <scan_patrol+0x48>
		
	return return_err;

}
800050c0:	0e 9c       	mov	r12,r7
800050c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800050c6:	00 00       	add	r0,r0
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	49 4c       	lddpc	r12,80005118 <rfid_sendID_message+0x38>
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	4a 24       	lddpc	r4,80005154 <rfid_sendID_message+0x74>
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	4f 70       	lddpc	r0,800052ac <local_start_timer>
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	d8 c8       	*unknown*
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	6f 30       	ld.w	r0,r7[0x4c]
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	d8 dc       	*unknown*

800050e0 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
800050e0:	eb cd 40 e0 	pushm	r5-r7,lr
800050e4:	21 bd       	sub	sp,108
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
800050e6:	4c bc       	lddpc	r12,80005210 <rfid_sendID_message+0x130>
800050e8:	30 08       	mov	r8,0
800050ea:	30 09       	mov	r9,0
800050ec:	f8 e9 00 00 	st.d	r12[0],r8
800050f0:	30 0a       	mov	r10,0
800050f2:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800050f4:	fa e9 00 1c 	st.d	sp[28],r8
800050f8:	fa e9 00 24 	st.d	sp[36],r8
800050fc:	fa e9 00 2c 	st.d	sp[44],r8
80005100:	fa e9 00 34 	st.d	sp[52],r8
80005104:	fa e9 00 3c 	st.d	sp[60],r8
80005108:	fa e9 00 44 	st.d	sp[68],r8
8000510c:	fa e9 00 4c 	st.d	sp[76],r8
80005110:	fa e9 00 54 	st.d	sp[84],r8
80005114:	fa e9 00 5c 	st.d	sp[92],r8
80005118:	fa e9 00 64 	st.d	sp[100],r8
	
	return_err = scan_patrol(SN);
8000511c:	f0 1f 00 3e 	mcall	80005214 <rfid_sendID_message+0x134>
80005120:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005122:	c6 c1       	brne	800051fa <rfid_sendID_message+0x11a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005124:	4b b6       	lddpc	r6,80005210 <rfid_sendID_message+0x130>
80005126:	0d b8       	ld.ub	r8,r6[0x3]
80005128:	1a d8       	st.w	--sp,r8
8000512a:	0d a8       	ld.ub	r8,r6[0x2]
8000512c:	1a d8       	st.w	--sp,r8
8000512e:	0d 98       	ld.ub	r8,r6[0x1]
80005130:	1a d8       	st.w	--sp,r8
80005132:	0d 88       	ld.ub	r8,r6[0x0]
80005134:	1a d8       	st.w	--sp,r8
80005136:	4b 9c       	lddpc	r12,80005218 <rfid_sendID_message+0x138>
80005138:	f0 1f 00 39 	mcall	8000521c <rfid_sendID_message+0x13c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
8000513c:	37 7b       	mov	r11,119
8000513e:	30 1c       	mov	r12,1
80005140:	f0 1f 00 38 	mcall	80005220 <rfid_sendID_message+0x140>
80005144:	fa c8 ff ee 	sub	r8,sp,-18
80005148:	fa c9 ff ec 	sub	r9,sp,-20
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
8000514c:	ec c5 ff fc 	sub	r5,r6,-4
80005150:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005152:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005154:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005156:	0d 8a       	ld.ub	r10,r6[0x0]
80005158:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000515c:	fc 0b 18 00 	cp.b	r11,lr
80005160:	f7 bb 08 d0 	subls	r11,-48
80005164:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005168:	f7 bb 0b a9 	subhi	r11,-87
8000516c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005170:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005172:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005176:	fc 0a 18 00 	cp.b	r10,lr
8000517a:	f7 ba 08 d0 	subls	r10,-48
8000517e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005182:	f7 ba 0b a9 	subhi	r10,-87
80005186:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000518a:	b0 bc       	st.b	r8[0x3],r12
8000518c:	2f f6       	sub	r6,-1
8000518e:	2f c8       	sub	r8,-4
80005190:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005192:	0a 36       	cp.w	r6,r5
80005194:	ce 11       	brne	80005156 <rfid_sendID_message+0x76>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80005196:	4a 48       	lddpc	r8,80005224 <rfid_sendID_message+0x144>
80005198:	11 89       	ld.ub	r9,r8[0x0]
8000519a:	39 f8       	mov	r8,-97
8000519c:	f0 09 18 00 	cp.b	r9,r8
800051a0:	e0 88 00 05 	brls	800051aa <rfid_sendID_message+0xca>
800051a4:	38 09       	mov	r9,-128
800051a6:	4a 08       	lddpc	r8,80005224 <rfid_sendID_message+0x144>
800051a8:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800051aa:	49 f8       	lddpc	r8,80005224 <rfid_sendID_message+0x144>
800051ac:	11 86       	ld.ub	r6,r8[0x0]
800051ae:	2f f6       	sub	r6,-1
800051b0:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800051b2:	30 5a       	mov	r10,5
800051b4:	49 db       	lddpc	r11,80005228 <rfid_sendID_message+0x148>
800051b6:	fa cc ff e9 	sub	r12,sp,-23
800051ba:	f0 1f 00 1d 	mcall	8000522c <rfid_sendID_message+0x14c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800051be:	31 88       	mov	r8,24
800051c0:	fb 58 00 12 	st.h	sp[18],r8
800051c4:	fb 66 00 16 	st.b	sp[22],r6
800051c8:	fe 78 e0 00 	mov	r8,-8192
800051cc:	fb 58 00 14 	st.h	sp[20],r8
800051d0:	fa c6 ff e4 	sub	r6,sp,-28
800051d4:	30 aa       	mov	r10,10
800051d6:	fa cb ff ee 	sub	r11,sp,-18
800051da:	0c 9c       	mov	r12,r6
800051dc:	f0 1f 00 14 	mcall	8000522c <rfid_sendID_message+0x14c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800051e0:	31 0a       	mov	r10,16
800051e2:	fa cb ff fe 	sub	r11,sp,-2
800051e6:	fa cc ff da 	sub	r12,sp,-38
800051ea:	f0 1f 00 11 	mcall	8000522c <rfid_sendID_message+0x14c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800051ee:	30 9a       	mov	r10,9
800051f0:	31 ab       	mov	r11,26
800051f2:	0c 9c       	mov	r12,r6
800051f4:	f0 1f 00 0f 	mcall	80005230 <rfid_sendID_message+0x150>
800051f8:	c0 88       	rjmp	80005208 <rfid_sendID_message+0x128>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800051fa:	37 8b       	mov	r11,120
800051fc:	30 1c       	mov	r12,1
800051fe:	f0 1f 00 09 	mcall	80005220 <rfid_sendID_message+0x140>
		log("no card find...\n");
80005202:	48 dc       	lddpc	r12,80005234 <rfid_sendID_message+0x154>
80005204:	f0 1f 00 06 	mcall	8000521c <rfid_sendID_message+0x13c>
	}
	
	return return_err;
	
}
80005208:	0e 9c       	mov	r12,r7
8000520a:	2e 5d       	sub	sp,-108
8000520c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005210:	00 00       	add	r0,r0
80005212:	0b 64       	ld.uh	r4,--r5
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	50 90       	stdsp	sp[0x24],r0
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	d8 f0       	acall	0x8f
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	6f 30       	ld.w	r0,r7[0x4c]
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	40 a0       	lddsp	r0,sp[0x28]
80005224:	00 00       	add	r0,r0
80005226:	05 30       	ld.ub	r0,r2++
80005228:	00 00       	add	r0,r0
8000522a:	05 28       	ld.uh	r8,r2++
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	77 ac       	ld.w	r12,r11[0x68]
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	3f 68       	mov	r8,-10
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	d9 0c       	*unknown*

80005238 <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80005238:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000523a:	f0 1f 00 02 	mcall	80005240 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000523e:	d8 02       	popm	pc
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	4b 5c       	lddpc	r12,80005314 <local_start_pll0+0x3c>

80005244 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005244:	58 0c       	cp.w	r12,0
80005246:	5e 0c       	reteq	r12
80005248:	30 08       	mov	r8,0
	{
		nop();
8000524a:	d7 03       	nop
		nop();
8000524c:	d7 03       	nop
		nop();
8000524e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005250:	2f f8       	sub	r8,-1
80005252:	10 3c       	cp.w	r12,r8
80005254:	fe 9b ff fb 	brhi	8000524a <delay_ns+0x6>
80005258:	5e fc       	retal	r12
8000525a:	d7 03       	nop

8000525c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000525c:	eb cd 40 e0 	pushm	r5-r7,lr
80005260:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005262:	58 0c       	cp.w	r12,0
80005264:	c0 b0       	breq	8000527a <delay_us+0x1e>
80005266:	30 07       	mov	r7,0
		delay_ns(1000);
80005268:	e0 65 03 e8 	mov	r5,1000
8000526c:	0a 9c       	mov	r12,r5
8000526e:	f0 1f 00 05 	mcall	80005280 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005272:	2f f7       	sub	r7,-1
80005274:	0e 36       	cp.w	r6,r7
80005276:	fe 9b ff fb 	brhi	8000526c <delay_us+0x10>
8000527a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000527e:	00 00       	add	r0,r0
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	52 44       	stdsp	sp[0x90],r4

80005284 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005284:	eb cd 40 e0 	pushm	r5-r7,lr
80005288:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000528a:	58 0c       	cp.w	r12,0
8000528c:	c0 b0       	breq	800052a2 <delay_ms+0x1e>
8000528e:	30 07       	mov	r7,0
		delay_us(1000);
80005290:	e0 65 03 e8 	mov	r5,1000
80005294:	0a 9c       	mov	r12,r5
80005296:	f0 1f 00 05 	mcall	800052a8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000529a:	2f f7       	sub	r7,-1
8000529c:	0e 36       	cp.w	r6,r7
8000529e:	fe 9b ff fb 	brhi	80005294 <delay_ms+0x10>
800052a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052a6:	00 00       	add	r0,r0
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	52 5c       	stdsp	sp[0x94],r12

800052ac <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800052ac:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800052ae:	30 3b       	mov	r11,3
800052b0:	48 8c       	lddpc	r12,800052d0 <local_start_timer+0x24>
800052b2:	f0 1f 00 09 	mcall	800052d4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800052b6:	fe 78 38 00 	mov	r8,-51200
800052ba:	e0 69 91 0d 	mov	r9,37133
800052be:	ea 19 00 52 	orh	r9,0x52
800052c2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800052c4:	32 09       	mov	r9,32
800052c6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800052c8:	30 59       	mov	r9,5
800052ca:	91 09       	st.w	r8[0x0],r9
}
800052cc:	d8 02       	popm	pc
800052ce:	00 00       	add	r0,r0
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	d9 20       	acall	0x92
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	54 6c       	stdsp	sp[0x118],r12

800052d8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800052d8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800052da:	30 3a       	mov	r10,3
800052dc:	e0 6b 1b 00 	mov	r11,6912
800052e0:	ea 1b 00 b7 	orh	r11,0xb7
800052e4:	fe 7c 0c 00 	mov	r12,-62464
800052e8:	f0 1f 00 19 	mcall	8000534c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800052ec:	31 08       	mov	r8,16
800052ee:	1a d8       	st.w	--sp,r8
800052f0:	30 08       	mov	r8,0
800052f2:	30 19       	mov	r9,1
800052f4:	30 7a       	mov	r10,7
800052f6:	10 9b       	mov	r11,r8
800052f8:	fe 7c 0c 00 	mov	r12,-62464
800052fc:	f0 1f 00 15 	mcall	80005350 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005300:	30 08       	mov	r8,0
80005302:	30 19       	mov	r9,1
80005304:	12 9a       	mov	r10,r9
80005306:	10 9b       	mov	r11,r8
80005308:	fe 7c 0c 00 	mov	r12,-62464
8000530c:	f0 1f 00 12 	mcall	80005354 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005310:	30 0b       	mov	r11,0
80005312:	fe 7c 0c 00 	mov	r12,-62464
80005316:	f0 1f 00 11 	mcall	80005358 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000531a:	fe 7c 0c 00 	mov	r12,-62464
8000531e:	f0 1f 00 10 	mcall	8000535c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005322:	30 0a       	mov	r10,0
80005324:	1a da       	st.w	--sp,r10
80005326:	1a da       	st.w	--sp,r10
80005328:	14 98       	mov	r8,r10
8000532a:	14 99       	mov	r9,r10
8000532c:	30 1b       	mov	r11,1
8000532e:	fe 7c 0c 00 	mov	r12,-62464
80005332:	f0 1f 00 0c 	mcall	80005360 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005336:	30 1c       	mov	r12,1
80005338:	f0 1f 00 0b 	mcall	80005364 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000533c:	30 2b       	mov	r11,2
8000533e:	fe 7c 0c 00 	mov	r12,-62464
80005342:	f0 1f 00 0a 	mcall	80005368 <local_start_pll0+0x90>
80005346:	2f dd       	sub	sp,-12
/****/
}
80005348:	d8 02       	popm	pc
8000534a:	00 00       	add	r0,r0
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	57 20       	stdsp	sp[0x1c8],r0
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	56 c2       	stdsp	sp[0x1b0],r2
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	56 e4       	stdsp	sp[0x1b8],r4
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	56 fe       	stdsp	sp[0x1bc],lr
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	57 0c       	stdsp	sp[0x1c0],r12
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	56 7c       	stdsp	sp[0x19c],r12
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	54 0c       	stdsp	sp[0x100],r12
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	57 16       	stdsp	sp[0x1c4],r6

8000536c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
8000536c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005370:	f0 1f 00 1a 	mcall	800053d8 <xg_flashc_init+0x6c>
80005374:	49 a8       	lddpc	r8,800053dc <xg_flashc_init+0x70>
80005376:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005378:	70 08       	ld.w	r8,r8[0x0]
8000537a:	58 08       	cp.w	r8,0
8000537c:	c0 41       	brne	80005384 <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
8000537e:	49 9c       	lddpc	r12,800053e0 <xg_flashc_init+0x74>
80005380:	f0 1f 00 19 	mcall	800053e4 <xg_flashc_init+0x78>
	//计数最大值为300
	//初始值为1(当flash信息数量为0时：用户扫点 -> flash-save -> flash-count+1 -> take Sem -> send -> wait for give-Sem(success/fail))
	//如果此时反馈成功，则继续查询count值是否等于0/等待用户扫点
	//如果此时反馈失败，则flash-save
	//当flash信息数量！=0时；等待查询count值
	SendM_CountingSemaphore = xSemaphoreCreateCounting(300, 1);
80005384:	30 1b       	mov	r11,1
80005386:	e0 6c 01 2c 	mov	r12,300
8000538a:	f0 1f 00 18 	mcall	800053e8 <xg_flashc_init+0x7c>
8000538e:	49 88       	lddpc	r8,800053ec <xg_flashc_init+0x80>
80005390:	91 0c       	st.w	r8[0x0],r12
	if (SendM_CountingSemaphore == NULL)
80005392:	70 08       	ld.w	r8,r8[0x0]
80005394:	58 08       	cp.w	r8,0
80005396:	c0 41       	brne	8000539e <xg_flashc_init+0x32>
	{
		log("Create the SendM_Counting semaphore failure\n");
80005398:	49 6c       	lddpc	r12,800053f0 <xg_flashc_init+0x84>
8000539a:	f0 1f 00 13 	mcall	800053e4 <xg_flashc_init+0x78>
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
8000539e:	30 4b       	mov	r11,4
800053a0:	31 4c       	mov	r12,20
800053a2:	f0 1f 00 15 	mcall	800053f4 <xg_flashc_init+0x88>
800053a6:	49 58       	lddpc	r8,800053f8 <xg_flashc_init+0x8c>
800053a8:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
800053aa:	30 4b       	mov	r11,4
800053ac:	31 4c       	mov	r12,20
800053ae:	f0 1f 00 12 	mcall	800053f4 <xg_flashc_init+0x88>
800053b2:	49 38       	lddpc	r8,800053fc <xg_flashc_init+0x90>
800053b4:	91 0c       	st.w	r8[0x0],r12
800053b6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800053b8:	10 96       	mov	r6,r8
800053ba:	49 25       	lddpc	r5,80005400 <xg_flashc_init+0x94>
800053bc:	6c 0c       	ld.w	r12,r6[0x0]
800053be:	ea 07 00 0b 	add	r11,r5,r7
800053c2:	f0 1f 00 11 	mcall	80005404 <xg_flashc_init+0x98>
800053c6:	2e 67       	sub	r7,-26
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
800053c8:	e0 47 02 08 	cp.w	r7,520
800053cc:	cf 81       	brne	800053bc <xg_flashc_init+0x50>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
800053ce:	f0 1f 00 0f 	mcall	80005408 <xg_flashc_init+0x9c>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
800053d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053d6:	00 00       	add	r0,r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	63 e0       	ld.w	r0,r1[0x78]
800053dc:	00 00       	add	r0,r0
800053de:	0b 74       	ld.ub	r4,--r5
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	d9 38       	*unknown*
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	6f 30       	ld.w	r0,r7[0x4c]
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	64 ac       	ld.w	r12,r2[0x28]
800053ec:	00 00       	add	r0,r0
800053ee:	0b 7c       	ld.ub	r12,--r5
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	d9 64       	*unknown*
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	64 38       	ld.w	r8,r2[0xc]
800053f8:	00 00       	add	r0,r0
800053fa:	0b 70       	ld.ub	r0,--r5
800053fc:	00 00       	add	r0,r0
800053fe:	0b 78       	ld.ub	r8,--r5
80005400:	00 00       	add	r0,r0
80005402:	51 3c       	stdsp	sp[0x4c],r12
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	2c 3c       	sub	r12,-61
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	2a 74       	sub	r4,-89

8000540c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000540c:	fe 68 14 00 	mov	r8,-125952
80005410:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005412:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005416:	91 09       	st.w	r8[0x0],r9
}
80005418:	5e fc       	retal	r12

8000541a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000541a:	f8 08 16 05 	lsr	r8,r12,0x5
8000541e:	a9 68       	lsl	r8,0x8
80005420:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005424:	58 1b       	cp.w	r11,1
80005426:	c0 d0       	breq	80005440 <gpio_enable_module_pin+0x26>
80005428:	c0 63       	brcs	80005434 <gpio_enable_module_pin+0x1a>
8000542a:	58 2b       	cp.w	r11,2
8000542c:	c1 00       	breq	8000544c <gpio_enable_module_pin+0x32>
8000542e:	58 3b       	cp.w	r11,3
80005430:	c1 40       	breq	80005458 <gpio_enable_module_pin+0x3e>
80005432:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005434:	30 19       	mov	r9,1
80005436:	f2 0c 09 49 	lsl	r9,r9,r12
8000543a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000543c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000543e:	c1 28       	rjmp	80005462 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005440:	30 19       	mov	r9,1
80005442:	f2 0c 09 49 	lsl	r9,r9,r12
80005446:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005448:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000544a:	c0 c8       	rjmp	80005462 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000544c:	30 19       	mov	r9,1
8000544e:	f2 0c 09 49 	lsl	r9,r9,r12
80005452:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005454:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005456:	c0 68       	rjmp	80005462 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005458:	30 19       	mov	r9,1
8000545a:	f2 0c 09 49 	lsl	r9,r9,r12
8000545e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005460:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005462:	30 19       	mov	r9,1
80005464:	f2 0c 09 4c 	lsl	r12,r9,r12
80005468:	91 2c       	st.w	r8[0x8],r12
8000546a:	5e fd       	retal	0

8000546c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000546c:	d4 21       	pushm	r4-r7,lr
8000546e:	18 97       	mov	r7,r12
80005470:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005472:	58 0b       	cp.w	r11,0
80005474:	c0 31       	brne	8000547a <gpio_enable_module+0xe>
80005476:	30 05       	mov	r5,0
80005478:	c0 d8       	rjmp	80005492 <gpio_enable_module+0x26>
8000547a:	30 06       	mov	r6,0
8000547c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000547e:	6e 1b       	ld.w	r11,r7[0x4]
80005480:	6e 0c       	ld.w	r12,r7[0x0]
80005482:	f0 1f 00 06 	mcall	80005498 <gpio_enable_module+0x2c>
80005486:	18 45       	or	r5,r12
		gpiomap++;
80005488:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000548a:	2f f6       	sub	r6,-1
8000548c:	0c 34       	cp.w	r4,r6
8000548e:	fe 9b ff f8 	brhi	8000547e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005492:	0a 9c       	mov	r12,r5
80005494:	d8 22       	popm	r4-r7,pc
80005496:	00 00       	add	r0,r0
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	54 1a       	stdsp	sp[0x104],r10

8000549c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000549c:	f8 08 16 05 	lsr	r8,r12,0x5
800054a0:	a9 68       	lsl	r8,0x8
800054a2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800054a6:	30 19       	mov	r9,1
800054a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800054ac:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800054b0:	91 1c       	st.w	r8[0x4],r12
}
800054b2:	5e fc       	retal	r12

800054b4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054b4:	f8 08 16 05 	lsr	r8,r12,0x5
800054b8:	a9 68       	lsl	r8,0x8
800054ba:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800054be:	30 19       	mov	r9,1
800054c0:	f2 0c 09 4c 	lsl	r12,r9,r12
800054c4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800054c8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800054cc:	91 1c       	st.w	r8[0x4],r12
}
800054ce:	5e fc       	retal	r12

800054d0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054d0:	f8 08 16 05 	lsr	r8,r12,0x5
800054d4:	a9 68       	lsl	r8,0x8
800054d6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800054da:	30 19       	mov	r9,1
800054dc:	f2 0c 09 4c 	lsl	r12,r9,r12
800054e0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800054e4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800054e8:	91 1c       	st.w	r8[0x4],r12
}
800054ea:	5e fc       	retal	r12

800054ec <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800054ec:	c0 08       	rjmp	800054ec <_unhandled_interrupt>
800054ee:	d7 03       	nop

800054f0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800054f0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800054f4:	49 99       	lddpc	r9,80005558 <INTC_register_interrupt+0x68>
800054f6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800054fa:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800054fe:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005500:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005504:	58 0a       	cp.w	r10,0
80005506:	c0 91       	brne	80005518 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005508:	49 59       	lddpc	r9,8000555c <INTC_register_interrupt+0x6c>
8000550a:	49 6a       	lddpc	r10,80005560 <INTC_register_interrupt+0x70>
8000550c:	12 1a       	sub	r10,r9
8000550e:	fe 79 08 00 	mov	r9,-63488
80005512:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005516:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005518:	58 1a       	cp.w	r10,1
8000551a:	c0 a1       	brne	8000552e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000551c:	49 09       	lddpc	r9,8000555c <INTC_register_interrupt+0x6c>
8000551e:	49 2a       	lddpc	r10,80005564 <INTC_register_interrupt+0x74>
80005520:	12 1a       	sub	r10,r9
80005522:	bf aa       	sbr	r10,0x1e
80005524:	fe 79 08 00 	mov	r9,-63488
80005528:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000552c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000552e:	58 2a       	cp.w	r10,2
80005530:	c0 a1       	brne	80005544 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005532:	48 b9       	lddpc	r9,8000555c <INTC_register_interrupt+0x6c>
80005534:	48 da       	lddpc	r10,80005568 <INTC_register_interrupt+0x78>
80005536:	12 1a       	sub	r10,r9
80005538:	bf ba       	sbr	r10,0x1f
8000553a:	fe 79 08 00 	mov	r9,-63488
8000553e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005542:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005544:	48 69       	lddpc	r9,8000555c <INTC_register_interrupt+0x6c>
80005546:	48 aa       	lddpc	r10,8000556c <INTC_register_interrupt+0x7c>
80005548:	12 1a       	sub	r10,r9
8000554a:	ea 1a c0 00 	orh	r10,0xc000
8000554e:	fe 79 08 00 	mov	r9,-63488
80005552:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005556:	5e fc       	retal	r12
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	d9 a4       	*unknown*
8000555c:	80 00       	ld.sh	r0,r0[0x0]
8000555e:	ce 00       	breq	8000551e <INTC_register_interrupt+0x2e>
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	cf 04       	brge	80005542 <INTC_register_interrupt+0x52>
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	cf 12       	brcc	80005548 <INTC_register_interrupt+0x58>
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	cf 20       	breq	8000554e <INTC_register_interrupt+0x5e>
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	cf 2e       	rcall	80005352 <local_start_pll0+0x7a>

80005570 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005570:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005572:	49 18       	lddpc	r8,800055b4 <INTC_init_interrupts+0x44>
80005574:	e3 b8 00 01 	mtsr	0x4,r8
80005578:	49 0e       	lddpc	lr,800055b8 <INTC_init_interrupts+0x48>
8000557a:	30 07       	mov	r7,0
8000557c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000557e:	49 0c       	lddpc	r12,800055bc <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005580:	49 05       	lddpc	r5,800055c0 <INTC_init_interrupts+0x50>
80005582:	10 15       	sub	r5,r8
80005584:	fe 76 08 00 	mov	r6,-63488
80005588:	c1 08       	rjmp	800055a8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000558a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000558c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000558e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005590:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005594:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005596:	10 3a       	cp.w	r10,r8
80005598:	fe 9b ff fc 	brhi	80005590 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000559c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800055a0:	2f f7       	sub	r7,-1
800055a2:	2f 8e       	sub	lr,-8
800055a4:	59 37       	cp.w	r7,19
800055a6:	c0 50       	breq	800055b0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055a8:	7c 08       	ld.w	r8,lr[0x0]
800055aa:	58 08       	cp.w	r8,0
800055ac:	ce f1       	brne	8000558a <INTC_init_interrupts+0x1a>
800055ae:	cf 7b       	rjmp	8000559c <INTC_init_interrupts+0x2c>
800055b0:	d8 22       	popm	r4-r7,pc
800055b2:	00 00       	add	r0,r0
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	ce 00       	breq	80005576 <INTC_init_interrupts+0x6>
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	d9 a4       	*unknown*
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	54 ec       	stdsp	sp[0x138],r12
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	cf 04       	brge	800055a2 <INTC_init_interrupts+0x32>

800055c4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800055c4:	fe 78 08 00 	mov	r8,-63488
800055c8:	e0 69 00 83 	mov	r9,131
800055cc:	f2 0c 01 0c 	sub	r12,r9,r12
800055d0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800055d4:	f2 ca ff c0 	sub	r10,r9,-64
800055d8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800055dc:	58 08       	cp.w	r8,0
800055de:	c0 21       	brne	800055e2 <_get_interrupt_handler+0x1e>
800055e0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800055e2:	f0 08 12 00 	clz	r8,r8
800055e6:	48 5a       	lddpc	r10,800055f8 <_get_interrupt_handler+0x34>
800055e8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800055ec:	f0 08 11 1f 	rsub	r8,r8,31
800055f0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800055f2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800055f6:	5e fc       	retal	r12
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	d9 a4       	*unknown*

800055fc <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800055fc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800055fe:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005602:	99 a8       	st.w	r12[0x28],r8
}
80005604:	5e fc       	retal	r12
80005606:	d7 03       	nop

80005608 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005608:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000560a:	ec 5b bb 9f 	cp.w	r11,899999
8000560e:	e0 8b 00 04 	brhi	80005616 <pm_enable_osc0_crystal+0xe>
80005612:	30 4b       	mov	r11,4
80005614:	c1 38       	rjmp	8000563a <pm_enable_osc0_crystal+0x32>
80005616:	e0 68 c6 bf 	mov	r8,50879
8000561a:	ea 18 00 2d 	orh	r8,0x2d
8000561e:	10 3b       	cp.w	r11,r8
80005620:	e0 8b 00 04 	brhi	80005628 <pm_enable_osc0_crystal+0x20>
80005624:	30 5b       	mov	r11,5
80005626:	c0 a8       	rjmp	8000563a <pm_enable_osc0_crystal+0x32>
80005628:	e0 68 12 00 	mov	r8,4608
8000562c:	ea 18 00 7a 	orh	r8,0x7a
80005630:	10 3b       	cp.w	r11,r8
80005632:	f9 bb 03 06 	movlo	r11,6
80005636:	f9 bb 02 07 	movhs	r11,7
8000563a:	f0 1f 00 02 	mcall	80005640 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000563e:	d8 02       	popm	pc
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	55 fc       	stdsp	sp[0x17c],r12

80005644 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005644:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005646:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000564a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000564c:	78 08       	ld.w	r8,r12[0x0]
8000564e:	a3 a8       	sbr	r8,0x2
80005650:	99 08       	st.w	r12[0x0],r8
}
80005652:	5e fc       	retal	r12

80005654 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005654:	79 58       	ld.w	r8,r12[0x54]
80005656:	e2 18 00 80 	andl	r8,0x80,COH
8000565a:	cf d0       	breq	80005654 <pm_wait_for_clk0_ready>
}
8000565c:	5e fc       	retal	r12
8000565e:	d7 03       	nop

80005660 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005660:	eb cd 40 80 	pushm	r7,lr
80005664:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005666:	f0 1f 00 04 	mcall	80005674 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000566a:	0e 9c       	mov	r12,r7
8000566c:	f0 1f 00 03 	mcall	80005678 <pm_enable_clk0+0x18>
}
80005670:	e3 cd 80 80 	ldm	sp++,r7,pc
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	56 44       	stdsp	sp[0x190],r4
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	56 54       	stdsp	sp[0x194],r4

8000567c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000567c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005680:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005684:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005686:	09 f7       	ld.ub	r7,r4[0x7]
80005688:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000568c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005690:	09 b4       	ld.ub	r4,r4[0x3]
80005692:	08 96       	mov	r6,r4
80005694:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005698:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000569c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800056a0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800056a4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800056a8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800056ac:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800056b0:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800056b4:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800056b6:	79 58       	ld.w	r8,r12[0x54]
800056b8:	e2 18 00 20 	andl	r8,0x20,COH
800056bc:	cf d0       	breq	800056b6 <pm_cksel+0x3a>
}
800056be:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800056c2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800056c2:	eb cd 40 80 	pushm	r7,lr
800056c6:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800056c8:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800056ca:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800056ce:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800056d2:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800056d6:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800056da:	2f 8b       	sub	r11,-8
800056dc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800056e0:	e3 cd 80 80 	ldm	sp++,r7,pc

800056e4 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800056e4:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800056e6:	2f 8b       	sub	r11,-8
800056e8:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800056ec:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800056f0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800056f4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800056f8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800056fc:	d8 02       	popm	pc

800056fe <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800056fe:	2f 8b       	sub	r11,-8
80005700:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005704:	a1 a8       	sbr	r8,0x0
80005706:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000570a:	5e fc       	retal	r12

8000570c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000570c:	79 58       	ld.w	r8,r12[0x54]
8000570e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005712:	cf d0       	breq	8000570c <pm_wait_for_pll0_locked>
}
80005714:	5e fc       	retal	r12

80005716 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005716:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005718:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000571c:	99 08       	st.w	r12[0x0],r8
}
8000571e:	5e fc       	retal	r12

80005720 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005720:	eb cd 40 c0 	pushm	r6-r7,lr
80005724:	18 97       	mov	r7,r12
80005726:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005728:	f0 1f 00 06 	mcall	80005740 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000572c:	0c 9b       	mov	r11,r6
8000572e:	0e 9c       	mov	r12,r7
80005730:	f0 1f 00 05 	mcall	80005744 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005734:	30 1b       	mov	r11,1
80005736:	0e 9c       	mov	r12,r7
80005738:	f0 1f 00 04 	mcall	80005748 <pm_switch_to_osc0+0x28>
}
8000573c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	56 08       	stdsp	sp[0x180],r8
80005744:	80 00       	ld.sh	r0,r0[0x0]
80005746:	56 60       	stdsp	sp[0x198],r0
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	57 16       	stdsp	sp[0x1c4],r6

8000574c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000574c:	f8 c8 00 01 	sub	r8,r12,1
80005750:	f0 0b 00 0b 	add	r11,r8,r11
80005754:	f6 0c 0d 0a 	divu	r10,r11,r12
80005758:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000575a:	f4 c8 00 01 	sub	r8,r10,1
8000575e:	e0 48 00 fe 	cp.w	r8,254
80005762:	e0 88 00 03 	brls	80005768 <getBaudDiv+0x1c>
80005766:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005768:	5c 8c       	casts.h	r12
}
8000576a:	5e fc       	retal	r12

8000576c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000576c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005770:	30 18       	mov	r8,1
80005772:	f0 09 18 00 	cp.b	r9,r8
80005776:	e0 88 00 04 	brls	8000577e <spi_initMaster+0x12>
8000577a:	30 2c       	mov	r12,2
8000577c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000577e:	e0 68 00 80 	mov	r8,128
80005782:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005784:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005786:	30 19       	mov	r9,1
80005788:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000578c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005790:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005794:	30 09       	mov	r9,0
80005796:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000579a:	30 fa       	mov	r10,15
8000579c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800057a0:	99 18       	st.w	r12[0x4],r8
800057a2:	5e f9       	retal	r9

800057a4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800057a4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800057a6:	30 18       	mov	r8,1
800057a8:	f0 0b 18 00 	cp.b	r11,r8
800057ac:	5f be       	srhi	lr
800057ae:	f0 0a 18 00 	cp.b	r10,r8
800057b2:	5f b8       	srhi	r8
800057b4:	fd e8 10 08 	or	r8,lr,r8
800057b8:	c0 30       	breq	800057be <spi_selectionMode+0x1a>
800057ba:	30 2c       	mov	r12,2
800057bc:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800057be:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800057c0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800057c4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800057c8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800057cc:	99 18       	st.w	r12[0x4],r8
800057ce:	d8 0a       	popm	pc,r12=0

800057d0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800057d0:	30 18       	mov	r8,1
800057d2:	99 08       	st.w	r12[0x0],r8
}
800057d4:	5e fc       	retal	r12

800057d6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800057d6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800057da:	c0 58       	rjmp	800057e4 <spi_write+0xe>
		if (!timeout--) {
800057dc:	58 08       	cp.w	r8,0
800057de:	c0 21       	brne	800057e2 <spi_write+0xc>
800057e0:	5e ff       	retal	1
800057e2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800057e4:	78 49       	ld.w	r9,r12[0x10]
800057e6:	e2 19 00 02 	andl	r9,0x2,COH
800057ea:	cf 90       	breq	800057dc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800057ec:	5c 7b       	castu.h	r11
800057ee:	99 3b       	st.w	r12[0xc],r11
800057f0:	5e fd       	retal	0

800057f2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800057f2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800057f6:	c0 58       	rjmp	80005800 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800057f8:	58 08       	cp.w	r8,0
800057fa:	c0 21       	brne	800057fe <spi_read+0xc>
800057fc:	5e ff       	retal	1
800057fe:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005800:	78 49       	ld.w	r9,r12[0x10]
80005802:	e2 19 02 01 	andl	r9,0x201,COH
80005806:	e0 49 02 01 	cp.w	r9,513
8000580a:	cf 71       	brne	800057f8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000580c:	78 28       	ld.w	r8,r12[0x8]
8000580e:	b6 08       	st.h	r11[0x0],r8
80005810:	5e fd       	retal	0
80005812:	d7 03       	nop

80005814 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005814:	eb cd 40 f8 	pushm	r3-r7,lr
80005818:	18 95       	mov	r5,r12
8000581a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000581c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005820:	30 38       	mov	r8,3
80005822:	f0 06 18 00 	cp.b	r6,r8
80005826:	e0 8b 00 5e 	brhi	800058e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000582a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000582e:	30 18       	mov	r8,1
80005830:	f0 04 18 00 	cp.b	r4,r8
80005834:	e0 8b 00 57 	brhi	800058e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005838:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000583c:	30 78       	mov	r8,7
8000583e:	f0 03 18 00 	cp.b	r3,r8
80005842:	e0 88 00 50 	brls	800058e2 <spi_setupChipReg+0xce>
80005846:	31 08       	mov	r8,16
80005848:	f0 03 18 00 	cp.b	r3,r8
8000584c:	e0 8b 00 4b 	brhi	800058e2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005850:	14 9b       	mov	r11,r10
80005852:	6e 1c       	ld.w	r12,r7[0x4]
80005854:	f0 1f 00 26 	mcall	800058ec <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005858:	c4 55       	brlt	800058e2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000585a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000585c:	ec 09 16 01 	lsr	r9,r6,0x1
80005860:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005864:	ec 16 00 01 	eorl	r6,0x1
80005868:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000586c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005870:	20 83       	sub	r3,8
80005872:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005876:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000587a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000587e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005882:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005886:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000588a:	0f 89       	ld.ub	r9,r7[0x0]
8000588c:	30 1a       	mov	r10,1
8000588e:	f4 09 18 00 	cp.b	r9,r10
80005892:	c0 d0       	breq	800058ac <spi_setupChipReg+0x98>
80005894:	c0 a3       	brcs	800058a8 <spi_setupChipReg+0x94>
80005896:	30 2a       	mov	r10,2
80005898:	f4 09 18 00 	cp.b	r9,r10
8000589c:	c0 a0       	breq	800058b0 <spi_setupChipReg+0x9c>
8000589e:	30 3a       	mov	r10,3
800058a0:	f4 09 18 00 	cp.b	r9,r10
800058a4:	c1 f1       	brne	800058e2 <spi_setupChipReg+0xce>
800058a6:	c0 78       	rjmp	800058b4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800058a8:	8b c8       	st.w	r5[0x30],r8
		break;
800058aa:	c0 68       	rjmp	800058b6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800058ac:	8b d8       	st.w	r5[0x34],r8
		break;
800058ae:	c0 48       	rjmp	800058b6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800058b0:	8b e8       	st.w	r5[0x38],r8
		break;
800058b2:	c0 28       	rjmp	800058b6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800058b4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800058b6:	48 f8       	lddpc	r8,800058f0 <spi_setupChipReg+0xdc>
800058b8:	70 08       	ld.w	r8,r8[0x0]
800058ba:	58 08       	cp.w	r8,0
800058bc:	c1 61       	brne	800058e8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800058be:	30 0b       	mov	r11,0
800058c0:	30 1c       	mov	r12,1
800058c2:	f0 1f 00 0d 	mcall	800058f4 <spi_setupChipReg+0xe0>
800058c6:	48 b8       	lddpc	r8,800058f0 <spi_setupChipReg+0xdc>
800058c8:	91 0c       	st.w	r8[0x0],r12
800058ca:	58 0c       	cp.w	r12,0
800058cc:	c0 a0       	breq	800058e0 <spi_setupChipReg+0xcc>
800058ce:	30 09       	mov	r9,0
800058d0:	12 9a       	mov	r10,r9
800058d2:	12 9b       	mov	r11,r9
800058d4:	f0 1f 00 09 	mcall	800058f8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800058d8:	48 68       	lddpc	r8,800058f0 <spi_setupChipReg+0xdc>
800058da:	70 08       	ld.w	r8,r8[0x0]
800058dc:	58 08       	cp.w	r8,0
800058de:	c0 51       	brne	800058e8 <spi_setupChipReg+0xd4>
800058e0:	c0 08       	rjmp	800058e0 <spi_setupChipReg+0xcc>
800058e2:	30 2c       	mov	r12,2
800058e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800058e8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	57 4c       	stdsp	sp[0x1d0],r12
800058f0:	00 00       	add	r0,r0
800058f2:	53 48       	stdsp	sp[0xd0],r8
800058f4:	80 00       	ld.sh	r0,r0[0x0]
800058f6:	64 38       	ld.w	r8,r2[0xc]
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	62 e0       	ld.w	r0,r1[0x38]

800058fc <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800058fc:	d4 01       	pushm	lr
800058fe:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005902:	c0 58       	rjmp	8000590c <spi_unselectChip+0x10>
		if (!timeout--) {
80005904:	58 08       	cp.w	r8,0
80005906:	c0 21       	brne	8000590a <spi_unselectChip+0xe>
80005908:	da 0a       	popm	pc,r12=1
8000590a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000590c:	78 49       	ld.w	r9,r12[0x10]
8000590e:	e2 19 02 00 	andl	r9,0x200,COH
80005912:	cf 90       	breq	80005904 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005914:	78 18       	ld.w	r8,r12[0x4]
80005916:	ea 18 00 0f 	orh	r8,0xf
8000591a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000591c:	fc 18 01 00 	movh	r8,0x100
80005920:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005922:	30 09       	mov	r9,0
80005924:	12 9a       	mov	r10,r9
80005926:	12 9b       	mov	r11,r9
80005928:	48 38       	lddpc	r8,80005934 <spi_unselectChip+0x38>
8000592a:	70 0c       	ld.w	r12,r8[0x0]
8000592c:	f0 1f 00 03 	mcall	80005938 <spi_unselectChip+0x3c>
80005930:	d8 0a       	popm	pc,r12=0
80005932:	00 00       	add	r0,r0
80005934:	00 00       	add	r0,r0
80005936:	53 48       	stdsp	sp[0xd0],r8
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	62 e0       	ld.w	r0,r1[0x38]

8000593c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000593c:	eb cd 40 f8 	pushm	r3-r7,lr
80005940:	18 94       	mov	r4,r12
80005942:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005944:	49 a6       	lddpc	r6,800059ac <spi_selectChip+0x70>
80005946:	30 07       	mov	r7,0
80005948:	31 45       	mov	r5,20
8000594a:	0e 99       	mov	r9,r7
8000594c:	0a 9a       	mov	r10,r5
8000594e:	0e 9b       	mov	r11,r7
80005950:	6c 0c       	ld.w	r12,r6[0x0]
80005952:	f0 1f 00 18 	mcall	800059b0 <spi_selectChip+0x74>
80005956:	cf a0       	breq	8000594a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005958:	68 18       	ld.w	r8,r4[0x4]
8000595a:	ea 18 00 0f 	orh	r8,0xf
8000595e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005960:	68 18       	ld.w	r8,r4[0x4]
80005962:	e2 18 00 04 	andl	r8,0x4,COH
80005966:	c1 10       	breq	80005988 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005968:	30 e8       	mov	r8,14
8000596a:	f0 03 18 00 	cp.b	r3,r8
8000596e:	e0 8b 00 1c 	brhi	800059a6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005972:	68 19       	ld.w	r9,r4[0x4]
80005974:	e6 08 15 10 	lsl	r8,r3,0x10
80005978:	ea 18 ff f0 	orh	r8,0xfff0
8000597c:	e8 18 ff ff 	orl	r8,0xffff
80005980:	12 68       	and	r8,r9
80005982:	89 18       	st.w	r4[0x4],r8
80005984:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005988:	30 38       	mov	r8,3
8000598a:	f0 03 18 00 	cp.b	r3,r8
8000598e:	e0 8b 00 0c 	brhi	800059a6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005992:	68 19       	ld.w	r9,r4[0x4]
80005994:	2f 03       	sub	r3,-16
80005996:	30 18       	mov	r8,1
80005998:	f0 03 09 48 	lsl	r8,r8,r3
8000599c:	5c d8       	com	r8
8000599e:	12 68       	and	r8,r9
800059a0:	89 18       	st.w	r4[0x4],r8
800059a2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059a6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800059a8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059ac:	00 00       	add	r0,r0
800059ae:	53 48       	stdsp	sp[0xd0],r8
800059b0:	80 00       	ld.sh	r0,r0[0x0]
800059b2:	60 d4       	ld.w	r4,r0[0x34]

800059b4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800059b4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800059b6:	f6 08 15 04 	lsl	r8,r11,0x4
800059ba:	14 38       	cp.w	r8,r10
800059bc:	f9 b8 08 10 	movls	r8,16
800059c0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800059c4:	f0 0b 02 4b 	mul	r11,r8,r11
800059c8:	f6 09 16 01 	lsr	r9,r11,0x1
800059cc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800059d0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800059d4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800059d8:	f2 cb 00 01 	sub	r11,r9,1
800059dc:	e0 4b ff fe 	cp.w	r11,65534
800059e0:	e0 88 00 03 	brls	800059e6 <usart_set_async_baudrate+0x32>
800059e4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800059e6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800059e8:	e8 6e 00 00 	mov	lr,524288
800059ec:	59 08       	cp.w	r8,16
800059ee:	fc 08 17 10 	movne	r8,lr
800059f2:	f9 b8 00 00 	moveq	r8,0
800059f6:	e4 1b ff f7 	andh	r11,0xfff7
800059fa:	e0 1b fe cf 	andl	r11,0xfecf
800059fe:	16 48       	or	r8,r11
80005a00:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005a02:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005a06:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005a0a:	99 89       	st.w	r12[0x20],r9
80005a0c:	d8 0a       	popm	pc,r12=0

80005a0e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005a0e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005a10:	e2 18 00 02 	andl	r8,0x2,COH
80005a14:	c0 31       	brne	80005a1a <usart_write_char+0xc>
80005a16:	30 2c       	mov	r12,2
80005a18:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005a1a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005a1e:	99 7b       	st.w	r12[0x1c],r11
80005a20:	5e fd       	retal	0
80005a22:	d7 03       	nop

80005a24 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005a24:	eb cd 40 e0 	pushm	r5-r7,lr
80005a28:	18 96       	mov	r6,r12
80005a2a:	16 95       	mov	r5,r11
80005a2c:	e0 67 27 0f 	mov	r7,9999
80005a30:	c0 68       	rjmp	80005a3c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005a32:	58 07       	cp.w	r7,0
80005a34:	c0 31       	brne	80005a3a <usart_putchar+0x16>
80005a36:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005a3a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005a3c:	0a 9b       	mov	r11,r5
80005a3e:	0c 9c       	mov	r12,r6
80005a40:	f0 1f 00 03 	mcall	80005a4c <usart_putchar+0x28>
80005a44:	cf 71       	brne	80005a32 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005a46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005a4a:	00 00       	add	r0,r0
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	5a 0e       	cp.w	lr,-32

80005a50 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005a50:	78 58       	ld.w	r8,r12[0x14]
80005a52:	e2 18 00 e0 	andl	r8,0xe0,COH
80005a56:	c0 30       	breq	80005a5c <usart_read_char+0xc>
80005a58:	30 4c       	mov	r12,4
80005a5a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005a5c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005a5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005a62:	c0 31       	brne	80005a68 <usart_read_char+0x18>
80005a64:	30 3c       	mov	r12,3
80005a66:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005a68:	78 68       	ld.w	r8,r12[0x18]
80005a6a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005a6e:	97 08       	st.w	r11[0x0],r8
80005a70:	5e fd       	retal	0
80005a72:	d7 03       	nop

80005a74 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005a74:	eb cd 40 c0 	pushm	r6-r7,lr
80005a78:	20 1d       	sub	sp,4
80005a7a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005a7c:	1a 97       	mov	r7,sp
80005a7e:	1a 9b       	mov	r11,sp
80005a80:	0c 9c       	mov	r12,r6
80005a82:	f0 1f 00 07 	mcall	80005a9c <usart_getchar+0x28>
80005a86:	58 3c       	cp.w	r12,3
80005a88:	cf b0       	breq	80005a7e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005a8a:	58 4c       	cp.w	r12,4
80005a8c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005a90:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005a94:	2f fd       	sub	sp,-4
80005a96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a9a:	00 00       	add	r0,r0
80005a9c:	80 00       	ld.sh	r0,r0[0x0]
80005a9e:	5a 50       	cp.w	r0,-27

80005aa0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005aa0:	eb cd 40 c0 	pushm	r6-r7,lr
80005aa4:	18 96       	mov	r6,r12
80005aa6:	16 97       	mov	r7,r11
  while (*string != '\0')
80005aa8:	17 8b       	ld.ub	r11,r11[0x0]
80005aaa:	58 0b       	cp.w	r11,0
80005aac:	c0 80       	breq	80005abc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005aae:	2f f7       	sub	r7,-1
80005ab0:	0c 9c       	mov	r12,r6
80005ab2:	f0 1f 00 04 	mcall	80005ac0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005ab6:	0f 8b       	ld.ub	r11,r7[0x0]
80005ab8:	58 0b       	cp.w	r11,0
80005aba:	cf a1       	brne	80005aae <usart_write_line+0xe>
80005abc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	5a 24       	cp.w	r4,-30

80005ac4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005ac4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005ac8:	e6 18 00 01 	andh	r8,0x1,COH
80005acc:	c0 71       	brne	80005ada <usart_reset+0x16>
80005ace:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005ad0:	3f f8       	mov	r8,-1
80005ad2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005ad4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005ad6:	d5 03       	csrf	0x10
80005ad8:	c0 48       	rjmp	80005ae0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005ada:	3f f8       	mov	r8,-1
80005adc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005ade:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005ae0:	30 08       	mov	r8,0
80005ae2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005ae4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005ae6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005ae8:	ea 68 61 0c 	mov	r8,680204
80005aec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005aee:	5e fc       	retal	r12

80005af0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005af0:	eb cd 40 e0 	pushm	r5-r7,lr
80005af4:	18 96       	mov	r6,r12
80005af6:	16 97       	mov	r7,r11
80005af8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005afa:	f0 1f 00 2f 	mcall	80005bb4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005afe:	58 07       	cp.w	r7,0
80005b00:	c5 80       	breq	80005bb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005b02:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005b04:	30 49       	mov	r9,4
80005b06:	f2 08 18 00 	cp.b	r8,r9
80005b0a:	e0 88 00 53 	brls	80005bb0 <usart_init_rs232+0xc0>
80005b0e:	30 99       	mov	r9,9
80005b10:	f2 08 18 00 	cp.b	r8,r9
80005b14:	e0 8b 00 4e 	brhi	80005bb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005b18:	0f d9       	ld.ub	r9,r7[0x5]
80005b1a:	30 78       	mov	r8,7
80005b1c:	f0 09 18 00 	cp.b	r9,r8
80005b20:	e0 8b 00 48 	brhi	80005bb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005b24:	8e 39       	ld.sh	r9,r7[0x6]
80005b26:	e0 68 01 01 	mov	r8,257
80005b2a:	f0 09 19 00 	cp.h	r9,r8
80005b2e:	e0 8b 00 41 	brhi	80005bb0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005b32:	ef 39 00 08 	ld.ub	r9,r7[8]
80005b36:	30 38       	mov	r8,3
80005b38:	f0 09 18 00 	cp.b	r9,r8
80005b3c:	e0 8b 00 3a 	brhi	80005bb0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005b40:	0a 9a       	mov	r10,r5
80005b42:	6e 0b       	ld.w	r11,r7[0x0]
80005b44:	0c 9c       	mov	r12,r6
80005b46:	f0 1f 00 1d 	mcall	80005bb8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005b4a:	58 1c       	cp.w	r12,1
80005b4c:	c3 20       	breq	80005bb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005b4e:	0f c8       	ld.ub	r8,r7[0x4]
80005b50:	30 99       	mov	r9,9
80005b52:	f2 08 18 00 	cp.b	r8,r9
80005b56:	c0 51       	brne	80005b60 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005b58:	6c 18       	ld.w	r8,r6[0x4]
80005b5a:	b1 b8       	sbr	r8,0x11
80005b5c:	8d 18       	st.w	r6[0x4],r8
80005b5e:	c0 68       	rjmp	80005b6a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005b60:	6c 19       	ld.w	r9,r6[0x4]
80005b62:	20 58       	sub	r8,5
80005b64:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005b68:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005b6a:	6c 19       	ld.w	r9,r6[0x4]
80005b6c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005b70:	0f d8       	ld.ub	r8,r7[0x5]
80005b72:	a9 78       	lsl	r8,0x9
80005b74:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005b78:	12 48       	or	r8,r9
80005b7a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005b7c:	8e 38       	ld.sh	r8,r7[0x6]
80005b7e:	30 29       	mov	r9,2
80005b80:	f2 08 19 00 	cp.h	r8,r9
80005b84:	e0 88 00 09 	brls	80005b96 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005b88:	6c 18       	ld.w	r8,r6[0x4]
80005b8a:	ad b8       	sbr	r8,0xd
80005b8c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005b8e:	8e b8       	ld.uh	r8,r7[0x6]
80005b90:	20 28       	sub	r8,2
80005b92:	8d a8       	st.w	r6[0x28],r8
80005b94:	c0 68       	rjmp	80005ba0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005b96:	6c 19       	ld.w	r9,r6[0x4]
80005b98:	5c 78       	castu.h	r8
80005b9a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005b9e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005ba0:	6c 18       	ld.w	r8,r6[0x4]
80005ba2:	e0 18 ff f0 	andl	r8,0xfff0
80005ba6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005ba8:	35 08       	mov	r8,80
80005baa:	8d 08       	st.w	r6[0x0],r8
80005bac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005bb0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	5a c4       	cp.w	r4,-20
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	59 b4       	cp.w	r4,27

80005bbc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005bbc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005bc0:	fe c0 8d c0 	sub	r0,pc,-29248

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005bc4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005bc8:	d5 53       	csrf	0x15
  cp      r0, r1
80005bca:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005bcc:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005bd0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005bd2:	c0 62       	brcc	80005bde <idata_load_loop_end>
  cp      r0, r1
80005bd4:	48 92       	lddpc	r2,80005bf8 <udata_clear_loop_end+0x4>

80005bd6 <idata_load_loop>:
  brlo    idata_load_loop
80005bd6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005bd8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005bda:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005bdc:	cf d3       	brcs	80005bd6 <idata_load_loop>

80005bde <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005bde:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005be2:	e0 61 53 58 	mov	r1,21336
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005be6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005be8:	c0 62       	brcc	80005bf4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005bea:	30 02       	mov	r2,0
80005bec:	30 03       	mov	r3,0

80005bee <udata_clear_loop>:
80005bee:	a1 22       	st.d	r0++,r2
80005bf0:	02 30       	cp.w	r0,r1
80005bf2:	cf e3       	brcs	80005bee <udata_clear_loop>

80005bf4 <udata_clear_loop_end>:
80005bf4:	fe cf e9 10 	sub	pc,pc,-5872
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	e2 d8 f8 c8 	satsub.w	r8,r1,-1848

80005bfc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005bfc:	f8 c8 ff f8 	sub	r8,r12,-8
80005c00:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005c02:	3f f9       	mov	r9,-1
80005c04:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005c06:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005c08:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005c0a:	30 08       	mov	r8,0
80005c0c:	99 08       	st.w	r12[0x0],r8
}
80005c0e:	5e fc       	retal	r12

80005c10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005c10:	30 08       	mov	r8,0
80005c12:	99 48       	st.w	r12[0x10],r8
}
80005c14:	5e fc       	retal	r12

80005c16 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005c16:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005c18:	70 19       	ld.w	r9,r8[0x4]
80005c1a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005c1c:	78 19       	ld.w	r9,r12[0x4]
80005c1e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c20:	70 19       	ld.w	r9,r8[0x4]
80005c22:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c24:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005c26:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c28:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c2a:	78 08       	ld.w	r8,r12[0x0]
80005c2c:	2f f8       	sub	r8,-1
80005c2e:	99 08       	st.w	r12[0x0],r8
}
80005c30:	5e fc       	retal	r12

80005c32 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005c32:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005c34:	5b fa       	cp.w	r10,-1
80005c36:	c0 31       	brne	80005c3c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005c38:	78 48       	ld.w	r8,r12[0x10]
80005c3a:	c0 c8       	rjmp	80005c52 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005c3c:	f8 c8 ff f8 	sub	r8,r12,-8
80005c40:	70 19       	ld.w	r9,r8[0x4]
80005c42:	72 09       	ld.w	r9,r9[0x0]
80005c44:	12 3a       	cp.w	r10,r9
80005c46:	c0 63       	brcs	80005c52 <vListInsert+0x20>
80005c48:	70 18       	ld.w	r8,r8[0x4]
80005c4a:	70 19       	ld.w	r9,r8[0x4]
80005c4c:	72 09       	ld.w	r9,r9[0x0]
80005c4e:	12 3a       	cp.w	r10,r9
80005c50:	cf c2       	brcc	80005c48 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005c52:	70 19       	ld.w	r9,r8[0x4]
80005c54:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c56:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005c58:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c5a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c5c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c5e:	78 08       	ld.w	r8,r12[0x0]
80005c60:	2f f8       	sub	r8,-1
80005c62:	99 08       	st.w	r12[0x0],r8
}
80005c64:	5e fc       	retal	r12

80005c66 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005c66:	78 18       	ld.w	r8,r12[0x4]
80005c68:	78 29       	ld.w	r9,r12[0x8]
80005c6a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005c6c:	78 28       	ld.w	r8,r12[0x8]
80005c6e:	78 19       	ld.w	r9,r12[0x4]
80005c70:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005c72:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005c74:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005c76:	18 39       	cp.w	r9,r12
80005c78:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005c7c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005c80:	30 09       	mov	r9,0
80005c82:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005c84:	70 09       	ld.w	r9,r8[0x0]
80005c86:	20 19       	sub	r9,1
80005c88:	91 09       	st.w	r8[0x0],r9
}
80005c8a:	5e fc       	retal	r12

80005c8c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005c8c:	e0 68 08 08 	mov	r8,2056
80005c90:	ea 18 08 08 	orh	r8,0x808
80005c94:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005c96:	e0 68 09 09 	mov	r8,2313
80005c9a:	ea 18 09 09 	orh	r8,0x909
80005c9e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005ca0:	e0 68 0a 0a 	mov	r8,2570
80005ca4:	ea 18 0a 0a 	orh	r8,0xa0a
80005ca8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005caa:	e0 68 0b 0b 	mov	r8,2827
80005cae:	ea 18 0b 0b 	orh	r8,0xb0b
80005cb2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005cb4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005cb6:	e0 68 be ef 	mov	r8,48879
80005cba:	ea 18 de ad 	orh	r8,0xdead
80005cbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005cc0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005cc2:	fc 18 00 40 	movh	r8,0x40
80005cc6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005cc8:	e0 68 00 ff 	mov	r8,255
80005ccc:	ea 18 ff 00 	orh	r8,0xff00
80005cd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005cd2:	e0 68 01 01 	mov	r8,257
80005cd6:	ea 18 01 01 	orh	r8,0x101
80005cda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005cdc:	e0 68 02 02 	mov	r8,514
80005ce0:	ea 18 02 02 	orh	r8,0x202
80005ce4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005ce6:	e0 68 03 03 	mov	r8,771
80005cea:	ea 18 03 03 	orh	r8,0x303
80005cee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005cf0:	e0 68 04 04 	mov	r8,1028
80005cf4:	ea 18 04 04 	orh	r8,0x404
80005cf8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005cfa:	e0 68 05 05 	mov	r8,1285
80005cfe:	ea 18 05 05 	orh	r8,0x505
80005d02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005d04:	e0 68 06 06 	mov	r8,1542
80005d08:	ea 18 06 06 	orh	r8,0x606
80005d0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005d0e:	e0 68 07 07 	mov	r8,1799
80005d12:	ea 18 07 07 	orh	r8,0x707
80005d16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005d18:	30 08       	mov	r8,0
80005d1a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005d1c:	5e fc       	retal	r12
80005d1e:	d7 03       	nop

80005d20 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005d20:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005d22:	48 38       	lddpc	r8,80005d2c <vPortEnterCritical+0xc>
80005d24:	70 09       	ld.w	r9,r8[0x0]
80005d26:	2f f9       	sub	r9,-1
80005d28:	91 09       	st.w	r8[0x0],r9
}
80005d2a:	5e fc       	retal	r12
80005d2c:	00 00       	add	r0,r0
80005d2e:	05 34       	ld.ub	r4,r2++

80005d30 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005d30:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005d32:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005d34:	30 0a       	mov	r10,0
80005d36:	14 9b       	mov	r11,r10
80005d38:	49 2c       	lddpc	r12,80005d80 <xPortStartScheduler+0x50>
80005d3a:	f0 1f 00 13 	mcall	80005d84 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005d3e:	e0 68 5d c0 	mov	r8,24000
80005d42:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005d46:	30 08       	mov	r8,0
80005d48:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005d4c:	e0 68 0c f8 	mov	r8,3320
80005d50:	ea 18 00 00 	orh	r8,0x0
80005d54:	70 00       	ld.w	r0,r8[0x0]
80005d56:	60 0d       	ld.w	sp,r0[0x0]
80005d58:	1b 00       	ld.w	r0,sp++
80005d5a:	e0 68 05 34 	mov	r8,1332
80005d5e:	ea 18 00 00 	orh	r8,0x0
80005d62:	91 00       	st.w	r8[0x0],r0
80005d64:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d68:	2f ed       	sub	sp,-8
80005d6a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005d6e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005d72:	e3 b0 00 00 	mtsr	0x0,r0
80005d76:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005d7a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005d7e:	d8 0a       	popm	pc,r12=0
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	5e 4c       	retge	r12
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	54 f0       	stdsp	sp[0x13c],r0

80005d88 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005d88:	20 6d       	sub	sp,24
80005d8a:	eb cd 00 ff 	pushm	r0-r7
80005d8e:	fa c7 ff c0 	sub	r7,sp,-64
80005d92:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005d96:	ef 40 ff e0 	st.w	r7[-32],r0
80005d9a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005d9e:	ef 40 ff e4 	st.w	r7[-28],r0
80005da2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005da6:	e0 68 05 34 	mov	r8,1332
80005daa:	ea 18 00 00 	orh	r8,0x0
80005dae:	70 00       	ld.w	r0,r8[0x0]
80005db0:	1a d0       	st.w	--sp,r0
80005db2:	f0 1f 00 1a 	mcall	80005e18 <LABEL_RET_SCALL_263+0x14>
80005db6:	e0 68 0c f8 	mov	r8,3320
80005dba:	ea 18 00 00 	orh	r8,0x0
80005dbe:	70 00       	ld.w	r0,r8[0x0]
80005dc0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005dc2:	f0 1f 00 17 	mcall	80005e1c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005dc6:	e0 68 0c f8 	mov	r8,3320
80005dca:	ea 18 00 00 	orh	r8,0x0
80005dce:	70 00       	ld.w	r0,r8[0x0]
80005dd0:	60 0d       	ld.w	sp,r0[0x0]
80005dd2:	1b 00       	ld.w	r0,sp++
80005dd4:	e0 68 05 34 	mov	r8,1332
80005dd8:	ea 18 00 00 	orh	r8,0x0
80005ddc:	91 00       	st.w	r8[0x0],r0
80005dde:	fa c7 ff d8 	sub	r7,sp,-40
80005de2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005de6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005dea:	e0 61 05 34 	mov	r1,1332
80005dee:	ea 11 00 00 	orh	r1,0x0
80005df2:	62 02       	ld.w	r2,r1[0x0]
80005df4:	58 02       	cp.w	r2,0
80005df6:	c0 70       	breq	80005e04 <LABEL_RET_SCALL_263>
80005df8:	e4 c2 00 01 	sub	r2,r2,1
80005dfc:	83 02       	st.w	r1[0x0],r2
80005dfe:	58 02       	cp.w	r2,0
80005e00:	c0 21       	brne	80005e04 <LABEL_RET_SCALL_263>
80005e02:	b1 c0       	cbr	r0,0x10

80005e04 <LABEL_RET_SCALL_263>:
80005e04:	ef 40 ff f8 	st.w	r7[-8],r0
80005e08:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005e0c:	ef 40 ff fc 	st.w	r7[-4],r0
80005e10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e14:	2f ad       	sub	sp,-24
80005e16:	d6 13       	rets
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	5d 20       	mustr	r0
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	64 d4       	ld.w	r4,r2[0x34]

80005e20 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005e20:	e1 b8 00 43 	mfsr	r8,0x10c
80005e24:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005e28:	5e fc       	retal	r12
80005e2a:	d7 03       	nop

80005e2c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005e2c:	48 78       	lddpc	r8,80005e48 <vPortExitCritical+0x1c>
80005e2e:	70 08       	ld.w	r8,r8[0x0]
80005e30:	58 08       	cp.w	r8,0
80005e32:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005e34:	48 58       	lddpc	r8,80005e48 <vPortExitCritical+0x1c>
80005e36:	70 09       	ld.w	r9,r8[0x0]
80005e38:	20 19       	sub	r9,1
80005e3a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005e3c:	70 08       	ld.w	r8,r8[0x0]
80005e3e:	58 08       	cp.w	r8,0
80005e40:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005e42:	d5 03       	csrf	0x10
80005e44:	5e fc       	retal	r12
80005e46:	00 00       	add	r0,r0
80005e48:	00 00       	add	r0,r0
80005e4a:	05 34       	ld.ub	r4,r2++

80005e4c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005e4c:	eb cd 00 ff 	pushm	r0-r7
80005e50:	e0 68 05 34 	mov	r8,1332
80005e54:	ea 18 00 00 	orh	r8,0x0
80005e58:	70 00       	ld.w	r0,r8[0x0]
80005e5a:	1a d0       	st.w	--sp,r0
80005e5c:	7a 90       	ld.w	r0,sp[0x24]
80005e5e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005e62:	58 10       	cp.w	r0,1
80005e64:	e0 8b 00 08 	brhi	80005e74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005e68:	e0 68 0c f8 	mov	r8,3320
80005e6c:	ea 18 00 00 	orh	r8,0x0
80005e70:	70 00       	ld.w	r0,r8[0x0]
80005e72:	81 0d       	st.w	r0[0x0],sp

80005e74 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005e74:	f0 1f 00 12 	mcall	80005ebc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005e78:	f0 1f 00 12 	mcall	80005ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005e7c:	f0 1f 00 12 	mcall	80005ec4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005e80:	f0 1f 00 12 	mcall	80005ec8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005e84:	7a 90       	ld.w	r0,sp[0x24]
80005e86:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005e8a:	58 10       	cp.w	r0,1
80005e8c:	e0 8b 00 0e 	brhi	80005ea8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005e90:	f0 1f 00 0c 	mcall	80005ec0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005e94:	f0 1f 00 0e 	mcall	80005ecc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005e98:	f0 1f 00 0c 	mcall	80005ec8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005e9c:	e0 68 0c f8 	mov	r8,3320
80005ea0:	ea 18 00 00 	orh	r8,0x0
80005ea4:	70 00       	ld.w	r0,r8[0x0]
80005ea6:	60 0d       	ld.w	sp,r0[0x0]

80005ea8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005ea8:	1b 00       	ld.w	r0,sp++
80005eaa:	e0 68 05 34 	mov	r8,1332
80005eae:	ea 18 00 00 	orh	r8,0x0
80005eb2:	91 00       	st.w	r8[0x0],r0
80005eb4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005eb8:	d6 03       	rete
80005eba:	00 00       	add	r0,r0
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	5e 20       	reths	r0
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	5d 20       	mustr	r0
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	66 d8       	ld.w	r8,r3[0x34]
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	5e 2c       	reths	r12
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	64 d4       	ld.w	r4,r2[0x34]

80005ed0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005ed0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005ed2:	f0 1f 00 02 	mcall	80005ed8 <__malloc_lock+0x8>
}
80005ed6:	d8 02       	popm	pc
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	64 c4       	ld.w	r4,r2[0x30]

80005edc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005edc:	d4 01       	pushm	lr
	xTaskResumeAll();
80005ede:	f0 1f 00 02 	mcall	80005ee4 <__malloc_unlock+0x8>
}
80005ee2:	d8 02       	popm	pc
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	68 80       	ld.w	r0,r4[0x20]

80005ee8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005ee8:	d4 21       	pushm	r4-r7,lr
80005eea:	16 95       	mov	r5,r11
80005eec:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005eee:	58 0c       	cp.w	r12,0
80005ef0:	c0 30       	breq	80005ef6 <_read+0xe>
80005ef2:	3f f7       	mov	r7,-1
80005ef4:	c1 48       	rjmp	80005f1c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005ef6:	58 0a       	cp.w	r10,0
80005ef8:	e0 89 00 04 	brgt	80005f00 <_read+0x18>
80005efc:	30 07       	mov	r7,0
80005efe:	c0 f8       	rjmp	80005f1c <_read+0x34>
80005f00:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005f02:	48 84       	lddpc	r4,80005f20 <_read+0x38>
80005f04:	68 0c       	ld.w	r12,r4[0x0]
80005f06:	f0 1f 00 08 	mcall	80005f24 <_read+0x3c>
    if (c < 0)
80005f0a:	c0 95       	brlt	80005f1c <_read+0x34>
      break;

    *ptr++ = c;
80005f0c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005f10:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005f12:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005f16:	58 08       	cp.w	r8,0
80005f18:	fe 99 ff f6 	brgt	80005f04 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005f1c:	0e 9c       	mov	r12,r7
80005f1e:	d8 22       	popm	r4-r7,pc
80005f20:	00 00       	add	r0,r0
80005f22:	53 4c       	stdsp	sp[0xd0],r12
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	5a 74       	cp.w	r4,-25

80005f28 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005f28:	d4 21       	pushm	r4-r7,lr
80005f2a:	16 95       	mov	r5,r11
80005f2c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005f2e:	20 1c       	sub	r12,1
80005f30:	58 2c       	cp.w	r12,2
80005f32:	e0 8b 00 12 	brhi	80005f56 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f36:	58 0a       	cp.w	r10,0
80005f38:	c0 31       	brne	80005f3e <_write+0x16>
80005f3a:	30 07       	mov	r7,0
80005f3c:	c0 e8       	rjmp	80005f58 <_write+0x30>
80005f3e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005f40:	48 74       	lddpc	r4,80005f5c <_write+0x34>
80005f42:	68 0c       	ld.w	r12,r4[0x0]
80005f44:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005f48:	f0 1f 00 06 	mcall	80005f60 <_write+0x38>
80005f4c:	c0 55       	brlt	80005f56 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005f4e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f50:	0e 36       	cp.w	r6,r7
80005f52:	cf 81       	brne	80005f42 <_write+0x1a>
80005f54:	c0 28       	rjmp	80005f58 <_write+0x30>
80005f56:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005f58:	0e 9c       	mov	r12,r7
80005f5a:	d8 22       	popm	r4-r7,pc
80005f5c:	00 00       	add	r0,r0
80005f5e:	53 4c       	stdsp	sp[0xd0],r12
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	5a 24       	cp.w	r4,-30

80005f64 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005f64:	eb cd 40 80 	pushm	r7,lr
80005f68:	18 97       	mov	r7,r12
	if( pv )
80005f6a:	58 0c       	cp.w	r12,0
80005f6c:	c0 80       	breq	80005f7c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005f6e:	f0 1f 00 05 	mcall	80005f80 <vPortFree+0x1c>
		{
			free( pv );
80005f72:	0e 9c       	mov	r12,r7
80005f74:	f0 1f 00 04 	mcall	80005f84 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005f78:	f0 1f 00 04 	mcall	80005f88 <vPortFree+0x24>
80005f7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	64 c4       	ld.w	r4,r2[0x30]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	73 54       	ld.w	r4,r9[0x54]
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	68 80       	ld.w	r0,r4[0x20]

80005f8c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005f8c:	eb cd 40 80 	pushm	r7,lr
80005f90:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005f92:	f0 1f 00 06 	mcall	80005fa8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005f96:	0e 9c       	mov	r12,r7
80005f98:	f0 1f 00 05 	mcall	80005fac <pvPortMalloc+0x20>
80005f9c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005f9e:	f0 1f 00 05 	mcall	80005fb0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005fa2:	0e 9c       	mov	r12,r7
80005fa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	64 c4       	ld.w	r4,r2[0x30]
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	73 64       	ld.w	r4,r9[0x58]
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	68 80       	ld.w	r0,r4[0x20]

80005fb4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005fb4:	d4 01       	pushm	lr
80005fb6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005fb8:	78 09       	ld.w	r9,r12[0x0]
80005fba:	58 09       	cp.w	r9,0
80005fbc:	c1 10       	breq	80005fde <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005fbe:	78 3a       	ld.w	r10,r12[0xc]
80005fc0:	79 09       	ld.w	r9,r12[0x40]
80005fc2:	f4 09 00 09 	add	r9,r10,r9
80005fc6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005fc8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005fca:	14 39       	cp.w	r9,r10
80005fcc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005fd0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005fd4:	79 0a       	ld.w	r10,r12[0x40]
80005fd6:	78 3b       	ld.w	r11,r12[0xc]
80005fd8:	10 9c       	mov	r12,r8
80005fda:	f0 1f 00 02 	mcall	80005fe0 <prvCopyDataFromQueue+0x2c>
80005fde:	d8 02       	popm	pc
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	77 ac       	ld.w	r12,r11[0x68]

80005fe4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005fe4:	eb cd 40 c0 	pushm	r6-r7,lr
80005fe8:	18 97       	mov	r7,r12
80005fea:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005fec:	78 e8       	ld.w	r8,r12[0x38]
80005fee:	58 08       	cp.w	r8,0
80005ff0:	c0 31       	brne	80005ff6 <xQueueReceiveFromISR+0x12>
80005ff2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005ff6:	f0 1f 00 0e 	mcall	8000602c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005ffa:	6e e8       	ld.w	r8,r7[0x38]
80005ffc:	20 18       	sub	r8,1
80005ffe:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006000:	6f 18       	ld.w	r8,r7[0x44]
80006002:	5b f8       	cp.w	r8,-1
80006004:	c0 d1       	brne	8000601e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006006:	6e 48       	ld.w	r8,r7[0x10]
80006008:	58 08       	cp.w	r8,0
8000600a:	c0 f0       	breq	80006028 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000600c:	ee cc ff f0 	sub	r12,r7,-16
80006010:	f0 1f 00 08 	mcall	80006030 <xQueueReceiveFromISR+0x4c>
80006014:	c0 a0       	breq	80006028 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006016:	30 1c       	mov	r12,1
80006018:	8d 0c       	st.w	r6[0x0],r12
8000601a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000601e:	2f f8       	sub	r8,-1
80006020:	ef 48 00 44 	st.w	r7[68],r8
80006024:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006028:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	5f b4       	srhi	r4
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	66 5c       	ld.w	r12,r3[0x14]

80006034 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006034:	eb cd 40 c0 	pushm	r6-r7,lr
80006038:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000603a:	f0 1f 00 23 	mcall	800060c4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000603e:	6f 28       	ld.w	r8,r7[0x48]
80006040:	58 08       	cp.w	r8,0
80006042:	e0 8a 00 18 	brle	80006072 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006046:	6e 98       	ld.w	r8,r7[0x24]
80006048:	58 08       	cp.w	r8,0
8000604a:	c1 40       	breq	80006072 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000604c:	ee c6 ff dc 	sub	r6,r7,-36
80006050:	c0 48       	rjmp	80006058 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006052:	6e 98       	ld.w	r8,r7[0x24]
80006054:	58 08       	cp.w	r8,0
80006056:	c0 e0       	breq	80006072 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006058:	0c 9c       	mov	r12,r6
8000605a:	f0 1f 00 1c 	mcall	800060c8 <prvUnlockQueue+0x94>
8000605e:	c0 30       	breq	80006064 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006060:	f0 1f 00 1b 	mcall	800060cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006064:	6f 28       	ld.w	r8,r7[0x48]
80006066:	20 18       	sub	r8,1
80006068:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000606c:	58 08       	cp.w	r8,0
8000606e:	fe 99 ff f2 	brgt	80006052 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006072:	3f f8       	mov	r8,-1
80006074:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006078:	f0 1f 00 16 	mcall	800060d0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000607c:	f0 1f 00 12 	mcall	800060c4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006080:	6f 18       	ld.w	r8,r7[0x44]
80006082:	58 08       	cp.w	r8,0
80006084:	e0 8a 00 18 	brle	800060b4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006088:	6e 48       	ld.w	r8,r7[0x10]
8000608a:	58 08       	cp.w	r8,0
8000608c:	c1 40       	breq	800060b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000608e:	ee c6 ff f0 	sub	r6,r7,-16
80006092:	c0 48       	rjmp	8000609a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006094:	6e 48       	ld.w	r8,r7[0x10]
80006096:	58 08       	cp.w	r8,0
80006098:	c0 e0       	breq	800060b4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000609a:	0c 9c       	mov	r12,r6
8000609c:	f0 1f 00 0b 	mcall	800060c8 <prvUnlockQueue+0x94>
800060a0:	c0 30       	breq	800060a6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800060a2:	f0 1f 00 0b 	mcall	800060cc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800060a6:	6f 18       	ld.w	r8,r7[0x44]
800060a8:	20 18       	sub	r8,1
800060aa:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800060ae:	58 08       	cp.w	r8,0
800060b0:	fe 99 ff f2 	brgt	80006094 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800060b4:	3f f8       	mov	r8,-1
800060b6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800060ba:	f0 1f 00 06 	mcall	800060d0 <prvUnlockQueue+0x9c>
}
800060be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060c2:	00 00       	add	r0,r0
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	5d 20       	mustr	r0
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	66 5c       	ld.w	r12,r3[0x14]
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	65 68       	ld.w	r8,r2[0x58]
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	5e 2c       	reths	r12

800060d4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800060d4:	d4 31       	pushm	r0-r7,lr
800060d6:	20 5d       	sub	sp,20
800060d8:	18 97       	mov	r7,r12
800060da:	50 0b       	stdsp	sp[0x0],r11
800060dc:	50 2a       	stdsp	sp[0x8],r10
800060de:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060e0:	f8 c2 ff dc 	sub	r2,r12,-36
800060e4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060e6:	fa c4 ff f4 	sub	r4,sp,-12
800060ea:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800060ec:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060ee:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800060f2:	f0 1f 00 3e 	mcall	800061e8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060f6:	6e e8       	ld.w	r8,r7[0x38]
800060f8:	58 08       	cp.w	r8,0
800060fa:	c2 a0       	breq	8000614e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800060fc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800060fe:	40 0b       	lddsp	r11,sp[0x0]
80006100:	0e 9c       	mov	r12,r7
80006102:	f0 1f 00 3b 	mcall	800061ec <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006106:	40 18       	lddsp	r8,sp[0x4]
80006108:	58 08       	cp.w	r8,0
8000610a:	c1 51       	brne	80006134 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000610c:	6e e8       	ld.w	r8,r7[0x38]
8000610e:	20 18       	sub	r8,1
80006110:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006112:	6e 08       	ld.w	r8,r7[0x0]
80006114:	58 08       	cp.w	r8,0
80006116:	c0 41       	brne	8000611e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006118:	f0 1f 00 36 	mcall	800061f0 <xQueueGenericReceive+0x11c>
8000611c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000611e:	6e 48       	ld.w	r8,r7[0x10]
80006120:	58 08       	cp.w	r8,0
80006122:	c1 20       	breq	80006146 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006124:	ee cc ff f0 	sub	r12,r7,-16
80006128:	f0 1f 00 33 	mcall	800061f4 <xQueueGenericReceive+0x120>
8000612c:	58 1c       	cp.w	r12,1
8000612e:	c0 c1       	brne	80006146 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006130:	d7 33       	scall
80006132:	c0 a8       	rjmp	80006146 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006134:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006136:	6e 98       	ld.w	r8,r7[0x24]
80006138:	58 08       	cp.w	r8,0
8000613a:	c0 60       	breq	80006146 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000613c:	04 9c       	mov	r12,r2
8000613e:	f0 1f 00 2e 	mcall	800061f4 <xQueueGenericReceive+0x120>
80006142:	c0 20       	breq	80006146 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006144:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006146:	f0 1f 00 2d 	mcall	800061f8 <xQueueGenericReceive+0x124>
8000614a:	30 1c       	mov	r12,1
				return pdPASS;
8000614c:	c4 c8       	rjmp	800061e4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000614e:	40 28       	lddsp	r8,sp[0x8]
80006150:	58 08       	cp.w	r8,0
80006152:	c0 51       	brne	8000615c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006154:	f0 1f 00 29 	mcall	800061f8 <xQueueGenericReceive+0x124>
80006158:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000615a:	c4 58       	rjmp	800061e4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000615c:	58 05       	cp.w	r5,0
8000615e:	c0 51       	brne	80006168 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006160:	08 9c       	mov	r12,r4
80006162:	f0 1f 00 27 	mcall	800061fc <xQueueGenericReceive+0x128>
80006166:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006168:	f0 1f 00 24 	mcall	800061f8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000616c:	f0 1f 00 25 	mcall	80006200 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006170:	f0 1f 00 1e 	mcall	800061e8 <xQueueGenericReceive+0x114>
80006174:	6f 18       	ld.w	r8,r7[0x44]
80006176:	5b f8       	cp.w	r8,-1
80006178:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000617c:	6f 28       	ld.w	r8,r7[0x48]
8000617e:	5b f8       	cp.w	r8,-1
80006180:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006184:	f0 1f 00 1d 	mcall	800061f8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006188:	06 9b       	mov	r11,r3
8000618a:	08 9c       	mov	r12,r4
8000618c:	f0 1f 00 1e 	mcall	80006204 <xQueueGenericReceive+0x130>
80006190:	c2 41       	brne	800061d8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006192:	f0 1f 00 16 	mcall	800061e8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006196:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006198:	f0 1f 00 18 	mcall	800061f8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000619c:	58 06       	cp.w	r6,0
8000619e:	c1 71       	brne	800061cc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061a0:	6e 08       	ld.w	r8,r7[0x0]
800061a2:	58 08       	cp.w	r8,0
800061a4:	c0 81       	brne	800061b4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800061a6:	f0 1f 00 11 	mcall	800061e8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800061aa:	6e 1c       	ld.w	r12,r7[0x4]
800061ac:	f0 1f 00 17 	mcall	80006208 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800061b0:	f0 1f 00 12 	mcall	800061f8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800061b4:	40 2b       	lddsp	r11,sp[0x8]
800061b6:	04 9c       	mov	r12,r2
800061b8:	f0 1f 00 15 	mcall	8000620c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800061bc:	0e 9c       	mov	r12,r7
800061be:	f0 1f 00 15 	mcall	80006210 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800061c2:	f0 1f 00 15 	mcall	80006214 <xQueueGenericReceive+0x140>
800061c6:	c9 61       	brne	800060f2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800061c8:	d7 33       	scall
800061ca:	c9 4b       	rjmp	800060f2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800061cc:	0e 9c       	mov	r12,r7
800061ce:	f0 1f 00 11 	mcall	80006210 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800061d2:	f0 1f 00 11 	mcall	80006214 <xQueueGenericReceive+0x140>
800061d6:	c8 eb       	rjmp	800060f2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800061d8:	0e 9c       	mov	r12,r7
800061da:	f0 1f 00 0e 	mcall	80006210 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800061de:	f0 1f 00 0e 	mcall	80006214 <xQueueGenericReceive+0x140>
800061e2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800061e4:	2f bd       	sub	sp,-20
800061e6:	d8 32       	popm	r0-r7,pc
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	5d 20       	mustr	r0
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	5f b4       	srhi	r4
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	65 74       	ld.w	r4,r2[0x5c]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	66 5c       	ld.w	r12,r3[0x14]
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	5e 2c       	reths	r12
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	65 50       	ld.w	r0,r2[0x54]
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	64 c4       	ld.w	r4,r2[0x30]
80006204:	80 00       	ld.sh	r0,r0[0x0]
80006206:	67 ec       	ld.w	r12,r3[0x78]
80006208:	80 00       	ld.sh	r0,r0[0x0]
8000620a:	65 d8       	ld.w	r8,r2[0x74]
8000620c:	80 00       	ld.sh	r0,r0[0x0]
8000620e:	6a 8c       	ld.w	r12,r5[0x20]
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	60 34       	ld.w	r4,r0[0xc]
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	68 80       	ld.w	r0,r4[0x20]

80006218 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006218:	eb cd 40 80 	pushm	r7,lr
8000621c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000621e:	79 08       	ld.w	r8,r12[0x40]
80006220:	58 08       	cp.w	r8,0
80006222:	c0 a1       	brne	80006236 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006224:	78 08       	ld.w	r8,r12[0x0]
80006226:	58 08       	cp.w	r8,0
80006228:	c2 b1       	brne	8000627e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000622a:	78 1c       	ld.w	r12,r12[0x4]
8000622c:	f0 1f 00 17 	mcall	80006288 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006230:	30 08       	mov	r8,0
80006232:	8f 18       	st.w	r7[0x4],r8
80006234:	c2 58       	rjmp	8000627e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006236:	58 0a       	cp.w	r10,0
80006238:	c1 01       	brne	80006258 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000623a:	10 9a       	mov	r10,r8
8000623c:	78 2c       	ld.w	r12,r12[0x8]
8000623e:	f0 1f 00 14 	mcall	8000628c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006242:	6e 29       	ld.w	r9,r7[0x8]
80006244:	6f 08       	ld.w	r8,r7[0x40]
80006246:	f2 08 00 08 	add	r8,r9,r8
8000624a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000624c:	6e 19       	ld.w	r9,r7[0x4]
8000624e:	12 38       	cp.w	r8,r9
80006250:	c1 73       	brcs	8000627e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006252:	6e 08       	ld.w	r8,r7[0x0]
80006254:	8f 28       	st.w	r7[0x8],r8
80006256:	c1 48       	rjmp	8000627e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006258:	10 9a       	mov	r10,r8
8000625a:	78 3c       	ld.w	r12,r12[0xc]
8000625c:	f0 1f 00 0c 	mcall	8000628c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006260:	6f 08       	ld.w	r8,r7[0x40]
80006262:	6e 39       	ld.w	r9,r7[0xc]
80006264:	f2 08 01 08 	sub	r8,r9,r8
80006268:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000626a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000626c:	12 38       	cp.w	r8,r9
8000626e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006272:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006276:	f3 d8 e3 19 	subcs	r9,r9,r8
8000627a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000627e:	6e e8       	ld.w	r8,r7[0x38]
80006280:	2f f8       	sub	r8,-1
80006282:	8f e8       	st.w	r7[0x38],r8
}
80006284:	e3 cd 80 80 	ldm	sp++,r7,pc
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	65 80       	ld.w	r0,r2[0x60]
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	77 ac       	ld.w	r12,r11[0x68]

80006290 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006290:	eb cd 40 c0 	pushm	r6-r7,lr
80006294:	18 97       	mov	r7,r12
80006296:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006298:	78 ec       	ld.w	r12,r12[0x38]
8000629a:	6e f8       	ld.w	r8,r7[0x3c]
8000629c:	10 3c       	cp.w	r12,r8
8000629e:	c0 33       	brcs	800062a4 <xQueueGenericSendFromISR+0x14>
800062a0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800062a4:	12 9a       	mov	r10,r9
800062a6:	0e 9c       	mov	r12,r7
800062a8:	f0 1f 00 0c 	mcall	800062d8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800062ac:	6f 28       	ld.w	r8,r7[0x48]
800062ae:	5b f8       	cp.w	r8,-1
800062b0:	c0 d1       	brne	800062ca <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800062b2:	6e 98       	ld.w	r8,r7[0x24]
800062b4:	58 08       	cp.w	r8,0
800062b6:	c0 f0       	breq	800062d4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800062b8:	ee cc ff dc 	sub	r12,r7,-36
800062bc:	f0 1f 00 08 	mcall	800062dc <xQueueGenericSendFromISR+0x4c>
800062c0:	c0 a0       	breq	800062d4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800062c2:	30 1c       	mov	r12,1
800062c4:	8d 0c       	st.w	r6[0x0],r12
800062c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800062ca:	2f f8       	sub	r8,-1
800062cc:	ef 48 00 48 	st.w	r7[72],r8
800062d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800062d4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	62 18       	ld.w	r8,r1[0x4]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	66 5c       	ld.w	r12,r3[0x14]

800062e0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800062e0:	d4 31       	pushm	r0-r7,lr
800062e2:	20 5d       	sub	sp,20
800062e4:	18 97       	mov	r7,r12
800062e6:	50 0b       	stdsp	sp[0x0],r11
800062e8:	50 2a       	stdsp	sp[0x8],r10
800062ea:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800062ec:	f8 c0 ff f0 	sub	r0,r12,-16
800062f0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062f2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800062f6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062f8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800062fc:	f0 1f 00 2f 	mcall	800063b8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006300:	6e e9       	ld.w	r9,r7[0x38]
80006302:	6e f8       	ld.w	r8,r7[0x3c]
80006304:	10 39       	cp.w	r9,r8
80006306:	c1 42       	brcc	8000632e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006308:	40 1a       	lddsp	r10,sp[0x4]
8000630a:	40 0b       	lddsp	r11,sp[0x0]
8000630c:	0e 9c       	mov	r12,r7
8000630e:	f0 1f 00 2c 	mcall	800063bc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006312:	6e 98       	ld.w	r8,r7[0x24]
80006314:	58 08       	cp.w	r8,0
80006316:	c0 80       	breq	80006326 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006318:	ee cc ff dc 	sub	r12,r7,-36
8000631c:	f0 1f 00 29 	mcall	800063c0 <xQueueGenericSend+0xe0>
80006320:	58 1c       	cp.w	r12,1
80006322:	c0 21       	brne	80006326 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006324:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006326:	f0 1f 00 28 	mcall	800063c4 <xQueueGenericSend+0xe4>
8000632a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000632c:	c4 38       	rjmp	800063b2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000632e:	40 28       	lddsp	r8,sp[0x8]
80006330:	58 08       	cp.w	r8,0
80006332:	c0 51       	brne	8000633c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006334:	f0 1f 00 24 	mcall	800063c4 <xQueueGenericSend+0xe4>
80006338:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000633a:	c3 c8       	rjmp	800063b2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000633c:	58 04       	cp.w	r4,0
8000633e:	c0 51       	brne	80006348 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006340:	06 9c       	mov	r12,r3
80006342:	f0 1f 00 22 	mcall	800063c8 <xQueueGenericSend+0xe8>
80006346:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006348:	f0 1f 00 1f 	mcall	800063c4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000634c:	f0 1f 00 20 	mcall	800063cc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006350:	f0 1f 00 1a 	mcall	800063b8 <xQueueGenericSend+0xd8>
80006354:	6f 18       	ld.w	r8,r7[0x44]
80006356:	5b f8       	cp.w	r8,-1
80006358:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000635c:	6f 28       	ld.w	r8,r7[0x48]
8000635e:	5b f8       	cp.w	r8,-1
80006360:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006364:	f0 1f 00 18 	mcall	800063c4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006368:	04 9b       	mov	r11,r2
8000636a:	06 9c       	mov	r12,r3
8000636c:	f0 1f 00 19 	mcall	800063d0 <xQueueGenericSend+0xf0>
80006370:	c1 b1       	brne	800063a6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006372:	f0 1f 00 12 	mcall	800063b8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006376:	6e e5       	ld.w	r5,r7[0x38]
80006378:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000637a:	f0 1f 00 13 	mcall	800063c4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000637e:	0c 35       	cp.w	r5,r6
80006380:	c0 d1       	brne	8000639a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006382:	40 2b       	lddsp	r11,sp[0x8]
80006384:	00 9c       	mov	r12,r0
80006386:	f0 1f 00 14 	mcall	800063d4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000638a:	0e 9c       	mov	r12,r7
8000638c:	f0 1f 00 13 	mcall	800063d8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006390:	f0 1f 00 13 	mcall	800063dc <xQueueGenericSend+0xfc>
80006394:	cb 41       	brne	800062fc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006396:	d7 33       	scall
80006398:	cb 2b       	rjmp	800062fc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000639a:	0e 9c       	mov	r12,r7
8000639c:	f0 1f 00 0f 	mcall	800063d8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800063a0:	f0 1f 00 0f 	mcall	800063dc <xQueueGenericSend+0xfc>
800063a4:	ca cb       	rjmp	800062fc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800063a6:	0e 9c       	mov	r12,r7
800063a8:	f0 1f 00 0c 	mcall	800063d8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800063ac:	f0 1f 00 0c 	mcall	800063dc <xQueueGenericSend+0xfc>
800063b0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800063b2:	2f bd       	sub	sp,-20
800063b4:	d8 32       	popm	r0-r7,pc
800063b6:	00 00       	add	r0,r0
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	5d 20       	mustr	r0
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	62 18       	ld.w	r8,r1[0x4]
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	66 5c       	ld.w	r12,r3[0x14]
800063c4:	80 00       	ld.sh	r0,r0[0x0]
800063c6:	5e 2c       	reths	r12
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	65 50       	ld.w	r0,r2[0x54]
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	64 c4       	ld.w	r4,r2[0x30]
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	67 ec       	ld.w	r12,r3[0x78]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	6a 8c       	ld.w	r12,r5[0x20]
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	60 34       	ld.w	r4,r0[0xc]
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	68 80       	ld.w	r0,r4[0x20]

800063e0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800063e0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800063e4:	34 cc       	mov	r12,76
800063e6:	f0 1f 00 12 	mcall	8000642c <xQueueCreateMutex+0x4c>
800063ea:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800063ec:	c1 d0       	breq	80006426 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800063ee:	30 06       	mov	r6,0
800063f0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800063f2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800063f4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800063f6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800063f8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800063fa:	30 18       	mov	r8,1
800063fc:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800063fe:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006402:	3f f8       	mov	r8,-1
80006404:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006408:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000640c:	2f 0c       	sub	r12,-16
8000640e:	f0 1f 00 09 	mcall	80006430 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006412:	ee cc ff dc 	sub	r12,r7,-36
80006416:	f0 1f 00 07 	mcall	80006430 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000641a:	0c 99       	mov	r9,r6
8000641c:	0c 9a       	mov	r10,r6
8000641e:	0c 9b       	mov	r11,r6
80006420:	0e 9c       	mov	r12,r7
80006422:	f0 1f 00 05 	mcall	80006434 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006426:	0e 9c       	mov	r12,r7
80006428:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	5f 8c       	srls	r12
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	5b fc       	cp.w	r12,-1
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	62 e0       	ld.w	r0,r1[0x38]

80006438 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006438:	d4 21       	pushm	r4-r7,lr
8000643a:	18 97       	mov	r7,r12
8000643c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000643e:	58 0c       	cp.w	r12,0
80006440:	c2 f0       	breq	8000649e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006442:	34 cc       	mov	r12,76
80006444:	f0 1f 00 17 	mcall	800064a0 <xQueueCreate+0x68>
80006448:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000644a:	c2 a0       	breq	8000649e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000644c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006450:	e8 cc ff ff 	sub	r12,r4,-1
80006454:	f0 1f 00 13 	mcall	800064a0 <xQueueCreate+0x68>
80006458:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000645a:	c1 e0       	breq	80006496 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000645c:	f8 04 00 04 	add	r4,r12,r4
80006460:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006462:	30 08       	mov	r8,0
80006464:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006466:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006468:	ee c8 00 01 	sub	r8,r7,1
8000646c:	ad 38       	mul	r8,r6
8000646e:	10 0c       	add	r12,r8
80006470:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006472:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006474:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006478:	3f f8       	mov	r8,-1
8000647a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000647e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006482:	ea cc ff f0 	sub	r12,r5,-16
80006486:	f0 1f 00 08 	mcall	800064a4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000648a:	ea cc ff dc 	sub	r12,r5,-36
8000648e:	f0 1f 00 06 	mcall	800064a4 <xQueueCreate+0x6c>
80006492:	0a 9c       	mov	r12,r5
80006494:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006496:	0a 9c       	mov	r12,r5
80006498:	f0 1f 00 04 	mcall	800064a8 <xQueueCreate+0x70>
8000649c:	d8 2a       	popm	r4-r7,pc,r12=0
8000649e:	d8 2a       	popm	r4-r7,pc,r12=0
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	5f 8c       	srls	r12
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	5b fc       	cp.w	r12,-1
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	5f 64       	srmi	r4

800064ac <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
800064ac:	eb cd 40 80 	pushm	r7,lr
800064b0:	16 97       	mov	r7,r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800064b2:	30 0b       	mov	r11,0
800064b4:	f0 1f 00 03 	mcall	800064c0 <xQueueCreateCountingSemaphore+0x14>

		if( pxHandle != NULL )
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800064b8:	f9 f7 1a 0e 	st.wne	r12[0x38],r7
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
800064bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	64 38       	ld.w	r8,r2[0xc]

800064c4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800064c4:	48 38       	lddpc	r8,800064d0 <vTaskSuspendAll+0xc>
800064c6:	70 09       	ld.w	r9,r8[0x0]
800064c8:	2f f9       	sub	r9,-1
800064ca:	91 09       	st.w	r8[0x0],r9
}
800064cc:	5e fc       	retal	r12
800064ce:	00 00       	add	r0,r0
800064d0:	00 00       	add	r0,r0
800064d2:	0d 28       	ld.uh	r8,r6++

800064d4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800064d4:	49 a8       	lddpc	r8,8000653c <vTaskSwitchContext+0x68>
800064d6:	70 08       	ld.w	r8,r8[0x0]
800064d8:	58 08       	cp.w	r8,0
800064da:	c0 b1       	brne	800064f0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800064dc:	49 98       	lddpc	r8,80006540 <vTaskSwitchContext+0x6c>
800064de:	70 08       	ld.w	r8,r8[0x0]
800064e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800064e4:	49 89       	lddpc	r9,80006544 <vTaskSwitchContext+0x70>
800064e6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800064ea:	58 08       	cp.w	r8,0
800064ec:	c0 60       	breq	800064f8 <vTaskSwitchContext+0x24>
800064ee:	c1 18       	rjmp	80006510 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800064f0:	30 19       	mov	r9,1
800064f2:	49 68       	lddpc	r8,80006548 <vTaskSwitchContext+0x74>
800064f4:	91 09       	st.w	r8[0x0],r9
800064f6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800064f8:	49 28       	lddpc	r8,80006540 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800064fa:	49 3a       	lddpc	r10,80006544 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800064fc:	70 09       	ld.w	r9,r8[0x0]
800064fe:	20 19       	sub	r9,1
80006500:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006502:	70 09       	ld.w	r9,r8[0x0]
80006504:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006508:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000650c:	58 09       	cp.w	r9,0
8000650e:	cf 70       	breq	800064fc <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006510:	48 c8       	lddpc	r8,80006540 <vTaskSwitchContext+0x6c>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006518:	48 b9       	lddpc	r9,80006544 <vTaskSwitchContext+0x70>
8000651a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000651e:	70 19       	ld.w	r9,r8[0x4]
80006520:	72 19       	ld.w	r9,r9[0x4]
80006522:	91 19       	st.w	r8[0x4],r9
80006524:	f0 ca ff f8 	sub	r10,r8,-8
80006528:	14 39       	cp.w	r9,r10
8000652a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000652e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006532:	70 18       	ld.w	r8,r8[0x4]
80006534:	70 39       	ld.w	r9,r8[0xc]
80006536:	48 68       	lddpc	r8,8000654c <vTaskSwitchContext+0x78>
80006538:	91 09       	st.w	r8[0x0],r9
8000653a:	5e fc       	retal	r12
8000653c:	00 00       	add	r0,r0
8000653e:	0d 28       	ld.uh	r8,r6++
80006540:	00 00       	add	r0,r0
80006542:	0d 60       	ld.uh	r0,--r6
80006544:	00 00       	add	r0,r0
80006546:	0c 44       	or	r4,r6
80006548:	00 00       	add	r0,r0
8000654a:	0d 48       	ld.w	r8,--r6
8000654c:	00 00       	add	r0,r0
8000654e:	0c f8       	st.b	--r6,r8

80006550 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006550:	48 48       	lddpc	r8,80006560 <vTaskSetTimeOutState+0x10>
80006552:	70 08       	ld.w	r8,r8[0x0]
80006554:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006556:	48 48       	lddpc	r8,80006564 <vTaskSetTimeOutState+0x14>
80006558:	70 08       	ld.w	r8,r8[0x0]
8000655a:	99 18       	st.w	r12[0x4],r8
}
8000655c:	5e fc       	retal	r12
8000655e:	00 00       	add	r0,r0
80006560:	00 00       	add	r0,r0
80006562:	0c 3c       	cp.w	r12,r6
80006564:	00 00       	add	r0,r0
80006566:	0d 24       	ld.uh	r4,r6++

80006568 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006568:	30 19       	mov	r9,1
8000656a:	48 28       	lddpc	r8,80006570 <vTaskMissedYield+0x8>
8000656c:	91 09       	st.w	r8[0x0],r9
}
8000656e:	5e fc       	retal	r12
80006570:	00 00       	add	r0,r0
80006572:	0d 48       	ld.w	r8,--r6

80006574 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006574:	48 28       	lddpc	r8,8000657c <xTaskGetCurrentTaskHandle+0x8>
80006576:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006578:	5e fc       	retal	r12
8000657a:	00 00       	add	r0,r0
8000657c:	00 00       	add	r0,r0
8000657e:	0c f8       	st.b	--r6,r8

80006580 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006580:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006584:	58 0c       	cp.w	r12,0
80006586:	c1 f0       	breq	800065c4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006588:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000658a:	78 b9       	ld.w	r9,r12[0x2c]
8000658c:	79 18       	ld.w	r8,r12[0x44]
8000658e:	10 39       	cp.w	r9,r8
80006590:	c1 a0       	breq	800065c4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006592:	f8 c6 ff fc 	sub	r6,r12,-4
80006596:	0c 9c       	mov	r12,r6
80006598:	f0 1f 00 0c 	mcall	800065c8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000659c:	6f 1c       	ld.w	r12,r7[0x44]
8000659e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800065a0:	f8 08 11 08 	rsub	r8,r12,8
800065a4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800065a6:	48 a8       	lddpc	r8,800065cc <vTaskPriorityDisinherit+0x4c>
800065a8:	70 08       	ld.w	r8,r8[0x0]
800065aa:	10 3c       	cp.w	r12,r8
800065ac:	e0 88 00 04 	brls	800065b4 <vTaskPriorityDisinherit+0x34>
800065b0:	48 78       	lddpc	r8,800065cc <vTaskPriorityDisinherit+0x4c>
800065b2:	91 0c       	st.w	r8[0x0],r12
800065b4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065b8:	0c 9b       	mov	r11,r6
800065ba:	48 68       	lddpc	r8,800065d0 <vTaskPriorityDisinherit+0x50>
800065bc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800065c0:	f0 1f 00 05 	mcall	800065d4 <vTaskPriorityDisinherit+0x54>
800065c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	5c 66       	casts.b	r6
800065cc:	00 00       	add	r0,r0
800065ce:	0d 60       	ld.uh	r0,--r6
800065d0:	00 00       	add	r0,r0
800065d2:	0c 44       	or	r4,r6
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5c 16       	scr	r6

800065d8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800065d8:	eb cd 40 c0 	pushm	r6-r7,lr
800065dc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800065de:	49 b8       	lddpc	r8,80006648 <vTaskPriorityInherit+0x70>
800065e0:	70 08       	ld.w	r8,r8[0x0]
800065e2:	78 b9       	ld.w	r9,r12[0x2c]
800065e4:	70 b8       	ld.w	r8,r8[0x2c]
800065e6:	10 39       	cp.w	r9,r8
800065e8:	c2 d2       	brcc	80006642 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800065ea:	49 88       	lddpc	r8,80006648 <vTaskPriorityInherit+0x70>
800065ec:	70 08       	ld.w	r8,r8[0x0]
800065ee:	70 b8       	ld.w	r8,r8[0x2c]
800065f0:	f0 08 11 08 	rsub	r8,r8,8
800065f4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800065f6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800065fa:	49 59       	lddpc	r9,8000664c <vTaskPriorityInherit+0x74>
800065fc:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006600:	78 59       	ld.w	r9,r12[0x14]
80006602:	10 39       	cp.w	r9,r8
80006604:	c1 b1       	brne	8000663a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006606:	f8 c6 ff fc 	sub	r6,r12,-4
8000660a:	0c 9c       	mov	r12,r6
8000660c:	f0 1f 00 11 	mcall	80006650 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006610:	48 e8       	lddpc	r8,80006648 <vTaskPriorityInherit+0x70>
80006612:	70 08       	ld.w	r8,r8[0x0]
80006614:	70 bc       	ld.w	r12,r8[0x2c]
80006616:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006618:	48 f8       	lddpc	r8,80006654 <vTaskPriorityInherit+0x7c>
8000661a:	70 08       	ld.w	r8,r8[0x0]
8000661c:	10 3c       	cp.w	r12,r8
8000661e:	e0 88 00 04 	brls	80006626 <vTaskPriorityInherit+0x4e>
80006622:	48 d8       	lddpc	r8,80006654 <vTaskPriorityInherit+0x7c>
80006624:	91 0c       	st.w	r8[0x0],r12
80006626:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000662a:	0c 9b       	mov	r11,r6
8000662c:	48 88       	lddpc	r8,8000664c <vTaskPriorityInherit+0x74>
8000662e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006632:	f0 1f 00 0a 	mcall	80006658 <vTaskPriorityInherit+0x80>
80006636:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000663a:	48 48       	lddpc	r8,80006648 <vTaskPriorityInherit+0x70>
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	70 b8       	ld.w	r8,r8[0x2c]
80006640:	99 b8       	st.w	r12[0x2c],r8
80006642:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006646:	00 00       	add	r0,r0
80006648:	00 00       	add	r0,r0
8000664a:	0c f8       	st.b	--r6,r8
8000664c:	00 00       	add	r0,r0
8000664e:	0c 44       	or	r4,r6
80006650:	80 00       	ld.sh	r0,r0[0x0]
80006652:	5c 66       	casts.b	r6
80006654:	00 00       	add	r0,r0
80006656:	0d 60       	ld.uh	r0,--r6
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	5c 16       	scr	r6

8000665c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000665c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006660:	78 38       	ld.w	r8,r12[0xc]
80006662:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006664:	ee c6 ff e8 	sub	r6,r7,-24
80006668:	0c 9c       	mov	r12,r6
8000666a:	f0 1f 00 15 	mcall	800066bc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000666e:	49 58       	lddpc	r8,800066c0 <xTaskRemoveFromEventList+0x64>
80006670:	70 08       	ld.w	r8,r8[0x0]
80006672:	58 08       	cp.w	r8,0
80006674:	c1 71       	brne	800066a2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006676:	ee c6 ff fc 	sub	r6,r7,-4
8000667a:	0c 9c       	mov	r12,r6
8000667c:	f0 1f 00 10 	mcall	800066bc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006680:	6e bc       	ld.w	r12,r7[0x2c]
80006682:	49 18       	lddpc	r8,800066c4 <xTaskRemoveFromEventList+0x68>
80006684:	70 08       	ld.w	r8,r8[0x0]
80006686:	10 3c       	cp.w	r12,r8
80006688:	e0 88 00 04 	brls	80006690 <xTaskRemoveFromEventList+0x34>
8000668c:	48 e8       	lddpc	r8,800066c4 <xTaskRemoveFromEventList+0x68>
8000668e:	91 0c       	st.w	r8[0x0],r12
80006690:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006694:	0c 9b       	mov	r11,r6
80006696:	48 d8       	lddpc	r8,800066c8 <xTaskRemoveFromEventList+0x6c>
80006698:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000669c:	f0 1f 00 0c 	mcall	800066cc <xTaskRemoveFromEventList+0x70>
800066a0:	c0 58       	rjmp	800066aa <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800066a2:	0c 9b       	mov	r11,r6
800066a4:	48 bc       	lddpc	r12,800066d0 <xTaskRemoveFromEventList+0x74>
800066a6:	f0 1f 00 0a 	mcall	800066cc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066aa:	48 b8       	lddpc	r8,800066d4 <xTaskRemoveFromEventList+0x78>
800066ac:	70 08       	ld.w	r8,r8[0x0]
800066ae:	6e b9       	ld.w	r9,r7[0x2c]
800066b0:	70 b8       	ld.w	r8,r8[0x2c]
800066b2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800066b4:	5f 2c       	srhs	r12
800066b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066ba:	00 00       	add	r0,r0
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	5c 66       	casts.b	r6
800066c0:	00 00       	add	r0,r0
800066c2:	0d 28       	ld.uh	r8,r6++
800066c4:	00 00       	add	r0,r0
800066c6:	0d 60       	ld.uh	r0,--r6
800066c8:	00 00       	add	r0,r0
800066ca:	0c 44       	or	r4,r6
800066cc:	80 00       	ld.sh	r0,r0[0x0]
800066ce:	5c 16       	scr	r6
800066d0:	00 00       	add	r0,r0
800066d2:	0c fc       	st.b	--r6,r12
800066d4:	00 00       	add	r0,r0
800066d6:	0c f8       	st.b	--r6,r8

800066d8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800066d8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800066dc:	4b 98       	lddpc	r8,800067c0 <vTaskIncrementTick+0xe8>
800066de:	70 08       	ld.w	r8,r8[0x0]
800066e0:	58 08       	cp.w	r8,0
800066e2:	c6 91       	brne	800067b4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800066e4:	4b 88       	lddpc	r8,800067c4 <vTaskIncrementTick+0xec>
800066e6:	70 09       	ld.w	r9,r8[0x0]
800066e8:	2f f9       	sub	r9,-1
800066ea:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800066ec:	70 08       	ld.w	r8,r8[0x0]
800066ee:	58 08       	cp.w	r8,0
800066f0:	c1 a1       	brne	80006724 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800066f2:	4b 68       	lddpc	r8,800067c8 <vTaskIncrementTick+0xf0>
800066f4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800066f6:	4b 69       	lddpc	r9,800067cc <vTaskIncrementTick+0xf4>
800066f8:	72 0b       	ld.w	r11,r9[0x0]
800066fa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800066fc:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800066fe:	4b 59       	lddpc	r9,800067d0 <vTaskIncrementTick+0xf8>
80006700:	72 0a       	ld.w	r10,r9[0x0]
80006702:	2f fa       	sub	r10,-1
80006704:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006706:	70 08       	ld.w	r8,r8[0x0]
80006708:	70 08       	ld.w	r8,r8[0x0]
8000670a:	58 08       	cp.w	r8,0
8000670c:	c0 51       	brne	80006716 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000670e:	3f f9       	mov	r9,-1
80006710:	4b 18       	lddpc	r8,800067d4 <vTaskIncrementTick+0xfc>
80006712:	91 09       	st.w	r8[0x0],r9
80006714:	c0 88       	rjmp	80006724 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006716:	4a d8       	lddpc	r8,800067c8 <vTaskIncrementTick+0xf0>
80006718:	70 08       	ld.w	r8,r8[0x0]
8000671a:	70 38       	ld.w	r8,r8[0xc]
8000671c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000671e:	70 19       	ld.w	r9,r8[0x4]
80006720:	4a d8       	lddpc	r8,800067d4 <vTaskIncrementTick+0xfc>
80006722:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006724:	4a 88       	lddpc	r8,800067c4 <vTaskIncrementTick+0xec>
80006726:	70 09       	ld.w	r9,r8[0x0]
80006728:	4a b8       	lddpc	r8,800067d4 <vTaskIncrementTick+0xfc>
8000672a:	70 08       	ld.w	r8,r8[0x0]
8000672c:	10 39       	cp.w	r9,r8
8000672e:	c4 73       	brcs	800067bc <vTaskIncrementTick+0xe4>
80006730:	4a 68       	lddpc	r8,800067c8 <vTaskIncrementTick+0xf0>
80006732:	70 08       	ld.w	r8,r8[0x0]
80006734:	70 08       	ld.w	r8,r8[0x0]
80006736:	58 08       	cp.w	r8,0
80006738:	c0 c0       	breq	80006750 <vTaskIncrementTick+0x78>
8000673a:	4a 48       	lddpc	r8,800067c8 <vTaskIncrementTick+0xf0>
8000673c:	70 08       	ld.w	r8,r8[0x0]
8000673e:	70 38       	ld.w	r8,r8[0xc]
80006740:	70 37       	ld.w	r7,r8[0xc]
80006742:	6e 18       	ld.w	r8,r7[0x4]
80006744:	4a 09       	lddpc	r9,800067c4 <vTaskIncrementTick+0xec>
80006746:	72 09       	ld.w	r9,r9[0x0]
80006748:	12 38       	cp.w	r8,r9
8000674a:	e0 88 00 14 	brls	80006772 <vTaskIncrementTick+0x9a>
8000674e:	c0 e8       	rjmp	8000676a <vTaskIncrementTick+0x92>
80006750:	3f f9       	mov	r9,-1
80006752:	4a 18       	lddpc	r8,800067d4 <vTaskIncrementTick+0xfc>
80006754:	91 09       	st.w	r8[0x0],r9
80006756:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000675a:	6a 08       	ld.w	r8,r5[0x0]
8000675c:	70 38       	ld.w	r8,r8[0xc]
8000675e:	70 37       	ld.w	r7,r8[0xc]
80006760:	6e 18       	ld.w	r8,r7[0x4]
80006762:	64 09       	ld.w	r9,r2[0x0]
80006764:	12 38       	cp.w	r8,r9
80006766:	e0 88 00 0a 	brls	8000677a <vTaskIncrementTick+0xa2>
8000676a:	49 b9       	lddpc	r9,800067d4 <vTaskIncrementTick+0xfc>
8000676c:	93 08       	st.w	r9[0x0],r8
8000676e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006772:	49 a4       	lddpc	r4,800067d8 <vTaskIncrementTick+0x100>
80006774:	49 a3       	lddpc	r3,800067dc <vTaskIncrementTick+0x104>
80006776:	49 55       	lddpc	r5,800067c8 <vTaskIncrementTick+0xf0>
80006778:	49 32       	lddpc	r2,800067c4 <vTaskIncrementTick+0xec>
8000677a:	ee c6 ff fc 	sub	r6,r7,-4
8000677e:	0c 9c       	mov	r12,r6
80006780:	f0 1f 00 18 	mcall	800067e0 <vTaskIncrementTick+0x108>
80006784:	6e a8       	ld.w	r8,r7[0x28]
80006786:	58 08       	cp.w	r8,0
80006788:	c0 50       	breq	80006792 <vTaskIncrementTick+0xba>
8000678a:	ee cc ff e8 	sub	r12,r7,-24
8000678e:	f0 1f 00 15 	mcall	800067e0 <vTaskIncrementTick+0x108>
80006792:	6e bc       	ld.w	r12,r7[0x2c]
80006794:	68 08       	ld.w	r8,r4[0x0]
80006796:	10 3c       	cp.w	r12,r8
80006798:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000679c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067a0:	0c 9b       	mov	r11,r6
800067a2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800067a6:	f0 1f 00 10 	mcall	800067e4 <vTaskIncrementTick+0x10c>
800067aa:	6a 08       	ld.w	r8,r5[0x0]
800067ac:	70 08       	ld.w	r8,r8[0x0]
800067ae:	58 08       	cp.w	r8,0
800067b0:	cd 51       	brne	8000675a <vTaskIncrementTick+0x82>
800067b2:	cc fb       	rjmp	80006750 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800067b4:	48 d8       	lddpc	r8,800067e8 <vTaskIncrementTick+0x110>
800067b6:	70 09       	ld.w	r9,r8[0x0]
800067b8:	2f f9       	sub	r9,-1
800067ba:	91 09       	st.w	r8[0x0],r9
800067bc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067c0:	00 00       	add	r0,r0
800067c2:	0d 28       	ld.uh	r8,r6++
800067c4:	00 00       	add	r0,r0
800067c6:	0d 24       	ld.uh	r4,r6++
800067c8:	00 00       	add	r0,r0
800067ca:	0c 30       	cp.w	r0,r6
800067cc:	00 00       	add	r0,r0
800067ce:	0c 40       	or	r0,r6
800067d0:	00 00       	add	r0,r0
800067d2:	0c 3c       	cp.w	r12,r6
800067d4:	00 00       	add	r0,r0
800067d6:	05 38       	ld.ub	r8,r2++
800067d8:	00 00       	add	r0,r0
800067da:	0d 60       	ld.uh	r0,--r6
800067dc:	00 00       	add	r0,r0
800067de:	0c 44       	or	r4,r6
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	5c 66       	casts.b	r6
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5c 16       	scr	r6
800067e8:	00 00       	add	r0,r0
800067ea:	0c 28       	rsub	r8,r6

800067ec <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800067ec:	eb cd 40 c0 	pushm	r6-r7,lr
800067f0:	18 97       	mov	r7,r12
800067f2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800067f4:	f0 1f 00 15 	mcall	80006848 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800067f8:	6c 08       	ld.w	r8,r6[0x0]
800067fa:	5b f8       	cp.w	r8,-1
800067fc:	c0 31       	brne	80006802 <xTaskCheckForTimeOut+0x16>
800067fe:	30 07       	mov	r7,0
80006800:	c1 f8       	rjmp	8000683e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006802:	49 39       	lddpc	r9,8000684c <xTaskCheckForTimeOut+0x60>
80006804:	72 09       	ld.w	r9,r9[0x0]
80006806:	6e 0a       	ld.w	r10,r7[0x0]
80006808:	12 3a       	cp.w	r10,r9
8000680a:	c0 70       	breq	80006818 <xTaskCheckForTimeOut+0x2c>
8000680c:	49 19       	lddpc	r9,80006850 <xTaskCheckForTimeOut+0x64>
8000680e:	72 09       	ld.w	r9,r9[0x0]
80006810:	6e 1a       	ld.w	r10,r7[0x4]
80006812:	12 3a       	cp.w	r10,r9
80006814:	e0 88 00 14 	brls	8000683c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006818:	48 e9       	lddpc	r9,80006850 <xTaskCheckForTimeOut+0x64>
8000681a:	72 0a       	ld.w	r10,r9[0x0]
8000681c:	6e 19       	ld.w	r9,r7[0x4]
8000681e:	12 1a       	sub	r10,r9
80006820:	14 38       	cp.w	r8,r10
80006822:	e0 88 00 0d 	brls	8000683c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006826:	48 ba       	lddpc	r10,80006850 <xTaskCheckForTimeOut+0x64>
80006828:	74 0a       	ld.w	r10,r10[0x0]
8000682a:	14 19       	sub	r9,r10
8000682c:	f2 08 00 08 	add	r8,r9,r8
80006830:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006832:	0e 9c       	mov	r12,r7
80006834:	f0 1f 00 08 	mcall	80006854 <xTaskCheckForTimeOut+0x68>
80006838:	30 07       	mov	r7,0
8000683a:	c0 28       	rjmp	8000683e <xTaskCheckForTimeOut+0x52>
8000683c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000683e:	f0 1f 00 07 	mcall	80006858 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006842:	0e 9c       	mov	r12,r7
80006844:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	5d 20       	mustr	r0
8000684c:	00 00       	add	r0,r0
8000684e:	0c 3c       	cp.w	r12,r6
80006850:	00 00       	add	r0,r0
80006852:	0d 24       	ld.uh	r4,r6++
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	65 50       	ld.w	r0,r2[0x54]
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	5e 2c       	reths	r12

8000685c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000685c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006860:	f0 1f 00 05 	mcall	80006874 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006864:	48 58       	lddpc	r8,80006878 <xTaskGetTickCount+0x1c>
80006866:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006868:	f0 1f 00 05 	mcall	8000687c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000686c:	0e 9c       	mov	r12,r7
8000686e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006872:	00 00       	add	r0,r0
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	5d 20       	mustr	r0
80006878:	00 00       	add	r0,r0
8000687a:	0d 24       	ld.uh	r4,r6++
8000687c:	80 00       	ld.sh	r0,r0[0x0]
8000687e:	5e 2c       	reths	r12

80006880 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006880:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006884:	f0 1f 00 2c 	mcall	80006934 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006888:	4a c8       	lddpc	r8,80006938 <xTaskResumeAll+0xb8>
8000688a:	70 09       	ld.w	r9,r8[0x0]
8000688c:	20 19       	sub	r9,1
8000688e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006890:	70 08       	ld.w	r8,r8[0x0]
80006892:	58 08       	cp.w	r8,0
80006894:	c4 91       	brne	80006926 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006896:	4a a8       	lddpc	r8,8000693c <xTaskResumeAll+0xbc>
80006898:	70 08       	ld.w	r8,r8[0x0]
8000689a:	58 08       	cp.w	r8,0
8000689c:	c4 50       	breq	80006926 <xTaskResumeAll+0xa6>
8000689e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800068a0:	4a 85       	lddpc	r5,80006940 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800068a2:	4a 93       	lddpc	r3,80006944 <xTaskResumeAll+0xc4>
800068a4:	4a 92       	lddpc	r2,80006948 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068a6:	4a a1       	lddpc	r1,8000694c <xTaskResumeAll+0xcc>
800068a8:	c1 e8       	rjmp	800068e4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800068aa:	6a 38       	ld.w	r8,r5[0xc]
800068ac:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800068ae:	ee cc ff e8 	sub	r12,r7,-24
800068b2:	f0 1f 00 28 	mcall	80006950 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800068b6:	ee c6 ff fc 	sub	r6,r7,-4
800068ba:	0c 9c       	mov	r12,r6
800068bc:	f0 1f 00 25 	mcall	80006950 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800068c0:	6e bc       	ld.w	r12,r7[0x2c]
800068c2:	66 08       	ld.w	r8,r3[0x0]
800068c4:	10 3c       	cp.w	r12,r8
800068c6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800068ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800068ce:	0c 9b       	mov	r11,r6
800068d0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800068d4:	f0 1f 00 20 	mcall	80006954 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068d8:	62 08       	ld.w	r8,r1[0x0]
800068da:	6e b9       	ld.w	r9,r7[0x2c]
800068dc:	70 b8       	ld.w	r8,r8[0x2c]
800068de:	10 39       	cp.w	r9,r8
800068e0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800068e4:	6a 08       	ld.w	r8,r5[0x0]
800068e6:	58 08       	cp.w	r8,0
800068e8:	ce 11       	brne	800068aa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800068ea:	49 c8       	lddpc	r8,80006958 <xTaskResumeAll+0xd8>
800068ec:	70 08       	ld.w	r8,r8[0x0]
800068ee:	58 08       	cp.w	r8,0
800068f0:	c0 f0       	breq	8000690e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800068f2:	49 a8       	lddpc	r8,80006958 <xTaskResumeAll+0xd8>
800068f4:	70 08       	ld.w	r8,r8[0x0]
800068f6:	58 08       	cp.w	r8,0
800068f8:	c1 10       	breq	8000691a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800068fa:	49 87       	lddpc	r7,80006958 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800068fc:	f0 1f 00 18 	mcall	8000695c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006900:	6e 08       	ld.w	r8,r7[0x0]
80006902:	20 18       	sub	r8,1
80006904:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006906:	6e 08       	ld.w	r8,r7[0x0]
80006908:	58 08       	cp.w	r8,0
8000690a:	cf 91       	brne	800068fc <xTaskResumeAll+0x7c>
8000690c:	c0 78       	rjmp	8000691a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000690e:	58 14       	cp.w	r4,1
80006910:	c0 50       	breq	8000691a <xTaskResumeAll+0x9a>
80006912:	49 48       	lddpc	r8,80006960 <xTaskResumeAll+0xe0>
80006914:	70 08       	ld.w	r8,r8[0x0]
80006916:	58 18       	cp.w	r8,1
80006918:	c0 71       	brne	80006926 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000691a:	30 09       	mov	r9,0
8000691c:	49 18       	lddpc	r8,80006960 <xTaskResumeAll+0xe0>
8000691e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006920:	d7 33       	scall
80006922:	30 17       	mov	r7,1
80006924:	c0 28       	rjmp	80006928 <xTaskResumeAll+0xa8>
80006926:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006928:	f0 1f 00 0f 	mcall	80006964 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000692c:	0e 9c       	mov	r12,r7
8000692e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006932:	00 00       	add	r0,r0
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	5d 20       	mustr	r0
80006938:	00 00       	add	r0,r0
8000693a:	0d 28       	ld.uh	r8,r6++
8000693c:	00 00       	add	r0,r0
8000693e:	0d 44       	ld.w	r4,--r6
80006940:	00 00       	add	r0,r0
80006942:	0c fc       	st.b	--r6,r12
80006944:	00 00       	add	r0,r0
80006946:	0d 60       	ld.uh	r0,--r6
80006948:	00 00       	add	r0,r0
8000694a:	0c 44       	or	r4,r6
8000694c:	00 00       	add	r0,r0
8000694e:	0c f8       	st.b	--r6,r8
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	5c 66       	casts.b	r6
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	5c 16       	scr	r6
80006958:	00 00       	add	r0,r0
8000695a:	0c 28       	rsub	r8,r6
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	66 d8       	ld.w	r8,r3[0x34]
80006960:	00 00       	add	r0,r0
80006962:	0d 48       	ld.w	r8,--r6
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	5e 2c       	reths	r12

80006968 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006968:	eb cd 40 80 	pushm	r7,lr
8000696c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000696e:	49 08       	lddpc	r8,800069ac <prvAddCurrentTaskToDelayedList+0x44>
80006970:	70 08       	ld.w	r8,r8[0x0]
80006972:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006974:	48 f8       	lddpc	r8,800069b0 <prvAddCurrentTaskToDelayedList+0x48>
80006976:	70 08       	ld.w	r8,r8[0x0]
80006978:	10 3c       	cp.w	r12,r8
8000697a:	c0 a2       	brcc	8000698e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000697c:	48 c8       	lddpc	r8,800069ac <prvAddCurrentTaskToDelayedList+0x44>
8000697e:	70 0b       	ld.w	r11,r8[0x0]
80006980:	48 d8       	lddpc	r8,800069b4 <prvAddCurrentTaskToDelayedList+0x4c>
80006982:	70 0c       	ld.w	r12,r8[0x0]
80006984:	2f cb       	sub	r11,-4
80006986:	f0 1f 00 0d 	mcall	800069b8 <prvAddCurrentTaskToDelayedList+0x50>
8000698a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000698e:	48 88       	lddpc	r8,800069ac <prvAddCurrentTaskToDelayedList+0x44>
80006990:	70 0b       	ld.w	r11,r8[0x0]
80006992:	48 b8       	lddpc	r8,800069bc <prvAddCurrentTaskToDelayedList+0x54>
80006994:	70 0c       	ld.w	r12,r8[0x0]
80006996:	2f cb       	sub	r11,-4
80006998:	f0 1f 00 08 	mcall	800069b8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000699c:	48 98       	lddpc	r8,800069c0 <prvAddCurrentTaskToDelayedList+0x58>
8000699e:	70 08       	ld.w	r8,r8[0x0]
800069a0:	10 37       	cp.w	r7,r8
800069a2:	c0 32       	brcc	800069a8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800069a4:	48 78       	lddpc	r8,800069c0 <prvAddCurrentTaskToDelayedList+0x58>
800069a6:	91 07       	st.w	r8[0x0],r7
800069a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800069ac:	00 00       	add	r0,r0
800069ae:	0c f8       	st.b	--r6,r8
800069b0:	00 00       	add	r0,r0
800069b2:	0d 24       	ld.uh	r4,r6++
800069b4:	00 00       	add	r0,r0
800069b6:	0c 40       	or	r0,r6
800069b8:	80 00       	ld.sh	r0,r0[0x0]
800069ba:	5c 32       	neg	r2
800069bc:	00 00       	add	r0,r0
800069be:	0c 30       	cp.w	r0,r6
800069c0:	00 00       	add	r0,r0
800069c2:	05 38       	ld.ub	r8,r2++

800069c4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800069c4:	eb cd 40 c0 	pushm	r6-r7,lr
800069c8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800069ca:	58 0c       	cp.w	r12,0
800069cc:	c1 10       	breq	800069ee <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800069ce:	f0 1f 00 0a 	mcall	800069f4 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800069d2:	48 a8       	lddpc	r8,800069f8 <vTaskDelay+0x34>
800069d4:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069d6:	48 a8       	lddpc	r8,800069fc <vTaskDelay+0x38>
800069d8:	70 0c       	ld.w	r12,r8[0x0]
800069da:	2f cc       	sub	r12,-4
800069dc:	f0 1f 00 09 	mcall	80006a00 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800069e0:	ee 06 00 0c 	add	r12,r7,r6
800069e4:	f0 1f 00 08 	mcall	80006a04 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800069e8:	f0 1f 00 08 	mcall	80006a08 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800069ec:	c0 21       	brne	800069f0 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800069ee:	d7 33       	scall
800069f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	64 c4       	ld.w	r4,r2[0x30]
800069f8:	00 00       	add	r0,r0
800069fa:	0d 24       	ld.uh	r4,r6++
800069fc:	00 00       	add	r0,r0
800069fe:	0c f8       	st.b	--r6,r8
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	5c 66       	casts.b	r6
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	69 68       	ld.w	r8,r4[0x58]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	68 80       	ld.w	r0,r4[0x20]

80006a0c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006a0c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a10:	18 96       	mov	r6,r12
80006a12:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006a14:	f0 1f 00 18 	mcall	80006a74 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006a18:	6c 08       	ld.w	r8,r6[0x0]
80006a1a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006a1c:	49 79       	lddpc	r9,80006a78 <vTaskDelayUntil+0x6c>
80006a1e:	72 09       	ld.w	r9,r9[0x0]
80006a20:	12 38       	cp.w	r8,r9
80006a22:	e0 88 00 0c 	brls	80006a3a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006a26:	0e 38       	cp.w	r8,r7
80006a28:	e0 88 00 22 	brls	80006a6c <vTaskDelayUntil+0x60>
80006a2c:	49 38       	lddpc	r8,80006a78 <vTaskDelayUntil+0x6c>
80006a2e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006a30:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006a32:	10 37       	cp.w	r7,r8
80006a34:	e0 88 00 14 	brls	80006a5c <vTaskDelayUntil+0x50>
80006a38:	c0 a8       	rjmp	80006a4c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006a3a:	0e 38       	cp.w	r8,r7
80006a3c:	e0 8b 00 16 	brhi	80006a68 <vTaskDelayUntil+0x5c>
80006a40:	48 e8       	lddpc	r8,80006a78 <vTaskDelayUntil+0x6c>
80006a42:	70 08       	ld.w	r8,r8[0x0]
80006a44:	10 37       	cp.w	r7,r8
80006a46:	e0 8b 00 11 	brhi	80006a68 <vTaskDelayUntil+0x5c>
80006a4a:	c1 18       	rjmp	80006a6c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a4c:	48 c8       	lddpc	r8,80006a7c <vTaskDelayUntil+0x70>
80006a4e:	70 0c       	ld.w	r12,r8[0x0]
80006a50:	2f cc       	sub	r12,-4
80006a52:	f0 1f 00 0c 	mcall	80006a80 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a56:	0e 9c       	mov	r12,r7
80006a58:	f0 1f 00 0b 	mcall	80006a84 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006a5c:	f0 1f 00 0b 	mcall	80006a88 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a60:	c0 81       	brne	80006a70 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006a62:	d7 33       	scall
80006a64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006a68:	8d 07       	st.w	r6[0x0],r7
80006a6a:	cf 1b       	rjmp	80006a4c <vTaskDelayUntil+0x40>
80006a6c:	8d 07       	st.w	r6[0x0],r7
80006a6e:	cf 7b       	rjmp	80006a5c <vTaskDelayUntil+0x50>
80006a70:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	64 c4       	ld.w	r4,r2[0x30]
80006a78:	00 00       	add	r0,r0
80006a7a:	0d 24       	ld.uh	r4,r6++
80006a7c:	00 00       	add	r0,r0
80006a7e:	0c f8       	st.b	--r6,r8
80006a80:	80 00       	ld.sh	r0,r0[0x0]
80006a82:	5c 66       	casts.b	r6
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	69 68       	ld.w	r8,r4[0x58]
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	68 80       	ld.w	r0,r4[0x20]

80006a8c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006a8c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a90:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006a92:	48 e7       	lddpc	r7,80006ac8 <vTaskPlaceOnEventList+0x3c>
80006a94:	6e 0b       	ld.w	r11,r7[0x0]
80006a96:	2e 8b       	sub	r11,-24
80006a98:	f0 1f 00 0d 	mcall	80006acc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a9c:	6e 0c       	ld.w	r12,r7[0x0]
80006a9e:	2f cc       	sub	r12,-4
80006aa0:	f0 1f 00 0c 	mcall	80006ad0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006aa4:	5b f6       	cp.w	r6,-1
80006aa6:	c0 81       	brne	80006ab6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aa8:	6e 0b       	ld.w	r11,r7[0x0]
80006aaa:	2f cb       	sub	r11,-4
80006aac:	48 ac       	lddpc	r12,80006ad4 <vTaskPlaceOnEventList+0x48>
80006aae:	f0 1f 00 0b 	mcall	80006ad8 <vTaskPlaceOnEventList+0x4c>
80006ab2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006ab6:	48 a8       	lddpc	r8,80006adc <vTaskPlaceOnEventList+0x50>
80006ab8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006aba:	ec 0c 00 0c 	add	r12,r6,r12
80006abe:	f0 1f 00 09 	mcall	80006ae0 <vTaskPlaceOnEventList+0x54>
80006ac2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ac6:	00 00       	add	r0,r0
80006ac8:	00 00       	add	r0,r0
80006aca:	0c f8       	st.b	--r6,r8
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	5c 32       	neg	r2
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	5c 66       	casts.b	r6
80006ad4:	00 00       	add	r0,r0
80006ad6:	0d 4c       	ld.w	r12,--r6
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	5c 16       	scr	r6
80006adc:	00 00       	add	r0,r0
80006ade:	0d 24       	ld.uh	r4,r6++
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	69 68       	ld.w	r8,r4[0x58]

80006ae4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006ae4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006ae8:	49 67       	lddpc	r7,80006b40 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006aea:	49 74       	lddpc	r4,80006b44 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006aec:	49 73       	lddpc	r3,80006b48 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006aee:	49 85       	lddpc	r5,80006b4c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006af0:	6e 08       	ld.w	r8,r7[0x0]
80006af2:	58 08       	cp.w	r8,0
80006af4:	c1 e0       	breq	80006b30 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006af6:	f0 1f 00 17 	mcall	80006b50 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006afa:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006afc:	f0 1f 00 16 	mcall	80006b54 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006b00:	58 06       	cp.w	r6,0
80006b02:	c1 70       	breq	80006b30 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b04:	f0 1f 00 15 	mcall	80006b58 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b08:	68 38       	ld.w	r8,r4[0xc]
80006b0a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006b0c:	ec cc ff fc 	sub	r12,r6,-4
80006b10:	f0 1f 00 13 	mcall	80006b5c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006b14:	66 08       	ld.w	r8,r3[0x0]
80006b16:	20 18       	sub	r8,1
80006b18:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006b1a:	6e 08       	ld.w	r8,r7[0x0]
80006b1c:	20 18       	sub	r8,1
80006b1e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006b20:	f0 1f 00 10 	mcall	80006b60 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006b24:	6c cc       	ld.w	r12,r6[0x30]
80006b26:	f0 1f 00 10 	mcall	80006b64 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006b2a:	0c 9c       	mov	r12,r6
80006b2c:	f0 1f 00 0e 	mcall	80006b64 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b30:	6a 08       	ld.w	r8,r5[0x0]
80006b32:	58 18       	cp.w	r8,1
80006b34:	e0 88 00 03 	brls	80006b3a <prvIdleTask+0x56>
			{
				taskYIELD();
80006b38:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006b3a:	f0 1f 00 0c 	mcall	80006b68 <prvIdleTask+0x84>
		}
		#endif
	}
80006b3e:	cd 9b       	rjmp	80006af0 <prvIdleTask+0xc>
80006b40:	00 00       	add	r0,r0
80006b42:	0c 38       	cp.w	r8,r6
80006b44:	00 00       	add	r0,r0
80006b46:	0c e4       	st.h	--r6,r4
80006b48:	00 00       	add	r0,r0
80006b4a:	0d 44       	ld.w	r4,--r6
80006b4c:	00 00       	add	r0,r0
80006b4e:	0c 44       	or	r4,r6
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	64 c4       	ld.w	r4,r2[0x30]
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	68 80       	ld.w	r0,r4[0x20]
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	5d 20       	mustr	r0
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5c 66       	casts.b	r6
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	5e 2c       	reths	r12
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	5f 64       	srmi	r4
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	20 2c       	sub	r12,2

80006b6c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006b6c:	d4 31       	pushm	r0-r7,lr
80006b6e:	20 1d       	sub	sp,4
80006b70:	fa c4 ff d8 	sub	r4,sp,-40
80006b74:	50 0c       	stdsp	sp[0x0],r12
80006b76:	16 91       	mov	r1,r11
80006b78:	14 97       	mov	r7,r10
80006b7a:	12 90       	mov	r0,r9
80006b7c:	10 93       	mov	r3,r8
80006b7e:	68 02       	ld.w	r2,r4[0x0]
80006b80:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006b82:	34 8c       	mov	r12,72
80006b84:	f0 1f 00 5c 	mcall	80006cf4 <xTaskGenericCreate+0x188>
80006b88:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006b8a:	c0 31       	brne	80006b90 <xTaskGenericCreate+0x24>
80006b8c:	3f fc       	mov	r12,-1
80006b8e:	ca f8       	rjmp	80006cec <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b90:	58 06       	cp.w	r6,0
80006b92:	e0 81 00 af 	brne	80006cf0 <xTaskGenericCreate+0x184>
80006b96:	0e 9c       	mov	r12,r7
80006b98:	5c 7c       	castu.h	r12
80006b9a:	a3 6c       	lsl	r12,0x2
80006b9c:	f0 1f 00 56 	mcall	80006cf4 <xTaskGenericCreate+0x188>
80006ba0:	18 96       	mov	r6,r12
80006ba2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006ba4:	c0 61       	brne	80006bb0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006ba6:	0a 9c       	mov	r12,r5
80006ba8:	f0 1f 00 54 	mcall	80006cf8 <xTaskGenericCreate+0x18c>
80006bac:	3f fc       	mov	r12,-1
80006bae:	c9 f8       	rjmp	80006cec <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006bb0:	5c 77       	castu.h	r7
80006bb2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006bb6:	e0 6b 00 a5 	mov	r11,165
80006bba:	0c 9c       	mov	r12,r6
80006bbc:	f0 1f 00 50 	mcall	80006cfc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006bc0:	ee c6 00 01 	sub	r6,r7,1
80006bc4:	6a c8       	ld.w	r8,r5[0x30]
80006bc6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006bca:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006bce:	31 0a       	mov	r10,16
80006bd0:	02 9b       	mov	r11,r1
80006bd2:	ea cc ff cc 	sub	r12,r5,-52
80006bd6:	f0 1f 00 4b 	mcall	80006d00 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006bda:	30 08       	mov	r8,0
80006bdc:	eb 68 00 43 	st.b	r5[67],r8
80006be0:	58 73       	cp.w	r3,7
80006be2:	e6 07 17 80 	movls	r7,r3
80006be6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006bea:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006bec:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006bf0:	ea c4 ff fc 	sub	r4,r5,-4
80006bf4:	08 9c       	mov	r12,r4
80006bf6:	f0 1f 00 44 	mcall	80006d04 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006bfa:	ea cc ff e8 	sub	r12,r5,-24
80006bfe:	f0 1f 00 42 	mcall	80006d04 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006c02:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006c04:	ee 07 11 08 	rsub	r7,r7,8
80006c08:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c0a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006c0c:	00 9a       	mov	r10,r0
80006c0e:	40 0b       	lddsp	r11,sp[0x0]
80006c10:	0c 9c       	mov	r12,r6
80006c12:	f0 1f 00 3e 	mcall	80006d08 <xTaskGenericCreate+0x19c>
80006c16:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006c18:	58 02       	cp.w	r2,0
80006c1a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006c1e:	f0 1f 00 3c 	mcall	80006d0c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006c22:	4b c8       	lddpc	r8,80006d10 <xTaskGenericCreate+0x1a4>
80006c24:	70 09       	ld.w	r9,r8[0x0]
80006c26:	2f f9       	sub	r9,-1
80006c28:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006c2a:	4b b8       	lddpc	r8,80006d14 <xTaskGenericCreate+0x1a8>
80006c2c:	70 08       	ld.w	r8,r8[0x0]
80006c2e:	58 08       	cp.w	r8,0
80006c30:	c2 61       	brne	80006c7c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006c32:	4b 98       	lddpc	r8,80006d14 <xTaskGenericCreate+0x1a8>
80006c34:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006c36:	4b 78       	lddpc	r8,80006d10 <xTaskGenericCreate+0x1a4>
80006c38:	70 08       	ld.w	r8,r8[0x0]
80006c3a:	58 18       	cp.w	r8,1
80006c3c:	c2 b1       	brne	80006c92 <xTaskGenericCreate+0x126>
80006c3e:	4b 77       	lddpc	r7,80006d18 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006c40:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006c44:	0e 9c       	mov	r12,r7
80006c46:	f0 1f 00 36 	mcall	80006d1c <xTaskGenericCreate+0x1b0>
80006c4a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006c4c:	0c 37       	cp.w	r7,r6
80006c4e:	cf b1       	brne	80006c44 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006c50:	4b 47       	lddpc	r7,80006d20 <xTaskGenericCreate+0x1b4>
80006c52:	0e 9c       	mov	r12,r7
80006c54:	f0 1f 00 32 	mcall	80006d1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006c58:	4b 36       	lddpc	r6,80006d24 <xTaskGenericCreate+0x1b8>
80006c5a:	0c 9c       	mov	r12,r6
80006c5c:	f0 1f 00 30 	mcall	80006d1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006c60:	4b 2c       	lddpc	r12,80006d28 <xTaskGenericCreate+0x1bc>
80006c62:	f0 1f 00 2f 	mcall	80006d1c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006c66:	4b 2c       	lddpc	r12,80006d2c <xTaskGenericCreate+0x1c0>
80006c68:	f0 1f 00 2d 	mcall	80006d1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006c6c:	4b 1c       	lddpc	r12,80006d30 <xTaskGenericCreate+0x1c4>
80006c6e:	f0 1f 00 2c 	mcall	80006d1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006c72:	4b 18       	lddpc	r8,80006d34 <xTaskGenericCreate+0x1c8>
80006c74:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006c76:	4b 18       	lddpc	r8,80006d38 <xTaskGenericCreate+0x1cc>
80006c78:	91 06       	st.w	r8[0x0],r6
80006c7a:	c0 c8       	rjmp	80006c92 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006c7c:	4b 08       	lddpc	r8,80006d3c <xTaskGenericCreate+0x1d0>
80006c7e:	70 08       	ld.w	r8,r8[0x0]
80006c80:	58 08       	cp.w	r8,0
80006c82:	c0 81       	brne	80006c92 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006c84:	4a 48       	lddpc	r8,80006d14 <xTaskGenericCreate+0x1a8>
80006c86:	70 08       	ld.w	r8,r8[0x0]
80006c88:	70 b8       	ld.w	r8,r8[0x2c]
80006c8a:	10 33       	cp.w	r3,r8
80006c8c:	c0 33       	brcs	80006c92 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006c8e:	4a 28       	lddpc	r8,80006d14 <xTaskGenericCreate+0x1a8>
80006c90:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006c92:	6a b8       	ld.w	r8,r5[0x2c]
80006c94:	4a b9       	lddpc	r9,80006d40 <xTaskGenericCreate+0x1d4>
80006c96:	72 09       	ld.w	r9,r9[0x0]
80006c98:	12 38       	cp.w	r8,r9
80006c9a:	e0 88 00 04 	brls	80006ca2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006c9e:	4a 99       	lddpc	r9,80006d40 <xTaskGenericCreate+0x1d4>
80006ca0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006ca2:	4a 98       	lddpc	r8,80006d44 <xTaskGenericCreate+0x1d8>
80006ca4:	70 09       	ld.w	r9,r8[0x0]
80006ca6:	2f f9       	sub	r9,-1
80006ca8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006caa:	6a b8       	ld.w	r8,r5[0x2c]
80006cac:	4a 79       	lddpc	r9,80006d48 <xTaskGenericCreate+0x1dc>
80006cae:	72 09       	ld.w	r9,r9[0x0]
80006cb0:	12 38       	cp.w	r8,r9
80006cb2:	e0 88 00 04 	brls	80006cba <xTaskGenericCreate+0x14e>
80006cb6:	4a 59       	lddpc	r9,80006d48 <xTaskGenericCreate+0x1dc>
80006cb8:	93 08       	st.w	r9[0x0],r8
80006cba:	6a bc       	ld.w	r12,r5[0x2c]
80006cbc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006cc0:	08 9b       	mov	r11,r4
80006cc2:	49 68       	lddpc	r8,80006d18 <xTaskGenericCreate+0x1ac>
80006cc4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006cc8:	f0 1f 00 21 	mcall	80006d4c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006ccc:	f0 1f 00 21 	mcall	80006d50 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006cd0:	49 b8       	lddpc	r8,80006d3c <xTaskGenericCreate+0x1d0>
80006cd2:	70 08       	ld.w	r8,r8[0x0]
80006cd4:	58 08       	cp.w	r8,0
80006cd6:	c0 a0       	breq	80006cea <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006cd8:	48 f8       	lddpc	r8,80006d14 <xTaskGenericCreate+0x1a8>
80006cda:	70 08       	ld.w	r8,r8[0x0]
80006cdc:	70 b8       	ld.w	r8,r8[0x2c]
80006cde:	10 33       	cp.w	r3,r8
80006ce0:	e0 88 00 05 	brls	80006cea <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ce4:	d7 33       	scall
80006ce6:	30 1c       	mov	r12,1
80006ce8:	c0 28       	rjmp	80006cec <xTaskGenericCreate+0x180>
80006cea:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006cec:	2f fd       	sub	sp,-4
80006cee:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006cf0:	99 c6       	st.w	r12[0x30],r6
80006cf2:	c5 fb       	rjmp	80006bb0 <xTaskGenericCreate+0x44>
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	5f 8c       	srls	r12
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	5f 64       	srmi	r4
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	78 f4       	ld.w	r4,r12[0x3c]
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	7c 20       	ld.w	r0,lr[0x8]
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	5c 10       	scr	r0
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	5c 8c       	casts.h	r12
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	5d 20       	mustr	r0
80006d10:	00 00       	add	r0,r0
80006d12:	0d 44       	ld.w	r4,--r6
80006d14:	00 00       	add	r0,r0
80006d16:	0c f8       	st.b	--r6,r8
80006d18:	00 00       	add	r0,r0
80006d1a:	0c 44       	or	r4,r6
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	5b fc       	cp.w	r12,-1
80006d20:	00 00       	add	r0,r0
80006d22:	0d 10       	ld.sh	r0,r6++
80006d24:	00 00       	add	r0,r0
80006d26:	0d 2c       	ld.uh	r12,r6++
80006d28:	00 00       	add	r0,r0
80006d2a:	0c fc       	st.b	--r6,r12
80006d2c:	00 00       	add	r0,r0
80006d2e:	0c e4       	st.h	--r6,r4
80006d30:	00 00       	add	r0,r0
80006d32:	0d 4c       	ld.w	r12,--r6
80006d34:	00 00       	add	r0,r0
80006d36:	0c 30       	cp.w	r0,r6
80006d38:	00 00       	add	r0,r0
80006d3a:	0c 40       	or	r0,r6
80006d3c:	00 00       	add	r0,r0
80006d3e:	0c 34       	cp.w	r4,r6
80006d40:	00 00       	add	r0,r0
80006d42:	0c 2c       	rsub	r12,r6
80006d44:	00 00       	add	r0,r0
80006d46:	0d 40       	ld.w	r0,--r6
80006d48:	00 00       	add	r0,r0
80006d4a:	0d 60       	ld.uh	r0,--r6
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	5c 16       	scr	r6
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	5e 2c       	reths	r12

80006d54 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006d54:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006d56:	30 09       	mov	r9,0
80006d58:	1a d9       	st.w	--sp,r9
80006d5a:	1a d9       	st.w	--sp,r9
80006d5c:	1a d9       	st.w	--sp,r9
80006d5e:	12 98       	mov	r8,r9
80006d60:	e0 6a 01 00 	mov	r10,256
80006d64:	48 9b       	lddpc	r11,80006d88 <vTaskStartScheduler+0x34>
80006d66:	48 ac       	lddpc	r12,80006d8c <vTaskStartScheduler+0x38>
80006d68:	f0 1f 00 0a 	mcall	80006d90 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006d6c:	2f dd       	sub	sp,-12
80006d6e:	58 1c       	cp.w	r12,1
80006d70:	c0 a1       	brne	80006d84 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006d72:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006d74:	30 19       	mov	r9,1
80006d76:	48 88       	lddpc	r8,80006d94 <vTaskStartScheduler+0x40>
80006d78:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006d7a:	30 09       	mov	r9,0
80006d7c:	48 78       	lddpc	r8,80006d98 <vTaskStartScheduler+0x44>
80006d7e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006d80:	f0 1f 00 07 	mcall	80006d9c <vTaskStartScheduler+0x48>
80006d84:	d8 02       	popm	pc
80006d86:	00 00       	add	r0,r0
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	da 3c       	*unknown*
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	6a e4       	ld.w	r4,r5[0x38]
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	6b 6c       	ld.w	r12,r5[0x58]
80006d94:	00 00       	add	r0,r0
80006d96:	0c 34       	cp.w	r4,r6
80006d98:	00 00       	add	r0,r0
80006d9a:	0d 24       	ld.uh	r4,r6++
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	5d 30       	musfr	r0

80006da0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006da0:	16 cc       	st.b	r11++,r12
	return str;
}
80006da2:	5e fb       	retal	r11

80006da4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006da4:	eb cd 40 c0 	pushm	r6-r7,lr
80006da8:	20 3d       	sub	sp,12
80006daa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006dac:	30 06       	mov	r6,0
80006dae:	30 07       	mov	r7,0
80006db0:	fa e7 00 00 	st.d	sp[0],r6
80006db4:	30 0c       	mov	r12,0
80006db6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006db8:	58 08       	cp.w	r8,0
80006dba:	c1 30       	breq	80006de0 <PrintHex+0x3c>
80006dbc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006dbe:	1a 9c       	mov	r12,sp
80006dc0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006dc4:	58 9e       	cp.w	lr,9
80006dc6:	e0 8a 00 04 	brle	80006dce <PrintHex+0x2a>
80006dca:	2c 9e       	sub	lr,-55
80006dcc:	c0 48       	rjmp	80006dd4 <PrintHex+0x30>
80006dce:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006dd2:	2d 0e       	sub	lr,-48
80006dd4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006dd8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006dda:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006ddc:	cf 21       	brne	80006dc0 <PrintHex+0x1c>
80006dde:	c0 48       	rjmp	80006de6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006de0:	33 08       	mov	r8,48
80006de2:	ba 88       	st.b	sp[0x0],r8
80006de4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006de6:	f6 09 01 08 	sub	r8,r11,r9
80006dea:	58 08       	cp.w	r8,0
80006dec:	e0 8a 00 13 	brle	80006e12 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006df0:	12 1b       	sub	r11,r9
80006df2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006df6:	18 9e       	mov	lr,r12
80006df8:	58 0c       	cp.w	r12,0
80006dfa:	e0 8a 00 0c 	brle	80006e12 <PrintHex+0x6e>
80006dfe:	1a 9b       	mov	r11,sp
80006e00:	12 0b       	add	r11,r9
80006e02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006e04:	33 07       	mov	r7,48
80006e06:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e08:	2f f8       	sub	r8,-1
80006e0a:	1c 38       	cp.w	r8,lr
80006e0c:	cf d5       	brlt	80006e06 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e0e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e12:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006e16:	f0 cb ff ff 	sub	r11,r8,-1
80006e1a:	58 0b       	cp.w	r11,0
80006e1c:	e0 8a 00 19 	brle	80006e4e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e20:	fa cb ff f4 	sub	r11,sp,-12
80006e24:	f6 09 00 09 	add	r9,r11,r9
80006e28:	37 8b       	mov	r11,120
80006e2a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006e2e:	fa c9 ff f4 	sub	r9,sp,-12
80006e32:	10 09       	add	r9,r8
80006e34:	33 0b       	mov	r11,48
80006e36:	f3 6b ff f4 	st.b	r9[-12],r11
80006e3a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e3e:	fa ce 00 01 	sub	lr,sp,1
80006e42:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006e44:	11 8b       	ld.ub	r11,r8[0x0]
80006e46:	12 cb       	st.b	r9++,r11
80006e48:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006e4a:	1c 38       	cp.w	r8,lr
80006e4c:	cf c1       	brne	80006e44 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006e4e:	14 9c       	mov	r12,r10
80006e50:	2f dd       	sub	sp,-12
80006e52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006e56 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006e56:	d4 21       	pushm	r4-r7,lr
80006e58:	20 3d       	sub	sp,12
80006e5a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006e5c:	30 06       	mov	r6,0
80006e5e:	30 07       	mov	r7,0
80006e60:	fa e7 00 00 	st.d	sp[0],r6
80006e64:	30 0c       	mov	r12,0
80006e66:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006e68:	58 08       	cp.w	r8,0
80006e6a:	c0 35       	brlt	80006e70 <PrintDec+0x1a>
80006e6c:	14 97       	mov	r7,r10
80006e6e:	c0 58       	rjmp	80006e78 <PrintDec+0x22>
	{
		*p++ = '-';
80006e70:	14 97       	mov	r7,r10
80006e72:	32 d9       	mov	r9,45
80006e74:	0e c9       	st.b	r7++,r9
		i = -i;
80006e76:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006e78:	58 08       	cp.w	r8,0
80006e7a:	c0 51       	brne	80006e84 <PrintDec+0x2e>
80006e7c:	33 08       	mov	r8,48
80006e7e:	ba 88       	st.b	sp[0x0],r8
80006e80:	30 1e       	mov	lr,1
80006e82:	c2 f8       	rjmp	80006ee0 <PrintDec+0x8a>
	
	int ten = i%10;
80006e84:	e0 65 66 67 	mov	r5,26215
80006e88:	ea 15 66 66 	orh	r5,0x6666
80006e8c:	f0 05 04 44 	muls.d	r4,r8,r5
80006e90:	ea 0c 14 02 	asr	r12,r5,0x2
80006e94:	f0 09 14 1f 	asr	r9,r8,0x1f
80006e98:	f8 09 01 09 	sub	r9,r12,r9
80006e9c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ea0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006ea4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006ea6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006ea8:	e0 66 66 67 	mov	r6,26215
80006eac:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006eb0:	2d 09       	sub	r9,-48
80006eb2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006eb6:	2f fe       	sub	lr,-1
		i /= 10;
80006eb8:	f0 06 04 44 	muls.d	r4,r8,r6
80006ebc:	ea 09 14 02 	asr	r9,r5,0x2
80006ec0:	bf 58       	asr	r8,0x1f
80006ec2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006ec6:	f0 06 04 44 	muls.d	r4,r8,r6
80006eca:	ea 09 14 02 	asr	r9,r5,0x2
80006ece:	f0 05 14 1f 	asr	r5,r8,0x1f
80006ed2:	0a 19       	sub	r9,r5
80006ed4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ed8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006edc:	58 08       	cp.w	r8,0
80006ede:	ce 91       	brne	80006eb0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006ee0:	f6 0e 01 08 	sub	r8,r11,lr
80006ee4:	58 08       	cp.w	r8,0
80006ee6:	e0 89 00 06 	brgt	80006ef2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006eea:	58 0e       	cp.w	lr,0
80006eec:	e0 89 00 14 	brgt	80006f14 <PrintDec+0xbe>
80006ef0:	c1 d8       	rjmp	80006f2a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006ef2:	1c 1b       	sub	r11,lr
80006ef4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006ef6:	16 9c       	mov	r12,r11
80006ef8:	58 0b       	cp.w	r11,0
80006efa:	fe 9a ff f8 	brle	80006eea <PrintDec+0x94>
80006efe:	1a 99       	mov	r9,sp
80006f00:	1c 09       	add	r9,lr
80006f02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f04:	33 06       	mov	r6,48
80006f06:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f08:	2f f8       	sub	r8,-1
80006f0a:	18 38       	cp.w	r8,r12
80006f0c:	cf d5       	brlt	80006f06 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006f0e:	f6 0e 00 0e 	add	lr,r11,lr
80006f12:	ce cb       	rjmp	80006eea <PrintDec+0x94>
80006f14:	fa c8 ff f4 	sub	r8,sp,-12
80006f18:	1c 08       	add	r8,lr
80006f1a:	20 d8       	sub	r8,13
80006f1c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f20:	11 89       	ld.ub	r9,r8[0x0]
80006f22:	0e c9       	st.b	r7++,r9
80006f24:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f26:	16 38       	cp.w	r8,r11
80006f28:	cf c1       	brne	80006f20 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006f2a:	14 9c       	mov	r12,r10
80006f2c:	2f dd       	sub	sp,-12
80006f2e:	d8 22       	popm	r4-r7,pc

80006f30 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006f30:	d4 31       	pushm	r0-r7,lr
80006f32:	fa cd 02 08 	sub	sp,sp,520
80006f36:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006f38:	e0 6a 01 00 	mov	r10,256
80006f3c:	30 0b       	mov	r11,0
80006f3e:	fa cc fe f8 	sub	r12,sp,-264
80006f42:	f0 1f 00 4e 	mcall	80007078 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006f46:	fa c4 fd d4 	sub	r4,sp,-556
80006f4a:	30 0a       	mov	r10,0
80006f4c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f4e:	fa c3 ff fc 	sub	r3,sp,-4
80006f52:	e0 61 01 00 	mov	r1,256
80006f56:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006f58:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f5a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f5e:	02 9a       	mov	r10,r1
80006f60:	00 9b       	mov	r11,r0
80006f62:	06 9c       	mov	r12,r3
80006f64:	f0 1f 00 45 	mcall	80007078 <log+0x148>
			
					if(*str == '%')
80006f68:	0f 88       	ld.ub	r8,r7[0x0]
80006f6a:	e4 08 18 00 	cp.b	r8,r2
80006f6e:	c5 71       	brne	8000701c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006f70:	ee c8 ff ff 	sub	r8,r7,-1
80006f74:	11 89       	ld.ub	r9,r8[0x0]
80006f76:	4c 2a       	lddpc	r10,8000707c <log+0x14c>
80006f78:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006f7a:	23 09       	sub	r9,48
80006f7c:	30 9a       	mov	r10,9
80006f7e:	f4 09 18 00 	cp.b	r9,r10
80006f82:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006f86:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f8a:	f7 b9 08 30 	subls	r9,48
80006f8e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006f92:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006f96:	0f 88       	ld.ub	r8,r7[0x0]
80006f98:	22 58       	sub	r8,37
80006f9a:	e0 48 00 53 	cp.w	r8,83
80006f9e:	e0 8b 00 31 	brhi	80007000 <log+0xd0>
80006fa2:	4b 89       	lddpc	r9,80007080 <log+0x150>
80006fa4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006fa8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006fac:	06 9a       	mov	r10,r3
80006fae:	40 0b       	lddsp	r11,sp[0x0]
80006fb0:	5c 5b       	castu.b	r11
80006fb2:	68 0c       	ld.w	r12,r4[0x0]
80006fb4:	f0 1f 00 34 	mcall	80007084 <log+0x154>
							break;
80006fb8:	c2 98       	rjmp	8000700a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006fba:	4b 4c       	lddpc	r12,80007088 <log+0x158>
80006fbc:	f0 1f 00 34 	mcall	8000708c <log+0x15c>
80006fc0:	08 95       	mov	r5,r4
80006fc2:	06 9c       	mov	r12,r3
							break;
80006fc4:	c2 38       	rjmp	8000700a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006fc6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006fca:	06 9a       	mov	r10,r3
80006fcc:	40 0b       	lddsp	r11,sp[0x0]
80006fce:	5c 5b       	castu.b	r11
80006fd0:	68 0c       	ld.w	r12,r4[0x0]
80006fd2:	f0 1f 00 30 	mcall	80007090 <log+0x160>
80006fd6:	06 9c       	mov	r12,r3
							break;
80006fd8:	c1 98       	rjmp	8000700a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006fda:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006fde:	06 9b       	mov	r11,r3
80006fe0:	09 bc       	ld.ub	r12,r4[0x3]
80006fe2:	f0 1f 00 2d 	mcall	80007094 <log+0x164>
80006fe6:	06 9c       	mov	r12,r3
							break;
80006fe8:	c1 18       	rjmp	8000700a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006fea:	e8 c5 ff fc 	sub	r5,r4,-4
80006fee:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006ff0:	c0 d8       	rjmp	8000700a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006ff2:	06 9b       	mov	r11,r3
80006ff4:	32 5c       	mov	r12,37
80006ff6:	f0 1f 00 28 	mcall	80007094 <log+0x164>
80006ffa:	08 95       	mov	r5,r4
80006ffc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006ffe:	c0 68       	rjmp	8000700a <log+0xda>
							
							default:
							log("I need relax.");
80007000:	4a 6c       	lddpc	r12,80007098 <log+0x168>
80007002:	f0 1f 00 23 	mcall	8000708c <log+0x15c>
80007006:	08 95       	mov	r5,r4
80007008:	06 9c       	mov	r12,r3
						}
						str++;
8000700a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000700c:	1a dc       	st.w	--sp,r12
8000700e:	1a d6       	st.w	--sp,r6
80007010:	4a 3b       	lddpc	r11,8000709c <log+0x16c>
80007012:	0c 9c       	mov	r12,r6
80007014:	f0 1f 00 23 	mcall	800070a0 <log+0x170>
80007018:	2f ed       	sub	sp,-8
8000701a:	c0 a8       	rjmp	8000702e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000701c:	2f f7       	sub	r7,-1
8000701e:	1a d8       	st.w	--sp,r8
80007020:	1a d6       	st.w	--sp,r6
80007022:	4a 1b       	lddpc	r11,800070a4 <log+0x174>
80007024:	0c 9c       	mov	r12,r6
80007026:	f0 1f 00 1f 	mcall	800070a0 <log+0x170>
8000702a:	08 95       	mov	r5,r4
8000702c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000702e:	0f 89       	ld.ub	r9,r7[0x0]
80007030:	30 08       	mov	r8,0
80007032:	f0 09 18 00 	cp.b	r9,r8
80007036:	c0 30       	breq	8000703c <log+0x10c>
80007038:	0a 94       	mov	r4,r5
8000703a:	c9 2b       	rjmp	80006f5e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000703c:	fa c7 fe f8 	sub	r7,sp,-264
80007040:	1a d7       	st.w	--sp,r7
80007042:	49 ab       	lddpc	r11,800070a8 <log+0x178>
80007044:	0e 9c       	mov	r12,r7
80007046:	f0 1f 00 17 	mcall	800070a0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000704a:	5c 5c       	castu.b	r12
8000704c:	f8 c6 ff ff 	sub	r6,r12,-1
80007050:	0c 9c       	mov	r12,r6
80007052:	f0 1f 00 17 	mcall	800070ac <log+0x17c>
80007056:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007058:	0c 9a       	mov	r10,r6
8000705a:	0e 9b       	mov	r11,r7
8000705c:	f0 1f 00 15 	mcall	800070b0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007060:	30 09       	mov	r9,0
80007062:	30 5a       	mov	r10,5
80007064:	fa cb fe f8 	sub	r11,sp,-264
80007068:	49 38       	lddpc	r8,800070b4 <log+0x184>
8000706a:	70 0c       	ld.w	r12,r8[0x0]
8000706c:	f0 1f 00 13 	mcall	800070b8 <log+0x188>
80007070:	2f fd       	sub	sp,-4
	
	
}
80007072:	fe 3d fd f8 	sub	sp,-520
80007076:	d8 32       	popm	r0-r7,pc
80007078:	80 00       	ld.sh	r0,r0[0x0]
8000707a:	78 f4       	ld.w	r4,r12[0x3c]
8000707c:	00 00       	add	r0,r0
8000707e:	0d 64       	ld.uh	r4,--r6
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	da 44       	*unknown*
80007084:	80 00       	ld.sh	r0,r0[0x0]
80007086:	6e 56       	ld.w	r6,r7[0x14]
80007088:	80 00       	ld.sh	r0,r0[0x0]
8000708a:	dc f0       	acall	0xcf
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	6f 30       	ld.w	r0,r7[0x4c]
80007090:	80 00       	ld.sh	r0,r0[0x0]
80007092:	6d a4       	ld.w	r4,r6[0x68]
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	6d a0       	ld.w	r0,r6[0x68]
80007098:	80 00       	ld.sh	r0,r0[0x0]
8000709a:	dd 00       	acall	0xd0
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	dd 10       	acall	0xd1
800070a0:	80 00       	ld.sh	r0,r0[0x0]
800070a2:	7b e4       	ld.w	r4,sp[0x78]
800070a4:	80 00       	ld.sh	r0,r0[0x0]
800070a6:	dd 18       	*unknown*
800070a8:	80 00       	ld.sh	r0,r0[0x0]
800070aa:	dd 20       	acall	0xd2
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	5f 8c       	srls	r12
800070b0:	80 00       	ld.sh	r0,r0[0x0]
800070b2:	77 ac       	ld.w	r12,r11[0x68]
800070b4:	00 00       	add	r0,r0
800070b6:	53 50       	stdsp	sp[0xd4],r0
800070b8:	80 00       	ld.sh	r0,r0[0x0]
800070ba:	62 e0       	ld.w	r0,r1[0x38]

800070bc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800070bc:	d4 31       	pushm	r0-r7,lr
800070be:	fa cd 02 0c 	sub	sp,sp,524
800070c2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800070c4:	e0 6a 01 00 	mov	r10,256
800070c8:	30 0b       	mov	r11,0
800070ca:	fa cc fe f4 	sub	r12,sp,-268
800070ce:	f0 1f 00 4c 	mcall	800071fc <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800070d2:	fa c4 fd d0 	sub	r4,sp,-560
800070d6:	30 0a       	mov	r10,0
800070d8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800070da:	fa c3 ff fc 	sub	r3,sp,-4
800070de:	e0 61 01 00 	mov	r1,256
800070e2:	14 90       	mov	r0,r10
			
			if(*str == '%')
800070e4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070e6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800070ea:	02 9a       	mov	r10,r1
800070ec:	00 9b       	mov	r11,r0
800070ee:	06 9c       	mov	r12,r3
800070f0:	f0 1f 00 43 	mcall	800071fc <logFromISR+0x140>
			
			if(*str == '%')
800070f4:	0f 88       	ld.ub	r8,r7[0x0]
800070f6:	e4 08 18 00 	cp.b	r8,r2
800070fa:	c5 11       	brne	8000719c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800070fc:	ee c8 ff ff 	sub	r8,r7,-1
80007100:	11 89       	ld.ub	r9,r8[0x0]
80007102:	4c 0a       	lddpc	r10,80007200 <logFromISR+0x144>
80007104:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007106:	23 09       	sub	r9,48
80007108:	30 9a       	mov	r10,9
8000710a:	f4 09 18 00 	cp.b	r9,r10
8000710e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007112:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007116:	f7 b9 08 30 	subls	r9,48
8000711a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000711e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007122:	0f 88       	ld.ub	r8,r7[0x0]
80007124:	22 58       	sub	r8,37
80007126:	e0 48 00 53 	cp.w	r8,83
8000712a:	e0 8b 00 2b 	brhi	80007180 <logFromISR+0xc4>
8000712e:	4b 69       	lddpc	r9,80007204 <logFromISR+0x148>
80007130:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007134:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007138:	06 9a       	mov	r10,r3
8000713a:	40 0b       	lddsp	r11,sp[0x0]
8000713c:	5c 5b       	castu.b	r11
8000713e:	68 0c       	ld.w	r12,r4[0x0]
80007140:	f0 1f 00 32 	mcall	80007208 <logFromISR+0x14c>
					break;
80007144:	c2 38       	rjmp	8000718a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007146:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000714a:	06 9a       	mov	r10,r3
8000714c:	40 0b       	lddsp	r11,sp[0x0]
8000714e:	5c 5b       	castu.b	r11
80007150:	68 0c       	ld.w	r12,r4[0x0]
80007152:	f0 1f 00 2f 	mcall	8000720c <logFromISR+0x150>
80007156:	06 9c       	mov	r12,r3
					break;
80007158:	c1 98       	rjmp	8000718a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000715a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000715e:	06 9b       	mov	r11,r3
80007160:	09 bc       	ld.ub	r12,r4[0x3]
80007162:	f0 1f 00 2c 	mcall	80007210 <logFromISR+0x154>
80007166:	06 9c       	mov	r12,r3
					break;
80007168:	c1 18       	rjmp	8000718a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000716a:	e8 c5 ff fc 	sub	r5,r4,-4
8000716e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007170:	c0 d8       	rjmp	8000718a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007172:	06 9b       	mov	r11,r3
80007174:	32 5c       	mov	r12,37
80007176:	f0 1f 00 27 	mcall	80007210 <logFromISR+0x154>
8000717a:	08 95       	mov	r5,r4
8000717c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000717e:	c0 68       	rjmp	8000718a <logFromISR+0xce>
					default:
					log("I need relax.");
80007180:	4a 5c       	lddpc	r12,80007214 <logFromISR+0x158>
80007182:	f0 1f 00 26 	mcall	80007218 <logFromISR+0x15c>
80007186:	08 95       	mov	r5,r4
80007188:	06 9c       	mov	r12,r3
				}
				str++;
8000718a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000718c:	1a dc       	st.w	--sp,r12
8000718e:	1a d6       	st.w	--sp,r6
80007190:	4a 3b       	lddpc	r11,8000721c <logFromISR+0x160>
80007192:	0c 9c       	mov	r12,r6
80007194:	f0 1f 00 23 	mcall	80007220 <logFromISR+0x164>
80007198:	2f ed       	sub	sp,-8
8000719a:	c0 a8       	rjmp	800071ae <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000719c:	2f f7       	sub	r7,-1
8000719e:	1a d8       	st.w	--sp,r8
800071a0:	1a d6       	st.w	--sp,r6
800071a2:	4a 1b       	lddpc	r11,80007224 <logFromISR+0x168>
800071a4:	0c 9c       	mov	r12,r6
800071a6:	f0 1f 00 1f 	mcall	80007220 <logFromISR+0x164>
800071aa:	08 95       	mov	r5,r4
800071ac:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800071ae:	0f 89       	ld.ub	r9,r7[0x0]
800071b0:	30 08       	mov	r8,0
800071b2:	f0 09 18 00 	cp.b	r9,r8
800071b6:	c0 30       	breq	800071bc <logFromISR+0x100>
800071b8:	0a 94       	mov	r4,r5
800071ba:	c9 8b       	rjmp	800070ea <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800071bc:	fa c7 fe f4 	sub	r7,sp,-268
800071c0:	1a d7       	st.w	--sp,r7
800071c2:	49 ab       	lddpc	r11,80007228 <logFromISR+0x16c>
800071c4:	0e 9c       	mov	r12,r7
800071c6:	f0 1f 00 17 	mcall	80007220 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800071ca:	5c 5c       	castu.b	r12
800071cc:	f8 c6 ff ff 	sub	r6,r12,-1
800071d0:	0c 9c       	mov	r12,r6
800071d2:	f0 1f 00 17 	mcall	8000722c <logFromISR+0x170>
800071d6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800071d8:	0c 9a       	mov	r10,r6
800071da:	0e 9b       	mov	r11,r7
800071dc:	f0 1f 00 15 	mcall	80007230 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800071e0:	30 09       	mov	r9,0
800071e2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800071e4:	fa ca fe f8 	sub	r10,sp,-264
800071e8:	fa cb fe f4 	sub	r11,sp,-268
800071ec:	49 28       	lddpc	r8,80007234 <logFromISR+0x178>
800071ee:	70 0c       	ld.w	r12,r8[0x0]
800071f0:	f0 1f 00 12 	mcall	80007238 <logFromISR+0x17c>
800071f4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800071f6:	fe 3d fd f4 	sub	sp,-524
800071fa:	d8 32       	popm	r0-r7,pc
800071fc:	80 00       	ld.sh	r0,r0[0x0]
800071fe:	78 f4       	ld.w	r4,r12[0x3c]
80007200:	00 00       	add	r0,r0
80007202:	0d 65       	ld.uh	r5,--r6
80007204:	80 00       	ld.sh	r0,r0[0x0]
80007206:	db 94       	*unknown*
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	6e 56       	ld.w	r6,r7[0x14]
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	6d a4       	ld.w	r4,r6[0x68]
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	6d a0       	ld.w	r0,r6[0x68]
80007214:	80 00       	ld.sh	r0,r0[0x0]
80007216:	dd 00       	acall	0xd0
80007218:	80 00       	ld.sh	r0,r0[0x0]
8000721a:	6f 30       	ld.w	r0,r7[0x4c]
8000721c:	80 00       	ld.sh	r0,r0[0x0]
8000721e:	dd 10       	acall	0xd1
80007220:	80 00       	ld.sh	r0,r0[0x0]
80007222:	7b e4       	ld.w	r4,sp[0x78]
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	dd 18       	*unknown*
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	dd 20       	acall	0xd2
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	5f 8c       	srls	r12
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	77 ac       	ld.w	r12,r11[0x68]
80007234:	00 00       	add	r0,r0
80007236:	53 50       	stdsp	sp[0xd4],r0
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	62 90       	ld.w	r0,r1[0x24]

8000723c <log_init>:
		
	return str;
}

void log_init(void)
{
8000723c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000723e:	30 2b       	mov	r11,2
80007240:	48 fc       	lddpc	r12,8000727c <log_init+0x40>
80007242:	f0 1f 00 10 	mcall	80007280 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007246:	e0 6a 36 00 	mov	r10,13824
8000724a:	ea 1a 01 6e 	orh	r10,0x16e
8000724e:	48 eb       	lddpc	r11,80007284 <log_init+0x48>
80007250:	fe 7c 18 00 	mov	r12,-59392
80007254:	f0 1f 00 0d 	mcall	80007288 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007258:	30 4b       	mov	r11,4
8000725a:	33 2c       	mov	r12,50
8000725c:	f0 1f 00 0c 	mcall	8000728c <log_init+0x50>
80007260:	48 c8       	lddpc	r8,80007290 <log_init+0x54>
80007262:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007264:	30 09       	mov	r9,0
80007266:	1a d9       	st.w	--sp,r9
80007268:	1a d9       	st.w	--sp,r9
8000726a:	1a d9       	st.w	--sp,r9
8000726c:	30 28       	mov	r8,2
8000726e:	36 4a       	mov	r10,100
80007270:	48 9b       	lddpc	r11,80007294 <log_init+0x58>
80007272:	48 ac       	lddpc	r12,80007298 <log_init+0x5c>
80007274:	f0 1f 00 0a 	mcall	8000729c <log_init+0x60>
80007278:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000727a:	d8 02       	popm	pc
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	dd 2c       	*unknown*
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	54 6c       	stdsp	sp[0x118],r12
80007284:	80 00       	ld.sh	r0,r0[0x0]
80007286:	dc e4       	*unknown*
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	5a f0       	cp.w	r0,-17
8000728c:	80 00       	ld.sh	r0,r0[0x0]
8000728e:	64 38       	ld.w	r8,r2[0xc]
80007290:	00 00       	add	r0,r0
80007292:	53 50       	stdsp	sp[0xd4],r0
80007294:	80 00       	ld.sh	r0,r0[0x0]
80007296:	dd 28       	*unknown*
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	72 a0       	ld.w	r0,r9[0x28]
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	6b 6c       	ld.w	r12,r5[0x58]

800072a0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800072a0:	eb cd 40 f8 	pushm	r3-r7,lr
800072a4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072a6:	48 c7       	lddpc	r7,800072d4 <task_log+0x34>
800072a8:	30 05       	mov	r5,0
800072aa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800072ac:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072b0:	0a 99       	mov	r9,r5
800072b2:	08 9a       	mov	r10,r4
800072b4:	1a 9b       	mov	r11,sp
800072b6:	6e 0c       	ld.w	r12,r7[0x0]
800072b8:	f0 1f 00 08 	mcall	800072d8 <task_log+0x38>
800072bc:	58 1c       	cp.w	r12,1
800072be:	cf 91       	brne	800072b0 <task_log+0x10>
		{
			if( NULL != str)
800072c0:	40 0b       	lddsp	r11,sp[0x0]
800072c2:	58 0b       	cp.w	r11,0
800072c4:	cf 60       	breq	800072b0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800072c6:	06 9c       	mov	r12,r3
800072c8:	f0 1f 00 05 	mcall	800072dc <task_log+0x3c>
				vPortFree(str);
800072cc:	40 0c       	lddsp	r12,sp[0x0]
800072ce:	f0 1f 00 05 	mcall	800072e0 <task_log+0x40>
800072d2:	ce fb       	rjmp	800072b0 <task_log+0x10>
800072d4:	00 00       	add	r0,r0
800072d6:	53 50       	stdsp	sp[0xd4],r0
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	60 d4       	ld.w	r4,r0[0x34]
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	5a a0       	cp.w	r0,-22
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	5f 64       	srmi	r4

800072e4 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800072e4:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800072e6:	fe 78 10 00 	mov	r8,-61440
800072ea:	30 19       	mov	r9,1
800072ec:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800072f0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800072f4:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800072f8:	d3 03       	ssrf	0x10
	local_start_pll0();
800072fa:	f0 1f 00 0c 	mcall	80007328 <main+0x44>
		
	INTC_init_interrupts();
800072fe:	f0 1f 00 0c 	mcall	8000732c <main+0x48>
		
	log_init();
80007302:	f0 1f 00 0c 	mcall	80007330 <main+0x4c>
	log("----start debug----");
80007306:	48 cc       	lddpc	r12,80007334 <main+0x50>
80007308:	f0 1f 00 0c 	mcall	80007338 <main+0x54>
	
	xg_flashc_init();
8000730c:	f0 1f 00 0c 	mcall	8000733c <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007310:	f0 1f 00 0c 	mcall	80007340 <main+0x5c>
		
	app_init();
80007314:	f0 1f 00 0c 	mcall	80007344 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007318:	f0 1f 00 0c 	mcall	80007348 <main+0x64>

	local_start_timer();
8000731c:	f0 1f 00 0c 	mcall	8000734c <main+0x68>
		
	vTaskStartScheduler();
80007320:	f0 1f 00 0c 	mcall	80007350 <main+0x6c>
	return 0;
	
}
80007324:	d8 0a       	popm	pc,r12=0
80007326:	00 00       	add	r0,r0
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	52 d8       	stdsp	sp[0xb4],r8
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	55 70       	stdsp	sp[0x15c],r0
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	72 3c       	ld.w	r12,r9[0xc]
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	dd 3c       	*unknown*
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	6f 30       	ld.w	r0,r7[0x4c]
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	53 6c       	stdsp	sp[0xd8],r12
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	52 38       	stdsp	sp[0x8c],r8
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	20 3c       	sub	r12,3
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	41 00       	lddsp	r0,sp[0x40]
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	52 ac       	stdsp	sp[0xa8],r12
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	6d 54       	ld.w	r4,r6[0x54]

80007354 <free>:
80007354:	d4 01       	pushm	lr
80007356:	e0 68 0a 3c 	mov	r8,2620
8000735a:	18 9b       	mov	r11,r12
8000735c:	70 0c       	ld.w	r12,r8[0x0]
8000735e:	e0 a0 1e 61 	rcall	8000b020 <_free_r>
80007362:	d8 02       	popm	pc

80007364 <malloc>:
80007364:	d4 01       	pushm	lr
80007366:	e0 68 0a 3c 	mov	r8,2620
8000736a:	18 9b       	mov	r11,r12
8000736c:	70 0c       	ld.w	r12,r8[0x0]
8000736e:	c0 3c       	rcall	80007374 <_malloc_r>
80007370:	d8 02       	popm	pc
80007372:	d7 03       	nop

80007374 <_malloc_r>:
80007374:	d4 31       	pushm	r0-r7,lr
80007376:	f6 c8 ff f5 	sub	r8,r11,-11
8000737a:	18 95       	mov	r5,r12
8000737c:	10 97       	mov	r7,r8
8000737e:	e0 17 ff f8 	andl	r7,0xfff8
80007382:	59 68       	cp.w	r8,22
80007384:	f9 b7 08 10 	movls	r7,16
80007388:	16 37       	cp.w	r7,r11
8000738a:	5f 38       	srlo	r8
8000738c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007390:	c0 50       	breq	8000739a <_malloc_r+0x26>
80007392:	30 c8       	mov	r8,12
80007394:	99 38       	st.w	r12[0xc],r8
80007396:	e0 8f 01 fa 	bral	8000778a <_malloc_r+0x416>
8000739a:	fe b0 f5 9b 	rcall	80005ed0 <__malloc_lock>
8000739e:	e0 47 01 f7 	cp.w	r7,503
800073a2:	e0 8b 00 1d 	brhi	800073dc <_malloc_r+0x68>
800073a6:	ee 03 16 03 	lsr	r3,r7,0x3
800073aa:	e0 68 05 3c 	mov	r8,1340
800073ae:	f0 03 00 38 	add	r8,r8,r3<<0x3
800073b2:	70 36       	ld.w	r6,r8[0xc]
800073b4:	10 36       	cp.w	r6,r8
800073b6:	c0 61       	brne	800073c2 <_malloc_r+0x4e>
800073b8:	ec c8 ff f8 	sub	r8,r6,-8
800073bc:	70 36       	ld.w	r6,r8[0xc]
800073be:	10 36       	cp.w	r6,r8
800073c0:	c0 c0       	breq	800073d8 <_malloc_r+0x64>
800073c2:	6c 18       	ld.w	r8,r6[0x4]
800073c4:	e0 18 ff fc 	andl	r8,0xfffc
800073c8:	6c 3a       	ld.w	r10,r6[0xc]
800073ca:	ec 08 00 09 	add	r9,r6,r8
800073ce:	0a 9c       	mov	r12,r5
800073d0:	6c 28       	ld.w	r8,r6[0x8]
800073d2:	95 28       	st.w	r10[0x8],r8
800073d4:	91 3a       	st.w	r8[0xc],r10
800073d6:	c4 78       	rjmp	80007464 <_malloc_r+0xf0>
800073d8:	2f e3       	sub	r3,-2
800073da:	c4 d8       	rjmp	80007474 <_malloc_r+0x100>
800073dc:	ee 03 16 09 	lsr	r3,r7,0x9
800073e0:	c0 41       	brne	800073e8 <_malloc_r+0x74>
800073e2:	ee 03 16 03 	lsr	r3,r7,0x3
800073e6:	c2 68       	rjmp	80007432 <_malloc_r+0xbe>
800073e8:	58 43       	cp.w	r3,4
800073ea:	e0 8b 00 06 	brhi	800073f6 <_malloc_r+0x82>
800073ee:	ee 03 16 06 	lsr	r3,r7,0x6
800073f2:	2c 83       	sub	r3,-56
800073f4:	c1 f8       	rjmp	80007432 <_malloc_r+0xbe>
800073f6:	59 43       	cp.w	r3,20
800073f8:	e0 8b 00 04 	brhi	80007400 <_malloc_r+0x8c>
800073fc:	2a 53       	sub	r3,-91
800073fe:	c1 a8       	rjmp	80007432 <_malloc_r+0xbe>
80007400:	e0 43 00 54 	cp.w	r3,84
80007404:	e0 8b 00 06 	brhi	80007410 <_malloc_r+0x9c>
80007408:	ee 03 16 0c 	lsr	r3,r7,0xc
8000740c:	29 23       	sub	r3,-110
8000740e:	c1 28       	rjmp	80007432 <_malloc_r+0xbe>
80007410:	e0 43 01 54 	cp.w	r3,340
80007414:	e0 8b 00 06 	brhi	80007420 <_malloc_r+0xac>
80007418:	ee 03 16 0f 	lsr	r3,r7,0xf
8000741c:	28 93       	sub	r3,-119
8000741e:	c0 a8       	rjmp	80007432 <_malloc_r+0xbe>
80007420:	e0 43 05 54 	cp.w	r3,1364
80007424:	e0 88 00 04 	brls	8000742c <_malloc_r+0xb8>
80007428:	37 e3       	mov	r3,126
8000742a:	c0 48       	rjmp	80007432 <_malloc_r+0xbe>
8000742c:	ee 03 16 12 	lsr	r3,r7,0x12
80007430:	28 43       	sub	r3,-124
80007432:	e0 6a 05 3c 	mov	r10,1340
80007436:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000743a:	74 36       	ld.w	r6,r10[0xc]
8000743c:	c1 98       	rjmp	8000746e <_malloc_r+0xfa>
8000743e:	6c 19       	ld.w	r9,r6[0x4]
80007440:	e0 19 ff fc 	andl	r9,0xfffc
80007444:	f2 07 01 0b 	sub	r11,r9,r7
80007448:	58 fb       	cp.w	r11,15
8000744a:	e0 8a 00 04 	brle	80007452 <_malloc_r+0xde>
8000744e:	20 13       	sub	r3,1
80007450:	c1 18       	rjmp	80007472 <_malloc_r+0xfe>
80007452:	6c 38       	ld.w	r8,r6[0xc]
80007454:	58 0b       	cp.w	r11,0
80007456:	c0 b5       	brlt	8000746c <_malloc_r+0xf8>
80007458:	6c 2a       	ld.w	r10,r6[0x8]
8000745a:	ec 09 00 09 	add	r9,r6,r9
8000745e:	0a 9c       	mov	r12,r5
80007460:	91 2a       	st.w	r8[0x8],r10
80007462:	95 38       	st.w	r10[0xc],r8
80007464:	72 18       	ld.w	r8,r9[0x4]
80007466:	a1 a8       	sbr	r8,0x0
80007468:	93 18       	st.w	r9[0x4],r8
8000746a:	cb c8       	rjmp	800075e2 <_malloc_r+0x26e>
8000746c:	10 96       	mov	r6,r8
8000746e:	14 36       	cp.w	r6,r10
80007470:	ce 71       	brne	8000743e <_malloc_r+0xca>
80007472:	2f f3       	sub	r3,-1
80007474:	e0 6a 05 3c 	mov	r10,1340
80007478:	f4 cc ff f8 	sub	r12,r10,-8
8000747c:	78 26       	ld.w	r6,r12[0x8]
8000747e:	18 36       	cp.w	r6,r12
80007480:	c6 c0       	breq	80007558 <_malloc_r+0x1e4>
80007482:	6c 19       	ld.w	r9,r6[0x4]
80007484:	e0 19 ff fc 	andl	r9,0xfffc
80007488:	f2 07 01 08 	sub	r8,r9,r7
8000748c:	58 f8       	cp.w	r8,15
8000748e:	e0 89 00 8f 	brgt	800075ac <_malloc_r+0x238>
80007492:	99 3c       	st.w	r12[0xc],r12
80007494:	99 2c       	st.w	r12[0x8],r12
80007496:	58 08       	cp.w	r8,0
80007498:	c0 55       	brlt	800074a2 <_malloc_r+0x12e>
8000749a:	ec 09 00 09 	add	r9,r6,r9
8000749e:	0a 9c       	mov	r12,r5
800074a0:	ce 2b       	rjmp	80007464 <_malloc_r+0xf0>
800074a2:	e0 49 01 ff 	cp.w	r9,511
800074a6:	e0 8b 00 13 	brhi	800074cc <_malloc_r+0x158>
800074aa:	a3 99       	lsr	r9,0x3
800074ac:	f4 09 00 38 	add	r8,r10,r9<<0x3
800074b0:	70 2b       	ld.w	r11,r8[0x8]
800074b2:	8d 38       	st.w	r6[0xc],r8
800074b4:	8d 2b       	st.w	r6[0x8],r11
800074b6:	97 36       	st.w	r11[0xc],r6
800074b8:	91 26       	st.w	r8[0x8],r6
800074ba:	a3 49       	asr	r9,0x2
800074bc:	74 18       	ld.w	r8,r10[0x4]
800074be:	30 1b       	mov	r11,1
800074c0:	f6 09 09 49 	lsl	r9,r11,r9
800074c4:	f1 e9 10 09 	or	r9,r8,r9
800074c8:	95 19       	st.w	r10[0x4],r9
800074ca:	c4 78       	rjmp	80007558 <_malloc_r+0x1e4>
800074cc:	f2 0a 16 09 	lsr	r10,r9,0x9
800074d0:	58 4a       	cp.w	r10,4
800074d2:	e0 8b 00 07 	brhi	800074e0 <_malloc_r+0x16c>
800074d6:	f2 0a 16 06 	lsr	r10,r9,0x6
800074da:	2c 8a       	sub	r10,-56
800074dc:	c2 08       	rjmp	8000751c <_malloc_r+0x1a8>
800074de:	d7 03       	nop
800074e0:	59 4a       	cp.w	r10,20
800074e2:	e0 8b 00 04 	brhi	800074ea <_malloc_r+0x176>
800074e6:	2a 5a       	sub	r10,-91
800074e8:	c1 a8       	rjmp	8000751c <_malloc_r+0x1a8>
800074ea:	e0 4a 00 54 	cp.w	r10,84
800074ee:	e0 8b 00 06 	brhi	800074fa <_malloc_r+0x186>
800074f2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800074f6:	29 2a       	sub	r10,-110
800074f8:	c1 28       	rjmp	8000751c <_malloc_r+0x1a8>
800074fa:	e0 4a 01 54 	cp.w	r10,340
800074fe:	e0 8b 00 06 	brhi	8000750a <_malloc_r+0x196>
80007502:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007506:	28 9a       	sub	r10,-119
80007508:	c0 a8       	rjmp	8000751c <_malloc_r+0x1a8>
8000750a:	e0 4a 05 54 	cp.w	r10,1364
8000750e:	e0 88 00 04 	brls	80007516 <_malloc_r+0x1a2>
80007512:	37 ea       	mov	r10,126
80007514:	c0 48       	rjmp	8000751c <_malloc_r+0x1a8>
80007516:	f2 0a 16 12 	lsr	r10,r9,0x12
8000751a:	28 4a       	sub	r10,-124
8000751c:	e0 6b 05 3c 	mov	r11,1340
80007520:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007524:	68 28       	ld.w	r8,r4[0x8]
80007526:	08 38       	cp.w	r8,r4
80007528:	c0 e1       	brne	80007544 <_malloc_r+0x1d0>
8000752a:	76 19       	ld.w	r9,r11[0x4]
8000752c:	a3 4a       	asr	r10,0x2
8000752e:	30 1e       	mov	lr,1
80007530:	fc 0a 09 4a 	lsl	r10,lr,r10
80007534:	f3 ea 10 0a 	or	r10,r9,r10
80007538:	10 99       	mov	r9,r8
8000753a:	97 1a       	st.w	r11[0x4],r10
8000753c:	c0 a8       	rjmp	80007550 <_malloc_r+0x1dc>
8000753e:	70 28       	ld.w	r8,r8[0x8]
80007540:	08 38       	cp.w	r8,r4
80007542:	c0 60       	breq	8000754e <_malloc_r+0x1da>
80007544:	70 1a       	ld.w	r10,r8[0x4]
80007546:	e0 1a ff fc 	andl	r10,0xfffc
8000754a:	14 39       	cp.w	r9,r10
8000754c:	cf 93       	brcs	8000753e <_malloc_r+0x1ca>
8000754e:	70 39       	ld.w	r9,r8[0xc]
80007550:	8d 39       	st.w	r6[0xc],r9
80007552:	8d 28       	st.w	r6[0x8],r8
80007554:	91 36       	st.w	r8[0xc],r6
80007556:	93 26       	st.w	r9[0x8],r6
80007558:	e6 08 14 02 	asr	r8,r3,0x2
8000755c:	30 1b       	mov	r11,1
8000755e:	e0 64 05 3c 	mov	r4,1340
80007562:	f6 08 09 4b 	lsl	r11,r11,r8
80007566:	68 18       	ld.w	r8,r4[0x4]
80007568:	10 3b       	cp.w	r11,r8
8000756a:	e0 8b 00 6b 	brhi	80007640 <_malloc_r+0x2cc>
8000756e:	f7 e8 00 09 	and	r9,r11,r8
80007572:	c0 b1       	brne	80007588 <_malloc_r+0x214>
80007574:	e0 13 ff fc 	andl	r3,0xfffc
80007578:	a1 7b       	lsl	r11,0x1
8000757a:	2f c3       	sub	r3,-4
8000757c:	c0 38       	rjmp	80007582 <_malloc_r+0x20e>
8000757e:	2f c3       	sub	r3,-4
80007580:	a1 7b       	lsl	r11,0x1
80007582:	f7 e8 00 09 	and	r9,r11,r8
80007586:	cf c0       	breq	8000757e <_malloc_r+0x20a>
80007588:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000758c:	06 92       	mov	r2,r3
8000758e:	1c 91       	mov	r1,lr
80007590:	62 36       	ld.w	r6,r1[0xc]
80007592:	c2 e8       	rjmp	800075ee <_malloc_r+0x27a>
80007594:	6c 1a       	ld.w	r10,r6[0x4]
80007596:	e0 1a ff fc 	andl	r10,0xfffc
8000759a:	f4 07 01 08 	sub	r8,r10,r7
8000759e:	58 f8       	cp.w	r8,15
800075a0:	e0 8a 00 15 	brle	800075ca <_malloc_r+0x256>
800075a4:	6c 3a       	ld.w	r10,r6[0xc]
800075a6:	6c 29       	ld.w	r9,r6[0x8]
800075a8:	95 29       	st.w	r10[0x8],r9
800075aa:	93 3a       	st.w	r9[0xc],r10
800075ac:	0e 99       	mov	r9,r7
800075ae:	ec 07 00 07 	add	r7,r6,r7
800075b2:	a1 a9       	sbr	r9,0x0
800075b4:	99 37       	st.w	r12[0xc],r7
800075b6:	99 27       	st.w	r12[0x8],r7
800075b8:	8d 19       	st.w	r6[0x4],r9
800075ba:	ee 08 09 08 	st.w	r7[r8],r8
800075be:	8f 2c       	st.w	r7[0x8],r12
800075c0:	8f 3c       	st.w	r7[0xc],r12
800075c2:	a1 a8       	sbr	r8,0x0
800075c4:	0a 9c       	mov	r12,r5
800075c6:	8f 18       	st.w	r7[0x4],r8
800075c8:	c0 d8       	rjmp	800075e2 <_malloc_r+0x26e>
800075ca:	6c 39       	ld.w	r9,r6[0xc]
800075cc:	58 08       	cp.w	r8,0
800075ce:	c0 f5       	brlt	800075ec <_malloc_r+0x278>
800075d0:	ec 0a 00 0a 	add	r10,r6,r10
800075d4:	74 18       	ld.w	r8,r10[0x4]
800075d6:	a1 a8       	sbr	r8,0x0
800075d8:	0a 9c       	mov	r12,r5
800075da:	95 18       	st.w	r10[0x4],r8
800075dc:	6c 28       	ld.w	r8,r6[0x8]
800075de:	93 28       	st.w	r9[0x8],r8
800075e0:	91 39       	st.w	r8[0xc],r9
800075e2:	fe b0 f4 7d 	rcall	80005edc <__malloc_unlock>
800075e6:	ec cc ff f8 	sub	r12,r6,-8
800075ea:	d8 32       	popm	r0-r7,pc
800075ec:	12 96       	mov	r6,r9
800075ee:	02 36       	cp.w	r6,r1
800075f0:	cd 21       	brne	80007594 <_malloc_r+0x220>
800075f2:	2f f2       	sub	r2,-1
800075f4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800075f8:	c0 30       	breq	800075fe <_malloc_r+0x28a>
800075fa:	2f 81       	sub	r1,-8
800075fc:	cc ab       	rjmp	80007590 <_malloc_r+0x21c>
800075fe:	1c 98       	mov	r8,lr
80007600:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007604:	c0 81       	brne	80007614 <_malloc_r+0x2a0>
80007606:	68 19       	ld.w	r9,r4[0x4]
80007608:	f6 08 11 ff 	rsub	r8,r11,-1
8000760c:	f3 e8 00 08 	and	r8,r9,r8
80007610:	89 18       	st.w	r4[0x4],r8
80007612:	c0 78       	rjmp	80007620 <_malloc_r+0x2ac>
80007614:	f0 c9 00 08 	sub	r9,r8,8
80007618:	20 13       	sub	r3,1
8000761a:	70 08       	ld.w	r8,r8[0x0]
8000761c:	12 38       	cp.w	r8,r9
8000761e:	cf 10       	breq	80007600 <_malloc_r+0x28c>
80007620:	a1 7b       	lsl	r11,0x1
80007622:	68 18       	ld.w	r8,r4[0x4]
80007624:	10 3b       	cp.w	r11,r8
80007626:	e0 8b 00 0d 	brhi	80007640 <_malloc_r+0x2cc>
8000762a:	58 0b       	cp.w	r11,0
8000762c:	c0 a0       	breq	80007640 <_malloc_r+0x2cc>
8000762e:	04 93       	mov	r3,r2
80007630:	c0 38       	rjmp	80007636 <_malloc_r+0x2c2>
80007632:	2f c3       	sub	r3,-4
80007634:	a1 7b       	lsl	r11,0x1
80007636:	f7 e8 00 09 	and	r9,r11,r8
8000763a:	ca 71       	brne	80007588 <_malloc_r+0x214>
8000763c:	cf bb       	rjmp	80007632 <_malloc_r+0x2be>
8000763e:	d7 03       	nop
80007640:	68 23       	ld.w	r3,r4[0x8]
80007642:	66 12       	ld.w	r2,r3[0x4]
80007644:	e0 12 ff fc 	andl	r2,0xfffc
80007648:	0e 32       	cp.w	r2,r7
8000764a:	5f 39       	srlo	r9
8000764c:	e4 07 01 08 	sub	r8,r2,r7
80007650:	58 f8       	cp.w	r8,15
80007652:	5f aa       	srle	r10
80007654:	f5 e9 10 09 	or	r9,r10,r9
80007658:	e0 80 00 9a 	breq	8000778c <_malloc_r+0x418>
8000765c:	e0 68 0d 70 	mov	r8,3440
80007660:	70 01       	ld.w	r1,r8[0x0]
80007662:	e0 68 09 48 	mov	r8,2376
80007666:	2f 01       	sub	r1,-16
80007668:	70 08       	ld.w	r8,r8[0x0]
8000766a:	0e 01       	add	r1,r7
8000766c:	5b f8       	cp.w	r8,-1
8000766e:	c0 40       	breq	80007676 <_malloc_r+0x302>
80007670:	28 11       	sub	r1,-127
80007672:	e0 11 ff 80 	andl	r1,0xff80
80007676:	02 9b       	mov	r11,r1
80007678:	0a 9c       	mov	r12,r5
8000767a:	e0 a0 02 a5 	rcall	80007bc4 <_sbrk_r>
8000767e:	18 96       	mov	r6,r12
80007680:	5b fc       	cp.w	r12,-1
80007682:	c7 50       	breq	8000776c <_malloc_r+0x3f8>
80007684:	e6 02 00 08 	add	r8,r3,r2
80007688:	10 3c       	cp.w	r12,r8
8000768a:	c0 32       	brcc	80007690 <_malloc_r+0x31c>
8000768c:	08 33       	cp.w	r3,r4
8000768e:	c6 f1       	brne	8000776c <_malloc_r+0x3f8>
80007690:	e0 6a 0d 74 	mov	r10,3444
80007694:	74 09       	ld.w	r9,r10[0x0]
80007696:	e2 09 00 09 	add	r9,r1,r9
8000769a:	95 09       	st.w	r10[0x0],r9
8000769c:	10 36       	cp.w	r6,r8
8000769e:	c0 a1       	brne	800076b2 <_malloc_r+0x33e>
800076a0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800076a4:	c0 71       	brne	800076b2 <_malloc_r+0x33e>
800076a6:	e2 02 00 02 	add	r2,r1,r2
800076aa:	68 28       	ld.w	r8,r4[0x8]
800076ac:	a1 a2       	sbr	r2,0x0
800076ae:	91 12       	st.w	r8[0x4],r2
800076b0:	c4 f8       	rjmp	8000774e <_malloc_r+0x3da>
800076b2:	e0 6a 09 48 	mov	r10,2376
800076b6:	74 0b       	ld.w	r11,r10[0x0]
800076b8:	5b fb       	cp.w	r11,-1
800076ba:	c0 31       	brne	800076c0 <_malloc_r+0x34c>
800076bc:	95 06       	st.w	r10[0x0],r6
800076be:	c0 78       	rjmp	800076cc <_malloc_r+0x358>
800076c0:	ec 09 00 09 	add	r9,r6,r9
800076c4:	e0 6a 0d 74 	mov	r10,3444
800076c8:	10 19       	sub	r9,r8
800076ca:	95 09       	st.w	r10[0x0],r9
800076cc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800076d0:	f0 09 11 08 	rsub	r9,r8,8
800076d4:	58 08       	cp.w	r8,0
800076d6:	f2 08 17 10 	movne	r8,r9
800076da:	ed d8 e1 06 	addne	r6,r6,r8
800076de:	28 08       	sub	r8,-128
800076e0:	ec 01 00 01 	add	r1,r6,r1
800076e4:	0a 9c       	mov	r12,r5
800076e6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800076ea:	f0 01 01 01 	sub	r1,r8,r1
800076ee:	02 9b       	mov	r11,r1
800076f0:	e0 a0 02 6a 	rcall	80007bc4 <_sbrk_r>
800076f4:	e0 68 0d 74 	mov	r8,3444
800076f8:	5b fc       	cp.w	r12,-1
800076fa:	ec 0c 17 00 	moveq	r12,r6
800076fe:	f9 b1 00 00 	moveq	r1,0
80007702:	70 09       	ld.w	r9,r8[0x0]
80007704:	0c 1c       	sub	r12,r6
80007706:	89 26       	st.w	r4[0x8],r6
80007708:	02 0c       	add	r12,r1
8000770a:	12 01       	add	r1,r9
8000770c:	a1 ac       	sbr	r12,0x0
8000770e:	91 01       	st.w	r8[0x0],r1
80007710:	8d 1c       	st.w	r6[0x4],r12
80007712:	08 33       	cp.w	r3,r4
80007714:	c1 d0       	breq	8000774e <_malloc_r+0x3da>
80007716:	58 f2       	cp.w	r2,15
80007718:	e0 8b 00 05 	brhi	80007722 <_malloc_r+0x3ae>
8000771c:	30 18       	mov	r8,1
8000771e:	8d 18       	st.w	r6[0x4],r8
80007720:	c2 68       	rjmp	8000776c <_malloc_r+0x3f8>
80007722:	30 59       	mov	r9,5
80007724:	20 c2       	sub	r2,12
80007726:	e0 12 ff f8 	andl	r2,0xfff8
8000772a:	e6 02 00 08 	add	r8,r3,r2
8000772e:	91 29       	st.w	r8[0x8],r9
80007730:	91 19       	st.w	r8[0x4],r9
80007732:	66 18       	ld.w	r8,r3[0x4]
80007734:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007738:	e5 e8 10 08 	or	r8,r2,r8
8000773c:	87 18       	st.w	r3[0x4],r8
8000773e:	58 f2       	cp.w	r2,15
80007740:	e0 88 00 07 	brls	8000774e <_malloc_r+0x3da>
80007744:	e6 cb ff f8 	sub	r11,r3,-8
80007748:	0a 9c       	mov	r12,r5
8000774a:	e0 a0 1c 6b 	rcall	8000b020 <_free_r>
8000774e:	e0 69 0d 6c 	mov	r9,3436
80007752:	72 0a       	ld.w	r10,r9[0x0]
80007754:	e0 68 0d 74 	mov	r8,3444
80007758:	70 08       	ld.w	r8,r8[0x0]
8000775a:	14 38       	cp.w	r8,r10
8000775c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007760:	e0 69 0d 68 	mov	r9,3432
80007764:	72 0a       	ld.w	r10,r9[0x0]
80007766:	14 38       	cp.w	r8,r10
80007768:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000776c:	68 28       	ld.w	r8,r4[0x8]
8000776e:	70 18       	ld.w	r8,r8[0x4]
80007770:	e0 18 ff fc 	andl	r8,0xfffc
80007774:	0e 38       	cp.w	r8,r7
80007776:	5f 39       	srlo	r9
80007778:	0e 18       	sub	r8,r7
8000777a:	58 f8       	cp.w	r8,15
8000777c:	5f aa       	srle	r10
8000777e:	f5 e9 10 09 	or	r9,r10,r9
80007782:	c0 50       	breq	8000778c <_malloc_r+0x418>
80007784:	0a 9c       	mov	r12,r5
80007786:	fe b0 f3 ab 	rcall	80005edc <__malloc_unlock>
8000778a:	d8 3a       	popm	r0-r7,pc,r12=0
8000778c:	68 26       	ld.w	r6,r4[0x8]
8000778e:	a1 a8       	sbr	r8,0x0
80007790:	0e 99       	mov	r9,r7
80007792:	a1 a9       	sbr	r9,0x0
80007794:	8d 19       	st.w	r6[0x4],r9
80007796:	ec 07 00 07 	add	r7,r6,r7
8000779a:	0a 9c       	mov	r12,r5
8000779c:	89 27       	st.w	r4[0x8],r7
8000779e:	8f 18       	st.w	r7[0x4],r8
800077a0:	fe b0 f3 9e 	rcall	80005edc <__malloc_unlock>
800077a4:	ec cc ff f8 	sub	r12,r6,-8
800077a8:	d8 32       	popm	r0-r7,pc
800077aa:	d7 03       	nop

800077ac <memcpy>:
800077ac:	58 8a       	cp.w	r10,8
800077ae:	c2 f5       	brlt	8000780c <memcpy+0x60>
800077b0:	f9 eb 10 09 	or	r9,r12,r11
800077b4:	e2 19 00 03 	andl	r9,0x3,COH
800077b8:	e0 81 00 97 	brne	800078e6 <memcpy+0x13a>
800077bc:	e0 4a 00 20 	cp.w	r10,32
800077c0:	c3 b4       	brge	80007836 <memcpy+0x8a>
800077c2:	f4 08 14 02 	asr	r8,r10,0x2
800077c6:	f0 09 11 08 	rsub	r9,r8,8
800077ca:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800077ce:	76 69       	ld.w	r9,r11[0x18]
800077d0:	99 69       	st.w	r12[0x18],r9
800077d2:	76 59       	ld.w	r9,r11[0x14]
800077d4:	99 59       	st.w	r12[0x14],r9
800077d6:	76 49       	ld.w	r9,r11[0x10]
800077d8:	99 49       	st.w	r12[0x10],r9
800077da:	76 39       	ld.w	r9,r11[0xc]
800077dc:	99 39       	st.w	r12[0xc],r9
800077de:	76 29       	ld.w	r9,r11[0x8]
800077e0:	99 29       	st.w	r12[0x8],r9
800077e2:	76 19       	ld.w	r9,r11[0x4]
800077e4:	99 19       	st.w	r12[0x4],r9
800077e6:	76 09       	ld.w	r9,r11[0x0]
800077e8:	99 09       	st.w	r12[0x0],r9
800077ea:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800077ee:	f8 08 00 28 	add	r8,r12,r8<<0x2
800077f2:	e0 1a 00 03 	andl	r10,0x3
800077f6:	f4 0a 11 04 	rsub	r10,r10,4
800077fa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800077fe:	17 a9       	ld.ub	r9,r11[0x2]
80007800:	b0 a9       	st.b	r8[0x2],r9
80007802:	17 99       	ld.ub	r9,r11[0x1]
80007804:	b0 99       	st.b	r8[0x1],r9
80007806:	17 89       	ld.ub	r9,r11[0x0]
80007808:	b0 89       	st.b	r8[0x0],r9
8000780a:	5e fc       	retal	r12
8000780c:	f4 0a 11 09 	rsub	r10,r10,9
80007810:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007814:	17 f9       	ld.ub	r9,r11[0x7]
80007816:	b8 f9       	st.b	r12[0x7],r9
80007818:	17 e9       	ld.ub	r9,r11[0x6]
8000781a:	b8 e9       	st.b	r12[0x6],r9
8000781c:	17 d9       	ld.ub	r9,r11[0x5]
8000781e:	b8 d9       	st.b	r12[0x5],r9
80007820:	17 c9       	ld.ub	r9,r11[0x4]
80007822:	b8 c9       	st.b	r12[0x4],r9
80007824:	17 b9       	ld.ub	r9,r11[0x3]
80007826:	b8 b9       	st.b	r12[0x3],r9
80007828:	17 a9       	ld.ub	r9,r11[0x2]
8000782a:	b8 a9       	st.b	r12[0x2],r9
8000782c:	17 99       	ld.ub	r9,r11[0x1]
8000782e:	b8 99       	st.b	r12[0x1],r9
80007830:	17 89       	ld.ub	r9,r11[0x0]
80007832:	b8 89       	st.b	r12[0x0],r9
80007834:	5e fc       	retal	r12
80007836:	eb cd 40 c0 	pushm	r6-r7,lr
8000783a:	18 99       	mov	r9,r12
8000783c:	22 0a       	sub	r10,32
8000783e:	b7 07       	ld.d	r6,r11++
80007840:	b3 26       	st.d	r9++,r6
80007842:	b7 07       	ld.d	r6,r11++
80007844:	b3 26       	st.d	r9++,r6
80007846:	b7 07       	ld.d	r6,r11++
80007848:	b3 26       	st.d	r9++,r6
8000784a:	b7 07       	ld.d	r6,r11++
8000784c:	b3 26       	st.d	r9++,r6
8000784e:	22 0a       	sub	r10,32
80007850:	cf 74       	brge	8000783e <memcpy+0x92>
80007852:	2f 0a       	sub	r10,-16
80007854:	c0 65       	brlt	80007860 <memcpy+0xb4>
80007856:	b7 07       	ld.d	r6,r11++
80007858:	b3 26       	st.d	r9++,r6
8000785a:	b7 07       	ld.d	r6,r11++
8000785c:	b3 26       	st.d	r9++,r6
8000785e:	21 0a       	sub	r10,16
80007860:	5c 3a       	neg	r10
80007862:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007866:	d7 03       	nop
80007868:	d7 03       	nop
8000786a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000786e:	f3 66 00 0e 	st.b	r9[14],r6
80007872:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007876:	f3 66 00 0d 	st.b	r9[13],r6
8000787a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000787e:	f3 66 00 0c 	st.b	r9[12],r6
80007882:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007886:	f3 66 00 0b 	st.b	r9[11],r6
8000788a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000788e:	f3 66 00 0a 	st.b	r9[10],r6
80007892:	f7 36 00 09 	ld.ub	r6,r11[9]
80007896:	f3 66 00 09 	st.b	r9[9],r6
8000789a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000789e:	f3 66 00 08 	st.b	r9[8],r6
800078a2:	f7 36 00 07 	ld.ub	r6,r11[7]
800078a6:	f3 66 00 07 	st.b	r9[7],r6
800078aa:	f7 36 00 06 	ld.ub	r6,r11[6]
800078ae:	f3 66 00 06 	st.b	r9[6],r6
800078b2:	f7 36 00 05 	ld.ub	r6,r11[5]
800078b6:	f3 66 00 05 	st.b	r9[5],r6
800078ba:	f7 36 00 04 	ld.ub	r6,r11[4]
800078be:	f3 66 00 04 	st.b	r9[4],r6
800078c2:	f7 36 00 03 	ld.ub	r6,r11[3]
800078c6:	f3 66 00 03 	st.b	r9[3],r6
800078ca:	f7 36 00 02 	ld.ub	r6,r11[2]
800078ce:	f3 66 00 02 	st.b	r9[2],r6
800078d2:	f7 36 00 01 	ld.ub	r6,r11[1]
800078d6:	f3 66 00 01 	st.b	r9[1],r6
800078da:	f7 36 00 00 	ld.ub	r6,r11[0]
800078de:	f3 66 00 00 	st.b	r9[0],r6
800078e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078e6:	20 1a       	sub	r10,1
800078e8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800078ec:	f8 0a 0b 09 	st.b	r12[r10],r9
800078f0:	cf b1       	brne	800078e6 <memcpy+0x13a>
800078f2:	5e fc       	retal	r12

800078f4 <memset>:
800078f4:	18 98       	mov	r8,r12
800078f6:	c0 38       	rjmp	800078fc <memset+0x8>
800078f8:	10 cb       	st.b	r8++,r11
800078fa:	20 1a       	sub	r10,1
800078fc:	58 0a       	cp.w	r10,0
800078fe:	cf d1       	brne	800078f8 <memset+0x4>
80007900:	5e fc       	retal	r12
80007902:	d7 03       	nop

80007904 <_realloc_r>:
80007904:	d4 31       	pushm	r0-r7,lr
80007906:	20 1d       	sub	sp,4
80007908:	16 94       	mov	r4,r11
8000790a:	18 92       	mov	r2,r12
8000790c:	14 9b       	mov	r11,r10
8000790e:	58 04       	cp.w	r4,0
80007910:	c0 51       	brne	8000791a <_realloc_r+0x16>
80007912:	fe b0 fd 31 	rcall	80007374 <_malloc_r>
80007916:	18 95       	mov	r5,r12
80007918:	c5 39       	rjmp	80007bbe <_realloc_r+0x2ba>
8000791a:	50 0a       	stdsp	sp[0x0],r10
8000791c:	fe b0 f2 da 	rcall	80005ed0 <__malloc_lock>
80007920:	40 0b       	lddsp	r11,sp[0x0]
80007922:	f6 c8 ff f5 	sub	r8,r11,-11
80007926:	e8 c1 00 08 	sub	r1,r4,8
8000792a:	10 96       	mov	r6,r8
8000792c:	62 1c       	ld.w	r12,r1[0x4]
8000792e:	e0 16 ff f8 	andl	r6,0xfff8
80007932:	59 68       	cp.w	r8,22
80007934:	f9 b6 08 10 	movls	r6,16
80007938:	16 36       	cp.w	r6,r11
8000793a:	5f 38       	srlo	r8
8000793c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007940:	c0 50       	breq	8000794a <_realloc_r+0x46>
80007942:	30 c8       	mov	r8,12
80007944:	30 05       	mov	r5,0
80007946:	85 38       	st.w	r2[0xc],r8
80007948:	c3 b9       	rjmp	80007bbe <_realloc_r+0x2ba>
8000794a:	18 90       	mov	r0,r12
8000794c:	e0 10 ff fc 	andl	r0,0xfffc
80007950:	0c 30       	cp.w	r0,r6
80007952:	e0 84 01 0b 	brge	80007b68 <_realloc_r+0x264>
80007956:	e0 68 05 3c 	mov	r8,1340
8000795a:	e2 00 00 09 	add	r9,r1,r0
8000795e:	70 25       	ld.w	r5,r8[0x8]
80007960:	0a 39       	cp.w	r9,r5
80007962:	c0 90       	breq	80007974 <_realloc_r+0x70>
80007964:	72 1a       	ld.w	r10,r9[0x4]
80007966:	a1 ca       	cbr	r10,0x0
80007968:	f2 0a 00 0a 	add	r10,r9,r10
8000796c:	74 1a       	ld.w	r10,r10[0x4]
8000796e:	ed ba 00 00 	bld	r10,0x0
80007972:	c2 20       	breq	800079b6 <_realloc_r+0xb2>
80007974:	72 1a       	ld.w	r10,r9[0x4]
80007976:	e0 1a ff fc 	andl	r10,0xfffc
8000797a:	f4 00 00 03 	add	r3,r10,r0
8000797e:	0a 39       	cp.w	r9,r5
80007980:	c1 31       	brne	800079a6 <_realloc_r+0xa2>
80007982:	ec c7 ff f0 	sub	r7,r6,-16
80007986:	0e 33       	cp.w	r3,r7
80007988:	c1 95       	brlt	800079ba <_realloc_r+0xb6>
8000798a:	e2 06 00 09 	add	r9,r1,r6
8000798e:	0c 13       	sub	r3,r6
80007990:	a1 a3       	sbr	r3,0x0
80007992:	93 13       	st.w	r9[0x4],r3
80007994:	91 29       	st.w	r8[0x8],r9
80007996:	04 9c       	mov	r12,r2
80007998:	62 18       	ld.w	r8,r1[0x4]
8000799a:	08 95       	mov	r5,r4
8000799c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079a0:	10 46       	or	r6,r8
800079a2:	83 16       	st.w	r1[0x4],r6
800079a4:	c0 b9       	rjmp	80007bba <_realloc_r+0x2b6>
800079a6:	0c 33       	cp.w	r3,r6
800079a8:	c0 95       	brlt	800079ba <_realloc_r+0xb6>
800079aa:	72 28       	ld.w	r8,r9[0x8]
800079ac:	02 97       	mov	r7,r1
800079ae:	72 39       	ld.w	r9,r9[0xc]
800079b0:	93 28       	st.w	r9[0x8],r8
800079b2:	91 39       	st.w	r8[0xc],r9
800079b4:	cd c8       	rjmp	80007b6c <_realloc_r+0x268>
800079b6:	30 0a       	mov	r10,0
800079b8:	14 99       	mov	r9,r10
800079ba:	ed bc 00 00 	bld	r12,0x0
800079be:	e0 80 00 95 	breq	80007ae8 <_realloc_r+0x1e4>
800079c2:	62 07       	ld.w	r7,r1[0x0]
800079c4:	e2 07 01 07 	sub	r7,r1,r7
800079c8:	6e 1c       	ld.w	r12,r7[0x4]
800079ca:	e0 1c ff fc 	andl	r12,0xfffc
800079ce:	58 09       	cp.w	r9,0
800079d0:	c5 60       	breq	80007a7c <_realloc_r+0x178>
800079d2:	f8 00 00 03 	add	r3,r12,r0
800079d6:	0a 39       	cp.w	r9,r5
800079d8:	c4 81       	brne	80007a68 <_realloc_r+0x164>
800079da:	14 03       	add	r3,r10
800079dc:	ec c9 ff f0 	sub	r9,r6,-16
800079e0:	12 33       	cp.w	r3,r9
800079e2:	c4 d5       	brlt	80007a7c <_realloc_r+0x178>
800079e4:	6e 3a       	ld.w	r10,r7[0xc]
800079e6:	6e 29       	ld.w	r9,r7[0x8]
800079e8:	95 29       	st.w	r10[0x8],r9
800079ea:	93 3a       	st.w	r9[0xc],r10
800079ec:	ee c5 ff f8 	sub	r5,r7,-8
800079f0:	e0 ca 00 04 	sub	r10,r0,4
800079f4:	e0 4a 00 24 	cp.w	r10,36
800079f8:	e0 8b 00 25 	brhi	80007a42 <_realloc_r+0x13e>
800079fc:	0a 99       	mov	r9,r5
800079fe:	59 3a       	cp.w	r10,19
80007a00:	e0 88 00 1a 	brls	80007a34 <_realloc_r+0x130>
80007a04:	09 09       	ld.w	r9,r4++
80007a06:	8b 09       	st.w	r5[0x0],r9
80007a08:	09 09       	ld.w	r9,r4++
80007a0a:	8f 39       	st.w	r7[0xc],r9
80007a0c:	ee c9 ff f0 	sub	r9,r7,-16
80007a10:	59 ba       	cp.w	r10,27
80007a12:	e0 88 00 11 	brls	80007a34 <_realloc_r+0x130>
80007a16:	09 0b       	ld.w	r11,r4++
80007a18:	93 0b       	st.w	r9[0x0],r11
80007a1a:	09 09       	ld.w	r9,r4++
80007a1c:	8f 59       	st.w	r7[0x14],r9
80007a1e:	ee c9 ff e8 	sub	r9,r7,-24
80007a22:	e0 4a 00 24 	cp.w	r10,36
80007a26:	c0 71       	brne	80007a34 <_realloc_r+0x130>
80007a28:	09 0a       	ld.w	r10,r4++
80007a2a:	93 0a       	st.w	r9[0x0],r10
80007a2c:	ee c9 ff e0 	sub	r9,r7,-32
80007a30:	09 0a       	ld.w	r10,r4++
80007a32:	8f 7a       	st.w	r7[0x1c],r10
80007a34:	09 0a       	ld.w	r10,r4++
80007a36:	12 aa       	st.w	r9++,r10
80007a38:	68 0a       	ld.w	r10,r4[0x0]
80007a3a:	93 0a       	st.w	r9[0x0],r10
80007a3c:	68 1a       	ld.w	r10,r4[0x4]
80007a3e:	93 1a       	st.w	r9[0x4],r10
80007a40:	c0 78       	rjmp	80007a4e <_realloc_r+0x14a>
80007a42:	50 08       	stdsp	sp[0x0],r8
80007a44:	08 9b       	mov	r11,r4
80007a46:	0a 9c       	mov	r12,r5
80007a48:	e0 a0 1d 8f 	rcall	8000b566 <memmove>
80007a4c:	40 08       	lddsp	r8,sp[0x0]
80007a4e:	ee 06 00 09 	add	r9,r7,r6
80007a52:	0c 13       	sub	r3,r6
80007a54:	a1 a3       	sbr	r3,0x0
80007a56:	93 13       	st.w	r9[0x4],r3
80007a58:	91 29       	st.w	r8[0x8],r9
80007a5a:	04 9c       	mov	r12,r2
80007a5c:	6e 18       	ld.w	r8,r7[0x4]
80007a5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a62:	10 46       	or	r6,r8
80007a64:	8f 16       	st.w	r7[0x4],r6
80007a66:	ca a8       	rjmp	80007bba <_realloc_r+0x2b6>
80007a68:	14 03       	add	r3,r10
80007a6a:	0c 33       	cp.w	r3,r6
80007a6c:	c0 85       	brlt	80007a7c <_realloc_r+0x178>
80007a6e:	72 28       	ld.w	r8,r9[0x8]
80007a70:	72 39       	ld.w	r9,r9[0xc]
80007a72:	93 28       	st.w	r9[0x8],r8
80007a74:	91 39       	st.w	r8[0xc],r9
80007a76:	6e 28       	ld.w	r8,r7[0x8]
80007a78:	6e 39       	ld.w	r9,r7[0xc]
80007a7a:	c0 78       	rjmp	80007a88 <_realloc_r+0x184>
80007a7c:	f8 00 00 03 	add	r3,r12,r0
80007a80:	0c 33       	cp.w	r3,r6
80007a82:	c3 35       	brlt	80007ae8 <_realloc_r+0x1e4>
80007a84:	6e 39       	ld.w	r9,r7[0xc]
80007a86:	6e 28       	ld.w	r8,r7[0x8]
80007a88:	93 28       	st.w	r9[0x8],r8
80007a8a:	91 39       	st.w	r8[0xc],r9
80007a8c:	e0 ca 00 04 	sub	r10,r0,4
80007a90:	ee cc ff f8 	sub	r12,r7,-8
80007a94:	e0 4a 00 24 	cp.w	r10,36
80007a98:	e0 8b 00 24 	brhi	80007ae0 <_realloc_r+0x1dc>
80007a9c:	59 3a       	cp.w	r10,19
80007a9e:	e0 88 00 1a 	brls	80007ad2 <_realloc_r+0x1ce>
80007aa2:	09 08       	ld.w	r8,r4++
80007aa4:	99 08       	st.w	r12[0x0],r8
80007aa6:	09 08       	ld.w	r8,r4++
80007aa8:	8f 38       	st.w	r7[0xc],r8
80007aaa:	ee cc ff f0 	sub	r12,r7,-16
80007aae:	59 ba       	cp.w	r10,27
80007ab0:	e0 88 00 11 	brls	80007ad2 <_realloc_r+0x1ce>
80007ab4:	09 08       	ld.w	r8,r4++
80007ab6:	99 08       	st.w	r12[0x0],r8
80007ab8:	09 08       	ld.w	r8,r4++
80007aba:	8f 58       	st.w	r7[0x14],r8
80007abc:	ee cc ff e8 	sub	r12,r7,-24
80007ac0:	e0 4a 00 24 	cp.w	r10,36
80007ac4:	c0 71       	brne	80007ad2 <_realloc_r+0x1ce>
80007ac6:	09 08       	ld.w	r8,r4++
80007ac8:	99 08       	st.w	r12[0x0],r8
80007aca:	ee cc ff e0 	sub	r12,r7,-32
80007ace:	09 08       	ld.w	r8,r4++
80007ad0:	8f 78       	st.w	r7[0x1c],r8
80007ad2:	09 08       	ld.w	r8,r4++
80007ad4:	18 a8       	st.w	r12++,r8
80007ad6:	68 08       	ld.w	r8,r4[0x0]
80007ad8:	99 08       	st.w	r12[0x0],r8
80007ada:	68 18       	ld.w	r8,r4[0x4]
80007adc:	99 18       	st.w	r12[0x4],r8
80007ade:	c4 78       	rjmp	80007b6c <_realloc_r+0x268>
80007ae0:	08 9b       	mov	r11,r4
80007ae2:	e0 a0 1d 42 	rcall	8000b566 <memmove>
80007ae6:	c4 38       	rjmp	80007b6c <_realloc_r+0x268>
80007ae8:	04 9c       	mov	r12,r2
80007aea:	fe b0 fc 45 	rcall	80007374 <_malloc_r>
80007aee:	18 95       	mov	r5,r12
80007af0:	c3 a0       	breq	80007b64 <_realloc_r+0x260>
80007af2:	62 18       	ld.w	r8,r1[0x4]
80007af4:	f8 c9 00 08 	sub	r9,r12,8
80007af8:	a1 c8       	cbr	r8,0x0
80007afa:	e2 08 00 08 	add	r8,r1,r8
80007afe:	10 39       	cp.w	r9,r8
80007b00:	c0 71       	brne	80007b0e <_realloc_r+0x20a>
80007b02:	72 13       	ld.w	r3,r9[0x4]
80007b04:	02 97       	mov	r7,r1
80007b06:	e0 13 ff fc 	andl	r3,0xfffc
80007b0a:	00 03       	add	r3,r0
80007b0c:	c3 08       	rjmp	80007b6c <_realloc_r+0x268>
80007b0e:	e0 ca 00 04 	sub	r10,r0,4
80007b12:	e0 4a 00 24 	cp.w	r10,36
80007b16:	e0 8b 00 20 	brhi	80007b56 <_realloc_r+0x252>
80007b1a:	08 99       	mov	r9,r4
80007b1c:	18 98       	mov	r8,r12
80007b1e:	59 3a       	cp.w	r10,19
80007b20:	e0 88 00 14 	brls	80007b48 <_realloc_r+0x244>
80007b24:	13 0b       	ld.w	r11,r9++
80007b26:	10 ab       	st.w	r8++,r11
80007b28:	13 0b       	ld.w	r11,r9++
80007b2a:	10 ab       	st.w	r8++,r11
80007b2c:	59 ba       	cp.w	r10,27
80007b2e:	e0 88 00 0d 	brls	80007b48 <_realloc_r+0x244>
80007b32:	13 0b       	ld.w	r11,r9++
80007b34:	10 ab       	st.w	r8++,r11
80007b36:	13 0b       	ld.w	r11,r9++
80007b38:	10 ab       	st.w	r8++,r11
80007b3a:	e0 4a 00 24 	cp.w	r10,36
80007b3e:	c0 51       	brne	80007b48 <_realloc_r+0x244>
80007b40:	13 0a       	ld.w	r10,r9++
80007b42:	10 aa       	st.w	r8++,r10
80007b44:	13 0a       	ld.w	r10,r9++
80007b46:	10 aa       	st.w	r8++,r10
80007b48:	13 0a       	ld.w	r10,r9++
80007b4a:	10 aa       	st.w	r8++,r10
80007b4c:	72 0a       	ld.w	r10,r9[0x0]
80007b4e:	91 0a       	st.w	r8[0x0],r10
80007b50:	72 19       	ld.w	r9,r9[0x4]
80007b52:	91 19       	st.w	r8[0x4],r9
80007b54:	c0 48       	rjmp	80007b5c <_realloc_r+0x258>
80007b56:	08 9b       	mov	r11,r4
80007b58:	e0 a0 1d 07 	rcall	8000b566 <memmove>
80007b5c:	08 9b       	mov	r11,r4
80007b5e:	04 9c       	mov	r12,r2
80007b60:	e0 a0 1a 60 	rcall	8000b020 <_free_r>
80007b64:	04 9c       	mov	r12,r2
80007b66:	c2 a8       	rjmp	80007bba <_realloc_r+0x2b6>
80007b68:	00 93       	mov	r3,r0
80007b6a:	02 97       	mov	r7,r1
80007b6c:	e6 06 01 09 	sub	r9,r3,r6
80007b70:	6e 18       	ld.w	r8,r7[0x4]
80007b72:	58 f9       	cp.w	r9,15
80007b74:	e0 88 00 16 	brls	80007ba0 <_realloc_r+0x29c>
80007b78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b7c:	ed e8 10 08 	or	r8,r6,r8
80007b80:	8f 18       	st.w	r7[0x4],r8
80007b82:	12 98       	mov	r8,r9
80007b84:	a1 a8       	sbr	r8,0x0
80007b86:	ee 06 00 0b 	add	r11,r7,r6
80007b8a:	f6 09 00 09 	add	r9,r11,r9
80007b8e:	97 18       	st.w	r11[0x4],r8
80007b90:	72 18       	ld.w	r8,r9[0x4]
80007b92:	a1 a8       	sbr	r8,0x0
80007b94:	2f 8b       	sub	r11,-8
80007b96:	93 18       	st.w	r9[0x4],r8
80007b98:	04 9c       	mov	r12,r2
80007b9a:	e0 a0 1a 43 	rcall	8000b020 <_free_r>
80007b9e:	c0 b8       	rjmp	80007bb4 <_realloc_r+0x2b0>
80007ba0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ba4:	e7 e8 10 08 	or	r8,r3,r8
80007ba8:	8f 18       	st.w	r7[0x4],r8
80007baa:	ee 03 00 03 	add	r3,r7,r3
80007bae:	66 18       	ld.w	r8,r3[0x4]
80007bb0:	a1 a8       	sbr	r8,0x0
80007bb2:	87 18       	st.w	r3[0x4],r8
80007bb4:	04 9c       	mov	r12,r2
80007bb6:	ee c5 ff f8 	sub	r5,r7,-8
80007bba:	fe b0 f1 91 	rcall	80005edc <__malloc_unlock>
80007bbe:	0a 9c       	mov	r12,r5
80007bc0:	2f fd       	sub	sp,-4
80007bc2:	d8 32       	popm	r0-r7,pc

80007bc4 <_sbrk_r>:
80007bc4:	d4 21       	pushm	r4-r7,lr
80007bc6:	30 08       	mov	r8,0
80007bc8:	18 97       	mov	r7,r12
80007bca:	e0 66 53 54 	mov	r6,21332
80007bce:	16 9c       	mov	r12,r11
80007bd0:	8d 08       	st.w	r6[0x0],r8
80007bd2:	c8 5c       	rcall	80007cdc <_sbrk>
80007bd4:	5b fc       	cp.w	r12,-1
80007bd6:	c0 51       	brne	80007be0 <_sbrk_r+0x1c>
80007bd8:	6c 08       	ld.w	r8,r6[0x0]
80007bda:	58 08       	cp.w	r8,0
80007bdc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007be0:	d8 22       	popm	r4-r7,pc
80007be2:	d7 03       	nop

80007be4 <sprintf>:
80007be4:	d4 01       	pushm	lr
80007be6:	21 7d       	sub	sp,92
80007be8:	e0 68 ff ff 	mov	r8,65535
80007bec:	ea 18 7f ff 	orh	r8,0x7fff
80007bf0:	50 58       	stdsp	sp[0x14],r8
80007bf2:	50 28       	stdsp	sp[0x8],r8
80007bf4:	e0 68 02 08 	mov	r8,520
80007bf8:	ba 68       	st.h	sp[0xc],r8
80007bfa:	3f f8       	mov	r8,-1
80007bfc:	ba 78       	st.h	sp[0xe],r8
80007bfe:	e0 68 0a 3c 	mov	r8,2620
80007c02:	50 4c       	stdsp	sp[0x10],r12
80007c04:	16 9a       	mov	r10,r11
80007c06:	50 0c       	stdsp	sp[0x0],r12
80007c08:	fa c9 ff a0 	sub	r9,sp,-96
80007c0c:	70 0c       	ld.w	r12,r8[0x0]
80007c0e:	1a 9b       	mov	r11,sp
80007c10:	e0 a0 02 1a 	rcall	80008044 <_vfprintf_r>
80007c14:	30 09       	mov	r9,0
80007c16:	40 08       	lddsp	r8,sp[0x0]
80007c18:	b0 89       	st.b	r8[0x0],r9
80007c1a:	2e 9d       	sub	sp,-92
80007c1c:	d8 02       	popm	pc
80007c1e:	d7 03       	nop

80007c20 <strncpy>:
80007c20:	30 08       	mov	r8,0
80007c22:	10 3a       	cp.w	r10,r8
80007c24:	5e 0c       	reteq	r12
80007c26:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007c2a:	f8 08 0b 09 	st.b	r12[r8],r9
80007c2e:	2f f8       	sub	r8,-1
80007c30:	58 09       	cp.w	r9,0
80007c32:	cf 81       	brne	80007c22 <strncpy+0x2>
80007c34:	10 3a       	cp.w	r10,r8
80007c36:	5e 0c       	reteq	r12
80007c38:	f8 08 0b 09 	st.b	r12[r8],r9
80007c3c:	2f f8       	sub	r8,-1
80007c3e:	cf bb       	rjmp	80007c34 <strncpy+0x14>

80007c40 <_close>:
80007c40:	30 28       	mov	r8,2
80007c42:	d6 73       	breakpoint
80007c44:	3f fc       	mov	r12,-1
80007c46:	35 8b       	mov	r11,88
80007c48:	58 0c       	cp.w	r12,0
80007c4a:	5e 4c       	retge	r12
80007c4c:	e0 6a 53 54 	mov	r10,21332
80007c50:	95 0b       	st.w	r10[0x0],r11
80007c52:	5e fc       	retal	r12

80007c54 <_lseek>:
80007c54:	30 58       	mov	r8,5
80007c56:	d6 73       	breakpoint
80007c58:	3f fc       	mov	r12,-1
80007c5a:	35 8b       	mov	r11,88
80007c5c:	58 0c       	cp.w	r12,0
80007c5e:	5e 4c       	retge	r12
80007c60:	e0 6a 53 54 	mov	r10,21332
80007c64:	95 0b       	st.w	r10[0x0],r11
80007c66:	5e fc       	retal	r12

80007c68 <isatty>:
80007c68:	30 b8       	mov	r8,11
80007c6a:	d6 73       	breakpoint
80007c6c:	3f fc       	mov	r12,-1
80007c6e:	35 8b       	mov	r11,88
80007c70:	58 0c       	cp.w	r12,0
80007c72:	5e 4c       	retge	r12
80007c74:	e0 6a 53 54 	mov	r10,21332
80007c78:	95 0b       	st.w	r10[0x0],r11
80007c7a:	5e fc       	retal	r12

80007c7c <_fstat_host>:
80007c7c:	30 98       	mov	r8,9
80007c7e:	d6 73       	breakpoint
80007c80:	3f fc       	mov	r12,-1
80007c82:	35 8b       	mov	r11,88
80007c84:	58 0c       	cp.w	r12,0
80007c86:	5e 4c       	retge	r12
80007c88:	e0 6a 53 54 	mov	r10,21332
80007c8c:	95 0b       	st.w	r10[0x0],r11
80007c8e:	5e fc       	retal	r12

80007c90 <_fstat>:
80007c90:	d4 21       	pushm	r4-r7,lr
80007c92:	21 0d       	sub	sp,64
80007c94:	16 97       	mov	r7,r11
80007c96:	1a 9b       	mov	r11,sp
80007c98:	cf 2f       	rcall	80007c7c <_fstat_host>
80007c9a:	c0 34       	brge	80007ca0 <_fstat+0x10>
80007c9c:	3f fc       	mov	r12,-1
80007c9e:	c1 c8       	rjmp	80007cd6 <_fstat+0x46>
80007ca0:	40 08       	lddsp	r8,sp[0x0]
80007ca2:	ae 08       	st.h	r7[0x0],r8
80007ca4:	40 18       	lddsp	r8,sp[0x4]
80007ca6:	ae 18       	st.h	r7[0x2],r8
80007ca8:	40 28       	lddsp	r8,sp[0x8]
80007caa:	8f 18       	st.w	r7[0x4],r8
80007cac:	40 38       	lddsp	r8,sp[0xc]
80007cae:	ae 48       	st.h	r7[0x8],r8
80007cb0:	40 48       	lddsp	r8,sp[0x10]
80007cb2:	ae 58       	st.h	r7[0xa],r8
80007cb4:	40 58       	lddsp	r8,sp[0x14]
80007cb6:	ae 68       	st.h	r7[0xc],r8
80007cb8:	40 68       	lddsp	r8,sp[0x18]
80007cba:	ae 78       	st.h	r7[0xe],r8
80007cbc:	40 88       	lddsp	r8,sp[0x20]
80007cbe:	8f 48       	st.w	r7[0x10],r8
80007cc0:	40 a8       	lddsp	r8,sp[0x28]
80007cc2:	8f b8       	st.w	r7[0x2c],r8
80007cc4:	40 c8       	lddsp	r8,sp[0x30]
80007cc6:	8f c8       	st.w	r7[0x30],r8
80007cc8:	40 d8       	lddsp	r8,sp[0x34]
80007cca:	8f 58       	st.w	r7[0x14],r8
80007ccc:	40 e8       	lddsp	r8,sp[0x38]
80007cce:	30 0c       	mov	r12,0
80007cd0:	8f 78       	st.w	r7[0x1c],r8
80007cd2:	40 f8       	lddsp	r8,sp[0x3c]
80007cd4:	8f 98       	st.w	r7[0x24],r8
80007cd6:	2f 0d       	sub	sp,-64
80007cd8:	d8 22       	popm	r4-r7,pc
80007cda:	d7 03       	nop

80007cdc <_sbrk>:
80007cdc:	d4 01       	pushm	lr
80007cde:	e0 68 0d 9c 	mov	r8,3484
80007ce2:	70 09       	ld.w	r9,r8[0x0]
80007ce4:	58 09       	cp.w	r9,0
80007ce6:	c0 41       	brne	80007cee <_sbrk+0x12>
80007ce8:	e0 69 53 58 	mov	r9,21336
80007cec:	91 09       	st.w	r8[0x0],r9
80007cee:	e0 69 0d 9c 	mov	r9,3484
80007cf2:	e0 7a 70 00 	mov	r10,94208
80007cf6:	72 08       	ld.w	r8,r9[0x0]
80007cf8:	f0 0c 00 0c 	add	r12,r8,r12
80007cfc:	14 3c       	cp.w	r12,r10
80007cfe:	e0 8b 00 04 	brhi	80007d06 <_sbrk+0x2a>
80007d02:	93 0c       	st.w	r9[0x0],r12
80007d04:	c0 68       	rjmp	80007d10 <_sbrk+0x34>
80007d06:	e0 a0 18 15 	rcall	8000ad30 <__errno>
80007d0a:	30 c8       	mov	r8,12
80007d0c:	99 08       	st.w	r12[0x0],r8
80007d0e:	3f f8       	mov	r8,-1
80007d10:	10 9c       	mov	r12,r8
80007d12:	d8 02       	popm	pc

80007d14 <get_arg>:
80007d14:	d4 31       	pushm	r0-r7,lr
80007d16:	20 8d       	sub	sp,32
80007d18:	fa c4 ff bc 	sub	r4,sp,-68
80007d1c:	50 4b       	stdsp	sp[0x10],r11
80007d1e:	68 2e       	ld.w	lr,r4[0x8]
80007d20:	50 58       	stdsp	sp[0x14],r8
80007d22:	12 96       	mov	r6,r9
80007d24:	7c 0b       	ld.w	r11,lr[0x0]
80007d26:	70 05       	ld.w	r5,r8[0x0]
80007d28:	50 6e       	stdsp	sp[0x18],lr
80007d2a:	58 0b       	cp.w	r11,0
80007d2c:	f4 0b 17 00 	moveq	r11,r10
80007d30:	68 03       	ld.w	r3,r4[0x0]
80007d32:	68 11       	ld.w	r1,r4[0x4]
80007d34:	40 49       	lddsp	r9,sp[0x10]
80007d36:	30 08       	mov	r8,0
80007d38:	c2 89       	rjmp	80007f88 <get_arg+0x274>
80007d3a:	2f fb       	sub	r11,-1
80007d3c:	32 5c       	mov	r12,37
80007d3e:	17 8a       	ld.ub	r10,r11[0x0]
80007d40:	f8 0a 18 00 	cp.b	r10,r12
80007d44:	5f 1e       	srne	lr
80007d46:	f0 0a 18 00 	cp.b	r10,r8
80007d4a:	5f 1c       	srne	r12
80007d4c:	fd ec 00 0c 	and	r12,lr,r12
80007d50:	f0 0c 18 00 	cp.b	r12,r8
80007d54:	cf 31       	brne	80007d3a <get_arg+0x26>
80007d56:	58 0a       	cp.w	r10,0
80007d58:	e0 80 01 25 	breq	80007fa2 <get_arg+0x28e>
80007d5c:	30 0c       	mov	r12,0
80007d5e:	3f fa       	mov	r10,-1
80007d60:	18 90       	mov	r0,r12
80007d62:	50 3a       	stdsp	sp[0xc],r10
80007d64:	18 94       	mov	r4,r12
80007d66:	18 92       	mov	r2,r12
80007d68:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007d6c:	16 97       	mov	r7,r11
80007d6e:	50 7c       	stdsp	sp[0x1c],r12
80007d70:	fe cc 9d 4c 	sub	r12,pc,-25268
80007d74:	0f 3a       	ld.ub	r10,r7++
80007d76:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007d7a:	40 7c       	lddsp	r12,sp[0x1c]
80007d7c:	1c 0c       	add	r12,lr
80007d7e:	fe ce 9e 22 	sub	lr,pc,-25054
80007d82:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007d86:	20 1e       	sub	lr,1
80007d88:	50 0e       	stdsp	sp[0x0],lr
80007d8a:	fe ce 9e 9a 	sub	lr,pc,-24934
80007d8e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007d92:	50 7c       	stdsp	sp[0x1c],r12
80007d94:	40 0c       	lddsp	r12,sp[0x0]
80007d96:	58 7c       	cp.w	r12,7
80007d98:	e0 8b 00 f1 	brhi	80007f7a <get_arg+0x266>
80007d9c:	fe ce a0 4c 	sub	lr,pc,-24500
80007da0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007da4:	36 8b       	mov	r11,104
80007da6:	f6 0a 18 00 	cp.b	r10,r11
80007daa:	e0 80 00 e8 	breq	80007f7a <get_arg+0x266>
80007dae:	37 1b       	mov	r11,113
80007db0:	f6 0a 18 00 	cp.b	r10,r11
80007db4:	c0 70       	breq	80007dc2 <get_arg+0xae>
80007db6:	34 cb       	mov	r11,76
80007db8:	f6 0a 18 00 	cp.b	r10,r11
80007dbc:	c0 51       	brne	80007dc6 <get_arg+0xb2>
80007dbe:	a3 b4       	sbr	r4,0x3
80007dc0:	cd d8       	rjmp	80007f7a <get_arg+0x266>
80007dc2:	a5 b4       	sbr	r4,0x5
80007dc4:	cd b8       	rjmp	80007f7a <get_arg+0x266>
80007dc6:	08 9a       	mov	r10,r4
80007dc8:	0e 9b       	mov	r11,r7
80007dca:	a5 aa       	sbr	r10,0x4
80007dcc:	17 3c       	ld.ub	r12,r11++
80007dce:	a5 b4       	sbr	r4,0x5
80007dd0:	36 ce       	mov	lr,108
80007dd2:	fc 0c 18 00 	cp.b	r12,lr
80007dd6:	e0 80 00 d3 	breq	80007f7c <get_arg+0x268>
80007dda:	14 94       	mov	r4,r10
80007ddc:	cc f8       	rjmp	80007f7a <get_arg+0x266>
80007dde:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007de2:	36 7c       	mov	r12,103
80007de4:	f8 0a 18 00 	cp.b	r10,r12
80007de8:	e0 8b 00 27 	brhi	80007e36 <get_arg+0x122>
80007dec:	36 5b       	mov	r11,101
80007dee:	f6 0a 18 00 	cp.b	r10,r11
80007df2:	c4 82       	brcc	80007e82 <get_arg+0x16e>
80007df4:	34 fb       	mov	r11,79
80007df6:	f6 0a 18 00 	cp.b	r10,r11
80007dfa:	c4 80       	breq	80007e8a <get_arg+0x176>
80007dfc:	e0 8b 00 0c 	brhi	80007e14 <get_arg+0x100>
80007e00:	34 5b       	mov	r11,69
80007e02:	f6 0a 18 00 	cp.b	r10,r11
80007e06:	c3 e0       	breq	80007e82 <get_arg+0x16e>
80007e08:	34 7b       	mov	r11,71
80007e0a:	f6 0a 18 00 	cp.b	r10,r11
80007e0e:	c3 a0       	breq	80007e82 <get_arg+0x16e>
80007e10:	34 4b       	mov	r11,68
80007e12:	c0 88       	rjmp	80007e22 <get_arg+0x10e>
80007e14:	35 8b       	mov	r11,88
80007e16:	f6 0a 18 00 	cp.b	r10,r11
80007e1a:	c2 c0       	breq	80007e72 <get_arg+0x15e>
80007e1c:	e0 8b 00 07 	brhi	80007e2a <get_arg+0x116>
80007e20:	35 5b       	mov	r11,85
80007e22:	f6 0a 18 00 	cp.b	r10,r11
80007e26:	c3 51       	brne	80007e90 <get_arg+0x17c>
80007e28:	c3 18       	rjmp	80007e8a <get_arg+0x176>
80007e2a:	36 3b       	mov	r11,99
80007e2c:	f6 0a 18 00 	cp.b	r10,r11
80007e30:	c2 f0       	breq	80007e8e <get_arg+0x17a>
80007e32:	36 4b       	mov	r11,100
80007e34:	c0 e8       	rjmp	80007e50 <get_arg+0x13c>
80007e36:	37 0b       	mov	r11,112
80007e38:	f6 0a 18 00 	cp.b	r10,r11
80007e3c:	c2 50       	breq	80007e86 <get_arg+0x172>
80007e3e:	e0 8b 00 0d 	brhi	80007e58 <get_arg+0x144>
80007e42:	36 eb       	mov	r11,110
80007e44:	f6 0a 18 00 	cp.b	r10,r11
80007e48:	c1 f0       	breq	80007e86 <get_arg+0x172>
80007e4a:	e0 8b 00 14 	brhi	80007e72 <get_arg+0x15e>
80007e4e:	36 9b       	mov	r11,105
80007e50:	f6 0a 18 00 	cp.b	r10,r11
80007e54:	c1 e1       	brne	80007e90 <get_arg+0x17c>
80007e56:	c0 e8       	rjmp	80007e72 <get_arg+0x15e>
80007e58:	37 5b       	mov	r11,117
80007e5a:	f6 0a 18 00 	cp.b	r10,r11
80007e5e:	c0 a0       	breq	80007e72 <get_arg+0x15e>
80007e60:	37 8b       	mov	r11,120
80007e62:	f6 0a 18 00 	cp.b	r10,r11
80007e66:	c0 60       	breq	80007e72 <get_arg+0x15e>
80007e68:	37 3b       	mov	r11,115
80007e6a:	f6 0a 18 00 	cp.b	r10,r11
80007e6e:	c1 11       	brne	80007e90 <get_arg+0x17c>
80007e70:	c0 b8       	rjmp	80007e86 <get_arg+0x172>
80007e72:	ed b4 00 04 	bld	r4,0x4
80007e76:	c0 a0       	breq	80007e8a <get_arg+0x176>
80007e78:	ed b4 00 05 	bld	r4,0x5
80007e7c:	c0 91       	brne	80007e8e <get_arg+0x17a>
80007e7e:	30 20       	mov	r0,2
80007e80:	c0 88       	rjmp	80007e90 <get_arg+0x17c>
80007e82:	30 40       	mov	r0,4
80007e84:	c0 68       	rjmp	80007e90 <get_arg+0x17c>
80007e86:	30 30       	mov	r0,3
80007e88:	c0 48       	rjmp	80007e90 <get_arg+0x17c>
80007e8a:	30 10       	mov	r0,1
80007e8c:	c0 28       	rjmp	80007e90 <get_arg+0x17c>
80007e8e:	30 00       	mov	r0,0
80007e90:	40 3b       	lddsp	r11,sp[0xc]
80007e92:	5b fb       	cp.w	r11,-1
80007e94:	c0 40       	breq	80007e9c <get_arg+0x188>
80007e96:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007e9a:	c7 08       	rjmp	80007f7a <get_arg+0x266>
80007e9c:	58 60       	cp.w	r0,6
80007e9e:	e0 8b 00 6e 	brhi	80007f7a <get_arg+0x266>
80007ea2:	6c 0a       	ld.w	r10,r6[0x0]
80007ea4:	ea cc ff ff 	sub	r12,r5,-1
80007ea8:	fe ce a1 38 	sub	lr,pc,-24264
80007eac:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007eb0:	f4 cb ff f8 	sub	r11,r10,-8
80007eb4:	8d 0b       	st.w	r6[0x0],r11
80007eb6:	f4 ea 00 00 	ld.d	r10,r10[0]
80007eba:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007ebe:	c0 f8       	rjmp	80007edc <get_arg+0x1c8>
80007ec0:	f4 cb ff fc 	sub	r11,r10,-4
80007ec4:	8d 0b       	st.w	r6[0x0],r11
80007ec6:	74 0a       	ld.w	r10,r10[0x0]
80007ec8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ecc:	c0 88       	rjmp	80007edc <get_arg+0x1c8>
80007ece:	f4 cb ff f8 	sub	r11,r10,-8
80007ed2:	8d 0b       	st.w	r6[0x0],r11
80007ed4:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ed8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007edc:	0e 9b       	mov	r11,r7
80007ede:	18 95       	mov	r5,r12
80007ee0:	c4 e8       	rjmp	80007f7c <get_arg+0x268>
80007ee2:	62 0a       	ld.w	r10,r1[0x0]
80007ee4:	5b fa       	cp.w	r10,-1
80007ee6:	c0 b1       	brne	80007efc <get_arg+0x1e8>
80007ee8:	50 19       	stdsp	sp[0x4],r9
80007eea:	50 28       	stdsp	sp[0x8],r8
80007eec:	e0 6a 00 80 	mov	r10,128
80007ef0:	30 0b       	mov	r11,0
80007ef2:	02 9c       	mov	r12,r1
80007ef4:	fe b0 fd 00 	rcall	800078f4 <memset>
80007ef8:	40 28       	lddsp	r8,sp[0x8]
80007efa:	40 19       	lddsp	r9,sp[0x4]
80007efc:	e4 cc 00 01 	sub	r12,r2,1
80007f00:	0e 9b       	mov	r11,r7
80007f02:	50 3c       	stdsp	sp[0xc],r12
80007f04:	f2 0c 0c 49 	max	r9,r9,r12
80007f08:	c3 a8       	rjmp	80007f7c <get_arg+0x268>
80007f0a:	62 0a       	ld.w	r10,r1[0x0]
80007f0c:	5b fa       	cp.w	r10,-1
80007f0e:	c0 b1       	brne	80007f24 <get_arg+0x210>
80007f10:	50 19       	stdsp	sp[0x4],r9
80007f12:	50 28       	stdsp	sp[0x8],r8
80007f14:	e0 6a 00 80 	mov	r10,128
80007f18:	30 0b       	mov	r11,0
80007f1a:	02 9c       	mov	r12,r1
80007f1c:	fe b0 fc ec 	rcall	800078f4 <memset>
80007f20:	40 28       	lddsp	r8,sp[0x8]
80007f22:	40 19       	lddsp	r9,sp[0x4]
80007f24:	20 12       	sub	r2,1
80007f26:	30 0a       	mov	r10,0
80007f28:	0e 9b       	mov	r11,r7
80007f2a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007f2e:	f2 02 0c 49 	max	r9,r9,r2
80007f32:	c2 58       	rjmp	80007f7c <get_arg+0x268>
80007f34:	16 97       	mov	r7,r11
80007f36:	6c 0a       	ld.w	r10,r6[0x0]
80007f38:	f4 cb ff fc 	sub	r11,r10,-4
80007f3c:	8d 0b       	st.w	r6[0x0],r11
80007f3e:	74 0a       	ld.w	r10,r10[0x0]
80007f40:	0e 9b       	mov	r11,r7
80007f42:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f46:	2f f5       	sub	r5,-1
80007f48:	c1 a8       	rjmp	80007f7c <get_arg+0x268>
80007f4a:	f4 c2 00 30 	sub	r2,r10,48
80007f4e:	c0 68       	rjmp	80007f5a <get_arg+0x246>
80007f50:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007f54:	2f f7       	sub	r7,-1
80007f56:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007f5a:	0f 8a       	ld.ub	r10,r7[0x0]
80007f5c:	58 0a       	cp.w	r10,0
80007f5e:	c0 e0       	breq	80007f7a <get_arg+0x266>
80007f60:	23 0a       	sub	r10,48
80007f62:	58 9a       	cp.w	r10,9
80007f64:	fe 98 ff f6 	brls	80007f50 <get_arg+0x23c>
80007f68:	c0 98       	rjmp	80007f7a <get_arg+0x266>
80007f6a:	2f f7       	sub	r7,-1
80007f6c:	0f 8a       	ld.ub	r10,r7[0x0]
80007f6e:	58 0a       	cp.w	r10,0
80007f70:	c0 50       	breq	80007f7a <get_arg+0x266>
80007f72:	23 0a       	sub	r10,48
80007f74:	58 9a       	cp.w	r10,9
80007f76:	fe 98 ff fa 	brls	80007f6a <get_arg+0x256>
80007f7a:	0e 9b       	mov	r11,r7
80007f7c:	40 7c       	lddsp	r12,sp[0x1c]
80007f7e:	30 ba       	mov	r10,11
80007f80:	f4 0c 18 00 	cp.b	r12,r10
80007f84:	fe 91 fe f2 	brne	80007d68 <get_arg+0x54>
80007f88:	40 42       	lddsp	r2,sp[0x10]
80007f8a:	17 8c       	ld.ub	r12,r11[0x0]
80007f8c:	0a 32       	cp.w	r2,r5
80007f8e:	5f 4a       	srge	r10
80007f90:	f0 0c 18 00 	cp.b	r12,r8
80007f94:	5f 1c       	srne	r12
80007f96:	f9 ea 00 0a 	and	r10,r12,r10
80007f9a:	f0 0a 18 00 	cp.b	r10,r8
80007f9e:	fe 91 fe cf 	brne	80007d3c <get_arg+0x28>
80007fa2:	30 08       	mov	r8,0
80007fa4:	40 4e       	lddsp	lr,sp[0x10]
80007fa6:	17 8a       	ld.ub	r10,r11[0x0]
80007fa8:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007fac:	f0 0a 18 00 	cp.b	r10,r8
80007fb0:	fc 09 17 10 	movne	r9,lr
80007fb4:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007fb8:	06 9e       	mov	lr,r3
80007fba:	c2 a8       	rjmp	8000800e <get_arg+0x2fa>
80007fbc:	62 0a       	ld.w	r10,r1[0x0]
80007fbe:	58 3a       	cp.w	r10,3
80007fc0:	c1 e0       	breq	80007ffc <get_arg+0x2e8>
80007fc2:	e0 89 00 07 	brgt	80007fd0 <get_arg+0x2bc>
80007fc6:	58 1a       	cp.w	r10,1
80007fc8:	c1 a0       	breq	80007ffc <get_arg+0x2e8>
80007fca:	58 2a       	cp.w	r10,2
80007fcc:	c1 81       	brne	80007ffc <get_arg+0x2e8>
80007fce:	c0 58       	rjmp	80007fd8 <get_arg+0x2c4>
80007fd0:	58 5a       	cp.w	r10,5
80007fd2:	c0 c0       	breq	80007fea <get_arg+0x2d6>
80007fd4:	c0 b5       	brlt	80007fea <get_arg+0x2d6>
80007fd6:	c1 38       	rjmp	80007ffc <get_arg+0x2e8>
80007fd8:	6c 0a       	ld.w	r10,r6[0x0]
80007fda:	f4 cc ff f8 	sub	r12,r10,-8
80007fde:	8d 0c       	st.w	r6[0x0],r12
80007fe0:	f4 e2 00 00 	ld.d	r2,r10[0]
80007fe4:	f0 e3 00 00 	st.d	r8[0],r2
80007fe8:	c1 08       	rjmp	80008008 <get_arg+0x2f4>
80007fea:	6c 0a       	ld.w	r10,r6[0x0]
80007fec:	f4 cc ff f8 	sub	r12,r10,-8
80007ff0:	8d 0c       	st.w	r6[0x0],r12
80007ff2:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ff6:	f0 e3 00 00 	st.d	r8[0],r2
80007ffa:	c0 78       	rjmp	80008008 <get_arg+0x2f4>
80007ffc:	6c 0a       	ld.w	r10,r6[0x0]
80007ffe:	f4 cc ff fc 	sub	r12,r10,-4
80008002:	8d 0c       	st.w	r6[0x0],r12
80008004:	74 0a       	ld.w	r10,r10[0x0]
80008006:	91 0a       	st.w	r8[0x0],r10
80008008:	2f f5       	sub	r5,-1
8000800a:	2f 88       	sub	r8,-8
8000800c:	2f c1       	sub	r1,-4
8000800e:	12 35       	cp.w	r5,r9
80008010:	fe 9a ff d6 	brle	80007fbc <get_arg+0x2a8>
80008014:	1c 93       	mov	r3,lr
80008016:	40 52       	lddsp	r2,sp[0x14]
80008018:	40 6e       	lddsp	lr,sp[0x18]
8000801a:	85 05       	st.w	r2[0x0],r5
8000801c:	9d 0b       	st.w	lr[0x0],r11
8000801e:	40 4b       	lddsp	r11,sp[0x10]
80008020:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008024:	2f 8d       	sub	sp,-32
80008026:	d8 32       	popm	r0-r7,pc

80008028 <__sprint_r>:
80008028:	d4 21       	pushm	r4-r7,lr
8000802a:	14 97       	mov	r7,r10
8000802c:	74 28       	ld.w	r8,r10[0x8]
8000802e:	58 08       	cp.w	r8,0
80008030:	c0 41       	brne	80008038 <__sprint_r+0x10>
80008032:	95 18       	st.w	r10[0x4],r8
80008034:	10 9c       	mov	r12,r8
80008036:	d8 22       	popm	r4-r7,pc
80008038:	e0 a0 18 ba 	rcall	8000b1ac <__sfvwrite_r>
8000803c:	30 08       	mov	r8,0
8000803e:	8f 18       	st.w	r7[0x4],r8
80008040:	8f 28       	st.w	r7[0x8],r8
80008042:	d8 22       	popm	r4-r7,pc

80008044 <_vfprintf_r>:
80008044:	d4 31       	pushm	r0-r7,lr
80008046:	fa cd 06 bc 	sub	sp,sp,1724
8000804a:	51 09       	stdsp	sp[0x40],r9
8000804c:	16 91       	mov	r1,r11
8000804e:	14 97       	mov	r7,r10
80008050:	18 95       	mov	r5,r12
80008052:	e0 a0 1a 1d 	rcall	8000b48c <_localeconv_r>
80008056:	78 0c       	ld.w	r12,r12[0x0]
80008058:	50 cc       	stdsp	sp[0x30],r12
8000805a:	58 05       	cp.w	r5,0
8000805c:	c0 70       	breq	8000806a <_vfprintf_r+0x26>
8000805e:	6a 68       	ld.w	r8,r5[0x18]
80008060:	58 08       	cp.w	r8,0
80008062:	c0 41       	brne	8000806a <_vfprintf_r+0x26>
80008064:	0a 9c       	mov	r12,r5
80008066:	e0 a0 17 43 	rcall	8000aeec <__sinit>
8000806a:	fe c8 9f 36 	sub	r8,pc,-24778
8000806e:	10 31       	cp.w	r1,r8
80008070:	c0 31       	brne	80008076 <_vfprintf_r+0x32>
80008072:	6a 01       	ld.w	r1,r5[0x0]
80008074:	c0 c8       	rjmp	8000808c <_vfprintf_r+0x48>
80008076:	fe c8 9f 22 	sub	r8,pc,-24798
8000807a:	10 31       	cp.w	r1,r8
8000807c:	c0 31       	brne	80008082 <_vfprintf_r+0x3e>
8000807e:	6a 11       	ld.w	r1,r5[0x4]
80008080:	c0 68       	rjmp	8000808c <_vfprintf_r+0x48>
80008082:	fe c8 9f 0e 	sub	r8,pc,-24818
80008086:	10 31       	cp.w	r1,r8
80008088:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000808c:	82 68       	ld.sh	r8,r1[0xc]
8000808e:	ed b8 00 03 	bld	r8,0x3
80008092:	c0 41       	brne	8000809a <_vfprintf_r+0x56>
80008094:	62 48       	ld.w	r8,r1[0x10]
80008096:	58 08       	cp.w	r8,0
80008098:	c0 71       	brne	800080a6 <_vfprintf_r+0x62>
8000809a:	02 9b       	mov	r11,r1
8000809c:	0a 9c       	mov	r12,r5
8000809e:	e0 a0 0f 5d 	rcall	80009f58 <__swsetup_r>
800080a2:	e0 81 0f 54 	brne	80009f4a <_vfprintf_r+0x1f06>
800080a6:	82 68       	ld.sh	r8,r1[0xc]
800080a8:	10 99       	mov	r9,r8
800080aa:	e2 19 00 1a 	andl	r9,0x1a,COH
800080ae:	58 a9       	cp.w	r9,10
800080b0:	c3 c1       	brne	80008128 <_vfprintf_r+0xe4>
800080b2:	82 79       	ld.sh	r9,r1[0xe]
800080b4:	30 0a       	mov	r10,0
800080b6:	f4 09 19 00 	cp.h	r9,r10
800080ba:	c3 75       	brlt	80008128 <_vfprintf_r+0xe4>
800080bc:	a1 d8       	cbr	r8,0x1
800080be:	fb 58 05 d0 	st.h	sp[1488],r8
800080c2:	62 88       	ld.w	r8,r1[0x20]
800080c4:	fb 48 05 e4 	st.w	sp[1508],r8
800080c8:	62 a8       	ld.w	r8,r1[0x28]
800080ca:	fb 48 05 ec 	st.w	sp[1516],r8
800080ce:	fa c8 ff bc 	sub	r8,sp,-68
800080d2:	fb 48 05 d4 	st.w	sp[1492],r8
800080d6:	fb 48 05 c4 	st.w	sp[1476],r8
800080da:	e0 68 04 00 	mov	r8,1024
800080de:	fb 48 05 d8 	st.w	sp[1496],r8
800080e2:	fb 48 05 cc 	st.w	sp[1484],r8
800080e6:	30 08       	mov	r8,0
800080e8:	fb 59 05 d2 	st.h	sp[1490],r9
800080ec:	0e 9a       	mov	r10,r7
800080ee:	41 09       	lddsp	r9,sp[0x40]
800080f0:	fa c7 fa 3c 	sub	r7,sp,-1476
800080f4:	fb 48 05 dc 	st.w	sp[1500],r8
800080f8:	0a 9c       	mov	r12,r5
800080fa:	0e 9b       	mov	r11,r7
800080fc:	ca 4f       	rcall	80008044 <_vfprintf_r>
800080fe:	50 bc       	stdsp	sp[0x2c],r12
80008100:	c0 95       	brlt	80008112 <_vfprintf_r+0xce>
80008102:	0e 9b       	mov	r11,r7
80008104:	0a 9c       	mov	r12,r5
80008106:	e0 a0 16 1b 	rcall	8000ad3c <_fflush_r>
8000810a:	40 be       	lddsp	lr,sp[0x2c]
8000810c:	f9 be 01 ff 	movne	lr,-1
80008110:	50 be       	stdsp	sp[0x2c],lr
80008112:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008116:	ed b8 00 06 	bld	r8,0x6
8000811a:	e0 81 0f 1a 	brne	80009f4e <_vfprintf_r+0x1f0a>
8000811e:	82 68       	ld.sh	r8,r1[0xc]
80008120:	a7 a8       	sbr	r8,0x6
80008122:	a2 68       	st.h	r1[0xc],r8
80008124:	e0 8f 0f 15 	bral	80009f4e <_vfprintf_r+0x1f0a>
80008128:	30 08       	mov	r8,0
8000812a:	fb 48 06 b4 	st.w	sp[1716],r8
8000812e:	fb 48 06 90 	st.w	sp[1680],r8
80008132:	fb 48 06 8c 	st.w	sp[1676],r8
80008136:	fb 48 06 b0 	st.w	sp[1712],r8
8000813a:	30 08       	mov	r8,0
8000813c:	30 09       	mov	r9,0
8000813e:	50 a7       	stdsp	sp[0x28],r7
80008140:	50 78       	stdsp	sp[0x1c],r8
80008142:	fa c3 f9 e0 	sub	r3,sp,-1568
80008146:	3f f8       	mov	r8,-1
80008148:	50 59       	stdsp	sp[0x14],r9
8000814a:	fb 43 06 88 	st.w	sp[1672],r3
8000814e:	fb 48 05 44 	st.w	sp[1348],r8
80008152:	12 9c       	mov	r12,r9
80008154:	50 69       	stdsp	sp[0x18],r9
80008156:	50 d9       	stdsp	sp[0x34],r9
80008158:	50 e9       	stdsp	sp[0x38],r9
8000815a:	50 b9       	stdsp	sp[0x2c],r9
8000815c:	12 97       	mov	r7,r9
8000815e:	0a 94       	mov	r4,r5
80008160:	40 a2       	lddsp	r2,sp[0x28]
80008162:	32 5a       	mov	r10,37
80008164:	30 08       	mov	r8,0
80008166:	c0 28       	rjmp	8000816a <_vfprintf_r+0x126>
80008168:	2f f2       	sub	r2,-1
8000816a:	05 89       	ld.ub	r9,r2[0x0]
8000816c:	f0 09 18 00 	cp.b	r9,r8
80008170:	5f 1b       	srne	r11
80008172:	f4 09 18 00 	cp.b	r9,r10
80008176:	5f 19       	srne	r9
80008178:	f3 eb 00 0b 	and	r11,r9,r11
8000817c:	f0 0b 18 00 	cp.b	r11,r8
80008180:	cf 41       	brne	80008168 <_vfprintf_r+0x124>
80008182:	40 ab       	lddsp	r11,sp[0x28]
80008184:	e4 0b 01 06 	sub	r6,r2,r11
80008188:	c1 e0       	breq	800081c4 <_vfprintf_r+0x180>
8000818a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000818e:	0c 08       	add	r8,r6
80008190:	87 0b       	st.w	r3[0x0],r11
80008192:	fb 48 06 90 	st.w	sp[1680],r8
80008196:	87 16       	st.w	r3[0x4],r6
80008198:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000819c:	2f f8       	sub	r8,-1
8000819e:	fb 48 06 8c 	st.w	sp[1676],r8
800081a2:	58 78       	cp.w	r8,7
800081a4:	e0 89 00 04 	brgt	800081ac <_vfprintf_r+0x168>
800081a8:	2f 83       	sub	r3,-8
800081aa:	c0 a8       	rjmp	800081be <_vfprintf_r+0x17a>
800081ac:	fa ca f9 78 	sub	r10,sp,-1672
800081b0:	02 9b       	mov	r11,r1
800081b2:	08 9c       	mov	r12,r4
800081b4:	c3 af       	rcall	80008028 <__sprint_r>
800081b6:	e0 81 0e c6 	brne	80009f42 <_vfprintf_r+0x1efe>
800081ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800081be:	40 ba       	lddsp	r10,sp[0x2c]
800081c0:	0c 0a       	add	r10,r6
800081c2:	50 ba       	stdsp	sp[0x2c],r10
800081c4:	05 89       	ld.ub	r9,r2[0x0]
800081c6:	30 08       	mov	r8,0
800081c8:	f0 09 18 00 	cp.b	r9,r8
800081cc:	e0 80 0e aa 	breq	80009f20 <_vfprintf_r+0x1edc>
800081d0:	30 09       	mov	r9,0
800081d2:	fb 68 06 bb 	st.b	sp[1723],r8
800081d6:	0e 96       	mov	r6,r7
800081d8:	e4 c8 ff ff 	sub	r8,r2,-1
800081dc:	3f fe       	mov	lr,-1
800081de:	50 93       	stdsp	sp[0x24],r3
800081e0:	50 41       	stdsp	sp[0x10],r1
800081e2:	0e 93       	mov	r3,r7
800081e4:	04 91       	mov	r1,r2
800081e6:	50 89       	stdsp	sp[0x20],r9
800081e8:	50 a8       	stdsp	sp[0x28],r8
800081ea:	50 2e       	stdsp	sp[0x8],lr
800081ec:	50 39       	stdsp	sp[0xc],r9
800081ee:	12 95       	mov	r5,r9
800081f0:	12 90       	mov	r0,r9
800081f2:	10 97       	mov	r7,r8
800081f4:	08 92       	mov	r2,r4
800081f6:	c0 78       	rjmp	80008204 <_vfprintf_r+0x1c0>
800081f8:	3f fc       	mov	r12,-1
800081fa:	08 97       	mov	r7,r4
800081fc:	50 2c       	stdsp	sp[0x8],r12
800081fe:	c0 38       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008200:	30 0b       	mov	r11,0
80008202:	50 3b       	stdsp	sp[0xc],r11
80008204:	0f 38       	ld.ub	r8,r7++
80008206:	c0 28       	rjmp	8000820a <_vfprintf_r+0x1c6>
80008208:	12 90       	mov	r0,r9
8000820a:	f0 c9 00 20 	sub	r9,r8,32
8000820e:	e0 49 00 58 	cp.w	r9,88
80008212:	e0 8b 0a 30 	brhi	80009672 <_vfprintf_r+0x162e>
80008216:	fe ca a4 8a 	sub	r10,pc,-23414
8000821a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000821e:	50 a7       	stdsp	sp[0x28],r7
80008220:	50 80       	stdsp	sp[0x20],r0
80008222:	0c 97       	mov	r7,r6
80008224:	04 94       	mov	r4,r2
80008226:	06 96       	mov	r6,r3
80008228:	02 92       	mov	r2,r1
8000822a:	fe c9 a2 62 	sub	r9,pc,-23966
8000822e:	40 93       	lddsp	r3,sp[0x24]
80008230:	10 90       	mov	r0,r8
80008232:	40 41       	lddsp	r1,sp[0x10]
80008234:	50 d9       	stdsp	sp[0x34],r9
80008236:	e0 8f 08 8e 	bral	80009352 <_vfprintf_r+0x130e>
8000823a:	30 08       	mov	r8,0
8000823c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008240:	f0 09 18 00 	cp.b	r9,r8
80008244:	ce 01       	brne	80008204 <_vfprintf_r+0x1c0>
80008246:	32 08       	mov	r8,32
80008248:	c6 e8       	rjmp	80008324 <_vfprintf_r+0x2e0>
8000824a:	a1 a5       	sbr	r5,0x0
8000824c:	cd cb       	rjmp	80008204 <_vfprintf_r+0x1c0>
8000824e:	0f 89       	ld.ub	r9,r7[0x0]
80008250:	f2 c8 00 30 	sub	r8,r9,48
80008254:	58 98       	cp.w	r8,9
80008256:	e0 8b 00 1d 	brhi	80008290 <_vfprintf_r+0x24c>
8000825a:	ee c8 ff ff 	sub	r8,r7,-1
8000825e:	30 0b       	mov	r11,0
80008260:	23 09       	sub	r9,48
80008262:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008266:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000826a:	11 39       	ld.ub	r9,r8++
8000826c:	f2 ca 00 30 	sub	r10,r9,48
80008270:	58 9a       	cp.w	r10,9
80008272:	fe 98 ff f7 	brls	80008260 <_vfprintf_r+0x21c>
80008276:	e0 49 00 24 	cp.w	r9,36
8000827a:	cc 31       	brne	80008200 <_vfprintf_r+0x1bc>
8000827c:	e0 4b 00 20 	cp.w	r11,32
80008280:	e0 89 0e 60 	brgt	80009f40 <_vfprintf_r+0x1efc>
80008284:	20 1b       	sub	r11,1
80008286:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000828a:	12 3b       	cp.w	r11,r9
8000828c:	c0 95       	brlt	8000829e <_vfprintf_r+0x25a>
8000828e:	c1 08       	rjmp	800082ae <_vfprintf_r+0x26a>
80008290:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008294:	ec ca ff ff 	sub	r10,r6,-1
80008298:	12 36       	cp.w	r6,r9
8000829a:	c1 f5       	brlt	800082d8 <_vfprintf_r+0x294>
8000829c:	c2 68       	rjmp	800082e8 <_vfprintf_r+0x2a4>
8000829e:	fa ce f9 44 	sub	lr,sp,-1724
800082a2:	10 97       	mov	r7,r8
800082a4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800082a8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800082ac:	c3 58       	rjmp	80008316 <_vfprintf_r+0x2d2>
800082ae:	10 97       	mov	r7,r8
800082b0:	fa c8 f9 50 	sub	r8,sp,-1712
800082b4:	1a d8       	st.w	--sp,r8
800082b6:	fa c8 fa b8 	sub	r8,sp,-1352
800082ba:	1a d8       	st.w	--sp,r8
800082bc:	fa c8 fb b4 	sub	r8,sp,-1100
800082c0:	02 9a       	mov	r10,r1
800082c2:	1a d8       	st.w	--sp,r8
800082c4:	04 9c       	mov	r12,r2
800082c6:	fa c8 f9 40 	sub	r8,sp,-1728
800082ca:	fa c9 ff b4 	sub	r9,sp,-76
800082ce:	fe b0 fd 23 	rcall	80007d14 <get_arg>
800082d2:	2f dd       	sub	sp,-12
800082d4:	78 00       	ld.w	r0,r12[0x0]
800082d6:	c2 08       	rjmp	80008316 <_vfprintf_r+0x2d2>
800082d8:	fa cc f9 44 	sub	r12,sp,-1724
800082dc:	14 96       	mov	r6,r10
800082de:	f8 03 00 38 	add	r8,r12,r3<<0x3
800082e2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800082e6:	c1 88       	rjmp	80008316 <_vfprintf_r+0x2d2>
800082e8:	41 08       	lddsp	r8,sp[0x40]
800082ea:	59 f9       	cp.w	r9,31
800082ec:	e0 89 00 11 	brgt	8000830e <_vfprintf_r+0x2ca>
800082f0:	f0 cb ff fc 	sub	r11,r8,-4
800082f4:	51 0b       	stdsp	sp[0x40],r11
800082f6:	70 00       	ld.w	r0,r8[0x0]
800082f8:	fa cb f9 44 	sub	r11,sp,-1724
800082fc:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008300:	f1 40 fd 88 	st.w	r8[-632],r0
80008304:	2f f9       	sub	r9,-1
80008306:	14 96       	mov	r6,r10
80008308:	fb 49 06 b4 	st.w	sp[1716],r9
8000830c:	c0 58       	rjmp	80008316 <_vfprintf_r+0x2d2>
8000830e:	70 00       	ld.w	r0,r8[0x0]
80008310:	14 96       	mov	r6,r10
80008312:	2f c8       	sub	r8,-4
80008314:	51 08       	stdsp	sp[0x40],r8
80008316:	58 00       	cp.w	r0,0
80008318:	fe 94 ff 76 	brge	80008204 <_vfprintf_r+0x1c0>
8000831c:	5c 30       	neg	r0
8000831e:	a3 a5       	sbr	r5,0x2
80008320:	c7 2b       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008322:	32 b8       	mov	r8,43
80008324:	fb 68 06 bb 	st.b	sp[1723],r8
80008328:	c6 eb       	rjmp	80008204 <_vfprintf_r+0x1c0>
8000832a:	0f 38       	ld.ub	r8,r7++
8000832c:	e0 48 00 2a 	cp.w	r8,42
80008330:	c0 30       	breq	80008336 <_vfprintf_r+0x2f2>
80008332:	30 09       	mov	r9,0
80008334:	c7 98       	rjmp	80008426 <_vfprintf_r+0x3e2>
80008336:	0f 88       	ld.ub	r8,r7[0x0]
80008338:	f0 c9 00 30 	sub	r9,r8,48
8000833c:	58 99       	cp.w	r9,9
8000833e:	e0 8b 00 1f 	brhi	8000837c <_vfprintf_r+0x338>
80008342:	ee c4 ff ff 	sub	r4,r7,-1
80008346:	30 0b       	mov	r11,0
80008348:	23 08       	sub	r8,48
8000834a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000834e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008352:	09 38       	ld.ub	r8,r4++
80008354:	f0 c9 00 30 	sub	r9,r8,48
80008358:	58 99       	cp.w	r9,9
8000835a:	fe 98 ff f7 	brls	80008348 <_vfprintf_r+0x304>
8000835e:	e0 48 00 24 	cp.w	r8,36
80008362:	fe 91 ff 4f 	brne	80008200 <_vfprintf_r+0x1bc>
80008366:	e0 4b 00 20 	cp.w	r11,32
8000836a:	e0 89 0d eb 	brgt	80009f40 <_vfprintf_r+0x1efc>
8000836e:	20 1b       	sub	r11,1
80008370:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008374:	10 3b       	cp.w	r11,r8
80008376:	c0 a5       	brlt	8000838a <_vfprintf_r+0x346>
80008378:	c1 18       	rjmp	8000839a <_vfprintf_r+0x356>
8000837a:	d7 03       	nop
8000837c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008380:	ec c9 ff ff 	sub	r9,r6,-1
80008384:	14 36       	cp.w	r6,r10
80008386:	c1 f5       	brlt	800083c4 <_vfprintf_r+0x380>
80008388:	c2 88       	rjmp	800083d8 <_vfprintf_r+0x394>
8000838a:	fa ca f9 44 	sub	r10,sp,-1724
8000838e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008392:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008396:	50 2b       	stdsp	sp[0x8],r11
80008398:	c3 c8       	rjmp	80008410 <_vfprintf_r+0x3cc>
8000839a:	fa c8 f9 50 	sub	r8,sp,-1712
8000839e:	1a d8       	st.w	--sp,r8
800083a0:	fa c8 fa b8 	sub	r8,sp,-1352
800083a4:	1a d8       	st.w	--sp,r8
800083a6:	fa c8 fb b4 	sub	r8,sp,-1100
800083aa:	02 9a       	mov	r10,r1
800083ac:	1a d8       	st.w	--sp,r8
800083ae:	04 9c       	mov	r12,r2
800083b0:	fa c8 f9 40 	sub	r8,sp,-1728
800083b4:	fa c9 ff b4 	sub	r9,sp,-76
800083b8:	fe b0 fc ae 	rcall	80007d14 <get_arg>
800083bc:	2f dd       	sub	sp,-12
800083be:	78 0c       	ld.w	r12,r12[0x0]
800083c0:	50 2c       	stdsp	sp[0x8],r12
800083c2:	c2 78       	rjmp	80008410 <_vfprintf_r+0x3cc>
800083c4:	12 96       	mov	r6,r9
800083c6:	0e 94       	mov	r4,r7
800083c8:	fa c9 f9 44 	sub	r9,sp,-1724
800083cc:	f2 03 00 38 	add	r8,r9,r3<<0x3
800083d0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800083d4:	50 28       	stdsp	sp[0x8],r8
800083d6:	c1 d8       	rjmp	80008410 <_vfprintf_r+0x3cc>
800083d8:	41 08       	lddsp	r8,sp[0x40]
800083da:	59 fa       	cp.w	r10,31
800083dc:	e0 89 00 14 	brgt	80008404 <_vfprintf_r+0x3c0>
800083e0:	f0 cb ff fc 	sub	r11,r8,-4
800083e4:	70 08       	ld.w	r8,r8[0x0]
800083e6:	51 0b       	stdsp	sp[0x40],r11
800083e8:	50 28       	stdsp	sp[0x8],r8
800083ea:	fa c6 f9 44 	sub	r6,sp,-1724
800083ee:	40 2e       	lddsp	lr,sp[0x8]
800083f0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800083f4:	f1 4e fd 88 	st.w	r8[-632],lr
800083f8:	2f fa       	sub	r10,-1
800083fa:	0e 94       	mov	r4,r7
800083fc:	fb 4a 06 b4 	st.w	sp[1716],r10
80008400:	12 96       	mov	r6,r9
80008402:	c0 78       	rjmp	80008410 <_vfprintf_r+0x3cc>
80008404:	70 0c       	ld.w	r12,r8[0x0]
80008406:	0e 94       	mov	r4,r7
80008408:	2f c8       	sub	r8,-4
8000840a:	50 2c       	stdsp	sp[0x8],r12
8000840c:	12 96       	mov	r6,r9
8000840e:	51 08       	stdsp	sp[0x40],r8
80008410:	40 2b       	lddsp	r11,sp[0x8]
80008412:	58 0b       	cp.w	r11,0
80008414:	fe 95 fe f2 	brlt	800081f8 <_vfprintf_r+0x1b4>
80008418:	08 97       	mov	r7,r4
8000841a:	cf 5a       	rjmp	80008204 <_vfprintf_r+0x1c0>
8000841c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008420:	0f 38       	ld.ub	r8,r7++
80008422:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008426:	f0 ca 00 30 	sub	r10,r8,48
8000842a:	58 9a       	cp.w	r10,9
8000842c:	fe 98 ff f8 	brls	8000841c <_vfprintf_r+0x3d8>
80008430:	3f fa       	mov	r10,-1
80008432:	f2 0a 0c 49 	max	r9,r9,r10
80008436:	50 29       	stdsp	sp[0x8],r9
80008438:	ce 9a       	rjmp	8000820a <_vfprintf_r+0x1c6>
8000843a:	a7 b5       	sbr	r5,0x7
8000843c:	ce 4a       	rjmp	80008204 <_vfprintf_r+0x1c0>
8000843e:	30 09       	mov	r9,0
80008440:	23 08       	sub	r8,48
80008442:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008446:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000844a:	0f 38       	ld.ub	r8,r7++
8000844c:	f0 ca 00 30 	sub	r10,r8,48
80008450:	58 9a       	cp.w	r10,9
80008452:	fe 98 ff f7 	brls	80008440 <_vfprintf_r+0x3fc>
80008456:	e0 48 00 24 	cp.w	r8,36
8000845a:	fe 91 fe d7 	brne	80008208 <_vfprintf_r+0x1c4>
8000845e:	e0 49 00 20 	cp.w	r9,32
80008462:	e0 89 0d 6f 	brgt	80009f40 <_vfprintf_r+0x1efc>
80008466:	f2 c3 00 01 	sub	r3,r9,1
8000846a:	30 19       	mov	r9,1
8000846c:	50 39       	stdsp	sp[0xc],r9
8000846e:	cc ba       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008470:	a3 b5       	sbr	r5,0x3
80008472:	cc 9a       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008474:	a7 a5       	sbr	r5,0x6
80008476:	cc 7a       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008478:	0a 98       	mov	r8,r5
8000847a:	a5 b5       	sbr	r5,0x5
8000847c:	a5 a8       	sbr	r8,0x4
8000847e:	0f 89       	ld.ub	r9,r7[0x0]
80008480:	36 ce       	mov	lr,108
80008482:	fc 09 18 00 	cp.b	r9,lr
80008486:	f7 b7 00 ff 	subeq	r7,-1
8000848a:	f0 05 17 10 	movne	r5,r8
8000848e:	cb ba       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008490:	a5 b5       	sbr	r5,0x5
80008492:	cb 9a       	rjmp	80008204 <_vfprintf_r+0x1c0>
80008494:	50 a7       	stdsp	sp[0x28],r7
80008496:	50 80       	stdsp	sp[0x20],r0
80008498:	0c 97       	mov	r7,r6
8000849a:	10 90       	mov	r0,r8
8000849c:	06 96       	mov	r6,r3
8000849e:	04 94       	mov	r4,r2
800084a0:	40 93       	lddsp	r3,sp[0x24]
800084a2:	02 92       	mov	r2,r1
800084a4:	0e 99       	mov	r9,r7
800084a6:	40 41       	lddsp	r1,sp[0x10]
800084a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084ac:	40 3c       	lddsp	r12,sp[0xc]
800084ae:	58 0c       	cp.w	r12,0
800084b0:	c1 d0       	breq	800084ea <_vfprintf_r+0x4a6>
800084b2:	10 36       	cp.w	r6,r8
800084b4:	c0 64       	brge	800084c0 <_vfprintf_r+0x47c>
800084b6:	fa cb f9 44 	sub	r11,sp,-1724
800084ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084be:	c1 d8       	rjmp	800084f8 <_vfprintf_r+0x4b4>
800084c0:	fa c8 f9 50 	sub	r8,sp,-1712
800084c4:	1a d8       	st.w	--sp,r8
800084c6:	fa c8 fa b8 	sub	r8,sp,-1352
800084ca:	1a d8       	st.w	--sp,r8
800084cc:	fa c8 fb b4 	sub	r8,sp,-1100
800084d0:	1a d8       	st.w	--sp,r8
800084d2:	fa c8 f9 40 	sub	r8,sp,-1728
800084d6:	fa c9 ff b4 	sub	r9,sp,-76
800084da:	04 9a       	mov	r10,r2
800084dc:	0c 9b       	mov	r11,r6
800084de:	08 9c       	mov	r12,r4
800084e0:	fe b0 fc 1a 	rcall	80007d14 <get_arg>
800084e4:	2f dd       	sub	sp,-12
800084e6:	19 b8       	ld.ub	r8,r12[0x3]
800084e8:	c2 28       	rjmp	8000852c <_vfprintf_r+0x4e8>
800084ea:	2f f7       	sub	r7,-1
800084ec:	10 39       	cp.w	r9,r8
800084ee:	c0 84       	brge	800084fe <_vfprintf_r+0x4ba>
800084f0:	fa ca f9 44 	sub	r10,sp,-1724
800084f4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084f8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800084fc:	c1 88       	rjmp	8000852c <_vfprintf_r+0x4e8>
800084fe:	41 09       	lddsp	r9,sp[0x40]
80008500:	59 f8       	cp.w	r8,31
80008502:	e0 89 00 12 	brgt	80008526 <_vfprintf_r+0x4e2>
80008506:	f2 ca ff fc 	sub	r10,r9,-4
8000850a:	51 0a       	stdsp	sp[0x40],r10
8000850c:	72 09       	ld.w	r9,r9[0x0]
8000850e:	fa c6 f9 44 	sub	r6,sp,-1724
80008512:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008516:	2f f8       	sub	r8,-1
80008518:	f5 49 fd 88 	st.w	r10[-632],r9
8000851c:	fb 48 06 b4 	st.w	sp[1716],r8
80008520:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008524:	c0 48       	rjmp	8000852c <_vfprintf_r+0x4e8>
80008526:	13 b8       	ld.ub	r8,r9[0x3]
80008528:	2f c9       	sub	r9,-4
8000852a:	51 09       	stdsp	sp[0x40],r9
8000852c:	fb 68 06 60 	st.b	sp[1632],r8
80008530:	30 0e       	mov	lr,0
80008532:	30 08       	mov	r8,0
80008534:	30 12       	mov	r2,1
80008536:	fb 68 06 bb 	st.b	sp[1723],r8
8000853a:	50 2e       	stdsp	sp[0x8],lr
8000853c:	e0 8f 08 ad 	bral	80009696 <_vfprintf_r+0x1652>
80008540:	50 a7       	stdsp	sp[0x28],r7
80008542:	50 80       	stdsp	sp[0x20],r0
80008544:	0c 97       	mov	r7,r6
80008546:	04 94       	mov	r4,r2
80008548:	06 96       	mov	r6,r3
8000854a:	02 92       	mov	r2,r1
8000854c:	40 93       	lddsp	r3,sp[0x24]
8000854e:	10 90       	mov	r0,r8
80008550:	40 41       	lddsp	r1,sp[0x10]
80008552:	a5 a5       	sbr	r5,0x4
80008554:	c0 a8       	rjmp	80008568 <_vfprintf_r+0x524>
80008556:	50 a7       	stdsp	sp[0x28],r7
80008558:	50 80       	stdsp	sp[0x20],r0
8000855a:	0c 97       	mov	r7,r6
8000855c:	04 94       	mov	r4,r2
8000855e:	06 96       	mov	r6,r3
80008560:	02 92       	mov	r2,r1
80008562:	40 93       	lddsp	r3,sp[0x24]
80008564:	10 90       	mov	r0,r8
80008566:	40 41       	lddsp	r1,sp[0x10]
80008568:	ed b5 00 05 	bld	r5,0x5
8000856c:	c5 11       	brne	8000860e <_vfprintf_r+0x5ca>
8000856e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008572:	40 3c       	lddsp	r12,sp[0xc]
80008574:	58 0c       	cp.w	r12,0
80008576:	c1 e0       	breq	800085b2 <_vfprintf_r+0x56e>
80008578:	10 36       	cp.w	r6,r8
8000857a:	c0 64       	brge	80008586 <_vfprintf_r+0x542>
8000857c:	fa cb f9 44 	sub	r11,sp,-1724
80008580:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008584:	c2 08       	rjmp	800085c4 <_vfprintf_r+0x580>
80008586:	fa c8 f9 50 	sub	r8,sp,-1712
8000858a:	1a d8       	st.w	--sp,r8
8000858c:	fa c8 fa b8 	sub	r8,sp,-1352
80008590:	0c 9b       	mov	r11,r6
80008592:	1a d8       	st.w	--sp,r8
80008594:	fa c8 fb b4 	sub	r8,sp,-1100
80008598:	1a d8       	st.w	--sp,r8
8000859a:	fa c9 ff b4 	sub	r9,sp,-76
8000859e:	fa c8 f9 40 	sub	r8,sp,-1728
800085a2:	04 9a       	mov	r10,r2
800085a4:	08 9c       	mov	r12,r4
800085a6:	fe b0 fb b7 	rcall	80007d14 <get_arg>
800085aa:	2f dd       	sub	sp,-12
800085ac:	78 1b       	ld.w	r11,r12[0x4]
800085ae:	78 09       	ld.w	r9,r12[0x0]
800085b0:	c2 b8       	rjmp	80008606 <_vfprintf_r+0x5c2>
800085b2:	ee ca ff ff 	sub	r10,r7,-1
800085b6:	10 37       	cp.w	r7,r8
800085b8:	c0 b4       	brge	800085ce <_vfprintf_r+0x58a>
800085ba:	fa c9 f9 44 	sub	r9,sp,-1724
800085be:	14 97       	mov	r7,r10
800085c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085c4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800085c8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800085cc:	c1 d8       	rjmp	80008606 <_vfprintf_r+0x5c2>
800085ce:	41 09       	lddsp	r9,sp[0x40]
800085d0:	59 f8       	cp.w	r8,31
800085d2:	e0 89 00 14 	brgt	800085fa <_vfprintf_r+0x5b6>
800085d6:	f2 cb ff f8 	sub	r11,r9,-8
800085da:	51 0b       	stdsp	sp[0x40],r11
800085dc:	fa c6 f9 44 	sub	r6,sp,-1724
800085e0:	72 1b       	ld.w	r11,r9[0x4]
800085e2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800085e6:	72 09       	ld.w	r9,r9[0x0]
800085e8:	f9 4b fd 8c 	st.w	r12[-628],r11
800085ec:	f9 49 fd 88 	st.w	r12[-632],r9
800085f0:	2f f8       	sub	r8,-1
800085f2:	14 97       	mov	r7,r10
800085f4:	fb 48 06 b4 	st.w	sp[1716],r8
800085f8:	c0 78       	rjmp	80008606 <_vfprintf_r+0x5c2>
800085fa:	f2 c8 ff f8 	sub	r8,r9,-8
800085fe:	72 1b       	ld.w	r11,r9[0x4]
80008600:	14 97       	mov	r7,r10
80008602:	51 08       	stdsp	sp[0x40],r8
80008604:	72 09       	ld.w	r9,r9[0x0]
80008606:	16 98       	mov	r8,r11
80008608:	fa e9 00 00 	st.d	sp[0],r8
8000860c:	ca e8       	rjmp	80008768 <_vfprintf_r+0x724>
8000860e:	ed b5 00 04 	bld	r5,0x4
80008612:	c1 71       	brne	80008640 <_vfprintf_r+0x5fc>
80008614:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008618:	40 3e       	lddsp	lr,sp[0xc]
8000861a:	58 0e       	cp.w	lr,0
8000861c:	c0 80       	breq	8000862c <_vfprintf_r+0x5e8>
8000861e:	10 36       	cp.w	r6,r8
80008620:	c6 94       	brge	800086f2 <_vfprintf_r+0x6ae>
80008622:	fa cc f9 44 	sub	r12,sp,-1724
80008626:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000862a:	c8 28       	rjmp	8000872e <_vfprintf_r+0x6ea>
8000862c:	ee ca ff ff 	sub	r10,r7,-1
80008630:	10 37       	cp.w	r7,r8
80008632:	e0 84 00 81 	brge	80008734 <_vfprintf_r+0x6f0>
80008636:	fa cb f9 44 	sub	r11,sp,-1724
8000863a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000863e:	c7 78       	rjmp	8000872c <_vfprintf_r+0x6e8>
80008640:	ed b5 00 06 	bld	r5,0x6
80008644:	c4 b1       	brne	800086da <_vfprintf_r+0x696>
80008646:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000864a:	40 3c       	lddsp	r12,sp[0xc]
8000864c:	58 0c       	cp.w	r12,0
8000864e:	c1 d0       	breq	80008688 <_vfprintf_r+0x644>
80008650:	10 36       	cp.w	r6,r8
80008652:	c0 64       	brge	8000865e <_vfprintf_r+0x61a>
80008654:	fa cb f9 44 	sub	r11,sp,-1724
80008658:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000865c:	c1 f8       	rjmp	8000869a <_vfprintf_r+0x656>
8000865e:	fa c8 f9 50 	sub	r8,sp,-1712
80008662:	1a d8       	st.w	--sp,r8
80008664:	fa c8 fa b8 	sub	r8,sp,-1352
80008668:	1a d8       	st.w	--sp,r8
8000866a:	fa c8 fb b4 	sub	r8,sp,-1100
8000866e:	1a d8       	st.w	--sp,r8
80008670:	fa c8 f9 40 	sub	r8,sp,-1728
80008674:	fa c9 ff b4 	sub	r9,sp,-76
80008678:	04 9a       	mov	r10,r2
8000867a:	0c 9b       	mov	r11,r6
8000867c:	08 9c       	mov	r12,r4
8000867e:	fe b0 fb 4b 	rcall	80007d14 <get_arg>
80008682:	2f dd       	sub	sp,-12
80008684:	98 18       	ld.sh	r8,r12[0x2]
80008686:	c2 68       	rjmp	800086d2 <_vfprintf_r+0x68e>
80008688:	ee ca ff ff 	sub	r10,r7,-1
8000868c:	10 37       	cp.w	r7,r8
8000868e:	c0 94       	brge	800086a0 <_vfprintf_r+0x65c>
80008690:	fa c9 f9 44 	sub	r9,sp,-1724
80008694:	14 97       	mov	r7,r10
80008696:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000869a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000869e:	c1 a8       	rjmp	800086d2 <_vfprintf_r+0x68e>
800086a0:	41 09       	lddsp	r9,sp[0x40]
800086a2:	59 f8       	cp.w	r8,31
800086a4:	e0 89 00 13 	brgt	800086ca <_vfprintf_r+0x686>
800086a8:	f2 cb ff fc 	sub	r11,r9,-4
800086ac:	51 0b       	stdsp	sp[0x40],r11
800086ae:	72 09       	ld.w	r9,r9[0x0]
800086b0:	fa c6 f9 44 	sub	r6,sp,-1724
800086b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086b8:	2f f8       	sub	r8,-1
800086ba:	f7 49 fd 88 	st.w	r11[-632],r9
800086be:	fb 48 06 b4 	st.w	sp[1716],r8
800086c2:	14 97       	mov	r7,r10
800086c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086c8:	c0 58       	rjmp	800086d2 <_vfprintf_r+0x68e>
800086ca:	92 18       	ld.sh	r8,r9[0x2]
800086cc:	14 97       	mov	r7,r10
800086ce:	2f c9       	sub	r9,-4
800086d0:	51 09       	stdsp	sp[0x40],r9
800086d2:	50 18       	stdsp	sp[0x4],r8
800086d4:	bf 58       	asr	r8,0x1f
800086d6:	50 08       	stdsp	sp[0x0],r8
800086d8:	c4 88       	rjmp	80008768 <_vfprintf_r+0x724>
800086da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086de:	40 3c       	lddsp	r12,sp[0xc]
800086e0:	58 0c       	cp.w	r12,0
800086e2:	c1 d0       	breq	8000871c <_vfprintf_r+0x6d8>
800086e4:	10 36       	cp.w	r6,r8
800086e6:	c0 64       	brge	800086f2 <_vfprintf_r+0x6ae>
800086e8:	fa cb f9 44 	sub	r11,sp,-1724
800086ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086f0:	c1 f8       	rjmp	8000872e <_vfprintf_r+0x6ea>
800086f2:	fa c8 f9 50 	sub	r8,sp,-1712
800086f6:	1a d8       	st.w	--sp,r8
800086f8:	fa c8 fa b8 	sub	r8,sp,-1352
800086fc:	0c 9b       	mov	r11,r6
800086fe:	1a d8       	st.w	--sp,r8
80008700:	fa c8 fb b4 	sub	r8,sp,-1100
80008704:	04 9a       	mov	r10,r2
80008706:	1a d8       	st.w	--sp,r8
80008708:	08 9c       	mov	r12,r4
8000870a:	fa c8 f9 40 	sub	r8,sp,-1728
8000870e:	fa c9 ff b4 	sub	r9,sp,-76
80008712:	fe b0 fb 01 	rcall	80007d14 <get_arg>
80008716:	2f dd       	sub	sp,-12
80008718:	78 0b       	ld.w	r11,r12[0x0]
8000871a:	c2 48       	rjmp	80008762 <_vfprintf_r+0x71e>
8000871c:	ee ca ff ff 	sub	r10,r7,-1
80008720:	10 37       	cp.w	r7,r8
80008722:	c0 94       	brge	80008734 <_vfprintf_r+0x6f0>
80008724:	fa c9 f9 44 	sub	r9,sp,-1724
80008728:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000872c:	14 97       	mov	r7,r10
8000872e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008732:	c1 88       	rjmp	80008762 <_vfprintf_r+0x71e>
80008734:	41 09       	lddsp	r9,sp[0x40]
80008736:	59 f8       	cp.w	r8,31
80008738:	e0 89 00 11 	brgt	8000875a <_vfprintf_r+0x716>
8000873c:	f2 cb ff fc 	sub	r11,r9,-4
80008740:	51 0b       	stdsp	sp[0x40],r11
80008742:	fa c6 f9 44 	sub	r6,sp,-1724
80008746:	72 0b       	ld.w	r11,r9[0x0]
80008748:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000874c:	f3 4b fd 88 	st.w	r9[-632],r11
80008750:	2f f8       	sub	r8,-1
80008752:	14 97       	mov	r7,r10
80008754:	fb 48 06 b4 	st.w	sp[1716],r8
80008758:	c0 58       	rjmp	80008762 <_vfprintf_r+0x71e>
8000875a:	72 0b       	ld.w	r11,r9[0x0]
8000875c:	14 97       	mov	r7,r10
8000875e:	2f c9       	sub	r9,-4
80008760:	51 09       	stdsp	sp[0x40],r9
80008762:	50 1b       	stdsp	sp[0x4],r11
80008764:	bf 5b       	asr	r11,0x1f
80008766:	50 0b       	stdsp	sp[0x0],r11
80008768:	fa ea 00 00 	ld.d	r10,sp[0]
8000876c:	58 0a       	cp.w	r10,0
8000876e:	5c 2b       	cpc	r11
80008770:	c0 e4       	brge	8000878c <_vfprintf_r+0x748>
80008772:	30 08       	mov	r8,0
80008774:	fa ea 00 00 	ld.d	r10,sp[0]
80008778:	30 09       	mov	r9,0
8000877a:	f0 0a 01 0a 	sub	r10,r8,r10
8000877e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008782:	32 d8       	mov	r8,45
80008784:	fa eb 00 00 	st.d	sp[0],r10
80008788:	fb 68 06 bb 	st.b	sp[1723],r8
8000878c:	30 18       	mov	r8,1
8000878e:	e0 8f 06 fa 	bral	80009582 <_vfprintf_r+0x153e>
80008792:	50 a7       	stdsp	sp[0x28],r7
80008794:	50 80       	stdsp	sp[0x20],r0
80008796:	0c 97       	mov	r7,r6
80008798:	04 94       	mov	r4,r2
8000879a:	06 96       	mov	r6,r3
8000879c:	02 92       	mov	r2,r1
8000879e:	40 93       	lddsp	r3,sp[0x24]
800087a0:	10 90       	mov	r0,r8
800087a2:	40 41       	lddsp	r1,sp[0x10]
800087a4:	0e 99       	mov	r9,r7
800087a6:	ed b5 00 03 	bld	r5,0x3
800087aa:	c4 11       	brne	8000882c <_vfprintf_r+0x7e8>
800087ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087b0:	40 3a       	lddsp	r10,sp[0xc]
800087b2:	58 0a       	cp.w	r10,0
800087b4:	c1 90       	breq	800087e6 <_vfprintf_r+0x7a2>
800087b6:	10 36       	cp.w	r6,r8
800087b8:	c6 45       	brlt	80008880 <_vfprintf_r+0x83c>
800087ba:	fa c8 f9 50 	sub	r8,sp,-1712
800087be:	1a d8       	st.w	--sp,r8
800087c0:	fa c8 fa b8 	sub	r8,sp,-1352
800087c4:	1a d8       	st.w	--sp,r8
800087c6:	fa c8 fb b4 	sub	r8,sp,-1100
800087ca:	0c 9b       	mov	r11,r6
800087cc:	1a d8       	st.w	--sp,r8
800087ce:	04 9a       	mov	r10,r2
800087d0:	fa c8 f9 40 	sub	r8,sp,-1728
800087d4:	fa c9 ff b4 	sub	r9,sp,-76
800087d8:	08 9c       	mov	r12,r4
800087da:	fe b0 fa 9d 	rcall	80007d14 <get_arg>
800087de:	2f dd       	sub	sp,-12
800087e0:	78 16       	ld.w	r6,r12[0x4]
800087e2:	50 76       	stdsp	sp[0x1c],r6
800087e4:	c4 88       	rjmp	80008874 <_vfprintf_r+0x830>
800087e6:	2f f7       	sub	r7,-1
800087e8:	10 39       	cp.w	r9,r8
800087ea:	c0 c4       	brge	80008802 <_vfprintf_r+0x7be>
800087ec:	fa ce f9 44 	sub	lr,sp,-1724
800087f0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800087f4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800087f8:	50 7c       	stdsp	sp[0x1c],r12
800087fa:	ec f6 fd 88 	ld.w	r6,r6[-632]
800087fe:	50 56       	stdsp	sp[0x14],r6
80008800:	c6 68       	rjmp	800088cc <_vfprintf_r+0x888>
80008802:	41 09       	lddsp	r9,sp[0x40]
80008804:	59 f8       	cp.w	r8,31
80008806:	e0 89 00 10 	brgt	80008826 <_vfprintf_r+0x7e2>
8000880a:	f2 ca ff f8 	sub	r10,r9,-8
8000880e:	72 1b       	ld.w	r11,r9[0x4]
80008810:	51 0a       	stdsp	sp[0x40],r10
80008812:	72 09       	ld.w	r9,r9[0x0]
80008814:	fa ca f9 44 	sub	r10,sp,-1724
80008818:	50 7b       	stdsp	sp[0x1c],r11
8000881a:	50 59       	stdsp	sp[0x14],r9
8000881c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008820:	40 5b       	lddsp	r11,sp[0x14]
80008822:	40 7a       	lddsp	r10,sp[0x1c]
80008824:	c4 78       	rjmp	800088b2 <_vfprintf_r+0x86e>
80008826:	72 18       	ld.w	r8,r9[0x4]
80008828:	50 78       	stdsp	sp[0x1c],r8
8000882a:	c4 c8       	rjmp	800088c2 <_vfprintf_r+0x87e>
8000882c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008830:	40 3e       	lddsp	lr,sp[0xc]
80008832:	58 0e       	cp.w	lr,0
80008834:	c2 30       	breq	8000887a <_vfprintf_r+0x836>
80008836:	10 36       	cp.w	r6,r8
80008838:	c0 94       	brge	8000884a <_vfprintf_r+0x806>
8000883a:	fa cc f9 44 	sub	r12,sp,-1724
8000883e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008842:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008846:	50 7b       	stdsp	sp[0x1c],r11
80008848:	cd 9b       	rjmp	800087fa <_vfprintf_r+0x7b6>
8000884a:	fa c8 f9 50 	sub	r8,sp,-1712
8000884e:	1a d8       	st.w	--sp,r8
80008850:	fa c8 fa b8 	sub	r8,sp,-1352
80008854:	04 9a       	mov	r10,r2
80008856:	1a d8       	st.w	--sp,r8
80008858:	fa c8 fb b4 	sub	r8,sp,-1100
8000885c:	0c 9b       	mov	r11,r6
8000885e:	1a d8       	st.w	--sp,r8
80008860:	08 9c       	mov	r12,r4
80008862:	fa c8 f9 40 	sub	r8,sp,-1728
80008866:	fa c9 ff b4 	sub	r9,sp,-76
8000886a:	fe b0 fa 55 	rcall	80007d14 <get_arg>
8000886e:	2f dd       	sub	sp,-12
80008870:	78 1a       	ld.w	r10,r12[0x4]
80008872:	50 7a       	stdsp	sp[0x1c],r10
80008874:	78 0c       	ld.w	r12,r12[0x0]
80008876:	50 5c       	stdsp	sp[0x14],r12
80008878:	c2 a8       	rjmp	800088cc <_vfprintf_r+0x888>
8000887a:	2f f7       	sub	r7,-1
8000887c:	10 39       	cp.w	r9,r8
8000887e:	c0 94       	brge	80008890 <_vfprintf_r+0x84c>
80008880:	fa c9 f9 44 	sub	r9,sp,-1724
80008884:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008888:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000888c:	50 78       	stdsp	sp[0x1c],r8
8000888e:	cb 6b       	rjmp	800087fa <_vfprintf_r+0x7b6>
80008890:	41 09       	lddsp	r9,sp[0x40]
80008892:	59 f8       	cp.w	r8,31
80008894:	e0 89 00 15 	brgt	800088be <_vfprintf_r+0x87a>
80008898:	f2 ca ff f8 	sub	r10,r9,-8
8000889c:	72 16       	ld.w	r6,r9[0x4]
8000889e:	72 09       	ld.w	r9,r9[0x0]
800088a0:	51 0a       	stdsp	sp[0x40],r10
800088a2:	50 59       	stdsp	sp[0x14],r9
800088a4:	fa ce f9 44 	sub	lr,sp,-1724
800088a8:	50 76       	stdsp	sp[0x1c],r6
800088aa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800088ae:	40 5b       	lddsp	r11,sp[0x14]
800088b0:	0c 9a       	mov	r10,r6
800088b2:	f2 eb fd 88 	st.d	r9[-632],r10
800088b6:	2f f8       	sub	r8,-1
800088b8:	fb 48 06 b4 	st.w	sp[1716],r8
800088bc:	c0 88       	rjmp	800088cc <_vfprintf_r+0x888>
800088be:	72 1c       	ld.w	r12,r9[0x4]
800088c0:	50 7c       	stdsp	sp[0x1c],r12
800088c2:	f2 c8 ff f8 	sub	r8,r9,-8
800088c6:	51 08       	stdsp	sp[0x40],r8
800088c8:	72 09       	ld.w	r9,r9[0x0]
800088ca:	50 59       	stdsp	sp[0x14],r9
800088cc:	40 5b       	lddsp	r11,sp[0x14]
800088ce:	40 7a       	lddsp	r10,sp[0x1c]
800088d0:	e0 a0 19 54 	rcall	8000bb78 <__isinfd>
800088d4:	18 96       	mov	r6,r12
800088d6:	c1 70       	breq	80008904 <_vfprintf_r+0x8c0>
800088d8:	30 08       	mov	r8,0
800088da:	30 09       	mov	r9,0
800088dc:	40 5b       	lddsp	r11,sp[0x14]
800088de:	40 7a       	lddsp	r10,sp[0x1c]
800088e0:	e0 a0 1d b4 	rcall	8000c448 <__avr32_f64_cmp_lt>
800088e4:	c0 40       	breq	800088ec <_vfprintf_r+0x8a8>
800088e6:	32 d8       	mov	r8,45
800088e8:	fb 68 06 bb 	st.b	sp[1723],r8
800088ec:	fe c8 a9 10 	sub	r8,pc,-22256
800088f0:	fe c6 a9 10 	sub	r6,pc,-22256
800088f4:	a7 d5       	cbr	r5,0x7
800088f6:	e0 40 00 47 	cp.w	r0,71
800088fa:	f0 06 17 a0 	movle	r6,r8
800088fe:	30 32       	mov	r2,3
80008900:	e0 8f 06 ce 	bral	8000969c <_vfprintf_r+0x1658>
80008904:	40 5b       	lddsp	r11,sp[0x14]
80008906:	40 7a       	lddsp	r10,sp[0x1c]
80008908:	e0 a0 19 4d 	rcall	8000bba2 <__isnand>
8000890c:	c0 e0       	breq	80008928 <_vfprintf_r+0x8e4>
8000890e:	50 26       	stdsp	sp[0x8],r6
80008910:	fe c8 a9 2c 	sub	r8,pc,-22228
80008914:	fe c6 a9 2c 	sub	r6,pc,-22228
80008918:	a7 d5       	cbr	r5,0x7
8000891a:	e0 40 00 47 	cp.w	r0,71
8000891e:	f0 06 17 a0 	movle	r6,r8
80008922:	30 32       	mov	r2,3
80008924:	e0 8f 06 c2 	bral	800096a8 <_vfprintf_r+0x1664>
80008928:	40 2a       	lddsp	r10,sp[0x8]
8000892a:	5b fa       	cp.w	r10,-1
8000892c:	c0 41       	brne	80008934 <_vfprintf_r+0x8f0>
8000892e:	30 69       	mov	r9,6
80008930:	50 29       	stdsp	sp[0x8],r9
80008932:	c1 18       	rjmp	80008954 <_vfprintf_r+0x910>
80008934:	e0 40 00 47 	cp.w	r0,71
80008938:	5f 09       	sreq	r9
8000893a:	e0 40 00 67 	cp.w	r0,103
8000893e:	5f 08       	sreq	r8
80008940:	f3 e8 10 08 	or	r8,r9,r8
80008944:	f8 08 18 00 	cp.b	r8,r12
80008948:	c0 60       	breq	80008954 <_vfprintf_r+0x910>
8000894a:	40 28       	lddsp	r8,sp[0x8]
8000894c:	58 08       	cp.w	r8,0
8000894e:	f9 b8 00 01 	moveq	r8,1
80008952:	50 28       	stdsp	sp[0x8],r8
80008954:	40 78       	lddsp	r8,sp[0x1c]
80008956:	40 59       	lddsp	r9,sp[0x14]
80008958:	fa e9 06 94 	st.d	sp[1684],r8
8000895c:	a9 a5       	sbr	r5,0x8
8000895e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008962:	58 08       	cp.w	r8,0
80008964:	c0 65       	brlt	80008970 <_vfprintf_r+0x92c>
80008966:	40 5e       	lddsp	lr,sp[0x14]
80008968:	30 0c       	mov	r12,0
8000896a:	50 6e       	stdsp	sp[0x18],lr
8000896c:	50 9c       	stdsp	sp[0x24],r12
8000896e:	c0 78       	rjmp	8000897c <_vfprintf_r+0x938>
80008970:	40 5b       	lddsp	r11,sp[0x14]
80008972:	32 da       	mov	r10,45
80008974:	ee 1b 80 00 	eorh	r11,0x8000
80008978:	50 9a       	stdsp	sp[0x24],r10
8000897a:	50 6b       	stdsp	sp[0x18],r11
8000897c:	e0 40 00 46 	cp.w	r0,70
80008980:	5f 09       	sreq	r9
80008982:	e0 40 00 66 	cp.w	r0,102
80008986:	5f 08       	sreq	r8
80008988:	f3 e8 10 08 	or	r8,r9,r8
8000898c:	50 48       	stdsp	sp[0x10],r8
8000898e:	c0 40       	breq	80008996 <_vfprintf_r+0x952>
80008990:	40 22       	lddsp	r2,sp[0x8]
80008992:	30 39       	mov	r9,3
80008994:	c1 08       	rjmp	800089b4 <_vfprintf_r+0x970>
80008996:	e0 40 00 45 	cp.w	r0,69
8000899a:	5f 09       	sreq	r9
8000899c:	e0 40 00 65 	cp.w	r0,101
800089a0:	5f 08       	sreq	r8
800089a2:	40 22       	lddsp	r2,sp[0x8]
800089a4:	10 49       	or	r9,r8
800089a6:	2f f2       	sub	r2,-1
800089a8:	40 46       	lddsp	r6,sp[0x10]
800089aa:	ec 09 18 00 	cp.b	r9,r6
800089ae:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800089b2:	30 29       	mov	r9,2
800089b4:	fa c8 f9 5c 	sub	r8,sp,-1700
800089b8:	1a d8       	st.w	--sp,r8
800089ba:	fa c8 f9 54 	sub	r8,sp,-1708
800089be:	1a d8       	st.w	--sp,r8
800089c0:	fa c8 f9 4c 	sub	r8,sp,-1716
800089c4:	08 9c       	mov	r12,r4
800089c6:	1a d8       	st.w	--sp,r8
800089c8:	04 98       	mov	r8,r2
800089ca:	40 9b       	lddsp	r11,sp[0x24]
800089cc:	40 aa       	lddsp	r10,sp[0x28]
800089ce:	e0 a0 0b c3 	rcall	8000a154 <_dtoa_r>
800089d2:	e0 40 00 47 	cp.w	r0,71
800089d6:	5f 19       	srne	r9
800089d8:	e0 40 00 67 	cp.w	r0,103
800089dc:	5f 18       	srne	r8
800089de:	18 96       	mov	r6,r12
800089e0:	2f dd       	sub	sp,-12
800089e2:	f3 e8 00 08 	and	r8,r9,r8
800089e6:	c0 41       	brne	800089ee <_vfprintf_r+0x9aa>
800089e8:	ed b5 00 00 	bld	r5,0x0
800089ec:	c3 01       	brne	80008a4c <_vfprintf_r+0xa08>
800089ee:	ec 02 00 0e 	add	lr,r6,r2
800089f2:	50 3e       	stdsp	sp[0xc],lr
800089f4:	40 4c       	lddsp	r12,sp[0x10]
800089f6:	58 0c       	cp.w	r12,0
800089f8:	c1 50       	breq	80008a22 <_vfprintf_r+0x9de>
800089fa:	0d 89       	ld.ub	r9,r6[0x0]
800089fc:	33 08       	mov	r8,48
800089fe:	f0 09 18 00 	cp.b	r9,r8
80008a02:	c0 b1       	brne	80008a18 <_vfprintf_r+0x9d4>
80008a04:	30 08       	mov	r8,0
80008a06:	30 09       	mov	r9,0
80008a08:	40 6b       	lddsp	r11,sp[0x18]
80008a0a:	40 7a       	lddsp	r10,sp[0x1c]
80008a0c:	e0 a0 1c d7 	rcall	8000c3ba <__avr32_f64_cmp_eq>
80008a10:	fb b2 00 01 	rsubeq	r2,1
80008a14:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008a18:	40 3b       	lddsp	r11,sp[0xc]
80008a1a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a1e:	10 0b       	add	r11,r8
80008a20:	50 3b       	stdsp	sp[0xc],r11
80008a22:	40 6b       	lddsp	r11,sp[0x18]
80008a24:	30 08       	mov	r8,0
80008a26:	30 09       	mov	r9,0
80008a28:	40 7a       	lddsp	r10,sp[0x1c]
80008a2a:	e0 a0 1c c8 	rcall	8000c3ba <__avr32_f64_cmp_eq>
80008a2e:	c0 90       	breq	80008a40 <_vfprintf_r+0x9fc>
80008a30:	40 3a       	lddsp	r10,sp[0xc]
80008a32:	fb 4a 06 a4 	st.w	sp[1700],r10
80008a36:	c0 58       	rjmp	80008a40 <_vfprintf_r+0x9fc>
80008a38:	10 c9       	st.b	r8++,r9
80008a3a:	fb 48 06 a4 	st.w	sp[1700],r8
80008a3e:	c0 28       	rjmp	80008a42 <_vfprintf_r+0x9fe>
80008a40:	33 09       	mov	r9,48
80008a42:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008a46:	40 3e       	lddsp	lr,sp[0xc]
80008a48:	1c 38       	cp.w	r8,lr
80008a4a:	cf 73       	brcs	80008a38 <_vfprintf_r+0x9f4>
80008a4c:	e0 40 00 47 	cp.w	r0,71
80008a50:	5f 09       	sreq	r9
80008a52:	e0 40 00 67 	cp.w	r0,103
80008a56:	5f 08       	sreq	r8
80008a58:	f3 e8 10 08 	or	r8,r9,r8
80008a5c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008a60:	0c 19       	sub	r9,r6
80008a62:	50 69       	stdsp	sp[0x18],r9
80008a64:	58 08       	cp.w	r8,0
80008a66:	c0 b0       	breq	80008a7c <_vfprintf_r+0xa38>
80008a68:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a6c:	5b d8       	cp.w	r8,-3
80008a6e:	c0 55       	brlt	80008a78 <_vfprintf_r+0xa34>
80008a70:	40 2c       	lddsp	r12,sp[0x8]
80008a72:	18 38       	cp.w	r8,r12
80008a74:	e0 8a 00 6a 	brle	80008b48 <_vfprintf_r+0xb04>
80008a78:	20 20       	sub	r0,2
80008a7a:	c0 58       	rjmp	80008a84 <_vfprintf_r+0xa40>
80008a7c:	e0 40 00 65 	cp.w	r0,101
80008a80:	e0 89 00 46 	brgt	80008b0c <_vfprintf_r+0xac8>
80008a84:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008a88:	fb 60 06 9c 	st.b	sp[1692],r0
80008a8c:	20 1b       	sub	r11,1
80008a8e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008a92:	c0 47       	brpl	80008a9a <_vfprintf_r+0xa56>
80008a94:	5c 3b       	neg	r11
80008a96:	32 d8       	mov	r8,45
80008a98:	c0 28       	rjmp	80008a9c <_vfprintf_r+0xa58>
80008a9a:	32 b8       	mov	r8,43
80008a9c:	fb 68 06 9d 	st.b	sp[1693],r8
80008aa0:	58 9b       	cp.w	r11,9
80008aa2:	e0 8a 00 1d 	brle	80008adc <_vfprintf_r+0xa98>
80008aa6:	fa c9 fa 35 	sub	r9,sp,-1483
80008aaa:	30 aa       	mov	r10,10
80008aac:	12 98       	mov	r8,r9
80008aae:	0e 9c       	mov	r12,r7
80008ab0:	0c 92       	mov	r2,r6
80008ab2:	f6 0a 0c 06 	divs	r6,r11,r10
80008ab6:	0e 9b       	mov	r11,r7
80008ab8:	2d 0b       	sub	r11,-48
80008aba:	10 fb       	st.b	--r8,r11
80008abc:	0c 9b       	mov	r11,r6
80008abe:	58 96       	cp.w	r6,9
80008ac0:	fe 99 ff f9 	brgt	80008ab2 <_vfprintf_r+0xa6e>
80008ac4:	2d 0b       	sub	r11,-48
80008ac6:	18 97       	mov	r7,r12
80008ac8:	04 96       	mov	r6,r2
80008aca:	10 fb       	st.b	--r8,r11
80008acc:	fa ca f9 62 	sub	r10,sp,-1694
80008ad0:	c0 38       	rjmp	80008ad6 <_vfprintf_r+0xa92>
80008ad2:	11 3b       	ld.ub	r11,r8++
80008ad4:	14 cb       	st.b	r10++,r11
80008ad6:	12 38       	cp.w	r8,r9
80008ad8:	cf d3       	brcs	80008ad2 <_vfprintf_r+0xa8e>
80008ada:	c0 98       	rjmp	80008aec <_vfprintf_r+0xaa8>
80008adc:	2d 0b       	sub	r11,-48
80008ade:	33 08       	mov	r8,48
80008ae0:	fb 6b 06 9f 	st.b	sp[1695],r11
80008ae4:	fb 68 06 9e 	st.b	sp[1694],r8
80008ae8:	fa ca f9 60 	sub	r10,sp,-1696
80008aec:	fa c8 f9 64 	sub	r8,sp,-1692
80008af0:	f4 08 01 08 	sub	r8,r10,r8
80008af4:	50 e8       	stdsp	sp[0x38],r8
80008af6:	10 92       	mov	r2,r8
80008af8:	40 6b       	lddsp	r11,sp[0x18]
80008afa:	16 02       	add	r2,r11
80008afc:	58 1b       	cp.w	r11,1
80008afe:	e0 89 00 05 	brgt	80008b08 <_vfprintf_r+0xac4>
80008b02:	ed b5 00 00 	bld	r5,0x0
80008b06:	c3 51       	brne	80008b70 <_vfprintf_r+0xb2c>
80008b08:	2f f2       	sub	r2,-1
80008b0a:	c3 38       	rjmp	80008b70 <_vfprintf_r+0xb2c>
80008b0c:	e0 40 00 66 	cp.w	r0,102
80008b10:	c1 c1       	brne	80008b48 <_vfprintf_r+0xb04>
80008b12:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b16:	58 02       	cp.w	r2,0
80008b18:	e0 8a 00 0c 	brle	80008b30 <_vfprintf_r+0xaec>
80008b1c:	40 2a       	lddsp	r10,sp[0x8]
80008b1e:	58 0a       	cp.w	r10,0
80008b20:	c0 41       	brne	80008b28 <_vfprintf_r+0xae4>
80008b22:	ed b5 00 00 	bld	r5,0x0
80008b26:	c2 51       	brne	80008b70 <_vfprintf_r+0xb2c>
80008b28:	2f f2       	sub	r2,-1
80008b2a:	40 29       	lddsp	r9,sp[0x8]
80008b2c:	12 02       	add	r2,r9
80008b2e:	c0 b8       	rjmp	80008b44 <_vfprintf_r+0xb00>
80008b30:	40 28       	lddsp	r8,sp[0x8]
80008b32:	58 08       	cp.w	r8,0
80008b34:	c0 61       	brne	80008b40 <_vfprintf_r+0xafc>
80008b36:	ed b5 00 00 	bld	r5,0x0
80008b3a:	c0 30       	breq	80008b40 <_vfprintf_r+0xafc>
80008b3c:	30 12       	mov	r2,1
80008b3e:	c1 98       	rjmp	80008b70 <_vfprintf_r+0xb2c>
80008b40:	40 22       	lddsp	r2,sp[0x8]
80008b42:	2f e2       	sub	r2,-2
80008b44:	36 60       	mov	r0,102
80008b46:	c1 58       	rjmp	80008b70 <_vfprintf_r+0xb2c>
80008b48:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b4c:	40 6e       	lddsp	lr,sp[0x18]
80008b4e:	1c 32       	cp.w	r2,lr
80008b50:	c0 65       	brlt	80008b5c <_vfprintf_r+0xb18>
80008b52:	ed b5 00 00 	bld	r5,0x0
80008b56:	f7 b2 00 ff 	subeq	r2,-1
80008b5a:	c0 a8       	rjmp	80008b6e <_vfprintf_r+0xb2a>
80008b5c:	e4 08 11 02 	rsub	r8,r2,2
80008b60:	40 6c       	lddsp	r12,sp[0x18]
80008b62:	58 02       	cp.w	r2,0
80008b64:	f0 02 17 a0 	movle	r2,r8
80008b68:	f9 b2 09 01 	movgt	r2,1
80008b6c:	18 02       	add	r2,r12
80008b6e:	36 70       	mov	r0,103
80008b70:	40 9b       	lddsp	r11,sp[0x24]
80008b72:	58 0b       	cp.w	r11,0
80008b74:	e0 80 05 94 	breq	8000969c <_vfprintf_r+0x1658>
80008b78:	32 d8       	mov	r8,45
80008b7a:	fb 68 06 bb 	st.b	sp[1723],r8
80008b7e:	e0 8f 05 93 	bral	800096a4 <_vfprintf_r+0x1660>
80008b82:	50 a7       	stdsp	sp[0x28],r7
80008b84:	04 94       	mov	r4,r2
80008b86:	0c 97       	mov	r7,r6
80008b88:	02 92       	mov	r2,r1
80008b8a:	06 96       	mov	r6,r3
80008b8c:	40 41       	lddsp	r1,sp[0x10]
80008b8e:	40 93       	lddsp	r3,sp[0x24]
80008b90:	0e 99       	mov	r9,r7
80008b92:	ed b5 00 05 	bld	r5,0x5
80008b96:	c4 81       	brne	80008c26 <_vfprintf_r+0xbe2>
80008b98:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b9c:	40 3e       	lddsp	lr,sp[0xc]
80008b9e:	58 0e       	cp.w	lr,0
80008ba0:	c1 d0       	breq	80008bda <_vfprintf_r+0xb96>
80008ba2:	10 36       	cp.w	r6,r8
80008ba4:	c0 64       	brge	80008bb0 <_vfprintf_r+0xb6c>
80008ba6:	fa cc f9 44 	sub	r12,sp,-1724
80008baa:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008bae:	c1 d8       	rjmp	80008be8 <_vfprintf_r+0xba4>
80008bb0:	fa c8 f9 50 	sub	r8,sp,-1712
80008bb4:	1a d8       	st.w	--sp,r8
80008bb6:	fa c8 fa b8 	sub	r8,sp,-1352
80008bba:	04 9a       	mov	r10,r2
80008bbc:	1a d8       	st.w	--sp,r8
80008bbe:	fa c8 fb b4 	sub	r8,sp,-1100
80008bc2:	0c 9b       	mov	r11,r6
80008bc4:	1a d8       	st.w	--sp,r8
80008bc6:	08 9c       	mov	r12,r4
80008bc8:	fa c8 f9 40 	sub	r8,sp,-1728
80008bcc:	fa c9 ff b4 	sub	r9,sp,-76
80008bd0:	fe b0 f8 a2 	rcall	80007d14 <get_arg>
80008bd4:	2f dd       	sub	sp,-12
80008bd6:	78 0a       	ld.w	r10,r12[0x0]
80008bd8:	c2 08       	rjmp	80008c18 <_vfprintf_r+0xbd4>
80008bda:	2f f7       	sub	r7,-1
80008bdc:	10 39       	cp.w	r9,r8
80008bde:	c0 84       	brge	80008bee <_vfprintf_r+0xbaa>
80008be0:	fa cb f9 44 	sub	r11,sp,-1724
80008be4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008be8:	ec fa fd 88 	ld.w	r10,r6[-632]
80008bec:	c1 68       	rjmp	80008c18 <_vfprintf_r+0xbd4>
80008bee:	41 09       	lddsp	r9,sp[0x40]
80008bf0:	59 f8       	cp.w	r8,31
80008bf2:	e0 89 00 10 	brgt	80008c12 <_vfprintf_r+0xbce>
80008bf6:	f2 ca ff fc 	sub	r10,r9,-4
80008bfa:	51 0a       	stdsp	sp[0x40],r10
80008bfc:	fa c6 f9 44 	sub	r6,sp,-1724
80008c00:	72 0a       	ld.w	r10,r9[0x0]
80008c02:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c06:	f3 4a fd 88 	st.w	r9[-632],r10
80008c0a:	2f f8       	sub	r8,-1
80008c0c:	fb 48 06 b4 	st.w	sp[1716],r8
80008c10:	c0 48       	rjmp	80008c18 <_vfprintf_r+0xbd4>
80008c12:	72 0a       	ld.w	r10,r9[0x0]
80008c14:	2f c9       	sub	r9,-4
80008c16:	51 09       	stdsp	sp[0x40],r9
80008c18:	40 be       	lddsp	lr,sp[0x2c]
80008c1a:	1c 98       	mov	r8,lr
80008c1c:	95 1e       	st.w	r10[0x4],lr
80008c1e:	bf 58       	asr	r8,0x1f
80008c20:	95 08       	st.w	r10[0x0],r8
80008c22:	fe 9f fa 9f 	bral	80008160 <_vfprintf_r+0x11c>
80008c26:	ed b5 00 04 	bld	r5,0x4
80008c2a:	c4 80       	breq	80008cba <_vfprintf_r+0xc76>
80008c2c:	e2 15 00 40 	andl	r5,0x40,COH
80008c30:	c4 50       	breq	80008cba <_vfprintf_r+0xc76>
80008c32:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c36:	40 3c       	lddsp	r12,sp[0xc]
80008c38:	58 0c       	cp.w	r12,0
80008c3a:	c1 d0       	breq	80008c74 <_vfprintf_r+0xc30>
80008c3c:	10 36       	cp.w	r6,r8
80008c3e:	c0 64       	brge	80008c4a <_vfprintf_r+0xc06>
80008c40:	fa cb f9 44 	sub	r11,sp,-1724
80008c44:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c48:	c1 d8       	rjmp	80008c82 <_vfprintf_r+0xc3e>
80008c4a:	fa c8 f9 50 	sub	r8,sp,-1712
80008c4e:	1a d8       	st.w	--sp,r8
80008c50:	fa c8 fa b8 	sub	r8,sp,-1352
80008c54:	04 9a       	mov	r10,r2
80008c56:	1a d8       	st.w	--sp,r8
80008c58:	fa c8 fb b4 	sub	r8,sp,-1100
80008c5c:	0c 9b       	mov	r11,r6
80008c5e:	1a d8       	st.w	--sp,r8
80008c60:	08 9c       	mov	r12,r4
80008c62:	fa c8 f9 40 	sub	r8,sp,-1728
80008c66:	fa c9 ff b4 	sub	r9,sp,-76
80008c6a:	fe b0 f8 55 	rcall	80007d14 <get_arg>
80008c6e:	2f dd       	sub	sp,-12
80008c70:	78 0a       	ld.w	r10,r12[0x0]
80008c72:	c2 08       	rjmp	80008cb2 <_vfprintf_r+0xc6e>
80008c74:	2f f7       	sub	r7,-1
80008c76:	10 39       	cp.w	r9,r8
80008c78:	c0 84       	brge	80008c88 <_vfprintf_r+0xc44>
80008c7a:	fa ca f9 44 	sub	r10,sp,-1724
80008c7e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c82:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c86:	c1 68       	rjmp	80008cb2 <_vfprintf_r+0xc6e>
80008c88:	41 09       	lddsp	r9,sp[0x40]
80008c8a:	59 f8       	cp.w	r8,31
80008c8c:	e0 89 00 10 	brgt	80008cac <_vfprintf_r+0xc68>
80008c90:	f2 ca ff fc 	sub	r10,r9,-4
80008c94:	51 0a       	stdsp	sp[0x40],r10
80008c96:	fa c6 f9 44 	sub	r6,sp,-1724
80008c9a:	72 0a       	ld.w	r10,r9[0x0]
80008c9c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ca0:	f3 4a fd 88 	st.w	r9[-632],r10
80008ca4:	2f f8       	sub	r8,-1
80008ca6:	fb 48 06 b4 	st.w	sp[1716],r8
80008caa:	c0 48       	rjmp	80008cb2 <_vfprintf_r+0xc6e>
80008cac:	72 0a       	ld.w	r10,r9[0x0]
80008cae:	2f c9       	sub	r9,-4
80008cb0:	51 09       	stdsp	sp[0x40],r9
80008cb2:	40 be       	lddsp	lr,sp[0x2c]
80008cb4:	b4 0e       	st.h	r10[0x0],lr
80008cb6:	fe 9f fa 55 	bral	80008160 <_vfprintf_r+0x11c>
80008cba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cbe:	40 3c       	lddsp	r12,sp[0xc]
80008cc0:	58 0c       	cp.w	r12,0
80008cc2:	c1 d0       	breq	80008cfc <_vfprintf_r+0xcb8>
80008cc4:	10 36       	cp.w	r6,r8
80008cc6:	c0 64       	brge	80008cd2 <_vfprintf_r+0xc8e>
80008cc8:	fa cb f9 44 	sub	r11,sp,-1724
80008ccc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cd0:	c1 d8       	rjmp	80008d0a <_vfprintf_r+0xcc6>
80008cd2:	fa c8 f9 50 	sub	r8,sp,-1712
80008cd6:	1a d8       	st.w	--sp,r8
80008cd8:	fa c8 fa b8 	sub	r8,sp,-1352
80008cdc:	04 9a       	mov	r10,r2
80008cde:	1a d8       	st.w	--sp,r8
80008ce0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ce4:	0c 9b       	mov	r11,r6
80008ce6:	1a d8       	st.w	--sp,r8
80008ce8:	08 9c       	mov	r12,r4
80008cea:	fa c8 f9 40 	sub	r8,sp,-1728
80008cee:	fa c9 ff b4 	sub	r9,sp,-76
80008cf2:	fe b0 f8 11 	rcall	80007d14 <get_arg>
80008cf6:	2f dd       	sub	sp,-12
80008cf8:	78 0a       	ld.w	r10,r12[0x0]
80008cfa:	c2 08       	rjmp	80008d3a <_vfprintf_r+0xcf6>
80008cfc:	2f f7       	sub	r7,-1
80008cfe:	10 39       	cp.w	r9,r8
80008d00:	c0 84       	brge	80008d10 <_vfprintf_r+0xccc>
80008d02:	fa ca f9 44 	sub	r10,sp,-1724
80008d06:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d0a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d0e:	c1 68       	rjmp	80008d3a <_vfprintf_r+0xcf6>
80008d10:	41 09       	lddsp	r9,sp[0x40]
80008d12:	59 f8       	cp.w	r8,31
80008d14:	e0 89 00 10 	brgt	80008d34 <_vfprintf_r+0xcf0>
80008d18:	f2 ca ff fc 	sub	r10,r9,-4
80008d1c:	51 0a       	stdsp	sp[0x40],r10
80008d1e:	fa c6 f9 44 	sub	r6,sp,-1724
80008d22:	72 0a       	ld.w	r10,r9[0x0]
80008d24:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d28:	f3 4a fd 88 	st.w	r9[-632],r10
80008d2c:	2f f8       	sub	r8,-1
80008d2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d32:	c0 48       	rjmp	80008d3a <_vfprintf_r+0xcf6>
80008d34:	72 0a       	ld.w	r10,r9[0x0]
80008d36:	2f c9       	sub	r9,-4
80008d38:	51 09       	stdsp	sp[0x40],r9
80008d3a:	40 be       	lddsp	lr,sp[0x2c]
80008d3c:	95 0e       	st.w	r10[0x0],lr
80008d3e:	fe 9f fa 11 	bral	80008160 <_vfprintf_r+0x11c>
80008d42:	50 a7       	stdsp	sp[0x28],r7
80008d44:	50 80       	stdsp	sp[0x20],r0
80008d46:	0c 97       	mov	r7,r6
80008d48:	04 94       	mov	r4,r2
80008d4a:	06 96       	mov	r6,r3
80008d4c:	02 92       	mov	r2,r1
80008d4e:	40 93       	lddsp	r3,sp[0x24]
80008d50:	10 90       	mov	r0,r8
80008d52:	40 41       	lddsp	r1,sp[0x10]
80008d54:	a5 a5       	sbr	r5,0x4
80008d56:	c0 a8       	rjmp	80008d6a <_vfprintf_r+0xd26>
80008d58:	50 a7       	stdsp	sp[0x28],r7
80008d5a:	50 80       	stdsp	sp[0x20],r0
80008d5c:	0c 97       	mov	r7,r6
80008d5e:	04 94       	mov	r4,r2
80008d60:	06 96       	mov	r6,r3
80008d62:	02 92       	mov	r2,r1
80008d64:	40 93       	lddsp	r3,sp[0x24]
80008d66:	10 90       	mov	r0,r8
80008d68:	40 41       	lddsp	r1,sp[0x10]
80008d6a:	ed b5 00 05 	bld	r5,0x5
80008d6e:	c5 d1       	brne	80008e28 <_vfprintf_r+0xde4>
80008d70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d74:	40 3c       	lddsp	r12,sp[0xc]
80008d76:	58 0c       	cp.w	r12,0
80008d78:	c2 60       	breq	80008dc4 <_vfprintf_r+0xd80>
80008d7a:	10 36       	cp.w	r6,r8
80008d7c:	c0 a4       	brge	80008d90 <_vfprintf_r+0xd4c>
80008d7e:	fa cb f9 44 	sub	r11,sp,-1724
80008d82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d86:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008d8a:	fa e9 00 00 	st.d	sp[0],r8
80008d8e:	c1 88       	rjmp	80008dbe <_vfprintf_r+0xd7a>
80008d90:	fa c8 f9 50 	sub	r8,sp,-1712
80008d94:	1a d8       	st.w	--sp,r8
80008d96:	fa c8 fa b8 	sub	r8,sp,-1352
80008d9a:	04 9a       	mov	r10,r2
80008d9c:	1a d8       	st.w	--sp,r8
80008d9e:	0c 9b       	mov	r11,r6
80008da0:	fa c8 fb b4 	sub	r8,sp,-1100
80008da4:	08 9c       	mov	r12,r4
80008da6:	1a d8       	st.w	--sp,r8
80008da8:	fa c8 f9 40 	sub	r8,sp,-1728
80008dac:	fa c9 ff b4 	sub	r9,sp,-76
80008db0:	fe b0 f7 b2 	rcall	80007d14 <get_arg>
80008db4:	2f dd       	sub	sp,-12
80008db6:	f8 ea 00 00 	ld.d	r10,r12[0]
80008dba:	fa eb 00 00 	st.d	sp[0],r10
80008dbe:	30 08       	mov	r8,0
80008dc0:	e0 8f 03 de 	bral	8000957c <_vfprintf_r+0x1538>
80008dc4:	ee ca ff ff 	sub	r10,r7,-1
80008dc8:	10 37       	cp.w	r7,r8
80008dca:	c0 b4       	brge	80008de0 <_vfprintf_r+0xd9c>
80008dcc:	fa c9 f9 44 	sub	r9,sp,-1724
80008dd0:	14 97       	mov	r7,r10
80008dd2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dd6:	ec ea fd 88 	ld.d	r10,r6[-632]
80008dda:	fa eb 00 00 	st.d	sp[0],r10
80008dde:	c1 88       	rjmp	80008e0e <_vfprintf_r+0xdca>
80008de0:	41 09       	lddsp	r9,sp[0x40]
80008de2:	59 f8       	cp.w	r8,31
80008de4:	e0 89 00 18 	brgt	80008e14 <_vfprintf_r+0xdd0>
80008de8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008dec:	f2 cb ff f8 	sub	r11,r9,-8
80008df0:	fa e7 00 00 	st.d	sp[0],r6
80008df4:	51 0b       	stdsp	sp[0x40],r11
80008df6:	fa c6 f9 44 	sub	r6,sp,-1724
80008dfa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dfe:	fa e6 00 00 	ld.d	r6,sp[0]
80008e02:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e06:	2f f8       	sub	r8,-1
80008e08:	14 97       	mov	r7,r10
80008e0a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e0e:	40 38       	lddsp	r8,sp[0xc]
80008e10:	e0 8f 03 b6 	bral	8000957c <_vfprintf_r+0x1538>
80008e14:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e18:	40 38       	lddsp	r8,sp[0xc]
80008e1a:	fa e7 00 00 	st.d	sp[0],r6
80008e1e:	2f 89       	sub	r9,-8
80008e20:	14 97       	mov	r7,r10
80008e22:	51 09       	stdsp	sp[0x40],r9
80008e24:	e0 8f 03 ac 	bral	8000957c <_vfprintf_r+0x1538>
80008e28:	ed b5 00 04 	bld	r5,0x4
80008e2c:	c1 61       	brne	80008e58 <_vfprintf_r+0xe14>
80008e2e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e32:	40 3e       	lddsp	lr,sp[0xc]
80008e34:	58 0e       	cp.w	lr,0
80008e36:	c0 80       	breq	80008e46 <_vfprintf_r+0xe02>
80008e38:	10 36       	cp.w	r6,r8
80008e3a:	c6 74       	brge	80008f08 <_vfprintf_r+0xec4>
80008e3c:	fa cc f9 44 	sub	r12,sp,-1724
80008e40:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008e44:	c8 08       	rjmp	80008f44 <_vfprintf_r+0xf00>
80008e46:	ee ca ff ff 	sub	r10,r7,-1
80008e4a:	10 37       	cp.w	r7,r8
80008e4c:	c7 f4       	brge	80008f4a <_vfprintf_r+0xf06>
80008e4e:	fa cb f9 44 	sub	r11,sp,-1724
80008e52:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e56:	c7 68       	rjmp	80008f42 <_vfprintf_r+0xefe>
80008e58:	ed b5 00 06 	bld	r5,0x6
80008e5c:	c4 a1       	brne	80008ef0 <_vfprintf_r+0xeac>
80008e5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e62:	40 3c       	lddsp	r12,sp[0xc]
80008e64:	58 0c       	cp.w	r12,0
80008e66:	c1 d0       	breq	80008ea0 <_vfprintf_r+0xe5c>
80008e68:	10 36       	cp.w	r6,r8
80008e6a:	c0 64       	brge	80008e76 <_vfprintf_r+0xe32>
80008e6c:	fa cb f9 44 	sub	r11,sp,-1724
80008e70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e74:	c1 f8       	rjmp	80008eb2 <_vfprintf_r+0xe6e>
80008e76:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7a:	1a d8       	st.w	--sp,r8
80008e7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008e80:	1a d8       	st.w	--sp,r8
80008e82:	fa c8 fb b4 	sub	r8,sp,-1100
80008e86:	1a d8       	st.w	--sp,r8
80008e88:	fa c8 f9 40 	sub	r8,sp,-1728
80008e8c:	fa c9 ff b4 	sub	r9,sp,-76
80008e90:	04 9a       	mov	r10,r2
80008e92:	0c 9b       	mov	r11,r6
80008e94:	08 9c       	mov	r12,r4
80008e96:	fe b0 f7 3f 	rcall	80007d14 <get_arg>
80008e9a:	2f dd       	sub	sp,-12
80008e9c:	98 18       	ld.sh	r8,r12[0x2]
80008e9e:	c2 68       	rjmp	80008eea <_vfprintf_r+0xea6>
80008ea0:	ee ca ff ff 	sub	r10,r7,-1
80008ea4:	10 37       	cp.w	r7,r8
80008ea6:	c0 94       	brge	80008eb8 <_vfprintf_r+0xe74>
80008ea8:	fa c9 f9 44 	sub	r9,sp,-1724
80008eac:	14 97       	mov	r7,r10
80008eae:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eb2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008eb6:	c1 a8       	rjmp	80008eea <_vfprintf_r+0xea6>
80008eb8:	41 09       	lddsp	r9,sp[0x40]
80008eba:	59 f8       	cp.w	r8,31
80008ebc:	e0 89 00 13 	brgt	80008ee2 <_vfprintf_r+0xe9e>
80008ec0:	f2 cb ff fc 	sub	r11,r9,-4
80008ec4:	51 0b       	stdsp	sp[0x40],r11
80008ec6:	72 09       	ld.w	r9,r9[0x0]
80008ec8:	fa c6 f9 44 	sub	r6,sp,-1724
80008ecc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008ed0:	2f f8       	sub	r8,-1
80008ed2:	f7 49 fd 88 	st.w	r11[-632],r9
80008ed6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eda:	14 97       	mov	r7,r10
80008edc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008ee0:	c0 58       	rjmp	80008eea <_vfprintf_r+0xea6>
80008ee2:	92 18       	ld.sh	r8,r9[0x2]
80008ee4:	14 97       	mov	r7,r10
80008ee6:	2f c9       	sub	r9,-4
80008ee8:	51 09       	stdsp	sp[0x40],r9
80008eea:	5c 78       	castu.h	r8
80008eec:	50 18       	stdsp	sp[0x4],r8
80008eee:	c4 68       	rjmp	80008f7a <_vfprintf_r+0xf36>
80008ef0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ef4:	40 3c       	lddsp	r12,sp[0xc]
80008ef6:	58 0c       	cp.w	r12,0
80008ef8:	c1 d0       	breq	80008f32 <_vfprintf_r+0xeee>
80008efa:	10 36       	cp.w	r6,r8
80008efc:	c0 64       	brge	80008f08 <_vfprintf_r+0xec4>
80008efe:	fa cb f9 44 	sub	r11,sp,-1724
80008f02:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f06:	c1 f8       	rjmp	80008f44 <_vfprintf_r+0xf00>
80008f08:	fa c8 f9 50 	sub	r8,sp,-1712
80008f0c:	1a d8       	st.w	--sp,r8
80008f0e:	fa c8 fa b8 	sub	r8,sp,-1352
80008f12:	0c 9b       	mov	r11,r6
80008f14:	1a d8       	st.w	--sp,r8
80008f16:	fa c8 fb b4 	sub	r8,sp,-1100
80008f1a:	04 9a       	mov	r10,r2
80008f1c:	1a d8       	st.w	--sp,r8
80008f1e:	08 9c       	mov	r12,r4
80008f20:	fa c8 f9 40 	sub	r8,sp,-1728
80008f24:	fa c9 ff b4 	sub	r9,sp,-76
80008f28:	fe b0 f6 f6 	rcall	80007d14 <get_arg>
80008f2c:	2f dd       	sub	sp,-12
80008f2e:	78 0b       	ld.w	r11,r12[0x0]
80008f30:	c2 48       	rjmp	80008f78 <_vfprintf_r+0xf34>
80008f32:	ee ca ff ff 	sub	r10,r7,-1
80008f36:	10 37       	cp.w	r7,r8
80008f38:	c0 94       	brge	80008f4a <_vfprintf_r+0xf06>
80008f3a:	fa c9 f9 44 	sub	r9,sp,-1724
80008f3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f42:	14 97       	mov	r7,r10
80008f44:	ec fb fd 88 	ld.w	r11,r6[-632]
80008f48:	c1 88       	rjmp	80008f78 <_vfprintf_r+0xf34>
80008f4a:	41 09       	lddsp	r9,sp[0x40]
80008f4c:	59 f8       	cp.w	r8,31
80008f4e:	e0 89 00 11 	brgt	80008f70 <_vfprintf_r+0xf2c>
80008f52:	f2 cb ff fc 	sub	r11,r9,-4
80008f56:	51 0b       	stdsp	sp[0x40],r11
80008f58:	fa c6 f9 44 	sub	r6,sp,-1724
80008f5c:	72 0b       	ld.w	r11,r9[0x0]
80008f5e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f62:	f3 4b fd 88 	st.w	r9[-632],r11
80008f66:	2f f8       	sub	r8,-1
80008f68:	14 97       	mov	r7,r10
80008f6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f6e:	c0 58       	rjmp	80008f78 <_vfprintf_r+0xf34>
80008f70:	72 0b       	ld.w	r11,r9[0x0]
80008f72:	14 97       	mov	r7,r10
80008f74:	2f c9       	sub	r9,-4
80008f76:	51 09       	stdsp	sp[0x40],r9
80008f78:	50 1b       	stdsp	sp[0x4],r11
80008f7a:	30 0e       	mov	lr,0
80008f7c:	50 0e       	stdsp	sp[0x0],lr
80008f7e:	1c 98       	mov	r8,lr
80008f80:	e0 8f 02 fe 	bral	8000957c <_vfprintf_r+0x1538>
80008f84:	50 a7       	stdsp	sp[0x28],r7
80008f86:	50 80       	stdsp	sp[0x20],r0
80008f88:	0c 97       	mov	r7,r6
80008f8a:	04 94       	mov	r4,r2
80008f8c:	06 96       	mov	r6,r3
80008f8e:	02 92       	mov	r2,r1
80008f90:	40 93       	lddsp	r3,sp[0x24]
80008f92:	40 41       	lddsp	r1,sp[0x10]
80008f94:	0e 99       	mov	r9,r7
80008f96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f9a:	40 3c       	lddsp	r12,sp[0xc]
80008f9c:	58 0c       	cp.w	r12,0
80008f9e:	c1 d0       	breq	80008fd8 <_vfprintf_r+0xf94>
80008fa0:	10 36       	cp.w	r6,r8
80008fa2:	c0 64       	brge	80008fae <_vfprintf_r+0xf6a>
80008fa4:	fa cb f9 44 	sub	r11,sp,-1724
80008fa8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fac:	c1 d8       	rjmp	80008fe6 <_vfprintf_r+0xfa2>
80008fae:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb2:	1a d8       	st.w	--sp,r8
80008fb4:	fa c8 fa b8 	sub	r8,sp,-1352
80008fb8:	1a d8       	st.w	--sp,r8
80008fba:	fa c8 fb b4 	sub	r8,sp,-1100
80008fbe:	1a d8       	st.w	--sp,r8
80008fc0:	fa c9 ff b4 	sub	r9,sp,-76
80008fc4:	fa c8 f9 40 	sub	r8,sp,-1728
80008fc8:	04 9a       	mov	r10,r2
80008fca:	0c 9b       	mov	r11,r6
80008fcc:	08 9c       	mov	r12,r4
80008fce:	fe b0 f6 a3 	rcall	80007d14 <get_arg>
80008fd2:	2f dd       	sub	sp,-12
80008fd4:	78 09       	ld.w	r9,r12[0x0]
80008fd6:	c2 18       	rjmp	80009018 <_vfprintf_r+0xfd4>
80008fd8:	2f f7       	sub	r7,-1
80008fda:	10 39       	cp.w	r9,r8
80008fdc:	c0 84       	brge	80008fec <_vfprintf_r+0xfa8>
80008fde:	fa ca f9 44 	sub	r10,sp,-1724
80008fe2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008fe6:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008fea:	c1 78       	rjmp	80009018 <_vfprintf_r+0xfd4>
80008fec:	41 09       	lddsp	r9,sp[0x40]
80008fee:	59 f8       	cp.w	r8,31
80008ff0:	e0 89 00 10 	brgt	80009010 <_vfprintf_r+0xfcc>
80008ff4:	f2 ca ff fc 	sub	r10,r9,-4
80008ff8:	51 0a       	stdsp	sp[0x40],r10
80008ffa:	fa c6 f9 44 	sub	r6,sp,-1724
80008ffe:	72 09       	ld.w	r9,r9[0x0]
80009000:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009004:	f5 49 fd 88 	st.w	r10[-632],r9
80009008:	2f f8       	sub	r8,-1
8000900a:	fb 48 06 b4 	st.w	sp[1716],r8
8000900e:	c0 58       	rjmp	80009018 <_vfprintf_r+0xfd4>
80009010:	f2 c8 ff fc 	sub	r8,r9,-4
80009014:	51 08       	stdsp	sp[0x40],r8
80009016:	72 09       	ld.w	r9,r9[0x0]
80009018:	33 08       	mov	r8,48
8000901a:	fb 68 06 b8 	st.b	sp[1720],r8
8000901e:	37 88       	mov	r8,120
80009020:	30 0e       	mov	lr,0
80009022:	fb 68 06 b9 	st.b	sp[1721],r8
80009026:	fe cc b0 3a 	sub	r12,pc,-20422
8000902a:	50 19       	stdsp	sp[0x4],r9
8000902c:	a1 b5       	sbr	r5,0x1
8000902e:	50 0e       	stdsp	sp[0x0],lr
80009030:	50 dc       	stdsp	sp[0x34],r12
80009032:	30 28       	mov	r8,2
80009034:	37 80       	mov	r0,120
80009036:	e0 8f 02 a3 	bral	8000957c <_vfprintf_r+0x1538>
8000903a:	50 a7       	stdsp	sp[0x28],r7
8000903c:	50 80       	stdsp	sp[0x20],r0
8000903e:	10 90       	mov	r0,r8
80009040:	30 08       	mov	r8,0
80009042:	fb 68 06 bb 	st.b	sp[1723],r8
80009046:	0c 97       	mov	r7,r6
80009048:	04 94       	mov	r4,r2
8000904a:	06 96       	mov	r6,r3
8000904c:	02 92       	mov	r2,r1
8000904e:	40 93       	lddsp	r3,sp[0x24]
80009050:	40 41       	lddsp	r1,sp[0x10]
80009052:	0e 99       	mov	r9,r7
80009054:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009058:	40 3b       	lddsp	r11,sp[0xc]
8000905a:	58 0b       	cp.w	r11,0
8000905c:	c1 d0       	breq	80009096 <_vfprintf_r+0x1052>
8000905e:	10 36       	cp.w	r6,r8
80009060:	c0 64       	brge	8000906c <_vfprintf_r+0x1028>
80009062:	fa ca f9 44 	sub	r10,sp,-1724
80009066:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000906a:	c1 d8       	rjmp	800090a4 <_vfprintf_r+0x1060>
8000906c:	fa c8 f9 50 	sub	r8,sp,-1712
80009070:	1a d8       	st.w	--sp,r8
80009072:	fa c8 fa b8 	sub	r8,sp,-1352
80009076:	1a d8       	st.w	--sp,r8
80009078:	fa c8 fb b4 	sub	r8,sp,-1100
8000907c:	0c 9b       	mov	r11,r6
8000907e:	1a d8       	st.w	--sp,r8
80009080:	04 9a       	mov	r10,r2
80009082:	fa c8 f9 40 	sub	r8,sp,-1728
80009086:	fa c9 ff b4 	sub	r9,sp,-76
8000908a:	08 9c       	mov	r12,r4
8000908c:	fe b0 f6 44 	rcall	80007d14 <get_arg>
80009090:	2f dd       	sub	sp,-12
80009092:	78 06       	ld.w	r6,r12[0x0]
80009094:	c2 08       	rjmp	800090d4 <_vfprintf_r+0x1090>
80009096:	2f f7       	sub	r7,-1
80009098:	10 39       	cp.w	r9,r8
8000909a:	c0 84       	brge	800090aa <_vfprintf_r+0x1066>
8000909c:	fa c9 f9 44 	sub	r9,sp,-1724
800090a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090a4:	ec f6 fd 88 	ld.w	r6,r6[-632]
800090a8:	c1 68       	rjmp	800090d4 <_vfprintf_r+0x1090>
800090aa:	41 09       	lddsp	r9,sp[0x40]
800090ac:	59 f8       	cp.w	r8,31
800090ae:	e0 89 00 10 	brgt	800090ce <_vfprintf_r+0x108a>
800090b2:	f2 ca ff fc 	sub	r10,r9,-4
800090b6:	51 0a       	stdsp	sp[0x40],r10
800090b8:	72 06       	ld.w	r6,r9[0x0]
800090ba:	fa ce f9 44 	sub	lr,sp,-1724
800090be:	fc 08 00 39 	add	r9,lr,r8<<0x3
800090c2:	f3 46 fd 88 	st.w	r9[-632],r6
800090c6:	2f f8       	sub	r8,-1
800090c8:	fb 48 06 b4 	st.w	sp[1716],r8
800090cc:	c0 48       	rjmp	800090d4 <_vfprintf_r+0x1090>
800090ce:	72 06       	ld.w	r6,r9[0x0]
800090d0:	2f c9       	sub	r9,-4
800090d2:	51 09       	stdsp	sp[0x40],r9
800090d4:	40 2c       	lddsp	r12,sp[0x8]
800090d6:	58 0c       	cp.w	r12,0
800090d8:	c1 05       	brlt	800090f8 <_vfprintf_r+0x10b4>
800090da:	18 9a       	mov	r10,r12
800090dc:	30 0b       	mov	r11,0
800090de:	0c 9c       	mov	r12,r6
800090e0:	e0 a0 12 38 	rcall	8000b550 <memchr>
800090e4:	e0 80 02 df 	breq	800096a2 <_vfprintf_r+0x165e>
800090e8:	f8 06 01 02 	sub	r2,r12,r6
800090ec:	40 2b       	lddsp	r11,sp[0x8]
800090ee:	16 32       	cp.w	r2,r11
800090f0:	e0 89 02 d9 	brgt	800096a2 <_vfprintf_r+0x165e>
800090f4:	e0 8f 02 d4 	bral	8000969c <_vfprintf_r+0x1658>
800090f8:	30 0a       	mov	r10,0
800090fa:	0c 9c       	mov	r12,r6
800090fc:	50 2a       	stdsp	sp[0x8],r10
800090fe:	e0 a0 15 99 	rcall	8000bc30 <strlen>
80009102:	18 92       	mov	r2,r12
80009104:	e0 8f 02 d2 	bral	800096a8 <_vfprintf_r+0x1664>
80009108:	50 a7       	stdsp	sp[0x28],r7
8000910a:	50 80       	stdsp	sp[0x20],r0
8000910c:	0c 97       	mov	r7,r6
8000910e:	04 94       	mov	r4,r2
80009110:	06 96       	mov	r6,r3
80009112:	02 92       	mov	r2,r1
80009114:	40 93       	lddsp	r3,sp[0x24]
80009116:	10 90       	mov	r0,r8
80009118:	40 41       	lddsp	r1,sp[0x10]
8000911a:	a5 a5       	sbr	r5,0x4
8000911c:	c0 a8       	rjmp	80009130 <_vfprintf_r+0x10ec>
8000911e:	50 a7       	stdsp	sp[0x28],r7
80009120:	50 80       	stdsp	sp[0x20],r0
80009122:	0c 97       	mov	r7,r6
80009124:	04 94       	mov	r4,r2
80009126:	06 96       	mov	r6,r3
80009128:	02 92       	mov	r2,r1
8000912a:	40 93       	lddsp	r3,sp[0x24]
8000912c:	10 90       	mov	r0,r8
8000912e:	40 41       	lddsp	r1,sp[0x10]
80009130:	ed b5 00 05 	bld	r5,0x5
80009134:	c5 61       	brne	800091e0 <_vfprintf_r+0x119c>
80009136:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000913a:	40 39       	lddsp	r9,sp[0xc]
8000913c:	58 09       	cp.w	r9,0
8000913e:	c2 10       	breq	80009180 <_vfprintf_r+0x113c>
80009140:	10 36       	cp.w	r6,r8
80009142:	c0 74       	brge	80009150 <_vfprintf_r+0x110c>
80009144:	fa c8 f9 44 	sub	r8,sp,-1724
80009148:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000914c:	c2 38       	rjmp	80009192 <_vfprintf_r+0x114e>
8000914e:	d7 03       	nop
80009150:	fa c8 f9 50 	sub	r8,sp,-1712
80009154:	1a d8       	st.w	--sp,r8
80009156:	fa c8 fa b8 	sub	r8,sp,-1352
8000915a:	1a d8       	st.w	--sp,r8
8000915c:	fa c8 fb b4 	sub	r8,sp,-1100
80009160:	1a d8       	st.w	--sp,r8
80009162:	fa c8 f9 40 	sub	r8,sp,-1728
80009166:	fa c9 ff b4 	sub	r9,sp,-76
8000916a:	04 9a       	mov	r10,r2
8000916c:	0c 9b       	mov	r11,r6
8000916e:	08 9c       	mov	r12,r4
80009170:	fe b0 f5 d2 	rcall	80007d14 <get_arg>
80009174:	2f dd       	sub	sp,-12
80009176:	f8 e8 00 00 	ld.d	r8,r12[0]
8000917a:	fa e9 00 00 	st.d	sp[0],r8
8000917e:	c2 e8       	rjmp	800091da <_vfprintf_r+0x1196>
80009180:	ee ca ff ff 	sub	r10,r7,-1
80009184:	10 37       	cp.w	r7,r8
80009186:	c0 b4       	brge	8000919c <_vfprintf_r+0x1158>
80009188:	fa c8 f9 44 	sub	r8,sp,-1724
8000918c:	14 97       	mov	r7,r10
8000918e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009192:	ec ea fd 88 	ld.d	r10,r6[-632]
80009196:	fa eb 00 00 	st.d	sp[0],r10
8000919a:	c2 08       	rjmp	800091da <_vfprintf_r+0x1196>
8000919c:	41 09       	lddsp	r9,sp[0x40]
8000919e:	59 f8       	cp.w	r8,31
800091a0:	e0 89 00 16 	brgt	800091cc <_vfprintf_r+0x1188>
800091a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800091a8:	f2 cb ff f8 	sub	r11,r9,-8
800091ac:	fa e7 00 00 	st.d	sp[0],r6
800091b0:	51 0b       	stdsp	sp[0x40],r11
800091b2:	fa c6 f9 44 	sub	r6,sp,-1724
800091b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091ba:	fa e6 00 00 	ld.d	r6,sp[0]
800091be:	f2 e7 fd 88 	st.d	r9[-632],r6
800091c2:	2f f8       	sub	r8,-1
800091c4:	14 97       	mov	r7,r10
800091c6:	fb 48 06 b4 	st.w	sp[1716],r8
800091ca:	c0 88       	rjmp	800091da <_vfprintf_r+0x1196>
800091cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800091d0:	2f 89       	sub	r9,-8
800091d2:	fa e7 00 00 	st.d	sp[0],r6
800091d6:	51 09       	stdsp	sp[0x40],r9
800091d8:	14 97       	mov	r7,r10
800091da:	30 18       	mov	r8,1
800091dc:	e0 8f 01 d0 	bral	8000957c <_vfprintf_r+0x1538>
800091e0:	ed b5 00 04 	bld	r5,0x4
800091e4:	c1 61       	brne	80009210 <_vfprintf_r+0x11cc>
800091e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091ea:	40 3e       	lddsp	lr,sp[0xc]
800091ec:	58 0e       	cp.w	lr,0
800091ee:	c0 80       	breq	800091fe <_vfprintf_r+0x11ba>
800091f0:	10 36       	cp.w	r6,r8
800091f2:	c6 74       	brge	800092c0 <_vfprintf_r+0x127c>
800091f4:	fa cc f9 44 	sub	r12,sp,-1724
800091f8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800091fc:	c8 08       	rjmp	800092fc <_vfprintf_r+0x12b8>
800091fe:	ee ca ff ff 	sub	r10,r7,-1
80009202:	10 37       	cp.w	r7,r8
80009204:	c7 f4       	brge	80009302 <_vfprintf_r+0x12be>
80009206:	fa cb f9 44 	sub	r11,sp,-1724
8000920a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000920e:	c7 68       	rjmp	800092fa <_vfprintf_r+0x12b6>
80009210:	ed b5 00 06 	bld	r5,0x6
80009214:	c4 a1       	brne	800092a8 <_vfprintf_r+0x1264>
80009216:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000921a:	40 3c       	lddsp	r12,sp[0xc]
8000921c:	58 0c       	cp.w	r12,0
8000921e:	c1 d0       	breq	80009258 <_vfprintf_r+0x1214>
80009220:	10 36       	cp.w	r6,r8
80009222:	c0 64       	brge	8000922e <_vfprintf_r+0x11ea>
80009224:	fa cb f9 44 	sub	r11,sp,-1724
80009228:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000922c:	c1 f8       	rjmp	8000926a <_vfprintf_r+0x1226>
8000922e:	fa c8 f9 50 	sub	r8,sp,-1712
80009232:	1a d8       	st.w	--sp,r8
80009234:	fa c8 fa b8 	sub	r8,sp,-1352
80009238:	1a d8       	st.w	--sp,r8
8000923a:	fa c8 fb b4 	sub	r8,sp,-1100
8000923e:	1a d8       	st.w	--sp,r8
80009240:	fa c8 f9 40 	sub	r8,sp,-1728
80009244:	fa c9 ff b4 	sub	r9,sp,-76
80009248:	04 9a       	mov	r10,r2
8000924a:	0c 9b       	mov	r11,r6
8000924c:	08 9c       	mov	r12,r4
8000924e:	fe b0 f5 63 	rcall	80007d14 <get_arg>
80009252:	2f dd       	sub	sp,-12
80009254:	98 18       	ld.sh	r8,r12[0x2]
80009256:	c2 68       	rjmp	800092a2 <_vfprintf_r+0x125e>
80009258:	ee ca ff ff 	sub	r10,r7,-1
8000925c:	10 37       	cp.w	r7,r8
8000925e:	c0 94       	brge	80009270 <_vfprintf_r+0x122c>
80009260:	fa c9 f9 44 	sub	r9,sp,-1724
80009264:	14 97       	mov	r7,r10
80009266:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000926a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000926e:	c1 a8       	rjmp	800092a2 <_vfprintf_r+0x125e>
80009270:	41 09       	lddsp	r9,sp[0x40]
80009272:	59 f8       	cp.w	r8,31
80009274:	e0 89 00 13 	brgt	8000929a <_vfprintf_r+0x1256>
80009278:	f2 cb ff fc 	sub	r11,r9,-4
8000927c:	51 0b       	stdsp	sp[0x40],r11
8000927e:	72 09       	ld.w	r9,r9[0x0]
80009280:	fa c6 f9 44 	sub	r6,sp,-1724
80009284:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009288:	2f f8       	sub	r8,-1
8000928a:	f7 49 fd 88 	st.w	r11[-632],r9
8000928e:	fb 48 06 b4 	st.w	sp[1716],r8
80009292:	14 97       	mov	r7,r10
80009294:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009298:	c0 58       	rjmp	800092a2 <_vfprintf_r+0x125e>
8000929a:	92 18       	ld.sh	r8,r9[0x2]
8000929c:	14 97       	mov	r7,r10
8000929e:	2f c9       	sub	r9,-4
800092a0:	51 09       	stdsp	sp[0x40],r9
800092a2:	5c 78       	castu.h	r8
800092a4:	50 18       	stdsp	sp[0x4],r8
800092a6:	c4 68       	rjmp	80009332 <_vfprintf_r+0x12ee>
800092a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092ac:	40 3c       	lddsp	r12,sp[0xc]
800092ae:	58 0c       	cp.w	r12,0
800092b0:	c1 d0       	breq	800092ea <_vfprintf_r+0x12a6>
800092b2:	10 36       	cp.w	r6,r8
800092b4:	c0 64       	brge	800092c0 <_vfprintf_r+0x127c>
800092b6:	fa cb f9 44 	sub	r11,sp,-1724
800092ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092be:	c1 f8       	rjmp	800092fc <_vfprintf_r+0x12b8>
800092c0:	fa c8 f9 50 	sub	r8,sp,-1712
800092c4:	1a d8       	st.w	--sp,r8
800092c6:	fa c8 fa b8 	sub	r8,sp,-1352
800092ca:	0c 9b       	mov	r11,r6
800092cc:	1a d8       	st.w	--sp,r8
800092ce:	fa c8 fb b4 	sub	r8,sp,-1100
800092d2:	04 9a       	mov	r10,r2
800092d4:	1a d8       	st.w	--sp,r8
800092d6:	08 9c       	mov	r12,r4
800092d8:	fa c8 f9 40 	sub	r8,sp,-1728
800092dc:	fa c9 ff b4 	sub	r9,sp,-76
800092e0:	fe b0 f5 1a 	rcall	80007d14 <get_arg>
800092e4:	2f dd       	sub	sp,-12
800092e6:	78 0b       	ld.w	r11,r12[0x0]
800092e8:	c2 48       	rjmp	80009330 <_vfprintf_r+0x12ec>
800092ea:	ee ca ff ff 	sub	r10,r7,-1
800092ee:	10 37       	cp.w	r7,r8
800092f0:	c0 94       	brge	80009302 <_vfprintf_r+0x12be>
800092f2:	fa c9 f9 44 	sub	r9,sp,-1724
800092f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092fa:	14 97       	mov	r7,r10
800092fc:	ec fb fd 88 	ld.w	r11,r6[-632]
80009300:	c1 88       	rjmp	80009330 <_vfprintf_r+0x12ec>
80009302:	41 09       	lddsp	r9,sp[0x40]
80009304:	59 f8       	cp.w	r8,31
80009306:	e0 89 00 11 	brgt	80009328 <_vfprintf_r+0x12e4>
8000930a:	f2 cb ff fc 	sub	r11,r9,-4
8000930e:	51 0b       	stdsp	sp[0x40],r11
80009310:	fa c6 f9 44 	sub	r6,sp,-1724
80009314:	72 0b       	ld.w	r11,r9[0x0]
80009316:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000931a:	f3 4b fd 88 	st.w	r9[-632],r11
8000931e:	2f f8       	sub	r8,-1
80009320:	14 97       	mov	r7,r10
80009322:	fb 48 06 b4 	st.w	sp[1716],r8
80009326:	c0 58       	rjmp	80009330 <_vfprintf_r+0x12ec>
80009328:	72 0b       	ld.w	r11,r9[0x0]
8000932a:	14 97       	mov	r7,r10
8000932c:	2f c9       	sub	r9,-4
8000932e:	51 09       	stdsp	sp[0x40],r9
80009330:	50 1b       	stdsp	sp[0x4],r11
80009332:	30 0e       	mov	lr,0
80009334:	30 18       	mov	r8,1
80009336:	50 0e       	stdsp	sp[0x0],lr
80009338:	c2 29       	rjmp	8000957c <_vfprintf_r+0x1538>
8000933a:	50 a7       	stdsp	sp[0x28],r7
8000933c:	50 80       	stdsp	sp[0x20],r0
8000933e:	0c 97       	mov	r7,r6
80009340:	04 94       	mov	r4,r2
80009342:	06 96       	mov	r6,r3
80009344:	02 92       	mov	r2,r1
80009346:	fe cc b3 5a 	sub	r12,pc,-19622
8000934a:	40 93       	lddsp	r3,sp[0x24]
8000934c:	10 90       	mov	r0,r8
8000934e:	40 41       	lddsp	r1,sp[0x10]
80009350:	50 dc       	stdsp	sp[0x34],r12
80009352:	ed b5 00 05 	bld	r5,0x5
80009356:	c5 51       	brne	80009400 <_vfprintf_r+0x13bc>
80009358:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000935c:	40 3b       	lddsp	r11,sp[0xc]
8000935e:	58 0b       	cp.w	r11,0
80009360:	c2 20       	breq	800093a4 <_vfprintf_r+0x1360>
80009362:	10 36       	cp.w	r6,r8
80009364:	c0 a4       	brge	80009378 <_vfprintf_r+0x1334>
80009366:	fa ca f9 44 	sub	r10,sp,-1724
8000936a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000936e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009372:	fa e9 00 00 	st.d	sp[0],r8
80009376:	cf 28       	rjmp	8000955a <_vfprintf_r+0x1516>
80009378:	fa c8 f9 50 	sub	r8,sp,-1712
8000937c:	1a d8       	st.w	--sp,r8
8000937e:	fa c8 fa b8 	sub	r8,sp,-1352
80009382:	04 9a       	mov	r10,r2
80009384:	1a d8       	st.w	--sp,r8
80009386:	0c 9b       	mov	r11,r6
80009388:	fa c8 fb b4 	sub	r8,sp,-1100
8000938c:	08 9c       	mov	r12,r4
8000938e:	1a d8       	st.w	--sp,r8
80009390:	fa c8 f9 40 	sub	r8,sp,-1728
80009394:	fa c9 ff b4 	sub	r9,sp,-76
80009398:	fe b0 f4 be 	rcall	80007d14 <get_arg>
8000939c:	2f dd       	sub	sp,-12
8000939e:	f8 ea 00 00 	ld.d	r10,r12[0]
800093a2:	c0 c8       	rjmp	800093ba <_vfprintf_r+0x1376>
800093a4:	ee ca ff ff 	sub	r10,r7,-1
800093a8:	10 37       	cp.w	r7,r8
800093aa:	c0 b4       	brge	800093c0 <_vfprintf_r+0x137c>
800093ac:	fa c9 f9 44 	sub	r9,sp,-1724
800093b0:	14 97       	mov	r7,r10
800093b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093b6:	ec ea fd 88 	ld.d	r10,r6[-632]
800093ba:	fa eb 00 00 	st.d	sp[0],r10
800093be:	cc e8       	rjmp	8000955a <_vfprintf_r+0x1516>
800093c0:	41 09       	lddsp	r9,sp[0x40]
800093c2:	59 f8       	cp.w	r8,31
800093c4:	e0 89 00 16 	brgt	800093f0 <_vfprintf_r+0x13ac>
800093c8:	f2 e6 00 00 	ld.d	r6,r9[0]
800093cc:	f2 cb ff f8 	sub	r11,r9,-8
800093d0:	fa e7 00 00 	st.d	sp[0],r6
800093d4:	51 0b       	stdsp	sp[0x40],r11
800093d6:	fa c6 f9 44 	sub	r6,sp,-1724
800093da:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093de:	fa e6 00 00 	ld.d	r6,sp[0]
800093e2:	f2 e7 fd 88 	st.d	r9[-632],r6
800093e6:	2f f8       	sub	r8,-1
800093e8:	14 97       	mov	r7,r10
800093ea:	fb 48 06 b4 	st.w	sp[1716],r8
800093ee:	cb 68       	rjmp	8000955a <_vfprintf_r+0x1516>
800093f0:	f2 e6 00 00 	ld.d	r6,r9[0]
800093f4:	2f 89       	sub	r9,-8
800093f6:	fa e7 00 00 	st.d	sp[0],r6
800093fa:	51 09       	stdsp	sp[0x40],r9
800093fc:	14 97       	mov	r7,r10
800093fe:	ca e8       	rjmp	8000955a <_vfprintf_r+0x1516>
80009400:	ed b5 00 04 	bld	r5,0x4
80009404:	c1 71       	brne	80009432 <_vfprintf_r+0x13ee>
80009406:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000940a:	40 3e       	lddsp	lr,sp[0xc]
8000940c:	58 0e       	cp.w	lr,0
8000940e:	c0 80       	breq	8000941e <_vfprintf_r+0x13da>
80009410:	10 36       	cp.w	r6,r8
80009412:	c6 94       	brge	800094e4 <_vfprintf_r+0x14a0>
80009414:	fa cc f9 44 	sub	r12,sp,-1724
80009418:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000941c:	c8 28       	rjmp	80009520 <_vfprintf_r+0x14dc>
8000941e:	ee ca ff ff 	sub	r10,r7,-1
80009422:	10 37       	cp.w	r7,r8
80009424:	e0 84 00 81 	brge	80009526 <_vfprintf_r+0x14e2>
80009428:	fa cb f9 44 	sub	r11,sp,-1724
8000942c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009430:	c7 78       	rjmp	8000951e <_vfprintf_r+0x14da>
80009432:	ed b5 00 06 	bld	r5,0x6
80009436:	c4 b1       	brne	800094cc <_vfprintf_r+0x1488>
80009438:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000943c:	40 3c       	lddsp	r12,sp[0xc]
8000943e:	58 0c       	cp.w	r12,0
80009440:	c1 d0       	breq	8000947a <_vfprintf_r+0x1436>
80009442:	10 36       	cp.w	r6,r8
80009444:	c0 64       	brge	80009450 <_vfprintf_r+0x140c>
80009446:	fa cb f9 44 	sub	r11,sp,-1724
8000944a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000944e:	c1 f8       	rjmp	8000948c <_vfprintf_r+0x1448>
80009450:	fa c8 f9 50 	sub	r8,sp,-1712
80009454:	1a d8       	st.w	--sp,r8
80009456:	fa c8 fa b8 	sub	r8,sp,-1352
8000945a:	1a d8       	st.w	--sp,r8
8000945c:	fa c8 fb b4 	sub	r8,sp,-1100
80009460:	1a d8       	st.w	--sp,r8
80009462:	fa c8 f9 40 	sub	r8,sp,-1728
80009466:	fa c9 ff b4 	sub	r9,sp,-76
8000946a:	04 9a       	mov	r10,r2
8000946c:	0c 9b       	mov	r11,r6
8000946e:	08 9c       	mov	r12,r4
80009470:	fe b0 f4 52 	rcall	80007d14 <get_arg>
80009474:	2f dd       	sub	sp,-12
80009476:	98 18       	ld.sh	r8,r12[0x2]
80009478:	c2 78       	rjmp	800094c6 <_vfprintf_r+0x1482>
8000947a:	ee ca ff ff 	sub	r10,r7,-1
8000947e:	10 37       	cp.w	r7,r8
80009480:	c0 a4       	brge	80009494 <_vfprintf_r+0x1450>
80009482:	fa c9 f9 44 	sub	r9,sp,-1724
80009486:	14 97       	mov	r7,r10
80009488:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000948c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009490:	c1 b8       	rjmp	800094c6 <_vfprintf_r+0x1482>
80009492:	d7 03       	nop
80009494:	41 09       	lddsp	r9,sp[0x40]
80009496:	59 f8       	cp.w	r8,31
80009498:	e0 89 00 13 	brgt	800094be <_vfprintf_r+0x147a>
8000949c:	f2 cb ff fc 	sub	r11,r9,-4
800094a0:	51 0b       	stdsp	sp[0x40],r11
800094a2:	72 09       	ld.w	r9,r9[0x0]
800094a4:	fa c6 f9 44 	sub	r6,sp,-1724
800094a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800094ac:	2f f8       	sub	r8,-1
800094ae:	f7 49 fd 88 	st.w	r11[-632],r9
800094b2:	fb 48 06 b4 	st.w	sp[1716],r8
800094b6:	14 97       	mov	r7,r10
800094b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800094bc:	c0 58       	rjmp	800094c6 <_vfprintf_r+0x1482>
800094be:	92 18       	ld.sh	r8,r9[0x2]
800094c0:	14 97       	mov	r7,r10
800094c2:	2f c9       	sub	r9,-4
800094c4:	51 09       	stdsp	sp[0x40],r9
800094c6:	5c 78       	castu.h	r8
800094c8:	50 18       	stdsp	sp[0x4],r8
800094ca:	c4 68       	rjmp	80009556 <_vfprintf_r+0x1512>
800094cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094d0:	40 3c       	lddsp	r12,sp[0xc]
800094d2:	58 0c       	cp.w	r12,0
800094d4:	c1 d0       	breq	8000950e <_vfprintf_r+0x14ca>
800094d6:	10 36       	cp.w	r6,r8
800094d8:	c0 64       	brge	800094e4 <_vfprintf_r+0x14a0>
800094da:	fa cb f9 44 	sub	r11,sp,-1724
800094de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094e2:	c1 f8       	rjmp	80009520 <_vfprintf_r+0x14dc>
800094e4:	fa c8 f9 50 	sub	r8,sp,-1712
800094e8:	1a d8       	st.w	--sp,r8
800094ea:	fa c8 fa b8 	sub	r8,sp,-1352
800094ee:	0c 9b       	mov	r11,r6
800094f0:	1a d8       	st.w	--sp,r8
800094f2:	fa c8 fb b4 	sub	r8,sp,-1100
800094f6:	04 9a       	mov	r10,r2
800094f8:	1a d8       	st.w	--sp,r8
800094fa:	08 9c       	mov	r12,r4
800094fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009500:	fa c9 ff b4 	sub	r9,sp,-76
80009504:	fe b0 f4 08 	rcall	80007d14 <get_arg>
80009508:	2f dd       	sub	sp,-12
8000950a:	78 0b       	ld.w	r11,r12[0x0]
8000950c:	c2 48       	rjmp	80009554 <_vfprintf_r+0x1510>
8000950e:	ee ca ff ff 	sub	r10,r7,-1
80009512:	10 37       	cp.w	r7,r8
80009514:	c0 94       	brge	80009526 <_vfprintf_r+0x14e2>
80009516:	fa c9 f9 44 	sub	r9,sp,-1724
8000951a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000951e:	14 97       	mov	r7,r10
80009520:	ec fb fd 88 	ld.w	r11,r6[-632]
80009524:	c1 88       	rjmp	80009554 <_vfprintf_r+0x1510>
80009526:	41 09       	lddsp	r9,sp[0x40]
80009528:	59 f8       	cp.w	r8,31
8000952a:	e0 89 00 11 	brgt	8000954c <_vfprintf_r+0x1508>
8000952e:	f2 cb ff fc 	sub	r11,r9,-4
80009532:	51 0b       	stdsp	sp[0x40],r11
80009534:	fa c6 f9 44 	sub	r6,sp,-1724
80009538:	72 0b       	ld.w	r11,r9[0x0]
8000953a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000953e:	f3 4b fd 88 	st.w	r9[-632],r11
80009542:	2f f8       	sub	r8,-1
80009544:	14 97       	mov	r7,r10
80009546:	fb 48 06 b4 	st.w	sp[1716],r8
8000954a:	c0 58       	rjmp	80009554 <_vfprintf_r+0x1510>
8000954c:	72 0b       	ld.w	r11,r9[0x0]
8000954e:	14 97       	mov	r7,r10
80009550:	2f c9       	sub	r9,-4
80009552:	51 09       	stdsp	sp[0x40],r9
80009554:	50 1b       	stdsp	sp[0x4],r11
80009556:	30 0e       	mov	lr,0
80009558:	50 0e       	stdsp	sp[0x0],lr
8000955a:	40 08       	lddsp	r8,sp[0x0]
8000955c:	40 1c       	lddsp	r12,sp[0x4]
8000955e:	18 48       	or	r8,r12
80009560:	5f 19       	srne	r9
80009562:	0a 98       	mov	r8,r5
80009564:	eb e9 00 09 	and	r9,r5,r9
80009568:	a1 b8       	sbr	r8,0x1
8000956a:	58 09       	cp.w	r9,0
8000956c:	c0 70       	breq	8000957a <_vfprintf_r+0x1536>
8000956e:	10 95       	mov	r5,r8
80009570:	fb 60 06 b9 	st.b	sp[1721],r0
80009574:	33 08       	mov	r8,48
80009576:	fb 68 06 b8 	st.b	sp[1720],r8
8000957a:	30 28       	mov	r8,2
8000957c:	30 09       	mov	r9,0
8000957e:	fb 69 06 bb 	st.b	sp[1723],r9
80009582:	0a 99       	mov	r9,r5
80009584:	a7 d9       	cbr	r9,0x7
80009586:	40 2b       	lddsp	r11,sp[0x8]
80009588:	40 16       	lddsp	r6,sp[0x4]
8000958a:	58 0b       	cp.w	r11,0
8000958c:	5f 1a       	srne	r10
8000958e:	f2 05 17 40 	movge	r5,r9
80009592:	fa c2 f9 78 	sub	r2,sp,-1672
80009596:	40 09       	lddsp	r9,sp[0x0]
80009598:	0c 49       	or	r9,r6
8000959a:	5f 19       	srne	r9
8000959c:	f5 e9 10 09 	or	r9,r10,r9
800095a0:	c5 c0       	breq	80009658 <_vfprintf_r+0x1614>
800095a2:	30 19       	mov	r9,1
800095a4:	f2 08 18 00 	cp.b	r8,r9
800095a8:	c0 60       	breq	800095b4 <_vfprintf_r+0x1570>
800095aa:	30 29       	mov	r9,2
800095ac:	f2 08 18 00 	cp.b	r8,r9
800095b0:	c0 41       	brne	800095b8 <_vfprintf_r+0x1574>
800095b2:	c3 c8       	rjmp	8000962a <_vfprintf_r+0x15e6>
800095b4:	04 96       	mov	r6,r2
800095b6:	c3 08       	rjmp	80009616 <_vfprintf_r+0x15d2>
800095b8:	04 96       	mov	r6,r2
800095ba:	fa e8 00 00 	ld.d	r8,sp[0]
800095be:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800095c2:	2d 0a       	sub	r10,-48
800095c4:	0c fa       	st.b	--r6,r10
800095c6:	f0 0b 16 03 	lsr	r11,r8,0x3
800095ca:	f2 0c 16 03 	lsr	r12,r9,0x3
800095ce:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800095d2:	18 99       	mov	r9,r12
800095d4:	16 98       	mov	r8,r11
800095d6:	58 08       	cp.w	r8,0
800095d8:	5c 29       	cpc	r9
800095da:	cf 21       	brne	800095be <_vfprintf_r+0x157a>
800095dc:	fa e9 00 00 	st.d	sp[0],r8
800095e0:	ed b5 00 00 	bld	r5,0x0
800095e4:	c4 51       	brne	8000966e <_vfprintf_r+0x162a>
800095e6:	33 09       	mov	r9,48
800095e8:	f2 0a 18 00 	cp.b	r10,r9
800095ec:	c4 10       	breq	8000966e <_vfprintf_r+0x162a>
800095ee:	0c f9       	st.b	--r6,r9
800095f0:	c3 f8       	rjmp	8000966e <_vfprintf_r+0x162a>
800095f2:	fa ea 00 00 	ld.d	r10,sp[0]
800095f6:	30 a8       	mov	r8,10
800095f8:	30 09       	mov	r9,0
800095fa:	e0 a0 1a 19 	rcall	8000ca2c <__avr32_umod64>
800095fe:	30 a8       	mov	r8,10
80009600:	2d 0a       	sub	r10,-48
80009602:	30 09       	mov	r9,0
80009604:	ac 8a       	st.b	r6[0x0],r10
80009606:	fa ea 00 00 	ld.d	r10,sp[0]
8000960a:	e0 a0 18 df 	rcall	8000c7c8 <__avr32_udiv64>
8000960e:	16 99       	mov	r9,r11
80009610:	14 98       	mov	r8,r10
80009612:	fa e9 00 00 	st.d	sp[0],r8
80009616:	20 16       	sub	r6,1
80009618:	fa ea 00 00 	ld.d	r10,sp[0]
8000961c:	58 9a       	cp.w	r10,9
8000961e:	5c 2b       	cpc	r11
80009620:	fe 9b ff e9 	brhi	800095f2 <_vfprintf_r+0x15ae>
80009624:	1b f8       	ld.ub	r8,sp[0x7]
80009626:	2d 08       	sub	r8,-48
80009628:	c2 08       	rjmp	80009668 <_vfprintf_r+0x1624>
8000962a:	04 96       	mov	r6,r2
8000962c:	fa e8 00 00 	ld.d	r8,sp[0]
80009630:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009634:	40 de       	lddsp	lr,sp[0x34]
80009636:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000963a:	0c fa       	st.b	--r6,r10
8000963c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009640:	f0 0a 16 04 	lsr	r10,r8,0x4
80009644:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009648:	16 99       	mov	r9,r11
8000964a:	14 98       	mov	r8,r10
8000964c:	58 08       	cp.w	r8,0
8000964e:	5c 29       	cpc	r9
80009650:	cf 01       	brne	80009630 <_vfprintf_r+0x15ec>
80009652:	fa e9 00 00 	st.d	sp[0],r8
80009656:	c0 c8       	rjmp	8000966e <_vfprintf_r+0x162a>
80009658:	58 08       	cp.w	r8,0
8000965a:	c0 91       	brne	8000966c <_vfprintf_r+0x1628>
8000965c:	ed b5 00 00 	bld	r5,0x0
80009660:	c0 61       	brne	8000966c <_vfprintf_r+0x1628>
80009662:	fa c6 f9 79 	sub	r6,sp,-1671
80009666:	33 08       	mov	r8,48
80009668:	ac 88       	st.b	r6[0x0],r8
8000966a:	c0 28       	rjmp	8000966e <_vfprintf_r+0x162a>
8000966c:	04 96       	mov	r6,r2
8000966e:	0c 12       	sub	r2,r6
80009670:	c1 c8       	rjmp	800096a8 <_vfprintf_r+0x1664>
80009672:	50 a7       	stdsp	sp[0x28],r7
80009674:	50 80       	stdsp	sp[0x20],r0
80009676:	40 93       	lddsp	r3,sp[0x24]
80009678:	0c 97       	mov	r7,r6
8000967a:	10 90       	mov	r0,r8
8000967c:	04 94       	mov	r4,r2
8000967e:	40 41       	lddsp	r1,sp[0x10]
80009680:	58 08       	cp.w	r8,0
80009682:	e0 80 04 4f 	breq	80009f20 <_vfprintf_r+0x1edc>
80009686:	fb 68 06 60 	st.b	sp[1632],r8
8000968a:	30 0c       	mov	r12,0
8000968c:	30 08       	mov	r8,0
8000968e:	30 12       	mov	r2,1
80009690:	fb 68 06 bb 	st.b	sp[1723],r8
80009694:	50 2c       	stdsp	sp[0x8],r12
80009696:	fa c6 f9 a0 	sub	r6,sp,-1632
8000969a:	c0 78       	rjmp	800096a8 <_vfprintf_r+0x1664>
8000969c:	30 0b       	mov	r11,0
8000969e:	50 2b       	stdsp	sp[0x8],r11
800096a0:	c0 48       	rjmp	800096a8 <_vfprintf_r+0x1664>
800096a2:	40 22       	lddsp	r2,sp[0x8]
800096a4:	30 0a       	mov	r10,0
800096a6:	50 2a       	stdsp	sp[0x8],r10
800096a8:	40 29       	lddsp	r9,sp[0x8]
800096aa:	e4 09 0c 49 	max	r9,r2,r9
800096ae:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800096b2:	50 39       	stdsp	sp[0xc],r9
800096b4:	0a 9e       	mov	lr,r5
800096b6:	30 09       	mov	r9,0
800096b8:	e2 1e 00 02 	andl	lr,0x2,COH
800096bc:	f2 08 18 00 	cp.b	r8,r9
800096c0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800096c4:	f7 b8 01 ff 	subne	r8,-1
800096c8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800096cc:	0a 9b       	mov	r11,r5
800096ce:	58 0e       	cp.w	lr,0
800096d0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800096d4:	f7 bc 01 fe 	subne	r12,-2
800096d8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800096dc:	e2 1b 00 84 	andl	r11,0x84,COH
800096e0:	50 fe       	stdsp	sp[0x3c],lr
800096e2:	50 9b       	stdsp	sp[0x24],r11
800096e4:	c4 71       	brne	80009772 <_vfprintf_r+0x172e>
800096e6:	40 8a       	lddsp	r10,sp[0x20]
800096e8:	40 39       	lddsp	r9,sp[0xc]
800096ea:	12 1a       	sub	r10,r9
800096ec:	50 4a       	stdsp	sp[0x10],r10
800096ee:	58 0a       	cp.w	r10,0
800096f0:	e0 89 00 20 	brgt	80009730 <_vfprintf_r+0x16ec>
800096f4:	c3 f8       	rjmp	80009772 <_vfprintf_r+0x172e>
800096f6:	2f 09       	sub	r9,-16
800096f8:	2f f8       	sub	r8,-1
800096fa:	fe ce b6 f6 	sub	lr,pc,-18698
800096fe:	31 0c       	mov	r12,16
80009700:	fb 49 06 90 	st.w	sp[1680],r9
80009704:	87 0e       	st.w	r3[0x0],lr
80009706:	87 1c       	st.w	r3[0x4],r12
80009708:	fb 48 06 8c 	st.w	sp[1676],r8
8000970c:	58 78       	cp.w	r8,7
8000970e:	e0 89 00 04 	brgt	80009716 <_vfprintf_r+0x16d2>
80009712:	2f 83       	sub	r3,-8
80009714:	c0 b8       	rjmp	8000972a <_vfprintf_r+0x16e6>
80009716:	fa ca f9 78 	sub	r10,sp,-1672
8000971a:	02 9b       	mov	r11,r1
8000971c:	08 9c       	mov	r12,r4
8000971e:	fe b0 f4 85 	rcall	80008028 <__sprint_r>
80009722:	e0 81 04 10 	brne	80009f42 <_vfprintf_r+0x1efe>
80009726:	fa c3 f9 e0 	sub	r3,sp,-1568
8000972a:	40 4b       	lddsp	r11,sp[0x10]
8000972c:	21 0b       	sub	r11,16
8000972e:	50 4b       	stdsp	sp[0x10],r11
80009730:	fa f9 06 90 	ld.w	r9,sp[1680]
80009734:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009738:	fe ca b7 34 	sub	r10,pc,-18636
8000973c:	40 4e       	lddsp	lr,sp[0x10]
8000973e:	59 0e       	cp.w	lr,16
80009740:	fe 99 ff db 	brgt	800096f6 <_vfprintf_r+0x16b2>
80009744:	1c 09       	add	r9,lr
80009746:	2f f8       	sub	r8,-1
80009748:	87 0a       	st.w	r3[0x0],r10
8000974a:	fb 49 06 90 	st.w	sp[1680],r9
8000974e:	87 1e       	st.w	r3[0x4],lr
80009750:	fb 48 06 8c 	st.w	sp[1676],r8
80009754:	58 78       	cp.w	r8,7
80009756:	e0 89 00 04 	brgt	8000975e <_vfprintf_r+0x171a>
8000975a:	2f 83       	sub	r3,-8
8000975c:	c0 b8       	rjmp	80009772 <_vfprintf_r+0x172e>
8000975e:	fa ca f9 78 	sub	r10,sp,-1672
80009762:	02 9b       	mov	r11,r1
80009764:	08 9c       	mov	r12,r4
80009766:	fe b0 f4 61 	rcall	80008028 <__sprint_r>
8000976a:	e0 81 03 ec 	brne	80009f42 <_vfprintf_r+0x1efe>
8000976e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009772:	30 09       	mov	r9,0
80009774:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009778:	f2 08 18 00 	cp.b	r8,r9
8000977c:	c1 f0       	breq	800097ba <_vfprintf_r+0x1776>
8000977e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009782:	fa c9 f9 45 	sub	r9,sp,-1723
80009786:	2f f8       	sub	r8,-1
80009788:	87 09       	st.w	r3[0x0],r9
8000978a:	fb 48 06 90 	st.w	sp[1680],r8
8000978e:	30 19       	mov	r9,1
80009790:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009794:	87 19       	st.w	r3[0x4],r9
80009796:	2f f8       	sub	r8,-1
80009798:	fb 48 06 8c 	st.w	sp[1676],r8
8000979c:	58 78       	cp.w	r8,7
8000979e:	e0 89 00 04 	brgt	800097a6 <_vfprintf_r+0x1762>
800097a2:	2f 83       	sub	r3,-8
800097a4:	c0 b8       	rjmp	800097ba <_vfprintf_r+0x1776>
800097a6:	fa ca f9 78 	sub	r10,sp,-1672
800097aa:	02 9b       	mov	r11,r1
800097ac:	08 9c       	mov	r12,r4
800097ae:	fe b0 f4 3d 	rcall	80008028 <__sprint_r>
800097b2:	e0 81 03 c8 	brne	80009f42 <_vfprintf_r+0x1efe>
800097b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ba:	40 fc       	lddsp	r12,sp[0x3c]
800097bc:	58 0c       	cp.w	r12,0
800097be:	c1 f0       	breq	800097fc <_vfprintf_r+0x17b8>
800097c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800097c4:	fa c9 f9 48 	sub	r9,sp,-1720
800097c8:	2f e8       	sub	r8,-2
800097ca:	87 09       	st.w	r3[0x0],r9
800097cc:	fb 48 06 90 	st.w	sp[1680],r8
800097d0:	30 29       	mov	r9,2
800097d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097d6:	87 19       	st.w	r3[0x4],r9
800097d8:	2f f8       	sub	r8,-1
800097da:	fb 48 06 8c 	st.w	sp[1676],r8
800097de:	58 78       	cp.w	r8,7
800097e0:	e0 89 00 04 	brgt	800097e8 <_vfprintf_r+0x17a4>
800097e4:	2f 83       	sub	r3,-8
800097e6:	c0 b8       	rjmp	800097fc <_vfprintf_r+0x17b8>
800097e8:	fa ca f9 78 	sub	r10,sp,-1672
800097ec:	02 9b       	mov	r11,r1
800097ee:	08 9c       	mov	r12,r4
800097f0:	fe b0 f4 1c 	rcall	80008028 <__sprint_r>
800097f4:	e0 81 03 a7 	brne	80009f42 <_vfprintf_r+0x1efe>
800097f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800097fc:	40 9b       	lddsp	r11,sp[0x24]
800097fe:	e0 4b 00 80 	cp.w	r11,128
80009802:	c4 71       	brne	80009890 <_vfprintf_r+0x184c>
80009804:	40 8a       	lddsp	r10,sp[0x20]
80009806:	40 39       	lddsp	r9,sp[0xc]
80009808:	12 1a       	sub	r10,r9
8000980a:	50 4a       	stdsp	sp[0x10],r10
8000980c:	58 0a       	cp.w	r10,0
8000980e:	e0 89 00 20 	brgt	8000984e <_vfprintf_r+0x180a>
80009812:	c3 f8       	rjmp	80009890 <_vfprintf_r+0x184c>
80009814:	2f 09       	sub	r9,-16
80009816:	2f f8       	sub	r8,-1
80009818:	fe ce b8 04 	sub	lr,pc,-18428
8000981c:	31 0c       	mov	r12,16
8000981e:	fb 49 06 90 	st.w	sp[1680],r9
80009822:	87 0e       	st.w	r3[0x0],lr
80009824:	87 1c       	st.w	r3[0x4],r12
80009826:	fb 48 06 8c 	st.w	sp[1676],r8
8000982a:	58 78       	cp.w	r8,7
8000982c:	e0 89 00 04 	brgt	80009834 <_vfprintf_r+0x17f0>
80009830:	2f 83       	sub	r3,-8
80009832:	c0 b8       	rjmp	80009848 <_vfprintf_r+0x1804>
80009834:	fa ca f9 78 	sub	r10,sp,-1672
80009838:	02 9b       	mov	r11,r1
8000983a:	08 9c       	mov	r12,r4
8000983c:	fe b0 f3 f6 	rcall	80008028 <__sprint_r>
80009840:	e0 81 03 81 	brne	80009f42 <_vfprintf_r+0x1efe>
80009844:	fa c3 f9 e0 	sub	r3,sp,-1568
80009848:	40 4b       	lddsp	r11,sp[0x10]
8000984a:	21 0b       	sub	r11,16
8000984c:	50 4b       	stdsp	sp[0x10],r11
8000984e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009852:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009856:	fe ca b8 42 	sub	r10,pc,-18366
8000985a:	40 4e       	lddsp	lr,sp[0x10]
8000985c:	59 0e       	cp.w	lr,16
8000985e:	fe 99 ff db 	brgt	80009814 <_vfprintf_r+0x17d0>
80009862:	1c 09       	add	r9,lr
80009864:	2f f8       	sub	r8,-1
80009866:	87 0a       	st.w	r3[0x0],r10
80009868:	fb 49 06 90 	st.w	sp[1680],r9
8000986c:	87 1e       	st.w	r3[0x4],lr
8000986e:	fb 48 06 8c 	st.w	sp[1676],r8
80009872:	58 78       	cp.w	r8,7
80009874:	e0 89 00 04 	brgt	8000987c <_vfprintf_r+0x1838>
80009878:	2f 83       	sub	r3,-8
8000987a:	c0 b8       	rjmp	80009890 <_vfprintf_r+0x184c>
8000987c:	fa ca f9 78 	sub	r10,sp,-1672
80009880:	02 9b       	mov	r11,r1
80009882:	08 9c       	mov	r12,r4
80009884:	fe b0 f3 d2 	rcall	80008028 <__sprint_r>
80009888:	e0 81 03 5d 	brne	80009f42 <_vfprintf_r+0x1efe>
8000988c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009890:	40 2c       	lddsp	r12,sp[0x8]
80009892:	04 1c       	sub	r12,r2
80009894:	50 2c       	stdsp	sp[0x8],r12
80009896:	58 0c       	cp.w	r12,0
80009898:	e0 89 00 20 	brgt	800098d8 <_vfprintf_r+0x1894>
8000989c:	c3 f8       	rjmp	8000991a <_vfprintf_r+0x18d6>
8000989e:	2f 09       	sub	r9,-16
800098a0:	2f f8       	sub	r8,-1
800098a2:	fe cb b8 8e 	sub	r11,pc,-18290
800098a6:	31 0a       	mov	r10,16
800098a8:	fb 49 06 90 	st.w	sp[1680],r9
800098ac:	87 0b       	st.w	r3[0x0],r11
800098ae:	87 1a       	st.w	r3[0x4],r10
800098b0:	fb 48 06 8c 	st.w	sp[1676],r8
800098b4:	58 78       	cp.w	r8,7
800098b6:	e0 89 00 04 	brgt	800098be <_vfprintf_r+0x187a>
800098ba:	2f 83       	sub	r3,-8
800098bc:	c0 b8       	rjmp	800098d2 <_vfprintf_r+0x188e>
800098be:	fa ca f9 78 	sub	r10,sp,-1672
800098c2:	02 9b       	mov	r11,r1
800098c4:	08 9c       	mov	r12,r4
800098c6:	fe b0 f3 b1 	rcall	80008028 <__sprint_r>
800098ca:	e0 81 03 3c 	brne	80009f42 <_vfprintf_r+0x1efe>
800098ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d2:	40 29       	lddsp	r9,sp[0x8]
800098d4:	21 09       	sub	r9,16
800098d6:	50 29       	stdsp	sp[0x8],r9
800098d8:	fa f9 06 90 	ld.w	r9,sp[1680]
800098dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098e0:	fe ca b8 cc 	sub	r10,pc,-18228
800098e4:	40 2e       	lddsp	lr,sp[0x8]
800098e6:	59 0e       	cp.w	lr,16
800098e8:	fe 99 ff db 	brgt	8000989e <_vfprintf_r+0x185a>
800098ec:	1c 09       	add	r9,lr
800098ee:	2f f8       	sub	r8,-1
800098f0:	87 0a       	st.w	r3[0x0],r10
800098f2:	fb 49 06 90 	st.w	sp[1680],r9
800098f6:	87 1e       	st.w	r3[0x4],lr
800098f8:	fb 48 06 8c 	st.w	sp[1676],r8
800098fc:	58 78       	cp.w	r8,7
800098fe:	e0 89 00 04 	brgt	80009906 <_vfprintf_r+0x18c2>
80009902:	2f 83       	sub	r3,-8
80009904:	c0 b8       	rjmp	8000991a <_vfprintf_r+0x18d6>
80009906:	fa ca f9 78 	sub	r10,sp,-1672
8000990a:	02 9b       	mov	r11,r1
8000990c:	08 9c       	mov	r12,r4
8000990e:	fe b0 f3 8d 	rcall	80008028 <__sprint_r>
80009912:	e0 81 03 18 	brne	80009f42 <_vfprintf_r+0x1efe>
80009916:	fa c3 f9 e0 	sub	r3,sp,-1568
8000991a:	ed b5 00 08 	bld	r5,0x8
8000991e:	c0 b0       	breq	80009934 <_vfprintf_r+0x18f0>
80009920:	fa f8 06 90 	ld.w	r8,sp[1680]
80009924:	87 12       	st.w	r3[0x4],r2
80009926:	87 06       	st.w	r3[0x0],r6
80009928:	f0 02 00 02 	add	r2,r8,r2
8000992c:	fb 42 06 90 	st.w	sp[1680],r2
80009930:	e0 8f 01 d4 	bral	80009cd8 <_vfprintf_r+0x1c94>
80009934:	e0 40 00 65 	cp.w	r0,101
80009938:	e0 8a 01 d6 	brle	80009ce4 <_vfprintf_r+0x1ca0>
8000993c:	30 08       	mov	r8,0
8000993e:	30 09       	mov	r9,0
80009940:	40 5b       	lddsp	r11,sp[0x14]
80009942:	40 7a       	lddsp	r10,sp[0x1c]
80009944:	e0 a0 15 3b 	rcall	8000c3ba <__avr32_f64_cmp_eq>
80009948:	c7 90       	breq	80009a3a <_vfprintf_r+0x19f6>
8000994a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000994e:	fe c9 b9 4e 	sub	r9,pc,-18098
80009952:	2f f8       	sub	r8,-1
80009954:	87 09       	st.w	r3[0x0],r9
80009956:	fb 48 06 90 	st.w	sp[1680],r8
8000995a:	30 19       	mov	r9,1
8000995c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009960:	87 19       	st.w	r3[0x4],r9
80009962:	2f f8       	sub	r8,-1
80009964:	fb 48 06 8c 	st.w	sp[1676],r8
80009968:	58 78       	cp.w	r8,7
8000996a:	e0 89 00 05 	brgt	80009974 <_vfprintf_r+0x1930>
8000996e:	2f 83       	sub	r3,-8
80009970:	c0 c8       	rjmp	80009988 <_vfprintf_r+0x1944>
80009972:	d7 03       	nop
80009974:	fa ca f9 78 	sub	r10,sp,-1672
80009978:	02 9b       	mov	r11,r1
8000997a:	08 9c       	mov	r12,r4
8000997c:	fe b0 f3 56 	rcall	80008028 <__sprint_r>
80009980:	e0 81 02 e1 	brne	80009f42 <_vfprintf_r+0x1efe>
80009984:	fa c3 f9 e0 	sub	r3,sp,-1568
80009988:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000998c:	40 6c       	lddsp	r12,sp[0x18]
8000998e:	18 38       	cp.w	r8,r12
80009990:	c0 55       	brlt	8000999a <_vfprintf_r+0x1956>
80009992:	ed b5 00 00 	bld	r5,0x0
80009996:	e0 81 02 6b 	brne	80009e6c <_vfprintf_r+0x1e28>
8000999a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000999e:	2f f8       	sub	r8,-1
800099a0:	40 cb       	lddsp	r11,sp[0x30]
800099a2:	fb 48 06 90 	st.w	sp[1680],r8
800099a6:	30 19       	mov	r9,1
800099a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ac:	87 0b       	st.w	r3[0x0],r11
800099ae:	2f f8       	sub	r8,-1
800099b0:	87 19       	st.w	r3[0x4],r9
800099b2:	fb 48 06 8c 	st.w	sp[1676],r8
800099b6:	58 78       	cp.w	r8,7
800099b8:	e0 89 00 04 	brgt	800099c0 <_vfprintf_r+0x197c>
800099bc:	2f 83       	sub	r3,-8
800099be:	c0 b8       	rjmp	800099d4 <_vfprintf_r+0x1990>
800099c0:	fa ca f9 78 	sub	r10,sp,-1672
800099c4:	02 9b       	mov	r11,r1
800099c6:	08 9c       	mov	r12,r4
800099c8:	fe b0 f3 30 	rcall	80008028 <__sprint_r>
800099cc:	e0 81 02 bb 	brne	80009f42 <_vfprintf_r+0x1efe>
800099d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d4:	40 66       	lddsp	r6,sp[0x18]
800099d6:	20 16       	sub	r6,1
800099d8:	58 06       	cp.w	r6,0
800099da:	e0 89 00 1d 	brgt	80009a14 <_vfprintf_r+0x19d0>
800099de:	e0 8f 02 47 	bral	80009e6c <_vfprintf_r+0x1e28>
800099e2:	2f 09       	sub	r9,-16
800099e4:	2f f8       	sub	r8,-1
800099e6:	fb 49 06 90 	st.w	sp[1680],r9
800099ea:	87 02       	st.w	r3[0x0],r2
800099ec:	87 10       	st.w	r3[0x4],r0
800099ee:	fb 48 06 8c 	st.w	sp[1676],r8
800099f2:	58 78       	cp.w	r8,7
800099f4:	e0 89 00 04 	brgt	800099fc <_vfprintf_r+0x19b8>
800099f8:	2f 83       	sub	r3,-8
800099fa:	c0 b8       	rjmp	80009a10 <_vfprintf_r+0x19cc>
800099fc:	fa ca f9 78 	sub	r10,sp,-1672
80009a00:	02 9b       	mov	r11,r1
80009a02:	08 9c       	mov	r12,r4
80009a04:	fe b0 f3 12 	rcall	80008028 <__sprint_r>
80009a08:	e0 81 02 9d 	brne	80009f42 <_vfprintf_r+0x1efe>
80009a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a10:	21 06       	sub	r6,16
80009a12:	c0 48       	rjmp	80009a1a <_vfprintf_r+0x19d6>
80009a14:	fe c2 ba 00 	sub	r2,pc,-17920
80009a18:	31 00       	mov	r0,16
80009a1a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a22:	fe ca ba 0e 	sub	r10,pc,-17906
80009a26:	59 06       	cp.w	r6,16
80009a28:	fe 99 ff dd 	brgt	800099e2 <_vfprintf_r+0x199e>
80009a2c:	0c 09       	add	r9,r6
80009a2e:	87 0a       	st.w	r3[0x0],r10
80009a30:	fb 49 06 90 	st.w	sp[1680],r9
80009a34:	2f f8       	sub	r8,-1
80009a36:	87 16       	st.w	r3[0x4],r6
80009a38:	c5 39       	rjmp	80009cde <_vfprintf_r+0x1c9a>
80009a3a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009a3e:	58 0a       	cp.w	r10,0
80009a40:	e0 89 00 92 	brgt	80009b64 <_vfprintf_r+0x1b20>
80009a44:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a48:	fe c9 ba 48 	sub	r9,pc,-17848
80009a4c:	2f f8       	sub	r8,-1
80009a4e:	87 09       	st.w	r3[0x0],r9
80009a50:	fb 48 06 90 	st.w	sp[1680],r8
80009a54:	30 19       	mov	r9,1
80009a56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a5a:	87 19       	st.w	r3[0x4],r9
80009a5c:	2f f8       	sub	r8,-1
80009a5e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a62:	58 78       	cp.w	r8,7
80009a64:	e0 89 00 04 	brgt	80009a6c <_vfprintf_r+0x1a28>
80009a68:	2f 83       	sub	r3,-8
80009a6a:	c0 b8       	rjmp	80009a80 <_vfprintf_r+0x1a3c>
80009a6c:	fa ca f9 78 	sub	r10,sp,-1672
80009a70:	02 9b       	mov	r11,r1
80009a72:	08 9c       	mov	r12,r4
80009a74:	fe b0 f2 da 	rcall	80008028 <__sprint_r>
80009a78:	e0 81 02 65 	brne	80009f42 <_vfprintf_r+0x1efe>
80009a7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a80:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a84:	58 08       	cp.w	r8,0
80009a86:	c0 81       	brne	80009a96 <_vfprintf_r+0x1a52>
80009a88:	40 6a       	lddsp	r10,sp[0x18]
80009a8a:	58 0a       	cp.w	r10,0
80009a8c:	c0 51       	brne	80009a96 <_vfprintf_r+0x1a52>
80009a8e:	ed b5 00 00 	bld	r5,0x0
80009a92:	e0 81 01 ed 	brne	80009e6c <_vfprintf_r+0x1e28>
80009a96:	40 c9       	lddsp	r9,sp[0x30]
80009a98:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a9c:	2f f8       	sub	r8,-1
80009a9e:	87 09       	st.w	r3[0x0],r9
80009aa0:	fb 48 06 90 	st.w	sp[1680],r8
80009aa4:	30 19       	mov	r9,1
80009aa6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aaa:	87 19       	st.w	r3[0x4],r9
80009aac:	2f f8       	sub	r8,-1
80009aae:	fb 48 06 8c 	st.w	sp[1676],r8
80009ab2:	58 78       	cp.w	r8,7
80009ab4:	e0 89 00 04 	brgt	80009abc <_vfprintf_r+0x1a78>
80009ab8:	2f 83       	sub	r3,-8
80009aba:	c0 b8       	rjmp	80009ad0 <_vfprintf_r+0x1a8c>
80009abc:	fa ca f9 78 	sub	r10,sp,-1672
80009ac0:	02 9b       	mov	r11,r1
80009ac2:	08 9c       	mov	r12,r4
80009ac4:	fe b0 f2 b2 	rcall	80008028 <__sprint_r>
80009ac8:	e0 81 02 3d 	brne	80009f42 <_vfprintf_r+0x1efe>
80009acc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ad0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009ad4:	5c 32       	neg	r2
80009ad6:	58 02       	cp.w	r2,0
80009ad8:	e0 89 00 1d 	brgt	80009b12 <_vfprintf_r+0x1ace>
80009adc:	c3 d8       	rjmp	80009b56 <_vfprintf_r+0x1b12>
80009ade:	2f 09       	sub	r9,-16
80009ae0:	2f f8       	sub	r8,-1
80009ae2:	31 0e       	mov	lr,16
80009ae4:	fb 49 06 90 	st.w	sp[1680],r9
80009ae8:	87 00       	st.w	r3[0x0],r0
80009aea:	87 1e       	st.w	r3[0x4],lr
80009aec:	fb 48 06 8c 	st.w	sp[1676],r8
80009af0:	58 78       	cp.w	r8,7
80009af2:	e0 89 00 04 	brgt	80009afa <_vfprintf_r+0x1ab6>
80009af6:	2f 83       	sub	r3,-8
80009af8:	c0 b8       	rjmp	80009b0e <_vfprintf_r+0x1aca>
80009afa:	fa ca f9 78 	sub	r10,sp,-1672
80009afe:	02 9b       	mov	r11,r1
80009b00:	08 9c       	mov	r12,r4
80009b02:	fe b0 f2 93 	rcall	80008028 <__sprint_r>
80009b06:	e0 81 02 1e 	brne	80009f42 <_vfprintf_r+0x1efe>
80009b0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b0e:	21 02       	sub	r2,16
80009b10:	c0 38       	rjmp	80009b16 <_vfprintf_r+0x1ad2>
80009b12:	fe c0 ba fe 	sub	r0,pc,-17666
80009b16:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b1e:	fe ca bb 0a 	sub	r10,pc,-17654
80009b22:	59 02       	cp.w	r2,16
80009b24:	fe 99 ff dd 	brgt	80009ade <_vfprintf_r+0x1a9a>
80009b28:	04 09       	add	r9,r2
80009b2a:	2f f8       	sub	r8,-1
80009b2c:	87 0a       	st.w	r3[0x0],r10
80009b2e:	fb 49 06 90 	st.w	sp[1680],r9
80009b32:	87 12       	st.w	r3[0x4],r2
80009b34:	fb 48 06 8c 	st.w	sp[1676],r8
80009b38:	58 78       	cp.w	r8,7
80009b3a:	e0 89 00 04 	brgt	80009b42 <_vfprintf_r+0x1afe>
80009b3e:	2f 83       	sub	r3,-8
80009b40:	c0 b8       	rjmp	80009b56 <_vfprintf_r+0x1b12>
80009b42:	fa ca f9 78 	sub	r10,sp,-1672
80009b46:	02 9b       	mov	r11,r1
80009b48:	08 9c       	mov	r12,r4
80009b4a:	fe b0 f2 6f 	rcall	80008028 <__sprint_r>
80009b4e:	e0 81 01 fa 	brne	80009f42 <_vfprintf_r+0x1efe>
80009b52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b56:	40 6c       	lddsp	r12,sp[0x18]
80009b58:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b5c:	87 06       	st.w	r3[0x0],r6
80009b5e:	87 1c       	st.w	r3[0x4],r12
80009b60:	18 08       	add	r8,r12
80009b62:	cb 98       	rjmp	80009cd4 <_vfprintf_r+0x1c90>
80009b64:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b6c:	40 6b       	lddsp	r11,sp[0x18]
80009b6e:	16 3a       	cp.w	r10,r11
80009b70:	c6 f5       	brlt	80009c4e <_vfprintf_r+0x1c0a>
80009b72:	16 09       	add	r9,r11
80009b74:	2f f8       	sub	r8,-1
80009b76:	87 06       	st.w	r3[0x0],r6
80009b78:	fb 49 06 90 	st.w	sp[1680],r9
80009b7c:	87 1b       	st.w	r3[0x4],r11
80009b7e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b82:	58 78       	cp.w	r8,7
80009b84:	e0 89 00 04 	brgt	80009b8c <_vfprintf_r+0x1b48>
80009b88:	2f 83       	sub	r3,-8
80009b8a:	c0 b8       	rjmp	80009ba0 <_vfprintf_r+0x1b5c>
80009b8c:	fa ca f9 78 	sub	r10,sp,-1672
80009b90:	02 9b       	mov	r11,r1
80009b92:	08 9c       	mov	r12,r4
80009b94:	fe b0 f2 4a 	rcall	80008028 <__sprint_r>
80009b98:	e0 81 01 d5 	brne	80009f42 <_vfprintf_r+0x1efe>
80009b9c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ba0:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009ba4:	40 6a       	lddsp	r10,sp[0x18]
80009ba6:	14 16       	sub	r6,r10
80009ba8:	58 06       	cp.w	r6,0
80009baa:	e0 89 00 1c 	brgt	80009be2 <_vfprintf_r+0x1b9e>
80009bae:	c3 d8       	rjmp	80009c28 <_vfprintf_r+0x1be4>
80009bb0:	2f 09       	sub	r9,-16
80009bb2:	2f f8       	sub	r8,-1
80009bb4:	fb 49 06 90 	st.w	sp[1680],r9
80009bb8:	87 02       	st.w	r3[0x0],r2
80009bba:	87 10       	st.w	r3[0x4],r0
80009bbc:	fb 48 06 8c 	st.w	sp[1676],r8
80009bc0:	58 78       	cp.w	r8,7
80009bc2:	e0 89 00 04 	brgt	80009bca <_vfprintf_r+0x1b86>
80009bc6:	2f 83       	sub	r3,-8
80009bc8:	c0 b8       	rjmp	80009bde <_vfprintf_r+0x1b9a>
80009bca:	fa ca f9 78 	sub	r10,sp,-1672
80009bce:	02 9b       	mov	r11,r1
80009bd0:	08 9c       	mov	r12,r4
80009bd2:	fe b0 f2 2b 	rcall	80008028 <__sprint_r>
80009bd6:	e0 81 01 b6 	brne	80009f42 <_vfprintf_r+0x1efe>
80009bda:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bde:	21 06       	sub	r6,16
80009be0:	c0 48       	rjmp	80009be8 <_vfprintf_r+0x1ba4>
80009be2:	fe c2 bb ce 	sub	r2,pc,-17458
80009be6:	31 00       	mov	r0,16
80009be8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bf0:	fe ca bb dc 	sub	r10,pc,-17444
80009bf4:	59 06       	cp.w	r6,16
80009bf6:	fe 99 ff dd 	brgt	80009bb0 <_vfprintf_r+0x1b6c>
80009bfa:	0c 09       	add	r9,r6
80009bfc:	2f f8       	sub	r8,-1
80009bfe:	87 0a       	st.w	r3[0x0],r10
80009c00:	fb 49 06 90 	st.w	sp[1680],r9
80009c04:	87 16       	st.w	r3[0x4],r6
80009c06:	fb 48 06 8c 	st.w	sp[1676],r8
80009c0a:	58 78       	cp.w	r8,7
80009c0c:	e0 89 00 04 	brgt	80009c14 <_vfprintf_r+0x1bd0>
80009c10:	2f 83       	sub	r3,-8
80009c12:	c0 b8       	rjmp	80009c28 <_vfprintf_r+0x1be4>
80009c14:	fa ca f9 78 	sub	r10,sp,-1672
80009c18:	02 9b       	mov	r11,r1
80009c1a:	08 9c       	mov	r12,r4
80009c1c:	fe b0 f2 06 	rcall	80008028 <__sprint_r>
80009c20:	e0 81 01 91 	brne	80009f42 <_vfprintf_r+0x1efe>
80009c24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c28:	ed b5 00 00 	bld	r5,0x0
80009c2c:	e0 81 01 20 	brne	80009e6c <_vfprintf_r+0x1e28>
80009c30:	40 c9       	lddsp	r9,sp[0x30]
80009c32:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c36:	2f f8       	sub	r8,-1
80009c38:	87 09       	st.w	r3[0x0],r9
80009c3a:	fb 48 06 90 	st.w	sp[1680],r8
80009c3e:	30 19       	mov	r9,1
80009c40:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c44:	87 19       	st.w	r3[0x4],r9
80009c46:	2f f8       	sub	r8,-1
80009c48:	fb 48 06 8c 	st.w	sp[1676],r8
80009c4c:	c0 29       	rjmp	80009e50 <_vfprintf_r+0x1e0c>
80009c4e:	14 09       	add	r9,r10
80009c50:	2f f8       	sub	r8,-1
80009c52:	fb 49 06 90 	st.w	sp[1680],r9
80009c56:	87 06       	st.w	r3[0x0],r6
80009c58:	87 1a       	st.w	r3[0x4],r10
80009c5a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c5e:	58 78       	cp.w	r8,7
80009c60:	e0 89 00 04 	brgt	80009c68 <_vfprintf_r+0x1c24>
80009c64:	2f 83       	sub	r3,-8
80009c66:	c0 b8       	rjmp	80009c7c <_vfprintf_r+0x1c38>
80009c68:	fa ca f9 78 	sub	r10,sp,-1672
80009c6c:	02 9b       	mov	r11,r1
80009c6e:	08 9c       	mov	r12,r4
80009c70:	fe b0 f1 dc 	rcall	80008028 <__sprint_r>
80009c74:	e0 81 01 67 	brne	80009f42 <_vfprintf_r+0x1efe>
80009c78:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c7c:	40 c8       	lddsp	r8,sp[0x30]
80009c7e:	87 08       	st.w	r3[0x0],r8
80009c80:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c84:	2f f8       	sub	r8,-1
80009c86:	30 19       	mov	r9,1
80009c88:	fb 48 06 90 	st.w	sp[1680],r8
80009c8c:	87 19       	st.w	r3[0x4],r9
80009c8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c92:	2f f8       	sub	r8,-1
80009c94:	fb 48 06 8c 	st.w	sp[1676],r8
80009c98:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c9c:	58 78       	cp.w	r8,7
80009c9e:	e0 89 00 04 	brgt	80009ca6 <_vfprintf_r+0x1c62>
80009ca2:	2f 83       	sub	r3,-8
80009ca4:	c0 b8       	rjmp	80009cba <_vfprintf_r+0x1c76>
80009ca6:	fa ca f9 78 	sub	r10,sp,-1672
80009caa:	02 9b       	mov	r11,r1
80009cac:	08 9c       	mov	r12,r4
80009cae:	fe b0 f1 bd 	rcall	80008028 <__sprint_r>
80009cb2:	e0 81 01 48 	brne	80009f42 <_vfprintf_r+0x1efe>
80009cb6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cba:	04 06       	add	r6,r2
80009cbc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009cc0:	87 06       	st.w	r3[0x0],r6
80009cc2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cc6:	40 66       	lddsp	r6,sp[0x18]
80009cc8:	40 6e       	lddsp	lr,sp[0x18]
80009cca:	10 16       	sub	r6,r8
80009ccc:	f2 08 01 08 	sub	r8,r9,r8
80009cd0:	87 16       	st.w	r3[0x4],r6
80009cd2:	1c 08       	add	r8,lr
80009cd4:	fb 48 06 90 	st.w	sp[1680],r8
80009cd8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cdc:	2f f8       	sub	r8,-1
80009cde:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce2:	cb 78       	rjmp	80009e50 <_vfprintf_r+0x1e0c>
80009ce4:	40 6c       	lddsp	r12,sp[0x18]
80009ce6:	58 1c       	cp.w	r12,1
80009ce8:	e0 89 00 06 	brgt	80009cf4 <_vfprintf_r+0x1cb0>
80009cec:	ed b5 00 00 	bld	r5,0x0
80009cf0:	e0 81 00 85 	brne	80009dfa <_vfprintf_r+0x1db6>
80009cf4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cf8:	2f f8       	sub	r8,-1
80009cfa:	30 19       	mov	r9,1
80009cfc:	fb 48 06 90 	st.w	sp[1680],r8
80009d00:	87 06       	st.w	r3[0x0],r6
80009d02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d06:	87 19       	st.w	r3[0x4],r9
80009d08:	2f f8       	sub	r8,-1
80009d0a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d0e:	58 78       	cp.w	r8,7
80009d10:	e0 89 00 04 	brgt	80009d18 <_vfprintf_r+0x1cd4>
80009d14:	2f 83       	sub	r3,-8
80009d16:	c0 b8       	rjmp	80009d2c <_vfprintf_r+0x1ce8>
80009d18:	fa ca f9 78 	sub	r10,sp,-1672
80009d1c:	02 9b       	mov	r11,r1
80009d1e:	08 9c       	mov	r12,r4
80009d20:	fe b0 f1 84 	rcall	80008028 <__sprint_r>
80009d24:	e0 81 01 0f 	brne	80009f42 <_vfprintf_r+0x1efe>
80009d28:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d30:	2f f8       	sub	r8,-1
80009d32:	40 cb       	lddsp	r11,sp[0x30]
80009d34:	fb 48 06 90 	st.w	sp[1680],r8
80009d38:	30 19       	mov	r9,1
80009d3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d3e:	87 0b       	st.w	r3[0x0],r11
80009d40:	2f f8       	sub	r8,-1
80009d42:	87 19       	st.w	r3[0x4],r9
80009d44:	fb 48 06 8c 	st.w	sp[1676],r8
80009d48:	58 78       	cp.w	r8,7
80009d4a:	e0 89 00 05 	brgt	80009d54 <_vfprintf_r+0x1d10>
80009d4e:	2f 83       	sub	r3,-8
80009d50:	c0 c8       	rjmp	80009d68 <_vfprintf_r+0x1d24>
80009d52:	d7 03       	nop
80009d54:	fa ca f9 78 	sub	r10,sp,-1672
80009d58:	02 9b       	mov	r11,r1
80009d5a:	08 9c       	mov	r12,r4
80009d5c:	fe b0 f1 66 	rcall	80008028 <__sprint_r>
80009d60:	e0 81 00 f1 	brne	80009f42 <_vfprintf_r+0x1efe>
80009d64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d68:	30 08       	mov	r8,0
80009d6a:	30 09       	mov	r9,0
80009d6c:	40 5b       	lddsp	r11,sp[0x14]
80009d6e:	40 7a       	lddsp	r10,sp[0x1c]
80009d70:	e0 a0 13 25 	rcall	8000c3ba <__avr32_f64_cmp_eq>
80009d74:	40 68       	lddsp	r8,sp[0x18]
80009d76:	20 18       	sub	r8,1
80009d78:	58 0c       	cp.w	r12,0
80009d7a:	c0 d1       	brne	80009d94 <_vfprintf_r+0x1d50>
80009d7c:	2f f6       	sub	r6,-1
80009d7e:	87 18       	st.w	r3[0x4],r8
80009d80:	87 06       	st.w	r3[0x0],r6
80009d82:	fa f6 06 90 	ld.w	r6,sp[1680]
80009d86:	10 06       	add	r6,r8
80009d88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d8c:	fb 46 06 90 	st.w	sp[1680],r6
80009d90:	2f f8       	sub	r8,-1
80009d92:	c3 18       	rjmp	80009df4 <_vfprintf_r+0x1db0>
80009d94:	10 96       	mov	r6,r8
80009d96:	58 08       	cp.w	r8,0
80009d98:	e0 89 00 1c 	brgt	80009dd0 <_vfprintf_r+0x1d8c>
80009d9c:	c4 b8       	rjmp	80009e32 <_vfprintf_r+0x1dee>
80009d9e:	2f 09       	sub	r9,-16
80009da0:	2f f8       	sub	r8,-1
80009da2:	fb 49 06 90 	st.w	sp[1680],r9
80009da6:	87 02       	st.w	r3[0x0],r2
80009da8:	87 10       	st.w	r3[0x4],r0
80009daa:	fb 48 06 8c 	st.w	sp[1676],r8
80009dae:	58 78       	cp.w	r8,7
80009db0:	e0 89 00 04 	brgt	80009db8 <_vfprintf_r+0x1d74>
80009db4:	2f 83       	sub	r3,-8
80009db6:	c0 b8       	rjmp	80009dcc <_vfprintf_r+0x1d88>
80009db8:	fa ca f9 78 	sub	r10,sp,-1672
80009dbc:	02 9b       	mov	r11,r1
80009dbe:	08 9c       	mov	r12,r4
80009dc0:	fe b0 f1 34 	rcall	80008028 <__sprint_r>
80009dc4:	e0 81 00 bf 	brne	80009f42 <_vfprintf_r+0x1efe>
80009dc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dcc:	21 06       	sub	r6,16
80009dce:	c0 48       	rjmp	80009dd6 <_vfprintf_r+0x1d92>
80009dd0:	fe c2 bd bc 	sub	r2,pc,-16964
80009dd4:	31 00       	mov	r0,16
80009dd6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009dda:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dde:	fe ca bd ca 	sub	r10,pc,-16950
80009de2:	59 06       	cp.w	r6,16
80009de4:	fe 99 ff dd 	brgt	80009d9e <_vfprintf_r+0x1d5a>
80009de8:	0c 09       	add	r9,r6
80009dea:	87 0a       	st.w	r3[0x0],r10
80009dec:	fb 49 06 90 	st.w	sp[1680],r9
80009df0:	2f f8       	sub	r8,-1
80009df2:	87 16       	st.w	r3[0x4],r6
80009df4:	fb 48 06 8c 	st.w	sp[1676],r8
80009df8:	c0 e8       	rjmp	80009e14 <_vfprintf_r+0x1dd0>
80009dfa:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dfe:	2f f8       	sub	r8,-1
80009e00:	30 19       	mov	r9,1
80009e02:	fb 48 06 90 	st.w	sp[1680],r8
80009e06:	87 06       	st.w	r3[0x0],r6
80009e08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e0c:	87 19       	st.w	r3[0x4],r9
80009e0e:	2f f8       	sub	r8,-1
80009e10:	fb 48 06 8c 	st.w	sp[1676],r8
80009e14:	58 78       	cp.w	r8,7
80009e16:	e0 89 00 04 	brgt	80009e1e <_vfprintf_r+0x1dda>
80009e1a:	2f 83       	sub	r3,-8
80009e1c:	c0 b8       	rjmp	80009e32 <_vfprintf_r+0x1dee>
80009e1e:	fa ca f9 78 	sub	r10,sp,-1672
80009e22:	02 9b       	mov	r11,r1
80009e24:	08 9c       	mov	r12,r4
80009e26:	fe b0 f1 01 	rcall	80008028 <__sprint_r>
80009e2a:	e0 81 00 8c 	brne	80009f42 <_vfprintf_r+0x1efe>
80009e2e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e32:	40 ea       	lddsp	r10,sp[0x38]
80009e34:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e38:	14 08       	add	r8,r10
80009e3a:	fa c9 f9 64 	sub	r9,sp,-1692
80009e3e:	fb 48 06 90 	st.w	sp[1680],r8
80009e42:	87 1a       	st.w	r3[0x4],r10
80009e44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e48:	87 09       	st.w	r3[0x0],r9
80009e4a:	2f f8       	sub	r8,-1
80009e4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e50:	58 78       	cp.w	r8,7
80009e52:	e0 89 00 04 	brgt	80009e5a <_vfprintf_r+0x1e16>
80009e56:	2f 83       	sub	r3,-8
80009e58:	c0 a8       	rjmp	80009e6c <_vfprintf_r+0x1e28>
80009e5a:	fa ca f9 78 	sub	r10,sp,-1672
80009e5e:	02 9b       	mov	r11,r1
80009e60:	08 9c       	mov	r12,r4
80009e62:	fe b0 f0 e3 	rcall	80008028 <__sprint_r>
80009e66:	c6 e1       	brne	80009f42 <_vfprintf_r+0x1efe>
80009e68:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e6c:	e2 15 00 04 	andl	r5,0x4,COH
80009e70:	c3 f0       	breq	80009eee <_vfprintf_r+0x1eaa>
80009e72:	40 86       	lddsp	r6,sp[0x20]
80009e74:	40 39       	lddsp	r9,sp[0xc]
80009e76:	12 16       	sub	r6,r9
80009e78:	58 06       	cp.w	r6,0
80009e7a:	e0 89 00 1a 	brgt	80009eae <_vfprintf_r+0x1e6a>
80009e7e:	c3 88       	rjmp	80009eee <_vfprintf_r+0x1eaa>
80009e80:	2f 09       	sub	r9,-16
80009e82:	2f f8       	sub	r8,-1
80009e84:	fb 49 06 90 	st.w	sp[1680],r9
80009e88:	87 05       	st.w	r3[0x0],r5
80009e8a:	87 12       	st.w	r3[0x4],r2
80009e8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e90:	58 78       	cp.w	r8,7
80009e92:	e0 89 00 04 	brgt	80009e9a <_vfprintf_r+0x1e56>
80009e96:	2f 83       	sub	r3,-8
80009e98:	c0 98       	rjmp	80009eaa <_vfprintf_r+0x1e66>
80009e9a:	00 9a       	mov	r10,r0
80009e9c:	02 9b       	mov	r11,r1
80009e9e:	08 9c       	mov	r12,r4
80009ea0:	fe b0 f0 c4 	rcall	80008028 <__sprint_r>
80009ea4:	c4 f1       	brne	80009f42 <_vfprintf_r+0x1efe>
80009ea6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eaa:	21 06       	sub	r6,16
80009eac:	c0 68       	rjmp	80009eb8 <_vfprintf_r+0x1e74>
80009eae:	fe c5 be aa 	sub	r5,pc,-16726
80009eb2:	31 02       	mov	r2,16
80009eb4:	fa c0 f9 78 	sub	r0,sp,-1672
80009eb8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ebc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ec0:	fe ca be bc 	sub	r10,pc,-16708
80009ec4:	59 06       	cp.w	r6,16
80009ec6:	fe 99 ff dd 	brgt	80009e80 <_vfprintf_r+0x1e3c>
80009eca:	0c 09       	add	r9,r6
80009ecc:	2f f8       	sub	r8,-1
80009ece:	87 0a       	st.w	r3[0x0],r10
80009ed0:	87 16       	st.w	r3[0x4],r6
80009ed2:	fb 49 06 90 	st.w	sp[1680],r9
80009ed6:	fb 48 06 8c 	st.w	sp[1676],r8
80009eda:	58 78       	cp.w	r8,7
80009edc:	e0 8a 00 09 	brle	80009eee <_vfprintf_r+0x1eaa>
80009ee0:	fa ca f9 78 	sub	r10,sp,-1672
80009ee4:	02 9b       	mov	r11,r1
80009ee6:	08 9c       	mov	r12,r4
80009ee8:	fe b0 f0 a0 	rcall	80008028 <__sprint_r>
80009eec:	c2 b1       	brne	80009f42 <_vfprintf_r+0x1efe>
80009eee:	40 bc       	lddsp	r12,sp[0x2c]
80009ef0:	40 36       	lddsp	r6,sp[0xc]
80009ef2:	40 8e       	lddsp	lr,sp[0x20]
80009ef4:	ec 0e 0c 48 	max	r8,r6,lr
80009ef8:	10 0c       	add	r12,r8
80009efa:	50 bc       	stdsp	sp[0x2c],r12
80009efc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f00:	58 08       	cp.w	r8,0
80009f02:	c0 80       	breq	80009f12 <_vfprintf_r+0x1ece>
80009f04:	fa ca f9 78 	sub	r10,sp,-1672
80009f08:	02 9b       	mov	r11,r1
80009f0a:	08 9c       	mov	r12,r4
80009f0c:	fe b0 f0 8e 	rcall	80008028 <__sprint_r>
80009f10:	c1 91       	brne	80009f42 <_vfprintf_r+0x1efe>
80009f12:	30 0b       	mov	r11,0
80009f14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f18:	fb 4b 06 8c 	st.w	sp[1676],r11
80009f1c:	fe 9f f1 22 	bral	80008160 <_vfprintf_r+0x11c>
80009f20:	08 95       	mov	r5,r4
80009f22:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f26:	58 08       	cp.w	r8,0
80009f28:	c0 80       	breq	80009f38 <_vfprintf_r+0x1ef4>
80009f2a:	08 9c       	mov	r12,r4
80009f2c:	fa ca f9 78 	sub	r10,sp,-1672
80009f30:	02 9b       	mov	r11,r1
80009f32:	fe b0 f0 7b 	rcall	80008028 <__sprint_r>
80009f36:	c0 61       	brne	80009f42 <_vfprintf_r+0x1efe>
80009f38:	30 08       	mov	r8,0
80009f3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009f3e:	c0 28       	rjmp	80009f42 <_vfprintf_r+0x1efe>
80009f40:	40 41       	lddsp	r1,sp[0x10]
80009f42:	82 68       	ld.sh	r8,r1[0xc]
80009f44:	ed b8 00 06 	bld	r8,0x6
80009f48:	c0 31       	brne	80009f4e <_vfprintf_r+0x1f0a>
80009f4a:	3f fa       	mov	r10,-1
80009f4c:	50 ba       	stdsp	sp[0x2c],r10
80009f4e:	40 bc       	lddsp	r12,sp[0x2c]
80009f50:	fe 3d f9 44 	sub	sp,-1724
80009f54:	d8 32       	popm	r0-r7,pc
80009f56:	d7 03       	nop

80009f58 <__swsetup_r>:
80009f58:	d4 21       	pushm	r4-r7,lr
80009f5a:	e0 68 0a 3c 	mov	r8,2620
80009f5e:	18 96       	mov	r6,r12
80009f60:	16 97       	mov	r7,r11
80009f62:	70 0c       	ld.w	r12,r8[0x0]
80009f64:	58 0c       	cp.w	r12,0
80009f66:	c0 60       	breq	80009f72 <__swsetup_r+0x1a>
80009f68:	78 68       	ld.w	r8,r12[0x18]
80009f6a:	58 08       	cp.w	r8,0
80009f6c:	c0 31       	brne	80009f72 <__swsetup_r+0x1a>
80009f6e:	e0 a0 07 bf 	rcall	8000aeec <__sinit>
80009f72:	fe c8 be 3e 	sub	r8,pc,-16834
80009f76:	10 37       	cp.w	r7,r8
80009f78:	c0 61       	brne	80009f84 <__swsetup_r+0x2c>
80009f7a:	e0 68 0a 3c 	mov	r8,2620
80009f7e:	70 08       	ld.w	r8,r8[0x0]
80009f80:	70 07       	ld.w	r7,r8[0x0]
80009f82:	c1 28       	rjmp	80009fa6 <__swsetup_r+0x4e>
80009f84:	fe c8 be 30 	sub	r8,pc,-16848
80009f88:	10 37       	cp.w	r7,r8
80009f8a:	c0 61       	brne	80009f96 <__swsetup_r+0x3e>
80009f8c:	e0 68 0a 3c 	mov	r8,2620
80009f90:	70 08       	ld.w	r8,r8[0x0]
80009f92:	70 17       	ld.w	r7,r8[0x4]
80009f94:	c0 98       	rjmp	80009fa6 <__swsetup_r+0x4e>
80009f96:	fe c8 be 22 	sub	r8,pc,-16862
80009f9a:	10 37       	cp.w	r7,r8
80009f9c:	c0 51       	brne	80009fa6 <__swsetup_r+0x4e>
80009f9e:	e0 68 0a 3c 	mov	r8,2620
80009fa2:	70 08       	ld.w	r8,r8[0x0]
80009fa4:	70 27       	ld.w	r7,r8[0x8]
80009fa6:	8e 68       	ld.sh	r8,r7[0xc]
80009fa8:	ed b8 00 03 	bld	r8,0x3
80009fac:	c1 e0       	breq	80009fe8 <__swsetup_r+0x90>
80009fae:	ed b8 00 04 	bld	r8,0x4
80009fb2:	c3 e1       	brne	8000a02e <__swsetup_r+0xd6>
80009fb4:	ed b8 00 02 	bld	r8,0x2
80009fb8:	c1 51       	brne	80009fe2 <__swsetup_r+0x8a>
80009fba:	6e db       	ld.w	r11,r7[0x34]
80009fbc:	58 0b       	cp.w	r11,0
80009fbe:	c0 a0       	breq	80009fd2 <__swsetup_r+0x7a>
80009fc0:	ee c8 ff bc 	sub	r8,r7,-68
80009fc4:	10 3b       	cp.w	r11,r8
80009fc6:	c0 40       	breq	80009fce <__swsetup_r+0x76>
80009fc8:	0c 9c       	mov	r12,r6
80009fca:	e0 a0 08 2b 	rcall	8000b020 <_free_r>
80009fce:	30 08       	mov	r8,0
80009fd0:	8f d8       	st.w	r7[0x34],r8
80009fd2:	8e 68       	ld.sh	r8,r7[0xc]
80009fd4:	e0 18 ff db 	andl	r8,0xffdb
80009fd8:	ae 68       	st.h	r7[0xc],r8
80009fda:	30 08       	mov	r8,0
80009fdc:	8f 18       	st.w	r7[0x4],r8
80009fde:	6e 48       	ld.w	r8,r7[0x10]
80009fe0:	8f 08       	st.w	r7[0x0],r8
80009fe2:	8e 68       	ld.sh	r8,r7[0xc]
80009fe4:	a3 b8       	sbr	r8,0x3
80009fe6:	ae 68       	st.h	r7[0xc],r8
80009fe8:	6e 48       	ld.w	r8,r7[0x10]
80009fea:	58 08       	cp.w	r8,0
80009fec:	c0 b1       	brne	8000a002 <__swsetup_r+0xaa>
80009fee:	8e 68       	ld.sh	r8,r7[0xc]
80009ff0:	e2 18 02 80 	andl	r8,0x280,COH
80009ff4:	e0 48 02 00 	cp.w	r8,512
80009ff8:	c0 50       	breq	8000a002 <__swsetup_r+0xaa>
80009ffa:	0c 9c       	mov	r12,r6
80009ffc:	0e 9b       	mov	r11,r7
80009ffe:	e0 a0 0a 4b 	rcall	8000b494 <__smakebuf_r>
8000a002:	8e 69       	ld.sh	r9,r7[0xc]
8000a004:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a008:	c0 70       	breq	8000a016 <__swsetup_r+0xbe>
8000a00a:	30 08       	mov	r8,0
8000a00c:	8f 28       	st.w	r7[0x8],r8
8000a00e:	6e 58       	ld.w	r8,r7[0x14]
8000a010:	5c 38       	neg	r8
8000a012:	8f 68       	st.w	r7[0x18],r8
8000a014:	c0 68       	rjmp	8000a020 <__swsetup_r+0xc8>
8000a016:	ed b9 00 01 	bld	r9,0x1
8000a01a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a01e:	8f 28       	st.w	r7[0x8],r8
8000a020:	6e 48       	ld.w	r8,r7[0x10]
8000a022:	58 08       	cp.w	r8,0
8000a024:	c0 61       	brne	8000a030 <__swsetup_r+0xd8>
8000a026:	8e 68       	ld.sh	r8,r7[0xc]
8000a028:	ed b8 00 07 	bld	r8,0x7
8000a02c:	c0 21       	brne	8000a030 <__swsetup_r+0xd8>
8000a02e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a030:	d8 2a       	popm	r4-r7,pc,r12=0
8000a032:	d7 03       	nop

8000a034 <quorem>:
8000a034:	d4 31       	pushm	r0-r7,lr
8000a036:	20 2d       	sub	sp,8
8000a038:	18 97       	mov	r7,r12
8000a03a:	78 48       	ld.w	r8,r12[0x10]
8000a03c:	76 46       	ld.w	r6,r11[0x10]
8000a03e:	0c 38       	cp.w	r8,r6
8000a040:	c0 34       	brge	8000a046 <quorem+0x12>
8000a042:	30 0c       	mov	r12,0
8000a044:	c8 58       	rjmp	8000a14e <quorem+0x11a>
8000a046:	ec c2 ff fc 	sub	r2,r6,-4
8000a04a:	f6 c3 ff ec 	sub	r3,r11,-20
8000a04e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a052:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a056:	2f f9       	sub	r9,-1
8000a058:	20 16       	sub	r6,1
8000a05a:	f8 09 0d 08 	divu	r8,r12,r9
8000a05e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a062:	ee c4 ff ec 	sub	r4,r7,-20
8000a066:	10 95       	mov	r5,r8
8000a068:	58 08       	cp.w	r8,0
8000a06a:	c4 10       	breq	8000a0ec <quorem+0xb8>
8000a06c:	30 09       	mov	r9,0
8000a06e:	06 9a       	mov	r10,r3
8000a070:	08 98       	mov	r8,r4
8000a072:	12 91       	mov	r1,r9
8000a074:	50 0b       	stdsp	sp[0x0],r11
8000a076:	70 0e       	ld.w	lr,r8[0x0]
8000a078:	b1 8e       	lsr	lr,0x10
8000a07a:	50 1e       	stdsp	sp[0x4],lr
8000a07c:	15 0e       	ld.w	lr,r10++
8000a07e:	fc 00 16 10 	lsr	r0,lr,0x10
8000a082:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a086:	ea 0e 03 41 	mac	r1,r5,lr
8000a08a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a08e:	b1 81       	lsr	r1,0x10
8000a090:	40 1b       	lddsp	r11,sp[0x4]
8000a092:	ea 00 02 40 	mul	r0,r5,r0
8000a096:	e2 00 00 00 	add	r0,r1,r0
8000a09a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a09e:	02 1b       	sub	r11,r1
8000a0a0:	50 1b       	stdsp	sp[0x4],r11
8000a0a2:	70 0b       	ld.w	r11,r8[0x0]
8000a0a4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a0a8:	02 09       	add	r9,r1
8000a0aa:	f2 0e 01 0e 	sub	lr,r9,lr
8000a0ae:	b0 1e       	st.h	r8[0x2],lr
8000a0b0:	fc 09 14 10 	asr	r9,lr,0x10
8000a0b4:	40 1e       	lddsp	lr,sp[0x4]
8000a0b6:	fc 09 00 09 	add	r9,lr,r9
8000a0ba:	b0 09       	st.h	r8[0x0],r9
8000a0bc:	e0 01 16 10 	lsr	r1,r0,0x10
8000a0c0:	2f c8       	sub	r8,-4
8000a0c2:	b1 49       	asr	r9,0x10
8000a0c4:	04 3a       	cp.w	r10,r2
8000a0c6:	fe 98 ff d8 	brls	8000a076 <quorem+0x42>
8000a0ca:	40 0b       	lddsp	r11,sp[0x0]
8000a0cc:	58 0c       	cp.w	r12,0
8000a0ce:	c0 f1       	brne	8000a0ec <quorem+0xb8>
8000a0d0:	ec c8 ff fb 	sub	r8,r6,-5
8000a0d4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a0d8:	c0 28       	rjmp	8000a0dc <quorem+0xa8>
8000a0da:	20 16       	sub	r6,1
8000a0dc:	20 48       	sub	r8,4
8000a0de:	08 38       	cp.w	r8,r4
8000a0e0:	e0 88 00 05 	brls	8000a0ea <quorem+0xb6>
8000a0e4:	70 09       	ld.w	r9,r8[0x0]
8000a0e6:	58 09       	cp.w	r9,0
8000a0e8:	cf 90       	breq	8000a0da <quorem+0xa6>
8000a0ea:	8f 46       	st.w	r7[0x10],r6
8000a0ec:	0e 9c       	mov	r12,r7
8000a0ee:	e0 a0 0a d2 	rcall	8000b692 <__mcmp>
8000a0f2:	c2 d5       	brlt	8000a14c <quorem+0x118>
8000a0f4:	2f f5       	sub	r5,-1
8000a0f6:	08 98       	mov	r8,r4
8000a0f8:	30 09       	mov	r9,0
8000a0fa:	07 0b       	ld.w	r11,r3++
8000a0fc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a100:	70 0c       	ld.w	r12,r8[0x0]
8000a102:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a106:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a10a:	14 1e       	sub	lr,r10
8000a10c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a110:	16 1a       	sub	r10,r11
8000a112:	12 0a       	add	r10,r9
8000a114:	b0 1a       	st.h	r8[0x2],r10
8000a116:	b1 4a       	asr	r10,0x10
8000a118:	fc 0a 00 09 	add	r9,lr,r10
8000a11c:	b0 09       	st.h	r8[0x0],r9
8000a11e:	2f c8       	sub	r8,-4
8000a120:	b1 49       	asr	r9,0x10
8000a122:	04 33       	cp.w	r3,r2
8000a124:	fe 98 ff eb 	brls	8000a0fa <quorem+0xc6>
8000a128:	ec c8 ff fb 	sub	r8,r6,-5
8000a12c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a130:	58 09       	cp.w	r9,0
8000a132:	c0 d1       	brne	8000a14c <quorem+0x118>
8000a134:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a138:	c0 28       	rjmp	8000a13c <quorem+0x108>
8000a13a:	20 16       	sub	r6,1
8000a13c:	20 48       	sub	r8,4
8000a13e:	08 38       	cp.w	r8,r4
8000a140:	e0 88 00 05 	brls	8000a14a <quorem+0x116>
8000a144:	70 09       	ld.w	r9,r8[0x0]
8000a146:	58 09       	cp.w	r9,0
8000a148:	cf 90       	breq	8000a13a <quorem+0x106>
8000a14a:	8f 46       	st.w	r7[0x10],r6
8000a14c:	0a 9c       	mov	r12,r5
8000a14e:	2f ed       	sub	sp,-8
8000a150:	d8 32       	popm	r0-r7,pc
8000a152:	d7 03       	nop

8000a154 <_dtoa_r>:
8000a154:	d4 31       	pushm	r0-r7,lr
8000a156:	21 ad       	sub	sp,104
8000a158:	fa c4 ff 74 	sub	r4,sp,-140
8000a15c:	18 97       	mov	r7,r12
8000a15e:	16 95       	mov	r5,r11
8000a160:	68 2c       	ld.w	r12,r4[0x8]
8000a162:	50 c9       	stdsp	sp[0x30],r9
8000a164:	68 16       	ld.w	r6,r4[0x4]
8000a166:	68 09       	ld.w	r9,r4[0x0]
8000a168:	50 e8       	stdsp	sp[0x38],r8
8000a16a:	14 94       	mov	r4,r10
8000a16c:	51 2c       	stdsp	sp[0x48],r12
8000a16e:	fa e5 00 08 	st.d	sp[8],r4
8000a172:	51 59       	stdsp	sp[0x54],r9
8000a174:	6e 95       	ld.w	r5,r7[0x24]
8000a176:	58 05       	cp.w	r5,0
8000a178:	c0 91       	brne	8000a18a <_dtoa_r+0x36>
8000a17a:	31 0c       	mov	r12,16
8000a17c:	fe b0 e8 f4 	rcall	80007364 <malloc>
8000a180:	99 35       	st.w	r12[0xc],r5
8000a182:	8f 9c       	st.w	r7[0x24],r12
8000a184:	99 15       	st.w	r12[0x4],r5
8000a186:	99 25       	st.w	r12[0x8],r5
8000a188:	99 05       	st.w	r12[0x0],r5
8000a18a:	6e 99       	ld.w	r9,r7[0x24]
8000a18c:	72 08       	ld.w	r8,r9[0x0]
8000a18e:	58 08       	cp.w	r8,0
8000a190:	c0 f0       	breq	8000a1ae <_dtoa_r+0x5a>
8000a192:	72 1a       	ld.w	r10,r9[0x4]
8000a194:	91 1a       	st.w	r8[0x4],r10
8000a196:	30 1a       	mov	r10,1
8000a198:	72 19       	ld.w	r9,r9[0x4]
8000a19a:	f4 09 09 49 	lsl	r9,r10,r9
8000a19e:	10 9b       	mov	r11,r8
8000a1a0:	91 29       	st.w	r8[0x8],r9
8000a1a2:	0e 9c       	mov	r12,r7
8000a1a4:	e0 a0 0a 90 	rcall	8000b6c4 <_Bfree>
8000a1a8:	6e 98       	ld.w	r8,r7[0x24]
8000a1aa:	30 09       	mov	r9,0
8000a1ac:	91 09       	st.w	r8[0x0],r9
8000a1ae:	40 28       	lddsp	r8,sp[0x8]
8000a1b0:	10 94       	mov	r4,r8
8000a1b2:	58 08       	cp.w	r8,0
8000a1b4:	c0 64       	brge	8000a1c0 <_dtoa_r+0x6c>
8000a1b6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a1ba:	50 28       	stdsp	sp[0x8],r8
8000a1bc:	30 18       	mov	r8,1
8000a1be:	c0 28       	rjmp	8000a1c2 <_dtoa_r+0x6e>
8000a1c0:	30 08       	mov	r8,0
8000a1c2:	8d 08       	st.w	r6[0x0],r8
8000a1c4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a1c8:	40 26       	lddsp	r6,sp[0x8]
8000a1ca:	0c 98       	mov	r8,r6
8000a1cc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a1d0:	18 38       	cp.w	r8,r12
8000a1d2:	c2 01       	brne	8000a212 <_dtoa_r+0xbe>
8000a1d4:	e0 68 27 0f 	mov	r8,9999
8000a1d8:	41 5b       	lddsp	r11,sp[0x54]
8000a1da:	97 08       	st.w	r11[0x0],r8
8000a1dc:	40 3a       	lddsp	r10,sp[0xc]
8000a1de:	58 0a       	cp.w	r10,0
8000a1e0:	c0 71       	brne	8000a1ee <_dtoa_r+0x9a>
8000a1e2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a1e6:	c0 41       	brne	8000a1ee <_dtoa_r+0x9a>
8000a1e8:	fe cc c0 c4 	sub	r12,pc,-16188
8000a1ec:	c0 38       	rjmp	8000a1f2 <_dtoa_r+0x9e>
8000a1ee:	fe cc c0 be 	sub	r12,pc,-16194
8000a1f2:	41 29       	lddsp	r9,sp[0x48]
8000a1f4:	58 09       	cp.w	r9,0
8000a1f6:	e0 80 05 9a 	breq	8000ad2a <_dtoa_r+0xbd6>
8000a1fa:	f8 c8 ff fd 	sub	r8,r12,-3
8000a1fe:	f8 c9 ff f8 	sub	r9,r12,-8
8000a202:	11 8b       	ld.ub	r11,r8[0x0]
8000a204:	30 0a       	mov	r10,0
8000a206:	41 25       	lddsp	r5,sp[0x48]
8000a208:	f4 0b 18 00 	cp.b	r11,r10
8000a20c:	f2 08 17 10 	movne	r8,r9
8000a210:	c1 68       	rjmp	8000a23c <_dtoa_r+0xe8>
8000a212:	fa ea 00 08 	ld.d	r10,sp[8]
8000a216:	30 08       	mov	r8,0
8000a218:	fa eb 00 3c 	st.d	sp[60],r10
8000a21c:	30 09       	mov	r9,0
8000a21e:	e0 a0 10 ce 	rcall	8000c3ba <__avr32_f64_cmp_eq>
8000a222:	c1 00       	breq	8000a242 <_dtoa_r+0xee>
8000a224:	30 18       	mov	r8,1
8000a226:	41 5a       	lddsp	r10,sp[0x54]
8000a228:	95 08       	st.w	r10[0x0],r8
8000a22a:	fe cc c2 2a 	sub	r12,pc,-15830
8000a22e:	41 29       	lddsp	r9,sp[0x48]
8000a230:	f8 08 00 08 	add	r8,r12,r8
8000a234:	58 09       	cp.w	r9,0
8000a236:	e0 80 05 7a 	breq	8000ad2a <_dtoa_r+0xbd6>
8000a23a:	12 95       	mov	r5,r9
8000a23c:	8b 08       	st.w	r5[0x0],r8
8000a23e:	e0 8f 05 76 	bral	8000ad2a <_dtoa_r+0xbd6>
8000a242:	fa c8 ff 9c 	sub	r8,sp,-100
8000a246:	fa c9 ff a0 	sub	r9,sp,-96
8000a24a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a24e:	0e 9c       	mov	r12,r7
8000a250:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a254:	e0 a0 0a 8a 	rcall	8000b768 <__d2b>
8000a258:	18 93       	mov	r3,r12
8000a25a:	58 05       	cp.w	r5,0
8000a25c:	c0 d0       	breq	8000a276 <_dtoa_r+0x122>
8000a25e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a262:	30 04       	mov	r4,0
8000a264:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a268:	ea c5 03 ff 	sub	r5,r5,1023
8000a26c:	10 9b       	mov	r11,r8
8000a26e:	51 74       	stdsp	sp[0x5c],r4
8000a270:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a274:	c2 58       	rjmp	8000a2be <_dtoa_r+0x16a>
8000a276:	41 88       	lddsp	r8,sp[0x60]
8000a278:	41 9c       	lddsp	r12,sp[0x64]
8000a27a:	10 0c       	add	r12,r8
8000a27c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a280:	e0 45 00 20 	cp.w	r5,32
8000a284:	e0 8a 00 0e 	brle	8000a2a0 <_dtoa_r+0x14c>
8000a288:	f8 cc fb ee 	sub	r12,r12,-1042
8000a28c:	40 3b       	lddsp	r11,sp[0xc]
8000a28e:	ea 08 11 40 	rsub	r8,r5,64
8000a292:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a296:	ec 08 09 46 	lsl	r6,r6,r8
8000a29a:	0c 4c       	or	r12,r6
8000a29c:	c0 78       	rjmp	8000a2aa <_dtoa_r+0x156>
8000a29e:	d7 03       	nop
8000a2a0:	ea 0c 11 20 	rsub	r12,r5,32
8000a2a4:	40 3a       	lddsp	r10,sp[0xc]
8000a2a6:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a2aa:	e0 a0 10 14 	rcall	8000c2d2 <__avr32_u32_to_f64>
8000a2ae:	fc 18 fe 10 	movh	r8,0xfe10
8000a2b2:	30 19       	mov	r9,1
8000a2b4:	ea c5 04 33 	sub	r5,r5,1075
8000a2b8:	f0 0b 00 0b 	add	r11,r8,r11
8000a2bc:	51 79       	stdsp	sp[0x5c],r9
8000a2be:	30 08       	mov	r8,0
8000a2c0:	fc 19 3f f8 	movh	r9,0x3ff8
8000a2c4:	e0 a0 0e 9c 	rcall	8000bffc <__avr32_f64_sub>
8000a2c8:	e0 68 43 61 	mov	r8,17249
8000a2cc:	ea 18 63 6f 	orh	r8,0x636f
8000a2d0:	e0 69 87 a7 	mov	r9,34727
8000a2d4:	ea 19 3f d2 	orh	r9,0x3fd2
8000a2d8:	e0 a0 0d a6 	rcall	8000be24 <__avr32_f64_mul>
8000a2dc:	e0 68 c8 b3 	mov	r8,51379
8000a2e0:	ea 18 8b 60 	orh	r8,0x8b60
8000a2e4:	e0 69 8a 28 	mov	r9,35368
8000a2e8:	ea 19 3f c6 	orh	r9,0x3fc6
8000a2ec:	e0 a0 0f 56 	rcall	8000c198 <__avr32_f64_add>
8000a2f0:	0a 9c       	mov	r12,r5
8000a2f2:	14 90       	mov	r0,r10
8000a2f4:	16 91       	mov	r1,r11
8000a2f6:	e0 a0 0f f2 	rcall	8000c2da <__avr32_s32_to_f64>
8000a2fa:	e0 68 79 fb 	mov	r8,31227
8000a2fe:	ea 18 50 9f 	orh	r8,0x509f
8000a302:	e0 69 44 13 	mov	r9,17427
8000a306:	ea 19 3f d3 	orh	r9,0x3fd3
8000a30a:	e0 a0 0d 8d 	rcall	8000be24 <__avr32_f64_mul>
8000a30e:	14 98       	mov	r8,r10
8000a310:	16 99       	mov	r9,r11
8000a312:	00 9a       	mov	r10,r0
8000a314:	02 9b       	mov	r11,r1
8000a316:	e0 a0 0f 41 	rcall	8000c198 <__avr32_f64_add>
8000a31a:	14 90       	mov	r0,r10
8000a31c:	16 91       	mov	r1,r11
8000a31e:	e0 a0 0f c7 	rcall	8000c2ac <__avr32_f64_to_s32>
8000a322:	30 08       	mov	r8,0
8000a324:	18 96       	mov	r6,r12
8000a326:	30 09       	mov	r9,0
8000a328:	00 9a       	mov	r10,r0
8000a32a:	02 9b       	mov	r11,r1
8000a32c:	e0 a0 10 8e 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a330:	c0 c0       	breq	8000a348 <_dtoa_r+0x1f4>
8000a332:	0c 9c       	mov	r12,r6
8000a334:	e0 a0 0f d3 	rcall	8000c2da <__avr32_s32_to_f64>
8000a338:	14 98       	mov	r8,r10
8000a33a:	16 99       	mov	r9,r11
8000a33c:	00 9a       	mov	r10,r0
8000a33e:	02 9b       	mov	r11,r1
8000a340:	e0 a0 10 3d 	rcall	8000c3ba <__avr32_f64_cmp_eq>
8000a344:	f7 b6 00 01 	subeq	r6,1
8000a348:	59 66       	cp.w	r6,22
8000a34a:	e0 88 00 05 	brls	8000a354 <_dtoa_r+0x200>
8000a34e:	30 18       	mov	r8,1
8000a350:	51 48       	stdsp	sp[0x50],r8
8000a352:	c1 38       	rjmp	8000a378 <_dtoa_r+0x224>
8000a354:	fe c8 c1 70 	sub	r8,pc,-16016
8000a358:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a35c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a360:	e0 a0 10 74 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a364:	f9 b4 00 00 	moveq	r4,0
8000a368:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a36c:	f7 b6 01 01 	subne	r6,1
8000a370:	f9 bc 01 00 	movne	r12,0
8000a374:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a378:	41 90       	lddsp	r0,sp[0x64]
8000a37a:	20 10       	sub	r0,1
8000a37c:	0a 10       	sub	r0,r5
8000a37e:	c0 46       	brmi	8000a386 <_dtoa_r+0x232>
8000a380:	50 40       	stdsp	sp[0x10],r0
8000a382:	30 00       	mov	r0,0
8000a384:	c0 48       	rjmp	8000a38c <_dtoa_r+0x238>
8000a386:	30 0b       	mov	r11,0
8000a388:	5c 30       	neg	r0
8000a38a:	50 4b       	stdsp	sp[0x10],r11
8000a38c:	ec 02 11 00 	rsub	r2,r6,0
8000a390:	58 06       	cp.w	r6,0
8000a392:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a396:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a39a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a39e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a3a2:	f9 b2 04 00 	movge	r2,0
8000a3a6:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a3aa:	f9 b9 05 00 	movlt	r9,0
8000a3ae:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a3b2:	40 c8       	lddsp	r8,sp[0x30]
8000a3b4:	58 98       	cp.w	r8,9
8000a3b6:	e0 8b 00 20 	brhi	8000a3f6 <_dtoa_r+0x2a2>
8000a3ba:	58 58       	cp.w	r8,5
8000a3bc:	f9 b4 0a 01 	movle	r4,1
8000a3c0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a3c4:	f7 b5 09 04 	subgt	r5,4
8000a3c8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a3cc:	f9 b4 09 00 	movgt	r4,0
8000a3d0:	40 cc       	lddsp	r12,sp[0x30]
8000a3d2:	58 3c       	cp.w	r12,3
8000a3d4:	c2 d0       	breq	8000a42e <_dtoa_r+0x2da>
8000a3d6:	e0 89 00 05 	brgt	8000a3e0 <_dtoa_r+0x28c>
8000a3da:	58 2c       	cp.w	r12,2
8000a3dc:	c1 01       	brne	8000a3fc <_dtoa_r+0x2a8>
8000a3de:	c1 88       	rjmp	8000a40e <_dtoa_r+0x2ba>
8000a3e0:	40 cb       	lddsp	r11,sp[0x30]
8000a3e2:	58 4b       	cp.w	r11,4
8000a3e4:	c0 60       	breq	8000a3f0 <_dtoa_r+0x29c>
8000a3e6:	58 5b       	cp.w	r11,5
8000a3e8:	c0 a1       	brne	8000a3fc <_dtoa_r+0x2a8>
8000a3ea:	30 1a       	mov	r10,1
8000a3ec:	50 da       	stdsp	sp[0x34],r10
8000a3ee:	c2 28       	rjmp	8000a432 <_dtoa_r+0x2de>
8000a3f0:	30 19       	mov	r9,1
8000a3f2:	50 d9       	stdsp	sp[0x34],r9
8000a3f4:	c0 f8       	rjmp	8000a412 <_dtoa_r+0x2be>
8000a3f6:	30 08       	mov	r8,0
8000a3f8:	30 14       	mov	r4,1
8000a3fa:	50 c8       	stdsp	sp[0x30],r8
8000a3fc:	3f f5       	mov	r5,-1
8000a3fe:	30 1c       	mov	r12,1
8000a400:	30 0b       	mov	r11,0
8000a402:	50 95       	stdsp	sp[0x24],r5
8000a404:	50 dc       	stdsp	sp[0x34],r12
8000a406:	0a 91       	mov	r1,r5
8000a408:	31 28       	mov	r8,18
8000a40a:	50 eb       	stdsp	sp[0x38],r11
8000a40c:	c2 08       	rjmp	8000a44c <_dtoa_r+0x2f8>
8000a40e:	30 0a       	mov	r10,0
8000a410:	50 da       	stdsp	sp[0x34],r10
8000a412:	40 e9       	lddsp	r9,sp[0x38]
8000a414:	58 09       	cp.w	r9,0
8000a416:	e0 89 00 07 	brgt	8000a424 <_dtoa_r+0x2d0>
8000a41a:	30 18       	mov	r8,1
8000a41c:	50 98       	stdsp	sp[0x24],r8
8000a41e:	10 91       	mov	r1,r8
8000a420:	50 e8       	stdsp	sp[0x38],r8
8000a422:	c1 58       	rjmp	8000a44c <_dtoa_r+0x2f8>
8000a424:	40 e5       	lddsp	r5,sp[0x38]
8000a426:	50 95       	stdsp	sp[0x24],r5
8000a428:	0a 91       	mov	r1,r5
8000a42a:	0a 98       	mov	r8,r5
8000a42c:	c1 08       	rjmp	8000a44c <_dtoa_r+0x2f8>
8000a42e:	30 0c       	mov	r12,0
8000a430:	50 dc       	stdsp	sp[0x34],r12
8000a432:	40 eb       	lddsp	r11,sp[0x38]
8000a434:	ec 0b 00 0b 	add	r11,r6,r11
8000a438:	50 9b       	stdsp	sp[0x24],r11
8000a43a:	16 98       	mov	r8,r11
8000a43c:	2f f8       	sub	r8,-1
8000a43e:	58 08       	cp.w	r8,0
8000a440:	e0 89 00 05 	brgt	8000a44a <_dtoa_r+0x2f6>
8000a444:	10 91       	mov	r1,r8
8000a446:	30 18       	mov	r8,1
8000a448:	c0 28       	rjmp	8000a44c <_dtoa_r+0x2f8>
8000a44a:	10 91       	mov	r1,r8
8000a44c:	30 09       	mov	r9,0
8000a44e:	6e 9a       	ld.w	r10,r7[0x24]
8000a450:	95 19       	st.w	r10[0x4],r9
8000a452:	30 49       	mov	r9,4
8000a454:	c0 68       	rjmp	8000a460 <_dtoa_r+0x30c>
8000a456:	d7 03       	nop
8000a458:	6a 1a       	ld.w	r10,r5[0x4]
8000a45a:	a1 79       	lsl	r9,0x1
8000a45c:	2f fa       	sub	r10,-1
8000a45e:	8b 1a       	st.w	r5[0x4],r10
8000a460:	6e 95       	ld.w	r5,r7[0x24]
8000a462:	f2 ca ff ec 	sub	r10,r9,-20
8000a466:	10 3a       	cp.w	r10,r8
8000a468:	fe 98 ff f8 	brls	8000a458 <_dtoa_r+0x304>
8000a46c:	6a 1b       	ld.w	r11,r5[0x4]
8000a46e:	0e 9c       	mov	r12,r7
8000a470:	e0 a0 09 44 	rcall	8000b6f8 <_Balloc>
8000a474:	58 e1       	cp.w	r1,14
8000a476:	5f 88       	srls	r8
8000a478:	8b 0c       	st.w	r5[0x0],r12
8000a47a:	f1 e4 00 04 	and	r4,r8,r4
8000a47e:	6e 98       	ld.w	r8,r7[0x24]
8000a480:	70 08       	ld.w	r8,r8[0x0]
8000a482:	50 88       	stdsp	sp[0x20],r8
8000a484:	e0 80 01 82 	breq	8000a788 <_dtoa_r+0x634>
8000a488:	58 06       	cp.w	r6,0
8000a48a:	e0 8a 00 43 	brle	8000a510 <_dtoa_r+0x3bc>
8000a48e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a492:	fe c8 c2 ae 	sub	r8,pc,-15698
8000a496:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a49a:	fa e5 00 18 	st.d	sp[24],r4
8000a49e:	ec 04 14 04 	asr	r4,r6,0x4
8000a4a2:	ed b4 00 04 	bld	r4,0x4
8000a4a6:	c0 30       	breq	8000a4ac <_dtoa_r+0x358>
8000a4a8:	30 25       	mov	r5,2
8000a4aa:	c1 08       	rjmp	8000a4ca <_dtoa_r+0x376>
8000a4ac:	fe c8 c2 00 	sub	r8,pc,-15872
8000a4b0:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a4b4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4b8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a4bc:	e0 a0 0f fa 	rcall	8000c4b0 <__avr32_f64_div>
8000a4c0:	30 35       	mov	r5,3
8000a4c2:	14 98       	mov	r8,r10
8000a4c4:	16 99       	mov	r9,r11
8000a4c6:	fa e9 00 08 	st.d	sp[8],r8
8000a4ca:	fe cc c2 1e 	sub	r12,pc,-15842
8000a4ce:	50 a3       	stdsp	sp[0x28],r3
8000a4d0:	0c 93       	mov	r3,r6
8000a4d2:	18 96       	mov	r6,r12
8000a4d4:	c0 f8       	rjmp	8000a4f2 <_dtoa_r+0x39e>
8000a4d6:	fa ea 00 18 	ld.d	r10,sp[24]
8000a4da:	ed b4 00 00 	bld	r4,0x0
8000a4de:	c0 81       	brne	8000a4ee <_dtoa_r+0x39a>
8000a4e0:	ec e8 00 00 	ld.d	r8,r6[0]
8000a4e4:	2f f5       	sub	r5,-1
8000a4e6:	e0 a0 0c 9f 	rcall	8000be24 <__avr32_f64_mul>
8000a4ea:	fa eb 00 18 	st.d	sp[24],r10
8000a4ee:	a1 54       	asr	r4,0x1
8000a4f0:	2f 86       	sub	r6,-8
8000a4f2:	58 04       	cp.w	r4,0
8000a4f4:	cf 11       	brne	8000a4d6 <_dtoa_r+0x382>
8000a4f6:	fa e8 00 18 	ld.d	r8,sp[24]
8000a4fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4fe:	06 96       	mov	r6,r3
8000a500:	e0 a0 0f d8 	rcall	8000c4b0 <__avr32_f64_div>
8000a504:	40 a3       	lddsp	r3,sp[0x28]
8000a506:	14 98       	mov	r8,r10
8000a508:	16 99       	mov	r9,r11
8000a50a:	fa e9 00 08 	st.d	sp[8],r8
8000a50e:	c2 f8       	rjmp	8000a56c <_dtoa_r+0x418>
8000a510:	ec 08 11 00 	rsub	r8,r6,0
8000a514:	c0 31       	brne	8000a51a <_dtoa_r+0x3c6>
8000a516:	30 25       	mov	r5,2
8000a518:	c2 a8       	rjmp	8000a56c <_dtoa_r+0x418>
8000a51a:	fe cc c2 6e 	sub	r12,pc,-15762
8000a51e:	f0 04 14 04 	asr	r4,r8,0x4
8000a522:	50 1c       	stdsp	sp[0x4],r12
8000a524:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a528:	fe c9 c3 44 	sub	r9,pc,-15548
8000a52c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a530:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a534:	e0 a0 0c 78 	rcall	8000be24 <__avr32_f64_mul>
8000a538:	40 1c       	lddsp	r12,sp[0x4]
8000a53a:	50 63       	stdsp	sp[0x18],r3
8000a53c:	30 25       	mov	r5,2
8000a53e:	0c 93       	mov	r3,r6
8000a540:	fa eb 00 08 	st.d	sp[8],r10
8000a544:	18 96       	mov	r6,r12
8000a546:	c0 f8       	rjmp	8000a564 <_dtoa_r+0x410>
8000a548:	fa ea 00 08 	ld.d	r10,sp[8]
8000a54c:	ed b4 00 00 	bld	r4,0x0
8000a550:	c0 81       	brne	8000a560 <_dtoa_r+0x40c>
8000a552:	ec e8 00 00 	ld.d	r8,r6[0]
8000a556:	2f f5       	sub	r5,-1
8000a558:	e0 a0 0c 66 	rcall	8000be24 <__avr32_f64_mul>
8000a55c:	fa eb 00 08 	st.d	sp[8],r10
8000a560:	a1 54       	asr	r4,0x1
8000a562:	2f 86       	sub	r6,-8
8000a564:	58 04       	cp.w	r4,0
8000a566:	cf 11       	brne	8000a548 <_dtoa_r+0x3f4>
8000a568:	06 96       	mov	r6,r3
8000a56a:	40 63       	lddsp	r3,sp[0x18]
8000a56c:	41 4a       	lddsp	r10,sp[0x50]
8000a56e:	58 0a       	cp.w	r10,0
8000a570:	c2 a0       	breq	8000a5c4 <_dtoa_r+0x470>
8000a572:	fa e8 00 08 	ld.d	r8,sp[8]
8000a576:	58 01       	cp.w	r1,0
8000a578:	5f 94       	srgt	r4
8000a57a:	fa e9 00 18 	st.d	sp[24],r8
8000a57e:	30 08       	mov	r8,0
8000a580:	fc 19 3f f0 	movh	r9,0x3ff0
8000a584:	fa ea 00 18 	ld.d	r10,sp[24]
8000a588:	e0 a0 0f 60 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a58c:	f9 bc 00 00 	moveq	r12,0
8000a590:	f9 bc 01 01 	movne	r12,1
8000a594:	e9 ec 00 0c 	and	r12,r4,r12
8000a598:	c1 60       	breq	8000a5c4 <_dtoa_r+0x470>
8000a59a:	40 98       	lddsp	r8,sp[0x24]
8000a59c:	58 08       	cp.w	r8,0
8000a59e:	e0 8a 00 f1 	brle	8000a780 <_dtoa_r+0x62c>
8000a5a2:	30 08       	mov	r8,0
8000a5a4:	fc 19 40 24 	movh	r9,0x4024
8000a5a8:	ec c4 00 01 	sub	r4,r6,1
8000a5ac:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5b0:	2f f5       	sub	r5,-1
8000a5b2:	50 64       	stdsp	sp[0x18],r4
8000a5b4:	e0 a0 0c 38 	rcall	8000be24 <__avr32_f64_mul>
8000a5b8:	40 94       	lddsp	r4,sp[0x24]
8000a5ba:	14 98       	mov	r8,r10
8000a5bc:	16 99       	mov	r9,r11
8000a5be:	fa e9 00 08 	st.d	sp[8],r8
8000a5c2:	c0 38       	rjmp	8000a5c8 <_dtoa_r+0x474>
8000a5c4:	50 66       	stdsp	sp[0x18],r6
8000a5c6:	02 94       	mov	r4,r1
8000a5c8:	0a 9c       	mov	r12,r5
8000a5ca:	e0 a0 0e 88 	rcall	8000c2da <__avr32_s32_to_f64>
8000a5ce:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5d2:	e0 a0 0c 29 	rcall	8000be24 <__avr32_f64_mul>
8000a5d6:	30 08       	mov	r8,0
8000a5d8:	fc 19 40 1c 	movh	r9,0x401c
8000a5dc:	e0 a0 0d de 	rcall	8000c198 <__avr32_f64_add>
8000a5e0:	14 98       	mov	r8,r10
8000a5e2:	16 99       	mov	r9,r11
8000a5e4:	fa e9 00 28 	st.d	sp[40],r8
8000a5e8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a5ec:	40 a5       	lddsp	r5,sp[0x28]
8000a5ee:	10 05       	add	r5,r8
8000a5f0:	50 a5       	stdsp	sp[0x28],r5
8000a5f2:	58 04       	cp.w	r4,0
8000a5f4:	c2 11       	brne	8000a636 <_dtoa_r+0x4e2>
8000a5f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5fa:	30 08       	mov	r8,0
8000a5fc:	fc 19 40 14 	movh	r9,0x4014
8000a600:	e0 a0 0c fe 	rcall	8000bffc <__avr32_f64_sub>
8000a604:	40 bc       	lddsp	r12,sp[0x2c]
8000a606:	fa eb 00 08 	st.d	sp[8],r10
8000a60a:	14 98       	mov	r8,r10
8000a60c:	16 99       	mov	r9,r11
8000a60e:	18 9a       	mov	r10,r12
8000a610:	0a 9b       	mov	r11,r5
8000a612:	e0 a0 0f 1b 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a616:	e0 81 02 54 	brne	8000aabe <_dtoa_r+0x96a>
8000a61a:	0a 98       	mov	r8,r5
8000a61c:	40 b9       	lddsp	r9,sp[0x2c]
8000a61e:	ee 18 80 00 	eorh	r8,0x8000
8000a622:	fa ea 00 08 	ld.d	r10,sp[8]
8000a626:	10 95       	mov	r5,r8
8000a628:	12 98       	mov	r8,r9
8000a62a:	0a 99       	mov	r9,r5
8000a62c:	e0 a0 0f 0e 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a630:	e0 81 02 3e 	brne	8000aaac <_dtoa_r+0x958>
8000a634:	ca 68       	rjmp	8000a780 <_dtoa_r+0x62c>
8000a636:	fe c9 c4 52 	sub	r9,pc,-15278
8000a63a:	e8 c8 00 01 	sub	r8,r4,1
8000a63e:	40 d5       	lddsp	r5,sp[0x34]
8000a640:	58 05       	cp.w	r5,0
8000a642:	c4 f0       	breq	8000a6e0 <_dtoa_r+0x58c>
8000a644:	30 0c       	mov	r12,0
8000a646:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a64a:	51 3c       	stdsp	sp[0x4c],r12
8000a64c:	30 0a       	mov	r10,0
8000a64e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a652:	e0 a0 0f 2f 	rcall	8000c4b0 <__avr32_f64_div>
8000a656:	fa e8 00 28 	ld.d	r8,sp[40]
8000a65a:	40 85       	lddsp	r5,sp[0x20]
8000a65c:	e0 a0 0c d0 	rcall	8000bffc <__avr32_f64_sub>
8000a660:	fa eb 00 28 	st.d	sp[40],r10
8000a664:	fa ea 00 08 	ld.d	r10,sp[8]
8000a668:	e0 a0 0e 22 	rcall	8000c2ac <__avr32_f64_to_s32>
8000a66c:	51 6c       	stdsp	sp[0x58],r12
8000a66e:	e0 a0 0e 36 	rcall	8000c2da <__avr32_s32_to_f64>
8000a672:	14 98       	mov	r8,r10
8000a674:	16 99       	mov	r9,r11
8000a676:	fa ea 00 08 	ld.d	r10,sp[8]
8000a67a:	e0 a0 0c c1 	rcall	8000bffc <__avr32_f64_sub>
8000a67e:	fa eb 00 08 	st.d	sp[8],r10
8000a682:	41 68       	lddsp	r8,sp[0x58]
8000a684:	2d 08       	sub	r8,-48
8000a686:	0a c8       	st.b	r5++,r8
8000a688:	41 39       	lddsp	r9,sp[0x4c]
8000a68a:	2f f9       	sub	r9,-1
8000a68c:	51 39       	stdsp	sp[0x4c],r9
8000a68e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a692:	e0 a0 0e db 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a696:	e0 81 03 39 	brne	8000ad08 <_dtoa_r+0xbb4>
8000a69a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a69e:	30 0a       	mov	r10,0
8000a6a0:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a6a4:	e0 a0 0c ac 	rcall	8000bffc <__avr32_f64_sub>
8000a6a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6ac:	e0 a0 0e ce 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a6b0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a6b4:	30 08       	mov	r8,0
8000a6b6:	fc 19 40 24 	movh	r9,0x4024
8000a6ba:	e0 81 00 da 	brne	8000a86e <_dtoa_r+0x71a>
8000a6be:	41 3c       	lddsp	r12,sp[0x4c]
8000a6c0:	08 3c       	cp.w	r12,r4
8000a6c2:	c5 f4       	brge	8000a780 <_dtoa_r+0x62c>
8000a6c4:	e0 a0 0b b0 	rcall	8000be24 <__avr32_f64_mul>
8000a6c8:	30 08       	mov	r8,0
8000a6ca:	fa eb 00 28 	st.d	sp[40],r10
8000a6ce:	fc 19 40 24 	movh	r9,0x4024
8000a6d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6d6:	e0 a0 0b a7 	rcall	8000be24 <__avr32_f64_mul>
8000a6da:	fa eb 00 08 	st.d	sp[8],r10
8000a6de:	cc 3b       	rjmp	8000a664 <_dtoa_r+0x510>
8000a6e0:	40 85       	lddsp	r5,sp[0x20]
8000a6e2:	08 05       	add	r5,r4
8000a6e4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a6e8:	51 35       	stdsp	sp[0x4c],r5
8000a6ea:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6ee:	40 85       	lddsp	r5,sp[0x20]
8000a6f0:	e0 a0 0b 9a 	rcall	8000be24 <__avr32_f64_mul>
8000a6f4:	fa eb 00 28 	st.d	sp[40],r10
8000a6f8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6fc:	e0 a0 0d d8 	rcall	8000c2ac <__avr32_f64_to_s32>
8000a700:	51 6c       	stdsp	sp[0x58],r12
8000a702:	e0 a0 0d ec 	rcall	8000c2da <__avr32_s32_to_f64>
8000a706:	14 98       	mov	r8,r10
8000a708:	16 99       	mov	r9,r11
8000a70a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a70e:	e0 a0 0c 77 	rcall	8000bffc <__avr32_f64_sub>
8000a712:	fa eb 00 08 	st.d	sp[8],r10
8000a716:	41 68       	lddsp	r8,sp[0x58]
8000a718:	2d 08       	sub	r8,-48
8000a71a:	0a c8       	st.b	r5++,r8
8000a71c:	41 3c       	lddsp	r12,sp[0x4c]
8000a71e:	18 35       	cp.w	r5,r12
8000a720:	c2 81       	brne	8000a770 <_dtoa_r+0x61c>
8000a722:	30 08       	mov	r8,0
8000a724:	fc 19 3f e0 	movh	r9,0x3fe0
8000a728:	fa ea 00 28 	ld.d	r10,sp[40]
8000a72c:	e0 a0 0d 36 	rcall	8000c198 <__avr32_f64_add>
8000a730:	40 85       	lddsp	r5,sp[0x20]
8000a732:	fa e8 00 08 	ld.d	r8,sp[8]
8000a736:	08 05       	add	r5,r4
8000a738:	e0 a0 0e 88 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a73c:	e0 81 00 99 	brne	8000a86e <_dtoa_r+0x71a>
8000a740:	fa e8 00 28 	ld.d	r8,sp[40]
8000a744:	30 0a       	mov	r10,0
8000a746:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a74a:	e0 a0 0c 59 	rcall	8000bffc <__avr32_f64_sub>
8000a74e:	14 98       	mov	r8,r10
8000a750:	16 99       	mov	r9,r11
8000a752:	fa ea 00 08 	ld.d	r10,sp[8]
8000a756:	e0 a0 0e 79 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a75a:	c1 30       	breq	8000a780 <_dtoa_r+0x62c>
8000a75c:	33 09       	mov	r9,48
8000a75e:	0a 98       	mov	r8,r5
8000a760:	11 7a       	ld.ub	r10,--r8
8000a762:	f2 0a 18 00 	cp.b	r10,r9
8000a766:	e0 81 02 d1 	brne	8000ad08 <_dtoa_r+0xbb4>
8000a76a:	10 95       	mov	r5,r8
8000a76c:	cf 9b       	rjmp	8000a75e <_dtoa_r+0x60a>
8000a76e:	d7 03       	nop
8000a770:	30 08       	mov	r8,0
8000a772:	fc 19 40 24 	movh	r9,0x4024
8000a776:	e0 a0 0b 57 	rcall	8000be24 <__avr32_f64_mul>
8000a77a:	fa eb 00 08 	st.d	sp[8],r10
8000a77e:	cb db       	rjmp	8000a6f8 <_dtoa_r+0x5a4>
8000a780:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a784:	fa eb 00 08 	st.d	sp[8],r10
8000a788:	58 e6       	cp.w	r6,14
8000a78a:	5f ab       	srle	r11
8000a78c:	41 8a       	lddsp	r10,sp[0x60]
8000a78e:	30 08       	mov	r8,0
8000a790:	f4 09 11 ff 	rsub	r9,r10,-1
8000a794:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a798:	f0 09 18 00 	cp.b	r9,r8
8000a79c:	e0 80 00 82 	breq	8000a8a0 <_dtoa_r+0x74c>
8000a7a0:	40 ea       	lddsp	r10,sp[0x38]
8000a7a2:	58 01       	cp.w	r1,0
8000a7a4:	5f a9       	srle	r9
8000a7a6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a7aa:	fe ca c5 c6 	sub	r10,pc,-14906
8000a7ae:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a7b2:	fa e5 00 10 	st.d	sp[16],r4
8000a7b6:	f0 09 18 00 	cp.b	r9,r8
8000a7ba:	c1 40       	breq	8000a7e2 <_dtoa_r+0x68e>
8000a7bc:	58 01       	cp.w	r1,0
8000a7be:	e0 81 01 77 	brne	8000aaac <_dtoa_r+0x958>
8000a7c2:	30 08       	mov	r8,0
8000a7c4:	fc 19 40 14 	movh	r9,0x4014
8000a7c8:	08 9a       	mov	r10,r4
8000a7ca:	0a 9b       	mov	r11,r5
8000a7cc:	e0 a0 0b 2c 	rcall	8000be24 <__avr32_f64_mul>
8000a7d0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7d4:	e0 a0 0e 06 	rcall	8000c3e0 <__avr32_f64_cmp_ge>
8000a7d8:	e0 81 01 6a 	brne	8000aaac <_dtoa_r+0x958>
8000a7dc:	02 92       	mov	r2,r1
8000a7de:	e0 8f 01 72 	bral	8000aac2 <_dtoa_r+0x96e>
8000a7e2:	40 85       	lddsp	r5,sp[0x20]
8000a7e4:	30 14       	mov	r4,1
8000a7e6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a7ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ee:	e0 a0 0e 61 	rcall	8000c4b0 <__avr32_f64_div>
8000a7f2:	e0 a0 0d 5d 	rcall	8000c2ac <__avr32_f64_to_s32>
8000a7f6:	18 92       	mov	r2,r12
8000a7f8:	e0 a0 0d 71 	rcall	8000c2da <__avr32_s32_to_f64>
8000a7fc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a800:	e0 a0 0b 12 	rcall	8000be24 <__avr32_f64_mul>
8000a804:	14 98       	mov	r8,r10
8000a806:	16 99       	mov	r9,r11
8000a808:	fa ea 00 08 	ld.d	r10,sp[8]
8000a80c:	e0 a0 0b f8 	rcall	8000bffc <__avr32_f64_sub>
8000a810:	fa eb 00 08 	st.d	sp[8],r10
8000a814:	e4 c8 ff d0 	sub	r8,r2,-48
8000a818:	0a c8       	st.b	r5++,r8
8000a81a:	fc 19 40 24 	movh	r9,0x4024
8000a81e:	30 08       	mov	r8,0
8000a820:	02 34       	cp.w	r4,r1
8000a822:	c3 31       	brne	8000a888 <_dtoa_r+0x734>
8000a824:	fa e8 00 08 	ld.d	r8,sp[8]
8000a828:	e0 a0 0c b8 	rcall	8000c198 <__avr32_f64_add>
8000a82c:	16 91       	mov	r1,r11
8000a82e:	14 90       	mov	r0,r10
8000a830:	14 98       	mov	r8,r10
8000a832:	02 99       	mov	r9,r1
8000a834:	fa ea 00 10 	ld.d	r10,sp[16]
8000a838:	e0 a0 0e 08 	rcall	8000c448 <__avr32_f64_cmp_lt>
8000a83c:	c1 a1       	brne	8000a870 <_dtoa_r+0x71c>
8000a83e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a842:	00 9a       	mov	r10,r0
8000a844:	02 9b       	mov	r11,r1
8000a846:	e0 a0 0d ba 	rcall	8000c3ba <__avr32_f64_cmp_eq>
8000a84a:	e0 80 02 5e 	breq	8000ad06 <_dtoa_r+0xbb2>
8000a84e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a852:	c0 f1       	brne	8000a870 <_dtoa_r+0x71c>
8000a854:	e0 8f 02 59 	bral	8000ad06 <_dtoa_r+0xbb2>
8000a858:	40 8a       	lddsp	r10,sp[0x20]
8000a85a:	14 38       	cp.w	r8,r10
8000a85c:	c0 30       	breq	8000a862 <_dtoa_r+0x70e>
8000a85e:	10 95       	mov	r5,r8
8000a860:	c0 98       	rjmp	8000a872 <_dtoa_r+0x71e>
8000a862:	33 08       	mov	r8,48
8000a864:	40 89       	lddsp	r9,sp[0x20]
8000a866:	2f f6       	sub	r6,-1
8000a868:	b2 88       	st.b	r9[0x0],r8
8000a86a:	40 88       	lddsp	r8,sp[0x20]
8000a86c:	c0 88       	rjmp	8000a87c <_dtoa_r+0x728>
8000a86e:	40 66       	lddsp	r6,sp[0x18]
8000a870:	33 99       	mov	r9,57
8000a872:	0a 98       	mov	r8,r5
8000a874:	11 7a       	ld.ub	r10,--r8
8000a876:	f2 0a 18 00 	cp.b	r10,r9
8000a87a:	ce f0       	breq	8000a858 <_dtoa_r+0x704>
8000a87c:	50 66       	stdsp	sp[0x18],r6
8000a87e:	11 89       	ld.ub	r9,r8[0x0]
8000a880:	2f f9       	sub	r9,-1
8000a882:	b0 89       	st.b	r8[0x0],r9
8000a884:	e0 8f 02 42 	bral	8000ad08 <_dtoa_r+0xbb4>
8000a888:	e0 a0 0a ce 	rcall	8000be24 <__avr32_f64_mul>
8000a88c:	2f f4       	sub	r4,-1
8000a88e:	fa eb 00 08 	st.d	sp[8],r10
8000a892:	30 08       	mov	r8,0
8000a894:	30 09       	mov	r9,0
8000a896:	e0 a0 0d 92 	rcall	8000c3ba <__avr32_f64_cmp_eq>
8000a89a:	ca 60       	breq	8000a7e6 <_dtoa_r+0x692>
8000a89c:	e0 8f 02 35 	bral	8000ad06 <_dtoa_r+0xbb2>
8000a8a0:	40 d8       	lddsp	r8,sp[0x34]
8000a8a2:	58 08       	cp.w	r8,0
8000a8a4:	c0 51       	brne	8000a8ae <_dtoa_r+0x75a>
8000a8a6:	04 98       	mov	r8,r2
8000a8a8:	00 95       	mov	r5,r0
8000a8aa:	40 d4       	lddsp	r4,sp[0x34]
8000a8ac:	c3 78       	rjmp	8000a91a <_dtoa_r+0x7c6>
8000a8ae:	40 c5       	lddsp	r5,sp[0x30]
8000a8b0:	58 15       	cp.w	r5,1
8000a8b2:	e0 89 00 0f 	brgt	8000a8d0 <_dtoa_r+0x77c>
8000a8b6:	41 74       	lddsp	r4,sp[0x5c]
8000a8b8:	58 04       	cp.w	r4,0
8000a8ba:	c0 40       	breq	8000a8c2 <_dtoa_r+0x76e>
8000a8bc:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a8c0:	c0 48       	rjmp	8000a8c8 <_dtoa_r+0x774>
8000a8c2:	41 99       	lddsp	r9,sp[0x64]
8000a8c4:	f2 09 11 36 	rsub	r9,r9,54
8000a8c8:	04 98       	mov	r8,r2
8000a8ca:	00 95       	mov	r5,r0
8000a8cc:	c1 c8       	rjmp	8000a904 <_dtoa_r+0x7b0>
8000a8ce:	d7 03       	nop
8000a8d0:	e2 c8 00 01 	sub	r8,r1,1
8000a8d4:	58 01       	cp.w	r1,0
8000a8d6:	e0 05 17 40 	movge	r5,r0
8000a8da:	e2 09 17 40 	movge	r9,r1
8000a8de:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a8e2:	f9 b9 05 00 	movlt	r9,0
8000a8e6:	10 32       	cp.w	r2,r8
8000a8e8:	e5 d8 e4 18 	subge	r8,r2,r8
8000a8ec:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a8f0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a8f4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a8f8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a8fc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a900:	f9 b8 05 00 	movlt	r8,0
8000a904:	40 4b       	lddsp	r11,sp[0x10]
8000a906:	12 0b       	add	r11,r9
8000a908:	50 08       	stdsp	sp[0x0],r8
8000a90a:	50 4b       	stdsp	sp[0x10],r11
8000a90c:	12 00       	add	r0,r9
8000a90e:	30 1b       	mov	r11,1
8000a910:	0e 9c       	mov	r12,r7
8000a912:	e0 a0 08 a7 	rcall	8000ba60 <__i2b>
8000a916:	40 08       	lddsp	r8,sp[0x0]
8000a918:	18 94       	mov	r4,r12
8000a91a:	40 4a       	lddsp	r10,sp[0x10]
8000a91c:	58 05       	cp.w	r5,0
8000a91e:	5f 99       	srgt	r9
8000a920:	58 0a       	cp.w	r10,0
8000a922:	5f 9a       	srgt	r10
8000a924:	f5 e9 00 09 	and	r9,r10,r9
8000a928:	c0 80       	breq	8000a938 <_dtoa_r+0x7e4>
8000a92a:	40 4c       	lddsp	r12,sp[0x10]
8000a92c:	f8 05 0d 49 	min	r9,r12,r5
8000a930:	12 1c       	sub	r12,r9
8000a932:	12 10       	sub	r0,r9
8000a934:	50 4c       	stdsp	sp[0x10],r12
8000a936:	12 15       	sub	r5,r9
8000a938:	58 02       	cp.w	r2,0
8000a93a:	e0 8a 00 27 	brle	8000a988 <_dtoa_r+0x834>
8000a93e:	40 db       	lddsp	r11,sp[0x34]
8000a940:	58 0b       	cp.w	r11,0
8000a942:	c1 d0       	breq	8000a97c <_dtoa_r+0x828>
8000a944:	58 08       	cp.w	r8,0
8000a946:	e0 8a 00 17 	brle	8000a974 <_dtoa_r+0x820>
8000a94a:	10 9a       	mov	r10,r8
8000a94c:	50 08       	stdsp	sp[0x0],r8
8000a94e:	08 9b       	mov	r11,r4
8000a950:	0e 9c       	mov	r12,r7
8000a952:	e0 a0 08 cd 	rcall	8000baec <__pow5mult>
8000a956:	06 9a       	mov	r10,r3
8000a958:	18 9b       	mov	r11,r12
8000a95a:	18 94       	mov	r4,r12
8000a95c:	0e 9c       	mov	r12,r7
8000a95e:	e0 a0 08 01 	rcall	8000b960 <__multiply>
8000a962:	18 99       	mov	r9,r12
8000a964:	06 9b       	mov	r11,r3
8000a966:	50 19       	stdsp	sp[0x4],r9
8000a968:	0e 9c       	mov	r12,r7
8000a96a:	e0 a0 06 ad 	rcall	8000b6c4 <_Bfree>
8000a96e:	40 19       	lddsp	r9,sp[0x4]
8000a970:	40 08       	lddsp	r8,sp[0x0]
8000a972:	12 93       	mov	r3,r9
8000a974:	e4 08 01 0a 	sub	r10,r2,r8
8000a978:	c0 80       	breq	8000a988 <_dtoa_r+0x834>
8000a97a:	c0 28       	rjmp	8000a97e <_dtoa_r+0x82a>
8000a97c:	04 9a       	mov	r10,r2
8000a97e:	06 9b       	mov	r11,r3
8000a980:	0e 9c       	mov	r12,r7
8000a982:	e0 a0 08 b5 	rcall	8000baec <__pow5mult>
8000a986:	18 93       	mov	r3,r12
8000a988:	30 1b       	mov	r11,1
8000a98a:	0e 9c       	mov	r12,r7
8000a98c:	e0 a0 08 6a 	rcall	8000ba60 <__i2b>
8000a990:	41 1a       	lddsp	r10,sp[0x44]
8000a992:	18 92       	mov	r2,r12
8000a994:	58 0a       	cp.w	r10,0
8000a996:	e0 8a 00 07 	brle	8000a9a4 <_dtoa_r+0x850>
8000a99a:	18 9b       	mov	r11,r12
8000a99c:	0e 9c       	mov	r12,r7
8000a99e:	e0 a0 08 a7 	rcall	8000baec <__pow5mult>
8000a9a2:	18 92       	mov	r2,r12
8000a9a4:	40 c9       	lddsp	r9,sp[0x30]
8000a9a6:	58 19       	cp.w	r9,1
8000a9a8:	e0 89 00 14 	brgt	8000a9d0 <_dtoa_r+0x87c>
8000a9ac:	40 38       	lddsp	r8,sp[0xc]
8000a9ae:	58 08       	cp.w	r8,0
8000a9b0:	c1 01       	brne	8000a9d0 <_dtoa_r+0x87c>
8000a9b2:	40 29       	lddsp	r9,sp[0x8]
8000a9b4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a9b8:	c0 c1       	brne	8000a9d0 <_dtoa_r+0x87c>
8000a9ba:	12 98       	mov	r8,r9
8000a9bc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a9c0:	c0 80       	breq	8000a9d0 <_dtoa_r+0x87c>
8000a9c2:	40 4c       	lddsp	r12,sp[0x10]
8000a9c4:	30 1b       	mov	r11,1
8000a9c6:	2f fc       	sub	r12,-1
8000a9c8:	2f f0       	sub	r0,-1
8000a9ca:	50 4c       	stdsp	sp[0x10],r12
8000a9cc:	50 6b       	stdsp	sp[0x18],r11
8000a9ce:	c0 38       	rjmp	8000a9d4 <_dtoa_r+0x880>
8000a9d0:	30 0a       	mov	r10,0
8000a9d2:	50 6a       	stdsp	sp[0x18],r10
8000a9d4:	41 19       	lddsp	r9,sp[0x44]
8000a9d6:	58 09       	cp.w	r9,0
8000a9d8:	c0 31       	brne	8000a9de <_dtoa_r+0x88a>
8000a9da:	30 1c       	mov	r12,1
8000a9dc:	c0 98       	rjmp	8000a9ee <_dtoa_r+0x89a>
8000a9de:	64 48       	ld.w	r8,r2[0x10]
8000a9e0:	2f c8       	sub	r8,-4
8000a9e2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a9e6:	e0 a0 05 df 	rcall	8000b5a4 <__hi0bits>
8000a9ea:	f8 0c 11 20 	rsub	r12,r12,32
8000a9ee:	40 4b       	lddsp	r11,sp[0x10]
8000a9f0:	f8 0b 00 08 	add	r8,r12,r11
8000a9f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a9f8:	c0 c0       	breq	8000aa10 <_dtoa_r+0x8bc>
8000a9fa:	f0 08 11 20 	rsub	r8,r8,32
8000a9fe:	58 48       	cp.w	r8,4
8000aa00:	e0 8a 00 06 	brle	8000aa0c <_dtoa_r+0x8b8>
8000aa04:	20 48       	sub	r8,4
8000aa06:	10 0b       	add	r11,r8
8000aa08:	50 4b       	stdsp	sp[0x10],r11
8000aa0a:	c0 78       	rjmp	8000aa18 <_dtoa_r+0x8c4>
8000aa0c:	58 48       	cp.w	r8,4
8000aa0e:	c0 70       	breq	8000aa1c <_dtoa_r+0x8c8>
8000aa10:	40 4a       	lddsp	r10,sp[0x10]
8000aa12:	2e 48       	sub	r8,-28
8000aa14:	10 0a       	add	r10,r8
8000aa16:	50 4a       	stdsp	sp[0x10],r10
8000aa18:	10 00       	add	r0,r8
8000aa1a:	10 05       	add	r5,r8
8000aa1c:	58 00       	cp.w	r0,0
8000aa1e:	e0 8a 00 08 	brle	8000aa2e <_dtoa_r+0x8da>
8000aa22:	06 9b       	mov	r11,r3
8000aa24:	00 9a       	mov	r10,r0
8000aa26:	0e 9c       	mov	r12,r7
8000aa28:	e0 a0 07 58 	rcall	8000b8d8 <__lshift>
8000aa2c:	18 93       	mov	r3,r12
8000aa2e:	40 49       	lddsp	r9,sp[0x10]
8000aa30:	58 09       	cp.w	r9,0
8000aa32:	e0 8a 00 08 	brle	8000aa42 <_dtoa_r+0x8ee>
8000aa36:	04 9b       	mov	r11,r2
8000aa38:	12 9a       	mov	r10,r9
8000aa3a:	0e 9c       	mov	r12,r7
8000aa3c:	e0 a0 07 4e 	rcall	8000b8d8 <__lshift>
8000aa40:	18 92       	mov	r2,r12
8000aa42:	41 48       	lddsp	r8,sp[0x50]
8000aa44:	58 08       	cp.w	r8,0
8000aa46:	c1 b0       	breq	8000aa7c <_dtoa_r+0x928>
8000aa48:	04 9b       	mov	r11,r2
8000aa4a:	06 9c       	mov	r12,r3
8000aa4c:	e0 a0 06 23 	rcall	8000b692 <__mcmp>
8000aa50:	c1 64       	brge	8000aa7c <_dtoa_r+0x928>
8000aa52:	06 9b       	mov	r11,r3
8000aa54:	30 09       	mov	r9,0
8000aa56:	30 aa       	mov	r10,10
8000aa58:	0e 9c       	mov	r12,r7
8000aa5a:	e0 a0 08 0b 	rcall	8000ba70 <__multadd>
8000aa5e:	20 16       	sub	r6,1
8000aa60:	18 93       	mov	r3,r12
8000aa62:	40 dc       	lddsp	r12,sp[0x34]
8000aa64:	58 0c       	cp.w	r12,0
8000aa66:	c0 31       	brne	8000aa6c <_dtoa_r+0x918>
8000aa68:	40 91       	lddsp	r1,sp[0x24]
8000aa6a:	c0 98       	rjmp	8000aa7c <_dtoa_r+0x928>
8000aa6c:	08 9b       	mov	r11,r4
8000aa6e:	40 91       	lddsp	r1,sp[0x24]
8000aa70:	30 09       	mov	r9,0
8000aa72:	30 aa       	mov	r10,10
8000aa74:	0e 9c       	mov	r12,r7
8000aa76:	e0 a0 07 fd 	rcall	8000ba70 <__multadd>
8000aa7a:	18 94       	mov	r4,r12
8000aa7c:	58 01       	cp.w	r1,0
8000aa7e:	5f a9       	srle	r9
8000aa80:	40 cb       	lddsp	r11,sp[0x30]
8000aa82:	58 2b       	cp.w	r11,2
8000aa84:	5f 98       	srgt	r8
8000aa86:	f3 e8 00 08 	and	r8,r9,r8
8000aa8a:	c2 50       	breq	8000aad4 <_dtoa_r+0x980>
8000aa8c:	58 01       	cp.w	r1,0
8000aa8e:	c1 11       	brne	8000aab0 <_dtoa_r+0x95c>
8000aa90:	04 9b       	mov	r11,r2
8000aa92:	02 99       	mov	r9,r1
8000aa94:	30 5a       	mov	r10,5
8000aa96:	0e 9c       	mov	r12,r7
8000aa98:	e0 a0 07 ec 	rcall	8000ba70 <__multadd>
8000aa9c:	18 92       	mov	r2,r12
8000aa9e:	18 9b       	mov	r11,r12
8000aaa0:	06 9c       	mov	r12,r3
8000aaa2:	e0 a0 05 f8 	rcall	8000b692 <__mcmp>
8000aaa6:	e0 89 00 0f 	brgt	8000aac4 <_dtoa_r+0x970>
8000aaaa:	c0 38       	rjmp	8000aab0 <_dtoa_r+0x95c>
8000aaac:	30 02       	mov	r2,0
8000aaae:	04 94       	mov	r4,r2
8000aab0:	40 ea       	lddsp	r10,sp[0x38]
8000aab2:	30 09       	mov	r9,0
8000aab4:	5c da       	com	r10
8000aab6:	40 85       	lddsp	r5,sp[0x20]
8000aab8:	50 6a       	stdsp	sp[0x18],r10
8000aaba:	50 49       	stdsp	sp[0x10],r9
8000aabc:	c0 f9       	rjmp	8000acda <_dtoa_r+0xb86>
8000aabe:	08 92       	mov	r2,r4
8000aac0:	40 66       	lddsp	r6,sp[0x18]
8000aac2:	04 94       	mov	r4,r2
8000aac4:	2f f6       	sub	r6,-1
8000aac6:	50 66       	stdsp	sp[0x18],r6
8000aac8:	33 18       	mov	r8,49
8000aaca:	40 85       	lddsp	r5,sp[0x20]
8000aacc:	0a c8       	st.b	r5++,r8
8000aace:	30 08       	mov	r8,0
8000aad0:	50 48       	stdsp	sp[0x10],r8
8000aad2:	c0 49       	rjmp	8000acda <_dtoa_r+0xb86>
8000aad4:	40 dc       	lddsp	r12,sp[0x34]
8000aad6:	58 0c       	cp.w	r12,0
8000aad8:	e0 80 00 b5 	breq	8000ac42 <_dtoa_r+0xaee>
8000aadc:	58 05       	cp.w	r5,0
8000aade:	e0 8a 00 08 	brle	8000aaee <_dtoa_r+0x99a>
8000aae2:	08 9b       	mov	r11,r4
8000aae4:	0a 9a       	mov	r10,r5
8000aae6:	0e 9c       	mov	r12,r7
8000aae8:	e0 a0 06 f8 	rcall	8000b8d8 <__lshift>
8000aaec:	18 94       	mov	r4,r12
8000aaee:	40 6b       	lddsp	r11,sp[0x18]
8000aaf0:	58 0b       	cp.w	r11,0
8000aaf2:	c0 31       	brne	8000aaf8 <_dtoa_r+0x9a4>
8000aaf4:	08 9c       	mov	r12,r4
8000aaf6:	c1 38       	rjmp	8000ab1c <_dtoa_r+0x9c8>
8000aaf8:	68 1b       	ld.w	r11,r4[0x4]
8000aafa:	0e 9c       	mov	r12,r7
8000aafc:	e0 a0 05 fe 	rcall	8000b6f8 <_Balloc>
8000ab00:	68 4a       	ld.w	r10,r4[0x10]
8000ab02:	18 95       	mov	r5,r12
8000ab04:	e8 cb ff f4 	sub	r11,r4,-12
8000ab08:	2f ea       	sub	r10,-2
8000ab0a:	2f 4c       	sub	r12,-12
8000ab0c:	a3 6a       	lsl	r10,0x2
8000ab0e:	fe b0 e6 4f 	rcall	800077ac <memcpy>
8000ab12:	0a 9b       	mov	r11,r5
8000ab14:	30 1a       	mov	r10,1
8000ab16:	0e 9c       	mov	r12,r7
8000ab18:	e0 a0 06 e0 	rcall	8000b8d8 <__lshift>
8000ab1c:	50 44       	stdsp	sp[0x10],r4
8000ab1e:	40 3a       	lddsp	r10,sp[0xc]
8000ab20:	30 19       	mov	r9,1
8000ab22:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ab26:	18 94       	mov	r4,r12
8000ab28:	50 da       	stdsp	sp[0x34],r10
8000ab2a:	40 85       	lddsp	r5,sp[0x20]
8000ab2c:	50 99       	stdsp	sp[0x24],r9
8000ab2e:	50 26       	stdsp	sp[0x8],r6
8000ab30:	50 e1       	stdsp	sp[0x38],r1
8000ab32:	04 9b       	mov	r11,r2
8000ab34:	06 9c       	mov	r12,r3
8000ab36:	fe b0 fa 7f 	rcall	8000a034 <quorem>
8000ab3a:	40 4b       	lddsp	r11,sp[0x10]
8000ab3c:	f8 c0 ff d0 	sub	r0,r12,-48
8000ab40:	06 9c       	mov	r12,r3
8000ab42:	e0 a0 05 a8 	rcall	8000b692 <__mcmp>
8000ab46:	08 9a       	mov	r10,r4
8000ab48:	50 6c       	stdsp	sp[0x18],r12
8000ab4a:	04 9b       	mov	r11,r2
8000ab4c:	0e 9c       	mov	r12,r7
8000ab4e:	e0 a0 06 5d 	rcall	8000b808 <__mdiff>
8000ab52:	18 91       	mov	r1,r12
8000ab54:	78 38       	ld.w	r8,r12[0xc]
8000ab56:	58 08       	cp.w	r8,0
8000ab58:	c0 30       	breq	8000ab5e <_dtoa_r+0xa0a>
8000ab5a:	30 16       	mov	r6,1
8000ab5c:	c0 68       	rjmp	8000ab68 <_dtoa_r+0xa14>
8000ab5e:	18 9b       	mov	r11,r12
8000ab60:	06 9c       	mov	r12,r3
8000ab62:	e0 a0 05 98 	rcall	8000b692 <__mcmp>
8000ab66:	18 96       	mov	r6,r12
8000ab68:	0e 9c       	mov	r12,r7
8000ab6a:	02 9b       	mov	r11,r1
8000ab6c:	e0 a0 05 ac 	rcall	8000b6c4 <_Bfree>
8000ab70:	40 cc       	lddsp	r12,sp[0x30]
8000ab72:	ed ec 10 08 	or	r8,r6,r12
8000ab76:	c0 d1       	brne	8000ab90 <_dtoa_r+0xa3c>
8000ab78:	40 db       	lddsp	r11,sp[0x34]
8000ab7a:	58 0b       	cp.w	r11,0
8000ab7c:	c0 a1       	brne	8000ab90 <_dtoa_r+0xa3c>
8000ab7e:	40 26       	lddsp	r6,sp[0x8]
8000ab80:	e0 40 00 39 	cp.w	r0,57
8000ab84:	c3 00       	breq	8000abe4 <_dtoa_r+0xa90>
8000ab86:	40 6a       	lddsp	r10,sp[0x18]
8000ab88:	58 0a       	cp.w	r10,0
8000ab8a:	e0 89 00 24 	brgt	8000abd2 <_dtoa_r+0xa7e>
8000ab8e:	c2 f8       	rjmp	8000abec <_dtoa_r+0xa98>
8000ab90:	40 69       	lddsp	r9,sp[0x18]
8000ab92:	58 09       	cp.w	r9,0
8000ab94:	c0 85       	brlt	8000aba4 <_dtoa_r+0xa50>
8000ab96:	12 98       	mov	r8,r9
8000ab98:	40 cc       	lddsp	r12,sp[0x30]
8000ab9a:	18 48       	or	r8,r12
8000ab9c:	c1 d1       	brne	8000abd6 <_dtoa_r+0xa82>
8000ab9e:	40 db       	lddsp	r11,sp[0x34]
8000aba0:	58 0b       	cp.w	r11,0
8000aba2:	c1 a1       	brne	8000abd6 <_dtoa_r+0xa82>
8000aba4:	0c 99       	mov	r9,r6
8000aba6:	40 26       	lddsp	r6,sp[0x8]
8000aba8:	58 09       	cp.w	r9,0
8000abaa:	e0 8a 00 21 	brle	8000abec <_dtoa_r+0xa98>
8000abae:	06 9b       	mov	r11,r3
8000abb0:	30 1a       	mov	r10,1
8000abb2:	0e 9c       	mov	r12,r7
8000abb4:	e0 a0 06 92 	rcall	8000b8d8 <__lshift>
8000abb8:	04 9b       	mov	r11,r2
8000abba:	18 93       	mov	r3,r12
8000abbc:	e0 a0 05 6b 	rcall	8000b692 <__mcmp>
8000abc0:	e0 89 00 06 	brgt	8000abcc <_dtoa_r+0xa78>
8000abc4:	c1 41       	brne	8000abec <_dtoa_r+0xa98>
8000abc6:	ed b0 00 00 	bld	r0,0x0
8000abca:	c1 11       	brne	8000abec <_dtoa_r+0xa98>
8000abcc:	e0 40 00 39 	cp.w	r0,57
8000abd0:	c0 a0       	breq	8000abe4 <_dtoa_r+0xa90>
8000abd2:	2f f0       	sub	r0,-1
8000abd4:	c0 c8       	rjmp	8000abec <_dtoa_r+0xa98>
8000abd6:	58 06       	cp.w	r6,0
8000abd8:	e0 8a 00 0c 	brle	8000abf0 <_dtoa_r+0xa9c>
8000abdc:	40 26       	lddsp	r6,sp[0x8]
8000abde:	e0 40 00 39 	cp.w	r0,57
8000abe2:	c0 41       	brne	8000abea <_dtoa_r+0xa96>
8000abe4:	33 98       	mov	r8,57
8000abe6:	0a c8       	st.b	r5++,r8
8000abe8:	c6 78       	rjmp	8000acb6 <_dtoa_r+0xb62>
8000abea:	2f f0       	sub	r0,-1
8000abec:	0a c0       	st.b	r5++,r0
8000abee:	c7 58       	rjmp	8000acd8 <_dtoa_r+0xb84>
8000abf0:	0a c0       	st.b	r5++,r0
8000abf2:	40 9a       	lddsp	r10,sp[0x24]
8000abf4:	40 e9       	lddsp	r9,sp[0x38]
8000abf6:	12 3a       	cp.w	r10,r9
8000abf8:	c4 30       	breq	8000ac7e <_dtoa_r+0xb2a>
8000abfa:	06 9b       	mov	r11,r3
8000abfc:	30 09       	mov	r9,0
8000abfe:	30 aa       	mov	r10,10
8000ac00:	0e 9c       	mov	r12,r7
8000ac02:	e0 a0 07 37 	rcall	8000ba70 <__multadd>
8000ac06:	40 48       	lddsp	r8,sp[0x10]
8000ac08:	18 93       	mov	r3,r12
8000ac0a:	08 38       	cp.w	r8,r4
8000ac0c:	c0 91       	brne	8000ac1e <_dtoa_r+0xaca>
8000ac0e:	10 9b       	mov	r11,r8
8000ac10:	30 09       	mov	r9,0
8000ac12:	30 aa       	mov	r10,10
8000ac14:	0e 9c       	mov	r12,r7
8000ac16:	e0 a0 07 2d 	rcall	8000ba70 <__multadd>
8000ac1a:	50 4c       	stdsp	sp[0x10],r12
8000ac1c:	c0 e8       	rjmp	8000ac38 <_dtoa_r+0xae4>
8000ac1e:	40 4b       	lddsp	r11,sp[0x10]
8000ac20:	30 09       	mov	r9,0
8000ac22:	30 aa       	mov	r10,10
8000ac24:	0e 9c       	mov	r12,r7
8000ac26:	e0 a0 07 25 	rcall	8000ba70 <__multadd>
8000ac2a:	08 9b       	mov	r11,r4
8000ac2c:	50 4c       	stdsp	sp[0x10],r12
8000ac2e:	30 09       	mov	r9,0
8000ac30:	30 aa       	mov	r10,10
8000ac32:	0e 9c       	mov	r12,r7
8000ac34:	e0 a0 07 1e 	rcall	8000ba70 <__multadd>
8000ac38:	18 94       	mov	r4,r12
8000ac3a:	40 9c       	lddsp	r12,sp[0x24]
8000ac3c:	2f fc       	sub	r12,-1
8000ac3e:	50 9c       	stdsp	sp[0x24],r12
8000ac40:	c7 9b       	rjmp	8000ab32 <_dtoa_r+0x9de>
8000ac42:	30 18       	mov	r8,1
8000ac44:	06 90       	mov	r0,r3
8000ac46:	40 85       	lddsp	r5,sp[0x20]
8000ac48:	08 93       	mov	r3,r4
8000ac4a:	0c 94       	mov	r4,r6
8000ac4c:	10 96       	mov	r6,r8
8000ac4e:	04 9b       	mov	r11,r2
8000ac50:	00 9c       	mov	r12,r0
8000ac52:	fe b0 f9 f1 	rcall	8000a034 <quorem>
8000ac56:	2d 0c       	sub	r12,-48
8000ac58:	0a cc       	st.b	r5++,r12
8000ac5a:	02 36       	cp.w	r6,r1
8000ac5c:	c0 a4       	brge	8000ac70 <_dtoa_r+0xb1c>
8000ac5e:	00 9b       	mov	r11,r0
8000ac60:	30 09       	mov	r9,0
8000ac62:	30 aa       	mov	r10,10
8000ac64:	0e 9c       	mov	r12,r7
8000ac66:	2f f6       	sub	r6,-1
8000ac68:	e0 a0 07 04 	rcall	8000ba70 <__multadd>
8000ac6c:	18 90       	mov	r0,r12
8000ac6e:	cf 0b       	rjmp	8000ac4e <_dtoa_r+0xafa>
8000ac70:	08 96       	mov	r6,r4
8000ac72:	30 0b       	mov	r11,0
8000ac74:	06 94       	mov	r4,r3
8000ac76:	50 4b       	stdsp	sp[0x10],r11
8000ac78:	00 93       	mov	r3,r0
8000ac7a:	18 90       	mov	r0,r12
8000ac7c:	c0 28       	rjmp	8000ac80 <_dtoa_r+0xb2c>
8000ac7e:	40 26       	lddsp	r6,sp[0x8]
8000ac80:	06 9b       	mov	r11,r3
8000ac82:	30 1a       	mov	r10,1
8000ac84:	0e 9c       	mov	r12,r7
8000ac86:	e0 a0 06 29 	rcall	8000b8d8 <__lshift>
8000ac8a:	04 9b       	mov	r11,r2
8000ac8c:	18 93       	mov	r3,r12
8000ac8e:	e0 a0 05 02 	rcall	8000b692 <__mcmp>
8000ac92:	e0 89 00 12 	brgt	8000acb6 <_dtoa_r+0xb62>
8000ac96:	c1 b1       	brne	8000accc <_dtoa_r+0xb78>
8000ac98:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ac9c:	c0 d1       	brne	8000acb6 <_dtoa_r+0xb62>
8000ac9e:	c1 78       	rjmp	8000accc <_dtoa_r+0xb78>
8000aca0:	40 89       	lddsp	r9,sp[0x20]
8000aca2:	12 38       	cp.w	r8,r9
8000aca4:	c0 30       	breq	8000acaa <_dtoa_r+0xb56>
8000aca6:	10 95       	mov	r5,r8
8000aca8:	c0 88       	rjmp	8000acb8 <_dtoa_r+0xb64>
8000acaa:	2f f6       	sub	r6,-1
8000acac:	50 66       	stdsp	sp[0x18],r6
8000acae:	33 18       	mov	r8,49
8000acb0:	40 8c       	lddsp	r12,sp[0x20]
8000acb2:	b8 88       	st.b	r12[0x0],r8
8000acb4:	c1 38       	rjmp	8000acda <_dtoa_r+0xb86>
8000acb6:	33 9a       	mov	r10,57
8000acb8:	0a 98       	mov	r8,r5
8000acba:	11 79       	ld.ub	r9,--r8
8000acbc:	f4 09 18 00 	cp.b	r9,r10
8000acc0:	cf 00       	breq	8000aca0 <_dtoa_r+0xb4c>
8000acc2:	2f f9       	sub	r9,-1
8000acc4:	b0 89       	st.b	r8[0x0],r9
8000acc6:	c0 98       	rjmp	8000acd8 <_dtoa_r+0xb84>
8000acc8:	10 95       	mov	r5,r8
8000acca:	c0 28       	rjmp	8000acce <_dtoa_r+0xb7a>
8000accc:	33 09       	mov	r9,48
8000acce:	0a 98       	mov	r8,r5
8000acd0:	11 7a       	ld.ub	r10,--r8
8000acd2:	f2 0a 18 00 	cp.b	r10,r9
8000acd6:	cf 90       	breq	8000acc8 <_dtoa_r+0xb74>
8000acd8:	50 66       	stdsp	sp[0x18],r6
8000acda:	04 9b       	mov	r11,r2
8000acdc:	0e 9c       	mov	r12,r7
8000acde:	e0 a0 04 f3 	rcall	8000b6c4 <_Bfree>
8000ace2:	58 04       	cp.w	r4,0
8000ace4:	c1 20       	breq	8000ad08 <_dtoa_r+0xbb4>
8000ace6:	40 4b       	lddsp	r11,sp[0x10]
8000ace8:	08 3b       	cp.w	r11,r4
8000acea:	5f 19       	srne	r9
8000acec:	58 0b       	cp.w	r11,0
8000acee:	5f 18       	srne	r8
8000acf0:	f3 e8 00 08 	and	r8,r9,r8
8000acf4:	c0 40       	breq	8000acfc <_dtoa_r+0xba8>
8000acf6:	0e 9c       	mov	r12,r7
8000acf8:	e0 a0 04 e6 	rcall	8000b6c4 <_Bfree>
8000acfc:	08 9b       	mov	r11,r4
8000acfe:	0e 9c       	mov	r12,r7
8000ad00:	e0 a0 04 e2 	rcall	8000b6c4 <_Bfree>
8000ad04:	c0 28       	rjmp	8000ad08 <_dtoa_r+0xbb4>
8000ad06:	50 66       	stdsp	sp[0x18],r6
8000ad08:	0e 9c       	mov	r12,r7
8000ad0a:	06 9b       	mov	r11,r3
8000ad0c:	e0 a0 04 dc 	rcall	8000b6c4 <_Bfree>
8000ad10:	30 08       	mov	r8,0
8000ad12:	aa 88       	st.b	r5[0x0],r8
8000ad14:	40 68       	lddsp	r8,sp[0x18]
8000ad16:	41 5a       	lddsp	r10,sp[0x54]
8000ad18:	2f f8       	sub	r8,-1
8000ad1a:	41 29       	lddsp	r9,sp[0x48]
8000ad1c:	95 08       	st.w	r10[0x0],r8
8000ad1e:	40 8c       	lddsp	r12,sp[0x20]
8000ad20:	58 09       	cp.w	r9,0
8000ad22:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ad26:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ad2a:	2e 6d       	sub	sp,-104
8000ad2c:	d8 32       	popm	r0-r7,pc
8000ad2e:	d7 03       	nop

8000ad30 <__errno>:
8000ad30:	e0 68 0a 3c 	mov	r8,2620
8000ad34:	70 0c       	ld.w	r12,r8[0x0]
8000ad36:	2f 4c       	sub	r12,-12
8000ad38:	5e fc       	retal	r12
8000ad3a:	d7 03       	nop

8000ad3c <_fflush_r>:
8000ad3c:	d4 21       	pushm	r4-r7,lr
8000ad3e:	16 97       	mov	r7,r11
8000ad40:	18 96       	mov	r6,r12
8000ad42:	76 48       	ld.w	r8,r11[0x10]
8000ad44:	58 08       	cp.w	r8,0
8000ad46:	c7 f0       	breq	8000ae44 <_fflush_r+0x108>
8000ad48:	58 0c       	cp.w	r12,0
8000ad4a:	c0 50       	breq	8000ad54 <_fflush_r+0x18>
8000ad4c:	78 68       	ld.w	r8,r12[0x18]
8000ad4e:	58 08       	cp.w	r8,0
8000ad50:	c0 21       	brne	8000ad54 <_fflush_r+0x18>
8000ad52:	cc dc       	rcall	8000aeec <__sinit>
8000ad54:	fe c8 cc 20 	sub	r8,pc,-13280
8000ad58:	10 37       	cp.w	r7,r8
8000ad5a:	c0 31       	brne	8000ad60 <_fflush_r+0x24>
8000ad5c:	6c 07       	ld.w	r7,r6[0x0]
8000ad5e:	c0 c8       	rjmp	8000ad76 <_fflush_r+0x3a>
8000ad60:	fe c8 cc 0c 	sub	r8,pc,-13300
8000ad64:	10 37       	cp.w	r7,r8
8000ad66:	c0 31       	brne	8000ad6c <_fflush_r+0x30>
8000ad68:	6c 17       	ld.w	r7,r6[0x4]
8000ad6a:	c0 68       	rjmp	8000ad76 <_fflush_r+0x3a>
8000ad6c:	fe c8 cb f8 	sub	r8,pc,-13320
8000ad70:	10 37       	cp.w	r7,r8
8000ad72:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ad76:	8e 6a       	ld.sh	r10,r7[0xc]
8000ad78:	14 98       	mov	r8,r10
8000ad7a:	ed ba 00 03 	bld	r10,0x3
8000ad7e:	c4 20       	breq	8000ae02 <_fflush_r+0xc6>
8000ad80:	ab ba       	sbr	r10,0xb
8000ad82:	ae 6a       	st.h	r7[0xc],r10
8000ad84:	6e 18       	ld.w	r8,r7[0x4]
8000ad86:	58 08       	cp.w	r8,0
8000ad88:	e0 89 00 06 	brgt	8000ad94 <_fflush_r+0x58>
8000ad8c:	6f 08       	ld.w	r8,r7[0x40]
8000ad8e:	58 08       	cp.w	r8,0
8000ad90:	e0 8a 00 5a 	brle	8000ae44 <_fflush_r+0x108>
8000ad94:	6e b8       	ld.w	r8,r7[0x2c]
8000ad96:	58 08       	cp.w	r8,0
8000ad98:	c5 60       	breq	8000ae44 <_fflush_r+0x108>
8000ad9a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ad9e:	c0 30       	breq	8000ada4 <_fflush_r+0x68>
8000ada0:	6f 55       	ld.w	r5,r7[0x54]
8000ada2:	c0 f8       	rjmp	8000adc0 <_fflush_r+0x84>
8000ada4:	30 19       	mov	r9,1
8000ada6:	6e 8b       	ld.w	r11,r7[0x20]
8000ada8:	0c 9c       	mov	r12,r6
8000adaa:	5d 18       	icall	r8
8000adac:	18 95       	mov	r5,r12
8000adae:	5b fc       	cp.w	r12,-1
8000adb0:	c0 81       	brne	8000adc0 <_fflush_r+0x84>
8000adb2:	6c 38       	ld.w	r8,r6[0xc]
8000adb4:	59 d8       	cp.w	r8,29
8000adb6:	c4 70       	breq	8000ae44 <_fflush_r+0x108>
8000adb8:	8e 68       	ld.sh	r8,r7[0xc]
8000adba:	a7 a8       	sbr	r8,0x6
8000adbc:	ae 68       	st.h	r7[0xc],r8
8000adbe:	d8 22       	popm	r4-r7,pc
8000adc0:	8e 68       	ld.sh	r8,r7[0xc]
8000adc2:	ed b8 00 02 	bld	r8,0x2
8000adc6:	c0 91       	brne	8000add8 <_fflush_r+0x9c>
8000adc8:	6e 18       	ld.w	r8,r7[0x4]
8000adca:	10 15       	sub	r5,r8
8000adcc:	6e d8       	ld.w	r8,r7[0x34]
8000adce:	58 08       	cp.w	r8,0
8000add0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000add4:	eb d8 e1 15 	subne	r5,r5,r8
8000add8:	6e b8       	ld.w	r8,r7[0x2c]
8000adda:	0c 9c       	mov	r12,r6
8000addc:	30 09       	mov	r9,0
8000adde:	0a 9a       	mov	r10,r5
8000ade0:	6e 8b       	ld.w	r11,r7[0x20]
8000ade2:	5d 18       	icall	r8
8000ade4:	8e 68       	ld.sh	r8,r7[0xc]
8000ade6:	0a 3c       	cp.w	r12,r5
8000ade8:	c2 61       	brne	8000ae34 <_fflush_r+0xf8>
8000adea:	ab d8       	cbr	r8,0xb
8000adec:	30 0c       	mov	r12,0
8000adee:	6e 49       	ld.w	r9,r7[0x10]
8000adf0:	ae 68       	st.h	r7[0xc],r8
8000adf2:	8f 1c       	st.w	r7[0x4],r12
8000adf4:	8f 09       	st.w	r7[0x0],r9
8000adf6:	ed b8 00 0c 	bld	r8,0xc
8000adfa:	c2 51       	brne	8000ae44 <_fflush_r+0x108>
8000adfc:	ef 45 00 54 	st.w	r7[84],r5
8000ae00:	d8 22       	popm	r4-r7,pc
8000ae02:	6e 45       	ld.w	r5,r7[0x10]
8000ae04:	58 05       	cp.w	r5,0
8000ae06:	c1 f0       	breq	8000ae44 <_fflush_r+0x108>
8000ae08:	6e 04       	ld.w	r4,r7[0x0]
8000ae0a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ae0e:	8f 05       	st.w	r7[0x0],r5
8000ae10:	f9 b8 01 00 	movne	r8,0
8000ae14:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ae18:	0a 14       	sub	r4,r5
8000ae1a:	8f 28       	st.w	r7[0x8],r8
8000ae1c:	c1 18       	rjmp	8000ae3e <_fflush_r+0x102>
8000ae1e:	08 99       	mov	r9,r4
8000ae20:	0a 9a       	mov	r10,r5
8000ae22:	6e a8       	ld.w	r8,r7[0x28]
8000ae24:	6e 8b       	ld.w	r11,r7[0x20]
8000ae26:	0c 9c       	mov	r12,r6
8000ae28:	5d 18       	icall	r8
8000ae2a:	18 14       	sub	r4,r12
8000ae2c:	58 0c       	cp.w	r12,0
8000ae2e:	e0 89 00 07 	brgt	8000ae3c <_fflush_r+0x100>
8000ae32:	8e 68       	ld.sh	r8,r7[0xc]
8000ae34:	a7 a8       	sbr	r8,0x6
8000ae36:	3f fc       	mov	r12,-1
8000ae38:	ae 68       	st.h	r7[0xc],r8
8000ae3a:	d8 22       	popm	r4-r7,pc
8000ae3c:	18 05       	add	r5,r12
8000ae3e:	58 04       	cp.w	r4,0
8000ae40:	fe 99 ff ef 	brgt	8000ae1e <_fflush_r+0xe2>
8000ae44:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae46:	d7 03       	nop

8000ae48 <__sfp_lock_acquire>:
8000ae48:	5e fc       	retal	r12

8000ae4a <__sfp_lock_release>:
8000ae4a:	5e fc       	retal	r12

8000ae4c <_cleanup_r>:
8000ae4c:	d4 01       	pushm	lr
8000ae4e:	fe cb f0 ae 	sub	r11,pc,-3922
8000ae52:	e0 a0 02 f7 	rcall	8000b440 <_fwalk>
8000ae56:	d8 02       	popm	pc

8000ae58 <__sfmoreglue>:
8000ae58:	d4 21       	pushm	r4-r7,lr
8000ae5a:	16 95       	mov	r5,r11
8000ae5c:	f6 06 10 5c 	mul	r6,r11,92
8000ae60:	ec cb ff f4 	sub	r11,r6,-12
8000ae64:	fe b0 e2 88 	rcall	80007374 <_malloc_r>
8000ae68:	18 97       	mov	r7,r12
8000ae6a:	c0 90       	breq	8000ae7c <__sfmoreglue+0x24>
8000ae6c:	99 15       	st.w	r12[0x4],r5
8000ae6e:	30 0b       	mov	r11,0
8000ae70:	2f 4c       	sub	r12,-12
8000ae72:	0c 9a       	mov	r10,r6
8000ae74:	8f 2c       	st.w	r7[0x8],r12
8000ae76:	8f 0b       	st.w	r7[0x0],r11
8000ae78:	fe b0 e5 3e 	rcall	800078f4 <memset>
8000ae7c:	0e 9c       	mov	r12,r7
8000ae7e:	d8 22       	popm	r4-r7,pc

8000ae80 <__sfp>:
8000ae80:	d4 21       	pushm	r4-r7,lr
8000ae82:	fe c8 cc ea 	sub	r8,pc,-13078
8000ae86:	18 96       	mov	r6,r12
8000ae88:	70 07       	ld.w	r7,r8[0x0]
8000ae8a:	6e 68       	ld.w	r8,r7[0x18]
8000ae8c:	58 08       	cp.w	r8,0
8000ae8e:	c0 31       	brne	8000ae94 <__sfp+0x14>
8000ae90:	0e 9c       	mov	r12,r7
8000ae92:	c2 dc       	rcall	8000aeec <__sinit>
8000ae94:	ee c7 ff 28 	sub	r7,r7,-216
8000ae98:	30 05       	mov	r5,0
8000ae9a:	6e 2c       	ld.w	r12,r7[0x8]
8000ae9c:	6e 18       	ld.w	r8,r7[0x4]
8000ae9e:	c0 68       	rjmp	8000aeaa <__sfp+0x2a>
8000aea0:	98 69       	ld.sh	r9,r12[0xc]
8000aea2:	ea 09 19 00 	cp.h	r9,r5
8000aea6:	c1 10       	breq	8000aec8 <__sfp+0x48>
8000aea8:	2a 4c       	sub	r12,-92
8000aeaa:	20 18       	sub	r8,1
8000aeac:	cf a7       	brpl	8000aea0 <__sfp+0x20>
8000aeae:	6e 08       	ld.w	r8,r7[0x0]
8000aeb0:	58 08       	cp.w	r8,0
8000aeb2:	c0 61       	brne	8000aebe <__sfp+0x3e>
8000aeb4:	30 4b       	mov	r11,4
8000aeb6:	0c 9c       	mov	r12,r6
8000aeb8:	cd 0f       	rcall	8000ae58 <__sfmoreglue>
8000aeba:	8f 0c       	st.w	r7[0x0],r12
8000aebc:	c0 30       	breq	8000aec2 <__sfp+0x42>
8000aebe:	6e 07       	ld.w	r7,r7[0x0]
8000aec0:	ce db       	rjmp	8000ae9a <__sfp+0x1a>
8000aec2:	30 c8       	mov	r8,12
8000aec4:	8d 38       	st.w	r6[0xc],r8
8000aec6:	d8 22       	popm	r4-r7,pc
8000aec8:	30 08       	mov	r8,0
8000aeca:	f9 48 00 4c 	st.w	r12[76],r8
8000aece:	99 08       	st.w	r12[0x0],r8
8000aed0:	99 28       	st.w	r12[0x8],r8
8000aed2:	99 18       	st.w	r12[0x4],r8
8000aed4:	99 48       	st.w	r12[0x10],r8
8000aed6:	99 58       	st.w	r12[0x14],r8
8000aed8:	99 68       	st.w	r12[0x18],r8
8000aeda:	99 d8       	st.w	r12[0x34],r8
8000aedc:	99 e8       	st.w	r12[0x38],r8
8000aede:	f9 48 00 48 	st.w	r12[72],r8
8000aee2:	3f f8       	mov	r8,-1
8000aee4:	b8 78       	st.h	r12[0xe],r8
8000aee6:	30 18       	mov	r8,1
8000aee8:	b8 68       	st.h	r12[0xc],r8
8000aeea:	d8 22       	popm	r4-r7,pc

8000aeec <__sinit>:
8000aeec:	d4 21       	pushm	r4-r7,lr
8000aeee:	18 96       	mov	r6,r12
8000aef0:	78 67       	ld.w	r7,r12[0x18]
8000aef2:	58 07       	cp.w	r7,0
8000aef4:	c4 91       	brne	8000af86 <__sinit+0x9a>
8000aef6:	fe c8 00 aa 	sub	r8,pc,170
8000aefa:	30 15       	mov	r5,1
8000aefc:	99 a8       	st.w	r12[0x28],r8
8000aefe:	f9 47 00 d8 	st.w	r12[216],r7
8000af02:	f9 47 00 dc 	st.w	r12[220],r7
8000af06:	f9 47 00 e0 	st.w	r12[224],r7
8000af0a:	99 65       	st.w	r12[0x18],r5
8000af0c:	cb af       	rcall	8000ae80 <__sfp>
8000af0e:	8d 0c       	st.w	r6[0x0],r12
8000af10:	0c 9c       	mov	r12,r6
8000af12:	cb 7f       	rcall	8000ae80 <__sfp>
8000af14:	8d 1c       	st.w	r6[0x4],r12
8000af16:	0c 9c       	mov	r12,r6
8000af18:	cb 4f       	rcall	8000ae80 <__sfp>
8000af1a:	6c 09       	ld.w	r9,r6[0x0]
8000af1c:	30 48       	mov	r8,4
8000af1e:	93 07       	st.w	r9[0x0],r7
8000af20:	b2 68       	st.h	r9[0xc],r8
8000af22:	93 17       	st.w	r9[0x4],r7
8000af24:	93 27       	st.w	r9[0x8],r7
8000af26:	6c 18       	ld.w	r8,r6[0x4]
8000af28:	b2 77       	st.h	r9[0xe],r7
8000af2a:	93 47       	st.w	r9[0x10],r7
8000af2c:	93 57       	st.w	r9[0x14],r7
8000af2e:	93 67       	st.w	r9[0x18],r7
8000af30:	93 89       	st.w	r9[0x20],r9
8000af32:	91 07       	st.w	r8[0x0],r7
8000af34:	91 17       	st.w	r8[0x4],r7
8000af36:	91 27       	st.w	r8[0x8],r7
8000af38:	fe ce f3 24 	sub	lr,pc,-3292
8000af3c:	fe cb f3 54 	sub	r11,pc,-3244
8000af40:	93 9e       	st.w	r9[0x24],lr
8000af42:	93 ab       	st.w	r9[0x28],r11
8000af44:	fe ca f3 7c 	sub	r10,pc,-3204
8000af48:	fe c4 f3 88 	sub	r4,pc,-3192
8000af4c:	93 ba       	st.w	r9[0x2c],r10
8000af4e:	93 c4       	st.w	r9[0x30],r4
8000af50:	30 99       	mov	r9,9
8000af52:	b0 69       	st.h	r8[0xc],r9
8000af54:	b0 75       	st.h	r8[0xe],r5
8000af56:	91 c4       	st.w	r8[0x30],r4
8000af58:	91 47       	st.w	r8[0x10],r7
8000af5a:	91 57       	st.w	r8[0x14],r7
8000af5c:	91 67       	st.w	r8[0x18],r7
8000af5e:	91 88       	st.w	r8[0x20],r8
8000af60:	91 9e       	st.w	r8[0x24],lr
8000af62:	91 ab       	st.w	r8[0x28],r11
8000af64:	91 ba       	st.w	r8[0x2c],r10
8000af66:	8d 2c       	st.w	r6[0x8],r12
8000af68:	31 28       	mov	r8,18
8000af6a:	99 07       	st.w	r12[0x0],r7
8000af6c:	b8 68       	st.h	r12[0xc],r8
8000af6e:	99 17       	st.w	r12[0x4],r7
8000af70:	99 27       	st.w	r12[0x8],r7
8000af72:	30 28       	mov	r8,2
8000af74:	b8 78       	st.h	r12[0xe],r8
8000af76:	99 c4       	st.w	r12[0x30],r4
8000af78:	99 67       	st.w	r12[0x18],r7
8000af7a:	99 9e       	st.w	r12[0x24],lr
8000af7c:	99 ab       	st.w	r12[0x28],r11
8000af7e:	99 ba       	st.w	r12[0x2c],r10
8000af80:	99 47       	st.w	r12[0x10],r7
8000af82:	99 57       	st.w	r12[0x14],r7
8000af84:	99 8c       	st.w	r12[0x20],r12
8000af86:	d8 22       	popm	r4-r7,pc

8000af88 <_malloc_trim_r>:
8000af88:	d4 21       	pushm	r4-r7,lr
8000af8a:	16 95       	mov	r5,r11
8000af8c:	18 97       	mov	r7,r12
8000af8e:	fe b0 d7 a1 	rcall	80005ed0 <__malloc_lock>
8000af92:	e0 64 05 3c 	mov	r4,1340
8000af96:	68 28       	ld.w	r8,r4[0x8]
8000af98:	70 16       	ld.w	r6,r8[0x4]
8000af9a:	e0 16 ff fc 	andl	r6,0xfffc
8000af9e:	ec c8 ff 91 	sub	r8,r6,-111
8000afa2:	f0 05 01 05 	sub	r5,r8,r5
8000afa6:	e0 15 ff 80 	andl	r5,0xff80
8000afaa:	ea c5 00 80 	sub	r5,r5,128
8000afae:	e0 45 00 7f 	cp.w	r5,127
8000afb2:	e0 8a 00 25 	brle	8000affc <_malloc_trim_r+0x74>
8000afb6:	30 0b       	mov	r11,0
8000afb8:	0e 9c       	mov	r12,r7
8000afba:	fe b0 e6 05 	rcall	80007bc4 <_sbrk_r>
8000afbe:	68 28       	ld.w	r8,r4[0x8]
8000afc0:	0c 08       	add	r8,r6
8000afc2:	10 3c       	cp.w	r12,r8
8000afc4:	c1 c1       	brne	8000affc <_malloc_trim_r+0x74>
8000afc6:	ea 0b 11 00 	rsub	r11,r5,0
8000afca:	0e 9c       	mov	r12,r7
8000afcc:	fe b0 e5 fc 	rcall	80007bc4 <_sbrk_r>
8000afd0:	5b fc       	cp.w	r12,-1
8000afd2:	c1 91       	brne	8000b004 <_malloc_trim_r+0x7c>
8000afd4:	30 0b       	mov	r11,0
8000afd6:	0e 9c       	mov	r12,r7
8000afd8:	fe b0 e5 f6 	rcall	80007bc4 <_sbrk_r>
8000afdc:	68 28       	ld.w	r8,r4[0x8]
8000afde:	f8 08 01 09 	sub	r9,r12,r8
8000afe2:	58 f9       	cp.w	r9,15
8000afe4:	e0 8a 00 0c 	brle	8000affc <_malloc_trim_r+0x74>
8000afe8:	a1 a9       	sbr	r9,0x0
8000afea:	91 19       	st.w	r8[0x4],r9
8000afec:	e0 68 09 48 	mov	r8,2376
8000aff0:	70 09       	ld.w	r9,r8[0x0]
8000aff2:	e0 68 0d 74 	mov	r8,3444
8000aff6:	f8 09 01 09 	sub	r9,r12,r9
8000affa:	91 09       	st.w	r8[0x0],r9
8000affc:	0e 9c       	mov	r12,r7
8000affe:	fe b0 d7 6f 	rcall	80005edc <__malloc_unlock>
8000b002:	d8 2a       	popm	r4-r7,pc,r12=0
8000b004:	68 28       	ld.w	r8,r4[0x8]
8000b006:	0a 16       	sub	r6,r5
8000b008:	a1 a6       	sbr	r6,0x0
8000b00a:	91 16       	st.w	r8[0x4],r6
8000b00c:	e0 68 0d 74 	mov	r8,3444
8000b010:	70 09       	ld.w	r9,r8[0x0]
8000b012:	0a 19       	sub	r9,r5
8000b014:	0e 9c       	mov	r12,r7
8000b016:	91 09       	st.w	r8[0x0],r9
8000b018:	fe b0 d7 62 	rcall	80005edc <__malloc_unlock>
8000b01c:	da 2a       	popm	r4-r7,pc,r12=1
8000b01e:	d7 03       	nop

8000b020 <_free_r>:
8000b020:	d4 21       	pushm	r4-r7,lr
8000b022:	16 96       	mov	r6,r11
8000b024:	18 97       	mov	r7,r12
8000b026:	58 0b       	cp.w	r11,0
8000b028:	e0 80 00 c0 	breq	8000b1a8 <_free_r+0x188>
8000b02c:	fe b0 d7 52 	rcall	80005ed0 <__malloc_lock>
8000b030:	20 86       	sub	r6,8
8000b032:	e0 6a 05 3c 	mov	r10,1340
8000b036:	6c 18       	ld.w	r8,r6[0x4]
8000b038:	74 2e       	ld.w	lr,r10[0x8]
8000b03a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b03e:	a1 c8       	cbr	r8,0x0
8000b040:	ec 08 00 09 	add	r9,r6,r8
8000b044:	72 1b       	ld.w	r11,r9[0x4]
8000b046:	e0 1b ff fc 	andl	r11,0xfffc
8000b04a:	1c 39       	cp.w	r9,lr
8000b04c:	c1 e1       	brne	8000b088 <_free_r+0x68>
8000b04e:	f6 08 00 08 	add	r8,r11,r8
8000b052:	58 0c       	cp.w	r12,0
8000b054:	c0 81       	brne	8000b064 <_free_r+0x44>
8000b056:	6c 09       	ld.w	r9,r6[0x0]
8000b058:	12 16       	sub	r6,r9
8000b05a:	12 08       	add	r8,r9
8000b05c:	6c 3b       	ld.w	r11,r6[0xc]
8000b05e:	6c 29       	ld.w	r9,r6[0x8]
8000b060:	97 29       	st.w	r11[0x8],r9
8000b062:	93 3b       	st.w	r9[0xc],r11
8000b064:	10 99       	mov	r9,r8
8000b066:	95 26       	st.w	r10[0x8],r6
8000b068:	a1 a9       	sbr	r9,0x0
8000b06a:	8d 19       	st.w	r6[0x4],r9
8000b06c:	e0 69 09 44 	mov	r9,2372
8000b070:	72 09       	ld.w	r9,r9[0x0]
8000b072:	12 38       	cp.w	r8,r9
8000b074:	c0 63       	brcs	8000b080 <_free_r+0x60>
8000b076:	e0 68 0d 70 	mov	r8,3440
8000b07a:	0e 9c       	mov	r12,r7
8000b07c:	70 0b       	ld.w	r11,r8[0x0]
8000b07e:	c8 5f       	rcall	8000af88 <_malloc_trim_r>
8000b080:	0e 9c       	mov	r12,r7
8000b082:	fe b0 d7 2d 	rcall	80005edc <__malloc_unlock>
8000b086:	d8 22       	popm	r4-r7,pc
8000b088:	93 1b       	st.w	r9[0x4],r11
8000b08a:	58 0c       	cp.w	r12,0
8000b08c:	c0 30       	breq	8000b092 <_free_r+0x72>
8000b08e:	30 0c       	mov	r12,0
8000b090:	c1 08       	rjmp	8000b0b0 <_free_r+0x90>
8000b092:	6c 0e       	ld.w	lr,r6[0x0]
8000b094:	f4 c5 ff f8 	sub	r5,r10,-8
8000b098:	1c 16       	sub	r6,lr
8000b09a:	1c 08       	add	r8,lr
8000b09c:	6c 2e       	ld.w	lr,r6[0x8]
8000b09e:	0a 3e       	cp.w	lr,r5
8000b0a0:	f9 bc 00 01 	moveq	r12,1
8000b0a4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b0a8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b0ac:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b0b0:	f2 0b 00 0e 	add	lr,r9,r11
8000b0b4:	7c 1e       	ld.w	lr,lr[0x4]
8000b0b6:	ed be 00 00 	bld	lr,0x0
8000b0ba:	c1 40       	breq	8000b0e2 <_free_r+0xc2>
8000b0bc:	16 08       	add	r8,r11
8000b0be:	58 0c       	cp.w	r12,0
8000b0c0:	c0 d1       	brne	8000b0da <_free_r+0xba>
8000b0c2:	e0 6e 05 3c 	mov	lr,1340
8000b0c6:	72 2b       	ld.w	r11,r9[0x8]
8000b0c8:	2f 8e       	sub	lr,-8
8000b0ca:	1c 3b       	cp.w	r11,lr
8000b0cc:	c0 71       	brne	8000b0da <_free_r+0xba>
8000b0ce:	97 36       	st.w	r11[0xc],r6
8000b0d0:	97 26       	st.w	r11[0x8],r6
8000b0d2:	8d 2b       	st.w	r6[0x8],r11
8000b0d4:	8d 3b       	st.w	r6[0xc],r11
8000b0d6:	30 1c       	mov	r12,1
8000b0d8:	c0 58       	rjmp	8000b0e2 <_free_r+0xc2>
8000b0da:	72 2b       	ld.w	r11,r9[0x8]
8000b0dc:	72 39       	ld.w	r9,r9[0xc]
8000b0de:	93 2b       	st.w	r9[0x8],r11
8000b0e0:	97 39       	st.w	r11[0xc],r9
8000b0e2:	10 99       	mov	r9,r8
8000b0e4:	ec 08 09 08 	st.w	r6[r8],r8
8000b0e8:	a1 a9       	sbr	r9,0x0
8000b0ea:	8d 19       	st.w	r6[0x4],r9
8000b0ec:	58 0c       	cp.w	r12,0
8000b0ee:	c5 a1       	brne	8000b1a2 <_free_r+0x182>
8000b0f0:	e0 48 01 ff 	cp.w	r8,511
8000b0f4:	e0 8b 00 13 	brhi	8000b11a <_free_r+0xfa>
8000b0f8:	a3 98       	lsr	r8,0x3
8000b0fa:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b0fe:	72 2b       	ld.w	r11,r9[0x8]
8000b100:	8d 39       	st.w	r6[0xc],r9
8000b102:	8d 2b       	st.w	r6[0x8],r11
8000b104:	97 36       	st.w	r11[0xc],r6
8000b106:	93 26       	st.w	r9[0x8],r6
8000b108:	a3 48       	asr	r8,0x2
8000b10a:	74 19       	ld.w	r9,r10[0x4]
8000b10c:	30 1b       	mov	r11,1
8000b10e:	f6 08 09 48 	lsl	r8,r11,r8
8000b112:	f3 e8 10 08 	or	r8,r9,r8
8000b116:	95 18       	st.w	r10[0x4],r8
8000b118:	c4 58       	rjmp	8000b1a2 <_free_r+0x182>
8000b11a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b11e:	58 4b       	cp.w	r11,4
8000b120:	e0 8b 00 06 	brhi	8000b12c <_free_r+0x10c>
8000b124:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b128:	2c 8b       	sub	r11,-56
8000b12a:	c2 08       	rjmp	8000b16a <_free_r+0x14a>
8000b12c:	59 4b       	cp.w	r11,20
8000b12e:	e0 8b 00 04 	brhi	8000b136 <_free_r+0x116>
8000b132:	2a 5b       	sub	r11,-91
8000b134:	c1 b8       	rjmp	8000b16a <_free_r+0x14a>
8000b136:	e0 4b 00 54 	cp.w	r11,84
8000b13a:	e0 8b 00 06 	brhi	8000b146 <_free_r+0x126>
8000b13e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b142:	29 2b       	sub	r11,-110
8000b144:	c1 38       	rjmp	8000b16a <_free_r+0x14a>
8000b146:	e0 4b 01 54 	cp.w	r11,340
8000b14a:	e0 8b 00 06 	brhi	8000b156 <_free_r+0x136>
8000b14e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b152:	28 9b       	sub	r11,-119
8000b154:	c0 b8       	rjmp	8000b16a <_free_r+0x14a>
8000b156:	e0 4b 05 54 	cp.w	r11,1364
8000b15a:	e0 88 00 05 	brls	8000b164 <_free_r+0x144>
8000b15e:	37 eb       	mov	r11,126
8000b160:	c0 58       	rjmp	8000b16a <_free_r+0x14a>
8000b162:	d7 03       	nop
8000b164:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b168:	28 4b       	sub	r11,-124
8000b16a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b16e:	78 29       	ld.w	r9,r12[0x8]
8000b170:	18 39       	cp.w	r9,r12
8000b172:	c0 e1       	brne	8000b18e <_free_r+0x16e>
8000b174:	74 18       	ld.w	r8,r10[0x4]
8000b176:	a3 4b       	asr	r11,0x2
8000b178:	30 1c       	mov	r12,1
8000b17a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b17e:	f1 eb 10 0b 	or	r11,r8,r11
8000b182:	12 98       	mov	r8,r9
8000b184:	95 1b       	st.w	r10[0x4],r11
8000b186:	c0 a8       	rjmp	8000b19a <_free_r+0x17a>
8000b188:	72 29       	ld.w	r9,r9[0x8]
8000b18a:	18 39       	cp.w	r9,r12
8000b18c:	c0 60       	breq	8000b198 <_free_r+0x178>
8000b18e:	72 1a       	ld.w	r10,r9[0x4]
8000b190:	e0 1a ff fc 	andl	r10,0xfffc
8000b194:	14 38       	cp.w	r8,r10
8000b196:	cf 93       	brcs	8000b188 <_free_r+0x168>
8000b198:	72 38       	ld.w	r8,r9[0xc]
8000b19a:	8d 38       	st.w	r6[0xc],r8
8000b19c:	8d 29       	st.w	r6[0x8],r9
8000b19e:	93 36       	st.w	r9[0xc],r6
8000b1a0:	91 26       	st.w	r8[0x8],r6
8000b1a2:	0e 9c       	mov	r12,r7
8000b1a4:	fe b0 d6 9c 	rcall	80005edc <__malloc_unlock>
8000b1a8:	d8 22       	popm	r4-r7,pc
8000b1aa:	d7 03       	nop

8000b1ac <__sfvwrite_r>:
8000b1ac:	d4 31       	pushm	r0-r7,lr
8000b1ae:	20 3d       	sub	sp,12
8000b1b0:	14 94       	mov	r4,r10
8000b1b2:	18 95       	mov	r5,r12
8000b1b4:	16 97       	mov	r7,r11
8000b1b6:	74 28       	ld.w	r8,r10[0x8]
8000b1b8:	58 08       	cp.w	r8,0
8000b1ba:	e0 80 01 40 	breq	8000b43a <__sfvwrite_r+0x28e>
8000b1be:	96 68       	ld.sh	r8,r11[0xc]
8000b1c0:	ed b8 00 03 	bld	r8,0x3
8000b1c4:	c0 41       	brne	8000b1cc <__sfvwrite_r+0x20>
8000b1c6:	76 48       	ld.w	r8,r11[0x10]
8000b1c8:	58 08       	cp.w	r8,0
8000b1ca:	c0 c1       	brne	8000b1e2 <__sfvwrite_r+0x36>
8000b1cc:	0e 9b       	mov	r11,r7
8000b1ce:	0a 9c       	mov	r12,r5
8000b1d0:	fe b0 f6 c4 	rcall	80009f58 <__swsetup_r>
8000b1d4:	c0 70       	breq	8000b1e2 <__sfvwrite_r+0x36>
8000b1d6:	8e 68       	ld.sh	r8,r7[0xc]
8000b1d8:	a7 a8       	sbr	r8,0x6
8000b1da:	ae 68       	st.h	r7[0xc],r8
8000b1dc:	30 98       	mov	r8,9
8000b1de:	8b 38       	st.w	r5[0xc],r8
8000b1e0:	c2 b9       	rjmp	8000b436 <__sfvwrite_r+0x28a>
8000b1e2:	8e 63       	ld.sh	r3,r7[0xc]
8000b1e4:	68 00       	ld.w	r0,r4[0x0]
8000b1e6:	06 96       	mov	r6,r3
8000b1e8:	e2 16 00 02 	andl	r6,0x2,COH
8000b1ec:	c2 10       	breq	8000b22e <__sfvwrite_r+0x82>
8000b1ee:	30 03       	mov	r3,0
8000b1f0:	e0 62 04 00 	mov	r2,1024
8000b1f4:	06 96       	mov	r6,r3
8000b1f6:	c0 48       	rjmp	8000b1fe <__sfvwrite_r+0x52>
8000b1f8:	60 03       	ld.w	r3,r0[0x0]
8000b1fa:	60 16       	ld.w	r6,r0[0x4]
8000b1fc:	2f 80       	sub	r0,-8
8000b1fe:	58 06       	cp.w	r6,0
8000b200:	cf c0       	breq	8000b1f8 <__sfvwrite_r+0x4c>
8000b202:	e0 46 04 00 	cp.w	r6,1024
8000b206:	ec 09 17 80 	movls	r9,r6
8000b20a:	e4 09 17 b0 	movhi	r9,r2
8000b20e:	06 9a       	mov	r10,r3
8000b210:	6e a8       	ld.w	r8,r7[0x28]
8000b212:	6e 8b       	ld.w	r11,r7[0x20]
8000b214:	0a 9c       	mov	r12,r5
8000b216:	5d 18       	icall	r8
8000b218:	18 16       	sub	r6,r12
8000b21a:	58 0c       	cp.w	r12,0
8000b21c:	e0 8a 01 0a 	brle	8000b430 <__sfvwrite_r+0x284>
8000b220:	68 28       	ld.w	r8,r4[0x8]
8000b222:	18 18       	sub	r8,r12
8000b224:	89 28       	st.w	r4[0x8],r8
8000b226:	e0 80 01 0a 	breq	8000b43a <__sfvwrite_r+0x28e>
8000b22a:	18 03       	add	r3,r12
8000b22c:	ce 9b       	rjmp	8000b1fe <__sfvwrite_r+0x52>
8000b22e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b232:	c0 70       	breq	8000b240 <__sfvwrite_r+0x94>
8000b234:	50 06       	stdsp	sp[0x0],r6
8000b236:	0c 93       	mov	r3,r6
8000b238:	0c 91       	mov	r1,r6
8000b23a:	50 15       	stdsp	sp[0x4],r5
8000b23c:	08 92       	mov	r2,r4
8000b23e:	c9 c8       	rjmp	8000b376 <__sfvwrite_r+0x1ca>
8000b240:	06 96       	mov	r6,r3
8000b242:	08 91       	mov	r1,r4
8000b244:	c0 48       	rjmp	8000b24c <__sfvwrite_r+0xa0>
8000b246:	60 03       	ld.w	r3,r0[0x0]
8000b248:	60 16       	ld.w	r6,r0[0x4]
8000b24a:	2f 80       	sub	r0,-8
8000b24c:	58 06       	cp.w	r6,0
8000b24e:	cf c0       	breq	8000b246 <__sfvwrite_r+0x9a>
8000b250:	8e 68       	ld.sh	r8,r7[0xc]
8000b252:	6e 24       	ld.w	r4,r7[0x8]
8000b254:	10 99       	mov	r9,r8
8000b256:	e2 19 02 00 	andl	r9,0x200,COH
8000b25a:	c5 50       	breq	8000b304 <__sfvwrite_r+0x158>
8000b25c:	08 36       	cp.w	r6,r4
8000b25e:	c4 43       	brcs	8000b2e6 <__sfvwrite_r+0x13a>
8000b260:	10 99       	mov	r9,r8
8000b262:	e2 19 04 80 	andl	r9,0x480,COH
8000b266:	c4 00       	breq	8000b2e6 <__sfvwrite_r+0x13a>
8000b268:	6e 4b       	ld.w	r11,r7[0x10]
8000b26a:	6e 09       	ld.w	r9,r7[0x0]
8000b26c:	16 19       	sub	r9,r11
8000b26e:	50 09       	stdsp	sp[0x0],r9
8000b270:	6e 59       	ld.w	r9,r7[0x14]
8000b272:	10 9c       	mov	r12,r8
8000b274:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b278:	30 28       	mov	r8,2
8000b27a:	f4 08 0c 08 	divs	r8,r10,r8
8000b27e:	fa e9 00 04 	st.d	sp[4],r8
8000b282:	10 94       	mov	r4,r8
8000b284:	40 09       	lddsp	r9,sp[0x0]
8000b286:	e2 1c 04 00 	andl	r12,0x400,COH
8000b28a:	2f f9       	sub	r9,-1
8000b28c:	0c 09       	add	r9,r6
8000b28e:	12 38       	cp.w	r8,r9
8000b290:	f2 04 17 30 	movlo	r4,r9
8000b294:	58 0c       	cp.w	r12,0
8000b296:	c1 10       	breq	8000b2b8 <__sfvwrite_r+0x10c>
8000b298:	08 9b       	mov	r11,r4
8000b29a:	0a 9c       	mov	r12,r5
8000b29c:	fe b0 e0 6c 	rcall	80007374 <_malloc_r>
8000b2a0:	18 92       	mov	r2,r12
8000b2a2:	c1 40       	breq	8000b2ca <__sfvwrite_r+0x11e>
8000b2a4:	40 0a       	lddsp	r10,sp[0x0]
8000b2a6:	6e 4b       	ld.w	r11,r7[0x10]
8000b2a8:	fe b0 e2 82 	rcall	800077ac <memcpy>
8000b2ac:	8e 68       	ld.sh	r8,r7[0xc]
8000b2ae:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b2b2:	a7 b8       	sbr	r8,0x7
8000b2b4:	ae 68       	st.h	r7[0xc],r8
8000b2b6:	c0 d8       	rjmp	8000b2d0 <__sfvwrite_r+0x124>
8000b2b8:	08 9a       	mov	r10,r4
8000b2ba:	0a 9c       	mov	r12,r5
8000b2bc:	fe b0 e3 24 	rcall	80007904 <_realloc_r>
8000b2c0:	18 92       	mov	r2,r12
8000b2c2:	c0 71       	brne	8000b2d0 <__sfvwrite_r+0x124>
8000b2c4:	6e 4b       	ld.w	r11,r7[0x10]
8000b2c6:	0a 9c       	mov	r12,r5
8000b2c8:	ca ce       	rcall	8000b020 <_free_r>
8000b2ca:	30 c8       	mov	r8,12
8000b2cc:	8b 38       	st.w	r5[0xc],r8
8000b2ce:	cb 18       	rjmp	8000b430 <__sfvwrite_r+0x284>
8000b2d0:	40 0a       	lddsp	r10,sp[0x0]
8000b2d2:	40 09       	lddsp	r9,sp[0x0]
8000b2d4:	e8 0a 01 0a 	sub	r10,r4,r10
8000b2d8:	e4 09 00 08 	add	r8,r2,r9
8000b2dc:	8f 54       	st.w	r7[0x14],r4
8000b2de:	8f 2a       	st.w	r7[0x8],r10
8000b2e0:	8f 08       	st.w	r7[0x0],r8
8000b2e2:	8f 42       	st.w	r7[0x10],r2
8000b2e4:	0c 94       	mov	r4,r6
8000b2e6:	08 36       	cp.w	r6,r4
8000b2e8:	ec 04 17 30 	movlo	r4,r6
8000b2ec:	06 9b       	mov	r11,r3
8000b2ee:	08 9a       	mov	r10,r4
8000b2f0:	6e 0c       	ld.w	r12,r7[0x0]
8000b2f2:	c3 ad       	rcall	8000b566 <memmove>
8000b2f4:	6e 08       	ld.w	r8,r7[0x0]
8000b2f6:	08 08       	add	r8,r4
8000b2f8:	8f 08       	st.w	r7[0x0],r8
8000b2fa:	6e 28       	ld.w	r8,r7[0x8]
8000b2fc:	08 18       	sub	r8,r4
8000b2fe:	0c 94       	mov	r4,r6
8000b300:	8f 28       	st.w	r7[0x8],r8
8000b302:	c2 e8       	rjmp	8000b35e <__sfvwrite_r+0x1b2>
8000b304:	08 36       	cp.w	r6,r4
8000b306:	5f ba       	srhi	r10
8000b308:	6e 0c       	ld.w	r12,r7[0x0]
8000b30a:	6e 48       	ld.w	r8,r7[0x10]
8000b30c:	10 3c       	cp.w	r12,r8
8000b30e:	5f b8       	srhi	r8
8000b310:	f5 e8 00 08 	and	r8,r10,r8
8000b314:	f2 08 18 00 	cp.b	r8,r9
8000b318:	c0 d0       	breq	8000b332 <__sfvwrite_r+0x186>
8000b31a:	06 9b       	mov	r11,r3
8000b31c:	08 9a       	mov	r10,r4
8000b31e:	c2 4d       	rcall	8000b566 <memmove>
8000b320:	6e 08       	ld.w	r8,r7[0x0]
8000b322:	08 08       	add	r8,r4
8000b324:	0e 9b       	mov	r11,r7
8000b326:	8f 08       	st.w	r7[0x0],r8
8000b328:	0a 9c       	mov	r12,r5
8000b32a:	fe b0 fd 09 	rcall	8000ad3c <_fflush_r>
8000b32e:	c1 80       	breq	8000b35e <__sfvwrite_r+0x1b2>
8000b330:	c8 08       	rjmp	8000b430 <__sfvwrite_r+0x284>
8000b332:	6e 59       	ld.w	r9,r7[0x14]
8000b334:	12 36       	cp.w	r6,r9
8000b336:	c0 a3       	brcs	8000b34a <__sfvwrite_r+0x19e>
8000b338:	6e a8       	ld.w	r8,r7[0x28]
8000b33a:	06 9a       	mov	r10,r3
8000b33c:	6e 8b       	ld.w	r11,r7[0x20]
8000b33e:	0a 9c       	mov	r12,r5
8000b340:	5d 18       	icall	r8
8000b342:	18 94       	mov	r4,r12
8000b344:	e0 89 00 0d 	brgt	8000b35e <__sfvwrite_r+0x1b2>
8000b348:	c7 48       	rjmp	8000b430 <__sfvwrite_r+0x284>
8000b34a:	0c 9a       	mov	r10,r6
8000b34c:	06 9b       	mov	r11,r3
8000b34e:	c0 cd       	rcall	8000b566 <memmove>
8000b350:	6e 08       	ld.w	r8,r7[0x0]
8000b352:	0c 08       	add	r8,r6
8000b354:	0c 94       	mov	r4,r6
8000b356:	8f 08       	st.w	r7[0x0],r8
8000b358:	6e 28       	ld.w	r8,r7[0x8]
8000b35a:	0c 18       	sub	r8,r6
8000b35c:	8f 28       	st.w	r7[0x8],r8
8000b35e:	62 28       	ld.w	r8,r1[0x8]
8000b360:	08 18       	sub	r8,r4
8000b362:	83 28       	st.w	r1[0x8],r8
8000b364:	c6 b0       	breq	8000b43a <__sfvwrite_r+0x28e>
8000b366:	08 16       	sub	r6,r4
8000b368:	08 03       	add	r3,r4
8000b36a:	c7 1b       	rjmp	8000b24c <__sfvwrite_r+0xa0>
8000b36c:	60 03       	ld.w	r3,r0[0x0]
8000b36e:	60 11       	ld.w	r1,r0[0x4]
8000b370:	30 08       	mov	r8,0
8000b372:	2f 80       	sub	r0,-8
8000b374:	50 08       	stdsp	sp[0x0],r8
8000b376:	58 01       	cp.w	r1,0
8000b378:	cf a0       	breq	8000b36c <__sfvwrite_r+0x1c0>
8000b37a:	40 0a       	lddsp	r10,sp[0x0]
8000b37c:	58 0a       	cp.w	r10,0
8000b37e:	c1 41       	brne	8000b3a6 <__sfvwrite_r+0x1fa>
8000b380:	e2 c6 ff ff 	sub	r6,r1,-1
8000b384:	02 9a       	mov	r10,r1
8000b386:	30 ab       	mov	r11,10
8000b388:	06 9c       	mov	r12,r3
8000b38a:	ce 3c       	rcall	8000b550 <memchr>
8000b38c:	f8 c8 ff ff 	sub	r8,r12,-1
8000b390:	58 0c       	cp.w	r12,0
8000b392:	f1 d3 e1 16 	subne	r6,r8,r3
8000b396:	f9 b9 01 01 	movne	r9,1
8000b39a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b39e:	f9 b8 00 01 	moveq	r8,1
8000b3a2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b3a6:	02 36       	cp.w	r6,r1
8000b3a8:	ec 04 17 80 	movls	r4,r6
8000b3ac:	e2 04 17 b0 	movhi	r4,r1
8000b3b0:	6e 59       	ld.w	r9,r7[0x14]
8000b3b2:	6e 25       	ld.w	r5,r7[0x8]
8000b3b4:	f2 05 00 05 	add	r5,r9,r5
8000b3b8:	0a 34       	cp.w	r4,r5
8000b3ba:	5f 9a       	srgt	r10
8000b3bc:	6e 0c       	ld.w	r12,r7[0x0]
8000b3be:	6e 48       	ld.w	r8,r7[0x10]
8000b3c0:	10 3c       	cp.w	r12,r8
8000b3c2:	5f b8       	srhi	r8
8000b3c4:	f5 e8 00 08 	and	r8,r10,r8
8000b3c8:	30 0a       	mov	r10,0
8000b3ca:	f4 08 18 00 	cp.b	r8,r10
8000b3ce:	c0 d0       	breq	8000b3e8 <__sfvwrite_r+0x23c>
8000b3d0:	06 9b       	mov	r11,r3
8000b3d2:	0a 9a       	mov	r10,r5
8000b3d4:	cc 9c       	rcall	8000b566 <memmove>
8000b3d6:	6e 08       	ld.w	r8,r7[0x0]
8000b3d8:	0a 08       	add	r8,r5
8000b3da:	0e 9b       	mov	r11,r7
8000b3dc:	8f 08       	st.w	r7[0x0],r8
8000b3de:	40 1c       	lddsp	r12,sp[0x4]
8000b3e0:	fe b0 fc ae 	rcall	8000ad3c <_fflush_r>
8000b3e4:	c1 70       	breq	8000b412 <__sfvwrite_r+0x266>
8000b3e6:	c2 58       	rjmp	8000b430 <__sfvwrite_r+0x284>
8000b3e8:	12 34       	cp.w	r4,r9
8000b3ea:	c0 a5       	brlt	8000b3fe <__sfvwrite_r+0x252>
8000b3ec:	6e a8       	ld.w	r8,r7[0x28]
8000b3ee:	06 9a       	mov	r10,r3
8000b3f0:	6e 8b       	ld.w	r11,r7[0x20]
8000b3f2:	40 1c       	lddsp	r12,sp[0x4]
8000b3f4:	5d 18       	icall	r8
8000b3f6:	18 95       	mov	r5,r12
8000b3f8:	e0 89 00 0d 	brgt	8000b412 <__sfvwrite_r+0x266>
8000b3fc:	c1 a8       	rjmp	8000b430 <__sfvwrite_r+0x284>
8000b3fe:	08 9a       	mov	r10,r4
8000b400:	06 9b       	mov	r11,r3
8000b402:	cb 2c       	rcall	8000b566 <memmove>
8000b404:	6e 08       	ld.w	r8,r7[0x0]
8000b406:	08 08       	add	r8,r4
8000b408:	08 95       	mov	r5,r4
8000b40a:	8f 08       	st.w	r7[0x0],r8
8000b40c:	6e 28       	ld.w	r8,r7[0x8]
8000b40e:	08 18       	sub	r8,r4
8000b410:	8f 28       	st.w	r7[0x8],r8
8000b412:	0a 16       	sub	r6,r5
8000b414:	c0 71       	brne	8000b422 <__sfvwrite_r+0x276>
8000b416:	0e 9b       	mov	r11,r7
8000b418:	40 1c       	lddsp	r12,sp[0x4]
8000b41a:	fe b0 fc 91 	rcall	8000ad3c <_fflush_r>
8000b41e:	c0 91       	brne	8000b430 <__sfvwrite_r+0x284>
8000b420:	50 06       	stdsp	sp[0x0],r6
8000b422:	64 28       	ld.w	r8,r2[0x8]
8000b424:	0a 18       	sub	r8,r5
8000b426:	85 28       	st.w	r2[0x8],r8
8000b428:	c0 90       	breq	8000b43a <__sfvwrite_r+0x28e>
8000b42a:	0a 11       	sub	r1,r5
8000b42c:	0a 03       	add	r3,r5
8000b42e:	ca 4b       	rjmp	8000b376 <__sfvwrite_r+0x1ca>
8000b430:	8e 68       	ld.sh	r8,r7[0xc]
8000b432:	a7 a8       	sbr	r8,0x6
8000b434:	ae 68       	st.h	r7[0xc],r8
8000b436:	3f fc       	mov	r12,-1
8000b438:	c0 28       	rjmp	8000b43c <__sfvwrite_r+0x290>
8000b43a:	30 0c       	mov	r12,0
8000b43c:	2f dd       	sub	sp,-12
8000b43e:	d8 32       	popm	r0-r7,pc

8000b440 <_fwalk>:
8000b440:	d4 31       	pushm	r0-r7,lr
8000b442:	30 05       	mov	r5,0
8000b444:	16 91       	mov	r1,r11
8000b446:	f8 c7 ff 28 	sub	r7,r12,-216
8000b44a:	0a 92       	mov	r2,r5
8000b44c:	fe b0 fc fe 	rcall	8000ae48 <__sfp_lock_acquire>
8000b450:	3f f3       	mov	r3,-1
8000b452:	c1 68       	rjmp	8000b47e <_fwalk+0x3e>
8000b454:	6e 26       	ld.w	r6,r7[0x8]
8000b456:	6e 14       	ld.w	r4,r7[0x4]
8000b458:	2f 46       	sub	r6,-12
8000b45a:	c0 c8       	rjmp	8000b472 <_fwalk+0x32>
8000b45c:	8c 08       	ld.sh	r8,r6[0x0]
8000b45e:	e4 08 19 00 	cp.h	r8,r2
8000b462:	c0 70       	breq	8000b470 <_fwalk+0x30>
8000b464:	8c 18       	ld.sh	r8,r6[0x2]
8000b466:	e6 08 19 00 	cp.h	r8,r3
8000b46a:	c0 30       	breq	8000b470 <_fwalk+0x30>
8000b46c:	5d 11       	icall	r1
8000b46e:	18 45       	or	r5,r12
8000b470:	2a 46       	sub	r6,-92
8000b472:	20 14       	sub	r4,1
8000b474:	ec cc 00 0c 	sub	r12,r6,12
8000b478:	58 04       	cp.w	r4,0
8000b47a:	cf 14       	brge	8000b45c <_fwalk+0x1c>
8000b47c:	6e 07       	ld.w	r7,r7[0x0]
8000b47e:	58 07       	cp.w	r7,0
8000b480:	ce a1       	brne	8000b454 <_fwalk+0x14>
8000b482:	fe b0 fc e4 	rcall	8000ae4a <__sfp_lock_release>
8000b486:	0a 9c       	mov	r12,r5
8000b488:	d8 32       	popm	r0-r7,pc
8000b48a:	d7 03       	nop

8000b48c <_localeconv_r>:
8000b48c:	fe cc d2 f0 	sub	r12,pc,-11536
8000b490:	5e fc       	retal	r12
8000b492:	d7 03       	nop

8000b494 <__smakebuf_r>:
8000b494:	d4 21       	pushm	r4-r7,lr
8000b496:	20 fd       	sub	sp,60
8000b498:	96 68       	ld.sh	r8,r11[0xc]
8000b49a:	16 97       	mov	r7,r11
8000b49c:	18 96       	mov	r6,r12
8000b49e:	e2 18 00 02 	andl	r8,0x2,COH
8000b4a2:	c3 d1       	brne	8000b51c <__smakebuf_r+0x88>
8000b4a4:	96 7b       	ld.sh	r11,r11[0xe]
8000b4a6:	f0 0b 19 00 	cp.h	r11,r8
8000b4aa:	c0 55       	brlt	8000b4b4 <__smakebuf_r+0x20>
8000b4ac:	1a 9a       	mov	r10,sp
8000b4ae:	e0 a0 04 81 	rcall	8000bdb0 <_fstat_r>
8000b4b2:	c0 f4       	brge	8000b4d0 <__smakebuf_r+0x3c>
8000b4b4:	8e 65       	ld.sh	r5,r7[0xc]
8000b4b6:	0a 98       	mov	r8,r5
8000b4b8:	ab b8       	sbr	r8,0xb
8000b4ba:	e2 15 00 80 	andl	r5,0x80,COH
8000b4be:	ae 68       	st.h	r7[0xc],r8
8000b4c0:	30 04       	mov	r4,0
8000b4c2:	e0 68 04 00 	mov	r8,1024
8000b4c6:	f9 b5 01 40 	movne	r5,64
8000b4ca:	f0 05 17 00 	moveq	r5,r8
8000b4ce:	c1 c8       	rjmp	8000b506 <__smakebuf_r+0x72>
8000b4d0:	40 18       	lddsp	r8,sp[0x4]
8000b4d2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b4d6:	e0 48 20 00 	cp.w	r8,8192
8000b4da:	5f 04       	sreq	r4
8000b4dc:	e0 48 80 00 	cp.w	r8,32768
8000b4e0:	c0 e1       	brne	8000b4fc <__smakebuf_r+0x68>
8000b4e2:	6e b9       	ld.w	r9,r7[0x2c]
8000b4e4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b4e8:	10 39       	cp.w	r9,r8
8000b4ea:	c0 91       	brne	8000b4fc <__smakebuf_r+0x68>
8000b4ec:	8e 68       	ld.sh	r8,r7[0xc]
8000b4ee:	e0 65 04 00 	mov	r5,1024
8000b4f2:	ab a8       	sbr	r8,0xa
8000b4f4:	ef 45 00 50 	st.w	r7[80],r5
8000b4f8:	ae 68       	st.h	r7[0xc],r8
8000b4fa:	c0 68       	rjmp	8000b506 <__smakebuf_r+0x72>
8000b4fc:	8e 68       	ld.sh	r8,r7[0xc]
8000b4fe:	e0 65 04 00 	mov	r5,1024
8000b502:	ab b8       	sbr	r8,0xb
8000b504:	ae 68       	st.h	r7[0xc],r8
8000b506:	0a 9b       	mov	r11,r5
8000b508:	0c 9c       	mov	r12,r6
8000b50a:	fe b0 df 35 	rcall	80007374 <_malloc_r>
8000b50e:	8e 68       	ld.sh	r8,r7[0xc]
8000b510:	c0 d1       	brne	8000b52a <__smakebuf_r+0x96>
8000b512:	ed b8 00 09 	bld	r8,0x9
8000b516:	c1 b0       	breq	8000b54c <__smakebuf_r+0xb8>
8000b518:	a1 b8       	sbr	r8,0x1
8000b51a:	ae 68       	st.h	r7[0xc],r8
8000b51c:	ee c8 ff b9 	sub	r8,r7,-71
8000b520:	8f 48       	st.w	r7[0x10],r8
8000b522:	8f 08       	st.w	r7[0x0],r8
8000b524:	30 18       	mov	r8,1
8000b526:	8f 58       	st.w	r7[0x14],r8
8000b528:	c1 28       	rjmp	8000b54c <__smakebuf_r+0xb8>
8000b52a:	a7 b8       	sbr	r8,0x7
8000b52c:	8f 4c       	st.w	r7[0x10],r12
8000b52e:	ae 68       	st.h	r7[0xc],r8
8000b530:	8f 55       	st.w	r7[0x14],r5
8000b532:	fe c8 06 e6 	sub	r8,pc,1766
8000b536:	8f 0c       	st.w	r7[0x0],r12
8000b538:	8d a8       	st.w	r6[0x28],r8
8000b53a:	58 04       	cp.w	r4,0
8000b53c:	c0 80       	breq	8000b54c <__smakebuf_r+0xb8>
8000b53e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b540:	fe b0 e3 94 	rcall	80007c68 <isatty>
8000b544:	c0 40       	breq	8000b54c <__smakebuf_r+0xb8>
8000b546:	8e 68       	ld.sh	r8,r7[0xc]
8000b548:	a1 a8       	sbr	r8,0x0
8000b54a:	ae 68       	st.h	r7[0xc],r8
8000b54c:	2f 1d       	sub	sp,-60
8000b54e:	d8 22       	popm	r4-r7,pc

8000b550 <memchr>:
8000b550:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b554:	c0 68       	rjmp	8000b560 <memchr+0x10>
8000b556:	20 1a       	sub	r10,1
8000b558:	19 88       	ld.ub	r8,r12[0x0]
8000b55a:	16 38       	cp.w	r8,r11
8000b55c:	5e 0c       	reteq	r12
8000b55e:	2f fc       	sub	r12,-1
8000b560:	58 0a       	cp.w	r10,0
8000b562:	cf a1       	brne	8000b556 <memchr+0x6>
8000b564:	5e fa       	retal	r10

8000b566 <memmove>:
8000b566:	d4 01       	pushm	lr
8000b568:	18 3b       	cp.w	r11,r12
8000b56a:	c1 92       	brcc	8000b59c <memmove+0x36>
8000b56c:	f6 0a 00 09 	add	r9,r11,r10
8000b570:	12 3c       	cp.w	r12,r9
8000b572:	c1 52       	brcc	8000b59c <memmove+0x36>
8000b574:	f8 0a 00 0b 	add	r11,r12,r10
8000b578:	30 08       	mov	r8,0
8000b57a:	c0 68       	rjmp	8000b586 <memmove+0x20>
8000b57c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b580:	20 1a       	sub	r10,1
8000b582:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b586:	20 18       	sub	r8,1
8000b588:	58 0a       	cp.w	r10,0
8000b58a:	cf 91       	brne	8000b57c <memmove+0x16>
8000b58c:	d8 02       	popm	pc
8000b58e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b592:	20 1a       	sub	r10,1
8000b594:	f8 08 0b 09 	st.b	r12[r8],r9
8000b598:	2f f8       	sub	r8,-1
8000b59a:	c0 28       	rjmp	8000b59e <memmove+0x38>
8000b59c:	30 08       	mov	r8,0
8000b59e:	58 0a       	cp.w	r10,0
8000b5a0:	cf 71       	brne	8000b58e <memmove+0x28>
8000b5a2:	d8 02       	popm	pc

8000b5a4 <__hi0bits>:
8000b5a4:	18 98       	mov	r8,r12
8000b5a6:	e0 1c 00 00 	andl	r12,0x0
8000b5aa:	f0 09 15 10 	lsl	r9,r8,0x10
8000b5ae:	58 0c       	cp.w	r12,0
8000b5b0:	f2 08 17 00 	moveq	r8,r9
8000b5b4:	f9 bc 00 10 	moveq	r12,16
8000b5b8:	f9 bc 01 00 	movne	r12,0
8000b5bc:	10 9a       	mov	r10,r8
8000b5be:	f0 09 15 08 	lsl	r9,r8,0x8
8000b5c2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b5c6:	f7 bc 00 f8 	subeq	r12,-8
8000b5ca:	f2 08 17 00 	moveq	r8,r9
8000b5ce:	10 9a       	mov	r10,r8
8000b5d0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b5d4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b5d8:	f7 bc 00 fc 	subeq	r12,-4
8000b5dc:	f2 08 17 00 	moveq	r8,r9
8000b5e0:	10 9a       	mov	r10,r8
8000b5e2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b5e6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b5ea:	f7 bc 00 fe 	subeq	r12,-2
8000b5ee:	f2 08 17 00 	moveq	r8,r9
8000b5f2:	58 08       	cp.w	r8,0
8000b5f4:	5e 5c       	retlt	r12
8000b5f6:	ed b8 00 1e 	bld	r8,0x1e
8000b5fa:	f9 bc 01 20 	movne	r12,32
8000b5fe:	f7 bc 00 ff 	subeq	r12,-1
8000b602:	5e fc       	retal	r12

8000b604 <__lo0bits>:
8000b604:	18 99       	mov	r9,r12
8000b606:	78 08       	ld.w	r8,r12[0x0]
8000b608:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b60c:	c1 50       	breq	8000b636 <__lo0bits+0x32>
8000b60e:	ed b8 00 00 	bld	r8,0x0
8000b612:	c0 21       	brne	8000b616 <__lo0bits+0x12>
8000b614:	5e fd       	retal	0
8000b616:	10 9b       	mov	r11,r8
8000b618:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b61c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b620:	a3 88       	lsr	r8,0x2
8000b622:	58 0b       	cp.w	r11,0
8000b624:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b628:	f9 bc 01 01 	movne	r12,1
8000b62c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b630:	f9 bc 00 02 	moveq	r12,2
8000b634:	5e fc       	retal	r12
8000b636:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b63a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b63e:	58 0a       	cp.w	r10,0
8000b640:	f6 08 17 00 	moveq	r8,r11
8000b644:	f9 bc 00 10 	moveq	r12,16
8000b648:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b64c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b650:	58 0b       	cp.w	r11,0
8000b652:	f7 bc 00 f8 	subeq	r12,-8
8000b656:	f4 08 17 00 	moveq	r8,r10
8000b65a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b65e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b662:	58 0b       	cp.w	r11,0
8000b664:	f7 bc 00 fc 	subeq	r12,-4
8000b668:	f4 08 17 00 	moveq	r8,r10
8000b66c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b670:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b674:	58 0b       	cp.w	r11,0
8000b676:	f7 bc 00 fe 	subeq	r12,-2
8000b67a:	f4 08 17 00 	moveq	r8,r10
8000b67e:	ed b8 00 00 	bld	r8,0x0
8000b682:	c0 60       	breq	8000b68e <__lo0bits+0x8a>
8000b684:	a1 98       	lsr	r8,0x1
8000b686:	c0 31       	brne	8000b68c <__lo0bits+0x88>
8000b688:	32 0c       	mov	r12,32
8000b68a:	5e fc       	retal	r12
8000b68c:	2f fc       	sub	r12,-1
8000b68e:	93 08       	st.w	r9[0x0],r8
8000b690:	5e fc       	retal	r12

8000b692 <__mcmp>:
8000b692:	d4 01       	pushm	lr
8000b694:	18 98       	mov	r8,r12
8000b696:	76 49       	ld.w	r9,r11[0x10]
8000b698:	78 4c       	ld.w	r12,r12[0x10]
8000b69a:	12 1c       	sub	r12,r9
8000b69c:	c1 31       	brne	8000b6c2 <__mcmp+0x30>
8000b69e:	2f b9       	sub	r9,-5
8000b6a0:	a3 69       	lsl	r9,0x2
8000b6a2:	12 0b       	add	r11,r9
8000b6a4:	f0 09 00 09 	add	r9,r8,r9
8000b6a8:	2e c8       	sub	r8,-20
8000b6aa:	13 4e       	ld.w	lr,--r9
8000b6ac:	17 4a       	ld.w	r10,--r11
8000b6ae:	14 3e       	cp.w	lr,r10
8000b6b0:	c0 60       	breq	8000b6bc <__mcmp+0x2a>
8000b6b2:	f9 bc 03 ff 	movlo	r12,-1
8000b6b6:	f9 bc 02 01 	movhs	r12,1
8000b6ba:	d8 02       	popm	pc
8000b6bc:	10 39       	cp.w	r9,r8
8000b6be:	fe 9b ff f6 	brhi	8000b6aa <__mcmp+0x18>
8000b6c2:	d8 02       	popm	pc

8000b6c4 <_Bfree>:
8000b6c4:	d4 21       	pushm	r4-r7,lr
8000b6c6:	18 97       	mov	r7,r12
8000b6c8:	16 95       	mov	r5,r11
8000b6ca:	78 96       	ld.w	r6,r12[0x24]
8000b6cc:	58 06       	cp.w	r6,0
8000b6ce:	c0 91       	brne	8000b6e0 <_Bfree+0x1c>
8000b6d0:	31 0c       	mov	r12,16
8000b6d2:	fe b0 de 49 	rcall	80007364 <malloc>
8000b6d6:	99 36       	st.w	r12[0xc],r6
8000b6d8:	8f 9c       	st.w	r7[0x24],r12
8000b6da:	99 16       	st.w	r12[0x4],r6
8000b6dc:	99 26       	st.w	r12[0x8],r6
8000b6de:	99 06       	st.w	r12[0x0],r6
8000b6e0:	58 05       	cp.w	r5,0
8000b6e2:	c0 90       	breq	8000b6f4 <_Bfree+0x30>
8000b6e4:	6a 19       	ld.w	r9,r5[0x4]
8000b6e6:	6e 98       	ld.w	r8,r7[0x24]
8000b6e8:	70 38       	ld.w	r8,r8[0xc]
8000b6ea:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b6ee:	8b 0a       	st.w	r5[0x0],r10
8000b6f0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b6f4:	d8 22       	popm	r4-r7,pc
8000b6f6:	d7 03       	nop

8000b6f8 <_Balloc>:
8000b6f8:	d4 21       	pushm	r4-r7,lr
8000b6fa:	18 97       	mov	r7,r12
8000b6fc:	16 96       	mov	r6,r11
8000b6fe:	78 95       	ld.w	r5,r12[0x24]
8000b700:	58 05       	cp.w	r5,0
8000b702:	c0 91       	brne	8000b714 <_Balloc+0x1c>
8000b704:	31 0c       	mov	r12,16
8000b706:	fe b0 de 2f 	rcall	80007364 <malloc>
8000b70a:	99 35       	st.w	r12[0xc],r5
8000b70c:	8f 9c       	st.w	r7[0x24],r12
8000b70e:	99 15       	st.w	r12[0x4],r5
8000b710:	99 25       	st.w	r12[0x8],r5
8000b712:	99 05       	st.w	r12[0x0],r5
8000b714:	6e 95       	ld.w	r5,r7[0x24]
8000b716:	6a 38       	ld.w	r8,r5[0xc]
8000b718:	58 08       	cp.w	r8,0
8000b71a:	c0 b1       	brne	8000b730 <_Balloc+0x38>
8000b71c:	31 0a       	mov	r10,16
8000b71e:	30 4b       	mov	r11,4
8000b720:	0e 9c       	mov	r12,r7
8000b722:	e0 a0 02 a7 	rcall	8000bc70 <_calloc_r>
8000b726:	8b 3c       	st.w	r5[0xc],r12
8000b728:	6e 98       	ld.w	r8,r7[0x24]
8000b72a:	70 3c       	ld.w	r12,r8[0xc]
8000b72c:	58 0c       	cp.w	r12,0
8000b72e:	c1 b0       	breq	8000b764 <_Balloc+0x6c>
8000b730:	6e 98       	ld.w	r8,r7[0x24]
8000b732:	70 38       	ld.w	r8,r8[0xc]
8000b734:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b738:	70 0c       	ld.w	r12,r8[0x0]
8000b73a:	58 0c       	cp.w	r12,0
8000b73c:	c0 40       	breq	8000b744 <_Balloc+0x4c>
8000b73e:	78 09       	ld.w	r9,r12[0x0]
8000b740:	91 09       	st.w	r8[0x0],r9
8000b742:	c0 e8       	rjmp	8000b75e <_Balloc+0x66>
8000b744:	0e 9c       	mov	r12,r7
8000b746:	30 17       	mov	r7,1
8000b748:	0e 9b       	mov	r11,r7
8000b74a:	ee 06 09 47 	lsl	r7,r7,r6
8000b74e:	ee ca ff fb 	sub	r10,r7,-5
8000b752:	a3 6a       	lsl	r10,0x2
8000b754:	e0 a0 02 8e 	rcall	8000bc70 <_calloc_r>
8000b758:	c0 60       	breq	8000b764 <_Balloc+0x6c>
8000b75a:	99 16       	st.w	r12[0x4],r6
8000b75c:	99 27       	st.w	r12[0x8],r7
8000b75e:	30 08       	mov	r8,0
8000b760:	99 38       	st.w	r12[0xc],r8
8000b762:	99 48       	st.w	r12[0x10],r8
8000b764:	d8 22       	popm	r4-r7,pc
8000b766:	d7 03       	nop

8000b768 <__d2b>:
8000b768:	d4 31       	pushm	r0-r7,lr
8000b76a:	20 2d       	sub	sp,8
8000b76c:	16 93       	mov	r3,r11
8000b76e:	12 96       	mov	r6,r9
8000b770:	10 95       	mov	r5,r8
8000b772:	14 92       	mov	r2,r10
8000b774:	30 1b       	mov	r11,1
8000b776:	cc 1f       	rcall	8000b6f8 <_Balloc>
8000b778:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b77c:	50 09       	stdsp	sp[0x0],r9
8000b77e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b782:	b5 a9       	sbr	r9,0x14
8000b784:	f0 01 16 14 	lsr	r1,r8,0x14
8000b788:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b78c:	18 94       	mov	r4,r12
8000b78e:	58 02       	cp.w	r2,0
8000b790:	c1 d0       	breq	8000b7ca <__d2b+0x62>
8000b792:	fa cc ff f8 	sub	r12,sp,-8
8000b796:	18 d2       	st.w	--r12,r2
8000b798:	c3 6f       	rcall	8000b604 <__lo0bits>
8000b79a:	40 18       	lddsp	r8,sp[0x4]
8000b79c:	c0 d0       	breq	8000b7b6 <__d2b+0x4e>
8000b79e:	40 09       	lddsp	r9,sp[0x0]
8000b7a0:	f8 0a 11 20 	rsub	r10,r12,32
8000b7a4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b7a8:	f5 e8 10 08 	or	r8,r10,r8
8000b7ac:	89 58       	st.w	r4[0x14],r8
8000b7ae:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b7b2:	50 09       	stdsp	sp[0x0],r9
8000b7b4:	c0 28       	rjmp	8000b7b8 <__d2b+0x50>
8000b7b6:	89 58       	st.w	r4[0x14],r8
8000b7b8:	40 08       	lddsp	r8,sp[0x0]
8000b7ba:	58 08       	cp.w	r8,0
8000b7bc:	f9 b3 01 02 	movne	r3,2
8000b7c0:	f9 b3 00 01 	moveq	r3,1
8000b7c4:	89 68       	st.w	r4[0x18],r8
8000b7c6:	89 43       	st.w	r4[0x10],r3
8000b7c8:	c0 88       	rjmp	8000b7d8 <__d2b+0x70>
8000b7ca:	1a 9c       	mov	r12,sp
8000b7cc:	c1 cf       	rcall	8000b604 <__lo0bits>
8000b7ce:	30 13       	mov	r3,1
8000b7d0:	40 08       	lddsp	r8,sp[0x0]
8000b7d2:	2e 0c       	sub	r12,-32
8000b7d4:	89 43       	st.w	r4[0x10],r3
8000b7d6:	89 58       	st.w	r4[0x14],r8
8000b7d8:	58 01       	cp.w	r1,0
8000b7da:	c0 90       	breq	8000b7ec <__d2b+0x84>
8000b7dc:	e2 c1 04 33 	sub	r1,r1,1075
8000b7e0:	18 01       	add	r1,r12
8000b7e2:	8d 01       	st.w	r6[0x0],r1
8000b7e4:	f8 0c 11 35 	rsub	r12,r12,53
8000b7e8:	8b 0c       	st.w	r5[0x0],r12
8000b7ea:	c0 c8       	rjmp	8000b802 <__d2b+0x9a>
8000b7ec:	e6 c8 ff fc 	sub	r8,r3,-4
8000b7f0:	f8 cc 04 32 	sub	r12,r12,1074
8000b7f4:	a5 73       	lsl	r3,0x5
8000b7f6:	8d 0c       	st.w	r6[0x0],r12
8000b7f8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b7fc:	cd 4e       	rcall	8000b5a4 <__hi0bits>
8000b7fe:	18 13       	sub	r3,r12
8000b800:	8b 03       	st.w	r5[0x0],r3
8000b802:	08 9c       	mov	r12,r4
8000b804:	2f ed       	sub	sp,-8
8000b806:	d8 32       	popm	r0-r7,pc

8000b808 <__mdiff>:
8000b808:	d4 31       	pushm	r0-r7,lr
8000b80a:	74 48       	ld.w	r8,r10[0x10]
8000b80c:	76 45       	ld.w	r5,r11[0x10]
8000b80e:	16 97       	mov	r7,r11
8000b810:	14 96       	mov	r6,r10
8000b812:	10 15       	sub	r5,r8
8000b814:	c1 31       	brne	8000b83a <__mdiff+0x32>
8000b816:	2f b8       	sub	r8,-5
8000b818:	ee ce ff ec 	sub	lr,r7,-20
8000b81c:	a3 68       	lsl	r8,0x2
8000b81e:	f4 08 00 0b 	add	r11,r10,r8
8000b822:	ee 08 00 08 	add	r8,r7,r8
8000b826:	11 4a       	ld.w	r10,--r8
8000b828:	17 49       	ld.w	r9,--r11
8000b82a:	12 3a       	cp.w	r10,r9
8000b82c:	c0 30       	breq	8000b832 <__mdiff+0x2a>
8000b82e:	c0 e2       	brcc	8000b84a <__mdiff+0x42>
8000b830:	c0 78       	rjmp	8000b83e <__mdiff+0x36>
8000b832:	1c 38       	cp.w	r8,lr
8000b834:	fe 9b ff f9 	brhi	8000b826 <__mdiff+0x1e>
8000b838:	c4 98       	rjmp	8000b8ca <__mdiff+0xc2>
8000b83a:	58 05       	cp.w	r5,0
8000b83c:	c0 64       	brge	8000b848 <__mdiff+0x40>
8000b83e:	0e 98       	mov	r8,r7
8000b840:	30 15       	mov	r5,1
8000b842:	0c 97       	mov	r7,r6
8000b844:	10 96       	mov	r6,r8
8000b846:	c0 28       	rjmp	8000b84a <__mdiff+0x42>
8000b848:	30 05       	mov	r5,0
8000b84a:	6e 1b       	ld.w	r11,r7[0x4]
8000b84c:	c5 6f       	rcall	8000b6f8 <_Balloc>
8000b84e:	6e 49       	ld.w	r9,r7[0x10]
8000b850:	6c 44       	ld.w	r4,r6[0x10]
8000b852:	99 35       	st.w	r12[0xc],r5
8000b854:	2f b4       	sub	r4,-5
8000b856:	f2 c5 ff fb 	sub	r5,r9,-5
8000b85a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b85e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b862:	2e c6       	sub	r6,-20
8000b864:	2e c7       	sub	r7,-20
8000b866:	f8 c8 ff ec 	sub	r8,r12,-20
8000b86a:	30 0a       	mov	r10,0
8000b86c:	0f 0e       	ld.w	lr,r7++
8000b86e:	0d 0b       	ld.w	r11,r6++
8000b870:	fc 02 16 10 	lsr	r2,lr,0x10
8000b874:	f6 03 16 10 	lsr	r3,r11,0x10
8000b878:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b87c:	e4 03 01 03 	sub	r3,r2,r3
8000b880:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b884:	fc 0b 01 0b 	sub	r11,lr,r11
8000b888:	f6 0a 00 0a 	add	r10,r11,r10
8000b88c:	b0 1a       	st.h	r8[0x2],r10
8000b88e:	b1 4a       	asr	r10,0x10
8000b890:	e6 0a 00 0a 	add	r10,r3,r10
8000b894:	b0 0a       	st.h	r8[0x0],r10
8000b896:	2f c8       	sub	r8,-4
8000b898:	b1 4a       	asr	r10,0x10
8000b89a:	08 36       	cp.w	r6,r4
8000b89c:	ce 83       	brcs	8000b86c <__mdiff+0x64>
8000b89e:	c0 d8       	rjmp	8000b8b8 <__mdiff+0xb0>
8000b8a0:	0f 0b       	ld.w	r11,r7++
8000b8a2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b8a6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8aa:	16 0a       	add	r10,r11
8000b8ac:	b0 1a       	st.h	r8[0x2],r10
8000b8ae:	b1 4a       	asr	r10,0x10
8000b8b0:	1c 0a       	add	r10,lr
8000b8b2:	b0 0a       	st.h	r8[0x0],r10
8000b8b4:	2f c8       	sub	r8,-4
8000b8b6:	b1 4a       	asr	r10,0x10
8000b8b8:	0a 37       	cp.w	r7,r5
8000b8ba:	cf 33       	brcs	8000b8a0 <__mdiff+0x98>
8000b8bc:	c0 28       	rjmp	8000b8c0 <__mdiff+0xb8>
8000b8be:	20 19       	sub	r9,1
8000b8c0:	11 4a       	ld.w	r10,--r8
8000b8c2:	58 0a       	cp.w	r10,0
8000b8c4:	cf d0       	breq	8000b8be <__mdiff+0xb6>
8000b8c6:	99 49       	st.w	r12[0x10],r9
8000b8c8:	d8 32       	popm	r0-r7,pc
8000b8ca:	30 0b       	mov	r11,0
8000b8cc:	c1 6f       	rcall	8000b6f8 <_Balloc>
8000b8ce:	30 18       	mov	r8,1
8000b8d0:	99 48       	st.w	r12[0x10],r8
8000b8d2:	30 08       	mov	r8,0
8000b8d4:	99 58       	st.w	r12[0x14],r8
8000b8d6:	d8 32       	popm	r0-r7,pc

8000b8d8 <__lshift>:
8000b8d8:	d4 31       	pushm	r0-r7,lr
8000b8da:	16 97       	mov	r7,r11
8000b8dc:	76 46       	ld.w	r6,r11[0x10]
8000b8de:	f4 02 14 05 	asr	r2,r10,0x5
8000b8e2:	2f f6       	sub	r6,-1
8000b8e4:	14 93       	mov	r3,r10
8000b8e6:	18 94       	mov	r4,r12
8000b8e8:	04 06       	add	r6,r2
8000b8ea:	76 1b       	ld.w	r11,r11[0x4]
8000b8ec:	6e 28       	ld.w	r8,r7[0x8]
8000b8ee:	c0 38       	rjmp	8000b8f4 <__lshift+0x1c>
8000b8f0:	2f fb       	sub	r11,-1
8000b8f2:	a1 78       	lsl	r8,0x1
8000b8f4:	10 36       	cp.w	r6,r8
8000b8f6:	fe 99 ff fd 	brgt	8000b8f0 <__lshift+0x18>
8000b8fa:	08 9c       	mov	r12,r4
8000b8fc:	cf ee       	rcall	8000b6f8 <_Balloc>
8000b8fe:	30 09       	mov	r9,0
8000b900:	18 95       	mov	r5,r12
8000b902:	f8 c8 ff ec 	sub	r8,r12,-20
8000b906:	12 9a       	mov	r10,r9
8000b908:	c0 38       	rjmp	8000b90e <__lshift+0x36>
8000b90a:	10 aa       	st.w	r8++,r10
8000b90c:	2f f9       	sub	r9,-1
8000b90e:	04 39       	cp.w	r9,r2
8000b910:	cf d5       	brlt	8000b90a <__lshift+0x32>
8000b912:	6e 4b       	ld.w	r11,r7[0x10]
8000b914:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b918:	2f bb       	sub	r11,-5
8000b91a:	ee c9 ff ec 	sub	r9,r7,-20
8000b91e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b922:	58 03       	cp.w	r3,0
8000b924:	c1 30       	breq	8000b94a <__lshift+0x72>
8000b926:	e6 0c 11 20 	rsub	r12,r3,32
8000b92a:	30 0a       	mov	r10,0
8000b92c:	72 02       	ld.w	r2,r9[0x0]
8000b92e:	e4 03 09 42 	lsl	r2,r2,r3
8000b932:	04 4a       	or	r10,r2
8000b934:	10 aa       	st.w	r8++,r10
8000b936:	13 0a       	ld.w	r10,r9++
8000b938:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b93c:	16 39       	cp.w	r9,r11
8000b93e:	cf 73       	brcs	8000b92c <__lshift+0x54>
8000b940:	91 0a       	st.w	r8[0x0],r10
8000b942:	58 0a       	cp.w	r10,0
8000b944:	c0 70       	breq	8000b952 <__lshift+0x7a>
8000b946:	2f f6       	sub	r6,-1
8000b948:	c0 58       	rjmp	8000b952 <__lshift+0x7a>
8000b94a:	13 0a       	ld.w	r10,r9++
8000b94c:	10 aa       	st.w	r8++,r10
8000b94e:	16 39       	cp.w	r9,r11
8000b950:	cf d3       	brcs	8000b94a <__lshift+0x72>
8000b952:	08 9c       	mov	r12,r4
8000b954:	20 16       	sub	r6,1
8000b956:	0e 9b       	mov	r11,r7
8000b958:	8b 46       	st.w	r5[0x10],r6
8000b95a:	cb 5e       	rcall	8000b6c4 <_Bfree>
8000b95c:	0a 9c       	mov	r12,r5
8000b95e:	d8 32       	popm	r0-r7,pc

8000b960 <__multiply>:
8000b960:	d4 31       	pushm	r0-r7,lr
8000b962:	20 2d       	sub	sp,8
8000b964:	76 49       	ld.w	r9,r11[0x10]
8000b966:	74 48       	ld.w	r8,r10[0x10]
8000b968:	16 96       	mov	r6,r11
8000b96a:	14 95       	mov	r5,r10
8000b96c:	10 39       	cp.w	r9,r8
8000b96e:	ec 08 17 50 	movlt	r8,r6
8000b972:	ea 06 17 50 	movlt	r6,r5
8000b976:	f0 05 17 50 	movlt	r5,r8
8000b97a:	6c 28       	ld.w	r8,r6[0x8]
8000b97c:	76 43       	ld.w	r3,r11[0x10]
8000b97e:	74 42       	ld.w	r2,r10[0x10]
8000b980:	76 1b       	ld.w	r11,r11[0x4]
8000b982:	e4 03 00 07 	add	r7,r2,r3
8000b986:	10 37       	cp.w	r7,r8
8000b988:	f7 bb 09 ff 	subgt	r11,-1
8000b98c:	cb 6e       	rcall	8000b6f8 <_Balloc>
8000b98e:	ee c4 ff fb 	sub	r4,r7,-5
8000b992:	f8 c9 ff ec 	sub	r9,r12,-20
8000b996:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b99a:	30 0a       	mov	r10,0
8000b99c:	12 98       	mov	r8,r9
8000b99e:	c0 28       	rjmp	8000b9a2 <__multiply+0x42>
8000b9a0:	10 aa       	st.w	r8++,r10
8000b9a2:	08 38       	cp.w	r8,r4
8000b9a4:	cf e3       	brcs	8000b9a0 <__multiply+0x40>
8000b9a6:	2f b3       	sub	r3,-5
8000b9a8:	2f b2       	sub	r2,-5
8000b9aa:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b9ae:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b9b2:	ec cb ff ec 	sub	r11,r6,-20
8000b9b6:	50 12       	stdsp	sp[0x4],r2
8000b9b8:	ea ca ff ec 	sub	r10,r5,-20
8000b9bc:	c4 48       	rjmp	8000ba44 <__multiply+0xe4>
8000b9be:	94 95       	ld.uh	r5,r10[0x2]
8000b9c0:	58 05       	cp.w	r5,0
8000b9c2:	c2 00       	breq	8000ba02 <__multiply+0xa2>
8000b9c4:	12 98       	mov	r8,r9
8000b9c6:	16 96       	mov	r6,r11
8000b9c8:	30 0e       	mov	lr,0
8000b9ca:	50 09       	stdsp	sp[0x0],r9
8000b9cc:	0d 02       	ld.w	r2,r6++
8000b9ce:	e4 00 16 10 	lsr	r0,r2,0x10
8000b9d2:	70 01       	ld.w	r1,r8[0x0]
8000b9d4:	70 09       	ld.w	r9,r8[0x0]
8000b9d6:	b1 81       	lsr	r1,0x10
8000b9d8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b9dc:	e0 05 03 41 	mac	r1,r0,r5
8000b9e0:	ab 32       	mul	r2,r5
8000b9e2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b9e6:	00 02       	add	r2,r0
8000b9e8:	e4 0e 00 0e 	add	lr,r2,lr
8000b9ec:	b0 1e       	st.h	r8[0x2],lr
8000b9ee:	b1 8e       	lsr	lr,0x10
8000b9f0:	1c 01       	add	r1,lr
8000b9f2:	b0 01       	st.h	r8[0x0],r1
8000b9f4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b9f8:	2f c8       	sub	r8,-4
8000b9fa:	06 36       	cp.w	r6,r3
8000b9fc:	ce 83       	brcs	8000b9cc <__multiply+0x6c>
8000b9fe:	40 09       	lddsp	r9,sp[0x0]
8000ba00:	91 0e       	st.w	r8[0x0],lr
8000ba02:	94 86       	ld.uh	r6,r10[0x0]
8000ba04:	58 06       	cp.w	r6,0
8000ba06:	c1 d0       	breq	8000ba40 <__multiply+0xe0>
8000ba08:	72 02       	ld.w	r2,r9[0x0]
8000ba0a:	12 98       	mov	r8,r9
8000ba0c:	16 9e       	mov	lr,r11
8000ba0e:	30 05       	mov	r5,0
8000ba10:	b0 12       	st.h	r8[0x2],r2
8000ba12:	1d 01       	ld.w	r1,lr++
8000ba14:	90 82       	ld.uh	r2,r8[0x0]
8000ba16:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ba1a:	ad 30       	mul	r0,r6
8000ba1c:	e0 02 00 02 	add	r2,r0,r2
8000ba20:	e4 05 00 05 	add	r5,r2,r5
8000ba24:	b0 05       	st.h	r8[0x0],r5
8000ba26:	b1 85       	lsr	r5,0x10
8000ba28:	b1 81       	lsr	r1,0x10
8000ba2a:	2f c8       	sub	r8,-4
8000ba2c:	ad 31       	mul	r1,r6
8000ba2e:	90 92       	ld.uh	r2,r8[0x2]
8000ba30:	e2 02 00 02 	add	r2,r1,r2
8000ba34:	0a 02       	add	r2,r5
8000ba36:	e4 05 16 10 	lsr	r5,r2,0x10
8000ba3a:	06 3e       	cp.w	lr,r3
8000ba3c:	ce a3       	brcs	8000ba10 <__multiply+0xb0>
8000ba3e:	91 02       	st.w	r8[0x0],r2
8000ba40:	2f ca       	sub	r10,-4
8000ba42:	2f c9       	sub	r9,-4
8000ba44:	40 18       	lddsp	r8,sp[0x4]
8000ba46:	10 3a       	cp.w	r10,r8
8000ba48:	cb b3       	brcs	8000b9be <__multiply+0x5e>
8000ba4a:	c0 28       	rjmp	8000ba4e <__multiply+0xee>
8000ba4c:	20 17       	sub	r7,1
8000ba4e:	58 07       	cp.w	r7,0
8000ba50:	e0 8a 00 05 	brle	8000ba5a <__multiply+0xfa>
8000ba54:	09 48       	ld.w	r8,--r4
8000ba56:	58 08       	cp.w	r8,0
8000ba58:	cf a0       	breq	8000ba4c <__multiply+0xec>
8000ba5a:	99 47       	st.w	r12[0x10],r7
8000ba5c:	2f ed       	sub	sp,-8
8000ba5e:	d8 32       	popm	r0-r7,pc

8000ba60 <__i2b>:
8000ba60:	d4 21       	pushm	r4-r7,lr
8000ba62:	16 97       	mov	r7,r11
8000ba64:	30 1b       	mov	r11,1
8000ba66:	c4 9e       	rcall	8000b6f8 <_Balloc>
8000ba68:	30 19       	mov	r9,1
8000ba6a:	99 57       	st.w	r12[0x14],r7
8000ba6c:	99 49       	st.w	r12[0x10],r9
8000ba6e:	d8 22       	popm	r4-r7,pc

8000ba70 <__multadd>:
8000ba70:	d4 31       	pushm	r0-r7,lr
8000ba72:	30 08       	mov	r8,0
8000ba74:	12 95       	mov	r5,r9
8000ba76:	16 97       	mov	r7,r11
8000ba78:	18 96       	mov	r6,r12
8000ba7a:	76 44       	ld.w	r4,r11[0x10]
8000ba7c:	f6 c9 ff ec 	sub	r9,r11,-20
8000ba80:	72 0b       	ld.w	r11,r9[0x0]
8000ba82:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ba86:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ba8a:	f4 0c 02 4c 	mul	r12,r10,r12
8000ba8e:	f4 0b 03 45 	mac	r5,r10,r11
8000ba92:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ba96:	b1 85       	lsr	r5,0x10
8000ba98:	18 05       	add	r5,r12
8000ba9a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ba9e:	f8 0b 00 0b 	add	r11,r12,r11
8000baa2:	12 ab       	st.w	r9++,r11
8000baa4:	2f f8       	sub	r8,-1
8000baa6:	b1 85       	lsr	r5,0x10
8000baa8:	08 38       	cp.w	r8,r4
8000baaa:	ce b5       	brlt	8000ba80 <__multadd+0x10>
8000baac:	58 05       	cp.w	r5,0
8000baae:	c1 c0       	breq	8000bae6 <__multadd+0x76>
8000bab0:	6e 28       	ld.w	r8,r7[0x8]
8000bab2:	10 34       	cp.w	r4,r8
8000bab4:	c1 35       	brlt	8000bada <__multadd+0x6a>
8000bab6:	6e 1b       	ld.w	r11,r7[0x4]
8000bab8:	0c 9c       	mov	r12,r6
8000baba:	2f fb       	sub	r11,-1
8000babc:	c1 ee       	rcall	8000b6f8 <_Balloc>
8000babe:	6e 4a       	ld.w	r10,r7[0x10]
8000bac0:	ee cb ff f4 	sub	r11,r7,-12
8000bac4:	18 93       	mov	r3,r12
8000bac6:	2f ea       	sub	r10,-2
8000bac8:	2f 4c       	sub	r12,-12
8000baca:	a3 6a       	lsl	r10,0x2
8000bacc:	fe b0 de 70 	rcall	800077ac <memcpy>
8000bad0:	0e 9b       	mov	r11,r7
8000bad2:	0c 9c       	mov	r12,r6
8000bad4:	fe b0 fd f8 	rcall	8000b6c4 <_Bfree>
8000bad8:	06 97       	mov	r7,r3
8000bada:	e8 c8 ff ff 	sub	r8,r4,-1
8000bade:	2f b4       	sub	r4,-5
8000bae0:	8f 48       	st.w	r7[0x10],r8
8000bae2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bae6:	0e 9c       	mov	r12,r7
8000bae8:	d8 32       	popm	r0-r7,pc
8000baea:	d7 03       	nop

8000baec <__pow5mult>:
8000baec:	d4 31       	pushm	r0-r7,lr
8000baee:	14 96       	mov	r6,r10
8000baf0:	18 97       	mov	r7,r12
8000baf2:	16 94       	mov	r4,r11
8000baf4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000baf8:	c0 90       	breq	8000bb0a <__pow5mult+0x1e>
8000bafa:	20 18       	sub	r8,1
8000bafc:	fe c9 d9 24 	sub	r9,pc,-9948
8000bb00:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bb04:	30 09       	mov	r9,0
8000bb06:	cb 5f       	rcall	8000ba70 <__multadd>
8000bb08:	18 94       	mov	r4,r12
8000bb0a:	a3 46       	asr	r6,0x2
8000bb0c:	c3 40       	breq	8000bb74 <__pow5mult+0x88>
8000bb0e:	6e 95       	ld.w	r5,r7[0x24]
8000bb10:	58 05       	cp.w	r5,0
8000bb12:	c0 91       	brne	8000bb24 <__pow5mult+0x38>
8000bb14:	31 0c       	mov	r12,16
8000bb16:	fe b0 dc 27 	rcall	80007364 <malloc>
8000bb1a:	99 35       	st.w	r12[0xc],r5
8000bb1c:	8f 9c       	st.w	r7[0x24],r12
8000bb1e:	99 15       	st.w	r12[0x4],r5
8000bb20:	99 25       	st.w	r12[0x8],r5
8000bb22:	99 05       	st.w	r12[0x0],r5
8000bb24:	6e 93       	ld.w	r3,r7[0x24]
8000bb26:	66 25       	ld.w	r5,r3[0x8]
8000bb28:	58 05       	cp.w	r5,0
8000bb2a:	c0 c1       	brne	8000bb42 <__pow5mult+0x56>
8000bb2c:	e0 6b 02 71 	mov	r11,625
8000bb30:	0e 9c       	mov	r12,r7
8000bb32:	c9 7f       	rcall	8000ba60 <__i2b>
8000bb34:	87 2c       	st.w	r3[0x8],r12
8000bb36:	30 08       	mov	r8,0
8000bb38:	18 95       	mov	r5,r12
8000bb3a:	99 08       	st.w	r12[0x0],r8
8000bb3c:	c0 38       	rjmp	8000bb42 <__pow5mult+0x56>
8000bb3e:	06 9c       	mov	r12,r3
8000bb40:	18 95       	mov	r5,r12
8000bb42:	ed b6 00 00 	bld	r6,0x0
8000bb46:	c0 b1       	brne	8000bb5c <__pow5mult+0x70>
8000bb48:	08 9b       	mov	r11,r4
8000bb4a:	0a 9a       	mov	r10,r5
8000bb4c:	0e 9c       	mov	r12,r7
8000bb4e:	c0 9f       	rcall	8000b960 <__multiply>
8000bb50:	08 9b       	mov	r11,r4
8000bb52:	18 93       	mov	r3,r12
8000bb54:	0e 9c       	mov	r12,r7
8000bb56:	06 94       	mov	r4,r3
8000bb58:	fe b0 fd b6 	rcall	8000b6c4 <_Bfree>
8000bb5c:	a1 56       	asr	r6,0x1
8000bb5e:	c0 b0       	breq	8000bb74 <__pow5mult+0x88>
8000bb60:	6a 03       	ld.w	r3,r5[0x0]
8000bb62:	58 03       	cp.w	r3,0
8000bb64:	ce d1       	brne	8000bb3e <__pow5mult+0x52>
8000bb66:	0a 9a       	mov	r10,r5
8000bb68:	0a 9b       	mov	r11,r5
8000bb6a:	0e 9c       	mov	r12,r7
8000bb6c:	cf ae       	rcall	8000b960 <__multiply>
8000bb6e:	8b 0c       	st.w	r5[0x0],r12
8000bb70:	99 03       	st.w	r12[0x0],r3
8000bb72:	ce 7b       	rjmp	8000bb40 <__pow5mult+0x54>
8000bb74:	08 9c       	mov	r12,r4
8000bb76:	d8 32       	popm	r0-r7,pc

8000bb78 <__isinfd>:
8000bb78:	14 98       	mov	r8,r10
8000bb7a:	fc 19 7f f0 	movh	r9,0x7ff0
8000bb7e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bb82:	f0 0b 11 00 	rsub	r11,r8,0
8000bb86:	f7 e8 10 08 	or	r8,r11,r8
8000bb8a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bb8e:	f2 08 01 08 	sub	r8,r9,r8
8000bb92:	f0 0c 11 00 	rsub	r12,r8,0
8000bb96:	f9 e8 10 08 	or	r8,r12,r8
8000bb9a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bb9e:	2f fc       	sub	r12,-1
8000bba0:	5e fc       	retal	r12

8000bba2 <__isnand>:
8000bba2:	14 98       	mov	r8,r10
8000bba4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bba8:	f0 0c 11 00 	rsub	r12,r8,0
8000bbac:	10 4c       	or	r12,r8
8000bbae:	fc 18 7f f0 	movh	r8,0x7ff0
8000bbb2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bbb6:	f0 0c 01 0c 	sub	r12,r8,r12
8000bbba:	bf 9c       	lsr	r12,0x1f
8000bbbc:	5e fc       	retal	r12
8000bbbe:	d7 03       	nop

8000bbc0 <__sclose>:
8000bbc0:	d4 01       	pushm	lr
8000bbc2:	96 7b       	ld.sh	r11,r11[0xe]
8000bbc4:	c8 2c       	rcall	8000bcc8 <_close_r>
8000bbc6:	d8 02       	popm	pc

8000bbc8 <__sseek>:
8000bbc8:	d4 21       	pushm	r4-r7,lr
8000bbca:	16 97       	mov	r7,r11
8000bbcc:	96 7b       	ld.sh	r11,r11[0xe]
8000bbce:	c0 3d       	rcall	8000bdd4 <_lseek_r>
8000bbd0:	8e 68       	ld.sh	r8,r7[0xc]
8000bbd2:	10 99       	mov	r9,r8
8000bbd4:	ad c8       	cbr	r8,0xc
8000bbd6:	ad a9       	sbr	r9,0xc
8000bbd8:	5b fc       	cp.w	r12,-1
8000bbda:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bbde:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bbe2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bbe6:	d8 22       	popm	r4-r7,pc

8000bbe8 <__swrite>:
8000bbe8:	d4 21       	pushm	r4-r7,lr
8000bbea:	96 68       	ld.sh	r8,r11[0xc]
8000bbec:	16 97       	mov	r7,r11
8000bbee:	14 95       	mov	r5,r10
8000bbf0:	12 94       	mov	r4,r9
8000bbf2:	e2 18 01 00 	andl	r8,0x100,COH
8000bbf6:	18 96       	mov	r6,r12
8000bbf8:	c0 50       	breq	8000bc02 <__swrite+0x1a>
8000bbfa:	30 29       	mov	r9,2
8000bbfc:	30 0a       	mov	r10,0
8000bbfe:	96 7b       	ld.sh	r11,r11[0xe]
8000bc00:	ce ac       	rcall	8000bdd4 <_lseek_r>
8000bc02:	8e 68       	ld.sh	r8,r7[0xc]
8000bc04:	ad c8       	cbr	r8,0xc
8000bc06:	08 99       	mov	r9,r4
8000bc08:	0a 9a       	mov	r10,r5
8000bc0a:	8e 7b       	ld.sh	r11,r7[0xe]
8000bc0c:	0c 9c       	mov	r12,r6
8000bc0e:	ae 68       	st.h	r7[0xc],r8
8000bc10:	c1 cc       	rcall	8000bc48 <_write_r>
8000bc12:	d8 22       	popm	r4-r7,pc

8000bc14 <__sread>:
8000bc14:	d4 21       	pushm	r4-r7,lr
8000bc16:	16 97       	mov	r7,r11
8000bc18:	96 7b       	ld.sh	r11,r11[0xe]
8000bc1a:	cf 1c       	rcall	8000bdfc <_read_r>
8000bc1c:	c0 65       	brlt	8000bc28 <__sread+0x14>
8000bc1e:	6f 58       	ld.w	r8,r7[0x54]
8000bc20:	18 08       	add	r8,r12
8000bc22:	ef 48 00 54 	st.w	r7[84],r8
8000bc26:	d8 22       	popm	r4-r7,pc
8000bc28:	8e 68       	ld.sh	r8,r7[0xc]
8000bc2a:	ad c8       	cbr	r8,0xc
8000bc2c:	ae 68       	st.h	r7[0xc],r8
8000bc2e:	d8 22       	popm	r4-r7,pc

8000bc30 <strlen>:
8000bc30:	30 09       	mov	r9,0
8000bc32:	18 98       	mov	r8,r12
8000bc34:	c0 28       	rjmp	8000bc38 <strlen+0x8>
8000bc36:	2f f8       	sub	r8,-1
8000bc38:	11 8a       	ld.ub	r10,r8[0x0]
8000bc3a:	f2 0a 18 00 	cp.b	r10,r9
8000bc3e:	cf c1       	brne	8000bc36 <strlen+0x6>
8000bc40:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc44:	5e fc       	retal	r12
8000bc46:	d7 03       	nop

8000bc48 <_write_r>:
8000bc48:	d4 21       	pushm	r4-r7,lr
8000bc4a:	16 98       	mov	r8,r11
8000bc4c:	18 97       	mov	r7,r12
8000bc4e:	10 9c       	mov	r12,r8
8000bc50:	30 08       	mov	r8,0
8000bc52:	14 9b       	mov	r11,r10
8000bc54:	e0 66 53 54 	mov	r6,21332
8000bc58:	12 9a       	mov	r10,r9
8000bc5a:	8d 08       	st.w	r6[0x0],r8
8000bc5c:	fe b0 d1 66 	rcall	80005f28 <_write>
8000bc60:	5b fc       	cp.w	r12,-1
8000bc62:	c0 51       	brne	8000bc6c <_write_r+0x24>
8000bc64:	6c 08       	ld.w	r8,r6[0x0]
8000bc66:	58 08       	cp.w	r8,0
8000bc68:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc6c:	d8 22       	popm	r4-r7,pc
8000bc6e:	d7 03       	nop

8000bc70 <_calloc_r>:
8000bc70:	d4 21       	pushm	r4-r7,lr
8000bc72:	f4 0b 02 4b 	mul	r11,r10,r11
8000bc76:	fe b0 db 7f 	rcall	80007374 <_malloc_r>
8000bc7a:	18 97       	mov	r7,r12
8000bc7c:	c2 30       	breq	8000bcc2 <_calloc_r+0x52>
8000bc7e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bc82:	e0 1a ff fc 	andl	r10,0xfffc
8000bc86:	20 4a       	sub	r10,4
8000bc88:	e0 4a 00 24 	cp.w	r10,36
8000bc8c:	e0 8b 00 18 	brhi	8000bcbc <_calloc_r+0x4c>
8000bc90:	18 98       	mov	r8,r12
8000bc92:	59 3a       	cp.w	r10,19
8000bc94:	e0 88 00 0f 	brls	8000bcb2 <_calloc_r+0x42>
8000bc98:	30 09       	mov	r9,0
8000bc9a:	10 a9       	st.w	r8++,r9
8000bc9c:	10 a9       	st.w	r8++,r9
8000bc9e:	59 ba       	cp.w	r10,27
8000bca0:	e0 88 00 09 	brls	8000bcb2 <_calloc_r+0x42>
8000bca4:	10 a9       	st.w	r8++,r9
8000bca6:	10 a9       	st.w	r8++,r9
8000bca8:	e0 4a 00 24 	cp.w	r10,36
8000bcac:	c0 31       	brne	8000bcb2 <_calloc_r+0x42>
8000bcae:	10 a9       	st.w	r8++,r9
8000bcb0:	10 a9       	st.w	r8++,r9
8000bcb2:	30 09       	mov	r9,0
8000bcb4:	10 a9       	st.w	r8++,r9
8000bcb6:	91 19       	st.w	r8[0x4],r9
8000bcb8:	91 09       	st.w	r8[0x0],r9
8000bcba:	c0 48       	rjmp	8000bcc2 <_calloc_r+0x52>
8000bcbc:	30 0b       	mov	r11,0
8000bcbe:	fe b0 de 1b 	rcall	800078f4 <memset>
8000bcc2:	0e 9c       	mov	r12,r7
8000bcc4:	d8 22       	popm	r4-r7,pc
8000bcc6:	d7 03       	nop

8000bcc8 <_close_r>:
8000bcc8:	d4 21       	pushm	r4-r7,lr
8000bcca:	30 08       	mov	r8,0
8000bccc:	18 97       	mov	r7,r12
8000bcce:	e0 66 53 54 	mov	r6,21332
8000bcd2:	16 9c       	mov	r12,r11
8000bcd4:	8d 08       	st.w	r6[0x0],r8
8000bcd6:	fe b0 df b5 	rcall	80007c40 <_close>
8000bcda:	5b fc       	cp.w	r12,-1
8000bcdc:	c0 51       	brne	8000bce6 <_close_r+0x1e>
8000bcde:	6c 08       	ld.w	r8,r6[0x0]
8000bce0:	58 08       	cp.w	r8,0
8000bce2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bce6:	d8 22       	popm	r4-r7,pc

8000bce8 <_fclose_r>:
8000bce8:	d4 21       	pushm	r4-r7,lr
8000bcea:	18 96       	mov	r6,r12
8000bcec:	16 97       	mov	r7,r11
8000bcee:	58 0b       	cp.w	r11,0
8000bcf0:	c0 31       	brne	8000bcf6 <_fclose_r+0xe>
8000bcf2:	16 95       	mov	r5,r11
8000bcf4:	c5 38       	rjmp	8000bd9a <_fclose_r+0xb2>
8000bcf6:	fe b0 f8 a9 	rcall	8000ae48 <__sfp_lock_acquire>
8000bcfa:	58 06       	cp.w	r6,0
8000bcfc:	c0 70       	breq	8000bd0a <_fclose_r+0x22>
8000bcfe:	6c 68       	ld.w	r8,r6[0x18]
8000bd00:	58 08       	cp.w	r8,0
8000bd02:	c0 41       	brne	8000bd0a <_fclose_r+0x22>
8000bd04:	0c 9c       	mov	r12,r6
8000bd06:	fe b0 f8 f3 	rcall	8000aeec <__sinit>
8000bd0a:	fe c8 db d6 	sub	r8,pc,-9258
8000bd0e:	10 37       	cp.w	r7,r8
8000bd10:	c0 31       	brne	8000bd16 <_fclose_r+0x2e>
8000bd12:	6c 07       	ld.w	r7,r6[0x0]
8000bd14:	c0 c8       	rjmp	8000bd2c <_fclose_r+0x44>
8000bd16:	fe c8 db c2 	sub	r8,pc,-9278
8000bd1a:	10 37       	cp.w	r7,r8
8000bd1c:	c0 31       	brne	8000bd22 <_fclose_r+0x3a>
8000bd1e:	6c 17       	ld.w	r7,r6[0x4]
8000bd20:	c0 68       	rjmp	8000bd2c <_fclose_r+0x44>
8000bd22:	fe c8 db ae 	sub	r8,pc,-9298
8000bd26:	10 37       	cp.w	r7,r8
8000bd28:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bd2c:	8e 69       	ld.sh	r9,r7[0xc]
8000bd2e:	30 08       	mov	r8,0
8000bd30:	f0 09 19 00 	cp.h	r9,r8
8000bd34:	c0 51       	brne	8000bd3e <_fclose_r+0x56>
8000bd36:	fe b0 f8 8a 	rcall	8000ae4a <__sfp_lock_release>
8000bd3a:	30 05       	mov	r5,0
8000bd3c:	c2 f8       	rjmp	8000bd9a <_fclose_r+0xb2>
8000bd3e:	0e 9b       	mov	r11,r7
8000bd40:	0c 9c       	mov	r12,r6
8000bd42:	fe b0 f7 fd 	rcall	8000ad3c <_fflush_r>
8000bd46:	6e c8       	ld.w	r8,r7[0x30]
8000bd48:	18 95       	mov	r5,r12
8000bd4a:	58 08       	cp.w	r8,0
8000bd4c:	c0 60       	breq	8000bd58 <_fclose_r+0x70>
8000bd4e:	6e 8b       	ld.w	r11,r7[0x20]
8000bd50:	0c 9c       	mov	r12,r6
8000bd52:	5d 18       	icall	r8
8000bd54:	f9 b5 05 ff 	movlt	r5,-1
8000bd58:	8e 68       	ld.sh	r8,r7[0xc]
8000bd5a:	ed b8 00 07 	bld	r8,0x7
8000bd5e:	c0 51       	brne	8000bd68 <_fclose_r+0x80>
8000bd60:	6e 4b       	ld.w	r11,r7[0x10]
8000bd62:	0c 9c       	mov	r12,r6
8000bd64:	fe b0 f9 5e 	rcall	8000b020 <_free_r>
8000bd68:	6e db       	ld.w	r11,r7[0x34]
8000bd6a:	58 0b       	cp.w	r11,0
8000bd6c:	c0 a0       	breq	8000bd80 <_fclose_r+0x98>
8000bd6e:	ee c8 ff bc 	sub	r8,r7,-68
8000bd72:	10 3b       	cp.w	r11,r8
8000bd74:	c0 40       	breq	8000bd7c <_fclose_r+0x94>
8000bd76:	0c 9c       	mov	r12,r6
8000bd78:	fe b0 f9 54 	rcall	8000b020 <_free_r>
8000bd7c:	30 08       	mov	r8,0
8000bd7e:	8f d8       	st.w	r7[0x34],r8
8000bd80:	6f 2b       	ld.w	r11,r7[0x48]
8000bd82:	58 0b       	cp.w	r11,0
8000bd84:	c0 70       	breq	8000bd92 <_fclose_r+0xaa>
8000bd86:	0c 9c       	mov	r12,r6
8000bd88:	fe b0 f9 4c 	rcall	8000b020 <_free_r>
8000bd8c:	30 08       	mov	r8,0
8000bd8e:	ef 48 00 48 	st.w	r7[72],r8
8000bd92:	30 08       	mov	r8,0
8000bd94:	ae 68       	st.h	r7[0xc],r8
8000bd96:	fe b0 f8 5a 	rcall	8000ae4a <__sfp_lock_release>
8000bd9a:	0a 9c       	mov	r12,r5
8000bd9c:	d8 22       	popm	r4-r7,pc
8000bd9e:	d7 03       	nop

8000bda0 <fclose>:
8000bda0:	d4 01       	pushm	lr
8000bda2:	e0 68 0a 3c 	mov	r8,2620
8000bda6:	18 9b       	mov	r11,r12
8000bda8:	70 0c       	ld.w	r12,r8[0x0]
8000bdaa:	c9 ff       	rcall	8000bce8 <_fclose_r>
8000bdac:	d8 02       	popm	pc
8000bdae:	d7 03       	nop

8000bdb0 <_fstat_r>:
8000bdb0:	d4 21       	pushm	r4-r7,lr
8000bdb2:	16 98       	mov	r8,r11
8000bdb4:	18 97       	mov	r7,r12
8000bdb6:	10 9c       	mov	r12,r8
8000bdb8:	30 08       	mov	r8,0
8000bdba:	e0 66 53 54 	mov	r6,21332
8000bdbe:	14 9b       	mov	r11,r10
8000bdc0:	8d 08       	st.w	r6[0x0],r8
8000bdc2:	fe b0 df 67 	rcall	80007c90 <_fstat>
8000bdc6:	5b fc       	cp.w	r12,-1
8000bdc8:	c0 51       	brne	8000bdd2 <_fstat_r+0x22>
8000bdca:	6c 08       	ld.w	r8,r6[0x0]
8000bdcc:	58 08       	cp.w	r8,0
8000bdce:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdd2:	d8 22       	popm	r4-r7,pc

8000bdd4 <_lseek_r>:
8000bdd4:	d4 21       	pushm	r4-r7,lr
8000bdd6:	16 98       	mov	r8,r11
8000bdd8:	18 97       	mov	r7,r12
8000bdda:	10 9c       	mov	r12,r8
8000bddc:	30 08       	mov	r8,0
8000bdde:	14 9b       	mov	r11,r10
8000bde0:	e0 66 53 54 	mov	r6,21332
8000bde4:	12 9a       	mov	r10,r9
8000bde6:	8d 08       	st.w	r6[0x0],r8
8000bde8:	fe b0 df 36 	rcall	80007c54 <_lseek>
8000bdec:	5b fc       	cp.w	r12,-1
8000bdee:	c0 51       	brne	8000bdf8 <_lseek_r+0x24>
8000bdf0:	6c 08       	ld.w	r8,r6[0x0]
8000bdf2:	58 08       	cp.w	r8,0
8000bdf4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdf8:	d8 22       	popm	r4-r7,pc
8000bdfa:	d7 03       	nop

8000bdfc <_read_r>:
8000bdfc:	d4 21       	pushm	r4-r7,lr
8000bdfe:	16 98       	mov	r8,r11
8000be00:	18 97       	mov	r7,r12
8000be02:	10 9c       	mov	r12,r8
8000be04:	30 08       	mov	r8,0
8000be06:	14 9b       	mov	r11,r10
8000be08:	e0 66 53 54 	mov	r6,21332
8000be0c:	12 9a       	mov	r10,r9
8000be0e:	8d 08       	st.w	r6[0x0],r8
8000be10:	fe b0 d0 6c 	rcall	80005ee8 <_read>
8000be14:	5b fc       	cp.w	r12,-1
8000be16:	c0 51       	brne	8000be20 <_read_r+0x24>
8000be18:	6c 08       	ld.w	r8,r6[0x0]
8000be1a:	58 08       	cp.w	r8,0
8000be1c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be20:	d8 22       	popm	r4-r7,pc
8000be22:	d7 03       	nop

8000be24 <__avr32_f64_mul>:
8000be24:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000be28:	e0 80 00 dc 	breq	8000bfe0 <__avr32_f64_mul_op1_zero>
8000be2c:	d4 21       	pushm	r4-r7,lr
8000be2e:	f7 e9 20 0e 	eor	lr,r11,r9
8000be32:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000be36:	30 15       	mov	r5,1
8000be38:	c4 30       	breq	8000bebe <__avr32_f64_mul_op1_subnormal>
8000be3a:	ab 6b       	lsl	r11,0xa
8000be3c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000be40:	ab 6a       	lsl	r10,0xa
8000be42:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000be46:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000be4a:	c5 c0       	breq	8000bf02 <__avr32_f64_mul_op2_subnormal>
8000be4c:	a1 78       	lsl	r8,0x1
8000be4e:	5c f9       	rol	r9
8000be50:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000be54:	e0 47 07 ff 	cp.w	r7,2047
8000be58:	c7 70       	breq	8000bf46 <__avr32_f64_mul_op_nan_or_inf>
8000be5a:	e0 46 07 ff 	cp.w	r6,2047
8000be5e:	c7 40       	breq	8000bf46 <__avr32_f64_mul_op_nan_or_inf>
8000be60:	ee 06 00 0c 	add	r12,r7,r6
8000be64:	e0 2c 03 fe 	sub	r12,1022
8000be68:	f6 08 06 44 	mulu.d	r4,r11,r8
8000be6c:	f4 09 07 44 	macu.d	r4,r10,r9
8000be70:	f4 08 06 46 	mulu.d	r6,r10,r8
8000be74:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000be78:	08 07       	add	r7,r4
8000be7a:	f4 05 00 4a 	adc	r10,r10,r5
8000be7e:	5c 0b       	acr	r11
8000be80:	ed bb 00 14 	bld	r11,0x14
8000be84:	c0 50       	breq	8000be8e <__avr32_f64_mul+0x6a>
8000be86:	a1 77       	lsl	r7,0x1
8000be88:	5c fa       	rol	r10
8000be8a:	5c fb       	rol	r11
8000be8c:	20 1c       	sub	r12,1
8000be8e:	58 0c       	cp.w	r12,0
8000be90:	e0 8a 00 6f 	brle	8000bf6e <__avr32_f64_mul_res_subnormal>
8000be94:	e0 4c 07 ff 	cp.w	r12,2047
8000be98:	e0 84 00 9c 	brge	8000bfd0 <__avr32_f64_mul_res_inf>
8000be9c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bea0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bea4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bea8:	ee 17 80 00 	eorh	r7,0x8000
8000beac:	f1 b7 04 20 	satu	r7,0x1
8000beb0:	0e 0a       	add	r10,r7
8000beb2:	5c 0b       	acr	r11
8000beb4:	ed be 00 1f 	bld	lr,0x1f
8000beb8:	ef bb 00 1f 	bst	r11,0x1f
8000bebc:	d8 22       	popm	r4-r7,pc

8000bebe <__avr32_f64_mul_op1_subnormal>:
8000bebe:	e4 1b 00 0f 	andh	r11,0xf
8000bec2:	f4 0c 12 00 	clz	r12,r10
8000bec6:	f6 06 12 00 	clz	r6,r11
8000beca:	f7 bc 03 e1 	sublo	r12,-31
8000bece:	f8 06 17 30 	movlo	r6,r12
8000bed2:	f7 b6 02 01 	subhs	r6,1
8000bed6:	e0 46 00 20 	cp.w	r6,32
8000beda:	c0 d4       	brge	8000bef4 <__avr32_f64_mul_op1_subnormal+0x36>
8000bedc:	ec 0c 11 20 	rsub	r12,r6,32
8000bee0:	f6 06 09 4b 	lsl	r11,r11,r6
8000bee4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bee8:	18 4b       	or	r11,r12
8000beea:	f4 06 09 4a 	lsl	r10,r10,r6
8000beee:	20 b6       	sub	r6,11
8000bef0:	0c 17       	sub	r7,r6
8000bef2:	ca ab       	rjmp	8000be46 <__avr32_f64_mul+0x22>
8000bef4:	f4 06 09 4b 	lsl	r11,r10,r6
8000bef8:	c6 40       	breq	8000bfc0 <__avr32_f64_mul_res_zero>
8000befa:	30 0a       	mov	r10,0
8000befc:	20 b6       	sub	r6,11
8000befe:	0c 17       	sub	r7,r6
8000bf00:	ca 3b       	rjmp	8000be46 <__avr32_f64_mul+0x22>

8000bf02 <__avr32_f64_mul_op2_subnormal>:
8000bf02:	e4 19 00 0f 	andh	r9,0xf
8000bf06:	f0 0c 12 00 	clz	r12,r8
8000bf0a:	f2 05 12 00 	clz	r5,r9
8000bf0e:	f7 bc 03 ea 	sublo	r12,-22
8000bf12:	f8 05 17 30 	movlo	r5,r12
8000bf16:	f7 b5 02 0a 	subhs	r5,10
8000bf1a:	e0 45 00 20 	cp.w	r5,32
8000bf1e:	c0 d4       	brge	8000bf38 <__avr32_f64_mul_op2_subnormal+0x36>
8000bf20:	ea 0c 11 20 	rsub	r12,r5,32
8000bf24:	f2 05 09 49 	lsl	r9,r9,r5
8000bf28:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bf2c:	18 49       	or	r9,r12
8000bf2e:	f0 05 09 48 	lsl	r8,r8,r5
8000bf32:	20 25       	sub	r5,2
8000bf34:	0a 16       	sub	r6,r5
8000bf36:	c8 fb       	rjmp	8000be54 <__avr32_f64_mul+0x30>
8000bf38:	f0 05 09 49 	lsl	r9,r8,r5
8000bf3c:	c4 20       	breq	8000bfc0 <__avr32_f64_mul_res_zero>
8000bf3e:	30 08       	mov	r8,0
8000bf40:	20 25       	sub	r5,2
8000bf42:	0a 16       	sub	r6,r5
8000bf44:	c8 8b       	rjmp	8000be54 <__avr32_f64_mul+0x30>

8000bf46 <__avr32_f64_mul_op_nan_or_inf>:
8000bf46:	e4 19 00 0f 	andh	r9,0xf
8000bf4a:	e4 1b 00 0f 	andh	r11,0xf
8000bf4e:	14 4b       	or	r11,r10
8000bf50:	10 49       	or	r9,r8
8000bf52:	e0 47 07 ff 	cp.w	r7,2047
8000bf56:	c0 91       	brne	8000bf68 <__avr32_f64_mul_op1_not_naninf>
8000bf58:	58 0b       	cp.w	r11,0
8000bf5a:	c3 81       	brne	8000bfca <__avr32_f64_mul_res_nan>
8000bf5c:	e0 46 07 ff 	cp.w	r6,2047
8000bf60:	c3 81       	brne	8000bfd0 <__avr32_f64_mul_res_inf>
8000bf62:	58 09       	cp.w	r9,0
8000bf64:	c3 60       	breq	8000bfd0 <__avr32_f64_mul_res_inf>
8000bf66:	c3 28       	rjmp	8000bfca <__avr32_f64_mul_res_nan>

8000bf68 <__avr32_f64_mul_op1_not_naninf>:
8000bf68:	58 09       	cp.w	r9,0
8000bf6a:	c3 30       	breq	8000bfd0 <__avr32_f64_mul_res_inf>
8000bf6c:	c2 f8       	rjmp	8000bfca <__avr32_f64_mul_res_nan>

8000bf6e <__avr32_f64_mul_res_subnormal>:
8000bf6e:	5c 3c       	neg	r12
8000bf70:	2f fc       	sub	r12,-1
8000bf72:	f1 bc 04 c0 	satu	r12,0x6
8000bf76:	e0 4c 00 20 	cp.w	r12,32
8000bf7a:	c1 14       	brge	8000bf9c <__avr32_f64_mul_res_subnormal+0x2e>
8000bf7c:	f8 08 11 20 	rsub	r8,r12,32
8000bf80:	0e 46       	or	r6,r7
8000bf82:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bf86:	f4 08 09 49 	lsl	r9,r10,r8
8000bf8a:	12 47       	or	r7,r9
8000bf8c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bf90:	f6 08 09 49 	lsl	r9,r11,r8
8000bf94:	12 4a       	or	r10,r9
8000bf96:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bf9a:	c8 3b       	rjmp	8000bea0 <__avr32_f64_mul+0x7c>
8000bf9c:	f8 08 11 20 	rsub	r8,r12,32
8000bfa0:	f9 b9 00 00 	moveq	r9,0
8000bfa4:	c0 30       	breq	8000bfaa <__avr32_f64_mul_res_subnormal+0x3c>
8000bfa6:	f6 08 09 49 	lsl	r9,r11,r8
8000bfaa:	0e 46       	or	r6,r7
8000bfac:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bfb0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bfb4:	f3 ea 10 07 	or	r7,r9,r10
8000bfb8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bfbc:	30 0b       	mov	r11,0
8000bfbe:	c7 1b       	rjmp	8000bea0 <__avr32_f64_mul+0x7c>

8000bfc0 <__avr32_f64_mul_res_zero>:
8000bfc0:	1c 9b       	mov	r11,lr
8000bfc2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfc6:	30 0a       	mov	r10,0
8000bfc8:	d8 22       	popm	r4-r7,pc

8000bfca <__avr32_f64_mul_res_nan>:
8000bfca:	3f fb       	mov	r11,-1
8000bfcc:	3f fa       	mov	r10,-1
8000bfce:	d8 22       	popm	r4-r7,pc

8000bfd0 <__avr32_f64_mul_res_inf>:
8000bfd0:	f0 6b 00 00 	mov	r11,-1048576
8000bfd4:	ed be 00 1f 	bld	lr,0x1f
8000bfd8:	ef bb 00 1f 	bst	r11,0x1f
8000bfdc:	30 0a       	mov	r10,0
8000bfde:	d8 22       	popm	r4-r7,pc

8000bfe0 <__avr32_f64_mul_op1_zero>:
8000bfe0:	f7 e9 20 0b 	eor	r11,r11,r9
8000bfe4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfe8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bfec:	e0 4c 07 ff 	cp.w	r12,2047
8000bff0:	5e 1c       	retne	r12
8000bff2:	3f fa       	mov	r10,-1
8000bff4:	3f fb       	mov	r11,-1
8000bff6:	5e fc       	retal	r12

8000bff8 <__avr32_f64_sub_from_add>:
8000bff8:	ee 19 80 00 	eorh	r9,0x8000

8000bffc <__avr32_f64_sub>:
8000bffc:	f7 e9 20 0c 	eor	r12,r11,r9
8000c000:	e0 86 00 ca 	brmi	8000c194 <__avr32_f64_add_from_sub>
8000c004:	eb cd 40 e0 	pushm	r5-r7,lr
8000c008:	16 9c       	mov	r12,r11
8000c00a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c00e:	bf db       	cbr	r11,0x1f
8000c010:	bf d9       	cbr	r9,0x1f
8000c012:	10 3a       	cp.w	r10,r8
8000c014:	f2 0b 13 00 	cpc	r11,r9
8000c018:	c0 92       	brcc	8000c02a <__avr32_f64_sub+0x2e>
8000c01a:	16 97       	mov	r7,r11
8000c01c:	12 9b       	mov	r11,r9
8000c01e:	0e 99       	mov	r9,r7
8000c020:	14 97       	mov	r7,r10
8000c022:	10 9a       	mov	r10,r8
8000c024:	0e 98       	mov	r8,r7
8000c026:	ee 1c 80 00 	eorh	r12,0x8000
8000c02a:	f6 07 16 14 	lsr	r7,r11,0x14
8000c02e:	ab 7b       	lsl	r11,0xb
8000c030:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c034:	ab 7a       	lsl	r10,0xb
8000c036:	bf bb       	sbr	r11,0x1f
8000c038:	f2 06 16 14 	lsr	r6,r9,0x14
8000c03c:	c4 40       	breq	8000c0c4 <__avr32_f64_sub_opL_subnormal>
8000c03e:	ab 79       	lsl	r9,0xb
8000c040:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c044:	ab 78       	lsl	r8,0xb
8000c046:	bf b9       	sbr	r9,0x1f

8000c048 <__avr32_f64_sub_opL_subnormal_done>:
8000c048:	e0 47 07 ff 	cp.w	r7,2047
8000c04c:	c4 f0       	breq	8000c0ea <__avr32_f64_sub_opH_nan_or_inf>
8000c04e:	0e 26       	rsub	r6,r7
8000c050:	c1 20       	breq	8000c074 <__avr32_f64_sub_shift_done>
8000c052:	ec 05 11 20 	rsub	r5,r6,32
8000c056:	e0 46 00 20 	cp.w	r6,32
8000c05a:	c7 c2       	brcc	8000c152 <__avr32_f64_sub_longshift>
8000c05c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c060:	f2 05 09 45 	lsl	r5,r9,r5
8000c064:	f0 06 0a 48 	lsr	r8,r8,r6
8000c068:	f2 06 0a 49 	lsr	r9,r9,r6
8000c06c:	0a 48       	or	r8,r5
8000c06e:	58 0e       	cp.w	lr,0
8000c070:	5f 1e       	srne	lr
8000c072:	1c 48       	or	r8,lr

8000c074 <__avr32_f64_sub_shift_done>:
8000c074:	10 1a       	sub	r10,r8
8000c076:	f6 09 01 4b 	sbc	r11,r11,r9
8000c07a:	f6 06 12 00 	clz	r6,r11
8000c07e:	c0 e0       	breq	8000c09a <__avr32_f64_sub_longnormalize_done>
8000c080:	c7 83       	brcs	8000c170 <__avr32_f64_sub_longnormalize>
8000c082:	ec 0e 11 20 	rsub	lr,r6,32
8000c086:	f6 06 09 4b 	lsl	r11,r11,r6
8000c08a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c08e:	1c 4b       	or	r11,lr
8000c090:	f4 06 09 4a 	lsl	r10,r10,r6
8000c094:	0c 17       	sub	r7,r6
8000c096:	e0 8a 00 39 	brle	8000c108 <__avr32_f64_sub_subnormal_result>

8000c09a <__avr32_f64_sub_longnormalize_done>:
8000c09a:	f4 09 15 15 	lsl	r9,r10,0x15
8000c09e:	ab 9a       	lsr	r10,0xb
8000c0a0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c0a4:	ab 9b       	lsr	r11,0xb
8000c0a6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0aa:	18 4b       	or	r11,r12

8000c0ac <__avr32_f64_sub_round>:
8000c0ac:	fc 17 80 00 	movh	r7,0x8000
8000c0b0:	ed ba 00 00 	bld	r10,0x0
8000c0b4:	f7 b7 01 ff 	subne	r7,-1
8000c0b8:	0e 39       	cp.w	r9,r7
8000c0ba:	5f 29       	srhs	r9
8000c0bc:	12 0a       	add	r10,r9
8000c0be:	5c 0b       	acr	r11
8000c0c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0c4 <__avr32_f64_sub_opL_subnormal>:
8000c0c4:	ab 79       	lsl	r9,0xb
8000c0c6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c0ca:	ab 78       	lsl	r8,0xb
8000c0cc:	f3 e8 10 0e 	or	lr,r9,r8
8000c0d0:	f9 b6 01 01 	movne	r6,1
8000c0d4:	ee 0e 11 00 	rsub	lr,r7,0
8000c0d8:	f9 b7 00 01 	moveq	r7,1
8000c0dc:	ef bb 00 1f 	bst	r11,0x1f
8000c0e0:	f7 ea 10 0e 	or	lr,r11,r10
8000c0e4:	f9 b7 00 00 	moveq	r7,0
8000c0e8:	cb 0b       	rjmp	8000c048 <__avr32_f64_sub_opL_subnormal_done>

8000c0ea <__avr32_f64_sub_opH_nan_or_inf>:
8000c0ea:	bf db       	cbr	r11,0x1f
8000c0ec:	f7 ea 10 0e 	or	lr,r11,r10
8000c0f0:	c0 81       	brne	8000c100 <__avr32_f64_sub_return_nan>
8000c0f2:	e0 46 07 ff 	cp.w	r6,2047
8000c0f6:	c0 50       	breq	8000c100 <__avr32_f64_sub_return_nan>
8000c0f8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c0fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c100 <__avr32_f64_sub_return_nan>:
8000c100:	3f fa       	mov	r10,-1
8000c102:	3f fb       	mov	r11,-1
8000c104:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c108 <__avr32_f64_sub_subnormal_result>:
8000c108:	5c 37       	neg	r7
8000c10a:	2f f7       	sub	r7,-1
8000c10c:	f1 b7 04 c0 	satu	r7,0x6
8000c110:	e0 47 00 20 	cp.w	r7,32
8000c114:	c1 14       	brge	8000c136 <__avr32_f64_sub_subnormal_result+0x2e>
8000c116:	ee 08 11 20 	rsub	r8,r7,32
8000c11a:	f4 08 09 49 	lsl	r9,r10,r8
8000c11e:	5f 16       	srne	r6
8000c120:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c124:	0c 4a       	or	r10,r6
8000c126:	f6 08 09 49 	lsl	r9,r11,r8
8000c12a:	f5 e9 10 0a 	or	r10,r10,r9
8000c12e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c132:	30 07       	mov	r7,0
8000c134:	cb 3b       	rjmp	8000c09a <__avr32_f64_sub_longnormalize_done>
8000c136:	ee 08 11 40 	rsub	r8,r7,64
8000c13a:	f6 08 09 49 	lsl	r9,r11,r8
8000c13e:	14 49       	or	r9,r10
8000c140:	5f 16       	srne	r6
8000c142:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c146:	0c 4a       	or	r10,r6
8000c148:	30 0b       	mov	r11,0
8000c14a:	30 07       	mov	r7,0
8000c14c:	ca 7b       	rjmp	8000c09a <__avr32_f64_sub_longnormalize_done>
8000c14e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c152 <__avr32_f64_sub_longshift>:
8000c152:	f1 b6 04 c0 	satu	r6,0x6
8000c156:	f0 0e 17 00 	moveq	lr,r8
8000c15a:	c0 40       	breq	8000c162 <__avr32_f64_sub_longshift+0x10>
8000c15c:	f2 05 09 4e 	lsl	lr,r9,r5
8000c160:	10 4e       	or	lr,r8
8000c162:	f2 06 0a 48 	lsr	r8,r9,r6
8000c166:	30 09       	mov	r9,0
8000c168:	58 0e       	cp.w	lr,0
8000c16a:	5f 1e       	srne	lr
8000c16c:	1c 48       	or	r8,lr
8000c16e:	c8 3b       	rjmp	8000c074 <__avr32_f64_sub_shift_done>

8000c170 <__avr32_f64_sub_longnormalize>:
8000c170:	f4 06 12 00 	clz	r6,r10
8000c174:	f9 b7 03 00 	movlo	r7,0
8000c178:	f9 b6 03 00 	movlo	r6,0
8000c17c:	f9 bc 03 00 	movlo	r12,0
8000c180:	f7 b6 02 e0 	subhs	r6,-32
8000c184:	f4 06 09 4b 	lsl	r11,r10,r6
8000c188:	30 0a       	mov	r10,0
8000c18a:	0c 17       	sub	r7,r6
8000c18c:	fe 9a ff be 	brle	8000c108 <__avr32_f64_sub_subnormal_result>
8000c190:	c8 5b       	rjmp	8000c09a <__avr32_f64_sub_longnormalize_done>
8000c192:	d7 03       	nop

8000c194 <__avr32_f64_add_from_sub>:
8000c194:	ee 19 80 00 	eorh	r9,0x8000

8000c198 <__avr32_f64_add>:
8000c198:	f7 e9 20 0c 	eor	r12,r11,r9
8000c19c:	fe 96 ff 2e 	brmi	8000bff8 <__avr32_f64_sub_from_add>
8000c1a0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c1a4:	16 9c       	mov	r12,r11
8000c1a6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c1aa:	bf db       	cbr	r11,0x1f
8000c1ac:	bf d9       	cbr	r9,0x1f
8000c1ae:	12 3b       	cp.w	r11,r9
8000c1b0:	c0 72       	brcc	8000c1be <__avr32_f64_add+0x26>
8000c1b2:	16 97       	mov	r7,r11
8000c1b4:	12 9b       	mov	r11,r9
8000c1b6:	0e 99       	mov	r9,r7
8000c1b8:	14 97       	mov	r7,r10
8000c1ba:	10 9a       	mov	r10,r8
8000c1bc:	0e 98       	mov	r8,r7
8000c1be:	30 0e       	mov	lr,0
8000c1c0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c1c4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c1c8:	b5 ab       	sbr	r11,0x14
8000c1ca:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c1ce:	c6 20       	breq	8000c292 <__avr32_f64_add_op2_subnormal>
8000c1d0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c1d4:	b5 a9       	sbr	r9,0x14
8000c1d6:	e0 47 07 ff 	cp.w	r7,2047
8000c1da:	c2 80       	breq	8000c22a <__avr32_f64_add_opH_nan_or_inf>
8000c1dc:	0e 26       	rsub	r6,r7
8000c1de:	c1 20       	breq	8000c202 <__avr32_f64_add_shift_done>
8000c1e0:	e0 46 00 36 	cp.w	r6,54
8000c1e4:	c1 52       	brcc	8000c20e <__avr32_f64_add_res_of_done>
8000c1e6:	ec 05 11 20 	rsub	r5,r6,32
8000c1ea:	e0 46 00 20 	cp.w	r6,32
8000c1ee:	c3 52       	brcc	8000c258 <__avr32_f64_add_longshift>
8000c1f0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c1f4:	f2 05 09 45 	lsl	r5,r9,r5
8000c1f8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c1fc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c200:	0a 48       	or	r8,r5

8000c202 <__avr32_f64_add_shift_done>:
8000c202:	10 0a       	add	r10,r8
8000c204:	f6 09 00 4b 	adc	r11,r11,r9
8000c208:	ed bb 00 15 	bld	r11,0x15
8000c20c:	c3 40       	breq	8000c274 <__avr32_f64_add_res_of>

8000c20e <__avr32_f64_add_res_of_done>:
8000c20e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c212:	18 4b       	or	r11,r12

8000c214 <__avr32_f64_add_round>:
8000c214:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c218:	18 4e       	or	lr,r12
8000c21a:	ee 1e 80 00 	eorh	lr,0x8000
8000c21e:	f1 be 04 20 	satu	lr,0x1
8000c222:	1c 0a       	add	r10,lr
8000c224:	5c 0b       	acr	r11
8000c226:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c22a <__avr32_f64_add_opH_nan_or_inf>:
8000c22a:	b5 cb       	cbr	r11,0x14
8000c22c:	f7 ea 10 0e 	or	lr,r11,r10
8000c230:	c1 01       	brne	8000c250 <__avr32_f64_add_return_nan>
8000c232:	e0 46 07 ff 	cp.w	r6,2047
8000c236:	c0 30       	breq	8000c23c <__avr32_f64_add_opL_nan_or_inf>
8000c238:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c23c <__avr32_f64_add_opL_nan_or_inf>:
8000c23c:	b5 c9       	cbr	r9,0x14
8000c23e:	f3 e8 10 0e 	or	lr,r9,r8
8000c242:	c0 71       	brne	8000c250 <__avr32_f64_add_return_nan>
8000c244:	30 0a       	mov	r10,0
8000c246:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c24a:	18 4b       	or	r11,r12
8000c24c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c250 <__avr32_f64_add_return_nan>:
8000c250:	3f fa       	mov	r10,-1
8000c252:	3f fb       	mov	r11,-1
8000c254:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c258 <__avr32_f64_add_longshift>:
8000c258:	f1 b6 04 c0 	satu	r6,0x6
8000c25c:	f0 0e 17 00 	moveq	lr,r8
8000c260:	c0 60       	breq	8000c26c <__avr32_f64_add_longshift+0x14>
8000c262:	f2 05 09 4e 	lsl	lr,r9,r5
8000c266:	58 08       	cp.w	r8,0
8000c268:	5f 18       	srne	r8
8000c26a:	10 4e       	or	lr,r8
8000c26c:	f2 06 0a 48 	lsr	r8,r9,r6
8000c270:	30 09       	mov	r9,0
8000c272:	cc 8b       	rjmp	8000c202 <__avr32_f64_add_shift_done>

8000c274 <__avr32_f64_add_res_of>:
8000c274:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c278:	a1 9b       	lsr	r11,0x1
8000c27a:	5d 0a       	ror	r10
8000c27c:	5d 0e       	ror	lr
8000c27e:	2f f7       	sub	r7,-1
8000c280:	e0 47 07 ff 	cp.w	r7,2047
8000c284:	f9 ba 00 00 	moveq	r10,0
8000c288:	f9 bb 00 00 	moveq	r11,0
8000c28c:	f9 be 00 00 	moveq	lr,0
8000c290:	cb fb       	rjmp	8000c20e <__avr32_f64_add_res_of_done>

8000c292 <__avr32_f64_add_op2_subnormal>:
8000c292:	30 16       	mov	r6,1
8000c294:	58 07       	cp.w	r7,0
8000c296:	ca 01       	brne	8000c1d6 <__avr32_f64_add+0x3e>
8000c298:	b5 cb       	cbr	r11,0x14
8000c29a:	10 0a       	add	r10,r8
8000c29c:	f6 09 00 4b 	adc	r11,r11,r9
8000c2a0:	18 4b       	or	r11,r12
8000c2a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c2a6:	d7 03       	nop

8000c2a8 <__avr32_f64_to_u32>:
8000c2a8:	58 0b       	cp.w	r11,0
8000c2aa:	5e 6d       	retmi	0

8000c2ac <__avr32_f64_to_s32>:
8000c2ac:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c2b0:	b5 9c       	lsr	r12,0x15
8000c2b2:	e0 2c 03 ff 	sub	r12,1023
8000c2b6:	5e 3d       	retlo	0
8000c2b8:	f8 0c 11 1f 	rsub	r12,r12,31
8000c2bc:	16 99       	mov	r9,r11
8000c2be:	ab 7b       	lsl	r11,0xb
8000c2c0:	bf bb       	sbr	r11,0x1f
8000c2c2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c2c6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c2ca:	a1 79       	lsl	r9,0x1
8000c2cc:	5e 2b       	reths	r11
8000c2ce:	5c 3b       	neg	r11
8000c2d0:	5e fb       	retal	r11

8000c2d2 <__avr32_u32_to_f64>:
8000c2d2:	f8 cb 00 00 	sub	r11,r12,0
8000c2d6:	30 0c       	mov	r12,0
8000c2d8:	c0 38       	rjmp	8000c2de <__avr32_s32_to_f64+0x4>

8000c2da <__avr32_s32_to_f64>:
8000c2da:	18 9b       	mov	r11,r12
8000c2dc:	5c 4b       	abs	r11
8000c2de:	30 0a       	mov	r10,0
8000c2e0:	5e 0b       	reteq	r11
8000c2e2:	d4 01       	pushm	lr
8000c2e4:	e0 69 04 1e 	mov	r9,1054
8000c2e8:	f6 08 12 00 	clz	r8,r11
8000c2ec:	c1 70       	breq	8000c31a <__avr32_s32_to_f64+0x40>
8000c2ee:	c0 c3       	brcs	8000c306 <__avr32_s32_to_f64+0x2c>
8000c2f0:	f0 0e 11 20 	rsub	lr,r8,32
8000c2f4:	f6 08 09 4b 	lsl	r11,r11,r8
8000c2f8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c2fc:	1c 4b       	or	r11,lr
8000c2fe:	f4 08 09 4a 	lsl	r10,r10,r8
8000c302:	10 19       	sub	r9,r8
8000c304:	c0 b8       	rjmp	8000c31a <__avr32_s32_to_f64+0x40>
8000c306:	f4 08 12 00 	clz	r8,r10
8000c30a:	f9 b8 03 00 	movlo	r8,0
8000c30e:	f7 b8 02 e0 	subhs	r8,-32
8000c312:	f4 08 09 4b 	lsl	r11,r10,r8
8000c316:	30 0a       	mov	r10,0
8000c318:	10 19       	sub	r9,r8
8000c31a:	58 09       	cp.w	r9,0
8000c31c:	e0 89 00 30 	brgt	8000c37c <__avr32_s32_to_f64+0xa2>
8000c320:	5c 39       	neg	r9
8000c322:	2f f9       	sub	r9,-1
8000c324:	e0 49 00 36 	cp.w	r9,54
8000c328:	c0 43       	brcs	8000c330 <__avr32_s32_to_f64+0x56>
8000c32a:	30 0b       	mov	r11,0
8000c32c:	30 0a       	mov	r10,0
8000c32e:	c2 68       	rjmp	8000c37a <__avr32_s32_to_f64+0xa0>
8000c330:	2f 69       	sub	r9,-10
8000c332:	f2 08 11 20 	rsub	r8,r9,32
8000c336:	e0 49 00 20 	cp.w	r9,32
8000c33a:	c0 b2       	brcc	8000c350 <__avr32_s32_to_f64+0x76>
8000c33c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c340:	f6 08 09 48 	lsl	r8,r11,r8
8000c344:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c348:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c34c:	10 4b       	or	r11,r8
8000c34e:	c0 88       	rjmp	8000c35e <__avr32_s32_to_f64+0x84>
8000c350:	f6 08 09 4e 	lsl	lr,r11,r8
8000c354:	14 4e       	or	lr,r10
8000c356:	16 9a       	mov	r10,r11
8000c358:	30 0b       	mov	r11,0
8000c35a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c35e:	ed ba 00 00 	bld	r10,0x0
8000c362:	c0 92       	brcc	8000c374 <__avr32_s32_to_f64+0x9a>
8000c364:	1c 7e       	tst	lr,lr
8000c366:	c0 41       	brne	8000c36e <__avr32_s32_to_f64+0x94>
8000c368:	ed ba 00 01 	bld	r10,0x1
8000c36c:	c0 42       	brcc	8000c374 <__avr32_s32_to_f64+0x9a>
8000c36e:	2f fa       	sub	r10,-1
8000c370:	f7 bb 02 ff 	subhs	r11,-1
8000c374:	5c fc       	rol	r12
8000c376:	5d 0b       	ror	r11
8000c378:	5d 0a       	ror	r10
8000c37a:	d8 02       	popm	pc
8000c37c:	e0 68 03 ff 	mov	r8,1023
8000c380:	ed ba 00 0b 	bld	r10,0xb
8000c384:	f7 b8 00 ff 	subeq	r8,-1
8000c388:	10 0a       	add	r10,r8
8000c38a:	5c 0b       	acr	r11
8000c38c:	f7 b9 03 fe 	sublo	r9,-2
8000c390:	e0 49 07 ff 	cp.w	r9,2047
8000c394:	c0 55       	brlt	8000c39e <__avr32_s32_to_f64+0xc4>
8000c396:	30 0a       	mov	r10,0
8000c398:	fc 1b ff e0 	movh	r11,0xffe0
8000c39c:	c0 c8       	rjmp	8000c3b4 <__floatsidf_return_op1>
8000c39e:	ed bb 00 1f 	bld	r11,0x1f
8000c3a2:	f7 b9 01 01 	subne	r9,1
8000c3a6:	ab 9a       	lsr	r10,0xb
8000c3a8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c3ac:	a1 7b       	lsl	r11,0x1
8000c3ae:	ab 9b       	lsr	r11,0xb
8000c3b0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c3b4 <__floatsidf_return_op1>:
8000c3b4:	a1 7c       	lsl	r12,0x1
8000c3b6:	5d 0b       	ror	r11
8000c3b8:	d8 02       	popm	pc

8000c3ba <__avr32_f64_cmp_eq>:
8000c3ba:	10 3a       	cp.w	r10,r8
8000c3bc:	f2 0b 13 00 	cpc	r11,r9
8000c3c0:	c0 80       	breq	8000c3d0 <__avr32_f64_cmp_eq+0x16>
8000c3c2:	a1 7b       	lsl	r11,0x1
8000c3c4:	a1 79       	lsl	r9,0x1
8000c3c6:	14 4b       	or	r11,r10
8000c3c8:	12 4b       	or	r11,r9
8000c3ca:	10 4b       	or	r11,r8
8000c3cc:	5e 0f       	reteq	1
8000c3ce:	5e fd       	retal	0
8000c3d0:	a1 7b       	lsl	r11,0x1
8000c3d2:	fc 1c ff e0 	movh	r12,0xffe0
8000c3d6:	58 0a       	cp.w	r10,0
8000c3d8:	f8 0b 13 00 	cpc	r11,r12
8000c3dc:	5e 8f       	retls	1
8000c3de:	5e fd       	retal	0

8000c3e0 <__avr32_f64_cmp_ge>:
8000c3e0:	1a de       	st.w	--sp,lr
8000c3e2:	1a d7       	st.w	--sp,r7
8000c3e4:	a1 7b       	lsl	r11,0x1
8000c3e6:	5f 3c       	srlo	r12
8000c3e8:	a1 79       	lsl	r9,0x1
8000c3ea:	5f 37       	srlo	r7
8000c3ec:	5c fc       	rol	r12
8000c3ee:	fc 1e ff e0 	movh	lr,0xffe0
8000c3f2:	58 0a       	cp.w	r10,0
8000c3f4:	fc 0b 13 00 	cpc	r11,lr
8000c3f8:	e0 8b 00 1d 	brhi	8000c432 <__avr32_f64_cmp_ge+0x52>
8000c3fc:	58 08       	cp.w	r8,0
8000c3fe:	fc 09 13 00 	cpc	r9,lr
8000c402:	e0 8b 00 18 	brhi	8000c432 <__avr32_f64_cmp_ge+0x52>
8000c406:	58 0b       	cp.w	r11,0
8000c408:	f5 ba 00 00 	subfeq	r10,0
8000c40c:	c1 50       	breq	8000c436 <__avr32_f64_cmp_ge+0x56>
8000c40e:	1b 07       	ld.w	r7,sp++
8000c410:	1b 0e       	ld.w	lr,sp++
8000c412:	58 3c       	cp.w	r12,3
8000c414:	c0 a0       	breq	8000c428 <__avr32_f64_cmp_ge+0x48>
8000c416:	58 1c       	cp.w	r12,1
8000c418:	c0 33       	brcs	8000c41e <__avr32_f64_cmp_ge+0x3e>
8000c41a:	5e 0f       	reteq	1
8000c41c:	5e 1d       	retne	0
8000c41e:	10 3a       	cp.w	r10,r8
8000c420:	f2 0b 13 00 	cpc	r11,r9
8000c424:	5e 2f       	reths	1
8000c426:	5e 3d       	retlo	0
8000c428:	14 38       	cp.w	r8,r10
8000c42a:	f6 09 13 00 	cpc	r9,r11
8000c42e:	5e 2f       	reths	1
8000c430:	5e 3d       	retlo	0
8000c432:	1b 07       	ld.w	r7,sp++
8000c434:	d8 0a       	popm	pc,r12=0
8000c436:	58 17       	cp.w	r7,1
8000c438:	5f 0c       	sreq	r12
8000c43a:	58 09       	cp.w	r9,0
8000c43c:	f5 b8 00 00 	subfeq	r8,0
8000c440:	1b 07       	ld.w	r7,sp++
8000c442:	1b 0e       	ld.w	lr,sp++
8000c444:	5e 0f       	reteq	1
8000c446:	5e fc       	retal	r12

8000c448 <__avr32_f64_cmp_lt>:
8000c448:	1a de       	st.w	--sp,lr
8000c44a:	1a d7       	st.w	--sp,r7
8000c44c:	a1 7b       	lsl	r11,0x1
8000c44e:	5f 3c       	srlo	r12
8000c450:	a1 79       	lsl	r9,0x1
8000c452:	5f 37       	srlo	r7
8000c454:	5c fc       	rol	r12
8000c456:	fc 1e ff e0 	movh	lr,0xffe0
8000c45a:	58 0a       	cp.w	r10,0
8000c45c:	fc 0b 13 00 	cpc	r11,lr
8000c460:	e0 8b 00 1d 	brhi	8000c49a <__avr32_f64_cmp_lt+0x52>
8000c464:	58 08       	cp.w	r8,0
8000c466:	fc 09 13 00 	cpc	r9,lr
8000c46a:	e0 8b 00 18 	brhi	8000c49a <__avr32_f64_cmp_lt+0x52>
8000c46e:	58 0b       	cp.w	r11,0
8000c470:	f5 ba 00 00 	subfeq	r10,0
8000c474:	c1 50       	breq	8000c49e <__avr32_f64_cmp_lt+0x56>
8000c476:	1b 07       	ld.w	r7,sp++
8000c478:	1b 0e       	ld.w	lr,sp++
8000c47a:	58 3c       	cp.w	r12,3
8000c47c:	c0 a0       	breq	8000c490 <__avr32_f64_cmp_lt+0x48>
8000c47e:	58 1c       	cp.w	r12,1
8000c480:	c0 33       	brcs	8000c486 <__avr32_f64_cmp_lt+0x3e>
8000c482:	5e 0d       	reteq	0
8000c484:	5e 1f       	retne	1
8000c486:	10 3a       	cp.w	r10,r8
8000c488:	f2 0b 13 00 	cpc	r11,r9
8000c48c:	5e 2d       	reths	0
8000c48e:	5e 3f       	retlo	1
8000c490:	14 38       	cp.w	r8,r10
8000c492:	f6 09 13 00 	cpc	r9,r11
8000c496:	5e 2d       	reths	0
8000c498:	5e 3f       	retlo	1
8000c49a:	1b 07       	ld.w	r7,sp++
8000c49c:	d8 0a       	popm	pc,r12=0
8000c49e:	58 17       	cp.w	r7,1
8000c4a0:	5f 1c       	srne	r12
8000c4a2:	58 09       	cp.w	r9,0
8000c4a4:	f5 b8 00 00 	subfeq	r8,0
8000c4a8:	1b 07       	ld.w	r7,sp++
8000c4aa:	1b 0e       	ld.w	lr,sp++
8000c4ac:	5e 0d       	reteq	0
8000c4ae:	5e fc       	retal	r12

8000c4b0 <__avr32_f64_div>:
8000c4b0:	eb cd 40 ff 	pushm	r0-r7,lr
8000c4b4:	f7 e9 20 0e 	eor	lr,r11,r9
8000c4b8:	f6 07 16 14 	lsr	r7,r11,0x14
8000c4bc:	a9 7b       	lsl	r11,0x9
8000c4be:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c4c2:	a9 7a       	lsl	r10,0x9
8000c4c4:	bd bb       	sbr	r11,0x1d
8000c4c6:	e4 1b 3f ff 	andh	r11,0x3fff
8000c4ca:	ab d7       	cbr	r7,0xb
8000c4cc:	e0 80 00 cc 	breq	8000c664 <__avr32_f64_div_round_subnormal+0x54>
8000c4d0:	e0 47 07 ff 	cp.w	r7,2047
8000c4d4:	e0 84 00 b5 	brge	8000c63e <__avr32_f64_div_round_subnormal+0x2e>
8000c4d8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c4dc:	a9 79       	lsl	r9,0x9
8000c4de:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c4e2:	a9 78       	lsl	r8,0x9
8000c4e4:	bd b9       	sbr	r9,0x1d
8000c4e6:	e4 19 3f ff 	andh	r9,0x3fff
8000c4ea:	ab d6       	cbr	r6,0xb
8000c4ec:	e0 80 00 e2 	breq	8000c6b0 <__avr32_f64_div_round_subnormal+0xa0>
8000c4f0:	e0 46 07 ff 	cp.w	r6,2047
8000c4f4:	e0 84 00 b2 	brge	8000c658 <__avr32_f64_div_round_subnormal+0x48>
8000c4f8:	0c 17       	sub	r7,r6
8000c4fa:	fe 37 fc 01 	sub	r7,-1023
8000c4fe:	fc 1c 80 00 	movh	r12,0x8000
8000c502:	f8 03 16 01 	lsr	r3,r12,0x1
8000c506:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c50a:	5c d4       	com	r4
8000c50c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c510:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c514:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c518:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c51c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c520:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c524:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c528:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c52c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c530:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c534:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c538:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c53c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c540:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c544:	e4 09 07 40 	macu.d	r0,r2,r9
8000c548:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c54c:	02 04       	add	r4,r1
8000c54e:	5c 05       	acr	r5
8000c550:	a3 65       	lsl	r5,0x2
8000c552:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c556:	a3 64       	lsl	r4,0x2
8000c558:	5c 34       	neg	r4
8000c55a:	f8 05 01 45 	sbc	r5,r12,r5
8000c55e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c562:	e4 05 07 40 	macu.d	r0,r2,r5
8000c566:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c56a:	02 04       	add	r4,r1
8000c56c:	5c 05       	acr	r5
8000c56e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c572:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c576:	e8 02 15 02 	lsl	r2,r4,0x2
8000c57a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c57e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c582:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c586:	02 04       	add	r4,r1
8000c588:	5c 05       	acr	r5
8000c58a:	a3 65       	lsl	r5,0x2
8000c58c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c590:	a3 64       	lsl	r4,0x2
8000c592:	5c 34       	neg	r4
8000c594:	f8 05 01 45 	sbc	r5,r12,r5
8000c598:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c59c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5a4:	02 04       	add	r4,r1
8000c5a6:	5c 05       	acr	r5
8000c5a8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5ac:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c5b0:	e8 02 15 02 	lsl	r2,r4,0x2
8000c5b4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c5b8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c5bc:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c5c0:	02 02       	add	r2,r1
8000c5c2:	5c 03       	acr	r3
8000c5c4:	ed b3 00 1c 	bld	r3,0x1c
8000c5c8:	c0 90       	breq	8000c5da <__avr32_f64_div+0x12a>
8000c5ca:	a1 72       	lsl	r2,0x1
8000c5cc:	5c f3       	rol	r3
8000c5ce:	20 17       	sub	r7,1
8000c5d0:	a3 9a       	lsr	r10,0x3
8000c5d2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c5d6:	a3 9b       	lsr	r11,0x3
8000c5d8:	c0 58       	rjmp	8000c5e2 <__avr32_f64_div+0x132>
8000c5da:	a5 8a       	lsr	r10,0x4
8000c5dc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c5e0:	a5 8b       	lsr	r11,0x4
8000c5e2:	58 07       	cp.w	r7,0
8000c5e4:	e0 8a 00 8b 	brle	8000c6fa <__avr32_f64_div_res_subnormal>
8000c5e8:	e0 12 ff 00 	andl	r2,0xff00
8000c5ec:	e8 12 00 80 	orl	r2,0x80
8000c5f0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5f4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5f8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c5fc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c600:	00 05       	add	r5,r0
8000c602:	f0 01 00 48 	adc	r8,r8,r1
8000c606:	5c 09       	acr	r9
8000c608:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c60c:	58 04       	cp.w	r4,0
8000c60e:	5c 25       	cpc	r5

8000c610 <__avr32_f64_div_round_subnormal>:
8000c610:	f4 08 13 00 	cpc	r8,r10
8000c614:	f6 09 13 00 	cpc	r9,r11
8000c618:	5f 36       	srlo	r6
8000c61a:	f8 06 17 00 	moveq	r6,r12
8000c61e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c622:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c626:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c62a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c62e:	ed be 00 1f 	bld	lr,0x1f
8000c632:	ef bb 00 1f 	bst	r11,0x1f
8000c636:	0c 0a       	add	r10,r6
8000c638:	5c 0b       	acr	r11
8000c63a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c63e:	e4 1b 00 0f 	andh	r11,0xf
8000c642:	14 4b       	or	r11,r10
8000c644:	e0 81 00 a7 	brne	8000c792 <__avr32_f64_div_res_subnormal+0x98>
8000c648:	f2 06 16 14 	lsr	r6,r9,0x14
8000c64c:	ab d6       	cbr	r6,0xb
8000c64e:	e0 46 07 ff 	cp.w	r6,2047
8000c652:	e0 81 00 a4 	brne	8000c79a <__avr32_f64_div_res_subnormal+0xa0>
8000c656:	c9 e8       	rjmp	8000c792 <__avr32_f64_div_res_subnormal+0x98>
8000c658:	e4 19 00 0f 	andh	r9,0xf
8000c65c:	10 49       	or	r9,r8
8000c65e:	e0 81 00 9a 	brne	8000c792 <__avr32_f64_div_res_subnormal+0x98>
8000c662:	c9 28       	rjmp	8000c786 <__avr32_f64_div_res_subnormal+0x8c>
8000c664:	a3 7b       	lsl	r11,0x3
8000c666:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c66a:	a3 7a       	lsl	r10,0x3
8000c66c:	f5 eb 10 04 	or	r4,r10,r11
8000c670:	e0 80 00 a0 	breq	8000c7b0 <__avr32_f64_div_op1_zero>
8000c674:	f6 04 12 00 	clz	r4,r11
8000c678:	c1 70       	breq	8000c6a6 <__avr32_f64_div_round_subnormal+0x96>
8000c67a:	c0 c3       	brcs	8000c692 <__avr32_f64_div_round_subnormal+0x82>
8000c67c:	e8 05 11 20 	rsub	r5,r4,32
8000c680:	f6 04 09 4b 	lsl	r11,r11,r4
8000c684:	f4 05 0a 45 	lsr	r5,r10,r5
8000c688:	0a 4b       	or	r11,r5
8000c68a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c68e:	08 17       	sub	r7,r4
8000c690:	c0 b8       	rjmp	8000c6a6 <__avr32_f64_div_round_subnormal+0x96>
8000c692:	f4 04 12 00 	clz	r4,r10
8000c696:	f9 b4 03 00 	movlo	r4,0
8000c69a:	f7 b4 02 e0 	subhs	r4,-32
8000c69e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c6a2:	30 0a       	mov	r10,0
8000c6a4:	08 17       	sub	r7,r4
8000c6a6:	a3 8a       	lsr	r10,0x2
8000c6a8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c6ac:	a3 8b       	lsr	r11,0x2
8000c6ae:	c1 1b       	rjmp	8000c4d0 <__avr32_f64_div+0x20>
8000c6b0:	a3 79       	lsl	r9,0x3
8000c6b2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c6b6:	a3 78       	lsl	r8,0x3
8000c6b8:	f3 e8 10 04 	or	r4,r9,r8
8000c6bc:	c6 f0       	breq	8000c79a <__avr32_f64_div_res_subnormal+0xa0>
8000c6be:	f2 04 12 00 	clz	r4,r9
8000c6c2:	c1 70       	breq	8000c6f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c6c4:	c0 c3       	brcs	8000c6dc <__avr32_f64_div_round_subnormal+0xcc>
8000c6c6:	e8 05 11 20 	rsub	r5,r4,32
8000c6ca:	f2 04 09 49 	lsl	r9,r9,r4
8000c6ce:	f0 05 0a 45 	lsr	r5,r8,r5
8000c6d2:	0a 49       	or	r9,r5
8000c6d4:	f0 04 09 48 	lsl	r8,r8,r4
8000c6d8:	08 16       	sub	r6,r4
8000c6da:	c0 b8       	rjmp	8000c6f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c6dc:	f0 04 12 00 	clz	r4,r8
8000c6e0:	f9 b4 03 00 	movlo	r4,0
8000c6e4:	f7 b4 02 e0 	subhs	r4,-32
8000c6e8:	f0 04 09 49 	lsl	r9,r8,r4
8000c6ec:	30 08       	mov	r8,0
8000c6ee:	08 16       	sub	r6,r4
8000c6f0:	a3 88       	lsr	r8,0x2
8000c6f2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c6f6:	a3 89       	lsr	r9,0x2
8000c6f8:	cf ca       	rjmp	8000c4f0 <__avr32_f64_div+0x40>

8000c6fa <__avr32_f64_div_res_subnormal>:
8000c6fa:	5c 37       	neg	r7
8000c6fc:	2f f7       	sub	r7,-1
8000c6fe:	f1 b7 04 c0 	satu	r7,0x6
8000c702:	e0 47 00 20 	cp.w	r7,32
8000c706:	c1 54       	brge	8000c730 <__avr32_f64_div_res_subnormal+0x36>
8000c708:	ee 06 11 20 	rsub	r6,r7,32
8000c70c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c710:	e6 06 09 4c 	lsl	r12,r3,r6
8000c714:	18 42       	or	r2,r12
8000c716:	e6 07 0a 43 	lsr	r3,r3,r7
8000c71a:	f4 06 09 41 	lsl	r1,r10,r6
8000c71e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c722:	f6 06 09 4c 	lsl	r12,r11,r6
8000c726:	18 4a       	or	r10,r12
8000c728:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c72c:	30 00       	mov	r0,0
8000c72e:	c1 58       	rjmp	8000c758 <__avr32_f64_div_res_subnormal+0x5e>
8000c730:	ee 06 11 20 	rsub	r6,r7,32
8000c734:	f9 b0 00 00 	moveq	r0,0
8000c738:	f9 bc 00 00 	moveq	r12,0
8000c73c:	c0 50       	breq	8000c746 <__avr32_f64_div_res_subnormal+0x4c>
8000c73e:	f4 06 09 40 	lsl	r0,r10,r6
8000c742:	f6 06 09 4c 	lsl	r12,r11,r6
8000c746:	e6 07 0a 42 	lsr	r2,r3,r7
8000c74a:	30 03       	mov	r3,0
8000c74c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c750:	18 41       	or	r1,r12
8000c752:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c756:	30 0b       	mov	r11,0
8000c758:	e0 12 ff 00 	andl	r2,0xff00
8000c75c:	e8 12 00 80 	orl	r2,0x80
8000c760:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c764:	e4 09 07 46 	macu.d	r6,r2,r9
8000c768:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c76c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c770:	0c 05       	add	r5,r6
8000c772:	f0 07 00 48 	adc	r8,r8,r7
8000c776:	5c 09       	acr	r9
8000c778:	30 07       	mov	r7,0
8000c77a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c77e:	00 34       	cp.w	r4,r0
8000c780:	e2 05 13 00 	cpc	r5,r1
8000c784:	c4 6b       	rjmp	8000c610 <__avr32_f64_div_round_subnormal>
8000c786:	1c 9b       	mov	r11,lr
8000c788:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c78c:	30 0a       	mov	r10,0
8000c78e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c792:	3f fb       	mov	r11,-1
8000c794:	30 0a       	mov	r10,0
8000c796:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c79a:	f5 eb 10 04 	or	r4,r10,r11
8000c79e:	c0 90       	breq	8000c7b0 <__avr32_f64_div_op1_zero>
8000c7a0:	1c 9b       	mov	r11,lr
8000c7a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c7a6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c7aa:	30 0a       	mov	r10,0
8000c7ac:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c7b0 <__avr32_f64_div_op1_zero>:
8000c7b0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c7b4:	ce f0       	breq	8000c792 <__avr32_f64_div_res_subnormal+0x98>
8000c7b6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c7ba:	e0 44 07 ff 	cp.w	r4,2047
8000c7be:	ce 41       	brne	8000c786 <__avr32_f64_div_res_subnormal+0x8c>
8000c7c0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c7c4:	ce 10       	breq	8000c786 <__avr32_f64_div_res_subnormal+0x8c>
8000c7c6:	ce 6b       	rjmp	8000c792 <__avr32_f64_div_res_subnormal+0x98>

8000c7c8 <__avr32_udiv64>:
8000c7c8:	d4 31       	pushm	r0-r7,lr
8000c7ca:	1a 97       	mov	r7,sp
8000c7cc:	20 3d       	sub	sp,12
8000c7ce:	10 9c       	mov	r12,r8
8000c7d0:	12 9e       	mov	lr,r9
8000c7d2:	14 93       	mov	r3,r10
8000c7d4:	58 09       	cp.w	r9,0
8000c7d6:	e0 81 00 bd 	brne	8000c950 <__avr32_udiv64+0x188>
8000c7da:	16 38       	cp.w	r8,r11
8000c7dc:	e0 88 00 40 	brls	8000c85c <__avr32_udiv64+0x94>
8000c7e0:	f0 08 12 00 	clz	r8,r8
8000c7e4:	c0 d0       	breq	8000c7fe <__avr32_udiv64+0x36>
8000c7e6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c7ea:	f0 09 11 20 	rsub	r9,r8,32
8000c7ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000c7f2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c7f6:	f4 08 09 43 	lsl	r3,r10,r8
8000c7fa:	f3 eb 10 0b 	or	r11,r9,r11
8000c7fe:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c802:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c806:	f6 0e 0d 00 	divu	r0,r11,lr
8000c80a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c80e:	00 99       	mov	r9,r0
8000c810:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c814:	e0 0a 02 48 	mul	r8,r0,r10
8000c818:	10 3b       	cp.w	r11,r8
8000c81a:	c0 a2       	brcc	8000c82e <__avr32_udiv64+0x66>
8000c81c:	20 19       	sub	r9,1
8000c81e:	18 0b       	add	r11,r12
8000c820:	18 3b       	cp.w	r11,r12
8000c822:	c0 63       	brcs	8000c82e <__avr32_udiv64+0x66>
8000c824:	10 3b       	cp.w	r11,r8
8000c826:	f7 b9 03 01 	sublo	r9,1
8000c82a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c82e:	f6 08 01 01 	sub	r1,r11,r8
8000c832:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c836:	e2 0e 0d 00 	divu	r0,r1,lr
8000c83a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c83e:	00 98       	mov	r8,r0
8000c840:	e0 0a 02 4a 	mul	r10,r0,r10
8000c844:	14 33       	cp.w	r3,r10
8000c846:	c0 82       	brcc	8000c856 <__avr32_udiv64+0x8e>
8000c848:	20 18       	sub	r8,1
8000c84a:	18 03       	add	r3,r12
8000c84c:	18 33       	cp.w	r3,r12
8000c84e:	c0 43       	brcs	8000c856 <__avr32_udiv64+0x8e>
8000c850:	14 33       	cp.w	r3,r10
8000c852:	f7 b8 03 01 	sublo	r8,1
8000c856:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c85a:	cd f8       	rjmp	8000ca18 <__avr32_udiv64+0x250>
8000c85c:	58 08       	cp.w	r8,0
8000c85e:	c0 51       	brne	8000c868 <__avr32_udiv64+0xa0>
8000c860:	30 19       	mov	r9,1
8000c862:	f2 08 0d 08 	divu	r8,r9,r8
8000c866:	10 9c       	mov	r12,r8
8000c868:	f8 06 12 00 	clz	r6,r12
8000c86c:	c0 41       	brne	8000c874 <__avr32_udiv64+0xac>
8000c86e:	18 1b       	sub	r11,r12
8000c870:	30 19       	mov	r9,1
8000c872:	c4 08       	rjmp	8000c8f2 <__avr32_udiv64+0x12a>
8000c874:	ec 01 11 20 	rsub	r1,r6,32
8000c878:	f4 01 0a 49 	lsr	r9,r10,r1
8000c87c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c880:	f6 06 09 48 	lsl	r8,r11,r6
8000c884:	f6 01 0a 41 	lsr	r1,r11,r1
8000c888:	f3 e8 10 08 	or	r8,r9,r8
8000c88c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c890:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c894:	e2 03 0d 00 	divu	r0,r1,r3
8000c898:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c89c:	00 9e       	mov	lr,r0
8000c89e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8a2:	e0 05 02 49 	mul	r9,r0,r5
8000c8a6:	12 3b       	cp.w	r11,r9
8000c8a8:	c0 a2       	brcc	8000c8bc <__avr32_udiv64+0xf4>
8000c8aa:	20 1e       	sub	lr,1
8000c8ac:	18 0b       	add	r11,r12
8000c8ae:	18 3b       	cp.w	r11,r12
8000c8b0:	c0 63       	brcs	8000c8bc <__avr32_udiv64+0xf4>
8000c8b2:	12 3b       	cp.w	r11,r9
8000c8b4:	f7 be 03 01 	sublo	lr,1
8000c8b8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8bc:	12 1b       	sub	r11,r9
8000c8be:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c8c2:	f6 03 0d 02 	divu	r2,r11,r3
8000c8c6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c8ca:	04 99       	mov	r9,r2
8000c8cc:	e4 05 02 4b 	mul	r11,r2,r5
8000c8d0:	16 38       	cp.w	r8,r11
8000c8d2:	c0 a2       	brcc	8000c8e6 <__avr32_udiv64+0x11e>
8000c8d4:	20 19       	sub	r9,1
8000c8d6:	18 08       	add	r8,r12
8000c8d8:	18 38       	cp.w	r8,r12
8000c8da:	c0 63       	brcs	8000c8e6 <__avr32_udiv64+0x11e>
8000c8dc:	16 38       	cp.w	r8,r11
8000c8de:	f7 b9 03 01 	sublo	r9,1
8000c8e2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c8e6:	f4 06 09 43 	lsl	r3,r10,r6
8000c8ea:	f0 0b 01 0b 	sub	r11,r8,r11
8000c8ee:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c8f2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c8f6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c8fa:	f6 06 0d 00 	divu	r0,r11,r6
8000c8fe:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c902:	00 9a       	mov	r10,r0
8000c904:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c908:	e0 0e 02 48 	mul	r8,r0,lr
8000c90c:	10 3b       	cp.w	r11,r8
8000c90e:	c0 a2       	brcc	8000c922 <__avr32_udiv64+0x15a>
8000c910:	20 1a       	sub	r10,1
8000c912:	18 0b       	add	r11,r12
8000c914:	18 3b       	cp.w	r11,r12
8000c916:	c0 63       	brcs	8000c922 <__avr32_udiv64+0x15a>
8000c918:	10 3b       	cp.w	r11,r8
8000c91a:	f7 ba 03 01 	sublo	r10,1
8000c91e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c922:	f6 08 01 01 	sub	r1,r11,r8
8000c926:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c92a:	e2 06 0d 00 	divu	r0,r1,r6
8000c92e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c932:	00 98       	mov	r8,r0
8000c934:	e0 0e 02 4b 	mul	r11,r0,lr
8000c938:	16 33       	cp.w	r3,r11
8000c93a:	c0 82       	brcc	8000c94a <__avr32_udiv64+0x182>
8000c93c:	20 18       	sub	r8,1
8000c93e:	18 03       	add	r3,r12
8000c940:	18 33       	cp.w	r3,r12
8000c942:	c0 43       	brcs	8000c94a <__avr32_udiv64+0x182>
8000c944:	16 33       	cp.w	r3,r11
8000c946:	f7 b8 03 01 	sublo	r8,1
8000c94a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c94e:	c6 98       	rjmp	8000ca20 <__avr32_udiv64+0x258>
8000c950:	16 39       	cp.w	r9,r11
8000c952:	e0 8b 00 65 	brhi	8000ca1c <__avr32_udiv64+0x254>
8000c956:	f2 09 12 00 	clz	r9,r9
8000c95a:	c0 b1       	brne	8000c970 <__avr32_udiv64+0x1a8>
8000c95c:	10 3a       	cp.w	r10,r8
8000c95e:	5f 2a       	srhs	r10
8000c960:	1c 3b       	cp.w	r11,lr
8000c962:	5f b8       	srhi	r8
8000c964:	10 4a       	or	r10,r8
8000c966:	f2 0a 18 00 	cp.b	r10,r9
8000c96a:	c5 90       	breq	8000ca1c <__avr32_udiv64+0x254>
8000c96c:	30 18       	mov	r8,1
8000c96e:	c5 98       	rjmp	8000ca20 <__avr32_udiv64+0x258>
8000c970:	f0 09 09 46 	lsl	r6,r8,r9
8000c974:	f2 03 11 20 	rsub	r3,r9,32
8000c978:	fc 09 09 4e 	lsl	lr,lr,r9
8000c97c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c980:	f6 09 09 4c 	lsl	r12,r11,r9
8000c984:	f4 03 0a 42 	lsr	r2,r10,r3
8000c988:	ef 46 ff f4 	st.w	r7[-12],r6
8000c98c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c990:	18 42       	or	r2,r12
8000c992:	f1 ee 10 0c 	or	r12,r8,lr
8000c996:	f8 01 16 10 	lsr	r1,r12,0x10
8000c99a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c99e:	e6 01 0d 04 	divu	r4,r3,r1
8000c9a2:	e4 03 16 10 	lsr	r3,r2,0x10
8000c9a6:	08 9e       	mov	lr,r4
8000c9a8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c9ac:	e8 06 02 48 	mul	r8,r4,r6
8000c9b0:	10 33       	cp.w	r3,r8
8000c9b2:	c0 a2       	brcc	8000c9c6 <__avr32_udiv64+0x1fe>
8000c9b4:	20 1e       	sub	lr,1
8000c9b6:	18 03       	add	r3,r12
8000c9b8:	18 33       	cp.w	r3,r12
8000c9ba:	c0 63       	brcs	8000c9c6 <__avr32_udiv64+0x1fe>
8000c9bc:	10 33       	cp.w	r3,r8
8000c9be:	f7 be 03 01 	sublo	lr,1
8000c9c2:	e7 dc e3 03 	addcs	r3,r3,r12
8000c9c6:	10 13       	sub	r3,r8
8000c9c8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c9cc:	e6 01 0d 00 	divu	r0,r3,r1
8000c9d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9d4:	00 98       	mov	r8,r0
8000c9d6:	e0 06 02 46 	mul	r6,r0,r6
8000c9da:	0c 3b       	cp.w	r11,r6
8000c9dc:	c0 a2       	brcc	8000c9f0 <__avr32_udiv64+0x228>
8000c9de:	20 18       	sub	r8,1
8000c9e0:	18 0b       	add	r11,r12
8000c9e2:	18 3b       	cp.w	r11,r12
8000c9e4:	c0 63       	brcs	8000c9f0 <__avr32_udiv64+0x228>
8000c9e6:	0c 3b       	cp.w	r11,r6
8000c9e8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9ec:	f7 b8 03 01 	sublo	r8,1
8000c9f0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c9f4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c9f8:	0c 1b       	sub	r11,r6
8000c9fa:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c9fe:	06 95       	mov	r5,r3
8000ca00:	16 35       	cp.w	r5,r11
8000ca02:	e0 8b 00 0a 	brhi	8000ca16 <__avr32_udiv64+0x24e>
8000ca06:	5f 0b       	sreq	r11
8000ca08:	f4 09 09 49 	lsl	r9,r10,r9
8000ca0c:	12 32       	cp.w	r2,r9
8000ca0e:	5f b9       	srhi	r9
8000ca10:	f7 e9 00 09 	and	r9,r11,r9
8000ca14:	c0 60       	breq	8000ca20 <__avr32_udiv64+0x258>
8000ca16:	20 18       	sub	r8,1
8000ca18:	30 09       	mov	r9,0
8000ca1a:	c0 38       	rjmp	8000ca20 <__avr32_udiv64+0x258>
8000ca1c:	30 09       	mov	r9,0
8000ca1e:	12 98       	mov	r8,r9
8000ca20:	10 9a       	mov	r10,r8
8000ca22:	12 93       	mov	r3,r9
8000ca24:	10 92       	mov	r2,r8
8000ca26:	12 9b       	mov	r11,r9
8000ca28:	2f dd       	sub	sp,-12
8000ca2a:	d8 32       	popm	r0-r7,pc

8000ca2c <__avr32_umod64>:
8000ca2c:	d4 31       	pushm	r0-r7,lr
8000ca2e:	1a 97       	mov	r7,sp
8000ca30:	20 3d       	sub	sp,12
8000ca32:	10 9c       	mov	r12,r8
8000ca34:	12 95       	mov	r5,r9
8000ca36:	14 9e       	mov	lr,r10
8000ca38:	16 91       	mov	r1,r11
8000ca3a:	16 96       	mov	r6,r11
8000ca3c:	58 09       	cp.w	r9,0
8000ca3e:	e0 81 00 81 	brne	8000cb40 <__avr32_umod64+0x114>
8000ca42:	16 38       	cp.w	r8,r11
8000ca44:	e0 88 00 12 	brls	8000ca68 <__avr32_umod64+0x3c>
8000ca48:	f0 08 12 00 	clz	r8,r8
8000ca4c:	c4 e0       	breq	8000cae8 <__avr32_umod64+0xbc>
8000ca4e:	f6 08 09 46 	lsl	r6,r11,r8
8000ca52:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca56:	f0 0b 11 20 	rsub	r11,r8,32
8000ca5a:	f4 08 09 4e 	lsl	lr,r10,r8
8000ca5e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ca62:	f7 e6 10 06 	or	r6,r11,r6
8000ca66:	c4 18       	rjmp	8000cae8 <__avr32_umod64+0xbc>
8000ca68:	58 08       	cp.w	r8,0
8000ca6a:	c0 51       	brne	8000ca74 <__avr32_umod64+0x48>
8000ca6c:	30 19       	mov	r9,1
8000ca6e:	f2 08 0d 08 	divu	r8,r9,r8
8000ca72:	10 9c       	mov	r12,r8
8000ca74:	f8 08 12 00 	clz	r8,r12
8000ca78:	c0 31       	brne	8000ca7e <__avr32_umod64+0x52>
8000ca7a:	18 16       	sub	r6,r12
8000ca7c:	c3 68       	rjmp	8000cae8 <__avr32_umod64+0xbc>
8000ca7e:	f0 03 11 20 	rsub	r3,r8,32
8000ca82:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ca86:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca8a:	ec 08 09 49 	lsl	r9,r6,r8
8000ca8e:	ec 03 0a 43 	lsr	r3,r6,r3
8000ca92:	f7 e9 10 09 	or	r9,r11,r9
8000ca96:	f8 05 16 10 	lsr	r5,r12,0x10
8000ca9a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca9e:	e6 05 0d 02 	divu	r2,r3,r5
8000caa2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000caa6:	ec 02 02 4b 	mul	r11,r6,r2
8000caaa:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000caae:	16 3e       	cp.w	lr,r11
8000cab0:	c0 72       	brcc	8000cabe <__avr32_umod64+0x92>
8000cab2:	18 0e       	add	lr,r12
8000cab4:	18 3e       	cp.w	lr,r12
8000cab6:	c0 43       	brcs	8000cabe <__avr32_umod64+0x92>
8000cab8:	16 3e       	cp.w	lr,r11
8000caba:	fd dc e3 0e 	addcs	lr,lr,r12
8000cabe:	fc 0b 01 03 	sub	r3,lr,r11
8000cac2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cac6:	e6 05 0d 02 	divu	r2,r3,r5
8000caca:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cace:	a5 36       	mul	r6,r2
8000cad0:	0c 39       	cp.w	r9,r6
8000cad2:	c0 72       	brcc	8000cae0 <__avr32_umod64+0xb4>
8000cad4:	18 09       	add	r9,r12
8000cad6:	18 39       	cp.w	r9,r12
8000cad8:	c0 43       	brcs	8000cae0 <__avr32_umod64+0xb4>
8000cada:	0c 39       	cp.w	r9,r6
8000cadc:	f3 dc e3 09 	addcs	r9,r9,r12
8000cae0:	f2 06 01 06 	sub	r6,r9,r6
8000cae4:	f4 08 09 4e 	lsl	lr,r10,r8
8000cae8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000caec:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000caf0:	ec 0a 0d 02 	divu	r2,r6,r10
8000caf4:	fc 09 16 10 	lsr	r9,lr,0x10
8000caf8:	ea 02 02 4b 	mul	r11,r5,r2
8000cafc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb00:	16 39       	cp.w	r9,r11
8000cb02:	c0 72       	brcc	8000cb10 <__avr32_umod64+0xe4>
8000cb04:	18 09       	add	r9,r12
8000cb06:	18 39       	cp.w	r9,r12
8000cb08:	c0 43       	brcs	8000cb10 <__avr32_umod64+0xe4>
8000cb0a:	16 39       	cp.w	r9,r11
8000cb0c:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb10:	f2 0b 01 0b 	sub	r11,r9,r11
8000cb14:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cb18:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cb1c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cb20:	ea 0a 02 4a 	mul	r10,r5,r10
8000cb24:	14 3e       	cp.w	lr,r10
8000cb26:	c0 72       	brcc	8000cb34 <__avr32_umod64+0x108>
8000cb28:	18 0e       	add	lr,r12
8000cb2a:	18 3e       	cp.w	lr,r12
8000cb2c:	c0 43       	brcs	8000cb34 <__avr32_umod64+0x108>
8000cb2e:	14 3e       	cp.w	lr,r10
8000cb30:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb34:	fc 0a 01 0a 	sub	r10,lr,r10
8000cb38:	30 0b       	mov	r11,0
8000cb3a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cb3e:	c7 b8       	rjmp	8000cc34 <__avr32_umod64+0x208>
8000cb40:	16 39       	cp.w	r9,r11
8000cb42:	e0 8b 00 79 	brhi	8000cc34 <__avr32_umod64+0x208>
8000cb46:	f2 09 12 00 	clz	r9,r9
8000cb4a:	c1 21       	brne	8000cb6e <__avr32_umod64+0x142>
8000cb4c:	10 3a       	cp.w	r10,r8
8000cb4e:	5f 2b       	srhs	r11
8000cb50:	0a 31       	cp.w	r1,r5
8000cb52:	5f ba       	srhi	r10
8000cb54:	f7 ea 10 0a 	or	r10,r11,r10
8000cb58:	f2 0a 18 00 	cp.b	r10,r9
8000cb5c:	c0 60       	breq	8000cb68 <__avr32_umod64+0x13c>
8000cb5e:	fc 08 01 0c 	sub	r12,lr,r8
8000cb62:	e2 05 01 46 	sbc	r6,r1,r5
8000cb66:	18 9e       	mov	lr,r12
8000cb68:	0c 9b       	mov	r11,r6
8000cb6a:	1c 9a       	mov	r10,lr
8000cb6c:	c6 48       	rjmp	8000cc34 <__avr32_umod64+0x208>
8000cb6e:	ea 09 09 4c 	lsl	r12,r5,r9
8000cb72:	f2 06 11 20 	rsub	r6,r9,32
8000cb76:	f6 09 09 4b 	lsl	r11,r11,r9
8000cb7a:	f0 09 09 42 	lsl	r2,r8,r9
8000cb7e:	ef 46 ff f4 	st.w	r7[-12],r6
8000cb82:	f0 06 0a 48 	lsr	r8,r8,r6
8000cb86:	18 48       	or	r8,r12
8000cb88:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cb8c:	f4 09 09 43 	lsl	r3,r10,r9
8000cb90:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cb94:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cb98:	16 4a       	or	r10,r11
8000cb9a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cb9e:	f8 0b 0d 04 	divu	r4,r12,r11
8000cba2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cba6:	08 91       	mov	r1,r4
8000cba8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cbac:	e8 0e 02 46 	mul	r6,r4,lr
8000cbb0:	0c 3c       	cp.w	r12,r6
8000cbb2:	c0 a2       	brcc	8000cbc6 <__avr32_umod64+0x19a>
8000cbb4:	20 11       	sub	r1,1
8000cbb6:	10 0c       	add	r12,r8
8000cbb8:	10 3c       	cp.w	r12,r8
8000cbba:	c0 63       	brcs	8000cbc6 <__avr32_umod64+0x19a>
8000cbbc:	0c 3c       	cp.w	r12,r6
8000cbbe:	f7 b1 03 01 	sublo	r1,1
8000cbc2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cbc6:	0c 1c       	sub	r12,r6
8000cbc8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cbcc:	f8 0b 0d 04 	divu	r4,r12,r11
8000cbd0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cbd4:	08 96       	mov	r6,r4
8000cbd6:	e8 0e 02 4e 	mul	lr,r4,lr
8000cbda:	1c 3b       	cp.w	r11,lr
8000cbdc:	c0 a2       	brcc	8000cbf0 <__avr32_umod64+0x1c4>
8000cbde:	20 16       	sub	r6,1
8000cbe0:	10 0b       	add	r11,r8
8000cbe2:	10 3b       	cp.w	r11,r8
8000cbe4:	c0 63       	brcs	8000cbf0 <__avr32_umod64+0x1c4>
8000cbe6:	1c 3b       	cp.w	r11,lr
8000cbe8:	f7 b6 03 01 	sublo	r6,1
8000cbec:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cbf0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cbf4:	1c 1b       	sub	r11,lr
8000cbf6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cbfa:	00 9e       	mov	lr,r0
8000cbfc:	02 9c       	mov	r12,r1
8000cbfe:	16 3c       	cp.w	r12,r11
8000cc00:	e0 8b 00 08 	brhi	8000cc10 <__avr32_umod64+0x1e4>
8000cc04:	5f 06       	sreq	r6
8000cc06:	06 30       	cp.w	r0,r3
8000cc08:	5f ba       	srhi	r10
8000cc0a:	ed ea 00 0a 	and	r10,r6,r10
8000cc0e:	c0 60       	breq	8000cc1a <__avr32_umod64+0x1ee>
8000cc10:	fc 02 01 04 	sub	r4,lr,r2
8000cc14:	f8 08 01 4c 	sbc	r12,r12,r8
8000cc18:	08 9e       	mov	lr,r4
8000cc1a:	e6 0e 01 0a 	sub	r10,r3,lr
8000cc1e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cc22:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cc26:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cc2a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cc2e:	f8 01 09 4c 	lsl	r12,r12,r1
8000cc32:	18 4a       	or	r10,r12
8000cc34:	2f dd       	sub	sp,-12
8000cc36:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 71 78 	sub	pc,pc,29048

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 5f 	rcall	800055c4 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 58 	rcall	800055c4 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 51 	rcall	800055c4 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 4a 	rcall	800055c4 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
